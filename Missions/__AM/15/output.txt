// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35089 0 0
// InitNature ;
  19: CALL 34813 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11072 0 0
// PrepareRussian ;
  40: CALL 6956 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14966 0 0
// MC_Start ( ) ;
  60: CALL 37201 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 137
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 138
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59462 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59555 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58905 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58720 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59462 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59555 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58720 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58905 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59335 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58402 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59462 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59555 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 142
 955: PUSH
 956: LD_EXP 142
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58720 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59462 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59555 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58612 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59873 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 59044 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59335 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59335 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59667 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58720 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59286 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 65112 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 69936 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 69936 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 69936 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 69936 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 69936 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 65112 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 65112 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 65112 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 65112 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 65112 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 65112 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 65112 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 65112 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 65112 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 65112 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 65112 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 65112 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 65112 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 65112 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 65112 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 65112 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 65112 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 65112 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 65112 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 65112 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 65112 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 65112 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 65112 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 65112 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 65112 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 65112 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 65112 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 65112 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 18 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 18
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 18 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 18
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 6
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 61
4021: PPUSH
4022: LD_INT 89
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 69936 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 65112 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 65112 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 65112 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4448: LD_EXP 61
4452: PPUSH
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 10
4458: PPUSH
4459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_INT 22
4470: PUSH
4471: LD_VAR 0 3
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PUSH
4480: LD_INT 30
4482: PUSH
4483: LD_INT 32
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: PUSH
4490: LD_INT 58
4492: PUSH
4493: EMPTY
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: PPUSH
4501: CALL_OW 69
4505: ST_TO_ADDR
// for i = 1 to 10 do
4506: LD_ADDR_VAR 0 2
4510: PUSH
4511: DOUBLE
4512: LD_INT 1
4514: DEC
4515: ST_TO_ADDR
4516: LD_INT 10
4518: PUSH
4519: FOR_TO
4520: IFFALSE 4592
// begin uc_nation := nation_nature ;
4522: LD_ADDR_OWVAR 21
4526: PUSH
4527: LD_INT 0
4529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4530: LD_ADDR_OWVAR 28
4534: PUSH
4535: LD_INT 15
4537: ST_TO_ADDR
// hc_gallery :=  ;
4538: LD_ADDR_OWVAR 33
4542: PUSH
4543: LD_STRING 
4545: ST_TO_ADDR
// hc_name :=  ;
4546: LD_ADDR_OWVAR 26
4550: PUSH
4551: LD_STRING 
4553: ST_TO_ADDR
// un := CreateHuman ;
4554: LD_ADDR_VAR 0 4
4558: PUSH
4559: CALL_OW 44
4563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4564: LD_VAR 0 4
4568: PPUSH
4569: LD_VAR 0 5
4573: PUSH
4574: LD_VAR 0 5
4578: PUSH
4579: LD_VAR 0 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 52
// end ;
4590: GO 4519
4592: POP
4593: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4594: LD_ADDR_VAR 0 5
4598: PUSH
4599: LD_STRING 12_kurt_squad
4601: PPUSH
4602: CALL_OW 31
4606: ST_TO_ADDR
// if tmp then
4607: LD_VAR 0 5
4611: IFFALSE 4645
// for i in tmp do
4613: LD_ADDR_VAR 0 2
4617: PUSH
4618: LD_VAR 0 5
4622: PUSH
4623: FOR_IN
4624: IFFALSE 4643
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4626: LD_VAR 0 2
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 0
4636: PPUSH
4637: CALL_OW 49
4641: GO 4623
4643: POP
4644: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4645: LD_INT 324
4647: PPUSH
4648: LD_INT 5
4650: PPUSH
4651: LD_STRING 
4653: PPUSH
4654: LD_INT 8
4656: PUSH
4657: LD_INT 9
4659: PUSH
4660: LD_INT 10
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: LD_OWVAR 67
4672: ARRAY
4673: PPUSH
4674: LD_INT 3000
4676: PUSH
4677: LD_INT 500
4679: PUSH
4680: LD_INT 150
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: LIST
4687: PPUSH
4688: LD_INT 16
4690: PUSH
4691: LD_INT 6
4693: PUSH
4694: LD_INT 6
4696: PUSH
4697: LD_INT 8
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PPUSH
4706: CALL 73345 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4710: LD_ADDR_EXP 113
4714: PUSH
4715: LD_EXP 113
4719: PPUSH
4720: LD_INT 3
4722: PPUSH
4723: LD_INT 22
4725: PUSH
4726: LD_VAR 0 3
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 23
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 3
4747: PUSH
4748: LD_INT 21
4750: PUSH
4751: LD_INT 2
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: LIST
4766: PPUSH
4767: CALL_OW 69
4771: PUSH
4772: LD_EXP 60
4776: DIFF
4777: PPUSH
4778: CALL_OW 1
4782: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 7
4788: PPUSH
4789: CALL_OW 383
// Friend := CreateHuman ;
4793: LD_ADDR_EXP 62
4797: PUSH
4798: CALL_OW 44
4802: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4803: LD_INT 14
4805: PPUSH
4806: LD_INT 3
4808: PPUSH
4809: LD_INT 1
4811: PPUSH
4812: LD_INT 29
4814: PPUSH
4815: LD_INT 100
4817: PPUSH
4818: CALL 69936 0 5
// powellBomb := CreateVehicle ;
4822: LD_ADDR_EXP 63
4826: PUSH
4827: CALL_OW 45
4831: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4832: LD_EXP 63
4836: PPUSH
4837: LD_INT 90
4839: PPUSH
4840: LD_INT 51
4842: PPUSH
4843: LD_INT 0
4845: PPUSH
4846: CALL_OW 48
// end ;
4850: LD_VAR 0 1
4854: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4855: LD_INT 0
4857: PPUSH
4858: PPUSH
4859: PPUSH
// if IsLive ( kozlov_fac ) then
4860: LD_INT 332
4862: PPUSH
4863: CALL_OW 300
4867: IFFALSE 4871
// exit ;
4869: GO 5438
// ComExitBuilding ( Kozlov ) ;
4871: LD_EXP 61
4875: PPUSH
4876: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4880: LD_EXP 61
4884: PPUSH
4885: CALL_OW 257
4889: PUSH
4890: LD_INT 2
4892: NONEQUAL
4893: IFFALSE 4928
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4895: LD_EXP 61
4899: PPUSH
4900: LD_INT 324
4902: PPUSH
4903: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4907: LD_EXP 61
4911: PPUSH
4912: LD_INT 2
4914: PPUSH
4915: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4919: LD_EXP 61
4923: PPUSH
4924: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4928: LD_EXP 61
4932: PPUSH
4933: LD_INT 2
4935: PPUSH
4936: LD_INT 93
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4949: LD_INT 35
4951: PPUSH
4952: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4956: LD_INT 22
4958: PUSH
4959: LD_INT 8
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 30
4968: PUSH
4969: LD_INT 3
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: LD_INT 23
4978: PUSH
4979: LD_INT 3
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PUSH
4986: LD_INT 57
4988: PUSH
4989: EMPTY
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: IFFALSE 4949
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 8
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 3
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: LD_INT 23
5031: PUSH
5032: LD_INT 3
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 57
5041: PUSH
5042: EMPTY
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 1
5058: ARRAY
5059: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5060: LD_INT 22
5062: PUSH
5063: LD_INT 8
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 23
5072: PUSH
5073: LD_INT 3
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 30
5082: PUSH
5083: LD_INT 21
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 69
5099: NOT
5100: IFFALSE 5178
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5102: LD_EXP 61
5106: PPUSH
5107: LD_INT 21
5109: PPUSH
5110: LD_INT 97
5112: PPUSH
5113: LD_INT 36
5115: PPUSH
5116: LD_INT 5
5118: PPUSH
5119: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5130: LD_INT 22
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 23
5142: PUSH
5143: LD_INT 3
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 30
5152: PUSH
5153: LD_INT 21
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 57
5162: PUSH
5163: EMPTY
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: PPUSH
5172: CALL_OW 69
5176: IFFALSE 5123
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5178: LD_INT 22
5180: PUSH
5181: LD_INT 8
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: PUSH
5188: LD_INT 23
5190: PUSH
5191: LD_INT 3
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 30
5200: PUSH
5201: LD_INT 18
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 69
5217: NOT
5218: IFFALSE 5296
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5220: LD_EXP 61
5224: PPUSH
5225: LD_INT 18
5227: PPUSH
5228: LD_INT 89
5230: PPUSH
5231: LD_INT 32
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5241: LD_INT 35
5243: PPUSH
5244: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5248: LD_INT 22
5250: PUSH
5251: LD_INT 8
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: LD_INT 23
5260: PUSH
5261: LD_INT 3
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 30
5270: PUSH
5271: LD_INT 18
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: PUSH
5278: LD_INT 57
5280: PUSH
5281: EMPTY
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 69
5294: IFFALSE 5241
// end ; lab := kozlov_lab ;
5296: LD_ADDR_VAR 0 3
5300: PUSH
5301: LD_INT 336
5303: ST_TO_ADDR
// if not lab then
5304: LD_VAR 0 3
5308: NOT
5309: IFFALSE 5313
// exit ;
5311: GO 5438
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5313: LD_EXP 61
5317: PPUSH
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 1
5325: ARRAY
5326: PPUSH
5327: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5331: LD_EXP 61
5335: PPUSH
5336: LD_INT 4
5338: PPUSH
5339: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: LD_INT 25
5354: PPUSH
5355: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5359: LD_INT 35
5361: PPUSH
5362: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5366: LD_INT 25
5368: PPUSH
5369: LD_INT 8
5371: PPUSH
5372: CALL_OW 321
5376: PUSH
5377: LD_INT 2
5379: EQUAL
5380: IFFALSE 5359
// ComExitBuilding ( Kozlov ) ;
5382: LD_EXP 61
5386: PPUSH
5387: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5391: LD_EXP 61
5395: PPUSH
5396: LD_VAR 0 2
5400: PPUSH
5401: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5405: LD_EXP 61
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5417: LD_VAR 0 2
5421: PPUSH
5422: LD_INT 23
5424: PPUSH
5425: LD_INT 3
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: LD_INT 48
5433: PPUSH
5434: CALL_OW 125
// end ;
5438: LD_VAR 0 1
5442: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5443: LD_EXP 22
5447: NOT
5448: PUSH
5449: LD_EXP 15
5453: PUSH
5454: LD_INT 6
5456: GREATEREQUAL
5457: AND
5458: IFFALSE 5539
5460: GO 5462
5462: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5463: LD_INT 3
5465: PPUSH
5466: LD_INT 3
5468: PPUSH
5469: CALL 58905 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5473: LD_INT 3
5475: PPUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 14
5496: PUSH
5497: LD_INT 1
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 28
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_INT 14
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 28
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL 58768 0 2
// end ;
5539: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5540: LD_EXP 22
5544: NOT
5545: PUSH
5546: LD_EXP 15
5550: PUSH
5551: LD_INT 6
5553: GREATEREQUAL
5554: AND
5555: PUSH
5556: LD_INT 3
5558: PPUSH
5559: LD_INT 1
5561: PPUSH
5562: CALL 60186 0 2
5566: NOT
5567: AND
5568: IFFALSE 6408
5570: GO 5572
5572: DISABLE
5573: LD_INT 0
5575: PPUSH
5576: PPUSH
5577: PPUSH
// begin enable ;
5578: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5579: LD_INT 22
5581: PUSH
5582: LD_INT 8
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 23
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: PUSH
5599: LD_INT 30
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 69
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 6408
// if Prob ( 40 ) then
5623: LD_INT 40
5625: PPUSH
5626: CALL_OW 13
5630: IFFALSE 5757
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5632: LD_INT 3
5634: PPUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 28
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 14
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 28
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 14
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: LD_INT 26
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PPUSH
5751: CALL 58768 0 2
// end else
5755: GO 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5757: LD_INT 3
5759: PPUSH
5760: LD_INT 14
5762: PUSH
5763: LD_INT 1
5765: PUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 27
5771: PUSH
5772: LD_INT 26
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_OWVAR 67
5787: ARRAY
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 14
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 27
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_OWVAR 67
5822: ARRAY
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 14
5832: PUSH
5833: LD_INT 1
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 26
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: PUSH
5853: LD_OWVAR 67
5857: ARRAY
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: PUSH
5865: LD_INT 13
5867: PUSH
5868: LD_INT 1
5870: PUSH
5871: LD_INT 2
5873: PUSH
5874: LD_INT 26
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: LD_INT 29
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_OWVAR 67
5892: ARRAY
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 13
5902: PUSH
5903: LD_INT 1
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: LD_INT 29
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 14
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 2
5926: PUSH
5927: LD_INT 26
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL 58768 0 2
// end ; repeat wait ( 0 0$1 ) ;
5948: LD_INT 35
5950: PPUSH
5951: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5955: LD_INT 3
5957: PPUSH
5958: LD_INT 1
5960: PPUSH
5961: CALL 60186 0 2
5965: PUSH
5966: LD_INT 6
5968: GREATEREQUAL
5969: IFFALSE 5948
// wait ( 0 0$30 ) ;
5971: LD_INT 1050
5973: PPUSH
5974: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_INT 3
5985: PPUSH
5986: LD_INT 1
5988: PPUSH
5989: CALL 60186 0 2
5993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5994: LD_ADDR_EXP 132
5998: PUSH
5999: LD_EXP 132
6003: PPUSH
6004: LD_INT 3
6006: PPUSH
6007: LD_EXP 132
6011: PUSH
6012: LD_INT 3
6014: ARRAY
6015: PUSH
6016: LD_VAR 0 2
6020: DIFF
6021: PPUSH
6022: CALL_OW 1
6026: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6027: LD_ADDR_VAR 0 3
6031: PUSH
6032: LD_INT 0
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: CALL_OW 12
6042: ST_TO_ADDR
// if target then
6043: LD_VAR 0 3
6047: IFFALSE 6175
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6049: LD_ADDR_VAR 0 2
6053: PUSH
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 24
6061: PUSH
6062: LD_INT 250
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 72
6073: ST_TO_ADDR
// for i in tmp do
6074: LD_ADDR_VAR 0 1
6078: PUSH
6079: LD_VAR 0 2
6083: PUSH
6084: FOR_IN
6085: IFFALSE 6125
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6087: LD_VAR 0 1
6091: PPUSH
6092: LD_INT 89
6094: PPUSH
6095: LD_INT 71
6097: PPUSH
6098: CALL_OW 297
6102: PUSH
6103: LD_INT 9
6105: GREATER
6106: IFFALSE 6123
// ComMoveXY ( i , 89 , 71 ) ;
6108: LD_VAR 0 1
6112: PPUSH
6113: LD_INT 89
6115: PPUSH
6116: LD_INT 71
6118: PPUSH
6119: CALL_OW 111
6123: GO 6084
6125: POP
6126: POP
// wait ( 0 0$1 ) ;
6127: LD_INT 35
6129: PPUSH
6130: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: LD_INT 92
6141: PUSH
6142: LD_INT 89
6144: PUSH
6145: LD_INT 71
6147: PUSH
6148: LD_INT 9
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 72
6161: PUSH
6162: LD_VAR 0 2
6166: PUSH
6167: LD_INT 1
6169: MINUS
6170: GREATEREQUAL
6171: IFFALSE 6049
// end else
6173: GO 6299
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_VAR 0 2
6184: PPUSH
6185: LD_INT 24
6187: PUSH
6188: LD_INT 250
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 72
6199: ST_TO_ADDR
// for i in tmp do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_IN
6211: IFFALSE 6251
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6213: LD_VAR 0 1
6217: PPUSH
6218: LD_INT 125
6220: PPUSH
6221: LD_INT 129
6223: PPUSH
6224: CALL_OW 297
6228: PUSH
6229: LD_INT 9
6231: GREATER
6232: IFFALSE 6249
// ComMoveXY ( i , 125 , 129 ) ;
6234: LD_VAR 0 1
6238: PPUSH
6239: LD_INT 125
6241: PPUSH
6242: LD_INT 129
6244: PPUSH
6245: CALL_OW 111
6249: GO 6210
6251: POP
6252: POP
// wait ( 0 0$1 ) ;
6253: LD_INT 35
6255: PPUSH
6256: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 92
6267: PUSH
6268: LD_INT 125
6270: PUSH
6271: LD_INT 129
6273: PUSH
6274: LD_INT 9
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: PPUSH
6283: CALL_OW 72
6287: PUSH
6288: LD_VAR 0 2
6292: PUSH
6293: LD_INT 1
6295: MINUS
6296: GREATEREQUAL
6297: IFFALSE 6175
// end ; repeat wait ( 0 0$1 ) ;
6299: LD_INT 35
6301: PPUSH
6302: CALL_OW 67
// for i in tmp do
6306: LD_ADDR_VAR 0 1
6310: PUSH
6311: LD_VAR 0 2
6315: PUSH
6316: FOR_IN
6317: IFFALSE 6399
// begin if GetLives ( i ) > 251 then
6319: LD_VAR 0 1
6323: PPUSH
6324: CALL_OW 256
6328: PUSH
6329: LD_INT 251
6331: GREATER
6332: IFFALSE 6370
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6334: LD_VAR 0 1
6338: PPUSH
6339: LD_INT 81
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: PPUSH
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 74
6363: PPUSH
6364: CALL_OW 115
6368: GO 6397
// if IsDead ( i ) then
6370: LD_VAR 0 1
6374: PPUSH
6375: CALL_OW 301
6379: IFFALSE 6397
// tmp := tmp diff i ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PUSH
6391: LD_VAR 0 1
6395: DIFF
6396: ST_TO_ADDR
// end ;
6397: GO 6316
6399: POP
6400: POP
// until not tmp ;
6401: LD_VAR 0 2
6405: NOT
6406: IFFALSE 6299
// end ;
6408: PPOPN 3
6410: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6411: LD_EXP 22
6415: NOT
6416: PUSH
6417: LD_EXP 15
6421: PUSH
6422: LD_INT 6
6424: GREATEREQUAL
6425: AND
6426: PUSH
6427: LD_OWVAR 67
6431: PUSH
6432: LD_INT 1
6434: GREATER
6435: AND
6436: IFFALSE 6953
6438: GO 6440
6440: DISABLE
6441: LD_INT 0
6443: PPUSH
6444: PPUSH
6445: PPUSH
// begin enable ;
6446: ENABLE
// tmp := [ ] ;
6447: LD_ADDR_VAR 0 3
6451: PUSH
6452: EMPTY
6453: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6454: LD_ADDR_VAR 0 1
6458: PUSH
6459: DOUBLE
6460: LD_INT 1
6462: DEC
6463: ST_TO_ADDR
6464: LD_INT 4
6466: PUSH
6467: LD_INT 6
6469: PUSH
6470: LD_INT 7
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_OWVAR 67
6482: ARRAY
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6645
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6503: LD_INT 13
6505: PUSH
6506: LD_INT 14
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 2
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_INT 5
6530: PPUSH
6531: LD_INT 27
6533: PUSH
6534: LD_INT 28
6536: PUSH
6537: LD_INT 26
6539: PUSH
6540: LD_INT 25
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 1
6551: PPUSH
6552: LD_INT 4
6554: PPUSH
6555: CALL_OW 12
6559: ARRAY
6560: PPUSH
6561: LD_INT 88
6563: PPUSH
6564: CALL 69936 0 5
// un := CreateVehicle ;
6568: LD_ADDR_VAR 0 2
6572: PUSH
6573: CALL_OW 45
6577: ST_TO_ADDR
// tmp := tmp ^ un ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_VAR 0 3
6587: PUSH
6588: LD_VAR 0 2
6592: ADD
6593: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 3
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 30
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6621: LD_VAR 0 2
6625: PPUSH
6626: LD_INT 16
6628: PPUSH
6629: LD_INT 11
6631: PPUSH
6632: CALL_OW 111
// wait ( 0 0$2 ) ;
6636: LD_INT 70
6638: PPUSH
6639: CALL_OW 67
// end ;
6643: GO 6484
6645: POP
6646: POP
// for i = 1 to Difficulty do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_OWVAR 67
6661: PUSH
6662: FOR_TO
6663: IFFALSE 6788
// begin uc_side := 8 ;
6665: LD_ADDR_OWVAR 20
6669: PUSH
6670: LD_INT 8
6672: ST_TO_ADDR
// uc_nation := 2 ;
6673: LD_ADDR_OWVAR 21
6677: PUSH
6678: LD_INT 2
6680: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6681: LD_INT 0
6683: PPUSH
6684: LD_INT 8
6686: PPUSH
6687: LD_INT 8
6689: PUSH
6690: LD_INT 8
6692: PUSH
6693: LD_INT 9
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: LIST
6700: PUSH
6701: LD_OWVAR 67
6705: ARRAY
6706: PPUSH
6707: CALL_OW 380
// un := CreateHuman ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: CALL_OW 44
6720: ST_TO_ADDR
// tmp := tmp ^ un ;
6721: LD_ADDR_VAR 0 3
6725: PUSH
6726: LD_VAR 0 3
6730: PUSH
6731: LD_VAR 0 2
6735: ADD
6736: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6737: LD_VAR 0 2
6741: PPUSH
6742: LD_INT 3
6744: PPUSH
6745: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 30
6756: PPUSH
6757: LD_INT 0
6759: PPUSH
6760: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6764: LD_VAR 0 2
6768: PPUSH
6769: LD_INT 16
6771: PPUSH
6772: LD_INT 11
6774: PPUSH
6775: CALL_OW 111
// wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// end ;
6786: GO 6662
6788: POP
6789: POP
// repeat wait ( 0 0$1 ) ;
6790: LD_INT 35
6792: PPUSH
6793: CALL_OW 67
// for i in tmp do
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: FOR_IN
6808: IFFALSE 6944
// begin if GetLives ( i ) > 250 then
6810: LD_VAR 0 1
6814: PPUSH
6815: CALL_OW 256
6819: PUSH
6820: LD_INT 250
6822: GREATER
6823: IFFALSE 6915
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6825: LD_INT 81
6827: PUSH
6828: LD_INT 8
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 91
6837: PUSH
6838: LD_VAR 0 1
6842: PUSH
6843: LD_INT 10
6845: PUSH
6846: EMPTY
6847: LIST
6848: LIST
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: NOT
6860: IFFALSE 6879
// ComAgressiveMove ( i , 67 , 110 ) else
6862: LD_VAR 0 1
6866: PPUSH
6867: LD_INT 67
6869: PPUSH
6870: LD_INT 110
6872: PPUSH
6873: CALL_OW 114
6877: GO 6913
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_INT 81
6886: PUSH
6887: LD_INT 8
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 69
6898: PPUSH
6899: LD_VAR 0 1
6903: PPUSH
6904: CALL_OW 74
6908: PPUSH
6909: CALL_OW 115
// end else
6913: GO 6942
// if IsDead ( i ) then
6915: LD_VAR 0 1
6919: PPUSH
6920: CALL_OW 301
6924: IFFALSE 6942
// tmp := tmp diff i ;
6926: LD_ADDR_VAR 0 3
6930: PUSH
6931: LD_VAR 0 3
6935: PUSH
6936: LD_VAR 0 1
6940: DIFF
6941: ST_TO_ADDR
// end ;
6942: GO 6807
6944: POP
6945: POP
// until not tmp ;
6946: LD_VAR 0 3
6950: NOT
6951: IFFALSE 6790
// end ; end_of_file
6953: PPOPN 3
6955: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
// side := 3 ;
6967: LD_ADDR_VAR 0 6
6971: PUSH
6972: LD_INT 3
6974: ST_TO_ADDR
// uc_side := side ;
6975: LD_ADDR_OWVAR 20
6979: PUSH
6980: LD_VAR 0 6
6984: ST_TO_ADDR
// uc_nation := 3 ;
6985: LD_ADDR_OWVAR 21
6989: PUSH
6990: LD_INT 3
6992: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6993: LD_ADDR_VAR 0 2
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_VAR 0 6
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: LD_INT 21
7012: PUSH
7013: LD_INT 3
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PPUSH
7024: CALL_OW 69
7028: PUSH
7029: FOR_IN
7030: IFFALSE 7046
// SetBLevel ( i , 10 ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: LD_INT 10
7039: PPUSH
7040: CALL_OW 241
7044: GO 7029
7046: POP
7047: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7048: LD_ADDR_VAR 0 9
7052: PUSH
7053: LD_INT 22
7055: PUSH
7056: LD_VAR 0 6
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PUSH
7065: LD_INT 30
7067: PUSH
7068: LD_INT 34
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PPUSH
7079: CALL_OW 69
7083: ST_TO_ADDR
// if teleport then
7084: LD_VAR 0 9
7088: IFFALSE 7109
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7090: LD_VAR 0 9
7094: PUSH
7095: LD_INT 1
7097: ARRAY
7098: PPUSH
7099: LD_INT 123
7101: PPUSH
7102: LD_INT 122
7104: PPUSH
7105: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7109: LD_ADDR_EXP 64
7113: PUSH
7114: LD_STRING Platonov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7122: LD_ADDR_EXP 65
7126: PUSH
7127: LD_STRING Kovalyuk
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7135: LD_ADDR_EXP 67
7139: PUSH
7140: LD_STRING Yakotich
7142: PPUSH
7143: LD_EXP 1
7147: NOT
7148: PPUSH
7149: LD_STRING 09_
7151: PPUSH
7152: CALL 65112 0 3
7156: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7157: LD_ADDR_EXP 66
7161: PUSH
7162: LD_STRING Bystrov
7164: PPUSH
7165: CALL_OW 25
7169: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7170: LD_ADDR_EXP 68
7174: PUSH
7175: LD_STRING Gleb
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7183: LD_STRING 03_Cornel
7185: PPUSH
7186: CALL_OW 28
7190: IFFALSE 7238
// begin Bierezov := NewCharacter ( Mikhail ) ;
7192: LD_ADDR_EXP 69
7196: PUSH
7197: LD_STRING Mikhail
7199: PPUSH
7200: CALL_OW 25
7204: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7205: LD_EXP 69
7209: PPUSH
7210: LD_INT 197
7212: PPUSH
7213: LD_INT 111
7215: PPUSH
7216: LD_INT 9
7218: PPUSH
7219: LD_INT 0
7221: PPUSH
7222: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7226: LD_EXP 69
7230: PPUSH
7231: LD_INT 3
7233: PPUSH
7234: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7238: LD_EXP 64
7242: PPUSH
7243: LD_INT 126
7245: PPUSH
7246: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7250: LD_EXP 65
7254: PPUSH
7255: LD_INT 134
7257: PPUSH
7258: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7262: LD_EXP 67
7266: PPUSH
7267: LD_INT 197
7269: PPUSH
7270: LD_INT 111
7272: PPUSH
7273: LD_INT 9
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7283: LD_EXP 66
7287: PPUSH
7288: LD_INT 197
7290: PPUSH
7291: LD_INT 111
7293: PPUSH
7294: LD_INT 9
7296: PPUSH
7297: LD_INT 0
7299: PPUSH
7300: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7304: LD_EXP 68
7308: PPUSH
7309: LD_INT 197
7311: PPUSH
7312: LD_INT 111
7314: PPUSH
7315: LD_INT 9
7317: PPUSH
7318: LD_INT 0
7320: PPUSH
7321: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: LD_INT 126
7332: PPUSH
7333: LD_INT 4
7335: PPUSH
7336: LD_STRING zhukov
7338: PPUSH
7339: LD_INT 9
7341: PUSH
7342: LD_INT 10
7344: PUSH
7345: LD_INT 10
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PUSH
7353: LD_OWVAR 67
7357: ARRAY
7358: PPUSH
7359: LD_INT 90000
7361: PUSH
7362: LD_INT 1000
7364: PUSH
7365: LD_INT 300
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: LIST
7372: PPUSH
7373: LD_INT 18
7375: PUSH
7376: LD_INT 8
7378: PUSH
7379: LD_INT 13
7381: PUSH
7382: LD_INT 8
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: PPUSH
7391: CALL 73345 0 6
7395: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7396: LD_ADDR_VAR 0 4
7400: PUSH
7401: LD_INT 267
7403: PPUSH
7404: CALL_OW 274
7408: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 1
7416: PPUSH
7417: LD_INT 5000
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7439: LD_VAR 0 4
7443: PPUSH
7444: LD_INT 3
7446: PPUSH
7447: LD_INT 200
7449: PPUSH
7450: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7454: LD_ADDR_EXP 113
7458: PUSH
7459: LD_EXP 113
7463: PPUSH
7464: LD_INT 2
7466: PPUSH
7467: LD_VAR 0 5
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_VAR 0 6
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 21
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: UNION
7510: PUSH
7511: LD_EXP 64
7515: DIFF
7516: PPUSH
7517: CALL_OW 1
7521: ST_TO_ADDR
// behemoths := [ ] ;
7522: LD_ADDR_EXP 72
7526: PUSH
7527: EMPTY
7528: ST_TO_ADDR
// behemothBuilders := [ ] ;
7529: LD_ADDR_EXP 73
7533: PUSH
7534: EMPTY
7535: ST_TO_ADDR
// if Kovalyuk then
7536: LD_EXP 65
7540: IFFALSE 7562
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7542: LD_ADDR_EXP 73
7546: PUSH
7547: LD_EXP 73
7551: PPUSH
7552: LD_EXP 65
7556: PPUSH
7557: CALL 101101 0 2
7561: ST_TO_ADDR
// j := 3 ;
7562: LD_ADDR_VAR 0 3
7566: PUSH
7567: LD_INT 3
7569: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_INT 3
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 25
7587: PUSH
7588: LD_INT 3
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: PUSH
7604: LD_EXP 65
7608: DIFF
7609: PUSH
7610: FOR_IN
7611: IFFALSE 7661
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7613: LD_ADDR_EXP 73
7617: PUSH
7618: LD_EXP 73
7622: PPUSH
7623: LD_VAR 0 2
7627: PPUSH
7628: CALL 101101 0 2
7632: ST_TO_ADDR
// j := j - 1 ;
7633: LD_ADDR_VAR 0 3
7637: PUSH
7638: LD_VAR 0 3
7642: PUSH
7643: LD_INT 1
7645: MINUS
7646: ST_TO_ADDR
// if j = 0 then
7647: LD_VAR 0 3
7651: PUSH
7652: LD_INT 0
7654: EQUAL
7655: IFFALSE 7659
// break ;
7657: GO 7661
// end ;
7659: GO 7610
7661: POP
7662: POP
// end ;
7663: LD_VAR 0 1
7667: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7668: LD_INT 0
7670: PPUSH
7671: PPUSH
7672: PPUSH
7673: PPUSH
7674: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 209
7682: PUSH
7683: LD_INT 149
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 219
7692: PUSH
7693: LD_INT 154
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 223
7702: PUSH
7703: LD_INT 149
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 232
7712: PUSH
7713: LD_INT 155
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: ST_TO_ADDR
// if not behemothBuilders then
7726: LD_EXP 73
7730: NOT
7731: IFFALSE 7735
// exit ;
7733: GO 7839
// j := 1 ;
7735: LD_ADDR_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: ST_TO_ADDR
// for i in behemothBuilders do
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_EXP 73
7752: PUSH
7753: FOR_IN
7754: IFFALSE 7837
// begin if IsInUnit ( i ) then
7756: LD_VAR 0 2
7760: PPUSH
7761: CALL_OW 310
7765: IFFALSE 7776
// ComExitBuilding ( i ) ;
7767: LD_VAR 0 2
7771: PPUSH
7772: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 37
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 1
7797: ARRAY
7798: PPUSH
7799: LD_VAR 0 4
7803: PUSH
7804: LD_VAR 0 3
7808: ARRAY
7809: PUSH
7810: LD_INT 2
7812: ARRAY
7813: PPUSH
7814: LD_INT 0
7816: PPUSH
7817: CALL_OW 230
// j := j + 1 ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_VAR 0 3
7830: PUSH
7831: LD_INT 1
7833: PLUS
7834: ST_TO_ADDR
// end ;
7835: GO 7753
7837: POP
7838: POP
// end ;
7839: LD_VAR 0 1
7843: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7844: LD_INT 24
7846: PPUSH
7847: LD_INT 30
7849: PUSH
7850: LD_INT 37
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PPUSH
7857: CALL_OW 70
7861: IFFALSE 7874
7863: GO 7865
7865: DISABLE
// behemothUnderConstruct := true ;
7866: LD_ADDR_EXP 26
7870: PUSH
7871: LD_INT 1
7873: ST_TO_ADDR
7874: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7875: LD_INT 3
7877: PPUSH
7878: CALL 101162 0 1
7882: PUSH
7883: LD_INT 22
7885: PUSH
7886: LD_INT 3
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: PUSH
7893: LD_INT 30
7895: PUSH
7896: LD_INT 37
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: NOT
7912: AND
7913: IFFALSE 8099
7915: GO 7917
7917: DISABLE
7918: LD_INT 0
7920: PPUSH
7921: PPUSH
// begin enable ;
7922: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7923: LD_ADDR_VAR 0 2
7927: PUSH
7928: LD_INT 3
7930: PPUSH
7931: CALL 101162 0 1
7935: ST_TO_ADDR
// for i in tmp do
7936: LD_ADDR_VAR 0 1
7940: PUSH
7941: LD_VAR 0 2
7945: PUSH
7946: FOR_IN
7947: IFFALSE 8097
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_INT 9
7956: PPUSH
7957: CALL_OW 308
7961: PUSH
7962: LD_VAR 0 1
7966: PPUSH
7967: CALL_OW 110
7971: PUSH
7972: LD_INT 2
7974: EQUAL
7975: NOT
7976: AND
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7991: LD_INT 81
7993: PUSH
7994: LD_INT 3
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 91
8003: PUSH
8004: LD_VAR 0 1
8008: PUSH
8009: LD_INT 12
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 69
8025: NOT
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8061
// ComAgressiveMove ( i , 64 , 93 ) else
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 64
8051: PPUSH
8052: LD_INT 93
8054: PPUSH
8055: CALL_OW 114
8059: GO 8095
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8061: LD_VAR 0 1
8065: PPUSH
8066: LD_INT 81
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: PPUSH
8076: CALL_OW 69
8080: PPUSH
8081: LD_VAR 0 1
8085: PPUSH
8086: CALL_OW 74
8090: PPUSH
8091: CALL_OW 115
// end ;
8095: GO 7946
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8102: LD_INT 0
8104: PPUSH
8105: PPUSH
8106: PPUSH
// result := [ ] ;
8107: LD_ADDR_VAR 0 2
8111: PUSH
8112: EMPTY
8113: ST_TO_ADDR
// uc_side := 6 ;
8114: LD_ADDR_OWVAR 20
8118: PUSH
8119: LD_INT 6
8121: ST_TO_ADDR
// uc_nation := 3 ;
8122: LD_ADDR_OWVAR 21
8126: PUSH
8127: LD_INT 3
8129: ST_TO_ADDR
// case strength of 1 :
8130: LD_VAR 0 1
8134: PUSH
8135: LD_INT 1
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8281
8143: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8144: LD_ADDR_VAR 0 3
8148: PUSH
8149: DOUBLE
8150: LD_INT 1
8152: DEC
8153: ST_TO_ADDR
8154: LD_INT 4
8156: PUSH
8157: LD_INT 5
8159: PUSH
8160: LD_INT 6
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_OWVAR 67
8172: ARRAY
8173: PUSH
8174: FOR_TO
8175: IFFALSE 8277
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8177: LD_INT 22
8179: PUSH
8180: LD_INT 24
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_VAR 0 3
8191: PUSH
8192: LD_INT 2
8194: MOD
8195: PUSH
8196: LD_INT 1
8198: PLUS
8199: ARRAY
8200: PPUSH
8201: LD_INT 1
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 1
8213: PPUSH
8214: LD_INT 2
8216: PPUSH
8217: CALL_OW 12
8221: ARRAY
8222: PPUSH
8223: LD_INT 3
8225: PPUSH
8226: LD_INT 43
8228: PUSH
8229: LD_INT 44
8231: PUSH
8232: LD_INT 45
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 1
8242: PPUSH
8243: LD_INT 3
8245: PPUSH
8246: CALL_OW 12
8250: ARRAY
8251: PPUSH
8252: LD_INT 80
8254: PPUSH
8255: CALL 69936 0 5
// result := result union CreateVehicle ;
8259: LD_ADDR_VAR 0 2
8263: PUSH
8264: LD_VAR 0 2
8268: PUSH
8269: CALL_OW 45
8273: UNION
8274: ST_TO_ADDR
// end ;
8275: GO 8174
8277: POP
8278: POP
// end ; 2 :
8279: GO 9232
8281: LD_INT 2
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8445
8289: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 5
8302: PUSH
8303: LD_INT 6
8305: PUSH
8306: LD_INT 7
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_OWVAR 67
8318: ARRAY
8319: PUSH
8320: FOR_TO
8321: IFFALSE 8441
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8323: LD_INT 22
8325: PUSH
8326: LD_INT 24
8328: PUSH
8329: LD_INT 24
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 3
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: LD_INT 44
8387: PUSH
8388: LD_INT 46
8390: PUSH
8391: LD_INT 46
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_INT 6
8409: MOD
8410: PUSH
8411: LD_INT 1
8413: PLUS
8414: ARRAY
8415: PPUSH
8416: LD_INT 80
8418: PPUSH
8419: CALL 69936 0 5
// result := result union CreateVehicle ;
8423: LD_ADDR_VAR 0 2
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: CALL_OW 45
8437: UNION
8438: ST_TO_ADDR
// end ;
8439: GO 8320
8441: POP
8442: POP
// end ; 3 :
8443: GO 9232
8445: LD_INT 3
8447: DOUBLE
8448: EQUAL
8449: IFTRUE 8453
8451: GO 8609
8453: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8454: LD_ADDR_VAR 0 3
8458: PUSH
8459: DOUBLE
8460: LD_INT 1
8462: DEC
8463: ST_TO_ADDR
8464: LD_INT 5
8466: PUSH
8467: LD_INT 7
8469: PUSH
8470: LD_INT 8
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: FOR_TO
8485: IFFALSE 8605
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8487: LD_INT 22
8489: PUSH
8490: LD_INT 24
8492: PUSH
8493: LD_INT 24
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: LIST
8500: PUSH
8501: LD_VAR 0 3
8505: PUSH
8506: LD_INT 3
8508: MOD
8509: PUSH
8510: LD_INT 1
8512: PLUS
8513: ARRAY
8514: PPUSH
8515: LD_INT 1
8517: PUSH
8518: LD_INT 3
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 1
8527: PPUSH
8528: LD_INT 2
8530: PPUSH
8531: CALL_OW 12
8535: ARRAY
8536: PPUSH
8537: LD_INT 3
8539: PPUSH
8540: LD_INT 43
8542: PUSH
8543: LD_INT 47
8545: PUSH
8546: LD_INT 45
8548: PUSH
8549: LD_INT 45
8551: PUSH
8552: LD_INT 46
8554: PUSH
8555: LD_INT 46
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: PUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 6
8573: MOD
8574: PUSH
8575: LD_INT 1
8577: PLUS
8578: ARRAY
8579: PPUSH
8580: LD_INT 80
8582: PPUSH
8583: CALL 69936 0 5
// result := result union CreateVehicle ;
8587: LD_ADDR_VAR 0 2
8591: PUSH
8592: LD_VAR 0 2
8596: PUSH
8597: CALL_OW 45
8601: UNION
8602: ST_TO_ADDR
// end ;
8603: GO 8484
8605: POP
8606: POP
// end ; 4 :
8607: GO 9232
8609: LD_INT 4
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 9231
8617: POP
// begin uc_nation := 3 ;
8618: LD_ADDR_OWVAR 21
8622: PUSH
8623: LD_INT 3
8625: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8626: LD_ADDR_VAR 0 3
8630: PUSH
8631: DOUBLE
8632: LD_INT 1
8634: DEC
8635: ST_TO_ADDR
8636: LD_INT 6
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 9
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: LIST
8649: PUSH
8650: LD_OWVAR 67
8654: ARRAY
8655: PUSH
8656: FOR_TO
8657: IFFALSE 8777
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8659: LD_INT 22
8661: PUSH
8662: LD_INT 24
8664: PUSH
8665: LD_INT 24
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_VAR 0 3
8677: PUSH
8678: LD_INT 3
8680: MOD
8681: PUSH
8682: LD_INT 1
8684: PLUS
8685: ARRAY
8686: PPUSH
8687: LD_INT 1
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 1
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: CALL_OW 12
8707: ARRAY
8708: PPUSH
8709: LD_INT 3
8711: PPUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 47
8717: PUSH
8718: LD_INT 47
8720: PUSH
8721: LD_INT 45
8723: PUSH
8724: LD_INT 46
8726: PUSH
8727: LD_INT 46
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 6
8745: MOD
8746: PUSH
8747: LD_INT 1
8749: PLUS
8750: ARRAY
8751: PPUSH
8752: LD_INT 80
8754: PPUSH
8755: CALL 69936 0 5
// result := result union CreateVehicle ;
8759: LD_ADDR_VAR 0 2
8763: PUSH
8764: LD_VAR 0 2
8768: PUSH
8769: CALL_OW 45
8773: UNION
8774: ST_TO_ADDR
// end ;
8775: GO 8656
8777: POP
8778: POP
// if not KappaStatus then
8779: LD_EXP 2
8783: NOT
8784: IFFALSE 9019
// begin uc_nation := 1 ;
8786: LD_ADDR_OWVAR 21
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// for i = 1 to 3 do
8794: LD_ADDR_VAR 0 3
8798: PUSH
8799: DOUBLE
8800: LD_INT 1
8802: DEC
8803: ST_TO_ADDR
8804: LD_INT 3
8806: PUSH
8807: FOR_TO
8808: IFFALSE 8944
// begin j := rand ( 0 , 1 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 0
8817: PPUSH
8818: LD_INT 1
8820: PPUSH
8821: CALL_OW 12
8825: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8826: LD_INT 3
8828: PUSH
8829: LD_INT 5
8831: PUSH
8832: LD_INT 5
8834: PUSH
8835: LD_INT 4
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: PUSH
8844: LD_VAR 0 4
8848: PUSH
8849: LD_INT 1
8851: PPUSH
8852: LD_INT 3
8854: PPUSH
8855: CALL_OW 12
8859: PLUS
8860: ARRAY
8861: PPUSH
8862: LD_INT 1
8864: PUSH
8865: LD_INT 3
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: PUSH
8872: LD_INT 1
8874: PPUSH
8875: LD_INT 2
8877: PPUSH
8878: CALL_OW 12
8882: ARRAY
8883: PPUSH
8884: LD_INT 3
8886: PPUSH
8887: LD_INT 9
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: LD_INT 6
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_VAR 0 4
8905: PUSH
8906: LD_INT 1
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: CALL_OW 12
8916: PLUS
8917: ARRAY
8918: PPUSH
8919: LD_INT 85
8921: PPUSH
8922: CALL 69936 0 5
// result := result union CreateVehicle ;
8926: LD_ADDR_VAR 0 2
8930: PUSH
8931: LD_VAR 0 2
8935: PUSH
8936: CALL_OW 45
8940: UNION
8941: ST_TO_ADDR
// end ;
8942: GO 8807
8944: POP
8945: POP
// if vsevolodFirstAttack then
8946: LD_EXP 24
8950: IFFALSE 9017
// begin vsevolodFirstAttack := false ;
8952: LD_ADDR_EXP 24
8956: PUSH
8957: LD_INT 0
8959: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8960: LD_INT 5
8962: PPUSH
8963: LD_INT 3
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 6
8971: PPUSH
8972: LD_INT 100
8974: PPUSH
8975: CALL 69936 0 5
// sewiVeh := CreateVehicle ;
8979: LD_ADDR_EXP 71
8983: PUSH
8984: CALL_OW 45
8988: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8989: LD_EXP 71
8993: PPUSH
8994: LD_INT 1
8996: PPUSH
8997: CALL_OW 242
// result := result union sewiVeh ;
9001: LD_ADDR_VAR 0 2
9005: PUSH
9006: LD_VAR 0 2
9010: PUSH
9011: LD_EXP 71
9015: UNION
9016: ST_TO_ADDR
// end ; end else
9017: GO 9229
// if vsevolodFirstAttack then
9019: LD_EXP 24
9023: IFFALSE 9229
// begin vsevolodFirstAttack := false ;
9025: LD_ADDR_EXP 24
9029: PUSH
9030: LD_INT 0
9032: ST_TO_ADDR
// uc_nation := 3 ;
9033: LD_ADDR_OWVAR 21
9037: PUSH
9038: LD_INT 3
9040: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: DOUBLE
9047: LD_INT 1
9049: DEC
9050: ST_TO_ADDR
9051: LD_INT 2
9053: PUSH
9054: LD_OWVAR 67
9058: PLUS
9059: PUSH
9060: FOR_TO
9061: IFFALSE 9169
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9063: LD_INT 22
9065: PUSH
9066: LD_INT 24
9068: PUSH
9069: LD_INT 24
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: PUSH
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 3
9084: MOD
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: ARRAY
9090: PPUSH
9091: LD_INT 1
9093: PUSH
9094: LD_INT 3
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 2
9106: PPUSH
9107: CALL_OW 12
9111: ARRAY
9112: PPUSH
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 45
9118: PUSH
9119: LD_INT 47
9121: PUSH
9122: LD_INT 47
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_VAR 0 3
9134: PUSH
9135: LD_INT 3
9137: MOD
9138: PUSH
9139: LD_INT 1
9141: PLUS
9142: ARRAY
9143: PPUSH
9144: LD_INT 80
9146: PPUSH
9147: CALL 69936 0 5
// result := result union CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: LD_VAR 0 2
9160: PUSH
9161: CALL_OW 45
9165: UNION
9166: ST_TO_ADDR
// end ;
9167: GO 9060
9169: POP
9170: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9171: LD_INT 24
9173: PPUSH
9174: LD_INT 3
9176: PPUSH
9177: LD_INT 1
9179: PPUSH
9180: LD_INT 47
9182: PPUSH
9183: LD_INT 100
9185: PPUSH
9186: CALL 69936 0 5
// sewiVeh := CreateVehicle ;
9190: LD_ADDR_EXP 71
9194: PUSH
9195: CALL_OW 45
9199: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9200: LD_EXP 71
9204: PPUSH
9205: LD_INT 6
9207: NEG
9208: PPUSH
9209: CALL_OW 242
// result := result union sewiVeh ;
9213: LD_ADDR_VAR 0 2
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_EXP 71
9227: UNION
9228: ST_TO_ADDR
// end ; end ; end ;
9229: GO 9232
9231: POP
// end ;
9232: LD_VAR 0 2
9236: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9237: LD_EXP 16
9241: IFFALSE 10082
9243: GO 9245
9245: DISABLE
9246: LD_INT 0
9248: PPUSH
9249: PPUSH
9250: PPUSH
9251: PPUSH
9252: PPUSH
9253: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9254: LD_ADDR_VAR 0 4
9258: PUSH
9259: LD_INT 11
9261: PUSH
9262: LD_INT 12
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9269: LD_ADDR_VAR 0 3
9273: PUSH
9274: LD_INT 11550
9276: PUSH
9277: LD_INT 10150
9279: PUSH
9280: LD_INT 9800
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_OWVAR 67
9292: ARRAY
9293: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9294: LD_ADDR_VAR 0 6
9298: PUSH
9299: LD_INT 70
9301: PUSH
9302: LD_INT 118
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PUSH
9309: LD_INT 78
9311: PUSH
9312: LD_INT 31
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: ST_TO_ADDR
// repeat if missionStage = 2 then
9323: LD_EXP 15
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: IFFALSE 9342
// wait ( 1 1$30 ) else
9333: LD_INT 3150
9335: PPUSH
9336: CALL_OW 67
9340: GO 9351
// wait ( time ) ;
9342: LD_VAR 0 3
9346: PPUSH
9347: CALL_OW 67
// if missionStage = 6 then
9351: LD_EXP 15
9355: PUSH
9356: LD_INT 6
9358: EQUAL
9359: IFFALSE 9387
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9361: LD_INT 51
9363: PPUSH
9364: LD_INT 6
9366: PPUSH
9367: LD_INT 2
9369: PPUSH
9370: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9374: LD_INT 57
9376: PPUSH
9377: LD_INT 6
9379: PPUSH
9380: LD_INT 2
9382: PPUSH
9383: CALL_OW 322
// end ; if missionStage = 8 then
9387: LD_EXP 15
9391: PUSH
9392: LD_INT 8
9394: EQUAL
9395: IFFALSE 9423
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9397: LD_INT 52
9399: PPUSH
9400: LD_INT 6
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9410: LD_INT 58
9412: PPUSH
9413: LD_INT 6
9415: PPUSH
9416: LD_INT 2
9418: PPUSH
9419: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9423: LD_EXP 15
9427: PUSH
9428: LD_INT 10
9430: EQUAL
9431: PUSH
9432: LD_OWVAR 67
9436: PUSH
9437: LD_INT 1
9439: GREATER
9440: AND
9441: IFFALSE 9469
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9443: LD_INT 53
9445: PPUSH
9446: LD_INT 6
9448: PPUSH
9449: LD_INT 2
9451: PPUSH
9452: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9456: LD_INT 59
9458: PPUSH
9459: LD_INT 6
9461: PPUSH
9462: LD_INT 2
9464: PPUSH
9465: CALL_OW 322
// end ; if activeAttacks then
9469: LD_EXP 16
9473: IFFALSE 10076
// begin if missionStage = 2 then
9475: LD_EXP 15
9479: PUSH
9480: LD_INT 2
9482: EQUAL
9483: IFFALSE 9493
// strength := 1 ;
9485: LD_ADDR_VAR 0 5
9489: PUSH
9490: LD_INT 1
9492: ST_TO_ADDR
// if missionStage > 2 then
9493: LD_EXP 15
9497: PUSH
9498: LD_INT 2
9500: GREATER
9501: IFFALSE 9511
// strength := 2 ;
9503: LD_ADDR_VAR 0 5
9507: PUSH
9508: LD_INT 2
9510: ST_TO_ADDR
// if missionStage > 6 then
9511: LD_EXP 15
9515: PUSH
9516: LD_INT 6
9518: GREATER
9519: IFFALSE 9529
// strength := 3 ;
9521: LD_ADDR_VAR 0 5
9525: PUSH
9526: LD_INT 3
9528: ST_TO_ADDR
// if missionStage > 10 then
9529: LD_EXP 15
9533: PUSH
9534: LD_INT 10
9536: GREATER
9537: IFFALSE 9547
// strength := 4 ;
9539: LD_ADDR_VAR 0 5
9543: PUSH
9544: LD_INT 4
9546: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9547: LD_ADDR_VAR 0 2
9551: PUSH
9552: LD_VAR 0 5
9556: PPUSH
9557: CALL 8102 0 1
9561: ST_TO_ADDR
// for i in tmp do
9562: LD_ADDR_VAR 0 1
9566: PUSH
9567: LD_VAR 0 2
9571: PUSH
9572: FOR_IN
9573: IFFALSE 9756
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9575: LD_VAR 0 1
9579: PPUSH
9580: LD_VAR 0 4
9584: PUSH
9585: LD_INT 1
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 12
9595: ARRAY
9596: PPUSH
9597: LD_INT 0
9599: PPUSH
9600: CALL_OW 49
// if i = sewiVeh then
9604: LD_VAR 0 1
9608: PUSH
9609: LD_EXP 71
9613: EQUAL
9614: IFFALSE 9651
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9616: LD_ADDR_EXP 70
9620: PUSH
9621: LD_STRING Vsevolod
9623: PPUSH
9624: LD_INT 0
9626: PPUSH
9627: LD_STRING 
9629: PPUSH
9630: CALL 65112 0 3
9634: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9635: LD_EXP 70
9639: PPUSH
9640: LD_VAR 0 1
9644: PPUSH
9645: CALL_OW 52
// end else
9649: GO 9732
// if GetControl ( i ) = control_manual then
9651: LD_VAR 0 1
9655: PPUSH
9656: CALL_OW 263
9660: PUSH
9661: LD_INT 1
9663: EQUAL
9664: IFFALSE 9732
// begin uc_side := 6 ;
9666: LD_ADDR_OWVAR 20
9670: PUSH
9671: LD_INT 6
9673: ST_TO_ADDR
// uc_nation := 3 ;
9674: LD_ADDR_OWVAR 21
9678: PUSH
9679: LD_INT 3
9681: ST_TO_ADDR
// hc_gallery :=  ;
9682: LD_ADDR_OWVAR 33
9686: PUSH
9687: LD_STRING 
9689: ST_TO_ADDR
// hc_name :=  ;
9690: LD_ADDR_OWVAR 26
9694: PUSH
9695: LD_STRING 
9697: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9698: LD_INT 0
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: LD_INT 10
9706: PPUSH
9707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9711: CALL_OW 44
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9725: LD_INT 10
9727: PPUSH
9728: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9732: LD_VAR 0 1
9736: PPUSH
9737: LD_INT 111
9739: PPUSH
9740: LD_INT 197
9742: PPUSH
9743: CALL_OW 111
// wait ( 0 0$2 ) ;
9747: LD_INT 70
9749: PPUSH
9750: CALL_OW 67
// end ;
9754: GO 9572
9756: POP
9757: POP
// repeat wait ( 0 0$1 ) ;
9758: LD_INT 35
9760: PPUSH
9761: CALL_OW 67
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 10057
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9778: LD_INT 81
9780: PUSH
9781: LD_INT 6
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: LD_INT 91
9790: PUSH
9791: LD_VAR 0 1
9795: PUSH
9796: LD_INT 12
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 69
9812: IFFALSE 9870
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_INT 81
9821: PUSH
9822: LD_INT 6
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: LD_INT 91
9831: PUSH
9832: LD_VAR 0 1
9836: PUSH
9837: LD_INT 12
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: PPUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 74
9863: PPUSH
9864: CALL_OW 115
9868: GO 10055
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9870: LD_INT 9
9872: PPUSH
9873: LD_INT 81
9875: PUSH
9876: LD_INT 6
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PPUSH
9883: CALL_OW 70
9887: IFFALSE 10021
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9889: LD_VAR 0 1
9893: PPUSH
9894: LD_VAR 0 6
9898: PUSH
9899: LD_INT 1
9901: ARRAY
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PPUSH
9907: LD_VAR 0 6
9911: PUSH
9912: LD_INT 1
9914: ARRAY
9915: PUSH
9916: LD_INT 2
9918: ARRAY
9919: PPUSH
9920: CALL_OW 297
9924: PUSH
9925: LD_INT 10
9927: GREATER
9928: PUSH
9929: LD_VAR 0 1
9933: PPUSH
9934: LD_INT 9
9936: PPUSH
9937: CALL_OW 308
9941: NOT
9942: AND
9943: IFFALSE 9982
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9945: LD_VAR 0 1
9949: PPUSH
9950: LD_VAR 0 6
9954: PUSH
9955: LD_INT 1
9957: ARRAY
9958: PUSH
9959: LD_INT 1
9961: ARRAY
9962: PPUSH
9963: LD_VAR 0 6
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PUSH
9972: LD_INT 2
9974: ARRAY
9975: PPUSH
9976: CALL_OW 114
9980: GO 10019
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_INT 9
9989: PPUSH
9990: LD_INT 81
9992: PUSH
9993: LD_INT 6
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PPUSH
10000: CALL_OW 70
10004: PPUSH
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 74
10014: PPUSH
10015: CALL_OW 115
// end else
10019: GO 10055
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_INT 81
10028: PUSH
10029: LD_INT 6
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 69
10040: PPUSH
10041: LD_VAR 0 1
10045: PPUSH
10046: CALL_OW 74
10050: PPUSH
10051: CALL_OW 115
// end ;
10055: GO 9775
10057: POP
10058: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10059: LD_INT 22
10061: PUSH
10062: LD_INT 6
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: NOT
10074: IFFALSE 9758
// end ; until russianDestroyed ;
10076: LD_EXP 21
10080: IFFALSE 9323
// end ;
10082: PPOPN 6
10084: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10085: LD_EXP 21
10089: NOT
10090: PUSH
10091: LD_EXP 15
10095: PUSH
10096: LD_INT 6
10098: GREATEREQUAL
10099: AND
10100: PUSH
10101: LD_INT 2
10103: PPUSH
10104: LD_INT 1
10106: PPUSH
10107: CALL 60186 0 2
10111: NOT
10112: AND
10113: IFFALSE 11069
10115: GO 10117
10117: DISABLE
10118: LD_INT 0
10120: PPUSH
10121: PPUSH
10122: PPUSH
10123: PPUSH
// begin enable ;
10124: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10125: LD_INT 22
10127: PUSH
10128: LD_INT 3
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 30
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PPUSH
10149: CALL_OW 69
10153: NOT
10154: IFFALSE 10158
// exit ;
10156: GO 11069
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10158: LD_ADDR_VAR 0 4
10162: PUSH
10163: LD_INT 22
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: LD_INT 30
10175: PUSH
10176: LD_INT 34
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PPUSH
10187: CALL_OW 69
10191: ST_TO_ADDR
// if Prob ( 40 ) then
10192: LD_INT 40
10194: PPUSH
10195: CALL_OW 13
10199: IFFALSE 10326
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10201: LD_INT 2
10203: PPUSH
10204: LD_INT 22
10206: PUSH
10207: LD_INT 3
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 49
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 22
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 49
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: PUSH
10240: LD_INT 22
10242: PUSH
10243: LD_INT 3
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 49
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 24
10260: PUSH
10261: LD_INT 3
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 46
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 24
10278: PUSH
10279: LD_INT 3
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 46
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: PUSH
10294: LD_INT 24
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 46
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL 58768 0 2
// end else
10324: GO 10449
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10326: LD_INT 2
10328: PPUSH
10329: LD_INT 24
10331: PUSH
10332: LD_INT 3
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 47
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 24
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 47
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: PUSH
10365: LD_INT 24
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 47
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 24
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 46
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 24
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 46
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 24
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 46
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: PPUSH
10445: CALL 58768 0 2
// end ; if Difficulty > 1 then
10449: LD_OWVAR 67
10453: PUSH
10454: LD_INT 1
10456: GREATER
10457: IFFALSE 10487
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10459: LD_INT 2
10461: PPUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 47
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: PPUSH
10483: CALL 58768 0 2
// repeat wait ( 0 0$1 ) ;
10487: LD_INT 35
10489: PPUSH
10490: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10494: LD_INT 2
10496: PPUSH
10497: LD_INT 1
10499: PPUSH
10500: CALL 60186 0 2
10504: PUSH
10505: LD_INT 6
10507: PUSH
10508: LD_INT 7
10510: PUSH
10511: LD_INT 7
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: LD_OWVAR 67
10523: ARRAY
10524: GREATEREQUAL
10525: IFFALSE 10487
// wait ( 0 0$30 ) ;
10527: LD_INT 1050
10529: PPUSH
10530: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10534: LD_ADDR_VAR 0 2
10538: PUSH
10539: LD_INT 2
10541: PPUSH
10542: LD_INT 1
10544: PPUSH
10545: CALL 60186 0 2
10549: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10550: LD_ADDR_EXP 132
10554: PUSH
10555: LD_EXP 132
10559: PPUSH
10560: LD_INT 2
10562: PPUSH
10563: LD_EXP 132
10567: PUSH
10568: LD_INT 2
10570: ARRAY
10571: PUSH
10572: LD_VAR 0 2
10576: DIFF
10577: PPUSH
10578: CALL_OW 1
10582: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10583: LD_ADDR_VAR 0 3
10587: PUSH
10588: LD_INT 0
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 12
10598: ST_TO_ADDR
// if target then
10599: LD_VAR 0 3
10603: IFFALSE 10731
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: LD_INT 24
10617: PUSH
10618: LD_INT 250
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PPUSH
10625: CALL_OW 72
10629: ST_TO_ADDR
// for i in tmp do
10630: LD_ADDR_VAR 0 1
10634: PUSH
10635: LD_VAR 0 2
10639: PUSH
10640: FOR_IN
10641: IFFALSE 10681
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 139
10650: PPUSH
10651: LD_INT 89
10653: PPUSH
10654: CALL_OW 297
10658: PUSH
10659: LD_INT 9
10661: GREATER
10662: IFFALSE 10679
// ComMoveXY ( i , 139 , 89 ) ;
10664: LD_VAR 0 1
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: LD_INT 89
10674: PPUSH
10675: CALL_OW 111
10679: GO 10640
10681: POP
10682: POP
// wait ( 0 0$1 ) ;
10683: LD_INT 35
10685: PPUSH
10686: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10690: LD_VAR 0 2
10694: PPUSH
10695: LD_INT 92
10697: PUSH
10698: LD_INT 139
10700: PUSH
10701: LD_INT 89
10703: PUSH
10704: LD_INT 9
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PPUSH
10713: CALL_OW 72
10717: PUSH
10718: LD_VAR 0 2
10722: PUSH
10723: LD_INT 1
10725: MINUS
10726: GREATEREQUAL
10727: IFFALSE 10605
// end else
10729: GO 10873
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10731: LD_VAR 0 2
10735: PPUSH
10736: LD_VAR 0 4
10740: PUSH
10741: LD_INT 1
10743: ARRAY
10744: PPUSH
10745: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 250
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 72
10773: ST_TO_ADDR
// for i in tmp do
10774: LD_ADDR_VAR 0 1
10778: PUSH
10779: LD_VAR 0 2
10783: PUSH
10784: FOR_IN
10785: IFFALSE 10825
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 124
10794: PPUSH
10795: LD_INT 139
10797: PPUSH
10798: CALL_OW 297
10802: PUSH
10803: LD_INT 9
10805: GREATER
10806: IFFALSE 10823
// ComMoveXY ( i , 124 , 139 ) ;
10808: LD_VAR 0 1
10812: PPUSH
10813: LD_INT 124
10815: PPUSH
10816: LD_INT 139
10818: PPUSH
10819: CALL_OW 111
10823: GO 10784
10825: POP
10826: POP
// wait ( 0 0$1 ) ;
10827: LD_INT 35
10829: PPUSH
10830: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_INT 92
10841: PUSH
10842: LD_INT 124
10844: PUSH
10845: LD_INT 139
10847: PUSH
10848: LD_INT 9
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 72
10861: PUSH
10862: LD_VAR 0 2
10866: PUSH
10867: LD_INT 1
10869: MINUS
10870: GREATEREQUAL
10871: IFFALSE 10749
// end ; repeat wait ( 0 0$1 ) ;
10873: LD_INT 35
10875: PPUSH
10876: CALL_OW 67
// for i in tmp do
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_VAR 0 2
10889: PUSH
10890: FOR_IN
10891: IFFALSE 11060
// begin if GetLives ( i ) > 251 then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 256
10902: PUSH
10903: LD_INT 251
10905: GREATER
10906: IFFALSE 11031
// begin if GetWeapon ( i ) = ru_time_lapser then
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 264
10917: PUSH
10918: LD_INT 49
10920: EQUAL
10921: IFFALSE 10977
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 2
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 1
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 8
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 112
10975: GO 11029
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_INT 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_INT 1
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 22
10997: PUSH
10998: LD_INT 8
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: PPUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 74
11024: PPUSH
11025: CALL_OW 115
// end else
11029: GO 11058
// if IsDead ( i ) then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 301
11040: IFFALSE 11058
// tmp := tmp diff i ;
11042: LD_ADDR_VAR 0 2
11046: PUSH
11047: LD_VAR 0 2
11051: PUSH
11052: LD_VAR 0 1
11056: DIFF
11057: ST_TO_ADDR
// end ;
11058: GO 10890
11060: POP
11061: POP
// until not tmp ;
11062: LD_VAR 0 2
11066: NOT
11067: IFFALSE 10873
// end ; end_of_file
11069: PPOPN 4
11071: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11072: LD_INT 0
11074: PPUSH
11075: PPUSH
11076: PPUSH
11077: PPUSH
11078: PPUSH
11079: PPUSH
// side := 7 ;
11080: LD_ADDR_VAR 0 5
11084: PUSH
11085: LD_INT 7
11087: ST_TO_ADDR
// uc_side := side ;
11088: LD_ADDR_OWVAR 20
11092: PUSH
11093: LD_VAR 0 5
11097: ST_TO_ADDR
// uc_nation := 1 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_VAR 0 5
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: LD_INT 21
11125: PUSH
11126: LD_INT 3
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PPUSH
11137: CALL_OW 69
11141: PUSH
11142: FOR_IN
11143: IFFALSE 11159
// SetBLevel ( i , 10 ) ;
11145: LD_VAR 0 2
11149: PPUSH
11150: LD_INT 10
11152: PPUSH
11153: CALL_OW 241
11157: GO 11142
11159: POP
11160: POP
// base := GetBase ( al_depot ) ;
11161: LD_ADDR_VAR 0 4
11165: PUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 274
11173: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11174: LD_ADDR_VAR 0 6
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_VAR 0 5
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PUSH
11191: LD_INT 30
11193: PUSH
11194: LD_INT 34
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: ST_TO_ADDR
// if teleport then
11210: LD_VAR 0 6
11214: IFFALSE 11235
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11216: LD_VAR 0 6
11220: PUSH
11221: LD_INT 1
11223: ARRAY
11224: PPUSH
11225: LD_INT 262
11227: PPUSH
11228: LD_INT 119
11230: PPUSH
11231: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 1
11242: PPUSH
11243: LD_INT 19500
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 2
11257: PPUSH
11258: LD_INT 200
11260: PPUSH
11261: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11265: LD_VAR 0 4
11269: PPUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 650
11275: PPUSH
11276: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11280: LD_ADDR_EXP 74
11284: PUSH
11285: LD_STRING Roth
11287: PPUSH
11288: CALL_OW 25
11292: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11293: LD_ADDR_EXP 75
11297: PUSH
11298: LD_STRING Simms
11300: PPUSH
11301: LD_EXP 1
11305: NOT
11306: PPUSH
11307: LD_STRING 10c_
11309: PPUSH
11310: CALL 65112 0 3
11314: ST_TO_ADDR
// if not Simms then
11315: LD_EXP 75
11319: NOT
11320: IFFALSE 11350
// begin uc_nation := 1 ;
11322: LD_ADDR_OWVAR 21
11326: PUSH
11327: LD_INT 1
11329: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11330: LD_INT 2
11332: PPUSH
11333: LD_INT 10
11335: PPUSH
11336: CALL_OW 384
// Simms := CreateHuman ;
11340: LD_ADDR_EXP 75
11344: PUSH
11345: CALL_OW 44
11349: ST_TO_ADDR
// end ; uc_nation := 3 ;
11350: LD_ADDR_OWVAR 21
11354: PUSH
11355: LD_INT 3
11357: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11358: LD_ADDR_EXP 76
11362: PUSH
11363: LD_STRING Kirilenkova
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11371: LD_ADDR_EXP 90
11375: PUSH
11376: LD_STRING Oblukov
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11384: LD_ADDR_EXP 77
11388: PUSH
11389: LD_STRING Dolgov
11391: PPUSH
11392: CALL_OW 25
11396: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11397: LD_ADDR_EXP 78
11401: PUSH
11402: LD_STRING Petrosyan
11404: PPUSH
11405: CALL_OW 25
11409: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11410: LD_ADDR_EXP 89
11414: PUSH
11415: LD_STRING Scholtze
11417: PPUSH
11418: CALL_OW 25
11422: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11423: LD_ADDR_EXP 88
11427: PUSH
11428: LD_STRING Kapitsova
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11436: LD_ADDR_EXP 79
11440: PUSH
11441: LD_STRING Petrovova
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11449: LD_ADDR_EXP 80
11453: PUSH
11454: LD_STRING Kuzmov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11462: LD_ADDR_EXP 87
11466: PUSH
11467: LD_STRING Karamazov
11469: PPUSH
11470: CALL_OW 25
11474: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11475: LD_STRING 13_Lipshchin_1
11477: PPUSH
11478: LD_INT 0
11480: PPUSH
11481: CALL_OW 30
11485: IFFALSE 11500
// Lipshchin := NewCharacter ( Lipshchin ) ;
11487: LD_ADDR_EXP 81
11491: PUSH
11492: LD_STRING Lipshchin
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11500: LD_STRING 13_Titov_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Titov := NewCharacter ( Titov ) ;
11512: LD_ADDR_EXP 83
11516: PUSH
11517: LD_STRING Titov
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11525: LD_STRING 13_Gnyevko_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Gnyevko := NewCharacter ( Gnyevko ) ;
11537: LD_ADDR_EXP 82
11541: PUSH
11542: LD_STRING Gnyevko
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11550: LD_STRING 13_Xavier_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Xavier := NewCharacter ( Xavier2 ) ;
11562: LD_ADDR_EXP 84
11566: PUSH
11567: LD_STRING Xavier2
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11575: LD_STRING 13_Belkov_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Belkov := NewCharacter ( Belkov ) ;
11587: LD_ADDR_EXP 85
11591: PUSH
11592: LD_STRING Belkov
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if not BurlakStatus then
11600: LD_EXP 9
11604: NOT
11605: IFFALSE 11620
// Burlak = NewCharacter ( Burlak ) ;
11607: LD_ADDR_EXP 86
11611: PUSH
11612: LD_STRING Burlak
11614: PPUSH
11615: CALL_OW 25
11619: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11620: LD_ADDR_VAR 0 3
11624: PUSH
11625: LD_EXP 74
11629: PUSH
11630: LD_EXP 76
11634: PUSH
11635: LD_EXP 90
11639: PUSH
11640: LD_EXP 77
11644: PUSH
11645: LD_EXP 78
11649: PUSH
11650: LD_EXP 89
11654: PUSH
11655: LD_EXP 88
11659: PUSH
11660: LD_EXP 79
11664: PUSH
11665: LD_EXP 80
11669: PUSH
11670: LD_EXP 87
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: ST_TO_ADDR
// if Simms then
11687: LD_EXP 75
11691: IFFALSE 11709
// tmp := tmp ^ Simms ;
11693: LD_ADDR_VAR 0 3
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_EXP 75
11707: ADD
11708: ST_TO_ADDR
// if Titov then
11709: LD_EXP 83
11713: IFFALSE 11731
// tmp := tmp ^ Titov ;
11715: LD_ADDR_VAR 0 3
11719: PUSH
11720: LD_VAR 0 3
11724: PUSH
11725: LD_EXP 83
11729: ADD
11730: ST_TO_ADDR
// if Lipshchin then
11731: LD_EXP 81
11735: IFFALSE 11753
// tmp := tmp ^ Lipshchin ;
11737: LD_ADDR_VAR 0 3
11741: PUSH
11742: LD_VAR 0 3
11746: PUSH
11747: LD_EXP 81
11751: ADD
11752: ST_TO_ADDR
// if Gnyevko then
11753: LD_EXP 82
11757: IFFALSE 11775
// tmp := tmp ^ Gnyevko ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_VAR 0 3
11768: PUSH
11769: LD_EXP 82
11773: ADD
11774: ST_TO_ADDR
// if Xavier then
11775: LD_EXP 84
11779: IFFALSE 11797
// tmp := tmp ^ Xavier ;
11781: LD_ADDR_VAR 0 3
11785: PUSH
11786: LD_VAR 0 3
11790: PUSH
11791: LD_EXP 84
11795: ADD
11796: ST_TO_ADDR
// if Belkov then
11797: LD_EXP 85
11801: IFFALSE 11819
// tmp := tmp ^ Belkov ;
11803: LD_ADDR_VAR 0 3
11807: PUSH
11808: LD_VAR 0 3
11812: PUSH
11813: LD_EXP 85
11817: ADD
11818: ST_TO_ADDR
// if Burlak then
11819: LD_EXP 86
11823: IFFALSE 11841
// tmp := tmp ^ Burlak ;
11825: LD_ADDR_VAR 0 3
11829: PUSH
11830: LD_VAR 0 3
11834: PUSH
11835: LD_EXP 86
11839: ADD
11840: ST_TO_ADDR
// for i = 1 to 11 do
11841: LD_ADDR_VAR 0 2
11845: PUSH
11846: DOUBLE
11847: LD_INT 1
11849: DEC
11850: ST_TO_ADDR
11851: LD_INT 11
11853: PUSH
11854: FOR_TO
11855: IFFALSE 11921
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11857: LD_ADDR_OWVAR 21
11861: PUSH
11862: LD_INT 1
11864: PUSH
11865: LD_INT 3
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 1
11874: PPUSH
11875: LD_INT 2
11877: PPUSH
11878: CALL_OW 12
11882: ARRAY
11883: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11884: LD_INT 0
11886: PPUSH
11887: LD_VAR 0 2
11891: PUSH
11892: LD_INT 2
11894: DIV
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11903: LD_ADDR_VAR 0 3
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: CALL_OW 44
11917: ADD
11918: ST_TO_ADDR
// end ;
11919: GO 11854
11921: POP
11922: POP
// for i in tmp do
11923: LD_ADDR_VAR 0 2
11927: PUSH
11928: LD_VAR 0 3
11932: PUSH
11933: FOR_IN
11934: IFFALSE 11959
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11936: LD_VAR 0 2
11940: PPUSH
11941: LD_INT 260
11943: PPUSH
11944: LD_INT 235
11946: PPUSH
11947: LD_INT 8
11949: PPUSH
11950: LD_INT 0
11952: PPUSH
11953: CALL_OW 50
11957: GO 11933
11959: POP
11960: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11961: LD_ADDR_EXP 113
11965: PUSH
11966: LD_EXP 113
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: LD_INT 22
11976: PUSH
11977: LD_VAR 0 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 3
11988: PUSH
11989: LD_INT 21
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PPUSH
12007: CALL_OW 69
12011: PUSH
12012: LD_EXP 74
12016: PUSH
12017: LD_EXP 75
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: DIFF
12026: PPUSH
12027: CALL_OW 1
12031: ST_TO_ADDR
// uc_side := 0 ;
12032: LD_ADDR_OWVAR 20
12036: PUSH
12037: LD_INT 0
12039: ST_TO_ADDR
// uc_nation := 0 ;
12040: LD_ADDR_OWVAR 21
12044: PUSH
12045: LD_INT 0
12047: ST_TO_ADDR
// for i = 1 to 5 do
12048: LD_ADDR_VAR 0 2
12052: PUSH
12053: DOUBLE
12054: LD_INT 1
12056: DEC
12057: ST_TO_ADDR
12058: LD_INT 5
12060: PUSH
12061: FOR_TO
12062: IFFALSE 12099
// begin InitHc ;
12064: CALL_OW 19
// hc_class := class_apeman ;
12068: LD_ADDR_OWVAR 28
12072: PUSH
12073: LD_INT 12
12075: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12076: CALL_OW 44
12080: PPUSH
12081: LD_INT 299
12083: PPUSH
12084: LD_INT 229
12086: PPUSH
12087: LD_INT 10
12089: PPUSH
12090: LD_INT 0
12092: PPUSH
12093: CALL_OW 50
// end ;
12097: GO 12061
12099: POP
12100: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 259
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12116: LD_EXP 74
12120: PPUSH
12121: LD_INT 262
12123: PPUSH
12124: LD_INT 235
12126: PPUSH
12127: CALL_OW 178
// if Simms then
12131: LD_EXP 75
12135: IFFALSE 12166
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_INT 262
12144: PPUSH
12145: LD_INT 235
12147: PPUSH
12148: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12152: LD_EXP 75
12156: PPUSH
12157: LD_EXP 74
12161: PPUSH
12162: CALL_OW 179
// end ; end ;
12166: LD_VAR 0 1
12170: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12171: LD_EXP 31
12175: PUSH
12176: LD_EXP 23
12180: NOT
12181: AND
12182: IFFALSE 12358
12184: GO 12186
12186: DISABLE
12187: LD_INT 0
12189: PPUSH
12190: PPUSH
12191: PPUSH
// begin enable ;
12192: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 81
12200: PUSH
12201: LD_INT 7
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 2
12210: PUSH
12211: LD_INT 32
12213: PUSH
12214: LD_INT 3
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 30
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 30
12233: PUSH
12234: LD_INT 28
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 34
12243: PUSH
12244: LD_INT 49
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 34
12253: PUSH
12254: LD_INT 10
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: LD_INT 34
12263: PUSH
12264: LD_INT 8
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: ST_TO_ADDR
// if not tmp then
12289: LD_VAR 0 2
12293: NOT
12294: IFFALSE 12298
// exit ;
12296: GO 12358
// target := tmp [ rand ( 1 , tmp ) ] ;
12298: LD_ADDR_VAR 0 3
12302: PUSH
12303: LD_VAR 0 2
12307: PUSH
12308: LD_INT 1
12310: PPUSH
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 12
12320: ARRAY
12321: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 255
12331: PUSH
12332: LD_INT 1
12334: EQUAL
12335: IFFALSE 12346
// CenterNowOnUnits ( target ) ;
12337: LD_VAR 0 3
12341: PPUSH
12342: CALL_OW 87
// SetLives ( target , 0 ) ;
12346: LD_VAR 0 3
12350: PPUSH
12351: LD_INT 0
12353: PPUSH
12354: CALL_OW 234
// end ;
12358: PPOPN 3
12360: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12361: LD_EXP 23
12365: NOT
12366: PUSH
12367: LD_EXP 31
12371: AND
12372: IFFALSE 12894
12374: GO 12376
12376: DISABLE
12377: LD_INT 0
12379: PPUSH
12380: PPUSH
12381: PPUSH
// begin uc_side := 7 ;
12382: LD_ADDR_OWVAR 20
12386: PUSH
12387: LD_INT 7
12389: ST_TO_ADDR
// uc_nation := 1 ;
12390: LD_ADDR_OWVAR 21
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_INT 125
12405: PUSH
12406: LD_INT 163
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 185
12415: PUSH
12416: LD_INT 168
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 111
12425: PUSH
12426: LD_INT 97
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: PPUSH
12438: CALL 101206 0 1
12442: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12443: LD_ADDR_EXP 91
12447: PUSH
12448: EMPTY
12449: ST_TO_ADDR
// for i = 1 to Difficulty do
12450: LD_ADDR_VAR 0 1
12454: PUSH
12455: DOUBLE
12456: LD_INT 1
12458: DEC
12459: ST_TO_ADDR
12460: LD_OWVAR 67
12464: PUSH
12465: FOR_TO
12466: IFFALSE 12624
// begin InitHc ;
12468: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12472: LD_INT 0
12474: PPUSH
12475: LD_INT 8
12477: PPUSH
12478: CALL_OW 381
// un := CreateHuman ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: CALL_OW 44
12491: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12492: LD_VAR 0 2
12496: PPUSH
12497: LD_INT 258
12499: PPUSH
12500: LD_INT 267
12502: PPUSH
12503: LD_INT 4
12505: PPUSH
12506: LD_INT 0
12508: PPUSH
12509: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12513: LD_ADDR_EXP 91
12517: PUSH
12518: LD_EXP 91
12522: PUSH
12523: LD_VAR 0 2
12527: UNION
12528: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12529: LD_VAR 0 2
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 1
12547: ARRAY
12548: PPUSH
12549: LD_VAR 0 3
12553: PUSH
12554: LD_VAR 0 1
12558: ARRAY
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 4
12566: PPUSH
12567: LD_INT 1
12569: PPUSH
12570: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12574: LD_VAR 0 2
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 1
12592: ARRAY
12593: PPUSH
12594: LD_VAR 0 3
12598: PUSH
12599: LD_VAR 0 1
12603: ARRAY
12604: PUSH
12605: LD_INT 2
12607: ARRAY
12608: PPUSH
12609: CALL_OW 171
// AddComInvisible ( un ) ;
12613: LD_VAR 0 2
12617: PPUSH
12618: CALL_OW 212
// end ;
12622: GO 12465
12624: POP
12625: POP
// repeat wait ( 0 0$20 ) ;
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 67
// for i in allianceSpecialForce do
12633: LD_ADDR_VAR 0 1
12637: PUSH
12638: LD_EXP 91
12642: PUSH
12643: FOR_IN
12644: IFFALSE 12879
// begin if IsInvisible ( i ) then
12646: LD_VAR 0 1
12650: PPUSH
12651: CALL_OW 571
12655: IFFALSE 12848
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12657: LD_ADDR_VAR 0 3
12661: PUSH
12662: LD_INT 22
12664: PUSH
12665: LD_INT 1
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: LD_INT 50
12674: PUSH
12675: EMPTY
12676: LIST
12677: PUSH
12678: LD_INT 56
12680: PUSH
12681: EMPTY
12682: LIST
12683: PUSH
12684: LD_INT 91
12686: PUSH
12687: LD_VAR 0 1
12691: PUSH
12692: LD_INT 25
12694: PUSH
12695: LD_INT 30
12697: PUSH
12698: LD_INT 35
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 2
12719: PUSH
12720: LD_INT 25
12722: PUSH
12723: LD_INT 1
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: LD_INT 25
12732: PUSH
12733: LD_INT 2
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 25
12742: PUSH
12743: LD_INT 3
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 25
12752: PUSH
12753: LD_INT 4
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 25
12762: PUSH
12763: LD_INT 5
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 25
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: PPUSH
12796: CALL_OW 69
12800: ST_TO_ADDR
// if not tmp then
12801: LD_VAR 0 3
12805: NOT
12806: IFFALSE 12810
// continue ;
12808: GO 12643
// if Prob ( 30 * Difficulty ) then
12810: LD_INT 30
12812: PUSH
12813: LD_OWVAR 67
12817: MUL
12818: PPUSH
12819: CALL_OW 13
12823: IFFALSE 12848
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_VAR 0 3
12837: PPUSH
12838: CALL_OW 12
12842: ARRAY
12843: PPUSH
12844: CALL 31141 0 1
// end ; if IsDead ( i ) then
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 301
12857: IFFALSE 12877
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12859: LD_ADDR_EXP 91
12863: PUSH
12864: LD_EXP 91
12868: PUSH
12869: LD_VAR 0 1
12873: DIFF
12874: ST_TO_ADDR
// continue ;
12875: GO 12643
// end ; end ;
12877: GO 12643
12879: POP
12880: POP
// until allianceDestroyed or not allianceSpecialForce ;
12881: LD_EXP 23
12885: PUSH
12886: LD_EXP 91
12890: NOT
12891: OR
12892: IFFALSE 12626
// end ;
12894: PPOPN 3
12896: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12897: LD_EXP 23
12901: NOT
12902: PUSH
12903: LD_EXP 31
12907: AND
12908: IFFALSE 13875
12910: GO 12912
12912: DISABLE
12913: LD_INT 0
12915: PPUSH
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12920: LD_INT 22
12922: PUSH
12923: LD_INT 7
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: LD_INT 30
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PPUSH
12944: CALL_OW 69
12948: NOT
12949: IFFALSE 12953
// exit ;
12951: GO 13875
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12953: LD_ADDR_VAR 0 4
12957: PUSH
12958: LD_INT 22
12960: PUSH
12961: LD_INT 7
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 30
12970: PUSH
12971: LD_INT 34
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PPUSH
12982: CALL_OW 69
12986: ST_TO_ADDR
// if Prob ( 40 ) then
12987: LD_INT 40
12989: PPUSH
12990: CALL_OW 13
12994: IFFALSE 13121
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 5
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 2
13007: PUSH
13008: LD_INT 6
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 2
13025: PUSH
13026: LD_INT 6
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 6
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 24
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 45
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 3
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 47
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 58768 0 2
// end else
13119: GO 13244
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 24
13126: PUSH
13127: LD_INT 3
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 47
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 24
13144: PUSH
13145: LD_INT 3
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 47
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PUSH
13160: LD_INT 5
13162: PUSH
13163: LD_INT 3
13165: PUSH
13166: LD_INT 2
13168: PUSH
13169: LD_INT 9
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: LD_INT 5
13180: PUSH
13181: LD_INT 3
13183: PUSH
13184: LD_INT 2
13186: PUSH
13187: LD_INT 9
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 24
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: LD_INT 3
13204: PUSH
13205: LD_INT 45
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 24
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 45
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: PPUSH
13240: CALL 58768 0 2
// end ; if Difficulty > 1 then
13244: LD_OWVAR 67
13248: PUSH
13249: LD_INT 1
13251: GREATER
13252: IFFALSE 13282
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13254: LD_INT 1
13256: PPUSH
13257: LD_INT 24
13259: PUSH
13260: LD_INT 3
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 47
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: PUSH
13275: EMPTY
13276: LIST
13277: PPUSH
13278: CALL 58768 0 2
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13289: LD_INT 1
13291: PPUSH
13292: LD_INT 1
13294: PPUSH
13295: CALL 60186 0 2
13299: PUSH
13300: LD_INT 6
13302: PUSH
13303: LD_INT 7
13305: PUSH
13306: LD_INT 7
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: PUSH
13314: LD_OWVAR 67
13318: ARRAY
13319: GREATEREQUAL
13320: IFFALSE 13282
// wait ( 0 0$40 ) ;
13322: LD_INT 1400
13324: PPUSH
13325: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13329: LD_ADDR_VAR 0 2
13333: PUSH
13334: LD_INT 1
13336: PPUSH
13337: LD_INT 1
13339: PPUSH
13340: CALL 60186 0 2
13344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13345: LD_ADDR_EXP 132
13349: PUSH
13350: LD_EXP 132
13354: PPUSH
13355: LD_INT 1
13357: PPUSH
13358: LD_EXP 132
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PUSH
13367: LD_VAR 0 2
13371: DIFF
13372: PPUSH
13373: CALL_OW 1
13377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13378: LD_ADDR_VAR 0 3
13382: PUSH
13383: LD_INT 0
13385: PPUSH
13386: LD_INT 1
13388: PPUSH
13389: CALL_OW 12
13393: ST_TO_ADDR
// if target then
13394: LD_VAR 0 3
13398: IFFALSE 13564
// begin for i in tmp do
13400: LD_ADDR_VAR 0 1
13404: PUSH
13405: LD_VAR 0 2
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13436
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13413: LD_VAR 0 1
13417: PPUSH
13418: LD_INT 179
13420: PPUSH
13421: LD_INT 209
13423: PPUSH
13424: LD_INT 8
13426: PPUSH
13427: LD_INT 1
13429: PPUSH
13430: CALL_OW 483
13434: GO 13410
13436: POP
13437: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: LD_INT 24
13450: PUSH
13451: LD_INT 250
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PPUSH
13458: CALL_OW 72
13462: ST_TO_ADDR
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13514
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 179
13483: PPUSH
13484: LD_INT 209
13486: PPUSH
13487: CALL_OW 297
13491: PUSH
13492: LD_INT 9
13494: GREATER
13495: IFFALSE 13512
// ComMoveXY ( i , 179 , 209 ) ;
13497: LD_VAR 0 1
13501: PPUSH
13502: LD_INT 179
13504: PPUSH
13505: LD_INT 209
13507: PPUSH
13508: CALL_OW 111
13512: GO 13473
13514: POP
13515: POP
// wait ( 0 0$1 ) ;
13516: LD_INT 35
13518: PPUSH
13519: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13523: LD_VAR 0 2
13527: PPUSH
13528: LD_INT 92
13530: PUSH
13531: LD_INT 179
13533: PUSH
13534: LD_INT 209
13536: PUSH
13537: LD_INT 9
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: PPUSH
13546: CALL_OW 72
13550: PUSH
13551: LD_VAR 0 2
13555: PUSH
13556: LD_INT 1
13558: MINUS
13559: GREATEREQUAL
13560: IFFALSE 13438
// end else
13562: GO 13726
// begin for i in tmp do
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: LD_VAR 0 2
13573: PUSH
13574: FOR_IN
13575: IFFALSE 13600
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_INT 285
13584: PPUSH
13585: LD_INT 163
13587: PPUSH
13588: LD_INT 8
13590: PPUSH
13591: LD_INT 1
13593: PPUSH
13594: CALL_OW 483
13598: GO 13574
13600: POP
13601: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13602: LD_ADDR_VAR 0 2
13606: PUSH
13607: LD_VAR 0 2
13611: PPUSH
13612: LD_INT 24
13614: PUSH
13615: LD_INT 250
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PPUSH
13622: CALL_OW 72
13626: ST_TO_ADDR
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13678
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13640: LD_VAR 0 1
13644: PPUSH
13645: LD_INT 285
13647: PPUSH
13648: LD_INT 163
13650: PPUSH
13651: CALL_OW 297
13655: PUSH
13656: LD_INT 9
13658: GREATER
13659: IFFALSE 13676
// ComMoveXY ( i , 285 , 163 ) ;
13661: LD_VAR 0 1
13665: PPUSH
13666: LD_INT 285
13668: PPUSH
13669: LD_INT 163
13671: PPUSH
13672: CALL_OW 111
13676: GO 13637
13678: POP
13679: POP
// wait ( 0 0$1 ) ;
13680: LD_INT 35
13682: PPUSH
13683: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13687: LD_VAR 0 2
13691: PPUSH
13692: LD_INT 92
13694: PUSH
13695: LD_INT 285
13697: PUSH
13698: LD_INT 163
13700: PUSH
13701: LD_INT 9
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: PPUSH
13710: CALL_OW 72
13714: PUSH
13715: LD_VAR 0 2
13719: PUSH
13720: LD_INT 1
13722: MINUS
13723: GREATEREQUAL
13724: IFFALSE 13602
// end ; repeat wait ( 0 0$1 ) ;
13726: LD_INT 35
13728: PPUSH
13729: CALL_OW 67
// for i in tmp do
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_VAR 0 2
13742: PUSH
13743: FOR_IN
13744: IFFALSE 13866
// if GetLives ( i ) > 251 then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 256
13755: PUSH
13756: LD_INT 251
13758: GREATER
13759: IFFALSE 13848
// begin if GetWeapon ( i ) = ru_time_lapser then
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 264
13770: PUSH
13771: LD_INT 49
13773: EQUAL
13774: IFFALSE 13812
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13776: LD_VAR 0 1
13780: PPUSH
13781: LD_INT 81
13783: PUSH
13784: LD_INT 7
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 69
13795: PPUSH
13796: LD_VAR 0 1
13800: PPUSH
13801: CALL_OW 74
13805: PPUSH
13806: CALL_OW 112
13810: GO 13846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13812: LD_VAR 0 1
13816: PPUSH
13817: LD_INT 81
13819: PUSH
13820: LD_INT 7
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PPUSH
13827: CALL_OW 69
13831: PPUSH
13832: LD_VAR 0 1
13836: PPUSH
13837: CALL_OW 74
13841: PPUSH
13842: CALL_OW 115
// end else
13846: GO 13864
// tmp := tmp diff i ;
13848: LD_ADDR_VAR 0 2
13852: PUSH
13853: LD_VAR 0 2
13857: PUSH
13858: LD_VAR 0 1
13862: DIFF
13863: ST_TO_ADDR
13864: GO 13743
13866: POP
13867: POP
// until not tmp ;
13868: LD_VAR 0 2
13872: NOT
13873: IFFALSE 13726
// end ; end_of_file
13875: PPOPN 4
13877: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13878: LD_INT 0
13880: PPUSH
13881: PPUSH
13882: PPUSH
13883: PPUSH
// missionStage := 13 ;
13884: LD_ADDR_EXP 15
13888: PUSH
13889: LD_INT 13
13891: ST_TO_ADDR
// uc_side := 2 ;
13892: LD_ADDR_OWVAR 20
13896: PUSH
13897: LD_INT 2
13899: ST_TO_ADDR
// uc_nation := 2 ;
13900: LD_ADDR_OWVAR 21
13904: PUSH
13905: LD_INT 2
13907: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13908: LD_ADDR_EXP 92
13912: PUSH
13913: LD_STRING Omar
13915: PPUSH
13916: CALL_OW 25
13920: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13921: LD_EXP 92
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13933: LD_EXP 92
13937: PPUSH
13938: LD_INT 242
13940: PPUSH
13941: LD_INT 75
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13951: LD_ADDR_EXP 93
13955: PUSH
13956: LD_STRING Heike
13958: PPUSH
13959: CALL_OW 25
13963: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13964: LD_INT 14
13966: PPUSH
13967: LD_INT 3
13969: PPUSH
13970: LD_INT 1
13972: PPUSH
13973: LD_INT 27
13975: PPUSH
13976: LD_INT 100
13978: PPUSH
13979: CALL 69936 0 5
// veh := CreateVehicle ;
13983: LD_ADDR_VAR 0 3
13987: PUSH
13988: CALL_OW 45
13992: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13993: LD_VAR 0 3
13997: PPUSH
13998: LD_INT 1
14000: PPUSH
14001: CALL_OW 242
// SetDir ( veh , 4 ) ;
14005: LD_VAR 0 3
14009: PPUSH
14010: LD_INT 4
14012: PPUSH
14013: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14017: LD_VAR 0 3
14021: PPUSH
14022: LD_INT 241
14024: PPUSH
14025: LD_INT 72
14027: PPUSH
14028: LD_INT 0
14030: PPUSH
14031: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14035: LD_EXP 93
14039: PPUSH
14040: LD_VAR 0 3
14044: PPUSH
14045: CALL_OW 52
// if KhatamStatus then
14049: LD_EXP 8
14053: IFFALSE 14104
// begin Khatam := NewCharacter ( Khatam ) ;
14055: LD_ADDR_EXP 94
14059: PUSH
14060: LD_STRING Khatam
14062: PPUSH
14063: CALL_OW 25
14067: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14068: LD_EXP 94
14072: PPUSH
14073: LD_INT 245
14075: PPUSH
14076: LD_INT 78
14078: PPUSH
14079: LD_INT 3
14081: PPUSH
14082: LD_INT 0
14084: PPUSH
14085: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14089: LD_EXP 94
14093: PPUSH
14094: LD_INT 4
14096: PPUSH
14097: LD_INT 10
14099: PPUSH
14100: CALL_OW 237
// end ; for i = 1 to Difficulty do
14104: LD_ADDR_VAR 0 2
14108: PUSH
14109: DOUBLE
14110: LD_INT 1
14112: DEC
14113: ST_TO_ADDR
14114: LD_OWVAR 67
14118: PUSH
14119: FOR_TO
14120: IFFALSE 14186
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14122: LD_INT 0
14124: PPUSH
14125: LD_INT 7
14127: PUSH
14128: LD_OWVAR 67
14132: PLUS
14133: PPUSH
14134: CALL_OW 384
// un := CreateHuman ;
14138: LD_ADDR_VAR 0 4
14142: PUSH
14143: CALL_OW 44
14147: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14148: LD_VAR 0 4
14152: PPUSH
14153: LD_INT 28
14155: PUSH
14156: LD_INT 29
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 2
14170: MOD
14171: PUSH
14172: LD_INT 1
14174: PLUS
14175: ARRAY
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14119
14186: POP
14187: POP
// for i = 1 to 6 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 6
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14247
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 7
14209: PUSH
14210: LD_OWVAR 67
14214: PLUS
14215: PPUSH
14216: CALL_OW 381
// un := CreateHuman ;
14220: LD_ADDR_VAR 0 4
14224: PUSH
14225: CALL_OW 44
14229: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14230: LD_VAR 0 4
14234: PPUSH
14235: LD_INT 28
14237: PPUSH
14238: LD_INT 0
14240: PPUSH
14241: CALL_OW 49
// end ;
14245: GO 14201
14247: POP
14248: POP
// for i = 1 to 3 do
14249: LD_ADDR_VAR 0 2
14253: PUSH
14254: DOUBLE
14255: LD_INT 1
14257: DEC
14258: ST_TO_ADDR
14259: LD_INT 3
14261: PUSH
14262: FOR_TO
14263: IFFALSE 14311
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14265: LD_INT 0
14267: PPUSH
14268: LD_INT 8
14270: PPUSH
14271: LD_INT 7
14273: PUSH
14274: LD_OWVAR 67
14278: PLUS
14279: PPUSH
14280: CALL_OW 380
// un := CreateHuman ;
14284: LD_ADDR_VAR 0 4
14288: PUSH
14289: CALL_OW 44
14293: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14294: LD_VAR 0 4
14298: PPUSH
14299: LD_INT 28
14301: PPUSH
14302: LD_INT 0
14304: PPUSH
14305: CALL_OW 49
// end ;
14309: GO 14262
14311: POP
14312: POP
// for i = 1 to 3 do
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: DOUBLE
14319: LD_INT 1
14321: DEC
14322: ST_TO_ADDR
14323: LD_INT 3
14325: PUSH
14326: FOR_TO
14327: IFFALSE 14417
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14329: LD_INT 14
14331: PPUSH
14332: LD_INT 2
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: LD_INT 28
14340: PPUSH
14341: LD_INT 80
14343: PPUSH
14344: CALL 69936 0 5
// veh := CreateVehicle ;
14348: LD_ADDR_VAR 0 3
14352: PUSH
14353: CALL_OW 45
14357: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 3
14365: PPUSH
14366: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 29
14377: PPUSH
14378: LD_INT 0
14380: PPUSH
14381: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14385: LD_INT 0
14387: PPUSH
14388: LD_INT 7
14390: PUSH
14391: LD_OWVAR 67
14395: PLUS
14396: PPUSH
14397: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14401: CALL_OW 44
14405: PPUSH
14406: LD_VAR 0 3
14410: PPUSH
14411: CALL_OW 52
// end ;
14415: GO 14326
14417: POP
14418: POP
// for i = 1 to 5 + Difficulty do
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: DOUBLE
14425: LD_INT 1
14427: DEC
14428: ST_TO_ADDR
14429: LD_INT 5
14431: PUSH
14432: LD_OWVAR 67
14436: PLUS
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14566
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14441: LD_INT 14
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: LD_INT 3
14449: PPUSH
14450: CALL_OW 12
14454: PPUSH
14455: LD_INT 1
14457: PPUSH
14458: LD_INT 28
14460: PUSH
14461: LD_INT 26
14463: PUSH
14464: LD_INT 27
14466: PUSH
14467: LD_INT 25
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: LD_VAR 0 2
14480: PUSH
14481: LD_INT 4
14483: MOD
14484: PUSH
14485: LD_INT 1
14487: PLUS
14488: ARRAY
14489: PPUSH
14490: LD_INT 80
14492: PPUSH
14493: CALL 69936 0 5
// veh := CreateVehicle ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: CALL_OW 45
14506: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14507: LD_VAR 0 3
14511: PPUSH
14512: LD_INT 4
14514: PPUSH
14515: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14519: LD_VAR 0 3
14523: PPUSH
14524: LD_INT 28
14526: PPUSH
14527: LD_INT 0
14529: PPUSH
14530: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14534: LD_INT 0
14536: PPUSH
14537: LD_INT 7
14539: PUSH
14540: LD_OWVAR 67
14544: PLUS
14545: PPUSH
14546: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14550: CALL_OW 44
14554: PPUSH
14555: LD_VAR 0 3
14559: PPUSH
14560: CALL_OW 52
// end ;
14564: GO 14438
14566: POP
14567: POP
// for i = 1 to 3 do
14568: LD_ADDR_VAR 0 2
14572: PUSH
14573: DOUBLE
14574: LD_INT 1
14576: DEC
14577: ST_TO_ADDR
14578: LD_INT 3
14580: PUSH
14581: FOR_TO
14582: IFFALSE 14642
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14584: LD_INT 14
14586: PPUSH
14587: LD_INT 3
14589: PPUSH
14590: LD_INT 5
14592: PPUSH
14593: LD_INT 29
14595: PPUSH
14596: LD_INT 80
14598: PPUSH
14599: CALL 69936 0 5
// veh := CreateVehicle ;
14603: LD_ADDR_VAR 0 3
14607: PUSH
14608: CALL_OW 45
14612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14613: LD_VAR 0 3
14617: PPUSH
14618: LD_INT 4
14620: PPUSH
14621: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14625: LD_VAR 0 3
14629: PPUSH
14630: LD_INT 28
14632: PPUSH
14633: LD_INT 0
14635: PPUSH
14636: CALL_OW 49
// end ;
14640: GO 14581
14642: POP
14643: POP
// end ;
14644: LD_VAR 0 1
14648: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14649: LD_INT 22
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: PPUSH
14659: CALL_OW 69
14663: IFFALSE 14963
14665: GO 14667
14667: DISABLE
14668: LD_INT 0
14670: PPUSH
14671: PPUSH
14672: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 22
14680: PUSH
14681: LD_INT 2
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: PUSH
14688: LD_INT 25
14690: PUSH
14691: LD_INT 4
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PPUSH
14702: CALL_OW 69
14706: PUSH
14707: LD_EXP 94
14711: DIFF
14712: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14713: LD_ADDR_VAR 0 2
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 2
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: PUSH
14733: LD_EXP 94
14737: PUSH
14738: LD_VAR 0 3
14742: UNION
14743: DIFF
14744: ST_TO_ADDR
// if Khatam then
14745: LD_EXP 94
14749: IFFALSE 14766
// ComMoveXY ( Khatam , 211 , 92 ) ;
14751: LD_EXP 94
14755: PPUSH
14756: LD_INT 211
14758: PPUSH
14759: LD_INT 92
14761: PPUSH
14762: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14766: LD_INT 197
14768: PPUSH
14769: LD_INT 80
14771: PPUSH
14772: LD_INT 2
14774: PPUSH
14775: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14779: LD_INT 213
14781: PPUSH
14782: LD_INT 90
14784: PPUSH
14785: LD_INT 2
14787: PPUSH
14788: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14792: LD_INT 215
14794: PPUSH
14795: LD_INT 129
14797: PPUSH
14798: LD_INT 2
14800: PPUSH
14801: CALL_OW 441
// if sci then
14805: LD_VAR 0 3
14809: IFFALSE 14830
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14811: LD_VAR 0 3
14815: PUSH
14816: LD_INT 1
14818: ARRAY
14819: PPUSH
14820: LD_INT 197
14822: PPUSH
14823: LD_INT 80
14825: PPUSH
14826: CALL_OW 158
// if sci > 1 then
14830: LD_VAR 0 3
14834: PUSH
14835: LD_INT 1
14837: GREATER
14838: IFFALSE 14859
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14840: LD_VAR 0 3
14844: PUSH
14845: LD_INT 2
14847: ARRAY
14848: PPUSH
14849: LD_INT 213
14851: PPUSH
14852: LD_INT 90
14854: PPUSH
14855: CALL_OW 158
// if sci > 2 then
14859: LD_VAR 0 3
14863: PUSH
14864: LD_INT 2
14866: GREATER
14867: IFFALSE 14888
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14869: LD_VAR 0 3
14873: PUSH
14874: LD_INT 3
14876: ARRAY
14877: PPUSH
14878: LD_INT 215
14880: PPUSH
14881: LD_INT 129
14883: PPUSH
14884: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14888: LD_INT 35
14890: PPUSH
14891: CALL_OW 67
// for i in tmp do
14895: LD_ADDR_VAR 0 1
14899: PUSH
14900: LD_VAR 0 2
14904: PUSH
14905: FOR_IN
14906: IFFALSE 14944
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14908: LD_VAR 0 1
14912: PPUSH
14913: LD_INT 81
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: PPUSH
14923: CALL_OW 69
14927: PPUSH
14928: LD_VAR 0 1
14932: PPUSH
14933: CALL_OW 74
14937: PPUSH
14938: CALL_OW 115
14942: GO 14905
14944: POP
14945: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14946: LD_INT 22
14948: PUSH
14949: LD_INT 2
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: CALL_OW 69
14960: NOT
14961: IFFALSE 14888
// end ; end_of_file
14963: PPOPN 3
14965: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14966: LD_INT 0
14968: PPUSH
14969: PPUSH
14970: PPUSH
14971: PPUSH
14972: PPUSH
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
// Video ( true ) ;
14977: LD_INT 1
14979: PPUSH
14980: CALL 101073 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_INT 7
14991: PPUSH
14992: LD_INT 0
14994: PPUSH
14995: CALL_OW 517
14999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15000: LD_ADDR_VAR 0 2
15004: PUSH
15005: DOUBLE
15006: LD_INT 1
15008: DEC
15009: ST_TO_ADDR
15010: LD_VAR 0 5
15014: PUSH
15015: LD_INT 1
15017: ARRAY
15018: PUSH
15019: FOR_TO
15020: IFFALSE 15065
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_VAR 0 5
15041: PUSH
15042: LD_INT 2
15044: ARRAY
15045: PUSH
15046: LD_VAR 0 2
15050: ARRAY
15051: PPUSH
15052: LD_INT 1
15054: PPUSH
15055: LD_INT 15
15057: NEG
15058: PPUSH
15059: CALL 100987 0 4
15063: GO 15019
15065: POP
15066: POP
// CenterNowOnUnits ( Powell ) ;
15067: LD_EXP 58
15071: PPUSH
15072: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15076: LD_ADDR_VAR 0 5
15080: PUSH
15081: LD_EXP 56
15085: PUSH
15086: EMPTY
15087: LIST
15088: ST_TO_ADDR
// if GirlNewVeh then
15089: LD_EXP 57
15093: IFFALSE 15111
// tmp := tmp ^ GirlNewVeh ;
15095: LD_ADDR_VAR 0 5
15099: PUSH
15100: LD_VAR 0 5
15104: PUSH
15105: LD_EXP 57
15109: ADD
15110: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15111: LD_VAR 0 5
15115: PPUSH
15116: LD_INT 60
15118: PPUSH
15119: LD_INT 109
15121: PPUSH
15122: CALL_OW 111
// if KappaStatus then
15126: LD_EXP 2
15130: IFFALSE 15182
// begin Say ( JMM , D1nT-JMM-1 ) ;
15132: LD_EXP 39
15136: PPUSH
15137: LD_STRING D1nT-JMM-1
15139: PPUSH
15140: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15144: LD_EXP 58
15148: PPUSH
15149: LD_STRING D1T-Pow-1
15151: PPUSH
15152: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15156: LD_EXP 39
15160: PPUSH
15161: LD_STRING D1T-JMM-2
15163: PPUSH
15164: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15168: LD_EXP 58
15172: PPUSH
15173: LD_STRING D1T-Pow-2
15175: PPUSH
15176: CALL_OW 88
// end else
15180: GO 15388
// if JMMGirlStatus then
15182: LD_EXP 6
15186: IFFALSE 15331
// begin Say ( JMM , D1T-JMM-1 ) ;
15188: LD_EXP 39
15192: PPUSH
15193: LD_STRING D1T-JMM-1
15195: PPUSH
15196: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15200: LD_EXP 58
15204: PPUSH
15205: LD_STRING D1T-Pow-1
15207: PPUSH
15208: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-3
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-3
15231: PPUSH
15232: CALL_OW 88
// if JMMGirl then
15236: LD_EXP 7
15240: IFFALSE 15329
// begin case JMMGirl of 1 :
15242: LD_EXP 7
15246: PUSH
15247: LD_INT 1
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15270
15255: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15256: LD_EXP 40
15260: PPUSH
15261: LD_STRING D1T-Joan-3
15263: PPUSH
15264: CALL_OW 88
15268: GO 15317
15270: LD_INT 2
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15293
15278: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15279: LD_EXP 42
15283: PPUSH
15284: LD_STRING D1T-Lisa-3
15286: PPUSH
15287: CALL_OW 88
15291: GO 15317
15293: LD_INT 3
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15316
15301: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15302: LD_EXP 54
15306: PPUSH
15307: LD_STRING D1T-Con-3
15309: PPUSH
15310: CALL_OW 88
15314: GO 15317
15316: POP
// Say ( Powell , D1T-Pow-4 ) ;
15317: LD_EXP 58
15321: PPUSH
15322: LD_STRING D1T-Pow-4
15324: PPUSH
15325: CALL_OW 88
// end ; end else
15329: GO 15388
// if not FastEnd then
15331: LD_EXP 11
15335: NOT
15336: IFFALSE 15364
// begin Say ( JMM , D1T-JMM-4 ) ;
15338: LD_EXP 39
15342: PPUSH
15343: LD_STRING D1T-JMM-4
15345: PPUSH
15346: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15350: LD_EXP 58
15354: PPUSH
15355: LD_STRING D1T-Pow-5
15357: PPUSH
15358: CALL_OW 88
// end else
15362: GO 15388
// begin Say ( JMM , D1nT-JMM-1 ) ;
15364: LD_EXP 39
15368: PPUSH
15369: LD_STRING D1nT-JMM-1
15371: PPUSH
15372: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15376: LD_EXP 58
15380: PPUSH
15381: LD_STRING D1nT-Pow-1
15383: PPUSH
15384: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15388: LD_INT 35
15390: PPUSH
15391: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15395: LD_EXP 56
15399: PPUSH
15400: CALL_OW 314
15404: NOT
15405: IFFALSE 15388
// ComExitVehicle ( JMM ) ;
15407: LD_EXP 39
15411: PPUSH
15412: CALL_OW 121
// wait ( 3 ) ;
15416: LD_INT 3
15418: PPUSH
15419: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_INT 60
15430: PPUSH
15431: LD_INT 94
15433: PPUSH
15434: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15438: LD_EXP 39
15442: PPUSH
15443: LD_EXP 58
15447: PPUSH
15448: CALL_OW 179
// if Joan then
15452: LD_EXP 40
15456: IFFALSE 15510
// begin ComExitVehicle ( Joan ) ;
15458: LD_EXP 40
15462: PPUSH
15463: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15467: LD_EXP 40
15471: PPUSH
15472: LD_INT 35
15474: PPUSH
15475: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_INT 65
15486: PPUSH
15487: LD_INT 104
15489: PPUSH
15490: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15494: LD_EXP 40
15498: PPUSH
15499: LD_EXP 39
15503: PPUSH
15504: CALL_OW 179
// end else
15508: GO 15644
// if Lisa and JMMGirl = 2 then
15510: LD_EXP 42
15514: PUSH
15515: LD_EXP 7
15519: PUSH
15520: LD_INT 2
15522: EQUAL
15523: AND
15524: IFFALSE 15578
// begin ComExitVehicle ( Lisa ) ;
15526: LD_EXP 42
15530: PPUSH
15531: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15535: LD_EXP 42
15539: PPUSH
15540: LD_INT 35
15542: PPUSH
15543: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_INT 65
15554: PPUSH
15555: LD_INT 104
15557: PPUSH
15558: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15562: LD_EXP 42
15566: PPUSH
15567: LD_EXP 39
15571: PPUSH
15572: CALL_OW 179
// end else
15576: GO 15644
// if Connie and JMMGirl = 3 then
15578: LD_EXP 54
15582: PUSH
15583: LD_EXP 7
15587: PUSH
15588: LD_INT 3
15590: EQUAL
15591: AND
15592: IFFALSE 15644
// begin ComExitVehicle ( Connie ) ;
15594: LD_EXP 54
15598: PPUSH
15599: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15603: LD_EXP 54
15607: PPUSH
15608: LD_INT 35
15610: PPUSH
15611: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_INT 65
15622: PPUSH
15623: LD_INT 104
15625: PPUSH
15626: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15630: LD_EXP 54
15634: PPUSH
15635: LD_EXP 39
15639: PPUSH
15640: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15644: LD_INT 35
15646: PPUSH
15647: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15651: LD_EXP 39
15655: PPUSH
15656: LD_EXP 58
15660: PPUSH
15661: CALL_OW 296
15665: PUSH
15666: LD_INT 6
15668: LESS
15669: IFFALSE 15644
// wait ( 0 0$0.5 ) ;
15671: LD_INT 18
15673: PPUSH
15674: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15678: LD_EXP 39
15682: PPUSH
15683: LD_STRING D1-JMM-1
15685: PPUSH
15686: CALL_OW 88
// async ;
15690: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15691: LD_EXP 58
15695: PPUSH
15696: LD_STRING D1-Pow-1
15698: PPUSH
15699: CALL_OW 88
// if not dialogue_skipped then
15703: LD_OWVAR 59
15707: NOT
15708: IFFALSE 15717
// wait ( 0 0$2 ) ;
15710: LD_INT 70
15712: PPUSH
15713: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15717: LD_INT 170
15719: PPUSH
15720: LD_INT 99
15722: PPUSH
15723: LD_INT 1
15725: PPUSH
15726: LD_INT 6
15728: NEG
15729: PPUSH
15730: CALL 100987 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15734: LD_INT 174
15736: PPUSH
15737: LD_INT 115
15739: PPUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_INT 6
15745: NEG
15746: PPUSH
15747: CALL 100987 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15751: LD_INT 169
15753: PPUSH
15754: LD_INT 71
15756: PPUSH
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 6
15762: NEG
15763: PPUSH
15764: CALL 100987 0 4
// if not dialogue_skipped then
15768: LD_OWVAR 59
15772: NOT
15773: IFFALSE 15792
// begin CenterOnXY ( 170 , 99 ) ;
15775: LD_INT 170
15777: PPUSH
15778: LD_INT 99
15780: PPUSH
15781: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15785: LD_INT 80
15787: PPUSH
15788: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15792: LD_INT 75
15794: PPUSH
15795: LD_INT 53
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: LD_INT 9
15803: NEG
15804: PPUSH
15805: CALL 100987 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15809: LD_INT 54
15811: PPUSH
15812: LD_INT 42
15814: PPUSH
15815: LD_INT 1
15817: PPUSH
15818: LD_INT 9
15820: NEG
15821: PPUSH
15822: CALL 100987 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15826: LD_INT 62
15828: PPUSH
15829: LD_INT 51
15831: PPUSH
15832: LD_INT 1
15834: PPUSH
15835: LD_INT 9
15837: NEG
15838: PPUSH
15839: CALL 100987 0 4
// if not dialogue_skipped then
15843: LD_OWVAR 59
15847: NOT
15848: IFFALSE 15867
// begin CenterOnXY ( 75 , 53 ) ;
15850: LD_INT 75
15852: PPUSH
15853: LD_INT 53
15855: PPUSH
15856: CALL_OW 84
// wait ( 0 0$4 ) ;
15860: LD_INT 140
15862: PPUSH
15863: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15867: LD_EXP 58
15871: PPUSH
15872: CALL_OW 87
// if not dialogue_skipped then
15876: LD_OWVAR 59
15880: NOT
15881: IFFALSE 15890
// wait ( 0 0$2 ) ;
15883: LD_INT 70
15885: PPUSH
15886: CALL_OW 67
// sync ;
15890: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15891: LD_EXP 39
15895: PPUSH
15896: LD_STRING D1-JMM-2
15898: PPUSH
15899: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15903: LD_EXP 58
15907: PPUSH
15908: LD_STRING D1-Pow-2
15910: PPUSH
15911: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15915: LD_EXP 39
15919: PPUSH
15920: LD_STRING D1-JMM-3
15922: PPUSH
15923: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15927: LD_EXP 58
15931: PPUSH
15932: LD_STRING D1-Pow-3
15934: PPUSH
15935: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15939: LD_EXP 39
15943: PPUSH
15944: LD_STRING D1-JMM-4
15946: PPUSH
15947: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15951: LD_EXP 58
15955: PPUSH
15956: LD_STRING D1-Pow-4
15958: PPUSH
15959: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15963: LD_EXP 39
15967: PPUSH
15968: LD_STRING D1-JMM-5
15970: PPUSH
15971: CALL_OW 88
// async ;
15975: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-5
15983: PPUSH
15984: CALL_OW 88
// if not dialogue_skipped then
15988: LD_OWVAR 59
15992: NOT
15993: IFFALSE 16002
// wait ( 0 0$3.6 ) ;
15995: LD_INT 126
15997: PPUSH
15998: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16002: LD_INT 134
16004: PPUSH
16005: LD_INT 210
16007: PPUSH
16008: LD_INT 1
16010: PPUSH
16011: LD_INT 11
16013: NEG
16014: PPUSH
16015: CALL 100987 0 4
// if not dialogue_skipped then
16019: LD_OWVAR 59
16023: NOT
16024: IFFALSE 16043
// begin CenterOnXY ( 134 , 210 ) ;
16026: LD_INT 134
16028: PPUSH
16029: LD_INT 210
16031: PPUSH
16032: CALL_OW 84
// wait ( 0 0$2 ) ;
16036: LD_INT 70
16038: PPUSH
16039: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16043: LD_INT 101
16045: PPUSH
16046: LD_INT 159
16048: PPUSH
16049: LD_INT 1
16051: PPUSH
16052: LD_INT 10
16054: NEG
16055: PPUSH
16056: CALL 100987 0 4
// if not dialogue_skipped then
16060: LD_OWVAR 59
16064: NOT
16065: IFFALSE 16084
// begin CenterOnXY ( 101 , 159 ) ;
16067: LD_INT 101
16069: PPUSH
16070: LD_INT 159
16072: PPUSH
16073: CALL_OW 84
// wait ( 0 0$2 ) ;
16077: LD_INT 70
16079: PPUSH
16080: CALL_OW 67
// end ; sync ;
16084: SYNC
// CenterNowOnUnits ( Powell ) ;
16085: LD_EXP 58
16089: PPUSH
16090: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: LD_INT 2
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: LD_INT 4
16110: PUSH
16111: LD_INT 5
16113: PUSH
16114: LD_INT 6
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: ST_TO_ADDR
// if not dialogue_skipped then
16125: LD_OWVAR 59
16129: NOT
16130: IFFALSE 16299
// begin game_speed := 4 ;
16132: LD_ADDR_OWVAR 65
16136: PUSH
16137: LD_INT 4
16139: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16140: LD_INT 210
16142: PPUSH
16143: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16147: LD_ADDR_VAR 0 7
16151: PUSH
16152: LD_STRING Q1
16154: PPUSH
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 98
16164: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16165: LD_ADDR_VAR 0 7
16169: PUSH
16170: LD_STRING Q1
16172: PPUSH
16173: LD_VAR 0 6
16177: PPUSH
16178: CALL_OW 98
16182: ST_TO_ADDR
// options = options diff dec ;
16183: LD_ADDR_VAR 0 6
16187: PUSH
16188: LD_VAR 0 6
16192: PUSH
16193: LD_VAR 0 7
16197: DIFF
16198: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16199: LD_VAR 0 7
16203: PPUSH
16204: LD_VAR 0 6
16208: PPUSH
16209: CALL 17771 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16213: LD_VAR 0 7
16217: PUSH
16218: LD_INT 5
16220: PUSH
16221: LD_INT 6
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: IN
16228: PUSH
16229: LD_VAR 0 6
16233: PUSH
16234: LD_INT 2
16236: EQUAL
16237: OR
16238: IFFALSE 16165
// if not ( dec in [ 5 , 6 ] ) then
16240: LD_VAR 0 7
16244: PUSH
16245: LD_INT 5
16247: PUSH
16248: LD_INT 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: IN
16255: NOT
16256: IFFALSE 16299
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16258: LD_ADDR_VAR 0 7
16262: PUSH
16263: LD_STRING Q1a
16265: PPUSH
16266: LD_INT 1
16268: PUSH
16269: LD_INT 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: CALL_OW 98
16280: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16281: LD_VAR 0 7
16285: PUSH
16286: LD_INT 4
16288: PLUS
16289: PPUSH
16290: LD_VAR 0 6
16294: PPUSH
16295: CALL 17771 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16299: LD_INT 81
16301: PPUSH
16302: LD_INT 127
16304: PPUSH
16305: CALL_OW 84
// amount := 5 ;
16309: LD_ADDR_VAR 0 8
16313: PUSH
16314: LD_INT 5
16316: ST_TO_ADDR
// macmilan_squad := [ ] ;
16317: LD_ADDR_VAR 0 9
16321: PUSH
16322: EMPTY
16323: ST_TO_ADDR
// if vip < amount then
16324: LD_EXP 59
16328: PUSH
16329: LD_VAR 0 8
16333: LESS
16334: IFFALSE 16378
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16336: LD_ADDR_VAR 0 5
16340: PUSH
16341: LD_EXP 59
16345: PUSH
16346: LD_INT 22
16348: PUSH
16349: LD_INT 4
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: UNION
16375: ST_TO_ADDR
16376: GO 16388
// tmp := vip ;
16378: LD_ADDR_VAR 0 5
16382: PUSH
16383: LD_EXP 59
16387: ST_TO_ADDR
// tmp := tmp diff Powell ;
16388: LD_ADDR_VAR 0 5
16392: PUSH
16393: LD_VAR 0 5
16397: PUSH
16398: LD_EXP 58
16402: DIFF
16403: ST_TO_ADDR
// if tmp < amount then
16404: LD_VAR 0 5
16408: PUSH
16409: LD_VAR 0 8
16413: LESS
16414: IFFALSE 16426
// amount := tmp ;
16416: LD_ADDR_VAR 0 8
16420: PUSH
16421: LD_VAR 0 5
16425: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16426: LD_VAR 0 5
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PPUSH
16435: CALL_OW 257
16439: PUSH
16440: LD_INT 2
16442: NONEQUAL
16443: IFFALSE 16505
// begin if IsInUnit ( tmp [ 1 ] ) then
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 310
16458: IFFALSE 16473
// ComExitBuilding ( tmp [ 1 ] ) ;
16460: LD_VAR 0 5
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16473: LD_VAR 0 5
16477: PUSH
16478: LD_INT 1
16480: ARRAY
16481: PPUSH
16482: LD_INT 387
16484: PPUSH
16485: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16489: LD_VAR 0 5
16493: PUSH
16494: LD_INT 1
16496: ARRAY
16497: PPUSH
16498: LD_INT 2
16500: PPUSH
16501: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_INT 82
16512: PPUSH
16513: LD_INT 129
16515: PPUSH
16516: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16520: LD_EXP 39
16524: PPUSH
16525: LD_EXP 58
16529: PPUSH
16530: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16534: LD_INT 22
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: PUSH
16549: LD_EXP 39
16553: DIFF
16554: PPUSH
16555: LD_INT 84
16557: PPUSH
16558: LD_INT 128
16560: PPUSH
16561: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 69
16579: PUSH
16580: LD_EXP 39
16584: DIFF
16585: PPUSH
16586: LD_EXP 39
16590: PPUSH
16591: CALL_OW 179
// for i = 1 to amount do
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: DOUBLE
16601: LD_INT 1
16603: DEC
16604: ST_TO_ADDR
16605: LD_VAR 0 8
16609: PUSH
16610: FOR_TO
16611: IFFALSE 16779
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16613: LD_ADDR_VAR 0 9
16617: PUSH
16618: LD_VAR 0 9
16622: PUSH
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: ADD
16634: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 2
16644: ARRAY
16645: PPUSH
16646: CALL_OW 310
16650: IFFALSE 16667
// AddComExitBuilding ( tmp [ i ] ) ;
16652: LD_VAR 0 5
16656: PUSH
16657: LD_VAR 0 2
16661: ARRAY
16662: PPUSH
16663: CALL_OW 182
// if i = 2 and JMMNewVeh then
16667: LD_VAR 0 2
16671: PUSH
16672: LD_INT 2
16674: EQUAL
16675: PUSH
16676: LD_EXP 56
16680: AND
16681: IFFALSE 16739
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 2
16692: ARRAY
16693: PPUSH
16694: LD_EXP 56
16698: PPUSH
16699: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16703: LD_VAR 0 5
16707: PUSH
16708: LD_VAR 0 2
16712: ARRAY
16713: PPUSH
16714: LD_INT 86
16716: PPUSH
16717: LD_INT 133
16719: PPUSH
16720: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16739: LD_VAR 0 5
16743: PUSH
16744: LD_VAR 0 2
16748: ARRAY
16749: PPUSH
16750: LD_INT 8
16752: PPUSH
16753: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: LD_EXP 39
16772: PPUSH
16773: CALL_OW 179
// end ;
16777: GO 16610
16779: POP
16780: POP
// if GirlNewVeh then
16781: LD_EXP 57
16785: IFFALSE 16799
// SetSide ( GirlNewVeh , 4 ) ;
16787: LD_EXP 57
16791: PPUSH
16792: LD_INT 4
16794: PPUSH
16795: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16799: LD_INT 35
16801: PPUSH
16802: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16806: LD_VAR 0 9
16810: PPUSH
16811: LD_INT 95
16813: PUSH
16814: LD_INT 9
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PPUSH
16821: CALL_OW 72
16825: PUSH
16826: LD_INT 0
16828: EQUAL
16829: PUSH
16830: LD_EXP 39
16834: PPUSH
16835: LD_INT 9
16837: PPUSH
16838: CALL_OW 308
16842: NOT
16843: AND
16844: IFFALSE 16799
// wait ( 0 0$2 ) ;
16846: LD_INT 70
16848: PPUSH
16849: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16853: LD_VAR 0 9
16857: PPUSH
16858: LD_INT 1
16860: PPUSH
16861: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16865: LD_INT 21
16867: PUSH
16868: LD_INT 2
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 92
16877: PUSH
16878: LD_INT 83
16880: PUSH
16881: LD_INT 130
16883: PUSH
16884: LD_INT 10
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PPUSH
16902: LD_INT 1
16904: PPUSH
16905: CALL_OW 235
// Video ( false ) ;
16909: LD_INT 0
16911: PPUSH
16912: CALL 101073 0 1
// ChangeMissionObjectives ( M1 ) ;
16916: LD_STRING M1
16918: PPUSH
16919: CALL_OW 337
// SaveForQuickRestart ;
16923: CALL_OW 22
// missionStart := true ;
16927: LD_ADDR_EXP 13
16931: PUSH
16932: LD_INT 1
16934: ST_TO_ADDR
// missionStage := 2 ;
16935: LD_ADDR_EXP 15
16939: PUSH
16940: LD_INT 2
16942: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16943: LD_INT 105
16945: PPUSH
16946: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16950: LD_ADDR_VAR 0 5
16954: PUSH
16955: LD_INT 22
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 21
16967: PUSH
16968: LD_INT 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PPUSH
16979: CALL_OW 69
16983: PUSH
16984: LD_EXP 58
16988: DIFF
16989: ST_TO_ADDR
// if not tmp then
16990: LD_VAR 0 5
16994: NOT
16995: IFFALSE 17010
// tmp := [ Powell ] ;
16997: LD_ADDR_VAR 0 5
17001: PUSH
17002: LD_EXP 58
17006: PUSH
17007: EMPTY
17008: LIST
17009: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17010: LD_ADDR_EXP 113
17014: PUSH
17015: LD_EXP 113
17019: PPUSH
17020: LD_INT 4
17022: PPUSH
17023: LD_INT 22
17025: PUSH
17026: LD_INT 4
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: PUSH
17033: LD_INT 23
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 3
17045: PUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 2
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PPUSH
17065: CALL_OW 69
17069: PUSH
17070: LD_EXP 58
17074: DIFF
17075: PPUSH
17076: CALL_OW 1
17080: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17081: LD_ADDR_VAR 0 4
17085: PUSH
17086: LD_INT 22
17088: PUSH
17089: LD_INT 4
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 34
17098: PUSH
17099: LD_INT 12
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: PPUSH
17110: CALL_OW 69
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 310
17132: IFFALSE 17147
// ComExitBuilding ( tmp [ 1 ] ) ;
17134: LD_VAR 0 5
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17147: LD_VAR 0 5
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PPUSH
17156: LD_VAR 0 4
17160: PPUSH
17161: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17165: LD_VAR 0 5
17169: PUSH
17170: LD_INT 1
17172: ARRAY
17173: PPUSH
17174: LD_INT 80
17176: PPUSH
17177: LD_INT 136
17179: PPUSH
17180: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17184: LD_VAR 0 5
17188: PUSH
17189: LD_INT 1
17191: ARRAY
17192: PPUSH
17193: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17197: LD_VAR 0 5
17201: PUSH
17202: LD_INT 1
17204: ARRAY
17205: PPUSH
17206: LD_INT 59
17208: PPUSH
17209: LD_INT 112
17211: PPUSH
17212: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17229: LD_EXP 40
17233: PUSH
17234: LD_EXP 40
17238: PPUSH
17239: CALL_OW 255
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: AND
17248: IFFALSE 17274
// begin Say ( Joan , D3W-Joan-1 ) ;
17250: LD_EXP 40
17254: PPUSH
17255: LD_STRING D3W-Joan-1
17257: PPUSH
17258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17262: LD_EXP 39
17266: PPUSH
17267: LD_STRING D3W-JMM-1
17269: PPUSH
17270: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17274: LD_EXP 42
17278: PUSH
17279: LD_EXP 42
17283: PPUSH
17284: CALL_OW 255
17288: PUSH
17289: LD_INT 1
17291: EQUAL
17292: AND
17293: PUSH
17294: LD_EXP 42
17298: PUSH
17299: LD_EXP 59
17303: IN
17304: NOT
17305: AND
17306: IFFALSE 17332
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17308: LD_EXP 42
17312: PPUSH
17313: LD_STRING D3W-Lisa-1
17315: PPUSH
17316: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17320: LD_EXP 39
17324: PPUSH
17325: LD_STRING D3W-JMM-1
17327: PPUSH
17328: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17332: LD_EXP 54
17336: PUSH
17337: LD_EXP 54
17341: PPUSH
17342: CALL_OW 255
17346: PUSH
17347: LD_INT 1
17349: EQUAL
17350: AND
17351: IFFALSE 17377
// begin Say ( Connie , D3W-Con-1 ) ;
17353: LD_EXP 54
17357: PPUSH
17358: LD_STRING D3W-Con-1
17360: PPUSH
17361: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17365: LD_EXP 39
17369: PPUSH
17370: LD_STRING D3W-JMM-1
17372: PPUSH
17373: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17377: LD_EXP 42
17381: PUSH
17382: LD_EXP 59
17386: IN
17387: PUSH
17388: LD_EXP 42
17392: PPUSH
17393: CALL_OW 255
17397: PUSH
17398: LD_INT 1
17400: EQUAL
17401: AND
17402: IFFALSE 17418
// Say ( Lisa , D3nW-Lisa-1 ) else
17404: LD_EXP 42
17408: PPUSH
17409: LD_STRING D3nW-Lisa-1
17411: PPUSH
17412: CALL_OW 88
17416: GO 17662
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17418: LD_EXP 45
17422: PUSH
17423: LD_EXP 59
17427: IN
17428: PUSH
17429: LD_EXP 45
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 1
17441: EQUAL
17442: AND
17443: IFFALSE 17459
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17445: LD_EXP 45
17449: PPUSH
17450: LD_STRING D3nW-Cyrus-1
17452: PPUSH
17453: CALL_OW 88
17457: GO 17662
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17459: LD_EXP 44
17463: PUSH
17464: LD_EXP 59
17468: IN
17469: PUSH
17470: LD_EXP 44
17474: PPUSH
17475: CALL_OW 255
17479: PUSH
17480: LD_INT 1
17482: EQUAL
17483: AND
17484: IFFALSE 17500
// Say ( Bobby , D3nW-Bobby-1 ) else
17486: LD_EXP 44
17490: PPUSH
17491: LD_STRING D3nW-Bobby-1
17493: PPUSH
17494: CALL_OW 88
17498: GO 17662
// if Gary in vip and GetSide ( Gary ) = 1 then
17500: LD_EXP 51
17504: PUSH
17505: LD_EXP 59
17509: IN
17510: PUSH
17511: LD_EXP 51
17515: PPUSH
17516: CALL_OW 255
17520: PUSH
17521: LD_INT 1
17523: EQUAL
17524: AND
17525: IFFALSE 17541
// Say ( Gary , D3nW-Gary-1 ) else
17527: LD_EXP 51
17531: PPUSH
17532: LD_STRING D3nW-Gary-1
17534: PPUSH
17535: CALL_OW 88
17539: GO 17662
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17541: LD_EXP 43
17545: PUSH
17546: LD_EXP 59
17550: IN
17551: PUSH
17552: LD_EXP 43
17556: PPUSH
17557: CALL_OW 255
17561: PUSH
17562: LD_INT 1
17564: EQUAL
17565: AND
17566: IFFALSE 17582
// Say ( Donaldson , D3nW-Don-1 ) else
17568: LD_EXP 43
17572: PPUSH
17573: LD_STRING D3nW-Don-1
17575: PPUSH
17576: CALL_OW 88
17580: GO 17662
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17582: LD_EXP 50
17586: PUSH
17587: LD_EXP 59
17591: IN
17592: PUSH
17593: LD_EXP 50
17597: PPUSH
17598: CALL_OW 255
17602: PUSH
17603: LD_INT 1
17605: EQUAL
17606: AND
17607: IFFALSE 17623
// Say ( Cornel , D3nW-Corn-1 ) else
17609: LD_EXP 50
17613: PPUSH
17614: LD_STRING D3nW-Corn-1
17616: PPUSH
17617: CALL_OW 88
17621: GO 17662
// if Frank in vip and GetSide ( Frank ) = 1 then
17623: LD_EXP 52
17627: PUSH
17628: LD_EXP 59
17632: IN
17633: PUSH
17634: LD_EXP 52
17638: PPUSH
17639: CALL_OW 255
17643: PUSH
17644: LD_INT 1
17646: EQUAL
17647: AND
17648: IFFALSE 17662
// Say ( Frank , D3nW-Frank-1 ) ;
17650: LD_EXP 52
17654: PPUSH
17655: LD_STRING D3nW-Frank-1
17657: PPUSH
17658: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17662: LD_EXP 59
17666: PPUSH
17667: LD_INT 22
17669: PUSH
17670: LD_INT 1
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: PPUSH
17677: CALL_OW 72
17681: IFFALSE 17707
// begin Say ( JMM , D3nW-JMM-1 ) ;
17683: LD_EXP 39
17687: PPUSH
17688: LD_STRING D3nW-JMM-1
17690: PPUSH
17691: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17695: LD_EXP 39
17699: PPUSH
17700: LD_STRING D3nW-JMM-1a
17702: PPUSH
17703: CALL_OW 88
// end ; t := 0 0$00 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_INT 0
17714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17715: LD_INT 35
17717: PPUSH
17718: CALL_OW 67
// t := t + 0 0$1 ;
17722: LD_ADDR_VAR 0 3
17726: PUSH
17727: LD_VAR 0 3
17731: PUSH
17732: LD_INT 35
17734: PLUS
17735: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17736: LD_INT 59
17738: PPUSH
17739: LD_INT 112
17741: PPUSH
17742: CALL_OW 428
17746: PUSH
17747: LD_VAR 0 3
17751: PUSH
17752: LD_INT 2100
17754: GREATER
17755: OR
17756: IFFALSE 17715
// activeAttacks := true ;
17758: LD_ADDR_EXP 16
17762: PUSH
17763: LD_INT 1
17765: ST_TO_ADDR
// end ;
17766: LD_VAR 0 1
17770: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17771: LD_INT 0
17773: PPUSH
// case question of 1 :
17774: LD_VAR 0 1
17778: PUSH
17779: LD_INT 1
17781: DOUBLE
17782: EQUAL
17783: IFTRUE 17787
17785: GO 17838
17787: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D2Mot-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17800: LD_EXP 58
17804: PPUSH
17805: LD_STRING D2Mot-Pow-1
17807: PPUSH
17808: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17812: LD_EXP 39
17816: PPUSH
17817: LD_STRING D2Mot-JMM-2
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17824: LD_EXP 58
17828: PPUSH
17829: LD_STRING D2Mot-Pow-2
17831: PPUSH
17832: CALL_OW 88
// end ; 2 :
17836: GO 18189
17838: LD_INT 2
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17922
17846: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17847: LD_EXP 39
17851: PPUSH
17852: LD_STRING D2Rus-JMM-1
17854: PPUSH
17855: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17859: LD_EXP 58
17863: PPUSH
17864: LD_STRING D2Rus-Pow-1
17866: PPUSH
17867: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17871: LD_EXP 39
17875: PPUSH
17876: LD_STRING D2Rus-JMM-2
17878: PPUSH
17879: CALL_OW 88
// if not ( 3 in list_of_q ) then
17883: LD_INT 3
17885: PUSH
17886: LD_VAR 0 2
17890: IN
17891: NOT
17892: IFFALSE 17908
// Say ( Powell , D2Rus-Pow-2 ) else
17894: LD_EXP 58
17898: PPUSH
17899: LD_STRING D2Rus-Pow-2
17901: PPUSH
17902: CALL_OW 88
17906: GO 17920
// Say ( Powell , D2Rus-Pow-2a ) ;
17908: LD_EXP 58
17912: PPUSH
17913: LD_STRING D2Rus-Pow-2a
17915: PPUSH
17916: CALL_OW 88
// end ; 3 :
17920: GO 18189
17922: LD_INT 3
17924: DOUBLE
17925: EQUAL
17926: IFTRUE 17930
17928: GO 18015
17930: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17931: LD_EXP 39
17935: PPUSH
17936: LD_STRING D2Leg-JMM-1
17938: PPUSH
17939: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17943: LD_EXP 58
17947: PPUSH
17948: LD_STRING D2Leg-Pow-1
17950: PPUSH
17951: CALL_OW 88
// if 2 in list_of_q then
17955: LD_INT 2
17957: PUSH
17958: LD_VAR 0 2
17962: IN
17963: IFFALSE 17989
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17965: LD_EXP 39
17969: PPUSH
17970: LD_STRING D2Leg-JMM-2
17972: PPUSH
17973: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17977: LD_EXP 58
17981: PPUSH
17982: LD_STRING D2Leg-Pow-2
17984: PPUSH
17985: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17989: LD_EXP 39
17993: PPUSH
17994: LD_STRING D2Leg-JMM-3
17996: PPUSH
17997: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18001: LD_EXP 58
18005: PPUSH
18006: LD_STRING D2Leg-Pow-3
18008: PPUSH
18009: CALL_OW 88
// end ; 4 :
18013: GO 18189
18015: LD_INT 4
18017: DOUBLE
18018: EQUAL
18019: IFTRUE 18023
18021: GO 18098
18023: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18024: LD_EXP 39
18028: PPUSH
18029: LD_STRING D2Ar-JMM-1
18031: PPUSH
18032: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18036: LD_EXP 58
18040: PPUSH
18041: LD_STRING D2Ar-Pow-1
18043: PPUSH
18044: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18048: LD_EXP 39
18052: PPUSH
18053: LD_STRING D2Ar-JMM-2
18055: PPUSH
18056: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18060: LD_EXP 58
18064: PPUSH
18065: LD_STRING D2Ar-Pow-2
18067: PPUSH
18068: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18072: LD_EXP 39
18076: PPUSH
18077: LD_STRING D2Ar-JMM-3
18079: PPUSH
18080: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18084: LD_EXP 58
18088: PPUSH
18089: LD_STRING D2Ar-Pow-3
18091: PPUSH
18092: CALL_OW 88
// end ; 5 :
18096: GO 18189
18098: LD_INT 5
18100: DOUBLE
18101: EQUAL
18102: IFTRUE 18106
18104: GO 18121
18106: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18107: LD_EXP 39
18111: PPUSH
18112: LD_STRING D2Conf-JMM-1
18114: PPUSH
18115: CALL_OW 88
18119: GO 18189
18121: LD_INT 6
18123: DOUBLE
18124: EQUAL
18125: IFTRUE 18129
18127: GO 18188
18129: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18130: LD_EXP 39
18134: PPUSH
18135: LD_STRING D2Com-JMM-1
18137: PPUSH
18138: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18142: LD_EXP 58
18146: PPUSH
18147: LD_STRING D2Com-Pow-1
18149: PPUSH
18150: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18154: LD_EXP 39
18158: PPUSH
18159: LD_STRING D2Com-JMM-2
18161: PPUSH
18162: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18166: LD_EXP 58
18170: PPUSH
18171: LD_STRING D2Com-Pow-2
18173: PPUSH
18174: CALL_OW 88
// powellAngerQuery := true ;
18178: LD_ADDR_EXP 36
18182: PUSH
18183: LD_INT 1
18185: ST_TO_ADDR
// end ; end ;
18186: GO 18189
18188: POP
// end ;
18189: LD_VAR 0 3
18193: RET
// every 0 0$5 trigger missionStart do var tmp ;
18194: LD_EXP 13
18198: IFFALSE 18481
18200: GO 18202
18202: DISABLE
18203: LD_INT 0
18205: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18206: LD_INT 35
18208: PPUSH
18209: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18213: LD_INT 14
18215: PPUSH
18216: LD_INT 22
18218: PUSH
18219: LD_INT 1
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: PPUSH
18226: CALL_OW 70
18230: PUSH
18231: LD_EXP 15
18235: PUSH
18236: LD_INT 2
18238: PUSH
18239: LD_INT 3
18241: PUSH
18242: LD_INT 4
18244: PUSH
18245: LD_INT 5
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: IN
18254: AND
18255: IFFALSE 18471
// begin powellAnger := powellAnger + 1 ;
18257: LD_ADDR_EXP 17
18261: PUSH
18262: LD_EXP 17
18266: PUSH
18267: LD_INT 1
18269: PLUS
18270: ST_TO_ADDR
// Video ( true ) ;
18271: LD_INT 1
18273: PPUSH
18274: CALL 101073 0 1
// CenterNowOnUnits ( tmp ) ;
18278: LD_VAR 0 1
18282: PPUSH
18283: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18287: LD_INT 14
18289: PPUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PPUSH
18300: CALL_OW 70
18304: PPUSH
18305: LD_INT 86
18307: PPUSH
18308: LD_INT 133
18310: PPUSH
18311: CALL_OW 111
// async ;
18315: ASYNC
// case powellAnger of 1 :
18316: LD_EXP 17
18320: PUSH
18321: LD_INT 1
18323: DOUBLE
18324: EQUAL
18325: IFTRUE 18329
18327: GO 18344
18329: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18330: LD_EXP 58
18334: PPUSH
18335: LD_STRING DBack1-Pow-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18391
18344: LD_INT 2
18346: DOUBLE
18347: EQUAL
18348: IFTRUE 18352
18350: GO 18367
18352: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18353: LD_EXP 58
18357: PPUSH
18358: LD_STRING DBack2-Pow-1
18360: PPUSH
18361: CALL_OW 88
18365: GO 18391
18367: LD_INT 3
18369: DOUBLE
18370: EQUAL
18371: IFTRUE 18375
18373: GO 18390
18375: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18376: LD_EXP 58
18380: PPUSH
18381: LD_STRING DBack3-Pow-1
18383: PPUSH
18384: CALL_OW 88
18388: GO 18391
18390: POP
// sync ;
18391: SYNC
// repeat wait ( 0 0$1 ) ;
18392: LD_INT 35
18394: PPUSH
18395: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18399: LD_INT 14
18401: PPUSH
18402: LD_INT 22
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 70
18416: PPUSH
18417: LD_INT 86
18419: PPUSH
18420: LD_INT 133
18422: PPUSH
18423: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18427: LD_INT 14
18429: PPUSH
18430: LD_INT 22
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: EMPTY
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 70
18444: NOT
18445: IFFALSE 18392
// if powellAnger >= 3 then
18447: LD_EXP 17
18451: PUSH
18452: LD_INT 3
18454: GREATEREQUAL
18455: IFFALSE 18464
// YouLost ( Dismissed ) ;
18457: LD_STRING Dismissed
18459: PPUSH
18460: CALL_OW 104
// Video ( false ) ;
18464: LD_INT 0
18466: PPUSH
18467: CALL 101073 0 1
// end ; until missionStage > 5 ;
18471: LD_EXP 15
18475: PUSH
18476: LD_INT 5
18478: GREATER
18479: IFFALSE 18206
// end ;
18481: PPOPN 1
18483: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18484: LD_EXP 13
18488: PUSH
18489: LD_INT 22
18491: PUSH
18492: LD_INT 4
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 21
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: EMPTY
18510: LIST
18511: LIST
18512: PPUSH
18513: CALL_OW 69
18517: PUSH
18518: LD_INT 4
18520: GREATEREQUAL
18521: AND
18522: PUSH
18523: LD_EXP 15
18527: PUSH
18528: LD_INT 2
18530: EQUAL
18531: AND
18532: IFFALSE 20355
18534: GO 18536
18536: DISABLE
18537: LD_INT 0
18539: PPUSH
18540: PPUSH
18541: PPUSH
18542: PPUSH
18543: PPUSH
18544: PPUSH
18545: PPUSH
18546: PPUSH
// begin missionStage := 3 ;
18547: LD_ADDR_EXP 15
18551: PUSH
18552: LD_INT 3
18554: ST_TO_ADDR
// retreat := false ;
18555: LD_ADDR_VAR 0 4
18559: PUSH
18560: LD_INT 0
18562: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18563: LD_ADDR_VAR 0 5
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 4
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18597: LD_ADDR_VAR 0 6
18601: PUSH
18602: LD_INT 22
18604: PUSH
18605: LD_INT 4
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 5
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: ST_TO_ADDR
// if not bar then
18631: LD_VAR 0 6
18635: NOT
18636: IFFALSE 18689
// begin repeat wait ( 0 0$1 ) ;
18638: LD_INT 35
18640: PPUSH
18641: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18645: LD_INT 22
18647: PUSH
18648: LD_INT 4
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: LD_INT 57
18660: PUSH
18661: EMPTY
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 30
18670: PUSH
18671: LD_INT 5
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: PPUSH
18683: CALL_OW 69
18687: IFFALSE 18638
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18689: LD_ADDR_VAR 0 6
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 4
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 30
18706: PUSH
18707: LD_INT 5
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PPUSH
18718: CALL_OW 69
18722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18723: LD_INT 35
18725: PPUSH
18726: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18730: LD_EXP 132
18734: PUSH
18735: LD_INT 4
18737: ARRAY
18738: PUSH
18739: LD_INT 4
18741: GREATEREQUAL
18742: IFFALSE 18723
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_INT 4
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: LD_INT 2
18761: PUSH
18762: LD_INT 25
18764: PUSH
18765: LD_INT 1
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: PUSH
18772: LD_INT 25
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PUSH
18782: LD_INT 25
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 25
18794: PUSH
18795: LD_INT 4
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 25
18804: PUSH
18805: LD_INT 5
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL_OW 69
18828: PUSH
18829: LD_EXP 58
18833: PUSH
18834: LD_EXP 59
18838: ADD
18839: DIFF
18840: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18841: LD_ADDR_VAR 0 3
18845: PUSH
18846: LD_VAR 0 2
18850: PPUSH
18851: LD_INT 26
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PPUSH
18861: CALL_OW 72
18865: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18866: LD_ADDR_VAR 0 2
18870: PUSH
18871: LD_VAR 0 2
18875: PUSH
18876: LD_VAR 0 3
18880: DIFF
18881: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18882: LD_ADDR_VAR 0 2
18886: PUSH
18887: LD_VAR 0 2
18891: PPUSH
18892: LD_INT 1
18894: PPUSH
18895: CALL 99607 0 2
18899: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_VAR 0 3
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 99607 0 2
18917: ST_TO_ADDR
// for i = 1 to 4 do
18918: LD_ADDR_VAR 0 1
18922: PUSH
18923: DOUBLE
18924: LD_INT 1
18926: DEC
18927: ST_TO_ADDR
18928: LD_INT 4
18930: PUSH
18931: FOR_TO
18932: IFFALSE 19098
// begin if tmp2 then
18934: LD_VAR 0 3
18938: IFFALSE 19019
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18940: LD_ADDR_EXP 18
18944: PUSH
18945: LD_EXP 18
18949: PPUSH
18950: LD_INT 1
18952: PPUSH
18953: LD_EXP 18
18957: PUSH
18958: LD_INT 1
18960: ARRAY
18961: PUSH
18962: LD_VAR 0 3
18966: PUSH
18967: LD_VAR 0 3
18971: ARRAY
18972: ADD
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18979: LD_VAR 0 3
18983: PUSH
18984: LD_VAR 0 3
18988: ARRAY
18989: PPUSH
18990: LD_INT 1
18992: PPUSH
18993: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_VAR 0 3
19011: PPUSH
19012: CALL_OW 3
19016: ST_TO_ADDR
// end else
19017: GO 19096
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19019: LD_ADDR_EXP 18
19023: PUSH
19024: LD_EXP 18
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: LD_EXP 18
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 2
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19058: LD_VAR 0 2
19062: PUSH
19063: LD_VAR 0 2
19067: ARRAY
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19076: LD_ADDR_VAR 0 2
19080: PUSH
19081: LD_VAR 0 2
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 3
19095: ST_TO_ADDR
// end ; end ;
19096: GO 18931
19098: POP
19099: POP
// if tmp2 then
19100: LD_VAR 0 3
19104: IFFALSE 19122
// tmp := tmp union tmp2 ;
19106: LD_ADDR_VAR 0 2
19110: PUSH
19111: LD_VAR 0 2
19115: PUSH
19116: LD_VAR 0 3
19120: UNION
19121: ST_TO_ADDR
// for i = 1 to 4 do
19122: LD_ADDR_VAR 0 1
19126: PUSH
19127: DOUBLE
19128: LD_INT 1
19130: DEC
19131: ST_TO_ADDR
19132: LD_INT 4
19134: PUSH
19135: FOR_TO
19136: IFFALSE 19185
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19138: LD_ADDR_EXP 18
19142: PUSH
19143: LD_EXP 18
19147: PPUSH
19148: LD_INT 2
19150: PPUSH
19151: LD_EXP 18
19155: PUSH
19156: LD_INT 2
19158: ARRAY
19159: PUSH
19160: LD_VAR 0 2
19164: PUSH
19165: LD_VAR 0 2
19169: PUSH
19170: LD_VAR 0 1
19174: MINUS
19175: ARRAY
19176: ADD
19177: PPUSH
19178: CALL_OW 1
19182: ST_TO_ADDR
19183: GO 19135
19185: POP
19186: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19187: LD_ADDR_EXP 113
19191: PUSH
19192: LD_EXP 113
19196: PPUSH
19197: LD_INT 4
19199: PPUSH
19200: LD_EXP 113
19204: PUSH
19205: LD_INT 4
19207: ARRAY
19208: PUSH
19209: LD_EXP 18
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: DIFF
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19224: LD_VAR 0 5
19228: PUSH
19229: LD_INT 1
19231: ARRAY
19232: PPUSH
19233: CALL_OW 313
19237: IFFALSE 19292
// begin for i in UnitsInside ( arm [ 1 ] ) do
19239: LD_ADDR_VAR 0 1
19243: PUSH
19244: LD_VAR 0 5
19248: PUSH
19249: LD_INT 1
19251: ARRAY
19252: PPUSH
19253: CALL_OW 313
19257: PUSH
19258: FOR_IN
19259: IFFALSE 19290
// begin ComExitBuilding ( i ) ;
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19270: LD_VAR 0 1
19274: PPUSH
19275: LD_VAR 0 6
19279: PUSH
19280: LD_INT 1
19282: ARRAY
19283: PPUSH
19284: CALL_OW 180
// end ;
19288: GO 19258
19290: POP
19291: POP
// end ; wait ( 0 0$3 ) ;
19292: LD_INT 105
19294: PPUSH
19295: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19299: LD_ADDR_VAR 0 1
19303: PUSH
19304: LD_EXP 18
19308: PUSH
19309: LD_INT 1
19311: ARRAY
19312: PUSH
19313: FOR_IN
19314: IFFALSE 19421
// begin if IsInUnit ( i ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 310
19325: IFFALSE 19336
// ComExitBuilding ( i ) ;
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 122
// if GetClass ( i ) <> 1 then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 257
19345: PUSH
19346: LD_INT 1
19348: NONEQUAL
19349: IFFALSE 19390
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19351: LD_VAR 0 1
19355: PPUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_INT 1
19376: PPUSH
19377: CALL_OW 183
// AddComExitBuilding ( i ) ;
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_INT 60
19397: PPUSH
19398: LD_INT 94
19400: PPUSH
19401: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19405: LD_VAR 0 1
19409: PPUSH
19410: LD_EXP 58
19414: PPUSH
19415: CALL_OW 179
// end ;
19419: GO 19313
19421: POP
19422: POP
// wait ( 0 0$15 ) ;
19423: LD_INT 525
19425: PPUSH
19426: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19430: LD_EXP 58
19434: PPUSH
19435: LD_STRING D4-Pow-1
19437: PPUSH
19438: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19442: LD_ADDR_VAR 0 2
19446: PUSH
19447: LD_EXP 18
19451: PUSH
19452: LD_INT 1
19454: ARRAY
19455: PPUSH
19456: LD_INT 26
19458: PUSH
19459: LD_INT 1
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PPUSH
19466: CALL_OW 72
19470: ST_TO_ADDR
// if tmp then
19471: LD_VAR 0 2
19475: IFFALSE 19493
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19477: LD_VAR 0 2
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_STRING D4-Sol1-1
19488: PPUSH
19489: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19493: LD_EXP 58
19497: PPUSH
19498: LD_STRING D4-Pow-2
19500: PPUSH
19501: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19505: LD_ADDR_VAR 0 1
19509: PUSH
19510: DOUBLE
19511: LD_INT 1
19513: DEC
19514: ST_TO_ADDR
19515: LD_EXP 18
19519: PUSH
19520: LD_INT 1
19522: ARRAY
19523: PUSH
19524: FOR_TO
19525: IFFALSE 19618
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PUSH
19536: LD_VAR 0 1
19540: ARRAY
19541: PPUSH
19542: LD_EXP 132
19546: PUSH
19547: LD_INT 4
19549: ARRAY
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19559: LD_ADDR_EXP 132
19563: PUSH
19564: LD_EXP 132
19568: PPUSH
19569: LD_INT 4
19571: PPUSH
19572: LD_EXP 132
19576: PUSH
19577: LD_INT 4
19579: ARRAY
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: CALL_OW 3
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19594: LD_INT 8
19596: PPUSH
19597: LD_EXP 18
19601: PUSH
19602: LD_INT 1
19604: ARRAY
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 471
// end ;
19616: GO 19524
19618: POP
19619: POP
// repeat wait ( 0 0$1 ) ;
19620: LD_INT 35
19622: PPUSH
19623: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19627: LD_EXP 18
19631: PUSH
19632: LD_INT 1
19634: ARRAY
19635: PPUSH
19636: LD_INT 55
19638: PUSH
19639: EMPTY
19640: LIST
19641: PPUSH
19642: CALL_OW 72
19646: PUSH
19647: LD_INT 4
19649: GREATEREQUAL
19650: IFFALSE 19620
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 69
19663: PPUSH
19664: LD_INT 94
19666: PPUSH
19667: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19671: LD_EXP 18
19675: PUSH
19676: LD_INT 1
19678: ARRAY
19679: PPUSH
19680: LD_INT 82
19682: PPUSH
19683: LD_INT 83
19685: PPUSH
19686: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19690: LD_EXP 18
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: LD_INT 77
19701: PPUSH
19702: LD_INT 69
19704: PPUSH
19705: CALL_OW 174
// repeat wait ( 3 ) ;
19709: LD_INT 3
19711: PPUSH
19712: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19716: LD_ADDR_VAR 0 1
19720: PUSH
19721: LD_EXP 18
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: FOR_IN
19731: IFFALSE 19867
// begin if GetLives ( i ) < 990 then
19733: LD_VAR 0 1
19737: PPUSH
19738: CALL_OW 256
19742: PUSH
19743: LD_INT 990
19745: LESS
19746: IFFALSE 19760
// SetLives ( i , 1000 ) ;
19748: LD_VAR 0 1
19752: PPUSH
19753: LD_INT 1000
19755: PPUSH
19756: CALL_OW 234
// if not IsInUnit ( i ) then
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 310
19769: NOT
19770: IFFALSE 19865
// begin if not HasTask ( i ) then
19772: LD_VAR 0 1
19776: PPUSH
19777: CALL_OW 314
19781: NOT
19782: IFFALSE 19799
// ComMoveXY ( i , 64 , 93 ) ;
19784: LD_VAR 0 1
19788: PPUSH
19789: LD_INT 64
19791: PPUSH
19792: LD_INT 93
19794: PPUSH
19795: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19799: LD_VAR 0 4
19803: NOT
19804: PUSH
19805: LD_VAR 0 1
19809: PPUSH
19810: CALL_OW 258
19814: PUSH
19815: LD_INT 1
19817: EQUAL
19818: AND
19819: IFFALSE 19865
// begin retreat := true ;
19821: LD_ADDR_VAR 0 4
19825: PUSH
19826: LD_INT 1
19828: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19841: LD_VAR 0 1
19845: PPUSH
19846: LD_STRING D4a-Sol1-1
19848: PPUSH
19849: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19853: LD_EXP 58
19857: PPUSH
19858: LD_STRING D4a-Pow-1
19860: PPUSH
19861: CALL_OW 88
// end ; end ; end ;
19865: GO 19730
19867: POP
19868: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19869: LD_EXP 18
19873: PUSH
19874: LD_INT 1
19876: ARRAY
19877: PPUSH
19878: LD_INT 95
19880: PUSH
19881: LD_INT 9
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 55
19893: PUSH
19894: EMPTY
19895: LIST
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: PUSH
19910: LD_INT 4
19912: GREATEREQUAL
19913: IFFALSE 19709
// for i in powellSquadAttack [ 1 ] do
19915: LD_ADDR_VAR 0 1
19919: PUSH
19920: LD_EXP 18
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PUSH
19929: FOR_IN
19930: IFFALSE 20066
// begin if GetTag ( i ) = 2 then
19932: LD_VAR 0 1
19936: PPUSH
19937: CALL_OW 110
19941: PUSH
19942: LD_INT 2
19944: EQUAL
19945: IFFALSE 20007
// begin ComMoveXY ( i , 60 , 94 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_INT 60
19954: PPUSH
19955: LD_INT 94
19957: PPUSH
19958: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_EXP 58
19971: PPUSH
19972: CALL_OW 179
// wait ( 0 0$3 ) ;
19976: LD_INT 105
19978: PPUSH
19979: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19983: LD_VAR 0 1
19987: PPUSH
19988: LD_STRING D4a-Sol1-2
19990: PPUSH
19991: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19995: LD_EXP 58
19999: PPUSH
20000: LD_STRING D4a-Pow-2
20002: PPUSH
20003: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20007: LD_VAR 0 1
20011: PPUSH
20012: LD_INT 0
20014: PPUSH
20015: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20019: LD_ADDR_EXP 113
20023: PUSH
20024: LD_EXP 113
20028: PPUSH
20029: LD_INT 4
20031: PPUSH
20032: LD_EXP 113
20036: PUSH
20037: LD_INT 4
20039: ARRAY
20040: PUSH
20041: LD_VAR 0 1
20045: UNION
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20052: LD_INT 8
20054: PPUSH
20055: LD_VAR 0 1
20059: PPUSH
20060: CALL_OW 472
// end ;
20064: GO 19929
20066: POP
20067: POP
// wait ( 4 4$00 ) ;
20068: LD_INT 8400
20070: PPUSH
20071: CALL_OW 67
// uc_side := 6 ;
20075: LD_ADDR_OWVAR 20
20079: PUSH
20080: LD_INT 6
20082: ST_TO_ADDR
// uc_nation := 3 ;
20083: LD_ADDR_OWVAR 21
20087: PUSH
20088: LD_INT 3
20090: ST_TO_ADDR
// ru := [ ] ;
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: EMPTY
20097: ST_TO_ADDR
// for i = 1 to 4 do
20098: LD_ADDR_VAR 0 1
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_INT 4
20110: PUSH
20111: FOR_TO
20112: IFFALSE 20213
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20114: LD_INT 22
20116: PPUSH
20117: LD_INT 1
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 43
20125: PUSH
20126: LD_INT 44
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PUSH
20133: LD_INT 1
20135: PPUSH
20136: LD_INT 2
20138: PPUSH
20139: CALL_OW 12
20143: ARRAY
20144: PPUSH
20145: LD_INT 89
20147: PPUSH
20148: CALL 69936 0 5
// un := CreateVehicle ;
20152: LD_ADDR_VAR 0 8
20156: PUSH
20157: CALL_OW 45
20161: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20162: LD_VAR 0 8
20166: PPUSH
20167: LD_INT 4
20169: PPUSH
20170: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20174: LD_VAR 0 8
20178: PPUSH
20179: LD_INT 136
20181: PPUSH
20182: LD_INT 90
20184: PPUSH
20185: LD_INT 8
20187: PPUSH
20188: LD_INT 0
20190: PPUSH
20191: CALL_OW 50
// ru := ru ^ un ;
20195: LD_ADDR_VAR 0 7
20199: PUSH
20200: LD_VAR 0 7
20204: PUSH
20205: LD_VAR 0 8
20209: ADD
20210: ST_TO_ADDR
// end ;
20211: GO 20111
20213: POP
20214: POP
// if ru then
20215: LD_VAR 0 7
20219: IFFALSE 20236
// ComAgressiveMove ( ru , 80 , 92 ) ;
20221: LD_VAR 0 7
20225: PPUSH
20226: LD_INT 80
20228: PPUSH
20229: LD_INT 92
20231: PPUSH
20232: CALL_OW 114
// wait ( 8 8$00 ) ;
20236: LD_INT 16800
20238: PPUSH
20239: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20243: LD_INT 4
20245: PPUSH
20246: LD_INT 3
20248: PUSH
20249: LD_INT 1
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 5
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: PUSH
20264: LD_INT 4
20266: PUSH
20267: LD_INT 1
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 6
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 1
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 7
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: LIST
20298: LIST
20299: PUSH
20300: LD_INT 3
20302: PUSH
20303: LD_INT 1
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 7
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 3
20320: PUSH
20321: LD_INT 1
20323: PUSH
20324: LD_INT 1
20326: PUSH
20327: LD_INT 5
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PPUSH
20343: CALL 58720 0 2
// missionStage := 4 ;
20347: LD_ADDR_EXP 15
20351: PUSH
20352: LD_INT 4
20354: ST_TO_ADDR
// end ;
20355: PPOPN 8
20357: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20358: LD_EXP 15
20362: PUSH
20363: LD_INT 4
20365: EQUAL
20366: PUSH
20367: LD_INT 22
20369: PUSH
20370: LD_INT 4
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 21
20379: PUSH
20380: LD_INT 2
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PPUSH
20391: CALL_OW 69
20395: PUSH
20396: LD_INT 5
20398: GREATEREQUAL
20399: AND
20400: IFFALSE 24505
20402: GO 20404
20404: DISABLE
20405: LD_INT 0
20407: PPUSH
20408: PPUSH
20409: PPUSH
20410: PPUSH
20411: PPUSH
20412: PPUSH
20413: PPUSH
20414: PPUSH
20415: PPUSH
20416: PPUSH
20417: PPUSH
20418: PPUSH
20419: PPUSH
// begin missionStage := 5 ;
20420: LD_ADDR_EXP 15
20424: PUSH
20425: LD_INT 5
20427: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20428: LD_ADDR_VAR 0 10
20432: PUSH
20433: LD_INT 22
20435: PUSH
20436: LD_INT 4
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: LD_INT 2
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 4
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: LD_INT 30
20458: PUSH
20459: LD_INT 5
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: LIST
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PPUSH
20475: CALL_OW 69
20479: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20480: LD_ADDR_VAR 0 6
20484: PUSH
20485: LD_INT 22
20487: PUSH
20488: LD_INT 4
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 21
20497: PUSH
20498: LD_INT 1
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 3
20507: PUSH
20508: LD_INT 25
20510: PUSH
20511: LD_INT 16
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 3
20524: PUSH
20525: LD_INT 25
20527: PUSH
20528: LD_INT 12
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: LIST
20543: LIST
20544: PPUSH
20545: CALL_OW 69
20549: PUSH
20550: LD_EXP 58
20554: DIFF
20555: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20556: LD_ADDR_VAR 0 9
20560: PUSH
20561: LD_INT 22
20563: PUSH
20564: LD_INT 4
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 30
20573: PUSH
20574: LD_INT 3
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: PPUSH
20585: CALL_OW 69
20589: PUSH
20590: LD_INT 1
20592: ARRAY
20593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20594: LD_INT 35
20596: PPUSH
20597: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20601: LD_EXP 132
20605: PUSH
20606: LD_INT 4
20608: ARRAY
20609: PUSH
20610: LD_INT 5
20612: GREATEREQUAL
20613: PUSH
20614: LD_EXP 132
20618: PUSH
20619: LD_INT 4
20621: ARRAY
20622: PPUSH
20623: LD_INT 58
20625: PUSH
20626: EMPTY
20627: LIST
20628: PPUSH
20629: CALL_OW 72
20633: PUSH
20634: LD_INT 5
20636: GREATEREQUAL
20637: AND
20638: IFFALSE 20594
// powellAllowRetreat := false ;
20640: LD_ADDR_EXP 19
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20648: LD_INT 700
20650: PPUSH
20651: CALL_OW 67
// activeAttacks := false ;
20655: LD_ADDR_EXP 16
20659: PUSH
20660: LD_INT 0
20662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20663: LD_INT 35
20665: PPUSH
20666: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20670: LD_INT 22
20672: PUSH
20673: LD_INT 6
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PPUSH
20680: CALL_OW 69
20684: PUSH
20685: LD_INT 0
20687: EQUAL
20688: IFFALSE 20663
// tmp := mc_vehicles [ 4 ] ;
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_EXP 132
20699: PUSH
20700: LD_INT 4
20702: ARRAY
20703: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20704: LD_ADDR_VAR 0 1
20708: PUSH
20709: DOUBLE
20710: LD_INT 1
20712: DEC
20713: ST_TO_ADDR
20714: LD_EXP 18
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20981
// begin for j in powellSquadAttack [ i ] do
20722: LD_ADDR_VAR 0 2
20726: PUSH
20727: LD_EXP 18
20731: PUSH
20732: LD_VAR 0 1
20736: ARRAY
20737: PUSH
20738: FOR_IN
20739: IFFALSE 20977
// begin forces := forces diff j ;
20741: LD_ADDR_VAR 0 6
20745: PUSH
20746: LD_VAR 0 6
20750: PUSH
20751: LD_VAR 0 2
20755: DIFF
20756: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20757: LD_VAR 0 2
20761: PPUSH
20762: LD_INT 1
20764: PPUSH
20765: CALL_OW 109
// wait ( 0 0$2 ) ;
20769: LD_INT 70
20771: PPUSH
20772: CALL_OW 67
// if IsInUnit ( j ) then
20776: LD_VAR 0 2
20780: PPUSH
20781: CALL_OW 310
20785: IFFALSE 20796
// ComExitBuilding ( j ) ;
20787: LD_VAR 0 2
20791: PPUSH
20792: CALL_OW 122
// if GetClass ( j ) <> 1 then
20796: LD_VAR 0 2
20800: PPUSH
20801: CALL_OW 257
20805: PUSH
20806: LD_INT 1
20808: NONEQUAL
20809: IFFALSE 20889
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20811: LD_VAR 0 10
20815: PUSH
20816: LD_INT 1
20818: ARRAY
20819: PPUSH
20820: CALL_OW 313
20824: PUSH
20825: LD_INT 5
20827: GREATEREQUAL
20828: IFFALSE 20850
// AddComEnterUnit ( j , arm [ 2 ] ) else
20830: LD_VAR 0 2
20834: PPUSH
20835: LD_VAR 0 10
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: PPUSH
20844: CALL_OW 180
20848: GO 20868
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20850: LD_VAR 0 2
20854: PPUSH
20855: LD_VAR 0 10
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20868: LD_VAR 0 2
20872: PPUSH
20873: LD_INT 1
20875: PPUSH
20876: CALL_OW 183
// AddComExitBuilding ( j ) ;
20880: LD_VAR 0 2
20884: PPUSH
20885: CALL_OW 182
// end ; if i = 2 then
20889: LD_VAR 0 1
20893: PUSH
20894: LD_INT 2
20896: EQUAL
20897: IFFALSE 20914
// AddComMoveXY ( j , 61 , 93 ) ;
20899: LD_VAR 0 2
20903: PPUSH
20904: LD_INT 61
20906: PPUSH
20907: LD_INT 93
20909: PPUSH
20910: CALL_OW 171
// if i = 1 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 1
20921: EQUAL
20922: IFFALSE 20975
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_VAR 0 3
20933: PUSH
20934: LD_INT 1
20936: ARRAY
20937: PPUSH
20938: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_VAR 0 3
20951: PPUSH
20952: LD_INT 1
20954: PPUSH
20955: CALL_OW 3
20959: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20960: LD_VAR 0 2
20964: PPUSH
20965: LD_INT 69
20967: PPUSH
20968: LD_INT 94
20970: PPUSH
20971: CALL_OW 171
// end ; end ;
20975: GO 20738
20977: POP
20978: POP
// end ;
20979: GO 20719
20981: POP
20982: POP
// wait ( 0 0$55 ) ;
20983: LD_INT 1925
20985: PPUSH
20986: CALL_OW 67
// MC_Kill ( 4 ) ;
20990: LD_INT 4
20992: PPUSH
20993: CALL 35324 0 1
// tmp := UnitsInside ( fac ) ;
20997: LD_ADDR_VAR 0 3
21001: PUSH
21002: LD_VAR 0 9
21006: PPUSH
21007: CALL_OW 313
21011: ST_TO_ADDR
// if tmp then
21012: LD_VAR 0 3
21016: IFFALSE 21137
// for i in tmp do
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: LD_VAR 0 3
21027: PUSH
21028: FOR_IN
21029: IFFALSE 21135
// begin ComExitBuilding ( i ) ;
21031: LD_VAR 0 1
21035: PPUSH
21036: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21040: LD_VAR 0 10
21044: PUSH
21045: LD_INT 2
21047: ARRAY
21048: PPUSH
21049: CALL_OW 313
21053: PUSH
21054: LD_INT 6
21056: LESS
21057: IFFALSE 21079
// AddComEnterUnit ( i , arm [ 2 ] ) else
21059: LD_VAR 0 1
21063: PPUSH
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 2
21071: ARRAY
21072: PPUSH
21073: CALL_OW 180
21077: GO 21133
// if UnitsInside ( arm [ 1 ] ) < 6 then
21079: LD_VAR 0 10
21083: PUSH
21084: LD_INT 1
21086: ARRAY
21087: PPUSH
21088: CALL_OW 313
21092: PUSH
21093: LD_INT 6
21095: LESS
21096: IFFALSE 21118
// AddComEnterUnit ( i , arm [ 1 ] ) else
21098: LD_VAR 0 1
21102: PPUSH
21103: LD_VAR 0 10
21107: PUSH
21108: LD_INT 1
21110: ARRAY
21111: PPUSH
21112: CALL_OW 180
21116: GO 21133
// AddComMoveXY ( i , 37 , 68 ) ;
21118: LD_VAR 0 1
21122: PPUSH
21123: LD_INT 37
21125: PPUSH
21126: LD_INT 68
21128: PPUSH
21129: CALL_OW 171
// end ;
21133: GO 21028
21135: POP
21136: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21137: LD_ADDR_VAR 0 11
21141: PUSH
21142: LD_VAR 0 6
21146: PPUSH
21147: LD_INT 26
21149: PUSH
21150: LD_INT 1
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL_OW 72
21161: PUSH
21162: LD_EXP 59
21166: DIFF
21167: ST_TO_ADDR
// if not speaker then
21168: LD_VAR 0 11
21172: NOT
21173: IFFALSE 21200
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21175: LD_ADDR_VAR 0 11
21179: PUSH
21180: LD_VAR 0 6
21184: PPUSH
21185: LD_INT 26
21187: PUSH
21188: LD_INT 1
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PPUSH
21195: CALL_OW 72
21199: ST_TO_ADDR
// if speaker then
21200: LD_VAR 0 11
21204: IFFALSE 21220
// speaker := speaker [ 1 ] ;
21206: LD_ADDR_VAR 0 11
21210: PUSH
21211: LD_VAR 0 11
21215: PUSH
21216: LD_INT 1
21218: ARRAY
21219: ST_TO_ADDR
// Video ( true ) ;
21220: LD_INT 1
21222: PPUSH
21223: CALL 101073 0 1
// CenterNowOnUnits ( Powell ) ;
21227: LD_EXP 58
21231: PPUSH
21232: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21236: LD_ADDR_VAR 0 3
21240: PUSH
21241: LD_VAR 0 6
21245: PPUSH
21246: LD_INT 3
21248: PUSH
21249: LD_INT 25
21251: PUSH
21252: LD_INT 1
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PPUSH
21263: CALL_OW 72
21267: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21268: LD_ADDR_VAR 0 12
21272: PUSH
21273: LD_INT 22
21275: PUSH
21276: LD_INT 4
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 30
21285: PUSH
21286: LD_INT 32
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 58
21295: PUSH
21296: EMPTY
21297: LIST
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: LIST
21303: PPUSH
21304: CALL_OW 69
21308: ST_TO_ADDR
// for i = 1 to 6 do
21309: LD_ADDR_VAR 0 1
21313: PUSH
21314: DOUBLE
21315: LD_INT 1
21317: DEC
21318: ST_TO_ADDR
21319: LD_INT 6
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21464
// begin if IsInUnit ( tmp [ i ] ) then
21325: LD_VAR 0 3
21329: PUSH
21330: LD_VAR 0 1
21334: ARRAY
21335: PPUSH
21336: CALL_OW 310
21340: IFFALSE 21357
// ComExitBuilding ( tmp [ i ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21357: LD_VAR 0 3
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: PPUSH
21368: LD_VAR 0 10
21372: PUSH
21373: LD_INT 1
21375: ARRAY
21376: PPUSH
21377: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21381: LD_VAR 0 3
21385: PUSH
21386: LD_VAR 0 1
21390: ARRAY
21391: PPUSH
21392: LD_INT 1
21394: PPUSH
21395: CALL_OW 183
// if emp_towers then
21399: LD_VAR 0 12
21403: IFFALSE 21462
// begin AddComExitBuilding ( tmp [ i ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21420: LD_VAR 0 3
21424: PUSH
21425: LD_VAR 0 1
21429: ARRAY
21430: PPUSH
21431: LD_VAR 0 12
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21444: LD_ADDR_VAR 0 12
21448: PUSH
21449: LD_VAR 0 12
21453: PPUSH
21454: LD_INT 1
21456: PPUSH
21457: CALL_OW 3
21461: ST_TO_ADDR
// end ; end ;
21462: GO 21322
21464: POP
21465: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_EXP 18
21475: PUSH
21476: LD_INT 1
21478: ARRAY
21479: PUSH
21480: LD_EXP 18
21484: PUSH
21485: LD_INT 2
21487: ARRAY
21488: ADD
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21505: LD_ADDR_VAR 0 1
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 2
21517: ARRAY
21518: PUSH
21519: FOR_IN
21520: IFFALSE 21538
// ComTurnUnit ( i , Powell ) ;
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_EXP 58
21531: PPUSH
21532: CALL_OW 119
21536: GO 21519
21538: POP
21539: POP
// Say ( Powell , D5-Pow-1 ) ;
21540: LD_EXP 58
21544: PPUSH
21545: LD_STRING D5-Pow-1
21547: PPUSH
21548: CALL_OW 88
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21574
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: PPUSH
21567: LD_STRING D5-Sol2-1
21569: PPUSH
21570: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21574: LD_EXP 58
21578: PPUSH
21579: LD_STRING D5-Pow-2
21581: PPUSH
21582: CALL_OW 88
// if tmp > 1 then
21586: LD_VAR 0 3
21590: PUSH
21591: LD_INT 1
21593: GREATER
21594: IFFALSE 21612
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21596: LD_VAR 0 3
21600: PUSH
21601: LD_INT 2
21603: ARRAY
21604: PPUSH
21605: LD_STRING D5-Sol2-2
21607: PPUSH
21608: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21612: LD_EXP 58
21616: PPUSH
21617: LD_STRING D5-Pow-3
21619: PPUSH
21620: CALL_OW 88
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21631: LD_ADDR_VAR 0 3
21635: PUSH
21636: LD_EXP 18
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PUSH
21645: LD_EXP 18
21649: PUSH
21650: LD_INT 2
21652: ARRAY
21653: UNION
21654: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21655: LD_VAR 0 3
21659: PPUSH
21660: LD_INT 80
21662: PPUSH
21663: LD_INT 67
21665: PPUSH
21666: CALL_OW 114
// wait ( 0 0$2 ) ;
21670: LD_INT 70
21672: PPUSH
21673: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21677: LD_INT 79
21679: PPUSH
21680: LD_INT 72
21682: PPUSH
21683: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21687: LD_INT 35
21689: PPUSH
21690: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21694: LD_VAR 0 3
21698: PPUSH
21699: LD_INT 3
21701: PUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1000
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PPUSH
21716: CALL_OW 72
21720: IFFALSE 21687
// Say ( Powell , D5a-Pow-1 ) ;
21722: LD_EXP 58
21726: PPUSH
21727: LD_STRING D5a-Pow-1
21729: PPUSH
21730: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21734: LD_EXP 58
21738: PPUSH
21739: LD_STRING D5a-Pow-1a
21741: PPUSH
21742: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21746: LD_INT 10
21748: PPUSH
21749: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21753: LD_EXP 58
21757: PPUSH
21758: LD_STRING D5a-Pow-1b
21760: PPUSH
21761: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21765: LD_EXP 58
21769: PPUSH
21770: LD_STRING D5a-Pow-1c
21772: PPUSH
21773: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21777: LD_EXP 58
21781: PPUSH
21782: LD_STRING D5a-Pow-1d
21784: PPUSH
21785: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21789: LD_INT 35
21791: PPUSH
21792: CALL_OW 67
// if not HasTask ( tmp ) then
21796: LD_VAR 0 3
21800: PPUSH
21801: CALL_OW 314
21805: NOT
21806: IFFALSE 21823
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 80
21815: PPUSH
21816: LD_INT 67
21818: PPUSH
21819: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21823: LD_VAR 0 3
21827: PPUSH
21828: LD_INT 24
21830: PUSH
21831: LD_INT 1
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PPUSH
21838: CALL_OW 72
21842: NOT
21843: IFFALSE 21789
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21845: LD_ADDR_VAR 0 3
21849: PUSH
21850: LD_INT 22
21852: PUSH
21853: LD_INT 4
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 92
21862: PUSH
21863: LD_INT 60
21865: PUSH
21866: LD_INT 93
21868: PUSH
21869: LD_INT 10
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 3
21880: PUSH
21881: LD_INT 54
21883: PUSH
21884: EMPTY
21885: LIST
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: PPUSH
21896: CALL_OW 69
21900: PUSH
21901: LD_EXP 58
21905: DIFF
21906: ST_TO_ADDR
// if tmp then
21907: LD_VAR 0 3
21911: IFFALSE 21945
// for i in tmp do
21913: LD_ADDR_VAR 0 1
21917: PUSH
21918: LD_VAR 0 3
21922: PUSH
21923: FOR_IN
21924: IFFALSE 21943
// ComMoveXY ( i , 36 , 67 ) ;
21926: LD_VAR 0 1
21930: PPUSH
21931: LD_INT 36
21933: PPUSH
21934: LD_INT 67
21936: PPUSH
21937: CALL_OW 111
21941: GO 21923
21943: POP
21944: POP
// wait ( 0 0$3 ) ;
21945: LD_INT 105
21947: PPUSH
21948: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6-Sol3-1
21959: PPUSH
21960: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21964: LD_EXP 58
21968: PPUSH
21969: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21973: LD_EXP 58
21977: PPUSH
21978: LD_STRING D6-Pow-1
21980: PPUSH
21981: CALL_OW 88
// tmp := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// for i = 1 to 2 do
21992: LD_ADDR_VAR 0 1
21996: PUSH
21997: DOUBLE
21998: LD_INT 1
22000: DEC
22001: ST_TO_ADDR
22002: LD_INT 2
22004: PUSH
22005: FOR_TO
22006: IFFALSE 22120
// begin uc_side := 8 ;
22008: LD_ADDR_OWVAR 20
22012: PUSH
22013: LD_INT 8
22015: ST_TO_ADDR
// uc_nation := 2 ;
22016: LD_ADDR_OWVAR 21
22020: PUSH
22021: LD_INT 2
22023: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22024: LD_INT 14
22026: PPUSH
22027: LD_INT 3
22029: PPUSH
22030: LD_INT 2
22032: PPUSH
22033: LD_INT 29
22035: PPUSH
22036: LD_INT 100
22038: PPUSH
22039: CALL 69936 0 5
// veh := CreateVehicle ;
22043: LD_ADDR_VAR 0 13
22047: PUSH
22048: CALL_OW 45
22052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22053: LD_VAR 0 13
22057: PPUSH
22058: LD_INT 4
22060: PPUSH
22061: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22065: LD_VAR 0 13
22069: PPUSH
22070: LD_INT 99
22072: PPUSH
22073: LD_INT 83
22075: PPUSH
22076: LD_INT 6
22078: PPUSH
22079: LD_INT 0
22081: PPUSH
22082: CALL_OW 50
// wait ( 3 ) ;
22086: LD_INT 3
22088: PPUSH
22089: CALL_OW 67
// Connect ( veh ) ;
22093: LD_VAR 0 13
22097: PPUSH
22098: CALL 72991 0 1
// tmp := tmp ^ veh ;
22102: LD_ADDR_VAR 0 3
22106: PUSH
22107: LD_VAR 0 3
22111: PUSH
22112: LD_VAR 0 13
22116: ADD
22117: ST_TO_ADDR
// end ;
22118: GO 22005
22120: POP
22121: POP
// wait ( 0 0$1 ) ;
22122: LD_INT 35
22124: PPUSH
22125: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22129: LD_INT 99
22131: PPUSH
22132: LD_INT 83
22134: PPUSH
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 10
22140: PPUSH
22141: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22145: LD_INT 99
22147: PPUSH
22148: LD_INT 83
22150: PPUSH
22151: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22155: LD_VAR 0 11
22159: PPUSH
22160: LD_STRING D6-Sol3-2
22162: PPUSH
22163: CALL_OW 88
// async ;
22167: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22168: LD_EXP 58
22172: PPUSH
22173: LD_STRING D6-Pow-2
22175: PPUSH
22176: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22180: LD_VAR 0 3
22184: PUSH
22185: LD_INT 1
22187: ARRAY
22188: PPUSH
22189: LD_VAR 0 9
22193: PPUSH
22194: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22198: LD_VAR 0 3
22202: PUSH
22203: LD_INT 2
22205: ARRAY
22206: PPUSH
22207: LD_INT 22
22209: PUSH
22210: LD_INT 4
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: LD_INT 21
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 69
22235: PPUSH
22236: LD_VAR 0 3
22240: PUSH
22241: LD_INT 2
22243: ARRAY
22244: PPUSH
22245: CALL_OW 74
22249: PPUSH
22250: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22254: LD_EXP 58
22258: PPUSH
22259: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22263: LD_INT 99
22265: PPUSH
22266: LD_INT 83
22268: PPUSH
22269: LD_INT 1
22271: PPUSH
22272: CALL_OW 331
// repeat wait ( 4 ) ;
22276: LD_INT 4
22278: PPUSH
22279: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22283: LD_VAR 0 3
22287: PUSH
22288: LD_INT 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 256
22296: PUSH
22297: LD_INT 1000
22299: LESS
22300: IFFALSE 22318
// SetLives ( tmp [ 1 ] , 1000 ) ;
22302: LD_VAR 0 3
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PPUSH
22311: LD_INT 1000
22313: PPUSH
22314: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22318: LD_INT 22
22320: PUSH
22321: LD_INT 4
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: LD_INT 30
22330: PUSH
22331: LD_INT 3
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PPUSH
22342: CALL_OW 69
22346: PUSH
22347: LD_INT 0
22349: EQUAL
22350: IFFALSE 22276
// sync ;
22352: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22353: LD_EXP 58
22357: PPUSH
22358: LD_STRING D6a-Pow-1
22360: PPUSH
22361: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22365: LD_VAR 0 11
22369: PPUSH
22370: LD_STRING D6a-Sol3-1
22372: PPUSH
22373: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22377: LD_EXP 58
22381: PPUSH
22382: LD_STRING D6a-Pow-2
22384: PPUSH
22385: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22389: LD_VAR 0 11
22393: PPUSH
22394: LD_STRING D6a-Sol3-2
22396: PPUSH
22397: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22401: LD_EXP 58
22405: PPUSH
22406: LD_STRING D6a-Pow-3
22408: PPUSH
22409: CALL_OW 88
// powellCenterCameraMode := true ;
22413: LD_ADDR_EXP 20
22417: PUSH
22418: LD_INT 1
22420: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22421: LD_ADDR_VAR 0 1
22425: PUSH
22426: LD_INT 22
22428: PUSH
22429: LD_INT 8
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: PUSH
22436: LD_INT 25
22438: PUSH
22439: LD_INT 2
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PPUSH
22450: CALL_OW 69
22454: PUSH
22455: FOR_IN
22456: IFFALSE 22511
// begin SetTag ( i , 1 ) ;
22458: LD_VAR 0 1
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 109
// ComExitBuilding ( i ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 35
22486: PPUSH
22487: LD_INT 6
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_INT 53
22501: PPUSH
22502: LD_INT 4
22504: PPUSH
22505: CALL_OW 171
// end ;
22509: GO 22455
22511: POP
22512: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: LD_INT 22
22520: PUSH
22521: LD_INT 4
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PUSH
22528: LD_INT 21
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 3
22540: PUSH
22541: LD_INT 34
22543: PUSH
22544: LD_INT 12
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22565: LD_EXP 58
22569: PPUSH
22570: LD_VAR 0 3
22574: PPUSH
22575: LD_EXP 58
22579: PPUSH
22580: CALL_OW 74
22584: PPUSH
22585: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 88
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 100
22611: PPUSH
22612: LD_INT 75
22614: PPUSH
22615: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22619: LD_EXP 58
22623: PPUSH
22624: LD_INT 88
22626: PPUSH
22627: LD_INT 53
22629: PPUSH
22630: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22634: LD_INT 8
22636: PPUSH
22637: LD_EXP 58
22641: PPUSH
22642: CALL_OW 471
// repeat wait ( 3 ) ;
22646: LD_INT 3
22648: PPUSH
22649: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 92
22665: PUSH
22666: LD_INT 100
22668: PUSH
22669: LD_INT 75
22671: PUSH
22672: LD_INT 6
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PPUSH
22685: CALL_OW 69
22689: IFFALSE 22646
// async ;
22691: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22692: LD_EXP 58
22696: PPUSH
22697: LD_STRING D6b-Pow-1
22699: PPUSH
22700: CALL_OW 88
// repeat wait ( 3 ) ;
22704: LD_INT 3
22706: PPUSH
22707: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: PPUSH
22721: CALL_OW 256
22725: PUSH
22726: LD_INT 1000
22728: LESS
22729: IFFALSE 22748
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22731: LD_EXP 58
22735: PPUSH
22736: CALL_OW 310
22740: PPUSH
22741: LD_INT 1000
22743: PPUSH
22744: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22748: LD_EXP 58
22752: PPUSH
22753: CALL_OW 256
22757: PUSH
22758: LD_INT 1000
22760: LESS
22761: IFFALSE 22775
// SetLives ( Powell , 1000 ) ;
22763: LD_EXP 58
22767: PPUSH
22768: LD_INT 1000
22770: PPUSH
22771: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22775: LD_EXP 58
22779: PPUSH
22780: LD_EXP 63
22784: PPUSH
22785: CALL_OW 296
22789: PUSH
22790: LD_INT 5
22792: LESS
22793: PUSH
22794: LD_EXP 58
22798: PPUSH
22799: CALL_OW 310
22803: PPUSH
22804: LD_EXP 63
22808: PPUSH
22809: CALL_OW 296
22813: PUSH
22814: LD_INT 5
22816: LESS
22817: OR
22818: IFFALSE 22837
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: CALL_OW 310
22829: PPUSH
22830: LD_INT 100
22832: PPUSH
22833: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22837: LD_EXP 58
22841: PPUSH
22842: CALL_OW 310
22846: NOT
22847: IFFALSE 22704
// DoNotAttack ( 8 , powellBomb ) ;
22849: LD_INT 8
22851: PPUSH
22852: LD_EXP 63
22856: PPUSH
22857: CALL_OW 471
// game_speed := 4 ;
22861: LD_ADDR_OWVAR 65
22865: PUSH
22866: LD_INT 4
22868: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22869: LD_EXP 58
22873: PPUSH
22874: LD_STRING D6b-Pow-1a
22876: PPUSH
22877: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22881: LD_EXP 58
22885: PPUSH
22886: LD_EXP 63
22890: PPUSH
22891: CALL_OW 180
// sync ;
22895: SYNC
// repeat wait ( 0 0$1 ) ;
22896: LD_INT 35
22898: PPUSH
22899: CALL_OW 67
// until IsInUnit ( Powell ) ;
22903: LD_EXP 58
22907: PPUSH
22908: CALL_OW 310
22912: IFFALSE 22896
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22914: LD_INT 8
22916: PPUSH
22917: LD_EXP 58
22921: PPUSH
22922: CALL_OW 310
22926: PPUSH
22927: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 91
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 44
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 96
22968: PPUSH
22969: LD_INT 41
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 92
22983: PPUSH
22984: LD_INT 39
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 88
22998: PPUSH
22999: LD_INT 41
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 91
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 44
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 96
23043: PPUSH
23044: LD_INT 41
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 92
23058: PPUSH
23059: LD_INT 39
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 88
23073: PPUSH
23074: LD_INT 41
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 91
23088: PPUSH
23089: LD_INT 44
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 39
23106: PPUSH
23107: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23111: LD_EXP 58
23115: PPUSH
23116: LD_INT 93
23118: PPUSH
23119: LD_INT 36
23121: PPUSH
23122: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23126: LD_INT 122
23128: PPUSH
23129: CALL_OW 67
// game_speed := 4 ;
23133: LD_ADDR_OWVAR 65
23137: PUSH
23138: LD_INT 4
23140: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23141: LD_EXP 58
23145: PPUSH
23146: LD_STRING D6b-Pow-1b
23148: PPUSH
23149: CALL_OW 88
// tmp := [ ] ;
23153: LD_ADDR_VAR 0 3
23157: PUSH
23158: EMPTY
23159: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23160: LD_ADDR_VAR 0 5
23164: PUSH
23165: LD_INT 78
23167: PUSH
23168: LD_INT 47
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PUSH
23175: LD_INT 106
23177: PUSH
23178: LD_INT 53
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23189: LD_ADDR_VAR 0 1
23193: PUSH
23194: LD_INT 22
23196: PUSH
23197: LD_INT 8
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: PUSH
23204: LD_INT 21
23206: PUSH
23207: LD_INT 3
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 92
23216: PUSH
23217: LD_INT 90
23219: PUSH
23220: LD_INT 52
23222: PUSH
23223: LD_INT 12
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: PPUSH
23237: CALL_OW 69
23241: PUSH
23242: FOR_IN
23243: IFFALSE 23268
// tmp := tmp ^ UnitsInside ( i ) ;
23245: LD_ADDR_VAR 0 3
23249: PUSH
23250: LD_VAR 0 3
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 313
23264: ADD
23265: ST_TO_ADDR
23266: GO 23242
23268: POP
23269: POP
// for i in tmp do
23270: LD_ADDR_VAR 0 1
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23443
// begin dist := 9999 ;
23283: LD_ADDR_VAR 0 8
23287: PUSH
23288: LD_INT 9999
23290: ST_TO_ADDR
// _xy := [ ] ;
23291: LD_ADDR_VAR 0 7
23295: PUSH
23296: EMPTY
23297: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23298: LD_VAR 0 1
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL_OW 109
// ComExitBuilding ( i ) ;
23310: LD_VAR 0 1
23314: PPUSH
23315: CALL_OW 122
// for j in xy do
23319: LD_ADDR_VAR 0 2
23323: PUSH
23324: LD_VAR 0 5
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23412
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23332: LD_VAR 0 1
23336: PPUSH
23337: LD_VAR 0 2
23341: PUSH
23342: LD_INT 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 2
23350: PUSH
23351: LD_INT 2
23353: ARRAY
23354: PPUSH
23355: CALL_OW 297
23359: PUSH
23360: LD_VAR 0 8
23364: LESS
23365: IFFALSE 23410
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23367: LD_ADDR_VAR 0 8
23371: PUSH
23372: LD_VAR 0 1
23376: PPUSH
23377: LD_VAR 0 2
23381: PUSH
23382: LD_INT 1
23384: ARRAY
23385: PPUSH
23386: LD_VAR 0 2
23390: PUSH
23391: LD_INT 2
23393: ARRAY
23394: PPUSH
23395: CALL_OW 297
23399: ST_TO_ADDR
// _xy := j ;
23400: LD_ADDR_VAR 0 7
23404: PUSH
23405: LD_VAR 0 2
23409: ST_TO_ADDR
// end ;
23410: GO 23329
23412: POP
23413: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23414: LD_VAR 0 1
23418: PPUSH
23419: LD_VAR 0 7
23423: PUSH
23424: LD_INT 1
23426: ARRAY
23427: PPUSH
23428: LD_VAR 0 7
23432: PUSH
23433: LD_INT 2
23435: ARRAY
23436: PPUSH
23437: CALL_OW 171
// end ;
23441: GO 23280
23443: POP
23444: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: LD_INT 26
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 25
23467: PUSH
23468: LD_INT 1
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PPUSH
23479: CALL_OW 72
23483: ST_TO_ADDR
// if tmp2 < 2 then
23484: LD_VAR 0 4
23488: PUSH
23489: LD_INT 2
23491: LESS
23492: IFFALSE 23561
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23494: LD_ADDR_VAR 0 4
23498: PUSH
23499: LD_INT 22
23501: PUSH
23502: LD_INT 8
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: LD_INT 1
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 3
23521: PUSH
23522: LD_INT 25
23524: PUSH
23525: LD_INT 15
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: LIST
23540: PPUSH
23541: CALL_OW 69
23545: PUSH
23546: LD_EXP 60
23550: PUSH
23551: LD_EXP 61
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: DIFF
23560: ST_TO_ADDR
// if tmp2 then
23561: LD_VAR 0 4
23565: IFFALSE 23583
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23567: LD_VAR 0 4
23571: PUSH
23572: LD_INT 1
23574: ARRAY
23575: PPUSH
23576: LD_STRING D6b-ArSol1-1
23578: PPUSH
23579: CALL_OW 88
// async ;
23583: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23584: LD_EXP 58
23588: PPUSH
23589: LD_STRING D6b-Pow-2
23591: PPUSH
23592: CALL_OW 88
// wait ( 0 0$1 ) ;
23596: LD_INT 35
23598: PPUSH
23599: CALL_OW 67
// if tmp2 > 1 then
23603: LD_VAR 0 4
23607: PUSH
23608: LD_INT 1
23610: GREATER
23611: IFFALSE 23629
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23613: LD_VAR 0 4
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: LD_STRING D6b-ArSol2-1
23624: PPUSH
23625: CALL_OW 88
// sync ;
23629: SYNC
// repeat wait ( 5 ) ;
23630: LD_INT 5
23632: PPUSH
23633: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23637: LD_INT 93
23639: PPUSH
23640: LD_INT 36
23642: PPUSH
23643: CALL_OW 428
23647: PPUSH
23648: CALL_OW 255
23652: PUSH
23653: LD_INT 4
23655: EQUAL
23656: IFFALSE 23630
// DialogueOn ;
23658: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23662: LD_INT 10
23664: PPUSH
23665: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23669: LD_EXP 58
23673: PPUSH
23674: LD_STRING D6b-Pow-2a
23676: PPUSH
23677: CALL_OW 88
// DialogueOff ;
23681: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23685: LD_EXP 58
23689: PPUSH
23690: CALL_OW 310
23694: PPUSH
23695: LD_INT 332
23697: PPUSH
23698: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23702: LD_INT 93
23704: PPUSH
23705: LD_INT 35
23707: PPUSH
23708: LD_INT 1
23710: PPUSH
23711: LD_INT 6
23713: NEG
23714: PPUSH
23715: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23719: LD_INT 35
23721: PPUSH
23722: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23726: LD_INT 332
23728: PPUSH
23729: CALL_OW 256
23733: PUSH
23734: LD_INT 1000
23736: LESS
23737: PUSH
23738: LD_INT 332
23740: PPUSH
23741: CALL_OW 300
23745: AND
23746: IFFALSE 23758
// SetLives ( kozlov_fac , 0 ) ;
23748: LD_INT 332
23750: PPUSH
23751: LD_INT 0
23753: PPUSH
23754: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23758: LD_INT 332
23760: PPUSH
23761: CALL_OW 301
23765: PUSH
23766: LD_EXP 58
23770: PPUSH
23771: CALL_OW 301
23775: OR
23776: IFFALSE 23719
// game_speed := 4 ;
23778: LD_ADDR_OWVAR 65
23782: PUSH
23783: LD_INT 4
23785: ST_TO_ADDR
// powellCenterCameraMode := false ;
23786: LD_ADDR_EXP 20
23790: PUSH
23791: LD_INT 0
23793: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23794: LD_ADDR_VAR 0 1
23798: PUSH
23799: LD_VAR 0 3
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: LD_INT 8
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 25
23816: PUSH
23817: LD_INT 2
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 69
23832: UNION
23833: PUSH
23834: FOR_IN
23835: IFFALSE 23851
// SetTag ( i , 0 ) ;
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_INT 0
23844: PPUSH
23845: CALL_OW 109
23849: GO 23834
23851: POP
23852: POP
// wait ( 0 0$3 ) ;
23853: LD_INT 105
23855: PPUSH
23856: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23860: LD_INT 93
23862: PPUSH
23863: LD_INT 35
23865: PPUSH
23866: LD_INT 1
23868: PPUSH
23869: CALL_OW 331
// DialogueOn ;
23873: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23877: LD_VAR 0 11
23881: PPUSH
23882: LD_STRING D6c-Sol3-1
23884: PPUSH
23885: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23889: LD_INT 10
23891: PPUSH
23892: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23896: LD_EXP 39
23900: PPUSH
23901: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23905: LD_EXP 39
23909: PPUSH
23910: LD_STRING D6c-JMM-1
23912: PPUSH
23913: CALL_OW 88
// if Cyrus then
23917: LD_EXP 45
23921: IFFALSE 23935
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23923: LD_EXP 45
23927: PPUSH
23928: LD_STRING D6c-Cyrus-1
23930: PPUSH
23931: CALL_OW 88
// if Bobby then
23935: LD_EXP 44
23939: IFFALSE 23953
// Say ( Bobby , D6c-Bobby-1 ) ;
23941: LD_EXP 44
23945: PPUSH
23946: LD_STRING D6c-Bobby-1
23948: PPUSH
23949: CALL_OW 88
// if Cornel then
23953: LD_EXP 50
23957: IFFALSE 23971
// Say ( Cornel , D6c-Corn-1 ) ;
23959: LD_EXP 50
23963: PPUSH
23964: LD_STRING D6c-Corn-1
23966: PPUSH
23967: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23971: LD_ADDR_VAR 0 4
23975: PUSH
23976: LD_INT 2
23978: PUSH
23979: LD_INT 22
23981: PUSH
23982: LD_INT 1
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 22
23991: PUSH
23992: LD_INT 4
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 26
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 3
24016: PUSH
24017: LD_INT 25
24019: PUSH
24020: LD_INT 16
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 25
24029: PUSH
24030: LD_INT 12
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: PPUSH
24047: CALL_OW 69
24051: PUSH
24052: LD_VAR 0 11
24056: PUSH
24057: LD_EXP 39
24061: UNION
24062: PUSH
24063: LD_EXP 59
24067: UNION
24068: PUSH
24069: EMPTY
24070: LIST
24071: DIFF
24072: ST_TO_ADDR
// if tmp2 then
24073: LD_VAR 0 4
24077: IFFALSE 24095
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24079: LD_VAR 0 4
24083: PUSH
24084: LD_INT 1
24086: ARRAY
24087: PPUSH
24088: LD_STRING D6c-Sol1-1
24090: PPUSH
24091: CALL_OW 88
// if Lisa then
24095: LD_EXP 42
24099: IFFALSE 24113
// Say ( Lisa , D6c-Lisa-1 ) ;
24101: LD_EXP 42
24105: PPUSH
24106: LD_STRING D6c-Lisa-1
24108: PPUSH
24109: CALL_OW 88
// if Gary then
24113: LD_EXP 51
24117: IFFALSE 24131
// Say ( Gary , D6c-Gary-1 ) ;
24119: LD_EXP 51
24123: PPUSH
24124: LD_STRING D6c-Gary-1
24126: PPUSH
24127: CALL_OW 88
// if Donaldson then
24131: LD_EXP 43
24135: IFFALSE 24149
// Say ( Donaldson , D6c-Don-1 ) ;
24137: LD_EXP 43
24141: PPUSH
24142: LD_STRING D6c-Don-1
24144: PPUSH
24145: CALL_OW 88
// if tmp2 > 1 then
24149: LD_VAR 0 4
24153: PUSH
24154: LD_INT 1
24156: GREATER
24157: IFFALSE 24175
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24159: LD_VAR 0 4
24163: PUSH
24164: LD_INT 2
24166: ARRAY
24167: PPUSH
24168: LD_STRING D6c-Sol2-1
24170: PPUSH
24171: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24175: LD_VAR 0 11
24179: PPUSH
24180: LD_STRING D6c-Sol3-2
24182: PPUSH
24183: CALL_OW 88
// dwait ( 0 0$1 ) ;
24187: LD_INT 35
24189: PPUSH
24190: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24194: LD_EXP 39
24198: PPUSH
24199: LD_STRING D6c-JMM-2
24201: PPUSH
24202: CALL_OW 88
// DialogueOff ;
24206: CALL_OW 7
// Video ( false ) ;
24210: LD_INT 0
24212: PPUSH
24213: CALL 101073 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24217: LD_INT 22
24219: PUSH
24220: LD_INT 4
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PPUSH
24227: CALL_OW 69
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 4
24244: PPUSH
24245: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24249: LD_ADDR_VAR 0 1
24253: PUSH
24254: LD_INT 4
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: LD_INT 2
24262: PPUSH
24263: CALL 65175 0 3
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24306
// if GetTech ( i , 1 ) <> state_researched then
24271: LD_VAR 0 1
24275: PPUSH
24276: LD_INT 1
24278: PPUSH
24279: CALL_OW 321
24283: PUSH
24284: LD_INT 2
24286: NONEQUAL
24287: IFFALSE 24304
// SetTech ( i , 1 , state_researched ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 1
24296: PPUSH
24297: LD_INT 2
24299: PPUSH
24300: CALL_OW 322
24304: GO 24268
24306: POP
24307: POP
// missionStage := 6 ;
24308: LD_ADDR_EXP 15
24312: PUSH
24313: LD_INT 6
24315: ST_TO_ADDR
// activeAttacks := true ;
24316: LD_ADDR_EXP 16
24320: PUSH
24321: LD_INT 1
24323: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24324: LD_STRING M2
24326: PPUSH
24327: CALL_OW 337
// SaveForQuickRestart ;
24331: CALL_OW 22
// wait ( 0 0$40 ) ;
24335: LD_INT 1400
24337: PPUSH
24338: CALL_OW 67
// DialogueOn ;
24342: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24346: LD_EXP 62
24350: PPUSH
24351: LD_STRING D7-Friend-1
24353: PPUSH
24354: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24358: LD_EXP 39
24362: PPUSH
24363: LD_STRING D7-JMM-1
24365: PPUSH
24366: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24370: LD_EXP 62
24374: PPUSH
24375: LD_STRING D7-Friend-2
24377: PPUSH
24378: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24382: LD_EXP 39
24386: PPUSH
24387: LD_STRING D7-JMM-2
24389: PPUSH
24390: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24394: LD_EXP 62
24398: PPUSH
24399: LD_STRING D7-Friend-3
24401: PPUSH
24402: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24406: LD_EXP 39
24410: PPUSH
24411: LD_STRING D7-JMM-3
24413: PPUSH
24414: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24418: LD_EXP 62
24422: PPUSH
24423: LD_STRING D7-Friend-4
24425: PPUSH
24426: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24430: LD_EXP 39
24434: PPUSH
24435: LD_STRING D7-JMM-4
24437: PPUSH
24438: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24442: LD_EXP 62
24446: PPUSH
24447: LD_STRING D7-Friend-5
24449: PPUSH
24450: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24454: LD_EXP 39
24458: PPUSH
24459: LD_STRING D7-JMM-5
24461: PPUSH
24462: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24466: LD_EXP 62
24470: PPUSH
24471: LD_STRING D7-Friend-6
24473: PPUSH
24474: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24478: LD_EXP 39
24482: PPUSH
24483: LD_STRING D7-JMM-6
24485: PPUSH
24486: CALL_OW 88
// DialogueOff ;
24490: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24494: LD_STRING Mlegion
24496: PPUSH
24497: CALL_OW 337
// RebuildKozlovFactory ;
24501: CALL 4855 0 0
// end ;
24505: PPOPN 13
24507: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24508: LD_EXP 20
24512: PUSH
24513: LD_EXP 58
24517: PPUSH
24518: CALL_OW 300
24522: AND
24523: IFFALSE 24565
24525: GO 24527
24527: DISABLE
// begin enable ;
24528: ENABLE
// if IsInUnit ( Powell ) then
24529: LD_EXP 58
24533: PPUSH
24534: CALL_OW 310
24538: IFFALSE 24556
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24540: LD_EXP 58
24544: PPUSH
24545: CALL_OW 310
24549: PPUSH
24550: CALL_OW 85
24554: GO 24565
// CenterOnUnits ( Powell ) ;
24556: LD_EXP 58
24560: PPUSH
24561: CALL_OW 85
// end ;
24565: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24566: LD_INT 22
24568: PUSH
24569: LD_INT 8
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 34
24578: PUSH
24579: LD_INT 48
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 69
24594: IFFALSE 24868
24596: GO 24598
24598: DISABLE
24599: LD_INT 0
24601: PPUSH
24602: PPUSH
// begin if missionStage < 9 then
24603: LD_EXP 15
24607: PUSH
24608: LD_INT 9
24610: LESS
24611: IFFALSE 24621
// missionStage := 9 ;
24613: LD_ADDR_EXP 15
24617: PUSH
24618: LD_INT 9
24620: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24621: LD_ADDR_VAR 0 1
24625: PUSH
24626: LD_INT 22
24628: PUSH
24629: LD_INT 8
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 34
24638: PUSH
24639: LD_INT 48
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PPUSH
24650: CALL_OW 69
24654: PUSH
24655: LD_INT 1
24657: ARRAY
24658: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24659: LD_INT 175
24661: PPUSH
24662: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24666: LD_EXP 12
24670: PUSH
24671: LD_EXP 3
24675: PUSH
24676: LD_INT 0
24678: PUSH
24679: LD_INT 2
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: IN
24686: OR
24687: IFFALSE 24710
// target := [ 68 , 108 , 1 ] else
24689: LD_ADDR_VAR 0 2
24693: PUSH
24694: LD_INT 68
24696: PUSH
24697: LD_INT 108
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: LIST
24707: ST_TO_ADDR
24708: GO 24729
// target := [ 181 , 88 , 2 ] ;
24710: LD_ADDR_VAR 0 2
24714: PUSH
24715: LD_INT 181
24717: PUSH
24718: LD_INT 88
24720: PUSH
24721: LD_INT 2
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24729: LD_VAR 0 1
24733: PPUSH
24734: LD_VAR 0 2
24738: PUSH
24739: LD_INT 1
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 2
24747: PUSH
24748: LD_INT 2
24750: ARRAY
24751: PPUSH
24752: CALL_OW 176
// if target [ 3 ] = 1 then
24756: LD_VAR 0 2
24760: PUSH
24761: LD_INT 3
24763: ARRAY
24764: PUSH
24765: LD_INT 1
24767: EQUAL
24768: IFFALSE 24784
// SayRadio ( Kurt , D12-Kurt-1 ) else
24770: LD_EXP 60
24774: PPUSH
24775: LD_STRING D12-Kurt-1
24777: PPUSH
24778: CALL_OW 94
24782: GO 24808
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24784: LD_EXP 60
24788: PPUSH
24789: LD_STRING D12a-Kurt-1
24791: PPUSH
24792: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24796: LD_EXP 74
24800: PPUSH
24801: LD_STRING D12a-Roth-1
24803: PPUSH
24804: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24808: LD_INT 350
24810: PPUSH
24811: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24815: LD_VAR 0 1
24819: PPUSH
24820: LD_INT 22
24822: PUSH
24823: LD_INT 8
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 23
24832: PUSH
24833: LD_INT 2
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 30
24842: PUSH
24843: LD_INT 3
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: CALL_OW 228
// end ;
24868: PPOPN 2
24870: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24871: LD_EXP 60
24875: PPUSH
24876: CALL_OW 256
24880: PUSH
24881: LD_INT 999
24883: LESS
24884: PUSH
24885: LD_INT 22
24887: PUSH
24888: LD_INT 8
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: LD_INT 21
24897: PUSH
24898: LD_INT 1
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 23
24907: PUSH
24908: LD_INT 2
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: PUSH
24925: LD_INT 9
24927: PUSH
24928: LD_INT 8
24930: PUSH
24931: LD_INT 7
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: PUSH
24939: LD_OWVAR 67
24943: ARRAY
24944: LESSEQUAL
24945: OR
24946: PUSH
24947: LD_INT 22
24949: PUSH
24950: LD_INT 8
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 34
24959: PUSH
24960: LD_INT 48
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PPUSH
24971: CALL_OW 69
24975: NOT
24976: AND
24977: PUSH
24978: LD_EXP 60
24982: PPUSH
24983: CALL_OW 302
24987: AND
24988: PUSH
24989: LD_INT 5
24991: PPUSH
24992: LD_INT 22
24994: PUSH
24995: LD_INT 1
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PPUSH
25002: CALL_OW 70
25006: AND
25007: IFFALSE 25712
25009: GO 25011
25011: DISABLE
25012: LD_INT 0
25014: PPUSH
25015: PPUSH
25016: PPUSH
// begin DialogueOn ;
25017: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25021: LD_EXP 39
25025: PPUSH
25026: LD_STRING D13-JMM-1
25028: PPUSH
25029: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25033: LD_EXP 60
25037: PPUSH
25038: LD_STRING D13-Kurt-1
25040: PPUSH
25041: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25045: LD_EXP 39
25049: PPUSH
25050: LD_STRING D13-JMM-2
25052: PPUSH
25053: CALL_OW 88
// if FakeInfo then
25057: LD_EXP 12
25061: IFFALSE 25081
// begin Say ( Kurt , D13-Kurt-2 ) ;
25063: LD_EXP 60
25067: PPUSH
25068: LD_STRING D13-Kurt-2
25070: PPUSH
25071: CALL_OW 88
// DialogueOff ;
25075: CALL_OW 7
// exit ;
25079: GO 25712
// end ; if not KurtStatus then
25081: LD_EXP 3
25085: NOT
25086: IFFALSE 25102
// Say ( Kurt , D13-Kurt-2b ) else
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2b
25095: PPUSH
25096: CALL_OW 88
25100: GO 25114
// Say ( Kurt , D13-Kurt-2a ) ;
25102: LD_EXP 60
25106: PPUSH
25107: LD_STRING D13-Kurt-2a
25109: PPUSH
25110: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25114: LD_EXP 39
25118: PPUSH
25119: LD_STRING D13-JMM-3
25121: PPUSH
25122: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25126: LD_EXP 60
25130: PPUSH
25131: LD_STRING D13-Kurt-3
25133: PPUSH
25134: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25138: LD_EXP 39
25142: PPUSH
25143: LD_STRING D13-JMM-4
25145: PPUSH
25146: CALL_OW 88
// DialogueOff ;
25150: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25154: LD_STRING MlegionOut
25156: PPUSH
25157: CALL_OW 337
// legionDestroyed := true ;
25161: LD_ADDR_EXP 22
25165: PUSH
25166: LD_INT 1
25168: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25169: LD_INT 3
25171: PPUSH
25172: CALL 35324 0 1
// KillUnit ( Kozlov ) ;
25176: LD_EXP 61
25180: PPUSH
25181: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25185: LD_ADDR_VAR 0 1
25189: PUSH
25190: LD_INT 22
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 23
25202: PUSH
25203: LD_INT 3
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 3
25212: PUSH
25213: LD_INT 21
25215: PUSH
25216: LD_INT 33
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PPUSH
25232: CALL_OW 69
25236: PUSH
25237: FOR_IN
25238: IFFALSE 25251
// KillUnit ( i ) ;
25240: LD_VAR 0 1
25244: PPUSH
25245: CALL_OW 66
25249: GO 25237
25251: POP
25252: POP
// ChangeSideFog ( 8 , 1 ) ;
25253: LD_INT 8
25255: PPUSH
25256: LD_INT 1
25258: PPUSH
25259: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25263: LD_ADDR_VAR 0 2
25267: PUSH
25268: LD_INT 22
25270: PUSH
25271: LD_INT 8
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 21
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PPUSH
25292: CALL_OW 69
25296: PUSH
25297: LD_EXP 61
25301: PUSH
25302: LD_EXP 60
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: DIFF
25311: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25312: LD_VAR 0 2
25316: PUSH
25317: LD_INT 6
25319: PUSH
25320: LD_INT 5
25322: PUSH
25323: LD_INT 4
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: LIST
25330: PUSH
25331: LD_OWVAR 67
25335: ARRAY
25336: GREATEREQUAL
25337: IFFALSE 25511
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_INT 6
25346: PUSH
25347: LD_INT 5
25349: PUSH
25350: LD_INT 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_OWVAR 67
25362: ARRAY
25363: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25364: LD_ADDR_VAR 0 1
25368: PUSH
25369: DOUBLE
25370: LD_VAR 0 2
25374: PUSH
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 1
25382: PLUS
25383: MINUS
25384: INC
25385: ST_TO_ADDR
25386: LD_INT 1
25388: PUSH
25389: FOR_DOWNTO
25390: IFFALSE 25507
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25392: LD_ADDR_EXP 38
25396: PUSH
25397: LD_EXP 38
25401: PUSH
25402: LD_VAR 0 2
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: ADD
25413: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25414: LD_VAR 0 2
25418: PUSH
25419: LD_VAR 0 1
25423: ARRAY
25424: PPUSH
25425: CALL_OW 310
25429: IFFALSE 25446
// ComExitBuilding ( tmp [ i ] ) ;
25431: LD_VAR 0 2
25435: PUSH
25436: LD_VAR 0 1
25440: ARRAY
25441: PPUSH
25442: CALL_OW 122
// if IsInUnit ( i ) then
25446: LD_VAR 0 1
25450: PPUSH
25451: CALL_OW 310
25455: IFFALSE 25472
// ComExitVehicle ( tmp [ i ] ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25472: LD_VAR 0 2
25476: PUSH
25477: LD_VAR 0 1
25481: ARRAY
25482: PPUSH
25483: LD_INT 34
25485: PUSH
25486: LD_INT 0
25488: PPUSH
25489: LD_INT 6
25491: PPUSH
25492: CALL_OW 12
25496: PLUS
25497: PPUSH
25498: LD_INT 1
25500: PPUSH
25501: CALL_OW 171
// end ;
25505: GO 25389
25507: POP
25508: POP
// end else
25509: GO 25521
// x := tmp ;
25511: LD_ADDR_VAR 0 3
25515: PUSH
25516: LD_VAR 0 2
25520: ST_TO_ADDR
// for i := tmp downto tmp - x do
25521: LD_ADDR_VAR 0 1
25525: PUSH
25526: DOUBLE
25527: LD_VAR 0 2
25531: INC
25532: ST_TO_ADDR
25533: LD_VAR 0 2
25537: PUSH
25538: LD_VAR 0 3
25542: MINUS
25543: PUSH
25544: FOR_DOWNTO
25545: IFFALSE 25599
// begin if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitVehicle ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25579: LD_VAR 0 2
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: PPUSH
25590: LD_INT 1
25592: PPUSH
25593: CALL_OW 235
// end ;
25597: GO 25544
25599: POP
25600: POP
// SetSide ( Kurt , 1 ) ;
25601: LD_EXP 60
25605: PPUSH
25606: LD_INT 1
25608: PPUSH
25609: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25613: LD_INT 22
25615: PUSH
25616: LD_INT 8
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 21
25625: PUSH
25626: LD_INT 3
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PPUSH
25637: CALL_OW 69
25641: PPUSH
25642: LD_INT 1
25644: PPUSH
25645: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25649: LD_INT 8
25651: PPUSH
25652: LD_INT 1
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: LD_INT 1
25660: PPUSH
25661: CALL_OW 80
// wait ( 1 1$20 ) ;
25665: LD_INT 2800
25667: PPUSH
25668: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25672: LD_EXP 62
25676: PPUSH
25677: LD_INT 37
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 48
// wait ( 0 0$1 ) ;
25690: LD_INT 35
25692: PPUSH
25693: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 60
25704: PPUSH
25705: LD_INT 95
25707: PPUSH
25708: CALL_OW 111
// end ;
25712: PPOPN 3
25714: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25715: LD_EXP 22
25719: NOT
25720: PUSH
25721: LD_INT 22
25723: PUSH
25724: LD_INT 8
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 21
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PPUSH
25745: CALL_OW 69
25749: PUSH
25750: LD_INT 0
25752: EQUAL
25753: AND
25754: IFFALSE 25774
25756: GO 25758
25758: DISABLE
// begin legionDestroyed := true ;
25759: LD_ADDR_EXP 22
25763: PUSH
25764: LD_INT 1
25766: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25767: LD_STRING MlegionOut
25769: PPUSH
25770: CALL_OW 337
// end ;
25774: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25775: LD_EXP 38
25779: IFFALSE 25854
25781: GO 25783
25783: DISABLE
25784: LD_INT 0
25786: PPUSH
// begin enable ;
25787: ENABLE
// for i in legionEscapeUnits do
25788: LD_ADDR_VAR 0 1
25792: PUSH
25793: LD_EXP 38
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25852
// begin if IsInArea ( i , legionEscapeArea ) then
25801: LD_VAR 0 1
25805: PPUSH
25806: LD_INT 31
25808: PPUSH
25809: CALL_OW 308
25813: IFFALSE 25826
// RemoveUnit ( i ) else
25815: LD_VAR 0 1
25819: PPUSH
25820: CALL_OW 64
25824: GO 25850
// if not HasTask ( i ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: CALL_OW 314
25835: NOT
25836: IFFALSE 25850
// ComMoveToArea ( i , legionEscapeArea ) ;
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 31
25845: PPUSH
25846: CALL_OW 113
// end ;
25850: GO 25798
25852: POP
25853: POP
// end ;
25854: PPOPN 1
25856: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25857: LD_INT 1
25859: PPUSH
25860: LD_EXP 62
25864: PPUSH
25865: CALL_OW 292
25869: IFFALSE 26167
25871: GO 25873
25873: DISABLE
25874: LD_INT 0
25876: PPUSH
// begin wait ( 0 0$2 ) ;
25877: LD_INT 70
25879: PPUSH
25880: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25884: LD_EXP 62
25888: PPUSH
25889: CALL_OW 87
// DialogueOn ;
25893: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25897: LD_EXP 39
25901: PPUSH
25902: LD_STRING D14-JMM-1
25904: PPUSH
25905: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25909: LD_EXP 62
25913: PPUSH
25914: LD_STRING D14-Friend-1
25916: PPUSH
25917: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25921: LD_EXP 39
25925: PPUSH
25926: LD_STRING D14-JMM-2
25928: PPUSH
25929: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25933: LD_EXP 62
25937: PPUSH
25938: LD_STRING D14-Friend-2
25940: PPUSH
25941: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25945: LD_EXP 39
25949: PPUSH
25950: LD_STRING D14-JMM-3
25952: PPUSH
25953: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25957: LD_EXP 62
25961: PPUSH
25962: LD_STRING D14-Friend-3
25964: PPUSH
25965: CALL_OW 88
// DialogueOff ;
25969: CALL_OW 7
// dec = Query ( Q14 ) ;
25973: LD_ADDR_VAR 0 1
25977: PUSH
25978: LD_STRING Q14
25980: PPUSH
25981: CALL_OW 97
25985: ST_TO_ADDR
// if dec = 1 then
25986: LD_VAR 0 1
25990: PUSH
25991: LD_INT 1
25993: EQUAL
25994: IFFALSE 26028
// begin DialogueOn ;
25996: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26000: LD_EXP 39
26004: PPUSH
26005: LD_STRING D14a-JMM-1
26007: PPUSH
26008: CALL_OW 88
// DialogueOff ;
26012: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26016: LD_EXP 62
26020: PPUSH
26021: LD_INT 1
26023: PPUSH
26024: CALL_OW 235
// end ; if dec = 2 then
26028: LD_VAR 0 1
26032: PUSH
26033: LD_INT 2
26035: EQUAL
26036: IFFALSE 26089
// begin DialogueOn ;
26038: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26042: LD_EXP 39
26046: PPUSH
26047: LD_STRING D14b-JMM-1
26049: PPUSH
26050: CALL_OW 88
// DialogueOff ;
26054: CALL_OW 7
// wait ( 0 0$1 ) ;
26058: LD_INT 35
26060: PPUSH
26061: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26065: LD_EXP 62
26069: PPUSH
26070: LD_INT 9
26072: PPUSH
26073: LD_INT 2
26075: PPUSH
26076: CALL_OW 111
// AddComHold ( Friend ) ;
26080: LD_EXP 62
26084: PPUSH
26085: CALL_OW 200
// end ; if dec = 3 then
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 3
26096: EQUAL
26097: IFFALSE 26167
// begin DialogueOn ;
26099: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26103: LD_EXP 39
26107: PPUSH
26108: LD_STRING D14c-JMM-1
26110: PPUSH
26111: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26115: LD_EXP 62
26119: PPUSH
26120: LD_STRING D14c-Friend-1
26122: PPUSH
26123: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26127: LD_EXP 39
26131: PPUSH
26132: LD_STRING D14c-JMM-2
26134: PPUSH
26135: CALL_OW 88
// DialogueOff ;
26139: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26143: LD_EXP 62
26147: PPUSH
26148: LD_INT 9
26150: PPUSH
26151: LD_INT 2
26153: PPUSH
26154: CALL_OW 111
// AddComHold ( Friend ) ;
26158: LD_EXP 62
26162: PPUSH
26163: CALL_OW 200
// end ; end ;
26167: PPOPN 1
26169: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26170: LD_INT 9
26172: PPUSH
26173: LD_INT 2
26175: PPUSH
26176: CALL_OW 428
26180: PUSH
26181: LD_EXP 62
26185: EQUAL
26186: PUSH
26187: LD_EXP 62
26191: PPUSH
26192: CALL_OW 255
26196: PUSH
26197: LD_INT 8
26199: EQUAL
26200: AND
26201: IFFALSE 26215
26203: GO 26205
26205: DISABLE
// RemoveUnit ( Friend ) ;
26206: LD_EXP 62
26210: PPUSH
26211: CALL_OW 64
26215: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26216: LD_EXP 14
26220: PUSH
26221: LD_INT 31500
26223: GREATEREQUAL
26224: PUSH
26225: LD_EXP 7
26229: AND
26230: PUSH
26231: LD_EXP 2
26235: AND
26236: IFFALSE 26666
26238: GO 26240
26240: DISABLE
26241: LD_INT 0
26243: PPUSH
26244: PPUSH
26245: PPUSH
// begin missionStage := 7 ;
26246: LD_ADDR_EXP 15
26250: PUSH
26251: LD_INT 7
26253: ST_TO_ADDR
// uc_side = 1 ;
26254: LD_ADDR_OWVAR 20
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// uc_nation = 1 ;
26262: LD_ADDR_OWVAR 21
26266: PUSH
26267: LD_INT 1
26269: ST_TO_ADDR
// for i = 1 to 5 do
26270: LD_ADDR_VAR 0 1
26274: PUSH
26275: DOUBLE
26276: LD_INT 1
26278: DEC
26279: ST_TO_ADDR
26280: LD_INT 5
26282: PUSH
26283: FOR_TO
26284: IFFALSE 26380
// begin vc_engine = 3 ;
26286: LD_ADDR_OWVAR 39
26290: PUSH
26291: LD_INT 3
26293: ST_TO_ADDR
// vc_control = 3 ;
26294: LD_ADDR_OWVAR 38
26298: PUSH
26299: LD_INT 3
26301: ST_TO_ADDR
// vc_chassis = 3 ;
26302: LD_ADDR_OWVAR 37
26306: PUSH
26307: LD_INT 3
26309: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26310: LD_ADDR_OWVAR 40
26314: PUSH
26315: LD_INT 5
26317: PUSH
26318: LD_INT 9
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 1
26331: PPUSH
26332: LD_INT 3
26334: PPUSH
26335: CALL_OW 12
26339: ARRAY
26340: ST_TO_ADDR
// veh = CreateVehicle ;
26341: LD_ADDR_VAR 0 2
26345: PUSH
26346: CALL_OW 45
26350: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26351: LD_VAR 0 2
26355: PPUSH
26356: LD_INT 1
26358: PPUSH
26359: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26363: LD_VAR 0 2
26367: PPUSH
26368: LD_INT 19
26370: PPUSH
26371: LD_INT 0
26373: PPUSH
26374: CALL_OW 49
// end ;
26378: GO 26283
26380: POP
26381: POP
// vc_engine = 3 ;
26382: LD_ADDR_OWVAR 39
26386: PUSH
26387: LD_INT 3
26389: ST_TO_ADDR
// vc_control = 1 ;
26390: LD_ADDR_OWVAR 38
26394: PUSH
26395: LD_INT 1
26397: ST_TO_ADDR
// vc_chassis = 3 ;
26398: LD_ADDR_OWVAR 37
26402: PUSH
26403: LD_INT 3
26405: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26406: LD_ADDR_OWVAR 40
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: LD_INT 9
26416: PUSH
26417: LD_INT 7
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 1
26427: PPUSH
26428: LD_INT 3
26430: PPUSH
26431: CALL_OW 12
26435: ARRAY
26436: ST_TO_ADDR
// vehG = CreateVehicle ;
26437: LD_ADDR_VAR 0 3
26441: PUSH
26442: CALL_OW 45
26446: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26447: LD_VAR 0 3
26451: PPUSH
26452: LD_INT 1
26454: PPUSH
26455: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26459: LD_VAR 0 3
26463: PPUSH
26464: LD_INT 19
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 49
// if JMMGirl = 1 then
26474: LD_EXP 7
26478: PUSH
26479: LD_INT 1
26481: EQUAL
26482: IFFALSE 26538
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26484: LD_ADDR_EXP 40
26488: PUSH
26489: LD_STRING Joan
26491: PPUSH
26492: LD_INT 1
26494: PPUSH
26495: LD_STRING 14_
26497: PPUSH
26498: CALL 65112 0 3
26502: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26503: LD_EXP 40
26507: PPUSH
26508: LD_VAR 0 3
26512: PPUSH
26513: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26517: LD_VAR 0 3
26521: PPUSH
26522: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26526: LD_EXP 40
26530: PPUSH
26531: LD_STRING D10BW-Joan-1
26533: PPUSH
26534: CALL_OW 94
// end ; if JMMGirl = 2 then
26538: LD_EXP 7
26542: PUSH
26543: LD_INT 2
26545: EQUAL
26546: IFFALSE 26602
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26548: LD_ADDR_EXP 42
26552: PUSH
26553: LD_STRING Lisa
26555: PPUSH
26556: LD_INT 1
26558: PPUSH
26559: LD_STRING 14_
26561: PPUSH
26562: CALL 65112 0 3
26566: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26567: LD_EXP 42
26571: PPUSH
26572: LD_VAR 0 3
26576: PPUSH
26577: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26581: LD_VAR 0 3
26585: PPUSH
26586: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26590: LD_EXP 42
26594: PPUSH
26595: LD_STRING D10BW-Lisa-1
26597: PPUSH
26598: CALL_OW 94
// end ; if JMMGirl = 3 then
26602: LD_EXP 7
26606: PUSH
26607: LD_INT 3
26609: EQUAL
26610: IFFALSE 26666
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26612: LD_ADDR_EXP 54
26616: PUSH
26617: LD_STRING Connie
26619: PPUSH
26620: LD_INT 1
26622: PPUSH
26623: LD_STRING 14_
26625: PPUSH
26626: CALL 65112 0 3
26630: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26631: LD_EXP 54
26635: PPUSH
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26654: LD_EXP 54
26658: PPUSH
26659: LD_STRING D10BW-Con-1
26661: PPUSH
26662: CALL_OW 94
// end ; end ;
26666: PPOPN 3
26668: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26669: LD_EXP 14
26673: PUSH
26674: LD_INT 94500
26676: GREATEREQUAL
26677: IFFALSE 27089
26679: GO 26681
26681: DISABLE
26682: LD_INT 0
26684: PPUSH
26685: PPUSH
26686: PPUSH
// begin tmp := PrepareStevensSquad ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: CALL 2197 0 0
26696: ST_TO_ADDR
// if not tmp then
26697: LD_VAR 0 3
26701: NOT
26702: IFFALSE 26706
// exit ;
26704: GO 27089
// uc_side := 1 ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_INT 1
26713: ST_TO_ADDR
// uc_nation := 1 ;
26714: LD_ADDR_OWVAR 21
26718: PUSH
26719: LD_INT 1
26721: ST_TO_ADDR
// for i in tmp do
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: LD_VAR 0 3
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26830
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26735: LD_INT 3
26737: PPUSH
26738: LD_INT 3
26740: PPUSH
26741: LD_INT 1
26743: PPUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: PPUSH
26761: LD_INT 3
26763: PPUSH
26764: CALL_OW 12
26768: ARRAY
26769: PPUSH
26770: LD_INT 40
26772: PPUSH
26773: CALL 69936 0 5
// veh := CreateVehicle ;
26777: LD_ADDR_VAR 0 2
26781: PUSH
26782: CALL_OW 45
26786: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26787: LD_VAR 0 2
26791: PPUSH
26792: LD_INT 1
26794: PPUSH
26795: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26799: LD_VAR 0 2
26803: PPUSH
26804: LD_INT 19
26806: PPUSH
26807: LD_INT 0
26809: PPUSH
26810: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26814: LD_VAR 0 1
26818: PPUSH
26819: LD_VAR 0 2
26823: PPUSH
26824: CALL_OW 52
// end ;
26828: GO 26732
26830: POP
26831: POP
// missionStage := 8 ;
26832: LD_ADDR_EXP 15
26836: PUSH
26837: LD_INT 8
26839: ST_TO_ADDR
// DialogueOn ;
26840: CALL_OW 6
// if Stevens then
26844: LD_EXP 41
26848: IFFALSE 26962
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26850: LD_EXP 41
26854: PPUSH
26855: CALL_OW 310
26859: PPUSH
26860: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26864: LD_EXP 41
26868: PPUSH
26869: LD_STRING D8-Huck-1
26871: PPUSH
26872: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26876: LD_EXP 39
26880: PPUSH
26881: LD_STRING D8-JMM-1
26883: PPUSH
26884: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26888: LD_EXP 41
26892: PPUSH
26893: LD_STRING D8-Huck-2
26895: PPUSH
26896: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26900: LD_EXP 39
26904: PPUSH
26905: LD_STRING D8-JMM-2
26907: PPUSH
26908: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26912: LD_EXP 41
26916: PPUSH
26917: LD_STRING D8-Huck-3
26919: PPUSH
26920: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26924: LD_EXP 39
26928: PPUSH
26929: LD_STRING D8-JMM-3
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26936: LD_EXP 41
26940: PPUSH
26941: LD_STRING D8-Huck-4
26943: PPUSH
26944: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26948: LD_EXP 39
26952: PPUSH
26953: LD_STRING D8-JMM-4
26955: PPUSH
26956: CALL_OW 88
// end else
26960: GO 27072
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26962: LD_EXP 55
26966: PPUSH
26967: CALL_OW 310
26971: PPUSH
26972: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26976: LD_EXP 55
26980: PPUSH
26981: LD_STRING D8-Huck-1
26983: PPUSH
26984: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26988: LD_EXP 39
26992: PPUSH
26993: LD_STRING D8-JMM-1a
26995: PPUSH
26996: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27000: LD_EXP 55
27004: PPUSH
27005: LD_STRING D8-Huck-2
27007: PPUSH
27008: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27012: LD_EXP 39
27016: PPUSH
27017: LD_STRING D8-JMM-2
27019: PPUSH
27020: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27024: LD_EXP 55
27028: PPUSH
27029: LD_STRING D8-Huck-3
27031: PPUSH
27032: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27036: LD_EXP 39
27040: PPUSH
27041: LD_STRING D8-JMM-3
27043: PPUSH
27044: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27048: LD_EXP 55
27052: PPUSH
27053: LD_STRING D8-Huck-4
27055: PPUSH
27056: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27060: LD_EXP 39
27064: PPUSH
27065: LD_STRING D8-JMM-4
27067: PPUSH
27068: CALL_OW 88
// end ; DialogueOff ;
27072: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27076: LD_INT 25
27078: PPUSH
27079: LD_INT 1
27081: PPUSH
27082: LD_INT 1
27084: PPUSH
27085: CALL_OW 322
// end ;
27089: PPOPN 3
27091: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27092: LD_INT 1
27094: PPUSH
27095: LD_EXP 71
27099: PPUSH
27100: CALL_OW 292
27104: IFFALSE 27355
27106: GO 27108
27108: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27109: LD_EXP 71
27113: PPUSH
27114: CALL_OW 87
// DialogueOn ;
27118: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27122: LD_EXP 39
27126: PPUSH
27127: LD_STRING D10nB-JMM-1
27129: PPUSH
27130: CALL_OW 88
// if BurlakStatus = 1 then
27134: LD_EXP 9
27138: PUSH
27139: LD_INT 1
27141: EQUAL
27142: IFFALSE 27156
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27144: LD_EXP 70
27148: PPUSH
27149: LD_STRING D10nB-Vse-1a
27151: PPUSH
27152: CALL_OW 94
// end ; if BurlakStatus = 0 then
27156: LD_EXP 9
27160: PUSH
27161: LD_INT 0
27163: EQUAL
27164: IFFALSE 27178
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27166: LD_EXP 70
27170: PPUSH
27171: LD_STRING D10nB-Vse-1
27173: PPUSH
27174: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27178: LD_EXP 39
27182: PPUSH
27183: LD_STRING D10nB-JMM-2
27185: PPUSH
27186: CALL_OW 88
// if KappaStatus then
27190: LD_EXP 2
27194: IFFALSE 27208
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27196: LD_EXP 70
27200: PPUSH
27201: LD_STRING D10nB-Vse-5a
27203: PPUSH
27204: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27208: LD_EXP 2
27212: NOT
27213: PUSH
27214: LD_EXP 6
27218: PUSH
27219: LD_INT 0
27221: EQUAL
27222: AND
27223: IFFALSE 27351
// begin if JMMGirl = 1 then
27225: LD_EXP 7
27229: PUSH
27230: LD_INT 1
27232: EQUAL
27233: IFFALSE 27283
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27235: LD_EXP 70
27239: PPUSH
27240: LD_STRING D10nB-Vse-2
27242: PPUSH
27243: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27247: LD_EXP 39
27251: PPUSH
27252: LD_STRING D10nB-JMM-3
27254: PPUSH
27255: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27259: LD_EXP 70
27263: PPUSH
27264: LD_STRING D10nB-Vse-3
27266: PPUSH
27267: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27271: LD_EXP 39
27275: PPUSH
27276: LD_STRING D10nB-JMM-4
27278: PPUSH
27279: CALL_OW 88
// end ; if JMMGirl = 2 then
27283: LD_EXP 7
27287: PUSH
27288: LD_INT 2
27290: EQUAL
27291: IFFALSE 27317
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27293: LD_EXP 70
27297: PPUSH
27298: LD_STRING D10nB-Vse-4
27300: PPUSH
27301: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27305: LD_EXP 39
27309: PPUSH
27310: LD_STRING D10nB-JMM-5
27312: PPUSH
27313: CALL_OW 88
// end ; if JMMGirl = 3 then
27317: LD_EXP 7
27321: PUSH
27322: LD_INT 3
27324: EQUAL
27325: IFFALSE 27351
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27327: LD_EXP 70
27331: PPUSH
27332: LD_STRING D10nB-Vse-5
27334: PPUSH
27335: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27339: LD_EXP 39
27343: PPUSH
27344: LD_STRING D10nB-JMM-6
27346: PPUSH
27347: CALL_OW 88
// end ; end ; DialogueOff ;
27351: CALL_OW 7
// end ;
27355: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27356: LD_EXP 14
27360: PUSH
27361: LD_INT 115500
27363: GREATEREQUAL
27364: IFFALSE 27740
27366: GO 27368
27368: DISABLE
27369: LD_INT 0
27371: PPUSH
// begin missionStage := 10 ;
27372: LD_ADDR_EXP 15
27376: PUSH
27377: LD_INT 10
27379: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27380: LD_ADDR_VAR 0 1
27384: PUSH
27385: LD_INT 22
27387: PUSH
27388: LD_INT 1
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 23
27397: PUSH
27398: LD_INT 1
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 26
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 3
27417: PUSH
27418: LD_INT 25
27420: PUSH
27421: LD_INT 12
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 3
27434: PUSH
27435: LD_INT 25
27437: PUSH
27438: LD_INT 16
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: PPUSH
27456: CALL_OW 69
27460: PUSH
27461: LD_EXP 39
27465: PUSH
27466: LD_EXP 60
27470: PUSH
27471: LD_EXP 41
27475: PUSH
27476: LD_EXP 55
27480: PUSH
27481: LD_EXP 42
27485: PUSH
27486: LD_EXP 43
27490: PUSH
27491: LD_EXP 44
27495: PUSH
27496: LD_EXP 45
27500: PUSH
27501: LD_EXP 46
27505: PUSH
27506: LD_EXP 47
27510: PUSH
27511: LD_EXP 48
27515: PUSH
27516: LD_EXP 49
27520: PUSH
27521: LD_EXP 50
27525: PUSH
27526: LD_EXP 51
27530: PUSH
27531: LD_EXP 52
27535: PUSH
27536: LD_EXP 53
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: DIFF
27559: ST_TO_ADDR
// if not tmp and Brown then
27560: LD_VAR 0 1
27564: NOT
27565: PUSH
27566: LD_EXP 47
27570: AND
27571: IFFALSE 27586
// tmp := [ Brown ] ;
27573: LD_ADDR_VAR 0 1
27577: PUSH
27578: LD_EXP 47
27582: PUSH
27583: EMPTY
27584: LIST
27585: ST_TO_ADDR
// DialogueOn ;
27586: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27590: LD_VAR 0 1
27594: PUSH
27595: LD_INT 1
27597: ARRAY
27598: PPUSH
27599: LD_STRING D11-Sol1-1
27601: PPUSH
27602: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27606: LD_EXP 64
27610: PPUSH
27611: LD_STRING D11-Pla-1
27613: PPUSH
27614: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27618: LD_EXP 65
27622: PPUSH
27623: LD_STRING D11-Kov-1
27625: PPUSH
27626: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27630: LD_EXP 64
27634: PPUSH
27635: LD_STRING D11-Pla-2
27637: PPUSH
27638: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27642: LD_VAR 0 1
27646: PUSH
27647: LD_INT 1
27649: ARRAY
27650: PPUSH
27651: LD_STRING D11-Sol1-2
27653: PPUSH
27654: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27658: LD_EXP 39
27662: PPUSH
27663: LD_STRING D11-JMM-2
27665: PPUSH
27666: CALL_OW 88
// DialogueOff ;
27670: CALL_OW 7
// allowBehemothConstruct := true ;
27674: LD_ADDR_EXP 25
27678: PUSH
27679: LD_INT 1
27681: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27682: LD_STRING M4
27684: PPUSH
27685: CALL_OW 337
// BuildBehemoths ;
27689: CALL 7668 0 0
// repeat wait ( 15 15$00 ) ;
27693: LD_INT 31500
27695: PPUSH
27696: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27700: LD_EXP 27
27704: IFFALSE 27708
// break ;
27706: GO 27740
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27708: LD_INT 267
27710: PPUSH
27711: CALL_OW 274
27715: PPUSH
27716: LD_INT 1
27718: PPUSH
27719: CALL_OW 275
27723: PUSH
27724: LD_INT 1000
27726: GREATEREQUAL
27727: IFFALSE 27733
// BuildBehemoths ;
27729: CALL 7668 0 0
// until not behemothBuilders ;
27733: LD_EXP 73
27737: NOT
27738: IFFALSE 27693
// end ;
27740: PPOPN 1
27742: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27743: LD_EXP 73
27747: NOT
27748: PUSH
27749: LD_EXP 28
27753: NOT
27754: AND
27755: PUSH
27756: LD_EXP 25
27760: AND
27761: IFFALSE 27781
27763: GO 27765
27765: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27766: LD_STRING M4a
27768: PPUSH
27769: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27773: LD_ADDR_EXP 27
27777: PUSH
27778: LD_INT 1
27780: ST_TO_ADDR
// end ;
27781: END
// every 0 0$1 trigger behemothDone do
27782: LD_EXP 28
27786: IFFALSE 27798
27788: GO 27790
27790: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27791: LD_STRING M4b
27793: PPUSH
27794: CALL_OW 337
27798: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27799: LD_EXP 29
27803: NOT
27804: IFFALSE 28000
27806: GO 27808
27808: DISABLE
27809: LD_INT 0
27811: PPUSH
27812: PPUSH
// begin enable ;
27813: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27814: LD_ADDR_VAR 0 1
27818: PUSH
27819: LD_INT 3
27821: PPUSH
27822: CALL 101162 0 1
27826: ST_TO_ADDR
// if not tmp and not behemothDone then
27827: LD_VAR 0 1
27831: NOT
27832: PUSH
27833: LD_EXP 28
27837: NOT
27838: AND
27839: IFFALSE 27875
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27841: LD_ADDR_VAR 0 1
27845: PUSH
27846: LD_INT 22
27848: PUSH
27849: LD_INT 3
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 30
27858: PUSH
27859: LD_INT 37
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PPUSH
27870: CALL_OW 69
27874: ST_TO_ADDR
// if not tmp then
27875: LD_VAR 0 1
27879: NOT
27880: IFFALSE 27884
// exit ;
27882: GO 28000
// for i in tmp do
27884: LD_ADDR_VAR 0 2
27888: PUSH
27889: LD_VAR 0 1
27893: PUSH
27894: FOR_IN
27895: IFFALSE 27998
// if See ( 1 , i ) then
27897: LD_INT 1
27899: PPUSH
27900: LD_VAR 0 2
27904: PPUSH
27905: CALL_OW 292
27909: IFFALSE 27996
// begin if GetType ( i ) = unit_building then
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 247
27920: PUSH
27921: LD_INT 3
27923: EQUAL
27924: IFFALSE 27962
// begin CenterNowOnUnits ( i ) ;
27926: LD_VAR 0 2
27930: PPUSH
27931: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27935: LD_EXP 39
27939: PPUSH
27940: LD_STRING D17a-JMM-1
27942: PPUSH
27943: CALL_OW 88
// seeBehemoth := true ;
27947: LD_ADDR_EXP 29
27951: PUSH
27952: LD_INT 1
27954: ST_TO_ADDR
// disable ;
27955: DISABLE
// exit ;
27956: POP
27957: POP
27958: GO 28000
// end else
27960: GO 27996
// begin CenterNowOnUnits ( i ) ;
27962: LD_VAR 0 2
27966: PPUSH
27967: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27971: LD_EXP 39
27975: PPUSH
27976: LD_STRING D17b-JMM-1
27978: PPUSH
27979: CALL_OW 88
// seeBehemoth := true ;
27983: LD_ADDR_EXP 29
27987: PUSH
27988: LD_INT 1
27990: ST_TO_ADDR
// disable ;
27991: DISABLE
// exit ;
27992: POP
27993: POP
27994: GO 28000
// end ; end ;
27996: GO 27894
27998: POP
27999: POP
// end ;
28000: PPOPN 2
28002: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28003: LD_EXP 14
28007: PUSH
28008: LD_INT 123200
28010: GREATEREQUAL
28011: IFFALSE 29187
28013: GO 28015
28015: DISABLE
28016: LD_INT 0
28018: PPUSH
28019: PPUSH
28020: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28021: LD_INT 2
28023: PPUSH
28024: LD_INT 23
28026: PUSH
28027: LD_INT 3
28029: PUSH
28030: LD_INT 3
28032: PUSH
28033: LD_INT 48
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: PUSH
28042: EMPTY
28043: LIST
28044: PPUSH
28045: CALL 58768 0 2
// repeat wait ( 0 0$1 ) ;
28049: LD_INT 35
28051: PPUSH
28052: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28056: LD_INT 22
28058: PUSH
28059: LD_INT 3
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 34
28068: PUSH
28069: LD_INT 48
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PPUSH
28080: CALL_OW 69
28084: IFFALSE 28049
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28086: LD_ADDR_VAR 0 1
28090: PUSH
28091: LD_INT 22
28093: PUSH
28094: LD_INT 3
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 34
28103: PUSH
28104: LD_INT 48
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PPUSH
28115: CALL_OW 69
28119: PUSH
28120: LD_INT 1
28122: ARRAY
28123: ST_TO_ADDR
// missionStage := 12 ;
28124: LD_ADDR_EXP 15
28128: PUSH
28129: LD_INT 12
28131: ST_TO_ADDR
// platonovHasBomb := true ;
28132: LD_ADDR_EXP 30
28136: PUSH
28137: LD_INT 1
28139: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: LD_INT 181
28147: PPUSH
28148: LD_INT 86
28150: PPUSH
28151: CALL_OW 171
// AddComHold ( bomb ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 200
// wait ( 0 0$10 ) ;
28164: LD_INT 350
28166: PPUSH
28167: CALL_OW 67
// DialogueOn ;
28171: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28175: LD_EXP 64
28179: PPUSH
28180: LD_STRING D15-Pla-1
28182: PPUSH
28183: CALL_OW 94
// dec = Query ( Q15a ) ;
28187: LD_ADDR_VAR 0 2
28191: PUSH
28192: LD_STRING Q15a
28194: PPUSH
28195: CALL_OW 97
28199: ST_TO_ADDR
// if dec = 1 then
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 1
28207: EQUAL
28208: IFFALSE 28231
// begin Say ( JMM , D15a-JMM-1 ) ;
28210: LD_EXP 39
28214: PPUSH
28215: LD_STRING D15a-JMM-1
28217: PPUSH
28218: CALL_OW 88
// YouLost ( Surrender ) ;
28222: LD_STRING Surrender
28224: PPUSH
28225: CALL_OW 104
// exit ;
28229: GO 29187
// end ; if dec = 2 then
28231: LD_VAR 0 2
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28308
// begin Say ( JMM , D15b-JMM-1 ) ;
28241: LD_EXP 39
28245: PPUSH
28246: LD_STRING D15b-JMM-1
28248: PPUSH
28249: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28253: LD_EXP 64
28257: PPUSH
28258: LD_STRING D15b-Pla-1
28260: PPUSH
28261: CALL_OW 94
// DialogueOff ;
28265: CALL_OW 7
// wait ( 3 3$00 ) ;
28269: LD_INT 6300
28271: PPUSH
28272: CALL_OW 67
// DialogueOn ;
28276: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28280: LD_EXP 39
28284: PPUSH
28285: LD_STRING D15d-JMM-1a
28287: PPUSH
28288: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28292: LD_EXP 64
28296: PPUSH
28297: LD_STRING D15d-Pla-1
28299: PPUSH
28300: CALL_OW 94
// DialogueOff ;
28304: CALL_OW 7
// end ; if dec = 3 then
28308: LD_VAR 0 2
28312: PUSH
28313: LD_INT 3
28315: EQUAL
28316: IFFALSE 28370
// begin Say ( JMM , D15c-JMM-1 ) ;
28318: LD_EXP 39
28322: PPUSH
28323: LD_STRING D15c-JMM-1
28325: PPUSH
28326: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28330: LD_EXP 64
28334: PPUSH
28335: LD_STRING D15c-Pla-1
28337: PPUSH
28338: CALL_OW 94
// DialogueOff ;
28342: CALL_OW 7
// wait ( 0 0$15 ) ;
28346: LD_INT 525
28348: PPUSH
28349: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28353: LD_VAR 0 1
28357: PPUSH
28358: LD_INT 60
28360: PPUSH
28361: LD_INT 95
28363: PPUSH
28364: CALL_OW 116
// exit ;
28368: GO 29187
// end ; if dec = 4 then
28370: LD_VAR 0 2
28374: PUSH
28375: LD_INT 4
28377: EQUAL
28378: IFFALSE 28408
// begin Say ( JMM , D15d-JMM-1 ) ;
28380: LD_EXP 39
28384: PPUSH
28385: LD_STRING D15d-JMM-1
28387: PPUSH
28388: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28392: LD_EXP 64
28396: PPUSH
28397: LD_STRING D15d-Pla-1
28399: PPUSH
28400: CALL_OW 94
// DialogueOff ;
28404: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28408: LD_EXP 62
28412: PPUSH
28413: CALL_OW 302
28417: PUSH
28418: LD_EXP 62
28422: PPUSH
28423: CALL_OW 255
28427: PUSH
28428: LD_INT 1
28430: EQUAL
28431: AND
28432: PUSH
28433: LD_INT 22
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 34
28445: PUSH
28446: LD_INT 8
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PPUSH
28457: CALL_OW 69
28461: NOT
28462: AND
28463: IFFALSE 29088
// begin SetSide ( Friend , 8 ) ;
28465: LD_EXP 62
28469: PPUSH
28470: LD_INT 8
28472: PPUSH
28473: CALL_OW 235
// if IsInUnit ( Friend ) then
28477: LD_EXP 62
28481: PPUSH
28482: CALL_OW 310
28486: IFFALSE 28497
// ComExitBuilding ( Friend ) ;
28488: LD_EXP 62
28492: PPUSH
28493: CALL_OW 122
// if IsDriver ( Friend ) then
28497: LD_EXP 62
28501: PPUSH
28502: CALL 98707 0 1
28506: IFFALSE 28517
// ComExitVehicle ( Friend ) ;
28508: LD_EXP 62
28512: PPUSH
28513: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28517: LD_EXP 62
28521: PPUSH
28522: LD_INT 9
28524: PPUSH
28525: LD_INT 2
28527: PPUSH
28528: CALL_OW 171
// wait ( 0 0$05 ) ;
28532: LD_INT 175
28534: PPUSH
28535: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28539: LD_EXP 62
28543: PPUSH
28544: CALL_OW 87
// DialogueOn ;
28548: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28552: LD_EXP 39
28556: PPUSH
28557: LD_STRING D16-JMM-1
28559: PPUSH
28560: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28564: LD_EXP 62
28568: PPUSH
28569: LD_STRING D16-Friend-1
28571: PPUSH
28572: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28576: LD_EXP 39
28580: PPUSH
28581: LD_STRING D16-JMM-2
28583: PPUSH
28584: CALL_OW 88
// DialogueOff ;
28588: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28592: LD_EXP 62
28596: PPUSH
28597: LD_INT 1
28599: PPUSH
28600: CALL_OW 235
// ComHold ( Friend ) ;
28604: LD_EXP 62
28608: PPUSH
28609: CALL_OW 140
// wait ( 0 0$20 ) ;
28613: LD_INT 700
28615: PPUSH
28616: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28620: LD_EXP 62
28624: PPUSH
28625: LD_INT 9
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: CALL_OW 297
28635: PUSH
28636: LD_INT 30
28638: LESS
28639: IFFALSE 28708
// begin SetSide ( Friend , 8 ) ;
28641: LD_EXP 62
28645: PPUSH
28646: LD_INT 8
28648: PPUSH
28649: CALL_OW 235
// if IsInUnit ( Friend ) then
28653: LD_EXP 62
28657: PPUSH
28658: CALL_OW 310
28662: IFFALSE 28673
// ComExitBuilding ( Friend ) ;
28664: LD_EXP 62
28668: PPUSH
28669: CALL_OW 122
// if IsDriver ( Friend ) then
28673: LD_EXP 62
28677: PPUSH
28678: CALL 98707 0 1
28682: IFFALSE 28693
// ComExitVehicle ( Friend ) ;
28684: LD_EXP 62
28688: PPUSH
28689: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28693: LD_EXP 62
28697: PPUSH
28698: LD_INT 9
28700: PPUSH
28701: LD_INT 2
28703: PPUSH
28704: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28708: LD_INT 1050
28710: PPUSH
28711: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28715: LD_INT 22
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 34
28727: PUSH
28728: LD_INT 8
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: NOT
28744: IFFALSE 29066
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28746: LD_ADDR_VAR 0 3
28750: PUSH
28751: LD_INT 22
28753: PUSH
28754: LD_INT 1
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 26
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 3
28773: PUSH
28774: LD_INT 25
28776: PUSH
28777: LD_INT 12
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 25
28786: PUSH
28787: LD_INT 16
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: PPUSH
28804: CALL_OW 69
28808: PUSH
28809: LD_EXP 39
28813: PUSH
28814: LD_EXP 41
28818: PUSH
28819: LD_EXP 55
28823: PUSH
28824: LD_EXP 42
28828: PUSH
28829: LD_EXP 43
28833: PUSH
28834: LD_EXP 44
28838: PUSH
28839: LD_EXP 45
28843: PUSH
28844: LD_EXP 46
28848: PUSH
28849: LD_EXP 47
28853: PUSH
28854: LD_EXP 48
28858: PUSH
28859: LD_EXP 49
28863: PUSH
28864: LD_EXP 50
28868: PUSH
28869: LD_EXP 51
28873: PUSH
28874: LD_EXP 52
28878: PUSH
28879: LD_EXP 53
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: DIFF
28901: ST_TO_ADDR
// DialogueOn ;
28902: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28906: LD_EXP 64
28910: PPUSH
28911: LD_STRING D16a-Pla-1
28913: PPUSH
28914: CALL_OW 94
// if Stevens then
28918: LD_EXP 41
28922: IFFALSE 28938
// Say ( Stevens , D16a-Huck-1 ) else
28924: LD_EXP 41
28928: PPUSH
28929: LD_STRING D16a-Huck-1
28931: PPUSH
28932: CALL_OW 88
28936: GO 28980
// if Baker then
28938: LD_EXP 55
28942: IFFALSE 28958
// Say ( Baker , D16a-Huck-1 ) else
28944: LD_EXP 55
28948: PPUSH
28949: LD_STRING D16a-Huck-1
28951: PPUSH
28952: CALL_OW 88
28956: GO 28980
// if tmp then
28958: LD_VAR 0 3
28962: IFFALSE 28980
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28964: LD_VAR 0 3
28968: PUSH
28969: LD_INT 1
28971: ARRAY
28972: PPUSH
28973: LD_STRING D16a-Sol1-1
28975: PPUSH
28976: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28980: LD_EXP 62
28984: PPUSH
28985: CALL_OW 255
28989: PUSH
28990: LD_INT 8
28992: EQUAL
28993: IFFALSE 29009
// Say ( JMM , D16a-JMM-1 ) else
28995: LD_EXP 39
28999: PPUSH
29000: LD_STRING D16a-JMM-1
29002: PPUSH
29003: CALL_OW 88
29007: GO 29045
// begin Say ( JMM , D16a-JMM-1a ) ;
29009: LD_EXP 39
29013: PPUSH
29014: LD_STRING D16a-JMM-1a
29016: PPUSH
29017: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29021: LD_EXP 62
29025: PPUSH
29026: LD_STRING D16a-Friend-1
29028: PPUSH
29029: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29033: LD_EXP 62
29037: PPUSH
29038: LD_INT 3
29040: PPUSH
29041: CALL_OW 235
// end ; DialogueOff ;
29045: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29049: LD_VAR 0 1
29053: PPUSH
29054: LD_INT 60
29056: PPUSH
29057: LD_INT 95
29059: PPUSH
29060: CALL_OW 116
// end else
29064: GO 29086
// begin DialogueOn ;
29066: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29070: LD_EXP 64
29074: PPUSH
29075: LD_STRING D16c-Pla-
29077: PPUSH
29078: CALL_OW 94
// DialogueOff ;
29082: CALL_OW 7
// end ; end else
29086: GO 29187
// begin wait ( 3 3$00 ) ;
29088: LD_INT 6300
29090: PPUSH
29091: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29095: LD_INT 22
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 34
29107: PUSH
29108: LD_INT 8
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PPUSH
29119: CALL_OW 69
29123: NOT
29124: IFFALSE 29167
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29126: LD_EXP 64
29130: PPUSH
29131: LD_STRING D16b-Pla-1
29133: PPUSH
29134: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29138: LD_EXP 39
29142: PPUSH
29143: LD_STRING D16b-JMM-
29145: PPUSH
29146: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29150: LD_VAR 0 1
29154: PPUSH
29155: LD_INT 60
29157: PPUSH
29158: LD_INT 95
29160: PPUSH
29161: CALL_OW 116
// end else
29165: GO 29187
// begin DialogueOn ;
29167: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D16c-Pla-
29178: PPUSH
29179: CALL_OW 94
// DialogueOff ;
29183: CALL_OW 7
// end ; end ; end ;
29187: PPOPN 3
29189: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29190: LD_EXP 14
29194: PUSH
29195: LD_INT 126000
29197: GREATEREQUAL
29198: PUSH
29199: LD_EXP 23
29203: NOT
29204: AND
29205: PUSH
29206: LD_EXP 74
29210: PPUSH
29211: CALL_OW 302
29215: AND
29216: IFFALSE 29574
29218: GO 29220
29220: DISABLE
29221: LD_INT 0
29223: PPUSH
// begin missionStage = 11 ;
29224: LD_ADDR_EXP 15
29228: PUSH
29229: LD_INT 11
29231: ST_TO_ADDR
// DialogueOn ;
29232: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29236: LD_EXP 74
29240: PPUSH
29241: LD_STRING D9-Roth-1
29243: PPUSH
29244: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29248: LD_EXP 39
29252: PPUSH
29253: LD_STRING D9-JMM-1
29255: PPUSH
29256: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29260: LD_EXP 74
29264: PPUSH
29265: LD_STRING D9-Roth-2
29267: PPUSH
29268: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29272: LD_EXP 74
29276: PPUSH
29277: LD_STRING D9-Roth-2a
29279: PPUSH
29280: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29284: LD_EXP 64
29288: PPUSH
29289: LD_STRING D9-Pla-2
29291: PPUSH
29292: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29296: LD_EXP 74
29300: PPUSH
29301: LD_STRING D9-Roth-3
29303: PPUSH
29304: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29308: LD_EXP 64
29312: PPUSH
29313: LD_STRING D9-Pla-3
29315: PPUSH
29316: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29320: LD_EXP 74
29324: PPUSH
29325: LD_STRING D9-Roth-4
29327: PPUSH
29328: CALL_OW 94
// dec = Query ( Q9 ) ;
29332: LD_ADDR_VAR 0 1
29336: PUSH
29337: LD_STRING Q9
29339: PPUSH
29340: CALL_OW 97
29344: ST_TO_ADDR
// if dec = 1 then
29345: LD_VAR 0 1
29349: PUSH
29350: LD_INT 1
29352: EQUAL
29353: IFFALSE 29367
// SayRadio ( Roth , D9a-Roth-1 ) ;
29355: LD_EXP 74
29359: PPUSH
29360: LD_STRING D9a-Roth-1
29362: PPUSH
29363: CALL_OW 94
// if dec = 2 then
29367: LD_VAR 0 1
29371: PUSH
29372: LD_INT 2
29374: EQUAL
29375: IFFALSE 29401
// begin Say ( JMM , D9b-JMM-1 ) ;
29377: LD_EXP 39
29381: PPUSH
29382: LD_STRING D9b-JMM-1
29384: PPUSH
29385: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29389: LD_EXP 74
29393: PPUSH
29394: LD_STRING D9b-Roth-1
29396: PPUSH
29397: CALL_OW 94
// end ; if dec = 3 then
29401: LD_VAR 0 1
29405: PUSH
29406: LD_INT 3
29408: EQUAL
29409: IFFALSE 29471
// begin Say ( JMM , D9c-JMM-1 ) ;
29411: LD_EXP 39
29415: PPUSH
29416: LD_STRING D9c-JMM-1
29418: PPUSH
29419: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29423: LD_EXP 74
29427: PPUSH
29428: LD_STRING D9c-Roth-1
29430: PPUSH
29431: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29435: LD_EXP 39
29439: PPUSH
29440: LD_STRING D9c-JMM-2
29442: PPUSH
29443: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29447: LD_EXP 74
29451: PPUSH
29452: LD_STRING D9c-Roth-2
29454: PPUSH
29455: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29459: LD_EXP 39
29463: PPUSH
29464: LD_STRING D9c-JMM-3
29466: PPUSH
29467: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29471: LD_EXP 74
29475: PPUSH
29476: LD_STRING D9c-Roth-3
29478: PPUSH
29479: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29483: LD_EXP 74
29487: PPUSH
29488: LD_STRING D9cont-Roth-1
29490: PPUSH
29491: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29495: LD_EXP 39
29499: PPUSH
29500: LD_STRING D9cont-JMM-1
29502: PPUSH
29503: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29507: LD_EXP 74
29511: PPUSH
29512: LD_STRING D9cont-Roth-2
29514: PPUSH
29515: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29519: LD_EXP 39
29523: PPUSH
29524: LD_STRING D9cont-JMM-2
29526: PPUSH
29527: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29531: LD_EXP 74
29535: PPUSH
29536: LD_STRING D9cont-Roth-3
29538: PPUSH
29539: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29543: LD_EXP 39
29547: PPUSH
29548: LD_STRING D9cont-JMM-3
29550: PPUSH
29551: CALL_OW 88
// DialogueOff ;
29555: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29559: LD_STRING M3
29561: PPUSH
29562: CALL_OW 337
// allianceActive := true ;
29566: LD_ADDR_EXP 31
29570: PUSH
29571: LD_INT 1
29573: ST_TO_ADDR
// end ;
29574: PPOPN 1
29576: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29577: LD_INT 1
29579: PPUSH
29580: LD_INT 126
29582: PPUSH
29583: CALL_OW 292
29587: PUSH
29588: LD_EXP 64
29592: PPUSH
29593: CALL_OW 310
29597: AND
29598: IFFALSE 29678
29600: GO 29602
29602: DISABLE
29603: LD_INT 0
29605: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29606: LD_EXP 64
29610: PPUSH
29611: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_INT 4
29622: PPUSH
29623: LD_INT 22
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PPUSH
29633: CALL_OW 70
29637: PPUSH
29638: LD_EXP 64
29642: PPUSH
29643: CALL_OW 74
29647: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29648: LD_EXP 64
29652: PPUSH
29653: LD_VAR 0 1
29657: PUSH
29658: LD_INT 1
29660: ARRAY
29661: PPUSH
29662: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29666: LD_EXP 64
29670: PPUSH
29671: LD_STRING D18-Pla-1
29673: PPUSH
29674: CALL_OW 88
// end ;
29678: PPOPN 1
29680: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29681: LD_EXP 64
29685: PPUSH
29686: CALL_OW 301
29690: PUSH
29691: LD_EXP 67
29695: PPUSH
29696: CALL_OW 301
29700: AND
29701: PUSH
29702: LD_INT 22
29704: PUSH
29705: LD_INT 3
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 21
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 50
29724: PUSH
29725: EMPTY
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: PPUSH
29733: CALL_OW 69
29737: PUSH
29738: LD_INT 7
29740: PUSH
29741: LD_INT 8
29743: PUSH
29744: LD_INT 9
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: PUSH
29752: LD_OWVAR 67
29756: ARRAY
29757: LESS
29758: AND
29759: IFFALSE 30530
29761: GO 29763
29763: DISABLE
29764: LD_INT 0
29766: PPUSH
29767: PPUSH
29768: PPUSH
29769: PPUSH
// begin MC_Kill ( 1 ) ;
29770: LD_INT 1
29772: PPUSH
29773: CALL 35324 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29777: LD_INT 1
29779: PPUSH
29780: LD_INT 3
29782: PPUSH
29783: LD_INT 1
29785: PPUSH
29786: LD_INT 1
29788: PPUSH
29789: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29793: LD_ADDR_VAR 0 1
29797: PUSH
29798: LD_INT 22
29800: PUSH
29801: LD_INT 3
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 21
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 24
29820: PUSH
29821: LD_INT 900
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: LIST
29832: PPUSH
29833: CALL_OW 69
29837: PUSH
29838: FOR_IN
29839: IFFALSE 29870
// if GetSex ( i ) = sex_male then
29841: LD_VAR 0 1
29845: PPUSH
29846: CALL_OW 258
29850: PUSH
29851: LD_INT 1
29853: EQUAL
29854: IFFALSE 29868
// begin tmp = i ;
29856: LD_ADDR_VAR 0 2
29860: PUSH
29861: LD_VAR 0 1
29865: ST_TO_ADDR
// break ;
29866: GO 29870
// end ;
29868: GO 29838
29870: POP
29871: POP
// if tmp = 0 then
29872: LD_VAR 0 2
29876: PUSH
29877: LD_INT 0
29879: EQUAL
29880: IFFALSE 29934
// begin uc_side = 3 ;
29882: LD_ADDR_OWVAR 20
29886: PUSH
29887: LD_INT 3
29889: ST_TO_ADDR
// uc_nation = 3 ;
29890: LD_ADDR_OWVAR 21
29894: PUSH
29895: LD_INT 3
29897: ST_TO_ADDR
// hc_name =  ;
29898: LD_ADDR_OWVAR 26
29902: PUSH
29903: LD_STRING 
29905: ST_TO_ADDR
// hc_gallery =  ;
29906: LD_ADDR_OWVAR 33
29910: PUSH
29911: LD_STRING 
29913: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 10
29919: PPUSH
29920: CALL_OW 381
// tmp = CreateHuman ;
29924: LD_ADDR_VAR 0 2
29928: PUSH
29929: CALL_OW 44
29933: ST_TO_ADDR
// end ; DialogueOn ;
29934: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_STRING DSurrenderRussians-RSol1-1a
29945: PPUSH
29946: CALL_OW 94
// DialogueOff ;
29950: CALL_OW 7
// russianDestroyed := true ;
29954: LD_ADDR_EXP 21
29958: PUSH
29959: LD_INT 1
29961: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29962: LD_INT 22
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 21
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PPUSH
29986: CALL_OW 69
29990: PPUSH
29991: CALL_OW 122
// wait ( 0 0$1 ) ;
29995: LD_INT 35
29997: PPUSH
29998: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30002: LD_INT 22
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 21
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PPUSH
30026: CALL_OW 69
30030: PPUSH
30031: LD_INT 25
30033: PPUSH
30034: CALL_OW 173
// wait ( 0 0$10 ) ;
30038: LD_INT 350
30040: PPUSH
30041: CALL_OW 67
// PrepareOmarInvasion ;
30045: CALL 13878 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30049: LD_ADDR_VAR 0 2
30053: PUSH
30054: LD_EXP 92
30058: PPUSH
30059: CALL_OW 250
30063: PUSH
30064: LD_EXP 92
30068: PPUSH
30069: CALL_OW 251
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30078: LD_VAR 0 2
30082: PUSH
30083: LD_INT 1
30085: ARRAY
30086: PPUSH
30087: LD_VAR 0 2
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: PPUSH
30096: LD_INT 1
30098: PPUSH
30099: LD_INT 8
30101: NEG
30102: PPUSH
30103: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30107: LD_EXP 92
30111: PPUSH
30112: CALL_OW 87
// DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30120: LD_EXP 39
30124: PPUSH
30125: LD_STRING D19-JMM-1
30127: PPUSH
30128: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30132: LD_ADDR_VAR 0 3
30136: PUSH
30137: LD_INT 22
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 26
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 2
30159: PUSH
30160: LD_INT 25
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 25
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 25
30182: PUSH
30183: LD_INT 3
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 25
30192: PUSH
30193: LD_INT 4
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 25
30202: PUSH
30203: LD_INT 5
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 25
30212: PUSH
30213: LD_INT 8
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: LIST
30233: PPUSH
30234: CALL_OW 69
30238: PUSH
30239: LD_EXP 39
30243: PUSH
30244: LD_EXP 40
30248: PUSH
30249: LD_EXP 41
30253: PUSH
30254: LD_EXP 42
30258: PUSH
30259: LD_EXP 43
30263: PUSH
30264: LD_EXP 44
30268: PUSH
30269: LD_EXP 45
30273: PUSH
30274: LD_EXP 46
30278: PUSH
30279: LD_EXP 47
30283: PUSH
30284: LD_EXP 48
30288: PUSH
30289: LD_EXP 49
30293: PUSH
30294: LD_EXP 50
30298: PUSH
30299: LD_EXP 51
30303: PUSH
30304: LD_EXP 52
30308: PUSH
30309: LD_EXP 53
30313: PUSH
30314: LD_EXP 54
30318: PUSH
30319: LD_EXP 55
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: DIFF
30343: ST_TO_ADDR
// if tmp2 then
30344: LD_VAR 0 3
30348: IFFALSE 30366
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30350: LD_VAR 0 3
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: PPUSH
30359: LD_STRING D19-Sol1-1
30361: PPUSH
30362: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30366: LD_EXP 39
30370: PPUSH
30371: LD_STRING D19-JMM-2
30373: PPUSH
30374: CALL_OW 88
// DialogueOff ;
30378: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30382: LD_VAR 0 2
30386: PUSH
30387: LD_INT 1
30389: ARRAY
30390: PPUSH
30391: LD_VAR 0 2
30395: PUSH
30396: LD_INT 2
30398: ARRAY
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30407: LD_STRING M5
30409: PPUSH
30410: CALL_OW 337
// omarOnMotherLode := false ;
30414: LD_ADDR_VAR 0 4
30418: PUSH
30419: LD_INT 0
30421: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30422: LD_INT 35
30424: PPUSH
30425: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30429: LD_EXP 92
30433: PPUSH
30434: LD_INT 215
30436: PPUSH
30437: LD_INT 100
30439: PPUSH
30440: CALL_OW 297
30444: PUSH
30445: LD_INT 10
30447: LESS
30448: PUSH
30449: LD_VAR 0 4
30453: NOT
30454: AND
30455: IFFALSE 30489
// begin omarOnMotherLode := true ;
30457: LD_ADDR_VAR 0 4
30461: PUSH
30462: LD_INT 1
30464: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30465: LD_EXP 39
30469: PPUSH
30470: LD_STRING D19b-JMM-1
30472: PPUSH
30473: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30477: LD_EXP 92
30481: PPUSH
30482: LD_STRING DOmarContam-Omar-1
30484: PPUSH
30485: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30489: LD_EXP 92
30493: PPUSH
30494: CALL_OW 301
30498: IFFALSE 30422
// Say ( JMM , D19a-JMM-1 ) ;
30500: LD_EXP 39
30504: PPUSH
30505: LD_STRING D19a-JMM-1
30507: PPUSH
30508: CALL_OW 88
// if Heike then
30512: LD_EXP 93
30516: IFFALSE 30530
// Say ( Heike , D19a-Hke-1 ) ;
30518: LD_EXP 93
30522: PPUSH
30523: LD_STRING D19a-Hke-1
30525: PPUSH
30526: CALL_OW 88
// end ;
30530: PPOPN 4
30532: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30533: LD_INT 22
30535: PUSH
30536: LD_INT 3
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 21
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PPUSH
30557: CALL_OW 69
30561: PUSH
30562: LD_EXP 21
30566: AND
30567: IFFALSE 30635
30569: GO 30571
30571: DISABLE
30572: LD_INT 0
30574: PPUSH
30575: PPUSH
// begin enable ;
30576: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30577: LD_ADDR_VAR 0 2
30581: PUSH
30582: LD_INT 25
30584: PPUSH
30585: LD_INT 22
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 70
30599: ST_TO_ADDR
// if not tmp then
30600: LD_VAR 0 2
30604: NOT
30605: IFFALSE 30609
// exit ;
30607: GO 30635
// for i in tmp do
30609: LD_ADDR_VAR 0 1
30613: PUSH
30614: LD_VAR 0 2
30618: PUSH
30619: FOR_IN
30620: IFFALSE 30633
// RemoveUnit ( i ) ;
30622: LD_VAR 0 1
30626: PPUSH
30627: CALL_OW 64
30631: GO 30619
30633: POP
30634: POP
// end ;
30635: PPOPN 2
30637: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30638: LD_INT 22
30640: PUSH
30641: LD_INT 7
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 21
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 69
30666: PUSH
30667: LD_INT 6
30669: LESS
30670: IFFALSE 31138
30672: GO 30674
30674: DISABLE
30675: LD_INT 0
30677: PPUSH
30678: PPUSH
// begin MC_Kill ( 1 ) ;
30679: LD_INT 1
30681: PPUSH
30682: CALL 35324 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30686: LD_INT 7
30688: PPUSH
30689: LD_INT 1
30691: PPUSH
30692: LD_INT 1
30694: PPUSH
30695: LD_INT 1
30697: PPUSH
30698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30702: LD_ADDR_VAR 0 1
30706: PUSH
30707: LD_INT 22
30709: PUSH
30710: LD_INT 7
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 26
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: CALL_OW 69
30735: PUSH
30736: LD_EXP 74
30740: DIFF
30741: ST_TO_ADDR
// if tmp then
30742: LD_VAR 0 1
30746: IFFALSE 30764
// tmp := tmp [ 1 ] else
30748: LD_ADDR_VAR 0 1
30752: PUSH
30753: LD_VAR 0 1
30757: PUSH
30758: LD_INT 1
30760: ARRAY
30761: ST_TO_ADDR
30762: GO 30800
// begin uc_side := 7 ;
30764: LD_ADDR_OWVAR 20
30768: PUSH
30769: LD_INT 7
30771: ST_TO_ADDR
// uc_nation := 1 ;
30772: LD_ADDR_OWVAR 21
30776: PUSH
30777: LD_INT 1
30779: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30780: LD_INT 1
30782: PPUSH
30783: LD_INT 8
30785: PPUSH
30786: CALL_OW 384
// tmp := CreateHuman ;
30790: LD_ADDR_VAR 0 1
30794: PUSH
30795: CALL_OW 44
30799: ST_TO_ADDR
// end ; DialogueOn ;
30800: CALL_OW 6
// if IsOK ( Roth ) then
30804: LD_EXP 74
30808: PPUSH
30809: CALL_OW 302
30813: IFFALSE 30827
// Say ( JMM , DAb-JMM-1 ) ;
30815: LD_EXP 39
30819: PPUSH
30820: LD_STRING DAb-JMM-1
30822: PPUSH
30823: CALL_OW 88
// if IsOK ( Roth ) then
30827: LD_EXP 74
30831: PPUSH
30832: CALL_OW 302
30836: IFFALSE 30860
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30838: LD_EXP 74
30842: PPUSH
30843: LD_STRING DSurrenderAlliance-Roth-1
30845: PPUSH
30846: CALL_OW 88
// RothCaptured := true ;
30850: LD_ADDR_EXP 33
30854: PUSH
30855: LD_INT 1
30857: ST_TO_ADDR
// end else
30858: GO 30872
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30860: LD_VAR 0 1
30864: PPUSH
30865: LD_STRING DSurrenderAlliance-Sci1-1
30867: PPUSH
30868: CALL_OW 88
// DialogueOff ;
30872: CALL_OW 7
// allianceDestroyed := true ;
30876: LD_ADDR_EXP 23
30880: PUSH
30881: LD_INT 1
30883: ST_TO_ADDR
// if capturedUnit = 0 then
30884: LD_EXP 34
30888: PUSH
30889: LD_INT 0
30891: EQUAL
30892: IFFALSE 30901
// SetAchievement ( ACH_ALLIANCE ) ;
30894: LD_STRING ACH_ALLIANCE
30896: PPUSH
30897: CALL_OW 543
// if trueAmericans then
30901: LD_EXP 35
30905: IFFALSE 30981
// begin if trueAmericans = 1 then
30907: LD_EXP 35
30911: PUSH
30912: LD_INT 1
30914: EQUAL
30915: IFFALSE 30931
// Say ( JMM , DAb-JMM-1a ) else
30917: LD_EXP 39
30921: PPUSH
30922: LD_STRING DAb-JMM-1a
30924: PPUSH
30925: CALL_OW 88
30929: GO 30943
// Say ( JMM , DAb-JMM-1b ) ;
30931: LD_EXP 39
30935: PPUSH
30936: LD_STRING DAb-JMM-1b
30938: PPUSH
30939: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30943: LD_EXP 35
30947: PPUSH
30948: CALL_OW 87
// for i in trueAmericans do
30952: LD_ADDR_VAR 0 2
30956: PUSH
30957: LD_EXP 35
30961: PUSH
30962: FOR_IN
30963: IFFALSE 30979
// SetSide ( i , 1 ) ;
30965: LD_VAR 0 2
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 235
30977: GO 30962
30979: POP
30980: POP
// end ; repeat wait ( 0 0$1 ) ;
30981: LD_INT 35
30983: PPUSH
30984: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30988: LD_ADDR_VAR 0 2
30992: PUSH
30993: LD_INT 22
30995: PUSH
30996: LD_INT 7
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 21
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PPUSH
31017: CALL_OW 69
31021: PUSH
31022: FOR_IN
31023: IFFALSE 31105
// begin if IsInUnit ( i ) then
31025: LD_VAR 0 2
31029: PPUSH
31030: CALL_OW 310
31034: IFFALSE 31045
// ComExitBuilding ( i ) ;
31036: LD_VAR 0 2
31040: PPUSH
31041: CALL_OW 122
// if IsDriver ( i ) then
31045: LD_VAR 0 2
31049: PPUSH
31050: CALL 98707 0 1
31054: IFFALSE 31065
// ComExitVehicle ( i ) ;
31056: LD_VAR 0 2
31060: PPUSH
31061: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31065: LD_VAR 0 2
31069: PPUSH
31070: LD_INT 26
31072: PPUSH
31073: CALL_OW 308
31077: NOT
31078: IFFALSE 31094
// AddComMoveToArea ( i , allianceEscapeArea ) else
31080: LD_VAR 0 2
31084: PPUSH
31085: LD_INT 26
31087: PPUSH
31088: CALL_OW 173
31092: GO 31103
// RemoveUnit ( i ) ;
31094: LD_VAR 0 2
31098: PPUSH
31099: CALL_OW 64
// end ;
31103: GO 31022
31105: POP
31106: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31107: LD_INT 22
31109: PUSH
31110: LD_INT 7
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 21
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PPUSH
31131: CALL_OW 69
31135: NOT
31136: IFFALSE 30981
// end ;
31138: PPOPN 2
31140: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31141: LD_INT 0
31143: PPUSH
31144: PPUSH
// if not unit then
31145: LD_VAR 0 1
31149: NOT
31150: IFFALSE 31154
// exit ;
31152: GO 32652
// DoNotAttack ( 7 , unit ) ;
31154: LD_INT 7
31156: PPUSH
31157: LD_VAR 0 1
31161: PPUSH
31162: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_INT 260
31173: PPUSH
31174: LD_INT 235
31176: PPUSH
31177: LD_INT 3
31179: PPUSH
31180: LD_INT 1
31182: PPUSH
31183: CALL_OW 483
// SetSide ( unit , 4 ) ;
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_INT 4
31194: PPUSH
31195: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31199: LD_ADDR_EXP 34
31203: PUSH
31204: LD_EXP 34
31208: PUSH
31209: LD_INT 1
31211: PLUS
31212: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31213: LD_INT 70
31215: PPUSH
31216: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31220: LD_INT 260
31222: PPUSH
31223: LD_INT 235
31225: PPUSH
31226: LD_INT 1
31228: PPUSH
31229: LD_INT 8
31231: NEG
31232: PPUSH
31233: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31237: LD_VAR 0 1
31241: PPUSH
31242: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31246: LD_VAR 0 1
31250: PPUSH
31251: LD_EXP 74
31255: PPUSH
31256: CALL_OW 119
// DialogueOn ;
31260: CALL_OW 6
// case unit of JMM :
31264: LD_VAR 0 1
31268: PUSH
31269: LD_EXP 39
31273: DOUBLE
31274: EQUAL
31275: IFTRUE 31279
31277: GO 31294
31279: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31280: LD_EXP 39
31284: PPUSH
31285: LD_STRING DA1-JMM-1
31287: PPUSH
31288: CALL_OW 91
31292: GO 31736
31294: LD_EXP 40
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31305: LD_EXP 40
31309: PPUSH
31310: LD_STRING DA1-Joan-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31736
31319: LD_EXP 42
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31330: LD_EXP 42
31334: PPUSH
31335: LD_STRING DA1-Lisa-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31736
31344: LD_EXP 43
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31355: LD_EXP 43
31359: PPUSH
31360: LD_STRING DA1-Don-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31736
31369: LD_EXP 50
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31380: LD_EXP 50
31384: PPUSH
31385: LD_STRING DA1-Corn-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31736
31394: LD_EXP 46
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31405: LD_EXP 46
31409: PPUSH
31410: LD_STRING DA1-Den-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31736
31419: LD_EXP 44
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31430: LD_EXP 44
31434: PPUSH
31435: LD_STRING DA1-Bobby-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31736
31444: LD_EXP 48
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31455: LD_EXP 48
31459: PPUSH
31460: LD_STRING DA1-Glad-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31736
31469: LD_EXP 45
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31480: LD_EXP 45
31484: PPUSH
31485: LD_STRING DA1-Cyrus-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31736
31494: LD_EXP 41
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31505: LD_EXP 41
31509: PPUSH
31510: LD_STRING DA1-Huck-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31736
31519: LD_EXP 55
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31530: LD_EXP 55
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31736
31544: LD_EXP 47
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31555: LD_EXP 47
31559: PPUSH
31560: LD_STRING DA1-Brown-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31736
31569: LD_EXP 51
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31580: LD_EXP 51
31584: PPUSH
31585: LD_STRING DA1-Gary-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31736
31594: LD_EXP 54
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31605: LD_EXP 54
31609: PPUSH
31610: LD_STRING DA1-Con-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31736
31619: LD_EXP 60
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31630: LD_EXP 60
31634: PPUSH
31635: LD_STRING DA1-Kurt-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31736
31644: LD_EXP 53
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31655: LD_EXP 53
31659: PPUSH
31660: LD_STRING DA1-Yam-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31736
31669: LD_EXP 52
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31680: LD_EXP 52
31684: PPUSH
31685: LD_STRING DA1-Frank-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31736
31694: POP
// begin if GetSex ( unit ) = sex_male then
31695: LD_VAR 0 1
31699: PPUSH
31700: CALL_OW 258
31704: PUSH
31705: LD_INT 1
31707: EQUAL
31708: IFFALSE 31724
// ForceSay ( unit , DA1-Sol1-1 ) else
31710: LD_VAR 0 1
31714: PPUSH
31715: LD_STRING DA1-Sol1-1
31717: PPUSH
31718: CALL_OW 91
31722: GO 31736
// ForceSay ( unit , DA1-FSol1-1 ) ;
31724: LD_VAR 0 1
31728: PPUSH
31729: LD_STRING DA1-FSol1-1
31731: PPUSH
31732: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31736: LD_EXP 74
31740: PPUSH
31741: LD_STRING DA-Roth-1
31743: PPUSH
31744: CALL_OW 88
// if capturedUnit = 1 then
31748: LD_EXP 34
31752: PUSH
31753: LD_INT 1
31755: EQUAL
31756: IFFALSE 31784
// begin Say ( Simms , DA-Sim-1 ) ;
31758: LD_EXP 75
31762: PPUSH
31763: LD_STRING DA-Sim-1
31765: PPUSH
31766: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31770: LD_EXP 74
31774: PPUSH
31775: LD_STRING DA-Roth-2
31777: PPUSH
31778: CALL_OW 88
// end else
31782: GO 31796
// Say ( Simms , DA-Sim-2 ) ;
31784: LD_EXP 75
31788: PPUSH
31789: LD_STRING DA-Sim-2
31791: PPUSH
31792: CALL_OW 88
// case unit of JMM :
31796: LD_VAR 0 1
31800: PUSH
31801: LD_EXP 39
31805: DOUBLE
31806: EQUAL
31807: IFTRUE 31811
31809: GO 31826
31811: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31812: LD_EXP 39
31816: PPUSH
31817: LD_STRING DA1-JMM-1a
31819: PPUSH
31820: CALL_OW 91
31824: GO 32333
31826: LD_EXP 40
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31837: LD_EXP 40
31841: PPUSH
31842: LD_STRING DA1-Joan-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32333
31851: LD_EXP 42
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31862: LD_EXP 42
31866: PPUSH
31867: LD_STRING DA1-Lisa-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32333
31876: LD_EXP 43
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31887: LD_EXP 43
31891: PPUSH
31892: LD_STRING DA1-Don-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32333
31901: LD_EXP 50
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31912: LD_EXP 50
31916: PPUSH
31917: LD_STRING DA1-Corn-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32333
31926: LD_EXP 46
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31937: LD_EXP 46
31941: PPUSH
31942: LD_STRING DA1-Den-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32333
31951: LD_EXP 44
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31962: LD_EXP 44
31966: PPUSH
31967: LD_STRING DA1-Bobby-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32333
31976: LD_EXP 48
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31987: LD_EXP 48
31991: PPUSH
31992: LD_STRING DA1-Glad-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32333
32001: LD_EXP 45
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32012: LD_EXP 45
32016: PPUSH
32017: LD_STRING DA1-Cyrus-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32333
32026: LD_EXP 41
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32037: LD_EXP 41
32041: PPUSH
32042: LD_STRING DA1-Huck-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32333
32051: LD_EXP 55
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32062: LD_EXP 55
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32333
32076: LD_EXP 47
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32087: LD_EXP 47
32091: PPUSH
32092: LD_STRING DA1-Brown-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32333
32101: LD_EXP 51
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32112: LD_EXP 51
32116: PPUSH
32117: LD_STRING DA1-Gary-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32333
32126: LD_EXP 54
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32137: LD_EXP 54
32141: PPUSH
32142: LD_STRING DA1-Con-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32333
32151: LD_EXP 60
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32162: LD_EXP 60
32166: PPUSH
32167: LD_STRING DA1-Kurt-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32333
32176: LD_EXP 53
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32187: LD_EXP 53
32191: PPUSH
32192: LD_STRING DA1-Yam-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32333
32201: LD_EXP 52
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32212: LD_EXP 52
32216: PPUSH
32217: LD_STRING DA1-Frank-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32333
32226: POP
// begin join := rand ( 0 , 1 ) ;
32227: LD_ADDR_VAR 0 3
32231: PUSH
32232: LD_INT 0
32234: PPUSH
32235: LD_INT 1
32237: PPUSH
32238: CALL_OW 12
32242: ST_TO_ADDR
// if join then
32243: LD_VAR 0 3
32247: IFFALSE 32292
// begin if GetSex ( unit ) = sex_male then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 258
32258: PUSH
32259: LD_INT 1
32261: EQUAL
32262: IFFALSE 32278
// ForceSay ( unit , DA1-Sol1-1b ) else
32264: LD_VAR 0 1
32268: PPUSH
32269: LD_STRING DA1-Sol1-1b
32271: PPUSH
32272: CALL_OW 91
32276: GO 32290
// ForceSay ( unit , DA1-FSol1-1b ) ;
32278: LD_VAR 0 1
32282: PPUSH
32283: LD_STRING DA1-FSol1-1b
32285: PPUSH
32286: CALL_OW 91
// end else
32290: GO 32333
// begin if GetSex ( unit ) = sex_male then
32292: LD_VAR 0 1
32296: PPUSH
32297: CALL_OW 258
32301: PUSH
32302: LD_INT 1
32304: EQUAL
32305: IFFALSE 32321
// ForceSay ( unit , DA1-Sol1-1a ) else
32307: LD_VAR 0 1
32311: PPUSH
32312: LD_STRING DA1-Sol1-1a
32314: PPUSH
32315: CALL_OW 91
32319: GO 32333
// ForceSay ( unit , DA1-FSol1-1a ) ;
32321: LD_VAR 0 1
32325: PPUSH
32326: LD_STRING DA1-FSol1-1a
32328: PPUSH
32329: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32333: LD_VAR 0 1
32337: PUSH
32338: LD_EXP 39
32342: EQUAL
32343: IFFALSE 32354
// begin YouLost ( JMMCaptured ) ;
32345: LD_STRING JMMCaptured
32347: PPUSH
32348: CALL_OW 104
// exit ;
32352: GO 32652
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32354: LD_VAR 0 1
32358: PUSH
32359: LD_EXP 43
32363: PUSH
32364: LD_EXP 46
32368: PUSH
32369: LD_EXP 44
32373: PUSH
32374: LD_EXP 41
32378: PUSH
32379: LD_EXP 55
32383: PUSH
32384: LD_EXP 47
32388: PUSH
32389: LD_EXP 53
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: IN
32403: PUSH
32404: LD_VAR 0 3
32408: OR
32409: IFFALSE 32508
// begin Say ( Roth , DA-Roth-3 ) ;
32411: LD_EXP 74
32415: PPUSH
32416: LD_STRING DA-Roth-3
32418: PPUSH
32419: CALL_OW 88
// SetSide ( unit , 7 ) ;
32423: LD_VAR 0 1
32427: PPUSH
32428: LD_INT 7
32430: PPUSH
32431: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32435: LD_ADDR_EXP 113
32439: PUSH
32440: LD_EXP 113
32444: PPUSH
32445: LD_INT 1
32447: PPUSH
32448: LD_EXP 113
32452: PUSH
32453: LD_INT 1
32455: ARRAY
32456: PUSH
32457: LD_VAR 0 1
32461: ADD
32462: PPUSH
32463: CALL_OW 1
32467: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32468: LD_INT 260
32470: PPUSH
32471: LD_INT 235
32473: PPUSH
32474: LD_INT 1
32476: PPUSH
32477: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32481: LD_VAR 0 1
32485: PPUSH
32486: LD_INT 1000
32488: PPUSH
32489: CALL_OW 234
// DialogueOff ;
32493: CALL_OW 7
// ComFree ( unit ) ;
32497: LD_VAR 0 1
32501: PPUSH
32502: CALL_OW 139
// end else
32506: GO 32589
// begin Say ( Roth , DA-Roth-3a ) ;
32508: LD_EXP 74
32512: PPUSH
32513: LD_STRING DA-Roth-3a
32515: PPUSH
32516: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32520: LD_ADDR_EXP 35
32524: PUSH
32525: LD_EXP 35
32529: PUSH
32530: LD_VAR 0 1
32534: ADD
32535: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32536: LD_INT 260
32538: PPUSH
32539: LD_INT 235
32541: PPUSH
32542: LD_INT 1
32544: PPUSH
32545: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32549: LD_VAR 0 1
32553: PPUSH
32554: LD_INT 1000
32556: PPUSH
32557: CALL_OW 234
// DialogueOff ;
32561: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 272
32572: PPUSH
32573: LD_INT 254
32575: PPUSH
32576: CALL_OW 111
// AddComHold ( unit ) ;
32580: LD_VAR 0 1
32584: PPUSH
32585: CALL_OW 200
// end ; if capturedUnit = 1 then
32589: LD_EXP 34
32593: PUSH
32594: LD_INT 1
32596: EQUAL
32597: IFFALSE 32652
// begin DialogueOn ;
32599: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32603: LD_EXP 39
32607: PPUSH
32608: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32612: LD_EXP 39
32616: PPUSH
32617: LD_STRING DAa-JMM-1
32619: PPUSH
32620: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32624: LD_EXP 39
32628: PPUSH
32629: LD_STRING DAa-JMM-1a
32631: PPUSH
32632: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32636: LD_EXP 39
32640: PPUSH
32641: LD_STRING DAa-JMM-1b
32643: PPUSH
32644: CALL_OW 88
// DialogueOff ;
32648: CALL_OW 7
// end ; end ;
32652: LD_VAR 0 2
32656: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32657: LD_EXP 15
32661: PUSH
32662: LD_INT 13
32664: GREATEREQUAL
32665: PUSH
32666: LD_INT 22
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 21
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PPUSH
32690: CALL_OW 69
32694: PUSH
32695: LD_INT 0
32697: EQUAL
32698: AND
32699: PUSH
32700: LD_INT 22
32702: PUSH
32703: LD_INT 2
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 21
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 50
32722: PUSH
32723: EMPTY
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 69
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: AND
32740: PUSH
32741: LD_EXP 21
32745: AND
32746: PUSH
32747: LD_EXP 22
32751: AND
32752: PUSH
32753: LD_EXP 23
32757: AND
32758: IFFALSE 33400
32760: GO 32762
32762: DISABLE
32763: LD_INT 0
32765: PPUSH
32766: PPUSH
32767: PPUSH
// begin m1 := false ;
32768: LD_ADDR_VAR 0 1
32772: PUSH
32773: LD_INT 0
32775: ST_TO_ADDR
// m2 := false ;
32776: LD_ADDR_VAR 0 2
32780: PUSH
32781: LD_INT 0
32783: ST_TO_ADDR
// m3 := false ;
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 0
32791: ST_TO_ADDR
// if not bombExploded then
32792: LD_EXP 37
32796: NOT
32797: IFFALSE 32806
// SetAchievement ( ACH_SIBROCKET ) ;
32799: LD_STRING ACH_SIBROCKET
32801: PPUSH
32802: CALL_OW 543
// if tick <= 120 120$00 then
32806: LD_OWVAR 1
32810: PUSH
32811: LD_INT 252000
32813: LESSEQUAL
32814: IFFALSE 32830
// begin wait ( 3 ) ;
32816: LD_INT 3
32818: PPUSH
32819: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32823: LD_STRING ACH_ASPEED_15
32825: PPUSH
32826: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32830: LD_EXP 39
32834: PPUSH
32835: CALL_OW 87
// music_class := 5 ;
32839: LD_ADDR_OWVAR 72
32843: PUSH
32844: LD_INT 5
32846: ST_TO_ADDR
// music_nat := 5 ;
32847: LD_ADDR_OWVAR 71
32851: PUSH
32852: LD_INT 5
32854: ST_TO_ADDR
// DialogueOn ;
32855: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32859: LD_EXP 39
32863: PPUSH
32864: LD_STRING D20-JMM-1
32866: PPUSH
32867: CALL_OW 88
// if IsOK ( Joan ) then
32871: LD_EXP 40
32875: PPUSH
32876: CALL_OW 302
32880: IFFALSE 32894
// Say ( Joan , D20-Joan-1 ) ;
32882: LD_EXP 40
32886: PPUSH
32887: LD_STRING D20-Joan-1
32889: PPUSH
32890: CALL_OW 88
// if IsOk ( Lisa ) then
32894: LD_EXP 42
32898: PPUSH
32899: CALL_OW 302
32903: IFFALSE 32917
// Say ( Lisa , D20-Lisa-1 ) ;
32905: LD_EXP 42
32909: PPUSH
32910: LD_STRING D20-Lisa-1
32912: PPUSH
32913: CALL_OW 88
// if IsOk ( Donaldson ) then
32917: LD_EXP 43
32921: PPUSH
32922: CALL_OW 302
32926: IFFALSE 32940
// Say ( Donaldson , D20-Don-1 ) ;
32928: LD_EXP 43
32932: PPUSH
32933: LD_STRING D20-Don-1
32935: PPUSH
32936: CALL_OW 88
// if IsOK ( Cornel ) then
32940: LD_EXP 50
32944: PPUSH
32945: CALL_OW 302
32949: IFFALSE 32963
// Say ( Cornel , D20-Corn-1 ) ;
32951: LD_EXP 50
32955: PPUSH
32956: LD_STRING D20-Corn-1
32958: PPUSH
32959: CALL_OW 88
// if IsOk ( Denis ) then
32963: LD_EXP 46
32967: PPUSH
32968: CALL_OW 302
32972: IFFALSE 32986
// Say ( Denis , D20-Den-1 ) ;
32974: LD_EXP 46
32978: PPUSH
32979: LD_STRING D20-Den-1
32981: PPUSH
32982: CALL_OW 88
// if IsOk ( Bobby ) then
32986: LD_EXP 44
32990: PPUSH
32991: CALL_OW 302
32995: IFFALSE 33009
// Say ( Bobby , D20-Bobby-1 ) ;
32997: LD_EXP 44
33001: PPUSH
33002: LD_STRING D20-Bobby-1
33004: PPUSH
33005: CALL_OW 88
// if IsOk ( Gladstone ) then
33009: LD_EXP 48
33013: PPUSH
33014: CALL_OW 302
33018: IFFALSE 33032
// Say ( Gladstone , D20-Glad-1 ) ;
33020: LD_EXP 48
33024: PPUSH
33025: LD_STRING D20-Glad-1
33027: PPUSH
33028: CALL_OW 88
// if IsOk ( Cyrus ) then
33032: LD_EXP 45
33036: PPUSH
33037: CALL_OW 302
33041: IFFALSE 33055
// Say ( Cyrus , D20-Cyrus-1 ) ;
33043: LD_EXP 45
33047: PPUSH
33048: LD_STRING D20-Cyrus-1
33050: PPUSH
33051: CALL_OW 88
// if IsOk ( Stevens ) then
33055: LD_EXP 41
33059: PPUSH
33060: CALL_OW 302
33064: IFFALSE 33078
// Say ( Stevens , D20-Huck-1 ) ;
33066: LD_EXP 41
33070: PPUSH
33071: LD_STRING D20-Huck-1
33073: PPUSH
33074: CALL_OW 88
// if IsOk ( Brown ) then
33078: LD_EXP 47
33082: PPUSH
33083: CALL_OW 302
33087: IFFALSE 33101
// Say ( Brown , D20-Brown-1 ) ;
33089: LD_EXP 47
33093: PPUSH
33094: LD_STRING D20-Brown-1
33096: PPUSH
33097: CALL_OW 88
// if IsOk ( Gary ) then
33101: LD_EXP 51
33105: PPUSH
33106: CALL_OW 302
33110: IFFALSE 33124
// Say ( Gary , D20-Gary-1 ) ;
33112: LD_EXP 51
33116: PPUSH
33117: LD_STRING D20-Gary-1
33119: PPUSH
33120: CALL_OW 88
// if IsOk ( Connie ) then
33124: LD_EXP 54
33128: PPUSH
33129: CALL_OW 302
33133: IFFALSE 33147
// Say ( Connie , D20-Con-1 ) ;
33135: LD_EXP 54
33139: PPUSH
33140: LD_STRING D20-Con-1
33142: PPUSH
33143: CALL_OW 88
// if IsOk ( Kurt ) then
33147: LD_EXP 60
33151: PPUSH
33152: CALL_OW 302
33156: IFFALSE 33170
// Say ( Kurt , D20-Kurt-1 ) ;
33158: LD_EXP 60
33162: PPUSH
33163: LD_STRING D20-Kurt-1
33165: PPUSH
33166: CALL_OW 88
// if IsOk ( Kikuchi ) then
33170: LD_EXP 53
33174: PPUSH
33175: CALL_OW 302
33179: IFFALSE 33193
// Say ( Kikuchi , D20-Yam-1 ) ;
33181: LD_EXP 53
33185: PPUSH
33186: LD_STRING D20-Yam-1
33188: PPUSH
33189: CALL_OW 88
// if IsOk ( Frank ) then
33193: LD_EXP 52
33197: PPUSH
33198: CALL_OW 302
33202: IFFALSE 33216
// Say ( Frank , D20-Frank-1 ) ;
33204: LD_EXP 52
33208: PPUSH
33209: LD_STRING D20-Frank-1
33211: PPUSH
33212: CALL_OW 88
// DialogueOff ;
33216: CALL_OW 7
// if RothCaptured then
33220: LD_EXP 33
33224: IFFALSE 33246
// begin m1 := true ;
33226: LD_ADDR_VAR 0 1
33230: PUSH
33231: LD_INT 1
33233: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33234: LD_STRING Roth
33236: PPUSH
33237: LD_INT 1
33239: PPUSH
33240: CALL_OW 101
// end else
33244: GO 33257
// AddMedal ( Roth , - 1 ) ;
33246: LD_STRING Roth
33248: PPUSH
33249: LD_INT 1
33251: NEG
33252: PPUSH
33253: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33257: LD_EXP 27
33261: IFFALSE 33283
// begin m2 := true ;
33263: LD_ADDR_VAR 0 2
33267: PUSH
33268: LD_INT 1
33270: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33271: LD_STRING Project
33273: PPUSH
33274: LD_INT 1
33276: PPUSH
33277: CALL_OW 101
// end else
33281: GO 33294
// AddMedal ( Project , - 1 ) ;
33283: LD_STRING Project
33285: PPUSH
33286: LD_INT 1
33288: NEG
33289: PPUSH
33290: CALL_OW 101
// if lostCounter = 0 then
33294: LD_EXP 32
33298: PUSH
33299: LD_INT 0
33301: EQUAL
33302: IFFALSE 33324
// begin m3 := true ;
33304: LD_ADDR_VAR 0 3
33308: PUSH
33309: LD_INT 1
33311: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33312: LD_STRING NoLosses
33314: PPUSH
33315: LD_INT 1
33317: PPUSH
33318: CALL_OW 101
// end else
33322: GO 33335
// AddMedal ( NoLosses , - 1 ) ;
33324: LD_STRING NoLosses
33326: PPUSH
33327: LD_INT 1
33329: NEG
33330: PPUSH
33331: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33335: LD_VAR 0 1
33339: PUSH
33340: LD_VAR 0 2
33344: AND
33345: PUSH
33346: LD_VAR 0 3
33350: AND
33351: PUSH
33352: LD_OWVAR 67
33356: PUSH
33357: LD_INT 3
33359: EQUAL
33360: AND
33361: IFFALSE 33373
// SetAchievementEX ( ACH_AMER , 15 ) ;
33363: LD_STRING ACH_AMER
33365: PPUSH
33366: LD_INT 15
33368: PPUSH
33369: CALL_OW 564
// GiveMedals ( MAIN ) ;
33373: LD_STRING MAIN
33375: PPUSH
33376: CALL_OW 102
// music_class := 4 ;
33380: LD_ADDR_OWVAR 72
33384: PUSH
33385: LD_INT 4
33387: ST_TO_ADDR
// music_nat := 1 ;
33388: LD_ADDR_OWVAR 71
33392: PUSH
33393: LD_INT 1
33395: ST_TO_ADDR
// YouWin ;
33396: CALL_OW 103
// end ; end_of_file
33400: PPOPN 3
33402: END
// export function CustomEvent ( event ) ; begin
33403: LD_INT 0
33405: PPUSH
// end ;
33406: LD_VAR 0 2
33410: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33411: LD_VAR 0 1
33415: PUSH
33416: LD_INT 1
33418: EQUAL
33419: PUSH
33420: LD_VAR 0 2
33424: PUSH
33425: LD_INT 4
33427: EQUAL
33428: AND
33429: PUSH
33430: LD_EXP 58
33434: PPUSH
33435: CALL_OW 300
33439: AND
33440: IFFALSE 33456
// begin wait ( 0 0$2 ) ;
33442: LD_INT 70
33444: PPUSH
33445: CALL_OW 67
// YouLost ( Dismissed ) ;
33449: LD_STRING Dismissed
33451: PPUSH
33452: CALL_OW 104
// end ; end ;
33456: PPOPN 2
33458: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33459: LD_VAR 0 2
33463: PPUSH
33464: LD_VAR 0 3
33468: PPUSH
33469: LD_INT 18
33471: PPUSH
33472: CALL_OW 309
33476: IFFALSE 33485
// YouLost ( Motherlode3 ) ;
33478: LD_STRING Motherlode3
33480: PPUSH
33481: CALL_OW 104
// end ;
33485: PPOPN 3
33487: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33488: LD_EXP 27
33492: NOT
33493: IFFALSE 33503
// behemothDone := true ;
33495: LD_ADDR_EXP 28
33499: PUSH
33500: LD_INT 1
33502: ST_TO_ADDR
// end ;
33503: PPOPN 1
33505: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33506: LD_VAR 0 1
33510: PPUSH
33511: CALL_OW 255
33515: PUSH
33516: LD_INT 1
33518: EQUAL
33519: IFFALSE 33529
// bombExploded := true ;
33521: LD_ADDR_EXP 37
33525: PUSH
33526: LD_INT 1
33528: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33529: LD_VAR 0 1
33533: PPUSH
33534: CALL_OW 255
33538: PUSH
33539: LD_INT 1
33541: EQUAL
33542: PUSH
33543: LD_EXP 30
33547: AND
33548: PUSH
33549: LD_INT 22
33551: PUSH
33552: LD_INT 3
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 34
33561: PUSH
33562: LD_INT 48
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PPUSH
33573: CALL_OW 69
33577: AND
33578: PUSH
33579: LD_INT 22
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 34
33591: PUSH
33592: LD_INT 8
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PPUSH
33603: CALL_OW 69
33607: NOT
33608: AND
33609: IFFALSE 33661
// begin wait ( 0 0$5 ) ;
33611: LD_INT 175
33613: PPUSH
33614: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33618: LD_INT 22
33620: PUSH
33621: LD_INT 3
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 34
33630: PUSH
33631: LD_INT 48
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PPUSH
33642: CALL_OW 69
33646: PUSH
33647: LD_INT 1
33649: ARRAY
33650: PPUSH
33651: LD_INT 60
33653: PPUSH
33654: LD_INT 95
33656: PPUSH
33657: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33661: LD_VAR 0 2
33665: PPUSH
33666: LD_VAR 0 3
33670: PPUSH
33671: LD_INT 18
33673: PPUSH
33674: CALL_OW 309
33678: IFFALSE 33738
// begin if GetSide ( unit ) = 1 then
33680: LD_VAR 0 1
33684: PPUSH
33685: CALL_OW 255
33689: PUSH
33690: LD_INT 1
33692: EQUAL
33693: IFFALSE 33709
// begin wait ( 0 0$6 ) ;
33695: LD_INT 210
33697: PPUSH
33698: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33702: LD_STRING Motherlode2
33704: PPUSH
33705: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33709: LD_VAR 0 1
33713: PPUSH
33714: CALL_OW 255
33718: PUSH
33719: LD_INT 8
33721: EQUAL
33722: IFFALSE 33738
// begin wait ( 0 0$6 ) ;
33724: LD_INT 210
33726: PPUSH
33727: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33731: LD_STRING Motherlode1
33733: PPUSH
33734: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33738: LD_VAR 0 1
33742: PPUSH
33743: CALL_OW 255
33747: PUSH
33748: LD_INT 3
33750: EQUAL
33751: IFFALSE 33772
// begin wait ( 0 0$5 ) ;
33753: LD_INT 175
33755: PPUSH
33756: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33760: LD_EXP 64
33764: PPUSH
33765: LD_STRING D18-Pla-1
33767: PPUSH
33768: CALL_OW 94
// end ; end ;
33772: PPOPN 3
33774: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33775: LD_VAR 0 1
33779: PUSH
33780: LD_INT 22
33782: PUSH
33783: LD_INT 1
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 21
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 23
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: PPUSH
33815: CALL_OW 69
33819: IN
33820: IFFALSE 33836
// lostCounter := lostCounter + 1 ;
33822: LD_ADDR_EXP 32
33826: PUSH
33827: LD_EXP 32
33831: PUSH
33832: LD_INT 1
33834: PLUS
33835: ST_TO_ADDR
// if un in behemothBuilders then
33836: LD_VAR 0 1
33840: PUSH
33841: LD_EXP 73
33845: IN
33846: IFFALSE 33866
// begin behemothBuilders := behemothBuilders diff un ;
33848: LD_ADDR_EXP 73
33852: PUSH
33853: LD_EXP 73
33857: PUSH
33858: LD_VAR 0 1
33862: DIFF
33863: ST_TO_ADDR
// exit ;
33864: GO 33896
// end ; if un = JMM then
33866: LD_VAR 0 1
33870: PUSH
33871: LD_EXP 39
33875: EQUAL
33876: IFFALSE 33887
// begin YouLost ( JMM ) ;
33878: LD_STRING JMM
33880: PPUSH
33881: CALL_OW 104
// exit ;
33885: GO 33896
// end ; MCE_UnitDestroyed ( un ) ;
33887: LD_VAR 0 1
33891: PPUSH
33892: CALL 62160 0 1
// end ;
33896: PPOPN 1
33898: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33899: LD_VAR 0 1
33903: PPUSH
33904: LD_VAR 0 2
33908: PPUSH
33909: CALL 64494 0 2
// end ;
33913: PPOPN 2
33915: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL 63562 0 1
// end ;
33925: PPOPN 1
33927: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33928: LD_VAR 0 1
33932: PUSH
33933: LD_INT 22
33935: PUSH
33936: LD_INT 8
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 30
33945: PUSH
33946: LD_INT 2
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 23
33955: PUSH
33956: LD_INT 3
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: LIST
33967: PPUSH
33968: CALL_OW 69
33972: IN
33973: IFFALSE 34000
// begin ComUpgrade ( building ) ;
33975: LD_VAR 0 1
33979: PPUSH
33980: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33984: LD_EXP 61
33988: PPUSH
33989: LD_VAR 0 1
33993: PPUSH
33994: CALL 72909 0 2
// exit ;
33998: GO 34009
// end ; MCE_BuildingComplete ( building ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL 63803 0 1
// end ;
34009: PPOPN 1
34011: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34012: LD_VAR 0 1
34016: PPUSH
34017: LD_VAR 0 2
34021: PPUSH
34022: CALL 61856 0 2
// end ;
34026: PPOPN 2
34028: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: LD_VAR 0 2
34038: PPUSH
34039: LD_VAR 0 3
34043: PPUSH
34044: LD_VAR 0 4
34048: PPUSH
34049: LD_VAR 0 5
34053: PPUSH
34054: CALL 61476 0 5
// end ;
34058: PPOPN 5
34060: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34061: LD_VAR 0 1
34065: PPUSH
34066: LD_VAR 0 2
34070: PPUSH
34071: CALL 61072 0 2
// end ;
34075: PPOPN 2
34077: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34078: LD_VAR 0 1
34082: PPUSH
34083: LD_VAR 0 2
34087: PPUSH
34088: LD_VAR 0 3
34092: PPUSH
34093: LD_VAR 0 4
34097: PPUSH
34098: CALL 60910 0 4
// end ;
34102: PPOPN 4
34104: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34105: LD_VAR 0 1
34109: PPUSH
34110: LD_VAR 0 2
34114: PPUSH
34115: LD_VAR 0 3
34119: PPUSH
34120: CALL 60685 0 3
// end ;
34124: PPOPN 3
34126: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34127: LD_VAR 0 1
34131: PPUSH
34132: LD_VAR 0 2
34136: PPUSH
34137: CALL 60570 0 2
// end ;
34141: PPOPN 2
34143: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34144: LD_VAR 0 1
34148: PPUSH
34149: LD_VAR 0 2
34153: PPUSH
34154: CALL 64755 0 2
// end ;
34158: PPOPN 2
34160: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34161: LD_VAR 0 1
34165: PPUSH
34166: CALL_OW 255
34170: PUSH
34171: LD_INT 4
34173: EQUAL
34174: PUSH
34175: LD_VAR 0 1
34179: PUSH
34180: LD_EXP 18
34184: PUSH
34185: LD_INT 1
34187: ARRAY
34188: IN
34189: AND
34190: PUSH
34191: LD_EXP 19
34195: AND
34196: IFFALSE 34215
// begin ComMoveXY ( driver , 61 , 93 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 61
34205: PPUSH
34206: LD_INT 93
34208: PPUSH
34209: CALL_OW 111
// exit ;
34213: GO 34239
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34215: LD_VAR 0 1
34219: PPUSH
34220: LD_VAR 0 2
34224: PPUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: LD_VAR 0 4
34234: PPUSH
34235: CALL 64971 0 4
// end ;
34239: PPOPN 4
34241: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34242: LD_VAR 0 1
34246: PPUSH
34247: LD_VAR 0 2
34251: PPUSH
34252: CALL 60379 0 2
// end ;
34256: PPOPN 2
34258: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34259: LD_VAR 0 1
34263: PPUSH
34264: CALL 115197 0 1
// end ; end_of_file
34268: PPOPN 1
34270: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34271: LD_EXP 15
34275: PUSH
34276: LD_INT 2
34278: EQUAL
34279: IFFALSE 34758
34281: GO 34283
34283: DISABLE
34284: LD_INT 0
34286: PPUSH
// begin time := 0 0$40 ;
34287: LD_ADDR_VAR 0 1
34291: PUSH
34292: LD_INT 1400
34294: ST_TO_ADDR
// repeat wait ( time ) ;
34295: LD_VAR 0 1
34299: PPUSH
34300: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34304: LD_INT 1
34306: PPUSH
34307: LD_INT 5
34309: PPUSH
34310: CALL_OW 12
34314: PPUSH
34315: LD_INT 106
34317: PPUSH
34318: LD_INT 150
34320: PPUSH
34321: LD_INT 19
34323: PPUSH
34324: LD_INT 1
34326: PPUSH
34327: CALL_OW 56
// time := time + 0 0$9 ;
34331: LD_ADDR_VAR 0 1
34335: PUSH
34336: LD_VAR 0 1
34340: PUSH
34341: LD_INT 315
34343: PLUS
34344: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34345: LD_INT 455
34347: PPUSH
34348: LD_INT 840
34350: PPUSH
34351: CALL_OW 12
34355: PPUSH
34356: CALL_OW 67
// if Prob ( 50 ) then
34360: LD_INT 50
34362: PPUSH
34363: CALL_OW 13
34367: IFFALSE 34396
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34369: LD_INT 1
34371: PPUSH
34372: LD_INT 5
34374: PPUSH
34375: CALL_OW 12
34379: PPUSH
34380: LD_INT 62
34382: PPUSH
34383: LD_INT 108
34385: PPUSH
34386: LD_INT 10
34388: PPUSH
34389: LD_INT 1
34391: PPUSH
34392: CALL_OW 56
// until missionStage > 4 ;
34396: LD_EXP 15
34400: PUSH
34401: LD_INT 4
34403: GREATER
34404: IFFALSE 34295
// repeat wait ( 0 0$1 ) ;
34406: LD_INT 35
34408: PPUSH
34409: CALL_OW 67
// until missionStage = 6 ;
34413: LD_EXP 15
34417: PUSH
34418: LD_INT 6
34420: EQUAL
34421: IFFALSE 34406
// time := 0 0$50 ;
34423: LD_ADDR_VAR 0 1
34427: PUSH
34428: LD_INT 1750
34430: ST_TO_ADDR
// repeat wait ( time ) ;
34431: LD_VAR 0 1
34435: PPUSH
34436: CALL_OW 67
// if Prob ( 50 ) then
34440: LD_INT 50
34442: PPUSH
34443: CALL_OW 13
34447: IFFALSE 34476
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34449: LD_INT 1
34451: PPUSH
34452: LD_INT 5
34454: PPUSH
34455: CALL_OW 12
34459: PPUSH
34460: LD_INT 106
34462: PPUSH
34463: LD_INT 89
34465: PPUSH
34466: LD_INT 45
34468: PPUSH
34469: LD_INT 1
34471: PPUSH
34472: CALL_OW 56
// time := time + 0 0$2 ;
34476: LD_ADDR_VAR 0 1
34480: PUSH
34481: LD_VAR 0 1
34485: PUSH
34486: LD_INT 70
34488: PLUS
34489: ST_TO_ADDR
// if Prob ( 30 ) then
34490: LD_INT 30
34492: PPUSH
34493: CALL_OW 13
34497: IFFALSE 34543
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34499: LD_INT 385
34501: PPUSH
34502: LD_INT 945
34504: PPUSH
34505: CALL_OW 12
34509: PPUSH
34510: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34514: LD_INT 1
34516: PPUSH
34517: LD_INT 5
34519: PPUSH
34520: CALL_OW 12
34524: PPUSH
34525: LD_INT 21
34527: PPUSH
34528: LD_INT 26
34530: PPUSH
34531: LD_INT 12
34533: PPUSH
34534: LD_INT 1
34536: PPUSH
34537: CALL_OW 56
// end else
34541: GO 34579
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34543: LD_INT 700
34545: PPUSH
34546: LD_INT 1225
34548: PPUSH
34549: CALL_OW 12
34553: PPUSH
34554: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34558: LD_INT 1
34560: PPUSH
34561: LD_INT 5
34563: PPUSH
34564: CALL_OW 12
34568: PPUSH
34569: LD_INT 16
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: CALL_OW 55
// end ; if Prob ( 50 ) then
34579: LD_INT 50
34581: PPUSH
34582: CALL_OW 13
34586: IFFALSE 34632
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34588: LD_INT 700
34590: PPUSH
34591: LD_INT 1050
34593: PPUSH
34594: CALL_OW 12
34598: PPUSH
34599: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34603: LD_INT 1
34605: PPUSH
34606: LD_INT 5
34608: PPUSH
34609: CALL_OW 12
34613: PPUSH
34614: LD_INT 181
34616: PPUSH
34617: LD_INT 218
34619: PPUSH
34620: LD_INT 16
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: CALL_OW 56
// end else
34630: GO 34668
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34632: LD_INT 350
34634: PPUSH
34635: LD_INT 525
34637: PPUSH
34638: CALL_OW 12
34642: PPUSH
34643: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34647: LD_INT 1
34649: PPUSH
34650: LD_INT 5
34652: PPUSH
34653: CALL_OW 12
34657: PPUSH
34658: LD_INT 15
34660: PPUSH
34661: LD_INT 1
34663: PPUSH
34664: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34668: LD_INT 45
34670: PUSH
34671: LD_INT 32
34673: PUSH
34674: LD_INT 25
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: LIST
34681: PUSH
34682: LD_OWVAR 67
34686: ARRAY
34687: PPUSH
34688: CALL_OW 13
34692: IFFALSE 34736
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34694: LD_INT 175
34696: PPUSH
34697: LD_INT 315
34699: PPUSH
34700: CALL_OW 12
34704: PPUSH
34705: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34709: LD_INT 1
34711: PPUSH
34712: LD_INT 5
34714: PPUSH
34715: CALL_OW 12
34719: PPUSH
34720: LD_INT 103
34722: PPUSH
34723: LD_INT 140
34725: PPUSH
34726: LD_INT 20
34728: PPUSH
34729: LD_INT 1
34731: PPUSH
34732: CALL_OW 56
// end ; if time > 1 1$20 then
34736: LD_VAR 0 1
34740: PUSH
34741: LD_INT 2800
34743: GREATER
34744: IFFALSE 34754
// time := 0 0$30 ;
34746: LD_ADDR_VAR 0 1
34750: PUSH
34751: LD_INT 1050
34753: ST_TO_ADDR
// until false ;
34754: LD_INT 0
34756: IFFALSE 34431
// end ; end_of_file
34758: PPOPN 1
34760: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34761: LD_EXP 13
34765: PUSH
34766: LD_EXP 15
34770: PUSH
34771: LD_INT 6
34773: GREATEREQUAL
34774: AND
34775: IFFALSE 34812
34777: GO 34779
34779: DISABLE
// begin enable ;
34780: ENABLE
// missionTime := missionTime + 0 0$1 ;
34781: LD_ADDR_EXP 14
34785: PUSH
34786: LD_EXP 14
34790: PUSH
34791: LD_INT 35
34793: PLUS
34794: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34795: LD_ADDR_OWVAR 47
34799: PUSH
34800: LD_STRING #Am15-1
34802: PUSH
34803: LD_EXP 14
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: ST_TO_ADDR
// end ; end_of_file
34812: END
// export function InitNature ; begin
34813: LD_INT 0
34815: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34816: LD_INT 3
34818: PPUSH
34819: LD_INT 3
34821: PPUSH
34822: LD_INT 2
34824: PPUSH
34825: LD_INT 1
34827: PPUSH
34828: LD_INT 1
34830: PPUSH
34831: LD_INT 0
34833: PPUSH
34834: LD_INT 0
34836: PPUSH
34837: LD_INT 20
34839: PPUSH
34840: LD_INT 0
34842: PPUSH
34843: CALL 97727 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34847: LD_INT 2
34849: PPUSH
34850: LD_INT 1
34852: PPUSH
34853: LD_INT 1
34855: PPUSH
34856: LD_INT 1
34858: PPUSH
34859: LD_INT 1
34861: PPUSH
34862: LD_INT 0
34864: PPUSH
34865: LD_INT 0
34867: PPUSH
34868: LD_INT 21
34870: PPUSH
34871: LD_INT 0
34873: PPUSH
34874: CALL 97727 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34878: LD_INT 4
34880: PPUSH
34881: LD_INT 1
34883: PPUSH
34884: LD_INT 2
34886: PPUSH
34887: LD_INT 4
34889: PPUSH
34890: LD_INT 2
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 0
34898: PPUSH
34899: LD_INT 22
34901: PPUSH
34902: LD_INT 0
34904: PPUSH
34905: CALL 97727 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34909: LD_INT 0
34911: PPUSH
34912: LD_INT 0
34914: PPUSH
34915: LD_INT 0
34917: PPUSH
34918: LD_INT 0
34920: PPUSH
34921: LD_INT 0
34923: PPUSH
34924: LD_INT 0
34926: PPUSH
34927: LD_INT 9
34929: PPUSH
34930: LD_INT 0
34932: PPUSH
34933: LD_INT 23
34935: PPUSH
34936: CALL 97727 0 9
// end ; end_of_file
34940: LD_VAR 0 1
34944: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
34945: LD_INT 0
34947: PPUSH
// ar_miner := 81 ;
34948: LD_ADDR_EXP 102
34952: PUSH
34953: LD_INT 81
34955: ST_TO_ADDR
// ar_crane := 88 ;
34956: LD_ADDR_EXP 101
34960: PUSH
34961: LD_INT 88
34963: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34964: LD_ADDR_EXP 96
34968: PUSH
34969: LD_INT 89
34971: ST_TO_ADDR
// us_hack := 99 ;
34972: LD_ADDR_EXP 97
34976: PUSH
34977: LD_INT 99
34979: ST_TO_ADDR
// us_artillery := 97 ;
34980: LD_ADDR_EXP 98
34984: PUSH
34985: LD_INT 97
34987: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34988: LD_ADDR_EXP 99
34992: PUSH
34993: LD_INT 91
34995: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
34996: LD_ADDR_EXP 100
35000: PUSH
35001: LD_INT 92
35003: ST_TO_ADDR
// ru_radar := 98 ;
35004: LD_ADDR_EXP 95
35008: PUSH
35009: LD_INT 98
35011: ST_TO_ADDR
// tech_Artillery := 80 ;
35012: LD_ADDR_EXP 103
35016: PUSH
35017: LD_INT 80
35019: ST_TO_ADDR
// tech_RadMat := 81 ;
35020: LD_ADDR_EXP 104
35024: PUSH
35025: LD_INT 81
35027: ST_TO_ADDR
// tech_BasicTools := 82 ;
35028: LD_ADDR_EXP 105
35032: PUSH
35033: LD_INT 82
35035: ST_TO_ADDR
// tech_Cargo := 83 ;
35036: LD_ADDR_EXP 106
35040: PUSH
35041: LD_INT 83
35043: ST_TO_ADDR
// tech_Track := 84 ;
35044: LD_ADDR_EXP 107
35048: PUSH
35049: LD_INT 84
35051: ST_TO_ADDR
// tech_Crane := 85 ;
35052: LD_ADDR_EXP 108
35056: PUSH
35057: LD_INT 85
35059: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35060: LD_ADDR_EXP 109
35064: PUSH
35065: LD_INT 86
35067: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35068: LD_ADDR_EXP 110
35072: PUSH
35073: LD_INT 87
35075: ST_TO_ADDR
// end ;
35076: LD_VAR 0 1
35080: RET
// every 1 do
35081: GO 35083
35083: DISABLE
// InitGlobalVariables ; end_of_file
35084: CALL 34945 0 0
35088: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35089: LD_INT 0
35091: PPUSH
35092: PPUSH
// skirmish := false ;
35093: LD_ADDR_EXP 111
35097: PUSH
35098: LD_INT 0
35100: ST_TO_ADDR
// debug_mc := false ;
35101: LD_ADDR_EXP 112
35105: PUSH
35106: LD_INT 0
35108: ST_TO_ADDR
// mc_bases := [ ] ;
35109: LD_ADDR_EXP 113
35113: PUSH
35114: EMPTY
35115: ST_TO_ADDR
// mc_sides := [ ] ;
35116: LD_ADDR_EXP 139
35120: PUSH
35121: EMPTY
35122: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35123: LD_ADDR_EXP 114
35127: PUSH
35128: EMPTY
35129: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35130: LD_ADDR_EXP 115
35134: PUSH
35135: EMPTY
35136: ST_TO_ADDR
// mc_need_heal := [ ] ;
35137: LD_ADDR_EXP 116
35141: PUSH
35142: EMPTY
35143: ST_TO_ADDR
// mc_healers := [ ] ;
35144: LD_ADDR_EXP 117
35148: PUSH
35149: EMPTY
35150: ST_TO_ADDR
// mc_build_list := [ ] ;
35151: LD_ADDR_EXP 118
35155: PUSH
35156: EMPTY
35157: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35158: LD_ADDR_EXP 145
35162: PUSH
35163: EMPTY
35164: ST_TO_ADDR
// mc_builders := [ ] ;
35165: LD_ADDR_EXP 119
35169: PUSH
35170: EMPTY
35171: ST_TO_ADDR
// mc_construct_list := [ ] ;
35172: LD_ADDR_EXP 120
35176: PUSH
35177: EMPTY
35178: ST_TO_ADDR
// mc_turret_list := [ ] ;
35179: LD_ADDR_EXP 121
35183: PUSH
35184: EMPTY
35185: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35186: LD_ADDR_EXP 122
35190: PUSH
35191: EMPTY
35192: ST_TO_ADDR
// mc_miners := [ ] ;
35193: LD_ADDR_EXP 127
35197: PUSH
35198: EMPTY
35199: ST_TO_ADDR
// mc_mines := [ ] ;
35200: LD_ADDR_EXP 126
35204: PUSH
35205: EMPTY
35206: ST_TO_ADDR
// mc_minefields := [ ] ;
35207: LD_ADDR_EXP 128
35211: PUSH
35212: EMPTY
35213: ST_TO_ADDR
// mc_crates := [ ] ;
35214: LD_ADDR_EXP 129
35218: PUSH
35219: EMPTY
35220: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35221: LD_ADDR_EXP 130
35225: PUSH
35226: EMPTY
35227: ST_TO_ADDR
// mc_crates_area := [ ] ;
35228: LD_ADDR_EXP 131
35232: PUSH
35233: EMPTY
35234: ST_TO_ADDR
// mc_vehicles := [ ] ;
35235: LD_ADDR_EXP 132
35239: PUSH
35240: EMPTY
35241: ST_TO_ADDR
// mc_attack := [ ] ;
35242: LD_ADDR_EXP 133
35246: PUSH
35247: EMPTY
35248: ST_TO_ADDR
// mc_produce := [ ] ;
35249: LD_ADDR_EXP 134
35253: PUSH
35254: EMPTY
35255: ST_TO_ADDR
// mc_defender := [ ] ;
35256: LD_ADDR_EXP 135
35260: PUSH
35261: EMPTY
35262: ST_TO_ADDR
// mc_parking := [ ] ;
35263: LD_ADDR_EXP 137
35267: PUSH
35268: EMPTY
35269: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35270: LD_ADDR_EXP 123
35274: PUSH
35275: EMPTY
35276: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35277: LD_ADDR_EXP 125
35281: PUSH
35282: EMPTY
35283: ST_TO_ADDR
// mc_scan := [ ] ;
35284: LD_ADDR_EXP 136
35288: PUSH
35289: EMPTY
35290: ST_TO_ADDR
// mc_scan_area := [ ] ;
35291: LD_ADDR_EXP 138
35295: PUSH
35296: EMPTY
35297: ST_TO_ADDR
// mc_tech := [ ] ;
35298: LD_ADDR_EXP 140
35302: PUSH
35303: EMPTY
35304: ST_TO_ADDR
// mc_class := [ ] ;
35305: LD_ADDR_EXP 154
35309: PUSH
35310: EMPTY
35311: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35312: LD_ADDR_EXP 155
35316: PUSH
35317: EMPTY
35318: ST_TO_ADDR
// end ;
35319: LD_VAR 0 1
35323: RET
// export function MC_Kill ( base ) ; begin
35324: LD_INT 0
35326: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35327: LD_ADDR_EXP 113
35331: PUSH
35332: LD_EXP 113
35336: PPUSH
35337: LD_VAR 0 1
35341: PPUSH
35342: EMPTY
35343: PPUSH
35344: CALL_OW 1
35348: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35349: LD_ADDR_EXP 114
35353: PUSH
35354: LD_EXP 114
35358: PPUSH
35359: LD_VAR 0 1
35363: PPUSH
35364: EMPTY
35365: PPUSH
35366: CALL_OW 1
35370: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35371: LD_ADDR_EXP 115
35375: PUSH
35376: LD_EXP 115
35380: PPUSH
35381: LD_VAR 0 1
35385: PPUSH
35386: EMPTY
35387: PPUSH
35388: CALL_OW 1
35392: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35393: LD_ADDR_EXP 116
35397: PUSH
35398: LD_EXP 116
35402: PPUSH
35403: LD_VAR 0 1
35407: PPUSH
35408: EMPTY
35409: PPUSH
35410: CALL_OW 1
35414: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35415: LD_ADDR_EXP 117
35419: PUSH
35420: LD_EXP 117
35424: PPUSH
35425: LD_VAR 0 1
35429: PPUSH
35430: EMPTY
35431: PPUSH
35432: CALL_OW 1
35436: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35437: LD_ADDR_EXP 118
35441: PUSH
35442: LD_EXP 118
35446: PPUSH
35447: LD_VAR 0 1
35451: PPUSH
35452: EMPTY
35453: PPUSH
35454: CALL_OW 1
35458: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35459: LD_ADDR_EXP 119
35463: PUSH
35464: LD_EXP 119
35468: PPUSH
35469: LD_VAR 0 1
35473: PPUSH
35474: EMPTY
35475: PPUSH
35476: CALL_OW 1
35480: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35481: LD_ADDR_EXP 120
35485: PUSH
35486: LD_EXP 120
35490: PPUSH
35491: LD_VAR 0 1
35495: PPUSH
35496: EMPTY
35497: PPUSH
35498: CALL_OW 1
35502: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35503: LD_ADDR_EXP 121
35507: PUSH
35508: LD_EXP 121
35512: PPUSH
35513: LD_VAR 0 1
35517: PPUSH
35518: EMPTY
35519: PPUSH
35520: CALL_OW 1
35524: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35525: LD_ADDR_EXP 122
35529: PUSH
35530: LD_EXP 122
35534: PPUSH
35535: LD_VAR 0 1
35539: PPUSH
35540: EMPTY
35541: PPUSH
35542: CALL_OW 1
35546: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35547: LD_ADDR_EXP 123
35551: PUSH
35552: LD_EXP 123
35556: PPUSH
35557: LD_VAR 0 1
35561: PPUSH
35562: EMPTY
35563: PPUSH
35564: CALL_OW 1
35568: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35569: LD_ADDR_EXP 124
35573: PUSH
35574: LD_EXP 124
35578: PPUSH
35579: LD_VAR 0 1
35583: PPUSH
35584: LD_INT 0
35586: PPUSH
35587: CALL_OW 1
35591: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35592: LD_ADDR_EXP 125
35596: PUSH
35597: LD_EXP 125
35601: PPUSH
35602: LD_VAR 0 1
35606: PPUSH
35607: EMPTY
35608: PPUSH
35609: CALL_OW 1
35613: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35614: LD_ADDR_EXP 126
35618: PUSH
35619: LD_EXP 126
35623: PPUSH
35624: LD_VAR 0 1
35628: PPUSH
35629: EMPTY
35630: PPUSH
35631: CALL_OW 1
35635: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35636: LD_ADDR_EXP 127
35640: PUSH
35641: LD_EXP 127
35645: PPUSH
35646: LD_VAR 0 1
35650: PPUSH
35651: EMPTY
35652: PPUSH
35653: CALL_OW 1
35657: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35658: LD_ADDR_EXP 128
35662: PUSH
35663: LD_EXP 128
35667: PPUSH
35668: LD_VAR 0 1
35672: PPUSH
35673: EMPTY
35674: PPUSH
35675: CALL_OW 1
35679: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35680: LD_ADDR_EXP 129
35684: PUSH
35685: LD_EXP 129
35689: PPUSH
35690: LD_VAR 0 1
35694: PPUSH
35695: EMPTY
35696: PPUSH
35697: CALL_OW 1
35701: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35702: LD_ADDR_EXP 130
35706: PUSH
35707: LD_EXP 130
35711: PPUSH
35712: LD_VAR 0 1
35716: PPUSH
35717: EMPTY
35718: PPUSH
35719: CALL_OW 1
35723: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35724: LD_ADDR_EXP 131
35728: PUSH
35729: LD_EXP 131
35733: PPUSH
35734: LD_VAR 0 1
35738: PPUSH
35739: EMPTY
35740: PPUSH
35741: CALL_OW 1
35745: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35746: LD_ADDR_EXP 132
35750: PUSH
35751: LD_EXP 132
35755: PPUSH
35756: LD_VAR 0 1
35760: PPUSH
35761: EMPTY
35762: PPUSH
35763: CALL_OW 1
35767: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35768: LD_ADDR_EXP 133
35772: PUSH
35773: LD_EXP 133
35777: PPUSH
35778: LD_VAR 0 1
35782: PPUSH
35783: EMPTY
35784: PPUSH
35785: CALL_OW 1
35789: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35790: LD_ADDR_EXP 134
35794: PUSH
35795: LD_EXP 134
35799: PPUSH
35800: LD_VAR 0 1
35804: PPUSH
35805: EMPTY
35806: PPUSH
35807: CALL_OW 1
35811: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35812: LD_ADDR_EXP 135
35816: PUSH
35817: LD_EXP 135
35821: PPUSH
35822: LD_VAR 0 1
35826: PPUSH
35827: EMPTY
35828: PPUSH
35829: CALL_OW 1
35833: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35834: LD_ADDR_EXP 136
35838: PUSH
35839: LD_EXP 136
35843: PPUSH
35844: LD_VAR 0 1
35848: PPUSH
35849: EMPTY
35850: PPUSH
35851: CALL_OW 1
35855: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35856: LD_ADDR_EXP 137
35860: PUSH
35861: LD_EXP 137
35865: PPUSH
35866: LD_VAR 0 1
35870: PPUSH
35871: EMPTY
35872: PPUSH
35873: CALL_OW 1
35877: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35878: LD_ADDR_EXP 138
35882: PUSH
35883: LD_EXP 138
35887: PPUSH
35888: LD_VAR 0 1
35892: PPUSH
35893: EMPTY
35894: PPUSH
35895: CALL_OW 1
35899: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35900: LD_ADDR_EXP 140
35904: PUSH
35905: LD_EXP 140
35909: PPUSH
35910: LD_VAR 0 1
35914: PPUSH
35915: EMPTY
35916: PPUSH
35917: CALL_OW 1
35921: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35922: LD_ADDR_EXP 142
35926: PUSH
35927: LD_EXP 142
35931: PPUSH
35932: LD_VAR 0 1
35936: PPUSH
35937: EMPTY
35938: PPUSH
35939: CALL_OW 1
35943: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35944: LD_ADDR_EXP 143
35948: PUSH
35949: LD_EXP 143
35953: PPUSH
35954: LD_VAR 0 1
35958: PPUSH
35959: EMPTY
35960: PPUSH
35961: CALL_OW 1
35965: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35966: LD_ADDR_EXP 144
35970: PUSH
35971: LD_EXP 144
35975: PPUSH
35976: LD_VAR 0 1
35980: PPUSH
35981: EMPTY
35982: PPUSH
35983: CALL_OW 1
35987: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35988: LD_ADDR_EXP 145
35992: PUSH
35993: LD_EXP 145
35997: PPUSH
35998: LD_VAR 0 1
36002: PPUSH
36003: EMPTY
36004: PPUSH
36005: CALL_OW 1
36009: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36010: LD_ADDR_EXP 146
36014: PUSH
36015: LD_EXP 146
36019: PPUSH
36020: LD_VAR 0 1
36024: PPUSH
36025: EMPTY
36026: PPUSH
36027: CALL_OW 1
36031: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36032: LD_ADDR_EXP 147
36036: PUSH
36037: LD_EXP 147
36041: PPUSH
36042: LD_VAR 0 1
36046: PPUSH
36047: EMPTY
36048: PPUSH
36049: CALL_OW 1
36053: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36054: LD_ADDR_EXP 148
36058: PUSH
36059: LD_EXP 148
36063: PPUSH
36064: LD_VAR 0 1
36068: PPUSH
36069: EMPTY
36070: PPUSH
36071: CALL_OW 1
36075: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36076: LD_ADDR_EXP 149
36080: PUSH
36081: LD_EXP 149
36085: PPUSH
36086: LD_VAR 0 1
36090: PPUSH
36091: EMPTY
36092: PPUSH
36093: CALL_OW 1
36097: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36098: LD_ADDR_EXP 150
36102: PUSH
36103: LD_EXP 150
36107: PPUSH
36108: LD_VAR 0 1
36112: PPUSH
36113: EMPTY
36114: PPUSH
36115: CALL_OW 1
36119: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36120: LD_ADDR_EXP 151
36124: PUSH
36125: LD_EXP 151
36129: PPUSH
36130: LD_VAR 0 1
36134: PPUSH
36135: EMPTY
36136: PPUSH
36137: CALL_OW 1
36141: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36142: LD_ADDR_EXP 152
36146: PUSH
36147: LD_EXP 152
36151: PPUSH
36152: LD_VAR 0 1
36156: PPUSH
36157: EMPTY
36158: PPUSH
36159: CALL_OW 1
36163: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36164: LD_ADDR_EXP 153
36168: PUSH
36169: LD_EXP 153
36173: PPUSH
36174: LD_VAR 0 1
36178: PPUSH
36179: EMPTY
36180: PPUSH
36181: CALL_OW 1
36185: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36186: LD_ADDR_EXP 154
36190: PUSH
36191: LD_EXP 154
36195: PPUSH
36196: LD_VAR 0 1
36200: PPUSH
36201: EMPTY
36202: PPUSH
36203: CALL_OW 1
36207: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36208: LD_ADDR_EXP 155
36212: PUSH
36213: LD_EXP 155
36217: PPUSH
36218: LD_VAR 0 1
36222: PPUSH
36223: LD_INT 0
36225: PPUSH
36226: CALL_OW 1
36230: ST_TO_ADDR
// end ;
36231: LD_VAR 0 2
36235: RET
// export function MC_Add ( side , units ) ; var base ; begin
36236: LD_INT 0
36238: PPUSH
36239: PPUSH
// base := mc_bases + 1 ;
36240: LD_ADDR_VAR 0 4
36244: PUSH
36245: LD_EXP 113
36249: PUSH
36250: LD_INT 1
36252: PLUS
36253: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36254: LD_ADDR_EXP 139
36258: PUSH
36259: LD_EXP 139
36263: PPUSH
36264: LD_VAR 0 4
36268: PPUSH
36269: LD_VAR 0 1
36273: PPUSH
36274: CALL_OW 1
36278: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36279: LD_ADDR_EXP 113
36283: PUSH
36284: LD_EXP 113
36288: PPUSH
36289: LD_VAR 0 4
36293: PPUSH
36294: LD_VAR 0 2
36298: PPUSH
36299: CALL_OW 1
36303: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36304: LD_ADDR_EXP 114
36308: PUSH
36309: LD_EXP 114
36313: PPUSH
36314: LD_VAR 0 4
36318: PPUSH
36319: EMPTY
36320: PPUSH
36321: CALL_OW 1
36325: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36326: LD_ADDR_EXP 115
36330: PUSH
36331: LD_EXP 115
36335: PPUSH
36336: LD_VAR 0 4
36340: PPUSH
36341: EMPTY
36342: PPUSH
36343: CALL_OW 1
36347: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36348: LD_ADDR_EXP 116
36352: PUSH
36353: LD_EXP 116
36357: PPUSH
36358: LD_VAR 0 4
36362: PPUSH
36363: EMPTY
36364: PPUSH
36365: CALL_OW 1
36369: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36370: LD_ADDR_EXP 117
36374: PUSH
36375: LD_EXP 117
36379: PPUSH
36380: LD_VAR 0 4
36384: PPUSH
36385: EMPTY
36386: PPUSH
36387: CALL_OW 1
36391: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36392: LD_ADDR_EXP 118
36396: PUSH
36397: LD_EXP 118
36401: PPUSH
36402: LD_VAR 0 4
36406: PPUSH
36407: EMPTY
36408: PPUSH
36409: CALL_OW 1
36413: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36414: LD_ADDR_EXP 119
36418: PUSH
36419: LD_EXP 119
36423: PPUSH
36424: LD_VAR 0 4
36428: PPUSH
36429: EMPTY
36430: PPUSH
36431: CALL_OW 1
36435: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36436: LD_ADDR_EXP 120
36440: PUSH
36441: LD_EXP 120
36445: PPUSH
36446: LD_VAR 0 4
36450: PPUSH
36451: EMPTY
36452: PPUSH
36453: CALL_OW 1
36457: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36458: LD_ADDR_EXP 121
36462: PUSH
36463: LD_EXP 121
36467: PPUSH
36468: LD_VAR 0 4
36472: PPUSH
36473: EMPTY
36474: PPUSH
36475: CALL_OW 1
36479: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36480: LD_ADDR_EXP 122
36484: PUSH
36485: LD_EXP 122
36489: PPUSH
36490: LD_VAR 0 4
36494: PPUSH
36495: EMPTY
36496: PPUSH
36497: CALL_OW 1
36501: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36502: LD_ADDR_EXP 123
36506: PUSH
36507: LD_EXP 123
36511: PPUSH
36512: LD_VAR 0 4
36516: PPUSH
36517: EMPTY
36518: PPUSH
36519: CALL_OW 1
36523: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36524: LD_ADDR_EXP 124
36528: PUSH
36529: LD_EXP 124
36533: PPUSH
36534: LD_VAR 0 4
36538: PPUSH
36539: LD_INT 0
36541: PPUSH
36542: CALL_OW 1
36546: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36547: LD_ADDR_EXP 125
36551: PUSH
36552: LD_EXP 125
36556: PPUSH
36557: LD_VAR 0 4
36561: PPUSH
36562: EMPTY
36563: PPUSH
36564: CALL_OW 1
36568: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36569: LD_ADDR_EXP 126
36573: PUSH
36574: LD_EXP 126
36578: PPUSH
36579: LD_VAR 0 4
36583: PPUSH
36584: EMPTY
36585: PPUSH
36586: CALL_OW 1
36590: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36591: LD_ADDR_EXP 127
36595: PUSH
36596: LD_EXP 127
36600: PPUSH
36601: LD_VAR 0 4
36605: PPUSH
36606: EMPTY
36607: PPUSH
36608: CALL_OW 1
36612: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36613: LD_ADDR_EXP 128
36617: PUSH
36618: LD_EXP 128
36622: PPUSH
36623: LD_VAR 0 4
36627: PPUSH
36628: EMPTY
36629: PPUSH
36630: CALL_OW 1
36634: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36635: LD_ADDR_EXP 129
36639: PUSH
36640: LD_EXP 129
36644: PPUSH
36645: LD_VAR 0 4
36649: PPUSH
36650: EMPTY
36651: PPUSH
36652: CALL_OW 1
36656: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36657: LD_ADDR_EXP 130
36661: PUSH
36662: LD_EXP 130
36666: PPUSH
36667: LD_VAR 0 4
36671: PPUSH
36672: EMPTY
36673: PPUSH
36674: CALL_OW 1
36678: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36679: LD_ADDR_EXP 131
36683: PUSH
36684: LD_EXP 131
36688: PPUSH
36689: LD_VAR 0 4
36693: PPUSH
36694: EMPTY
36695: PPUSH
36696: CALL_OW 1
36700: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36701: LD_ADDR_EXP 132
36705: PUSH
36706: LD_EXP 132
36710: PPUSH
36711: LD_VAR 0 4
36715: PPUSH
36716: EMPTY
36717: PPUSH
36718: CALL_OW 1
36722: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36723: LD_ADDR_EXP 133
36727: PUSH
36728: LD_EXP 133
36732: PPUSH
36733: LD_VAR 0 4
36737: PPUSH
36738: EMPTY
36739: PPUSH
36740: CALL_OW 1
36744: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36745: LD_ADDR_EXP 134
36749: PUSH
36750: LD_EXP 134
36754: PPUSH
36755: LD_VAR 0 4
36759: PPUSH
36760: EMPTY
36761: PPUSH
36762: CALL_OW 1
36766: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36767: LD_ADDR_EXP 135
36771: PUSH
36772: LD_EXP 135
36776: PPUSH
36777: LD_VAR 0 4
36781: PPUSH
36782: EMPTY
36783: PPUSH
36784: CALL_OW 1
36788: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36789: LD_ADDR_EXP 136
36793: PUSH
36794: LD_EXP 136
36798: PPUSH
36799: LD_VAR 0 4
36803: PPUSH
36804: EMPTY
36805: PPUSH
36806: CALL_OW 1
36810: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36811: LD_ADDR_EXP 137
36815: PUSH
36816: LD_EXP 137
36820: PPUSH
36821: LD_VAR 0 4
36825: PPUSH
36826: EMPTY
36827: PPUSH
36828: CALL_OW 1
36832: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36833: LD_ADDR_EXP 138
36837: PUSH
36838: LD_EXP 138
36842: PPUSH
36843: LD_VAR 0 4
36847: PPUSH
36848: EMPTY
36849: PPUSH
36850: CALL_OW 1
36854: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36855: LD_ADDR_EXP 140
36859: PUSH
36860: LD_EXP 140
36864: PPUSH
36865: LD_VAR 0 4
36869: PPUSH
36870: EMPTY
36871: PPUSH
36872: CALL_OW 1
36876: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36877: LD_ADDR_EXP 142
36881: PUSH
36882: LD_EXP 142
36886: PPUSH
36887: LD_VAR 0 4
36891: PPUSH
36892: EMPTY
36893: PPUSH
36894: CALL_OW 1
36898: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36899: LD_ADDR_EXP 143
36903: PUSH
36904: LD_EXP 143
36908: PPUSH
36909: LD_VAR 0 4
36913: PPUSH
36914: EMPTY
36915: PPUSH
36916: CALL_OW 1
36920: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36921: LD_ADDR_EXP 144
36925: PUSH
36926: LD_EXP 144
36930: PPUSH
36931: LD_VAR 0 4
36935: PPUSH
36936: EMPTY
36937: PPUSH
36938: CALL_OW 1
36942: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36943: LD_ADDR_EXP 145
36947: PUSH
36948: LD_EXP 145
36952: PPUSH
36953: LD_VAR 0 4
36957: PPUSH
36958: EMPTY
36959: PPUSH
36960: CALL_OW 1
36964: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36965: LD_ADDR_EXP 146
36969: PUSH
36970: LD_EXP 146
36974: PPUSH
36975: LD_VAR 0 4
36979: PPUSH
36980: EMPTY
36981: PPUSH
36982: CALL_OW 1
36986: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36987: LD_ADDR_EXP 147
36991: PUSH
36992: LD_EXP 147
36996: PPUSH
36997: LD_VAR 0 4
37001: PPUSH
37002: EMPTY
37003: PPUSH
37004: CALL_OW 1
37008: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37009: LD_ADDR_EXP 148
37013: PUSH
37014: LD_EXP 148
37018: PPUSH
37019: LD_VAR 0 4
37023: PPUSH
37024: EMPTY
37025: PPUSH
37026: CALL_OW 1
37030: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37031: LD_ADDR_EXP 149
37035: PUSH
37036: LD_EXP 149
37040: PPUSH
37041: LD_VAR 0 4
37045: PPUSH
37046: EMPTY
37047: PPUSH
37048: CALL_OW 1
37052: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37053: LD_ADDR_EXP 150
37057: PUSH
37058: LD_EXP 150
37062: PPUSH
37063: LD_VAR 0 4
37067: PPUSH
37068: EMPTY
37069: PPUSH
37070: CALL_OW 1
37074: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37075: LD_ADDR_EXP 151
37079: PUSH
37080: LD_EXP 151
37084: PPUSH
37085: LD_VAR 0 4
37089: PPUSH
37090: EMPTY
37091: PPUSH
37092: CALL_OW 1
37096: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37097: LD_ADDR_EXP 152
37101: PUSH
37102: LD_EXP 152
37106: PPUSH
37107: LD_VAR 0 4
37111: PPUSH
37112: EMPTY
37113: PPUSH
37114: CALL_OW 1
37118: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37119: LD_ADDR_EXP 153
37123: PUSH
37124: LD_EXP 153
37128: PPUSH
37129: LD_VAR 0 4
37133: PPUSH
37134: EMPTY
37135: PPUSH
37136: CALL_OW 1
37140: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37141: LD_ADDR_EXP 154
37145: PUSH
37146: LD_EXP 154
37150: PPUSH
37151: LD_VAR 0 4
37155: PPUSH
37156: EMPTY
37157: PPUSH
37158: CALL_OW 1
37162: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37163: LD_ADDR_EXP 155
37167: PUSH
37168: LD_EXP 155
37172: PPUSH
37173: LD_VAR 0 4
37177: PPUSH
37178: LD_INT 0
37180: PPUSH
37181: CALL_OW 1
37185: ST_TO_ADDR
// result := base ;
37186: LD_ADDR_VAR 0 3
37190: PUSH
37191: LD_VAR 0 4
37195: ST_TO_ADDR
// end ;
37196: LD_VAR 0 3
37200: RET
// export function MC_Start ( ) ; var i ; begin
37201: LD_INT 0
37203: PPUSH
37204: PPUSH
// for i = 1 to mc_bases do
37205: LD_ADDR_VAR 0 2
37209: PUSH
37210: DOUBLE
37211: LD_INT 1
37213: DEC
37214: ST_TO_ADDR
37215: LD_EXP 113
37219: PUSH
37220: FOR_TO
37221: IFFALSE 38298
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37223: LD_ADDR_EXP 113
37227: PUSH
37228: LD_EXP 113
37232: PPUSH
37233: LD_VAR 0 2
37237: PPUSH
37238: LD_EXP 113
37242: PUSH
37243: LD_VAR 0 2
37247: ARRAY
37248: PUSH
37249: LD_INT 0
37251: DIFF
37252: PPUSH
37253: CALL_OW 1
37257: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37258: LD_ADDR_EXP 114
37262: PUSH
37263: LD_EXP 114
37267: PPUSH
37268: LD_VAR 0 2
37272: PPUSH
37273: EMPTY
37274: PPUSH
37275: CALL_OW 1
37279: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37280: LD_ADDR_EXP 115
37284: PUSH
37285: LD_EXP 115
37289: PPUSH
37290: LD_VAR 0 2
37294: PPUSH
37295: EMPTY
37296: PPUSH
37297: CALL_OW 1
37301: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37302: LD_ADDR_EXP 116
37306: PUSH
37307: LD_EXP 116
37311: PPUSH
37312: LD_VAR 0 2
37316: PPUSH
37317: EMPTY
37318: PPUSH
37319: CALL_OW 1
37323: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37324: LD_ADDR_EXP 117
37328: PUSH
37329: LD_EXP 117
37333: PPUSH
37334: LD_VAR 0 2
37338: PPUSH
37339: EMPTY
37340: PUSH
37341: EMPTY
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PPUSH
37347: CALL_OW 1
37351: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37352: LD_ADDR_EXP 118
37356: PUSH
37357: LD_EXP 118
37361: PPUSH
37362: LD_VAR 0 2
37366: PPUSH
37367: EMPTY
37368: PPUSH
37369: CALL_OW 1
37373: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37374: LD_ADDR_EXP 145
37378: PUSH
37379: LD_EXP 145
37383: PPUSH
37384: LD_VAR 0 2
37388: PPUSH
37389: EMPTY
37390: PPUSH
37391: CALL_OW 1
37395: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37396: LD_ADDR_EXP 119
37400: PUSH
37401: LD_EXP 119
37405: PPUSH
37406: LD_VAR 0 2
37410: PPUSH
37411: EMPTY
37412: PPUSH
37413: CALL_OW 1
37417: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37418: LD_ADDR_EXP 120
37422: PUSH
37423: LD_EXP 120
37427: PPUSH
37428: LD_VAR 0 2
37432: PPUSH
37433: EMPTY
37434: PPUSH
37435: CALL_OW 1
37439: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37440: LD_ADDR_EXP 121
37444: PUSH
37445: LD_EXP 121
37449: PPUSH
37450: LD_VAR 0 2
37454: PPUSH
37455: LD_EXP 113
37459: PUSH
37460: LD_VAR 0 2
37464: ARRAY
37465: PPUSH
37466: LD_INT 2
37468: PUSH
37469: LD_INT 30
37471: PUSH
37472: LD_INT 32
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 30
37481: PUSH
37482: LD_INT 33
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: LIST
37493: PPUSH
37494: CALL_OW 72
37498: PPUSH
37499: CALL_OW 1
37503: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37504: LD_ADDR_EXP 122
37508: PUSH
37509: LD_EXP 122
37513: PPUSH
37514: LD_VAR 0 2
37518: PPUSH
37519: LD_EXP 113
37523: PUSH
37524: LD_VAR 0 2
37528: ARRAY
37529: PPUSH
37530: LD_INT 2
37532: PUSH
37533: LD_INT 30
37535: PUSH
37536: LD_INT 32
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 30
37545: PUSH
37546: LD_INT 31
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 58
37560: PUSH
37561: EMPTY
37562: LIST
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PPUSH
37568: CALL_OW 72
37572: PPUSH
37573: CALL_OW 1
37577: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37578: LD_ADDR_EXP 123
37582: PUSH
37583: LD_EXP 123
37587: PPUSH
37588: LD_VAR 0 2
37592: PPUSH
37593: EMPTY
37594: PPUSH
37595: CALL_OW 1
37599: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37600: LD_ADDR_EXP 127
37604: PUSH
37605: LD_EXP 127
37609: PPUSH
37610: LD_VAR 0 2
37614: PPUSH
37615: EMPTY
37616: PPUSH
37617: CALL_OW 1
37621: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37622: LD_ADDR_EXP 126
37626: PUSH
37627: LD_EXP 126
37631: PPUSH
37632: LD_VAR 0 2
37636: PPUSH
37637: EMPTY
37638: PPUSH
37639: CALL_OW 1
37643: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37644: LD_ADDR_EXP 128
37648: PUSH
37649: LD_EXP 128
37653: PPUSH
37654: LD_VAR 0 2
37658: PPUSH
37659: EMPTY
37660: PPUSH
37661: CALL_OW 1
37665: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37666: LD_ADDR_EXP 129
37670: PUSH
37671: LD_EXP 129
37675: PPUSH
37676: LD_VAR 0 2
37680: PPUSH
37681: EMPTY
37682: PPUSH
37683: CALL_OW 1
37687: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37688: LD_ADDR_EXP 130
37692: PUSH
37693: LD_EXP 130
37697: PPUSH
37698: LD_VAR 0 2
37702: PPUSH
37703: EMPTY
37704: PPUSH
37705: CALL_OW 1
37709: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37710: LD_ADDR_EXP 131
37714: PUSH
37715: LD_EXP 131
37719: PPUSH
37720: LD_VAR 0 2
37724: PPUSH
37725: EMPTY
37726: PPUSH
37727: CALL_OW 1
37731: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37732: LD_ADDR_EXP 132
37736: PUSH
37737: LD_EXP 132
37741: PPUSH
37742: LD_VAR 0 2
37746: PPUSH
37747: EMPTY
37748: PPUSH
37749: CALL_OW 1
37753: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37754: LD_ADDR_EXP 133
37758: PUSH
37759: LD_EXP 133
37763: PPUSH
37764: LD_VAR 0 2
37768: PPUSH
37769: EMPTY
37770: PPUSH
37771: CALL_OW 1
37775: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37776: LD_ADDR_EXP 134
37780: PUSH
37781: LD_EXP 134
37785: PPUSH
37786: LD_VAR 0 2
37790: PPUSH
37791: EMPTY
37792: PPUSH
37793: CALL_OW 1
37797: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37798: LD_ADDR_EXP 135
37802: PUSH
37803: LD_EXP 135
37807: PPUSH
37808: LD_VAR 0 2
37812: PPUSH
37813: EMPTY
37814: PPUSH
37815: CALL_OW 1
37819: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37820: LD_ADDR_EXP 124
37824: PUSH
37825: LD_EXP 124
37829: PPUSH
37830: LD_VAR 0 2
37834: PPUSH
37835: LD_INT 0
37837: PPUSH
37838: CALL_OW 1
37842: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37843: LD_ADDR_EXP 137
37847: PUSH
37848: LD_EXP 137
37852: PPUSH
37853: LD_VAR 0 2
37857: PPUSH
37858: LD_INT 0
37860: PPUSH
37861: CALL_OW 1
37865: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37866: LD_ADDR_EXP 125
37870: PUSH
37871: LD_EXP 125
37875: PPUSH
37876: LD_VAR 0 2
37880: PPUSH
37881: EMPTY
37882: PPUSH
37883: CALL_OW 1
37887: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37888: LD_ADDR_EXP 136
37892: PUSH
37893: LD_EXP 136
37897: PPUSH
37898: LD_VAR 0 2
37902: PPUSH
37903: LD_INT 0
37905: PPUSH
37906: CALL_OW 1
37910: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37911: LD_ADDR_EXP 138
37915: PUSH
37916: LD_EXP 138
37920: PPUSH
37921: LD_VAR 0 2
37925: PPUSH
37926: EMPTY
37927: PPUSH
37928: CALL_OW 1
37932: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37933: LD_ADDR_EXP 141
37937: PUSH
37938: LD_EXP 141
37942: PPUSH
37943: LD_VAR 0 2
37947: PPUSH
37948: LD_INT 0
37950: PPUSH
37951: CALL_OW 1
37955: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37956: LD_ADDR_EXP 142
37960: PUSH
37961: LD_EXP 142
37965: PPUSH
37966: LD_VAR 0 2
37970: PPUSH
37971: EMPTY
37972: PPUSH
37973: CALL_OW 1
37977: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37978: LD_ADDR_EXP 143
37982: PUSH
37983: LD_EXP 143
37987: PPUSH
37988: LD_VAR 0 2
37992: PPUSH
37993: EMPTY
37994: PPUSH
37995: CALL_OW 1
37999: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38000: LD_ADDR_EXP 144
38004: PUSH
38005: LD_EXP 144
38009: PPUSH
38010: LD_VAR 0 2
38014: PPUSH
38015: EMPTY
38016: PPUSH
38017: CALL_OW 1
38021: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38022: LD_ADDR_EXP 146
38026: PUSH
38027: LD_EXP 146
38031: PPUSH
38032: LD_VAR 0 2
38036: PPUSH
38037: LD_EXP 113
38041: PUSH
38042: LD_VAR 0 2
38046: ARRAY
38047: PPUSH
38048: LD_INT 2
38050: PUSH
38051: LD_INT 30
38053: PUSH
38054: LD_INT 6
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 30
38063: PUSH
38064: LD_INT 7
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 30
38073: PUSH
38074: LD_INT 8
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: PPUSH
38087: CALL_OW 72
38091: PPUSH
38092: CALL_OW 1
38096: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38097: LD_ADDR_EXP 147
38101: PUSH
38102: LD_EXP 147
38106: PPUSH
38107: LD_VAR 0 2
38111: PPUSH
38112: EMPTY
38113: PPUSH
38114: CALL_OW 1
38118: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38119: LD_ADDR_EXP 148
38123: PUSH
38124: LD_EXP 148
38128: PPUSH
38129: LD_VAR 0 2
38133: PPUSH
38134: EMPTY
38135: PPUSH
38136: CALL_OW 1
38140: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38141: LD_ADDR_EXP 149
38145: PUSH
38146: LD_EXP 149
38150: PPUSH
38151: LD_VAR 0 2
38155: PPUSH
38156: EMPTY
38157: PPUSH
38158: CALL_OW 1
38162: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38163: LD_ADDR_EXP 150
38167: PUSH
38168: LD_EXP 150
38172: PPUSH
38173: LD_VAR 0 2
38177: PPUSH
38178: EMPTY
38179: PPUSH
38180: CALL_OW 1
38184: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38185: LD_ADDR_EXP 151
38189: PUSH
38190: LD_EXP 151
38194: PPUSH
38195: LD_VAR 0 2
38199: PPUSH
38200: EMPTY
38201: PPUSH
38202: CALL_OW 1
38206: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38207: LD_ADDR_EXP 152
38211: PUSH
38212: LD_EXP 152
38216: PPUSH
38217: LD_VAR 0 2
38221: PPUSH
38222: EMPTY
38223: PPUSH
38224: CALL_OW 1
38228: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38229: LD_ADDR_EXP 153
38233: PUSH
38234: LD_EXP 153
38238: PPUSH
38239: LD_VAR 0 2
38243: PPUSH
38244: EMPTY
38245: PPUSH
38246: CALL_OW 1
38250: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38251: LD_ADDR_EXP 154
38255: PUSH
38256: LD_EXP 154
38260: PPUSH
38261: LD_VAR 0 2
38265: PPUSH
38266: EMPTY
38267: PPUSH
38268: CALL_OW 1
38272: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38273: LD_ADDR_EXP 155
38277: PUSH
38278: LD_EXP 155
38282: PPUSH
38283: LD_VAR 0 2
38287: PPUSH
38288: LD_INT 0
38290: PPUSH
38291: CALL_OW 1
38295: ST_TO_ADDR
// end ;
38296: GO 37220
38298: POP
38299: POP
// MC_InitSides ( ) ;
38300: CALL 38586 0 0
// MC_InitResearch ( ) ;
38304: CALL 38325 0 0
// CustomInitMacro ( ) ;
38308: CALL 467 0 0
// skirmish := true ;
38312: LD_ADDR_EXP 111
38316: PUSH
38317: LD_INT 1
38319: ST_TO_ADDR
// end ;
38320: LD_VAR 0 1
38324: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38325: LD_INT 0
38327: PPUSH
38328: PPUSH
38329: PPUSH
38330: PPUSH
38331: PPUSH
38332: PPUSH
// if not mc_bases then
38333: LD_EXP 113
38337: NOT
38338: IFFALSE 38342
// exit ;
38340: GO 38581
// for i = 1 to 8 do
38342: LD_ADDR_VAR 0 2
38346: PUSH
38347: DOUBLE
38348: LD_INT 1
38350: DEC
38351: ST_TO_ADDR
38352: LD_INT 8
38354: PUSH
38355: FOR_TO
38356: IFFALSE 38382
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38358: LD_ADDR_EXP 140
38362: PUSH
38363: LD_EXP 140
38367: PPUSH
38368: LD_VAR 0 2
38372: PPUSH
38373: EMPTY
38374: PPUSH
38375: CALL_OW 1
38379: ST_TO_ADDR
38380: GO 38355
38382: POP
38383: POP
// tmp := [ ] ;
38384: LD_ADDR_VAR 0 5
38388: PUSH
38389: EMPTY
38390: ST_TO_ADDR
// for i = 1 to mc_sides do
38391: LD_ADDR_VAR 0 2
38395: PUSH
38396: DOUBLE
38397: LD_INT 1
38399: DEC
38400: ST_TO_ADDR
38401: LD_EXP 139
38405: PUSH
38406: FOR_TO
38407: IFFALSE 38465
// if not mc_sides [ i ] in tmp then
38409: LD_EXP 139
38413: PUSH
38414: LD_VAR 0 2
38418: ARRAY
38419: PUSH
38420: LD_VAR 0 5
38424: IN
38425: NOT
38426: IFFALSE 38463
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38428: LD_ADDR_VAR 0 5
38432: PUSH
38433: LD_VAR 0 5
38437: PPUSH
38438: LD_VAR 0 5
38442: PUSH
38443: LD_INT 1
38445: PLUS
38446: PPUSH
38447: LD_EXP 139
38451: PUSH
38452: LD_VAR 0 2
38456: ARRAY
38457: PPUSH
38458: CALL_OW 2
38462: ST_TO_ADDR
38463: GO 38406
38465: POP
38466: POP
// if not tmp then
38467: LD_VAR 0 5
38471: NOT
38472: IFFALSE 38476
// exit ;
38474: GO 38581
// for j in tmp do
38476: LD_ADDR_VAR 0 3
38480: PUSH
38481: LD_VAR 0 5
38485: PUSH
38486: FOR_IN
38487: IFFALSE 38579
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38489: LD_ADDR_VAR 0 6
38493: PUSH
38494: LD_INT 22
38496: PUSH
38497: LD_VAR 0 3
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PPUSH
38506: CALL_OW 69
38510: ST_TO_ADDR
// if not un then
38511: LD_VAR 0 6
38515: NOT
38516: IFFALSE 38520
// continue ;
38518: GO 38486
// nation := GetNation ( un [ 1 ] ) ;
38520: LD_ADDR_VAR 0 4
38524: PUSH
38525: LD_VAR 0 6
38529: PUSH
38530: LD_INT 1
38532: ARRAY
38533: PPUSH
38534: CALL_OW 248
38538: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38539: LD_ADDR_EXP 140
38543: PUSH
38544: LD_EXP 140
38548: PPUSH
38549: LD_VAR 0 3
38553: PPUSH
38554: LD_VAR 0 3
38558: PPUSH
38559: LD_VAR 0 4
38563: PPUSH
38564: LD_INT 1
38566: PPUSH
38567: CALL 65175 0 3
38571: PPUSH
38572: CALL_OW 1
38576: ST_TO_ADDR
// end ;
38577: GO 38486
38579: POP
38580: POP
// end ;
38581: LD_VAR 0 1
38585: RET
// export function MC_InitSides ( ) ; var i ; begin
38586: LD_INT 0
38588: PPUSH
38589: PPUSH
// if not mc_bases then
38590: LD_EXP 113
38594: NOT
38595: IFFALSE 38599
// exit ;
38597: GO 38673
// for i = 1 to mc_bases do
38599: LD_ADDR_VAR 0 2
38603: PUSH
38604: DOUBLE
38605: LD_INT 1
38607: DEC
38608: ST_TO_ADDR
38609: LD_EXP 113
38613: PUSH
38614: FOR_TO
38615: IFFALSE 38671
// if mc_bases [ i ] then
38617: LD_EXP 113
38621: PUSH
38622: LD_VAR 0 2
38626: ARRAY
38627: IFFALSE 38669
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38629: LD_ADDR_EXP 139
38633: PUSH
38634: LD_EXP 139
38638: PPUSH
38639: LD_VAR 0 2
38643: PPUSH
38644: LD_EXP 113
38648: PUSH
38649: LD_VAR 0 2
38653: ARRAY
38654: PUSH
38655: LD_INT 1
38657: ARRAY
38658: PPUSH
38659: CALL_OW 255
38663: PPUSH
38664: CALL_OW 1
38668: ST_TO_ADDR
38669: GO 38614
38671: POP
38672: POP
// end ;
38673: LD_VAR 0 1
38677: RET
// every 0 0$01 trigger skirmish do
38678: LD_EXP 111
38682: IFFALSE 38836
38684: GO 38686
38686: DISABLE
// begin enable ;
38687: ENABLE
// MC_CheckBuildings ( ) ;
38688: CALL 43334 0 0
// MC_CheckPeopleLife ( ) ;
38692: CALL 43459 0 0
// RaiseSailEvent ( 100 ) ;
38696: LD_INT 100
38698: PPUSH
38699: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38703: LD_INT 103
38705: PPUSH
38706: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38710: LD_INT 104
38712: PPUSH
38713: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38717: LD_INT 105
38719: PPUSH
38720: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38724: LD_INT 106
38726: PPUSH
38727: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38731: LD_INT 107
38733: PPUSH
38734: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38738: LD_INT 108
38740: PPUSH
38741: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38745: LD_INT 109
38747: PPUSH
38748: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38752: LD_INT 110
38754: PPUSH
38755: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38759: LD_INT 111
38761: PPUSH
38762: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38766: LD_INT 112
38768: PPUSH
38769: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38773: LD_INT 113
38775: PPUSH
38776: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38780: LD_INT 120
38782: PPUSH
38783: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38787: LD_INT 121
38789: PPUSH
38790: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38794: LD_INT 122
38796: PPUSH
38797: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38801: LD_INT 123
38803: PPUSH
38804: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38808: LD_INT 124
38810: PPUSH
38811: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38815: LD_INT 125
38817: PPUSH
38818: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38822: LD_INT 126
38824: PPUSH
38825: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38829: LD_INT 200
38831: PPUSH
38832: CALL_OW 427
// end ;
38836: END
// on SailEvent ( event ) do begin if event < 100 then
38837: LD_VAR 0 1
38841: PUSH
38842: LD_INT 100
38844: LESS
38845: IFFALSE 38856
// CustomEvent ( event ) ;
38847: LD_VAR 0 1
38851: PPUSH
38852: CALL 33403 0 1
// if event = 100 then
38856: LD_VAR 0 1
38860: PUSH
38861: LD_INT 100
38863: EQUAL
38864: IFFALSE 38870
// MC_ClassManager ( ) ;
38866: CALL 39262 0 0
// if event = 101 then
38870: LD_VAR 0 1
38874: PUSH
38875: LD_INT 101
38877: EQUAL
38878: IFFALSE 38884
// MC_RepairBuildings ( ) ;
38880: CALL 44044 0 0
// if event = 102 then
38884: LD_VAR 0 1
38888: PUSH
38889: LD_INT 102
38891: EQUAL
38892: IFFALSE 38898
// MC_Heal ( ) ;
38894: CALL 44903 0 0
// if event = 103 then
38898: LD_VAR 0 1
38902: PUSH
38903: LD_INT 103
38905: EQUAL
38906: IFFALSE 38912
// MC_Build ( ) ;
38908: CALL 45325 0 0
// if event = 104 then
38912: LD_VAR 0 1
38916: PUSH
38917: LD_INT 104
38919: EQUAL
38920: IFFALSE 38926
// MC_TurretWeapon ( ) ;
38922: CALL 46938 0 0
// if event = 105 then
38926: LD_VAR 0 1
38930: PUSH
38931: LD_INT 105
38933: EQUAL
38934: IFFALSE 38940
// MC_BuildUpgrade ( ) ;
38936: CALL 46489 0 0
// if event = 106 then
38940: LD_VAR 0 1
38944: PUSH
38945: LD_INT 106
38947: EQUAL
38948: IFFALSE 38954
// MC_PlantMines ( ) ;
38950: CALL 47368 0 0
// if event = 107 then
38954: LD_VAR 0 1
38958: PUSH
38959: LD_INT 107
38961: EQUAL
38962: IFFALSE 38968
// MC_CollectCrates ( ) ;
38964: CALL 48166 0 0
// if event = 108 then
38968: LD_VAR 0 1
38972: PUSH
38973: LD_INT 108
38975: EQUAL
38976: IFFALSE 38982
// MC_LinkRemoteControl ( ) ;
38978: CALL 49942 0 0
// if event = 109 then
38982: LD_VAR 0 1
38986: PUSH
38987: LD_INT 109
38989: EQUAL
38990: IFFALSE 38996
// MC_ProduceVehicle ( ) ;
38992: CALL 50123 0 0
// if event = 110 then
38996: LD_VAR 0 1
39000: PUSH
39001: LD_INT 110
39003: EQUAL
39004: IFFALSE 39010
// MC_SendAttack ( ) ;
39006: CALL 50589 0 0
// if event = 111 then
39010: LD_VAR 0 1
39014: PUSH
39015: LD_INT 111
39017: EQUAL
39018: IFFALSE 39024
// MC_Defend ( ) ;
39020: CALL 50697 0 0
// if event = 112 then
39024: LD_VAR 0 1
39028: PUSH
39029: LD_INT 112
39031: EQUAL
39032: IFFALSE 39038
// MC_Research ( ) ;
39034: CALL 51302 0 0
// if event = 113 then
39038: LD_VAR 0 1
39042: PUSH
39043: LD_INT 113
39045: EQUAL
39046: IFFALSE 39052
// MC_MinesTrigger ( ) ;
39048: CALL 52416 0 0
// if event = 120 then
39052: LD_VAR 0 1
39056: PUSH
39057: LD_INT 120
39059: EQUAL
39060: IFFALSE 39066
// MC_RepairVehicle ( ) ;
39062: CALL 52515 0 0
// if event = 121 then
39066: LD_VAR 0 1
39070: PUSH
39071: LD_INT 121
39073: EQUAL
39074: IFFALSE 39080
// MC_TameApe ( ) ;
39076: CALL 53245 0 0
// if event = 122 then
39080: LD_VAR 0 1
39084: PUSH
39085: LD_INT 122
39087: EQUAL
39088: IFFALSE 39094
// MC_ChangeApeClass ( ) ;
39090: CALL 54074 0 0
// if event = 123 then
39094: LD_VAR 0 1
39098: PUSH
39099: LD_INT 123
39101: EQUAL
39102: IFFALSE 39108
// MC_Bazooka ( ) ;
39104: CALL 54724 0 0
// if event = 124 then
39108: LD_VAR 0 1
39112: PUSH
39113: LD_INT 124
39115: EQUAL
39116: IFFALSE 39122
// MC_TeleportExit ( ) ;
39118: CALL 54922 0 0
// if event = 125 then
39122: LD_VAR 0 1
39126: PUSH
39127: LD_INT 125
39129: EQUAL
39130: IFFALSE 39136
// MC_Deposits ( ) ;
39132: CALL 55569 0 0
// if event = 126 then
39136: LD_VAR 0 1
39140: PUSH
39141: LD_INT 126
39143: EQUAL
39144: IFFALSE 39150
// MC_RemoteDriver ( ) ;
39146: CALL 56194 0 0
// if event = 200 then
39150: LD_VAR 0 1
39154: PUSH
39155: LD_INT 200
39157: EQUAL
39158: IFFALSE 39164
// MC_Idle ( ) ;
39160: CALL 58143 0 0
// end ;
39164: PPOPN 1
39166: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39167: LD_INT 0
39169: PPUSH
39170: PPUSH
// if not mc_bases [ base ] or not tag then
39171: LD_EXP 113
39175: PUSH
39176: LD_VAR 0 1
39180: ARRAY
39181: NOT
39182: PUSH
39183: LD_VAR 0 2
39187: NOT
39188: OR
39189: IFFALSE 39193
// exit ;
39191: GO 39257
// for i in mc_bases [ base ] union mc_ape [ base ] do
39193: LD_ADDR_VAR 0 4
39197: PUSH
39198: LD_EXP 113
39202: PUSH
39203: LD_VAR 0 1
39207: ARRAY
39208: PUSH
39209: LD_EXP 142
39213: PUSH
39214: LD_VAR 0 1
39218: ARRAY
39219: UNION
39220: PUSH
39221: FOR_IN
39222: IFFALSE 39255
// if GetTag ( i ) = tag then
39224: LD_VAR 0 4
39228: PPUSH
39229: CALL_OW 110
39233: PUSH
39234: LD_VAR 0 2
39238: EQUAL
39239: IFFALSE 39253
// SetTag ( i , 0 ) ;
39241: LD_VAR 0 4
39245: PPUSH
39246: LD_INT 0
39248: PPUSH
39249: CALL_OW 109
39253: GO 39221
39255: POP
39256: POP
// end ;
39257: LD_VAR 0 3
39261: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39262: LD_INT 0
39264: PPUSH
39265: PPUSH
39266: PPUSH
39267: PPUSH
39268: PPUSH
39269: PPUSH
39270: PPUSH
39271: PPUSH
// if not mc_bases then
39272: LD_EXP 113
39276: NOT
39277: IFFALSE 39281
// exit ;
39279: GO 39739
// for i = 1 to mc_bases do
39281: LD_ADDR_VAR 0 2
39285: PUSH
39286: DOUBLE
39287: LD_INT 1
39289: DEC
39290: ST_TO_ADDR
39291: LD_EXP 113
39295: PUSH
39296: FOR_TO
39297: IFFALSE 39737
// begin tmp := MC_ClassCheckReq ( i ) ;
39299: LD_ADDR_VAR 0 4
39303: PUSH
39304: LD_VAR 0 2
39308: PPUSH
39309: CALL 39744 0 1
39313: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39314: LD_ADDR_EXP 154
39318: PUSH
39319: LD_EXP 154
39323: PPUSH
39324: LD_VAR 0 2
39328: PPUSH
39329: LD_VAR 0 4
39333: PPUSH
39334: CALL_OW 1
39338: ST_TO_ADDR
// if not tmp then
39339: LD_VAR 0 4
39343: NOT
39344: IFFALSE 39348
// continue ;
39346: GO 39296
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39348: LD_ADDR_VAR 0 6
39352: PUSH
39353: LD_EXP 113
39357: PUSH
39358: LD_VAR 0 2
39362: ARRAY
39363: PPUSH
39364: LD_INT 2
39366: PUSH
39367: LD_INT 30
39369: PUSH
39370: LD_INT 4
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 30
39379: PUSH
39380: LD_INT 5
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: LIST
39391: PPUSH
39392: CALL_OW 72
39396: PUSH
39397: LD_EXP 113
39401: PUSH
39402: LD_VAR 0 2
39406: ARRAY
39407: PPUSH
39408: LD_INT 2
39410: PUSH
39411: LD_INT 30
39413: PUSH
39414: LD_INT 0
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 30
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: LIST
39435: PPUSH
39436: CALL_OW 72
39440: PUSH
39441: LD_EXP 113
39445: PUSH
39446: LD_VAR 0 2
39450: ARRAY
39451: PPUSH
39452: LD_INT 30
39454: PUSH
39455: LD_INT 3
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PPUSH
39462: CALL_OW 72
39466: PUSH
39467: LD_EXP 113
39471: PUSH
39472: LD_VAR 0 2
39476: ARRAY
39477: PPUSH
39478: LD_INT 2
39480: PUSH
39481: LD_INT 30
39483: PUSH
39484: LD_INT 6
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 30
39493: PUSH
39494: LD_INT 7
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 30
39503: PUSH
39504: LD_INT 8
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: PPUSH
39517: CALL_OW 72
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: ST_TO_ADDR
// for j = 1 to 4 do
39528: LD_ADDR_VAR 0 3
39532: PUSH
39533: DOUBLE
39534: LD_INT 1
39536: DEC
39537: ST_TO_ADDR
39538: LD_INT 4
39540: PUSH
39541: FOR_TO
39542: IFFALSE 39733
// begin if not tmp [ j ] then
39544: LD_VAR 0 4
39548: PUSH
39549: LD_VAR 0 3
39553: ARRAY
39554: NOT
39555: IFFALSE 39559
// continue ;
39557: GO 39541
// for p in tmp [ j ] do
39559: LD_ADDR_VAR 0 5
39563: PUSH
39564: LD_VAR 0 4
39568: PUSH
39569: LD_VAR 0 3
39573: ARRAY
39574: PUSH
39575: FOR_IN
39576: IFFALSE 39729
// begin if not b [ j ] then
39578: LD_VAR 0 6
39582: PUSH
39583: LD_VAR 0 3
39587: ARRAY
39588: NOT
39589: IFFALSE 39593
// break ;
39591: GO 39729
// e := 0 ;
39593: LD_ADDR_VAR 0 7
39597: PUSH
39598: LD_INT 0
39600: ST_TO_ADDR
// for k in b [ j ] do
39601: LD_ADDR_VAR 0 8
39605: PUSH
39606: LD_VAR 0 6
39610: PUSH
39611: LD_VAR 0 3
39615: ARRAY
39616: PUSH
39617: FOR_IN
39618: IFFALSE 39645
// if IsNotFull ( k ) then
39620: LD_VAR 0 8
39624: PPUSH
39625: CALL 67324 0 1
39629: IFFALSE 39643
// begin e := k ;
39631: LD_ADDR_VAR 0 7
39635: PUSH
39636: LD_VAR 0 8
39640: ST_TO_ADDR
// break ;
39641: GO 39645
// end ;
39643: GO 39617
39645: POP
39646: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39647: LD_VAR 0 7
39651: PUSH
39652: LD_VAR 0 5
39656: PPUSH
39657: LD_VAR 0 7
39661: PPUSH
39662: CALL 99744 0 2
39666: NOT
39667: AND
39668: IFFALSE 39727
// begin if IsInUnit ( p ) then
39670: LD_VAR 0 5
39674: PPUSH
39675: CALL_OW 310
39679: IFFALSE 39690
// ComExitBuilding ( p ) ;
39681: LD_VAR 0 5
39685: PPUSH
39686: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39690: LD_VAR 0 5
39694: PPUSH
39695: LD_VAR 0 7
39699: PPUSH
39700: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39704: LD_VAR 0 5
39708: PPUSH
39709: LD_VAR 0 3
39713: PPUSH
39714: CALL_OW 183
// AddComExitBuilding ( p ) ;
39718: LD_VAR 0 5
39722: PPUSH
39723: CALL_OW 182
// end ; end ;
39727: GO 39575
39729: POP
39730: POP
// end ;
39731: GO 39541
39733: POP
39734: POP
// end ;
39735: GO 39296
39737: POP
39738: POP
// end ;
39739: LD_VAR 0 1
39743: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39744: LD_INT 0
39746: PPUSH
39747: PPUSH
39748: PPUSH
39749: PPUSH
39750: PPUSH
39751: PPUSH
39752: PPUSH
39753: PPUSH
39754: PPUSH
39755: PPUSH
39756: PPUSH
39757: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39758: LD_VAR 0 1
39762: NOT
39763: PUSH
39764: LD_EXP 113
39768: PUSH
39769: LD_VAR 0 1
39773: ARRAY
39774: NOT
39775: OR
39776: PUSH
39777: LD_EXP 113
39781: PUSH
39782: LD_VAR 0 1
39786: ARRAY
39787: PPUSH
39788: LD_INT 2
39790: PUSH
39791: LD_INT 30
39793: PUSH
39794: LD_INT 0
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 30
39803: PUSH
39804: LD_INT 1
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: LIST
39815: PPUSH
39816: CALL_OW 72
39820: NOT
39821: OR
39822: IFFALSE 39826
// exit ;
39824: GO 43329
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39826: LD_ADDR_VAR 0 4
39830: PUSH
39831: LD_EXP 113
39835: PUSH
39836: LD_VAR 0 1
39840: ARRAY
39841: PPUSH
39842: LD_INT 2
39844: PUSH
39845: LD_INT 25
39847: PUSH
39848: LD_INT 1
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 25
39857: PUSH
39858: LD_INT 2
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 25
39867: PUSH
39868: LD_INT 3
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 25
39877: PUSH
39878: LD_INT 4
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 25
39887: PUSH
39888: LD_INT 5
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 25
39897: PUSH
39898: LD_INT 8
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 25
39907: PUSH
39908: LD_INT 9
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: PPUSH
39925: CALL_OW 72
39929: ST_TO_ADDR
// if not tmp then
39930: LD_VAR 0 4
39934: NOT
39935: IFFALSE 39939
// exit ;
39937: GO 43329
// for i in tmp do
39939: LD_ADDR_VAR 0 3
39943: PUSH
39944: LD_VAR 0 4
39948: PUSH
39949: FOR_IN
39950: IFFALSE 39981
// if GetTag ( i ) then
39952: LD_VAR 0 3
39956: PPUSH
39957: CALL_OW 110
39961: IFFALSE 39979
// tmp := tmp diff i ;
39963: LD_ADDR_VAR 0 4
39967: PUSH
39968: LD_VAR 0 4
39972: PUSH
39973: LD_VAR 0 3
39977: DIFF
39978: ST_TO_ADDR
39979: GO 39949
39981: POP
39982: POP
// if not tmp then
39983: LD_VAR 0 4
39987: NOT
39988: IFFALSE 39992
// exit ;
39990: GO 43329
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39992: LD_ADDR_VAR 0 5
39996: PUSH
39997: LD_EXP 113
40001: PUSH
40002: LD_VAR 0 1
40006: ARRAY
40007: PPUSH
40008: LD_INT 2
40010: PUSH
40011: LD_INT 25
40013: PUSH
40014: LD_INT 1
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 25
40023: PUSH
40024: LD_INT 5
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 25
40033: PUSH
40034: LD_INT 8
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 25
40043: PUSH
40044: LD_INT 9
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: PPUSH
40058: CALL_OW 72
40062: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40063: LD_ADDR_VAR 0 6
40067: PUSH
40068: LD_EXP 113
40072: PUSH
40073: LD_VAR 0 1
40077: ARRAY
40078: PPUSH
40079: LD_INT 25
40081: PUSH
40082: LD_INT 2
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PPUSH
40089: CALL_OW 72
40093: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40094: LD_ADDR_VAR 0 7
40098: PUSH
40099: LD_EXP 113
40103: PUSH
40104: LD_VAR 0 1
40108: ARRAY
40109: PPUSH
40110: LD_INT 25
40112: PUSH
40113: LD_INT 3
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PPUSH
40120: CALL_OW 72
40124: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40125: LD_ADDR_VAR 0 8
40129: PUSH
40130: LD_EXP 113
40134: PUSH
40135: LD_VAR 0 1
40139: ARRAY
40140: PPUSH
40141: LD_INT 25
40143: PUSH
40144: LD_INT 4
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 24
40153: PUSH
40154: LD_INT 251
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PPUSH
40165: CALL_OW 72
40169: ST_TO_ADDR
// if mc_scan [ base ] then
40170: LD_EXP 136
40174: PUSH
40175: LD_VAR 0 1
40179: ARRAY
40180: IFFALSE 40641
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40182: LD_ADDR_EXP 155
40186: PUSH
40187: LD_EXP 155
40191: PPUSH
40192: LD_VAR 0 1
40196: PPUSH
40197: LD_INT 4
40199: PPUSH
40200: CALL_OW 1
40204: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40205: LD_ADDR_VAR 0 12
40209: PUSH
40210: LD_EXP 113
40214: PUSH
40215: LD_VAR 0 1
40219: ARRAY
40220: PPUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 30
40226: PUSH
40227: LD_INT 4
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 30
40236: PUSH
40237: LD_INT 5
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: LIST
40248: PPUSH
40249: CALL_OW 72
40253: ST_TO_ADDR
// if not b then
40254: LD_VAR 0 12
40258: NOT
40259: IFFALSE 40263
// exit ;
40261: GO 43329
// p := [ ] ;
40263: LD_ADDR_VAR 0 11
40267: PUSH
40268: EMPTY
40269: ST_TO_ADDR
// if sci >= 2 then
40270: LD_VAR 0 8
40274: PUSH
40275: LD_INT 2
40277: GREATEREQUAL
40278: IFFALSE 40309
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40280: LD_ADDR_VAR 0 8
40284: PUSH
40285: LD_VAR 0 8
40289: PUSH
40290: LD_INT 1
40292: ARRAY
40293: PUSH
40294: LD_VAR 0 8
40298: PUSH
40299: LD_INT 2
40301: ARRAY
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: ST_TO_ADDR
40307: GO 40370
// if sci = 1 then
40309: LD_VAR 0 8
40313: PUSH
40314: LD_INT 1
40316: EQUAL
40317: IFFALSE 40338
// sci := [ sci [ 1 ] ] else
40319: LD_ADDR_VAR 0 8
40323: PUSH
40324: LD_VAR 0 8
40328: PUSH
40329: LD_INT 1
40331: ARRAY
40332: PUSH
40333: EMPTY
40334: LIST
40335: ST_TO_ADDR
40336: GO 40370
// if sci = 0 then
40338: LD_VAR 0 8
40342: PUSH
40343: LD_INT 0
40345: EQUAL
40346: IFFALSE 40370
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40348: LD_ADDR_VAR 0 11
40352: PUSH
40353: LD_VAR 0 4
40357: PPUSH
40358: LD_INT 4
40360: PPUSH
40361: CALL 99607 0 2
40365: PUSH
40366: LD_INT 1
40368: ARRAY
40369: ST_TO_ADDR
// if eng > 4 then
40370: LD_VAR 0 6
40374: PUSH
40375: LD_INT 4
40377: GREATER
40378: IFFALSE 40424
// for i = eng downto 4 do
40380: LD_ADDR_VAR 0 3
40384: PUSH
40385: DOUBLE
40386: LD_VAR 0 6
40390: INC
40391: ST_TO_ADDR
40392: LD_INT 4
40394: PUSH
40395: FOR_DOWNTO
40396: IFFALSE 40422
// eng := eng diff eng [ i ] ;
40398: LD_ADDR_VAR 0 6
40402: PUSH
40403: LD_VAR 0 6
40407: PUSH
40408: LD_VAR 0 6
40412: PUSH
40413: LD_VAR 0 3
40417: ARRAY
40418: DIFF
40419: ST_TO_ADDR
40420: GO 40395
40422: POP
40423: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40424: LD_ADDR_VAR 0 4
40428: PUSH
40429: LD_VAR 0 4
40433: PUSH
40434: LD_VAR 0 5
40438: PUSH
40439: LD_VAR 0 6
40443: UNION
40444: PUSH
40445: LD_VAR 0 7
40449: UNION
40450: PUSH
40451: LD_VAR 0 8
40455: UNION
40456: DIFF
40457: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40458: LD_ADDR_VAR 0 13
40462: PUSH
40463: LD_EXP 113
40467: PUSH
40468: LD_VAR 0 1
40472: ARRAY
40473: PPUSH
40474: LD_INT 2
40476: PUSH
40477: LD_INT 30
40479: PUSH
40480: LD_INT 32
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 30
40489: PUSH
40490: LD_INT 31
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: LIST
40501: PPUSH
40502: CALL_OW 72
40506: PUSH
40507: LD_EXP 113
40511: PUSH
40512: LD_VAR 0 1
40516: ARRAY
40517: PPUSH
40518: LD_INT 2
40520: PUSH
40521: LD_INT 30
40523: PUSH
40524: LD_INT 4
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 30
40533: PUSH
40534: LD_INT 5
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: LIST
40545: PPUSH
40546: CALL_OW 72
40550: PUSH
40551: LD_INT 6
40553: MUL
40554: PLUS
40555: ST_TO_ADDR
// if bcount < tmp then
40556: LD_VAR 0 13
40560: PUSH
40561: LD_VAR 0 4
40565: LESS
40566: IFFALSE 40612
// for i = tmp downto bcount do
40568: LD_ADDR_VAR 0 3
40572: PUSH
40573: DOUBLE
40574: LD_VAR 0 4
40578: INC
40579: ST_TO_ADDR
40580: LD_VAR 0 13
40584: PUSH
40585: FOR_DOWNTO
40586: IFFALSE 40610
// tmp := Delete ( tmp , tmp ) ;
40588: LD_ADDR_VAR 0 4
40592: PUSH
40593: LD_VAR 0 4
40597: PPUSH
40598: LD_VAR 0 4
40602: PPUSH
40603: CALL_OW 3
40607: ST_TO_ADDR
40608: GO 40585
40610: POP
40611: POP
// result := [ tmp , 0 , 0 , p ] ;
40612: LD_ADDR_VAR 0 2
40616: PUSH
40617: LD_VAR 0 4
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: LD_INT 0
40627: PUSH
40628: LD_VAR 0 11
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: ST_TO_ADDR
// exit ;
40639: GO 43329
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40641: LD_EXP 113
40645: PUSH
40646: LD_VAR 0 1
40650: ARRAY
40651: PPUSH
40652: LD_INT 2
40654: PUSH
40655: LD_INT 30
40657: PUSH
40658: LD_INT 6
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 30
40667: PUSH
40668: LD_INT 7
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 30
40677: PUSH
40678: LD_INT 8
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: PPUSH
40691: CALL_OW 72
40695: NOT
40696: PUSH
40697: LD_EXP 113
40701: PUSH
40702: LD_VAR 0 1
40706: ARRAY
40707: PPUSH
40708: LD_INT 30
40710: PUSH
40711: LD_INT 3
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PPUSH
40718: CALL_OW 72
40722: NOT
40723: AND
40724: IFFALSE 40796
// begin if eng = tmp then
40726: LD_VAR 0 6
40730: PUSH
40731: LD_VAR 0 4
40735: EQUAL
40736: IFFALSE 40740
// exit ;
40738: GO 43329
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40740: LD_ADDR_EXP 155
40744: PUSH
40745: LD_EXP 155
40749: PPUSH
40750: LD_VAR 0 1
40754: PPUSH
40755: LD_INT 1
40757: PPUSH
40758: CALL_OW 1
40762: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40763: LD_ADDR_VAR 0 2
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: LD_VAR 0 4
40775: PUSH
40776: LD_VAR 0 6
40780: DIFF
40781: PUSH
40782: LD_INT 0
40784: PUSH
40785: LD_INT 0
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: ST_TO_ADDR
// exit ;
40794: GO 43329
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40796: LD_EXP 140
40800: PUSH
40801: LD_EXP 139
40805: PUSH
40806: LD_VAR 0 1
40810: ARRAY
40811: ARRAY
40812: PUSH
40813: LD_EXP 113
40817: PUSH
40818: LD_VAR 0 1
40822: ARRAY
40823: PPUSH
40824: LD_INT 2
40826: PUSH
40827: LD_INT 30
40829: PUSH
40830: LD_INT 6
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 30
40839: PUSH
40840: LD_INT 7
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 30
40849: PUSH
40850: LD_INT 8
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: PPUSH
40863: CALL_OW 72
40867: AND
40868: PUSH
40869: LD_EXP 113
40873: PUSH
40874: LD_VAR 0 1
40878: ARRAY
40879: PPUSH
40880: LD_INT 30
40882: PUSH
40883: LD_INT 3
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PPUSH
40890: CALL_OW 72
40894: NOT
40895: AND
40896: IFFALSE 41110
// begin if sci >= 6 then
40898: LD_VAR 0 8
40902: PUSH
40903: LD_INT 6
40905: GREATEREQUAL
40906: IFFALSE 40910
// exit ;
40908: GO 43329
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40910: LD_ADDR_EXP 155
40914: PUSH
40915: LD_EXP 155
40919: PPUSH
40920: LD_VAR 0 1
40924: PPUSH
40925: LD_INT 2
40927: PPUSH
40928: CALL_OW 1
40932: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40933: LD_ADDR_VAR 0 9
40937: PUSH
40938: LD_VAR 0 4
40942: PUSH
40943: LD_VAR 0 8
40947: DIFF
40948: PPUSH
40949: LD_INT 4
40951: PPUSH
40952: CALL 99607 0 2
40956: ST_TO_ADDR
// p := [ ] ;
40957: LD_ADDR_VAR 0 11
40961: PUSH
40962: EMPTY
40963: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40964: LD_VAR 0 8
40968: PUSH
40969: LD_INT 6
40971: LESS
40972: PUSH
40973: LD_VAR 0 9
40977: PUSH
40978: LD_INT 6
40980: GREATER
40981: AND
40982: IFFALSE 41063
// begin for i = 1 to 6 - sci do
40984: LD_ADDR_VAR 0 3
40988: PUSH
40989: DOUBLE
40990: LD_INT 1
40992: DEC
40993: ST_TO_ADDR
40994: LD_INT 6
40996: PUSH
40997: LD_VAR 0 8
41001: MINUS
41002: PUSH
41003: FOR_TO
41004: IFFALSE 41059
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41006: LD_ADDR_VAR 0 11
41010: PUSH
41011: LD_VAR 0 11
41015: PPUSH
41016: LD_VAR 0 11
41020: PUSH
41021: LD_INT 1
41023: PLUS
41024: PPUSH
41025: LD_VAR 0 9
41029: PUSH
41030: LD_INT 1
41032: ARRAY
41033: PPUSH
41034: CALL_OW 2
41038: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41039: LD_ADDR_VAR 0 9
41043: PUSH
41044: LD_VAR 0 9
41048: PPUSH
41049: LD_INT 1
41051: PPUSH
41052: CALL_OW 3
41056: ST_TO_ADDR
// end ;
41057: GO 41003
41059: POP
41060: POP
// end else
41061: GO 41083
// if sort then
41063: LD_VAR 0 9
41067: IFFALSE 41083
// p := sort [ 1 ] ;
41069: LD_ADDR_VAR 0 11
41073: PUSH
41074: LD_VAR 0 9
41078: PUSH
41079: LD_INT 1
41081: ARRAY
41082: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41083: LD_ADDR_VAR 0 2
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: LD_INT 0
41096: PUSH
41097: LD_VAR 0 11
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: ST_TO_ADDR
// exit ;
41108: GO 43329
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41110: LD_EXP 140
41114: PUSH
41115: LD_EXP 139
41119: PUSH
41120: LD_VAR 0 1
41124: ARRAY
41125: ARRAY
41126: PUSH
41127: LD_EXP 113
41131: PUSH
41132: LD_VAR 0 1
41136: ARRAY
41137: PPUSH
41138: LD_INT 2
41140: PUSH
41141: LD_INT 30
41143: PUSH
41144: LD_INT 6
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 30
41153: PUSH
41154: LD_INT 7
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: LD_INT 30
41163: PUSH
41164: LD_INT 8
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: LIST
41175: LIST
41176: PPUSH
41177: CALL_OW 72
41181: AND
41182: PUSH
41183: LD_EXP 113
41187: PUSH
41188: LD_VAR 0 1
41192: ARRAY
41193: PPUSH
41194: LD_INT 30
41196: PUSH
41197: LD_INT 3
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PPUSH
41204: CALL_OW 72
41208: AND
41209: IFFALSE 41943
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41211: LD_ADDR_EXP 155
41215: PUSH
41216: LD_EXP 155
41220: PPUSH
41221: LD_VAR 0 1
41225: PPUSH
41226: LD_INT 3
41228: PPUSH
41229: CALL_OW 1
41233: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41234: LD_ADDR_VAR 0 2
41238: PUSH
41239: LD_INT 0
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: LD_INT 0
41247: PUSH
41248: LD_INT 0
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: ST_TO_ADDR
// if not eng then
41257: LD_VAR 0 6
41261: NOT
41262: IFFALSE 41325
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41264: LD_ADDR_VAR 0 11
41268: PUSH
41269: LD_VAR 0 4
41273: PPUSH
41274: LD_INT 2
41276: PPUSH
41277: CALL 99607 0 2
41281: PUSH
41282: LD_INT 1
41284: ARRAY
41285: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41286: LD_ADDR_VAR 0 2
41290: PUSH
41291: LD_VAR 0 2
41295: PPUSH
41296: LD_INT 2
41298: PPUSH
41299: LD_VAR 0 11
41303: PPUSH
41304: CALL_OW 1
41308: ST_TO_ADDR
// tmp := tmp diff p ;
41309: LD_ADDR_VAR 0 4
41313: PUSH
41314: LD_VAR 0 4
41318: PUSH
41319: LD_VAR 0 11
41323: DIFF
41324: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41325: LD_VAR 0 4
41329: PUSH
41330: LD_VAR 0 8
41334: PUSH
41335: LD_INT 6
41337: LESS
41338: AND
41339: IFFALSE 41527
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41341: LD_ADDR_VAR 0 9
41345: PUSH
41346: LD_VAR 0 4
41350: PUSH
41351: LD_VAR 0 8
41355: PUSH
41356: LD_VAR 0 7
41360: UNION
41361: DIFF
41362: PPUSH
41363: LD_INT 4
41365: PPUSH
41366: CALL 99607 0 2
41370: ST_TO_ADDR
// p := [ ] ;
41371: LD_ADDR_VAR 0 11
41375: PUSH
41376: EMPTY
41377: ST_TO_ADDR
// if sort then
41378: LD_VAR 0 9
41382: IFFALSE 41498
// for i = 1 to 6 - sci do
41384: LD_ADDR_VAR 0 3
41388: PUSH
41389: DOUBLE
41390: LD_INT 1
41392: DEC
41393: ST_TO_ADDR
41394: LD_INT 6
41396: PUSH
41397: LD_VAR 0 8
41401: MINUS
41402: PUSH
41403: FOR_TO
41404: IFFALSE 41496
// begin if i = sort then
41406: LD_VAR 0 3
41410: PUSH
41411: LD_VAR 0 9
41415: EQUAL
41416: IFFALSE 41420
// break ;
41418: GO 41496
// if GetClass ( i ) = 4 then
41420: LD_VAR 0 3
41424: PPUSH
41425: CALL_OW 257
41429: PUSH
41430: LD_INT 4
41432: EQUAL
41433: IFFALSE 41437
// continue ;
41435: GO 41403
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41437: LD_ADDR_VAR 0 11
41441: PUSH
41442: LD_VAR 0 11
41446: PPUSH
41447: LD_VAR 0 11
41451: PUSH
41452: LD_INT 1
41454: PLUS
41455: PPUSH
41456: LD_VAR 0 9
41460: PUSH
41461: LD_VAR 0 3
41465: ARRAY
41466: PPUSH
41467: CALL_OW 2
41471: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41472: LD_ADDR_VAR 0 4
41476: PUSH
41477: LD_VAR 0 4
41481: PUSH
41482: LD_VAR 0 9
41486: PUSH
41487: LD_VAR 0 3
41491: ARRAY
41492: DIFF
41493: ST_TO_ADDR
// end ;
41494: GO 41403
41496: POP
41497: POP
// if p then
41498: LD_VAR 0 11
41502: IFFALSE 41527
// result := Replace ( result , 4 , p ) ;
41504: LD_ADDR_VAR 0 2
41508: PUSH
41509: LD_VAR 0 2
41513: PPUSH
41514: LD_INT 4
41516: PPUSH
41517: LD_VAR 0 11
41521: PPUSH
41522: CALL_OW 1
41526: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41527: LD_VAR 0 4
41531: PUSH
41532: LD_VAR 0 7
41536: PUSH
41537: LD_INT 6
41539: LESS
41540: AND
41541: IFFALSE 41729
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41543: LD_ADDR_VAR 0 9
41547: PUSH
41548: LD_VAR 0 4
41552: PUSH
41553: LD_VAR 0 8
41557: PUSH
41558: LD_VAR 0 7
41562: UNION
41563: DIFF
41564: PPUSH
41565: LD_INT 3
41567: PPUSH
41568: CALL 99607 0 2
41572: ST_TO_ADDR
// p := [ ] ;
41573: LD_ADDR_VAR 0 11
41577: PUSH
41578: EMPTY
41579: ST_TO_ADDR
// if sort then
41580: LD_VAR 0 9
41584: IFFALSE 41700
// for i = 1 to 6 - mech do
41586: LD_ADDR_VAR 0 3
41590: PUSH
41591: DOUBLE
41592: LD_INT 1
41594: DEC
41595: ST_TO_ADDR
41596: LD_INT 6
41598: PUSH
41599: LD_VAR 0 7
41603: MINUS
41604: PUSH
41605: FOR_TO
41606: IFFALSE 41698
// begin if i = sort then
41608: LD_VAR 0 3
41612: PUSH
41613: LD_VAR 0 9
41617: EQUAL
41618: IFFALSE 41622
// break ;
41620: GO 41698
// if GetClass ( i ) = 3 then
41622: LD_VAR 0 3
41626: PPUSH
41627: CALL_OW 257
41631: PUSH
41632: LD_INT 3
41634: EQUAL
41635: IFFALSE 41639
// continue ;
41637: GO 41605
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41639: LD_ADDR_VAR 0 11
41643: PUSH
41644: LD_VAR 0 11
41648: PPUSH
41649: LD_VAR 0 11
41653: PUSH
41654: LD_INT 1
41656: PLUS
41657: PPUSH
41658: LD_VAR 0 9
41662: PUSH
41663: LD_VAR 0 3
41667: ARRAY
41668: PPUSH
41669: CALL_OW 2
41673: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41674: LD_ADDR_VAR 0 4
41678: PUSH
41679: LD_VAR 0 4
41683: PUSH
41684: LD_VAR 0 9
41688: PUSH
41689: LD_VAR 0 3
41693: ARRAY
41694: DIFF
41695: ST_TO_ADDR
// end ;
41696: GO 41605
41698: POP
41699: POP
// if p then
41700: LD_VAR 0 11
41704: IFFALSE 41729
// result := Replace ( result , 3 , p ) ;
41706: LD_ADDR_VAR 0 2
41710: PUSH
41711: LD_VAR 0 2
41715: PPUSH
41716: LD_INT 3
41718: PPUSH
41719: LD_VAR 0 11
41723: PPUSH
41724: CALL_OW 1
41728: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41729: LD_VAR 0 4
41733: PUSH
41734: LD_INT 6
41736: GREATER
41737: PUSH
41738: LD_VAR 0 6
41742: PUSH
41743: LD_INT 6
41745: LESS
41746: AND
41747: IFFALSE 41941
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41749: LD_ADDR_VAR 0 9
41753: PUSH
41754: LD_VAR 0 4
41758: PUSH
41759: LD_VAR 0 8
41763: PUSH
41764: LD_VAR 0 7
41768: UNION
41769: PUSH
41770: LD_VAR 0 6
41774: UNION
41775: DIFF
41776: PPUSH
41777: LD_INT 2
41779: PPUSH
41780: CALL 99607 0 2
41784: ST_TO_ADDR
// p := [ ] ;
41785: LD_ADDR_VAR 0 11
41789: PUSH
41790: EMPTY
41791: ST_TO_ADDR
// if sort then
41792: LD_VAR 0 9
41796: IFFALSE 41912
// for i = 1 to 6 - eng do
41798: LD_ADDR_VAR 0 3
41802: PUSH
41803: DOUBLE
41804: LD_INT 1
41806: DEC
41807: ST_TO_ADDR
41808: LD_INT 6
41810: PUSH
41811: LD_VAR 0 6
41815: MINUS
41816: PUSH
41817: FOR_TO
41818: IFFALSE 41910
// begin if i = sort then
41820: LD_VAR 0 3
41824: PUSH
41825: LD_VAR 0 9
41829: EQUAL
41830: IFFALSE 41834
// break ;
41832: GO 41910
// if GetClass ( i ) = 2 then
41834: LD_VAR 0 3
41838: PPUSH
41839: CALL_OW 257
41843: PUSH
41844: LD_INT 2
41846: EQUAL
41847: IFFALSE 41851
// continue ;
41849: GO 41817
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41851: LD_ADDR_VAR 0 11
41855: PUSH
41856: LD_VAR 0 11
41860: PPUSH
41861: LD_VAR 0 11
41865: PUSH
41866: LD_INT 1
41868: PLUS
41869: PPUSH
41870: LD_VAR 0 9
41874: PUSH
41875: LD_VAR 0 3
41879: ARRAY
41880: PPUSH
41881: CALL_OW 2
41885: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41886: LD_ADDR_VAR 0 4
41890: PUSH
41891: LD_VAR 0 4
41895: PUSH
41896: LD_VAR 0 9
41900: PUSH
41901: LD_VAR 0 3
41905: ARRAY
41906: DIFF
41907: ST_TO_ADDR
// end ;
41908: GO 41817
41910: POP
41911: POP
// if p then
41912: LD_VAR 0 11
41916: IFFALSE 41941
// result := Replace ( result , 2 , p ) ;
41918: LD_ADDR_VAR 0 2
41922: PUSH
41923: LD_VAR 0 2
41927: PPUSH
41928: LD_INT 2
41930: PPUSH
41931: LD_VAR 0 11
41935: PPUSH
41936: CALL_OW 1
41940: ST_TO_ADDR
// end ; exit ;
41941: GO 43329
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41943: LD_EXP 140
41947: PUSH
41948: LD_EXP 139
41952: PUSH
41953: LD_VAR 0 1
41957: ARRAY
41958: ARRAY
41959: NOT
41960: PUSH
41961: LD_EXP 113
41965: PUSH
41966: LD_VAR 0 1
41970: ARRAY
41971: PPUSH
41972: LD_INT 30
41974: PUSH
41975: LD_INT 3
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PPUSH
41982: CALL_OW 72
41986: AND
41987: PUSH
41988: LD_EXP 118
41992: PUSH
41993: LD_VAR 0 1
41997: ARRAY
41998: AND
41999: IFFALSE 42607
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42001: LD_ADDR_EXP 155
42005: PUSH
42006: LD_EXP 155
42010: PPUSH
42011: LD_VAR 0 1
42015: PPUSH
42016: LD_INT 5
42018: PPUSH
42019: CALL_OW 1
42023: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42024: LD_ADDR_VAR 0 2
42028: PUSH
42029: LD_INT 0
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: LD_INT 0
42037: PUSH
42038: LD_INT 0
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: ST_TO_ADDR
// if sci > 1 then
42047: LD_VAR 0 8
42051: PUSH
42052: LD_INT 1
42054: GREATER
42055: IFFALSE 42083
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42057: LD_ADDR_VAR 0 4
42061: PUSH
42062: LD_VAR 0 4
42066: PUSH
42067: LD_VAR 0 8
42071: PUSH
42072: LD_VAR 0 8
42076: PUSH
42077: LD_INT 1
42079: ARRAY
42080: DIFF
42081: DIFF
42082: ST_TO_ADDR
// if tmp and not sci then
42083: LD_VAR 0 4
42087: PUSH
42088: LD_VAR 0 8
42092: NOT
42093: AND
42094: IFFALSE 42163
// begin sort := SortBySkill ( tmp , 4 ) ;
42096: LD_ADDR_VAR 0 9
42100: PUSH
42101: LD_VAR 0 4
42105: PPUSH
42106: LD_INT 4
42108: PPUSH
42109: CALL 99607 0 2
42113: ST_TO_ADDR
// if sort then
42114: LD_VAR 0 9
42118: IFFALSE 42134
// p := sort [ 1 ] ;
42120: LD_ADDR_VAR 0 11
42124: PUSH
42125: LD_VAR 0 9
42129: PUSH
42130: LD_INT 1
42132: ARRAY
42133: ST_TO_ADDR
// if p then
42134: LD_VAR 0 11
42138: IFFALSE 42163
// result := Replace ( result , 4 , p ) ;
42140: LD_ADDR_VAR 0 2
42144: PUSH
42145: LD_VAR 0 2
42149: PPUSH
42150: LD_INT 4
42152: PPUSH
42153: LD_VAR 0 11
42157: PPUSH
42158: CALL_OW 1
42162: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42163: LD_ADDR_VAR 0 4
42167: PUSH
42168: LD_VAR 0 4
42172: PUSH
42173: LD_VAR 0 7
42177: DIFF
42178: ST_TO_ADDR
// if tmp and mech < 6 then
42179: LD_VAR 0 4
42183: PUSH
42184: LD_VAR 0 7
42188: PUSH
42189: LD_INT 6
42191: LESS
42192: AND
42193: IFFALSE 42381
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42195: LD_ADDR_VAR 0 9
42199: PUSH
42200: LD_VAR 0 4
42204: PUSH
42205: LD_VAR 0 8
42209: PUSH
42210: LD_VAR 0 7
42214: UNION
42215: DIFF
42216: PPUSH
42217: LD_INT 3
42219: PPUSH
42220: CALL 99607 0 2
42224: ST_TO_ADDR
// p := [ ] ;
42225: LD_ADDR_VAR 0 11
42229: PUSH
42230: EMPTY
42231: ST_TO_ADDR
// if sort then
42232: LD_VAR 0 9
42236: IFFALSE 42352
// for i = 1 to 6 - mech do
42238: LD_ADDR_VAR 0 3
42242: PUSH
42243: DOUBLE
42244: LD_INT 1
42246: DEC
42247: ST_TO_ADDR
42248: LD_INT 6
42250: PUSH
42251: LD_VAR 0 7
42255: MINUS
42256: PUSH
42257: FOR_TO
42258: IFFALSE 42350
// begin if i = sort then
42260: LD_VAR 0 3
42264: PUSH
42265: LD_VAR 0 9
42269: EQUAL
42270: IFFALSE 42274
// break ;
42272: GO 42350
// if GetClass ( i ) = 3 then
42274: LD_VAR 0 3
42278: PPUSH
42279: CALL_OW 257
42283: PUSH
42284: LD_INT 3
42286: EQUAL
42287: IFFALSE 42291
// continue ;
42289: GO 42257
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42291: LD_ADDR_VAR 0 11
42295: PUSH
42296: LD_VAR 0 11
42300: PPUSH
42301: LD_VAR 0 11
42305: PUSH
42306: LD_INT 1
42308: PLUS
42309: PPUSH
42310: LD_VAR 0 9
42314: PUSH
42315: LD_VAR 0 3
42319: ARRAY
42320: PPUSH
42321: CALL_OW 2
42325: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42326: LD_ADDR_VAR 0 4
42330: PUSH
42331: LD_VAR 0 4
42335: PUSH
42336: LD_VAR 0 9
42340: PUSH
42341: LD_VAR 0 3
42345: ARRAY
42346: DIFF
42347: ST_TO_ADDR
// end ;
42348: GO 42257
42350: POP
42351: POP
// if p then
42352: LD_VAR 0 11
42356: IFFALSE 42381
// result := Replace ( result , 3 , p ) ;
42358: LD_ADDR_VAR 0 2
42362: PUSH
42363: LD_VAR 0 2
42367: PPUSH
42368: LD_INT 3
42370: PPUSH
42371: LD_VAR 0 11
42375: PPUSH
42376: CALL_OW 1
42380: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42381: LD_ADDR_VAR 0 4
42385: PUSH
42386: LD_VAR 0 4
42390: PUSH
42391: LD_VAR 0 6
42395: DIFF
42396: ST_TO_ADDR
// if tmp and eng < 6 then
42397: LD_VAR 0 4
42401: PUSH
42402: LD_VAR 0 6
42406: PUSH
42407: LD_INT 6
42409: LESS
42410: AND
42411: IFFALSE 42605
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42413: LD_ADDR_VAR 0 9
42417: PUSH
42418: LD_VAR 0 4
42422: PUSH
42423: LD_VAR 0 8
42427: PUSH
42428: LD_VAR 0 7
42432: UNION
42433: PUSH
42434: LD_VAR 0 6
42438: UNION
42439: DIFF
42440: PPUSH
42441: LD_INT 2
42443: PPUSH
42444: CALL 99607 0 2
42448: ST_TO_ADDR
// p := [ ] ;
42449: LD_ADDR_VAR 0 11
42453: PUSH
42454: EMPTY
42455: ST_TO_ADDR
// if sort then
42456: LD_VAR 0 9
42460: IFFALSE 42576
// for i = 1 to 6 - eng do
42462: LD_ADDR_VAR 0 3
42466: PUSH
42467: DOUBLE
42468: LD_INT 1
42470: DEC
42471: ST_TO_ADDR
42472: LD_INT 6
42474: PUSH
42475: LD_VAR 0 6
42479: MINUS
42480: PUSH
42481: FOR_TO
42482: IFFALSE 42574
// begin if i = sort then
42484: LD_VAR 0 3
42488: PUSH
42489: LD_VAR 0 9
42493: EQUAL
42494: IFFALSE 42498
// break ;
42496: GO 42574
// if GetClass ( i ) = 2 then
42498: LD_VAR 0 3
42502: PPUSH
42503: CALL_OW 257
42507: PUSH
42508: LD_INT 2
42510: EQUAL
42511: IFFALSE 42515
// continue ;
42513: GO 42481
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42515: LD_ADDR_VAR 0 11
42519: PUSH
42520: LD_VAR 0 11
42524: PPUSH
42525: LD_VAR 0 11
42529: PUSH
42530: LD_INT 1
42532: PLUS
42533: PPUSH
42534: LD_VAR 0 9
42538: PUSH
42539: LD_VAR 0 3
42543: ARRAY
42544: PPUSH
42545: CALL_OW 2
42549: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42550: LD_ADDR_VAR 0 4
42554: PUSH
42555: LD_VAR 0 4
42559: PUSH
42560: LD_VAR 0 9
42564: PUSH
42565: LD_VAR 0 3
42569: ARRAY
42570: DIFF
42571: ST_TO_ADDR
// end ;
42572: GO 42481
42574: POP
42575: POP
// if p then
42576: LD_VAR 0 11
42580: IFFALSE 42605
// result := Replace ( result , 2 , p ) ;
42582: LD_ADDR_VAR 0 2
42586: PUSH
42587: LD_VAR 0 2
42591: PPUSH
42592: LD_INT 2
42594: PPUSH
42595: LD_VAR 0 11
42599: PPUSH
42600: CALL_OW 1
42604: ST_TO_ADDR
// end ; exit ;
42605: GO 43329
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42607: LD_EXP 140
42611: PUSH
42612: LD_EXP 139
42616: PUSH
42617: LD_VAR 0 1
42621: ARRAY
42622: ARRAY
42623: NOT
42624: PUSH
42625: LD_EXP 113
42629: PUSH
42630: LD_VAR 0 1
42634: ARRAY
42635: PPUSH
42636: LD_INT 30
42638: PUSH
42639: LD_INT 3
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PPUSH
42646: CALL_OW 72
42650: AND
42651: PUSH
42652: LD_EXP 118
42656: PUSH
42657: LD_VAR 0 1
42661: ARRAY
42662: NOT
42663: AND
42664: IFFALSE 43329
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42666: LD_ADDR_EXP 155
42670: PUSH
42671: LD_EXP 155
42675: PPUSH
42676: LD_VAR 0 1
42680: PPUSH
42681: LD_INT 6
42683: PPUSH
42684: CALL_OW 1
42688: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42689: LD_ADDR_VAR 0 2
42693: PUSH
42694: LD_INT 0
42696: PUSH
42697: LD_INT 0
42699: PUSH
42700: LD_INT 0
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: LIST
42710: LIST
42711: ST_TO_ADDR
// if sci >= 1 then
42712: LD_VAR 0 8
42716: PUSH
42717: LD_INT 1
42719: GREATEREQUAL
42720: IFFALSE 42742
// tmp := tmp diff sci [ 1 ] ;
42722: LD_ADDR_VAR 0 4
42726: PUSH
42727: LD_VAR 0 4
42731: PUSH
42732: LD_VAR 0 8
42736: PUSH
42737: LD_INT 1
42739: ARRAY
42740: DIFF
42741: ST_TO_ADDR
// if tmp and not sci then
42742: LD_VAR 0 4
42746: PUSH
42747: LD_VAR 0 8
42751: NOT
42752: AND
42753: IFFALSE 42822
// begin sort := SortBySkill ( tmp , 4 ) ;
42755: LD_ADDR_VAR 0 9
42759: PUSH
42760: LD_VAR 0 4
42764: PPUSH
42765: LD_INT 4
42767: PPUSH
42768: CALL 99607 0 2
42772: ST_TO_ADDR
// if sort then
42773: LD_VAR 0 9
42777: IFFALSE 42793
// p := sort [ 1 ] ;
42779: LD_ADDR_VAR 0 11
42783: PUSH
42784: LD_VAR 0 9
42788: PUSH
42789: LD_INT 1
42791: ARRAY
42792: ST_TO_ADDR
// if p then
42793: LD_VAR 0 11
42797: IFFALSE 42822
// result := Replace ( result , 4 , p ) ;
42799: LD_ADDR_VAR 0 2
42803: PUSH
42804: LD_VAR 0 2
42808: PPUSH
42809: LD_INT 4
42811: PPUSH
42812: LD_VAR 0 11
42816: PPUSH
42817: CALL_OW 1
42821: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42822: LD_ADDR_VAR 0 4
42826: PUSH
42827: LD_VAR 0 4
42831: PUSH
42832: LD_VAR 0 7
42836: DIFF
42837: ST_TO_ADDR
// if tmp and mech < 6 then
42838: LD_VAR 0 4
42842: PUSH
42843: LD_VAR 0 7
42847: PUSH
42848: LD_INT 6
42850: LESS
42851: AND
42852: IFFALSE 43034
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42854: LD_ADDR_VAR 0 9
42858: PUSH
42859: LD_VAR 0 4
42863: PUSH
42864: LD_VAR 0 7
42868: DIFF
42869: PPUSH
42870: LD_INT 3
42872: PPUSH
42873: CALL 99607 0 2
42877: ST_TO_ADDR
// p := [ ] ;
42878: LD_ADDR_VAR 0 11
42882: PUSH
42883: EMPTY
42884: ST_TO_ADDR
// if sort then
42885: LD_VAR 0 9
42889: IFFALSE 43005
// for i = 1 to 6 - mech do
42891: LD_ADDR_VAR 0 3
42895: PUSH
42896: DOUBLE
42897: LD_INT 1
42899: DEC
42900: ST_TO_ADDR
42901: LD_INT 6
42903: PUSH
42904: LD_VAR 0 7
42908: MINUS
42909: PUSH
42910: FOR_TO
42911: IFFALSE 43003
// begin if i = sort then
42913: LD_VAR 0 3
42917: PUSH
42918: LD_VAR 0 9
42922: EQUAL
42923: IFFALSE 42927
// break ;
42925: GO 43003
// if GetClass ( i ) = 3 then
42927: LD_VAR 0 3
42931: PPUSH
42932: CALL_OW 257
42936: PUSH
42937: LD_INT 3
42939: EQUAL
42940: IFFALSE 42944
// continue ;
42942: GO 42910
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42944: LD_ADDR_VAR 0 11
42948: PUSH
42949: LD_VAR 0 11
42953: PPUSH
42954: LD_VAR 0 11
42958: PUSH
42959: LD_INT 1
42961: PLUS
42962: PPUSH
42963: LD_VAR 0 9
42967: PUSH
42968: LD_VAR 0 3
42972: ARRAY
42973: PPUSH
42974: CALL_OW 2
42978: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42979: LD_ADDR_VAR 0 4
42983: PUSH
42984: LD_VAR 0 4
42988: PUSH
42989: LD_VAR 0 9
42993: PUSH
42994: LD_VAR 0 3
42998: ARRAY
42999: DIFF
43000: ST_TO_ADDR
// end ;
43001: GO 42910
43003: POP
43004: POP
// if p then
43005: LD_VAR 0 11
43009: IFFALSE 43034
// result := Replace ( result , 3 , p ) ;
43011: LD_ADDR_VAR 0 2
43015: PUSH
43016: LD_VAR 0 2
43020: PPUSH
43021: LD_INT 3
43023: PPUSH
43024: LD_VAR 0 11
43028: PPUSH
43029: CALL_OW 1
43033: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43034: LD_ADDR_VAR 0 4
43038: PUSH
43039: LD_VAR 0 4
43043: PUSH
43044: LD_VAR 0 6
43048: DIFF
43049: ST_TO_ADDR
// if tmp and eng < 4 then
43050: LD_VAR 0 4
43054: PUSH
43055: LD_VAR 0 6
43059: PUSH
43060: LD_INT 4
43062: LESS
43063: AND
43064: IFFALSE 43254
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43066: LD_ADDR_VAR 0 9
43070: PUSH
43071: LD_VAR 0 4
43075: PUSH
43076: LD_VAR 0 7
43080: PUSH
43081: LD_VAR 0 6
43085: UNION
43086: DIFF
43087: PPUSH
43088: LD_INT 2
43090: PPUSH
43091: CALL 99607 0 2
43095: ST_TO_ADDR
// p := [ ] ;
43096: LD_ADDR_VAR 0 11
43100: PUSH
43101: EMPTY
43102: ST_TO_ADDR
// if sort then
43103: LD_VAR 0 9
43107: IFFALSE 43223
// for i = 1 to 4 - eng do
43109: LD_ADDR_VAR 0 3
43113: PUSH
43114: DOUBLE
43115: LD_INT 1
43117: DEC
43118: ST_TO_ADDR
43119: LD_INT 4
43121: PUSH
43122: LD_VAR 0 6
43126: MINUS
43127: PUSH
43128: FOR_TO
43129: IFFALSE 43221
// begin if i = sort then
43131: LD_VAR 0 3
43135: PUSH
43136: LD_VAR 0 9
43140: EQUAL
43141: IFFALSE 43145
// break ;
43143: GO 43221
// if GetClass ( i ) = 2 then
43145: LD_VAR 0 3
43149: PPUSH
43150: CALL_OW 257
43154: PUSH
43155: LD_INT 2
43157: EQUAL
43158: IFFALSE 43162
// continue ;
43160: GO 43128
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43162: LD_ADDR_VAR 0 11
43166: PUSH
43167: LD_VAR 0 11
43171: PPUSH
43172: LD_VAR 0 11
43176: PUSH
43177: LD_INT 1
43179: PLUS
43180: PPUSH
43181: LD_VAR 0 9
43185: PUSH
43186: LD_VAR 0 3
43190: ARRAY
43191: PPUSH
43192: CALL_OW 2
43196: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43197: LD_ADDR_VAR 0 4
43201: PUSH
43202: LD_VAR 0 4
43206: PUSH
43207: LD_VAR 0 9
43211: PUSH
43212: LD_VAR 0 3
43216: ARRAY
43217: DIFF
43218: ST_TO_ADDR
// end ;
43219: GO 43128
43221: POP
43222: POP
// if p then
43223: LD_VAR 0 11
43227: IFFALSE 43252
// result := Replace ( result , 2 , p ) ;
43229: LD_ADDR_VAR 0 2
43233: PUSH
43234: LD_VAR 0 2
43238: PPUSH
43239: LD_INT 2
43241: PPUSH
43242: LD_VAR 0 11
43246: PPUSH
43247: CALL_OW 1
43251: ST_TO_ADDR
// end else
43252: GO 43298
// for i = eng downto 5 do
43254: LD_ADDR_VAR 0 3
43258: PUSH
43259: DOUBLE
43260: LD_VAR 0 6
43264: INC
43265: ST_TO_ADDR
43266: LD_INT 5
43268: PUSH
43269: FOR_DOWNTO
43270: IFFALSE 43296
// tmp := tmp union eng [ i ] ;
43272: LD_ADDR_VAR 0 4
43276: PUSH
43277: LD_VAR 0 4
43281: PUSH
43282: LD_VAR 0 6
43286: PUSH
43287: LD_VAR 0 3
43291: ARRAY
43292: UNION
43293: ST_TO_ADDR
43294: GO 43269
43296: POP
43297: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43298: LD_ADDR_VAR 0 2
43302: PUSH
43303: LD_VAR 0 2
43307: PPUSH
43308: LD_INT 1
43310: PPUSH
43311: LD_VAR 0 4
43315: PUSH
43316: LD_VAR 0 5
43320: DIFF
43321: PPUSH
43322: CALL_OW 1
43326: ST_TO_ADDR
// exit ;
43327: GO 43329
// end ; end ;
43329: LD_VAR 0 2
43333: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43334: LD_INT 0
43336: PPUSH
43337: PPUSH
43338: PPUSH
// if not mc_bases then
43339: LD_EXP 113
43343: NOT
43344: IFFALSE 43348
// exit ;
43346: GO 43454
// for i = 1 to mc_bases do
43348: LD_ADDR_VAR 0 2
43352: PUSH
43353: DOUBLE
43354: LD_INT 1
43356: DEC
43357: ST_TO_ADDR
43358: LD_EXP 113
43362: PUSH
43363: FOR_TO
43364: IFFALSE 43445
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43366: LD_ADDR_VAR 0 3
43370: PUSH
43371: LD_EXP 113
43375: PUSH
43376: LD_VAR 0 2
43380: ARRAY
43381: PPUSH
43382: LD_INT 21
43384: PUSH
43385: LD_INT 3
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 3
43394: PUSH
43395: LD_INT 24
43397: PUSH
43398: LD_INT 1000
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PPUSH
43413: CALL_OW 72
43417: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43418: LD_ADDR_EXP 114
43422: PUSH
43423: LD_EXP 114
43427: PPUSH
43428: LD_VAR 0 2
43432: PPUSH
43433: LD_VAR 0 3
43437: PPUSH
43438: CALL_OW 1
43442: ST_TO_ADDR
// end ;
43443: GO 43363
43445: POP
43446: POP
// RaiseSailEvent ( 101 ) ;
43447: LD_INT 101
43449: PPUSH
43450: CALL_OW 427
// end ;
43454: LD_VAR 0 1
43458: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43459: LD_INT 0
43461: PPUSH
43462: PPUSH
43463: PPUSH
43464: PPUSH
43465: PPUSH
43466: PPUSH
43467: PPUSH
// if not mc_bases then
43468: LD_EXP 113
43472: NOT
43473: IFFALSE 43477
// exit ;
43475: GO 44039
// for i = 1 to mc_bases do
43477: LD_ADDR_VAR 0 2
43481: PUSH
43482: DOUBLE
43483: LD_INT 1
43485: DEC
43486: ST_TO_ADDR
43487: LD_EXP 113
43491: PUSH
43492: FOR_TO
43493: IFFALSE 44030
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43495: LD_ADDR_VAR 0 5
43499: PUSH
43500: LD_EXP 113
43504: PUSH
43505: LD_VAR 0 2
43509: ARRAY
43510: PUSH
43511: LD_EXP 142
43515: PUSH
43516: LD_VAR 0 2
43520: ARRAY
43521: UNION
43522: PPUSH
43523: LD_INT 21
43525: PUSH
43526: LD_INT 1
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: LD_INT 1
43535: PUSH
43536: LD_INT 3
43538: PUSH
43539: LD_INT 54
43541: PUSH
43542: EMPTY
43543: LIST
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 3
43551: PUSH
43552: LD_INT 24
43554: PUSH
43555: LD_INT 800
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: LIST
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PPUSH
43575: CALL_OW 72
43579: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43580: LD_ADDR_VAR 0 6
43584: PUSH
43585: LD_EXP 113
43589: PUSH
43590: LD_VAR 0 2
43594: ARRAY
43595: PPUSH
43596: LD_INT 21
43598: PUSH
43599: LD_INT 1
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: PUSH
43609: LD_INT 3
43611: PUSH
43612: LD_INT 54
43614: PUSH
43615: EMPTY
43616: LIST
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 3
43624: PUSH
43625: LD_INT 24
43627: PUSH
43628: LD_INT 250
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: LIST
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PPUSH
43648: CALL_OW 72
43652: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43653: LD_ADDR_VAR 0 7
43657: PUSH
43658: LD_VAR 0 5
43662: PUSH
43663: LD_VAR 0 6
43667: DIFF
43668: ST_TO_ADDR
// if not need_heal_1 then
43669: LD_VAR 0 6
43673: NOT
43674: IFFALSE 43707
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43676: LD_ADDR_EXP 116
43680: PUSH
43681: LD_EXP 116
43685: PPUSH
43686: LD_VAR 0 2
43690: PUSH
43691: LD_INT 1
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PPUSH
43698: EMPTY
43699: PPUSH
43700: CALL 70058 0 3
43704: ST_TO_ADDR
43705: GO 43777
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43707: LD_ADDR_EXP 116
43711: PUSH
43712: LD_EXP 116
43716: PPUSH
43717: LD_VAR 0 2
43721: PUSH
43722: LD_INT 1
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PPUSH
43729: LD_EXP 116
43733: PUSH
43734: LD_VAR 0 2
43738: ARRAY
43739: PUSH
43740: LD_INT 1
43742: ARRAY
43743: PPUSH
43744: LD_INT 3
43746: PUSH
43747: LD_INT 24
43749: PUSH
43750: LD_INT 1000
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PPUSH
43761: CALL_OW 72
43765: PUSH
43766: LD_VAR 0 6
43770: UNION
43771: PPUSH
43772: CALL 70058 0 3
43776: ST_TO_ADDR
// if not need_heal_2 then
43777: LD_VAR 0 7
43781: NOT
43782: IFFALSE 43815
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43784: LD_ADDR_EXP 116
43788: PUSH
43789: LD_EXP 116
43793: PPUSH
43794: LD_VAR 0 2
43798: PUSH
43799: LD_INT 2
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PPUSH
43806: EMPTY
43807: PPUSH
43808: CALL 70058 0 3
43812: ST_TO_ADDR
43813: GO 43847
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43815: LD_ADDR_EXP 116
43819: PUSH
43820: LD_EXP 116
43824: PPUSH
43825: LD_VAR 0 2
43829: PUSH
43830: LD_INT 2
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PPUSH
43837: LD_VAR 0 7
43841: PPUSH
43842: CALL 70058 0 3
43846: ST_TO_ADDR
// if need_heal_2 then
43847: LD_VAR 0 7
43851: IFFALSE 44012
// for j in need_heal_2 do
43853: LD_ADDR_VAR 0 3
43857: PUSH
43858: LD_VAR 0 7
43862: PUSH
43863: FOR_IN
43864: IFFALSE 44010
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43866: LD_ADDR_VAR 0 5
43870: PUSH
43871: LD_EXP 113
43875: PUSH
43876: LD_VAR 0 2
43880: ARRAY
43881: PPUSH
43882: LD_INT 2
43884: PUSH
43885: LD_INT 30
43887: PUSH
43888: LD_INT 6
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 30
43897: PUSH
43898: LD_INT 7
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 30
43907: PUSH
43908: LD_INT 8
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: PUSH
43915: LD_INT 30
43917: PUSH
43918: LD_INT 0
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 30
43927: PUSH
43928: LD_INT 1
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: LIST
43939: LIST
43940: LIST
43941: LIST
43942: PPUSH
43943: CALL_OW 72
43947: ST_TO_ADDR
// if tmp then
43948: LD_VAR 0 5
43952: IFFALSE 44008
// begin k := NearestUnitToUnit ( tmp , j ) ;
43954: LD_ADDR_VAR 0 4
43958: PUSH
43959: LD_VAR 0 5
43963: PPUSH
43964: LD_VAR 0 3
43968: PPUSH
43969: CALL_OW 74
43973: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43974: LD_VAR 0 3
43978: PPUSH
43979: LD_VAR 0 4
43983: PPUSH
43984: CALL_OW 296
43988: PUSH
43989: LD_INT 5
43991: GREATER
43992: IFFALSE 44008
// ComMoveUnit ( j , k ) ;
43994: LD_VAR 0 3
43998: PPUSH
43999: LD_VAR 0 4
44003: PPUSH
44004: CALL_OW 112
// end ; end ;
44008: GO 43863
44010: POP
44011: POP
// if not need_heal_1 and not need_heal_2 then
44012: LD_VAR 0 6
44016: NOT
44017: PUSH
44018: LD_VAR 0 7
44022: NOT
44023: AND
44024: IFFALSE 44028
// continue ;
44026: GO 43492
// end ;
44028: GO 43492
44030: POP
44031: POP
// RaiseSailEvent ( 102 ) ;
44032: LD_INT 102
44034: PPUSH
44035: CALL_OW 427
// end ;
44039: LD_VAR 0 1
44043: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44044: LD_INT 0
44046: PPUSH
44047: PPUSH
44048: PPUSH
44049: PPUSH
44050: PPUSH
44051: PPUSH
44052: PPUSH
44053: PPUSH
// if not mc_bases then
44054: LD_EXP 113
44058: NOT
44059: IFFALSE 44063
// exit ;
44061: GO 44898
// for i = 1 to mc_bases do
44063: LD_ADDR_VAR 0 2
44067: PUSH
44068: DOUBLE
44069: LD_INT 1
44071: DEC
44072: ST_TO_ADDR
44073: LD_EXP 113
44077: PUSH
44078: FOR_TO
44079: IFFALSE 44896
// begin if not mc_building_need_repair [ i ] then
44081: LD_EXP 114
44085: PUSH
44086: LD_VAR 0 2
44090: ARRAY
44091: NOT
44092: IFFALSE 44266
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
44094: LD_ADDR_VAR 0 6
44098: PUSH
44099: LD_EXP 132
44103: PUSH
44104: LD_VAR 0 2
44108: ARRAY
44109: PPUSH
44110: LD_INT 3
44112: PUSH
44113: LD_INT 24
44115: PUSH
44116: LD_INT 1000
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 2
44129: PUSH
44130: LD_INT 34
44132: PUSH
44133: LD_INT 13
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: LD_INT 34
44142: PUSH
44143: LD_INT 52
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: LIST
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PPUSH
44159: CALL_OW 72
44163: ST_TO_ADDR
// if cranes then
44164: LD_VAR 0 6
44168: IFFALSE 44230
// for j in cranes do
44170: LD_ADDR_VAR 0 3
44174: PUSH
44175: LD_VAR 0 6
44179: PUSH
44180: FOR_IN
44181: IFFALSE 44228
// if not IsInArea ( j , mc_parking [ i ] ) then
44183: LD_VAR 0 3
44187: PPUSH
44188: LD_EXP 137
44192: PUSH
44193: LD_VAR 0 2
44197: ARRAY
44198: PPUSH
44199: CALL_OW 308
44203: NOT
44204: IFFALSE 44226
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44206: LD_VAR 0 3
44210: PPUSH
44211: LD_EXP 137
44215: PUSH
44216: LD_VAR 0 2
44220: ARRAY
44221: PPUSH
44222: CALL_OW 113
44226: GO 44180
44228: POP
44229: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44230: LD_ADDR_EXP 115
44234: PUSH
44235: LD_EXP 115
44239: PPUSH
44240: LD_VAR 0 2
44244: PPUSH
44245: EMPTY
44246: PPUSH
44247: CALL_OW 1
44251: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44252: LD_VAR 0 2
44256: PPUSH
44257: LD_INT 101
44259: PPUSH
44260: CALL 39167 0 2
// continue ;
44264: GO 44078
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44266: LD_ADDR_EXP 119
44270: PUSH
44271: LD_EXP 119
44275: PPUSH
44276: LD_VAR 0 2
44280: PPUSH
44281: EMPTY
44282: PPUSH
44283: CALL_OW 1
44287: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44288: LD_VAR 0 2
44292: PPUSH
44293: LD_INT 103
44295: PPUSH
44296: CALL 39167 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44300: LD_ADDR_VAR 0 5
44304: PUSH
44305: LD_EXP 113
44309: PUSH
44310: LD_VAR 0 2
44314: ARRAY
44315: PUSH
44316: LD_EXP 142
44320: PUSH
44321: LD_VAR 0 2
44325: ARRAY
44326: UNION
44327: PPUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 25
44333: PUSH
44334: LD_INT 2
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: PUSH
44341: LD_INT 25
44343: PUSH
44344: LD_INT 16
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: LIST
44355: PUSH
44356: EMPTY
44357: LIST
44358: PPUSH
44359: CALL_OW 72
44363: PUSH
44364: LD_EXP 116
44368: PUSH
44369: LD_VAR 0 2
44373: ARRAY
44374: PUSH
44375: LD_INT 1
44377: ARRAY
44378: PUSH
44379: LD_EXP 116
44383: PUSH
44384: LD_VAR 0 2
44388: ARRAY
44389: PUSH
44390: LD_INT 2
44392: ARRAY
44393: UNION
44394: DIFF
44395: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44396: LD_ADDR_VAR 0 6
44400: PUSH
44401: LD_EXP 132
44405: PUSH
44406: LD_VAR 0 2
44410: ARRAY
44411: PPUSH
44412: LD_INT 2
44414: PUSH
44415: LD_INT 34
44417: PUSH
44418: LD_INT 13
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 34
44427: PUSH
44428: LD_INT 52
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: LIST
44439: PPUSH
44440: CALL_OW 72
44444: ST_TO_ADDR
// if cranes then
44445: LD_VAR 0 6
44449: IFFALSE 44585
// begin for j in cranes do
44451: LD_ADDR_VAR 0 3
44455: PUSH
44456: LD_VAR 0 6
44460: PUSH
44461: FOR_IN
44462: IFFALSE 44583
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44464: LD_VAR 0 3
44468: PPUSH
44469: CALL_OW 256
44473: PUSH
44474: LD_INT 500
44476: GREATEREQUAL
44477: PUSH
44478: LD_VAR 0 3
44482: PPUSH
44483: CALL_OW 314
44487: NOT
44488: AND
44489: IFFALSE 44523
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44491: LD_VAR 0 3
44495: PPUSH
44496: LD_EXP 114
44500: PUSH
44501: LD_VAR 0 2
44505: ARRAY
44506: PPUSH
44507: LD_VAR 0 3
44511: PPUSH
44512: CALL_OW 74
44516: PPUSH
44517: CALL_OW 130
44521: GO 44581
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44523: LD_VAR 0 3
44527: PPUSH
44528: CALL_OW 256
44532: PUSH
44533: LD_INT 500
44535: LESS
44536: PUSH
44537: LD_VAR 0 3
44541: PPUSH
44542: LD_EXP 137
44546: PUSH
44547: LD_VAR 0 2
44551: ARRAY
44552: PPUSH
44553: CALL_OW 308
44557: NOT
44558: AND
44559: IFFALSE 44581
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44561: LD_VAR 0 3
44565: PPUSH
44566: LD_EXP 137
44570: PUSH
44571: LD_VAR 0 2
44575: ARRAY
44576: PPUSH
44577: CALL_OW 113
44581: GO 44461
44583: POP
44584: POP
// end ; if tmp > 3 then
44585: LD_VAR 0 5
44589: PUSH
44590: LD_INT 3
44592: GREATER
44593: IFFALSE 44613
// tmp := ShrinkArray ( tmp , 4 ) ;
44595: LD_ADDR_VAR 0 5
44599: PUSH
44600: LD_VAR 0 5
44604: PPUSH
44605: LD_INT 4
44607: PPUSH
44608: CALL 101416 0 2
44612: ST_TO_ADDR
// if not tmp then
44613: LD_VAR 0 5
44617: NOT
44618: IFFALSE 44622
// continue ;
44620: GO 44078
// for j in tmp do
44622: LD_ADDR_VAR 0 3
44626: PUSH
44627: LD_VAR 0 5
44631: PUSH
44632: FOR_IN
44633: IFFALSE 44892
// begin if IsInUnit ( j ) then
44635: LD_VAR 0 3
44639: PPUSH
44640: CALL_OW 310
44644: IFFALSE 44655
// ComExitBuilding ( j ) ;
44646: LD_VAR 0 3
44650: PPUSH
44651: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44655: LD_VAR 0 3
44659: PUSH
44660: LD_EXP 115
44664: PUSH
44665: LD_VAR 0 2
44669: ARRAY
44670: IN
44671: NOT
44672: IFFALSE 44730
// begin SetTag ( j , 101 ) ;
44674: LD_VAR 0 3
44678: PPUSH
44679: LD_INT 101
44681: PPUSH
44682: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44686: LD_ADDR_EXP 115
44690: PUSH
44691: LD_EXP 115
44695: PPUSH
44696: LD_VAR 0 2
44700: PUSH
44701: LD_EXP 115
44705: PUSH
44706: LD_VAR 0 2
44710: ARRAY
44711: PUSH
44712: LD_INT 1
44714: PLUS
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PPUSH
44720: LD_VAR 0 3
44724: PPUSH
44725: CALL 70058 0 3
44729: ST_TO_ADDR
// end ; wait ( 1 ) ;
44730: LD_INT 1
44732: PPUSH
44733: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44737: LD_ADDR_VAR 0 7
44741: PUSH
44742: LD_EXP 114
44746: PUSH
44747: LD_VAR 0 2
44751: ARRAY
44752: ST_TO_ADDR
// if mc_scan [ i ] then
44753: LD_EXP 136
44757: PUSH
44758: LD_VAR 0 2
44762: ARRAY
44763: IFFALSE 44825
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44765: LD_ADDR_VAR 0 7
44769: PUSH
44770: LD_EXP 114
44774: PUSH
44775: LD_VAR 0 2
44779: ARRAY
44780: PPUSH
44781: LD_INT 3
44783: PUSH
44784: LD_INT 30
44786: PUSH
44787: LD_INT 32
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 30
44796: PUSH
44797: LD_INT 33
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: LD_INT 30
44806: PUSH
44807: LD_INT 31
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: PPUSH
44820: CALL_OW 72
44824: ST_TO_ADDR
// if not to_repair_tmp then
44825: LD_VAR 0 7
44829: NOT
44830: IFFALSE 44834
// continue ;
44832: GO 44632
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44834: LD_ADDR_VAR 0 8
44838: PUSH
44839: LD_VAR 0 7
44843: PPUSH
44844: LD_VAR 0 3
44848: PPUSH
44849: CALL_OW 74
44853: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
44854: LD_VAR 0 8
44858: PPUSH
44859: LD_INT 16
44861: PPUSH
44862: CALL 72651 0 2
44866: PUSH
44867: LD_INT 4
44869: ARRAY
44870: PUSH
44871: LD_INT 5
44873: LESS
44874: IFFALSE 44890
// ComRepairBuilding ( j , to_repair ) ;
44876: LD_VAR 0 3
44880: PPUSH
44881: LD_VAR 0 8
44885: PPUSH
44886: CALL_OW 130
// end ;
44890: GO 44632
44892: POP
44893: POP
// end ;
44894: GO 44078
44896: POP
44897: POP
// end ;
44898: LD_VAR 0 1
44902: RET
// export function MC_Heal ; var i , j , tmp ; begin
44903: LD_INT 0
44905: PPUSH
44906: PPUSH
44907: PPUSH
44908: PPUSH
// if not mc_bases then
44909: LD_EXP 113
44913: NOT
44914: IFFALSE 44918
// exit ;
44916: GO 45320
// for i = 1 to mc_bases do
44918: LD_ADDR_VAR 0 2
44922: PUSH
44923: DOUBLE
44924: LD_INT 1
44926: DEC
44927: ST_TO_ADDR
44928: LD_EXP 113
44932: PUSH
44933: FOR_TO
44934: IFFALSE 45318
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44936: LD_EXP 116
44940: PUSH
44941: LD_VAR 0 2
44945: ARRAY
44946: PUSH
44947: LD_INT 1
44949: ARRAY
44950: NOT
44951: PUSH
44952: LD_EXP 116
44956: PUSH
44957: LD_VAR 0 2
44961: ARRAY
44962: PUSH
44963: LD_INT 2
44965: ARRAY
44966: NOT
44967: AND
44968: IFFALSE 45006
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44970: LD_ADDR_EXP 117
44974: PUSH
44975: LD_EXP 117
44979: PPUSH
44980: LD_VAR 0 2
44984: PPUSH
44985: EMPTY
44986: PPUSH
44987: CALL_OW 1
44991: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44992: LD_VAR 0 2
44996: PPUSH
44997: LD_INT 102
44999: PPUSH
45000: CALL 39167 0 2
// continue ;
45004: GO 44933
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45006: LD_ADDR_VAR 0 4
45010: PUSH
45011: LD_EXP 113
45015: PUSH
45016: LD_VAR 0 2
45020: ARRAY
45021: PPUSH
45022: LD_INT 25
45024: PUSH
45025: LD_INT 4
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PPUSH
45032: CALL_OW 72
45036: ST_TO_ADDR
// if not tmp then
45037: LD_VAR 0 4
45041: NOT
45042: IFFALSE 45046
// continue ;
45044: GO 44933
// if mc_taming [ i ] then
45046: LD_EXP 144
45050: PUSH
45051: LD_VAR 0 2
45055: ARRAY
45056: IFFALSE 45080
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45058: LD_ADDR_EXP 144
45062: PUSH
45063: LD_EXP 144
45067: PPUSH
45068: LD_VAR 0 2
45072: PPUSH
45073: EMPTY
45074: PPUSH
45075: CALL_OW 1
45079: ST_TO_ADDR
// for j in tmp do
45080: LD_ADDR_VAR 0 3
45084: PUSH
45085: LD_VAR 0 4
45089: PUSH
45090: FOR_IN
45091: IFFALSE 45314
// begin if IsInUnit ( j ) then
45093: LD_VAR 0 3
45097: PPUSH
45098: CALL_OW 310
45102: IFFALSE 45113
// ComExitBuilding ( j ) ;
45104: LD_VAR 0 3
45108: PPUSH
45109: CALL_OW 122
// if not j in mc_healers [ i ] then
45113: LD_VAR 0 3
45117: PUSH
45118: LD_EXP 117
45122: PUSH
45123: LD_VAR 0 2
45127: ARRAY
45128: IN
45129: NOT
45130: IFFALSE 45176
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45132: LD_ADDR_EXP 117
45136: PUSH
45137: LD_EXP 117
45141: PPUSH
45142: LD_VAR 0 2
45146: PUSH
45147: LD_EXP 117
45151: PUSH
45152: LD_VAR 0 2
45156: ARRAY
45157: PUSH
45158: LD_INT 1
45160: PLUS
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PPUSH
45166: LD_VAR 0 3
45170: PPUSH
45171: CALL 70058 0 3
45175: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45176: LD_VAR 0 3
45180: PPUSH
45181: CALL_OW 110
45185: PUSH
45186: LD_INT 102
45188: NONEQUAL
45189: IFFALSE 45203
// SetTag ( j , 102 ) ;
45191: LD_VAR 0 3
45195: PPUSH
45196: LD_INT 102
45198: PPUSH
45199: CALL_OW 109
// Wait ( 3 ) ;
45203: LD_INT 3
45205: PPUSH
45206: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45210: LD_EXP 116
45214: PUSH
45215: LD_VAR 0 2
45219: ARRAY
45220: PUSH
45221: LD_INT 1
45223: ARRAY
45224: IFFALSE 45256
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45226: LD_VAR 0 3
45230: PPUSH
45231: LD_EXP 116
45235: PUSH
45236: LD_VAR 0 2
45240: ARRAY
45241: PUSH
45242: LD_INT 1
45244: ARRAY
45245: PUSH
45246: LD_INT 1
45248: ARRAY
45249: PPUSH
45250: CALL_OW 128
45254: GO 45312
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45256: LD_VAR 0 3
45260: PPUSH
45261: CALL_OW 314
45265: NOT
45266: PUSH
45267: LD_EXP 116
45271: PUSH
45272: LD_VAR 0 2
45276: ARRAY
45277: PUSH
45278: LD_INT 2
45280: ARRAY
45281: AND
45282: IFFALSE 45312
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45284: LD_VAR 0 3
45288: PPUSH
45289: LD_EXP 116
45293: PUSH
45294: LD_VAR 0 2
45298: ARRAY
45299: PUSH
45300: LD_INT 2
45302: ARRAY
45303: PUSH
45304: LD_INT 1
45306: ARRAY
45307: PPUSH
45308: CALL_OW 128
// end ;
45312: GO 45090
45314: POP
45315: POP
// end ;
45316: GO 44933
45318: POP
45319: POP
// end ;
45320: LD_VAR 0 1
45324: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45325: LD_INT 0
45327: PPUSH
45328: PPUSH
45329: PPUSH
45330: PPUSH
45331: PPUSH
// if not mc_bases then
45332: LD_EXP 113
45336: NOT
45337: IFFALSE 45341
// exit ;
45339: GO 46484
// for i = 1 to mc_bases do
45341: LD_ADDR_VAR 0 2
45345: PUSH
45346: DOUBLE
45347: LD_INT 1
45349: DEC
45350: ST_TO_ADDR
45351: LD_EXP 113
45355: PUSH
45356: FOR_TO
45357: IFFALSE 46482
// begin if mc_scan [ i ] then
45359: LD_EXP 136
45363: PUSH
45364: LD_VAR 0 2
45368: ARRAY
45369: IFFALSE 45373
// continue ;
45371: GO 45356
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45373: LD_EXP 118
45377: PUSH
45378: LD_VAR 0 2
45382: ARRAY
45383: NOT
45384: PUSH
45385: LD_EXP 120
45389: PUSH
45390: LD_VAR 0 2
45394: ARRAY
45395: NOT
45396: AND
45397: PUSH
45398: LD_EXP 119
45402: PUSH
45403: LD_VAR 0 2
45407: ARRAY
45408: AND
45409: IFFALSE 45447
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45411: LD_ADDR_EXP 119
45415: PUSH
45416: LD_EXP 119
45420: PPUSH
45421: LD_VAR 0 2
45425: PPUSH
45426: EMPTY
45427: PPUSH
45428: CALL_OW 1
45432: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45433: LD_VAR 0 2
45437: PPUSH
45438: LD_INT 103
45440: PPUSH
45441: CALL 39167 0 2
// continue ;
45445: GO 45356
// end ; if mc_construct_list [ i ] then
45447: LD_EXP 120
45451: PUSH
45452: LD_VAR 0 2
45456: ARRAY
45457: IFFALSE 45677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45459: LD_ADDR_VAR 0 4
45463: PUSH
45464: LD_EXP 113
45468: PUSH
45469: LD_VAR 0 2
45473: ARRAY
45474: PPUSH
45475: LD_INT 25
45477: PUSH
45478: LD_INT 2
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PPUSH
45485: CALL_OW 72
45489: PUSH
45490: LD_EXP 115
45494: PUSH
45495: LD_VAR 0 2
45499: ARRAY
45500: DIFF
45501: ST_TO_ADDR
// if not tmp then
45502: LD_VAR 0 4
45506: NOT
45507: IFFALSE 45511
// continue ;
45509: GO 45356
// for j in tmp do
45511: LD_ADDR_VAR 0 3
45515: PUSH
45516: LD_VAR 0 4
45520: PUSH
45521: FOR_IN
45522: IFFALSE 45673
// begin if not mc_builders [ i ] then
45524: LD_EXP 119
45528: PUSH
45529: LD_VAR 0 2
45533: ARRAY
45534: NOT
45535: IFFALSE 45593
// begin SetTag ( j , 103 ) ;
45537: LD_VAR 0 3
45541: PPUSH
45542: LD_INT 103
45544: PPUSH
45545: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45549: LD_ADDR_EXP 119
45553: PUSH
45554: LD_EXP 119
45558: PPUSH
45559: LD_VAR 0 2
45563: PUSH
45564: LD_EXP 119
45568: PUSH
45569: LD_VAR 0 2
45573: ARRAY
45574: PUSH
45575: LD_INT 1
45577: PLUS
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PPUSH
45583: LD_VAR 0 3
45587: PPUSH
45588: CALL 70058 0 3
45592: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45593: LD_VAR 0 3
45597: PPUSH
45598: CALL_OW 310
45602: IFFALSE 45613
// ComExitBuilding ( j ) ;
45604: LD_VAR 0 3
45608: PPUSH
45609: CALL_OW 122
// wait ( 3 ) ;
45613: LD_INT 3
45615: PPUSH
45616: CALL_OW 67
// if not mc_construct_list [ i ] then
45620: LD_EXP 120
45624: PUSH
45625: LD_VAR 0 2
45629: ARRAY
45630: NOT
45631: IFFALSE 45635
// break ;
45633: GO 45673
// if not HasTask ( j ) then
45635: LD_VAR 0 3
45639: PPUSH
45640: CALL_OW 314
45644: NOT
45645: IFFALSE 45671
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45647: LD_VAR 0 3
45651: PPUSH
45652: LD_EXP 120
45656: PUSH
45657: LD_VAR 0 2
45661: ARRAY
45662: PUSH
45663: LD_INT 1
45665: ARRAY
45666: PPUSH
45667: CALL 72909 0 2
// end ;
45671: GO 45521
45673: POP
45674: POP
// end else
45675: GO 46480
// if mc_build_list [ i ] then
45677: LD_EXP 118
45681: PUSH
45682: LD_VAR 0 2
45686: ARRAY
45687: IFFALSE 46480
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45689: LD_ADDR_VAR 0 5
45693: PUSH
45694: LD_EXP 113
45698: PUSH
45699: LD_VAR 0 2
45703: ARRAY
45704: PPUSH
45705: LD_INT 2
45707: PUSH
45708: LD_INT 30
45710: PUSH
45711: LD_INT 0
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: PUSH
45718: LD_INT 30
45720: PUSH
45721: LD_INT 1
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: PPUSH
45733: CALL_OW 72
45737: ST_TO_ADDR
// if depot then
45738: LD_VAR 0 5
45742: IFFALSE 45760
// depot := depot [ 1 ] else
45744: LD_ADDR_VAR 0 5
45748: PUSH
45749: LD_VAR 0 5
45753: PUSH
45754: LD_INT 1
45756: ARRAY
45757: ST_TO_ADDR
45758: GO 45768
// depot := 0 ;
45760: LD_ADDR_VAR 0 5
45764: PUSH
45765: LD_INT 0
45767: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45768: LD_EXP 118
45772: PUSH
45773: LD_VAR 0 2
45777: ARRAY
45778: PUSH
45779: LD_INT 1
45781: ARRAY
45782: PUSH
45783: LD_INT 1
45785: ARRAY
45786: PPUSH
45787: CALL 72739 0 1
45791: PUSH
45792: LD_EXP 113
45796: PUSH
45797: LD_VAR 0 2
45801: ARRAY
45802: PPUSH
45803: LD_INT 2
45805: PUSH
45806: LD_INT 30
45808: PUSH
45809: LD_INT 2
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 30
45818: PUSH
45819: LD_INT 3
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: LIST
45830: PPUSH
45831: CALL_OW 72
45835: NOT
45836: AND
45837: IFFALSE 45942
// begin for j = 1 to mc_build_list [ i ] do
45839: LD_ADDR_VAR 0 3
45843: PUSH
45844: DOUBLE
45845: LD_INT 1
45847: DEC
45848: ST_TO_ADDR
45849: LD_EXP 118
45853: PUSH
45854: LD_VAR 0 2
45858: ARRAY
45859: PUSH
45860: FOR_TO
45861: IFFALSE 45940
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45863: LD_EXP 118
45867: PUSH
45868: LD_VAR 0 2
45872: ARRAY
45873: PUSH
45874: LD_VAR 0 3
45878: ARRAY
45879: PUSH
45880: LD_INT 1
45882: ARRAY
45883: PUSH
45884: LD_INT 2
45886: EQUAL
45887: IFFALSE 45938
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45889: LD_ADDR_EXP 118
45893: PUSH
45894: LD_EXP 118
45898: PPUSH
45899: LD_VAR 0 2
45903: PPUSH
45904: LD_EXP 118
45908: PUSH
45909: LD_VAR 0 2
45913: ARRAY
45914: PPUSH
45915: LD_VAR 0 3
45919: PPUSH
45920: LD_INT 1
45922: PPUSH
45923: LD_INT 0
45925: PPUSH
45926: CALL 69476 0 4
45930: PPUSH
45931: CALL_OW 1
45935: ST_TO_ADDR
// break ;
45936: GO 45940
// end ;
45938: GO 45860
45940: POP
45941: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45942: LD_EXP 118
45946: PUSH
45947: LD_VAR 0 2
45951: ARRAY
45952: PUSH
45953: LD_INT 1
45955: ARRAY
45956: PUSH
45957: LD_INT 1
45959: ARRAY
45960: PUSH
45961: LD_INT 0
45963: EQUAL
45964: PUSH
45965: LD_VAR 0 5
45969: PUSH
45970: LD_VAR 0 5
45974: PPUSH
45975: LD_EXP 118
45979: PUSH
45980: LD_VAR 0 2
45984: ARRAY
45985: PUSH
45986: LD_INT 1
45988: ARRAY
45989: PUSH
45990: LD_INT 1
45992: ARRAY
45993: PPUSH
45994: LD_EXP 118
45998: PUSH
45999: LD_VAR 0 2
46003: ARRAY
46004: PUSH
46005: LD_INT 1
46007: ARRAY
46008: PUSH
46009: LD_INT 2
46011: ARRAY
46012: PPUSH
46013: LD_EXP 118
46017: PUSH
46018: LD_VAR 0 2
46022: ARRAY
46023: PUSH
46024: LD_INT 1
46026: ARRAY
46027: PUSH
46028: LD_INT 3
46030: ARRAY
46031: PPUSH
46032: LD_EXP 118
46036: PUSH
46037: LD_VAR 0 2
46041: ARRAY
46042: PUSH
46043: LD_INT 1
46045: ARRAY
46046: PUSH
46047: LD_INT 4
46049: ARRAY
46050: PPUSH
46051: CALL 77473 0 5
46055: AND
46056: OR
46057: IFFALSE 46338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46059: LD_ADDR_VAR 0 4
46063: PUSH
46064: LD_EXP 113
46068: PUSH
46069: LD_VAR 0 2
46073: ARRAY
46074: PPUSH
46075: LD_INT 25
46077: PUSH
46078: LD_INT 2
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PPUSH
46085: CALL_OW 72
46089: PUSH
46090: LD_EXP 115
46094: PUSH
46095: LD_VAR 0 2
46099: ARRAY
46100: DIFF
46101: ST_TO_ADDR
// if not tmp then
46102: LD_VAR 0 4
46106: NOT
46107: IFFALSE 46111
// continue ;
46109: GO 45356
// for j in tmp do
46111: LD_ADDR_VAR 0 3
46115: PUSH
46116: LD_VAR 0 4
46120: PUSH
46121: FOR_IN
46122: IFFALSE 46334
// begin if not mc_builders [ i ] then
46124: LD_EXP 119
46128: PUSH
46129: LD_VAR 0 2
46133: ARRAY
46134: NOT
46135: IFFALSE 46193
// begin SetTag ( j , 103 ) ;
46137: LD_VAR 0 3
46141: PPUSH
46142: LD_INT 103
46144: PPUSH
46145: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46149: LD_ADDR_EXP 119
46153: PUSH
46154: LD_EXP 119
46158: PPUSH
46159: LD_VAR 0 2
46163: PUSH
46164: LD_EXP 119
46168: PUSH
46169: LD_VAR 0 2
46173: ARRAY
46174: PUSH
46175: LD_INT 1
46177: PLUS
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PPUSH
46183: LD_VAR 0 3
46187: PPUSH
46188: CALL 70058 0 3
46192: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46193: LD_VAR 0 3
46197: PPUSH
46198: CALL_OW 310
46202: IFFALSE 46213
// ComExitBuilding ( j ) ;
46204: LD_VAR 0 3
46208: PPUSH
46209: CALL_OW 122
// wait ( 3 ) ;
46213: LD_INT 3
46215: PPUSH
46216: CALL_OW 67
// if not mc_build_list [ i ] then
46220: LD_EXP 118
46224: PUSH
46225: LD_VAR 0 2
46229: ARRAY
46230: NOT
46231: IFFALSE 46235
// break ;
46233: GO 46334
// if not HasTask ( j ) then
46235: LD_VAR 0 3
46239: PPUSH
46240: CALL_OW 314
46244: NOT
46245: IFFALSE 46332
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46247: LD_VAR 0 3
46251: PPUSH
46252: LD_EXP 118
46256: PUSH
46257: LD_VAR 0 2
46261: ARRAY
46262: PUSH
46263: LD_INT 1
46265: ARRAY
46266: PUSH
46267: LD_INT 1
46269: ARRAY
46270: PPUSH
46271: LD_EXP 118
46275: PUSH
46276: LD_VAR 0 2
46280: ARRAY
46281: PUSH
46282: LD_INT 1
46284: ARRAY
46285: PUSH
46286: LD_INT 2
46288: ARRAY
46289: PPUSH
46290: LD_EXP 118
46294: PUSH
46295: LD_VAR 0 2
46299: ARRAY
46300: PUSH
46301: LD_INT 1
46303: ARRAY
46304: PUSH
46305: LD_INT 3
46307: ARRAY
46308: PPUSH
46309: LD_EXP 118
46313: PUSH
46314: LD_VAR 0 2
46318: ARRAY
46319: PUSH
46320: LD_INT 1
46322: ARRAY
46323: PUSH
46324: LD_INT 4
46326: ARRAY
46327: PPUSH
46328: CALL_OW 145
// end ;
46332: GO 46121
46334: POP
46335: POP
// end else
46336: GO 46480
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46338: LD_EXP 113
46342: PUSH
46343: LD_VAR 0 2
46347: ARRAY
46348: PPUSH
46349: LD_EXP 118
46353: PUSH
46354: LD_VAR 0 2
46358: ARRAY
46359: PUSH
46360: LD_INT 1
46362: ARRAY
46363: PUSH
46364: LD_INT 1
46366: ARRAY
46367: PPUSH
46368: LD_EXP 118
46372: PUSH
46373: LD_VAR 0 2
46377: ARRAY
46378: PUSH
46379: LD_INT 1
46381: ARRAY
46382: PUSH
46383: LD_INT 2
46385: ARRAY
46386: PPUSH
46387: LD_EXP 118
46391: PUSH
46392: LD_VAR 0 2
46396: ARRAY
46397: PUSH
46398: LD_INT 1
46400: ARRAY
46401: PUSH
46402: LD_INT 3
46404: ARRAY
46405: PPUSH
46406: LD_EXP 118
46410: PUSH
46411: LD_VAR 0 2
46415: ARRAY
46416: PUSH
46417: LD_INT 1
46419: ARRAY
46420: PUSH
46421: LD_INT 4
46423: ARRAY
46424: PPUSH
46425: CALL 76809 0 5
46429: NOT
46430: IFFALSE 46480
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46432: LD_ADDR_EXP 118
46436: PUSH
46437: LD_EXP 118
46441: PPUSH
46442: LD_VAR 0 2
46446: PPUSH
46447: LD_EXP 118
46451: PUSH
46452: LD_VAR 0 2
46456: ARRAY
46457: PPUSH
46458: LD_INT 1
46460: PPUSH
46461: LD_INT 1
46463: NEG
46464: PPUSH
46465: LD_INT 0
46467: PPUSH
46468: CALL 69476 0 4
46472: PPUSH
46473: CALL_OW 1
46477: ST_TO_ADDR
// continue ;
46478: GO 45356
// end ; end ; end ;
46480: GO 45356
46482: POP
46483: POP
// end ;
46484: LD_VAR 0 1
46488: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46489: LD_INT 0
46491: PPUSH
46492: PPUSH
46493: PPUSH
46494: PPUSH
46495: PPUSH
46496: PPUSH
// if not mc_bases then
46497: LD_EXP 113
46501: NOT
46502: IFFALSE 46506
// exit ;
46504: GO 46933
// for i = 1 to mc_bases do
46506: LD_ADDR_VAR 0 2
46510: PUSH
46511: DOUBLE
46512: LD_INT 1
46514: DEC
46515: ST_TO_ADDR
46516: LD_EXP 113
46520: PUSH
46521: FOR_TO
46522: IFFALSE 46931
// begin tmp := mc_build_upgrade [ i ] ;
46524: LD_ADDR_VAR 0 4
46528: PUSH
46529: LD_EXP 145
46533: PUSH
46534: LD_VAR 0 2
46538: ARRAY
46539: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46540: LD_ADDR_VAR 0 6
46544: PUSH
46545: LD_EXP 146
46549: PUSH
46550: LD_VAR 0 2
46554: ARRAY
46555: PPUSH
46556: LD_INT 2
46558: PUSH
46559: LD_INT 30
46561: PUSH
46562: LD_INT 6
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 30
46571: PUSH
46572: LD_INT 7
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: LIST
46583: PPUSH
46584: CALL_OW 72
46588: ST_TO_ADDR
// if not tmp and not lab then
46589: LD_VAR 0 4
46593: NOT
46594: PUSH
46595: LD_VAR 0 6
46599: NOT
46600: AND
46601: IFFALSE 46605
// continue ;
46603: GO 46521
// if tmp then
46605: LD_VAR 0 4
46609: IFFALSE 46729
// for j in tmp do
46611: LD_ADDR_VAR 0 3
46615: PUSH
46616: LD_VAR 0 4
46620: PUSH
46621: FOR_IN
46622: IFFALSE 46727
// begin if UpgradeCost ( j ) then
46624: LD_VAR 0 3
46628: PPUSH
46629: CALL 76469 0 1
46633: IFFALSE 46725
// begin ComUpgrade ( j ) ;
46635: LD_VAR 0 3
46639: PPUSH
46640: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46644: LD_ADDR_EXP 145
46648: PUSH
46649: LD_EXP 145
46653: PPUSH
46654: LD_VAR 0 2
46658: PPUSH
46659: LD_EXP 145
46663: PUSH
46664: LD_VAR 0 2
46668: ARRAY
46669: PUSH
46670: LD_VAR 0 3
46674: DIFF
46675: PPUSH
46676: CALL_OW 1
46680: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46681: LD_ADDR_EXP 120
46685: PUSH
46686: LD_EXP 120
46690: PPUSH
46691: LD_VAR 0 2
46695: PUSH
46696: LD_EXP 120
46700: PUSH
46701: LD_VAR 0 2
46705: ARRAY
46706: PUSH
46707: LD_INT 1
46709: PLUS
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: PPUSH
46715: LD_VAR 0 3
46719: PPUSH
46720: CALL 70058 0 3
46724: ST_TO_ADDR
// end ; end ;
46725: GO 46621
46727: POP
46728: POP
// if not lab or not mc_lab_upgrade [ i ] then
46729: LD_VAR 0 6
46733: NOT
46734: PUSH
46735: LD_EXP 147
46739: PUSH
46740: LD_VAR 0 2
46744: ARRAY
46745: NOT
46746: OR
46747: IFFALSE 46751
// continue ;
46749: GO 46521
// for j in lab do
46751: LD_ADDR_VAR 0 3
46755: PUSH
46756: LD_VAR 0 6
46760: PUSH
46761: FOR_IN
46762: IFFALSE 46927
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46764: LD_VAR 0 3
46768: PPUSH
46769: CALL_OW 266
46773: PUSH
46774: LD_INT 6
46776: PUSH
46777: LD_INT 7
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: IN
46784: PUSH
46785: LD_VAR 0 3
46789: PPUSH
46790: CALL_OW 461
46794: PUSH
46795: LD_INT 1
46797: NONEQUAL
46798: AND
46799: IFFALSE 46925
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46801: LD_VAR 0 3
46805: PPUSH
46806: LD_EXP 147
46810: PUSH
46811: LD_VAR 0 2
46815: ARRAY
46816: PUSH
46817: LD_INT 1
46819: ARRAY
46820: PPUSH
46821: CALL 76674 0 2
46825: IFFALSE 46925
// begin ComCancel ( j ) ;
46827: LD_VAR 0 3
46831: PPUSH
46832: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46836: LD_VAR 0 3
46840: PPUSH
46841: LD_EXP 147
46845: PUSH
46846: LD_VAR 0 2
46850: ARRAY
46851: PUSH
46852: LD_INT 1
46854: ARRAY
46855: PPUSH
46856: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46860: LD_VAR 0 3
46864: PUSH
46865: LD_EXP 120
46869: PUSH
46870: LD_VAR 0 2
46874: ARRAY
46875: IN
46876: NOT
46877: IFFALSE 46923
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46879: LD_ADDR_EXP 120
46883: PUSH
46884: LD_EXP 120
46888: PPUSH
46889: LD_VAR 0 2
46893: PUSH
46894: LD_EXP 120
46898: PUSH
46899: LD_VAR 0 2
46903: ARRAY
46904: PUSH
46905: LD_INT 1
46907: PLUS
46908: PUSH
46909: EMPTY
46910: LIST
46911: LIST
46912: PPUSH
46913: LD_VAR 0 3
46917: PPUSH
46918: CALL 70058 0 3
46922: ST_TO_ADDR
// break ;
46923: GO 46927
// end ; end ; end ;
46925: GO 46761
46927: POP
46928: POP
// end ;
46929: GO 46521
46931: POP
46932: POP
// end ;
46933: LD_VAR 0 1
46937: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46938: LD_INT 0
46940: PPUSH
46941: PPUSH
46942: PPUSH
46943: PPUSH
46944: PPUSH
46945: PPUSH
46946: PPUSH
46947: PPUSH
46948: PPUSH
// if not mc_bases then
46949: LD_EXP 113
46953: NOT
46954: IFFALSE 46958
// exit ;
46956: GO 47363
// for i = 1 to mc_bases do
46958: LD_ADDR_VAR 0 2
46962: PUSH
46963: DOUBLE
46964: LD_INT 1
46966: DEC
46967: ST_TO_ADDR
46968: LD_EXP 113
46972: PUSH
46973: FOR_TO
46974: IFFALSE 47361
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46976: LD_EXP 121
46980: PUSH
46981: LD_VAR 0 2
46985: ARRAY
46986: NOT
46987: PUSH
46988: LD_EXP 113
46992: PUSH
46993: LD_VAR 0 2
46997: ARRAY
46998: PPUSH
46999: LD_INT 30
47001: PUSH
47002: LD_INT 3
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: PPUSH
47009: CALL_OW 72
47013: NOT
47014: OR
47015: IFFALSE 47019
// continue ;
47017: GO 46973
// busy := false ;
47019: LD_ADDR_VAR 0 8
47023: PUSH
47024: LD_INT 0
47026: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47027: LD_ADDR_VAR 0 4
47031: PUSH
47032: LD_EXP 113
47036: PUSH
47037: LD_VAR 0 2
47041: ARRAY
47042: PPUSH
47043: LD_INT 30
47045: PUSH
47046: LD_INT 3
47048: PUSH
47049: EMPTY
47050: LIST
47051: LIST
47052: PPUSH
47053: CALL_OW 72
47057: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47058: LD_ADDR_VAR 0 6
47062: PUSH
47063: LD_EXP 121
47067: PUSH
47068: LD_VAR 0 2
47072: ARRAY
47073: PPUSH
47074: LD_INT 2
47076: PUSH
47077: LD_INT 30
47079: PUSH
47080: LD_INT 32
47082: PUSH
47083: EMPTY
47084: LIST
47085: LIST
47086: PUSH
47087: LD_INT 30
47089: PUSH
47090: LD_INT 33
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: LIST
47101: PPUSH
47102: CALL_OW 72
47106: ST_TO_ADDR
// if not t then
47107: LD_VAR 0 6
47111: NOT
47112: IFFALSE 47116
// continue ;
47114: GO 46973
// for j in tmp do
47116: LD_ADDR_VAR 0 3
47120: PUSH
47121: LD_VAR 0 4
47125: PUSH
47126: FOR_IN
47127: IFFALSE 47157
// if not BuildingStatus ( j ) = bs_idle then
47129: LD_VAR 0 3
47133: PPUSH
47134: CALL_OW 461
47138: PUSH
47139: LD_INT 2
47141: EQUAL
47142: NOT
47143: IFFALSE 47155
// begin busy := true ;
47145: LD_ADDR_VAR 0 8
47149: PUSH
47150: LD_INT 1
47152: ST_TO_ADDR
// break ;
47153: GO 47157
// end ;
47155: GO 47126
47157: POP
47158: POP
// if busy then
47159: LD_VAR 0 8
47163: IFFALSE 47167
// continue ;
47165: GO 46973
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47167: LD_ADDR_VAR 0 7
47171: PUSH
47172: LD_VAR 0 6
47176: PPUSH
47177: LD_INT 35
47179: PUSH
47180: LD_INT 0
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: PPUSH
47187: CALL_OW 72
47191: ST_TO_ADDR
// if tw then
47192: LD_VAR 0 7
47196: IFFALSE 47273
// begin tw := tw [ 1 ] ;
47198: LD_ADDR_VAR 0 7
47202: PUSH
47203: LD_VAR 0 7
47207: PUSH
47208: LD_INT 1
47210: ARRAY
47211: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47212: LD_ADDR_VAR 0 9
47216: PUSH
47217: LD_VAR 0 7
47221: PPUSH
47222: LD_EXP 138
47226: PUSH
47227: LD_VAR 0 2
47231: ARRAY
47232: PPUSH
47233: CALL 75028 0 2
47237: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47238: LD_EXP 152
47242: PUSH
47243: LD_VAR 0 2
47247: ARRAY
47248: IFFALSE 47271
// if not weapon in mc_allowed_tower_weapons [ i ] then
47250: LD_VAR 0 9
47254: PUSH
47255: LD_EXP 152
47259: PUSH
47260: LD_VAR 0 2
47264: ARRAY
47265: IN
47266: NOT
47267: IFFALSE 47271
// continue ;
47269: GO 46973
// end else
47271: GO 47336
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47273: LD_ADDR_VAR 0 5
47277: PUSH
47278: LD_EXP 121
47282: PUSH
47283: LD_VAR 0 2
47287: ARRAY
47288: PPUSH
47289: LD_VAR 0 4
47293: PPUSH
47294: CALL 100649 0 2
47298: ST_TO_ADDR
// if not tmp2 then
47299: LD_VAR 0 5
47303: NOT
47304: IFFALSE 47308
// continue ;
47306: GO 46973
// tw := tmp2 [ 1 ] ;
47308: LD_ADDR_VAR 0 7
47312: PUSH
47313: LD_VAR 0 5
47317: PUSH
47318: LD_INT 1
47320: ARRAY
47321: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47322: LD_ADDR_VAR 0 9
47326: PUSH
47327: LD_VAR 0 5
47331: PUSH
47332: LD_INT 2
47334: ARRAY
47335: ST_TO_ADDR
// end ; if not weapon then
47336: LD_VAR 0 9
47340: NOT
47341: IFFALSE 47345
// continue ;
47343: GO 46973
// ComPlaceWeapon ( tw , weapon ) ;
47345: LD_VAR 0 7
47349: PPUSH
47350: LD_VAR 0 9
47354: PPUSH
47355: CALL_OW 148
// end ;
47359: GO 46973
47361: POP
47362: POP
// end ;
47363: LD_VAR 0 1
47367: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47368: LD_INT 0
47370: PPUSH
47371: PPUSH
47372: PPUSH
47373: PPUSH
47374: PPUSH
47375: PPUSH
// if not mc_bases then
47376: LD_EXP 113
47380: NOT
47381: IFFALSE 47385
// exit ;
47383: GO 48161
// for i = 1 to mc_bases do
47385: LD_ADDR_VAR 0 2
47389: PUSH
47390: DOUBLE
47391: LD_INT 1
47393: DEC
47394: ST_TO_ADDR
47395: LD_EXP 113
47399: PUSH
47400: FOR_TO
47401: IFFALSE 48159
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47403: LD_EXP 126
47407: PUSH
47408: LD_VAR 0 2
47412: ARRAY
47413: NOT
47414: PUSH
47415: LD_EXP 126
47419: PUSH
47420: LD_VAR 0 2
47424: ARRAY
47425: PUSH
47426: LD_EXP 127
47430: PUSH
47431: LD_VAR 0 2
47435: ARRAY
47436: EQUAL
47437: OR
47438: PUSH
47439: LD_EXP 136
47443: PUSH
47444: LD_VAR 0 2
47448: ARRAY
47449: OR
47450: IFFALSE 47454
// continue ;
47452: GO 47400
// if mc_miners [ i ] then
47454: LD_EXP 127
47458: PUSH
47459: LD_VAR 0 2
47463: ARRAY
47464: IFFALSE 47846
// begin for j = mc_miners [ i ] downto 1 do
47466: LD_ADDR_VAR 0 3
47470: PUSH
47471: DOUBLE
47472: LD_EXP 127
47476: PUSH
47477: LD_VAR 0 2
47481: ARRAY
47482: INC
47483: ST_TO_ADDR
47484: LD_INT 1
47486: PUSH
47487: FOR_DOWNTO
47488: IFFALSE 47844
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47490: LD_EXP 127
47494: PUSH
47495: LD_VAR 0 2
47499: ARRAY
47500: PUSH
47501: LD_VAR 0 3
47505: ARRAY
47506: PPUSH
47507: CALL_OW 301
47511: PUSH
47512: LD_EXP 127
47516: PUSH
47517: LD_VAR 0 2
47521: ARRAY
47522: PUSH
47523: LD_VAR 0 3
47527: ARRAY
47528: PPUSH
47529: CALL_OW 257
47533: PUSH
47534: LD_INT 1
47536: NONEQUAL
47537: OR
47538: IFFALSE 47601
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47540: LD_ADDR_VAR 0 5
47544: PUSH
47545: LD_EXP 127
47549: PUSH
47550: LD_VAR 0 2
47554: ARRAY
47555: PUSH
47556: LD_EXP 127
47560: PUSH
47561: LD_VAR 0 2
47565: ARRAY
47566: PUSH
47567: LD_VAR 0 3
47571: ARRAY
47572: DIFF
47573: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47574: LD_ADDR_EXP 127
47578: PUSH
47579: LD_EXP 127
47583: PPUSH
47584: LD_VAR 0 2
47588: PPUSH
47589: LD_VAR 0 5
47593: PPUSH
47594: CALL_OW 1
47598: ST_TO_ADDR
// continue ;
47599: GO 47487
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47601: LD_EXP 127
47605: PUSH
47606: LD_VAR 0 2
47610: ARRAY
47611: PUSH
47612: LD_VAR 0 3
47616: ARRAY
47617: PPUSH
47618: CALL_OW 257
47622: PUSH
47623: LD_INT 1
47625: EQUAL
47626: PUSH
47627: LD_EXP 127
47631: PUSH
47632: LD_VAR 0 2
47636: ARRAY
47637: PUSH
47638: LD_VAR 0 3
47642: ARRAY
47643: PPUSH
47644: CALL_OW 459
47648: NOT
47649: AND
47650: PUSH
47651: LD_EXP 127
47655: PUSH
47656: LD_VAR 0 2
47660: ARRAY
47661: PUSH
47662: LD_VAR 0 3
47666: ARRAY
47667: PPUSH
47668: CALL_OW 314
47672: NOT
47673: AND
47674: IFFALSE 47842
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47676: LD_EXP 127
47680: PUSH
47681: LD_VAR 0 2
47685: ARRAY
47686: PUSH
47687: LD_VAR 0 3
47691: ARRAY
47692: PPUSH
47693: CALL_OW 310
47697: IFFALSE 47720
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47699: LD_EXP 127
47703: PUSH
47704: LD_VAR 0 2
47708: ARRAY
47709: PUSH
47710: LD_VAR 0 3
47714: ARRAY
47715: PPUSH
47716: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47720: LD_EXP 127
47724: PUSH
47725: LD_VAR 0 2
47729: ARRAY
47730: PUSH
47731: LD_VAR 0 3
47735: ARRAY
47736: PPUSH
47737: CALL_OW 314
47741: NOT
47742: IFFALSE 47842
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47744: LD_EXP 127
47748: PUSH
47749: LD_VAR 0 2
47753: ARRAY
47754: PUSH
47755: LD_VAR 0 3
47759: ARRAY
47760: PPUSH
47761: LD_EXP 126
47765: PUSH
47766: LD_VAR 0 2
47770: ARRAY
47771: PUSH
47772: LD_VAR 0 3
47776: PUSH
47777: LD_EXP 126
47781: PUSH
47782: LD_VAR 0 2
47786: ARRAY
47787: MOD
47788: PUSH
47789: LD_INT 1
47791: PLUS
47792: ARRAY
47793: PUSH
47794: LD_INT 1
47796: ARRAY
47797: PPUSH
47798: LD_EXP 126
47802: PUSH
47803: LD_VAR 0 2
47807: ARRAY
47808: PUSH
47809: LD_VAR 0 3
47813: PUSH
47814: LD_EXP 126
47818: PUSH
47819: LD_VAR 0 2
47823: ARRAY
47824: MOD
47825: PUSH
47826: LD_INT 1
47828: PLUS
47829: ARRAY
47830: PUSH
47831: LD_INT 2
47833: ARRAY
47834: PPUSH
47835: LD_INT 0
47837: PPUSH
47838: CALL_OW 193
// end ; end ;
47842: GO 47487
47844: POP
47845: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47846: LD_ADDR_VAR 0 5
47850: PUSH
47851: LD_EXP 113
47855: PUSH
47856: LD_VAR 0 2
47860: ARRAY
47861: PPUSH
47862: LD_INT 2
47864: PUSH
47865: LD_INT 30
47867: PUSH
47868: LD_INT 4
47870: PUSH
47871: EMPTY
47872: LIST
47873: LIST
47874: PUSH
47875: LD_INT 30
47877: PUSH
47878: LD_INT 5
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 30
47887: PUSH
47888: LD_INT 32
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: PPUSH
47901: CALL_OW 72
47905: ST_TO_ADDR
// if not tmp then
47906: LD_VAR 0 5
47910: NOT
47911: IFFALSE 47915
// continue ;
47913: GO 47400
// list := [ ] ;
47915: LD_ADDR_VAR 0 6
47919: PUSH
47920: EMPTY
47921: ST_TO_ADDR
// for j in tmp do
47922: LD_ADDR_VAR 0 3
47926: PUSH
47927: LD_VAR 0 5
47931: PUSH
47932: FOR_IN
47933: IFFALSE 48002
// begin for k in UnitsInside ( j ) do
47935: LD_ADDR_VAR 0 4
47939: PUSH
47940: LD_VAR 0 3
47944: PPUSH
47945: CALL_OW 313
47949: PUSH
47950: FOR_IN
47951: IFFALSE 47998
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47953: LD_VAR 0 4
47957: PPUSH
47958: CALL_OW 257
47962: PUSH
47963: LD_INT 1
47965: EQUAL
47966: PUSH
47967: LD_VAR 0 4
47971: PPUSH
47972: CALL_OW 459
47976: NOT
47977: AND
47978: IFFALSE 47996
// list := list ^ k ;
47980: LD_ADDR_VAR 0 6
47984: PUSH
47985: LD_VAR 0 6
47989: PUSH
47990: LD_VAR 0 4
47994: ADD
47995: ST_TO_ADDR
47996: GO 47950
47998: POP
47999: POP
// end ;
48000: GO 47932
48002: POP
48003: POP
// list := list diff mc_miners [ i ] ;
48004: LD_ADDR_VAR 0 6
48008: PUSH
48009: LD_VAR 0 6
48013: PUSH
48014: LD_EXP 127
48018: PUSH
48019: LD_VAR 0 2
48023: ARRAY
48024: DIFF
48025: ST_TO_ADDR
// if not list then
48026: LD_VAR 0 6
48030: NOT
48031: IFFALSE 48035
// continue ;
48033: GO 47400
// k := mc_mines [ i ] - mc_miners [ i ] ;
48035: LD_ADDR_VAR 0 4
48039: PUSH
48040: LD_EXP 126
48044: PUSH
48045: LD_VAR 0 2
48049: ARRAY
48050: PUSH
48051: LD_EXP 127
48055: PUSH
48056: LD_VAR 0 2
48060: ARRAY
48061: MINUS
48062: ST_TO_ADDR
// if k > list then
48063: LD_VAR 0 4
48067: PUSH
48068: LD_VAR 0 6
48072: GREATER
48073: IFFALSE 48085
// k := list ;
48075: LD_ADDR_VAR 0 4
48079: PUSH
48080: LD_VAR 0 6
48084: ST_TO_ADDR
// for j = 1 to k do
48085: LD_ADDR_VAR 0 3
48089: PUSH
48090: DOUBLE
48091: LD_INT 1
48093: DEC
48094: ST_TO_ADDR
48095: LD_VAR 0 4
48099: PUSH
48100: FOR_TO
48101: IFFALSE 48155
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48103: LD_ADDR_EXP 127
48107: PUSH
48108: LD_EXP 127
48112: PPUSH
48113: LD_VAR 0 2
48117: PUSH
48118: LD_EXP 127
48122: PUSH
48123: LD_VAR 0 2
48127: ARRAY
48128: PUSH
48129: LD_INT 1
48131: PLUS
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PPUSH
48137: LD_VAR 0 6
48141: PUSH
48142: LD_VAR 0 3
48146: ARRAY
48147: PPUSH
48148: CALL 70058 0 3
48152: ST_TO_ADDR
48153: GO 48100
48155: POP
48156: POP
// end ;
48157: GO 47400
48159: POP
48160: POP
// end ;
48161: LD_VAR 0 1
48165: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48166: LD_INT 0
48168: PPUSH
48169: PPUSH
48170: PPUSH
48171: PPUSH
48172: PPUSH
48173: PPUSH
48174: PPUSH
48175: PPUSH
48176: PPUSH
48177: PPUSH
// if not mc_bases then
48178: LD_EXP 113
48182: NOT
48183: IFFALSE 48187
// exit ;
48185: GO 49937
// for i = 1 to mc_bases do
48187: LD_ADDR_VAR 0 2
48191: PUSH
48192: DOUBLE
48193: LD_INT 1
48195: DEC
48196: ST_TO_ADDR
48197: LD_EXP 113
48201: PUSH
48202: FOR_TO
48203: IFFALSE 49935
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48205: LD_EXP 113
48209: PUSH
48210: LD_VAR 0 2
48214: ARRAY
48215: NOT
48216: PUSH
48217: LD_EXP 120
48221: PUSH
48222: LD_VAR 0 2
48226: ARRAY
48227: OR
48228: IFFALSE 48232
// continue ;
48230: GO 48202
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48232: LD_EXP 129
48236: PUSH
48237: LD_VAR 0 2
48241: ARRAY
48242: NOT
48243: PUSH
48244: LD_EXP 130
48248: PUSH
48249: LD_VAR 0 2
48253: ARRAY
48254: AND
48255: IFFALSE 48293
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48257: LD_ADDR_EXP 130
48261: PUSH
48262: LD_EXP 130
48266: PPUSH
48267: LD_VAR 0 2
48271: PPUSH
48272: EMPTY
48273: PPUSH
48274: CALL_OW 1
48278: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48279: LD_VAR 0 2
48283: PPUSH
48284: LD_INT 107
48286: PPUSH
48287: CALL 39167 0 2
// continue ;
48291: GO 48202
// end ; target := [ ] ;
48293: LD_ADDR_VAR 0 6
48297: PUSH
48298: EMPTY
48299: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48300: LD_ADDR_VAR 0 3
48304: PUSH
48305: DOUBLE
48306: LD_EXP 129
48310: PUSH
48311: LD_VAR 0 2
48315: ARRAY
48316: INC
48317: ST_TO_ADDR
48318: LD_INT 1
48320: PUSH
48321: FOR_DOWNTO
48322: IFFALSE 48582
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48324: LD_EXP 129
48328: PUSH
48329: LD_VAR 0 2
48333: ARRAY
48334: PUSH
48335: LD_VAR 0 3
48339: ARRAY
48340: PUSH
48341: LD_INT 2
48343: ARRAY
48344: PPUSH
48345: LD_EXP 129
48349: PUSH
48350: LD_VAR 0 2
48354: ARRAY
48355: PUSH
48356: LD_VAR 0 3
48360: ARRAY
48361: PUSH
48362: LD_INT 3
48364: ARRAY
48365: PPUSH
48366: CALL_OW 488
48370: PUSH
48371: LD_EXP 129
48375: PUSH
48376: LD_VAR 0 2
48380: ARRAY
48381: PUSH
48382: LD_VAR 0 3
48386: ARRAY
48387: PUSH
48388: LD_INT 2
48390: ARRAY
48391: PPUSH
48392: LD_EXP 129
48396: PUSH
48397: LD_VAR 0 2
48401: ARRAY
48402: PUSH
48403: LD_VAR 0 3
48407: ARRAY
48408: PUSH
48409: LD_INT 3
48411: ARRAY
48412: PPUSH
48413: CALL_OW 284
48417: PUSH
48418: LD_INT 0
48420: EQUAL
48421: AND
48422: IFFALSE 48477
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48424: LD_ADDR_VAR 0 5
48428: PUSH
48429: LD_EXP 129
48433: PUSH
48434: LD_VAR 0 2
48438: ARRAY
48439: PPUSH
48440: LD_VAR 0 3
48444: PPUSH
48445: CALL_OW 3
48449: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48450: LD_ADDR_EXP 129
48454: PUSH
48455: LD_EXP 129
48459: PPUSH
48460: LD_VAR 0 2
48464: PPUSH
48465: LD_VAR 0 5
48469: PPUSH
48470: CALL_OW 1
48474: ST_TO_ADDR
// continue ;
48475: GO 48321
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48477: LD_EXP 113
48481: PUSH
48482: LD_VAR 0 2
48486: ARRAY
48487: PUSH
48488: LD_INT 1
48490: ARRAY
48491: PPUSH
48492: CALL_OW 255
48496: PPUSH
48497: LD_EXP 129
48501: PUSH
48502: LD_VAR 0 2
48506: ARRAY
48507: PUSH
48508: LD_VAR 0 3
48512: ARRAY
48513: PUSH
48514: LD_INT 2
48516: ARRAY
48517: PPUSH
48518: LD_EXP 129
48522: PUSH
48523: LD_VAR 0 2
48527: ARRAY
48528: PUSH
48529: LD_VAR 0 3
48533: ARRAY
48534: PUSH
48535: LD_INT 3
48537: ARRAY
48538: PPUSH
48539: LD_INT 30
48541: PPUSH
48542: CALL 70954 0 4
48546: PUSH
48547: LD_INT 4
48549: ARRAY
48550: PUSH
48551: LD_INT 0
48553: EQUAL
48554: IFFALSE 48580
// begin target := mc_crates [ i ] [ j ] ;
48556: LD_ADDR_VAR 0 6
48560: PUSH
48561: LD_EXP 129
48565: PUSH
48566: LD_VAR 0 2
48570: ARRAY
48571: PUSH
48572: LD_VAR 0 3
48576: ARRAY
48577: ST_TO_ADDR
// break ;
48578: GO 48582
// end ; end ;
48580: GO 48321
48582: POP
48583: POP
// if not target then
48584: LD_VAR 0 6
48588: NOT
48589: IFFALSE 48593
// continue ;
48591: GO 48202
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48593: LD_ADDR_VAR 0 7
48597: PUSH
48598: LD_EXP 132
48602: PUSH
48603: LD_VAR 0 2
48607: ARRAY
48608: PPUSH
48609: LD_INT 2
48611: PUSH
48612: LD_INT 3
48614: PUSH
48615: LD_INT 58
48617: PUSH
48618: EMPTY
48619: LIST
48620: PUSH
48621: EMPTY
48622: LIST
48623: LIST
48624: PUSH
48625: LD_INT 61
48627: PUSH
48628: EMPTY
48629: LIST
48630: PUSH
48631: LD_INT 33
48633: PUSH
48634: LD_INT 5
48636: PUSH
48637: EMPTY
48638: LIST
48639: LIST
48640: PUSH
48641: LD_INT 33
48643: PUSH
48644: LD_INT 3
48646: PUSH
48647: EMPTY
48648: LIST
48649: LIST
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: PUSH
48658: LD_INT 2
48660: PUSH
48661: LD_INT 34
48663: PUSH
48664: LD_INT 32
48666: PUSH
48667: EMPTY
48668: LIST
48669: LIST
48670: PUSH
48671: LD_INT 34
48673: PUSH
48674: LD_INT 51
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 34
48683: PUSH
48684: LD_INT 12
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: PUSH
48697: EMPTY
48698: LIST
48699: LIST
48700: PPUSH
48701: CALL_OW 72
48705: ST_TO_ADDR
// if not cargo then
48706: LD_VAR 0 7
48710: NOT
48711: IFFALSE 49354
// begin if mc_crates_collector [ i ] < 5 then
48713: LD_EXP 130
48717: PUSH
48718: LD_VAR 0 2
48722: ARRAY
48723: PUSH
48724: LD_INT 5
48726: LESS
48727: IFFALSE 49093
// begin if mc_ape [ i ] then
48729: LD_EXP 142
48733: PUSH
48734: LD_VAR 0 2
48738: ARRAY
48739: IFFALSE 48786
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48741: LD_ADDR_VAR 0 5
48745: PUSH
48746: LD_EXP 142
48750: PUSH
48751: LD_VAR 0 2
48755: ARRAY
48756: PPUSH
48757: LD_INT 25
48759: PUSH
48760: LD_INT 16
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 24
48769: PUSH
48770: LD_INT 750
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: PPUSH
48781: CALL_OW 72
48785: ST_TO_ADDR
// if not tmp then
48786: LD_VAR 0 5
48790: NOT
48791: IFFALSE 48838
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48793: LD_ADDR_VAR 0 5
48797: PUSH
48798: LD_EXP 113
48802: PUSH
48803: LD_VAR 0 2
48807: ARRAY
48808: PPUSH
48809: LD_INT 25
48811: PUSH
48812: LD_INT 2
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PUSH
48819: LD_INT 24
48821: PUSH
48822: LD_INT 750
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: PUSH
48829: EMPTY
48830: LIST
48831: LIST
48832: PPUSH
48833: CALL_OW 72
48837: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48838: LD_EXP 142
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: PUSH
48849: LD_EXP 113
48853: PUSH
48854: LD_VAR 0 2
48858: ARRAY
48859: PPUSH
48860: LD_INT 25
48862: PUSH
48863: LD_INT 2
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 24
48872: PUSH
48873: LD_INT 750
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PPUSH
48884: CALL_OW 72
48888: AND
48889: PUSH
48890: LD_VAR 0 5
48894: PUSH
48895: LD_INT 5
48897: LESS
48898: AND
48899: IFFALSE 48981
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48901: LD_ADDR_VAR 0 3
48905: PUSH
48906: LD_EXP 113
48910: PUSH
48911: LD_VAR 0 2
48915: ARRAY
48916: PPUSH
48917: LD_INT 25
48919: PUSH
48920: LD_INT 2
48922: PUSH
48923: EMPTY
48924: LIST
48925: LIST
48926: PUSH
48927: LD_INT 24
48929: PUSH
48930: LD_INT 750
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PUSH
48937: EMPTY
48938: LIST
48939: LIST
48940: PPUSH
48941: CALL_OW 72
48945: PUSH
48946: FOR_IN
48947: IFFALSE 48979
// begin tmp := tmp union j ;
48949: LD_ADDR_VAR 0 5
48953: PUSH
48954: LD_VAR 0 5
48958: PUSH
48959: LD_VAR 0 3
48963: UNION
48964: ST_TO_ADDR
// if tmp >= 5 then
48965: LD_VAR 0 5
48969: PUSH
48970: LD_INT 5
48972: GREATEREQUAL
48973: IFFALSE 48977
// break ;
48975: GO 48979
// end ;
48977: GO 48946
48979: POP
48980: POP
// end ; if not tmp then
48981: LD_VAR 0 5
48985: NOT
48986: IFFALSE 48990
// continue ;
48988: GO 48202
// for j in tmp do
48990: LD_ADDR_VAR 0 3
48994: PUSH
48995: LD_VAR 0 5
48999: PUSH
49000: FOR_IN
49001: IFFALSE 49091
// if not GetTag ( j ) then
49003: LD_VAR 0 3
49007: PPUSH
49008: CALL_OW 110
49012: NOT
49013: IFFALSE 49089
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49015: LD_ADDR_EXP 130
49019: PUSH
49020: LD_EXP 130
49024: PPUSH
49025: LD_VAR 0 2
49029: PUSH
49030: LD_EXP 130
49034: PUSH
49035: LD_VAR 0 2
49039: ARRAY
49040: PUSH
49041: LD_INT 1
49043: PLUS
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: PPUSH
49049: LD_VAR 0 3
49053: PPUSH
49054: CALL 70058 0 3
49058: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49059: LD_VAR 0 3
49063: PPUSH
49064: LD_INT 107
49066: PPUSH
49067: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49071: LD_EXP 130
49075: PUSH
49076: LD_VAR 0 2
49080: ARRAY
49081: PUSH
49082: LD_INT 5
49084: GREATEREQUAL
49085: IFFALSE 49089
// break ;
49087: GO 49091
// end ;
49089: GO 49000
49091: POP
49092: POP
// end ; if mc_crates_collector [ i ] and target then
49093: LD_EXP 130
49097: PUSH
49098: LD_VAR 0 2
49102: ARRAY
49103: PUSH
49104: LD_VAR 0 6
49108: AND
49109: IFFALSE 49352
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49111: LD_EXP 130
49115: PUSH
49116: LD_VAR 0 2
49120: ARRAY
49121: PUSH
49122: LD_VAR 0 6
49126: PUSH
49127: LD_INT 1
49129: ARRAY
49130: LESS
49131: IFFALSE 49151
// tmp := mc_crates_collector [ i ] else
49133: LD_ADDR_VAR 0 5
49137: PUSH
49138: LD_EXP 130
49142: PUSH
49143: LD_VAR 0 2
49147: ARRAY
49148: ST_TO_ADDR
49149: GO 49165
// tmp := target [ 1 ] ;
49151: LD_ADDR_VAR 0 5
49155: PUSH
49156: LD_VAR 0 6
49160: PUSH
49161: LD_INT 1
49163: ARRAY
49164: ST_TO_ADDR
// k := 0 ;
49165: LD_ADDR_VAR 0 4
49169: PUSH
49170: LD_INT 0
49172: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49173: LD_ADDR_VAR 0 3
49177: PUSH
49178: LD_EXP 130
49182: PUSH
49183: LD_VAR 0 2
49187: ARRAY
49188: PUSH
49189: FOR_IN
49190: IFFALSE 49350
// begin k := k + 1 ;
49192: LD_ADDR_VAR 0 4
49196: PUSH
49197: LD_VAR 0 4
49201: PUSH
49202: LD_INT 1
49204: PLUS
49205: ST_TO_ADDR
// if k > tmp then
49206: LD_VAR 0 4
49210: PUSH
49211: LD_VAR 0 5
49215: GREATER
49216: IFFALSE 49220
// break ;
49218: GO 49350
// if not GetClass ( j ) in [ 2 , 16 ] then
49220: LD_VAR 0 3
49224: PPUSH
49225: CALL_OW 257
49229: PUSH
49230: LD_INT 2
49232: PUSH
49233: LD_INT 16
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: IN
49240: NOT
49241: IFFALSE 49294
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49243: LD_ADDR_EXP 130
49247: PUSH
49248: LD_EXP 130
49252: PPUSH
49253: LD_VAR 0 2
49257: PPUSH
49258: LD_EXP 130
49262: PUSH
49263: LD_VAR 0 2
49267: ARRAY
49268: PUSH
49269: LD_VAR 0 3
49273: DIFF
49274: PPUSH
49275: CALL_OW 1
49279: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49280: LD_VAR 0 3
49284: PPUSH
49285: LD_INT 0
49287: PPUSH
49288: CALL_OW 109
// continue ;
49292: GO 49189
// end ; if IsInUnit ( j ) then
49294: LD_VAR 0 3
49298: PPUSH
49299: CALL_OW 310
49303: IFFALSE 49314
// ComExitBuilding ( j ) ;
49305: LD_VAR 0 3
49309: PPUSH
49310: CALL_OW 122
// wait ( 3 ) ;
49314: LD_INT 3
49316: PPUSH
49317: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49321: LD_VAR 0 3
49325: PPUSH
49326: LD_VAR 0 6
49330: PUSH
49331: LD_INT 2
49333: ARRAY
49334: PPUSH
49335: LD_VAR 0 6
49339: PUSH
49340: LD_INT 3
49342: ARRAY
49343: PPUSH
49344: CALL_OW 117
// end ;
49348: GO 49189
49350: POP
49351: POP
// end ; end else
49352: GO 49933
// begin for j in cargo do
49354: LD_ADDR_VAR 0 3
49358: PUSH
49359: LD_VAR 0 7
49363: PUSH
49364: FOR_IN
49365: IFFALSE 49931
// begin if GetTag ( j ) <> 0 then
49367: LD_VAR 0 3
49371: PPUSH
49372: CALL_OW 110
49376: PUSH
49377: LD_INT 0
49379: NONEQUAL
49380: IFFALSE 49384
// continue ;
49382: GO 49364
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49384: LD_VAR 0 3
49388: PPUSH
49389: CALL_OW 256
49393: PUSH
49394: LD_INT 1000
49396: LESS
49397: PUSH
49398: LD_VAR 0 3
49402: PPUSH
49403: LD_EXP 137
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: PPUSH
49414: CALL_OW 308
49418: NOT
49419: AND
49420: IFFALSE 49442
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49422: LD_VAR 0 3
49426: PPUSH
49427: LD_EXP 137
49431: PUSH
49432: LD_VAR 0 2
49436: ARRAY
49437: PPUSH
49438: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49442: LD_VAR 0 3
49446: PPUSH
49447: CALL_OW 256
49451: PUSH
49452: LD_INT 1000
49454: LESS
49455: PUSH
49456: LD_VAR 0 3
49460: PPUSH
49461: LD_EXP 137
49465: PUSH
49466: LD_VAR 0 2
49470: ARRAY
49471: PPUSH
49472: CALL_OW 308
49476: AND
49477: IFFALSE 49481
// continue ;
49479: GO 49364
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49481: LD_VAR 0 3
49485: PPUSH
49486: CALL_OW 262
49490: PUSH
49491: LD_INT 2
49493: EQUAL
49494: PUSH
49495: LD_VAR 0 3
49499: PPUSH
49500: CALL_OW 261
49504: PUSH
49505: LD_INT 15
49507: LESS
49508: AND
49509: IFFALSE 49513
// continue ;
49511: GO 49364
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49513: LD_VAR 0 3
49517: PPUSH
49518: CALL_OW 262
49522: PUSH
49523: LD_INT 1
49525: EQUAL
49526: PUSH
49527: LD_VAR 0 3
49531: PPUSH
49532: CALL_OW 261
49536: PUSH
49537: LD_INT 10
49539: LESS
49540: AND
49541: IFFALSE 49870
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49543: LD_ADDR_VAR 0 8
49547: PUSH
49548: LD_EXP 113
49552: PUSH
49553: LD_VAR 0 2
49557: ARRAY
49558: PPUSH
49559: LD_INT 2
49561: PUSH
49562: LD_INT 30
49564: PUSH
49565: LD_INT 0
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 30
49574: PUSH
49575: LD_INT 1
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: LIST
49586: PPUSH
49587: CALL_OW 72
49591: ST_TO_ADDR
// if not depot then
49592: LD_VAR 0 8
49596: NOT
49597: IFFALSE 49601
// continue ;
49599: GO 49364
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49601: LD_VAR 0 3
49605: PPUSH
49606: LD_VAR 0 8
49610: PPUSH
49611: LD_VAR 0 3
49615: PPUSH
49616: CALL_OW 74
49620: PPUSH
49621: CALL_OW 296
49625: PUSH
49626: LD_INT 6
49628: LESS
49629: IFFALSE 49645
// SetFuel ( j , 100 ) else
49631: LD_VAR 0 3
49635: PPUSH
49636: LD_INT 100
49638: PPUSH
49639: CALL_OW 240
49643: GO 49870
// if GetFuel ( j ) = 0 then
49645: LD_VAR 0 3
49649: PPUSH
49650: CALL_OW 261
49654: PUSH
49655: LD_INT 0
49657: EQUAL
49658: IFFALSE 49870
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49660: LD_ADDR_EXP 132
49664: PUSH
49665: LD_EXP 132
49669: PPUSH
49670: LD_VAR 0 2
49674: PPUSH
49675: LD_EXP 132
49679: PUSH
49680: LD_VAR 0 2
49684: ARRAY
49685: PUSH
49686: LD_VAR 0 3
49690: DIFF
49691: PPUSH
49692: CALL_OW 1
49696: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49697: LD_VAR 0 3
49701: PPUSH
49702: CALL_OW 263
49706: PUSH
49707: LD_INT 1
49709: EQUAL
49710: IFFALSE 49726
// ComExitVehicle ( IsInUnit ( j ) ) ;
49712: LD_VAR 0 3
49716: PPUSH
49717: CALL_OW 310
49721: PPUSH
49722: CALL_OW 121
// if GetControl ( j ) = control_remote then
49726: LD_VAR 0 3
49730: PPUSH
49731: CALL_OW 263
49735: PUSH
49736: LD_INT 2
49738: EQUAL
49739: IFFALSE 49750
// ComUnlink ( j ) ;
49741: LD_VAR 0 3
49745: PPUSH
49746: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49750: LD_ADDR_VAR 0 9
49754: PUSH
49755: LD_VAR 0 2
49759: PPUSH
49760: LD_INT 3
49762: PPUSH
49763: CALL 59223 0 2
49767: ST_TO_ADDR
// if fac then
49768: LD_VAR 0 9
49772: IFFALSE 49868
// begin for k in fac do
49774: LD_ADDR_VAR 0 4
49778: PUSH
49779: LD_VAR 0 9
49783: PUSH
49784: FOR_IN
49785: IFFALSE 49866
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49787: LD_ADDR_VAR 0 10
49791: PUSH
49792: LD_VAR 0 9
49796: PPUSH
49797: LD_VAR 0 3
49801: PPUSH
49802: CALL_OW 265
49806: PPUSH
49807: LD_VAR 0 3
49811: PPUSH
49812: CALL_OW 262
49816: PPUSH
49817: LD_VAR 0 3
49821: PPUSH
49822: CALL_OW 263
49826: PPUSH
49827: LD_VAR 0 3
49831: PPUSH
49832: CALL_OW 264
49836: PPUSH
49837: CALL 67590 0 5
49841: ST_TO_ADDR
// if components then
49842: LD_VAR 0 10
49846: IFFALSE 49864
// begin MC_InsertProduceList ( i , components ) ;
49848: LD_VAR 0 2
49852: PPUSH
49853: LD_VAR 0 10
49857: PPUSH
49858: CALL 58768 0 2
// break ;
49862: GO 49866
// end ; end ;
49864: GO 49784
49866: POP
49867: POP
// end ; continue ;
49868: GO 49364
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49870: LD_VAR 0 3
49874: PPUSH
49875: LD_INT 1
49877: PPUSH
49878: CALL_OW 289
49882: PUSH
49883: LD_INT 100
49885: LESS
49886: PUSH
49887: LD_VAR 0 3
49891: PPUSH
49892: CALL_OW 314
49896: NOT
49897: AND
49898: IFFALSE 49927
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49900: LD_VAR 0 3
49904: PPUSH
49905: LD_VAR 0 6
49909: PUSH
49910: LD_INT 2
49912: ARRAY
49913: PPUSH
49914: LD_VAR 0 6
49918: PUSH
49919: LD_INT 3
49921: ARRAY
49922: PPUSH
49923: CALL_OW 117
// break ;
49927: GO 49931
// end ;
49929: GO 49364
49931: POP
49932: POP
// end ; end ;
49933: GO 48202
49935: POP
49936: POP
// end ;
49937: LD_VAR 0 1
49941: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49942: LD_INT 0
49944: PPUSH
49945: PPUSH
49946: PPUSH
49947: PPUSH
// if not mc_bases then
49948: LD_EXP 113
49952: NOT
49953: IFFALSE 49957
// exit ;
49955: GO 50118
// for i = 1 to mc_bases do
49957: LD_ADDR_VAR 0 2
49961: PUSH
49962: DOUBLE
49963: LD_INT 1
49965: DEC
49966: ST_TO_ADDR
49967: LD_EXP 113
49971: PUSH
49972: FOR_TO
49973: IFFALSE 50116
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49975: LD_ADDR_VAR 0 4
49979: PUSH
49980: LD_EXP 132
49984: PUSH
49985: LD_VAR 0 2
49989: ARRAY
49990: PUSH
49991: LD_EXP 135
49995: PUSH
49996: LD_VAR 0 2
50000: ARRAY
50001: UNION
50002: PPUSH
50003: LD_INT 33
50005: PUSH
50006: LD_INT 2
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: PPUSH
50013: CALL_OW 72
50017: ST_TO_ADDR
// if tmp then
50018: LD_VAR 0 4
50022: IFFALSE 50114
// for j in tmp do
50024: LD_ADDR_VAR 0 3
50028: PUSH
50029: LD_VAR 0 4
50033: PUSH
50034: FOR_IN
50035: IFFALSE 50112
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50037: LD_VAR 0 3
50041: PPUSH
50042: CALL_OW 312
50046: NOT
50047: PUSH
50048: LD_VAR 0 3
50052: PPUSH
50053: CALL_OW 256
50057: PUSH
50058: LD_INT 250
50060: GREATEREQUAL
50061: AND
50062: IFFALSE 50075
// Connect ( j ) else
50064: LD_VAR 0 3
50068: PPUSH
50069: CALL 72991 0 1
50073: GO 50110
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50075: LD_VAR 0 3
50079: PPUSH
50080: CALL_OW 256
50084: PUSH
50085: LD_INT 250
50087: LESS
50088: PUSH
50089: LD_VAR 0 3
50093: PPUSH
50094: CALL_OW 312
50098: AND
50099: IFFALSE 50110
// ComUnlink ( j ) ;
50101: LD_VAR 0 3
50105: PPUSH
50106: CALL_OW 136
50110: GO 50034
50112: POP
50113: POP
// end ;
50114: GO 49972
50116: POP
50117: POP
// end ;
50118: LD_VAR 0 1
50122: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50123: LD_INT 0
50125: PPUSH
50126: PPUSH
50127: PPUSH
50128: PPUSH
50129: PPUSH
// if not mc_bases then
50130: LD_EXP 113
50134: NOT
50135: IFFALSE 50139
// exit ;
50137: GO 50584
// for i = 1 to mc_bases do
50139: LD_ADDR_VAR 0 2
50143: PUSH
50144: DOUBLE
50145: LD_INT 1
50147: DEC
50148: ST_TO_ADDR
50149: LD_EXP 113
50153: PUSH
50154: FOR_TO
50155: IFFALSE 50582
// begin if not mc_produce [ i ] then
50157: LD_EXP 134
50161: PUSH
50162: LD_VAR 0 2
50166: ARRAY
50167: NOT
50168: IFFALSE 50172
// continue ;
50170: GO 50154
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50172: LD_ADDR_VAR 0 5
50176: PUSH
50177: LD_EXP 113
50181: PUSH
50182: LD_VAR 0 2
50186: ARRAY
50187: PPUSH
50188: LD_INT 30
50190: PUSH
50191: LD_INT 3
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PPUSH
50198: CALL_OW 72
50202: ST_TO_ADDR
// if not fac then
50203: LD_VAR 0 5
50207: NOT
50208: IFFALSE 50212
// continue ;
50210: GO 50154
// for j in fac do
50212: LD_ADDR_VAR 0 3
50216: PUSH
50217: LD_VAR 0 5
50221: PUSH
50222: FOR_IN
50223: IFFALSE 50578
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50225: LD_VAR 0 3
50229: PPUSH
50230: CALL_OW 461
50234: PUSH
50235: LD_INT 2
50237: NONEQUAL
50238: PUSH
50239: LD_VAR 0 3
50243: PPUSH
50244: LD_INT 15
50246: PPUSH
50247: CALL 72651 0 2
50251: PUSH
50252: LD_INT 4
50254: ARRAY
50255: OR
50256: IFFALSE 50260
// continue ;
50258: GO 50222
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50260: LD_VAR 0 3
50264: PPUSH
50265: LD_EXP 134
50269: PUSH
50270: LD_VAR 0 2
50274: ARRAY
50275: PUSH
50276: LD_INT 1
50278: ARRAY
50279: PUSH
50280: LD_INT 1
50282: ARRAY
50283: PPUSH
50284: LD_EXP 134
50288: PUSH
50289: LD_VAR 0 2
50293: ARRAY
50294: PUSH
50295: LD_INT 1
50297: ARRAY
50298: PUSH
50299: LD_INT 2
50301: ARRAY
50302: PPUSH
50303: LD_EXP 134
50307: PUSH
50308: LD_VAR 0 2
50312: ARRAY
50313: PUSH
50314: LD_INT 1
50316: ARRAY
50317: PUSH
50318: LD_INT 3
50320: ARRAY
50321: PPUSH
50322: LD_EXP 134
50326: PUSH
50327: LD_VAR 0 2
50331: ARRAY
50332: PUSH
50333: LD_INT 1
50335: ARRAY
50336: PUSH
50337: LD_INT 4
50339: ARRAY
50340: PPUSH
50341: CALL_OW 448
50345: PUSH
50346: LD_VAR 0 3
50350: PPUSH
50351: LD_EXP 134
50355: PUSH
50356: LD_VAR 0 2
50360: ARRAY
50361: PUSH
50362: LD_INT 1
50364: ARRAY
50365: PUSH
50366: LD_INT 1
50368: ARRAY
50369: PUSH
50370: LD_EXP 134
50374: PUSH
50375: LD_VAR 0 2
50379: ARRAY
50380: PUSH
50381: LD_INT 1
50383: ARRAY
50384: PUSH
50385: LD_INT 2
50387: ARRAY
50388: PUSH
50389: LD_EXP 134
50393: PUSH
50394: LD_VAR 0 2
50398: ARRAY
50399: PUSH
50400: LD_INT 1
50402: ARRAY
50403: PUSH
50404: LD_INT 3
50406: ARRAY
50407: PUSH
50408: LD_EXP 134
50412: PUSH
50413: LD_VAR 0 2
50417: ARRAY
50418: PUSH
50419: LD_INT 1
50421: ARRAY
50422: PUSH
50423: LD_INT 4
50425: ARRAY
50426: PUSH
50427: EMPTY
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: PPUSH
50433: CALL 76322 0 2
50437: AND
50438: IFFALSE 50576
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50440: LD_VAR 0 3
50444: PPUSH
50445: LD_EXP 134
50449: PUSH
50450: LD_VAR 0 2
50454: ARRAY
50455: PUSH
50456: LD_INT 1
50458: ARRAY
50459: PUSH
50460: LD_INT 1
50462: ARRAY
50463: PPUSH
50464: LD_EXP 134
50468: PUSH
50469: LD_VAR 0 2
50473: ARRAY
50474: PUSH
50475: LD_INT 1
50477: ARRAY
50478: PUSH
50479: LD_INT 2
50481: ARRAY
50482: PPUSH
50483: LD_EXP 134
50487: PUSH
50488: LD_VAR 0 2
50492: ARRAY
50493: PUSH
50494: LD_INT 1
50496: ARRAY
50497: PUSH
50498: LD_INT 3
50500: ARRAY
50501: PPUSH
50502: LD_EXP 134
50506: PUSH
50507: LD_VAR 0 2
50511: ARRAY
50512: PUSH
50513: LD_INT 1
50515: ARRAY
50516: PUSH
50517: LD_INT 4
50519: ARRAY
50520: PPUSH
50521: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50525: LD_ADDR_VAR 0 4
50529: PUSH
50530: LD_EXP 134
50534: PUSH
50535: LD_VAR 0 2
50539: ARRAY
50540: PPUSH
50541: LD_INT 1
50543: PPUSH
50544: CALL_OW 3
50548: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50549: LD_ADDR_EXP 134
50553: PUSH
50554: LD_EXP 134
50558: PPUSH
50559: LD_VAR 0 2
50563: PPUSH
50564: LD_VAR 0 4
50568: PPUSH
50569: CALL_OW 1
50573: ST_TO_ADDR
// break ;
50574: GO 50578
// end ; end ;
50576: GO 50222
50578: POP
50579: POP
// end ;
50580: GO 50154
50582: POP
50583: POP
// end ;
50584: LD_VAR 0 1
50588: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50589: LD_INT 0
50591: PPUSH
50592: PPUSH
50593: PPUSH
// if not mc_bases then
50594: LD_EXP 113
50598: NOT
50599: IFFALSE 50603
// exit ;
50601: GO 50692
// for i = 1 to mc_bases do
50603: LD_ADDR_VAR 0 2
50607: PUSH
50608: DOUBLE
50609: LD_INT 1
50611: DEC
50612: ST_TO_ADDR
50613: LD_EXP 113
50617: PUSH
50618: FOR_TO
50619: IFFALSE 50690
// begin if mc_attack [ i ] then
50621: LD_EXP 133
50625: PUSH
50626: LD_VAR 0 2
50630: ARRAY
50631: IFFALSE 50688
// begin tmp := mc_attack [ i ] [ 1 ] ;
50633: LD_ADDR_VAR 0 3
50637: PUSH
50638: LD_EXP 133
50642: PUSH
50643: LD_VAR 0 2
50647: ARRAY
50648: PUSH
50649: LD_INT 1
50651: ARRAY
50652: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50653: LD_ADDR_EXP 133
50657: PUSH
50658: LD_EXP 133
50662: PPUSH
50663: LD_VAR 0 2
50667: PPUSH
50668: EMPTY
50669: PPUSH
50670: CALL_OW 1
50674: ST_TO_ADDR
// Attack ( tmp ) ;
50675: LD_VAR 0 3
50679: PPUSH
50680: CALL 119080 0 1
// exit ;
50684: POP
50685: POP
50686: GO 50692
// end ; end ;
50688: GO 50618
50690: POP
50691: POP
// end ;
50692: LD_VAR 0 1
50696: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50697: LD_INT 0
50699: PPUSH
50700: PPUSH
50701: PPUSH
50702: PPUSH
50703: PPUSH
50704: PPUSH
50705: PPUSH
// if not mc_bases then
50706: LD_EXP 113
50710: NOT
50711: IFFALSE 50715
// exit ;
50713: GO 51297
// for i = 1 to mc_bases do
50715: LD_ADDR_VAR 0 2
50719: PUSH
50720: DOUBLE
50721: LD_INT 1
50723: DEC
50724: ST_TO_ADDR
50725: LD_EXP 113
50729: PUSH
50730: FOR_TO
50731: IFFALSE 51295
// begin if not mc_bases [ i ] then
50733: LD_EXP 113
50737: PUSH
50738: LD_VAR 0 2
50742: ARRAY
50743: NOT
50744: IFFALSE 50748
// continue ;
50746: GO 50730
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50748: LD_ADDR_VAR 0 7
50752: PUSH
50753: LD_EXP 113
50757: PUSH
50758: LD_VAR 0 2
50762: ARRAY
50763: PUSH
50764: LD_INT 1
50766: ARRAY
50767: PPUSH
50768: CALL 66894 0 1
50772: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50773: LD_ADDR_EXP 136
50777: PUSH
50778: LD_EXP 136
50782: PPUSH
50783: LD_VAR 0 2
50787: PPUSH
50788: LD_EXP 113
50792: PUSH
50793: LD_VAR 0 2
50797: ARRAY
50798: PUSH
50799: LD_INT 1
50801: ARRAY
50802: PPUSH
50803: CALL_OW 255
50807: PPUSH
50808: LD_EXP 138
50812: PUSH
50813: LD_VAR 0 2
50817: ARRAY
50818: PPUSH
50819: CALL 66859 0 2
50823: PPUSH
50824: CALL_OW 1
50828: ST_TO_ADDR
// if not mc_scan [ i ] then
50829: LD_EXP 136
50833: PUSH
50834: LD_VAR 0 2
50838: ARRAY
50839: NOT
50840: IFFALSE 50995
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50842: LD_ADDR_VAR 0 4
50846: PUSH
50847: LD_EXP 113
50851: PUSH
50852: LD_VAR 0 2
50856: ARRAY
50857: PPUSH
50858: LD_INT 2
50860: PUSH
50861: LD_INT 25
50863: PUSH
50864: LD_INT 5
50866: PUSH
50867: EMPTY
50868: LIST
50869: LIST
50870: PUSH
50871: LD_INT 25
50873: PUSH
50874: LD_INT 8
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PUSH
50881: LD_INT 25
50883: PUSH
50884: LD_INT 9
50886: PUSH
50887: EMPTY
50888: LIST
50889: LIST
50890: PUSH
50891: EMPTY
50892: LIST
50893: LIST
50894: LIST
50895: LIST
50896: PPUSH
50897: CALL_OW 72
50901: ST_TO_ADDR
// if not tmp then
50902: LD_VAR 0 4
50906: NOT
50907: IFFALSE 50911
// continue ;
50909: GO 50730
// for j in tmp do
50911: LD_ADDR_VAR 0 3
50915: PUSH
50916: LD_VAR 0 4
50920: PUSH
50921: FOR_IN
50922: IFFALSE 50993
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50924: LD_VAR 0 3
50928: PPUSH
50929: CALL_OW 310
50933: PPUSH
50934: CALL_OW 266
50938: PUSH
50939: LD_INT 5
50941: EQUAL
50942: PUSH
50943: LD_VAR 0 3
50947: PPUSH
50948: CALL_OW 257
50952: PUSH
50953: LD_INT 1
50955: EQUAL
50956: AND
50957: PUSH
50958: LD_VAR 0 3
50962: PPUSH
50963: CALL_OW 459
50967: NOT
50968: AND
50969: PUSH
50970: LD_VAR 0 7
50974: AND
50975: IFFALSE 50991
// ComChangeProfession ( j , class ) ;
50977: LD_VAR 0 3
50981: PPUSH
50982: LD_VAR 0 7
50986: PPUSH
50987: CALL_OW 123
50991: GO 50921
50993: POP
50994: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50995: LD_EXP 136
50999: PUSH
51000: LD_VAR 0 2
51004: ARRAY
51005: PUSH
51006: LD_EXP 135
51010: PUSH
51011: LD_VAR 0 2
51015: ARRAY
51016: NOT
51017: AND
51018: PUSH
51019: LD_EXP 113
51023: PUSH
51024: LD_VAR 0 2
51028: ARRAY
51029: PPUSH
51030: LD_INT 30
51032: PUSH
51033: LD_INT 32
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PPUSH
51040: CALL_OW 72
51044: NOT
51045: AND
51046: PUSH
51047: LD_EXP 113
51051: PUSH
51052: LD_VAR 0 2
51056: ARRAY
51057: PPUSH
51058: LD_INT 2
51060: PUSH
51061: LD_INT 30
51063: PUSH
51064: LD_INT 4
51066: PUSH
51067: EMPTY
51068: LIST
51069: LIST
51070: PUSH
51071: LD_INT 30
51073: PUSH
51074: LD_INT 5
51076: PUSH
51077: EMPTY
51078: LIST
51079: LIST
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: LIST
51085: PPUSH
51086: CALL_OW 72
51090: NOT
51091: AND
51092: IFFALSE 51224
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51094: LD_ADDR_VAR 0 4
51098: PUSH
51099: LD_EXP 113
51103: PUSH
51104: LD_VAR 0 2
51108: ARRAY
51109: PPUSH
51110: LD_INT 2
51112: PUSH
51113: LD_INT 25
51115: PUSH
51116: LD_INT 1
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: PUSH
51123: LD_INT 25
51125: PUSH
51126: LD_INT 5
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: PUSH
51133: LD_INT 25
51135: PUSH
51136: LD_INT 8
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PUSH
51143: LD_INT 25
51145: PUSH
51146: LD_INT 9
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: PUSH
51153: EMPTY
51154: LIST
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: PPUSH
51160: CALL_OW 72
51164: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51165: LD_ADDR_VAR 0 4
51169: PUSH
51170: LD_VAR 0 4
51174: PUSH
51175: LD_VAR 0 4
51179: PPUSH
51180: LD_INT 18
51182: PPUSH
51183: CALL 98619 0 2
51187: DIFF
51188: ST_TO_ADDR
// if tmp then
51189: LD_VAR 0 4
51193: IFFALSE 51224
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51195: LD_VAR 0 2
51199: PPUSH
51200: LD_VAR 0 4
51204: PPUSH
51205: LD_EXP 138
51209: PUSH
51210: LD_VAR 0 2
51214: ARRAY
51215: PPUSH
51216: CALL 123789 0 3
// exit ;
51220: POP
51221: POP
51222: GO 51297
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51224: LD_EXP 136
51228: PUSH
51229: LD_VAR 0 2
51233: ARRAY
51234: PUSH
51235: LD_EXP 135
51239: PUSH
51240: LD_VAR 0 2
51244: ARRAY
51245: AND
51246: IFFALSE 51293
// begin tmp := mc_defender [ i ] ;
51248: LD_ADDR_VAR 0 4
51252: PUSH
51253: LD_EXP 135
51257: PUSH
51258: LD_VAR 0 2
51262: ARRAY
51263: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51264: LD_VAR 0 2
51268: PPUSH
51269: LD_VAR 0 4
51273: PPUSH
51274: LD_EXP 136
51278: PUSH
51279: LD_VAR 0 2
51283: ARRAY
51284: PPUSH
51285: CALL 124350 0 3
// exit ;
51289: POP
51290: POP
51291: GO 51297
// end ; end ;
51293: GO 50730
51295: POP
51296: POP
// end ;
51297: LD_VAR 0 1
51301: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51302: LD_INT 0
51304: PPUSH
51305: PPUSH
51306: PPUSH
51307: PPUSH
51308: PPUSH
51309: PPUSH
51310: PPUSH
51311: PPUSH
51312: PPUSH
51313: PPUSH
51314: PPUSH
// if not mc_bases then
51315: LD_EXP 113
51319: NOT
51320: IFFALSE 51324
// exit ;
51322: GO 52411
// for i = 1 to mc_bases do
51324: LD_ADDR_VAR 0 2
51328: PUSH
51329: DOUBLE
51330: LD_INT 1
51332: DEC
51333: ST_TO_ADDR
51334: LD_EXP 113
51338: PUSH
51339: FOR_TO
51340: IFFALSE 52409
// begin tmp := mc_lab [ i ] ;
51342: LD_ADDR_VAR 0 6
51346: PUSH
51347: LD_EXP 146
51351: PUSH
51352: LD_VAR 0 2
51356: ARRAY
51357: ST_TO_ADDR
// if not tmp then
51358: LD_VAR 0 6
51362: NOT
51363: IFFALSE 51367
// continue ;
51365: GO 51339
// idle_lab := 0 ;
51367: LD_ADDR_VAR 0 11
51371: PUSH
51372: LD_INT 0
51374: ST_TO_ADDR
// for j in tmp do
51375: LD_ADDR_VAR 0 3
51379: PUSH
51380: LD_VAR 0 6
51384: PUSH
51385: FOR_IN
51386: IFFALSE 52405
// begin researching := false ;
51388: LD_ADDR_VAR 0 10
51392: PUSH
51393: LD_INT 0
51395: ST_TO_ADDR
// side := GetSide ( j ) ;
51396: LD_ADDR_VAR 0 4
51400: PUSH
51401: LD_VAR 0 3
51405: PPUSH
51406: CALL_OW 255
51410: ST_TO_ADDR
// if not mc_tech [ side ] then
51411: LD_EXP 140
51415: PUSH
51416: LD_VAR 0 4
51420: ARRAY
51421: NOT
51422: IFFALSE 51426
// continue ;
51424: GO 51385
// if BuildingStatus ( j ) = bs_idle then
51426: LD_VAR 0 3
51430: PPUSH
51431: CALL_OW 461
51435: PUSH
51436: LD_INT 2
51438: EQUAL
51439: IFFALSE 51627
// begin if idle_lab and UnitsInside ( j ) < 6 then
51441: LD_VAR 0 11
51445: PUSH
51446: LD_VAR 0 3
51450: PPUSH
51451: CALL_OW 313
51455: PUSH
51456: LD_INT 6
51458: LESS
51459: AND
51460: IFFALSE 51531
// begin tmp2 := UnitsInside ( idle_lab ) ;
51462: LD_ADDR_VAR 0 9
51466: PUSH
51467: LD_VAR 0 11
51471: PPUSH
51472: CALL_OW 313
51476: ST_TO_ADDR
// if tmp2 then
51477: LD_VAR 0 9
51481: IFFALSE 51523
// for x in tmp2 do
51483: LD_ADDR_VAR 0 7
51487: PUSH
51488: LD_VAR 0 9
51492: PUSH
51493: FOR_IN
51494: IFFALSE 51521
// begin ComExitBuilding ( x ) ;
51496: LD_VAR 0 7
51500: PPUSH
51501: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51505: LD_VAR 0 7
51509: PPUSH
51510: LD_VAR 0 3
51514: PPUSH
51515: CALL_OW 180
// end ;
51519: GO 51493
51521: POP
51522: POP
// idle_lab := 0 ;
51523: LD_ADDR_VAR 0 11
51527: PUSH
51528: LD_INT 0
51530: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51531: LD_ADDR_VAR 0 5
51535: PUSH
51536: LD_EXP 140
51540: PUSH
51541: LD_VAR 0 4
51545: ARRAY
51546: PUSH
51547: FOR_IN
51548: IFFALSE 51608
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51550: LD_VAR 0 3
51554: PPUSH
51555: LD_VAR 0 5
51559: PPUSH
51560: CALL_OW 430
51564: PUSH
51565: LD_VAR 0 4
51569: PPUSH
51570: LD_VAR 0 5
51574: PPUSH
51575: CALL 65964 0 2
51579: AND
51580: IFFALSE 51606
// begin researching := true ;
51582: LD_ADDR_VAR 0 10
51586: PUSH
51587: LD_INT 1
51589: ST_TO_ADDR
// ComResearch ( j , t ) ;
51590: LD_VAR 0 3
51594: PPUSH
51595: LD_VAR 0 5
51599: PPUSH
51600: CALL_OW 124
// break ;
51604: GO 51608
// end ;
51606: GO 51547
51608: POP
51609: POP
// if not researching then
51610: LD_VAR 0 10
51614: NOT
51615: IFFALSE 51627
// idle_lab := j ;
51617: LD_ADDR_VAR 0 11
51621: PUSH
51622: LD_VAR 0 3
51626: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51627: LD_VAR 0 3
51631: PPUSH
51632: CALL_OW 461
51636: PUSH
51637: LD_INT 10
51639: EQUAL
51640: IFFALSE 52228
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51642: LD_EXP 142
51646: PUSH
51647: LD_VAR 0 2
51651: ARRAY
51652: NOT
51653: PUSH
51654: LD_EXP 143
51658: PUSH
51659: LD_VAR 0 2
51663: ARRAY
51664: NOT
51665: AND
51666: PUSH
51667: LD_EXP 140
51671: PUSH
51672: LD_VAR 0 4
51676: ARRAY
51677: PUSH
51678: LD_INT 1
51680: GREATER
51681: AND
51682: IFFALSE 51813
// begin ComCancel ( j ) ;
51684: LD_VAR 0 3
51688: PPUSH
51689: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51693: LD_ADDR_EXP 140
51697: PUSH
51698: LD_EXP 140
51702: PPUSH
51703: LD_VAR 0 4
51707: PPUSH
51708: LD_EXP 140
51712: PUSH
51713: LD_VAR 0 4
51717: ARRAY
51718: PPUSH
51719: LD_EXP 140
51723: PUSH
51724: LD_VAR 0 4
51728: ARRAY
51729: PUSH
51730: LD_INT 1
51732: MINUS
51733: PPUSH
51734: LD_EXP 140
51738: PUSH
51739: LD_VAR 0 4
51743: ARRAY
51744: PPUSH
51745: LD_INT 0
51747: PPUSH
51748: CALL 69476 0 4
51752: PPUSH
51753: CALL_OW 1
51757: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51758: LD_ADDR_EXP 140
51762: PUSH
51763: LD_EXP 140
51767: PPUSH
51768: LD_VAR 0 4
51772: PPUSH
51773: LD_EXP 140
51777: PUSH
51778: LD_VAR 0 4
51782: ARRAY
51783: PPUSH
51784: LD_EXP 140
51788: PUSH
51789: LD_VAR 0 4
51793: ARRAY
51794: PPUSH
51795: LD_INT 1
51797: PPUSH
51798: LD_INT 0
51800: PPUSH
51801: CALL 69476 0 4
51805: PPUSH
51806: CALL_OW 1
51810: ST_TO_ADDR
// continue ;
51811: GO 51385
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51813: LD_EXP 142
51817: PUSH
51818: LD_VAR 0 2
51822: ARRAY
51823: PUSH
51824: LD_EXP 143
51828: PUSH
51829: LD_VAR 0 2
51833: ARRAY
51834: NOT
51835: AND
51836: IFFALSE 51963
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51838: LD_ADDR_EXP 143
51842: PUSH
51843: LD_EXP 143
51847: PPUSH
51848: LD_VAR 0 2
51852: PUSH
51853: LD_EXP 143
51857: PUSH
51858: LD_VAR 0 2
51862: ARRAY
51863: PUSH
51864: LD_INT 1
51866: PLUS
51867: PUSH
51868: EMPTY
51869: LIST
51870: LIST
51871: PPUSH
51872: LD_EXP 142
51876: PUSH
51877: LD_VAR 0 2
51881: ARRAY
51882: PUSH
51883: LD_INT 1
51885: ARRAY
51886: PPUSH
51887: CALL 70058 0 3
51891: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51892: LD_EXP 142
51896: PUSH
51897: LD_VAR 0 2
51901: ARRAY
51902: PUSH
51903: LD_INT 1
51905: ARRAY
51906: PPUSH
51907: LD_INT 112
51909: PPUSH
51910: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51914: LD_ADDR_VAR 0 9
51918: PUSH
51919: LD_EXP 142
51923: PUSH
51924: LD_VAR 0 2
51928: ARRAY
51929: PPUSH
51930: LD_INT 1
51932: PPUSH
51933: CALL_OW 3
51937: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51938: LD_ADDR_EXP 142
51942: PUSH
51943: LD_EXP 142
51947: PPUSH
51948: LD_VAR 0 2
51952: PPUSH
51953: LD_VAR 0 9
51957: PPUSH
51958: CALL_OW 1
51962: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51963: LD_EXP 142
51967: PUSH
51968: LD_VAR 0 2
51972: ARRAY
51973: PUSH
51974: LD_EXP 143
51978: PUSH
51979: LD_VAR 0 2
51983: ARRAY
51984: AND
51985: PUSH
51986: LD_EXP 143
51990: PUSH
51991: LD_VAR 0 2
51995: ARRAY
51996: PUSH
51997: LD_INT 1
51999: ARRAY
52000: PPUSH
52001: CALL_OW 310
52005: NOT
52006: AND
52007: PUSH
52008: LD_VAR 0 3
52012: PPUSH
52013: CALL_OW 313
52017: PUSH
52018: LD_INT 6
52020: EQUAL
52021: AND
52022: IFFALSE 52078
// begin tmp2 := UnitsInside ( j ) ;
52024: LD_ADDR_VAR 0 9
52028: PUSH
52029: LD_VAR 0 3
52033: PPUSH
52034: CALL_OW 313
52038: ST_TO_ADDR
// if tmp2 = 6 then
52039: LD_VAR 0 9
52043: PUSH
52044: LD_INT 6
52046: EQUAL
52047: IFFALSE 52078
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52049: LD_VAR 0 9
52053: PUSH
52054: LD_INT 1
52056: ARRAY
52057: PPUSH
52058: LD_INT 112
52060: PPUSH
52061: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52065: LD_VAR 0 9
52069: PUSH
52070: LD_INT 1
52072: ARRAY
52073: PPUSH
52074: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52078: LD_EXP 143
52082: PUSH
52083: LD_VAR 0 2
52087: ARRAY
52088: PUSH
52089: LD_EXP 143
52093: PUSH
52094: LD_VAR 0 2
52098: ARRAY
52099: PUSH
52100: LD_INT 1
52102: ARRAY
52103: PPUSH
52104: CALL_OW 314
52108: NOT
52109: AND
52110: PUSH
52111: LD_EXP 143
52115: PUSH
52116: LD_VAR 0 2
52120: ARRAY
52121: PUSH
52122: LD_INT 1
52124: ARRAY
52125: PPUSH
52126: CALL_OW 310
52130: NOT
52131: AND
52132: IFFALSE 52158
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52134: LD_EXP 143
52138: PUSH
52139: LD_VAR 0 2
52143: ARRAY
52144: PUSH
52145: LD_INT 1
52147: ARRAY
52148: PPUSH
52149: LD_VAR 0 3
52153: PPUSH
52154: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52158: LD_EXP 143
52162: PUSH
52163: LD_VAR 0 2
52167: ARRAY
52168: PUSH
52169: LD_INT 1
52171: ARRAY
52172: PPUSH
52173: CALL_OW 310
52177: PUSH
52178: LD_EXP 143
52182: PUSH
52183: LD_VAR 0 2
52187: ARRAY
52188: PUSH
52189: LD_INT 1
52191: ARRAY
52192: PPUSH
52193: CALL_OW 310
52197: PPUSH
52198: CALL_OW 461
52202: PUSH
52203: LD_INT 3
52205: NONEQUAL
52206: AND
52207: IFFALSE 52228
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52209: LD_EXP 143
52213: PUSH
52214: LD_VAR 0 2
52218: ARRAY
52219: PUSH
52220: LD_INT 1
52222: ARRAY
52223: PPUSH
52224: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52228: LD_VAR 0 3
52232: PPUSH
52233: CALL_OW 461
52237: PUSH
52238: LD_INT 6
52240: EQUAL
52241: PUSH
52242: LD_VAR 0 6
52246: PUSH
52247: LD_INT 1
52249: GREATER
52250: AND
52251: IFFALSE 52403
// begin sci := [ ] ;
52253: LD_ADDR_VAR 0 8
52257: PUSH
52258: EMPTY
52259: ST_TO_ADDR
// for x in ( tmp diff j ) do
52260: LD_ADDR_VAR 0 7
52264: PUSH
52265: LD_VAR 0 6
52269: PUSH
52270: LD_VAR 0 3
52274: DIFF
52275: PUSH
52276: FOR_IN
52277: IFFALSE 52329
// begin if sci = 6 then
52279: LD_VAR 0 8
52283: PUSH
52284: LD_INT 6
52286: EQUAL
52287: IFFALSE 52291
// break ;
52289: GO 52329
// if BuildingStatus ( x ) = bs_idle then
52291: LD_VAR 0 7
52295: PPUSH
52296: CALL_OW 461
52300: PUSH
52301: LD_INT 2
52303: EQUAL
52304: IFFALSE 52327
// sci := sci ^ UnitsInside ( x ) ;
52306: LD_ADDR_VAR 0 8
52310: PUSH
52311: LD_VAR 0 8
52315: PUSH
52316: LD_VAR 0 7
52320: PPUSH
52321: CALL_OW 313
52325: ADD
52326: ST_TO_ADDR
// end ;
52327: GO 52276
52329: POP
52330: POP
// if not sci then
52331: LD_VAR 0 8
52335: NOT
52336: IFFALSE 52340
// continue ;
52338: GO 51385
// for x in sci do
52340: LD_ADDR_VAR 0 7
52344: PUSH
52345: LD_VAR 0 8
52349: PUSH
52350: FOR_IN
52351: IFFALSE 52401
// if IsInUnit ( x ) and not HasTask ( x ) then
52353: LD_VAR 0 7
52357: PPUSH
52358: CALL_OW 310
52362: PUSH
52363: LD_VAR 0 7
52367: PPUSH
52368: CALL_OW 314
52372: NOT
52373: AND
52374: IFFALSE 52399
// begin ComExitBuilding ( x ) ;
52376: LD_VAR 0 7
52380: PPUSH
52381: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52385: LD_VAR 0 7
52389: PPUSH
52390: LD_VAR 0 3
52394: PPUSH
52395: CALL_OW 180
// end ;
52399: GO 52350
52401: POP
52402: POP
// end ; end ;
52403: GO 51385
52405: POP
52406: POP
// end ;
52407: GO 51339
52409: POP
52410: POP
// end ;
52411: LD_VAR 0 1
52415: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52416: LD_INT 0
52418: PPUSH
52419: PPUSH
// if not mc_bases then
52420: LD_EXP 113
52424: NOT
52425: IFFALSE 52429
// exit ;
52427: GO 52510
// for i = 1 to mc_bases do
52429: LD_ADDR_VAR 0 2
52433: PUSH
52434: DOUBLE
52435: LD_INT 1
52437: DEC
52438: ST_TO_ADDR
52439: LD_EXP 113
52443: PUSH
52444: FOR_TO
52445: IFFALSE 52508
// if mc_mines [ i ] and mc_miners [ i ] then
52447: LD_EXP 126
52451: PUSH
52452: LD_VAR 0 2
52456: ARRAY
52457: PUSH
52458: LD_EXP 127
52462: PUSH
52463: LD_VAR 0 2
52467: ARRAY
52468: AND
52469: IFFALSE 52506
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52471: LD_EXP 127
52475: PUSH
52476: LD_VAR 0 2
52480: ARRAY
52481: PUSH
52482: LD_INT 1
52484: ARRAY
52485: PPUSH
52486: CALL_OW 255
52490: PPUSH
52491: LD_EXP 126
52495: PUSH
52496: LD_VAR 0 2
52500: ARRAY
52501: PPUSH
52502: CALL 67047 0 2
52506: GO 52444
52508: POP
52509: POP
// end ;
52510: LD_VAR 0 1
52514: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52515: LD_INT 0
52517: PPUSH
52518: PPUSH
52519: PPUSH
52520: PPUSH
52521: PPUSH
52522: PPUSH
52523: PPUSH
52524: PPUSH
// if not mc_bases or not mc_parking then
52525: LD_EXP 113
52529: NOT
52530: PUSH
52531: LD_EXP 137
52535: NOT
52536: OR
52537: IFFALSE 52541
// exit ;
52539: GO 53240
// for i = 1 to mc_bases do
52541: LD_ADDR_VAR 0 2
52545: PUSH
52546: DOUBLE
52547: LD_INT 1
52549: DEC
52550: ST_TO_ADDR
52551: LD_EXP 113
52555: PUSH
52556: FOR_TO
52557: IFFALSE 53238
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52559: LD_EXP 113
52563: PUSH
52564: LD_VAR 0 2
52568: ARRAY
52569: NOT
52570: PUSH
52571: LD_EXP 137
52575: PUSH
52576: LD_VAR 0 2
52580: ARRAY
52581: NOT
52582: OR
52583: IFFALSE 52587
// continue ;
52585: GO 52556
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52587: LD_ADDR_VAR 0 5
52591: PUSH
52592: LD_EXP 113
52596: PUSH
52597: LD_VAR 0 2
52601: ARRAY
52602: PUSH
52603: LD_INT 1
52605: ARRAY
52606: PPUSH
52607: CALL_OW 255
52611: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52612: LD_ADDR_VAR 0 6
52616: PUSH
52617: LD_EXP 113
52621: PUSH
52622: LD_VAR 0 2
52626: ARRAY
52627: PPUSH
52628: LD_INT 30
52630: PUSH
52631: LD_INT 3
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: PPUSH
52638: CALL_OW 72
52642: ST_TO_ADDR
// if not fac then
52643: LD_VAR 0 6
52647: NOT
52648: IFFALSE 52699
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52650: LD_ADDR_VAR 0 6
52654: PUSH
52655: LD_EXP 113
52659: PUSH
52660: LD_VAR 0 2
52664: ARRAY
52665: PPUSH
52666: LD_INT 2
52668: PUSH
52669: LD_INT 30
52671: PUSH
52672: LD_INT 0
52674: PUSH
52675: EMPTY
52676: LIST
52677: LIST
52678: PUSH
52679: LD_INT 30
52681: PUSH
52682: LD_INT 1
52684: PUSH
52685: EMPTY
52686: LIST
52687: LIST
52688: PUSH
52689: EMPTY
52690: LIST
52691: LIST
52692: LIST
52693: PPUSH
52694: CALL_OW 72
52698: ST_TO_ADDR
// if not fac then
52699: LD_VAR 0 6
52703: NOT
52704: IFFALSE 52708
// continue ;
52706: GO 52556
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52708: LD_ADDR_VAR 0 7
52712: PUSH
52713: LD_EXP 137
52717: PUSH
52718: LD_VAR 0 2
52722: ARRAY
52723: PPUSH
52724: LD_INT 22
52726: PUSH
52727: LD_VAR 0 5
52731: PUSH
52732: EMPTY
52733: LIST
52734: LIST
52735: PUSH
52736: LD_INT 21
52738: PUSH
52739: LD_INT 2
52741: PUSH
52742: EMPTY
52743: LIST
52744: LIST
52745: PUSH
52746: LD_INT 3
52748: PUSH
52749: LD_INT 24
52751: PUSH
52752: LD_INT 1000
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PUSH
52759: EMPTY
52760: LIST
52761: LIST
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: LIST
52767: PPUSH
52768: CALL_OW 70
52772: ST_TO_ADDR
// for j in fac do
52773: LD_ADDR_VAR 0 3
52777: PUSH
52778: LD_VAR 0 6
52782: PUSH
52783: FOR_IN
52784: IFFALSE 52865
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52786: LD_ADDR_VAR 0 7
52790: PUSH
52791: LD_VAR 0 7
52795: PUSH
52796: LD_INT 22
52798: PUSH
52799: LD_VAR 0 5
52803: PUSH
52804: EMPTY
52805: LIST
52806: LIST
52807: PUSH
52808: LD_INT 91
52810: PUSH
52811: LD_VAR 0 3
52815: PUSH
52816: LD_INT 15
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: LIST
52823: PUSH
52824: LD_INT 21
52826: PUSH
52827: LD_INT 2
52829: PUSH
52830: EMPTY
52831: LIST
52832: LIST
52833: PUSH
52834: LD_INT 3
52836: PUSH
52837: LD_INT 24
52839: PUSH
52840: LD_INT 1000
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: LIST
52855: LIST
52856: PPUSH
52857: CALL_OW 69
52861: UNION
52862: ST_TO_ADDR
52863: GO 52783
52865: POP
52866: POP
// if not vehs then
52867: LD_VAR 0 7
52871: NOT
52872: IFFALSE 52898
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52874: LD_ADDR_EXP 125
52878: PUSH
52879: LD_EXP 125
52883: PPUSH
52884: LD_VAR 0 2
52888: PPUSH
52889: EMPTY
52890: PPUSH
52891: CALL_OW 1
52895: ST_TO_ADDR
// continue ;
52896: GO 52556
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52898: LD_ADDR_VAR 0 8
52902: PUSH
52903: LD_EXP 113
52907: PUSH
52908: LD_VAR 0 2
52912: ARRAY
52913: PPUSH
52914: LD_INT 30
52916: PUSH
52917: LD_INT 3
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: PPUSH
52924: CALL_OW 72
52928: ST_TO_ADDR
// if tmp then
52929: LD_VAR 0 8
52933: IFFALSE 53036
// begin for j in tmp do
52935: LD_ADDR_VAR 0 3
52939: PUSH
52940: LD_VAR 0 8
52944: PUSH
52945: FOR_IN
52946: IFFALSE 53034
// for k in UnitsInside ( j ) do
52948: LD_ADDR_VAR 0 4
52952: PUSH
52953: LD_VAR 0 3
52957: PPUSH
52958: CALL_OW 313
52962: PUSH
52963: FOR_IN
52964: IFFALSE 53030
// if k then
52966: LD_VAR 0 4
52970: IFFALSE 53028
// if not k in mc_repair_vehicle [ i ] then
52972: LD_VAR 0 4
52976: PUSH
52977: LD_EXP 125
52981: PUSH
52982: LD_VAR 0 2
52986: ARRAY
52987: IN
52988: NOT
52989: IFFALSE 53028
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52991: LD_ADDR_EXP 125
52995: PUSH
52996: LD_EXP 125
53000: PPUSH
53001: LD_VAR 0 2
53005: PPUSH
53006: LD_EXP 125
53010: PUSH
53011: LD_VAR 0 2
53015: ARRAY
53016: PUSH
53017: LD_VAR 0 4
53021: UNION
53022: PPUSH
53023: CALL_OW 1
53027: ST_TO_ADDR
53028: GO 52963
53030: POP
53031: POP
53032: GO 52945
53034: POP
53035: POP
// end ; if not mc_repair_vehicle [ i ] then
53036: LD_EXP 125
53040: PUSH
53041: LD_VAR 0 2
53045: ARRAY
53046: NOT
53047: IFFALSE 53051
// continue ;
53049: GO 52556
// for j in mc_repair_vehicle [ i ] do
53051: LD_ADDR_VAR 0 3
53055: PUSH
53056: LD_EXP 125
53060: PUSH
53061: LD_VAR 0 2
53065: ARRAY
53066: PUSH
53067: FOR_IN
53068: IFFALSE 53234
// begin if GetClass ( j ) <> 3 then
53070: LD_VAR 0 3
53074: PPUSH
53075: CALL_OW 257
53079: PUSH
53080: LD_INT 3
53082: NONEQUAL
53083: IFFALSE 53124
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53085: LD_ADDR_EXP 125
53089: PUSH
53090: LD_EXP 125
53094: PPUSH
53095: LD_VAR 0 2
53099: PPUSH
53100: LD_EXP 125
53104: PUSH
53105: LD_VAR 0 2
53109: ARRAY
53110: PUSH
53111: LD_VAR 0 3
53115: DIFF
53116: PPUSH
53117: CALL_OW 1
53121: ST_TO_ADDR
// continue ;
53122: GO 53067
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53124: LD_VAR 0 3
53128: PPUSH
53129: CALL_OW 311
53133: NOT
53134: PUSH
53135: LD_VAR 0 3
53139: PUSH
53140: LD_EXP 116
53144: PUSH
53145: LD_VAR 0 2
53149: ARRAY
53150: PUSH
53151: LD_INT 1
53153: ARRAY
53154: IN
53155: NOT
53156: AND
53157: PUSH
53158: LD_VAR 0 3
53162: PUSH
53163: LD_EXP 116
53167: PUSH
53168: LD_VAR 0 2
53172: ARRAY
53173: PUSH
53174: LD_INT 2
53176: ARRAY
53177: IN
53178: NOT
53179: AND
53180: IFFALSE 53232
// begin if IsInUnit ( j ) then
53182: LD_VAR 0 3
53186: PPUSH
53187: CALL_OW 310
53191: IFFALSE 53202
// ComExitBuilding ( j ) ;
53193: LD_VAR 0 3
53197: PPUSH
53198: CALL_OW 122
// if not HasTask ( j ) then
53202: LD_VAR 0 3
53206: PPUSH
53207: CALL_OW 314
53211: NOT
53212: IFFALSE 53232
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53214: LD_VAR 0 3
53218: PPUSH
53219: LD_VAR 0 7
53223: PUSH
53224: LD_INT 1
53226: ARRAY
53227: PPUSH
53228: CALL_OW 189
// end ; end ;
53232: GO 53067
53234: POP
53235: POP
// end ;
53236: GO 52556
53238: POP
53239: POP
// end ;
53240: LD_VAR 0 1
53244: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53245: LD_INT 0
53247: PPUSH
53248: PPUSH
53249: PPUSH
53250: PPUSH
53251: PPUSH
53252: PPUSH
53253: PPUSH
53254: PPUSH
53255: PPUSH
53256: PPUSH
53257: PPUSH
// if not mc_bases then
53258: LD_EXP 113
53262: NOT
53263: IFFALSE 53267
// exit ;
53265: GO 54069
// for i = 1 to mc_bases do
53267: LD_ADDR_VAR 0 2
53271: PUSH
53272: DOUBLE
53273: LD_INT 1
53275: DEC
53276: ST_TO_ADDR
53277: LD_EXP 113
53281: PUSH
53282: FOR_TO
53283: IFFALSE 54067
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53285: LD_EXP 141
53289: PUSH
53290: LD_VAR 0 2
53294: ARRAY
53295: NOT
53296: PUSH
53297: LD_EXP 116
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PUSH
53308: LD_INT 1
53310: ARRAY
53311: OR
53312: PUSH
53313: LD_EXP 116
53317: PUSH
53318: LD_VAR 0 2
53322: ARRAY
53323: PUSH
53324: LD_INT 2
53326: ARRAY
53327: OR
53328: PUSH
53329: LD_EXP 139
53333: PUSH
53334: LD_VAR 0 2
53338: ARRAY
53339: PPUSH
53340: LD_INT 1
53342: PPUSH
53343: CALL_OW 325
53347: NOT
53348: OR
53349: PUSH
53350: LD_EXP 136
53354: PUSH
53355: LD_VAR 0 2
53359: ARRAY
53360: OR
53361: IFFALSE 53365
// continue ;
53363: GO 53282
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53365: LD_ADDR_VAR 0 8
53369: PUSH
53370: LD_EXP 113
53374: PUSH
53375: LD_VAR 0 2
53379: ARRAY
53380: PPUSH
53381: LD_INT 25
53383: PUSH
53384: LD_INT 4
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PUSH
53391: LD_INT 50
53393: PUSH
53394: EMPTY
53395: LIST
53396: PUSH
53397: LD_INT 3
53399: PUSH
53400: LD_INT 60
53402: PUSH
53403: EMPTY
53404: LIST
53405: PUSH
53406: EMPTY
53407: LIST
53408: LIST
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: LIST
53414: PPUSH
53415: CALL_OW 72
53419: PUSH
53420: LD_EXP 117
53424: PUSH
53425: LD_VAR 0 2
53429: ARRAY
53430: DIFF
53431: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53432: LD_ADDR_VAR 0 9
53436: PUSH
53437: LD_EXP 113
53441: PUSH
53442: LD_VAR 0 2
53446: ARRAY
53447: PPUSH
53448: LD_INT 2
53450: PUSH
53451: LD_INT 30
53453: PUSH
53454: LD_INT 0
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: PUSH
53461: LD_INT 30
53463: PUSH
53464: LD_INT 1
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: LIST
53475: PPUSH
53476: CALL_OW 72
53480: ST_TO_ADDR
// if not tmp or not dep then
53481: LD_VAR 0 8
53485: NOT
53486: PUSH
53487: LD_VAR 0 9
53491: NOT
53492: OR
53493: IFFALSE 53497
// continue ;
53495: GO 53282
// side := GetSide ( tmp [ 1 ] ) ;
53497: LD_ADDR_VAR 0 11
53501: PUSH
53502: LD_VAR 0 8
53506: PUSH
53507: LD_INT 1
53509: ARRAY
53510: PPUSH
53511: CALL_OW 255
53515: ST_TO_ADDR
// dep := dep [ 1 ] ;
53516: LD_ADDR_VAR 0 9
53520: PUSH
53521: LD_VAR 0 9
53525: PUSH
53526: LD_INT 1
53528: ARRAY
53529: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53530: LD_ADDR_VAR 0 7
53534: PUSH
53535: LD_EXP 141
53539: PUSH
53540: LD_VAR 0 2
53544: ARRAY
53545: PPUSH
53546: LD_INT 22
53548: PUSH
53549: LD_INT 0
53551: PUSH
53552: EMPTY
53553: LIST
53554: LIST
53555: PUSH
53556: LD_INT 25
53558: PUSH
53559: LD_INT 12
53561: PUSH
53562: EMPTY
53563: LIST
53564: LIST
53565: PUSH
53566: EMPTY
53567: LIST
53568: LIST
53569: PPUSH
53570: CALL_OW 70
53574: PUSH
53575: LD_INT 22
53577: PUSH
53578: LD_INT 0
53580: PUSH
53581: EMPTY
53582: LIST
53583: LIST
53584: PUSH
53585: LD_INT 25
53587: PUSH
53588: LD_INT 12
53590: PUSH
53591: EMPTY
53592: LIST
53593: LIST
53594: PUSH
53595: LD_INT 91
53597: PUSH
53598: LD_VAR 0 9
53602: PUSH
53603: LD_INT 20
53605: PUSH
53606: EMPTY
53607: LIST
53608: LIST
53609: LIST
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: LIST
53615: PPUSH
53616: CALL_OW 69
53620: UNION
53621: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53622: LD_ADDR_VAR 0 10
53626: PUSH
53627: LD_EXP 141
53631: PUSH
53632: LD_VAR 0 2
53636: ARRAY
53637: PPUSH
53638: LD_INT 81
53640: PUSH
53641: LD_VAR 0 11
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: PPUSH
53650: CALL_OW 70
53654: ST_TO_ADDR
// if not apes or danger_at_area then
53655: LD_VAR 0 7
53659: NOT
53660: PUSH
53661: LD_VAR 0 10
53665: OR
53666: IFFALSE 53716
// begin if mc_taming [ i ] then
53668: LD_EXP 144
53672: PUSH
53673: LD_VAR 0 2
53677: ARRAY
53678: IFFALSE 53714
// begin MC_Reset ( i , 121 ) ;
53680: LD_VAR 0 2
53684: PPUSH
53685: LD_INT 121
53687: PPUSH
53688: CALL 39167 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53692: LD_ADDR_EXP 144
53696: PUSH
53697: LD_EXP 144
53701: PPUSH
53702: LD_VAR 0 2
53706: PPUSH
53707: EMPTY
53708: PPUSH
53709: CALL_OW 1
53713: ST_TO_ADDR
// end ; continue ;
53714: GO 53282
// end ; for j in tmp do
53716: LD_ADDR_VAR 0 3
53720: PUSH
53721: LD_VAR 0 8
53725: PUSH
53726: FOR_IN
53727: IFFALSE 54063
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53729: LD_VAR 0 3
53733: PUSH
53734: LD_EXP 144
53738: PUSH
53739: LD_VAR 0 2
53743: ARRAY
53744: IN
53745: NOT
53746: PUSH
53747: LD_EXP 144
53751: PUSH
53752: LD_VAR 0 2
53756: ARRAY
53757: PUSH
53758: LD_INT 3
53760: LESS
53761: AND
53762: IFFALSE 53820
// begin SetTag ( j , 121 ) ;
53764: LD_VAR 0 3
53768: PPUSH
53769: LD_INT 121
53771: PPUSH
53772: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53776: LD_ADDR_EXP 144
53780: PUSH
53781: LD_EXP 144
53785: PPUSH
53786: LD_VAR 0 2
53790: PUSH
53791: LD_EXP 144
53795: PUSH
53796: LD_VAR 0 2
53800: ARRAY
53801: PUSH
53802: LD_INT 1
53804: PLUS
53805: PUSH
53806: EMPTY
53807: LIST
53808: LIST
53809: PPUSH
53810: LD_VAR 0 3
53814: PPUSH
53815: CALL 70058 0 3
53819: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53820: LD_VAR 0 3
53824: PUSH
53825: LD_EXP 144
53829: PUSH
53830: LD_VAR 0 2
53834: ARRAY
53835: IN
53836: IFFALSE 54061
// begin if GetClass ( j ) <> 4 then
53838: LD_VAR 0 3
53842: PPUSH
53843: CALL_OW 257
53847: PUSH
53848: LD_INT 4
53850: NONEQUAL
53851: IFFALSE 53904
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53853: LD_ADDR_EXP 144
53857: PUSH
53858: LD_EXP 144
53862: PPUSH
53863: LD_VAR 0 2
53867: PPUSH
53868: LD_EXP 144
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: PUSH
53879: LD_VAR 0 3
53883: DIFF
53884: PPUSH
53885: CALL_OW 1
53889: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53890: LD_VAR 0 3
53894: PPUSH
53895: LD_INT 0
53897: PPUSH
53898: CALL_OW 109
// continue ;
53902: GO 53726
// end ; if IsInUnit ( j ) then
53904: LD_VAR 0 3
53908: PPUSH
53909: CALL_OW 310
53913: IFFALSE 53924
// ComExitBuilding ( j ) ;
53915: LD_VAR 0 3
53919: PPUSH
53920: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53924: LD_ADDR_VAR 0 6
53928: PUSH
53929: LD_VAR 0 7
53933: PPUSH
53934: LD_VAR 0 3
53938: PPUSH
53939: CALL_OW 74
53943: ST_TO_ADDR
// if not ape then
53944: LD_VAR 0 6
53948: NOT
53949: IFFALSE 53953
// break ;
53951: GO 54063
// x := GetX ( ape ) ;
53953: LD_ADDR_VAR 0 4
53957: PUSH
53958: LD_VAR 0 6
53962: PPUSH
53963: CALL_OW 250
53967: ST_TO_ADDR
// y := GetY ( ape ) ;
53968: LD_ADDR_VAR 0 5
53972: PUSH
53973: LD_VAR 0 6
53977: PPUSH
53978: CALL_OW 251
53982: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53983: LD_VAR 0 4
53987: PPUSH
53988: LD_VAR 0 5
53992: PPUSH
53993: CALL_OW 488
53997: NOT
53998: PUSH
53999: LD_VAR 0 11
54003: PPUSH
54004: LD_VAR 0 4
54008: PPUSH
54009: LD_VAR 0 5
54013: PPUSH
54014: LD_INT 20
54016: PPUSH
54017: CALL 70954 0 4
54021: PUSH
54022: LD_INT 4
54024: ARRAY
54025: OR
54026: IFFALSE 54030
// break ;
54028: GO 54063
// if not HasTask ( j ) then
54030: LD_VAR 0 3
54034: PPUSH
54035: CALL_OW 314
54039: NOT
54040: IFFALSE 54061
// ComTameXY ( j , x , y ) ;
54042: LD_VAR 0 3
54046: PPUSH
54047: LD_VAR 0 4
54051: PPUSH
54052: LD_VAR 0 5
54056: PPUSH
54057: CALL_OW 131
// end ; end ;
54061: GO 53726
54063: POP
54064: POP
// end ;
54065: GO 53282
54067: POP
54068: POP
// end ;
54069: LD_VAR 0 1
54073: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54074: LD_INT 0
54076: PPUSH
54077: PPUSH
54078: PPUSH
54079: PPUSH
54080: PPUSH
54081: PPUSH
54082: PPUSH
54083: PPUSH
// if not mc_bases then
54084: LD_EXP 113
54088: NOT
54089: IFFALSE 54093
// exit ;
54091: GO 54719
// for i = 1 to mc_bases do
54093: LD_ADDR_VAR 0 2
54097: PUSH
54098: DOUBLE
54099: LD_INT 1
54101: DEC
54102: ST_TO_ADDR
54103: LD_EXP 113
54107: PUSH
54108: FOR_TO
54109: IFFALSE 54717
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54111: LD_EXP 142
54115: PUSH
54116: LD_VAR 0 2
54120: ARRAY
54121: NOT
54122: PUSH
54123: LD_EXP 142
54127: PUSH
54128: LD_VAR 0 2
54132: ARRAY
54133: PPUSH
54134: LD_INT 25
54136: PUSH
54137: LD_INT 12
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: PPUSH
54144: CALL_OW 72
54148: NOT
54149: OR
54150: IFFALSE 54154
// continue ;
54152: GO 54108
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54154: LD_ADDR_VAR 0 5
54158: PUSH
54159: LD_EXP 142
54163: PUSH
54164: LD_VAR 0 2
54168: ARRAY
54169: PUSH
54170: LD_INT 1
54172: ARRAY
54173: PPUSH
54174: CALL_OW 255
54178: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54179: LD_VAR 0 5
54183: PPUSH
54184: LD_INT 2
54186: PPUSH
54187: CALL_OW 325
54191: IFFALSE 54444
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54193: LD_ADDR_VAR 0 4
54197: PUSH
54198: LD_EXP 142
54202: PUSH
54203: LD_VAR 0 2
54207: ARRAY
54208: PPUSH
54209: LD_INT 25
54211: PUSH
54212: LD_INT 16
54214: PUSH
54215: EMPTY
54216: LIST
54217: LIST
54218: PPUSH
54219: CALL_OW 72
54223: ST_TO_ADDR
// if tmp < 6 then
54224: LD_VAR 0 4
54228: PUSH
54229: LD_INT 6
54231: LESS
54232: IFFALSE 54444
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54234: LD_ADDR_VAR 0 6
54238: PUSH
54239: LD_EXP 113
54243: PUSH
54244: LD_VAR 0 2
54248: ARRAY
54249: PPUSH
54250: LD_INT 2
54252: PUSH
54253: LD_INT 30
54255: PUSH
54256: LD_INT 0
54258: PUSH
54259: EMPTY
54260: LIST
54261: LIST
54262: PUSH
54263: LD_INT 30
54265: PUSH
54266: LD_INT 1
54268: PUSH
54269: EMPTY
54270: LIST
54271: LIST
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: LIST
54277: PPUSH
54278: CALL_OW 72
54282: ST_TO_ADDR
// if depot then
54283: LD_VAR 0 6
54287: IFFALSE 54444
// begin selected := 0 ;
54289: LD_ADDR_VAR 0 7
54293: PUSH
54294: LD_INT 0
54296: ST_TO_ADDR
// for j in depot do
54297: LD_ADDR_VAR 0 3
54301: PUSH
54302: LD_VAR 0 6
54306: PUSH
54307: FOR_IN
54308: IFFALSE 54339
// begin if UnitsInside ( j ) < 6 then
54310: LD_VAR 0 3
54314: PPUSH
54315: CALL_OW 313
54319: PUSH
54320: LD_INT 6
54322: LESS
54323: IFFALSE 54337
// begin selected := j ;
54325: LD_ADDR_VAR 0 7
54329: PUSH
54330: LD_VAR 0 3
54334: ST_TO_ADDR
// break ;
54335: GO 54339
// end ; end ;
54337: GO 54307
54339: POP
54340: POP
// if selected then
54341: LD_VAR 0 7
54345: IFFALSE 54444
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54347: LD_ADDR_VAR 0 3
54351: PUSH
54352: LD_EXP 142
54356: PUSH
54357: LD_VAR 0 2
54361: ARRAY
54362: PPUSH
54363: LD_INT 25
54365: PUSH
54366: LD_INT 12
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: PPUSH
54373: CALL_OW 72
54377: PUSH
54378: FOR_IN
54379: IFFALSE 54442
// if not HasTask ( j ) then
54381: LD_VAR 0 3
54385: PPUSH
54386: CALL_OW 314
54390: NOT
54391: IFFALSE 54440
// begin if not IsInUnit ( j ) then
54393: LD_VAR 0 3
54397: PPUSH
54398: CALL_OW 310
54402: NOT
54403: IFFALSE 54419
// ComEnterUnit ( j , selected ) ;
54405: LD_VAR 0 3
54409: PPUSH
54410: LD_VAR 0 7
54414: PPUSH
54415: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54419: LD_VAR 0 3
54423: PPUSH
54424: LD_INT 16
54426: PPUSH
54427: CALL_OW 183
// AddComExitBuilding ( j ) ;
54431: LD_VAR 0 3
54435: PPUSH
54436: CALL_OW 182
// end ;
54440: GO 54378
54442: POP
54443: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54444: LD_VAR 0 5
54448: PPUSH
54449: LD_INT 11
54451: PPUSH
54452: CALL_OW 325
54456: IFFALSE 54715
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54458: LD_ADDR_VAR 0 4
54462: PUSH
54463: LD_EXP 142
54467: PUSH
54468: LD_VAR 0 2
54472: ARRAY
54473: PPUSH
54474: LD_INT 25
54476: PUSH
54477: LD_INT 16
54479: PUSH
54480: EMPTY
54481: LIST
54482: LIST
54483: PPUSH
54484: CALL_OW 72
54488: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54489: LD_VAR 0 4
54493: PUSH
54494: LD_INT 6
54496: GREATEREQUAL
54497: PUSH
54498: LD_VAR 0 5
54502: PPUSH
54503: LD_INT 2
54505: PPUSH
54506: CALL_OW 325
54510: NOT
54511: OR
54512: IFFALSE 54715
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54514: LD_ADDR_VAR 0 8
54518: PUSH
54519: LD_EXP 113
54523: PUSH
54524: LD_VAR 0 2
54528: ARRAY
54529: PPUSH
54530: LD_INT 2
54532: PUSH
54533: LD_INT 30
54535: PUSH
54536: LD_INT 4
54538: PUSH
54539: EMPTY
54540: LIST
54541: LIST
54542: PUSH
54543: LD_INT 30
54545: PUSH
54546: LD_INT 5
54548: PUSH
54549: EMPTY
54550: LIST
54551: LIST
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: LIST
54557: PPUSH
54558: CALL_OW 72
54562: ST_TO_ADDR
// if barracks then
54563: LD_VAR 0 8
54567: IFFALSE 54715
// begin selected := 0 ;
54569: LD_ADDR_VAR 0 7
54573: PUSH
54574: LD_INT 0
54576: ST_TO_ADDR
// for j in barracks do
54577: LD_ADDR_VAR 0 3
54581: PUSH
54582: LD_VAR 0 8
54586: PUSH
54587: FOR_IN
54588: IFFALSE 54619
// begin if UnitsInside ( j ) < 6 then
54590: LD_VAR 0 3
54594: PPUSH
54595: CALL_OW 313
54599: PUSH
54600: LD_INT 6
54602: LESS
54603: IFFALSE 54617
// begin selected := j ;
54605: LD_ADDR_VAR 0 7
54609: PUSH
54610: LD_VAR 0 3
54614: ST_TO_ADDR
// break ;
54615: GO 54619
// end ; end ;
54617: GO 54587
54619: POP
54620: POP
// if selected then
54621: LD_VAR 0 7
54625: IFFALSE 54715
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54627: LD_ADDR_VAR 0 3
54631: PUSH
54632: LD_EXP 142
54636: PUSH
54637: LD_VAR 0 2
54641: ARRAY
54642: PPUSH
54643: LD_INT 25
54645: PUSH
54646: LD_INT 12
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: PPUSH
54653: CALL_OW 72
54657: PUSH
54658: FOR_IN
54659: IFFALSE 54713
// if not IsInUnit ( j ) and not HasTask ( j ) then
54661: LD_VAR 0 3
54665: PPUSH
54666: CALL_OW 310
54670: NOT
54671: PUSH
54672: LD_VAR 0 3
54676: PPUSH
54677: CALL_OW 314
54681: NOT
54682: AND
54683: IFFALSE 54711
// begin ComEnterUnit ( j , selected ) ;
54685: LD_VAR 0 3
54689: PPUSH
54690: LD_VAR 0 7
54694: PPUSH
54695: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54699: LD_VAR 0 3
54703: PPUSH
54704: LD_INT 15
54706: PPUSH
54707: CALL_OW 183
// end ;
54711: GO 54658
54713: POP
54714: POP
// end ; end ; end ; end ; end ;
54715: GO 54108
54717: POP
54718: POP
// end ;
54719: LD_VAR 0 1
54723: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54724: LD_INT 0
54726: PPUSH
54727: PPUSH
54728: PPUSH
54729: PPUSH
// if not mc_bases then
54730: LD_EXP 113
54734: NOT
54735: IFFALSE 54739
// exit ;
54737: GO 54917
// for i = 1 to mc_bases do
54739: LD_ADDR_VAR 0 2
54743: PUSH
54744: DOUBLE
54745: LD_INT 1
54747: DEC
54748: ST_TO_ADDR
54749: LD_EXP 113
54753: PUSH
54754: FOR_TO
54755: IFFALSE 54915
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54757: LD_ADDR_VAR 0 4
54761: PUSH
54762: LD_EXP 113
54766: PUSH
54767: LD_VAR 0 2
54771: ARRAY
54772: PPUSH
54773: LD_INT 25
54775: PUSH
54776: LD_INT 9
54778: PUSH
54779: EMPTY
54780: LIST
54781: LIST
54782: PPUSH
54783: CALL_OW 72
54787: ST_TO_ADDR
// if not tmp then
54788: LD_VAR 0 4
54792: NOT
54793: IFFALSE 54797
// continue ;
54795: GO 54754
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54797: LD_EXP 139
54801: PUSH
54802: LD_VAR 0 2
54806: ARRAY
54807: PPUSH
54808: LD_INT 29
54810: PPUSH
54811: CALL_OW 325
54815: NOT
54816: PUSH
54817: LD_EXP 139
54821: PUSH
54822: LD_VAR 0 2
54826: ARRAY
54827: PPUSH
54828: LD_INT 28
54830: PPUSH
54831: CALL_OW 325
54835: NOT
54836: AND
54837: IFFALSE 54841
// continue ;
54839: GO 54754
// for j in tmp do
54841: LD_ADDR_VAR 0 3
54845: PUSH
54846: LD_VAR 0 4
54850: PUSH
54851: FOR_IN
54852: IFFALSE 54911
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54854: LD_VAR 0 3
54858: PUSH
54859: LD_EXP 116
54863: PUSH
54864: LD_VAR 0 2
54868: ARRAY
54869: PUSH
54870: LD_INT 1
54872: ARRAY
54873: IN
54874: NOT
54875: PUSH
54876: LD_VAR 0 3
54880: PUSH
54881: LD_EXP 116
54885: PUSH
54886: LD_VAR 0 2
54890: ARRAY
54891: PUSH
54892: LD_INT 2
54894: ARRAY
54895: IN
54896: NOT
54897: AND
54898: IFFALSE 54909
// ComSpaceTimeShoot ( j ) ;
54900: LD_VAR 0 3
54904: PPUSH
54905: CALL 66055 0 1
54909: GO 54851
54911: POP
54912: POP
// end ;
54913: GO 54754
54915: POP
54916: POP
// end ;
54917: LD_VAR 0 1
54921: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54922: LD_INT 0
54924: PPUSH
54925: PPUSH
54926: PPUSH
54927: PPUSH
54928: PPUSH
54929: PPUSH
54930: PPUSH
54931: PPUSH
54932: PPUSH
// if not mc_bases then
54933: LD_EXP 113
54937: NOT
54938: IFFALSE 54942
// exit ;
54940: GO 55564
// for i = 1 to mc_bases do
54942: LD_ADDR_VAR 0 2
54946: PUSH
54947: DOUBLE
54948: LD_INT 1
54950: DEC
54951: ST_TO_ADDR
54952: LD_EXP 113
54956: PUSH
54957: FOR_TO
54958: IFFALSE 55562
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54960: LD_EXP 148
54964: PUSH
54965: LD_VAR 0 2
54969: ARRAY
54970: NOT
54971: PUSH
54972: LD_INT 38
54974: PPUSH
54975: LD_EXP 139
54979: PUSH
54980: LD_VAR 0 2
54984: ARRAY
54985: PPUSH
54986: CALL_OW 321
54990: PUSH
54991: LD_INT 2
54993: NONEQUAL
54994: OR
54995: IFFALSE 54999
// continue ;
54997: GO 54957
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54999: LD_ADDR_VAR 0 8
55003: PUSH
55004: LD_EXP 113
55008: PUSH
55009: LD_VAR 0 2
55013: ARRAY
55014: PPUSH
55015: LD_INT 30
55017: PUSH
55018: LD_INT 34
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: PPUSH
55025: CALL_OW 72
55029: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55030: LD_ADDR_VAR 0 9
55034: PUSH
55035: LD_EXP 113
55039: PUSH
55040: LD_VAR 0 2
55044: ARRAY
55045: PPUSH
55046: LD_INT 25
55048: PUSH
55049: LD_INT 4
55051: PUSH
55052: EMPTY
55053: LIST
55054: LIST
55055: PPUSH
55056: CALL_OW 72
55060: PPUSH
55061: LD_INT 0
55063: PPUSH
55064: CALL 98619 0 2
55068: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55069: LD_VAR 0 9
55073: NOT
55074: PUSH
55075: LD_VAR 0 8
55079: NOT
55080: OR
55081: PUSH
55082: LD_EXP 113
55086: PUSH
55087: LD_VAR 0 2
55091: ARRAY
55092: PPUSH
55093: LD_INT 124
55095: PPUSH
55096: CALL 98619 0 2
55100: OR
55101: IFFALSE 55105
// continue ;
55103: GO 54957
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55105: LD_EXP 149
55109: PUSH
55110: LD_VAR 0 2
55114: ARRAY
55115: PUSH
55116: LD_EXP 148
55120: PUSH
55121: LD_VAR 0 2
55125: ARRAY
55126: LESS
55127: PUSH
55128: LD_EXP 149
55132: PUSH
55133: LD_VAR 0 2
55137: ARRAY
55138: PUSH
55139: LD_VAR 0 8
55143: LESS
55144: AND
55145: IFFALSE 55560
// begin tmp := sci [ 1 ] ;
55147: LD_ADDR_VAR 0 7
55151: PUSH
55152: LD_VAR 0 9
55156: PUSH
55157: LD_INT 1
55159: ARRAY
55160: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55161: LD_VAR 0 7
55165: PPUSH
55166: LD_INT 124
55168: PPUSH
55169: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55173: LD_ADDR_VAR 0 3
55177: PUSH
55178: DOUBLE
55179: LD_EXP 148
55183: PUSH
55184: LD_VAR 0 2
55188: ARRAY
55189: INC
55190: ST_TO_ADDR
55191: LD_EXP 148
55195: PUSH
55196: LD_VAR 0 2
55200: ARRAY
55201: PUSH
55202: FOR_DOWNTO
55203: IFFALSE 55546
// begin if IsInUnit ( tmp ) then
55205: LD_VAR 0 7
55209: PPUSH
55210: CALL_OW 310
55214: IFFALSE 55225
// ComExitBuilding ( tmp ) ;
55216: LD_VAR 0 7
55220: PPUSH
55221: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55225: LD_INT 35
55227: PPUSH
55228: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55232: LD_VAR 0 7
55236: PPUSH
55237: CALL_OW 310
55241: NOT
55242: PUSH
55243: LD_VAR 0 7
55247: PPUSH
55248: CALL_OW 314
55252: NOT
55253: AND
55254: IFFALSE 55225
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55256: LD_ADDR_VAR 0 6
55260: PUSH
55261: LD_VAR 0 7
55265: PPUSH
55266: CALL_OW 250
55270: PUSH
55271: LD_VAR 0 7
55275: PPUSH
55276: CALL_OW 251
55280: PUSH
55281: EMPTY
55282: LIST
55283: LIST
55284: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55285: LD_INT 35
55287: PPUSH
55288: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55292: LD_ADDR_VAR 0 4
55296: PUSH
55297: LD_EXP 148
55301: PUSH
55302: LD_VAR 0 2
55306: ARRAY
55307: PUSH
55308: LD_VAR 0 3
55312: ARRAY
55313: PUSH
55314: LD_INT 1
55316: ARRAY
55317: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55318: LD_ADDR_VAR 0 5
55322: PUSH
55323: LD_EXP 148
55327: PUSH
55328: LD_VAR 0 2
55332: ARRAY
55333: PUSH
55334: LD_VAR 0 3
55338: ARRAY
55339: PUSH
55340: LD_INT 2
55342: ARRAY
55343: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55344: LD_VAR 0 7
55348: PPUSH
55349: LD_INT 10
55351: PPUSH
55352: CALL 72651 0 2
55356: PUSH
55357: LD_INT 4
55359: ARRAY
55360: IFFALSE 55398
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55362: LD_VAR 0 7
55366: PPUSH
55367: LD_VAR 0 6
55371: PUSH
55372: LD_INT 1
55374: ARRAY
55375: PPUSH
55376: LD_VAR 0 6
55380: PUSH
55381: LD_INT 2
55383: ARRAY
55384: PPUSH
55385: CALL_OW 111
// wait ( 0 0$10 ) ;
55389: LD_INT 350
55391: PPUSH
55392: CALL_OW 67
// end else
55396: GO 55424
// begin ComMoveXY ( tmp , x , y ) ;
55398: LD_VAR 0 7
55402: PPUSH
55403: LD_VAR 0 4
55407: PPUSH
55408: LD_VAR 0 5
55412: PPUSH
55413: CALL_OW 111
// wait ( 0 0$3 ) ;
55417: LD_INT 105
55419: PPUSH
55420: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55424: LD_VAR 0 7
55428: PPUSH
55429: LD_VAR 0 4
55433: PPUSH
55434: LD_VAR 0 5
55438: PPUSH
55439: CALL_OW 307
55443: IFFALSE 55285
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55445: LD_VAR 0 7
55449: PPUSH
55450: LD_VAR 0 4
55454: PPUSH
55455: LD_VAR 0 5
55459: PPUSH
55460: LD_VAR 0 8
55464: PUSH
55465: LD_VAR 0 3
55469: ARRAY
55470: PPUSH
55471: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55475: LD_INT 35
55477: PPUSH
55478: CALL_OW 67
// until not HasTask ( tmp ) ;
55482: LD_VAR 0 7
55486: PPUSH
55487: CALL_OW 314
55491: NOT
55492: IFFALSE 55475
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55494: LD_ADDR_EXP 149
55498: PUSH
55499: LD_EXP 149
55503: PPUSH
55504: LD_VAR 0 2
55508: PUSH
55509: LD_EXP 149
55513: PUSH
55514: LD_VAR 0 2
55518: ARRAY
55519: PUSH
55520: LD_INT 1
55522: PLUS
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: PPUSH
55528: LD_VAR 0 8
55532: PUSH
55533: LD_VAR 0 3
55537: ARRAY
55538: PPUSH
55539: CALL 70058 0 3
55543: ST_TO_ADDR
// end ;
55544: GO 55202
55546: POP
55547: POP
// MC_Reset ( i , 124 ) ;
55548: LD_VAR 0 2
55552: PPUSH
55553: LD_INT 124
55555: PPUSH
55556: CALL 39167 0 2
// end ; end ;
55560: GO 54957
55562: POP
55563: POP
// end ;
55564: LD_VAR 0 1
55568: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55569: LD_INT 0
55571: PPUSH
55572: PPUSH
55573: PPUSH
// if not mc_bases then
55574: LD_EXP 113
55578: NOT
55579: IFFALSE 55583
// exit ;
55581: GO 56189
// for i = 1 to mc_bases do
55583: LD_ADDR_VAR 0 2
55587: PUSH
55588: DOUBLE
55589: LD_INT 1
55591: DEC
55592: ST_TO_ADDR
55593: LD_EXP 113
55597: PUSH
55598: FOR_TO
55599: IFFALSE 56187
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55601: LD_ADDR_VAR 0 3
55605: PUSH
55606: LD_EXP 113
55610: PUSH
55611: LD_VAR 0 2
55615: ARRAY
55616: PPUSH
55617: LD_INT 25
55619: PUSH
55620: LD_INT 4
55622: PUSH
55623: EMPTY
55624: LIST
55625: LIST
55626: PPUSH
55627: CALL_OW 72
55631: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55632: LD_VAR 0 3
55636: NOT
55637: PUSH
55638: LD_EXP 150
55642: PUSH
55643: LD_VAR 0 2
55647: ARRAY
55648: NOT
55649: OR
55650: PUSH
55651: LD_EXP 113
55655: PUSH
55656: LD_VAR 0 2
55660: ARRAY
55661: PPUSH
55662: LD_INT 2
55664: PUSH
55665: LD_INT 30
55667: PUSH
55668: LD_INT 0
55670: PUSH
55671: EMPTY
55672: LIST
55673: LIST
55674: PUSH
55675: LD_INT 30
55677: PUSH
55678: LD_INT 1
55680: PUSH
55681: EMPTY
55682: LIST
55683: LIST
55684: PUSH
55685: EMPTY
55686: LIST
55687: LIST
55688: LIST
55689: PPUSH
55690: CALL_OW 72
55694: NOT
55695: OR
55696: IFFALSE 55746
// begin if mc_deposits_finder [ i ] then
55698: LD_EXP 151
55702: PUSH
55703: LD_VAR 0 2
55707: ARRAY
55708: IFFALSE 55744
// begin MC_Reset ( i , 125 ) ;
55710: LD_VAR 0 2
55714: PPUSH
55715: LD_INT 125
55717: PPUSH
55718: CALL 39167 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55722: LD_ADDR_EXP 151
55726: PUSH
55727: LD_EXP 151
55731: PPUSH
55732: LD_VAR 0 2
55736: PPUSH
55737: EMPTY
55738: PPUSH
55739: CALL_OW 1
55743: ST_TO_ADDR
// end ; continue ;
55744: GO 55598
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55746: LD_EXP 150
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PUSH
55757: LD_INT 1
55759: ARRAY
55760: PUSH
55761: LD_INT 3
55763: ARRAY
55764: PUSH
55765: LD_INT 1
55767: EQUAL
55768: PUSH
55769: LD_INT 20
55771: PPUSH
55772: LD_EXP 139
55776: PUSH
55777: LD_VAR 0 2
55781: ARRAY
55782: PPUSH
55783: CALL_OW 321
55787: PUSH
55788: LD_INT 2
55790: NONEQUAL
55791: AND
55792: IFFALSE 55842
// begin if mc_deposits_finder [ i ] then
55794: LD_EXP 151
55798: PUSH
55799: LD_VAR 0 2
55803: ARRAY
55804: IFFALSE 55840
// begin MC_Reset ( i , 125 ) ;
55806: LD_VAR 0 2
55810: PPUSH
55811: LD_INT 125
55813: PPUSH
55814: CALL 39167 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55818: LD_ADDR_EXP 151
55822: PUSH
55823: LD_EXP 151
55827: PPUSH
55828: LD_VAR 0 2
55832: PPUSH
55833: EMPTY
55834: PPUSH
55835: CALL_OW 1
55839: ST_TO_ADDR
// end ; continue ;
55840: GO 55598
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55842: LD_EXP 150
55846: PUSH
55847: LD_VAR 0 2
55851: ARRAY
55852: PUSH
55853: LD_INT 1
55855: ARRAY
55856: PUSH
55857: LD_INT 1
55859: ARRAY
55860: PPUSH
55861: LD_EXP 150
55865: PUSH
55866: LD_VAR 0 2
55870: ARRAY
55871: PUSH
55872: LD_INT 1
55874: ARRAY
55875: PUSH
55876: LD_INT 2
55878: ARRAY
55879: PPUSH
55880: LD_EXP 139
55884: PUSH
55885: LD_VAR 0 2
55889: ARRAY
55890: PPUSH
55891: CALL_OW 440
55895: IFFALSE 55938
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55897: LD_ADDR_EXP 150
55901: PUSH
55902: LD_EXP 150
55906: PPUSH
55907: LD_VAR 0 2
55911: PPUSH
55912: LD_EXP 150
55916: PUSH
55917: LD_VAR 0 2
55921: ARRAY
55922: PPUSH
55923: LD_INT 1
55925: PPUSH
55926: CALL_OW 3
55930: PPUSH
55931: CALL_OW 1
55935: ST_TO_ADDR
55936: GO 56185
// begin if not mc_deposits_finder [ i ] then
55938: LD_EXP 151
55942: PUSH
55943: LD_VAR 0 2
55947: ARRAY
55948: NOT
55949: IFFALSE 56001
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55951: LD_ADDR_EXP 151
55955: PUSH
55956: LD_EXP 151
55960: PPUSH
55961: LD_VAR 0 2
55965: PPUSH
55966: LD_VAR 0 3
55970: PUSH
55971: LD_INT 1
55973: ARRAY
55974: PUSH
55975: EMPTY
55976: LIST
55977: PPUSH
55978: CALL_OW 1
55982: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55983: LD_VAR 0 3
55987: PUSH
55988: LD_INT 1
55990: ARRAY
55991: PPUSH
55992: LD_INT 125
55994: PPUSH
55995: CALL_OW 109
// end else
55999: GO 56185
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56001: LD_EXP 151
56005: PUSH
56006: LD_VAR 0 2
56010: ARRAY
56011: PUSH
56012: LD_INT 1
56014: ARRAY
56015: PPUSH
56016: CALL_OW 310
56020: IFFALSE 56043
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56022: LD_EXP 151
56026: PUSH
56027: LD_VAR 0 2
56031: ARRAY
56032: PUSH
56033: LD_INT 1
56035: ARRAY
56036: PPUSH
56037: CALL_OW 122
56041: GO 56185
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56043: LD_EXP 151
56047: PUSH
56048: LD_VAR 0 2
56052: ARRAY
56053: PUSH
56054: LD_INT 1
56056: ARRAY
56057: PPUSH
56058: CALL_OW 314
56062: NOT
56063: PUSH
56064: LD_EXP 151
56068: PUSH
56069: LD_VAR 0 2
56073: ARRAY
56074: PUSH
56075: LD_INT 1
56077: ARRAY
56078: PPUSH
56079: LD_EXP 150
56083: PUSH
56084: LD_VAR 0 2
56088: ARRAY
56089: PUSH
56090: LD_INT 1
56092: ARRAY
56093: PUSH
56094: LD_INT 1
56096: ARRAY
56097: PPUSH
56098: LD_EXP 150
56102: PUSH
56103: LD_VAR 0 2
56107: ARRAY
56108: PUSH
56109: LD_INT 1
56111: ARRAY
56112: PUSH
56113: LD_INT 2
56115: ARRAY
56116: PPUSH
56117: CALL_OW 297
56121: PUSH
56122: LD_INT 6
56124: GREATER
56125: AND
56126: IFFALSE 56185
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56128: LD_EXP 151
56132: PUSH
56133: LD_VAR 0 2
56137: ARRAY
56138: PUSH
56139: LD_INT 1
56141: ARRAY
56142: PPUSH
56143: LD_EXP 150
56147: PUSH
56148: LD_VAR 0 2
56152: ARRAY
56153: PUSH
56154: LD_INT 1
56156: ARRAY
56157: PUSH
56158: LD_INT 1
56160: ARRAY
56161: PPUSH
56162: LD_EXP 150
56166: PUSH
56167: LD_VAR 0 2
56171: ARRAY
56172: PUSH
56173: LD_INT 1
56175: ARRAY
56176: PUSH
56177: LD_INT 2
56179: ARRAY
56180: PPUSH
56181: CALL_OW 111
// end ; end ; end ;
56185: GO 55598
56187: POP
56188: POP
// end ;
56189: LD_VAR 0 1
56193: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56194: LD_INT 0
56196: PPUSH
56197: PPUSH
56198: PPUSH
56199: PPUSH
56200: PPUSH
56201: PPUSH
56202: PPUSH
56203: PPUSH
56204: PPUSH
56205: PPUSH
56206: PPUSH
// if not mc_bases then
56207: LD_EXP 113
56211: NOT
56212: IFFALSE 56216
// exit ;
56214: GO 57156
// for i = 1 to mc_bases do
56216: LD_ADDR_VAR 0 2
56220: PUSH
56221: DOUBLE
56222: LD_INT 1
56224: DEC
56225: ST_TO_ADDR
56226: LD_EXP 113
56230: PUSH
56231: FOR_TO
56232: IFFALSE 57154
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56234: LD_EXP 113
56238: PUSH
56239: LD_VAR 0 2
56243: ARRAY
56244: NOT
56245: PUSH
56246: LD_EXP 136
56250: PUSH
56251: LD_VAR 0 2
56255: ARRAY
56256: OR
56257: IFFALSE 56261
// continue ;
56259: GO 56231
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56261: LD_ADDR_VAR 0 7
56265: PUSH
56266: LD_EXP 113
56270: PUSH
56271: LD_VAR 0 2
56275: ARRAY
56276: PUSH
56277: LD_INT 1
56279: ARRAY
56280: PPUSH
56281: CALL_OW 248
56285: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56286: LD_VAR 0 7
56290: PUSH
56291: LD_INT 3
56293: EQUAL
56294: PUSH
56295: LD_EXP 132
56299: PUSH
56300: LD_VAR 0 2
56304: ARRAY
56305: PUSH
56306: LD_EXP 135
56310: PUSH
56311: LD_VAR 0 2
56315: ARRAY
56316: UNION
56317: PPUSH
56318: LD_INT 33
56320: PUSH
56321: LD_INT 2
56323: PUSH
56324: EMPTY
56325: LIST
56326: LIST
56327: PPUSH
56328: CALL_OW 72
56332: NOT
56333: OR
56334: IFFALSE 56338
// continue ;
56336: GO 56231
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56338: LD_ADDR_VAR 0 9
56342: PUSH
56343: LD_EXP 113
56347: PUSH
56348: LD_VAR 0 2
56352: ARRAY
56353: PPUSH
56354: LD_INT 30
56356: PUSH
56357: LD_INT 36
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: PPUSH
56364: CALL_OW 72
56368: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56369: LD_ADDR_VAR 0 10
56373: PUSH
56374: LD_EXP 132
56378: PUSH
56379: LD_VAR 0 2
56383: ARRAY
56384: PPUSH
56385: LD_INT 34
56387: PUSH
56388: LD_INT 31
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PPUSH
56395: CALL_OW 72
56399: ST_TO_ADDR
// if not cts and not mcts then
56400: LD_VAR 0 9
56404: NOT
56405: PUSH
56406: LD_VAR 0 10
56410: NOT
56411: AND
56412: IFFALSE 56416
// continue ;
56414: GO 56231
// x := cts ;
56416: LD_ADDR_VAR 0 11
56420: PUSH
56421: LD_VAR 0 9
56425: ST_TO_ADDR
// if not x then
56426: LD_VAR 0 11
56430: NOT
56431: IFFALSE 56443
// x := mcts ;
56433: LD_ADDR_VAR 0 11
56437: PUSH
56438: LD_VAR 0 10
56442: ST_TO_ADDR
// if not x then
56443: LD_VAR 0 11
56447: NOT
56448: IFFALSE 56452
// continue ;
56450: GO 56231
// if mc_remote_driver [ i ] then
56452: LD_EXP 153
56456: PUSH
56457: LD_VAR 0 2
56461: ARRAY
56462: IFFALSE 56849
// for j in mc_remote_driver [ i ] do
56464: LD_ADDR_VAR 0 3
56468: PUSH
56469: LD_EXP 153
56473: PUSH
56474: LD_VAR 0 2
56478: ARRAY
56479: PUSH
56480: FOR_IN
56481: IFFALSE 56847
// begin if GetClass ( j ) <> 3 then
56483: LD_VAR 0 3
56487: PPUSH
56488: CALL_OW 257
56492: PUSH
56493: LD_INT 3
56495: NONEQUAL
56496: IFFALSE 56549
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56498: LD_ADDR_EXP 153
56502: PUSH
56503: LD_EXP 153
56507: PPUSH
56508: LD_VAR 0 2
56512: PPUSH
56513: LD_EXP 153
56517: PUSH
56518: LD_VAR 0 2
56522: ARRAY
56523: PUSH
56524: LD_VAR 0 3
56528: DIFF
56529: PPUSH
56530: CALL_OW 1
56534: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56535: LD_VAR 0 3
56539: PPUSH
56540: LD_INT 0
56542: PPUSH
56543: CALL_OW 109
// continue ;
56547: GO 56480
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56549: LD_EXP 132
56553: PUSH
56554: LD_VAR 0 2
56558: ARRAY
56559: PPUSH
56560: LD_INT 34
56562: PUSH
56563: LD_INT 31
56565: PUSH
56566: EMPTY
56567: LIST
56568: LIST
56569: PUSH
56570: LD_INT 58
56572: PUSH
56573: EMPTY
56574: LIST
56575: PUSH
56576: EMPTY
56577: LIST
56578: LIST
56579: PPUSH
56580: CALL_OW 72
56584: PUSH
56585: LD_VAR 0 3
56589: PPUSH
56590: CALL 98707 0 1
56594: NOT
56595: AND
56596: IFFALSE 56667
// begin if IsInUnit ( j ) then
56598: LD_VAR 0 3
56602: PPUSH
56603: CALL_OW 310
56607: IFFALSE 56618
// ComExitBuilding ( j ) ;
56609: LD_VAR 0 3
56613: PPUSH
56614: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56618: LD_VAR 0 3
56622: PPUSH
56623: LD_EXP 132
56627: PUSH
56628: LD_VAR 0 2
56632: ARRAY
56633: PPUSH
56634: LD_INT 34
56636: PUSH
56637: LD_INT 31
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: PUSH
56644: LD_INT 58
56646: PUSH
56647: EMPTY
56648: LIST
56649: PUSH
56650: EMPTY
56651: LIST
56652: LIST
56653: PPUSH
56654: CALL_OW 72
56658: PUSH
56659: LD_INT 1
56661: ARRAY
56662: PPUSH
56663: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56667: LD_VAR 0 3
56671: PPUSH
56672: CALL_OW 310
56676: NOT
56677: PUSH
56678: LD_VAR 0 3
56682: PPUSH
56683: CALL_OW 310
56687: PPUSH
56688: CALL_OW 266
56692: PUSH
56693: LD_INT 36
56695: NONEQUAL
56696: PUSH
56697: LD_VAR 0 3
56701: PPUSH
56702: CALL 98707 0 1
56706: NOT
56707: AND
56708: OR
56709: IFFALSE 56845
// begin if IsInUnit ( j ) then
56711: LD_VAR 0 3
56715: PPUSH
56716: CALL_OW 310
56720: IFFALSE 56731
// ComExitBuilding ( j ) ;
56722: LD_VAR 0 3
56726: PPUSH
56727: CALL_OW 122
// ct := 0 ;
56731: LD_ADDR_VAR 0 8
56735: PUSH
56736: LD_INT 0
56738: ST_TO_ADDR
// for k in x do
56739: LD_ADDR_VAR 0 4
56743: PUSH
56744: LD_VAR 0 11
56748: PUSH
56749: FOR_IN
56750: IFFALSE 56823
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56752: LD_VAR 0 4
56756: PPUSH
56757: CALL_OW 264
56761: PUSH
56762: LD_INT 31
56764: EQUAL
56765: PUSH
56766: LD_VAR 0 4
56770: PPUSH
56771: CALL_OW 311
56775: NOT
56776: AND
56777: PUSH
56778: LD_VAR 0 4
56782: PPUSH
56783: CALL_OW 266
56787: PUSH
56788: LD_INT 36
56790: EQUAL
56791: PUSH
56792: LD_VAR 0 4
56796: PPUSH
56797: CALL_OW 313
56801: PUSH
56802: LD_INT 3
56804: LESS
56805: AND
56806: OR
56807: IFFALSE 56821
// begin ct := k ;
56809: LD_ADDR_VAR 0 8
56813: PUSH
56814: LD_VAR 0 4
56818: ST_TO_ADDR
// break ;
56819: GO 56823
// end ;
56821: GO 56749
56823: POP
56824: POP
// if ct then
56825: LD_VAR 0 8
56829: IFFALSE 56845
// ComEnterUnit ( j , ct ) ;
56831: LD_VAR 0 3
56835: PPUSH
56836: LD_VAR 0 8
56840: PPUSH
56841: CALL_OW 120
// end ; end ;
56845: GO 56480
56847: POP
56848: POP
// places := 0 ;
56849: LD_ADDR_VAR 0 5
56853: PUSH
56854: LD_INT 0
56856: ST_TO_ADDR
// for j = 1 to x do
56857: LD_ADDR_VAR 0 3
56861: PUSH
56862: DOUBLE
56863: LD_INT 1
56865: DEC
56866: ST_TO_ADDR
56867: LD_VAR 0 11
56871: PUSH
56872: FOR_TO
56873: IFFALSE 56949
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56875: LD_VAR 0 11
56879: PUSH
56880: LD_VAR 0 3
56884: ARRAY
56885: PPUSH
56886: CALL_OW 264
56890: PUSH
56891: LD_INT 31
56893: EQUAL
56894: IFFALSE 56912
// places := places + 1 else
56896: LD_ADDR_VAR 0 5
56900: PUSH
56901: LD_VAR 0 5
56905: PUSH
56906: LD_INT 1
56908: PLUS
56909: ST_TO_ADDR
56910: GO 56947
// if GetBType ( x [ j ] ) = b_control_tower then
56912: LD_VAR 0 11
56916: PUSH
56917: LD_VAR 0 3
56921: ARRAY
56922: PPUSH
56923: CALL_OW 266
56927: PUSH
56928: LD_INT 36
56930: EQUAL
56931: IFFALSE 56947
// places := places + 3 ;
56933: LD_ADDR_VAR 0 5
56937: PUSH
56938: LD_VAR 0 5
56942: PUSH
56943: LD_INT 3
56945: PLUS
56946: ST_TO_ADDR
56947: GO 56872
56949: POP
56950: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56951: LD_VAR 0 5
56955: PUSH
56956: LD_INT 0
56958: EQUAL
56959: PUSH
56960: LD_VAR 0 5
56964: PUSH
56965: LD_EXP 153
56969: PUSH
56970: LD_VAR 0 2
56974: ARRAY
56975: LESSEQUAL
56976: OR
56977: IFFALSE 56981
// continue ;
56979: GO 56231
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56981: LD_ADDR_VAR 0 6
56985: PUSH
56986: LD_EXP 113
56990: PUSH
56991: LD_VAR 0 2
56995: ARRAY
56996: PPUSH
56997: LD_INT 25
56999: PUSH
57000: LD_INT 3
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: PPUSH
57007: CALL_OW 72
57011: PUSH
57012: LD_EXP 153
57016: PUSH
57017: LD_VAR 0 2
57021: ARRAY
57022: DIFF
57023: PPUSH
57024: LD_INT 3
57026: PPUSH
57027: CALL 99607 0 2
57031: ST_TO_ADDR
// for j in tmp do
57032: LD_ADDR_VAR 0 3
57036: PUSH
57037: LD_VAR 0 6
57041: PUSH
57042: FOR_IN
57043: IFFALSE 57078
// if GetTag ( j ) > 0 then
57045: LD_VAR 0 3
57049: PPUSH
57050: CALL_OW 110
57054: PUSH
57055: LD_INT 0
57057: GREATER
57058: IFFALSE 57076
// tmp := tmp diff j ;
57060: LD_ADDR_VAR 0 6
57064: PUSH
57065: LD_VAR 0 6
57069: PUSH
57070: LD_VAR 0 3
57074: DIFF
57075: ST_TO_ADDR
57076: GO 57042
57078: POP
57079: POP
// if not tmp then
57080: LD_VAR 0 6
57084: NOT
57085: IFFALSE 57089
// continue ;
57087: GO 56231
// if places then
57089: LD_VAR 0 5
57093: IFFALSE 57152
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57095: LD_ADDR_EXP 153
57099: PUSH
57100: LD_EXP 153
57104: PPUSH
57105: LD_VAR 0 2
57109: PPUSH
57110: LD_EXP 153
57114: PUSH
57115: LD_VAR 0 2
57119: ARRAY
57120: PUSH
57121: LD_VAR 0 6
57125: PUSH
57126: LD_INT 1
57128: ARRAY
57129: UNION
57130: PPUSH
57131: CALL_OW 1
57135: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57136: LD_VAR 0 6
57140: PUSH
57141: LD_INT 1
57143: ARRAY
57144: PPUSH
57145: LD_INT 126
57147: PPUSH
57148: CALL_OW 109
// end ; end ;
57152: GO 56231
57154: POP
57155: POP
// end ;
57156: LD_VAR 0 1
57160: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57161: LD_INT 0
57163: PPUSH
57164: PPUSH
57165: PPUSH
57166: PPUSH
57167: PPUSH
57168: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57169: LD_VAR 0 1
57173: NOT
57174: PUSH
57175: LD_VAR 0 2
57179: NOT
57180: OR
57181: PUSH
57182: LD_VAR 0 3
57186: NOT
57187: OR
57188: PUSH
57189: LD_VAR 0 4
57193: PUSH
57194: LD_INT 1
57196: PUSH
57197: LD_INT 2
57199: PUSH
57200: LD_INT 3
57202: PUSH
57203: LD_INT 4
57205: PUSH
57206: LD_INT 5
57208: PUSH
57209: LD_INT 8
57211: PUSH
57212: LD_INT 9
57214: PUSH
57215: LD_INT 15
57217: PUSH
57218: LD_INT 16
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: LIST
57225: LIST
57226: LIST
57227: LIST
57228: LIST
57229: LIST
57230: LIST
57231: IN
57232: NOT
57233: OR
57234: IFFALSE 57238
// exit ;
57236: GO 58138
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57238: LD_ADDR_VAR 0 2
57242: PUSH
57243: LD_VAR 0 2
57247: PPUSH
57248: LD_INT 21
57250: PUSH
57251: LD_INT 3
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: PUSH
57258: LD_INT 24
57260: PUSH
57261: LD_INT 250
57263: PUSH
57264: EMPTY
57265: LIST
57266: LIST
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PPUSH
57272: CALL_OW 72
57276: ST_TO_ADDR
// case class of 1 , 15 :
57277: LD_VAR 0 4
57281: PUSH
57282: LD_INT 1
57284: DOUBLE
57285: EQUAL
57286: IFTRUE 57296
57288: LD_INT 15
57290: DOUBLE
57291: EQUAL
57292: IFTRUE 57296
57294: GO 57381
57296: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57297: LD_ADDR_VAR 0 8
57301: PUSH
57302: LD_VAR 0 2
57306: PPUSH
57307: LD_INT 2
57309: PUSH
57310: LD_INT 30
57312: PUSH
57313: LD_INT 32
57315: PUSH
57316: EMPTY
57317: LIST
57318: LIST
57319: PUSH
57320: LD_INT 30
57322: PUSH
57323: LD_INT 31
57325: PUSH
57326: EMPTY
57327: LIST
57328: LIST
57329: PUSH
57330: EMPTY
57331: LIST
57332: LIST
57333: LIST
57334: PPUSH
57335: CALL_OW 72
57339: PUSH
57340: LD_VAR 0 2
57344: PPUSH
57345: LD_INT 2
57347: PUSH
57348: LD_INT 30
57350: PUSH
57351: LD_INT 4
57353: PUSH
57354: EMPTY
57355: LIST
57356: LIST
57357: PUSH
57358: LD_INT 30
57360: PUSH
57361: LD_INT 5
57363: PUSH
57364: EMPTY
57365: LIST
57366: LIST
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: LIST
57372: PPUSH
57373: CALL_OW 72
57377: ADD
57378: ST_TO_ADDR
57379: GO 57627
57381: LD_INT 2
57383: DOUBLE
57384: EQUAL
57385: IFTRUE 57395
57387: LD_INT 16
57389: DOUBLE
57390: EQUAL
57391: IFTRUE 57395
57393: GO 57441
57395: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57396: LD_ADDR_VAR 0 8
57400: PUSH
57401: LD_VAR 0 2
57405: PPUSH
57406: LD_INT 2
57408: PUSH
57409: LD_INT 30
57411: PUSH
57412: LD_INT 0
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PUSH
57419: LD_INT 30
57421: PUSH
57422: LD_INT 1
57424: PUSH
57425: EMPTY
57426: LIST
57427: LIST
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: LIST
57433: PPUSH
57434: CALL_OW 72
57438: ST_TO_ADDR
57439: GO 57627
57441: LD_INT 3
57443: DOUBLE
57444: EQUAL
57445: IFTRUE 57449
57447: GO 57495
57449: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57450: LD_ADDR_VAR 0 8
57454: PUSH
57455: LD_VAR 0 2
57459: PPUSH
57460: LD_INT 2
57462: PUSH
57463: LD_INT 30
57465: PUSH
57466: LD_INT 2
57468: PUSH
57469: EMPTY
57470: LIST
57471: LIST
57472: PUSH
57473: LD_INT 30
57475: PUSH
57476: LD_INT 3
57478: PUSH
57479: EMPTY
57480: LIST
57481: LIST
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: LIST
57487: PPUSH
57488: CALL_OW 72
57492: ST_TO_ADDR
57493: GO 57627
57495: LD_INT 4
57497: DOUBLE
57498: EQUAL
57499: IFTRUE 57503
57501: GO 57560
57503: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57504: LD_ADDR_VAR 0 8
57508: PUSH
57509: LD_VAR 0 2
57513: PPUSH
57514: LD_INT 2
57516: PUSH
57517: LD_INT 30
57519: PUSH
57520: LD_INT 6
57522: PUSH
57523: EMPTY
57524: LIST
57525: LIST
57526: PUSH
57527: LD_INT 30
57529: PUSH
57530: LD_INT 7
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: PUSH
57537: LD_INT 30
57539: PUSH
57540: LD_INT 8
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: PUSH
57547: EMPTY
57548: LIST
57549: LIST
57550: LIST
57551: LIST
57552: PPUSH
57553: CALL_OW 72
57557: ST_TO_ADDR
57558: GO 57627
57560: LD_INT 5
57562: DOUBLE
57563: EQUAL
57564: IFTRUE 57580
57566: LD_INT 8
57568: DOUBLE
57569: EQUAL
57570: IFTRUE 57580
57572: LD_INT 9
57574: DOUBLE
57575: EQUAL
57576: IFTRUE 57580
57578: GO 57626
57580: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57581: LD_ADDR_VAR 0 8
57585: PUSH
57586: LD_VAR 0 2
57590: PPUSH
57591: LD_INT 2
57593: PUSH
57594: LD_INT 30
57596: PUSH
57597: LD_INT 4
57599: PUSH
57600: EMPTY
57601: LIST
57602: LIST
57603: PUSH
57604: LD_INT 30
57606: PUSH
57607: LD_INT 5
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: PUSH
57614: EMPTY
57615: LIST
57616: LIST
57617: LIST
57618: PPUSH
57619: CALL_OW 72
57623: ST_TO_ADDR
57624: GO 57627
57626: POP
// if not tmp then
57627: LD_VAR 0 8
57631: NOT
57632: IFFALSE 57636
// exit ;
57634: GO 58138
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57636: LD_VAR 0 4
57640: PUSH
57641: LD_INT 1
57643: PUSH
57644: LD_INT 15
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: IN
57651: PUSH
57652: LD_EXP 122
57656: PUSH
57657: LD_VAR 0 1
57661: ARRAY
57662: AND
57663: IFFALSE 57819
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57665: LD_ADDR_VAR 0 9
57669: PUSH
57670: LD_EXP 122
57674: PUSH
57675: LD_VAR 0 1
57679: ARRAY
57680: PUSH
57681: LD_INT 1
57683: ARRAY
57684: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57685: LD_VAR 0 9
57689: PUSH
57690: LD_EXP 123
57694: PUSH
57695: LD_VAR 0 1
57699: ARRAY
57700: IN
57701: NOT
57702: IFFALSE 57817
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57704: LD_ADDR_EXP 123
57708: PUSH
57709: LD_EXP 123
57713: PPUSH
57714: LD_VAR 0 1
57718: PUSH
57719: LD_EXP 123
57723: PUSH
57724: LD_VAR 0 1
57728: ARRAY
57729: PUSH
57730: LD_INT 1
57732: PLUS
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: PPUSH
57738: LD_VAR 0 9
57742: PPUSH
57743: CALL 70058 0 3
57747: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57748: LD_ADDR_EXP 122
57752: PUSH
57753: LD_EXP 122
57757: PPUSH
57758: LD_VAR 0 1
57762: PPUSH
57763: LD_EXP 122
57767: PUSH
57768: LD_VAR 0 1
57772: ARRAY
57773: PUSH
57774: LD_VAR 0 9
57778: DIFF
57779: PPUSH
57780: CALL_OW 1
57784: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57785: LD_VAR 0 3
57789: PPUSH
57790: LD_EXP 123
57794: PUSH
57795: LD_VAR 0 1
57799: ARRAY
57800: PUSH
57801: LD_EXP 123
57805: PUSH
57806: LD_VAR 0 1
57810: ARRAY
57811: ARRAY
57812: PPUSH
57813: CALL_OW 120
// end ; exit ;
57817: GO 58138
// end ; if tmp > 1 then
57819: LD_VAR 0 8
57823: PUSH
57824: LD_INT 1
57826: GREATER
57827: IFFALSE 57931
// for i = 2 to tmp do
57829: LD_ADDR_VAR 0 6
57833: PUSH
57834: DOUBLE
57835: LD_INT 2
57837: DEC
57838: ST_TO_ADDR
57839: LD_VAR 0 8
57843: PUSH
57844: FOR_TO
57845: IFFALSE 57929
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57847: LD_VAR 0 8
57851: PUSH
57852: LD_VAR 0 6
57856: ARRAY
57857: PPUSH
57858: CALL_OW 461
57862: PUSH
57863: LD_INT 6
57865: EQUAL
57866: IFFALSE 57927
// begin x := tmp [ i ] ;
57868: LD_ADDR_VAR 0 9
57872: PUSH
57873: LD_VAR 0 8
57877: PUSH
57878: LD_VAR 0 6
57882: ARRAY
57883: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57884: LD_ADDR_VAR 0 8
57888: PUSH
57889: LD_VAR 0 8
57893: PPUSH
57894: LD_VAR 0 6
57898: PPUSH
57899: CALL_OW 3
57903: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57904: LD_ADDR_VAR 0 8
57908: PUSH
57909: LD_VAR 0 8
57913: PPUSH
57914: LD_INT 1
57916: PPUSH
57917: LD_VAR 0 9
57921: PPUSH
57922: CALL_OW 2
57926: ST_TO_ADDR
// end ;
57927: GO 57844
57929: POP
57930: POP
// for i in tmp do
57931: LD_ADDR_VAR 0 6
57935: PUSH
57936: LD_VAR 0 8
57940: PUSH
57941: FOR_IN
57942: IFFALSE 58011
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57944: LD_VAR 0 6
57948: PPUSH
57949: CALL_OW 313
57953: PUSH
57954: LD_INT 6
57956: LESS
57957: PUSH
57958: LD_VAR 0 6
57962: PPUSH
57963: CALL_OW 266
57967: PUSH
57968: LD_INT 31
57970: PUSH
57971: LD_INT 32
57973: PUSH
57974: EMPTY
57975: LIST
57976: LIST
57977: IN
57978: NOT
57979: AND
57980: PUSH
57981: LD_VAR 0 6
57985: PPUSH
57986: CALL_OW 313
57990: PUSH
57991: LD_INT 0
57993: EQUAL
57994: OR
57995: IFFALSE 58009
// begin j := i ;
57997: LD_ADDR_VAR 0 7
58001: PUSH
58002: LD_VAR 0 6
58006: ST_TO_ADDR
// break ;
58007: GO 58011
// end ; end ;
58009: GO 57941
58011: POP
58012: POP
// if j then
58013: LD_VAR 0 7
58017: IFFALSE 58035
// ComEnterUnit ( unit , j ) else
58019: LD_VAR 0 3
58023: PPUSH
58024: LD_VAR 0 7
58028: PPUSH
58029: CALL_OW 120
58033: GO 58138
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58035: LD_ADDR_VAR 0 10
58039: PUSH
58040: LD_VAR 0 2
58044: PPUSH
58045: LD_INT 2
58047: PUSH
58048: LD_INT 30
58050: PUSH
58051: LD_INT 0
58053: PUSH
58054: EMPTY
58055: LIST
58056: LIST
58057: PUSH
58058: LD_INT 30
58060: PUSH
58061: LD_INT 1
58063: PUSH
58064: EMPTY
58065: LIST
58066: LIST
58067: PUSH
58068: EMPTY
58069: LIST
58070: LIST
58071: LIST
58072: PPUSH
58073: CALL_OW 72
58077: ST_TO_ADDR
// if depot then
58078: LD_VAR 0 10
58082: IFFALSE 58138
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58084: LD_ADDR_VAR 0 10
58088: PUSH
58089: LD_VAR 0 10
58093: PPUSH
58094: LD_VAR 0 3
58098: PPUSH
58099: CALL_OW 74
58103: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58104: LD_VAR 0 3
58108: PPUSH
58109: LD_VAR 0 10
58113: PPUSH
58114: CALL_OW 296
58118: PUSH
58119: LD_INT 10
58121: GREATER
58122: IFFALSE 58138
// ComStandNearbyBuilding ( unit , depot ) ;
58124: LD_VAR 0 3
58128: PPUSH
58129: LD_VAR 0 10
58133: PPUSH
58134: CALL 66672 0 2
// end ; end ; end ;
58138: LD_VAR 0 5
58142: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58143: LD_INT 0
58145: PPUSH
58146: PPUSH
58147: PPUSH
58148: PPUSH
// if not mc_bases then
58149: LD_EXP 113
58153: NOT
58154: IFFALSE 58158
// exit ;
58156: GO 58397
// for i = 1 to mc_bases do
58158: LD_ADDR_VAR 0 2
58162: PUSH
58163: DOUBLE
58164: LD_INT 1
58166: DEC
58167: ST_TO_ADDR
58168: LD_EXP 113
58172: PUSH
58173: FOR_TO
58174: IFFALSE 58395
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58176: LD_ADDR_VAR 0 4
58180: PUSH
58181: LD_EXP 113
58185: PUSH
58186: LD_VAR 0 2
58190: ARRAY
58191: PPUSH
58192: LD_INT 21
58194: PUSH
58195: LD_INT 1
58197: PUSH
58198: EMPTY
58199: LIST
58200: LIST
58201: PPUSH
58202: CALL_OW 72
58206: PUSH
58207: LD_EXP 142
58211: PUSH
58212: LD_VAR 0 2
58216: ARRAY
58217: UNION
58218: ST_TO_ADDR
// if not tmp then
58219: LD_VAR 0 4
58223: NOT
58224: IFFALSE 58228
// continue ;
58226: GO 58173
// for j in tmp do
58228: LD_ADDR_VAR 0 3
58232: PUSH
58233: LD_VAR 0 4
58237: PUSH
58238: FOR_IN
58239: IFFALSE 58391
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58241: LD_VAR 0 3
58245: PPUSH
58246: CALL_OW 110
58250: NOT
58251: PUSH
58252: LD_VAR 0 3
58256: PPUSH
58257: CALL_OW 314
58261: NOT
58262: AND
58263: PUSH
58264: LD_VAR 0 3
58268: PPUSH
58269: CALL_OW 311
58273: NOT
58274: AND
58275: PUSH
58276: LD_VAR 0 3
58280: PPUSH
58281: CALL_OW 310
58285: NOT
58286: AND
58287: PUSH
58288: LD_VAR 0 3
58292: PUSH
58293: LD_EXP 116
58297: PUSH
58298: LD_VAR 0 2
58302: ARRAY
58303: PUSH
58304: LD_INT 1
58306: ARRAY
58307: IN
58308: NOT
58309: AND
58310: PUSH
58311: LD_VAR 0 3
58315: PUSH
58316: LD_EXP 116
58320: PUSH
58321: LD_VAR 0 2
58325: ARRAY
58326: PUSH
58327: LD_INT 2
58329: ARRAY
58330: IN
58331: NOT
58332: AND
58333: PUSH
58334: LD_VAR 0 3
58338: PUSH
58339: LD_EXP 125
58343: PUSH
58344: LD_VAR 0 2
58348: ARRAY
58349: IN
58350: NOT
58351: AND
58352: IFFALSE 58389
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58354: LD_VAR 0 2
58358: PPUSH
58359: LD_EXP 113
58363: PUSH
58364: LD_VAR 0 2
58368: ARRAY
58369: PPUSH
58370: LD_VAR 0 3
58374: PPUSH
58375: LD_VAR 0 3
58379: PPUSH
58380: CALL_OW 257
58384: PPUSH
58385: CALL 57161 0 4
// end ;
58389: GO 58238
58391: POP
58392: POP
// end ;
58393: GO 58173
58395: POP
58396: POP
// end ;
58397: LD_VAR 0 1
58401: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58402: LD_INT 0
58404: PPUSH
58405: PPUSH
58406: PPUSH
58407: PPUSH
58408: PPUSH
58409: PPUSH
// if not mc_bases [ base ] then
58410: LD_EXP 113
58414: PUSH
58415: LD_VAR 0 1
58419: ARRAY
58420: NOT
58421: IFFALSE 58425
// exit ;
58423: GO 58607
// tmp := [ ] ;
58425: LD_ADDR_VAR 0 6
58429: PUSH
58430: EMPTY
58431: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58432: LD_ADDR_VAR 0 7
58436: PUSH
58437: LD_VAR 0 3
58441: PPUSH
58442: LD_INT 0
58444: PPUSH
58445: CALL_OW 517
58449: ST_TO_ADDR
// if not list then
58450: LD_VAR 0 7
58454: NOT
58455: IFFALSE 58459
// exit ;
58457: GO 58607
// for i = 1 to amount do
58459: LD_ADDR_VAR 0 5
58463: PUSH
58464: DOUBLE
58465: LD_INT 1
58467: DEC
58468: ST_TO_ADDR
58469: LD_VAR 0 2
58473: PUSH
58474: FOR_TO
58475: IFFALSE 58555
// begin x := rand ( 1 , list [ 1 ] ) ;
58477: LD_ADDR_VAR 0 8
58481: PUSH
58482: LD_INT 1
58484: PPUSH
58485: LD_VAR 0 7
58489: PUSH
58490: LD_INT 1
58492: ARRAY
58493: PPUSH
58494: CALL_OW 12
58498: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58499: LD_ADDR_VAR 0 6
58503: PUSH
58504: LD_VAR 0 6
58508: PPUSH
58509: LD_VAR 0 5
58513: PPUSH
58514: LD_VAR 0 7
58518: PUSH
58519: LD_INT 1
58521: ARRAY
58522: PUSH
58523: LD_VAR 0 8
58527: ARRAY
58528: PUSH
58529: LD_VAR 0 7
58533: PUSH
58534: LD_INT 2
58536: ARRAY
58537: PUSH
58538: LD_VAR 0 8
58542: ARRAY
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: PPUSH
58548: CALL_OW 1
58552: ST_TO_ADDR
// end ;
58553: GO 58474
58555: POP
58556: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58557: LD_ADDR_EXP 126
58561: PUSH
58562: LD_EXP 126
58566: PPUSH
58567: LD_VAR 0 1
58571: PPUSH
58572: LD_VAR 0 6
58576: PPUSH
58577: CALL_OW 1
58581: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58582: LD_ADDR_EXP 128
58586: PUSH
58587: LD_EXP 128
58591: PPUSH
58592: LD_VAR 0 1
58596: PPUSH
58597: LD_VAR 0 3
58601: PPUSH
58602: CALL_OW 1
58606: ST_TO_ADDR
// end ;
58607: LD_VAR 0 4
58611: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58612: LD_INT 0
58614: PPUSH
// if not mc_bases [ base ] then
58615: LD_EXP 113
58619: PUSH
58620: LD_VAR 0 1
58624: ARRAY
58625: NOT
58626: IFFALSE 58630
// exit ;
58628: GO 58655
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58630: LD_ADDR_EXP 118
58634: PUSH
58635: LD_EXP 118
58639: PPUSH
58640: LD_VAR 0 1
58644: PPUSH
58645: LD_VAR 0 2
58649: PPUSH
58650: CALL_OW 1
58654: ST_TO_ADDR
// end ;
58655: LD_VAR 0 3
58659: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58660: LD_INT 0
58662: PPUSH
// if not mc_bases [ base ] then
58663: LD_EXP 113
58667: PUSH
58668: LD_VAR 0 1
58672: ARRAY
58673: NOT
58674: IFFALSE 58678
// exit ;
58676: GO 58715
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58678: LD_ADDR_EXP 118
58682: PUSH
58683: LD_EXP 118
58687: PPUSH
58688: LD_VAR 0 1
58692: PPUSH
58693: LD_EXP 118
58697: PUSH
58698: LD_VAR 0 1
58702: ARRAY
58703: PUSH
58704: LD_VAR 0 2
58708: UNION
58709: PPUSH
58710: CALL_OW 1
58714: ST_TO_ADDR
// end ;
58715: LD_VAR 0 3
58719: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58720: LD_INT 0
58722: PPUSH
// if not mc_bases [ base ] then
58723: LD_EXP 113
58727: PUSH
58728: LD_VAR 0 1
58732: ARRAY
58733: NOT
58734: IFFALSE 58738
// exit ;
58736: GO 58763
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58738: LD_ADDR_EXP 134
58742: PUSH
58743: LD_EXP 134
58747: PPUSH
58748: LD_VAR 0 1
58752: PPUSH
58753: LD_VAR 0 2
58757: PPUSH
58758: CALL_OW 1
58762: ST_TO_ADDR
// end ;
58763: LD_VAR 0 3
58767: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58768: LD_INT 0
58770: PPUSH
// if not mc_bases [ base ] then
58771: LD_EXP 113
58775: PUSH
58776: LD_VAR 0 1
58780: ARRAY
58781: NOT
58782: IFFALSE 58786
// exit ;
58784: GO 58823
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58786: LD_ADDR_EXP 134
58790: PUSH
58791: LD_EXP 134
58795: PPUSH
58796: LD_VAR 0 1
58800: PPUSH
58801: LD_EXP 134
58805: PUSH
58806: LD_VAR 0 1
58810: ARRAY
58811: PUSH
58812: LD_VAR 0 2
58816: ADD
58817: PPUSH
58818: CALL_OW 1
58822: ST_TO_ADDR
// end ;
58823: LD_VAR 0 3
58827: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58828: LD_INT 0
58830: PPUSH
// if not mc_bases [ base ] then
58831: LD_EXP 113
58835: PUSH
58836: LD_VAR 0 1
58840: ARRAY
58841: NOT
58842: IFFALSE 58846
// exit ;
58844: GO 58900
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58846: LD_ADDR_EXP 135
58850: PUSH
58851: LD_EXP 135
58855: PPUSH
58856: LD_VAR 0 1
58860: PPUSH
58861: LD_VAR 0 2
58865: PPUSH
58866: CALL_OW 1
58870: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58871: LD_ADDR_EXP 124
58875: PUSH
58876: LD_EXP 124
58880: PPUSH
58881: LD_VAR 0 1
58885: PPUSH
58886: LD_VAR 0 2
58890: PUSH
58891: LD_INT 0
58893: PLUS
58894: PPUSH
58895: CALL_OW 1
58899: ST_TO_ADDR
// end ;
58900: LD_VAR 0 3
58904: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58905: LD_INT 0
58907: PPUSH
// if not mc_bases [ base ] then
58908: LD_EXP 113
58912: PUSH
58913: LD_VAR 0 1
58917: ARRAY
58918: NOT
58919: IFFALSE 58923
// exit ;
58921: GO 58948
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58923: LD_ADDR_EXP 124
58927: PUSH
58928: LD_EXP 124
58932: PPUSH
58933: LD_VAR 0 1
58937: PPUSH
58938: LD_VAR 0 2
58942: PPUSH
58943: CALL_OW 1
58947: ST_TO_ADDR
// end ;
58948: LD_VAR 0 3
58952: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58953: LD_INT 0
58955: PPUSH
58956: PPUSH
58957: PPUSH
58958: PPUSH
// if not mc_bases [ base ] then
58959: LD_EXP 113
58963: PUSH
58964: LD_VAR 0 1
58968: ARRAY
58969: NOT
58970: IFFALSE 58974
// exit ;
58972: GO 59039
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58974: LD_ADDR_EXP 133
58978: PUSH
58979: LD_EXP 133
58983: PPUSH
58984: LD_VAR 0 1
58988: PUSH
58989: LD_EXP 133
58993: PUSH
58994: LD_VAR 0 1
58998: ARRAY
58999: PUSH
59000: LD_INT 1
59002: PLUS
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: PPUSH
59008: LD_VAR 0 1
59012: PUSH
59013: LD_VAR 0 2
59017: PUSH
59018: LD_VAR 0 3
59022: PUSH
59023: LD_VAR 0 4
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: LIST
59033: PPUSH
59034: CALL 70058 0 3
59038: ST_TO_ADDR
// end ;
59039: LD_VAR 0 5
59043: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59044: LD_INT 0
59046: PPUSH
// if not mc_bases [ base ] then
59047: LD_EXP 113
59051: PUSH
59052: LD_VAR 0 1
59056: ARRAY
59057: NOT
59058: IFFALSE 59062
// exit ;
59060: GO 59087
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59062: LD_ADDR_EXP 150
59066: PUSH
59067: LD_EXP 150
59071: PPUSH
59072: LD_VAR 0 1
59076: PPUSH
59077: LD_VAR 0 2
59081: PPUSH
59082: CALL_OW 1
59086: ST_TO_ADDR
// end ;
59087: LD_VAR 0 3
59091: RET
// export function MC_GetMinesField ( base ) ; begin
59092: LD_INT 0
59094: PPUSH
// result := mc_mines [ base ] ;
59095: LD_ADDR_VAR 0 2
59099: PUSH
59100: LD_EXP 126
59104: PUSH
59105: LD_VAR 0 1
59109: ARRAY
59110: ST_TO_ADDR
// end ;
59111: LD_VAR 0 2
59115: RET
// export function MC_GetProduceList ( base ) ; begin
59116: LD_INT 0
59118: PPUSH
// result := mc_produce [ base ] ;
59119: LD_ADDR_VAR 0 2
59123: PUSH
59124: LD_EXP 134
59128: PUSH
59129: LD_VAR 0 1
59133: ARRAY
59134: ST_TO_ADDR
// end ;
59135: LD_VAR 0 2
59139: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59140: LD_INT 0
59142: PPUSH
59143: PPUSH
// if not mc_bases then
59144: LD_EXP 113
59148: NOT
59149: IFFALSE 59153
// exit ;
59151: GO 59218
// if mc_bases [ base ] then
59153: LD_EXP 113
59157: PUSH
59158: LD_VAR 0 1
59162: ARRAY
59163: IFFALSE 59218
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59165: LD_ADDR_VAR 0 3
59169: PUSH
59170: LD_EXP 113
59174: PUSH
59175: LD_VAR 0 1
59179: ARRAY
59180: PPUSH
59181: LD_INT 30
59183: PUSH
59184: LD_VAR 0 2
59188: PUSH
59189: EMPTY
59190: LIST
59191: LIST
59192: PPUSH
59193: CALL_OW 72
59197: ST_TO_ADDR
// if result then
59198: LD_VAR 0 3
59202: IFFALSE 59218
// result := result [ 1 ] ;
59204: LD_ADDR_VAR 0 3
59208: PUSH
59209: LD_VAR 0 3
59213: PUSH
59214: LD_INT 1
59216: ARRAY
59217: ST_TO_ADDR
// end ; end ;
59218: LD_VAR 0 3
59222: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59223: LD_INT 0
59225: PPUSH
59226: PPUSH
// if not mc_bases then
59227: LD_EXP 113
59231: NOT
59232: IFFALSE 59236
// exit ;
59234: GO 59281
// if mc_bases [ base ] then
59236: LD_EXP 113
59240: PUSH
59241: LD_VAR 0 1
59245: ARRAY
59246: IFFALSE 59281
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59248: LD_ADDR_VAR 0 3
59252: PUSH
59253: LD_EXP 113
59257: PUSH
59258: LD_VAR 0 1
59262: ARRAY
59263: PPUSH
59264: LD_INT 30
59266: PUSH
59267: LD_VAR 0 2
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: PPUSH
59276: CALL_OW 72
59280: ST_TO_ADDR
// end ;
59281: LD_VAR 0 3
59285: RET
// export function MC_SetTame ( base , area ) ; begin
59286: LD_INT 0
59288: PPUSH
// if not mc_bases or not base then
59289: LD_EXP 113
59293: NOT
59294: PUSH
59295: LD_VAR 0 1
59299: NOT
59300: OR
59301: IFFALSE 59305
// exit ;
59303: GO 59330
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59305: LD_ADDR_EXP 141
59309: PUSH
59310: LD_EXP 141
59314: PPUSH
59315: LD_VAR 0 1
59319: PPUSH
59320: LD_VAR 0 2
59324: PPUSH
59325: CALL_OW 1
59329: ST_TO_ADDR
// end ;
59330: LD_VAR 0 3
59334: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59335: LD_INT 0
59337: PPUSH
59338: PPUSH
// if not mc_bases or not base then
59339: LD_EXP 113
59343: NOT
59344: PUSH
59345: LD_VAR 0 1
59349: NOT
59350: OR
59351: IFFALSE 59355
// exit ;
59353: GO 59457
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59355: LD_ADDR_VAR 0 4
59359: PUSH
59360: LD_EXP 113
59364: PUSH
59365: LD_VAR 0 1
59369: ARRAY
59370: PPUSH
59371: LD_INT 30
59373: PUSH
59374: LD_VAR 0 2
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PPUSH
59383: CALL_OW 72
59387: ST_TO_ADDR
// if not tmp then
59388: LD_VAR 0 4
59392: NOT
59393: IFFALSE 59397
// exit ;
59395: GO 59457
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59397: LD_ADDR_EXP 145
59401: PUSH
59402: LD_EXP 145
59406: PPUSH
59407: LD_VAR 0 1
59411: PPUSH
59412: LD_EXP 145
59416: PUSH
59417: LD_VAR 0 1
59421: ARRAY
59422: PPUSH
59423: LD_EXP 145
59427: PUSH
59428: LD_VAR 0 1
59432: ARRAY
59433: PUSH
59434: LD_INT 1
59436: PLUS
59437: PPUSH
59438: LD_VAR 0 4
59442: PUSH
59443: LD_INT 1
59445: ARRAY
59446: PPUSH
59447: CALL_OW 2
59451: PPUSH
59452: CALL_OW 1
59456: ST_TO_ADDR
// end ;
59457: LD_VAR 0 3
59461: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59462: LD_INT 0
59464: PPUSH
59465: PPUSH
// if not mc_bases or not base or not kinds then
59466: LD_EXP 113
59470: NOT
59471: PUSH
59472: LD_VAR 0 1
59476: NOT
59477: OR
59478: PUSH
59479: LD_VAR 0 2
59483: NOT
59484: OR
59485: IFFALSE 59489
// exit ;
59487: GO 59550
// for i in kinds do
59489: LD_ADDR_VAR 0 4
59493: PUSH
59494: LD_VAR 0 2
59498: PUSH
59499: FOR_IN
59500: IFFALSE 59548
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59502: LD_ADDR_EXP 147
59506: PUSH
59507: LD_EXP 147
59511: PPUSH
59512: LD_VAR 0 1
59516: PUSH
59517: LD_EXP 147
59521: PUSH
59522: LD_VAR 0 1
59526: ARRAY
59527: PUSH
59528: LD_INT 1
59530: PLUS
59531: PUSH
59532: EMPTY
59533: LIST
59534: LIST
59535: PPUSH
59536: LD_VAR 0 4
59540: PPUSH
59541: CALL 70058 0 3
59545: ST_TO_ADDR
59546: GO 59499
59548: POP
59549: POP
// end ;
59550: LD_VAR 0 3
59554: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59555: LD_INT 0
59557: PPUSH
// if not mc_bases or not base or not areas then
59558: LD_EXP 113
59562: NOT
59563: PUSH
59564: LD_VAR 0 1
59568: NOT
59569: OR
59570: PUSH
59571: LD_VAR 0 2
59575: NOT
59576: OR
59577: IFFALSE 59581
// exit ;
59579: GO 59606
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59581: LD_ADDR_EXP 131
59585: PUSH
59586: LD_EXP 131
59590: PPUSH
59591: LD_VAR 0 1
59595: PPUSH
59596: LD_VAR 0 2
59600: PPUSH
59601: CALL_OW 1
59605: ST_TO_ADDR
// end ;
59606: LD_VAR 0 3
59610: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59611: LD_INT 0
59613: PPUSH
// if not mc_bases or not base or not teleports_exit then
59614: LD_EXP 113
59618: NOT
59619: PUSH
59620: LD_VAR 0 1
59624: NOT
59625: OR
59626: PUSH
59627: LD_VAR 0 2
59631: NOT
59632: OR
59633: IFFALSE 59637
// exit ;
59635: GO 59662
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59637: LD_ADDR_EXP 148
59641: PUSH
59642: LD_EXP 148
59646: PPUSH
59647: LD_VAR 0 1
59651: PPUSH
59652: LD_VAR 0 2
59656: PPUSH
59657: CALL_OW 1
59661: ST_TO_ADDR
// end ;
59662: LD_VAR 0 3
59666: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59667: LD_INT 0
59669: PPUSH
59670: PPUSH
59671: PPUSH
// if not mc_bases or not base or not ext_list then
59672: LD_EXP 113
59676: NOT
59677: PUSH
59678: LD_VAR 0 1
59682: NOT
59683: OR
59684: PUSH
59685: LD_VAR 0 5
59689: NOT
59690: OR
59691: IFFALSE 59695
// exit ;
59693: GO 59868
// tmp := GetFacExtXYD ( x , y , d ) ;
59695: LD_ADDR_VAR 0 8
59699: PUSH
59700: LD_VAR 0 2
59704: PPUSH
59705: LD_VAR 0 3
59709: PPUSH
59710: LD_VAR 0 4
59714: PPUSH
59715: CALL 98737 0 3
59719: ST_TO_ADDR
// if not tmp then
59720: LD_VAR 0 8
59724: NOT
59725: IFFALSE 59729
// exit ;
59727: GO 59868
// for i in tmp do
59729: LD_ADDR_VAR 0 7
59733: PUSH
59734: LD_VAR 0 8
59738: PUSH
59739: FOR_IN
59740: IFFALSE 59866
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59742: LD_ADDR_EXP 118
59746: PUSH
59747: LD_EXP 118
59751: PPUSH
59752: LD_VAR 0 1
59756: PPUSH
59757: LD_EXP 118
59761: PUSH
59762: LD_VAR 0 1
59766: ARRAY
59767: PPUSH
59768: LD_EXP 118
59772: PUSH
59773: LD_VAR 0 1
59777: ARRAY
59778: PUSH
59779: LD_INT 1
59781: PLUS
59782: PPUSH
59783: LD_VAR 0 5
59787: PUSH
59788: LD_INT 1
59790: ARRAY
59791: PUSH
59792: LD_VAR 0 7
59796: PUSH
59797: LD_INT 1
59799: ARRAY
59800: PUSH
59801: LD_VAR 0 7
59805: PUSH
59806: LD_INT 2
59808: ARRAY
59809: PUSH
59810: LD_VAR 0 7
59814: PUSH
59815: LD_INT 3
59817: ARRAY
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: LIST
59823: LIST
59824: PPUSH
59825: CALL_OW 2
59829: PPUSH
59830: CALL_OW 1
59834: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59835: LD_ADDR_VAR 0 5
59839: PUSH
59840: LD_VAR 0 5
59844: PPUSH
59845: LD_INT 1
59847: PPUSH
59848: CALL_OW 3
59852: ST_TO_ADDR
// if not ext_list then
59853: LD_VAR 0 5
59857: NOT
59858: IFFALSE 59864
// exit ;
59860: POP
59861: POP
59862: GO 59868
// end ;
59864: GO 59739
59866: POP
59867: POP
// end ;
59868: LD_VAR 0 6
59872: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59873: LD_INT 0
59875: PPUSH
// if not mc_bases or not base or not weapon_list then
59876: LD_EXP 113
59880: NOT
59881: PUSH
59882: LD_VAR 0 1
59886: NOT
59887: OR
59888: PUSH
59889: LD_VAR 0 2
59893: NOT
59894: OR
59895: IFFALSE 59899
// exit ;
59897: GO 59924
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59899: LD_ADDR_EXP 152
59903: PUSH
59904: LD_EXP 152
59908: PPUSH
59909: LD_VAR 0 1
59913: PPUSH
59914: LD_VAR 0 2
59918: PPUSH
59919: CALL_OW 1
59923: ST_TO_ADDR
// end ;
59924: LD_VAR 0 3
59928: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59929: LD_INT 0
59931: PPUSH
// if not mc_bases or not base or not tech_list then
59932: LD_EXP 113
59936: NOT
59937: PUSH
59938: LD_VAR 0 1
59942: NOT
59943: OR
59944: PUSH
59945: LD_VAR 0 2
59949: NOT
59950: OR
59951: IFFALSE 59955
// exit ;
59953: GO 59980
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59955: LD_ADDR_EXP 140
59959: PUSH
59960: LD_EXP 140
59964: PPUSH
59965: LD_VAR 0 1
59969: PPUSH
59970: LD_VAR 0 2
59974: PPUSH
59975: CALL_OW 1
59979: ST_TO_ADDR
// end ;
59980: LD_VAR 0 3
59984: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59985: LD_INT 0
59987: PPUSH
// if not mc_bases or not parking_area or not base then
59988: LD_EXP 113
59992: NOT
59993: PUSH
59994: LD_VAR 0 2
59998: NOT
59999: OR
60000: PUSH
60001: LD_VAR 0 1
60005: NOT
60006: OR
60007: IFFALSE 60011
// exit ;
60009: GO 60036
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60011: LD_ADDR_EXP 137
60015: PUSH
60016: LD_EXP 137
60020: PPUSH
60021: LD_VAR 0 1
60025: PPUSH
60026: LD_VAR 0 2
60030: PPUSH
60031: CALL_OW 1
60035: ST_TO_ADDR
// end ;
60036: LD_VAR 0 3
60040: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60041: LD_INT 0
60043: PPUSH
// if not mc_bases or not base or not scan_area then
60044: LD_EXP 113
60048: NOT
60049: PUSH
60050: LD_VAR 0 1
60054: NOT
60055: OR
60056: PUSH
60057: LD_VAR 0 2
60061: NOT
60062: OR
60063: IFFALSE 60067
// exit ;
60065: GO 60092
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60067: LD_ADDR_EXP 138
60071: PUSH
60072: LD_EXP 138
60076: PPUSH
60077: LD_VAR 0 1
60081: PPUSH
60082: LD_VAR 0 2
60086: PPUSH
60087: CALL_OW 1
60091: ST_TO_ADDR
// end ;
60092: LD_VAR 0 3
60096: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60097: LD_INT 0
60099: PPUSH
60100: PPUSH
// if not mc_bases or not base then
60101: LD_EXP 113
60105: NOT
60106: PUSH
60107: LD_VAR 0 1
60111: NOT
60112: OR
60113: IFFALSE 60117
// exit ;
60115: GO 60181
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60117: LD_ADDR_VAR 0 3
60121: PUSH
60122: LD_INT 1
60124: PUSH
60125: LD_INT 2
60127: PUSH
60128: LD_INT 3
60130: PUSH
60131: LD_INT 4
60133: PUSH
60134: LD_INT 11
60136: PUSH
60137: EMPTY
60138: LIST
60139: LIST
60140: LIST
60141: LIST
60142: LIST
60143: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60144: LD_ADDR_EXP 140
60148: PUSH
60149: LD_EXP 140
60153: PPUSH
60154: LD_VAR 0 1
60158: PPUSH
60159: LD_EXP 140
60163: PUSH
60164: LD_VAR 0 1
60168: ARRAY
60169: PUSH
60170: LD_VAR 0 3
60174: DIFF
60175: PPUSH
60176: CALL_OW 1
60180: ST_TO_ADDR
// end ;
60181: LD_VAR 0 2
60185: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60186: LD_INT 0
60188: PPUSH
// result := mc_vehicles [ base ] ;
60189: LD_ADDR_VAR 0 3
60193: PUSH
60194: LD_EXP 132
60198: PUSH
60199: LD_VAR 0 1
60203: ARRAY
60204: ST_TO_ADDR
// if onlyCombat then
60205: LD_VAR 0 2
60209: IFFALSE 60374
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60211: LD_ADDR_VAR 0 3
60215: PUSH
60216: LD_VAR 0 3
60220: PUSH
60221: LD_VAR 0 3
60225: PPUSH
60226: LD_INT 2
60228: PUSH
60229: LD_INT 34
60231: PUSH
60232: LD_INT 12
60234: PUSH
60235: EMPTY
60236: LIST
60237: LIST
60238: PUSH
60239: LD_INT 34
60241: PUSH
60242: LD_INT 51
60244: PUSH
60245: EMPTY
60246: LIST
60247: LIST
60248: PUSH
60249: LD_INT 34
60251: PUSH
60252: LD_EXP 96
60256: PUSH
60257: EMPTY
60258: LIST
60259: LIST
60260: PUSH
60261: LD_INT 34
60263: PUSH
60264: LD_INT 32
60266: PUSH
60267: EMPTY
60268: LIST
60269: LIST
60270: PUSH
60271: LD_INT 34
60273: PUSH
60274: LD_INT 13
60276: PUSH
60277: EMPTY
60278: LIST
60279: LIST
60280: PUSH
60281: LD_INT 34
60283: PUSH
60284: LD_INT 52
60286: PUSH
60287: EMPTY
60288: LIST
60289: LIST
60290: PUSH
60291: LD_INT 34
60293: PUSH
60294: LD_INT 14
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PUSH
60301: LD_INT 34
60303: PUSH
60304: LD_INT 53
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: PUSH
60311: LD_INT 34
60313: PUSH
60314: LD_EXP 95
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: PUSH
60323: LD_INT 34
60325: PUSH
60326: LD_INT 31
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: PUSH
60333: LD_INT 34
60335: PUSH
60336: LD_INT 48
60338: PUSH
60339: EMPTY
60340: LIST
60341: LIST
60342: PUSH
60343: LD_INT 34
60345: PUSH
60346: LD_INT 8
60348: PUSH
60349: EMPTY
60350: LIST
60351: LIST
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: LIST
60357: LIST
60358: LIST
60359: LIST
60360: LIST
60361: LIST
60362: LIST
60363: LIST
60364: LIST
60365: LIST
60366: LIST
60367: PPUSH
60368: CALL_OW 72
60372: DIFF
60373: ST_TO_ADDR
// end ; end_of_file
60374: LD_VAR 0 3
60378: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60379: LD_INT 0
60381: PPUSH
60382: PPUSH
60383: PPUSH
// if not mc_bases or not skirmish then
60384: LD_EXP 113
60388: NOT
60389: PUSH
60390: LD_EXP 111
60394: NOT
60395: OR
60396: IFFALSE 60400
// exit ;
60398: GO 60565
// for i = 1 to mc_bases do
60400: LD_ADDR_VAR 0 4
60404: PUSH
60405: DOUBLE
60406: LD_INT 1
60408: DEC
60409: ST_TO_ADDR
60410: LD_EXP 113
60414: PUSH
60415: FOR_TO
60416: IFFALSE 60563
// begin if sci in mc_bases [ i ] then
60418: LD_VAR 0 2
60422: PUSH
60423: LD_EXP 113
60427: PUSH
60428: LD_VAR 0 4
60432: ARRAY
60433: IN
60434: IFFALSE 60561
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60436: LD_ADDR_EXP 142
60440: PUSH
60441: LD_EXP 142
60445: PPUSH
60446: LD_VAR 0 4
60450: PUSH
60451: LD_EXP 142
60455: PUSH
60456: LD_VAR 0 4
60460: ARRAY
60461: PUSH
60462: LD_INT 1
60464: PLUS
60465: PUSH
60466: EMPTY
60467: LIST
60468: LIST
60469: PPUSH
60470: LD_VAR 0 1
60474: PPUSH
60475: CALL 70058 0 3
60479: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60480: LD_ADDR_VAR 0 5
60484: PUSH
60485: LD_EXP 113
60489: PUSH
60490: LD_VAR 0 4
60494: ARRAY
60495: PPUSH
60496: LD_INT 2
60498: PUSH
60499: LD_INT 30
60501: PUSH
60502: LD_INT 0
60504: PUSH
60505: EMPTY
60506: LIST
60507: LIST
60508: PUSH
60509: LD_INT 30
60511: PUSH
60512: LD_INT 1
60514: PUSH
60515: EMPTY
60516: LIST
60517: LIST
60518: PUSH
60519: EMPTY
60520: LIST
60521: LIST
60522: LIST
60523: PPUSH
60524: CALL_OW 72
60528: PPUSH
60529: LD_VAR 0 1
60533: PPUSH
60534: CALL_OW 74
60538: ST_TO_ADDR
// if tmp then
60539: LD_VAR 0 5
60543: IFFALSE 60559
// ComStandNearbyBuilding ( ape , tmp ) ;
60545: LD_VAR 0 1
60549: PPUSH
60550: LD_VAR 0 5
60554: PPUSH
60555: CALL 66672 0 2
// break ;
60559: GO 60563
// end ; end ;
60561: GO 60415
60563: POP
60564: POP
// end ;
60565: LD_VAR 0 3
60569: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60570: LD_INT 0
60572: PPUSH
60573: PPUSH
60574: PPUSH
// if not mc_bases or not skirmish then
60575: LD_EXP 113
60579: NOT
60580: PUSH
60581: LD_EXP 111
60585: NOT
60586: OR
60587: IFFALSE 60591
// exit ;
60589: GO 60680
// for i = 1 to mc_bases do
60591: LD_ADDR_VAR 0 4
60595: PUSH
60596: DOUBLE
60597: LD_INT 1
60599: DEC
60600: ST_TO_ADDR
60601: LD_EXP 113
60605: PUSH
60606: FOR_TO
60607: IFFALSE 60678
// begin if building in mc_busy_turret_list [ i ] then
60609: LD_VAR 0 1
60613: PUSH
60614: LD_EXP 123
60618: PUSH
60619: LD_VAR 0 4
60623: ARRAY
60624: IN
60625: IFFALSE 60676
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60627: LD_ADDR_VAR 0 5
60631: PUSH
60632: LD_EXP 123
60636: PUSH
60637: LD_VAR 0 4
60641: ARRAY
60642: PUSH
60643: LD_VAR 0 1
60647: DIFF
60648: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60649: LD_ADDR_EXP 123
60653: PUSH
60654: LD_EXP 123
60658: PPUSH
60659: LD_VAR 0 4
60663: PPUSH
60664: LD_VAR 0 5
60668: PPUSH
60669: CALL_OW 1
60673: ST_TO_ADDR
// break ;
60674: GO 60678
// end ; end ;
60676: GO 60606
60678: POP
60679: POP
// end ;
60680: LD_VAR 0 3
60684: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60685: LD_INT 0
60687: PPUSH
60688: PPUSH
60689: PPUSH
// if not mc_bases or not skirmish then
60690: LD_EXP 113
60694: NOT
60695: PUSH
60696: LD_EXP 111
60700: NOT
60701: OR
60702: IFFALSE 60706
// exit ;
60704: GO 60905
// for i = 1 to mc_bases do
60706: LD_ADDR_VAR 0 5
60710: PUSH
60711: DOUBLE
60712: LD_INT 1
60714: DEC
60715: ST_TO_ADDR
60716: LD_EXP 113
60720: PUSH
60721: FOR_TO
60722: IFFALSE 60903
// if building in mc_bases [ i ] then
60724: LD_VAR 0 1
60728: PUSH
60729: LD_EXP 113
60733: PUSH
60734: LD_VAR 0 5
60738: ARRAY
60739: IN
60740: IFFALSE 60901
// begin tmp := mc_bases [ i ] diff building ;
60742: LD_ADDR_VAR 0 6
60746: PUSH
60747: LD_EXP 113
60751: PUSH
60752: LD_VAR 0 5
60756: ARRAY
60757: PUSH
60758: LD_VAR 0 1
60762: DIFF
60763: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60764: LD_ADDR_EXP 113
60768: PUSH
60769: LD_EXP 113
60773: PPUSH
60774: LD_VAR 0 5
60778: PPUSH
60779: LD_VAR 0 6
60783: PPUSH
60784: CALL_OW 1
60788: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60789: LD_VAR 0 1
60793: PUSH
60794: LD_EXP 121
60798: PUSH
60799: LD_VAR 0 5
60803: ARRAY
60804: IN
60805: IFFALSE 60844
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60807: LD_ADDR_EXP 121
60811: PUSH
60812: LD_EXP 121
60816: PPUSH
60817: LD_VAR 0 5
60821: PPUSH
60822: LD_EXP 121
60826: PUSH
60827: LD_VAR 0 5
60831: ARRAY
60832: PUSH
60833: LD_VAR 0 1
60837: DIFF
60838: PPUSH
60839: CALL_OW 1
60843: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60844: LD_VAR 0 1
60848: PUSH
60849: LD_EXP 122
60853: PUSH
60854: LD_VAR 0 5
60858: ARRAY
60859: IN
60860: IFFALSE 60899
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60862: LD_ADDR_EXP 122
60866: PUSH
60867: LD_EXP 122
60871: PPUSH
60872: LD_VAR 0 5
60876: PPUSH
60877: LD_EXP 122
60881: PUSH
60882: LD_VAR 0 5
60886: ARRAY
60887: PUSH
60888: LD_VAR 0 1
60892: DIFF
60893: PPUSH
60894: CALL_OW 1
60898: ST_TO_ADDR
// break ;
60899: GO 60903
// end ;
60901: GO 60721
60903: POP
60904: POP
// end ;
60905: LD_VAR 0 4
60909: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60910: LD_INT 0
60912: PPUSH
60913: PPUSH
60914: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60915: LD_EXP 113
60919: NOT
60920: PUSH
60921: LD_EXP 111
60925: NOT
60926: OR
60927: PUSH
60928: LD_VAR 0 3
60932: PUSH
60933: LD_EXP 139
60937: IN
60938: NOT
60939: OR
60940: IFFALSE 60944
// exit ;
60942: GO 61067
// for i = 1 to mc_vehicles do
60944: LD_ADDR_VAR 0 6
60948: PUSH
60949: DOUBLE
60950: LD_INT 1
60952: DEC
60953: ST_TO_ADDR
60954: LD_EXP 132
60958: PUSH
60959: FOR_TO
60960: IFFALSE 61065
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60962: LD_VAR 0 2
60966: PUSH
60967: LD_EXP 132
60971: PUSH
60972: LD_VAR 0 6
60976: ARRAY
60977: IN
60978: PUSH
60979: LD_VAR 0 1
60983: PUSH
60984: LD_EXP 132
60988: PUSH
60989: LD_VAR 0 6
60993: ARRAY
60994: IN
60995: OR
60996: IFFALSE 61063
// begin tmp := mc_vehicles [ i ] diff old ;
60998: LD_ADDR_VAR 0 7
61002: PUSH
61003: LD_EXP 132
61007: PUSH
61008: LD_VAR 0 6
61012: ARRAY
61013: PUSH
61014: LD_VAR 0 2
61018: DIFF
61019: ST_TO_ADDR
// tmp := tmp diff new ;
61020: LD_ADDR_VAR 0 7
61024: PUSH
61025: LD_VAR 0 7
61029: PUSH
61030: LD_VAR 0 1
61034: DIFF
61035: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61036: LD_ADDR_EXP 132
61040: PUSH
61041: LD_EXP 132
61045: PPUSH
61046: LD_VAR 0 6
61050: PPUSH
61051: LD_VAR 0 7
61055: PPUSH
61056: CALL_OW 1
61060: ST_TO_ADDR
// break ;
61061: GO 61065
// end ;
61063: GO 60959
61065: POP
61066: POP
// end ;
61067: LD_VAR 0 5
61071: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61072: LD_INT 0
61074: PPUSH
61075: PPUSH
61076: PPUSH
61077: PPUSH
// if not mc_bases or not skirmish then
61078: LD_EXP 113
61082: NOT
61083: PUSH
61084: LD_EXP 111
61088: NOT
61089: OR
61090: IFFALSE 61094
// exit ;
61092: GO 61471
// side := GetSide ( vehicle ) ;
61094: LD_ADDR_VAR 0 5
61098: PUSH
61099: LD_VAR 0 1
61103: PPUSH
61104: CALL_OW 255
61108: ST_TO_ADDR
// for i = 1 to mc_bases do
61109: LD_ADDR_VAR 0 4
61113: PUSH
61114: DOUBLE
61115: LD_INT 1
61117: DEC
61118: ST_TO_ADDR
61119: LD_EXP 113
61123: PUSH
61124: FOR_TO
61125: IFFALSE 61469
// begin if factory in mc_bases [ i ] then
61127: LD_VAR 0 2
61131: PUSH
61132: LD_EXP 113
61136: PUSH
61137: LD_VAR 0 4
61141: ARRAY
61142: IN
61143: IFFALSE 61467
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61145: LD_EXP 135
61149: PUSH
61150: LD_VAR 0 4
61154: ARRAY
61155: PUSH
61156: LD_EXP 124
61160: PUSH
61161: LD_VAR 0 4
61165: ARRAY
61166: LESS
61167: PUSH
61168: LD_VAR 0 1
61172: PPUSH
61173: CALL_OW 264
61177: PUSH
61178: LD_INT 31
61180: PUSH
61181: LD_INT 32
61183: PUSH
61184: LD_INT 51
61186: PUSH
61187: LD_EXP 96
61191: PUSH
61192: LD_INT 12
61194: PUSH
61195: LD_INT 30
61197: PUSH
61198: LD_EXP 95
61202: PUSH
61203: LD_INT 11
61205: PUSH
61206: LD_INT 53
61208: PUSH
61209: LD_INT 14
61211: PUSH
61212: LD_EXP 99
61216: PUSH
61217: LD_INT 29
61219: PUSH
61220: LD_EXP 97
61224: PUSH
61225: LD_INT 13
61227: PUSH
61228: LD_INT 52
61230: PUSH
61231: LD_INT 48
61233: PUSH
61234: LD_INT 8
61236: PUSH
61237: EMPTY
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: LIST
61254: LIST
61255: IN
61256: NOT
61257: AND
61258: IFFALSE 61306
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61260: LD_ADDR_EXP 135
61264: PUSH
61265: LD_EXP 135
61269: PPUSH
61270: LD_VAR 0 4
61274: PUSH
61275: LD_EXP 135
61279: PUSH
61280: LD_VAR 0 4
61284: ARRAY
61285: PUSH
61286: LD_INT 1
61288: PLUS
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PPUSH
61294: LD_VAR 0 1
61298: PPUSH
61299: CALL 70058 0 3
61303: ST_TO_ADDR
61304: GO 61350
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61306: LD_ADDR_EXP 132
61310: PUSH
61311: LD_EXP 132
61315: PPUSH
61316: LD_VAR 0 4
61320: PUSH
61321: LD_EXP 132
61325: PUSH
61326: LD_VAR 0 4
61330: ARRAY
61331: PUSH
61332: LD_INT 1
61334: PLUS
61335: PUSH
61336: EMPTY
61337: LIST
61338: LIST
61339: PPUSH
61340: LD_VAR 0 1
61344: PPUSH
61345: CALL 70058 0 3
61349: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61350: LD_VAR 0 1
61354: PPUSH
61355: CALL_OW 263
61359: PUSH
61360: LD_INT 2
61362: EQUAL
61363: IFFALSE 61383
// begin repeat wait ( 0 0$1 ) ;
61365: LD_INT 35
61367: PPUSH
61368: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61372: LD_VAR 0 1
61376: PPUSH
61377: CALL_OW 312
61381: IFFALSE 61365
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61383: LD_VAR 0 1
61387: PPUSH
61388: LD_EXP 137
61392: PUSH
61393: LD_VAR 0 4
61397: ARRAY
61398: PPUSH
61399: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61403: LD_VAR 0 1
61407: PPUSH
61408: CALL_OW 263
61412: PUSH
61413: LD_INT 1
61415: NONEQUAL
61416: IFFALSE 61420
// break ;
61418: GO 61469
// repeat wait ( 0 0$1 ) ;
61420: LD_INT 35
61422: PPUSH
61423: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61427: LD_VAR 0 1
61431: PPUSH
61432: LD_EXP 137
61436: PUSH
61437: LD_VAR 0 4
61441: ARRAY
61442: PPUSH
61443: CALL_OW 308
61447: IFFALSE 61420
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61449: LD_VAR 0 1
61453: PPUSH
61454: CALL_OW 311
61458: PPUSH
61459: CALL_OW 121
// exit ;
61463: POP
61464: POP
61465: GO 61471
// end ; end ;
61467: GO 61124
61469: POP
61470: POP
// end ;
61471: LD_VAR 0 3
61475: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61476: LD_INT 0
61478: PPUSH
61479: PPUSH
61480: PPUSH
61481: PPUSH
// if not mc_bases or not skirmish then
61482: LD_EXP 113
61486: NOT
61487: PUSH
61488: LD_EXP 111
61492: NOT
61493: OR
61494: IFFALSE 61498
// exit ;
61496: GO 61851
// repeat wait ( 0 0$1 ) ;
61498: LD_INT 35
61500: PPUSH
61501: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61505: LD_VAR 0 2
61509: PPUSH
61510: LD_VAR 0 3
61514: PPUSH
61515: CALL_OW 284
61519: IFFALSE 61498
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61521: LD_VAR 0 2
61525: PPUSH
61526: LD_VAR 0 3
61530: PPUSH
61531: CALL_OW 283
61535: PUSH
61536: LD_INT 4
61538: EQUAL
61539: IFFALSE 61543
// exit ;
61541: GO 61851
// for i = 1 to mc_bases do
61543: LD_ADDR_VAR 0 7
61547: PUSH
61548: DOUBLE
61549: LD_INT 1
61551: DEC
61552: ST_TO_ADDR
61553: LD_EXP 113
61557: PUSH
61558: FOR_TO
61559: IFFALSE 61849
// begin if mc_crates_area [ i ] then
61561: LD_EXP 131
61565: PUSH
61566: LD_VAR 0 7
61570: ARRAY
61571: IFFALSE 61682
// for j in mc_crates_area [ i ] do
61573: LD_ADDR_VAR 0 8
61577: PUSH
61578: LD_EXP 131
61582: PUSH
61583: LD_VAR 0 7
61587: ARRAY
61588: PUSH
61589: FOR_IN
61590: IFFALSE 61680
// if InArea ( x , y , j ) then
61592: LD_VAR 0 2
61596: PPUSH
61597: LD_VAR 0 3
61601: PPUSH
61602: LD_VAR 0 8
61606: PPUSH
61607: CALL_OW 309
61611: IFFALSE 61678
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61613: LD_ADDR_EXP 129
61617: PUSH
61618: LD_EXP 129
61622: PPUSH
61623: LD_VAR 0 7
61627: PUSH
61628: LD_EXP 129
61632: PUSH
61633: LD_VAR 0 7
61637: ARRAY
61638: PUSH
61639: LD_INT 1
61641: PLUS
61642: PUSH
61643: EMPTY
61644: LIST
61645: LIST
61646: PPUSH
61647: LD_VAR 0 4
61651: PUSH
61652: LD_VAR 0 2
61656: PUSH
61657: LD_VAR 0 3
61661: PUSH
61662: EMPTY
61663: LIST
61664: LIST
61665: LIST
61666: PPUSH
61667: CALL 70058 0 3
61671: ST_TO_ADDR
// exit ;
61672: POP
61673: POP
61674: POP
61675: POP
61676: GO 61851
// end ;
61678: GO 61589
61680: POP
61681: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61682: LD_ADDR_VAR 0 9
61686: PUSH
61687: LD_EXP 113
61691: PUSH
61692: LD_VAR 0 7
61696: ARRAY
61697: PPUSH
61698: LD_INT 2
61700: PUSH
61701: LD_INT 30
61703: PUSH
61704: LD_INT 0
61706: PUSH
61707: EMPTY
61708: LIST
61709: LIST
61710: PUSH
61711: LD_INT 30
61713: PUSH
61714: LD_INT 1
61716: PUSH
61717: EMPTY
61718: LIST
61719: LIST
61720: PUSH
61721: EMPTY
61722: LIST
61723: LIST
61724: LIST
61725: PPUSH
61726: CALL_OW 72
61730: ST_TO_ADDR
// if not depot then
61731: LD_VAR 0 9
61735: NOT
61736: IFFALSE 61740
// continue ;
61738: GO 61558
// for j in depot do
61740: LD_ADDR_VAR 0 8
61744: PUSH
61745: LD_VAR 0 9
61749: PUSH
61750: FOR_IN
61751: IFFALSE 61845
// if GetDistUnitXY ( j , x , y ) < 30 then
61753: LD_VAR 0 8
61757: PPUSH
61758: LD_VAR 0 2
61762: PPUSH
61763: LD_VAR 0 3
61767: PPUSH
61768: CALL_OW 297
61772: PUSH
61773: LD_INT 30
61775: LESS
61776: IFFALSE 61843
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61778: LD_ADDR_EXP 129
61782: PUSH
61783: LD_EXP 129
61787: PPUSH
61788: LD_VAR 0 7
61792: PUSH
61793: LD_EXP 129
61797: PUSH
61798: LD_VAR 0 7
61802: ARRAY
61803: PUSH
61804: LD_INT 1
61806: PLUS
61807: PUSH
61808: EMPTY
61809: LIST
61810: LIST
61811: PPUSH
61812: LD_VAR 0 4
61816: PUSH
61817: LD_VAR 0 2
61821: PUSH
61822: LD_VAR 0 3
61826: PUSH
61827: EMPTY
61828: LIST
61829: LIST
61830: LIST
61831: PPUSH
61832: CALL 70058 0 3
61836: ST_TO_ADDR
// exit ;
61837: POP
61838: POP
61839: POP
61840: POP
61841: GO 61851
// end ;
61843: GO 61750
61845: POP
61846: POP
// end ;
61847: GO 61558
61849: POP
61850: POP
// end ;
61851: LD_VAR 0 6
61855: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61856: LD_INT 0
61858: PPUSH
61859: PPUSH
61860: PPUSH
61861: PPUSH
// if not mc_bases or not skirmish then
61862: LD_EXP 113
61866: NOT
61867: PUSH
61868: LD_EXP 111
61872: NOT
61873: OR
61874: IFFALSE 61878
// exit ;
61876: GO 62155
// side := GetSide ( lab ) ;
61878: LD_ADDR_VAR 0 4
61882: PUSH
61883: LD_VAR 0 2
61887: PPUSH
61888: CALL_OW 255
61892: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61893: LD_VAR 0 4
61897: PUSH
61898: LD_EXP 139
61902: IN
61903: NOT
61904: PUSH
61905: LD_EXP 140
61909: NOT
61910: OR
61911: PUSH
61912: LD_EXP 113
61916: NOT
61917: OR
61918: IFFALSE 61922
// exit ;
61920: GO 62155
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61922: LD_ADDR_EXP 140
61926: PUSH
61927: LD_EXP 140
61931: PPUSH
61932: LD_VAR 0 4
61936: PPUSH
61937: LD_EXP 140
61941: PUSH
61942: LD_VAR 0 4
61946: ARRAY
61947: PUSH
61948: LD_VAR 0 1
61952: DIFF
61953: PPUSH
61954: CALL_OW 1
61958: ST_TO_ADDR
// for i = 1 to mc_bases do
61959: LD_ADDR_VAR 0 5
61963: PUSH
61964: DOUBLE
61965: LD_INT 1
61967: DEC
61968: ST_TO_ADDR
61969: LD_EXP 113
61973: PUSH
61974: FOR_TO
61975: IFFALSE 62153
// begin if lab in mc_bases [ i ] then
61977: LD_VAR 0 2
61981: PUSH
61982: LD_EXP 113
61986: PUSH
61987: LD_VAR 0 5
61991: ARRAY
61992: IN
61993: IFFALSE 62151
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61995: LD_VAR 0 1
61999: PUSH
62000: LD_INT 11
62002: PUSH
62003: LD_INT 4
62005: PUSH
62006: LD_INT 3
62008: PUSH
62009: LD_INT 2
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: LIST
62016: LIST
62017: IN
62018: PUSH
62019: LD_EXP 143
62023: PUSH
62024: LD_VAR 0 5
62028: ARRAY
62029: AND
62030: IFFALSE 62151
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62032: LD_ADDR_VAR 0 6
62036: PUSH
62037: LD_EXP 143
62041: PUSH
62042: LD_VAR 0 5
62046: ARRAY
62047: PUSH
62048: LD_INT 1
62050: ARRAY
62051: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62052: LD_ADDR_EXP 143
62056: PUSH
62057: LD_EXP 143
62061: PPUSH
62062: LD_VAR 0 5
62066: PPUSH
62067: EMPTY
62068: PPUSH
62069: CALL_OW 1
62073: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62074: LD_VAR 0 6
62078: PPUSH
62079: LD_INT 0
62081: PPUSH
62082: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62086: LD_VAR 0 6
62090: PPUSH
62091: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62095: LD_ADDR_EXP 142
62099: PUSH
62100: LD_EXP 142
62104: PPUSH
62105: LD_VAR 0 5
62109: PPUSH
62110: LD_EXP 142
62114: PUSH
62115: LD_VAR 0 5
62119: ARRAY
62120: PPUSH
62121: LD_INT 1
62123: PPUSH
62124: LD_VAR 0 6
62128: PPUSH
62129: CALL_OW 2
62133: PPUSH
62134: CALL_OW 1
62138: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62139: LD_VAR 0 5
62143: PPUSH
62144: LD_INT 112
62146: PPUSH
62147: CALL 39167 0 2
// end ; end ; end ;
62151: GO 61974
62153: POP
62154: POP
// end ;
62155: LD_VAR 0 3
62159: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62160: LD_INT 0
62162: PPUSH
62163: PPUSH
62164: PPUSH
62165: PPUSH
62166: PPUSH
62167: PPUSH
62168: PPUSH
62169: PPUSH
// if not mc_bases or not skirmish then
62170: LD_EXP 113
62174: NOT
62175: PUSH
62176: LD_EXP 111
62180: NOT
62181: OR
62182: IFFALSE 62186
// exit ;
62184: GO 63557
// for i = 1 to mc_bases do
62186: LD_ADDR_VAR 0 3
62190: PUSH
62191: DOUBLE
62192: LD_INT 1
62194: DEC
62195: ST_TO_ADDR
62196: LD_EXP 113
62200: PUSH
62201: FOR_TO
62202: IFFALSE 63555
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62204: LD_VAR 0 1
62208: PUSH
62209: LD_EXP 113
62213: PUSH
62214: LD_VAR 0 3
62218: ARRAY
62219: IN
62220: PUSH
62221: LD_VAR 0 1
62225: PUSH
62226: LD_EXP 120
62230: PUSH
62231: LD_VAR 0 3
62235: ARRAY
62236: IN
62237: OR
62238: PUSH
62239: LD_VAR 0 1
62243: PUSH
62244: LD_EXP 135
62248: PUSH
62249: LD_VAR 0 3
62253: ARRAY
62254: IN
62255: OR
62256: PUSH
62257: LD_VAR 0 1
62261: PUSH
62262: LD_EXP 132
62266: PUSH
62267: LD_VAR 0 3
62271: ARRAY
62272: IN
62273: OR
62274: PUSH
62275: LD_VAR 0 1
62279: PUSH
62280: LD_EXP 142
62284: PUSH
62285: LD_VAR 0 3
62289: ARRAY
62290: IN
62291: OR
62292: PUSH
62293: LD_VAR 0 1
62297: PUSH
62298: LD_EXP 143
62302: PUSH
62303: LD_VAR 0 3
62307: ARRAY
62308: IN
62309: OR
62310: IFFALSE 63553
// begin if un in mc_ape [ i ] then
62312: LD_VAR 0 1
62316: PUSH
62317: LD_EXP 142
62321: PUSH
62322: LD_VAR 0 3
62326: ARRAY
62327: IN
62328: IFFALSE 62367
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62330: LD_ADDR_EXP 142
62334: PUSH
62335: LD_EXP 142
62339: PPUSH
62340: LD_VAR 0 3
62344: PPUSH
62345: LD_EXP 142
62349: PUSH
62350: LD_VAR 0 3
62354: ARRAY
62355: PUSH
62356: LD_VAR 0 1
62360: DIFF
62361: PPUSH
62362: CALL_OW 1
62366: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62367: LD_VAR 0 1
62371: PUSH
62372: LD_EXP 143
62376: PUSH
62377: LD_VAR 0 3
62381: ARRAY
62382: IN
62383: IFFALSE 62407
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62385: LD_ADDR_EXP 143
62389: PUSH
62390: LD_EXP 143
62394: PPUSH
62395: LD_VAR 0 3
62399: PPUSH
62400: EMPTY
62401: PPUSH
62402: CALL_OW 1
62406: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62407: LD_VAR 0 1
62411: PPUSH
62412: CALL_OW 247
62416: PUSH
62417: LD_INT 2
62419: EQUAL
62420: PUSH
62421: LD_VAR 0 1
62425: PPUSH
62426: CALL_OW 110
62430: PUSH
62431: LD_INT 20
62433: EQUAL
62434: PUSH
62435: LD_VAR 0 1
62439: PUSH
62440: LD_EXP 135
62444: PUSH
62445: LD_VAR 0 3
62449: ARRAY
62450: IN
62451: OR
62452: PUSH
62453: LD_VAR 0 1
62457: PPUSH
62458: CALL_OW 264
62462: PUSH
62463: LD_INT 12
62465: PUSH
62466: LD_INT 51
62468: PUSH
62469: LD_EXP 96
62473: PUSH
62474: LD_INT 32
62476: PUSH
62477: LD_INT 13
62479: PUSH
62480: LD_INT 52
62482: PUSH
62483: LD_INT 31
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: LIST
62490: LIST
62491: LIST
62492: LIST
62493: LIST
62494: IN
62495: OR
62496: AND
62497: IFFALSE 62805
// begin if un in mc_defender [ i ] then
62499: LD_VAR 0 1
62503: PUSH
62504: LD_EXP 135
62508: PUSH
62509: LD_VAR 0 3
62513: ARRAY
62514: IN
62515: IFFALSE 62554
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62517: LD_ADDR_EXP 135
62521: PUSH
62522: LD_EXP 135
62526: PPUSH
62527: LD_VAR 0 3
62531: PPUSH
62532: LD_EXP 135
62536: PUSH
62537: LD_VAR 0 3
62541: ARRAY
62542: PUSH
62543: LD_VAR 0 1
62547: DIFF
62548: PPUSH
62549: CALL_OW 1
62553: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62554: LD_ADDR_VAR 0 8
62558: PUSH
62559: LD_VAR 0 3
62563: PPUSH
62564: LD_INT 3
62566: PPUSH
62567: CALL 59223 0 2
62571: ST_TO_ADDR
// if fac then
62572: LD_VAR 0 8
62576: IFFALSE 62805
// begin for j in fac do
62578: LD_ADDR_VAR 0 4
62582: PUSH
62583: LD_VAR 0 8
62587: PUSH
62588: FOR_IN
62589: IFFALSE 62803
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62591: LD_ADDR_VAR 0 9
62595: PUSH
62596: LD_VAR 0 8
62600: PPUSH
62601: LD_VAR 0 1
62605: PPUSH
62606: CALL_OW 265
62610: PPUSH
62611: LD_VAR 0 1
62615: PPUSH
62616: CALL_OW 262
62620: PPUSH
62621: LD_VAR 0 1
62625: PPUSH
62626: CALL_OW 263
62630: PPUSH
62631: LD_VAR 0 1
62635: PPUSH
62636: CALL_OW 264
62640: PPUSH
62641: CALL 67590 0 5
62645: ST_TO_ADDR
// if components then
62646: LD_VAR 0 9
62650: IFFALSE 62801
// begin if GetWeapon ( un ) = ar_control_tower then
62652: LD_VAR 0 1
62656: PPUSH
62657: CALL_OW 264
62661: PUSH
62662: LD_INT 31
62664: EQUAL
62665: IFFALSE 62782
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62667: LD_VAR 0 1
62671: PPUSH
62672: CALL_OW 311
62676: PPUSH
62677: LD_INT 0
62679: PPUSH
62680: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62684: LD_ADDR_EXP 153
62688: PUSH
62689: LD_EXP 153
62693: PPUSH
62694: LD_VAR 0 3
62698: PPUSH
62699: LD_EXP 153
62703: PUSH
62704: LD_VAR 0 3
62708: ARRAY
62709: PUSH
62710: LD_VAR 0 1
62714: PPUSH
62715: CALL_OW 311
62719: DIFF
62720: PPUSH
62721: CALL_OW 1
62725: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62726: LD_ADDR_VAR 0 7
62730: PUSH
62731: LD_EXP 134
62735: PUSH
62736: LD_VAR 0 3
62740: ARRAY
62741: PPUSH
62742: LD_INT 1
62744: PPUSH
62745: LD_VAR 0 9
62749: PPUSH
62750: CALL_OW 2
62754: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62755: LD_ADDR_EXP 134
62759: PUSH
62760: LD_EXP 134
62764: PPUSH
62765: LD_VAR 0 3
62769: PPUSH
62770: LD_VAR 0 7
62774: PPUSH
62775: CALL_OW 1
62779: ST_TO_ADDR
// end else
62780: GO 62799
// MC_InsertProduceList ( i , [ components ] ) ;
62782: LD_VAR 0 3
62786: PPUSH
62787: LD_VAR 0 9
62791: PUSH
62792: EMPTY
62793: LIST
62794: PPUSH
62795: CALL 58768 0 2
// break ;
62799: GO 62803
// end ; end ;
62801: GO 62588
62803: POP
62804: POP
// end ; end ; if GetType ( un ) = unit_building then
62805: LD_VAR 0 1
62809: PPUSH
62810: CALL_OW 247
62814: PUSH
62815: LD_INT 3
62817: EQUAL
62818: IFFALSE 63221
// begin btype := GetBType ( un ) ;
62820: LD_ADDR_VAR 0 5
62824: PUSH
62825: LD_VAR 0 1
62829: PPUSH
62830: CALL_OW 266
62834: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62835: LD_VAR 0 5
62839: PUSH
62840: LD_INT 29
62842: PUSH
62843: LD_INT 30
62845: PUSH
62846: EMPTY
62847: LIST
62848: LIST
62849: IN
62850: IFFALSE 62923
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62852: LD_VAR 0 1
62856: PPUSH
62857: CALL_OW 250
62861: PPUSH
62862: LD_VAR 0 1
62866: PPUSH
62867: CALL_OW 251
62871: PPUSH
62872: LD_VAR 0 1
62876: PPUSH
62877: CALL_OW 255
62881: PPUSH
62882: CALL_OW 440
62886: NOT
62887: IFFALSE 62923
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62889: LD_VAR 0 1
62893: PPUSH
62894: CALL_OW 250
62898: PPUSH
62899: LD_VAR 0 1
62903: PPUSH
62904: CALL_OW 251
62908: PPUSH
62909: LD_VAR 0 1
62913: PPUSH
62914: CALL_OW 255
62918: PPUSH
62919: CALL_OW 441
// end ; if btype = b_warehouse then
62923: LD_VAR 0 5
62927: PUSH
62928: LD_INT 1
62930: EQUAL
62931: IFFALSE 62949
// begin btype := b_depot ;
62933: LD_ADDR_VAR 0 5
62937: PUSH
62938: LD_INT 0
62940: ST_TO_ADDR
// pos := 1 ;
62941: LD_ADDR_VAR 0 6
62945: PUSH
62946: LD_INT 1
62948: ST_TO_ADDR
// end ; if btype = b_factory then
62949: LD_VAR 0 5
62953: PUSH
62954: LD_INT 3
62956: EQUAL
62957: IFFALSE 62975
// begin btype := b_workshop ;
62959: LD_ADDR_VAR 0 5
62963: PUSH
62964: LD_INT 2
62966: ST_TO_ADDR
// pos := 1 ;
62967: LD_ADDR_VAR 0 6
62971: PUSH
62972: LD_INT 1
62974: ST_TO_ADDR
// end ; if btype = b_barracks then
62975: LD_VAR 0 5
62979: PUSH
62980: LD_INT 5
62982: EQUAL
62983: IFFALSE 62993
// btype := b_armoury ;
62985: LD_ADDR_VAR 0 5
62989: PUSH
62990: LD_INT 4
62992: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62993: LD_VAR 0 5
62997: PUSH
62998: LD_INT 7
63000: PUSH
63001: LD_INT 8
63003: PUSH
63004: EMPTY
63005: LIST
63006: LIST
63007: IN
63008: IFFALSE 63018
// btype := b_lab ;
63010: LD_ADDR_VAR 0 5
63014: PUSH
63015: LD_INT 6
63017: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63018: LD_ADDR_EXP 118
63022: PUSH
63023: LD_EXP 118
63027: PPUSH
63028: LD_VAR 0 3
63032: PUSH
63033: LD_EXP 118
63037: PUSH
63038: LD_VAR 0 3
63042: ARRAY
63043: PUSH
63044: LD_INT 1
63046: PLUS
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: PPUSH
63052: LD_VAR 0 5
63056: PUSH
63057: LD_VAR 0 1
63061: PPUSH
63062: CALL_OW 250
63066: PUSH
63067: LD_VAR 0 1
63071: PPUSH
63072: CALL_OW 251
63076: PUSH
63077: LD_VAR 0 1
63081: PPUSH
63082: CALL_OW 254
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: LIST
63091: LIST
63092: PPUSH
63093: CALL 70058 0 3
63097: ST_TO_ADDR
// if pos = 1 then
63098: LD_VAR 0 6
63102: PUSH
63103: LD_INT 1
63105: EQUAL
63106: IFFALSE 63221
// begin tmp := mc_build_list [ i ] ;
63108: LD_ADDR_VAR 0 7
63112: PUSH
63113: LD_EXP 118
63117: PUSH
63118: LD_VAR 0 3
63122: ARRAY
63123: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63124: LD_VAR 0 7
63128: PPUSH
63129: LD_INT 2
63131: PUSH
63132: LD_INT 30
63134: PUSH
63135: LD_INT 0
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: PUSH
63142: LD_INT 30
63144: PUSH
63145: LD_INT 1
63147: PUSH
63148: EMPTY
63149: LIST
63150: LIST
63151: PUSH
63152: EMPTY
63153: LIST
63154: LIST
63155: LIST
63156: PPUSH
63157: CALL_OW 72
63161: IFFALSE 63171
// pos := 2 ;
63163: LD_ADDR_VAR 0 6
63167: PUSH
63168: LD_INT 2
63170: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63171: LD_ADDR_VAR 0 7
63175: PUSH
63176: LD_VAR 0 7
63180: PPUSH
63181: LD_VAR 0 6
63185: PPUSH
63186: LD_VAR 0 7
63190: PPUSH
63191: CALL 70384 0 3
63195: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63196: LD_ADDR_EXP 118
63200: PUSH
63201: LD_EXP 118
63205: PPUSH
63206: LD_VAR 0 3
63210: PPUSH
63211: LD_VAR 0 7
63215: PPUSH
63216: CALL_OW 1
63220: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63221: LD_VAR 0 1
63225: PUSH
63226: LD_EXP 113
63230: PUSH
63231: LD_VAR 0 3
63235: ARRAY
63236: IN
63237: IFFALSE 63276
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63239: LD_ADDR_EXP 113
63243: PUSH
63244: LD_EXP 113
63248: PPUSH
63249: LD_VAR 0 3
63253: PPUSH
63254: LD_EXP 113
63258: PUSH
63259: LD_VAR 0 3
63263: ARRAY
63264: PUSH
63265: LD_VAR 0 1
63269: DIFF
63270: PPUSH
63271: CALL_OW 1
63275: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63276: LD_VAR 0 1
63280: PUSH
63281: LD_EXP 120
63285: PUSH
63286: LD_VAR 0 3
63290: ARRAY
63291: IN
63292: IFFALSE 63331
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63294: LD_ADDR_EXP 120
63298: PUSH
63299: LD_EXP 120
63303: PPUSH
63304: LD_VAR 0 3
63308: PPUSH
63309: LD_EXP 120
63313: PUSH
63314: LD_VAR 0 3
63318: ARRAY
63319: PUSH
63320: LD_VAR 0 1
63324: DIFF
63325: PPUSH
63326: CALL_OW 1
63330: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63331: LD_VAR 0 1
63335: PUSH
63336: LD_EXP 132
63340: PUSH
63341: LD_VAR 0 3
63345: ARRAY
63346: IN
63347: IFFALSE 63386
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63349: LD_ADDR_EXP 132
63353: PUSH
63354: LD_EXP 132
63358: PPUSH
63359: LD_VAR 0 3
63363: PPUSH
63364: LD_EXP 132
63368: PUSH
63369: LD_VAR 0 3
63373: ARRAY
63374: PUSH
63375: LD_VAR 0 1
63379: DIFF
63380: PPUSH
63381: CALL_OW 1
63385: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63386: LD_VAR 0 1
63390: PUSH
63391: LD_EXP 135
63395: PUSH
63396: LD_VAR 0 3
63400: ARRAY
63401: IN
63402: IFFALSE 63441
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63404: LD_ADDR_EXP 135
63408: PUSH
63409: LD_EXP 135
63413: PPUSH
63414: LD_VAR 0 3
63418: PPUSH
63419: LD_EXP 135
63423: PUSH
63424: LD_VAR 0 3
63428: ARRAY
63429: PUSH
63430: LD_VAR 0 1
63434: DIFF
63435: PPUSH
63436: CALL_OW 1
63440: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63441: LD_VAR 0 1
63445: PUSH
63446: LD_EXP 122
63450: PUSH
63451: LD_VAR 0 3
63455: ARRAY
63456: IN
63457: IFFALSE 63496
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63459: LD_ADDR_EXP 122
63463: PUSH
63464: LD_EXP 122
63468: PPUSH
63469: LD_VAR 0 3
63473: PPUSH
63474: LD_EXP 122
63478: PUSH
63479: LD_VAR 0 3
63483: ARRAY
63484: PUSH
63485: LD_VAR 0 1
63489: DIFF
63490: PPUSH
63491: CALL_OW 1
63495: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63496: LD_VAR 0 1
63500: PUSH
63501: LD_EXP 121
63505: PUSH
63506: LD_VAR 0 3
63510: ARRAY
63511: IN
63512: IFFALSE 63551
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63514: LD_ADDR_EXP 121
63518: PUSH
63519: LD_EXP 121
63523: PPUSH
63524: LD_VAR 0 3
63528: PPUSH
63529: LD_EXP 121
63533: PUSH
63534: LD_VAR 0 3
63538: ARRAY
63539: PUSH
63540: LD_VAR 0 1
63544: DIFF
63545: PPUSH
63546: CALL_OW 1
63550: ST_TO_ADDR
// end ; break ;
63551: GO 63555
// end ;
63553: GO 62201
63555: POP
63556: POP
// end ;
63557: LD_VAR 0 2
63561: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63562: LD_INT 0
63564: PPUSH
63565: PPUSH
63566: PPUSH
// if not mc_bases or not skirmish then
63567: LD_EXP 113
63571: NOT
63572: PUSH
63573: LD_EXP 111
63577: NOT
63578: OR
63579: IFFALSE 63583
// exit ;
63581: GO 63798
// for i = 1 to mc_bases do
63583: LD_ADDR_VAR 0 3
63587: PUSH
63588: DOUBLE
63589: LD_INT 1
63591: DEC
63592: ST_TO_ADDR
63593: LD_EXP 113
63597: PUSH
63598: FOR_TO
63599: IFFALSE 63796
// begin if building in mc_construct_list [ i ] then
63601: LD_VAR 0 1
63605: PUSH
63606: LD_EXP 120
63610: PUSH
63611: LD_VAR 0 3
63615: ARRAY
63616: IN
63617: IFFALSE 63794
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63619: LD_ADDR_EXP 120
63623: PUSH
63624: LD_EXP 120
63628: PPUSH
63629: LD_VAR 0 3
63633: PPUSH
63634: LD_EXP 120
63638: PUSH
63639: LD_VAR 0 3
63643: ARRAY
63644: PUSH
63645: LD_VAR 0 1
63649: DIFF
63650: PPUSH
63651: CALL_OW 1
63655: ST_TO_ADDR
// if building in mc_lab [ i ] then
63656: LD_VAR 0 1
63660: PUSH
63661: LD_EXP 146
63665: PUSH
63666: LD_VAR 0 3
63670: ARRAY
63671: IN
63672: IFFALSE 63727
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63674: LD_ADDR_EXP 147
63678: PUSH
63679: LD_EXP 147
63683: PPUSH
63684: LD_VAR 0 3
63688: PPUSH
63689: LD_EXP 147
63693: PUSH
63694: LD_VAR 0 3
63698: ARRAY
63699: PPUSH
63700: LD_INT 1
63702: PPUSH
63703: LD_EXP 147
63707: PUSH
63708: LD_VAR 0 3
63712: ARRAY
63713: PPUSH
63714: LD_INT 0
63716: PPUSH
63717: CALL 69476 0 4
63721: PPUSH
63722: CALL_OW 1
63726: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63727: LD_VAR 0 1
63731: PUSH
63732: LD_EXP 113
63736: PUSH
63737: LD_VAR 0 3
63741: ARRAY
63742: IN
63743: NOT
63744: IFFALSE 63790
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63746: LD_ADDR_EXP 113
63750: PUSH
63751: LD_EXP 113
63755: PPUSH
63756: LD_VAR 0 3
63760: PUSH
63761: LD_EXP 113
63765: PUSH
63766: LD_VAR 0 3
63770: ARRAY
63771: PUSH
63772: LD_INT 1
63774: PLUS
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: PPUSH
63780: LD_VAR 0 1
63784: PPUSH
63785: CALL 70058 0 3
63789: ST_TO_ADDR
// exit ;
63790: POP
63791: POP
63792: GO 63798
// end ; end ;
63794: GO 63598
63796: POP
63797: POP
// end ;
63798: LD_VAR 0 2
63802: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63803: LD_INT 0
63805: PPUSH
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
63811: PPUSH
// if not mc_bases or not skirmish then
63812: LD_EXP 113
63816: NOT
63817: PUSH
63818: LD_EXP 111
63822: NOT
63823: OR
63824: IFFALSE 63828
// exit ;
63826: GO 64489
// for i = 1 to mc_bases do
63828: LD_ADDR_VAR 0 3
63832: PUSH
63833: DOUBLE
63834: LD_INT 1
63836: DEC
63837: ST_TO_ADDR
63838: LD_EXP 113
63842: PUSH
63843: FOR_TO
63844: IFFALSE 64487
// begin if building in mc_construct_list [ i ] then
63846: LD_VAR 0 1
63850: PUSH
63851: LD_EXP 120
63855: PUSH
63856: LD_VAR 0 3
63860: ARRAY
63861: IN
63862: IFFALSE 64485
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63864: LD_ADDR_EXP 120
63868: PUSH
63869: LD_EXP 120
63873: PPUSH
63874: LD_VAR 0 3
63878: PPUSH
63879: LD_EXP 120
63883: PUSH
63884: LD_VAR 0 3
63888: ARRAY
63889: PUSH
63890: LD_VAR 0 1
63894: DIFF
63895: PPUSH
63896: CALL_OW 1
63900: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63901: LD_ADDR_EXP 113
63905: PUSH
63906: LD_EXP 113
63910: PPUSH
63911: LD_VAR 0 3
63915: PUSH
63916: LD_EXP 113
63920: PUSH
63921: LD_VAR 0 3
63925: ARRAY
63926: PUSH
63927: LD_INT 1
63929: PLUS
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PPUSH
63935: LD_VAR 0 1
63939: PPUSH
63940: CALL 70058 0 3
63944: ST_TO_ADDR
// btype := GetBType ( building ) ;
63945: LD_ADDR_VAR 0 5
63949: PUSH
63950: LD_VAR 0 1
63954: PPUSH
63955: CALL_OW 266
63959: ST_TO_ADDR
// side := GetSide ( building ) ;
63960: LD_ADDR_VAR 0 8
63964: PUSH
63965: LD_VAR 0 1
63969: PPUSH
63970: CALL_OW 255
63974: ST_TO_ADDR
// if btype = b_lab then
63975: LD_VAR 0 5
63979: PUSH
63980: LD_INT 6
63982: EQUAL
63983: IFFALSE 64033
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63985: LD_ADDR_EXP 146
63989: PUSH
63990: LD_EXP 146
63994: PPUSH
63995: LD_VAR 0 3
63999: PUSH
64000: LD_EXP 146
64004: PUSH
64005: LD_VAR 0 3
64009: ARRAY
64010: PUSH
64011: LD_INT 1
64013: PLUS
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PPUSH
64019: LD_VAR 0 1
64023: PPUSH
64024: CALL 70058 0 3
64028: ST_TO_ADDR
// exit ;
64029: POP
64030: POP
64031: GO 64489
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64033: LD_VAR 0 5
64037: PUSH
64038: LD_INT 0
64040: PUSH
64041: LD_INT 2
64043: PUSH
64044: LD_INT 4
64046: PUSH
64047: EMPTY
64048: LIST
64049: LIST
64050: LIST
64051: IN
64052: IFFALSE 64176
// begin if btype = b_armoury then
64054: LD_VAR 0 5
64058: PUSH
64059: LD_INT 4
64061: EQUAL
64062: IFFALSE 64072
// btype := b_barracks ;
64064: LD_ADDR_VAR 0 5
64068: PUSH
64069: LD_INT 5
64071: ST_TO_ADDR
// if btype = b_depot then
64072: LD_VAR 0 5
64076: PUSH
64077: LD_INT 0
64079: EQUAL
64080: IFFALSE 64090
// btype := b_warehouse ;
64082: LD_ADDR_VAR 0 5
64086: PUSH
64087: LD_INT 1
64089: ST_TO_ADDR
// if btype = b_workshop then
64090: LD_VAR 0 5
64094: PUSH
64095: LD_INT 2
64097: EQUAL
64098: IFFALSE 64108
// btype := b_factory ;
64100: LD_ADDR_VAR 0 5
64104: PUSH
64105: LD_INT 3
64107: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64108: LD_VAR 0 5
64112: PPUSH
64113: LD_VAR 0 8
64117: PPUSH
64118: CALL_OW 323
64122: PUSH
64123: LD_INT 1
64125: EQUAL
64126: IFFALSE 64172
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64128: LD_ADDR_EXP 145
64132: PUSH
64133: LD_EXP 145
64137: PPUSH
64138: LD_VAR 0 3
64142: PUSH
64143: LD_EXP 145
64147: PUSH
64148: LD_VAR 0 3
64152: ARRAY
64153: PUSH
64154: LD_INT 1
64156: PLUS
64157: PUSH
64158: EMPTY
64159: LIST
64160: LIST
64161: PPUSH
64162: LD_VAR 0 1
64166: PPUSH
64167: CALL 70058 0 3
64171: ST_TO_ADDR
// exit ;
64172: POP
64173: POP
64174: GO 64489
// end ; if btype in [ b_bunker , b_turret ] then
64176: LD_VAR 0 5
64180: PUSH
64181: LD_INT 32
64183: PUSH
64184: LD_INT 33
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: IN
64191: IFFALSE 64481
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64193: LD_ADDR_EXP 121
64197: PUSH
64198: LD_EXP 121
64202: PPUSH
64203: LD_VAR 0 3
64207: PUSH
64208: LD_EXP 121
64212: PUSH
64213: LD_VAR 0 3
64217: ARRAY
64218: PUSH
64219: LD_INT 1
64221: PLUS
64222: PUSH
64223: EMPTY
64224: LIST
64225: LIST
64226: PPUSH
64227: LD_VAR 0 1
64231: PPUSH
64232: CALL 70058 0 3
64236: ST_TO_ADDR
// if btype = b_bunker then
64237: LD_VAR 0 5
64241: PUSH
64242: LD_INT 32
64244: EQUAL
64245: IFFALSE 64481
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64247: LD_ADDR_EXP 122
64251: PUSH
64252: LD_EXP 122
64256: PPUSH
64257: LD_VAR 0 3
64261: PUSH
64262: LD_EXP 122
64266: PUSH
64267: LD_VAR 0 3
64271: ARRAY
64272: PUSH
64273: LD_INT 1
64275: PLUS
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PPUSH
64281: LD_VAR 0 1
64285: PPUSH
64286: CALL 70058 0 3
64290: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64291: LD_ADDR_VAR 0 6
64295: PUSH
64296: LD_EXP 113
64300: PUSH
64301: LD_VAR 0 3
64305: ARRAY
64306: PPUSH
64307: LD_INT 25
64309: PUSH
64310: LD_INT 1
64312: PUSH
64313: EMPTY
64314: LIST
64315: LIST
64316: PUSH
64317: LD_INT 3
64319: PUSH
64320: LD_INT 54
64322: PUSH
64323: EMPTY
64324: LIST
64325: PUSH
64326: EMPTY
64327: LIST
64328: LIST
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PPUSH
64334: CALL_OW 72
64338: ST_TO_ADDR
// if tmp then
64339: LD_VAR 0 6
64343: IFFALSE 64349
// exit ;
64345: POP
64346: POP
64347: GO 64489
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64349: LD_ADDR_VAR 0 6
64353: PUSH
64354: LD_EXP 113
64358: PUSH
64359: LD_VAR 0 3
64363: ARRAY
64364: PPUSH
64365: LD_INT 2
64367: PUSH
64368: LD_INT 30
64370: PUSH
64371: LD_INT 4
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PUSH
64378: LD_INT 30
64380: PUSH
64381: LD_INT 5
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: LIST
64392: PPUSH
64393: CALL_OW 72
64397: ST_TO_ADDR
// if not tmp then
64398: LD_VAR 0 6
64402: NOT
64403: IFFALSE 64409
// exit ;
64405: POP
64406: POP
64407: GO 64489
// for j in tmp do
64409: LD_ADDR_VAR 0 4
64413: PUSH
64414: LD_VAR 0 6
64418: PUSH
64419: FOR_IN
64420: IFFALSE 64479
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64422: LD_ADDR_VAR 0 7
64426: PUSH
64427: LD_VAR 0 4
64431: PPUSH
64432: CALL_OW 313
64436: PPUSH
64437: LD_INT 25
64439: PUSH
64440: LD_INT 1
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: PPUSH
64447: CALL_OW 72
64451: ST_TO_ADDR
// if units then
64452: LD_VAR 0 7
64456: IFFALSE 64477
// begin ComExitBuilding ( units [ 1 ] ) ;
64458: LD_VAR 0 7
64462: PUSH
64463: LD_INT 1
64465: ARRAY
64466: PPUSH
64467: CALL_OW 122
// exit ;
64471: POP
64472: POP
64473: POP
64474: POP
64475: GO 64489
// end ; end ;
64477: GO 64419
64479: POP
64480: POP
// end ; end ; exit ;
64481: POP
64482: POP
64483: GO 64489
// end ; end ;
64485: GO 63843
64487: POP
64488: POP
// end ;
64489: LD_VAR 0 2
64493: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64494: LD_INT 0
64496: PPUSH
64497: PPUSH
64498: PPUSH
64499: PPUSH
64500: PPUSH
64501: PPUSH
64502: PPUSH
// if not mc_bases or not skirmish then
64503: LD_EXP 113
64507: NOT
64508: PUSH
64509: LD_EXP 111
64513: NOT
64514: OR
64515: IFFALSE 64519
// exit ;
64517: GO 64750
// btype := GetBType ( building ) ;
64519: LD_ADDR_VAR 0 6
64523: PUSH
64524: LD_VAR 0 1
64528: PPUSH
64529: CALL_OW 266
64533: ST_TO_ADDR
// x := GetX ( building ) ;
64534: LD_ADDR_VAR 0 7
64538: PUSH
64539: LD_VAR 0 1
64543: PPUSH
64544: CALL_OW 250
64548: ST_TO_ADDR
// y := GetY ( building ) ;
64549: LD_ADDR_VAR 0 8
64553: PUSH
64554: LD_VAR 0 1
64558: PPUSH
64559: CALL_OW 251
64563: ST_TO_ADDR
// d := GetDir ( building ) ;
64564: LD_ADDR_VAR 0 9
64568: PUSH
64569: LD_VAR 0 1
64573: PPUSH
64574: CALL_OW 254
64578: ST_TO_ADDR
// for i = 1 to mc_bases do
64579: LD_ADDR_VAR 0 4
64583: PUSH
64584: DOUBLE
64585: LD_INT 1
64587: DEC
64588: ST_TO_ADDR
64589: LD_EXP 113
64593: PUSH
64594: FOR_TO
64595: IFFALSE 64748
// begin if not mc_build_list [ i ] then
64597: LD_EXP 118
64601: PUSH
64602: LD_VAR 0 4
64606: ARRAY
64607: NOT
64608: IFFALSE 64612
// continue ;
64610: GO 64594
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64612: LD_VAR 0 6
64616: PUSH
64617: LD_VAR 0 7
64621: PUSH
64622: LD_VAR 0 8
64626: PUSH
64627: LD_VAR 0 9
64631: PUSH
64632: EMPTY
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: PPUSH
64638: LD_EXP 118
64642: PUSH
64643: LD_VAR 0 4
64647: ARRAY
64648: PUSH
64649: LD_INT 1
64651: ARRAY
64652: PPUSH
64653: CALL 76227 0 2
64657: IFFALSE 64746
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64659: LD_ADDR_EXP 118
64663: PUSH
64664: LD_EXP 118
64668: PPUSH
64669: LD_VAR 0 4
64673: PPUSH
64674: LD_EXP 118
64678: PUSH
64679: LD_VAR 0 4
64683: ARRAY
64684: PPUSH
64685: LD_INT 1
64687: PPUSH
64688: CALL_OW 3
64692: PPUSH
64693: CALL_OW 1
64697: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64698: LD_ADDR_EXP 120
64702: PUSH
64703: LD_EXP 120
64707: PPUSH
64708: LD_VAR 0 4
64712: PUSH
64713: LD_EXP 120
64717: PUSH
64718: LD_VAR 0 4
64722: ARRAY
64723: PUSH
64724: LD_INT 1
64726: PLUS
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PPUSH
64732: LD_VAR 0 1
64736: PPUSH
64737: CALL 70058 0 3
64741: ST_TO_ADDR
// exit ;
64742: POP
64743: POP
64744: GO 64750
// end ; end ;
64746: GO 64594
64748: POP
64749: POP
// end ;
64750: LD_VAR 0 3
64754: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64755: LD_INT 0
64757: PPUSH
64758: PPUSH
64759: PPUSH
// if not mc_bases or not skirmish then
64760: LD_EXP 113
64764: NOT
64765: PUSH
64766: LD_EXP 111
64770: NOT
64771: OR
64772: IFFALSE 64776
// exit ;
64774: GO 64966
// for i = 1 to mc_bases do
64776: LD_ADDR_VAR 0 4
64780: PUSH
64781: DOUBLE
64782: LD_INT 1
64784: DEC
64785: ST_TO_ADDR
64786: LD_EXP 113
64790: PUSH
64791: FOR_TO
64792: IFFALSE 64879
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64794: LD_VAR 0 1
64798: PUSH
64799: LD_EXP 121
64803: PUSH
64804: LD_VAR 0 4
64808: ARRAY
64809: IN
64810: PUSH
64811: LD_VAR 0 1
64815: PUSH
64816: LD_EXP 122
64820: PUSH
64821: LD_VAR 0 4
64825: ARRAY
64826: IN
64827: NOT
64828: AND
64829: IFFALSE 64877
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64831: LD_ADDR_EXP 122
64835: PUSH
64836: LD_EXP 122
64840: PPUSH
64841: LD_VAR 0 4
64845: PUSH
64846: LD_EXP 122
64850: PUSH
64851: LD_VAR 0 4
64855: ARRAY
64856: PUSH
64857: LD_INT 1
64859: PLUS
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PPUSH
64865: LD_VAR 0 1
64869: PPUSH
64870: CALL 70058 0 3
64874: ST_TO_ADDR
// break ;
64875: GO 64879
// end ; end ;
64877: GO 64791
64879: POP
64880: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64881: LD_VAR 0 1
64885: PPUSH
64886: CALL_OW 257
64890: PUSH
64891: LD_EXP 139
64895: IN
64896: PUSH
64897: LD_VAR 0 1
64901: PPUSH
64902: CALL_OW 266
64906: PUSH
64907: LD_INT 5
64909: EQUAL
64910: AND
64911: PUSH
64912: LD_VAR 0 2
64916: PPUSH
64917: CALL_OW 110
64921: PUSH
64922: LD_INT 18
64924: NONEQUAL
64925: AND
64926: IFFALSE 64966
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64928: LD_VAR 0 2
64932: PPUSH
64933: CALL_OW 257
64937: PUSH
64938: LD_INT 5
64940: PUSH
64941: LD_INT 8
64943: PUSH
64944: LD_INT 9
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: LIST
64951: IN
64952: IFFALSE 64966
// SetClass ( unit , 1 ) ;
64954: LD_VAR 0 2
64958: PPUSH
64959: LD_INT 1
64961: PPUSH
64962: CALL_OW 336
// end ;
64966: LD_VAR 0 3
64970: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64971: LD_INT 0
64973: PPUSH
64974: PPUSH
// if not mc_bases or not skirmish then
64975: LD_EXP 113
64979: NOT
64980: PUSH
64981: LD_EXP 111
64985: NOT
64986: OR
64987: IFFALSE 64991
// exit ;
64989: GO 65107
// if GetLives ( abandoned_vehicle ) > 250 then
64991: LD_VAR 0 2
64995: PPUSH
64996: CALL_OW 256
65000: PUSH
65001: LD_INT 250
65003: GREATER
65004: IFFALSE 65008
// exit ;
65006: GO 65107
// for i = 1 to mc_bases do
65008: LD_ADDR_VAR 0 6
65012: PUSH
65013: DOUBLE
65014: LD_INT 1
65016: DEC
65017: ST_TO_ADDR
65018: LD_EXP 113
65022: PUSH
65023: FOR_TO
65024: IFFALSE 65105
// begin if driver in mc_bases [ i ] then
65026: LD_VAR 0 1
65030: PUSH
65031: LD_EXP 113
65035: PUSH
65036: LD_VAR 0 6
65040: ARRAY
65041: IN
65042: IFFALSE 65103
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65044: LD_VAR 0 1
65048: PPUSH
65049: LD_EXP 113
65053: PUSH
65054: LD_VAR 0 6
65058: ARRAY
65059: PPUSH
65060: LD_INT 2
65062: PUSH
65063: LD_INT 30
65065: PUSH
65066: LD_INT 0
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PUSH
65073: LD_INT 30
65075: PUSH
65076: LD_INT 1
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: PUSH
65083: EMPTY
65084: LIST
65085: LIST
65086: LIST
65087: PPUSH
65088: CALL_OW 72
65092: PUSH
65093: LD_INT 1
65095: ARRAY
65096: PPUSH
65097: CALL_OW 112
// break ;
65101: GO 65105
// end ; end ;
65103: GO 65023
65105: POP
65106: POP
// end ; end_of_file
65107: LD_VAR 0 5
65111: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65112: LD_INT 0
65114: PPUSH
65115: PPUSH
// if exist_mode then
65116: LD_VAR 0 2
65120: IFFALSE 65145
// unit := CreateCharacter ( prefix & ident ) else
65122: LD_ADDR_VAR 0 5
65126: PUSH
65127: LD_VAR 0 3
65131: PUSH
65132: LD_VAR 0 1
65136: STR
65137: PPUSH
65138: CALL_OW 34
65142: ST_TO_ADDR
65143: GO 65160
// unit := NewCharacter ( ident ) ;
65145: LD_ADDR_VAR 0 5
65149: PUSH
65150: LD_VAR 0 1
65154: PPUSH
65155: CALL_OW 25
65159: ST_TO_ADDR
// result := unit ;
65160: LD_ADDR_VAR 0 4
65164: PUSH
65165: LD_VAR 0 5
65169: ST_TO_ADDR
// end ;
65170: LD_VAR 0 4
65174: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65175: LD_INT 0
65177: PPUSH
65178: PPUSH
// if not side or not nation then
65179: LD_VAR 0 1
65183: NOT
65184: PUSH
65185: LD_VAR 0 2
65189: NOT
65190: OR
65191: IFFALSE 65195
// exit ;
65193: GO 65959
// case nation of nation_american :
65195: LD_VAR 0 2
65199: PUSH
65200: LD_INT 1
65202: DOUBLE
65203: EQUAL
65204: IFTRUE 65208
65206: GO 65422
65208: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65209: LD_ADDR_VAR 0 4
65213: PUSH
65214: LD_INT 35
65216: PUSH
65217: LD_INT 45
65219: PUSH
65220: LD_INT 46
65222: PUSH
65223: LD_INT 47
65225: PUSH
65226: LD_INT 82
65228: PUSH
65229: LD_INT 83
65231: PUSH
65232: LD_INT 84
65234: PUSH
65235: LD_INT 85
65237: PUSH
65238: LD_INT 86
65240: PUSH
65241: LD_INT 1
65243: PUSH
65244: LD_INT 2
65246: PUSH
65247: LD_INT 6
65249: PUSH
65250: LD_INT 15
65252: PUSH
65253: LD_INT 16
65255: PUSH
65256: LD_INT 7
65258: PUSH
65259: LD_INT 12
65261: PUSH
65262: LD_INT 13
65264: PUSH
65265: LD_INT 10
65267: PUSH
65268: LD_INT 14
65270: PUSH
65271: LD_INT 20
65273: PUSH
65274: LD_INT 21
65276: PUSH
65277: LD_INT 22
65279: PUSH
65280: LD_INT 25
65282: PUSH
65283: LD_INT 32
65285: PUSH
65286: LD_INT 27
65288: PUSH
65289: LD_INT 36
65291: PUSH
65292: LD_INT 69
65294: PUSH
65295: LD_INT 39
65297: PUSH
65298: LD_INT 34
65300: PUSH
65301: LD_INT 40
65303: PUSH
65304: LD_INT 48
65306: PUSH
65307: LD_INT 49
65309: PUSH
65310: LD_INT 50
65312: PUSH
65313: LD_INT 51
65315: PUSH
65316: LD_INT 52
65318: PUSH
65319: LD_INT 53
65321: PUSH
65322: LD_INT 54
65324: PUSH
65325: LD_INT 55
65327: PUSH
65328: LD_INT 56
65330: PUSH
65331: LD_INT 57
65333: PUSH
65334: LD_INT 58
65336: PUSH
65337: LD_INT 59
65339: PUSH
65340: LD_INT 60
65342: PUSH
65343: LD_INT 61
65345: PUSH
65346: LD_INT 62
65348: PUSH
65349: LD_INT 80
65351: PUSH
65352: LD_INT 82
65354: PUSH
65355: LD_INT 83
65357: PUSH
65358: LD_INT 84
65360: PUSH
65361: LD_INT 85
65363: PUSH
65364: LD_INT 86
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: LIST
65412: LIST
65413: LIST
65414: LIST
65415: LIST
65416: LIST
65417: LIST
65418: LIST
65419: ST_TO_ADDR
65420: GO 65883
65422: LD_INT 2
65424: DOUBLE
65425: EQUAL
65426: IFTRUE 65430
65428: GO 65652
65430: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65431: LD_ADDR_VAR 0 4
65435: PUSH
65436: LD_INT 35
65438: PUSH
65439: LD_INT 45
65441: PUSH
65442: LD_INT 46
65444: PUSH
65445: LD_INT 47
65447: PUSH
65448: LD_INT 82
65450: PUSH
65451: LD_INT 83
65453: PUSH
65454: LD_INT 84
65456: PUSH
65457: LD_INT 85
65459: PUSH
65460: LD_INT 87
65462: PUSH
65463: LD_INT 70
65465: PUSH
65466: LD_INT 1
65468: PUSH
65469: LD_INT 11
65471: PUSH
65472: LD_INT 3
65474: PUSH
65475: LD_INT 4
65477: PUSH
65478: LD_INT 5
65480: PUSH
65481: LD_INT 6
65483: PUSH
65484: LD_INT 15
65486: PUSH
65487: LD_INT 18
65489: PUSH
65490: LD_INT 7
65492: PUSH
65493: LD_INT 17
65495: PUSH
65496: LD_INT 8
65498: PUSH
65499: LD_INT 20
65501: PUSH
65502: LD_INT 21
65504: PUSH
65505: LD_INT 22
65507: PUSH
65508: LD_INT 72
65510: PUSH
65511: LD_INT 26
65513: PUSH
65514: LD_INT 69
65516: PUSH
65517: LD_INT 39
65519: PUSH
65520: LD_INT 40
65522: PUSH
65523: LD_INT 41
65525: PUSH
65526: LD_INT 42
65528: PUSH
65529: LD_INT 43
65531: PUSH
65532: LD_INT 48
65534: PUSH
65535: LD_INT 49
65537: PUSH
65538: LD_INT 50
65540: PUSH
65541: LD_INT 51
65543: PUSH
65544: LD_INT 52
65546: PUSH
65547: LD_INT 53
65549: PUSH
65550: LD_INT 54
65552: PUSH
65553: LD_INT 55
65555: PUSH
65556: LD_INT 56
65558: PUSH
65559: LD_INT 60
65561: PUSH
65562: LD_INT 61
65564: PUSH
65565: LD_INT 62
65567: PUSH
65568: LD_INT 66
65570: PUSH
65571: LD_INT 67
65573: PUSH
65574: LD_INT 68
65576: PUSH
65577: LD_INT 81
65579: PUSH
65580: LD_INT 82
65582: PUSH
65583: LD_INT 83
65585: PUSH
65586: LD_INT 84
65588: PUSH
65589: LD_INT 85
65591: PUSH
65592: LD_INT 87
65594: PUSH
65595: EMPTY
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: LIST
65639: LIST
65640: LIST
65641: LIST
65642: LIST
65643: LIST
65644: LIST
65645: LIST
65646: LIST
65647: LIST
65648: LIST
65649: ST_TO_ADDR
65650: GO 65883
65652: LD_INT 3
65654: DOUBLE
65655: EQUAL
65656: IFTRUE 65660
65658: GO 65882
65660: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65661: LD_ADDR_VAR 0 4
65665: PUSH
65666: LD_INT 46
65668: PUSH
65669: LD_INT 47
65671: PUSH
65672: LD_INT 1
65674: PUSH
65675: LD_INT 2
65677: PUSH
65678: LD_INT 82
65680: PUSH
65681: LD_INT 83
65683: PUSH
65684: LD_INT 84
65686: PUSH
65687: LD_INT 85
65689: PUSH
65690: LD_INT 86
65692: PUSH
65693: LD_INT 11
65695: PUSH
65696: LD_INT 9
65698: PUSH
65699: LD_INT 20
65701: PUSH
65702: LD_INT 19
65704: PUSH
65705: LD_INT 21
65707: PUSH
65708: LD_INT 24
65710: PUSH
65711: LD_INT 22
65713: PUSH
65714: LD_INT 25
65716: PUSH
65717: LD_INT 28
65719: PUSH
65720: LD_INT 29
65722: PUSH
65723: LD_INT 30
65725: PUSH
65726: LD_INT 31
65728: PUSH
65729: LD_INT 37
65731: PUSH
65732: LD_INT 38
65734: PUSH
65735: LD_INT 32
65737: PUSH
65738: LD_INT 27
65740: PUSH
65741: LD_INT 33
65743: PUSH
65744: LD_INT 69
65746: PUSH
65747: LD_INT 39
65749: PUSH
65750: LD_INT 34
65752: PUSH
65753: LD_INT 40
65755: PUSH
65756: LD_INT 71
65758: PUSH
65759: LD_INT 23
65761: PUSH
65762: LD_INT 44
65764: PUSH
65765: LD_INT 48
65767: PUSH
65768: LD_INT 49
65770: PUSH
65771: LD_INT 50
65773: PUSH
65774: LD_INT 51
65776: PUSH
65777: LD_INT 52
65779: PUSH
65780: LD_INT 53
65782: PUSH
65783: LD_INT 54
65785: PUSH
65786: LD_INT 55
65788: PUSH
65789: LD_INT 56
65791: PUSH
65792: LD_INT 57
65794: PUSH
65795: LD_INT 58
65797: PUSH
65798: LD_INT 59
65800: PUSH
65801: LD_INT 63
65803: PUSH
65804: LD_INT 64
65806: PUSH
65807: LD_INT 65
65809: PUSH
65810: LD_INT 82
65812: PUSH
65813: LD_INT 83
65815: PUSH
65816: LD_INT 84
65818: PUSH
65819: LD_INT 85
65821: PUSH
65822: LD_INT 86
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: LIST
65876: LIST
65877: LIST
65878: LIST
65879: ST_TO_ADDR
65880: GO 65883
65882: POP
// if state > - 1 and state < 3 then
65883: LD_VAR 0 3
65887: PUSH
65888: LD_INT 1
65890: NEG
65891: GREATER
65892: PUSH
65893: LD_VAR 0 3
65897: PUSH
65898: LD_INT 3
65900: LESS
65901: AND
65902: IFFALSE 65959
// for i in result do
65904: LD_ADDR_VAR 0 5
65908: PUSH
65909: LD_VAR 0 4
65913: PUSH
65914: FOR_IN
65915: IFFALSE 65957
// if GetTech ( i , side ) <> state then
65917: LD_VAR 0 5
65921: PPUSH
65922: LD_VAR 0 1
65926: PPUSH
65927: CALL_OW 321
65931: PUSH
65932: LD_VAR 0 3
65936: NONEQUAL
65937: IFFALSE 65955
// result := result diff i ;
65939: LD_ADDR_VAR 0 4
65943: PUSH
65944: LD_VAR 0 4
65948: PUSH
65949: LD_VAR 0 5
65953: DIFF
65954: ST_TO_ADDR
65955: GO 65914
65957: POP
65958: POP
// end ;
65959: LD_VAR 0 4
65963: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65964: LD_INT 0
65966: PPUSH
65967: PPUSH
65968: PPUSH
// result := true ;
65969: LD_ADDR_VAR 0 3
65973: PUSH
65974: LD_INT 1
65976: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65977: LD_ADDR_VAR 0 5
65981: PUSH
65982: LD_VAR 0 2
65986: PPUSH
65987: CALL_OW 480
65991: ST_TO_ADDR
// if not tmp then
65992: LD_VAR 0 5
65996: NOT
65997: IFFALSE 66001
// exit ;
65999: GO 66050
// for i in tmp do
66001: LD_ADDR_VAR 0 4
66005: PUSH
66006: LD_VAR 0 5
66010: PUSH
66011: FOR_IN
66012: IFFALSE 66048
// if GetTech ( i , side ) <> state_researched then
66014: LD_VAR 0 4
66018: PPUSH
66019: LD_VAR 0 1
66023: PPUSH
66024: CALL_OW 321
66028: PUSH
66029: LD_INT 2
66031: NONEQUAL
66032: IFFALSE 66046
// begin result := false ;
66034: LD_ADDR_VAR 0 3
66038: PUSH
66039: LD_INT 0
66041: ST_TO_ADDR
// exit ;
66042: POP
66043: POP
66044: GO 66050
// end ;
66046: GO 66011
66048: POP
66049: POP
// end ;
66050: LD_VAR 0 3
66054: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66055: LD_INT 0
66057: PPUSH
66058: PPUSH
66059: PPUSH
66060: PPUSH
66061: PPUSH
66062: PPUSH
66063: PPUSH
66064: PPUSH
66065: PPUSH
66066: PPUSH
66067: PPUSH
66068: PPUSH
66069: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66070: LD_VAR 0 1
66074: NOT
66075: PUSH
66076: LD_VAR 0 1
66080: PPUSH
66081: CALL_OW 257
66085: PUSH
66086: LD_INT 9
66088: NONEQUAL
66089: OR
66090: IFFALSE 66094
// exit ;
66092: GO 66667
// side := GetSide ( unit ) ;
66094: LD_ADDR_VAR 0 9
66098: PUSH
66099: LD_VAR 0 1
66103: PPUSH
66104: CALL_OW 255
66108: ST_TO_ADDR
// tech_space := tech_spacanom ;
66109: LD_ADDR_VAR 0 12
66113: PUSH
66114: LD_INT 29
66116: ST_TO_ADDR
// tech_time := tech_taurad ;
66117: LD_ADDR_VAR 0 13
66121: PUSH
66122: LD_INT 28
66124: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66125: LD_ADDR_VAR 0 11
66129: PUSH
66130: LD_VAR 0 1
66134: PPUSH
66135: CALL_OW 310
66139: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66140: LD_VAR 0 11
66144: PPUSH
66145: CALL_OW 247
66149: PUSH
66150: LD_INT 2
66152: EQUAL
66153: IFFALSE 66157
// exit ;
66155: GO 66667
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66157: LD_ADDR_VAR 0 8
66161: PUSH
66162: LD_INT 81
66164: PUSH
66165: LD_VAR 0 9
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PUSH
66174: LD_INT 3
66176: PUSH
66177: LD_INT 21
66179: PUSH
66180: LD_INT 3
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: EMPTY
66188: LIST
66189: LIST
66190: PUSH
66191: EMPTY
66192: LIST
66193: LIST
66194: PPUSH
66195: CALL_OW 69
66199: ST_TO_ADDR
// if not tmp then
66200: LD_VAR 0 8
66204: NOT
66205: IFFALSE 66209
// exit ;
66207: GO 66667
// if in_unit then
66209: LD_VAR 0 11
66213: IFFALSE 66237
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66215: LD_ADDR_VAR 0 10
66219: PUSH
66220: LD_VAR 0 8
66224: PPUSH
66225: LD_VAR 0 11
66229: PPUSH
66230: CALL_OW 74
66234: ST_TO_ADDR
66235: GO 66257
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66237: LD_ADDR_VAR 0 10
66241: PUSH
66242: LD_VAR 0 8
66246: PPUSH
66247: LD_VAR 0 1
66251: PPUSH
66252: CALL_OW 74
66256: ST_TO_ADDR
// if not enemy then
66257: LD_VAR 0 10
66261: NOT
66262: IFFALSE 66266
// exit ;
66264: GO 66667
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66266: LD_VAR 0 11
66270: PUSH
66271: LD_VAR 0 11
66275: PPUSH
66276: LD_VAR 0 10
66280: PPUSH
66281: CALL_OW 296
66285: PUSH
66286: LD_INT 13
66288: GREATER
66289: AND
66290: PUSH
66291: LD_VAR 0 1
66295: PPUSH
66296: LD_VAR 0 10
66300: PPUSH
66301: CALL_OW 296
66305: PUSH
66306: LD_INT 12
66308: GREATER
66309: OR
66310: IFFALSE 66314
// exit ;
66312: GO 66667
// missile := [ 1 ] ;
66314: LD_ADDR_VAR 0 14
66318: PUSH
66319: LD_INT 1
66321: PUSH
66322: EMPTY
66323: LIST
66324: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66325: LD_VAR 0 9
66329: PPUSH
66330: LD_VAR 0 12
66334: PPUSH
66335: CALL_OW 325
66339: IFFALSE 66368
// missile := Insert ( missile , missile + 1 , 2 ) ;
66341: LD_ADDR_VAR 0 14
66345: PUSH
66346: LD_VAR 0 14
66350: PPUSH
66351: LD_VAR 0 14
66355: PUSH
66356: LD_INT 1
66358: PLUS
66359: PPUSH
66360: LD_INT 2
66362: PPUSH
66363: CALL_OW 2
66367: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66368: LD_VAR 0 9
66372: PPUSH
66373: LD_VAR 0 13
66377: PPUSH
66378: CALL_OW 325
66382: PUSH
66383: LD_VAR 0 10
66387: PPUSH
66388: CALL_OW 255
66392: PPUSH
66393: LD_VAR 0 13
66397: PPUSH
66398: CALL_OW 325
66402: NOT
66403: AND
66404: IFFALSE 66433
// missile := Insert ( missile , missile + 1 , 3 ) ;
66406: LD_ADDR_VAR 0 14
66410: PUSH
66411: LD_VAR 0 14
66415: PPUSH
66416: LD_VAR 0 14
66420: PUSH
66421: LD_INT 1
66423: PLUS
66424: PPUSH
66425: LD_INT 3
66427: PPUSH
66428: CALL_OW 2
66432: ST_TO_ADDR
// if missile < 2 then
66433: LD_VAR 0 14
66437: PUSH
66438: LD_INT 2
66440: LESS
66441: IFFALSE 66445
// exit ;
66443: GO 66667
// x := GetX ( enemy ) ;
66445: LD_ADDR_VAR 0 4
66449: PUSH
66450: LD_VAR 0 10
66454: PPUSH
66455: CALL_OW 250
66459: ST_TO_ADDR
// y := GetY ( enemy ) ;
66460: LD_ADDR_VAR 0 5
66464: PUSH
66465: LD_VAR 0 10
66469: PPUSH
66470: CALL_OW 251
66474: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66475: LD_ADDR_VAR 0 6
66479: PUSH
66480: LD_VAR 0 4
66484: PUSH
66485: LD_INT 1
66487: NEG
66488: PPUSH
66489: LD_INT 1
66491: PPUSH
66492: CALL_OW 12
66496: PLUS
66497: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66498: LD_ADDR_VAR 0 7
66502: PUSH
66503: LD_VAR 0 5
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PPUSH
66512: LD_INT 1
66514: PPUSH
66515: CALL_OW 12
66519: PLUS
66520: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66521: LD_VAR 0 6
66525: PPUSH
66526: LD_VAR 0 7
66530: PPUSH
66531: CALL_OW 488
66535: NOT
66536: IFFALSE 66558
// begin _x := x ;
66538: LD_ADDR_VAR 0 6
66542: PUSH
66543: LD_VAR 0 4
66547: ST_TO_ADDR
// _y := y ;
66548: LD_ADDR_VAR 0 7
66552: PUSH
66553: LD_VAR 0 5
66557: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66558: LD_ADDR_VAR 0 3
66562: PUSH
66563: LD_INT 1
66565: PPUSH
66566: LD_VAR 0 14
66570: PPUSH
66571: CALL_OW 12
66575: ST_TO_ADDR
// case i of 1 :
66576: LD_VAR 0 3
66580: PUSH
66581: LD_INT 1
66583: DOUBLE
66584: EQUAL
66585: IFTRUE 66589
66587: GO 66606
66589: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66590: LD_VAR 0 1
66594: PPUSH
66595: LD_VAR 0 10
66599: PPUSH
66600: CALL_OW 115
66604: GO 66667
66606: LD_INT 2
66608: DOUBLE
66609: EQUAL
66610: IFTRUE 66614
66612: GO 66636
66614: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66615: LD_VAR 0 1
66619: PPUSH
66620: LD_VAR 0 6
66624: PPUSH
66625: LD_VAR 0 7
66629: PPUSH
66630: CALL_OW 153
66634: GO 66667
66636: LD_INT 3
66638: DOUBLE
66639: EQUAL
66640: IFTRUE 66644
66642: GO 66666
66644: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66645: LD_VAR 0 1
66649: PPUSH
66650: LD_VAR 0 6
66654: PPUSH
66655: LD_VAR 0 7
66659: PPUSH
66660: CALL_OW 154
66664: GO 66667
66666: POP
// end ;
66667: LD_VAR 0 2
66671: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66672: LD_INT 0
66674: PPUSH
66675: PPUSH
66676: PPUSH
66677: PPUSH
66678: PPUSH
66679: PPUSH
// if not unit or not building then
66680: LD_VAR 0 1
66684: NOT
66685: PUSH
66686: LD_VAR 0 2
66690: NOT
66691: OR
66692: IFFALSE 66696
// exit ;
66694: GO 66854
// x := GetX ( building ) ;
66696: LD_ADDR_VAR 0 5
66700: PUSH
66701: LD_VAR 0 2
66705: PPUSH
66706: CALL_OW 250
66710: ST_TO_ADDR
// y := GetY ( building ) ;
66711: LD_ADDR_VAR 0 6
66715: PUSH
66716: LD_VAR 0 2
66720: PPUSH
66721: CALL_OW 251
66725: ST_TO_ADDR
// for i = 0 to 5 do
66726: LD_ADDR_VAR 0 4
66730: PUSH
66731: DOUBLE
66732: LD_INT 0
66734: DEC
66735: ST_TO_ADDR
66736: LD_INT 5
66738: PUSH
66739: FOR_TO
66740: IFFALSE 66852
// begin _x := ShiftX ( x , i , 3 ) ;
66742: LD_ADDR_VAR 0 7
66746: PUSH
66747: LD_VAR 0 5
66751: PPUSH
66752: LD_VAR 0 4
66756: PPUSH
66757: LD_INT 3
66759: PPUSH
66760: CALL_OW 272
66764: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66765: LD_ADDR_VAR 0 8
66769: PUSH
66770: LD_VAR 0 6
66774: PPUSH
66775: LD_VAR 0 4
66779: PPUSH
66780: LD_INT 3
66782: PPUSH
66783: CALL_OW 273
66787: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66788: LD_VAR 0 7
66792: PPUSH
66793: LD_VAR 0 8
66797: PPUSH
66798: CALL_OW 488
66802: NOT
66803: IFFALSE 66807
// continue ;
66805: GO 66739
// if HexInfo ( _x , _y ) = 0 then
66807: LD_VAR 0 7
66811: PPUSH
66812: LD_VAR 0 8
66816: PPUSH
66817: CALL_OW 428
66821: PUSH
66822: LD_INT 0
66824: EQUAL
66825: IFFALSE 66850
// begin ComMoveXY ( unit , _x , _y ) ;
66827: LD_VAR 0 1
66831: PPUSH
66832: LD_VAR 0 7
66836: PPUSH
66837: LD_VAR 0 8
66841: PPUSH
66842: CALL_OW 111
// exit ;
66846: POP
66847: POP
66848: GO 66854
// end ; end ;
66850: GO 66739
66852: POP
66853: POP
// end ;
66854: LD_VAR 0 3
66858: RET
// export function ScanBase ( side , base_area ) ; begin
66859: LD_INT 0
66861: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66862: LD_ADDR_VAR 0 3
66866: PUSH
66867: LD_VAR 0 2
66871: PPUSH
66872: LD_INT 81
66874: PUSH
66875: LD_VAR 0 1
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PPUSH
66884: CALL_OW 70
66888: ST_TO_ADDR
// end ;
66889: LD_VAR 0 3
66893: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66894: LD_INT 0
66896: PPUSH
66897: PPUSH
66898: PPUSH
66899: PPUSH
// result := false ;
66900: LD_ADDR_VAR 0 2
66904: PUSH
66905: LD_INT 0
66907: ST_TO_ADDR
// side := GetSide ( unit ) ;
66908: LD_ADDR_VAR 0 3
66912: PUSH
66913: LD_VAR 0 1
66917: PPUSH
66918: CALL_OW 255
66922: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66923: LD_ADDR_VAR 0 4
66927: PUSH
66928: LD_VAR 0 1
66932: PPUSH
66933: CALL_OW 248
66937: ST_TO_ADDR
// case nat of 1 :
66938: LD_VAR 0 4
66942: PUSH
66943: LD_INT 1
66945: DOUBLE
66946: EQUAL
66947: IFTRUE 66951
66949: GO 66962
66951: POP
// tech := tech_lassight ; 2 :
66952: LD_ADDR_VAR 0 5
66956: PUSH
66957: LD_INT 12
66959: ST_TO_ADDR
66960: GO 67001
66962: LD_INT 2
66964: DOUBLE
66965: EQUAL
66966: IFTRUE 66970
66968: GO 66981
66970: POP
// tech := tech_mortar ; 3 :
66971: LD_ADDR_VAR 0 5
66975: PUSH
66976: LD_INT 41
66978: ST_TO_ADDR
66979: GO 67001
66981: LD_INT 3
66983: DOUBLE
66984: EQUAL
66985: IFTRUE 66989
66987: GO 67000
66989: POP
// tech := tech_bazooka ; end ;
66990: LD_ADDR_VAR 0 5
66994: PUSH
66995: LD_INT 44
66997: ST_TO_ADDR
66998: GO 67001
67000: POP
// if Researched ( side , tech ) then
67001: LD_VAR 0 3
67005: PPUSH
67006: LD_VAR 0 5
67010: PPUSH
67011: CALL_OW 325
67015: IFFALSE 67042
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67017: LD_ADDR_VAR 0 2
67021: PUSH
67022: LD_INT 5
67024: PUSH
67025: LD_INT 8
67027: PUSH
67028: LD_INT 9
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: LIST
67035: PUSH
67036: LD_VAR 0 4
67040: ARRAY
67041: ST_TO_ADDR
// end ;
67042: LD_VAR 0 2
67046: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67047: LD_INT 0
67049: PPUSH
67050: PPUSH
67051: PPUSH
// if not mines then
67052: LD_VAR 0 2
67056: NOT
67057: IFFALSE 67061
// exit ;
67059: GO 67205
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67061: LD_ADDR_VAR 0 5
67065: PUSH
67066: LD_INT 81
67068: PUSH
67069: LD_VAR 0 1
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PUSH
67078: LD_INT 3
67080: PUSH
67081: LD_INT 21
67083: PUSH
67084: LD_INT 3
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PPUSH
67099: CALL_OW 69
67103: ST_TO_ADDR
// for i in mines do
67104: LD_ADDR_VAR 0 4
67108: PUSH
67109: LD_VAR 0 2
67113: PUSH
67114: FOR_IN
67115: IFFALSE 67203
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67117: LD_VAR 0 4
67121: PUSH
67122: LD_INT 1
67124: ARRAY
67125: PPUSH
67126: LD_VAR 0 4
67130: PUSH
67131: LD_INT 2
67133: ARRAY
67134: PPUSH
67135: CALL_OW 458
67139: NOT
67140: IFFALSE 67144
// continue ;
67142: GO 67114
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67144: LD_VAR 0 4
67148: PUSH
67149: LD_INT 1
67151: ARRAY
67152: PPUSH
67153: LD_VAR 0 4
67157: PUSH
67158: LD_INT 2
67160: ARRAY
67161: PPUSH
67162: CALL_OW 428
67166: PUSH
67167: LD_VAR 0 5
67171: IN
67172: IFFALSE 67201
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67174: LD_VAR 0 4
67178: PUSH
67179: LD_INT 1
67181: ARRAY
67182: PPUSH
67183: LD_VAR 0 4
67187: PUSH
67188: LD_INT 2
67190: ARRAY
67191: PPUSH
67192: LD_VAR 0 1
67196: PPUSH
67197: CALL_OW 456
// end ;
67201: GO 67114
67203: POP
67204: POP
// end ;
67205: LD_VAR 0 3
67209: RET
// export function Count ( array ) ; var i ; begin
67210: LD_INT 0
67212: PPUSH
67213: PPUSH
// result := 0 ;
67214: LD_ADDR_VAR 0 2
67218: PUSH
67219: LD_INT 0
67221: ST_TO_ADDR
// for i in array do
67222: LD_ADDR_VAR 0 3
67226: PUSH
67227: LD_VAR 0 1
67231: PUSH
67232: FOR_IN
67233: IFFALSE 67257
// if i then
67235: LD_VAR 0 3
67239: IFFALSE 67255
// result := result + 1 ;
67241: LD_ADDR_VAR 0 2
67245: PUSH
67246: LD_VAR 0 2
67250: PUSH
67251: LD_INT 1
67253: PLUS
67254: ST_TO_ADDR
67255: GO 67232
67257: POP
67258: POP
// end ;
67259: LD_VAR 0 2
67263: RET
// export function IsEmpty ( building ) ; begin
67264: LD_INT 0
67266: PPUSH
// if not building then
67267: LD_VAR 0 1
67271: NOT
67272: IFFALSE 67276
// exit ;
67274: GO 67319
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67276: LD_ADDR_VAR 0 2
67280: PUSH
67281: LD_VAR 0 1
67285: PUSH
67286: LD_INT 22
67288: PUSH
67289: LD_VAR 0 1
67293: PPUSH
67294: CALL_OW 255
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 58
67305: PUSH
67306: EMPTY
67307: LIST
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PPUSH
67313: CALL_OW 69
67317: IN
67318: ST_TO_ADDR
// end ;
67319: LD_VAR 0 2
67323: RET
// export function IsNotFull ( building ) ; begin
67324: LD_INT 0
67326: PPUSH
// if not building then
67327: LD_VAR 0 1
67331: NOT
67332: IFFALSE 67336
// exit ;
67334: GO 67355
// result := UnitsInside ( building ) < 6 ;
67336: LD_ADDR_VAR 0 2
67340: PUSH
67341: LD_VAR 0 1
67345: PPUSH
67346: CALL_OW 313
67350: PUSH
67351: LD_INT 6
67353: LESS
67354: ST_TO_ADDR
// end ;
67355: LD_VAR 0 2
67359: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67360: LD_INT 0
67362: PPUSH
67363: PPUSH
67364: PPUSH
67365: PPUSH
// tmp := [ ] ;
67366: LD_ADDR_VAR 0 3
67370: PUSH
67371: EMPTY
67372: ST_TO_ADDR
// list := [ ] ;
67373: LD_ADDR_VAR 0 5
67377: PUSH
67378: EMPTY
67379: ST_TO_ADDR
// for i = 16 to 25 do
67380: LD_ADDR_VAR 0 4
67384: PUSH
67385: DOUBLE
67386: LD_INT 16
67388: DEC
67389: ST_TO_ADDR
67390: LD_INT 25
67392: PUSH
67393: FOR_TO
67394: IFFALSE 67467
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67396: LD_ADDR_VAR 0 3
67400: PUSH
67401: LD_VAR 0 3
67405: PUSH
67406: LD_INT 22
67408: PUSH
67409: LD_VAR 0 1
67413: PPUSH
67414: CALL_OW 255
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 91
67425: PUSH
67426: LD_VAR 0 1
67430: PUSH
67431: LD_INT 6
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 30
67441: PUSH
67442: LD_VAR 0 4
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: LIST
67455: PUSH
67456: EMPTY
67457: LIST
67458: PPUSH
67459: CALL_OW 69
67463: ADD
67464: ST_TO_ADDR
67465: GO 67393
67467: POP
67468: POP
// for i = 1 to tmp do
67469: LD_ADDR_VAR 0 4
67473: PUSH
67474: DOUBLE
67475: LD_INT 1
67477: DEC
67478: ST_TO_ADDR
67479: LD_VAR 0 3
67483: PUSH
67484: FOR_TO
67485: IFFALSE 67573
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67487: LD_ADDR_VAR 0 5
67491: PUSH
67492: LD_VAR 0 5
67496: PUSH
67497: LD_VAR 0 3
67501: PUSH
67502: LD_VAR 0 4
67506: ARRAY
67507: PPUSH
67508: CALL_OW 266
67512: PUSH
67513: LD_VAR 0 3
67517: PUSH
67518: LD_VAR 0 4
67522: ARRAY
67523: PPUSH
67524: CALL_OW 250
67528: PUSH
67529: LD_VAR 0 3
67533: PUSH
67534: LD_VAR 0 4
67538: ARRAY
67539: PPUSH
67540: CALL_OW 251
67544: PUSH
67545: LD_VAR 0 3
67549: PUSH
67550: LD_VAR 0 4
67554: ARRAY
67555: PPUSH
67556: CALL_OW 254
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: PUSH
67567: EMPTY
67568: LIST
67569: ADD
67570: ST_TO_ADDR
67571: GO 67484
67573: POP
67574: POP
// result := list ;
67575: LD_ADDR_VAR 0 2
67579: PUSH
67580: LD_VAR 0 5
67584: ST_TO_ADDR
// end ;
67585: LD_VAR 0 2
67589: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67590: LD_INT 0
67592: PPUSH
67593: PPUSH
67594: PPUSH
67595: PPUSH
67596: PPUSH
67597: PPUSH
67598: PPUSH
// if not factory then
67599: LD_VAR 0 1
67603: NOT
67604: IFFALSE 67608
// exit ;
67606: GO 68201
// if control = control_apeman then
67608: LD_VAR 0 4
67612: PUSH
67613: LD_INT 5
67615: EQUAL
67616: IFFALSE 67725
// begin tmp := UnitsInside ( factory ) ;
67618: LD_ADDR_VAR 0 8
67622: PUSH
67623: LD_VAR 0 1
67627: PPUSH
67628: CALL_OW 313
67632: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67633: LD_VAR 0 8
67637: PPUSH
67638: LD_INT 25
67640: PUSH
67641: LD_INT 12
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PPUSH
67648: CALL_OW 72
67652: NOT
67653: IFFALSE 67663
// control := control_manual ;
67655: LD_ADDR_VAR 0 4
67659: PUSH
67660: LD_INT 1
67662: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67663: LD_ADDR_VAR 0 8
67667: PUSH
67668: LD_VAR 0 1
67672: PPUSH
67673: CALL 67360 0 1
67677: ST_TO_ADDR
// if tmp then
67678: LD_VAR 0 8
67682: IFFALSE 67725
// begin for i in tmp do
67684: LD_ADDR_VAR 0 7
67688: PUSH
67689: LD_VAR 0 8
67693: PUSH
67694: FOR_IN
67695: IFFALSE 67723
// if i [ 1 ] = b_ext_radio then
67697: LD_VAR 0 7
67701: PUSH
67702: LD_INT 1
67704: ARRAY
67705: PUSH
67706: LD_INT 22
67708: EQUAL
67709: IFFALSE 67721
// begin control := control_remote ;
67711: LD_ADDR_VAR 0 4
67715: PUSH
67716: LD_INT 2
67718: ST_TO_ADDR
// break ;
67719: GO 67723
// end ;
67721: GO 67694
67723: POP
67724: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67725: LD_VAR 0 1
67729: PPUSH
67730: LD_VAR 0 2
67734: PPUSH
67735: LD_VAR 0 3
67739: PPUSH
67740: LD_VAR 0 4
67744: PPUSH
67745: LD_VAR 0 5
67749: PPUSH
67750: CALL_OW 448
67754: IFFALSE 67789
// begin result := [ chassis , engine , control , weapon ] ;
67756: LD_ADDR_VAR 0 6
67760: PUSH
67761: LD_VAR 0 2
67765: PUSH
67766: LD_VAR 0 3
67770: PUSH
67771: LD_VAR 0 4
67775: PUSH
67776: LD_VAR 0 5
67780: PUSH
67781: EMPTY
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: ST_TO_ADDR
// exit ;
67787: GO 68201
// end ; _chassis := AvailableChassisList ( factory ) ;
67789: LD_ADDR_VAR 0 9
67793: PUSH
67794: LD_VAR 0 1
67798: PPUSH
67799: CALL_OW 475
67803: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67804: LD_ADDR_VAR 0 11
67808: PUSH
67809: LD_VAR 0 1
67813: PPUSH
67814: CALL_OW 476
67818: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67819: LD_ADDR_VAR 0 12
67823: PUSH
67824: LD_VAR 0 1
67828: PPUSH
67829: CALL_OW 477
67833: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67834: LD_ADDR_VAR 0 10
67838: PUSH
67839: LD_VAR 0 1
67843: PPUSH
67844: CALL_OW 478
67848: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67849: LD_VAR 0 9
67853: NOT
67854: PUSH
67855: LD_VAR 0 11
67859: NOT
67860: OR
67861: PUSH
67862: LD_VAR 0 12
67866: NOT
67867: OR
67868: PUSH
67869: LD_VAR 0 10
67873: NOT
67874: OR
67875: IFFALSE 67910
// begin result := [ chassis , engine , control , weapon ] ;
67877: LD_ADDR_VAR 0 6
67881: PUSH
67882: LD_VAR 0 2
67886: PUSH
67887: LD_VAR 0 3
67891: PUSH
67892: LD_VAR 0 4
67896: PUSH
67897: LD_VAR 0 5
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: ST_TO_ADDR
// exit ;
67908: GO 68201
// end ; if not chassis in _chassis then
67910: LD_VAR 0 2
67914: PUSH
67915: LD_VAR 0 9
67919: IN
67920: NOT
67921: IFFALSE 67947
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67923: LD_ADDR_VAR 0 2
67927: PUSH
67928: LD_VAR 0 9
67932: PUSH
67933: LD_INT 1
67935: PPUSH
67936: LD_VAR 0 9
67940: PPUSH
67941: CALL_OW 12
67945: ARRAY
67946: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67947: LD_VAR 0 2
67951: PPUSH
67952: LD_VAR 0 3
67956: PPUSH
67957: CALL 68206 0 2
67961: NOT
67962: IFFALSE 68021
// repeat engine := _engine [ 1 ] ;
67964: LD_ADDR_VAR 0 3
67968: PUSH
67969: LD_VAR 0 11
67973: PUSH
67974: LD_INT 1
67976: ARRAY
67977: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67978: LD_ADDR_VAR 0 11
67982: PUSH
67983: LD_VAR 0 11
67987: PPUSH
67988: LD_INT 1
67990: PPUSH
67991: CALL_OW 3
67995: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67996: LD_VAR 0 2
68000: PPUSH
68001: LD_VAR 0 3
68005: PPUSH
68006: CALL 68206 0 2
68010: PUSH
68011: LD_VAR 0 11
68015: PUSH
68016: EMPTY
68017: EQUAL
68018: OR
68019: IFFALSE 67964
// if not control in _control then
68021: LD_VAR 0 4
68025: PUSH
68026: LD_VAR 0 12
68030: IN
68031: NOT
68032: IFFALSE 68058
// control := _control [ rand ( 1 , _control ) ] ;
68034: LD_ADDR_VAR 0 4
68038: PUSH
68039: LD_VAR 0 12
68043: PUSH
68044: LD_INT 1
68046: PPUSH
68047: LD_VAR 0 12
68051: PPUSH
68052: CALL_OW 12
68056: ARRAY
68057: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68058: LD_VAR 0 2
68062: PPUSH
68063: LD_VAR 0 5
68067: PPUSH
68068: CALL 68426 0 2
68072: NOT
68073: IFFALSE 68132
// repeat weapon := _weapon [ 1 ] ;
68075: LD_ADDR_VAR 0 5
68079: PUSH
68080: LD_VAR 0 10
68084: PUSH
68085: LD_INT 1
68087: ARRAY
68088: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68089: LD_ADDR_VAR 0 10
68093: PUSH
68094: LD_VAR 0 10
68098: PPUSH
68099: LD_INT 1
68101: PPUSH
68102: CALL_OW 3
68106: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68107: LD_VAR 0 2
68111: PPUSH
68112: LD_VAR 0 5
68116: PPUSH
68117: CALL 68426 0 2
68121: PUSH
68122: LD_VAR 0 10
68126: PUSH
68127: EMPTY
68128: EQUAL
68129: OR
68130: IFFALSE 68075
// result := [ ] ;
68132: LD_ADDR_VAR 0 6
68136: PUSH
68137: EMPTY
68138: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68139: LD_VAR 0 1
68143: PPUSH
68144: LD_VAR 0 2
68148: PPUSH
68149: LD_VAR 0 3
68153: PPUSH
68154: LD_VAR 0 4
68158: PPUSH
68159: LD_VAR 0 5
68163: PPUSH
68164: CALL_OW 448
68168: IFFALSE 68201
// result := [ chassis , engine , control , weapon ] ;
68170: LD_ADDR_VAR 0 6
68174: PUSH
68175: LD_VAR 0 2
68179: PUSH
68180: LD_VAR 0 3
68184: PUSH
68185: LD_VAR 0 4
68189: PUSH
68190: LD_VAR 0 5
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: ST_TO_ADDR
// end ;
68201: LD_VAR 0 6
68205: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68206: LD_INT 0
68208: PPUSH
// if not chassis or not engine then
68209: LD_VAR 0 1
68213: NOT
68214: PUSH
68215: LD_VAR 0 2
68219: NOT
68220: OR
68221: IFFALSE 68225
// exit ;
68223: GO 68421
// case engine of engine_solar :
68225: LD_VAR 0 2
68229: PUSH
68230: LD_INT 2
68232: DOUBLE
68233: EQUAL
68234: IFTRUE 68238
68236: GO 68276
68238: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68239: LD_ADDR_VAR 0 3
68243: PUSH
68244: LD_INT 11
68246: PUSH
68247: LD_INT 12
68249: PUSH
68250: LD_INT 13
68252: PUSH
68253: LD_INT 14
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: LD_INT 2
68261: PUSH
68262: LD_INT 3
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: ST_TO_ADDR
68274: GO 68405
68276: LD_INT 1
68278: DOUBLE
68279: EQUAL
68280: IFTRUE 68284
68282: GO 68346
68284: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68285: LD_ADDR_VAR 0 3
68289: PUSH
68290: LD_INT 11
68292: PUSH
68293: LD_INT 12
68295: PUSH
68296: LD_INT 13
68298: PUSH
68299: LD_INT 14
68301: PUSH
68302: LD_INT 1
68304: PUSH
68305: LD_INT 2
68307: PUSH
68308: LD_INT 3
68310: PUSH
68311: LD_INT 4
68313: PUSH
68314: LD_INT 5
68316: PUSH
68317: LD_INT 21
68319: PUSH
68320: LD_INT 23
68322: PUSH
68323: LD_INT 22
68325: PUSH
68326: LD_INT 24
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: ST_TO_ADDR
68344: GO 68405
68346: LD_INT 3
68348: DOUBLE
68349: EQUAL
68350: IFTRUE 68354
68352: GO 68404
68354: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68355: LD_ADDR_VAR 0 3
68359: PUSH
68360: LD_INT 13
68362: PUSH
68363: LD_INT 14
68365: PUSH
68366: LD_INT 2
68368: PUSH
68369: LD_INT 3
68371: PUSH
68372: LD_INT 4
68374: PUSH
68375: LD_INT 5
68377: PUSH
68378: LD_INT 21
68380: PUSH
68381: LD_INT 22
68383: PUSH
68384: LD_INT 23
68386: PUSH
68387: LD_INT 24
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: ST_TO_ADDR
68402: GO 68405
68404: POP
// result := ( chassis in result ) ;
68405: LD_ADDR_VAR 0 3
68409: PUSH
68410: LD_VAR 0 1
68414: PUSH
68415: LD_VAR 0 3
68419: IN
68420: ST_TO_ADDR
// end ;
68421: LD_VAR 0 3
68425: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68426: LD_INT 0
68428: PPUSH
// if not chassis or not weapon then
68429: LD_VAR 0 1
68433: NOT
68434: PUSH
68435: LD_VAR 0 2
68439: NOT
68440: OR
68441: IFFALSE 68445
// exit ;
68443: GO 69471
// case weapon of us_machine_gun :
68445: LD_VAR 0 2
68449: PUSH
68450: LD_INT 2
68452: DOUBLE
68453: EQUAL
68454: IFTRUE 68458
68456: GO 68488
68458: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68459: LD_ADDR_VAR 0 3
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: LD_INT 2
68469: PUSH
68470: LD_INT 3
68472: PUSH
68473: LD_INT 4
68475: PUSH
68476: LD_INT 5
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: ST_TO_ADDR
68486: GO 69455
68488: LD_INT 3
68490: DOUBLE
68491: EQUAL
68492: IFTRUE 68496
68494: GO 68526
68496: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68497: LD_ADDR_VAR 0 3
68501: PUSH
68502: LD_INT 1
68504: PUSH
68505: LD_INT 2
68507: PUSH
68508: LD_INT 3
68510: PUSH
68511: LD_INT 4
68513: PUSH
68514: LD_INT 5
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: ST_TO_ADDR
68524: GO 69455
68526: LD_INT 11
68528: DOUBLE
68529: EQUAL
68530: IFTRUE 68534
68532: GO 68564
68534: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68535: LD_ADDR_VAR 0 3
68539: PUSH
68540: LD_INT 1
68542: PUSH
68543: LD_INT 2
68545: PUSH
68546: LD_INT 3
68548: PUSH
68549: LD_INT 4
68551: PUSH
68552: LD_INT 5
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: ST_TO_ADDR
68562: GO 69455
68564: LD_INT 4
68566: DOUBLE
68567: EQUAL
68568: IFTRUE 68572
68570: GO 68598
68572: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68573: LD_ADDR_VAR 0 3
68577: PUSH
68578: LD_INT 2
68580: PUSH
68581: LD_INT 3
68583: PUSH
68584: LD_INT 4
68586: PUSH
68587: LD_INT 5
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: ST_TO_ADDR
68596: GO 69455
68598: LD_INT 5
68600: DOUBLE
68601: EQUAL
68602: IFTRUE 68606
68604: GO 68632
68606: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68607: LD_ADDR_VAR 0 3
68611: PUSH
68612: LD_INT 2
68614: PUSH
68615: LD_INT 3
68617: PUSH
68618: LD_INT 4
68620: PUSH
68621: LD_INT 5
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: ST_TO_ADDR
68630: GO 69455
68632: LD_INT 9
68634: DOUBLE
68635: EQUAL
68636: IFTRUE 68640
68638: GO 68666
68640: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68641: LD_ADDR_VAR 0 3
68645: PUSH
68646: LD_INT 2
68648: PUSH
68649: LD_INT 3
68651: PUSH
68652: LD_INT 4
68654: PUSH
68655: LD_INT 5
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: ST_TO_ADDR
68664: GO 69455
68666: LD_INT 7
68668: DOUBLE
68669: EQUAL
68670: IFTRUE 68674
68672: GO 68700
68674: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68675: LD_ADDR_VAR 0 3
68679: PUSH
68680: LD_INT 2
68682: PUSH
68683: LD_INT 3
68685: PUSH
68686: LD_INT 4
68688: PUSH
68689: LD_INT 5
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: ST_TO_ADDR
68698: GO 69455
68700: LD_INT 12
68702: DOUBLE
68703: EQUAL
68704: IFTRUE 68708
68706: GO 68734
68708: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68709: LD_ADDR_VAR 0 3
68713: PUSH
68714: LD_INT 2
68716: PUSH
68717: LD_INT 3
68719: PUSH
68720: LD_INT 4
68722: PUSH
68723: LD_INT 5
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: ST_TO_ADDR
68732: GO 69455
68734: LD_INT 13
68736: DOUBLE
68737: EQUAL
68738: IFTRUE 68742
68740: GO 68768
68742: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68743: LD_ADDR_VAR 0 3
68747: PUSH
68748: LD_INT 2
68750: PUSH
68751: LD_INT 3
68753: PUSH
68754: LD_INT 4
68756: PUSH
68757: LD_INT 5
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: ST_TO_ADDR
68766: GO 69455
68768: LD_INT 14
68770: DOUBLE
68771: EQUAL
68772: IFTRUE 68776
68774: GO 68794
68776: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68777: LD_ADDR_VAR 0 3
68781: PUSH
68782: LD_INT 4
68784: PUSH
68785: LD_INT 5
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: ST_TO_ADDR
68792: GO 69455
68794: LD_INT 6
68796: DOUBLE
68797: EQUAL
68798: IFTRUE 68802
68800: GO 68820
68802: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68803: LD_ADDR_VAR 0 3
68807: PUSH
68808: LD_INT 4
68810: PUSH
68811: LD_INT 5
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: ST_TO_ADDR
68818: GO 69455
68820: LD_INT 10
68822: DOUBLE
68823: EQUAL
68824: IFTRUE 68828
68826: GO 68846
68828: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68829: LD_ADDR_VAR 0 3
68833: PUSH
68834: LD_INT 4
68836: PUSH
68837: LD_INT 5
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: ST_TO_ADDR
68844: GO 69455
68846: LD_INT 22
68848: DOUBLE
68849: EQUAL
68850: IFTRUE 68854
68852: GO 68880
68854: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68855: LD_ADDR_VAR 0 3
68859: PUSH
68860: LD_INT 11
68862: PUSH
68863: LD_INT 12
68865: PUSH
68866: LD_INT 13
68868: PUSH
68869: LD_INT 14
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: ST_TO_ADDR
68878: GO 69455
68880: LD_INT 23
68882: DOUBLE
68883: EQUAL
68884: IFTRUE 68888
68886: GO 68914
68888: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68889: LD_ADDR_VAR 0 3
68893: PUSH
68894: LD_INT 11
68896: PUSH
68897: LD_INT 12
68899: PUSH
68900: LD_INT 13
68902: PUSH
68903: LD_INT 14
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: ST_TO_ADDR
68912: GO 69455
68914: LD_INT 24
68916: DOUBLE
68917: EQUAL
68918: IFTRUE 68922
68920: GO 68948
68922: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68923: LD_ADDR_VAR 0 3
68927: PUSH
68928: LD_INT 11
68930: PUSH
68931: LD_INT 12
68933: PUSH
68934: LD_INT 13
68936: PUSH
68937: LD_INT 14
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: ST_TO_ADDR
68946: GO 69455
68948: LD_INT 30
68950: DOUBLE
68951: EQUAL
68952: IFTRUE 68956
68954: GO 68982
68956: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68957: LD_ADDR_VAR 0 3
68961: PUSH
68962: LD_INT 11
68964: PUSH
68965: LD_INT 12
68967: PUSH
68968: LD_INT 13
68970: PUSH
68971: LD_INT 14
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: LIST
68978: LIST
68979: ST_TO_ADDR
68980: GO 69455
68982: LD_INT 25
68984: DOUBLE
68985: EQUAL
68986: IFTRUE 68990
68988: GO 69008
68990: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68991: LD_ADDR_VAR 0 3
68995: PUSH
68996: LD_INT 13
68998: PUSH
68999: LD_INT 14
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: ST_TO_ADDR
69006: GO 69455
69008: LD_INT 27
69010: DOUBLE
69011: EQUAL
69012: IFTRUE 69016
69014: GO 69034
69016: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69017: LD_ADDR_VAR 0 3
69021: PUSH
69022: LD_INT 13
69024: PUSH
69025: LD_INT 14
69027: PUSH
69028: EMPTY
69029: LIST
69030: LIST
69031: ST_TO_ADDR
69032: GO 69455
69034: LD_INT 28
69036: DOUBLE
69037: EQUAL
69038: IFTRUE 69042
69040: GO 69060
69042: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69043: LD_ADDR_VAR 0 3
69047: PUSH
69048: LD_INT 13
69050: PUSH
69051: LD_INT 14
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: ST_TO_ADDR
69058: GO 69455
69060: LD_INT 29
69062: DOUBLE
69063: EQUAL
69064: IFTRUE 69068
69066: GO 69086
69068: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69069: LD_ADDR_VAR 0 3
69073: PUSH
69074: LD_INT 13
69076: PUSH
69077: LD_INT 14
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: ST_TO_ADDR
69084: GO 69455
69086: LD_INT 31
69088: DOUBLE
69089: EQUAL
69090: IFTRUE 69094
69092: GO 69112
69094: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69095: LD_ADDR_VAR 0 3
69099: PUSH
69100: LD_INT 13
69102: PUSH
69103: LD_INT 14
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: ST_TO_ADDR
69110: GO 69455
69112: LD_INT 26
69114: DOUBLE
69115: EQUAL
69116: IFTRUE 69120
69118: GO 69138
69120: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69121: LD_ADDR_VAR 0 3
69125: PUSH
69126: LD_INT 13
69128: PUSH
69129: LD_INT 14
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: ST_TO_ADDR
69136: GO 69455
69138: LD_INT 42
69140: DOUBLE
69141: EQUAL
69142: IFTRUE 69146
69144: GO 69172
69146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69147: LD_ADDR_VAR 0 3
69151: PUSH
69152: LD_INT 21
69154: PUSH
69155: LD_INT 22
69157: PUSH
69158: LD_INT 23
69160: PUSH
69161: LD_INT 24
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: ST_TO_ADDR
69170: GO 69455
69172: LD_INT 43
69174: DOUBLE
69175: EQUAL
69176: IFTRUE 69180
69178: GO 69206
69180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69181: LD_ADDR_VAR 0 3
69185: PUSH
69186: LD_INT 21
69188: PUSH
69189: LD_INT 22
69191: PUSH
69192: LD_INT 23
69194: PUSH
69195: LD_INT 24
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: ST_TO_ADDR
69204: GO 69455
69206: LD_INT 44
69208: DOUBLE
69209: EQUAL
69210: IFTRUE 69214
69212: GO 69240
69214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69215: LD_ADDR_VAR 0 3
69219: PUSH
69220: LD_INT 21
69222: PUSH
69223: LD_INT 22
69225: PUSH
69226: LD_INT 23
69228: PUSH
69229: LD_INT 24
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: ST_TO_ADDR
69238: GO 69455
69240: LD_INT 45
69242: DOUBLE
69243: EQUAL
69244: IFTRUE 69248
69246: GO 69274
69248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69249: LD_ADDR_VAR 0 3
69253: PUSH
69254: LD_INT 21
69256: PUSH
69257: LD_INT 22
69259: PUSH
69260: LD_INT 23
69262: PUSH
69263: LD_INT 24
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: ST_TO_ADDR
69272: GO 69455
69274: LD_INT 49
69276: DOUBLE
69277: EQUAL
69278: IFTRUE 69282
69280: GO 69308
69282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69283: LD_ADDR_VAR 0 3
69287: PUSH
69288: LD_INT 21
69290: PUSH
69291: LD_INT 22
69293: PUSH
69294: LD_INT 23
69296: PUSH
69297: LD_INT 24
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: ST_TO_ADDR
69306: GO 69455
69308: LD_INT 51
69310: DOUBLE
69311: EQUAL
69312: IFTRUE 69316
69314: GO 69342
69316: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69317: LD_ADDR_VAR 0 3
69321: PUSH
69322: LD_INT 21
69324: PUSH
69325: LD_INT 22
69327: PUSH
69328: LD_INT 23
69330: PUSH
69331: LD_INT 24
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: ST_TO_ADDR
69340: GO 69455
69342: LD_INT 52
69344: DOUBLE
69345: EQUAL
69346: IFTRUE 69350
69348: GO 69376
69350: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69351: LD_ADDR_VAR 0 3
69355: PUSH
69356: LD_INT 21
69358: PUSH
69359: LD_INT 22
69361: PUSH
69362: LD_INT 23
69364: PUSH
69365: LD_INT 24
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: LIST
69372: LIST
69373: ST_TO_ADDR
69374: GO 69455
69376: LD_INT 53
69378: DOUBLE
69379: EQUAL
69380: IFTRUE 69384
69382: GO 69402
69384: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69385: LD_ADDR_VAR 0 3
69389: PUSH
69390: LD_INT 23
69392: PUSH
69393: LD_INT 24
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: ST_TO_ADDR
69400: GO 69455
69402: LD_INT 46
69404: DOUBLE
69405: EQUAL
69406: IFTRUE 69410
69408: GO 69428
69410: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69411: LD_ADDR_VAR 0 3
69415: PUSH
69416: LD_INT 23
69418: PUSH
69419: LD_INT 24
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: ST_TO_ADDR
69426: GO 69455
69428: LD_INT 47
69430: DOUBLE
69431: EQUAL
69432: IFTRUE 69436
69434: GO 69454
69436: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69437: LD_ADDR_VAR 0 3
69441: PUSH
69442: LD_INT 23
69444: PUSH
69445: LD_INT 24
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: ST_TO_ADDR
69452: GO 69455
69454: POP
// result := ( chassis in result ) ;
69455: LD_ADDR_VAR 0 3
69459: PUSH
69460: LD_VAR 0 1
69464: PUSH
69465: LD_VAR 0 3
69469: IN
69470: ST_TO_ADDR
// end ;
69471: LD_VAR 0 3
69475: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69476: LD_INT 0
69478: PPUSH
69479: PPUSH
69480: PPUSH
69481: PPUSH
69482: PPUSH
69483: PPUSH
69484: PPUSH
// result := array ;
69485: LD_ADDR_VAR 0 5
69489: PUSH
69490: LD_VAR 0 1
69494: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69495: LD_VAR 0 1
69499: NOT
69500: PUSH
69501: LD_VAR 0 2
69505: NOT
69506: OR
69507: PUSH
69508: LD_VAR 0 3
69512: NOT
69513: OR
69514: PUSH
69515: LD_VAR 0 2
69519: PUSH
69520: LD_VAR 0 1
69524: GREATER
69525: OR
69526: PUSH
69527: LD_VAR 0 3
69531: PUSH
69532: LD_VAR 0 1
69536: GREATER
69537: OR
69538: IFFALSE 69542
// exit ;
69540: GO 69838
// if direction then
69542: LD_VAR 0 4
69546: IFFALSE 69610
// begin d := 1 ;
69548: LD_ADDR_VAR 0 9
69552: PUSH
69553: LD_INT 1
69555: ST_TO_ADDR
// if i_from > i_to then
69556: LD_VAR 0 2
69560: PUSH
69561: LD_VAR 0 3
69565: GREATER
69566: IFFALSE 69592
// length := ( array - i_from ) + i_to else
69568: LD_ADDR_VAR 0 11
69572: PUSH
69573: LD_VAR 0 1
69577: PUSH
69578: LD_VAR 0 2
69582: MINUS
69583: PUSH
69584: LD_VAR 0 3
69588: PLUS
69589: ST_TO_ADDR
69590: GO 69608
// length := i_to - i_from ;
69592: LD_ADDR_VAR 0 11
69596: PUSH
69597: LD_VAR 0 3
69601: PUSH
69602: LD_VAR 0 2
69606: MINUS
69607: ST_TO_ADDR
// end else
69608: GO 69671
// begin d := - 1 ;
69610: LD_ADDR_VAR 0 9
69614: PUSH
69615: LD_INT 1
69617: NEG
69618: ST_TO_ADDR
// if i_from > i_to then
69619: LD_VAR 0 2
69623: PUSH
69624: LD_VAR 0 3
69628: GREATER
69629: IFFALSE 69649
// length := i_from - i_to else
69631: LD_ADDR_VAR 0 11
69635: PUSH
69636: LD_VAR 0 2
69640: PUSH
69641: LD_VAR 0 3
69645: MINUS
69646: ST_TO_ADDR
69647: GO 69671
// length := ( array - i_to ) + i_from ;
69649: LD_ADDR_VAR 0 11
69653: PUSH
69654: LD_VAR 0 1
69658: PUSH
69659: LD_VAR 0 3
69663: MINUS
69664: PUSH
69665: LD_VAR 0 2
69669: PLUS
69670: ST_TO_ADDR
// end ; if not length then
69671: LD_VAR 0 11
69675: NOT
69676: IFFALSE 69680
// exit ;
69678: GO 69838
// tmp := array ;
69680: LD_ADDR_VAR 0 10
69684: PUSH
69685: LD_VAR 0 1
69689: ST_TO_ADDR
// for i = 1 to length do
69690: LD_ADDR_VAR 0 6
69694: PUSH
69695: DOUBLE
69696: LD_INT 1
69698: DEC
69699: ST_TO_ADDR
69700: LD_VAR 0 11
69704: PUSH
69705: FOR_TO
69706: IFFALSE 69826
// begin for j = 1 to array do
69708: LD_ADDR_VAR 0 7
69712: PUSH
69713: DOUBLE
69714: LD_INT 1
69716: DEC
69717: ST_TO_ADDR
69718: LD_VAR 0 1
69722: PUSH
69723: FOR_TO
69724: IFFALSE 69812
// begin k := j + d ;
69726: LD_ADDR_VAR 0 8
69730: PUSH
69731: LD_VAR 0 7
69735: PUSH
69736: LD_VAR 0 9
69740: PLUS
69741: ST_TO_ADDR
// if k > array then
69742: LD_VAR 0 8
69746: PUSH
69747: LD_VAR 0 1
69751: GREATER
69752: IFFALSE 69762
// k := 1 ;
69754: LD_ADDR_VAR 0 8
69758: PUSH
69759: LD_INT 1
69761: ST_TO_ADDR
// if not k then
69762: LD_VAR 0 8
69766: NOT
69767: IFFALSE 69779
// k := array ;
69769: LD_ADDR_VAR 0 8
69773: PUSH
69774: LD_VAR 0 1
69778: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69779: LD_ADDR_VAR 0 10
69783: PUSH
69784: LD_VAR 0 10
69788: PPUSH
69789: LD_VAR 0 8
69793: PPUSH
69794: LD_VAR 0 1
69798: PUSH
69799: LD_VAR 0 7
69803: ARRAY
69804: PPUSH
69805: CALL_OW 1
69809: ST_TO_ADDR
// end ;
69810: GO 69723
69812: POP
69813: POP
// array := tmp ;
69814: LD_ADDR_VAR 0 1
69818: PUSH
69819: LD_VAR 0 10
69823: ST_TO_ADDR
// end ;
69824: GO 69705
69826: POP
69827: POP
// result := array ;
69828: LD_ADDR_VAR 0 5
69832: PUSH
69833: LD_VAR 0 1
69837: ST_TO_ADDR
// end ;
69838: LD_VAR 0 5
69842: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69843: LD_INT 0
69845: PPUSH
69846: PPUSH
// result := 0 ;
69847: LD_ADDR_VAR 0 3
69851: PUSH
69852: LD_INT 0
69854: ST_TO_ADDR
// if not array or not value in array then
69855: LD_VAR 0 1
69859: NOT
69860: PUSH
69861: LD_VAR 0 2
69865: PUSH
69866: LD_VAR 0 1
69870: IN
69871: NOT
69872: OR
69873: IFFALSE 69877
// exit ;
69875: GO 69931
// for i = 1 to array do
69877: LD_ADDR_VAR 0 4
69881: PUSH
69882: DOUBLE
69883: LD_INT 1
69885: DEC
69886: ST_TO_ADDR
69887: LD_VAR 0 1
69891: PUSH
69892: FOR_TO
69893: IFFALSE 69929
// if value = array [ i ] then
69895: LD_VAR 0 2
69899: PUSH
69900: LD_VAR 0 1
69904: PUSH
69905: LD_VAR 0 4
69909: ARRAY
69910: EQUAL
69911: IFFALSE 69927
// begin result := i ;
69913: LD_ADDR_VAR 0 3
69917: PUSH
69918: LD_VAR 0 4
69922: ST_TO_ADDR
// exit ;
69923: POP
69924: POP
69925: GO 69931
// end ;
69927: GO 69892
69929: POP
69930: POP
// end ;
69931: LD_VAR 0 3
69935: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69936: LD_INT 0
69938: PPUSH
// vc_chassis := chassis ;
69939: LD_ADDR_OWVAR 37
69943: PUSH
69944: LD_VAR 0 1
69948: ST_TO_ADDR
// vc_engine := engine ;
69949: LD_ADDR_OWVAR 39
69953: PUSH
69954: LD_VAR 0 2
69958: ST_TO_ADDR
// vc_control := control ;
69959: LD_ADDR_OWVAR 38
69963: PUSH
69964: LD_VAR 0 3
69968: ST_TO_ADDR
// vc_weapon := weapon ;
69969: LD_ADDR_OWVAR 40
69973: PUSH
69974: LD_VAR 0 4
69978: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69979: LD_ADDR_OWVAR 41
69983: PUSH
69984: LD_VAR 0 5
69988: ST_TO_ADDR
// end ;
69989: LD_VAR 0 6
69993: RET
// export function WantPlant ( unit ) ; var task ; begin
69994: LD_INT 0
69996: PPUSH
69997: PPUSH
// result := false ;
69998: LD_ADDR_VAR 0 2
70002: PUSH
70003: LD_INT 0
70005: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70006: LD_ADDR_VAR 0 3
70010: PUSH
70011: LD_VAR 0 1
70015: PPUSH
70016: CALL_OW 437
70020: ST_TO_ADDR
// if task then
70021: LD_VAR 0 3
70025: IFFALSE 70053
// if task [ 1 ] [ 1 ] = p then
70027: LD_VAR 0 3
70031: PUSH
70032: LD_INT 1
70034: ARRAY
70035: PUSH
70036: LD_INT 1
70038: ARRAY
70039: PUSH
70040: LD_STRING p
70042: EQUAL
70043: IFFALSE 70053
// result := true ;
70045: LD_ADDR_VAR 0 2
70049: PUSH
70050: LD_INT 1
70052: ST_TO_ADDR
// end ;
70053: LD_VAR 0 2
70057: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70058: LD_INT 0
70060: PPUSH
70061: PPUSH
70062: PPUSH
70063: PPUSH
// if pos < 1 then
70064: LD_VAR 0 2
70068: PUSH
70069: LD_INT 1
70071: LESS
70072: IFFALSE 70076
// exit ;
70074: GO 70379
// if pos = 1 then
70076: LD_VAR 0 2
70080: PUSH
70081: LD_INT 1
70083: EQUAL
70084: IFFALSE 70117
// result := Replace ( arr , pos [ 1 ] , value ) else
70086: LD_ADDR_VAR 0 4
70090: PUSH
70091: LD_VAR 0 1
70095: PPUSH
70096: LD_VAR 0 2
70100: PUSH
70101: LD_INT 1
70103: ARRAY
70104: PPUSH
70105: LD_VAR 0 3
70109: PPUSH
70110: CALL_OW 1
70114: ST_TO_ADDR
70115: GO 70379
// begin tmp := arr ;
70117: LD_ADDR_VAR 0 6
70121: PUSH
70122: LD_VAR 0 1
70126: ST_TO_ADDR
// s_arr := [ tmp ] ;
70127: LD_ADDR_VAR 0 7
70131: PUSH
70132: LD_VAR 0 6
70136: PUSH
70137: EMPTY
70138: LIST
70139: ST_TO_ADDR
// for i = 1 to pos - 1 do
70140: LD_ADDR_VAR 0 5
70144: PUSH
70145: DOUBLE
70146: LD_INT 1
70148: DEC
70149: ST_TO_ADDR
70150: LD_VAR 0 2
70154: PUSH
70155: LD_INT 1
70157: MINUS
70158: PUSH
70159: FOR_TO
70160: IFFALSE 70205
// begin tmp := tmp [ pos [ i ] ] ;
70162: LD_ADDR_VAR 0 6
70166: PUSH
70167: LD_VAR 0 6
70171: PUSH
70172: LD_VAR 0 2
70176: PUSH
70177: LD_VAR 0 5
70181: ARRAY
70182: ARRAY
70183: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70184: LD_ADDR_VAR 0 7
70188: PUSH
70189: LD_VAR 0 7
70193: PUSH
70194: LD_VAR 0 6
70198: PUSH
70199: EMPTY
70200: LIST
70201: ADD
70202: ST_TO_ADDR
// end ;
70203: GO 70159
70205: POP
70206: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70207: LD_ADDR_VAR 0 6
70211: PUSH
70212: LD_VAR 0 6
70216: PPUSH
70217: LD_VAR 0 2
70221: PUSH
70222: LD_VAR 0 2
70226: ARRAY
70227: PPUSH
70228: LD_VAR 0 3
70232: PPUSH
70233: CALL_OW 1
70237: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70238: LD_ADDR_VAR 0 7
70242: PUSH
70243: LD_VAR 0 7
70247: PPUSH
70248: LD_VAR 0 7
70252: PPUSH
70253: LD_VAR 0 6
70257: PPUSH
70258: CALL_OW 1
70262: ST_TO_ADDR
// for i = s_arr downto 2 do
70263: LD_ADDR_VAR 0 5
70267: PUSH
70268: DOUBLE
70269: LD_VAR 0 7
70273: INC
70274: ST_TO_ADDR
70275: LD_INT 2
70277: PUSH
70278: FOR_DOWNTO
70279: IFFALSE 70363
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70281: LD_ADDR_VAR 0 6
70285: PUSH
70286: LD_VAR 0 7
70290: PUSH
70291: LD_VAR 0 5
70295: PUSH
70296: LD_INT 1
70298: MINUS
70299: ARRAY
70300: PPUSH
70301: LD_VAR 0 2
70305: PUSH
70306: LD_VAR 0 5
70310: PUSH
70311: LD_INT 1
70313: MINUS
70314: ARRAY
70315: PPUSH
70316: LD_VAR 0 7
70320: PUSH
70321: LD_VAR 0 5
70325: ARRAY
70326: PPUSH
70327: CALL_OW 1
70331: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70332: LD_ADDR_VAR 0 7
70336: PUSH
70337: LD_VAR 0 7
70341: PPUSH
70342: LD_VAR 0 5
70346: PUSH
70347: LD_INT 1
70349: MINUS
70350: PPUSH
70351: LD_VAR 0 6
70355: PPUSH
70356: CALL_OW 1
70360: ST_TO_ADDR
// end ;
70361: GO 70278
70363: POP
70364: POP
// result := s_arr [ 1 ] ;
70365: LD_ADDR_VAR 0 4
70369: PUSH
70370: LD_VAR 0 7
70374: PUSH
70375: LD_INT 1
70377: ARRAY
70378: ST_TO_ADDR
// end ; end ;
70379: LD_VAR 0 4
70383: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70384: LD_INT 0
70386: PPUSH
70387: PPUSH
// if not list then
70388: LD_VAR 0 1
70392: NOT
70393: IFFALSE 70397
// exit ;
70395: GO 70488
// i := list [ pos1 ] ;
70397: LD_ADDR_VAR 0 5
70401: PUSH
70402: LD_VAR 0 1
70406: PUSH
70407: LD_VAR 0 2
70411: ARRAY
70412: ST_TO_ADDR
// if not i then
70413: LD_VAR 0 5
70417: NOT
70418: IFFALSE 70422
// exit ;
70420: GO 70488
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70422: LD_ADDR_VAR 0 1
70426: PUSH
70427: LD_VAR 0 1
70431: PPUSH
70432: LD_VAR 0 2
70436: PPUSH
70437: LD_VAR 0 1
70441: PUSH
70442: LD_VAR 0 3
70446: ARRAY
70447: PPUSH
70448: CALL_OW 1
70452: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70453: LD_ADDR_VAR 0 1
70457: PUSH
70458: LD_VAR 0 1
70462: PPUSH
70463: LD_VAR 0 3
70467: PPUSH
70468: LD_VAR 0 5
70472: PPUSH
70473: CALL_OW 1
70477: ST_TO_ADDR
// result := list ;
70478: LD_ADDR_VAR 0 4
70482: PUSH
70483: LD_VAR 0 1
70487: ST_TO_ADDR
// end ;
70488: LD_VAR 0 4
70492: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70493: LD_INT 0
70495: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70496: LD_ADDR_VAR 0 5
70500: PUSH
70501: LD_VAR 0 1
70505: PPUSH
70506: CALL_OW 250
70510: PPUSH
70511: LD_VAR 0 1
70515: PPUSH
70516: CALL_OW 251
70520: PPUSH
70521: LD_VAR 0 2
70525: PPUSH
70526: LD_VAR 0 3
70530: PPUSH
70531: LD_VAR 0 4
70535: PPUSH
70536: CALL 70546 0 5
70540: ST_TO_ADDR
// end ;
70541: LD_VAR 0 5
70545: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70546: LD_INT 0
70548: PPUSH
70549: PPUSH
70550: PPUSH
70551: PPUSH
// if not list then
70552: LD_VAR 0 3
70556: NOT
70557: IFFALSE 70561
// exit ;
70559: GO 70949
// result := [ ] ;
70561: LD_ADDR_VAR 0 6
70565: PUSH
70566: EMPTY
70567: ST_TO_ADDR
// for i in list do
70568: LD_ADDR_VAR 0 7
70572: PUSH
70573: LD_VAR 0 3
70577: PUSH
70578: FOR_IN
70579: IFFALSE 70781
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70581: LD_ADDR_VAR 0 9
70585: PUSH
70586: LD_VAR 0 7
70590: PPUSH
70591: LD_VAR 0 1
70595: PPUSH
70596: LD_VAR 0 2
70600: PPUSH
70601: CALL_OW 297
70605: ST_TO_ADDR
// if not result then
70606: LD_VAR 0 6
70610: NOT
70611: IFFALSE 70637
// result := [ [ i , tmp ] ] else
70613: LD_ADDR_VAR 0 6
70617: PUSH
70618: LD_VAR 0 7
70622: PUSH
70623: LD_VAR 0 9
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: EMPTY
70633: LIST
70634: ST_TO_ADDR
70635: GO 70779
// begin if result [ result ] [ 2 ] < tmp then
70637: LD_VAR 0 6
70641: PUSH
70642: LD_VAR 0 6
70646: ARRAY
70647: PUSH
70648: LD_INT 2
70650: ARRAY
70651: PUSH
70652: LD_VAR 0 9
70656: LESS
70657: IFFALSE 70699
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70659: LD_ADDR_VAR 0 6
70663: PUSH
70664: LD_VAR 0 6
70668: PPUSH
70669: LD_VAR 0 6
70673: PUSH
70674: LD_INT 1
70676: PLUS
70677: PPUSH
70678: LD_VAR 0 7
70682: PUSH
70683: LD_VAR 0 9
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PPUSH
70692: CALL_OW 2
70696: ST_TO_ADDR
70697: GO 70779
// for j = 1 to result do
70699: LD_ADDR_VAR 0 8
70703: PUSH
70704: DOUBLE
70705: LD_INT 1
70707: DEC
70708: ST_TO_ADDR
70709: LD_VAR 0 6
70713: PUSH
70714: FOR_TO
70715: IFFALSE 70777
// begin if tmp < result [ j ] [ 2 ] then
70717: LD_VAR 0 9
70721: PUSH
70722: LD_VAR 0 6
70726: PUSH
70727: LD_VAR 0 8
70731: ARRAY
70732: PUSH
70733: LD_INT 2
70735: ARRAY
70736: LESS
70737: IFFALSE 70775
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70739: LD_ADDR_VAR 0 6
70743: PUSH
70744: LD_VAR 0 6
70748: PPUSH
70749: LD_VAR 0 8
70753: PPUSH
70754: LD_VAR 0 7
70758: PUSH
70759: LD_VAR 0 9
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PPUSH
70768: CALL_OW 2
70772: ST_TO_ADDR
// break ;
70773: GO 70777
// end ; end ;
70775: GO 70714
70777: POP
70778: POP
// end ; end ;
70779: GO 70578
70781: POP
70782: POP
// if result and not asc then
70783: LD_VAR 0 6
70787: PUSH
70788: LD_VAR 0 4
70792: NOT
70793: AND
70794: IFFALSE 70869
// begin tmp := result ;
70796: LD_ADDR_VAR 0 9
70800: PUSH
70801: LD_VAR 0 6
70805: ST_TO_ADDR
// for i = tmp downto 1 do
70806: LD_ADDR_VAR 0 7
70810: PUSH
70811: DOUBLE
70812: LD_VAR 0 9
70816: INC
70817: ST_TO_ADDR
70818: LD_INT 1
70820: PUSH
70821: FOR_DOWNTO
70822: IFFALSE 70867
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70824: LD_ADDR_VAR 0 6
70828: PUSH
70829: LD_VAR 0 6
70833: PPUSH
70834: LD_VAR 0 9
70838: PUSH
70839: LD_VAR 0 7
70843: MINUS
70844: PUSH
70845: LD_INT 1
70847: PLUS
70848: PPUSH
70849: LD_VAR 0 9
70853: PUSH
70854: LD_VAR 0 7
70858: ARRAY
70859: PPUSH
70860: CALL_OW 1
70864: ST_TO_ADDR
70865: GO 70821
70867: POP
70868: POP
// end ; tmp := [ ] ;
70869: LD_ADDR_VAR 0 9
70873: PUSH
70874: EMPTY
70875: ST_TO_ADDR
// if mode then
70876: LD_VAR 0 5
70880: IFFALSE 70949
// begin for i = 1 to result do
70882: LD_ADDR_VAR 0 7
70886: PUSH
70887: DOUBLE
70888: LD_INT 1
70890: DEC
70891: ST_TO_ADDR
70892: LD_VAR 0 6
70896: PUSH
70897: FOR_TO
70898: IFFALSE 70937
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70900: LD_ADDR_VAR 0 9
70904: PUSH
70905: LD_VAR 0 9
70909: PPUSH
70910: LD_VAR 0 7
70914: PPUSH
70915: LD_VAR 0 6
70919: PUSH
70920: LD_VAR 0 7
70924: ARRAY
70925: PUSH
70926: LD_INT 1
70928: ARRAY
70929: PPUSH
70930: CALL_OW 1
70934: ST_TO_ADDR
70935: GO 70897
70937: POP
70938: POP
// result := tmp ;
70939: LD_ADDR_VAR 0 6
70943: PUSH
70944: LD_VAR 0 9
70948: ST_TO_ADDR
// end ; end ;
70949: LD_VAR 0 6
70953: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70954: LD_INT 0
70956: PPUSH
70957: PPUSH
70958: PPUSH
70959: PPUSH
70960: PPUSH
70961: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70962: LD_ADDR_VAR 0 5
70966: PUSH
70967: LD_INT 0
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: LD_INT 0
70975: PUSH
70976: EMPTY
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: ST_TO_ADDR
// if not x or not y then
70984: LD_VAR 0 2
70988: NOT
70989: PUSH
70990: LD_VAR 0 3
70994: NOT
70995: OR
70996: IFFALSE 71000
// exit ;
70998: GO 72646
// if not range then
71000: LD_VAR 0 4
71004: NOT
71005: IFFALSE 71015
// range := 10 ;
71007: LD_ADDR_VAR 0 4
71011: PUSH
71012: LD_INT 10
71014: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71015: LD_ADDR_VAR 0 8
71019: PUSH
71020: LD_INT 81
71022: PUSH
71023: LD_VAR 0 1
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 92
71034: PUSH
71035: LD_VAR 0 2
71039: PUSH
71040: LD_VAR 0 3
71044: PUSH
71045: LD_VAR 0 4
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 3
71058: PUSH
71059: LD_INT 21
71061: PUSH
71062: LD_INT 3
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: LIST
71077: PPUSH
71078: CALL_OW 69
71082: ST_TO_ADDR
// if not tmp then
71083: LD_VAR 0 8
71087: NOT
71088: IFFALSE 71092
// exit ;
71090: GO 72646
// for i in tmp do
71092: LD_ADDR_VAR 0 6
71096: PUSH
71097: LD_VAR 0 8
71101: PUSH
71102: FOR_IN
71103: IFFALSE 72621
// begin points := [ 0 , 0 , 0 ] ;
71105: LD_ADDR_VAR 0 9
71109: PUSH
71110: LD_INT 0
71112: PUSH
71113: LD_INT 0
71115: PUSH
71116: LD_INT 0
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: LIST
71123: ST_TO_ADDR
// bpoints := 1 ;
71124: LD_ADDR_VAR 0 10
71128: PUSH
71129: LD_INT 1
71131: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71132: LD_VAR 0 6
71136: PPUSH
71137: CALL_OW 247
71141: PUSH
71142: LD_INT 1
71144: DOUBLE
71145: EQUAL
71146: IFTRUE 71150
71148: GO 71728
71150: POP
// begin if GetClass ( i ) = 1 then
71151: LD_VAR 0 6
71155: PPUSH
71156: CALL_OW 257
71160: PUSH
71161: LD_INT 1
71163: EQUAL
71164: IFFALSE 71185
// points := [ 10 , 5 , 3 ] ;
71166: LD_ADDR_VAR 0 9
71170: PUSH
71171: LD_INT 10
71173: PUSH
71174: LD_INT 5
71176: PUSH
71177: LD_INT 3
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: LIST
71184: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71185: LD_VAR 0 6
71189: PPUSH
71190: CALL_OW 257
71194: PUSH
71195: LD_INT 2
71197: PUSH
71198: LD_INT 3
71200: PUSH
71201: LD_INT 4
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: LIST
71208: IN
71209: IFFALSE 71230
// points := [ 3 , 2 , 1 ] ;
71211: LD_ADDR_VAR 0 9
71215: PUSH
71216: LD_INT 3
71218: PUSH
71219: LD_INT 2
71221: PUSH
71222: LD_INT 1
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: LIST
71229: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71230: LD_VAR 0 6
71234: PPUSH
71235: CALL_OW 257
71239: PUSH
71240: LD_INT 5
71242: EQUAL
71243: IFFALSE 71264
// points := [ 130 , 5 , 2 ] ;
71245: LD_ADDR_VAR 0 9
71249: PUSH
71250: LD_INT 130
71252: PUSH
71253: LD_INT 5
71255: PUSH
71256: LD_INT 2
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: LIST
71263: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71264: LD_VAR 0 6
71268: PPUSH
71269: CALL_OW 257
71273: PUSH
71274: LD_INT 8
71276: EQUAL
71277: IFFALSE 71298
// points := [ 35 , 35 , 30 ] ;
71279: LD_ADDR_VAR 0 9
71283: PUSH
71284: LD_INT 35
71286: PUSH
71287: LD_INT 35
71289: PUSH
71290: LD_INT 30
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: LIST
71297: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71298: LD_VAR 0 6
71302: PPUSH
71303: CALL_OW 257
71307: PUSH
71308: LD_INT 9
71310: EQUAL
71311: IFFALSE 71332
// points := [ 20 , 55 , 40 ] ;
71313: LD_ADDR_VAR 0 9
71317: PUSH
71318: LD_INT 20
71320: PUSH
71321: LD_INT 55
71323: PUSH
71324: LD_INT 40
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: LIST
71331: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71332: LD_VAR 0 6
71336: PPUSH
71337: CALL_OW 257
71341: PUSH
71342: LD_INT 12
71344: PUSH
71345: LD_INT 16
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: IN
71352: IFFALSE 71373
// points := [ 5 , 3 , 2 ] ;
71354: LD_ADDR_VAR 0 9
71358: PUSH
71359: LD_INT 5
71361: PUSH
71362: LD_INT 3
71364: PUSH
71365: LD_INT 2
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: LIST
71372: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71373: LD_VAR 0 6
71377: PPUSH
71378: CALL_OW 257
71382: PUSH
71383: LD_INT 17
71385: EQUAL
71386: IFFALSE 71407
// points := [ 100 , 50 , 75 ] ;
71388: LD_ADDR_VAR 0 9
71392: PUSH
71393: LD_INT 100
71395: PUSH
71396: LD_INT 50
71398: PUSH
71399: LD_INT 75
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: LIST
71406: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71407: LD_VAR 0 6
71411: PPUSH
71412: CALL_OW 257
71416: PUSH
71417: LD_INT 15
71419: EQUAL
71420: IFFALSE 71441
// points := [ 10 , 5 , 3 ] ;
71422: LD_ADDR_VAR 0 9
71426: PUSH
71427: LD_INT 10
71429: PUSH
71430: LD_INT 5
71432: PUSH
71433: LD_INT 3
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: LIST
71440: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71441: LD_VAR 0 6
71445: PPUSH
71446: CALL_OW 257
71450: PUSH
71451: LD_INT 14
71453: EQUAL
71454: IFFALSE 71475
// points := [ 10 , 0 , 0 ] ;
71456: LD_ADDR_VAR 0 9
71460: PUSH
71461: LD_INT 10
71463: PUSH
71464: LD_INT 0
71466: PUSH
71467: LD_INT 0
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: LIST
71474: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71475: LD_VAR 0 6
71479: PPUSH
71480: CALL_OW 257
71484: PUSH
71485: LD_INT 11
71487: EQUAL
71488: IFFALSE 71509
// points := [ 30 , 10 , 5 ] ;
71490: LD_ADDR_VAR 0 9
71494: PUSH
71495: LD_INT 30
71497: PUSH
71498: LD_INT 10
71500: PUSH
71501: LD_INT 5
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: LIST
71508: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71509: LD_VAR 0 1
71513: PPUSH
71514: LD_INT 5
71516: PPUSH
71517: CALL_OW 321
71521: PUSH
71522: LD_INT 2
71524: EQUAL
71525: IFFALSE 71542
// bpoints := bpoints * 1.8 ;
71527: LD_ADDR_VAR 0 10
71531: PUSH
71532: LD_VAR 0 10
71536: PUSH
71537: LD_REAL  1.80000000000000E+0000
71540: MUL
71541: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71542: LD_VAR 0 6
71546: PPUSH
71547: CALL_OW 257
71551: PUSH
71552: LD_INT 1
71554: PUSH
71555: LD_INT 2
71557: PUSH
71558: LD_INT 3
71560: PUSH
71561: LD_INT 4
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: LIST
71568: LIST
71569: IN
71570: PUSH
71571: LD_VAR 0 1
71575: PPUSH
71576: LD_INT 51
71578: PPUSH
71579: CALL_OW 321
71583: PUSH
71584: LD_INT 2
71586: EQUAL
71587: AND
71588: IFFALSE 71605
// bpoints := bpoints * 1.2 ;
71590: LD_ADDR_VAR 0 10
71594: PUSH
71595: LD_VAR 0 10
71599: PUSH
71600: LD_REAL  1.20000000000000E+0000
71603: MUL
71604: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71605: LD_VAR 0 6
71609: PPUSH
71610: CALL_OW 257
71614: PUSH
71615: LD_INT 5
71617: PUSH
71618: LD_INT 7
71620: PUSH
71621: LD_INT 9
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: LIST
71628: IN
71629: PUSH
71630: LD_VAR 0 1
71634: PPUSH
71635: LD_INT 52
71637: PPUSH
71638: CALL_OW 321
71642: PUSH
71643: LD_INT 2
71645: EQUAL
71646: AND
71647: IFFALSE 71664
// bpoints := bpoints * 1.5 ;
71649: LD_ADDR_VAR 0 10
71653: PUSH
71654: LD_VAR 0 10
71658: PUSH
71659: LD_REAL  1.50000000000000E+0000
71662: MUL
71663: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71664: LD_VAR 0 1
71668: PPUSH
71669: LD_INT 66
71671: PPUSH
71672: CALL_OW 321
71676: PUSH
71677: LD_INT 2
71679: EQUAL
71680: IFFALSE 71697
// bpoints := bpoints * 1.1 ;
71682: LD_ADDR_VAR 0 10
71686: PUSH
71687: LD_VAR 0 10
71691: PUSH
71692: LD_REAL  1.10000000000000E+0000
71695: MUL
71696: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71697: LD_ADDR_VAR 0 10
71701: PUSH
71702: LD_VAR 0 10
71706: PUSH
71707: LD_VAR 0 6
71711: PPUSH
71712: LD_INT 1
71714: PPUSH
71715: CALL_OW 259
71719: PUSH
71720: LD_REAL  1.15000000000000E+0000
71723: MUL
71724: MUL
71725: ST_TO_ADDR
// end ; unit_vehicle :
71726: GO 72550
71728: LD_INT 2
71730: DOUBLE
71731: EQUAL
71732: IFTRUE 71736
71734: GO 72538
71736: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71737: LD_VAR 0 6
71741: PPUSH
71742: CALL_OW 264
71746: PUSH
71747: LD_INT 2
71749: PUSH
71750: LD_INT 42
71752: PUSH
71753: LD_INT 24
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: LIST
71760: IN
71761: IFFALSE 71782
// points := [ 25 , 5 , 3 ] ;
71763: LD_ADDR_VAR 0 9
71767: PUSH
71768: LD_INT 25
71770: PUSH
71771: LD_INT 5
71773: PUSH
71774: LD_INT 3
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: LIST
71781: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71782: LD_VAR 0 6
71786: PPUSH
71787: CALL_OW 264
71791: PUSH
71792: LD_INT 4
71794: PUSH
71795: LD_INT 43
71797: PUSH
71798: LD_INT 25
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: LIST
71805: IN
71806: IFFALSE 71827
// points := [ 40 , 15 , 5 ] ;
71808: LD_ADDR_VAR 0 9
71812: PUSH
71813: LD_INT 40
71815: PUSH
71816: LD_INT 15
71818: PUSH
71819: LD_INT 5
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: LIST
71826: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71827: LD_VAR 0 6
71831: PPUSH
71832: CALL_OW 264
71836: PUSH
71837: LD_INT 3
71839: PUSH
71840: LD_INT 23
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: IN
71847: IFFALSE 71868
// points := [ 7 , 25 , 8 ] ;
71849: LD_ADDR_VAR 0 9
71853: PUSH
71854: LD_INT 7
71856: PUSH
71857: LD_INT 25
71859: PUSH
71860: LD_INT 8
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: LIST
71867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71868: LD_VAR 0 6
71872: PPUSH
71873: CALL_OW 264
71877: PUSH
71878: LD_INT 5
71880: PUSH
71881: LD_INT 27
71883: PUSH
71884: LD_INT 44
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: LIST
71891: IN
71892: IFFALSE 71913
// points := [ 14 , 50 , 16 ] ;
71894: LD_ADDR_VAR 0 9
71898: PUSH
71899: LD_INT 14
71901: PUSH
71902: LD_INT 50
71904: PUSH
71905: LD_INT 16
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: LIST
71912: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71913: LD_VAR 0 6
71917: PPUSH
71918: CALL_OW 264
71922: PUSH
71923: LD_INT 6
71925: PUSH
71926: LD_INT 46
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: IN
71933: IFFALSE 71954
// points := [ 32 , 120 , 70 ] ;
71935: LD_ADDR_VAR 0 9
71939: PUSH
71940: LD_INT 32
71942: PUSH
71943: LD_INT 120
71945: PUSH
71946: LD_INT 70
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: LIST
71953: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71954: LD_VAR 0 6
71958: PPUSH
71959: CALL_OW 264
71963: PUSH
71964: LD_INT 7
71966: PUSH
71967: LD_INT 28
71969: PUSH
71970: LD_INT 45
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: LIST
71977: IN
71978: IFFALSE 71999
// points := [ 35 , 20 , 45 ] ;
71980: LD_ADDR_VAR 0 9
71984: PUSH
71985: LD_INT 35
71987: PUSH
71988: LD_INT 20
71990: PUSH
71991: LD_INT 45
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: LIST
71998: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71999: LD_VAR 0 6
72003: PPUSH
72004: CALL_OW 264
72008: PUSH
72009: LD_INT 47
72011: PUSH
72012: EMPTY
72013: LIST
72014: IN
72015: IFFALSE 72036
// points := [ 67 , 45 , 75 ] ;
72017: LD_ADDR_VAR 0 9
72021: PUSH
72022: LD_INT 67
72024: PUSH
72025: LD_INT 45
72027: PUSH
72028: LD_INT 75
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: LIST
72035: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72036: LD_VAR 0 6
72040: PPUSH
72041: CALL_OW 264
72045: PUSH
72046: LD_INT 26
72048: PUSH
72049: EMPTY
72050: LIST
72051: IN
72052: IFFALSE 72073
// points := [ 120 , 30 , 80 ] ;
72054: LD_ADDR_VAR 0 9
72058: PUSH
72059: LD_INT 120
72061: PUSH
72062: LD_INT 30
72064: PUSH
72065: LD_INT 80
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: LIST
72072: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72073: LD_VAR 0 6
72077: PPUSH
72078: CALL_OW 264
72082: PUSH
72083: LD_INT 22
72085: PUSH
72086: EMPTY
72087: LIST
72088: IN
72089: IFFALSE 72110
// points := [ 40 , 1 , 1 ] ;
72091: LD_ADDR_VAR 0 9
72095: PUSH
72096: LD_INT 40
72098: PUSH
72099: LD_INT 1
72101: PUSH
72102: LD_INT 1
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: LIST
72109: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72110: LD_VAR 0 6
72114: PPUSH
72115: CALL_OW 264
72119: PUSH
72120: LD_INT 29
72122: PUSH
72123: EMPTY
72124: LIST
72125: IN
72126: IFFALSE 72147
// points := [ 70 , 200 , 400 ] ;
72128: LD_ADDR_VAR 0 9
72132: PUSH
72133: LD_INT 70
72135: PUSH
72136: LD_INT 200
72138: PUSH
72139: LD_INT 400
72141: PUSH
72142: EMPTY
72143: LIST
72144: LIST
72145: LIST
72146: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72147: LD_VAR 0 6
72151: PPUSH
72152: CALL_OW 264
72156: PUSH
72157: LD_INT 14
72159: PUSH
72160: LD_INT 53
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: IN
72167: IFFALSE 72188
// points := [ 40 , 10 , 20 ] ;
72169: LD_ADDR_VAR 0 9
72173: PUSH
72174: LD_INT 40
72176: PUSH
72177: LD_INT 10
72179: PUSH
72180: LD_INT 20
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: LIST
72187: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72188: LD_VAR 0 6
72192: PPUSH
72193: CALL_OW 264
72197: PUSH
72198: LD_INT 9
72200: PUSH
72201: EMPTY
72202: LIST
72203: IN
72204: IFFALSE 72225
// points := [ 5 , 70 , 20 ] ;
72206: LD_ADDR_VAR 0 9
72210: PUSH
72211: LD_INT 5
72213: PUSH
72214: LD_INT 70
72216: PUSH
72217: LD_INT 20
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72225: LD_VAR 0 6
72229: PPUSH
72230: CALL_OW 264
72234: PUSH
72235: LD_INT 10
72237: PUSH
72238: EMPTY
72239: LIST
72240: IN
72241: IFFALSE 72262
// points := [ 35 , 110 , 70 ] ;
72243: LD_ADDR_VAR 0 9
72247: PUSH
72248: LD_INT 35
72250: PUSH
72251: LD_INT 110
72253: PUSH
72254: LD_INT 70
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: LIST
72261: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72262: LD_VAR 0 6
72266: PPUSH
72267: CALL_OW 265
72271: PUSH
72272: LD_INT 25
72274: EQUAL
72275: IFFALSE 72296
// points := [ 80 , 65 , 100 ] ;
72277: LD_ADDR_VAR 0 9
72281: PUSH
72282: LD_INT 80
72284: PUSH
72285: LD_INT 65
72287: PUSH
72288: LD_INT 100
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: LIST
72295: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72296: LD_VAR 0 6
72300: PPUSH
72301: CALL_OW 263
72305: PUSH
72306: LD_INT 1
72308: EQUAL
72309: IFFALSE 72344
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72311: LD_ADDR_VAR 0 10
72315: PUSH
72316: LD_VAR 0 10
72320: PUSH
72321: LD_VAR 0 6
72325: PPUSH
72326: CALL_OW 311
72330: PPUSH
72331: LD_INT 3
72333: PPUSH
72334: CALL_OW 259
72338: PUSH
72339: LD_INT 4
72341: MUL
72342: MUL
72343: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72344: LD_VAR 0 6
72348: PPUSH
72349: CALL_OW 263
72353: PUSH
72354: LD_INT 2
72356: EQUAL
72357: IFFALSE 72408
// begin j := IsControledBy ( i ) ;
72359: LD_ADDR_VAR 0 7
72363: PUSH
72364: LD_VAR 0 6
72368: PPUSH
72369: CALL_OW 312
72373: ST_TO_ADDR
// if j then
72374: LD_VAR 0 7
72378: IFFALSE 72408
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72380: LD_ADDR_VAR 0 10
72384: PUSH
72385: LD_VAR 0 10
72389: PUSH
72390: LD_VAR 0 7
72394: PPUSH
72395: LD_INT 3
72397: PPUSH
72398: CALL_OW 259
72402: PUSH
72403: LD_INT 3
72405: MUL
72406: MUL
72407: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72408: LD_VAR 0 6
72412: PPUSH
72413: CALL_OW 264
72417: PUSH
72418: LD_INT 5
72420: PUSH
72421: LD_INT 6
72423: PUSH
72424: LD_INT 46
72426: PUSH
72427: LD_INT 44
72429: PUSH
72430: LD_INT 47
72432: PUSH
72433: LD_INT 45
72435: PUSH
72436: LD_INT 28
72438: PUSH
72439: LD_INT 7
72441: PUSH
72442: LD_INT 27
72444: PUSH
72445: LD_INT 29
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: IN
72460: PUSH
72461: LD_VAR 0 1
72465: PPUSH
72466: LD_INT 52
72468: PPUSH
72469: CALL_OW 321
72473: PUSH
72474: LD_INT 2
72476: EQUAL
72477: AND
72478: IFFALSE 72495
// bpoints := bpoints * 1.2 ;
72480: LD_ADDR_VAR 0 10
72484: PUSH
72485: LD_VAR 0 10
72489: PUSH
72490: LD_REAL  1.20000000000000E+0000
72493: MUL
72494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72495: LD_VAR 0 6
72499: PPUSH
72500: CALL_OW 264
72504: PUSH
72505: LD_INT 6
72507: PUSH
72508: LD_INT 46
72510: PUSH
72511: LD_INT 47
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: LIST
72518: IN
72519: IFFALSE 72536
// bpoints := bpoints * 1.2 ;
72521: LD_ADDR_VAR 0 10
72525: PUSH
72526: LD_VAR 0 10
72530: PUSH
72531: LD_REAL  1.20000000000000E+0000
72534: MUL
72535: ST_TO_ADDR
// end ; unit_building :
72536: GO 72550
72538: LD_INT 3
72540: DOUBLE
72541: EQUAL
72542: IFTRUE 72546
72544: GO 72549
72546: POP
// ; end ;
72547: GO 72550
72549: POP
// for j = 1 to 3 do
72550: LD_ADDR_VAR 0 7
72554: PUSH
72555: DOUBLE
72556: LD_INT 1
72558: DEC
72559: ST_TO_ADDR
72560: LD_INT 3
72562: PUSH
72563: FOR_TO
72564: IFFALSE 72617
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72566: LD_ADDR_VAR 0 5
72570: PUSH
72571: LD_VAR 0 5
72575: PPUSH
72576: LD_VAR 0 7
72580: PPUSH
72581: LD_VAR 0 5
72585: PUSH
72586: LD_VAR 0 7
72590: ARRAY
72591: PUSH
72592: LD_VAR 0 9
72596: PUSH
72597: LD_VAR 0 7
72601: ARRAY
72602: PUSH
72603: LD_VAR 0 10
72607: MUL
72608: PLUS
72609: PPUSH
72610: CALL_OW 1
72614: ST_TO_ADDR
72615: GO 72563
72617: POP
72618: POP
// end ;
72619: GO 71102
72621: POP
72622: POP
// result := Replace ( result , 4 , tmp ) ;
72623: LD_ADDR_VAR 0 5
72627: PUSH
72628: LD_VAR 0 5
72632: PPUSH
72633: LD_INT 4
72635: PPUSH
72636: LD_VAR 0 8
72640: PPUSH
72641: CALL_OW 1
72645: ST_TO_ADDR
// end ;
72646: LD_VAR 0 5
72650: RET
// export function DangerAtRange ( unit , range ) ; begin
72651: LD_INT 0
72653: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72654: LD_ADDR_VAR 0 3
72658: PUSH
72659: LD_VAR 0 1
72663: PPUSH
72664: CALL_OW 255
72668: PPUSH
72669: LD_VAR 0 1
72673: PPUSH
72674: CALL_OW 250
72678: PPUSH
72679: LD_VAR 0 1
72683: PPUSH
72684: CALL_OW 251
72688: PPUSH
72689: LD_VAR 0 2
72693: PPUSH
72694: CALL 70954 0 4
72698: ST_TO_ADDR
// end ;
72699: LD_VAR 0 3
72703: RET
// export function DangerInArea ( side , area ) ; begin
72704: LD_INT 0
72706: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72707: LD_ADDR_VAR 0 3
72711: PUSH
72712: LD_VAR 0 2
72716: PPUSH
72717: LD_INT 81
72719: PUSH
72720: LD_VAR 0 1
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PPUSH
72729: CALL_OW 70
72733: ST_TO_ADDR
// end ;
72734: LD_VAR 0 3
72738: RET
// export function IsExtension ( b ) ; begin
72739: LD_INT 0
72741: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72742: LD_ADDR_VAR 0 2
72746: PUSH
72747: LD_VAR 0 1
72751: PUSH
72752: LD_INT 23
72754: PUSH
72755: LD_INT 20
72757: PUSH
72758: LD_INT 22
72760: PUSH
72761: LD_INT 17
72763: PUSH
72764: LD_INT 24
72766: PUSH
72767: LD_INT 21
72769: PUSH
72770: LD_INT 19
72772: PUSH
72773: LD_INT 16
72775: PUSH
72776: LD_INT 25
72778: PUSH
72779: LD_INT 18
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: IN
72794: ST_TO_ADDR
// end ;
72795: LD_VAR 0 2
72799: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72800: LD_INT 0
72802: PPUSH
72803: PPUSH
72804: PPUSH
// result := [ ] ;
72805: LD_ADDR_VAR 0 3
72809: PUSH
72810: EMPTY
72811: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72812: LD_ADDR_VAR 0 4
72816: PUSH
72817: LD_VAR 0 2
72821: PPUSH
72822: LD_INT 21
72824: PUSH
72825: LD_INT 3
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PPUSH
72832: CALL_OW 70
72836: ST_TO_ADDR
// if not tmp then
72837: LD_VAR 0 4
72841: NOT
72842: IFFALSE 72846
// exit ;
72844: GO 72904
// for i in tmp do
72846: LD_ADDR_VAR 0 5
72850: PUSH
72851: LD_VAR 0 4
72855: PUSH
72856: FOR_IN
72857: IFFALSE 72892
// if GetBase ( i ) <> base then
72859: LD_VAR 0 5
72863: PPUSH
72864: CALL_OW 274
72868: PUSH
72869: LD_VAR 0 1
72873: NONEQUAL
72874: IFFALSE 72890
// ComLinkToBase ( base , i ) ;
72876: LD_VAR 0 1
72880: PPUSH
72881: LD_VAR 0 5
72885: PPUSH
72886: CALL_OW 169
72890: GO 72856
72892: POP
72893: POP
// result := tmp ;
72894: LD_ADDR_VAR 0 3
72898: PUSH
72899: LD_VAR 0 4
72903: ST_TO_ADDR
// end ;
72904: LD_VAR 0 3
72908: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72909: LD_INT 0
72911: PPUSH
72912: PPUSH
// if BuildingStatus ( b ) = bs_build then
72913: LD_VAR 0 2
72917: PPUSH
72918: CALL_OW 461
72922: PUSH
72923: LD_INT 1
72925: EQUAL
72926: IFFALSE 72986
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72928: LD_VAR 0 1
72932: PPUSH
72933: LD_STRING h
72935: PUSH
72936: LD_VAR 0 2
72940: PPUSH
72941: CALL_OW 250
72945: PUSH
72946: LD_VAR 0 2
72950: PPUSH
72951: CALL_OW 251
72955: PUSH
72956: LD_VAR 0 2
72960: PUSH
72961: LD_INT 0
72963: PUSH
72964: LD_INT 0
72966: PUSH
72967: LD_INT 0
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: LIST
72976: LIST
72977: LIST
72978: PUSH
72979: EMPTY
72980: LIST
72981: PPUSH
72982: CALL_OW 446
// end ;
72986: LD_VAR 0 3
72990: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72991: LD_INT 0
72993: PPUSH
72994: PPUSH
72995: PPUSH
72996: PPUSH
72997: PPUSH
72998: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72999: LD_VAR 0 1
73003: NOT
73004: PUSH
73005: LD_VAR 0 1
73009: PPUSH
73010: CALL_OW 263
73014: PUSH
73015: LD_INT 2
73017: EQUAL
73018: NOT
73019: OR
73020: IFFALSE 73024
// exit ;
73022: GO 73340
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73024: LD_ADDR_VAR 0 6
73028: PUSH
73029: LD_INT 22
73031: PUSH
73032: LD_VAR 0 1
73036: PPUSH
73037: CALL_OW 255
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 2
73048: PUSH
73049: LD_INT 30
73051: PUSH
73052: LD_INT 36
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 34
73061: PUSH
73062: LD_INT 31
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: LIST
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PPUSH
73078: CALL_OW 69
73082: ST_TO_ADDR
// if not tmp then
73083: LD_VAR 0 6
73087: NOT
73088: IFFALSE 73092
// exit ;
73090: GO 73340
// result := [ ] ;
73092: LD_ADDR_VAR 0 2
73096: PUSH
73097: EMPTY
73098: ST_TO_ADDR
// for i in tmp do
73099: LD_ADDR_VAR 0 3
73103: PUSH
73104: LD_VAR 0 6
73108: PUSH
73109: FOR_IN
73110: IFFALSE 73181
// begin t := UnitsInside ( i ) ;
73112: LD_ADDR_VAR 0 4
73116: PUSH
73117: LD_VAR 0 3
73121: PPUSH
73122: CALL_OW 313
73126: ST_TO_ADDR
// if t then
73127: LD_VAR 0 4
73131: IFFALSE 73179
// for j in t do
73133: LD_ADDR_VAR 0 7
73137: PUSH
73138: LD_VAR 0 4
73142: PUSH
73143: FOR_IN
73144: IFFALSE 73177
// result := Insert ( result , result + 1 , j ) ;
73146: LD_ADDR_VAR 0 2
73150: PUSH
73151: LD_VAR 0 2
73155: PPUSH
73156: LD_VAR 0 2
73160: PUSH
73161: LD_INT 1
73163: PLUS
73164: PPUSH
73165: LD_VAR 0 7
73169: PPUSH
73170: CALL_OW 2
73174: ST_TO_ADDR
73175: GO 73143
73177: POP
73178: POP
// end ;
73179: GO 73109
73181: POP
73182: POP
// if not result then
73183: LD_VAR 0 2
73187: NOT
73188: IFFALSE 73192
// exit ;
73190: GO 73340
// mech := result [ 1 ] ;
73192: LD_ADDR_VAR 0 5
73196: PUSH
73197: LD_VAR 0 2
73201: PUSH
73202: LD_INT 1
73204: ARRAY
73205: ST_TO_ADDR
// if result > 1 then
73206: LD_VAR 0 2
73210: PUSH
73211: LD_INT 1
73213: GREATER
73214: IFFALSE 73326
// for i = 2 to result do
73216: LD_ADDR_VAR 0 3
73220: PUSH
73221: DOUBLE
73222: LD_INT 2
73224: DEC
73225: ST_TO_ADDR
73226: LD_VAR 0 2
73230: PUSH
73231: FOR_TO
73232: IFFALSE 73324
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73234: LD_ADDR_VAR 0 4
73238: PUSH
73239: LD_VAR 0 2
73243: PUSH
73244: LD_VAR 0 3
73248: ARRAY
73249: PPUSH
73250: LD_INT 3
73252: PPUSH
73253: CALL_OW 259
73257: PUSH
73258: LD_VAR 0 2
73262: PUSH
73263: LD_VAR 0 3
73267: ARRAY
73268: PPUSH
73269: CALL_OW 432
73273: MINUS
73274: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73275: LD_VAR 0 4
73279: PUSH
73280: LD_VAR 0 5
73284: PPUSH
73285: LD_INT 3
73287: PPUSH
73288: CALL_OW 259
73292: PUSH
73293: LD_VAR 0 5
73297: PPUSH
73298: CALL_OW 432
73302: MINUS
73303: GREATEREQUAL
73304: IFFALSE 73322
// mech := result [ i ] ;
73306: LD_ADDR_VAR 0 5
73310: PUSH
73311: LD_VAR 0 2
73315: PUSH
73316: LD_VAR 0 3
73320: ARRAY
73321: ST_TO_ADDR
// end ;
73322: GO 73231
73324: POP
73325: POP
// ComLinkTo ( vehicle , mech ) ;
73326: LD_VAR 0 1
73330: PPUSH
73331: LD_VAR 0 5
73335: PPUSH
73336: CALL_OW 135
// end ;
73340: LD_VAR 0 2
73344: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73345: LD_INT 0
73347: PPUSH
73348: PPUSH
73349: PPUSH
73350: PPUSH
73351: PPUSH
73352: PPUSH
73353: PPUSH
73354: PPUSH
73355: PPUSH
73356: PPUSH
73357: PPUSH
73358: PPUSH
73359: PPUSH
// result := [ ] ;
73360: LD_ADDR_VAR 0 7
73364: PUSH
73365: EMPTY
73366: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73367: LD_VAR 0 1
73371: PPUSH
73372: CALL_OW 266
73376: PUSH
73377: LD_INT 0
73379: PUSH
73380: LD_INT 1
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: IN
73387: NOT
73388: IFFALSE 73392
// exit ;
73390: GO 75023
// if name then
73392: LD_VAR 0 3
73396: IFFALSE 73412
// SetBName ( base_dep , name ) ;
73398: LD_VAR 0 1
73402: PPUSH
73403: LD_VAR 0 3
73407: PPUSH
73408: CALL_OW 500
// base := GetBase ( base_dep ) ;
73412: LD_ADDR_VAR 0 15
73416: PUSH
73417: LD_VAR 0 1
73421: PPUSH
73422: CALL_OW 274
73426: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73427: LD_ADDR_VAR 0 16
73431: PUSH
73432: LD_VAR 0 1
73436: PPUSH
73437: CALL_OW 255
73441: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73442: LD_ADDR_VAR 0 17
73446: PUSH
73447: LD_VAR 0 1
73451: PPUSH
73452: CALL_OW 248
73456: ST_TO_ADDR
// if sources then
73457: LD_VAR 0 5
73461: IFFALSE 73508
// for i = 1 to 3 do
73463: LD_ADDR_VAR 0 8
73467: PUSH
73468: DOUBLE
73469: LD_INT 1
73471: DEC
73472: ST_TO_ADDR
73473: LD_INT 3
73475: PUSH
73476: FOR_TO
73477: IFFALSE 73506
// AddResourceType ( base , i , sources [ i ] ) ;
73479: LD_VAR 0 15
73483: PPUSH
73484: LD_VAR 0 8
73488: PPUSH
73489: LD_VAR 0 5
73493: PUSH
73494: LD_VAR 0 8
73498: ARRAY
73499: PPUSH
73500: CALL_OW 276
73504: GO 73476
73506: POP
73507: POP
// buildings := GetBaseBuildings ( base , area ) ;
73508: LD_ADDR_VAR 0 18
73512: PUSH
73513: LD_VAR 0 15
73517: PPUSH
73518: LD_VAR 0 2
73522: PPUSH
73523: CALL 72800 0 2
73527: ST_TO_ADDR
// InitHc ;
73528: CALL_OW 19
// InitUc ;
73532: CALL_OW 18
// uc_side := side ;
73536: LD_ADDR_OWVAR 20
73540: PUSH
73541: LD_VAR 0 16
73545: ST_TO_ADDR
// uc_nation := nation ;
73546: LD_ADDR_OWVAR 21
73550: PUSH
73551: LD_VAR 0 17
73555: ST_TO_ADDR
// if buildings then
73556: LD_VAR 0 18
73560: IFFALSE 74882
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73562: LD_ADDR_VAR 0 19
73566: PUSH
73567: LD_VAR 0 18
73571: PPUSH
73572: LD_INT 2
73574: PUSH
73575: LD_INT 30
73577: PUSH
73578: LD_INT 29
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 30
73587: PUSH
73588: LD_INT 30
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: EMPTY
73596: LIST
73597: LIST
73598: LIST
73599: PPUSH
73600: CALL_OW 72
73604: ST_TO_ADDR
// if tmp then
73605: LD_VAR 0 19
73609: IFFALSE 73657
// for i in tmp do
73611: LD_ADDR_VAR 0 8
73615: PUSH
73616: LD_VAR 0 19
73620: PUSH
73621: FOR_IN
73622: IFFALSE 73655
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73624: LD_VAR 0 8
73628: PPUSH
73629: CALL_OW 250
73633: PPUSH
73634: LD_VAR 0 8
73638: PPUSH
73639: CALL_OW 251
73643: PPUSH
73644: LD_VAR 0 16
73648: PPUSH
73649: CALL_OW 441
73653: GO 73621
73655: POP
73656: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73657: LD_VAR 0 18
73661: PPUSH
73662: LD_INT 2
73664: PUSH
73665: LD_INT 30
73667: PUSH
73668: LD_INT 32
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: LD_INT 30
73677: PUSH
73678: LD_INT 33
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: LIST
73689: PPUSH
73690: CALL_OW 72
73694: IFFALSE 73782
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73696: LD_ADDR_VAR 0 8
73700: PUSH
73701: LD_VAR 0 18
73705: PPUSH
73706: LD_INT 2
73708: PUSH
73709: LD_INT 30
73711: PUSH
73712: LD_INT 32
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: PUSH
73719: LD_INT 30
73721: PUSH
73722: LD_INT 33
73724: PUSH
73725: EMPTY
73726: LIST
73727: LIST
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: LIST
73733: PPUSH
73734: CALL_OW 72
73738: PUSH
73739: FOR_IN
73740: IFFALSE 73780
// begin if not GetBWeapon ( i ) then
73742: LD_VAR 0 8
73746: PPUSH
73747: CALL_OW 269
73751: NOT
73752: IFFALSE 73778
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73754: LD_VAR 0 8
73758: PPUSH
73759: LD_VAR 0 8
73763: PPUSH
73764: LD_VAR 0 2
73768: PPUSH
73769: CALL 75028 0 2
73773: PPUSH
73774: CALL_OW 431
// end ;
73778: GO 73739
73780: POP
73781: POP
// end ; for i = 1 to personel do
73782: LD_ADDR_VAR 0 8
73786: PUSH
73787: DOUBLE
73788: LD_INT 1
73790: DEC
73791: ST_TO_ADDR
73792: LD_VAR 0 6
73796: PUSH
73797: FOR_TO
73798: IFFALSE 74862
// begin if i > 4 then
73800: LD_VAR 0 8
73804: PUSH
73805: LD_INT 4
73807: GREATER
73808: IFFALSE 73812
// break ;
73810: GO 74862
// case i of 1 :
73812: LD_VAR 0 8
73816: PUSH
73817: LD_INT 1
73819: DOUBLE
73820: EQUAL
73821: IFTRUE 73825
73823: GO 73905
73825: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73826: LD_ADDR_VAR 0 12
73830: PUSH
73831: LD_VAR 0 18
73835: PPUSH
73836: LD_INT 22
73838: PUSH
73839: LD_VAR 0 16
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: PUSH
73848: LD_INT 58
73850: PUSH
73851: EMPTY
73852: LIST
73853: PUSH
73854: LD_INT 2
73856: PUSH
73857: LD_INT 30
73859: PUSH
73860: LD_INT 32
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 30
73869: PUSH
73870: LD_INT 4
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 30
73879: PUSH
73880: LD_INT 5
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: LIST
73897: PPUSH
73898: CALL_OW 72
73902: ST_TO_ADDR
73903: GO 74127
73905: LD_INT 2
73907: DOUBLE
73908: EQUAL
73909: IFTRUE 73913
73911: GO 73975
73913: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73914: LD_ADDR_VAR 0 12
73918: PUSH
73919: LD_VAR 0 18
73923: PPUSH
73924: LD_INT 22
73926: PUSH
73927: LD_VAR 0 16
73931: PUSH
73932: EMPTY
73933: LIST
73934: LIST
73935: PUSH
73936: LD_INT 2
73938: PUSH
73939: LD_INT 30
73941: PUSH
73942: LD_INT 0
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 30
73951: PUSH
73952: LD_INT 1
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: LIST
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PPUSH
73968: CALL_OW 72
73972: ST_TO_ADDR
73973: GO 74127
73975: LD_INT 3
73977: DOUBLE
73978: EQUAL
73979: IFTRUE 73983
73981: GO 74045
73983: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73984: LD_ADDR_VAR 0 12
73988: PUSH
73989: LD_VAR 0 18
73993: PPUSH
73994: LD_INT 22
73996: PUSH
73997: LD_VAR 0 16
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 2
74008: PUSH
74009: LD_INT 30
74011: PUSH
74012: LD_INT 2
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 30
74021: PUSH
74022: LD_INT 3
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: PPUSH
74038: CALL_OW 72
74042: ST_TO_ADDR
74043: GO 74127
74045: LD_INT 4
74047: DOUBLE
74048: EQUAL
74049: IFTRUE 74053
74051: GO 74126
74053: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74054: LD_ADDR_VAR 0 12
74058: PUSH
74059: LD_VAR 0 18
74063: PPUSH
74064: LD_INT 22
74066: PUSH
74067: LD_VAR 0 16
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: LD_INT 30
74081: PUSH
74082: LD_INT 6
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 30
74091: PUSH
74092: LD_INT 7
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 30
74101: PUSH
74102: LD_INT 8
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: LIST
74113: LIST
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PPUSH
74119: CALL_OW 72
74123: ST_TO_ADDR
74124: GO 74127
74126: POP
// if i = 1 then
74127: LD_VAR 0 8
74131: PUSH
74132: LD_INT 1
74134: EQUAL
74135: IFFALSE 74246
// begin tmp := [ ] ;
74137: LD_ADDR_VAR 0 19
74141: PUSH
74142: EMPTY
74143: ST_TO_ADDR
// for j in f do
74144: LD_ADDR_VAR 0 9
74148: PUSH
74149: LD_VAR 0 12
74153: PUSH
74154: FOR_IN
74155: IFFALSE 74228
// if GetBType ( j ) = b_bunker then
74157: LD_VAR 0 9
74161: PPUSH
74162: CALL_OW 266
74166: PUSH
74167: LD_INT 32
74169: EQUAL
74170: IFFALSE 74197
// tmp := Insert ( tmp , 1 , j ) else
74172: LD_ADDR_VAR 0 19
74176: PUSH
74177: LD_VAR 0 19
74181: PPUSH
74182: LD_INT 1
74184: PPUSH
74185: LD_VAR 0 9
74189: PPUSH
74190: CALL_OW 2
74194: ST_TO_ADDR
74195: GO 74226
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74197: LD_ADDR_VAR 0 19
74201: PUSH
74202: LD_VAR 0 19
74206: PPUSH
74207: LD_VAR 0 19
74211: PUSH
74212: LD_INT 1
74214: PLUS
74215: PPUSH
74216: LD_VAR 0 9
74220: PPUSH
74221: CALL_OW 2
74225: ST_TO_ADDR
74226: GO 74154
74228: POP
74229: POP
// if tmp then
74230: LD_VAR 0 19
74234: IFFALSE 74246
// f := tmp ;
74236: LD_ADDR_VAR 0 12
74240: PUSH
74241: LD_VAR 0 19
74245: ST_TO_ADDR
// end ; x := personel [ i ] ;
74246: LD_ADDR_VAR 0 13
74250: PUSH
74251: LD_VAR 0 6
74255: PUSH
74256: LD_VAR 0 8
74260: ARRAY
74261: ST_TO_ADDR
// if x = - 1 then
74262: LD_VAR 0 13
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: EQUAL
74271: IFFALSE 74480
// begin for j in f do
74273: LD_ADDR_VAR 0 9
74277: PUSH
74278: LD_VAR 0 12
74282: PUSH
74283: FOR_IN
74284: IFFALSE 74476
// repeat InitHc ;
74286: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74290: LD_VAR 0 9
74294: PPUSH
74295: CALL_OW 266
74299: PUSH
74300: LD_INT 5
74302: EQUAL
74303: IFFALSE 74373
// begin if UnitsInside ( j ) < 3 then
74305: LD_VAR 0 9
74309: PPUSH
74310: CALL_OW 313
74314: PUSH
74315: LD_INT 3
74317: LESS
74318: IFFALSE 74354
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74320: LD_INT 0
74322: PPUSH
74323: LD_INT 5
74325: PUSH
74326: LD_INT 8
74328: PUSH
74329: LD_INT 9
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: LIST
74336: PUSH
74337: LD_VAR 0 17
74341: ARRAY
74342: PPUSH
74343: LD_VAR 0 4
74347: PPUSH
74348: CALL_OW 380
74352: GO 74371
// PrepareHuman ( false , i , skill ) ;
74354: LD_INT 0
74356: PPUSH
74357: LD_VAR 0 8
74361: PPUSH
74362: LD_VAR 0 4
74366: PPUSH
74367: CALL_OW 380
// end else
74371: GO 74390
// PrepareHuman ( false , i , skill ) ;
74373: LD_INT 0
74375: PPUSH
74376: LD_VAR 0 8
74380: PPUSH
74381: LD_VAR 0 4
74385: PPUSH
74386: CALL_OW 380
// un := CreateHuman ;
74390: LD_ADDR_VAR 0 14
74394: PUSH
74395: CALL_OW 44
74399: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74400: LD_ADDR_VAR 0 7
74404: PUSH
74405: LD_VAR 0 7
74409: PPUSH
74410: LD_INT 1
74412: PPUSH
74413: LD_VAR 0 14
74417: PPUSH
74418: CALL_OW 2
74422: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74423: LD_VAR 0 14
74427: PPUSH
74428: LD_VAR 0 9
74432: PPUSH
74433: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74437: LD_VAR 0 9
74441: PPUSH
74442: CALL_OW 313
74446: PUSH
74447: LD_INT 6
74449: EQUAL
74450: PUSH
74451: LD_VAR 0 9
74455: PPUSH
74456: CALL_OW 266
74460: PUSH
74461: LD_INT 32
74463: PUSH
74464: LD_INT 31
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: IN
74471: OR
74472: IFFALSE 74286
74474: GO 74283
74476: POP
74477: POP
// end else
74478: GO 74860
// for j = 1 to x do
74480: LD_ADDR_VAR 0 9
74484: PUSH
74485: DOUBLE
74486: LD_INT 1
74488: DEC
74489: ST_TO_ADDR
74490: LD_VAR 0 13
74494: PUSH
74495: FOR_TO
74496: IFFALSE 74858
// begin InitHc ;
74498: CALL_OW 19
// if not f then
74502: LD_VAR 0 12
74506: NOT
74507: IFFALSE 74596
// begin PrepareHuman ( false , i , skill ) ;
74509: LD_INT 0
74511: PPUSH
74512: LD_VAR 0 8
74516: PPUSH
74517: LD_VAR 0 4
74521: PPUSH
74522: CALL_OW 380
// un := CreateHuman ;
74526: LD_ADDR_VAR 0 14
74530: PUSH
74531: CALL_OW 44
74535: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74536: LD_ADDR_VAR 0 7
74540: PUSH
74541: LD_VAR 0 7
74545: PPUSH
74546: LD_INT 1
74548: PPUSH
74549: LD_VAR 0 14
74553: PPUSH
74554: CALL_OW 2
74558: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74559: LD_VAR 0 14
74563: PPUSH
74564: LD_VAR 0 1
74568: PPUSH
74569: CALL_OW 250
74573: PPUSH
74574: LD_VAR 0 1
74578: PPUSH
74579: CALL_OW 251
74583: PPUSH
74584: LD_INT 10
74586: PPUSH
74587: LD_INT 0
74589: PPUSH
74590: CALL_OW 50
// continue ;
74594: GO 74495
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74596: LD_VAR 0 12
74600: PUSH
74601: LD_INT 1
74603: ARRAY
74604: PPUSH
74605: CALL_OW 313
74609: PUSH
74610: LD_VAR 0 12
74614: PUSH
74615: LD_INT 1
74617: ARRAY
74618: PPUSH
74619: CALL_OW 266
74623: PUSH
74624: LD_INT 32
74626: PUSH
74627: LD_INT 31
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: IN
74634: AND
74635: PUSH
74636: LD_VAR 0 12
74640: PUSH
74641: LD_INT 1
74643: ARRAY
74644: PPUSH
74645: CALL_OW 313
74649: PUSH
74650: LD_INT 6
74652: EQUAL
74653: OR
74654: IFFALSE 74674
// f := Delete ( f , 1 ) ;
74656: LD_ADDR_VAR 0 12
74660: PUSH
74661: LD_VAR 0 12
74665: PPUSH
74666: LD_INT 1
74668: PPUSH
74669: CALL_OW 3
74673: ST_TO_ADDR
// if not f then
74674: LD_VAR 0 12
74678: NOT
74679: IFFALSE 74697
// begin x := x + 2 ;
74681: LD_ADDR_VAR 0 13
74685: PUSH
74686: LD_VAR 0 13
74690: PUSH
74691: LD_INT 2
74693: PLUS
74694: ST_TO_ADDR
// continue ;
74695: GO 74495
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74697: LD_VAR 0 12
74701: PUSH
74702: LD_INT 1
74704: ARRAY
74705: PPUSH
74706: CALL_OW 266
74710: PUSH
74711: LD_INT 5
74713: EQUAL
74714: IFFALSE 74788
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74716: LD_VAR 0 12
74720: PUSH
74721: LD_INT 1
74723: ARRAY
74724: PPUSH
74725: CALL_OW 313
74729: PUSH
74730: LD_INT 3
74732: LESS
74733: IFFALSE 74769
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74735: LD_INT 0
74737: PPUSH
74738: LD_INT 5
74740: PUSH
74741: LD_INT 8
74743: PUSH
74744: LD_INT 9
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: LIST
74751: PUSH
74752: LD_VAR 0 17
74756: ARRAY
74757: PPUSH
74758: LD_VAR 0 4
74762: PPUSH
74763: CALL_OW 380
74767: GO 74786
// PrepareHuman ( false , i , skill ) ;
74769: LD_INT 0
74771: PPUSH
74772: LD_VAR 0 8
74776: PPUSH
74777: LD_VAR 0 4
74781: PPUSH
74782: CALL_OW 380
// end else
74786: GO 74805
// PrepareHuman ( false , i , skill ) ;
74788: LD_INT 0
74790: PPUSH
74791: LD_VAR 0 8
74795: PPUSH
74796: LD_VAR 0 4
74800: PPUSH
74801: CALL_OW 380
// un := CreateHuman ;
74805: LD_ADDR_VAR 0 14
74809: PUSH
74810: CALL_OW 44
74814: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74815: LD_ADDR_VAR 0 7
74819: PUSH
74820: LD_VAR 0 7
74824: PPUSH
74825: LD_INT 1
74827: PPUSH
74828: LD_VAR 0 14
74832: PPUSH
74833: CALL_OW 2
74837: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74838: LD_VAR 0 14
74842: PPUSH
74843: LD_VAR 0 12
74847: PUSH
74848: LD_INT 1
74850: ARRAY
74851: PPUSH
74852: CALL_OW 52
// end ;
74856: GO 74495
74858: POP
74859: POP
// end ;
74860: GO 73797
74862: POP
74863: POP
// result := result ^ buildings ;
74864: LD_ADDR_VAR 0 7
74868: PUSH
74869: LD_VAR 0 7
74873: PUSH
74874: LD_VAR 0 18
74878: ADD
74879: ST_TO_ADDR
// end else
74880: GO 75023
// begin for i = 1 to personel do
74882: LD_ADDR_VAR 0 8
74886: PUSH
74887: DOUBLE
74888: LD_INT 1
74890: DEC
74891: ST_TO_ADDR
74892: LD_VAR 0 6
74896: PUSH
74897: FOR_TO
74898: IFFALSE 75021
// begin if i > 4 then
74900: LD_VAR 0 8
74904: PUSH
74905: LD_INT 4
74907: GREATER
74908: IFFALSE 74912
// break ;
74910: GO 75021
// x := personel [ i ] ;
74912: LD_ADDR_VAR 0 13
74916: PUSH
74917: LD_VAR 0 6
74921: PUSH
74922: LD_VAR 0 8
74926: ARRAY
74927: ST_TO_ADDR
// if x = - 1 then
74928: LD_VAR 0 13
74932: PUSH
74933: LD_INT 1
74935: NEG
74936: EQUAL
74937: IFFALSE 74941
// continue ;
74939: GO 74897
// PrepareHuman ( false , i , skill ) ;
74941: LD_INT 0
74943: PPUSH
74944: LD_VAR 0 8
74948: PPUSH
74949: LD_VAR 0 4
74953: PPUSH
74954: CALL_OW 380
// un := CreateHuman ;
74958: LD_ADDR_VAR 0 14
74962: PUSH
74963: CALL_OW 44
74967: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74968: LD_VAR 0 14
74972: PPUSH
74973: LD_VAR 0 1
74977: PPUSH
74978: CALL_OW 250
74982: PPUSH
74983: LD_VAR 0 1
74987: PPUSH
74988: CALL_OW 251
74992: PPUSH
74993: LD_INT 10
74995: PPUSH
74996: LD_INT 0
74998: PPUSH
74999: CALL_OW 50
// result := result ^ un ;
75003: LD_ADDR_VAR 0 7
75007: PUSH
75008: LD_VAR 0 7
75012: PUSH
75013: LD_VAR 0 14
75017: ADD
75018: ST_TO_ADDR
// end ;
75019: GO 74897
75021: POP
75022: POP
// end ; end ;
75023: LD_VAR 0 7
75027: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75028: LD_INT 0
75030: PPUSH
75031: PPUSH
75032: PPUSH
75033: PPUSH
75034: PPUSH
75035: PPUSH
75036: PPUSH
75037: PPUSH
75038: PPUSH
75039: PPUSH
75040: PPUSH
75041: PPUSH
75042: PPUSH
75043: PPUSH
75044: PPUSH
75045: PPUSH
// result := false ;
75046: LD_ADDR_VAR 0 3
75050: PUSH
75051: LD_INT 0
75053: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75054: LD_VAR 0 1
75058: NOT
75059: PUSH
75060: LD_VAR 0 1
75064: PPUSH
75065: CALL_OW 266
75069: PUSH
75070: LD_INT 32
75072: PUSH
75073: LD_INT 33
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: IN
75080: NOT
75081: OR
75082: IFFALSE 75086
// exit ;
75084: GO 76222
// nat := GetNation ( tower ) ;
75086: LD_ADDR_VAR 0 12
75090: PUSH
75091: LD_VAR 0 1
75095: PPUSH
75096: CALL_OW 248
75100: ST_TO_ADDR
// side := GetSide ( tower ) ;
75101: LD_ADDR_VAR 0 16
75105: PUSH
75106: LD_VAR 0 1
75110: PPUSH
75111: CALL_OW 255
75115: ST_TO_ADDR
// x := GetX ( tower ) ;
75116: LD_ADDR_VAR 0 10
75120: PUSH
75121: LD_VAR 0 1
75125: PPUSH
75126: CALL_OW 250
75130: ST_TO_ADDR
// y := GetY ( tower ) ;
75131: LD_ADDR_VAR 0 11
75135: PUSH
75136: LD_VAR 0 1
75140: PPUSH
75141: CALL_OW 251
75145: ST_TO_ADDR
// if not x or not y then
75146: LD_VAR 0 10
75150: NOT
75151: PUSH
75152: LD_VAR 0 11
75156: NOT
75157: OR
75158: IFFALSE 75162
// exit ;
75160: GO 76222
// weapon := 0 ;
75162: LD_ADDR_VAR 0 18
75166: PUSH
75167: LD_INT 0
75169: ST_TO_ADDR
// fac_list := [ ] ;
75170: LD_ADDR_VAR 0 17
75174: PUSH
75175: EMPTY
75176: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75177: LD_ADDR_VAR 0 6
75181: PUSH
75182: LD_VAR 0 1
75186: PPUSH
75187: CALL_OW 274
75191: PPUSH
75192: LD_VAR 0 2
75196: PPUSH
75197: CALL 72800 0 2
75201: PPUSH
75202: LD_INT 30
75204: PUSH
75205: LD_INT 3
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PPUSH
75212: CALL_OW 72
75216: ST_TO_ADDR
// if not factories then
75217: LD_VAR 0 6
75221: NOT
75222: IFFALSE 75226
// exit ;
75224: GO 76222
// for i in factories do
75226: LD_ADDR_VAR 0 8
75230: PUSH
75231: LD_VAR 0 6
75235: PUSH
75236: FOR_IN
75237: IFFALSE 75262
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75239: LD_ADDR_VAR 0 17
75243: PUSH
75244: LD_VAR 0 17
75248: PUSH
75249: LD_VAR 0 8
75253: PPUSH
75254: CALL_OW 478
75258: UNION
75259: ST_TO_ADDR
75260: GO 75236
75262: POP
75263: POP
// if not fac_list then
75264: LD_VAR 0 17
75268: NOT
75269: IFFALSE 75273
// exit ;
75271: GO 76222
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75273: LD_ADDR_VAR 0 5
75277: PUSH
75278: LD_INT 4
75280: PUSH
75281: LD_INT 5
75283: PUSH
75284: LD_INT 9
75286: PUSH
75287: LD_INT 10
75289: PUSH
75290: LD_INT 6
75292: PUSH
75293: LD_INT 7
75295: PUSH
75296: LD_INT 11
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: LIST
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: PUSH
75308: LD_INT 27
75310: PUSH
75311: LD_INT 28
75313: PUSH
75314: LD_INT 26
75316: PUSH
75317: LD_INT 30
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 43
75328: PUSH
75329: LD_INT 44
75331: PUSH
75332: LD_INT 46
75334: PUSH
75335: LD_INT 45
75337: PUSH
75338: LD_INT 47
75340: PUSH
75341: LD_INT 49
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: LIST
75356: PUSH
75357: LD_VAR 0 12
75361: ARRAY
75362: ST_TO_ADDR
// for i in list do
75363: LD_ADDR_VAR 0 8
75367: PUSH
75368: LD_VAR 0 5
75372: PUSH
75373: FOR_IN
75374: IFFALSE 75407
// if not i in fac_list then
75376: LD_VAR 0 8
75380: PUSH
75381: LD_VAR 0 17
75385: IN
75386: NOT
75387: IFFALSE 75405
// list := list diff i ;
75389: LD_ADDR_VAR 0 5
75393: PUSH
75394: LD_VAR 0 5
75398: PUSH
75399: LD_VAR 0 8
75403: DIFF
75404: ST_TO_ADDR
75405: GO 75373
75407: POP
75408: POP
// if not list then
75409: LD_VAR 0 5
75413: NOT
75414: IFFALSE 75418
// exit ;
75416: GO 76222
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75418: LD_VAR 0 12
75422: PUSH
75423: LD_INT 3
75425: EQUAL
75426: PUSH
75427: LD_INT 49
75429: PUSH
75430: LD_VAR 0 5
75434: IN
75435: AND
75436: PUSH
75437: LD_INT 31
75439: PPUSH
75440: LD_VAR 0 16
75444: PPUSH
75445: CALL_OW 321
75449: PUSH
75450: LD_INT 2
75452: EQUAL
75453: AND
75454: IFFALSE 75514
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75456: LD_INT 22
75458: PUSH
75459: LD_VAR 0 16
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: PUSH
75468: LD_INT 35
75470: PUSH
75471: LD_INT 49
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 91
75480: PUSH
75481: LD_VAR 0 1
75485: PUSH
75486: LD_INT 10
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: LIST
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: LIST
75498: PPUSH
75499: CALL_OW 69
75503: NOT
75504: IFFALSE 75514
// weapon := ru_time_lapser ;
75506: LD_ADDR_VAR 0 18
75510: PUSH
75511: LD_INT 49
75513: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75514: LD_VAR 0 12
75518: PUSH
75519: LD_INT 1
75521: PUSH
75522: LD_INT 2
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: IN
75529: PUSH
75530: LD_INT 11
75532: PUSH
75533: LD_VAR 0 5
75537: IN
75538: PUSH
75539: LD_INT 30
75541: PUSH
75542: LD_VAR 0 5
75546: IN
75547: OR
75548: AND
75549: PUSH
75550: LD_INT 6
75552: PPUSH
75553: LD_VAR 0 16
75557: PPUSH
75558: CALL_OW 321
75562: PUSH
75563: LD_INT 2
75565: EQUAL
75566: AND
75567: IFFALSE 75732
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75569: LD_INT 22
75571: PUSH
75572: LD_VAR 0 16
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 2
75583: PUSH
75584: LD_INT 35
75586: PUSH
75587: LD_INT 11
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 35
75596: PUSH
75597: LD_INT 30
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: LIST
75608: PUSH
75609: LD_INT 91
75611: PUSH
75612: LD_VAR 0 1
75616: PUSH
75617: LD_INT 18
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: LIST
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: LIST
75629: PPUSH
75630: CALL_OW 69
75634: NOT
75635: PUSH
75636: LD_INT 22
75638: PUSH
75639: LD_VAR 0 16
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 2
75650: PUSH
75651: LD_INT 30
75653: PUSH
75654: LD_INT 32
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 30
75663: PUSH
75664: LD_INT 33
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 91
75678: PUSH
75679: LD_VAR 0 1
75683: PUSH
75684: LD_INT 12
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: LIST
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: LIST
75696: PUSH
75697: EMPTY
75698: LIST
75699: PPUSH
75700: CALL_OW 69
75704: PUSH
75705: LD_INT 2
75707: GREATER
75708: AND
75709: IFFALSE 75732
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75711: LD_ADDR_VAR 0 18
75715: PUSH
75716: LD_INT 11
75718: PUSH
75719: LD_INT 30
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: LD_VAR 0 12
75730: ARRAY
75731: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75732: LD_VAR 0 18
75736: NOT
75737: PUSH
75738: LD_INT 40
75740: PPUSH
75741: LD_VAR 0 16
75745: PPUSH
75746: CALL_OW 321
75750: PUSH
75751: LD_INT 2
75753: EQUAL
75754: AND
75755: PUSH
75756: LD_INT 7
75758: PUSH
75759: LD_VAR 0 5
75763: IN
75764: PUSH
75765: LD_INT 28
75767: PUSH
75768: LD_VAR 0 5
75772: IN
75773: OR
75774: PUSH
75775: LD_INT 45
75777: PUSH
75778: LD_VAR 0 5
75782: IN
75783: OR
75784: AND
75785: IFFALSE 76039
// begin hex := GetHexInfo ( x , y ) ;
75787: LD_ADDR_VAR 0 4
75791: PUSH
75792: LD_VAR 0 10
75796: PPUSH
75797: LD_VAR 0 11
75801: PPUSH
75802: CALL_OW 546
75806: ST_TO_ADDR
// if hex [ 1 ] then
75807: LD_VAR 0 4
75811: PUSH
75812: LD_INT 1
75814: ARRAY
75815: IFFALSE 75819
// exit ;
75817: GO 76222
// height := hex [ 2 ] ;
75819: LD_ADDR_VAR 0 15
75823: PUSH
75824: LD_VAR 0 4
75828: PUSH
75829: LD_INT 2
75831: ARRAY
75832: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75833: LD_ADDR_VAR 0 14
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: LD_INT 2
75843: PUSH
75844: LD_INT 3
75846: PUSH
75847: LD_INT 5
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: LIST
75854: LIST
75855: ST_TO_ADDR
// for i in tmp do
75856: LD_ADDR_VAR 0 8
75860: PUSH
75861: LD_VAR 0 14
75865: PUSH
75866: FOR_IN
75867: IFFALSE 76037
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75869: LD_ADDR_VAR 0 9
75873: PUSH
75874: LD_VAR 0 10
75878: PPUSH
75879: LD_VAR 0 8
75883: PPUSH
75884: LD_INT 5
75886: PPUSH
75887: CALL_OW 272
75891: PUSH
75892: LD_VAR 0 11
75896: PPUSH
75897: LD_VAR 0 8
75901: PPUSH
75902: LD_INT 5
75904: PPUSH
75905: CALL_OW 273
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75914: LD_VAR 0 9
75918: PUSH
75919: LD_INT 1
75921: ARRAY
75922: PPUSH
75923: LD_VAR 0 9
75927: PUSH
75928: LD_INT 2
75930: ARRAY
75931: PPUSH
75932: CALL_OW 488
75936: IFFALSE 76035
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75938: LD_ADDR_VAR 0 4
75942: PUSH
75943: LD_VAR 0 9
75947: PUSH
75948: LD_INT 1
75950: ARRAY
75951: PPUSH
75952: LD_VAR 0 9
75956: PUSH
75957: LD_INT 2
75959: ARRAY
75960: PPUSH
75961: CALL_OW 546
75965: ST_TO_ADDR
// if hex [ 1 ] then
75966: LD_VAR 0 4
75970: PUSH
75971: LD_INT 1
75973: ARRAY
75974: IFFALSE 75978
// continue ;
75976: GO 75866
// h := hex [ 2 ] ;
75978: LD_ADDR_VAR 0 13
75982: PUSH
75983: LD_VAR 0 4
75987: PUSH
75988: LD_INT 2
75990: ARRAY
75991: ST_TO_ADDR
// if h + 7 < height then
75992: LD_VAR 0 13
75996: PUSH
75997: LD_INT 7
75999: PLUS
76000: PUSH
76001: LD_VAR 0 15
76005: LESS
76006: IFFALSE 76035
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76008: LD_ADDR_VAR 0 18
76012: PUSH
76013: LD_INT 7
76015: PUSH
76016: LD_INT 28
76018: PUSH
76019: LD_INT 45
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: LIST
76026: PUSH
76027: LD_VAR 0 12
76031: ARRAY
76032: ST_TO_ADDR
// break ;
76033: GO 76037
// end ; end ; end ;
76035: GO 75866
76037: POP
76038: POP
// end ; if not weapon then
76039: LD_VAR 0 18
76043: NOT
76044: IFFALSE 76104
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76046: LD_ADDR_VAR 0 5
76050: PUSH
76051: LD_VAR 0 5
76055: PUSH
76056: LD_INT 11
76058: PUSH
76059: LD_INT 30
76061: PUSH
76062: LD_INT 49
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: LIST
76069: DIFF
76070: ST_TO_ADDR
// if not list then
76071: LD_VAR 0 5
76075: NOT
76076: IFFALSE 76080
// exit ;
76078: GO 76222
// weapon := list [ rand ( 1 , list ) ] ;
76080: LD_ADDR_VAR 0 18
76084: PUSH
76085: LD_VAR 0 5
76089: PUSH
76090: LD_INT 1
76092: PPUSH
76093: LD_VAR 0 5
76097: PPUSH
76098: CALL_OW 12
76102: ARRAY
76103: ST_TO_ADDR
// end ; if weapon then
76104: LD_VAR 0 18
76108: IFFALSE 76222
// begin tmp := CostOfWeapon ( weapon ) ;
76110: LD_ADDR_VAR 0 14
76114: PUSH
76115: LD_VAR 0 18
76119: PPUSH
76120: CALL_OW 451
76124: ST_TO_ADDR
// j := GetBase ( tower ) ;
76125: LD_ADDR_VAR 0 9
76129: PUSH
76130: LD_VAR 0 1
76134: PPUSH
76135: CALL_OW 274
76139: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76140: LD_VAR 0 9
76144: PPUSH
76145: LD_INT 1
76147: PPUSH
76148: CALL_OW 275
76152: PUSH
76153: LD_VAR 0 14
76157: PUSH
76158: LD_INT 1
76160: ARRAY
76161: GREATEREQUAL
76162: PUSH
76163: LD_VAR 0 9
76167: PPUSH
76168: LD_INT 2
76170: PPUSH
76171: CALL_OW 275
76175: PUSH
76176: LD_VAR 0 14
76180: PUSH
76181: LD_INT 2
76183: ARRAY
76184: GREATEREQUAL
76185: AND
76186: PUSH
76187: LD_VAR 0 9
76191: PPUSH
76192: LD_INT 3
76194: PPUSH
76195: CALL_OW 275
76199: PUSH
76200: LD_VAR 0 14
76204: PUSH
76205: LD_INT 3
76207: ARRAY
76208: GREATEREQUAL
76209: AND
76210: IFFALSE 76222
// result := weapon ;
76212: LD_ADDR_VAR 0 3
76216: PUSH
76217: LD_VAR 0 18
76221: ST_TO_ADDR
// end ; end ;
76222: LD_VAR 0 3
76226: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76227: LD_INT 0
76229: PPUSH
76230: PPUSH
// result := true ;
76231: LD_ADDR_VAR 0 3
76235: PUSH
76236: LD_INT 1
76238: ST_TO_ADDR
// if array1 = array2 then
76239: LD_VAR 0 1
76243: PUSH
76244: LD_VAR 0 2
76248: EQUAL
76249: IFFALSE 76309
// begin for i = 1 to array1 do
76251: LD_ADDR_VAR 0 4
76255: PUSH
76256: DOUBLE
76257: LD_INT 1
76259: DEC
76260: ST_TO_ADDR
76261: LD_VAR 0 1
76265: PUSH
76266: FOR_TO
76267: IFFALSE 76305
// if array1 [ i ] <> array2 [ i ] then
76269: LD_VAR 0 1
76273: PUSH
76274: LD_VAR 0 4
76278: ARRAY
76279: PUSH
76280: LD_VAR 0 2
76284: PUSH
76285: LD_VAR 0 4
76289: ARRAY
76290: NONEQUAL
76291: IFFALSE 76303
// begin result := false ;
76293: LD_ADDR_VAR 0 3
76297: PUSH
76298: LD_INT 0
76300: ST_TO_ADDR
// break ;
76301: GO 76305
// end ;
76303: GO 76266
76305: POP
76306: POP
// end else
76307: GO 76317
// result := false ;
76309: LD_ADDR_VAR 0 3
76313: PUSH
76314: LD_INT 0
76316: ST_TO_ADDR
// end ;
76317: LD_VAR 0 3
76321: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76322: LD_INT 0
76324: PPUSH
76325: PPUSH
76326: PPUSH
// pom := GetBase ( fac ) ;
76327: LD_ADDR_VAR 0 5
76331: PUSH
76332: LD_VAR 0 1
76336: PPUSH
76337: CALL_OW 274
76341: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76342: LD_ADDR_VAR 0 4
76346: PUSH
76347: LD_VAR 0 2
76351: PUSH
76352: LD_INT 1
76354: ARRAY
76355: PPUSH
76356: LD_VAR 0 2
76360: PUSH
76361: LD_INT 2
76363: ARRAY
76364: PPUSH
76365: LD_VAR 0 2
76369: PUSH
76370: LD_INT 3
76372: ARRAY
76373: PPUSH
76374: LD_VAR 0 2
76378: PUSH
76379: LD_INT 4
76381: ARRAY
76382: PPUSH
76383: CALL_OW 449
76387: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76388: LD_ADDR_VAR 0 3
76392: PUSH
76393: LD_VAR 0 5
76397: PPUSH
76398: LD_INT 1
76400: PPUSH
76401: CALL_OW 275
76405: PUSH
76406: LD_VAR 0 4
76410: PUSH
76411: LD_INT 1
76413: ARRAY
76414: GREATEREQUAL
76415: PUSH
76416: LD_VAR 0 5
76420: PPUSH
76421: LD_INT 2
76423: PPUSH
76424: CALL_OW 275
76428: PUSH
76429: LD_VAR 0 4
76433: PUSH
76434: LD_INT 2
76436: ARRAY
76437: GREATEREQUAL
76438: AND
76439: PUSH
76440: LD_VAR 0 5
76444: PPUSH
76445: LD_INT 3
76447: PPUSH
76448: CALL_OW 275
76452: PUSH
76453: LD_VAR 0 4
76457: PUSH
76458: LD_INT 3
76460: ARRAY
76461: GREATEREQUAL
76462: AND
76463: ST_TO_ADDR
// end ;
76464: LD_VAR 0 3
76468: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76469: LD_INT 0
76471: PPUSH
76472: PPUSH
76473: PPUSH
76474: PPUSH
// pom := GetBase ( building ) ;
76475: LD_ADDR_VAR 0 3
76479: PUSH
76480: LD_VAR 0 1
76484: PPUSH
76485: CALL_OW 274
76489: ST_TO_ADDR
// if not pom then
76490: LD_VAR 0 3
76494: NOT
76495: IFFALSE 76499
// exit ;
76497: GO 76669
// btype := GetBType ( building ) ;
76499: LD_ADDR_VAR 0 5
76503: PUSH
76504: LD_VAR 0 1
76508: PPUSH
76509: CALL_OW 266
76513: ST_TO_ADDR
// if btype = b_armoury then
76514: LD_VAR 0 5
76518: PUSH
76519: LD_INT 4
76521: EQUAL
76522: IFFALSE 76532
// btype := b_barracks ;
76524: LD_ADDR_VAR 0 5
76528: PUSH
76529: LD_INT 5
76531: ST_TO_ADDR
// if btype = b_depot then
76532: LD_VAR 0 5
76536: PUSH
76537: LD_INT 0
76539: EQUAL
76540: IFFALSE 76550
// btype := b_warehouse ;
76542: LD_ADDR_VAR 0 5
76546: PUSH
76547: LD_INT 1
76549: ST_TO_ADDR
// if btype = b_workshop then
76550: LD_VAR 0 5
76554: PUSH
76555: LD_INT 2
76557: EQUAL
76558: IFFALSE 76568
// btype := b_factory ;
76560: LD_ADDR_VAR 0 5
76564: PUSH
76565: LD_INT 3
76567: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76568: LD_ADDR_VAR 0 4
76572: PUSH
76573: LD_VAR 0 5
76577: PPUSH
76578: LD_VAR 0 1
76582: PPUSH
76583: CALL_OW 248
76587: PPUSH
76588: CALL_OW 450
76592: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76593: LD_ADDR_VAR 0 2
76597: PUSH
76598: LD_VAR 0 3
76602: PPUSH
76603: LD_INT 1
76605: PPUSH
76606: CALL_OW 275
76610: PUSH
76611: LD_VAR 0 4
76615: PUSH
76616: LD_INT 1
76618: ARRAY
76619: GREATEREQUAL
76620: PUSH
76621: LD_VAR 0 3
76625: PPUSH
76626: LD_INT 2
76628: PPUSH
76629: CALL_OW 275
76633: PUSH
76634: LD_VAR 0 4
76638: PUSH
76639: LD_INT 2
76641: ARRAY
76642: GREATEREQUAL
76643: AND
76644: PUSH
76645: LD_VAR 0 3
76649: PPUSH
76650: LD_INT 3
76652: PPUSH
76653: CALL_OW 275
76657: PUSH
76658: LD_VAR 0 4
76662: PUSH
76663: LD_INT 3
76665: ARRAY
76666: GREATEREQUAL
76667: AND
76668: ST_TO_ADDR
// end ;
76669: LD_VAR 0 2
76673: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76674: LD_INT 0
76676: PPUSH
76677: PPUSH
76678: PPUSH
// pom := GetBase ( building ) ;
76679: LD_ADDR_VAR 0 4
76683: PUSH
76684: LD_VAR 0 1
76688: PPUSH
76689: CALL_OW 274
76693: ST_TO_ADDR
// if not pom then
76694: LD_VAR 0 4
76698: NOT
76699: IFFALSE 76703
// exit ;
76701: GO 76804
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76703: LD_ADDR_VAR 0 5
76707: PUSH
76708: LD_VAR 0 2
76712: PPUSH
76713: LD_VAR 0 1
76717: PPUSH
76718: CALL_OW 248
76722: PPUSH
76723: CALL_OW 450
76727: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76728: LD_ADDR_VAR 0 3
76732: PUSH
76733: LD_VAR 0 4
76737: PPUSH
76738: LD_INT 1
76740: PPUSH
76741: CALL_OW 275
76745: PUSH
76746: LD_VAR 0 5
76750: PUSH
76751: LD_INT 1
76753: ARRAY
76754: GREATEREQUAL
76755: PUSH
76756: LD_VAR 0 4
76760: PPUSH
76761: LD_INT 2
76763: PPUSH
76764: CALL_OW 275
76768: PUSH
76769: LD_VAR 0 5
76773: PUSH
76774: LD_INT 2
76776: ARRAY
76777: GREATEREQUAL
76778: AND
76779: PUSH
76780: LD_VAR 0 4
76784: PPUSH
76785: LD_INT 3
76787: PPUSH
76788: CALL_OW 275
76792: PUSH
76793: LD_VAR 0 5
76797: PUSH
76798: LD_INT 3
76800: ARRAY
76801: GREATEREQUAL
76802: AND
76803: ST_TO_ADDR
// end ;
76804: LD_VAR 0 3
76808: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76809: LD_INT 0
76811: PPUSH
76812: PPUSH
76813: PPUSH
76814: PPUSH
76815: PPUSH
76816: PPUSH
76817: PPUSH
76818: PPUSH
76819: PPUSH
76820: PPUSH
// result := false ;
76821: LD_ADDR_VAR 0 6
76825: PUSH
76826: LD_INT 0
76828: ST_TO_ADDR
// if not base or not btype or not x or not y then
76829: LD_VAR 0 1
76833: NOT
76834: PUSH
76835: LD_VAR 0 2
76839: NOT
76840: OR
76841: PUSH
76842: LD_VAR 0 3
76846: NOT
76847: OR
76848: PUSH
76849: LD_VAR 0 4
76853: NOT
76854: OR
76855: IFFALSE 76859
// exit ;
76857: GO 77468
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76859: LD_ADDR_VAR 0 12
76863: PUSH
76864: LD_VAR 0 2
76868: PPUSH
76869: LD_VAR 0 3
76873: PPUSH
76874: LD_VAR 0 4
76878: PPUSH
76879: LD_VAR 0 5
76883: PPUSH
76884: LD_VAR 0 1
76888: PUSH
76889: LD_INT 1
76891: ARRAY
76892: PPUSH
76893: CALL_OW 248
76897: PPUSH
76898: LD_INT 0
76900: PPUSH
76901: CALL 78305 0 6
76905: ST_TO_ADDR
// if not hexes then
76906: LD_VAR 0 12
76910: NOT
76911: IFFALSE 76915
// exit ;
76913: GO 77468
// for i = 1 to hexes do
76915: LD_ADDR_VAR 0 7
76919: PUSH
76920: DOUBLE
76921: LD_INT 1
76923: DEC
76924: ST_TO_ADDR
76925: LD_VAR 0 12
76929: PUSH
76930: FOR_TO
76931: IFFALSE 77466
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76933: LD_ADDR_VAR 0 11
76937: PUSH
76938: LD_VAR 0 12
76942: PUSH
76943: LD_VAR 0 7
76947: ARRAY
76948: PUSH
76949: LD_INT 1
76951: ARRAY
76952: PPUSH
76953: LD_VAR 0 12
76957: PUSH
76958: LD_VAR 0 7
76962: ARRAY
76963: PUSH
76964: LD_INT 2
76966: ARRAY
76967: PPUSH
76968: CALL_OW 428
76972: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76973: LD_VAR 0 12
76977: PUSH
76978: LD_VAR 0 7
76982: ARRAY
76983: PUSH
76984: LD_INT 1
76986: ARRAY
76987: PPUSH
76988: LD_VAR 0 12
76992: PUSH
76993: LD_VAR 0 7
76997: ARRAY
76998: PUSH
76999: LD_INT 2
77001: ARRAY
77002: PPUSH
77003: CALL_OW 351
77007: PUSH
77008: LD_VAR 0 12
77012: PUSH
77013: LD_VAR 0 7
77017: ARRAY
77018: PUSH
77019: LD_INT 1
77021: ARRAY
77022: PPUSH
77023: LD_VAR 0 12
77027: PUSH
77028: LD_VAR 0 7
77032: ARRAY
77033: PUSH
77034: LD_INT 2
77036: ARRAY
77037: PPUSH
77038: CALL_OW 488
77042: NOT
77043: OR
77044: PUSH
77045: LD_VAR 0 11
77049: PPUSH
77050: CALL_OW 247
77054: PUSH
77055: LD_INT 3
77057: EQUAL
77058: OR
77059: IFFALSE 77065
// exit ;
77061: POP
77062: POP
77063: GO 77468
// if not tmp or not tmp in base then
77065: LD_VAR 0 11
77069: NOT
77070: PUSH
77071: LD_VAR 0 11
77075: PUSH
77076: LD_VAR 0 1
77080: IN
77081: NOT
77082: OR
77083: IFFALSE 77087
// continue ;
77085: GO 76930
// result := true ;
77087: LD_ADDR_VAR 0 6
77091: PUSH
77092: LD_INT 1
77094: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77095: LD_ADDR_VAR 0 15
77099: PUSH
77100: LD_VAR 0 1
77104: PPUSH
77105: LD_INT 22
77107: PUSH
77108: LD_VAR 0 11
77112: PPUSH
77113: CALL_OW 255
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 2
77124: PUSH
77125: LD_INT 30
77127: PUSH
77128: LD_INT 0
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 30
77137: PUSH
77138: LD_INT 1
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: LIST
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PPUSH
77154: CALL_OW 72
77158: ST_TO_ADDR
// if dep then
77159: LD_VAR 0 15
77163: IFFALSE 77299
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77165: LD_ADDR_VAR 0 14
77169: PUSH
77170: LD_VAR 0 15
77174: PUSH
77175: LD_INT 1
77177: ARRAY
77178: PPUSH
77179: CALL_OW 250
77183: PPUSH
77184: LD_VAR 0 15
77188: PUSH
77189: LD_INT 1
77191: ARRAY
77192: PPUSH
77193: CALL_OW 254
77197: PPUSH
77198: LD_INT 5
77200: PPUSH
77201: CALL_OW 272
77205: PUSH
77206: LD_VAR 0 15
77210: PUSH
77211: LD_INT 1
77213: ARRAY
77214: PPUSH
77215: CALL_OW 251
77219: PPUSH
77220: LD_VAR 0 15
77224: PUSH
77225: LD_INT 1
77227: ARRAY
77228: PPUSH
77229: CALL_OW 254
77233: PPUSH
77234: LD_INT 5
77236: PPUSH
77237: CALL_OW 273
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77246: LD_VAR 0 14
77250: PUSH
77251: LD_INT 1
77253: ARRAY
77254: PPUSH
77255: LD_VAR 0 14
77259: PUSH
77260: LD_INT 2
77262: ARRAY
77263: PPUSH
77264: CALL_OW 488
77268: IFFALSE 77299
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77270: LD_VAR 0 11
77274: PPUSH
77275: LD_VAR 0 14
77279: PUSH
77280: LD_INT 1
77282: ARRAY
77283: PPUSH
77284: LD_VAR 0 14
77288: PUSH
77289: LD_INT 2
77291: ARRAY
77292: PPUSH
77293: CALL_OW 111
// continue ;
77297: GO 76930
// end ; end ; r := GetDir ( tmp ) ;
77299: LD_ADDR_VAR 0 13
77303: PUSH
77304: LD_VAR 0 11
77308: PPUSH
77309: CALL_OW 254
77313: ST_TO_ADDR
// if r = 5 then
77314: LD_VAR 0 13
77318: PUSH
77319: LD_INT 5
77321: EQUAL
77322: IFFALSE 77332
// r := 0 ;
77324: LD_ADDR_VAR 0 13
77328: PUSH
77329: LD_INT 0
77331: ST_TO_ADDR
// for j = r to 5 do
77332: LD_ADDR_VAR 0 8
77336: PUSH
77337: DOUBLE
77338: LD_VAR 0 13
77342: DEC
77343: ST_TO_ADDR
77344: LD_INT 5
77346: PUSH
77347: FOR_TO
77348: IFFALSE 77462
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77350: LD_ADDR_VAR 0 9
77354: PUSH
77355: LD_VAR 0 11
77359: PPUSH
77360: CALL_OW 250
77364: PPUSH
77365: LD_VAR 0 8
77369: PPUSH
77370: LD_INT 2
77372: PPUSH
77373: CALL_OW 272
77377: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77378: LD_ADDR_VAR 0 10
77382: PUSH
77383: LD_VAR 0 11
77387: PPUSH
77388: CALL_OW 251
77392: PPUSH
77393: LD_VAR 0 8
77397: PPUSH
77398: LD_INT 2
77400: PPUSH
77401: CALL_OW 273
77405: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77406: LD_VAR 0 9
77410: PPUSH
77411: LD_VAR 0 10
77415: PPUSH
77416: CALL_OW 488
77420: PUSH
77421: LD_VAR 0 9
77425: PPUSH
77426: LD_VAR 0 10
77430: PPUSH
77431: CALL_OW 428
77435: NOT
77436: AND
77437: IFFALSE 77460
// begin ComMoveXY ( tmp , _x , _y ) ;
77439: LD_VAR 0 11
77443: PPUSH
77444: LD_VAR 0 9
77448: PPUSH
77449: LD_VAR 0 10
77453: PPUSH
77454: CALL_OW 111
// break ;
77458: GO 77462
// end ; end ;
77460: GO 77347
77462: POP
77463: POP
// end ;
77464: GO 76930
77466: POP
77467: POP
// end ;
77468: LD_VAR 0 6
77472: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77473: LD_INT 0
77475: PPUSH
77476: PPUSH
77477: PPUSH
77478: PPUSH
77479: PPUSH
77480: PPUSH
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
// result := false ;
77485: LD_ADDR_VAR 0 6
77489: PUSH
77490: LD_INT 0
77492: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77493: LD_VAR 0 1
77497: NOT
77498: PUSH
77499: LD_VAR 0 1
77503: PPUSH
77504: CALL_OW 266
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: IN
77519: NOT
77520: OR
77521: PUSH
77522: LD_VAR 0 2
77526: NOT
77527: OR
77528: PUSH
77529: LD_VAR 0 5
77533: PUSH
77534: LD_INT 0
77536: PUSH
77537: LD_INT 1
77539: PUSH
77540: LD_INT 2
77542: PUSH
77543: LD_INT 3
77545: PUSH
77546: LD_INT 4
77548: PUSH
77549: LD_INT 5
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: IN
77560: NOT
77561: OR
77562: PUSH
77563: LD_VAR 0 3
77567: PPUSH
77568: LD_VAR 0 4
77572: PPUSH
77573: CALL_OW 488
77577: NOT
77578: OR
77579: IFFALSE 77583
// exit ;
77581: GO 78300
// pom := GetBase ( depot ) ;
77583: LD_ADDR_VAR 0 10
77587: PUSH
77588: LD_VAR 0 1
77592: PPUSH
77593: CALL_OW 274
77597: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77598: LD_ADDR_VAR 0 11
77602: PUSH
77603: LD_VAR 0 2
77607: PPUSH
77608: LD_VAR 0 1
77612: PPUSH
77613: CALL_OW 248
77617: PPUSH
77618: CALL_OW 450
77622: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77623: LD_VAR 0 10
77627: PPUSH
77628: LD_INT 1
77630: PPUSH
77631: CALL_OW 275
77635: PUSH
77636: LD_VAR 0 11
77640: PUSH
77641: LD_INT 1
77643: ARRAY
77644: GREATEREQUAL
77645: PUSH
77646: LD_VAR 0 10
77650: PPUSH
77651: LD_INT 2
77653: PPUSH
77654: CALL_OW 275
77658: PUSH
77659: LD_VAR 0 11
77663: PUSH
77664: LD_INT 2
77666: ARRAY
77667: GREATEREQUAL
77668: AND
77669: PUSH
77670: LD_VAR 0 10
77674: PPUSH
77675: LD_INT 3
77677: PPUSH
77678: CALL_OW 275
77682: PUSH
77683: LD_VAR 0 11
77687: PUSH
77688: LD_INT 3
77690: ARRAY
77691: GREATEREQUAL
77692: AND
77693: NOT
77694: IFFALSE 77698
// exit ;
77696: GO 78300
// if GetBType ( depot ) = b_depot then
77698: LD_VAR 0 1
77702: PPUSH
77703: CALL_OW 266
77707: PUSH
77708: LD_INT 0
77710: EQUAL
77711: IFFALSE 77723
// dist := 28 else
77713: LD_ADDR_VAR 0 14
77717: PUSH
77718: LD_INT 28
77720: ST_TO_ADDR
77721: GO 77731
// dist := 36 ;
77723: LD_ADDR_VAR 0 14
77727: PUSH
77728: LD_INT 36
77730: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77731: LD_VAR 0 1
77735: PPUSH
77736: LD_VAR 0 3
77740: PPUSH
77741: LD_VAR 0 4
77745: PPUSH
77746: CALL_OW 297
77750: PUSH
77751: LD_VAR 0 14
77755: GREATER
77756: IFFALSE 77760
// exit ;
77758: GO 78300
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77760: LD_ADDR_VAR 0 12
77764: PUSH
77765: LD_VAR 0 2
77769: PPUSH
77770: LD_VAR 0 3
77774: PPUSH
77775: LD_VAR 0 4
77779: PPUSH
77780: LD_VAR 0 5
77784: PPUSH
77785: LD_VAR 0 1
77789: PPUSH
77790: CALL_OW 248
77794: PPUSH
77795: LD_INT 0
77797: PPUSH
77798: CALL 78305 0 6
77802: ST_TO_ADDR
// if not hexes then
77803: LD_VAR 0 12
77807: NOT
77808: IFFALSE 77812
// exit ;
77810: GO 78300
// hex := GetHexInfo ( x , y ) ;
77812: LD_ADDR_VAR 0 15
77816: PUSH
77817: LD_VAR 0 3
77821: PPUSH
77822: LD_VAR 0 4
77826: PPUSH
77827: CALL_OW 546
77831: ST_TO_ADDR
// if hex [ 1 ] then
77832: LD_VAR 0 15
77836: PUSH
77837: LD_INT 1
77839: ARRAY
77840: IFFALSE 77844
// exit ;
77842: GO 78300
// height := hex [ 2 ] ;
77844: LD_ADDR_VAR 0 13
77848: PUSH
77849: LD_VAR 0 15
77853: PUSH
77854: LD_INT 2
77856: ARRAY
77857: ST_TO_ADDR
// for i = 1 to hexes do
77858: LD_ADDR_VAR 0 7
77862: PUSH
77863: DOUBLE
77864: LD_INT 1
77866: DEC
77867: ST_TO_ADDR
77868: LD_VAR 0 12
77872: PUSH
77873: FOR_TO
77874: IFFALSE 78204
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77876: LD_VAR 0 12
77880: PUSH
77881: LD_VAR 0 7
77885: ARRAY
77886: PUSH
77887: LD_INT 1
77889: ARRAY
77890: PPUSH
77891: LD_VAR 0 12
77895: PUSH
77896: LD_VAR 0 7
77900: ARRAY
77901: PUSH
77902: LD_INT 2
77904: ARRAY
77905: PPUSH
77906: CALL_OW 488
77910: NOT
77911: PUSH
77912: LD_VAR 0 12
77916: PUSH
77917: LD_VAR 0 7
77921: ARRAY
77922: PUSH
77923: LD_INT 1
77925: ARRAY
77926: PPUSH
77927: LD_VAR 0 12
77931: PUSH
77932: LD_VAR 0 7
77936: ARRAY
77937: PUSH
77938: LD_INT 2
77940: ARRAY
77941: PPUSH
77942: CALL_OW 428
77946: PUSH
77947: LD_INT 0
77949: GREATER
77950: OR
77951: PUSH
77952: LD_VAR 0 12
77956: PUSH
77957: LD_VAR 0 7
77961: ARRAY
77962: PUSH
77963: LD_INT 1
77965: ARRAY
77966: PPUSH
77967: LD_VAR 0 12
77971: PUSH
77972: LD_VAR 0 7
77976: ARRAY
77977: PUSH
77978: LD_INT 2
77980: ARRAY
77981: PPUSH
77982: CALL_OW 351
77986: OR
77987: IFFALSE 77993
// exit ;
77989: POP
77990: POP
77991: GO 78300
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77993: LD_ADDR_VAR 0 8
77997: PUSH
77998: LD_VAR 0 12
78002: PUSH
78003: LD_VAR 0 7
78007: ARRAY
78008: PUSH
78009: LD_INT 1
78011: ARRAY
78012: PPUSH
78013: LD_VAR 0 12
78017: PUSH
78018: LD_VAR 0 7
78022: ARRAY
78023: PUSH
78024: LD_INT 2
78026: ARRAY
78027: PPUSH
78028: CALL_OW 546
78032: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78033: LD_VAR 0 8
78037: PUSH
78038: LD_INT 1
78040: ARRAY
78041: PUSH
78042: LD_VAR 0 8
78046: PUSH
78047: LD_INT 2
78049: ARRAY
78050: PUSH
78051: LD_VAR 0 13
78055: PUSH
78056: LD_INT 2
78058: PLUS
78059: GREATER
78060: OR
78061: PUSH
78062: LD_VAR 0 8
78066: PUSH
78067: LD_INT 2
78069: ARRAY
78070: PUSH
78071: LD_VAR 0 13
78075: PUSH
78076: LD_INT 2
78078: MINUS
78079: LESS
78080: OR
78081: PUSH
78082: LD_VAR 0 8
78086: PUSH
78087: LD_INT 3
78089: ARRAY
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: LD_INT 8
78096: PUSH
78097: LD_INT 9
78099: PUSH
78100: LD_INT 10
78102: PUSH
78103: LD_INT 11
78105: PUSH
78106: LD_INT 12
78108: PUSH
78109: LD_INT 13
78111: PUSH
78112: LD_INT 16
78114: PUSH
78115: LD_INT 17
78117: PUSH
78118: LD_INT 18
78120: PUSH
78121: LD_INT 19
78123: PUSH
78124: LD_INT 20
78126: PUSH
78127: LD_INT 21
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: IN
78145: NOT
78146: OR
78147: PUSH
78148: LD_VAR 0 8
78152: PUSH
78153: LD_INT 5
78155: ARRAY
78156: NOT
78157: OR
78158: PUSH
78159: LD_VAR 0 8
78163: PUSH
78164: LD_INT 6
78166: ARRAY
78167: PUSH
78168: LD_INT 1
78170: PUSH
78171: LD_INT 2
78173: PUSH
78174: LD_INT 7
78176: PUSH
78177: LD_INT 9
78179: PUSH
78180: LD_INT 10
78182: PUSH
78183: LD_INT 11
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: LIST
78190: LIST
78191: LIST
78192: LIST
78193: IN
78194: NOT
78195: OR
78196: IFFALSE 78202
// exit ;
78198: POP
78199: POP
78200: GO 78300
// end ;
78202: GO 77873
78204: POP
78205: POP
// side := GetSide ( depot ) ;
78206: LD_ADDR_VAR 0 9
78210: PUSH
78211: LD_VAR 0 1
78215: PPUSH
78216: CALL_OW 255
78220: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78221: LD_VAR 0 9
78225: PPUSH
78226: LD_VAR 0 3
78230: PPUSH
78231: LD_VAR 0 4
78235: PPUSH
78236: LD_INT 20
78238: PPUSH
78239: CALL 70954 0 4
78243: PUSH
78244: LD_INT 4
78246: ARRAY
78247: IFFALSE 78251
// exit ;
78249: GO 78300
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78251: LD_VAR 0 2
78255: PUSH
78256: LD_INT 29
78258: PUSH
78259: LD_INT 30
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: IN
78266: PUSH
78267: LD_VAR 0 3
78271: PPUSH
78272: LD_VAR 0 4
78276: PPUSH
78277: LD_VAR 0 9
78281: PPUSH
78282: CALL_OW 440
78286: NOT
78287: AND
78288: IFFALSE 78292
// exit ;
78290: GO 78300
// result := true ;
78292: LD_ADDR_VAR 0 6
78296: PUSH
78297: LD_INT 1
78299: ST_TO_ADDR
// end ;
78300: LD_VAR 0 6
78304: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78305: LD_INT 0
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
78314: PPUSH
78315: PPUSH
78316: PPUSH
78317: PPUSH
78318: PPUSH
78319: PPUSH
78320: PPUSH
78321: PPUSH
78322: PPUSH
78323: PPUSH
78324: PPUSH
78325: PPUSH
78326: PPUSH
78327: PPUSH
78328: PPUSH
78329: PPUSH
78330: PPUSH
78331: PPUSH
78332: PPUSH
78333: PPUSH
78334: PPUSH
78335: PPUSH
78336: PPUSH
78337: PPUSH
78338: PPUSH
78339: PPUSH
78340: PPUSH
78341: PPUSH
78342: PPUSH
78343: PPUSH
78344: PPUSH
78345: PPUSH
78346: PPUSH
78347: PPUSH
78348: PPUSH
78349: PPUSH
78350: PPUSH
78351: PPUSH
78352: PPUSH
78353: PPUSH
78354: PPUSH
78355: PPUSH
78356: PPUSH
78357: PPUSH
78358: PPUSH
78359: PPUSH
78360: PPUSH
78361: PPUSH
78362: PPUSH
78363: PPUSH
78364: PPUSH
// result = [ ] ;
78365: LD_ADDR_VAR 0 7
78369: PUSH
78370: EMPTY
78371: ST_TO_ADDR
// temp_list = [ ] ;
78372: LD_ADDR_VAR 0 9
78376: PUSH
78377: EMPTY
78378: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78379: LD_VAR 0 4
78383: PUSH
78384: LD_INT 0
78386: PUSH
78387: LD_INT 1
78389: PUSH
78390: LD_INT 2
78392: PUSH
78393: LD_INT 3
78395: PUSH
78396: LD_INT 4
78398: PUSH
78399: LD_INT 5
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: IN
78410: NOT
78411: PUSH
78412: LD_VAR 0 1
78416: PUSH
78417: LD_INT 0
78419: PUSH
78420: LD_INT 1
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: IN
78427: PUSH
78428: LD_VAR 0 5
78432: PUSH
78433: LD_INT 1
78435: PUSH
78436: LD_INT 2
78438: PUSH
78439: LD_INT 3
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: LIST
78446: IN
78447: NOT
78448: AND
78449: OR
78450: IFFALSE 78454
// exit ;
78452: GO 96845
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78454: LD_VAR 0 1
78458: PUSH
78459: LD_INT 6
78461: PUSH
78462: LD_INT 7
78464: PUSH
78465: LD_INT 8
78467: PUSH
78468: LD_INT 13
78470: PUSH
78471: LD_INT 12
78473: PUSH
78474: LD_INT 15
78476: PUSH
78477: LD_INT 11
78479: PUSH
78480: LD_INT 14
78482: PUSH
78483: LD_INT 10
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: LIST
78490: LIST
78491: LIST
78492: LIST
78493: LIST
78494: LIST
78495: LIST
78496: IN
78497: IFFALSE 78507
// btype = b_lab ;
78499: LD_ADDR_VAR 0 1
78503: PUSH
78504: LD_INT 6
78506: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78507: LD_VAR 0 6
78511: PUSH
78512: LD_INT 0
78514: PUSH
78515: LD_INT 1
78517: PUSH
78518: LD_INT 2
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: LIST
78525: IN
78526: NOT
78527: PUSH
78528: LD_VAR 0 1
78532: PUSH
78533: LD_INT 0
78535: PUSH
78536: LD_INT 1
78538: PUSH
78539: LD_INT 2
78541: PUSH
78542: LD_INT 3
78544: PUSH
78545: LD_INT 6
78547: PUSH
78548: LD_INT 36
78550: PUSH
78551: LD_INT 4
78553: PUSH
78554: LD_INT 5
78556: PUSH
78557: LD_INT 31
78559: PUSH
78560: LD_INT 32
78562: PUSH
78563: LD_INT 33
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: IN
78579: NOT
78580: PUSH
78581: LD_VAR 0 6
78585: PUSH
78586: LD_INT 1
78588: EQUAL
78589: AND
78590: OR
78591: PUSH
78592: LD_VAR 0 1
78596: PUSH
78597: LD_INT 2
78599: PUSH
78600: LD_INT 3
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: IN
78607: NOT
78608: PUSH
78609: LD_VAR 0 6
78613: PUSH
78614: LD_INT 2
78616: EQUAL
78617: AND
78618: OR
78619: IFFALSE 78629
// mode = 0 ;
78621: LD_ADDR_VAR 0 6
78625: PUSH
78626: LD_INT 0
78628: ST_TO_ADDR
// case mode of 0 :
78629: LD_VAR 0 6
78633: PUSH
78634: LD_INT 0
78636: DOUBLE
78637: EQUAL
78638: IFTRUE 78642
78640: GO 90095
78642: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78643: LD_ADDR_VAR 0 11
78647: PUSH
78648: LD_INT 0
78650: PUSH
78651: LD_INT 0
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 0
78660: PUSH
78661: LD_INT 1
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 1
78671: PUSH
78672: LD_INT 0
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 1
78681: PUSH
78682: LD_INT 1
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 0
78691: PUSH
78692: LD_INT 1
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 1
78701: NEG
78702: PUSH
78703: LD_INT 0
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 1
78712: NEG
78713: PUSH
78714: LD_INT 1
78716: NEG
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 1
78724: NEG
78725: PUSH
78726: LD_INT 2
78728: NEG
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 0
78736: PUSH
78737: LD_INT 2
78739: NEG
78740: PUSH
78741: EMPTY
78742: LIST
78743: LIST
78744: PUSH
78745: LD_INT 1
78747: PUSH
78748: LD_INT 1
78750: NEG
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 1
78758: PUSH
78759: LD_INT 2
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: LD_INT 2
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 1
78778: NEG
78779: PUSH
78780: LD_INT 1
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 1
78789: PUSH
78790: LD_INT 3
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: LD_INT 3
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PUSH
78807: LD_INT 1
78809: NEG
78810: PUSH
78811: LD_INT 2
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78836: LD_ADDR_VAR 0 12
78840: PUSH
78841: LD_INT 0
78843: PUSH
78844: LD_INT 0
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PUSH
78851: LD_INT 0
78853: PUSH
78854: LD_INT 1
78856: NEG
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 1
78864: PUSH
78865: LD_INT 0
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 1
78874: PUSH
78875: LD_INT 1
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 0
78884: PUSH
78885: LD_INT 1
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 1
78894: NEG
78895: PUSH
78896: LD_INT 0
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 1
78905: NEG
78906: PUSH
78907: LD_INT 1
78909: NEG
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: PUSH
78915: LD_INT 1
78917: PUSH
78918: LD_INT 1
78920: NEG
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 2
78928: PUSH
78929: LD_INT 0
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 2
78938: PUSH
78939: LD_INT 1
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 1
78948: NEG
78949: PUSH
78950: LD_INT 1
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 2
78959: NEG
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: EMPTY
78965: LIST
78966: LIST
78967: PUSH
78968: LD_INT 2
78970: NEG
78971: PUSH
78972: LD_INT 1
78974: NEG
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 2
78982: NEG
78983: PUSH
78984: LD_INT 1
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 3
78993: NEG
78994: PUSH
78995: LD_INT 0
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 3
79004: NEG
79005: PUSH
79006: LD_INT 1
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79032: LD_ADDR_VAR 0 13
79036: PUSH
79037: LD_INT 0
79039: PUSH
79040: LD_INT 0
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 0
79049: PUSH
79050: LD_INT 1
79052: NEG
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: PUSH
79061: LD_INT 0
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 1
79070: PUSH
79071: LD_INT 1
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 0
79080: PUSH
79081: LD_INT 1
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: LD_INT 0
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 1
79101: NEG
79102: PUSH
79103: LD_INT 1
79105: NEG
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 1
79113: NEG
79114: PUSH
79115: LD_INT 2
79117: NEG
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 2
79125: PUSH
79126: LD_INT 1
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 2
79135: PUSH
79136: LD_INT 2
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: LD_INT 1
79145: PUSH
79146: LD_INT 2
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 2
79155: NEG
79156: PUSH
79157: LD_INT 1
79159: NEG
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 2
79167: NEG
79168: PUSH
79169: LD_INT 2
79171: NEG
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 2
79179: NEG
79180: PUSH
79181: LD_INT 3
79183: NEG
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 3
79191: NEG
79192: PUSH
79193: LD_INT 2
79195: NEG
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 3
79203: NEG
79204: PUSH
79205: LD_INT 3
79207: NEG
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79231: LD_ADDR_VAR 0 14
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: LD_INT 0
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 0
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 1
79259: PUSH
79260: LD_INT 0
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 1
79269: PUSH
79270: LD_INT 1
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 0
79279: PUSH
79280: LD_INT 1
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 1
79289: NEG
79290: PUSH
79291: LD_INT 0
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: PUSH
79298: LD_INT 1
79300: NEG
79301: PUSH
79302: LD_INT 1
79304: NEG
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 1
79312: NEG
79313: PUSH
79314: LD_INT 2
79316: NEG
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 0
79324: PUSH
79325: LD_INT 2
79327: NEG
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 1
79335: PUSH
79336: LD_INT 1
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 1
79346: PUSH
79347: LD_INT 2
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 0
79356: PUSH
79357: LD_INT 2
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 1
79366: NEG
79367: PUSH
79368: LD_INT 1
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 1
79377: NEG
79378: PUSH
79379: LD_INT 3
79381: NEG
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 0
79389: PUSH
79390: LD_INT 3
79392: NEG
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 1
79400: PUSH
79401: LD_INT 2
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79427: LD_ADDR_VAR 0 15
79431: PUSH
79432: LD_INT 0
79434: PUSH
79435: LD_INT 0
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 0
79444: PUSH
79445: LD_INT 1
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: PUSH
79456: LD_INT 0
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 1
79465: PUSH
79466: LD_INT 1
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 0
79475: PUSH
79476: LD_INT 1
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 1
79485: NEG
79486: PUSH
79487: LD_INT 0
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 1
79508: PUSH
79509: LD_INT 1
79511: NEG
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 2
79519: PUSH
79520: LD_INT 0
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 2
79529: PUSH
79530: LD_INT 1
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 1
79539: NEG
79540: PUSH
79541: LD_INT 1
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 2
79550: NEG
79551: PUSH
79552: LD_INT 0
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 2
79561: NEG
79562: PUSH
79563: LD_INT 1
79565: NEG
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 2
79573: PUSH
79574: LD_INT 1
79576: NEG
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 3
79584: PUSH
79585: LD_INT 0
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 3
79594: PUSH
79595: LD_INT 1
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79620: LD_ADDR_VAR 0 16
79624: PUSH
79625: LD_INT 0
79627: PUSH
79628: LD_INT 0
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 0
79637: PUSH
79638: LD_INT 1
79640: NEG
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 1
79648: PUSH
79649: LD_INT 0
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 1
79658: PUSH
79659: LD_INT 1
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: LD_INT 0
79668: PUSH
79669: LD_INT 1
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PUSH
79676: LD_INT 1
79678: NEG
79679: PUSH
79680: LD_INT 0
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 1
79689: NEG
79690: PUSH
79691: LD_INT 1
79693: NEG
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 1
79701: NEG
79702: PUSH
79703: LD_INT 2
79705: NEG
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 2
79713: PUSH
79714: LD_INT 1
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: LD_INT 2
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 1
79733: PUSH
79734: LD_INT 2
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 2
79743: NEG
79744: PUSH
79745: LD_INT 1
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 2
79755: NEG
79756: PUSH
79757: LD_INT 2
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 3
79767: PUSH
79768: LD_INT 2
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 3
79777: PUSH
79778: LD_INT 3
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 2
79787: PUSH
79788: LD_INT 3
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: LIST
79811: LIST
79812: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79813: LD_ADDR_VAR 0 17
79817: PUSH
79818: LD_INT 0
79820: PUSH
79821: LD_INT 0
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: LD_INT 1
79833: NEG
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 1
79841: PUSH
79842: LD_INT 0
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 1
79851: PUSH
79852: LD_INT 1
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 0
79861: PUSH
79862: LD_INT 1
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: NEG
79872: PUSH
79873: LD_INT 0
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 1
79882: NEG
79883: PUSH
79884: LD_INT 1
79886: NEG
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 1
79894: NEG
79895: PUSH
79896: LD_INT 2
79898: NEG
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: LD_INT 2
79909: NEG
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: LD_INT 1
79920: NEG
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 2
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 2
79938: PUSH
79939: LD_INT 1
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 2
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: PUSH
79959: LD_INT 2
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 0
79968: PUSH
79969: LD_INT 2
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 1
79978: NEG
79979: PUSH
79980: LD_INT 1
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 2
79989: NEG
79990: PUSH
79991: LD_INT 0
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 2
80000: NEG
80001: PUSH
80002: LD_INT 1
80004: NEG
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 2
80012: NEG
80013: PUSH
80014: LD_INT 2
80016: NEG
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: LIST
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80043: LD_ADDR_VAR 0 18
80047: PUSH
80048: LD_INT 0
80050: PUSH
80051: LD_INT 0
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 0
80060: PUSH
80061: LD_INT 1
80063: NEG
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 1
80071: PUSH
80072: LD_INT 0
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 1
80081: PUSH
80082: LD_INT 1
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 0
80091: PUSH
80092: LD_INT 1
80094: PUSH
80095: EMPTY
80096: LIST
80097: LIST
80098: PUSH
80099: LD_INT 1
80101: NEG
80102: PUSH
80103: LD_INT 0
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 1
80112: NEG
80113: PUSH
80114: LD_INT 1
80116: NEG
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PUSH
80122: LD_INT 1
80124: NEG
80125: PUSH
80126: LD_INT 2
80128: NEG
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 0
80136: PUSH
80137: LD_INT 2
80139: NEG
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 1
80147: PUSH
80148: LD_INT 1
80150: NEG
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 2
80158: PUSH
80159: LD_INT 0
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: LD_INT 2
80168: PUSH
80169: LD_INT 1
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 2
80178: PUSH
80179: LD_INT 2
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 1
80188: PUSH
80189: LD_INT 2
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 0
80198: PUSH
80199: LD_INT 2
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 1
80208: NEG
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 2
80219: NEG
80220: PUSH
80221: LD_INT 0
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 2
80230: NEG
80231: PUSH
80232: LD_INT 1
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 2
80242: NEG
80243: PUSH
80244: LD_INT 2
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80273: LD_ADDR_VAR 0 19
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: LD_INT 0
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 0
80290: PUSH
80291: LD_INT 1
80293: NEG
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 1
80301: PUSH
80302: LD_INT 0
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 1
80311: PUSH
80312: LD_INT 1
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 0
80321: PUSH
80322: LD_INT 1
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 1
80331: NEG
80332: PUSH
80333: LD_INT 0
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 1
80342: NEG
80343: PUSH
80344: LD_INT 1
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 1
80354: NEG
80355: PUSH
80356: LD_INT 2
80358: NEG
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 0
80366: PUSH
80367: LD_INT 2
80369: NEG
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: LD_INT 1
80380: NEG
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 2
80388: PUSH
80389: LD_INT 0
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 2
80398: PUSH
80399: LD_INT 1
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 2
80408: PUSH
80409: LD_INT 2
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: LD_INT 2
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: LD_INT 2
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: LD_INT 1
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: NEG
80450: PUSH
80451: LD_INT 0
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 2
80460: NEG
80461: PUSH
80462: LD_INT 1
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 2
80472: NEG
80473: PUSH
80474: LD_INT 2
80476: NEG
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80503: LD_ADDR_VAR 0 20
80507: PUSH
80508: LD_INT 0
80510: PUSH
80511: LD_INT 0
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 0
80520: PUSH
80521: LD_INT 1
80523: NEG
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 1
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: PUSH
80542: LD_INT 1
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 0
80551: PUSH
80552: LD_INT 1
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 1
80561: NEG
80562: PUSH
80563: LD_INT 0
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 1
80572: NEG
80573: PUSH
80574: LD_INT 1
80576: NEG
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 1
80584: NEG
80585: PUSH
80586: LD_INT 2
80588: NEG
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 0
80596: PUSH
80597: LD_INT 2
80599: NEG
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 1
80607: PUSH
80608: LD_INT 1
80610: NEG
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 2
80618: PUSH
80619: LD_INT 0
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 2
80628: PUSH
80629: LD_INT 1
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 2
80638: PUSH
80639: LD_INT 2
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: PUSH
80649: LD_INT 2
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 0
80658: PUSH
80659: LD_INT 2
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 1
80668: NEG
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PUSH
80677: LD_INT 2
80679: NEG
80680: PUSH
80681: LD_INT 0
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 2
80690: NEG
80691: PUSH
80692: LD_INT 1
80694: NEG
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 2
80702: NEG
80703: PUSH
80704: LD_INT 2
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80733: LD_ADDR_VAR 0 21
80737: PUSH
80738: LD_INT 0
80740: PUSH
80741: LD_INT 0
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: LD_INT 1
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 1
80761: PUSH
80762: LD_INT 0
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 1
80771: PUSH
80772: LD_INT 1
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: LD_INT 0
80781: PUSH
80782: LD_INT 1
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: LD_INT 1
80791: NEG
80792: PUSH
80793: LD_INT 0
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: LD_INT 1
80806: NEG
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: LD_INT 2
80818: NEG
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 0
80826: PUSH
80827: LD_INT 2
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: LD_INT 1
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 2
80848: PUSH
80849: LD_INT 0
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 2
80858: PUSH
80859: LD_INT 1
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 2
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 1
80878: PUSH
80879: LD_INT 2
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: LD_INT 2
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: LD_INT 1
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 2
80909: NEG
80910: PUSH
80911: LD_INT 0
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 2
80920: NEG
80921: PUSH
80922: LD_INT 1
80924: NEG
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 2
80932: NEG
80933: PUSH
80934: LD_INT 2
80936: NEG
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80963: LD_ADDR_VAR 0 22
80967: PUSH
80968: LD_INT 0
80970: PUSH
80971: LD_INT 0
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 0
80980: PUSH
80981: LD_INT 1
80983: NEG
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: LD_INT 0
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: PUSH
81002: LD_INT 1
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 0
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 0
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 1
81032: NEG
81033: PUSH
81034: LD_INT 1
81036: NEG
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 1
81044: NEG
81045: PUSH
81046: LD_INT 2
81048: NEG
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: LD_INT 0
81056: PUSH
81057: LD_INT 2
81059: NEG
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 1
81067: PUSH
81068: LD_INT 1
81070: NEG
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 2
81078: PUSH
81079: LD_INT 0
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 2
81088: PUSH
81089: LD_INT 1
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 2
81098: PUSH
81099: LD_INT 2
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 1
81108: PUSH
81109: LD_INT 2
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 0
81118: PUSH
81119: LD_INT 2
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 1
81128: NEG
81129: PUSH
81130: LD_INT 1
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 2
81139: NEG
81140: PUSH
81141: LD_INT 0
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PUSH
81148: LD_INT 2
81150: NEG
81151: PUSH
81152: LD_INT 1
81154: NEG
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: PUSH
81160: LD_INT 2
81162: NEG
81163: PUSH
81164: LD_INT 2
81166: NEG
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81193: LD_ADDR_VAR 0 23
81197: PUSH
81198: LD_INT 0
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: LD_INT 1
81213: NEG
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 1
81221: PUSH
81222: LD_INT 0
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 1
81231: PUSH
81232: LD_INT 1
81234: PUSH
81235: EMPTY
81236: LIST
81237: LIST
81238: PUSH
81239: LD_INT 0
81241: PUSH
81242: LD_INT 1
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 1
81251: NEG
81252: PUSH
81253: LD_INT 0
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 1
81262: NEG
81263: PUSH
81264: LD_INT 1
81266: NEG
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 1
81274: NEG
81275: PUSH
81276: LD_INT 2
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 0
81286: PUSH
81287: LD_INT 2
81289: NEG
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 1
81297: PUSH
81298: LD_INT 1
81300: NEG
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 2
81318: PUSH
81319: LD_INT 1
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 2
81328: PUSH
81329: LD_INT 2
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 1
81338: PUSH
81339: LD_INT 2
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 0
81348: PUSH
81349: LD_INT 2
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 1
81358: NEG
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 2
81369: NEG
81370: PUSH
81371: LD_INT 0
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 2
81380: NEG
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 2
81392: NEG
81393: PUSH
81394: LD_INT 2
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 2
81404: NEG
81405: PUSH
81406: LD_INT 3
81408: NEG
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 1
81416: NEG
81417: PUSH
81418: LD_INT 3
81420: NEG
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 1
81428: PUSH
81429: LD_INT 2
81431: NEG
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 2
81439: PUSH
81440: LD_INT 1
81442: NEG
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81473: LD_ADDR_VAR 0 24
81477: PUSH
81478: LD_INT 0
81480: PUSH
81481: LD_INT 0
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 0
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: PUSH
81502: LD_INT 0
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 1
81511: PUSH
81512: LD_INT 1
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 0
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 1
81531: NEG
81532: PUSH
81533: LD_INT 0
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 1
81542: NEG
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 1
81554: NEG
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: LD_INT 2
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: PUSH
81578: LD_INT 1
81580: NEG
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 2
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 2
81598: PUSH
81599: LD_INT 1
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 2
81608: PUSH
81609: LD_INT 2
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 1
81618: PUSH
81619: LD_INT 2
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 0
81628: PUSH
81629: LD_INT 2
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: LD_INT 1
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 2
81649: NEG
81650: PUSH
81651: LD_INT 0
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 2
81660: NEG
81661: PUSH
81662: LD_INT 1
81664: NEG
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 2
81672: NEG
81673: PUSH
81674: LD_INT 2
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 1
81684: PUSH
81685: LD_INT 2
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 2
81695: PUSH
81696: LD_INT 1
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 3
81706: PUSH
81707: LD_INT 1
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 3
81716: PUSH
81717: LD_INT 2
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81749: LD_ADDR_VAR 0 25
81753: PUSH
81754: LD_INT 0
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 0
81766: PUSH
81767: LD_INT 1
81769: NEG
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 1
81777: PUSH
81778: LD_INT 0
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 1
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: LD_INT 1
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 1
81807: NEG
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 1
81818: NEG
81819: PUSH
81820: LD_INT 1
81822: NEG
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 1
81830: NEG
81831: PUSH
81832: LD_INT 2
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: LD_INT 2
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: LD_INT 1
81856: NEG
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 2
81874: PUSH
81875: LD_INT 1
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 2
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: LD_INT 2
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: LD_INT 2
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 1
81914: NEG
81915: PUSH
81916: LD_INT 1
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 2
81925: NEG
81926: PUSH
81927: LD_INT 0
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 2
81936: NEG
81937: PUSH
81938: LD_INT 1
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 2
81948: NEG
81949: PUSH
81950: LD_INT 2
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 3
81960: PUSH
81961: LD_INT 1
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 3
81970: PUSH
81971: LD_INT 2
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 2
81980: PUSH
81981: LD_INT 3
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: LD_INT 3
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82023: LD_ADDR_VAR 0 26
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 0
82040: PUSH
82041: LD_INT 1
82043: NEG
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 1
82051: PUSH
82052: LD_INT 0
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 1
82061: PUSH
82062: LD_INT 1
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 0
82071: PUSH
82072: LD_INT 1
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: LD_INT 0
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 1
82092: NEG
82093: PUSH
82094: LD_INT 1
82096: NEG
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 1
82104: NEG
82105: PUSH
82106: LD_INT 2
82108: NEG
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 0
82116: PUSH
82117: LD_INT 2
82119: NEG
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 1
82127: PUSH
82128: LD_INT 1
82130: NEG
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: PUSH
82136: LD_INT 2
82138: PUSH
82139: LD_INT 0
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 2
82148: PUSH
82149: LD_INT 1
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 2
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 1
82168: PUSH
82169: LD_INT 2
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 0
82178: PUSH
82179: LD_INT 2
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 1
82188: NEG
82189: PUSH
82190: LD_INT 1
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 2
82199: NEG
82200: PUSH
82201: LD_INT 0
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: PUSH
82208: LD_INT 2
82210: NEG
82211: PUSH
82212: LD_INT 1
82214: NEG
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 2
82222: NEG
82223: PUSH
82224: LD_INT 2
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 2
82234: PUSH
82235: LD_INT 3
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 1
82244: PUSH
82245: LD_INT 3
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 1
82254: NEG
82255: PUSH
82256: LD_INT 2
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 2
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82299: LD_ADDR_VAR 0 27
82303: PUSH
82304: LD_INT 0
82306: PUSH
82307: LD_INT 0
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: LD_INT 1
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 1
82327: PUSH
82328: LD_INT 0
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: LD_INT 1
82337: PUSH
82338: LD_INT 1
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PUSH
82345: LD_INT 0
82347: PUSH
82348: LD_INT 1
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 1
82357: NEG
82358: PUSH
82359: LD_INT 0
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: LD_INT 1
82368: NEG
82369: PUSH
82370: LD_INT 1
82372: NEG
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 1
82380: NEG
82381: PUSH
82382: LD_INT 2
82384: NEG
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 0
82392: PUSH
82393: LD_INT 2
82395: NEG
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 1
82403: PUSH
82404: LD_INT 1
82406: NEG
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 2
82414: PUSH
82415: LD_INT 0
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 2
82424: PUSH
82425: LD_INT 1
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 2
82434: PUSH
82435: LD_INT 2
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 1
82444: PUSH
82445: LD_INT 2
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 0
82454: PUSH
82455: LD_INT 2
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: LD_INT 1
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 2
82475: NEG
82476: PUSH
82477: LD_INT 0
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 2
82486: NEG
82487: PUSH
82488: LD_INT 1
82490: NEG
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 2
82498: NEG
82499: PUSH
82500: LD_INT 2
82502: NEG
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: NEG
82511: PUSH
82512: LD_INT 2
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: NEG
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 3
82532: NEG
82533: PUSH
82534: LD_INT 1
82536: NEG
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 3
82544: NEG
82545: PUSH
82546: LD_INT 2
82548: NEG
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82579: LD_ADDR_VAR 0 28
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: LD_INT 0
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 0
82596: PUSH
82597: LD_INT 1
82599: NEG
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 1
82607: PUSH
82608: LD_INT 0
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: PUSH
82618: LD_INT 1
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 0
82627: PUSH
82628: LD_INT 1
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 1
82637: NEG
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: LD_INT 1
82648: NEG
82649: PUSH
82650: LD_INT 1
82652: NEG
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 1
82660: NEG
82661: PUSH
82662: LD_INT 2
82664: NEG
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 0
82672: PUSH
82673: LD_INT 2
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: PUSH
82684: LD_INT 1
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 2
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 2
82704: PUSH
82705: LD_INT 1
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 2
82714: PUSH
82715: LD_INT 2
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 1
82724: PUSH
82725: LD_INT 2
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 0
82734: PUSH
82735: LD_INT 2
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: LD_INT 1
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 2
82755: NEG
82756: PUSH
82757: LD_INT 0
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 2
82766: NEG
82767: PUSH
82768: LD_INT 1
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 2
82778: NEG
82779: PUSH
82780: LD_INT 2
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 2
82790: NEG
82791: PUSH
82792: LD_INT 3
82794: NEG
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: LD_INT 3
82806: NEG
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 3
82814: NEG
82815: PUSH
82816: LD_INT 1
82818: NEG
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 3
82826: NEG
82827: PUSH
82828: LD_INT 2
82830: NEG
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82861: LD_ADDR_VAR 0 29
82865: PUSH
82866: LD_INT 0
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: PUSH
82876: LD_INT 0
82878: PUSH
82879: LD_INT 1
82881: NEG
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 1
82889: PUSH
82890: LD_INT 0
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 1
82899: PUSH
82900: LD_INT 1
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 0
82909: PUSH
82910: LD_INT 1
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 1
82919: NEG
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: NEG
82931: PUSH
82932: LD_INT 1
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: LD_INT 2
82946: NEG
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 2
82976: PUSH
82977: LD_INT 0
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 2
82986: PUSH
82987: LD_INT 1
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: PUSH
82997: LD_INT 2
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 2
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 1
83016: NEG
83017: PUSH
83018: LD_INT 1
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 2
83039: NEG
83040: PUSH
83041: LD_INT 2
83043: NEG
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 2
83051: NEG
83052: PUSH
83053: LD_INT 3
83055: NEG
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 2
83063: PUSH
83064: LD_INT 1
83066: NEG
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 3
83074: PUSH
83075: LD_INT 1
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 1
83084: PUSH
83085: LD_INT 3
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 1
83094: NEG
83095: PUSH
83096: LD_INT 2
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 3
83105: NEG
83106: PUSH
83107: LD_INT 2
83109: NEG
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83140: LD_ADDR_VAR 0 30
83144: PUSH
83145: LD_INT 0
83147: PUSH
83148: LD_INT 0
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 0
83157: PUSH
83158: LD_INT 1
83160: NEG
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 1
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 0
83188: PUSH
83189: LD_INT 1
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 1
83198: NEG
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 1
83209: NEG
83210: PUSH
83211: LD_INT 1
83213: NEG
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 1
83221: NEG
83222: PUSH
83223: LD_INT 2
83225: NEG
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 0
83233: PUSH
83234: LD_INT 2
83236: NEG
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 1
83244: PUSH
83245: LD_INT 1
83247: NEG
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 2
83255: PUSH
83256: LD_INT 0
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: LD_INT 1
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 2
83275: PUSH
83276: LD_INT 2
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 1
83285: PUSH
83286: LD_INT 2
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: LD_INT 1
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 2
83306: NEG
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 1
83329: NEG
83330: PUSH
83331: LD_INT 3
83333: NEG
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 1
83341: PUSH
83342: LD_INT 2
83344: NEG
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 3
83352: PUSH
83353: LD_INT 2
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 2
83362: PUSH
83363: LD_INT 3
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 2
83372: NEG
83373: PUSH
83374: LD_INT 1
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: LD_INT 3
83383: NEG
83384: PUSH
83385: LD_INT 1
83387: NEG
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83418: LD_ADDR_VAR 0 31
83422: PUSH
83423: LD_INT 0
83425: PUSH
83426: LD_INT 0
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 0
83435: PUSH
83436: LD_INT 1
83438: NEG
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: LD_INT 0
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 1
83456: PUSH
83457: LD_INT 1
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 0
83466: PUSH
83467: LD_INT 1
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 1
83476: NEG
83477: PUSH
83478: LD_INT 0
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 1
83487: NEG
83488: PUSH
83489: LD_INT 1
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 1
83499: NEG
83500: PUSH
83501: LD_INT 2
83503: NEG
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: LD_INT 1
83514: NEG
83515: PUSH
83516: EMPTY
83517: LIST
83518: LIST
83519: PUSH
83520: LD_INT 2
83522: PUSH
83523: LD_INT 0
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 2
83532: PUSH
83533: LD_INT 1
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: LD_INT 2
83542: PUSH
83543: LD_INT 2
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 1
83552: PUSH
83553: LD_INT 2
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 0
83562: PUSH
83563: LD_INT 2
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 1
83572: NEG
83573: PUSH
83574: LD_INT 1
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 2
83583: NEG
83584: PUSH
83585: LD_INT 1
83587: NEG
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 2
83595: NEG
83596: PUSH
83597: LD_INT 2
83599: NEG
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 2
83607: NEG
83608: PUSH
83609: LD_INT 3
83611: NEG
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: PUSH
83617: LD_INT 2
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 3
83630: PUSH
83631: LD_INT 1
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: PUSH
83641: LD_INT 3
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 1
83650: NEG
83651: PUSH
83652: LD_INT 2
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 3
83661: NEG
83662: PUSH
83663: LD_INT 2
83665: NEG
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83696: LD_ADDR_VAR 0 32
83700: PUSH
83701: LD_INT 0
83703: PUSH
83704: LD_INT 0
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 0
83713: PUSH
83714: LD_INT 1
83716: NEG
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 1
83724: PUSH
83725: LD_INT 0
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: LD_INT 1
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 0
83744: PUSH
83745: LD_INT 1
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 1
83754: NEG
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 1
83765: NEG
83766: PUSH
83767: LD_INT 1
83769: NEG
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PUSH
83775: LD_INT 1
83777: NEG
83778: PUSH
83779: LD_INT 2
83781: NEG
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 0
83789: PUSH
83790: LD_INT 2
83792: NEG
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 1
83800: PUSH
83801: LD_INT 1
83803: NEG
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 2
83811: PUSH
83812: LD_INT 1
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 2
83821: PUSH
83822: LD_INT 2
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: PUSH
83829: LD_INT 1
83831: PUSH
83832: LD_INT 2
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: PUSH
83839: LD_INT 0
83841: PUSH
83842: LD_INT 2
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: PUSH
83849: LD_INT 1
83851: NEG
83852: PUSH
83853: LD_INT 1
83855: PUSH
83856: EMPTY
83857: LIST
83858: LIST
83859: PUSH
83860: LD_INT 2
83862: NEG
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 2
83873: NEG
83874: PUSH
83875: LD_INT 1
83877: NEG
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 1
83885: NEG
83886: PUSH
83887: LD_INT 3
83889: NEG
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 1
83897: PUSH
83898: LD_INT 2
83900: NEG
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 3
83908: PUSH
83909: LD_INT 2
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 2
83918: PUSH
83919: LD_INT 3
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PUSH
83930: LD_INT 1
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: LD_INT 3
83939: NEG
83940: PUSH
83941: LD_INT 1
83943: NEG
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83974: LD_ADDR_VAR 0 33
83978: PUSH
83979: LD_INT 0
83981: PUSH
83982: LD_INT 0
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: LD_INT 1
83994: NEG
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 1
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: LD_INT 1
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 0
84022: PUSH
84023: LD_INT 1
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 1
84032: NEG
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 1
84043: NEG
84044: PUSH
84045: LD_INT 1
84047: NEG
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: PUSH
84053: LD_INT 1
84055: NEG
84056: PUSH
84057: LD_INT 2
84059: NEG
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 1
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 2
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 2
84088: PUSH
84089: LD_INT 1
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 1
84098: PUSH
84099: LD_INT 2
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 0
84108: PUSH
84109: LD_INT 2
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: PUSH
84116: LD_INT 1
84118: NEG
84119: PUSH
84120: LD_INT 1
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 2
84129: NEG
84130: PUSH
84131: LD_INT 0
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 2
84140: NEG
84141: PUSH
84142: LD_INT 1
84144: NEG
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 2
84152: NEG
84153: PUSH
84154: LD_INT 2
84156: NEG
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 2
84164: NEG
84165: PUSH
84166: LD_INT 3
84168: NEG
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 2
84176: PUSH
84177: LD_INT 1
84179: NEG
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: PUSH
84185: LD_INT 3
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: LD_INT 3
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: LD_INT 2
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 3
84218: NEG
84219: PUSH
84220: LD_INT 2
84222: NEG
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: LIST
84252: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84253: LD_ADDR_VAR 0 34
84257: PUSH
84258: LD_INT 0
84260: PUSH
84261: LD_INT 0
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: PUSH
84268: LD_INT 0
84270: PUSH
84271: LD_INT 1
84273: NEG
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 1
84281: PUSH
84282: LD_INT 0
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 1
84291: PUSH
84292: LD_INT 1
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 0
84301: PUSH
84302: LD_INT 1
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 1
84311: NEG
84312: PUSH
84313: LD_INT 0
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: LD_INT 1
84326: NEG
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 1
84334: NEG
84335: PUSH
84336: LD_INT 2
84338: NEG
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: LD_INT 2
84349: NEG
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 1
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 2
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 2
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 1
84398: NEG
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: LD_INT 2
84409: NEG
84410: PUSH
84411: LD_INT 0
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 2
84420: NEG
84421: PUSH
84422: LD_INT 1
84424: NEG
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 2
84432: NEG
84433: PUSH
84434: LD_INT 2
84436: NEG
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 1
84444: NEG
84445: PUSH
84446: LD_INT 3
84448: NEG
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 1
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 3
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 2
84477: PUSH
84478: LD_INT 3
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 2
84487: NEG
84488: PUSH
84489: LD_INT 1
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 3
84498: NEG
84499: PUSH
84500: LD_INT 1
84502: NEG
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84533: LD_ADDR_VAR 0 35
84537: PUSH
84538: LD_INT 0
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: LD_INT 1
84553: NEG
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 1
84561: PUSH
84562: LD_INT 0
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 1
84571: PUSH
84572: LD_INT 1
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 0
84581: PUSH
84582: LD_INT 1
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 1
84591: NEG
84592: PUSH
84593: LD_INT 0
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 1
84602: NEG
84603: PUSH
84604: LD_INT 1
84606: NEG
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 2
84614: PUSH
84615: LD_INT 1
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: PUSH
84622: LD_INT 2
84624: NEG
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84645: LD_ADDR_VAR 0 36
84649: PUSH
84650: LD_INT 0
84652: PUSH
84653: LD_INT 0
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 0
84662: PUSH
84663: LD_INT 1
84665: NEG
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: PUSH
84684: LD_INT 1
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: LD_INT 1
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 1
84703: NEG
84704: PUSH
84705: LD_INT 0
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 1
84714: NEG
84715: PUSH
84716: LD_INT 1
84718: NEG
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 1
84726: NEG
84727: PUSH
84728: LD_INT 2
84730: NEG
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 1
84738: PUSH
84739: LD_INT 2
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84757: LD_ADDR_VAR 0 37
84761: PUSH
84762: LD_INT 0
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 0
84774: PUSH
84775: LD_INT 1
84777: NEG
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 1
84785: PUSH
84786: LD_INT 0
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 1
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 0
84805: PUSH
84806: LD_INT 1
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 1
84815: NEG
84816: PUSH
84817: LD_INT 0
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 1
84826: NEG
84827: PUSH
84828: LD_INT 1
84830: NEG
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: PUSH
84839: LD_INT 1
84841: NEG
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 1
84849: NEG
84850: PUSH
84851: LD_INT 1
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84869: LD_ADDR_VAR 0 38
84873: PUSH
84874: LD_INT 0
84876: PUSH
84877: LD_INT 0
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 0
84886: PUSH
84887: LD_INT 1
84889: NEG
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: LD_INT 0
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: PUSH
84908: LD_INT 1
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 0
84917: PUSH
84918: LD_INT 1
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: NEG
84928: PUSH
84929: LD_INT 0
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: PUSH
84936: LD_INT 1
84938: NEG
84939: PUSH
84940: LD_INT 1
84942: NEG
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 2
84950: PUSH
84951: LD_INT 1
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PUSH
84958: LD_INT 2
84960: NEG
84961: PUSH
84962: LD_INT 1
84964: NEG
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84981: LD_ADDR_VAR 0 39
84985: PUSH
84986: LD_INT 0
84988: PUSH
84989: LD_INT 0
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 0
84998: PUSH
84999: LD_INT 1
85001: NEG
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 1
85009: PUSH
85010: LD_INT 0
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 0
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 1
85039: NEG
85040: PUSH
85041: LD_INT 0
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: LD_INT 1
85054: NEG
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 1
85062: NEG
85063: PUSH
85064: LD_INT 2
85066: NEG
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 1
85074: PUSH
85075: LD_INT 2
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85093: LD_ADDR_VAR 0 40
85097: PUSH
85098: LD_INT 0
85100: PUSH
85101: LD_INT 0
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: PUSH
85108: LD_INT 0
85110: PUSH
85111: LD_INT 1
85113: NEG
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 1
85121: PUSH
85122: LD_INT 0
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: PUSH
85132: LD_INT 1
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 0
85141: PUSH
85142: LD_INT 1
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 1
85151: NEG
85152: PUSH
85153: LD_INT 0
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: NEG
85163: PUSH
85164: LD_INT 1
85166: NEG
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 1
85174: PUSH
85175: LD_INT 1
85177: NEG
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 1
85185: NEG
85186: PUSH
85187: LD_INT 1
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85205: LD_ADDR_VAR 0 41
85209: PUSH
85210: LD_INT 0
85212: PUSH
85213: LD_INT 0
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 0
85222: PUSH
85223: LD_INT 1
85225: NEG
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: PUSH
85234: LD_INT 0
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 1
85243: PUSH
85244: LD_INT 1
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 0
85253: PUSH
85254: LD_INT 1
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: LD_INT 1
85263: NEG
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: PUSH
85272: LD_INT 1
85274: NEG
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: LD_INT 2
85290: NEG
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: PUSH
85299: LD_INT 1
85301: NEG
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 2
85309: PUSH
85310: LD_INT 0
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: PUSH
85317: LD_INT 2
85319: PUSH
85320: LD_INT 1
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 2
85329: PUSH
85330: LD_INT 2
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PUSH
85337: LD_INT 1
85339: PUSH
85340: LD_INT 2
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: PUSH
85347: LD_INT 1
85349: NEG
85350: PUSH
85351: LD_INT 1
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 2
85360: NEG
85361: PUSH
85362: LD_INT 0
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 2
85371: NEG
85372: PUSH
85373: LD_INT 1
85375: NEG
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 2
85383: NEG
85384: PUSH
85385: LD_INT 2
85387: NEG
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 2
85395: NEG
85396: PUSH
85397: LD_INT 3
85399: NEG
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 2
85407: PUSH
85408: LD_INT 1
85410: NEG
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 3
85418: PUSH
85419: LD_INT 0
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 3
85428: PUSH
85429: LD_INT 1
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: LD_INT 3
85438: PUSH
85439: LD_INT 2
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 3
85448: PUSH
85449: LD_INT 3
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: PUSH
85456: LD_INT 2
85458: PUSH
85459: LD_INT 3
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PUSH
85466: LD_INT 2
85468: NEG
85469: PUSH
85470: LD_INT 1
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 3
85479: NEG
85480: PUSH
85481: LD_INT 0
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 3
85490: NEG
85491: PUSH
85492: LD_INT 1
85494: NEG
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 3
85502: NEG
85503: PUSH
85504: LD_INT 2
85506: NEG
85507: PUSH
85508: EMPTY
85509: LIST
85510: LIST
85511: PUSH
85512: LD_INT 3
85514: NEG
85515: PUSH
85516: LD_INT 3
85518: NEG
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85555: LD_ADDR_VAR 0 42
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 0
85572: PUSH
85573: LD_INT 1
85575: NEG
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 1
85583: PUSH
85584: LD_INT 0
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: LD_INT 1
85593: PUSH
85594: LD_INT 1
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: LD_INT 1
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 1
85624: NEG
85625: PUSH
85626: LD_INT 1
85628: NEG
85629: PUSH
85630: EMPTY
85631: LIST
85632: LIST
85633: PUSH
85634: LD_INT 1
85636: NEG
85637: PUSH
85638: LD_INT 2
85640: NEG
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: LD_INT 2
85651: NEG
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 1
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 2
85670: PUSH
85671: LD_INT 1
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 2
85680: PUSH
85681: LD_INT 2
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: PUSH
85691: LD_INT 2
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: LD_INT 2
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: LD_INT 1
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 2
85721: NEG
85722: PUSH
85723: LD_INT 1
85725: NEG
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 2
85733: NEG
85734: PUSH
85735: LD_INT 2
85737: NEG
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 2
85745: NEG
85746: PUSH
85747: LD_INT 3
85749: NEG
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: PUSH
85755: LD_INT 1
85757: NEG
85758: PUSH
85759: LD_INT 3
85761: NEG
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 0
85769: PUSH
85770: LD_INT 3
85772: NEG
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 1
85780: PUSH
85781: LD_INT 2
85783: NEG
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 3
85791: PUSH
85792: LD_INT 2
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 3
85801: PUSH
85802: LD_INT 3
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 2
85811: PUSH
85812: LD_INT 3
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 1
85821: PUSH
85822: LD_INT 3
85824: PUSH
85825: EMPTY
85826: LIST
85827: LIST
85828: PUSH
85829: LD_INT 0
85831: PUSH
85832: LD_INT 3
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: PUSH
85839: LD_INT 1
85841: NEG
85842: PUSH
85843: LD_INT 2
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 3
85852: NEG
85853: PUSH
85854: LD_INT 2
85856: NEG
85857: PUSH
85858: EMPTY
85859: LIST
85860: LIST
85861: PUSH
85862: LD_INT 3
85864: NEG
85865: PUSH
85866: LD_INT 3
85868: NEG
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85905: LD_ADDR_VAR 0 43
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: LD_INT 0
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 1
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 1
85963: NEG
85964: PUSH
85965: LD_INT 0
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: NEG
85975: PUSH
85976: LD_INT 1
85978: NEG
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 1
85986: NEG
85987: PUSH
85988: LD_INT 2
85990: NEG
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 0
85998: PUSH
85999: LD_INT 2
86001: NEG
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 1
86009: PUSH
86010: LD_INT 1
86012: NEG
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 2
86020: PUSH
86021: LD_INT 0
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: LD_INT 2
86030: PUSH
86031: LD_INT 1
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 1
86040: PUSH
86041: LD_INT 2
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 0
86050: PUSH
86051: LD_INT 2
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 1
86060: NEG
86061: PUSH
86062: LD_INT 1
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PUSH
86069: LD_INT 2
86071: NEG
86072: PUSH
86073: LD_INT 0
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 2
86082: NEG
86083: PUSH
86084: LD_INT 1
86086: NEG
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 1
86094: NEG
86095: PUSH
86096: LD_INT 3
86098: NEG
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: LD_INT 0
86106: PUSH
86107: LD_INT 3
86109: NEG
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 1
86117: PUSH
86118: LD_INT 2
86120: NEG
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 2
86128: PUSH
86129: LD_INT 1
86131: NEG
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 3
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 3
86149: PUSH
86150: LD_INT 1
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: PUSH
86160: LD_INT 3
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: LD_INT 3
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 1
86179: NEG
86180: PUSH
86181: LD_INT 2
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 2
86190: NEG
86191: PUSH
86192: LD_INT 1
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: LD_INT 3
86201: NEG
86202: PUSH
86203: LD_INT 0
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: PUSH
86210: LD_INT 3
86212: NEG
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86253: LD_ADDR_VAR 0 44
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: LD_INT 1
86273: NEG
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 1
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: LD_INT 0
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 1
86322: NEG
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: LD_INT 2
86338: NEG
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 1
86346: PUSH
86347: LD_INT 1
86349: NEG
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 2
86357: PUSH
86358: LD_INT 0
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 2
86367: PUSH
86368: LD_INT 1
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 2
86377: PUSH
86378: LD_INT 2
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 1
86387: PUSH
86388: LD_INT 2
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 2
86408: NEG
86409: PUSH
86410: LD_INT 0
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 2
86419: NEG
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 2
86431: NEG
86432: PUSH
86433: LD_INT 2
86435: NEG
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 2
86443: NEG
86444: PUSH
86445: LD_INT 3
86447: NEG
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 2
86455: PUSH
86456: LD_INT 1
86458: NEG
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 3
86466: PUSH
86467: LD_INT 0
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 3
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 3
86486: PUSH
86487: LD_INT 2
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: PUSH
86494: LD_INT 3
86496: PUSH
86497: LD_INT 3
86499: PUSH
86500: EMPTY
86501: LIST
86502: LIST
86503: PUSH
86504: LD_INT 2
86506: PUSH
86507: LD_INT 3
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 2
86516: NEG
86517: PUSH
86518: LD_INT 1
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 3
86527: NEG
86528: PUSH
86529: LD_INT 0
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 3
86538: NEG
86539: PUSH
86540: LD_INT 1
86542: NEG
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 3
86550: NEG
86551: PUSH
86552: LD_INT 2
86554: NEG
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: LD_INT 3
86562: NEG
86563: PUSH
86564: LD_INT 3
86566: NEG
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86603: LD_ADDR_VAR 0 45
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: LD_INT 1
86623: NEG
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 1
86631: PUSH
86632: LD_INT 0
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 1
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: LD_INT 1
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 1
86661: NEG
86662: PUSH
86663: LD_INT 0
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 1
86672: NEG
86673: PUSH
86674: LD_INT 1
86676: NEG
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 1
86684: NEG
86685: PUSH
86686: LD_INT 2
86688: NEG
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 0
86696: PUSH
86697: LD_INT 2
86699: NEG
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 1
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 2
86718: PUSH
86719: LD_INT 1
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 2
86728: PUSH
86729: LD_INT 2
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: LD_INT 2
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 0
86748: PUSH
86749: LD_INT 2
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: LD_INT 1
86773: NEG
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 2
86781: NEG
86782: PUSH
86783: LD_INT 2
86785: NEG
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 2
86793: NEG
86794: PUSH
86795: LD_INT 3
86797: NEG
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 1
86805: NEG
86806: PUSH
86807: LD_INT 3
86809: NEG
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 0
86817: PUSH
86818: LD_INT 3
86820: NEG
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: LD_INT 2
86831: NEG
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 3
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 3
86849: PUSH
86850: LD_INT 3
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 2
86859: PUSH
86860: LD_INT 3
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: PUSH
86870: LD_INT 3
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 0
86879: PUSH
86880: LD_INT 3
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PUSH
86887: LD_INT 1
86889: NEG
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 3
86900: NEG
86901: PUSH
86902: LD_INT 2
86904: NEG
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: LD_INT 3
86916: NEG
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86953: LD_ADDR_VAR 0 46
86957: PUSH
86958: LD_INT 0
86960: PUSH
86961: LD_INT 0
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 0
86970: PUSH
86971: LD_INT 1
86973: NEG
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 1
86981: PUSH
86982: LD_INT 0
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 1
86991: PUSH
86992: LD_INT 1
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 0
87001: PUSH
87002: LD_INT 1
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 1
87011: NEG
87012: PUSH
87013: LD_INT 0
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: LD_INT 1
87022: NEG
87023: PUSH
87024: LD_INT 1
87026: NEG
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PUSH
87032: LD_INT 1
87034: NEG
87035: PUSH
87036: LD_INT 2
87038: NEG
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: LD_INT 2
87049: NEG
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 1
87057: PUSH
87058: LD_INT 1
87060: NEG
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 2
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 2
87078: PUSH
87079: LD_INT 1
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 1
87088: PUSH
87089: LD_INT 2
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: LD_INT 2
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: LD_INT 1
87108: NEG
87109: PUSH
87110: LD_INT 1
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 2
87119: NEG
87120: PUSH
87121: LD_INT 0
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: LD_INT 2
87130: NEG
87131: PUSH
87132: LD_INT 1
87134: NEG
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: NEG
87143: PUSH
87144: LD_INT 3
87146: NEG
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: LD_INT 3
87157: NEG
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 1
87165: PUSH
87166: LD_INT 2
87168: NEG
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 2
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 3
87187: PUSH
87188: LD_INT 0
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 3
87197: PUSH
87198: LD_INT 1
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 1
87207: PUSH
87208: LD_INT 3
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 0
87217: PUSH
87218: LD_INT 3
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 1
87227: NEG
87228: PUSH
87229: LD_INT 2
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 2
87238: NEG
87239: PUSH
87240: LD_INT 1
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 3
87249: NEG
87250: PUSH
87251: LD_INT 0
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PUSH
87258: LD_INT 3
87260: NEG
87261: PUSH
87262: LD_INT 1
87264: NEG
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: LIST
87291: LIST
87292: LIST
87293: LIST
87294: LIST
87295: LIST
87296: LIST
87297: LIST
87298: LIST
87299: LIST
87300: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87301: LD_ADDR_VAR 0 47
87305: PUSH
87306: LD_INT 0
87308: PUSH
87309: LD_INT 0
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 0
87318: PUSH
87319: LD_INT 1
87321: NEG
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 1
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: LD_INT 1
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 1
87359: NEG
87360: PUSH
87361: LD_INT 0
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 1
87370: NEG
87371: PUSH
87372: LD_INT 1
87374: NEG
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 1
87382: NEG
87383: PUSH
87384: LD_INT 2
87386: NEG
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 0
87394: PUSH
87395: LD_INT 2
87397: NEG
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 1
87405: PUSH
87406: LD_INT 1
87408: NEG
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: LD_INT 2
87416: NEG
87417: PUSH
87418: LD_INT 1
87420: NEG
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 2
87428: NEG
87429: PUSH
87430: LD_INT 2
87432: NEG
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87452: LD_ADDR_VAR 0 48
87456: PUSH
87457: LD_INT 0
87459: PUSH
87460: LD_INT 0
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 0
87469: PUSH
87470: LD_INT 1
87472: NEG
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 1
87480: PUSH
87481: LD_INT 0
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: PUSH
87488: LD_INT 1
87490: PUSH
87491: LD_INT 1
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 0
87500: PUSH
87501: LD_INT 1
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 1
87510: NEG
87511: PUSH
87512: LD_INT 0
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: LD_INT 1
87521: NEG
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 1
87533: NEG
87534: PUSH
87535: LD_INT 2
87537: NEG
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: PUSH
87543: LD_INT 0
87545: PUSH
87546: LD_INT 2
87548: NEG
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: PUSH
87554: LD_INT 1
87556: PUSH
87557: LD_INT 1
87559: NEG
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 2
87567: PUSH
87568: LD_INT 0
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: PUSH
87575: LD_INT 2
87577: PUSH
87578: LD_INT 1
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87599: LD_ADDR_VAR 0 49
87603: PUSH
87604: LD_INT 0
87606: PUSH
87607: LD_INT 0
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PUSH
87614: LD_INT 0
87616: PUSH
87617: LD_INT 1
87619: NEG
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 1
87627: PUSH
87628: LD_INT 0
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 1
87637: PUSH
87638: LD_INT 1
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 0
87647: PUSH
87648: LD_INT 1
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 1
87657: NEG
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 1
87668: NEG
87669: PUSH
87670: LD_INT 1
87672: NEG
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: LD_INT 1
87680: PUSH
87681: LD_INT 1
87683: NEG
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 2
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 2
87701: PUSH
87702: LD_INT 1
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 2
87711: PUSH
87712: LD_INT 2
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 1
87721: PUSH
87722: LD_INT 2
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87743: LD_ADDR_VAR 0 50
87747: PUSH
87748: LD_INT 0
87750: PUSH
87751: LD_INT 0
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: LD_INT 1
87763: NEG
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 1
87771: PUSH
87772: LD_INT 0
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 1
87781: PUSH
87782: LD_INT 1
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 0
87791: PUSH
87792: LD_INT 1
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: LD_INT 1
87801: NEG
87802: PUSH
87803: LD_INT 0
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 1
87812: NEG
87813: PUSH
87814: LD_INT 1
87816: NEG
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 2
87824: PUSH
87825: LD_INT 1
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 2
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: PUSH
87842: LD_INT 1
87844: PUSH
87845: LD_INT 2
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: LD_INT 2
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 1
87864: NEG
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87887: LD_ADDR_VAR 0 51
87891: PUSH
87892: LD_INT 0
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: LD_INT 1
87907: NEG
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 1
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: LD_INT 1
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: PUSH
87933: LD_INT 0
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 1
87945: NEG
87946: PUSH
87947: LD_INT 0
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: LD_INT 1
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 1
87968: PUSH
87969: LD_INT 2
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 0
87978: PUSH
87979: LD_INT 2
87981: PUSH
87982: EMPTY
87983: LIST
87984: LIST
87985: PUSH
87986: LD_INT 1
87988: NEG
87989: PUSH
87990: LD_INT 1
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 2
87999: NEG
88000: PUSH
88001: LD_INT 0
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 2
88010: NEG
88011: PUSH
88012: LD_INT 1
88014: NEG
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88034: LD_ADDR_VAR 0 52
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 0
88051: PUSH
88052: LD_INT 1
88054: NEG
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 1
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 1
88072: PUSH
88073: LD_INT 1
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: LD_INT 1
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 1
88103: NEG
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 1
88115: NEG
88116: PUSH
88117: LD_INT 2
88119: NEG
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 1
88127: NEG
88128: PUSH
88129: LD_INT 1
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 2
88138: NEG
88139: PUSH
88140: LD_INT 0
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 2
88149: NEG
88150: PUSH
88151: LD_INT 1
88153: NEG
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 2
88161: NEG
88162: PUSH
88163: LD_INT 2
88165: NEG
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88185: LD_ADDR_VAR 0 53
88189: PUSH
88190: LD_INT 0
88192: PUSH
88193: LD_INT 0
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: PUSH
88200: LD_INT 0
88202: PUSH
88203: LD_INT 1
88205: NEG
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 1
88213: PUSH
88214: LD_INT 0
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 1
88223: PUSH
88224: LD_INT 1
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: PUSH
88231: LD_INT 0
88233: PUSH
88234: LD_INT 1
88236: PUSH
88237: EMPTY
88238: LIST
88239: LIST
88240: PUSH
88241: LD_INT 1
88243: NEG
88244: PUSH
88245: LD_INT 0
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: PUSH
88256: LD_INT 1
88258: NEG
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 1
88266: NEG
88267: PUSH
88268: LD_INT 2
88270: NEG
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 0
88278: PUSH
88279: LD_INT 2
88281: NEG
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 1
88289: PUSH
88290: LD_INT 1
88292: NEG
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 2
88300: PUSH
88301: LD_INT 0
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 2
88310: PUSH
88311: LD_INT 1
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 2
88320: PUSH
88321: LD_INT 2
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 1
88330: PUSH
88331: LD_INT 2
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: PUSH
88338: LD_INT 0
88340: PUSH
88341: LD_INT 2
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 1
88350: NEG
88351: PUSH
88352: LD_INT 1
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 2
88361: NEG
88362: PUSH
88363: LD_INT 0
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 2
88372: NEG
88373: PUSH
88374: LD_INT 1
88376: NEG
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 2
88384: NEG
88385: PUSH
88386: LD_INT 2
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88415: LD_ADDR_VAR 0 54
88419: PUSH
88420: LD_INT 0
88422: PUSH
88423: LD_INT 0
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 0
88432: PUSH
88433: LD_INT 1
88435: NEG
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 1
88443: PUSH
88444: LD_INT 0
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 1
88453: PUSH
88454: LD_INT 1
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 0
88463: PUSH
88464: LD_INT 1
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 1
88473: NEG
88474: PUSH
88475: LD_INT 0
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 1
88484: NEG
88485: PUSH
88486: LD_INT 1
88488: NEG
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 1
88496: NEG
88497: PUSH
88498: LD_INT 2
88500: NEG
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 0
88508: PUSH
88509: LD_INT 2
88511: NEG
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: LD_INT 1
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: PUSH
88531: LD_INT 0
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 2
88540: PUSH
88541: LD_INT 1
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 2
88550: PUSH
88551: LD_INT 2
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: PUSH
88561: LD_INT 2
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 0
88570: PUSH
88571: LD_INT 2
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: LD_INT 1
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 2
88591: NEG
88592: PUSH
88593: LD_INT 0
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 2
88602: NEG
88603: PUSH
88604: LD_INT 1
88606: NEG
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: PUSH
88612: LD_INT 2
88614: NEG
88615: PUSH
88616: LD_INT 2
88618: NEG
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88645: LD_ADDR_VAR 0 55
88649: PUSH
88650: LD_INT 0
88652: PUSH
88653: LD_INT 0
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 0
88662: PUSH
88663: LD_INT 1
88665: NEG
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 1
88673: PUSH
88674: LD_INT 0
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 1
88683: PUSH
88684: LD_INT 1
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: LD_INT 1
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: PUSH
88701: LD_INT 1
88703: NEG
88704: PUSH
88705: LD_INT 0
88707: PUSH
88708: EMPTY
88709: LIST
88710: LIST
88711: PUSH
88712: LD_INT 1
88714: NEG
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 1
88726: NEG
88727: PUSH
88728: LD_INT 2
88730: NEG
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: LD_INT 2
88741: NEG
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 1
88749: PUSH
88750: LD_INT 1
88752: NEG
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 2
88760: PUSH
88761: LD_INT 0
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 2
88770: PUSH
88771: LD_INT 1
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 2
88780: PUSH
88781: LD_INT 2
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: LD_INT 1
88790: PUSH
88791: LD_INT 2
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 0
88800: PUSH
88801: LD_INT 2
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 1
88810: NEG
88811: PUSH
88812: LD_INT 1
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 2
88821: NEG
88822: PUSH
88823: LD_INT 0
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 2
88832: NEG
88833: PUSH
88834: LD_INT 1
88836: NEG
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: PUSH
88842: LD_INT 2
88844: NEG
88845: PUSH
88846: LD_INT 2
88848: NEG
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88875: LD_ADDR_VAR 0 56
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: LD_INT 0
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: LD_INT 1
88895: NEG
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: PUSH
88904: LD_INT 0
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 1
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: LD_INT 1
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: LD_INT 0
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: PUSH
88942: LD_INT 1
88944: NEG
88945: PUSH
88946: LD_INT 1
88948: NEG
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 1
88956: NEG
88957: PUSH
88958: LD_INT 2
88960: NEG
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: LD_INT 2
88971: NEG
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 1
88979: PUSH
88980: LD_INT 1
88982: NEG
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 2
88990: PUSH
88991: LD_INT 0
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 2
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: LD_INT 2
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: PUSH
89021: LD_INT 2
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 0
89030: PUSH
89031: LD_INT 2
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 1
89040: NEG
89041: PUSH
89042: LD_INT 1
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: NEG
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 2
89062: NEG
89063: PUSH
89064: LD_INT 1
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 2
89074: NEG
89075: PUSH
89076: LD_INT 2
89078: NEG
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89105: LD_ADDR_VAR 0 57
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: LD_INT 1
89125: NEG
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 1
89133: PUSH
89134: LD_INT 0
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 1
89143: PUSH
89144: LD_INT 1
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: LD_INT 1
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 1
89163: NEG
89164: PUSH
89165: LD_INT 0
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: NEG
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 1
89186: NEG
89187: PUSH
89188: LD_INT 2
89190: NEG
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: LD_INT 2
89201: NEG
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 1
89209: PUSH
89210: LD_INT 1
89212: NEG
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 2
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 2
89230: PUSH
89231: LD_INT 1
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: LD_INT 2
89240: PUSH
89241: LD_INT 2
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: LD_INT 2
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 0
89260: PUSH
89261: LD_INT 2
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 1
89270: NEG
89271: PUSH
89272: LD_INT 1
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 2
89281: NEG
89282: PUSH
89283: LD_INT 0
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 2
89292: NEG
89293: PUSH
89294: LD_INT 1
89296: NEG
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 2
89304: NEG
89305: PUSH
89306: LD_INT 2
89308: NEG
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89335: LD_ADDR_VAR 0 58
89339: PUSH
89340: LD_INT 0
89342: PUSH
89343: LD_INT 0
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 0
89352: PUSH
89353: LD_INT 1
89355: NEG
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 1
89363: PUSH
89364: LD_INT 0
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 1
89373: PUSH
89374: LD_INT 1
89376: PUSH
89377: EMPTY
89378: LIST
89379: LIST
89380: PUSH
89381: LD_INT 0
89383: PUSH
89384: LD_INT 1
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: LD_INT 1
89393: NEG
89394: PUSH
89395: LD_INT 0
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: PUSH
89402: LD_INT 1
89404: NEG
89405: PUSH
89406: LD_INT 1
89408: NEG
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: PUSH
89414: LD_INT 1
89416: NEG
89417: PUSH
89418: LD_INT 2
89420: NEG
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 0
89428: PUSH
89429: LD_INT 2
89431: NEG
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 1
89439: PUSH
89440: LD_INT 1
89442: NEG
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 2
89450: PUSH
89451: LD_INT 0
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 2
89460: PUSH
89461: LD_INT 1
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 2
89470: PUSH
89471: LD_INT 2
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: LD_INT 2
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 0
89490: PUSH
89491: LD_INT 2
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: LD_INT 1
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 2
89511: NEG
89512: PUSH
89513: LD_INT 0
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 2
89522: NEG
89523: PUSH
89524: LD_INT 1
89526: NEG
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 2
89534: NEG
89535: PUSH
89536: LD_INT 2
89538: NEG
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89565: LD_ADDR_VAR 0 59
89569: PUSH
89570: LD_INT 0
89572: PUSH
89573: LD_INT 0
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 0
89582: PUSH
89583: LD_INT 1
89585: NEG
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 1
89593: PUSH
89594: LD_INT 0
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 1
89603: PUSH
89604: LD_INT 1
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 1
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 1
89623: NEG
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 1
89634: NEG
89635: PUSH
89636: LD_INT 1
89638: NEG
89639: PUSH
89640: EMPTY
89641: LIST
89642: LIST
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89653: LD_ADDR_VAR 0 60
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: LD_INT 0
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 0
89670: PUSH
89671: LD_INT 1
89673: NEG
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 1
89681: PUSH
89682: LD_INT 0
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: LD_INT 1
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 0
89701: PUSH
89702: LD_INT 1
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 1
89711: NEG
89712: PUSH
89713: LD_INT 0
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 1
89722: NEG
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89741: LD_ADDR_VAR 0 61
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: LD_INT 0
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 0
89758: PUSH
89759: LD_INT 1
89761: NEG
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 1
89769: PUSH
89770: LD_INT 0
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 1
89779: PUSH
89780: LD_INT 1
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 0
89789: PUSH
89790: LD_INT 1
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 1
89799: NEG
89800: PUSH
89801: LD_INT 0
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 1
89810: NEG
89811: PUSH
89812: LD_INT 1
89814: NEG
89815: PUSH
89816: EMPTY
89817: LIST
89818: LIST
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89829: LD_ADDR_VAR 0 62
89833: PUSH
89834: LD_INT 0
89836: PUSH
89837: LD_INT 0
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 0
89846: PUSH
89847: LD_INT 1
89849: NEG
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 1
89857: PUSH
89858: LD_INT 0
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 1
89867: PUSH
89868: LD_INT 1
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 0
89877: PUSH
89878: LD_INT 1
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: LD_INT 1
89887: NEG
89888: PUSH
89889: LD_INT 0
89891: PUSH
89892: EMPTY
89893: LIST
89894: LIST
89895: PUSH
89896: LD_INT 1
89898: NEG
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89917: LD_ADDR_VAR 0 63
89921: PUSH
89922: LD_INT 0
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 0
89934: PUSH
89935: LD_INT 1
89937: NEG
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 1
89945: PUSH
89946: LD_INT 0
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: LD_INT 1
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 0
89965: PUSH
89966: LD_INT 1
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 1
89975: NEG
89976: PUSH
89977: LD_INT 0
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: LD_INT 1
89990: NEG
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90005: LD_ADDR_VAR 0 64
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: LD_INT 0
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: LD_INT 1
90025: NEG
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: LD_INT 0
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 1
90043: PUSH
90044: LD_INT 1
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 0
90053: PUSH
90054: LD_INT 1
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 1
90063: NEG
90064: PUSH
90065: LD_INT 0
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 1
90074: NEG
90075: PUSH
90076: LD_INT 1
90078: NEG
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: ST_TO_ADDR
// end ; 1 :
90093: GO 95990
90095: LD_INT 1
90097: DOUBLE
90098: EQUAL
90099: IFTRUE 90103
90101: GO 92726
90103: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90104: LD_ADDR_VAR 0 11
90108: PUSH
90109: LD_INT 1
90111: NEG
90112: PUSH
90113: LD_INT 3
90115: NEG
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 0
90123: PUSH
90124: LD_INT 3
90126: NEG
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 1
90134: PUSH
90135: LD_INT 2
90137: NEG
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: LIST
90147: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90148: LD_ADDR_VAR 0 12
90152: PUSH
90153: LD_INT 2
90155: PUSH
90156: LD_INT 1
90158: NEG
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 3
90166: PUSH
90167: LD_INT 0
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 3
90176: PUSH
90177: LD_INT 1
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: LIST
90188: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90189: LD_ADDR_VAR 0 13
90193: PUSH
90194: LD_INT 3
90196: PUSH
90197: LD_INT 2
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 3
90206: PUSH
90207: LD_INT 3
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 2
90216: PUSH
90217: LD_INT 3
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: LIST
90228: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90229: LD_ADDR_VAR 0 14
90233: PUSH
90234: LD_INT 1
90236: PUSH
90237: LD_INT 3
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 0
90246: PUSH
90247: LD_INT 3
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 1
90256: NEG
90257: PUSH
90258: LD_INT 2
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: LIST
90269: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90270: LD_ADDR_VAR 0 15
90274: PUSH
90275: LD_INT 2
90277: NEG
90278: PUSH
90279: LD_INT 1
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: PUSH
90286: LD_INT 3
90288: NEG
90289: PUSH
90290: LD_INT 0
90292: PUSH
90293: EMPTY
90294: LIST
90295: LIST
90296: PUSH
90297: LD_INT 3
90299: NEG
90300: PUSH
90301: LD_INT 1
90303: NEG
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: LIST
90313: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90314: LD_ADDR_VAR 0 16
90318: PUSH
90319: LD_INT 2
90321: NEG
90322: PUSH
90323: LD_INT 3
90325: NEG
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 3
90333: NEG
90334: PUSH
90335: LD_INT 2
90337: NEG
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 3
90345: NEG
90346: PUSH
90347: LD_INT 3
90349: NEG
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: LIST
90359: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90360: LD_ADDR_VAR 0 17
90364: PUSH
90365: LD_INT 1
90367: NEG
90368: PUSH
90369: LD_INT 3
90371: NEG
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 0
90379: PUSH
90380: LD_INT 3
90382: NEG
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 1
90390: PUSH
90391: LD_INT 2
90393: NEG
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: LIST
90403: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90404: LD_ADDR_VAR 0 18
90408: PUSH
90409: LD_INT 2
90411: PUSH
90412: LD_INT 1
90414: NEG
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 3
90422: PUSH
90423: LD_INT 0
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 3
90432: PUSH
90433: LD_INT 1
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: PUSH
90440: EMPTY
90441: LIST
90442: LIST
90443: LIST
90444: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90445: LD_ADDR_VAR 0 19
90449: PUSH
90450: LD_INT 3
90452: PUSH
90453: LD_INT 2
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: LD_INT 3
90462: PUSH
90463: LD_INT 3
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 2
90472: PUSH
90473: LD_INT 3
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: LIST
90484: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90485: LD_ADDR_VAR 0 20
90489: PUSH
90490: LD_INT 1
90492: PUSH
90493: LD_INT 3
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 0
90502: PUSH
90503: LD_INT 3
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: LD_INT 1
90512: NEG
90513: PUSH
90514: LD_INT 2
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: LIST
90525: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90526: LD_ADDR_VAR 0 21
90530: PUSH
90531: LD_INT 2
90533: NEG
90534: PUSH
90535: LD_INT 1
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 3
90544: NEG
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 3
90555: NEG
90556: PUSH
90557: LD_INT 1
90559: NEG
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: LIST
90569: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90570: LD_ADDR_VAR 0 22
90574: PUSH
90575: LD_INT 2
90577: NEG
90578: PUSH
90579: LD_INT 3
90581: NEG
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: LD_INT 3
90589: NEG
90590: PUSH
90591: LD_INT 2
90593: NEG
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 3
90601: NEG
90602: PUSH
90603: LD_INT 3
90605: NEG
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: LIST
90615: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90616: LD_ADDR_VAR 0 23
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: LD_INT 3
90626: NEG
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 1
90634: NEG
90635: PUSH
90636: LD_INT 4
90638: NEG
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 1
90646: PUSH
90647: LD_INT 3
90649: NEG
90650: PUSH
90651: EMPTY
90652: LIST
90653: LIST
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: LIST
90659: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90660: LD_ADDR_VAR 0 24
90664: PUSH
90665: LD_INT 3
90667: PUSH
90668: LD_INT 0
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 3
90677: PUSH
90678: LD_INT 1
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 4
90688: PUSH
90689: LD_INT 1
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: LIST
90700: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90701: LD_ADDR_VAR 0 25
90705: PUSH
90706: LD_INT 3
90708: PUSH
90709: LD_INT 3
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 4
90718: PUSH
90719: LD_INT 3
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: LD_INT 3
90728: PUSH
90729: LD_INT 4
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: LIST
90740: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90741: LD_ADDR_VAR 0 26
90745: PUSH
90746: LD_INT 0
90748: PUSH
90749: LD_INT 3
90751: PUSH
90752: EMPTY
90753: LIST
90754: LIST
90755: PUSH
90756: LD_INT 1
90758: PUSH
90759: LD_INT 4
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: LD_INT 1
90768: NEG
90769: PUSH
90770: LD_INT 3
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: LIST
90781: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90782: LD_ADDR_VAR 0 27
90786: PUSH
90787: LD_INT 3
90789: NEG
90790: PUSH
90791: LD_INT 0
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 3
90800: NEG
90801: PUSH
90802: LD_INT 1
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 4
90811: NEG
90812: PUSH
90813: LD_INT 1
90815: NEG
90816: PUSH
90817: EMPTY
90818: LIST
90819: LIST
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: LIST
90825: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90826: LD_ADDR_VAR 0 28
90830: PUSH
90831: LD_INT 3
90833: NEG
90834: PUSH
90835: LD_INT 3
90837: NEG
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: PUSH
90843: LD_INT 3
90845: NEG
90846: PUSH
90847: LD_INT 4
90849: NEG
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 4
90857: NEG
90858: PUSH
90859: LD_INT 3
90861: NEG
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: LIST
90871: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90872: LD_ADDR_VAR 0 29
90876: PUSH
90877: LD_INT 1
90879: NEG
90880: PUSH
90881: LD_INT 3
90883: NEG
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: LD_INT 3
90894: NEG
90895: PUSH
90896: EMPTY
90897: LIST
90898: LIST
90899: PUSH
90900: LD_INT 1
90902: PUSH
90903: LD_INT 2
90905: NEG
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 1
90913: NEG
90914: PUSH
90915: LD_INT 4
90917: NEG
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 0
90925: PUSH
90926: LD_INT 4
90928: NEG
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 1
90936: PUSH
90937: LD_INT 3
90939: NEG
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 1
90947: NEG
90948: PUSH
90949: LD_INT 5
90951: NEG
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 0
90959: PUSH
90960: LD_INT 5
90962: NEG
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: LD_INT 1
90970: PUSH
90971: LD_INT 4
90973: NEG
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PUSH
90979: LD_INT 1
90981: NEG
90982: PUSH
90983: LD_INT 6
90985: NEG
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 0
90993: PUSH
90994: LD_INT 6
90996: NEG
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 1
91004: PUSH
91005: LD_INT 5
91007: NEG
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91027: LD_ADDR_VAR 0 30
91031: PUSH
91032: LD_INT 2
91034: PUSH
91035: LD_INT 1
91037: NEG
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 3
91045: PUSH
91046: LD_INT 0
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 3
91055: PUSH
91056: LD_INT 1
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: PUSH
91063: LD_INT 3
91065: PUSH
91066: LD_INT 1
91068: NEG
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: PUSH
91074: LD_INT 4
91076: PUSH
91077: LD_INT 0
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: PUSH
91084: LD_INT 4
91086: PUSH
91087: LD_INT 1
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 4
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 5
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PUSH
91115: LD_INT 5
91117: PUSH
91118: LD_INT 1
91120: PUSH
91121: EMPTY
91122: LIST
91123: LIST
91124: PUSH
91125: LD_INT 5
91127: PUSH
91128: LD_INT 1
91130: NEG
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: PUSH
91136: LD_INT 6
91138: PUSH
91139: LD_INT 0
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: PUSH
91146: LD_INT 6
91148: PUSH
91149: LD_INT 1
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: EMPTY
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91170: LD_ADDR_VAR 0 31
91174: PUSH
91175: LD_INT 3
91177: PUSH
91178: LD_INT 2
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 3
91187: PUSH
91188: LD_INT 3
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 2
91197: PUSH
91198: LD_INT 3
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 4
91207: PUSH
91208: LD_INT 3
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 4
91217: PUSH
91218: LD_INT 4
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 3
91227: PUSH
91228: LD_INT 4
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 5
91237: PUSH
91238: LD_INT 4
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: LD_INT 5
91247: PUSH
91248: LD_INT 5
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 4
91257: PUSH
91258: LD_INT 5
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 6
91267: PUSH
91268: LD_INT 5
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 6
91277: PUSH
91278: LD_INT 6
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: LD_INT 5
91287: PUSH
91288: LD_INT 6
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91309: LD_ADDR_VAR 0 32
91313: PUSH
91314: LD_INT 1
91316: PUSH
91317: LD_INT 3
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 0
91326: PUSH
91327: LD_INT 3
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: PUSH
91334: LD_INT 1
91336: NEG
91337: PUSH
91338: LD_INT 2
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 1
91347: PUSH
91348: LD_INT 4
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 0
91357: PUSH
91358: LD_INT 4
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 1
91367: NEG
91368: PUSH
91369: LD_INT 3
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 1
91378: PUSH
91379: LD_INT 5
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 0
91388: PUSH
91389: LD_INT 5
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 1
91398: NEG
91399: PUSH
91400: LD_INT 4
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 1
91409: PUSH
91410: LD_INT 6
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 0
91419: PUSH
91420: LD_INT 6
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 1
91429: NEG
91430: PUSH
91431: LD_INT 5
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91452: LD_ADDR_VAR 0 33
91456: PUSH
91457: LD_INT 2
91459: NEG
91460: PUSH
91461: LD_INT 1
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 3
91470: NEG
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 3
91481: NEG
91482: PUSH
91483: LD_INT 1
91485: NEG
91486: PUSH
91487: EMPTY
91488: LIST
91489: LIST
91490: PUSH
91491: LD_INT 3
91493: NEG
91494: PUSH
91495: LD_INT 1
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 4
91504: NEG
91505: PUSH
91506: LD_INT 0
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 4
91515: NEG
91516: PUSH
91517: LD_INT 1
91519: NEG
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 4
91527: NEG
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 5
91538: NEG
91539: PUSH
91540: LD_INT 0
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 5
91549: NEG
91550: PUSH
91551: LD_INT 1
91553: NEG
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 5
91561: NEG
91562: PUSH
91563: LD_INT 1
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: LD_INT 6
91572: NEG
91573: PUSH
91574: LD_INT 0
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 6
91583: NEG
91584: PUSH
91585: LD_INT 1
91587: NEG
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91607: LD_ADDR_VAR 0 34
91611: PUSH
91612: LD_INT 2
91614: NEG
91615: PUSH
91616: LD_INT 3
91618: NEG
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 3
91626: NEG
91627: PUSH
91628: LD_INT 2
91630: NEG
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 3
91638: NEG
91639: PUSH
91640: LD_INT 3
91642: NEG
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 3
91650: NEG
91651: PUSH
91652: LD_INT 4
91654: NEG
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 4
91662: NEG
91663: PUSH
91664: LD_INT 3
91666: NEG
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 4
91674: NEG
91675: PUSH
91676: LD_INT 4
91678: NEG
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 4
91686: NEG
91687: PUSH
91688: LD_INT 5
91690: NEG
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 5
91698: NEG
91699: PUSH
91700: LD_INT 4
91702: NEG
91703: PUSH
91704: EMPTY
91705: LIST
91706: LIST
91707: PUSH
91708: LD_INT 5
91710: NEG
91711: PUSH
91712: LD_INT 5
91714: NEG
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 5
91722: NEG
91723: PUSH
91724: LD_INT 6
91726: NEG
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 6
91734: NEG
91735: PUSH
91736: LD_INT 5
91738: NEG
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: LD_INT 6
91746: NEG
91747: PUSH
91748: LD_INT 6
91750: NEG
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91770: LD_ADDR_VAR 0 41
91774: PUSH
91775: LD_INT 0
91777: PUSH
91778: LD_INT 2
91780: NEG
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: PUSH
91786: LD_INT 1
91788: NEG
91789: PUSH
91790: LD_INT 3
91792: NEG
91793: PUSH
91794: EMPTY
91795: LIST
91796: LIST
91797: PUSH
91798: LD_INT 1
91800: PUSH
91801: LD_INT 2
91803: NEG
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: LIST
91813: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91814: LD_ADDR_VAR 0 42
91818: PUSH
91819: LD_INT 2
91821: PUSH
91822: LD_INT 0
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 2
91831: PUSH
91832: LD_INT 1
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 3
91842: PUSH
91843: LD_INT 1
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: LIST
91854: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91855: LD_ADDR_VAR 0 43
91859: PUSH
91860: LD_INT 2
91862: PUSH
91863: LD_INT 2
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: LD_INT 3
91872: PUSH
91873: LD_INT 2
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: LD_INT 2
91882: PUSH
91883: LD_INT 3
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: LIST
91894: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91895: LD_ADDR_VAR 0 44
91899: PUSH
91900: LD_INT 0
91902: PUSH
91903: LD_INT 2
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 1
91912: PUSH
91913: LD_INT 3
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 1
91922: NEG
91923: PUSH
91924: LD_INT 2
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: LIST
91935: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91936: LD_ADDR_VAR 0 45
91940: PUSH
91941: LD_INT 2
91943: NEG
91944: PUSH
91945: LD_INT 0
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 2
91954: NEG
91955: PUSH
91956: LD_INT 1
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 3
91965: NEG
91966: PUSH
91967: LD_INT 1
91969: NEG
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: LIST
91979: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91980: LD_ADDR_VAR 0 46
91984: PUSH
91985: LD_INT 2
91987: NEG
91988: PUSH
91989: LD_INT 2
91991: NEG
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: PUSH
91997: LD_INT 2
91999: NEG
92000: PUSH
92001: LD_INT 3
92003: NEG
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: PUSH
92009: LD_INT 3
92011: NEG
92012: PUSH
92013: LD_INT 2
92015: NEG
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: LIST
92025: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92026: LD_ADDR_VAR 0 47
92030: PUSH
92031: LD_INT 2
92033: NEG
92034: PUSH
92035: LD_INT 3
92037: NEG
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 1
92045: NEG
92046: PUSH
92047: LD_INT 3
92049: NEG
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92059: LD_ADDR_VAR 0 48
92063: PUSH
92064: LD_INT 1
92066: PUSH
92067: LD_INT 2
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 2
92077: PUSH
92078: LD_INT 1
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92090: LD_ADDR_VAR 0 49
92094: PUSH
92095: LD_INT 3
92097: PUSH
92098: LD_INT 1
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 3
92107: PUSH
92108: LD_INT 2
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92119: LD_ADDR_VAR 0 50
92123: PUSH
92124: LD_INT 2
92126: PUSH
92127: LD_INT 3
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: LD_INT 3
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92148: LD_ADDR_VAR 0 51
92152: PUSH
92153: LD_INT 1
92155: NEG
92156: PUSH
92157: LD_INT 2
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 2
92166: NEG
92167: PUSH
92168: LD_INT 1
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92179: LD_ADDR_VAR 0 52
92183: PUSH
92184: LD_INT 3
92186: NEG
92187: PUSH
92188: LD_INT 1
92190: NEG
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 3
92198: NEG
92199: PUSH
92200: LD_INT 2
92202: NEG
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92212: LD_ADDR_VAR 0 53
92216: PUSH
92217: LD_INT 1
92219: NEG
92220: PUSH
92221: LD_INT 3
92223: NEG
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: LD_INT 0
92231: PUSH
92232: LD_INT 3
92234: NEG
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 1
92242: PUSH
92243: LD_INT 2
92245: NEG
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: EMPTY
92252: LIST
92253: LIST
92254: LIST
92255: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92256: LD_ADDR_VAR 0 54
92260: PUSH
92261: LD_INT 2
92263: PUSH
92264: LD_INT 1
92266: NEG
92267: PUSH
92268: EMPTY
92269: LIST
92270: LIST
92271: PUSH
92272: LD_INT 3
92274: PUSH
92275: LD_INT 0
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 3
92284: PUSH
92285: LD_INT 1
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: EMPTY
92293: LIST
92294: LIST
92295: LIST
92296: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92297: LD_ADDR_VAR 0 55
92301: PUSH
92302: LD_INT 3
92304: PUSH
92305: LD_INT 2
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 3
92314: PUSH
92315: LD_INT 3
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 2
92324: PUSH
92325: LD_INT 3
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: LIST
92336: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92337: LD_ADDR_VAR 0 56
92341: PUSH
92342: LD_INT 1
92344: PUSH
92345: LD_INT 3
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 0
92354: PUSH
92355: LD_INT 3
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: PUSH
92362: LD_INT 1
92364: NEG
92365: PUSH
92366: LD_INT 2
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: LIST
92377: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92378: LD_ADDR_VAR 0 57
92382: PUSH
92383: LD_INT 2
92385: NEG
92386: PUSH
92387: LD_INT 1
92389: PUSH
92390: EMPTY
92391: LIST
92392: LIST
92393: PUSH
92394: LD_INT 3
92396: NEG
92397: PUSH
92398: LD_INT 0
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: LD_INT 3
92407: NEG
92408: PUSH
92409: LD_INT 1
92411: NEG
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: LIST
92421: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92422: LD_ADDR_VAR 0 58
92426: PUSH
92427: LD_INT 2
92429: NEG
92430: PUSH
92431: LD_INT 3
92433: NEG
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: PUSH
92439: LD_INT 3
92441: NEG
92442: PUSH
92443: LD_INT 2
92445: NEG
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 3
92453: NEG
92454: PUSH
92455: LD_INT 3
92457: NEG
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: LIST
92467: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92468: LD_ADDR_VAR 0 59
92472: PUSH
92473: LD_INT 1
92475: NEG
92476: PUSH
92477: LD_INT 2
92479: NEG
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 0
92487: PUSH
92488: LD_INT 2
92490: NEG
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 1
92498: PUSH
92499: LD_INT 1
92501: NEG
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: LIST
92511: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92512: LD_ADDR_VAR 0 60
92516: PUSH
92517: LD_INT 1
92519: PUSH
92520: LD_INT 1
92522: NEG
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 2
92530: PUSH
92531: LD_INT 0
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: PUSH
92538: LD_INT 2
92540: PUSH
92541: LD_INT 1
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: LIST
92552: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92553: LD_ADDR_VAR 0 61
92557: PUSH
92558: LD_INT 2
92560: PUSH
92561: LD_INT 1
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 2
92570: PUSH
92571: LD_INT 2
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 1
92580: PUSH
92581: LD_INT 2
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: LIST
92592: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92593: LD_ADDR_VAR 0 62
92597: PUSH
92598: LD_INT 1
92600: PUSH
92601: LD_INT 2
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 0
92610: PUSH
92611: LD_INT 2
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: LD_INT 1
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: EMPTY
92630: LIST
92631: LIST
92632: LIST
92633: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92634: LD_ADDR_VAR 0 63
92638: PUSH
92639: LD_INT 1
92641: NEG
92642: PUSH
92643: LD_INT 1
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 2
92652: NEG
92653: PUSH
92654: LD_INT 0
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: PUSH
92661: LD_INT 2
92663: NEG
92664: PUSH
92665: LD_INT 1
92667: NEG
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: LIST
92677: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92678: LD_ADDR_VAR 0 64
92682: PUSH
92683: LD_INT 1
92685: NEG
92686: PUSH
92687: LD_INT 2
92689: NEG
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PUSH
92695: LD_INT 2
92697: NEG
92698: PUSH
92699: LD_INT 1
92701: NEG
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PUSH
92707: LD_INT 2
92709: NEG
92710: PUSH
92711: LD_INT 2
92713: NEG
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: LIST
92723: ST_TO_ADDR
// end ; 2 :
92724: GO 95990
92726: LD_INT 2
92728: DOUBLE
92729: EQUAL
92730: IFTRUE 92734
92732: GO 95989
92734: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92735: LD_ADDR_VAR 0 29
92739: PUSH
92740: LD_INT 4
92742: PUSH
92743: LD_INT 0
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: PUSH
92750: LD_INT 4
92752: PUSH
92753: LD_INT 1
92755: NEG
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 5
92763: PUSH
92764: LD_INT 0
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 5
92773: PUSH
92774: LD_INT 1
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 4
92783: PUSH
92784: LD_INT 1
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 3
92793: PUSH
92794: LD_INT 0
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: LD_INT 3
92803: PUSH
92804: LD_INT 1
92806: NEG
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: PUSH
92812: LD_INT 3
92814: PUSH
92815: LD_INT 2
92817: NEG
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 5
92825: PUSH
92826: LD_INT 2
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 3
92835: PUSH
92836: LD_INT 3
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 3
92845: PUSH
92846: LD_INT 2
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: PUSH
92853: LD_INT 4
92855: PUSH
92856: LD_INT 3
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 4
92865: PUSH
92866: LD_INT 4
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 3
92875: PUSH
92876: LD_INT 4
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 2
92885: PUSH
92886: LD_INT 3
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 2
92895: PUSH
92896: LD_INT 2
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 4
92905: PUSH
92906: LD_INT 2
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: LD_INT 2
92915: PUSH
92916: LD_INT 4
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 0
92925: PUSH
92926: LD_INT 4
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 0
92935: PUSH
92936: LD_INT 3
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 1
92945: PUSH
92946: LD_INT 4
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 1
92955: PUSH
92956: LD_INT 5
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 0
92965: PUSH
92966: LD_INT 5
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 1
92975: NEG
92976: PUSH
92977: LD_INT 4
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 1
92986: NEG
92987: PUSH
92988: LD_INT 3
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 2
92997: PUSH
92998: LD_INT 5
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 2
93007: NEG
93008: PUSH
93009: LD_INT 3
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: LD_INT 3
93018: NEG
93019: PUSH
93020: LD_INT 0
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 3
93029: NEG
93030: PUSH
93031: LD_INT 1
93033: NEG
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: PUSH
93039: LD_INT 2
93041: NEG
93042: PUSH
93043: LD_INT 0
93045: PUSH
93046: EMPTY
93047: LIST
93048: LIST
93049: PUSH
93050: LD_INT 2
93052: NEG
93053: PUSH
93054: LD_INT 1
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 3
93063: NEG
93064: PUSH
93065: LD_INT 1
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 4
93074: NEG
93075: PUSH
93076: LD_INT 0
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 4
93085: NEG
93086: PUSH
93087: LD_INT 1
93089: NEG
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: PUSH
93095: LD_INT 4
93097: NEG
93098: PUSH
93099: LD_INT 2
93101: NEG
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: PUSH
93107: LD_INT 2
93109: NEG
93110: PUSH
93111: LD_INT 2
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: LD_INT 4
93120: NEG
93121: PUSH
93122: LD_INT 4
93124: NEG
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 4
93132: NEG
93133: PUSH
93134: LD_INT 5
93136: NEG
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 3
93144: NEG
93145: PUSH
93146: LD_INT 4
93148: NEG
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 3
93156: NEG
93157: PUSH
93158: LD_INT 3
93160: NEG
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 4
93168: NEG
93169: PUSH
93170: LD_INT 3
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 5
93180: NEG
93181: PUSH
93182: LD_INT 4
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 5
93192: NEG
93193: PUSH
93194: LD_INT 5
93196: NEG
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 3
93204: NEG
93205: PUSH
93206: LD_INT 5
93208: NEG
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 5
93216: NEG
93217: PUSH
93218: LD_INT 3
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93273: LD_ADDR_VAR 0 30
93277: PUSH
93278: LD_INT 4
93280: PUSH
93281: LD_INT 4
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PUSH
93288: LD_INT 4
93290: PUSH
93291: LD_INT 3
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 5
93300: PUSH
93301: LD_INT 4
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 5
93310: PUSH
93311: LD_INT 5
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 4
93320: PUSH
93321: LD_INT 5
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 3
93330: PUSH
93331: LD_INT 4
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 3
93340: PUSH
93341: LD_INT 3
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 5
93350: PUSH
93351: LD_INT 3
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 3
93360: PUSH
93361: LD_INT 5
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 0
93370: PUSH
93371: LD_INT 3
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: LD_INT 2
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 1
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 1
93400: PUSH
93401: LD_INT 4
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 0
93410: PUSH
93411: LD_INT 4
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 1
93420: NEG
93421: PUSH
93422: LD_INT 3
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: PUSH
93429: LD_INT 1
93431: NEG
93432: PUSH
93433: LD_INT 2
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 2
93442: PUSH
93443: LD_INT 4
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: LD_INT 2
93452: NEG
93453: PUSH
93454: LD_INT 2
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 4
93463: NEG
93464: PUSH
93465: LD_INT 0
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 4
93474: NEG
93475: PUSH
93476: LD_INT 1
93478: NEG
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 3
93486: NEG
93487: PUSH
93488: LD_INT 0
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 3
93497: NEG
93498: PUSH
93499: LD_INT 1
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: PUSH
93506: LD_INT 4
93508: NEG
93509: PUSH
93510: LD_INT 1
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PUSH
93517: LD_INT 5
93519: NEG
93520: PUSH
93521: LD_INT 0
93523: PUSH
93524: EMPTY
93525: LIST
93526: LIST
93527: PUSH
93528: LD_INT 5
93530: NEG
93531: PUSH
93532: LD_INT 1
93534: NEG
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 5
93542: NEG
93543: PUSH
93544: LD_INT 2
93546: NEG
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: LD_INT 3
93554: NEG
93555: PUSH
93556: LD_INT 2
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: PUSH
93563: LD_INT 3
93565: NEG
93566: PUSH
93567: LD_INT 3
93569: NEG
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 3
93577: NEG
93578: PUSH
93579: LD_INT 4
93581: NEG
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 2
93589: NEG
93590: PUSH
93591: LD_INT 3
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 2
93601: NEG
93602: PUSH
93603: LD_INT 2
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 3
93613: NEG
93614: PUSH
93615: LD_INT 2
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 4
93625: NEG
93626: PUSH
93627: LD_INT 3
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 4
93637: NEG
93638: PUSH
93639: LD_INT 4
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 2
93649: NEG
93650: PUSH
93651: LD_INT 4
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 4
93661: NEG
93662: PUSH
93663: LD_INT 2
93665: NEG
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 0
93673: PUSH
93674: LD_INT 4
93676: NEG
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PUSH
93682: LD_INT 0
93684: PUSH
93685: LD_INT 5
93687: NEG
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: PUSH
93693: LD_INT 1
93695: PUSH
93696: LD_INT 4
93698: NEG
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 1
93706: PUSH
93707: LD_INT 3
93709: NEG
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 0
93717: PUSH
93718: LD_INT 3
93720: NEG
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: LD_INT 1
93728: NEG
93729: PUSH
93730: LD_INT 4
93732: NEG
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: PUSH
93738: LD_INT 1
93740: NEG
93741: PUSH
93742: LD_INT 5
93744: NEG
93745: PUSH
93746: EMPTY
93747: LIST
93748: LIST
93749: PUSH
93750: LD_INT 2
93752: PUSH
93753: LD_INT 3
93755: NEG
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: PUSH
93761: LD_INT 2
93763: NEG
93764: PUSH
93765: LD_INT 5
93767: NEG
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93820: LD_ADDR_VAR 0 31
93824: PUSH
93825: LD_INT 0
93827: PUSH
93828: LD_INT 4
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 0
93837: PUSH
93838: LD_INT 3
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 1
93847: PUSH
93848: LD_INT 4
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: PUSH
93855: LD_INT 1
93857: PUSH
93858: LD_INT 5
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 0
93867: PUSH
93868: LD_INT 5
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 1
93877: NEG
93878: PUSH
93879: LD_INT 4
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PUSH
93886: LD_INT 1
93888: NEG
93889: PUSH
93890: LD_INT 3
93892: PUSH
93893: EMPTY
93894: LIST
93895: LIST
93896: PUSH
93897: LD_INT 2
93899: PUSH
93900: LD_INT 5
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: PUSH
93907: LD_INT 2
93909: NEG
93910: PUSH
93911: LD_INT 3
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 3
93920: NEG
93921: PUSH
93922: LD_INT 0
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: PUSH
93929: LD_INT 3
93931: NEG
93932: PUSH
93933: LD_INT 1
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 2
93943: NEG
93944: PUSH
93945: LD_INT 0
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 2
93954: NEG
93955: PUSH
93956: LD_INT 1
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 3
93965: NEG
93966: PUSH
93967: LD_INT 1
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 4
93976: NEG
93977: PUSH
93978: LD_INT 0
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 4
93987: NEG
93988: PUSH
93989: LD_INT 1
93991: NEG
93992: PUSH
93993: EMPTY
93994: LIST
93995: LIST
93996: PUSH
93997: LD_INT 4
93999: NEG
94000: PUSH
94001: LD_INT 2
94003: NEG
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: PUSH
94009: LD_INT 2
94011: NEG
94012: PUSH
94013: LD_INT 2
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: LD_INT 4
94022: NEG
94023: PUSH
94024: LD_INT 4
94026: NEG
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 4
94034: NEG
94035: PUSH
94036: LD_INT 5
94038: NEG
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 3
94046: NEG
94047: PUSH
94048: LD_INT 4
94050: NEG
94051: PUSH
94052: EMPTY
94053: LIST
94054: LIST
94055: PUSH
94056: LD_INT 3
94058: NEG
94059: PUSH
94060: LD_INT 3
94062: NEG
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 4
94070: NEG
94071: PUSH
94072: LD_INT 3
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 5
94082: NEG
94083: PUSH
94084: LD_INT 4
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 5
94094: NEG
94095: PUSH
94096: LD_INT 5
94098: NEG
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 5
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 5
94118: NEG
94119: PUSH
94120: LD_INT 3
94122: NEG
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 0
94130: PUSH
94131: LD_INT 3
94133: NEG
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 0
94141: PUSH
94142: LD_INT 4
94144: NEG
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: PUSH
94150: LD_INT 1
94152: PUSH
94153: LD_INT 3
94155: NEG
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 1
94163: PUSH
94164: LD_INT 2
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 0
94174: PUSH
94175: LD_INT 2
94177: NEG
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 1
94185: NEG
94186: PUSH
94187: LD_INT 3
94189: NEG
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: LD_INT 1
94197: NEG
94198: PUSH
94199: LD_INT 4
94201: NEG
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PUSH
94207: LD_INT 2
94209: PUSH
94210: LD_INT 2
94212: NEG
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 2
94220: NEG
94221: PUSH
94222: LD_INT 4
94224: NEG
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 4
94232: PUSH
94233: LD_INT 0
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 4
94242: PUSH
94243: LD_INT 1
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 5
94253: PUSH
94254: LD_INT 0
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 5
94263: PUSH
94264: LD_INT 1
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 4
94273: PUSH
94274: LD_INT 1
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 3
94283: PUSH
94284: LD_INT 0
94286: PUSH
94287: EMPTY
94288: LIST
94289: LIST
94290: PUSH
94291: LD_INT 3
94293: PUSH
94294: LD_INT 1
94296: NEG
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 3
94304: PUSH
94305: LD_INT 2
94307: NEG
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 5
94315: PUSH
94316: LD_INT 2
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94370: LD_ADDR_VAR 0 32
94374: PUSH
94375: LD_INT 4
94377: NEG
94378: PUSH
94379: LD_INT 0
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 4
94388: NEG
94389: PUSH
94390: LD_INT 1
94392: NEG
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 3
94400: NEG
94401: PUSH
94402: LD_INT 0
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 3
94411: NEG
94412: PUSH
94413: LD_INT 1
94415: PUSH
94416: EMPTY
94417: LIST
94418: LIST
94419: PUSH
94420: LD_INT 4
94422: NEG
94423: PUSH
94424: LD_INT 1
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: PUSH
94431: LD_INT 5
94433: NEG
94434: PUSH
94435: LD_INT 0
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 5
94444: NEG
94445: PUSH
94446: LD_INT 1
94448: NEG
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 5
94456: NEG
94457: PUSH
94458: LD_INT 2
94460: NEG
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: PUSH
94466: LD_INT 3
94468: NEG
94469: PUSH
94470: LD_INT 2
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 3
94479: NEG
94480: PUSH
94481: LD_INT 3
94483: NEG
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 3
94491: NEG
94492: PUSH
94493: LD_INT 4
94495: NEG
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 2
94503: NEG
94504: PUSH
94505: LD_INT 3
94507: NEG
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: LD_INT 2
94515: NEG
94516: PUSH
94517: LD_INT 2
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 3
94527: NEG
94528: PUSH
94529: LD_INT 2
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 4
94539: NEG
94540: PUSH
94541: LD_INT 3
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 4
94551: NEG
94552: PUSH
94553: LD_INT 4
94555: NEG
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 2
94563: NEG
94564: PUSH
94565: LD_INT 4
94567: NEG
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: PUSH
94573: LD_INT 4
94575: NEG
94576: PUSH
94577: LD_INT 2
94579: NEG
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 0
94587: PUSH
94588: LD_INT 4
94590: NEG
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 0
94598: PUSH
94599: LD_INT 5
94601: NEG
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 1
94609: PUSH
94610: LD_INT 4
94612: NEG
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 1
94620: PUSH
94621: LD_INT 3
94623: NEG
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PUSH
94629: LD_INT 0
94631: PUSH
94632: LD_INT 3
94634: NEG
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: LD_INT 1
94642: NEG
94643: PUSH
94644: LD_INT 4
94646: NEG
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 1
94654: NEG
94655: PUSH
94656: LD_INT 5
94658: NEG
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 2
94666: PUSH
94667: LD_INT 3
94669: NEG
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 2
94677: NEG
94678: PUSH
94679: LD_INT 5
94681: NEG
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 3
94689: PUSH
94690: LD_INT 0
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: PUSH
94697: LD_INT 3
94699: PUSH
94700: LD_INT 1
94702: NEG
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 4
94710: PUSH
94711: LD_INT 0
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 4
94720: PUSH
94721: LD_INT 1
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 3
94730: PUSH
94731: LD_INT 1
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 2
94740: PUSH
94741: LD_INT 0
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 2
94750: PUSH
94751: LD_INT 1
94753: NEG
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 2
94761: PUSH
94762: LD_INT 2
94764: NEG
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 4
94772: PUSH
94773: LD_INT 2
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 4
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 4
94792: PUSH
94793: LD_INT 3
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 5
94802: PUSH
94803: LD_INT 4
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 5
94812: PUSH
94813: LD_INT 5
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 4
94822: PUSH
94823: LD_INT 5
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 3
94832: PUSH
94833: LD_INT 4
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 3
94842: PUSH
94843: LD_INT 3
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 5
94852: PUSH
94853: LD_INT 3
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 3
94862: PUSH
94863: LD_INT 5
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94917: LD_ADDR_VAR 0 33
94921: PUSH
94922: LD_INT 4
94924: NEG
94925: PUSH
94926: LD_INT 4
94928: NEG
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 4
94936: NEG
94937: PUSH
94938: LD_INT 5
94940: NEG
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 3
94948: NEG
94949: PUSH
94950: LD_INT 4
94952: NEG
94953: PUSH
94954: EMPTY
94955: LIST
94956: LIST
94957: PUSH
94958: LD_INT 3
94960: NEG
94961: PUSH
94962: LD_INT 3
94964: NEG
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: PUSH
94970: LD_INT 4
94972: NEG
94973: PUSH
94974: LD_INT 3
94976: NEG
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 5
94984: NEG
94985: PUSH
94986: LD_INT 4
94988: NEG
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 5
94996: NEG
94997: PUSH
94998: LD_INT 5
95000: NEG
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 3
95008: NEG
95009: PUSH
95010: LD_INT 5
95012: NEG
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 5
95020: NEG
95021: PUSH
95022: LD_INT 3
95024: NEG
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: LD_INT 0
95032: PUSH
95033: LD_INT 3
95035: NEG
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: LD_INT 0
95043: PUSH
95044: LD_INT 4
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 1
95054: PUSH
95055: LD_INT 3
95057: NEG
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 1
95065: PUSH
95066: LD_INT 2
95068: NEG
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 0
95076: PUSH
95077: LD_INT 2
95079: NEG
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: PUSH
95085: LD_INT 1
95087: NEG
95088: PUSH
95089: LD_INT 3
95091: NEG
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: LD_INT 1
95099: NEG
95100: PUSH
95101: LD_INT 4
95103: NEG
95104: PUSH
95105: EMPTY
95106: LIST
95107: LIST
95108: PUSH
95109: LD_INT 2
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 2
95122: NEG
95123: PUSH
95124: LD_INT 4
95126: NEG
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 4
95134: PUSH
95135: LD_INT 0
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 4
95144: PUSH
95145: LD_INT 1
95147: NEG
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 5
95155: PUSH
95156: LD_INT 0
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 5
95165: PUSH
95166: LD_INT 1
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 4
95175: PUSH
95176: LD_INT 1
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 3
95185: PUSH
95186: LD_INT 0
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 3
95195: PUSH
95196: LD_INT 1
95198: NEG
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 3
95206: PUSH
95207: LD_INT 2
95209: NEG
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 5
95217: PUSH
95218: LD_INT 2
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 3
95227: PUSH
95228: LD_INT 3
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: PUSH
95235: LD_INT 3
95237: PUSH
95238: LD_INT 2
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 4
95247: PUSH
95248: LD_INT 3
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 4
95257: PUSH
95258: LD_INT 4
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 3
95267: PUSH
95268: LD_INT 4
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 2
95277: PUSH
95278: LD_INT 3
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 2
95287: PUSH
95288: LD_INT 2
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 4
95297: PUSH
95298: LD_INT 2
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 2
95307: PUSH
95308: LD_INT 4
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 0
95317: PUSH
95318: LD_INT 4
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 0
95327: PUSH
95328: LD_INT 3
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 1
95337: PUSH
95338: LD_INT 4
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 1
95347: PUSH
95348: LD_INT 5
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: LD_INT 0
95357: PUSH
95358: LD_INT 5
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 1
95367: NEG
95368: PUSH
95369: LD_INT 4
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PUSH
95376: LD_INT 1
95378: NEG
95379: PUSH
95380: LD_INT 3
95382: PUSH
95383: EMPTY
95384: LIST
95385: LIST
95386: PUSH
95387: LD_INT 2
95389: PUSH
95390: LD_INT 5
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 2
95399: NEG
95400: PUSH
95401: LD_INT 3
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: EMPTY
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95455: LD_ADDR_VAR 0 34
95459: PUSH
95460: LD_INT 0
95462: PUSH
95463: LD_INT 4
95465: NEG
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PUSH
95471: LD_INT 0
95473: PUSH
95474: LD_INT 5
95476: NEG
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: PUSH
95482: LD_INT 1
95484: PUSH
95485: LD_INT 4
95487: NEG
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 1
95495: PUSH
95496: LD_INT 3
95498: NEG
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 0
95506: PUSH
95507: LD_INT 3
95509: NEG
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_INT 1
95517: NEG
95518: PUSH
95519: LD_INT 4
95521: NEG
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 1
95529: NEG
95530: PUSH
95531: LD_INT 5
95533: NEG
95534: PUSH
95535: EMPTY
95536: LIST
95537: LIST
95538: PUSH
95539: LD_INT 2
95541: PUSH
95542: LD_INT 3
95544: NEG
95545: PUSH
95546: EMPTY
95547: LIST
95548: LIST
95549: PUSH
95550: LD_INT 2
95552: NEG
95553: PUSH
95554: LD_INT 5
95556: NEG
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 3
95564: PUSH
95565: LD_INT 0
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 3
95574: PUSH
95575: LD_INT 1
95577: NEG
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 4
95585: PUSH
95586: LD_INT 0
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 4
95595: PUSH
95596: LD_INT 1
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 3
95605: PUSH
95606: LD_INT 1
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 2
95615: PUSH
95616: LD_INT 0
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: LD_INT 2
95625: PUSH
95626: LD_INT 1
95628: NEG
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: LD_INT 2
95639: NEG
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: PUSH
95645: LD_INT 4
95647: PUSH
95648: LD_INT 2
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 4
95657: PUSH
95658: LD_INT 4
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: LD_INT 4
95667: PUSH
95668: LD_INT 3
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 5
95677: PUSH
95678: LD_INT 4
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 5
95687: PUSH
95688: LD_INT 5
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 4
95697: PUSH
95698: LD_INT 5
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 3
95707: PUSH
95708: LD_INT 4
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 3
95717: PUSH
95718: LD_INT 3
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 5
95727: PUSH
95728: LD_INT 3
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 3
95737: PUSH
95738: LD_INT 5
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: LD_INT 0
95747: PUSH
95748: LD_INT 3
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 0
95757: PUSH
95758: LD_INT 2
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 1
95767: PUSH
95768: LD_INT 3
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: LD_INT 1
95777: PUSH
95778: LD_INT 4
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 0
95787: PUSH
95788: LD_INT 4
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 1
95797: NEG
95798: PUSH
95799: LD_INT 3
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: PUSH
95806: LD_INT 1
95808: NEG
95809: PUSH
95810: LD_INT 2
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 2
95819: PUSH
95820: LD_INT 4
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 2
95829: NEG
95830: PUSH
95831: LD_INT 2
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 4
95840: NEG
95841: PUSH
95842: LD_INT 0
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 4
95851: NEG
95852: PUSH
95853: LD_INT 1
95855: NEG
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: PUSH
95861: LD_INT 3
95863: NEG
95864: PUSH
95865: LD_INT 0
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: PUSH
95872: LD_INT 3
95874: NEG
95875: PUSH
95876: LD_INT 1
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 4
95885: NEG
95886: PUSH
95887: LD_INT 1
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 5
95896: NEG
95897: PUSH
95898: LD_INT 0
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 5
95907: NEG
95908: PUSH
95909: LD_INT 1
95911: NEG
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 5
95919: NEG
95920: PUSH
95921: LD_INT 2
95923: NEG
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: LD_INT 3
95931: NEG
95932: PUSH
95933: LD_INT 2
95935: PUSH
95936: EMPTY
95937: LIST
95938: LIST
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: ST_TO_ADDR
// end ; end ;
95987: GO 95990
95989: POP
// case btype of b_depot , b_warehouse :
95990: LD_VAR 0 1
95994: PUSH
95995: LD_INT 0
95997: DOUBLE
95998: EQUAL
95999: IFTRUE 96009
96001: LD_INT 1
96003: DOUBLE
96004: EQUAL
96005: IFTRUE 96009
96007: GO 96210
96009: POP
// case nation of nation_american :
96010: LD_VAR 0 5
96014: PUSH
96015: LD_INT 1
96017: DOUBLE
96018: EQUAL
96019: IFTRUE 96023
96021: GO 96079
96023: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96024: LD_ADDR_VAR 0 9
96028: PUSH
96029: LD_VAR 0 11
96033: PUSH
96034: LD_VAR 0 12
96038: PUSH
96039: LD_VAR 0 13
96043: PUSH
96044: LD_VAR 0 14
96048: PUSH
96049: LD_VAR 0 15
96053: PUSH
96054: LD_VAR 0 16
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: PUSH
96067: LD_VAR 0 4
96071: PUSH
96072: LD_INT 1
96074: PLUS
96075: ARRAY
96076: ST_TO_ADDR
96077: GO 96208
96079: LD_INT 2
96081: DOUBLE
96082: EQUAL
96083: IFTRUE 96087
96085: GO 96143
96087: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96088: LD_ADDR_VAR 0 9
96092: PUSH
96093: LD_VAR 0 17
96097: PUSH
96098: LD_VAR 0 18
96102: PUSH
96103: LD_VAR 0 19
96107: PUSH
96108: LD_VAR 0 20
96112: PUSH
96113: LD_VAR 0 21
96117: PUSH
96118: LD_VAR 0 22
96122: PUSH
96123: EMPTY
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: PUSH
96131: LD_VAR 0 4
96135: PUSH
96136: LD_INT 1
96138: PLUS
96139: ARRAY
96140: ST_TO_ADDR
96141: GO 96208
96143: LD_INT 3
96145: DOUBLE
96146: EQUAL
96147: IFTRUE 96151
96149: GO 96207
96151: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96152: LD_ADDR_VAR 0 9
96156: PUSH
96157: LD_VAR 0 23
96161: PUSH
96162: LD_VAR 0 24
96166: PUSH
96167: LD_VAR 0 25
96171: PUSH
96172: LD_VAR 0 26
96176: PUSH
96177: LD_VAR 0 27
96181: PUSH
96182: LD_VAR 0 28
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: PUSH
96195: LD_VAR 0 4
96199: PUSH
96200: LD_INT 1
96202: PLUS
96203: ARRAY
96204: ST_TO_ADDR
96205: GO 96208
96207: POP
96208: GO 96763
96210: LD_INT 2
96212: DOUBLE
96213: EQUAL
96214: IFTRUE 96224
96216: LD_INT 3
96218: DOUBLE
96219: EQUAL
96220: IFTRUE 96224
96222: GO 96280
96224: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96225: LD_ADDR_VAR 0 9
96229: PUSH
96230: LD_VAR 0 29
96234: PUSH
96235: LD_VAR 0 30
96239: PUSH
96240: LD_VAR 0 31
96244: PUSH
96245: LD_VAR 0 32
96249: PUSH
96250: LD_VAR 0 33
96254: PUSH
96255: LD_VAR 0 34
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: PUSH
96268: LD_VAR 0 4
96272: PUSH
96273: LD_INT 1
96275: PLUS
96276: ARRAY
96277: ST_TO_ADDR
96278: GO 96763
96280: LD_INT 16
96282: DOUBLE
96283: EQUAL
96284: IFTRUE 96342
96286: LD_INT 17
96288: DOUBLE
96289: EQUAL
96290: IFTRUE 96342
96292: LD_INT 18
96294: DOUBLE
96295: EQUAL
96296: IFTRUE 96342
96298: LD_INT 19
96300: DOUBLE
96301: EQUAL
96302: IFTRUE 96342
96304: LD_INT 22
96306: DOUBLE
96307: EQUAL
96308: IFTRUE 96342
96310: LD_INT 20
96312: DOUBLE
96313: EQUAL
96314: IFTRUE 96342
96316: LD_INT 21
96318: DOUBLE
96319: EQUAL
96320: IFTRUE 96342
96322: LD_INT 23
96324: DOUBLE
96325: EQUAL
96326: IFTRUE 96342
96328: LD_INT 24
96330: DOUBLE
96331: EQUAL
96332: IFTRUE 96342
96334: LD_INT 25
96336: DOUBLE
96337: EQUAL
96338: IFTRUE 96342
96340: GO 96398
96342: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96343: LD_ADDR_VAR 0 9
96347: PUSH
96348: LD_VAR 0 35
96352: PUSH
96353: LD_VAR 0 36
96357: PUSH
96358: LD_VAR 0 37
96362: PUSH
96363: LD_VAR 0 38
96367: PUSH
96368: LD_VAR 0 39
96372: PUSH
96373: LD_VAR 0 40
96377: PUSH
96378: EMPTY
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: PUSH
96386: LD_VAR 0 4
96390: PUSH
96391: LD_INT 1
96393: PLUS
96394: ARRAY
96395: ST_TO_ADDR
96396: GO 96763
96398: LD_INT 6
96400: DOUBLE
96401: EQUAL
96402: IFTRUE 96454
96404: LD_INT 7
96406: DOUBLE
96407: EQUAL
96408: IFTRUE 96454
96410: LD_INT 8
96412: DOUBLE
96413: EQUAL
96414: IFTRUE 96454
96416: LD_INT 13
96418: DOUBLE
96419: EQUAL
96420: IFTRUE 96454
96422: LD_INT 12
96424: DOUBLE
96425: EQUAL
96426: IFTRUE 96454
96428: LD_INT 15
96430: DOUBLE
96431: EQUAL
96432: IFTRUE 96454
96434: LD_INT 11
96436: DOUBLE
96437: EQUAL
96438: IFTRUE 96454
96440: LD_INT 14
96442: DOUBLE
96443: EQUAL
96444: IFTRUE 96454
96446: LD_INT 10
96448: DOUBLE
96449: EQUAL
96450: IFTRUE 96454
96452: GO 96510
96454: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96455: LD_ADDR_VAR 0 9
96459: PUSH
96460: LD_VAR 0 41
96464: PUSH
96465: LD_VAR 0 42
96469: PUSH
96470: LD_VAR 0 43
96474: PUSH
96475: LD_VAR 0 44
96479: PUSH
96480: LD_VAR 0 45
96484: PUSH
96485: LD_VAR 0 46
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: PUSH
96498: LD_VAR 0 4
96502: PUSH
96503: LD_INT 1
96505: PLUS
96506: ARRAY
96507: ST_TO_ADDR
96508: GO 96763
96510: LD_INT 36
96512: DOUBLE
96513: EQUAL
96514: IFTRUE 96518
96516: GO 96574
96518: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96519: LD_ADDR_VAR 0 9
96523: PUSH
96524: LD_VAR 0 47
96528: PUSH
96529: LD_VAR 0 48
96533: PUSH
96534: LD_VAR 0 49
96538: PUSH
96539: LD_VAR 0 50
96543: PUSH
96544: LD_VAR 0 51
96548: PUSH
96549: LD_VAR 0 52
96553: PUSH
96554: EMPTY
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: PUSH
96562: LD_VAR 0 4
96566: PUSH
96567: LD_INT 1
96569: PLUS
96570: ARRAY
96571: ST_TO_ADDR
96572: GO 96763
96574: LD_INT 4
96576: DOUBLE
96577: EQUAL
96578: IFTRUE 96600
96580: LD_INT 5
96582: DOUBLE
96583: EQUAL
96584: IFTRUE 96600
96586: LD_INT 34
96588: DOUBLE
96589: EQUAL
96590: IFTRUE 96600
96592: LD_INT 37
96594: DOUBLE
96595: EQUAL
96596: IFTRUE 96600
96598: GO 96656
96600: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96601: LD_ADDR_VAR 0 9
96605: PUSH
96606: LD_VAR 0 53
96610: PUSH
96611: LD_VAR 0 54
96615: PUSH
96616: LD_VAR 0 55
96620: PUSH
96621: LD_VAR 0 56
96625: PUSH
96626: LD_VAR 0 57
96630: PUSH
96631: LD_VAR 0 58
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: PUSH
96644: LD_VAR 0 4
96648: PUSH
96649: LD_INT 1
96651: PLUS
96652: ARRAY
96653: ST_TO_ADDR
96654: GO 96763
96656: LD_INT 31
96658: DOUBLE
96659: EQUAL
96660: IFTRUE 96706
96662: LD_INT 32
96664: DOUBLE
96665: EQUAL
96666: IFTRUE 96706
96668: LD_INT 33
96670: DOUBLE
96671: EQUAL
96672: IFTRUE 96706
96674: LD_INT 27
96676: DOUBLE
96677: EQUAL
96678: IFTRUE 96706
96680: LD_INT 26
96682: DOUBLE
96683: EQUAL
96684: IFTRUE 96706
96686: LD_INT 28
96688: DOUBLE
96689: EQUAL
96690: IFTRUE 96706
96692: LD_INT 29
96694: DOUBLE
96695: EQUAL
96696: IFTRUE 96706
96698: LD_INT 30
96700: DOUBLE
96701: EQUAL
96702: IFTRUE 96706
96704: GO 96762
96706: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96707: LD_ADDR_VAR 0 9
96711: PUSH
96712: LD_VAR 0 59
96716: PUSH
96717: LD_VAR 0 60
96721: PUSH
96722: LD_VAR 0 61
96726: PUSH
96727: LD_VAR 0 62
96731: PUSH
96732: LD_VAR 0 63
96736: PUSH
96737: LD_VAR 0 64
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: PUSH
96750: LD_VAR 0 4
96754: PUSH
96755: LD_INT 1
96757: PLUS
96758: ARRAY
96759: ST_TO_ADDR
96760: GO 96763
96762: POP
// temp_list2 = [ ] ;
96763: LD_ADDR_VAR 0 10
96767: PUSH
96768: EMPTY
96769: ST_TO_ADDR
// for i in temp_list do
96770: LD_ADDR_VAR 0 8
96774: PUSH
96775: LD_VAR 0 9
96779: PUSH
96780: FOR_IN
96781: IFFALSE 96833
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96783: LD_ADDR_VAR 0 10
96787: PUSH
96788: LD_VAR 0 10
96792: PUSH
96793: LD_VAR 0 8
96797: PUSH
96798: LD_INT 1
96800: ARRAY
96801: PUSH
96802: LD_VAR 0 2
96806: PLUS
96807: PUSH
96808: LD_VAR 0 8
96812: PUSH
96813: LD_INT 2
96815: ARRAY
96816: PUSH
96817: LD_VAR 0 3
96821: PLUS
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: EMPTY
96828: LIST
96829: ADD
96830: ST_TO_ADDR
96831: GO 96780
96833: POP
96834: POP
// result = temp_list2 ;
96835: LD_ADDR_VAR 0 7
96839: PUSH
96840: LD_VAR 0 10
96844: ST_TO_ADDR
// end ;
96845: LD_VAR 0 7
96849: RET
// export function EnemyInRange ( unit , dist ) ; begin
96850: LD_INT 0
96852: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96853: LD_ADDR_VAR 0 3
96857: PUSH
96858: LD_VAR 0 1
96862: PPUSH
96863: CALL_OW 255
96867: PPUSH
96868: LD_VAR 0 1
96872: PPUSH
96873: CALL_OW 250
96877: PPUSH
96878: LD_VAR 0 1
96882: PPUSH
96883: CALL_OW 251
96887: PPUSH
96888: LD_VAR 0 2
96892: PPUSH
96893: CALL 70954 0 4
96897: PUSH
96898: LD_INT 4
96900: ARRAY
96901: ST_TO_ADDR
// end ;
96902: LD_VAR 0 3
96906: RET
// export function PlayerSeeMe ( unit ) ; begin
96907: LD_INT 0
96909: PPUSH
// result := See ( your_side , unit ) ;
96910: LD_ADDR_VAR 0 2
96914: PUSH
96915: LD_OWVAR 2
96919: PPUSH
96920: LD_VAR 0 1
96924: PPUSH
96925: CALL_OW 292
96929: ST_TO_ADDR
// end ;
96930: LD_VAR 0 2
96934: RET
// export function ReverseDir ( unit ) ; begin
96935: LD_INT 0
96937: PPUSH
// if not unit then
96938: LD_VAR 0 1
96942: NOT
96943: IFFALSE 96947
// exit ;
96945: GO 96970
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96947: LD_ADDR_VAR 0 2
96951: PUSH
96952: LD_VAR 0 1
96956: PPUSH
96957: CALL_OW 254
96961: PUSH
96962: LD_INT 3
96964: PLUS
96965: PUSH
96966: LD_INT 6
96968: MOD
96969: ST_TO_ADDR
// end ;
96970: LD_VAR 0 2
96974: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96975: LD_INT 0
96977: PPUSH
96978: PPUSH
96979: PPUSH
96980: PPUSH
96981: PPUSH
// if not hexes then
96982: LD_VAR 0 2
96986: NOT
96987: IFFALSE 96991
// exit ;
96989: GO 97139
// dist := 9999 ;
96991: LD_ADDR_VAR 0 5
96995: PUSH
96996: LD_INT 9999
96998: ST_TO_ADDR
// for i = 1 to hexes do
96999: LD_ADDR_VAR 0 4
97003: PUSH
97004: DOUBLE
97005: LD_INT 1
97007: DEC
97008: ST_TO_ADDR
97009: LD_VAR 0 2
97013: PUSH
97014: FOR_TO
97015: IFFALSE 97127
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97017: LD_VAR 0 1
97021: PPUSH
97022: LD_VAR 0 2
97026: PUSH
97027: LD_VAR 0 4
97031: ARRAY
97032: PUSH
97033: LD_INT 1
97035: ARRAY
97036: PPUSH
97037: LD_VAR 0 2
97041: PUSH
97042: LD_VAR 0 4
97046: ARRAY
97047: PUSH
97048: LD_INT 2
97050: ARRAY
97051: PPUSH
97052: CALL_OW 297
97056: PUSH
97057: LD_VAR 0 5
97061: LESS
97062: IFFALSE 97125
// begin hex := hexes [ i ] ;
97064: LD_ADDR_VAR 0 7
97068: PUSH
97069: LD_VAR 0 2
97073: PUSH
97074: LD_VAR 0 4
97078: ARRAY
97079: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97080: LD_ADDR_VAR 0 5
97084: PUSH
97085: LD_VAR 0 1
97089: PPUSH
97090: LD_VAR 0 2
97094: PUSH
97095: LD_VAR 0 4
97099: ARRAY
97100: PUSH
97101: LD_INT 1
97103: ARRAY
97104: PPUSH
97105: LD_VAR 0 2
97109: PUSH
97110: LD_VAR 0 4
97114: ARRAY
97115: PUSH
97116: LD_INT 2
97118: ARRAY
97119: PPUSH
97120: CALL_OW 297
97124: ST_TO_ADDR
// end ; end ;
97125: GO 97014
97127: POP
97128: POP
// result := hex ;
97129: LD_ADDR_VAR 0 3
97133: PUSH
97134: LD_VAR 0 7
97138: ST_TO_ADDR
// end ;
97139: LD_VAR 0 3
97143: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97144: LD_INT 0
97146: PPUSH
97147: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97148: LD_VAR 0 1
97152: NOT
97153: PUSH
97154: LD_VAR 0 1
97158: PUSH
97159: LD_INT 21
97161: PUSH
97162: LD_INT 2
97164: PUSH
97165: EMPTY
97166: LIST
97167: LIST
97168: PUSH
97169: LD_INT 23
97171: PUSH
97172: LD_INT 2
97174: PUSH
97175: EMPTY
97176: LIST
97177: LIST
97178: PUSH
97179: EMPTY
97180: LIST
97181: LIST
97182: PPUSH
97183: CALL_OW 69
97187: IN
97188: NOT
97189: OR
97190: IFFALSE 97194
// exit ;
97192: GO 97241
// for i = 1 to 3 do
97194: LD_ADDR_VAR 0 3
97198: PUSH
97199: DOUBLE
97200: LD_INT 1
97202: DEC
97203: ST_TO_ADDR
97204: LD_INT 3
97206: PUSH
97207: FOR_TO
97208: IFFALSE 97239
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97210: LD_VAR 0 1
97214: PPUSH
97215: CALL_OW 250
97219: PPUSH
97220: LD_VAR 0 1
97224: PPUSH
97225: CALL_OW 251
97229: PPUSH
97230: LD_INT 1
97232: PPUSH
97233: CALL_OW 453
97237: GO 97207
97239: POP
97240: POP
// end ;
97241: LD_VAR 0 2
97245: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97246: LD_INT 0
97248: PPUSH
97249: PPUSH
97250: PPUSH
97251: PPUSH
97252: PPUSH
97253: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97254: LD_VAR 0 1
97258: NOT
97259: PUSH
97260: LD_VAR 0 2
97264: NOT
97265: OR
97266: PUSH
97267: LD_VAR 0 1
97271: PPUSH
97272: CALL_OW 314
97276: OR
97277: IFFALSE 97281
// exit ;
97279: GO 97722
// x := GetX ( enemy_unit ) ;
97281: LD_ADDR_VAR 0 7
97285: PUSH
97286: LD_VAR 0 2
97290: PPUSH
97291: CALL_OW 250
97295: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97296: LD_ADDR_VAR 0 8
97300: PUSH
97301: LD_VAR 0 2
97305: PPUSH
97306: CALL_OW 251
97310: ST_TO_ADDR
// if not x or not y then
97311: LD_VAR 0 7
97315: NOT
97316: PUSH
97317: LD_VAR 0 8
97321: NOT
97322: OR
97323: IFFALSE 97327
// exit ;
97325: GO 97722
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97327: LD_ADDR_VAR 0 6
97331: PUSH
97332: LD_VAR 0 7
97336: PPUSH
97337: LD_INT 0
97339: PPUSH
97340: LD_INT 4
97342: PPUSH
97343: CALL_OW 272
97347: PUSH
97348: LD_VAR 0 8
97352: PPUSH
97353: LD_INT 0
97355: PPUSH
97356: LD_INT 4
97358: PPUSH
97359: CALL_OW 273
97363: PUSH
97364: EMPTY
97365: LIST
97366: LIST
97367: PUSH
97368: LD_VAR 0 7
97372: PPUSH
97373: LD_INT 1
97375: PPUSH
97376: LD_INT 4
97378: PPUSH
97379: CALL_OW 272
97383: PUSH
97384: LD_VAR 0 8
97388: PPUSH
97389: LD_INT 1
97391: PPUSH
97392: LD_INT 4
97394: PPUSH
97395: CALL_OW 273
97399: PUSH
97400: EMPTY
97401: LIST
97402: LIST
97403: PUSH
97404: LD_VAR 0 7
97408: PPUSH
97409: LD_INT 2
97411: PPUSH
97412: LD_INT 4
97414: PPUSH
97415: CALL_OW 272
97419: PUSH
97420: LD_VAR 0 8
97424: PPUSH
97425: LD_INT 2
97427: PPUSH
97428: LD_INT 4
97430: PPUSH
97431: CALL_OW 273
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_VAR 0 7
97444: PPUSH
97445: LD_INT 3
97447: PPUSH
97448: LD_INT 4
97450: PPUSH
97451: CALL_OW 272
97455: PUSH
97456: LD_VAR 0 8
97460: PPUSH
97461: LD_INT 3
97463: PPUSH
97464: LD_INT 4
97466: PPUSH
97467: CALL_OW 273
97471: PUSH
97472: EMPTY
97473: LIST
97474: LIST
97475: PUSH
97476: LD_VAR 0 7
97480: PPUSH
97481: LD_INT 4
97483: PPUSH
97484: LD_INT 4
97486: PPUSH
97487: CALL_OW 272
97491: PUSH
97492: LD_VAR 0 8
97496: PPUSH
97497: LD_INT 4
97499: PPUSH
97500: LD_INT 4
97502: PPUSH
97503: CALL_OW 273
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: PUSH
97512: LD_VAR 0 7
97516: PPUSH
97517: LD_INT 5
97519: PPUSH
97520: LD_INT 4
97522: PPUSH
97523: CALL_OW 272
97527: PUSH
97528: LD_VAR 0 8
97532: PPUSH
97533: LD_INT 5
97535: PPUSH
97536: LD_INT 4
97538: PPUSH
97539: CALL_OW 273
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: LIST
97552: LIST
97553: LIST
97554: LIST
97555: ST_TO_ADDR
// for i = tmp downto 1 do
97556: LD_ADDR_VAR 0 4
97560: PUSH
97561: DOUBLE
97562: LD_VAR 0 6
97566: INC
97567: ST_TO_ADDR
97568: LD_INT 1
97570: PUSH
97571: FOR_DOWNTO
97572: IFFALSE 97673
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97574: LD_VAR 0 6
97578: PUSH
97579: LD_VAR 0 4
97583: ARRAY
97584: PUSH
97585: LD_INT 1
97587: ARRAY
97588: PPUSH
97589: LD_VAR 0 6
97593: PUSH
97594: LD_VAR 0 4
97598: ARRAY
97599: PUSH
97600: LD_INT 2
97602: ARRAY
97603: PPUSH
97604: CALL_OW 488
97608: NOT
97609: PUSH
97610: LD_VAR 0 6
97614: PUSH
97615: LD_VAR 0 4
97619: ARRAY
97620: PUSH
97621: LD_INT 1
97623: ARRAY
97624: PPUSH
97625: LD_VAR 0 6
97629: PUSH
97630: LD_VAR 0 4
97634: ARRAY
97635: PUSH
97636: LD_INT 2
97638: ARRAY
97639: PPUSH
97640: CALL_OW 428
97644: PUSH
97645: LD_INT 0
97647: NONEQUAL
97648: OR
97649: IFFALSE 97671
// tmp := Delete ( tmp , i ) ;
97651: LD_ADDR_VAR 0 6
97655: PUSH
97656: LD_VAR 0 6
97660: PPUSH
97661: LD_VAR 0 4
97665: PPUSH
97666: CALL_OW 3
97670: ST_TO_ADDR
97671: GO 97571
97673: POP
97674: POP
// j := GetClosestHex ( unit , tmp ) ;
97675: LD_ADDR_VAR 0 5
97679: PUSH
97680: LD_VAR 0 1
97684: PPUSH
97685: LD_VAR 0 6
97689: PPUSH
97690: CALL 96975 0 2
97694: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97695: LD_VAR 0 1
97699: PPUSH
97700: LD_VAR 0 5
97704: PUSH
97705: LD_INT 1
97707: ARRAY
97708: PPUSH
97709: LD_VAR 0 5
97713: PUSH
97714: LD_INT 2
97716: ARRAY
97717: PPUSH
97718: CALL_OW 111
// end ;
97722: LD_VAR 0 3
97726: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97727: LD_INT 0
97729: PPUSH
97730: PPUSH
97731: PPUSH
// uc_side = 0 ;
97732: LD_ADDR_OWVAR 20
97736: PUSH
97737: LD_INT 0
97739: ST_TO_ADDR
// uc_nation = 0 ;
97740: LD_ADDR_OWVAR 21
97744: PUSH
97745: LD_INT 0
97747: ST_TO_ADDR
// InitHc_All ( ) ;
97748: CALL_OW 584
// InitVc ;
97752: CALL_OW 20
// if mastodonts then
97756: LD_VAR 0 6
97760: IFFALSE 97827
// for i = 1 to mastodonts do
97762: LD_ADDR_VAR 0 11
97766: PUSH
97767: DOUBLE
97768: LD_INT 1
97770: DEC
97771: ST_TO_ADDR
97772: LD_VAR 0 6
97776: PUSH
97777: FOR_TO
97778: IFFALSE 97825
// begin vc_chassis := 31 ;
97780: LD_ADDR_OWVAR 37
97784: PUSH
97785: LD_INT 31
97787: ST_TO_ADDR
// vc_control := control_rider ;
97788: LD_ADDR_OWVAR 38
97792: PUSH
97793: LD_INT 4
97795: ST_TO_ADDR
// animal := CreateVehicle ;
97796: LD_ADDR_VAR 0 12
97800: PUSH
97801: CALL_OW 45
97805: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97806: LD_VAR 0 12
97810: PPUSH
97811: LD_VAR 0 8
97815: PPUSH
97816: LD_INT 0
97818: PPUSH
97819: CALL 100015 0 3
// end ;
97823: GO 97777
97825: POP
97826: POP
// if horses then
97827: LD_VAR 0 5
97831: IFFALSE 97898
// for i = 1 to horses do
97833: LD_ADDR_VAR 0 11
97837: PUSH
97838: DOUBLE
97839: LD_INT 1
97841: DEC
97842: ST_TO_ADDR
97843: LD_VAR 0 5
97847: PUSH
97848: FOR_TO
97849: IFFALSE 97896
// begin hc_class := 21 ;
97851: LD_ADDR_OWVAR 28
97855: PUSH
97856: LD_INT 21
97858: ST_TO_ADDR
// hc_gallery :=  ;
97859: LD_ADDR_OWVAR 33
97863: PUSH
97864: LD_STRING 
97866: ST_TO_ADDR
// animal := CreateHuman ;
97867: LD_ADDR_VAR 0 12
97871: PUSH
97872: CALL_OW 44
97876: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97877: LD_VAR 0 12
97881: PPUSH
97882: LD_VAR 0 8
97886: PPUSH
97887: LD_INT 0
97889: PPUSH
97890: CALL 100015 0 3
// end ;
97894: GO 97848
97896: POP
97897: POP
// if birds then
97898: LD_VAR 0 1
97902: IFFALSE 97969
// for i = 1 to birds do
97904: LD_ADDR_VAR 0 11
97908: PUSH
97909: DOUBLE
97910: LD_INT 1
97912: DEC
97913: ST_TO_ADDR
97914: LD_VAR 0 1
97918: PUSH
97919: FOR_TO
97920: IFFALSE 97967
// begin hc_class = 18 ;
97922: LD_ADDR_OWVAR 28
97926: PUSH
97927: LD_INT 18
97929: ST_TO_ADDR
// hc_gallery =  ;
97930: LD_ADDR_OWVAR 33
97934: PUSH
97935: LD_STRING 
97937: ST_TO_ADDR
// animal := CreateHuman ;
97938: LD_ADDR_VAR 0 12
97942: PUSH
97943: CALL_OW 44
97947: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97948: LD_VAR 0 12
97952: PPUSH
97953: LD_VAR 0 8
97957: PPUSH
97958: LD_INT 0
97960: PPUSH
97961: CALL 100015 0 3
// end ;
97965: GO 97919
97967: POP
97968: POP
// if tigers then
97969: LD_VAR 0 2
97973: IFFALSE 98057
// for i = 1 to tigers do
97975: LD_ADDR_VAR 0 11
97979: PUSH
97980: DOUBLE
97981: LD_INT 1
97983: DEC
97984: ST_TO_ADDR
97985: LD_VAR 0 2
97989: PUSH
97990: FOR_TO
97991: IFFALSE 98055
// begin hc_class = class_tiger ;
97993: LD_ADDR_OWVAR 28
97997: PUSH
97998: LD_INT 14
98000: ST_TO_ADDR
// hc_gallery =  ;
98001: LD_ADDR_OWVAR 33
98005: PUSH
98006: LD_STRING 
98008: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98009: LD_ADDR_OWVAR 35
98013: PUSH
98014: LD_INT 7
98016: NEG
98017: PPUSH
98018: LD_INT 7
98020: PPUSH
98021: CALL_OW 12
98025: ST_TO_ADDR
// animal := CreateHuman ;
98026: LD_ADDR_VAR 0 12
98030: PUSH
98031: CALL_OW 44
98035: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98036: LD_VAR 0 12
98040: PPUSH
98041: LD_VAR 0 8
98045: PPUSH
98046: LD_INT 0
98048: PPUSH
98049: CALL 100015 0 3
// end ;
98053: GO 97990
98055: POP
98056: POP
// if apemans then
98057: LD_VAR 0 3
98061: IFFALSE 98184
// for i = 1 to apemans do
98063: LD_ADDR_VAR 0 11
98067: PUSH
98068: DOUBLE
98069: LD_INT 1
98071: DEC
98072: ST_TO_ADDR
98073: LD_VAR 0 3
98077: PUSH
98078: FOR_TO
98079: IFFALSE 98182
// begin hc_class = class_apeman ;
98081: LD_ADDR_OWVAR 28
98085: PUSH
98086: LD_INT 12
98088: ST_TO_ADDR
// hc_gallery =  ;
98089: LD_ADDR_OWVAR 33
98093: PUSH
98094: LD_STRING 
98096: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98097: LD_ADDR_OWVAR 35
98101: PUSH
98102: LD_INT 5
98104: NEG
98105: PPUSH
98106: LD_INT 5
98108: PPUSH
98109: CALL_OW 12
98113: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98114: LD_ADDR_OWVAR 31
98118: PUSH
98119: LD_INT 1
98121: PPUSH
98122: LD_INT 3
98124: PPUSH
98125: CALL_OW 12
98129: PUSH
98130: LD_INT 1
98132: PPUSH
98133: LD_INT 3
98135: PPUSH
98136: CALL_OW 12
98140: PUSH
98141: LD_INT 0
98143: PUSH
98144: LD_INT 0
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: ST_TO_ADDR
// animal := CreateHuman ;
98153: LD_ADDR_VAR 0 12
98157: PUSH
98158: CALL_OW 44
98162: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98163: LD_VAR 0 12
98167: PPUSH
98168: LD_VAR 0 8
98172: PPUSH
98173: LD_INT 0
98175: PPUSH
98176: CALL 100015 0 3
// end ;
98180: GO 98078
98182: POP
98183: POP
// if enchidnas then
98184: LD_VAR 0 4
98188: IFFALSE 98255
// for i = 1 to enchidnas do
98190: LD_ADDR_VAR 0 11
98194: PUSH
98195: DOUBLE
98196: LD_INT 1
98198: DEC
98199: ST_TO_ADDR
98200: LD_VAR 0 4
98204: PUSH
98205: FOR_TO
98206: IFFALSE 98253
// begin hc_class = 13 ;
98208: LD_ADDR_OWVAR 28
98212: PUSH
98213: LD_INT 13
98215: ST_TO_ADDR
// hc_gallery =  ;
98216: LD_ADDR_OWVAR 33
98220: PUSH
98221: LD_STRING 
98223: ST_TO_ADDR
// animal := CreateHuman ;
98224: LD_ADDR_VAR 0 12
98228: PUSH
98229: CALL_OW 44
98233: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98234: LD_VAR 0 12
98238: PPUSH
98239: LD_VAR 0 8
98243: PPUSH
98244: LD_INT 0
98246: PPUSH
98247: CALL 100015 0 3
// end ;
98251: GO 98205
98253: POP
98254: POP
// if fishes then
98255: LD_VAR 0 7
98259: IFFALSE 98326
// for i = 1 to fishes do
98261: LD_ADDR_VAR 0 11
98265: PUSH
98266: DOUBLE
98267: LD_INT 1
98269: DEC
98270: ST_TO_ADDR
98271: LD_VAR 0 7
98275: PUSH
98276: FOR_TO
98277: IFFALSE 98324
// begin hc_class = 20 ;
98279: LD_ADDR_OWVAR 28
98283: PUSH
98284: LD_INT 20
98286: ST_TO_ADDR
// hc_gallery =  ;
98287: LD_ADDR_OWVAR 33
98291: PUSH
98292: LD_STRING 
98294: ST_TO_ADDR
// animal := CreateHuman ;
98295: LD_ADDR_VAR 0 12
98299: PUSH
98300: CALL_OW 44
98304: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98305: LD_VAR 0 12
98309: PPUSH
98310: LD_VAR 0 9
98314: PPUSH
98315: LD_INT 0
98317: PPUSH
98318: CALL 100015 0 3
// end ;
98322: GO 98276
98324: POP
98325: POP
// end ;
98326: LD_VAR 0 10
98330: RET
// export function WantHeal ( sci , unit ) ; begin
98331: LD_INT 0
98333: PPUSH
// if GetTaskList ( sci ) > 0 then
98334: LD_VAR 0 1
98338: PPUSH
98339: CALL_OW 437
98343: PUSH
98344: LD_INT 0
98346: GREATER
98347: IFFALSE 98417
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98349: LD_VAR 0 1
98353: PPUSH
98354: CALL_OW 437
98358: PUSH
98359: LD_INT 1
98361: ARRAY
98362: PUSH
98363: LD_INT 1
98365: ARRAY
98366: PUSH
98367: LD_STRING l
98369: EQUAL
98370: PUSH
98371: LD_VAR 0 1
98375: PPUSH
98376: CALL_OW 437
98380: PUSH
98381: LD_INT 1
98383: ARRAY
98384: PUSH
98385: LD_INT 4
98387: ARRAY
98388: PUSH
98389: LD_VAR 0 2
98393: EQUAL
98394: AND
98395: IFFALSE 98407
// result := true else
98397: LD_ADDR_VAR 0 3
98401: PUSH
98402: LD_INT 1
98404: ST_TO_ADDR
98405: GO 98415
// result := false ;
98407: LD_ADDR_VAR 0 3
98411: PUSH
98412: LD_INT 0
98414: ST_TO_ADDR
// end else
98415: GO 98425
// result := false ;
98417: LD_ADDR_VAR 0 3
98421: PUSH
98422: LD_INT 0
98424: ST_TO_ADDR
// end ;
98425: LD_VAR 0 3
98429: RET
// export function HealTarget ( sci ) ; begin
98430: LD_INT 0
98432: PPUSH
// if not sci then
98433: LD_VAR 0 1
98437: NOT
98438: IFFALSE 98442
// exit ;
98440: GO 98507
// result := 0 ;
98442: LD_ADDR_VAR 0 2
98446: PUSH
98447: LD_INT 0
98449: ST_TO_ADDR
// if GetTaskList ( sci ) then
98450: LD_VAR 0 1
98454: PPUSH
98455: CALL_OW 437
98459: IFFALSE 98507
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98461: LD_VAR 0 1
98465: PPUSH
98466: CALL_OW 437
98470: PUSH
98471: LD_INT 1
98473: ARRAY
98474: PUSH
98475: LD_INT 1
98477: ARRAY
98478: PUSH
98479: LD_STRING l
98481: EQUAL
98482: IFFALSE 98507
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98484: LD_ADDR_VAR 0 2
98488: PUSH
98489: LD_VAR 0 1
98493: PPUSH
98494: CALL_OW 437
98498: PUSH
98499: LD_INT 1
98501: ARRAY
98502: PUSH
98503: LD_INT 4
98505: ARRAY
98506: ST_TO_ADDR
// end ;
98507: LD_VAR 0 2
98511: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98512: LD_INT 0
98514: PPUSH
98515: PPUSH
98516: PPUSH
98517: PPUSH
// if not base_units then
98518: LD_VAR 0 1
98522: NOT
98523: IFFALSE 98527
// exit ;
98525: GO 98614
// result := false ;
98527: LD_ADDR_VAR 0 2
98531: PUSH
98532: LD_INT 0
98534: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98535: LD_ADDR_VAR 0 5
98539: PUSH
98540: LD_VAR 0 1
98544: PPUSH
98545: LD_INT 21
98547: PUSH
98548: LD_INT 3
98550: PUSH
98551: EMPTY
98552: LIST
98553: LIST
98554: PPUSH
98555: CALL_OW 72
98559: ST_TO_ADDR
// if not tmp then
98560: LD_VAR 0 5
98564: NOT
98565: IFFALSE 98569
// exit ;
98567: GO 98614
// for i in tmp do
98569: LD_ADDR_VAR 0 3
98573: PUSH
98574: LD_VAR 0 5
98578: PUSH
98579: FOR_IN
98580: IFFALSE 98612
// begin result := EnemyInRange ( i , 22 ) ;
98582: LD_ADDR_VAR 0 2
98586: PUSH
98587: LD_VAR 0 3
98591: PPUSH
98592: LD_INT 22
98594: PPUSH
98595: CALL 96850 0 2
98599: ST_TO_ADDR
// if result then
98600: LD_VAR 0 2
98604: IFFALSE 98610
// exit ;
98606: POP
98607: POP
98608: GO 98614
// end ;
98610: GO 98579
98612: POP
98613: POP
// end ;
98614: LD_VAR 0 2
98618: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98619: LD_INT 0
98621: PPUSH
98622: PPUSH
// if not units then
98623: LD_VAR 0 1
98627: NOT
98628: IFFALSE 98632
// exit ;
98630: GO 98702
// result := [ ] ;
98632: LD_ADDR_VAR 0 3
98636: PUSH
98637: EMPTY
98638: ST_TO_ADDR
// for i in units do
98639: LD_ADDR_VAR 0 4
98643: PUSH
98644: LD_VAR 0 1
98648: PUSH
98649: FOR_IN
98650: IFFALSE 98700
// if GetTag ( i ) = tag then
98652: LD_VAR 0 4
98656: PPUSH
98657: CALL_OW 110
98661: PUSH
98662: LD_VAR 0 2
98666: EQUAL
98667: IFFALSE 98698
// result := Insert ( result , result + 1 , i ) ;
98669: LD_ADDR_VAR 0 3
98673: PUSH
98674: LD_VAR 0 3
98678: PPUSH
98679: LD_VAR 0 3
98683: PUSH
98684: LD_INT 1
98686: PLUS
98687: PPUSH
98688: LD_VAR 0 4
98692: PPUSH
98693: CALL_OW 2
98697: ST_TO_ADDR
98698: GO 98649
98700: POP
98701: POP
// end ;
98702: LD_VAR 0 3
98706: RET
// export function IsDriver ( un ) ; begin
98707: LD_INT 0
98709: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98710: LD_ADDR_VAR 0 2
98714: PUSH
98715: LD_VAR 0 1
98719: PUSH
98720: LD_INT 55
98722: PUSH
98723: EMPTY
98724: LIST
98725: PPUSH
98726: CALL_OW 69
98730: IN
98731: ST_TO_ADDR
// end ;
98732: LD_VAR 0 2
98736: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98737: LD_INT 0
98739: PPUSH
98740: PPUSH
// list := [ ] ;
98741: LD_ADDR_VAR 0 5
98745: PUSH
98746: EMPTY
98747: ST_TO_ADDR
// case d of 0 :
98748: LD_VAR 0 3
98752: PUSH
98753: LD_INT 0
98755: DOUBLE
98756: EQUAL
98757: IFTRUE 98761
98759: GO 98894
98761: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98762: LD_ADDR_VAR 0 5
98766: PUSH
98767: LD_VAR 0 1
98771: PUSH
98772: LD_INT 4
98774: MINUS
98775: PUSH
98776: LD_VAR 0 2
98780: PUSH
98781: LD_INT 4
98783: MINUS
98784: PUSH
98785: LD_INT 2
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: LIST
98792: PUSH
98793: LD_VAR 0 1
98797: PUSH
98798: LD_INT 3
98800: MINUS
98801: PUSH
98802: LD_VAR 0 2
98806: PUSH
98807: LD_INT 1
98809: PUSH
98810: EMPTY
98811: LIST
98812: LIST
98813: LIST
98814: PUSH
98815: LD_VAR 0 1
98819: PUSH
98820: LD_INT 4
98822: PLUS
98823: PUSH
98824: LD_VAR 0 2
98828: PUSH
98829: LD_INT 4
98831: PUSH
98832: EMPTY
98833: LIST
98834: LIST
98835: LIST
98836: PUSH
98837: LD_VAR 0 1
98841: PUSH
98842: LD_INT 3
98844: PLUS
98845: PUSH
98846: LD_VAR 0 2
98850: PUSH
98851: LD_INT 3
98853: PLUS
98854: PUSH
98855: LD_INT 5
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: LIST
98862: PUSH
98863: LD_VAR 0 1
98867: PUSH
98868: LD_VAR 0 2
98872: PUSH
98873: LD_INT 4
98875: PLUS
98876: PUSH
98877: LD_INT 0
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: LIST
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: LIST
98889: LIST
98890: LIST
98891: ST_TO_ADDR
// end ; 1 :
98892: GO 99592
98894: LD_INT 1
98896: DOUBLE
98897: EQUAL
98898: IFTRUE 98902
98900: GO 99035
98902: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98903: LD_ADDR_VAR 0 5
98907: PUSH
98908: LD_VAR 0 1
98912: PUSH
98913: LD_VAR 0 2
98917: PUSH
98918: LD_INT 4
98920: MINUS
98921: PUSH
98922: LD_INT 3
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: LIST
98929: PUSH
98930: LD_VAR 0 1
98934: PUSH
98935: LD_INT 3
98937: MINUS
98938: PUSH
98939: LD_VAR 0 2
98943: PUSH
98944: LD_INT 3
98946: MINUS
98947: PUSH
98948: LD_INT 2
98950: PUSH
98951: EMPTY
98952: LIST
98953: LIST
98954: LIST
98955: PUSH
98956: LD_VAR 0 1
98960: PUSH
98961: LD_INT 4
98963: MINUS
98964: PUSH
98965: LD_VAR 0 2
98969: PUSH
98970: LD_INT 1
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: LIST
98977: PUSH
98978: LD_VAR 0 1
98982: PUSH
98983: LD_VAR 0 2
98987: PUSH
98988: LD_INT 3
98990: PLUS
98991: PUSH
98992: LD_INT 0
98994: PUSH
98995: EMPTY
98996: LIST
98997: LIST
98998: LIST
98999: PUSH
99000: LD_VAR 0 1
99004: PUSH
99005: LD_INT 4
99007: PLUS
99008: PUSH
99009: LD_VAR 0 2
99013: PUSH
99014: LD_INT 4
99016: PLUS
99017: PUSH
99018: LD_INT 5
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: LIST
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: ST_TO_ADDR
// end ; 2 :
99033: GO 99592
99035: LD_INT 2
99037: DOUBLE
99038: EQUAL
99039: IFTRUE 99043
99041: GO 99172
99043: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99044: LD_ADDR_VAR 0 5
99048: PUSH
99049: LD_VAR 0 1
99053: PUSH
99054: LD_VAR 0 2
99058: PUSH
99059: LD_INT 3
99061: MINUS
99062: PUSH
99063: LD_INT 3
99065: PUSH
99066: EMPTY
99067: LIST
99068: LIST
99069: LIST
99070: PUSH
99071: LD_VAR 0 1
99075: PUSH
99076: LD_INT 4
99078: PLUS
99079: PUSH
99080: LD_VAR 0 2
99084: PUSH
99085: LD_INT 4
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: LIST
99092: PUSH
99093: LD_VAR 0 1
99097: PUSH
99098: LD_VAR 0 2
99102: PUSH
99103: LD_INT 4
99105: PLUS
99106: PUSH
99107: LD_INT 0
99109: PUSH
99110: EMPTY
99111: LIST
99112: LIST
99113: LIST
99114: PUSH
99115: LD_VAR 0 1
99119: PUSH
99120: LD_INT 3
99122: MINUS
99123: PUSH
99124: LD_VAR 0 2
99128: PUSH
99129: LD_INT 1
99131: PUSH
99132: EMPTY
99133: LIST
99134: LIST
99135: LIST
99136: PUSH
99137: LD_VAR 0 1
99141: PUSH
99142: LD_INT 4
99144: MINUS
99145: PUSH
99146: LD_VAR 0 2
99150: PUSH
99151: LD_INT 4
99153: MINUS
99154: PUSH
99155: LD_INT 2
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: LIST
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: ST_TO_ADDR
// end ; 3 :
99170: GO 99592
99172: LD_INT 3
99174: DOUBLE
99175: EQUAL
99176: IFTRUE 99180
99178: GO 99313
99180: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99181: LD_ADDR_VAR 0 5
99185: PUSH
99186: LD_VAR 0 1
99190: PUSH
99191: LD_INT 3
99193: PLUS
99194: PUSH
99195: LD_VAR 0 2
99199: PUSH
99200: LD_INT 4
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: LIST
99207: PUSH
99208: LD_VAR 0 1
99212: PUSH
99213: LD_INT 4
99215: PLUS
99216: PUSH
99217: LD_VAR 0 2
99221: PUSH
99222: LD_INT 4
99224: PLUS
99225: PUSH
99226: LD_INT 5
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: LIST
99233: PUSH
99234: LD_VAR 0 1
99238: PUSH
99239: LD_INT 4
99241: MINUS
99242: PUSH
99243: LD_VAR 0 2
99247: PUSH
99248: LD_INT 1
99250: PUSH
99251: EMPTY
99252: LIST
99253: LIST
99254: LIST
99255: PUSH
99256: LD_VAR 0 1
99260: PUSH
99261: LD_VAR 0 2
99265: PUSH
99266: LD_INT 4
99268: MINUS
99269: PUSH
99270: LD_INT 3
99272: PUSH
99273: EMPTY
99274: LIST
99275: LIST
99276: LIST
99277: PUSH
99278: LD_VAR 0 1
99282: PUSH
99283: LD_INT 3
99285: MINUS
99286: PUSH
99287: LD_VAR 0 2
99291: PUSH
99292: LD_INT 3
99294: MINUS
99295: PUSH
99296: LD_INT 2
99298: PUSH
99299: EMPTY
99300: LIST
99301: LIST
99302: LIST
99303: PUSH
99304: EMPTY
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: ST_TO_ADDR
// end ; 4 :
99311: GO 99592
99313: LD_INT 4
99315: DOUBLE
99316: EQUAL
99317: IFTRUE 99321
99319: GO 99454
99321: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99322: LD_ADDR_VAR 0 5
99326: PUSH
99327: LD_VAR 0 1
99331: PUSH
99332: LD_VAR 0 2
99336: PUSH
99337: LD_INT 4
99339: PLUS
99340: PUSH
99341: LD_INT 0
99343: PUSH
99344: EMPTY
99345: LIST
99346: LIST
99347: LIST
99348: PUSH
99349: LD_VAR 0 1
99353: PUSH
99354: LD_INT 3
99356: PLUS
99357: PUSH
99358: LD_VAR 0 2
99362: PUSH
99363: LD_INT 3
99365: PLUS
99366: PUSH
99367: LD_INT 5
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: LIST
99374: PUSH
99375: LD_VAR 0 1
99379: PUSH
99380: LD_INT 4
99382: PLUS
99383: PUSH
99384: LD_VAR 0 2
99388: PUSH
99389: LD_INT 4
99391: PUSH
99392: EMPTY
99393: LIST
99394: LIST
99395: LIST
99396: PUSH
99397: LD_VAR 0 1
99401: PUSH
99402: LD_VAR 0 2
99406: PUSH
99407: LD_INT 3
99409: MINUS
99410: PUSH
99411: LD_INT 3
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: LIST
99418: PUSH
99419: LD_VAR 0 1
99423: PUSH
99424: LD_INT 4
99426: MINUS
99427: PUSH
99428: LD_VAR 0 2
99432: PUSH
99433: LD_INT 4
99435: MINUS
99436: PUSH
99437: LD_INT 2
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: LIST
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: ST_TO_ADDR
// end ; 5 :
99452: GO 99592
99454: LD_INT 5
99456: DOUBLE
99457: EQUAL
99458: IFTRUE 99462
99460: GO 99591
99462: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99463: LD_ADDR_VAR 0 5
99467: PUSH
99468: LD_VAR 0 1
99472: PUSH
99473: LD_INT 4
99475: MINUS
99476: PUSH
99477: LD_VAR 0 2
99481: PUSH
99482: LD_INT 1
99484: PUSH
99485: EMPTY
99486: LIST
99487: LIST
99488: LIST
99489: PUSH
99490: LD_VAR 0 1
99494: PUSH
99495: LD_VAR 0 2
99499: PUSH
99500: LD_INT 4
99502: MINUS
99503: PUSH
99504: LD_INT 3
99506: PUSH
99507: EMPTY
99508: LIST
99509: LIST
99510: LIST
99511: PUSH
99512: LD_VAR 0 1
99516: PUSH
99517: LD_INT 4
99519: PLUS
99520: PUSH
99521: LD_VAR 0 2
99525: PUSH
99526: LD_INT 4
99528: PLUS
99529: PUSH
99530: LD_INT 5
99532: PUSH
99533: EMPTY
99534: LIST
99535: LIST
99536: LIST
99537: PUSH
99538: LD_VAR 0 1
99542: PUSH
99543: LD_INT 3
99545: PLUS
99546: PUSH
99547: LD_VAR 0 2
99551: PUSH
99552: LD_INT 4
99554: PUSH
99555: EMPTY
99556: LIST
99557: LIST
99558: LIST
99559: PUSH
99560: LD_VAR 0 1
99564: PUSH
99565: LD_VAR 0 2
99569: PUSH
99570: LD_INT 3
99572: PLUS
99573: PUSH
99574: LD_INT 0
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: LIST
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: ST_TO_ADDR
// end ; end ;
99589: GO 99592
99591: POP
// result := list ;
99592: LD_ADDR_VAR 0 4
99596: PUSH
99597: LD_VAR 0 5
99601: ST_TO_ADDR
// end ;
99602: LD_VAR 0 4
99606: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99607: LD_INT 0
99609: PPUSH
99610: PPUSH
99611: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99612: LD_VAR 0 1
99616: NOT
99617: PUSH
99618: LD_VAR 0 2
99622: PUSH
99623: LD_INT 1
99625: PUSH
99626: LD_INT 2
99628: PUSH
99629: LD_INT 3
99631: PUSH
99632: LD_INT 4
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: IN
99641: NOT
99642: OR
99643: IFFALSE 99647
// exit ;
99645: GO 99739
// tmp := [ ] ;
99647: LD_ADDR_VAR 0 5
99651: PUSH
99652: EMPTY
99653: ST_TO_ADDR
// for i in units do
99654: LD_ADDR_VAR 0 4
99658: PUSH
99659: LD_VAR 0 1
99663: PUSH
99664: FOR_IN
99665: IFFALSE 99708
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99667: LD_ADDR_VAR 0 5
99671: PUSH
99672: LD_VAR 0 5
99676: PPUSH
99677: LD_VAR 0 5
99681: PUSH
99682: LD_INT 1
99684: PLUS
99685: PPUSH
99686: LD_VAR 0 4
99690: PPUSH
99691: LD_VAR 0 2
99695: PPUSH
99696: CALL_OW 259
99700: PPUSH
99701: CALL_OW 2
99705: ST_TO_ADDR
99706: GO 99664
99708: POP
99709: POP
// if not tmp then
99710: LD_VAR 0 5
99714: NOT
99715: IFFALSE 99719
// exit ;
99717: GO 99739
// result := SortListByListDesc ( units , tmp ) ;
99719: LD_ADDR_VAR 0 3
99723: PUSH
99724: LD_VAR 0 1
99728: PPUSH
99729: LD_VAR 0 5
99733: PPUSH
99734: CALL_OW 77
99738: ST_TO_ADDR
// end ;
99739: LD_VAR 0 3
99743: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99744: LD_INT 0
99746: PPUSH
99747: PPUSH
99748: PPUSH
// result := false ;
99749: LD_ADDR_VAR 0 3
99753: PUSH
99754: LD_INT 0
99756: ST_TO_ADDR
// x := GetX ( building ) ;
99757: LD_ADDR_VAR 0 4
99761: PUSH
99762: LD_VAR 0 2
99766: PPUSH
99767: CALL_OW 250
99771: ST_TO_ADDR
// y := GetY ( building ) ;
99772: LD_ADDR_VAR 0 5
99776: PUSH
99777: LD_VAR 0 2
99781: PPUSH
99782: CALL_OW 251
99786: ST_TO_ADDR
// if not building or not x or not y then
99787: LD_VAR 0 2
99791: NOT
99792: PUSH
99793: LD_VAR 0 4
99797: NOT
99798: OR
99799: PUSH
99800: LD_VAR 0 5
99804: NOT
99805: OR
99806: IFFALSE 99810
// exit ;
99808: GO 99902
// if GetTaskList ( unit ) then
99810: LD_VAR 0 1
99814: PPUSH
99815: CALL_OW 437
99819: IFFALSE 99902
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99821: LD_STRING e
99823: PUSH
99824: LD_VAR 0 1
99828: PPUSH
99829: CALL_OW 437
99833: PUSH
99834: LD_INT 1
99836: ARRAY
99837: PUSH
99838: LD_INT 1
99840: ARRAY
99841: EQUAL
99842: PUSH
99843: LD_VAR 0 4
99847: PUSH
99848: LD_VAR 0 1
99852: PPUSH
99853: CALL_OW 437
99857: PUSH
99858: LD_INT 1
99860: ARRAY
99861: PUSH
99862: LD_INT 2
99864: ARRAY
99865: EQUAL
99866: AND
99867: PUSH
99868: LD_VAR 0 5
99872: PUSH
99873: LD_VAR 0 1
99877: PPUSH
99878: CALL_OW 437
99882: PUSH
99883: LD_INT 1
99885: ARRAY
99886: PUSH
99887: LD_INT 3
99889: ARRAY
99890: EQUAL
99891: AND
99892: IFFALSE 99902
// result := true end ;
99894: LD_ADDR_VAR 0 3
99898: PUSH
99899: LD_INT 1
99901: ST_TO_ADDR
// end ;
99902: LD_VAR 0 3
99906: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99907: LD_INT 0
99909: PPUSH
// result := false ;
99910: LD_ADDR_VAR 0 4
99914: PUSH
99915: LD_INT 0
99917: ST_TO_ADDR
// if GetTaskList ( unit ) then
99918: LD_VAR 0 1
99922: PPUSH
99923: CALL_OW 437
99927: IFFALSE 100010
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99929: LD_STRING M
99931: PUSH
99932: LD_VAR 0 1
99936: PPUSH
99937: CALL_OW 437
99941: PUSH
99942: LD_INT 1
99944: ARRAY
99945: PUSH
99946: LD_INT 1
99948: ARRAY
99949: EQUAL
99950: PUSH
99951: LD_VAR 0 2
99955: PUSH
99956: LD_VAR 0 1
99960: PPUSH
99961: CALL_OW 437
99965: PUSH
99966: LD_INT 1
99968: ARRAY
99969: PUSH
99970: LD_INT 2
99972: ARRAY
99973: EQUAL
99974: AND
99975: PUSH
99976: LD_VAR 0 3
99980: PUSH
99981: LD_VAR 0 1
99985: PPUSH
99986: CALL_OW 437
99990: PUSH
99991: LD_INT 1
99993: ARRAY
99994: PUSH
99995: LD_INT 3
99997: ARRAY
99998: EQUAL
99999: AND
100000: IFFALSE 100010
// result := true ;
100002: LD_ADDR_VAR 0 4
100006: PUSH
100007: LD_INT 1
100009: ST_TO_ADDR
// end ; end ;
100010: LD_VAR 0 4
100014: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100015: LD_INT 0
100017: PPUSH
100018: PPUSH
100019: PPUSH
100020: PPUSH
// if not unit or not area then
100021: LD_VAR 0 1
100025: NOT
100026: PUSH
100027: LD_VAR 0 2
100031: NOT
100032: OR
100033: IFFALSE 100037
// exit ;
100035: GO 100201
// tmp := AreaToList ( area , i ) ;
100037: LD_ADDR_VAR 0 6
100041: PUSH
100042: LD_VAR 0 2
100046: PPUSH
100047: LD_VAR 0 5
100051: PPUSH
100052: CALL_OW 517
100056: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100057: LD_ADDR_VAR 0 5
100061: PUSH
100062: DOUBLE
100063: LD_INT 1
100065: DEC
100066: ST_TO_ADDR
100067: LD_VAR 0 6
100071: PUSH
100072: LD_INT 1
100074: ARRAY
100075: PUSH
100076: FOR_TO
100077: IFFALSE 100199
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100079: LD_ADDR_VAR 0 7
100083: PUSH
100084: LD_VAR 0 6
100088: PUSH
100089: LD_INT 1
100091: ARRAY
100092: PUSH
100093: LD_VAR 0 5
100097: ARRAY
100098: PUSH
100099: LD_VAR 0 6
100103: PUSH
100104: LD_INT 2
100106: ARRAY
100107: PUSH
100108: LD_VAR 0 5
100112: ARRAY
100113: PUSH
100114: EMPTY
100115: LIST
100116: LIST
100117: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100118: LD_VAR 0 7
100122: PUSH
100123: LD_INT 1
100125: ARRAY
100126: PPUSH
100127: LD_VAR 0 7
100131: PUSH
100132: LD_INT 2
100134: ARRAY
100135: PPUSH
100136: CALL_OW 428
100140: PUSH
100141: LD_INT 0
100143: EQUAL
100144: IFFALSE 100197
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100146: LD_VAR 0 1
100150: PPUSH
100151: LD_VAR 0 7
100155: PUSH
100156: LD_INT 1
100158: ARRAY
100159: PPUSH
100160: LD_VAR 0 7
100164: PUSH
100165: LD_INT 2
100167: ARRAY
100168: PPUSH
100169: LD_VAR 0 3
100173: PPUSH
100174: CALL_OW 48
// result := IsPlaced ( unit ) ;
100178: LD_ADDR_VAR 0 4
100182: PUSH
100183: LD_VAR 0 1
100187: PPUSH
100188: CALL_OW 305
100192: ST_TO_ADDR
// exit ;
100193: POP
100194: POP
100195: GO 100201
// end ; end ;
100197: GO 100076
100199: POP
100200: POP
// end ;
100201: LD_VAR 0 4
100205: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100206: LD_INT 0
100208: PPUSH
100209: PPUSH
100210: PPUSH
// if not side or side > 8 then
100211: LD_VAR 0 1
100215: NOT
100216: PUSH
100217: LD_VAR 0 1
100221: PUSH
100222: LD_INT 8
100224: GREATER
100225: OR
100226: IFFALSE 100230
// exit ;
100228: GO 100417
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100230: LD_ADDR_VAR 0 4
100234: PUSH
100235: LD_INT 22
100237: PUSH
100238: LD_VAR 0 1
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: PUSH
100247: LD_INT 21
100249: PUSH
100250: LD_INT 3
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: PUSH
100257: EMPTY
100258: LIST
100259: LIST
100260: PPUSH
100261: CALL_OW 69
100265: ST_TO_ADDR
// if not tmp then
100266: LD_VAR 0 4
100270: NOT
100271: IFFALSE 100275
// exit ;
100273: GO 100417
// enable_addtolog := true ;
100275: LD_ADDR_OWVAR 81
100279: PUSH
100280: LD_INT 1
100282: ST_TO_ADDR
// AddToLog ( [ ) ;
100283: LD_STRING [
100285: PPUSH
100286: CALL_OW 561
// for i in tmp do
100290: LD_ADDR_VAR 0 3
100294: PUSH
100295: LD_VAR 0 4
100299: PUSH
100300: FOR_IN
100301: IFFALSE 100408
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100303: LD_STRING [
100305: PUSH
100306: LD_VAR 0 3
100310: PPUSH
100311: CALL_OW 266
100315: STR
100316: PUSH
100317: LD_STRING , 
100319: STR
100320: PUSH
100321: LD_VAR 0 3
100325: PPUSH
100326: CALL_OW 250
100330: STR
100331: PUSH
100332: LD_STRING , 
100334: STR
100335: PUSH
100336: LD_VAR 0 3
100340: PPUSH
100341: CALL_OW 251
100345: STR
100346: PUSH
100347: LD_STRING , 
100349: STR
100350: PUSH
100351: LD_VAR 0 3
100355: PPUSH
100356: CALL_OW 254
100360: STR
100361: PUSH
100362: LD_STRING , 
100364: STR
100365: PUSH
100366: LD_VAR 0 3
100370: PPUSH
100371: LD_INT 1
100373: PPUSH
100374: CALL_OW 268
100378: STR
100379: PUSH
100380: LD_STRING , 
100382: STR
100383: PUSH
100384: LD_VAR 0 3
100388: PPUSH
100389: LD_INT 2
100391: PPUSH
100392: CALL_OW 268
100396: STR
100397: PUSH
100398: LD_STRING ],
100400: STR
100401: PPUSH
100402: CALL_OW 561
// end ;
100406: GO 100300
100408: POP
100409: POP
// AddToLog ( ]; ) ;
100410: LD_STRING ];
100412: PPUSH
100413: CALL_OW 561
// end ;
100417: LD_VAR 0 2
100421: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100422: LD_INT 0
100424: PPUSH
100425: PPUSH
100426: PPUSH
100427: PPUSH
100428: PPUSH
// if not area or not rate or not max then
100429: LD_VAR 0 1
100433: NOT
100434: PUSH
100435: LD_VAR 0 2
100439: NOT
100440: OR
100441: PUSH
100442: LD_VAR 0 4
100446: NOT
100447: OR
100448: IFFALSE 100452
// exit ;
100450: GO 100644
// while 1 do
100452: LD_INT 1
100454: IFFALSE 100644
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100456: LD_ADDR_VAR 0 9
100460: PUSH
100461: LD_VAR 0 1
100465: PPUSH
100466: LD_INT 1
100468: PPUSH
100469: CALL_OW 287
100473: PUSH
100474: LD_INT 10
100476: MUL
100477: ST_TO_ADDR
// r := rate / 10 ;
100478: LD_ADDR_VAR 0 7
100482: PUSH
100483: LD_VAR 0 2
100487: PUSH
100488: LD_INT 10
100490: DIVREAL
100491: ST_TO_ADDR
// time := 1 1$00 ;
100492: LD_ADDR_VAR 0 8
100496: PUSH
100497: LD_INT 2100
100499: ST_TO_ADDR
// if amount < min then
100500: LD_VAR 0 9
100504: PUSH
100505: LD_VAR 0 3
100509: LESS
100510: IFFALSE 100528
// r := r * 2 else
100512: LD_ADDR_VAR 0 7
100516: PUSH
100517: LD_VAR 0 7
100521: PUSH
100522: LD_INT 2
100524: MUL
100525: ST_TO_ADDR
100526: GO 100554
// if amount > max then
100528: LD_VAR 0 9
100532: PUSH
100533: LD_VAR 0 4
100537: GREATER
100538: IFFALSE 100554
// r := r / 2 ;
100540: LD_ADDR_VAR 0 7
100544: PUSH
100545: LD_VAR 0 7
100549: PUSH
100550: LD_INT 2
100552: DIVREAL
100553: ST_TO_ADDR
// time := time / r ;
100554: LD_ADDR_VAR 0 8
100558: PUSH
100559: LD_VAR 0 8
100563: PUSH
100564: LD_VAR 0 7
100568: DIVREAL
100569: ST_TO_ADDR
// if time < 0 then
100570: LD_VAR 0 8
100574: PUSH
100575: LD_INT 0
100577: LESS
100578: IFFALSE 100595
// time := time * - 1 ;
100580: LD_ADDR_VAR 0 8
100584: PUSH
100585: LD_VAR 0 8
100589: PUSH
100590: LD_INT 1
100592: NEG
100593: MUL
100594: ST_TO_ADDR
// wait ( time ) ;
100595: LD_VAR 0 8
100599: PPUSH
100600: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100604: LD_INT 35
100606: PPUSH
100607: LD_INT 875
100609: PPUSH
100610: CALL_OW 12
100614: PPUSH
100615: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100619: LD_INT 1
100621: PPUSH
100622: LD_INT 5
100624: PPUSH
100625: CALL_OW 12
100629: PPUSH
100630: LD_VAR 0 1
100634: PPUSH
100635: LD_INT 1
100637: PPUSH
100638: CALL_OW 55
// end ;
100642: GO 100452
// end ;
100644: LD_VAR 0 5
100648: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100649: LD_INT 0
100651: PPUSH
100652: PPUSH
100653: PPUSH
100654: PPUSH
100655: PPUSH
100656: PPUSH
100657: PPUSH
100658: PPUSH
// if not turrets or not factories then
100659: LD_VAR 0 1
100663: NOT
100664: PUSH
100665: LD_VAR 0 2
100669: NOT
100670: OR
100671: IFFALSE 100675
// exit ;
100673: GO 100982
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100675: LD_ADDR_VAR 0 10
100679: PUSH
100680: LD_INT 5
100682: PUSH
100683: LD_INT 6
100685: PUSH
100686: EMPTY
100687: LIST
100688: LIST
100689: PUSH
100690: LD_INT 2
100692: PUSH
100693: LD_INT 4
100695: PUSH
100696: EMPTY
100697: LIST
100698: LIST
100699: PUSH
100700: LD_INT 3
100702: PUSH
100703: LD_INT 5
100705: PUSH
100706: EMPTY
100707: LIST
100708: LIST
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: LIST
100714: PUSH
100715: LD_INT 24
100717: PUSH
100718: LD_INT 25
100720: PUSH
100721: EMPTY
100722: LIST
100723: LIST
100724: PUSH
100725: LD_INT 23
100727: PUSH
100728: LD_INT 27
100730: PUSH
100731: EMPTY
100732: LIST
100733: LIST
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PUSH
100739: LD_INT 42
100741: PUSH
100742: LD_INT 43
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: PUSH
100749: LD_INT 44
100751: PUSH
100752: LD_INT 46
100754: PUSH
100755: EMPTY
100756: LIST
100757: LIST
100758: PUSH
100759: LD_INT 45
100761: PUSH
100762: LD_INT 47
100764: PUSH
100765: EMPTY
100766: LIST
100767: LIST
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: LIST
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: LIST
100778: ST_TO_ADDR
// result := [ ] ;
100779: LD_ADDR_VAR 0 3
100783: PUSH
100784: EMPTY
100785: ST_TO_ADDR
// for i in turrets do
100786: LD_ADDR_VAR 0 4
100790: PUSH
100791: LD_VAR 0 1
100795: PUSH
100796: FOR_IN
100797: IFFALSE 100980
// begin nat := GetNation ( i ) ;
100799: LD_ADDR_VAR 0 7
100803: PUSH
100804: LD_VAR 0 4
100808: PPUSH
100809: CALL_OW 248
100813: ST_TO_ADDR
// weapon := 0 ;
100814: LD_ADDR_VAR 0 8
100818: PUSH
100819: LD_INT 0
100821: ST_TO_ADDR
// if not nat then
100822: LD_VAR 0 7
100826: NOT
100827: IFFALSE 100831
// continue ;
100829: GO 100796
// for j in list [ nat ] do
100831: LD_ADDR_VAR 0 5
100835: PUSH
100836: LD_VAR 0 10
100840: PUSH
100841: LD_VAR 0 7
100845: ARRAY
100846: PUSH
100847: FOR_IN
100848: IFFALSE 100889
// if GetBWeapon ( i ) = j [ 1 ] then
100850: LD_VAR 0 4
100854: PPUSH
100855: CALL_OW 269
100859: PUSH
100860: LD_VAR 0 5
100864: PUSH
100865: LD_INT 1
100867: ARRAY
100868: EQUAL
100869: IFFALSE 100887
// begin weapon := j [ 2 ] ;
100871: LD_ADDR_VAR 0 8
100875: PUSH
100876: LD_VAR 0 5
100880: PUSH
100881: LD_INT 2
100883: ARRAY
100884: ST_TO_ADDR
// break ;
100885: GO 100889
// end ;
100887: GO 100847
100889: POP
100890: POP
// if not weapon then
100891: LD_VAR 0 8
100895: NOT
100896: IFFALSE 100900
// continue ;
100898: GO 100796
// for k in factories do
100900: LD_ADDR_VAR 0 6
100904: PUSH
100905: LD_VAR 0 2
100909: PUSH
100910: FOR_IN
100911: IFFALSE 100976
// begin weapons := AvailableWeaponList ( k ) ;
100913: LD_ADDR_VAR 0 9
100917: PUSH
100918: LD_VAR 0 6
100922: PPUSH
100923: CALL_OW 478
100927: ST_TO_ADDR
// if not weapons then
100928: LD_VAR 0 9
100932: NOT
100933: IFFALSE 100937
// continue ;
100935: GO 100910
// if weapon in weapons then
100937: LD_VAR 0 8
100941: PUSH
100942: LD_VAR 0 9
100946: IN
100947: IFFALSE 100974
// begin result := [ i , weapon ] ;
100949: LD_ADDR_VAR 0 3
100953: PUSH
100954: LD_VAR 0 4
100958: PUSH
100959: LD_VAR 0 8
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: ST_TO_ADDR
// exit ;
100968: POP
100969: POP
100970: POP
100971: POP
100972: GO 100982
// end ; end ;
100974: GO 100910
100976: POP
100977: POP
// end ;
100978: GO 100796
100980: POP
100981: POP
// end ;
100982: LD_VAR 0 3
100986: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100987: LD_INT 0
100989: PPUSH
// if not side or side > 8 then
100990: LD_VAR 0 3
100994: NOT
100995: PUSH
100996: LD_VAR 0 3
101000: PUSH
101001: LD_INT 8
101003: GREATER
101004: OR
101005: IFFALSE 101009
// exit ;
101007: GO 101068
// if not range then
101009: LD_VAR 0 4
101013: NOT
101014: IFFALSE 101025
// range := - 12 ;
101016: LD_ADDR_VAR 0 4
101020: PUSH
101021: LD_INT 12
101023: NEG
101024: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101025: LD_VAR 0 1
101029: PPUSH
101030: LD_VAR 0 2
101034: PPUSH
101035: LD_VAR 0 3
101039: PPUSH
101040: LD_VAR 0 4
101044: PPUSH
101045: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101049: LD_VAR 0 1
101053: PPUSH
101054: LD_VAR 0 2
101058: PPUSH
101059: LD_VAR 0 3
101063: PPUSH
101064: CALL_OW 331
// end ;
101068: LD_VAR 0 5
101072: RET
// export function Video ( mode ) ; begin
101073: LD_INT 0
101075: PPUSH
// ingame_video = mode ;
101076: LD_ADDR_OWVAR 52
101080: PUSH
101081: LD_VAR 0 1
101085: ST_TO_ADDR
// interface_hidden = mode ;
101086: LD_ADDR_OWVAR 54
101090: PUSH
101091: LD_VAR 0 1
101095: ST_TO_ADDR
// end ;
101096: LD_VAR 0 2
101100: RET
// export function Join ( array , element ) ; begin
101101: LD_INT 0
101103: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101104: LD_ADDR_VAR 0 3
101108: PUSH
101109: LD_VAR 0 1
101113: PPUSH
101114: LD_VAR 0 1
101118: PUSH
101119: LD_INT 1
101121: PLUS
101122: PPUSH
101123: LD_VAR 0 2
101127: PPUSH
101128: CALL_OW 1
101132: ST_TO_ADDR
// end ;
101133: LD_VAR 0 3
101137: RET
// export function JoinUnion ( array , element ) ; begin
101138: LD_INT 0
101140: PPUSH
// result := array union element ;
101141: LD_ADDR_VAR 0 3
101145: PUSH
101146: LD_VAR 0 1
101150: PUSH
101151: LD_VAR 0 2
101155: UNION
101156: ST_TO_ADDR
// end ;
101157: LD_VAR 0 3
101161: RET
// export function GetBehemoths ( side ) ; begin
101162: LD_INT 0
101164: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101165: LD_ADDR_VAR 0 2
101169: PUSH
101170: LD_INT 22
101172: PUSH
101173: LD_VAR 0 1
101177: PUSH
101178: EMPTY
101179: LIST
101180: LIST
101181: PUSH
101182: LD_INT 31
101184: PUSH
101185: LD_INT 25
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: PUSH
101192: EMPTY
101193: LIST
101194: LIST
101195: PPUSH
101196: CALL_OW 69
101200: ST_TO_ADDR
// end ;
101201: LD_VAR 0 2
101205: RET
// export function Shuffle ( array ) ; var i , index ; begin
101206: LD_INT 0
101208: PPUSH
101209: PPUSH
101210: PPUSH
// result := [ ] ;
101211: LD_ADDR_VAR 0 2
101215: PUSH
101216: EMPTY
101217: ST_TO_ADDR
// if not array then
101218: LD_VAR 0 1
101222: NOT
101223: IFFALSE 101227
// exit ;
101225: GO 101326
// Randomize ;
101227: CALL_OW 10
// for i = array downto 1 do
101231: LD_ADDR_VAR 0 3
101235: PUSH
101236: DOUBLE
101237: LD_VAR 0 1
101241: INC
101242: ST_TO_ADDR
101243: LD_INT 1
101245: PUSH
101246: FOR_DOWNTO
101247: IFFALSE 101324
// begin index := rand ( 1 , array ) ;
101249: LD_ADDR_VAR 0 4
101253: PUSH
101254: LD_INT 1
101256: PPUSH
101257: LD_VAR 0 1
101261: PPUSH
101262: CALL_OW 12
101266: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101267: LD_ADDR_VAR 0 2
101271: PUSH
101272: LD_VAR 0 2
101276: PPUSH
101277: LD_VAR 0 2
101281: PUSH
101282: LD_INT 1
101284: PLUS
101285: PPUSH
101286: LD_VAR 0 1
101290: PUSH
101291: LD_VAR 0 4
101295: ARRAY
101296: PPUSH
101297: CALL_OW 2
101301: ST_TO_ADDR
// array := Delete ( array , index ) ;
101302: LD_ADDR_VAR 0 1
101306: PUSH
101307: LD_VAR 0 1
101311: PPUSH
101312: LD_VAR 0 4
101316: PPUSH
101317: CALL_OW 3
101321: ST_TO_ADDR
// end ;
101322: GO 101246
101324: POP
101325: POP
// end ;
101326: LD_VAR 0 2
101330: RET
// export function GetBaseMaterials ( base ) ; begin
101331: LD_INT 0
101333: PPUSH
// result := [ 0 , 0 , 0 ] ;
101334: LD_ADDR_VAR 0 2
101338: PUSH
101339: LD_INT 0
101341: PUSH
101342: LD_INT 0
101344: PUSH
101345: LD_INT 0
101347: PUSH
101348: EMPTY
101349: LIST
101350: LIST
101351: LIST
101352: ST_TO_ADDR
// if not base then
101353: LD_VAR 0 1
101357: NOT
101358: IFFALSE 101362
// exit ;
101360: GO 101411
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101362: LD_ADDR_VAR 0 2
101366: PUSH
101367: LD_VAR 0 1
101371: PPUSH
101372: LD_INT 1
101374: PPUSH
101375: CALL_OW 275
101379: PUSH
101380: LD_VAR 0 1
101384: PPUSH
101385: LD_INT 2
101387: PPUSH
101388: CALL_OW 275
101392: PUSH
101393: LD_VAR 0 1
101397: PPUSH
101398: LD_INT 3
101400: PPUSH
101401: CALL_OW 275
101405: PUSH
101406: EMPTY
101407: LIST
101408: LIST
101409: LIST
101410: ST_TO_ADDR
// end ;
101411: LD_VAR 0 2
101415: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101416: LD_INT 0
101418: PPUSH
101419: PPUSH
// result := array ;
101420: LD_ADDR_VAR 0 3
101424: PUSH
101425: LD_VAR 0 1
101429: ST_TO_ADDR
// if size > 0 then
101430: LD_VAR 0 2
101434: PUSH
101435: LD_INT 0
101437: GREATER
101438: IFFALSE 101484
// for i := array downto size do
101440: LD_ADDR_VAR 0 4
101444: PUSH
101445: DOUBLE
101446: LD_VAR 0 1
101450: INC
101451: ST_TO_ADDR
101452: LD_VAR 0 2
101456: PUSH
101457: FOR_DOWNTO
101458: IFFALSE 101482
// result := Delete ( result , result ) ;
101460: LD_ADDR_VAR 0 3
101464: PUSH
101465: LD_VAR 0 3
101469: PPUSH
101470: LD_VAR 0 3
101474: PPUSH
101475: CALL_OW 3
101479: ST_TO_ADDR
101480: GO 101457
101482: POP
101483: POP
// end ;
101484: LD_VAR 0 3
101488: RET
// export function ComExit ( unit ) ; var tmp ; begin
101489: LD_INT 0
101491: PPUSH
101492: PPUSH
// if not IsInUnit ( unit ) then
101493: LD_VAR 0 1
101497: PPUSH
101498: CALL_OW 310
101502: NOT
101503: IFFALSE 101507
// exit ;
101505: GO 101567
// tmp := IsInUnit ( unit ) ;
101507: LD_ADDR_VAR 0 3
101511: PUSH
101512: LD_VAR 0 1
101516: PPUSH
101517: CALL_OW 310
101521: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101522: LD_VAR 0 3
101526: PPUSH
101527: CALL_OW 247
101531: PUSH
101532: LD_INT 2
101534: EQUAL
101535: IFFALSE 101548
// ComExitVehicle ( unit ) else
101537: LD_VAR 0 1
101541: PPUSH
101542: CALL_OW 121
101546: GO 101557
// ComExitBuilding ( unit ) ;
101548: LD_VAR 0 1
101552: PPUSH
101553: CALL_OW 122
// result := tmp ;
101557: LD_ADDR_VAR 0 2
101561: PUSH
101562: LD_VAR 0 3
101566: ST_TO_ADDR
// end ;
101567: LD_VAR 0 2
101571: RET
// export function ResetHc ; begin
101572: LD_INT 0
101574: PPUSH
// InitHc ;
101575: CALL_OW 19
// hc_importance := 0 ;
101579: LD_ADDR_OWVAR 32
101583: PUSH
101584: LD_INT 0
101586: ST_TO_ADDR
// end ;
101587: LD_VAR 0 1
101591: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101592: LD_INT 0
101594: PPUSH
101595: PPUSH
101596: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101597: LD_ADDR_VAR 0 6
101601: PUSH
101602: LD_VAR 0 1
101606: PUSH
101607: LD_VAR 0 3
101611: PLUS
101612: PUSH
101613: LD_INT 2
101615: DIV
101616: ST_TO_ADDR
// if _x < 0 then
101617: LD_VAR 0 6
101621: PUSH
101622: LD_INT 0
101624: LESS
101625: IFFALSE 101642
// _x := _x * - 1 ;
101627: LD_ADDR_VAR 0 6
101631: PUSH
101632: LD_VAR 0 6
101636: PUSH
101637: LD_INT 1
101639: NEG
101640: MUL
101641: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101642: LD_ADDR_VAR 0 7
101646: PUSH
101647: LD_VAR 0 2
101651: PUSH
101652: LD_VAR 0 4
101656: PLUS
101657: PUSH
101658: LD_INT 2
101660: DIV
101661: ST_TO_ADDR
// if _y < 0 then
101662: LD_VAR 0 7
101666: PUSH
101667: LD_INT 0
101669: LESS
101670: IFFALSE 101687
// _y := _y * - 1 ;
101672: LD_ADDR_VAR 0 7
101676: PUSH
101677: LD_VAR 0 7
101681: PUSH
101682: LD_INT 1
101684: NEG
101685: MUL
101686: ST_TO_ADDR
// result := [ _x , _y ] ;
101687: LD_ADDR_VAR 0 5
101691: PUSH
101692: LD_VAR 0 6
101696: PUSH
101697: LD_VAR 0 7
101701: PUSH
101702: EMPTY
101703: LIST
101704: LIST
101705: ST_TO_ADDR
// end ;
101706: LD_VAR 0 5
101710: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101711: LD_INT 0
101713: PPUSH
101714: PPUSH
101715: PPUSH
101716: PPUSH
// task := GetTaskList ( unit ) ;
101717: LD_ADDR_VAR 0 7
101721: PUSH
101722: LD_VAR 0 1
101726: PPUSH
101727: CALL_OW 437
101731: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101732: LD_VAR 0 7
101736: NOT
101737: PUSH
101738: LD_VAR 0 1
101742: PPUSH
101743: LD_VAR 0 2
101747: PPUSH
101748: CALL_OW 308
101752: NOT
101753: AND
101754: IFFALSE 101758
// exit ;
101756: GO 101876
// if IsInArea ( unit , area ) then
101758: LD_VAR 0 1
101762: PPUSH
101763: LD_VAR 0 2
101767: PPUSH
101768: CALL_OW 308
101772: IFFALSE 101790
// begin ComMoveToArea ( unit , goAway ) ;
101774: LD_VAR 0 1
101778: PPUSH
101779: LD_VAR 0 3
101783: PPUSH
101784: CALL_OW 113
// exit ;
101788: GO 101876
// end ; if task [ 1 ] [ 1 ] <> M then
101790: LD_VAR 0 7
101794: PUSH
101795: LD_INT 1
101797: ARRAY
101798: PUSH
101799: LD_INT 1
101801: ARRAY
101802: PUSH
101803: LD_STRING M
101805: NONEQUAL
101806: IFFALSE 101810
// exit ;
101808: GO 101876
// x := task [ 1 ] [ 2 ] ;
101810: LD_ADDR_VAR 0 5
101814: PUSH
101815: LD_VAR 0 7
101819: PUSH
101820: LD_INT 1
101822: ARRAY
101823: PUSH
101824: LD_INT 2
101826: ARRAY
101827: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101828: LD_ADDR_VAR 0 6
101832: PUSH
101833: LD_VAR 0 7
101837: PUSH
101838: LD_INT 1
101840: ARRAY
101841: PUSH
101842: LD_INT 3
101844: ARRAY
101845: ST_TO_ADDR
// if InArea ( x , y , area ) then
101846: LD_VAR 0 5
101850: PPUSH
101851: LD_VAR 0 6
101855: PPUSH
101856: LD_VAR 0 2
101860: PPUSH
101861: CALL_OW 309
101865: IFFALSE 101876
// ComStop ( unit ) ;
101867: LD_VAR 0 1
101871: PPUSH
101872: CALL_OW 141
// end ;
101876: LD_VAR 0 4
101880: RET
// export function Abs ( value ) ; begin
101881: LD_INT 0
101883: PPUSH
// result := value ;
101884: LD_ADDR_VAR 0 2
101888: PUSH
101889: LD_VAR 0 1
101893: ST_TO_ADDR
// if value < 0 then
101894: LD_VAR 0 1
101898: PUSH
101899: LD_INT 0
101901: LESS
101902: IFFALSE 101919
// result := value * - 1 ;
101904: LD_ADDR_VAR 0 2
101908: PUSH
101909: LD_VAR 0 1
101913: PUSH
101914: LD_INT 1
101916: NEG
101917: MUL
101918: ST_TO_ADDR
// end ; end_of_file end_of_file
101919: LD_VAR 0 2
101923: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
101924: LD_VAR 0 2
101928: PUSH
101929: LD_INT 100
101931: EQUAL
101932: IFFALSE 102881
// begin if not StreamModeActive then
101934: LD_EXP 156
101938: NOT
101939: IFFALSE 101949
// StreamModeActive := true ;
101941: LD_ADDR_EXP 156
101945: PUSH
101946: LD_INT 1
101948: ST_TO_ADDR
// if p3 = 0 then
101949: LD_VAR 0 3
101953: PUSH
101954: LD_INT 0
101956: EQUAL
101957: IFFALSE 101963
// InitStreamMode ;
101959: CALL 103039 0 0
// if p3 = 1 then
101963: LD_VAR 0 3
101967: PUSH
101968: LD_INT 1
101970: EQUAL
101971: IFFALSE 101981
// sRocket := true ;
101973: LD_ADDR_EXP 161
101977: PUSH
101978: LD_INT 1
101980: ST_TO_ADDR
// if p3 = 2 then
101981: LD_VAR 0 3
101985: PUSH
101986: LD_INT 2
101988: EQUAL
101989: IFFALSE 101999
// sSpeed := true ;
101991: LD_ADDR_EXP 160
101995: PUSH
101996: LD_INT 1
101998: ST_TO_ADDR
// if p3 = 3 then
101999: LD_VAR 0 3
102003: PUSH
102004: LD_INT 3
102006: EQUAL
102007: IFFALSE 102017
// sEngine := true ;
102009: LD_ADDR_EXP 162
102013: PUSH
102014: LD_INT 1
102016: ST_TO_ADDR
// if p3 = 4 then
102017: LD_VAR 0 3
102021: PUSH
102022: LD_INT 4
102024: EQUAL
102025: IFFALSE 102035
// sSpec := true ;
102027: LD_ADDR_EXP 159
102031: PUSH
102032: LD_INT 1
102034: ST_TO_ADDR
// if p3 = 5 then
102035: LD_VAR 0 3
102039: PUSH
102040: LD_INT 5
102042: EQUAL
102043: IFFALSE 102053
// sLevel := true ;
102045: LD_ADDR_EXP 163
102049: PUSH
102050: LD_INT 1
102052: ST_TO_ADDR
// if p3 = 6 then
102053: LD_VAR 0 3
102057: PUSH
102058: LD_INT 6
102060: EQUAL
102061: IFFALSE 102071
// sArmoury := true ;
102063: LD_ADDR_EXP 164
102067: PUSH
102068: LD_INT 1
102070: ST_TO_ADDR
// if p3 = 7 then
102071: LD_VAR 0 3
102075: PUSH
102076: LD_INT 7
102078: EQUAL
102079: IFFALSE 102089
// sRadar := true ;
102081: LD_ADDR_EXP 165
102085: PUSH
102086: LD_INT 1
102088: ST_TO_ADDR
// if p3 = 8 then
102089: LD_VAR 0 3
102093: PUSH
102094: LD_INT 8
102096: EQUAL
102097: IFFALSE 102107
// sBunker := true ;
102099: LD_ADDR_EXP 166
102103: PUSH
102104: LD_INT 1
102106: ST_TO_ADDR
// if p3 = 9 then
102107: LD_VAR 0 3
102111: PUSH
102112: LD_INT 9
102114: EQUAL
102115: IFFALSE 102125
// sHack := true ;
102117: LD_ADDR_EXP 167
102121: PUSH
102122: LD_INT 1
102124: ST_TO_ADDR
// if p3 = 10 then
102125: LD_VAR 0 3
102129: PUSH
102130: LD_INT 10
102132: EQUAL
102133: IFFALSE 102143
// sFire := true ;
102135: LD_ADDR_EXP 168
102139: PUSH
102140: LD_INT 1
102142: ST_TO_ADDR
// if p3 = 11 then
102143: LD_VAR 0 3
102147: PUSH
102148: LD_INT 11
102150: EQUAL
102151: IFFALSE 102161
// sRefresh := true ;
102153: LD_ADDR_EXP 169
102157: PUSH
102158: LD_INT 1
102160: ST_TO_ADDR
// if p3 = 12 then
102161: LD_VAR 0 3
102165: PUSH
102166: LD_INT 12
102168: EQUAL
102169: IFFALSE 102179
// sExp := true ;
102171: LD_ADDR_EXP 170
102175: PUSH
102176: LD_INT 1
102178: ST_TO_ADDR
// if p3 = 13 then
102179: LD_VAR 0 3
102183: PUSH
102184: LD_INT 13
102186: EQUAL
102187: IFFALSE 102197
// sDepot := true ;
102189: LD_ADDR_EXP 171
102193: PUSH
102194: LD_INT 1
102196: ST_TO_ADDR
// if p3 = 14 then
102197: LD_VAR 0 3
102201: PUSH
102202: LD_INT 14
102204: EQUAL
102205: IFFALSE 102215
// sFlag := true ;
102207: LD_ADDR_EXP 172
102211: PUSH
102212: LD_INT 1
102214: ST_TO_ADDR
// if p3 = 15 then
102215: LD_VAR 0 3
102219: PUSH
102220: LD_INT 15
102222: EQUAL
102223: IFFALSE 102233
// sKamikadze := true ;
102225: LD_ADDR_EXP 180
102229: PUSH
102230: LD_INT 1
102232: ST_TO_ADDR
// if p3 = 16 then
102233: LD_VAR 0 3
102237: PUSH
102238: LD_INT 16
102240: EQUAL
102241: IFFALSE 102251
// sTroll := true ;
102243: LD_ADDR_EXP 181
102247: PUSH
102248: LD_INT 1
102250: ST_TO_ADDR
// if p3 = 17 then
102251: LD_VAR 0 3
102255: PUSH
102256: LD_INT 17
102258: EQUAL
102259: IFFALSE 102269
// sSlow := true ;
102261: LD_ADDR_EXP 182
102265: PUSH
102266: LD_INT 1
102268: ST_TO_ADDR
// if p3 = 18 then
102269: LD_VAR 0 3
102273: PUSH
102274: LD_INT 18
102276: EQUAL
102277: IFFALSE 102287
// sLack := true ;
102279: LD_ADDR_EXP 183
102283: PUSH
102284: LD_INT 1
102286: ST_TO_ADDR
// if p3 = 19 then
102287: LD_VAR 0 3
102291: PUSH
102292: LD_INT 19
102294: EQUAL
102295: IFFALSE 102305
// sTank := true ;
102297: LD_ADDR_EXP 185
102301: PUSH
102302: LD_INT 1
102304: ST_TO_ADDR
// if p3 = 20 then
102305: LD_VAR 0 3
102309: PUSH
102310: LD_INT 20
102312: EQUAL
102313: IFFALSE 102323
// sRemote := true ;
102315: LD_ADDR_EXP 186
102319: PUSH
102320: LD_INT 1
102322: ST_TO_ADDR
// if p3 = 21 then
102323: LD_VAR 0 3
102327: PUSH
102328: LD_INT 21
102330: EQUAL
102331: IFFALSE 102341
// sPowell := true ;
102333: LD_ADDR_EXP 187
102337: PUSH
102338: LD_INT 1
102340: ST_TO_ADDR
// if p3 = 22 then
102341: LD_VAR 0 3
102345: PUSH
102346: LD_INT 22
102348: EQUAL
102349: IFFALSE 102359
// sTeleport := true ;
102351: LD_ADDR_EXP 190
102355: PUSH
102356: LD_INT 1
102358: ST_TO_ADDR
// if p3 = 23 then
102359: LD_VAR 0 3
102363: PUSH
102364: LD_INT 23
102366: EQUAL
102367: IFFALSE 102377
// sOilTower := true ;
102369: LD_ADDR_EXP 192
102373: PUSH
102374: LD_INT 1
102376: ST_TO_ADDR
// if p3 = 24 then
102377: LD_VAR 0 3
102381: PUSH
102382: LD_INT 24
102384: EQUAL
102385: IFFALSE 102395
// sShovel := true ;
102387: LD_ADDR_EXP 193
102391: PUSH
102392: LD_INT 1
102394: ST_TO_ADDR
// if p3 = 25 then
102395: LD_VAR 0 3
102399: PUSH
102400: LD_INT 25
102402: EQUAL
102403: IFFALSE 102413
// sSheik := true ;
102405: LD_ADDR_EXP 194
102409: PUSH
102410: LD_INT 1
102412: ST_TO_ADDR
// if p3 = 26 then
102413: LD_VAR 0 3
102417: PUSH
102418: LD_INT 26
102420: EQUAL
102421: IFFALSE 102431
// sEarthquake := true ;
102423: LD_ADDR_EXP 196
102427: PUSH
102428: LD_INT 1
102430: ST_TO_ADDR
// if p3 = 27 then
102431: LD_VAR 0 3
102435: PUSH
102436: LD_INT 27
102438: EQUAL
102439: IFFALSE 102449
// sAI := true ;
102441: LD_ADDR_EXP 197
102445: PUSH
102446: LD_INT 1
102448: ST_TO_ADDR
// if p3 = 28 then
102449: LD_VAR 0 3
102453: PUSH
102454: LD_INT 28
102456: EQUAL
102457: IFFALSE 102467
// sCargo := true ;
102459: LD_ADDR_EXP 200
102463: PUSH
102464: LD_INT 1
102466: ST_TO_ADDR
// if p3 = 29 then
102467: LD_VAR 0 3
102471: PUSH
102472: LD_INT 29
102474: EQUAL
102475: IFFALSE 102485
// sDLaser := true ;
102477: LD_ADDR_EXP 201
102481: PUSH
102482: LD_INT 1
102484: ST_TO_ADDR
// if p3 = 30 then
102485: LD_VAR 0 3
102489: PUSH
102490: LD_INT 30
102492: EQUAL
102493: IFFALSE 102503
// sExchange := true ;
102495: LD_ADDR_EXP 202
102499: PUSH
102500: LD_INT 1
102502: ST_TO_ADDR
// if p3 = 31 then
102503: LD_VAR 0 3
102507: PUSH
102508: LD_INT 31
102510: EQUAL
102511: IFFALSE 102521
// sFac := true ;
102513: LD_ADDR_EXP 203
102517: PUSH
102518: LD_INT 1
102520: ST_TO_ADDR
// if p3 = 32 then
102521: LD_VAR 0 3
102525: PUSH
102526: LD_INT 32
102528: EQUAL
102529: IFFALSE 102539
// sPower := true ;
102531: LD_ADDR_EXP 204
102535: PUSH
102536: LD_INT 1
102538: ST_TO_ADDR
// if p3 = 33 then
102539: LD_VAR 0 3
102543: PUSH
102544: LD_INT 33
102546: EQUAL
102547: IFFALSE 102557
// sRandom := true ;
102549: LD_ADDR_EXP 205
102553: PUSH
102554: LD_INT 1
102556: ST_TO_ADDR
// if p3 = 34 then
102557: LD_VAR 0 3
102561: PUSH
102562: LD_INT 34
102564: EQUAL
102565: IFFALSE 102575
// sShield := true ;
102567: LD_ADDR_EXP 206
102571: PUSH
102572: LD_INT 1
102574: ST_TO_ADDR
// if p3 = 35 then
102575: LD_VAR 0 3
102579: PUSH
102580: LD_INT 35
102582: EQUAL
102583: IFFALSE 102593
// sTime := true ;
102585: LD_ADDR_EXP 207
102589: PUSH
102590: LD_INT 1
102592: ST_TO_ADDR
// if p3 = 36 then
102593: LD_VAR 0 3
102597: PUSH
102598: LD_INT 36
102600: EQUAL
102601: IFFALSE 102611
// sTools := true ;
102603: LD_ADDR_EXP 208
102607: PUSH
102608: LD_INT 1
102610: ST_TO_ADDR
// if p3 = 101 then
102611: LD_VAR 0 3
102615: PUSH
102616: LD_INT 101
102618: EQUAL
102619: IFFALSE 102629
// sSold := true ;
102621: LD_ADDR_EXP 173
102625: PUSH
102626: LD_INT 1
102628: ST_TO_ADDR
// if p3 = 102 then
102629: LD_VAR 0 3
102633: PUSH
102634: LD_INT 102
102636: EQUAL
102637: IFFALSE 102647
// sDiff := true ;
102639: LD_ADDR_EXP 174
102643: PUSH
102644: LD_INT 1
102646: ST_TO_ADDR
// if p3 = 103 then
102647: LD_VAR 0 3
102651: PUSH
102652: LD_INT 103
102654: EQUAL
102655: IFFALSE 102665
// sFog := true ;
102657: LD_ADDR_EXP 177
102661: PUSH
102662: LD_INT 1
102664: ST_TO_ADDR
// if p3 = 104 then
102665: LD_VAR 0 3
102669: PUSH
102670: LD_INT 104
102672: EQUAL
102673: IFFALSE 102683
// sReset := true ;
102675: LD_ADDR_EXP 178
102679: PUSH
102680: LD_INT 1
102682: ST_TO_ADDR
// if p3 = 105 then
102683: LD_VAR 0 3
102687: PUSH
102688: LD_INT 105
102690: EQUAL
102691: IFFALSE 102701
// sSun := true ;
102693: LD_ADDR_EXP 179
102697: PUSH
102698: LD_INT 1
102700: ST_TO_ADDR
// if p3 = 106 then
102701: LD_VAR 0 3
102705: PUSH
102706: LD_INT 106
102708: EQUAL
102709: IFFALSE 102719
// sTiger := true ;
102711: LD_ADDR_EXP 175
102715: PUSH
102716: LD_INT 1
102718: ST_TO_ADDR
// if p3 = 107 then
102719: LD_VAR 0 3
102723: PUSH
102724: LD_INT 107
102726: EQUAL
102727: IFFALSE 102737
// sBomb := true ;
102729: LD_ADDR_EXP 176
102733: PUSH
102734: LD_INT 1
102736: ST_TO_ADDR
// if p3 = 108 then
102737: LD_VAR 0 3
102741: PUSH
102742: LD_INT 108
102744: EQUAL
102745: IFFALSE 102755
// sWound := true ;
102747: LD_ADDR_EXP 184
102751: PUSH
102752: LD_INT 1
102754: ST_TO_ADDR
// if p3 = 109 then
102755: LD_VAR 0 3
102759: PUSH
102760: LD_INT 109
102762: EQUAL
102763: IFFALSE 102773
// sBetray := true ;
102765: LD_ADDR_EXP 188
102769: PUSH
102770: LD_INT 1
102772: ST_TO_ADDR
// if p3 = 110 then
102773: LD_VAR 0 3
102777: PUSH
102778: LD_INT 110
102780: EQUAL
102781: IFFALSE 102791
// sContamin := true ;
102783: LD_ADDR_EXP 189
102787: PUSH
102788: LD_INT 1
102790: ST_TO_ADDR
// if p3 = 111 then
102791: LD_VAR 0 3
102795: PUSH
102796: LD_INT 111
102798: EQUAL
102799: IFFALSE 102809
// sOil := true ;
102801: LD_ADDR_EXP 191
102805: PUSH
102806: LD_INT 1
102808: ST_TO_ADDR
// if p3 = 112 then
102809: LD_VAR 0 3
102813: PUSH
102814: LD_INT 112
102816: EQUAL
102817: IFFALSE 102827
// sStu := true ;
102819: LD_ADDR_EXP 195
102823: PUSH
102824: LD_INT 1
102826: ST_TO_ADDR
// if p3 = 113 then
102827: LD_VAR 0 3
102831: PUSH
102832: LD_INT 113
102834: EQUAL
102835: IFFALSE 102845
// sBazooka := true ;
102837: LD_ADDR_EXP 198
102841: PUSH
102842: LD_INT 1
102844: ST_TO_ADDR
// if p3 = 114 then
102845: LD_VAR 0 3
102849: PUSH
102850: LD_INT 114
102852: EQUAL
102853: IFFALSE 102863
// sMortar := true ;
102855: LD_ADDR_EXP 199
102859: PUSH
102860: LD_INT 1
102862: ST_TO_ADDR
// if p3 = 115 then
102863: LD_VAR 0 3
102867: PUSH
102868: LD_INT 115
102870: EQUAL
102871: IFFALSE 102881
// sRanger := true ;
102873: LD_ADDR_EXP 209
102877: PUSH
102878: LD_INT 1
102880: ST_TO_ADDR
// end ; if p2 = 101 then
102881: LD_VAR 0 2
102885: PUSH
102886: LD_INT 101
102888: EQUAL
102889: IFFALSE 103017
// begin case p3 of 1 :
102891: LD_VAR 0 3
102895: PUSH
102896: LD_INT 1
102898: DOUBLE
102899: EQUAL
102900: IFTRUE 102904
102902: GO 102911
102904: POP
// hHackUnlimitedResources ; 2 :
102905: CALL 114052 0 0
102909: GO 103017
102911: LD_INT 2
102913: DOUBLE
102914: EQUAL
102915: IFTRUE 102919
102917: GO 102926
102919: POP
// hHackSetLevel10 ; 3 :
102920: CALL 114185 0 0
102924: GO 103017
102926: LD_INT 3
102928: DOUBLE
102929: EQUAL
102930: IFTRUE 102934
102932: GO 102941
102934: POP
// hHackSetLevel10YourUnits ; 4 :
102935: CALL 114270 0 0
102939: GO 103017
102941: LD_INT 4
102943: DOUBLE
102944: EQUAL
102945: IFTRUE 102949
102947: GO 102956
102949: POP
// hHackInvincible ; 5 :
102950: CALL 114718 0 0
102954: GO 103017
102956: LD_INT 5
102958: DOUBLE
102959: EQUAL
102960: IFTRUE 102964
102962: GO 102971
102964: POP
// hHackInvisible ; 6 :
102965: CALL 114829 0 0
102969: GO 103017
102971: LD_INT 6
102973: DOUBLE
102974: EQUAL
102975: IFTRUE 102979
102977: GO 102986
102979: POP
// hHackChangeYourSide ; 7 :
102980: CALL 114886 0 0
102984: GO 103017
102986: LD_INT 7
102988: DOUBLE
102989: EQUAL
102990: IFTRUE 102994
102992: GO 103001
102994: POP
// hHackChangeUnitSide ; 8 :
102995: CALL 114928 0 0
102999: GO 103017
103001: LD_INT 8
103003: DOUBLE
103004: EQUAL
103005: IFTRUE 103009
103007: GO 103016
103009: POP
// hHackFog ; end ;
103010: CALL 115029 0 0
103014: GO 103017
103016: POP
// end ; end ;
103017: PPOPN 6
103019: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
103020: GO 103022
103022: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
103023: LD_STRING initStreamRollete();
103025: PPUSH
103026: CALL_OW 559
// InitStreamMode ;
103030: CALL 103039 0 0
// DefineStreamItems ( ) ;
103034: CALL 103479 0 0
// end ;
103038: END
// function InitStreamMode ; begin
103039: LD_INT 0
103041: PPUSH
// streamModeActive := false ;
103042: LD_ADDR_EXP 156
103046: PUSH
103047: LD_INT 0
103049: ST_TO_ADDR
// normalCounter := 36 ;
103050: LD_ADDR_EXP 157
103054: PUSH
103055: LD_INT 36
103057: ST_TO_ADDR
// hardcoreCounter := 16 ;
103058: LD_ADDR_EXP 158
103062: PUSH
103063: LD_INT 16
103065: ST_TO_ADDR
// sRocket := false ;
103066: LD_ADDR_EXP 161
103070: PUSH
103071: LD_INT 0
103073: ST_TO_ADDR
// sSpeed := false ;
103074: LD_ADDR_EXP 160
103078: PUSH
103079: LD_INT 0
103081: ST_TO_ADDR
// sEngine := false ;
103082: LD_ADDR_EXP 162
103086: PUSH
103087: LD_INT 0
103089: ST_TO_ADDR
// sSpec := false ;
103090: LD_ADDR_EXP 159
103094: PUSH
103095: LD_INT 0
103097: ST_TO_ADDR
// sLevel := false ;
103098: LD_ADDR_EXP 163
103102: PUSH
103103: LD_INT 0
103105: ST_TO_ADDR
// sArmoury := false ;
103106: LD_ADDR_EXP 164
103110: PUSH
103111: LD_INT 0
103113: ST_TO_ADDR
// sRadar := false ;
103114: LD_ADDR_EXP 165
103118: PUSH
103119: LD_INT 0
103121: ST_TO_ADDR
// sBunker := false ;
103122: LD_ADDR_EXP 166
103126: PUSH
103127: LD_INT 0
103129: ST_TO_ADDR
// sHack := false ;
103130: LD_ADDR_EXP 167
103134: PUSH
103135: LD_INT 0
103137: ST_TO_ADDR
// sFire := false ;
103138: LD_ADDR_EXP 168
103142: PUSH
103143: LD_INT 0
103145: ST_TO_ADDR
// sRefresh := false ;
103146: LD_ADDR_EXP 169
103150: PUSH
103151: LD_INT 0
103153: ST_TO_ADDR
// sExp := false ;
103154: LD_ADDR_EXP 170
103158: PUSH
103159: LD_INT 0
103161: ST_TO_ADDR
// sDepot := false ;
103162: LD_ADDR_EXP 171
103166: PUSH
103167: LD_INT 0
103169: ST_TO_ADDR
// sFlag := false ;
103170: LD_ADDR_EXP 172
103174: PUSH
103175: LD_INT 0
103177: ST_TO_ADDR
// sKamikadze := false ;
103178: LD_ADDR_EXP 180
103182: PUSH
103183: LD_INT 0
103185: ST_TO_ADDR
// sTroll := false ;
103186: LD_ADDR_EXP 181
103190: PUSH
103191: LD_INT 0
103193: ST_TO_ADDR
// sSlow := false ;
103194: LD_ADDR_EXP 182
103198: PUSH
103199: LD_INT 0
103201: ST_TO_ADDR
// sLack := false ;
103202: LD_ADDR_EXP 183
103206: PUSH
103207: LD_INT 0
103209: ST_TO_ADDR
// sTank := false ;
103210: LD_ADDR_EXP 185
103214: PUSH
103215: LD_INT 0
103217: ST_TO_ADDR
// sRemote := false ;
103218: LD_ADDR_EXP 186
103222: PUSH
103223: LD_INT 0
103225: ST_TO_ADDR
// sPowell := false ;
103226: LD_ADDR_EXP 187
103230: PUSH
103231: LD_INT 0
103233: ST_TO_ADDR
// sTeleport := false ;
103234: LD_ADDR_EXP 190
103238: PUSH
103239: LD_INT 0
103241: ST_TO_ADDR
// sOilTower := false ;
103242: LD_ADDR_EXP 192
103246: PUSH
103247: LD_INT 0
103249: ST_TO_ADDR
// sShovel := false ;
103250: LD_ADDR_EXP 193
103254: PUSH
103255: LD_INT 0
103257: ST_TO_ADDR
// sSheik := false ;
103258: LD_ADDR_EXP 194
103262: PUSH
103263: LD_INT 0
103265: ST_TO_ADDR
// sEarthquake := false ;
103266: LD_ADDR_EXP 196
103270: PUSH
103271: LD_INT 0
103273: ST_TO_ADDR
// sAI := false ;
103274: LD_ADDR_EXP 197
103278: PUSH
103279: LD_INT 0
103281: ST_TO_ADDR
// sCargo := false ;
103282: LD_ADDR_EXP 200
103286: PUSH
103287: LD_INT 0
103289: ST_TO_ADDR
// sDLaser := false ;
103290: LD_ADDR_EXP 201
103294: PUSH
103295: LD_INT 0
103297: ST_TO_ADDR
// sExchange := false ;
103298: LD_ADDR_EXP 202
103302: PUSH
103303: LD_INT 0
103305: ST_TO_ADDR
// sFac := false ;
103306: LD_ADDR_EXP 203
103310: PUSH
103311: LD_INT 0
103313: ST_TO_ADDR
// sPower := false ;
103314: LD_ADDR_EXP 204
103318: PUSH
103319: LD_INT 0
103321: ST_TO_ADDR
// sRandom := false ;
103322: LD_ADDR_EXP 205
103326: PUSH
103327: LD_INT 0
103329: ST_TO_ADDR
// sShield := false ;
103330: LD_ADDR_EXP 206
103334: PUSH
103335: LD_INT 0
103337: ST_TO_ADDR
// sTime := false ;
103338: LD_ADDR_EXP 207
103342: PUSH
103343: LD_INT 0
103345: ST_TO_ADDR
// sTools := false ;
103346: LD_ADDR_EXP 208
103350: PUSH
103351: LD_INT 0
103353: ST_TO_ADDR
// sSold := false ;
103354: LD_ADDR_EXP 173
103358: PUSH
103359: LD_INT 0
103361: ST_TO_ADDR
// sDiff := false ;
103362: LD_ADDR_EXP 174
103366: PUSH
103367: LD_INT 0
103369: ST_TO_ADDR
// sFog := false ;
103370: LD_ADDR_EXP 177
103374: PUSH
103375: LD_INT 0
103377: ST_TO_ADDR
// sReset := false ;
103378: LD_ADDR_EXP 178
103382: PUSH
103383: LD_INT 0
103385: ST_TO_ADDR
// sSun := false ;
103386: LD_ADDR_EXP 179
103390: PUSH
103391: LD_INT 0
103393: ST_TO_ADDR
// sTiger := false ;
103394: LD_ADDR_EXP 175
103398: PUSH
103399: LD_INT 0
103401: ST_TO_ADDR
// sBomb := false ;
103402: LD_ADDR_EXP 176
103406: PUSH
103407: LD_INT 0
103409: ST_TO_ADDR
// sWound := false ;
103410: LD_ADDR_EXP 184
103414: PUSH
103415: LD_INT 0
103417: ST_TO_ADDR
// sBetray := false ;
103418: LD_ADDR_EXP 188
103422: PUSH
103423: LD_INT 0
103425: ST_TO_ADDR
// sContamin := false ;
103426: LD_ADDR_EXP 189
103430: PUSH
103431: LD_INT 0
103433: ST_TO_ADDR
// sOil := false ;
103434: LD_ADDR_EXP 191
103438: PUSH
103439: LD_INT 0
103441: ST_TO_ADDR
// sStu := false ;
103442: LD_ADDR_EXP 195
103446: PUSH
103447: LD_INT 0
103449: ST_TO_ADDR
// sBazooka := false ;
103450: LD_ADDR_EXP 198
103454: PUSH
103455: LD_INT 0
103457: ST_TO_ADDR
// sMortar := false ;
103458: LD_ADDR_EXP 199
103462: PUSH
103463: LD_INT 0
103465: ST_TO_ADDR
// sRanger := false ;
103466: LD_ADDR_EXP 209
103470: PUSH
103471: LD_INT 0
103473: ST_TO_ADDR
// end ;
103474: LD_VAR 0 1
103478: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
103479: LD_INT 0
103481: PPUSH
103482: PPUSH
103483: PPUSH
103484: PPUSH
103485: PPUSH
// result := [ ] ;
103486: LD_ADDR_VAR 0 1
103490: PUSH
103491: EMPTY
103492: ST_TO_ADDR
// if campaign_id = 1 then
103493: LD_OWVAR 69
103497: PUSH
103498: LD_INT 1
103500: EQUAL
103501: IFFALSE 106439
// begin case mission_number of 1 :
103503: LD_OWVAR 70
103507: PUSH
103508: LD_INT 1
103510: DOUBLE
103511: EQUAL
103512: IFTRUE 103516
103514: GO 103580
103516: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
103517: LD_ADDR_VAR 0 1
103521: PUSH
103522: LD_INT 2
103524: PUSH
103525: LD_INT 4
103527: PUSH
103528: LD_INT 11
103530: PUSH
103531: LD_INT 12
103533: PUSH
103534: LD_INT 15
103536: PUSH
103537: LD_INT 16
103539: PUSH
103540: LD_INT 22
103542: PUSH
103543: LD_INT 23
103545: PUSH
103546: LD_INT 26
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: LIST
103553: LIST
103554: LIST
103555: LIST
103556: LIST
103557: LIST
103558: LIST
103559: PUSH
103560: LD_INT 101
103562: PUSH
103563: LD_INT 102
103565: PUSH
103566: LD_INT 106
103568: PUSH
103569: EMPTY
103570: LIST
103571: LIST
103572: LIST
103573: PUSH
103574: EMPTY
103575: LIST
103576: LIST
103577: ST_TO_ADDR
103578: GO 106437
103580: LD_INT 2
103582: DOUBLE
103583: EQUAL
103584: IFTRUE 103588
103586: GO 103660
103588: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
103589: LD_ADDR_VAR 0 1
103593: PUSH
103594: LD_INT 2
103596: PUSH
103597: LD_INT 4
103599: PUSH
103600: LD_INT 11
103602: PUSH
103603: LD_INT 12
103605: PUSH
103606: LD_INT 15
103608: PUSH
103609: LD_INT 16
103611: PUSH
103612: LD_INT 22
103614: PUSH
103615: LD_INT 23
103617: PUSH
103618: LD_INT 26
103620: PUSH
103621: EMPTY
103622: LIST
103623: LIST
103624: LIST
103625: LIST
103626: LIST
103627: LIST
103628: LIST
103629: LIST
103630: LIST
103631: PUSH
103632: LD_INT 101
103634: PUSH
103635: LD_INT 102
103637: PUSH
103638: LD_INT 105
103640: PUSH
103641: LD_INT 106
103643: PUSH
103644: LD_INT 108
103646: PUSH
103647: EMPTY
103648: LIST
103649: LIST
103650: LIST
103651: LIST
103652: LIST
103653: PUSH
103654: EMPTY
103655: LIST
103656: LIST
103657: ST_TO_ADDR
103658: GO 106437
103660: LD_INT 3
103662: DOUBLE
103663: EQUAL
103664: IFTRUE 103668
103666: GO 103744
103668: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
103669: LD_ADDR_VAR 0 1
103673: PUSH
103674: LD_INT 2
103676: PUSH
103677: LD_INT 4
103679: PUSH
103680: LD_INT 5
103682: PUSH
103683: LD_INT 11
103685: PUSH
103686: LD_INT 12
103688: PUSH
103689: LD_INT 15
103691: PUSH
103692: LD_INT 16
103694: PUSH
103695: LD_INT 22
103697: PUSH
103698: LD_INT 26
103700: PUSH
103701: LD_INT 36
103703: PUSH
103704: EMPTY
103705: LIST
103706: LIST
103707: LIST
103708: LIST
103709: LIST
103710: LIST
103711: LIST
103712: LIST
103713: LIST
103714: LIST
103715: PUSH
103716: LD_INT 101
103718: PUSH
103719: LD_INT 102
103721: PUSH
103722: LD_INT 105
103724: PUSH
103725: LD_INT 106
103727: PUSH
103728: LD_INT 108
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: LIST
103735: LIST
103736: LIST
103737: PUSH
103738: EMPTY
103739: LIST
103740: LIST
103741: ST_TO_ADDR
103742: GO 106437
103744: LD_INT 4
103746: DOUBLE
103747: EQUAL
103748: IFTRUE 103752
103750: GO 103836
103752: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
103753: LD_ADDR_VAR 0 1
103757: PUSH
103758: LD_INT 2
103760: PUSH
103761: LD_INT 4
103763: PUSH
103764: LD_INT 5
103766: PUSH
103767: LD_INT 8
103769: PUSH
103770: LD_INT 11
103772: PUSH
103773: LD_INT 12
103775: PUSH
103776: LD_INT 15
103778: PUSH
103779: LD_INT 16
103781: PUSH
103782: LD_INT 22
103784: PUSH
103785: LD_INT 23
103787: PUSH
103788: LD_INT 26
103790: PUSH
103791: LD_INT 36
103793: PUSH
103794: EMPTY
103795: LIST
103796: LIST
103797: LIST
103798: LIST
103799: LIST
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: LIST
103806: LIST
103807: PUSH
103808: LD_INT 101
103810: PUSH
103811: LD_INT 102
103813: PUSH
103814: LD_INT 105
103816: PUSH
103817: LD_INT 106
103819: PUSH
103820: LD_INT 108
103822: PUSH
103823: EMPTY
103824: LIST
103825: LIST
103826: LIST
103827: LIST
103828: LIST
103829: PUSH
103830: EMPTY
103831: LIST
103832: LIST
103833: ST_TO_ADDR
103834: GO 106437
103836: LD_INT 5
103838: DOUBLE
103839: EQUAL
103840: IFTRUE 103844
103842: GO 103944
103844: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
103845: LD_ADDR_VAR 0 1
103849: PUSH
103850: LD_INT 2
103852: PUSH
103853: LD_INT 4
103855: PUSH
103856: LD_INT 5
103858: PUSH
103859: LD_INT 6
103861: PUSH
103862: LD_INT 8
103864: PUSH
103865: LD_INT 11
103867: PUSH
103868: LD_INT 12
103870: PUSH
103871: LD_INT 15
103873: PUSH
103874: LD_INT 16
103876: PUSH
103877: LD_INT 22
103879: PUSH
103880: LD_INT 23
103882: PUSH
103883: LD_INT 25
103885: PUSH
103886: LD_INT 26
103888: PUSH
103889: LD_INT 36
103891: PUSH
103892: EMPTY
103893: LIST
103894: LIST
103895: LIST
103896: LIST
103897: LIST
103898: LIST
103899: LIST
103900: LIST
103901: LIST
103902: LIST
103903: LIST
103904: LIST
103905: LIST
103906: LIST
103907: PUSH
103908: LD_INT 101
103910: PUSH
103911: LD_INT 102
103913: PUSH
103914: LD_INT 105
103916: PUSH
103917: LD_INT 106
103919: PUSH
103920: LD_INT 108
103922: PUSH
103923: LD_INT 109
103925: PUSH
103926: LD_INT 112
103928: PUSH
103929: EMPTY
103930: LIST
103931: LIST
103932: LIST
103933: LIST
103934: LIST
103935: LIST
103936: LIST
103937: PUSH
103938: EMPTY
103939: LIST
103940: LIST
103941: ST_TO_ADDR
103942: GO 106437
103944: LD_INT 6
103946: DOUBLE
103947: EQUAL
103948: IFTRUE 103952
103950: GO 104072
103952: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
103953: LD_ADDR_VAR 0 1
103957: PUSH
103958: LD_INT 2
103960: PUSH
103961: LD_INT 4
103963: PUSH
103964: LD_INT 5
103966: PUSH
103967: LD_INT 6
103969: PUSH
103970: LD_INT 8
103972: PUSH
103973: LD_INT 11
103975: PUSH
103976: LD_INT 12
103978: PUSH
103979: LD_INT 15
103981: PUSH
103982: LD_INT 16
103984: PUSH
103985: LD_INT 20
103987: PUSH
103988: LD_INT 21
103990: PUSH
103991: LD_INT 22
103993: PUSH
103994: LD_INT 23
103996: PUSH
103997: LD_INT 25
103999: PUSH
104000: LD_INT 26
104002: PUSH
104003: LD_INT 30
104005: PUSH
104006: LD_INT 31
104008: PUSH
104009: LD_INT 32
104011: PUSH
104012: LD_INT 36
104014: PUSH
104015: EMPTY
104016: LIST
104017: LIST
104018: LIST
104019: LIST
104020: LIST
104021: LIST
104022: LIST
104023: LIST
104024: LIST
104025: LIST
104026: LIST
104027: LIST
104028: LIST
104029: LIST
104030: LIST
104031: LIST
104032: LIST
104033: LIST
104034: LIST
104035: PUSH
104036: LD_INT 101
104038: PUSH
104039: LD_INT 102
104041: PUSH
104042: LD_INT 105
104044: PUSH
104045: LD_INT 106
104047: PUSH
104048: LD_INT 108
104050: PUSH
104051: LD_INT 109
104053: PUSH
104054: LD_INT 112
104056: PUSH
104057: EMPTY
104058: LIST
104059: LIST
104060: LIST
104061: LIST
104062: LIST
104063: LIST
104064: LIST
104065: PUSH
104066: EMPTY
104067: LIST
104068: LIST
104069: ST_TO_ADDR
104070: GO 106437
104072: LD_INT 7
104074: DOUBLE
104075: EQUAL
104076: IFTRUE 104080
104078: GO 104180
104080: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
104081: LD_ADDR_VAR 0 1
104085: PUSH
104086: LD_INT 2
104088: PUSH
104089: LD_INT 4
104091: PUSH
104092: LD_INT 5
104094: PUSH
104095: LD_INT 7
104097: PUSH
104098: LD_INT 11
104100: PUSH
104101: LD_INT 12
104103: PUSH
104104: LD_INT 15
104106: PUSH
104107: LD_INT 16
104109: PUSH
104110: LD_INT 20
104112: PUSH
104113: LD_INT 21
104115: PUSH
104116: LD_INT 22
104118: PUSH
104119: LD_INT 23
104121: PUSH
104122: LD_INT 25
104124: PUSH
104125: LD_INT 26
104127: PUSH
104128: EMPTY
104129: LIST
104130: LIST
104131: LIST
104132: LIST
104133: LIST
104134: LIST
104135: LIST
104136: LIST
104137: LIST
104138: LIST
104139: LIST
104140: LIST
104141: LIST
104142: LIST
104143: PUSH
104144: LD_INT 101
104146: PUSH
104147: LD_INT 102
104149: PUSH
104150: LD_INT 103
104152: PUSH
104153: LD_INT 105
104155: PUSH
104156: LD_INT 106
104158: PUSH
104159: LD_INT 108
104161: PUSH
104162: LD_INT 112
104164: PUSH
104165: EMPTY
104166: LIST
104167: LIST
104168: LIST
104169: LIST
104170: LIST
104171: LIST
104172: LIST
104173: PUSH
104174: EMPTY
104175: LIST
104176: LIST
104177: ST_TO_ADDR
104178: GO 106437
104180: LD_INT 8
104182: DOUBLE
104183: EQUAL
104184: IFTRUE 104188
104186: GO 104316
104188: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
104189: LD_ADDR_VAR 0 1
104193: PUSH
104194: LD_INT 2
104196: PUSH
104197: LD_INT 4
104199: PUSH
104200: LD_INT 5
104202: PUSH
104203: LD_INT 6
104205: PUSH
104206: LD_INT 7
104208: PUSH
104209: LD_INT 8
104211: PUSH
104212: LD_INT 11
104214: PUSH
104215: LD_INT 12
104217: PUSH
104218: LD_INT 15
104220: PUSH
104221: LD_INT 16
104223: PUSH
104224: LD_INT 20
104226: PUSH
104227: LD_INT 21
104229: PUSH
104230: LD_INT 22
104232: PUSH
104233: LD_INT 23
104235: PUSH
104236: LD_INT 25
104238: PUSH
104239: LD_INT 26
104241: PUSH
104242: LD_INT 30
104244: PUSH
104245: LD_INT 31
104247: PUSH
104248: LD_INT 32
104250: PUSH
104251: LD_INT 36
104253: PUSH
104254: EMPTY
104255: LIST
104256: LIST
104257: LIST
104258: LIST
104259: LIST
104260: LIST
104261: LIST
104262: LIST
104263: LIST
104264: LIST
104265: LIST
104266: LIST
104267: LIST
104268: LIST
104269: LIST
104270: LIST
104271: LIST
104272: LIST
104273: LIST
104274: LIST
104275: PUSH
104276: LD_INT 101
104278: PUSH
104279: LD_INT 102
104281: PUSH
104282: LD_INT 103
104284: PUSH
104285: LD_INT 105
104287: PUSH
104288: LD_INT 106
104290: PUSH
104291: LD_INT 108
104293: PUSH
104294: LD_INT 109
104296: PUSH
104297: LD_INT 112
104299: PUSH
104300: EMPTY
104301: LIST
104302: LIST
104303: LIST
104304: LIST
104305: LIST
104306: LIST
104307: LIST
104308: LIST
104309: PUSH
104310: EMPTY
104311: LIST
104312: LIST
104313: ST_TO_ADDR
104314: GO 106437
104316: LD_INT 9
104318: DOUBLE
104319: EQUAL
104320: IFTRUE 104324
104322: GO 104460
104324: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
104325: LD_ADDR_VAR 0 1
104329: PUSH
104330: LD_INT 2
104332: PUSH
104333: LD_INT 4
104335: PUSH
104336: LD_INT 5
104338: PUSH
104339: LD_INT 6
104341: PUSH
104342: LD_INT 7
104344: PUSH
104345: LD_INT 8
104347: PUSH
104348: LD_INT 11
104350: PUSH
104351: LD_INT 12
104353: PUSH
104354: LD_INT 15
104356: PUSH
104357: LD_INT 16
104359: PUSH
104360: LD_INT 20
104362: PUSH
104363: LD_INT 21
104365: PUSH
104366: LD_INT 22
104368: PUSH
104369: LD_INT 23
104371: PUSH
104372: LD_INT 25
104374: PUSH
104375: LD_INT 26
104377: PUSH
104378: LD_INT 28
104380: PUSH
104381: LD_INT 30
104383: PUSH
104384: LD_INT 31
104386: PUSH
104387: LD_INT 32
104389: PUSH
104390: LD_INT 36
104392: PUSH
104393: EMPTY
104394: LIST
104395: LIST
104396: LIST
104397: LIST
104398: LIST
104399: LIST
104400: LIST
104401: LIST
104402: LIST
104403: LIST
104404: LIST
104405: LIST
104406: LIST
104407: LIST
104408: LIST
104409: LIST
104410: LIST
104411: LIST
104412: LIST
104413: LIST
104414: LIST
104415: PUSH
104416: LD_INT 101
104418: PUSH
104419: LD_INT 102
104421: PUSH
104422: LD_INT 103
104424: PUSH
104425: LD_INT 105
104427: PUSH
104428: LD_INT 106
104430: PUSH
104431: LD_INT 108
104433: PUSH
104434: LD_INT 109
104436: PUSH
104437: LD_INT 112
104439: PUSH
104440: LD_INT 114
104442: PUSH
104443: EMPTY
104444: LIST
104445: LIST
104446: LIST
104447: LIST
104448: LIST
104449: LIST
104450: LIST
104451: LIST
104452: LIST
104453: PUSH
104454: EMPTY
104455: LIST
104456: LIST
104457: ST_TO_ADDR
104458: GO 106437
104460: LD_INT 10
104462: DOUBLE
104463: EQUAL
104464: IFTRUE 104468
104466: GO 104652
104468: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
104469: LD_ADDR_VAR 0 1
104473: PUSH
104474: LD_INT 2
104476: PUSH
104477: LD_INT 4
104479: PUSH
104480: LD_INT 5
104482: PUSH
104483: LD_INT 6
104485: PUSH
104486: LD_INT 7
104488: PUSH
104489: LD_INT 8
104491: PUSH
104492: LD_INT 9
104494: PUSH
104495: LD_INT 10
104497: PUSH
104498: LD_INT 11
104500: PUSH
104501: LD_INT 12
104503: PUSH
104504: LD_INT 13
104506: PUSH
104507: LD_INT 14
104509: PUSH
104510: LD_INT 15
104512: PUSH
104513: LD_INT 16
104515: PUSH
104516: LD_INT 17
104518: PUSH
104519: LD_INT 18
104521: PUSH
104522: LD_INT 19
104524: PUSH
104525: LD_INT 20
104527: PUSH
104528: LD_INT 21
104530: PUSH
104531: LD_INT 22
104533: PUSH
104534: LD_INT 23
104536: PUSH
104537: LD_INT 24
104539: PUSH
104540: LD_INT 25
104542: PUSH
104543: LD_INT 26
104545: PUSH
104546: LD_INT 28
104548: PUSH
104549: LD_INT 30
104551: PUSH
104552: LD_INT 31
104554: PUSH
104555: LD_INT 32
104557: PUSH
104558: LD_INT 36
104560: PUSH
104561: EMPTY
104562: LIST
104563: LIST
104564: LIST
104565: LIST
104566: LIST
104567: LIST
104568: LIST
104569: LIST
104570: LIST
104571: LIST
104572: LIST
104573: LIST
104574: LIST
104575: LIST
104576: LIST
104577: LIST
104578: LIST
104579: LIST
104580: LIST
104581: LIST
104582: LIST
104583: LIST
104584: LIST
104585: LIST
104586: LIST
104587: LIST
104588: LIST
104589: LIST
104590: LIST
104591: PUSH
104592: LD_INT 101
104594: PUSH
104595: LD_INT 102
104597: PUSH
104598: LD_INT 103
104600: PUSH
104601: LD_INT 104
104603: PUSH
104604: LD_INT 105
104606: PUSH
104607: LD_INT 106
104609: PUSH
104610: LD_INT 107
104612: PUSH
104613: LD_INT 108
104615: PUSH
104616: LD_INT 109
104618: PUSH
104619: LD_INT 110
104621: PUSH
104622: LD_INT 111
104624: PUSH
104625: LD_INT 112
104627: PUSH
104628: LD_INT 114
104630: PUSH
104631: EMPTY
104632: LIST
104633: LIST
104634: LIST
104635: LIST
104636: LIST
104637: LIST
104638: LIST
104639: LIST
104640: LIST
104641: LIST
104642: LIST
104643: LIST
104644: LIST
104645: PUSH
104646: EMPTY
104647: LIST
104648: LIST
104649: ST_TO_ADDR
104650: GO 106437
104652: LD_INT 11
104654: DOUBLE
104655: EQUAL
104656: IFTRUE 104660
104658: GO 104852
104660: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
104661: LD_ADDR_VAR 0 1
104665: PUSH
104666: LD_INT 2
104668: PUSH
104669: LD_INT 3
104671: PUSH
104672: LD_INT 4
104674: PUSH
104675: LD_INT 5
104677: PUSH
104678: LD_INT 6
104680: PUSH
104681: LD_INT 7
104683: PUSH
104684: LD_INT 8
104686: PUSH
104687: LD_INT 9
104689: PUSH
104690: LD_INT 10
104692: PUSH
104693: LD_INT 11
104695: PUSH
104696: LD_INT 12
104698: PUSH
104699: LD_INT 13
104701: PUSH
104702: LD_INT 14
104704: PUSH
104705: LD_INT 15
104707: PUSH
104708: LD_INT 16
104710: PUSH
104711: LD_INT 17
104713: PUSH
104714: LD_INT 18
104716: PUSH
104717: LD_INT 19
104719: PUSH
104720: LD_INT 20
104722: PUSH
104723: LD_INT 21
104725: PUSH
104726: LD_INT 22
104728: PUSH
104729: LD_INT 23
104731: PUSH
104732: LD_INT 24
104734: PUSH
104735: LD_INT 25
104737: PUSH
104738: LD_INT 26
104740: PUSH
104741: LD_INT 28
104743: PUSH
104744: LD_INT 30
104746: PUSH
104747: LD_INT 31
104749: PUSH
104750: LD_INT 32
104752: PUSH
104753: LD_INT 34
104755: PUSH
104756: LD_INT 36
104758: PUSH
104759: EMPTY
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: LIST
104779: LIST
104780: LIST
104781: LIST
104782: LIST
104783: LIST
104784: LIST
104785: LIST
104786: LIST
104787: LIST
104788: LIST
104789: LIST
104790: LIST
104791: PUSH
104792: LD_INT 101
104794: PUSH
104795: LD_INT 102
104797: PUSH
104798: LD_INT 103
104800: PUSH
104801: LD_INT 104
104803: PUSH
104804: LD_INT 105
104806: PUSH
104807: LD_INT 106
104809: PUSH
104810: LD_INT 107
104812: PUSH
104813: LD_INT 108
104815: PUSH
104816: LD_INT 109
104818: PUSH
104819: LD_INT 110
104821: PUSH
104822: LD_INT 111
104824: PUSH
104825: LD_INT 112
104827: PUSH
104828: LD_INT 114
104830: PUSH
104831: EMPTY
104832: LIST
104833: LIST
104834: LIST
104835: LIST
104836: LIST
104837: LIST
104838: LIST
104839: LIST
104840: LIST
104841: LIST
104842: LIST
104843: LIST
104844: LIST
104845: PUSH
104846: EMPTY
104847: LIST
104848: LIST
104849: ST_TO_ADDR
104850: GO 106437
104852: LD_INT 12
104854: DOUBLE
104855: EQUAL
104856: IFTRUE 104860
104858: GO 105068
104860: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
104861: LD_ADDR_VAR 0 1
104865: PUSH
104866: LD_INT 1
104868: PUSH
104869: LD_INT 2
104871: PUSH
104872: LD_INT 3
104874: PUSH
104875: LD_INT 4
104877: PUSH
104878: LD_INT 5
104880: PUSH
104881: LD_INT 6
104883: PUSH
104884: LD_INT 7
104886: PUSH
104887: LD_INT 8
104889: PUSH
104890: LD_INT 9
104892: PUSH
104893: LD_INT 10
104895: PUSH
104896: LD_INT 11
104898: PUSH
104899: LD_INT 12
104901: PUSH
104902: LD_INT 13
104904: PUSH
104905: LD_INT 14
104907: PUSH
104908: LD_INT 15
104910: PUSH
104911: LD_INT 16
104913: PUSH
104914: LD_INT 17
104916: PUSH
104917: LD_INT 18
104919: PUSH
104920: LD_INT 19
104922: PUSH
104923: LD_INT 20
104925: PUSH
104926: LD_INT 21
104928: PUSH
104929: LD_INT 22
104931: PUSH
104932: LD_INT 23
104934: PUSH
104935: LD_INT 24
104937: PUSH
104938: LD_INT 25
104940: PUSH
104941: LD_INT 26
104943: PUSH
104944: LD_INT 27
104946: PUSH
104947: LD_INT 28
104949: PUSH
104950: LD_INT 30
104952: PUSH
104953: LD_INT 31
104955: PUSH
104956: LD_INT 32
104958: PUSH
104959: LD_INT 33
104961: PUSH
104962: LD_INT 34
104964: PUSH
104965: LD_INT 36
104967: PUSH
104968: EMPTY
104969: LIST
104970: LIST
104971: LIST
104972: LIST
104973: LIST
104974: LIST
104975: LIST
104976: LIST
104977: LIST
104978: LIST
104979: LIST
104980: LIST
104981: LIST
104982: LIST
104983: LIST
104984: LIST
104985: LIST
104986: LIST
104987: LIST
104988: LIST
104989: LIST
104990: LIST
104991: LIST
104992: LIST
104993: LIST
104994: LIST
104995: LIST
104996: LIST
104997: LIST
104998: LIST
104999: LIST
105000: LIST
105001: LIST
105002: LIST
105003: PUSH
105004: LD_INT 101
105006: PUSH
105007: LD_INT 102
105009: PUSH
105010: LD_INT 103
105012: PUSH
105013: LD_INT 104
105015: PUSH
105016: LD_INT 105
105018: PUSH
105019: LD_INT 106
105021: PUSH
105022: LD_INT 107
105024: PUSH
105025: LD_INT 108
105027: PUSH
105028: LD_INT 109
105030: PUSH
105031: LD_INT 110
105033: PUSH
105034: LD_INT 111
105036: PUSH
105037: LD_INT 112
105039: PUSH
105040: LD_INT 113
105042: PUSH
105043: LD_INT 114
105045: PUSH
105046: EMPTY
105047: LIST
105048: LIST
105049: LIST
105050: LIST
105051: LIST
105052: LIST
105053: LIST
105054: LIST
105055: LIST
105056: LIST
105057: LIST
105058: LIST
105059: LIST
105060: LIST
105061: PUSH
105062: EMPTY
105063: LIST
105064: LIST
105065: ST_TO_ADDR
105066: GO 106437
105068: LD_INT 13
105070: DOUBLE
105071: EQUAL
105072: IFTRUE 105076
105074: GO 105272
105076: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
105077: LD_ADDR_VAR 0 1
105081: PUSH
105082: LD_INT 1
105084: PUSH
105085: LD_INT 2
105087: PUSH
105088: LD_INT 3
105090: PUSH
105091: LD_INT 4
105093: PUSH
105094: LD_INT 5
105096: PUSH
105097: LD_INT 8
105099: PUSH
105100: LD_INT 9
105102: PUSH
105103: LD_INT 10
105105: PUSH
105106: LD_INT 11
105108: PUSH
105109: LD_INT 12
105111: PUSH
105112: LD_INT 14
105114: PUSH
105115: LD_INT 15
105117: PUSH
105118: LD_INT 16
105120: PUSH
105121: LD_INT 17
105123: PUSH
105124: LD_INT 18
105126: PUSH
105127: LD_INT 19
105129: PUSH
105130: LD_INT 20
105132: PUSH
105133: LD_INT 21
105135: PUSH
105136: LD_INT 22
105138: PUSH
105139: LD_INT 23
105141: PUSH
105142: LD_INT 24
105144: PUSH
105145: LD_INT 25
105147: PUSH
105148: LD_INT 26
105150: PUSH
105151: LD_INT 27
105153: PUSH
105154: LD_INT 28
105156: PUSH
105157: LD_INT 30
105159: PUSH
105160: LD_INT 31
105162: PUSH
105163: LD_INT 32
105165: PUSH
105166: LD_INT 33
105168: PUSH
105169: LD_INT 34
105171: PUSH
105172: LD_INT 36
105174: PUSH
105175: EMPTY
105176: LIST
105177: LIST
105178: LIST
105179: LIST
105180: LIST
105181: LIST
105182: LIST
105183: LIST
105184: LIST
105185: LIST
105186: LIST
105187: LIST
105188: LIST
105189: LIST
105190: LIST
105191: LIST
105192: LIST
105193: LIST
105194: LIST
105195: LIST
105196: LIST
105197: LIST
105198: LIST
105199: LIST
105200: LIST
105201: LIST
105202: LIST
105203: LIST
105204: LIST
105205: LIST
105206: LIST
105207: PUSH
105208: LD_INT 101
105210: PUSH
105211: LD_INT 102
105213: PUSH
105214: LD_INT 103
105216: PUSH
105217: LD_INT 104
105219: PUSH
105220: LD_INT 105
105222: PUSH
105223: LD_INT 106
105225: PUSH
105226: LD_INT 107
105228: PUSH
105229: LD_INT 108
105231: PUSH
105232: LD_INT 109
105234: PUSH
105235: LD_INT 110
105237: PUSH
105238: LD_INT 111
105240: PUSH
105241: LD_INT 112
105243: PUSH
105244: LD_INT 113
105246: PUSH
105247: LD_INT 114
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: LIST
105254: LIST
105255: LIST
105256: LIST
105257: LIST
105258: LIST
105259: LIST
105260: LIST
105261: LIST
105262: LIST
105263: LIST
105264: LIST
105265: PUSH
105266: EMPTY
105267: LIST
105268: LIST
105269: ST_TO_ADDR
105270: GO 106437
105272: LD_INT 14
105274: DOUBLE
105275: EQUAL
105276: IFTRUE 105280
105278: GO 105492
105280: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
105281: LD_ADDR_VAR 0 1
105285: PUSH
105286: LD_INT 1
105288: PUSH
105289: LD_INT 2
105291: PUSH
105292: LD_INT 3
105294: PUSH
105295: LD_INT 4
105297: PUSH
105298: LD_INT 5
105300: PUSH
105301: LD_INT 6
105303: PUSH
105304: LD_INT 7
105306: PUSH
105307: LD_INT 8
105309: PUSH
105310: LD_INT 9
105312: PUSH
105313: LD_INT 10
105315: PUSH
105316: LD_INT 11
105318: PUSH
105319: LD_INT 12
105321: PUSH
105322: LD_INT 13
105324: PUSH
105325: LD_INT 14
105327: PUSH
105328: LD_INT 15
105330: PUSH
105331: LD_INT 16
105333: PUSH
105334: LD_INT 17
105336: PUSH
105337: LD_INT 18
105339: PUSH
105340: LD_INT 19
105342: PUSH
105343: LD_INT 20
105345: PUSH
105346: LD_INT 21
105348: PUSH
105349: LD_INT 22
105351: PUSH
105352: LD_INT 23
105354: PUSH
105355: LD_INT 24
105357: PUSH
105358: LD_INT 25
105360: PUSH
105361: LD_INT 26
105363: PUSH
105364: LD_INT 27
105366: PUSH
105367: LD_INT 28
105369: PUSH
105370: LD_INT 29
105372: PUSH
105373: LD_INT 30
105375: PUSH
105376: LD_INT 31
105378: PUSH
105379: LD_INT 32
105381: PUSH
105382: LD_INT 33
105384: PUSH
105385: LD_INT 34
105387: PUSH
105388: LD_INT 36
105390: PUSH
105391: EMPTY
105392: LIST
105393: LIST
105394: LIST
105395: LIST
105396: LIST
105397: LIST
105398: LIST
105399: LIST
105400: LIST
105401: LIST
105402: LIST
105403: LIST
105404: LIST
105405: LIST
105406: LIST
105407: LIST
105408: LIST
105409: LIST
105410: LIST
105411: LIST
105412: LIST
105413: LIST
105414: LIST
105415: LIST
105416: LIST
105417: LIST
105418: LIST
105419: LIST
105420: LIST
105421: LIST
105422: LIST
105423: LIST
105424: LIST
105425: LIST
105426: LIST
105427: PUSH
105428: LD_INT 101
105430: PUSH
105431: LD_INT 102
105433: PUSH
105434: LD_INT 103
105436: PUSH
105437: LD_INT 104
105439: PUSH
105440: LD_INT 105
105442: PUSH
105443: LD_INT 106
105445: PUSH
105446: LD_INT 107
105448: PUSH
105449: LD_INT 108
105451: PUSH
105452: LD_INT 109
105454: PUSH
105455: LD_INT 110
105457: PUSH
105458: LD_INT 111
105460: PUSH
105461: LD_INT 112
105463: PUSH
105464: LD_INT 113
105466: PUSH
105467: LD_INT 114
105469: PUSH
105470: EMPTY
105471: LIST
105472: LIST
105473: LIST
105474: LIST
105475: LIST
105476: LIST
105477: LIST
105478: LIST
105479: LIST
105480: LIST
105481: LIST
105482: LIST
105483: LIST
105484: LIST
105485: PUSH
105486: EMPTY
105487: LIST
105488: LIST
105489: ST_TO_ADDR
105490: GO 106437
105492: LD_INT 15
105494: DOUBLE
105495: EQUAL
105496: IFTRUE 105500
105498: GO 105712
105500: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
105501: LD_ADDR_VAR 0 1
105505: PUSH
105506: LD_INT 1
105508: PUSH
105509: LD_INT 2
105511: PUSH
105512: LD_INT 3
105514: PUSH
105515: LD_INT 4
105517: PUSH
105518: LD_INT 5
105520: PUSH
105521: LD_INT 6
105523: PUSH
105524: LD_INT 7
105526: PUSH
105527: LD_INT 8
105529: PUSH
105530: LD_INT 9
105532: PUSH
105533: LD_INT 10
105535: PUSH
105536: LD_INT 11
105538: PUSH
105539: LD_INT 12
105541: PUSH
105542: LD_INT 13
105544: PUSH
105545: LD_INT 14
105547: PUSH
105548: LD_INT 15
105550: PUSH
105551: LD_INT 16
105553: PUSH
105554: LD_INT 17
105556: PUSH
105557: LD_INT 18
105559: PUSH
105560: LD_INT 19
105562: PUSH
105563: LD_INT 20
105565: PUSH
105566: LD_INT 21
105568: PUSH
105569: LD_INT 22
105571: PUSH
105572: LD_INT 23
105574: PUSH
105575: LD_INT 24
105577: PUSH
105578: LD_INT 25
105580: PUSH
105581: LD_INT 26
105583: PUSH
105584: LD_INT 27
105586: PUSH
105587: LD_INT 28
105589: PUSH
105590: LD_INT 29
105592: PUSH
105593: LD_INT 30
105595: PUSH
105596: LD_INT 31
105598: PUSH
105599: LD_INT 32
105601: PUSH
105602: LD_INT 33
105604: PUSH
105605: LD_INT 34
105607: PUSH
105608: LD_INT 36
105610: PUSH
105611: EMPTY
105612: LIST
105613: LIST
105614: LIST
105615: LIST
105616: LIST
105617: LIST
105618: LIST
105619: LIST
105620: LIST
105621: LIST
105622: LIST
105623: LIST
105624: LIST
105625: LIST
105626: LIST
105627: LIST
105628: LIST
105629: LIST
105630: LIST
105631: LIST
105632: LIST
105633: LIST
105634: LIST
105635: LIST
105636: LIST
105637: LIST
105638: LIST
105639: LIST
105640: LIST
105641: LIST
105642: LIST
105643: LIST
105644: LIST
105645: LIST
105646: LIST
105647: PUSH
105648: LD_INT 101
105650: PUSH
105651: LD_INT 102
105653: PUSH
105654: LD_INT 103
105656: PUSH
105657: LD_INT 104
105659: PUSH
105660: LD_INT 105
105662: PUSH
105663: LD_INT 106
105665: PUSH
105666: LD_INT 107
105668: PUSH
105669: LD_INT 108
105671: PUSH
105672: LD_INT 109
105674: PUSH
105675: LD_INT 110
105677: PUSH
105678: LD_INT 111
105680: PUSH
105681: LD_INT 112
105683: PUSH
105684: LD_INT 113
105686: PUSH
105687: LD_INT 114
105689: PUSH
105690: EMPTY
105691: LIST
105692: LIST
105693: LIST
105694: LIST
105695: LIST
105696: LIST
105697: LIST
105698: LIST
105699: LIST
105700: LIST
105701: LIST
105702: LIST
105703: LIST
105704: LIST
105705: PUSH
105706: EMPTY
105707: LIST
105708: LIST
105709: ST_TO_ADDR
105710: GO 106437
105712: LD_INT 16
105714: DOUBLE
105715: EQUAL
105716: IFTRUE 105720
105718: GO 105844
105720: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
105721: LD_ADDR_VAR 0 1
105725: PUSH
105726: LD_INT 2
105728: PUSH
105729: LD_INT 4
105731: PUSH
105732: LD_INT 5
105734: PUSH
105735: LD_INT 7
105737: PUSH
105738: LD_INT 11
105740: PUSH
105741: LD_INT 12
105743: PUSH
105744: LD_INT 15
105746: PUSH
105747: LD_INT 16
105749: PUSH
105750: LD_INT 20
105752: PUSH
105753: LD_INT 21
105755: PUSH
105756: LD_INT 22
105758: PUSH
105759: LD_INT 23
105761: PUSH
105762: LD_INT 25
105764: PUSH
105765: LD_INT 26
105767: PUSH
105768: LD_INT 30
105770: PUSH
105771: LD_INT 31
105773: PUSH
105774: LD_INT 32
105776: PUSH
105777: LD_INT 33
105779: PUSH
105780: LD_INT 34
105782: PUSH
105783: EMPTY
105784: LIST
105785: LIST
105786: LIST
105787: LIST
105788: LIST
105789: LIST
105790: LIST
105791: LIST
105792: LIST
105793: LIST
105794: LIST
105795: LIST
105796: LIST
105797: LIST
105798: LIST
105799: LIST
105800: LIST
105801: LIST
105802: LIST
105803: PUSH
105804: LD_INT 101
105806: PUSH
105807: LD_INT 102
105809: PUSH
105810: LD_INT 103
105812: PUSH
105813: LD_INT 106
105815: PUSH
105816: LD_INT 108
105818: PUSH
105819: LD_INT 112
105821: PUSH
105822: LD_INT 113
105824: PUSH
105825: LD_INT 114
105827: PUSH
105828: EMPTY
105829: LIST
105830: LIST
105831: LIST
105832: LIST
105833: LIST
105834: LIST
105835: LIST
105836: LIST
105837: PUSH
105838: EMPTY
105839: LIST
105840: LIST
105841: ST_TO_ADDR
105842: GO 106437
105844: LD_INT 17
105846: DOUBLE
105847: EQUAL
105848: IFTRUE 105852
105850: GO 106064
105852: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
105853: LD_ADDR_VAR 0 1
105857: PUSH
105858: LD_INT 1
105860: PUSH
105861: LD_INT 2
105863: PUSH
105864: LD_INT 3
105866: PUSH
105867: LD_INT 4
105869: PUSH
105870: LD_INT 5
105872: PUSH
105873: LD_INT 6
105875: PUSH
105876: LD_INT 7
105878: PUSH
105879: LD_INT 8
105881: PUSH
105882: LD_INT 9
105884: PUSH
105885: LD_INT 10
105887: PUSH
105888: LD_INT 11
105890: PUSH
105891: LD_INT 12
105893: PUSH
105894: LD_INT 13
105896: PUSH
105897: LD_INT 14
105899: PUSH
105900: LD_INT 15
105902: PUSH
105903: LD_INT 16
105905: PUSH
105906: LD_INT 17
105908: PUSH
105909: LD_INT 18
105911: PUSH
105912: LD_INT 19
105914: PUSH
105915: LD_INT 20
105917: PUSH
105918: LD_INT 21
105920: PUSH
105921: LD_INT 22
105923: PUSH
105924: LD_INT 23
105926: PUSH
105927: LD_INT 24
105929: PUSH
105930: LD_INT 25
105932: PUSH
105933: LD_INT 26
105935: PUSH
105936: LD_INT 27
105938: PUSH
105939: LD_INT 28
105941: PUSH
105942: LD_INT 29
105944: PUSH
105945: LD_INT 30
105947: PUSH
105948: LD_INT 31
105950: PUSH
105951: LD_INT 32
105953: PUSH
105954: LD_INT 33
105956: PUSH
105957: LD_INT 34
105959: PUSH
105960: LD_INT 36
105962: PUSH
105963: EMPTY
105964: LIST
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: LIST
105970: LIST
105971: LIST
105972: LIST
105973: LIST
105974: LIST
105975: LIST
105976: LIST
105977: LIST
105978: LIST
105979: LIST
105980: LIST
105981: LIST
105982: LIST
105983: LIST
105984: LIST
105985: LIST
105986: LIST
105987: LIST
105988: LIST
105989: LIST
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: LIST
105995: LIST
105996: LIST
105997: LIST
105998: LIST
105999: PUSH
106000: LD_INT 101
106002: PUSH
106003: LD_INT 102
106005: PUSH
106006: LD_INT 103
106008: PUSH
106009: LD_INT 104
106011: PUSH
106012: LD_INT 105
106014: PUSH
106015: LD_INT 106
106017: PUSH
106018: LD_INT 107
106020: PUSH
106021: LD_INT 108
106023: PUSH
106024: LD_INT 109
106026: PUSH
106027: LD_INT 110
106029: PUSH
106030: LD_INT 111
106032: PUSH
106033: LD_INT 112
106035: PUSH
106036: LD_INT 113
106038: PUSH
106039: LD_INT 114
106041: PUSH
106042: EMPTY
106043: LIST
106044: LIST
106045: LIST
106046: LIST
106047: LIST
106048: LIST
106049: LIST
106050: LIST
106051: LIST
106052: LIST
106053: LIST
106054: LIST
106055: LIST
106056: LIST
106057: PUSH
106058: EMPTY
106059: LIST
106060: LIST
106061: ST_TO_ADDR
106062: GO 106437
106064: LD_INT 18
106066: DOUBLE
106067: EQUAL
106068: IFTRUE 106072
106070: GO 106208
106072: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
106073: LD_ADDR_VAR 0 1
106077: PUSH
106078: LD_INT 2
106080: PUSH
106081: LD_INT 4
106083: PUSH
106084: LD_INT 5
106086: PUSH
106087: LD_INT 7
106089: PUSH
106090: LD_INT 11
106092: PUSH
106093: LD_INT 12
106095: PUSH
106096: LD_INT 15
106098: PUSH
106099: LD_INT 16
106101: PUSH
106102: LD_INT 20
106104: PUSH
106105: LD_INT 21
106107: PUSH
106108: LD_INT 22
106110: PUSH
106111: LD_INT 23
106113: PUSH
106114: LD_INT 25
106116: PUSH
106117: LD_INT 26
106119: PUSH
106120: LD_INT 30
106122: PUSH
106123: LD_INT 31
106125: PUSH
106126: LD_INT 32
106128: PUSH
106129: LD_INT 33
106131: PUSH
106132: LD_INT 34
106134: PUSH
106135: LD_INT 35
106137: PUSH
106138: LD_INT 36
106140: PUSH
106141: EMPTY
106142: LIST
106143: LIST
106144: LIST
106145: LIST
106146: LIST
106147: LIST
106148: LIST
106149: LIST
106150: LIST
106151: LIST
106152: LIST
106153: LIST
106154: LIST
106155: LIST
106156: LIST
106157: LIST
106158: LIST
106159: LIST
106160: LIST
106161: LIST
106162: LIST
106163: PUSH
106164: LD_INT 101
106166: PUSH
106167: LD_INT 102
106169: PUSH
106170: LD_INT 103
106172: PUSH
106173: LD_INT 106
106175: PUSH
106176: LD_INT 108
106178: PUSH
106179: LD_INT 112
106181: PUSH
106182: LD_INT 113
106184: PUSH
106185: LD_INT 114
106187: PUSH
106188: LD_INT 115
106190: PUSH
106191: EMPTY
106192: LIST
106193: LIST
106194: LIST
106195: LIST
106196: LIST
106197: LIST
106198: LIST
106199: LIST
106200: LIST
106201: PUSH
106202: EMPTY
106203: LIST
106204: LIST
106205: ST_TO_ADDR
106206: GO 106437
106208: LD_INT 19
106210: DOUBLE
106211: EQUAL
106212: IFTRUE 106216
106214: GO 106436
106216: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
106217: LD_ADDR_VAR 0 1
106221: PUSH
106222: LD_INT 1
106224: PUSH
106225: LD_INT 2
106227: PUSH
106228: LD_INT 3
106230: PUSH
106231: LD_INT 4
106233: PUSH
106234: LD_INT 5
106236: PUSH
106237: LD_INT 6
106239: PUSH
106240: LD_INT 7
106242: PUSH
106243: LD_INT 8
106245: PUSH
106246: LD_INT 9
106248: PUSH
106249: LD_INT 10
106251: PUSH
106252: LD_INT 11
106254: PUSH
106255: LD_INT 12
106257: PUSH
106258: LD_INT 13
106260: PUSH
106261: LD_INT 14
106263: PUSH
106264: LD_INT 15
106266: PUSH
106267: LD_INT 16
106269: PUSH
106270: LD_INT 17
106272: PUSH
106273: LD_INT 18
106275: PUSH
106276: LD_INT 19
106278: PUSH
106279: LD_INT 20
106281: PUSH
106282: LD_INT 21
106284: PUSH
106285: LD_INT 22
106287: PUSH
106288: LD_INT 23
106290: PUSH
106291: LD_INT 24
106293: PUSH
106294: LD_INT 25
106296: PUSH
106297: LD_INT 26
106299: PUSH
106300: LD_INT 27
106302: PUSH
106303: LD_INT 28
106305: PUSH
106306: LD_INT 29
106308: PUSH
106309: LD_INT 30
106311: PUSH
106312: LD_INT 31
106314: PUSH
106315: LD_INT 32
106317: PUSH
106318: LD_INT 33
106320: PUSH
106321: LD_INT 34
106323: PUSH
106324: LD_INT 35
106326: PUSH
106327: LD_INT 36
106329: PUSH
106330: EMPTY
106331: LIST
106332: LIST
106333: LIST
106334: LIST
106335: LIST
106336: LIST
106337: LIST
106338: LIST
106339: LIST
106340: LIST
106341: LIST
106342: LIST
106343: LIST
106344: LIST
106345: LIST
106346: LIST
106347: LIST
106348: LIST
106349: LIST
106350: LIST
106351: LIST
106352: LIST
106353: LIST
106354: LIST
106355: LIST
106356: LIST
106357: LIST
106358: LIST
106359: LIST
106360: LIST
106361: LIST
106362: LIST
106363: LIST
106364: LIST
106365: LIST
106366: LIST
106367: PUSH
106368: LD_INT 101
106370: PUSH
106371: LD_INT 102
106373: PUSH
106374: LD_INT 103
106376: PUSH
106377: LD_INT 104
106379: PUSH
106380: LD_INT 105
106382: PUSH
106383: LD_INT 106
106385: PUSH
106386: LD_INT 107
106388: PUSH
106389: LD_INT 108
106391: PUSH
106392: LD_INT 109
106394: PUSH
106395: LD_INT 110
106397: PUSH
106398: LD_INT 111
106400: PUSH
106401: LD_INT 112
106403: PUSH
106404: LD_INT 113
106406: PUSH
106407: LD_INT 114
106409: PUSH
106410: LD_INT 115
106412: PUSH
106413: EMPTY
106414: LIST
106415: LIST
106416: LIST
106417: LIST
106418: LIST
106419: LIST
106420: LIST
106421: LIST
106422: LIST
106423: LIST
106424: LIST
106425: LIST
106426: LIST
106427: LIST
106428: LIST
106429: PUSH
106430: EMPTY
106431: LIST
106432: LIST
106433: ST_TO_ADDR
106434: GO 106437
106436: POP
// end else
106437: GO 106656
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
106439: LD_ADDR_VAR 0 1
106443: PUSH
106444: LD_INT 1
106446: PUSH
106447: LD_INT 2
106449: PUSH
106450: LD_INT 3
106452: PUSH
106453: LD_INT 4
106455: PUSH
106456: LD_INT 5
106458: PUSH
106459: LD_INT 6
106461: PUSH
106462: LD_INT 7
106464: PUSH
106465: LD_INT 8
106467: PUSH
106468: LD_INT 9
106470: PUSH
106471: LD_INT 10
106473: PUSH
106474: LD_INT 11
106476: PUSH
106477: LD_INT 12
106479: PUSH
106480: LD_INT 13
106482: PUSH
106483: LD_INT 14
106485: PUSH
106486: LD_INT 15
106488: PUSH
106489: LD_INT 16
106491: PUSH
106492: LD_INT 17
106494: PUSH
106495: LD_INT 18
106497: PUSH
106498: LD_INT 19
106500: PUSH
106501: LD_INT 20
106503: PUSH
106504: LD_INT 21
106506: PUSH
106507: LD_INT 22
106509: PUSH
106510: LD_INT 23
106512: PUSH
106513: LD_INT 24
106515: PUSH
106516: LD_INT 25
106518: PUSH
106519: LD_INT 26
106521: PUSH
106522: LD_INT 27
106524: PUSH
106525: LD_INT 28
106527: PUSH
106528: LD_INT 29
106530: PUSH
106531: LD_INT 30
106533: PUSH
106534: LD_INT 31
106536: PUSH
106537: LD_INT 32
106539: PUSH
106540: LD_INT 33
106542: PUSH
106543: LD_INT 34
106545: PUSH
106546: LD_INT 35
106548: PUSH
106549: LD_INT 36
106551: PUSH
106552: EMPTY
106553: LIST
106554: LIST
106555: LIST
106556: LIST
106557: LIST
106558: LIST
106559: LIST
106560: LIST
106561: LIST
106562: LIST
106563: LIST
106564: LIST
106565: LIST
106566: LIST
106567: LIST
106568: LIST
106569: LIST
106570: LIST
106571: LIST
106572: LIST
106573: LIST
106574: LIST
106575: LIST
106576: LIST
106577: LIST
106578: LIST
106579: LIST
106580: LIST
106581: LIST
106582: LIST
106583: LIST
106584: LIST
106585: LIST
106586: LIST
106587: LIST
106588: LIST
106589: PUSH
106590: LD_INT 101
106592: PUSH
106593: LD_INT 102
106595: PUSH
106596: LD_INT 103
106598: PUSH
106599: LD_INT 104
106601: PUSH
106602: LD_INT 105
106604: PUSH
106605: LD_INT 106
106607: PUSH
106608: LD_INT 107
106610: PUSH
106611: LD_INT 108
106613: PUSH
106614: LD_INT 109
106616: PUSH
106617: LD_INT 110
106619: PUSH
106620: LD_INT 111
106622: PUSH
106623: LD_INT 112
106625: PUSH
106626: LD_INT 113
106628: PUSH
106629: LD_INT 114
106631: PUSH
106632: LD_INT 115
106634: PUSH
106635: EMPTY
106636: LIST
106637: LIST
106638: LIST
106639: LIST
106640: LIST
106641: LIST
106642: LIST
106643: LIST
106644: LIST
106645: LIST
106646: LIST
106647: LIST
106648: LIST
106649: LIST
106650: LIST
106651: PUSH
106652: EMPTY
106653: LIST
106654: LIST
106655: ST_TO_ADDR
// if result then
106656: LD_VAR 0 1
106660: IFFALSE 106949
// begin normal :=  ;
106662: LD_ADDR_VAR 0 3
106666: PUSH
106667: LD_STRING 
106669: ST_TO_ADDR
// hardcore :=  ;
106670: LD_ADDR_VAR 0 4
106674: PUSH
106675: LD_STRING 
106677: ST_TO_ADDR
// for i = 1 to normalCounter do
106678: LD_ADDR_VAR 0 5
106682: PUSH
106683: DOUBLE
106684: LD_INT 1
106686: DEC
106687: ST_TO_ADDR
106688: LD_EXP 157
106692: PUSH
106693: FOR_TO
106694: IFFALSE 106795
// begin tmp := 0 ;
106696: LD_ADDR_VAR 0 2
106700: PUSH
106701: LD_STRING 0
106703: ST_TO_ADDR
// if result [ 1 ] then
106704: LD_VAR 0 1
106708: PUSH
106709: LD_INT 1
106711: ARRAY
106712: IFFALSE 106777
// if result [ 1 ] [ 1 ] = i then
106714: LD_VAR 0 1
106718: PUSH
106719: LD_INT 1
106721: ARRAY
106722: PUSH
106723: LD_INT 1
106725: ARRAY
106726: PUSH
106727: LD_VAR 0 5
106731: EQUAL
106732: IFFALSE 106777
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
106734: LD_ADDR_VAR 0 1
106738: PUSH
106739: LD_VAR 0 1
106743: PPUSH
106744: LD_INT 1
106746: PPUSH
106747: LD_VAR 0 1
106751: PUSH
106752: LD_INT 1
106754: ARRAY
106755: PPUSH
106756: LD_INT 1
106758: PPUSH
106759: CALL_OW 3
106763: PPUSH
106764: CALL_OW 1
106768: ST_TO_ADDR
// tmp := 1 ;
106769: LD_ADDR_VAR 0 2
106773: PUSH
106774: LD_STRING 1
106776: ST_TO_ADDR
// end ; normal := normal & tmp ;
106777: LD_ADDR_VAR 0 3
106781: PUSH
106782: LD_VAR 0 3
106786: PUSH
106787: LD_VAR 0 2
106791: STR
106792: ST_TO_ADDR
// end ;
106793: GO 106693
106795: POP
106796: POP
// for i = 1 to hardcoreCounter do
106797: LD_ADDR_VAR 0 5
106801: PUSH
106802: DOUBLE
106803: LD_INT 1
106805: DEC
106806: ST_TO_ADDR
106807: LD_EXP 158
106811: PUSH
106812: FOR_TO
106813: IFFALSE 106918
// begin tmp := 0 ;
106815: LD_ADDR_VAR 0 2
106819: PUSH
106820: LD_STRING 0
106822: ST_TO_ADDR
// if result [ 2 ] then
106823: LD_VAR 0 1
106827: PUSH
106828: LD_INT 2
106830: ARRAY
106831: IFFALSE 106900
// if result [ 2 ] [ 1 ] = 100 + i then
106833: LD_VAR 0 1
106837: PUSH
106838: LD_INT 2
106840: ARRAY
106841: PUSH
106842: LD_INT 1
106844: ARRAY
106845: PUSH
106846: LD_INT 100
106848: PUSH
106849: LD_VAR 0 5
106853: PLUS
106854: EQUAL
106855: IFFALSE 106900
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
106857: LD_ADDR_VAR 0 1
106861: PUSH
106862: LD_VAR 0 1
106866: PPUSH
106867: LD_INT 2
106869: PPUSH
106870: LD_VAR 0 1
106874: PUSH
106875: LD_INT 2
106877: ARRAY
106878: PPUSH
106879: LD_INT 1
106881: PPUSH
106882: CALL_OW 3
106886: PPUSH
106887: CALL_OW 1
106891: ST_TO_ADDR
// tmp := 1 ;
106892: LD_ADDR_VAR 0 2
106896: PUSH
106897: LD_STRING 1
106899: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
106900: LD_ADDR_VAR 0 4
106904: PUSH
106905: LD_VAR 0 4
106909: PUSH
106910: LD_VAR 0 2
106914: STR
106915: ST_TO_ADDR
// end ;
106916: GO 106812
106918: POP
106919: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
106920: LD_STRING getStreamItemsFromMission("
106922: PUSH
106923: LD_VAR 0 3
106927: STR
106928: PUSH
106929: LD_STRING ","
106931: STR
106932: PUSH
106933: LD_VAR 0 4
106937: STR
106938: PUSH
106939: LD_STRING ")
106941: STR
106942: PPUSH
106943: CALL_OW 559
// end else
106947: GO 106956
// ToLua ( getStreamItemsFromMission("","") ) ;
106949: LD_STRING getStreamItemsFromMission("","")
106951: PPUSH
106952: CALL_OW 559
// end ;
106956: LD_VAR 0 1
106960: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
106961: LD_EXP 156
106965: PUSH
106966: LD_EXP 161
106970: AND
106971: IFFALSE 107095
106973: GO 106975
106975: DISABLE
106976: LD_INT 0
106978: PPUSH
106979: PPUSH
// begin enable ;
106980: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
106981: LD_ADDR_VAR 0 2
106985: PUSH
106986: LD_INT 22
106988: PUSH
106989: LD_OWVAR 2
106993: PUSH
106994: EMPTY
106995: LIST
106996: LIST
106997: PUSH
106998: LD_INT 2
107000: PUSH
107001: LD_INT 34
107003: PUSH
107004: LD_INT 7
107006: PUSH
107007: EMPTY
107008: LIST
107009: LIST
107010: PUSH
107011: LD_INT 34
107013: PUSH
107014: LD_INT 45
107016: PUSH
107017: EMPTY
107018: LIST
107019: LIST
107020: PUSH
107021: LD_INT 34
107023: PUSH
107024: LD_INT 28
107026: PUSH
107027: EMPTY
107028: LIST
107029: LIST
107030: PUSH
107031: LD_INT 34
107033: PUSH
107034: LD_INT 47
107036: PUSH
107037: EMPTY
107038: LIST
107039: LIST
107040: PUSH
107041: EMPTY
107042: LIST
107043: LIST
107044: LIST
107045: LIST
107046: LIST
107047: PUSH
107048: EMPTY
107049: LIST
107050: LIST
107051: PPUSH
107052: CALL_OW 69
107056: ST_TO_ADDR
// if not tmp then
107057: LD_VAR 0 2
107061: NOT
107062: IFFALSE 107066
// exit ;
107064: GO 107095
// for i in tmp do
107066: LD_ADDR_VAR 0 1
107070: PUSH
107071: LD_VAR 0 2
107075: PUSH
107076: FOR_IN
107077: IFFALSE 107093
// begin SetLives ( i , 0 ) ;
107079: LD_VAR 0 1
107083: PPUSH
107084: LD_INT 0
107086: PPUSH
107087: CALL_OW 234
// end ;
107091: GO 107076
107093: POP
107094: POP
// end ;
107095: PPOPN 2
107097: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
107098: LD_EXP 156
107102: PUSH
107103: LD_EXP 162
107107: AND
107108: IFFALSE 107192
107110: GO 107112
107112: DISABLE
107113: LD_INT 0
107115: PPUSH
107116: PPUSH
// begin enable ;
107117: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
107118: LD_ADDR_VAR 0 2
107122: PUSH
107123: LD_INT 22
107125: PUSH
107126: LD_OWVAR 2
107130: PUSH
107131: EMPTY
107132: LIST
107133: LIST
107134: PUSH
107135: LD_INT 32
107137: PUSH
107138: LD_INT 3
107140: PUSH
107141: EMPTY
107142: LIST
107143: LIST
107144: PUSH
107145: EMPTY
107146: LIST
107147: LIST
107148: PPUSH
107149: CALL_OW 69
107153: ST_TO_ADDR
// if not tmp then
107154: LD_VAR 0 2
107158: NOT
107159: IFFALSE 107163
// exit ;
107161: GO 107192
// for i in tmp do
107163: LD_ADDR_VAR 0 1
107167: PUSH
107168: LD_VAR 0 2
107172: PUSH
107173: FOR_IN
107174: IFFALSE 107190
// begin SetLives ( i , 0 ) ;
107176: LD_VAR 0 1
107180: PPUSH
107181: LD_INT 0
107183: PPUSH
107184: CALL_OW 234
// end ;
107188: GO 107173
107190: POP
107191: POP
// end ;
107192: PPOPN 2
107194: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
107195: LD_EXP 156
107199: PUSH
107200: LD_EXP 159
107204: AND
107205: IFFALSE 107298
107207: GO 107209
107209: DISABLE
107210: LD_INT 0
107212: PPUSH
// begin enable ;
107213: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
107214: LD_ADDR_VAR 0 1
107218: PUSH
107219: LD_INT 22
107221: PUSH
107222: LD_OWVAR 2
107226: PUSH
107227: EMPTY
107228: LIST
107229: LIST
107230: PUSH
107231: LD_INT 2
107233: PUSH
107234: LD_INT 25
107236: PUSH
107237: LD_INT 5
107239: PUSH
107240: EMPTY
107241: LIST
107242: LIST
107243: PUSH
107244: LD_INT 25
107246: PUSH
107247: LD_INT 9
107249: PUSH
107250: EMPTY
107251: LIST
107252: LIST
107253: PUSH
107254: LD_INT 25
107256: PUSH
107257: LD_INT 8
107259: PUSH
107260: EMPTY
107261: LIST
107262: LIST
107263: PUSH
107264: EMPTY
107265: LIST
107266: LIST
107267: LIST
107268: LIST
107269: PUSH
107270: EMPTY
107271: LIST
107272: LIST
107273: PPUSH
107274: CALL_OW 69
107278: PUSH
107279: FOR_IN
107280: IFFALSE 107296
// begin SetClass ( i , 1 ) ;
107282: LD_VAR 0 1
107286: PPUSH
107287: LD_INT 1
107289: PPUSH
107290: CALL_OW 336
// end ;
107294: GO 107279
107296: POP
107297: POP
// end ;
107298: PPOPN 1
107300: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
107301: LD_EXP 156
107305: PUSH
107306: LD_EXP 160
107310: AND
107311: PUSH
107312: LD_OWVAR 65
107316: PUSH
107317: LD_INT 7
107319: LESS
107320: AND
107321: IFFALSE 107335
107323: GO 107325
107325: DISABLE
// begin enable ;
107326: ENABLE
// game_speed := 7 ;
107327: LD_ADDR_OWVAR 65
107331: PUSH
107332: LD_INT 7
107334: ST_TO_ADDR
// end ;
107335: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
107336: LD_EXP 156
107340: PUSH
107341: LD_EXP 163
107345: AND
107346: IFFALSE 107548
107348: GO 107350
107350: DISABLE
107351: LD_INT 0
107353: PPUSH
107354: PPUSH
107355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107356: LD_ADDR_VAR 0 3
107360: PUSH
107361: LD_INT 81
107363: PUSH
107364: LD_OWVAR 2
107368: PUSH
107369: EMPTY
107370: LIST
107371: LIST
107372: PUSH
107373: LD_INT 21
107375: PUSH
107376: LD_INT 1
107378: PUSH
107379: EMPTY
107380: LIST
107381: LIST
107382: PUSH
107383: EMPTY
107384: LIST
107385: LIST
107386: PPUSH
107387: CALL_OW 69
107391: ST_TO_ADDR
// if not tmp then
107392: LD_VAR 0 3
107396: NOT
107397: IFFALSE 107401
// exit ;
107399: GO 107548
// if tmp > 5 then
107401: LD_VAR 0 3
107405: PUSH
107406: LD_INT 5
107408: GREATER
107409: IFFALSE 107421
// k := 5 else
107411: LD_ADDR_VAR 0 2
107415: PUSH
107416: LD_INT 5
107418: ST_TO_ADDR
107419: GO 107431
// k := tmp ;
107421: LD_ADDR_VAR 0 2
107425: PUSH
107426: LD_VAR 0 3
107430: ST_TO_ADDR
// for i := 1 to k do
107431: LD_ADDR_VAR 0 1
107435: PUSH
107436: DOUBLE
107437: LD_INT 1
107439: DEC
107440: ST_TO_ADDR
107441: LD_VAR 0 2
107445: PUSH
107446: FOR_TO
107447: IFFALSE 107546
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
107449: LD_VAR 0 3
107453: PUSH
107454: LD_VAR 0 1
107458: ARRAY
107459: PPUSH
107460: LD_VAR 0 1
107464: PUSH
107465: LD_INT 4
107467: MOD
107468: PUSH
107469: LD_INT 1
107471: PLUS
107472: PPUSH
107473: CALL_OW 259
107477: PUSH
107478: LD_INT 10
107480: LESS
107481: IFFALSE 107544
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
107483: LD_VAR 0 3
107487: PUSH
107488: LD_VAR 0 1
107492: ARRAY
107493: PPUSH
107494: LD_VAR 0 1
107498: PUSH
107499: LD_INT 4
107501: MOD
107502: PUSH
107503: LD_INT 1
107505: PLUS
107506: PPUSH
107507: LD_VAR 0 3
107511: PUSH
107512: LD_VAR 0 1
107516: ARRAY
107517: PPUSH
107518: LD_VAR 0 1
107522: PUSH
107523: LD_INT 4
107525: MOD
107526: PUSH
107527: LD_INT 1
107529: PLUS
107530: PPUSH
107531: CALL_OW 259
107535: PUSH
107536: LD_INT 1
107538: PLUS
107539: PPUSH
107540: CALL_OW 237
107544: GO 107446
107546: POP
107547: POP
// end ;
107548: PPOPN 3
107550: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
107551: LD_EXP 156
107555: PUSH
107556: LD_EXP 164
107560: AND
107561: IFFALSE 107581
107563: GO 107565
107565: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
107566: LD_INT 4
107568: PPUSH
107569: LD_OWVAR 2
107573: PPUSH
107574: LD_INT 0
107576: PPUSH
107577: CALL_OW 324
107581: END
// every 0 0$1 trigger StreamModeActive and sShovel do
107582: LD_EXP 156
107586: PUSH
107587: LD_EXP 193
107591: AND
107592: IFFALSE 107612
107594: GO 107596
107596: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
107597: LD_INT 19
107599: PPUSH
107600: LD_OWVAR 2
107604: PPUSH
107605: LD_INT 0
107607: PPUSH
107608: CALL_OW 324
107612: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
107613: LD_EXP 156
107617: PUSH
107618: LD_EXP 165
107622: AND
107623: IFFALSE 107725
107625: GO 107627
107627: DISABLE
107628: LD_INT 0
107630: PPUSH
107631: PPUSH
// begin enable ;
107632: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
107633: LD_ADDR_VAR 0 2
107637: PUSH
107638: LD_INT 22
107640: PUSH
107641: LD_OWVAR 2
107645: PUSH
107646: EMPTY
107647: LIST
107648: LIST
107649: PUSH
107650: LD_INT 2
107652: PUSH
107653: LD_INT 34
107655: PUSH
107656: LD_INT 11
107658: PUSH
107659: EMPTY
107660: LIST
107661: LIST
107662: PUSH
107663: LD_INT 34
107665: PUSH
107666: LD_INT 30
107668: PUSH
107669: EMPTY
107670: LIST
107671: LIST
107672: PUSH
107673: EMPTY
107674: LIST
107675: LIST
107676: LIST
107677: PUSH
107678: EMPTY
107679: LIST
107680: LIST
107681: PPUSH
107682: CALL_OW 69
107686: ST_TO_ADDR
// if not tmp then
107687: LD_VAR 0 2
107691: NOT
107692: IFFALSE 107696
// exit ;
107694: GO 107725
// for i in tmp do
107696: LD_ADDR_VAR 0 1
107700: PUSH
107701: LD_VAR 0 2
107705: PUSH
107706: FOR_IN
107707: IFFALSE 107723
// begin SetLives ( i , 0 ) ;
107709: LD_VAR 0 1
107713: PPUSH
107714: LD_INT 0
107716: PPUSH
107717: CALL_OW 234
// end ;
107721: GO 107706
107723: POP
107724: POP
// end ;
107725: PPOPN 2
107727: END
// every 0 0$1 trigger StreamModeActive and sBunker do
107728: LD_EXP 156
107732: PUSH
107733: LD_EXP 166
107737: AND
107738: IFFALSE 107758
107740: GO 107742
107742: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
107743: LD_INT 32
107745: PPUSH
107746: LD_OWVAR 2
107750: PPUSH
107751: LD_INT 0
107753: PPUSH
107754: CALL_OW 324
107758: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
107759: LD_EXP 156
107763: PUSH
107764: LD_EXP 167
107768: AND
107769: IFFALSE 107950
107771: GO 107773
107773: DISABLE
107774: LD_INT 0
107776: PPUSH
107777: PPUSH
107778: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
107779: LD_ADDR_VAR 0 2
107783: PUSH
107784: LD_INT 22
107786: PUSH
107787: LD_OWVAR 2
107791: PUSH
107792: EMPTY
107793: LIST
107794: LIST
107795: PUSH
107796: LD_INT 33
107798: PUSH
107799: LD_INT 3
107801: PUSH
107802: EMPTY
107803: LIST
107804: LIST
107805: PUSH
107806: EMPTY
107807: LIST
107808: LIST
107809: PPUSH
107810: CALL_OW 69
107814: ST_TO_ADDR
// if not tmp then
107815: LD_VAR 0 2
107819: NOT
107820: IFFALSE 107824
// exit ;
107822: GO 107950
// side := 0 ;
107824: LD_ADDR_VAR 0 3
107828: PUSH
107829: LD_INT 0
107831: ST_TO_ADDR
// for i := 1 to 8 do
107832: LD_ADDR_VAR 0 1
107836: PUSH
107837: DOUBLE
107838: LD_INT 1
107840: DEC
107841: ST_TO_ADDR
107842: LD_INT 8
107844: PUSH
107845: FOR_TO
107846: IFFALSE 107894
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
107848: LD_OWVAR 2
107852: PUSH
107853: LD_VAR 0 1
107857: NONEQUAL
107858: PUSH
107859: LD_OWVAR 2
107863: PPUSH
107864: LD_VAR 0 1
107868: PPUSH
107869: CALL_OW 81
107873: PUSH
107874: LD_INT 2
107876: EQUAL
107877: AND
107878: IFFALSE 107892
// begin side := i ;
107880: LD_ADDR_VAR 0 3
107884: PUSH
107885: LD_VAR 0 1
107889: ST_TO_ADDR
// break ;
107890: GO 107894
// end ;
107892: GO 107845
107894: POP
107895: POP
// if not side then
107896: LD_VAR 0 3
107900: NOT
107901: IFFALSE 107905
// exit ;
107903: GO 107950
// for i := 1 to tmp do
107905: LD_ADDR_VAR 0 1
107909: PUSH
107910: DOUBLE
107911: LD_INT 1
107913: DEC
107914: ST_TO_ADDR
107915: LD_VAR 0 2
107919: PUSH
107920: FOR_TO
107921: IFFALSE 107948
// if Prob ( 60 ) then
107923: LD_INT 60
107925: PPUSH
107926: CALL_OW 13
107930: IFFALSE 107946
// SetSide ( i , side ) ;
107932: LD_VAR 0 1
107936: PPUSH
107937: LD_VAR 0 3
107941: PPUSH
107942: CALL_OW 235
107946: GO 107920
107948: POP
107949: POP
// end ;
107950: PPOPN 3
107952: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
107953: LD_EXP 156
107957: PUSH
107958: LD_EXP 169
107962: AND
107963: IFFALSE 108082
107965: GO 107967
107967: DISABLE
107968: LD_INT 0
107970: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
107971: LD_ADDR_VAR 0 1
107975: PUSH
107976: LD_INT 22
107978: PUSH
107979: LD_OWVAR 2
107983: PUSH
107984: EMPTY
107985: LIST
107986: LIST
107987: PUSH
107988: LD_INT 21
107990: PUSH
107991: LD_INT 1
107993: PUSH
107994: EMPTY
107995: LIST
107996: LIST
107997: PUSH
107998: LD_INT 3
108000: PUSH
108001: LD_INT 23
108003: PUSH
108004: LD_INT 0
108006: PUSH
108007: EMPTY
108008: LIST
108009: LIST
108010: PUSH
108011: EMPTY
108012: LIST
108013: LIST
108014: PUSH
108015: EMPTY
108016: LIST
108017: LIST
108018: LIST
108019: PPUSH
108020: CALL_OW 69
108024: PUSH
108025: FOR_IN
108026: IFFALSE 108080
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
108028: LD_VAR 0 1
108032: PPUSH
108033: CALL_OW 257
108037: PUSH
108038: LD_INT 1
108040: PUSH
108041: LD_INT 2
108043: PUSH
108044: LD_INT 3
108046: PUSH
108047: LD_INT 4
108049: PUSH
108050: EMPTY
108051: LIST
108052: LIST
108053: LIST
108054: LIST
108055: IN
108056: IFFALSE 108078
// SetClass ( un , rand ( 1 , 4 ) ) ;
108058: LD_VAR 0 1
108062: PPUSH
108063: LD_INT 1
108065: PPUSH
108066: LD_INT 4
108068: PPUSH
108069: CALL_OW 12
108073: PPUSH
108074: CALL_OW 336
108078: GO 108025
108080: POP
108081: POP
// end ;
108082: PPOPN 1
108084: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
108085: LD_EXP 156
108089: PUSH
108090: LD_EXP 168
108094: AND
108095: IFFALSE 108174
108097: GO 108099
108099: DISABLE
108100: LD_INT 0
108102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108103: LD_ADDR_VAR 0 1
108107: PUSH
108108: LD_INT 22
108110: PUSH
108111: LD_OWVAR 2
108115: PUSH
108116: EMPTY
108117: LIST
108118: LIST
108119: PUSH
108120: LD_INT 21
108122: PUSH
108123: LD_INT 3
108125: PUSH
108126: EMPTY
108127: LIST
108128: LIST
108129: PUSH
108130: EMPTY
108131: LIST
108132: LIST
108133: PPUSH
108134: CALL_OW 69
108138: ST_TO_ADDR
// if not tmp then
108139: LD_VAR 0 1
108143: NOT
108144: IFFALSE 108148
// exit ;
108146: GO 108174
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
108148: LD_VAR 0 1
108152: PUSH
108153: LD_INT 1
108155: PPUSH
108156: LD_VAR 0 1
108160: PPUSH
108161: CALL_OW 12
108165: ARRAY
108166: PPUSH
108167: LD_INT 100
108169: PPUSH
108170: CALL_OW 234
// end ;
108174: PPOPN 1
108176: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
108177: LD_EXP 156
108181: PUSH
108182: LD_EXP 170
108186: AND
108187: IFFALSE 108285
108189: GO 108191
108191: DISABLE
108192: LD_INT 0
108194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
108195: LD_ADDR_VAR 0 1
108199: PUSH
108200: LD_INT 22
108202: PUSH
108203: LD_OWVAR 2
108207: PUSH
108208: EMPTY
108209: LIST
108210: LIST
108211: PUSH
108212: LD_INT 21
108214: PUSH
108215: LD_INT 1
108217: PUSH
108218: EMPTY
108219: LIST
108220: LIST
108221: PUSH
108222: EMPTY
108223: LIST
108224: LIST
108225: PPUSH
108226: CALL_OW 69
108230: ST_TO_ADDR
// if not tmp then
108231: LD_VAR 0 1
108235: NOT
108236: IFFALSE 108240
// exit ;
108238: GO 108285
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
108240: LD_VAR 0 1
108244: PUSH
108245: LD_INT 1
108247: PPUSH
108248: LD_VAR 0 1
108252: PPUSH
108253: CALL_OW 12
108257: ARRAY
108258: PPUSH
108259: LD_INT 1
108261: PPUSH
108262: LD_INT 4
108264: PPUSH
108265: CALL_OW 12
108269: PPUSH
108270: LD_INT 3000
108272: PPUSH
108273: LD_INT 9000
108275: PPUSH
108276: CALL_OW 12
108280: PPUSH
108281: CALL_OW 492
// end ;
108285: PPOPN 1
108287: END
// every 0 0$1 trigger StreamModeActive and sDepot do
108288: LD_EXP 156
108292: PUSH
108293: LD_EXP 171
108297: AND
108298: IFFALSE 108318
108300: GO 108302
108302: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
108303: LD_INT 1
108305: PPUSH
108306: LD_OWVAR 2
108310: PPUSH
108311: LD_INT 0
108313: PPUSH
108314: CALL_OW 324
108318: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
108319: LD_EXP 156
108323: PUSH
108324: LD_EXP 172
108328: AND
108329: IFFALSE 108412
108331: GO 108333
108333: DISABLE
108334: LD_INT 0
108336: PPUSH
108337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108338: LD_ADDR_VAR 0 2
108342: PUSH
108343: LD_INT 22
108345: PUSH
108346: LD_OWVAR 2
108350: PUSH
108351: EMPTY
108352: LIST
108353: LIST
108354: PUSH
108355: LD_INT 21
108357: PUSH
108358: LD_INT 3
108360: PUSH
108361: EMPTY
108362: LIST
108363: LIST
108364: PUSH
108365: EMPTY
108366: LIST
108367: LIST
108368: PPUSH
108369: CALL_OW 69
108373: ST_TO_ADDR
// if not tmp then
108374: LD_VAR 0 2
108378: NOT
108379: IFFALSE 108383
// exit ;
108381: GO 108412
// for i in tmp do
108383: LD_ADDR_VAR 0 1
108387: PUSH
108388: LD_VAR 0 2
108392: PUSH
108393: FOR_IN
108394: IFFALSE 108410
// SetBLevel ( i , 10 ) ;
108396: LD_VAR 0 1
108400: PPUSH
108401: LD_INT 10
108403: PPUSH
108404: CALL_OW 241
108408: GO 108393
108410: POP
108411: POP
// end ;
108412: PPOPN 2
108414: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
108415: LD_EXP 156
108419: PUSH
108420: LD_EXP 173
108424: AND
108425: IFFALSE 108536
108427: GO 108429
108429: DISABLE
108430: LD_INT 0
108432: PPUSH
108433: PPUSH
108434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108435: LD_ADDR_VAR 0 3
108439: PUSH
108440: LD_INT 22
108442: PUSH
108443: LD_OWVAR 2
108447: PUSH
108448: EMPTY
108449: LIST
108450: LIST
108451: PUSH
108452: LD_INT 25
108454: PUSH
108455: LD_INT 1
108457: PUSH
108458: EMPTY
108459: LIST
108460: LIST
108461: PUSH
108462: EMPTY
108463: LIST
108464: LIST
108465: PPUSH
108466: CALL_OW 69
108470: ST_TO_ADDR
// if not tmp then
108471: LD_VAR 0 3
108475: NOT
108476: IFFALSE 108480
// exit ;
108478: GO 108536
// un := tmp [ rand ( 1 , tmp ) ] ;
108480: LD_ADDR_VAR 0 2
108484: PUSH
108485: LD_VAR 0 3
108489: PUSH
108490: LD_INT 1
108492: PPUSH
108493: LD_VAR 0 3
108497: PPUSH
108498: CALL_OW 12
108502: ARRAY
108503: ST_TO_ADDR
// if Crawls ( un ) then
108504: LD_VAR 0 2
108508: PPUSH
108509: CALL_OW 318
108513: IFFALSE 108524
// ComWalk ( un ) ;
108515: LD_VAR 0 2
108519: PPUSH
108520: CALL_OW 138
// SetClass ( un , class_sniper ) ;
108524: LD_VAR 0 2
108528: PPUSH
108529: LD_INT 5
108531: PPUSH
108532: CALL_OW 336
// end ;
108536: PPOPN 3
108538: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
108539: LD_EXP 156
108543: PUSH
108544: LD_EXP 174
108548: AND
108549: PUSH
108550: LD_OWVAR 67
108554: PUSH
108555: LD_INT 3
108557: LESS
108558: AND
108559: IFFALSE 108578
108561: GO 108563
108563: DISABLE
// Difficulty := Difficulty + 1 ;
108564: LD_ADDR_OWVAR 67
108568: PUSH
108569: LD_OWVAR 67
108573: PUSH
108574: LD_INT 1
108576: PLUS
108577: ST_TO_ADDR
108578: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
108579: LD_EXP 156
108583: PUSH
108584: LD_EXP 175
108588: AND
108589: IFFALSE 108692
108591: GO 108593
108593: DISABLE
108594: LD_INT 0
108596: PPUSH
// begin for i := 1 to 5 do
108597: LD_ADDR_VAR 0 1
108601: PUSH
108602: DOUBLE
108603: LD_INT 1
108605: DEC
108606: ST_TO_ADDR
108607: LD_INT 5
108609: PUSH
108610: FOR_TO
108611: IFFALSE 108690
// begin uc_nation := nation_nature ;
108613: LD_ADDR_OWVAR 21
108617: PUSH
108618: LD_INT 0
108620: ST_TO_ADDR
// uc_side := 0 ;
108621: LD_ADDR_OWVAR 20
108625: PUSH
108626: LD_INT 0
108628: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108629: LD_ADDR_OWVAR 29
108633: PUSH
108634: LD_INT 12
108636: PUSH
108637: LD_INT 12
108639: PUSH
108640: EMPTY
108641: LIST
108642: LIST
108643: ST_TO_ADDR
// hc_agressivity := 20 ;
108644: LD_ADDR_OWVAR 35
108648: PUSH
108649: LD_INT 20
108651: ST_TO_ADDR
// hc_class := class_tiger ;
108652: LD_ADDR_OWVAR 28
108656: PUSH
108657: LD_INT 14
108659: ST_TO_ADDR
// hc_gallery :=  ;
108660: LD_ADDR_OWVAR 33
108664: PUSH
108665: LD_STRING 
108667: ST_TO_ADDR
// hc_name :=  ;
108668: LD_ADDR_OWVAR 26
108672: PUSH
108673: LD_STRING 
108675: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
108676: CALL_OW 44
108680: PPUSH
108681: LD_INT 0
108683: PPUSH
108684: CALL_OW 51
// end ;
108688: GO 108610
108690: POP
108691: POP
// end ;
108692: PPOPN 1
108694: END
// every 0 0$1 trigger StreamModeActive and sBomb do
108695: LD_EXP 156
108699: PUSH
108700: LD_EXP 176
108704: AND
108705: IFFALSE 108714
108707: GO 108709
108709: DISABLE
// StreamSibBomb ;
108710: CALL 108715 0 0
108714: END
// export function StreamSibBomb ; var i , x , y ; begin
108715: LD_INT 0
108717: PPUSH
108718: PPUSH
108719: PPUSH
108720: PPUSH
// result := false ;
108721: LD_ADDR_VAR 0 1
108725: PUSH
108726: LD_INT 0
108728: ST_TO_ADDR
// for i := 1 to 16 do
108729: LD_ADDR_VAR 0 2
108733: PUSH
108734: DOUBLE
108735: LD_INT 1
108737: DEC
108738: ST_TO_ADDR
108739: LD_INT 16
108741: PUSH
108742: FOR_TO
108743: IFFALSE 108942
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108745: LD_ADDR_VAR 0 3
108749: PUSH
108750: LD_INT 10
108752: PUSH
108753: LD_INT 20
108755: PUSH
108756: LD_INT 30
108758: PUSH
108759: LD_INT 40
108761: PUSH
108762: LD_INT 50
108764: PUSH
108765: LD_INT 60
108767: PUSH
108768: LD_INT 70
108770: PUSH
108771: LD_INT 80
108773: PUSH
108774: LD_INT 90
108776: PUSH
108777: LD_INT 100
108779: PUSH
108780: LD_INT 110
108782: PUSH
108783: LD_INT 120
108785: PUSH
108786: LD_INT 130
108788: PUSH
108789: LD_INT 140
108791: PUSH
108792: LD_INT 150
108794: PUSH
108795: EMPTY
108796: LIST
108797: LIST
108798: LIST
108799: LIST
108800: LIST
108801: LIST
108802: LIST
108803: LIST
108804: LIST
108805: LIST
108806: LIST
108807: LIST
108808: LIST
108809: LIST
108810: LIST
108811: PUSH
108812: LD_INT 1
108814: PPUSH
108815: LD_INT 15
108817: PPUSH
108818: CALL_OW 12
108822: ARRAY
108823: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108824: LD_ADDR_VAR 0 4
108828: PUSH
108829: LD_INT 10
108831: PUSH
108832: LD_INT 20
108834: PUSH
108835: LD_INT 30
108837: PUSH
108838: LD_INT 40
108840: PUSH
108841: LD_INT 50
108843: PUSH
108844: LD_INT 60
108846: PUSH
108847: LD_INT 70
108849: PUSH
108850: LD_INT 80
108852: PUSH
108853: LD_INT 90
108855: PUSH
108856: LD_INT 100
108858: PUSH
108859: LD_INT 110
108861: PUSH
108862: LD_INT 120
108864: PUSH
108865: LD_INT 130
108867: PUSH
108868: LD_INT 140
108870: PUSH
108871: LD_INT 150
108873: PUSH
108874: EMPTY
108875: LIST
108876: LIST
108877: LIST
108878: LIST
108879: LIST
108880: LIST
108881: LIST
108882: LIST
108883: LIST
108884: LIST
108885: LIST
108886: LIST
108887: LIST
108888: LIST
108889: LIST
108890: PUSH
108891: LD_INT 1
108893: PPUSH
108894: LD_INT 15
108896: PPUSH
108897: CALL_OW 12
108901: ARRAY
108902: ST_TO_ADDR
// if ValidHex ( x , y ) then
108903: LD_VAR 0 3
108907: PPUSH
108908: LD_VAR 0 4
108912: PPUSH
108913: CALL_OW 488
108917: IFFALSE 108940
// begin result := [ x , y ] ;
108919: LD_ADDR_VAR 0 1
108923: PUSH
108924: LD_VAR 0 3
108928: PUSH
108929: LD_VAR 0 4
108933: PUSH
108934: EMPTY
108935: LIST
108936: LIST
108937: ST_TO_ADDR
// break ;
108938: GO 108942
// end ; end ;
108940: GO 108742
108942: POP
108943: POP
// if result then
108944: LD_VAR 0 1
108948: IFFALSE 109008
// begin ToLua ( playSibBomb() ) ;
108950: LD_STRING playSibBomb()
108952: PPUSH
108953: CALL_OW 559
// wait ( 0 0$14 ) ;
108957: LD_INT 490
108959: PPUSH
108960: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
108964: LD_VAR 0 1
108968: PUSH
108969: LD_INT 1
108971: ARRAY
108972: PPUSH
108973: LD_VAR 0 1
108977: PUSH
108978: LD_INT 2
108980: ARRAY
108981: PPUSH
108982: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
108986: LD_VAR 0 1
108990: PUSH
108991: LD_INT 1
108993: ARRAY
108994: PPUSH
108995: LD_VAR 0 1
108999: PUSH
109000: LD_INT 2
109002: ARRAY
109003: PPUSH
109004: CALL_OW 429
// end ; end ;
109008: LD_VAR 0 1
109012: RET
// every 0 0$1 trigger StreamModeActive and sReset do
109013: LD_EXP 156
109017: PUSH
109018: LD_EXP 178
109022: AND
109023: IFFALSE 109035
109025: GO 109027
109027: DISABLE
// YouLost (  ) ;
109028: LD_STRING 
109030: PPUSH
109031: CALL_OW 104
109035: END
// every 0 0$1 trigger StreamModeActive and sFog do
109036: LD_EXP 156
109040: PUSH
109041: LD_EXP 177
109045: AND
109046: IFFALSE 109060
109048: GO 109050
109050: DISABLE
// FogOff ( your_side ) ;
109051: LD_OWVAR 2
109055: PPUSH
109056: CALL_OW 344
109060: END
// every 0 0$1 trigger StreamModeActive and sSun do
109061: LD_EXP 156
109065: PUSH
109066: LD_EXP 179
109070: AND
109071: IFFALSE 109099
109073: GO 109075
109075: DISABLE
// begin solar_recharge_percent := 0 ;
109076: LD_ADDR_OWVAR 79
109080: PUSH
109081: LD_INT 0
109083: ST_TO_ADDR
// wait ( 5 5$00 ) ;
109084: LD_INT 10500
109086: PPUSH
109087: CALL_OW 67
// solar_recharge_percent := 100 ;
109091: LD_ADDR_OWVAR 79
109095: PUSH
109096: LD_INT 100
109098: ST_TO_ADDR
// end ;
109099: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
109100: LD_EXP 156
109104: PUSH
109105: LD_EXP 180
109109: AND
109110: IFFALSE 109349
109112: GO 109114
109114: DISABLE
109115: LD_INT 0
109117: PPUSH
109118: PPUSH
109119: PPUSH
// begin tmp := [ ] ;
109120: LD_ADDR_VAR 0 3
109124: PUSH
109125: EMPTY
109126: ST_TO_ADDR
// for i := 1 to 6 do
109127: LD_ADDR_VAR 0 1
109131: PUSH
109132: DOUBLE
109133: LD_INT 1
109135: DEC
109136: ST_TO_ADDR
109137: LD_INT 6
109139: PUSH
109140: FOR_TO
109141: IFFALSE 109246
// begin uc_nation := nation_nature ;
109143: LD_ADDR_OWVAR 21
109147: PUSH
109148: LD_INT 0
109150: ST_TO_ADDR
// uc_side := 0 ;
109151: LD_ADDR_OWVAR 20
109155: PUSH
109156: LD_INT 0
109158: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109159: LD_ADDR_OWVAR 29
109163: PUSH
109164: LD_INT 12
109166: PUSH
109167: LD_INT 12
109169: PUSH
109170: EMPTY
109171: LIST
109172: LIST
109173: ST_TO_ADDR
// hc_agressivity := 20 ;
109174: LD_ADDR_OWVAR 35
109178: PUSH
109179: LD_INT 20
109181: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
109182: LD_ADDR_OWVAR 28
109186: PUSH
109187: LD_INT 17
109189: ST_TO_ADDR
// hc_gallery :=  ;
109190: LD_ADDR_OWVAR 33
109194: PUSH
109195: LD_STRING 
109197: ST_TO_ADDR
// hc_name :=  ;
109198: LD_ADDR_OWVAR 26
109202: PUSH
109203: LD_STRING 
109205: ST_TO_ADDR
// un := CreateHuman ;
109206: LD_ADDR_VAR 0 2
109210: PUSH
109211: CALL_OW 44
109215: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
109216: LD_VAR 0 2
109220: PPUSH
109221: LD_INT 1
109223: PPUSH
109224: CALL_OW 51
// tmp := tmp ^ un ;
109228: LD_ADDR_VAR 0 3
109232: PUSH
109233: LD_VAR 0 3
109237: PUSH
109238: LD_VAR 0 2
109242: ADD
109243: ST_TO_ADDR
// end ;
109244: GO 109140
109246: POP
109247: POP
// repeat wait ( 0 0$1 ) ;
109248: LD_INT 35
109250: PPUSH
109251: CALL_OW 67
// for un in tmp do
109255: LD_ADDR_VAR 0 2
109259: PUSH
109260: LD_VAR 0 3
109264: PUSH
109265: FOR_IN
109266: IFFALSE 109340
// begin if IsDead ( un ) then
109268: LD_VAR 0 2
109272: PPUSH
109273: CALL_OW 301
109277: IFFALSE 109297
// begin tmp := tmp diff un ;
109279: LD_ADDR_VAR 0 3
109283: PUSH
109284: LD_VAR 0 3
109288: PUSH
109289: LD_VAR 0 2
109293: DIFF
109294: ST_TO_ADDR
// continue ;
109295: GO 109265
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
109297: LD_VAR 0 2
109301: PPUSH
109302: LD_INT 3
109304: PUSH
109305: LD_INT 22
109307: PUSH
109308: LD_INT 0
109310: PUSH
109311: EMPTY
109312: LIST
109313: LIST
109314: PUSH
109315: EMPTY
109316: LIST
109317: LIST
109318: PPUSH
109319: CALL_OW 69
109323: PPUSH
109324: LD_VAR 0 2
109328: PPUSH
109329: CALL_OW 74
109333: PPUSH
109334: CALL_OW 115
// end ;
109338: GO 109265
109340: POP
109341: POP
// until not tmp ;
109342: LD_VAR 0 3
109346: NOT
109347: IFFALSE 109248
// end ;
109349: PPOPN 3
109351: END
// every 0 0$1 trigger StreamModeActive and sTroll do
109352: LD_EXP 156
109356: PUSH
109357: LD_EXP 181
109361: AND
109362: IFFALSE 109416
109364: GO 109366
109366: DISABLE
// begin ToLua ( displayTroll(); ) ;
109367: LD_STRING displayTroll();
109369: PPUSH
109370: CALL_OW 559
// wait ( 3 3$00 ) ;
109374: LD_INT 6300
109376: PPUSH
109377: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109381: LD_STRING hideTroll();
109383: PPUSH
109384: CALL_OW 559
// wait ( 1 1$00 ) ;
109388: LD_INT 2100
109390: PPUSH
109391: CALL_OW 67
// ToLua ( displayTroll(); ) ;
109395: LD_STRING displayTroll();
109397: PPUSH
109398: CALL_OW 559
// wait ( 1 1$00 ) ;
109402: LD_INT 2100
109404: PPUSH
109405: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109409: LD_STRING hideTroll();
109411: PPUSH
109412: CALL_OW 559
// end ;
109416: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
109417: LD_EXP 156
109421: PUSH
109422: LD_EXP 182
109426: AND
109427: IFFALSE 109490
109429: GO 109431
109431: DISABLE
109432: LD_INT 0
109434: PPUSH
// begin p := 0 ;
109435: LD_ADDR_VAR 0 1
109439: PUSH
109440: LD_INT 0
109442: ST_TO_ADDR
// repeat game_speed := 1 ;
109443: LD_ADDR_OWVAR 65
109447: PUSH
109448: LD_INT 1
109450: ST_TO_ADDR
// wait ( 0 0$1 ) ;
109451: LD_INT 35
109453: PPUSH
109454: CALL_OW 67
// p := p + 1 ;
109458: LD_ADDR_VAR 0 1
109462: PUSH
109463: LD_VAR 0 1
109467: PUSH
109468: LD_INT 1
109470: PLUS
109471: ST_TO_ADDR
// until p >= 60 ;
109472: LD_VAR 0 1
109476: PUSH
109477: LD_INT 60
109479: GREATEREQUAL
109480: IFFALSE 109443
// game_speed := 4 ;
109482: LD_ADDR_OWVAR 65
109486: PUSH
109487: LD_INT 4
109489: ST_TO_ADDR
// end ;
109490: PPOPN 1
109492: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
109493: LD_EXP 156
109497: PUSH
109498: LD_EXP 183
109502: AND
109503: IFFALSE 109649
109505: GO 109507
109507: DISABLE
109508: LD_INT 0
109510: PPUSH
109511: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109512: LD_ADDR_VAR 0 1
109516: PUSH
109517: LD_INT 22
109519: PUSH
109520: LD_OWVAR 2
109524: PUSH
109525: EMPTY
109526: LIST
109527: LIST
109528: PUSH
109529: LD_INT 2
109531: PUSH
109532: LD_INT 30
109534: PUSH
109535: LD_INT 0
109537: PUSH
109538: EMPTY
109539: LIST
109540: LIST
109541: PUSH
109542: LD_INT 30
109544: PUSH
109545: LD_INT 1
109547: PUSH
109548: EMPTY
109549: LIST
109550: LIST
109551: PUSH
109552: EMPTY
109553: LIST
109554: LIST
109555: LIST
109556: PUSH
109557: EMPTY
109558: LIST
109559: LIST
109560: PPUSH
109561: CALL_OW 69
109565: ST_TO_ADDR
// if not depot then
109566: LD_VAR 0 1
109570: NOT
109571: IFFALSE 109575
// exit ;
109573: GO 109649
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
109575: LD_ADDR_VAR 0 2
109579: PUSH
109580: LD_VAR 0 1
109584: PUSH
109585: LD_INT 1
109587: PPUSH
109588: LD_VAR 0 1
109592: PPUSH
109593: CALL_OW 12
109597: ARRAY
109598: PPUSH
109599: CALL_OW 274
109603: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
109604: LD_VAR 0 2
109608: PPUSH
109609: LD_INT 1
109611: PPUSH
109612: LD_INT 0
109614: PPUSH
109615: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
109619: LD_VAR 0 2
109623: PPUSH
109624: LD_INT 2
109626: PPUSH
109627: LD_INT 0
109629: PPUSH
109630: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
109634: LD_VAR 0 2
109638: PPUSH
109639: LD_INT 3
109641: PPUSH
109642: LD_INT 0
109644: PPUSH
109645: CALL_OW 277
// end ;
109649: PPOPN 2
109651: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
109652: LD_EXP 156
109656: PUSH
109657: LD_EXP 184
109661: AND
109662: IFFALSE 109759
109664: GO 109666
109666: DISABLE
109667: LD_INT 0
109669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109670: LD_ADDR_VAR 0 1
109674: PUSH
109675: LD_INT 22
109677: PUSH
109678: LD_OWVAR 2
109682: PUSH
109683: EMPTY
109684: LIST
109685: LIST
109686: PUSH
109687: LD_INT 21
109689: PUSH
109690: LD_INT 1
109692: PUSH
109693: EMPTY
109694: LIST
109695: LIST
109696: PUSH
109697: LD_INT 3
109699: PUSH
109700: LD_INT 23
109702: PUSH
109703: LD_INT 0
109705: PUSH
109706: EMPTY
109707: LIST
109708: LIST
109709: PUSH
109710: EMPTY
109711: LIST
109712: LIST
109713: PUSH
109714: EMPTY
109715: LIST
109716: LIST
109717: LIST
109718: PPUSH
109719: CALL_OW 69
109723: ST_TO_ADDR
// if not tmp then
109724: LD_VAR 0 1
109728: NOT
109729: IFFALSE 109733
// exit ;
109731: GO 109759
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
109733: LD_VAR 0 1
109737: PUSH
109738: LD_INT 1
109740: PPUSH
109741: LD_VAR 0 1
109745: PPUSH
109746: CALL_OW 12
109750: ARRAY
109751: PPUSH
109752: LD_INT 200
109754: PPUSH
109755: CALL_OW 234
// end ;
109759: PPOPN 1
109761: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
109762: LD_EXP 156
109766: PUSH
109767: LD_EXP 185
109771: AND
109772: IFFALSE 109851
109774: GO 109776
109776: DISABLE
109777: LD_INT 0
109779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
109780: LD_ADDR_VAR 0 1
109784: PUSH
109785: LD_INT 22
109787: PUSH
109788: LD_OWVAR 2
109792: PUSH
109793: EMPTY
109794: LIST
109795: LIST
109796: PUSH
109797: LD_INT 21
109799: PUSH
109800: LD_INT 2
109802: PUSH
109803: EMPTY
109804: LIST
109805: LIST
109806: PUSH
109807: EMPTY
109808: LIST
109809: LIST
109810: PPUSH
109811: CALL_OW 69
109815: ST_TO_ADDR
// if not tmp then
109816: LD_VAR 0 1
109820: NOT
109821: IFFALSE 109825
// exit ;
109823: GO 109851
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
109825: LD_VAR 0 1
109829: PUSH
109830: LD_INT 1
109832: PPUSH
109833: LD_VAR 0 1
109837: PPUSH
109838: CALL_OW 12
109842: ARRAY
109843: PPUSH
109844: LD_INT 60
109846: PPUSH
109847: CALL_OW 234
// end ;
109851: PPOPN 1
109853: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
109854: LD_EXP 156
109858: PUSH
109859: LD_EXP 186
109863: AND
109864: IFFALSE 109963
109866: GO 109868
109868: DISABLE
109869: LD_INT 0
109871: PPUSH
109872: PPUSH
// begin enable ;
109873: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
109874: LD_ADDR_VAR 0 1
109878: PUSH
109879: LD_INT 22
109881: PUSH
109882: LD_OWVAR 2
109886: PUSH
109887: EMPTY
109888: LIST
109889: LIST
109890: PUSH
109891: LD_INT 61
109893: PUSH
109894: EMPTY
109895: LIST
109896: PUSH
109897: LD_INT 33
109899: PUSH
109900: LD_INT 2
109902: PUSH
109903: EMPTY
109904: LIST
109905: LIST
109906: PUSH
109907: EMPTY
109908: LIST
109909: LIST
109910: LIST
109911: PPUSH
109912: CALL_OW 69
109916: ST_TO_ADDR
// if not tmp then
109917: LD_VAR 0 1
109921: NOT
109922: IFFALSE 109926
// exit ;
109924: GO 109963
// for i in tmp do
109926: LD_ADDR_VAR 0 2
109930: PUSH
109931: LD_VAR 0 1
109935: PUSH
109936: FOR_IN
109937: IFFALSE 109961
// if IsControledBy ( i ) then
109939: LD_VAR 0 2
109943: PPUSH
109944: CALL_OW 312
109948: IFFALSE 109959
// ComUnlink ( i ) ;
109950: LD_VAR 0 2
109954: PPUSH
109955: CALL_OW 136
109959: GO 109936
109961: POP
109962: POP
// end ;
109963: PPOPN 2
109965: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
109966: LD_EXP 156
109970: PUSH
109971: LD_EXP 187
109975: AND
109976: IFFALSE 110116
109978: GO 109980
109980: DISABLE
109981: LD_INT 0
109983: PPUSH
109984: PPUSH
// begin ToLua ( displayPowell(); ) ;
109985: LD_STRING displayPowell();
109987: PPUSH
109988: CALL_OW 559
// uc_side := 0 ;
109992: LD_ADDR_OWVAR 20
109996: PUSH
109997: LD_INT 0
109999: ST_TO_ADDR
// uc_nation := 2 ;
110000: LD_ADDR_OWVAR 21
110004: PUSH
110005: LD_INT 2
110007: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
110008: LD_ADDR_OWVAR 37
110012: PUSH
110013: LD_INT 14
110015: ST_TO_ADDR
// vc_engine := engine_siberite ;
110016: LD_ADDR_OWVAR 39
110020: PUSH
110021: LD_INT 3
110023: ST_TO_ADDR
// vc_control := control_apeman ;
110024: LD_ADDR_OWVAR 38
110028: PUSH
110029: LD_INT 5
110031: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
110032: LD_ADDR_OWVAR 40
110036: PUSH
110037: LD_INT 29
110039: ST_TO_ADDR
// un := CreateVehicle ;
110040: LD_ADDR_VAR 0 2
110044: PUSH
110045: CALL_OW 45
110049: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110050: LD_VAR 0 2
110054: PPUSH
110055: LD_INT 1
110057: PPUSH
110058: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110062: LD_INT 35
110064: PPUSH
110065: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110069: LD_VAR 0 2
110073: PPUSH
110074: LD_INT 22
110076: PUSH
110077: LD_OWVAR 2
110081: PUSH
110082: EMPTY
110083: LIST
110084: LIST
110085: PPUSH
110086: CALL_OW 69
110090: PPUSH
110091: LD_VAR 0 2
110095: PPUSH
110096: CALL_OW 74
110100: PPUSH
110101: CALL_OW 115
// until IsDead ( un ) ;
110105: LD_VAR 0 2
110109: PPUSH
110110: CALL_OW 301
110114: IFFALSE 110062
// end ;
110116: PPOPN 2
110118: END
// every 0 0$1 trigger StreamModeActive and sStu do
110119: LD_EXP 156
110123: PUSH
110124: LD_EXP 195
110128: AND
110129: IFFALSE 110145
110131: GO 110133
110133: DISABLE
// begin ToLua ( displayStucuk(); ) ;
110134: LD_STRING displayStucuk();
110136: PPUSH
110137: CALL_OW 559
// ResetFog ;
110141: CALL_OW 335
// end ;
110145: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
110146: LD_EXP 156
110150: PUSH
110151: LD_EXP 188
110155: AND
110156: IFFALSE 110297
110158: GO 110160
110160: DISABLE
110161: LD_INT 0
110163: PPUSH
110164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110165: LD_ADDR_VAR 0 2
110169: PUSH
110170: LD_INT 22
110172: PUSH
110173: LD_OWVAR 2
110177: PUSH
110178: EMPTY
110179: LIST
110180: LIST
110181: PUSH
110182: LD_INT 21
110184: PUSH
110185: LD_INT 1
110187: PUSH
110188: EMPTY
110189: LIST
110190: LIST
110191: PUSH
110192: EMPTY
110193: LIST
110194: LIST
110195: PPUSH
110196: CALL_OW 69
110200: ST_TO_ADDR
// if not tmp then
110201: LD_VAR 0 2
110205: NOT
110206: IFFALSE 110210
// exit ;
110208: GO 110297
// un := tmp [ rand ( 1 , tmp ) ] ;
110210: LD_ADDR_VAR 0 1
110214: PUSH
110215: LD_VAR 0 2
110219: PUSH
110220: LD_INT 1
110222: PPUSH
110223: LD_VAR 0 2
110227: PPUSH
110228: CALL_OW 12
110232: ARRAY
110233: ST_TO_ADDR
// SetSide ( un , 0 ) ;
110234: LD_VAR 0 1
110238: PPUSH
110239: LD_INT 0
110241: PPUSH
110242: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
110246: LD_VAR 0 1
110250: PPUSH
110251: LD_OWVAR 3
110255: PUSH
110256: LD_VAR 0 1
110260: DIFF
110261: PPUSH
110262: LD_VAR 0 1
110266: PPUSH
110267: CALL_OW 74
110271: PPUSH
110272: CALL_OW 115
// wait ( 0 0$20 ) ;
110276: LD_INT 700
110278: PPUSH
110279: CALL_OW 67
// SetSide ( un , your_side ) ;
110283: LD_VAR 0 1
110287: PPUSH
110288: LD_OWVAR 2
110292: PPUSH
110293: CALL_OW 235
// end ;
110297: PPOPN 2
110299: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
110300: LD_EXP 156
110304: PUSH
110305: LD_EXP 189
110309: AND
110310: IFFALSE 110416
110312: GO 110314
110314: DISABLE
110315: LD_INT 0
110317: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110318: LD_ADDR_VAR 0 1
110322: PUSH
110323: LD_INT 22
110325: PUSH
110326: LD_OWVAR 2
110330: PUSH
110331: EMPTY
110332: LIST
110333: LIST
110334: PUSH
110335: LD_INT 2
110337: PUSH
110338: LD_INT 30
110340: PUSH
110341: LD_INT 0
110343: PUSH
110344: EMPTY
110345: LIST
110346: LIST
110347: PUSH
110348: LD_INT 30
110350: PUSH
110351: LD_INT 1
110353: PUSH
110354: EMPTY
110355: LIST
110356: LIST
110357: PUSH
110358: EMPTY
110359: LIST
110360: LIST
110361: LIST
110362: PUSH
110363: EMPTY
110364: LIST
110365: LIST
110366: PPUSH
110367: CALL_OW 69
110371: ST_TO_ADDR
// if not depot then
110372: LD_VAR 0 1
110376: NOT
110377: IFFALSE 110381
// exit ;
110379: GO 110416
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
110381: LD_VAR 0 1
110385: PUSH
110386: LD_INT 1
110388: ARRAY
110389: PPUSH
110390: CALL_OW 250
110394: PPUSH
110395: LD_VAR 0 1
110399: PUSH
110400: LD_INT 1
110402: ARRAY
110403: PPUSH
110404: CALL_OW 251
110408: PPUSH
110409: LD_INT 70
110411: PPUSH
110412: CALL_OW 495
// end ;
110416: PPOPN 1
110418: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
110419: LD_EXP 156
110423: PUSH
110424: LD_EXP 190
110428: AND
110429: IFFALSE 110640
110431: GO 110433
110433: DISABLE
110434: LD_INT 0
110436: PPUSH
110437: PPUSH
110438: PPUSH
110439: PPUSH
110440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110441: LD_ADDR_VAR 0 5
110445: PUSH
110446: LD_INT 22
110448: PUSH
110449: LD_OWVAR 2
110453: PUSH
110454: EMPTY
110455: LIST
110456: LIST
110457: PUSH
110458: LD_INT 21
110460: PUSH
110461: LD_INT 1
110463: PUSH
110464: EMPTY
110465: LIST
110466: LIST
110467: PUSH
110468: EMPTY
110469: LIST
110470: LIST
110471: PPUSH
110472: CALL_OW 69
110476: ST_TO_ADDR
// if not tmp then
110477: LD_VAR 0 5
110481: NOT
110482: IFFALSE 110486
// exit ;
110484: GO 110640
// for i in tmp do
110486: LD_ADDR_VAR 0 1
110490: PUSH
110491: LD_VAR 0 5
110495: PUSH
110496: FOR_IN
110497: IFFALSE 110638
// begin d := rand ( 0 , 5 ) ;
110499: LD_ADDR_VAR 0 4
110503: PUSH
110504: LD_INT 0
110506: PPUSH
110507: LD_INT 5
110509: PPUSH
110510: CALL_OW 12
110514: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
110515: LD_ADDR_VAR 0 2
110519: PUSH
110520: LD_VAR 0 1
110524: PPUSH
110525: CALL_OW 250
110529: PPUSH
110530: LD_VAR 0 4
110534: PPUSH
110535: LD_INT 3
110537: PPUSH
110538: LD_INT 12
110540: PPUSH
110541: CALL_OW 12
110545: PPUSH
110546: CALL_OW 272
110550: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
110551: LD_ADDR_VAR 0 3
110555: PUSH
110556: LD_VAR 0 1
110560: PPUSH
110561: CALL_OW 251
110565: PPUSH
110566: LD_VAR 0 4
110570: PPUSH
110571: LD_INT 3
110573: PPUSH
110574: LD_INT 12
110576: PPUSH
110577: CALL_OW 12
110581: PPUSH
110582: CALL_OW 273
110586: ST_TO_ADDR
// if ValidHex ( x , y ) then
110587: LD_VAR 0 2
110591: PPUSH
110592: LD_VAR 0 3
110596: PPUSH
110597: CALL_OW 488
110601: IFFALSE 110636
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
110603: LD_VAR 0 1
110607: PPUSH
110608: LD_VAR 0 2
110612: PPUSH
110613: LD_VAR 0 3
110617: PPUSH
110618: LD_INT 3
110620: PPUSH
110621: LD_INT 6
110623: PPUSH
110624: CALL_OW 12
110628: PPUSH
110629: LD_INT 1
110631: PPUSH
110632: CALL_OW 483
// end ;
110636: GO 110496
110638: POP
110639: POP
// end ;
110640: PPOPN 5
110642: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110643: LD_EXP 156
110647: PUSH
110648: LD_EXP 191
110652: AND
110653: IFFALSE 110747
110655: GO 110657
110657: DISABLE
110658: LD_INT 0
110660: PPUSH
110661: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
110662: LD_ADDR_VAR 0 2
110666: PUSH
110667: LD_INT 22
110669: PUSH
110670: LD_OWVAR 2
110674: PUSH
110675: EMPTY
110676: LIST
110677: LIST
110678: PUSH
110679: LD_INT 32
110681: PUSH
110682: LD_INT 1
110684: PUSH
110685: EMPTY
110686: LIST
110687: LIST
110688: PUSH
110689: LD_INT 21
110691: PUSH
110692: LD_INT 2
110694: PUSH
110695: EMPTY
110696: LIST
110697: LIST
110698: PUSH
110699: EMPTY
110700: LIST
110701: LIST
110702: LIST
110703: PPUSH
110704: CALL_OW 69
110708: ST_TO_ADDR
// if not tmp then
110709: LD_VAR 0 2
110713: NOT
110714: IFFALSE 110718
// exit ;
110716: GO 110747
// for i in tmp do
110718: LD_ADDR_VAR 0 1
110722: PUSH
110723: LD_VAR 0 2
110727: PUSH
110728: FOR_IN
110729: IFFALSE 110745
// SetFuel ( i , 0 ) ;
110731: LD_VAR 0 1
110735: PPUSH
110736: LD_INT 0
110738: PPUSH
110739: CALL_OW 240
110743: GO 110728
110745: POP
110746: POP
// end ;
110747: PPOPN 2
110749: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
110750: LD_EXP 156
110754: PUSH
110755: LD_EXP 192
110759: AND
110760: IFFALSE 110826
110762: GO 110764
110764: DISABLE
110765: LD_INT 0
110767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
110768: LD_ADDR_VAR 0 1
110772: PUSH
110773: LD_INT 22
110775: PUSH
110776: LD_OWVAR 2
110780: PUSH
110781: EMPTY
110782: LIST
110783: LIST
110784: PUSH
110785: LD_INT 30
110787: PUSH
110788: LD_INT 29
110790: PUSH
110791: EMPTY
110792: LIST
110793: LIST
110794: PUSH
110795: EMPTY
110796: LIST
110797: LIST
110798: PPUSH
110799: CALL_OW 69
110803: ST_TO_ADDR
// if not tmp then
110804: LD_VAR 0 1
110808: NOT
110809: IFFALSE 110813
// exit ;
110811: GO 110826
// DestroyUnit ( tmp [ 1 ] ) ;
110813: LD_VAR 0 1
110817: PUSH
110818: LD_INT 1
110820: ARRAY
110821: PPUSH
110822: CALL_OW 65
// end ;
110826: PPOPN 1
110828: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
110829: LD_EXP 156
110833: PUSH
110834: LD_EXP 194
110838: AND
110839: IFFALSE 110968
110841: GO 110843
110843: DISABLE
110844: LD_INT 0
110846: PPUSH
// begin uc_side := 0 ;
110847: LD_ADDR_OWVAR 20
110851: PUSH
110852: LD_INT 0
110854: ST_TO_ADDR
// uc_nation := nation_arabian ;
110855: LD_ADDR_OWVAR 21
110859: PUSH
110860: LD_INT 2
110862: ST_TO_ADDR
// hc_gallery :=  ;
110863: LD_ADDR_OWVAR 33
110867: PUSH
110868: LD_STRING 
110870: ST_TO_ADDR
// hc_name :=  ;
110871: LD_ADDR_OWVAR 26
110875: PUSH
110876: LD_STRING 
110878: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
110879: LD_INT 1
110881: PPUSH
110882: LD_INT 11
110884: PPUSH
110885: LD_INT 10
110887: PPUSH
110888: CALL_OW 380
// un := CreateHuman ;
110892: LD_ADDR_VAR 0 1
110896: PUSH
110897: CALL_OW 44
110901: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110902: LD_VAR 0 1
110906: PPUSH
110907: LD_INT 1
110909: PPUSH
110910: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110914: LD_INT 35
110916: PPUSH
110917: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110921: LD_VAR 0 1
110925: PPUSH
110926: LD_INT 22
110928: PUSH
110929: LD_OWVAR 2
110933: PUSH
110934: EMPTY
110935: LIST
110936: LIST
110937: PPUSH
110938: CALL_OW 69
110942: PPUSH
110943: LD_VAR 0 1
110947: PPUSH
110948: CALL_OW 74
110952: PPUSH
110953: CALL_OW 115
// until IsDead ( un ) ;
110957: LD_VAR 0 1
110961: PPUSH
110962: CALL_OW 301
110966: IFFALSE 110914
// end ;
110968: PPOPN 1
110970: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
110971: LD_EXP 156
110975: PUSH
110976: LD_EXP 196
110980: AND
110981: IFFALSE 110993
110983: GO 110985
110985: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110986: LD_STRING earthquake(getX(game), 0, 32)
110988: PPUSH
110989: CALL_OW 559
110993: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110994: LD_EXP 156
110998: PUSH
110999: LD_EXP 197
111003: AND
111004: IFFALSE 111095
111006: GO 111008
111008: DISABLE
111009: LD_INT 0
111011: PPUSH
// begin enable ;
111012: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
111013: LD_ADDR_VAR 0 1
111017: PUSH
111018: LD_INT 22
111020: PUSH
111021: LD_OWVAR 2
111025: PUSH
111026: EMPTY
111027: LIST
111028: LIST
111029: PUSH
111030: LD_INT 21
111032: PUSH
111033: LD_INT 2
111035: PUSH
111036: EMPTY
111037: LIST
111038: LIST
111039: PUSH
111040: LD_INT 33
111042: PUSH
111043: LD_INT 3
111045: PUSH
111046: EMPTY
111047: LIST
111048: LIST
111049: PUSH
111050: EMPTY
111051: LIST
111052: LIST
111053: LIST
111054: PPUSH
111055: CALL_OW 69
111059: ST_TO_ADDR
// if not tmp then
111060: LD_VAR 0 1
111064: NOT
111065: IFFALSE 111069
// exit ;
111067: GO 111095
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111069: LD_VAR 0 1
111073: PUSH
111074: LD_INT 1
111076: PPUSH
111077: LD_VAR 0 1
111081: PPUSH
111082: CALL_OW 12
111086: ARRAY
111087: PPUSH
111088: LD_INT 1
111090: PPUSH
111091: CALL_OW 234
// end ;
111095: PPOPN 1
111097: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
111098: LD_EXP 156
111102: PUSH
111103: LD_EXP 198
111107: AND
111108: IFFALSE 111249
111110: GO 111112
111112: DISABLE
111113: LD_INT 0
111115: PPUSH
111116: PPUSH
111117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111118: LD_ADDR_VAR 0 3
111122: PUSH
111123: LD_INT 22
111125: PUSH
111126: LD_OWVAR 2
111130: PUSH
111131: EMPTY
111132: LIST
111133: LIST
111134: PUSH
111135: LD_INT 25
111137: PUSH
111138: LD_INT 1
111140: PUSH
111141: EMPTY
111142: LIST
111143: LIST
111144: PUSH
111145: EMPTY
111146: LIST
111147: LIST
111148: PPUSH
111149: CALL_OW 69
111153: ST_TO_ADDR
// if not tmp then
111154: LD_VAR 0 3
111158: NOT
111159: IFFALSE 111163
// exit ;
111161: GO 111249
// un := tmp [ rand ( 1 , tmp ) ] ;
111163: LD_ADDR_VAR 0 2
111167: PUSH
111168: LD_VAR 0 3
111172: PUSH
111173: LD_INT 1
111175: PPUSH
111176: LD_VAR 0 3
111180: PPUSH
111181: CALL_OW 12
111185: ARRAY
111186: ST_TO_ADDR
// if Crawls ( un ) then
111187: LD_VAR 0 2
111191: PPUSH
111192: CALL_OW 318
111196: IFFALSE 111207
// ComWalk ( un ) ;
111198: LD_VAR 0 2
111202: PPUSH
111203: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
111207: LD_VAR 0 2
111211: PPUSH
111212: LD_INT 9
111214: PPUSH
111215: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
111219: LD_INT 28
111221: PPUSH
111222: LD_OWVAR 2
111226: PPUSH
111227: LD_INT 2
111229: PPUSH
111230: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
111234: LD_INT 29
111236: PPUSH
111237: LD_OWVAR 2
111241: PPUSH
111242: LD_INT 2
111244: PPUSH
111245: CALL_OW 322
// end ;
111249: PPOPN 3
111251: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
111252: LD_EXP 156
111256: PUSH
111257: LD_EXP 199
111261: AND
111262: IFFALSE 111373
111264: GO 111266
111266: DISABLE
111267: LD_INT 0
111269: PPUSH
111270: PPUSH
111271: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111272: LD_ADDR_VAR 0 3
111276: PUSH
111277: LD_INT 22
111279: PUSH
111280: LD_OWVAR 2
111284: PUSH
111285: EMPTY
111286: LIST
111287: LIST
111288: PUSH
111289: LD_INT 25
111291: PUSH
111292: LD_INT 1
111294: PUSH
111295: EMPTY
111296: LIST
111297: LIST
111298: PUSH
111299: EMPTY
111300: LIST
111301: LIST
111302: PPUSH
111303: CALL_OW 69
111307: ST_TO_ADDR
// if not tmp then
111308: LD_VAR 0 3
111312: NOT
111313: IFFALSE 111317
// exit ;
111315: GO 111373
// un := tmp [ rand ( 1 , tmp ) ] ;
111317: LD_ADDR_VAR 0 2
111321: PUSH
111322: LD_VAR 0 3
111326: PUSH
111327: LD_INT 1
111329: PPUSH
111330: LD_VAR 0 3
111334: PPUSH
111335: CALL_OW 12
111339: ARRAY
111340: ST_TO_ADDR
// if Crawls ( un ) then
111341: LD_VAR 0 2
111345: PPUSH
111346: CALL_OW 318
111350: IFFALSE 111361
// ComWalk ( un ) ;
111352: LD_VAR 0 2
111356: PPUSH
111357: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111361: LD_VAR 0 2
111365: PPUSH
111366: LD_INT 8
111368: PPUSH
111369: CALL_OW 336
// end ;
111373: PPOPN 3
111375: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
111376: LD_EXP 156
111380: PUSH
111381: LD_EXP 200
111385: AND
111386: IFFALSE 111530
111388: GO 111390
111390: DISABLE
111391: LD_INT 0
111393: PPUSH
111394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
111395: LD_ADDR_VAR 0 2
111399: PUSH
111400: LD_INT 22
111402: PUSH
111403: LD_OWVAR 2
111407: PUSH
111408: EMPTY
111409: LIST
111410: LIST
111411: PUSH
111412: LD_INT 21
111414: PUSH
111415: LD_INT 2
111417: PUSH
111418: EMPTY
111419: LIST
111420: LIST
111421: PUSH
111422: LD_INT 2
111424: PUSH
111425: LD_INT 34
111427: PUSH
111428: LD_INT 12
111430: PUSH
111431: EMPTY
111432: LIST
111433: LIST
111434: PUSH
111435: LD_INT 34
111437: PUSH
111438: LD_INT 51
111440: PUSH
111441: EMPTY
111442: LIST
111443: LIST
111444: PUSH
111445: LD_INT 34
111447: PUSH
111448: LD_INT 32
111450: PUSH
111451: EMPTY
111452: LIST
111453: LIST
111454: PUSH
111455: EMPTY
111456: LIST
111457: LIST
111458: LIST
111459: LIST
111460: PUSH
111461: EMPTY
111462: LIST
111463: LIST
111464: LIST
111465: PPUSH
111466: CALL_OW 69
111470: ST_TO_ADDR
// if not tmp then
111471: LD_VAR 0 2
111475: NOT
111476: IFFALSE 111480
// exit ;
111478: GO 111530
// for i in tmp do
111480: LD_ADDR_VAR 0 1
111484: PUSH
111485: LD_VAR 0 2
111489: PUSH
111490: FOR_IN
111491: IFFALSE 111528
// if GetCargo ( i , mat_artifact ) = 0 then
111493: LD_VAR 0 1
111497: PPUSH
111498: LD_INT 4
111500: PPUSH
111501: CALL_OW 289
111505: PUSH
111506: LD_INT 0
111508: EQUAL
111509: IFFALSE 111526
// SetCargo ( i , mat_siberit , 100 ) ;
111511: LD_VAR 0 1
111515: PPUSH
111516: LD_INT 3
111518: PPUSH
111519: LD_INT 100
111521: PPUSH
111522: CALL_OW 290
111526: GO 111490
111528: POP
111529: POP
// end ;
111530: PPOPN 2
111532: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
111533: LD_EXP 156
111537: PUSH
111538: LD_EXP 201
111542: AND
111543: IFFALSE 111726
111545: GO 111547
111547: DISABLE
111548: LD_INT 0
111550: PPUSH
111551: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
111552: LD_ADDR_VAR 0 2
111556: PUSH
111557: LD_INT 22
111559: PUSH
111560: LD_OWVAR 2
111564: PUSH
111565: EMPTY
111566: LIST
111567: LIST
111568: PPUSH
111569: CALL_OW 69
111573: ST_TO_ADDR
// if not tmp then
111574: LD_VAR 0 2
111578: NOT
111579: IFFALSE 111583
// exit ;
111581: GO 111726
// for i := 1 to 2 do
111583: LD_ADDR_VAR 0 1
111587: PUSH
111588: DOUBLE
111589: LD_INT 1
111591: DEC
111592: ST_TO_ADDR
111593: LD_INT 2
111595: PUSH
111596: FOR_TO
111597: IFFALSE 111724
// begin uc_side := your_side ;
111599: LD_ADDR_OWVAR 20
111603: PUSH
111604: LD_OWVAR 2
111608: ST_TO_ADDR
// uc_nation := nation_american ;
111609: LD_ADDR_OWVAR 21
111613: PUSH
111614: LD_INT 1
111616: ST_TO_ADDR
// vc_chassis := us_morphling ;
111617: LD_ADDR_OWVAR 37
111621: PUSH
111622: LD_INT 5
111624: ST_TO_ADDR
// vc_engine := engine_siberite ;
111625: LD_ADDR_OWVAR 39
111629: PUSH
111630: LD_INT 3
111632: ST_TO_ADDR
// vc_control := control_computer ;
111633: LD_ADDR_OWVAR 38
111637: PUSH
111638: LD_INT 3
111640: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111641: LD_ADDR_OWVAR 40
111645: PUSH
111646: LD_INT 10
111648: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
111649: LD_VAR 0 2
111653: PUSH
111654: LD_INT 1
111656: ARRAY
111657: PPUSH
111658: CALL_OW 310
111662: NOT
111663: IFFALSE 111710
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
111665: CALL_OW 45
111669: PPUSH
111670: LD_VAR 0 2
111674: PUSH
111675: LD_INT 1
111677: ARRAY
111678: PPUSH
111679: CALL_OW 250
111683: PPUSH
111684: LD_VAR 0 2
111688: PUSH
111689: LD_INT 1
111691: ARRAY
111692: PPUSH
111693: CALL_OW 251
111697: PPUSH
111698: LD_INT 12
111700: PPUSH
111701: LD_INT 1
111703: PPUSH
111704: CALL_OW 50
111708: GO 111722
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
111710: CALL_OW 45
111714: PPUSH
111715: LD_INT 1
111717: PPUSH
111718: CALL_OW 51
// end ;
111722: GO 111596
111724: POP
111725: POP
// end ;
111726: PPOPN 2
111728: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
111729: LD_EXP 156
111733: PUSH
111734: LD_EXP 202
111738: AND
111739: IFFALSE 111961
111741: GO 111743
111743: DISABLE
111744: LD_INT 0
111746: PPUSH
111747: PPUSH
111748: PPUSH
111749: PPUSH
111750: PPUSH
111751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111752: LD_ADDR_VAR 0 6
111756: PUSH
111757: LD_INT 22
111759: PUSH
111760: LD_OWVAR 2
111764: PUSH
111765: EMPTY
111766: LIST
111767: LIST
111768: PUSH
111769: LD_INT 21
111771: PUSH
111772: LD_INT 1
111774: PUSH
111775: EMPTY
111776: LIST
111777: LIST
111778: PUSH
111779: LD_INT 3
111781: PUSH
111782: LD_INT 23
111784: PUSH
111785: LD_INT 0
111787: PUSH
111788: EMPTY
111789: LIST
111790: LIST
111791: PUSH
111792: EMPTY
111793: LIST
111794: LIST
111795: PUSH
111796: EMPTY
111797: LIST
111798: LIST
111799: LIST
111800: PPUSH
111801: CALL_OW 69
111805: ST_TO_ADDR
// if not tmp then
111806: LD_VAR 0 6
111810: NOT
111811: IFFALSE 111815
// exit ;
111813: GO 111961
// s1 := rand ( 1 , 4 ) ;
111815: LD_ADDR_VAR 0 2
111819: PUSH
111820: LD_INT 1
111822: PPUSH
111823: LD_INT 4
111825: PPUSH
111826: CALL_OW 12
111830: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
111831: LD_ADDR_VAR 0 4
111835: PUSH
111836: LD_VAR 0 6
111840: PUSH
111841: LD_INT 1
111843: ARRAY
111844: PPUSH
111845: LD_VAR 0 2
111849: PPUSH
111850: CALL_OW 259
111854: ST_TO_ADDR
// if s1 = 1 then
111855: LD_VAR 0 2
111859: PUSH
111860: LD_INT 1
111862: EQUAL
111863: IFFALSE 111883
// s2 := rand ( 2 , 4 ) else
111865: LD_ADDR_VAR 0 3
111869: PUSH
111870: LD_INT 2
111872: PPUSH
111873: LD_INT 4
111875: PPUSH
111876: CALL_OW 12
111880: ST_TO_ADDR
111881: GO 111891
// s2 := 1 ;
111883: LD_ADDR_VAR 0 3
111887: PUSH
111888: LD_INT 1
111890: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
111891: LD_ADDR_VAR 0 5
111895: PUSH
111896: LD_VAR 0 6
111900: PUSH
111901: LD_INT 1
111903: ARRAY
111904: PPUSH
111905: LD_VAR 0 3
111909: PPUSH
111910: CALL_OW 259
111914: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
111915: LD_VAR 0 6
111919: PUSH
111920: LD_INT 1
111922: ARRAY
111923: PPUSH
111924: LD_VAR 0 2
111928: PPUSH
111929: LD_VAR 0 5
111933: PPUSH
111934: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
111938: LD_VAR 0 6
111942: PUSH
111943: LD_INT 1
111945: ARRAY
111946: PPUSH
111947: LD_VAR 0 3
111951: PPUSH
111952: LD_VAR 0 4
111956: PPUSH
111957: CALL_OW 237
// end ;
111961: PPOPN 6
111963: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111964: LD_EXP 156
111968: PUSH
111969: LD_EXP 203
111973: AND
111974: IFFALSE 112053
111976: GO 111978
111978: DISABLE
111979: LD_INT 0
111981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111982: LD_ADDR_VAR 0 1
111986: PUSH
111987: LD_INT 22
111989: PUSH
111990: LD_OWVAR 2
111994: PUSH
111995: EMPTY
111996: LIST
111997: LIST
111998: PUSH
111999: LD_INT 30
112001: PUSH
112002: LD_INT 3
112004: PUSH
112005: EMPTY
112006: LIST
112007: LIST
112008: PUSH
112009: EMPTY
112010: LIST
112011: LIST
112012: PPUSH
112013: CALL_OW 69
112017: ST_TO_ADDR
// if not tmp then
112018: LD_VAR 0 1
112022: NOT
112023: IFFALSE 112027
// exit ;
112025: GO 112053
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
112027: LD_VAR 0 1
112031: PUSH
112032: LD_INT 1
112034: PPUSH
112035: LD_VAR 0 1
112039: PPUSH
112040: CALL_OW 12
112044: ARRAY
112045: PPUSH
112046: LD_INT 1
112048: PPUSH
112049: CALL_OW 234
// end ;
112053: PPOPN 1
112055: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
112056: LD_EXP 156
112060: PUSH
112061: LD_EXP 204
112065: AND
112066: IFFALSE 112178
112068: GO 112070
112070: DISABLE
112071: LD_INT 0
112073: PPUSH
112074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
112075: LD_ADDR_VAR 0 2
112079: PUSH
112080: LD_INT 22
112082: PUSH
112083: LD_OWVAR 2
112087: PUSH
112088: EMPTY
112089: LIST
112090: LIST
112091: PUSH
112092: LD_INT 2
112094: PUSH
112095: LD_INT 30
112097: PUSH
112098: LD_INT 27
112100: PUSH
112101: EMPTY
112102: LIST
112103: LIST
112104: PUSH
112105: LD_INT 30
112107: PUSH
112108: LD_INT 26
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: PUSH
112115: LD_INT 30
112117: PUSH
112118: LD_INT 28
112120: PUSH
112121: EMPTY
112122: LIST
112123: LIST
112124: PUSH
112125: EMPTY
112126: LIST
112127: LIST
112128: LIST
112129: LIST
112130: PUSH
112131: EMPTY
112132: LIST
112133: LIST
112134: PPUSH
112135: CALL_OW 69
112139: ST_TO_ADDR
// if not tmp then
112140: LD_VAR 0 2
112144: NOT
112145: IFFALSE 112149
// exit ;
112147: GO 112178
// for i in tmp do
112149: LD_ADDR_VAR 0 1
112153: PUSH
112154: LD_VAR 0 2
112158: PUSH
112159: FOR_IN
112160: IFFALSE 112176
// SetLives ( i , 1 ) ;
112162: LD_VAR 0 1
112166: PPUSH
112167: LD_INT 1
112169: PPUSH
112170: CALL_OW 234
112174: GO 112159
112176: POP
112177: POP
// end ;
112178: PPOPN 2
112180: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
112181: LD_EXP 156
112185: PUSH
112186: LD_EXP 205
112190: AND
112191: IFFALSE 112465
112193: GO 112195
112195: DISABLE
112196: LD_INT 0
112198: PPUSH
112199: PPUSH
112200: PPUSH
// begin i := rand ( 1 , 7 ) ;
112201: LD_ADDR_VAR 0 1
112205: PUSH
112206: LD_INT 1
112208: PPUSH
112209: LD_INT 7
112211: PPUSH
112212: CALL_OW 12
112216: ST_TO_ADDR
// case i of 1 :
112217: LD_VAR 0 1
112221: PUSH
112222: LD_INT 1
112224: DOUBLE
112225: EQUAL
112226: IFTRUE 112230
112228: GO 112240
112230: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
112231: LD_STRING earthquake(getX(game), 0, 32)
112233: PPUSH
112234: CALL_OW 559
112238: GO 112465
112240: LD_INT 2
112242: DOUBLE
112243: EQUAL
112244: IFTRUE 112248
112246: GO 112262
112248: POP
// begin ToLua ( displayStucuk(); ) ;
112249: LD_STRING displayStucuk();
112251: PPUSH
112252: CALL_OW 559
// ResetFog ;
112256: CALL_OW 335
// end ; 3 :
112260: GO 112465
112262: LD_INT 3
112264: DOUBLE
112265: EQUAL
112266: IFTRUE 112270
112268: GO 112374
112270: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112271: LD_ADDR_VAR 0 2
112275: PUSH
112276: LD_INT 22
112278: PUSH
112279: LD_OWVAR 2
112283: PUSH
112284: EMPTY
112285: LIST
112286: LIST
112287: PUSH
112288: LD_INT 25
112290: PUSH
112291: LD_INT 1
112293: PUSH
112294: EMPTY
112295: LIST
112296: LIST
112297: PUSH
112298: EMPTY
112299: LIST
112300: LIST
112301: PPUSH
112302: CALL_OW 69
112306: ST_TO_ADDR
// if not tmp then
112307: LD_VAR 0 2
112311: NOT
112312: IFFALSE 112316
// exit ;
112314: GO 112465
// un := tmp [ rand ( 1 , tmp ) ] ;
112316: LD_ADDR_VAR 0 3
112320: PUSH
112321: LD_VAR 0 2
112325: PUSH
112326: LD_INT 1
112328: PPUSH
112329: LD_VAR 0 2
112333: PPUSH
112334: CALL_OW 12
112338: ARRAY
112339: ST_TO_ADDR
// if Crawls ( un ) then
112340: LD_VAR 0 3
112344: PPUSH
112345: CALL_OW 318
112349: IFFALSE 112360
// ComWalk ( un ) ;
112351: LD_VAR 0 3
112355: PPUSH
112356: CALL_OW 138
// SetClass ( un , class_mortar ) ;
112360: LD_VAR 0 3
112364: PPUSH
112365: LD_INT 8
112367: PPUSH
112368: CALL_OW 336
// end ; 4 :
112372: GO 112465
112374: LD_INT 4
112376: DOUBLE
112377: EQUAL
112378: IFTRUE 112382
112380: GO 112443
112382: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
112383: LD_ADDR_VAR 0 2
112387: PUSH
112388: LD_INT 22
112390: PUSH
112391: LD_OWVAR 2
112395: PUSH
112396: EMPTY
112397: LIST
112398: LIST
112399: PUSH
112400: LD_INT 30
112402: PUSH
112403: LD_INT 29
112405: PUSH
112406: EMPTY
112407: LIST
112408: LIST
112409: PUSH
112410: EMPTY
112411: LIST
112412: LIST
112413: PPUSH
112414: CALL_OW 69
112418: ST_TO_ADDR
// if not tmp then
112419: LD_VAR 0 2
112423: NOT
112424: IFFALSE 112428
// exit ;
112426: GO 112465
// DestroyUnit ( tmp [ 1 ] ) ;
112428: LD_VAR 0 2
112432: PUSH
112433: LD_INT 1
112435: ARRAY
112436: PPUSH
112437: CALL_OW 65
// end ; 5 .. 7 :
112441: GO 112465
112443: LD_INT 5
112445: DOUBLE
112446: GREATEREQUAL
112447: IFFALSE 112455
112449: LD_INT 7
112451: DOUBLE
112452: LESSEQUAL
112453: IFTRUE 112457
112455: GO 112464
112457: POP
// StreamSibBomb ; end ;
112458: CALL 108715 0 0
112462: GO 112465
112464: POP
// end ;
112465: PPOPN 3
112467: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
112468: LD_EXP 156
112472: PUSH
112473: LD_EXP 206
112477: AND
112478: IFFALSE 112634
112480: GO 112482
112482: DISABLE
112483: LD_INT 0
112485: PPUSH
112486: PPUSH
112487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
112488: LD_ADDR_VAR 0 2
112492: PUSH
112493: LD_INT 81
112495: PUSH
112496: LD_OWVAR 2
112500: PUSH
112501: EMPTY
112502: LIST
112503: LIST
112504: PUSH
112505: LD_INT 2
112507: PUSH
112508: LD_INT 21
112510: PUSH
112511: LD_INT 1
112513: PUSH
112514: EMPTY
112515: LIST
112516: LIST
112517: PUSH
112518: LD_INT 21
112520: PUSH
112521: LD_INT 2
112523: PUSH
112524: EMPTY
112525: LIST
112526: LIST
112527: PUSH
112528: EMPTY
112529: LIST
112530: LIST
112531: LIST
112532: PUSH
112533: EMPTY
112534: LIST
112535: LIST
112536: PPUSH
112537: CALL_OW 69
112541: ST_TO_ADDR
// if not tmp then
112542: LD_VAR 0 2
112546: NOT
112547: IFFALSE 112551
// exit ;
112549: GO 112634
// p := 0 ;
112551: LD_ADDR_VAR 0 3
112555: PUSH
112556: LD_INT 0
112558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112559: LD_INT 35
112561: PPUSH
112562: CALL_OW 67
// p := p + 1 ;
112566: LD_ADDR_VAR 0 3
112570: PUSH
112571: LD_VAR 0 3
112575: PUSH
112576: LD_INT 1
112578: PLUS
112579: ST_TO_ADDR
// for i in tmp do
112580: LD_ADDR_VAR 0 1
112584: PUSH
112585: LD_VAR 0 2
112589: PUSH
112590: FOR_IN
112591: IFFALSE 112622
// if GetLives ( i ) < 1000 then
112593: LD_VAR 0 1
112597: PPUSH
112598: CALL_OW 256
112602: PUSH
112603: LD_INT 1000
112605: LESS
112606: IFFALSE 112620
// SetLives ( i , 1000 ) ;
112608: LD_VAR 0 1
112612: PPUSH
112613: LD_INT 1000
112615: PPUSH
112616: CALL_OW 234
112620: GO 112590
112622: POP
112623: POP
// until p > 20 ;
112624: LD_VAR 0 3
112628: PUSH
112629: LD_INT 20
112631: GREATER
112632: IFFALSE 112559
// end ;
112634: PPOPN 3
112636: END
// every 0 0$1 trigger StreamModeActive and sTime do
112637: LD_EXP 156
112641: PUSH
112642: LD_EXP 207
112646: AND
112647: IFFALSE 112682
112649: GO 112651
112651: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
112652: LD_INT 28
112654: PPUSH
112655: LD_OWVAR 2
112659: PPUSH
112660: LD_INT 2
112662: PPUSH
112663: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
112667: LD_INT 30
112669: PPUSH
112670: LD_OWVAR 2
112674: PPUSH
112675: LD_INT 2
112677: PPUSH
112678: CALL_OW 322
// end ;
112682: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
112683: LD_EXP 156
112687: PUSH
112688: LD_EXP 208
112692: AND
112693: IFFALSE 112814
112695: GO 112697
112697: DISABLE
112698: LD_INT 0
112700: PPUSH
112701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112702: LD_ADDR_VAR 0 2
112706: PUSH
112707: LD_INT 22
112709: PUSH
112710: LD_OWVAR 2
112714: PUSH
112715: EMPTY
112716: LIST
112717: LIST
112718: PUSH
112719: LD_INT 21
112721: PUSH
112722: LD_INT 1
112724: PUSH
112725: EMPTY
112726: LIST
112727: LIST
112728: PUSH
112729: LD_INT 3
112731: PUSH
112732: LD_INT 23
112734: PUSH
112735: LD_INT 0
112737: PUSH
112738: EMPTY
112739: LIST
112740: LIST
112741: PUSH
112742: EMPTY
112743: LIST
112744: LIST
112745: PUSH
112746: EMPTY
112747: LIST
112748: LIST
112749: LIST
112750: PPUSH
112751: CALL_OW 69
112755: ST_TO_ADDR
// if not tmp then
112756: LD_VAR 0 2
112760: NOT
112761: IFFALSE 112765
// exit ;
112763: GO 112814
// for i in tmp do
112765: LD_ADDR_VAR 0 1
112769: PUSH
112770: LD_VAR 0 2
112774: PUSH
112775: FOR_IN
112776: IFFALSE 112812
// begin if Crawls ( i ) then
112778: LD_VAR 0 1
112782: PPUSH
112783: CALL_OW 318
112787: IFFALSE 112798
// ComWalk ( i ) ;
112789: LD_VAR 0 1
112793: PPUSH
112794: CALL_OW 138
// SetClass ( i , 2 ) ;
112798: LD_VAR 0 1
112802: PPUSH
112803: LD_INT 2
112805: PPUSH
112806: CALL_OW 336
// end ;
112810: GO 112775
112812: POP
112813: POP
// end ;
112814: PPOPN 2
112816: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
112817: LD_EXP 156
112821: PUSH
112822: LD_EXP 209
112826: AND
112827: IFFALSE 113108
112829: GO 112831
112831: DISABLE
112832: LD_INT 0
112834: PPUSH
112835: PPUSH
112836: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
112837: LD_OWVAR 2
112841: PPUSH
112842: LD_INT 9
112844: PPUSH
112845: LD_INT 1
112847: PPUSH
112848: LD_INT 1
112850: PPUSH
112851: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
112855: LD_INT 9
112857: PPUSH
112858: LD_OWVAR 2
112862: PPUSH
112863: CALL_OW 343
// uc_side := 9 ;
112867: LD_ADDR_OWVAR 20
112871: PUSH
112872: LD_INT 9
112874: ST_TO_ADDR
// uc_nation := 2 ;
112875: LD_ADDR_OWVAR 21
112879: PUSH
112880: LD_INT 2
112882: ST_TO_ADDR
// hc_name := Dark Warrior ;
112883: LD_ADDR_OWVAR 26
112887: PUSH
112888: LD_STRING Dark Warrior
112890: ST_TO_ADDR
// hc_gallery :=  ;
112891: LD_ADDR_OWVAR 33
112895: PUSH
112896: LD_STRING 
112898: ST_TO_ADDR
// hc_noskilllimit := true ;
112899: LD_ADDR_OWVAR 76
112903: PUSH
112904: LD_INT 1
112906: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
112907: LD_ADDR_OWVAR 31
112911: PUSH
112912: LD_INT 30
112914: PUSH
112915: LD_INT 30
112917: PUSH
112918: LD_INT 30
112920: PUSH
112921: LD_INT 30
112923: PUSH
112924: EMPTY
112925: LIST
112926: LIST
112927: LIST
112928: LIST
112929: ST_TO_ADDR
// un := CreateHuman ;
112930: LD_ADDR_VAR 0 3
112934: PUSH
112935: CALL_OW 44
112939: ST_TO_ADDR
// hc_noskilllimit := false ;
112940: LD_ADDR_OWVAR 76
112944: PUSH
112945: LD_INT 0
112947: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112948: LD_VAR 0 3
112952: PPUSH
112953: LD_INT 1
112955: PPUSH
112956: CALL_OW 51
// p := 0 ;
112960: LD_ADDR_VAR 0 2
112964: PUSH
112965: LD_INT 0
112967: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112968: LD_INT 35
112970: PPUSH
112971: CALL_OW 67
// p := p + 1 ;
112975: LD_ADDR_VAR 0 2
112979: PUSH
112980: LD_VAR 0 2
112984: PUSH
112985: LD_INT 1
112987: PLUS
112988: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112989: LD_VAR 0 3
112993: PPUSH
112994: CALL_OW 256
112998: PUSH
112999: LD_INT 1000
113001: LESS
113002: IFFALSE 113016
// SetLives ( un , 1000 ) ;
113004: LD_VAR 0 3
113008: PPUSH
113009: LD_INT 1000
113011: PPUSH
113012: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
113016: LD_VAR 0 3
113020: PPUSH
113021: LD_INT 81
113023: PUSH
113024: LD_OWVAR 2
113028: PUSH
113029: EMPTY
113030: LIST
113031: LIST
113032: PUSH
113033: LD_INT 91
113035: PUSH
113036: LD_VAR 0 3
113040: PUSH
113041: LD_INT 30
113043: PUSH
113044: EMPTY
113045: LIST
113046: LIST
113047: LIST
113048: PUSH
113049: EMPTY
113050: LIST
113051: LIST
113052: PPUSH
113053: CALL_OW 69
113057: PPUSH
113058: LD_VAR 0 3
113062: PPUSH
113063: CALL_OW 74
113067: PPUSH
113068: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
113072: LD_VAR 0 2
113076: PUSH
113077: LD_INT 60
113079: GREATER
113080: PUSH
113081: LD_VAR 0 3
113085: PPUSH
113086: CALL_OW 301
113090: OR
113091: IFFALSE 112968
// if un then
113093: LD_VAR 0 3
113097: IFFALSE 113108
// RemoveUnit ( un ) ;
113099: LD_VAR 0 3
113103: PPUSH
113104: CALL_OW 64
// end ;
113108: PPOPN 3
113110: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113111: LD_INT 0
113113: PPUSH
// case cmd of 301 :
113114: LD_VAR 0 1
113118: PUSH
113119: LD_INT 301
113121: DOUBLE
113122: EQUAL
113123: IFTRUE 113127
113125: GO 113159
113127: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
113128: LD_VAR 0 6
113132: PPUSH
113133: LD_VAR 0 7
113137: PPUSH
113138: LD_VAR 0 8
113142: PPUSH
113143: LD_VAR 0 4
113147: PPUSH
113148: LD_VAR 0 5
113152: PPUSH
113153: CALL 114360 0 5
113157: GO 113280
113159: LD_INT 302
113161: DOUBLE
113162: EQUAL
113163: IFTRUE 113167
113165: GO 113204
113167: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
113168: LD_VAR 0 6
113172: PPUSH
113173: LD_VAR 0 7
113177: PPUSH
113178: LD_VAR 0 8
113182: PPUSH
113183: LD_VAR 0 9
113187: PPUSH
113188: LD_VAR 0 4
113192: PPUSH
113193: LD_VAR 0 5
113197: PPUSH
113198: CALL 114451 0 6
113202: GO 113280
113204: LD_INT 303
113206: DOUBLE
113207: EQUAL
113208: IFTRUE 113212
113210: GO 113249
113212: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
113213: LD_VAR 0 6
113217: PPUSH
113218: LD_VAR 0 7
113222: PPUSH
113223: LD_VAR 0 8
113227: PPUSH
113228: LD_VAR 0 9
113232: PPUSH
113233: LD_VAR 0 4
113237: PPUSH
113238: LD_VAR 0 5
113242: PPUSH
113243: CALL 113285 0 6
113247: GO 113280
113249: LD_INT 304
113251: DOUBLE
113252: EQUAL
113253: IFTRUE 113257
113255: GO 113279
113257: POP
// hHackTeleport ( unit , x , y ) ; end ;
113258: LD_VAR 0 2
113262: PPUSH
113263: LD_VAR 0 4
113267: PPUSH
113268: LD_VAR 0 5
113272: PPUSH
113273: CALL 115044 0 3
113277: GO 113280
113279: POP
// end ;
113280: LD_VAR 0 12
113284: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
113285: LD_INT 0
113287: PPUSH
113288: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
113289: LD_VAR 0 1
113293: PUSH
113294: LD_INT 1
113296: LESS
113297: PUSH
113298: LD_VAR 0 1
113302: PUSH
113303: LD_INT 3
113305: GREATER
113306: OR
113307: PUSH
113308: LD_VAR 0 5
113312: PPUSH
113313: LD_VAR 0 6
113317: PPUSH
113318: CALL_OW 428
113322: OR
113323: IFFALSE 113327
// exit ;
113325: GO 114047
// uc_side := your_side ;
113327: LD_ADDR_OWVAR 20
113331: PUSH
113332: LD_OWVAR 2
113336: ST_TO_ADDR
// uc_nation := nation ;
113337: LD_ADDR_OWVAR 21
113341: PUSH
113342: LD_VAR 0 1
113346: ST_TO_ADDR
// bc_level = 1 ;
113347: LD_ADDR_OWVAR 43
113351: PUSH
113352: LD_INT 1
113354: ST_TO_ADDR
// case btype of 1 :
113355: LD_VAR 0 2
113359: PUSH
113360: LD_INT 1
113362: DOUBLE
113363: EQUAL
113364: IFTRUE 113368
113366: GO 113379
113368: POP
// bc_type := b_depot ; 2 :
113369: LD_ADDR_OWVAR 42
113373: PUSH
113374: LD_INT 0
113376: ST_TO_ADDR
113377: GO 113991
113379: LD_INT 2
113381: DOUBLE
113382: EQUAL
113383: IFTRUE 113387
113385: GO 113398
113387: POP
// bc_type := b_warehouse ; 3 :
113388: LD_ADDR_OWVAR 42
113392: PUSH
113393: LD_INT 1
113395: ST_TO_ADDR
113396: GO 113991
113398: LD_INT 3
113400: DOUBLE
113401: EQUAL
113402: IFTRUE 113406
113404: GO 113417
113406: POP
// bc_type := b_lab ; 4 .. 9 :
113407: LD_ADDR_OWVAR 42
113411: PUSH
113412: LD_INT 6
113414: ST_TO_ADDR
113415: GO 113991
113417: LD_INT 4
113419: DOUBLE
113420: GREATEREQUAL
113421: IFFALSE 113429
113423: LD_INT 9
113425: DOUBLE
113426: LESSEQUAL
113427: IFTRUE 113431
113429: GO 113483
113431: POP
// begin bc_type := b_lab_half ;
113432: LD_ADDR_OWVAR 42
113436: PUSH
113437: LD_INT 7
113439: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
113440: LD_ADDR_OWVAR 44
113444: PUSH
113445: LD_INT 10
113447: PUSH
113448: LD_INT 11
113450: PUSH
113451: LD_INT 12
113453: PUSH
113454: LD_INT 15
113456: PUSH
113457: LD_INT 14
113459: PUSH
113460: LD_INT 13
113462: PUSH
113463: EMPTY
113464: LIST
113465: LIST
113466: LIST
113467: LIST
113468: LIST
113469: LIST
113470: PUSH
113471: LD_VAR 0 2
113475: PUSH
113476: LD_INT 3
113478: MINUS
113479: ARRAY
113480: ST_TO_ADDR
// end ; 10 .. 13 :
113481: GO 113991
113483: LD_INT 10
113485: DOUBLE
113486: GREATEREQUAL
113487: IFFALSE 113495
113489: LD_INT 13
113491: DOUBLE
113492: LESSEQUAL
113493: IFTRUE 113497
113495: GO 113574
113497: POP
// begin bc_type := b_lab_full ;
113498: LD_ADDR_OWVAR 42
113502: PUSH
113503: LD_INT 8
113505: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
113506: LD_ADDR_OWVAR 44
113510: PUSH
113511: LD_INT 10
113513: PUSH
113514: LD_INT 12
113516: PUSH
113517: LD_INT 14
113519: PUSH
113520: LD_INT 13
113522: PUSH
113523: EMPTY
113524: LIST
113525: LIST
113526: LIST
113527: LIST
113528: PUSH
113529: LD_VAR 0 2
113533: PUSH
113534: LD_INT 9
113536: MINUS
113537: ARRAY
113538: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
113539: LD_ADDR_OWVAR 45
113543: PUSH
113544: LD_INT 11
113546: PUSH
113547: LD_INT 15
113549: PUSH
113550: LD_INT 12
113552: PUSH
113553: LD_INT 15
113555: PUSH
113556: EMPTY
113557: LIST
113558: LIST
113559: LIST
113560: LIST
113561: PUSH
113562: LD_VAR 0 2
113566: PUSH
113567: LD_INT 9
113569: MINUS
113570: ARRAY
113571: ST_TO_ADDR
// end ; 14 :
113572: GO 113991
113574: LD_INT 14
113576: DOUBLE
113577: EQUAL
113578: IFTRUE 113582
113580: GO 113593
113582: POP
// bc_type := b_workshop ; 15 :
113583: LD_ADDR_OWVAR 42
113587: PUSH
113588: LD_INT 2
113590: ST_TO_ADDR
113591: GO 113991
113593: LD_INT 15
113595: DOUBLE
113596: EQUAL
113597: IFTRUE 113601
113599: GO 113612
113601: POP
// bc_type := b_factory ; 16 :
113602: LD_ADDR_OWVAR 42
113606: PUSH
113607: LD_INT 3
113609: ST_TO_ADDR
113610: GO 113991
113612: LD_INT 16
113614: DOUBLE
113615: EQUAL
113616: IFTRUE 113620
113618: GO 113631
113620: POP
// bc_type := b_ext_gun ; 17 :
113621: LD_ADDR_OWVAR 42
113625: PUSH
113626: LD_INT 17
113628: ST_TO_ADDR
113629: GO 113991
113631: LD_INT 17
113633: DOUBLE
113634: EQUAL
113635: IFTRUE 113639
113637: GO 113667
113639: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
113640: LD_ADDR_OWVAR 42
113644: PUSH
113645: LD_INT 19
113647: PUSH
113648: LD_INT 23
113650: PUSH
113651: LD_INT 19
113653: PUSH
113654: EMPTY
113655: LIST
113656: LIST
113657: LIST
113658: PUSH
113659: LD_VAR 0 1
113663: ARRAY
113664: ST_TO_ADDR
113665: GO 113991
113667: LD_INT 18
113669: DOUBLE
113670: EQUAL
113671: IFTRUE 113675
113673: GO 113686
113675: POP
// bc_type := b_ext_radar ; 19 :
113676: LD_ADDR_OWVAR 42
113680: PUSH
113681: LD_INT 20
113683: ST_TO_ADDR
113684: GO 113991
113686: LD_INT 19
113688: DOUBLE
113689: EQUAL
113690: IFTRUE 113694
113692: GO 113705
113694: POP
// bc_type := b_ext_radio ; 20 :
113695: LD_ADDR_OWVAR 42
113699: PUSH
113700: LD_INT 22
113702: ST_TO_ADDR
113703: GO 113991
113705: LD_INT 20
113707: DOUBLE
113708: EQUAL
113709: IFTRUE 113713
113711: GO 113724
113713: POP
// bc_type := b_ext_siberium ; 21 :
113714: LD_ADDR_OWVAR 42
113718: PUSH
113719: LD_INT 21
113721: ST_TO_ADDR
113722: GO 113991
113724: LD_INT 21
113726: DOUBLE
113727: EQUAL
113728: IFTRUE 113732
113730: GO 113743
113732: POP
// bc_type := b_ext_computer ; 22 :
113733: LD_ADDR_OWVAR 42
113737: PUSH
113738: LD_INT 24
113740: ST_TO_ADDR
113741: GO 113991
113743: LD_INT 22
113745: DOUBLE
113746: EQUAL
113747: IFTRUE 113751
113749: GO 113762
113751: POP
// bc_type := b_ext_track ; 23 :
113752: LD_ADDR_OWVAR 42
113756: PUSH
113757: LD_INT 16
113759: ST_TO_ADDR
113760: GO 113991
113762: LD_INT 23
113764: DOUBLE
113765: EQUAL
113766: IFTRUE 113770
113768: GO 113781
113770: POP
// bc_type := b_ext_laser ; 24 :
113771: LD_ADDR_OWVAR 42
113775: PUSH
113776: LD_INT 25
113778: ST_TO_ADDR
113779: GO 113991
113781: LD_INT 24
113783: DOUBLE
113784: EQUAL
113785: IFTRUE 113789
113787: GO 113800
113789: POP
// bc_type := b_control_tower ; 25 :
113790: LD_ADDR_OWVAR 42
113794: PUSH
113795: LD_INT 36
113797: ST_TO_ADDR
113798: GO 113991
113800: LD_INT 25
113802: DOUBLE
113803: EQUAL
113804: IFTRUE 113808
113806: GO 113819
113808: POP
// bc_type := b_breastwork ; 26 :
113809: LD_ADDR_OWVAR 42
113813: PUSH
113814: LD_INT 31
113816: ST_TO_ADDR
113817: GO 113991
113819: LD_INT 26
113821: DOUBLE
113822: EQUAL
113823: IFTRUE 113827
113825: GO 113838
113827: POP
// bc_type := b_bunker ; 27 :
113828: LD_ADDR_OWVAR 42
113832: PUSH
113833: LD_INT 32
113835: ST_TO_ADDR
113836: GO 113991
113838: LD_INT 27
113840: DOUBLE
113841: EQUAL
113842: IFTRUE 113846
113844: GO 113857
113846: POP
// bc_type := b_turret ; 28 :
113847: LD_ADDR_OWVAR 42
113851: PUSH
113852: LD_INT 33
113854: ST_TO_ADDR
113855: GO 113991
113857: LD_INT 28
113859: DOUBLE
113860: EQUAL
113861: IFTRUE 113865
113863: GO 113876
113865: POP
// bc_type := b_armoury ; 29 :
113866: LD_ADDR_OWVAR 42
113870: PUSH
113871: LD_INT 4
113873: ST_TO_ADDR
113874: GO 113991
113876: LD_INT 29
113878: DOUBLE
113879: EQUAL
113880: IFTRUE 113884
113882: GO 113895
113884: POP
// bc_type := b_barracks ; 30 :
113885: LD_ADDR_OWVAR 42
113889: PUSH
113890: LD_INT 5
113892: ST_TO_ADDR
113893: GO 113991
113895: LD_INT 30
113897: DOUBLE
113898: EQUAL
113899: IFTRUE 113903
113901: GO 113914
113903: POP
// bc_type := b_solar_power ; 31 :
113904: LD_ADDR_OWVAR 42
113908: PUSH
113909: LD_INT 27
113911: ST_TO_ADDR
113912: GO 113991
113914: LD_INT 31
113916: DOUBLE
113917: EQUAL
113918: IFTRUE 113922
113920: GO 113933
113922: POP
// bc_type := b_oil_power ; 32 :
113923: LD_ADDR_OWVAR 42
113927: PUSH
113928: LD_INT 26
113930: ST_TO_ADDR
113931: GO 113991
113933: LD_INT 32
113935: DOUBLE
113936: EQUAL
113937: IFTRUE 113941
113939: GO 113952
113941: POP
// bc_type := b_siberite_power ; 33 :
113942: LD_ADDR_OWVAR 42
113946: PUSH
113947: LD_INT 28
113949: ST_TO_ADDR
113950: GO 113991
113952: LD_INT 33
113954: DOUBLE
113955: EQUAL
113956: IFTRUE 113960
113958: GO 113971
113960: POP
// bc_type := b_oil_mine ; 34 :
113961: LD_ADDR_OWVAR 42
113965: PUSH
113966: LD_INT 29
113968: ST_TO_ADDR
113969: GO 113991
113971: LD_INT 34
113973: DOUBLE
113974: EQUAL
113975: IFTRUE 113979
113977: GO 113990
113979: POP
// bc_type := b_siberite_mine ; end ;
113980: LD_ADDR_OWVAR 42
113984: PUSH
113985: LD_INT 30
113987: ST_TO_ADDR
113988: GO 113991
113990: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
113991: LD_ADDR_VAR 0 8
113995: PUSH
113996: LD_VAR 0 5
114000: PPUSH
114001: LD_VAR 0 6
114005: PPUSH
114006: LD_VAR 0 3
114010: PPUSH
114011: CALL_OW 47
114015: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
114016: LD_OWVAR 42
114020: PUSH
114021: LD_INT 32
114023: PUSH
114024: LD_INT 33
114026: PUSH
114027: EMPTY
114028: LIST
114029: LIST
114030: IN
114031: IFFALSE 114047
// PlaceWeaponTurret ( b , weapon ) ;
114033: LD_VAR 0 8
114037: PPUSH
114038: LD_VAR 0 4
114042: PPUSH
114043: CALL_OW 431
// end ;
114047: LD_VAR 0 7
114051: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
114052: LD_INT 0
114054: PPUSH
114055: PPUSH
114056: PPUSH
114057: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114058: LD_ADDR_VAR 0 4
114062: PUSH
114063: LD_INT 22
114065: PUSH
114066: LD_OWVAR 2
114070: PUSH
114071: EMPTY
114072: LIST
114073: LIST
114074: PUSH
114075: LD_INT 2
114077: PUSH
114078: LD_INT 30
114080: PUSH
114081: LD_INT 0
114083: PUSH
114084: EMPTY
114085: LIST
114086: LIST
114087: PUSH
114088: LD_INT 30
114090: PUSH
114091: LD_INT 1
114093: PUSH
114094: EMPTY
114095: LIST
114096: LIST
114097: PUSH
114098: EMPTY
114099: LIST
114100: LIST
114101: LIST
114102: PUSH
114103: EMPTY
114104: LIST
114105: LIST
114106: PPUSH
114107: CALL_OW 69
114111: ST_TO_ADDR
// if not tmp then
114112: LD_VAR 0 4
114116: NOT
114117: IFFALSE 114121
// exit ;
114119: GO 114180
// for i in tmp do
114121: LD_ADDR_VAR 0 2
114125: PUSH
114126: LD_VAR 0 4
114130: PUSH
114131: FOR_IN
114132: IFFALSE 114178
// for j = 1 to 3 do
114134: LD_ADDR_VAR 0 3
114138: PUSH
114139: DOUBLE
114140: LD_INT 1
114142: DEC
114143: ST_TO_ADDR
114144: LD_INT 3
114146: PUSH
114147: FOR_TO
114148: IFFALSE 114174
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
114150: LD_VAR 0 2
114154: PPUSH
114155: CALL_OW 274
114159: PPUSH
114160: LD_VAR 0 3
114164: PPUSH
114165: LD_INT 99999
114167: PPUSH
114168: CALL_OW 277
114172: GO 114147
114174: POP
114175: POP
114176: GO 114131
114178: POP
114179: POP
// end ;
114180: LD_VAR 0 1
114184: RET
// export function hHackSetLevel10 ; var i , j ; begin
114185: LD_INT 0
114187: PPUSH
114188: PPUSH
114189: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114190: LD_ADDR_VAR 0 2
114194: PUSH
114195: LD_INT 21
114197: PUSH
114198: LD_INT 1
114200: PUSH
114201: EMPTY
114202: LIST
114203: LIST
114204: PPUSH
114205: CALL_OW 69
114209: PUSH
114210: FOR_IN
114211: IFFALSE 114263
// if IsSelected ( i ) then
114213: LD_VAR 0 2
114217: PPUSH
114218: CALL_OW 306
114222: IFFALSE 114261
// begin for j := 1 to 4 do
114224: LD_ADDR_VAR 0 3
114228: PUSH
114229: DOUBLE
114230: LD_INT 1
114232: DEC
114233: ST_TO_ADDR
114234: LD_INT 4
114236: PUSH
114237: FOR_TO
114238: IFFALSE 114259
// SetSkill ( i , j , 10 ) ;
114240: LD_VAR 0 2
114244: PPUSH
114245: LD_VAR 0 3
114249: PPUSH
114250: LD_INT 10
114252: PPUSH
114253: CALL_OW 237
114257: GO 114237
114259: POP
114260: POP
// end ;
114261: GO 114210
114263: POP
114264: POP
// end ;
114265: LD_VAR 0 1
114269: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
114270: LD_INT 0
114272: PPUSH
114273: PPUSH
114274: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
114275: LD_ADDR_VAR 0 2
114279: PUSH
114280: LD_INT 22
114282: PUSH
114283: LD_OWVAR 2
114287: PUSH
114288: EMPTY
114289: LIST
114290: LIST
114291: PUSH
114292: LD_INT 21
114294: PUSH
114295: LD_INT 1
114297: PUSH
114298: EMPTY
114299: LIST
114300: LIST
114301: PUSH
114302: EMPTY
114303: LIST
114304: LIST
114305: PPUSH
114306: CALL_OW 69
114310: PUSH
114311: FOR_IN
114312: IFFALSE 114353
// begin for j := 1 to 4 do
114314: LD_ADDR_VAR 0 3
114318: PUSH
114319: DOUBLE
114320: LD_INT 1
114322: DEC
114323: ST_TO_ADDR
114324: LD_INT 4
114326: PUSH
114327: FOR_TO
114328: IFFALSE 114349
// SetSkill ( i , j , 10 ) ;
114330: LD_VAR 0 2
114334: PPUSH
114335: LD_VAR 0 3
114339: PPUSH
114340: LD_INT 10
114342: PPUSH
114343: CALL_OW 237
114347: GO 114327
114349: POP
114350: POP
// end ;
114351: GO 114311
114353: POP
114354: POP
// end ;
114355: LD_VAR 0 1
114359: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
114360: LD_INT 0
114362: PPUSH
// uc_side := your_side ;
114363: LD_ADDR_OWVAR 20
114367: PUSH
114368: LD_OWVAR 2
114372: ST_TO_ADDR
// uc_nation := nation ;
114373: LD_ADDR_OWVAR 21
114377: PUSH
114378: LD_VAR 0 1
114382: ST_TO_ADDR
// InitHc ;
114383: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
114387: LD_INT 0
114389: PPUSH
114390: LD_VAR 0 2
114394: PPUSH
114395: LD_VAR 0 3
114399: PPUSH
114400: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
114404: LD_VAR 0 4
114408: PPUSH
114409: LD_VAR 0 5
114413: PPUSH
114414: CALL_OW 428
114418: PUSH
114419: LD_INT 0
114421: EQUAL
114422: IFFALSE 114446
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
114424: CALL_OW 44
114428: PPUSH
114429: LD_VAR 0 4
114433: PPUSH
114434: LD_VAR 0 5
114438: PPUSH
114439: LD_INT 1
114441: PPUSH
114442: CALL_OW 48
// end ;
114446: LD_VAR 0 6
114450: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
114451: LD_INT 0
114453: PPUSH
114454: PPUSH
// uc_side := your_side ;
114455: LD_ADDR_OWVAR 20
114459: PUSH
114460: LD_OWVAR 2
114464: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
114465: LD_VAR 0 1
114469: PUSH
114470: LD_INT 1
114472: PUSH
114473: LD_INT 2
114475: PUSH
114476: LD_INT 3
114478: PUSH
114479: LD_INT 4
114481: PUSH
114482: LD_INT 5
114484: PUSH
114485: EMPTY
114486: LIST
114487: LIST
114488: LIST
114489: LIST
114490: LIST
114491: IN
114492: IFFALSE 114504
// uc_nation := nation_american else
114494: LD_ADDR_OWVAR 21
114498: PUSH
114499: LD_INT 1
114501: ST_TO_ADDR
114502: GO 114547
// if chassis in [ 11 , 12 , 13 , 14 ] then
114504: LD_VAR 0 1
114508: PUSH
114509: LD_INT 11
114511: PUSH
114512: LD_INT 12
114514: PUSH
114515: LD_INT 13
114517: PUSH
114518: LD_INT 14
114520: PUSH
114521: EMPTY
114522: LIST
114523: LIST
114524: LIST
114525: LIST
114526: IN
114527: IFFALSE 114539
// uc_nation := nation_arabian else
114529: LD_ADDR_OWVAR 21
114533: PUSH
114534: LD_INT 2
114536: ST_TO_ADDR
114537: GO 114547
// uc_nation := nation_russian ;
114539: LD_ADDR_OWVAR 21
114543: PUSH
114544: LD_INT 3
114546: ST_TO_ADDR
// vc_chassis := chassis ;
114547: LD_ADDR_OWVAR 37
114551: PUSH
114552: LD_VAR 0 1
114556: ST_TO_ADDR
// vc_engine := engine ;
114557: LD_ADDR_OWVAR 39
114561: PUSH
114562: LD_VAR 0 2
114566: ST_TO_ADDR
// vc_control := control ;
114567: LD_ADDR_OWVAR 38
114571: PUSH
114572: LD_VAR 0 3
114576: ST_TO_ADDR
// vc_weapon := weapon ;
114577: LD_ADDR_OWVAR 40
114581: PUSH
114582: LD_VAR 0 4
114586: ST_TO_ADDR
// un := CreateVehicle ;
114587: LD_ADDR_VAR 0 8
114591: PUSH
114592: CALL_OW 45
114596: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
114597: LD_VAR 0 8
114601: PPUSH
114602: LD_INT 0
114604: PPUSH
114605: LD_INT 5
114607: PPUSH
114608: CALL_OW 12
114612: PPUSH
114613: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
114617: LD_VAR 0 8
114621: PPUSH
114622: LD_VAR 0 5
114626: PPUSH
114627: LD_VAR 0 6
114631: PPUSH
114632: LD_INT 1
114634: PPUSH
114635: CALL_OW 48
// end ;
114639: LD_VAR 0 7
114643: RET
// export hInvincible ; every 1 do
114644: GO 114646
114646: DISABLE
// hInvincible := [ ] ;
114647: LD_ADDR_EXP 210
114651: PUSH
114652: EMPTY
114653: ST_TO_ADDR
114654: END
// every 10 do var i ;
114655: GO 114657
114657: DISABLE
114658: LD_INT 0
114660: PPUSH
// begin enable ;
114661: ENABLE
// if not hInvincible then
114662: LD_EXP 210
114666: NOT
114667: IFFALSE 114671
// exit ;
114669: GO 114715
// for i in hInvincible do
114671: LD_ADDR_VAR 0 1
114675: PUSH
114676: LD_EXP 210
114680: PUSH
114681: FOR_IN
114682: IFFALSE 114713
// if GetLives ( i ) < 1000 then
114684: LD_VAR 0 1
114688: PPUSH
114689: CALL_OW 256
114693: PUSH
114694: LD_INT 1000
114696: LESS
114697: IFFALSE 114711
// SetLives ( i , 1000 ) ;
114699: LD_VAR 0 1
114703: PPUSH
114704: LD_INT 1000
114706: PPUSH
114707: CALL_OW 234
114711: GO 114681
114713: POP
114714: POP
// end ;
114715: PPOPN 1
114717: END
// export function hHackInvincible ; var i ; begin
114718: LD_INT 0
114720: PPUSH
114721: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
114722: LD_ADDR_VAR 0 2
114726: PUSH
114727: LD_INT 2
114729: PUSH
114730: LD_INT 21
114732: PUSH
114733: LD_INT 1
114735: PUSH
114736: EMPTY
114737: LIST
114738: LIST
114739: PUSH
114740: LD_INT 21
114742: PUSH
114743: LD_INT 2
114745: PUSH
114746: EMPTY
114747: LIST
114748: LIST
114749: PUSH
114750: EMPTY
114751: LIST
114752: LIST
114753: LIST
114754: PPUSH
114755: CALL_OW 69
114759: PUSH
114760: FOR_IN
114761: IFFALSE 114822
// if IsSelected ( i ) then
114763: LD_VAR 0 2
114767: PPUSH
114768: CALL_OW 306
114772: IFFALSE 114820
// begin if i in hInvincible then
114774: LD_VAR 0 2
114778: PUSH
114779: LD_EXP 210
114783: IN
114784: IFFALSE 114804
// hInvincible := hInvincible diff i else
114786: LD_ADDR_EXP 210
114790: PUSH
114791: LD_EXP 210
114795: PUSH
114796: LD_VAR 0 2
114800: DIFF
114801: ST_TO_ADDR
114802: GO 114820
// hInvincible := hInvincible union i ;
114804: LD_ADDR_EXP 210
114808: PUSH
114809: LD_EXP 210
114813: PUSH
114814: LD_VAR 0 2
114818: UNION
114819: ST_TO_ADDR
// end ;
114820: GO 114760
114822: POP
114823: POP
// end ;
114824: LD_VAR 0 1
114828: RET
// export function hHackInvisible ; var i , j ; begin
114829: LD_INT 0
114831: PPUSH
114832: PPUSH
114833: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114834: LD_ADDR_VAR 0 2
114838: PUSH
114839: LD_INT 21
114841: PUSH
114842: LD_INT 1
114844: PUSH
114845: EMPTY
114846: LIST
114847: LIST
114848: PPUSH
114849: CALL_OW 69
114853: PUSH
114854: FOR_IN
114855: IFFALSE 114879
// if IsSelected ( i ) then
114857: LD_VAR 0 2
114861: PPUSH
114862: CALL_OW 306
114866: IFFALSE 114877
// ComForceInvisible ( i ) ;
114868: LD_VAR 0 2
114872: PPUSH
114873: CALL_OW 496
114877: GO 114854
114879: POP
114880: POP
// end ;
114881: LD_VAR 0 1
114885: RET
// export function hHackChangeYourSide ; begin
114886: LD_INT 0
114888: PPUSH
// if your_side = 8 then
114889: LD_OWVAR 2
114893: PUSH
114894: LD_INT 8
114896: EQUAL
114897: IFFALSE 114909
// your_side := 0 else
114899: LD_ADDR_OWVAR 2
114903: PUSH
114904: LD_INT 0
114906: ST_TO_ADDR
114907: GO 114923
// your_side := your_side + 1 ;
114909: LD_ADDR_OWVAR 2
114913: PUSH
114914: LD_OWVAR 2
114918: PUSH
114919: LD_INT 1
114921: PLUS
114922: ST_TO_ADDR
// end ;
114923: LD_VAR 0 1
114927: RET
// export function hHackChangeUnitSide ; var i , j ; begin
114928: LD_INT 0
114930: PPUSH
114931: PPUSH
114932: PPUSH
// for i in all_units do
114933: LD_ADDR_VAR 0 2
114937: PUSH
114938: LD_OWVAR 3
114942: PUSH
114943: FOR_IN
114944: IFFALSE 115022
// if IsSelected ( i ) then
114946: LD_VAR 0 2
114950: PPUSH
114951: CALL_OW 306
114955: IFFALSE 115020
// begin j := GetSide ( i ) ;
114957: LD_ADDR_VAR 0 3
114961: PUSH
114962: LD_VAR 0 2
114966: PPUSH
114967: CALL_OW 255
114971: ST_TO_ADDR
// if j = 8 then
114972: LD_VAR 0 3
114976: PUSH
114977: LD_INT 8
114979: EQUAL
114980: IFFALSE 114992
// j := 0 else
114982: LD_ADDR_VAR 0 3
114986: PUSH
114987: LD_INT 0
114989: ST_TO_ADDR
114990: GO 115006
// j := j + 1 ;
114992: LD_ADDR_VAR 0 3
114996: PUSH
114997: LD_VAR 0 3
115001: PUSH
115002: LD_INT 1
115004: PLUS
115005: ST_TO_ADDR
// SetSide ( i , j ) ;
115006: LD_VAR 0 2
115010: PPUSH
115011: LD_VAR 0 3
115015: PPUSH
115016: CALL_OW 235
// end ;
115020: GO 114943
115022: POP
115023: POP
// end ;
115024: LD_VAR 0 1
115028: RET
// export function hHackFog ; begin
115029: LD_INT 0
115031: PPUSH
// FogOff ( true ) ;
115032: LD_INT 1
115034: PPUSH
115035: CALL_OW 344
// end ;
115039: LD_VAR 0 1
115043: RET
// export function hHackTeleport ( unit , x , y ) ; begin
115044: LD_INT 0
115046: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
115047: LD_VAR 0 1
115051: PPUSH
115052: LD_VAR 0 2
115056: PPUSH
115057: LD_VAR 0 3
115061: PPUSH
115062: LD_INT 1
115064: PPUSH
115065: LD_INT 1
115067: PPUSH
115068: CALL_OW 483
// CenterOnXY ( x , y ) ;
115072: LD_VAR 0 2
115076: PPUSH
115077: LD_VAR 0 3
115081: PPUSH
115082: CALL_OW 84
// end ; end_of_file
115086: LD_VAR 0 4
115090: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
115091: LD_INT 0
115093: PPUSH
115094: PPUSH
115095: PPUSH
115096: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
115097: LD_VAR 0 1
115101: PPUSH
115102: CALL_OW 264
115106: PUSH
115107: LD_EXP 99
115111: EQUAL
115112: IFFALSE 115184
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115114: LD_INT 68
115116: PPUSH
115117: LD_VAR 0 1
115121: PPUSH
115122: CALL_OW 255
115126: PPUSH
115127: CALL_OW 321
115131: PUSH
115132: LD_INT 2
115134: EQUAL
115135: IFFALSE 115147
// eff := 70 else
115137: LD_ADDR_VAR 0 4
115141: PUSH
115142: LD_INT 70
115144: ST_TO_ADDR
115145: GO 115155
// eff := 30 ;
115147: LD_ADDR_VAR 0 4
115151: PUSH
115152: LD_INT 30
115154: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115155: LD_VAR 0 1
115159: PPUSH
115160: CALL_OW 250
115164: PPUSH
115165: LD_VAR 0 1
115169: PPUSH
115170: CALL_OW 251
115174: PPUSH
115175: LD_VAR 0 4
115179: PPUSH
115180: CALL_OW 495
// end ; end ;
115184: LD_VAR 0 2
115188: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
115189: LD_INT 0
115191: PPUSH
// end ;
115192: LD_VAR 0 4
115196: RET
// export function SOS_Command ( cmd ) ; begin
115197: LD_INT 0
115199: PPUSH
// end ;
115200: LD_VAR 0 2
115204: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
115205: LD_INT 0
115207: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
115208: LD_VAR 0 1
115212: PUSH
115213: LD_INT 250
115215: EQUAL
115216: PUSH
115217: LD_VAR 0 2
115221: PPUSH
115222: CALL_OW 264
115226: PUSH
115227: LD_EXP 102
115231: EQUAL
115232: AND
115233: IFFALSE 115254
// MinerPlaceMine ( unit , x , y ) ;
115235: LD_VAR 0 2
115239: PPUSH
115240: LD_VAR 0 4
115244: PPUSH
115245: LD_VAR 0 5
115249: PPUSH
115250: CALL 117595 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
115254: LD_VAR 0 1
115258: PUSH
115259: LD_INT 251
115261: EQUAL
115262: PUSH
115263: LD_VAR 0 2
115267: PPUSH
115268: CALL_OW 264
115272: PUSH
115273: LD_EXP 102
115277: EQUAL
115278: AND
115279: IFFALSE 115300
// MinerDetonateMine ( unit , x , y ) ;
115281: LD_VAR 0 2
115285: PPUSH
115286: LD_VAR 0 4
115290: PPUSH
115291: LD_VAR 0 5
115295: PPUSH
115296: CALL 117872 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
115300: LD_VAR 0 1
115304: PUSH
115305: LD_INT 252
115307: EQUAL
115308: PUSH
115309: LD_VAR 0 2
115313: PPUSH
115314: CALL_OW 264
115318: PUSH
115319: LD_EXP 102
115323: EQUAL
115324: AND
115325: IFFALSE 115346
// MinerCreateMinefield ( unit , x , y ) ;
115327: LD_VAR 0 2
115331: PPUSH
115332: LD_VAR 0 4
115336: PPUSH
115337: LD_VAR 0 5
115341: PPUSH
115342: CALL 118289 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
115346: LD_VAR 0 1
115350: PUSH
115351: LD_INT 253
115353: EQUAL
115354: PUSH
115355: LD_VAR 0 2
115359: PPUSH
115360: CALL_OW 257
115364: PUSH
115365: LD_INT 5
115367: EQUAL
115368: AND
115369: IFFALSE 115390
// ComBinocular ( unit , x , y ) ;
115371: LD_VAR 0 2
115375: PPUSH
115376: LD_VAR 0 4
115380: PPUSH
115381: LD_VAR 0 5
115385: PPUSH
115386: CALL 118660 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
115390: LD_VAR 0 1
115394: PUSH
115395: LD_INT 254
115397: EQUAL
115398: PUSH
115399: LD_VAR 0 2
115403: PPUSH
115404: CALL_OW 264
115408: PUSH
115409: LD_EXP 97
115413: EQUAL
115414: AND
115415: PUSH
115416: LD_VAR 0 3
115420: PPUSH
115421: CALL_OW 263
115425: PUSH
115426: LD_INT 3
115428: EQUAL
115429: AND
115430: IFFALSE 115446
// HackDestroyVehicle ( unit , selectedUnit ) ;
115432: LD_VAR 0 2
115436: PPUSH
115437: LD_VAR 0 3
115441: PPUSH
115442: CALL 116955 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115446: LD_VAR 0 1
115450: PUSH
115451: LD_INT 255
115453: EQUAL
115454: PUSH
115455: LD_VAR 0 2
115459: PPUSH
115460: CALL_OW 264
115464: PUSH
115465: LD_INT 14
115467: PUSH
115468: LD_INT 53
115470: PUSH
115471: EMPTY
115472: LIST
115473: LIST
115474: IN
115475: AND
115476: PUSH
115477: LD_VAR 0 4
115481: PPUSH
115482: LD_VAR 0 5
115486: PPUSH
115487: CALL_OW 488
115491: AND
115492: IFFALSE 115516
// CutTreeXYR ( unit , x , y , 12 ) ;
115494: LD_VAR 0 2
115498: PPUSH
115499: LD_VAR 0 4
115503: PPUSH
115504: LD_VAR 0 5
115508: PPUSH
115509: LD_INT 12
115511: PPUSH
115512: CALL 115521 0 4
// end ;
115516: LD_VAR 0 6
115520: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
115521: LD_INT 0
115523: PPUSH
115524: PPUSH
115525: PPUSH
115526: PPUSH
115527: PPUSH
115528: PPUSH
115529: PPUSH
115530: PPUSH
115531: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
115532: LD_VAR 0 1
115536: NOT
115537: PUSH
115538: LD_VAR 0 2
115542: PPUSH
115543: LD_VAR 0 3
115547: PPUSH
115548: CALL_OW 488
115552: NOT
115553: OR
115554: PUSH
115555: LD_VAR 0 4
115559: NOT
115560: OR
115561: IFFALSE 115565
// exit ;
115563: GO 115905
// list := [ ] ;
115565: LD_ADDR_VAR 0 13
115569: PUSH
115570: EMPTY
115571: ST_TO_ADDR
// if x - r < 0 then
115572: LD_VAR 0 2
115576: PUSH
115577: LD_VAR 0 4
115581: MINUS
115582: PUSH
115583: LD_INT 0
115585: LESS
115586: IFFALSE 115598
// min_x := 0 else
115588: LD_ADDR_VAR 0 7
115592: PUSH
115593: LD_INT 0
115595: ST_TO_ADDR
115596: GO 115614
// min_x := x - r ;
115598: LD_ADDR_VAR 0 7
115602: PUSH
115603: LD_VAR 0 2
115607: PUSH
115608: LD_VAR 0 4
115612: MINUS
115613: ST_TO_ADDR
// if y - r < 0 then
115614: LD_VAR 0 3
115618: PUSH
115619: LD_VAR 0 4
115623: MINUS
115624: PUSH
115625: LD_INT 0
115627: LESS
115628: IFFALSE 115640
// min_y := 0 else
115630: LD_ADDR_VAR 0 8
115634: PUSH
115635: LD_INT 0
115637: ST_TO_ADDR
115638: GO 115656
// min_y := y - r ;
115640: LD_ADDR_VAR 0 8
115644: PUSH
115645: LD_VAR 0 3
115649: PUSH
115650: LD_VAR 0 4
115654: MINUS
115655: ST_TO_ADDR
// max_x := x + r ;
115656: LD_ADDR_VAR 0 9
115660: PUSH
115661: LD_VAR 0 2
115665: PUSH
115666: LD_VAR 0 4
115670: PLUS
115671: ST_TO_ADDR
// max_y := y + r ;
115672: LD_ADDR_VAR 0 10
115676: PUSH
115677: LD_VAR 0 3
115681: PUSH
115682: LD_VAR 0 4
115686: PLUS
115687: ST_TO_ADDR
// for _x = min_x to max_x do
115688: LD_ADDR_VAR 0 11
115692: PUSH
115693: DOUBLE
115694: LD_VAR 0 7
115698: DEC
115699: ST_TO_ADDR
115700: LD_VAR 0 9
115704: PUSH
115705: FOR_TO
115706: IFFALSE 115823
// for _y = min_y to max_y do
115708: LD_ADDR_VAR 0 12
115712: PUSH
115713: DOUBLE
115714: LD_VAR 0 8
115718: DEC
115719: ST_TO_ADDR
115720: LD_VAR 0 10
115724: PUSH
115725: FOR_TO
115726: IFFALSE 115819
// begin if not ValidHex ( _x , _y ) then
115728: LD_VAR 0 11
115732: PPUSH
115733: LD_VAR 0 12
115737: PPUSH
115738: CALL_OW 488
115742: NOT
115743: IFFALSE 115747
// continue ;
115745: GO 115725
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
115747: LD_VAR 0 11
115751: PPUSH
115752: LD_VAR 0 12
115756: PPUSH
115757: CALL_OW 351
115761: PUSH
115762: LD_VAR 0 11
115766: PPUSH
115767: LD_VAR 0 12
115771: PPUSH
115772: CALL_OW 554
115776: AND
115777: IFFALSE 115817
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
115779: LD_ADDR_VAR 0 13
115783: PUSH
115784: LD_VAR 0 13
115788: PPUSH
115789: LD_VAR 0 13
115793: PUSH
115794: LD_INT 1
115796: PLUS
115797: PPUSH
115798: LD_VAR 0 11
115802: PUSH
115803: LD_VAR 0 12
115807: PUSH
115808: EMPTY
115809: LIST
115810: LIST
115811: PPUSH
115812: CALL_OW 2
115816: ST_TO_ADDR
// end ;
115817: GO 115725
115819: POP
115820: POP
115821: GO 115705
115823: POP
115824: POP
// if not list then
115825: LD_VAR 0 13
115829: NOT
115830: IFFALSE 115834
// exit ;
115832: GO 115905
// for i in list do
115834: LD_ADDR_VAR 0 6
115838: PUSH
115839: LD_VAR 0 13
115843: PUSH
115844: FOR_IN
115845: IFFALSE 115903
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
115847: LD_VAR 0 1
115851: PPUSH
115852: LD_STRING M
115854: PUSH
115855: LD_VAR 0 6
115859: PUSH
115860: LD_INT 1
115862: ARRAY
115863: PUSH
115864: LD_VAR 0 6
115868: PUSH
115869: LD_INT 2
115871: ARRAY
115872: PUSH
115873: LD_INT 0
115875: PUSH
115876: LD_INT 0
115878: PUSH
115879: LD_INT 0
115881: PUSH
115882: LD_INT 0
115884: PUSH
115885: EMPTY
115886: LIST
115887: LIST
115888: LIST
115889: LIST
115890: LIST
115891: LIST
115892: LIST
115893: PUSH
115894: EMPTY
115895: LIST
115896: PPUSH
115897: CALL_OW 447
115901: GO 115844
115903: POP
115904: POP
// end ;
115905: LD_VAR 0 5
115909: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
115910: LD_EXP 211
115914: NOT
115915: IFFALSE 115965
115917: GO 115919
115919: DISABLE
// begin initHack := true ;
115920: LD_ADDR_EXP 211
115924: PUSH
115925: LD_INT 1
115927: ST_TO_ADDR
// hackTanks := [ ] ;
115928: LD_ADDR_EXP 212
115932: PUSH
115933: EMPTY
115934: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
115935: LD_ADDR_EXP 213
115939: PUSH
115940: EMPTY
115941: ST_TO_ADDR
// hackLimit := 3 ;
115942: LD_ADDR_EXP 214
115946: PUSH
115947: LD_INT 3
115949: ST_TO_ADDR
// hackDist := 12 ;
115950: LD_ADDR_EXP 215
115954: PUSH
115955: LD_INT 12
115957: ST_TO_ADDR
// hackCounter := [ ] ;
115958: LD_ADDR_EXP 216
115962: PUSH
115963: EMPTY
115964: ST_TO_ADDR
// end ;
115965: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
115966: LD_EXP 211
115970: PUSH
115971: LD_INT 34
115973: PUSH
115974: LD_EXP 97
115978: PUSH
115979: EMPTY
115980: LIST
115981: LIST
115982: PPUSH
115983: CALL_OW 69
115987: AND
115988: IFFALSE 116243
115990: GO 115992
115992: DISABLE
115993: LD_INT 0
115995: PPUSH
115996: PPUSH
// begin enable ;
115997: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
115998: LD_ADDR_VAR 0 1
116002: PUSH
116003: LD_INT 34
116005: PUSH
116006: LD_EXP 97
116010: PUSH
116011: EMPTY
116012: LIST
116013: LIST
116014: PPUSH
116015: CALL_OW 69
116019: PUSH
116020: FOR_IN
116021: IFFALSE 116241
// begin if not i in hackTanks then
116023: LD_VAR 0 1
116027: PUSH
116028: LD_EXP 212
116032: IN
116033: NOT
116034: IFFALSE 116117
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116036: LD_ADDR_EXP 212
116040: PUSH
116041: LD_EXP 212
116045: PPUSH
116046: LD_EXP 212
116050: PUSH
116051: LD_INT 1
116053: PLUS
116054: PPUSH
116055: LD_VAR 0 1
116059: PPUSH
116060: CALL_OW 1
116064: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116065: LD_ADDR_EXP 213
116069: PUSH
116070: LD_EXP 213
116074: PPUSH
116075: LD_EXP 213
116079: PUSH
116080: LD_INT 1
116082: PLUS
116083: PPUSH
116084: EMPTY
116085: PPUSH
116086: CALL_OW 1
116090: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116091: LD_ADDR_EXP 216
116095: PUSH
116096: LD_EXP 216
116100: PPUSH
116101: LD_EXP 216
116105: PUSH
116106: LD_INT 1
116108: PLUS
116109: PPUSH
116110: EMPTY
116111: PPUSH
116112: CALL_OW 1
116116: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116117: LD_VAR 0 1
116121: PPUSH
116122: CALL_OW 302
116126: NOT
116127: IFFALSE 116140
// begin HackUnlinkAll ( i ) ;
116129: LD_VAR 0 1
116133: PPUSH
116134: CALL 116246 0 1
// continue ;
116138: GO 116020
// end ; HackCheckCapturedStatus ( i ) ;
116140: LD_VAR 0 1
116144: PPUSH
116145: CALL 116689 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116149: LD_ADDR_VAR 0 2
116153: PUSH
116154: LD_INT 81
116156: PUSH
116157: LD_VAR 0 1
116161: PPUSH
116162: CALL_OW 255
116166: PUSH
116167: EMPTY
116168: LIST
116169: LIST
116170: PUSH
116171: LD_INT 33
116173: PUSH
116174: LD_INT 3
116176: PUSH
116177: EMPTY
116178: LIST
116179: LIST
116180: PUSH
116181: LD_INT 91
116183: PUSH
116184: LD_VAR 0 1
116188: PUSH
116189: LD_EXP 215
116193: PUSH
116194: EMPTY
116195: LIST
116196: LIST
116197: LIST
116198: PUSH
116199: LD_INT 50
116201: PUSH
116202: EMPTY
116203: LIST
116204: PUSH
116205: EMPTY
116206: LIST
116207: LIST
116208: LIST
116209: LIST
116210: PPUSH
116211: CALL_OW 69
116215: ST_TO_ADDR
// if not tmp then
116216: LD_VAR 0 2
116220: NOT
116221: IFFALSE 116225
// continue ;
116223: GO 116020
// HackLink ( i , tmp ) ;
116225: LD_VAR 0 1
116229: PPUSH
116230: LD_VAR 0 2
116234: PPUSH
116235: CALL 116382 0 2
// end ;
116239: GO 116020
116241: POP
116242: POP
// end ;
116243: PPOPN 2
116245: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116246: LD_INT 0
116248: PPUSH
116249: PPUSH
116250: PPUSH
// if not hack in hackTanks then
116251: LD_VAR 0 1
116255: PUSH
116256: LD_EXP 212
116260: IN
116261: NOT
116262: IFFALSE 116266
// exit ;
116264: GO 116377
// index := GetElementIndex ( hackTanks , hack ) ;
116266: LD_ADDR_VAR 0 4
116270: PUSH
116271: LD_EXP 212
116275: PPUSH
116276: LD_VAR 0 1
116280: PPUSH
116281: CALL 69843 0 2
116285: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116286: LD_EXP 213
116290: PUSH
116291: LD_VAR 0 4
116295: ARRAY
116296: IFFALSE 116377
// begin for i in hackTanksCaptured [ index ] do
116298: LD_ADDR_VAR 0 3
116302: PUSH
116303: LD_EXP 213
116307: PUSH
116308: LD_VAR 0 4
116312: ARRAY
116313: PUSH
116314: FOR_IN
116315: IFFALSE 116341
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116317: LD_VAR 0 3
116321: PUSH
116322: LD_INT 1
116324: ARRAY
116325: PPUSH
116326: LD_VAR 0 3
116330: PUSH
116331: LD_INT 2
116333: ARRAY
116334: PPUSH
116335: CALL_OW 235
116339: GO 116314
116341: POP
116342: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116343: LD_ADDR_EXP 213
116347: PUSH
116348: LD_EXP 213
116352: PPUSH
116353: LD_VAR 0 4
116357: PPUSH
116358: EMPTY
116359: PPUSH
116360: CALL_OW 1
116364: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116365: LD_VAR 0 1
116369: PPUSH
116370: LD_INT 0
116372: PPUSH
116373: CALL_OW 505
// end ; end ;
116377: LD_VAR 0 2
116381: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116382: LD_INT 0
116384: PPUSH
116385: PPUSH
116386: PPUSH
// if not hack in hackTanks or not vehicles then
116387: LD_VAR 0 1
116391: PUSH
116392: LD_EXP 212
116396: IN
116397: NOT
116398: PUSH
116399: LD_VAR 0 2
116403: NOT
116404: OR
116405: IFFALSE 116409
// exit ;
116407: GO 116684
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116409: LD_ADDR_VAR 0 2
116413: PUSH
116414: LD_VAR 0 1
116418: PPUSH
116419: LD_VAR 0 2
116423: PPUSH
116424: LD_INT 1
116426: PPUSH
116427: LD_INT 1
116429: PPUSH
116430: CALL 70493 0 4
116434: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116435: LD_ADDR_VAR 0 5
116439: PUSH
116440: LD_EXP 212
116444: PPUSH
116445: LD_VAR 0 1
116449: PPUSH
116450: CALL 69843 0 2
116454: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116455: LD_EXP 213
116459: PUSH
116460: LD_VAR 0 5
116464: ARRAY
116465: PUSH
116466: LD_EXP 214
116470: LESS
116471: IFFALSE 116660
// begin for i := 1 to vehicles do
116473: LD_ADDR_VAR 0 4
116477: PUSH
116478: DOUBLE
116479: LD_INT 1
116481: DEC
116482: ST_TO_ADDR
116483: LD_VAR 0 2
116487: PUSH
116488: FOR_TO
116489: IFFALSE 116658
// begin if hackTanksCaptured [ index ] = hackLimit then
116491: LD_EXP 213
116495: PUSH
116496: LD_VAR 0 5
116500: ARRAY
116501: PUSH
116502: LD_EXP 214
116506: EQUAL
116507: IFFALSE 116511
// break ;
116509: GO 116658
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
116511: LD_ADDR_EXP 216
116515: PUSH
116516: LD_EXP 216
116520: PPUSH
116521: LD_VAR 0 5
116525: PPUSH
116526: LD_EXP 216
116530: PUSH
116531: LD_VAR 0 5
116535: ARRAY
116536: PUSH
116537: LD_INT 1
116539: PLUS
116540: PPUSH
116541: CALL_OW 1
116545: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
116546: LD_ADDR_EXP 213
116550: PUSH
116551: LD_EXP 213
116555: PPUSH
116556: LD_VAR 0 5
116560: PUSH
116561: LD_EXP 213
116565: PUSH
116566: LD_VAR 0 5
116570: ARRAY
116571: PUSH
116572: LD_INT 1
116574: PLUS
116575: PUSH
116576: EMPTY
116577: LIST
116578: LIST
116579: PPUSH
116580: LD_VAR 0 2
116584: PUSH
116585: LD_VAR 0 4
116589: ARRAY
116590: PUSH
116591: LD_VAR 0 2
116595: PUSH
116596: LD_VAR 0 4
116600: ARRAY
116601: PPUSH
116602: CALL_OW 255
116606: PUSH
116607: EMPTY
116608: LIST
116609: LIST
116610: PPUSH
116611: CALL 70058 0 3
116615: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
116616: LD_VAR 0 2
116620: PUSH
116621: LD_VAR 0 4
116625: ARRAY
116626: PPUSH
116627: LD_VAR 0 1
116631: PPUSH
116632: CALL_OW 255
116636: PPUSH
116637: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
116641: LD_VAR 0 2
116645: PUSH
116646: LD_VAR 0 4
116650: ARRAY
116651: PPUSH
116652: CALL_OW 141
// end ;
116656: GO 116488
116658: POP
116659: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
116660: LD_VAR 0 1
116664: PPUSH
116665: LD_EXP 213
116669: PUSH
116670: LD_VAR 0 5
116674: ARRAY
116675: PUSH
116676: LD_INT 0
116678: PLUS
116679: PPUSH
116680: CALL_OW 505
// end ;
116684: LD_VAR 0 3
116688: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
116689: LD_INT 0
116691: PPUSH
116692: PPUSH
116693: PPUSH
116694: PPUSH
// if not hack in hackTanks then
116695: LD_VAR 0 1
116699: PUSH
116700: LD_EXP 212
116704: IN
116705: NOT
116706: IFFALSE 116710
// exit ;
116708: GO 116950
// index := GetElementIndex ( hackTanks , hack ) ;
116710: LD_ADDR_VAR 0 4
116714: PUSH
116715: LD_EXP 212
116719: PPUSH
116720: LD_VAR 0 1
116724: PPUSH
116725: CALL 69843 0 2
116729: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
116730: LD_ADDR_VAR 0 3
116734: PUSH
116735: DOUBLE
116736: LD_EXP 213
116740: PUSH
116741: LD_VAR 0 4
116745: ARRAY
116746: INC
116747: ST_TO_ADDR
116748: LD_INT 1
116750: PUSH
116751: FOR_DOWNTO
116752: IFFALSE 116924
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
116754: LD_ADDR_VAR 0 5
116758: PUSH
116759: LD_EXP 213
116763: PUSH
116764: LD_VAR 0 4
116768: ARRAY
116769: PUSH
116770: LD_VAR 0 3
116774: ARRAY
116775: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
116776: LD_VAR 0 5
116780: PUSH
116781: LD_INT 1
116783: ARRAY
116784: PPUSH
116785: CALL_OW 302
116789: NOT
116790: PUSH
116791: LD_VAR 0 5
116795: PUSH
116796: LD_INT 1
116798: ARRAY
116799: PPUSH
116800: CALL_OW 255
116804: PUSH
116805: LD_VAR 0 1
116809: PPUSH
116810: CALL_OW 255
116814: NONEQUAL
116815: OR
116816: IFFALSE 116922
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
116818: LD_VAR 0 5
116822: PUSH
116823: LD_INT 1
116825: ARRAY
116826: PPUSH
116827: CALL_OW 305
116831: PUSH
116832: LD_VAR 0 5
116836: PUSH
116837: LD_INT 1
116839: ARRAY
116840: PPUSH
116841: CALL_OW 255
116845: PUSH
116846: LD_VAR 0 1
116850: PPUSH
116851: CALL_OW 255
116855: EQUAL
116856: AND
116857: IFFALSE 116881
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
116859: LD_VAR 0 5
116863: PUSH
116864: LD_INT 1
116866: ARRAY
116867: PPUSH
116868: LD_VAR 0 5
116872: PUSH
116873: LD_INT 2
116875: ARRAY
116876: PPUSH
116877: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
116881: LD_ADDR_EXP 213
116885: PUSH
116886: LD_EXP 213
116890: PPUSH
116891: LD_VAR 0 4
116895: PPUSH
116896: LD_EXP 213
116900: PUSH
116901: LD_VAR 0 4
116905: ARRAY
116906: PPUSH
116907: LD_VAR 0 3
116911: PPUSH
116912: CALL_OW 3
116916: PPUSH
116917: CALL_OW 1
116921: ST_TO_ADDR
// end ; end ;
116922: GO 116751
116924: POP
116925: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
116926: LD_VAR 0 1
116930: PPUSH
116931: LD_EXP 213
116935: PUSH
116936: LD_VAR 0 4
116940: ARRAY
116941: PUSH
116942: LD_INT 0
116944: PLUS
116945: PPUSH
116946: CALL_OW 505
// end ;
116950: LD_VAR 0 2
116954: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
116955: LD_INT 0
116957: PPUSH
116958: PPUSH
116959: PPUSH
116960: PPUSH
// if not hack in hackTanks then
116961: LD_VAR 0 1
116965: PUSH
116966: LD_EXP 212
116970: IN
116971: NOT
116972: IFFALSE 116976
// exit ;
116974: GO 117061
// index := GetElementIndex ( hackTanks , hack ) ;
116976: LD_ADDR_VAR 0 5
116980: PUSH
116981: LD_EXP 212
116985: PPUSH
116986: LD_VAR 0 1
116990: PPUSH
116991: CALL 69843 0 2
116995: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
116996: LD_ADDR_VAR 0 4
117000: PUSH
117001: DOUBLE
117002: LD_INT 1
117004: DEC
117005: ST_TO_ADDR
117006: LD_EXP 213
117010: PUSH
117011: LD_VAR 0 5
117015: ARRAY
117016: PUSH
117017: FOR_TO
117018: IFFALSE 117059
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117020: LD_EXP 213
117024: PUSH
117025: LD_VAR 0 5
117029: ARRAY
117030: PUSH
117031: LD_VAR 0 4
117035: ARRAY
117036: PUSH
117037: LD_INT 1
117039: ARRAY
117040: PUSH
117041: LD_VAR 0 2
117045: EQUAL
117046: IFFALSE 117057
// KillUnit ( vehicle ) ;
117048: LD_VAR 0 2
117052: PPUSH
117053: CALL_OW 66
117057: GO 117017
117059: POP
117060: POP
// end ;
117061: LD_VAR 0 3
117065: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
117066: LD_EXP 217
117070: NOT
117071: IFFALSE 117106
117073: GO 117075
117075: DISABLE
// begin initMiner := true ;
117076: LD_ADDR_EXP 217
117080: PUSH
117081: LD_INT 1
117083: ST_TO_ADDR
// minersList := [ ] ;
117084: LD_ADDR_EXP 218
117088: PUSH
117089: EMPTY
117090: ST_TO_ADDR
// minerMinesList := [ ] ;
117091: LD_ADDR_EXP 219
117095: PUSH
117096: EMPTY
117097: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
117098: LD_ADDR_EXP 220
117102: PUSH
117103: LD_INT 5
117105: ST_TO_ADDR
// end ;
117106: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
117107: LD_EXP 217
117111: PUSH
117112: LD_INT 34
117114: PUSH
117115: LD_EXP 102
117119: PUSH
117120: EMPTY
117121: LIST
117122: LIST
117123: PPUSH
117124: CALL_OW 69
117128: AND
117129: IFFALSE 117592
117131: GO 117133
117133: DISABLE
117134: LD_INT 0
117136: PPUSH
117137: PPUSH
117138: PPUSH
117139: PPUSH
// begin enable ;
117140: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117141: LD_ADDR_VAR 0 1
117145: PUSH
117146: LD_INT 34
117148: PUSH
117149: LD_EXP 102
117153: PUSH
117154: EMPTY
117155: LIST
117156: LIST
117157: PPUSH
117158: CALL_OW 69
117162: PUSH
117163: FOR_IN
117164: IFFALSE 117236
// begin if not i in minersList then
117166: LD_VAR 0 1
117170: PUSH
117171: LD_EXP 218
117175: IN
117176: NOT
117177: IFFALSE 117234
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117179: LD_ADDR_EXP 218
117183: PUSH
117184: LD_EXP 218
117188: PPUSH
117189: LD_EXP 218
117193: PUSH
117194: LD_INT 1
117196: PLUS
117197: PPUSH
117198: LD_VAR 0 1
117202: PPUSH
117203: CALL_OW 1
117207: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117208: LD_ADDR_EXP 219
117212: PUSH
117213: LD_EXP 219
117217: PPUSH
117218: LD_EXP 219
117222: PUSH
117223: LD_INT 1
117225: PLUS
117226: PPUSH
117227: EMPTY
117228: PPUSH
117229: CALL_OW 1
117233: ST_TO_ADDR
// end end ;
117234: GO 117163
117236: POP
117237: POP
// for i := minerMinesList downto 1 do
117238: LD_ADDR_VAR 0 1
117242: PUSH
117243: DOUBLE
117244: LD_EXP 219
117248: INC
117249: ST_TO_ADDR
117250: LD_INT 1
117252: PUSH
117253: FOR_DOWNTO
117254: IFFALSE 117590
// begin if IsLive ( minersList [ i ] ) then
117256: LD_EXP 218
117260: PUSH
117261: LD_VAR 0 1
117265: ARRAY
117266: PPUSH
117267: CALL_OW 300
117271: IFFALSE 117299
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
117273: LD_EXP 218
117277: PUSH
117278: LD_VAR 0 1
117282: ARRAY
117283: PPUSH
117284: LD_EXP 219
117288: PUSH
117289: LD_VAR 0 1
117293: ARRAY
117294: PPUSH
117295: CALL_OW 505
// if not minerMinesList [ i ] then
117299: LD_EXP 219
117303: PUSH
117304: LD_VAR 0 1
117308: ARRAY
117309: NOT
117310: IFFALSE 117314
// continue ;
117312: GO 117253
// for j := minerMinesList [ i ] downto 1 do
117314: LD_ADDR_VAR 0 2
117318: PUSH
117319: DOUBLE
117320: LD_EXP 219
117324: PUSH
117325: LD_VAR 0 1
117329: ARRAY
117330: INC
117331: ST_TO_ADDR
117332: LD_INT 1
117334: PUSH
117335: FOR_DOWNTO
117336: IFFALSE 117586
// begin side := GetSide ( minersList [ i ] ) ;
117338: LD_ADDR_VAR 0 3
117342: PUSH
117343: LD_EXP 218
117347: PUSH
117348: LD_VAR 0 1
117352: ARRAY
117353: PPUSH
117354: CALL_OW 255
117358: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117359: LD_ADDR_VAR 0 4
117363: PUSH
117364: LD_EXP 219
117368: PUSH
117369: LD_VAR 0 1
117373: ARRAY
117374: PUSH
117375: LD_VAR 0 2
117379: ARRAY
117380: PUSH
117381: LD_INT 1
117383: ARRAY
117384: PPUSH
117385: LD_EXP 219
117389: PUSH
117390: LD_VAR 0 1
117394: ARRAY
117395: PUSH
117396: LD_VAR 0 2
117400: ARRAY
117401: PUSH
117402: LD_INT 2
117404: ARRAY
117405: PPUSH
117406: CALL_OW 428
117410: ST_TO_ADDR
// if not tmp then
117411: LD_VAR 0 4
117415: NOT
117416: IFFALSE 117420
// continue ;
117418: GO 117335
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
117420: LD_VAR 0 4
117424: PUSH
117425: LD_INT 81
117427: PUSH
117428: LD_VAR 0 3
117432: PUSH
117433: EMPTY
117434: LIST
117435: LIST
117436: PPUSH
117437: CALL_OW 69
117441: IN
117442: PUSH
117443: LD_EXP 219
117447: PUSH
117448: LD_VAR 0 1
117452: ARRAY
117453: PUSH
117454: LD_VAR 0 2
117458: ARRAY
117459: PUSH
117460: LD_INT 1
117462: ARRAY
117463: PPUSH
117464: LD_EXP 219
117468: PUSH
117469: LD_VAR 0 1
117473: ARRAY
117474: PUSH
117475: LD_VAR 0 2
117479: ARRAY
117480: PUSH
117481: LD_INT 2
117483: ARRAY
117484: PPUSH
117485: CALL_OW 458
117489: AND
117490: IFFALSE 117584
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
117492: LD_EXP 219
117496: PUSH
117497: LD_VAR 0 1
117501: ARRAY
117502: PUSH
117503: LD_VAR 0 2
117507: ARRAY
117508: PUSH
117509: LD_INT 1
117511: ARRAY
117512: PPUSH
117513: LD_EXP 219
117517: PUSH
117518: LD_VAR 0 1
117522: ARRAY
117523: PUSH
117524: LD_VAR 0 2
117528: ARRAY
117529: PUSH
117530: LD_INT 2
117532: ARRAY
117533: PPUSH
117534: LD_VAR 0 3
117538: PPUSH
117539: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
117543: LD_ADDR_EXP 219
117547: PUSH
117548: LD_EXP 219
117552: PPUSH
117553: LD_VAR 0 1
117557: PPUSH
117558: LD_EXP 219
117562: PUSH
117563: LD_VAR 0 1
117567: ARRAY
117568: PPUSH
117569: LD_VAR 0 2
117573: PPUSH
117574: CALL_OW 3
117578: PPUSH
117579: CALL_OW 1
117583: ST_TO_ADDR
// end ; end ;
117584: GO 117335
117586: POP
117587: POP
// end ;
117588: GO 117253
117590: POP
117591: POP
// end ;
117592: PPOPN 4
117594: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
117595: LD_INT 0
117597: PPUSH
117598: PPUSH
// result := false ;
117599: LD_ADDR_VAR 0 4
117603: PUSH
117604: LD_INT 0
117606: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
117607: LD_VAR 0 1
117611: PPUSH
117612: CALL_OW 264
117616: PUSH
117617: LD_EXP 102
117621: EQUAL
117622: NOT
117623: IFFALSE 117627
// exit ;
117625: GO 117867
// index := GetElementIndex ( minersList , unit ) ;
117627: LD_ADDR_VAR 0 5
117631: PUSH
117632: LD_EXP 218
117636: PPUSH
117637: LD_VAR 0 1
117641: PPUSH
117642: CALL 69843 0 2
117646: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
117647: LD_EXP 219
117651: PUSH
117652: LD_VAR 0 5
117656: ARRAY
117657: PUSH
117658: LD_EXP 220
117662: GREATEREQUAL
117663: IFFALSE 117667
// exit ;
117665: GO 117867
// ComMoveXY ( unit , x , y ) ;
117667: LD_VAR 0 1
117671: PPUSH
117672: LD_VAR 0 2
117676: PPUSH
117677: LD_VAR 0 3
117681: PPUSH
117682: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
117686: LD_INT 35
117688: PPUSH
117689: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
117693: LD_VAR 0 1
117697: PPUSH
117698: LD_VAR 0 2
117702: PPUSH
117703: LD_VAR 0 3
117707: PPUSH
117708: CALL 99907 0 3
117712: NOT
117713: PUSH
117714: LD_VAR 0 1
117718: PPUSH
117719: CALL_OW 314
117723: AND
117724: IFFALSE 117728
// exit ;
117726: GO 117867
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
117728: LD_VAR 0 2
117732: PPUSH
117733: LD_VAR 0 3
117737: PPUSH
117738: CALL_OW 428
117742: PUSH
117743: LD_VAR 0 1
117747: EQUAL
117748: PUSH
117749: LD_VAR 0 1
117753: PPUSH
117754: CALL_OW 314
117758: NOT
117759: AND
117760: IFFALSE 117686
// PlaySoundXY ( x , y , PlantMine ) ;
117762: LD_VAR 0 2
117766: PPUSH
117767: LD_VAR 0 3
117771: PPUSH
117772: LD_STRING PlantMine
117774: PPUSH
117775: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
117779: LD_VAR 0 2
117783: PPUSH
117784: LD_VAR 0 3
117788: PPUSH
117789: LD_VAR 0 1
117793: PPUSH
117794: CALL_OW 255
117798: PPUSH
117799: LD_INT 0
117801: PPUSH
117802: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
117806: LD_ADDR_EXP 219
117810: PUSH
117811: LD_EXP 219
117815: PPUSH
117816: LD_VAR 0 5
117820: PUSH
117821: LD_EXP 219
117825: PUSH
117826: LD_VAR 0 5
117830: ARRAY
117831: PUSH
117832: LD_INT 1
117834: PLUS
117835: PUSH
117836: EMPTY
117837: LIST
117838: LIST
117839: PPUSH
117840: LD_VAR 0 2
117844: PUSH
117845: LD_VAR 0 3
117849: PUSH
117850: EMPTY
117851: LIST
117852: LIST
117853: PPUSH
117854: CALL 70058 0 3
117858: ST_TO_ADDR
// result := true ;
117859: LD_ADDR_VAR 0 4
117863: PUSH
117864: LD_INT 1
117866: ST_TO_ADDR
// end ;
117867: LD_VAR 0 4
117871: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
117872: LD_INT 0
117874: PPUSH
117875: PPUSH
117876: PPUSH
// if not unit in minersList then
117877: LD_VAR 0 1
117881: PUSH
117882: LD_EXP 218
117886: IN
117887: NOT
117888: IFFALSE 117892
// exit ;
117890: GO 118284
// index := GetElementIndex ( minersList , unit ) ;
117892: LD_ADDR_VAR 0 6
117896: PUSH
117897: LD_EXP 218
117901: PPUSH
117902: LD_VAR 0 1
117906: PPUSH
117907: CALL 69843 0 2
117911: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
117912: LD_ADDR_VAR 0 5
117916: PUSH
117917: DOUBLE
117918: LD_EXP 219
117922: PUSH
117923: LD_VAR 0 6
117927: ARRAY
117928: INC
117929: ST_TO_ADDR
117930: LD_INT 1
117932: PUSH
117933: FOR_DOWNTO
117934: IFFALSE 118095
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
117936: LD_EXP 219
117940: PUSH
117941: LD_VAR 0 6
117945: ARRAY
117946: PUSH
117947: LD_VAR 0 5
117951: ARRAY
117952: PUSH
117953: LD_INT 1
117955: ARRAY
117956: PUSH
117957: LD_VAR 0 2
117961: EQUAL
117962: PUSH
117963: LD_EXP 219
117967: PUSH
117968: LD_VAR 0 6
117972: ARRAY
117973: PUSH
117974: LD_VAR 0 5
117978: ARRAY
117979: PUSH
117980: LD_INT 2
117982: ARRAY
117983: PUSH
117984: LD_VAR 0 3
117988: EQUAL
117989: AND
117990: IFFALSE 118093
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
117992: LD_EXP 219
117996: PUSH
117997: LD_VAR 0 6
118001: ARRAY
118002: PUSH
118003: LD_VAR 0 5
118007: ARRAY
118008: PUSH
118009: LD_INT 1
118011: ARRAY
118012: PPUSH
118013: LD_EXP 219
118017: PUSH
118018: LD_VAR 0 6
118022: ARRAY
118023: PUSH
118024: LD_VAR 0 5
118028: ARRAY
118029: PUSH
118030: LD_INT 2
118032: ARRAY
118033: PPUSH
118034: LD_VAR 0 1
118038: PPUSH
118039: CALL_OW 255
118043: PPUSH
118044: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118048: LD_ADDR_EXP 219
118052: PUSH
118053: LD_EXP 219
118057: PPUSH
118058: LD_VAR 0 6
118062: PPUSH
118063: LD_EXP 219
118067: PUSH
118068: LD_VAR 0 6
118072: ARRAY
118073: PPUSH
118074: LD_VAR 0 5
118078: PPUSH
118079: CALL_OW 3
118083: PPUSH
118084: CALL_OW 1
118088: ST_TO_ADDR
// exit ;
118089: POP
118090: POP
118091: GO 118284
// end ; end ;
118093: GO 117933
118095: POP
118096: POP
// for i := minerMinesList [ index ] downto 1 do
118097: LD_ADDR_VAR 0 5
118101: PUSH
118102: DOUBLE
118103: LD_EXP 219
118107: PUSH
118108: LD_VAR 0 6
118112: ARRAY
118113: INC
118114: ST_TO_ADDR
118115: LD_INT 1
118117: PUSH
118118: FOR_DOWNTO
118119: IFFALSE 118282
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118121: LD_EXP 219
118125: PUSH
118126: LD_VAR 0 6
118130: ARRAY
118131: PUSH
118132: LD_VAR 0 5
118136: ARRAY
118137: PUSH
118138: LD_INT 1
118140: ARRAY
118141: PPUSH
118142: LD_EXP 219
118146: PUSH
118147: LD_VAR 0 6
118151: ARRAY
118152: PUSH
118153: LD_VAR 0 5
118157: ARRAY
118158: PUSH
118159: LD_INT 2
118161: ARRAY
118162: PPUSH
118163: LD_VAR 0 2
118167: PPUSH
118168: LD_VAR 0 3
118172: PPUSH
118173: CALL_OW 298
118177: PUSH
118178: LD_INT 6
118180: LESS
118181: IFFALSE 118280
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118183: LD_EXP 219
118187: PUSH
118188: LD_VAR 0 6
118192: ARRAY
118193: PUSH
118194: LD_VAR 0 5
118198: ARRAY
118199: PUSH
118200: LD_INT 1
118202: ARRAY
118203: PPUSH
118204: LD_EXP 219
118208: PUSH
118209: LD_VAR 0 6
118213: ARRAY
118214: PUSH
118215: LD_VAR 0 5
118219: ARRAY
118220: PUSH
118221: LD_INT 2
118223: ARRAY
118224: PPUSH
118225: LD_VAR 0 1
118229: PPUSH
118230: CALL_OW 255
118234: PPUSH
118235: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118239: LD_ADDR_EXP 219
118243: PUSH
118244: LD_EXP 219
118248: PPUSH
118249: LD_VAR 0 6
118253: PPUSH
118254: LD_EXP 219
118258: PUSH
118259: LD_VAR 0 6
118263: ARRAY
118264: PPUSH
118265: LD_VAR 0 5
118269: PPUSH
118270: CALL_OW 3
118274: PPUSH
118275: CALL_OW 1
118279: ST_TO_ADDR
// end ; end ;
118280: GO 118118
118282: POP
118283: POP
// end ;
118284: LD_VAR 0 4
118288: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118289: LD_INT 0
118291: PPUSH
118292: PPUSH
118293: PPUSH
118294: PPUSH
118295: PPUSH
118296: PPUSH
118297: PPUSH
118298: PPUSH
118299: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118300: LD_VAR 0 1
118304: PPUSH
118305: CALL_OW 264
118309: PUSH
118310: LD_EXP 102
118314: EQUAL
118315: NOT
118316: PUSH
118317: LD_VAR 0 1
118321: PUSH
118322: LD_EXP 218
118326: IN
118327: NOT
118328: OR
118329: IFFALSE 118333
// exit ;
118331: GO 118655
// index := GetElementIndex ( minersList , unit ) ;
118333: LD_ADDR_VAR 0 6
118337: PUSH
118338: LD_EXP 218
118342: PPUSH
118343: LD_VAR 0 1
118347: PPUSH
118348: CALL 69843 0 2
118352: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118353: LD_ADDR_VAR 0 8
118357: PUSH
118358: LD_EXP 220
118362: PUSH
118363: LD_EXP 219
118367: PUSH
118368: LD_VAR 0 6
118372: ARRAY
118373: MINUS
118374: ST_TO_ADDR
// if not minesFreeAmount then
118375: LD_VAR 0 8
118379: NOT
118380: IFFALSE 118384
// exit ;
118382: GO 118655
// tmp := [ ] ;
118384: LD_ADDR_VAR 0 7
118388: PUSH
118389: EMPTY
118390: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118391: LD_ADDR_VAR 0 5
118395: PUSH
118396: DOUBLE
118397: LD_INT 1
118399: DEC
118400: ST_TO_ADDR
118401: LD_VAR 0 8
118405: PUSH
118406: FOR_TO
118407: IFFALSE 118602
// begin _d := rand ( 0 , 5 ) ;
118409: LD_ADDR_VAR 0 11
118413: PUSH
118414: LD_INT 0
118416: PPUSH
118417: LD_INT 5
118419: PPUSH
118420: CALL_OW 12
118424: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
118425: LD_ADDR_VAR 0 12
118429: PUSH
118430: LD_INT 2
118432: PPUSH
118433: LD_INT 6
118435: PPUSH
118436: CALL_OW 12
118440: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
118441: LD_ADDR_VAR 0 9
118445: PUSH
118446: LD_VAR 0 2
118450: PPUSH
118451: LD_VAR 0 11
118455: PPUSH
118456: LD_VAR 0 12
118460: PPUSH
118461: CALL_OW 272
118465: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
118466: LD_ADDR_VAR 0 10
118470: PUSH
118471: LD_VAR 0 3
118475: PPUSH
118476: LD_VAR 0 11
118480: PPUSH
118481: LD_VAR 0 12
118485: PPUSH
118486: CALL_OW 273
118490: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
118491: LD_VAR 0 9
118495: PPUSH
118496: LD_VAR 0 10
118500: PPUSH
118501: CALL_OW 488
118505: PUSH
118506: LD_VAR 0 9
118510: PUSH
118511: LD_VAR 0 10
118515: PUSH
118516: EMPTY
118517: LIST
118518: LIST
118519: PUSH
118520: LD_VAR 0 7
118524: IN
118525: NOT
118526: AND
118527: PUSH
118528: LD_VAR 0 9
118532: PPUSH
118533: LD_VAR 0 10
118537: PPUSH
118538: CALL_OW 458
118542: NOT
118543: AND
118544: IFFALSE 118586
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
118546: LD_ADDR_VAR 0 7
118550: PUSH
118551: LD_VAR 0 7
118555: PPUSH
118556: LD_VAR 0 7
118560: PUSH
118561: LD_INT 1
118563: PLUS
118564: PPUSH
118565: LD_VAR 0 9
118569: PUSH
118570: LD_VAR 0 10
118574: PUSH
118575: EMPTY
118576: LIST
118577: LIST
118578: PPUSH
118579: CALL_OW 1
118583: ST_TO_ADDR
118584: GO 118600
// i := i - 1 ;
118586: LD_ADDR_VAR 0 5
118590: PUSH
118591: LD_VAR 0 5
118595: PUSH
118596: LD_INT 1
118598: MINUS
118599: ST_TO_ADDR
// end ;
118600: GO 118406
118602: POP
118603: POP
// for i in tmp do
118604: LD_ADDR_VAR 0 5
118608: PUSH
118609: LD_VAR 0 7
118613: PUSH
118614: FOR_IN
118615: IFFALSE 118653
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
118617: LD_VAR 0 1
118621: PPUSH
118622: LD_VAR 0 5
118626: PUSH
118627: LD_INT 1
118629: ARRAY
118630: PPUSH
118631: LD_VAR 0 5
118635: PUSH
118636: LD_INT 2
118638: ARRAY
118639: PPUSH
118640: CALL 117595 0 3
118644: NOT
118645: IFFALSE 118651
// exit ;
118647: POP
118648: POP
118649: GO 118655
118651: GO 118614
118653: POP
118654: POP
// end ;
118655: LD_VAR 0 4
118659: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
118660: LD_INT 0
118662: PPUSH
118663: PPUSH
118664: PPUSH
118665: PPUSH
118666: PPUSH
118667: PPUSH
118668: PPUSH
// if not GetClass ( unit ) = class_sniper then
118669: LD_VAR 0 1
118673: PPUSH
118674: CALL_OW 257
118678: PUSH
118679: LD_INT 5
118681: EQUAL
118682: NOT
118683: IFFALSE 118687
// exit ;
118685: GO 119075
// dist := 8 ;
118687: LD_ADDR_VAR 0 5
118691: PUSH
118692: LD_INT 8
118694: ST_TO_ADDR
// viewRange := 12 ;
118695: LD_ADDR_VAR 0 7
118699: PUSH
118700: LD_INT 12
118702: ST_TO_ADDR
// side := GetSide ( unit ) ;
118703: LD_ADDR_VAR 0 6
118707: PUSH
118708: LD_VAR 0 1
118712: PPUSH
118713: CALL_OW 255
118717: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
118718: LD_INT 61
118720: PPUSH
118721: LD_VAR 0 6
118725: PPUSH
118726: CALL_OW 321
118730: PUSH
118731: LD_INT 2
118733: EQUAL
118734: IFFALSE 118744
// viewRange := 16 ;
118736: LD_ADDR_VAR 0 7
118740: PUSH
118741: LD_INT 16
118743: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
118744: LD_VAR 0 1
118748: PPUSH
118749: LD_VAR 0 2
118753: PPUSH
118754: LD_VAR 0 3
118758: PPUSH
118759: CALL_OW 297
118763: PUSH
118764: LD_VAR 0 5
118768: GREATER
118769: IFFALSE 118848
// begin ComMoveXY ( unit , x , y ) ;
118771: LD_VAR 0 1
118775: PPUSH
118776: LD_VAR 0 2
118780: PPUSH
118781: LD_VAR 0 3
118785: PPUSH
118786: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118790: LD_INT 35
118792: PPUSH
118793: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
118797: LD_VAR 0 1
118801: PPUSH
118802: LD_VAR 0 2
118806: PPUSH
118807: LD_VAR 0 3
118811: PPUSH
118812: CALL 99907 0 3
118816: NOT
118817: IFFALSE 118821
// exit ;
118819: GO 119075
// until GetDistUnitXY ( unit , x , y ) < dist ;
118821: LD_VAR 0 1
118825: PPUSH
118826: LD_VAR 0 2
118830: PPUSH
118831: LD_VAR 0 3
118835: PPUSH
118836: CALL_OW 297
118840: PUSH
118841: LD_VAR 0 5
118845: LESS
118846: IFFALSE 118790
// end ; ComTurnXY ( unit , x , y ) ;
118848: LD_VAR 0 1
118852: PPUSH
118853: LD_VAR 0 2
118857: PPUSH
118858: LD_VAR 0 3
118862: PPUSH
118863: CALL_OW 118
// wait ( 5 ) ;
118867: LD_INT 5
118869: PPUSH
118870: CALL_OW 67
// _d := GetDir ( unit ) ;
118874: LD_ADDR_VAR 0 10
118878: PUSH
118879: LD_VAR 0 1
118883: PPUSH
118884: CALL_OW 254
118888: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
118889: LD_ADDR_VAR 0 8
118893: PUSH
118894: LD_VAR 0 1
118898: PPUSH
118899: CALL_OW 250
118903: PPUSH
118904: LD_VAR 0 10
118908: PPUSH
118909: LD_VAR 0 5
118913: PPUSH
118914: CALL_OW 272
118918: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
118919: LD_ADDR_VAR 0 9
118923: PUSH
118924: LD_VAR 0 1
118928: PPUSH
118929: CALL_OW 251
118933: PPUSH
118934: LD_VAR 0 10
118938: PPUSH
118939: LD_VAR 0 5
118943: PPUSH
118944: CALL_OW 273
118948: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
118949: LD_VAR 0 8
118953: PPUSH
118954: LD_VAR 0 9
118958: PPUSH
118959: CALL_OW 488
118963: NOT
118964: IFFALSE 118968
// exit ;
118966: GO 119075
// ComAnimCustom ( unit , 1 ) ;
118968: LD_VAR 0 1
118972: PPUSH
118973: LD_INT 1
118975: PPUSH
118976: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
118980: LD_VAR 0 8
118984: PPUSH
118985: LD_VAR 0 9
118989: PPUSH
118990: LD_VAR 0 6
118994: PPUSH
118995: LD_VAR 0 7
118999: PPUSH
119000: CALL_OW 330
// repeat wait ( 1 ) ;
119004: LD_INT 1
119006: PPUSH
119007: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
119011: LD_VAR 0 1
119015: PPUSH
119016: CALL_OW 316
119020: PUSH
119021: LD_VAR 0 1
119025: PPUSH
119026: CALL_OW 314
119030: OR
119031: PUSH
119032: LD_VAR 0 1
119036: PPUSH
119037: CALL_OW 302
119041: NOT
119042: OR
119043: PUSH
119044: LD_VAR 0 1
119048: PPUSH
119049: CALL_OW 301
119053: OR
119054: IFFALSE 119004
// RemoveSeeing ( _x , _y , side ) ;
119056: LD_VAR 0 8
119060: PPUSH
119061: LD_VAR 0 9
119065: PPUSH
119066: LD_VAR 0 6
119070: PPUSH
119071: CALL_OW 331
// end ; end_of_file
119075: LD_VAR 0 4
119079: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
119080: LD_INT 0
119082: PPUSH
119083: PPUSH
119084: PPUSH
119085: PPUSH
119086: PPUSH
119087: PPUSH
119088: PPUSH
119089: PPUSH
119090: PPUSH
119091: PPUSH
119092: PPUSH
119093: PPUSH
119094: PPUSH
119095: PPUSH
119096: PPUSH
119097: PPUSH
119098: PPUSH
119099: PPUSH
119100: PPUSH
119101: PPUSH
119102: PPUSH
119103: PPUSH
119104: PPUSH
119105: PPUSH
119106: PPUSH
119107: PPUSH
119108: PPUSH
119109: PPUSH
119110: PPUSH
119111: PPUSH
119112: PPUSH
119113: PPUSH
119114: PPUSH
119115: PPUSH
// if not list then
119116: LD_VAR 0 1
119120: NOT
119121: IFFALSE 119125
// exit ;
119123: GO 123784
// base := list [ 1 ] ;
119125: LD_ADDR_VAR 0 3
119129: PUSH
119130: LD_VAR 0 1
119134: PUSH
119135: LD_INT 1
119137: ARRAY
119138: ST_TO_ADDR
// group := list [ 2 ] ;
119139: LD_ADDR_VAR 0 4
119143: PUSH
119144: LD_VAR 0 1
119148: PUSH
119149: LD_INT 2
119151: ARRAY
119152: ST_TO_ADDR
// path := list [ 3 ] ;
119153: LD_ADDR_VAR 0 5
119157: PUSH
119158: LD_VAR 0 1
119162: PUSH
119163: LD_INT 3
119165: ARRAY
119166: ST_TO_ADDR
// flags := list [ 4 ] ;
119167: LD_ADDR_VAR 0 6
119171: PUSH
119172: LD_VAR 0 1
119176: PUSH
119177: LD_INT 4
119179: ARRAY
119180: ST_TO_ADDR
// mined := [ ] ;
119181: LD_ADDR_VAR 0 27
119185: PUSH
119186: EMPTY
119187: ST_TO_ADDR
// bombed := [ ] ;
119188: LD_ADDR_VAR 0 28
119192: PUSH
119193: EMPTY
119194: ST_TO_ADDR
// healers := [ ] ;
119195: LD_ADDR_VAR 0 31
119199: PUSH
119200: EMPTY
119201: ST_TO_ADDR
// to_heal := [ ] ;
119202: LD_ADDR_VAR 0 30
119206: PUSH
119207: EMPTY
119208: ST_TO_ADDR
// repairs := [ ] ;
119209: LD_ADDR_VAR 0 33
119213: PUSH
119214: EMPTY
119215: ST_TO_ADDR
// to_repair := [ ] ;
119216: LD_ADDR_VAR 0 32
119220: PUSH
119221: EMPTY
119222: ST_TO_ADDR
// if not group or not path then
119223: LD_VAR 0 4
119227: NOT
119228: PUSH
119229: LD_VAR 0 5
119233: NOT
119234: OR
119235: IFFALSE 119239
// exit ;
119237: GO 123784
// side := GetSide ( group [ 1 ] ) ;
119239: LD_ADDR_VAR 0 35
119243: PUSH
119244: LD_VAR 0 4
119248: PUSH
119249: LD_INT 1
119251: ARRAY
119252: PPUSH
119253: CALL_OW 255
119257: ST_TO_ADDR
// if flags then
119258: LD_VAR 0 6
119262: IFFALSE 119406
// begin f_ignore_area := flags [ 1 ] ;
119264: LD_ADDR_VAR 0 17
119268: PUSH
119269: LD_VAR 0 6
119273: PUSH
119274: LD_INT 1
119276: ARRAY
119277: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
119278: LD_ADDR_VAR 0 18
119282: PUSH
119283: LD_VAR 0 6
119287: PUSH
119288: LD_INT 2
119290: ARRAY
119291: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
119292: LD_ADDR_VAR 0 19
119296: PUSH
119297: LD_VAR 0 6
119301: PUSH
119302: LD_INT 3
119304: ARRAY
119305: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
119306: LD_ADDR_VAR 0 20
119310: PUSH
119311: LD_VAR 0 6
119315: PUSH
119316: LD_INT 4
119318: ARRAY
119319: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
119320: LD_ADDR_VAR 0 21
119324: PUSH
119325: LD_VAR 0 6
119329: PUSH
119330: LD_INT 5
119332: ARRAY
119333: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
119334: LD_ADDR_VAR 0 22
119338: PUSH
119339: LD_VAR 0 6
119343: PUSH
119344: LD_INT 6
119346: ARRAY
119347: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
119348: LD_ADDR_VAR 0 23
119352: PUSH
119353: LD_VAR 0 6
119357: PUSH
119358: LD_INT 7
119360: ARRAY
119361: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
119362: LD_ADDR_VAR 0 24
119366: PUSH
119367: LD_VAR 0 6
119371: PUSH
119372: LD_INT 8
119374: ARRAY
119375: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
119376: LD_ADDR_VAR 0 25
119380: PUSH
119381: LD_VAR 0 6
119385: PUSH
119386: LD_INT 9
119388: ARRAY
119389: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
119390: LD_ADDR_VAR 0 26
119394: PUSH
119395: LD_VAR 0 6
119399: PUSH
119400: LD_INT 10
119402: ARRAY
119403: ST_TO_ADDR
// end else
119404: GO 119486
// begin f_ignore_area := false ;
119406: LD_ADDR_VAR 0 17
119410: PUSH
119411: LD_INT 0
119413: ST_TO_ADDR
// f_capture := false ;
119414: LD_ADDR_VAR 0 18
119418: PUSH
119419: LD_INT 0
119421: ST_TO_ADDR
// f_ignore_civ := false ;
119422: LD_ADDR_VAR 0 19
119426: PUSH
119427: LD_INT 0
119429: ST_TO_ADDR
// f_murder := false ;
119430: LD_ADDR_VAR 0 20
119434: PUSH
119435: LD_INT 0
119437: ST_TO_ADDR
// f_mines := false ;
119438: LD_ADDR_VAR 0 21
119442: PUSH
119443: LD_INT 0
119445: ST_TO_ADDR
// f_repair := false ;
119446: LD_ADDR_VAR 0 22
119450: PUSH
119451: LD_INT 0
119453: ST_TO_ADDR
// f_heal := false ;
119454: LD_ADDR_VAR 0 23
119458: PUSH
119459: LD_INT 0
119461: ST_TO_ADDR
// f_spacetime := false ;
119462: LD_ADDR_VAR 0 24
119466: PUSH
119467: LD_INT 0
119469: ST_TO_ADDR
// f_attack_depot := false ;
119470: LD_ADDR_VAR 0 25
119474: PUSH
119475: LD_INT 0
119477: ST_TO_ADDR
// f_crawl := false ;
119478: LD_ADDR_VAR 0 26
119482: PUSH
119483: LD_INT 0
119485: ST_TO_ADDR
// end ; if f_heal then
119486: LD_VAR 0 23
119490: IFFALSE 119517
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
119492: LD_ADDR_VAR 0 31
119496: PUSH
119497: LD_VAR 0 4
119501: PPUSH
119502: LD_INT 25
119504: PUSH
119505: LD_INT 4
119507: PUSH
119508: EMPTY
119509: LIST
119510: LIST
119511: PPUSH
119512: CALL_OW 72
119516: ST_TO_ADDR
// if f_repair then
119517: LD_VAR 0 22
119521: IFFALSE 119548
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
119523: LD_ADDR_VAR 0 33
119527: PUSH
119528: LD_VAR 0 4
119532: PPUSH
119533: LD_INT 25
119535: PUSH
119536: LD_INT 3
119538: PUSH
119539: EMPTY
119540: LIST
119541: LIST
119542: PPUSH
119543: CALL_OW 72
119547: ST_TO_ADDR
// units_path := [ ] ;
119548: LD_ADDR_VAR 0 16
119552: PUSH
119553: EMPTY
119554: ST_TO_ADDR
// for i = 1 to group do
119555: LD_ADDR_VAR 0 7
119559: PUSH
119560: DOUBLE
119561: LD_INT 1
119563: DEC
119564: ST_TO_ADDR
119565: LD_VAR 0 4
119569: PUSH
119570: FOR_TO
119571: IFFALSE 119600
// units_path := Replace ( units_path , i , path ) ;
119573: LD_ADDR_VAR 0 16
119577: PUSH
119578: LD_VAR 0 16
119582: PPUSH
119583: LD_VAR 0 7
119587: PPUSH
119588: LD_VAR 0 5
119592: PPUSH
119593: CALL_OW 1
119597: ST_TO_ADDR
119598: GO 119570
119600: POP
119601: POP
// repeat for i = group downto 1 do
119602: LD_ADDR_VAR 0 7
119606: PUSH
119607: DOUBLE
119608: LD_VAR 0 4
119612: INC
119613: ST_TO_ADDR
119614: LD_INT 1
119616: PUSH
119617: FOR_DOWNTO
119618: IFFALSE 123740
// begin wait ( 5 ) ;
119620: LD_INT 5
119622: PPUSH
119623: CALL_OW 67
// tmp := [ ] ;
119627: LD_ADDR_VAR 0 14
119631: PUSH
119632: EMPTY
119633: ST_TO_ADDR
// attacking := false ;
119634: LD_ADDR_VAR 0 29
119638: PUSH
119639: LD_INT 0
119641: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
119642: LD_VAR 0 4
119646: PUSH
119647: LD_VAR 0 7
119651: ARRAY
119652: PPUSH
119653: CALL_OW 301
119657: PUSH
119658: LD_VAR 0 4
119662: PUSH
119663: LD_VAR 0 7
119667: ARRAY
119668: NOT
119669: OR
119670: IFFALSE 119779
// begin if GetType ( group [ i ] ) = unit_human then
119672: LD_VAR 0 4
119676: PUSH
119677: LD_VAR 0 7
119681: ARRAY
119682: PPUSH
119683: CALL_OW 247
119687: PUSH
119688: LD_INT 1
119690: EQUAL
119691: IFFALSE 119737
// begin to_heal := to_heal diff group [ i ] ;
119693: LD_ADDR_VAR 0 30
119697: PUSH
119698: LD_VAR 0 30
119702: PUSH
119703: LD_VAR 0 4
119707: PUSH
119708: LD_VAR 0 7
119712: ARRAY
119713: DIFF
119714: ST_TO_ADDR
// healers := healers diff group [ i ] ;
119715: LD_ADDR_VAR 0 31
119719: PUSH
119720: LD_VAR 0 31
119724: PUSH
119725: LD_VAR 0 4
119729: PUSH
119730: LD_VAR 0 7
119734: ARRAY
119735: DIFF
119736: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
119737: LD_ADDR_VAR 0 4
119741: PUSH
119742: LD_VAR 0 4
119746: PPUSH
119747: LD_VAR 0 7
119751: PPUSH
119752: CALL_OW 3
119756: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
119757: LD_ADDR_VAR 0 16
119761: PUSH
119762: LD_VAR 0 16
119766: PPUSH
119767: LD_VAR 0 7
119771: PPUSH
119772: CALL_OW 3
119776: ST_TO_ADDR
// continue ;
119777: GO 119617
// end ; if f_repair then
119779: LD_VAR 0 22
119783: IFFALSE 120272
// begin if GetType ( group [ i ] ) = unit_vehicle then
119785: LD_VAR 0 4
119789: PUSH
119790: LD_VAR 0 7
119794: ARRAY
119795: PPUSH
119796: CALL_OW 247
119800: PUSH
119801: LD_INT 2
119803: EQUAL
119804: IFFALSE 119994
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
119806: LD_VAR 0 4
119810: PUSH
119811: LD_VAR 0 7
119815: ARRAY
119816: PPUSH
119817: CALL_OW 256
119821: PUSH
119822: LD_INT 700
119824: LESS
119825: PUSH
119826: LD_VAR 0 4
119830: PUSH
119831: LD_VAR 0 7
119835: ARRAY
119836: PUSH
119837: LD_VAR 0 32
119841: IN
119842: NOT
119843: AND
119844: IFFALSE 119868
// to_repair := to_repair union group [ i ] ;
119846: LD_ADDR_VAR 0 32
119850: PUSH
119851: LD_VAR 0 32
119855: PUSH
119856: LD_VAR 0 4
119860: PUSH
119861: LD_VAR 0 7
119865: ARRAY
119866: UNION
119867: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
119868: LD_VAR 0 4
119872: PUSH
119873: LD_VAR 0 7
119877: ARRAY
119878: PPUSH
119879: CALL_OW 256
119883: PUSH
119884: LD_INT 1000
119886: EQUAL
119887: PUSH
119888: LD_VAR 0 4
119892: PUSH
119893: LD_VAR 0 7
119897: ARRAY
119898: PUSH
119899: LD_VAR 0 32
119903: IN
119904: AND
119905: IFFALSE 119929
// to_repair := to_repair diff group [ i ] ;
119907: LD_ADDR_VAR 0 32
119911: PUSH
119912: LD_VAR 0 32
119916: PUSH
119917: LD_VAR 0 4
119921: PUSH
119922: LD_VAR 0 7
119926: ARRAY
119927: DIFF
119928: ST_TO_ADDR
// if group [ i ] in to_repair then
119929: LD_VAR 0 4
119933: PUSH
119934: LD_VAR 0 7
119938: ARRAY
119939: PUSH
119940: LD_VAR 0 32
119944: IN
119945: IFFALSE 119992
// begin if not IsInArea ( group [ i ] , f_repair ) then
119947: LD_VAR 0 4
119951: PUSH
119952: LD_VAR 0 7
119956: ARRAY
119957: PPUSH
119958: LD_VAR 0 22
119962: PPUSH
119963: CALL_OW 308
119967: NOT
119968: IFFALSE 119990
// ComMoveToArea ( group [ i ] , f_repair ) ;
119970: LD_VAR 0 4
119974: PUSH
119975: LD_VAR 0 7
119979: ARRAY
119980: PPUSH
119981: LD_VAR 0 22
119985: PPUSH
119986: CALL_OW 113
// continue ;
119990: GO 119617
// end ; end else
119992: GO 120272
// if group [ i ] in repairs then
119994: LD_VAR 0 4
119998: PUSH
119999: LD_VAR 0 7
120003: ARRAY
120004: PUSH
120005: LD_VAR 0 33
120009: IN
120010: IFFALSE 120272
// begin if IsInUnit ( group [ i ] ) then
120012: LD_VAR 0 4
120016: PUSH
120017: LD_VAR 0 7
120021: ARRAY
120022: PPUSH
120023: CALL_OW 310
120027: IFFALSE 120095
// begin z := IsInUnit ( group [ i ] ) ;
120029: LD_ADDR_VAR 0 13
120033: PUSH
120034: LD_VAR 0 4
120038: PUSH
120039: LD_VAR 0 7
120043: ARRAY
120044: PPUSH
120045: CALL_OW 310
120049: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
120050: LD_VAR 0 13
120054: PUSH
120055: LD_VAR 0 32
120059: IN
120060: PUSH
120061: LD_VAR 0 13
120065: PPUSH
120066: LD_VAR 0 22
120070: PPUSH
120071: CALL_OW 308
120075: AND
120076: IFFALSE 120093
// ComExitVehicle ( group [ i ] ) ;
120078: LD_VAR 0 4
120082: PUSH
120083: LD_VAR 0 7
120087: ARRAY
120088: PPUSH
120089: CALL_OW 121
// end else
120093: GO 120272
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
120095: LD_ADDR_VAR 0 13
120099: PUSH
120100: LD_VAR 0 4
120104: PPUSH
120105: LD_INT 95
120107: PUSH
120108: LD_VAR 0 22
120112: PUSH
120113: EMPTY
120114: LIST
120115: LIST
120116: PUSH
120117: LD_INT 58
120119: PUSH
120120: EMPTY
120121: LIST
120122: PUSH
120123: EMPTY
120124: LIST
120125: LIST
120126: PPUSH
120127: CALL_OW 72
120131: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
120132: LD_VAR 0 4
120136: PUSH
120137: LD_VAR 0 7
120141: ARRAY
120142: PPUSH
120143: CALL_OW 314
120147: NOT
120148: IFFALSE 120270
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
120150: LD_ADDR_VAR 0 10
120154: PUSH
120155: LD_VAR 0 13
120159: PPUSH
120160: LD_VAR 0 4
120164: PUSH
120165: LD_VAR 0 7
120169: ARRAY
120170: PPUSH
120171: CALL_OW 74
120175: ST_TO_ADDR
// if not x then
120176: LD_VAR 0 10
120180: NOT
120181: IFFALSE 120185
// continue ;
120183: GO 119617
// if GetLives ( x ) < 1000 then
120185: LD_VAR 0 10
120189: PPUSH
120190: CALL_OW 256
120194: PUSH
120195: LD_INT 1000
120197: LESS
120198: IFFALSE 120222
// ComRepairVehicle ( group [ i ] , x ) else
120200: LD_VAR 0 4
120204: PUSH
120205: LD_VAR 0 7
120209: ARRAY
120210: PPUSH
120211: LD_VAR 0 10
120215: PPUSH
120216: CALL_OW 129
120220: GO 120270
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
120222: LD_VAR 0 23
120226: PUSH
120227: LD_VAR 0 4
120231: PUSH
120232: LD_VAR 0 7
120236: ARRAY
120237: PPUSH
120238: CALL_OW 256
120242: PUSH
120243: LD_INT 1000
120245: LESS
120246: AND
120247: NOT
120248: IFFALSE 120270
// ComEnterUnit ( group [ i ] , x ) ;
120250: LD_VAR 0 4
120254: PUSH
120255: LD_VAR 0 7
120259: ARRAY
120260: PPUSH
120261: LD_VAR 0 10
120265: PPUSH
120266: CALL_OW 120
// end ; continue ;
120270: GO 119617
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
120272: LD_VAR 0 23
120276: PUSH
120277: LD_VAR 0 4
120281: PUSH
120282: LD_VAR 0 7
120286: ARRAY
120287: PPUSH
120288: CALL_OW 247
120292: PUSH
120293: LD_INT 1
120295: EQUAL
120296: AND
120297: IFFALSE 120775
// begin if group [ i ] in healers then
120299: LD_VAR 0 4
120303: PUSH
120304: LD_VAR 0 7
120308: ARRAY
120309: PUSH
120310: LD_VAR 0 31
120314: IN
120315: IFFALSE 120588
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
120317: LD_VAR 0 4
120321: PUSH
120322: LD_VAR 0 7
120326: ARRAY
120327: PPUSH
120328: LD_VAR 0 23
120332: PPUSH
120333: CALL_OW 308
120337: NOT
120338: PUSH
120339: LD_VAR 0 4
120343: PUSH
120344: LD_VAR 0 7
120348: ARRAY
120349: PPUSH
120350: CALL_OW 314
120354: NOT
120355: AND
120356: IFFALSE 120380
// ComMoveToArea ( group [ i ] , f_heal ) else
120358: LD_VAR 0 4
120362: PUSH
120363: LD_VAR 0 7
120367: ARRAY
120368: PPUSH
120369: LD_VAR 0 23
120373: PPUSH
120374: CALL_OW 113
120378: GO 120586
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
120380: LD_VAR 0 4
120384: PUSH
120385: LD_VAR 0 7
120389: ARRAY
120390: PPUSH
120391: CALL 98430 0 1
120395: PPUSH
120396: CALL_OW 256
120400: PUSH
120401: LD_INT 1000
120403: EQUAL
120404: IFFALSE 120423
// ComStop ( group [ i ] ) else
120406: LD_VAR 0 4
120410: PUSH
120411: LD_VAR 0 7
120415: ARRAY
120416: PPUSH
120417: CALL_OW 141
120421: GO 120586
// if not HasTask ( group [ i ] ) and to_heal then
120423: LD_VAR 0 4
120427: PUSH
120428: LD_VAR 0 7
120432: ARRAY
120433: PPUSH
120434: CALL_OW 314
120438: NOT
120439: PUSH
120440: LD_VAR 0 30
120444: AND
120445: IFFALSE 120586
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
120447: LD_ADDR_VAR 0 13
120451: PUSH
120452: LD_VAR 0 30
120456: PPUSH
120457: LD_INT 3
120459: PUSH
120460: LD_INT 54
120462: PUSH
120463: EMPTY
120464: LIST
120465: PUSH
120466: EMPTY
120467: LIST
120468: LIST
120469: PPUSH
120470: CALL_OW 72
120474: PPUSH
120475: LD_VAR 0 4
120479: PUSH
120480: LD_VAR 0 7
120484: ARRAY
120485: PPUSH
120486: CALL_OW 74
120490: ST_TO_ADDR
// if z then
120491: LD_VAR 0 13
120495: IFFALSE 120586
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
120497: LD_INT 91
120499: PUSH
120500: LD_VAR 0 13
120504: PUSH
120505: LD_INT 10
120507: PUSH
120508: EMPTY
120509: LIST
120510: LIST
120511: LIST
120512: PUSH
120513: LD_INT 81
120515: PUSH
120516: LD_VAR 0 13
120520: PPUSH
120521: CALL_OW 255
120525: PUSH
120526: EMPTY
120527: LIST
120528: LIST
120529: PUSH
120530: EMPTY
120531: LIST
120532: LIST
120533: PPUSH
120534: CALL_OW 69
120538: PUSH
120539: LD_INT 0
120541: EQUAL
120542: IFFALSE 120566
// ComHeal ( group [ i ] , z ) else
120544: LD_VAR 0 4
120548: PUSH
120549: LD_VAR 0 7
120553: ARRAY
120554: PPUSH
120555: LD_VAR 0 13
120559: PPUSH
120560: CALL_OW 128
120564: GO 120586
// ComMoveToArea ( group [ i ] , f_heal ) ;
120566: LD_VAR 0 4
120570: PUSH
120571: LD_VAR 0 7
120575: ARRAY
120576: PPUSH
120577: LD_VAR 0 23
120581: PPUSH
120582: CALL_OW 113
// end ; continue ;
120586: GO 119617
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
120588: LD_VAR 0 4
120592: PUSH
120593: LD_VAR 0 7
120597: ARRAY
120598: PPUSH
120599: CALL_OW 256
120603: PUSH
120604: LD_INT 700
120606: LESS
120607: PUSH
120608: LD_VAR 0 4
120612: PUSH
120613: LD_VAR 0 7
120617: ARRAY
120618: PUSH
120619: LD_VAR 0 30
120623: IN
120624: NOT
120625: AND
120626: IFFALSE 120650
// to_heal := to_heal union group [ i ] ;
120628: LD_ADDR_VAR 0 30
120632: PUSH
120633: LD_VAR 0 30
120637: PUSH
120638: LD_VAR 0 4
120642: PUSH
120643: LD_VAR 0 7
120647: ARRAY
120648: UNION
120649: ST_TO_ADDR
// if group [ i ] in to_heal then
120650: LD_VAR 0 4
120654: PUSH
120655: LD_VAR 0 7
120659: ARRAY
120660: PUSH
120661: LD_VAR 0 30
120665: IN
120666: IFFALSE 120775
// begin if GetLives ( group [ i ] ) = 1000 then
120668: LD_VAR 0 4
120672: PUSH
120673: LD_VAR 0 7
120677: ARRAY
120678: PPUSH
120679: CALL_OW 256
120683: PUSH
120684: LD_INT 1000
120686: EQUAL
120687: IFFALSE 120713
// to_heal := to_heal diff group [ i ] else
120689: LD_ADDR_VAR 0 30
120693: PUSH
120694: LD_VAR 0 30
120698: PUSH
120699: LD_VAR 0 4
120703: PUSH
120704: LD_VAR 0 7
120708: ARRAY
120709: DIFF
120710: ST_TO_ADDR
120711: GO 120775
// begin if not IsInArea ( group [ i ] , to_heal ) then
120713: LD_VAR 0 4
120717: PUSH
120718: LD_VAR 0 7
120722: ARRAY
120723: PPUSH
120724: LD_VAR 0 30
120728: PPUSH
120729: CALL_OW 308
120733: NOT
120734: IFFALSE 120758
// ComMoveToArea ( group [ i ] , f_heal ) else
120736: LD_VAR 0 4
120740: PUSH
120741: LD_VAR 0 7
120745: ARRAY
120746: PPUSH
120747: LD_VAR 0 23
120751: PPUSH
120752: CALL_OW 113
120756: GO 120773
// ComHold ( group [ i ] ) ;
120758: LD_VAR 0 4
120762: PUSH
120763: LD_VAR 0 7
120767: ARRAY
120768: PPUSH
120769: CALL_OW 140
// continue ;
120773: GO 119617
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
120775: LD_VAR 0 4
120779: PUSH
120780: LD_VAR 0 7
120784: ARRAY
120785: PPUSH
120786: LD_INT 10
120788: PPUSH
120789: CALL 96850 0 2
120793: NOT
120794: PUSH
120795: LD_VAR 0 16
120799: PUSH
120800: LD_VAR 0 7
120804: ARRAY
120805: PUSH
120806: EMPTY
120807: EQUAL
120808: NOT
120809: AND
120810: IFFALSE 121076
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
120812: LD_VAR 0 4
120816: PUSH
120817: LD_VAR 0 7
120821: ARRAY
120822: PPUSH
120823: CALL_OW 262
120827: PUSH
120828: LD_INT 1
120830: PUSH
120831: LD_INT 2
120833: PUSH
120834: EMPTY
120835: LIST
120836: LIST
120837: IN
120838: IFFALSE 120879
// if GetFuel ( group [ i ] ) < 10 then
120840: LD_VAR 0 4
120844: PUSH
120845: LD_VAR 0 7
120849: ARRAY
120850: PPUSH
120851: CALL_OW 261
120855: PUSH
120856: LD_INT 10
120858: LESS
120859: IFFALSE 120879
// SetFuel ( group [ i ] , 12 ) ;
120861: LD_VAR 0 4
120865: PUSH
120866: LD_VAR 0 7
120870: ARRAY
120871: PPUSH
120872: LD_INT 12
120874: PPUSH
120875: CALL_OW 240
// if units_path [ i ] then
120879: LD_VAR 0 16
120883: PUSH
120884: LD_VAR 0 7
120888: ARRAY
120889: IFFALSE 121074
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
120891: LD_VAR 0 4
120895: PUSH
120896: LD_VAR 0 7
120900: ARRAY
120901: PPUSH
120902: LD_VAR 0 16
120906: PUSH
120907: LD_VAR 0 7
120911: ARRAY
120912: PUSH
120913: LD_INT 1
120915: ARRAY
120916: PUSH
120917: LD_INT 1
120919: ARRAY
120920: PPUSH
120921: LD_VAR 0 16
120925: PUSH
120926: LD_VAR 0 7
120930: ARRAY
120931: PUSH
120932: LD_INT 1
120934: ARRAY
120935: PUSH
120936: LD_INT 2
120938: ARRAY
120939: PPUSH
120940: CALL_OW 297
120944: PUSH
120945: LD_INT 6
120947: GREATER
120948: IFFALSE 121023
// begin if not HasTask ( group [ i ] ) then
120950: LD_VAR 0 4
120954: PUSH
120955: LD_VAR 0 7
120959: ARRAY
120960: PPUSH
120961: CALL_OW 314
120965: NOT
120966: IFFALSE 121021
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
120968: LD_VAR 0 4
120972: PUSH
120973: LD_VAR 0 7
120977: ARRAY
120978: PPUSH
120979: LD_VAR 0 16
120983: PUSH
120984: LD_VAR 0 7
120988: ARRAY
120989: PUSH
120990: LD_INT 1
120992: ARRAY
120993: PUSH
120994: LD_INT 1
120996: ARRAY
120997: PPUSH
120998: LD_VAR 0 16
121002: PUSH
121003: LD_VAR 0 7
121007: ARRAY
121008: PUSH
121009: LD_INT 1
121011: ARRAY
121012: PUSH
121013: LD_INT 2
121015: ARRAY
121016: PPUSH
121017: CALL_OW 114
// end else
121021: GO 121074
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
121023: LD_ADDR_VAR 0 15
121027: PUSH
121028: LD_VAR 0 16
121032: PUSH
121033: LD_VAR 0 7
121037: ARRAY
121038: PPUSH
121039: LD_INT 1
121041: PPUSH
121042: CALL_OW 3
121046: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
121047: LD_ADDR_VAR 0 16
121051: PUSH
121052: LD_VAR 0 16
121056: PPUSH
121057: LD_VAR 0 7
121061: PPUSH
121062: LD_VAR 0 15
121066: PPUSH
121067: CALL_OW 1
121071: ST_TO_ADDR
// continue ;
121072: GO 119617
// end ; end ; end else
121074: GO 123738
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
121076: LD_ADDR_VAR 0 14
121080: PUSH
121081: LD_INT 81
121083: PUSH
121084: LD_VAR 0 4
121088: PUSH
121089: LD_VAR 0 7
121093: ARRAY
121094: PPUSH
121095: CALL_OW 255
121099: PUSH
121100: EMPTY
121101: LIST
121102: LIST
121103: PPUSH
121104: CALL_OW 69
121108: ST_TO_ADDR
// if not tmp then
121109: LD_VAR 0 14
121113: NOT
121114: IFFALSE 121118
// continue ;
121116: GO 119617
// if f_ignore_area then
121118: LD_VAR 0 17
121122: IFFALSE 121210
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
121124: LD_ADDR_VAR 0 15
121128: PUSH
121129: LD_VAR 0 14
121133: PPUSH
121134: LD_INT 3
121136: PUSH
121137: LD_INT 92
121139: PUSH
121140: LD_VAR 0 17
121144: PUSH
121145: LD_INT 1
121147: ARRAY
121148: PUSH
121149: LD_VAR 0 17
121153: PUSH
121154: LD_INT 2
121156: ARRAY
121157: PUSH
121158: LD_VAR 0 17
121162: PUSH
121163: LD_INT 3
121165: ARRAY
121166: PUSH
121167: EMPTY
121168: LIST
121169: LIST
121170: LIST
121171: LIST
121172: PUSH
121173: EMPTY
121174: LIST
121175: LIST
121176: PPUSH
121177: CALL_OW 72
121181: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121182: LD_VAR 0 14
121186: PUSH
121187: LD_VAR 0 15
121191: DIFF
121192: IFFALSE 121210
// tmp := tmp diff tmp2 ;
121194: LD_ADDR_VAR 0 14
121198: PUSH
121199: LD_VAR 0 14
121203: PUSH
121204: LD_VAR 0 15
121208: DIFF
121209: ST_TO_ADDR
// end ; if not f_murder then
121210: LD_VAR 0 20
121214: NOT
121215: IFFALSE 121273
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
121217: LD_ADDR_VAR 0 15
121221: PUSH
121222: LD_VAR 0 14
121226: PPUSH
121227: LD_INT 3
121229: PUSH
121230: LD_INT 50
121232: PUSH
121233: EMPTY
121234: LIST
121235: PUSH
121236: EMPTY
121237: LIST
121238: LIST
121239: PPUSH
121240: CALL_OW 72
121244: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121245: LD_VAR 0 14
121249: PUSH
121250: LD_VAR 0 15
121254: DIFF
121255: IFFALSE 121273
// tmp := tmp diff tmp2 ;
121257: LD_ADDR_VAR 0 14
121261: PUSH
121262: LD_VAR 0 14
121266: PUSH
121267: LD_VAR 0 15
121271: DIFF
121272: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
121273: LD_ADDR_VAR 0 14
121277: PUSH
121278: LD_VAR 0 4
121282: PUSH
121283: LD_VAR 0 7
121287: ARRAY
121288: PPUSH
121289: LD_VAR 0 14
121293: PPUSH
121294: LD_INT 1
121296: PPUSH
121297: LD_INT 1
121299: PPUSH
121300: CALL 70493 0 4
121304: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
121305: LD_VAR 0 4
121309: PUSH
121310: LD_VAR 0 7
121314: ARRAY
121315: PPUSH
121316: CALL_OW 257
121320: PUSH
121321: LD_INT 1
121323: EQUAL
121324: IFFALSE 121772
// begin if WantPlant ( group [ i ] ) then
121326: LD_VAR 0 4
121330: PUSH
121331: LD_VAR 0 7
121335: ARRAY
121336: PPUSH
121337: CALL 69994 0 1
121341: IFFALSE 121345
// continue ;
121343: GO 119617
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
121345: LD_VAR 0 18
121349: PUSH
121350: LD_VAR 0 4
121354: PUSH
121355: LD_VAR 0 7
121359: ARRAY
121360: PPUSH
121361: CALL_OW 310
121365: NOT
121366: AND
121367: PUSH
121368: LD_VAR 0 14
121372: PUSH
121373: LD_INT 1
121375: ARRAY
121376: PUSH
121377: LD_VAR 0 14
121381: PPUSH
121382: LD_INT 21
121384: PUSH
121385: LD_INT 2
121387: PUSH
121388: EMPTY
121389: LIST
121390: LIST
121391: PUSH
121392: LD_INT 58
121394: PUSH
121395: EMPTY
121396: LIST
121397: PUSH
121398: EMPTY
121399: LIST
121400: LIST
121401: PPUSH
121402: CALL_OW 72
121406: IN
121407: AND
121408: IFFALSE 121444
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
121410: LD_VAR 0 4
121414: PUSH
121415: LD_VAR 0 7
121419: ARRAY
121420: PPUSH
121421: LD_VAR 0 14
121425: PUSH
121426: LD_INT 1
121428: ARRAY
121429: PPUSH
121430: CALL_OW 120
// attacking := true ;
121434: LD_ADDR_VAR 0 29
121438: PUSH
121439: LD_INT 1
121441: ST_TO_ADDR
// continue ;
121442: GO 119617
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
121444: LD_VAR 0 26
121448: PUSH
121449: LD_VAR 0 4
121453: PUSH
121454: LD_VAR 0 7
121458: ARRAY
121459: PPUSH
121460: CALL_OW 257
121464: PUSH
121465: LD_INT 1
121467: EQUAL
121468: AND
121469: PUSH
121470: LD_VAR 0 4
121474: PUSH
121475: LD_VAR 0 7
121479: ARRAY
121480: PPUSH
121481: CALL_OW 256
121485: PUSH
121486: LD_INT 800
121488: LESS
121489: AND
121490: PUSH
121491: LD_VAR 0 4
121495: PUSH
121496: LD_VAR 0 7
121500: ARRAY
121501: PPUSH
121502: CALL_OW 318
121506: NOT
121507: AND
121508: IFFALSE 121525
// ComCrawl ( group [ i ] ) ;
121510: LD_VAR 0 4
121514: PUSH
121515: LD_VAR 0 7
121519: ARRAY
121520: PPUSH
121521: CALL_OW 137
// if f_mines then
121525: LD_VAR 0 21
121529: IFFALSE 121772
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
121531: LD_VAR 0 14
121535: PUSH
121536: LD_INT 1
121538: ARRAY
121539: PPUSH
121540: CALL_OW 247
121544: PUSH
121545: LD_INT 3
121547: EQUAL
121548: PUSH
121549: LD_VAR 0 14
121553: PUSH
121554: LD_INT 1
121556: ARRAY
121557: PUSH
121558: LD_VAR 0 27
121562: IN
121563: NOT
121564: AND
121565: IFFALSE 121772
// begin x := GetX ( tmp [ 1 ] ) ;
121567: LD_ADDR_VAR 0 10
121571: PUSH
121572: LD_VAR 0 14
121576: PUSH
121577: LD_INT 1
121579: ARRAY
121580: PPUSH
121581: CALL_OW 250
121585: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
121586: LD_ADDR_VAR 0 11
121590: PUSH
121591: LD_VAR 0 14
121595: PUSH
121596: LD_INT 1
121598: ARRAY
121599: PPUSH
121600: CALL_OW 251
121604: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
121605: LD_ADDR_VAR 0 12
121609: PUSH
121610: LD_VAR 0 4
121614: PUSH
121615: LD_VAR 0 7
121619: ARRAY
121620: PPUSH
121621: CALL 96935 0 1
121625: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
121626: LD_VAR 0 4
121630: PUSH
121631: LD_VAR 0 7
121635: ARRAY
121636: PPUSH
121637: LD_VAR 0 10
121641: PPUSH
121642: LD_VAR 0 11
121646: PPUSH
121647: LD_VAR 0 14
121651: PUSH
121652: LD_INT 1
121654: ARRAY
121655: PPUSH
121656: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
121660: LD_VAR 0 4
121664: PUSH
121665: LD_VAR 0 7
121669: ARRAY
121670: PPUSH
121671: LD_VAR 0 10
121675: PPUSH
121676: LD_VAR 0 12
121680: PPUSH
121681: LD_INT 7
121683: PPUSH
121684: CALL_OW 272
121688: PPUSH
121689: LD_VAR 0 11
121693: PPUSH
121694: LD_VAR 0 12
121698: PPUSH
121699: LD_INT 7
121701: PPUSH
121702: CALL_OW 273
121706: PPUSH
121707: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
121711: LD_VAR 0 4
121715: PUSH
121716: LD_VAR 0 7
121720: ARRAY
121721: PPUSH
121722: LD_INT 71
121724: PPUSH
121725: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
121729: LD_ADDR_VAR 0 27
121733: PUSH
121734: LD_VAR 0 27
121738: PPUSH
121739: LD_VAR 0 27
121743: PUSH
121744: LD_INT 1
121746: PLUS
121747: PPUSH
121748: LD_VAR 0 14
121752: PUSH
121753: LD_INT 1
121755: ARRAY
121756: PPUSH
121757: CALL_OW 1
121761: ST_TO_ADDR
// attacking := true ;
121762: LD_ADDR_VAR 0 29
121766: PUSH
121767: LD_INT 1
121769: ST_TO_ADDR
// continue ;
121770: GO 119617
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
121772: LD_VAR 0 4
121776: PUSH
121777: LD_VAR 0 7
121781: ARRAY
121782: PPUSH
121783: CALL_OW 257
121787: PUSH
121788: LD_INT 17
121790: EQUAL
121791: PUSH
121792: LD_VAR 0 4
121796: PUSH
121797: LD_VAR 0 7
121801: ARRAY
121802: PPUSH
121803: CALL_OW 110
121807: PUSH
121808: LD_INT 71
121810: EQUAL
121811: NOT
121812: AND
121813: IFFALSE 121959
// begin attacking := false ;
121815: LD_ADDR_VAR 0 29
121819: PUSH
121820: LD_INT 0
121822: ST_TO_ADDR
// k := 5 ;
121823: LD_ADDR_VAR 0 9
121827: PUSH
121828: LD_INT 5
121830: ST_TO_ADDR
// if tmp < k then
121831: LD_VAR 0 14
121835: PUSH
121836: LD_VAR 0 9
121840: LESS
121841: IFFALSE 121853
// k := tmp ;
121843: LD_ADDR_VAR 0 9
121847: PUSH
121848: LD_VAR 0 14
121852: ST_TO_ADDR
// for j = 1 to k do
121853: LD_ADDR_VAR 0 8
121857: PUSH
121858: DOUBLE
121859: LD_INT 1
121861: DEC
121862: ST_TO_ADDR
121863: LD_VAR 0 9
121867: PUSH
121868: FOR_TO
121869: IFFALSE 121957
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
121871: LD_VAR 0 14
121875: PUSH
121876: LD_VAR 0 8
121880: ARRAY
121881: PUSH
121882: LD_VAR 0 14
121886: PPUSH
121887: LD_INT 58
121889: PUSH
121890: EMPTY
121891: LIST
121892: PPUSH
121893: CALL_OW 72
121897: IN
121898: NOT
121899: IFFALSE 121955
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121901: LD_VAR 0 4
121905: PUSH
121906: LD_VAR 0 7
121910: ARRAY
121911: PPUSH
121912: LD_VAR 0 14
121916: PUSH
121917: LD_VAR 0 8
121921: ARRAY
121922: PPUSH
121923: CALL_OW 115
// attacking := true ;
121927: LD_ADDR_VAR 0 29
121931: PUSH
121932: LD_INT 1
121934: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
121935: LD_VAR 0 4
121939: PUSH
121940: LD_VAR 0 7
121944: ARRAY
121945: PPUSH
121946: LD_INT 71
121948: PPUSH
121949: CALL_OW 109
// continue ;
121953: GO 121868
// end ; end ;
121955: GO 121868
121957: POP
121958: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
121959: LD_VAR 0 4
121963: PUSH
121964: LD_VAR 0 7
121968: ARRAY
121969: PPUSH
121970: CALL_OW 257
121974: PUSH
121975: LD_INT 8
121977: EQUAL
121978: PUSH
121979: LD_VAR 0 4
121983: PUSH
121984: LD_VAR 0 7
121988: ARRAY
121989: PPUSH
121990: CALL_OW 264
121994: PUSH
121995: LD_INT 28
121997: PUSH
121998: LD_INT 45
122000: PUSH
122001: LD_INT 7
122003: PUSH
122004: LD_INT 47
122006: PUSH
122007: EMPTY
122008: LIST
122009: LIST
122010: LIST
122011: LIST
122012: IN
122013: OR
122014: IFFALSE 122270
// begin attacking := false ;
122016: LD_ADDR_VAR 0 29
122020: PUSH
122021: LD_INT 0
122023: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
122024: LD_VAR 0 14
122028: PUSH
122029: LD_INT 1
122031: ARRAY
122032: PPUSH
122033: CALL_OW 266
122037: PUSH
122038: LD_INT 32
122040: PUSH
122041: LD_INT 31
122043: PUSH
122044: LD_INT 33
122046: PUSH
122047: LD_INT 4
122049: PUSH
122050: LD_INT 5
122052: PUSH
122053: EMPTY
122054: LIST
122055: LIST
122056: LIST
122057: LIST
122058: LIST
122059: IN
122060: IFFALSE 122246
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
122062: LD_ADDR_VAR 0 9
122066: PUSH
122067: LD_VAR 0 14
122071: PUSH
122072: LD_INT 1
122074: ARRAY
122075: PPUSH
122076: CALL_OW 266
122080: PPUSH
122081: LD_VAR 0 14
122085: PUSH
122086: LD_INT 1
122088: ARRAY
122089: PPUSH
122090: CALL_OW 250
122094: PPUSH
122095: LD_VAR 0 14
122099: PUSH
122100: LD_INT 1
122102: ARRAY
122103: PPUSH
122104: CALL_OW 251
122108: PPUSH
122109: LD_VAR 0 14
122113: PUSH
122114: LD_INT 1
122116: ARRAY
122117: PPUSH
122118: CALL_OW 254
122122: PPUSH
122123: LD_VAR 0 14
122127: PUSH
122128: LD_INT 1
122130: ARRAY
122131: PPUSH
122132: CALL_OW 248
122136: PPUSH
122137: LD_INT 0
122139: PPUSH
122140: CALL 78305 0 6
122144: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
122145: LD_ADDR_VAR 0 8
122149: PUSH
122150: LD_VAR 0 4
122154: PUSH
122155: LD_VAR 0 7
122159: ARRAY
122160: PPUSH
122161: LD_VAR 0 9
122165: PPUSH
122166: CALL 96975 0 2
122170: ST_TO_ADDR
// if j then
122171: LD_VAR 0 8
122175: IFFALSE 122244
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
122177: LD_VAR 0 8
122181: PUSH
122182: LD_INT 1
122184: ARRAY
122185: PPUSH
122186: LD_VAR 0 8
122190: PUSH
122191: LD_INT 2
122193: ARRAY
122194: PPUSH
122195: CALL_OW 488
122199: IFFALSE 122244
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
122201: LD_VAR 0 4
122205: PUSH
122206: LD_VAR 0 7
122210: ARRAY
122211: PPUSH
122212: LD_VAR 0 8
122216: PUSH
122217: LD_INT 1
122219: ARRAY
122220: PPUSH
122221: LD_VAR 0 8
122225: PUSH
122226: LD_INT 2
122228: ARRAY
122229: PPUSH
122230: CALL_OW 116
// attacking := true ;
122234: LD_ADDR_VAR 0 29
122238: PUSH
122239: LD_INT 1
122241: ST_TO_ADDR
// continue ;
122242: GO 119617
// end ; end else
122244: GO 122270
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122246: LD_VAR 0 4
122250: PUSH
122251: LD_VAR 0 7
122255: ARRAY
122256: PPUSH
122257: LD_VAR 0 14
122261: PUSH
122262: LD_INT 1
122264: ARRAY
122265: PPUSH
122266: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
122270: LD_VAR 0 4
122274: PUSH
122275: LD_VAR 0 7
122279: ARRAY
122280: PPUSH
122281: CALL_OW 265
122285: PUSH
122286: LD_INT 11
122288: EQUAL
122289: IFFALSE 122567
// begin k := 10 ;
122291: LD_ADDR_VAR 0 9
122295: PUSH
122296: LD_INT 10
122298: ST_TO_ADDR
// x := 0 ;
122299: LD_ADDR_VAR 0 10
122303: PUSH
122304: LD_INT 0
122306: ST_TO_ADDR
// if tmp < k then
122307: LD_VAR 0 14
122311: PUSH
122312: LD_VAR 0 9
122316: LESS
122317: IFFALSE 122329
// k := tmp ;
122319: LD_ADDR_VAR 0 9
122323: PUSH
122324: LD_VAR 0 14
122328: ST_TO_ADDR
// for j = k downto 1 do
122329: LD_ADDR_VAR 0 8
122333: PUSH
122334: DOUBLE
122335: LD_VAR 0 9
122339: INC
122340: ST_TO_ADDR
122341: LD_INT 1
122343: PUSH
122344: FOR_DOWNTO
122345: IFFALSE 122420
// begin if GetType ( tmp [ j ] ) = unit_human then
122347: LD_VAR 0 14
122351: PUSH
122352: LD_VAR 0 8
122356: ARRAY
122357: PPUSH
122358: CALL_OW 247
122362: PUSH
122363: LD_INT 1
122365: EQUAL
122366: IFFALSE 122418
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
122368: LD_VAR 0 4
122372: PUSH
122373: LD_VAR 0 7
122377: ARRAY
122378: PPUSH
122379: LD_VAR 0 14
122383: PUSH
122384: LD_VAR 0 8
122388: ARRAY
122389: PPUSH
122390: CALL 97246 0 2
// x := tmp [ j ] ;
122394: LD_ADDR_VAR 0 10
122398: PUSH
122399: LD_VAR 0 14
122403: PUSH
122404: LD_VAR 0 8
122408: ARRAY
122409: ST_TO_ADDR
// attacking := true ;
122410: LD_ADDR_VAR 0 29
122414: PUSH
122415: LD_INT 1
122417: ST_TO_ADDR
// end ; end ;
122418: GO 122344
122420: POP
122421: POP
// if not x then
122422: LD_VAR 0 10
122426: NOT
122427: IFFALSE 122567
// begin attacking := true ;
122429: LD_ADDR_VAR 0 29
122433: PUSH
122434: LD_INT 1
122436: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
122437: LD_VAR 0 4
122441: PUSH
122442: LD_VAR 0 7
122446: ARRAY
122447: PPUSH
122448: CALL_OW 250
122452: PPUSH
122453: LD_VAR 0 4
122457: PUSH
122458: LD_VAR 0 7
122462: ARRAY
122463: PPUSH
122464: CALL_OW 251
122468: PPUSH
122469: CALL_OW 546
122473: PUSH
122474: LD_INT 2
122476: ARRAY
122477: PUSH
122478: LD_VAR 0 14
122482: PUSH
122483: LD_INT 1
122485: ARRAY
122486: PPUSH
122487: CALL_OW 250
122491: PPUSH
122492: LD_VAR 0 14
122496: PUSH
122497: LD_INT 1
122499: ARRAY
122500: PPUSH
122501: CALL_OW 251
122505: PPUSH
122506: CALL_OW 546
122510: PUSH
122511: LD_INT 2
122513: ARRAY
122514: EQUAL
122515: IFFALSE 122543
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
122517: LD_VAR 0 4
122521: PUSH
122522: LD_VAR 0 7
122526: ARRAY
122527: PPUSH
122528: LD_VAR 0 14
122532: PUSH
122533: LD_INT 1
122535: ARRAY
122536: PPUSH
122537: CALL 97246 0 2
122541: GO 122567
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122543: LD_VAR 0 4
122547: PUSH
122548: LD_VAR 0 7
122552: ARRAY
122553: PPUSH
122554: LD_VAR 0 14
122558: PUSH
122559: LD_INT 1
122561: ARRAY
122562: PPUSH
122563: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
122567: LD_VAR 0 4
122571: PUSH
122572: LD_VAR 0 7
122576: ARRAY
122577: PPUSH
122578: CALL_OW 264
122582: PUSH
122583: LD_INT 29
122585: EQUAL
122586: IFFALSE 122952
// begin if WantsToAttack ( group [ i ] ) in bombed then
122588: LD_VAR 0 4
122592: PUSH
122593: LD_VAR 0 7
122597: ARRAY
122598: PPUSH
122599: CALL_OW 319
122603: PUSH
122604: LD_VAR 0 28
122608: IN
122609: IFFALSE 122613
// continue ;
122611: GO 119617
// k := 8 ;
122613: LD_ADDR_VAR 0 9
122617: PUSH
122618: LD_INT 8
122620: ST_TO_ADDR
// x := 0 ;
122621: LD_ADDR_VAR 0 10
122625: PUSH
122626: LD_INT 0
122628: ST_TO_ADDR
// if tmp < k then
122629: LD_VAR 0 14
122633: PUSH
122634: LD_VAR 0 9
122638: LESS
122639: IFFALSE 122651
// k := tmp ;
122641: LD_ADDR_VAR 0 9
122645: PUSH
122646: LD_VAR 0 14
122650: ST_TO_ADDR
// for j = 1 to k do
122651: LD_ADDR_VAR 0 8
122655: PUSH
122656: DOUBLE
122657: LD_INT 1
122659: DEC
122660: ST_TO_ADDR
122661: LD_VAR 0 9
122665: PUSH
122666: FOR_TO
122667: IFFALSE 122799
// begin if GetType ( tmp [ j ] ) = unit_building then
122669: LD_VAR 0 14
122673: PUSH
122674: LD_VAR 0 8
122678: ARRAY
122679: PPUSH
122680: CALL_OW 247
122684: PUSH
122685: LD_INT 3
122687: EQUAL
122688: IFFALSE 122797
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
122690: LD_VAR 0 14
122694: PUSH
122695: LD_VAR 0 8
122699: ARRAY
122700: PUSH
122701: LD_VAR 0 28
122705: IN
122706: NOT
122707: PUSH
122708: LD_VAR 0 14
122712: PUSH
122713: LD_VAR 0 8
122717: ARRAY
122718: PPUSH
122719: CALL_OW 313
122723: AND
122724: IFFALSE 122797
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
122726: LD_VAR 0 4
122730: PUSH
122731: LD_VAR 0 7
122735: ARRAY
122736: PPUSH
122737: LD_VAR 0 14
122741: PUSH
122742: LD_VAR 0 8
122746: ARRAY
122747: PPUSH
122748: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
122752: LD_ADDR_VAR 0 28
122756: PUSH
122757: LD_VAR 0 28
122761: PPUSH
122762: LD_VAR 0 28
122766: PUSH
122767: LD_INT 1
122769: PLUS
122770: PPUSH
122771: LD_VAR 0 14
122775: PUSH
122776: LD_VAR 0 8
122780: ARRAY
122781: PPUSH
122782: CALL_OW 1
122786: ST_TO_ADDR
// attacking := true ;
122787: LD_ADDR_VAR 0 29
122791: PUSH
122792: LD_INT 1
122794: ST_TO_ADDR
// break ;
122795: GO 122799
// end ; end ;
122797: GO 122666
122799: POP
122800: POP
// if not attacking and f_attack_depot then
122801: LD_VAR 0 29
122805: NOT
122806: PUSH
122807: LD_VAR 0 25
122811: AND
122812: IFFALSE 122907
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
122814: LD_ADDR_VAR 0 13
122818: PUSH
122819: LD_VAR 0 14
122823: PPUSH
122824: LD_INT 2
122826: PUSH
122827: LD_INT 30
122829: PUSH
122830: LD_INT 0
122832: PUSH
122833: EMPTY
122834: LIST
122835: LIST
122836: PUSH
122837: LD_INT 30
122839: PUSH
122840: LD_INT 1
122842: PUSH
122843: EMPTY
122844: LIST
122845: LIST
122846: PUSH
122847: EMPTY
122848: LIST
122849: LIST
122850: LIST
122851: PPUSH
122852: CALL_OW 72
122856: ST_TO_ADDR
// if z then
122857: LD_VAR 0 13
122861: IFFALSE 122907
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
122863: LD_VAR 0 4
122867: PUSH
122868: LD_VAR 0 7
122872: ARRAY
122873: PPUSH
122874: LD_VAR 0 13
122878: PPUSH
122879: LD_VAR 0 4
122883: PUSH
122884: LD_VAR 0 7
122888: ARRAY
122889: PPUSH
122890: CALL_OW 74
122894: PPUSH
122895: CALL_OW 115
// attacking := true ;
122899: LD_ADDR_VAR 0 29
122903: PUSH
122904: LD_INT 1
122906: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
122907: LD_VAR 0 4
122911: PUSH
122912: LD_VAR 0 7
122916: ARRAY
122917: PPUSH
122918: CALL_OW 256
122922: PUSH
122923: LD_INT 500
122925: LESS
122926: IFFALSE 122952
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122928: LD_VAR 0 4
122932: PUSH
122933: LD_VAR 0 7
122937: ARRAY
122938: PPUSH
122939: LD_VAR 0 14
122943: PUSH
122944: LD_INT 1
122946: ARRAY
122947: PPUSH
122948: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
122952: LD_VAR 0 4
122956: PUSH
122957: LD_VAR 0 7
122961: ARRAY
122962: PPUSH
122963: CALL_OW 264
122967: PUSH
122968: LD_INT 49
122970: EQUAL
122971: IFFALSE 123092
// begin if not HasTask ( group [ i ] ) then
122973: LD_VAR 0 4
122977: PUSH
122978: LD_VAR 0 7
122982: ARRAY
122983: PPUSH
122984: CALL_OW 314
122988: NOT
122989: IFFALSE 123092
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
122991: LD_ADDR_VAR 0 9
122995: PUSH
122996: LD_INT 81
122998: PUSH
122999: LD_VAR 0 4
123003: PUSH
123004: LD_VAR 0 7
123008: ARRAY
123009: PPUSH
123010: CALL_OW 255
123014: PUSH
123015: EMPTY
123016: LIST
123017: LIST
123018: PPUSH
123019: CALL_OW 69
123023: PPUSH
123024: LD_VAR 0 4
123028: PUSH
123029: LD_VAR 0 7
123033: ARRAY
123034: PPUSH
123035: CALL_OW 74
123039: ST_TO_ADDR
// if k then
123040: LD_VAR 0 9
123044: IFFALSE 123092
// if GetDistUnits ( group [ i ] , k ) > 10 then
123046: LD_VAR 0 4
123050: PUSH
123051: LD_VAR 0 7
123055: ARRAY
123056: PPUSH
123057: LD_VAR 0 9
123061: PPUSH
123062: CALL_OW 296
123066: PUSH
123067: LD_INT 10
123069: GREATER
123070: IFFALSE 123092
// ComMoveUnit ( group [ i ] , k ) ;
123072: LD_VAR 0 4
123076: PUSH
123077: LD_VAR 0 7
123081: ARRAY
123082: PPUSH
123083: LD_VAR 0 9
123087: PPUSH
123088: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
123092: LD_VAR 0 4
123096: PUSH
123097: LD_VAR 0 7
123101: ARRAY
123102: PPUSH
123103: CALL_OW 256
123107: PUSH
123108: LD_INT 250
123110: LESS
123111: PUSH
123112: LD_VAR 0 4
123116: PUSH
123117: LD_VAR 0 7
123121: ARRAY
123122: PUSH
123123: LD_INT 21
123125: PUSH
123126: LD_INT 2
123128: PUSH
123129: EMPTY
123130: LIST
123131: LIST
123132: PUSH
123133: LD_INT 23
123135: PUSH
123136: LD_INT 2
123138: PUSH
123139: EMPTY
123140: LIST
123141: LIST
123142: PUSH
123143: EMPTY
123144: LIST
123145: LIST
123146: PPUSH
123147: CALL_OW 69
123151: IN
123152: AND
123153: IFFALSE 123278
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
123155: LD_ADDR_VAR 0 9
123159: PUSH
123160: LD_OWVAR 3
123164: PUSH
123165: LD_VAR 0 4
123169: PUSH
123170: LD_VAR 0 7
123174: ARRAY
123175: DIFF
123176: PPUSH
123177: LD_VAR 0 4
123181: PUSH
123182: LD_VAR 0 7
123186: ARRAY
123187: PPUSH
123188: CALL_OW 74
123192: ST_TO_ADDR
// if not k then
123193: LD_VAR 0 9
123197: NOT
123198: IFFALSE 123202
// continue ;
123200: GO 119617
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
123202: LD_VAR 0 9
123206: PUSH
123207: LD_INT 81
123209: PUSH
123210: LD_VAR 0 4
123214: PUSH
123215: LD_VAR 0 7
123219: ARRAY
123220: PPUSH
123221: CALL_OW 255
123225: PUSH
123226: EMPTY
123227: LIST
123228: LIST
123229: PPUSH
123230: CALL_OW 69
123234: IN
123235: PUSH
123236: LD_VAR 0 9
123240: PPUSH
123241: LD_VAR 0 4
123245: PUSH
123246: LD_VAR 0 7
123250: ARRAY
123251: PPUSH
123252: CALL_OW 296
123256: PUSH
123257: LD_INT 5
123259: LESS
123260: AND
123261: IFFALSE 123278
// ComAutodestruct ( group [ i ] ) ;
123263: LD_VAR 0 4
123267: PUSH
123268: LD_VAR 0 7
123272: ARRAY
123273: PPUSH
123274: CALL 97144 0 1
// end ; if f_attack_depot then
123278: LD_VAR 0 25
123282: IFFALSE 123394
// begin k := 6 ;
123284: LD_ADDR_VAR 0 9
123288: PUSH
123289: LD_INT 6
123291: ST_TO_ADDR
// if tmp < k then
123292: LD_VAR 0 14
123296: PUSH
123297: LD_VAR 0 9
123301: LESS
123302: IFFALSE 123314
// k := tmp ;
123304: LD_ADDR_VAR 0 9
123308: PUSH
123309: LD_VAR 0 14
123313: ST_TO_ADDR
// for j = 1 to k do
123314: LD_ADDR_VAR 0 8
123318: PUSH
123319: DOUBLE
123320: LD_INT 1
123322: DEC
123323: ST_TO_ADDR
123324: LD_VAR 0 9
123328: PUSH
123329: FOR_TO
123330: IFFALSE 123392
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
123332: LD_VAR 0 8
123336: PPUSH
123337: CALL_OW 266
123341: PUSH
123342: LD_INT 0
123344: PUSH
123345: LD_INT 1
123347: PUSH
123348: EMPTY
123349: LIST
123350: LIST
123351: IN
123352: IFFALSE 123390
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123354: LD_VAR 0 4
123358: PUSH
123359: LD_VAR 0 7
123363: ARRAY
123364: PPUSH
123365: LD_VAR 0 14
123369: PUSH
123370: LD_VAR 0 8
123374: ARRAY
123375: PPUSH
123376: CALL_OW 115
// attacking := true ;
123380: LD_ADDR_VAR 0 29
123384: PUSH
123385: LD_INT 1
123387: ST_TO_ADDR
// break ;
123388: GO 123392
// end ;
123390: GO 123329
123392: POP
123393: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
123394: LD_VAR 0 4
123398: PUSH
123399: LD_VAR 0 7
123403: ARRAY
123404: PPUSH
123405: CALL_OW 302
123409: PUSH
123410: LD_VAR 0 29
123414: NOT
123415: AND
123416: IFFALSE 123738
// begin if GetTag ( group [ i ] ) = 71 then
123418: LD_VAR 0 4
123422: PUSH
123423: LD_VAR 0 7
123427: ARRAY
123428: PPUSH
123429: CALL_OW 110
123433: PUSH
123434: LD_INT 71
123436: EQUAL
123437: IFFALSE 123478
// begin if HasTask ( group [ i ] ) then
123439: LD_VAR 0 4
123443: PUSH
123444: LD_VAR 0 7
123448: ARRAY
123449: PPUSH
123450: CALL_OW 314
123454: IFFALSE 123460
// continue else
123456: GO 119617
123458: GO 123478
// SetTag ( group [ i ] , 0 ) ;
123460: LD_VAR 0 4
123464: PUSH
123465: LD_VAR 0 7
123469: ARRAY
123470: PPUSH
123471: LD_INT 0
123473: PPUSH
123474: CALL_OW 109
// end ; k := 8 ;
123478: LD_ADDR_VAR 0 9
123482: PUSH
123483: LD_INT 8
123485: ST_TO_ADDR
// x := 0 ;
123486: LD_ADDR_VAR 0 10
123490: PUSH
123491: LD_INT 0
123493: ST_TO_ADDR
// if tmp < k then
123494: LD_VAR 0 14
123498: PUSH
123499: LD_VAR 0 9
123503: LESS
123504: IFFALSE 123516
// k := tmp ;
123506: LD_ADDR_VAR 0 9
123510: PUSH
123511: LD_VAR 0 14
123515: ST_TO_ADDR
// for j = 1 to k do
123516: LD_ADDR_VAR 0 8
123520: PUSH
123521: DOUBLE
123522: LD_INT 1
123524: DEC
123525: ST_TO_ADDR
123526: LD_VAR 0 9
123530: PUSH
123531: FOR_TO
123532: IFFALSE 123630
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
123534: LD_VAR 0 14
123538: PUSH
123539: LD_VAR 0 8
123543: ARRAY
123544: PPUSH
123545: CALL_OW 247
123549: PUSH
123550: LD_INT 1
123552: EQUAL
123553: PUSH
123554: LD_VAR 0 14
123558: PUSH
123559: LD_VAR 0 8
123563: ARRAY
123564: PPUSH
123565: CALL_OW 256
123569: PUSH
123570: LD_INT 250
123572: LESS
123573: PUSH
123574: LD_VAR 0 20
123578: AND
123579: PUSH
123580: LD_VAR 0 20
123584: NOT
123585: PUSH
123586: LD_VAR 0 14
123590: PUSH
123591: LD_VAR 0 8
123595: ARRAY
123596: PPUSH
123597: CALL_OW 256
123601: PUSH
123602: LD_INT 250
123604: GREATEREQUAL
123605: AND
123606: OR
123607: AND
123608: IFFALSE 123628
// begin x := tmp [ j ] ;
123610: LD_ADDR_VAR 0 10
123614: PUSH
123615: LD_VAR 0 14
123619: PUSH
123620: LD_VAR 0 8
123624: ARRAY
123625: ST_TO_ADDR
// break ;
123626: GO 123630
// end ;
123628: GO 123531
123630: POP
123631: POP
// if x then
123632: LD_VAR 0 10
123636: IFFALSE 123660
// ComAttackUnit ( group [ i ] , x ) else
123638: LD_VAR 0 4
123642: PUSH
123643: LD_VAR 0 7
123647: ARRAY
123648: PPUSH
123649: LD_VAR 0 10
123653: PPUSH
123654: CALL_OW 115
123658: GO 123684
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123660: LD_VAR 0 4
123664: PUSH
123665: LD_VAR 0 7
123669: ARRAY
123670: PPUSH
123671: LD_VAR 0 14
123675: PUSH
123676: LD_INT 1
123678: ARRAY
123679: PPUSH
123680: CALL_OW 115
// if not HasTask ( group [ i ] ) then
123684: LD_VAR 0 4
123688: PUSH
123689: LD_VAR 0 7
123693: ARRAY
123694: PPUSH
123695: CALL_OW 314
123699: NOT
123700: IFFALSE 123738
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
123702: LD_VAR 0 4
123706: PUSH
123707: LD_VAR 0 7
123711: ARRAY
123712: PPUSH
123713: LD_VAR 0 14
123717: PPUSH
123718: LD_VAR 0 4
123722: PUSH
123723: LD_VAR 0 7
123727: ARRAY
123728: PPUSH
123729: CALL_OW 74
123733: PPUSH
123734: CALL_OW 115
// end ; end ; end ;
123738: GO 119617
123740: POP
123741: POP
// wait ( 0 0$2 ) ;
123742: LD_INT 70
123744: PPUSH
123745: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
123749: LD_VAR 0 4
123753: NOT
123754: PUSH
123755: LD_VAR 0 4
123759: PUSH
123760: EMPTY
123761: EQUAL
123762: OR
123763: PUSH
123764: LD_INT 81
123766: PUSH
123767: LD_VAR 0 35
123771: PUSH
123772: EMPTY
123773: LIST
123774: LIST
123775: PPUSH
123776: CALL_OW 69
123780: NOT
123781: OR
123782: IFFALSE 119602
// end ;
123784: LD_VAR 0 2
123788: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
123789: LD_INT 0
123791: PPUSH
123792: PPUSH
123793: PPUSH
123794: PPUSH
123795: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
123796: LD_VAR 0 1
123800: NOT
123801: PUSH
123802: LD_EXP 113
123806: PUSH
123807: LD_VAR 0 1
123811: ARRAY
123812: NOT
123813: OR
123814: PUSH
123815: LD_VAR 0 2
123819: NOT
123820: OR
123821: PUSH
123822: LD_VAR 0 3
123826: NOT
123827: OR
123828: IFFALSE 123832
// exit ;
123830: GO 124345
// side := mc_sides [ base ] ;
123832: LD_ADDR_VAR 0 6
123836: PUSH
123837: LD_EXP 139
123841: PUSH
123842: LD_VAR 0 1
123846: ARRAY
123847: ST_TO_ADDR
// if not side then
123848: LD_VAR 0 6
123852: NOT
123853: IFFALSE 123857
// exit ;
123855: GO 124345
// for i in solds do
123857: LD_ADDR_VAR 0 7
123861: PUSH
123862: LD_VAR 0 2
123866: PUSH
123867: FOR_IN
123868: IFFALSE 123929
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
123870: LD_VAR 0 7
123874: PPUSH
123875: CALL_OW 310
123879: PPUSH
123880: CALL_OW 266
123884: PUSH
123885: LD_INT 32
123887: PUSH
123888: LD_INT 31
123890: PUSH
123891: EMPTY
123892: LIST
123893: LIST
123894: IN
123895: IFFALSE 123915
// solds := solds diff i else
123897: LD_ADDR_VAR 0 2
123901: PUSH
123902: LD_VAR 0 2
123906: PUSH
123907: LD_VAR 0 7
123911: DIFF
123912: ST_TO_ADDR
123913: GO 123927
// SetTag ( i , 18 ) ;
123915: LD_VAR 0 7
123919: PPUSH
123920: LD_INT 18
123922: PPUSH
123923: CALL_OW 109
123927: GO 123867
123929: POP
123930: POP
// if not solds then
123931: LD_VAR 0 2
123935: NOT
123936: IFFALSE 123940
// exit ;
123938: GO 124345
// repeat wait ( 0 0$1 ) ;
123940: LD_INT 35
123942: PPUSH
123943: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
123947: LD_ADDR_VAR 0 5
123951: PUSH
123952: LD_VAR 0 6
123956: PPUSH
123957: LD_VAR 0 3
123961: PPUSH
123962: CALL 66859 0 2
123966: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123967: LD_EXP 113
123971: PUSH
123972: LD_VAR 0 1
123976: ARRAY
123977: NOT
123978: PUSH
123979: LD_EXP 113
123983: PUSH
123984: LD_VAR 0 1
123988: ARRAY
123989: PUSH
123990: EMPTY
123991: EQUAL
123992: OR
123993: IFFALSE 124030
// begin for i in solds do
123995: LD_ADDR_VAR 0 7
123999: PUSH
124000: LD_VAR 0 2
124004: PUSH
124005: FOR_IN
124006: IFFALSE 124019
// ComStop ( i ) ;
124008: LD_VAR 0 7
124012: PPUSH
124013: CALL_OW 141
124017: GO 124005
124019: POP
124020: POP
// solds := [ ] ;
124021: LD_ADDR_VAR 0 2
124025: PUSH
124026: EMPTY
124027: ST_TO_ADDR
// exit ;
124028: GO 124345
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
124030: LD_VAR 0 5
124034: NOT
124035: PUSH
124036: LD_VAR 0 5
124040: PUSH
124041: LD_INT 3
124043: GREATER
124044: OR
124045: PUSH
124046: LD_EXP 135
124050: PUSH
124051: LD_VAR 0 1
124055: ARRAY
124056: OR
124057: IFFALSE 124098
// begin for i in solds do
124059: LD_ADDR_VAR 0 7
124063: PUSH
124064: LD_VAR 0 2
124068: PUSH
124069: FOR_IN
124070: IFFALSE 124094
// if HasTask ( i ) then
124072: LD_VAR 0 7
124076: PPUSH
124077: CALL_OW 314
124081: IFFALSE 124092
// ComStop ( i ) ;
124083: LD_VAR 0 7
124087: PPUSH
124088: CALL_OW 141
124092: GO 124069
124094: POP
124095: POP
// break ;
124096: GO 124333
// end ; for i in solds do
124098: LD_ADDR_VAR 0 7
124102: PUSH
124103: LD_VAR 0 2
124107: PUSH
124108: FOR_IN
124109: IFFALSE 124325
// begin if IsInUnit ( i ) then
124111: LD_VAR 0 7
124115: PPUSH
124116: CALL_OW 310
124120: IFFALSE 124131
// ComExitBuilding ( i ) ;
124122: LD_VAR 0 7
124126: PPUSH
124127: CALL_OW 122
// if GetLives ( i ) > 333 then
124131: LD_VAR 0 7
124135: PPUSH
124136: CALL_OW 256
124140: PUSH
124141: LD_INT 333
124143: GREATER
124144: IFFALSE 124172
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
124146: LD_VAR 0 7
124150: PPUSH
124151: LD_VAR 0 5
124155: PPUSH
124156: LD_VAR 0 7
124160: PPUSH
124161: CALL_OW 74
124165: PPUSH
124166: CALL_OW 115
124170: GO 124323
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
124172: LD_ADDR_VAR 0 8
124176: PUSH
124177: LD_EXP 113
124181: PUSH
124182: LD_VAR 0 1
124186: ARRAY
124187: PPUSH
124188: LD_INT 2
124190: PUSH
124191: LD_INT 30
124193: PUSH
124194: LD_INT 0
124196: PUSH
124197: EMPTY
124198: LIST
124199: LIST
124200: PUSH
124201: LD_INT 30
124203: PUSH
124204: LD_INT 1
124206: PUSH
124207: EMPTY
124208: LIST
124209: LIST
124210: PUSH
124211: LD_INT 30
124213: PUSH
124214: LD_INT 6
124216: PUSH
124217: EMPTY
124218: LIST
124219: LIST
124220: PUSH
124221: EMPTY
124222: LIST
124223: LIST
124224: LIST
124225: LIST
124226: PPUSH
124227: CALL_OW 72
124231: PPUSH
124232: LD_VAR 0 7
124236: PPUSH
124237: CALL_OW 74
124241: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
124242: LD_VAR 0 7
124246: PPUSH
124247: LD_VAR 0 8
124251: PPUSH
124252: CALL_OW 250
124256: PPUSH
124257: LD_INT 3
124259: PPUSH
124260: LD_INT 5
124262: PPUSH
124263: CALL_OW 272
124267: PPUSH
124268: LD_VAR 0 8
124272: PPUSH
124273: CALL_OW 251
124277: PPUSH
124278: LD_INT 3
124280: PPUSH
124281: LD_INT 5
124283: PPUSH
124284: CALL_OW 273
124288: PPUSH
124289: CALL_OW 111
// SetTag ( i , 0 ) ;
124293: LD_VAR 0 7
124297: PPUSH
124298: LD_INT 0
124300: PPUSH
124301: CALL_OW 109
// solds := solds diff i ;
124305: LD_ADDR_VAR 0 2
124309: PUSH
124310: LD_VAR 0 2
124314: PUSH
124315: LD_VAR 0 7
124319: DIFF
124320: ST_TO_ADDR
// continue ;
124321: GO 124108
// end ; end ;
124323: GO 124108
124325: POP
124326: POP
// until solds ;
124327: LD_VAR 0 2
124331: IFFALSE 123940
// MC_Reset ( base , 18 ) ;
124333: LD_VAR 0 1
124337: PPUSH
124338: LD_INT 18
124340: PPUSH
124341: CALL 39167 0 2
// end ;
124345: LD_VAR 0 4
124349: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
124350: LD_INT 0
124352: PPUSH
124353: PPUSH
124354: PPUSH
124355: PPUSH
124356: PPUSH
124357: PPUSH
124358: PPUSH
124359: PPUSH
124360: PPUSH
124361: PPUSH
124362: PPUSH
124363: PPUSH
124364: PPUSH
124365: PPUSH
124366: PPUSH
124367: PPUSH
124368: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
124369: LD_ADDR_VAR 0 13
124373: PUSH
124374: LD_EXP 113
124378: PUSH
124379: LD_VAR 0 1
124383: ARRAY
124384: PPUSH
124385: LD_INT 25
124387: PUSH
124388: LD_INT 3
124390: PUSH
124391: EMPTY
124392: LIST
124393: LIST
124394: PPUSH
124395: CALL_OW 72
124399: ST_TO_ADDR
// if mc_remote_driver [ base ] then
124400: LD_EXP 153
124404: PUSH
124405: LD_VAR 0 1
124409: ARRAY
124410: IFFALSE 124434
// mechs := mechs diff mc_remote_driver [ base ] ;
124412: LD_ADDR_VAR 0 13
124416: PUSH
124417: LD_VAR 0 13
124421: PUSH
124422: LD_EXP 153
124426: PUSH
124427: LD_VAR 0 1
124431: ARRAY
124432: DIFF
124433: ST_TO_ADDR
// for i in mechs do
124434: LD_ADDR_VAR 0 5
124438: PUSH
124439: LD_VAR 0 13
124443: PUSH
124444: FOR_IN
124445: IFFALSE 124480
// if GetTag ( i ) > 0 then
124447: LD_VAR 0 5
124451: PPUSH
124452: CALL_OW 110
124456: PUSH
124457: LD_INT 0
124459: GREATER
124460: IFFALSE 124478
// mechs := mechs diff i ;
124462: LD_ADDR_VAR 0 13
124466: PUSH
124467: LD_VAR 0 13
124471: PUSH
124472: LD_VAR 0 5
124476: DIFF
124477: ST_TO_ADDR
124478: GO 124444
124480: POP
124481: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124482: LD_ADDR_VAR 0 9
124486: PUSH
124487: LD_EXP 113
124491: PUSH
124492: LD_VAR 0 1
124496: ARRAY
124497: PPUSH
124498: LD_INT 2
124500: PUSH
124501: LD_INT 25
124503: PUSH
124504: LD_INT 1
124506: PUSH
124507: EMPTY
124508: LIST
124509: LIST
124510: PUSH
124511: LD_INT 25
124513: PUSH
124514: LD_INT 5
124516: PUSH
124517: EMPTY
124518: LIST
124519: LIST
124520: PUSH
124521: LD_INT 25
124523: PUSH
124524: LD_INT 8
124526: PUSH
124527: EMPTY
124528: LIST
124529: LIST
124530: PUSH
124531: LD_INT 25
124533: PUSH
124534: LD_INT 9
124536: PUSH
124537: EMPTY
124538: LIST
124539: LIST
124540: PUSH
124541: EMPTY
124542: LIST
124543: LIST
124544: LIST
124545: LIST
124546: LIST
124547: PPUSH
124548: CALL_OW 72
124552: ST_TO_ADDR
// if not defenders and not solds then
124553: LD_VAR 0 2
124557: NOT
124558: PUSH
124559: LD_VAR 0 9
124563: NOT
124564: AND
124565: IFFALSE 124569
// exit ;
124567: GO 126195
// depot_under_attack := false ;
124569: LD_ADDR_VAR 0 17
124573: PUSH
124574: LD_INT 0
124576: ST_TO_ADDR
// sold_defenders := [ ] ;
124577: LD_ADDR_VAR 0 18
124581: PUSH
124582: EMPTY
124583: ST_TO_ADDR
// if mechs then
124584: LD_VAR 0 13
124588: IFFALSE 124717
// for i in defenders do
124590: LD_ADDR_VAR 0 5
124594: PUSH
124595: LD_VAR 0 2
124599: PUSH
124600: FOR_IN
124601: IFFALSE 124715
// begin SetTag ( i , 20 ) ;
124603: LD_VAR 0 5
124607: PPUSH
124608: LD_INT 20
124610: PPUSH
124611: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
124615: LD_VAR 0 5
124619: PPUSH
124620: CALL_OW 263
124624: PUSH
124625: LD_INT 1
124627: EQUAL
124628: PUSH
124629: LD_VAR 0 5
124633: PPUSH
124634: CALL_OW 311
124638: NOT
124639: AND
124640: PUSH
124641: LD_VAR 0 13
124645: AND
124646: IFFALSE 124713
// begin un := mechs [ 1 ] ;
124648: LD_ADDR_VAR 0 11
124652: PUSH
124653: LD_VAR 0 13
124657: PUSH
124658: LD_INT 1
124660: ARRAY
124661: ST_TO_ADDR
// ComExitBuilding ( un ) ;
124662: LD_VAR 0 11
124666: PPUSH
124667: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
124671: LD_VAR 0 11
124675: PPUSH
124676: LD_VAR 0 5
124680: PPUSH
124681: CALL_OW 180
// SetTag ( un , 19 ) ;
124685: LD_VAR 0 11
124689: PPUSH
124690: LD_INT 19
124692: PPUSH
124693: CALL_OW 109
// mechs := mechs diff un ;
124697: LD_ADDR_VAR 0 13
124701: PUSH
124702: LD_VAR 0 13
124706: PUSH
124707: LD_VAR 0 11
124711: DIFF
124712: ST_TO_ADDR
// end ; end ;
124713: GO 124600
124715: POP
124716: POP
// if solds then
124717: LD_VAR 0 9
124721: IFFALSE 124780
// for i in solds do
124723: LD_ADDR_VAR 0 5
124727: PUSH
124728: LD_VAR 0 9
124732: PUSH
124733: FOR_IN
124734: IFFALSE 124778
// if not GetTag ( i ) then
124736: LD_VAR 0 5
124740: PPUSH
124741: CALL_OW 110
124745: NOT
124746: IFFALSE 124776
// begin defenders := defenders union i ;
124748: LD_ADDR_VAR 0 2
124752: PUSH
124753: LD_VAR 0 2
124757: PUSH
124758: LD_VAR 0 5
124762: UNION
124763: ST_TO_ADDR
// SetTag ( i , 18 ) ;
124764: LD_VAR 0 5
124768: PPUSH
124769: LD_INT 18
124771: PPUSH
124772: CALL_OW 109
// end ;
124776: GO 124733
124778: POP
124779: POP
// repeat wait ( 0 0$1 ) ;
124780: LD_INT 35
124782: PPUSH
124783: CALL_OW 67
// enemy := mc_scan [ base ] ;
124787: LD_ADDR_VAR 0 3
124791: PUSH
124792: LD_EXP 136
124796: PUSH
124797: LD_VAR 0 1
124801: ARRAY
124802: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124803: LD_EXP 113
124807: PUSH
124808: LD_VAR 0 1
124812: ARRAY
124813: NOT
124814: PUSH
124815: LD_EXP 113
124819: PUSH
124820: LD_VAR 0 1
124824: ARRAY
124825: PUSH
124826: EMPTY
124827: EQUAL
124828: OR
124829: IFFALSE 124866
// begin for i in defenders do
124831: LD_ADDR_VAR 0 5
124835: PUSH
124836: LD_VAR 0 2
124840: PUSH
124841: FOR_IN
124842: IFFALSE 124855
// ComStop ( i ) ;
124844: LD_VAR 0 5
124848: PPUSH
124849: CALL_OW 141
124853: GO 124841
124855: POP
124856: POP
// defenders := [ ] ;
124857: LD_ADDR_VAR 0 2
124861: PUSH
124862: EMPTY
124863: ST_TO_ADDR
// exit ;
124864: GO 126195
// end ; for i in defenders do
124866: LD_ADDR_VAR 0 5
124870: PUSH
124871: LD_VAR 0 2
124875: PUSH
124876: FOR_IN
124877: IFFALSE 125695
// begin e := NearestUnitToUnit ( enemy , i ) ;
124879: LD_ADDR_VAR 0 14
124883: PUSH
124884: LD_VAR 0 3
124888: PPUSH
124889: LD_VAR 0 5
124893: PPUSH
124894: CALL_OW 74
124898: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
124899: LD_ADDR_VAR 0 8
124903: PUSH
124904: LD_EXP 113
124908: PUSH
124909: LD_VAR 0 1
124913: ARRAY
124914: PPUSH
124915: LD_INT 2
124917: PUSH
124918: LD_INT 30
124920: PUSH
124921: LD_INT 0
124923: PUSH
124924: EMPTY
124925: LIST
124926: LIST
124927: PUSH
124928: LD_INT 30
124930: PUSH
124931: LD_INT 1
124933: PUSH
124934: EMPTY
124935: LIST
124936: LIST
124937: PUSH
124938: EMPTY
124939: LIST
124940: LIST
124941: LIST
124942: PPUSH
124943: CALL_OW 72
124947: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
124948: LD_ADDR_VAR 0 17
124952: PUSH
124953: LD_VAR 0 8
124957: NOT
124958: PUSH
124959: LD_VAR 0 8
124963: PPUSH
124964: LD_INT 3
124966: PUSH
124967: LD_INT 24
124969: PUSH
124970: LD_INT 600
124972: PUSH
124973: EMPTY
124974: LIST
124975: LIST
124976: PUSH
124977: EMPTY
124978: LIST
124979: LIST
124980: PPUSH
124981: CALL_OW 72
124985: OR
124986: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
124987: LD_VAR 0 5
124991: PPUSH
124992: CALL_OW 247
124996: PUSH
124997: LD_INT 2
124999: DOUBLE
125000: EQUAL
125001: IFTRUE 125005
125003: GO 125401
125005: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
125006: LD_VAR 0 5
125010: PPUSH
125011: CALL_OW 256
125015: PUSH
125016: LD_INT 650
125018: GREATER
125019: PUSH
125020: LD_VAR 0 5
125024: PPUSH
125025: LD_VAR 0 14
125029: PPUSH
125030: CALL_OW 296
125034: PUSH
125035: LD_INT 40
125037: LESS
125038: PUSH
125039: LD_VAR 0 14
125043: PPUSH
125044: LD_EXP 138
125048: PUSH
125049: LD_VAR 0 1
125053: ARRAY
125054: PPUSH
125055: CALL_OW 308
125059: OR
125060: AND
125061: IFFALSE 125183
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
125063: LD_VAR 0 5
125067: PPUSH
125068: CALL_OW 262
125072: PUSH
125073: LD_INT 1
125075: EQUAL
125076: PUSH
125077: LD_VAR 0 5
125081: PPUSH
125082: CALL_OW 261
125086: PUSH
125087: LD_INT 30
125089: LESS
125090: AND
125091: PUSH
125092: LD_VAR 0 8
125096: AND
125097: IFFALSE 125167
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
125099: LD_VAR 0 5
125103: PPUSH
125104: LD_VAR 0 8
125108: PPUSH
125109: LD_VAR 0 5
125113: PPUSH
125114: CALL_OW 74
125118: PPUSH
125119: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
125123: LD_VAR 0 5
125127: PPUSH
125128: LD_VAR 0 8
125132: PPUSH
125133: LD_VAR 0 5
125137: PPUSH
125138: CALL_OW 74
125142: PPUSH
125143: CALL_OW 296
125147: PUSH
125148: LD_INT 6
125150: LESS
125151: IFFALSE 125165
// SetFuel ( i , 100 ) ;
125153: LD_VAR 0 5
125157: PPUSH
125158: LD_INT 100
125160: PPUSH
125161: CALL_OW 240
// end else
125165: GO 125181
// ComAttackUnit ( i , e ) ;
125167: LD_VAR 0 5
125171: PPUSH
125172: LD_VAR 0 14
125176: PPUSH
125177: CALL_OW 115
// end else
125181: GO 125284
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
125183: LD_VAR 0 14
125187: PPUSH
125188: LD_EXP 138
125192: PUSH
125193: LD_VAR 0 1
125197: ARRAY
125198: PPUSH
125199: CALL_OW 308
125203: NOT
125204: PUSH
125205: LD_VAR 0 5
125209: PPUSH
125210: LD_VAR 0 14
125214: PPUSH
125215: CALL_OW 296
125219: PUSH
125220: LD_INT 40
125222: GREATEREQUAL
125223: AND
125224: PUSH
125225: LD_VAR 0 5
125229: PPUSH
125230: CALL_OW 256
125234: PUSH
125235: LD_INT 650
125237: LESSEQUAL
125238: OR
125239: PUSH
125240: LD_VAR 0 5
125244: PPUSH
125245: LD_EXP 137
125249: PUSH
125250: LD_VAR 0 1
125254: ARRAY
125255: PPUSH
125256: CALL_OW 308
125260: NOT
125261: AND
125262: IFFALSE 125284
// ComMoveToArea ( i , mc_parking [ base ] ) ;
125264: LD_VAR 0 5
125268: PPUSH
125269: LD_EXP 137
125273: PUSH
125274: LD_VAR 0 1
125278: ARRAY
125279: PPUSH
125280: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
125284: LD_VAR 0 5
125288: PPUSH
125289: CALL_OW 256
125293: PUSH
125294: LD_INT 998
125296: LESS
125297: PUSH
125298: LD_VAR 0 5
125302: PPUSH
125303: CALL_OW 263
125307: PUSH
125308: LD_INT 1
125310: EQUAL
125311: AND
125312: PUSH
125313: LD_VAR 0 5
125317: PPUSH
125318: CALL_OW 311
125322: AND
125323: PUSH
125324: LD_VAR 0 5
125328: PPUSH
125329: LD_EXP 137
125333: PUSH
125334: LD_VAR 0 1
125338: ARRAY
125339: PPUSH
125340: CALL_OW 308
125344: AND
125345: IFFALSE 125399
// begin mech := IsDrivenBy ( i ) ;
125347: LD_ADDR_VAR 0 10
125351: PUSH
125352: LD_VAR 0 5
125356: PPUSH
125357: CALL_OW 311
125361: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
125362: LD_VAR 0 10
125366: PPUSH
125367: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
125371: LD_VAR 0 10
125375: PPUSH
125376: LD_VAR 0 5
125380: PPUSH
125381: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
125385: LD_VAR 0 10
125389: PPUSH
125390: LD_VAR 0 5
125394: PPUSH
125395: CALL_OW 180
// end ; end ; unit_human :
125399: GO 125666
125401: LD_INT 1
125403: DOUBLE
125404: EQUAL
125405: IFTRUE 125409
125407: GO 125665
125409: POP
// begin b := IsInUnit ( i ) ;
125410: LD_ADDR_VAR 0 19
125414: PUSH
125415: LD_VAR 0 5
125419: PPUSH
125420: CALL_OW 310
125424: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
125425: LD_ADDR_VAR 0 20
125429: PUSH
125430: LD_VAR 0 19
125434: NOT
125435: PUSH
125436: LD_VAR 0 19
125440: PPUSH
125441: CALL_OW 266
125445: PUSH
125446: LD_INT 32
125448: PUSH
125449: LD_INT 31
125451: PUSH
125452: EMPTY
125453: LIST
125454: LIST
125455: IN
125456: OR
125457: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
125458: LD_VAR 0 17
125462: PUSH
125463: LD_VAR 0 2
125467: PPUSH
125468: LD_INT 21
125470: PUSH
125471: LD_INT 2
125473: PUSH
125474: EMPTY
125475: LIST
125476: LIST
125477: PPUSH
125478: CALL_OW 72
125482: PUSH
125483: LD_INT 1
125485: LESSEQUAL
125486: OR
125487: PUSH
125488: LD_VAR 0 20
125492: AND
125493: PUSH
125494: LD_VAR 0 5
125498: PUSH
125499: LD_VAR 0 18
125503: IN
125504: NOT
125505: AND
125506: IFFALSE 125599
// begin if b then
125508: LD_VAR 0 19
125512: IFFALSE 125561
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
125514: LD_VAR 0 19
125518: PPUSH
125519: LD_VAR 0 3
125523: PPUSH
125524: LD_VAR 0 19
125528: PPUSH
125529: CALL_OW 74
125533: PPUSH
125534: CALL_OW 296
125538: PUSH
125539: LD_INT 10
125541: LESS
125542: PUSH
125543: LD_VAR 0 19
125547: PPUSH
125548: CALL_OW 461
125552: PUSH
125553: LD_INT 7
125555: NONEQUAL
125556: AND
125557: IFFALSE 125561
// continue ;
125559: GO 124876
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
125561: LD_ADDR_VAR 0 18
125565: PUSH
125566: LD_VAR 0 18
125570: PPUSH
125571: LD_VAR 0 18
125575: PUSH
125576: LD_INT 1
125578: PLUS
125579: PPUSH
125580: LD_VAR 0 5
125584: PPUSH
125585: CALL_OW 1
125589: ST_TO_ADDR
// ComExitBuilding ( i ) ;
125590: LD_VAR 0 5
125594: PPUSH
125595: CALL_OW 122
// end ; if sold_defenders then
125599: LD_VAR 0 18
125603: IFFALSE 125663
// if i in sold_defenders then
125605: LD_VAR 0 5
125609: PUSH
125610: LD_VAR 0 18
125614: IN
125615: IFFALSE 125663
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
125617: LD_VAR 0 5
125621: PPUSH
125622: CALL_OW 314
125626: NOT
125627: PUSH
125628: LD_VAR 0 5
125632: PPUSH
125633: LD_VAR 0 14
125637: PPUSH
125638: CALL_OW 296
125642: PUSH
125643: LD_INT 30
125645: LESS
125646: AND
125647: IFFALSE 125663
// ComAttackUnit ( i , e ) ;
125649: LD_VAR 0 5
125653: PPUSH
125654: LD_VAR 0 14
125658: PPUSH
125659: CALL_OW 115
// end ; end ; end ;
125663: GO 125666
125665: POP
// if IsDead ( i ) then
125666: LD_VAR 0 5
125670: PPUSH
125671: CALL_OW 301
125675: IFFALSE 125693
// defenders := defenders diff i ;
125677: LD_ADDR_VAR 0 2
125681: PUSH
125682: LD_VAR 0 2
125686: PUSH
125687: LD_VAR 0 5
125691: DIFF
125692: ST_TO_ADDR
// end ;
125693: GO 124876
125695: POP
125696: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
125697: LD_VAR 0 3
125701: NOT
125702: PUSH
125703: LD_VAR 0 2
125707: NOT
125708: OR
125709: PUSH
125710: LD_EXP 113
125714: PUSH
125715: LD_VAR 0 1
125719: ARRAY
125720: NOT
125721: OR
125722: IFFALSE 124780
// MC_Reset ( base , 18 ) ;
125724: LD_VAR 0 1
125728: PPUSH
125729: LD_INT 18
125731: PPUSH
125732: CALL 39167 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
125736: LD_ADDR_VAR 0 2
125740: PUSH
125741: LD_VAR 0 2
125745: PUSH
125746: LD_VAR 0 2
125750: PPUSH
125751: LD_INT 2
125753: PUSH
125754: LD_INT 25
125756: PUSH
125757: LD_INT 1
125759: PUSH
125760: EMPTY
125761: LIST
125762: LIST
125763: PUSH
125764: LD_INT 25
125766: PUSH
125767: LD_INT 5
125769: PUSH
125770: EMPTY
125771: LIST
125772: LIST
125773: PUSH
125774: LD_INT 25
125776: PUSH
125777: LD_INT 8
125779: PUSH
125780: EMPTY
125781: LIST
125782: LIST
125783: PUSH
125784: LD_INT 25
125786: PUSH
125787: LD_INT 9
125789: PUSH
125790: EMPTY
125791: LIST
125792: LIST
125793: PUSH
125794: EMPTY
125795: LIST
125796: LIST
125797: LIST
125798: LIST
125799: LIST
125800: PPUSH
125801: CALL_OW 72
125805: DIFF
125806: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
125807: LD_VAR 0 3
125811: NOT
125812: PUSH
125813: LD_VAR 0 2
125817: PPUSH
125818: LD_INT 21
125820: PUSH
125821: LD_INT 2
125823: PUSH
125824: EMPTY
125825: LIST
125826: LIST
125827: PPUSH
125828: CALL_OW 72
125832: AND
125833: IFFALSE 126171
// begin tmp := FilterByTag ( defenders , 19 ) ;
125835: LD_ADDR_VAR 0 12
125839: PUSH
125840: LD_VAR 0 2
125844: PPUSH
125845: LD_INT 19
125847: PPUSH
125848: CALL 98619 0 2
125852: ST_TO_ADDR
// if tmp then
125853: LD_VAR 0 12
125857: IFFALSE 125927
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
125859: LD_ADDR_VAR 0 12
125863: PUSH
125864: LD_VAR 0 12
125868: PPUSH
125869: LD_INT 25
125871: PUSH
125872: LD_INT 3
125874: PUSH
125875: EMPTY
125876: LIST
125877: LIST
125878: PPUSH
125879: CALL_OW 72
125883: ST_TO_ADDR
// if tmp then
125884: LD_VAR 0 12
125888: IFFALSE 125927
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
125890: LD_ADDR_EXP 125
125894: PUSH
125895: LD_EXP 125
125899: PPUSH
125900: LD_VAR 0 1
125904: PPUSH
125905: LD_EXP 125
125909: PUSH
125910: LD_VAR 0 1
125914: ARRAY
125915: PUSH
125916: LD_VAR 0 12
125920: UNION
125921: PPUSH
125922: CALL_OW 1
125926: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
125927: LD_VAR 0 1
125931: PPUSH
125932: LD_INT 19
125934: PPUSH
125935: CALL 39167 0 2
// repeat wait ( 0 0$1 ) ;
125939: LD_INT 35
125941: PPUSH
125942: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125946: LD_EXP 113
125950: PUSH
125951: LD_VAR 0 1
125955: ARRAY
125956: NOT
125957: PUSH
125958: LD_EXP 113
125962: PUSH
125963: LD_VAR 0 1
125967: ARRAY
125968: PUSH
125969: EMPTY
125970: EQUAL
125971: OR
125972: IFFALSE 126009
// begin for i in defenders do
125974: LD_ADDR_VAR 0 5
125978: PUSH
125979: LD_VAR 0 2
125983: PUSH
125984: FOR_IN
125985: IFFALSE 125998
// ComStop ( i ) ;
125987: LD_VAR 0 5
125991: PPUSH
125992: CALL_OW 141
125996: GO 125984
125998: POP
125999: POP
// defenders := [ ] ;
126000: LD_ADDR_VAR 0 2
126004: PUSH
126005: EMPTY
126006: ST_TO_ADDR
// exit ;
126007: GO 126195
// end ; for i in defenders do
126009: LD_ADDR_VAR 0 5
126013: PUSH
126014: LD_VAR 0 2
126018: PUSH
126019: FOR_IN
126020: IFFALSE 126109
// begin if not IsInArea ( i , mc_parking [ base ] ) then
126022: LD_VAR 0 5
126026: PPUSH
126027: LD_EXP 137
126031: PUSH
126032: LD_VAR 0 1
126036: ARRAY
126037: PPUSH
126038: CALL_OW 308
126042: NOT
126043: IFFALSE 126067
// ComMoveToArea ( i , mc_parking [ base ] ) else
126045: LD_VAR 0 5
126049: PPUSH
126050: LD_EXP 137
126054: PUSH
126055: LD_VAR 0 1
126059: ARRAY
126060: PPUSH
126061: CALL_OW 113
126065: GO 126107
// if GetControl ( i ) = control_manual then
126067: LD_VAR 0 5
126071: PPUSH
126072: CALL_OW 263
126076: PUSH
126077: LD_INT 1
126079: EQUAL
126080: IFFALSE 126107
// if IsDrivenBy ( i ) then
126082: LD_VAR 0 5
126086: PPUSH
126087: CALL_OW 311
126091: IFFALSE 126107
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
126093: LD_VAR 0 5
126097: PPUSH
126098: CALL_OW 311
126102: PPUSH
126103: CALL_OW 121
// end ;
126107: GO 126019
126109: POP
126110: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
126111: LD_VAR 0 2
126115: PPUSH
126116: LD_INT 95
126118: PUSH
126119: LD_EXP 137
126123: PUSH
126124: LD_VAR 0 1
126128: ARRAY
126129: PUSH
126130: EMPTY
126131: LIST
126132: LIST
126133: PPUSH
126134: CALL_OW 72
126138: PUSH
126139: LD_VAR 0 2
126143: EQUAL
126144: PUSH
126145: LD_EXP 136
126149: PUSH
126150: LD_VAR 0 1
126154: ARRAY
126155: OR
126156: PUSH
126157: LD_EXP 113
126161: PUSH
126162: LD_VAR 0 1
126166: ARRAY
126167: NOT
126168: OR
126169: IFFALSE 125939
// end ; MC_Reset ( base , 19 ) ;
126171: LD_VAR 0 1
126175: PPUSH
126176: LD_INT 19
126178: PPUSH
126179: CALL 39167 0 2
// MC_Reset ( base , 20 ) ;
126183: LD_VAR 0 1
126187: PPUSH
126188: LD_INT 20
126190: PPUSH
126191: CALL 39167 0 2
// end ; end_of_file
126195: LD_VAR 0 4
126199: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
126200: LD_VAR 0 1
126204: PUSH
126205: LD_INT 200
126207: DOUBLE
126208: GREATEREQUAL
126209: IFFALSE 126217
126211: LD_INT 299
126213: DOUBLE
126214: LESSEQUAL
126215: IFTRUE 126219
126217: GO 126251
126219: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
126220: LD_VAR 0 1
126224: PPUSH
126225: LD_VAR 0 2
126229: PPUSH
126230: LD_VAR 0 3
126234: PPUSH
126235: LD_VAR 0 4
126239: PPUSH
126240: LD_VAR 0 5
126244: PPUSH
126245: CALL 115205 0 5
126249: GO 126328
126251: LD_INT 300
126253: DOUBLE
126254: GREATEREQUAL
126255: IFFALSE 126263
126257: LD_INT 399
126259: DOUBLE
126260: LESSEQUAL
126261: IFTRUE 126265
126263: GO 126327
126265: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
126266: LD_VAR 0 1
126270: PPUSH
126271: LD_VAR 0 2
126275: PPUSH
126276: LD_VAR 0 3
126280: PPUSH
126281: LD_VAR 0 4
126285: PPUSH
126286: LD_VAR 0 5
126290: PPUSH
126291: LD_VAR 0 6
126295: PPUSH
126296: LD_VAR 0 7
126300: PPUSH
126301: LD_VAR 0 8
126305: PPUSH
126306: LD_VAR 0 9
126310: PPUSH
126311: LD_VAR 0 10
126315: PPUSH
126316: LD_VAR 0 11
126320: PPUSH
126321: CALL 113111 0 11
126325: GO 126328
126327: POP
// end ;
126328: PPOPN 11
126330: END
