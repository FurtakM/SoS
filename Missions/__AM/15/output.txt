// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38101 0 0
// InitNature ;
  19: CALL 37969 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12213 0 0
// PrepareRussian ;
  40: CALL 7197 0 0
// PrepareLegion ;
  44: CALL 4352 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 16933 0 0
// MC_Start ( ) ;
  60: CALL 40281 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63063 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63156 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 62506 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 62321 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63063 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63156 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 62321 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 62506 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 62936 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 61984 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63063 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63156 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 62321 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63063 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63156 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 62213 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 63474 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 62645 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 62936 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 62936 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 63268 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 62321 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 62887 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 68795 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 73635 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 73635 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 73635 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 73635 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 73635 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 68795 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 68795 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 68795 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 68795 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 68795 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 68795 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 68795 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 68795 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 68795 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 68795 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 68795 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 68795 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 68795 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 68795 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 68795 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// tmp := [ ] ;
3222: LD_ADDR_VAR 0 5
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// if JMMGirl <> 2 then
3229: LD_EXP 7
3233: PUSH
3234: LD_INT 2
3236: NONEQUAL
3237: IFFALSE 3261
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 43
3243: PUSH
3244: LD_STRING Lisa
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 68795 0 3
3260: ST_TO_ADDR
// if Lisa then
3261: LD_EXP 43
3265: IFFALSE 3283
// tmp := tmp ^ Lisa ;
3267: LD_ADDR_VAR 0 5
3271: PUSH
3272: LD_VAR 0 5
3276: PUSH
3277: LD_EXP 43
3281: ADD
3282: ST_TO_ADDR
// if JMMGirl < 3 then
3283: LD_EXP 7
3287: PUSH
3288: LD_INT 3
3290: LESS
3291: IFFALSE 3322
// begin Connie := NewCharacter ( Coonie ) ;
3293: LD_ADDR_EXP 55
3297: PUSH
3298: LD_STRING Coonie
3300: PPUSH
3301: CALL_OW 25
3305: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3306: LD_ADDR_VAR 0 5
3310: PUSH
3311: LD_VAR 0 5
3315: PUSH
3316: LD_EXP 55
3320: ADD
3321: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3322: LD_ADDR_EXP 44
3326: PUSH
3327: LD_STRING Donaldson
3329: PPUSH
3330: LD_EXP 1
3334: NOT
3335: PPUSH
3336: LD_STRING 13s_
3338: PPUSH
3339: CALL 68795 0 3
3343: ST_TO_ADDR
// if Donaldson then
3344: LD_EXP 44
3348: IFFALSE 3366
// tmp := tmp ^ Donaldson ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_VAR 0 5
3359: PUSH
3360: LD_EXP 44
3364: ADD
3365: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3366: LD_ADDR_EXP 45
3370: PUSH
3371: LD_STRING Bobby
3373: PPUSH
3374: LD_EXP 1
3378: NOT
3379: PPUSH
3380: LD_STRING 13s_
3382: PPUSH
3383: CALL 68795 0 3
3387: ST_TO_ADDR
// if Bobby then
3388: LD_EXP 45
3392: IFFALSE 3410
// tmp := tmp ^ Bobby ;
3394: LD_ADDR_VAR 0 5
3398: PUSH
3399: LD_VAR 0 5
3403: PUSH
3404: LD_EXP 45
3408: ADD
3409: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3410: LD_ADDR_EXP 46
3414: PUSH
3415: LD_STRING Cyrus
3417: PPUSH
3418: LD_EXP 1
3422: NOT
3423: PPUSH
3424: LD_STRING 13s_
3426: PPUSH
3427: CALL 68795 0 3
3431: ST_TO_ADDR
// if Cyrus then
3432: LD_EXP 46
3436: IFFALSE 3454
// tmp := tmp ^ Cyrus ;
3438: LD_ADDR_VAR 0 5
3442: PUSH
3443: LD_VAR 0 5
3447: PUSH
3448: LD_EXP 46
3452: ADD
3453: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3454: LD_ADDR_EXP 47
3458: PUSH
3459: LD_STRING Denis
3461: PPUSH
3462: LD_EXP 1
3466: NOT
3467: PPUSH
3468: LD_STRING 13s_
3470: PPUSH
3471: CALL 68795 0 3
3475: ST_TO_ADDR
// if not Denis then
3476: LD_EXP 47
3480: NOT
3481: IFFALSE 3505
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3483: LD_ADDR_EXP 47
3487: PUSH
3488: LD_STRING Denis
3490: PPUSH
3491: LD_EXP 1
3495: NOT
3496: PPUSH
3497: LD_STRING 13f_
3499: PPUSH
3500: CALL 68795 0 3
3504: ST_TO_ADDR
// if Denis then
3505: LD_EXP 47
3509: IFFALSE 3527
// tmp := tmp ^ Denis ;
3511: LD_ADDR_VAR 0 5
3515: PUSH
3516: LD_VAR 0 5
3520: PUSH
3521: LD_EXP 47
3525: ADD
3526: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3527: LD_ADDR_EXP 48
3531: PUSH
3532: LD_STRING Brown
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: LD_STRING 13s_
3543: PPUSH
3544: CALL 68795 0 3
3548: ST_TO_ADDR
// if Brown then
3549: LD_EXP 48
3553: IFFALSE 3571
// tmp := tmp ^ Brown ;
3555: LD_ADDR_VAR 0 5
3559: PUSH
3560: LD_VAR 0 5
3564: PUSH
3565: LD_EXP 48
3569: ADD
3570: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3571: LD_ADDR_EXP 49
3575: PUSH
3576: LD_STRING Gladstone
3578: PPUSH
3579: LD_EXP 1
3583: NOT
3584: PPUSH
3585: LD_STRING 13s_
3587: PPUSH
3588: CALL 68795 0 3
3592: ST_TO_ADDR
// if Gladstone then
3593: LD_EXP 49
3597: IFFALSE 3615
// tmp := tmp ^ Gladstone ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_VAR 0 5
3608: PUSH
3609: LD_EXP 49
3613: ADD
3614: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3615: LD_ADDR_EXP 50
3619: PUSH
3620: LD_STRING Houten
3622: PPUSH
3623: LD_EXP 1
3627: NOT
3628: PPUSH
3629: LD_STRING 13s_
3631: PPUSH
3632: CALL 68795 0 3
3636: ST_TO_ADDR
// if Houten then
3637: LD_EXP 50
3641: IFFALSE 3659
// tmp := tmp ^ Houten ;
3643: LD_ADDR_VAR 0 5
3647: PUSH
3648: LD_VAR 0 5
3652: PUSH
3653: LD_EXP 50
3657: ADD
3658: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3659: LD_ADDR_EXP 51
3663: PUSH
3664: LD_STRING Cornel
3666: PPUSH
3667: LD_EXP 1
3671: NOT
3672: PPUSH
3673: LD_STRING 13s_
3675: PPUSH
3676: CALL 68795 0 3
3680: ST_TO_ADDR
// if Cornel then
3681: LD_EXP 51
3685: IFFALSE 3703
// tmp := tmp ^ Cornel ;
3687: LD_ADDR_VAR 0 5
3691: PUSH
3692: LD_VAR 0 5
3696: PUSH
3697: LD_EXP 51
3701: ADD
3702: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3703: LD_ADDR_EXP 52
3707: PUSH
3708: LD_STRING Gary
3710: PPUSH
3711: LD_EXP 1
3715: NOT
3716: PPUSH
3717: LD_STRING 13s_
3719: PPUSH
3720: CALL 68795 0 3
3724: ST_TO_ADDR
// if Gary then
3725: LD_EXP 52
3729: IFFALSE 3747
// tmp := tmp ^ Gary ;
3731: LD_ADDR_VAR 0 5
3735: PUSH
3736: LD_VAR 0 5
3740: PUSH
3741: LD_EXP 52
3745: ADD
3746: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3747: LD_ADDR_EXP 53
3751: PUSH
3752: LD_STRING Frank
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: LD_STRING 13s_
3763: PPUSH
3764: CALL 68795 0 3
3768: ST_TO_ADDR
// if Frank then
3769: LD_EXP 53
3773: IFFALSE 3791
// tmp := tmp ^ Frank ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_VAR 0 5
3784: PUSH
3785: LD_EXP 53
3789: ADD
3790: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3791: LD_ADDR_EXP 54
3795: PUSH
3796: LD_STRING Kikuchi
3798: PPUSH
3799: LD_EXP 1
3803: NOT
3804: PPUSH
3805: LD_STRING 13s_
3807: PPUSH
3808: CALL 68795 0 3
3812: ST_TO_ADDR
// if Kikuchi then
3813: LD_EXP 54
3817: IFFALSE 3835
// tmp := tmp ^ Kikuchi ;
3819: LD_ADDR_VAR 0 5
3823: PUSH
3824: LD_VAR 0 5
3828: PUSH
3829: LD_EXP 54
3833: ADD
3834: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3835: LD_ADDR_EXP 57
3839: PUSH
3840: LD_STRING Mike
3842: PPUSH
3843: LD_EXP 1
3847: NOT
3848: PPUSH
3849: LD_STRING 10c_
3851: PPUSH
3852: CALL 68795 0 3
3856: ST_TO_ADDR
// if Mike then
3857: LD_EXP 57
3861: IFFALSE 3884
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3863: LD_EXP 57
3867: PPUSH
3868: LD_INT 61
3870: PPUSH
3871: LD_INT 89
3873: PPUSH
3874: LD_INT 8
3876: PPUSH
3877: LD_INT 0
3879: PPUSH
3880: CALL_OW 50
// vip := tmp ;
3884: LD_ADDR_EXP 61
3888: PUSH
3889: LD_VAR 0 5
3893: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_STRING 13s_others
3906: PPUSH
3907: CALL_OW 31
3911: UNION
3912: ST_TO_ADDR
// if tmp < 18 then
3913: LD_VAR 0 5
3917: PUSH
3918: LD_INT 18
3920: LESS
3921: IFFALSE 4014
// for i = 1 to 18 - tmp do
3923: LD_ADDR_VAR 0 2
3927: PUSH
3928: DOUBLE
3929: LD_INT 1
3931: DEC
3932: ST_TO_ADDR
3933: LD_INT 18
3935: PUSH
3936: LD_VAR 0 5
3940: MINUS
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4012
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3945: LD_INT 1
3947: PPUSH
3948: LD_VAR 0 2
3952: PUSH
3953: LD_INT 4
3955: MOD
3956: PUSH
3957: LD_INT 1
3959: PLUS
3960: PPUSH
3961: LD_INT 4
3963: PPUSH
3964: CALL_OW 380
// un := CreateHuman ;
3968: LD_ADDR_VAR 0 10
3972: PUSH
3973: CALL_OW 44
3977: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3978: LD_ADDR_VAR 0 5
3982: PUSH
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_VAR 0 10
3992: PPUSH
3993: CALL 106087 0 2
3997: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3998: LD_VAR 0 10
4002: PPUSH
4003: LD_INT 1
4005: PPUSH
4006: CALL_OW 109
// end ;
4010: GO 3942
4012: POP
4013: POP
// depot := HexInfo ( 53 , 94 ) ;
4014: LD_ADDR_VAR 0 6
4018: PUSH
4019: LD_INT 53
4021: PPUSH
4022: LD_INT 94
4024: PPUSH
4025: CALL_OW 428
4029: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4030: LD_ADDR_VAR 0 7
4034: PUSH
4035: LD_INT 56
4037: PPUSH
4038: LD_INT 101
4040: PPUSH
4041: CALL_OW 428
4045: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4046: LD_ADDR_VAR 0 8
4050: PUSH
4051: LD_INT 67
4053: PPUSH
4054: LD_INT 101
4056: PPUSH
4057: CALL_OW 428
4061: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4062: LD_ADDR_VAR 0 9
4066: PUSH
4067: LD_INT 54
4069: PPUSH
4070: LD_INT 85
4072: PPUSH
4073: CALL_OW 428
4077: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4078: LD_ADDR_VAR 0 3
4082: PUSH
4083: LD_VAR 0 8
4087: PUSH
4088: LD_VAR 0 6
4092: PUSH
4093: LD_VAR 0 9
4097: PUSH
4098: LD_VAR 0 7
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: ST_TO_ADDR
// for i in tmp do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: LD_VAR 0 5
4118: PUSH
4119: FOR_IN
4120: IFFALSE 4208
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4122: LD_VAR 0 3
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PPUSH
4131: CALL_OW 313
4135: PUSH
4136: LD_INT 6
4138: EQUAL
4139: IFFALSE 4159
// b := Delete ( b , 1 ) ;
4141: LD_ADDR_VAR 0 3
4145: PUSH
4146: LD_VAR 0 3
4150: PPUSH
4151: LD_INT 1
4153: PPUSH
4154: CALL_OW 3
4158: ST_TO_ADDR
// if b then
4159: LD_VAR 0 3
4163: IFFALSE 4185
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4165: LD_VAR 0 2
4169: PPUSH
4170: LD_VAR 0 3
4174: PUSH
4175: LD_INT 1
4177: ARRAY
4178: PPUSH
4179: CALL_OW 52
4183: GO 4206
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4185: LD_VAR 0 2
4189: PPUSH
4190: LD_INT 61
4192: PPUSH
4193: LD_INT 89
4195: PPUSH
4196: LD_INT 8
4198: PPUSH
4199: LD_INT 0
4201: PPUSH
4202: CALL_OW 50
// end ;
4206: GO 4119
4208: POP
4209: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 1
4218: PPUSH
4219: LD_INT 12
4221: PPUSH
4222: LD_INT 100
4224: PPUSH
4225: CALL 73635 0 5
// veh := CreateVehicle ;
4229: LD_ADDR_VAR 0 4
4233: PUSH
4234: CALL_OW 45
4238: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4239: LD_VAR 0 4
4243: PPUSH
4244: LD_INT 4
4246: PPUSH
4247: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4251: LD_VAR 0 4
4255: PPUSH
4256: LD_INT 49
4258: PPUSH
4259: LD_INT 88
4261: PPUSH
4262: LD_INT 0
4264: PPUSH
4265: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4269: LD_VAR 0 4
4273: PPUSH
4274: LD_INT 1
4276: PPUSH
4277: LD_INT 100
4279: PPUSH
4280: CALL_OW 290
// uc_side := 0 ;
4284: LD_ADDR_OWVAR 20
4288: PUSH
4289: LD_INT 0
4291: ST_TO_ADDR
// uc_nation := 0 ;
4292: LD_ADDR_OWVAR 21
4296: PUSH
4297: LD_INT 0
4299: ST_TO_ADDR
// for i := 1 to 3 do
4300: LD_ADDR_VAR 0 2
4304: PUSH
4305: DOUBLE
4306: LD_INT 1
4308: DEC
4309: ST_TO_ADDR
4310: LD_INT 3
4312: PUSH
4313: FOR_TO
4314: IFFALSE 4345
// begin InitHc ;
4316: CALL_OW 19
// hc_class := class_apeman ;
4320: LD_ADDR_OWVAR 28
4324: PUSH
4325: LD_INT 12
4327: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4328: CALL_OW 44
4332: PPUSH
4333: LD_INT 13
4335: PPUSH
4336: LD_INT 0
4338: PPUSH
4339: CALL_OW 49
// end ;
4343: GO 4313
4345: POP
4346: POP
// end ; end_of_file
4347: LD_VAR 0 1
4351: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4352: LD_INT 0
4354: PPUSH
4355: PPUSH
4356: PPUSH
4357: PPUSH
4358: PPUSH
// side := 8 ;
4359: LD_ADDR_VAR 0 3
4363: PUSH
4364: LD_INT 8
4366: ST_TO_ADDR
// uc_side := side ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_VAR 0 3
4376: ST_TO_ADDR
// uc_nation := 2 ;
4377: LD_ADDR_OWVAR 21
4381: PUSH
4382: LD_INT 2
4384: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4385: LD_ADDR_VAR 0 2
4389: PUSH
4390: LD_INT 22
4392: PUSH
4393: LD_VAR 0 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 21
4404: PUSH
4405: LD_INT 3
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PPUSH
4416: CALL_OW 69
4420: PUSH
4421: FOR_IN
4422: IFFALSE 4438
// SetBLevel ( i , 10 ) ;
4424: LD_VAR 0 2
4428: PPUSH
4429: LD_INT 10
4431: PPUSH
4432: CALL_OW 241
4436: GO 4421
4438: POP
4439: POP
// if KurtStatus then
4440: LD_EXP 3
4444: IFFALSE 4467
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4446: LD_ADDR_EXP 62
4450: PUSH
4451: LD_STRING Kurt
4453: PPUSH
4454: LD_INT 0
4456: PPUSH
4457: LD_STRING 
4459: PPUSH
4460: CALL 68795 0 3
4464: ST_TO_ADDR
4465: GO 4489
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4467: LD_ADDR_EXP 62
4471: PUSH
4472: LD_STRING AltKurt
4474: PPUSH
4475: LD_EXP 1
4479: NOT
4480: PPUSH
4481: LD_STRING 
4483: PPUSH
4484: CALL 68795 0 3
4488: ST_TO_ADDR
// if not Kurt then
4489: LD_EXP 62
4493: NOT
4494: IFFALSE 4520
// begin InitHc ;
4496: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4500: LD_INT 1
4502: PPUSH
4503: LD_INT 10
4505: PPUSH
4506: CALL_OW 381
// Kurt := CreateHuman ;
4510: LD_ADDR_EXP 62
4514: PUSH
4515: CALL_OW 44
4519: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4520: LD_EXP 62
4524: PPUSH
4525: LD_INT 324
4527: PPUSH
4528: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4532: LD_ADDR_EXP 63
4536: PUSH
4537: LD_STRING Kozlov
4539: PPUSH
4540: LD_INT 0
4542: PPUSH
4543: LD_STRING 
4545: PPUSH
4546: CALL 68795 0 3
4550: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4551: LD_EXP 63
4555: PPUSH
4556: LD_INT 22
4558: PUSH
4559: LD_INT 8
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 23
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 30
4578: PUSH
4579: LD_INT 8
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: LIST
4590: PPUSH
4591: CALL_OW 69
4595: PUSH
4596: LD_INT 1
4598: ARRAY
4599: PPUSH
4600: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4604: LD_EXP 63
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 10
4614: PPUSH
4615: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4619: LD_EXP 63
4623: PPUSH
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 10
4629: PPUSH
4630: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4634: LD_ADDR_VAR 0 5
4638: PUSH
4639: LD_INT 22
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 30
4653: PUSH
4654: LD_INT 32
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: PUSH
4661: LD_INT 58
4663: PUSH
4664: EMPTY
4665: LIST
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: LIST
4671: PPUSH
4672: CALL_OW 69
4676: ST_TO_ADDR
// for i = 1 to 10 do
4677: LD_ADDR_VAR 0 2
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_INT 10
4689: PUSH
4690: FOR_TO
4691: IFFALSE 4763
// begin uc_nation := nation_nature ;
4693: LD_ADDR_OWVAR 21
4697: PUSH
4698: LD_INT 0
4700: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4701: LD_ADDR_OWVAR 28
4705: PUSH
4706: LD_INT 15
4708: ST_TO_ADDR
// hc_gallery :=  ;
4709: LD_ADDR_OWVAR 33
4713: PUSH
4714: LD_STRING 
4716: ST_TO_ADDR
// hc_name :=  ;
4717: LD_ADDR_OWVAR 26
4721: PUSH
4722: LD_STRING 
4724: ST_TO_ADDR
// un := CreateHuman ;
4725: LD_ADDR_VAR 0 4
4729: PUSH
4730: CALL_OW 44
4734: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4735: LD_VAR 0 4
4739: PPUSH
4740: LD_VAR 0 5
4744: PUSH
4745: LD_VAR 0 5
4749: PUSH
4750: LD_VAR 0 2
4754: MINUS
4755: ARRAY
4756: PPUSH
4757: CALL_OW 52
// end ;
4761: GO 4690
4763: POP
4764: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4765: LD_ADDR_VAR 0 5
4769: PUSH
4770: LD_STRING 12_kurt_squad
4772: PPUSH
4773: CALL_OW 31
4777: ST_TO_ADDR
// if tmp then
4778: LD_VAR 0 5
4782: IFFALSE 4816
// for i in tmp do
4784: LD_ADDR_VAR 0 2
4788: PUSH
4789: LD_VAR 0 5
4793: PUSH
4794: FOR_IN
4795: IFFALSE 4814
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4797: LD_VAR 0 2
4801: PPUSH
4802: LD_INT 5
4804: PPUSH
4805: LD_INT 0
4807: PPUSH
4808: CALL_OW 49
4812: GO 4794
4814: POP
4815: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4816: LD_INT 324
4818: PPUSH
4819: LD_INT 5
4821: PPUSH
4822: LD_STRING 
4824: PPUSH
4825: LD_INT 8
4827: PUSH
4828: LD_INT 9
4830: PUSH
4831: LD_INT 10
4833: PUSH
4834: LD_INT 10
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: PUSH
4843: LD_OWVAR 67
4847: ARRAY
4848: PPUSH
4849: LD_INT 3000
4851: PUSH
4852: LD_INT 500
4854: PUSH
4855: LD_INT 150
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: LIST
4862: PPUSH
4863: LD_INT 16
4865: PUSH
4866: LD_INT 6
4868: PUSH
4869: LD_INT 6
4871: PUSH
4872: LD_INT 8
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL 77079 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4885: LD_ADDR_EXP 100
4889: PUSH
4890: LD_EXP 100
4894: PPUSH
4895: LD_INT 3
4897: PPUSH
4898: LD_INT 22
4900: PUSH
4901: LD_VAR 0 3
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 23
4912: PUSH
4913: LD_INT 2
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: LD_INT 3
4922: PUSH
4923: LD_INT 21
4925: PUSH
4926: LD_INT 2
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: LIST
4941: PPUSH
4942: CALL_OW 69
4946: PUSH
4947: LD_EXP 62
4951: DIFF
4952: PPUSH
4953: CALL_OW 1
4957: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4958: LD_INT 1
4960: PPUSH
4961: LD_INT 7
4963: PPUSH
4964: CALL_OW 383
// hc_name := Ali Hadrach ;
4968: LD_ADDR_OWVAR 26
4972: PUSH
4973: LD_STRING Ali Hadrach
4975: ST_TO_ADDR
// hc_face_number := 31 ;
4976: LD_ADDR_OWVAR 34
4980: PUSH
4981: LD_INT 31
4983: ST_TO_ADDR
// Friend := CreateHuman ;
4984: LD_ADDR_EXP 64
4988: PUSH
4989: CALL_OW 44
4993: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4994: LD_INT 14
4996: PPUSH
4997: LD_INT 3
4999: PPUSH
5000: LD_INT 1
5002: PPUSH
5003: LD_INT 29
5005: PPUSH
5006: LD_INT 100
5008: PPUSH
5009: CALL 73635 0 5
// powellBomb := CreateVehicle ;
5013: LD_ADDR_EXP 65
5017: PUSH
5018: CALL_OW 45
5022: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5023: LD_EXP 65
5027: PPUSH
5028: LD_INT 90
5030: PPUSH
5031: LD_INT 51
5033: PPUSH
5034: LD_INT 0
5036: PPUSH
5037: CALL_OW 48
// end ;
5041: LD_VAR 0 1
5045: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
// if IsLive ( kozlov_fac ) then
5051: LD_INT 332
5053: PPUSH
5054: CALL_OW 300
5058: IFFALSE 5062
// exit ;
5060: GO 5629
// ComExitBuilding ( Kozlov ) ;
5062: LD_EXP 63
5066: PPUSH
5067: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5071: LD_EXP 63
5075: PPUSH
5076: CALL_OW 257
5080: PUSH
5081: LD_INT 2
5083: NONEQUAL
5084: IFFALSE 5119
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5086: LD_EXP 63
5090: PPUSH
5091: LD_INT 324
5093: PPUSH
5094: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5098: LD_EXP 63
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5110: LD_EXP 63
5114: PPUSH
5115: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5119: LD_EXP 63
5123: PPUSH
5124: LD_INT 2
5126: PPUSH
5127: LD_INT 93
5129: PPUSH
5130: LD_INT 32
5132: PPUSH
5133: LD_INT 3
5135: PPUSH
5136: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5140: LD_INT 35
5142: PPUSH
5143: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5147: LD_INT 22
5149: PUSH
5150: LD_INT 8
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 30
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 23
5169: PUSH
5170: LD_INT 3
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 57
5179: PUSH
5180: EMPTY
5181: LIST
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: CALL_OW 69
5193: IFFALSE 5140
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5195: LD_ADDR_VAR 0 2
5199: PUSH
5200: LD_INT 22
5202: PUSH
5203: LD_INT 8
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 30
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 23
5222: PUSH
5223: LD_INT 3
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 57
5232: PUSH
5233: EMPTY
5234: LIST
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: PPUSH
5242: CALL_OW 69
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5251: LD_INT 22
5253: PUSH
5254: LD_INT 8
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 23
5263: PUSH
5264: LD_INT 3
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 30
5273: PUSH
5274: LD_INT 21
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: LIST
5285: PPUSH
5286: CALL_OW 69
5290: NOT
5291: IFFALSE 5369
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5293: LD_EXP 63
5297: PPUSH
5298: LD_INT 21
5300: PPUSH
5301: LD_INT 97
5303: PPUSH
5304: LD_INT 36
5306: PPUSH
5307: LD_INT 5
5309: PPUSH
5310: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5314: LD_INT 35
5316: PPUSH
5317: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5321: LD_INT 22
5323: PUSH
5324: LD_INT 8
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 23
5333: PUSH
5334: LD_INT 3
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 30
5343: PUSH
5344: LD_INT 21
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: PUSH
5351: LD_INT 57
5353: PUSH
5354: EMPTY
5355: LIST
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: IFFALSE 5314
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5369: LD_INT 22
5371: PUSH
5372: LD_INT 8
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 23
5381: PUSH
5382: LD_INT 3
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: LD_INT 30
5391: PUSH
5392: LD_INT 18
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL_OW 69
5408: NOT
5409: IFFALSE 5487
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5411: LD_EXP 63
5415: PPUSH
5416: LD_INT 18
5418: PPUSH
5419: LD_INT 89
5421: PPUSH
5422: LD_INT 32
5424: PPUSH
5425: LD_INT 1
5427: PPUSH
5428: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5432: LD_INT 35
5434: PPUSH
5435: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5439: LD_INT 22
5441: PUSH
5442: LD_INT 8
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 23
5451: PUSH
5452: LD_INT 3
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 30
5461: PUSH
5462: LD_INT 18
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 57
5471: PUSH
5472: EMPTY
5473: LIST
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: PPUSH
5481: CALL_OW 69
5485: IFFALSE 5432
// end ; lab := kozlov_lab ;
5487: LD_ADDR_VAR 0 3
5491: PUSH
5492: LD_INT 336
5494: ST_TO_ADDR
// if not lab then
5495: LD_VAR 0 3
5499: NOT
5500: IFFALSE 5504
// exit ;
5502: GO 5629
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5504: LD_EXP 63
5508: PPUSH
5509: LD_VAR 0 3
5513: PUSH
5514: LD_INT 1
5516: ARRAY
5517: PPUSH
5518: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5522: LD_EXP 63
5526: PPUSH
5527: LD_INT 4
5529: PPUSH
5530: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5534: LD_VAR 0 3
5538: PUSH
5539: LD_INT 1
5541: ARRAY
5542: PPUSH
5543: LD_INT 25
5545: PPUSH
5546: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5550: LD_INT 35
5552: PPUSH
5553: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5557: LD_INT 25
5559: PPUSH
5560: LD_INT 8
5562: PPUSH
5563: CALL_OW 321
5567: PUSH
5568: LD_INT 2
5570: EQUAL
5571: IFFALSE 5550
// ComExitBuilding ( Kozlov ) ;
5573: LD_EXP 63
5577: PPUSH
5578: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5582: LD_EXP 63
5586: PPUSH
5587: LD_VAR 0 2
5591: PPUSH
5592: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5596: LD_EXP 63
5600: PPUSH
5601: LD_INT 3
5603: PPUSH
5604: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5608: LD_VAR 0 2
5612: PPUSH
5613: LD_INT 23
5615: PPUSH
5616: LD_INT 3
5618: PPUSH
5619: LD_INT 1
5621: PPUSH
5622: LD_INT 48
5624: PPUSH
5625: CALL_OW 125
// end ;
5629: LD_VAR 0 1
5633: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5634: LD_EXP 22
5638: NOT
5639: PUSH
5640: LD_EXP 15
5644: PUSH
5645: LD_INT 6
5647: GREATEREQUAL
5648: AND
5649: IFFALSE 5730
5651: GO 5653
5653: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 3
5659: PPUSH
5660: CALL 62506 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5664: LD_INT 3
5666: PPUSH
5667: LD_INT 14
5669: PUSH
5670: LD_INT 1
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: LD_INT 28
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: LD_INT 1
5693: PUSH
5694: LD_INT 28
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: LD_INT 14
5705: PUSH
5706: LD_INT 1
5708: PUSH
5709: LD_INT 1
5711: PUSH
5712: LD_INT 28
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: PPUSH
5726: CALL 62369 0 2
// end ;
5730: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5731: LD_EXP 22
5735: NOT
5736: PUSH
5737: LD_EXP 15
5741: PUSH
5742: LD_INT 6
5744: GREATEREQUAL
5745: AND
5746: PUSH
5747: LD_INT 3
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: CALL 63787 0 2
5757: NOT
5758: AND
5759: IFFALSE 6633
5761: GO 5763
5763: DISABLE
5764: LD_INT 0
5766: PPUSH
5767: PPUSH
5768: PPUSH
// begin enable ;
5769: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5770: LD_INT 22
5772: PUSH
5773: LD_INT 8
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 23
5782: PUSH
5783: LD_INT 2
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 30
5792: PUSH
5793: LD_INT 3
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PPUSH
5805: CALL_OW 69
5809: NOT
5810: IFFALSE 5814
// exit ;
5812: GO 6633
// if Prob ( 40 ) then
5814: LD_INT 40
5816: PPUSH
5817: CALL_OW 13
5821: IFFALSE 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5823: LD_INT 3
5825: PPUSH
5826: LD_INT 14
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 28
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: LIST
5843: PUSH
5844: LD_INT 14
5846: PUSH
5847: LD_INT 1
5849: PUSH
5850: LD_INT 2
5852: PUSH
5853: LD_INT 28
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 14
5864: PUSH
5865: LD_INT 1
5867: PUSH
5868: LD_INT 2
5870: PUSH
5871: LD_INT 28
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: PUSH
5880: LD_INT 14
5882: PUSH
5883: LD_INT 1
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: LD_INT 28
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: PUSH
5898: LD_INT 14
5900: PUSH
5901: LD_INT 1
5903: PUSH
5904: LD_INT 2
5906: PUSH
5907: LD_INT 28
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 14
5918: PUSH
5919: LD_INT 1
5921: PUSH
5922: LD_INT 2
5924: PUSH
5925: LD_INT 26
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL 62369 0 2
// end else
5946: GO 6155
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5948: LD_INT 3
5950: PPUSH
5951: LD_INT 14
5953: PUSH
5954: LD_INT 1
5956: PUSH
5957: LD_INT 2
5959: PUSH
5960: LD_INT 27
5962: PUSH
5963: LD_INT 26
5965: PUSH
5966: LD_INT 26
5968: PUSH
5969: LD_INT 28
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_OWVAR 67
5982: ARRAY
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: PUSH
5990: LD_INT 14
5992: PUSH
5993: LD_INT 1
5995: PUSH
5996: LD_INT 2
5998: PUSH
5999: LD_INT 27
6001: PUSH
6002: LD_INT 26
6004: PUSH
6005: LD_INT 26
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: LD_OWVAR 67
6021: ARRAY
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_INT 14
6031: PUSH
6032: LD_INT 1
6034: PUSH
6035: LD_INT 2
6037: PUSH
6038: LD_INT 26
6040: PUSH
6041: LD_INT 26
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 29
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: LIST
6054: LIST
6055: PUSH
6056: LD_OWVAR 67
6060: ARRAY
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 13
6070: PUSH
6071: LD_INT 1
6073: PUSH
6074: LD_INT 2
6076: PUSH
6077: LD_INT 26
6079: PUSH
6080: LD_INT 29
6082: PUSH
6083: LD_INT 29
6085: PUSH
6086: LD_INT 29
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: PUSH
6095: LD_OWVAR 67
6099: ARRAY
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 13
6109: PUSH
6110: LD_INT 1
6112: PUSH
6113: LD_INT 2
6115: PUSH
6116: LD_INT 29
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 14
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 26
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: LIST
6150: PPUSH
6151: CALL 62369 0 2
// end ; repeat wait ( 0 0$1 ) ;
6155: LD_INT 35
6157: PPUSH
6158: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6162: LD_INT 3
6164: PPUSH
6165: LD_INT 1
6167: PPUSH
6168: CALL 63787 0 2
6172: PUSH
6173: LD_INT 6
6175: GREATEREQUAL
6176: IFFALSE 6155
// wait ( 0 0$30 ) ;
6178: LD_INT 1050
6180: PPUSH
6181: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6185: LD_ADDR_VAR 0 2
6189: PUSH
6190: LD_INT 3
6192: PPUSH
6193: LD_INT 1
6195: PPUSH
6196: CALL 63787 0 2
6200: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6201: LD_ADDR_EXP 119
6205: PUSH
6206: LD_EXP 119
6210: PPUSH
6211: LD_INT 3
6213: PPUSH
6214: LD_EXP 119
6218: PUSH
6219: LD_INT 3
6221: ARRAY
6222: PUSH
6223: LD_VAR 0 2
6227: DIFF
6228: PPUSH
6229: CALL_OW 1
6233: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6234: LD_ADDR_VAR 0 3
6238: PUSH
6239: LD_INT 0
6241: PPUSH
6242: LD_INT 2
6244: PPUSH
6245: CALL_OW 12
6249: ST_TO_ADDR
// if target then
6250: LD_VAR 0 3
6254: IFFALSE 6391
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6256: LD_ADDR_VAR 0 2
6260: PUSH
6261: LD_VAR 0 2
6265: PPUSH
6266: LD_INT 24
6268: PUSH
6269: LD_INT 250
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: PPUSH
6276: CALL_OW 72
6280: ST_TO_ADDR
// if not tmp then
6281: LD_VAR 0 2
6285: NOT
6286: IFFALSE 6290
// break ;
6288: GO 6389
// for i in tmp do
6290: LD_ADDR_VAR 0 1
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: FOR_IN
6301: IFFALSE 6341
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6303: LD_VAR 0 1
6307: PPUSH
6308: LD_INT 89
6310: PPUSH
6311: LD_INT 71
6313: PPUSH
6314: CALL_OW 297
6318: PUSH
6319: LD_INT 9
6321: GREATER
6322: IFFALSE 6339
// ComMoveXY ( i , 89 , 71 ) ;
6324: LD_VAR 0 1
6328: PPUSH
6329: LD_INT 89
6331: PPUSH
6332: LD_INT 71
6334: PPUSH
6335: CALL_OW 111
6339: GO 6300
6341: POP
6342: POP
// wait ( 0 0$1 ) ;
6343: LD_INT 35
6345: PPUSH
6346: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6350: LD_VAR 0 2
6354: PPUSH
6355: LD_INT 92
6357: PUSH
6358: LD_INT 89
6360: PUSH
6361: LD_INT 71
6363: PUSH
6364: LD_INT 9
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PPUSH
6373: CALL_OW 72
6377: PUSH
6378: LD_VAR 0 2
6382: PUSH
6383: LD_INT 1
6385: MINUS
6386: GREATEREQUAL
6387: IFFALSE 6256
// end else
6389: GO 6524
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 2
6400: PPUSH
6401: LD_INT 24
6403: PUSH
6404: LD_INT 250
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PPUSH
6411: CALL_OW 72
6415: ST_TO_ADDR
// if not tmp then
6416: LD_VAR 0 2
6420: NOT
6421: IFFALSE 6425
// break ;
6423: GO 6524
// for i in tmp do
6425: LD_ADDR_VAR 0 1
6429: PUSH
6430: LD_VAR 0 2
6434: PUSH
6435: FOR_IN
6436: IFFALSE 6476
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6438: LD_VAR 0 1
6442: PPUSH
6443: LD_INT 125
6445: PPUSH
6446: LD_INT 129
6448: PPUSH
6449: CALL_OW 297
6453: PUSH
6454: LD_INT 9
6456: GREATER
6457: IFFALSE 6474
// ComMoveXY ( i , 125 , 129 ) ;
6459: LD_VAR 0 1
6463: PPUSH
6464: LD_INT 125
6466: PPUSH
6467: LD_INT 129
6469: PPUSH
6470: CALL_OW 111
6474: GO 6435
6476: POP
6477: POP
// wait ( 0 0$1 ) ;
6478: LD_INT 35
6480: PPUSH
6481: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6485: LD_VAR 0 2
6489: PPUSH
6490: LD_INT 92
6492: PUSH
6493: LD_INT 125
6495: PUSH
6496: LD_INT 129
6498: PUSH
6499: LD_INT 9
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PPUSH
6508: CALL_OW 72
6512: PUSH
6513: LD_VAR 0 2
6517: PUSH
6518: LD_INT 1
6520: MINUS
6521: GREATEREQUAL
6522: IFFALSE 6391
// end ; repeat wait ( 0 0$1 ) ;
6524: LD_INT 35
6526: PPUSH
6527: CALL_OW 67
// for i in tmp do
6531: LD_ADDR_VAR 0 1
6535: PUSH
6536: LD_VAR 0 2
6540: PUSH
6541: FOR_IN
6542: IFFALSE 6624
// begin if GetLives ( i ) > 251 then
6544: LD_VAR 0 1
6548: PPUSH
6549: CALL_OW 256
6553: PUSH
6554: LD_INT 251
6556: GREATER
6557: IFFALSE 6595
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 81
6566: PUSH
6567: LD_INT 8
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PPUSH
6574: CALL_OW 69
6578: PPUSH
6579: LD_VAR 0 1
6583: PPUSH
6584: CALL_OW 74
6588: PPUSH
6589: CALL_OW 115
6593: GO 6622
// if IsDead ( i ) then
6595: LD_VAR 0 1
6599: PPUSH
6600: CALL_OW 301
6604: IFFALSE 6622
// tmp := tmp diff i ;
6606: LD_ADDR_VAR 0 2
6610: PUSH
6611: LD_VAR 0 2
6615: PUSH
6616: LD_VAR 0 1
6620: DIFF
6621: ST_TO_ADDR
// end ;
6622: GO 6541
6624: POP
6625: POP
// until not tmp ;
6626: LD_VAR 0 2
6630: NOT
6631: IFFALSE 6524
// end ;
6633: PPOPN 3
6635: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6636: LD_EXP 22
6640: NOT
6641: PUSH
6642: LD_EXP 15
6646: PUSH
6647: LD_INT 6
6649: GREATEREQUAL
6650: AND
6651: PUSH
6652: LD_OWVAR 67
6656: PUSH
6657: LD_INT 1
6659: GREATER
6660: AND
6661: IFFALSE 7194
6663: GO 6665
6665: DISABLE
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
// begin enable ;
6671: ENABLE
// tmp := [ ] ;
6672: LD_ADDR_VAR 0 3
6676: PUSH
6677: EMPTY
6678: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6679: LD_ADDR_VAR 0 1
6683: PUSH
6684: DOUBLE
6685: LD_INT 1
6687: DEC
6688: ST_TO_ADDR
6689: LD_INT 4
6691: PUSH
6692: LD_INT 6
6694: PUSH
6695: LD_INT 7
6697: PUSH
6698: LD_INT 8
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: PUSH
6707: LD_OWVAR 67
6711: ARRAY
6712: PUSH
6713: FOR_TO
6714: IFFALSE 6874
// begin uc_side := 8 ;
6716: LD_ADDR_OWVAR 20
6720: PUSH
6721: LD_INT 8
6723: ST_TO_ADDR
// uc_nation := 2 ;
6724: LD_ADDR_OWVAR 21
6728: PUSH
6729: LD_INT 2
6731: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6732: LD_INT 13
6734: PUSH
6735: LD_INT 14
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 1
6744: PPUSH
6745: LD_INT 2
6747: PPUSH
6748: CALL_OW 12
6752: ARRAY
6753: PPUSH
6754: LD_INT 1
6756: PPUSH
6757: LD_INT 5
6759: PPUSH
6760: LD_INT 27
6762: PUSH
6763: LD_INT 28
6765: PUSH
6766: LD_INT 26
6768: PUSH
6769: LD_INT 25
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 4
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: LD_INT 88
6792: PPUSH
6793: CALL 73635 0 5
// un := CreateVehicle ;
6797: LD_ADDR_VAR 0 2
6801: PUSH
6802: CALL_OW 45
6806: ST_TO_ADDR
// tmp := tmp ^ un ;
6807: LD_ADDR_VAR 0 3
6811: PUSH
6812: LD_VAR 0 3
6816: PUSH
6817: LD_VAR 0 2
6821: ADD
6822: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6823: LD_VAR 0 2
6827: PPUSH
6828: LD_INT 3
6830: PPUSH
6831: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6835: LD_VAR 0 2
6839: PPUSH
6840: LD_INT 30
6842: PPUSH
6843: LD_INT 0
6845: PPUSH
6846: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6850: LD_VAR 0 2
6854: PPUSH
6855: LD_INT 16
6857: PPUSH
6858: LD_INT 11
6860: PPUSH
6861: CALL_OW 111
// wait ( 0 0$2 ) ;
6865: LD_INT 70
6867: PPUSH
6868: CALL_OW 67
// end ;
6872: GO 6713
6874: POP
6875: POP
// for i = 1 to Difficulty do
6876: LD_ADDR_VAR 0 1
6880: PUSH
6881: DOUBLE
6882: LD_INT 1
6884: DEC
6885: ST_TO_ADDR
6886: LD_OWVAR 67
6890: PUSH
6891: FOR_TO
6892: IFFALSE 7021
// begin uc_side := 8 ;
6894: LD_ADDR_OWVAR 20
6898: PUSH
6899: LD_INT 8
6901: ST_TO_ADDR
// uc_nation := 2 ;
6902: LD_ADDR_OWVAR 21
6906: PUSH
6907: LD_INT 2
6909: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6910: LD_INT 0
6912: PPUSH
6913: LD_INT 8
6915: PPUSH
6916: LD_INT 8
6918: PUSH
6919: LD_INT 8
6921: PUSH
6922: LD_INT 9
6924: PUSH
6925: LD_INT 10
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_OWVAR 67
6938: ARRAY
6939: PPUSH
6940: CALL_OW 380
// un := CreateHuman ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: CALL_OW 44
6953: ST_TO_ADDR
// tmp := tmp ^ un ;
6954: LD_ADDR_VAR 0 3
6958: PUSH
6959: LD_VAR 0 3
6963: PUSH
6964: LD_VAR 0 2
6968: ADD
6969: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 3
6977: PPUSH
6978: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6982: LD_VAR 0 2
6986: PPUSH
6987: LD_INT 30
6989: PPUSH
6990: LD_INT 0
6992: PPUSH
6993: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6997: LD_VAR 0 2
7001: PPUSH
7002: LD_INT 16
7004: PPUSH
7005: LD_INT 11
7007: PPUSH
7008: CALL_OW 111
// wait ( 0 0$2 ) ;
7012: LD_INT 70
7014: PPUSH
7015: CALL_OW 67
// end ;
7019: GO 6891
7021: POP
7022: POP
// repeat wait ( 0 0$1 ) ;
7023: LD_INT 35
7025: PPUSH
7026: CALL_OW 67
// if legionDestroyed then
7030: LD_EXP 22
7034: IFFALSE 7038
// exit ;
7036: GO 7194
// for i in tmp do
7038: LD_ADDR_VAR 0 1
7042: PUSH
7043: LD_VAR 0 3
7047: PUSH
7048: FOR_IN
7049: IFFALSE 7185
// begin if GetLives ( i ) > 250 then
7051: LD_VAR 0 1
7055: PPUSH
7056: CALL_OW 256
7060: PUSH
7061: LD_INT 250
7063: GREATER
7064: IFFALSE 7156
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7066: LD_INT 81
7068: PUSH
7069: LD_INT 8
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 91
7078: PUSH
7079: LD_VAR 0 1
7083: PUSH
7084: LD_INT 10
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL_OW 69
7100: NOT
7101: IFFALSE 7120
// ComAgressiveMove ( i , 67 , 110 ) else
7103: LD_VAR 0 1
7107: PPUSH
7108: LD_INT 67
7110: PPUSH
7111: LD_INT 110
7113: PPUSH
7114: CALL_OW 114
7118: GO 7154
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7120: LD_VAR 0 1
7124: PPUSH
7125: LD_INT 81
7127: PUSH
7128: LD_INT 8
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PPUSH
7135: CALL_OW 69
7139: PPUSH
7140: LD_VAR 0 1
7144: PPUSH
7145: CALL_OW 74
7149: PPUSH
7150: CALL_OW 115
// end else
7154: GO 7183
// if IsDead ( i ) then
7156: LD_VAR 0 1
7160: PPUSH
7161: CALL_OW 301
7165: IFFALSE 7183
// tmp := tmp diff i ;
7167: LD_ADDR_VAR 0 3
7171: PUSH
7172: LD_VAR 0 3
7176: PUSH
7177: LD_VAR 0 1
7181: DIFF
7182: ST_TO_ADDR
// end ;
7183: GO 7048
7185: POP
7186: POP
// until not tmp ;
7187: LD_VAR 0 3
7191: NOT
7192: IFFALSE 7023
// end ; end_of_file
7194: PPOPN 3
7196: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7197: LD_INT 0
7199: PPUSH
7200: PPUSH
7201: PPUSH
7202: PPUSH
7203: PPUSH
7204: PPUSH
7205: PPUSH
7206: PPUSH
7207: PPUSH
7208: PPUSH
// side := 3 ;
7209: LD_ADDR_VAR 0 6
7213: PUSH
7214: LD_INT 3
7216: ST_TO_ADDR
// uc_side := side ;
7217: LD_ADDR_OWVAR 20
7221: PUSH
7222: LD_VAR 0 6
7226: ST_TO_ADDR
// uc_nation := 3 ;
7227: LD_ADDR_OWVAR 21
7231: PUSH
7232: LD_INT 3
7234: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7235: LD_ADDR_VAR 0 2
7239: PUSH
7240: LD_INT 22
7242: PUSH
7243: LD_VAR 0 6
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 21
7254: PUSH
7255: LD_INT 3
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: FOR_IN
7272: IFFALSE 7288
// SetBLevel ( i , 10 ) ;
7274: LD_VAR 0 2
7278: PPUSH
7279: LD_INT 10
7281: PPUSH
7282: CALL_OW 241
7286: GO 7271
7288: POP
7289: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7290: LD_ADDR_VAR 0 10
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 30
7309: PUSH
7310: LD_INT 34
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PPUSH
7321: CALL_OW 69
7325: ST_TO_ADDR
// if teleport then
7326: LD_VAR 0 10
7330: IFFALSE 7351
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7332: LD_VAR 0 10
7336: PUSH
7337: LD_INT 1
7339: ARRAY
7340: PPUSH
7341: LD_INT 123
7343: PPUSH
7344: LD_INT 122
7346: PPUSH
7347: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7351: LD_ADDR_EXP 66
7355: PUSH
7356: LD_STRING Platonov
7358: PPUSH
7359: CALL_OW 25
7363: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7364: LD_ADDR_EXP 67
7368: PUSH
7369: LD_STRING Kovalyuk
7371: PPUSH
7372: CALL_OW 25
7376: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7377: LD_ADDR_EXP 69
7381: PUSH
7382: LD_STRING Yakotich
7384: PPUSH
7385: LD_EXP 1
7389: NOT
7390: PPUSH
7391: LD_STRING 09_
7393: PPUSH
7394: CALL 68795 0 3
7398: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7399: LD_ADDR_EXP 68
7403: PUSH
7404: LD_STRING Bystrov
7406: PPUSH
7407: CALL_OW 25
7411: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7412: LD_ADDR_EXP 70
7416: PUSH
7417: LD_STRING Gleb
7419: PPUSH
7420: CALL_OW 25
7424: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7425: LD_STRING 03_Cornel
7427: PPUSH
7428: CALL_OW 28
7432: IFFALSE 7480
// begin Bierezov := NewCharacter ( Mikhail ) ;
7434: LD_ADDR_EXP 71
7438: PUSH
7439: LD_STRING Mikhail
7441: PPUSH
7442: CALL_OW 25
7446: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7447: LD_EXP 71
7451: PPUSH
7452: LD_INT 197
7454: PPUSH
7455: LD_INT 111
7457: PPUSH
7458: LD_INT 9
7460: PPUSH
7461: LD_INT 0
7463: PPUSH
7464: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7468: LD_EXP 71
7472: PPUSH
7473: LD_INT 3
7475: PPUSH
7476: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7480: LD_EXP 66
7484: PPUSH
7485: LD_INT 126
7487: PPUSH
7488: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7492: LD_EXP 67
7496: PPUSH
7497: LD_INT 134
7499: PPUSH
7500: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7504: LD_EXP 69
7508: PPUSH
7509: LD_INT 197
7511: PPUSH
7512: LD_INT 111
7514: PPUSH
7515: LD_INT 9
7517: PPUSH
7518: LD_INT 0
7520: PPUSH
7521: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7525: LD_EXP 68
7529: PPUSH
7530: LD_INT 197
7532: PPUSH
7533: LD_INT 111
7535: PPUSH
7536: LD_INT 9
7538: PPUSH
7539: LD_INT 0
7541: PPUSH
7542: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7546: LD_EXP 70
7550: PPUSH
7551: LD_INT 197
7553: PPUSH
7554: LD_INT 111
7556: PPUSH
7557: LD_INT 9
7559: PPUSH
7560: LD_INT 0
7562: PPUSH
7563: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7567: LD_ADDR_VAR 0 5
7571: PUSH
7572: LD_INT 126
7574: PPUSH
7575: LD_INT 4
7577: PPUSH
7578: LD_STRING zhukov
7580: PPUSH
7581: LD_INT 9
7583: PUSH
7584: LD_INT 10
7586: PUSH
7587: LD_INT 10
7589: PUSH
7590: LD_INT 10
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: LD_OWVAR 67
7603: ARRAY
7604: PPUSH
7605: LD_INT 90000
7607: PUSH
7608: LD_INT 1000
7610: PUSH
7611: LD_INT 300
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: PPUSH
7619: LD_INT 18
7621: PUSH
7622: LD_INT 8
7624: PUSH
7625: LD_INT 13
7627: PUSH
7628: LD_INT 8
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: LIST
7636: PPUSH
7637: CALL 77079 0 6
7641: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7642: LD_ADDR_EXP 100
7646: PUSH
7647: LD_EXP 100
7651: PPUSH
7652: LD_INT 2
7654: PPUSH
7655: LD_VAR 0 5
7659: PUSH
7660: LD_EXP 69
7664: PUSH
7665: LD_EXP 68
7669: PUSH
7670: LD_EXP 70
7674: PUSH
7675: LD_EXP 71
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: UNION
7686: PPUSH
7687: CALL_OW 1
7691: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7692: LD_ADDR_VAR 0 4
7696: PUSH
7697: LD_INT 267
7699: PPUSH
7700: CALL_OW 274
7704: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7705: LD_VAR 0 4
7709: PPUSH
7710: LD_INT 1
7712: PPUSH
7713: LD_INT 5000
7715: PPUSH
7716: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7720: LD_VAR 0 4
7724: PPUSH
7725: LD_INT 2
7727: PPUSH
7728: LD_INT 200
7730: PPUSH
7731: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7735: LD_VAR 0 4
7739: PPUSH
7740: LD_INT 3
7742: PPUSH
7743: LD_INT 200
7745: PPUSH
7746: CALL_OW 277
// for i := 1 to 6 do
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: DOUBLE
7756: LD_INT 1
7758: DEC
7759: ST_TO_ADDR
7760: LD_INT 6
7762: PUSH
7763: FOR_TO
7764: IFFALSE 7847
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7766: LD_INT 0
7768: PPUSH
7769: LD_INT 8
7771: PUSH
7772: LD_INT 9
7774: PUSH
7775: LD_INT 10
7777: PUSH
7778: LD_INT 10
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: LD_OWVAR 67
7791: ARRAY
7792: PPUSH
7793: CALL_OW 381
// un := CreateHuman ;
7797: LD_ADDR_VAR 0 8
7801: PUSH
7802: CALL_OW 44
7806: ST_TO_ADDR
// if i mod 2 = 0 then
7807: LD_VAR 0 2
7811: PUSH
7812: LD_INT 2
7814: MOD
7815: PUSH
7816: LD_INT 0
7818: EQUAL
7819: IFFALSE 7833
// SetClass ( un , class_bazooker ) ;
7821: LD_VAR 0 8
7825: PPUSH
7826: LD_INT 9
7828: PPUSH
7829: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
7833: LD_VAR 0 8
7837: PPUSH
7838: LD_INT 460
7840: PPUSH
7841: CALL_OW 52
// end ;
7845: GO 7763
7847: POP
7848: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
7849: LD_INT 21
7851: PPUSH
7852: LD_INT 3
7854: PPUSH
7855: LD_INT 3
7857: PPUSH
7858: LD_INT 52
7860: PPUSH
7861: LD_INT 100
7863: PPUSH
7864: CALL 73635 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
7868: CALL_OW 45
7872: PPUSH
7873: LD_INT 259
7875: PPUSH
7876: LD_INT 145
7878: PPUSH
7879: LD_INT 3
7881: PPUSH
7882: LD_INT 0
7884: PPUSH
7885: CALL 108227 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
7889: CALL_OW 45
7893: PPUSH
7894: LD_INT 245
7896: PPUSH
7897: LD_INT 139
7899: PPUSH
7900: LD_INT 3
7902: PPUSH
7903: LD_INT 0
7905: PPUSH
7906: CALL 108227 0 5
// behemoths := [ ] ;
7910: LD_ADDR_EXP 74
7914: PUSH
7915: EMPTY
7916: ST_TO_ADDR
// behemothBuilders := [ ] ;
7917: LD_ADDR_EXP 75
7921: PUSH
7922: EMPTY
7923: ST_TO_ADDR
// if Kovalyuk then
7924: LD_EXP 67
7928: IFFALSE 7950
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7930: LD_ADDR_EXP 75
7934: PUSH
7935: LD_EXP 75
7939: PPUSH
7940: LD_EXP 67
7944: PPUSH
7945: CALL 106087 0 2
7949: ST_TO_ADDR
// j := 3 ;
7950: LD_ADDR_VAR 0 3
7954: PUSH
7955: LD_INT 3
7957: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7958: LD_ADDR_VAR 0 2
7962: PUSH
7963: LD_INT 22
7965: PUSH
7966: LD_INT 3
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PUSH
7973: LD_INT 25
7975: PUSH
7976: LD_INT 3
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: PPUSH
7987: CALL_OW 69
7991: PUSH
7992: LD_EXP 67
7996: DIFF
7997: PUSH
7998: FOR_IN
7999: IFFALSE 8049
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8001: LD_ADDR_EXP 75
8005: PUSH
8006: LD_EXP 75
8010: PPUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL 106087 0 2
8020: ST_TO_ADDR
// j := j - 1 ;
8021: LD_ADDR_VAR 0 3
8025: PUSH
8026: LD_VAR 0 3
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: ST_TO_ADDR
// if j = 0 then
8035: LD_VAR 0 3
8039: PUSH
8040: LD_INT 0
8042: EQUAL
8043: IFFALSE 8047
// break ;
8045: GO 8049
// end ;
8047: GO 7998
8049: POP
8050: POP
// end ;
8051: LD_VAR 0 1
8055: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8056: LD_INT 0
8058: PPUSH
8059: PPUSH
8060: PPUSH
8061: PPUSH
8062: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8063: LD_ADDR_VAR 0 4
8067: PUSH
8068: LD_INT 209
8070: PUSH
8071: LD_INT 149
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: PUSH
8078: LD_INT 219
8080: PUSH
8081: LD_INT 154
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 223
8090: PUSH
8091: LD_INT 149
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 232
8100: PUSH
8101: LD_INT 155
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: LIST
8112: LIST
8113: ST_TO_ADDR
// if not behemothBuilders then
8114: LD_EXP 75
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8254
// j := 1 ;
8123: LD_ADDR_VAR 0 3
8127: PUSH
8128: LD_INT 1
8130: ST_TO_ADDR
// for i in behemothBuilders do
8131: LD_ADDR_VAR 0 2
8135: PUSH
8136: LD_EXP 75
8140: PUSH
8141: FOR_IN
8142: IFFALSE 8252
// begin if GetClass ( i ) <> class_mechanic then
8144: LD_VAR 0 2
8148: PPUSH
8149: CALL_OW 257
8153: PUSH
8154: LD_INT 3
8156: NONEQUAL
8157: IFFALSE 8171
// SetClass ( i , class_mechanic ) ;
8159: LD_VAR 0 2
8163: PPUSH
8164: LD_INT 3
8166: PPUSH
8167: CALL_OW 336
// if IsInUnit ( i ) then
8171: LD_VAR 0 2
8175: PPUSH
8176: CALL_OW 310
8180: IFFALSE 8191
// ComExitBuilding ( i ) ;
8182: LD_VAR 0 2
8186: PPUSH
8187: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8191: LD_VAR 0 2
8195: PPUSH
8196: LD_INT 37
8198: PPUSH
8199: LD_VAR 0 4
8203: PUSH
8204: LD_VAR 0 3
8208: ARRAY
8209: PUSH
8210: LD_INT 1
8212: ARRAY
8213: PPUSH
8214: LD_VAR 0 4
8218: PUSH
8219: LD_VAR 0 3
8223: ARRAY
8224: PUSH
8225: LD_INT 2
8227: ARRAY
8228: PPUSH
8229: LD_INT 0
8231: PPUSH
8232: CALL_OW 230
// j := j + 1 ;
8236: LD_ADDR_VAR 0 3
8240: PUSH
8241: LD_VAR 0 3
8245: PUSH
8246: LD_INT 1
8248: PLUS
8249: ST_TO_ADDR
// end ;
8250: GO 8141
8252: POP
8253: POP
// end ;
8254: LD_VAR 0 1
8258: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8259: LD_INT 24
8261: PPUSH
8262: LD_INT 30
8264: PUSH
8265: LD_INT 37
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PPUSH
8272: CALL_OW 70
8276: IFFALSE 8289
8278: GO 8280
8280: DISABLE
// behemothUnderConstruct := true ;
8281: LD_ADDR_EXP 26
8285: PUSH
8286: LD_INT 1
8288: ST_TO_ADDR
8289: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8290: LD_INT 3
8292: PPUSH
8293: CALL 106148 0 1
8297: PUSH
8298: LD_INT 22
8300: PUSH
8301: LD_INT 3
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: LD_INT 30
8310: PUSH
8311: LD_INT 37
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PPUSH
8322: CALL_OW 69
8326: NOT
8327: AND
8328: IFFALSE 8514
8330: GO 8332
8332: DISABLE
8333: LD_INT 0
8335: PPUSH
8336: PPUSH
// begin enable ;
8337: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8338: LD_ADDR_VAR 0 2
8342: PUSH
8343: LD_INT 3
8345: PPUSH
8346: CALL 106148 0 1
8350: ST_TO_ADDR
// for i in tmp do
8351: LD_ADDR_VAR 0 1
8355: PUSH
8356: LD_VAR 0 2
8360: PUSH
8361: FOR_IN
8362: IFFALSE 8512
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8364: LD_VAR 0 1
8368: PPUSH
8369: LD_INT 9
8371: PPUSH
8372: CALL_OW 308
8376: PUSH
8377: LD_VAR 0 1
8381: PPUSH
8382: CALL_OW 110
8386: PUSH
8387: LD_INT 2
8389: EQUAL
8390: NOT
8391: AND
8392: IFFALSE 8406
// SetTag ( i , 2 ) ;
8394: LD_VAR 0 1
8398: PPUSH
8399: LD_INT 2
8401: PPUSH
8402: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8406: LD_INT 81
8408: PUSH
8409: LD_INT 3
8411: PUSH
8412: EMPTY
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 91
8418: PUSH
8419: LD_VAR 0 1
8423: PUSH
8424: LD_INT 12
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: NOT
8441: PUSH
8442: LD_VAR 0 1
8446: PPUSH
8447: CALL_OW 110
8451: PUSH
8452: LD_INT 2
8454: EQUAL
8455: NOT
8456: AND
8457: IFFALSE 8476
// ComAgressiveMove ( i , 64 , 93 ) else
8459: LD_VAR 0 1
8463: PPUSH
8464: LD_INT 64
8466: PPUSH
8467: LD_INT 93
8469: PPUSH
8470: CALL_OW 114
8474: GO 8510
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8476: LD_VAR 0 1
8480: PPUSH
8481: LD_INT 81
8483: PUSH
8484: LD_INT 3
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 69
8495: PPUSH
8496: LD_VAR 0 1
8500: PPUSH
8501: CALL_OW 74
8505: PPUSH
8506: CALL_OW 115
// end ;
8510: GO 8361
8512: POP
8513: POP
// end ;
8514: PPOPN 2
8516: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8517: LD_INT 0
8519: PPUSH
8520: PPUSH
8521: PPUSH
// result := [ ] ;
8522: LD_ADDR_VAR 0 2
8526: PUSH
8527: EMPTY
8528: ST_TO_ADDR
// uc_side := 6 ;
8529: LD_ADDR_OWVAR 20
8533: PUSH
8534: LD_INT 6
8536: ST_TO_ADDR
// uc_nation := 3 ;
8537: LD_ADDR_OWVAR 21
8541: PUSH
8542: LD_INT 3
8544: ST_TO_ADDR
// case strength of 1 :
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 1
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8700
8558: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: DOUBLE
8565: LD_INT 1
8567: DEC
8568: ST_TO_ADDR
8569: LD_INT 4
8571: PUSH
8572: LD_INT 5
8574: PUSH
8575: LD_INT 6
8577: PUSH
8578: LD_INT 7
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: PUSH
8587: LD_OWVAR 67
8591: ARRAY
8592: PUSH
8593: FOR_TO
8594: IFFALSE 8696
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8596: LD_INT 22
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_VAR 0 3
8610: PUSH
8611: LD_INT 2
8613: MOD
8614: PUSH
8615: LD_INT 1
8617: PLUS
8618: ARRAY
8619: PPUSH
8620: LD_INT 1
8622: PUSH
8623: LD_INT 3
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 1
8632: PPUSH
8633: LD_INT 2
8635: PPUSH
8636: CALL_OW 12
8640: ARRAY
8641: PPUSH
8642: LD_INT 3
8644: PPUSH
8645: LD_INT 43
8647: PUSH
8648: LD_INT 44
8650: PUSH
8651: LD_INT 45
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: LIST
8658: PUSH
8659: LD_INT 1
8661: PPUSH
8662: LD_INT 3
8664: PPUSH
8665: CALL_OW 12
8669: ARRAY
8670: PPUSH
8671: LD_INT 80
8673: PPUSH
8674: CALL 73635 0 5
// result := result union CreateVehicle ;
8678: LD_ADDR_VAR 0 2
8682: PUSH
8683: LD_VAR 0 2
8687: PUSH
8688: CALL_OW 45
8692: UNION
8693: ST_TO_ADDR
// end ;
8694: GO 8593
8696: POP
8697: POP
// end ; 2 :
8698: GO 9695
8700: LD_INT 2
8702: DOUBLE
8703: EQUAL
8704: IFTRUE 8708
8706: GO 8876
8708: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8709: LD_ADDR_VAR 0 3
8713: PUSH
8714: DOUBLE
8715: LD_INT 1
8717: DEC
8718: ST_TO_ADDR
8719: LD_INT 5
8721: PUSH
8722: LD_INT 6
8724: PUSH
8725: LD_INT 7
8727: PUSH
8728: LD_INT 8
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: PUSH
8737: LD_OWVAR 67
8741: ARRAY
8742: PUSH
8743: FOR_TO
8744: IFFALSE 8872
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8746: LD_INT 22
8748: PUSH
8749: LD_INT 24
8751: PUSH
8752: LD_INT 24
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 3
8767: MOD
8768: PUSH
8769: LD_INT 1
8771: PLUS
8772: ARRAY
8773: PPUSH
8774: LD_INT 1
8776: PUSH
8777: LD_INT 3
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PUSH
8784: LD_INT 1
8786: PPUSH
8787: LD_INT 2
8789: PPUSH
8790: CALL_OW 12
8794: ARRAY
8795: PPUSH
8796: LD_INT 3
8798: PPUSH
8799: LD_INT 43
8801: PUSH
8802: LD_INT 44
8804: PUSH
8805: LD_INT 45
8807: PUSH
8808: LD_INT 44
8810: PUSH
8811: LD_INT 46
8813: PUSH
8814: LD_INT 46
8816: PUSH
8817: LD_INT 49
8819: PUSH
8820: LD_INT 49
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: LIST
8832: PUSH
8833: LD_VAR 0 3
8837: PUSH
8838: LD_INT 8
8840: MOD
8841: PUSH
8842: LD_INT 1
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 80
8849: PPUSH
8850: CALL 73635 0 5
// result := result union CreateVehicle ;
8854: LD_ADDR_VAR 0 2
8858: PUSH
8859: LD_VAR 0 2
8863: PUSH
8864: CALL_OW 45
8868: UNION
8869: ST_TO_ADDR
// end ;
8870: GO 8743
8872: POP
8873: POP
// end ; 3 :
8874: GO 9695
8876: LD_INT 3
8878: DOUBLE
8879: EQUAL
8880: IFTRUE 8884
8882: GO 9056
8884: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: DOUBLE
8891: LD_INT 1
8893: DEC
8894: ST_TO_ADDR
8895: LD_INT 6
8897: PUSH
8898: LD_INT 7
8900: PUSH
8901: LD_INT 8
8903: PUSH
8904: LD_INT 9
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: PUSH
8913: LD_OWVAR 67
8917: ARRAY
8918: PUSH
8919: FOR_TO
8920: IFFALSE 9052
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8922: LD_INT 22
8924: PUSH
8925: LD_INT 24
8927: PUSH
8928: LD_INT 24
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: LIST
8935: PUSH
8936: LD_VAR 0 3
8940: PUSH
8941: LD_INT 3
8943: MOD
8944: PUSH
8945: LD_INT 1
8947: PLUS
8948: ARRAY
8949: PPUSH
8950: LD_INT 1
8952: PUSH
8953: LD_INT 3
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_INT 2
8965: PPUSH
8966: CALL_OW 12
8970: ARRAY
8971: PPUSH
8972: LD_INT 3
8974: PPUSH
8975: LD_INT 43
8977: PUSH
8978: LD_INT 47
8980: PUSH
8981: LD_INT 45
8983: PUSH
8984: LD_INT 45
8986: PUSH
8987: LD_INT 46
8989: PUSH
8990: LD_INT 46
8992: PUSH
8993: LD_INT 49
8995: PUSH
8996: LD_INT 49
8998: PUSH
8999: LD_INT 49
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: PUSH
9013: LD_VAR 0 3
9017: PUSH
9018: LD_INT 9
9020: MOD
9021: PUSH
9022: LD_INT 1
9024: PLUS
9025: ARRAY
9026: PPUSH
9027: LD_INT 80
9029: PPUSH
9030: CALL 73635 0 5
// result := result union CreateVehicle ;
9034: LD_ADDR_VAR 0 2
9038: PUSH
9039: LD_VAR 0 2
9043: PUSH
9044: CALL_OW 45
9048: UNION
9049: ST_TO_ADDR
// end ;
9050: GO 8919
9052: POP
9053: POP
// end ; 4 :
9054: GO 9695
9056: LD_INT 4
9058: DOUBLE
9059: EQUAL
9060: IFTRUE 9064
9062: GO 9694
9064: POP
// begin uc_nation := 3 ;
9065: LD_ADDR_OWVAR 21
9069: PUSH
9070: LD_INT 3
9072: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9073: LD_ADDR_VAR 0 3
9077: PUSH
9078: DOUBLE
9079: LD_INT 1
9081: DEC
9082: ST_TO_ADDR
9083: LD_INT 6
9085: PUSH
9086: LD_INT 8
9088: PUSH
9089: LD_INT 9
9091: PUSH
9092: LD_INT 10
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: LD_OWVAR 67
9105: ARRAY
9106: PUSH
9107: FOR_TO
9108: IFFALSE 9240
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9110: LD_INT 22
9112: PUSH
9113: LD_INT 24
9115: PUSH
9116: LD_INT 24
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: LIST
9123: PUSH
9124: LD_VAR 0 3
9128: PUSH
9129: LD_INT 3
9131: MOD
9132: PUSH
9133: LD_INT 1
9135: PLUS
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PUSH
9141: LD_INT 3
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PUSH
9148: LD_INT 1
9150: PPUSH
9151: LD_INT 2
9153: PPUSH
9154: CALL_OW 12
9158: ARRAY
9159: PPUSH
9160: LD_INT 3
9162: PPUSH
9163: LD_INT 45
9165: PUSH
9166: LD_INT 47
9168: PUSH
9169: LD_INT 47
9171: PUSH
9172: LD_INT 45
9174: PUSH
9175: LD_INT 46
9177: PUSH
9178: LD_INT 46
9180: PUSH
9181: LD_INT 49
9183: PUSH
9184: LD_INT 49
9186: PUSH
9187: LD_INT 49
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: LIST
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: LIST
9200: PUSH
9201: LD_VAR 0 3
9205: PUSH
9206: LD_INT 9
9208: MOD
9209: PUSH
9210: LD_INT 1
9212: PLUS
9213: ARRAY
9214: PPUSH
9215: LD_INT 80
9217: PPUSH
9218: CALL 73635 0 5
// result := result union CreateVehicle ;
9222: LD_ADDR_VAR 0 2
9226: PUSH
9227: LD_VAR 0 2
9231: PUSH
9232: CALL_OW 45
9236: UNION
9237: ST_TO_ADDR
// end ;
9238: GO 9107
9240: POP
9241: POP
// if not KappaStatus then
9242: LD_EXP 2
9246: NOT
9247: IFFALSE 9482
// begin uc_nation := 1 ;
9249: LD_ADDR_OWVAR 21
9253: PUSH
9254: LD_INT 1
9256: ST_TO_ADDR
// for i = 1 to 3 do
9257: LD_ADDR_VAR 0 3
9261: PUSH
9262: DOUBLE
9263: LD_INT 1
9265: DEC
9266: ST_TO_ADDR
9267: LD_INT 3
9269: PUSH
9270: FOR_TO
9271: IFFALSE 9407
// begin j := rand ( 0 , 1 ) ;
9273: LD_ADDR_VAR 0 4
9277: PUSH
9278: LD_INT 0
9280: PPUSH
9281: LD_INT 1
9283: PPUSH
9284: CALL_OW 12
9288: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9289: LD_INT 3
9291: PUSH
9292: LD_INT 5
9294: PUSH
9295: LD_INT 5
9297: PUSH
9298: LD_INT 4
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: PUSH
9307: LD_VAR 0 4
9311: PUSH
9312: LD_INT 1
9314: PPUSH
9315: LD_INT 3
9317: PPUSH
9318: CALL_OW 12
9322: PLUS
9323: ARRAY
9324: PPUSH
9325: LD_INT 1
9327: PUSH
9328: LD_INT 3
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PUSH
9335: LD_INT 1
9337: PPUSH
9338: LD_INT 2
9340: PPUSH
9341: CALL_OW 12
9345: ARRAY
9346: PPUSH
9347: LD_INT 3
9349: PPUSH
9350: LD_INT 9
9352: PUSH
9353: LD_INT 7
9355: PUSH
9356: LD_INT 6
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 4
9368: PUSH
9369: LD_INT 1
9371: PPUSH
9372: LD_INT 2
9374: PPUSH
9375: CALL_OW 12
9379: PLUS
9380: ARRAY
9381: PPUSH
9382: LD_INT 85
9384: PPUSH
9385: CALL 73635 0 5
// result := result union CreateVehicle ;
9389: LD_ADDR_VAR 0 2
9393: PUSH
9394: LD_VAR 0 2
9398: PUSH
9399: CALL_OW 45
9403: UNION
9404: ST_TO_ADDR
// end ;
9405: GO 9270
9407: POP
9408: POP
// if vsevolodFirstAttack then
9409: LD_EXP 24
9413: IFFALSE 9480
// begin vsevolodFirstAttack := false ;
9415: LD_ADDR_EXP 24
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9423: LD_INT 5
9425: PPUSH
9426: LD_INT 3
9428: PPUSH
9429: LD_INT 1
9431: PPUSH
9432: LD_INT 6
9434: PPUSH
9435: LD_INT 100
9437: PPUSH
9438: CALL 73635 0 5
// sewiVeh := CreateVehicle ;
9442: LD_ADDR_EXP 73
9446: PUSH
9447: CALL_OW 45
9451: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9452: LD_EXP 73
9456: PPUSH
9457: LD_INT 1
9459: PPUSH
9460: CALL_OW 242
// result := result union sewiVeh ;
9464: LD_ADDR_VAR 0 2
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: LD_EXP 73
9478: UNION
9479: ST_TO_ADDR
// end ; end else
9480: GO 9692
// if vsevolodFirstAttack then
9482: LD_EXP 24
9486: IFFALSE 9692
// begin vsevolodFirstAttack := false ;
9488: LD_ADDR_EXP 24
9492: PUSH
9493: LD_INT 0
9495: ST_TO_ADDR
// uc_nation := 3 ;
9496: LD_ADDR_OWVAR 21
9500: PUSH
9501: LD_INT 3
9503: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9504: LD_ADDR_VAR 0 3
9508: PUSH
9509: DOUBLE
9510: LD_INT 1
9512: DEC
9513: ST_TO_ADDR
9514: LD_INT 2
9516: PUSH
9517: LD_OWVAR 67
9521: PLUS
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9632
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9526: LD_INT 22
9528: PUSH
9529: LD_INT 24
9531: PUSH
9532: LD_INT 24
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_VAR 0 3
9544: PUSH
9545: LD_INT 3
9547: MOD
9548: PUSH
9549: LD_INT 1
9551: PLUS
9552: ARRAY
9553: PPUSH
9554: LD_INT 1
9556: PUSH
9557: LD_INT 3
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 1
9566: PPUSH
9567: LD_INT 2
9569: PPUSH
9570: CALL_OW 12
9574: ARRAY
9575: PPUSH
9576: LD_INT 1
9578: PPUSH
9579: LD_INT 45
9581: PUSH
9582: LD_INT 47
9584: PUSH
9585: LD_INT 47
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: LIST
9592: PUSH
9593: LD_VAR 0 3
9597: PUSH
9598: LD_INT 3
9600: MOD
9601: PUSH
9602: LD_INT 1
9604: PLUS
9605: ARRAY
9606: PPUSH
9607: LD_INT 80
9609: PPUSH
9610: CALL 73635 0 5
// result := result union CreateVehicle ;
9614: LD_ADDR_VAR 0 2
9618: PUSH
9619: LD_VAR 0 2
9623: PUSH
9624: CALL_OW 45
9628: UNION
9629: ST_TO_ADDR
// end ;
9630: GO 9523
9632: POP
9633: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9634: LD_INT 24
9636: PPUSH
9637: LD_INT 3
9639: PPUSH
9640: LD_INT 1
9642: PPUSH
9643: LD_INT 47
9645: PPUSH
9646: LD_INT 100
9648: PPUSH
9649: CALL 73635 0 5
// sewiVeh := CreateVehicle ;
9653: LD_ADDR_EXP 73
9657: PUSH
9658: CALL_OW 45
9662: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9663: LD_EXP 73
9667: PPUSH
9668: LD_INT 6
9670: NEG
9671: PPUSH
9672: CALL_OW 242
// result := result union sewiVeh ;
9676: LD_ADDR_VAR 0 2
9680: PUSH
9681: LD_VAR 0 2
9685: PUSH
9686: LD_EXP 73
9690: UNION
9691: ST_TO_ADDR
// end ; end ; end ;
9692: GO 9695
9694: POP
// end ;
9695: LD_VAR 0 2
9699: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9700: LD_EXP 16
9704: IFFALSE 10424
9706: GO 9708
9708: DISABLE
9709: LD_INT 0
9711: PPUSH
9712: PPUSH
9713: PPUSH
9714: PPUSH
9715: PPUSH
9716: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9717: LD_ADDR_VAR 0 4
9721: PUSH
9722: LD_INT 11
9724: PUSH
9725: LD_INT 12
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9732: LD_ADDR_VAR 0 3
9736: PUSH
9737: LD_INT 11550
9739: PUSH
9740: LD_INT 10150
9742: PUSH
9743: LD_INT 9800
9745: PUSH
9746: LD_INT 9450
9748: PUSH
9749: EMPTY
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PUSH
9755: LD_OWVAR 67
9759: ARRAY
9760: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9761: LD_ADDR_VAR 0 6
9765: PUSH
9766: LD_INT 70
9768: PUSH
9769: LD_INT 118
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: LD_INT 78
9778: PUSH
9779: LD_INT 31
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: ST_TO_ADDR
// repeat if missionStage = 2 then
9790: LD_EXP 15
9794: PUSH
9795: LD_INT 2
9797: EQUAL
9798: IFFALSE 9809
// wait ( 1 1$30 ) else
9800: LD_INT 3150
9802: PPUSH
9803: CALL_OW 67
9807: GO 9818
// wait ( time ) ;
9809: LD_VAR 0 3
9813: PPUSH
9814: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9818: LD_EXP 15
9822: PUSH
9823: LD_INT 6
9825: EQUAL
9826: PUSH
9827: LD_OWVAR 67
9831: PUSH
9832: LD_INT 2
9834: GREATER
9835: OR
9836: IFFALSE 9864
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9838: LD_INT 51
9840: PPUSH
9841: LD_INT 6
9843: PPUSH
9844: LD_INT 2
9846: PPUSH
9847: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9851: LD_INT 57
9853: PPUSH
9854: LD_INT 6
9856: PPUSH
9857: LD_INT 2
9859: PPUSH
9860: CALL_OW 322
// end ; if missionStage = 8 then
9864: LD_EXP 15
9868: PUSH
9869: LD_INT 8
9871: EQUAL
9872: IFFALSE 9900
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9874: LD_INT 52
9876: PPUSH
9877: LD_INT 6
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9887: LD_INT 58
9889: PPUSH
9890: LD_INT 6
9892: PPUSH
9893: LD_INT 2
9895: PPUSH
9896: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
9900: LD_OWVAR 67
9904: PUSH
9905: LD_INT 4
9907: EQUAL
9908: PUSH
9909: LD_EXP 15
9913: PUSH
9914: LD_INT 10
9916: EQUAL
9917: OR
9918: IFFALSE 9946
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9920: LD_INT 53
9922: PPUSH
9923: LD_INT 6
9925: PPUSH
9926: LD_INT 2
9928: PPUSH
9929: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9933: LD_INT 59
9935: PPUSH
9936: LD_INT 6
9938: PPUSH
9939: LD_INT 2
9941: PPUSH
9942: CALL_OW 322
// end ; if activeAttacks then
9946: LD_EXP 16
9950: IFFALSE 10418
// begin if missionStage = 2 then
9952: LD_EXP 15
9956: PUSH
9957: LD_INT 2
9959: EQUAL
9960: IFFALSE 9970
// strength := 1 ;
9962: LD_ADDR_VAR 0 5
9966: PUSH
9967: LD_INT 1
9969: ST_TO_ADDR
// if missionStage > 2 then
9970: LD_EXP 15
9974: PUSH
9975: LD_INT 2
9977: GREATER
9978: IFFALSE 9988
// strength := 2 ;
9980: LD_ADDR_VAR 0 5
9984: PUSH
9985: LD_INT 2
9987: ST_TO_ADDR
// if missionStage > 6 then
9988: LD_EXP 15
9992: PUSH
9993: LD_INT 6
9995: GREATER
9996: IFFALSE 10006
// strength := 3 ;
9998: LD_ADDR_VAR 0 5
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// if missionStage > 10 then
10006: LD_EXP 15
10010: PUSH
10011: LD_INT 10
10013: GREATER
10014: IFFALSE 10024
// strength := 4 ;
10016: LD_ADDR_VAR 0 5
10020: PUSH
10021: LD_INT 4
10023: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10024: LD_ADDR_VAR 0 2
10028: PUSH
10029: LD_VAR 0 5
10033: PPUSH
10034: CALL 8517 0 1
10038: ST_TO_ADDR
// for i in tmp do
10039: LD_ADDR_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: FOR_IN
10050: IFFALSE 10308
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10052: LD_VAR 0 1
10056: PPUSH
10057: LD_VAR 0 4
10061: PUSH
10062: LD_INT 1
10064: PPUSH
10065: LD_INT 2
10067: PPUSH
10068: CALL_OW 12
10072: ARRAY
10073: PPUSH
10074: LD_INT 0
10076: PPUSH
10077: CALL_OW 49
// if i = sewiVeh then
10081: LD_VAR 0 1
10085: PUSH
10086: LD_EXP 73
10090: EQUAL
10091: IFFALSE 10128
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10093: LD_ADDR_EXP 72
10097: PUSH
10098: LD_STRING Vsevolod
10100: PPUSH
10101: LD_INT 0
10103: PPUSH
10104: LD_STRING 
10106: PPUSH
10107: CALL 68795 0 3
10111: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10112: LD_EXP 72
10116: PPUSH
10117: LD_VAR 0 1
10121: PPUSH
10122: CALL_OW 52
// end else
10126: GO 10209
// if GetControl ( i ) = control_manual then
10128: LD_VAR 0 1
10132: PPUSH
10133: CALL_OW 263
10137: PUSH
10138: LD_INT 1
10140: EQUAL
10141: IFFALSE 10209
// begin uc_side := 6 ;
10143: LD_ADDR_OWVAR 20
10147: PUSH
10148: LD_INT 6
10150: ST_TO_ADDR
// uc_nation := 3 ;
10151: LD_ADDR_OWVAR 21
10155: PUSH
10156: LD_INT 3
10158: ST_TO_ADDR
// hc_gallery :=  ;
10159: LD_ADDR_OWVAR 33
10163: PUSH
10164: LD_STRING 
10166: ST_TO_ADDR
// hc_name :=  ;
10167: LD_ADDR_OWVAR 26
10171: PUSH
10172: LD_STRING 
10174: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10175: LD_INT 0
10177: PPUSH
10178: LD_INT 3
10180: PPUSH
10181: LD_INT 10
10183: PPUSH
10184: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10188: CALL_OW 44
10192: PPUSH
10193: LD_VAR 0 1
10197: PPUSH
10198: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10202: LD_INT 10
10204: PPUSH
10205: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10209: LD_INT 1
10211: PPUSH
10212: LD_INT 3
10214: PPUSH
10215: CALL_OW 12
10219: PUSH
10220: LD_INT 1
10222: DOUBLE
10223: EQUAL
10224: IFTRUE 10228
10226: GO 10246
10228: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10229: LD_VAR 0 1
10233: PPUSH
10234: LD_INT 111
10236: PPUSH
10237: LD_INT 197
10239: PPUSH
10240: CALL_OW 111
10244: GO 10299
10246: LD_INT 2
10248: DOUBLE
10249: EQUAL
10250: IFTRUE 10254
10252: GO 10272
10254: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10255: LD_VAR 0 1
10259: PPUSH
10260: LD_INT 91
10262: PPUSH
10263: LD_INT 165
10265: PPUSH
10266: CALL_OW 111
10270: GO 10299
10272: LD_INT 3
10274: DOUBLE
10275: EQUAL
10276: IFTRUE 10280
10278: GO 10298
10280: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10281: LD_VAR 0 1
10285: PPUSH
10286: LD_INT 137
10288: PPUSH
10289: LD_INT 157
10291: PPUSH
10292: CALL_OW 111
10296: GO 10299
10298: POP
// wait ( 0 0$2 ) ;
10299: LD_INT 70
10301: PPUSH
10302: CALL_OW 67
// end ;
10306: GO 10049
10308: POP
10309: POP
// repeat wait ( 0 0$1 ) ;
10310: LD_INT 35
10312: PPUSH
10313: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10317: LD_ADDR_VAR 0 1
10321: PUSH
10322: LD_VAR 0 2
10326: PPUSH
10327: LD_INT 50
10329: PUSH
10330: EMPTY
10331: LIST
10332: PPUSH
10333: CALL_OW 72
10337: PUSH
10338: FOR_IN
10339: IFFALSE 10398
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10341: LD_VAR 0 1
10345: PPUSH
10346: LD_INT 108
10348: PUSH
10349: LD_INT 153
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: LD_INT 105
10358: PUSH
10359: LD_INT 149
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PUSH
10366: LD_INT 85
10368: PUSH
10369: LD_INT 131
10371: PUSH
10372: EMPTY
10373: LIST
10374: LIST
10375: PUSH
10376: LD_INT 64
10378: PUSH
10379: LD_INT 105
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: PPUSH
10392: CALL 108691 0 2
10396: GO 10338
10398: POP
10399: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10400: LD_VAR 0 2
10404: PPUSH
10405: LD_INT 50
10407: PUSH
10408: EMPTY
10409: LIST
10410: PPUSH
10411: CALL_OW 72
10415: NOT
10416: IFFALSE 10310
// end ; until russianDestroyed ;
10418: LD_EXP 21
10422: IFFALSE 9790
// end ;
10424: PPOPN 6
10426: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport ;
10427: LD_EXP 21
10431: NOT
10432: PUSH
10433: LD_EXP 15
10437: PUSH
10438: LD_INT 6
10440: GREATEREQUAL
10441: AND
10442: IFFALSE 11381
10444: GO 10446
10446: DISABLE
10447: LD_INT 0
10449: PPUSH
10450: PPUSH
10451: PPUSH
10452: PPUSH
// begin enable ;
10453: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10454: LD_INT 22
10456: PUSH
10457: LD_INT 3
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: LD_INT 30
10466: PUSH
10467: LD_INT 3
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: PPUSH
10478: CALL_OW 69
10482: NOT
10483: IFFALSE 10487
// exit ;
10485: GO 11381
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10487: LD_ADDR_VAR 0 4
10491: PUSH
10492: LD_INT 22
10494: PUSH
10495: LD_INT 3
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 30
10504: PUSH
10505: LD_INT 34
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PPUSH
10516: CALL_OW 69
10520: ST_TO_ADDR
// if Prob ( 40 ) then
10521: LD_INT 40
10523: PPUSH
10524: CALL_OW 13
10528: IFFALSE 10674
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10530: LD_INT 2
10532: PPUSH
10533: LD_INT 22
10535: PUSH
10536: LD_INT 3
10538: PUSH
10539: LD_INT 3
10541: PUSH
10542: LD_INT 49
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: PUSH
10551: LD_INT 22
10553: PUSH
10554: LD_INT 3
10556: PUSH
10557: LD_INT 3
10559: PUSH
10560: LD_INT 49
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: PUSH
10569: LD_INT 22
10571: PUSH
10572: LD_INT 3
10574: PUSH
10575: LD_INT 3
10577: PUSH
10578: LD_INT 49
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: PUSH
10587: LD_INT 24
10589: PUSH
10590: LD_INT 3
10592: PUSH
10593: LD_INT 3
10595: PUSH
10596: LD_INT 46
10598: PUSH
10599: EMPTY
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: PUSH
10605: LD_INT 24
10607: PUSH
10608: LD_INT 3
10610: PUSH
10611: LD_INT 3
10613: PUSH
10614: LD_INT 46
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PUSH
10623: LD_INT 24
10625: PUSH
10626: LD_INT 3
10628: PUSH
10629: LD_INT 3
10631: PUSH
10632: LD_INT 46
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: PUSH
10641: LD_INT 24
10643: PUSH
10644: LD_INT 3
10646: PUSH
10647: LD_INT 3
10649: PUSH
10650: LD_INT 46
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: PPUSH
10668: CALL 62369 0 2
// end else
10672: GO 10816
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10674: LD_INT 2
10676: PPUSH
10677: LD_INT 24
10679: PUSH
10680: LD_INT 3
10682: PUSH
10683: LD_INT 3
10685: PUSH
10686: LD_INT 47
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: PUSH
10695: LD_INT 24
10697: PUSH
10698: LD_INT 3
10700: PUSH
10701: LD_INT 3
10703: PUSH
10704: LD_INT 47
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 24
10715: PUSH
10716: LD_INT 3
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: LD_INT 47
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: PUSH
10731: LD_INT 24
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: LD_INT 3
10739: PUSH
10740: LD_INT 46
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: PUSH
10749: LD_INT 24
10751: PUSH
10752: LD_INT 3
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: LD_INT 46
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: LIST
10765: LIST
10766: PUSH
10767: LD_INT 24
10769: PUSH
10770: LD_INT 3
10772: PUSH
10773: LD_INT 3
10775: PUSH
10776: LD_INT 46
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: LIST
10783: LIST
10784: PUSH
10785: LD_INT 24
10787: PUSH
10788: LD_INT 3
10790: PUSH
10791: LD_INT 3
10793: PUSH
10794: LD_INT 46
10796: PUSH
10797: EMPTY
10798: LIST
10799: LIST
10800: LIST
10801: LIST
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: LIST
10810: LIST
10811: PPUSH
10812: CALL 62369 0 2
// end ; repeat wait ( 0 0$1 ) ;
10816: LD_INT 35
10818: PPUSH
10819: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10823: LD_INT 2
10825: PPUSH
10826: LD_INT 1
10828: PPUSH
10829: CALL 63787 0 2
10833: PUSH
10834: LD_INT 7
10836: GREATEREQUAL
10837: IFFALSE 10816
// wait ( 0 0$10 ) ;
10839: LD_INT 350
10841: PPUSH
10842: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_INT 2
10853: PPUSH
10854: LD_INT 1
10856: PPUSH
10857: CALL 63787 0 2
10861: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10862: LD_ADDR_EXP 119
10866: PUSH
10867: LD_EXP 119
10871: PPUSH
10872: LD_INT 2
10874: PPUSH
10875: LD_EXP 119
10879: PUSH
10880: LD_INT 2
10882: ARRAY
10883: PUSH
10884: LD_VAR 0 2
10888: DIFF
10889: PPUSH
10890: CALL_OW 1
10894: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10895: LD_ADDR_VAR 0 3
10899: PUSH
10900: LD_INT 0
10902: PPUSH
10903: LD_INT 1
10905: PPUSH
10906: CALL_OW 12
10910: ST_TO_ADDR
// if target then
10911: LD_VAR 0 3
10915: IFFALSE 11043
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10917: LD_ADDR_VAR 0 2
10921: PUSH
10922: LD_VAR 0 2
10926: PPUSH
10927: LD_INT 24
10929: PUSH
10930: LD_INT 250
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: PPUSH
10937: CALL_OW 72
10941: ST_TO_ADDR
// for i in tmp do
10942: LD_ADDR_VAR 0 1
10946: PUSH
10947: LD_VAR 0 2
10951: PUSH
10952: FOR_IN
10953: IFFALSE 10993
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10955: LD_VAR 0 1
10959: PPUSH
10960: LD_INT 139
10962: PPUSH
10963: LD_INT 89
10965: PPUSH
10966: CALL_OW 297
10970: PUSH
10971: LD_INT 9
10973: GREATER
10974: IFFALSE 10991
// ComMoveXY ( i , 139 , 89 ) ;
10976: LD_VAR 0 1
10980: PPUSH
10981: LD_INT 139
10983: PPUSH
10984: LD_INT 89
10986: PPUSH
10987: CALL_OW 111
10991: GO 10952
10993: POP
10994: POP
// wait ( 0 0$1 ) ;
10995: LD_INT 35
10997: PPUSH
10998: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
11002: LD_VAR 0 2
11006: PPUSH
11007: LD_INT 92
11009: PUSH
11010: LD_INT 139
11012: PUSH
11013: LD_INT 89
11015: PUSH
11016: LD_INT 9
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 72
11029: PUSH
11030: LD_VAR 0 2
11034: PUSH
11035: LD_INT 1
11037: MINUS
11038: GREATEREQUAL
11039: IFFALSE 10917
// end else
11041: GO 11185
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11043: LD_VAR 0 2
11047: PPUSH
11048: LD_VAR 0 4
11052: PUSH
11053: LD_INT 1
11055: ARRAY
11056: PPUSH
11057: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11061: LD_ADDR_VAR 0 2
11065: PUSH
11066: LD_VAR 0 2
11070: PPUSH
11071: LD_INT 24
11073: PUSH
11074: LD_INT 250
11076: PUSH
11077: EMPTY
11078: LIST
11079: LIST
11080: PPUSH
11081: CALL_OW 72
11085: ST_TO_ADDR
// for i in tmp do
11086: LD_ADDR_VAR 0 1
11090: PUSH
11091: LD_VAR 0 2
11095: PUSH
11096: FOR_IN
11097: IFFALSE 11137
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11099: LD_VAR 0 1
11103: PPUSH
11104: LD_INT 124
11106: PPUSH
11107: LD_INT 139
11109: PPUSH
11110: CALL_OW 297
11114: PUSH
11115: LD_INT 9
11117: GREATER
11118: IFFALSE 11135
// ComMoveXY ( i , 124 , 139 ) ;
11120: LD_VAR 0 1
11124: PPUSH
11125: LD_INT 124
11127: PPUSH
11128: LD_INT 139
11130: PPUSH
11131: CALL_OW 111
11135: GO 11096
11137: POP
11138: POP
// wait ( 0 0$1 ) ;
11139: LD_INT 35
11141: PPUSH
11142: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11146: LD_VAR 0 2
11150: PPUSH
11151: LD_INT 92
11153: PUSH
11154: LD_INT 124
11156: PUSH
11157: LD_INT 139
11159: PUSH
11160: LD_INT 9
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: PPUSH
11169: CALL_OW 72
11173: PUSH
11174: LD_VAR 0 2
11178: PUSH
11179: LD_INT 1
11181: MINUS
11182: GREATEREQUAL
11183: IFFALSE 11061
// end ; repeat wait ( 0 0$1 ) ;
11185: LD_INT 35
11187: PPUSH
11188: CALL_OW 67
// for i in tmp do
11192: LD_ADDR_VAR 0 1
11196: PUSH
11197: LD_VAR 0 2
11201: PUSH
11202: FOR_IN
11203: IFFALSE 11372
// begin if GetLives ( i ) > 251 then
11205: LD_VAR 0 1
11209: PPUSH
11210: CALL_OW 256
11214: PUSH
11215: LD_INT 251
11217: GREATER
11218: IFFALSE 11343
// begin if GetWeapon ( i ) = ru_time_lapser then
11220: LD_VAR 0 1
11224: PPUSH
11225: CALL_OW 264
11229: PUSH
11230: LD_INT 49
11232: EQUAL
11233: IFFALSE 11289
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11235: LD_VAR 0 1
11239: PPUSH
11240: LD_INT 2
11242: PUSH
11243: LD_INT 22
11245: PUSH
11246: LD_INT 1
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: LD_INT 22
11255: PUSH
11256: LD_INT 8
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: LIST
11267: PPUSH
11268: CALL_OW 69
11272: PPUSH
11273: LD_VAR 0 1
11277: PPUSH
11278: CALL_OW 74
11282: PPUSH
11283: CALL_OW 112
11287: GO 11341
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11289: LD_VAR 0 1
11293: PPUSH
11294: LD_INT 2
11296: PUSH
11297: LD_INT 22
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 22
11309: PUSH
11310: LD_INT 8
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: LIST
11321: PPUSH
11322: CALL_OW 69
11326: PPUSH
11327: LD_VAR 0 1
11331: PPUSH
11332: CALL_OW 74
11336: PPUSH
11337: CALL_OW 115
// end else
11341: GO 11370
// if IsDead ( i ) then
11343: LD_VAR 0 1
11347: PPUSH
11348: CALL_OW 301
11352: IFFALSE 11370
// tmp := tmp diff i ;
11354: LD_ADDR_VAR 0 2
11358: PUSH
11359: LD_VAR 0 2
11363: PUSH
11364: LD_VAR 0 1
11368: DIFF
11369: ST_TO_ADDR
// end ;
11370: GO 11202
11372: POP
11373: POP
// until not tmp ;
11374: LD_VAR 0 2
11378: NOT
11379: IFFALSE 11185
// end ;
11381: PPOPN 4
11383: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11384: LD_EXP 15
11388: PUSH
11389: LD_INT 7
11391: GREATEREQUAL
11392: PUSH
11393: LD_OWVAR 67
11397: PUSH
11398: LD_INT 1
11400: GREATER
11401: AND
11402: IFFALSE 11694
11404: GO 11406
11406: DISABLE
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
// begin ruMobile := [ ] ;
11412: LD_ADDR_EXP 76
11416: PUSH
11417: EMPTY
11418: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11419: LD_ADDR_VAR 0 1
11423: PUSH
11424: DOUBLE
11425: LD_INT 1
11427: DEC
11428: ST_TO_ADDR
11429: LD_INT 4
11431: PUSH
11432: LD_INT 5
11434: PUSH
11435: LD_INT 6
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: LIST
11442: PUSH
11443: LD_OWVAR 67
11447: PUSH
11448: LD_INT 1
11450: MINUS
11451: ARRAY
11452: PUSH
11453: FOR_TO
11454: IFFALSE 11692
// begin uc_side := 3 ;
11456: LD_ADDR_OWVAR 20
11460: PUSH
11461: LD_INT 3
11463: ST_TO_ADDR
// uc_nation := 1 ;
11464: LD_ADDR_OWVAR 21
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11472: LD_INT 5
11474: PPUSH
11475: LD_INT 3
11477: PPUSH
11478: LD_INT 1
11480: PPUSH
11481: LD_INT 9
11483: PUSH
11484: LD_INT 7
11486: PUSH
11487: EMPTY
11488: LIST
11489: LIST
11490: PUSH
11491: LD_VAR 0 1
11495: PUSH
11496: LD_INT 2
11498: MOD
11499: PUSH
11500: LD_INT 1
11502: PLUS
11503: ARRAY
11504: PPUSH
11505: LD_INT 100
11507: PPUSH
11508: CALL 73635 0 5
// veh := CreateVehicle ;
11512: LD_ADDR_VAR 0 2
11516: PUSH
11517: CALL_OW 45
11521: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11522: LD_VAR 0 2
11526: PPUSH
11527: LD_INT 3
11529: PPUSH
11530: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11534: LD_VAR 0 2
11538: PPUSH
11539: LD_INT 29
11541: PPUSH
11542: LD_INT 0
11544: PPUSH
11545: CALL_OW 49
// uc_nation := 3 ;
11549: LD_ADDR_OWVAR 21
11553: PUSH
11554: LD_INT 3
11556: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11557: LD_INT 0
11559: PPUSH
11560: LD_INT 10
11562: PPUSH
11563: CALL_OW 383
// un := CreateHuman ;
11567: LD_ADDR_VAR 0 3
11571: PUSH
11572: CALL_OW 44
11576: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11577: LD_VAR 0 3
11581: PPUSH
11582: LD_INT 105
11584: PPUSH
11585: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11589: LD_VAR 0 3
11593: PPUSH
11594: LD_INT 3
11596: PPUSH
11597: CALL_OW 259
11601: PUSH
11602: LD_INT 8
11604: PUSH
11605: LD_INT 9
11607: PUSH
11608: LD_INT 10
11610: PUSH
11611: EMPTY
11612: LIST
11613: LIST
11614: LIST
11615: PUSH
11616: LD_OWVAR 67
11620: ARRAY
11621: LESS
11622: IFFALSE 11656
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
11624: LD_VAR 0 3
11628: PPUSH
11629: LD_INT 3
11631: PPUSH
11632: LD_INT 8
11634: PUSH
11635: LD_INT 9
11637: PUSH
11638: LD_INT 10
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: PUSH
11646: LD_OWVAR 67
11650: ARRAY
11651: PPUSH
11652: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
11656: LD_VAR 0 3
11660: PPUSH
11661: LD_VAR 0 2
11665: PPUSH
11666: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11670: LD_ADDR_EXP 76
11674: PUSH
11675: LD_EXP 76
11679: PPUSH
11680: LD_VAR 0 2
11684: PPUSH
11685: CALL 106087 0 2
11689: ST_TO_ADDR
// end ;
11690: GO 11453
11692: POP
11693: POP
// end ;
11694: PPOPN 3
11696: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11697: LD_EXP 76
11701: IFFALSE 12210
11703: GO 11705
11705: DISABLE
11706: LD_INT 0
11708: PPUSH
11709: PPUSH
11710: PPUSH
// begin enable ;
11711: ENABLE
// if not ruMobile then
11712: LD_EXP 76
11716: NOT
11717: IFFALSE 11722
// begin disable ;
11719: DISABLE
// exit ;
11720: GO 12210
// end ; for i in ruMobile do
11722: LD_ADDR_VAR 0 1
11726: PUSH
11727: LD_EXP 76
11731: PUSH
11732: FOR_IN
11733: IFFALSE 12208
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11735: LD_VAR 0 1
11739: PPUSH
11740: CALL_OW 302
11744: NOT
11745: PUSH
11746: LD_VAR 0 1
11750: PPUSH
11751: CALL_OW 255
11755: PUSH
11756: LD_INT 3
11758: NONEQUAL
11759: OR
11760: IFFALSE 11780
// begin ruMobile := ruMobile diff i ;
11762: LD_ADDR_EXP 76
11766: PUSH
11767: LD_EXP 76
11771: PUSH
11772: LD_VAR 0 1
11776: DIFF
11777: ST_TO_ADDR
// continue ;
11778: GO 11732
// end ; if GetTag ( i ) = 300 then
11780: LD_VAR 0 1
11784: PPUSH
11785: CALL_OW 110
11789: PUSH
11790: LD_INT 300
11792: EQUAL
11793: IFFALSE 11843
// begin ComMoveXY ( i , 160 , 81 ) ;
11795: LD_VAR 0 1
11799: PPUSH
11800: LD_INT 160
11802: PPUSH
11803: LD_INT 81
11805: PPUSH
11806: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11810: LD_VAR 0 1
11814: PPUSH
11815: LD_INT 160
11817: PPUSH
11818: LD_INT 81
11820: PPUSH
11821: CALL_OW 297
11825: PUSH
11826: LD_INT 8
11828: LESS
11829: IFFALSE 11843
// SetTag ( i , 301 ) ;
11831: LD_VAR 0 1
11835: PPUSH
11836: LD_INT 301
11838: PPUSH
11839: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11843: LD_VAR 0 1
11847: PPUSH
11848: CALL_OW 110
11852: PUSH
11853: LD_INT 301
11855: EQUAL
11856: IFFALSE 11899
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11858: LD_VAR 0 1
11862: PPUSH
11863: LD_INT 33
11865: PPUSH
11866: CALL_OW 308
11870: NOT
11871: IFFALSE 11887
// ComMoveToArea ( i , ruMobileParkingArea ) else
11873: LD_VAR 0 1
11877: PPUSH
11878: LD_INT 33
11880: PPUSH
11881: CALL_OW 113
11885: GO 11899
// SetTag ( i , 302 ) ;
11887: LD_VAR 0 1
11891: PPUSH
11892: LD_INT 302
11894: PPUSH
11895: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11899: LD_VAR 0 1
11903: PPUSH
11904: CALL_OW 110
11908: PUSH
11909: LD_INT 302
11911: EQUAL
11912: IFFALSE 12042
// begin if GetLives ( i ) < 1000 then
11914: LD_VAR 0 1
11918: PPUSH
11919: CALL_OW 256
11923: PUSH
11924: LD_INT 1000
11926: LESS
11927: IFFALSE 12019
// begin if not IsDrivenBy ( i ) then
11929: LD_VAR 0 1
11933: PPUSH
11934: CALL_OW 311
11938: NOT
11939: IFFALSE 11943
// continue ;
11941: GO 11732
// mech := IsDrivenBy ( i ) ;
11943: LD_ADDR_VAR 0 2
11947: PUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 311
11957: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11958: LD_VAR 0 2
11962: PPUSH
11963: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11967: LD_VAR 0 2
11971: PPUSH
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11981: LD_INT 35
11983: PPUSH
11984: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11988: LD_VAR 0 1
11992: PPUSH
11993: CALL_OW 256
11997: PUSH
11998: LD_INT 1000
12000: EQUAL
12001: IFFALSE 11981
// ComEnterUnit ( mech , i ) ;
12003: LD_VAR 0 2
12007: PPUSH
12008: LD_VAR 0 1
12012: PPUSH
12013: CALL_OW 120
// end else
12017: GO 12042
// if IsDrivenBy ( i ) then
12019: LD_VAR 0 1
12023: PPUSH
12024: CALL_OW 311
12028: IFFALSE 12042
// SetTag ( i , 0 ) ;
12030: LD_VAR 0 1
12034: PPUSH
12035: LD_INT 0
12037: PPUSH
12038: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12042: LD_VAR 0 1
12046: PPUSH
12047: CALL_OW 110
12051: PUSH
12052: LD_INT 300
12054: LESS
12055: IFFALSE 12206
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12057: LD_ADDR_VAR 0 3
12061: PUSH
12062: LD_INT 4
12064: PPUSH
12065: LD_INT 81
12067: PUSH
12068: LD_INT 3
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PPUSH
12075: CALL_OW 70
12079: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 256
12089: PUSH
12090: LD_INT 650
12092: LESS
12093: IFFALSE 12118
// begin ComStop ( i ) ;
12095: LD_VAR 0 1
12099: PPUSH
12100: CALL_OW 141
// SetTag ( i , 300 ) ;
12104: LD_VAR 0 1
12108: PPUSH
12109: LD_INT 300
12111: PPUSH
12112: CALL_OW 109
// continue ;
12116: GO 11732
// end ; if enemy then
12118: LD_VAR 0 3
12122: IFFALSE 12162
// begin if not HasTask ( i ) then
12124: LD_VAR 0 1
12128: PPUSH
12129: CALL_OW 314
12133: NOT
12134: IFFALSE 12160
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12136: LD_VAR 0 1
12140: PPUSH
12141: LD_VAR 0 3
12145: PPUSH
12146: LD_VAR 0 1
12150: PPUSH
12151: CALL_OW 74
12155: PPUSH
12156: CALL_OW 115
// end else
12160: GO 12206
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12162: LD_VAR 0 1
12166: PPUSH
12167: LD_INT 158
12169: PUSH
12170: LD_INT 61
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 98
12179: PUSH
12180: LD_INT 100
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 78
12189: PUSH
12190: LD_INT 93
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL 108691 0 2
// end ; end ;
12206: GO 11732
12208: POP
12209: POP
// end ; end_of_file
12210: PPOPN 3
12212: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12213: LD_INT 0
12215: PPUSH
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
// side := 7 ;
12222: LD_ADDR_VAR 0 5
12226: PUSH
12227: LD_INT 7
12229: ST_TO_ADDR
// uc_side := side ;
12230: LD_ADDR_OWVAR 20
12234: PUSH
12235: LD_VAR 0 5
12239: ST_TO_ADDR
// uc_nation := 1 ;
12240: LD_ADDR_OWVAR 21
12244: PUSH
12245: LD_INT 1
12247: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12248: LD_ADDR_VAR 0 2
12252: PUSH
12253: LD_INT 22
12255: PUSH
12256: LD_VAR 0 5
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 21
12267: PUSH
12268: LD_INT 3
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: PPUSH
12279: CALL_OW 69
12283: PUSH
12284: FOR_IN
12285: IFFALSE 12301
// SetBLevel ( i , 10 ) ;
12287: LD_VAR 0 2
12291: PPUSH
12292: LD_INT 10
12294: PPUSH
12295: CALL_OW 241
12299: GO 12284
12301: POP
12302: POP
// base := GetBase ( al_depot ) ;
12303: LD_ADDR_VAR 0 4
12307: PUSH
12308: LD_INT 2
12310: PPUSH
12311: CALL_OW 274
12315: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12316: LD_ADDR_VAR 0 6
12320: PUSH
12321: LD_INT 22
12323: PUSH
12324: LD_VAR 0 5
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PUSH
12333: LD_INT 30
12335: PUSH
12336: LD_INT 34
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PPUSH
12347: CALL_OW 69
12351: ST_TO_ADDR
// if teleport then
12352: LD_VAR 0 6
12356: IFFALSE 12377
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12358: LD_VAR 0 6
12362: PUSH
12363: LD_INT 1
12365: ARRAY
12366: PPUSH
12367: LD_INT 262
12369: PPUSH
12370: LD_INT 119
12372: PPUSH
12373: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12377: LD_VAR 0 4
12381: PPUSH
12382: LD_INT 1
12384: PPUSH
12385: LD_INT 19500
12387: PPUSH
12388: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12392: LD_VAR 0 4
12396: PPUSH
12397: LD_INT 2
12399: PPUSH
12400: LD_INT 200
12402: PPUSH
12403: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12407: LD_VAR 0 4
12411: PPUSH
12412: LD_INT 3
12414: PPUSH
12415: LD_INT 650
12417: PPUSH
12418: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12422: LD_ADDR_EXP 77
12426: PUSH
12427: LD_STRING Roth
12429: PPUSH
12430: CALL_OW 25
12434: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12435: LD_ADDR_EXP 78
12439: PUSH
12440: LD_STRING Simms
12442: PPUSH
12443: LD_EXP 1
12447: NOT
12448: PPUSH
12449: LD_STRING 10c_
12451: PPUSH
12452: CALL 68795 0 3
12456: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12457: LD_EXP 78
12461: PPUSH
12462: LD_INT 4
12464: PPUSH
12465: CALL_OW 336
// if not Simms then
12469: LD_EXP 78
12473: NOT
12474: IFFALSE 12504
// begin uc_nation := 1 ;
12476: LD_ADDR_OWVAR 21
12480: PUSH
12481: LD_INT 1
12483: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12484: LD_INT 2
12486: PPUSH
12487: LD_INT 10
12489: PPUSH
12490: CALL_OW 384
// Simms := CreateHuman ;
12494: LD_ADDR_EXP 78
12498: PUSH
12499: CALL_OW 44
12503: ST_TO_ADDR
// end ; uc_nation := 3 ;
12504: LD_ADDR_OWVAR 21
12508: PUSH
12509: LD_INT 3
12511: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12512: LD_ADDR_EXP 79
12516: PUSH
12517: LD_STRING Kirilenkova
12519: PPUSH
12520: CALL_OW 25
12524: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12525: LD_ADDR_EXP 93
12529: PUSH
12530: LD_STRING Oblukov
12532: PPUSH
12533: CALL_OW 25
12537: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12538: LD_ADDR_EXP 80
12542: PUSH
12543: LD_STRING Dolgov
12545: PPUSH
12546: CALL_OW 25
12550: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12551: LD_ADDR_EXP 81
12555: PUSH
12556: LD_STRING Petrosyan
12558: PPUSH
12559: CALL_OW 25
12563: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12564: LD_ADDR_EXP 92
12568: PUSH
12569: LD_STRING Scholtze
12571: PPUSH
12572: CALL_OW 25
12576: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12577: LD_ADDR_EXP 91
12581: PUSH
12582: LD_STRING Kapitsova
12584: PPUSH
12585: CALL_OW 25
12589: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12590: LD_ADDR_EXP 82
12594: PUSH
12595: LD_STRING Petrovova
12597: PPUSH
12598: CALL_OW 25
12602: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12603: LD_ADDR_EXP 83
12607: PUSH
12608: LD_STRING Kuzmov
12610: PPUSH
12611: CALL_OW 25
12615: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12616: LD_ADDR_EXP 90
12620: PUSH
12621: LD_STRING Karamazov
12623: PPUSH
12624: CALL_OW 25
12628: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12629: LD_STRING 13_Lipshchin_1
12631: PPUSH
12632: LD_INT 0
12634: PPUSH
12635: CALL_OW 30
12639: IFFALSE 12654
// Lipshchin := NewCharacter ( Lipshchin ) ;
12641: LD_ADDR_EXP 84
12645: PUSH
12646: LD_STRING Lipshchin
12648: PPUSH
12649: CALL_OW 25
12653: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12654: LD_STRING 13_Titov_1
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 30
12664: IFFALSE 12679
// Titov := NewCharacter ( Titov ) ;
12666: LD_ADDR_EXP 86
12670: PUSH
12671: LD_STRING Titov
12673: PPUSH
12674: CALL_OW 25
12678: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12679: LD_STRING 13_Gnyevko_1
12681: PPUSH
12682: LD_INT 0
12684: PPUSH
12685: CALL_OW 30
12689: IFFALSE 12704
// Gnyevko := NewCharacter ( Gnyevko ) ;
12691: LD_ADDR_EXP 85
12695: PUSH
12696: LD_STRING Gnyevko
12698: PPUSH
12699: CALL_OW 25
12703: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12704: LD_STRING 13_Xavier_1
12706: PPUSH
12707: LD_INT 0
12709: PPUSH
12710: CALL_OW 30
12714: IFFALSE 12729
// Xavier := NewCharacter ( Xavier2 ) ;
12716: LD_ADDR_EXP 87
12720: PUSH
12721: LD_STRING Xavier2
12723: PPUSH
12724: CALL_OW 25
12728: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12729: LD_STRING 13_Belkov_1
12731: PPUSH
12732: LD_INT 0
12734: PPUSH
12735: CALL_OW 30
12739: IFFALSE 12754
// Belkov := NewCharacter ( Belkov ) ;
12741: LD_ADDR_EXP 88
12745: PUSH
12746: LD_STRING Belkov
12748: PPUSH
12749: CALL_OW 25
12753: ST_TO_ADDR
// if not BurlakStatus then
12754: LD_EXP 9
12758: NOT
12759: IFFALSE 12774
// Burlak = NewCharacter ( Burlak ) ;
12761: LD_ADDR_EXP 89
12765: PUSH
12766: LD_STRING Burlak
12768: PPUSH
12769: CALL_OW 25
12773: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12774: LD_ADDR_VAR 0 3
12778: PUSH
12779: LD_EXP 77
12783: PUSH
12784: LD_EXP 79
12788: PUSH
12789: LD_EXP 93
12793: PUSH
12794: LD_EXP 80
12798: PUSH
12799: LD_EXP 81
12803: PUSH
12804: LD_EXP 92
12808: PUSH
12809: LD_EXP 91
12813: PUSH
12814: LD_EXP 82
12818: PUSH
12819: LD_EXP 83
12823: PUSH
12824: LD_EXP 90
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: ST_TO_ADDR
// if Simms then
12841: LD_EXP 78
12845: IFFALSE 12863
// tmp := tmp ^ Simms ;
12847: LD_ADDR_VAR 0 3
12851: PUSH
12852: LD_VAR 0 3
12856: PUSH
12857: LD_EXP 78
12861: ADD
12862: ST_TO_ADDR
// if Titov then
12863: LD_EXP 86
12867: IFFALSE 12885
// tmp := tmp ^ Titov ;
12869: LD_ADDR_VAR 0 3
12873: PUSH
12874: LD_VAR 0 3
12878: PUSH
12879: LD_EXP 86
12883: ADD
12884: ST_TO_ADDR
// if Lipshchin then
12885: LD_EXP 84
12889: IFFALSE 12907
// tmp := tmp ^ Lipshchin ;
12891: LD_ADDR_VAR 0 3
12895: PUSH
12896: LD_VAR 0 3
12900: PUSH
12901: LD_EXP 84
12905: ADD
12906: ST_TO_ADDR
// if Gnyevko then
12907: LD_EXP 85
12911: IFFALSE 12929
// tmp := tmp ^ Gnyevko ;
12913: LD_ADDR_VAR 0 3
12917: PUSH
12918: LD_VAR 0 3
12922: PUSH
12923: LD_EXP 85
12927: ADD
12928: ST_TO_ADDR
// if Xavier then
12929: LD_EXP 87
12933: IFFALSE 12951
// tmp := tmp ^ Xavier ;
12935: LD_ADDR_VAR 0 3
12939: PUSH
12940: LD_VAR 0 3
12944: PUSH
12945: LD_EXP 87
12949: ADD
12950: ST_TO_ADDR
// if Belkov then
12951: LD_EXP 88
12955: IFFALSE 12973
// tmp := tmp ^ Belkov ;
12957: LD_ADDR_VAR 0 3
12961: PUSH
12962: LD_VAR 0 3
12966: PUSH
12967: LD_EXP 88
12971: ADD
12972: ST_TO_ADDR
// if Burlak then
12973: LD_EXP 89
12977: IFFALSE 12995
// tmp := tmp ^ Burlak ;
12979: LD_ADDR_VAR 0 3
12983: PUSH
12984: LD_VAR 0 3
12988: PUSH
12989: LD_EXP 89
12993: ADD
12994: ST_TO_ADDR
// for i = 1 to 11 do
12995: LD_ADDR_VAR 0 2
12999: PUSH
13000: DOUBLE
13001: LD_INT 1
13003: DEC
13004: ST_TO_ADDR
13005: LD_INT 11
13007: PUSH
13008: FOR_TO
13009: IFFALSE 13077
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13011: LD_ADDR_OWVAR 21
13015: PUSH
13016: LD_INT 1
13018: PUSH
13019: LD_INT 3
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PUSH
13026: LD_INT 1
13028: PPUSH
13029: LD_INT 2
13031: PPUSH
13032: CALL_OW 12
13036: ARRAY
13037: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13038: LD_INT 0
13040: PPUSH
13041: LD_INT 1
13043: PPUSH
13044: LD_INT 4
13046: PPUSH
13047: CALL_OW 12
13051: PPUSH
13052: LD_INT 10
13054: PPUSH
13055: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13059: LD_ADDR_VAR 0 3
13063: PUSH
13064: LD_VAR 0 3
13068: PUSH
13069: CALL_OW 44
13073: ADD
13074: ST_TO_ADDR
// end ;
13075: GO 13008
13077: POP
13078: POP
// for i in tmp do
13079: LD_ADDR_VAR 0 2
13083: PUSH
13084: LD_VAR 0 3
13088: PUSH
13089: FOR_IN
13090: IFFALSE 13115
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13092: LD_VAR 0 2
13096: PPUSH
13097: LD_INT 260
13099: PPUSH
13100: LD_INT 235
13102: PPUSH
13103: LD_INT 8
13105: PPUSH
13106: LD_INT 0
13108: PPUSH
13109: CALL_OW 50
13113: GO 13089
13115: POP
13116: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13117: LD_ADDR_EXP 100
13121: PUSH
13122: LD_EXP 100
13126: PPUSH
13127: LD_INT 1
13129: PPUSH
13130: LD_INT 22
13132: PUSH
13133: LD_VAR 0 5
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 3
13144: PUSH
13145: LD_INT 21
13147: PUSH
13148: LD_INT 2
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PUSH
13159: EMPTY
13160: LIST
13161: LIST
13162: PPUSH
13163: CALL_OW 69
13167: PUSH
13168: LD_EXP 77
13172: PUSH
13173: LD_EXP 78
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: DIFF
13182: PPUSH
13183: CALL_OW 1
13187: ST_TO_ADDR
// uc_side := 0 ;
13188: LD_ADDR_OWVAR 20
13192: PUSH
13193: LD_INT 0
13195: ST_TO_ADDR
// uc_nation := 0 ;
13196: LD_ADDR_OWVAR 21
13200: PUSH
13201: LD_INT 0
13203: ST_TO_ADDR
// for i = 1 to 5 do
13204: LD_ADDR_VAR 0 2
13208: PUSH
13209: DOUBLE
13210: LD_INT 1
13212: DEC
13213: ST_TO_ADDR
13214: LD_INT 5
13216: PUSH
13217: FOR_TO
13218: IFFALSE 13255
// begin InitHc ;
13220: CALL_OW 19
// hc_class := class_apeman ;
13224: LD_ADDR_OWVAR 28
13228: PUSH
13229: LD_INT 12
13231: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13232: CALL_OW 44
13236: PPUSH
13237: LD_INT 299
13239: PPUSH
13240: LD_INT 229
13242: PPUSH
13243: LD_INT 10
13245: PPUSH
13246: LD_INT 0
13248: PPUSH
13249: CALL_OW 50
// end ;
13253: GO 13217
13255: POP
13256: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13257: LD_EXP 77
13261: PPUSH
13262: LD_INT 259
13264: PPUSH
13265: LD_INT 235
13267: PPUSH
13268: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13272: LD_EXP 77
13276: PPUSH
13277: LD_INT 262
13279: PPUSH
13280: LD_INT 235
13282: PPUSH
13283: CALL_OW 178
// if Simms then
13287: LD_EXP 78
13291: IFFALSE 13322
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13293: LD_EXP 78
13297: PPUSH
13298: LD_INT 262
13300: PPUSH
13301: LD_INT 235
13303: PPUSH
13304: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13308: LD_EXP 78
13312: PPUSH
13313: LD_EXP 77
13317: PPUSH
13318: CALL_OW 179
// end ; uc_side := 7 ;
13322: LD_ADDR_OWVAR 20
13326: PUSH
13327: LD_INT 7
13329: ST_TO_ADDR
// uc_nation := 1 ;
13330: LD_ADDR_OWVAR 21
13334: PUSH
13335: LD_INT 1
13337: ST_TO_ADDR
// bc_type := b_control_tower ;
13338: LD_ADDR_OWVAR 42
13342: PUSH
13343: LD_INT 36
13345: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13346: LD_ADDR_VAR 0 7
13350: PUSH
13351: LD_INT 268
13353: PPUSH
13354: LD_INT 251
13356: PPUSH
13357: LD_INT 4
13359: PPUSH
13360: CALL_OW 47
13364: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13365: LD_INT 0
13367: PPUSH
13368: LD_INT 10
13370: PPUSH
13371: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13375: CALL_OW 44
13379: PPUSH
13380: LD_VAR 0 7
13384: PPUSH
13385: CALL_OW 52
// end ;
13389: LD_VAR 0 1
13393: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13394: LD_EXP 31
13398: PUSH
13399: LD_EXP 23
13403: NOT
13404: AND
13405: IFFALSE 13633
13407: GO 13409
13409: DISABLE
13410: LD_INT 0
13412: PPUSH
13413: PPUSH
13414: PPUSH
// begin enable ;
13415: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13416: LD_ADDR_VAR 0 2
13420: PUSH
13421: LD_INT 81
13423: PUSH
13424: LD_INT 7
13426: PUSH
13427: EMPTY
13428: LIST
13429: LIST
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: LD_INT 32
13436: PUSH
13437: LD_INT 3
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: LD_INT 30
13446: PUSH
13447: LD_INT 30
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 30
13456: PUSH
13457: LD_INT 28
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 34
13466: PUSH
13467: LD_INT 49
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 34
13476: PUSH
13477: LD_INT 10
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PUSH
13484: LD_INT 34
13486: PUSH
13487: LD_INT 8
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: LIST
13498: LIST
13499: LIST
13500: LIST
13501: LIST
13502: PUSH
13503: EMPTY
13504: LIST
13505: LIST
13506: PPUSH
13507: CALL_OW 69
13511: ST_TO_ADDR
// if not tmp then
13512: LD_VAR 0 2
13516: NOT
13517: IFFALSE 13521
// exit ;
13519: GO 13633
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13521: LD_VAR 0 2
13525: PPUSH
13526: LD_INT 34
13528: PUSH
13529: LD_INT 8
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PPUSH
13536: CALL_OW 72
13540: IFFALSE 13573
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13542: LD_ADDR_VAR 0 3
13546: PUSH
13547: LD_VAR 0 2
13551: PPUSH
13552: LD_INT 34
13554: PUSH
13555: LD_INT 8
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PPUSH
13562: CALL_OW 72
13566: PUSH
13567: LD_INT 1
13569: ARRAY
13570: ST_TO_ADDR
13571: GO 13597
// target := tmp [ rand ( 1 , tmp ) ] ;
13573: LD_ADDR_VAR 0 3
13577: PUSH
13578: LD_VAR 0 2
13582: PUSH
13583: LD_INT 1
13585: PPUSH
13586: LD_VAR 0 2
13590: PPUSH
13591: CALL_OW 12
13595: ARRAY
13596: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13597: LD_VAR 0 3
13601: PPUSH
13602: CALL_OW 255
13606: PUSH
13607: LD_INT 1
13609: EQUAL
13610: IFFALSE 13621
// CenterNowOnUnits ( target ) ;
13612: LD_VAR 0 3
13616: PPUSH
13617: CALL_OW 87
// SetLives ( target , 0 ) ;
13621: LD_VAR 0 3
13625: PPUSH
13626: LD_INT 0
13628: PPUSH
13629: CALL_OW 234
// end ;
13633: PPOPN 3
13635: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13636: LD_EXP 23
13640: NOT
13641: PUSH
13642: LD_EXP 31
13646: AND
13647: IFFALSE 14163
13649: GO 13651
13651: DISABLE
13652: LD_INT 0
13654: PPUSH
13655: PPUSH
13656: PPUSH
// begin uc_side := 7 ;
13657: LD_ADDR_OWVAR 20
13661: PUSH
13662: LD_INT 7
13664: ST_TO_ADDR
// uc_nation := 1 ;
13665: LD_ADDR_OWVAR 21
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
13673: LD_ADDR_VAR 0 3
13677: PUSH
13678: LD_INT 125
13680: PUSH
13681: LD_INT 163
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: PUSH
13688: LD_INT 185
13690: PUSH
13691: LD_INT 168
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PUSH
13698: LD_INT 111
13700: PUSH
13701: LD_INT 97
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: PUSH
13708: LD_INT 94
13710: PUSH
13711: LD_INT 114
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: PUSH
13718: EMPTY
13719: LIST
13720: LIST
13721: LIST
13722: LIST
13723: PPUSH
13724: CALL 106192 0 1
13728: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13729: LD_ADDR_EXP 94
13733: PUSH
13734: EMPTY
13735: ST_TO_ADDR
// for i = 1 to Difficulty do
13736: LD_ADDR_VAR 0 1
13740: PUSH
13741: DOUBLE
13742: LD_INT 1
13744: DEC
13745: ST_TO_ADDR
13746: LD_OWVAR 67
13750: PUSH
13751: FOR_TO
13752: IFFALSE 13910
// begin InitHc ;
13754: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13758: LD_INT 0
13760: PPUSH
13761: LD_INT 8
13763: PPUSH
13764: CALL_OW 381
// un := CreateHuman ;
13768: LD_ADDR_VAR 0 2
13772: PUSH
13773: CALL_OW 44
13777: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: LD_INT 258
13785: PPUSH
13786: LD_INT 267
13788: PPUSH
13789: LD_INT 4
13791: PPUSH
13792: LD_INT 0
13794: PPUSH
13795: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13799: LD_ADDR_EXP 94
13803: PUSH
13804: LD_EXP 94
13808: PUSH
13809: LD_VAR 0 2
13813: UNION
13814: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13815: LD_VAR 0 2
13819: PPUSH
13820: LD_VAR 0 3
13824: PUSH
13825: LD_VAR 0 1
13829: ARRAY
13830: PUSH
13831: LD_INT 1
13833: ARRAY
13834: PPUSH
13835: LD_VAR 0 3
13839: PUSH
13840: LD_VAR 0 1
13844: ARRAY
13845: PUSH
13846: LD_INT 2
13848: ARRAY
13849: PPUSH
13850: LD_INT 4
13852: PPUSH
13853: LD_INT 1
13855: PPUSH
13856: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13860: LD_VAR 0 2
13864: PPUSH
13865: LD_VAR 0 3
13869: PUSH
13870: LD_VAR 0 1
13874: ARRAY
13875: PUSH
13876: LD_INT 1
13878: ARRAY
13879: PPUSH
13880: LD_VAR 0 3
13884: PUSH
13885: LD_VAR 0 1
13889: ARRAY
13890: PUSH
13891: LD_INT 2
13893: ARRAY
13894: PPUSH
13895: CALL_OW 171
// AddComInvisible ( un ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 212
// end ;
13908: GO 13751
13910: POP
13911: POP
// repeat wait ( 0 0$45 ) ;
13912: LD_INT 1575
13914: PPUSH
13915: CALL_OW 67
// for i in allianceSpecialForce do
13919: LD_ADDR_VAR 0 1
13923: PUSH
13924: LD_EXP 94
13928: PUSH
13929: FOR_IN
13930: IFFALSE 14148
// begin if IsInvisible ( i ) then
13932: LD_VAR 0 1
13936: PPUSH
13937: CALL_OW 571
13941: IFFALSE 14117
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13943: LD_ADDR_VAR 0 3
13947: PUSH
13948: LD_INT 22
13950: PUSH
13951: LD_INT 1
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: PUSH
13958: LD_INT 50
13960: PUSH
13961: EMPTY
13962: LIST
13963: PUSH
13964: LD_INT 56
13966: PUSH
13967: EMPTY
13968: LIST
13969: PUSH
13970: LD_INT 91
13972: PUSH
13973: LD_VAR 0 1
13977: PUSH
13978: LD_INT 25
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 2
13988: PUSH
13989: LD_INT 25
13991: PUSH
13992: LD_INT 1
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 25
14001: PUSH
14002: LD_INT 2
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: LD_INT 25
14011: PUSH
14012: LD_INT 3
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 25
14021: PUSH
14022: LD_INT 4
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 25
14031: PUSH
14032: LD_INT 5
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 25
14041: PUSH
14042: LD_INT 8
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: LIST
14062: LIST
14063: LIST
14064: PPUSH
14065: CALL_OW 69
14069: ST_TO_ADDR
// if not tmp then
14070: LD_VAR 0 3
14074: NOT
14075: IFFALSE 14079
// continue ;
14077: GO 13929
// if Prob ( 30 * Difficulty ) then
14079: LD_INT 30
14081: PUSH
14082: LD_OWVAR 67
14086: MUL
14087: PPUSH
14088: CALL_OW 13
14092: IFFALSE 14117
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14094: LD_VAR 0 3
14098: PUSH
14099: LD_INT 1
14101: PPUSH
14102: LD_VAR 0 3
14106: PPUSH
14107: CALL_OW 12
14111: ARRAY
14112: PPUSH
14113: CALL 33978 0 1
// end ; if IsDead ( i ) then
14117: LD_VAR 0 1
14121: PPUSH
14122: CALL_OW 301
14126: IFFALSE 14146
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14128: LD_ADDR_EXP 94
14132: PUSH
14133: LD_EXP 94
14137: PUSH
14138: LD_VAR 0 1
14142: DIFF
14143: ST_TO_ADDR
// continue ;
14144: GO 13929
// end ; end ;
14146: GO 13929
14148: POP
14149: POP
// until allianceDestroyed or not allianceSpecialForce ;
14150: LD_EXP 23
14154: PUSH
14155: LD_EXP 94
14159: NOT
14160: OR
14161: IFFALSE 13912
// end ;
14163: PPOPN 3
14165: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14166: LD_EXP 31
14170: PUSH
14171: LD_INT 22
14173: PUSH
14174: LD_INT 1
14176: PUSH
14177: EMPTY
14178: LIST
14179: LIST
14180: PUSH
14181: LD_INT 2
14183: PUSH
14184: LD_INT 35
14186: PUSH
14187: LD_INT 8
14189: PUSH
14190: EMPTY
14191: LIST
14192: LIST
14193: PUSH
14194: LD_INT 34
14196: PUSH
14197: LD_INT 8
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: LIST
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PPUSH
14213: CALL_OW 69
14217: AND
14218: IFFALSE 14618
14220: GO 14222
14222: DISABLE
14223: LD_INT 0
14225: PPUSH
14226: PPUSH
14227: PPUSH
14228: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14229: LD_ADDR_VAR 0 1
14233: PUSH
14234: DOUBLE
14235: LD_INT 1
14237: DEC
14238: ST_TO_ADDR
14239: LD_INT 6
14241: PUSH
14242: LD_INT 8
14244: PUSH
14245: LD_INT 10
14247: PUSH
14248: LD_INT 12
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PUSH
14257: LD_OWVAR 67
14261: ARRAY
14262: PUSH
14263: FOR_TO
14264: IFFALSE 14456
// begin uc_side := 7 ;
14266: LD_ADDR_OWVAR 20
14270: PUSH
14271: LD_INT 7
14273: ST_TO_ADDR
// uc_nation := 1 ;
14274: LD_ADDR_OWVAR 21
14278: PUSH
14279: LD_INT 1
14281: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14282: LD_INT 5
14284: PPUSH
14285: LD_INT 3
14287: PPUSH
14288: LD_INT 2
14290: PUSH
14291: LD_INT 3
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: PUSH
14298: LD_INT 1
14300: PPUSH
14301: LD_INT 2
14303: PPUSH
14304: CALL_OW 12
14308: ARRAY
14309: PPUSH
14310: LD_INT 6
14312: PUSH
14313: LD_INT 9
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: PUSH
14320: LD_INT 1
14322: PPUSH
14323: LD_INT 2
14325: PPUSH
14326: CALL_OW 12
14330: ARRAY
14331: PPUSH
14332: LD_INT 100
14334: PPUSH
14335: CALL 73635 0 5
// un := CreateVehicle ;
14339: LD_ADDR_VAR 0 2
14343: PUSH
14344: CALL_OW 45
14348: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14349: LD_VAR 0 2
14353: PPUSH
14354: LD_INT 4
14356: PPUSH
14357: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14361: LD_VAR 0 2
14365: PPUSH
14366: LD_INT 307
14368: PPUSH
14369: LD_INT 219
14371: PPUSH
14372: LD_INT 6
14374: PPUSH
14375: LD_INT 0
14377: PPUSH
14378: CALL_OW 50
// if GetControl ( un ) = control_remote then
14382: LD_VAR 0 2
14386: PPUSH
14387: CALL_OW 263
14391: PUSH
14392: LD_INT 2
14394: EQUAL
14395: IFFALSE 14406
// Connect ( un ) ;
14397: LD_VAR 0 2
14401: PPUSH
14402: CALL 76726 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14406: LD_VAR 0 2
14410: PPUSH
14411: LD_INT 124
14413: PPUSH
14414: LD_INT 92
14416: PPUSH
14417: LD_INT 12
14419: PPUSH
14420: LD_INT 1
14422: PPUSH
14423: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14427: LD_ADDR_VAR 0 3
14431: PUSH
14432: LD_VAR 0 3
14436: PPUSH
14437: LD_VAR 0 2
14441: PPUSH
14442: CALL 106087 0 2
14446: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14447: LD_INT 10
14449: PPUSH
14450: CALL_OW 67
// end ;
14454: GO 14263
14456: POP
14457: POP
// repeat wait ( 0 0$2 ) ;
14458: LD_INT 70
14460: PPUSH
14461: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14465: LD_ADDR_VAR 0 4
14469: PUSH
14470: LD_INT 22
14472: PUSH
14473: LD_INT 1
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PUSH
14480: LD_INT 34
14482: PUSH
14483: LD_INT 8
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: PUSH
14490: EMPTY
14491: LIST
14492: LIST
14493: PPUSH
14494: CALL_OW 69
14498: ST_TO_ADDR
// if not e then
14499: LD_VAR 0 4
14503: NOT
14504: IFFALSE 14540
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14506: LD_ADDR_VAR 0 4
14510: PUSH
14511: LD_INT 22
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 21
14523: PUSH
14524: LD_INT 2
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PPUSH
14535: CALL_OW 69
14539: ST_TO_ADDR
// for i in tmp do
14540: LD_ADDR_VAR 0 1
14544: PUSH
14545: LD_VAR 0 3
14549: PUSH
14550: FOR_IN
14551: IFFALSE 14609
// if not IsOK ( i ) then
14553: LD_VAR 0 1
14557: PPUSH
14558: CALL_OW 302
14562: NOT
14563: IFFALSE 14583
// tmp := tmp diff i else
14565: LD_ADDR_VAR 0 3
14569: PUSH
14570: LD_VAR 0 3
14574: PUSH
14575: LD_VAR 0 1
14579: DIFF
14580: ST_TO_ADDR
14581: GO 14607
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
14583: LD_VAR 0 1
14587: PPUSH
14588: LD_VAR 0 4
14592: PPUSH
14593: LD_VAR 0 1
14597: PPUSH
14598: CALL_OW 74
14602: PPUSH
14603: CALL_OW 115
14607: GO 14550
14609: POP
14610: POP
// until not tmp ;
14611: LD_VAR 0 3
14615: NOT
14616: IFFALSE 14458
// end ;
14618: PPOPN 4
14620: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
14621: LD_EXP 23
14625: NOT
14626: PUSH
14627: LD_EXP 31
14631: AND
14632: IFFALSE 15582
14634: GO 14636
14636: DISABLE
14637: LD_INT 0
14639: PPUSH
14640: PPUSH
14641: PPUSH
14642: PPUSH
// begin enable ;
14643: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
14644: LD_INT 22
14646: PUSH
14647: LD_INT 7
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PUSH
14654: LD_INT 30
14656: PUSH
14657: LD_INT 3
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PPUSH
14668: CALL_OW 69
14672: NOT
14673: IFFALSE 14677
// exit ;
14675: GO 15582
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
14677: LD_ADDR_VAR 0 4
14681: PUSH
14682: LD_INT 22
14684: PUSH
14685: LD_INT 7
14687: PUSH
14688: EMPTY
14689: LIST
14690: LIST
14691: PUSH
14692: LD_INT 30
14694: PUSH
14695: LD_INT 34
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PUSH
14702: EMPTY
14703: LIST
14704: LIST
14705: PPUSH
14706: CALL_OW 69
14710: ST_TO_ADDR
// if Prob ( 40 ) then
14711: LD_INT 40
14713: PPUSH
14714: CALL_OW 13
14718: IFFALSE 14864
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
14720: LD_INT 1
14722: PPUSH
14723: LD_INT 5
14725: PUSH
14726: LD_INT 3
14728: PUSH
14729: LD_INT 2
14731: PUSH
14732: LD_INT 6
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: PUSH
14741: LD_INT 5
14743: PUSH
14744: LD_INT 3
14746: PUSH
14747: LD_INT 2
14749: PUSH
14750: LD_INT 6
14752: PUSH
14753: EMPTY
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 5
14761: PUSH
14762: LD_INT 3
14764: PUSH
14765: LD_INT 2
14767: PUSH
14768: LD_INT 6
14770: PUSH
14771: EMPTY
14772: LIST
14773: LIST
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 5
14779: PUSH
14780: LD_INT 3
14782: PUSH
14783: LD_INT 2
14785: PUSH
14786: LD_INT 9
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: PUSH
14795: LD_INT 24
14797: PUSH
14798: LD_INT 3
14800: PUSH
14801: LD_INT 3
14803: PUSH
14804: LD_INT 45
14806: PUSH
14807: EMPTY
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 24
14815: PUSH
14816: LD_INT 3
14818: PUSH
14819: LD_INT 3
14821: PUSH
14822: LD_INT 47
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 24
14833: PUSH
14834: LD_INT 3
14836: PUSH
14837: LD_INT 3
14839: PUSH
14840: LD_INT 45
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: PPUSH
14858: CALL 62369 0 2
// end else
14862: GO 15006
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 24
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: LD_INT 3
14875: PUSH
14876: LD_INT 47
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 24
14887: PUSH
14888: LD_INT 3
14890: PUSH
14891: LD_INT 3
14893: PUSH
14894: LD_INT 47
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 5
14905: PUSH
14906: LD_INT 3
14908: PUSH
14909: LD_INT 2
14911: PUSH
14912: LD_INT 9
14914: PUSH
14915: EMPTY
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: PUSH
14921: LD_INT 5
14923: PUSH
14924: LD_INT 3
14926: PUSH
14927: LD_INT 2
14929: PUSH
14930: LD_INT 9
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: LIST
14937: LIST
14938: PUSH
14939: LD_INT 5
14941: PUSH
14942: LD_INT 3
14944: PUSH
14945: LD_INT 2
14947: PUSH
14948: LD_INT 9
14950: PUSH
14951: EMPTY
14952: LIST
14953: LIST
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 24
14959: PUSH
14960: LD_INT 1
14962: PUSH
14963: LD_INT 3
14965: PUSH
14966: LD_INT 45
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: LIST
14973: LIST
14974: PUSH
14975: LD_INT 24
14977: PUSH
14978: LD_INT 1
14980: PUSH
14981: LD_INT 3
14983: PUSH
14984: LD_INT 45
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: PPUSH
15002: CALL 62369 0 2
// end ; repeat wait ( 0 0$1 ) ;
15006: LD_INT 35
15008: PPUSH
15009: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
15013: LD_INT 1
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL 63787 0 2
15023: PUSH
15024: LD_INT 7
15026: GREATEREQUAL
15027: IFFALSE 15006
// wait ( 0 0$10 ) ;
15029: LD_INT 350
15031: PPUSH
15032: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
15036: LD_ADDR_VAR 0 2
15040: PUSH
15041: LD_INT 1
15043: PPUSH
15044: LD_INT 1
15046: PPUSH
15047: CALL 63787 0 2
15051: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15052: LD_ADDR_EXP 119
15056: PUSH
15057: LD_EXP 119
15061: PPUSH
15062: LD_INT 1
15064: PPUSH
15065: LD_EXP 119
15069: PUSH
15070: LD_INT 1
15072: ARRAY
15073: PUSH
15074: LD_VAR 0 2
15078: DIFF
15079: PPUSH
15080: CALL_OW 1
15084: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15085: LD_ADDR_VAR 0 3
15089: PUSH
15090: LD_INT 0
15092: PPUSH
15093: LD_INT 1
15095: PPUSH
15096: CALL_OW 12
15100: ST_TO_ADDR
// if target then
15101: LD_VAR 0 3
15105: IFFALSE 15271
// begin for i in tmp do
15107: LD_ADDR_VAR 0 1
15111: PUSH
15112: LD_VAR 0 2
15116: PUSH
15117: FOR_IN
15118: IFFALSE 15143
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15120: LD_VAR 0 1
15124: PPUSH
15125: LD_INT 179
15127: PPUSH
15128: LD_INT 209
15130: PPUSH
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 1
15136: PPUSH
15137: CALL_OW 483
15141: GO 15117
15143: POP
15144: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15145: LD_ADDR_VAR 0 2
15149: PUSH
15150: LD_VAR 0 2
15154: PPUSH
15155: LD_INT 24
15157: PUSH
15158: LD_INT 250
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: PPUSH
15165: CALL_OW 72
15169: ST_TO_ADDR
// for i in tmp do
15170: LD_ADDR_VAR 0 1
15174: PUSH
15175: LD_VAR 0 2
15179: PUSH
15180: FOR_IN
15181: IFFALSE 15221
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15183: LD_VAR 0 1
15187: PPUSH
15188: LD_INT 179
15190: PPUSH
15191: LD_INT 209
15193: PPUSH
15194: CALL_OW 297
15198: PUSH
15199: LD_INT 9
15201: GREATER
15202: IFFALSE 15219
// ComMoveXY ( i , 179 , 209 ) ;
15204: LD_VAR 0 1
15208: PPUSH
15209: LD_INT 179
15211: PPUSH
15212: LD_INT 209
15214: PPUSH
15215: CALL_OW 111
15219: GO 15180
15221: POP
15222: POP
// wait ( 0 0$1 ) ;
15223: LD_INT 35
15225: PPUSH
15226: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
15230: LD_VAR 0 2
15234: PPUSH
15235: LD_INT 92
15237: PUSH
15238: LD_INT 179
15240: PUSH
15241: LD_INT 209
15243: PUSH
15244: LD_INT 9
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: PPUSH
15253: CALL_OW 72
15257: PUSH
15258: LD_VAR 0 2
15262: PUSH
15263: LD_INT 1
15265: MINUS
15266: GREATEREQUAL
15267: IFFALSE 15145
// end else
15269: GO 15433
// begin for i in tmp do
15271: LD_ADDR_VAR 0 1
15275: PUSH
15276: LD_VAR 0 2
15280: PUSH
15281: FOR_IN
15282: IFFALSE 15307
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15284: LD_VAR 0 1
15288: PPUSH
15289: LD_INT 285
15291: PPUSH
15292: LD_INT 163
15294: PPUSH
15295: LD_INT 8
15297: PPUSH
15298: LD_INT 1
15300: PPUSH
15301: CALL_OW 483
15305: GO 15281
15307: POP
15308: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15309: LD_ADDR_VAR 0 2
15313: PUSH
15314: LD_VAR 0 2
15318: PPUSH
15319: LD_INT 24
15321: PUSH
15322: LD_INT 250
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: PPUSH
15329: CALL_OW 72
15333: ST_TO_ADDR
// for i in tmp do
15334: LD_ADDR_VAR 0 1
15338: PUSH
15339: LD_VAR 0 2
15343: PUSH
15344: FOR_IN
15345: IFFALSE 15385
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 285
15354: PPUSH
15355: LD_INT 163
15357: PPUSH
15358: CALL_OW 297
15362: PUSH
15363: LD_INT 9
15365: GREATER
15366: IFFALSE 15383
// ComMoveXY ( i , 285 , 163 ) ;
15368: LD_VAR 0 1
15372: PPUSH
15373: LD_INT 285
15375: PPUSH
15376: LD_INT 163
15378: PPUSH
15379: CALL_OW 111
15383: GO 15344
15385: POP
15386: POP
// wait ( 0 0$1 ) ;
15387: LD_INT 35
15389: PPUSH
15390: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
15394: LD_VAR 0 2
15398: PPUSH
15399: LD_INT 92
15401: PUSH
15402: LD_INT 285
15404: PUSH
15405: LD_INT 163
15407: PUSH
15408: LD_INT 9
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: PPUSH
15417: CALL_OW 72
15421: PUSH
15422: LD_VAR 0 2
15426: PUSH
15427: LD_INT 1
15429: MINUS
15430: GREATEREQUAL
15431: IFFALSE 15309
// end ; repeat wait ( 0 0$1 ) ;
15433: LD_INT 35
15435: PPUSH
15436: CALL_OW 67
// for i in tmp do
15440: LD_ADDR_VAR 0 1
15444: PUSH
15445: LD_VAR 0 2
15449: PUSH
15450: FOR_IN
15451: IFFALSE 15573
// if GetLives ( i ) > 251 then
15453: LD_VAR 0 1
15457: PPUSH
15458: CALL_OW 256
15462: PUSH
15463: LD_INT 251
15465: GREATER
15466: IFFALSE 15555
// begin if GetWeapon ( i ) = ru_time_lapser then
15468: LD_VAR 0 1
15472: PPUSH
15473: CALL_OW 264
15477: PUSH
15478: LD_INT 49
15480: EQUAL
15481: IFFALSE 15519
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
15483: LD_VAR 0 1
15487: PPUSH
15488: LD_INT 81
15490: PUSH
15491: LD_INT 7
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PPUSH
15498: CALL_OW 69
15502: PPUSH
15503: LD_VAR 0 1
15507: PPUSH
15508: CALL_OW 74
15512: PPUSH
15513: CALL_OW 112
15517: GO 15553
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
15519: LD_VAR 0 1
15523: PPUSH
15524: LD_INT 81
15526: PUSH
15527: LD_INT 7
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PPUSH
15534: CALL_OW 69
15538: PPUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 74
15548: PPUSH
15549: CALL_OW 115
// end else
15553: GO 15571
// tmp := tmp diff i ;
15555: LD_ADDR_VAR 0 2
15559: PUSH
15560: LD_VAR 0 2
15564: PUSH
15565: LD_VAR 0 1
15569: DIFF
15570: ST_TO_ADDR
15571: GO 15450
15573: POP
15574: POP
// until not tmp ;
15575: LD_VAR 0 2
15579: NOT
15580: IFFALSE 15433
// end ;
15582: PPOPN 4
15584: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
15585: LD_EXP 31
15589: PUSH
15590: LD_EXP 77
15594: PPUSH
15595: CALL_OW 302
15599: AND
15600: PUSH
15601: LD_OWVAR 67
15605: PUSH
15606: LD_INT 2
15608: GREATER
15609: AND
15610: IFFALSE 15710
15612: GO 15614
15614: DISABLE
// begin enable ;
15615: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
15616: LD_EXP 77
15620: PPUSH
15621: LD_INT 245
15623: PPUSH
15624: LD_INT 234
15626: PPUSH
15627: CALL_OW 297
15631: PUSH
15632: LD_INT 6
15634: GREATER
15635: IFFALSE 15654
// ComMoveXY ( Roth , 245 , 234 ) else
15637: LD_EXP 77
15641: PPUSH
15642: LD_INT 245
15644: PPUSH
15645: LD_INT 234
15647: PPUSH
15648: CALL_OW 111
15652: GO 15710
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
15654: LD_EXP 77
15658: PPUSH
15659: LD_INT 259
15661: PUSH
15662: LD_INT 235
15664: PUSH
15665: EMPTY
15666: LIST
15667: LIST
15668: PUSH
15669: LD_INT 252
15671: PUSH
15672: LD_INT 209
15674: PUSH
15675: EMPTY
15676: LIST
15677: LIST
15678: PUSH
15679: LD_INT 275
15681: PUSH
15682: LD_INT 235
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: PUSH
15689: EMPTY
15690: LIST
15691: LIST
15692: LIST
15693: PUSH
15694: LD_INT 1
15696: PPUSH
15697: LD_INT 3
15699: PPUSH
15700: CALL_OW 12
15704: ARRAY
15705: PPUSH
15706: CALL 110089 0 2
// end ; end_of_file
15710: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
15711: LD_INT 0
15713: PPUSH
15714: PPUSH
15715: PPUSH
15716: PPUSH
// missionStage := 13 ;
15717: LD_ADDR_EXP 15
15721: PUSH
15722: LD_INT 13
15724: ST_TO_ADDR
// uc_side := 2 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 2
15732: ST_TO_ADDR
// uc_nation := 2 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 2
15740: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
15741: LD_ADDR_EXP 95
15745: PUSH
15746: LD_STRING Omar
15748: PPUSH
15749: CALL_OW 25
15753: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
15754: LD_EXP 95
15758: PPUSH
15759: LD_INT 4
15761: PPUSH
15762: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
15766: LD_EXP 95
15770: PPUSH
15771: LD_INT 242
15773: PPUSH
15774: LD_INT 75
15776: PPUSH
15777: LD_INT 0
15779: PPUSH
15780: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
15784: LD_ADDR_EXP 96
15788: PUSH
15789: LD_STRING Heike
15791: PPUSH
15792: CALL_OW 25
15796: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
15797: LD_INT 14
15799: PPUSH
15800: LD_INT 3
15802: PPUSH
15803: LD_INT 1
15805: PPUSH
15806: LD_INT 27
15808: PPUSH
15809: LD_INT 100
15811: PPUSH
15812: CALL 73635 0 5
// veh := CreateVehicle ;
15816: LD_ADDR_VAR 0 3
15820: PUSH
15821: CALL_OW 45
15825: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
15826: LD_VAR 0 3
15830: PPUSH
15831: LD_INT 2
15833: NEG
15834: PPUSH
15835: CALL_OW 242
// SetDir ( veh , 4 ) ;
15839: LD_VAR 0 3
15843: PPUSH
15844: LD_INT 4
15846: PPUSH
15847: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
15851: LD_VAR 0 3
15855: PPUSH
15856: LD_INT 241
15858: PPUSH
15859: LD_INT 72
15861: PPUSH
15862: LD_INT 0
15864: PPUSH
15865: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
15869: LD_EXP 96
15873: PPUSH
15874: LD_VAR 0 3
15878: PPUSH
15879: CALL_OW 52
// if KhatamStatus then
15883: LD_EXP 8
15887: IFFALSE 15950
// begin Khatam := NewCharacter ( Khatam ) ;
15889: LD_ADDR_EXP 97
15893: PUSH
15894: LD_STRING Khatam
15896: PPUSH
15897: CALL_OW 25
15901: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
15902: LD_EXP 97
15906: PPUSH
15907: LD_INT 245
15909: PPUSH
15910: LD_INT 78
15912: PPUSH
15913: LD_INT 3
15915: PPUSH
15916: LD_INT 0
15918: PPUSH
15919: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
15923: LD_EXP 97
15927: PPUSH
15928: LD_INT 4
15930: PPUSH
15931: LD_INT 10
15933: PPUSH
15934: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
15938: LD_EXP 97
15942: PPUSH
15943: LD_INT 4
15945: PPUSH
15946: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15950: LD_ADDR_VAR 0 2
15954: PUSH
15955: DOUBLE
15956: LD_INT 1
15958: DEC
15959: ST_TO_ADDR
15960: LD_INT 2
15962: PUSH
15963: LD_INT 2
15965: PUSH
15966: LD_INT 3
15968: PUSH
15969: LD_INT 3
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: PUSH
15978: LD_OWVAR 67
15982: ARRAY
15983: PUSH
15984: FOR_TO
15985: IFFALSE 16051
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15987: LD_INT 0
15989: PPUSH
15990: LD_INT 6
15992: PUSH
15993: LD_OWVAR 67
15997: PLUS
15998: PPUSH
15999: CALL_OW 384
// un := CreateHuman ;
16003: LD_ADDR_VAR 0 4
16007: PUSH
16008: CALL_OW 44
16012: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16013: LD_VAR 0 4
16017: PPUSH
16018: LD_INT 28
16020: PUSH
16021: LD_INT 29
16023: PUSH
16024: EMPTY
16025: LIST
16026: LIST
16027: PUSH
16028: LD_VAR 0 2
16032: PUSH
16033: LD_INT 2
16035: MOD
16036: PUSH
16037: LD_INT 1
16039: PLUS
16040: ARRAY
16041: PPUSH
16042: LD_INT 0
16044: PPUSH
16045: CALL_OW 49
// end ;
16049: GO 15984
16051: POP
16052: POP
// for i = 1 to 6 do
16053: LD_ADDR_VAR 0 2
16057: PUSH
16058: DOUBLE
16059: LD_INT 1
16061: DEC
16062: ST_TO_ADDR
16063: LD_INT 6
16065: PUSH
16066: FOR_TO
16067: IFFALSE 16112
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16069: LD_INT 0
16071: PPUSH
16072: LD_INT 6
16074: PUSH
16075: LD_OWVAR 67
16079: PLUS
16080: PPUSH
16081: CALL_OW 381
// un := CreateHuman ;
16085: LD_ADDR_VAR 0 4
16089: PUSH
16090: CALL_OW 44
16094: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16095: LD_VAR 0 4
16099: PPUSH
16100: LD_INT 32
16102: PPUSH
16103: LD_INT 0
16105: PPUSH
16106: CALL_OW 49
// end ;
16110: GO 16066
16112: POP
16113: POP
// for i = 1 to 3 do
16114: LD_ADDR_VAR 0 2
16118: PUSH
16119: DOUBLE
16120: LD_INT 1
16122: DEC
16123: ST_TO_ADDR
16124: LD_INT 3
16126: PUSH
16127: FOR_TO
16128: IFFALSE 16176
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16130: LD_INT 0
16132: PPUSH
16133: LD_INT 8
16135: PPUSH
16136: LD_INT 6
16138: PUSH
16139: LD_OWVAR 67
16143: PLUS
16144: PPUSH
16145: CALL_OW 380
// un := CreateHuman ;
16149: LD_ADDR_VAR 0 4
16153: PUSH
16154: CALL_OW 44
16158: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16159: LD_VAR 0 4
16163: PPUSH
16164: LD_INT 32
16166: PPUSH
16167: LD_INT 0
16169: PPUSH
16170: CALL_OW 49
// end ;
16174: GO 16127
16176: POP
16177: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16178: LD_ADDR_VAR 0 2
16182: PUSH
16183: DOUBLE
16184: LD_INT 1
16186: DEC
16187: ST_TO_ADDR
16188: LD_INT 2
16190: PUSH
16191: LD_INT 3
16193: PUSH
16194: LD_INT 4
16196: PUSH
16197: LD_INT 4
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: LIST
16204: LIST
16205: PUSH
16206: LD_OWVAR 67
16210: ARRAY
16211: PUSH
16212: FOR_TO
16213: IFFALSE 16303
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16215: LD_INT 14
16217: PPUSH
16218: LD_INT 2
16220: PPUSH
16221: LD_INT 1
16223: PPUSH
16224: LD_INT 28
16226: PPUSH
16227: LD_INT 80
16229: PPUSH
16230: CALL 73635 0 5
// veh := CreateVehicle ;
16234: LD_ADDR_VAR 0 3
16238: PUSH
16239: CALL_OW 45
16243: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16244: LD_VAR 0 3
16248: PPUSH
16249: LD_INT 3
16251: PPUSH
16252: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16256: LD_VAR 0 3
16260: PPUSH
16261: LD_INT 29
16263: PPUSH
16264: LD_INT 0
16266: PPUSH
16267: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16271: LD_INT 0
16273: PPUSH
16274: LD_INT 6
16276: PUSH
16277: LD_OWVAR 67
16281: PLUS
16282: PPUSH
16283: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16287: CALL_OW 44
16291: PPUSH
16292: LD_VAR 0 3
16296: PPUSH
16297: CALL_OW 52
// end ;
16301: GO 16212
16303: POP
16304: POP
// for i = 1 to 5 + Difficulty do
16305: LD_ADDR_VAR 0 2
16309: PUSH
16310: DOUBLE
16311: LD_INT 1
16313: DEC
16314: ST_TO_ADDR
16315: LD_INT 5
16317: PUSH
16318: LD_OWVAR 67
16322: PLUS
16323: PUSH
16324: FOR_TO
16325: IFFALSE 16452
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16327: LD_INT 14
16329: PPUSH
16330: LD_INT 1
16332: PPUSH
16333: LD_INT 3
16335: PPUSH
16336: CALL_OW 12
16340: PPUSH
16341: LD_INT 1
16343: PPUSH
16344: LD_INT 28
16346: PUSH
16347: LD_INT 26
16349: PUSH
16350: LD_INT 27
16352: PUSH
16353: LD_INT 25
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: LIST
16360: LIST
16361: PUSH
16362: LD_VAR 0 2
16366: PUSH
16367: LD_INT 4
16369: MOD
16370: PUSH
16371: LD_INT 1
16373: PLUS
16374: ARRAY
16375: PPUSH
16376: LD_INT 80
16378: PPUSH
16379: CALL 73635 0 5
// veh := CreateVehicle ;
16383: LD_ADDR_VAR 0 3
16387: PUSH
16388: CALL_OW 45
16392: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16393: LD_VAR 0 3
16397: PPUSH
16398: LD_INT 4
16400: PPUSH
16401: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16405: LD_VAR 0 3
16409: PPUSH
16410: LD_INT 28
16412: PPUSH
16413: LD_INT 0
16415: PPUSH
16416: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16420: LD_INT 0
16422: PPUSH
16423: LD_INT 6
16425: PUSH
16426: LD_OWVAR 67
16430: PLUS
16431: PPUSH
16432: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16436: CALL_OW 44
16440: PPUSH
16441: LD_VAR 0 3
16445: PPUSH
16446: CALL_OW 52
// end ;
16450: GO 16324
16452: POP
16453: POP
// for i = 1 to Difficulty do
16454: LD_ADDR_VAR 0 2
16458: PUSH
16459: DOUBLE
16460: LD_INT 1
16462: DEC
16463: ST_TO_ADDR
16464: LD_OWVAR 67
16468: PUSH
16469: FOR_TO
16470: IFFALSE 16530
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
16472: LD_INT 14
16474: PPUSH
16475: LD_INT 3
16477: PPUSH
16478: LD_INT 5
16480: PPUSH
16481: LD_INT 29
16483: PPUSH
16484: LD_INT 80
16486: PPUSH
16487: CALL 73635 0 5
// veh := CreateVehicle ;
16491: LD_ADDR_VAR 0 3
16495: PUSH
16496: CALL_OW 45
16500: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16501: LD_VAR 0 3
16505: PPUSH
16506: LD_INT 4
16508: PPUSH
16509: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16513: LD_VAR 0 3
16517: PPUSH
16518: LD_INT 28
16520: PPUSH
16521: LD_INT 0
16523: PPUSH
16524: CALL_OW 49
// end ;
16528: GO 16469
16530: POP
16531: POP
// end ;
16532: LD_VAR 0 1
16536: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
16537: LD_INT 22
16539: PUSH
16540: LD_INT 2
16542: PUSH
16543: EMPTY
16544: LIST
16545: LIST
16546: PPUSH
16547: CALL_OW 69
16551: IFFALSE 16930
16553: GO 16555
16555: DISABLE
16556: LD_INT 0
16558: PPUSH
16559: PPUSH
16560: PPUSH
16561: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
16562: LD_ADDR_VAR 0 3
16566: PUSH
16567: LD_INT 22
16569: PUSH
16570: LD_INT 2
16572: PUSH
16573: EMPTY
16574: LIST
16575: LIST
16576: PUSH
16577: LD_INT 25
16579: PUSH
16580: LD_INT 4
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: PUSH
16587: EMPTY
16588: LIST
16589: LIST
16590: PPUSH
16591: CALL_OW 69
16595: PUSH
16596: LD_EXP 97
16600: DIFF
16601: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
16602: LD_ADDR_VAR 0 2
16606: PUSH
16607: LD_INT 22
16609: PUSH
16610: LD_INT 2
16612: PUSH
16613: EMPTY
16614: LIST
16615: LIST
16616: PPUSH
16617: CALL_OW 69
16621: PUSH
16622: LD_EXP 97
16626: PUSH
16627: LD_VAR 0 3
16631: UNION
16632: DIFF
16633: ST_TO_ADDR
// if Khatam then
16634: LD_EXP 97
16638: IFFALSE 16655
// ComMoveXY ( Khatam , 211 , 92 ) ;
16640: LD_EXP 97
16644: PPUSH
16645: LD_INT 211
16647: PPUSH
16648: LD_INT 92
16650: PPUSH
16651: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
16655: LD_INT 197
16657: PPUSH
16658: LD_INT 80
16660: PPUSH
16661: LD_INT 2
16663: PPUSH
16664: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
16668: LD_INT 213
16670: PPUSH
16671: LD_INT 90
16673: PPUSH
16674: LD_INT 2
16676: PPUSH
16677: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
16681: LD_INT 215
16683: PPUSH
16684: LD_INT 129
16686: PPUSH
16687: LD_INT 2
16689: PPUSH
16690: CALL_OW 441
// if sci then
16694: LD_VAR 0 3
16698: IFFALSE 16719
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
16700: LD_VAR 0 3
16704: PUSH
16705: LD_INT 1
16707: ARRAY
16708: PPUSH
16709: LD_INT 197
16711: PPUSH
16712: LD_INT 80
16714: PPUSH
16715: CALL_OW 158
// if sci > 1 then
16719: LD_VAR 0 3
16723: PUSH
16724: LD_INT 1
16726: GREATER
16727: IFFALSE 16748
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
16729: LD_VAR 0 3
16733: PUSH
16734: LD_INT 2
16736: ARRAY
16737: PPUSH
16738: LD_INT 213
16740: PPUSH
16741: LD_INT 90
16743: PPUSH
16744: CALL_OW 158
// if sci > 2 then
16748: LD_VAR 0 3
16752: PUSH
16753: LD_INT 2
16755: GREATER
16756: IFFALSE 16777
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
16758: LD_VAR 0 3
16762: PUSH
16763: LD_INT 3
16765: ARRAY
16766: PPUSH
16767: LD_INT 215
16769: PPUSH
16770: LD_INT 129
16772: PPUSH
16773: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
16777: LD_VAR 0 2
16781: PPUSH
16782: LD_INT 195
16784: PPUSH
16785: LD_INT 102
16787: PPUSH
16788: CALL_OW 114
// wait ( 0 0$5 ) ;
16792: LD_INT 175
16794: PPUSH
16795: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
16799: LD_INT 70
16801: PPUSH
16802: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
16806: LD_ADDR_VAR 0 4
16810: PUSH
16811: LD_INT 92
16813: PUSH
16814: LD_INT 195
16816: PUSH
16817: LD_INT 102
16819: PUSH
16820: LD_INT 36
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: PUSH
16829: LD_INT 22
16831: PUSH
16832: LD_INT 1
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PPUSH
16843: CALL_OW 69
16847: ST_TO_ADDR
// for i in tmp do
16848: LD_ADDR_VAR 0 1
16852: PUSH
16853: LD_VAR 0 2
16857: PUSH
16858: FOR_IN
16859: IFFALSE 16910
// if enemy then
16861: LD_VAR 0 4
16865: IFFALSE 16893
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16867: LD_VAR 0 1
16871: PPUSH
16872: LD_VAR 0 4
16876: PPUSH
16877: LD_VAR 0 1
16881: PPUSH
16882: CALL_OW 74
16886: PPUSH
16887: CALL_OW 115
16891: GO 16908
// ComAgressiveMove ( i , 195 , 102 ) ;
16893: LD_VAR 0 1
16897: PPUSH
16898: LD_INT 195
16900: PPUSH
16901: LD_INT 102
16903: PPUSH
16904: CALL_OW 114
16908: GO 16858
16910: POP
16911: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
16912: LD_VAR 0 2
16916: PPUSH
16917: LD_INT 50
16919: PUSH
16920: EMPTY
16921: LIST
16922: PPUSH
16923: CALL_OW 72
16927: NOT
16928: IFFALSE 16799
// end ; end_of_file
16930: PPOPN 4
16932: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
16933: LD_INT 0
16935: PPUSH
16936: PPUSH
16937: PPUSH
16938: PPUSH
16939: PPUSH
16940: PPUSH
16941: PPUSH
16942: PPUSH
16943: PPUSH
// Video ( true ) ;
16944: LD_INT 1
16946: PPUSH
16947: CALL 106059 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16951: LD_ADDR_VAR 0 5
16955: PUSH
16956: LD_INT 7
16958: PPUSH
16959: LD_INT 0
16961: PPUSH
16962: CALL_OW 517
16966: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16967: LD_ADDR_VAR 0 2
16971: PUSH
16972: DOUBLE
16973: LD_INT 1
16975: DEC
16976: ST_TO_ADDR
16977: LD_VAR 0 5
16981: PUSH
16982: LD_INT 1
16984: ARRAY
16985: PUSH
16986: FOR_TO
16987: IFFALSE 17032
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16989: LD_VAR 0 5
16993: PUSH
16994: LD_INT 1
16996: ARRAY
16997: PUSH
16998: LD_VAR 0 2
17002: ARRAY
17003: PPUSH
17004: LD_VAR 0 5
17008: PUSH
17009: LD_INT 2
17011: ARRAY
17012: PUSH
17013: LD_VAR 0 2
17017: ARRAY
17018: PPUSH
17019: LD_INT 1
17021: PPUSH
17022: LD_INT 15
17024: NEG
17025: PPUSH
17026: CALL 105973 0 4
17030: GO 16986
17032: POP
17033: POP
// CenterNowOnUnits ( Powell ) ;
17034: LD_EXP 60
17038: PPUSH
17039: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17043: LD_ADDR_VAR 0 5
17047: PUSH
17048: LD_EXP 58
17052: PUSH
17053: EMPTY
17054: LIST
17055: ST_TO_ADDR
// if GirlNewVeh then
17056: LD_EXP 59
17060: IFFALSE 17078
// tmp := tmp ^ GirlNewVeh ;
17062: LD_ADDR_VAR 0 5
17066: PUSH
17067: LD_VAR 0 5
17071: PUSH
17072: LD_EXP 59
17076: ADD
17077: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17078: LD_VAR 0 5
17082: PPUSH
17083: LD_INT 60
17085: PPUSH
17086: LD_INT 109
17088: PPUSH
17089: CALL_OW 111
// if KappaStatus then
17093: LD_EXP 2
17097: IFFALSE 17149
// begin Say ( JMM , D1nT-JMM-1 ) ;
17099: LD_EXP 40
17103: PPUSH
17104: LD_STRING D1nT-JMM-1
17106: PPUSH
17107: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17111: LD_EXP 60
17115: PPUSH
17116: LD_STRING D1T-Pow-1
17118: PPUSH
17119: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17123: LD_EXP 40
17127: PPUSH
17128: LD_STRING D1T-JMM-2
17130: PPUSH
17131: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17135: LD_EXP 60
17139: PPUSH
17140: LD_STRING D1T-Pow-2
17142: PPUSH
17143: CALL_OW 88
// end else
17147: GO 17355
// if JMMGirlStatus then
17149: LD_EXP 6
17153: IFFALSE 17298
// begin Say ( JMM , D1T-JMM-1 ) ;
17155: LD_EXP 40
17159: PPUSH
17160: LD_STRING D1T-JMM-1
17162: PPUSH
17163: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17167: LD_EXP 60
17171: PPUSH
17172: LD_STRING D1T-Pow-1
17174: PPUSH
17175: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17179: LD_EXP 40
17183: PPUSH
17184: LD_STRING D1T-JMM-3
17186: PPUSH
17187: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17191: LD_EXP 60
17195: PPUSH
17196: LD_STRING D1T-Pow-3
17198: PPUSH
17199: CALL_OW 88
// if JMMGirl then
17203: LD_EXP 7
17207: IFFALSE 17296
// begin case JMMGirl of 1 :
17209: LD_EXP 7
17213: PUSH
17214: LD_INT 1
17216: DOUBLE
17217: EQUAL
17218: IFTRUE 17222
17220: GO 17237
17222: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17223: LD_EXP 41
17227: PPUSH
17228: LD_STRING D1T-Joan-3
17230: PPUSH
17231: CALL_OW 88
17235: GO 17284
17237: LD_INT 2
17239: DOUBLE
17240: EQUAL
17241: IFTRUE 17245
17243: GO 17260
17245: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17246: LD_EXP 43
17250: PPUSH
17251: LD_STRING D1T-Lisa-3
17253: PPUSH
17254: CALL_OW 88
17258: GO 17284
17260: LD_INT 3
17262: DOUBLE
17263: EQUAL
17264: IFTRUE 17268
17266: GO 17283
17268: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17269: LD_EXP 55
17273: PPUSH
17274: LD_STRING D1T-Con-3
17276: PPUSH
17277: CALL_OW 88
17281: GO 17284
17283: POP
// Say ( Powell , D1T-Pow-4 ) ;
17284: LD_EXP 60
17288: PPUSH
17289: LD_STRING D1T-Pow-4
17291: PPUSH
17292: CALL_OW 88
// end ; end else
17296: GO 17355
// if not FastEnd then
17298: LD_EXP 11
17302: NOT
17303: IFFALSE 17331
// begin Say ( JMM , D1T-JMM-4 ) ;
17305: LD_EXP 40
17309: PPUSH
17310: LD_STRING D1T-JMM-4
17312: PPUSH
17313: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17317: LD_EXP 60
17321: PPUSH
17322: LD_STRING D1T-Pow-5
17324: PPUSH
17325: CALL_OW 88
// end else
17329: GO 17355
// begin Say ( JMM , D1nT-JMM-1 ) ;
17331: LD_EXP 40
17335: PPUSH
17336: LD_STRING D1nT-JMM-1
17338: PPUSH
17339: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17343: LD_EXP 60
17347: PPUSH
17348: LD_STRING D1nT-Pow-1
17350: PPUSH
17351: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17355: LD_INT 3
17357: PPUSH
17358: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17362: LD_EXP 58
17366: PPUSH
17367: CALL_OW 314
17371: NOT
17372: IFFALSE 17355
// ComExitVehicle ( JMM ) ;
17374: LD_EXP 40
17378: PPUSH
17379: CALL_OW 121
// repeat wait ( 3 ) ;
17383: LD_INT 3
17385: PPUSH
17386: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17390: LD_EXP 40
17394: PPUSH
17395: CALL_OW 310
17399: NOT
17400: IFFALSE 17383
// ComMoveXY ( JMM , 60 , 94 ) ;
17402: LD_EXP 40
17406: PPUSH
17407: LD_INT 60
17409: PPUSH
17410: LD_INT 94
17412: PPUSH
17413: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17417: LD_EXP 40
17421: PPUSH
17422: LD_EXP 60
17426: PPUSH
17427: CALL_OW 179
// if Joan then
17431: LD_EXP 41
17435: IFFALSE 17489
// begin ComExitVehicle ( Joan ) ;
17437: LD_EXP 41
17441: PPUSH
17442: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17446: LD_EXP 41
17450: PPUSH
17451: LD_INT 35
17453: PPUSH
17454: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17458: LD_EXP 41
17462: PPUSH
17463: LD_INT 65
17465: PPUSH
17466: LD_INT 104
17468: PPUSH
17469: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
17473: LD_EXP 41
17477: PPUSH
17478: LD_EXP 40
17482: PPUSH
17483: CALL_OW 179
// end else
17487: GO 17623
// if Lisa and JMMGirl = 2 then
17489: LD_EXP 43
17493: PUSH
17494: LD_EXP 7
17498: PUSH
17499: LD_INT 2
17501: EQUAL
17502: AND
17503: IFFALSE 17557
// begin ComExitVehicle ( Lisa ) ;
17505: LD_EXP 43
17509: PPUSH
17510: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
17514: LD_EXP 43
17518: PPUSH
17519: LD_INT 35
17521: PPUSH
17522: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
17526: LD_EXP 43
17530: PPUSH
17531: LD_INT 65
17533: PPUSH
17534: LD_INT 104
17536: PPUSH
17537: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
17541: LD_EXP 43
17545: PPUSH
17546: LD_EXP 40
17550: PPUSH
17551: CALL_OW 179
// end else
17555: GO 17623
// if Connie and JMMGirl = 3 then
17557: LD_EXP 55
17561: PUSH
17562: LD_EXP 7
17566: PUSH
17567: LD_INT 3
17569: EQUAL
17570: AND
17571: IFFALSE 17623
// begin ComExitVehicle ( Connie ) ;
17573: LD_EXP 55
17577: PPUSH
17578: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
17582: LD_EXP 55
17586: PPUSH
17587: LD_INT 35
17589: PPUSH
17590: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
17594: LD_EXP 55
17598: PPUSH
17599: LD_INT 65
17601: PPUSH
17602: LD_INT 104
17604: PPUSH
17605: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
17609: LD_EXP 55
17613: PPUSH
17614: LD_EXP 40
17618: PPUSH
17619: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
17623: LD_INT 35
17625: PPUSH
17626: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
17630: LD_EXP 40
17634: PPUSH
17635: LD_EXP 60
17639: PPUSH
17640: CALL_OW 296
17644: PUSH
17645: LD_INT 8
17647: LESS
17648: IFFALSE 17623
// wait ( 0 0$0.5 ) ;
17650: LD_INT 18
17652: PPUSH
17653: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
17657: LD_EXP 40
17661: PPUSH
17662: LD_STRING D1-JMM-1
17664: PPUSH
17665: CALL_OW 88
// async ;
17669: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
17670: LD_EXP 60
17674: PPUSH
17675: LD_STRING D1-Pow-1
17677: PPUSH
17678: CALL_OW 88
// if not dialogue_skipped then
17682: LD_OWVAR 59
17686: NOT
17687: IFFALSE 17696
// wait ( 0 0$2 ) ;
17689: LD_INT 70
17691: PPUSH
17692: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
17696: LD_INT 170
17698: PPUSH
17699: LD_INT 99
17701: PPUSH
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 6
17707: NEG
17708: PPUSH
17709: CALL 105973 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
17713: LD_INT 174
17715: PPUSH
17716: LD_INT 115
17718: PPUSH
17719: LD_INT 1
17721: PPUSH
17722: LD_INT 6
17724: NEG
17725: PPUSH
17726: CALL 105973 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
17730: LD_INT 169
17732: PPUSH
17733: LD_INT 71
17735: PPUSH
17736: LD_INT 1
17738: PPUSH
17739: LD_INT 6
17741: NEG
17742: PPUSH
17743: CALL 105973 0 4
// if not dialogue_skipped then
17747: LD_OWVAR 59
17751: NOT
17752: IFFALSE 17771
// begin CenterOnXY ( 170 , 99 ) ;
17754: LD_INT 170
17756: PPUSH
17757: LD_INT 99
17759: PPUSH
17760: CALL_OW 84
// wait ( 0 0$2.3 ) ;
17764: LD_INT 80
17766: PPUSH
17767: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
17771: LD_INT 75
17773: PPUSH
17774: LD_INT 53
17776: PPUSH
17777: LD_INT 1
17779: PPUSH
17780: LD_INT 9
17782: NEG
17783: PPUSH
17784: CALL 105973 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
17788: LD_INT 54
17790: PPUSH
17791: LD_INT 42
17793: PPUSH
17794: LD_INT 1
17796: PPUSH
17797: LD_INT 9
17799: NEG
17800: PPUSH
17801: CALL 105973 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
17805: LD_INT 62
17807: PPUSH
17808: LD_INT 51
17810: PPUSH
17811: LD_INT 1
17813: PPUSH
17814: LD_INT 9
17816: NEG
17817: PPUSH
17818: CALL 105973 0 4
// if not dialogue_skipped then
17822: LD_OWVAR 59
17826: NOT
17827: IFFALSE 17846
// begin CenterOnXY ( 75 , 53 ) ;
17829: LD_INT 75
17831: PPUSH
17832: LD_INT 53
17834: PPUSH
17835: CALL_OW 84
// wait ( 0 0$4 ) ;
17839: LD_INT 140
17841: PPUSH
17842: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
17846: LD_EXP 60
17850: PPUSH
17851: CALL_OW 87
// if not dialogue_skipped then
17855: LD_OWVAR 59
17859: NOT
17860: IFFALSE 17869
// wait ( 0 0$2 ) ;
17862: LD_INT 70
17864: PPUSH
17865: CALL_OW 67
// sync ;
17869: SYNC
// Say ( JMM , D1-JMM-2 ) ;
17870: LD_EXP 40
17874: PPUSH
17875: LD_STRING D1-JMM-2
17877: PPUSH
17878: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
17882: LD_EXP 60
17886: PPUSH
17887: LD_STRING D1-Pow-2
17889: PPUSH
17890: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
17894: LD_EXP 40
17898: PPUSH
17899: LD_STRING D1-JMM-3
17901: PPUSH
17902: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
17906: LD_EXP 60
17910: PPUSH
17911: LD_STRING D1-Pow-3
17913: PPUSH
17914: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
17918: LD_EXP 40
17922: PPUSH
17923: LD_STRING D1-JMM-4
17925: PPUSH
17926: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
17930: LD_EXP 60
17934: PPUSH
17935: LD_STRING D1-Pow-4
17937: PPUSH
17938: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17942: LD_EXP 40
17946: PPUSH
17947: LD_STRING D1-JMM-5
17949: PPUSH
17950: CALL_OW 88
// async ;
17954: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17955: LD_EXP 60
17959: PPUSH
17960: LD_STRING D1-Pow-5
17962: PPUSH
17963: CALL_OW 88
// if not dialogue_skipped then
17967: LD_OWVAR 59
17971: NOT
17972: IFFALSE 17981
// wait ( 0 0$3.6 ) ;
17974: LD_INT 126
17976: PPUSH
17977: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17981: LD_INT 134
17983: PPUSH
17984: LD_INT 210
17986: PPUSH
17987: LD_INT 1
17989: PPUSH
17990: LD_INT 11
17992: NEG
17993: PPUSH
17994: CALL 105973 0 4
// if not dialogue_skipped then
17998: LD_OWVAR 59
18002: NOT
18003: IFFALSE 18022
// begin CenterOnXY ( 134 , 210 ) ;
18005: LD_INT 134
18007: PPUSH
18008: LD_INT 210
18010: PPUSH
18011: CALL_OW 84
// wait ( 0 0$2 ) ;
18015: LD_INT 70
18017: PPUSH
18018: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18022: LD_INT 101
18024: PPUSH
18025: LD_INT 159
18027: PPUSH
18028: LD_INT 1
18030: PPUSH
18031: LD_INT 10
18033: NEG
18034: PPUSH
18035: CALL 105973 0 4
// if not dialogue_skipped then
18039: LD_OWVAR 59
18043: NOT
18044: IFFALSE 18063
// begin CenterOnXY ( 101 , 159 ) ;
18046: LD_INT 101
18048: PPUSH
18049: LD_INT 159
18051: PPUSH
18052: CALL_OW 84
// wait ( 0 0$2 ) ;
18056: LD_INT 70
18058: PPUSH
18059: CALL_OW 67
// end ; sync ;
18063: SYNC
// CenterNowOnUnits ( Powell ) ;
18064: LD_EXP 60
18068: PPUSH
18069: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18073: LD_ADDR_VAR 0 6
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: LD_INT 2
18083: PUSH
18084: LD_INT 3
18086: PUSH
18087: LD_INT 4
18089: PUSH
18090: LD_INT 5
18092: PUSH
18093: LD_INT 6
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: LIST
18103: ST_TO_ADDR
// if not dialogue_skipped then
18104: LD_OWVAR 59
18108: NOT
18109: IFFALSE 18278
// begin game_speed := 4 ;
18111: LD_ADDR_OWVAR 65
18115: PUSH
18116: LD_INT 4
18118: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18119: LD_INT 210
18121: PPUSH
18122: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18126: LD_ADDR_VAR 0 7
18130: PUSH
18131: LD_STRING Q1
18133: PPUSH
18134: LD_VAR 0 6
18138: PPUSH
18139: CALL_OW 98
18143: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18144: LD_ADDR_VAR 0 7
18148: PUSH
18149: LD_STRING Q1
18151: PPUSH
18152: LD_VAR 0 6
18156: PPUSH
18157: CALL_OW 98
18161: ST_TO_ADDR
// options := options diff dec ;
18162: LD_ADDR_VAR 0 6
18166: PUSH
18167: LD_VAR 0 6
18171: PUSH
18172: LD_VAR 0 7
18176: DIFF
18177: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18178: LD_VAR 0 7
18182: PPUSH
18183: LD_VAR 0 6
18187: PPUSH
18188: CALL 19842 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18192: LD_VAR 0 7
18196: PUSH
18197: LD_INT 5
18199: PUSH
18200: LD_INT 6
18202: PUSH
18203: EMPTY
18204: LIST
18205: LIST
18206: IN
18207: PUSH
18208: LD_VAR 0 6
18212: PUSH
18213: LD_INT 2
18215: EQUAL
18216: OR
18217: IFFALSE 18144
// if not ( dec in [ 5 , 6 ] ) then
18219: LD_VAR 0 7
18223: PUSH
18224: LD_INT 5
18226: PUSH
18227: LD_INT 6
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: IN
18234: NOT
18235: IFFALSE 18278
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18237: LD_ADDR_VAR 0 7
18241: PUSH
18242: LD_STRING Q1a
18244: PPUSH
18245: LD_INT 1
18247: PUSH
18248: LD_INT 2
18250: PUSH
18251: EMPTY
18252: LIST
18253: LIST
18254: PPUSH
18255: CALL_OW 98
18259: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18260: LD_VAR 0 7
18264: PUSH
18265: LD_INT 4
18267: PLUS
18268: PPUSH
18269: LD_VAR 0 6
18273: PPUSH
18274: CALL 19842 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18278: LD_INT 81
18280: PPUSH
18281: LD_INT 127
18283: PPUSH
18284: CALL_OW 84
// amount := 8 ;
18288: LD_ADDR_VAR 0 8
18292: PUSH
18293: LD_INT 8
18295: ST_TO_ADDR
// macmilan_squad := [ ] ;
18296: LD_ADDR_VAR 0 9
18300: PUSH
18301: EMPTY
18302: ST_TO_ADDR
// if vip < amount then
18303: LD_EXP 61
18307: PUSH
18308: LD_VAR 0 8
18312: LESS
18313: IFFALSE 18357
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18315: LD_ADDR_VAR 0 5
18319: PUSH
18320: LD_EXP 61
18324: PUSH
18325: LD_INT 22
18327: PUSH
18328: LD_INT 4
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: PUSH
18335: LD_INT 21
18337: PUSH
18338: LD_INT 1
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PPUSH
18349: CALL_OW 69
18353: UNION
18354: ST_TO_ADDR
18355: GO 18367
// tmp := vip ;
18357: LD_ADDR_VAR 0 5
18361: PUSH
18362: LD_EXP 61
18366: ST_TO_ADDR
// tmp := tmp diff Powell ;
18367: LD_ADDR_VAR 0 5
18371: PUSH
18372: LD_VAR 0 5
18376: PUSH
18377: LD_EXP 60
18381: DIFF
18382: ST_TO_ADDR
// if tmp < amount then
18383: LD_VAR 0 5
18387: PUSH
18388: LD_VAR 0 8
18392: LESS
18393: IFFALSE 18405
// amount := tmp ;
18395: LD_ADDR_VAR 0 8
18399: PUSH
18400: LD_VAR 0 5
18404: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18405: LD_VAR 0 5
18409: PUSH
18410: LD_INT 1
18412: ARRAY
18413: PPUSH
18414: CALL_OW 257
18418: PUSH
18419: LD_INT 2
18421: NONEQUAL
18422: IFFALSE 18520
// begin if IsInUnit ( tmp [ 1 ] ) then
18424: LD_VAR 0 5
18428: PUSH
18429: LD_INT 1
18431: ARRAY
18432: PPUSH
18433: CALL_OW 310
18437: IFFALSE 18452
// ComExitBuilding ( tmp [ 1 ] ) ;
18439: LD_VAR 0 5
18443: PUSH
18444: LD_INT 1
18446: ARRAY
18447: PPUSH
18448: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18452: LD_INT 387
18454: PPUSH
18455: CALL_OW 313
18459: PUSH
18460: LD_INT 6
18462: EQUAL
18463: IFFALSE 18488
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
18465: LD_INT 387
18467: PPUSH
18468: CALL_OW 313
18472: PUSH
18473: LD_INT 1
18475: ARRAY
18476: PPUSH
18477: CALL_OW 122
// wait ( 3 ) ;
18481: LD_INT 3
18483: PPUSH
18484: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
18488: LD_VAR 0 5
18492: PUSH
18493: LD_INT 1
18495: ARRAY
18496: PPUSH
18497: LD_INT 387
18499: PPUSH
18500: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
18504: LD_VAR 0 5
18508: PUSH
18509: LD_INT 1
18511: ARRAY
18512: PPUSH
18513: LD_INT 2
18515: PPUSH
18516: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
18520: LD_EXP 40
18524: PPUSH
18525: LD_INT 82
18527: PPUSH
18528: LD_INT 129
18530: PPUSH
18531: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18535: LD_EXP 40
18539: PPUSH
18540: LD_EXP 60
18544: PPUSH
18545: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
18549: LD_INT 22
18551: PUSH
18552: LD_INT 1
18554: PUSH
18555: EMPTY
18556: LIST
18557: LIST
18558: PPUSH
18559: CALL_OW 69
18563: PUSH
18564: LD_EXP 40
18568: DIFF
18569: PPUSH
18570: LD_INT 84
18572: PPUSH
18573: LD_INT 128
18575: PPUSH
18576: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
18580: LD_INT 22
18582: PUSH
18583: LD_INT 1
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: PPUSH
18590: CALL_OW 69
18594: PUSH
18595: LD_EXP 40
18599: DIFF
18600: PPUSH
18601: LD_EXP 40
18605: PPUSH
18606: CALL_OW 179
// for i = 1 to amount do
18610: LD_ADDR_VAR 0 2
18614: PUSH
18615: DOUBLE
18616: LD_INT 1
18618: DEC
18619: ST_TO_ADDR
18620: LD_VAR 0 8
18624: PUSH
18625: FOR_TO
18626: IFFALSE 18794
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
18628: LD_ADDR_VAR 0 9
18632: PUSH
18633: LD_VAR 0 9
18637: PUSH
18638: LD_VAR 0 5
18642: PUSH
18643: LD_VAR 0 2
18647: ARRAY
18648: ADD
18649: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
18650: LD_VAR 0 5
18654: PUSH
18655: LD_VAR 0 2
18659: ARRAY
18660: PPUSH
18661: CALL_OW 310
18665: IFFALSE 18682
// AddComExitBuilding ( tmp [ i ] ) ;
18667: LD_VAR 0 5
18671: PUSH
18672: LD_VAR 0 2
18676: ARRAY
18677: PPUSH
18678: CALL_OW 182
// if i = 2 and JMMNewVeh then
18682: LD_VAR 0 2
18686: PUSH
18687: LD_INT 2
18689: EQUAL
18690: PUSH
18691: LD_EXP 58
18695: AND
18696: IFFALSE 18754
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
18698: LD_VAR 0 5
18702: PUSH
18703: LD_VAR 0 2
18707: ARRAY
18708: PPUSH
18709: LD_EXP 58
18713: PPUSH
18714: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
18718: LD_VAR 0 5
18722: PUSH
18723: LD_VAR 0 2
18727: ARRAY
18728: PPUSH
18729: LD_INT 86
18731: PPUSH
18732: LD_INT 133
18734: PPUSH
18735: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
18739: LD_VAR 0 5
18743: PUSH
18744: LD_VAR 0 2
18748: ARRAY
18749: PPUSH
18750: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
18754: LD_VAR 0 5
18758: PUSH
18759: LD_VAR 0 2
18763: ARRAY
18764: PPUSH
18765: LD_INT 8
18767: PPUSH
18768: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
18772: LD_VAR 0 5
18776: PUSH
18777: LD_VAR 0 2
18781: ARRAY
18782: PPUSH
18783: LD_EXP 40
18787: PPUSH
18788: CALL_OW 179
// end ;
18792: GO 18625
18794: POP
18795: POP
// if GirlNewVeh then
18796: LD_EXP 59
18800: IFFALSE 18814
// SetSide ( GirlNewVeh , 4 ) ;
18802: LD_EXP 59
18806: PPUSH
18807: LD_INT 4
18809: PPUSH
18810: CALL_OW 235
// if Mike then
18814: LD_EXP 57
18818: IFFALSE 18855
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
18820: LD_ADDR_VAR 0 9
18824: PUSH
18825: LD_VAR 0 9
18829: PPUSH
18830: LD_EXP 57
18834: PPUSH
18835: CALL 106087 0 2
18839: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
18840: LD_EXP 57
18844: PPUSH
18845: LD_INT 86
18847: PPUSH
18848: LD_INT 133
18850: PPUSH
18851: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
18855: LD_INT 35
18857: PPUSH
18858: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
18862: LD_VAR 0 9
18866: PPUSH
18867: LD_INT 95
18869: PUSH
18870: LD_INT 9
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: PPUSH
18877: CALL_OW 72
18881: PUSH
18882: LD_INT 0
18884: EQUAL
18885: PUSH
18886: LD_EXP 40
18890: PPUSH
18891: LD_INT 9
18893: PPUSH
18894: CALL_OW 308
18898: NOT
18899: AND
18900: IFFALSE 18855
// wait ( 0 0$2 ) ;
18902: LD_INT 70
18904: PPUSH
18905: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
18909: LD_VAR 0 9
18913: PPUSH
18914: LD_INT 1
18916: PPUSH
18917: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
18921: LD_INT 21
18923: PUSH
18924: LD_INT 2
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: LD_INT 92
18933: PUSH
18934: LD_INT 83
18936: PUSH
18937: LD_INT 130
18939: PUSH
18940: LD_INT 10
18942: PUSH
18943: EMPTY
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PPUSH
18953: CALL_OW 69
18957: PPUSH
18958: LD_INT 1
18960: PPUSH
18961: CALL_OW 235
// tick := 0 ;
18965: LD_ADDR_OWVAR 1
18969: PUSH
18970: LD_INT 0
18972: ST_TO_ADDR
// Video ( false ) ;
18973: LD_INT 0
18975: PPUSH
18976: CALL 106059 0 1
// ChangeMissionObjectives ( M1 ) ;
18980: LD_STRING M1
18982: PPUSH
18983: CALL_OW 337
// SaveForQuickRestart ;
18987: CALL_OW 22
// missionStart := true ;
18991: LD_ADDR_EXP 13
18995: PUSH
18996: LD_INT 1
18998: ST_TO_ADDR
// missionStage := 2 ;
18999: LD_ADDR_EXP 15
19003: PUSH
19004: LD_INT 2
19006: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19007: LD_INT 35
19009: PPUSH
19010: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_INT 22
19021: PUSH
19022: LD_INT 4
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: PUSH
19029: LD_INT 21
19031: PUSH
19032: LD_INT 1
19034: PUSH
19035: EMPTY
19036: LIST
19037: LIST
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: PPUSH
19043: CALL_OW 69
19047: PUSH
19048: LD_EXP 60
19052: DIFF
19053: ST_TO_ADDR
// if not tmp then
19054: LD_VAR 0 5
19058: NOT
19059: IFFALSE 19074
// tmp := [ Powell ] ;
19061: LD_ADDR_VAR 0 5
19065: PUSH
19066: LD_EXP 60
19070: PUSH
19071: EMPTY
19072: LIST
19073: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19074: LD_ADDR_VAR 0 4
19078: PUSH
19079: LD_INT 22
19081: PUSH
19082: LD_INT 4
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: PUSH
19089: LD_INT 34
19091: PUSH
19092: LD_INT 12
19094: PUSH
19095: EMPTY
19096: LIST
19097: LIST
19098: PUSH
19099: EMPTY
19100: LIST
19101: LIST
19102: PPUSH
19103: CALL_OW 69
19107: PUSH
19108: LD_INT 1
19110: ARRAY
19111: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19112: LD_VAR 0 5
19116: PUSH
19117: LD_INT 1
19119: ARRAY
19120: PPUSH
19121: CALL_OW 310
19125: IFFALSE 19140
// ComExitBuilding ( tmp [ 1 ] ) ;
19127: LD_VAR 0 5
19131: PUSH
19132: LD_INT 1
19134: ARRAY
19135: PPUSH
19136: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19140: LD_VAR 0 5
19144: PUSH
19145: LD_INT 1
19147: ARRAY
19148: PPUSH
19149: LD_VAR 0 4
19153: PPUSH
19154: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19158: LD_VAR 0 5
19162: PUSH
19163: LD_INT 1
19165: ARRAY
19166: PPUSH
19167: LD_INT 80
19169: PPUSH
19170: LD_INT 136
19172: PPUSH
19173: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19177: LD_VAR 0 5
19181: PUSH
19182: LD_INT 1
19184: ARRAY
19185: PPUSH
19186: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19190: LD_VAR 0 5
19194: PUSH
19195: LD_INT 1
19197: ARRAY
19198: PPUSH
19199: LD_INT 59
19201: PPUSH
19202: LD_INT 112
19204: PPUSH
19205: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19209: LD_VAR 0 5
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19222: LD_EXP 41
19226: PUSH
19227: LD_EXP 41
19231: PPUSH
19232: CALL_OW 255
19236: PUSH
19237: LD_INT 1
19239: EQUAL
19240: AND
19241: IFFALSE 19267
// begin Say ( Joan , D3W-Joan-1 ) ;
19243: LD_EXP 41
19247: PPUSH
19248: LD_STRING D3W-Joan-1
19250: PPUSH
19251: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19255: LD_EXP 40
19259: PPUSH
19260: LD_STRING D3W-JMM-1
19262: PPUSH
19263: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19267: LD_EXP 43
19271: PUSH
19272: LD_EXP 43
19276: PPUSH
19277: CALL_OW 255
19281: PUSH
19282: LD_INT 1
19284: EQUAL
19285: AND
19286: PUSH
19287: LD_EXP 43
19291: PUSH
19292: LD_EXP 61
19296: IN
19297: NOT
19298: AND
19299: IFFALSE 19325
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19301: LD_EXP 43
19305: PPUSH
19306: LD_STRING D3W-Lisa-1
19308: PPUSH
19309: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19313: LD_EXP 40
19317: PPUSH
19318: LD_STRING D3W-JMM-1
19320: PPUSH
19321: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19325: LD_EXP 55
19329: PUSH
19330: LD_EXP 55
19334: PPUSH
19335: CALL_OW 255
19339: PUSH
19340: LD_INT 1
19342: EQUAL
19343: AND
19344: IFFALSE 19370
// begin Say ( Connie , D3W-Con-1 ) ;
19346: LD_EXP 55
19350: PPUSH
19351: LD_STRING D3W-Con-1
19353: PPUSH
19354: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19358: LD_EXP 40
19362: PPUSH
19363: LD_STRING D3W-JMM-1
19365: PPUSH
19366: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19370: LD_INT 18
19372: PPUSH
19373: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19377: LD_EXP 43
19381: PUSH
19382: LD_EXP 61
19386: IN
19387: PUSH
19388: LD_EXP 43
19392: PPUSH
19393: CALL_OW 255
19397: PUSH
19398: LD_INT 1
19400: EQUAL
19401: AND
19402: IFFALSE 19418
// Say ( Lisa , D3nW-Lisa-1 ) else
19404: LD_EXP 43
19408: PPUSH
19409: LD_STRING D3nW-Lisa-1
19411: PPUSH
19412: CALL_OW 88
19416: GO 19662
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19418: LD_EXP 46
19422: PUSH
19423: LD_EXP 61
19427: IN
19428: PUSH
19429: LD_EXP 46
19433: PPUSH
19434: CALL_OW 255
19438: PUSH
19439: LD_INT 1
19441: EQUAL
19442: AND
19443: IFFALSE 19459
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19445: LD_EXP 46
19449: PPUSH
19450: LD_STRING D3nW-Cyrus-1
19452: PPUSH
19453: CALL_OW 88
19457: GO 19662
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19459: LD_EXP 45
19463: PUSH
19464: LD_EXP 61
19468: IN
19469: PUSH
19470: LD_EXP 45
19474: PPUSH
19475: CALL_OW 255
19479: PUSH
19480: LD_INT 1
19482: EQUAL
19483: AND
19484: IFFALSE 19500
// Say ( Bobby , D3nW-Bobby-1 ) else
19486: LD_EXP 45
19490: PPUSH
19491: LD_STRING D3nW-Bobby-1
19493: PPUSH
19494: CALL_OW 88
19498: GO 19662
// if Gary in vip and GetSide ( Gary ) = 1 then
19500: LD_EXP 52
19504: PUSH
19505: LD_EXP 61
19509: IN
19510: PUSH
19511: LD_EXP 52
19515: PPUSH
19516: CALL_OW 255
19520: PUSH
19521: LD_INT 1
19523: EQUAL
19524: AND
19525: IFFALSE 19541
// Say ( Gary , D3nW-Gary-1 ) else
19527: LD_EXP 52
19531: PPUSH
19532: LD_STRING D3nW-Gary-1
19534: PPUSH
19535: CALL_OW 88
19539: GO 19662
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
19541: LD_EXP 44
19545: PUSH
19546: LD_EXP 61
19550: IN
19551: PUSH
19552: LD_EXP 44
19556: PPUSH
19557: CALL_OW 255
19561: PUSH
19562: LD_INT 1
19564: EQUAL
19565: AND
19566: IFFALSE 19582
// Say ( Donaldson , D3nW-Don-1 ) else
19568: LD_EXP 44
19572: PPUSH
19573: LD_STRING D3nW-Don-1
19575: PPUSH
19576: CALL_OW 88
19580: GO 19662
// if Cornel in vip and GetSide ( Cornel ) = 1 then
19582: LD_EXP 51
19586: PUSH
19587: LD_EXP 61
19591: IN
19592: PUSH
19593: LD_EXP 51
19597: PPUSH
19598: CALL_OW 255
19602: PUSH
19603: LD_INT 1
19605: EQUAL
19606: AND
19607: IFFALSE 19623
// Say ( Cornel , D3nW-Corn-1 ) else
19609: LD_EXP 51
19613: PPUSH
19614: LD_STRING D3nW-Corn-1
19616: PPUSH
19617: CALL_OW 88
19621: GO 19662
// if Frank in vip and GetSide ( Frank ) = 1 then
19623: LD_EXP 53
19627: PUSH
19628: LD_EXP 61
19632: IN
19633: PUSH
19634: LD_EXP 53
19638: PPUSH
19639: CALL_OW 255
19643: PUSH
19644: LD_INT 1
19646: EQUAL
19647: AND
19648: IFFALSE 19662
// Say ( Frank , D3nW-Frank-1 ) ;
19650: LD_EXP 53
19654: PPUSH
19655: LD_STRING D3nW-Frank-1
19657: PPUSH
19658: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
19662: LD_EXP 61
19666: PPUSH
19667: LD_INT 22
19669: PUSH
19670: LD_INT 1
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PPUSH
19677: CALL_OW 72
19681: IFFALSE 19707
// begin Say ( JMM , D3nW-JMM-1 ) ;
19683: LD_EXP 40
19687: PPUSH
19688: LD_STRING D3nW-JMM-1
19690: PPUSH
19691: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
19695: LD_EXP 40
19699: PPUSH
19700: LD_STRING D3nW-JMM-1a
19702: PPUSH
19703: CALL_OW 88
// end ; t := 0 0$00 ;
19707: LD_ADDR_VAR 0 3
19711: PUSH
19712: LD_INT 0
19714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19715: LD_INT 35
19717: PPUSH
19718: CALL_OW 67
// t := t + 0 0$1 ;
19722: LD_ADDR_VAR 0 3
19726: PUSH
19727: LD_VAR 0 3
19731: PUSH
19732: LD_INT 35
19734: PLUS
19735: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
19736: LD_INT 59
19738: PPUSH
19739: LD_INT 112
19741: PPUSH
19742: CALL_OW 428
19746: PUSH
19747: LD_VAR 0 3
19751: PUSH
19752: LD_INT 2100
19754: GREATER
19755: OR
19756: IFFALSE 19715
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
19758: LD_ADDR_EXP 100
19762: PUSH
19763: LD_EXP 100
19767: PPUSH
19768: LD_INT 4
19770: PPUSH
19771: LD_INT 22
19773: PUSH
19774: LD_INT 4
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: PUSH
19781: LD_INT 23
19783: PUSH
19784: LD_INT 1
19786: PUSH
19787: EMPTY
19788: LIST
19789: LIST
19790: PUSH
19791: LD_INT 3
19793: PUSH
19794: LD_INT 21
19796: PUSH
19797: LD_INT 2
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: PUSH
19804: EMPTY
19805: LIST
19806: LIST
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: LIST
19812: PPUSH
19813: CALL_OW 69
19817: PUSH
19818: LD_EXP 60
19822: DIFF
19823: PPUSH
19824: CALL_OW 1
19828: ST_TO_ADDR
// activeAttacks := true ;
19829: LD_ADDR_EXP 16
19833: PUSH
19834: LD_INT 1
19836: ST_TO_ADDR
// end ;
19837: LD_VAR 0 1
19841: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
19842: LD_INT 0
19844: PPUSH
// case question of 1 :
19845: LD_VAR 0 1
19849: PUSH
19850: LD_INT 1
19852: DOUBLE
19853: EQUAL
19854: IFTRUE 19858
19856: GO 19909
19858: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
19859: LD_EXP 40
19863: PPUSH
19864: LD_STRING D2Mot-JMM-1
19866: PPUSH
19867: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
19871: LD_EXP 60
19875: PPUSH
19876: LD_STRING D2Mot-Pow-1
19878: PPUSH
19879: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
19883: LD_EXP 40
19887: PPUSH
19888: LD_STRING D2Mot-JMM-2
19890: PPUSH
19891: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
19895: LD_EXP 60
19899: PPUSH
19900: LD_STRING D2Mot-Pow-2
19902: PPUSH
19903: CALL_OW 88
// end ; 2 :
19907: GO 20260
19909: LD_INT 2
19911: DOUBLE
19912: EQUAL
19913: IFTRUE 19917
19915: GO 19993
19917: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
19918: LD_EXP 40
19922: PPUSH
19923: LD_STRING D2Rus-JMM-1
19925: PPUSH
19926: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
19930: LD_EXP 60
19934: PPUSH
19935: LD_STRING D2Rus-Pow-1
19937: PPUSH
19938: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19942: LD_EXP 40
19946: PPUSH
19947: LD_STRING D2Rus-JMM-2
19949: PPUSH
19950: CALL_OW 88
// if not ( 3 in list_of_q ) then
19954: LD_INT 3
19956: PUSH
19957: LD_VAR 0 2
19961: IN
19962: NOT
19963: IFFALSE 19979
// Say ( Powell , D2Rus-Pow-2 ) else
19965: LD_EXP 60
19969: PPUSH
19970: LD_STRING D2Rus-Pow-2
19972: PPUSH
19973: CALL_OW 88
19977: GO 19991
// Say ( Powell , D2Rus-Pow-2a ) ;
19979: LD_EXP 60
19983: PPUSH
19984: LD_STRING D2Rus-Pow-2a
19986: PPUSH
19987: CALL_OW 88
// end ; 3 :
19991: GO 20260
19993: LD_INT 3
19995: DOUBLE
19996: EQUAL
19997: IFTRUE 20001
19999: GO 20086
20001: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20002: LD_EXP 40
20006: PPUSH
20007: LD_STRING D2Leg-JMM-1
20009: PPUSH
20010: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20014: LD_EXP 60
20018: PPUSH
20019: LD_STRING D2Leg-Pow-1
20021: PPUSH
20022: CALL_OW 88
// if 2 in list_of_q then
20026: LD_INT 2
20028: PUSH
20029: LD_VAR 0 2
20033: IN
20034: IFFALSE 20060
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20036: LD_EXP 40
20040: PPUSH
20041: LD_STRING D2Leg-JMM-2
20043: PPUSH
20044: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20048: LD_EXP 60
20052: PPUSH
20053: LD_STRING D2Leg-Pow-2
20055: PPUSH
20056: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20060: LD_EXP 40
20064: PPUSH
20065: LD_STRING D2Leg-JMM-3
20067: PPUSH
20068: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20072: LD_EXP 60
20076: PPUSH
20077: LD_STRING D2Leg-Pow-3
20079: PPUSH
20080: CALL_OW 88
// end ; 4 :
20084: GO 20260
20086: LD_INT 4
20088: DOUBLE
20089: EQUAL
20090: IFTRUE 20094
20092: GO 20169
20094: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20095: LD_EXP 40
20099: PPUSH
20100: LD_STRING D2Ar-JMM-1
20102: PPUSH
20103: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20107: LD_EXP 60
20111: PPUSH
20112: LD_STRING D2Ar-Pow-1
20114: PPUSH
20115: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20119: LD_EXP 40
20123: PPUSH
20124: LD_STRING D2Ar-JMM-2
20126: PPUSH
20127: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20131: LD_EXP 60
20135: PPUSH
20136: LD_STRING D2Ar-Pow-2
20138: PPUSH
20139: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20143: LD_EXP 40
20147: PPUSH
20148: LD_STRING D2Ar-JMM-3
20150: PPUSH
20151: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20155: LD_EXP 60
20159: PPUSH
20160: LD_STRING D2Ar-Pow-3
20162: PPUSH
20163: CALL_OW 88
// end ; 5 :
20167: GO 20260
20169: LD_INT 5
20171: DOUBLE
20172: EQUAL
20173: IFTRUE 20177
20175: GO 20192
20177: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20178: LD_EXP 40
20182: PPUSH
20183: LD_STRING D2Conf-JMM-1
20185: PPUSH
20186: CALL_OW 88
20190: GO 20260
20192: LD_INT 6
20194: DOUBLE
20195: EQUAL
20196: IFTRUE 20200
20198: GO 20259
20200: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20201: LD_EXP 40
20205: PPUSH
20206: LD_STRING D2Com-JMM-1
20208: PPUSH
20209: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20213: LD_EXP 60
20217: PPUSH
20218: LD_STRING D2Com-Pow-1
20220: PPUSH
20221: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20225: LD_EXP 40
20229: PPUSH
20230: LD_STRING D2Com-JMM-2
20232: PPUSH
20233: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20237: LD_EXP 60
20241: PPUSH
20242: LD_STRING D2Com-Pow-2
20244: PPUSH
20245: CALL_OW 88
// powellAngerQuery := true ;
20249: LD_ADDR_EXP 36
20253: PUSH
20254: LD_INT 1
20256: ST_TO_ADDR
// end ; end ;
20257: GO 20260
20259: POP
// end ;
20260: LD_VAR 0 3
20264: RET
// every 0 0$5 trigger missionStart do var tmp ;
20265: LD_EXP 13
20269: IFFALSE 20552
20271: GO 20273
20273: DISABLE
20274: LD_INT 0
20276: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20277: LD_INT 35
20279: PPUSH
20280: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20284: LD_INT 14
20286: PPUSH
20287: LD_INT 22
20289: PUSH
20290: LD_INT 1
20292: PUSH
20293: EMPTY
20294: LIST
20295: LIST
20296: PPUSH
20297: CALL_OW 70
20301: PUSH
20302: LD_EXP 15
20306: PUSH
20307: LD_INT 2
20309: PUSH
20310: LD_INT 3
20312: PUSH
20313: LD_INT 4
20315: PUSH
20316: LD_INT 5
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: IN
20325: AND
20326: IFFALSE 20542
// begin powellAnger := powellAnger + 1 ;
20328: LD_ADDR_EXP 17
20332: PUSH
20333: LD_EXP 17
20337: PUSH
20338: LD_INT 1
20340: PLUS
20341: ST_TO_ADDR
// Video ( true ) ;
20342: LD_INT 1
20344: PPUSH
20345: CALL 106059 0 1
// CenterNowOnUnits ( tmp ) ;
20349: LD_VAR 0 1
20353: PPUSH
20354: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20358: LD_INT 14
20360: PPUSH
20361: LD_INT 22
20363: PUSH
20364: LD_INT 1
20366: PUSH
20367: EMPTY
20368: LIST
20369: LIST
20370: PPUSH
20371: CALL_OW 70
20375: PPUSH
20376: LD_INT 86
20378: PPUSH
20379: LD_INT 133
20381: PPUSH
20382: CALL_OW 111
// async ;
20386: ASYNC
// case powellAnger of 1 :
20387: LD_EXP 17
20391: PUSH
20392: LD_INT 1
20394: DOUBLE
20395: EQUAL
20396: IFTRUE 20400
20398: GO 20415
20400: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20401: LD_EXP 60
20405: PPUSH
20406: LD_STRING DBack1-Pow-1
20408: PPUSH
20409: CALL_OW 88
20413: GO 20462
20415: LD_INT 2
20417: DOUBLE
20418: EQUAL
20419: IFTRUE 20423
20421: GO 20438
20423: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20424: LD_EXP 60
20428: PPUSH
20429: LD_STRING DBack2-Pow-1
20431: PPUSH
20432: CALL_OW 88
20436: GO 20462
20438: LD_INT 3
20440: DOUBLE
20441: EQUAL
20442: IFTRUE 20446
20444: GO 20461
20446: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
20447: LD_EXP 60
20451: PPUSH
20452: LD_STRING DBack3-Pow-1
20454: PPUSH
20455: CALL_OW 88
20459: GO 20462
20461: POP
// sync ;
20462: SYNC
// repeat wait ( 0 0$1 ) ;
20463: LD_INT 35
20465: PPUSH
20466: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20470: LD_INT 14
20472: PPUSH
20473: LD_INT 22
20475: PUSH
20476: LD_INT 1
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: PPUSH
20483: CALL_OW 70
20487: PPUSH
20488: LD_INT 86
20490: PPUSH
20491: LD_INT 133
20493: PPUSH
20494: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
20498: LD_INT 14
20500: PPUSH
20501: LD_INT 22
20503: PUSH
20504: LD_INT 1
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: PPUSH
20511: CALL_OW 70
20515: NOT
20516: IFFALSE 20463
// if powellAnger >= 3 then
20518: LD_EXP 17
20522: PUSH
20523: LD_INT 3
20525: GREATEREQUAL
20526: IFFALSE 20535
// YouLost ( Dismissed ) ;
20528: LD_STRING Dismissed
20530: PPUSH
20531: CALL_OW 104
// Video ( false ) ;
20535: LD_INT 0
20537: PPUSH
20538: CALL 106059 0 1
// end ; until missionStage > 5 ;
20542: LD_EXP 15
20546: PUSH
20547: LD_INT 5
20549: GREATER
20550: IFFALSE 20277
// end ;
20552: PPOPN 1
20554: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
20555: LD_EXP 13
20559: PUSH
20560: LD_INT 22
20562: PUSH
20563: LD_INT 4
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: PUSH
20570: LD_INT 21
20572: PUSH
20573: LD_INT 2
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: PUSH
20580: EMPTY
20581: LIST
20582: LIST
20583: PPUSH
20584: CALL_OW 69
20588: PUSH
20589: LD_INT 4
20591: GREATEREQUAL
20592: AND
20593: PUSH
20594: LD_EXP 15
20598: PUSH
20599: LD_INT 2
20601: EQUAL
20602: AND
20603: IFFALSE 22793
20605: GO 20607
20607: DISABLE
20608: LD_INT 0
20610: PPUSH
20611: PPUSH
20612: PPUSH
20613: PPUSH
20614: PPUSH
20615: PPUSH
20616: PPUSH
20617: PPUSH
20618: PPUSH
20619: PPUSH
// begin missionStage := 3 ;
20620: LD_ADDR_EXP 15
20624: PUSH
20625: LD_INT 3
20627: ST_TO_ADDR
// retreat := false ;
20628: LD_ADDR_VAR 0 4
20632: PUSH
20633: LD_INT 0
20635: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
20636: LD_ADDR_VAR 0 5
20640: PUSH
20641: LD_INT 22
20643: PUSH
20644: LD_INT 4
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: PUSH
20651: LD_INT 30
20653: PUSH
20654: LD_INT 4
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20670: LD_ADDR_VAR 0 6
20674: PUSH
20675: LD_INT 22
20677: PUSH
20678: LD_INT 4
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: PUSH
20685: LD_INT 30
20687: PUSH
20688: LD_INT 5
20690: PUSH
20691: EMPTY
20692: LIST
20693: LIST
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: PPUSH
20699: CALL_OW 69
20703: ST_TO_ADDR
// if not bar then
20704: LD_VAR 0 6
20708: NOT
20709: IFFALSE 20762
// begin repeat wait ( 0 0$1 ) ;
20711: LD_INT 35
20713: PPUSH
20714: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
20718: LD_INT 22
20720: PUSH
20721: LD_INT 4
20723: PUSH
20724: EMPTY
20725: LIST
20726: LIST
20727: PUSH
20728: LD_INT 3
20730: PUSH
20731: LD_INT 57
20733: PUSH
20734: EMPTY
20735: LIST
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PUSH
20741: LD_INT 30
20743: PUSH
20744: LD_INT 5
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: PUSH
20751: EMPTY
20752: LIST
20753: LIST
20754: LIST
20755: PPUSH
20756: CALL_OW 69
20760: IFFALSE 20711
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20762: LD_ADDR_VAR 0 6
20766: PUSH
20767: LD_INT 22
20769: PUSH
20770: LD_INT 4
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: PUSH
20777: LD_INT 30
20779: PUSH
20780: LD_INT 5
20782: PUSH
20783: EMPTY
20784: LIST
20785: LIST
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: PPUSH
20791: CALL_OW 69
20795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20796: LD_INT 35
20798: PPUSH
20799: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
20803: LD_EXP 119
20807: PUSH
20808: LD_INT 4
20810: ARRAY
20811: PUSH
20812: LD_INT 4
20814: GREATEREQUAL
20815: IFFALSE 20796
// tmp := [ ] ;
20817: LD_ADDR_VAR 0 2
20821: PUSH
20822: EMPTY
20823: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
20824: LD_ADDR_VAR 0 1
20828: PUSH
20829: LD_INT 22
20831: PUSH
20832: LD_INT 4
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: PUSH
20839: LD_INT 2
20841: PUSH
20842: LD_INT 25
20844: PUSH
20845: LD_INT 1
20847: PUSH
20848: EMPTY
20849: LIST
20850: LIST
20851: PUSH
20852: LD_INT 25
20854: PUSH
20855: LD_INT 2
20857: PUSH
20858: EMPTY
20859: LIST
20860: LIST
20861: PUSH
20862: LD_INT 25
20864: PUSH
20865: LD_INT 3
20867: PUSH
20868: EMPTY
20869: LIST
20870: LIST
20871: PUSH
20872: LD_INT 25
20874: PUSH
20875: LD_INT 4
20877: PUSH
20878: EMPTY
20879: LIST
20880: LIST
20881: PUSH
20882: LD_INT 25
20884: PUSH
20885: LD_INT 5
20887: PUSH
20888: EMPTY
20889: LIST
20890: LIST
20891: PUSH
20892: EMPTY
20893: LIST
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PPUSH
20904: CALL_OW 69
20908: PUSH
20909: LD_EXP 60
20913: PUSH
20914: LD_EXP 61
20918: ADD
20919: DIFF
20920: PUSH
20921: FOR_IN
20922: IFFALSE 20986
// if GetTag ( i ) = 1 then
20924: LD_VAR 0 1
20928: PPUSH
20929: CALL_OW 110
20933: PUSH
20934: LD_INT 1
20936: EQUAL
20937: IFFALSE 20961
// tmp := Join ( tmp , i ) else
20939: LD_ADDR_VAR 0 2
20943: PUSH
20944: LD_VAR 0 2
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: CALL 106087 0 2
20958: ST_TO_ADDR
20959: GO 20984
// tmp := Insert ( tmp , 1 , i ) ;
20961: LD_ADDR_VAR 0 2
20965: PUSH
20966: LD_VAR 0 2
20970: PPUSH
20971: LD_INT 1
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: CALL_OW 2
20983: ST_TO_ADDR
20984: GO 20921
20986: POP
20987: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20988: LD_ADDR_VAR 0 3
20992: PUSH
20993: LD_VAR 0 2
20997: PPUSH
20998: LD_INT 26
21000: PUSH
21001: LD_INT 1
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PPUSH
21008: CALL_OW 72
21012: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
21013: LD_ADDR_VAR 0 2
21017: PUSH
21018: LD_VAR 0 2
21022: PUSH
21023: LD_VAR 0 3
21027: DIFF
21028: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21029: LD_ADDR_VAR 0 2
21033: PUSH
21034: LD_VAR 0 2
21038: PPUSH
21039: LD_INT 3
21041: PPUSH
21042: CALL 104604 0 2
21046: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21047: LD_ADDR_VAR 0 3
21051: PUSH
21052: LD_VAR 0 3
21056: PPUSH
21057: LD_INT 3
21059: PPUSH
21060: CALL 104604 0 2
21064: ST_TO_ADDR
// for i := 1 to 4 do
21065: LD_ADDR_VAR 0 1
21069: PUSH
21070: DOUBLE
21071: LD_INT 1
21073: DEC
21074: ST_TO_ADDR
21075: LD_INT 4
21077: PUSH
21078: FOR_TO
21079: IFFALSE 21232
// begin if tmp2 then
21081: LD_VAR 0 3
21085: IFFALSE 21153
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21087: LD_ADDR_EXP 18
21091: PUSH
21092: LD_EXP 18
21096: PPUSH
21097: LD_INT 1
21099: PPUSH
21100: LD_EXP 18
21104: PUSH
21105: LD_INT 1
21107: ARRAY
21108: PUSH
21109: LD_VAR 0 3
21113: PUSH
21114: LD_VAR 0 3
21118: ARRAY
21119: ADD
21120: PPUSH
21121: CALL_OW 1
21125: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21126: LD_VAR 0 3
21130: PUSH
21131: LD_VAR 0 3
21135: ARRAY
21136: PPUSH
21137: LD_INT 1
21139: PPUSH
21140: CALL_OW 109
// tmp2 := [ ] ;
21144: LD_ADDR_VAR 0 3
21148: PUSH
21149: EMPTY
21150: ST_TO_ADDR
// end else
21151: GO 21230
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21153: LD_ADDR_EXP 18
21157: PUSH
21158: LD_EXP 18
21162: PPUSH
21163: LD_INT 1
21165: PPUSH
21166: LD_EXP 18
21170: PUSH
21171: LD_INT 1
21173: ARRAY
21174: PUSH
21175: LD_VAR 0 2
21179: PUSH
21180: LD_VAR 0 2
21184: ARRAY
21185: ADD
21186: PPUSH
21187: CALL_OW 1
21191: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21192: LD_VAR 0 2
21196: PUSH
21197: LD_VAR 0 2
21201: ARRAY
21202: PPUSH
21203: LD_INT 1
21205: PPUSH
21206: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21210: LD_ADDR_VAR 0 2
21214: PUSH
21215: LD_VAR 0 2
21219: PPUSH
21220: LD_VAR 0 2
21224: PPUSH
21225: CALL_OW 3
21229: ST_TO_ADDR
// end ; end ;
21230: GO 21078
21232: POP
21233: POP
// if tmp2 then
21234: LD_VAR 0 3
21238: IFFALSE 21256
// tmp := tmp union tmp2 ;
21240: LD_ADDR_VAR 0 2
21244: PUSH
21245: LD_VAR 0 2
21249: PUSH
21250: LD_VAR 0 3
21254: UNION
21255: ST_TO_ADDR
// for i := 1 to 4 do
21256: LD_ADDR_VAR 0 1
21260: PUSH
21261: DOUBLE
21262: LD_INT 1
21264: DEC
21265: ST_TO_ADDR
21266: LD_INT 4
21268: PUSH
21269: FOR_TO
21270: IFFALSE 21319
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21272: LD_ADDR_EXP 18
21276: PUSH
21277: LD_EXP 18
21281: PPUSH
21282: LD_INT 2
21284: PPUSH
21285: LD_EXP 18
21289: PUSH
21290: LD_INT 2
21292: ARRAY
21293: PUSH
21294: LD_VAR 0 2
21298: PUSH
21299: LD_VAR 0 2
21303: PUSH
21304: LD_VAR 0 1
21308: MINUS
21309: ARRAY
21310: ADD
21311: PPUSH
21312: CALL_OW 1
21316: ST_TO_ADDR
21317: GO 21269
21319: POP
21320: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21321: LD_ADDR_EXP 100
21325: PUSH
21326: LD_EXP 100
21330: PPUSH
21331: LD_INT 4
21333: PPUSH
21334: LD_EXP 100
21338: PUSH
21339: LD_INT 4
21341: ARRAY
21342: PUSH
21343: LD_EXP 18
21347: PUSH
21348: LD_INT 1
21350: ARRAY
21351: DIFF
21352: PPUSH
21353: CALL_OW 1
21357: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21358: LD_VAR 0 5
21362: PUSH
21363: LD_INT 1
21365: ARRAY
21366: PPUSH
21367: CALL_OW 313
21371: IFFALSE 21426
// begin for i in UnitsInside ( arm [ 1 ] ) do
21373: LD_ADDR_VAR 0 1
21377: PUSH
21378: LD_VAR 0 5
21382: PUSH
21383: LD_INT 1
21385: ARRAY
21386: PPUSH
21387: CALL_OW 313
21391: PUSH
21392: FOR_IN
21393: IFFALSE 21424
// begin ComExitBuilding ( i ) ;
21395: LD_VAR 0 1
21399: PPUSH
21400: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
21404: LD_VAR 0 1
21408: PPUSH
21409: LD_VAR 0 6
21413: PUSH
21414: LD_INT 1
21416: ARRAY
21417: PPUSH
21418: CALL_OW 180
// end ;
21422: GO 21392
21424: POP
21425: POP
// end ; wait ( 0 0$3 ) ;
21426: LD_INT 105
21428: PPUSH
21429: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21433: LD_ADDR_VAR 0 1
21437: PUSH
21438: LD_EXP 18
21442: PUSH
21443: LD_INT 1
21445: ARRAY
21446: PUSH
21447: FOR_IN
21448: IFFALSE 21555
// begin if IsInUnit ( i ) then
21450: LD_VAR 0 1
21454: PPUSH
21455: CALL_OW 310
21459: IFFALSE 21470
// ComExitBuilding ( i ) ;
21461: LD_VAR 0 1
21465: PPUSH
21466: CALL_OW 122
// if GetClass ( i ) <> 1 then
21470: LD_VAR 0 1
21474: PPUSH
21475: CALL_OW 257
21479: PUSH
21480: LD_INT 1
21482: NONEQUAL
21483: IFFALSE 21524
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
21485: LD_VAR 0 1
21489: PPUSH
21490: LD_VAR 0 5
21494: PUSH
21495: LD_INT 1
21497: ARRAY
21498: PPUSH
21499: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
21503: LD_VAR 0 1
21507: PPUSH
21508: LD_INT 1
21510: PPUSH
21511: CALL_OW 183
// AddComExitBuilding ( i ) ;
21515: LD_VAR 0 1
21519: PPUSH
21520: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
21524: LD_VAR 0 1
21528: PPUSH
21529: LD_INT 60
21531: PPUSH
21532: LD_INT 94
21534: PPUSH
21535: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
21539: LD_VAR 0 1
21543: PPUSH
21544: LD_EXP 60
21548: PPUSH
21549: CALL_OW 179
// end ;
21553: GO 21447
21555: POP
21556: POP
// wait ( 0 0$10 ) ;
21557: LD_INT 350
21559: PPUSH
21560: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
21564: LD_EXP 60
21568: PPUSH
21569: LD_STRING D4-Pow-1
21571: PPUSH
21572: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
21576: LD_ADDR_VAR 0 2
21580: PUSH
21581: LD_EXP 18
21585: PUSH
21586: LD_INT 1
21588: ARRAY
21589: PPUSH
21590: LD_INT 26
21592: PUSH
21593: LD_INT 1
21595: PUSH
21596: EMPTY
21597: LIST
21598: LIST
21599: PPUSH
21600: CALL_OW 72
21604: ST_TO_ADDR
// if tmp then
21605: LD_VAR 0 2
21609: IFFALSE 21627
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
21611: LD_VAR 0 2
21615: PUSH
21616: LD_INT 1
21618: ARRAY
21619: PPUSH
21620: LD_STRING D4-Sol1-1
21622: PPUSH
21623: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
21627: LD_EXP 60
21631: PPUSH
21632: LD_STRING D4-Pow-2
21634: PPUSH
21635: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
21639: LD_ADDR_VAR 0 1
21643: PUSH
21644: DOUBLE
21645: LD_INT 1
21647: DEC
21648: ST_TO_ADDR
21649: LD_EXP 18
21653: PUSH
21654: LD_INT 1
21656: ARRAY
21657: PUSH
21658: FOR_TO
21659: IFFALSE 21752
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_VAR 0 1
21674: ARRAY
21675: PPUSH
21676: LD_EXP 119
21680: PUSH
21681: LD_INT 4
21683: ARRAY
21684: PUSH
21685: LD_INT 1
21687: ARRAY
21688: PPUSH
21689: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
21693: LD_ADDR_EXP 119
21697: PUSH
21698: LD_EXP 119
21702: PPUSH
21703: LD_INT 4
21705: PPUSH
21706: LD_EXP 119
21710: PUSH
21711: LD_INT 4
21713: ARRAY
21714: PPUSH
21715: LD_INT 1
21717: PPUSH
21718: CALL_OW 3
21722: PPUSH
21723: CALL_OW 1
21727: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
21728: LD_INT 8
21730: PPUSH
21731: LD_EXP 18
21735: PUSH
21736: LD_INT 1
21738: ARRAY
21739: PUSH
21740: LD_VAR 0 1
21744: ARRAY
21745: PPUSH
21746: CALL_OW 471
// end ;
21750: GO 21658
21752: POP
21753: POP
// repeat wait ( 0 0$1 ) ;
21754: LD_INT 35
21756: PPUSH
21757: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
21761: LD_EXP 18
21765: PUSH
21766: LD_INT 1
21768: ARRAY
21769: PPUSH
21770: LD_INT 55
21772: PUSH
21773: EMPTY
21774: LIST
21775: PPUSH
21776: CALL_OW 72
21780: PUSH
21781: LD_INT 4
21783: GREATEREQUAL
21784: IFFALSE 21754
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
21786: LD_EXP 18
21790: PUSH
21791: LD_INT 1
21793: ARRAY
21794: PPUSH
21795: LD_INT 69
21797: PPUSH
21798: LD_INT 94
21800: PPUSH
21801: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
21805: LD_EXP 18
21809: PUSH
21810: LD_INT 1
21812: ARRAY
21813: PPUSH
21814: LD_INT 82
21816: PPUSH
21817: LD_INT 83
21819: PPUSH
21820: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
21824: LD_EXP 18
21828: PUSH
21829: LD_INT 1
21831: ARRAY
21832: PPUSH
21833: LD_INT 77
21835: PPUSH
21836: LD_INT 69
21838: PPUSH
21839: CALL_OW 174
// repeat wait ( 3 ) ;
21843: LD_INT 3
21845: PPUSH
21846: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21850: LD_ADDR_VAR 0 1
21854: PUSH
21855: LD_EXP 18
21859: PUSH
21860: LD_INT 1
21862: ARRAY
21863: PUSH
21864: FOR_IN
21865: IFFALSE 22001
// begin if GetLives ( i ) < 990 then
21867: LD_VAR 0 1
21871: PPUSH
21872: CALL_OW 256
21876: PUSH
21877: LD_INT 990
21879: LESS
21880: IFFALSE 21894
// SetLives ( i , 1000 ) ;
21882: LD_VAR 0 1
21886: PPUSH
21887: LD_INT 1000
21889: PPUSH
21890: CALL_OW 234
// if not IsInUnit ( i ) then
21894: LD_VAR 0 1
21898: PPUSH
21899: CALL_OW 310
21903: NOT
21904: IFFALSE 21999
// begin if not HasTask ( i ) then
21906: LD_VAR 0 1
21910: PPUSH
21911: CALL_OW 314
21915: NOT
21916: IFFALSE 21933
// ComMoveXY ( i , 64 , 93 ) ;
21918: LD_VAR 0 1
21922: PPUSH
21923: LD_INT 64
21925: PPUSH
21926: LD_INT 93
21928: PPUSH
21929: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
21933: LD_VAR 0 4
21937: NOT
21938: PUSH
21939: LD_VAR 0 1
21943: PPUSH
21944: CALL_OW 258
21948: PUSH
21949: LD_INT 1
21951: EQUAL
21952: AND
21953: IFFALSE 21999
// begin retreat := true ;
21955: LD_ADDR_VAR 0 4
21959: PUSH
21960: LD_INT 1
21962: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21963: LD_VAR 0 1
21967: PPUSH
21968: LD_INT 2
21970: PPUSH
21971: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21975: LD_VAR 0 1
21979: PPUSH
21980: LD_STRING D4a-Sol1-1
21982: PPUSH
21983: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21987: LD_EXP 60
21991: PPUSH
21992: LD_STRING D4a-Pow-1
21994: PPUSH
21995: CALL_OW 88
// end ; end ; end ;
21999: GO 21864
22001: POP
22002: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22003: LD_EXP 18
22007: PUSH
22008: LD_INT 1
22010: ARRAY
22011: PPUSH
22012: LD_INT 95
22014: PUSH
22015: LD_INT 9
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: PUSH
22022: LD_INT 3
22024: PUSH
22025: LD_INT 55
22027: PUSH
22028: EMPTY
22029: LIST
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PPUSH
22039: CALL_OW 72
22043: PUSH
22044: LD_INT 4
22046: GREATEREQUAL
22047: IFFALSE 21843
// for i in powellSquadAttack [ 1 ] do
22049: LD_ADDR_VAR 0 1
22053: PUSH
22054: LD_EXP 18
22058: PUSH
22059: LD_INT 1
22061: ARRAY
22062: PUSH
22063: FOR_IN
22064: IFFALSE 22200
// begin if GetTag ( i ) = 2 then
22066: LD_VAR 0 1
22070: PPUSH
22071: CALL_OW 110
22075: PUSH
22076: LD_INT 2
22078: EQUAL
22079: IFFALSE 22141
// begin ComMoveXY ( i , 60 , 94 ) ;
22081: LD_VAR 0 1
22085: PPUSH
22086: LD_INT 60
22088: PPUSH
22089: LD_INT 94
22091: PPUSH
22092: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22096: LD_VAR 0 1
22100: PPUSH
22101: LD_EXP 60
22105: PPUSH
22106: CALL_OW 179
// wait ( 0 0$3 ) ;
22110: LD_INT 105
22112: PPUSH
22113: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22117: LD_VAR 0 1
22121: PPUSH
22122: LD_STRING D4a-Sol1-2
22124: PPUSH
22125: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22129: LD_EXP 60
22133: PPUSH
22134: LD_STRING D4a-Pow-2
22136: PPUSH
22137: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22141: LD_VAR 0 1
22145: PPUSH
22146: LD_INT 0
22148: PPUSH
22149: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22153: LD_ADDR_EXP 100
22157: PUSH
22158: LD_EXP 100
22162: PPUSH
22163: LD_INT 4
22165: PPUSH
22166: LD_EXP 100
22170: PUSH
22171: LD_INT 4
22173: ARRAY
22174: PUSH
22175: LD_VAR 0 1
22179: UNION
22180: PPUSH
22181: CALL_OW 1
22185: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22186: LD_INT 8
22188: PPUSH
22189: LD_VAR 0 1
22193: PPUSH
22194: CALL_OW 472
// end ;
22198: GO 22063
22200: POP
22201: POP
// wait ( 2 2$00 ) ;
22202: LD_INT 4200
22204: PPUSH
22205: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22209: LD_ADDR_VAR 0 9
22213: PUSH
22214: LD_INT 22
22216: PUSH
22217: LD_INT 4
22219: PUSH
22220: EMPTY
22221: LIST
22222: LIST
22223: PUSH
22224: LD_INT 30
22226: PUSH
22227: LD_INT 32
22229: PUSH
22230: EMPTY
22231: LIST
22232: LIST
22233: PUSH
22234: LD_INT 58
22236: PUSH
22237: EMPTY
22238: LIST
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: LIST
22244: PPUSH
22245: CALL_OW 69
22249: ST_TO_ADDR
// if tmp then
22250: LD_VAR 0 2
22254: IFFALSE 22494
// begin for i := 1 to tmp do
22256: LD_ADDR_VAR 0 1
22260: PUSH
22261: DOUBLE
22262: LD_INT 1
22264: DEC
22265: ST_TO_ADDR
22266: LD_VAR 0 2
22270: PUSH
22271: FOR_TO
22272: IFFALSE 22485
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22274: LD_ADDR_EXP 100
22278: PUSH
22279: LD_EXP 100
22283: PPUSH
22284: LD_INT 4
22286: PPUSH
22287: LD_EXP 100
22291: PUSH
22292: LD_INT 4
22294: ARRAY
22295: PUSH
22296: LD_VAR 0 2
22300: PUSH
22301: LD_VAR 0 1
22305: ARRAY
22306: DIFF
22307: PPUSH
22308: CALL_OW 1
22312: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22313: LD_ADDR_VAR 0 10
22317: PUSH
22318: LD_VAR 0 2
22322: PUSH
22323: LD_VAR 0 1
22327: ARRAY
22328: PPUSH
22329: CALL_OW 310
22333: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22334: LD_VAR 0 10
22338: PUSH
22339: LD_VAR 0 10
22343: PPUSH
22344: CALL_OW 266
22348: PUSH
22349: LD_INT 32
22351: EQUAL
22352: AND
22353: IFFALSE 22357
// continue ;
22355: GO 22271
// if t then
22357: LD_VAR 0 10
22361: IFFALSE 22378
// ComExitBuilding ( tmp [ i ] ) ;
22363: LD_VAR 0 2
22367: PUSH
22368: LD_VAR 0 1
22372: ARRAY
22373: PPUSH
22374: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22378: LD_VAR 0 2
22382: PUSH
22383: LD_VAR 0 1
22387: ARRAY
22388: PPUSH
22389: LD_VAR 0 5
22393: PUSH
22394: LD_INT 1
22396: ARRAY
22397: PPUSH
22398: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22402: LD_VAR 0 2
22406: PUSH
22407: LD_VAR 0 1
22411: ARRAY
22412: PPUSH
22413: LD_INT 1
22415: PPUSH
22416: CALL_OW 183
// if emptyTowers then
22420: LD_VAR 0 9
22424: IFFALSE 22483
// begin AddComExitBuilding ( tmp [ i ] ) ;
22426: LD_VAR 0 2
22430: PUSH
22431: LD_VAR 0 1
22435: ARRAY
22436: PPUSH
22437: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
22441: LD_VAR 0 2
22445: PUSH
22446: LD_VAR 0 1
22450: ARRAY
22451: PPUSH
22452: LD_VAR 0 9
22456: PUSH
22457: LD_INT 1
22459: ARRAY
22460: PPUSH
22461: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
22465: LD_ADDR_VAR 0 9
22469: PUSH
22470: LD_VAR 0 9
22474: PPUSH
22475: LD_INT 1
22477: PPUSH
22478: CALL_OW 3
22482: ST_TO_ADDR
// end ; end ;
22483: GO 22271
22485: POP
22486: POP
// wait ( 0 0$30 ) ;
22487: LD_INT 1050
22489: PPUSH
22490: CALL_OW 67
// end ; uc_side := 6 ;
22494: LD_ADDR_OWVAR 20
22498: PUSH
22499: LD_INT 6
22501: ST_TO_ADDR
// uc_nation := 3 ;
22502: LD_ADDR_OWVAR 21
22506: PUSH
22507: LD_INT 3
22509: ST_TO_ADDR
// ru := [ ] ;
22510: LD_ADDR_VAR 0 7
22514: PUSH
22515: EMPTY
22516: ST_TO_ADDR
// for i = 1 to 5 do
22517: LD_ADDR_VAR 0 1
22521: PUSH
22522: DOUBLE
22523: LD_INT 1
22525: DEC
22526: ST_TO_ADDR
22527: LD_INT 5
22529: PUSH
22530: FOR_TO
22531: IFFALSE 22651
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
22533: LD_INT 22
22535: PUSH
22536: LD_INT 23
22538: PUSH
22539: EMPTY
22540: LIST
22541: LIST
22542: PUSH
22543: LD_INT 1
22545: PPUSH
22546: LD_INT 2
22548: PPUSH
22549: CALL_OW 12
22553: ARRAY
22554: PPUSH
22555: LD_INT 1
22557: PPUSH
22558: LD_INT 3
22560: PPUSH
22561: LD_INT 43
22563: PUSH
22564: LD_INT 44
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: PUSH
22571: LD_INT 1
22573: PPUSH
22574: LD_INT 2
22576: PPUSH
22577: CALL_OW 12
22581: ARRAY
22582: PPUSH
22583: LD_INT 89
22585: PPUSH
22586: CALL 73635 0 5
// un := CreateVehicle ;
22590: LD_ADDR_VAR 0 8
22594: PUSH
22595: CALL_OW 45
22599: ST_TO_ADDR
// SetDir ( un , 4 ) ;
22600: LD_VAR 0 8
22604: PPUSH
22605: LD_INT 4
22607: PPUSH
22608: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
22612: LD_VAR 0 8
22616: PPUSH
22617: LD_INT 136
22619: PPUSH
22620: LD_INT 90
22622: PPUSH
22623: LD_INT 8
22625: PPUSH
22626: LD_INT 0
22628: PPUSH
22629: CALL_OW 50
// ru := ru ^ un ;
22633: LD_ADDR_VAR 0 7
22637: PUSH
22638: LD_VAR 0 7
22642: PUSH
22643: LD_VAR 0 8
22647: ADD
22648: ST_TO_ADDR
// end ;
22649: GO 22530
22651: POP
22652: POP
// if ru then
22653: LD_VAR 0 7
22657: IFFALSE 22674
// ComAgressiveMove ( ru , 57 , 94 ) ;
22659: LD_VAR 0 7
22663: PPUSH
22664: LD_INT 57
22666: PPUSH
22667: LD_INT 94
22669: PPUSH
22670: CALL_OW 114
// wait ( 3 3$00 ) ;
22674: LD_INT 6300
22676: PPUSH
22677: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22681: LD_INT 4
22683: PPUSH
22684: LD_INT 3
22686: PUSH
22687: LD_INT 1
22689: PUSH
22690: LD_INT 1
22692: PUSH
22693: LD_INT 5
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: LIST
22701: PUSH
22702: LD_INT 4
22704: PUSH
22705: LD_INT 1
22707: PUSH
22708: LD_INT 1
22710: PUSH
22711: LD_INT 6
22713: PUSH
22714: EMPTY
22715: LIST
22716: LIST
22717: LIST
22718: LIST
22719: PUSH
22720: LD_INT 4
22722: PUSH
22723: LD_INT 1
22725: PUSH
22726: LD_INT 1
22728: PUSH
22729: LD_INT 7
22731: PUSH
22732: EMPTY
22733: LIST
22734: LIST
22735: LIST
22736: LIST
22737: PUSH
22738: LD_INT 3
22740: PUSH
22741: LD_INT 1
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: LD_INT 7
22749: PUSH
22750: EMPTY
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: PUSH
22756: LD_INT 3
22758: PUSH
22759: LD_INT 1
22761: PUSH
22762: LD_INT 1
22764: PUSH
22765: LD_INT 5
22767: PUSH
22768: EMPTY
22769: LIST
22770: LIST
22771: LIST
22772: LIST
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: LIST
22780: PPUSH
22781: CALL 62321 0 2
// missionStage := 4 ;
22785: LD_ADDR_EXP 15
22789: PUSH
22790: LD_INT 4
22792: ST_TO_ADDR
// end ;
22793: PPOPN 10
22795: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
22796: LD_EXP 15
22800: PUSH
22801: LD_INT 4
22803: EQUAL
22804: PUSH
22805: LD_INT 22
22807: PUSH
22808: LD_INT 4
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: LD_INT 21
22817: PUSH
22818: LD_INT 2
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: PUSH
22825: EMPTY
22826: LIST
22827: LIST
22828: PPUSH
22829: CALL_OW 69
22833: PUSH
22834: LD_INT 5
22836: GREATEREQUAL
22837: AND
22838: IFFALSE 27105
22840: GO 22842
22842: DISABLE
22843: LD_INT 0
22845: PPUSH
22846: PPUSH
22847: PPUSH
22848: PPUSH
22849: PPUSH
22850: PPUSH
22851: PPUSH
22852: PPUSH
22853: PPUSH
22854: PPUSH
22855: PPUSH
22856: PPUSH
22857: PPUSH
// begin wait ( 0 0$10 ) ;
22858: LD_INT 350
22860: PPUSH
22861: CALL_OW 67
// missionStage := 5 ;
22865: LD_ADDR_EXP 15
22869: PUSH
22870: LD_INT 5
22872: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
22873: LD_ADDR_VAR 0 10
22877: PUSH
22878: LD_INT 22
22880: PUSH
22881: LD_INT 4
22883: PUSH
22884: EMPTY
22885: LIST
22886: LIST
22887: PUSH
22888: LD_INT 2
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 4
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: LD_INT 30
22903: PUSH
22904: LD_INT 5
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: LIST
22915: PUSH
22916: EMPTY
22917: LIST
22918: LIST
22919: PPUSH
22920: CALL_OW 69
22924: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
22925: LD_ADDR_VAR 0 6
22929: PUSH
22930: LD_INT 22
22932: PUSH
22933: LD_INT 4
22935: PUSH
22936: EMPTY
22937: LIST
22938: LIST
22939: PUSH
22940: LD_INT 21
22942: PUSH
22943: LD_INT 1
22945: PUSH
22946: EMPTY
22947: LIST
22948: LIST
22949: PUSH
22950: LD_INT 3
22952: PUSH
22953: LD_INT 25
22955: PUSH
22956: LD_INT 16
22958: PUSH
22959: EMPTY
22960: LIST
22961: LIST
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: PUSH
22967: LD_INT 3
22969: PUSH
22970: LD_INT 25
22972: PUSH
22973: LD_INT 12
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: PUSH
22980: EMPTY
22981: LIST
22982: LIST
22983: PUSH
22984: EMPTY
22985: LIST
22986: LIST
22987: LIST
22988: LIST
22989: PPUSH
22990: CALL_OW 69
22994: PUSH
22995: LD_EXP 60
22999: DIFF
23000: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23001: LD_ADDR_VAR 0 9
23005: PUSH
23006: LD_INT 22
23008: PUSH
23009: LD_INT 4
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: PUSH
23016: LD_INT 30
23018: PUSH
23019: LD_INT 3
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL_OW 69
23034: PUSH
23035: LD_INT 1
23037: ARRAY
23038: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23039: LD_INT 350
23041: PPUSH
23042: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23046: LD_EXP 119
23050: PUSH
23051: LD_INT 4
23053: ARRAY
23054: PUSH
23055: LD_INT 5
23057: LESS
23058: PUSH
23059: LD_VAR 0 9
23063: PPUSH
23064: CALL_OW 461
23068: PUSH
23069: LD_INT 2
23071: EQUAL
23072: AND
23073: IFFALSE 23103
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23075: LD_INT 4
23077: PPUSH
23078: LD_INT 3
23080: PUSH
23081: LD_INT 1
23083: PUSH
23084: LD_INT 1
23086: PUSH
23087: LD_INT 5
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: PUSH
23096: EMPTY
23097: LIST
23098: PPUSH
23099: CALL 62369 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23103: LD_EXP 119
23107: PUSH
23108: LD_INT 4
23110: ARRAY
23111: PUSH
23112: LD_INT 5
23114: GREATEREQUAL
23115: PUSH
23116: LD_EXP 119
23120: PUSH
23121: LD_INT 4
23123: ARRAY
23124: PPUSH
23125: LD_INT 58
23127: PUSH
23128: EMPTY
23129: LIST
23130: PPUSH
23131: CALL_OW 72
23135: PUSH
23136: LD_INT 5
23138: GREATEREQUAL
23139: AND
23140: IFFALSE 23039
// powellAllowRetreat := false ;
23142: LD_ADDR_EXP 19
23146: PUSH
23147: LD_INT 0
23149: ST_TO_ADDR
// activeAttacks := false ;
23150: LD_ADDR_EXP 16
23154: PUSH
23155: LD_INT 0
23157: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23158: LD_INT 35
23160: PPUSH
23161: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23165: LD_INT 22
23167: PUSH
23168: LD_INT 6
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PPUSH
23175: CALL_OW 69
23179: PUSH
23180: LD_INT 0
23182: EQUAL
23183: IFFALSE 23158
// tmp := mc_vehicles [ 4 ] ;
23185: LD_ADDR_VAR 0 3
23189: PUSH
23190: LD_EXP 119
23194: PUSH
23195: LD_INT 4
23197: ARRAY
23198: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23199: LD_ADDR_VAR 0 1
23203: PUSH
23204: DOUBLE
23205: LD_INT 1
23207: DEC
23208: ST_TO_ADDR
23209: LD_EXP 18
23213: PUSH
23214: FOR_TO
23215: IFFALSE 23476
// begin for j in powellSquadAttack [ i ] do
23217: LD_ADDR_VAR 0 2
23221: PUSH
23222: LD_EXP 18
23226: PUSH
23227: LD_VAR 0 1
23231: ARRAY
23232: PUSH
23233: FOR_IN
23234: IFFALSE 23472
// begin forces := forces diff j ;
23236: LD_ADDR_VAR 0 6
23240: PUSH
23241: LD_VAR 0 6
23245: PUSH
23246: LD_VAR 0 2
23250: DIFF
23251: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23252: LD_VAR 0 2
23256: PPUSH
23257: LD_INT 1
23259: PPUSH
23260: CALL_OW 109
// wait ( 0 0$2 ) ;
23264: LD_INT 70
23266: PPUSH
23267: CALL_OW 67
// if IsInUnit ( j ) then
23271: LD_VAR 0 2
23275: PPUSH
23276: CALL_OW 310
23280: IFFALSE 23291
// ComExitBuilding ( j ) ;
23282: LD_VAR 0 2
23286: PPUSH
23287: CALL_OW 122
// if GetClass ( j ) <> 1 then
23291: LD_VAR 0 2
23295: PPUSH
23296: CALL_OW 257
23300: PUSH
23301: LD_INT 1
23303: NONEQUAL
23304: IFFALSE 23384
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23306: LD_VAR 0 10
23310: PUSH
23311: LD_INT 1
23313: ARRAY
23314: PPUSH
23315: CALL_OW 313
23319: PUSH
23320: LD_INT 5
23322: GREATEREQUAL
23323: IFFALSE 23345
// AddComEnterUnit ( j , arm [ 2 ] ) else
23325: LD_VAR 0 2
23329: PPUSH
23330: LD_VAR 0 10
23334: PUSH
23335: LD_INT 2
23337: ARRAY
23338: PPUSH
23339: CALL_OW 180
23343: GO 23363
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23345: LD_VAR 0 2
23349: PPUSH
23350: LD_VAR 0 10
23354: PUSH
23355: LD_INT 1
23357: ARRAY
23358: PPUSH
23359: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
23363: LD_VAR 0 2
23367: PPUSH
23368: LD_INT 1
23370: PPUSH
23371: CALL_OW 183
// AddComExitBuilding ( j ) ;
23375: LD_VAR 0 2
23379: PPUSH
23380: CALL_OW 182
// end ; if i = 2 then
23384: LD_VAR 0 1
23388: PUSH
23389: LD_INT 2
23391: EQUAL
23392: IFFALSE 23409
// AddComMoveXY ( j , 61 , 93 ) ;
23394: LD_VAR 0 2
23398: PPUSH
23399: LD_INT 61
23401: PPUSH
23402: LD_INT 93
23404: PPUSH
23405: CALL_OW 171
// if i = 1 then
23409: LD_VAR 0 1
23413: PUSH
23414: LD_INT 1
23416: EQUAL
23417: IFFALSE 23470
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
23419: LD_VAR 0 2
23423: PPUSH
23424: LD_VAR 0 3
23428: PUSH
23429: LD_INT 1
23431: ARRAY
23432: PPUSH
23433: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
23437: LD_ADDR_VAR 0 3
23441: PUSH
23442: LD_VAR 0 3
23446: PPUSH
23447: LD_INT 1
23449: PPUSH
23450: CALL_OW 3
23454: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
23455: LD_VAR 0 2
23459: PPUSH
23460: LD_INT 69
23462: PPUSH
23463: LD_INT 94
23465: PPUSH
23466: CALL_OW 171
// end ; end ;
23470: GO 23233
23472: POP
23473: POP
// end ;
23474: GO 23214
23476: POP
23477: POP
// wait ( 0 0$30 ) ;
23478: LD_INT 1050
23480: PPUSH
23481: CALL_OW 67
// MC_Kill ( 4 ) ;
23485: LD_INT 4
23487: PPUSH
23488: CALL 38358 0 1
// tmp := UnitsInside ( fac ) ;
23492: LD_ADDR_VAR 0 3
23496: PUSH
23497: LD_VAR 0 9
23501: PPUSH
23502: CALL_OW 313
23506: ST_TO_ADDR
// if tmp then
23507: LD_VAR 0 3
23511: IFFALSE 23632
// for i in tmp do
23513: LD_ADDR_VAR 0 1
23517: PUSH
23518: LD_VAR 0 3
23522: PUSH
23523: FOR_IN
23524: IFFALSE 23630
// begin ComExitBuilding ( i ) ;
23526: LD_VAR 0 1
23530: PPUSH
23531: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
23535: LD_VAR 0 10
23539: PUSH
23540: LD_INT 2
23542: ARRAY
23543: PPUSH
23544: CALL_OW 313
23548: PUSH
23549: LD_INT 6
23551: LESS
23552: IFFALSE 23574
// AddComEnterUnit ( i , arm [ 2 ] ) else
23554: LD_VAR 0 1
23558: PPUSH
23559: LD_VAR 0 10
23563: PUSH
23564: LD_INT 2
23566: ARRAY
23567: PPUSH
23568: CALL_OW 180
23572: GO 23628
// if UnitsInside ( arm [ 1 ] ) < 6 then
23574: LD_VAR 0 10
23578: PUSH
23579: LD_INT 1
23581: ARRAY
23582: PPUSH
23583: CALL_OW 313
23587: PUSH
23588: LD_INT 6
23590: LESS
23591: IFFALSE 23613
// AddComEnterUnit ( i , arm [ 1 ] ) else
23593: LD_VAR 0 1
23597: PPUSH
23598: LD_VAR 0 10
23602: PUSH
23603: LD_INT 1
23605: ARRAY
23606: PPUSH
23607: CALL_OW 180
23611: GO 23628
// AddComMoveXY ( i , 37 , 68 ) ;
23613: LD_VAR 0 1
23617: PPUSH
23618: LD_INT 37
23620: PPUSH
23621: LD_INT 68
23623: PPUSH
23624: CALL_OW 171
// end ;
23628: GO 23523
23630: POP
23631: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
23632: LD_ADDR_VAR 0 11
23636: PUSH
23637: LD_VAR 0 6
23641: PPUSH
23642: LD_INT 26
23644: PUSH
23645: LD_INT 1
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PPUSH
23652: CALL_OW 72
23656: PUSH
23657: LD_EXP 61
23661: DIFF
23662: ST_TO_ADDR
// if not speaker then
23663: LD_VAR 0 11
23667: NOT
23668: IFFALSE 23695
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
23670: LD_ADDR_VAR 0 11
23674: PUSH
23675: LD_VAR 0 6
23679: PPUSH
23680: LD_INT 26
23682: PUSH
23683: LD_INT 1
23685: PUSH
23686: EMPTY
23687: LIST
23688: LIST
23689: PPUSH
23690: CALL_OW 72
23694: ST_TO_ADDR
// if speaker then
23695: LD_VAR 0 11
23699: IFFALSE 23715
// speaker := speaker [ 1 ] ;
23701: LD_ADDR_VAR 0 11
23705: PUSH
23706: LD_VAR 0 11
23710: PUSH
23711: LD_INT 1
23713: ARRAY
23714: ST_TO_ADDR
// Video ( true ) ;
23715: LD_INT 1
23717: PPUSH
23718: CALL 106059 0 1
// CenterNowOnUnits ( Powell ) ;
23722: LD_EXP 60
23726: PPUSH
23727: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
23731: LD_ADDR_VAR 0 3
23735: PUSH
23736: LD_VAR 0 6
23740: PPUSH
23741: LD_INT 3
23743: PUSH
23744: LD_INT 25
23746: PUSH
23747: LD_INT 1
23749: PUSH
23750: EMPTY
23751: LIST
23752: LIST
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: PPUSH
23758: CALL_OW 72
23762: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23763: LD_ADDR_VAR 0 12
23767: PUSH
23768: LD_INT 22
23770: PUSH
23771: LD_INT 4
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PUSH
23778: LD_INT 30
23780: PUSH
23781: LD_INT 32
23783: PUSH
23784: EMPTY
23785: LIST
23786: LIST
23787: PUSH
23788: LD_INT 58
23790: PUSH
23791: EMPTY
23792: LIST
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: LIST
23798: PPUSH
23799: CALL_OW 69
23803: ST_TO_ADDR
// for i := 1 to 4 do
23804: LD_ADDR_VAR 0 1
23808: PUSH
23809: DOUBLE
23810: LD_INT 1
23812: DEC
23813: ST_TO_ADDR
23814: LD_INT 4
23816: PUSH
23817: FOR_TO
23818: IFFALSE 23964
// begin if IsInUnit ( tmp [ i ] ) then
23820: LD_VAR 0 3
23824: PUSH
23825: LD_VAR 0 1
23829: ARRAY
23830: PPUSH
23831: CALL_OW 310
23835: IFFALSE 23852
// ComExitBuilding ( tmp [ i ] ) ;
23837: LD_VAR 0 3
23841: PUSH
23842: LD_VAR 0 1
23846: ARRAY
23847: PPUSH
23848: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23852: LD_VAR 0 3
23856: PUSH
23857: LD_VAR 0 1
23861: ARRAY
23862: PPUSH
23863: LD_VAR 0 10
23867: PUSH
23868: LD_INT 1
23870: ARRAY
23871: PPUSH
23872: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23876: LD_VAR 0 3
23880: PUSH
23881: LD_VAR 0 1
23885: ARRAY
23886: PPUSH
23887: LD_INT 1
23889: PPUSH
23890: CALL_OW 183
// if Count ( emp_towers ) then
23894: LD_VAR 0 12
23898: PPUSH
23899: CALL 70897 0 1
23903: IFFALSE 23962
// begin AddComExitBuilding ( tmp [ i ] ) ;
23905: LD_VAR 0 3
23909: PUSH
23910: LD_VAR 0 1
23914: ARRAY
23915: PPUSH
23916: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
23920: LD_VAR 0 3
23924: PUSH
23925: LD_VAR 0 1
23929: ARRAY
23930: PPUSH
23931: LD_VAR 0 12
23935: PUSH
23936: LD_INT 1
23938: ARRAY
23939: PPUSH
23940: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23944: LD_ADDR_VAR 0 12
23948: PUSH
23949: LD_VAR 0 12
23953: PPUSH
23954: LD_INT 1
23956: PPUSH
23957: CALL_OW 3
23961: ST_TO_ADDR
// end ; end ;
23962: GO 23817
23964: POP
23965: POP
// wait ( 0 0$5 ) ;
23966: LD_INT 175
23968: PPUSH
23969: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
23973: LD_VAR 0 3
23977: PPUSH
23978: LD_INT 3
23980: PUSH
23981: LD_INT 54
23983: PUSH
23984: EMPTY
23985: LIST
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PPUSH
23991: CALL_OW 72
23995: IFFALSE 24015
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
23997: LD_VAR 0 3
24001: PPUSH
24002: LD_VAR 0 10
24006: PUSH
24007: LD_INT 1
24009: ARRAY
24010: PPUSH
24011: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24015: LD_ADDR_VAR 0 3
24019: PUSH
24020: LD_EXP 18
24024: PUSH
24025: LD_INT 1
24027: ARRAY
24028: PUSH
24029: LD_EXP 18
24033: PUSH
24034: LD_INT 2
24036: ARRAY
24037: ADD
24038: PPUSH
24039: LD_INT 26
24041: PUSH
24042: LD_INT 1
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: PPUSH
24049: CALL_OW 72
24053: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24054: LD_ADDR_VAR 0 1
24058: PUSH
24059: LD_EXP 18
24063: PUSH
24064: LD_INT 2
24066: ARRAY
24067: PUSH
24068: FOR_IN
24069: IFFALSE 24087
// ComTurnUnit ( i , Powell ) ;
24071: LD_VAR 0 1
24075: PPUSH
24076: LD_EXP 60
24080: PPUSH
24081: CALL_OW 119
24085: GO 24068
24087: POP
24088: POP
// Say ( Powell , D5-Pow-1 ) ;
24089: LD_EXP 60
24093: PPUSH
24094: LD_STRING D5-Pow-1
24096: PPUSH
24097: CALL_OW 88
// if tmp then
24101: LD_VAR 0 3
24105: IFFALSE 24123
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24107: LD_VAR 0 3
24111: PUSH
24112: LD_INT 1
24114: ARRAY
24115: PPUSH
24116: LD_STRING D5-Sol2-1
24118: PPUSH
24119: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24123: LD_EXP 60
24127: PPUSH
24128: LD_STRING D5-Pow-2
24130: PPUSH
24131: CALL_OW 88
// if tmp > 1 then
24135: LD_VAR 0 3
24139: PUSH
24140: LD_INT 1
24142: GREATER
24143: IFFALSE 24161
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24145: LD_VAR 0 3
24149: PUSH
24150: LD_INT 2
24152: ARRAY
24153: PPUSH
24154: LD_STRING D5-Sol2-2
24156: PPUSH
24157: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24161: LD_EXP 60
24165: PPUSH
24166: LD_STRING D5-Pow-3
24168: PPUSH
24169: CALL_OW 88
// wait ( 0 0$1 ) ;
24173: LD_INT 35
24175: PPUSH
24176: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24180: LD_ADDR_VAR 0 3
24184: PUSH
24185: LD_EXP 18
24189: PUSH
24190: LD_INT 1
24192: ARRAY
24193: PUSH
24194: LD_EXP 18
24198: PUSH
24199: LD_INT 2
24201: ARRAY
24202: UNION
24203: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24204: LD_VAR 0 3
24208: PPUSH
24209: LD_INT 80
24211: PPUSH
24212: LD_INT 67
24214: PPUSH
24215: CALL_OW 114
// wait ( 0 0$2 ) ;
24219: LD_INT 70
24221: PPUSH
24222: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24226: LD_INT 79
24228: PPUSH
24229: LD_INT 72
24231: PPUSH
24232: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24236: LD_INT 70
24238: PPUSH
24239: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24243: LD_VAR 0 3
24247: PPUSH
24248: LD_INT 3
24250: PUSH
24251: LD_INT 24
24253: PUSH
24254: LD_INT 1000
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: EMPTY
24262: LIST
24263: LIST
24264: PPUSH
24265: CALL_OW 72
24269: IFFALSE 24236
// Say ( Powell , D5a-Pow-1 ) ;
24271: LD_EXP 60
24275: PPUSH
24276: LD_STRING D5a-Pow-1
24278: PPUSH
24279: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24283: LD_EXP 60
24287: PPUSH
24288: LD_STRING D5a-Pow-1a
24290: PPUSH
24291: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24295: LD_INT 24
24297: PPUSH
24298: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24302: LD_EXP 60
24306: PPUSH
24307: LD_STRING D5a-Pow-1b
24309: PPUSH
24310: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24314: LD_INT 10
24316: PPUSH
24317: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24321: LD_EXP 60
24325: PPUSH
24326: LD_STRING D5a-Pow-1c
24328: PPUSH
24329: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24333: LD_VAR 0 3
24337: PPUSH
24338: LD_INT 68
24340: PPUSH
24341: LD_INT 63
24343: PPUSH
24344: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24348: LD_INT 18
24350: PPUSH
24351: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24355: LD_EXP 60
24359: PPUSH
24360: LD_STRING D5a-Pow-1d
24362: PPUSH
24363: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
24367: LD_INT 35
24369: PPUSH
24370: CALL_OW 67
// if not HasTask ( tmp ) then
24374: LD_VAR 0 3
24378: PPUSH
24379: CALL_OW 314
24383: NOT
24384: IFFALSE 24401
// ComAgressiveMove ( tmp , 68 , 63 ) ;
24386: LD_VAR 0 3
24390: PPUSH
24391: LD_INT 68
24393: PPUSH
24394: LD_INT 63
24396: PPUSH
24397: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
24401: LD_VAR 0 3
24405: PPUSH
24406: LD_INT 24
24408: PUSH
24409: LD_INT 1
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: PPUSH
24416: CALL_OW 72
24420: NOT
24421: IFFALSE 24367
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
24423: LD_ADDR_VAR 0 3
24427: PUSH
24428: LD_INT 22
24430: PUSH
24431: LD_INT 4
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 92
24440: PUSH
24441: LD_INT 60
24443: PUSH
24444: LD_INT 93
24446: PUSH
24447: LD_INT 10
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: PUSH
24456: LD_INT 3
24458: PUSH
24459: LD_INT 54
24461: PUSH
24462: EMPTY
24463: LIST
24464: PUSH
24465: EMPTY
24466: LIST
24467: LIST
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: LIST
24473: PPUSH
24474: CALL_OW 69
24478: PUSH
24479: LD_EXP 60
24483: DIFF
24484: ST_TO_ADDR
// if tmp then
24485: LD_VAR 0 3
24489: IFFALSE 24523
// for i in tmp do
24491: LD_ADDR_VAR 0 1
24495: PUSH
24496: LD_VAR 0 3
24500: PUSH
24501: FOR_IN
24502: IFFALSE 24521
// ComMoveXY ( i , 36 , 67 ) ;
24504: LD_VAR 0 1
24508: PPUSH
24509: LD_INT 36
24511: PPUSH
24512: LD_INT 67
24514: PPUSH
24515: CALL_OW 111
24519: GO 24501
24521: POP
24522: POP
// wait ( 0 0$3 ) ;
24523: LD_INT 105
24525: PPUSH
24526: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
24530: LD_VAR 0 11
24534: PPUSH
24535: LD_STRING D6-Sol3-1
24537: PPUSH
24538: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
24542: LD_EXP 60
24546: PPUSH
24547: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
24551: LD_EXP 60
24555: PPUSH
24556: LD_STRING D6-Pow-1
24558: PPUSH
24559: CALL_OW 88
// tmp := [ ] ;
24563: LD_ADDR_VAR 0 3
24567: PUSH
24568: EMPTY
24569: ST_TO_ADDR
// for i = 1 to 2 do
24570: LD_ADDR_VAR 0 1
24574: PUSH
24575: DOUBLE
24576: LD_INT 1
24578: DEC
24579: ST_TO_ADDR
24580: LD_INT 2
24582: PUSH
24583: FOR_TO
24584: IFFALSE 24698
// begin uc_side := 8 ;
24586: LD_ADDR_OWVAR 20
24590: PUSH
24591: LD_INT 8
24593: ST_TO_ADDR
// uc_nation := 2 ;
24594: LD_ADDR_OWVAR 21
24598: PUSH
24599: LD_INT 2
24601: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
24602: LD_INT 14
24604: PPUSH
24605: LD_INT 3
24607: PPUSH
24608: LD_INT 2
24610: PPUSH
24611: LD_INT 29
24613: PPUSH
24614: LD_INT 100
24616: PPUSH
24617: CALL 73635 0 5
// veh := CreateVehicle ;
24621: LD_ADDR_VAR 0 13
24625: PUSH
24626: CALL_OW 45
24630: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
24631: LD_VAR 0 13
24635: PPUSH
24636: LD_INT 4
24638: PPUSH
24639: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
24643: LD_VAR 0 13
24647: PPUSH
24648: LD_INT 99
24650: PPUSH
24651: LD_INT 83
24653: PPUSH
24654: LD_INT 3
24656: PPUSH
24657: LD_INT 0
24659: PPUSH
24660: CALL_OW 50
// wait ( 3 ) ;
24664: LD_INT 3
24666: PPUSH
24667: CALL_OW 67
// Connect ( veh ) ;
24671: LD_VAR 0 13
24675: PPUSH
24676: CALL 76726 0 1
// tmp := tmp ^ veh ;
24680: LD_ADDR_VAR 0 3
24684: PUSH
24685: LD_VAR 0 3
24689: PUSH
24690: LD_VAR 0 13
24694: ADD
24695: ST_TO_ADDR
// end ;
24696: GO 24583
24698: POP
24699: POP
// wait ( 0 0$1 ) ;
24700: LD_INT 35
24702: PPUSH
24703: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
24707: LD_INT 99
24709: PPUSH
24710: LD_INT 83
24712: PPUSH
24713: LD_INT 1
24715: PPUSH
24716: LD_INT 10
24718: PPUSH
24719: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
24723: LD_INT 99
24725: PPUSH
24726: LD_INT 83
24728: PPUSH
24729: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
24733: LD_VAR 0 11
24737: PPUSH
24738: LD_STRING D6-Sol3-2
24740: PPUSH
24741: CALL_OW 88
// async ;
24745: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
24746: LD_EXP 60
24750: PPUSH
24751: LD_STRING D6-Pow-2
24753: PPUSH
24754: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
24758: LD_VAR 0 3
24762: PUSH
24763: LD_INT 1
24765: ARRAY
24766: PPUSH
24767: LD_VAR 0 9
24771: PPUSH
24772: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
24776: LD_VAR 0 3
24780: PUSH
24781: LD_INT 2
24783: ARRAY
24784: PPUSH
24785: LD_INT 22
24787: PUSH
24788: LD_INT 4
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 21
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PPUSH
24809: CALL_OW 69
24813: PPUSH
24814: LD_VAR 0 3
24818: PUSH
24819: LD_INT 2
24821: ARRAY
24822: PPUSH
24823: CALL_OW 74
24827: PPUSH
24828: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
24832: LD_EXP 60
24836: PPUSH
24837: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
24841: LD_INT 99
24843: PPUSH
24844: LD_INT 83
24846: PPUSH
24847: LD_INT 1
24849: PPUSH
24850: CALL_OW 331
// repeat wait ( 4 ) ;
24854: LD_INT 4
24856: PPUSH
24857: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
24861: LD_VAR 0 3
24865: PUSH
24866: LD_INT 1
24868: ARRAY
24869: PPUSH
24870: CALL_OW 256
24874: PUSH
24875: LD_INT 1000
24877: LESS
24878: IFFALSE 24896
// SetLives ( tmp [ 1 ] , 1000 ) ;
24880: LD_VAR 0 3
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: LD_INT 1000
24891: PPUSH
24892: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
24896: LD_INT 22
24898: PUSH
24899: LD_INT 4
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_INT 30
24908: PUSH
24909: LD_INT 3
24911: PUSH
24912: EMPTY
24913: LIST
24914: LIST
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: PUSH
24925: LD_INT 0
24927: EQUAL
24928: IFFALSE 24854
// skirmish := false ;
24930: LD_ADDR_EXP 98
24934: PUSH
24935: LD_INT 0
24937: ST_TO_ADDR
// sync ;
24938: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
24939: LD_EXP 60
24943: PPUSH
24944: LD_STRING D6a-Pow-1
24946: PPUSH
24947: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
24951: LD_VAR 0 11
24955: PPUSH
24956: LD_STRING D6a-Sol3-1
24958: PPUSH
24959: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
24963: LD_EXP 60
24967: PPUSH
24968: LD_STRING D6a-Pow-2
24970: PPUSH
24971: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
24975: LD_VAR 0 11
24979: PPUSH
24980: LD_STRING D6a-Sol3-2
24982: PPUSH
24983: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
24987: LD_EXP 60
24991: PPUSH
24992: LD_STRING D6a-Pow-3
24994: PPUSH
24995: CALL_OW 88
// powellCenterCameraMode := true ;
24999: LD_ADDR_EXP 20
25003: PUSH
25004: LD_INT 1
25006: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25007: LD_ADDR_VAR 0 1
25011: PUSH
25012: LD_INT 22
25014: PUSH
25015: LD_INT 8
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: LD_INT 25
25024: PUSH
25025: LD_INT 2
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: PPUSH
25036: CALL_OW 69
25040: PUSH
25041: FOR_IN
25042: IFFALSE 25097
// begin SetTag ( i , 1 ) ;
25044: LD_VAR 0 1
25048: PPUSH
25049: LD_INT 1
25051: PPUSH
25052: CALL_OW 109
// ComExitBuilding ( i ) ;
25056: LD_VAR 0 1
25060: PPUSH
25061: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25065: LD_VAR 0 1
25069: PPUSH
25070: LD_INT 35
25072: PPUSH
25073: LD_INT 6
25075: PPUSH
25076: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25080: LD_VAR 0 1
25084: PPUSH
25085: LD_INT 53
25087: PPUSH
25088: LD_INT 4
25090: PPUSH
25091: CALL_OW 171
// end ;
25095: GO 25041
25097: POP
25098: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25099: LD_ADDR_VAR 0 3
25103: PUSH
25104: LD_INT 22
25106: PUSH
25107: LD_INT 4
25109: PUSH
25110: EMPTY
25111: LIST
25112: LIST
25113: PUSH
25114: LD_INT 21
25116: PUSH
25117: LD_INT 2
25119: PUSH
25120: EMPTY
25121: LIST
25122: LIST
25123: PUSH
25124: LD_INT 3
25126: PUSH
25127: LD_INT 34
25129: PUSH
25130: LD_INT 12
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: LIST
25145: PPUSH
25146: CALL_OW 69
25150: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_VAR 0 3
25160: PPUSH
25161: LD_EXP 60
25165: PPUSH
25166: CALL_OW 74
25170: PPUSH
25171: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25175: LD_EXP 60
25179: PPUSH
25180: LD_INT 100
25182: PPUSH
25183: LD_INT 88
25185: PPUSH
25186: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25190: LD_EXP 60
25194: PPUSH
25195: LD_INT 100
25197: PPUSH
25198: LD_INT 75
25200: PPUSH
25201: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25205: LD_EXP 60
25209: PPUSH
25210: LD_INT 88
25212: PPUSH
25213: LD_INT 53
25215: PPUSH
25216: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25220: LD_INT 8
25222: PPUSH
25223: LD_EXP 60
25227: PPUSH
25228: CALL_OW 471
// repeat wait ( 3 ) ;
25232: LD_INT 3
25234: PPUSH
25235: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25239: LD_INT 22
25241: PUSH
25242: LD_INT 4
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: PUSH
25249: LD_INT 92
25251: PUSH
25252: LD_INT 100
25254: PUSH
25255: LD_INT 75
25257: PUSH
25258: LD_INT 6
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: PUSH
25267: EMPTY
25268: LIST
25269: LIST
25270: PPUSH
25271: CALL_OW 69
25275: IFFALSE 25232
// async ;
25277: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25278: LD_EXP 60
25282: PPUSH
25283: LD_STRING D6b-Pow-1
25285: PPUSH
25286: CALL_OW 88
// repeat wait ( 3 ) ;
25290: LD_INT 3
25292: PPUSH
25293: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25297: LD_EXP 60
25301: PPUSH
25302: CALL_OW 310
25306: PPUSH
25307: CALL_OW 256
25311: PUSH
25312: LD_INT 1000
25314: LESS
25315: IFFALSE 25334
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25317: LD_EXP 60
25321: PPUSH
25322: CALL_OW 310
25326: PPUSH
25327: LD_INT 1000
25329: PPUSH
25330: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25334: LD_EXP 60
25338: PPUSH
25339: CALL_OW 256
25343: PUSH
25344: LD_INT 1000
25346: LESS
25347: IFFALSE 25361
// SetLives ( Powell , 1000 ) ;
25349: LD_EXP 60
25353: PPUSH
25354: LD_INT 1000
25356: PPUSH
25357: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
25361: LD_EXP 60
25365: PPUSH
25366: LD_EXP 65
25370: PPUSH
25371: CALL_OW 296
25375: PUSH
25376: LD_INT 5
25378: LESS
25379: PUSH
25380: LD_EXP 60
25384: PPUSH
25385: CALL_OW 310
25389: PPUSH
25390: LD_EXP 65
25394: PPUSH
25395: CALL_OW 296
25399: PUSH
25400: LD_INT 5
25402: LESS
25403: OR
25404: IFFALSE 25423
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
25406: LD_EXP 60
25410: PPUSH
25411: CALL_OW 310
25415: PPUSH
25416: LD_INT 100
25418: PPUSH
25419: CALL_OW 234
// until not IsInUnit ( Powell ) ;
25423: LD_EXP 60
25427: PPUSH
25428: CALL_OW 310
25432: NOT
25433: IFFALSE 25290
// DoNotAttack ( 8 , powellBomb ) ;
25435: LD_INT 8
25437: PPUSH
25438: LD_EXP 65
25442: PPUSH
25443: CALL_OW 471
// game_speed := 4 ;
25447: LD_ADDR_OWVAR 65
25451: PUSH
25452: LD_INT 4
25454: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
25455: LD_EXP 60
25459: PPUSH
25460: LD_STRING D6b-Pow-1a
25462: PPUSH
25463: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
25467: LD_EXP 60
25471: PPUSH
25472: LD_EXP 65
25476: PPUSH
25477: CALL_OW 180
// sync ;
25481: SYNC
// repeat wait ( 0 0$1 ) ;
25482: LD_INT 35
25484: PPUSH
25485: CALL_OW 67
// until IsInUnit ( Powell ) ;
25489: LD_EXP 60
25493: PPUSH
25494: CALL_OW 310
25498: IFFALSE 25482
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
25500: LD_INT 8
25502: PPUSH
25503: LD_EXP 60
25507: PPUSH
25508: CALL_OW 310
25512: PPUSH
25513: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
25517: LD_EXP 60
25521: PPUSH
25522: LD_INT 91
25524: PPUSH
25525: LD_INT 44
25527: PPUSH
25528: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25532: LD_EXP 60
25536: PPUSH
25537: LD_INT 96
25539: PPUSH
25540: LD_INT 44
25542: PPUSH
25543: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25547: LD_EXP 60
25551: PPUSH
25552: LD_INT 96
25554: PPUSH
25555: LD_INT 41
25557: PPUSH
25558: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25562: LD_EXP 60
25566: PPUSH
25567: LD_INT 92
25569: PPUSH
25570: LD_INT 39
25572: PPUSH
25573: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25577: LD_EXP 60
25581: PPUSH
25582: LD_INT 88
25584: PPUSH
25585: LD_INT 41
25587: PPUSH
25588: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25592: LD_EXP 60
25596: PPUSH
25597: LD_INT 91
25599: PPUSH
25600: LD_INT 44
25602: PPUSH
25603: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25607: LD_EXP 60
25611: PPUSH
25612: LD_INT 96
25614: PPUSH
25615: LD_INT 44
25617: PPUSH
25618: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25622: LD_EXP 60
25626: PPUSH
25627: LD_INT 96
25629: PPUSH
25630: LD_INT 41
25632: PPUSH
25633: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25637: LD_EXP 60
25641: PPUSH
25642: LD_INT 92
25644: PPUSH
25645: LD_INT 39
25647: PPUSH
25648: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25652: LD_EXP 60
25656: PPUSH
25657: LD_INT 88
25659: PPUSH
25660: LD_INT 41
25662: PPUSH
25663: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25667: LD_EXP 60
25671: PPUSH
25672: LD_INT 91
25674: PPUSH
25675: LD_INT 44
25677: PPUSH
25678: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
25682: LD_EXP 60
25686: PPUSH
25687: LD_INT 93
25689: PPUSH
25690: LD_INT 39
25692: PPUSH
25693: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
25697: LD_EXP 60
25701: PPUSH
25702: LD_INT 93
25704: PPUSH
25705: LD_INT 36
25707: PPUSH
25708: CALL_OW 171
// wait ( 0 0$3.5 ) ;
25712: LD_INT 122
25714: PPUSH
25715: CALL_OW 67
// game_speed := 4 ;
25719: LD_ADDR_OWVAR 65
25723: PUSH
25724: LD_INT 4
25726: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
25727: LD_EXP 60
25731: PPUSH
25732: LD_STRING D6b-Pow-1b
25734: PPUSH
25735: CALL_OW 88
// tmp := [ ] ;
25739: LD_ADDR_VAR 0 3
25743: PUSH
25744: EMPTY
25745: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
25746: LD_ADDR_VAR 0 5
25750: PUSH
25751: LD_INT 78
25753: PUSH
25754: LD_INT 47
25756: PUSH
25757: EMPTY
25758: LIST
25759: LIST
25760: PUSH
25761: LD_INT 106
25763: PUSH
25764: LD_INT 53
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
25775: LD_ADDR_VAR 0 1
25779: PUSH
25780: LD_INT 22
25782: PUSH
25783: LD_INT 8
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: PUSH
25790: LD_INT 21
25792: PUSH
25793: LD_INT 3
25795: PUSH
25796: EMPTY
25797: LIST
25798: LIST
25799: PUSH
25800: LD_INT 92
25802: PUSH
25803: LD_INT 90
25805: PUSH
25806: LD_INT 52
25808: PUSH
25809: LD_INT 12
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: LIST
25816: LIST
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: LIST
25822: PPUSH
25823: CALL_OW 69
25827: PUSH
25828: FOR_IN
25829: IFFALSE 25854
// tmp := tmp ^ UnitsInside ( i ) ;
25831: LD_ADDR_VAR 0 3
25835: PUSH
25836: LD_VAR 0 3
25840: PUSH
25841: LD_VAR 0 1
25845: PPUSH
25846: CALL_OW 313
25850: ADD
25851: ST_TO_ADDR
25852: GO 25828
25854: POP
25855: POP
// for i in tmp do
25856: LD_ADDR_VAR 0 1
25860: PUSH
25861: LD_VAR 0 3
25865: PUSH
25866: FOR_IN
25867: IFFALSE 26029
// begin dist := 9999 ;
25869: LD_ADDR_VAR 0 8
25873: PUSH
25874: LD_INT 9999
25876: ST_TO_ADDR
// _xy := [ ] ;
25877: LD_ADDR_VAR 0 7
25881: PUSH
25882: EMPTY
25883: ST_TO_ADDR
// SetTag ( i , 1 ) ;
25884: LD_VAR 0 1
25888: PPUSH
25889: LD_INT 1
25891: PPUSH
25892: CALL_OW 109
// ComExitBuilding ( i ) ;
25896: LD_VAR 0 1
25900: PPUSH
25901: CALL_OW 122
// for j in xy do
25905: LD_ADDR_VAR 0 2
25909: PUSH
25910: LD_VAR 0 5
25914: PUSH
25915: FOR_IN
25916: IFFALSE 25998
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
25918: LD_VAR 0 1
25922: PPUSH
25923: LD_VAR 0 2
25927: PUSH
25928: LD_INT 1
25930: ARRAY
25931: PPUSH
25932: LD_VAR 0 2
25936: PUSH
25937: LD_INT 2
25939: ARRAY
25940: PPUSH
25941: CALL_OW 297
25945: PUSH
25946: LD_VAR 0 8
25950: LESS
25951: IFFALSE 25996
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
25953: LD_ADDR_VAR 0 8
25957: PUSH
25958: LD_VAR 0 1
25962: PPUSH
25963: LD_VAR 0 2
25967: PUSH
25968: LD_INT 1
25970: ARRAY
25971: PPUSH
25972: LD_VAR 0 2
25976: PUSH
25977: LD_INT 2
25979: ARRAY
25980: PPUSH
25981: CALL_OW 297
25985: ST_TO_ADDR
// _xy := j ;
25986: LD_ADDR_VAR 0 7
25990: PUSH
25991: LD_VAR 0 2
25995: ST_TO_ADDR
// end ;
25996: GO 25915
25998: POP
25999: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26000: LD_VAR 0 1
26004: PPUSH
26005: LD_VAR 0 7
26009: PUSH
26010: LD_INT 1
26012: ARRAY
26013: PPUSH
26014: LD_VAR 0 7
26018: PUSH
26019: LD_INT 2
26021: ARRAY
26022: PPUSH
26023: CALL_OW 171
// end ;
26027: GO 25866
26029: POP
26030: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26031: LD_ADDR_VAR 0 4
26035: PUSH
26036: LD_VAR 0 3
26040: PPUSH
26041: LD_INT 26
26043: PUSH
26044: LD_INT 1
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: PUSH
26051: LD_INT 25
26053: PUSH
26054: LD_INT 1
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PPUSH
26065: CALL_OW 72
26069: ST_TO_ADDR
// if tmp2 < 2 then
26070: LD_VAR 0 4
26074: PUSH
26075: LD_INT 2
26077: LESS
26078: IFFALSE 26147
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26080: LD_ADDR_VAR 0 4
26084: PUSH
26085: LD_INT 22
26087: PUSH
26088: LD_INT 8
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 26
26097: PUSH
26098: LD_INT 1
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: LD_INT 3
26107: PUSH
26108: LD_INT 25
26110: PUSH
26111: LD_INT 15
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: LIST
26126: PPUSH
26127: CALL_OW 69
26131: PUSH
26132: LD_EXP 62
26136: PUSH
26137: LD_EXP 63
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: DIFF
26146: ST_TO_ADDR
// if tmp2 then
26147: LD_VAR 0 4
26151: IFFALSE 26169
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26153: LD_VAR 0 4
26157: PUSH
26158: LD_INT 1
26160: ARRAY
26161: PPUSH
26162: LD_STRING D6b-ArSol1-1
26164: PPUSH
26165: CALL_OW 88
// async ;
26169: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26170: LD_EXP 60
26174: PPUSH
26175: LD_STRING D6b-Pow-2
26177: PPUSH
26178: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26182: LD_INT 18
26184: PPUSH
26185: CALL_OW 67
// if tmp2 > 1 then
26189: LD_VAR 0 4
26193: PUSH
26194: LD_INT 1
26196: GREATER
26197: IFFALSE 26215
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26199: LD_VAR 0 4
26203: PUSH
26204: LD_INT 2
26206: ARRAY
26207: PPUSH
26208: LD_STRING D6b-ArSol2-1
26210: PPUSH
26211: CALL_OW 88
// sync ;
26215: SYNC
// repeat wait ( 5 ) ;
26216: LD_INT 5
26218: PPUSH
26219: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26223: LD_INT 93
26225: PPUSH
26226: LD_INT 36
26228: PPUSH
26229: CALL_OW 428
26233: PPUSH
26234: CALL_OW 255
26238: PUSH
26239: LD_INT 4
26241: EQUAL
26242: IFFALSE 26216
// DialogueOn ;
26244: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26248: LD_INT 10
26250: PPUSH
26251: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26255: LD_EXP 60
26259: PPUSH
26260: LD_STRING D6b-Pow-2a
26262: PPUSH
26263: CALL_OW 88
// DialogueOff ;
26267: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26271: LD_EXP 60
26275: PPUSH
26276: CALL_OW 310
26280: PPUSH
26281: LD_INT 332
26283: PPUSH
26284: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26288: LD_INT 93
26290: PPUSH
26291: LD_INT 35
26293: PPUSH
26294: LD_INT 1
26296: PPUSH
26297: LD_INT 6
26299: NEG
26300: PPUSH
26301: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26305: LD_INT 35
26307: PPUSH
26308: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26312: LD_INT 332
26314: PPUSH
26315: CALL_OW 256
26319: PUSH
26320: LD_INT 1000
26322: LESS
26323: PUSH
26324: LD_INT 332
26326: PPUSH
26327: CALL_OW 300
26331: AND
26332: IFFALSE 26344
// SetLives ( kozlov_fac , 0 ) ;
26334: LD_INT 332
26336: PPUSH
26337: LD_INT 0
26339: PPUSH
26340: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26344: LD_INT 332
26346: PPUSH
26347: CALL_OW 301
26351: PUSH
26352: LD_EXP 60
26356: PPUSH
26357: CALL_OW 301
26361: OR
26362: IFFALSE 26305
// game_speed := 4 ;
26364: LD_ADDR_OWVAR 65
26368: PUSH
26369: LD_INT 4
26371: ST_TO_ADDR
// powellCenterCameraMode := false ;
26372: LD_ADDR_EXP 20
26376: PUSH
26377: LD_INT 0
26379: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26380: LD_ADDR_VAR 0 1
26384: PUSH
26385: LD_VAR 0 3
26389: PUSH
26390: LD_INT 22
26392: PUSH
26393: LD_INT 8
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: LD_INT 25
26402: PUSH
26403: LD_INT 2
26405: PUSH
26406: EMPTY
26407: LIST
26408: LIST
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PPUSH
26414: CALL_OW 69
26418: UNION
26419: PUSH
26420: FOR_IN
26421: IFFALSE 26437
// SetTag ( i , 0 ) ;
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_INT 0
26430: PPUSH
26431: CALL_OW 109
26435: GO 26420
26437: POP
26438: POP
// wait ( 0 0$3 ) ;
26439: LD_INT 105
26441: PPUSH
26442: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
26446: LD_INT 93
26448: PPUSH
26449: LD_INT 35
26451: PPUSH
26452: LD_INT 1
26454: PPUSH
26455: CALL_OW 331
// DialogueOn ;
26459: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
26463: LD_VAR 0 11
26467: PPUSH
26468: LD_STRING D6c-Sol3-1
26470: PPUSH
26471: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
26475: LD_INT 10
26477: PPUSH
26478: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
26482: LD_EXP 40
26486: PPUSH
26487: LD_STRING D6c-JMM-1
26489: PPUSH
26490: CALL_OW 88
// if Cyrus then
26494: LD_EXP 46
26498: IFFALSE 26512
// Say ( Cyrus , D6c-Cyrus-1 ) ;
26500: LD_EXP 46
26504: PPUSH
26505: LD_STRING D6c-Cyrus-1
26507: PPUSH
26508: CALL_OW 88
// if Bobby then
26512: LD_EXP 45
26516: IFFALSE 26530
// Say ( Bobby , D6c-Bobby-1 ) ;
26518: LD_EXP 45
26522: PPUSH
26523: LD_STRING D6c-Bobby-1
26525: PPUSH
26526: CALL_OW 88
// if Cornel then
26530: LD_EXP 51
26534: IFFALSE 26548
// Say ( Cornel , D6c-Corn-1 ) ;
26536: LD_EXP 51
26540: PPUSH
26541: LD_STRING D6c-Corn-1
26543: PPUSH
26544: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
26548: LD_ADDR_VAR 0 4
26552: PUSH
26553: LD_INT 2
26555: PUSH
26556: LD_INT 22
26558: PUSH
26559: LD_INT 1
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 22
26568: PUSH
26569: LD_INT 4
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 26
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 23
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: LIST
26605: PPUSH
26606: CALL_OW 69
26610: PUSH
26611: LD_VAR 0 11
26615: PUSH
26616: LD_EXP 40
26620: UNION
26621: PUSH
26622: LD_EXP 61
26626: UNION
26627: DIFF
26628: ST_TO_ADDR
// if tmp2 then
26629: LD_VAR 0 4
26633: IFFALSE 26651
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
26635: LD_VAR 0 4
26639: PUSH
26640: LD_INT 1
26642: ARRAY
26643: PPUSH
26644: LD_STRING D6c-Sol1-1
26646: PPUSH
26647: CALL_OW 88
// if Lisa then
26651: LD_EXP 43
26655: IFFALSE 26669
// Say ( Lisa , D6c-Lisa-1 ) ;
26657: LD_EXP 43
26661: PPUSH
26662: LD_STRING D6c-Lisa-1
26664: PPUSH
26665: CALL_OW 88
// if Gary then
26669: LD_EXP 52
26673: IFFALSE 26687
// Say ( Gary , D6c-Gary-1 ) ;
26675: LD_EXP 52
26679: PPUSH
26680: LD_STRING D6c-Gary-1
26682: PPUSH
26683: CALL_OW 88
// if Donaldson then
26687: LD_EXP 44
26691: IFFALSE 26705
// Say ( Donaldson , D6c-Don-1 ) ;
26693: LD_EXP 44
26697: PPUSH
26698: LD_STRING D6c-Don-1
26700: PPUSH
26701: CALL_OW 88
// if tmp2 > 1 then
26705: LD_VAR 0 4
26709: PUSH
26710: LD_INT 1
26712: GREATER
26713: IFFALSE 26731
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
26715: LD_VAR 0 4
26719: PUSH
26720: LD_INT 2
26722: ARRAY
26723: PPUSH
26724: LD_STRING D6c-Sol2-1
26726: PPUSH
26727: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
26731: LD_VAR 0 11
26735: PPUSH
26736: LD_STRING D6c-Sol3-2
26738: PPUSH
26739: CALL_OW 88
// if IsInUnit ( JMM ) then
26743: LD_EXP 40
26747: PPUSH
26748: CALL_OW 310
26752: IFFALSE 26770
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
26754: LD_EXP 40
26758: PPUSH
26759: CALL_OW 310
26763: PPUSH
26764: CALL_OW 87
26768: GO 26779
// CenterNowOnUnits ( JMM ) ;
26770: LD_EXP 40
26774: PPUSH
26775: CALL_OW 87
// dwait ( 0 0$2 ) ;
26779: LD_INT 70
26781: PPUSH
26782: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
26786: LD_EXP 40
26790: PPUSH
26791: LD_STRING D6c-JMM-2
26793: PPUSH
26794: CALL_OW 88
// DialogueOff ;
26798: CALL_OW 7
// Video ( false ) ;
26802: LD_INT 0
26804: PPUSH
26805: CALL 106059 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
26809: LD_INT 22
26811: PUSH
26812: LD_INT 4
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PPUSH
26819: CALL_OW 69
26823: PPUSH
26824: LD_INT 1
26826: PPUSH
26827: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
26831: LD_INT 4
26833: PPUSH
26834: LD_INT 4
26836: PPUSH
26837: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
26841: LD_ADDR_VAR 0 1
26845: PUSH
26846: LD_INT 4
26848: PPUSH
26849: LD_INT 1
26851: PPUSH
26852: LD_INT 2
26854: PPUSH
26855: CALL 68858 0 3
26859: PUSH
26860: FOR_IN
26861: IFFALSE 26898
// if GetTech ( i , 1 ) <> state_researched then
26863: LD_VAR 0 1
26867: PPUSH
26868: LD_INT 1
26870: PPUSH
26871: CALL_OW 321
26875: PUSH
26876: LD_INT 2
26878: NONEQUAL
26879: IFFALSE 26896
// SetTech ( i , 1 , state_researched ) ;
26881: LD_VAR 0 1
26885: PPUSH
26886: LD_INT 1
26888: PPUSH
26889: LD_INT 2
26891: PPUSH
26892: CALL_OW 322
26896: GO 26860
26898: POP
26899: POP
// missionStage := 6 ;
26900: LD_ADDR_EXP 15
26904: PUSH
26905: LD_INT 6
26907: ST_TO_ADDR
// activeAttacks := true ;
26908: LD_ADDR_EXP 16
26912: PUSH
26913: LD_INT 1
26915: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
26916: LD_STRING M2
26918: PPUSH
26919: CALL_OW 337
// SaveForQuickRestart ;
26923: CALL_OW 22
// wait ( 0 0$40 ) ;
26927: LD_INT 1400
26929: PPUSH
26930: CALL_OW 67
// DialogueOn ;
26934: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
26938: LD_EXP 64
26942: PPUSH
26943: LD_STRING D7-Friend-1
26945: PPUSH
26946: CALL 110006 0 2
// Say ( JMM , D7-JMM-1 ) ;
26950: LD_EXP 40
26954: PPUSH
26955: LD_STRING D7-JMM-1
26957: PPUSH
26958: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
26962: LD_EXP 64
26966: PPUSH
26967: LD_STRING D7-Friend-2
26969: PPUSH
26970: CALL 110006 0 2
// Say ( JMM , D7-JMM-2 ) ;
26974: LD_EXP 40
26978: PPUSH
26979: LD_STRING D7-JMM-2
26981: PPUSH
26982: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
26986: LD_EXP 64
26990: PPUSH
26991: LD_STRING D7-Friend-3
26993: PPUSH
26994: CALL 110006 0 2
// Say ( JMM , D7-JMM-3 ) ;
26998: LD_EXP 40
27002: PPUSH
27003: LD_STRING D7-JMM-3
27005: PPUSH
27006: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27010: LD_EXP 64
27014: PPUSH
27015: LD_STRING D7-Friend-4
27017: PPUSH
27018: CALL 110006 0 2
// Say ( JMM , D7-JMM-4 ) ;
27022: LD_EXP 40
27026: PPUSH
27027: LD_STRING D7-JMM-4
27029: PPUSH
27030: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27034: LD_EXP 64
27038: PPUSH
27039: LD_STRING D7-Friend-5
27041: PPUSH
27042: CALL 110006 0 2
// Say ( JMM , D7-JMM-5 ) ;
27046: LD_EXP 40
27050: PPUSH
27051: LD_STRING D7-JMM-5
27053: PPUSH
27054: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27058: LD_EXP 64
27062: PPUSH
27063: LD_STRING D7-Friend-6
27065: PPUSH
27066: CALL 110006 0 2
// Say ( JMM , D7-JMM-6 ) ;
27070: LD_EXP 40
27074: PPUSH
27075: LD_STRING D7-JMM-6
27077: PPUSH
27078: CALL_OW 88
// DialogueOff ;
27082: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27086: LD_STRING Mlegion
27088: PPUSH
27089: CALL_OW 337
// skirmish := true ;
27093: LD_ADDR_EXP 98
27097: PUSH
27098: LD_INT 1
27100: ST_TO_ADDR
// RebuildKozlovFactory ;
27101: CALL 5046 0 0
// end ;
27105: PPOPN 13
27107: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27108: LD_EXP 20
27112: PUSH
27113: LD_EXP 60
27117: PPUSH
27118: CALL_OW 300
27122: AND
27123: IFFALSE 27165
27125: GO 27127
27127: DISABLE
// begin enable ;
27128: ENABLE
// if IsInUnit ( Powell ) then
27129: LD_EXP 60
27133: PPUSH
27134: CALL_OW 310
27138: IFFALSE 27156
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27140: LD_EXP 60
27144: PPUSH
27145: CALL_OW 310
27149: PPUSH
27150: CALL_OW 85
27154: GO 27165
// CenterOnUnits ( Powell ) ;
27156: LD_EXP 60
27160: PPUSH
27161: CALL_OW 85
// end ;
27165: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27166: LD_INT 22
27168: PUSH
27169: LD_INT 8
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 34
27178: PUSH
27179: LD_INT 48
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PPUSH
27190: CALL_OW 69
27194: IFFALSE 27468
27196: GO 27198
27198: DISABLE
27199: LD_INT 0
27201: PPUSH
27202: PPUSH
// begin if missionStage < 9 then
27203: LD_EXP 15
27207: PUSH
27208: LD_INT 9
27210: LESS
27211: IFFALSE 27221
// missionStage := 9 ;
27213: LD_ADDR_EXP 15
27217: PUSH
27218: LD_INT 9
27220: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27221: LD_ADDR_VAR 0 1
27225: PUSH
27226: LD_INT 22
27228: PUSH
27229: LD_INT 8
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 34
27238: PUSH
27239: LD_INT 48
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: PPUSH
27250: CALL_OW 69
27254: PUSH
27255: LD_INT 1
27257: ARRAY
27258: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27259: LD_INT 175
27261: PPUSH
27262: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27266: LD_EXP 12
27270: PUSH
27271: LD_EXP 3
27275: PUSH
27276: LD_INT 0
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: IN
27286: OR
27287: IFFALSE 27310
// target := [ 68 , 108 , 1 ] else
27289: LD_ADDR_VAR 0 2
27293: PUSH
27294: LD_INT 68
27296: PUSH
27297: LD_INT 108
27299: PUSH
27300: LD_INT 1
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: LIST
27307: ST_TO_ADDR
27308: GO 27329
// target := [ 181 , 88 , 2 ] ;
27310: LD_ADDR_VAR 0 2
27314: PUSH
27315: LD_INT 181
27317: PUSH
27318: LD_INT 88
27320: PUSH
27321: LD_INT 2
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: LIST
27328: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27329: LD_VAR 0 1
27333: PPUSH
27334: LD_VAR 0 2
27338: PUSH
27339: LD_INT 1
27341: ARRAY
27342: PPUSH
27343: LD_VAR 0 2
27347: PUSH
27348: LD_INT 2
27350: ARRAY
27351: PPUSH
27352: CALL_OW 176
// if target [ 3 ] = 1 then
27356: LD_VAR 0 2
27360: PUSH
27361: LD_INT 3
27363: ARRAY
27364: PUSH
27365: LD_INT 1
27367: EQUAL
27368: IFFALSE 27384
// SayRadio ( Kurt , D12-Kurt-1 ) else
27370: LD_EXP 62
27374: PPUSH
27375: LD_STRING D12-Kurt-1
27377: PPUSH
27378: CALL_OW 94
27382: GO 27408
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
27384: LD_EXP 62
27388: PPUSH
27389: LD_STRING D12a-Kurt-1
27391: PPUSH
27392: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
27396: LD_EXP 77
27400: PPUSH
27401: LD_STRING D12a-Roth-1
27403: PPUSH
27404: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
27408: LD_INT 350
27410: PPUSH
27411: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
27415: LD_VAR 0 1
27419: PPUSH
27420: LD_INT 22
27422: PUSH
27423: LD_INT 8
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 23
27432: PUSH
27433: LD_INT 2
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 30
27442: PUSH
27443: LD_INT 3
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: EMPTY
27451: LIST
27452: LIST
27453: LIST
27454: PPUSH
27455: CALL_OW 69
27459: PUSH
27460: LD_INT 1
27462: ARRAY
27463: PPUSH
27464: CALL_OW 228
// end ;
27468: PPOPN 2
27470: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
27471: LD_EXP 62
27475: PPUSH
27476: CALL_OW 256
27480: PUSH
27481: LD_INT 999
27483: LESS
27484: PUSH
27485: LD_INT 22
27487: PUSH
27488: LD_INT 8
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: PUSH
27495: LD_INT 21
27497: PUSH
27498: LD_INT 1
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 23
27507: PUSH
27508: LD_INT 2
27510: PUSH
27511: EMPTY
27512: LIST
27513: LIST
27514: PUSH
27515: EMPTY
27516: LIST
27517: LIST
27518: LIST
27519: PPUSH
27520: CALL_OW 69
27524: PUSH
27525: LD_INT 9
27527: PUSH
27528: LD_INT 8
27530: PUSH
27531: LD_INT 7
27533: PUSH
27534: LD_INT 6
27536: PUSH
27537: EMPTY
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: PUSH
27543: LD_OWVAR 67
27547: ARRAY
27548: LESSEQUAL
27549: OR
27550: PUSH
27551: LD_INT 22
27553: PUSH
27554: LD_INT 8
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PUSH
27561: LD_INT 34
27563: PUSH
27564: LD_INT 48
27566: PUSH
27567: EMPTY
27568: LIST
27569: LIST
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PPUSH
27575: CALL_OW 69
27579: NOT
27580: AND
27581: PUSH
27582: LD_EXP 62
27586: PPUSH
27587: CALL_OW 302
27591: AND
27592: PUSH
27593: LD_INT 5
27595: PPUSH
27596: LD_INT 22
27598: PUSH
27599: LD_INT 1
27601: PUSH
27602: EMPTY
27603: LIST
27604: LIST
27605: PPUSH
27606: CALL_OW 70
27610: AND
27611: IFFALSE 28373
27613: GO 27615
27615: DISABLE
27616: LD_INT 0
27618: PPUSH
27619: PPUSH
27620: PPUSH
// begin legionDestroyed := true ;
27621: LD_ADDR_EXP 22
27625: PUSH
27626: LD_INT 1
27628: ST_TO_ADDR
// DialogueOn ;
27629: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
27633: LD_EXP 40
27637: PPUSH
27638: LD_STRING D13-JMM-1
27640: PPUSH
27641: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
27645: LD_EXP 62
27649: PPUSH
27650: LD_STRING D13-Kurt-1
27652: PPUSH
27653: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
27657: LD_EXP 40
27661: PPUSH
27662: LD_STRING D13-JMM-2
27664: PPUSH
27665: CALL_OW 88
// if FakeInfo then
27669: LD_EXP 12
27673: IFFALSE 27693
// begin Say ( Kurt , D13-Kurt-2 ) ;
27675: LD_EXP 62
27679: PPUSH
27680: LD_STRING D13-Kurt-2
27682: PPUSH
27683: CALL_OW 88
// DialogueOff ;
27687: CALL_OW 7
// exit ;
27691: GO 28373
// end ; if not KurtStatus then
27693: LD_EXP 3
27697: NOT
27698: IFFALSE 27714
// Say ( Kurt , D13-Kurt-2b ) else
27700: LD_EXP 62
27704: PPUSH
27705: LD_STRING D13-Kurt-2b
27707: PPUSH
27708: CALL_OW 88
27712: GO 27726
// Say ( Kurt , D13-Kurt-2a ) ;
27714: LD_EXP 62
27718: PPUSH
27719: LD_STRING D13-Kurt-2a
27721: PPUSH
27722: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
27726: LD_EXP 40
27730: PPUSH
27731: LD_STRING D13-JMM-3
27733: PPUSH
27734: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
27738: LD_EXP 62
27742: PPUSH
27743: LD_STRING D13-Kurt-3
27745: PPUSH
27746: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
27750: LD_EXP 40
27754: PPUSH
27755: LD_STRING D13-JMM-4
27757: PPUSH
27758: CALL_OW 88
// DialogueOff ;
27762: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
27766: LD_STRING MlegionOut
27768: PPUSH
27769: CALL_OW 337
// MC_Kill ( 3 ) ;
27773: LD_INT 3
27775: PPUSH
27776: CALL 38358 0 1
// KillUnit ( Kozlov ) ;
27780: LD_EXP 63
27784: PPUSH
27785: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
27789: LD_ADDR_VAR 0 1
27793: PUSH
27794: LD_INT 22
27796: PUSH
27797: LD_INT 8
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 23
27806: PUSH
27807: LD_INT 3
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: LD_INT 21
27819: PUSH
27820: LD_INT 33
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: LIST
27835: PPUSH
27836: CALL_OW 69
27840: PUSH
27841: FOR_IN
27842: IFFALSE 27855
// KillUnit ( i ) ;
27844: LD_VAR 0 1
27848: PPUSH
27849: CALL_OW 66
27853: GO 27841
27855: POP
27856: POP
// ChangeSideFog ( 8 , 1 ) ;
27857: LD_INT 8
27859: PPUSH
27860: LD_INT 1
27862: PPUSH
27863: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
27867: LD_ADDR_VAR 0 2
27871: PUSH
27872: LD_INT 22
27874: PUSH
27875: LD_INT 8
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 21
27884: PUSH
27885: LD_INT 1
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PPUSH
27896: CALL_OW 69
27900: PUSH
27901: LD_EXP 63
27905: PUSH
27906: LD_EXP 62
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: DIFF
27915: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
27916: LD_VAR 0 2
27920: PUSH
27921: LD_INT 6
27923: PUSH
27924: LD_INT 5
27926: PUSH
27927: LD_INT 4
27929: PUSH
27930: LD_INT 3
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: PUSH
27939: LD_OWVAR 67
27943: ARRAY
27944: GREATEREQUAL
27945: IFFALSE 28097
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
27947: LD_ADDR_VAR 0 3
27951: PUSH
27952: LD_INT 6
27954: PUSH
27955: LD_INT 5
27957: PUSH
27958: LD_INT 4
27960: PUSH
27961: LD_INT 3
27963: PUSH
27964: EMPTY
27965: LIST
27966: LIST
27967: LIST
27968: LIST
27969: PUSH
27970: LD_OWVAR 67
27974: ARRAY
27975: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
27976: LD_ADDR_VAR 0 1
27980: PUSH
27981: DOUBLE
27982: LD_VAR 0 2
27986: PUSH
27987: LD_VAR 0 3
27991: PUSH
27992: LD_INT 1
27994: PLUS
27995: MINUS
27996: INC
27997: ST_TO_ADDR
27998: LD_INT 1
28000: PUSH
28001: FOR_DOWNTO
28002: IFFALSE 28093
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28004: LD_ADDR_EXP 38
28008: PUSH
28009: LD_EXP 38
28013: PUSH
28014: LD_VAR 0 2
28018: PUSH
28019: LD_VAR 0 1
28023: ARRAY
28024: ADD
28025: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28026: LD_VAR 0 2
28030: PUSH
28031: LD_VAR 0 1
28035: ARRAY
28036: PPUSH
28037: CALL_OW 310
28041: IFFALSE 28058
// ComExit ( tmp [ i ] ) ;
28043: LD_VAR 0 2
28047: PUSH
28048: LD_VAR 0 1
28052: ARRAY
28053: PPUSH
28054: CALL 106485 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28058: LD_VAR 0 2
28062: PUSH
28063: LD_VAR 0 1
28067: ARRAY
28068: PPUSH
28069: LD_INT 34
28071: PUSH
28072: LD_INT 0
28074: PPUSH
28075: LD_INT 6
28077: PPUSH
28078: CALL_OW 12
28082: PLUS
28083: PPUSH
28084: LD_INT 1
28086: PPUSH
28087: CALL_OW 171
// end ;
28091: GO 28001
28093: POP
28094: POP
// end else
28095: GO 28107
// x := tmp ;
28097: LD_ADDR_VAR 0 3
28101: PUSH
28102: LD_VAR 0 2
28106: ST_TO_ADDR
// for i := tmp downto tmp - x do
28107: LD_ADDR_VAR 0 1
28111: PUSH
28112: DOUBLE
28113: LD_VAR 0 2
28117: INC
28118: ST_TO_ADDR
28119: LD_VAR 0 2
28123: PUSH
28124: LD_VAR 0 3
28128: MINUS
28129: PUSH
28130: FOR_DOWNTO
28131: IFFALSE 28203
// begin if IsInUnit ( tmp [ i ] ) then
28133: LD_VAR 0 2
28137: PUSH
28138: LD_VAR 0 1
28142: ARRAY
28143: PPUSH
28144: CALL_OW 310
28148: IFFALSE 28165
// ComExit ( tmp [ i ] ) ;
28150: LD_VAR 0 2
28154: PUSH
28155: LD_VAR 0 1
28159: ARRAY
28160: PPUSH
28161: CALL 106485 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28165: LD_VAR 0 2
28169: PUSH
28170: LD_VAR 0 1
28174: ARRAY
28175: PPUSH
28176: LD_INT 1
28178: PPUSH
28179: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28183: LD_VAR 0 2
28187: PUSH
28188: LD_VAR 0 1
28192: ARRAY
28193: PPUSH
28194: LD_INT 1000
28196: PPUSH
28197: CALL_OW 234
// end ;
28201: GO 28130
28203: POP
28204: POP
// wait ( 0 0$0.3 ) ;
28205: LD_INT 10
28207: PPUSH
28208: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28212: LD_ADDR_VAR 0 1
28216: PUSH
28217: LD_INT 22
28219: PUSH
28220: LD_INT 8
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 21
28229: PUSH
28230: LD_INT 2
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PPUSH
28241: CALL_OW 69
28245: PUSH
28246: FOR_IN
28247: IFFALSE 28260
// KillUnit ( i ) ;
28249: LD_VAR 0 1
28253: PPUSH
28254: CALL_OW 66
28258: GO 28246
28260: POP
28261: POP
// SetSide ( Kurt , 1 ) ;
28262: LD_EXP 62
28266: PPUSH
28267: LD_INT 1
28269: PPUSH
28270: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28274: LD_INT 22
28276: PUSH
28277: LD_INT 8
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: LD_INT 21
28286: PUSH
28287: LD_INT 3
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PPUSH
28298: CALL_OW 69
28302: PPUSH
28303: LD_INT 1
28305: PPUSH
28306: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28310: LD_INT 8
28312: PPUSH
28313: LD_INT 1
28315: PPUSH
28316: LD_INT 1
28318: PPUSH
28319: LD_INT 1
28321: PPUSH
28322: CALL_OW 80
// wait ( 1 1$20 ) ;
28326: LD_INT 2800
28328: PPUSH
28329: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28333: LD_EXP 64
28337: PPUSH
28338: LD_INT 37
28340: PPUSH
28341: LD_INT 1
28343: PPUSH
28344: LD_INT 0
28346: PPUSH
28347: CALL_OW 48
// wait ( 0 0$1 ) ;
28351: LD_INT 35
28353: PPUSH
28354: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28358: LD_EXP 64
28362: PPUSH
28363: LD_INT 60
28365: PPUSH
28366: LD_INT 95
28368: PPUSH
28369: CALL_OW 111
// end ;
28373: PPOPN 3
28375: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
28376: LD_EXP 22
28380: NOT
28381: PUSH
28382: LD_INT 22
28384: PUSH
28385: LD_INT 8
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: LD_INT 21
28394: PUSH
28395: LD_INT 1
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PPUSH
28406: CALL_OW 69
28410: PUSH
28411: LD_INT 0
28413: EQUAL
28414: AND
28415: IFFALSE 28435
28417: GO 28419
28419: DISABLE
// begin legionDestroyed := true ;
28420: LD_ADDR_EXP 22
28424: PUSH
28425: LD_INT 1
28427: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
28428: LD_STRING MlegionOut
28430: PPUSH
28431: CALL_OW 337
// end ;
28435: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
28436: LD_EXP 38
28440: IFFALSE 28515
28442: GO 28444
28444: DISABLE
28445: LD_INT 0
28447: PPUSH
// begin enable ;
28448: ENABLE
// for i in legionEscapeUnits do
28449: LD_ADDR_VAR 0 1
28453: PUSH
28454: LD_EXP 38
28458: PUSH
28459: FOR_IN
28460: IFFALSE 28513
// begin if IsInArea ( i , legionEscapeArea ) then
28462: LD_VAR 0 1
28466: PPUSH
28467: LD_INT 31
28469: PPUSH
28470: CALL_OW 308
28474: IFFALSE 28487
// RemoveUnit ( i ) else
28476: LD_VAR 0 1
28480: PPUSH
28481: CALL_OW 64
28485: GO 28511
// if not HasTask ( i ) then
28487: LD_VAR 0 1
28491: PPUSH
28492: CALL_OW 314
28496: NOT
28497: IFFALSE 28511
// ComMoveToArea ( i , legionEscapeArea ) ;
28499: LD_VAR 0 1
28503: PPUSH
28504: LD_INT 31
28506: PPUSH
28507: CALL_OW 113
// end ;
28511: GO 28459
28513: POP
28514: POP
// end ;
28515: PPOPN 1
28517: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
28518: LD_INT 1
28520: PPUSH
28521: LD_EXP 64
28525: PPUSH
28526: CALL_OW 292
28530: IFFALSE 28828
28532: GO 28534
28534: DISABLE
28535: LD_INT 0
28537: PPUSH
// begin wait ( 0 0$2 ) ;
28538: LD_INT 70
28540: PPUSH
28541: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28545: LD_EXP 64
28549: PPUSH
28550: CALL_OW 87
// DialogueOn ;
28554: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
28558: LD_EXP 40
28562: PPUSH
28563: LD_STRING D14-JMM-1
28565: PPUSH
28566: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
28570: LD_EXP 64
28574: PPUSH
28575: LD_STRING D14-Friend-1
28577: PPUSH
28578: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
28582: LD_EXP 40
28586: PPUSH
28587: LD_STRING D14-JMM-2
28589: PPUSH
28590: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
28594: LD_EXP 64
28598: PPUSH
28599: LD_STRING D14-Friend-2
28601: PPUSH
28602: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
28606: LD_EXP 40
28610: PPUSH
28611: LD_STRING D14-JMM-3
28613: PPUSH
28614: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
28618: LD_EXP 64
28622: PPUSH
28623: LD_STRING D14-Friend-3
28625: PPUSH
28626: CALL_OW 88
// DialogueOff ;
28630: CALL_OW 7
// dec := Query ( Q14 ) ;
28634: LD_ADDR_VAR 0 1
28638: PUSH
28639: LD_STRING Q14
28641: PPUSH
28642: CALL_OW 97
28646: ST_TO_ADDR
// if dec = 1 then
28647: LD_VAR 0 1
28651: PUSH
28652: LD_INT 1
28654: EQUAL
28655: IFFALSE 28689
// begin DialogueOn ;
28657: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
28661: LD_EXP 40
28665: PPUSH
28666: LD_STRING D14a-JMM-1
28668: PPUSH
28669: CALL_OW 88
// DialogueOff ;
28673: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28677: LD_EXP 64
28681: PPUSH
28682: LD_INT 1
28684: PPUSH
28685: CALL_OW 235
// end ; if dec = 2 then
28689: LD_VAR 0 1
28693: PUSH
28694: LD_INT 2
28696: EQUAL
28697: IFFALSE 28750
// begin DialogueOn ;
28699: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
28703: LD_EXP 40
28707: PPUSH
28708: LD_STRING D14b-JMM-1
28710: PPUSH
28711: CALL_OW 88
// DialogueOff ;
28715: CALL_OW 7
// wait ( 0 0$1 ) ;
28719: LD_INT 35
28721: PPUSH
28722: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
28726: LD_EXP 64
28730: PPUSH
28731: LD_INT 9
28733: PPUSH
28734: LD_INT 2
28736: PPUSH
28737: CALL_OW 111
// AddComHold ( Friend ) ;
28741: LD_EXP 64
28745: PPUSH
28746: CALL_OW 200
// end ; if dec = 3 then
28750: LD_VAR 0 1
28754: PUSH
28755: LD_INT 3
28757: EQUAL
28758: IFFALSE 28828
// begin DialogueOn ;
28760: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
28764: LD_EXP 40
28768: PPUSH
28769: LD_STRING D14c-JMM-1
28771: PPUSH
28772: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
28776: LD_EXP 64
28780: PPUSH
28781: LD_STRING D14c-Friend-1
28783: PPUSH
28784: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
28788: LD_EXP 40
28792: PPUSH
28793: LD_STRING D14c-JMM-2
28795: PPUSH
28796: CALL_OW 88
// DialogueOff ;
28800: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
28804: LD_EXP 64
28808: PPUSH
28809: LD_INT 9
28811: PPUSH
28812: LD_INT 2
28814: PPUSH
28815: CALL_OW 111
// AddComHold ( Friend ) ;
28819: LD_EXP 64
28823: PPUSH
28824: CALL_OW 200
// end ; end ;
28828: PPOPN 1
28830: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
28831: LD_INT 9
28833: PPUSH
28834: LD_INT 2
28836: PPUSH
28837: CALL_OW 428
28841: PUSH
28842: LD_EXP 64
28846: EQUAL
28847: PUSH
28848: LD_EXP 64
28852: PPUSH
28853: CALL_OW 255
28857: PUSH
28858: LD_INT 8
28860: EQUAL
28861: AND
28862: IFFALSE 28876
28864: GO 28866
28866: DISABLE
// RemoveUnit ( Friend ) ;
28867: LD_EXP 64
28871: PPUSH
28872: CALL_OW 64
28876: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
28877: LD_EXP 14
28881: PUSH
28882: LD_INT 31500
28884: GREATEREQUAL
28885: PUSH
28886: LD_EXP 7
28890: AND
28891: PUSH
28892: LD_EXP 2
28896: AND
28897: IFFALSE 29327
28899: GO 28901
28901: DISABLE
28902: LD_INT 0
28904: PPUSH
28905: PPUSH
28906: PPUSH
// begin missionStage := 7 ;
28907: LD_ADDR_EXP 15
28911: PUSH
28912: LD_INT 7
28914: ST_TO_ADDR
// uc_side = 1 ;
28915: LD_ADDR_OWVAR 20
28919: PUSH
28920: LD_INT 1
28922: ST_TO_ADDR
// uc_nation = 1 ;
28923: LD_ADDR_OWVAR 21
28927: PUSH
28928: LD_INT 1
28930: ST_TO_ADDR
// for i = 1 to 5 do
28931: LD_ADDR_VAR 0 1
28935: PUSH
28936: DOUBLE
28937: LD_INT 1
28939: DEC
28940: ST_TO_ADDR
28941: LD_INT 5
28943: PUSH
28944: FOR_TO
28945: IFFALSE 29041
// begin vc_engine = 3 ;
28947: LD_ADDR_OWVAR 39
28951: PUSH
28952: LD_INT 3
28954: ST_TO_ADDR
// vc_control = 3 ;
28955: LD_ADDR_OWVAR 38
28959: PUSH
28960: LD_INT 3
28962: ST_TO_ADDR
// vc_chassis = 3 ;
28963: LD_ADDR_OWVAR 37
28967: PUSH
28968: LD_INT 3
28970: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28971: LD_ADDR_OWVAR 40
28975: PUSH
28976: LD_INT 5
28978: PUSH
28979: LD_INT 9
28981: PUSH
28982: LD_INT 7
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 1
28992: PPUSH
28993: LD_INT 3
28995: PPUSH
28996: CALL_OW 12
29000: ARRAY
29001: ST_TO_ADDR
// veh = CreateVehicle ;
29002: LD_ADDR_VAR 0 2
29006: PUSH
29007: CALL_OW 45
29011: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29012: LD_VAR 0 2
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29024: LD_VAR 0 2
29028: PPUSH
29029: LD_INT 19
29031: PPUSH
29032: LD_INT 0
29034: PPUSH
29035: CALL_OW 49
// end ;
29039: GO 28944
29041: POP
29042: POP
// vc_engine = 3 ;
29043: LD_ADDR_OWVAR 39
29047: PUSH
29048: LD_INT 3
29050: ST_TO_ADDR
// vc_control = 1 ;
29051: LD_ADDR_OWVAR 38
29055: PUSH
29056: LD_INT 1
29058: ST_TO_ADDR
// vc_chassis = 3 ;
29059: LD_ADDR_OWVAR 37
29063: PUSH
29064: LD_INT 3
29066: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29067: LD_ADDR_OWVAR 40
29071: PUSH
29072: LD_INT 5
29074: PUSH
29075: LD_INT 9
29077: PUSH
29078: LD_INT 7
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: PPUSH
29089: LD_INT 3
29091: PPUSH
29092: CALL_OW 12
29096: ARRAY
29097: ST_TO_ADDR
// vehG = CreateVehicle ;
29098: LD_ADDR_VAR 0 3
29102: PUSH
29103: CALL_OW 45
29107: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29108: LD_VAR 0 3
29112: PPUSH
29113: LD_INT 1
29115: PPUSH
29116: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29120: LD_VAR 0 3
29124: PPUSH
29125: LD_INT 19
29127: PPUSH
29128: LD_INT 0
29130: PPUSH
29131: CALL_OW 49
// if JMMGirl = 1 then
29135: LD_EXP 7
29139: PUSH
29140: LD_INT 1
29142: EQUAL
29143: IFFALSE 29199
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29145: LD_ADDR_EXP 41
29149: PUSH
29150: LD_STRING Joan
29152: PPUSH
29153: LD_INT 1
29155: PPUSH
29156: LD_STRING 14_
29158: PPUSH
29159: CALL 68795 0 3
29163: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29164: LD_EXP 41
29168: PPUSH
29169: LD_VAR 0 3
29173: PPUSH
29174: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29178: LD_VAR 0 3
29182: PPUSH
29183: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29187: LD_EXP 41
29191: PPUSH
29192: LD_STRING D10BW-Joan-1
29194: PPUSH
29195: CALL_OW 94
// end ; if JMMGirl = 2 then
29199: LD_EXP 7
29203: PUSH
29204: LD_INT 2
29206: EQUAL
29207: IFFALSE 29263
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29209: LD_ADDR_EXP 43
29213: PUSH
29214: LD_STRING Lisa
29216: PPUSH
29217: LD_INT 1
29219: PPUSH
29220: LD_STRING 14_
29222: PPUSH
29223: CALL 68795 0 3
29227: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29228: LD_EXP 43
29232: PPUSH
29233: LD_VAR 0 3
29237: PPUSH
29238: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29242: LD_VAR 0 3
29246: PPUSH
29247: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29251: LD_EXP 43
29255: PPUSH
29256: LD_STRING D10BW-Lisa-1
29258: PPUSH
29259: CALL_OW 94
// end ; if JMMGirl = 3 then
29263: LD_EXP 7
29267: PUSH
29268: LD_INT 3
29270: EQUAL
29271: IFFALSE 29327
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29273: LD_ADDR_EXP 55
29277: PUSH
29278: LD_STRING Connie
29280: PPUSH
29281: LD_INT 1
29283: PPUSH
29284: LD_STRING 14_
29286: PPUSH
29287: CALL 68795 0 3
29291: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29292: LD_EXP 55
29296: PPUSH
29297: LD_VAR 0 3
29301: PPUSH
29302: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29306: LD_VAR 0 3
29310: PPUSH
29311: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29315: LD_EXP 55
29319: PPUSH
29320: LD_STRING D10BW-Con-1
29322: PPUSH
29323: CALL_OW 94
// end ; end ;
29327: PPOPN 3
29329: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29330: LD_EXP 14
29334: PUSH
29335: LD_INT 94500
29337: GREATEREQUAL
29338: IFFALSE 29750
29340: GO 29342
29342: DISABLE
29343: LD_INT 0
29345: PPUSH
29346: PPUSH
29347: PPUSH
// begin tmp := PrepareStevensSquad ;
29348: LD_ADDR_VAR 0 3
29352: PUSH
29353: CALL 2323 0 0
29357: ST_TO_ADDR
// if not tmp then
29358: LD_VAR 0 3
29362: NOT
29363: IFFALSE 29367
// exit ;
29365: GO 29750
// uc_side := 1 ;
29367: LD_ADDR_OWVAR 20
29371: PUSH
29372: LD_INT 1
29374: ST_TO_ADDR
// uc_nation := 1 ;
29375: LD_ADDR_OWVAR 21
29379: PUSH
29380: LD_INT 1
29382: ST_TO_ADDR
// for i in tmp do
29383: LD_ADDR_VAR 0 1
29387: PUSH
29388: LD_VAR 0 3
29392: PUSH
29393: FOR_IN
29394: IFFALSE 29491
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
29396: LD_INT 3
29398: PPUSH
29399: LD_INT 3
29401: PPUSH
29402: LD_INT 1
29404: PPUSH
29405: LD_INT 5
29407: PUSH
29408: LD_INT 9
29410: PUSH
29411: LD_INT 7
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 1
29421: PPUSH
29422: LD_INT 3
29424: PPUSH
29425: CALL_OW 12
29429: ARRAY
29430: PPUSH
29431: LD_INT 40
29433: PPUSH
29434: CALL 73635 0 5
// veh := CreateVehicle ;
29438: LD_ADDR_VAR 0 2
29442: PUSH
29443: CALL_OW 45
29447: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29448: LD_VAR 0 2
29452: PPUSH
29453: LD_INT 1
29455: PPUSH
29456: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29460: LD_VAR 0 2
29464: PPUSH
29465: LD_INT 19
29467: PPUSH
29468: LD_INT 0
29470: PPUSH
29471: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
29475: LD_VAR 0 1
29479: PPUSH
29480: LD_VAR 0 2
29484: PPUSH
29485: CALL_OW 52
// end ;
29489: GO 29393
29491: POP
29492: POP
// missionStage := 8 ;
29493: LD_ADDR_EXP 15
29497: PUSH
29498: LD_INT 8
29500: ST_TO_ADDR
// DialogueOn ;
29501: CALL_OW 6
// if Stevens then
29505: LD_EXP 42
29509: IFFALSE 29623
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
29511: LD_EXP 42
29515: PPUSH
29516: CALL_OW 310
29520: PPUSH
29521: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
29525: LD_EXP 42
29529: PPUSH
29530: LD_STRING D8-Huck-1
29532: PPUSH
29533: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
29537: LD_EXP 40
29541: PPUSH
29542: LD_STRING D8-JMM-1
29544: PPUSH
29545: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
29549: LD_EXP 42
29553: PPUSH
29554: LD_STRING D8-Huck-2
29556: PPUSH
29557: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29561: LD_EXP 40
29565: PPUSH
29566: LD_STRING D8-JMM-2
29568: PPUSH
29569: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
29573: LD_EXP 42
29577: PPUSH
29578: LD_STRING D8-Huck-3
29580: PPUSH
29581: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29585: LD_EXP 40
29589: PPUSH
29590: LD_STRING D8-JMM-3
29592: PPUSH
29593: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
29597: LD_EXP 42
29601: PPUSH
29602: LD_STRING D8-Huck-4
29604: PPUSH
29605: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29609: LD_EXP 40
29613: PPUSH
29614: LD_STRING D8-JMM-4
29616: PPUSH
29617: CALL_OW 88
// end else
29621: GO 29733
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
29623: LD_EXP 56
29627: PPUSH
29628: CALL_OW 310
29632: PPUSH
29633: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
29637: LD_EXP 56
29641: PPUSH
29642: LD_STRING D8-Huck-1
29644: PPUSH
29645: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
29649: LD_EXP 40
29653: PPUSH
29654: LD_STRING D8-JMM-1a
29656: PPUSH
29657: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
29661: LD_EXP 56
29665: PPUSH
29666: LD_STRING D8-Huck-2
29668: PPUSH
29669: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29673: LD_EXP 40
29677: PPUSH
29678: LD_STRING D8-JMM-2
29680: PPUSH
29681: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
29685: LD_EXP 56
29689: PPUSH
29690: LD_STRING D8-Huck-3
29692: PPUSH
29693: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29697: LD_EXP 40
29701: PPUSH
29702: LD_STRING D8-JMM-3
29704: PPUSH
29705: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
29709: LD_EXP 56
29713: PPUSH
29714: LD_STRING D8-Huck-4
29716: PPUSH
29717: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29721: LD_EXP 40
29725: PPUSH
29726: LD_STRING D8-JMM-4
29728: PPUSH
29729: CALL_OW 88
// end ; DialogueOff ;
29733: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
29737: LD_INT 25
29739: PPUSH
29740: LD_INT 1
29742: PPUSH
29743: LD_INT 1
29745: PPUSH
29746: CALL_OW 322
// end ;
29750: PPOPN 3
29752: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
29753: LD_EXP 73
29757: PPUSH
29758: CALL_OW 302
29762: PUSH
29763: LD_INT 1
29765: PPUSH
29766: LD_EXP 73
29770: PPUSH
29771: CALL_OW 292
29775: AND
29776: IFFALSE 30027
29778: GO 29780
29780: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
29781: LD_EXP 73
29785: PPUSH
29786: CALL_OW 87
// DialogueOn ;
29790: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
29794: LD_EXP 40
29798: PPUSH
29799: LD_STRING D10nB-JMM-1
29801: PPUSH
29802: CALL_OW 88
// if BurlakStatus = 1 then
29806: LD_EXP 9
29810: PUSH
29811: LD_INT 1
29813: EQUAL
29814: IFFALSE 29828
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
29816: LD_EXP 72
29820: PPUSH
29821: LD_STRING D10nB-Vse-1a
29823: PPUSH
29824: CALL_OW 94
// end ; if BurlakStatus = 0 then
29828: LD_EXP 9
29832: PUSH
29833: LD_INT 0
29835: EQUAL
29836: IFFALSE 29850
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
29838: LD_EXP 72
29842: PPUSH
29843: LD_STRING D10nB-Vse-1
29845: PPUSH
29846: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
29850: LD_EXP 40
29854: PPUSH
29855: LD_STRING D10nB-JMM-2
29857: PPUSH
29858: CALL_OW 88
// if KappaStatus then
29862: LD_EXP 2
29866: IFFALSE 29880
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
29868: LD_EXP 72
29872: PPUSH
29873: LD_STRING D10nB-Vse-5a
29875: PPUSH
29876: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
29880: LD_EXP 2
29884: NOT
29885: PUSH
29886: LD_EXP 6
29890: PUSH
29891: LD_INT 0
29893: EQUAL
29894: AND
29895: IFFALSE 30023
// begin if JMMGirl = 1 then
29897: LD_EXP 7
29901: PUSH
29902: LD_INT 1
29904: EQUAL
29905: IFFALSE 29955
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
29907: LD_EXP 72
29911: PPUSH
29912: LD_STRING D10nB-Vse-2
29914: PPUSH
29915: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
29919: LD_EXP 40
29923: PPUSH
29924: LD_STRING D10nB-JMM-3
29926: PPUSH
29927: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
29931: LD_EXP 72
29935: PPUSH
29936: LD_STRING D10nB-Vse-3
29938: PPUSH
29939: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
29943: LD_EXP 40
29947: PPUSH
29948: LD_STRING D10nB-JMM-4
29950: PPUSH
29951: CALL_OW 88
// end ; if JMMGirl = 2 then
29955: LD_EXP 7
29959: PUSH
29960: LD_INT 2
29962: EQUAL
29963: IFFALSE 29989
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
29965: LD_EXP 72
29969: PPUSH
29970: LD_STRING D10nB-Vse-4
29972: PPUSH
29973: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
29977: LD_EXP 40
29981: PPUSH
29982: LD_STRING D10nB-JMM-5
29984: PPUSH
29985: CALL_OW 88
// end ; if JMMGirl = 3 then
29989: LD_EXP 7
29993: PUSH
29994: LD_INT 3
29996: EQUAL
29997: IFFALSE 30023
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
29999: LD_EXP 72
30003: PPUSH
30004: LD_STRING D10nB-Vse-5
30006: PPUSH
30007: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30011: LD_EXP 40
30015: PPUSH
30016: LD_STRING D10nB-JMM-6
30018: PPUSH
30019: CALL_OW 88
// end ; end ; DialogueOff ;
30023: CALL_OW 7
// end ;
30027: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30028: LD_EXP 14
30032: PUSH
30033: LD_INT 115500
30035: GREATEREQUAL
30036: PUSH
30037: LD_EXP 67
30041: PPUSH
30042: CALL_OW 302
30046: AND
30047: PUSH
30048: LD_INT 267
30050: PPUSH
30051: CALL_OW 302
30055: AND
30056: IFFALSE 30432
30058: GO 30060
30060: DISABLE
30061: LD_INT 0
30063: PPUSH
// begin missionStage := 10 ;
30064: LD_ADDR_EXP 15
30068: PUSH
30069: LD_INT 10
30071: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30072: LD_ADDR_VAR 0 1
30076: PUSH
30077: LD_INT 22
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 23
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 26
30099: PUSH
30100: LD_INT 1
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 3
30109: PUSH
30110: LD_INT 25
30112: PUSH
30113: LD_INT 12
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 3
30126: PUSH
30127: LD_INT 25
30129: PUSH
30130: LD_INT 16
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: PPUSH
30148: CALL_OW 69
30152: PUSH
30153: LD_EXP 40
30157: PUSH
30158: LD_EXP 62
30162: PUSH
30163: LD_EXP 42
30167: PUSH
30168: LD_EXP 56
30172: PUSH
30173: LD_EXP 43
30177: PUSH
30178: LD_EXP 44
30182: PUSH
30183: LD_EXP 45
30187: PUSH
30188: LD_EXP 46
30192: PUSH
30193: LD_EXP 47
30197: PUSH
30198: LD_EXP 48
30202: PUSH
30203: LD_EXP 49
30207: PUSH
30208: LD_EXP 50
30212: PUSH
30213: LD_EXP 51
30217: PUSH
30218: LD_EXP 52
30222: PUSH
30223: LD_EXP 53
30227: PUSH
30228: LD_EXP 54
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: DIFF
30251: ST_TO_ADDR
// if not tmp and Brown then
30252: LD_VAR 0 1
30256: NOT
30257: PUSH
30258: LD_EXP 48
30262: AND
30263: IFFALSE 30278
// tmp := [ Brown ] ;
30265: LD_ADDR_VAR 0 1
30269: PUSH
30270: LD_EXP 48
30274: PUSH
30275: EMPTY
30276: LIST
30277: ST_TO_ADDR
// DialogueOn ;
30278: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30282: LD_VAR 0 1
30286: PUSH
30287: LD_INT 1
30289: ARRAY
30290: PPUSH
30291: LD_STRING D11-Sol1-1
30293: PPUSH
30294: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30298: LD_EXP 66
30302: PPUSH
30303: LD_STRING D11-Pla-1
30305: PPUSH
30306: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30310: LD_EXP 67
30314: PPUSH
30315: LD_STRING D11-Kov-1
30317: PPUSH
30318: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30322: LD_EXP 66
30326: PPUSH
30327: LD_STRING D11-Pla-2
30329: PPUSH
30330: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30334: LD_VAR 0 1
30338: PUSH
30339: LD_INT 1
30341: ARRAY
30342: PPUSH
30343: LD_STRING D11-Sol1-2
30345: PPUSH
30346: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
30350: LD_EXP 40
30354: PPUSH
30355: LD_STRING D11-JMM-2
30357: PPUSH
30358: CALL_OW 88
// DialogueOff ;
30362: CALL_OW 7
// allowBehemothConstruct := true ;
30366: LD_ADDR_EXP 25
30370: PUSH
30371: LD_INT 1
30373: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
30374: LD_STRING M4
30376: PPUSH
30377: CALL_OW 337
// BuildBehemoths ;
30381: CALL 8056 0 0
// repeat wait ( 15 15$00 ) ;
30385: LD_INT 31500
30387: PPUSH
30388: CALL_OW 67
// if behemothDestroyedBeforeFinish then
30392: LD_EXP 27
30396: IFFALSE 30400
// break ;
30398: GO 30432
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
30400: LD_INT 267
30402: PPUSH
30403: CALL_OW 274
30407: PPUSH
30408: LD_INT 1
30410: PPUSH
30411: CALL_OW 275
30415: PUSH
30416: LD_INT 1000
30418: GREATEREQUAL
30419: IFFALSE 30425
// BuildBehemoths ;
30421: CALL 8056 0 0
// until not behemothBuilders ;
30425: LD_EXP 75
30429: NOT
30430: IFFALSE 30385
// end ;
30432: PPOPN 1
30434: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
30435: LD_EXP 75
30439: NOT
30440: PUSH
30441: LD_EXP 28
30445: NOT
30446: AND
30447: PUSH
30448: LD_EXP 25
30452: AND
30453: IFFALSE 30473
30455: GO 30457
30457: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
30458: LD_STRING M4a
30460: PPUSH
30461: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
30465: LD_ADDR_EXP 27
30469: PUSH
30470: LD_INT 1
30472: ST_TO_ADDR
// end ;
30473: END
// every 0 0$1 trigger behemothDone do
30474: LD_EXP 28
30478: IFFALSE 30490
30480: GO 30482
30482: DISABLE
// ChangeMissionObjectives ( M4b ) ;
30483: LD_STRING M4b
30485: PPUSH
30486: CALL_OW 337
30490: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
30491: LD_EXP 29
30495: NOT
30496: IFFALSE 30692
30498: GO 30500
30500: DISABLE
30501: LD_INT 0
30503: PPUSH
30504: PPUSH
// begin enable ;
30505: ENABLE
// tmp := GetBehemoths ( 3 ) ;
30506: LD_ADDR_VAR 0 1
30510: PUSH
30511: LD_INT 3
30513: PPUSH
30514: CALL 106148 0 1
30518: ST_TO_ADDR
// if not tmp and not behemothDone then
30519: LD_VAR 0 1
30523: NOT
30524: PUSH
30525: LD_EXP 28
30529: NOT
30530: AND
30531: IFFALSE 30567
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
30533: LD_ADDR_VAR 0 1
30537: PUSH
30538: LD_INT 22
30540: PUSH
30541: LD_INT 3
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 30
30550: PUSH
30551: LD_INT 37
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PPUSH
30562: CALL_OW 69
30566: ST_TO_ADDR
// if not tmp then
30567: LD_VAR 0 1
30571: NOT
30572: IFFALSE 30576
// exit ;
30574: GO 30692
// for i in tmp do
30576: LD_ADDR_VAR 0 2
30580: PUSH
30581: LD_VAR 0 1
30585: PUSH
30586: FOR_IN
30587: IFFALSE 30690
// if See ( 1 , i ) then
30589: LD_INT 1
30591: PPUSH
30592: LD_VAR 0 2
30596: PPUSH
30597: CALL_OW 292
30601: IFFALSE 30688
// begin if GetType ( i ) = unit_building then
30603: LD_VAR 0 2
30607: PPUSH
30608: CALL_OW 247
30612: PUSH
30613: LD_INT 3
30615: EQUAL
30616: IFFALSE 30654
// begin disable ;
30618: DISABLE
// CenterNowOnUnits ( i ) ;
30619: LD_VAR 0 2
30623: PPUSH
30624: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
30628: LD_EXP 40
30632: PPUSH
30633: LD_STRING D17a-JMM-1
30635: PPUSH
30636: CALL_OW 88
// seeBehemoth := true ;
30640: LD_ADDR_EXP 29
30644: PUSH
30645: LD_INT 1
30647: ST_TO_ADDR
// exit ;
30648: POP
30649: POP
30650: GO 30692
// end else
30652: GO 30688
// begin disable ;
30654: DISABLE
// CenterNowOnUnits ( i ) ;
30655: LD_VAR 0 2
30659: PPUSH
30660: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
30664: LD_EXP 40
30668: PPUSH
30669: LD_STRING D17b-JMM-1
30671: PPUSH
30672: CALL_OW 88
// seeBehemoth := true ;
30676: LD_ADDR_EXP 29
30680: PUSH
30681: LD_INT 1
30683: ST_TO_ADDR
// exit ;
30684: POP
30685: POP
30686: GO 30692
// end ; end ;
30688: GO 30586
30690: POP
30691: POP
// end ;
30692: PPOPN 2
30694: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
30695: LD_EXP 14
30699: PUSH
30700: LD_INT 123200
30702: GREATEREQUAL
30703: IFFALSE 31903
30705: GO 30707
30707: DISABLE
30708: LD_INT 0
30710: PPUSH
30711: PPUSH
30712: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
30713: LD_INT 2
30715: PPUSH
30716: LD_INT 23
30718: PUSH
30719: LD_INT 3
30721: PUSH
30722: LD_INT 3
30724: PUSH
30725: LD_INT 48
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: PUSH
30734: EMPTY
30735: LIST
30736: PPUSH
30737: CALL 62369 0 2
// repeat wait ( 0 0$1 ) ;
30741: LD_INT 35
30743: PPUSH
30744: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
30748: LD_INT 22
30750: PUSH
30751: LD_INT 3
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: LD_INT 34
30760: PUSH
30761: LD_INT 48
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PPUSH
30772: CALL_OW 69
30776: IFFALSE 30741
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
30778: LD_ADDR_VAR 0 1
30782: PUSH
30783: LD_INT 22
30785: PUSH
30786: LD_INT 3
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 34
30795: PUSH
30796: LD_INT 48
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PPUSH
30807: CALL_OW 69
30811: PUSH
30812: LD_INT 1
30814: ARRAY
30815: ST_TO_ADDR
// missionStage := 12 ;
30816: LD_ADDR_EXP 15
30820: PUSH
30821: LD_INT 12
30823: ST_TO_ADDR
// platonovHasBomb := true ;
30824: LD_ADDR_EXP 30
30828: PUSH
30829: LD_INT 1
30831: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
30832: LD_VAR 0 1
30836: PPUSH
30837: LD_INT 181
30839: PPUSH
30840: LD_INT 86
30842: PPUSH
30843: CALL_OW 171
// AddComHold ( bomb ) ;
30847: LD_VAR 0 1
30851: PPUSH
30852: CALL_OW 200
// wait ( 0 0$10 ) ;
30856: LD_INT 350
30858: PPUSH
30859: CALL_OW 67
// DialogueOn ;
30863: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
30867: LD_EXP 66
30871: PPUSH
30872: LD_STRING D15-Pla-1
30874: PPUSH
30875: CALL_OW 94
// dec := Query ( Q15a ) ;
30879: LD_ADDR_VAR 0 2
30883: PUSH
30884: LD_STRING Q15a
30886: PPUSH
30887: CALL_OW 97
30891: ST_TO_ADDR
// if dec = 1 then
30892: LD_VAR 0 2
30896: PUSH
30897: LD_INT 1
30899: EQUAL
30900: IFFALSE 30923
// begin Say ( JMM , D15a-JMM-1 ) ;
30902: LD_EXP 40
30906: PPUSH
30907: LD_STRING D15a-JMM-1
30909: PPUSH
30910: CALL_OW 88
// YouLost ( Surrender ) ;
30914: LD_STRING Surrender
30916: PPUSH
30917: CALL_OW 104
// exit ;
30921: GO 31903
// end ; if dec = 2 then
30923: LD_VAR 0 2
30927: PUSH
30928: LD_INT 2
30930: EQUAL
30931: IFFALSE 31000
// begin Say ( JMM , D15b-JMM-1 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D15b-JMM-1
30940: PPUSH
30941: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
30945: LD_EXP 66
30949: PPUSH
30950: LD_STRING D15b-Pla-1
30952: PPUSH
30953: CALL_OW 94
// DialogueOff ;
30957: CALL_OW 7
// wait ( 3 3$00 ) ;
30961: LD_INT 6300
30963: PPUSH
30964: CALL_OW 67
// DialogueOn ;
30968: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
30972: LD_EXP 40
30976: PPUSH
30977: LD_STRING D15d-JMM-1a
30979: PPUSH
30980: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30984: LD_EXP 66
30988: PPUSH
30989: LD_STRING D15d-Pla-1
30991: PPUSH
30992: CALL_OW 94
// DialogueOff ;
30996: CALL_OW 7
// end ; if dec = 3 then
31000: LD_VAR 0 2
31004: PUSH
31005: LD_INT 3
31007: EQUAL
31008: IFFALSE 31062
// begin Say ( JMM , D15c-JMM-1 ) ;
31010: LD_EXP 40
31014: PPUSH
31015: LD_STRING D15c-JMM-1
31017: PPUSH
31018: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31022: LD_EXP 66
31026: PPUSH
31027: LD_STRING D15c-Pla-1
31029: PPUSH
31030: CALL_OW 94
// DialogueOff ;
31034: CALL_OW 7
// wait ( 0 0$15 ) ;
31038: LD_INT 525
31040: PPUSH
31041: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31045: LD_VAR 0 1
31049: PPUSH
31050: LD_INT 60
31052: PPUSH
31053: LD_INT 95
31055: PPUSH
31056: CALL_OW 116
// exit ;
31060: GO 31903
// end ; if dec = 4 then
31062: LD_VAR 0 2
31066: PUSH
31067: LD_INT 4
31069: EQUAL
31070: IFFALSE 31100
// begin Say ( JMM , D15d-JMM-1 ) ;
31072: LD_EXP 40
31076: PPUSH
31077: LD_STRING D15d-JMM-1
31079: PPUSH
31080: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31084: LD_EXP 66
31088: PPUSH
31089: LD_STRING D15d-Pla-1
31091: PPUSH
31092: CALL_OW 94
// DialogueOff ;
31096: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31100: LD_EXP 64
31104: PPUSH
31105: CALL_OW 302
31109: PUSH
31110: LD_EXP 64
31114: PPUSH
31115: CALL_OW 255
31119: PUSH
31120: LD_INT 1
31122: EQUAL
31123: AND
31124: PUSH
31125: LD_INT 22
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 34
31137: PUSH
31138: LD_INT 8
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: EMPTY
31146: LIST
31147: LIST
31148: PPUSH
31149: CALL_OW 69
31153: NOT
31154: AND
31155: IFFALSE 31804
// begin SetSide ( Friend , 8 ) ;
31157: LD_EXP 64
31161: PPUSH
31162: LD_INT 8
31164: PPUSH
31165: CALL_OW 235
// if IsInUnit ( Friend ) then
31169: LD_EXP 64
31173: PPUSH
31174: CALL_OW 310
31178: IFFALSE 31189
// ComExitBuilding ( Friend ) ;
31180: LD_EXP 64
31184: PPUSH
31185: CALL_OW 122
// if IsDriver ( Friend ) then
31189: LD_EXP 64
31193: PPUSH
31194: CALL 103704 0 1
31198: IFFALSE 31209
// ComExitVehicle ( Friend ) ;
31200: LD_EXP 64
31204: PPUSH
31205: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31209: LD_EXP 64
31213: PPUSH
31214: LD_INT 9
31216: PPUSH
31217: LD_INT 2
31219: PPUSH
31220: CALL_OW 171
// wait ( 0 0$05 ) ;
31224: LD_INT 175
31226: PPUSH
31227: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31231: LD_EXP 64
31235: PPUSH
31236: CALL_OW 87
// DialogueOn ;
31240: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31244: LD_EXP 40
31248: PPUSH
31249: LD_STRING D16-JMM-1
31251: PPUSH
31252: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31256: LD_EXP 64
31260: PPUSH
31261: LD_STRING D16-Friend-1
31263: PPUSH
31264: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31268: LD_EXP 40
31272: PPUSH
31273: LD_STRING D16-JMM-2
31275: PPUSH
31276: CALL_OW 88
// DialogueOff ;
31280: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31284: LD_EXP 64
31288: PPUSH
31289: LD_INT 1
31291: PPUSH
31292: CALL_OW 235
// ComHold ( Friend ) ;
31296: LD_EXP 64
31300: PPUSH
31301: CALL_OW 140
// wait ( 0 0$20 ) ;
31305: LD_INT 700
31307: PPUSH
31308: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31312: LD_EXP 64
31316: PPUSH
31317: LD_INT 9
31319: PPUSH
31320: LD_INT 2
31322: PPUSH
31323: CALL_OW 297
31327: PUSH
31328: LD_INT 30
31330: LESS
31331: IFFALSE 31400
// begin SetSide ( Friend , 8 ) ;
31333: LD_EXP 64
31337: PPUSH
31338: LD_INT 8
31340: PPUSH
31341: CALL_OW 235
// if IsInUnit ( Friend ) then
31345: LD_EXP 64
31349: PPUSH
31350: CALL_OW 310
31354: IFFALSE 31365
// ComExitBuilding ( Friend ) ;
31356: LD_EXP 64
31360: PPUSH
31361: CALL_OW 122
// if IsDriver ( Friend ) then
31365: LD_EXP 64
31369: PPUSH
31370: CALL 103704 0 1
31374: IFFALSE 31385
// ComExitVehicle ( Friend ) ;
31376: LD_EXP 64
31380: PPUSH
31381: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31385: LD_EXP 64
31389: PPUSH
31390: LD_INT 9
31392: PPUSH
31393: LD_INT 2
31395: PPUSH
31396: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
31400: LD_INT 1050
31402: PPUSH
31403: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31407: LD_INT 22
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 34
31419: PUSH
31420: LD_INT 8
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PPUSH
31431: CALL_OW 69
31435: NOT
31436: IFFALSE 31782
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31438: LD_ADDR_VAR 0 3
31442: PUSH
31443: LD_INT 22
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 26
31455: PUSH
31456: LD_INT 1
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 3
31465: PUSH
31466: LD_INT 25
31468: PUSH
31469: LD_INT 12
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 25
31478: PUSH
31479: LD_INT 16
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: LIST
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: LIST
31495: PPUSH
31496: CALL_OW 69
31500: PUSH
31501: LD_EXP 40
31505: PUSH
31506: LD_EXP 42
31510: PUSH
31511: LD_EXP 56
31515: PUSH
31516: LD_EXP 43
31520: PUSH
31521: LD_EXP 44
31525: PUSH
31526: LD_EXP 45
31530: PUSH
31531: LD_EXP 46
31535: PUSH
31536: LD_EXP 47
31540: PUSH
31541: LD_EXP 48
31545: PUSH
31546: LD_EXP 49
31550: PUSH
31551: LD_EXP 50
31555: PUSH
31556: LD_EXP 51
31560: PUSH
31561: LD_EXP 52
31565: PUSH
31566: LD_EXP 53
31570: PUSH
31571: LD_EXP 54
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: LIST
31580: LIST
31581: LIST
31582: LIST
31583: LIST
31584: LIST
31585: LIST
31586: LIST
31587: LIST
31588: LIST
31589: LIST
31590: LIST
31591: LIST
31592: DIFF
31593: ST_TO_ADDR
// DialogueOn ;
31594: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
31598: LD_EXP 66
31602: PPUSH
31603: LD_STRING D16a-Pla-1
31605: PPUSH
31606: CALL_OW 94
// if Stevens then
31610: LD_EXP 42
31614: IFFALSE 31630
// Say ( Stevens , D16a-Huck-1 ) else
31616: LD_EXP 42
31620: PPUSH
31621: LD_STRING D16a-Huck-1
31623: PPUSH
31624: CALL_OW 88
31628: GO 31672
// if Baker then
31630: LD_EXP 56
31634: IFFALSE 31650
// Say ( Baker , D16a-Huck-1 ) else
31636: LD_EXP 56
31640: PPUSH
31641: LD_STRING D16a-Huck-1
31643: PPUSH
31644: CALL_OW 88
31648: GO 31672
// if tmp then
31650: LD_VAR 0 3
31654: IFFALSE 31672
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
31656: LD_VAR 0 3
31660: PUSH
31661: LD_INT 1
31663: ARRAY
31664: PPUSH
31665: LD_STRING D16a-Sol1-1
31667: PPUSH
31668: CALL_OW 88
// if GetSide ( Friend ) = 8 then
31672: LD_EXP 64
31676: PPUSH
31677: CALL_OW 255
31681: PUSH
31682: LD_INT 8
31684: EQUAL
31685: IFFALSE 31701
// Say ( JMM , D16a-JMM-1 ) else
31687: LD_EXP 40
31691: PPUSH
31692: LD_STRING D16a-JMM-1
31694: PPUSH
31695: CALL_OW 88
31699: GO 31761
// begin Say ( JMM , D16a-JMM-1a ) ;
31701: LD_EXP 40
31705: PPUSH
31706: LD_STRING D16a-JMM-1a
31708: PPUSH
31709: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
31713: LD_EXP 64
31717: PPUSH
31718: LD_STRING D16a-Friend-1
31720: PPUSH
31721: CALL_OW 88
// ComExitBuilding ( Friend ) ;
31725: LD_EXP 64
31729: PPUSH
31730: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
31734: LD_EXP 64
31738: PPUSH
31739: LD_INT 191
31741: PPUSH
31742: LD_INT 103
31744: PPUSH
31745: CALL_OW 171
// SetSide ( Friend , 3 ) ;
31749: LD_EXP 64
31753: PPUSH
31754: LD_INT 3
31756: PPUSH
31757: CALL_OW 235
// end ; DialogueOff ;
31761: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
31765: LD_VAR 0 1
31769: PPUSH
31770: LD_INT 60
31772: PPUSH
31773: LD_INT 95
31775: PPUSH
31776: CALL_OW 116
// end else
31780: GO 31802
// begin DialogueOn ;
31782: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31786: LD_EXP 66
31790: PPUSH
31791: LD_STRING D16c-Pla-1
31793: PPUSH
31794: CALL_OW 94
// DialogueOff ;
31798: CALL_OW 7
// end ; end else
31802: GO 31903
// begin wait ( 3 3$00 ) ;
31804: LD_INT 6300
31806: PPUSH
31807: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31811: LD_INT 22
31813: PUSH
31814: LD_INT 1
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: PUSH
31821: LD_INT 34
31823: PUSH
31824: LD_INT 8
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PPUSH
31835: CALL_OW 69
31839: NOT
31840: IFFALSE 31883
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
31842: LD_EXP 66
31846: PPUSH
31847: LD_STRING D16b-Pla-1
31849: PPUSH
31850: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
31854: LD_EXP 40
31858: PPUSH
31859: LD_STRING D16b-JMM-1
31861: PPUSH
31862: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
31866: LD_VAR 0 1
31870: PPUSH
31871: LD_INT 60
31873: PPUSH
31874: LD_INT 95
31876: PPUSH
31877: CALL_OW 116
// end else
31881: GO 31903
// begin DialogueOn ;
31883: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31887: LD_EXP 66
31891: PPUSH
31892: LD_STRING D16c-Pla-1
31894: PPUSH
31895: CALL_OW 94
// DialogueOff ;
31899: CALL_OW 7
// end ; end ; end ;
31903: PPOPN 3
31905: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
31906: LD_INT 25
31908: PPUSH
31909: LD_INT 1
31911: PPUSH
31912: CALL_OW 321
31916: PUSH
31917: LD_INT 2
31919: EQUAL
31920: PUSH
31921: LD_EXP 14
31925: PUSH
31926: LD_INT 126000
31928: GREATEREQUAL
31929: OR
31930: PUSH
31931: LD_EXP 23
31935: NOT
31936: AND
31937: PUSH
31938: LD_EXP 77
31942: PPUSH
31943: CALL_OW 302
31947: AND
31948: IFFALSE 32306
31950: GO 31952
31952: DISABLE
31953: LD_INT 0
31955: PPUSH
// begin missionStage := 11 ;
31956: LD_ADDR_EXP 15
31960: PUSH
31961: LD_INT 11
31963: ST_TO_ADDR
// DialogueOn ;
31964: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
31968: LD_EXP 77
31972: PPUSH
31973: LD_STRING D9-Roth-1
31975: PPUSH
31976: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
31980: LD_EXP 40
31984: PPUSH
31985: LD_STRING D9-JMM-1
31987: PPUSH
31988: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
31992: LD_EXP 77
31996: PPUSH
31997: LD_STRING D9-Roth-2
31999: PPUSH
32000: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32004: LD_EXP 77
32008: PPUSH
32009: LD_STRING D9-Roth-2a
32011: PPUSH
32012: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32016: LD_EXP 66
32020: PPUSH
32021: LD_STRING D9-Pla-2
32023: PPUSH
32024: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32028: LD_EXP 77
32032: PPUSH
32033: LD_STRING D9-Roth-3
32035: PPUSH
32036: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32040: LD_EXP 66
32044: PPUSH
32045: LD_STRING D9-Pla-3
32047: PPUSH
32048: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32052: LD_EXP 77
32056: PPUSH
32057: LD_STRING D9-Roth-4
32059: PPUSH
32060: CALL_OW 94
// dec := Query ( Q9 ) ;
32064: LD_ADDR_VAR 0 1
32068: PUSH
32069: LD_STRING Q9
32071: PPUSH
32072: CALL_OW 97
32076: ST_TO_ADDR
// if dec = 1 then
32077: LD_VAR 0 1
32081: PUSH
32082: LD_INT 1
32084: EQUAL
32085: IFFALSE 32099
// SayRadio ( Roth , D9a-Roth-1 ) ;
32087: LD_EXP 77
32091: PPUSH
32092: LD_STRING D9a-Roth-1
32094: PPUSH
32095: CALL_OW 94
// if dec = 2 then
32099: LD_VAR 0 1
32103: PUSH
32104: LD_INT 2
32106: EQUAL
32107: IFFALSE 32133
// begin Say ( JMM , D9b-JMM-1 ) ;
32109: LD_EXP 40
32113: PPUSH
32114: LD_STRING D9b-JMM-1
32116: PPUSH
32117: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32121: LD_EXP 77
32125: PPUSH
32126: LD_STRING D9b-Roth-1
32128: PPUSH
32129: CALL_OW 94
// end ; if dec = 3 then
32133: LD_VAR 0 1
32137: PUSH
32138: LD_INT 3
32140: EQUAL
32141: IFFALSE 32203
// begin Say ( JMM , D9c-JMM-1 ) ;
32143: LD_EXP 40
32147: PPUSH
32148: LD_STRING D9c-JMM-1
32150: PPUSH
32151: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32155: LD_EXP 77
32159: PPUSH
32160: LD_STRING D9c-Roth-1
32162: PPUSH
32163: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32167: LD_EXP 40
32171: PPUSH
32172: LD_STRING D9c-JMM-2
32174: PPUSH
32175: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32179: LD_EXP 77
32183: PPUSH
32184: LD_STRING D9c-Roth-2
32186: PPUSH
32187: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32191: LD_EXP 40
32195: PPUSH
32196: LD_STRING D9c-JMM-3
32198: PPUSH
32199: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32203: LD_EXP 77
32207: PPUSH
32208: LD_STRING D9c-Roth-3
32210: PPUSH
32211: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32215: LD_EXP 77
32219: PPUSH
32220: LD_STRING D9cont-Roth-1
32222: PPUSH
32223: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32227: LD_EXP 40
32231: PPUSH
32232: LD_STRING D9cont-JMM-1
32234: PPUSH
32235: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32239: LD_EXP 77
32243: PPUSH
32244: LD_STRING D9cont-Roth-2
32246: PPUSH
32247: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32251: LD_EXP 40
32255: PPUSH
32256: LD_STRING D9cont-JMM-2
32258: PPUSH
32259: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32263: LD_EXP 77
32267: PPUSH
32268: LD_STRING D9cont-Roth-3
32270: PPUSH
32271: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32275: LD_EXP 40
32279: PPUSH
32280: LD_STRING D9cont-JMM-3
32282: PPUSH
32283: CALL_OW 88
// DialogueOff ;
32287: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32291: LD_STRING M3
32293: PPUSH
32294: CALL_OW 337
// allianceActive := true ;
32298: LD_ADDR_EXP 31
32302: PUSH
32303: LD_INT 1
32305: ST_TO_ADDR
// end ;
32306: PPOPN 1
32308: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32309: LD_INT 1
32311: PPUSH
32312: LD_INT 126
32314: PPUSH
32315: CALL_OW 292
32319: PUSH
32320: LD_EXP 66
32324: PPUSH
32325: CALL_OW 310
32329: AND
32330: IFFALSE 32483
32332: GO 32334
32334: DISABLE
32335: LD_INT 0
32337: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32338: LD_EXP 66
32342: PPUSH
32343: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
32347: LD_ADDR_VAR 0 1
32351: PUSH
32352: LD_INT 4
32354: PPUSH
32355: LD_INT 22
32357: PUSH
32358: LD_INT 1
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PPUSH
32365: CALL_OW 70
32369: PPUSH
32370: LD_EXP 66
32374: PPUSH
32375: CALL_OW 74
32379: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
32380: LD_EXP 66
32384: PPUSH
32385: LD_VAR 0 1
32389: PUSH
32390: LD_INT 1
32392: ARRAY
32393: PPUSH
32394: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
32398: LD_EXP 66
32402: PPUSH
32403: LD_STRING D18-Pla-1
32405: PPUSH
32406: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
32410: LD_INT 22
32412: PUSH
32413: LD_INT 3
32415: PUSH
32416: EMPTY
32417: LIST
32418: LIST
32419: PUSH
32420: LD_INT 34
32422: PUSH
32423: LD_INT 48
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PPUSH
32434: CALL_OW 69
32438: IFFALSE 32483
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
32440: LD_INT 22
32442: PUSH
32443: LD_INT 3
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: PUSH
32450: LD_INT 34
32452: PUSH
32453: LD_INT 48
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PPUSH
32464: CALL_OW 69
32468: PUSH
32469: LD_INT 1
32471: ARRAY
32472: PPUSH
32473: LD_INT 111
32475: PPUSH
32476: LD_INT 97
32478: PPUSH
32479: CALL_OW 116
// end ;
32483: PPOPN 1
32485: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
32486: LD_EXP 66
32490: PPUSH
32491: CALL_OW 301
32495: PUSH
32496: LD_EXP 69
32500: PPUSH
32501: CALL_OW 301
32505: AND
32506: PUSH
32507: LD_INT 22
32509: PUSH
32510: LD_INT 3
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 21
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 50
32529: PUSH
32530: EMPTY
32531: LIST
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: LIST
32537: PPUSH
32538: CALL_OW 69
32542: PUSH
32543: LD_INT 7
32545: PUSH
32546: LD_INT 8
32548: PUSH
32549: LD_INT 9
32551: PUSH
32552: LD_INT 10
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: PUSH
32561: LD_OWVAR 67
32565: ARRAY
32566: LESS
32567: AND
32568: IFFALSE 33367
32570: GO 32572
32572: DISABLE
32573: LD_INT 0
32575: PPUSH
32576: PPUSH
32577: PPUSH
32578: PPUSH
// begin MC_Kill ( 2 ) ;
32579: LD_INT 2
32581: PPUSH
32582: CALL 38358 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
32586: LD_INT 1
32588: PPUSH
32589: LD_INT 3
32591: PPUSH
32592: LD_INT 1
32594: PPUSH
32595: LD_INT 1
32597: PPUSH
32598: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
32602: LD_ADDR_VAR 0 2
32606: PUSH
32607: LD_INT 22
32609: PUSH
32610: LD_INT 3
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 21
32619: PUSH
32620: LD_INT 1
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 50
32629: PUSH
32630: EMPTY
32631: LIST
32632: PUSH
32633: LD_INT 26
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: PPUSH
32649: CALL_OW 69
32653: ST_TO_ADDR
// if not tmp then
32654: LD_VAR 0 2
32658: NOT
32659: IFFALSE 32715
// begin uc_side = 3 ;
32661: LD_ADDR_OWVAR 20
32665: PUSH
32666: LD_INT 3
32668: ST_TO_ADDR
// uc_nation = 3 ;
32669: LD_ADDR_OWVAR 21
32673: PUSH
32674: LD_INT 3
32676: ST_TO_ADDR
// hc_name =  ;
32677: LD_ADDR_OWVAR 26
32681: PUSH
32682: LD_STRING 
32684: ST_TO_ADDR
// hc_gallery =  ;
32685: LD_ADDR_OWVAR 33
32689: PUSH
32690: LD_STRING 
32692: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
32693: LD_INT 1
32695: PPUSH
32696: LD_INT 10
32698: PPUSH
32699: CALL_OW 381
// tmp = CreateHuman ;
32703: LD_ADDR_VAR 0 2
32707: PUSH
32708: CALL_OW 44
32712: ST_TO_ADDR
// end else
32713: GO 32729
// tmp := tmp [ 1 ] ;
32715: LD_ADDR_VAR 0 2
32719: PUSH
32720: LD_VAR 0 2
32724: PUSH
32725: LD_INT 1
32727: ARRAY
32728: ST_TO_ADDR
// DialogueOn ;
32729: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
32733: LD_VAR 0 2
32737: PPUSH
32738: LD_STRING DSurrenderRussians-RSol1-1a
32740: PPUSH
32741: CALL_OW 94
// DialogueOff ;
32745: CALL_OW 7
// russianDestroyed := true ;
32749: LD_ADDR_EXP 21
32753: PUSH
32754: LD_INT 1
32756: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
32757: LD_ADDR_VAR 0 1
32761: PUSH
32762: LD_INT 22
32764: PUSH
32765: LD_INT 6
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PPUSH
32772: CALL_OW 69
32776: PUSH
32777: FOR_IN
32778: IFFALSE 32791
// KillUnit ( i ) ;
32780: LD_VAR 0 1
32784: PPUSH
32785: CALL_OW 66
32789: GO 32777
32791: POP
32792: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
32793: LD_INT 22
32795: PUSH
32796: LD_INT 3
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 21
32805: PUSH
32806: LD_INT 1
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PPUSH
32817: CALL_OW 69
32821: PPUSH
32822: CALL_OW 122
// wait ( 0 0$1 ) ;
32826: LD_INT 35
32828: PPUSH
32829: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
32833: LD_INT 22
32835: PUSH
32836: LD_INT 3
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 21
32845: PUSH
32846: LD_INT 1
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PPUSH
32857: CALL_OW 69
32861: PPUSH
32862: LD_INT 25
32864: PPUSH
32865: CALL_OW 173
// wait ( 0 0$35 ) ;
32869: LD_INT 1225
32871: PPUSH
32872: CALL_OW 67
// PrepareOmarInvasion ;
32876: CALL 15711 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
32880: LD_ADDR_VAR 0 2
32884: PUSH
32885: LD_EXP 95
32889: PPUSH
32890: CALL_OW 250
32894: PUSH
32895: LD_EXP 95
32899: PPUSH
32900: CALL_OW 251
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
32909: LD_VAR 0 2
32913: PUSH
32914: LD_INT 1
32916: ARRAY
32917: PPUSH
32918: LD_VAR 0 2
32922: PUSH
32923: LD_INT 2
32925: ARRAY
32926: PPUSH
32927: LD_INT 1
32929: PPUSH
32930: LD_INT 8
32932: NEG
32933: PPUSH
32934: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
32938: LD_EXP 95
32942: PPUSH
32943: CALL_OW 87
// DialogueOn ;
32947: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
32951: LD_EXP 40
32955: PPUSH
32956: LD_STRING D19-JMM-1
32958: PPUSH
32959: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
32963: LD_ADDR_VAR 0 3
32967: PUSH
32968: LD_INT 22
32970: PUSH
32971: LD_INT 1
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 26
32980: PUSH
32981: LD_INT 1
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 2
32990: PUSH
32991: LD_INT 25
32993: PUSH
32994: LD_INT 1
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 25
33003: PUSH
33004: LD_INT 2
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 25
33013: PUSH
33014: LD_INT 3
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 25
33023: PUSH
33024: LD_INT 4
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 25
33033: PUSH
33034: LD_INT 5
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 25
33043: PUSH
33044: LD_INT 8
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: LIST
33064: PPUSH
33065: CALL_OW 69
33069: PUSH
33070: LD_EXP 40
33074: PUSH
33075: LD_EXP 41
33079: PUSH
33080: LD_EXP 62
33084: PUSH
33085: LD_EXP 42
33089: PUSH
33090: LD_EXP 43
33094: PUSH
33095: LD_EXP 44
33099: PUSH
33100: LD_EXP 45
33104: PUSH
33105: LD_EXP 46
33109: PUSH
33110: LD_EXP 47
33114: PUSH
33115: LD_EXP 48
33119: PUSH
33120: LD_EXP 49
33124: PUSH
33125: LD_EXP 50
33129: PUSH
33130: LD_EXP 51
33134: PUSH
33135: LD_EXP 52
33139: PUSH
33140: LD_EXP 53
33144: PUSH
33145: LD_EXP 54
33149: PUSH
33150: LD_EXP 55
33154: PUSH
33155: LD_EXP 56
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: DIFF
33180: ST_TO_ADDR
// if tmp2 then
33181: LD_VAR 0 3
33185: IFFALSE 33203
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33187: LD_VAR 0 3
33191: PUSH
33192: LD_INT 1
33194: ARRAY
33195: PPUSH
33196: LD_STRING D19-Sol1-1
33198: PPUSH
33199: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33203: LD_EXP 40
33207: PPUSH
33208: LD_STRING D19-JMM-2
33210: PPUSH
33211: CALL_OW 88
// DialogueOff ;
33215: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33219: LD_VAR 0 2
33223: PUSH
33224: LD_INT 1
33226: ARRAY
33227: PPUSH
33228: LD_VAR 0 2
33232: PUSH
33233: LD_INT 2
33235: ARRAY
33236: PPUSH
33237: LD_INT 1
33239: PPUSH
33240: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33244: LD_STRING M5
33246: PPUSH
33247: CALL_OW 337
// omarOnMotherLode := false ;
33251: LD_ADDR_VAR 0 4
33255: PUSH
33256: LD_INT 0
33258: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33259: LD_INT 35
33261: PPUSH
33262: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33266: LD_EXP 95
33270: PPUSH
33271: LD_INT 215
33273: PPUSH
33274: LD_INT 100
33276: PPUSH
33277: CALL_OW 297
33281: PUSH
33282: LD_INT 10
33284: LESS
33285: PUSH
33286: LD_VAR 0 4
33290: NOT
33291: AND
33292: IFFALSE 33326
// begin omarOnMotherLode := true ;
33294: LD_ADDR_VAR 0 4
33298: PUSH
33299: LD_INT 1
33301: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33302: LD_EXP 40
33306: PPUSH
33307: LD_STRING D19b-JMM-1
33309: PPUSH
33310: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33314: LD_EXP 95
33318: PPUSH
33319: LD_STRING DOmarContam-Omar-1
33321: PPUSH
33322: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33326: LD_EXP 95
33330: PPUSH
33331: CALL_OW 301
33335: IFFALSE 33259
// Say ( JMM , D19a-JMM-1 ) ;
33337: LD_EXP 40
33341: PPUSH
33342: LD_STRING D19a-JMM-1
33344: PPUSH
33345: CALL_OW 88
// if Heike then
33349: LD_EXP 96
33353: IFFALSE 33367
// Say ( Heike , D19a-Hke-1 ) ;
33355: LD_EXP 96
33359: PPUSH
33360: LD_STRING D19a-Hke-1
33362: PPUSH
33363: CALL_OW 88
// end ;
33367: PPOPN 4
33369: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
33370: LD_INT 22
33372: PUSH
33373: LD_INT 3
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 21
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: PPUSH
33394: CALL_OW 69
33398: PUSH
33399: LD_EXP 21
33403: AND
33404: IFFALSE 33472
33406: GO 33408
33408: DISABLE
33409: LD_INT 0
33411: PPUSH
33412: PPUSH
// begin enable ;
33413: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
33414: LD_ADDR_VAR 0 2
33418: PUSH
33419: LD_INT 25
33421: PPUSH
33422: LD_INT 22
33424: PUSH
33425: LD_INT 3
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PPUSH
33432: CALL_OW 70
33436: ST_TO_ADDR
// if not tmp then
33437: LD_VAR 0 2
33441: NOT
33442: IFFALSE 33446
// exit ;
33444: GO 33472
// for i in tmp do
33446: LD_ADDR_VAR 0 1
33450: PUSH
33451: LD_VAR 0 2
33455: PUSH
33456: FOR_IN
33457: IFFALSE 33470
// RemoveUnit ( i ) ;
33459: LD_VAR 0 1
33463: PPUSH
33464: CALL_OW 64
33468: GO 33456
33470: POP
33471: POP
// end ;
33472: PPOPN 2
33474: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
33475: LD_INT 22
33477: PUSH
33478: LD_INT 7
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 21
33487: PUSH
33488: LD_INT 1
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: EMPTY
33496: LIST
33497: LIST
33498: PPUSH
33499: CALL_OW 69
33503: PUSH
33504: LD_INT 6
33506: LESS
33507: IFFALSE 33975
33509: GO 33511
33511: DISABLE
33512: LD_INT 0
33514: PPUSH
33515: PPUSH
// begin MC_Kill ( 1 ) ;
33516: LD_INT 1
33518: PPUSH
33519: CALL 38358 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
33523: LD_INT 7
33525: PPUSH
33526: LD_INT 1
33528: PPUSH
33529: LD_INT 1
33531: PPUSH
33532: LD_INT 1
33534: PPUSH
33535: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
33539: LD_ADDR_VAR 0 1
33543: PUSH
33544: LD_INT 22
33546: PUSH
33547: LD_INT 7
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 26
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: PPUSH
33568: CALL_OW 69
33572: PUSH
33573: LD_EXP 77
33577: DIFF
33578: ST_TO_ADDR
// if tmp then
33579: LD_VAR 0 1
33583: IFFALSE 33601
// tmp := tmp [ 1 ] else
33585: LD_ADDR_VAR 0 1
33589: PUSH
33590: LD_VAR 0 1
33594: PUSH
33595: LD_INT 1
33597: ARRAY
33598: ST_TO_ADDR
33599: GO 33637
// begin uc_side := 7 ;
33601: LD_ADDR_OWVAR 20
33605: PUSH
33606: LD_INT 7
33608: ST_TO_ADDR
// uc_nation := 1 ;
33609: LD_ADDR_OWVAR 21
33613: PUSH
33614: LD_INT 1
33616: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
33617: LD_INT 1
33619: PPUSH
33620: LD_INT 8
33622: PPUSH
33623: CALL_OW 384
// tmp := CreateHuman ;
33627: LD_ADDR_VAR 0 1
33631: PUSH
33632: CALL_OW 44
33636: ST_TO_ADDR
// end ; DialogueOn ;
33637: CALL_OW 6
// if IsOK ( Roth ) then
33641: LD_EXP 77
33645: PPUSH
33646: CALL_OW 302
33650: IFFALSE 33664
// Say ( JMM , DAb-JMM-1 ) ;
33652: LD_EXP 40
33656: PPUSH
33657: LD_STRING DAb-JMM-1
33659: PPUSH
33660: CALL_OW 88
// if IsOK ( Roth ) then
33664: LD_EXP 77
33668: PPUSH
33669: CALL_OW 302
33673: IFFALSE 33697
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
33675: LD_EXP 77
33679: PPUSH
33680: LD_STRING DSurrenderAlliance-Roth-1
33682: PPUSH
33683: CALL_OW 88
// RothCaptured := true ;
33687: LD_ADDR_EXP 33
33691: PUSH
33692: LD_INT 1
33694: ST_TO_ADDR
// end else
33695: GO 33709
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
33697: LD_VAR 0 1
33701: PPUSH
33702: LD_STRING DSurrenderAlliance-Sci1-1
33704: PPUSH
33705: CALL_OW 88
// DialogueOff ;
33709: CALL_OW 7
// allianceDestroyed := true ;
33713: LD_ADDR_EXP 23
33717: PUSH
33718: LD_INT 1
33720: ST_TO_ADDR
// if capturedUnit = 0 then
33721: LD_EXP 34
33725: PUSH
33726: LD_INT 0
33728: EQUAL
33729: IFFALSE 33738
// SetAchievement ( ACH_ALLIANCE ) ;
33731: LD_STRING ACH_ALLIANCE
33733: PPUSH
33734: CALL_OW 543
// if trueAmericans then
33738: LD_EXP 35
33742: IFFALSE 33818
// begin if trueAmericans = 1 then
33744: LD_EXP 35
33748: PUSH
33749: LD_INT 1
33751: EQUAL
33752: IFFALSE 33768
// Say ( JMM , DAb-JMM-1a ) else
33754: LD_EXP 40
33758: PPUSH
33759: LD_STRING DAb-JMM-1a
33761: PPUSH
33762: CALL_OW 88
33766: GO 33780
// Say ( JMM , DAb-JMM-1b ) ;
33768: LD_EXP 40
33772: PPUSH
33773: LD_STRING DAb-JMM-1b
33775: PPUSH
33776: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
33780: LD_EXP 35
33784: PPUSH
33785: CALL_OW 87
// for i in trueAmericans do
33789: LD_ADDR_VAR 0 2
33793: PUSH
33794: LD_EXP 35
33798: PUSH
33799: FOR_IN
33800: IFFALSE 33816
// SetSide ( i , 1 ) ;
33802: LD_VAR 0 2
33806: PPUSH
33807: LD_INT 1
33809: PPUSH
33810: CALL_OW 235
33814: GO 33799
33816: POP
33817: POP
// end ; repeat wait ( 0 0$1 ) ;
33818: LD_INT 35
33820: PPUSH
33821: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
33825: LD_ADDR_VAR 0 2
33829: PUSH
33830: LD_INT 22
33832: PUSH
33833: LD_INT 7
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 21
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PPUSH
33854: CALL_OW 69
33858: PUSH
33859: FOR_IN
33860: IFFALSE 33942
// begin if IsInUnit ( i ) then
33862: LD_VAR 0 2
33866: PPUSH
33867: CALL_OW 310
33871: IFFALSE 33882
// ComExitBuilding ( i ) ;
33873: LD_VAR 0 2
33877: PPUSH
33878: CALL_OW 122
// if IsDriver ( i ) then
33882: LD_VAR 0 2
33886: PPUSH
33887: CALL 103704 0 1
33891: IFFALSE 33902
// ComExitVehicle ( i ) ;
33893: LD_VAR 0 2
33897: PPUSH
33898: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
33902: LD_VAR 0 2
33906: PPUSH
33907: LD_INT 26
33909: PPUSH
33910: CALL_OW 308
33914: NOT
33915: IFFALSE 33931
// AddComMoveToArea ( i , allianceEscapeArea ) else
33917: LD_VAR 0 2
33921: PPUSH
33922: LD_INT 26
33924: PPUSH
33925: CALL_OW 173
33929: GO 33940
// RemoveUnit ( i ) ;
33931: LD_VAR 0 2
33935: PPUSH
33936: CALL_OW 64
// end ;
33940: GO 33859
33942: POP
33943: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
33944: LD_INT 22
33946: PUSH
33947: LD_INT 7
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 21
33956: PUSH
33957: LD_INT 1
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PPUSH
33968: CALL_OW 69
33972: NOT
33973: IFFALSE 33818
// end ;
33975: PPOPN 2
33977: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
33978: LD_INT 0
33980: PPUSH
33981: PPUSH
// if not unit then
33982: LD_VAR 0 1
33986: NOT
33987: IFFALSE 33991
// exit ;
33989: GO 35499
// DoNotAttack ( 7 , unit ) ;
33991: LD_INT 7
33993: PPUSH
33994: LD_VAR 0 1
33998: PPUSH
33999: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_INT 260
34010: PPUSH
34011: LD_INT 235
34013: PPUSH
34014: LD_INT 3
34016: PPUSH
34017: LD_INT 1
34019: PPUSH
34020: CALL_OW 483
// SetSide ( unit , 4 ) ;
34024: LD_VAR 0 1
34028: PPUSH
34029: LD_INT 4
34031: PPUSH
34032: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34036: LD_ADDR_EXP 34
34040: PUSH
34041: LD_EXP 34
34045: PUSH
34046: LD_INT 1
34048: PLUS
34049: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34050: LD_INT 70
34052: PPUSH
34053: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34057: LD_INT 260
34059: PPUSH
34060: LD_INT 235
34062: PPUSH
34063: LD_INT 1
34065: PPUSH
34066: LD_INT 8
34068: NEG
34069: PPUSH
34070: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34074: LD_VAR 0 1
34078: PPUSH
34079: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34083: LD_VAR 0 1
34087: PPUSH
34088: LD_EXP 77
34092: PPUSH
34093: CALL_OW 119
// DialogueOn ;
34097: CALL_OW 6
// case unit of JMM :
34101: LD_VAR 0 1
34105: PUSH
34106: LD_EXP 40
34110: DOUBLE
34111: EQUAL
34112: IFTRUE 34116
34114: GO 34131
34116: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34117: LD_EXP 40
34121: PPUSH
34122: LD_STRING DA1-JMM-1
34124: PPUSH
34125: CALL_OW 91
34129: GO 34573
34131: LD_EXP 41
34135: DOUBLE
34136: EQUAL
34137: IFTRUE 34141
34139: GO 34156
34141: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34142: LD_EXP 41
34146: PPUSH
34147: LD_STRING DA1-Joan-1
34149: PPUSH
34150: CALL_OW 91
34154: GO 34573
34156: LD_EXP 43
34160: DOUBLE
34161: EQUAL
34162: IFTRUE 34166
34164: GO 34181
34166: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34167: LD_EXP 43
34171: PPUSH
34172: LD_STRING DA1-Lisa-1
34174: PPUSH
34175: CALL_OW 91
34179: GO 34573
34181: LD_EXP 44
34185: DOUBLE
34186: EQUAL
34187: IFTRUE 34191
34189: GO 34206
34191: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34192: LD_EXP 44
34196: PPUSH
34197: LD_STRING DA1-Don-1
34199: PPUSH
34200: CALL_OW 91
34204: GO 34573
34206: LD_EXP 51
34210: DOUBLE
34211: EQUAL
34212: IFTRUE 34216
34214: GO 34231
34216: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34217: LD_EXP 51
34221: PPUSH
34222: LD_STRING DA1-Corn-1
34224: PPUSH
34225: CALL_OW 91
34229: GO 34573
34231: LD_EXP 47
34235: DOUBLE
34236: EQUAL
34237: IFTRUE 34241
34239: GO 34256
34241: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34242: LD_EXP 47
34246: PPUSH
34247: LD_STRING DA1-Den-1
34249: PPUSH
34250: CALL_OW 91
34254: GO 34573
34256: LD_EXP 45
34260: DOUBLE
34261: EQUAL
34262: IFTRUE 34266
34264: GO 34281
34266: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34267: LD_EXP 45
34271: PPUSH
34272: LD_STRING DA1-Bobby-1
34274: PPUSH
34275: CALL_OW 91
34279: GO 34573
34281: LD_EXP 49
34285: DOUBLE
34286: EQUAL
34287: IFTRUE 34291
34289: GO 34306
34291: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34292: LD_EXP 49
34296: PPUSH
34297: LD_STRING DA1-Glad-1
34299: PPUSH
34300: CALL_OW 91
34304: GO 34573
34306: LD_EXP 46
34310: DOUBLE
34311: EQUAL
34312: IFTRUE 34316
34314: GO 34331
34316: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34317: LD_EXP 46
34321: PPUSH
34322: LD_STRING DA1-Cyrus-1
34324: PPUSH
34325: CALL_OW 91
34329: GO 34573
34331: LD_EXP 42
34335: DOUBLE
34336: EQUAL
34337: IFTRUE 34341
34339: GO 34356
34341: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34342: LD_EXP 42
34346: PPUSH
34347: LD_STRING DA1-Huck-1
34349: PPUSH
34350: CALL_OW 91
34354: GO 34573
34356: LD_EXP 56
34360: DOUBLE
34361: EQUAL
34362: IFTRUE 34366
34364: GO 34381
34366: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
34367: LD_EXP 56
34371: PPUSH
34372: LD_STRING DA1-Huck-1
34374: PPUSH
34375: CALL_OW 91
34379: GO 34573
34381: LD_EXP 48
34385: DOUBLE
34386: EQUAL
34387: IFTRUE 34391
34389: GO 34406
34391: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
34392: LD_EXP 48
34396: PPUSH
34397: LD_STRING DA1-Brown-1
34399: PPUSH
34400: CALL_OW 91
34404: GO 34573
34406: LD_EXP 52
34410: DOUBLE
34411: EQUAL
34412: IFTRUE 34416
34414: GO 34431
34416: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
34417: LD_EXP 52
34421: PPUSH
34422: LD_STRING DA1-Gary-1
34424: PPUSH
34425: CALL_OW 91
34429: GO 34573
34431: LD_EXP 55
34435: DOUBLE
34436: EQUAL
34437: IFTRUE 34441
34439: GO 34456
34441: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
34442: LD_EXP 55
34446: PPUSH
34447: LD_STRING DA1-Con-1
34449: PPUSH
34450: CALL_OW 91
34454: GO 34573
34456: LD_EXP 62
34460: DOUBLE
34461: EQUAL
34462: IFTRUE 34466
34464: GO 34481
34466: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
34467: LD_EXP 62
34471: PPUSH
34472: LD_STRING DA1-Kurt-1
34474: PPUSH
34475: CALL_OW 91
34479: GO 34573
34481: LD_EXP 54
34485: DOUBLE
34486: EQUAL
34487: IFTRUE 34491
34489: GO 34506
34491: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
34492: LD_EXP 54
34496: PPUSH
34497: LD_STRING DA1-Yam-1
34499: PPUSH
34500: CALL_OW 91
34504: GO 34573
34506: LD_EXP 53
34510: DOUBLE
34511: EQUAL
34512: IFTRUE 34516
34514: GO 34531
34516: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
34517: LD_EXP 53
34521: PPUSH
34522: LD_STRING DA1-Frank-1
34524: PPUSH
34525: CALL_OW 91
34529: GO 34573
34531: POP
// begin if GetSex ( unit ) = sex_male then
34532: LD_VAR 0 1
34536: PPUSH
34537: CALL_OW 258
34541: PUSH
34542: LD_INT 1
34544: EQUAL
34545: IFFALSE 34561
// ForceSay ( unit , DA1-Sol1-1 ) else
34547: LD_VAR 0 1
34551: PPUSH
34552: LD_STRING DA1-Sol1-1
34554: PPUSH
34555: CALL_OW 91
34559: GO 34573
// ForceSay ( unit , DA1-FSol1-1 ) ;
34561: LD_VAR 0 1
34565: PPUSH
34566: LD_STRING DA1-FSol1-1
34568: PPUSH
34569: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
34573: LD_EXP 77
34577: PPUSH
34578: LD_STRING DA-Roth-1
34580: PPUSH
34581: CALL_OW 88
// if capturedUnit = 1 then
34585: LD_EXP 34
34589: PUSH
34590: LD_INT 1
34592: EQUAL
34593: IFFALSE 34621
// begin Say ( Simms , DA-Sim-1 ) ;
34595: LD_EXP 78
34599: PPUSH
34600: LD_STRING DA-Sim-1
34602: PPUSH
34603: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
34607: LD_EXP 77
34611: PPUSH
34612: LD_STRING DA-Roth-2
34614: PPUSH
34615: CALL_OW 88
// end else
34619: GO 34633
// Say ( Simms , DA-Sim-2 ) ;
34621: LD_EXP 78
34625: PPUSH
34626: LD_STRING DA-Sim-2
34628: PPUSH
34629: CALL_OW 88
// case unit of JMM :
34633: LD_VAR 0 1
34637: PUSH
34638: LD_EXP 40
34642: DOUBLE
34643: EQUAL
34644: IFTRUE 34648
34646: GO 34663
34648: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
34649: LD_EXP 40
34653: PPUSH
34654: LD_STRING DA1-JMM-1a
34656: PPUSH
34657: CALL_OW 91
34661: GO 35180
34663: LD_EXP 41
34667: DOUBLE
34668: EQUAL
34669: IFTRUE 34673
34671: GO 34688
34673: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
34674: LD_EXP 41
34678: PPUSH
34679: LD_STRING DA1-Joan-1a
34681: PPUSH
34682: CALL_OW 91
34686: GO 35180
34688: LD_EXP 43
34692: DOUBLE
34693: EQUAL
34694: IFTRUE 34698
34696: GO 34713
34698: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
34699: LD_EXP 43
34703: PPUSH
34704: LD_STRING DA1-Lisa-1a
34706: PPUSH
34707: CALL_OW 91
34711: GO 35180
34713: LD_EXP 44
34717: DOUBLE
34718: EQUAL
34719: IFTRUE 34723
34721: GO 34738
34723: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
34724: LD_EXP 44
34728: PPUSH
34729: LD_STRING DA1-Don-1a
34731: PPUSH
34732: CALL_OW 91
34736: GO 35180
34738: LD_EXP 51
34742: DOUBLE
34743: EQUAL
34744: IFTRUE 34748
34746: GO 34763
34748: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
34749: LD_EXP 51
34753: PPUSH
34754: LD_STRING DA1-Corn-1a
34756: PPUSH
34757: CALL_OW 91
34761: GO 35180
34763: LD_EXP 47
34767: DOUBLE
34768: EQUAL
34769: IFTRUE 34773
34771: GO 34788
34773: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
34774: LD_EXP 47
34778: PPUSH
34779: LD_STRING DA1-Den-1a
34781: PPUSH
34782: CALL_OW 91
34786: GO 35180
34788: LD_EXP 45
34792: DOUBLE
34793: EQUAL
34794: IFTRUE 34798
34796: GO 34813
34798: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
34799: LD_EXP 45
34803: PPUSH
34804: LD_STRING DA1-Bobby-1a
34806: PPUSH
34807: CALL_OW 91
34811: GO 35180
34813: LD_EXP 49
34817: DOUBLE
34818: EQUAL
34819: IFTRUE 34823
34821: GO 34838
34823: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
34824: LD_EXP 49
34828: PPUSH
34829: LD_STRING DA1-Glad-1a
34831: PPUSH
34832: CALL_OW 91
34836: GO 35180
34838: LD_EXP 46
34842: DOUBLE
34843: EQUAL
34844: IFTRUE 34848
34846: GO 34863
34848: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
34849: LD_EXP 46
34853: PPUSH
34854: LD_STRING DA1-Cyrus-1a
34856: PPUSH
34857: CALL_OW 91
34861: GO 35180
34863: LD_EXP 42
34867: DOUBLE
34868: EQUAL
34869: IFTRUE 34873
34871: GO 34888
34873: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
34874: LD_EXP 42
34878: PPUSH
34879: LD_STRING DA1-Huck-1a
34881: PPUSH
34882: CALL_OW 91
34886: GO 35180
34888: LD_EXP 56
34892: DOUBLE
34893: EQUAL
34894: IFTRUE 34898
34896: GO 34913
34898: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
34899: LD_EXP 56
34903: PPUSH
34904: LD_STRING DA1-Huck-1a
34906: PPUSH
34907: CALL_OW 91
34911: GO 35180
34913: LD_EXP 48
34917: DOUBLE
34918: EQUAL
34919: IFTRUE 34923
34921: GO 34938
34923: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
34924: LD_EXP 48
34928: PPUSH
34929: LD_STRING DA1-Brown-1a
34931: PPUSH
34932: CALL_OW 91
34936: GO 35180
34938: LD_EXP 52
34942: DOUBLE
34943: EQUAL
34944: IFTRUE 34948
34946: GO 34963
34948: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
34949: LD_EXP 52
34953: PPUSH
34954: LD_STRING DA1-Gary-1a
34956: PPUSH
34957: CALL_OW 91
34961: GO 35180
34963: LD_EXP 55
34967: DOUBLE
34968: EQUAL
34969: IFTRUE 34973
34971: GO 34998
34973: POP
// if JMMGirl = 3 then
34974: LD_EXP 7
34978: PUSH
34979: LD_INT 3
34981: EQUAL
34982: IFFALSE 34996
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
34984: LD_EXP 55
34988: PPUSH
34989: LD_STRING DA1-Con-1a
34991: PPUSH
34992: CALL_OW 91
34996: GO 35180
34998: LD_EXP 62
35002: DOUBLE
35003: EQUAL
35004: IFTRUE 35008
35006: GO 35023
35008: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35009: LD_EXP 62
35013: PPUSH
35014: LD_STRING DA1-Kurt-1a
35016: PPUSH
35017: CALL_OW 91
35021: GO 35180
35023: LD_EXP 54
35027: DOUBLE
35028: EQUAL
35029: IFTRUE 35033
35031: GO 35048
35033: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35034: LD_EXP 54
35038: PPUSH
35039: LD_STRING DA1-Yam-1a
35041: PPUSH
35042: CALL_OW 91
35046: GO 35180
35048: LD_EXP 53
35052: DOUBLE
35053: EQUAL
35054: IFTRUE 35058
35056: GO 35073
35058: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35059: LD_EXP 53
35063: PPUSH
35064: LD_STRING DA1-Frank-1a
35066: PPUSH
35067: CALL_OW 91
35071: GO 35180
35073: POP
// begin join := rand ( 0 , 1 ) ;
35074: LD_ADDR_VAR 0 3
35078: PUSH
35079: LD_INT 0
35081: PPUSH
35082: LD_INT 1
35084: PPUSH
35085: CALL_OW 12
35089: ST_TO_ADDR
// if join then
35090: LD_VAR 0 3
35094: IFFALSE 35139
// begin if GetSex ( unit ) = sex_male then
35096: LD_VAR 0 1
35100: PPUSH
35101: CALL_OW 258
35105: PUSH
35106: LD_INT 1
35108: EQUAL
35109: IFFALSE 35125
// ForceSay ( unit , DA1-Sol1-1b ) else
35111: LD_VAR 0 1
35115: PPUSH
35116: LD_STRING DA1-Sol1-1b
35118: PPUSH
35119: CALL_OW 91
35123: GO 35137
// ForceSay ( unit , DA1-FSol1-1b ) ;
35125: LD_VAR 0 1
35129: PPUSH
35130: LD_STRING DA1-FSol1-1b
35132: PPUSH
35133: CALL_OW 91
// end else
35137: GO 35180
// begin if GetSex ( unit ) = sex_male then
35139: LD_VAR 0 1
35143: PPUSH
35144: CALL_OW 258
35148: PUSH
35149: LD_INT 1
35151: EQUAL
35152: IFFALSE 35168
// ForceSay ( unit , DA1-Sol1-1a ) else
35154: LD_VAR 0 1
35158: PPUSH
35159: LD_STRING DA1-Sol1-1a
35161: PPUSH
35162: CALL_OW 91
35166: GO 35180
// ForceSay ( unit , DA1-FSol1-1a ) ;
35168: LD_VAR 0 1
35172: PPUSH
35173: LD_STRING DA1-FSol1-1a
35175: PPUSH
35176: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35180: LD_VAR 0 1
35184: PUSH
35185: LD_EXP 40
35189: EQUAL
35190: IFFALSE 35201
// begin YouLost ( JMMCaptured ) ;
35192: LD_STRING JMMCaptured
35194: PPUSH
35195: CALL_OW 104
// exit ;
35199: GO 35499
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
35201: LD_VAR 0 1
35205: PUSH
35206: LD_EXP 44
35210: PUSH
35211: LD_EXP 47
35215: PUSH
35216: LD_EXP 45
35220: PUSH
35221: LD_EXP 42
35225: PUSH
35226: LD_EXP 56
35230: PUSH
35231: LD_EXP 48
35235: PUSH
35236: LD_EXP 54
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: LIST
35249: IN
35250: PUSH
35251: LD_VAR 0 3
35255: OR
35256: IFFALSE 35355
// begin Say ( Roth , DA-Roth-3 ) ;
35258: LD_EXP 77
35262: PPUSH
35263: LD_STRING DA-Roth-3
35265: PPUSH
35266: CALL_OW 88
// SetSide ( unit , 7 ) ;
35270: LD_VAR 0 1
35274: PPUSH
35275: LD_INT 7
35277: PPUSH
35278: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35282: LD_ADDR_EXP 100
35286: PUSH
35287: LD_EXP 100
35291: PPUSH
35292: LD_INT 1
35294: PPUSH
35295: LD_EXP 100
35299: PUSH
35300: LD_INT 1
35302: ARRAY
35303: PUSH
35304: LD_VAR 0 1
35308: ADD
35309: PPUSH
35310: CALL_OW 1
35314: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35315: LD_INT 260
35317: PPUSH
35318: LD_INT 235
35320: PPUSH
35321: LD_INT 1
35323: PPUSH
35324: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35328: LD_VAR 0 1
35332: PPUSH
35333: LD_INT 1000
35335: PPUSH
35336: CALL_OW 234
// DialogueOff ;
35340: CALL_OW 7
// ComFree ( unit ) ;
35344: LD_VAR 0 1
35348: PPUSH
35349: CALL_OW 139
// end else
35353: GO 35436
// begin Say ( Roth , DA-Roth-3a ) ;
35355: LD_EXP 77
35359: PPUSH
35360: LD_STRING DA-Roth-3a
35362: PPUSH
35363: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
35367: LD_ADDR_EXP 35
35371: PUSH
35372: LD_EXP 35
35376: PUSH
35377: LD_VAR 0 1
35381: ADD
35382: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35383: LD_INT 260
35385: PPUSH
35386: LD_INT 235
35388: PPUSH
35389: LD_INT 1
35391: PPUSH
35392: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35396: LD_VAR 0 1
35400: PPUSH
35401: LD_INT 1000
35403: PPUSH
35404: CALL_OW 234
// DialogueOff ;
35408: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
35412: LD_VAR 0 1
35416: PPUSH
35417: LD_INT 272
35419: PPUSH
35420: LD_INT 254
35422: PPUSH
35423: CALL_OW 111
// AddComHold ( unit ) ;
35427: LD_VAR 0 1
35431: PPUSH
35432: CALL_OW 200
// end ; if capturedUnit = 1 then
35436: LD_EXP 34
35440: PUSH
35441: LD_INT 1
35443: EQUAL
35444: IFFALSE 35499
// begin DialogueOn ;
35446: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
35450: LD_EXP 40
35454: PPUSH
35455: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
35459: LD_EXP 40
35463: PPUSH
35464: LD_STRING DAa-JMM-1
35466: PPUSH
35467: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
35471: LD_EXP 40
35475: PPUSH
35476: LD_STRING DAa-JMM-1a
35478: PPUSH
35479: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
35483: LD_EXP 40
35487: PPUSH
35488: LD_STRING DAa-JMM-1b
35490: PPUSH
35491: CALL_OW 88
// DialogueOff ;
35495: CALL_OW 7
// end ; end ;
35499: LD_VAR 0 2
35503: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
35504: LD_EXP 15
35508: PUSH
35509: LD_INT 13
35511: GREATEREQUAL
35512: PUSH
35513: LD_INT 22
35515: PUSH
35516: LD_INT 2
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 21
35525: PUSH
35526: LD_INT 1
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PPUSH
35537: CALL_OW 69
35541: PUSH
35542: LD_INT 0
35544: EQUAL
35545: AND
35546: PUSH
35547: LD_INT 22
35549: PUSH
35550: LD_INT 2
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 33
35559: PUSH
35560: LD_INT 5
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 21
35569: PUSH
35570: LD_INT 2
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 50
35579: PUSH
35580: EMPTY
35581: LIST
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: PPUSH
35589: CALL_OW 69
35593: PUSH
35594: LD_INT 0
35596: EQUAL
35597: AND
35598: PUSH
35599: LD_EXP 21
35603: AND
35604: PUSH
35605: LD_EXP 22
35609: AND
35610: PUSH
35611: LD_EXP 23
35615: AND
35616: IFFALSE 36312
35618: GO 35620
35620: DISABLE
35621: LD_INT 0
35623: PPUSH
35624: PPUSH
35625: PPUSH
// begin m1 := false ;
35626: LD_ADDR_VAR 0 1
35630: PUSH
35631: LD_INT 0
35633: ST_TO_ADDR
// m2 := false ;
35634: LD_ADDR_VAR 0 2
35638: PUSH
35639: LD_INT 0
35641: ST_TO_ADDR
// m3 := false ;
35642: LD_ADDR_VAR 0 3
35646: PUSH
35647: LD_INT 0
35649: ST_TO_ADDR
// if not bombExploded then
35650: LD_EXP 37
35654: NOT
35655: IFFALSE 35664
// SetAchievement ( ACH_SIBROCKET ) ;
35657: LD_STRING ACH_SIBROCKET
35659: PPUSH
35660: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
35664: LD_EXP 64
35668: PPUSH
35669: CALL_OW 255
35673: PUSH
35674: LD_INT 1
35676: EQUAL
35677: PUSH
35678: LD_EXP 64
35682: PPUSH
35683: CALL_OW 302
35687: AND
35688: IFFALSE 35704
// begin wait ( 3 ) ;
35690: LD_INT 3
35692: PPUSH
35693: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
35697: LD_STRING ACH_OPO
35699: PPUSH
35700: CALL_OW 543
// end ; if tick <= 120 120$00 then
35704: LD_OWVAR 1
35708: PUSH
35709: LD_INT 252000
35711: LESSEQUAL
35712: IFFALSE 35728
// begin wait ( 3 ) ;
35714: LD_INT 3
35716: PPUSH
35717: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
35721: LD_STRING ACH_ASPEED_15
35723: PPUSH
35724: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
35728: LD_EXP 40
35732: PPUSH
35733: CALL_OW 87
// music_class := 5 ;
35737: LD_ADDR_OWVAR 72
35741: PUSH
35742: LD_INT 5
35744: ST_TO_ADDR
// music_nat := 5 ;
35745: LD_ADDR_OWVAR 71
35749: PUSH
35750: LD_INT 5
35752: ST_TO_ADDR
// DialogueOn ;
35753: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
35757: LD_EXP 40
35761: PPUSH
35762: LD_STRING D20-JMM-1
35764: PPUSH
35765: CALL_OW 88
// if IsOK ( Joan ) then
35769: LD_EXP 41
35773: PPUSH
35774: CALL_OW 302
35778: IFFALSE 35792
// Say ( Joan , D20-Joan-1 ) ;
35780: LD_EXP 41
35784: PPUSH
35785: LD_STRING D20-Joan-1
35787: PPUSH
35788: CALL_OW 88
// if IsOk ( Lisa ) then
35792: LD_EXP 43
35796: PPUSH
35797: CALL_OW 302
35801: IFFALSE 35815
// Say ( Lisa , D20-Lisa-1 ) ;
35803: LD_EXP 43
35807: PPUSH
35808: LD_STRING D20-Lisa-1
35810: PPUSH
35811: CALL_OW 88
// if IsOk ( Donaldson ) then
35815: LD_EXP 44
35819: PPUSH
35820: CALL_OW 302
35824: IFFALSE 35838
// Say ( Donaldson , D20-Don-1 ) ;
35826: LD_EXP 44
35830: PPUSH
35831: LD_STRING D20-Don-1
35833: PPUSH
35834: CALL_OW 88
// if IsOK ( Cornel ) then
35838: LD_EXP 51
35842: PPUSH
35843: CALL_OW 302
35847: IFFALSE 35861
// Say ( Cornel , D20-Corn-1 ) ;
35849: LD_EXP 51
35853: PPUSH
35854: LD_STRING D20-Corn-1
35856: PPUSH
35857: CALL_OW 88
// if IsOk ( Denis ) then
35861: LD_EXP 47
35865: PPUSH
35866: CALL_OW 302
35870: IFFALSE 35884
// Say ( Denis , D20-Den-1 ) ;
35872: LD_EXP 47
35876: PPUSH
35877: LD_STRING D20-Den-1
35879: PPUSH
35880: CALL_OW 88
// if IsOk ( Bobby ) then
35884: LD_EXP 45
35888: PPUSH
35889: CALL_OW 302
35893: IFFALSE 35907
// Say ( Bobby , D20-Bobby-1 ) ;
35895: LD_EXP 45
35899: PPUSH
35900: LD_STRING D20-Bobby-1
35902: PPUSH
35903: CALL_OW 88
// if IsOk ( Gladstone ) then
35907: LD_EXP 49
35911: PPUSH
35912: CALL_OW 302
35916: IFFALSE 35930
// Say ( Gladstone , D20-Glad-1 ) ;
35918: LD_EXP 49
35922: PPUSH
35923: LD_STRING D20-Glad-1
35925: PPUSH
35926: CALL_OW 88
// if IsOk ( Cyrus ) then
35930: LD_EXP 46
35934: PPUSH
35935: CALL_OW 302
35939: IFFALSE 35953
// Say ( Cyrus , D20-Cyrus-1 ) ;
35941: LD_EXP 46
35945: PPUSH
35946: LD_STRING D20-Cyrus-1
35948: PPUSH
35949: CALL_OW 88
// if IsOk ( Stevens ) then
35953: LD_EXP 42
35957: PPUSH
35958: CALL_OW 302
35962: IFFALSE 35976
// Say ( Stevens , D20-Huck-1 ) ;
35964: LD_EXP 42
35968: PPUSH
35969: LD_STRING D20-Huck-1
35971: PPUSH
35972: CALL_OW 88
// if IsOk ( Brown ) then
35976: LD_EXP 48
35980: PPUSH
35981: CALL_OW 302
35985: IFFALSE 35999
// Say ( Brown , D20-Brown-1 ) ;
35987: LD_EXP 48
35991: PPUSH
35992: LD_STRING D20-Brown-1
35994: PPUSH
35995: CALL_OW 88
// if IsOk ( Gary ) then
35999: LD_EXP 52
36003: PPUSH
36004: CALL_OW 302
36008: IFFALSE 36022
// Say ( Gary , D20-Gary-1 ) ;
36010: LD_EXP 52
36014: PPUSH
36015: LD_STRING D20-Gary-1
36017: PPUSH
36018: CALL_OW 88
// if IsOk ( Connie ) then
36022: LD_EXP 55
36026: PPUSH
36027: CALL_OW 302
36031: IFFALSE 36045
// Say ( Connie , D20-Con-1 ) ;
36033: LD_EXP 55
36037: PPUSH
36038: LD_STRING D20-Con-1
36040: PPUSH
36041: CALL_OW 88
// if IsOk ( Kurt ) then
36045: LD_EXP 62
36049: PPUSH
36050: CALL_OW 302
36054: IFFALSE 36068
// Say ( Kurt , D20-Kurt-1 ) ;
36056: LD_EXP 62
36060: PPUSH
36061: LD_STRING D20-Kurt-1
36063: PPUSH
36064: CALL_OW 88
// if IsOk ( Kikuchi ) then
36068: LD_EXP 54
36072: PPUSH
36073: CALL_OW 302
36077: IFFALSE 36091
// Say ( Kikuchi , D20-Yam-1 ) ;
36079: LD_EXP 54
36083: PPUSH
36084: LD_STRING D20-Yam-1
36086: PPUSH
36087: CALL_OW 88
// if IsOk ( Frank ) then
36091: LD_EXP 53
36095: PPUSH
36096: CALL_OW 302
36100: IFFALSE 36114
// Say ( Frank , D20-Frank-1 ) ;
36102: LD_EXP 53
36106: PPUSH
36107: LD_STRING D20-Frank-1
36109: PPUSH
36110: CALL_OW 88
// DialogueOff ;
36114: CALL_OW 7
// if RothCaptured then
36118: LD_EXP 33
36122: IFFALSE 36144
// begin m1 := true ;
36124: LD_ADDR_VAR 0 1
36128: PUSH
36129: LD_INT 1
36131: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36132: LD_STRING Roth
36134: PPUSH
36135: LD_INT 1
36137: PPUSH
36138: CALL_OW 101
// end else
36142: GO 36155
// AddMedal ( Roth , - 1 ) ;
36144: LD_STRING Roth
36146: PPUSH
36147: LD_INT 1
36149: NEG
36150: PPUSH
36151: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36155: LD_EXP 25
36159: NOT
36160: PUSH
36161: LD_EXP 27
36165: OR
36166: PUSH
36167: LD_EXP 28
36171: NOT
36172: OR
36173: IFFALSE 36195
// begin m2 := true ;
36175: LD_ADDR_VAR 0 2
36179: PUSH
36180: LD_INT 1
36182: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36183: LD_STRING Project
36185: PPUSH
36186: LD_INT 1
36188: PPUSH
36189: CALL_OW 101
// end else
36193: GO 36206
// AddMedal ( Project , - 1 ) ;
36195: LD_STRING Project
36197: PPUSH
36198: LD_INT 1
36200: NEG
36201: PPUSH
36202: CALL_OW 101
// if lostCounter = 0 then
36206: LD_EXP 32
36210: PUSH
36211: LD_INT 0
36213: EQUAL
36214: IFFALSE 36236
// begin m3 := true ;
36216: LD_ADDR_VAR 0 3
36220: PUSH
36221: LD_INT 1
36223: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36224: LD_STRING NoLosses
36226: PPUSH
36227: LD_INT 1
36229: PPUSH
36230: CALL_OW 101
// end else
36234: GO 36247
// AddMedal ( NoLosses , - 1 ) ;
36236: LD_STRING NoLosses
36238: PPUSH
36239: LD_INT 1
36241: NEG
36242: PPUSH
36243: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36247: LD_VAR 0 1
36251: PUSH
36252: LD_VAR 0 2
36256: AND
36257: PUSH
36258: LD_VAR 0 3
36262: AND
36263: PUSH
36264: LD_OWVAR 67
36268: PUSH
36269: LD_INT 3
36271: GREATEREQUAL
36272: AND
36273: IFFALSE 36285
// SetAchievementEX ( ACH_AMER , 15 ) ;
36275: LD_STRING ACH_AMER
36277: PPUSH
36278: LD_INT 15
36280: PPUSH
36281: CALL_OW 564
// GiveMedals ( MAIN ) ;
36285: LD_STRING MAIN
36287: PPUSH
36288: CALL_OW 102
// music_class := 4 ;
36292: LD_ADDR_OWVAR 72
36296: PUSH
36297: LD_INT 4
36299: ST_TO_ADDR
// music_nat := 1 ;
36300: LD_ADDR_OWVAR 71
36304: PUSH
36305: LD_INT 1
36307: ST_TO_ADDR
// YouWin ;
36308: CALL_OW 103
// end ; end_of_file
36312: PPOPN 3
36314: END
// export function CustomEvent ( event ) ; begin
36315: LD_INT 0
36317: PPUSH
// end ;
36318: LD_VAR 0 2
36322: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
36323: LD_VAR 0 1
36327: PUSH
36328: LD_INT 1
36330: EQUAL
36331: PUSH
36332: LD_VAR 0 2
36336: PUSH
36337: LD_INT 4
36339: EQUAL
36340: AND
36341: PUSH
36342: LD_EXP 60
36346: PPUSH
36347: CALL_OW 300
36351: AND
36352: IFFALSE 36368
// begin wait ( 0 0$2 ) ;
36354: LD_INT 70
36356: PPUSH
36357: CALL_OW 67
// YouLost ( Dismissed ) ;
36361: LD_STRING Dismissed
36363: PPUSH
36364: CALL_OW 104
// end ; end ;
36368: PPOPN 2
36370: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
36371: LD_VAR 0 2
36375: PPUSH
36376: LD_VAR 0 3
36380: PPUSH
36381: LD_INT 18
36383: PPUSH
36384: CALL_OW 309
36388: IFFALSE 36397
// YouLost ( Motherlode3 ) ;
36390: LD_STRING Motherlode3
36392: PPUSH
36393: CALL_OW 104
// end ;
36397: PPOPN 3
36399: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
36400: LD_EXP 27
36404: NOT
36405: IFFALSE 36415
// behemothDone := true ;
36407: LD_ADDR_EXP 28
36411: PUSH
36412: LD_INT 1
36414: ST_TO_ADDR
// end ;
36415: PPOPN 1
36417: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
36418: LD_VAR 0 1
36422: PPUSH
36423: CALL_OW 255
36427: PUSH
36428: LD_INT 1
36430: EQUAL
36431: IFFALSE 36441
// bombExploded := true ;
36433: LD_ADDR_EXP 37
36437: PUSH
36438: LD_INT 1
36440: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
36441: LD_VAR 0 1
36445: PPUSH
36446: CALL_OW 255
36450: PUSH
36451: LD_INT 3
36453: EQUAL
36454: IFFALSE 36484
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
36456: LD_INT 2
36458: PPUSH
36459: LD_INT 23
36461: PUSH
36462: LD_INT 3
36464: PUSH
36465: LD_INT 3
36467: PUSH
36468: LD_INT 48
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: PUSH
36477: EMPTY
36478: LIST
36479: PPUSH
36480: CALL 62369 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
36484: LD_VAR 0 1
36488: PPUSH
36489: CALL_OW 255
36493: PUSH
36494: LD_INT 1
36496: EQUAL
36497: PUSH
36498: LD_EXP 64
36502: PPUSH
36503: CALL_OW 255
36507: PUSH
36508: LD_INT 1
36510: EQUAL
36511: AND
36512: PUSH
36513: LD_EXP 64
36517: PPUSH
36518: CALL_OW 302
36522: AND
36523: PUSH
36524: LD_EXP 30
36528: AND
36529: PUSH
36530: LD_INT 22
36532: PUSH
36533: LD_INT 3
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 34
36542: PUSH
36543: LD_INT 48
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PPUSH
36554: CALL_OW 69
36558: AND
36559: PUSH
36560: LD_INT 22
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 34
36572: PUSH
36573: LD_INT 8
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PPUSH
36584: CALL_OW 69
36588: NOT
36589: AND
36590: IFFALSE 36642
// begin wait ( 0 0$5 ) ;
36592: LD_INT 175
36594: PPUSH
36595: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
36599: LD_INT 22
36601: PUSH
36602: LD_INT 3
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 34
36611: PUSH
36612: LD_INT 48
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PPUSH
36623: CALL_OW 69
36627: PUSH
36628: LD_INT 1
36630: ARRAY
36631: PPUSH
36632: LD_INT 60
36634: PPUSH
36635: LD_INT 95
36637: PPUSH
36638: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
36642: LD_VAR 0 2
36646: PPUSH
36647: LD_VAR 0 3
36651: PPUSH
36652: LD_INT 18
36654: PPUSH
36655: CALL_OW 309
36659: PUSH
36660: LD_VAR 0 2
36664: PPUSH
36665: LD_VAR 0 3
36669: PPUSH
36670: LD_INT 18
36672: PPUSH
36673: CALL 109896 0 3
36677: OR
36678: IFFALSE 36725
// begin if GetSide ( unit ) = 1 then
36680: LD_VAR 0 1
36684: PPUSH
36685: CALL_OW 255
36689: PUSH
36690: LD_INT 1
36692: EQUAL
36693: IFFALSE 36711
// begin wait ( 0 0$6 ) ;
36695: LD_INT 210
36697: PPUSH
36698: CALL_OW 67
// YouLost ( Motherlode2 ) ;
36702: LD_STRING Motherlode2
36704: PPUSH
36705: CALL_OW 104
// end else
36709: GO 36725
// begin wait ( 0 0$6 ) ;
36711: LD_INT 210
36713: PPUSH
36714: CALL_OW 67
// YouLost ( Motherlode1 ) ;
36718: LD_STRING Motherlode1
36720: PPUSH
36721: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
36725: LD_VAR 0 1
36729: PPUSH
36730: CALL_OW 255
36734: PUSH
36735: LD_INT 3
36737: EQUAL
36738: IFFALSE 36759
// begin wait ( 0 0$5 ) ;
36740: LD_INT 175
36742: PPUSH
36743: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
36747: LD_EXP 66
36751: PPUSH
36752: LD_STRING D18-Pla-1
36754: PPUSH
36755: CALL_OW 94
// end ; end ;
36759: PPOPN 3
36761: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
36762: LD_VAR 0 1
36766: PPUSH
36767: CALL 125961 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
36771: LD_VAR 0 1
36775: PUSH
36776: LD_INT 22
36778: PUSH
36779: LD_INT 1
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 21
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 23
36798: PUSH
36799: LD_INT 1
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: LIST
36810: PPUSH
36811: CALL_OW 69
36815: IN
36816: IFFALSE 36832
// lostCounter := lostCounter + 1 ;
36818: LD_ADDR_EXP 32
36822: PUSH
36823: LD_EXP 32
36827: PUSH
36828: LD_INT 1
36830: PLUS
36831: ST_TO_ADDR
// if un in behemothBuilders then
36832: LD_VAR 0 1
36836: PUSH
36837: LD_EXP 75
36841: IN
36842: IFFALSE 36862
// begin behemothBuilders := behemothBuilders diff un ;
36844: LD_ADDR_EXP 75
36848: PUSH
36849: LD_EXP 75
36853: PUSH
36854: LD_VAR 0 1
36858: DIFF
36859: ST_TO_ADDR
// exit ;
36860: GO 36892
// end ; if un = JMM then
36862: LD_VAR 0 1
36866: PUSH
36867: LD_EXP 40
36871: EQUAL
36872: IFFALSE 36883
// begin YouLost ( JMM ) ;
36874: LD_STRING JMM
36876: PPUSH
36877: CALL_OW 104
// exit ;
36881: GO 36892
// end ; MCE_UnitDestroyed ( un ) ;
36883: LD_VAR 0 1
36887: PPUSH
36888: CALL 65811 0 1
// end ;
36892: PPOPN 1
36894: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
36895: LD_VAR 0 1
36899: PPUSH
36900: LD_VAR 0 2
36904: PPUSH
36905: CALL 68143 0 2
// end ;
36909: PPOPN 2
36911: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
36912: LD_VAR 0 1
36916: PPUSH
36917: CALL 67211 0 1
// end ;
36921: PPOPN 1
36923: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
36924: LD_VAR 0 1
36928: PUSH
36929: LD_INT 22
36931: PUSH
36932: LD_INT 8
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 30
36941: PUSH
36942: LD_INT 2
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 23
36951: PUSH
36952: LD_INT 3
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: LIST
36963: PPUSH
36964: CALL_OW 69
36968: IN
36969: IFFALSE 36996
// begin ComUpgrade ( building ) ;
36971: LD_VAR 0 1
36975: PPUSH
36976: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
36980: LD_EXP 63
36984: PPUSH
36985: LD_VAR 0 1
36989: PPUSH
36990: CALL 76618 0 2
// exit ;
36994: GO 37005
// end ; MCE_BuildingComplete ( building ) ;
36996: LD_VAR 0 1
37000: PPUSH
37001: CALL 67452 0 1
// end ;
37005: PPOPN 1
37007: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37008: LD_VAR 0 1
37012: PPUSH
37013: LD_VAR 0 2
37017: PPUSH
37018: CALL 65507 0 2
// end ;
37022: PPOPN 2
37024: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37025: LD_VAR 0 1
37029: PPUSH
37030: LD_VAR 0 2
37034: PPUSH
37035: LD_VAR 0 3
37039: PPUSH
37040: LD_VAR 0 4
37044: PPUSH
37045: LD_VAR 0 5
37049: PPUSH
37050: CALL 65127 0 5
// end ;
37054: PPOPN 5
37056: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37057: LD_VAR 0 1
37061: PPUSH
37062: CALL_OW 255
37066: PUSH
37067: LD_INT 1
37069: EQUAL
37070: IFFALSE 37087
// amConstructCounter := Inc ( amConstructCounter ) ;
37072: LD_ADDR_EXP 39
37076: PUSH
37077: LD_EXP 39
37081: PPUSH
37082: CALL 107448 0 1
37086: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37087: LD_VAR 0 1
37091: PPUSH
37092: LD_VAR 0 2
37096: PPUSH
37097: CALL 126081 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37101: LD_VAR 0 1
37105: PPUSH
37106: LD_VAR 0 2
37110: PPUSH
37111: CALL 64680 0 2
// end ;
37115: PPOPN 2
37117: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37118: LD_VAR 0 1
37122: PPUSH
37123: LD_VAR 0 2
37127: PPUSH
37128: LD_VAR 0 3
37132: PPUSH
37133: LD_VAR 0 4
37137: PPUSH
37138: CALL 64518 0 4
// end ;
37142: PPOPN 4
37144: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37145: LD_VAR 0 1
37149: PPUSH
37150: LD_VAR 0 2
37154: PPUSH
37155: LD_VAR 0 3
37159: PPUSH
37160: CALL 64293 0 3
// end ;
37164: PPOPN 3
37166: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37167: LD_VAR 0 1
37171: PPUSH
37172: LD_VAR 0 2
37176: PPUSH
37177: CALL 64178 0 2
// end ;
37181: PPOPN 2
37183: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37184: LD_VAR 0 1
37188: PPUSH
37189: LD_VAR 0 2
37193: PPUSH
37194: CALL 68438 0 2
// end ;
37198: PPOPN 2
37200: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37201: LD_VAR 0 1
37205: PUSH
37206: LD_INT 460
37208: EQUAL
37209: IFFALSE 37231
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37211: LD_VAR 0 2
37215: PPUSH
37216: LD_INT 227
37218: PPUSH
37219: LD_INT 136
37221: PPUSH
37222: CALL_OW 428
37226: PPUSH
37227: CALL_OW 120
// end ;
37231: PPOPN 2
37233: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37234: LD_VAR 0 1
37238: PPUSH
37239: CALL_OW 255
37243: PUSH
37244: LD_INT 4
37246: EQUAL
37247: PUSH
37248: LD_VAR 0 1
37252: PUSH
37253: LD_EXP 18
37257: PUSH
37258: LD_INT 1
37260: ARRAY
37261: IN
37262: AND
37263: PUSH
37264: LD_EXP 19
37268: AND
37269: IFFALSE 37288
// begin ComMoveXY ( driver , 61 , 93 ) ;
37271: LD_VAR 0 1
37275: PPUSH
37276: LD_INT 61
37278: PPUSH
37279: LD_INT 93
37281: PPUSH
37282: CALL_OW 111
// exit ;
37286: GO 37357
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
37288: LD_VAR 0 1
37292: PPUSH
37293: CALL_OW 255
37297: PUSH
37298: LD_INT 3
37300: EQUAL
37301: PUSH
37302: LD_VAR 0 1
37306: PPUSH
37307: CALL_OW 110
37311: PUSH
37312: LD_INT 105
37314: EQUAL
37315: AND
37316: IFFALSE 37333
// begin ComMoveXY ( driver , 187 , 92 ) ;
37318: LD_VAR 0 1
37322: PPUSH
37323: LD_INT 187
37325: PPUSH
37326: LD_INT 92
37328: PPUSH
37329: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
37333: LD_VAR 0 1
37337: PPUSH
37338: LD_VAR 0 2
37342: PPUSH
37343: LD_VAR 0 3
37347: PPUSH
37348: LD_VAR 0 4
37352: PPUSH
37353: CALL 68654 0 4
// end ;
37357: PPOPN 4
37359: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
37360: LD_VAR 0 1
37364: PPUSH
37365: LD_VAR 0 2
37369: PPUSH
37370: CALL 63987 0 2
// end ;
37374: PPOPN 2
37376: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
37377: LD_VAR 0 1
37381: PPUSH
37382: CALL 126065 0 1
// end ; end_of_file
37386: PPOPN 1
37388: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
37389: LD_EXP 15
37393: PUSH
37394: LD_INT 2
37396: EQUAL
37397: IFFALSE 37914
37399: GO 37401
37401: DISABLE
37402: LD_INT 0
37404: PPUSH
37405: PPUSH
// begin time := 0 0$35 ;
37406: LD_ADDR_VAR 0 2
37410: PUSH
37411: LD_INT 1225
37413: ST_TO_ADDR
// repeat wait ( time ) ;
37414: LD_VAR 0 2
37418: PPUSH
37419: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
37423: LD_INT 1
37425: PPUSH
37426: LD_INT 5
37428: PPUSH
37429: CALL_OW 12
37433: PPUSH
37434: LD_INT 106
37436: PPUSH
37437: LD_INT 150
37439: PPUSH
37440: LD_INT 19
37442: PPUSH
37443: LD_INT 1
37445: PPUSH
37446: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
37450: LD_INT 455
37452: PPUSH
37453: LD_INT 770
37455: PPUSH
37456: CALL_OW 12
37460: PPUSH
37461: CALL_OW 67
// if Prob ( 50 ) then
37465: LD_INT 50
37467: PPUSH
37468: CALL_OW 13
37472: IFFALSE 37501
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
37474: LD_INT 1
37476: PPUSH
37477: LD_INT 5
37479: PPUSH
37480: CALL_OW 12
37484: PPUSH
37485: LD_INT 62
37487: PPUSH
37488: LD_INT 108
37490: PPUSH
37491: LD_INT 10
37493: PPUSH
37494: LD_INT 1
37496: PPUSH
37497: CALL_OW 56
// until missionStage > 4 ;
37501: LD_EXP 15
37505: PUSH
37506: LD_INT 4
37508: GREATER
37509: IFFALSE 37414
// repeat wait ( 0 0$1 ) ;
37511: LD_INT 35
37513: PPUSH
37514: CALL_OW 67
// until missionStage = 6 ;
37518: LD_EXP 15
37522: PUSH
37523: LD_INT 6
37525: EQUAL
37526: IFFALSE 37511
// time := 0 0$20 ;
37528: LD_ADDR_VAR 0 2
37532: PUSH
37533: LD_INT 700
37535: ST_TO_ADDR
// repeat wait ( time ) ;
37536: LD_VAR 0 2
37540: PPUSH
37541: CALL_OW 67
// if Prob ( 90 ) then
37545: LD_INT 90
37547: PPUSH
37548: CALL_OW 13
37552: IFFALSE 37595
// begin time := time + 0 0$2 ;
37554: LD_ADDR_VAR 0 2
37558: PUSH
37559: LD_VAR 0 2
37563: PUSH
37564: LD_INT 70
37566: PLUS
37567: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
37568: LD_INT 1
37570: PPUSH
37571: LD_INT 5
37573: PPUSH
37574: CALL_OW 12
37578: PPUSH
37579: LD_INT 106
37581: PPUSH
37582: LD_INT 89
37584: PPUSH
37585: LD_INT 45
37587: PPUSH
37588: LD_INT 1
37590: PPUSH
37591: CALL_OW 56
// end ; if Prob ( 45 ) then
37595: LD_INT 45
37597: PPUSH
37598: CALL_OW 13
37602: IFFALSE 37658
// begin for i := 1 to 4 do
37604: LD_ADDR_VAR 0 1
37608: PUSH
37609: DOUBLE
37610: LD_INT 1
37612: DEC
37613: ST_TO_ADDR
37614: LD_INT 4
37616: PUSH
37617: FOR_TO
37618: IFFALSE 37656
// begin wait ( 0 0$5 ) ;
37620: LD_INT 175
37622: PPUSH
37623: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
37627: LD_INT 1
37629: PPUSH
37630: LD_INT 5
37632: PPUSH
37633: CALL_OW 12
37637: PPUSH
37638: LD_INT 113
37640: PPUSH
37641: LD_INT 117
37643: PPUSH
37644: LD_INT 25
37646: PPUSH
37647: LD_INT 1
37649: PPUSH
37650: CALL_OW 56
// end ;
37654: GO 37617
37656: POP
37657: POP
// end ; if Prob ( 40 ) then
37658: LD_INT 40
37660: PPUSH
37661: CALL_OW 13
37665: IFFALSE 37711
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
37667: LD_INT 385
37669: PPUSH
37670: LD_INT 945
37672: PPUSH
37673: CALL_OW 12
37677: PPUSH
37678: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
37682: LD_INT 1
37684: PPUSH
37685: LD_INT 5
37687: PPUSH
37688: CALL_OW 12
37692: PPUSH
37693: LD_INT 21
37695: PPUSH
37696: LD_INT 26
37698: PPUSH
37699: LD_INT 12
37701: PPUSH
37702: LD_INT 1
37704: PPUSH
37705: CALL_OW 56
// end else
37709: GO 37747
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
37711: LD_INT 700
37713: PPUSH
37714: LD_INT 1225
37716: PPUSH
37717: CALL_OW 12
37721: PPUSH
37722: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
37726: LD_INT 1
37728: PPUSH
37729: LD_INT 5
37731: PPUSH
37732: CALL_OW 12
37736: PPUSH
37737: LD_INT 16
37739: PPUSH
37740: LD_INT 1
37742: PPUSH
37743: CALL_OW 55
// end ; if Prob ( 50 ) then
37747: LD_INT 50
37749: PPUSH
37750: CALL_OW 13
37754: IFFALSE 37800
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
37756: LD_INT 700
37758: PPUSH
37759: LD_INT 1050
37761: PPUSH
37762: CALL_OW 12
37766: PPUSH
37767: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
37771: LD_INT 1
37773: PPUSH
37774: LD_INT 5
37776: PPUSH
37777: CALL_OW 12
37781: PPUSH
37782: LD_INT 168
37784: PPUSH
37785: LD_INT 168
37787: PPUSH
37788: LD_INT 16
37790: PPUSH
37791: LD_INT 1
37793: PPUSH
37794: CALL_OW 56
// end else
37798: GO 37836
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
37800: LD_INT 350
37802: PPUSH
37803: LD_INT 525
37805: PPUSH
37806: CALL_OW 12
37810: PPUSH
37811: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
37815: LD_INT 1
37817: PPUSH
37818: LD_INT 5
37820: PPUSH
37821: CALL_OW 12
37825: PPUSH
37826: LD_INT 15
37828: PPUSH
37829: LD_INT 1
37831: PPUSH
37832: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
37836: LD_INT 175
37838: PPUSH
37839: LD_INT 315
37841: PPUSH
37842: CALL_OW 12
37846: PPUSH
37847: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
37851: LD_INT 1
37853: PPUSH
37854: LD_INT 5
37856: PPUSH
37857: CALL_OW 12
37861: PPUSH
37862: LD_INT 103
37864: PPUSH
37865: LD_INT 140
37867: PPUSH
37868: LD_INT 20
37870: PPUSH
37871: LD_INT 1
37873: PPUSH
37874: CALL_OW 56
// time := time + 0 0$2 ;
37878: LD_ADDR_VAR 0 2
37882: PUSH
37883: LD_VAR 0 2
37887: PUSH
37888: LD_INT 70
37890: PLUS
37891: ST_TO_ADDR
// if time > 1 1$20 then
37892: LD_VAR 0 2
37896: PUSH
37897: LD_INT 2800
37899: GREATER
37900: IFFALSE 37910
// time := 0 0$30 ;
37902: LD_ADDR_VAR 0 2
37906: PUSH
37907: LD_INT 1050
37909: ST_TO_ADDR
// until false ;
37910: LD_INT 0
37912: IFFALSE 37536
// end ; end_of_file
37914: PPOPN 2
37916: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
37917: LD_EXP 13
37921: PUSH
37922: LD_EXP 15
37926: PUSH
37927: LD_INT 6
37929: GREATEREQUAL
37930: AND
37931: IFFALSE 37968
37933: GO 37935
37935: DISABLE
// begin enable ;
37936: ENABLE
// missionTime := missionTime + 0 0$1 ;
37937: LD_ADDR_EXP 14
37941: PUSH
37942: LD_EXP 14
37946: PUSH
37947: LD_INT 35
37949: PLUS
37950: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
37951: LD_ADDR_OWVAR 47
37955: PUSH
37956: LD_STRING #Am15-1
37958: PUSH
37959: LD_EXP 14
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: ST_TO_ADDR
// end ; end_of_file
37968: END
// export function InitNature ; begin
37969: LD_INT 0
37971: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
37972: LD_INT 3
37974: PPUSH
37975: LD_INT 3
37977: PPUSH
37978: LD_INT 2
37980: PPUSH
37981: LD_INT 1
37983: PPUSH
37984: LD_INT 1
37986: PPUSH
37987: LD_INT 0
37989: PPUSH
37990: LD_INT 0
37992: PPUSH
37993: LD_INT 20
37995: PPUSH
37996: LD_INT 0
37998: PPUSH
37999: CALL 102777 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38003: LD_INT 2
38005: PPUSH
38006: LD_INT 1
38008: PPUSH
38009: LD_INT 1
38011: PPUSH
38012: LD_INT 1
38014: PPUSH
38015: LD_INT 1
38017: PPUSH
38018: LD_INT 0
38020: PPUSH
38021: LD_INT 0
38023: PPUSH
38024: LD_INT 21
38026: PPUSH
38027: LD_INT 0
38029: PPUSH
38030: CALL 102777 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38034: LD_INT 4
38036: PPUSH
38037: LD_INT 1
38039: PPUSH
38040: LD_INT 2
38042: PPUSH
38043: LD_INT 4
38045: PPUSH
38046: LD_INT 2
38048: PPUSH
38049: LD_INT 1
38051: PPUSH
38052: LD_INT 0
38054: PPUSH
38055: LD_INT 22
38057: PPUSH
38058: LD_INT 0
38060: PPUSH
38061: CALL 102777 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38065: LD_INT 0
38067: PPUSH
38068: LD_INT 0
38070: PPUSH
38071: LD_INT 0
38073: PPUSH
38074: LD_INT 0
38076: PPUSH
38077: LD_INT 0
38079: PPUSH
38080: LD_INT 0
38082: PPUSH
38083: LD_INT 9
38085: PPUSH
38086: LD_INT 0
38088: PPUSH
38089: LD_INT 23
38091: PPUSH
38092: CALL 102777 0 9
// end ; end_of_file
38096: LD_VAR 0 1
38100: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38101: LD_INT 0
38103: PPUSH
38104: PPUSH
// skirmish := false ;
38105: LD_ADDR_EXP 98
38109: PUSH
38110: LD_INT 0
38112: ST_TO_ADDR
// debug_mc := false ;
38113: LD_ADDR_EXP 99
38117: PUSH
38118: LD_INT 0
38120: ST_TO_ADDR
// mc_bases := [ ] ;
38121: LD_ADDR_EXP 100
38125: PUSH
38126: EMPTY
38127: ST_TO_ADDR
// mc_sides := [ ] ;
38128: LD_ADDR_EXP 126
38132: PUSH
38133: EMPTY
38134: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38135: LD_ADDR_EXP 101
38139: PUSH
38140: EMPTY
38141: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38142: LD_ADDR_EXP 102
38146: PUSH
38147: EMPTY
38148: ST_TO_ADDR
// mc_need_heal := [ ] ;
38149: LD_ADDR_EXP 103
38153: PUSH
38154: EMPTY
38155: ST_TO_ADDR
// mc_healers := [ ] ;
38156: LD_ADDR_EXP 104
38160: PUSH
38161: EMPTY
38162: ST_TO_ADDR
// mc_build_list := [ ] ;
38163: LD_ADDR_EXP 105
38167: PUSH
38168: EMPTY
38169: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38170: LD_ADDR_EXP 132
38174: PUSH
38175: EMPTY
38176: ST_TO_ADDR
// mc_builders := [ ] ;
38177: LD_ADDR_EXP 106
38181: PUSH
38182: EMPTY
38183: ST_TO_ADDR
// mc_construct_list := [ ] ;
38184: LD_ADDR_EXP 107
38188: PUSH
38189: EMPTY
38190: ST_TO_ADDR
// mc_turret_list := [ ] ;
38191: LD_ADDR_EXP 108
38195: PUSH
38196: EMPTY
38197: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38198: LD_ADDR_EXP 109
38202: PUSH
38203: EMPTY
38204: ST_TO_ADDR
// mc_miners := [ ] ;
38205: LD_ADDR_EXP 114
38209: PUSH
38210: EMPTY
38211: ST_TO_ADDR
// mc_mines := [ ] ;
38212: LD_ADDR_EXP 113
38216: PUSH
38217: EMPTY
38218: ST_TO_ADDR
// mc_minefields := [ ] ;
38219: LD_ADDR_EXP 115
38223: PUSH
38224: EMPTY
38225: ST_TO_ADDR
// mc_crates := [ ] ;
38226: LD_ADDR_EXP 116
38230: PUSH
38231: EMPTY
38232: ST_TO_ADDR
// mc_crates_collector := [ ] ;
38233: LD_ADDR_EXP 117
38237: PUSH
38238: EMPTY
38239: ST_TO_ADDR
// mc_crates_area := [ ] ;
38240: LD_ADDR_EXP 118
38244: PUSH
38245: EMPTY
38246: ST_TO_ADDR
// mc_vehicles := [ ] ;
38247: LD_ADDR_EXP 119
38251: PUSH
38252: EMPTY
38253: ST_TO_ADDR
// mc_attack := [ ] ;
38254: LD_ADDR_EXP 120
38258: PUSH
38259: EMPTY
38260: ST_TO_ADDR
// mc_produce := [ ] ;
38261: LD_ADDR_EXP 121
38265: PUSH
38266: EMPTY
38267: ST_TO_ADDR
// mc_defender := [ ] ;
38268: LD_ADDR_EXP 122
38272: PUSH
38273: EMPTY
38274: ST_TO_ADDR
// mc_parking := [ ] ;
38275: LD_ADDR_EXP 124
38279: PUSH
38280: EMPTY
38281: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
38282: LD_ADDR_EXP 110
38286: PUSH
38287: EMPTY
38288: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
38289: LD_ADDR_EXP 112
38293: PUSH
38294: EMPTY
38295: ST_TO_ADDR
// mc_scan := [ ] ;
38296: LD_ADDR_EXP 123
38300: PUSH
38301: EMPTY
38302: ST_TO_ADDR
// mc_scan_area := [ ] ;
38303: LD_ADDR_EXP 125
38307: PUSH
38308: EMPTY
38309: ST_TO_ADDR
// mc_tech := [ ] ;
38310: LD_ADDR_EXP 127
38314: PUSH
38315: EMPTY
38316: ST_TO_ADDR
// mc_class := [ ] ;
38317: LD_ADDR_EXP 141
38321: PUSH
38322: EMPTY
38323: ST_TO_ADDR
// mc_class_case_use := [ ] ;
38324: LD_ADDR_EXP 142
38328: PUSH
38329: EMPTY
38330: ST_TO_ADDR
// mc_is_defending := [ ] ;
38331: LD_ADDR_EXP 143
38335: PUSH
38336: EMPTY
38337: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
38338: LD_ADDR_EXP 134
38342: PUSH
38343: EMPTY
38344: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
38345: LD_ADDR_EXP 144
38349: PUSH
38350: LD_INT 0
38352: ST_TO_ADDR
// end ;
38353: LD_VAR 0 1
38357: RET
// export function MC_Kill ( base ) ; begin
38358: LD_INT 0
38360: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
38361: LD_ADDR_EXP 100
38365: PUSH
38366: LD_EXP 100
38370: PPUSH
38371: LD_VAR 0 1
38375: PPUSH
38376: EMPTY
38377: PPUSH
38378: CALL_OW 1
38382: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38383: LD_ADDR_EXP 101
38387: PUSH
38388: LD_EXP 101
38392: PPUSH
38393: LD_VAR 0 1
38397: PPUSH
38398: EMPTY
38399: PPUSH
38400: CALL_OW 1
38404: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38405: LD_ADDR_EXP 102
38409: PUSH
38410: LD_EXP 102
38414: PPUSH
38415: LD_VAR 0 1
38419: PPUSH
38420: EMPTY
38421: PPUSH
38422: CALL_OW 1
38426: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38427: LD_ADDR_EXP 103
38431: PUSH
38432: LD_EXP 103
38436: PPUSH
38437: LD_VAR 0 1
38441: PPUSH
38442: EMPTY
38443: PPUSH
38444: CALL_OW 1
38448: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38449: LD_ADDR_EXP 104
38453: PUSH
38454: LD_EXP 104
38458: PPUSH
38459: LD_VAR 0 1
38463: PPUSH
38464: EMPTY
38465: PPUSH
38466: CALL_OW 1
38470: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38471: LD_ADDR_EXP 105
38475: PUSH
38476: LD_EXP 105
38480: PPUSH
38481: LD_VAR 0 1
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL_OW 1
38492: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38493: LD_ADDR_EXP 106
38497: PUSH
38498: LD_EXP 106
38502: PPUSH
38503: LD_VAR 0 1
38507: PPUSH
38508: EMPTY
38509: PPUSH
38510: CALL_OW 1
38514: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38515: LD_ADDR_EXP 107
38519: PUSH
38520: LD_EXP 107
38524: PPUSH
38525: LD_VAR 0 1
38529: PPUSH
38530: EMPTY
38531: PPUSH
38532: CALL_OW 1
38536: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38537: LD_ADDR_EXP 108
38541: PUSH
38542: LD_EXP 108
38546: PPUSH
38547: LD_VAR 0 1
38551: PPUSH
38552: EMPTY
38553: PPUSH
38554: CALL_OW 1
38558: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38559: LD_ADDR_EXP 109
38563: PUSH
38564: LD_EXP 109
38568: PPUSH
38569: LD_VAR 0 1
38573: PPUSH
38574: EMPTY
38575: PPUSH
38576: CALL_OW 1
38580: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38581: LD_ADDR_EXP 110
38585: PUSH
38586: LD_EXP 110
38590: PPUSH
38591: LD_VAR 0 1
38595: PPUSH
38596: EMPTY
38597: PPUSH
38598: CALL_OW 1
38602: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38603: LD_ADDR_EXP 111
38607: PUSH
38608: LD_EXP 111
38612: PPUSH
38613: LD_VAR 0 1
38617: PPUSH
38618: LD_INT 0
38620: PPUSH
38621: CALL_OW 1
38625: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38626: LD_ADDR_EXP 112
38630: PUSH
38631: LD_EXP 112
38635: PPUSH
38636: LD_VAR 0 1
38640: PPUSH
38641: EMPTY
38642: PPUSH
38643: CALL_OW 1
38647: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38648: LD_ADDR_EXP 113
38652: PUSH
38653: LD_EXP 113
38657: PPUSH
38658: LD_VAR 0 1
38662: PPUSH
38663: EMPTY
38664: PPUSH
38665: CALL_OW 1
38669: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38670: LD_ADDR_EXP 114
38674: PUSH
38675: LD_EXP 114
38679: PPUSH
38680: LD_VAR 0 1
38684: PPUSH
38685: EMPTY
38686: PPUSH
38687: CALL_OW 1
38691: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38692: LD_ADDR_EXP 115
38696: PUSH
38697: LD_EXP 115
38701: PPUSH
38702: LD_VAR 0 1
38706: PPUSH
38707: EMPTY
38708: PPUSH
38709: CALL_OW 1
38713: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38714: LD_ADDR_EXP 116
38718: PUSH
38719: LD_EXP 116
38723: PPUSH
38724: LD_VAR 0 1
38728: PPUSH
38729: EMPTY
38730: PPUSH
38731: CALL_OW 1
38735: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38736: LD_ADDR_EXP 117
38740: PUSH
38741: LD_EXP 117
38745: PPUSH
38746: LD_VAR 0 1
38750: PPUSH
38751: EMPTY
38752: PPUSH
38753: CALL_OW 1
38757: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38758: LD_ADDR_EXP 118
38762: PUSH
38763: LD_EXP 118
38767: PPUSH
38768: LD_VAR 0 1
38772: PPUSH
38773: EMPTY
38774: PPUSH
38775: CALL_OW 1
38779: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38780: LD_ADDR_EXP 119
38784: PUSH
38785: LD_EXP 119
38789: PPUSH
38790: LD_VAR 0 1
38794: PPUSH
38795: EMPTY
38796: PPUSH
38797: CALL_OW 1
38801: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38802: LD_ADDR_EXP 120
38806: PUSH
38807: LD_EXP 120
38811: PPUSH
38812: LD_VAR 0 1
38816: PPUSH
38817: EMPTY
38818: PPUSH
38819: CALL_OW 1
38823: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38824: LD_ADDR_EXP 121
38828: PUSH
38829: LD_EXP 121
38833: PPUSH
38834: LD_VAR 0 1
38838: PPUSH
38839: EMPTY
38840: PPUSH
38841: CALL_OW 1
38845: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38846: LD_ADDR_EXP 122
38850: PUSH
38851: LD_EXP 122
38855: PPUSH
38856: LD_VAR 0 1
38860: PPUSH
38861: EMPTY
38862: PPUSH
38863: CALL_OW 1
38867: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38868: LD_ADDR_EXP 123
38872: PUSH
38873: LD_EXP 123
38877: PPUSH
38878: LD_VAR 0 1
38882: PPUSH
38883: EMPTY
38884: PPUSH
38885: CALL_OW 1
38889: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38890: LD_ADDR_EXP 124
38894: PUSH
38895: LD_EXP 124
38899: PPUSH
38900: LD_VAR 0 1
38904: PPUSH
38905: EMPTY
38906: PPUSH
38907: CALL_OW 1
38911: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38912: LD_ADDR_EXP 125
38916: PUSH
38917: LD_EXP 125
38921: PPUSH
38922: LD_VAR 0 1
38926: PPUSH
38927: EMPTY
38928: PPUSH
38929: CALL_OW 1
38933: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38934: LD_ADDR_EXP 127
38938: PUSH
38939: LD_EXP 127
38943: PPUSH
38944: LD_VAR 0 1
38948: PPUSH
38949: EMPTY
38950: PPUSH
38951: CALL_OW 1
38955: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38956: LD_ADDR_EXP 129
38960: PUSH
38961: LD_EXP 129
38965: PPUSH
38966: LD_VAR 0 1
38970: PPUSH
38971: EMPTY
38972: PPUSH
38973: CALL_OW 1
38977: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38978: LD_ADDR_EXP 130
38982: PUSH
38983: LD_EXP 130
38987: PPUSH
38988: LD_VAR 0 1
38992: PPUSH
38993: EMPTY
38994: PPUSH
38995: CALL_OW 1
38999: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39000: LD_ADDR_EXP 131
39004: PUSH
39005: LD_EXP 131
39009: PPUSH
39010: LD_VAR 0 1
39014: PPUSH
39015: EMPTY
39016: PPUSH
39017: CALL_OW 1
39021: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39022: LD_ADDR_EXP 132
39026: PUSH
39027: LD_EXP 132
39031: PPUSH
39032: LD_VAR 0 1
39036: PPUSH
39037: EMPTY
39038: PPUSH
39039: CALL_OW 1
39043: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39044: LD_ADDR_EXP 133
39048: PUSH
39049: LD_EXP 133
39053: PPUSH
39054: LD_VAR 0 1
39058: PPUSH
39059: EMPTY
39060: PPUSH
39061: CALL_OW 1
39065: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39066: LD_ADDR_EXP 134
39070: PUSH
39071: LD_EXP 134
39075: PPUSH
39076: LD_VAR 0 1
39080: PPUSH
39081: EMPTY
39082: PPUSH
39083: CALL_OW 1
39087: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39088: LD_ADDR_EXP 135
39092: PUSH
39093: LD_EXP 135
39097: PPUSH
39098: LD_VAR 0 1
39102: PPUSH
39103: EMPTY
39104: PPUSH
39105: CALL_OW 1
39109: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39110: LD_ADDR_EXP 136
39114: PUSH
39115: LD_EXP 136
39119: PPUSH
39120: LD_VAR 0 1
39124: PPUSH
39125: EMPTY
39126: PPUSH
39127: CALL_OW 1
39131: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39132: LD_ADDR_EXP 137
39136: PUSH
39137: LD_EXP 137
39141: PPUSH
39142: LD_VAR 0 1
39146: PPUSH
39147: EMPTY
39148: PPUSH
39149: CALL_OW 1
39153: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39154: LD_ADDR_EXP 138
39158: PUSH
39159: LD_EXP 138
39163: PPUSH
39164: LD_VAR 0 1
39168: PPUSH
39169: EMPTY
39170: PPUSH
39171: CALL_OW 1
39175: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39176: LD_ADDR_EXP 139
39180: PUSH
39181: LD_EXP 139
39185: PPUSH
39186: LD_VAR 0 1
39190: PPUSH
39191: EMPTY
39192: PPUSH
39193: CALL_OW 1
39197: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39198: LD_ADDR_EXP 140
39202: PUSH
39203: LD_EXP 140
39207: PPUSH
39208: LD_VAR 0 1
39212: PPUSH
39213: EMPTY
39214: PPUSH
39215: CALL_OW 1
39219: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39220: LD_ADDR_EXP 141
39224: PUSH
39225: LD_EXP 141
39229: PPUSH
39230: LD_VAR 0 1
39234: PPUSH
39235: EMPTY
39236: PPUSH
39237: CALL_OW 1
39241: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39242: LD_ADDR_EXP 142
39246: PUSH
39247: LD_EXP 142
39251: PPUSH
39252: LD_VAR 0 1
39256: PPUSH
39257: LD_INT 0
39259: PPUSH
39260: CALL_OW 1
39264: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39265: LD_ADDR_EXP 143
39269: PUSH
39270: LD_EXP 143
39274: PPUSH
39275: LD_VAR 0 1
39279: PPUSH
39280: LD_INT 0
39282: PPUSH
39283: CALL_OW 1
39287: ST_TO_ADDR
// end ;
39288: LD_VAR 0 2
39292: RET
// export function MC_Add ( side , units ) ; var base ; begin
39293: LD_INT 0
39295: PPUSH
39296: PPUSH
// base := mc_bases + 1 ;
39297: LD_ADDR_VAR 0 4
39301: PUSH
39302: LD_EXP 100
39306: PUSH
39307: LD_INT 1
39309: PLUS
39310: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
39311: LD_ADDR_EXP 126
39315: PUSH
39316: LD_EXP 126
39320: PPUSH
39321: LD_VAR 0 4
39325: PPUSH
39326: LD_VAR 0 1
39330: PPUSH
39331: CALL_OW 1
39335: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
39336: LD_ADDR_EXP 100
39340: PUSH
39341: LD_EXP 100
39345: PPUSH
39346: LD_VAR 0 4
39350: PPUSH
39351: LD_VAR 0 2
39355: PPUSH
39356: CALL_OW 1
39360: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39361: LD_ADDR_EXP 101
39365: PUSH
39366: LD_EXP 101
39370: PPUSH
39371: LD_VAR 0 4
39375: PPUSH
39376: EMPTY
39377: PPUSH
39378: CALL_OW 1
39382: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39383: LD_ADDR_EXP 102
39387: PUSH
39388: LD_EXP 102
39392: PPUSH
39393: LD_VAR 0 4
39397: PPUSH
39398: EMPTY
39399: PPUSH
39400: CALL_OW 1
39404: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39405: LD_ADDR_EXP 103
39409: PUSH
39410: LD_EXP 103
39414: PPUSH
39415: LD_VAR 0 4
39419: PPUSH
39420: EMPTY
39421: PPUSH
39422: CALL_OW 1
39426: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39427: LD_ADDR_EXP 104
39431: PUSH
39432: LD_EXP 104
39436: PPUSH
39437: LD_VAR 0 4
39441: PPUSH
39442: EMPTY
39443: PPUSH
39444: CALL_OW 1
39448: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39449: LD_ADDR_EXP 105
39453: PUSH
39454: LD_EXP 105
39458: PPUSH
39459: LD_VAR 0 4
39463: PPUSH
39464: EMPTY
39465: PPUSH
39466: CALL_OW 1
39470: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39471: LD_ADDR_EXP 106
39475: PUSH
39476: LD_EXP 106
39480: PPUSH
39481: LD_VAR 0 4
39485: PPUSH
39486: EMPTY
39487: PPUSH
39488: CALL_OW 1
39492: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39493: LD_ADDR_EXP 107
39497: PUSH
39498: LD_EXP 107
39502: PPUSH
39503: LD_VAR 0 4
39507: PPUSH
39508: EMPTY
39509: PPUSH
39510: CALL_OW 1
39514: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39515: LD_ADDR_EXP 108
39519: PUSH
39520: LD_EXP 108
39524: PPUSH
39525: LD_VAR 0 4
39529: PPUSH
39530: EMPTY
39531: PPUSH
39532: CALL_OW 1
39536: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39537: LD_ADDR_EXP 109
39541: PUSH
39542: LD_EXP 109
39546: PPUSH
39547: LD_VAR 0 4
39551: PPUSH
39552: EMPTY
39553: PPUSH
39554: CALL_OW 1
39558: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39559: LD_ADDR_EXP 110
39563: PUSH
39564: LD_EXP 110
39568: PPUSH
39569: LD_VAR 0 4
39573: PPUSH
39574: EMPTY
39575: PPUSH
39576: CALL_OW 1
39580: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39581: LD_ADDR_EXP 111
39585: PUSH
39586: LD_EXP 111
39590: PPUSH
39591: LD_VAR 0 4
39595: PPUSH
39596: LD_INT 0
39598: PPUSH
39599: CALL_OW 1
39603: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39604: LD_ADDR_EXP 112
39608: PUSH
39609: LD_EXP 112
39613: PPUSH
39614: LD_VAR 0 4
39618: PPUSH
39619: EMPTY
39620: PPUSH
39621: CALL_OW 1
39625: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39626: LD_ADDR_EXP 113
39630: PUSH
39631: LD_EXP 113
39635: PPUSH
39636: LD_VAR 0 4
39640: PPUSH
39641: EMPTY
39642: PPUSH
39643: CALL_OW 1
39647: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39648: LD_ADDR_EXP 114
39652: PUSH
39653: LD_EXP 114
39657: PPUSH
39658: LD_VAR 0 4
39662: PPUSH
39663: EMPTY
39664: PPUSH
39665: CALL_OW 1
39669: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39670: LD_ADDR_EXP 115
39674: PUSH
39675: LD_EXP 115
39679: PPUSH
39680: LD_VAR 0 4
39684: PPUSH
39685: EMPTY
39686: PPUSH
39687: CALL_OW 1
39691: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39692: LD_ADDR_EXP 116
39696: PUSH
39697: LD_EXP 116
39701: PPUSH
39702: LD_VAR 0 4
39706: PPUSH
39707: EMPTY
39708: PPUSH
39709: CALL_OW 1
39713: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39714: LD_ADDR_EXP 117
39718: PUSH
39719: LD_EXP 117
39723: PPUSH
39724: LD_VAR 0 4
39728: PPUSH
39729: EMPTY
39730: PPUSH
39731: CALL_OW 1
39735: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39736: LD_ADDR_EXP 118
39740: PUSH
39741: LD_EXP 118
39745: PPUSH
39746: LD_VAR 0 4
39750: PPUSH
39751: EMPTY
39752: PPUSH
39753: CALL_OW 1
39757: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39758: LD_ADDR_EXP 119
39762: PUSH
39763: LD_EXP 119
39767: PPUSH
39768: LD_VAR 0 4
39772: PPUSH
39773: EMPTY
39774: PPUSH
39775: CALL_OW 1
39779: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39780: LD_ADDR_EXP 120
39784: PUSH
39785: LD_EXP 120
39789: PPUSH
39790: LD_VAR 0 4
39794: PPUSH
39795: EMPTY
39796: PPUSH
39797: CALL_OW 1
39801: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39802: LD_ADDR_EXP 121
39806: PUSH
39807: LD_EXP 121
39811: PPUSH
39812: LD_VAR 0 4
39816: PPUSH
39817: EMPTY
39818: PPUSH
39819: CALL_OW 1
39823: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39824: LD_ADDR_EXP 122
39828: PUSH
39829: LD_EXP 122
39833: PPUSH
39834: LD_VAR 0 4
39838: PPUSH
39839: EMPTY
39840: PPUSH
39841: CALL_OW 1
39845: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39846: LD_ADDR_EXP 123
39850: PUSH
39851: LD_EXP 123
39855: PPUSH
39856: LD_VAR 0 4
39860: PPUSH
39861: EMPTY
39862: PPUSH
39863: CALL_OW 1
39867: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39868: LD_ADDR_EXP 124
39872: PUSH
39873: LD_EXP 124
39877: PPUSH
39878: LD_VAR 0 4
39882: PPUSH
39883: EMPTY
39884: PPUSH
39885: CALL_OW 1
39889: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39890: LD_ADDR_EXP 125
39894: PUSH
39895: LD_EXP 125
39899: PPUSH
39900: LD_VAR 0 4
39904: PPUSH
39905: EMPTY
39906: PPUSH
39907: CALL_OW 1
39911: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39912: LD_ADDR_EXP 127
39916: PUSH
39917: LD_EXP 127
39921: PPUSH
39922: LD_VAR 0 4
39926: PPUSH
39927: EMPTY
39928: PPUSH
39929: CALL_OW 1
39933: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39934: LD_ADDR_EXP 129
39938: PUSH
39939: LD_EXP 129
39943: PPUSH
39944: LD_VAR 0 4
39948: PPUSH
39949: EMPTY
39950: PPUSH
39951: CALL_OW 1
39955: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39956: LD_ADDR_EXP 130
39960: PUSH
39961: LD_EXP 130
39965: PPUSH
39966: LD_VAR 0 4
39970: PPUSH
39971: EMPTY
39972: PPUSH
39973: CALL_OW 1
39977: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39978: LD_ADDR_EXP 131
39982: PUSH
39983: LD_EXP 131
39987: PPUSH
39988: LD_VAR 0 4
39992: PPUSH
39993: EMPTY
39994: PPUSH
39995: CALL_OW 1
39999: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40000: LD_ADDR_EXP 132
40004: PUSH
40005: LD_EXP 132
40009: PPUSH
40010: LD_VAR 0 4
40014: PPUSH
40015: EMPTY
40016: PPUSH
40017: CALL_OW 1
40021: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40022: LD_ADDR_EXP 133
40026: PUSH
40027: LD_EXP 133
40031: PPUSH
40032: LD_VAR 0 4
40036: PPUSH
40037: EMPTY
40038: PPUSH
40039: CALL_OW 1
40043: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40044: LD_ADDR_EXP 134
40048: PUSH
40049: LD_EXP 134
40053: PPUSH
40054: LD_VAR 0 4
40058: PPUSH
40059: EMPTY
40060: PPUSH
40061: CALL_OW 1
40065: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40066: LD_ADDR_EXP 135
40070: PUSH
40071: LD_EXP 135
40075: PPUSH
40076: LD_VAR 0 4
40080: PPUSH
40081: EMPTY
40082: PPUSH
40083: CALL_OW 1
40087: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40088: LD_ADDR_EXP 136
40092: PUSH
40093: LD_EXP 136
40097: PPUSH
40098: LD_VAR 0 4
40102: PPUSH
40103: EMPTY
40104: PPUSH
40105: CALL_OW 1
40109: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40110: LD_ADDR_EXP 137
40114: PUSH
40115: LD_EXP 137
40119: PPUSH
40120: LD_VAR 0 4
40124: PPUSH
40125: EMPTY
40126: PPUSH
40127: CALL_OW 1
40131: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40132: LD_ADDR_EXP 138
40136: PUSH
40137: LD_EXP 138
40141: PPUSH
40142: LD_VAR 0 4
40146: PPUSH
40147: EMPTY
40148: PPUSH
40149: CALL_OW 1
40153: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40154: LD_ADDR_EXP 139
40158: PUSH
40159: LD_EXP 139
40163: PPUSH
40164: LD_VAR 0 4
40168: PPUSH
40169: EMPTY
40170: PPUSH
40171: CALL_OW 1
40175: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40176: LD_ADDR_EXP 140
40180: PUSH
40181: LD_EXP 140
40185: PPUSH
40186: LD_VAR 0 4
40190: PPUSH
40191: EMPTY
40192: PPUSH
40193: CALL_OW 1
40197: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40198: LD_ADDR_EXP 141
40202: PUSH
40203: LD_EXP 141
40207: PPUSH
40208: LD_VAR 0 4
40212: PPUSH
40213: EMPTY
40214: PPUSH
40215: CALL_OW 1
40219: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40220: LD_ADDR_EXP 142
40224: PUSH
40225: LD_EXP 142
40229: PPUSH
40230: LD_VAR 0 4
40234: PPUSH
40235: LD_INT 0
40237: PPUSH
40238: CALL_OW 1
40242: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40243: LD_ADDR_EXP 143
40247: PUSH
40248: LD_EXP 143
40252: PPUSH
40253: LD_VAR 0 4
40257: PPUSH
40258: LD_INT 0
40260: PPUSH
40261: CALL_OW 1
40265: ST_TO_ADDR
// result := base ;
40266: LD_ADDR_VAR 0 3
40270: PUSH
40271: LD_VAR 0 4
40275: ST_TO_ADDR
// end ;
40276: LD_VAR 0 3
40280: RET
// export function MC_Start ( ) ; var i ; begin
40281: LD_INT 0
40283: PPUSH
40284: PPUSH
// for i = 1 to mc_bases do
40285: LD_ADDR_VAR 0 2
40289: PUSH
40290: DOUBLE
40291: LD_INT 1
40293: DEC
40294: ST_TO_ADDR
40295: LD_EXP 100
40299: PUSH
40300: FOR_TO
40301: IFFALSE 41401
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
40303: LD_ADDR_EXP 100
40307: PUSH
40308: LD_EXP 100
40312: PPUSH
40313: LD_VAR 0 2
40317: PPUSH
40318: LD_EXP 100
40322: PUSH
40323: LD_VAR 0 2
40327: ARRAY
40328: PUSH
40329: LD_INT 0
40331: DIFF
40332: PPUSH
40333: CALL_OW 1
40337: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
40338: LD_ADDR_EXP 101
40342: PUSH
40343: LD_EXP 101
40347: PPUSH
40348: LD_VAR 0 2
40352: PPUSH
40353: EMPTY
40354: PPUSH
40355: CALL_OW 1
40359: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40360: LD_ADDR_EXP 102
40364: PUSH
40365: LD_EXP 102
40369: PPUSH
40370: LD_VAR 0 2
40374: PPUSH
40375: EMPTY
40376: PPUSH
40377: CALL_OW 1
40381: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
40382: LD_ADDR_EXP 103
40386: PUSH
40387: LD_EXP 103
40391: PPUSH
40392: LD_VAR 0 2
40396: PPUSH
40397: EMPTY
40398: PPUSH
40399: CALL_OW 1
40403: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
40404: LD_ADDR_EXP 104
40408: PUSH
40409: LD_EXP 104
40413: PPUSH
40414: LD_VAR 0 2
40418: PPUSH
40419: EMPTY
40420: PUSH
40421: EMPTY
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PPUSH
40427: CALL_OW 1
40431: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
40432: LD_ADDR_EXP 105
40436: PUSH
40437: LD_EXP 105
40441: PPUSH
40442: LD_VAR 0 2
40446: PPUSH
40447: EMPTY
40448: PPUSH
40449: CALL_OW 1
40453: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
40454: LD_ADDR_EXP 132
40458: PUSH
40459: LD_EXP 132
40463: PPUSH
40464: LD_VAR 0 2
40468: PPUSH
40469: EMPTY
40470: PPUSH
40471: CALL_OW 1
40475: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
40476: LD_ADDR_EXP 106
40480: PUSH
40481: LD_EXP 106
40485: PPUSH
40486: LD_VAR 0 2
40490: PPUSH
40491: EMPTY
40492: PPUSH
40493: CALL_OW 1
40497: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
40498: LD_ADDR_EXP 107
40502: PUSH
40503: LD_EXP 107
40507: PPUSH
40508: LD_VAR 0 2
40512: PPUSH
40513: EMPTY
40514: PPUSH
40515: CALL_OW 1
40519: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
40520: LD_ADDR_EXP 108
40524: PUSH
40525: LD_EXP 108
40529: PPUSH
40530: LD_VAR 0 2
40534: PPUSH
40535: LD_EXP 100
40539: PUSH
40540: LD_VAR 0 2
40544: ARRAY
40545: PPUSH
40546: LD_INT 2
40548: PUSH
40549: LD_INT 30
40551: PUSH
40552: LD_INT 32
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 30
40561: PUSH
40562: LD_INT 33
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: LIST
40573: PPUSH
40574: CALL_OW 72
40578: PPUSH
40579: CALL_OW 1
40583: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
40584: LD_ADDR_EXP 109
40588: PUSH
40589: LD_EXP 109
40593: PPUSH
40594: LD_VAR 0 2
40598: PPUSH
40599: LD_EXP 100
40603: PUSH
40604: LD_VAR 0 2
40608: ARRAY
40609: PPUSH
40610: LD_INT 2
40612: PUSH
40613: LD_INT 30
40615: PUSH
40616: LD_INT 32
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 30
40625: PUSH
40626: LD_INT 31
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 58
40640: PUSH
40641: EMPTY
40642: LIST
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PPUSH
40648: CALL_OW 72
40652: PPUSH
40653: CALL_OW 1
40657: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
40658: LD_ADDR_EXP 110
40662: PUSH
40663: LD_EXP 110
40667: PPUSH
40668: LD_VAR 0 2
40672: PPUSH
40673: EMPTY
40674: PPUSH
40675: CALL_OW 1
40679: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
40680: LD_ADDR_EXP 114
40684: PUSH
40685: LD_EXP 114
40689: PPUSH
40690: LD_VAR 0 2
40694: PPUSH
40695: EMPTY
40696: PPUSH
40697: CALL_OW 1
40701: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
40702: LD_ADDR_EXP 113
40706: PUSH
40707: LD_EXP 113
40711: PPUSH
40712: LD_VAR 0 2
40716: PPUSH
40717: EMPTY
40718: PPUSH
40719: CALL_OW 1
40723: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
40724: LD_ADDR_EXP 115
40728: PUSH
40729: LD_EXP 115
40733: PPUSH
40734: LD_VAR 0 2
40738: PPUSH
40739: EMPTY
40740: PPUSH
40741: CALL_OW 1
40745: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
40746: LD_ADDR_EXP 116
40750: PUSH
40751: LD_EXP 116
40755: PPUSH
40756: LD_VAR 0 2
40760: PPUSH
40761: EMPTY
40762: PPUSH
40763: CALL_OW 1
40767: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
40768: LD_ADDR_EXP 117
40772: PUSH
40773: LD_EXP 117
40777: PPUSH
40778: LD_VAR 0 2
40782: PPUSH
40783: EMPTY
40784: PPUSH
40785: CALL_OW 1
40789: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
40790: LD_ADDR_EXP 118
40794: PUSH
40795: LD_EXP 118
40799: PPUSH
40800: LD_VAR 0 2
40804: PPUSH
40805: EMPTY
40806: PPUSH
40807: CALL_OW 1
40811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
40812: LD_ADDR_EXP 119
40816: PUSH
40817: LD_EXP 119
40821: PPUSH
40822: LD_VAR 0 2
40826: PPUSH
40827: EMPTY
40828: PPUSH
40829: CALL_OW 1
40833: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
40834: LD_ADDR_EXP 120
40838: PUSH
40839: LD_EXP 120
40843: PPUSH
40844: LD_VAR 0 2
40848: PPUSH
40849: EMPTY
40850: PPUSH
40851: CALL_OW 1
40855: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
40856: LD_ADDR_EXP 121
40860: PUSH
40861: LD_EXP 121
40865: PPUSH
40866: LD_VAR 0 2
40870: PPUSH
40871: EMPTY
40872: PPUSH
40873: CALL_OW 1
40877: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40878: LD_ADDR_EXP 122
40882: PUSH
40883: LD_EXP 122
40887: PPUSH
40888: LD_VAR 0 2
40892: PPUSH
40893: EMPTY
40894: PPUSH
40895: CALL_OW 1
40899: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
40900: LD_ADDR_EXP 111
40904: PUSH
40905: LD_EXP 111
40909: PPUSH
40910: LD_VAR 0 2
40914: PPUSH
40915: LD_INT 0
40917: PPUSH
40918: CALL_OW 1
40922: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
40923: LD_ADDR_EXP 124
40927: PUSH
40928: LD_EXP 124
40932: PPUSH
40933: LD_VAR 0 2
40937: PPUSH
40938: LD_INT 0
40940: PPUSH
40941: CALL_OW 1
40945: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40946: LD_ADDR_EXP 112
40950: PUSH
40951: LD_EXP 112
40955: PPUSH
40956: LD_VAR 0 2
40960: PPUSH
40961: EMPTY
40962: PPUSH
40963: CALL_OW 1
40967: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
40968: LD_ADDR_EXP 123
40972: PUSH
40973: LD_EXP 123
40977: PPUSH
40978: LD_VAR 0 2
40982: PPUSH
40983: LD_INT 0
40985: PPUSH
40986: CALL_OW 1
40990: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
40991: LD_ADDR_EXP 125
40995: PUSH
40996: LD_EXP 125
41000: PPUSH
41001: LD_VAR 0 2
41005: PPUSH
41006: EMPTY
41007: PPUSH
41008: CALL_OW 1
41012: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41013: LD_ADDR_EXP 128
41017: PUSH
41018: LD_EXP 128
41022: PPUSH
41023: LD_VAR 0 2
41027: PPUSH
41028: LD_INT 0
41030: PPUSH
41031: CALL_OW 1
41035: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41036: LD_ADDR_EXP 129
41040: PUSH
41041: LD_EXP 129
41045: PPUSH
41046: LD_VAR 0 2
41050: PPUSH
41051: EMPTY
41052: PPUSH
41053: CALL_OW 1
41057: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41058: LD_ADDR_EXP 130
41062: PUSH
41063: LD_EXP 130
41067: PPUSH
41068: LD_VAR 0 2
41072: PPUSH
41073: EMPTY
41074: PPUSH
41075: CALL_OW 1
41079: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41080: LD_ADDR_EXP 131
41084: PUSH
41085: LD_EXP 131
41089: PPUSH
41090: LD_VAR 0 2
41094: PPUSH
41095: EMPTY
41096: PPUSH
41097: CALL_OW 1
41101: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41102: LD_ADDR_EXP 133
41106: PUSH
41107: LD_EXP 133
41111: PPUSH
41112: LD_VAR 0 2
41116: PPUSH
41117: LD_EXP 100
41121: PUSH
41122: LD_VAR 0 2
41126: ARRAY
41127: PPUSH
41128: LD_INT 2
41130: PUSH
41131: LD_INT 30
41133: PUSH
41134: LD_INT 6
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 30
41143: PUSH
41144: LD_INT 7
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 30
41153: PUSH
41154: LD_INT 8
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: LIST
41165: LIST
41166: PPUSH
41167: CALL_OW 72
41171: PPUSH
41172: CALL_OW 1
41176: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41177: LD_ADDR_EXP 134
41181: PUSH
41182: LD_EXP 134
41186: PPUSH
41187: LD_VAR 0 2
41191: PPUSH
41192: EMPTY
41193: PPUSH
41194: CALL_OW 1
41198: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41199: LD_ADDR_EXP 135
41203: PUSH
41204: LD_EXP 135
41208: PPUSH
41209: LD_VAR 0 2
41213: PPUSH
41214: EMPTY
41215: PPUSH
41216: CALL_OW 1
41220: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
41221: LD_ADDR_EXP 136
41225: PUSH
41226: LD_EXP 136
41230: PPUSH
41231: LD_VAR 0 2
41235: PPUSH
41236: EMPTY
41237: PPUSH
41238: CALL_OW 1
41242: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41243: LD_ADDR_EXP 137
41247: PUSH
41248: LD_EXP 137
41252: PPUSH
41253: LD_VAR 0 2
41257: PPUSH
41258: EMPTY
41259: PPUSH
41260: CALL_OW 1
41264: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41265: LD_ADDR_EXP 138
41269: PUSH
41270: LD_EXP 138
41274: PPUSH
41275: LD_VAR 0 2
41279: PPUSH
41280: EMPTY
41281: PPUSH
41282: CALL_OW 1
41286: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
41287: LD_ADDR_EXP 139
41291: PUSH
41292: LD_EXP 139
41296: PPUSH
41297: LD_VAR 0 2
41301: PPUSH
41302: EMPTY
41303: PPUSH
41304: CALL_OW 1
41308: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
41309: LD_ADDR_EXP 140
41313: PUSH
41314: LD_EXP 140
41318: PPUSH
41319: LD_VAR 0 2
41323: PPUSH
41324: EMPTY
41325: PPUSH
41326: CALL_OW 1
41330: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
41331: LD_ADDR_EXP 141
41335: PUSH
41336: LD_EXP 141
41340: PPUSH
41341: LD_VAR 0 2
41345: PPUSH
41346: EMPTY
41347: PPUSH
41348: CALL_OW 1
41352: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
41353: LD_ADDR_EXP 142
41357: PUSH
41358: LD_EXP 142
41362: PPUSH
41363: LD_VAR 0 2
41367: PPUSH
41368: LD_INT 0
41370: PPUSH
41371: CALL_OW 1
41375: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
41376: LD_ADDR_EXP 143
41380: PUSH
41381: LD_EXP 143
41385: PPUSH
41386: LD_VAR 0 2
41390: PPUSH
41391: LD_INT 0
41393: PPUSH
41394: CALL_OW 1
41398: ST_TO_ADDR
// end ;
41399: GO 40300
41401: POP
41402: POP
// MC_InitSides ( ) ;
41403: CALL 41689 0 0
// MC_InitResearch ( ) ;
41407: CALL 41428 0 0
// CustomInitMacro ( ) ;
41411: CALL 475 0 0
// skirmish := true ;
41415: LD_ADDR_EXP 98
41419: PUSH
41420: LD_INT 1
41422: ST_TO_ADDR
// end ;
41423: LD_VAR 0 1
41427: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
41428: LD_INT 0
41430: PPUSH
41431: PPUSH
41432: PPUSH
41433: PPUSH
41434: PPUSH
41435: PPUSH
// if not mc_bases then
41436: LD_EXP 100
41440: NOT
41441: IFFALSE 41445
// exit ;
41443: GO 41684
// for i = 1 to 8 do
41445: LD_ADDR_VAR 0 2
41449: PUSH
41450: DOUBLE
41451: LD_INT 1
41453: DEC
41454: ST_TO_ADDR
41455: LD_INT 8
41457: PUSH
41458: FOR_TO
41459: IFFALSE 41485
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
41461: LD_ADDR_EXP 127
41465: PUSH
41466: LD_EXP 127
41470: PPUSH
41471: LD_VAR 0 2
41475: PPUSH
41476: EMPTY
41477: PPUSH
41478: CALL_OW 1
41482: ST_TO_ADDR
41483: GO 41458
41485: POP
41486: POP
// tmp := [ ] ;
41487: LD_ADDR_VAR 0 5
41491: PUSH
41492: EMPTY
41493: ST_TO_ADDR
// for i = 1 to mc_sides do
41494: LD_ADDR_VAR 0 2
41498: PUSH
41499: DOUBLE
41500: LD_INT 1
41502: DEC
41503: ST_TO_ADDR
41504: LD_EXP 126
41508: PUSH
41509: FOR_TO
41510: IFFALSE 41568
// if not mc_sides [ i ] in tmp then
41512: LD_EXP 126
41516: PUSH
41517: LD_VAR 0 2
41521: ARRAY
41522: PUSH
41523: LD_VAR 0 5
41527: IN
41528: NOT
41529: IFFALSE 41566
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
41531: LD_ADDR_VAR 0 5
41535: PUSH
41536: LD_VAR 0 5
41540: PPUSH
41541: LD_VAR 0 5
41545: PUSH
41546: LD_INT 1
41548: PLUS
41549: PPUSH
41550: LD_EXP 126
41554: PUSH
41555: LD_VAR 0 2
41559: ARRAY
41560: PPUSH
41561: CALL_OW 2
41565: ST_TO_ADDR
41566: GO 41509
41568: POP
41569: POP
// if not tmp then
41570: LD_VAR 0 5
41574: NOT
41575: IFFALSE 41579
// exit ;
41577: GO 41684
// for j in tmp do
41579: LD_ADDR_VAR 0 3
41583: PUSH
41584: LD_VAR 0 5
41588: PUSH
41589: FOR_IN
41590: IFFALSE 41682
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
41592: LD_ADDR_VAR 0 6
41596: PUSH
41597: LD_INT 22
41599: PUSH
41600: LD_VAR 0 3
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PPUSH
41609: CALL_OW 69
41613: ST_TO_ADDR
// if not un then
41614: LD_VAR 0 6
41618: NOT
41619: IFFALSE 41623
// continue ;
41621: GO 41589
// nation := GetNation ( un [ 1 ] ) ;
41623: LD_ADDR_VAR 0 4
41627: PUSH
41628: LD_VAR 0 6
41632: PUSH
41633: LD_INT 1
41635: ARRAY
41636: PPUSH
41637: CALL_OW 248
41641: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
41642: LD_ADDR_EXP 127
41646: PUSH
41647: LD_EXP 127
41651: PPUSH
41652: LD_VAR 0 3
41656: PPUSH
41657: LD_VAR 0 3
41661: PPUSH
41662: LD_VAR 0 4
41666: PPUSH
41667: LD_INT 1
41669: PPUSH
41670: CALL 68858 0 3
41674: PPUSH
41675: CALL_OW 1
41679: ST_TO_ADDR
// end ;
41680: GO 41589
41682: POP
41683: POP
// end ;
41684: LD_VAR 0 1
41688: RET
// export function MC_InitSides ( ) ; var i ; begin
41689: LD_INT 0
41691: PPUSH
41692: PPUSH
// if not mc_bases then
41693: LD_EXP 100
41697: NOT
41698: IFFALSE 41702
// exit ;
41700: GO 41776
// for i = 1 to mc_bases do
41702: LD_ADDR_VAR 0 2
41706: PUSH
41707: DOUBLE
41708: LD_INT 1
41710: DEC
41711: ST_TO_ADDR
41712: LD_EXP 100
41716: PUSH
41717: FOR_TO
41718: IFFALSE 41774
// if mc_bases [ i ] then
41720: LD_EXP 100
41724: PUSH
41725: LD_VAR 0 2
41729: ARRAY
41730: IFFALSE 41772
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
41732: LD_ADDR_EXP 126
41736: PUSH
41737: LD_EXP 126
41741: PPUSH
41742: LD_VAR 0 2
41746: PPUSH
41747: LD_EXP 100
41751: PUSH
41752: LD_VAR 0 2
41756: ARRAY
41757: PUSH
41758: LD_INT 1
41760: ARRAY
41761: PPUSH
41762: CALL_OW 255
41766: PPUSH
41767: CALL_OW 1
41771: ST_TO_ADDR
41772: GO 41717
41774: POP
41775: POP
// end ;
41776: LD_VAR 0 1
41780: RET
// every 0 0$03 trigger skirmish do
41781: LD_EXP 98
41785: IFFALSE 41939
41787: GO 41789
41789: DISABLE
// begin enable ;
41790: ENABLE
// MC_CheckBuildings ( ) ;
41791: CALL 46437 0 0
// MC_CheckPeopleLife ( ) ;
41795: CALL 46598 0 0
// RaiseSailEvent ( 100 ) ;
41799: LD_INT 100
41801: PPUSH
41802: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
41806: LD_INT 103
41808: PPUSH
41809: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
41813: LD_INT 104
41815: PPUSH
41816: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
41820: LD_INT 105
41822: PPUSH
41823: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
41827: LD_INT 106
41829: PPUSH
41830: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
41834: LD_INT 107
41836: PPUSH
41837: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
41841: LD_INT 108
41843: PPUSH
41844: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
41848: LD_INT 109
41850: PPUSH
41851: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
41855: LD_INT 110
41857: PPUSH
41858: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
41862: LD_INT 111
41864: PPUSH
41865: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
41869: LD_INT 112
41871: PPUSH
41872: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
41876: LD_INT 113
41878: PPUSH
41879: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
41883: LD_INT 120
41885: PPUSH
41886: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
41890: LD_INT 121
41892: PPUSH
41893: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
41897: LD_INT 122
41899: PPUSH
41900: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
41904: LD_INT 123
41906: PPUSH
41907: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
41911: LD_INT 124
41913: PPUSH
41914: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
41918: LD_INT 125
41920: PPUSH
41921: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
41925: LD_INT 126
41927: PPUSH
41928: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
41932: LD_INT 200
41934: PPUSH
41935: CALL_OW 427
// end ;
41939: END
// on SailEvent ( event ) do begin if event < 100 then
41940: LD_VAR 0 1
41944: PUSH
41945: LD_INT 100
41947: LESS
41948: IFFALSE 41959
// CustomEvent ( event ) ;
41950: LD_VAR 0 1
41954: PPUSH
41955: CALL 36315 0 1
// if event = 100 then
41959: LD_VAR 0 1
41963: PUSH
41964: LD_INT 100
41966: EQUAL
41967: IFFALSE 41973
// MC_ClassManager ( ) ;
41969: CALL 42365 0 0
// if event = 101 then
41973: LD_VAR 0 1
41977: PUSH
41978: LD_INT 101
41980: EQUAL
41981: IFFALSE 41987
// MC_RepairBuildings ( ) ;
41983: CALL 47183 0 0
// if event = 102 then
41987: LD_VAR 0 1
41991: PUSH
41992: LD_INT 102
41994: EQUAL
41995: IFFALSE 42001
// MC_Heal ( ) ;
41997: CALL 48118 0 0
// if event = 103 then
42001: LD_VAR 0 1
42005: PUSH
42006: LD_INT 103
42008: EQUAL
42009: IFFALSE 42015
// MC_Build ( ) ;
42011: CALL 48540 0 0
// if event = 104 then
42015: LD_VAR 0 1
42019: PUSH
42020: LD_INT 104
42022: EQUAL
42023: IFFALSE 42029
// MC_TurretWeapon ( ) ;
42025: CALL 50174 0 0
// if event = 105 then
42029: LD_VAR 0 1
42033: PUSH
42034: LD_INT 105
42036: EQUAL
42037: IFFALSE 42043
// MC_BuildUpgrade ( ) ;
42039: CALL 49725 0 0
// if event = 106 then
42043: LD_VAR 0 1
42047: PUSH
42048: LD_INT 106
42050: EQUAL
42051: IFFALSE 42057
// MC_PlantMines ( ) ;
42053: CALL 50604 0 0
// if event = 107 then
42057: LD_VAR 0 1
42061: PUSH
42062: LD_INT 107
42064: EQUAL
42065: IFFALSE 42071
// MC_CollectCrates ( ) ;
42067: CALL 51402 0 0
// if event = 108 then
42071: LD_VAR 0 1
42075: PUSH
42076: LD_INT 108
42078: EQUAL
42079: IFFALSE 42085
// MC_LinkRemoteControl ( ) ;
42081: CALL 53252 0 0
// if event = 109 then
42085: LD_VAR 0 1
42089: PUSH
42090: LD_INT 109
42092: EQUAL
42093: IFFALSE 42099
// MC_ProduceVehicle ( ) ;
42095: CALL 53433 0 0
// if event = 110 then
42099: LD_VAR 0 1
42103: PUSH
42104: LD_INT 110
42106: EQUAL
42107: IFFALSE 42113
// MC_SendAttack ( ) ;
42109: CALL 53899 0 0
// if event = 111 then
42113: LD_VAR 0 1
42117: PUSH
42118: LD_INT 111
42120: EQUAL
42121: IFFALSE 42127
// MC_Defend ( ) ;
42123: CALL 54007 0 0
// if event = 112 then
42127: LD_VAR 0 1
42131: PUSH
42132: LD_INT 112
42134: EQUAL
42135: IFFALSE 42141
// MC_Research ( ) ;
42137: CALL 54887 0 0
// if event = 113 then
42141: LD_VAR 0 1
42145: PUSH
42146: LD_INT 113
42148: EQUAL
42149: IFFALSE 42155
// MC_MinesTrigger ( ) ;
42151: CALL 56001 0 0
// if event = 120 then
42155: LD_VAR 0 1
42159: PUSH
42160: LD_INT 120
42162: EQUAL
42163: IFFALSE 42169
// MC_RepairVehicle ( ) ;
42165: CALL 56100 0 0
// if event = 121 then
42169: LD_VAR 0 1
42173: PUSH
42174: LD_INT 121
42176: EQUAL
42177: IFFALSE 42183
// MC_TameApe ( ) ;
42179: CALL 56869 0 0
// if event = 122 then
42183: LD_VAR 0 1
42187: PUSH
42188: LD_INT 122
42190: EQUAL
42191: IFFALSE 42197
// MC_ChangeApeClass ( ) ;
42193: CALL 57698 0 0
// if event = 123 then
42197: LD_VAR 0 1
42201: PUSH
42202: LD_INT 123
42204: EQUAL
42205: IFFALSE 42211
// MC_Bazooka ( ) ;
42207: CALL 58348 0 0
// if event = 124 then
42211: LD_VAR 0 1
42215: PUSH
42216: LD_INT 124
42218: EQUAL
42219: IFFALSE 42225
// MC_TeleportExit ( ) ;
42221: CALL 58546 0 0
// if event = 125 then
42225: LD_VAR 0 1
42229: PUSH
42230: LD_INT 125
42232: EQUAL
42233: IFFALSE 42239
// MC_Deposits ( ) ;
42235: CALL 59193 0 0
// if event = 126 then
42239: LD_VAR 0 1
42243: PUSH
42244: LD_INT 126
42246: EQUAL
42247: IFFALSE 42253
// MC_RemoteDriver ( ) ;
42249: CALL 59818 0 0
// if event = 200 then
42253: LD_VAR 0 1
42257: PUSH
42258: LD_INT 200
42260: EQUAL
42261: IFFALSE 42267
// MC_Idle ( ) ;
42263: CALL 61725 0 0
// end ;
42267: PPOPN 1
42269: END
// export function MC_Reset ( base , tag ) ; var i ; begin
42270: LD_INT 0
42272: PPUSH
42273: PPUSH
// if not mc_bases [ base ] or not tag then
42274: LD_EXP 100
42278: PUSH
42279: LD_VAR 0 1
42283: ARRAY
42284: NOT
42285: PUSH
42286: LD_VAR 0 2
42290: NOT
42291: OR
42292: IFFALSE 42296
// exit ;
42294: GO 42360
// for i in mc_bases [ base ] union mc_ape [ base ] do
42296: LD_ADDR_VAR 0 4
42300: PUSH
42301: LD_EXP 100
42305: PUSH
42306: LD_VAR 0 1
42310: ARRAY
42311: PUSH
42312: LD_EXP 129
42316: PUSH
42317: LD_VAR 0 1
42321: ARRAY
42322: UNION
42323: PUSH
42324: FOR_IN
42325: IFFALSE 42358
// if GetTag ( i ) = tag then
42327: LD_VAR 0 4
42331: PPUSH
42332: CALL_OW 110
42336: PUSH
42337: LD_VAR 0 2
42341: EQUAL
42342: IFFALSE 42356
// SetTag ( i , 0 ) ;
42344: LD_VAR 0 4
42348: PPUSH
42349: LD_INT 0
42351: PPUSH
42352: CALL_OW 109
42356: GO 42324
42358: POP
42359: POP
// end ;
42360: LD_VAR 0 3
42364: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
42365: LD_INT 0
42367: PPUSH
42368: PPUSH
42369: PPUSH
42370: PPUSH
42371: PPUSH
42372: PPUSH
42373: PPUSH
42374: PPUSH
// if not mc_bases then
42375: LD_EXP 100
42379: NOT
42380: IFFALSE 42384
// exit ;
42382: GO 42842
// for i = 1 to mc_bases do
42384: LD_ADDR_VAR 0 2
42388: PUSH
42389: DOUBLE
42390: LD_INT 1
42392: DEC
42393: ST_TO_ADDR
42394: LD_EXP 100
42398: PUSH
42399: FOR_TO
42400: IFFALSE 42840
// begin tmp := MC_ClassCheckReq ( i ) ;
42402: LD_ADDR_VAR 0 4
42406: PUSH
42407: LD_VAR 0 2
42411: PPUSH
42412: CALL 42847 0 1
42416: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
42417: LD_ADDR_EXP 141
42421: PUSH
42422: LD_EXP 141
42426: PPUSH
42427: LD_VAR 0 2
42431: PPUSH
42432: LD_VAR 0 4
42436: PPUSH
42437: CALL_OW 1
42441: ST_TO_ADDR
// if not tmp then
42442: LD_VAR 0 4
42446: NOT
42447: IFFALSE 42451
// continue ;
42449: GO 42399
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
42451: LD_ADDR_VAR 0 6
42455: PUSH
42456: LD_EXP 100
42460: PUSH
42461: LD_VAR 0 2
42465: ARRAY
42466: PPUSH
42467: LD_INT 2
42469: PUSH
42470: LD_INT 30
42472: PUSH
42473: LD_INT 4
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 30
42482: PUSH
42483: LD_INT 5
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: LIST
42494: PPUSH
42495: CALL_OW 72
42499: PUSH
42500: LD_EXP 100
42504: PUSH
42505: LD_VAR 0 2
42509: ARRAY
42510: PPUSH
42511: LD_INT 2
42513: PUSH
42514: LD_INT 30
42516: PUSH
42517: LD_INT 0
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 30
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: LIST
42538: PPUSH
42539: CALL_OW 72
42543: PUSH
42544: LD_EXP 100
42548: PUSH
42549: LD_VAR 0 2
42553: ARRAY
42554: PPUSH
42555: LD_INT 30
42557: PUSH
42558: LD_INT 3
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PPUSH
42565: CALL_OW 72
42569: PUSH
42570: LD_EXP 100
42574: PUSH
42575: LD_VAR 0 2
42579: ARRAY
42580: PPUSH
42581: LD_INT 2
42583: PUSH
42584: LD_INT 30
42586: PUSH
42587: LD_INT 6
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 30
42596: PUSH
42597: LD_INT 7
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 30
42606: PUSH
42607: LD_INT 8
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: PPUSH
42620: CALL_OW 72
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: ST_TO_ADDR
// for j = 1 to 4 do
42631: LD_ADDR_VAR 0 3
42635: PUSH
42636: DOUBLE
42637: LD_INT 1
42639: DEC
42640: ST_TO_ADDR
42641: LD_INT 4
42643: PUSH
42644: FOR_TO
42645: IFFALSE 42836
// begin if not tmp [ j ] then
42647: LD_VAR 0 4
42651: PUSH
42652: LD_VAR 0 3
42656: ARRAY
42657: NOT
42658: IFFALSE 42662
// continue ;
42660: GO 42644
// for p in tmp [ j ] do
42662: LD_ADDR_VAR 0 5
42666: PUSH
42667: LD_VAR 0 4
42671: PUSH
42672: LD_VAR 0 3
42676: ARRAY
42677: PUSH
42678: FOR_IN
42679: IFFALSE 42832
// begin if not b [ j ] then
42681: LD_VAR 0 6
42685: PUSH
42686: LD_VAR 0 3
42690: ARRAY
42691: NOT
42692: IFFALSE 42696
// break ;
42694: GO 42832
// e := 0 ;
42696: LD_ADDR_VAR 0 7
42700: PUSH
42701: LD_INT 0
42703: ST_TO_ADDR
// for k in b [ j ] do
42704: LD_ADDR_VAR 0 8
42708: PUSH
42709: LD_VAR 0 6
42713: PUSH
42714: LD_VAR 0 3
42718: ARRAY
42719: PUSH
42720: FOR_IN
42721: IFFALSE 42748
// if IsNotFull ( k ) then
42723: LD_VAR 0 8
42727: PPUSH
42728: CALL 70979 0 1
42732: IFFALSE 42746
// begin e := k ;
42734: LD_ADDR_VAR 0 7
42738: PUSH
42739: LD_VAR 0 8
42743: ST_TO_ADDR
// break ;
42744: GO 42748
// end ;
42746: GO 42720
42748: POP
42749: POP
// if e and not UnitGoingToBuilding ( p , e ) then
42750: LD_VAR 0 7
42754: PUSH
42755: LD_VAR 0 5
42759: PPUSH
42760: LD_VAR 0 7
42764: PPUSH
42765: CALL 104732 0 2
42769: NOT
42770: AND
42771: IFFALSE 42830
// begin if IsInUnit ( p ) then
42773: LD_VAR 0 5
42777: PPUSH
42778: CALL_OW 310
42782: IFFALSE 42793
// ComExitBuilding ( p ) ;
42784: LD_VAR 0 5
42788: PPUSH
42789: CALL_OW 122
// ComEnterUnit ( p , e ) ;
42793: LD_VAR 0 5
42797: PPUSH
42798: LD_VAR 0 7
42802: PPUSH
42803: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
42807: LD_VAR 0 5
42811: PPUSH
42812: LD_VAR 0 3
42816: PPUSH
42817: CALL_OW 183
// AddComExitBuilding ( p ) ;
42821: LD_VAR 0 5
42825: PPUSH
42826: CALL_OW 182
// end ; end ;
42830: GO 42678
42832: POP
42833: POP
// end ;
42834: GO 42644
42836: POP
42837: POP
// end ;
42838: GO 42399
42840: POP
42841: POP
// end ;
42842: LD_VAR 0 1
42846: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
42847: LD_INT 0
42849: PPUSH
42850: PPUSH
42851: PPUSH
42852: PPUSH
42853: PPUSH
42854: PPUSH
42855: PPUSH
42856: PPUSH
42857: PPUSH
42858: PPUSH
42859: PPUSH
42860: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42861: LD_VAR 0 1
42865: NOT
42866: PUSH
42867: LD_EXP 100
42871: PUSH
42872: LD_VAR 0 1
42876: ARRAY
42877: NOT
42878: OR
42879: PUSH
42880: LD_EXP 100
42884: PUSH
42885: LD_VAR 0 1
42889: ARRAY
42890: PPUSH
42891: LD_INT 2
42893: PUSH
42894: LD_INT 30
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: PUSH
42904: LD_INT 30
42906: PUSH
42907: LD_INT 1
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: LIST
42918: PPUSH
42919: CALL_OW 72
42923: NOT
42924: OR
42925: IFFALSE 42929
// exit ;
42927: GO 46432
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42929: LD_ADDR_VAR 0 4
42933: PUSH
42934: LD_EXP 100
42938: PUSH
42939: LD_VAR 0 1
42943: ARRAY
42944: PPUSH
42945: LD_INT 2
42947: PUSH
42948: LD_INT 25
42950: PUSH
42951: LD_INT 1
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 25
42960: PUSH
42961: LD_INT 2
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 25
42970: PUSH
42971: LD_INT 3
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 25
42980: PUSH
42981: LD_INT 4
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 25
42990: PUSH
42991: LD_INT 5
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 25
43000: PUSH
43001: LD_INT 8
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: LD_INT 25
43010: PUSH
43011: LD_INT 9
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: LIST
43027: PPUSH
43028: CALL_OW 72
43032: ST_TO_ADDR
// if not tmp then
43033: LD_VAR 0 4
43037: NOT
43038: IFFALSE 43042
// exit ;
43040: GO 46432
// for i in tmp do
43042: LD_ADDR_VAR 0 3
43046: PUSH
43047: LD_VAR 0 4
43051: PUSH
43052: FOR_IN
43053: IFFALSE 43084
// if GetTag ( i ) then
43055: LD_VAR 0 3
43059: PPUSH
43060: CALL_OW 110
43064: IFFALSE 43082
// tmp := tmp diff i ;
43066: LD_ADDR_VAR 0 4
43070: PUSH
43071: LD_VAR 0 4
43075: PUSH
43076: LD_VAR 0 3
43080: DIFF
43081: ST_TO_ADDR
43082: GO 43052
43084: POP
43085: POP
// if not tmp then
43086: LD_VAR 0 4
43090: NOT
43091: IFFALSE 43095
// exit ;
43093: GO 46432
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43095: LD_ADDR_VAR 0 5
43099: PUSH
43100: LD_EXP 100
43104: PUSH
43105: LD_VAR 0 1
43109: ARRAY
43110: PPUSH
43111: LD_INT 2
43113: PUSH
43114: LD_INT 25
43116: PUSH
43117: LD_INT 1
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 25
43126: PUSH
43127: LD_INT 5
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 25
43136: PUSH
43137: LD_INT 8
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: LD_INT 25
43146: PUSH
43147: LD_INT 9
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: PPUSH
43161: CALL_OW 72
43165: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43166: LD_ADDR_VAR 0 6
43170: PUSH
43171: LD_EXP 100
43175: PUSH
43176: LD_VAR 0 1
43180: ARRAY
43181: PPUSH
43182: LD_INT 25
43184: PUSH
43185: LD_INT 2
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: PPUSH
43192: CALL_OW 72
43196: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43197: LD_ADDR_VAR 0 7
43201: PUSH
43202: LD_EXP 100
43206: PUSH
43207: LD_VAR 0 1
43211: ARRAY
43212: PPUSH
43213: LD_INT 25
43215: PUSH
43216: LD_INT 3
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PPUSH
43223: CALL_OW 72
43227: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
43228: LD_ADDR_VAR 0 8
43232: PUSH
43233: LD_EXP 100
43237: PUSH
43238: LD_VAR 0 1
43242: ARRAY
43243: PPUSH
43244: LD_INT 25
43246: PUSH
43247: LD_INT 4
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 24
43256: PUSH
43257: LD_INT 251
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PPUSH
43268: CALL_OW 72
43272: ST_TO_ADDR
// if mc_is_defending [ base ] then
43273: LD_EXP 143
43277: PUSH
43278: LD_VAR 0 1
43282: ARRAY
43283: IFFALSE 43744
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
43285: LD_ADDR_EXP 142
43289: PUSH
43290: LD_EXP 142
43294: PPUSH
43295: LD_VAR 0 1
43299: PPUSH
43300: LD_INT 4
43302: PPUSH
43303: CALL_OW 1
43307: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43308: LD_ADDR_VAR 0 12
43312: PUSH
43313: LD_EXP 100
43317: PUSH
43318: LD_VAR 0 1
43322: ARRAY
43323: PPUSH
43324: LD_INT 2
43326: PUSH
43327: LD_INT 30
43329: PUSH
43330: LD_INT 4
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 30
43339: PUSH
43340: LD_INT 5
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: LIST
43351: PPUSH
43352: CALL_OW 72
43356: ST_TO_ADDR
// if not b then
43357: LD_VAR 0 12
43361: NOT
43362: IFFALSE 43366
// exit ;
43364: GO 46432
// p := [ ] ;
43366: LD_ADDR_VAR 0 11
43370: PUSH
43371: EMPTY
43372: ST_TO_ADDR
// if sci >= 2 then
43373: LD_VAR 0 8
43377: PUSH
43378: LD_INT 2
43380: GREATEREQUAL
43381: IFFALSE 43412
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
43383: LD_ADDR_VAR 0 8
43387: PUSH
43388: LD_VAR 0 8
43392: PUSH
43393: LD_INT 1
43395: ARRAY
43396: PUSH
43397: LD_VAR 0 8
43401: PUSH
43402: LD_INT 2
43404: ARRAY
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: ST_TO_ADDR
43410: GO 43473
// if sci = 1 then
43412: LD_VAR 0 8
43416: PUSH
43417: LD_INT 1
43419: EQUAL
43420: IFFALSE 43441
// sci := [ sci [ 1 ] ] else
43422: LD_ADDR_VAR 0 8
43426: PUSH
43427: LD_VAR 0 8
43431: PUSH
43432: LD_INT 1
43434: ARRAY
43435: PUSH
43436: EMPTY
43437: LIST
43438: ST_TO_ADDR
43439: GO 43473
// if sci = 0 then
43441: LD_VAR 0 8
43445: PUSH
43446: LD_INT 0
43448: EQUAL
43449: IFFALSE 43473
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
43451: LD_ADDR_VAR 0 11
43455: PUSH
43456: LD_VAR 0 4
43460: PPUSH
43461: LD_INT 4
43463: PPUSH
43464: CALL 104604 0 2
43468: PUSH
43469: LD_INT 1
43471: ARRAY
43472: ST_TO_ADDR
// if eng > 4 then
43473: LD_VAR 0 6
43477: PUSH
43478: LD_INT 4
43480: GREATER
43481: IFFALSE 43527
// for i = eng downto 4 do
43483: LD_ADDR_VAR 0 3
43487: PUSH
43488: DOUBLE
43489: LD_VAR 0 6
43493: INC
43494: ST_TO_ADDR
43495: LD_INT 4
43497: PUSH
43498: FOR_DOWNTO
43499: IFFALSE 43525
// eng := eng diff eng [ i ] ;
43501: LD_ADDR_VAR 0 6
43505: PUSH
43506: LD_VAR 0 6
43510: PUSH
43511: LD_VAR 0 6
43515: PUSH
43516: LD_VAR 0 3
43520: ARRAY
43521: DIFF
43522: ST_TO_ADDR
43523: GO 43498
43525: POP
43526: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
43527: LD_ADDR_VAR 0 4
43531: PUSH
43532: LD_VAR 0 4
43536: PUSH
43537: LD_VAR 0 5
43541: PUSH
43542: LD_VAR 0 6
43546: UNION
43547: PUSH
43548: LD_VAR 0 7
43552: UNION
43553: PUSH
43554: LD_VAR 0 8
43558: UNION
43559: DIFF
43560: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
43561: LD_ADDR_VAR 0 13
43565: PUSH
43566: LD_EXP 100
43570: PUSH
43571: LD_VAR 0 1
43575: ARRAY
43576: PPUSH
43577: LD_INT 2
43579: PUSH
43580: LD_INT 30
43582: PUSH
43583: LD_INT 32
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: LD_INT 30
43592: PUSH
43593: LD_INT 31
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: LIST
43604: PPUSH
43605: CALL_OW 72
43609: PUSH
43610: LD_EXP 100
43614: PUSH
43615: LD_VAR 0 1
43619: ARRAY
43620: PPUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 30
43626: PUSH
43627: LD_INT 4
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 30
43636: PUSH
43637: LD_INT 5
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: LIST
43648: PPUSH
43649: CALL_OW 72
43653: PUSH
43654: LD_INT 6
43656: MUL
43657: PLUS
43658: ST_TO_ADDR
// if bcount < tmp then
43659: LD_VAR 0 13
43663: PUSH
43664: LD_VAR 0 4
43668: LESS
43669: IFFALSE 43715
// for i = tmp downto bcount do
43671: LD_ADDR_VAR 0 3
43675: PUSH
43676: DOUBLE
43677: LD_VAR 0 4
43681: INC
43682: ST_TO_ADDR
43683: LD_VAR 0 13
43687: PUSH
43688: FOR_DOWNTO
43689: IFFALSE 43713
// tmp := Delete ( tmp , tmp ) ;
43691: LD_ADDR_VAR 0 4
43695: PUSH
43696: LD_VAR 0 4
43700: PPUSH
43701: LD_VAR 0 4
43705: PPUSH
43706: CALL_OW 3
43710: ST_TO_ADDR
43711: GO 43688
43713: POP
43714: POP
// result := [ tmp , 0 , 0 , p ] ;
43715: LD_ADDR_VAR 0 2
43719: PUSH
43720: LD_VAR 0 4
43724: PUSH
43725: LD_INT 0
43727: PUSH
43728: LD_INT 0
43730: PUSH
43731: LD_VAR 0 11
43735: PUSH
43736: EMPTY
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: ST_TO_ADDR
// exit ;
43742: GO 46432
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43744: LD_EXP 100
43748: PUSH
43749: LD_VAR 0 1
43753: ARRAY
43754: PPUSH
43755: LD_INT 2
43757: PUSH
43758: LD_INT 30
43760: PUSH
43761: LD_INT 6
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 30
43770: PUSH
43771: LD_INT 7
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 30
43780: PUSH
43781: LD_INT 8
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: LIST
43792: LIST
43793: PPUSH
43794: CALL_OW 72
43798: NOT
43799: PUSH
43800: LD_EXP 100
43804: PUSH
43805: LD_VAR 0 1
43809: ARRAY
43810: PPUSH
43811: LD_INT 30
43813: PUSH
43814: LD_INT 3
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PPUSH
43821: CALL_OW 72
43825: NOT
43826: AND
43827: IFFALSE 43899
// begin if eng = tmp then
43829: LD_VAR 0 6
43833: PUSH
43834: LD_VAR 0 4
43838: EQUAL
43839: IFFALSE 43843
// exit ;
43841: GO 46432
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
43843: LD_ADDR_EXP 142
43847: PUSH
43848: LD_EXP 142
43852: PPUSH
43853: LD_VAR 0 1
43857: PPUSH
43858: LD_INT 1
43860: PPUSH
43861: CALL_OW 1
43865: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
43866: LD_ADDR_VAR 0 2
43870: PUSH
43871: LD_INT 0
43873: PUSH
43874: LD_VAR 0 4
43878: PUSH
43879: LD_VAR 0 6
43883: DIFF
43884: PUSH
43885: LD_INT 0
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: ST_TO_ADDR
// exit ;
43897: GO 46432
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43899: LD_EXP 127
43903: PUSH
43904: LD_EXP 126
43908: PUSH
43909: LD_VAR 0 1
43913: ARRAY
43914: ARRAY
43915: PUSH
43916: LD_EXP 100
43920: PUSH
43921: LD_VAR 0 1
43925: ARRAY
43926: PPUSH
43927: LD_INT 2
43929: PUSH
43930: LD_INT 30
43932: PUSH
43933: LD_INT 6
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 30
43942: PUSH
43943: LD_INT 7
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 30
43952: PUSH
43953: LD_INT 8
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: PPUSH
43966: CALL_OW 72
43970: AND
43971: PUSH
43972: LD_EXP 100
43976: PUSH
43977: LD_VAR 0 1
43981: ARRAY
43982: PPUSH
43983: LD_INT 30
43985: PUSH
43986: LD_INT 3
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PPUSH
43993: CALL_OW 72
43997: NOT
43998: AND
43999: IFFALSE 44213
// begin if sci >= 6 then
44001: LD_VAR 0 8
44005: PUSH
44006: LD_INT 6
44008: GREATEREQUAL
44009: IFFALSE 44013
// exit ;
44011: GO 46432
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44013: LD_ADDR_EXP 142
44017: PUSH
44018: LD_EXP 142
44022: PPUSH
44023: LD_VAR 0 1
44027: PPUSH
44028: LD_INT 2
44030: PPUSH
44031: CALL_OW 1
44035: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44036: LD_ADDR_VAR 0 9
44040: PUSH
44041: LD_VAR 0 4
44045: PUSH
44046: LD_VAR 0 8
44050: DIFF
44051: PPUSH
44052: LD_INT 4
44054: PPUSH
44055: CALL 104604 0 2
44059: ST_TO_ADDR
// p := [ ] ;
44060: LD_ADDR_VAR 0 11
44064: PUSH
44065: EMPTY
44066: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44067: LD_VAR 0 8
44071: PUSH
44072: LD_INT 6
44074: LESS
44075: PUSH
44076: LD_VAR 0 9
44080: PUSH
44081: LD_INT 6
44083: GREATER
44084: AND
44085: IFFALSE 44166
// begin for i = 1 to 6 - sci do
44087: LD_ADDR_VAR 0 3
44091: PUSH
44092: DOUBLE
44093: LD_INT 1
44095: DEC
44096: ST_TO_ADDR
44097: LD_INT 6
44099: PUSH
44100: LD_VAR 0 8
44104: MINUS
44105: PUSH
44106: FOR_TO
44107: IFFALSE 44162
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44109: LD_ADDR_VAR 0 11
44113: PUSH
44114: LD_VAR 0 11
44118: PPUSH
44119: LD_VAR 0 11
44123: PUSH
44124: LD_INT 1
44126: PLUS
44127: PPUSH
44128: LD_VAR 0 9
44132: PUSH
44133: LD_INT 1
44135: ARRAY
44136: PPUSH
44137: CALL_OW 2
44141: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44142: LD_ADDR_VAR 0 9
44146: PUSH
44147: LD_VAR 0 9
44151: PPUSH
44152: LD_INT 1
44154: PPUSH
44155: CALL_OW 3
44159: ST_TO_ADDR
// end ;
44160: GO 44106
44162: POP
44163: POP
// end else
44164: GO 44186
// if sort then
44166: LD_VAR 0 9
44170: IFFALSE 44186
// p := sort [ 1 ] ;
44172: LD_ADDR_VAR 0 11
44176: PUSH
44177: LD_VAR 0 9
44181: PUSH
44182: LD_INT 1
44184: ARRAY
44185: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44186: LD_ADDR_VAR 0 2
44190: PUSH
44191: LD_INT 0
44193: PUSH
44194: LD_INT 0
44196: PUSH
44197: LD_INT 0
44199: PUSH
44200: LD_VAR 0 11
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: LIST
44209: LIST
44210: ST_TO_ADDR
// exit ;
44211: GO 46432
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44213: LD_EXP 127
44217: PUSH
44218: LD_EXP 126
44222: PUSH
44223: LD_VAR 0 1
44227: ARRAY
44228: ARRAY
44229: PUSH
44230: LD_EXP 100
44234: PUSH
44235: LD_VAR 0 1
44239: ARRAY
44240: PPUSH
44241: LD_INT 2
44243: PUSH
44244: LD_INT 30
44246: PUSH
44247: LD_INT 6
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 30
44256: PUSH
44257: LD_INT 7
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 30
44266: PUSH
44267: LD_INT 8
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: PPUSH
44280: CALL_OW 72
44284: AND
44285: PUSH
44286: LD_EXP 100
44290: PUSH
44291: LD_VAR 0 1
44295: ARRAY
44296: PPUSH
44297: LD_INT 30
44299: PUSH
44300: LD_INT 3
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PPUSH
44307: CALL_OW 72
44311: AND
44312: IFFALSE 45046
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
44314: LD_ADDR_EXP 142
44318: PUSH
44319: LD_EXP 142
44323: PPUSH
44324: LD_VAR 0 1
44328: PPUSH
44329: LD_INT 3
44331: PPUSH
44332: CALL_OW 1
44336: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44337: LD_ADDR_VAR 0 2
44341: PUSH
44342: LD_INT 0
44344: PUSH
44345: LD_INT 0
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 0
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: ST_TO_ADDR
// if not eng then
44360: LD_VAR 0 6
44364: NOT
44365: IFFALSE 44428
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
44367: LD_ADDR_VAR 0 11
44371: PUSH
44372: LD_VAR 0 4
44376: PPUSH
44377: LD_INT 2
44379: PPUSH
44380: CALL 104604 0 2
44384: PUSH
44385: LD_INT 1
44387: ARRAY
44388: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
44389: LD_ADDR_VAR 0 2
44393: PUSH
44394: LD_VAR 0 2
44398: PPUSH
44399: LD_INT 2
44401: PPUSH
44402: LD_VAR 0 11
44406: PPUSH
44407: CALL_OW 1
44411: ST_TO_ADDR
// tmp := tmp diff p ;
44412: LD_ADDR_VAR 0 4
44416: PUSH
44417: LD_VAR 0 4
44421: PUSH
44422: LD_VAR 0 11
44426: DIFF
44427: ST_TO_ADDR
// end ; if tmp and sci < 6 then
44428: LD_VAR 0 4
44432: PUSH
44433: LD_VAR 0 8
44437: PUSH
44438: LD_INT 6
44440: LESS
44441: AND
44442: IFFALSE 44630
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
44444: LD_ADDR_VAR 0 9
44448: PUSH
44449: LD_VAR 0 4
44453: PUSH
44454: LD_VAR 0 8
44458: PUSH
44459: LD_VAR 0 7
44463: UNION
44464: DIFF
44465: PPUSH
44466: LD_INT 4
44468: PPUSH
44469: CALL 104604 0 2
44473: ST_TO_ADDR
// p := [ ] ;
44474: LD_ADDR_VAR 0 11
44478: PUSH
44479: EMPTY
44480: ST_TO_ADDR
// if sort then
44481: LD_VAR 0 9
44485: IFFALSE 44601
// for i = 1 to 6 - sci do
44487: LD_ADDR_VAR 0 3
44491: PUSH
44492: DOUBLE
44493: LD_INT 1
44495: DEC
44496: ST_TO_ADDR
44497: LD_INT 6
44499: PUSH
44500: LD_VAR 0 8
44504: MINUS
44505: PUSH
44506: FOR_TO
44507: IFFALSE 44599
// begin if i = sort then
44509: LD_VAR 0 3
44513: PUSH
44514: LD_VAR 0 9
44518: EQUAL
44519: IFFALSE 44523
// break ;
44521: GO 44599
// if GetClass ( i ) = 4 then
44523: LD_VAR 0 3
44527: PPUSH
44528: CALL_OW 257
44532: PUSH
44533: LD_INT 4
44535: EQUAL
44536: IFFALSE 44540
// continue ;
44538: GO 44506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44540: LD_ADDR_VAR 0 11
44544: PUSH
44545: LD_VAR 0 11
44549: PPUSH
44550: LD_VAR 0 11
44554: PUSH
44555: LD_INT 1
44557: PLUS
44558: PPUSH
44559: LD_VAR 0 9
44563: PUSH
44564: LD_VAR 0 3
44568: ARRAY
44569: PPUSH
44570: CALL_OW 2
44574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44575: LD_ADDR_VAR 0 4
44579: PUSH
44580: LD_VAR 0 4
44584: PUSH
44585: LD_VAR 0 9
44589: PUSH
44590: LD_VAR 0 3
44594: ARRAY
44595: DIFF
44596: ST_TO_ADDR
// end ;
44597: GO 44506
44599: POP
44600: POP
// if p then
44601: LD_VAR 0 11
44605: IFFALSE 44630
// result := Replace ( result , 4 , p ) ;
44607: LD_ADDR_VAR 0 2
44611: PUSH
44612: LD_VAR 0 2
44616: PPUSH
44617: LD_INT 4
44619: PPUSH
44620: LD_VAR 0 11
44624: PPUSH
44625: CALL_OW 1
44629: ST_TO_ADDR
// end ; if tmp and mech < 6 then
44630: LD_VAR 0 4
44634: PUSH
44635: LD_VAR 0 7
44639: PUSH
44640: LD_INT 6
44642: LESS
44643: AND
44644: IFFALSE 44832
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44646: LD_ADDR_VAR 0 9
44650: PUSH
44651: LD_VAR 0 4
44655: PUSH
44656: LD_VAR 0 8
44660: PUSH
44661: LD_VAR 0 7
44665: UNION
44666: DIFF
44667: PPUSH
44668: LD_INT 3
44670: PPUSH
44671: CALL 104604 0 2
44675: ST_TO_ADDR
// p := [ ] ;
44676: LD_ADDR_VAR 0 11
44680: PUSH
44681: EMPTY
44682: ST_TO_ADDR
// if sort then
44683: LD_VAR 0 9
44687: IFFALSE 44803
// for i = 1 to 6 - mech do
44689: LD_ADDR_VAR 0 3
44693: PUSH
44694: DOUBLE
44695: LD_INT 1
44697: DEC
44698: ST_TO_ADDR
44699: LD_INT 6
44701: PUSH
44702: LD_VAR 0 7
44706: MINUS
44707: PUSH
44708: FOR_TO
44709: IFFALSE 44801
// begin if i = sort then
44711: LD_VAR 0 3
44715: PUSH
44716: LD_VAR 0 9
44720: EQUAL
44721: IFFALSE 44725
// break ;
44723: GO 44801
// if GetClass ( i ) = 3 then
44725: LD_VAR 0 3
44729: PPUSH
44730: CALL_OW 257
44734: PUSH
44735: LD_INT 3
44737: EQUAL
44738: IFFALSE 44742
// continue ;
44740: GO 44708
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44742: LD_ADDR_VAR 0 11
44746: PUSH
44747: LD_VAR 0 11
44751: PPUSH
44752: LD_VAR 0 11
44756: PUSH
44757: LD_INT 1
44759: PLUS
44760: PPUSH
44761: LD_VAR 0 9
44765: PUSH
44766: LD_VAR 0 3
44770: ARRAY
44771: PPUSH
44772: CALL_OW 2
44776: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44777: LD_ADDR_VAR 0 4
44781: PUSH
44782: LD_VAR 0 4
44786: PUSH
44787: LD_VAR 0 9
44791: PUSH
44792: LD_VAR 0 3
44796: ARRAY
44797: DIFF
44798: ST_TO_ADDR
// end ;
44799: GO 44708
44801: POP
44802: POP
// if p then
44803: LD_VAR 0 11
44807: IFFALSE 44832
// result := Replace ( result , 3 , p ) ;
44809: LD_ADDR_VAR 0 2
44813: PUSH
44814: LD_VAR 0 2
44818: PPUSH
44819: LD_INT 3
44821: PPUSH
44822: LD_VAR 0 11
44826: PPUSH
44827: CALL_OW 1
44831: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
44832: LD_VAR 0 4
44836: PUSH
44837: LD_INT 6
44839: GREATER
44840: PUSH
44841: LD_VAR 0 6
44845: PUSH
44846: LD_INT 6
44848: LESS
44849: AND
44850: IFFALSE 45044
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44852: LD_ADDR_VAR 0 9
44856: PUSH
44857: LD_VAR 0 4
44861: PUSH
44862: LD_VAR 0 8
44866: PUSH
44867: LD_VAR 0 7
44871: UNION
44872: PUSH
44873: LD_VAR 0 6
44877: UNION
44878: DIFF
44879: PPUSH
44880: LD_INT 2
44882: PPUSH
44883: CALL 104604 0 2
44887: ST_TO_ADDR
// p := [ ] ;
44888: LD_ADDR_VAR 0 11
44892: PUSH
44893: EMPTY
44894: ST_TO_ADDR
// if sort then
44895: LD_VAR 0 9
44899: IFFALSE 45015
// for i = 1 to 6 - eng do
44901: LD_ADDR_VAR 0 3
44905: PUSH
44906: DOUBLE
44907: LD_INT 1
44909: DEC
44910: ST_TO_ADDR
44911: LD_INT 6
44913: PUSH
44914: LD_VAR 0 6
44918: MINUS
44919: PUSH
44920: FOR_TO
44921: IFFALSE 45013
// begin if i = sort then
44923: LD_VAR 0 3
44927: PUSH
44928: LD_VAR 0 9
44932: EQUAL
44933: IFFALSE 44937
// break ;
44935: GO 45013
// if GetClass ( i ) = 2 then
44937: LD_VAR 0 3
44941: PPUSH
44942: CALL_OW 257
44946: PUSH
44947: LD_INT 2
44949: EQUAL
44950: IFFALSE 44954
// continue ;
44952: GO 44920
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44954: LD_ADDR_VAR 0 11
44958: PUSH
44959: LD_VAR 0 11
44963: PPUSH
44964: LD_VAR 0 11
44968: PUSH
44969: LD_INT 1
44971: PLUS
44972: PPUSH
44973: LD_VAR 0 9
44977: PUSH
44978: LD_VAR 0 3
44982: ARRAY
44983: PPUSH
44984: CALL_OW 2
44988: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44989: LD_ADDR_VAR 0 4
44993: PUSH
44994: LD_VAR 0 4
44998: PUSH
44999: LD_VAR 0 9
45003: PUSH
45004: LD_VAR 0 3
45008: ARRAY
45009: DIFF
45010: ST_TO_ADDR
// end ;
45011: GO 44920
45013: POP
45014: POP
// if p then
45015: LD_VAR 0 11
45019: IFFALSE 45044
// result := Replace ( result , 2 , p ) ;
45021: LD_ADDR_VAR 0 2
45025: PUSH
45026: LD_VAR 0 2
45030: PPUSH
45031: LD_INT 2
45033: PPUSH
45034: LD_VAR 0 11
45038: PPUSH
45039: CALL_OW 1
45043: ST_TO_ADDR
// end ; exit ;
45044: GO 46432
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45046: LD_EXP 127
45050: PUSH
45051: LD_EXP 126
45055: PUSH
45056: LD_VAR 0 1
45060: ARRAY
45061: ARRAY
45062: NOT
45063: PUSH
45064: LD_EXP 100
45068: PUSH
45069: LD_VAR 0 1
45073: ARRAY
45074: PPUSH
45075: LD_INT 30
45077: PUSH
45078: LD_INT 3
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PPUSH
45085: CALL_OW 72
45089: AND
45090: PUSH
45091: LD_EXP 105
45095: PUSH
45096: LD_VAR 0 1
45100: ARRAY
45101: AND
45102: IFFALSE 45710
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45104: LD_ADDR_EXP 142
45108: PUSH
45109: LD_EXP 142
45113: PPUSH
45114: LD_VAR 0 1
45118: PPUSH
45119: LD_INT 5
45121: PPUSH
45122: CALL_OW 1
45126: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45127: LD_ADDR_VAR 0 2
45131: PUSH
45132: LD_INT 0
45134: PUSH
45135: LD_INT 0
45137: PUSH
45138: LD_INT 0
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: ST_TO_ADDR
// if sci > 1 then
45150: LD_VAR 0 8
45154: PUSH
45155: LD_INT 1
45157: GREATER
45158: IFFALSE 45186
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45160: LD_ADDR_VAR 0 4
45164: PUSH
45165: LD_VAR 0 4
45169: PUSH
45170: LD_VAR 0 8
45174: PUSH
45175: LD_VAR 0 8
45179: PUSH
45180: LD_INT 1
45182: ARRAY
45183: DIFF
45184: DIFF
45185: ST_TO_ADDR
// if tmp and not sci then
45186: LD_VAR 0 4
45190: PUSH
45191: LD_VAR 0 8
45195: NOT
45196: AND
45197: IFFALSE 45266
// begin sort := SortBySkill ( tmp , 4 ) ;
45199: LD_ADDR_VAR 0 9
45203: PUSH
45204: LD_VAR 0 4
45208: PPUSH
45209: LD_INT 4
45211: PPUSH
45212: CALL 104604 0 2
45216: ST_TO_ADDR
// if sort then
45217: LD_VAR 0 9
45221: IFFALSE 45237
// p := sort [ 1 ] ;
45223: LD_ADDR_VAR 0 11
45227: PUSH
45228: LD_VAR 0 9
45232: PUSH
45233: LD_INT 1
45235: ARRAY
45236: ST_TO_ADDR
// if p then
45237: LD_VAR 0 11
45241: IFFALSE 45266
// result := Replace ( result , 4 , p ) ;
45243: LD_ADDR_VAR 0 2
45247: PUSH
45248: LD_VAR 0 2
45252: PPUSH
45253: LD_INT 4
45255: PPUSH
45256: LD_VAR 0 11
45260: PPUSH
45261: CALL_OW 1
45265: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45266: LD_ADDR_VAR 0 4
45270: PUSH
45271: LD_VAR 0 4
45275: PUSH
45276: LD_VAR 0 7
45280: DIFF
45281: ST_TO_ADDR
// if tmp and mech < 6 then
45282: LD_VAR 0 4
45286: PUSH
45287: LD_VAR 0 7
45291: PUSH
45292: LD_INT 6
45294: LESS
45295: AND
45296: IFFALSE 45484
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45298: LD_ADDR_VAR 0 9
45302: PUSH
45303: LD_VAR 0 4
45307: PUSH
45308: LD_VAR 0 8
45312: PUSH
45313: LD_VAR 0 7
45317: UNION
45318: DIFF
45319: PPUSH
45320: LD_INT 3
45322: PPUSH
45323: CALL 104604 0 2
45327: ST_TO_ADDR
// p := [ ] ;
45328: LD_ADDR_VAR 0 11
45332: PUSH
45333: EMPTY
45334: ST_TO_ADDR
// if sort then
45335: LD_VAR 0 9
45339: IFFALSE 45455
// for i = 1 to 6 - mech do
45341: LD_ADDR_VAR 0 3
45345: PUSH
45346: DOUBLE
45347: LD_INT 1
45349: DEC
45350: ST_TO_ADDR
45351: LD_INT 6
45353: PUSH
45354: LD_VAR 0 7
45358: MINUS
45359: PUSH
45360: FOR_TO
45361: IFFALSE 45453
// begin if i = sort then
45363: LD_VAR 0 3
45367: PUSH
45368: LD_VAR 0 9
45372: EQUAL
45373: IFFALSE 45377
// break ;
45375: GO 45453
// if GetClass ( i ) = 3 then
45377: LD_VAR 0 3
45381: PPUSH
45382: CALL_OW 257
45386: PUSH
45387: LD_INT 3
45389: EQUAL
45390: IFFALSE 45394
// continue ;
45392: GO 45360
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45394: LD_ADDR_VAR 0 11
45398: PUSH
45399: LD_VAR 0 11
45403: PPUSH
45404: LD_VAR 0 11
45408: PUSH
45409: LD_INT 1
45411: PLUS
45412: PPUSH
45413: LD_VAR 0 9
45417: PUSH
45418: LD_VAR 0 3
45422: ARRAY
45423: PPUSH
45424: CALL_OW 2
45428: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45429: LD_ADDR_VAR 0 4
45433: PUSH
45434: LD_VAR 0 4
45438: PUSH
45439: LD_VAR 0 9
45443: PUSH
45444: LD_VAR 0 3
45448: ARRAY
45449: DIFF
45450: ST_TO_ADDR
// end ;
45451: GO 45360
45453: POP
45454: POP
// if p then
45455: LD_VAR 0 11
45459: IFFALSE 45484
// result := Replace ( result , 3 , p ) ;
45461: LD_ADDR_VAR 0 2
45465: PUSH
45466: LD_VAR 0 2
45470: PPUSH
45471: LD_INT 3
45473: PPUSH
45474: LD_VAR 0 11
45478: PPUSH
45479: CALL_OW 1
45483: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
45484: LD_ADDR_VAR 0 4
45488: PUSH
45489: LD_VAR 0 4
45493: PUSH
45494: LD_VAR 0 6
45498: DIFF
45499: ST_TO_ADDR
// if tmp and eng < 6 then
45500: LD_VAR 0 4
45504: PUSH
45505: LD_VAR 0 6
45509: PUSH
45510: LD_INT 6
45512: LESS
45513: AND
45514: IFFALSE 45708
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45516: LD_ADDR_VAR 0 9
45520: PUSH
45521: LD_VAR 0 4
45525: PUSH
45526: LD_VAR 0 8
45530: PUSH
45531: LD_VAR 0 7
45535: UNION
45536: PUSH
45537: LD_VAR 0 6
45541: UNION
45542: DIFF
45543: PPUSH
45544: LD_INT 2
45546: PPUSH
45547: CALL 104604 0 2
45551: ST_TO_ADDR
// p := [ ] ;
45552: LD_ADDR_VAR 0 11
45556: PUSH
45557: EMPTY
45558: ST_TO_ADDR
// if sort then
45559: LD_VAR 0 9
45563: IFFALSE 45679
// for i = 1 to 6 - eng do
45565: LD_ADDR_VAR 0 3
45569: PUSH
45570: DOUBLE
45571: LD_INT 1
45573: DEC
45574: ST_TO_ADDR
45575: LD_INT 6
45577: PUSH
45578: LD_VAR 0 6
45582: MINUS
45583: PUSH
45584: FOR_TO
45585: IFFALSE 45677
// begin if i = sort then
45587: LD_VAR 0 3
45591: PUSH
45592: LD_VAR 0 9
45596: EQUAL
45597: IFFALSE 45601
// break ;
45599: GO 45677
// if GetClass ( i ) = 2 then
45601: LD_VAR 0 3
45605: PPUSH
45606: CALL_OW 257
45610: PUSH
45611: LD_INT 2
45613: EQUAL
45614: IFFALSE 45618
// continue ;
45616: GO 45584
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45618: LD_ADDR_VAR 0 11
45622: PUSH
45623: LD_VAR 0 11
45627: PPUSH
45628: LD_VAR 0 11
45632: PUSH
45633: LD_INT 1
45635: PLUS
45636: PPUSH
45637: LD_VAR 0 9
45641: PUSH
45642: LD_VAR 0 3
45646: ARRAY
45647: PPUSH
45648: CALL_OW 2
45652: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45653: LD_ADDR_VAR 0 4
45657: PUSH
45658: LD_VAR 0 4
45662: PUSH
45663: LD_VAR 0 9
45667: PUSH
45668: LD_VAR 0 3
45672: ARRAY
45673: DIFF
45674: ST_TO_ADDR
// end ;
45675: GO 45584
45677: POP
45678: POP
// if p then
45679: LD_VAR 0 11
45683: IFFALSE 45708
// result := Replace ( result , 2 , p ) ;
45685: LD_ADDR_VAR 0 2
45689: PUSH
45690: LD_VAR 0 2
45694: PPUSH
45695: LD_INT 2
45697: PPUSH
45698: LD_VAR 0 11
45702: PPUSH
45703: CALL_OW 1
45707: ST_TO_ADDR
// end ; exit ;
45708: GO 46432
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
45710: LD_EXP 127
45714: PUSH
45715: LD_EXP 126
45719: PUSH
45720: LD_VAR 0 1
45724: ARRAY
45725: ARRAY
45726: NOT
45727: PUSH
45728: LD_EXP 100
45732: PUSH
45733: LD_VAR 0 1
45737: ARRAY
45738: PPUSH
45739: LD_INT 30
45741: PUSH
45742: LD_INT 3
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PPUSH
45749: CALL_OW 72
45753: AND
45754: PUSH
45755: LD_EXP 105
45759: PUSH
45760: LD_VAR 0 1
45764: ARRAY
45765: NOT
45766: AND
45767: IFFALSE 46432
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
45769: LD_ADDR_EXP 142
45773: PUSH
45774: LD_EXP 142
45778: PPUSH
45779: LD_VAR 0 1
45783: PPUSH
45784: LD_INT 6
45786: PPUSH
45787: CALL_OW 1
45791: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45792: LD_ADDR_VAR 0 2
45796: PUSH
45797: LD_INT 0
45799: PUSH
45800: LD_INT 0
45802: PUSH
45803: LD_INT 0
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: ST_TO_ADDR
// if sci >= 1 then
45815: LD_VAR 0 8
45819: PUSH
45820: LD_INT 1
45822: GREATEREQUAL
45823: IFFALSE 45845
// tmp := tmp diff sci [ 1 ] ;
45825: LD_ADDR_VAR 0 4
45829: PUSH
45830: LD_VAR 0 4
45834: PUSH
45835: LD_VAR 0 8
45839: PUSH
45840: LD_INT 1
45842: ARRAY
45843: DIFF
45844: ST_TO_ADDR
// if tmp and not sci then
45845: LD_VAR 0 4
45849: PUSH
45850: LD_VAR 0 8
45854: NOT
45855: AND
45856: IFFALSE 45925
// begin sort := SortBySkill ( tmp , 4 ) ;
45858: LD_ADDR_VAR 0 9
45862: PUSH
45863: LD_VAR 0 4
45867: PPUSH
45868: LD_INT 4
45870: PPUSH
45871: CALL 104604 0 2
45875: ST_TO_ADDR
// if sort then
45876: LD_VAR 0 9
45880: IFFALSE 45896
// p := sort [ 1 ] ;
45882: LD_ADDR_VAR 0 11
45886: PUSH
45887: LD_VAR 0 9
45891: PUSH
45892: LD_INT 1
45894: ARRAY
45895: ST_TO_ADDR
// if p then
45896: LD_VAR 0 11
45900: IFFALSE 45925
// result := Replace ( result , 4 , p ) ;
45902: LD_ADDR_VAR 0 2
45906: PUSH
45907: LD_VAR 0 2
45911: PPUSH
45912: LD_INT 4
45914: PPUSH
45915: LD_VAR 0 11
45919: PPUSH
45920: CALL_OW 1
45924: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45925: LD_ADDR_VAR 0 4
45929: PUSH
45930: LD_VAR 0 4
45934: PUSH
45935: LD_VAR 0 7
45939: DIFF
45940: ST_TO_ADDR
// if tmp and mech < 6 then
45941: LD_VAR 0 4
45945: PUSH
45946: LD_VAR 0 7
45950: PUSH
45951: LD_INT 6
45953: LESS
45954: AND
45955: IFFALSE 46137
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
45957: LD_ADDR_VAR 0 9
45961: PUSH
45962: LD_VAR 0 4
45966: PUSH
45967: LD_VAR 0 7
45971: DIFF
45972: PPUSH
45973: LD_INT 3
45975: PPUSH
45976: CALL 104604 0 2
45980: ST_TO_ADDR
// p := [ ] ;
45981: LD_ADDR_VAR 0 11
45985: PUSH
45986: EMPTY
45987: ST_TO_ADDR
// if sort then
45988: LD_VAR 0 9
45992: IFFALSE 46108
// for i = 1 to 6 - mech do
45994: LD_ADDR_VAR 0 3
45998: PUSH
45999: DOUBLE
46000: LD_INT 1
46002: DEC
46003: ST_TO_ADDR
46004: LD_INT 6
46006: PUSH
46007: LD_VAR 0 7
46011: MINUS
46012: PUSH
46013: FOR_TO
46014: IFFALSE 46106
// begin if i = sort then
46016: LD_VAR 0 3
46020: PUSH
46021: LD_VAR 0 9
46025: EQUAL
46026: IFFALSE 46030
// break ;
46028: GO 46106
// if GetClass ( i ) = 3 then
46030: LD_VAR 0 3
46034: PPUSH
46035: CALL_OW 257
46039: PUSH
46040: LD_INT 3
46042: EQUAL
46043: IFFALSE 46047
// continue ;
46045: GO 46013
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46047: LD_ADDR_VAR 0 11
46051: PUSH
46052: LD_VAR 0 11
46056: PPUSH
46057: LD_VAR 0 11
46061: PUSH
46062: LD_INT 1
46064: PLUS
46065: PPUSH
46066: LD_VAR 0 9
46070: PUSH
46071: LD_VAR 0 3
46075: ARRAY
46076: PPUSH
46077: CALL_OW 2
46081: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46082: LD_ADDR_VAR 0 4
46086: PUSH
46087: LD_VAR 0 4
46091: PUSH
46092: LD_VAR 0 9
46096: PUSH
46097: LD_VAR 0 3
46101: ARRAY
46102: DIFF
46103: ST_TO_ADDR
// end ;
46104: GO 46013
46106: POP
46107: POP
// if p then
46108: LD_VAR 0 11
46112: IFFALSE 46137
// result := Replace ( result , 3 , p ) ;
46114: LD_ADDR_VAR 0 2
46118: PUSH
46119: LD_VAR 0 2
46123: PPUSH
46124: LD_INT 3
46126: PPUSH
46127: LD_VAR 0 11
46131: PPUSH
46132: CALL_OW 1
46136: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46137: LD_ADDR_VAR 0 4
46141: PUSH
46142: LD_VAR 0 4
46146: PUSH
46147: LD_VAR 0 6
46151: DIFF
46152: ST_TO_ADDR
// if tmp and eng < 4 then
46153: LD_VAR 0 4
46157: PUSH
46158: LD_VAR 0 6
46162: PUSH
46163: LD_INT 4
46165: LESS
46166: AND
46167: IFFALSE 46357
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46169: LD_ADDR_VAR 0 9
46173: PUSH
46174: LD_VAR 0 4
46178: PUSH
46179: LD_VAR 0 7
46183: PUSH
46184: LD_VAR 0 6
46188: UNION
46189: DIFF
46190: PPUSH
46191: LD_INT 2
46193: PPUSH
46194: CALL 104604 0 2
46198: ST_TO_ADDR
// p := [ ] ;
46199: LD_ADDR_VAR 0 11
46203: PUSH
46204: EMPTY
46205: ST_TO_ADDR
// if sort then
46206: LD_VAR 0 9
46210: IFFALSE 46326
// for i = 1 to 4 - eng do
46212: LD_ADDR_VAR 0 3
46216: PUSH
46217: DOUBLE
46218: LD_INT 1
46220: DEC
46221: ST_TO_ADDR
46222: LD_INT 4
46224: PUSH
46225: LD_VAR 0 6
46229: MINUS
46230: PUSH
46231: FOR_TO
46232: IFFALSE 46324
// begin if i = sort then
46234: LD_VAR 0 3
46238: PUSH
46239: LD_VAR 0 9
46243: EQUAL
46244: IFFALSE 46248
// break ;
46246: GO 46324
// if GetClass ( i ) = 2 then
46248: LD_VAR 0 3
46252: PPUSH
46253: CALL_OW 257
46257: PUSH
46258: LD_INT 2
46260: EQUAL
46261: IFFALSE 46265
// continue ;
46263: GO 46231
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46265: LD_ADDR_VAR 0 11
46269: PUSH
46270: LD_VAR 0 11
46274: PPUSH
46275: LD_VAR 0 11
46279: PUSH
46280: LD_INT 1
46282: PLUS
46283: PPUSH
46284: LD_VAR 0 9
46288: PUSH
46289: LD_VAR 0 3
46293: ARRAY
46294: PPUSH
46295: CALL_OW 2
46299: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46300: LD_ADDR_VAR 0 4
46304: PUSH
46305: LD_VAR 0 4
46309: PUSH
46310: LD_VAR 0 9
46314: PUSH
46315: LD_VAR 0 3
46319: ARRAY
46320: DIFF
46321: ST_TO_ADDR
// end ;
46322: GO 46231
46324: POP
46325: POP
// if p then
46326: LD_VAR 0 11
46330: IFFALSE 46355
// result := Replace ( result , 2 , p ) ;
46332: LD_ADDR_VAR 0 2
46336: PUSH
46337: LD_VAR 0 2
46341: PPUSH
46342: LD_INT 2
46344: PPUSH
46345: LD_VAR 0 11
46349: PPUSH
46350: CALL_OW 1
46354: ST_TO_ADDR
// end else
46355: GO 46401
// for i = eng downto 5 do
46357: LD_ADDR_VAR 0 3
46361: PUSH
46362: DOUBLE
46363: LD_VAR 0 6
46367: INC
46368: ST_TO_ADDR
46369: LD_INT 5
46371: PUSH
46372: FOR_DOWNTO
46373: IFFALSE 46399
// tmp := tmp union eng [ i ] ;
46375: LD_ADDR_VAR 0 4
46379: PUSH
46380: LD_VAR 0 4
46384: PUSH
46385: LD_VAR 0 6
46389: PUSH
46390: LD_VAR 0 3
46394: ARRAY
46395: UNION
46396: ST_TO_ADDR
46397: GO 46372
46399: POP
46400: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
46401: LD_ADDR_VAR 0 2
46405: PUSH
46406: LD_VAR 0 2
46410: PPUSH
46411: LD_INT 1
46413: PPUSH
46414: LD_VAR 0 4
46418: PUSH
46419: LD_VAR 0 5
46423: DIFF
46424: PPUSH
46425: CALL_OW 1
46429: ST_TO_ADDR
// exit ;
46430: GO 46432
// end ; end ;
46432: LD_VAR 0 2
46436: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
46437: LD_INT 0
46439: PPUSH
46440: PPUSH
46441: PPUSH
// if not mc_bases then
46442: LD_EXP 100
46446: NOT
46447: IFFALSE 46451
// exit ;
46449: GO 46593
// for i = 1 to mc_bases do
46451: LD_ADDR_VAR 0 2
46455: PUSH
46456: DOUBLE
46457: LD_INT 1
46459: DEC
46460: ST_TO_ADDR
46461: LD_EXP 100
46465: PUSH
46466: FOR_TO
46467: IFFALSE 46584
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
46469: LD_ADDR_VAR 0 3
46473: PUSH
46474: LD_EXP 100
46478: PUSH
46479: LD_VAR 0 2
46483: ARRAY
46484: PPUSH
46485: LD_INT 21
46487: PUSH
46488: LD_INT 3
46490: PUSH
46491: EMPTY
46492: LIST
46493: LIST
46494: PUSH
46495: LD_INT 3
46497: PUSH
46498: LD_INT 2
46500: PUSH
46501: LD_INT 30
46503: PUSH
46504: LD_INT 29
46506: PUSH
46507: EMPTY
46508: LIST
46509: LIST
46510: PUSH
46511: LD_INT 30
46513: PUSH
46514: LD_INT 30
46516: PUSH
46517: EMPTY
46518: LIST
46519: LIST
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: LIST
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 3
46532: PUSH
46533: LD_INT 24
46535: PUSH
46536: LD_INT 1000
46538: PUSH
46539: EMPTY
46540: LIST
46541: LIST
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: LIST
46551: PPUSH
46552: CALL_OW 72
46556: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
46557: LD_ADDR_EXP 101
46561: PUSH
46562: LD_EXP 101
46566: PPUSH
46567: LD_VAR 0 2
46571: PPUSH
46572: LD_VAR 0 3
46576: PPUSH
46577: CALL_OW 1
46581: ST_TO_ADDR
// end ;
46582: GO 46466
46584: POP
46585: POP
// RaiseSailEvent ( 101 ) ;
46586: LD_INT 101
46588: PPUSH
46589: CALL_OW 427
// end ;
46593: LD_VAR 0 1
46597: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
46598: LD_INT 0
46600: PPUSH
46601: PPUSH
46602: PPUSH
46603: PPUSH
46604: PPUSH
46605: PPUSH
46606: PPUSH
// if not mc_bases then
46607: LD_EXP 100
46611: NOT
46612: IFFALSE 46616
// exit ;
46614: GO 47178
// for i = 1 to mc_bases do
46616: LD_ADDR_VAR 0 2
46620: PUSH
46621: DOUBLE
46622: LD_INT 1
46624: DEC
46625: ST_TO_ADDR
46626: LD_EXP 100
46630: PUSH
46631: FOR_TO
46632: IFFALSE 47169
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
46634: LD_ADDR_VAR 0 5
46638: PUSH
46639: LD_EXP 100
46643: PUSH
46644: LD_VAR 0 2
46648: ARRAY
46649: PUSH
46650: LD_EXP 129
46654: PUSH
46655: LD_VAR 0 2
46659: ARRAY
46660: UNION
46661: PPUSH
46662: LD_INT 21
46664: PUSH
46665: LD_INT 1
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: PUSH
46672: LD_INT 1
46674: PUSH
46675: LD_INT 3
46677: PUSH
46678: LD_INT 54
46680: PUSH
46681: EMPTY
46682: LIST
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: LD_INT 24
46693: PUSH
46694: LD_INT 1000
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: EMPTY
46702: LIST
46703: LIST
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: LIST
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PPUSH
46714: CALL_OW 72
46718: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
46719: LD_ADDR_VAR 0 6
46723: PUSH
46724: LD_EXP 100
46728: PUSH
46729: LD_VAR 0 2
46733: ARRAY
46734: PPUSH
46735: LD_INT 21
46737: PUSH
46738: LD_INT 1
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: PUSH
46745: LD_INT 1
46747: PUSH
46748: LD_INT 3
46750: PUSH
46751: LD_INT 54
46753: PUSH
46754: EMPTY
46755: LIST
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: LD_INT 3
46763: PUSH
46764: LD_INT 24
46766: PUSH
46767: LD_INT 250
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: PUSH
46778: EMPTY
46779: LIST
46780: LIST
46781: LIST
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PPUSH
46787: CALL_OW 72
46791: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
46792: LD_ADDR_VAR 0 7
46796: PUSH
46797: LD_VAR 0 5
46801: PUSH
46802: LD_VAR 0 6
46806: DIFF
46807: ST_TO_ADDR
// if not need_heal_1 then
46808: LD_VAR 0 6
46812: NOT
46813: IFFALSE 46846
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
46815: LD_ADDR_EXP 103
46819: PUSH
46820: LD_EXP 103
46824: PPUSH
46825: LD_VAR 0 2
46829: PUSH
46830: LD_INT 1
46832: PUSH
46833: EMPTY
46834: LIST
46835: LIST
46836: PPUSH
46837: EMPTY
46838: PPUSH
46839: CALL 73757 0 3
46843: ST_TO_ADDR
46844: GO 46916
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
46846: LD_ADDR_EXP 103
46850: PUSH
46851: LD_EXP 103
46855: PPUSH
46856: LD_VAR 0 2
46860: PUSH
46861: LD_INT 1
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PPUSH
46868: LD_EXP 103
46872: PUSH
46873: LD_VAR 0 2
46877: ARRAY
46878: PUSH
46879: LD_INT 1
46881: ARRAY
46882: PPUSH
46883: LD_INT 3
46885: PUSH
46886: LD_INT 24
46888: PUSH
46889: LD_INT 1000
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PPUSH
46900: CALL_OW 72
46904: PUSH
46905: LD_VAR 0 6
46909: UNION
46910: PPUSH
46911: CALL 73757 0 3
46915: ST_TO_ADDR
// if not need_heal_2 then
46916: LD_VAR 0 7
46920: NOT
46921: IFFALSE 46954
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
46923: LD_ADDR_EXP 103
46927: PUSH
46928: LD_EXP 103
46932: PPUSH
46933: LD_VAR 0 2
46937: PUSH
46938: LD_INT 2
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: PPUSH
46945: EMPTY
46946: PPUSH
46947: CALL 73757 0 3
46951: ST_TO_ADDR
46952: GO 46986
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
46954: LD_ADDR_EXP 103
46958: PUSH
46959: LD_EXP 103
46963: PPUSH
46964: LD_VAR 0 2
46968: PUSH
46969: LD_INT 2
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PPUSH
46976: LD_VAR 0 7
46980: PPUSH
46981: CALL 73757 0 3
46985: ST_TO_ADDR
// if need_heal_2 then
46986: LD_VAR 0 7
46990: IFFALSE 47151
// for j in need_heal_2 do
46992: LD_ADDR_VAR 0 3
46996: PUSH
46997: LD_VAR 0 7
47001: PUSH
47002: FOR_IN
47003: IFFALSE 47149
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47005: LD_ADDR_VAR 0 5
47009: PUSH
47010: LD_EXP 100
47014: PUSH
47015: LD_VAR 0 2
47019: ARRAY
47020: PPUSH
47021: LD_INT 2
47023: PUSH
47024: LD_INT 30
47026: PUSH
47027: LD_INT 6
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 30
47036: PUSH
47037: LD_INT 7
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 30
47046: PUSH
47047: LD_INT 8
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 30
47056: PUSH
47057: LD_INT 0
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: PUSH
47064: LD_INT 30
47066: PUSH
47067: LD_INT 1
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: PPUSH
47082: CALL_OW 72
47086: ST_TO_ADDR
// if tmp then
47087: LD_VAR 0 5
47091: IFFALSE 47147
// begin k := NearestUnitToUnit ( tmp , j ) ;
47093: LD_ADDR_VAR 0 4
47097: PUSH
47098: LD_VAR 0 5
47102: PPUSH
47103: LD_VAR 0 3
47107: PPUSH
47108: CALL_OW 74
47112: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47113: LD_VAR 0 3
47117: PPUSH
47118: LD_VAR 0 4
47122: PPUSH
47123: CALL_OW 296
47127: PUSH
47128: LD_INT 5
47130: GREATER
47131: IFFALSE 47147
// ComMoveToNearbyEntrance ( j , k ) ;
47133: LD_VAR 0 3
47137: PPUSH
47138: LD_VAR 0 4
47142: PPUSH
47143: CALL 106964 0 2
// end ; end ;
47147: GO 47002
47149: POP
47150: POP
// if not need_heal_1 and not need_heal_2 then
47151: LD_VAR 0 6
47155: NOT
47156: PUSH
47157: LD_VAR 0 7
47161: NOT
47162: AND
47163: IFFALSE 47167
// continue ;
47165: GO 46631
// end ;
47167: GO 46631
47169: POP
47170: POP
// RaiseSailEvent ( 102 ) ;
47171: LD_INT 102
47173: PPUSH
47174: CALL_OW 427
// end ;
47178: LD_VAR 0 1
47182: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47183: LD_INT 0
47185: PPUSH
47186: PPUSH
47187: PPUSH
47188: PPUSH
47189: PPUSH
47190: PPUSH
47191: PPUSH
47192: PPUSH
// if not mc_bases then
47193: LD_EXP 100
47197: NOT
47198: IFFALSE 47202
// exit ;
47200: GO 48113
// for i = 1 to mc_bases do
47202: LD_ADDR_VAR 0 2
47206: PUSH
47207: DOUBLE
47208: LD_INT 1
47210: DEC
47211: ST_TO_ADDR
47212: LD_EXP 100
47216: PUSH
47217: FOR_TO
47218: IFFALSE 48111
// begin if not mc_building_need_repair [ i ] then
47220: LD_EXP 101
47224: PUSH
47225: LD_VAR 0 2
47229: ARRAY
47230: NOT
47231: IFFALSE 47416
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
47233: LD_ADDR_VAR 0 6
47237: PUSH
47238: LD_EXP 119
47242: PUSH
47243: LD_VAR 0 2
47247: ARRAY
47248: PPUSH
47249: LD_INT 3
47251: PUSH
47252: LD_INT 24
47254: PUSH
47255: LD_INT 1000
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PUSH
47266: LD_INT 2
47268: PUSH
47269: LD_INT 34
47271: PUSH
47272: LD_INT 13
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 34
47281: PUSH
47282: LD_INT 52
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 34
47291: PUSH
47292: LD_INT 88
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: EMPTY
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: PPUSH
47309: CALL_OW 72
47313: ST_TO_ADDR
// if cranes then
47314: LD_VAR 0 6
47318: IFFALSE 47380
// for j in cranes do
47320: LD_ADDR_VAR 0 3
47324: PUSH
47325: LD_VAR 0 6
47329: PUSH
47330: FOR_IN
47331: IFFALSE 47378
// if not IsInArea ( j , mc_parking [ i ] ) then
47333: LD_VAR 0 3
47337: PPUSH
47338: LD_EXP 124
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: PPUSH
47349: CALL_OW 308
47353: NOT
47354: IFFALSE 47376
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47356: LD_VAR 0 3
47360: PPUSH
47361: LD_EXP 124
47365: PUSH
47366: LD_VAR 0 2
47370: ARRAY
47371: PPUSH
47372: CALL_OW 113
47376: GO 47330
47378: POP
47379: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
47380: LD_ADDR_EXP 102
47384: PUSH
47385: LD_EXP 102
47389: PPUSH
47390: LD_VAR 0 2
47394: PPUSH
47395: EMPTY
47396: PPUSH
47397: CALL_OW 1
47401: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
47402: LD_VAR 0 2
47406: PPUSH
47407: LD_INT 101
47409: PPUSH
47410: CALL 42270 0 2
// continue ;
47414: GO 47217
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
47416: LD_ADDR_EXP 106
47420: PUSH
47421: LD_EXP 106
47425: PPUSH
47426: LD_VAR 0 2
47430: PPUSH
47431: EMPTY
47432: PPUSH
47433: CALL_OW 1
47437: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47438: LD_VAR 0 2
47442: PPUSH
47443: LD_INT 103
47445: PPUSH
47446: CALL 42270 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
47450: LD_ADDR_VAR 0 5
47454: PUSH
47455: LD_EXP 100
47459: PUSH
47460: LD_VAR 0 2
47464: ARRAY
47465: PUSH
47466: LD_EXP 129
47470: PUSH
47471: LD_VAR 0 2
47475: ARRAY
47476: UNION
47477: PPUSH
47478: LD_INT 2
47480: PUSH
47481: LD_INT 25
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: EMPTY
47488: LIST
47489: LIST
47490: PUSH
47491: LD_INT 25
47493: PUSH
47494: LD_INT 16
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: LIST
47505: PUSH
47506: EMPTY
47507: LIST
47508: PPUSH
47509: CALL_OW 72
47513: ST_TO_ADDR
// if mc_need_heal [ i ] then
47514: LD_EXP 103
47518: PUSH
47519: LD_VAR 0 2
47523: ARRAY
47524: IFFALSE 47568
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
47526: LD_ADDR_VAR 0 5
47530: PUSH
47531: LD_VAR 0 5
47535: PUSH
47536: LD_EXP 103
47540: PUSH
47541: LD_VAR 0 2
47545: ARRAY
47546: PUSH
47547: LD_INT 1
47549: ARRAY
47550: PUSH
47551: LD_EXP 103
47555: PUSH
47556: LD_VAR 0 2
47560: ARRAY
47561: PUSH
47562: LD_INT 2
47564: ARRAY
47565: UNION
47566: DIFF
47567: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
47568: LD_ADDR_VAR 0 6
47572: PUSH
47573: LD_EXP 119
47577: PUSH
47578: LD_VAR 0 2
47582: ARRAY
47583: PPUSH
47584: LD_INT 2
47586: PUSH
47587: LD_INT 34
47589: PUSH
47590: LD_INT 13
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: PUSH
47597: LD_INT 34
47599: PUSH
47600: LD_INT 52
47602: PUSH
47603: EMPTY
47604: LIST
47605: LIST
47606: PUSH
47607: LD_INT 34
47609: PUSH
47610: LD_INT 88
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: PPUSH
47623: CALL_OW 72
47627: ST_TO_ADDR
// if cranes then
47628: LD_VAR 0 6
47632: IFFALSE 47800
// begin for j in cranes do
47634: LD_ADDR_VAR 0 3
47638: PUSH
47639: LD_VAR 0 6
47643: PUSH
47644: FOR_IN
47645: IFFALSE 47798
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
47647: LD_VAR 0 3
47651: PPUSH
47652: CALL_OW 256
47656: PUSH
47657: LD_INT 1000
47659: EQUAL
47660: PUSH
47661: LD_VAR 0 3
47665: PPUSH
47666: CALL_OW 314
47670: NOT
47671: AND
47672: IFFALSE 47738
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
47674: LD_ADDR_VAR 0 8
47678: PUSH
47679: LD_EXP 101
47683: PUSH
47684: LD_VAR 0 2
47688: ARRAY
47689: PPUSH
47690: LD_VAR 0 3
47694: PPUSH
47695: CALL_OW 74
47699: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
47700: LD_VAR 0 8
47704: PPUSH
47705: LD_INT 16
47707: PPUSH
47708: CALL 76354 0 2
47712: PUSH
47713: LD_INT 4
47715: ARRAY
47716: PUSH
47717: LD_INT 10
47719: LESS
47720: IFFALSE 47736
// ComRepairBuilding ( j , to_repair ) ;
47722: LD_VAR 0 3
47726: PPUSH
47727: LD_VAR 0 8
47731: PPUSH
47732: CALL_OW 130
// end else
47736: GO 47796
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
47738: LD_VAR 0 3
47742: PPUSH
47743: CALL_OW 256
47747: PUSH
47748: LD_INT 500
47750: LESS
47751: PUSH
47752: LD_VAR 0 3
47756: PPUSH
47757: LD_EXP 124
47761: PUSH
47762: LD_VAR 0 2
47766: ARRAY
47767: PPUSH
47768: CALL_OW 308
47772: NOT
47773: AND
47774: IFFALSE 47796
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47776: LD_VAR 0 3
47780: PPUSH
47781: LD_EXP 124
47785: PUSH
47786: LD_VAR 0 2
47790: ARRAY
47791: PPUSH
47792: CALL_OW 113
// end ;
47796: GO 47644
47798: POP
47799: POP
// end ; if tmp > 3 then
47800: LD_VAR 0 5
47804: PUSH
47805: LD_INT 3
47807: GREATER
47808: IFFALSE 47828
// tmp := ShrinkArray ( tmp , 4 ) ;
47810: LD_ADDR_VAR 0 5
47814: PUSH
47815: LD_VAR 0 5
47819: PPUSH
47820: LD_INT 4
47822: PPUSH
47823: CALL 106402 0 2
47827: ST_TO_ADDR
// if not tmp then
47828: LD_VAR 0 5
47832: NOT
47833: IFFALSE 47837
// continue ;
47835: GO 47217
// for j in tmp do
47837: LD_ADDR_VAR 0 3
47841: PUSH
47842: LD_VAR 0 5
47846: PUSH
47847: FOR_IN
47848: IFFALSE 48107
// begin if IsInUnit ( j ) then
47850: LD_VAR 0 3
47854: PPUSH
47855: CALL_OW 310
47859: IFFALSE 47870
// ComExitBuilding ( j ) ;
47861: LD_VAR 0 3
47865: PPUSH
47866: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
47870: LD_VAR 0 3
47874: PUSH
47875: LD_EXP 102
47879: PUSH
47880: LD_VAR 0 2
47884: ARRAY
47885: IN
47886: NOT
47887: IFFALSE 47945
// begin SetTag ( j , 101 ) ;
47889: LD_VAR 0 3
47893: PPUSH
47894: LD_INT 101
47896: PPUSH
47897: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
47901: LD_ADDR_EXP 102
47905: PUSH
47906: LD_EXP 102
47910: PPUSH
47911: LD_VAR 0 2
47915: PUSH
47916: LD_EXP 102
47920: PUSH
47921: LD_VAR 0 2
47925: ARRAY
47926: PUSH
47927: LD_INT 1
47929: PLUS
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: PPUSH
47935: LD_VAR 0 3
47939: PPUSH
47940: CALL 73757 0 3
47944: ST_TO_ADDR
// end ; wait ( 1 ) ;
47945: LD_INT 1
47947: PPUSH
47948: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
47952: LD_ADDR_VAR 0 7
47956: PUSH
47957: LD_EXP 101
47961: PUSH
47962: LD_VAR 0 2
47966: ARRAY
47967: ST_TO_ADDR
// if mc_scan [ i ] then
47968: LD_EXP 123
47972: PUSH
47973: LD_VAR 0 2
47977: ARRAY
47978: IFFALSE 48040
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
47980: LD_ADDR_VAR 0 7
47984: PUSH
47985: LD_EXP 101
47989: PUSH
47990: LD_VAR 0 2
47994: ARRAY
47995: PPUSH
47996: LD_INT 3
47998: PUSH
47999: LD_INT 30
48001: PUSH
48002: LD_INT 32
48004: PUSH
48005: EMPTY
48006: LIST
48007: LIST
48008: PUSH
48009: LD_INT 30
48011: PUSH
48012: LD_INT 33
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: PUSH
48019: LD_INT 30
48021: PUSH
48022: LD_INT 31
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: PPUSH
48035: CALL_OW 72
48039: ST_TO_ADDR
// if not to_repair_tmp then
48040: LD_VAR 0 7
48044: NOT
48045: IFFALSE 48049
// continue ;
48047: GO 47847
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48049: LD_ADDR_VAR 0 8
48053: PUSH
48054: LD_VAR 0 7
48058: PPUSH
48059: LD_VAR 0 3
48063: PPUSH
48064: CALL_OW 74
48068: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48069: LD_VAR 0 8
48073: PPUSH
48074: LD_INT 16
48076: PPUSH
48077: CALL 76354 0 2
48081: PUSH
48082: LD_INT 4
48084: ARRAY
48085: PUSH
48086: LD_INT 14
48088: LESS
48089: IFFALSE 48105
// ComRepairBuilding ( j , to_repair ) ;
48091: LD_VAR 0 3
48095: PPUSH
48096: LD_VAR 0 8
48100: PPUSH
48101: CALL_OW 130
// end ;
48105: GO 47847
48107: POP
48108: POP
// end ;
48109: GO 47217
48111: POP
48112: POP
// end ;
48113: LD_VAR 0 1
48117: RET
// export function MC_Heal ; var i , j , tmp ; begin
48118: LD_INT 0
48120: PPUSH
48121: PPUSH
48122: PPUSH
48123: PPUSH
// if not mc_bases then
48124: LD_EXP 100
48128: NOT
48129: IFFALSE 48133
// exit ;
48131: GO 48535
// for i = 1 to mc_bases do
48133: LD_ADDR_VAR 0 2
48137: PUSH
48138: DOUBLE
48139: LD_INT 1
48141: DEC
48142: ST_TO_ADDR
48143: LD_EXP 100
48147: PUSH
48148: FOR_TO
48149: IFFALSE 48533
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48151: LD_EXP 103
48155: PUSH
48156: LD_VAR 0 2
48160: ARRAY
48161: PUSH
48162: LD_INT 1
48164: ARRAY
48165: NOT
48166: PUSH
48167: LD_EXP 103
48171: PUSH
48172: LD_VAR 0 2
48176: ARRAY
48177: PUSH
48178: LD_INT 2
48180: ARRAY
48181: NOT
48182: AND
48183: IFFALSE 48221
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48185: LD_ADDR_EXP 104
48189: PUSH
48190: LD_EXP 104
48194: PPUSH
48195: LD_VAR 0 2
48199: PPUSH
48200: EMPTY
48201: PPUSH
48202: CALL_OW 1
48206: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
48207: LD_VAR 0 2
48211: PPUSH
48212: LD_INT 102
48214: PPUSH
48215: CALL 42270 0 2
// continue ;
48219: GO 48148
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
48221: LD_ADDR_VAR 0 4
48225: PUSH
48226: LD_EXP 100
48230: PUSH
48231: LD_VAR 0 2
48235: ARRAY
48236: PPUSH
48237: LD_INT 25
48239: PUSH
48240: LD_INT 4
48242: PUSH
48243: EMPTY
48244: LIST
48245: LIST
48246: PPUSH
48247: CALL_OW 72
48251: ST_TO_ADDR
// if not tmp then
48252: LD_VAR 0 4
48256: NOT
48257: IFFALSE 48261
// continue ;
48259: GO 48148
// if mc_taming [ i ] then
48261: LD_EXP 131
48265: PUSH
48266: LD_VAR 0 2
48270: ARRAY
48271: IFFALSE 48295
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48273: LD_ADDR_EXP 131
48277: PUSH
48278: LD_EXP 131
48282: PPUSH
48283: LD_VAR 0 2
48287: PPUSH
48288: EMPTY
48289: PPUSH
48290: CALL_OW 1
48294: ST_TO_ADDR
// for j in tmp do
48295: LD_ADDR_VAR 0 3
48299: PUSH
48300: LD_VAR 0 4
48304: PUSH
48305: FOR_IN
48306: IFFALSE 48529
// begin if IsInUnit ( j ) then
48308: LD_VAR 0 3
48312: PPUSH
48313: CALL_OW 310
48317: IFFALSE 48328
// ComExitBuilding ( j ) ;
48319: LD_VAR 0 3
48323: PPUSH
48324: CALL_OW 122
// if not j in mc_healers [ i ] then
48328: LD_VAR 0 3
48332: PUSH
48333: LD_EXP 104
48337: PUSH
48338: LD_VAR 0 2
48342: ARRAY
48343: IN
48344: NOT
48345: IFFALSE 48391
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
48347: LD_ADDR_EXP 104
48351: PUSH
48352: LD_EXP 104
48356: PPUSH
48357: LD_VAR 0 2
48361: PUSH
48362: LD_EXP 104
48366: PUSH
48367: LD_VAR 0 2
48371: ARRAY
48372: PUSH
48373: LD_INT 1
48375: PLUS
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PPUSH
48381: LD_VAR 0 3
48385: PPUSH
48386: CALL 73757 0 3
48390: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
48391: LD_VAR 0 3
48395: PPUSH
48396: CALL_OW 110
48400: PUSH
48401: LD_INT 102
48403: NONEQUAL
48404: IFFALSE 48418
// SetTag ( j , 102 ) ;
48406: LD_VAR 0 3
48410: PPUSH
48411: LD_INT 102
48413: PPUSH
48414: CALL_OW 109
// Wait ( 3 ) ;
48418: LD_INT 3
48420: PPUSH
48421: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
48425: LD_EXP 103
48429: PUSH
48430: LD_VAR 0 2
48434: ARRAY
48435: PUSH
48436: LD_INT 1
48438: ARRAY
48439: IFFALSE 48471
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
48441: LD_VAR 0 3
48445: PPUSH
48446: LD_EXP 103
48450: PUSH
48451: LD_VAR 0 2
48455: ARRAY
48456: PUSH
48457: LD_INT 1
48459: ARRAY
48460: PUSH
48461: LD_INT 1
48463: ARRAY
48464: PPUSH
48465: CALL_OW 128
48469: GO 48527
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
48471: LD_VAR 0 3
48475: PPUSH
48476: CALL_OW 314
48480: NOT
48481: PUSH
48482: LD_EXP 103
48486: PUSH
48487: LD_VAR 0 2
48491: ARRAY
48492: PUSH
48493: LD_INT 2
48495: ARRAY
48496: AND
48497: IFFALSE 48527
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
48499: LD_VAR 0 3
48503: PPUSH
48504: LD_EXP 103
48508: PUSH
48509: LD_VAR 0 2
48513: ARRAY
48514: PUSH
48515: LD_INT 2
48517: ARRAY
48518: PUSH
48519: LD_INT 1
48521: ARRAY
48522: PPUSH
48523: CALL_OW 128
// end ;
48527: GO 48305
48529: POP
48530: POP
// end ;
48531: GO 48148
48533: POP
48534: POP
// end ;
48535: LD_VAR 0 1
48539: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
48540: LD_INT 0
48542: PPUSH
48543: PPUSH
48544: PPUSH
48545: PPUSH
48546: PPUSH
48547: PPUSH
// if not mc_bases then
48548: LD_EXP 100
48552: NOT
48553: IFFALSE 48557
// exit ;
48555: GO 49720
// for i = 1 to mc_bases do
48557: LD_ADDR_VAR 0 2
48561: PUSH
48562: DOUBLE
48563: LD_INT 1
48565: DEC
48566: ST_TO_ADDR
48567: LD_EXP 100
48571: PUSH
48572: FOR_TO
48573: IFFALSE 49718
// begin if mc_scan [ i ] then
48575: LD_EXP 123
48579: PUSH
48580: LD_VAR 0 2
48584: ARRAY
48585: IFFALSE 48589
// continue ;
48587: GO 48572
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
48589: LD_EXP 105
48593: PUSH
48594: LD_VAR 0 2
48598: ARRAY
48599: NOT
48600: PUSH
48601: LD_EXP 107
48605: PUSH
48606: LD_VAR 0 2
48610: ARRAY
48611: NOT
48612: AND
48613: PUSH
48614: LD_EXP 106
48618: PUSH
48619: LD_VAR 0 2
48623: ARRAY
48624: AND
48625: IFFALSE 48663
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
48627: LD_ADDR_EXP 106
48631: PUSH
48632: LD_EXP 106
48636: PPUSH
48637: LD_VAR 0 2
48641: PPUSH
48642: EMPTY
48643: PPUSH
48644: CALL_OW 1
48648: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48649: LD_VAR 0 2
48653: PPUSH
48654: LD_INT 103
48656: PPUSH
48657: CALL 42270 0 2
// continue ;
48661: GO 48572
// end ; if mc_construct_list [ i ] then
48663: LD_EXP 107
48667: PUSH
48668: LD_VAR 0 2
48672: ARRAY
48673: IFFALSE 48893
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48675: LD_ADDR_VAR 0 5
48679: PUSH
48680: LD_EXP 100
48684: PUSH
48685: LD_VAR 0 2
48689: ARRAY
48690: PPUSH
48691: LD_INT 25
48693: PUSH
48694: LD_INT 2
48696: PUSH
48697: EMPTY
48698: LIST
48699: LIST
48700: PPUSH
48701: CALL_OW 72
48705: PUSH
48706: LD_EXP 102
48710: PUSH
48711: LD_VAR 0 2
48715: ARRAY
48716: DIFF
48717: ST_TO_ADDR
// if not tmp then
48718: LD_VAR 0 5
48722: NOT
48723: IFFALSE 48727
// continue ;
48725: GO 48572
// for j in tmp do
48727: LD_ADDR_VAR 0 3
48731: PUSH
48732: LD_VAR 0 5
48736: PUSH
48737: FOR_IN
48738: IFFALSE 48889
// begin if not mc_builders [ i ] then
48740: LD_EXP 106
48744: PUSH
48745: LD_VAR 0 2
48749: ARRAY
48750: NOT
48751: IFFALSE 48809
// begin SetTag ( j , 103 ) ;
48753: LD_VAR 0 3
48757: PPUSH
48758: LD_INT 103
48760: PPUSH
48761: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48765: LD_ADDR_EXP 106
48769: PUSH
48770: LD_EXP 106
48774: PPUSH
48775: LD_VAR 0 2
48779: PUSH
48780: LD_EXP 106
48784: PUSH
48785: LD_VAR 0 2
48789: ARRAY
48790: PUSH
48791: LD_INT 1
48793: PLUS
48794: PUSH
48795: EMPTY
48796: LIST
48797: LIST
48798: PPUSH
48799: LD_VAR 0 3
48803: PPUSH
48804: CALL 73757 0 3
48808: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48809: LD_VAR 0 3
48813: PPUSH
48814: CALL_OW 310
48818: IFFALSE 48829
// ComExitBuilding ( j ) ;
48820: LD_VAR 0 3
48824: PPUSH
48825: CALL_OW 122
// wait ( 3 ) ;
48829: LD_INT 3
48831: PPUSH
48832: CALL_OW 67
// if not mc_construct_list [ i ] then
48836: LD_EXP 107
48840: PUSH
48841: LD_VAR 0 2
48845: ARRAY
48846: NOT
48847: IFFALSE 48851
// break ;
48849: GO 48889
// if not HasTask ( j ) then
48851: LD_VAR 0 3
48855: PPUSH
48856: CALL_OW 314
48860: NOT
48861: IFFALSE 48887
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
48863: LD_VAR 0 3
48867: PPUSH
48868: LD_EXP 107
48872: PUSH
48873: LD_VAR 0 2
48877: ARRAY
48878: PUSH
48879: LD_INT 1
48881: ARRAY
48882: PPUSH
48883: CALL 76618 0 2
// end ;
48887: GO 48737
48889: POP
48890: POP
// end else
48891: GO 49716
// if mc_build_list [ i ] then
48893: LD_EXP 105
48897: PUSH
48898: LD_VAR 0 2
48902: ARRAY
48903: IFFALSE 49716
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
48905: LD_EXP 105
48909: PUSH
48910: LD_VAR 0 2
48914: ARRAY
48915: PUSH
48916: LD_INT 1
48918: ARRAY
48919: PUSH
48920: LD_INT 1
48922: ARRAY
48923: PPUSH
48924: CALL 76442 0 1
48928: PUSH
48929: LD_EXP 100
48933: PUSH
48934: LD_VAR 0 2
48938: ARRAY
48939: PPUSH
48940: LD_INT 2
48942: PUSH
48943: LD_INT 30
48945: PUSH
48946: LD_INT 2
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 30
48955: PUSH
48956: LD_INT 3
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: EMPTY
48964: LIST
48965: LIST
48966: LIST
48967: PPUSH
48968: CALL_OW 72
48972: NOT
48973: AND
48974: IFFALSE 49079
// begin for j = 1 to mc_build_list [ i ] do
48976: LD_ADDR_VAR 0 3
48980: PUSH
48981: DOUBLE
48982: LD_INT 1
48984: DEC
48985: ST_TO_ADDR
48986: LD_EXP 105
48990: PUSH
48991: LD_VAR 0 2
48995: ARRAY
48996: PUSH
48997: FOR_TO
48998: IFFALSE 49077
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49000: LD_EXP 105
49004: PUSH
49005: LD_VAR 0 2
49009: ARRAY
49010: PUSH
49011: LD_VAR 0 3
49015: ARRAY
49016: PUSH
49017: LD_INT 1
49019: ARRAY
49020: PUSH
49021: LD_INT 2
49023: EQUAL
49024: IFFALSE 49075
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49026: LD_ADDR_EXP 105
49030: PUSH
49031: LD_EXP 105
49035: PPUSH
49036: LD_VAR 0 2
49040: PPUSH
49041: LD_EXP 105
49045: PUSH
49046: LD_VAR 0 2
49050: ARRAY
49051: PPUSH
49052: LD_VAR 0 3
49056: PPUSH
49057: LD_INT 1
49059: PPUSH
49060: LD_INT 0
49062: PPUSH
49063: CALL 73175 0 4
49067: PPUSH
49068: CALL_OW 1
49072: ST_TO_ADDR
// break ;
49073: GO 49077
// end ;
49075: GO 48997
49077: POP
49078: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49079: LD_ADDR_VAR 0 6
49083: PUSH
49084: LD_EXP 100
49088: PUSH
49089: LD_VAR 0 2
49093: ARRAY
49094: PPUSH
49095: LD_INT 2
49097: PUSH
49098: LD_INT 30
49100: PUSH
49101: LD_INT 0
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: PUSH
49108: LD_INT 30
49110: PUSH
49111: LD_INT 1
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PUSH
49118: EMPTY
49119: LIST
49120: LIST
49121: LIST
49122: PPUSH
49123: CALL_OW 72
49127: ST_TO_ADDR
// for k := 1 to depot do
49128: LD_ADDR_VAR 0 4
49132: PUSH
49133: DOUBLE
49134: LD_INT 1
49136: DEC
49137: ST_TO_ADDR
49138: LD_VAR 0 6
49142: PUSH
49143: FOR_TO
49144: IFFALSE 49714
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49146: LD_EXP 105
49150: PUSH
49151: LD_VAR 0 2
49155: ARRAY
49156: PUSH
49157: LD_INT 1
49159: ARRAY
49160: PUSH
49161: LD_INT 1
49163: ARRAY
49164: PUSH
49165: LD_INT 0
49167: EQUAL
49168: PUSH
49169: LD_VAR 0 6
49173: PUSH
49174: LD_VAR 0 4
49178: ARRAY
49179: PPUSH
49180: LD_EXP 105
49184: PUSH
49185: LD_VAR 0 2
49189: ARRAY
49190: PUSH
49191: LD_INT 1
49193: ARRAY
49194: PUSH
49195: LD_INT 1
49197: ARRAY
49198: PPUSH
49199: LD_EXP 105
49203: PUSH
49204: LD_VAR 0 2
49208: ARRAY
49209: PUSH
49210: LD_INT 1
49212: ARRAY
49213: PUSH
49214: LD_INT 2
49216: ARRAY
49217: PPUSH
49218: LD_EXP 105
49222: PUSH
49223: LD_VAR 0 2
49227: ARRAY
49228: PUSH
49229: LD_INT 1
49231: ARRAY
49232: PUSH
49233: LD_INT 3
49235: ARRAY
49236: PPUSH
49237: LD_EXP 105
49241: PUSH
49242: LD_VAR 0 2
49246: ARRAY
49247: PUSH
49248: LD_INT 1
49250: ARRAY
49251: PUSH
49252: LD_INT 4
49254: ARRAY
49255: PPUSH
49256: CALL 81854 0 5
49260: OR
49261: IFFALSE 49542
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49263: LD_ADDR_VAR 0 5
49267: PUSH
49268: LD_EXP 100
49272: PUSH
49273: LD_VAR 0 2
49277: ARRAY
49278: PPUSH
49279: LD_INT 25
49281: PUSH
49282: LD_INT 2
49284: PUSH
49285: EMPTY
49286: LIST
49287: LIST
49288: PPUSH
49289: CALL_OW 72
49293: PUSH
49294: LD_EXP 102
49298: PUSH
49299: LD_VAR 0 2
49303: ARRAY
49304: DIFF
49305: ST_TO_ADDR
// if not tmp then
49306: LD_VAR 0 5
49310: NOT
49311: IFFALSE 49315
// continue ;
49313: GO 49143
// for j in tmp do
49315: LD_ADDR_VAR 0 3
49319: PUSH
49320: LD_VAR 0 5
49324: PUSH
49325: FOR_IN
49326: IFFALSE 49538
// begin if not mc_builders [ i ] then
49328: LD_EXP 106
49332: PUSH
49333: LD_VAR 0 2
49337: ARRAY
49338: NOT
49339: IFFALSE 49397
// begin SetTag ( j , 103 ) ;
49341: LD_VAR 0 3
49345: PPUSH
49346: LD_INT 103
49348: PPUSH
49349: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49353: LD_ADDR_EXP 106
49357: PUSH
49358: LD_EXP 106
49362: PPUSH
49363: LD_VAR 0 2
49367: PUSH
49368: LD_EXP 106
49372: PUSH
49373: LD_VAR 0 2
49377: ARRAY
49378: PUSH
49379: LD_INT 1
49381: PLUS
49382: PUSH
49383: EMPTY
49384: LIST
49385: LIST
49386: PPUSH
49387: LD_VAR 0 3
49391: PPUSH
49392: CALL 73757 0 3
49396: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49397: LD_VAR 0 3
49401: PPUSH
49402: CALL_OW 310
49406: IFFALSE 49417
// ComExitBuilding ( j ) ;
49408: LD_VAR 0 3
49412: PPUSH
49413: CALL_OW 122
// wait ( 3 ) ;
49417: LD_INT 3
49419: PPUSH
49420: CALL_OW 67
// if not mc_build_list [ i ] then
49424: LD_EXP 105
49428: PUSH
49429: LD_VAR 0 2
49433: ARRAY
49434: NOT
49435: IFFALSE 49439
// break ;
49437: GO 49538
// if not HasTask ( j ) then
49439: LD_VAR 0 3
49443: PPUSH
49444: CALL_OW 314
49448: NOT
49449: IFFALSE 49536
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
49451: LD_VAR 0 3
49455: PPUSH
49456: LD_EXP 105
49460: PUSH
49461: LD_VAR 0 2
49465: ARRAY
49466: PUSH
49467: LD_INT 1
49469: ARRAY
49470: PUSH
49471: LD_INT 1
49473: ARRAY
49474: PPUSH
49475: LD_EXP 105
49479: PUSH
49480: LD_VAR 0 2
49484: ARRAY
49485: PUSH
49486: LD_INT 1
49488: ARRAY
49489: PUSH
49490: LD_INT 2
49492: ARRAY
49493: PPUSH
49494: LD_EXP 105
49498: PUSH
49499: LD_VAR 0 2
49503: ARRAY
49504: PUSH
49505: LD_INT 1
49507: ARRAY
49508: PUSH
49509: LD_INT 3
49511: ARRAY
49512: PPUSH
49513: LD_EXP 105
49517: PUSH
49518: LD_VAR 0 2
49522: ARRAY
49523: PUSH
49524: LD_INT 1
49526: ARRAY
49527: PUSH
49528: LD_INT 4
49530: ARRAY
49531: PPUSH
49532: CALL_OW 145
// end ;
49536: GO 49325
49538: POP
49539: POP
// end else
49540: GO 49712
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
49542: LD_EXP 100
49546: PUSH
49547: LD_VAR 0 2
49551: ARRAY
49552: PPUSH
49553: LD_EXP 105
49557: PUSH
49558: LD_VAR 0 2
49562: ARRAY
49563: PUSH
49564: LD_INT 1
49566: ARRAY
49567: PUSH
49568: LD_INT 1
49570: ARRAY
49571: PPUSH
49572: LD_EXP 105
49576: PUSH
49577: LD_VAR 0 2
49581: ARRAY
49582: PUSH
49583: LD_INT 1
49585: ARRAY
49586: PUSH
49587: LD_INT 2
49589: ARRAY
49590: PPUSH
49591: LD_EXP 105
49595: PUSH
49596: LD_VAR 0 2
49600: ARRAY
49601: PUSH
49602: LD_INT 1
49604: ARRAY
49605: PUSH
49606: LD_INT 3
49608: ARRAY
49609: PPUSH
49610: LD_EXP 105
49614: PUSH
49615: LD_VAR 0 2
49619: ARRAY
49620: PUSH
49621: LD_INT 1
49623: ARRAY
49624: PUSH
49625: LD_INT 4
49627: ARRAY
49628: PPUSH
49629: LD_EXP 100
49633: PUSH
49634: LD_VAR 0 2
49638: ARRAY
49639: PPUSH
49640: LD_INT 21
49642: PUSH
49643: LD_INT 3
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PPUSH
49650: CALL_OW 72
49654: PPUSH
49655: EMPTY
49656: PPUSH
49657: CALL 80608 0 7
49661: NOT
49662: IFFALSE 49712
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
49664: LD_ADDR_EXP 105
49668: PUSH
49669: LD_EXP 105
49673: PPUSH
49674: LD_VAR 0 2
49678: PPUSH
49679: LD_EXP 105
49683: PUSH
49684: LD_VAR 0 2
49688: ARRAY
49689: PPUSH
49690: LD_INT 1
49692: PPUSH
49693: LD_INT 1
49695: NEG
49696: PPUSH
49697: LD_INT 0
49699: PPUSH
49700: CALL 73175 0 4
49704: PPUSH
49705: CALL_OW 1
49709: ST_TO_ADDR
// continue ;
49710: GO 49143
// end ; end ;
49712: GO 49143
49714: POP
49715: POP
// end ; end ;
49716: GO 48572
49718: POP
49719: POP
// end ;
49720: LD_VAR 0 1
49724: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
49725: LD_INT 0
49727: PPUSH
49728: PPUSH
49729: PPUSH
49730: PPUSH
49731: PPUSH
49732: PPUSH
// if not mc_bases then
49733: LD_EXP 100
49737: NOT
49738: IFFALSE 49742
// exit ;
49740: GO 50169
// for i = 1 to mc_bases do
49742: LD_ADDR_VAR 0 2
49746: PUSH
49747: DOUBLE
49748: LD_INT 1
49750: DEC
49751: ST_TO_ADDR
49752: LD_EXP 100
49756: PUSH
49757: FOR_TO
49758: IFFALSE 50167
// begin tmp := mc_build_upgrade [ i ] ;
49760: LD_ADDR_VAR 0 4
49764: PUSH
49765: LD_EXP 132
49769: PUSH
49770: LD_VAR 0 2
49774: ARRAY
49775: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
49776: LD_ADDR_VAR 0 6
49780: PUSH
49781: LD_EXP 133
49785: PUSH
49786: LD_VAR 0 2
49790: ARRAY
49791: PPUSH
49792: LD_INT 2
49794: PUSH
49795: LD_INT 30
49797: PUSH
49798: LD_INT 6
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 30
49807: PUSH
49808: LD_INT 7
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: EMPTY
49816: LIST
49817: LIST
49818: LIST
49819: PPUSH
49820: CALL_OW 72
49824: ST_TO_ADDR
// if not tmp and not lab then
49825: LD_VAR 0 4
49829: NOT
49830: PUSH
49831: LD_VAR 0 6
49835: NOT
49836: AND
49837: IFFALSE 49841
// continue ;
49839: GO 49757
// if tmp then
49841: LD_VAR 0 4
49845: IFFALSE 49965
// for j in tmp do
49847: LD_ADDR_VAR 0 3
49851: PUSH
49852: LD_VAR 0 4
49856: PUSH
49857: FOR_IN
49858: IFFALSE 49963
// begin if UpgradeCost ( j ) then
49860: LD_VAR 0 3
49864: PPUSH
49865: CALL 80268 0 1
49869: IFFALSE 49961
// begin ComUpgrade ( j ) ;
49871: LD_VAR 0 3
49875: PPUSH
49876: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
49880: LD_ADDR_EXP 132
49884: PUSH
49885: LD_EXP 132
49889: PPUSH
49890: LD_VAR 0 2
49894: PPUSH
49895: LD_EXP 132
49899: PUSH
49900: LD_VAR 0 2
49904: ARRAY
49905: PUSH
49906: LD_VAR 0 3
49910: DIFF
49911: PPUSH
49912: CALL_OW 1
49916: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
49917: LD_ADDR_EXP 107
49921: PUSH
49922: LD_EXP 107
49926: PPUSH
49927: LD_VAR 0 2
49931: PUSH
49932: LD_EXP 107
49936: PUSH
49937: LD_VAR 0 2
49941: ARRAY
49942: PUSH
49943: LD_INT 1
49945: PLUS
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: PPUSH
49951: LD_VAR 0 3
49955: PPUSH
49956: CALL 73757 0 3
49960: ST_TO_ADDR
// end ; end ;
49961: GO 49857
49963: POP
49964: POP
// if not lab or not mc_lab_upgrade [ i ] then
49965: LD_VAR 0 6
49969: NOT
49970: PUSH
49971: LD_EXP 134
49975: PUSH
49976: LD_VAR 0 2
49980: ARRAY
49981: NOT
49982: OR
49983: IFFALSE 49987
// continue ;
49985: GO 49757
// for j in lab do
49987: LD_ADDR_VAR 0 3
49991: PUSH
49992: LD_VAR 0 6
49996: PUSH
49997: FOR_IN
49998: IFFALSE 50163
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50000: LD_VAR 0 3
50004: PPUSH
50005: CALL_OW 266
50009: PUSH
50010: LD_INT 6
50012: PUSH
50013: LD_INT 7
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: IN
50020: PUSH
50021: LD_VAR 0 3
50025: PPUSH
50026: CALL_OW 461
50030: PUSH
50031: LD_INT 1
50033: NONEQUAL
50034: AND
50035: IFFALSE 50161
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50037: LD_VAR 0 3
50041: PPUSH
50042: LD_EXP 134
50046: PUSH
50047: LD_VAR 0 2
50051: ARRAY
50052: PUSH
50053: LD_INT 1
50055: ARRAY
50056: PPUSH
50057: CALL 80473 0 2
50061: IFFALSE 50161
// begin ComCancel ( j ) ;
50063: LD_VAR 0 3
50067: PPUSH
50068: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50072: LD_VAR 0 3
50076: PPUSH
50077: LD_EXP 134
50081: PUSH
50082: LD_VAR 0 2
50086: ARRAY
50087: PUSH
50088: LD_INT 1
50090: ARRAY
50091: PPUSH
50092: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50096: LD_VAR 0 3
50100: PUSH
50101: LD_EXP 107
50105: PUSH
50106: LD_VAR 0 2
50110: ARRAY
50111: IN
50112: NOT
50113: IFFALSE 50159
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50115: LD_ADDR_EXP 107
50119: PUSH
50120: LD_EXP 107
50124: PPUSH
50125: LD_VAR 0 2
50129: PUSH
50130: LD_EXP 107
50134: PUSH
50135: LD_VAR 0 2
50139: ARRAY
50140: PUSH
50141: LD_INT 1
50143: PLUS
50144: PUSH
50145: EMPTY
50146: LIST
50147: LIST
50148: PPUSH
50149: LD_VAR 0 3
50153: PPUSH
50154: CALL 73757 0 3
50158: ST_TO_ADDR
// break ;
50159: GO 50163
// end ; end ; end ;
50161: GO 49997
50163: POP
50164: POP
// end ;
50165: GO 49757
50167: POP
50168: POP
// end ;
50169: LD_VAR 0 1
50173: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50174: LD_INT 0
50176: PPUSH
50177: PPUSH
50178: PPUSH
50179: PPUSH
50180: PPUSH
50181: PPUSH
50182: PPUSH
50183: PPUSH
50184: PPUSH
// if not mc_bases then
50185: LD_EXP 100
50189: NOT
50190: IFFALSE 50194
// exit ;
50192: GO 50599
// for i = 1 to mc_bases do
50194: LD_ADDR_VAR 0 2
50198: PUSH
50199: DOUBLE
50200: LD_INT 1
50202: DEC
50203: ST_TO_ADDR
50204: LD_EXP 100
50208: PUSH
50209: FOR_TO
50210: IFFALSE 50597
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
50212: LD_EXP 108
50216: PUSH
50217: LD_VAR 0 2
50221: ARRAY
50222: NOT
50223: PUSH
50224: LD_EXP 100
50228: PUSH
50229: LD_VAR 0 2
50233: ARRAY
50234: PPUSH
50235: LD_INT 30
50237: PUSH
50238: LD_INT 3
50240: PUSH
50241: EMPTY
50242: LIST
50243: LIST
50244: PPUSH
50245: CALL_OW 72
50249: NOT
50250: OR
50251: IFFALSE 50255
// continue ;
50253: GO 50209
// busy := false ;
50255: LD_ADDR_VAR 0 8
50259: PUSH
50260: LD_INT 0
50262: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50263: LD_ADDR_VAR 0 4
50267: PUSH
50268: LD_EXP 100
50272: PUSH
50273: LD_VAR 0 2
50277: ARRAY
50278: PPUSH
50279: LD_INT 30
50281: PUSH
50282: LD_INT 3
50284: PUSH
50285: EMPTY
50286: LIST
50287: LIST
50288: PPUSH
50289: CALL_OW 72
50293: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
50294: LD_ADDR_VAR 0 6
50298: PUSH
50299: LD_EXP 108
50303: PUSH
50304: LD_VAR 0 2
50308: ARRAY
50309: PPUSH
50310: LD_INT 2
50312: PUSH
50313: LD_INT 30
50315: PUSH
50316: LD_INT 32
50318: PUSH
50319: EMPTY
50320: LIST
50321: LIST
50322: PUSH
50323: LD_INT 30
50325: PUSH
50326: LD_INT 33
50328: PUSH
50329: EMPTY
50330: LIST
50331: LIST
50332: PUSH
50333: EMPTY
50334: LIST
50335: LIST
50336: LIST
50337: PPUSH
50338: CALL_OW 72
50342: ST_TO_ADDR
// if not t then
50343: LD_VAR 0 6
50347: NOT
50348: IFFALSE 50352
// continue ;
50350: GO 50209
// for j in tmp do
50352: LD_ADDR_VAR 0 3
50356: PUSH
50357: LD_VAR 0 4
50361: PUSH
50362: FOR_IN
50363: IFFALSE 50393
// if not BuildingStatus ( j ) = bs_idle then
50365: LD_VAR 0 3
50369: PPUSH
50370: CALL_OW 461
50374: PUSH
50375: LD_INT 2
50377: EQUAL
50378: NOT
50379: IFFALSE 50391
// begin busy := true ;
50381: LD_ADDR_VAR 0 8
50385: PUSH
50386: LD_INT 1
50388: ST_TO_ADDR
// break ;
50389: GO 50393
// end ;
50391: GO 50362
50393: POP
50394: POP
// if busy then
50395: LD_VAR 0 8
50399: IFFALSE 50403
// continue ;
50401: GO 50209
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
50403: LD_ADDR_VAR 0 7
50407: PUSH
50408: LD_VAR 0 6
50412: PPUSH
50413: LD_INT 35
50415: PUSH
50416: LD_INT 0
50418: PUSH
50419: EMPTY
50420: LIST
50421: LIST
50422: PPUSH
50423: CALL_OW 72
50427: ST_TO_ADDR
// if tw then
50428: LD_VAR 0 7
50432: IFFALSE 50509
// begin tw := tw [ 1 ] ;
50434: LD_ADDR_VAR 0 7
50438: PUSH
50439: LD_VAR 0 7
50443: PUSH
50444: LD_INT 1
50446: ARRAY
50447: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
50448: LD_ADDR_VAR 0 9
50452: PUSH
50453: LD_VAR 0 7
50457: PPUSH
50458: LD_EXP 125
50462: PUSH
50463: LD_VAR 0 2
50467: ARRAY
50468: PPUSH
50469: CALL 78765 0 2
50473: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
50474: LD_EXP 139
50478: PUSH
50479: LD_VAR 0 2
50483: ARRAY
50484: IFFALSE 50507
// if not weapon in mc_allowed_tower_weapons [ i ] then
50486: LD_VAR 0 9
50490: PUSH
50491: LD_EXP 139
50495: PUSH
50496: LD_VAR 0 2
50500: ARRAY
50501: IN
50502: NOT
50503: IFFALSE 50507
// continue ;
50505: GO 50209
// end else
50507: GO 50572
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
50509: LD_ADDR_VAR 0 5
50513: PUSH
50514: LD_EXP 108
50518: PUSH
50519: LD_VAR 0 2
50523: ARRAY
50524: PPUSH
50525: LD_VAR 0 4
50529: PPUSH
50530: CALL 105635 0 2
50534: ST_TO_ADDR
// if not tmp2 then
50535: LD_VAR 0 5
50539: NOT
50540: IFFALSE 50544
// continue ;
50542: GO 50209
// tw := tmp2 [ 1 ] ;
50544: LD_ADDR_VAR 0 7
50548: PUSH
50549: LD_VAR 0 5
50553: PUSH
50554: LD_INT 1
50556: ARRAY
50557: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
50558: LD_ADDR_VAR 0 9
50562: PUSH
50563: LD_VAR 0 5
50567: PUSH
50568: LD_INT 2
50570: ARRAY
50571: ST_TO_ADDR
// end ; if not weapon then
50572: LD_VAR 0 9
50576: NOT
50577: IFFALSE 50581
// continue ;
50579: GO 50209
// ComPlaceWeapon ( tw , weapon ) ;
50581: LD_VAR 0 7
50585: PPUSH
50586: LD_VAR 0 9
50590: PPUSH
50591: CALL_OW 148
// end ;
50595: GO 50209
50597: POP
50598: POP
// end ;
50599: LD_VAR 0 1
50603: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
50604: LD_INT 0
50606: PPUSH
50607: PPUSH
50608: PPUSH
50609: PPUSH
50610: PPUSH
50611: PPUSH
50612: PPUSH
// if not mc_bases then
50613: LD_EXP 100
50617: NOT
50618: IFFALSE 50622
// exit ;
50620: GO 51397
// for i = 1 to mc_bases do
50622: LD_ADDR_VAR 0 2
50626: PUSH
50627: DOUBLE
50628: LD_INT 1
50630: DEC
50631: ST_TO_ADDR
50632: LD_EXP 100
50636: PUSH
50637: FOR_TO
50638: IFFALSE 51395
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
50640: LD_EXP 113
50644: PUSH
50645: LD_VAR 0 2
50649: ARRAY
50650: NOT
50651: PUSH
50652: LD_EXP 113
50656: PUSH
50657: LD_VAR 0 2
50661: ARRAY
50662: PUSH
50663: LD_EXP 114
50667: PUSH
50668: LD_VAR 0 2
50672: ARRAY
50673: EQUAL
50674: OR
50675: PUSH
50676: LD_EXP 123
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: OR
50687: IFFALSE 50691
// continue ;
50689: GO 50637
// if mc_miners [ i ] then
50691: LD_EXP 114
50695: PUSH
50696: LD_VAR 0 2
50700: ARRAY
50701: IFFALSE 51082
// begin for j = mc_miners [ i ] downto 1 do
50703: LD_ADDR_VAR 0 3
50707: PUSH
50708: DOUBLE
50709: LD_EXP 114
50713: PUSH
50714: LD_VAR 0 2
50718: ARRAY
50719: INC
50720: ST_TO_ADDR
50721: LD_INT 1
50723: PUSH
50724: FOR_DOWNTO
50725: IFFALSE 51080
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
50727: LD_EXP 114
50731: PUSH
50732: LD_VAR 0 2
50736: ARRAY
50737: PUSH
50738: LD_VAR 0 3
50742: ARRAY
50743: PPUSH
50744: CALL_OW 301
50748: PUSH
50749: LD_EXP 114
50753: PUSH
50754: LD_VAR 0 2
50758: ARRAY
50759: PUSH
50760: LD_VAR 0 3
50764: ARRAY
50765: PPUSH
50766: CALL_OW 257
50770: PUSH
50771: LD_INT 1
50773: NONEQUAL
50774: OR
50775: IFFALSE 50838
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
50777: LD_ADDR_VAR 0 5
50781: PUSH
50782: LD_EXP 114
50786: PUSH
50787: LD_VAR 0 2
50791: ARRAY
50792: PUSH
50793: LD_EXP 114
50797: PUSH
50798: LD_VAR 0 2
50802: ARRAY
50803: PUSH
50804: LD_VAR 0 3
50808: ARRAY
50809: DIFF
50810: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
50811: LD_ADDR_EXP 114
50815: PUSH
50816: LD_EXP 114
50820: PPUSH
50821: LD_VAR 0 2
50825: PPUSH
50826: LD_VAR 0 5
50830: PPUSH
50831: CALL_OW 1
50835: ST_TO_ADDR
// continue ;
50836: GO 50724
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
50838: LD_EXP 114
50842: PUSH
50843: LD_VAR 0 2
50847: ARRAY
50848: PUSH
50849: LD_VAR 0 3
50853: ARRAY
50854: PPUSH
50855: CALL_OW 257
50859: PUSH
50860: LD_INT 1
50862: EQUAL
50863: PUSH
50864: LD_EXP 114
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: PUSH
50875: LD_VAR 0 3
50879: ARRAY
50880: PPUSH
50881: CALL_OW 459
50885: NOT
50886: AND
50887: PUSH
50888: LD_EXP 114
50892: PUSH
50893: LD_VAR 0 2
50897: ARRAY
50898: PUSH
50899: LD_VAR 0 3
50903: ARRAY
50904: PPUSH
50905: CALL_OW 314
50909: NOT
50910: AND
50911: IFFALSE 51078
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
50913: LD_EXP 114
50917: PUSH
50918: LD_VAR 0 2
50922: ARRAY
50923: PUSH
50924: LD_VAR 0 3
50928: ARRAY
50929: PPUSH
50930: CALL_OW 310
50934: IFFALSE 50957
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
50936: LD_EXP 114
50940: PUSH
50941: LD_VAR 0 2
50945: ARRAY
50946: PUSH
50947: LD_VAR 0 3
50951: ARRAY
50952: PPUSH
50953: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
50957: LD_EXP 114
50961: PUSH
50962: LD_VAR 0 2
50966: ARRAY
50967: PUSH
50968: LD_VAR 0 3
50972: ARRAY
50973: PPUSH
50974: CALL_OW 314
50978: NOT
50979: IFFALSE 51078
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
50981: LD_ADDR_VAR 0 7
50985: PUSH
50986: LD_VAR 0 3
50990: PUSH
50991: LD_EXP 113
50995: PUSH
50996: LD_VAR 0 2
51000: ARRAY
51001: PPUSH
51002: CALL 70897 0 1
51006: MOD
51007: PUSH
51008: LD_INT 1
51010: PLUS
51011: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51012: LD_EXP 114
51016: PUSH
51017: LD_VAR 0 2
51021: ARRAY
51022: PUSH
51023: LD_VAR 0 3
51027: ARRAY
51028: PPUSH
51029: LD_EXP 113
51033: PUSH
51034: LD_VAR 0 2
51038: ARRAY
51039: PUSH
51040: LD_VAR 0 7
51044: ARRAY
51045: PUSH
51046: LD_INT 1
51048: ARRAY
51049: PPUSH
51050: LD_EXP 113
51054: PUSH
51055: LD_VAR 0 2
51059: ARRAY
51060: PUSH
51061: LD_VAR 0 7
51065: ARRAY
51066: PUSH
51067: LD_INT 2
51069: ARRAY
51070: PPUSH
51071: LD_INT 0
51073: PPUSH
51074: CALL_OW 193
// end ; end ; end ;
51078: GO 50724
51080: POP
51081: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51082: LD_ADDR_VAR 0 5
51086: PUSH
51087: LD_EXP 100
51091: PUSH
51092: LD_VAR 0 2
51096: ARRAY
51097: PPUSH
51098: LD_INT 2
51100: PUSH
51101: LD_INT 30
51103: PUSH
51104: LD_INT 4
51106: PUSH
51107: EMPTY
51108: LIST
51109: LIST
51110: PUSH
51111: LD_INT 30
51113: PUSH
51114: LD_INT 5
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: PUSH
51121: LD_INT 30
51123: PUSH
51124: LD_INT 32
51126: PUSH
51127: EMPTY
51128: LIST
51129: LIST
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: PPUSH
51137: CALL_OW 72
51141: ST_TO_ADDR
// if not tmp then
51142: LD_VAR 0 5
51146: NOT
51147: IFFALSE 51151
// continue ;
51149: GO 50637
// list := [ ] ;
51151: LD_ADDR_VAR 0 6
51155: PUSH
51156: EMPTY
51157: ST_TO_ADDR
// for j in tmp do
51158: LD_ADDR_VAR 0 3
51162: PUSH
51163: LD_VAR 0 5
51167: PUSH
51168: FOR_IN
51169: IFFALSE 51238
// begin for k in UnitsInside ( j ) do
51171: LD_ADDR_VAR 0 4
51175: PUSH
51176: LD_VAR 0 3
51180: PPUSH
51181: CALL_OW 313
51185: PUSH
51186: FOR_IN
51187: IFFALSE 51234
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51189: LD_VAR 0 4
51193: PPUSH
51194: CALL_OW 257
51198: PUSH
51199: LD_INT 1
51201: EQUAL
51202: PUSH
51203: LD_VAR 0 4
51207: PPUSH
51208: CALL_OW 459
51212: NOT
51213: AND
51214: IFFALSE 51232
// list := list ^ k ;
51216: LD_ADDR_VAR 0 6
51220: PUSH
51221: LD_VAR 0 6
51225: PUSH
51226: LD_VAR 0 4
51230: ADD
51231: ST_TO_ADDR
51232: GO 51186
51234: POP
51235: POP
// end ;
51236: GO 51168
51238: POP
51239: POP
// list := list diff mc_miners [ i ] ;
51240: LD_ADDR_VAR 0 6
51244: PUSH
51245: LD_VAR 0 6
51249: PUSH
51250: LD_EXP 114
51254: PUSH
51255: LD_VAR 0 2
51259: ARRAY
51260: DIFF
51261: ST_TO_ADDR
// if not list then
51262: LD_VAR 0 6
51266: NOT
51267: IFFALSE 51271
// continue ;
51269: GO 50637
// k := mc_mines [ i ] - mc_miners [ i ] ;
51271: LD_ADDR_VAR 0 4
51275: PUSH
51276: LD_EXP 113
51280: PUSH
51281: LD_VAR 0 2
51285: ARRAY
51286: PUSH
51287: LD_EXP 114
51291: PUSH
51292: LD_VAR 0 2
51296: ARRAY
51297: MINUS
51298: ST_TO_ADDR
// if k > list then
51299: LD_VAR 0 4
51303: PUSH
51304: LD_VAR 0 6
51308: GREATER
51309: IFFALSE 51321
// k := list ;
51311: LD_ADDR_VAR 0 4
51315: PUSH
51316: LD_VAR 0 6
51320: ST_TO_ADDR
// for j = 1 to k do
51321: LD_ADDR_VAR 0 3
51325: PUSH
51326: DOUBLE
51327: LD_INT 1
51329: DEC
51330: ST_TO_ADDR
51331: LD_VAR 0 4
51335: PUSH
51336: FOR_TO
51337: IFFALSE 51391
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
51339: LD_ADDR_EXP 114
51343: PUSH
51344: LD_EXP 114
51348: PPUSH
51349: LD_VAR 0 2
51353: PUSH
51354: LD_EXP 114
51358: PUSH
51359: LD_VAR 0 2
51363: ARRAY
51364: PUSH
51365: LD_INT 1
51367: PLUS
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: PPUSH
51373: LD_VAR 0 6
51377: PUSH
51378: LD_VAR 0 3
51382: ARRAY
51383: PPUSH
51384: CALL 73757 0 3
51388: ST_TO_ADDR
51389: GO 51336
51391: POP
51392: POP
// end ;
51393: GO 50637
51395: POP
51396: POP
// end ;
51397: LD_VAR 0 1
51401: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
51402: LD_INT 0
51404: PPUSH
51405: PPUSH
51406: PPUSH
51407: PPUSH
51408: PPUSH
51409: PPUSH
51410: PPUSH
51411: PPUSH
51412: PPUSH
51413: PPUSH
51414: PPUSH
// if not mc_bases then
51415: LD_EXP 100
51419: NOT
51420: IFFALSE 51424
// exit ;
51422: GO 53247
// for i = 1 to mc_bases do
51424: LD_ADDR_VAR 0 2
51428: PUSH
51429: DOUBLE
51430: LD_INT 1
51432: DEC
51433: ST_TO_ADDR
51434: LD_EXP 100
51438: PUSH
51439: FOR_TO
51440: IFFALSE 53245
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
51442: LD_EXP 100
51446: PUSH
51447: LD_VAR 0 2
51451: ARRAY
51452: NOT
51453: PUSH
51454: LD_EXP 107
51458: PUSH
51459: LD_VAR 0 2
51463: ARRAY
51464: OR
51465: IFFALSE 51469
// continue ;
51467: GO 51439
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
51469: LD_EXP 116
51473: PUSH
51474: LD_VAR 0 2
51478: ARRAY
51479: NOT
51480: PUSH
51481: LD_EXP 117
51485: PUSH
51486: LD_VAR 0 2
51490: ARRAY
51491: AND
51492: IFFALSE 51530
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
51494: LD_ADDR_EXP 117
51498: PUSH
51499: LD_EXP 117
51503: PPUSH
51504: LD_VAR 0 2
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL_OW 1
51515: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
51516: LD_VAR 0 2
51520: PPUSH
51521: LD_INT 107
51523: PPUSH
51524: CALL 42270 0 2
// continue ;
51528: GO 51439
// end ; target := [ ] ;
51530: LD_ADDR_VAR 0 7
51534: PUSH
51535: EMPTY
51536: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51537: LD_ADDR_VAR 0 6
51541: PUSH
51542: LD_EXP 100
51546: PUSH
51547: LD_VAR 0 2
51551: ARRAY
51552: PUSH
51553: LD_INT 1
51555: ARRAY
51556: PPUSH
51557: CALL_OW 255
51561: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51562: LD_ADDR_VAR 0 9
51566: PUSH
51567: LD_EXP 100
51571: PUSH
51572: LD_VAR 0 2
51576: ARRAY
51577: PPUSH
51578: LD_INT 2
51580: PUSH
51581: LD_INT 30
51583: PUSH
51584: LD_INT 0
51586: PUSH
51587: EMPTY
51588: LIST
51589: LIST
51590: PUSH
51591: LD_INT 30
51593: PUSH
51594: LD_INT 1
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: LIST
51605: PPUSH
51606: CALL_OW 72
51610: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
51611: LD_ADDR_VAR 0 3
51615: PUSH
51616: DOUBLE
51617: LD_EXP 116
51621: PUSH
51622: LD_VAR 0 2
51626: ARRAY
51627: INC
51628: ST_TO_ADDR
51629: LD_INT 1
51631: PUSH
51632: FOR_DOWNTO
51633: IFFALSE 51878
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
51635: LD_EXP 116
51639: PUSH
51640: LD_VAR 0 2
51644: ARRAY
51645: PUSH
51646: LD_VAR 0 3
51650: ARRAY
51651: PUSH
51652: LD_INT 2
51654: ARRAY
51655: PPUSH
51656: LD_EXP 116
51660: PUSH
51661: LD_VAR 0 2
51665: ARRAY
51666: PUSH
51667: LD_VAR 0 3
51671: ARRAY
51672: PUSH
51673: LD_INT 3
51675: ARRAY
51676: PPUSH
51677: CALL_OW 488
51681: PUSH
51682: LD_EXP 116
51686: PUSH
51687: LD_VAR 0 2
51691: ARRAY
51692: PUSH
51693: LD_VAR 0 3
51697: ARRAY
51698: PUSH
51699: LD_INT 2
51701: ARRAY
51702: PPUSH
51703: LD_EXP 116
51707: PUSH
51708: LD_VAR 0 2
51712: ARRAY
51713: PUSH
51714: LD_VAR 0 3
51718: ARRAY
51719: PUSH
51720: LD_INT 3
51722: ARRAY
51723: PPUSH
51724: CALL_OW 284
51728: PUSH
51729: LD_INT 0
51731: EQUAL
51732: AND
51733: IFFALSE 51788
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
51735: LD_ADDR_VAR 0 5
51739: PUSH
51740: LD_EXP 116
51744: PUSH
51745: LD_VAR 0 2
51749: ARRAY
51750: PPUSH
51751: LD_VAR 0 3
51755: PPUSH
51756: CALL_OW 3
51760: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
51761: LD_ADDR_EXP 116
51765: PUSH
51766: LD_EXP 116
51770: PPUSH
51771: LD_VAR 0 2
51775: PPUSH
51776: LD_VAR 0 5
51780: PPUSH
51781: CALL_OW 1
51785: ST_TO_ADDR
// continue ;
51786: GO 51632
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
51788: LD_VAR 0 6
51792: PPUSH
51793: LD_EXP 116
51797: PUSH
51798: LD_VAR 0 2
51802: ARRAY
51803: PUSH
51804: LD_VAR 0 3
51808: ARRAY
51809: PUSH
51810: LD_INT 2
51812: ARRAY
51813: PPUSH
51814: LD_EXP 116
51818: PUSH
51819: LD_VAR 0 2
51823: ARRAY
51824: PUSH
51825: LD_VAR 0 3
51829: ARRAY
51830: PUSH
51831: LD_INT 3
51833: ARRAY
51834: PPUSH
51835: LD_INT 30
51837: PPUSH
51838: CALL 74653 0 4
51842: PUSH
51843: LD_INT 4
51845: ARRAY
51846: PUSH
51847: LD_INT 0
51849: EQUAL
51850: IFFALSE 51876
// begin target := mc_crates [ i ] [ j ] ;
51852: LD_ADDR_VAR 0 7
51856: PUSH
51857: LD_EXP 116
51861: PUSH
51862: LD_VAR 0 2
51866: ARRAY
51867: PUSH
51868: LD_VAR 0 3
51872: ARRAY
51873: ST_TO_ADDR
// break ;
51874: GO 51878
// end ; end ;
51876: GO 51632
51878: POP
51879: POP
// if not target then
51880: LD_VAR 0 7
51884: NOT
51885: IFFALSE 51889
// continue ;
51887: GO 51439
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
51889: LD_ADDR_VAR 0 8
51893: PUSH
51894: LD_EXP 119
51898: PUSH
51899: LD_VAR 0 2
51903: ARRAY
51904: PPUSH
51905: LD_INT 2
51907: PUSH
51908: LD_INT 3
51910: PUSH
51911: LD_INT 58
51913: PUSH
51914: EMPTY
51915: LIST
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PUSH
51921: LD_INT 61
51923: PUSH
51924: EMPTY
51925: LIST
51926: PUSH
51927: LD_INT 33
51929: PUSH
51930: LD_INT 5
51932: PUSH
51933: EMPTY
51934: LIST
51935: LIST
51936: PUSH
51937: LD_INT 33
51939: PUSH
51940: LD_INT 3
51942: PUSH
51943: EMPTY
51944: LIST
51945: LIST
51946: PUSH
51947: EMPTY
51948: LIST
51949: LIST
51950: LIST
51951: LIST
51952: LIST
51953: PUSH
51954: LD_INT 2
51956: PUSH
51957: LD_INT 34
51959: PUSH
51960: LD_INT 32
51962: PUSH
51963: EMPTY
51964: LIST
51965: LIST
51966: PUSH
51967: LD_INT 34
51969: PUSH
51970: LD_INT 51
51972: PUSH
51973: EMPTY
51974: LIST
51975: LIST
51976: PUSH
51977: LD_INT 34
51979: PUSH
51980: LD_INT 12
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: LIST
51991: LIST
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PPUSH
51997: CALL_OW 72
52001: ST_TO_ADDR
// if not cargo then
52002: LD_VAR 0 8
52006: NOT
52007: IFFALSE 52713
// begin if mc_crates_collector [ i ] < 5 then
52009: LD_EXP 117
52013: PUSH
52014: LD_VAR 0 2
52018: ARRAY
52019: PUSH
52020: LD_INT 5
52022: LESS
52023: IFFALSE 52389
// begin if mc_ape [ i ] then
52025: LD_EXP 129
52029: PUSH
52030: LD_VAR 0 2
52034: ARRAY
52035: IFFALSE 52082
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52037: LD_ADDR_VAR 0 5
52041: PUSH
52042: LD_EXP 129
52046: PUSH
52047: LD_VAR 0 2
52051: ARRAY
52052: PPUSH
52053: LD_INT 25
52055: PUSH
52056: LD_INT 16
52058: PUSH
52059: EMPTY
52060: LIST
52061: LIST
52062: PUSH
52063: LD_INT 24
52065: PUSH
52066: LD_INT 750
52068: PUSH
52069: EMPTY
52070: LIST
52071: LIST
52072: PUSH
52073: EMPTY
52074: LIST
52075: LIST
52076: PPUSH
52077: CALL_OW 72
52081: ST_TO_ADDR
// if not tmp then
52082: LD_VAR 0 5
52086: NOT
52087: IFFALSE 52134
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52089: LD_ADDR_VAR 0 5
52093: PUSH
52094: LD_EXP 100
52098: PUSH
52099: LD_VAR 0 2
52103: ARRAY
52104: PPUSH
52105: LD_INT 25
52107: PUSH
52108: LD_INT 2
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: PUSH
52115: LD_INT 24
52117: PUSH
52118: LD_INT 750
52120: PUSH
52121: EMPTY
52122: LIST
52123: LIST
52124: PUSH
52125: EMPTY
52126: LIST
52127: LIST
52128: PPUSH
52129: CALL_OW 72
52133: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52134: LD_EXP 129
52138: PUSH
52139: LD_VAR 0 2
52143: ARRAY
52144: PUSH
52145: LD_EXP 100
52149: PUSH
52150: LD_VAR 0 2
52154: ARRAY
52155: PPUSH
52156: LD_INT 25
52158: PUSH
52159: LD_INT 2
52161: PUSH
52162: EMPTY
52163: LIST
52164: LIST
52165: PUSH
52166: LD_INT 24
52168: PUSH
52169: LD_INT 750
52171: PUSH
52172: EMPTY
52173: LIST
52174: LIST
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: PPUSH
52180: CALL_OW 72
52184: AND
52185: PUSH
52186: LD_VAR 0 5
52190: PUSH
52191: LD_INT 5
52193: LESS
52194: AND
52195: IFFALSE 52277
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52197: LD_ADDR_VAR 0 3
52201: PUSH
52202: LD_EXP 100
52206: PUSH
52207: LD_VAR 0 2
52211: ARRAY
52212: PPUSH
52213: LD_INT 25
52215: PUSH
52216: LD_INT 2
52218: PUSH
52219: EMPTY
52220: LIST
52221: LIST
52222: PUSH
52223: LD_INT 24
52225: PUSH
52226: LD_INT 750
52228: PUSH
52229: EMPTY
52230: LIST
52231: LIST
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: PPUSH
52237: CALL_OW 72
52241: PUSH
52242: FOR_IN
52243: IFFALSE 52275
// begin tmp := tmp union j ;
52245: LD_ADDR_VAR 0 5
52249: PUSH
52250: LD_VAR 0 5
52254: PUSH
52255: LD_VAR 0 3
52259: UNION
52260: ST_TO_ADDR
// if tmp >= 5 then
52261: LD_VAR 0 5
52265: PUSH
52266: LD_INT 5
52268: GREATEREQUAL
52269: IFFALSE 52273
// break ;
52271: GO 52275
// end ;
52273: GO 52242
52275: POP
52276: POP
// end ; if not tmp then
52277: LD_VAR 0 5
52281: NOT
52282: IFFALSE 52286
// continue ;
52284: GO 51439
// for j in tmp do
52286: LD_ADDR_VAR 0 3
52290: PUSH
52291: LD_VAR 0 5
52295: PUSH
52296: FOR_IN
52297: IFFALSE 52387
// if not GetTag ( j ) then
52299: LD_VAR 0 3
52303: PPUSH
52304: CALL_OW 110
52308: NOT
52309: IFFALSE 52385
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
52311: LD_ADDR_EXP 117
52315: PUSH
52316: LD_EXP 117
52320: PPUSH
52321: LD_VAR 0 2
52325: PUSH
52326: LD_EXP 117
52330: PUSH
52331: LD_VAR 0 2
52335: ARRAY
52336: PUSH
52337: LD_INT 1
52339: PLUS
52340: PUSH
52341: EMPTY
52342: LIST
52343: LIST
52344: PPUSH
52345: LD_VAR 0 3
52349: PPUSH
52350: CALL 73757 0 3
52354: ST_TO_ADDR
// SetTag ( j , 107 ) ;
52355: LD_VAR 0 3
52359: PPUSH
52360: LD_INT 107
52362: PPUSH
52363: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
52367: LD_EXP 117
52371: PUSH
52372: LD_VAR 0 2
52376: ARRAY
52377: PUSH
52378: LD_INT 5
52380: GREATEREQUAL
52381: IFFALSE 52385
// break ;
52383: GO 52387
// end ;
52385: GO 52296
52387: POP
52388: POP
// end ; if mc_crates_collector [ i ] and target then
52389: LD_EXP 117
52393: PUSH
52394: LD_VAR 0 2
52398: ARRAY
52399: PUSH
52400: LD_VAR 0 7
52404: AND
52405: IFFALSE 52711
// begin if mc_crates_collector [ i ] < target [ 1 ] then
52407: LD_EXP 117
52411: PUSH
52412: LD_VAR 0 2
52416: ARRAY
52417: PUSH
52418: LD_VAR 0 7
52422: PUSH
52423: LD_INT 1
52425: ARRAY
52426: LESS
52427: IFFALSE 52447
// tmp := mc_crates_collector [ i ] else
52429: LD_ADDR_VAR 0 5
52433: PUSH
52434: LD_EXP 117
52438: PUSH
52439: LD_VAR 0 2
52443: ARRAY
52444: ST_TO_ADDR
52445: GO 52461
// tmp := target [ 1 ] ;
52447: LD_ADDR_VAR 0 5
52451: PUSH
52452: LD_VAR 0 7
52456: PUSH
52457: LD_INT 1
52459: ARRAY
52460: ST_TO_ADDR
// k := 0 ;
52461: LD_ADDR_VAR 0 4
52465: PUSH
52466: LD_INT 0
52468: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
52469: LD_ADDR_VAR 0 3
52473: PUSH
52474: LD_EXP 117
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PUSH
52485: FOR_IN
52486: IFFALSE 52709
// begin k := k + 1 ;
52488: LD_ADDR_VAR 0 4
52492: PUSH
52493: LD_VAR 0 4
52497: PUSH
52498: LD_INT 1
52500: PLUS
52501: ST_TO_ADDR
// if k > tmp then
52502: LD_VAR 0 4
52506: PUSH
52507: LD_VAR 0 5
52511: GREATER
52512: IFFALSE 52516
// break ;
52514: GO 52709
// if not GetClass ( j ) in [ 2 , 16 ] then
52516: LD_VAR 0 3
52520: PPUSH
52521: CALL_OW 257
52525: PUSH
52526: LD_INT 2
52528: PUSH
52529: LD_INT 16
52531: PUSH
52532: EMPTY
52533: LIST
52534: LIST
52535: IN
52536: NOT
52537: IFFALSE 52590
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
52539: LD_ADDR_EXP 117
52543: PUSH
52544: LD_EXP 117
52548: PPUSH
52549: LD_VAR 0 2
52553: PPUSH
52554: LD_EXP 117
52558: PUSH
52559: LD_VAR 0 2
52563: ARRAY
52564: PUSH
52565: LD_VAR 0 3
52569: DIFF
52570: PPUSH
52571: CALL_OW 1
52575: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52576: LD_VAR 0 3
52580: PPUSH
52581: LD_INT 0
52583: PPUSH
52584: CALL_OW 109
// continue ;
52588: GO 52485
// end ; if IsInUnit ( j ) then
52590: LD_VAR 0 3
52594: PPUSH
52595: CALL_OW 310
52599: IFFALSE 52610
// ComExitBuilding ( j ) ;
52601: LD_VAR 0 3
52605: PPUSH
52606: CALL_OW 122
// wait ( 3 ) ;
52610: LD_INT 3
52612: PPUSH
52613: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
52617: LD_VAR 0 3
52621: PPUSH
52622: CALL_OW 314
52626: PUSH
52627: LD_VAR 0 6
52631: PPUSH
52632: LD_VAR 0 7
52636: PUSH
52637: LD_INT 2
52639: ARRAY
52640: PPUSH
52641: LD_VAR 0 7
52645: PUSH
52646: LD_INT 3
52648: ARRAY
52649: PPUSH
52650: LD_INT 30
52652: PPUSH
52653: CALL 74653 0 4
52657: PUSH
52658: LD_INT 4
52660: ARRAY
52661: AND
52662: IFFALSE 52680
// ComStandNearbyBuilding ( j , depot ) else
52664: LD_VAR 0 3
52668: PPUSH
52669: LD_VAR 0 9
52673: PPUSH
52674: CALL 70359 0 2
52678: GO 52707
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
52680: LD_VAR 0 3
52684: PPUSH
52685: LD_VAR 0 7
52689: PUSH
52690: LD_INT 2
52692: ARRAY
52693: PPUSH
52694: LD_VAR 0 7
52698: PUSH
52699: LD_INT 3
52701: ARRAY
52702: PPUSH
52703: CALL_OW 117
// end ;
52707: GO 52485
52709: POP
52710: POP
// end ; end else
52711: GO 53243
// begin for j in cargo do
52713: LD_ADDR_VAR 0 3
52717: PUSH
52718: LD_VAR 0 8
52722: PUSH
52723: FOR_IN
52724: IFFALSE 53241
// begin if GetTag ( j ) <> 0 then
52726: LD_VAR 0 3
52730: PPUSH
52731: CALL_OW 110
52735: PUSH
52736: LD_INT 0
52738: NONEQUAL
52739: IFFALSE 52743
// continue ;
52741: GO 52723
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
52743: LD_VAR 0 3
52747: PPUSH
52748: CALL_OW 256
52752: PUSH
52753: LD_INT 1000
52755: LESS
52756: PUSH
52757: LD_VAR 0 3
52761: PPUSH
52762: LD_EXP 124
52766: PUSH
52767: LD_VAR 0 2
52771: ARRAY
52772: PPUSH
52773: CALL_OW 308
52777: NOT
52778: AND
52779: IFFALSE 52801
// ComMoveToArea ( j , mc_parking [ i ] ) ;
52781: LD_VAR 0 3
52785: PPUSH
52786: LD_EXP 124
52790: PUSH
52791: LD_VAR 0 2
52795: ARRAY
52796: PPUSH
52797: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
52801: LD_VAR 0 3
52805: PPUSH
52806: CALL_OW 256
52810: PUSH
52811: LD_INT 1000
52813: LESS
52814: PUSH
52815: LD_VAR 0 3
52819: PPUSH
52820: LD_EXP 124
52824: PUSH
52825: LD_VAR 0 2
52829: ARRAY
52830: PPUSH
52831: CALL_OW 308
52835: AND
52836: IFFALSE 52840
// continue ;
52838: GO 52723
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
52840: LD_VAR 0 3
52844: PPUSH
52845: CALL_OW 262
52849: PUSH
52850: LD_INT 2
52852: EQUAL
52853: PUSH
52854: LD_VAR 0 3
52858: PPUSH
52859: CALL_OW 261
52863: PUSH
52864: LD_INT 15
52866: LESS
52867: AND
52868: IFFALSE 52872
// continue ;
52870: GO 52723
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
52872: LD_VAR 0 3
52876: PPUSH
52877: CALL_OW 262
52881: PUSH
52882: LD_INT 1
52884: EQUAL
52885: PUSH
52886: LD_VAR 0 3
52890: PPUSH
52891: CALL_OW 261
52895: PUSH
52896: LD_INT 10
52898: LESS
52899: AND
52900: IFFALSE 53180
// begin if not depot then
52902: LD_VAR 0 9
52906: NOT
52907: IFFALSE 52911
// continue ;
52909: GO 52723
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
52911: LD_VAR 0 3
52915: PPUSH
52916: LD_VAR 0 9
52920: PPUSH
52921: LD_VAR 0 3
52925: PPUSH
52926: CALL_OW 74
52930: PPUSH
52931: CALL_OW 296
52935: PUSH
52936: LD_INT 6
52938: LESS
52939: IFFALSE 52955
// SetFuel ( j , 100 ) else
52941: LD_VAR 0 3
52945: PPUSH
52946: LD_INT 100
52948: PPUSH
52949: CALL_OW 240
52953: GO 53180
// if GetFuel ( j ) = 0 then
52955: LD_VAR 0 3
52959: PPUSH
52960: CALL_OW 261
52964: PUSH
52965: LD_INT 0
52967: EQUAL
52968: IFFALSE 53180
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
52970: LD_ADDR_EXP 119
52974: PUSH
52975: LD_EXP 119
52979: PPUSH
52980: LD_VAR 0 2
52984: PPUSH
52985: LD_EXP 119
52989: PUSH
52990: LD_VAR 0 2
52994: ARRAY
52995: PUSH
52996: LD_VAR 0 3
53000: DIFF
53001: PPUSH
53002: CALL_OW 1
53006: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53007: LD_VAR 0 3
53011: PPUSH
53012: CALL_OW 263
53016: PUSH
53017: LD_INT 1
53019: EQUAL
53020: IFFALSE 53036
// ComExitVehicle ( IsInUnit ( j ) ) ;
53022: LD_VAR 0 3
53026: PPUSH
53027: CALL_OW 310
53031: PPUSH
53032: CALL_OW 121
// if GetControl ( j ) = control_remote then
53036: LD_VAR 0 3
53040: PPUSH
53041: CALL_OW 263
53045: PUSH
53046: LD_INT 2
53048: EQUAL
53049: IFFALSE 53060
// ComUnlink ( j ) ;
53051: LD_VAR 0 3
53055: PPUSH
53056: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53060: LD_ADDR_VAR 0 10
53064: PUSH
53065: LD_VAR 0 2
53069: PPUSH
53070: LD_INT 3
53072: PPUSH
53073: CALL 62824 0 2
53077: ST_TO_ADDR
// if fac then
53078: LD_VAR 0 10
53082: IFFALSE 53178
// begin for k in fac do
53084: LD_ADDR_VAR 0 4
53088: PUSH
53089: LD_VAR 0 10
53093: PUSH
53094: FOR_IN
53095: IFFALSE 53176
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53097: LD_ADDR_VAR 0 11
53101: PUSH
53102: LD_VAR 0 10
53106: PPUSH
53107: LD_VAR 0 3
53111: PPUSH
53112: CALL_OW 265
53116: PPUSH
53117: LD_VAR 0 3
53121: PPUSH
53122: CALL_OW 262
53126: PPUSH
53127: LD_VAR 0 3
53131: PPUSH
53132: CALL_OW 263
53136: PPUSH
53137: LD_VAR 0 3
53141: PPUSH
53142: CALL_OW 264
53146: PPUSH
53147: CALL 71255 0 5
53151: ST_TO_ADDR
// if components then
53152: LD_VAR 0 11
53156: IFFALSE 53174
// begin MC_InsertProduceList ( i , components ) ;
53158: LD_VAR 0 2
53162: PPUSH
53163: LD_VAR 0 11
53167: PPUSH
53168: CALL 62369 0 2
// break ;
53172: GO 53176
// end ; end ;
53174: GO 53094
53176: POP
53177: POP
// end ; continue ;
53178: GO 52723
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53180: LD_VAR 0 3
53184: PPUSH
53185: LD_INT 1
53187: PPUSH
53188: CALL_OW 289
53192: PUSH
53193: LD_INT 100
53195: LESS
53196: PUSH
53197: LD_VAR 0 3
53201: PPUSH
53202: CALL_OW 314
53206: NOT
53207: AND
53208: IFFALSE 53237
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53210: LD_VAR 0 3
53214: PPUSH
53215: LD_VAR 0 7
53219: PUSH
53220: LD_INT 2
53222: ARRAY
53223: PPUSH
53224: LD_VAR 0 7
53228: PUSH
53229: LD_INT 3
53231: ARRAY
53232: PPUSH
53233: CALL_OW 117
// break ;
53237: GO 53241
// end ;
53239: GO 52723
53241: POP
53242: POP
// end ; end ;
53243: GO 51439
53245: POP
53246: POP
// end ;
53247: LD_VAR 0 1
53251: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
53252: LD_INT 0
53254: PPUSH
53255: PPUSH
53256: PPUSH
53257: PPUSH
// if not mc_bases then
53258: LD_EXP 100
53262: NOT
53263: IFFALSE 53267
// exit ;
53265: GO 53428
// for i = 1 to mc_bases do
53267: LD_ADDR_VAR 0 2
53271: PUSH
53272: DOUBLE
53273: LD_INT 1
53275: DEC
53276: ST_TO_ADDR
53277: LD_EXP 100
53281: PUSH
53282: FOR_TO
53283: IFFALSE 53426
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
53285: LD_ADDR_VAR 0 4
53289: PUSH
53290: LD_EXP 119
53294: PUSH
53295: LD_VAR 0 2
53299: ARRAY
53300: PUSH
53301: LD_EXP 122
53305: PUSH
53306: LD_VAR 0 2
53310: ARRAY
53311: UNION
53312: PPUSH
53313: LD_INT 33
53315: PUSH
53316: LD_INT 2
53318: PUSH
53319: EMPTY
53320: LIST
53321: LIST
53322: PPUSH
53323: CALL_OW 72
53327: ST_TO_ADDR
// if tmp then
53328: LD_VAR 0 4
53332: IFFALSE 53424
// for j in tmp do
53334: LD_ADDR_VAR 0 3
53338: PUSH
53339: LD_VAR 0 4
53343: PUSH
53344: FOR_IN
53345: IFFALSE 53422
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
53347: LD_VAR 0 3
53351: PPUSH
53352: CALL_OW 312
53356: NOT
53357: PUSH
53358: LD_VAR 0 3
53362: PPUSH
53363: CALL_OW 256
53367: PUSH
53368: LD_INT 250
53370: GREATEREQUAL
53371: AND
53372: IFFALSE 53385
// Connect ( j ) else
53374: LD_VAR 0 3
53378: PPUSH
53379: CALL 76726 0 1
53383: GO 53420
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
53385: LD_VAR 0 3
53389: PPUSH
53390: CALL_OW 256
53394: PUSH
53395: LD_INT 250
53397: LESS
53398: PUSH
53399: LD_VAR 0 3
53403: PPUSH
53404: CALL_OW 312
53408: AND
53409: IFFALSE 53420
// ComUnlink ( j ) ;
53411: LD_VAR 0 3
53415: PPUSH
53416: CALL_OW 136
53420: GO 53344
53422: POP
53423: POP
// end ;
53424: GO 53282
53426: POP
53427: POP
// end ;
53428: LD_VAR 0 1
53432: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
53433: LD_INT 0
53435: PPUSH
53436: PPUSH
53437: PPUSH
53438: PPUSH
53439: PPUSH
// if not mc_bases then
53440: LD_EXP 100
53444: NOT
53445: IFFALSE 53449
// exit ;
53447: GO 53894
// for i = 1 to mc_bases do
53449: LD_ADDR_VAR 0 2
53453: PUSH
53454: DOUBLE
53455: LD_INT 1
53457: DEC
53458: ST_TO_ADDR
53459: LD_EXP 100
53463: PUSH
53464: FOR_TO
53465: IFFALSE 53892
// begin if not mc_produce [ i ] then
53467: LD_EXP 121
53471: PUSH
53472: LD_VAR 0 2
53476: ARRAY
53477: NOT
53478: IFFALSE 53482
// continue ;
53480: GO 53464
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53482: LD_ADDR_VAR 0 5
53486: PUSH
53487: LD_EXP 100
53491: PUSH
53492: LD_VAR 0 2
53496: ARRAY
53497: PPUSH
53498: LD_INT 30
53500: PUSH
53501: LD_INT 3
53503: PUSH
53504: EMPTY
53505: LIST
53506: LIST
53507: PPUSH
53508: CALL_OW 72
53512: ST_TO_ADDR
// if not fac then
53513: LD_VAR 0 5
53517: NOT
53518: IFFALSE 53522
// continue ;
53520: GO 53464
// for j in fac do
53522: LD_ADDR_VAR 0 3
53526: PUSH
53527: LD_VAR 0 5
53531: PUSH
53532: FOR_IN
53533: IFFALSE 53888
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
53535: LD_VAR 0 3
53539: PPUSH
53540: CALL_OW 461
53544: PUSH
53545: LD_INT 2
53547: NONEQUAL
53548: PUSH
53549: LD_VAR 0 3
53553: PPUSH
53554: LD_INT 15
53556: PPUSH
53557: CALL 76354 0 2
53561: PUSH
53562: LD_INT 4
53564: ARRAY
53565: OR
53566: IFFALSE 53570
// continue ;
53568: GO 53532
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
53570: LD_VAR 0 3
53574: PPUSH
53575: LD_EXP 121
53579: PUSH
53580: LD_VAR 0 2
53584: ARRAY
53585: PUSH
53586: LD_INT 1
53588: ARRAY
53589: PUSH
53590: LD_INT 1
53592: ARRAY
53593: PPUSH
53594: LD_EXP 121
53598: PUSH
53599: LD_VAR 0 2
53603: ARRAY
53604: PUSH
53605: LD_INT 1
53607: ARRAY
53608: PUSH
53609: LD_INT 2
53611: ARRAY
53612: PPUSH
53613: LD_EXP 121
53617: PUSH
53618: LD_VAR 0 2
53622: ARRAY
53623: PUSH
53624: LD_INT 1
53626: ARRAY
53627: PUSH
53628: LD_INT 3
53630: ARRAY
53631: PPUSH
53632: LD_EXP 121
53636: PUSH
53637: LD_VAR 0 2
53641: ARRAY
53642: PUSH
53643: LD_INT 1
53645: ARRAY
53646: PUSH
53647: LD_INT 4
53649: ARRAY
53650: PPUSH
53651: CALL_OW 448
53655: PUSH
53656: LD_VAR 0 3
53660: PPUSH
53661: LD_EXP 121
53665: PUSH
53666: LD_VAR 0 2
53670: ARRAY
53671: PUSH
53672: LD_INT 1
53674: ARRAY
53675: PUSH
53676: LD_INT 1
53678: ARRAY
53679: PUSH
53680: LD_EXP 121
53684: PUSH
53685: LD_VAR 0 2
53689: ARRAY
53690: PUSH
53691: LD_INT 1
53693: ARRAY
53694: PUSH
53695: LD_INT 2
53697: ARRAY
53698: PUSH
53699: LD_EXP 121
53703: PUSH
53704: LD_VAR 0 2
53708: ARRAY
53709: PUSH
53710: LD_INT 1
53712: ARRAY
53713: PUSH
53714: LD_INT 3
53716: ARRAY
53717: PUSH
53718: LD_EXP 121
53722: PUSH
53723: LD_VAR 0 2
53727: ARRAY
53728: PUSH
53729: LD_INT 1
53731: ARRAY
53732: PUSH
53733: LD_INT 4
53735: ARRAY
53736: PUSH
53737: EMPTY
53738: LIST
53739: LIST
53740: LIST
53741: LIST
53742: PPUSH
53743: CALL 80121 0 2
53747: AND
53748: IFFALSE 53886
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
53750: LD_VAR 0 3
53754: PPUSH
53755: LD_EXP 121
53759: PUSH
53760: LD_VAR 0 2
53764: ARRAY
53765: PUSH
53766: LD_INT 1
53768: ARRAY
53769: PUSH
53770: LD_INT 1
53772: ARRAY
53773: PPUSH
53774: LD_EXP 121
53778: PUSH
53779: LD_VAR 0 2
53783: ARRAY
53784: PUSH
53785: LD_INT 1
53787: ARRAY
53788: PUSH
53789: LD_INT 2
53791: ARRAY
53792: PPUSH
53793: LD_EXP 121
53797: PUSH
53798: LD_VAR 0 2
53802: ARRAY
53803: PUSH
53804: LD_INT 1
53806: ARRAY
53807: PUSH
53808: LD_INT 3
53810: ARRAY
53811: PPUSH
53812: LD_EXP 121
53816: PUSH
53817: LD_VAR 0 2
53821: ARRAY
53822: PUSH
53823: LD_INT 1
53825: ARRAY
53826: PUSH
53827: LD_INT 4
53829: ARRAY
53830: PPUSH
53831: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
53835: LD_ADDR_VAR 0 4
53839: PUSH
53840: LD_EXP 121
53844: PUSH
53845: LD_VAR 0 2
53849: ARRAY
53850: PPUSH
53851: LD_INT 1
53853: PPUSH
53854: CALL_OW 3
53858: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
53859: LD_ADDR_EXP 121
53863: PUSH
53864: LD_EXP 121
53868: PPUSH
53869: LD_VAR 0 2
53873: PPUSH
53874: LD_VAR 0 4
53878: PPUSH
53879: CALL_OW 1
53883: ST_TO_ADDR
// break ;
53884: GO 53888
// end ; end ;
53886: GO 53532
53888: POP
53889: POP
// end ;
53890: GO 53464
53892: POP
53893: POP
// end ;
53894: LD_VAR 0 1
53898: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
53899: LD_INT 0
53901: PPUSH
53902: PPUSH
53903: PPUSH
// if not mc_bases then
53904: LD_EXP 100
53908: NOT
53909: IFFALSE 53913
// exit ;
53911: GO 54002
// for i = 1 to mc_bases do
53913: LD_ADDR_VAR 0 2
53917: PUSH
53918: DOUBLE
53919: LD_INT 1
53921: DEC
53922: ST_TO_ADDR
53923: LD_EXP 100
53927: PUSH
53928: FOR_TO
53929: IFFALSE 54000
// begin if mc_attack [ i ] then
53931: LD_EXP 120
53935: PUSH
53936: LD_VAR 0 2
53940: ARRAY
53941: IFFALSE 53998
// begin tmp := mc_attack [ i ] [ 1 ] ;
53943: LD_ADDR_VAR 0 3
53947: PUSH
53948: LD_EXP 120
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: PUSH
53959: LD_INT 1
53961: ARRAY
53962: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53963: LD_ADDR_EXP 120
53967: PUSH
53968: LD_EXP 120
53972: PPUSH
53973: LD_VAR 0 2
53977: PPUSH
53978: EMPTY
53979: PPUSH
53980: CALL_OW 1
53984: ST_TO_ADDR
// Attack ( tmp ) ;
53985: LD_VAR 0 3
53989: PPUSH
53990: CALL 130250 0 1
// exit ;
53994: POP
53995: POP
53996: GO 54002
// end ; end ;
53998: GO 53928
54000: POP
54001: POP
// end ;
54002: LD_VAR 0 1
54006: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54007: LD_INT 0
54009: PPUSH
54010: PPUSH
54011: PPUSH
54012: PPUSH
54013: PPUSH
54014: PPUSH
54015: PPUSH
// if not mc_bases then
54016: LD_EXP 100
54020: NOT
54021: IFFALSE 54025
// exit ;
54023: GO 54882
// for i = 1 to mc_bases do
54025: LD_ADDR_VAR 0 2
54029: PUSH
54030: DOUBLE
54031: LD_INT 1
54033: DEC
54034: ST_TO_ADDR
54035: LD_EXP 100
54039: PUSH
54040: FOR_TO
54041: IFFALSE 54880
// begin if not mc_bases [ i ] then
54043: LD_EXP 100
54047: PUSH
54048: LD_VAR 0 2
54052: ARRAY
54053: NOT
54054: IFFALSE 54058
// continue ;
54056: GO 54040
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54058: LD_ADDR_VAR 0 7
54062: PUSH
54063: LD_EXP 100
54067: PUSH
54068: LD_VAR 0 2
54072: ARRAY
54073: PUSH
54074: LD_INT 1
54076: ARRAY
54077: PPUSH
54078: CALL 70581 0 1
54082: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54083: LD_ADDR_EXP 123
54087: PUSH
54088: LD_EXP 123
54092: PPUSH
54093: LD_VAR 0 2
54097: PPUSH
54098: LD_EXP 100
54102: PUSH
54103: LD_VAR 0 2
54107: ARRAY
54108: PUSH
54109: LD_INT 1
54111: ARRAY
54112: PPUSH
54113: CALL_OW 255
54117: PPUSH
54118: LD_EXP 125
54122: PUSH
54123: LD_VAR 0 2
54127: ARRAY
54128: PPUSH
54129: CALL 70546 0 2
54133: PPUSH
54134: CALL_OW 1
54138: ST_TO_ADDR
// if not mc_scan [ i ] then
54139: LD_EXP 123
54143: PUSH
54144: LD_VAR 0 2
54148: ARRAY
54149: NOT
54150: IFFALSE 54328
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54152: LD_ADDR_EXP 143
54156: PUSH
54157: LD_EXP 143
54161: PPUSH
54162: LD_VAR 0 2
54166: PPUSH
54167: LD_INT 0
54169: PPUSH
54170: CALL_OW 1
54174: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54175: LD_ADDR_VAR 0 4
54179: PUSH
54180: LD_EXP 100
54184: PUSH
54185: LD_VAR 0 2
54189: ARRAY
54190: PPUSH
54191: LD_INT 2
54193: PUSH
54194: LD_INT 25
54196: PUSH
54197: LD_INT 5
54199: PUSH
54200: EMPTY
54201: LIST
54202: LIST
54203: PUSH
54204: LD_INT 25
54206: PUSH
54207: LD_INT 8
54209: PUSH
54210: EMPTY
54211: LIST
54212: LIST
54213: PUSH
54214: LD_INT 25
54216: PUSH
54217: LD_INT 9
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: PUSH
54224: EMPTY
54225: LIST
54226: LIST
54227: LIST
54228: LIST
54229: PPUSH
54230: CALL_OW 72
54234: ST_TO_ADDR
// if not tmp then
54235: LD_VAR 0 4
54239: NOT
54240: IFFALSE 54244
// continue ;
54242: GO 54040
// for j in tmp do
54244: LD_ADDR_VAR 0 3
54248: PUSH
54249: LD_VAR 0 4
54253: PUSH
54254: FOR_IN
54255: IFFALSE 54326
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
54257: LD_VAR 0 3
54261: PPUSH
54262: CALL_OW 310
54266: PPUSH
54267: CALL_OW 266
54271: PUSH
54272: LD_INT 5
54274: EQUAL
54275: PUSH
54276: LD_VAR 0 3
54280: PPUSH
54281: CALL_OW 257
54285: PUSH
54286: LD_INT 1
54288: EQUAL
54289: AND
54290: PUSH
54291: LD_VAR 0 3
54295: PPUSH
54296: CALL_OW 459
54300: NOT
54301: AND
54302: PUSH
54303: LD_VAR 0 7
54307: AND
54308: IFFALSE 54324
// ComChangeProfession ( j , class ) ;
54310: LD_VAR 0 3
54314: PPUSH
54315: LD_VAR 0 7
54319: PPUSH
54320: CALL_OW 123
54324: GO 54254
54326: POP
54327: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
54328: LD_EXP 123
54332: PUSH
54333: LD_VAR 0 2
54337: ARRAY
54338: PUSH
54339: LD_EXP 143
54343: PUSH
54344: LD_VAR 0 2
54348: ARRAY
54349: NOT
54350: AND
54351: PUSH
54352: LD_EXP 122
54356: PUSH
54357: LD_VAR 0 2
54361: ARRAY
54362: NOT
54363: AND
54364: PUSH
54365: LD_EXP 100
54369: PUSH
54370: LD_VAR 0 2
54374: ARRAY
54375: PPUSH
54376: LD_INT 50
54378: PUSH
54379: EMPTY
54380: LIST
54381: PUSH
54382: LD_INT 2
54384: PUSH
54385: LD_INT 30
54387: PUSH
54388: LD_INT 32
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: PUSH
54395: LD_INT 30
54397: PUSH
54398: LD_INT 33
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PUSH
54405: LD_INT 30
54407: PUSH
54408: LD_INT 4
54410: PUSH
54411: EMPTY
54412: LIST
54413: LIST
54414: PUSH
54415: LD_INT 30
54417: PUSH
54418: LD_INT 5
54420: PUSH
54421: EMPTY
54422: LIST
54423: LIST
54424: PUSH
54425: EMPTY
54426: LIST
54427: LIST
54428: LIST
54429: LIST
54430: LIST
54431: PUSH
54432: EMPTY
54433: LIST
54434: LIST
54435: PPUSH
54436: CALL_OW 72
54440: PUSH
54441: LD_INT 4
54443: LESS
54444: PUSH
54445: LD_EXP 100
54449: PUSH
54450: LD_VAR 0 2
54454: ARRAY
54455: PPUSH
54456: LD_INT 3
54458: PUSH
54459: LD_INT 24
54461: PUSH
54462: LD_INT 1000
54464: PUSH
54465: EMPTY
54466: LIST
54467: LIST
54468: PUSH
54469: EMPTY
54470: LIST
54471: LIST
54472: PUSH
54473: LD_INT 2
54475: PUSH
54476: LD_INT 30
54478: PUSH
54479: LD_INT 0
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: LD_INT 30
54488: PUSH
54489: LD_INT 1
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: LIST
54500: PUSH
54501: EMPTY
54502: LIST
54503: LIST
54504: PPUSH
54505: CALL_OW 72
54509: OR
54510: AND
54511: IFFALSE 54762
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54513: LD_ADDR_EXP 143
54517: PUSH
54518: LD_EXP 143
54522: PPUSH
54523: LD_VAR 0 2
54527: PPUSH
54528: LD_INT 1
54530: PPUSH
54531: CALL_OW 1
54535: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54536: LD_ADDR_VAR 0 4
54540: PUSH
54541: LD_EXP 100
54545: PUSH
54546: LD_VAR 0 2
54550: ARRAY
54551: PPUSH
54552: LD_INT 2
54554: PUSH
54555: LD_INT 25
54557: PUSH
54558: LD_INT 1
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PUSH
54565: LD_INT 25
54567: PUSH
54568: LD_INT 5
54570: PUSH
54571: EMPTY
54572: LIST
54573: LIST
54574: PUSH
54575: LD_INT 25
54577: PUSH
54578: LD_INT 8
54580: PUSH
54581: EMPTY
54582: LIST
54583: LIST
54584: PUSH
54585: LD_INT 25
54587: PUSH
54588: LD_INT 9
54590: PUSH
54591: EMPTY
54592: LIST
54593: LIST
54594: PUSH
54595: EMPTY
54596: LIST
54597: LIST
54598: LIST
54599: LIST
54600: LIST
54601: PPUSH
54602: CALL_OW 72
54606: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
54607: LD_ADDR_VAR 0 4
54611: PUSH
54612: LD_VAR 0 4
54616: PUSH
54617: LD_VAR 0 4
54621: PPUSH
54622: LD_INT 18
54624: PPUSH
54625: CALL 103669 0 2
54629: DIFF
54630: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
54631: LD_VAR 0 4
54635: NOT
54636: PUSH
54637: LD_EXP 100
54641: PUSH
54642: LD_VAR 0 2
54646: ARRAY
54647: PPUSH
54648: LD_INT 2
54650: PUSH
54651: LD_INT 30
54653: PUSH
54654: LD_INT 4
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: PUSH
54661: LD_INT 30
54663: PUSH
54664: LD_INT 5
54666: PUSH
54667: EMPTY
54668: LIST
54669: LIST
54670: PUSH
54671: EMPTY
54672: LIST
54673: LIST
54674: LIST
54675: PPUSH
54676: CALL_OW 72
54680: NOT
54681: AND
54682: IFFALSE 54744
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
54684: LD_ADDR_VAR 0 4
54688: PUSH
54689: LD_EXP 100
54693: PUSH
54694: LD_VAR 0 2
54698: ARRAY
54699: PPUSH
54700: LD_INT 2
54702: PUSH
54703: LD_INT 25
54705: PUSH
54706: LD_INT 2
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: PUSH
54713: LD_INT 25
54715: PUSH
54716: LD_INT 3
54718: PUSH
54719: EMPTY
54720: LIST
54721: LIST
54722: PUSH
54723: LD_INT 25
54725: PUSH
54726: LD_INT 4
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: LIST
54737: LIST
54738: PPUSH
54739: CALL_OW 72
54743: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
54744: LD_VAR 0 2
54748: PPUSH
54749: LD_VAR 0 4
54753: PPUSH
54754: CALL 134959 0 2
// exit ;
54758: POP
54759: POP
54760: GO 54882
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
54762: LD_EXP 123
54766: PUSH
54767: LD_VAR 0 2
54771: ARRAY
54772: PUSH
54773: LD_EXP 143
54777: PUSH
54778: LD_VAR 0 2
54782: ARRAY
54783: NOT
54784: AND
54785: PUSH
54786: LD_EXP 122
54790: PUSH
54791: LD_VAR 0 2
54795: ARRAY
54796: AND
54797: IFFALSE 54878
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54799: LD_ADDR_EXP 143
54803: PUSH
54804: LD_EXP 143
54808: PPUSH
54809: LD_VAR 0 2
54813: PPUSH
54814: LD_INT 1
54816: PPUSH
54817: CALL_OW 1
54821: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
54822: LD_ADDR_VAR 0 4
54826: PUSH
54827: LD_EXP 122
54831: PUSH
54832: LD_VAR 0 2
54836: ARRAY
54837: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54838: LD_ADDR_EXP 122
54842: PUSH
54843: LD_EXP 122
54847: PPUSH
54848: LD_VAR 0 2
54852: PPUSH
54853: EMPTY
54854: PPUSH
54855: CALL_OW 1
54859: ST_TO_ADDR
// Defend ( i , tmp ) ;
54860: LD_VAR 0 2
54864: PPUSH
54865: LD_VAR 0 4
54869: PPUSH
54870: CALL 135555 0 2
// exit ;
54874: POP
54875: POP
54876: GO 54882
// end ; end ;
54878: GO 54040
54880: POP
54881: POP
// end ;
54882: LD_VAR 0 1
54886: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
54887: LD_INT 0
54889: PPUSH
54890: PPUSH
54891: PPUSH
54892: PPUSH
54893: PPUSH
54894: PPUSH
54895: PPUSH
54896: PPUSH
54897: PPUSH
54898: PPUSH
54899: PPUSH
// if not mc_bases then
54900: LD_EXP 100
54904: NOT
54905: IFFALSE 54909
// exit ;
54907: GO 55996
// for i = 1 to mc_bases do
54909: LD_ADDR_VAR 0 2
54913: PUSH
54914: DOUBLE
54915: LD_INT 1
54917: DEC
54918: ST_TO_ADDR
54919: LD_EXP 100
54923: PUSH
54924: FOR_TO
54925: IFFALSE 55994
// begin tmp := mc_lab [ i ] ;
54927: LD_ADDR_VAR 0 6
54931: PUSH
54932: LD_EXP 133
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: ST_TO_ADDR
// if not tmp then
54943: LD_VAR 0 6
54947: NOT
54948: IFFALSE 54952
// continue ;
54950: GO 54924
// idle_lab := 0 ;
54952: LD_ADDR_VAR 0 11
54956: PUSH
54957: LD_INT 0
54959: ST_TO_ADDR
// for j in tmp do
54960: LD_ADDR_VAR 0 3
54964: PUSH
54965: LD_VAR 0 6
54969: PUSH
54970: FOR_IN
54971: IFFALSE 55990
// begin researching := false ;
54973: LD_ADDR_VAR 0 10
54977: PUSH
54978: LD_INT 0
54980: ST_TO_ADDR
// side := GetSide ( j ) ;
54981: LD_ADDR_VAR 0 4
54985: PUSH
54986: LD_VAR 0 3
54990: PPUSH
54991: CALL_OW 255
54995: ST_TO_ADDR
// if not mc_tech [ side ] then
54996: LD_EXP 127
55000: PUSH
55001: LD_VAR 0 4
55005: ARRAY
55006: NOT
55007: IFFALSE 55011
// continue ;
55009: GO 54970
// if BuildingStatus ( j ) = bs_idle then
55011: LD_VAR 0 3
55015: PPUSH
55016: CALL_OW 461
55020: PUSH
55021: LD_INT 2
55023: EQUAL
55024: IFFALSE 55212
// begin if idle_lab and UnitsInside ( j ) < 6 then
55026: LD_VAR 0 11
55030: PUSH
55031: LD_VAR 0 3
55035: PPUSH
55036: CALL_OW 313
55040: PUSH
55041: LD_INT 6
55043: LESS
55044: AND
55045: IFFALSE 55116
// begin tmp2 := UnitsInside ( idle_lab ) ;
55047: LD_ADDR_VAR 0 9
55051: PUSH
55052: LD_VAR 0 11
55056: PPUSH
55057: CALL_OW 313
55061: ST_TO_ADDR
// if tmp2 then
55062: LD_VAR 0 9
55066: IFFALSE 55108
// for x in tmp2 do
55068: LD_ADDR_VAR 0 7
55072: PUSH
55073: LD_VAR 0 9
55077: PUSH
55078: FOR_IN
55079: IFFALSE 55106
// begin ComExitBuilding ( x ) ;
55081: LD_VAR 0 7
55085: PPUSH
55086: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55090: LD_VAR 0 7
55094: PPUSH
55095: LD_VAR 0 3
55099: PPUSH
55100: CALL_OW 180
// end ;
55104: GO 55078
55106: POP
55107: POP
// idle_lab := 0 ;
55108: LD_ADDR_VAR 0 11
55112: PUSH
55113: LD_INT 0
55115: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55116: LD_ADDR_VAR 0 5
55120: PUSH
55121: LD_EXP 127
55125: PUSH
55126: LD_VAR 0 4
55130: ARRAY
55131: PUSH
55132: FOR_IN
55133: IFFALSE 55193
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55135: LD_VAR 0 3
55139: PPUSH
55140: LD_VAR 0 5
55144: PPUSH
55145: CALL_OW 430
55149: PUSH
55150: LD_VAR 0 4
55154: PPUSH
55155: LD_VAR 0 5
55159: PPUSH
55160: CALL 69651 0 2
55164: AND
55165: IFFALSE 55191
// begin researching := true ;
55167: LD_ADDR_VAR 0 10
55171: PUSH
55172: LD_INT 1
55174: ST_TO_ADDR
// ComResearch ( j , t ) ;
55175: LD_VAR 0 3
55179: PPUSH
55180: LD_VAR 0 5
55184: PPUSH
55185: CALL_OW 124
// break ;
55189: GO 55193
// end ;
55191: GO 55132
55193: POP
55194: POP
// if not researching then
55195: LD_VAR 0 10
55199: NOT
55200: IFFALSE 55212
// idle_lab := j ;
55202: LD_ADDR_VAR 0 11
55206: PUSH
55207: LD_VAR 0 3
55211: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
55212: LD_VAR 0 3
55216: PPUSH
55217: CALL_OW 461
55221: PUSH
55222: LD_INT 10
55224: EQUAL
55225: IFFALSE 55813
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
55227: LD_EXP 129
55231: PUSH
55232: LD_VAR 0 2
55236: ARRAY
55237: NOT
55238: PUSH
55239: LD_EXP 130
55243: PUSH
55244: LD_VAR 0 2
55248: ARRAY
55249: NOT
55250: AND
55251: PUSH
55252: LD_EXP 127
55256: PUSH
55257: LD_VAR 0 4
55261: ARRAY
55262: PUSH
55263: LD_INT 1
55265: GREATER
55266: AND
55267: IFFALSE 55398
// begin ComCancel ( j ) ;
55269: LD_VAR 0 3
55273: PPUSH
55274: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
55278: LD_ADDR_EXP 127
55282: PUSH
55283: LD_EXP 127
55287: PPUSH
55288: LD_VAR 0 4
55292: PPUSH
55293: LD_EXP 127
55297: PUSH
55298: LD_VAR 0 4
55302: ARRAY
55303: PPUSH
55304: LD_EXP 127
55308: PUSH
55309: LD_VAR 0 4
55313: ARRAY
55314: PUSH
55315: LD_INT 1
55317: MINUS
55318: PPUSH
55319: LD_EXP 127
55323: PUSH
55324: LD_VAR 0 4
55328: ARRAY
55329: PPUSH
55330: LD_INT 0
55332: PPUSH
55333: CALL 73175 0 4
55337: PPUSH
55338: CALL_OW 1
55342: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
55343: LD_ADDR_EXP 127
55347: PUSH
55348: LD_EXP 127
55352: PPUSH
55353: LD_VAR 0 4
55357: PPUSH
55358: LD_EXP 127
55362: PUSH
55363: LD_VAR 0 4
55367: ARRAY
55368: PPUSH
55369: LD_EXP 127
55373: PUSH
55374: LD_VAR 0 4
55378: ARRAY
55379: PPUSH
55380: LD_INT 1
55382: PPUSH
55383: LD_INT 0
55385: PPUSH
55386: CALL 73175 0 4
55390: PPUSH
55391: CALL_OW 1
55395: ST_TO_ADDR
// continue ;
55396: GO 54970
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
55398: LD_EXP 129
55402: PUSH
55403: LD_VAR 0 2
55407: ARRAY
55408: PUSH
55409: LD_EXP 130
55413: PUSH
55414: LD_VAR 0 2
55418: ARRAY
55419: NOT
55420: AND
55421: IFFALSE 55548
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
55423: LD_ADDR_EXP 130
55427: PUSH
55428: LD_EXP 130
55432: PPUSH
55433: LD_VAR 0 2
55437: PUSH
55438: LD_EXP 130
55442: PUSH
55443: LD_VAR 0 2
55447: ARRAY
55448: PUSH
55449: LD_INT 1
55451: PLUS
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: PPUSH
55457: LD_EXP 129
55461: PUSH
55462: LD_VAR 0 2
55466: ARRAY
55467: PUSH
55468: LD_INT 1
55470: ARRAY
55471: PPUSH
55472: CALL 73757 0 3
55476: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
55477: LD_EXP 129
55481: PUSH
55482: LD_VAR 0 2
55486: ARRAY
55487: PUSH
55488: LD_INT 1
55490: ARRAY
55491: PPUSH
55492: LD_INT 112
55494: PPUSH
55495: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
55499: LD_ADDR_VAR 0 9
55503: PUSH
55504: LD_EXP 129
55508: PUSH
55509: LD_VAR 0 2
55513: ARRAY
55514: PPUSH
55515: LD_INT 1
55517: PPUSH
55518: CALL_OW 3
55522: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
55523: LD_ADDR_EXP 129
55527: PUSH
55528: LD_EXP 129
55532: PPUSH
55533: LD_VAR 0 2
55537: PPUSH
55538: LD_VAR 0 9
55542: PPUSH
55543: CALL_OW 1
55547: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
55548: LD_EXP 129
55552: PUSH
55553: LD_VAR 0 2
55557: ARRAY
55558: PUSH
55559: LD_EXP 130
55563: PUSH
55564: LD_VAR 0 2
55568: ARRAY
55569: AND
55570: PUSH
55571: LD_EXP 130
55575: PUSH
55576: LD_VAR 0 2
55580: ARRAY
55581: PUSH
55582: LD_INT 1
55584: ARRAY
55585: PPUSH
55586: CALL_OW 310
55590: NOT
55591: AND
55592: PUSH
55593: LD_VAR 0 3
55597: PPUSH
55598: CALL_OW 313
55602: PUSH
55603: LD_INT 6
55605: EQUAL
55606: AND
55607: IFFALSE 55663
// begin tmp2 := UnitsInside ( j ) ;
55609: LD_ADDR_VAR 0 9
55613: PUSH
55614: LD_VAR 0 3
55618: PPUSH
55619: CALL_OW 313
55623: ST_TO_ADDR
// if tmp2 = 6 then
55624: LD_VAR 0 9
55628: PUSH
55629: LD_INT 6
55631: EQUAL
55632: IFFALSE 55663
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
55634: LD_VAR 0 9
55638: PUSH
55639: LD_INT 1
55641: ARRAY
55642: PPUSH
55643: LD_INT 112
55645: PPUSH
55646: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
55650: LD_VAR 0 9
55654: PUSH
55655: LD_INT 1
55657: ARRAY
55658: PPUSH
55659: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
55663: LD_EXP 130
55667: PUSH
55668: LD_VAR 0 2
55672: ARRAY
55673: PUSH
55674: LD_EXP 130
55678: PUSH
55679: LD_VAR 0 2
55683: ARRAY
55684: PUSH
55685: LD_INT 1
55687: ARRAY
55688: PPUSH
55689: CALL_OW 314
55693: NOT
55694: AND
55695: PUSH
55696: LD_EXP 130
55700: PUSH
55701: LD_VAR 0 2
55705: ARRAY
55706: PUSH
55707: LD_INT 1
55709: ARRAY
55710: PPUSH
55711: CALL_OW 310
55715: NOT
55716: AND
55717: IFFALSE 55743
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
55719: LD_EXP 130
55723: PUSH
55724: LD_VAR 0 2
55728: ARRAY
55729: PUSH
55730: LD_INT 1
55732: ARRAY
55733: PPUSH
55734: LD_VAR 0 3
55738: PPUSH
55739: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
55743: LD_EXP 130
55747: PUSH
55748: LD_VAR 0 2
55752: ARRAY
55753: PUSH
55754: LD_INT 1
55756: ARRAY
55757: PPUSH
55758: CALL_OW 310
55762: PUSH
55763: LD_EXP 130
55767: PUSH
55768: LD_VAR 0 2
55772: ARRAY
55773: PUSH
55774: LD_INT 1
55776: ARRAY
55777: PPUSH
55778: CALL_OW 310
55782: PPUSH
55783: CALL_OW 461
55787: PUSH
55788: LD_INT 3
55790: NONEQUAL
55791: AND
55792: IFFALSE 55813
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
55794: LD_EXP 130
55798: PUSH
55799: LD_VAR 0 2
55803: ARRAY
55804: PUSH
55805: LD_INT 1
55807: ARRAY
55808: PPUSH
55809: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
55813: LD_VAR 0 3
55817: PPUSH
55818: CALL_OW 461
55822: PUSH
55823: LD_INT 6
55825: EQUAL
55826: PUSH
55827: LD_VAR 0 6
55831: PUSH
55832: LD_INT 1
55834: GREATER
55835: AND
55836: IFFALSE 55988
// begin sci := [ ] ;
55838: LD_ADDR_VAR 0 8
55842: PUSH
55843: EMPTY
55844: ST_TO_ADDR
// for x in ( tmp diff j ) do
55845: LD_ADDR_VAR 0 7
55849: PUSH
55850: LD_VAR 0 6
55854: PUSH
55855: LD_VAR 0 3
55859: DIFF
55860: PUSH
55861: FOR_IN
55862: IFFALSE 55914
// begin if sci = 6 then
55864: LD_VAR 0 8
55868: PUSH
55869: LD_INT 6
55871: EQUAL
55872: IFFALSE 55876
// break ;
55874: GO 55914
// if BuildingStatus ( x ) = bs_idle then
55876: LD_VAR 0 7
55880: PPUSH
55881: CALL_OW 461
55885: PUSH
55886: LD_INT 2
55888: EQUAL
55889: IFFALSE 55912
// sci := sci ^ UnitsInside ( x ) ;
55891: LD_ADDR_VAR 0 8
55895: PUSH
55896: LD_VAR 0 8
55900: PUSH
55901: LD_VAR 0 7
55905: PPUSH
55906: CALL_OW 313
55910: ADD
55911: ST_TO_ADDR
// end ;
55912: GO 55861
55914: POP
55915: POP
// if not sci then
55916: LD_VAR 0 8
55920: NOT
55921: IFFALSE 55925
// continue ;
55923: GO 54970
// for x in sci do
55925: LD_ADDR_VAR 0 7
55929: PUSH
55930: LD_VAR 0 8
55934: PUSH
55935: FOR_IN
55936: IFFALSE 55986
// if IsInUnit ( x ) and not HasTask ( x ) then
55938: LD_VAR 0 7
55942: PPUSH
55943: CALL_OW 310
55947: PUSH
55948: LD_VAR 0 7
55952: PPUSH
55953: CALL_OW 314
55957: NOT
55958: AND
55959: IFFALSE 55984
// begin ComExitBuilding ( x ) ;
55961: LD_VAR 0 7
55965: PPUSH
55966: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55970: LD_VAR 0 7
55974: PPUSH
55975: LD_VAR 0 3
55979: PPUSH
55980: CALL_OW 180
// end ;
55984: GO 55935
55986: POP
55987: POP
// end ; end ;
55988: GO 54970
55990: POP
55991: POP
// end ;
55992: GO 54924
55994: POP
55995: POP
// end ;
55996: LD_VAR 0 1
56000: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56001: LD_INT 0
56003: PPUSH
56004: PPUSH
// if not mc_bases then
56005: LD_EXP 100
56009: NOT
56010: IFFALSE 56014
// exit ;
56012: GO 56095
// for i = 1 to mc_bases do
56014: LD_ADDR_VAR 0 2
56018: PUSH
56019: DOUBLE
56020: LD_INT 1
56022: DEC
56023: ST_TO_ADDR
56024: LD_EXP 100
56028: PUSH
56029: FOR_TO
56030: IFFALSE 56093
// if mc_mines [ i ] and mc_miners [ i ] then
56032: LD_EXP 113
56036: PUSH
56037: LD_VAR 0 2
56041: ARRAY
56042: PUSH
56043: LD_EXP 114
56047: PUSH
56048: LD_VAR 0 2
56052: ARRAY
56053: AND
56054: IFFALSE 56091
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56056: LD_EXP 114
56060: PUSH
56061: LD_VAR 0 2
56065: ARRAY
56066: PUSH
56067: LD_INT 1
56069: ARRAY
56070: PPUSH
56071: CALL_OW 255
56075: PPUSH
56076: LD_EXP 113
56080: PUSH
56081: LD_VAR 0 2
56085: ARRAY
56086: PPUSH
56087: CALL 70734 0 2
56091: GO 56029
56093: POP
56094: POP
// end ;
56095: LD_VAR 0 1
56099: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56100: LD_INT 0
56102: PPUSH
56103: PPUSH
56104: PPUSH
56105: PPUSH
56106: PPUSH
56107: PPUSH
56108: PPUSH
56109: PPUSH
// if not mc_bases or not mc_parking then
56110: LD_EXP 100
56114: NOT
56115: PUSH
56116: LD_EXP 124
56120: NOT
56121: OR
56122: IFFALSE 56126
// exit ;
56124: GO 56864
// for i = 1 to mc_bases do
56126: LD_ADDR_VAR 0 2
56130: PUSH
56131: DOUBLE
56132: LD_INT 1
56134: DEC
56135: ST_TO_ADDR
56136: LD_EXP 100
56140: PUSH
56141: FOR_TO
56142: IFFALSE 56862
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56144: LD_EXP 100
56148: PUSH
56149: LD_VAR 0 2
56153: ARRAY
56154: NOT
56155: PUSH
56156: LD_EXP 124
56160: PUSH
56161: LD_VAR 0 2
56165: ARRAY
56166: NOT
56167: OR
56168: IFFALSE 56172
// continue ;
56170: GO 56141
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56172: LD_ADDR_VAR 0 5
56176: PUSH
56177: LD_EXP 100
56181: PUSH
56182: LD_VAR 0 2
56186: ARRAY
56187: PUSH
56188: LD_INT 1
56190: ARRAY
56191: PPUSH
56192: CALL_OW 255
56196: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56197: LD_ADDR_VAR 0 6
56201: PUSH
56202: LD_EXP 100
56206: PUSH
56207: LD_VAR 0 2
56211: ARRAY
56212: PPUSH
56213: LD_INT 30
56215: PUSH
56216: LD_INT 3
56218: PUSH
56219: EMPTY
56220: LIST
56221: LIST
56222: PPUSH
56223: CALL_OW 72
56227: ST_TO_ADDR
// if not fac then
56228: LD_VAR 0 6
56232: NOT
56233: IFFALSE 56284
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56235: LD_ADDR_VAR 0 6
56239: PUSH
56240: LD_EXP 100
56244: PUSH
56245: LD_VAR 0 2
56249: ARRAY
56250: PPUSH
56251: LD_INT 2
56253: PUSH
56254: LD_INT 30
56256: PUSH
56257: LD_INT 0
56259: PUSH
56260: EMPTY
56261: LIST
56262: LIST
56263: PUSH
56264: LD_INT 30
56266: PUSH
56267: LD_INT 1
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: PUSH
56274: EMPTY
56275: LIST
56276: LIST
56277: LIST
56278: PPUSH
56279: CALL_OW 72
56283: ST_TO_ADDR
// if not fac then
56284: LD_VAR 0 6
56288: NOT
56289: IFFALSE 56293
// continue ;
56291: GO 56141
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56293: LD_ADDR_VAR 0 7
56297: PUSH
56298: LD_EXP 124
56302: PUSH
56303: LD_VAR 0 2
56307: ARRAY
56308: PPUSH
56309: LD_INT 22
56311: PUSH
56312: LD_VAR 0 5
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: PUSH
56321: LD_INT 21
56323: PUSH
56324: LD_INT 2
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: PUSH
56331: LD_INT 3
56333: PUSH
56334: LD_INT 60
56336: PUSH
56337: EMPTY
56338: LIST
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: PUSH
56344: LD_INT 3
56346: PUSH
56347: LD_INT 24
56349: PUSH
56350: LD_INT 1000
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: PUSH
56357: EMPTY
56358: LIST
56359: LIST
56360: PUSH
56361: EMPTY
56362: LIST
56363: LIST
56364: LIST
56365: LIST
56366: PPUSH
56367: CALL_OW 70
56371: ST_TO_ADDR
// for j in fac do
56372: LD_ADDR_VAR 0 3
56376: PUSH
56377: LD_VAR 0 6
56381: PUSH
56382: FOR_IN
56383: IFFALSE 56478
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56385: LD_ADDR_VAR 0 7
56389: PUSH
56390: LD_VAR 0 7
56394: PUSH
56395: LD_INT 22
56397: PUSH
56398: LD_VAR 0 5
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: PUSH
56407: LD_INT 91
56409: PUSH
56410: LD_VAR 0 3
56414: PUSH
56415: LD_INT 15
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: LIST
56422: PUSH
56423: LD_INT 21
56425: PUSH
56426: LD_INT 2
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PUSH
56433: LD_INT 3
56435: PUSH
56436: LD_INT 60
56438: PUSH
56439: EMPTY
56440: LIST
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: PUSH
56446: LD_INT 3
56448: PUSH
56449: LD_INT 24
56451: PUSH
56452: LD_INT 1000
56454: PUSH
56455: EMPTY
56456: LIST
56457: LIST
56458: PUSH
56459: EMPTY
56460: LIST
56461: LIST
56462: PUSH
56463: EMPTY
56464: LIST
56465: LIST
56466: LIST
56467: LIST
56468: LIST
56469: PPUSH
56470: CALL_OW 69
56474: UNION
56475: ST_TO_ADDR
56476: GO 56382
56478: POP
56479: POP
// if not vehs then
56480: LD_VAR 0 7
56484: NOT
56485: IFFALSE 56511
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56487: LD_ADDR_EXP 112
56491: PUSH
56492: LD_EXP 112
56496: PPUSH
56497: LD_VAR 0 2
56501: PPUSH
56502: EMPTY
56503: PPUSH
56504: CALL_OW 1
56508: ST_TO_ADDR
// continue ;
56509: GO 56141
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56511: LD_ADDR_VAR 0 8
56515: PUSH
56516: LD_EXP 100
56520: PUSH
56521: LD_VAR 0 2
56525: ARRAY
56526: PPUSH
56527: LD_INT 30
56529: PUSH
56530: LD_INT 3
56532: PUSH
56533: EMPTY
56534: LIST
56535: LIST
56536: PPUSH
56537: CALL_OW 72
56541: ST_TO_ADDR
// if tmp then
56542: LD_VAR 0 8
56546: IFFALSE 56649
// begin for j in tmp do
56548: LD_ADDR_VAR 0 3
56552: PUSH
56553: LD_VAR 0 8
56557: PUSH
56558: FOR_IN
56559: IFFALSE 56647
// for k in UnitsInside ( j ) do
56561: LD_ADDR_VAR 0 4
56565: PUSH
56566: LD_VAR 0 3
56570: PPUSH
56571: CALL_OW 313
56575: PUSH
56576: FOR_IN
56577: IFFALSE 56643
// if k then
56579: LD_VAR 0 4
56583: IFFALSE 56641
// if not k in mc_repair_vehicle [ i ] then
56585: LD_VAR 0 4
56589: PUSH
56590: LD_EXP 112
56594: PUSH
56595: LD_VAR 0 2
56599: ARRAY
56600: IN
56601: NOT
56602: IFFALSE 56641
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
56604: LD_ADDR_EXP 112
56608: PUSH
56609: LD_EXP 112
56613: PPUSH
56614: LD_VAR 0 2
56618: PPUSH
56619: LD_EXP 112
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PUSH
56630: LD_VAR 0 4
56634: UNION
56635: PPUSH
56636: CALL_OW 1
56640: ST_TO_ADDR
56641: GO 56576
56643: POP
56644: POP
56645: GO 56558
56647: POP
56648: POP
// end ; if not mc_repair_vehicle [ i ] then
56649: LD_EXP 112
56653: PUSH
56654: LD_VAR 0 2
56658: ARRAY
56659: NOT
56660: IFFALSE 56664
// continue ;
56662: GO 56141
// for j in mc_repair_vehicle [ i ] do
56664: LD_ADDR_VAR 0 3
56668: PUSH
56669: LD_EXP 112
56673: PUSH
56674: LD_VAR 0 2
56678: ARRAY
56679: PUSH
56680: FOR_IN
56681: IFFALSE 56858
// begin if GetClass ( j ) <> 3 then
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL_OW 257
56692: PUSH
56693: LD_INT 3
56695: NONEQUAL
56696: IFFALSE 56737
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
56698: LD_ADDR_EXP 112
56702: PUSH
56703: LD_EXP 112
56707: PPUSH
56708: LD_VAR 0 2
56712: PPUSH
56713: LD_EXP 112
56717: PUSH
56718: LD_VAR 0 2
56722: ARRAY
56723: PUSH
56724: LD_VAR 0 3
56728: DIFF
56729: PPUSH
56730: CALL_OW 1
56734: ST_TO_ADDR
// continue ;
56735: GO 56680
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
56737: LD_VAR 0 3
56741: PPUSH
56742: CALL_OW 311
56746: NOT
56747: PUSH
56748: LD_VAR 0 3
56752: PUSH
56753: LD_EXP 103
56757: PUSH
56758: LD_VAR 0 2
56762: ARRAY
56763: PUSH
56764: LD_INT 1
56766: ARRAY
56767: IN
56768: NOT
56769: AND
56770: PUSH
56771: LD_VAR 0 3
56775: PUSH
56776: LD_EXP 103
56780: PUSH
56781: LD_VAR 0 2
56785: ARRAY
56786: PUSH
56787: LD_INT 2
56789: ARRAY
56790: IN
56791: NOT
56792: AND
56793: IFFALSE 56856
// begin if IsInUnit ( j ) then
56795: LD_VAR 0 3
56799: PPUSH
56800: CALL_OW 310
56804: IFFALSE 56817
// ComExitBuilding ( j ) else
56806: LD_VAR 0 3
56810: PPUSH
56811: CALL_OW 122
56815: GO 56856
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
56817: LD_VAR 0 3
56821: PPUSH
56822: LD_VAR 0 7
56826: PUSH
56827: LD_INT 1
56829: ARRAY
56830: PPUSH
56831: CALL 108152 0 2
56835: NOT
56836: IFFALSE 56856
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
56838: LD_VAR 0 3
56842: PPUSH
56843: LD_VAR 0 7
56847: PUSH
56848: LD_INT 1
56850: ARRAY
56851: PPUSH
56852: CALL_OW 129
// end ; end ;
56856: GO 56680
56858: POP
56859: POP
// end ;
56860: GO 56141
56862: POP
56863: POP
// end ;
56864: LD_VAR 0 1
56868: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
56869: LD_INT 0
56871: PPUSH
56872: PPUSH
56873: PPUSH
56874: PPUSH
56875: PPUSH
56876: PPUSH
56877: PPUSH
56878: PPUSH
56879: PPUSH
56880: PPUSH
56881: PPUSH
// if not mc_bases then
56882: LD_EXP 100
56886: NOT
56887: IFFALSE 56891
// exit ;
56889: GO 57693
// for i = 1 to mc_bases do
56891: LD_ADDR_VAR 0 2
56895: PUSH
56896: DOUBLE
56897: LD_INT 1
56899: DEC
56900: ST_TO_ADDR
56901: LD_EXP 100
56905: PUSH
56906: FOR_TO
56907: IFFALSE 57691
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
56909: LD_EXP 128
56913: PUSH
56914: LD_VAR 0 2
56918: ARRAY
56919: NOT
56920: PUSH
56921: LD_EXP 103
56925: PUSH
56926: LD_VAR 0 2
56930: ARRAY
56931: PUSH
56932: LD_INT 1
56934: ARRAY
56935: OR
56936: PUSH
56937: LD_EXP 103
56941: PUSH
56942: LD_VAR 0 2
56946: ARRAY
56947: PUSH
56948: LD_INT 2
56950: ARRAY
56951: OR
56952: PUSH
56953: LD_EXP 126
56957: PUSH
56958: LD_VAR 0 2
56962: ARRAY
56963: PPUSH
56964: LD_INT 1
56966: PPUSH
56967: CALL_OW 325
56971: NOT
56972: OR
56973: PUSH
56974: LD_EXP 123
56978: PUSH
56979: LD_VAR 0 2
56983: ARRAY
56984: OR
56985: IFFALSE 56989
// continue ;
56987: GO 56906
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
56989: LD_ADDR_VAR 0 8
56993: PUSH
56994: LD_EXP 100
56998: PUSH
56999: LD_VAR 0 2
57003: ARRAY
57004: PPUSH
57005: LD_INT 25
57007: PUSH
57008: LD_INT 4
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: PUSH
57015: LD_INT 50
57017: PUSH
57018: EMPTY
57019: LIST
57020: PUSH
57021: LD_INT 3
57023: PUSH
57024: LD_INT 60
57026: PUSH
57027: EMPTY
57028: LIST
57029: PUSH
57030: EMPTY
57031: LIST
57032: LIST
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: LIST
57038: PPUSH
57039: CALL_OW 72
57043: PUSH
57044: LD_EXP 104
57048: PUSH
57049: LD_VAR 0 2
57053: ARRAY
57054: DIFF
57055: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57056: LD_ADDR_VAR 0 9
57060: PUSH
57061: LD_EXP 100
57065: PUSH
57066: LD_VAR 0 2
57070: ARRAY
57071: PPUSH
57072: LD_INT 2
57074: PUSH
57075: LD_INT 30
57077: PUSH
57078: LD_INT 0
57080: PUSH
57081: EMPTY
57082: LIST
57083: LIST
57084: PUSH
57085: LD_INT 30
57087: PUSH
57088: LD_INT 1
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: LIST
57099: PPUSH
57100: CALL_OW 72
57104: ST_TO_ADDR
// if not tmp or not dep then
57105: LD_VAR 0 8
57109: NOT
57110: PUSH
57111: LD_VAR 0 9
57115: NOT
57116: OR
57117: IFFALSE 57121
// continue ;
57119: GO 56906
// side := GetSide ( tmp [ 1 ] ) ;
57121: LD_ADDR_VAR 0 11
57125: PUSH
57126: LD_VAR 0 8
57130: PUSH
57131: LD_INT 1
57133: ARRAY
57134: PPUSH
57135: CALL_OW 255
57139: ST_TO_ADDR
// dep := dep [ 1 ] ;
57140: LD_ADDR_VAR 0 9
57144: PUSH
57145: LD_VAR 0 9
57149: PUSH
57150: LD_INT 1
57152: ARRAY
57153: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57154: LD_ADDR_VAR 0 7
57158: PUSH
57159: LD_EXP 128
57163: PUSH
57164: LD_VAR 0 2
57168: ARRAY
57169: PPUSH
57170: LD_INT 22
57172: PUSH
57173: LD_INT 0
57175: PUSH
57176: EMPTY
57177: LIST
57178: LIST
57179: PUSH
57180: LD_INT 25
57182: PUSH
57183: LD_INT 12
57185: PUSH
57186: EMPTY
57187: LIST
57188: LIST
57189: PUSH
57190: EMPTY
57191: LIST
57192: LIST
57193: PPUSH
57194: CALL_OW 70
57198: PUSH
57199: LD_INT 22
57201: PUSH
57202: LD_INT 0
57204: PUSH
57205: EMPTY
57206: LIST
57207: LIST
57208: PUSH
57209: LD_INT 25
57211: PUSH
57212: LD_INT 12
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: PUSH
57219: LD_INT 91
57221: PUSH
57222: LD_VAR 0 9
57226: PUSH
57227: LD_INT 20
57229: PUSH
57230: EMPTY
57231: LIST
57232: LIST
57233: LIST
57234: PUSH
57235: EMPTY
57236: LIST
57237: LIST
57238: LIST
57239: PPUSH
57240: CALL_OW 69
57244: UNION
57245: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57246: LD_ADDR_VAR 0 10
57250: PUSH
57251: LD_EXP 128
57255: PUSH
57256: LD_VAR 0 2
57260: ARRAY
57261: PPUSH
57262: LD_INT 81
57264: PUSH
57265: LD_VAR 0 11
57269: PUSH
57270: EMPTY
57271: LIST
57272: LIST
57273: PPUSH
57274: CALL_OW 70
57278: ST_TO_ADDR
// if not apes or danger_at_area then
57279: LD_VAR 0 7
57283: NOT
57284: PUSH
57285: LD_VAR 0 10
57289: OR
57290: IFFALSE 57340
// begin if mc_taming [ i ] then
57292: LD_EXP 131
57296: PUSH
57297: LD_VAR 0 2
57301: ARRAY
57302: IFFALSE 57338
// begin MC_Reset ( i , 121 ) ;
57304: LD_VAR 0 2
57308: PPUSH
57309: LD_INT 121
57311: PPUSH
57312: CALL 42270 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57316: LD_ADDR_EXP 131
57320: PUSH
57321: LD_EXP 131
57325: PPUSH
57326: LD_VAR 0 2
57330: PPUSH
57331: EMPTY
57332: PPUSH
57333: CALL_OW 1
57337: ST_TO_ADDR
// end ; continue ;
57338: GO 56906
// end ; for j in tmp do
57340: LD_ADDR_VAR 0 3
57344: PUSH
57345: LD_VAR 0 8
57349: PUSH
57350: FOR_IN
57351: IFFALSE 57687
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
57353: LD_VAR 0 3
57357: PUSH
57358: LD_EXP 131
57362: PUSH
57363: LD_VAR 0 2
57367: ARRAY
57368: IN
57369: NOT
57370: PUSH
57371: LD_EXP 131
57375: PUSH
57376: LD_VAR 0 2
57380: ARRAY
57381: PUSH
57382: LD_INT 3
57384: LESS
57385: AND
57386: IFFALSE 57444
// begin SetTag ( j , 121 ) ;
57388: LD_VAR 0 3
57392: PPUSH
57393: LD_INT 121
57395: PPUSH
57396: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
57400: LD_ADDR_EXP 131
57404: PUSH
57405: LD_EXP 131
57409: PPUSH
57410: LD_VAR 0 2
57414: PUSH
57415: LD_EXP 131
57419: PUSH
57420: LD_VAR 0 2
57424: ARRAY
57425: PUSH
57426: LD_INT 1
57428: PLUS
57429: PUSH
57430: EMPTY
57431: LIST
57432: LIST
57433: PPUSH
57434: LD_VAR 0 3
57438: PPUSH
57439: CALL 73757 0 3
57443: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
57444: LD_VAR 0 3
57448: PUSH
57449: LD_EXP 131
57453: PUSH
57454: LD_VAR 0 2
57458: ARRAY
57459: IN
57460: IFFALSE 57685
// begin if GetClass ( j ) <> 4 then
57462: LD_VAR 0 3
57466: PPUSH
57467: CALL_OW 257
57471: PUSH
57472: LD_INT 4
57474: NONEQUAL
57475: IFFALSE 57528
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
57477: LD_ADDR_EXP 131
57481: PUSH
57482: LD_EXP 131
57486: PPUSH
57487: LD_VAR 0 2
57491: PPUSH
57492: LD_EXP 131
57496: PUSH
57497: LD_VAR 0 2
57501: ARRAY
57502: PUSH
57503: LD_VAR 0 3
57507: DIFF
57508: PPUSH
57509: CALL_OW 1
57513: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57514: LD_VAR 0 3
57518: PPUSH
57519: LD_INT 0
57521: PPUSH
57522: CALL_OW 109
// continue ;
57526: GO 57350
// end ; if IsInUnit ( j ) then
57528: LD_VAR 0 3
57532: PPUSH
57533: CALL_OW 310
57537: IFFALSE 57548
// ComExitBuilding ( j ) ;
57539: LD_VAR 0 3
57543: PPUSH
57544: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
57548: LD_ADDR_VAR 0 6
57552: PUSH
57553: LD_VAR 0 7
57557: PPUSH
57558: LD_VAR 0 3
57562: PPUSH
57563: CALL_OW 74
57567: ST_TO_ADDR
// if not ape then
57568: LD_VAR 0 6
57572: NOT
57573: IFFALSE 57577
// break ;
57575: GO 57687
// x := GetX ( ape ) ;
57577: LD_ADDR_VAR 0 4
57581: PUSH
57582: LD_VAR 0 6
57586: PPUSH
57587: CALL_OW 250
57591: ST_TO_ADDR
// y := GetY ( ape ) ;
57592: LD_ADDR_VAR 0 5
57596: PUSH
57597: LD_VAR 0 6
57601: PPUSH
57602: CALL_OW 251
57606: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
57607: LD_VAR 0 4
57611: PPUSH
57612: LD_VAR 0 5
57616: PPUSH
57617: CALL_OW 488
57621: NOT
57622: PUSH
57623: LD_VAR 0 11
57627: PPUSH
57628: LD_VAR 0 4
57632: PPUSH
57633: LD_VAR 0 5
57637: PPUSH
57638: LD_INT 20
57640: PPUSH
57641: CALL 74653 0 4
57645: PUSH
57646: LD_INT 4
57648: ARRAY
57649: OR
57650: IFFALSE 57654
// break ;
57652: GO 57687
// if not HasTask ( j ) then
57654: LD_VAR 0 3
57658: PPUSH
57659: CALL_OW 314
57663: NOT
57664: IFFALSE 57685
// ComTameXY ( j , x , y ) ;
57666: LD_VAR 0 3
57670: PPUSH
57671: LD_VAR 0 4
57675: PPUSH
57676: LD_VAR 0 5
57680: PPUSH
57681: CALL_OW 131
// end ; end ;
57685: GO 57350
57687: POP
57688: POP
// end ;
57689: GO 56906
57691: POP
57692: POP
// end ;
57693: LD_VAR 0 1
57697: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
57698: LD_INT 0
57700: PPUSH
57701: PPUSH
57702: PPUSH
57703: PPUSH
57704: PPUSH
57705: PPUSH
57706: PPUSH
57707: PPUSH
// if not mc_bases then
57708: LD_EXP 100
57712: NOT
57713: IFFALSE 57717
// exit ;
57715: GO 58343
// for i = 1 to mc_bases do
57717: LD_ADDR_VAR 0 2
57721: PUSH
57722: DOUBLE
57723: LD_INT 1
57725: DEC
57726: ST_TO_ADDR
57727: LD_EXP 100
57731: PUSH
57732: FOR_TO
57733: IFFALSE 58341
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
57735: LD_EXP 129
57739: PUSH
57740: LD_VAR 0 2
57744: ARRAY
57745: NOT
57746: PUSH
57747: LD_EXP 129
57751: PUSH
57752: LD_VAR 0 2
57756: ARRAY
57757: PPUSH
57758: LD_INT 25
57760: PUSH
57761: LD_INT 12
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: PPUSH
57768: CALL_OW 72
57772: NOT
57773: OR
57774: IFFALSE 57778
// continue ;
57776: GO 57732
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
57778: LD_ADDR_VAR 0 5
57782: PUSH
57783: LD_EXP 129
57787: PUSH
57788: LD_VAR 0 2
57792: ARRAY
57793: PUSH
57794: LD_INT 1
57796: ARRAY
57797: PPUSH
57798: CALL_OW 255
57802: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
57803: LD_VAR 0 5
57807: PPUSH
57808: LD_INT 2
57810: PPUSH
57811: CALL_OW 325
57815: IFFALSE 58068
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
57817: LD_ADDR_VAR 0 4
57821: PUSH
57822: LD_EXP 129
57826: PUSH
57827: LD_VAR 0 2
57831: ARRAY
57832: PPUSH
57833: LD_INT 25
57835: PUSH
57836: LD_INT 16
57838: PUSH
57839: EMPTY
57840: LIST
57841: LIST
57842: PPUSH
57843: CALL_OW 72
57847: ST_TO_ADDR
// if tmp < 6 then
57848: LD_VAR 0 4
57852: PUSH
57853: LD_INT 6
57855: LESS
57856: IFFALSE 58068
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57858: LD_ADDR_VAR 0 6
57862: PUSH
57863: LD_EXP 100
57867: PUSH
57868: LD_VAR 0 2
57872: ARRAY
57873: PPUSH
57874: LD_INT 2
57876: PUSH
57877: LD_INT 30
57879: PUSH
57880: LD_INT 0
57882: PUSH
57883: EMPTY
57884: LIST
57885: LIST
57886: PUSH
57887: LD_INT 30
57889: PUSH
57890: LD_INT 1
57892: PUSH
57893: EMPTY
57894: LIST
57895: LIST
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: LIST
57901: PPUSH
57902: CALL_OW 72
57906: ST_TO_ADDR
// if depot then
57907: LD_VAR 0 6
57911: IFFALSE 58068
// begin selected := 0 ;
57913: LD_ADDR_VAR 0 7
57917: PUSH
57918: LD_INT 0
57920: ST_TO_ADDR
// for j in depot do
57921: LD_ADDR_VAR 0 3
57925: PUSH
57926: LD_VAR 0 6
57930: PUSH
57931: FOR_IN
57932: IFFALSE 57963
// begin if UnitsInside ( j ) < 6 then
57934: LD_VAR 0 3
57938: PPUSH
57939: CALL_OW 313
57943: PUSH
57944: LD_INT 6
57946: LESS
57947: IFFALSE 57961
// begin selected := j ;
57949: LD_ADDR_VAR 0 7
57953: PUSH
57954: LD_VAR 0 3
57958: ST_TO_ADDR
// break ;
57959: GO 57963
// end ; end ;
57961: GO 57931
57963: POP
57964: POP
// if selected then
57965: LD_VAR 0 7
57969: IFFALSE 58068
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57971: LD_ADDR_VAR 0 3
57975: PUSH
57976: LD_EXP 129
57980: PUSH
57981: LD_VAR 0 2
57985: ARRAY
57986: PPUSH
57987: LD_INT 25
57989: PUSH
57990: LD_INT 12
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: PPUSH
57997: CALL_OW 72
58001: PUSH
58002: FOR_IN
58003: IFFALSE 58066
// if not HasTask ( j ) then
58005: LD_VAR 0 3
58009: PPUSH
58010: CALL_OW 314
58014: NOT
58015: IFFALSE 58064
// begin if not IsInUnit ( j ) then
58017: LD_VAR 0 3
58021: PPUSH
58022: CALL_OW 310
58026: NOT
58027: IFFALSE 58043
// ComEnterUnit ( j , selected ) ;
58029: LD_VAR 0 3
58033: PPUSH
58034: LD_VAR 0 7
58038: PPUSH
58039: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58043: LD_VAR 0 3
58047: PPUSH
58048: LD_INT 16
58050: PPUSH
58051: CALL_OW 183
// AddComExitBuilding ( j ) ;
58055: LD_VAR 0 3
58059: PPUSH
58060: CALL_OW 182
// end ;
58064: GO 58002
58066: POP
58067: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58068: LD_VAR 0 5
58072: PPUSH
58073: LD_INT 11
58075: PPUSH
58076: CALL_OW 325
58080: IFFALSE 58339
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58082: LD_ADDR_VAR 0 4
58086: PUSH
58087: LD_EXP 129
58091: PUSH
58092: LD_VAR 0 2
58096: ARRAY
58097: PPUSH
58098: LD_INT 25
58100: PUSH
58101: LD_INT 16
58103: PUSH
58104: EMPTY
58105: LIST
58106: LIST
58107: PPUSH
58108: CALL_OW 72
58112: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58113: LD_VAR 0 4
58117: PUSH
58118: LD_INT 6
58120: GREATEREQUAL
58121: PUSH
58122: LD_VAR 0 5
58126: PPUSH
58127: LD_INT 2
58129: PPUSH
58130: CALL_OW 325
58134: NOT
58135: OR
58136: IFFALSE 58339
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58138: LD_ADDR_VAR 0 8
58142: PUSH
58143: LD_EXP 100
58147: PUSH
58148: LD_VAR 0 2
58152: ARRAY
58153: PPUSH
58154: LD_INT 2
58156: PUSH
58157: LD_INT 30
58159: PUSH
58160: LD_INT 4
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: PUSH
58167: LD_INT 30
58169: PUSH
58170: LD_INT 5
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: LIST
58181: PPUSH
58182: CALL_OW 72
58186: ST_TO_ADDR
// if barracks then
58187: LD_VAR 0 8
58191: IFFALSE 58339
// begin selected := 0 ;
58193: LD_ADDR_VAR 0 7
58197: PUSH
58198: LD_INT 0
58200: ST_TO_ADDR
// for j in barracks do
58201: LD_ADDR_VAR 0 3
58205: PUSH
58206: LD_VAR 0 8
58210: PUSH
58211: FOR_IN
58212: IFFALSE 58243
// begin if UnitsInside ( j ) < 6 then
58214: LD_VAR 0 3
58218: PPUSH
58219: CALL_OW 313
58223: PUSH
58224: LD_INT 6
58226: LESS
58227: IFFALSE 58241
// begin selected := j ;
58229: LD_ADDR_VAR 0 7
58233: PUSH
58234: LD_VAR 0 3
58238: ST_TO_ADDR
// break ;
58239: GO 58243
// end ; end ;
58241: GO 58211
58243: POP
58244: POP
// if selected then
58245: LD_VAR 0 7
58249: IFFALSE 58339
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58251: LD_ADDR_VAR 0 3
58255: PUSH
58256: LD_EXP 129
58260: PUSH
58261: LD_VAR 0 2
58265: ARRAY
58266: PPUSH
58267: LD_INT 25
58269: PUSH
58270: LD_INT 12
58272: PUSH
58273: EMPTY
58274: LIST
58275: LIST
58276: PPUSH
58277: CALL_OW 72
58281: PUSH
58282: FOR_IN
58283: IFFALSE 58337
// if not IsInUnit ( j ) and not HasTask ( j ) then
58285: LD_VAR 0 3
58289: PPUSH
58290: CALL_OW 310
58294: NOT
58295: PUSH
58296: LD_VAR 0 3
58300: PPUSH
58301: CALL_OW 314
58305: NOT
58306: AND
58307: IFFALSE 58335
// begin ComEnterUnit ( j , selected ) ;
58309: LD_VAR 0 3
58313: PPUSH
58314: LD_VAR 0 7
58318: PPUSH
58319: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
58323: LD_VAR 0 3
58327: PPUSH
58328: LD_INT 15
58330: PPUSH
58331: CALL_OW 183
// end ;
58335: GO 58282
58337: POP
58338: POP
// end ; end ; end ; end ; end ;
58339: GO 57732
58341: POP
58342: POP
// end ;
58343: LD_VAR 0 1
58347: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
58348: LD_INT 0
58350: PPUSH
58351: PPUSH
58352: PPUSH
58353: PPUSH
// if not mc_bases then
58354: LD_EXP 100
58358: NOT
58359: IFFALSE 58363
// exit ;
58361: GO 58541
// for i = 1 to mc_bases do
58363: LD_ADDR_VAR 0 2
58367: PUSH
58368: DOUBLE
58369: LD_INT 1
58371: DEC
58372: ST_TO_ADDR
58373: LD_EXP 100
58377: PUSH
58378: FOR_TO
58379: IFFALSE 58539
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
58381: LD_ADDR_VAR 0 4
58385: PUSH
58386: LD_EXP 100
58390: PUSH
58391: LD_VAR 0 2
58395: ARRAY
58396: PPUSH
58397: LD_INT 25
58399: PUSH
58400: LD_INT 9
58402: PUSH
58403: EMPTY
58404: LIST
58405: LIST
58406: PPUSH
58407: CALL_OW 72
58411: ST_TO_ADDR
// if not tmp then
58412: LD_VAR 0 4
58416: NOT
58417: IFFALSE 58421
// continue ;
58419: GO 58378
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
58421: LD_EXP 126
58425: PUSH
58426: LD_VAR 0 2
58430: ARRAY
58431: PPUSH
58432: LD_INT 29
58434: PPUSH
58435: CALL_OW 325
58439: NOT
58440: PUSH
58441: LD_EXP 126
58445: PUSH
58446: LD_VAR 0 2
58450: ARRAY
58451: PPUSH
58452: LD_INT 28
58454: PPUSH
58455: CALL_OW 325
58459: NOT
58460: AND
58461: IFFALSE 58465
// continue ;
58463: GO 58378
// for j in tmp do
58465: LD_ADDR_VAR 0 3
58469: PUSH
58470: LD_VAR 0 4
58474: PUSH
58475: FOR_IN
58476: IFFALSE 58535
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58478: LD_VAR 0 3
58482: PUSH
58483: LD_EXP 103
58487: PUSH
58488: LD_VAR 0 2
58492: ARRAY
58493: PUSH
58494: LD_INT 1
58496: ARRAY
58497: IN
58498: NOT
58499: PUSH
58500: LD_VAR 0 3
58504: PUSH
58505: LD_EXP 103
58509: PUSH
58510: LD_VAR 0 2
58514: ARRAY
58515: PUSH
58516: LD_INT 2
58518: ARRAY
58519: IN
58520: NOT
58521: AND
58522: IFFALSE 58533
// ComSpaceTimeShoot ( j ) ;
58524: LD_VAR 0 3
58528: PPUSH
58529: CALL 69742 0 1
58533: GO 58475
58535: POP
58536: POP
// end ;
58537: GO 58378
58539: POP
58540: POP
// end ;
58541: LD_VAR 0 1
58545: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
58546: LD_INT 0
58548: PPUSH
58549: PPUSH
58550: PPUSH
58551: PPUSH
58552: PPUSH
58553: PPUSH
58554: PPUSH
58555: PPUSH
58556: PPUSH
// if not mc_bases then
58557: LD_EXP 100
58561: NOT
58562: IFFALSE 58566
// exit ;
58564: GO 59188
// for i = 1 to mc_bases do
58566: LD_ADDR_VAR 0 2
58570: PUSH
58571: DOUBLE
58572: LD_INT 1
58574: DEC
58575: ST_TO_ADDR
58576: LD_EXP 100
58580: PUSH
58581: FOR_TO
58582: IFFALSE 59186
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
58584: LD_EXP 135
58588: PUSH
58589: LD_VAR 0 2
58593: ARRAY
58594: NOT
58595: PUSH
58596: LD_INT 38
58598: PPUSH
58599: LD_EXP 126
58603: PUSH
58604: LD_VAR 0 2
58608: ARRAY
58609: PPUSH
58610: CALL_OW 321
58614: PUSH
58615: LD_INT 2
58617: NONEQUAL
58618: OR
58619: IFFALSE 58623
// continue ;
58621: GO 58581
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
58623: LD_ADDR_VAR 0 8
58627: PUSH
58628: LD_EXP 100
58632: PUSH
58633: LD_VAR 0 2
58637: ARRAY
58638: PPUSH
58639: LD_INT 30
58641: PUSH
58642: LD_INT 34
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: PPUSH
58649: CALL_OW 72
58653: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
58654: LD_ADDR_VAR 0 9
58658: PUSH
58659: LD_EXP 100
58663: PUSH
58664: LD_VAR 0 2
58668: ARRAY
58669: PPUSH
58670: LD_INT 25
58672: PUSH
58673: LD_INT 4
58675: PUSH
58676: EMPTY
58677: LIST
58678: LIST
58679: PPUSH
58680: CALL_OW 72
58684: PPUSH
58685: LD_INT 0
58687: PPUSH
58688: CALL 103669 0 2
58692: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
58693: LD_VAR 0 9
58697: NOT
58698: PUSH
58699: LD_VAR 0 8
58703: NOT
58704: OR
58705: PUSH
58706: LD_EXP 100
58710: PUSH
58711: LD_VAR 0 2
58715: ARRAY
58716: PPUSH
58717: LD_INT 124
58719: PPUSH
58720: CALL 103669 0 2
58724: OR
58725: IFFALSE 58729
// continue ;
58727: GO 58581
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
58729: LD_EXP 136
58733: PUSH
58734: LD_VAR 0 2
58738: ARRAY
58739: PUSH
58740: LD_EXP 135
58744: PUSH
58745: LD_VAR 0 2
58749: ARRAY
58750: LESS
58751: PUSH
58752: LD_EXP 136
58756: PUSH
58757: LD_VAR 0 2
58761: ARRAY
58762: PUSH
58763: LD_VAR 0 8
58767: LESS
58768: AND
58769: IFFALSE 59184
// begin tmp := sci [ 1 ] ;
58771: LD_ADDR_VAR 0 7
58775: PUSH
58776: LD_VAR 0 9
58780: PUSH
58781: LD_INT 1
58783: ARRAY
58784: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
58785: LD_VAR 0 7
58789: PPUSH
58790: LD_INT 124
58792: PPUSH
58793: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
58797: LD_ADDR_VAR 0 3
58801: PUSH
58802: DOUBLE
58803: LD_EXP 135
58807: PUSH
58808: LD_VAR 0 2
58812: ARRAY
58813: INC
58814: ST_TO_ADDR
58815: LD_EXP 135
58819: PUSH
58820: LD_VAR 0 2
58824: ARRAY
58825: PUSH
58826: FOR_DOWNTO
58827: IFFALSE 59170
// begin if IsInUnit ( tmp ) then
58829: LD_VAR 0 7
58833: PPUSH
58834: CALL_OW 310
58838: IFFALSE 58849
// ComExitBuilding ( tmp ) ;
58840: LD_VAR 0 7
58844: PPUSH
58845: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
58849: LD_INT 35
58851: PPUSH
58852: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
58856: LD_VAR 0 7
58860: PPUSH
58861: CALL_OW 310
58865: NOT
58866: PUSH
58867: LD_VAR 0 7
58871: PPUSH
58872: CALL_OW 314
58876: NOT
58877: AND
58878: IFFALSE 58849
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
58880: LD_ADDR_VAR 0 6
58884: PUSH
58885: LD_VAR 0 7
58889: PPUSH
58890: CALL_OW 250
58894: PUSH
58895: LD_VAR 0 7
58899: PPUSH
58900: CALL_OW 251
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
58909: LD_INT 35
58911: PPUSH
58912: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
58916: LD_ADDR_VAR 0 4
58920: PUSH
58921: LD_EXP 135
58925: PUSH
58926: LD_VAR 0 2
58930: ARRAY
58931: PUSH
58932: LD_VAR 0 3
58936: ARRAY
58937: PUSH
58938: LD_INT 1
58940: ARRAY
58941: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
58942: LD_ADDR_VAR 0 5
58946: PUSH
58947: LD_EXP 135
58951: PUSH
58952: LD_VAR 0 2
58956: ARRAY
58957: PUSH
58958: LD_VAR 0 3
58962: ARRAY
58963: PUSH
58964: LD_INT 2
58966: ARRAY
58967: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
58968: LD_VAR 0 7
58972: PPUSH
58973: LD_INT 10
58975: PPUSH
58976: CALL 76354 0 2
58980: PUSH
58981: LD_INT 4
58983: ARRAY
58984: IFFALSE 59022
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
58986: LD_VAR 0 7
58990: PPUSH
58991: LD_VAR 0 6
58995: PUSH
58996: LD_INT 1
58998: ARRAY
58999: PPUSH
59000: LD_VAR 0 6
59004: PUSH
59005: LD_INT 2
59007: ARRAY
59008: PPUSH
59009: CALL_OW 111
// wait ( 0 0$10 ) ;
59013: LD_INT 350
59015: PPUSH
59016: CALL_OW 67
// end else
59020: GO 59048
// begin ComMoveXY ( tmp , x , y ) ;
59022: LD_VAR 0 7
59026: PPUSH
59027: LD_VAR 0 4
59031: PPUSH
59032: LD_VAR 0 5
59036: PPUSH
59037: CALL_OW 111
// wait ( 0 0$3 ) ;
59041: LD_INT 105
59043: PPUSH
59044: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59048: LD_VAR 0 7
59052: PPUSH
59053: LD_VAR 0 4
59057: PPUSH
59058: LD_VAR 0 5
59062: PPUSH
59063: CALL_OW 307
59067: IFFALSE 58909
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59069: LD_VAR 0 7
59073: PPUSH
59074: LD_VAR 0 4
59078: PPUSH
59079: LD_VAR 0 5
59083: PPUSH
59084: LD_VAR 0 8
59088: PUSH
59089: LD_VAR 0 3
59093: ARRAY
59094: PPUSH
59095: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59099: LD_INT 35
59101: PPUSH
59102: CALL_OW 67
// until not HasTask ( tmp ) ;
59106: LD_VAR 0 7
59110: PPUSH
59111: CALL_OW 314
59115: NOT
59116: IFFALSE 59099
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59118: LD_ADDR_EXP 136
59122: PUSH
59123: LD_EXP 136
59127: PPUSH
59128: LD_VAR 0 2
59132: PUSH
59133: LD_EXP 136
59137: PUSH
59138: LD_VAR 0 2
59142: ARRAY
59143: PUSH
59144: LD_INT 1
59146: PLUS
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: PPUSH
59152: LD_VAR 0 8
59156: PUSH
59157: LD_VAR 0 3
59161: ARRAY
59162: PPUSH
59163: CALL 73757 0 3
59167: ST_TO_ADDR
// end ;
59168: GO 58826
59170: POP
59171: POP
// MC_Reset ( i , 124 ) ;
59172: LD_VAR 0 2
59176: PPUSH
59177: LD_INT 124
59179: PPUSH
59180: CALL 42270 0 2
// end ; end ;
59184: GO 58581
59186: POP
59187: POP
// end ;
59188: LD_VAR 0 1
59192: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59193: LD_INT 0
59195: PPUSH
59196: PPUSH
59197: PPUSH
// if not mc_bases then
59198: LD_EXP 100
59202: NOT
59203: IFFALSE 59207
// exit ;
59205: GO 59813
// for i = 1 to mc_bases do
59207: LD_ADDR_VAR 0 2
59211: PUSH
59212: DOUBLE
59213: LD_INT 1
59215: DEC
59216: ST_TO_ADDR
59217: LD_EXP 100
59221: PUSH
59222: FOR_TO
59223: IFFALSE 59811
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59225: LD_ADDR_VAR 0 3
59229: PUSH
59230: LD_EXP 100
59234: PUSH
59235: LD_VAR 0 2
59239: ARRAY
59240: PPUSH
59241: LD_INT 25
59243: PUSH
59244: LD_INT 4
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: PPUSH
59251: CALL_OW 72
59255: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59256: LD_VAR 0 3
59260: NOT
59261: PUSH
59262: LD_EXP 137
59266: PUSH
59267: LD_VAR 0 2
59271: ARRAY
59272: NOT
59273: OR
59274: PUSH
59275: LD_EXP 100
59279: PUSH
59280: LD_VAR 0 2
59284: ARRAY
59285: PPUSH
59286: LD_INT 2
59288: PUSH
59289: LD_INT 30
59291: PUSH
59292: LD_INT 0
59294: PUSH
59295: EMPTY
59296: LIST
59297: LIST
59298: PUSH
59299: LD_INT 30
59301: PUSH
59302: LD_INT 1
59304: PUSH
59305: EMPTY
59306: LIST
59307: LIST
59308: PUSH
59309: EMPTY
59310: LIST
59311: LIST
59312: LIST
59313: PPUSH
59314: CALL_OW 72
59318: NOT
59319: OR
59320: IFFALSE 59370
// begin if mc_deposits_finder [ i ] then
59322: LD_EXP 138
59326: PUSH
59327: LD_VAR 0 2
59331: ARRAY
59332: IFFALSE 59368
// begin MC_Reset ( i , 125 ) ;
59334: LD_VAR 0 2
59338: PPUSH
59339: LD_INT 125
59341: PPUSH
59342: CALL 42270 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59346: LD_ADDR_EXP 138
59350: PUSH
59351: LD_EXP 138
59355: PPUSH
59356: LD_VAR 0 2
59360: PPUSH
59361: EMPTY
59362: PPUSH
59363: CALL_OW 1
59367: ST_TO_ADDR
// end ; continue ;
59368: GO 59222
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
59370: LD_EXP 137
59374: PUSH
59375: LD_VAR 0 2
59379: ARRAY
59380: PUSH
59381: LD_INT 1
59383: ARRAY
59384: PUSH
59385: LD_INT 3
59387: ARRAY
59388: PUSH
59389: LD_INT 1
59391: EQUAL
59392: PUSH
59393: LD_INT 20
59395: PPUSH
59396: LD_EXP 126
59400: PUSH
59401: LD_VAR 0 2
59405: ARRAY
59406: PPUSH
59407: CALL_OW 321
59411: PUSH
59412: LD_INT 2
59414: NONEQUAL
59415: AND
59416: IFFALSE 59466
// begin if mc_deposits_finder [ i ] then
59418: LD_EXP 138
59422: PUSH
59423: LD_VAR 0 2
59427: ARRAY
59428: IFFALSE 59464
// begin MC_Reset ( i , 125 ) ;
59430: LD_VAR 0 2
59434: PPUSH
59435: LD_INT 125
59437: PPUSH
59438: CALL 42270 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59442: LD_ADDR_EXP 138
59446: PUSH
59447: LD_EXP 138
59451: PPUSH
59452: LD_VAR 0 2
59456: PPUSH
59457: EMPTY
59458: PPUSH
59459: CALL_OW 1
59463: ST_TO_ADDR
// end ; continue ;
59464: GO 59222
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
59466: LD_EXP 137
59470: PUSH
59471: LD_VAR 0 2
59475: ARRAY
59476: PUSH
59477: LD_INT 1
59479: ARRAY
59480: PUSH
59481: LD_INT 1
59483: ARRAY
59484: PPUSH
59485: LD_EXP 137
59489: PUSH
59490: LD_VAR 0 2
59494: ARRAY
59495: PUSH
59496: LD_INT 1
59498: ARRAY
59499: PUSH
59500: LD_INT 2
59502: ARRAY
59503: PPUSH
59504: LD_EXP 126
59508: PUSH
59509: LD_VAR 0 2
59513: ARRAY
59514: PPUSH
59515: CALL_OW 440
59519: IFFALSE 59562
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
59521: LD_ADDR_EXP 137
59525: PUSH
59526: LD_EXP 137
59530: PPUSH
59531: LD_VAR 0 2
59535: PPUSH
59536: LD_EXP 137
59540: PUSH
59541: LD_VAR 0 2
59545: ARRAY
59546: PPUSH
59547: LD_INT 1
59549: PPUSH
59550: CALL_OW 3
59554: PPUSH
59555: CALL_OW 1
59559: ST_TO_ADDR
59560: GO 59809
// begin if not mc_deposits_finder [ i ] then
59562: LD_EXP 138
59566: PUSH
59567: LD_VAR 0 2
59571: ARRAY
59572: NOT
59573: IFFALSE 59625
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
59575: LD_ADDR_EXP 138
59579: PUSH
59580: LD_EXP 138
59584: PPUSH
59585: LD_VAR 0 2
59589: PPUSH
59590: LD_VAR 0 3
59594: PUSH
59595: LD_INT 1
59597: ARRAY
59598: PUSH
59599: EMPTY
59600: LIST
59601: PPUSH
59602: CALL_OW 1
59606: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
59607: LD_VAR 0 3
59611: PUSH
59612: LD_INT 1
59614: ARRAY
59615: PPUSH
59616: LD_INT 125
59618: PPUSH
59619: CALL_OW 109
// end else
59623: GO 59809
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
59625: LD_EXP 138
59629: PUSH
59630: LD_VAR 0 2
59634: ARRAY
59635: PUSH
59636: LD_INT 1
59638: ARRAY
59639: PPUSH
59640: CALL_OW 310
59644: IFFALSE 59667
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
59646: LD_EXP 138
59650: PUSH
59651: LD_VAR 0 2
59655: ARRAY
59656: PUSH
59657: LD_INT 1
59659: ARRAY
59660: PPUSH
59661: CALL_OW 122
59665: GO 59809
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
59667: LD_EXP 138
59671: PUSH
59672: LD_VAR 0 2
59676: ARRAY
59677: PUSH
59678: LD_INT 1
59680: ARRAY
59681: PPUSH
59682: CALL_OW 314
59686: NOT
59687: PUSH
59688: LD_EXP 138
59692: PUSH
59693: LD_VAR 0 2
59697: ARRAY
59698: PUSH
59699: LD_INT 1
59701: ARRAY
59702: PPUSH
59703: LD_EXP 137
59707: PUSH
59708: LD_VAR 0 2
59712: ARRAY
59713: PUSH
59714: LD_INT 1
59716: ARRAY
59717: PUSH
59718: LD_INT 1
59720: ARRAY
59721: PPUSH
59722: LD_EXP 137
59726: PUSH
59727: LD_VAR 0 2
59731: ARRAY
59732: PUSH
59733: LD_INT 1
59735: ARRAY
59736: PUSH
59737: LD_INT 2
59739: ARRAY
59740: PPUSH
59741: CALL_OW 297
59745: PUSH
59746: LD_INT 6
59748: GREATER
59749: AND
59750: IFFALSE 59809
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
59752: LD_EXP 138
59756: PUSH
59757: LD_VAR 0 2
59761: ARRAY
59762: PUSH
59763: LD_INT 1
59765: ARRAY
59766: PPUSH
59767: LD_EXP 137
59771: PUSH
59772: LD_VAR 0 2
59776: ARRAY
59777: PUSH
59778: LD_INT 1
59780: ARRAY
59781: PUSH
59782: LD_INT 1
59784: ARRAY
59785: PPUSH
59786: LD_EXP 137
59790: PUSH
59791: LD_VAR 0 2
59795: ARRAY
59796: PUSH
59797: LD_INT 1
59799: ARRAY
59800: PUSH
59801: LD_INT 2
59803: ARRAY
59804: PPUSH
59805: CALL_OW 111
// end ; end ; end ;
59809: GO 59222
59811: POP
59812: POP
// end ;
59813: LD_VAR 0 1
59817: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
59818: LD_INT 0
59820: PPUSH
59821: PPUSH
59822: PPUSH
59823: PPUSH
59824: PPUSH
59825: PPUSH
59826: PPUSH
59827: PPUSH
59828: PPUSH
59829: PPUSH
59830: PPUSH
// if not mc_bases then
59831: LD_EXP 100
59835: NOT
59836: IFFALSE 59840
// exit ;
59838: GO 60780
// for i = 1 to mc_bases do
59840: LD_ADDR_VAR 0 2
59844: PUSH
59845: DOUBLE
59846: LD_INT 1
59848: DEC
59849: ST_TO_ADDR
59850: LD_EXP 100
59854: PUSH
59855: FOR_TO
59856: IFFALSE 60778
// begin if not mc_bases [ i ] or mc_scan [ i ] then
59858: LD_EXP 100
59862: PUSH
59863: LD_VAR 0 2
59867: ARRAY
59868: NOT
59869: PUSH
59870: LD_EXP 123
59874: PUSH
59875: LD_VAR 0 2
59879: ARRAY
59880: OR
59881: IFFALSE 59885
// continue ;
59883: GO 59855
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
59885: LD_ADDR_VAR 0 7
59889: PUSH
59890: LD_EXP 100
59894: PUSH
59895: LD_VAR 0 2
59899: ARRAY
59900: PUSH
59901: LD_INT 1
59903: ARRAY
59904: PPUSH
59905: CALL_OW 248
59909: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
59910: LD_VAR 0 7
59914: PUSH
59915: LD_INT 3
59917: EQUAL
59918: PUSH
59919: LD_EXP 119
59923: PUSH
59924: LD_VAR 0 2
59928: ARRAY
59929: PUSH
59930: LD_EXP 122
59934: PUSH
59935: LD_VAR 0 2
59939: ARRAY
59940: UNION
59941: PPUSH
59942: LD_INT 33
59944: PUSH
59945: LD_INT 2
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PPUSH
59952: CALL_OW 72
59956: NOT
59957: OR
59958: IFFALSE 59962
// continue ;
59960: GO 59855
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
59962: LD_ADDR_VAR 0 9
59966: PUSH
59967: LD_EXP 100
59971: PUSH
59972: LD_VAR 0 2
59976: ARRAY
59977: PPUSH
59978: LD_INT 30
59980: PUSH
59981: LD_INT 36
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: PPUSH
59988: CALL_OW 72
59992: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
59993: LD_ADDR_VAR 0 10
59997: PUSH
59998: LD_EXP 119
60002: PUSH
60003: LD_VAR 0 2
60007: ARRAY
60008: PPUSH
60009: LD_INT 34
60011: PUSH
60012: LD_INT 31
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: PPUSH
60019: CALL_OW 72
60023: ST_TO_ADDR
// if not cts and not mcts then
60024: LD_VAR 0 9
60028: NOT
60029: PUSH
60030: LD_VAR 0 10
60034: NOT
60035: AND
60036: IFFALSE 60040
// continue ;
60038: GO 59855
// x := cts ;
60040: LD_ADDR_VAR 0 11
60044: PUSH
60045: LD_VAR 0 9
60049: ST_TO_ADDR
// if not x then
60050: LD_VAR 0 11
60054: NOT
60055: IFFALSE 60067
// x := mcts ;
60057: LD_ADDR_VAR 0 11
60061: PUSH
60062: LD_VAR 0 10
60066: ST_TO_ADDR
// if not x then
60067: LD_VAR 0 11
60071: NOT
60072: IFFALSE 60076
// continue ;
60074: GO 59855
// if mc_remote_driver [ i ] then
60076: LD_EXP 140
60080: PUSH
60081: LD_VAR 0 2
60085: ARRAY
60086: IFFALSE 60473
// for j in mc_remote_driver [ i ] do
60088: LD_ADDR_VAR 0 3
60092: PUSH
60093: LD_EXP 140
60097: PUSH
60098: LD_VAR 0 2
60102: ARRAY
60103: PUSH
60104: FOR_IN
60105: IFFALSE 60471
// begin if GetClass ( j ) <> 3 then
60107: LD_VAR 0 3
60111: PPUSH
60112: CALL_OW 257
60116: PUSH
60117: LD_INT 3
60119: NONEQUAL
60120: IFFALSE 60173
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60122: LD_ADDR_EXP 140
60126: PUSH
60127: LD_EXP 140
60131: PPUSH
60132: LD_VAR 0 2
60136: PPUSH
60137: LD_EXP 140
60141: PUSH
60142: LD_VAR 0 2
60146: ARRAY
60147: PUSH
60148: LD_VAR 0 3
60152: DIFF
60153: PPUSH
60154: CALL_OW 1
60158: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60159: LD_VAR 0 3
60163: PPUSH
60164: LD_INT 0
60166: PPUSH
60167: CALL_OW 109
// continue ;
60171: GO 60104
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60173: LD_EXP 119
60177: PUSH
60178: LD_VAR 0 2
60182: ARRAY
60183: PPUSH
60184: LD_INT 34
60186: PUSH
60187: LD_INT 31
60189: PUSH
60190: EMPTY
60191: LIST
60192: LIST
60193: PUSH
60194: LD_INT 58
60196: PUSH
60197: EMPTY
60198: LIST
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: PPUSH
60204: CALL_OW 72
60208: PUSH
60209: LD_VAR 0 3
60213: PPUSH
60214: CALL 103704 0 1
60218: NOT
60219: AND
60220: IFFALSE 60291
// begin if IsInUnit ( j ) then
60222: LD_VAR 0 3
60226: PPUSH
60227: CALL_OW 310
60231: IFFALSE 60242
// ComExitBuilding ( j ) ;
60233: LD_VAR 0 3
60237: PPUSH
60238: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60242: LD_VAR 0 3
60246: PPUSH
60247: LD_EXP 119
60251: PUSH
60252: LD_VAR 0 2
60256: ARRAY
60257: PPUSH
60258: LD_INT 34
60260: PUSH
60261: LD_INT 31
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: PUSH
60268: LD_INT 58
60270: PUSH
60271: EMPTY
60272: LIST
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PPUSH
60278: CALL_OW 72
60282: PUSH
60283: LD_INT 1
60285: ARRAY
60286: PPUSH
60287: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
60291: LD_VAR 0 3
60295: PPUSH
60296: CALL_OW 310
60300: NOT
60301: PUSH
60302: LD_VAR 0 3
60306: PPUSH
60307: CALL_OW 310
60311: PPUSH
60312: CALL_OW 266
60316: PUSH
60317: LD_INT 36
60319: NONEQUAL
60320: PUSH
60321: LD_VAR 0 3
60325: PPUSH
60326: CALL 103704 0 1
60330: NOT
60331: AND
60332: OR
60333: IFFALSE 60469
// begin if IsInUnit ( j ) then
60335: LD_VAR 0 3
60339: PPUSH
60340: CALL_OW 310
60344: IFFALSE 60355
// ComExitBuilding ( j ) ;
60346: LD_VAR 0 3
60350: PPUSH
60351: CALL_OW 122
// ct := 0 ;
60355: LD_ADDR_VAR 0 8
60359: PUSH
60360: LD_INT 0
60362: ST_TO_ADDR
// for k in x do
60363: LD_ADDR_VAR 0 4
60367: PUSH
60368: LD_VAR 0 11
60372: PUSH
60373: FOR_IN
60374: IFFALSE 60447
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
60376: LD_VAR 0 4
60380: PPUSH
60381: CALL_OW 264
60385: PUSH
60386: LD_INT 31
60388: EQUAL
60389: PUSH
60390: LD_VAR 0 4
60394: PPUSH
60395: CALL_OW 311
60399: NOT
60400: AND
60401: PUSH
60402: LD_VAR 0 4
60406: PPUSH
60407: CALL_OW 266
60411: PUSH
60412: LD_INT 36
60414: EQUAL
60415: PUSH
60416: LD_VAR 0 4
60420: PPUSH
60421: CALL_OW 313
60425: PUSH
60426: LD_INT 3
60428: LESS
60429: AND
60430: OR
60431: IFFALSE 60445
// begin ct := k ;
60433: LD_ADDR_VAR 0 8
60437: PUSH
60438: LD_VAR 0 4
60442: ST_TO_ADDR
// break ;
60443: GO 60447
// end ;
60445: GO 60373
60447: POP
60448: POP
// if ct then
60449: LD_VAR 0 8
60453: IFFALSE 60469
// ComEnterUnit ( j , ct ) ;
60455: LD_VAR 0 3
60459: PPUSH
60460: LD_VAR 0 8
60464: PPUSH
60465: CALL_OW 120
// end ; end ;
60469: GO 60104
60471: POP
60472: POP
// places := 0 ;
60473: LD_ADDR_VAR 0 5
60477: PUSH
60478: LD_INT 0
60480: ST_TO_ADDR
// for j = 1 to x do
60481: LD_ADDR_VAR 0 3
60485: PUSH
60486: DOUBLE
60487: LD_INT 1
60489: DEC
60490: ST_TO_ADDR
60491: LD_VAR 0 11
60495: PUSH
60496: FOR_TO
60497: IFFALSE 60573
// if GetWeapon ( x [ j ] ) = ar_control_tower then
60499: LD_VAR 0 11
60503: PUSH
60504: LD_VAR 0 3
60508: ARRAY
60509: PPUSH
60510: CALL_OW 264
60514: PUSH
60515: LD_INT 31
60517: EQUAL
60518: IFFALSE 60536
// places := places + 1 else
60520: LD_ADDR_VAR 0 5
60524: PUSH
60525: LD_VAR 0 5
60529: PUSH
60530: LD_INT 1
60532: PLUS
60533: ST_TO_ADDR
60534: GO 60571
// if GetBType ( x [ j ] ) = b_control_tower then
60536: LD_VAR 0 11
60540: PUSH
60541: LD_VAR 0 3
60545: ARRAY
60546: PPUSH
60547: CALL_OW 266
60551: PUSH
60552: LD_INT 36
60554: EQUAL
60555: IFFALSE 60571
// places := places + 3 ;
60557: LD_ADDR_VAR 0 5
60561: PUSH
60562: LD_VAR 0 5
60566: PUSH
60567: LD_INT 3
60569: PLUS
60570: ST_TO_ADDR
60571: GO 60496
60573: POP
60574: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
60575: LD_VAR 0 5
60579: PUSH
60580: LD_INT 0
60582: EQUAL
60583: PUSH
60584: LD_VAR 0 5
60588: PUSH
60589: LD_EXP 140
60593: PUSH
60594: LD_VAR 0 2
60598: ARRAY
60599: LESSEQUAL
60600: OR
60601: IFFALSE 60605
// continue ;
60603: GO 59855
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
60605: LD_ADDR_VAR 0 6
60609: PUSH
60610: LD_EXP 100
60614: PUSH
60615: LD_VAR 0 2
60619: ARRAY
60620: PPUSH
60621: LD_INT 25
60623: PUSH
60624: LD_INT 3
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: PPUSH
60631: CALL_OW 72
60635: PUSH
60636: LD_EXP 140
60640: PUSH
60641: LD_VAR 0 2
60645: ARRAY
60646: DIFF
60647: PPUSH
60648: LD_INT 3
60650: PPUSH
60651: CALL 104604 0 2
60655: ST_TO_ADDR
// for j in tmp do
60656: LD_ADDR_VAR 0 3
60660: PUSH
60661: LD_VAR 0 6
60665: PUSH
60666: FOR_IN
60667: IFFALSE 60702
// if GetTag ( j ) > 0 then
60669: LD_VAR 0 3
60673: PPUSH
60674: CALL_OW 110
60678: PUSH
60679: LD_INT 0
60681: GREATER
60682: IFFALSE 60700
// tmp := tmp diff j ;
60684: LD_ADDR_VAR 0 6
60688: PUSH
60689: LD_VAR 0 6
60693: PUSH
60694: LD_VAR 0 3
60698: DIFF
60699: ST_TO_ADDR
60700: GO 60666
60702: POP
60703: POP
// if not tmp then
60704: LD_VAR 0 6
60708: NOT
60709: IFFALSE 60713
// continue ;
60711: GO 59855
// if places then
60713: LD_VAR 0 5
60717: IFFALSE 60776
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
60719: LD_ADDR_EXP 140
60723: PUSH
60724: LD_EXP 140
60728: PPUSH
60729: LD_VAR 0 2
60733: PPUSH
60734: LD_EXP 140
60738: PUSH
60739: LD_VAR 0 2
60743: ARRAY
60744: PUSH
60745: LD_VAR 0 6
60749: PUSH
60750: LD_INT 1
60752: ARRAY
60753: UNION
60754: PPUSH
60755: CALL_OW 1
60759: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
60760: LD_VAR 0 6
60764: PUSH
60765: LD_INT 1
60767: ARRAY
60768: PPUSH
60769: LD_INT 126
60771: PPUSH
60772: CALL_OW 109
// end ; end ;
60776: GO 59855
60778: POP
60779: POP
// end ;
60780: LD_VAR 0 1
60784: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
60785: LD_INT 0
60787: PPUSH
60788: PPUSH
60789: PPUSH
60790: PPUSH
60791: PPUSH
60792: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
60793: LD_VAR 0 1
60797: NOT
60798: PUSH
60799: LD_VAR 0 2
60803: NOT
60804: OR
60805: PUSH
60806: LD_VAR 0 3
60810: NOT
60811: OR
60812: PUSH
60813: LD_VAR 0 4
60817: PUSH
60818: LD_INT 1
60820: PUSH
60821: LD_INT 2
60823: PUSH
60824: LD_INT 3
60826: PUSH
60827: LD_INT 4
60829: PUSH
60830: LD_INT 5
60832: PUSH
60833: LD_INT 8
60835: PUSH
60836: LD_INT 9
60838: PUSH
60839: LD_INT 15
60841: PUSH
60842: LD_INT 16
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: LIST
60849: LIST
60850: LIST
60851: LIST
60852: LIST
60853: LIST
60854: LIST
60855: IN
60856: NOT
60857: OR
60858: IFFALSE 60862
// exit ;
60860: GO 61720
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
60862: LD_ADDR_VAR 0 2
60866: PUSH
60867: LD_VAR 0 2
60871: PPUSH
60872: LD_INT 21
60874: PUSH
60875: LD_INT 3
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: PUSH
60882: LD_INT 24
60884: PUSH
60885: LD_INT 250
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PPUSH
60896: CALL_OW 72
60900: ST_TO_ADDR
// case class of 1 , 15 :
60901: LD_VAR 0 4
60905: PUSH
60906: LD_INT 1
60908: DOUBLE
60909: EQUAL
60910: IFTRUE 60920
60912: LD_INT 15
60914: DOUBLE
60915: EQUAL
60916: IFTRUE 60920
60918: GO 61005
60920: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
60921: LD_ADDR_VAR 0 8
60925: PUSH
60926: LD_VAR 0 2
60930: PPUSH
60931: LD_INT 2
60933: PUSH
60934: LD_INT 30
60936: PUSH
60937: LD_INT 32
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: PUSH
60944: LD_INT 30
60946: PUSH
60947: LD_INT 31
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: LIST
60958: PPUSH
60959: CALL_OW 72
60963: PUSH
60964: LD_VAR 0 2
60968: PPUSH
60969: LD_INT 2
60971: PUSH
60972: LD_INT 30
60974: PUSH
60975: LD_INT 4
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: PUSH
60982: LD_INT 30
60984: PUSH
60985: LD_INT 5
60987: PUSH
60988: EMPTY
60989: LIST
60990: LIST
60991: PUSH
60992: EMPTY
60993: LIST
60994: LIST
60995: LIST
60996: PPUSH
60997: CALL_OW 72
61001: ADD
61002: ST_TO_ADDR
61003: GO 61251
61005: LD_INT 2
61007: DOUBLE
61008: EQUAL
61009: IFTRUE 61019
61011: LD_INT 16
61013: DOUBLE
61014: EQUAL
61015: IFTRUE 61019
61017: GO 61065
61019: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61020: LD_ADDR_VAR 0 8
61024: PUSH
61025: LD_VAR 0 2
61029: PPUSH
61030: LD_INT 2
61032: PUSH
61033: LD_INT 30
61035: PUSH
61036: LD_INT 0
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PUSH
61043: LD_INT 30
61045: PUSH
61046: LD_INT 1
61048: PUSH
61049: EMPTY
61050: LIST
61051: LIST
61052: PUSH
61053: EMPTY
61054: LIST
61055: LIST
61056: LIST
61057: PPUSH
61058: CALL_OW 72
61062: ST_TO_ADDR
61063: GO 61251
61065: LD_INT 3
61067: DOUBLE
61068: EQUAL
61069: IFTRUE 61073
61071: GO 61119
61073: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61074: LD_ADDR_VAR 0 8
61078: PUSH
61079: LD_VAR 0 2
61083: PPUSH
61084: LD_INT 2
61086: PUSH
61087: LD_INT 30
61089: PUSH
61090: LD_INT 2
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: PUSH
61097: LD_INT 30
61099: PUSH
61100: LD_INT 3
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: LIST
61111: PPUSH
61112: CALL_OW 72
61116: ST_TO_ADDR
61117: GO 61251
61119: LD_INT 4
61121: DOUBLE
61122: EQUAL
61123: IFTRUE 61127
61125: GO 61184
61127: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61128: LD_ADDR_VAR 0 8
61132: PUSH
61133: LD_VAR 0 2
61137: PPUSH
61138: LD_INT 2
61140: PUSH
61141: LD_INT 30
61143: PUSH
61144: LD_INT 6
61146: PUSH
61147: EMPTY
61148: LIST
61149: LIST
61150: PUSH
61151: LD_INT 30
61153: PUSH
61154: LD_INT 7
61156: PUSH
61157: EMPTY
61158: LIST
61159: LIST
61160: PUSH
61161: LD_INT 30
61163: PUSH
61164: LD_INT 8
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: PUSH
61171: EMPTY
61172: LIST
61173: LIST
61174: LIST
61175: LIST
61176: PPUSH
61177: CALL_OW 72
61181: ST_TO_ADDR
61182: GO 61251
61184: LD_INT 5
61186: DOUBLE
61187: EQUAL
61188: IFTRUE 61204
61190: LD_INT 8
61192: DOUBLE
61193: EQUAL
61194: IFTRUE 61204
61196: LD_INT 9
61198: DOUBLE
61199: EQUAL
61200: IFTRUE 61204
61202: GO 61250
61204: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
61205: LD_ADDR_VAR 0 8
61209: PUSH
61210: LD_VAR 0 2
61214: PPUSH
61215: LD_INT 2
61217: PUSH
61218: LD_INT 30
61220: PUSH
61221: LD_INT 4
61223: PUSH
61224: EMPTY
61225: LIST
61226: LIST
61227: PUSH
61228: LD_INT 30
61230: PUSH
61231: LD_INT 5
61233: PUSH
61234: EMPTY
61235: LIST
61236: LIST
61237: PUSH
61238: EMPTY
61239: LIST
61240: LIST
61241: LIST
61242: PPUSH
61243: CALL_OW 72
61247: ST_TO_ADDR
61248: GO 61251
61250: POP
// if not tmp then
61251: LD_VAR 0 8
61255: NOT
61256: IFFALSE 61260
// exit ;
61258: GO 61720
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
61260: LD_VAR 0 4
61264: PUSH
61265: LD_INT 1
61267: PUSH
61268: LD_INT 15
61270: PUSH
61271: EMPTY
61272: LIST
61273: LIST
61274: IN
61275: PUSH
61276: LD_EXP 109
61280: PUSH
61281: LD_VAR 0 1
61285: ARRAY
61286: AND
61287: IFFALSE 61443
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
61289: LD_ADDR_VAR 0 9
61293: PUSH
61294: LD_EXP 109
61298: PUSH
61299: LD_VAR 0 1
61303: ARRAY
61304: PUSH
61305: LD_INT 1
61307: ARRAY
61308: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
61309: LD_VAR 0 9
61313: PUSH
61314: LD_EXP 110
61318: PUSH
61319: LD_VAR 0 1
61323: ARRAY
61324: IN
61325: NOT
61326: IFFALSE 61441
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
61328: LD_ADDR_EXP 110
61332: PUSH
61333: LD_EXP 110
61337: PPUSH
61338: LD_VAR 0 1
61342: PUSH
61343: LD_EXP 110
61347: PUSH
61348: LD_VAR 0 1
61352: ARRAY
61353: PUSH
61354: LD_INT 1
61356: PLUS
61357: PUSH
61358: EMPTY
61359: LIST
61360: LIST
61361: PPUSH
61362: LD_VAR 0 9
61366: PPUSH
61367: CALL 73757 0 3
61371: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
61372: LD_ADDR_EXP 109
61376: PUSH
61377: LD_EXP 109
61381: PPUSH
61382: LD_VAR 0 1
61386: PPUSH
61387: LD_EXP 109
61391: PUSH
61392: LD_VAR 0 1
61396: ARRAY
61397: PUSH
61398: LD_VAR 0 9
61402: DIFF
61403: PPUSH
61404: CALL_OW 1
61408: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
61409: LD_VAR 0 3
61413: PPUSH
61414: LD_EXP 110
61418: PUSH
61419: LD_VAR 0 1
61423: ARRAY
61424: PUSH
61425: LD_EXP 110
61429: PUSH
61430: LD_VAR 0 1
61434: ARRAY
61435: ARRAY
61436: PPUSH
61437: CALL_OW 120
// end ; exit ;
61441: GO 61720
// end ; if tmp > 1 then
61443: LD_VAR 0 8
61447: PUSH
61448: LD_INT 1
61450: GREATER
61451: IFFALSE 61555
// for i = 2 to tmp do
61453: LD_ADDR_VAR 0 6
61457: PUSH
61458: DOUBLE
61459: LD_INT 2
61461: DEC
61462: ST_TO_ADDR
61463: LD_VAR 0 8
61467: PUSH
61468: FOR_TO
61469: IFFALSE 61553
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
61471: LD_VAR 0 8
61475: PUSH
61476: LD_VAR 0 6
61480: ARRAY
61481: PPUSH
61482: CALL_OW 461
61486: PUSH
61487: LD_INT 6
61489: EQUAL
61490: IFFALSE 61551
// begin x := tmp [ i ] ;
61492: LD_ADDR_VAR 0 9
61496: PUSH
61497: LD_VAR 0 8
61501: PUSH
61502: LD_VAR 0 6
61506: ARRAY
61507: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
61508: LD_ADDR_VAR 0 8
61512: PUSH
61513: LD_VAR 0 8
61517: PPUSH
61518: LD_VAR 0 6
61522: PPUSH
61523: CALL_OW 3
61527: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
61528: LD_ADDR_VAR 0 8
61532: PUSH
61533: LD_VAR 0 8
61537: PPUSH
61538: LD_INT 1
61540: PPUSH
61541: LD_VAR 0 9
61545: PPUSH
61546: CALL_OW 2
61550: ST_TO_ADDR
// end ;
61551: GO 61468
61553: POP
61554: POP
// for i in tmp do
61555: LD_ADDR_VAR 0 6
61559: PUSH
61560: LD_VAR 0 8
61564: PUSH
61565: FOR_IN
61566: IFFALSE 61593
// begin if IsNotFull ( i ) then
61568: LD_VAR 0 6
61572: PPUSH
61573: CALL 70979 0 1
61577: IFFALSE 61591
// begin j := i ;
61579: LD_ADDR_VAR 0 7
61583: PUSH
61584: LD_VAR 0 6
61588: ST_TO_ADDR
// break ;
61589: GO 61593
// end ; end ;
61591: GO 61565
61593: POP
61594: POP
// if j then
61595: LD_VAR 0 7
61599: IFFALSE 61617
// ComEnterUnit ( unit , j ) else
61601: LD_VAR 0 3
61605: PPUSH
61606: LD_VAR 0 7
61610: PPUSH
61611: CALL_OW 120
61615: GO 61720
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61617: LD_ADDR_VAR 0 10
61621: PUSH
61622: LD_VAR 0 2
61626: PPUSH
61627: LD_INT 2
61629: PUSH
61630: LD_INT 30
61632: PUSH
61633: LD_INT 0
61635: PUSH
61636: EMPTY
61637: LIST
61638: LIST
61639: PUSH
61640: LD_INT 30
61642: PUSH
61643: LD_INT 1
61645: PUSH
61646: EMPTY
61647: LIST
61648: LIST
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: LIST
61654: PPUSH
61655: CALL_OW 72
61659: ST_TO_ADDR
// if depot then
61660: LD_VAR 0 10
61664: IFFALSE 61720
// begin depot := NearestUnitToUnit ( depot , unit ) ;
61666: LD_ADDR_VAR 0 10
61670: PUSH
61671: LD_VAR 0 10
61675: PPUSH
61676: LD_VAR 0 3
61680: PPUSH
61681: CALL_OW 74
61685: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
61686: LD_VAR 0 3
61690: PPUSH
61691: LD_VAR 0 10
61695: PPUSH
61696: CALL_OW 296
61700: PUSH
61701: LD_INT 10
61703: GREATER
61704: IFFALSE 61720
// ComStandNearbyBuilding ( unit , depot ) ;
61706: LD_VAR 0 3
61710: PPUSH
61711: LD_VAR 0 10
61715: PPUSH
61716: CALL 70359 0 2
// end ; end ; end ;
61720: LD_VAR 0 5
61724: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
61725: LD_INT 0
61727: PPUSH
61728: PPUSH
61729: PPUSH
61730: PPUSH
// if not mc_bases then
61731: LD_EXP 100
61735: NOT
61736: IFFALSE 61740
// exit ;
61738: GO 61979
// for i = 1 to mc_bases do
61740: LD_ADDR_VAR 0 2
61744: PUSH
61745: DOUBLE
61746: LD_INT 1
61748: DEC
61749: ST_TO_ADDR
61750: LD_EXP 100
61754: PUSH
61755: FOR_TO
61756: IFFALSE 61977
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
61758: LD_ADDR_VAR 0 4
61762: PUSH
61763: LD_EXP 100
61767: PUSH
61768: LD_VAR 0 2
61772: ARRAY
61773: PPUSH
61774: LD_INT 21
61776: PUSH
61777: LD_INT 1
61779: PUSH
61780: EMPTY
61781: LIST
61782: LIST
61783: PPUSH
61784: CALL_OW 72
61788: PUSH
61789: LD_EXP 129
61793: PUSH
61794: LD_VAR 0 2
61798: ARRAY
61799: UNION
61800: ST_TO_ADDR
// if not tmp then
61801: LD_VAR 0 4
61805: NOT
61806: IFFALSE 61810
// continue ;
61808: GO 61755
// for j in tmp do
61810: LD_ADDR_VAR 0 3
61814: PUSH
61815: LD_VAR 0 4
61819: PUSH
61820: FOR_IN
61821: IFFALSE 61973
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
61823: LD_VAR 0 3
61827: PPUSH
61828: CALL_OW 110
61832: NOT
61833: PUSH
61834: LD_VAR 0 3
61838: PPUSH
61839: CALL_OW 314
61843: NOT
61844: AND
61845: PUSH
61846: LD_VAR 0 3
61850: PPUSH
61851: CALL_OW 311
61855: NOT
61856: AND
61857: PUSH
61858: LD_VAR 0 3
61862: PPUSH
61863: CALL_OW 310
61867: NOT
61868: AND
61869: PUSH
61870: LD_VAR 0 3
61874: PUSH
61875: LD_EXP 103
61879: PUSH
61880: LD_VAR 0 2
61884: ARRAY
61885: PUSH
61886: LD_INT 1
61888: ARRAY
61889: IN
61890: NOT
61891: AND
61892: PUSH
61893: LD_VAR 0 3
61897: PUSH
61898: LD_EXP 103
61902: PUSH
61903: LD_VAR 0 2
61907: ARRAY
61908: PUSH
61909: LD_INT 2
61911: ARRAY
61912: IN
61913: NOT
61914: AND
61915: PUSH
61916: LD_VAR 0 3
61920: PUSH
61921: LD_EXP 112
61925: PUSH
61926: LD_VAR 0 2
61930: ARRAY
61931: IN
61932: NOT
61933: AND
61934: IFFALSE 61971
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
61936: LD_VAR 0 2
61940: PPUSH
61941: LD_EXP 100
61945: PUSH
61946: LD_VAR 0 2
61950: ARRAY
61951: PPUSH
61952: LD_VAR 0 3
61956: PPUSH
61957: LD_VAR 0 3
61961: PPUSH
61962: CALL_OW 257
61966: PPUSH
61967: CALL 60785 0 4
// end ;
61971: GO 61820
61973: POP
61974: POP
// end ;
61975: GO 61755
61977: POP
61978: POP
// end ;
61979: LD_VAR 0 1
61983: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
61984: LD_INT 0
61986: PPUSH
61987: PPUSH
61988: PPUSH
61989: PPUSH
61990: PPUSH
61991: PPUSH
// if not mc_bases [ base ] then
61992: LD_EXP 100
61996: PUSH
61997: LD_VAR 0 1
62001: ARRAY
62002: NOT
62003: IFFALSE 62007
// exit ;
62005: GO 62208
// tmp := [ ] ;
62007: LD_ADDR_VAR 0 6
62011: PUSH
62012: EMPTY
62013: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62014: LD_ADDR_VAR 0 7
62018: PUSH
62019: LD_VAR 0 3
62023: PPUSH
62024: LD_INT 0
62026: PPUSH
62027: CALL_OW 517
62031: ST_TO_ADDR
// if not list then
62032: LD_VAR 0 7
62036: NOT
62037: IFFALSE 62041
// exit ;
62039: GO 62208
// c := Count ( list [ 1 ] ) ;
62041: LD_ADDR_VAR 0 9
62045: PUSH
62046: LD_VAR 0 7
62050: PUSH
62051: LD_INT 1
62053: ARRAY
62054: PPUSH
62055: CALL 70897 0 1
62059: ST_TO_ADDR
// if amount > c then
62060: LD_VAR 0 2
62064: PUSH
62065: LD_VAR 0 9
62069: GREATER
62070: IFFALSE 62082
// amount := c ;
62072: LD_ADDR_VAR 0 2
62076: PUSH
62077: LD_VAR 0 9
62081: ST_TO_ADDR
// for i := 1 to amount do
62082: LD_ADDR_VAR 0 5
62086: PUSH
62087: DOUBLE
62088: LD_INT 1
62090: DEC
62091: ST_TO_ADDR
62092: LD_VAR 0 2
62096: PUSH
62097: FOR_TO
62098: IFFALSE 62156
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62100: LD_ADDR_VAR 0 6
62104: PUSH
62105: LD_VAR 0 6
62109: PPUSH
62110: LD_VAR 0 5
62114: PPUSH
62115: LD_VAR 0 7
62119: PUSH
62120: LD_INT 1
62122: ARRAY
62123: PUSH
62124: LD_VAR 0 5
62128: ARRAY
62129: PUSH
62130: LD_VAR 0 7
62134: PUSH
62135: LD_INT 2
62137: ARRAY
62138: PUSH
62139: LD_VAR 0 5
62143: ARRAY
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PPUSH
62149: CALL_OW 1
62153: ST_TO_ADDR
62154: GO 62097
62156: POP
62157: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62158: LD_ADDR_EXP 113
62162: PUSH
62163: LD_EXP 113
62167: PPUSH
62168: LD_VAR 0 1
62172: PPUSH
62173: LD_VAR 0 6
62177: PPUSH
62178: CALL_OW 1
62182: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62183: LD_ADDR_EXP 115
62187: PUSH
62188: LD_EXP 115
62192: PPUSH
62193: LD_VAR 0 1
62197: PPUSH
62198: LD_VAR 0 3
62202: PPUSH
62203: CALL_OW 1
62207: ST_TO_ADDR
// end ;
62208: LD_VAR 0 4
62212: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
62213: LD_INT 0
62215: PPUSH
// if not mc_bases [ base ] then
62216: LD_EXP 100
62220: PUSH
62221: LD_VAR 0 1
62225: ARRAY
62226: NOT
62227: IFFALSE 62231
// exit ;
62229: GO 62256
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
62231: LD_ADDR_EXP 105
62235: PUSH
62236: LD_EXP 105
62240: PPUSH
62241: LD_VAR 0 1
62245: PPUSH
62246: LD_VAR 0 2
62250: PPUSH
62251: CALL_OW 1
62255: ST_TO_ADDR
// end ;
62256: LD_VAR 0 3
62260: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
62261: LD_INT 0
62263: PPUSH
// if not mc_bases [ base ] then
62264: LD_EXP 100
62268: PUSH
62269: LD_VAR 0 1
62273: ARRAY
62274: NOT
62275: IFFALSE 62279
// exit ;
62277: GO 62316
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
62279: LD_ADDR_EXP 105
62283: PUSH
62284: LD_EXP 105
62288: PPUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: LD_EXP 105
62298: PUSH
62299: LD_VAR 0 1
62303: ARRAY
62304: PUSH
62305: LD_VAR 0 2
62309: UNION
62310: PPUSH
62311: CALL_OW 1
62315: ST_TO_ADDR
// end ;
62316: LD_VAR 0 3
62320: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
62321: LD_INT 0
62323: PPUSH
// if not mc_bases [ base ] then
62324: LD_EXP 100
62328: PUSH
62329: LD_VAR 0 1
62333: ARRAY
62334: NOT
62335: IFFALSE 62339
// exit ;
62337: GO 62364
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
62339: LD_ADDR_EXP 121
62343: PUSH
62344: LD_EXP 121
62348: PPUSH
62349: LD_VAR 0 1
62353: PPUSH
62354: LD_VAR 0 2
62358: PPUSH
62359: CALL_OW 1
62363: ST_TO_ADDR
// end ;
62364: LD_VAR 0 3
62368: RET
// export function MC_InsertProduceList ( base , components ) ; begin
62369: LD_INT 0
62371: PPUSH
// if not mc_bases [ base ] then
62372: LD_EXP 100
62376: PUSH
62377: LD_VAR 0 1
62381: ARRAY
62382: NOT
62383: IFFALSE 62387
// exit ;
62385: GO 62424
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
62387: LD_ADDR_EXP 121
62391: PUSH
62392: LD_EXP 121
62396: PPUSH
62397: LD_VAR 0 1
62401: PPUSH
62402: LD_EXP 121
62406: PUSH
62407: LD_VAR 0 1
62411: ARRAY
62412: PUSH
62413: LD_VAR 0 2
62417: ADD
62418: PPUSH
62419: CALL_OW 1
62423: ST_TO_ADDR
// end ;
62424: LD_VAR 0 3
62428: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
62429: LD_INT 0
62431: PPUSH
// if not mc_bases [ base ] then
62432: LD_EXP 100
62436: PUSH
62437: LD_VAR 0 1
62441: ARRAY
62442: NOT
62443: IFFALSE 62447
// exit ;
62445: GO 62501
// mc_defender := Replace ( mc_defender , base , deflist ) ;
62447: LD_ADDR_EXP 122
62451: PUSH
62452: LD_EXP 122
62456: PPUSH
62457: LD_VAR 0 1
62461: PPUSH
62462: LD_VAR 0 2
62466: PPUSH
62467: CALL_OW 1
62471: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
62472: LD_ADDR_EXP 111
62476: PUSH
62477: LD_EXP 111
62481: PPUSH
62482: LD_VAR 0 1
62486: PPUSH
62487: LD_VAR 0 2
62491: PUSH
62492: LD_INT 0
62494: PLUS
62495: PPUSH
62496: CALL_OW 1
62500: ST_TO_ADDR
// end ;
62501: LD_VAR 0 3
62505: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
62506: LD_INT 0
62508: PPUSH
// if not mc_bases [ base ] then
62509: LD_EXP 100
62513: PUSH
62514: LD_VAR 0 1
62518: ARRAY
62519: NOT
62520: IFFALSE 62524
// exit ;
62522: GO 62549
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
62524: LD_ADDR_EXP 111
62528: PUSH
62529: LD_EXP 111
62533: PPUSH
62534: LD_VAR 0 1
62538: PPUSH
62539: LD_VAR 0 2
62543: PPUSH
62544: CALL_OW 1
62548: ST_TO_ADDR
// end ;
62549: LD_VAR 0 3
62553: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
62554: LD_INT 0
62556: PPUSH
62557: PPUSH
62558: PPUSH
62559: PPUSH
// if not mc_bases [ base ] then
62560: LD_EXP 100
62564: PUSH
62565: LD_VAR 0 1
62569: ARRAY
62570: NOT
62571: IFFALSE 62575
// exit ;
62573: GO 62640
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
62575: LD_ADDR_EXP 120
62579: PUSH
62580: LD_EXP 120
62584: PPUSH
62585: LD_VAR 0 1
62589: PUSH
62590: LD_EXP 120
62594: PUSH
62595: LD_VAR 0 1
62599: ARRAY
62600: PUSH
62601: LD_INT 1
62603: PLUS
62604: PUSH
62605: EMPTY
62606: LIST
62607: LIST
62608: PPUSH
62609: LD_VAR 0 1
62613: PUSH
62614: LD_VAR 0 2
62618: PUSH
62619: LD_VAR 0 3
62623: PUSH
62624: LD_VAR 0 4
62628: PUSH
62629: EMPTY
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: PPUSH
62635: CALL 73757 0 3
62639: ST_TO_ADDR
// end ;
62640: LD_VAR 0 5
62644: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
62645: LD_INT 0
62647: PPUSH
// if not mc_bases [ base ] then
62648: LD_EXP 100
62652: PUSH
62653: LD_VAR 0 1
62657: ARRAY
62658: NOT
62659: IFFALSE 62663
// exit ;
62661: GO 62688
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
62663: LD_ADDR_EXP 137
62667: PUSH
62668: LD_EXP 137
62672: PPUSH
62673: LD_VAR 0 1
62677: PPUSH
62678: LD_VAR 0 2
62682: PPUSH
62683: CALL_OW 1
62687: ST_TO_ADDR
// end ;
62688: LD_VAR 0 3
62692: RET
// export function MC_GetMinesField ( base ) ; begin
62693: LD_INT 0
62695: PPUSH
// result := mc_mines [ base ] ;
62696: LD_ADDR_VAR 0 2
62700: PUSH
62701: LD_EXP 113
62705: PUSH
62706: LD_VAR 0 1
62710: ARRAY
62711: ST_TO_ADDR
// end ;
62712: LD_VAR 0 2
62716: RET
// export function MC_GetProduceList ( base ) ; begin
62717: LD_INT 0
62719: PPUSH
// result := mc_produce [ base ] ;
62720: LD_ADDR_VAR 0 2
62724: PUSH
62725: LD_EXP 121
62729: PUSH
62730: LD_VAR 0 1
62734: ARRAY
62735: ST_TO_ADDR
// end ;
62736: LD_VAR 0 2
62740: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
62741: LD_INT 0
62743: PPUSH
62744: PPUSH
// if not mc_bases then
62745: LD_EXP 100
62749: NOT
62750: IFFALSE 62754
// exit ;
62752: GO 62819
// if mc_bases [ base ] then
62754: LD_EXP 100
62758: PUSH
62759: LD_VAR 0 1
62763: ARRAY
62764: IFFALSE 62819
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62766: LD_ADDR_VAR 0 3
62770: PUSH
62771: LD_EXP 100
62775: PUSH
62776: LD_VAR 0 1
62780: ARRAY
62781: PPUSH
62782: LD_INT 30
62784: PUSH
62785: LD_VAR 0 2
62789: PUSH
62790: EMPTY
62791: LIST
62792: LIST
62793: PPUSH
62794: CALL_OW 72
62798: ST_TO_ADDR
// if result then
62799: LD_VAR 0 3
62803: IFFALSE 62819
// result := result [ 1 ] ;
62805: LD_ADDR_VAR 0 3
62809: PUSH
62810: LD_VAR 0 3
62814: PUSH
62815: LD_INT 1
62817: ARRAY
62818: ST_TO_ADDR
// end ; end ;
62819: LD_VAR 0 3
62823: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
62824: LD_INT 0
62826: PPUSH
62827: PPUSH
// if not mc_bases then
62828: LD_EXP 100
62832: NOT
62833: IFFALSE 62837
// exit ;
62835: GO 62882
// if mc_bases [ base ] then
62837: LD_EXP 100
62841: PUSH
62842: LD_VAR 0 1
62846: ARRAY
62847: IFFALSE 62882
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62849: LD_ADDR_VAR 0 3
62853: PUSH
62854: LD_EXP 100
62858: PUSH
62859: LD_VAR 0 1
62863: ARRAY
62864: PPUSH
62865: LD_INT 30
62867: PUSH
62868: LD_VAR 0 2
62872: PUSH
62873: EMPTY
62874: LIST
62875: LIST
62876: PPUSH
62877: CALL_OW 72
62881: ST_TO_ADDR
// end ;
62882: LD_VAR 0 3
62886: RET
// export function MC_SetTame ( base , area ) ; begin
62887: LD_INT 0
62889: PPUSH
// if not mc_bases or not base then
62890: LD_EXP 100
62894: NOT
62895: PUSH
62896: LD_VAR 0 1
62900: NOT
62901: OR
62902: IFFALSE 62906
// exit ;
62904: GO 62931
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
62906: LD_ADDR_EXP 128
62910: PUSH
62911: LD_EXP 128
62915: PPUSH
62916: LD_VAR 0 1
62920: PPUSH
62921: LD_VAR 0 2
62925: PPUSH
62926: CALL_OW 1
62930: ST_TO_ADDR
// end ;
62931: LD_VAR 0 3
62935: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
62936: LD_INT 0
62938: PPUSH
62939: PPUSH
// if not mc_bases or not base then
62940: LD_EXP 100
62944: NOT
62945: PUSH
62946: LD_VAR 0 1
62950: NOT
62951: OR
62952: IFFALSE 62956
// exit ;
62954: GO 63058
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62956: LD_ADDR_VAR 0 4
62960: PUSH
62961: LD_EXP 100
62965: PUSH
62966: LD_VAR 0 1
62970: ARRAY
62971: PPUSH
62972: LD_INT 30
62974: PUSH
62975: LD_VAR 0 2
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PPUSH
62984: CALL_OW 72
62988: ST_TO_ADDR
// if not tmp then
62989: LD_VAR 0 4
62993: NOT
62994: IFFALSE 62998
// exit ;
62996: GO 63058
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
62998: LD_ADDR_EXP 132
63002: PUSH
63003: LD_EXP 132
63007: PPUSH
63008: LD_VAR 0 1
63012: PPUSH
63013: LD_EXP 132
63017: PUSH
63018: LD_VAR 0 1
63022: ARRAY
63023: PPUSH
63024: LD_EXP 132
63028: PUSH
63029: LD_VAR 0 1
63033: ARRAY
63034: PUSH
63035: LD_INT 1
63037: PLUS
63038: PPUSH
63039: LD_VAR 0 4
63043: PUSH
63044: LD_INT 1
63046: ARRAY
63047: PPUSH
63048: CALL_OW 2
63052: PPUSH
63053: CALL_OW 1
63057: ST_TO_ADDR
// end ;
63058: LD_VAR 0 3
63062: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63063: LD_INT 0
63065: PPUSH
63066: PPUSH
// if not mc_bases or not base or not kinds then
63067: LD_EXP 100
63071: NOT
63072: PUSH
63073: LD_VAR 0 1
63077: NOT
63078: OR
63079: PUSH
63080: LD_VAR 0 2
63084: NOT
63085: OR
63086: IFFALSE 63090
// exit ;
63088: GO 63151
// for i in kinds do
63090: LD_ADDR_VAR 0 4
63094: PUSH
63095: LD_VAR 0 2
63099: PUSH
63100: FOR_IN
63101: IFFALSE 63149
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63103: LD_ADDR_EXP 134
63107: PUSH
63108: LD_EXP 134
63112: PPUSH
63113: LD_VAR 0 1
63117: PUSH
63118: LD_EXP 134
63122: PUSH
63123: LD_VAR 0 1
63127: ARRAY
63128: PUSH
63129: LD_INT 1
63131: PLUS
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PPUSH
63137: LD_VAR 0 4
63141: PPUSH
63142: CALL 73757 0 3
63146: ST_TO_ADDR
63147: GO 63100
63149: POP
63150: POP
// end ;
63151: LD_VAR 0 3
63155: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63156: LD_INT 0
63158: PPUSH
// if not mc_bases or not base or not areas then
63159: LD_EXP 100
63163: NOT
63164: PUSH
63165: LD_VAR 0 1
63169: NOT
63170: OR
63171: PUSH
63172: LD_VAR 0 2
63176: NOT
63177: OR
63178: IFFALSE 63182
// exit ;
63180: GO 63207
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63182: LD_ADDR_EXP 118
63186: PUSH
63187: LD_EXP 118
63191: PPUSH
63192: LD_VAR 0 1
63196: PPUSH
63197: LD_VAR 0 2
63201: PPUSH
63202: CALL_OW 1
63206: ST_TO_ADDR
// end ;
63207: LD_VAR 0 3
63211: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
63212: LD_INT 0
63214: PPUSH
// if not mc_bases or not base or not teleports_exit then
63215: LD_EXP 100
63219: NOT
63220: PUSH
63221: LD_VAR 0 1
63225: NOT
63226: OR
63227: PUSH
63228: LD_VAR 0 2
63232: NOT
63233: OR
63234: IFFALSE 63238
// exit ;
63236: GO 63263
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63238: LD_ADDR_EXP 135
63242: PUSH
63243: LD_EXP 135
63247: PPUSH
63248: LD_VAR 0 1
63252: PPUSH
63253: LD_VAR 0 2
63257: PPUSH
63258: CALL_OW 1
63262: ST_TO_ADDR
// end ;
63263: LD_VAR 0 3
63267: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
63268: LD_INT 0
63270: PPUSH
63271: PPUSH
63272: PPUSH
// if not mc_bases or not base or not ext_list then
63273: LD_EXP 100
63277: NOT
63278: PUSH
63279: LD_VAR 0 1
63283: NOT
63284: OR
63285: PUSH
63286: LD_VAR 0 5
63290: NOT
63291: OR
63292: IFFALSE 63296
// exit ;
63294: GO 63469
// tmp := GetFacExtXYD ( x , y , d ) ;
63296: LD_ADDR_VAR 0 8
63300: PUSH
63301: LD_VAR 0 2
63305: PPUSH
63306: LD_VAR 0 3
63310: PPUSH
63311: LD_VAR 0 4
63315: PPUSH
63316: CALL 103734 0 3
63320: ST_TO_ADDR
// if not tmp then
63321: LD_VAR 0 8
63325: NOT
63326: IFFALSE 63330
// exit ;
63328: GO 63469
// for i in tmp do
63330: LD_ADDR_VAR 0 7
63334: PUSH
63335: LD_VAR 0 8
63339: PUSH
63340: FOR_IN
63341: IFFALSE 63467
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
63343: LD_ADDR_EXP 105
63347: PUSH
63348: LD_EXP 105
63352: PPUSH
63353: LD_VAR 0 1
63357: PPUSH
63358: LD_EXP 105
63362: PUSH
63363: LD_VAR 0 1
63367: ARRAY
63368: PPUSH
63369: LD_EXP 105
63373: PUSH
63374: LD_VAR 0 1
63378: ARRAY
63379: PUSH
63380: LD_INT 1
63382: PLUS
63383: PPUSH
63384: LD_VAR 0 5
63388: PUSH
63389: LD_INT 1
63391: ARRAY
63392: PUSH
63393: LD_VAR 0 7
63397: PUSH
63398: LD_INT 1
63400: ARRAY
63401: PUSH
63402: LD_VAR 0 7
63406: PUSH
63407: LD_INT 2
63409: ARRAY
63410: PUSH
63411: LD_VAR 0 7
63415: PUSH
63416: LD_INT 3
63418: ARRAY
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: LIST
63424: LIST
63425: PPUSH
63426: CALL_OW 2
63430: PPUSH
63431: CALL_OW 1
63435: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
63436: LD_ADDR_VAR 0 5
63440: PUSH
63441: LD_VAR 0 5
63445: PPUSH
63446: LD_INT 1
63448: PPUSH
63449: CALL_OW 3
63453: ST_TO_ADDR
// if not ext_list then
63454: LD_VAR 0 5
63458: NOT
63459: IFFALSE 63465
// exit ;
63461: POP
63462: POP
63463: GO 63469
// end ;
63465: GO 63340
63467: POP
63468: POP
// end ;
63469: LD_VAR 0 6
63473: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
63474: LD_INT 0
63476: PPUSH
// if not mc_bases or not base or not weapon_list then
63477: LD_EXP 100
63481: NOT
63482: PUSH
63483: LD_VAR 0 1
63487: NOT
63488: OR
63489: PUSH
63490: LD_VAR 0 2
63494: NOT
63495: OR
63496: IFFALSE 63500
// exit ;
63498: GO 63525
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
63500: LD_ADDR_EXP 139
63504: PUSH
63505: LD_EXP 139
63509: PPUSH
63510: LD_VAR 0 1
63514: PPUSH
63515: LD_VAR 0 2
63519: PPUSH
63520: CALL_OW 1
63524: ST_TO_ADDR
// end ;
63525: LD_VAR 0 3
63529: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
63530: LD_INT 0
63532: PPUSH
// if not mc_bases or not base or not tech_list then
63533: LD_EXP 100
63537: NOT
63538: PUSH
63539: LD_VAR 0 1
63543: NOT
63544: OR
63545: PUSH
63546: LD_VAR 0 2
63550: NOT
63551: OR
63552: IFFALSE 63556
// exit ;
63554: GO 63581
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
63556: LD_ADDR_EXP 127
63560: PUSH
63561: LD_EXP 127
63565: PPUSH
63566: LD_VAR 0 1
63570: PPUSH
63571: LD_VAR 0 2
63575: PPUSH
63576: CALL_OW 1
63580: ST_TO_ADDR
// end ;
63581: LD_VAR 0 3
63585: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
63586: LD_INT 0
63588: PPUSH
// if not mc_bases or not parking_area or not base then
63589: LD_EXP 100
63593: NOT
63594: PUSH
63595: LD_VAR 0 2
63599: NOT
63600: OR
63601: PUSH
63602: LD_VAR 0 1
63606: NOT
63607: OR
63608: IFFALSE 63612
// exit ;
63610: GO 63637
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
63612: LD_ADDR_EXP 124
63616: PUSH
63617: LD_EXP 124
63621: PPUSH
63622: LD_VAR 0 1
63626: PPUSH
63627: LD_VAR 0 2
63631: PPUSH
63632: CALL_OW 1
63636: ST_TO_ADDR
// end ;
63637: LD_VAR 0 3
63641: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
63642: LD_INT 0
63644: PPUSH
// if not mc_bases or not base or not scan_area then
63645: LD_EXP 100
63649: NOT
63650: PUSH
63651: LD_VAR 0 1
63655: NOT
63656: OR
63657: PUSH
63658: LD_VAR 0 2
63662: NOT
63663: OR
63664: IFFALSE 63668
// exit ;
63666: GO 63693
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
63668: LD_ADDR_EXP 125
63672: PUSH
63673: LD_EXP 125
63677: PPUSH
63678: LD_VAR 0 1
63682: PPUSH
63683: LD_VAR 0 2
63687: PPUSH
63688: CALL_OW 1
63692: ST_TO_ADDR
// end ;
63693: LD_VAR 0 3
63697: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
63698: LD_INT 0
63700: PPUSH
63701: PPUSH
// if not mc_bases or not base then
63702: LD_EXP 100
63706: NOT
63707: PUSH
63708: LD_VAR 0 1
63712: NOT
63713: OR
63714: IFFALSE 63718
// exit ;
63716: GO 63782
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
63718: LD_ADDR_VAR 0 3
63722: PUSH
63723: LD_INT 1
63725: PUSH
63726: LD_INT 2
63728: PUSH
63729: LD_INT 3
63731: PUSH
63732: LD_INT 4
63734: PUSH
63735: LD_INT 11
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
63745: LD_ADDR_EXP 127
63749: PUSH
63750: LD_EXP 127
63754: PPUSH
63755: LD_VAR 0 1
63759: PPUSH
63760: LD_EXP 127
63764: PUSH
63765: LD_VAR 0 1
63769: ARRAY
63770: PUSH
63771: LD_VAR 0 3
63775: DIFF
63776: PPUSH
63777: CALL_OW 1
63781: ST_TO_ADDR
// end ;
63782: LD_VAR 0 2
63786: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
63787: LD_INT 0
63789: PPUSH
// result := mc_vehicles [ base ] ;
63790: LD_ADDR_VAR 0 3
63794: PUSH
63795: LD_EXP 119
63799: PUSH
63800: LD_VAR 0 1
63804: ARRAY
63805: ST_TO_ADDR
// if onlyCombat then
63806: LD_VAR 0 2
63810: IFFALSE 63982
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
63812: LD_ADDR_VAR 0 3
63816: PUSH
63817: LD_VAR 0 3
63821: PUSH
63822: LD_VAR 0 3
63826: PPUSH
63827: LD_INT 2
63829: PUSH
63830: LD_INT 34
63832: PUSH
63833: LD_INT 12
63835: PUSH
63836: EMPTY
63837: LIST
63838: LIST
63839: PUSH
63840: LD_INT 34
63842: PUSH
63843: LD_INT 51
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: LD_INT 34
63852: PUSH
63853: LD_INT 89
63855: PUSH
63856: EMPTY
63857: LIST
63858: LIST
63859: PUSH
63860: LD_INT 34
63862: PUSH
63863: LD_INT 32
63865: PUSH
63866: EMPTY
63867: LIST
63868: LIST
63869: PUSH
63870: LD_INT 34
63872: PUSH
63873: LD_INT 13
63875: PUSH
63876: EMPTY
63877: LIST
63878: LIST
63879: PUSH
63880: LD_INT 34
63882: PUSH
63883: LD_INT 52
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 34
63892: PUSH
63893: LD_INT 88
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 34
63902: PUSH
63903: LD_INT 14
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: LD_INT 34
63912: PUSH
63913: LD_INT 53
63915: PUSH
63916: EMPTY
63917: LIST
63918: LIST
63919: PUSH
63920: LD_INT 34
63922: PUSH
63923: LD_INT 98
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: PUSH
63930: LD_INT 34
63932: PUSH
63933: LD_INT 31
63935: PUSH
63936: EMPTY
63937: LIST
63938: LIST
63939: PUSH
63940: LD_INT 34
63942: PUSH
63943: LD_INT 48
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 34
63952: PUSH
63953: LD_INT 8
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: LIST
63970: LIST
63971: LIST
63972: LIST
63973: LIST
63974: LIST
63975: PPUSH
63976: CALL_OW 72
63980: DIFF
63981: ST_TO_ADDR
// end ; end_of_file
63982: LD_VAR 0 3
63986: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
63987: LD_INT 0
63989: PPUSH
63990: PPUSH
63991: PPUSH
// if not mc_bases or not skirmish then
63992: LD_EXP 100
63996: NOT
63997: PUSH
63998: LD_EXP 98
64002: NOT
64003: OR
64004: IFFALSE 64008
// exit ;
64006: GO 64173
// for i = 1 to mc_bases do
64008: LD_ADDR_VAR 0 4
64012: PUSH
64013: DOUBLE
64014: LD_INT 1
64016: DEC
64017: ST_TO_ADDR
64018: LD_EXP 100
64022: PUSH
64023: FOR_TO
64024: IFFALSE 64171
// begin if sci in mc_bases [ i ] then
64026: LD_VAR 0 2
64030: PUSH
64031: LD_EXP 100
64035: PUSH
64036: LD_VAR 0 4
64040: ARRAY
64041: IN
64042: IFFALSE 64169
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64044: LD_ADDR_EXP 129
64048: PUSH
64049: LD_EXP 129
64053: PPUSH
64054: LD_VAR 0 4
64058: PUSH
64059: LD_EXP 129
64063: PUSH
64064: LD_VAR 0 4
64068: ARRAY
64069: PUSH
64070: LD_INT 1
64072: PLUS
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: PPUSH
64078: LD_VAR 0 1
64082: PPUSH
64083: CALL 73757 0 3
64087: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64088: LD_ADDR_VAR 0 5
64092: PUSH
64093: LD_EXP 100
64097: PUSH
64098: LD_VAR 0 4
64102: ARRAY
64103: PPUSH
64104: LD_INT 2
64106: PUSH
64107: LD_INT 30
64109: PUSH
64110: LD_INT 0
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 30
64119: PUSH
64120: LD_INT 1
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: EMPTY
64128: LIST
64129: LIST
64130: LIST
64131: PPUSH
64132: CALL_OW 72
64136: PPUSH
64137: LD_VAR 0 1
64141: PPUSH
64142: CALL_OW 74
64146: ST_TO_ADDR
// if tmp then
64147: LD_VAR 0 5
64151: IFFALSE 64167
// ComStandNearbyBuilding ( ape , tmp ) ;
64153: LD_VAR 0 1
64157: PPUSH
64158: LD_VAR 0 5
64162: PPUSH
64163: CALL 70359 0 2
// break ;
64167: GO 64171
// end ; end ;
64169: GO 64023
64171: POP
64172: POP
// end ;
64173: LD_VAR 0 3
64177: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64178: LD_INT 0
64180: PPUSH
64181: PPUSH
64182: PPUSH
// if not mc_bases or not skirmish then
64183: LD_EXP 100
64187: NOT
64188: PUSH
64189: LD_EXP 98
64193: NOT
64194: OR
64195: IFFALSE 64199
// exit ;
64197: GO 64288
// for i = 1 to mc_bases do
64199: LD_ADDR_VAR 0 4
64203: PUSH
64204: DOUBLE
64205: LD_INT 1
64207: DEC
64208: ST_TO_ADDR
64209: LD_EXP 100
64213: PUSH
64214: FOR_TO
64215: IFFALSE 64286
// begin if building in mc_busy_turret_list [ i ] then
64217: LD_VAR 0 1
64221: PUSH
64222: LD_EXP 110
64226: PUSH
64227: LD_VAR 0 4
64231: ARRAY
64232: IN
64233: IFFALSE 64284
// begin tmp := mc_busy_turret_list [ i ] diff building ;
64235: LD_ADDR_VAR 0 5
64239: PUSH
64240: LD_EXP 110
64244: PUSH
64245: LD_VAR 0 4
64249: ARRAY
64250: PUSH
64251: LD_VAR 0 1
64255: DIFF
64256: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
64257: LD_ADDR_EXP 110
64261: PUSH
64262: LD_EXP 110
64266: PPUSH
64267: LD_VAR 0 4
64271: PPUSH
64272: LD_VAR 0 5
64276: PPUSH
64277: CALL_OW 1
64281: ST_TO_ADDR
// break ;
64282: GO 64286
// end ; end ;
64284: GO 64214
64286: POP
64287: POP
// end ;
64288: LD_VAR 0 3
64292: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
64293: LD_INT 0
64295: PPUSH
64296: PPUSH
64297: PPUSH
// if not mc_bases or not skirmish then
64298: LD_EXP 100
64302: NOT
64303: PUSH
64304: LD_EXP 98
64308: NOT
64309: OR
64310: IFFALSE 64314
// exit ;
64312: GO 64513
// for i = 1 to mc_bases do
64314: LD_ADDR_VAR 0 5
64318: PUSH
64319: DOUBLE
64320: LD_INT 1
64322: DEC
64323: ST_TO_ADDR
64324: LD_EXP 100
64328: PUSH
64329: FOR_TO
64330: IFFALSE 64511
// if building in mc_bases [ i ] then
64332: LD_VAR 0 1
64336: PUSH
64337: LD_EXP 100
64341: PUSH
64342: LD_VAR 0 5
64346: ARRAY
64347: IN
64348: IFFALSE 64509
// begin tmp := mc_bases [ i ] diff building ;
64350: LD_ADDR_VAR 0 6
64354: PUSH
64355: LD_EXP 100
64359: PUSH
64360: LD_VAR 0 5
64364: ARRAY
64365: PUSH
64366: LD_VAR 0 1
64370: DIFF
64371: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
64372: LD_ADDR_EXP 100
64376: PUSH
64377: LD_EXP 100
64381: PPUSH
64382: LD_VAR 0 5
64386: PPUSH
64387: LD_VAR 0 6
64391: PPUSH
64392: CALL_OW 1
64396: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
64397: LD_VAR 0 1
64401: PUSH
64402: LD_EXP 108
64406: PUSH
64407: LD_VAR 0 5
64411: ARRAY
64412: IN
64413: IFFALSE 64452
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
64415: LD_ADDR_EXP 108
64419: PUSH
64420: LD_EXP 108
64424: PPUSH
64425: LD_VAR 0 5
64429: PPUSH
64430: LD_EXP 108
64434: PUSH
64435: LD_VAR 0 5
64439: ARRAY
64440: PUSH
64441: LD_VAR 0 1
64445: DIFF
64446: PPUSH
64447: CALL_OW 1
64451: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
64452: LD_VAR 0 1
64456: PUSH
64457: LD_EXP 109
64461: PUSH
64462: LD_VAR 0 5
64466: ARRAY
64467: IN
64468: IFFALSE 64507
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
64470: LD_ADDR_EXP 109
64474: PUSH
64475: LD_EXP 109
64479: PPUSH
64480: LD_VAR 0 5
64484: PPUSH
64485: LD_EXP 109
64489: PUSH
64490: LD_VAR 0 5
64494: ARRAY
64495: PUSH
64496: LD_VAR 0 1
64500: DIFF
64501: PPUSH
64502: CALL_OW 1
64506: ST_TO_ADDR
// break ;
64507: GO 64511
// end ;
64509: GO 64329
64511: POP
64512: POP
// end ;
64513: LD_VAR 0 4
64517: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
64518: LD_INT 0
64520: PPUSH
64521: PPUSH
64522: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
64523: LD_EXP 100
64527: NOT
64528: PUSH
64529: LD_EXP 98
64533: NOT
64534: OR
64535: PUSH
64536: LD_VAR 0 3
64540: PUSH
64541: LD_EXP 126
64545: IN
64546: NOT
64547: OR
64548: IFFALSE 64552
// exit ;
64550: GO 64675
// for i = 1 to mc_vehicles do
64552: LD_ADDR_VAR 0 6
64556: PUSH
64557: DOUBLE
64558: LD_INT 1
64560: DEC
64561: ST_TO_ADDR
64562: LD_EXP 119
64566: PUSH
64567: FOR_TO
64568: IFFALSE 64673
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
64570: LD_VAR 0 2
64574: PUSH
64575: LD_EXP 119
64579: PUSH
64580: LD_VAR 0 6
64584: ARRAY
64585: IN
64586: PUSH
64587: LD_VAR 0 1
64591: PUSH
64592: LD_EXP 119
64596: PUSH
64597: LD_VAR 0 6
64601: ARRAY
64602: IN
64603: OR
64604: IFFALSE 64671
// begin tmp := mc_vehicles [ i ] diff old ;
64606: LD_ADDR_VAR 0 7
64610: PUSH
64611: LD_EXP 119
64615: PUSH
64616: LD_VAR 0 6
64620: ARRAY
64621: PUSH
64622: LD_VAR 0 2
64626: DIFF
64627: ST_TO_ADDR
// tmp := tmp diff new ;
64628: LD_ADDR_VAR 0 7
64632: PUSH
64633: LD_VAR 0 7
64637: PUSH
64638: LD_VAR 0 1
64642: DIFF
64643: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
64644: LD_ADDR_EXP 119
64648: PUSH
64649: LD_EXP 119
64653: PPUSH
64654: LD_VAR 0 6
64658: PPUSH
64659: LD_VAR 0 7
64663: PPUSH
64664: CALL_OW 1
64668: ST_TO_ADDR
// break ;
64669: GO 64673
// end ;
64671: GO 64567
64673: POP
64674: POP
// end ;
64675: LD_VAR 0 5
64679: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
64680: LD_INT 0
64682: PPUSH
64683: PPUSH
64684: PPUSH
64685: PPUSH
// if not mc_bases or not skirmish then
64686: LD_EXP 100
64690: NOT
64691: PUSH
64692: LD_EXP 98
64696: NOT
64697: OR
64698: IFFALSE 64702
// exit ;
64700: GO 65122
// repeat wait ( 0 0$1 ) ;
64702: LD_INT 35
64704: PPUSH
64705: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
64709: LD_EXP 144
64713: NOT
64714: IFFALSE 64702
// mc_block_vehicle_constructed_thread := true ;
64716: LD_ADDR_EXP 144
64720: PUSH
64721: LD_INT 1
64723: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
64724: LD_ADDR_VAR 0 5
64728: PUSH
64729: LD_VAR 0 1
64733: PPUSH
64734: CALL_OW 255
64738: ST_TO_ADDR
// for i = 1 to mc_bases do
64739: LD_ADDR_VAR 0 4
64743: PUSH
64744: DOUBLE
64745: LD_INT 1
64747: DEC
64748: ST_TO_ADDR
64749: LD_EXP 100
64753: PUSH
64754: FOR_TO
64755: IFFALSE 65112
// begin if factory in mc_bases [ i ] then
64757: LD_VAR 0 2
64761: PUSH
64762: LD_EXP 100
64766: PUSH
64767: LD_VAR 0 4
64771: ARRAY
64772: IN
64773: IFFALSE 65110
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
64775: LD_EXP 122
64779: PUSH
64780: LD_VAR 0 4
64784: ARRAY
64785: PUSH
64786: LD_EXP 111
64790: PUSH
64791: LD_VAR 0 4
64795: ARRAY
64796: LESS
64797: PUSH
64798: LD_VAR 0 1
64802: PPUSH
64803: CALL_OW 264
64807: PUSH
64808: LD_INT 31
64810: PUSH
64811: LD_INT 32
64813: PUSH
64814: LD_INT 51
64816: PUSH
64817: LD_INT 89
64819: PUSH
64820: LD_INT 12
64822: PUSH
64823: LD_INT 30
64825: PUSH
64826: LD_INT 98
64828: PUSH
64829: LD_INT 11
64831: PUSH
64832: LD_INT 53
64834: PUSH
64835: LD_INT 14
64837: PUSH
64838: LD_INT 91
64840: PUSH
64841: LD_INT 29
64843: PUSH
64844: LD_INT 99
64846: PUSH
64847: LD_INT 13
64849: PUSH
64850: LD_INT 52
64852: PUSH
64853: LD_INT 88
64855: PUSH
64856: LD_INT 48
64858: PUSH
64859: LD_INT 8
64861: PUSH
64862: EMPTY
64863: LIST
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: IN
64882: NOT
64883: AND
64884: IFFALSE 64932
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
64886: LD_ADDR_EXP 122
64890: PUSH
64891: LD_EXP 122
64895: PPUSH
64896: LD_VAR 0 4
64900: PUSH
64901: LD_EXP 122
64905: PUSH
64906: LD_VAR 0 4
64910: ARRAY
64911: PUSH
64912: LD_INT 1
64914: PLUS
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PPUSH
64920: LD_VAR 0 1
64924: PPUSH
64925: CALL 73757 0 3
64929: ST_TO_ADDR
64930: GO 64976
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
64932: LD_ADDR_EXP 119
64936: PUSH
64937: LD_EXP 119
64941: PPUSH
64942: LD_VAR 0 4
64946: PUSH
64947: LD_EXP 119
64951: PUSH
64952: LD_VAR 0 4
64956: ARRAY
64957: PUSH
64958: LD_INT 1
64960: PLUS
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PPUSH
64966: LD_VAR 0 1
64970: PPUSH
64971: CALL 73757 0 3
64975: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
64976: LD_ADDR_EXP 144
64980: PUSH
64981: LD_INT 0
64983: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
64984: LD_VAR 0 1
64988: PPUSH
64989: CALL_OW 263
64993: PUSH
64994: LD_INT 2
64996: EQUAL
64997: IFFALSE 65026
// begin repeat wait ( 0 0$3 ) ;
64999: LD_INT 105
65001: PPUSH
65002: CALL_OW 67
// Connect ( vehicle ) ;
65006: LD_VAR 0 1
65010: PPUSH
65011: CALL 76726 0 1
// until IsControledBy ( vehicle ) ;
65015: LD_VAR 0 1
65019: PPUSH
65020: CALL_OW 312
65024: IFFALSE 64999
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65026: LD_VAR 0 1
65030: PPUSH
65031: LD_EXP 124
65035: PUSH
65036: LD_VAR 0 4
65040: ARRAY
65041: PPUSH
65042: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65046: LD_VAR 0 1
65050: PPUSH
65051: CALL_OW 263
65055: PUSH
65056: LD_INT 1
65058: NONEQUAL
65059: IFFALSE 65063
// break ;
65061: GO 65112
// repeat wait ( 0 0$1 ) ;
65063: LD_INT 35
65065: PPUSH
65066: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65070: LD_VAR 0 1
65074: PPUSH
65075: LD_EXP 124
65079: PUSH
65080: LD_VAR 0 4
65084: ARRAY
65085: PPUSH
65086: CALL_OW 308
65090: IFFALSE 65063
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65092: LD_VAR 0 1
65096: PPUSH
65097: CALL_OW 311
65101: PPUSH
65102: CALL_OW 121
// exit ;
65106: POP
65107: POP
65108: GO 65122
// end ; end ;
65110: GO 64754
65112: POP
65113: POP
// mc_block_vehicle_constructed_thread := false ;
65114: LD_ADDR_EXP 144
65118: PUSH
65119: LD_INT 0
65121: ST_TO_ADDR
// end ;
65122: LD_VAR 0 3
65126: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65127: LD_INT 0
65129: PPUSH
65130: PPUSH
65131: PPUSH
65132: PPUSH
// if not mc_bases or not skirmish then
65133: LD_EXP 100
65137: NOT
65138: PUSH
65139: LD_EXP 98
65143: NOT
65144: OR
65145: IFFALSE 65149
// exit ;
65147: GO 65502
// repeat wait ( 0 0$1 ) ;
65149: LD_INT 35
65151: PPUSH
65152: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65156: LD_VAR 0 2
65160: PPUSH
65161: LD_VAR 0 3
65165: PPUSH
65166: CALL_OW 284
65170: IFFALSE 65149
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65172: LD_VAR 0 2
65176: PPUSH
65177: LD_VAR 0 3
65181: PPUSH
65182: CALL_OW 283
65186: PUSH
65187: LD_INT 4
65189: EQUAL
65190: IFFALSE 65194
// exit ;
65192: GO 65502
// for i = 1 to mc_bases do
65194: LD_ADDR_VAR 0 7
65198: PUSH
65199: DOUBLE
65200: LD_INT 1
65202: DEC
65203: ST_TO_ADDR
65204: LD_EXP 100
65208: PUSH
65209: FOR_TO
65210: IFFALSE 65500
// begin if mc_crates_area [ i ] then
65212: LD_EXP 118
65216: PUSH
65217: LD_VAR 0 7
65221: ARRAY
65222: IFFALSE 65333
// for j in mc_crates_area [ i ] do
65224: LD_ADDR_VAR 0 8
65228: PUSH
65229: LD_EXP 118
65233: PUSH
65234: LD_VAR 0 7
65238: ARRAY
65239: PUSH
65240: FOR_IN
65241: IFFALSE 65331
// if InArea ( x , y , j ) then
65243: LD_VAR 0 2
65247: PPUSH
65248: LD_VAR 0 3
65252: PPUSH
65253: LD_VAR 0 8
65257: PPUSH
65258: CALL_OW 309
65262: IFFALSE 65329
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65264: LD_ADDR_EXP 116
65268: PUSH
65269: LD_EXP 116
65273: PPUSH
65274: LD_VAR 0 7
65278: PUSH
65279: LD_EXP 116
65283: PUSH
65284: LD_VAR 0 7
65288: ARRAY
65289: PUSH
65290: LD_INT 1
65292: PLUS
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PPUSH
65298: LD_VAR 0 4
65302: PUSH
65303: LD_VAR 0 2
65307: PUSH
65308: LD_VAR 0 3
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: LIST
65317: PPUSH
65318: CALL 73757 0 3
65322: ST_TO_ADDR
// exit ;
65323: POP
65324: POP
65325: POP
65326: POP
65327: GO 65502
// end ;
65329: GO 65240
65331: POP
65332: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65333: LD_ADDR_VAR 0 9
65337: PUSH
65338: LD_EXP 100
65342: PUSH
65343: LD_VAR 0 7
65347: ARRAY
65348: PPUSH
65349: LD_INT 2
65351: PUSH
65352: LD_INT 30
65354: PUSH
65355: LD_INT 0
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PUSH
65362: LD_INT 30
65364: PUSH
65365: LD_INT 1
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: LIST
65376: PPUSH
65377: CALL_OW 72
65381: ST_TO_ADDR
// if not depot then
65382: LD_VAR 0 9
65386: NOT
65387: IFFALSE 65391
// continue ;
65389: GO 65209
// for j in depot do
65391: LD_ADDR_VAR 0 8
65395: PUSH
65396: LD_VAR 0 9
65400: PUSH
65401: FOR_IN
65402: IFFALSE 65496
// if GetDistUnitXY ( j , x , y ) < 30 then
65404: LD_VAR 0 8
65408: PPUSH
65409: LD_VAR 0 2
65413: PPUSH
65414: LD_VAR 0 3
65418: PPUSH
65419: CALL_OW 297
65423: PUSH
65424: LD_INT 30
65426: LESS
65427: IFFALSE 65494
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65429: LD_ADDR_EXP 116
65433: PUSH
65434: LD_EXP 116
65438: PPUSH
65439: LD_VAR 0 7
65443: PUSH
65444: LD_EXP 116
65448: PUSH
65449: LD_VAR 0 7
65453: ARRAY
65454: PUSH
65455: LD_INT 1
65457: PLUS
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PPUSH
65463: LD_VAR 0 4
65467: PUSH
65468: LD_VAR 0 2
65472: PUSH
65473: LD_VAR 0 3
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: LIST
65482: PPUSH
65483: CALL 73757 0 3
65487: ST_TO_ADDR
// exit ;
65488: POP
65489: POP
65490: POP
65491: POP
65492: GO 65502
// end ;
65494: GO 65401
65496: POP
65497: POP
// end ;
65498: GO 65209
65500: POP
65501: POP
// end ;
65502: LD_VAR 0 6
65506: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
65507: LD_INT 0
65509: PPUSH
65510: PPUSH
65511: PPUSH
65512: PPUSH
// if not mc_bases or not skirmish then
65513: LD_EXP 100
65517: NOT
65518: PUSH
65519: LD_EXP 98
65523: NOT
65524: OR
65525: IFFALSE 65529
// exit ;
65527: GO 65806
// side := GetSide ( lab ) ;
65529: LD_ADDR_VAR 0 4
65533: PUSH
65534: LD_VAR 0 2
65538: PPUSH
65539: CALL_OW 255
65543: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
65544: LD_VAR 0 4
65548: PUSH
65549: LD_EXP 126
65553: IN
65554: NOT
65555: PUSH
65556: LD_EXP 127
65560: NOT
65561: OR
65562: PUSH
65563: LD_EXP 100
65567: NOT
65568: OR
65569: IFFALSE 65573
// exit ;
65571: GO 65806
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
65573: LD_ADDR_EXP 127
65577: PUSH
65578: LD_EXP 127
65582: PPUSH
65583: LD_VAR 0 4
65587: PPUSH
65588: LD_EXP 127
65592: PUSH
65593: LD_VAR 0 4
65597: ARRAY
65598: PUSH
65599: LD_VAR 0 1
65603: DIFF
65604: PPUSH
65605: CALL_OW 1
65609: ST_TO_ADDR
// for i = 1 to mc_bases do
65610: LD_ADDR_VAR 0 5
65614: PUSH
65615: DOUBLE
65616: LD_INT 1
65618: DEC
65619: ST_TO_ADDR
65620: LD_EXP 100
65624: PUSH
65625: FOR_TO
65626: IFFALSE 65804
// begin if lab in mc_bases [ i ] then
65628: LD_VAR 0 2
65632: PUSH
65633: LD_EXP 100
65637: PUSH
65638: LD_VAR 0 5
65642: ARRAY
65643: IN
65644: IFFALSE 65802
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
65646: LD_VAR 0 1
65650: PUSH
65651: LD_INT 11
65653: PUSH
65654: LD_INT 4
65656: PUSH
65657: LD_INT 3
65659: PUSH
65660: LD_INT 2
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: IN
65669: PUSH
65670: LD_EXP 130
65674: PUSH
65675: LD_VAR 0 5
65679: ARRAY
65680: AND
65681: IFFALSE 65802
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
65683: LD_ADDR_VAR 0 6
65687: PUSH
65688: LD_EXP 130
65692: PUSH
65693: LD_VAR 0 5
65697: ARRAY
65698: PUSH
65699: LD_INT 1
65701: ARRAY
65702: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65703: LD_ADDR_EXP 130
65707: PUSH
65708: LD_EXP 130
65712: PPUSH
65713: LD_VAR 0 5
65717: PPUSH
65718: EMPTY
65719: PPUSH
65720: CALL_OW 1
65724: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
65725: LD_VAR 0 6
65729: PPUSH
65730: LD_INT 0
65732: PPUSH
65733: CALL_OW 109
// ComExitBuilding ( tmp ) ;
65737: LD_VAR 0 6
65741: PPUSH
65742: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
65746: LD_ADDR_EXP 129
65750: PUSH
65751: LD_EXP 129
65755: PPUSH
65756: LD_VAR 0 5
65760: PPUSH
65761: LD_EXP 129
65765: PUSH
65766: LD_VAR 0 5
65770: ARRAY
65771: PPUSH
65772: LD_INT 1
65774: PPUSH
65775: LD_VAR 0 6
65779: PPUSH
65780: CALL_OW 2
65784: PPUSH
65785: CALL_OW 1
65789: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
65790: LD_VAR 0 5
65794: PPUSH
65795: LD_INT 112
65797: PPUSH
65798: CALL 42270 0 2
// end ; end ; end ;
65802: GO 65625
65804: POP
65805: POP
// end ;
65806: LD_VAR 0 3
65810: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
65811: LD_INT 0
65813: PPUSH
65814: PPUSH
65815: PPUSH
65816: PPUSH
65817: PPUSH
65818: PPUSH
65819: PPUSH
65820: PPUSH
// if not mc_bases or not skirmish then
65821: LD_EXP 100
65825: NOT
65826: PUSH
65827: LD_EXP 98
65831: NOT
65832: OR
65833: IFFALSE 65837
// exit ;
65835: GO 67206
// for i = 1 to mc_bases do
65837: LD_ADDR_VAR 0 3
65841: PUSH
65842: DOUBLE
65843: LD_INT 1
65845: DEC
65846: ST_TO_ADDR
65847: LD_EXP 100
65851: PUSH
65852: FOR_TO
65853: IFFALSE 67204
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
65855: LD_VAR 0 1
65859: PUSH
65860: LD_EXP 100
65864: PUSH
65865: LD_VAR 0 3
65869: ARRAY
65870: IN
65871: PUSH
65872: LD_VAR 0 1
65876: PUSH
65877: LD_EXP 107
65881: PUSH
65882: LD_VAR 0 3
65886: ARRAY
65887: IN
65888: OR
65889: PUSH
65890: LD_VAR 0 1
65894: PUSH
65895: LD_EXP 122
65899: PUSH
65900: LD_VAR 0 3
65904: ARRAY
65905: IN
65906: OR
65907: PUSH
65908: LD_VAR 0 1
65912: PUSH
65913: LD_EXP 119
65917: PUSH
65918: LD_VAR 0 3
65922: ARRAY
65923: IN
65924: OR
65925: PUSH
65926: LD_VAR 0 1
65930: PUSH
65931: LD_EXP 129
65935: PUSH
65936: LD_VAR 0 3
65940: ARRAY
65941: IN
65942: OR
65943: PUSH
65944: LD_VAR 0 1
65948: PUSH
65949: LD_EXP 130
65953: PUSH
65954: LD_VAR 0 3
65958: ARRAY
65959: IN
65960: OR
65961: IFFALSE 67202
// begin if un in mc_ape [ i ] then
65963: LD_VAR 0 1
65967: PUSH
65968: LD_EXP 129
65972: PUSH
65973: LD_VAR 0 3
65977: ARRAY
65978: IN
65979: IFFALSE 66018
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
65981: LD_ADDR_EXP 129
65985: PUSH
65986: LD_EXP 129
65990: PPUSH
65991: LD_VAR 0 3
65995: PPUSH
65996: LD_EXP 129
66000: PUSH
66001: LD_VAR 0 3
66005: ARRAY
66006: PUSH
66007: LD_VAR 0 1
66011: DIFF
66012: PPUSH
66013: CALL_OW 1
66017: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66018: LD_VAR 0 1
66022: PUSH
66023: LD_EXP 130
66027: PUSH
66028: LD_VAR 0 3
66032: ARRAY
66033: IN
66034: IFFALSE 66058
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66036: LD_ADDR_EXP 130
66040: PUSH
66041: LD_EXP 130
66045: PPUSH
66046: LD_VAR 0 3
66050: PPUSH
66051: EMPTY
66052: PPUSH
66053: CALL_OW 1
66057: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66058: LD_VAR 0 1
66062: PPUSH
66063: CALL_OW 247
66067: PUSH
66068: LD_INT 2
66070: EQUAL
66071: PUSH
66072: LD_VAR 0 1
66076: PPUSH
66077: CALL_OW 110
66081: PUSH
66082: LD_INT 20
66084: EQUAL
66085: PUSH
66086: LD_VAR 0 1
66090: PUSH
66091: LD_EXP 122
66095: PUSH
66096: LD_VAR 0 3
66100: ARRAY
66101: IN
66102: OR
66103: PUSH
66104: LD_VAR 0 1
66108: PPUSH
66109: CALL_OW 264
66113: PUSH
66114: LD_INT 12
66116: PUSH
66117: LD_INT 51
66119: PUSH
66120: LD_INT 89
66122: PUSH
66123: LD_INT 32
66125: PUSH
66126: LD_INT 13
66128: PUSH
66129: LD_INT 52
66131: PUSH
66132: LD_INT 31
66134: PUSH
66135: EMPTY
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: IN
66144: OR
66145: AND
66146: IFFALSE 66454
// begin if un in mc_defender [ i ] then
66148: LD_VAR 0 1
66152: PUSH
66153: LD_EXP 122
66157: PUSH
66158: LD_VAR 0 3
66162: ARRAY
66163: IN
66164: IFFALSE 66203
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66166: LD_ADDR_EXP 122
66170: PUSH
66171: LD_EXP 122
66175: PPUSH
66176: LD_VAR 0 3
66180: PPUSH
66181: LD_EXP 122
66185: PUSH
66186: LD_VAR 0 3
66190: ARRAY
66191: PUSH
66192: LD_VAR 0 1
66196: DIFF
66197: PPUSH
66198: CALL_OW 1
66202: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66203: LD_ADDR_VAR 0 8
66207: PUSH
66208: LD_VAR 0 3
66212: PPUSH
66213: LD_INT 3
66215: PPUSH
66216: CALL 62824 0 2
66220: ST_TO_ADDR
// if fac then
66221: LD_VAR 0 8
66225: IFFALSE 66454
// begin for j in fac do
66227: LD_ADDR_VAR 0 4
66231: PUSH
66232: LD_VAR 0 8
66236: PUSH
66237: FOR_IN
66238: IFFALSE 66452
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66240: LD_ADDR_VAR 0 9
66244: PUSH
66245: LD_VAR 0 8
66249: PPUSH
66250: LD_VAR 0 1
66254: PPUSH
66255: CALL_OW 265
66259: PPUSH
66260: LD_VAR 0 1
66264: PPUSH
66265: CALL_OW 262
66269: PPUSH
66270: LD_VAR 0 1
66274: PPUSH
66275: CALL_OW 263
66279: PPUSH
66280: LD_VAR 0 1
66284: PPUSH
66285: CALL_OW 264
66289: PPUSH
66290: CALL 71255 0 5
66294: ST_TO_ADDR
// if components then
66295: LD_VAR 0 9
66299: IFFALSE 66450
// begin if GetWeapon ( un ) = ar_control_tower then
66301: LD_VAR 0 1
66305: PPUSH
66306: CALL_OW 264
66310: PUSH
66311: LD_INT 31
66313: EQUAL
66314: IFFALSE 66431
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
66316: LD_VAR 0 1
66320: PPUSH
66321: CALL_OW 311
66325: PPUSH
66326: LD_INT 0
66328: PPUSH
66329: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
66333: LD_ADDR_EXP 140
66337: PUSH
66338: LD_EXP 140
66342: PPUSH
66343: LD_VAR 0 3
66347: PPUSH
66348: LD_EXP 140
66352: PUSH
66353: LD_VAR 0 3
66357: ARRAY
66358: PUSH
66359: LD_VAR 0 1
66363: PPUSH
66364: CALL_OW 311
66368: DIFF
66369: PPUSH
66370: CALL_OW 1
66374: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
66375: LD_ADDR_VAR 0 7
66379: PUSH
66380: LD_EXP 121
66384: PUSH
66385: LD_VAR 0 3
66389: ARRAY
66390: PPUSH
66391: LD_INT 1
66393: PPUSH
66394: LD_VAR 0 9
66398: PPUSH
66399: CALL_OW 2
66403: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66404: LD_ADDR_EXP 121
66408: PUSH
66409: LD_EXP 121
66413: PPUSH
66414: LD_VAR 0 3
66418: PPUSH
66419: LD_VAR 0 7
66423: PPUSH
66424: CALL_OW 1
66428: ST_TO_ADDR
// end else
66429: GO 66448
// MC_InsertProduceList ( i , [ components ] ) ;
66431: LD_VAR 0 3
66435: PPUSH
66436: LD_VAR 0 9
66440: PUSH
66441: EMPTY
66442: LIST
66443: PPUSH
66444: CALL 62369 0 2
// break ;
66448: GO 66452
// end ; end ;
66450: GO 66237
66452: POP
66453: POP
// end ; end ; if GetType ( un ) = unit_building then
66454: LD_VAR 0 1
66458: PPUSH
66459: CALL_OW 247
66463: PUSH
66464: LD_INT 3
66466: EQUAL
66467: IFFALSE 66870
// begin btype := GetBType ( un ) ;
66469: LD_ADDR_VAR 0 5
66473: PUSH
66474: LD_VAR 0 1
66478: PPUSH
66479: CALL_OW 266
66483: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
66484: LD_VAR 0 5
66488: PUSH
66489: LD_INT 29
66491: PUSH
66492: LD_INT 30
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: IN
66499: IFFALSE 66572
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
66501: LD_VAR 0 1
66505: PPUSH
66506: CALL_OW 250
66510: PPUSH
66511: LD_VAR 0 1
66515: PPUSH
66516: CALL_OW 251
66520: PPUSH
66521: LD_VAR 0 1
66525: PPUSH
66526: CALL_OW 255
66530: PPUSH
66531: CALL_OW 440
66535: NOT
66536: IFFALSE 66572
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
66538: LD_VAR 0 1
66542: PPUSH
66543: CALL_OW 250
66547: PPUSH
66548: LD_VAR 0 1
66552: PPUSH
66553: CALL_OW 251
66557: PPUSH
66558: LD_VAR 0 1
66562: PPUSH
66563: CALL_OW 255
66567: PPUSH
66568: CALL_OW 441
// end ; if btype = b_warehouse then
66572: LD_VAR 0 5
66576: PUSH
66577: LD_INT 1
66579: EQUAL
66580: IFFALSE 66598
// begin btype := b_depot ;
66582: LD_ADDR_VAR 0 5
66586: PUSH
66587: LD_INT 0
66589: ST_TO_ADDR
// pos := 1 ;
66590: LD_ADDR_VAR 0 6
66594: PUSH
66595: LD_INT 1
66597: ST_TO_ADDR
// end ; if btype = b_factory then
66598: LD_VAR 0 5
66602: PUSH
66603: LD_INT 3
66605: EQUAL
66606: IFFALSE 66624
// begin btype := b_workshop ;
66608: LD_ADDR_VAR 0 5
66612: PUSH
66613: LD_INT 2
66615: ST_TO_ADDR
// pos := 1 ;
66616: LD_ADDR_VAR 0 6
66620: PUSH
66621: LD_INT 1
66623: ST_TO_ADDR
// end ; if btype = b_barracks then
66624: LD_VAR 0 5
66628: PUSH
66629: LD_INT 5
66631: EQUAL
66632: IFFALSE 66642
// btype := b_armoury ;
66634: LD_ADDR_VAR 0 5
66638: PUSH
66639: LD_INT 4
66641: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
66642: LD_VAR 0 5
66646: PUSH
66647: LD_INT 7
66649: PUSH
66650: LD_INT 8
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: IN
66657: IFFALSE 66667
// btype := b_lab ;
66659: LD_ADDR_VAR 0 5
66663: PUSH
66664: LD_INT 6
66666: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
66667: LD_ADDR_EXP 105
66671: PUSH
66672: LD_EXP 105
66676: PPUSH
66677: LD_VAR 0 3
66681: PUSH
66682: LD_EXP 105
66686: PUSH
66687: LD_VAR 0 3
66691: ARRAY
66692: PUSH
66693: LD_INT 1
66695: PLUS
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PPUSH
66701: LD_VAR 0 5
66705: PUSH
66706: LD_VAR 0 1
66710: PPUSH
66711: CALL_OW 250
66715: PUSH
66716: LD_VAR 0 1
66720: PPUSH
66721: CALL_OW 251
66725: PUSH
66726: LD_VAR 0 1
66730: PPUSH
66731: CALL_OW 254
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: PPUSH
66742: CALL 73757 0 3
66746: ST_TO_ADDR
// if pos = 1 then
66747: LD_VAR 0 6
66751: PUSH
66752: LD_INT 1
66754: EQUAL
66755: IFFALSE 66870
// begin tmp := mc_build_list [ i ] ;
66757: LD_ADDR_VAR 0 7
66761: PUSH
66762: LD_EXP 105
66766: PUSH
66767: LD_VAR 0 3
66771: ARRAY
66772: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66773: LD_VAR 0 7
66777: PPUSH
66778: LD_INT 2
66780: PUSH
66781: LD_INT 30
66783: PUSH
66784: LD_INT 0
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: LD_INT 30
66793: PUSH
66794: LD_INT 1
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: LIST
66805: PPUSH
66806: CALL_OW 72
66810: IFFALSE 66820
// pos := 2 ;
66812: LD_ADDR_VAR 0 6
66816: PUSH
66817: LD_INT 2
66819: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
66820: LD_ADDR_VAR 0 7
66824: PUSH
66825: LD_VAR 0 7
66829: PPUSH
66830: LD_VAR 0 6
66834: PPUSH
66835: LD_VAR 0 7
66839: PPUSH
66840: CALL 74083 0 3
66844: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
66845: LD_ADDR_EXP 105
66849: PUSH
66850: LD_EXP 105
66854: PPUSH
66855: LD_VAR 0 3
66859: PPUSH
66860: LD_VAR 0 7
66864: PPUSH
66865: CALL_OW 1
66869: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
66870: LD_VAR 0 1
66874: PUSH
66875: LD_EXP 100
66879: PUSH
66880: LD_VAR 0 3
66884: ARRAY
66885: IN
66886: IFFALSE 66925
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
66888: LD_ADDR_EXP 100
66892: PUSH
66893: LD_EXP 100
66897: PPUSH
66898: LD_VAR 0 3
66902: PPUSH
66903: LD_EXP 100
66907: PUSH
66908: LD_VAR 0 3
66912: ARRAY
66913: PUSH
66914: LD_VAR 0 1
66918: DIFF
66919: PPUSH
66920: CALL_OW 1
66924: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
66925: LD_VAR 0 1
66929: PUSH
66930: LD_EXP 107
66934: PUSH
66935: LD_VAR 0 3
66939: ARRAY
66940: IN
66941: IFFALSE 66980
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
66943: LD_ADDR_EXP 107
66947: PUSH
66948: LD_EXP 107
66952: PPUSH
66953: LD_VAR 0 3
66957: PPUSH
66958: LD_EXP 107
66962: PUSH
66963: LD_VAR 0 3
66967: ARRAY
66968: PUSH
66969: LD_VAR 0 1
66973: DIFF
66974: PPUSH
66975: CALL_OW 1
66979: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
66980: LD_VAR 0 1
66984: PUSH
66985: LD_EXP 119
66989: PUSH
66990: LD_VAR 0 3
66994: ARRAY
66995: IN
66996: IFFALSE 67035
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
66998: LD_ADDR_EXP 119
67002: PUSH
67003: LD_EXP 119
67007: PPUSH
67008: LD_VAR 0 3
67012: PPUSH
67013: LD_EXP 119
67017: PUSH
67018: LD_VAR 0 3
67022: ARRAY
67023: PUSH
67024: LD_VAR 0 1
67028: DIFF
67029: PPUSH
67030: CALL_OW 1
67034: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67035: LD_VAR 0 1
67039: PUSH
67040: LD_EXP 122
67044: PUSH
67045: LD_VAR 0 3
67049: ARRAY
67050: IN
67051: IFFALSE 67090
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67053: LD_ADDR_EXP 122
67057: PUSH
67058: LD_EXP 122
67062: PPUSH
67063: LD_VAR 0 3
67067: PPUSH
67068: LD_EXP 122
67072: PUSH
67073: LD_VAR 0 3
67077: ARRAY
67078: PUSH
67079: LD_VAR 0 1
67083: DIFF
67084: PPUSH
67085: CALL_OW 1
67089: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67090: LD_VAR 0 1
67094: PUSH
67095: LD_EXP 109
67099: PUSH
67100: LD_VAR 0 3
67104: ARRAY
67105: IN
67106: IFFALSE 67145
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67108: LD_ADDR_EXP 109
67112: PUSH
67113: LD_EXP 109
67117: PPUSH
67118: LD_VAR 0 3
67122: PPUSH
67123: LD_EXP 109
67127: PUSH
67128: LD_VAR 0 3
67132: ARRAY
67133: PUSH
67134: LD_VAR 0 1
67138: DIFF
67139: PPUSH
67140: CALL_OW 1
67144: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67145: LD_VAR 0 1
67149: PUSH
67150: LD_EXP 108
67154: PUSH
67155: LD_VAR 0 3
67159: ARRAY
67160: IN
67161: IFFALSE 67200
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67163: LD_ADDR_EXP 108
67167: PUSH
67168: LD_EXP 108
67172: PPUSH
67173: LD_VAR 0 3
67177: PPUSH
67178: LD_EXP 108
67182: PUSH
67183: LD_VAR 0 3
67187: ARRAY
67188: PUSH
67189: LD_VAR 0 1
67193: DIFF
67194: PPUSH
67195: CALL_OW 1
67199: ST_TO_ADDR
// end ; break ;
67200: GO 67204
// end ;
67202: GO 65852
67204: POP
67205: POP
// end ;
67206: LD_VAR 0 2
67210: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
67211: LD_INT 0
67213: PPUSH
67214: PPUSH
67215: PPUSH
// if not mc_bases or not skirmish then
67216: LD_EXP 100
67220: NOT
67221: PUSH
67222: LD_EXP 98
67226: NOT
67227: OR
67228: IFFALSE 67232
// exit ;
67230: GO 67447
// for i = 1 to mc_bases do
67232: LD_ADDR_VAR 0 3
67236: PUSH
67237: DOUBLE
67238: LD_INT 1
67240: DEC
67241: ST_TO_ADDR
67242: LD_EXP 100
67246: PUSH
67247: FOR_TO
67248: IFFALSE 67445
// begin if building in mc_construct_list [ i ] then
67250: LD_VAR 0 1
67254: PUSH
67255: LD_EXP 107
67259: PUSH
67260: LD_VAR 0 3
67264: ARRAY
67265: IN
67266: IFFALSE 67443
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67268: LD_ADDR_EXP 107
67272: PUSH
67273: LD_EXP 107
67277: PPUSH
67278: LD_VAR 0 3
67282: PPUSH
67283: LD_EXP 107
67287: PUSH
67288: LD_VAR 0 3
67292: ARRAY
67293: PUSH
67294: LD_VAR 0 1
67298: DIFF
67299: PPUSH
67300: CALL_OW 1
67304: ST_TO_ADDR
// if building in mc_lab [ i ] then
67305: LD_VAR 0 1
67309: PUSH
67310: LD_EXP 133
67314: PUSH
67315: LD_VAR 0 3
67319: ARRAY
67320: IN
67321: IFFALSE 67376
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
67323: LD_ADDR_EXP 134
67327: PUSH
67328: LD_EXP 134
67332: PPUSH
67333: LD_VAR 0 3
67337: PPUSH
67338: LD_EXP 134
67342: PUSH
67343: LD_VAR 0 3
67347: ARRAY
67348: PPUSH
67349: LD_INT 1
67351: PPUSH
67352: LD_EXP 134
67356: PUSH
67357: LD_VAR 0 3
67361: ARRAY
67362: PPUSH
67363: LD_INT 0
67365: PPUSH
67366: CALL 73175 0 4
67370: PPUSH
67371: CALL_OW 1
67375: ST_TO_ADDR
// if not building in mc_bases [ i ] then
67376: LD_VAR 0 1
67380: PUSH
67381: LD_EXP 100
67385: PUSH
67386: LD_VAR 0 3
67390: ARRAY
67391: IN
67392: NOT
67393: IFFALSE 67439
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67395: LD_ADDR_EXP 100
67399: PUSH
67400: LD_EXP 100
67404: PPUSH
67405: LD_VAR 0 3
67409: PUSH
67410: LD_EXP 100
67414: PUSH
67415: LD_VAR 0 3
67419: ARRAY
67420: PUSH
67421: LD_INT 1
67423: PLUS
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PPUSH
67429: LD_VAR 0 1
67433: PPUSH
67434: CALL 73757 0 3
67438: ST_TO_ADDR
// exit ;
67439: POP
67440: POP
67441: GO 67447
// end ; end ;
67443: GO 67247
67445: POP
67446: POP
// end ;
67447: LD_VAR 0 2
67451: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
67452: LD_INT 0
67454: PPUSH
67455: PPUSH
67456: PPUSH
67457: PPUSH
67458: PPUSH
67459: PPUSH
67460: PPUSH
// if not mc_bases or not skirmish then
67461: LD_EXP 100
67465: NOT
67466: PUSH
67467: LD_EXP 98
67471: NOT
67472: OR
67473: IFFALSE 67477
// exit ;
67475: GO 68138
// for i = 1 to mc_bases do
67477: LD_ADDR_VAR 0 3
67481: PUSH
67482: DOUBLE
67483: LD_INT 1
67485: DEC
67486: ST_TO_ADDR
67487: LD_EXP 100
67491: PUSH
67492: FOR_TO
67493: IFFALSE 68136
// begin if building in mc_construct_list [ i ] then
67495: LD_VAR 0 1
67499: PUSH
67500: LD_EXP 107
67504: PUSH
67505: LD_VAR 0 3
67509: ARRAY
67510: IN
67511: IFFALSE 68134
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67513: LD_ADDR_EXP 107
67517: PUSH
67518: LD_EXP 107
67522: PPUSH
67523: LD_VAR 0 3
67527: PPUSH
67528: LD_EXP 107
67532: PUSH
67533: LD_VAR 0 3
67537: ARRAY
67538: PUSH
67539: LD_VAR 0 1
67543: DIFF
67544: PPUSH
67545: CALL_OW 1
67549: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67550: LD_ADDR_EXP 100
67554: PUSH
67555: LD_EXP 100
67559: PPUSH
67560: LD_VAR 0 3
67564: PUSH
67565: LD_EXP 100
67569: PUSH
67570: LD_VAR 0 3
67574: ARRAY
67575: PUSH
67576: LD_INT 1
67578: PLUS
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PPUSH
67584: LD_VAR 0 1
67588: PPUSH
67589: CALL 73757 0 3
67593: ST_TO_ADDR
// btype := GetBType ( building ) ;
67594: LD_ADDR_VAR 0 5
67598: PUSH
67599: LD_VAR 0 1
67603: PPUSH
67604: CALL_OW 266
67608: ST_TO_ADDR
// side := GetSide ( building ) ;
67609: LD_ADDR_VAR 0 8
67613: PUSH
67614: LD_VAR 0 1
67618: PPUSH
67619: CALL_OW 255
67623: ST_TO_ADDR
// if btype = b_lab then
67624: LD_VAR 0 5
67628: PUSH
67629: LD_INT 6
67631: EQUAL
67632: IFFALSE 67682
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
67634: LD_ADDR_EXP 133
67638: PUSH
67639: LD_EXP 133
67643: PPUSH
67644: LD_VAR 0 3
67648: PUSH
67649: LD_EXP 133
67653: PUSH
67654: LD_VAR 0 3
67658: ARRAY
67659: PUSH
67660: LD_INT 1
67662: PLUS
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PPUSH
67668: LD_VAR 0 1
67672: PPUSH
67673: CALL 73757 0 3
67677: ST_TO_ADDR
// exit ;
67678: POP
67679: POP
67680: GO 68138
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
67682: LD_VAR 0 5
67686: PUSH
67687: LD_INT 0
67689: PUSH
67690: LD_INT 2
67692: PUSH
67693: LD_INT 4
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: LIST
67700: IN
67701: IFFALSE 67825
// begin if btype = b_armoury then
67703: LD_VAR 0 5
67707: PUSH
67708: LD_INT 4
67710: EQUAL
67711: IFFALSE 67721
// btype := b_barracks ;
67713: LD_ADDR_VAR 0 5
67717: PUSH
67718: LD_INT 5
67720: ST_TO_ADDR
// if btype = b_depot then
67721: LD_VAR 0 5
67725: PUSH
67726: LD_INT 0
67728: EQUAL
67729: IFFALSE 67739
// btype := b_warehouse ;
67731: LD_ADDR_VAR 0 5
67735: PUSH
67736: LD_INT 1
67738: ST_TO_ADDR
// if btype = b_workshop then
67739: LD_VAR 0 5
67743: PUSH
67744: LD_INT 2
67746: EQUAL
67747: IFFALSE 67757
// btype := b_factory ;
67749: LD_ADDR_VAR 0 5
67753: PUSH
67754: LD_INT 3
67756: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
67757: LD_VAR 0 5
67761: PPUSH
67762: LD_VAR 0 8
67766: PPUSH
67767: CALL_OW 323
67771: PUSH
67772: LD_INT 1
67774: EQUAL
67775: IFFALSE 67821
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
67777: LD_ADDR_EXP 132
67781: PUSH
67782: LD_EXP 132
67786: PPUSH
67787: LD_VAR 0 3
67791: PUSH
67792: LD_EXP 132
67796: PUSH
67797: LD_VAR 0 3
67801: ARRAY
67802: PUSH
67803: LD_INT 1
67805: PLUS
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PPUSH
67811: LD_VAR 0 1
67815: PPUSH
67816: CALL 73757 0 3
67820: ST_TO_ADDR
// exit ;
67821: POP
67822: POP
67823: GO 68138
// end ; if btype in [ b_bunker , b_turret ] then
67825: LD_VAR 0 5
67829: PUSH
67830: LD_INT 32
67832: PUSH
67833: LD_INT 33
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: IN
67840: IFFALSE 68130
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
67842: LD_ADDR_EXP 108
67846: PUSH
67847: LD_EXP 108
67851: PPUSH
67852: LD_VAR 0 3
67856: PUSH
67857: LD_EXP 108
67861: PUSH
67862: LD_VAR 0 3
67866: ARRAY
67867: PUSH
67868: LD_INT 1
67870: PLUS
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PPUSH
67876: LD_VAR 0 1
67880: PPUSH
67881: CALL 73757 0 3
67885: ST_TO_ADDR
// if btype = b_bunker then
67886: LD_VAR 0 5
67890: PUSH
67891: LD_INT 32
67893: EQUAL
67894: IFFALSE 68130
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67896: LD_ADDR_EXP 109
67900: PUSH
67901: LD_EXP 109
67905: PPUSH
67906: LD_VAR 0 3
67910: PUSH
67911: LD_EXP 109
67915: PUSH
67916: LD_VAR 0 3
67920: ARRAY
67921: PUSH
67922: LD_INT 1
67924: PLUS
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PPUSH
67930: LD_VAR 0 1
67934: PPUSH
67935: CALL 73757 0 3
67939: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
67940: LD_ADDR_VAR 0 6
67944: PUSH
67945: LD_EXP 100
67949: PUSH
67950: LD_VAR 0 3
67954: ARRAY
67955: PPUSH
67956: LD_INT 25
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 3
67968: PUSH
67969: LD_INT 54
67971: PUSH
67972: EMPTY
67973: LIST
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PPUSH
67983: CALL_OW 72
67987: ST_TO_ADDR
// if tmp then
67988: LD_VAR 0 6
67992: IFFALSE 67998
// exit ;
67994: POP
67995: POP
67996: GO 68138
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67998: LD_ADDR_VAR 0 6
68002: PUSH
68003: LD_EXP 100
68007: PUSH
68008: LD_VAR 0 3
68012: ARRAY
68013: PPUSH
68014: LD_INT 2
68016: PUSH
68017: LD_INT 30
68019: PUSH
68020: LD_INT 4
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 30
68029: PUSH
68030: LD_INT 5
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: LIST
68041: PPUSH
68042: CALL_OW 72
68046: ST_TO_ADDR
// if not tmp then
68047: LD_VAR 0 6
68051: NOT
68052: IFFALSE 68058
// exit ;
68054: POP
68055: POP
68056: GO 68138
// for j in tmp do
68058: LD_ADDR_VAR 0 4
68062: PUSH
68063: LD_VAR 0 6
68067: PUSH
68068: FOR_IN
68069: IFFALSE 68128
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68071: LD_ADDR_VAR 0 7
68075: PUSH
68076: LD_VAR 0 4
68080: PPUSH
68081: CALL_OW 313
68085: PPUSH
68086: LD_INT 25
68088: PUSH
68089: LD_INT 1
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PPUSH
68096: CALL_OW 72
68100: ST_TO_ADDR
// if units then
68101: LD_VAR 0 7
68105: IFFALSE 68126
// begin ComExitBuilding ( units [ 1 ] ) ;
68107: LD_VAR 0 7
68111: PUSH
68112: LD_INT 1
68114: ARRAY
68115: PPUSH
68116: CALL_OW 122
// exit ;
68120: POP
68121: POP
68122: POP
68123: POP
68124: GO 68138
// end ; end ;
68126: GO 68068
68128: POP
68129: POP
// end ; end ; exit ;
68130: POP
68131: POP
68132: GO 68138
// end ; end ;
68134: GO 67492
68136: POP
68137: POP
// end ;
68138: LD_VAR 0 2
68142: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68143: LD_INT 0
68145: PPUSH
68146: PPUSH
68147: PPUSH
68148: PPUSH
68149: PPUSH
68150: PPUSH
68151: PPUSH
// if not mc_bases or not skirmish then
68152: LD_EXP 100
68156: NOT
68157: PUSH
68158: LD_EXP 98
68162: NOT
68163: OR
68164: IFFALSE 68168
// exit ;
68166: GO 68433
// btype := GetBType ( building ) ;
68168: LD_ADDR_VAR 0 6
68172: PUSH
68173: LD_VAR 0 1
68177: PPUSH
68178: CALL_OW 266
68182: ST_TO_ADDR
// x := GetX ( building ) ;
68183: LD_ADDR_VAR 0 7
68187: PUSH
68188: LD_VAR 0 1
68192: PPUSH
68193: CALL_OW 250
68197: ST_TO_ADDR
// y := GetY ( building ) ;
68198: LD_ADDR_VAR 0 8
68202: PUSH
68203: LD_VAR 0 1
68207: PPUSH
68208: CALL_OW 251
68212: ST_TO_ADDR
// d := GetDir ( building ) ;
68213: LD_ADDR_VAR 0 9
68217: PUSH
68218: LD_VAR 0 1
68222: PPUSH
68223: CALL_OW 254
68227: ST_TO_ADDR
// for i = 1 to mc_bases do
68228: LD_ADDR_VAR 0 4
68232: PUSH
68233: DOUBLE
68234: LD_INT 1
68236: DEC
68237: ST_TO_ADDR
68238: LD_EXP 100
68242: PUSH
68243: FOR_TO
68244: IFFALSE 68431
// begin if not mc_build_list [ i ] then
68246: LD_EXP 105
68250: PUSH
68251: LD_VAR 0 4
68255: ARRAY
68256: NOT
68257: IFFALSE 68261
// continue ;
68259: GO 68243
// for j := 1 to mc_build_list [ i ] do
68261: LD_ADDR_VAR 0 5
68265: PUSH
68266: DOUBLE
68267: LD_INT 1
68269: DEC
68270: ST_TO_ADDR
68271: LD_EXP 105
68275: PUSH
68276: LD_VAR 0 4
68280: ARRAY
68281: PUSH
68282: FOR_TO
68283: IFFALSE 68427
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
68285: LD_VAR 0 6
68289: PUSH
68290: LD_VAR 0 7
68294: PUSH
68295: LD_VAR 0 8
68299: PUSH
68300: LD_VAR 0 9
68304: PUSH
68305: EMPTY
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: PPUSH
68311: LD_EXP 105
68315: PUSH
68316: LD_VAR 0 4
68320: ARRAY
68321: PUSH
68322: LD_VAR 0 5
68326: ARRAY
68327: PPUSH
68328: CALL 79937 0 2
68332: IFFALSE 68425
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
68334: LD_ADDR_EXP 105
68338: PUSH
68339: LD_EXP 105
68343: PPUSH
68344: LD_VAR 0 4
68348: PPUSH
68349: LD_EXP 105
68353: PUSH
68354: LD_VAR 0 4
68358: ARRAY
68359: PPUSH
68360: LD_VAR 0 5
68364: PPUSH
68365: CALL_OW 3
68369: PPUSH
68370: CALL_OW 1
68374: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
68375: LD_ADDR_EXP 107
68379: PUSH
68380: LD_EXP 107
68384: PPUSH
68385: LD_VAR 0 4
68389: PUSH
68390: LD_EXP 107
68394: PUSH
68395: LD_VAR 0 4
68399: ARRAY
68400: PUSH
68401: LD_INT 1
68403: PLUS
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: PPUSH
68409: LD_VAR 0 1
68413: PPUSH
68414: CALL 73757 0 3
68418: ST_TO_ADDR
// exit ;
68419: POP
68420: POP
68421: POP
68422: POP
68423: GO 68433
// end ;
68425: GO 68282
68427: POP
68428: POP
// end ;
68429: GO 68243
68431: POP
68432: POP
// end ;
68433: LD_VAR 0 3
68437: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
68438: LD_INT 0
68440: PPUSH
68441: PPUSH
68442: PPUSH
// if not mc_bases or not skirmish then
68443: LD_EXP 100
68447: NOT
68448: PUSH
68449: LD_EXP 98
68453: NOT
68454: OR
68455: IFFALSE 68459
// exit ;
68457: GO 68649
// for i = 1 to mc_bases do
68459: LD_ADDR_VAR 0 4
68463: PUSH
68464: DOUBLE
68465: LD_INT 1
68467: DEC
68468: ST_TO_ADDR
68469: LD_EXP 100
68473: PUSH
68474: FOR_TO
68475: IFFALSE 68562
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
68477: LD_VAR 0 1
68481: PUSH
68482: LD_EXP 108
68486: PUSH
68487: LD_VAR 0 4
68491: ARRAY
68492: IN
68493: PUSH
68494: LD_VAR 0 1
68498: PUSH
68499: LD_EXP 109
68503: PUSH
68504: LD_VAR 0 4
68508: ARRAY
68509: IN
68510: NOT
68511: AND
68512: IFFALSE 68560
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68514: LD_ADDR_EXP 109
68518: PUSH
68519: LD_EXP 109
68523: PPUSH
68524: LD_VAR 0 4
68528: PUSH
68529: LD_EXP 109
68533: PUSH
68534: LD_VAR 0 4
68538: ARRAY
68539: PUSH
68540: LD_INT 1
68542: PLUS
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PPUSH
68548: LD_VAR 0 1
68552: PPUSH
68553: CALL 73757 0 3
68557: ST_TO_ADDR
// break ;
68558: GO 68562
// end ; end ;
68560: GO 68474
68562: POP
68563: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
68564: LD_VAR 0 1
68568: PPUSH
68569: CALL_OW 257
68573: PUSH
68574: LD_EXP 126
68578: IN
68579: PUSH
68580: LD_VAR 0 1
68584: PPUSH
68585: CALL_OW 266
68589: PUSH
68590: LD_INT 5
68592: EQUAL
68593: AND
68594: PUSH
68595: LD_VAR 0 2
68599: PPUSH
68600: CALL_OW 110
68604: PUSH
68605: LD_INT 18
68607: NONEQUAL
68608: AND
68609: IFFALSE 68649
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
68611: LD_VAR 0 2
68615: PPUSH
68616: CALL_OW 257
68620: PUSH
68621: LD_INT 5
68623: PUSH
68624: LD_INT 8
68626: PUSH
68627: LD_INT 9
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: LIST
68634: IN
68635: IFFALSE 68649
// SetClass ( unit , 1 ) ;
68637: LD_VAR 0 2
68641: PPUSH
68642: LD_INT 1
68644: PPUSH
68645: CALL_OW 336
// end ;
68649: LD_VAR 0 3
68653: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
68654: LD_INT 0
68656: PPUSH
68657: PPUSH
// if not mc_bases or not skirmish then
68658: LD_EXP 100
68662: NOT
68663: PUSH
68664: LD_EXP 98
68668: NOT
68669: OR
68670: IFFALSE 68674
// exit ;
68672: GO 68790
// if GetLives ( abandoned_vehicle ) > 250 then
68674: LD_VAR 0 2
68678: PPUSH
68679: CALL_OW 256
68683: PUSH
68684: LD_INT 250
68686: GREATER
68687: IFFALSE 68691
// exit ;
68689: GO 68790
// for i = 1 to mc_bases do
68691: LD_ADDR_VAR 0 6
68695: PUSH
68696: DOUBLE
68697: LD_INT 1
68699: DEC
68700: ST_TO_ADDR
68701: LD_EXP 100
68705: PUSH
68706: FOR_TO
68707: IFFALSE 68788
// begin if driver in mc_bases [ i ] then
68709: LD_VAR 0 1
68713: PUSH
68714: LD_EXP 100
68718: PUSH
68719: LD_VAR 0 6
68723: ARRAY
68724: IN
68725: IFFALSE 68786
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
68727: LD_VAR 0 1
68731: PPUSH
68732: LD_EXP 100
68736: PUSH
68737: LD_VAR 0 6
68741: ARRAY
68742: PPUSH
68743: LD_INT 2
68745: PUSH
68746: LD_INT 30
68748: PUSH
68749: LD_INT 0
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 30
68758: PUSH
68759: LD_INT 1
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: LIST
68770: PPUSH
68771: CALL_OW 72
68775: PUSH
68776: LD_INT 1
68778: ARRAY
68779: PPUSH
68780: CALL 106964 0 2
// break ;
68784: GO 68788
// end ; end ;
68786: GO 68706
68788: POP
68789: POP
// end ; end_of_file
68790: LD_VAR 0 5
68794: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
68795: LD_INT 0
68797: PPUSH
68798: PPUSH
// if exist_mode then
68799: LD_VAR 0 2
68803: IFFALSE 68828
// unit := CreateCharacter ( prefix & ident ) else
68805: LD_ADDR_VAR 0 5
68809: PUSH
68810: LD_VAR 0 3
68814: PUSH
68815: LD_VAR 0 1
68819: STR
68820: PPUSH
68821: CALL_OW 34
68825: ST_TO_ADDR
68826: GO 68843
// unit := NewCharacter ( ident ) ;
68828: LD_ADDR_VAR 0 5
68832: PUSH
68833: LD_VAR 0 1
68837: PPUSH
68838: CALL_OW 25
68842: ST_TO_ADDR
// result := unit ;
68843: LD_ADDR_VAR 0 4
68847: PUSH
68848: LD_VAR 0 5
68852: ST_TO_ADDR
// end ;
68853: LD_VAR 0 4
68857: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
68858: LD_INT 0
68860: PPUSH
68861: PPUSH
// if not side or not nation then
68862: LD_VAR 0 1
68866: NOT
68867: PUSH
68868: LD_VAR 0 2
68872: NOT
68873: OR
68874: IFFALSE 68878
// exit ;
68876: GO 69646
// case nation of nation_american :
68878: LD_VAR 0 2
68882: PUSH
68883: LD_INT 1
68885: DOUBLE
68886: EQUAL
68887: IFTRUE 68891
68889: GO 69105
68891: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
68892: LD_ADDR_VAR 0 4
68896: PUSH
68897: LD_INT 35
68899: PUSH
68900: LD_INT 45
68902: PUSH
68903: LD_INT 46
68905: PUSH
68906: LD_INT 47
68908: PUSH
68909: LD_INT 82
68911: PUSH
68912: LD_INT 83
68914: PUSH
68915: LD_INT 84
68917: PUSH
68918: LD_INT 85
68920: PUSH
68921: LD_INT 86
68923: PUSH
68924: LD_INT 1
68926: PUSH
68927: LD_INT 2
68929: PUSH
68930: LD_INT 6
68932: PUSH
68933: LD_INT 15
68935: PUSH
68936: LD_INT 16
68938: PUSH
68939: LD_INT 7
68941: PUSH
68942: LD_INT 12
68944: PUSH
68945: LD_INT 13
68947: PUSH
68948: LD_INT 10
68950: PUSH
68951: LD_INT 14
68953: PUSH
68954: LD_INT 20
68956: PUSH
68957: LD_INT 21
68959: PUSH
68960: LD_INT 22
68962: PUSH
68963: LD_INT 25
68965: PUSH
68966: LD_INT 32
68968: PUSH
68969: LD_INT 27
68971: PUSH
68972: LD_INT 36
68974: PUSH
68975: LD_INT 69
68977: PUSH
68978: LD_INT 39
68980: PUSH
68981: LD_INT 34
68983: PUSH
68984: LD_INT 40
68986: PUSH
68987: LD_INT 48
68989: PUSH
68990: LD_INT 49
68992: PUSH
68993: LD_INT 50
68995: PUSH
68996: LD_INT 51
68998: PUSH
68999: LD_INT 52
69001: PUSH
69002: LD_INT 53
69004: PUSH
69005: LD_INT 54
69007: PUSH
69008: LD_INT 55
69010: PUSH
69011: LD_INT 56
69013: PUSH
69014: LD_INT 57
69016: PUSH
69017: LD_INT 58
69019: PUSH
69020: LD_INT 59
69022: PUSH
69023: LD_INT 60
69025: PUSH
69026: LD_INT 61
69028: PUSH
69029: LD_INT 62
69031: PUSH
69032: LD_INT 80
69034: PUSH
69035: LD_INT 82
69037: PUSH
69038: LD_INT 83
69040: PUSH
69041: LD_INT 84
69043: PUSH
69044: LD_INT 85
69046: PUSH
69047: LD_INT 86
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: LIST
69101: LIST
69102: ST_TO_ADDR
69103: GO 69570
69105: LD_INT 2
69107: DOUBLE
69108: EQUAL
69109: IFTRUE 69113
69111: GO 69339
69113: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69114: LD_ADDR_VAR 0 4
69118: PUSH
69119: LD_INT 35
69121: PUSH
69122: LD_INT 45
69124: PUSH
69125: LD_INT 46
69127: PUSH
69128: LD_INT 47
69130: PUSH
69131: LD_INT 82
69133: PUSH
69134: LD_INT 83
69136: PUSH
69137: LD_INT 84
69139: PUSH
69140: LD_INT 85
69142: PUSH
69143: LD_INT 87
69145: PUSH
69146: LD_INT 70
69148: PUSH
69149: LD_INT 1
69151: PUSH
69152: LD_INT 11
69154: PUSH
69155: LD_INT 3
69157: PUSH
69158: LD_INT 4
69160: PUSH
69161: LD_INT 5
69163: PUSH
69164: LD_INT 6
69166: PUSH
69167: LD_INT 15
69169: PUSH
69170: LD_INT 18
69172: PUSH
69173: LD_INT 7
69175: PUSH
69176: LD_INT 17
69178: PUSH
69179: LD_INT 8
69181: PUSH
69182: LD_INT 20
69184: PUSH
69185: LD_INT 21
69187: PUSH
69188: LD_INT 22
69190: PUSH
69191: LD_INT 72
69193: PUSH
69194: LD_INT 26
69196: PUSH
69197: LD_INT 69
69199: PUSH
69200: LD_INT 39
69202: PUSH
69203: LD_INT 40
69205: PUSH
69206: LD_INT 41
69208: PUSH
69209: LD_INT 42
69211: PUSH
69212: LD_INT 43
69214: PUSH
69215: LD_INT 48
69217: PUSH
69218: LD_INT 49
69220: PUSH
69221: LD_INT 50
69223: PUSH
69224: LD_INT 51
69226: PUSH
69227: LD_INT 52
69229: PUSH
69230: LD_INT 53
69232: PUSH
69233: LD_INT 54
69235: PUSH
69236: LD_INT 55
69238: PUSH
69239: LD_INT 56
69241: PUSH
69242: LD_INT 60
69244: PUSH
69245: LD_INT 61
69247: PUSH
69248: LD_INT 62
69250: PUSH
69251: LD_INT 66
69253: PUSH
69254: LD_INT 67
69256: PUSH
69257: LD_INT 68
69259: PUSH
69260: LD_INT 81
69262: PUSH
69263: LD_INT 82
69265: PUSH
69266: LD_INT 83
69268: PUSH
69269: LD_INT 84
69271: PUSH
69272: LD_INT 85
69274: PUSH
69275: LD_INT 87
69277: PUSH
69278: LD_INT 88
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: ST_TO_ADDR
69337: GO 69570
69339: LD_INT 3
69341: DOUBLE
69342: EQUAL
69343: IFTRUE 69347
69345: GO 69569
69347: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
69348: LD_ADDR_VAR 0 4
69352: PUSH
69353: LD_INT 46
69355: PUSH
69356: LD_INT 47
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: LD_INT 2
69364: PUSH
69365: LD_INT 82
69367: PUSH
69368: LD_INT 83
69370: PUSH
69371: LD_INT 84
69373: PUSH
69374: LD_INT 85
69376: PUSH
69377: LD_INT 86
69379: PUSH
69380: LD_INT 11
69382: PUSH
69383: LD_INT 9
69385: PUSH
69386: LD_INT 20
69388: PUSH
69389: LD_INT 19
69391: PUSH
69392: LD_INT 21
69394: PUSH
69395: LD_INT 24
69397: PUSH
69398: LD_INT 22
69400: PUSH
69401: LD_INT 25
69403: PUSH
69404: LD_INT 28
69406: PUSH
69407: LD_INT 29
69409: PUSH
69410: LD_INT 30
69412: PUSH
69413: LD_INT 31
69415: PUSH
69416: LD_INT 37
69418: PUSH
69419: LD_INT 38
69421: PUSH
69422: LD_INT 32
69424: PUSH
69425: LD_INT 27
69427: PUSH
69428: LD_INT 33
69430: PUSH
69431: LD_INT 69
69433: PUSH
69434: LD_INT 39
69436: PUSH
69437: LD_INT 34
69439: PUSH
69440: LD_INT 40
69442: PUSH
69443: LD_INT 71
69445: PUSH
69446: LD_INT 23
69448: PUSH
69449: LD_INT 44
69451: PUSH
69452: LD_INT 48
69454: PUSH
69455: LD_INT 49
69457: PUSH
69458: LD_INT 50
69460: PUSH
69461: LD_INT 51
69463: PUSH
69464: LD_INT 52
69466: PUSH
69467: LD_INT 53
69469: PUSH
69470: LD_INT 54
69472: PUSH
69473: LD_INT 55
69475: PUSH
69476: LD_INT 56
69478: PUSH
69479: LD_INT 57
69481: PUSH
69482: LD_INT 58
69484: PUSH
69485: LD_INT 59
69487: PUSH
69488: LD_INT 63
69490: PUSH
69491: LD_INT 64
69493: PUSH
69494: LD_INT 65
69496: PUSH
69497: LD_INT 82
69499: PUSH
69500: LD_INT 83
69502: PUSH
69503: LD_INT 84
69505: PUSH
69506: LD_INT 85
69508: PUSH
69509: LD_INT 86
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: LIST
69534: LIST
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: ST_TO_ADDR
69567: GO 69570
69569: POP
// if state > - 1 and state < 3 then
69570: LD_VAR 0 3
69574: PUSH
69575: LD_INT 1
69577: NEG
69578: GREATER
69579: PUSH
69580: LD_VAR 0 3
69584: PUSH
69585: LD_INT 3
69587: LESS
69588: AND
69589: IFFALSE 69646
// for i in result do
69591: LD_ADDR_VAR 0 5
69595: PUSH
69596: LD_VAR 0 4
69600: PUSH
69601: FOR_IN
69602: IFFALSE 69644
// if GetTech ( i , side ) <> state then
69604: LD_VAR 0 5
69608: PPUSH
69609: LD_VAR 0 1
69613: PPUSH
69614: CALL_OW 321
69618: PUSH
69619: LD_VAR 0 3
69623: NONEQUAL
69624: IFFALSE 69642
// result := result diff i ;
69626: LD_ADDR_VAR 0 4
69630: PUSH
69631: LD_VAR 0 4
69635: PUSH
69636: LD_VAR 0 5
69640: DIFF
69641: ST_TO_ADDR
69642: GO 69601
69644: POP
69645: POP
// end ;
69646: LD_VAR 0 4
69650: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
69651: LD_INT 0
69653: PPUSH
69654: PPUSH
69655: PPUSH
// result := true ;
69656: LD_ADDR_VAR 0 3
69660: PUSH
69661: LD_INT 1
69663: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
69664: LD_ADDR_VAR 0 5
69668: PUSH
69669: LD_VAR 0 2
69673: PPUSH
69674: CALL_OW 480
69678: ST_TO_ADDR
// if not tmp then
69679: LD_VAR 0 5
69683: NOT
69684: IFFALSE 69688
// exit ;
69686: GO 69737
// for i in tmp do
69688: LD_ADDR_VAR 0 4
69692: PUSH
69693: LD_VAR 0 5
69697: PUSH
69698: FOR_IN
69699: IFFALSE 69735
// if GetTech ( i , side ) <> state_researched then
69701: LD_VAR 0 4
69705: PPUSH
69706: LD_VAR 0 1
69710: PPUSH
69711: CALL_OW 321
69715: PUSH
69716: LD_INT 2
69718: NONEQUAL
69719: IFFALSE 69733
// begin result := false ;
69721: LD_ADDR_VAR 0 3
69725: PUSH
69726: LD_INT 0
69728: ST_TO_ADDR
// exit ;
69729: POP
69730: POP
69731: GO 69737
// end ;
69733: GO 69698
69735: POP
69736: POP
// end ;
69737: LD_VAR 0 3
69741: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
69742: LD_INT 0
69744: PPUSH
69745: PPUSH
69746: PPUSH
69747: PPUSH
69748: PPUSH
69749: PPUSH
69750: PPUSH
69751: PPUSH
69752: PPUSH
69753: PPUSH
69754: PPUSH
69755: PPUSH
69756: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
69757: LD_VAR 0 1
69761: NOT
69762: PUSH
69763: LD_VAR 0 1
69767: PPUSH
69768: CALL_OW 257
69772: PUSH
69773: LD_INT 9
69775: NONEQUAL
69776: OR
69777: IFFALSE 69781
// exit ;
69779: GO 70354
// side := GetSide ( unit ) ;
69781: LD_ADDR_VAR 0 9
69785: PUSH
69786: LD_VAR 0 1
69790: PPUSH
69791: CALL_OW 255
69795: ST_TO_ADDR
// tech_space := tech_spacanom ;
69796: LD_ADDR_VAR 0 12
69800: PUSH
69801: LD_INT 29
69803: ST_TO_ADDR
// tech_time := tech_taurad ;
69804: LD_ADDR_VAR 0 13
69808: PUSH
69809: LD_INT 28
69811: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
69812: LD_ADDR_VAR 0 11
69816: PUSH
69817: LD_VAR 0 1
69821: PPUSH
69822: CALL_OW 310
69826: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
69827: LD_VAR 0 11
69831: PPUSH
69832: CALL_OW 247
69836: PUSH
69837: LD_INT 2
69839: EQUAL
69840: IFFALSE 69844
// exit ;
69842: GO 70354
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69844: LD_ADDR_VAR 0 8
69848: PUSH
69849: LD_INT 81
69851: PUSH
69852: LD_VAR 0 9
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 3
69863: PUSH
69864: LD_INT 21
69866: PUSH
69867: LD_INT 3
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PPUSH
69882: CALL_OW 69
69886: ST_TO_ADDR
// if not tmp then
69887: LD_VAR 0 8
69891: NOT
69892: IFFALSE 69896
// exit ;
69894: GO 70354
// if in_unit then
69896: LD_VAR 0 11
69900: IFFALSE 69924
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
69902: LD_ADDR_VAR 0 10
69906: PUSH
69907: LD_VAR 0 8
69911: PPUSH
69912: LD_VAR 0 11
69916: PPUSH
69917: CALL_OW 74
69921: ST_TO_ADDR
69922: GO 69944
// enemy := NearestUnitToUnit ( tmp , unit ) ;
69924: LD_ADDR_VAR 0 10
69928: PUSH
69929: LD_VAR 0 8
69933: PPUSH
69934: LD_VAR 0 1
69938: PPUSH
69939: CALL_OW 74
69943: ST_TO_ADDR
// if not enemy then
69944: LD_VAR 0 10
69948: NOT
69949: IFFALSE 69953
// exit ;
69951: GO 70354
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
69953: LD_VAR 0 11
69957: PUSH
69958: LD_VAR 0 11
69962: PPUSH
69963: LD_VAR 0 10
69967: PPUSH
69968: CALL_OW 296
69972: PUSH
69973: LD_INT 13
69975: GREATER
69976: AND
69977: PUSH
69978: LD_VAR 0 1
69982: PPUSH
69983: LD_VAR 0 10
69987: PPUSH
69988: CALL_OW 296
69992: PUSH
69993: LD_INT 12
69995: GREATER
69996: OR
69997: IFFALSE 70001
// exit ;
69999: GO 70354
// missile := [ 1 ] ;
70001: LD_ADDR_VAR 0 14
70005: PUSH
70006: LD_INT 1
70008: PUSH
70009: EMPTY
70010: LIST
70011: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70012: LD_VAR 0 9
70016: PPUSH
70017: LD_VAR 0 12
70021: PPUSH
70022: CALL_OW 325
70026: IFFALSE 70055
// missile := Replace ( missile , missile + 1 , 2 ) ;
70028: LD_ADDR_VAR 0 14
70032: PUSH
70033: LD_VAR 0 14
70037: PPUSH
70038: LD_VAR 0 14
70042: PUSH
70043: LD_INT 1
70045: PLUS
70046: PPUSH
70047: LD_INT 2
70049: PPUSH
70050: CALL_OW 1
70054: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70055: LD_VAR 0 9
70059: PPUSH
70060: LD_VAR 0 13
70064: PPUSH
70065: CALL_OW 325
70069: PUSH
70070: LD_VAR 0 10
70074: PPUSH
70075: CALL_OW 255
70079: PPUSH
70080: LD_VAR 0 13
70084: PPUSH
70085: CALL_OW 325
70089: NOT
70090: AND
70091: IFFALSE 70120
// missile := Replace ( missile , missile + 1 , 3 ) ;
70093: LD_ADDR_VAR 0 14
70097: PUSH
70098: LD_VAR 0 14
70102: PPUSH
70103: LD_VAR 0 14
70107: PUSH
70108: LD_INT 1
70110: PLUS
70111: PPUSH
70112: LD_INT 3
70114: PPUSH
70115: CALL_OW 1
70119: ST_TO_ADDR
// if missile < 2 then
70120: LD_VAR 0 14
70124: PUSH
70125: LD_INT 2
70127: LESS
70128: IFFALSE 70132
// exit ;
70130: GO 70354
// x := GetX ( enemy ) ;
70132: LD_ADDR_VAR 0 4
70136: PUSH
70137: LD_VAR 0 10
70141: PPUSH
70142: CALL_OW 250
70146: ST_TO_ADDR
// y := GetY ( enemy ) ;
70147: LD_ADDR_VAR 0 5
70151: PUSH
70152: LD_VAR 0 10
70156: PPUSH
70157: CALL_OW 251
70161: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70162: LD_ADDR_VAR 0 6
70166: PUSH
70167: LD_VAR 0 4
70171: PUSH
70172: LD_INT 1
70174: NEG
70175: PPUSH
70176: LD_INT 1
70178: PPUSH
70179: CALL_OW 12
70183: PLUS
70184: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70185: LD_ADDR_VAR 0 7
70189: PUSH
70190: LD_VAR 0 5
70194: PUSH
70195: LD_INT 1
70197: NEG
70198: PPUSH
70199: LD_INT 1
70201: PPUSH
70202: CALL_OW 12
70206: PLUS
70207: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70208: LD_VAR 0 6
70212: PPUSH
70213: LD_VAR 0 7
70217: PPUSH
70218: CALL_OW 488
70222: NOT
70223: IFFALSE 70245
// begin _x := x ;
70225: LD_ADDR_VAR 0 6
70229: PUSH
70230: LD_VAR 0 4
70234: ST_TO_ADDR
// _y := y ;
70235: LD_ADDR_VAR 0 7
70239: PUSH
70240: LD_VAR 0 5
70244: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70245: LD_ADDR_VAR 0 3
70249: PUSH
70250: LD_INT 1
70252: PPUSH
70253: LD_VAR 0 14
70257: PPUSH
70258: CALL_OW 12
70262: ST_TO_ADDR
// case i of 1 :
70263: LD_VAR 0 3
70267: PUSH
70268: LD_INT 1
70270: DOUBLE
70271: EQUAL
70272: IFTRUE 70276
70274: GO 70293
70276: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
70277: LD_VAR 0 1
70281: PPUSH
70282: LD_VAR 0 10
70286: PPUSH
70287: CALL_OW 115
70291: GO 70354
70293: LD_INT 2
70295: DOUBLE
70296: EQUAL
70297: IFTRUE 70301
70299: GO 70323
70301: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
70302: LD_VAR 0 1
70306: PPUSH
70307: LD_VAR 0 6
70311: PPUSH
70312: LD_VAR 0 7
70316: PPUSH
70317: CALL_OW 153
70321: GO 70354
70323: LD_INT 3
70325: DOUBLE
70326: EQUAL
70327: IFTRUE 70331
70329: GO 70353
70331: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
70332: LD_VAR 0 1
70336: PPUSH
70337: LD_VAR 0 6
70341: PPUSH
70342: LD_VAR 0 7
70346: PPUSH
70347: CALL_OW 154
70351: GO 70354
70353: POP
// end ;
70354: LD_VAR 0 2
70358: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
70359: LD_INT 0
70361: PPUSH
70362: PPUSH
70363: PPUSH
70364: PPUSH
70365: PPUSH
70366: PPUSH
// if not unit or not building then
70367: LD_VAR 0 1
70371: NOT
70372: PUSH
70373: LD_VAR 0 2
70377: NOT
70378: OR
70379: IFFALSE 70383
// exit ;
70381: GO 70541
// x := GetX ( building ) ;
70383: LD_ADDR_VAR 0 5
70387: PUSH
70388: LD_VAR 0 2
70392: PPUSH
70393: CALL_OW 250
70397: ST_TO_ADDR
// y := GetY ( building ) ;
70398: LD_ADDR_VAR 0 6
70402: PUSH
70403: LD_VAR 0 2
70407: PPUSH
70408: CALL_OW 251
70412: ST_TO_ADDR
// for i = 0 to 5 do
70413: LD_ADDR_VAR 0 4
70417: PUSH
70418: DOUBLE
70419: LD_INT 0
70421: DEC
70422: ST_TO_ADDR
70423: LD_INT 5
70425: PUSH
70426: FOR_TO
70427: IFFALSE 70539
// begin _x := ShiftX ( x , i , 3 ) ;
70429: LD_ADDR_VAR 0 7
70433: PUSH
70434: LD_VAR 0 5
70438: PPUSH
70439: LD_VAR 0 4
70443: PPUSH
70444: LD_INT 3
70446: PPUSH
70447: CALL_OW 272
70451: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
70452: LD_ADDR_VAR 0 8
70456: PUSH
70457: LD_VAR 0 6
70461: PPUSH
70462: LD_VAR 0 4
70466: PPUSH
70467: LD_INT 3
70469: PPUSH
70470: CALL_OW 273
70474: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70475: LD_VAR 0 7
70479: PPUSH
70480: LD_VAR 0 8
70484: PPUSH
70485: CALL_OW 488
70489: NOT
70490: IFFALSE 70494
// continue ;
70492: GO 70426
// if HexInfo ( _x , _y ) = 0 then
70494: LD_VAR 0 7
70498: PPUSH
70499: LD_VAR 0 8
70503: PPUSH
70504: CALL_OW 428
70508: PUSH
70509: LD_INT 0
70511: EQUAL
70512: IFFALSE 70537
// begin ComMoveXY ( unit , _x , _y ) ;
70514: LD_VAR 0 1
70518: PPUSH
70519: LD_VAR 0 7
70523: PPUSH
70524: LD_VAR 0 8
70528: PPUSH
70529: CALL_OW 111
// exit ;
70533: POP
70534: POP
70535: GO 70541
// end ; end ;
70537: GO 70426
70539: POP
70540: POP
// end ;
70541: LD_VAR 0 3
70545: RET
// export function ScanBase ( side , base_area ) ; begin
70546: LD_INT 0
70548: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
70549: LD_ADDR_VAR 0 3
70553: PUSH
70554: LD_VAR 0 2
70558: PPUSH
70559: LD_INT 81
70561: PUSH
70562: LD_VAR 0 1
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PPUSH
70571: CALL_OW 70
70575: ST_TO_ADDR
// end ;
70576: LD_VAR 0 3
70580: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
70581: LD_INT 0
70583: PPUSH
70584: PPUSH
70585: PPUSH
70586: PPUSH
// result := false ;
70587: LD_ADDR_VAR 0 2
70591: PUSH
70592: LD_INT 0
70594: ST_TO_ADDR
// side := GetSide ( unit ) ;
70595: LD_ADDR_VAR 0 3
70599: PUSH
70600: LD_VAR 0 1
70604: PPUSH
70605: CALL_OW 255
70609: ST_TO_ADDR
// nat := GetNation ( unit ) ;
70610: LD_ADDR_VAR 0 4
70614: PUSH
70615: LD_VAR 0 1
70619: PPUSH
70620: CALL_OW 248
70624: ST_TO_ADDR
// case nat of 1 :
70625: LD_VAR 0 4
70629: PUSH
70630: LD_INT 1
70632: DOUBLE
70633: EQUAL
70634: IFTRUE 70638
70636: GO 70649
70638: POP
// tech := tech_lassight ; 2 :
70639: LD_ADDR_VAR 0 5
70643: PUSH
70644: LD_INT 12
70646: ST_TO_ADDR
70647: GO 70688
70649: LD_INT 2
70651: DOUBLE
70652: EQUAL
70653: IFTRUE 70657
70655: GO 70668
70657: POP
// tech := tech_mortar ; 3 :
70658: LD_ADDR_VAR 0 5
70662: PUSH
70663: LD_INT 41
70665: ST_TO_ADDR
70666: GO 70688
70668: LD_INT 3
70670: DOUBLE
70671: EQUAL
70672: IFTRUE 70676
70674: GO 70687
70676: POP
// tech := tech_bazooka ; end ;
70677: LD_ADDR_VAR 0 5
70681: PUSH
70682: LD_INT 44
70684: ST_TO_ADDR
70685: GO 70688
70687: POP
// if Researched ( side , tech ) then
70688: LD_VAR 0 3
70692: PPUSH
70693: LD_VAR 0 5
70697: PPUSH
70698: CALL_OW 325
70702: IFFALSE 70729
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
70704: LD_ADDR_VAR 0 2
70708: PUSH
70709: LD_INT 5
70711: PUSH
70712: LD_INT 8
70714: PUSH
70715: LD_INT 9
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: LIST
70722: PUSH
70723: LD_VAR 0 4
70727: ARRAY
70728: ST_TO_ADDR
// end ;
70729: LD_VAR 0 2
70733: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
70734: LD_INT 0
70736: PPUSH
70737: PPUSH
70738: PPUSH
// if not mines then
70739: LD_VAR 0 2
70743: NOT
70744: IFFALSE 70748
// exit ;
70746: GO 70892
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70748: LD_ADDR_VAR 0 5
70752: PUSH
70753: LD_INT 81
70755: PUSH
70756: LD_VAR 0 1
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 3
70767: PUSH
70768: LD_INT 21
70770: PUSH
70771: LD_INT 3
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PPUSH
70786: CALL_OW 69
70790: ST_TO_ADDR
// for i in mines do
70791: LD_ADDR_VAR 0 4
70795: PUSH
70796: LD_VAR 0 2
70800: PUSH
70801: FOR_IN
70802: IFFALSE 70890
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
70804: LD_VAR 0 4
70808: PUSH
70809: LD_INT 1
70811: ARRAY
70812: PPUSH
70813: LD_VAR 0 4
70817: PUSH
70818: LD_INT 2
70820: ARRAY
70821: PPUSH
70822: CALL_OW 458
70826: NOT
70827: IFFALSE 70831
// continue ;
70829: GO 70801
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
70831: LD_VAR 0 4
70835: PUSH
70836: LD_INT 1
70838: ARRAY
70839: PPUSH
70840: LD_VAR 0 4
70844: PUSH
70845: LD_INT 2
70847: ARRAY
70848: PPUSH
70849: CALL_OW 428
70853: PUSH
70854: LD_VAR 0 5
70858: IN
70859: IFFALSE 70888
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
70861: LD_VAR 0 4
70865: PUSH
70866: LD_INT 1
70868: ARRAY
70869: PPUSH
70870: LD_VAR 0 4
70874: PUSH
70875: LD_INT 2
70877: ARRAY
70878: PPUSH
70879: LD_VAR 0 1
70883: PPUSH
70884: CALL_OW 456
// end ;
70888: GO 70801
70890: POP
70891: POP
// end ;
70892: LD_VAR 0 3
70896: RET
// export function Count ( array ) ; begin
70897: LD_INT 0
70899: PPUSH
// result := array + 0 ;
70900: LD_ADDR_VAR 0 2
70904: PUSH
70905: LD_VAR 0 1
70909: PUSH
70910: LD_INT 0
70912: PLUS
70913: ST_TO_ADDR
// end ;
70914: LD_VAR 0 2
70918: RET
// export function IsEmpty ( building ) ; begin
70919: LD_INT 0
70921: PPUSH
// if not building then
70922: LD_VAR 0 1
70926: NOT
70927: IFFALSE 70931
// exit ;
70929: GO 70974
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
70931: LD_ADDR_VAR 0 2
70935: PUSH
70936: LD_VAR 0 1
70940: PUSH
70941: LD_INT 22
70943: PUSH
70944: LD_VAR 0 1
70948: PPUSH
70949: CALL_OW 255
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 58
70960: PUSH
70961: EMPTY
70962: LIST
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PPUSH
70968: CALL_OW 69
70972: IN
70973: ST_TO_ADDR
// end ;
70974: LD_VAR 0 2
70978: RET
// export function IsNotFull ( building ) ; var places ; begin
70979: LD_INT 0
70981: PPUSH
70982: PPUSH
// if not building then
70983: LD_VAR 0 1
70987: NOT
70988: IFFALSE 70992
// exit ;
70990: GO 71020
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
70992: LD_ADDR_VAR 0 2
70996: PUSH
70997: LD_VAR 0 1
71001: PPUSH
71002: LD_INT 3
71004: PUSH
71005: LD_INT 62
71007: PUSH
71008: EMPTY
71009: LIST
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PPUSH
71015: CALL_OW 72
71019: ST_TO_ADDR
// end ;
71020: LD_VAR 0 2
71024: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71025: LD_INT 0
71027: PPUSH
71028: PPUSH
71029: PPUSH
71030: PPUSH
// tmp := [ ] ;
71031: LD_ADDR_VAR 0 3
71035: PUSH
71036: EMPTY
71037: ST_TO_ADDR
// list := [ ] ;
71038: LD_ADDR_VAR 0 5
71042: PUSH
71043: EMPTY
71044: ST_TO_ADDR
// for i = 16 to 25 do
71045: LD_ADDR_VAR 0 4
71049: PUSH
71050: DOUBLE
71051: LD_INT 16
71053: DEC
71054: ST_TO_ADDR
71055: LD_INT 25
71057: PUSH
71058: FOR_TO
71059: IFFALSE 71132
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71061: LD_ADDR_VAR 0 3
71065: PUSH
71066: LD_VAR 0 3
71070: PUSH
71071: LD_INT 22
71073: PUSH
71074: LD_VAR 0 1
71078: PPUSH
71079: CALL_OW 255
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PUSH
71088: LD_INT 91
71090: PUSH
71091: LD_VAR 0 1
71095: PUSH
71096: LD_INT 6
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 30
71106: PUSH
71107: LD_VAR 0 4
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: LIST
71120: PUSH
71121: EMPTY
71122: LIST
71123: PPUSH
71124: CALL_OW 69
71128: ADD
71129: ST_TO_ADDR
71130: GO 71058
71132: POP
71133: POP
// for i = 1 to tmp do
71134: LD_ADDR_VAR 0 4
71138: PUSH
71139: DOUBLE
71140: LD_INT 1
71142: DEC
71143: ST_TO_ADDR
71144: LD_VAR 0 3
71148: PUSH
71149: FOR_TO
71150: IFFALSE 71238
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71152: LD_ADDR_VAR 0 5
71156: PUSH
71157: LD_VAR 0 5
71161: PUSH
71162: LD_VAR 0 3
71166: PUSH
71167: LD_VAR 0 4
71171: ARRAY
71172: PPUSH
71173: CALL_OW 266
71177: PUSH
71178: LD_VAR 0 3
71182: PUSH
71183: LD_VAR 0 4
71187: ARRAY
71188: PPUSH
71189: CALL_OW 250
71193: PUSH
71194: LD_VAR 0 3
71198: PUSH
71199: LD_VAR 0 4
71203: ARRAY
71204: PPUSH
71205: CALL_OW 251
71209: PUSH
71210: LD_VAR 0 3
71214: PUSH
71215: LD_VAR 0 4
71219: ARRAY
71220: PPUSH
71221: CALL_OW 254
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: LIST
71230: LIST
71231: PUSH
71232: EMPTY
71233: LIST
71234: ADD
71235: ST_TO_ADDR
71236: GO 71149
71238: POP
71239: POP
// result := list ;
71240: LD_ADDR_VAR 0 2
71244: PUSH
71245: LD_VAR 0 5
71249: ST_TO_ADDR
// end ;
71250: LD_VAR 0 2
71254: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
71255: LD_INT 0
71257: PPUSH
71258: PPUSH
71259: PPUSH
71260: PPUSH
71261: PPUSH
71262: PPUSH
71263: PPUSH
// if not factory then
71264: LD_VAR 0 1
71268: NOT
71269: IFFALSE 71273
// exit ;
71271: GO 71866
// if control = control_apeman then
71273: LD_VAR 0 4
71277: PUSH
71278: LD_INT 5
71280: EQUAL
71281: IFFALSE 71390
// begin tmp := UnitsInside ( factory ) ;
71283: LD_ADDR_VAR 0 8
71287: PUSH
71288: LD_VAR 0 1
71292: PPUSH
71293: CALL_OW 313
71297: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
71298: LD_VAR 0 8
71302: PPUSH
71303: LD_INT 25
71305: PUSH
71306: LD_INT 12
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PPUSH
71313: CALL_OW 72
71317: NOT
71318: IFFALSE 71328
// control := control_manual ;
71320: LD_ADDR_VAR 0 4
71324: PUSH
71325: LD_INT 1
71327: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
71328: LD_ADDR_VAR 0 8
71332: PUSH
71333: LD_VAR 0 1
71337: PPUSH
71338: CALL 71025 0 1
71342: ST_TO_ADDR
// if tmp then
71343: LD_VAR 0 8
71347: IFFALSE 71390
// begin for i in tmp do
71349: LD_ADDR_VAR 0 7
71353: PUSH
71354: LD_VAR 0 8
71358: PUSH
71359: FOR_IN
71360: IFFALSE 71388
// if i [ 1 ] = b_ext_radio then
71362: LD_VAR 0 7
71366: PUSH
71367: LD_INT 1
71369: ARRAY
71370: PUSH
71371: LD_INT 22
71373: EQUAL
71374: IFFALSE 71386
// begin control := control_remote ;
71376: LD_ADDR_VAR 0 4
71380: PUSH
71381: LD_INT 2
71383: ST_TO_ADDR
// break ;
71384: GO 71388
// end ;
71386: GO 71359
71388: POP
71389: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71390: LD_VAR 0 1
71394: PPUSH
71395: LD_VAR 0 2
71399: PPUSH
71400: LD_VAR 0 3
71404: PPUSH
71405: LD_VAR 0 4
71409: PPUSH
71410: LD_VAR 0 5
71414: PPUSH
71415: CALL_OW 448
71419: IFFALSE 71454
// begin result := [ chassis , engine , control , weapon ] ;
71421: LD_ADDR_VAR 0 6
71425: PUSH
71426: LD_VAR 0 2
71430: PUSH
71431: LD_VAR 0 3
71435: PUSH
71436: LD_VAR 0 4
71440: PUSH
71441: LD_VAR 0 5
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: LIST
71450: LIST
71451: ST_TO_ADDR
// exit ;
71452: GO 71866
// end ; _chassis := AvailableChassisList ( factory ) ;
71454: LD_ADDR_VAR 0 9
71458: PUSH
71459: LD_VAR 0 1
71463: PPUSH
71464: CALL_OW 475
71468: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
71469: LD_ADDR_VAR 0 11
71473: PUSH
71474: LD_VAR 0 1
71478: PPUSH
71479: CALL_OW 476
71483: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
71484: LD_ADDR_VAR 0 12
71488: PUSH
71489: LD_VAR 0 1
71493: PPUSH
71494: CALL_OW 477
71498: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
71499: LD_ADDR_VAR 0 10
71503: PUSH
71504: LD_VAR 0 1
71508: PPUSH
71509: CALL_OW 478
71513: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
71514: LD_VAR 0 9
71518: NOT
71519: PUSH
71520: LD_VAR 0 11
71524: NOT
71525: OR
71526: PUSH
71527: LD_VAR 0 12
71531: NOT
71532: OR
71533: PUSH
71534: LD_VAR 0 10
71538: NOT
71539: OR
71540: IFFALSE 71575
// begin result := [ chassis , engine , control , weapon ] ;
71542: LD_ADDR_VAR 0 6
71546: PUSH
71547: LD_VAR 0 2
71551: PUSH
71552: LD_VAR 0 3
71556: PUSH
71557: LD_VAR 0 4
71561: PUSH
71562: LD_VAR 0 5
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: LIST
71571: LIST
71572: ST_TO_ADDR
// exit ;
71573: GO 71866
// end ; if not chassis in _chassis then
71575: LD_VAR 0 2
71579: PUSH
71580: LD_VAR 0 9
71584: IN
71585: NOT
71586: IFFALSE 71612
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
71588: LD_ADDR_VAR 0 2
71592: PUSH
71593: LD_VAR 0 9
71597: PUSH
71598: LD_INT 1
71600: PPUSH
71601: LD_VAR 0 9
71605: PPUSH
71606: CALL_OW 12
71610: ARRAY
71611: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
71612: LD_VAR 0 2
71616: PPUSH
71617: LD_VAR 0 3
71621: PPUSH
71622: CALL 71871 0 2
71626: NOT
71627: IFFALSE 71686
// repeat engine := _engine [ 1 ] ;
71629: LD_ADDR_VAR 0 3
71633: PUSH
71634: LD_VAR 0 11
71638: PUSH
71639: LD_INT 1
71641: ARRAY
71642: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
71643: LD_ADDR_VAR 0 11
71647: PUSH
71648: LD_VAR 0 11
71652: PPUSH
71653: LD_INT 1
71655: PPUSH
71656: CALL_OW 3
71660: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
71661: LD_VAR 0 2
71665: PPUSH
71666: LD_VAR 0 3
71670: PPUSH
71671: CALL 71871 0 2
71675: PUSH
71676: LD_VAR 0 11
71680: PUSH
71681: EMPTY
71682: EQUAL
71683: OR
71684: IFFALSE 71629
// if not control in _control then
71686: LD_VAR 0 4
71690: PUSH
71691: LD_VAR 0 12
71695: IN
71696: NOT
71697: IFFALSE 71723
// control := _control [ rand ( 1 , _control ) ] ;
71699: LD_ADDR_VAR 0 4
71703: PUSH
71704: LD_VAR 0 12
71708: PUSH
71709: LD_INT 1
71711: PPUSH
71712: LD_VAR 0 12
71716: PPUSH
71717: CALL_OW 12
71721: ARRAY
71722: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
71723: LD_VAR 0 2
71727: PPUSH
71728: LD_VAR 0 5
71732: PPUSH
71733: CALL 72091 0 2
71737: NOT
71738: IFFALSE 71797
// repeat weapon := _weapon [ 1 ] ;
71740: LD_ADDR_VAR 0 5
71744: PUSH
71745: LD_VAR 0 10
71749: PUSH
71750: LD_INT 1
71752: ARRAY
71753: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
71754: LD_ADDR_VAR 0 10
71758: PUSH
71759: LD_VAR 0 10
71763: PPUSH
71764: LD_INT 1
71766: PPUSH
71767: CALL_OW 3
71771: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
71772: LD_VAR 0 2
71776: PPUSH
71777: LD_VAR 0 5
71781: PPUSH
71782: CALL 72091 0 2
71786: PUSH
71787: LD_VAR 0 10
71791: PUSH
71792: EMPTY
71793: EQUAL
71794: OR
71795: IFFALSE 71740
// result := [ ] ;
71797: LD_ADDR_VAR 0 6
71801: PUSH
71802: EMPTY
71803: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71804: LD_VAR 0 1
71808: PPUSH
71809: LD_VAR 0 2
71813: PPUSH
71814: LD_VAR 0 3
71818: PPUSH
71819: LD_VAR 0 4
71823: PPUSH
71824: LD_VAR 0 5
71828: PPUSH
71829: CALL_OW 448
71833: IFFALSE 71866
// result := [ chassis , engine , control , weapon ] ;
71835: LD_ADDR_VAR 0 6
71839: PUSH
71840: LD_VAR 0 2
71844: PUSH
71845: LD_VAR 0 3
71849: PUSH
71850: LD_VAR 0 4
71854: PUSH
71855: LD_VAR 0 5
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: ST_TO_ADDR
// end ;
71866: LD_VAR 0 6
71870: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
71871: LD_INT 0
71873: PPUSH
// if not chassis or not engine then
71874: LD_VAR 0 1
71878: NOT
71879: PUSH
71880: LD_VAR 0 2
71884: NOT
71885: OR
71886: IFFALSE 71890
// exit ;
71888: GO 72086
// case engine of engine_solar :
71890: LD_VAR 0 2
71894: PUSH
71895: LD_INT 2
71897: DOUBLE
71898: EQUAL
71899: IFTRUE 71903
71901: GO 71941
71903: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
71904: LD_ADDR_VAR 0 3
71908: PUSH
71909: LD_INT 11
71911: PUSH
71912: LD_INT 12
71914: PUSH
71915: LD_INT 13
71917: PUSH
71918: LD_INT 14
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: LD_INT 2
71926: PUSH
71927: LD_INT 3
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: LIST
71934: LIST
71935: LIST
71936: LIST
71937: LIST
71938: ST_TO_ADDR
71939: GO 72070
71941: LD_INT 1
71943: DOUBLE
71944: EQUAL
71945: IFTRUE 71949
71947: GO 72011
71949: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
71950: LD_ADDR_VAR 0 3
71954: PUSH
71955: LD_INT 11
71957: PUSH
71958: LD_INT 12
71960: PUSH
71961: LD_INT 13
71963: PUSH
71964: LD_INT 14
71966: PUSH
71967: LD_INT 1
71969: PUSH
71970: LD_INT 2
71972: PUSH
71973: LD_INT 3
71975: PUSH
71976: LD_INT 4
71978: PUSH
71979: LD_INT 5
71981: PUSH
71982: LD_INT 21
71984: PUSH
71985: LD_INT 23
71987: PUSH
71988: LD_INT 22
71990: PUSH
71991: LD_INT 24
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: LIST
72007: LIST
72008: ST_TO_ADDR
72009: GO 72070
72011: LD_INT 3
72013: DOUBLE
72014: EQUAL
72015: IFTRUE 72019
72017: GO 72069
72019: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72020: LD_ADDR_VAR 0 3
72024: PUSH
72025: LD_INT 13
72027: PUSH
72028: LD_INT 14
72030: PUSH
72031: LD_INT 2
72033: PUSH
72034: LD_INT 3
72036: PUSH
72037: LD_INT 4
72039: PUSH
72040: LD_INT 5
72042: PUSH
72043: LD_INT 21
72045: PUSH
72046: LD_INT 22
72048: PUSH
72049: LD_INT 23
72051: PUSH
72052: LD_INT 24
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: ST_TO_ADDR
72067: GO 72070
72069: POP
// result := ( chassis in result ) ;
72070: LD_ADDR_VAR 0 3
72074: PUSH
72075: LD_VAR 0 1
72079: PUSH
72080: LD_VAR 0 3
72084: IN
72085: ST_TO_ADDR
// end ;
72086: LD_VAR 0 3
72090: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72091: LD_INT 0
72093: PPUSH
// if not chassis or not weapon then
72094: LD_VAR 0 1
72098: NOT
72099: PUSH
72100: LD_VAR 0 2
72104: NOT
72105: OR
72106: IFFALSE 72110
// exit ;
72108: GO 73170
// case weapon of us_machine_gun :
72110: LD_VAR 0 2
72114: PUSH
72115: LD_INT 2
72117: DOUBLE
72118: EQUAL
72119: IFTRUE 72123
72121: GO 72153
72123: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72124: LD_ADDR_VAR 0 3
72128: PUSH
72129: LD_INT 1
72131: PUSH
72132: LD_INT 2
72134: PUSH
72135: LD_INT 3
72137: PUSH
72138: LD_INT 4
72140: PUSH
72141: LD_INT 5
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: ST_TO_ADDR
72151: GO 73154
72153: LD_INT 3
72155: DOUBLE
72156: EQUAL
72157: IFTRUE 72161
72159: GO 72191
72161: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72162: LD_ADDR_VAR 0 3
72166: PUSH
72167: LD_INT 1
72169: PUSH
72170: LD_INT 2
72172: PUSH
72173: LD_INT 3
72175: PUSH
72176: LD_INT 4
72178: PUSH
72179: LD_INT 5
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: ST_TO_ADDR
72189: GO 73154
72191: LD_INT 11
72193: DOUBLE
72194: EQUAL
72195: IFTRUE 72199
72197: GO 72229
72199: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72200: LD_ADDR_VAR 0 3
72204: PUSH
72205: LD_INT 1
72207: PUSH
72208: LD_INT 2
72210: PUSH
72211: LD_INT 3
72213: PUSH
72214: LD_INT 4
72216: PUSH
72217: LD_INT 5
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: ST_TO_ADDR
72227: GO 73154
72229: LD_INT 4
72231: DOUBLE
72232: EQUAL
72233: IFTRUE 72237
72235: GO 72263
72237: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72238: LD_ADDR_VAR 0 3
72242: PUSH
72243: LD_INT 2
72245: PUSH
72246: LD_INT 3
72248: PUSH
72249: LD_INT 4
72251: PUSH
72252: LD_INT 5
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: LIST
72259: LIST
72260: ST_TO_ADDR
72261: GO 73154
72263: LD_INT 5
72265: DOUBLE
72266: EQUAL
72267: IFTRUE 72271
72269: GO 72297
72271: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
72272: LD_ADDR_VAR 0 3
72276: PUSH
72277: LD_INT 2
72279: PUSH
72280: LD_INT 3
72282: PUSH
72283: LD_INT 4
72285: PUSH
72286: LD_INT 5
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: ST_TO_ADDR
72295: GO 73154
72297: LD_INT 9
72299: DOUBLE
72300: EQUAL
72301: IFTRUE 72305
72303: GO 72331
72305: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
72306: LD_ADDR_VAR 0 3
72310: PUSH
72311: LD_INT 2
72313: PUSH
72314: LD_INT 3
72316: PUSH
72317: LD_INT 4
72319: PUSH
72320: LD_INT 5
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: ST_TO_ADDR
72329: GO 73154
72331: LD_INT 7
72333: DOUBLE
72334: EQUAL
72335: IFTRUE 72339
72337: GO 72365
72339: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
72340: LD_ADDR_VAR 0 3
72344: PUSH
72345: LD_INT 2
72347: PUSH
72348: LD_INT 3
72350: PUSH
72351: LD_INT 4
72353: PUSH
72354: LD_INT 5
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: ST_TO_ADDR
72363: GO 73154
72365: LD_INT 12
72367: DOUBLE
72368: EQUAL
72369: IFTRUE 72373
72371: GO 72399
72373: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
72374: LD_ADDR_VAR 0 3
72378: PUSH
72379: LD_INT 2
72381: PUSH
72382: LD_INT 3
72384: PUSH
72385: LD_INT 4
72387: PUSH
72388: LD_INT 5
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: ST_TO_ADDR
72397: GO 73154
72399: LD_INT 13
72401: DOUBLE
72402: EQUAL
72403: IFTRUE 72407
72405: GO 72433
72407: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
72408: LD_ADDR_VAR 0 3
72412: PUSH
72413: LD_INT 2
72415: PUSH
72416: LD_INT 3
72418: PUSH
72419: LD_INT 4
72421: PUSH
72422: LD_INT 5
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: ST_TO_ADDR
72431: GO 73154
72433: LD_INT 14
72435: DOUBLE
72436: EQUAL
72437: IFTRUE 72441
72439: GO 72459
72441: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
72442: LD_ADDR_VAR 0 3
72446: PUSH
72447: LD_INT 4
72449: PUSH
72450: LD_INT 5
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: ST_TO_ADDR
72457: GO 73154
72459: LD_INT 6
72461: DOUBLE
72462: EQUAL
72463: IFTRUE 72467
72465: GO 72485
72467: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
72468: LD_ADDR_VAR 0 3
72472: PUSH
72473: LD_INT 4
72475: PUSH
72476: LD_INT 5
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: ST_TO_ADDR
72483: GO 73154
72485: LD_INT 10
72487: DOUBLE
72488: EQUAL
72489: IFTRUE 72493
72491: GO 72511
72493: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
72494: LD_ADDR_VAR 0 3
72498: PUSH
72499: LD_INT 4
72501: PUSH
72502: LD_INT 5
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: ST_TO_ADDR
72509: GO 73154
72511: LD_INT 22
72513: DOUBLE
72514: EQUAL
72515: IFTRUE 72519
72517: GO 72545
72519: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
72520: LD_ADDR_VAR 0 3
72524: PUSH
72525: LD_INT 11
72527: PUSH
72528: LD_INT 12
72530: PUSH
72531: LD_INT 13
72533: PUSH
72534: LD_INT 14
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: LIST
72541: LIST
72542: ST_TO_ADDR
72543: GO 73154
72545: LD_INT 23
72547: DOUBLE
72548: EQUAL
72549: IFTRUE 72553
72551: GO 72579
72553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
72554: LD_ADDR_VAR 0 3
72558: PUSH
72559: LD_INT 11
72561: PUSH
72562: LD_INT 12
72564: PUSH
72565: LD_INT 13
72567: PUSH
72568: LD_INT 14
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: LIST
72575: LIST
72576: ST_TO_ADDR
72577: GO 73154
72579: LD_INT 24
72581: DOUBLE
72582: EQUAL
72583: IFTRUE 72587
72585: GO 72613
72587: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
72588: LD_ADDR_VAR 0 3
72592: PUSH
72593: LD_INT 11
72595: PUSH
72596: LD_INT 12
72598: PUSH
72599: LD_INT 13
72601: PUSH
72602: LD_INT 14
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: LIST
72609: LIST
72610: ST_TO_ADDR
72611: GO 73154
72613: LD_INT 30
72615: DOUBLE
72616: EQUAL
72617: IFTRUE 72621
72619: GO 72647
72621: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
72622: LD_ADDR_VAR 0 3
72626: PUSH
72627: LD_INT 11
72629: PUSH
72630: LD_INT 12
72632: PUSH
72633: LD_INT 13
72635: PUSH
72636: LD_INT 14
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: LIST
72643: LIST
72644: ST_TO_ADDR
72645: GO 73154
72647: LD_INT 25
72649: DOUBLE
72650: EQUAL
72651: IFTRUE 72655
72653: GO 72673
72655: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
72656: LD_ADDR_VAR 0 3
72660: PUSH
72661: LD_INT 13
72663: PUSH
72664: LD_INT 14
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: ST_TO_ADDR
72671: GO 73154
72673: LD_INT 27
72675: DOUBLE
72676: EQUAL
72677: IFTRUE 72681
72679: GO 72699
72681: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
72682: LD_ADDR_VAR 0 3
72686: PUSH
72687: LD_INT 13
72689: PUSH
72690: LD_INT 14
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: ST_TO_ADDR
72697: GO 73154
72699: LD_INT 92
72701: DOUBLE
72702: EQUAL
72703: IFTRUE 72707
72705: GO 72733
72707: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
72708: LD_ADDR_VAR 0 3
72712: PUSH
72713: LD_INT 11
72715: PUSH
72716: LD_INT 12
72718: PUSH
72719: LD_INT 13
72721: PUSH
72722: LD_INT 14
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: ST_TO_ADDR
72731: GO 73154
72733: LD_INT 28
72735: DOUBLE
72736: EQUAL
72737: IFTRUE 72741
72739: GO 72759
72741: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
72742: LD_ADDR_VAR 0 3
72746: PUSH
72747: LD_INT 13
72749: PUSH
72750: LD_INT 14
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: ST_TO_ADDR
72757: GO 73154
72759: LD_INT 29
72761: DOUBLE
72762: EQUAL
72763: IFTRUE 72767
72765: GO 72785
72767: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
72768: LD_ADDR_VAR 0 3
72772: PUSH
72773: LD_INT 13
72775: PUSH
72776: LD_INT 14
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: ST_TO_ADDR
72783: GO 73154
72785: LD_INT 31
72787: DOUBLE
72788: EQUAL
72789: IFTRUE 72793
72791: GO 72811
72793: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
72794: LD_ADDR_VAR 0 3
72798: PUSH
72799: LD_INT 13
72801: PUSH
72802: LD_INT 14
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: ST_TO_ADDR
72809: GO 73154
72811: LD_INT 26
72813: DOUBLE
72814: EQUAL
72815: IFTRUE 72819
72817: GO 72837
72819: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
72820: LD_ADDR_VAR 0 3
72824: PUSH
72825: LD_INT 13
72827: PUSH
72828: LD_INT 14
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: ST_TO_ADDR
72835: GO 73154
72837: LD_INT 42
72839: DOUBLE
72840: EQUAL
72841: IFTRUE 72845
72843: GO 72871
72845: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
72846: LD_ADDR_VAR 0 3
72850: PUSH
72851: LD_INT 21
72853: PUSH
72854: LD_INT 22
72856: PUSH
72857: LD_INT 23
72859: PUSH
72860: LD_INT 24
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: LIST
72867: LIST
72868: ST_TO_ADDR
72869: GO 73154
72871: LD_INT 43
72873: DOUBLE
72874: EQUAL
72875: IFTRUE 72879
72877: GO 72905
72879: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
72880: LD_ADDR_VAR 0 3
72884: PUSH
72885: LD_INT 21
72887: PUSH
72888: LD_INT 22
72890: PUSH
72891: LD_INT 23
72893: PUSH
72894: LD_INT 24
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: LIST
72901: LIST
72902: ST_TO_ADDR
72903: GO 73154
72905: LD_INT 44
72907: DOUBLE
72908: EQUAL
72909: IFTRUE 72913
72911: GO 72939
72913: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
72914: LD_ADDR_VAR 0 3
72918: PUSH
72919: LD_INT 21
72921: PUSH
72922: LD_INT 22
72924: PUSH
72925: LD_INT 23
72927: PUSH
72928: LD_INT 24
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: ST_TO_ADDR
72937: GO 73154
72939: LD_INT 45
72941: DOUBLE
72942: EQUAL
72943: IFTRUE 72947
72945: GO 72973
72947: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
72948: LD_ADDR_VAR 0 3
72952: PUSH
72953: LD_INT 21
72955: PUSH
72956: LD_INT 22
72958: PUSH
72959: LD_INT 23
72961: PUSH
72962: LD_INT 24
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: ST_TO_ADDR
72971: GO 73154
72973: LD_INT 49
72975: DOUBLE
72976: EQUAL
72977: IFTRUE 72981
72979: GO 73007
72981: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
72982: LD_ADDR_VAR 0 3
72986: PUSH
72987: LD_INT 21
72989: PUSH
72990: LD_INT 22
72992: PUSH
72993: LD_INT 23
72995: PUSH
72996: LD_INT 24
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: ST_TO_ADDR
73005: GO 73154
73007: LD_INT 51
73009: DOUBLE
73010: EQUAL
73011: IFTRUE 73015
73013: GO 73041
73015: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73016: LD_ADDR_VAR 0 3
73020: PUSH
73021: LD_INT 21
73023: PUSH
73024: LD_INT 22
73026: PUSH
73027: LD_INT 23
73029: PUSH
73030: LD_INT 24
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: LIST
73037: LIST
73038: ST_TO_ADDR
73039: GO 73154
73041: LD_INT 52
73043: DOUBLE
73044: EQUAL
73045: IFTRUE 73049
73047: GO 73075
73049: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73050: LD_ADDR_VAR 0 3
73054: PUSH
73055: LD_INT 21
73057: PUSH
73058: LD_INT 22
73060: PUSH
73061: LD_INT 23
73063: PUSH
73064: LD_INT 24
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: ST_TO_ADDR
73073: GO 73154
73075: LD_INT 53
73077: DOUBLE
73078: EQUAL
73079: IFTRUE 73083
73081: GO 73101
73083: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73084: LD_ADDR_VAR 0 3
73088: PUSH
73089: LD_INT 23
73091: PUSH
73092: LD_INT 24
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: ST_TO_ADDR
73099: GO 73154
73101: LD_INT 46
73103: DOUBLE
73104: EQUAL
73105: IFTRUE 73109
73107: GO 73127
73109: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73110: LD_ADDR_VAR 0 3
73114: PUSH
73115: LD_INT 23
73117: PUSH
73118: LD_INT 24
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: ST_TO_ADDR
73125: GO 73154
73127: LD_INT 47
73129: DOUBLE
73130: EQUAL
73131: IFTRUE 73135
73133: GO 73153
73135: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73136: LD_ADDR_VAR 0 3
73140: PUSH
73141: LD_INT 23
73143: PUSH
73144: LD_INT 24
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: ST_TO_ADDR
73151: GO 73154
73153: POP
// result := ( chassis in result ) ;
73154: LD_ADDR_VAR 0 3
73158: PUSH
73159: LD_VAR 0 1
73163: PUSH
73164: LD_VAR 0 3
73168: IN
73169: ST_TO_ADDR
// end ;
73170: LD_VAR 0 3
73174: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73175: LD_INT 0
73177: PPUSH
73178: PPUSH
73179: PPUSH
73180: PPUSH
73181: PPUSH
73182: PPUSH
73183: PPUSH
// result := array ;
73184: LD_ADDR_VAR 0 5
73188: PUSH
73189: LD_VAR 0 1
73193: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73194: LD_VAR 0 1
73198: NOT
73199: PUSH
73200: LD_VAR 0 2
73204: NOT
73205: OR
73206: PUSH
73207: LD_VAR 0 3
73211: NOT
73212: OR
73213: PUSH
73214: LD_VAR 0 2
73218: PUSH
73219: LD_VAR 0 1
73223: GREATER
73224: OR
73225: PUSH
73226: LD_VAR 0 3
73230: PUSH
73231: LD_VAR 0 1
73235: GREATER
73236: OR
73237: IFFALSE 73241
// exit ;
73239: GO 73537
// if direction then
73241: LD_VAR 0 4
73245: IFFALSE 73309
// begin d := 1 ;
73247: LD_ADDR_VAR 0 9
73251: PUSH
73252: LD_INT 1
73254: ST_TO_ADDR
// if i_from > i_to then
73255: LD_VAR 0 2
73259: PUSH
73260: LD_VAR 0 3
73264: GREATER
73265: IFFALSE 73291
// length := ( array - i_from ) + i_to else
73267: LD_ADDR_VAR 0 11
73271: PUSH
73272: LD_VAR 0 1
73276: PUSH
73277: LD_VAR 0 2
73281: MINUS
73282: PUSH
73283: LD_VAR 0 3
73287: PLUS
73288: ST_TO_ADDR
73289: GO 73307
// length := i_to - i_from ;
73291: LD_ADDR_VAR 0 11
73295: PUSH
73296: LD_VAR 0 3
73300: PUSH
73301: LD_VAR 0 2
73305: MINUS
73306: ST_TO_ADDR
// end else
73307: GO 73370
// begin d := - 1 ;
73309: LD_ADDR_VAR 0 9
73313: PUSH
73314: LD_INT 1
73316: NEG
73317: ST_TO_ADDR
// if i_from > i_to then
73318: LD_VAR 0 2
73322: PUSH
73323: LD_VAR 0 3
73327: GREATER
73328: IFFALSE 73348
// length := i_from - i_to else
73330: LD_ADDR_VAR 0 11
73334: PUSH
73335: LD_VAR 0 2
73339: PUSH
73340: LD_VAR 0 3
73344: MINUS
73345: ST_TO_ADDR
73346: GO 73370
// length := ( array - i_to ) + i_from ;
73348: LD_ADDR_VAR 0 11
73352: PUSH
73353: LD_VAR 0 1
73357: PUSH
73358: LD_VAR 0 3
73362: MINUS
73363: PUSH
73364: LD_VAR 0 2
73368: PLUS
73369: ST_TO_ADDR
// end ; if not length then
73370: LD_VAR 0 11
73374: NOT
73375: IFFALSE 73379
// exit ;
73377: GO 73537
// tmp := array ;
73379: LD_ADDR_VAR 0 10
73383: PUSH
73384: LD_VAR 0 1
73388: ST_TO_ADDR
// for i = 1 to length do
73389: LD_ADDR_VAR 0 6
73393: PUSH
73394: DOUBLE
73395: LD_INT 1
73397: DEC
73398: ST_TO_ADDR
73399: LD_VAR 0 11
73403: PUSH
73404: FOR_TO
73405: IFFALSE 73525
// begin for j = 1 to array do
73407: LD_ADDR_VAR 0 7
73411: PUSH
73412: DOUBLE
73413: LD_INT 1
73415: DEC
73416: ST_TO_ADDR
73417: LD_VAR 0 1
73421: PUSH
73422: FOR_TO
73423: IFFALSE 73511
// begin k := j + d ;
73425: LD_ADDR_VAR 0 8
73429: PUSH
73430: LD_VAR 0 7
73434: PUSH
73435: LD_VAR 0 9
73439: PLUS
73440: ST_TO_ADDR
// if k > array then
73441: LD_VAR 0 8
73445: PUSH
73446: LD_VAR 0 1
73450: GREATER
73451: IFFALSE 73461
// k := 1 ;
73453: LD_ADDR_VAR 0 8
73457: PUSH
73458: LD_INT 1
73460: ST_TO_ADDR
// if not k then
73461: LD_VAR 0 8
73465: NOT
73466: IFFALSE 73478
// k := array ;
73468: LD_ADDR_VAR 0 8
73472: PUSH
73473: LD_VAR 0 1
73477: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
73478: LD_ADDR_VAR 0 10
73482: PUSH
73483: LD_VAR 0 10
73487: PPUSH
73488: LD_VAR 0 8
73492: PPUSH
73493: LD_VAR 0 1
73497: PUSH
73498: LD_VAR 0 7
73502: ARRAY
73503: PPUSH
73504: CALL_OW 1
73508: ST_TO_ADDR
// end ;
73509: GO 73422
73511: POP
73512: POP
// array := tmp ;
73513: LD_ADDR_VAR 0 1
73517: PUSH
73518: LD_VAR 0 10
73522: ST_TO_ADDR
// end ;
73523: GO 73404
73525: POP
73526: POP
// result := array ;
73527: LD_ADDR_VAR 0 5
73531: PUSH
73532: LD_VAR 0 1
73536: ST_TO_ADDR
// end ;
73537: LD_VAR 0 5
73541: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
73542: LD_INT 0
73544: PPUSH
73545: PPUSH
// result := 0 ;
73546: LD_ADDR_VAR 0 3
73550: PUSH
73551: LD_INT 0
73553: ST_TO_ADDR
// if not array or not value in array then
73554: LD_VAR 0 1
73558: NOT
73559: PUSH
73560: LD_VAR 0 2
73564: PUSH
73565: LD_VAR 0 1
73569: IN
73570: NOT
73571: OR
73572: IFFALSE 73576
// exit ;
73574: GO 73630
// for i = 1 to array do
73576: LD_ADDR_VAR 0 4
73580: PUSH
73581: DOUBLE
73582: LD_INT 1
73584: DEC
73585: ST_TO_ADDR
73586: LD_VAR 0 1
73590: PUSH
73591: FOR_TO
73592: IFFALSE 73628
// if value = array [ i ] then
73594: LD_VAR 0 2
73598: PUSH
73599: LD_VAR 0 1
73603: PUSH
73604: LD_VAR 0 4
73608: ARRAY
73609: EQUAL
73610: IFFALSE 73626
// begin result := i ;
73612: LD_ADDR_VAR 0 3
73616: PUSH
73617: LD_VAR 0 4
73621: ST_TO_ADDR
// exit ;
73622: POP
73623: POP
73624: GO 73630
// end ;
73626: GO 73591
73628: POP
73629: POP
// end ;
73630: LD_VAR 0 3
73634: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
73635: LD_INT 0
73637: PPUSH
// vc_chassis := chassis ;
73638: LD_ADDR_OWVAR 37
73642: PUSH
73643: LD_VAR 0 1
73647: ST_TO_ADDR
// vc_engine := engine ;
73648: LD_ADDR_OWVAR 39
73652: PUSH
73653: LD_VAR 0 2
73657: ST_TO_ADDR
// vc_control := control ;
73658: LD_ADDR_OWVAR 38
73662: PUSH
73663: LD_VAR 0 3
73667: ST_TO_ADDR
// vc_weapon := weapon ;
73668: LD_ADDR_OWVAR 40
73672: PUSH
73673: LD_VAR 0 4
73677: ST_TO_ADDR
// vc_fuel_battery := fuel ;
73678: LD_ADDR_OWVAR 41
73682: PUSH
73683: LD_VAR 0 5
73687: ST_TO_ADDR
// end ;
73688: LD_VAR 0 6
73692: RET
// export function WantPlant ( unit ) ; var task ; begin
73693: LD_INT 0
73695: PPUSH
73696: PPUSH
// result := false ;
73697: LD_ADDR_VAR 0 2
73701: PUSH
73702: LD_INT 0
73704: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
73705: LD_ADDR_VAR 0 3
73709: PUSH
73710: LD_VAR 0 1
73714: PPUSH
73715: CALL_OW 437
73719: ST_TO_ADDR
// if task then
73720: LD_VAR 0 3
73724: IFFALSE 73752
// if task [ 1 ] [ 1 ] = p then
73726: LD_VAR 0 3
73730: PUSH
73731: LD_INT 1
73733: ARRAY
73734: PUSH
73735: LD_INT 1
73737: ARRAY
73738: PUSH
73739: LD_STRING p
73741: EQUAL
73742: IFFALSE 73752
// result := true ;
73744: LD_ADDR_VAR 0 2
73748: PUSH
73749: LD_INT 1
73751: ST_TO_ADDR
// end ;
73752: LD_VAR 0 2
73756: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
73757: LD_INT 0
73759: PPUSH
73760: PPUSH
73761: PPUSH
73762: PPUSH
// if pos < 1 then
73763: LD_VAR 0 2
73767: PUSH
73768: LD_INT 1
73770: LESS
73771: IFFALSE 73775
// exit ;
73773: GO 74078
// if pos = 1 then
73775: LD_VAR 0 2
73779: PUSH
73780: LD_INT 1
73782: EQUAL
73783: IFFALSE 73816
// result := Replace ( arr , pos [ 1 ] , value ) else
73785: LD_ADDR_VAR 0 4
73789: PUSH
73790: LD_VAR 0 1
73794: PPUSH
73795: LD_VAR 0 2
73799: PUSH
73800: LD_INT 1
73802: ARRAY
73803: PPUSH
73804: LD_VAR 0 3
73808: PPUSH
73809: CALL_OW 1
73813: ST_TO_ADDR
73814: GO 74078
// begin tmp := arr ;
73816: LD_ADDR_VAR 0 6
73820: PUSH
73821: LD_VAR 0 1
73825: ST_TO_ADDR
// s_arr := [ tmp ] ;
73826: LD_ADDR_VAR 0 7
73830: PUSH
73831: LD_VAR 0 6
73835: PUSH
73836: EMPTY
73837: LIST
73838: ST_TO_ADDR
// for i = 1 to pos - 1 do
73839: LD_ADDR_VAR 0 5
73843: PUSH
73844: DOUBLE
73845: LD_INT 1
73847: DEC
73848: ST_TO_ADDR
73849: LD_VAR 0 2
73853: PUSH
73854: LD_INT 1
73856: MINUS
73857: PUSH
73858: FOR_TO
73859: IFFALSE 73904
// begin tmp := tmp [ pos [ i ] ] ;
73861: LD_ADDR_VAR 0 6
73865: PUSH
73866: LD_VAR 0 6
73870: PUSH
73871: LD_VAR 0 2
73875: PUSH
73876: LD_VAR 0 5
73880: ARRAY
73881: ARRAY
73882: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
73883: LD_ADDR_VAR 0 7
73887: PUSH
73888: LD_VAR 0 7
73892: PUSH
73893: LD_VAR 0 6
73897: PUSH
73898: EMPTY
73899: LIST
73900: ADD
73901: ST_TO_ADDR
// end ;
73902: GO 73858
73904: POP
73905: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
73906: LD_ADDR_VAR 0 6
73910: PUSH
73911: LD_VAR 0 6
73915: PPUSH
73916: LD_VAR 0 2
73920: PUSH
73921: LD_VAR 0 2
73925: ARRAY
73926: PPUSH
73927: LD_VAR 0 3
73931: PPUSH
73932: CALL_OW 1
73936: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
73937: LD_ADDR_VAR 0 7
73941: PUSH
73942: LD_VAR 0 7
73946: PPUSH
73947: LD_VAR 0 7
73951: PPUSH
73952: LD_VAR 0 6
73956: PPUSH
73957: CALL_OW 1
73961: ST_TO_ADDR
// for i = s_arr downto 2 do
73962: LD_ADDR_VAR 0 5
73966: PUSH
73967: DOUBLE
73968: LD_VAR 0 7
73972: INC
73973: ST_TO_ADDR
73974: LD_INT 2
73976: PUSH
73977: FOR_DOWNTO
73978: IFFALSE 74062
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
73980: LD_ADDR_VAR 0 6
73984: PUSH
73985: LD_VAR 0 7
73989: PUSH
73990: LD_VAR 0 5
73994: PUSH
73995: LD_INT 1
73997: MINUS
73998: ARRAY
73999: PPUSH
74000: LD_VAR 0 2
74004: PUSH
74005: LD_VAR 0 5
74009: PUSH
74010: LD_INT 1
74012: MINUS
74013: ARRAY
74014: PPUSH
74015: LD_VAR 0 7
74019: PUSH
74020: LD_VAR 0 5
74024: ARRAY
74025: PPUSH
74026: CALL_OW 1
74030: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74031: LD_ADDR_VAR 0 7
74035: PUSH
74036: LD_VAR 0 7
74040: PPUSH
74041: LD_VAR 0 5
74045: PUSH
74046: LD_INT 1
74048: MINUS
74049: PPUSH
74050: LD_VAR 0 6
74054: PPUSH
74055: CALL_OW 1
74059: ST_TO_ADDR
// end ;
74060: GO 73977
74062: POP
74063: POP
// result := s_arr [ 1 ] ;
74064: LD_ADDR_VAR 0 4
74068: PUSH
74069: LD_VAR 0 7
74073: PUSH
74074: LD_INT 1
74076: ARRAY
74077: ST_TO_ADDR
// end ; end ;
74078: LD_VAR 0 4
74082: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74083: LD_INT 0
74085: PPUSH
74086: PPUSH
// if not list then
74087: LD_VAR 0 1
74091: NOT
74092: IFFALSE 74096
// exit ;
74094: GO 74187
// i := list [ pos1 ] ;
74096: LD_ADDR_VAR 0 5
74100: PUSH
74101: LD_VAR 0 1
74105: PUSH
74106: LD_VAR 0 2
74110: ARRAY
74111: ST_TO_ADDR
// if not i then
74112: LD_VAR 0 5
74116: NOT
74117: IFFALSE 74121
// exit ;
74119: GO 74187
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74121: LD_ADDR_VAR 0 1
74125: PUSH
74126: LD_VAR 0 1
74130: PPUSH
74131: LD_VAR 0 2
74135: PPUSH
74136: LD_VAR 0 1
74140: PUSH
74141: LD_VAR 0 3
74145: ARRAY
74146: PPUSH
74147: CALL_OW 1
74151: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74152: LD_ADDR_VAR 0 1
74156: PUSH
74157: LD_VAR 0 1
74161: PPUSH
74162: LD_VAR 0 3
74166: PPUSH
74167: LD_VAR 0 5
74171: PPUSH
74172: CALL_OW 1
74176: ST_TO_ADDR
// result := list ;
74177: LD_ADDR_VAR 0 4
74181: PUSH
74182: LD_VAR 0 1
74186: ST_TO_ADDR
// end ;
74187: LD_VAR 0 4
74191: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74192: LD_INT 0
74194: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74195: LD_ADDR_VAR 0 5
74199: PUSH
74200: LD_VAR 0 1
74204: PPUSH
74205: CALL_OW 250
74209: PPUSH
74210: LD_VAR 0 1
74214: PPUSH
74215: CALL_OW 251
74219: PPUSH
74220: LD_VAR 0 2
74224: PPUSH
74225: LD_VAR 0 3
74229: PPUSH
74230: LD_VAR 0 4
74234: PPUSH
74235: CALL 74245 0 5
74239: ST_TO_ADDR
// end ;
74240: LD_VAR 0 5
74244: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
74245: LD_INT 0
74247: PPUSH
74248: PPUSH
74249: PPUSH
74250: PPUSH
// if not list then
74251: LD_VAR 0 3
74255: NOT
74256: IFFALSE 74260
// exit ;
74258: GO 74648
// result := [ ] ;
74260: LD_ADDR_VAR 0 6
74264: PUSH
74265: EMPTY
74266: ST_TO_ADDR
// for i in list do
74267: LD_ADDR_VAR 0 7
74271: PUSH
74272: LD_VAR 0 3
74276: PUSH
74277: FOR_IN
74278: IFFALSE 74480
// begin tmp := GetDistUnitXY ( i , x , y ) ;
74280: LD_ADDR_VAR 0 9
74284: PUSH
74285: LD_VAR 0 7
74289: PPUSH
74290: LD_VAR 0 1
74294: PPUSH
74295: LD_VAR 0 2
74299: PPUSH
74300: CALL_OW 297
74304: ST_TO_ADDR
// if not result then
74305: LD_VAR 0 6
74309: NOT
74310: IFFALSE 74336
// result := [ [ i , tmp ] ] else
74312: LD_ADDR_VAR 0 6
74316: PUSH
74317: LD_VAR 0 7
74321: PUSH
74322: LD_VAR 0 9
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: EMPTY
74332: LIST
74333: ST_TO_ADDR
74334: GO 74478
// begin if result [ result ] [ 2 ] < tmp then
74336: LD_VAR 0 6
74340: PUSH
74341: LD_VAR 0 6
74345: ARRAY
74346: PUSH
74347: LD_INT 2
74349: ARRAY
74350: PUSH
74351: LD_VAR 0 9
74355: LESS
74356: IFFALSE 74398
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
74358: LD_ADDR_VAR 0 6
74362: PUSH
74363: LD_VAR 0 6
74367: PPUSH
74368: LD_VAR 0 6
74372: PUSH
74373: LD_INT 1
74375: PLUS
74376: PPUSH
74377: LD_VAR 0 7
74381: PUSH
74382: LD_VAR 0 9
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PPUSH
74391: CALL_OW 2
74395: ST_TO_ADDR
74396: GO 74478
// for j = 1 to result do
74398: LD_ADDR_VAR 0 8
74402: PUSH
74403: DOUBLE
74404: LD_INT 1
74406: DEC
74407: ST_TO_ADDR
74408: LD_VAR 0 6
74412: PUSH
74413: FOR_TO
74414: IFFALSE 74476
// begin if tmp < result [ j ] [ 2 ] then
74416: LD_VAR 0 9
74420: PUSH
74421: LD_VAR 0 6
74425: PUSH
74426: LD_VAR 0 8
74430: ARRAY
74431: PUSH
74432: LD_INT 2
74434: ARRAY
74435: LESS
74436: IFFALSE 74474
// begin result := Insert ( result , j , [ i , tmp ] ) ;
74438: LD_ADDR_VAR 0 6
74442: PUSH
74443: LD_VAR 0 6
74447: PPUSH
74448: LD_VAR 0 8
74452: PPUSH
74453: LD_VAR 0 7
74457: PUSH
74458: LD_VAR 0 9
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PPUSH
74467: CALL_OW 2
74471: ST_TO_ADDR
// break ;
74472: GO 74476
// end ; end ;
74474: GO 74413
74476: POP
74477: POP
// end ; end ;
74478: GO 74277
74480: POP
74481: POP
// if result and not asc then
74482: LD_VAR 0 6
74486: PUSH
74487: LD_VAR 0 4
74491: NOT
74492: AND
74493: IFFALSE 74568
// begin tmp := result ;
74495: LD_ADDR_VAR 0 9
74499: PUSH
74500: LD_VAR 0 6
74504: ST_TO_ADDR
// for i = tmp downto 1 do
74505: LD_ADDR_VAR 0 7
74509: PUSH
74510: DOUBLE
74511: LD_VAR 0 9
74515: INC
74516: ST_TO_ADDR
74517: LD_INT 1
74519: PUSH
74520: FOR_DOWNTO
74521: IFFALSE 74566
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
74523: LD_ADDR_VAR 0 6
74527: PUSH
74528: LD_VAR 0 6
74532: PPUSH
74533: LD_VAR 0 9
74537: PUSH
74538: LD_VAR 0 7
74542: MINUS
74543: PUSH
74544: LD_INT 1
74546: PLUS
74547: PPUSH
74548: LD_VAR 0 9
74552: PUSH
74553: LD_VAR 0 7
74557: ARRAY
74558: PPUSH
74559: CALL_OW 1
74563: ST_TO_ADDR
74564: GO 74520
74566: POP
74567: POP
// end ; tmp := [ ] ;
74568: LD_ADDR_VAR 0 9
74572: PUSH
74573: EMPTY
74574: ST_TO_ADDR
// if mode then
74575: LD_VAR 0 5
74579: IFFALSE 74648
// begin for i = 1 to result do
74581: LD_ADDR_VAR 0 7
74585: PUSH
74586: DOUBLE
74587: LD_INT 1
74589: DEC
74590: ST_TO_ADDR
74591: LD_VAR 0 6
74595: PUSH
74596: FOR_TO
74597: IFFALSE 74636
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
74599: LD_ADDR_VAR 0 9
74603: PUSH
74604: LD_VAR 0 9
74608: PPUSH
74609: LD_VAR 0 7
74613: PPUSH
74614: LD_VAR 0 6
74618: PUSH
74619: LD_VAR 0 7
74623: ARRAY
74624: PUSH
74625: LD_INT 1
74627: ARRAY
74628: PPUSH
74629: CALL_OW 1
74633: ST_TO_ADDR
74634: GO 74596
74636: POP
74637: POP
// result := tmp ;
74638: LD_ADDR_VAR 0 6
74642: PUSH
74643: LD_VAR 0 9
74647: ST_TO_ADDR
// end ; end ;
74648: LD_VAR 0 6
74652: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
74653: LD_INT 0
74655: PPUSH
74656: PPUSH
74657: PPUSH
74658: PPUSH
74659: PPUSH
74660: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
74661: LD_ADDR_VAR 0 5
74665: PUSH
74666: LD_INT 0
74668: PUSH
74669: LD_INT 0
74671: PUSH
74672: LD_INT 0
74674: PUSH
74675: EMPTY
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: ST_TO_ADDR
// if not x or not y then
74683: LD_VAR 0 2
74687: NOT
74688: PUSH
74689: LD_VAR 0 3
74693: NOT
74694: OR
74695: IFFALSE 74699
// exit ;
74697: GO 76349
// if not range then
74699: LD_VAR 0 4
74703: NOT
74704: IFFALSE 74714
// range := 10 ;
74706: LD_ADDR_VAR 0 4
74710: PUSH
74711: LD_INT 10
74713: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
74714: LD_ADDR_VAR 0 8
74718: PUSH
74719: LD_INT 81
74721: PUSH
74722: LD_VAR 0 1
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 92
74733: PUSH
74734: LD_VAR 0 2
74738: PUSH
74739: LD_VAR 0 3
74743: PUSH
74744: LD_VAR 0 4
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: PUSH
74755: LD_INT 3
74757: PUSH
74758: LD_INT 21
74760: PUSH
74761: LD_INT 3
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: LIST
74776: PPUSH
74777: CALL_OW 69
74781: ST_TO_ADDR
// if not tmp then
74782: LD_VAR 0 8
74786: NOT
74787: IFFALSE 74791
// exit ;
74789: GO 76349
// for i in tmp do
74791: LD_ADDR_VAR 0 6
74795: PUSH
74796: LD_VAR 0 8
74800: PUSH
74801: FOR_IN
74802: IFFALSE 76324
// begin points := [ 0 , 0 , 0 ] ;
74804: LD_ADDR_VAR 0 9
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: LD_INT 0
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: LIST
74822: ST_TO_ADDR
// bpoints := 1 ;
74823: LD_ADDR_VAR 0 10
74827: PUSH
74828: LD_INT 1
74830: ST_TO_ADDR
// case GetType ( i ) of unit_human :
74831: LD_VAR 0 6
74835: PPUSH
74836: CALL_OW 247
74840: PUSH
74841: LD_INT 1
74843: DOUBLE
74844: EQUAL
74845: IFTRUE 74849
74847: GO 75427
74849: POP
// begin if GetClass ( i ) = 1 then
74850: LD_VAR 0 6
74854: PPUSH
74855: CALL_OW 257
74859: PUSH
74860: LD_INT 1
74862: EQUAL
74863: IFFALSE 74884
// points := [ 10 , 5 , 3 ] ;
74865: LD_ADDR_VAR 0 9
74869: PUSH
74870: LD_INT 10
74872: PUSH
74873: LD_INT 5
74875: PUSH
74876: LD_INT 3
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: LIST
74883: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
74884: LD_VAR 0 6
74888: PPUSH
74889: CALL_OW 257
74893: PUSH
74894: LD_INT 2
74896: PUSH
74897: LD_INT 3
74899: PUSH
74900: LD_INT 4
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: LIST
74907: IN
74908: IFFALSE 74929
// points := [ 3 , 2 , 1 ] ;
74910: LD_ADDR_VAR 0 9
74914: PUSH
74915: LD_INT 3
74917: PUSH
74918: LD_INT 2
74920: PUSH
74921: LD_INT 1
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: LIST
74928: ST_TO_ADDR
// if GetClass ( i ) = 5 then
74929: LD_VAR 0 6
74933: PPUSH
74934: CALL_OW 257
74938: PUSH
74939: LD_INT 5
74941: EQUAL
74942: IFFALSE 74963
// points := [ 130 , 5 , 2 ] ;
74944: LD_ADDR_VAR 0 9
74948: PUSH
74949: LD_INT 130
74951: PUSH
74952: LD_INT 5
74954: PUSH
74955: LD_INT 2
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: LIST
74962: ST_TO_ADDR
// if GetClass ( i ) = 8 then
74963: LD_VAR 0 6
74967: PPUSH
74968: CALL_OW 257
74972: PUSH
74973: LD_INT 8
74975: EQUAL
74976: IFFALSE 74997
// points := [ 35 , 35 , 30 ] ;
74978: LD_ADDR_VAR 0 9
74982: PUSH
74983: LD_INT 35
74985: PUSH
74986: LD_INT 35
74988: PUSH
74989: LD_INT 30
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: LIST
74996: ST_TO_ADDR
// if GetClass ( i ) = 9 then
74997: LD_VAR 0 6
75001: PPUSH
75002: CALL_OW 257
75006: PUSH
75007: LD_INT 9
75009: EQUAL
75010: IFFALSE 75031
// points := [ 20 , 55 , 40 ] ;
75012: LD_ADDR_VAR 0 9
75016: PUSH
75017: LD_INT 20
75019: PUSH
75020: LD_INT 55
75022: PUSH
75023: LD_INT 40
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: LIST
75030: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
75031: LD_VAR 0 6
75035: PPUSH
75036: CALL_OW 257
75040: PUSH
75041: LD_INT 12
75043: PUSH
75044: LD_INT 16
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: IN
75051: IFFALSE 75072
// points := [ 5 , 3 , 2 ] ;
75053: LD_ADDR_VAR 0 9
75057: PUSH
75058: LD_INT 5
75060: PUSH
75061: LD_INT 3
75063: PUSH
75064: LD_INT 2
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: LIST
75071: ST_TO_ADDR
// if GetClass ( i ) = 17 then
75072: LD_VAR 0 6
75076: PPUSH
75077: CALL_OW 257
75081: PUSH
75082: LD_INT 17
75084: EQUAL
75085: IFFALSE 75106
// points := [ 100 , 50 , 75 ] ;
75087: LD_ADDR_VAR 0 9
75091: PUSH
75092: LD_INT 100
75094: PUSH
75095: LD_INT 50
75097: PUSH
75098: LD_INT 75
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: LIST
75105: ST_TO_ADDR
// if GetClass ( i ) = 15 then
75106: LD_VAR 0 6
75110: PPUSH
75111: CALL_OW 257
75115: PUSH
75116: LD_INT 15
75118: EQUAL
75119: IFFALSE 75140
// points := [ 10 , 5 , 3 ] ;
75121: LD_ADDR_VAR 0 9
75125: PUSH
75126: LD_INT 10
75128: PUSH
75129: LD_INT 5
75131: PUSH
75132: LD_INT 3
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: LIST
75139: ST_TO_ADDR
// if GetClass ( i ) = 14 then
75140: LD_VAR 0 6
75144: PPUSH
75145: CALL_OW 257
75149: PUSH
75150: LD_INT 14
75152: EQUAL
75153: IFFALSE 75174
// points := [ 10 , 0 , 0 ] ;
75155: LD_ADDR_VAR 0 9
75159: PUSH
75160: LD_INT 10
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: LIST
75173: ST_TO_ADDR
// if GetClass ( i ) = 11 then
75174: LD_VAR 0 6
75178: PPUSH
75179: CALL_OW 257
75183: PUSH
75184: LD_INT 11
75186: EQUAL
75187: IFFALSE 75208
// points := [ 30 , 10 , 5 ] ;
75189: LD_ADDR_VAR 0 9
75193: PUSH
75194: LD_INT 30
75196: PUSH
75197: LD_INT 10
75199: PUSH
75200: LD_INT 5
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: LIST
75207: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
75208: LD_VAR 0 1
75212: PPUSH
75213: LD_INT 5
75215: PPUSH
75216: CALL_OW 321
75220: PUSH
75221: LD_INT 2
75223: EQUAL
75224: IFFALSE 75241
// bpoints := bpoints * 1.8 ;
75226: LD_ADDR_VAR 0 10
75230: PUSH
75231: LD_VAR 0 10
75235: PUSH
75236: LD_REAL  1.80000000000000E+0000
75239: MUL
75240: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
75241: LD_VAR 0 6
75245: PPUSH
75246: CALL_OW 257
75250: PUSH
75251: LD_INT 1
75253: PUSH
75254: LD_INT 2
75256: PUSH
75257: LD_INT 3
75259: PUSH
75260: LD_INT 4
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: IN
75269: PUSH
75270: LD_VAR 0 1
75274: PPUSH
75275: LD_INT 51
75277: PPUSH
75278: CALL_OW 321
75282: PUSH
75283: LD_INT 2
75285: EQUAL
75286: AND
75287: IFFALSE 75304
// bpoints := bpoints * 1.2 ;
75289: LD_ADDR_VAR 0 10
75293: PUSH
75294: LD_VAR 0 10
75298: PUSH
75299: LD_REAL  1.20000000000000E+0000
75302: MUL
75303: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
75304: LD_VAR 0 6
75308: PPUSH
75309: CALL_OW 257
75313: PUSH
75314: LD_INT 5
75316: PUSH
75317: LD_INT 7
75319: PUSH
75320: LD_INT 9
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: LIST
75327: IN
75328: PUSH
75329: LD_VAR 0 1
75333: PPUSH
75334: LD_INT 52
75336: PPUSH
75337: CALL_OW 321
75341: PUSH
75342: LD_INT 2
75344: EQUAL
75345: AND
75346: IFFALSE 75363
// bpoints := bpoints * 1.5 ;
75348: LD_ADDR_VAR 0 10
75352: PUSH
75353: LD_VAR 0 10
75357: PUSH
75358: LD_REAL  1.50000000000000E+0000
75361: MUL
75362: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
75363: LD_VAR 0 1
75367: PPUSH
75368: LD_INT 66
75370: PPUSH
75371: CALL_OW 321
75375: PUSH
75376: LD_INT 2
75378: EQUAL
75379: IFFALSE 75396
// bpoints := bpoints * 1.1 ;
75381: LD_ADDR_VAR 0 10
75385: PUSH
75386: LD_VAR 0 10
75390: PUSH
75391: LD_REAL  1.10000000000000E+0000
75394: MUL
75395: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
75396: LD_ADDR_VAR 0 10
75400: PUSH
75401: LD_VAR 0 10
75405: PUSH
75406: LD_VAR 0 6
75410: PPUSH
75411: LD_INT 1
75413: PPUSH
75414: CALL_OW 259
75418: PUSH
75419: LD_REAL  1.15000000000000E+0000
75422: MUL
75423: MUL
75424: ST_TO_ADDR
// end ; unit_vehicle :
75425: GO 76253
75427: LD_INT 2
75429: DOUBLE
75430: EQUAL
75431: IFTRUE 75435
75433: GO 76241
75435: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
75436: LD_VAR 0 6
75440: PPUSH
75441: CALL_OW 264
75445: PUSH
75446: LD_INT 2
75448: PUSH
75449: LD_INT 42
75451: PUSH
75452: LD_INT 24
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: LIST
75459: IN
75460: IFFALSE 75481
// points := [ 25 , 5 , 3 ] ;
75462: LD_ADDR_VAR 0 9
75466: PUSH
75467: LD_INT 25
75469: PUSH
75470: LD_INT 5
75472: PUSH
75473: LD_INT 3
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: LIST
75480: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
75481: LD_VAR 0 6
75485: PPUSH
75486: CALL_OW 264
75490: PUSH
75491: LD_INT 4
75493: PUSH
75494: LD_INT 43
75496: PUSH
75497: LD_INT 25
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: LIST
75504: IN
75505: IFFALSE 75526
// points := [ 40 , 15 , 5 ] ;
75507: LD_ADDR_VAR 0 9
75511: PUSH
75512: LD_INT 40
75514: PUSH
75515: LD_INT 15
75517: PUSH
75518: LD_INT 5
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: LIST
75525: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
75526: LD_VAR 0 6
75530: PPUSH
75531: CALL_OW 264
75535: PUSH
75536: LD_INT 3
75538: PUSH
75539: LD_INT 23
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: IN
75546: IFFALSE 75567
// points := [ 7 , 25 , 8 ] ;
75548: LD_ADDR_VAR 0 9
75552: PUSH
75553: LD_INT 7
75555: PUSH
75556: LD_INT 25
75558: PUSH
75559: LD_INT 8
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: LIST
75566: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
75567: LD_VAR 0 6
75571: PPUSH
75572: CALL_OW 264
75576: PUSH
75577: LD_INT 5
75579: PUSH
75580: LD_INT 27
75582: PUSH
75583: LD_INT 44
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: LIST
75590: IN
75591: IFFALSE 75612
// points := [ 14 , 50 , 16 ] ;
75593: LD_ADDR_VAR 0 9
75597: PUSH
75598: LD_INT 14
75600: PUSH
75601: LD_INT 50
75603: PUSH
75604: LD_INT 16
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: LIST
75611: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
75612: LD_VAR 0 6
75616: PPUSH
75617: CALL_OW 264
75621: PUSH
75622: LD_INT 6
75624: PUSH
75625: LD_INT 46
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: IN
75632: IFFALSE 75653
// points := [ 32 , 120 , 70 ] ;
75634: LD_ADDR_VAR 0 9
75638: PUSH
75639: LD_INT 32
75641: PUSH
75642: LD_INT 120
75644: PUSH
75645: LD_INT 70
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: LIST
75652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
75653: LD_VAR 0 6
75657: PPUSH
75658: CALL_OW 264
75662: PUSH
75663: LD_INT 7
75665: PUSH
75666: LD_INT 28
75668: PUSH
75669: LD_INT 45
75671: PUSH
75672: LD_INT 92
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: LIST
75679: LIST
75680: IN
75681: IFFALSE 75702
// points := [ 35 , 20 , 45 ] ;
75683: LD_ADDR_VAR 0 9
75687: PUSH
75688: LD_INT 35
75690: PUSH
75691: LD_INT 20
75693: PUSH
75694: LD_INT 45
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: LIST
75701: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
75702: LD_VAR 0 6
75706: PPUSH
75707: CALL_OW 264
75711: PUSH
75712: LD_INT 47
75714: PUSH
75715: EMPTY
75716: LIST
75717: IN
75718: IFFALSE 75739
// points := [ 67 , 45 , 75 ] ;
75720: LD_ADDR_VAR 0 9
75724: PUSH
75725: LD_INT 67
75727: PUSH
75728: LD_INT 45
75730: PUSH
75731: LD_INT 75
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: LIST
75738: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
75739: LD_VAR 0 6
75743: PPUSH
75744: CALL_OW 264
75748: PUSH
75749: LD_INT 26
75751: PUSH
75752: EMPTY
75753: LIST
75754: IN
75755: IFFALSE 75776
// points := [ 120 , 30 , 80 ] ;
75757: LD_ADDR_VAR 0 9
75761: PUSH
75762: LD_INT 120
75764: PUSH
75765: LD_INT 30
75767: PUSH
75768: LD_INT 80
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: LIST
75775: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
75776: LD_VAR 0 6
75780: PPUSH
75781: CALL_OW 264
75785: PUSH
75786: LD_INT 22
75788: PUSH
75789: EMPTY
75790: LIST
75791: IN
75792: IFFALSE 75813
// points := [ 40 , 1 , 1 ] ;
75794: LD_ADDR_VAR 0 9
75798: PUSH
75799: LD_INT 40
75801: PUSH
75802: LD_INT 1
75804: PUSH
75805: LD_INT 1
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: LIST
75812: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
75813: LD_VAR 0 6
75817: PPUSH
75818: CALL_OW 264
75822: PUSH
75823: LD_INT 29
75825: PUSH
75826: EMPTY
75827: LIST
75828: IN
75829: IFFALSE 75850
// points := [ 70 , 200 , 400 ] ;
75831: LD_ADDR_VAR 0 9
75835: PUSH
75836: LD_INT 70
75838: PUSH
75839: LD_INT 200
75841: PUSH
75842: LD_INT 400
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: LIST
75849: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
75850: LD_VAR 0 6
75854: PPUSH
75855: CALL_OW 264
75859: PUSH
75860: LD_INT 14
75862: PUSH
75863: LD_INT 53
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: IN
75870: IFFALSE 75891
// points := [ 40 , 10 , 20 ] ;
75872: LD_ADDR_VAR 0 9
75876: PUSH
75877: LD_INT 40
75879: PUSH
75880: LD_INT 10
75882: PUSH
75883: LD_INT 20
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: LIST
75890: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
75891: LD_VAR 0 6
75895: PPUSH
75896: CALL_OW 264
75900: PUSH
75901: LD_INT 9
75903: PUSH
75904: EMPTY
75905: LIST
75906: IN
75907: IFFALSE 75928
// points := [ 5 , 70 , 20 ] ;
75909: LD_ADDR_VAR 0 9
75913: PUSH
75914: LD_INT 5
75916: PUSH
75917: LD_INT 70
75919: PUSH
75920: LD_INT 20
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: LIST
75927: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
75928: LD_VAR 0 6
75932: PPUSH
75933: CALL_OW 264
75937: PUSH
75938: LD_INT 10
75940: PUSH
75941: EMPTY
75942: LIST
75943: IN
75944: IFFALSE 75965
// points := [ 35 , 110 , 70 ] ;
75946: LD_ADDR_VAR 0 9
75950: PUSH
75951: LD_INT 35
75953: PUSH
75954: LD_INT 110
75956: PUSH
75957: LD_INT 70
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: LIST
75964: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
75965: LD_VAR 0 6
75969: PPUSH
75970: CALL_OW 265
75974: PUSH
75975: LD_INT 25
75977: EQUAL
75978: IFFALSE 75999
// points := [ 80 , 65 , 100 ] ;
75980: LD_ADDR_VAR 0 9
75984: PUSH
75985: LD_INT 80
75987: PUSH
75988: LD_INT 65
75990: PUSH
75991: LD_INT 100
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: LIST
75998: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
75999: LD_VAR 0 6
76003: PPUSH
76004: CALL_OW 263
76008: PUSH
76009: LD_INT 1
76011: EQUAL
76012: IFFALSE 76047
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
76014: LD_ADDR_VAR 0 10
76018: PUSH
76019: LD_VAR 0 10
76023: PUSH
76024: LD_VAR 0 6
76028: PPUSH
76029: CALL_OW 311
76033: PPUSH
76034: LD_INT 3
76036: PPUSH
76037: CALL_OW 259
76041: PUSH
76042: LD_INT 4
76044: MUL
76045: MUL
76046: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
76047: LD_VAR 0 6
76051: PPUSH
76052: CALL_OW 263
76056: PUSH
76057: LD_INT 2
76059: EQUAL
76060: IFFALSE 76111
// begin j := IsControledBy ( i ) ;
76062: LD_ADDR_VAR 0 7
76066: PUSH
76067: LD_VAR 0 6
76071: PPUSH
76072: CALL_OW 312
76076: ST_TO_ADDR
// if j then
76077: LD_VAR 0 7
76081: IFFALSE 76111
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
76083: LD_ADDR_VAR 0 10
76087: PUSH
76088: LD_VAR 0 10
76092: PUSH
76093: LD_VAR 0 7
76097: PPUSH
76098: LD_INT 3
76100: PPUSH
76101: CALL_OW 259
76105: PUSH
76106: LD_INT 3
76108: MUL
76109: MUL
76110: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
76111: LD_VAR 0 6
76115: PPUSH
76116: CALL_OW 264
76120: PUSH
76121: LD_INT 5
76123: PUSH
76124: LD_INT 6
76126: PUSH
76127: LD_INT 46
76129: PUSH
76130: LD_INT 44
76132: PUSH
76133: LD_INT 47
76135: PUSH
76136: LD_INT 45
76138: PUSH
76139: LD_INT 28
76141: PUSH
76142: LD_INT 7
76144: PUSH
76145: LD_INT 27
76147: PUSH
76148: LD_INT 29
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: LIST
76162: IN
76163: PUSH
76164: LD_VAR 0 1
76168: PPUSH
76169: LD_INT 52
76171: PPUSH
76172: CALL_OW 321
76176: PUSH
76177: LD_INT 2
76179: EQUAL
76180: AND
76181: IFFALSE 76198
// bpoints := bpoints * 1.2 ;
76183: LD_ADDR_VAR 0 10
76187: PUSH
76188: LD_VAR 0 10
76192: PUSH
76193: LD_REAL  1.20000000000000E+0000
76196: MUL
76197: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
76198: LD_VAR 0 6
76202: PPUSH
76203: CALL_OW 264
76207: PUSH
76208: LD_INT 6
76210: PUSH
76211: LD_INT 46
76213: PUSH
76214: LD_INT 47
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: LIST
76221: IN
76222: IFFALSE 76239
// bpoints := bpoints * 1.2 ;
76224: LD_ADDR_VAR 0 10
76228: PUSH
76229: LD_VAR 0 10
76233: PUSH
76234: LD_REAL  1.20000000000000E+0000
76237: MUL
76238: ST_TO_ADDR
// end ; unit_building :
76239: GO 76253
76241: LD_INT 3
76243: DOUBLE
76244: EQUAL
76245: IFTRUE 76249
76247: GO 76252
76249: POP
// ; end ;
76250: GO 76253
76252: POP
// for j = 1 to 3 do
76253: LD_ADDR_VAR 0 7
76257: PUSH
76258: DOUBLE
76259: LD_INT 1
76261: DEC
76262: ST_TO_ADDR
76263: LD_INT 3
76265: PUSH
76266: FOR_TO
76267: IFFALSE 76320
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
76269: LD_ADDR_VAR 0 5
76273: PUSH
76274: LD_VAR 0 5
76278: PPUSH
76279: LD_VAR 0 7
76283: PPUSH
76284: LD_VAR 0 5
76288: PUSH
76289: LD_VAR 0 7
76293: ARRAY
76294: PUSH
76295: LD_VAR 0 9
76299: PUSH
76300: LD_VAR 0 7
76304: ARRAY
76305: PUSH
76306: LD_VAR 0 10
76310: MUL
76311: PLUS
76312: PPUSH
76313: CALL_OW 1
76317: ST_TO_ADDR
76318: GO 76266
76320: POP
76321: POP
// end ;
76322: GO 74801
76324: POP
76325: POP
// result := Replace ( result , 4 , tmp ) ;
76326: LD_ADDR_VAR 0 5
76330: PUSH
76331: LD_VAR 0 5
76335: PPUSH
76336: LD_INT 4
76338: PPUSH
76339: LD_VAR 0 8
76343: PPUSH
76344: CALL_OW 1
76348: ST_TO_ADDR
// end ;
76349: LD_VAR 0 5
76353: RET
// export function DangerAtRange ( unit , range ) ; begin
76354: LD_INT 0
76356: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
76357: LD_ADDR_VAR 0 3
76361: PUSH
76362: LD_VAR 0 1
76366: PPUSH
76367: CALL_OW 255
76371: PPUSH
76372: LD_VAR 0 1
76376: PPUSH
76377: CALL_OW 250
76381: PPUSH
76382: LD_VAR 0 1
76386: PPUSH
76387: CALL_OW 251
76391: PPUSH
76392: LD_VAR 0 2
76396: PPUSH
76397: CALL 74653 0 4
76401: ST_TO_ADDR
// end ;
76402: LD_VAR 0 3
76406: RET
// export function DangerInArea ( side , area ) ; begin
76407: LD_INT 0
76409: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
76410: LD_ADDR_VAR 0 3
76414: PUSH
76415: LD_VAR 0 2
76419: PPUSH
76420: LD_INT 81
76422: PUSH
76423: LD_VAR 0 1
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PPUSH
76432: CALL_OW 70
76436: ST_TO_ADDR
// end ;
76437: LD_VAR 0 3
76441: RET
// export function IsExtension ( b ) ; begin
76442: LD_INT 0
76444: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
76445: LD_ADDR_VAR 0 2
76449: PUSH
76450: LD_VAR 0 1
76454: PUSH
76455: LD_INT 23
76457: PUSH
76458: LD_INT 20
76460: PUSH
76461: LD_INT 22
76463: PUSH
76464: LD_INT 17
76466: PUSH
76467: LD_INT 24
76469: PUSH
76470: LD_INT 21
76472: PUSH
76473: LD_INT 19
76475: PUSH
76476: LD_INT 16
76478: PUSH
76479: LD_INT 25
76481: PUSH
76482: LD_INT 18
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: IN
76497: ST_TO_ADDR
// end ;
76498: LD_VAR 0 2
76502: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
76503: LD_INT 0
76505: PPUSH
76506: PPUSH
76507: PPUSH
// result := [ ] ;
76508: LD_ADDR_VAR 0 4
76512: PUSH
76513: EMPTY
76514: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
76515: LD_ADDR_VAR 0 5
76519: PUSH
76520: LD_VAR 0 2
76524: PPUSH
76525: LD_INT 21
76527: PUSH
76528: LD_INT 3
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PPUSH
76535: CALL_OW 70
76539: ST_TO_ADDR
// if not tmp then
76540: LD_VAR 0 5
76544: NOT
76545: IFFALSE 76549
// exit ;
76547: GO 76613
// if checkLink then
76549: LD_VAR 0 3
76553: IFFALSE 76603
// begin for i in tmp do
76555: LD_ADDR_VAR 0 6
76559: PUSH
76560: LD_VAR 0 5
76564: PUSH
76565: FOR_IN
76566: IFFALSE 76601
// if GetBase ( i ) <> base then
76568: LD_VAR 0 6
76572: PPUSH
76573: CALL_OW 274
76577: PUSH
76578: LD_VAR 0 1
76582: NONEQUAL
76583: IFFALSE 76599
// ComLinkToBase ( base , i ) ;
76585: LD_VAR 0 1
76589: PPUSH
76590: LD_VAR 0 6
76594: PPUSH
76595: CALL_OW 169
76599: GO 76565
76601: POP
76602: POP
// end ; result := tmp ;
76603: LD_ADDR_VAR 0 4
76607: PUSH
76608: LD_VAR 0 5
76612: ST_TO_ADDR
// end ;
76613: LD_VAR 0 4
76617: RET
// export function ComComplete ( units , b ) ; var i ; begin
76618: LD_INT 0
76620: PPUSH
76621: PPUSH
// if not units then
76622: LD_VAR 0 1
76626: NOT
76627: IFFALSE 76631
// exit ;
76629: GO 76721
// for i in units do
76631: LD_ADDR_VAR 0 4
76635: PUSH
76636: LD_VAR 0 1
76640: PUSH
76641: FOR_IN
76642: IFFALSE 76719
// if BuildingStatus ( b ) = bs_build then
76644: LD_VAR 0 2
76648: PPUSH
76649: CALL_OW 461
76653: PUSH
76654: LD_INT 1
76656: EQUAL
76657: IFFALSE 76717
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
76659: LD_VAR 0 4
76663: PPUSH
76664: LD_STRING h
76666: PUSH
76667: LD_VAR 0 2
76671: PPUSH
76672: CALL_OW 250
76676: PUSH
76677: LD_VAR 0 2
76681: PPUSH
76682: CALL_OW 251
76686: PUSH
76687: LD_VAR 0 2
76691: PUSH
76692: LD_INT 0
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: PUSH
76710: EMPTY
76711: LIST
76712: PPUSH
76713: CALL_OW 446
76717: GO 76641
76719: POP
76720: POP
// end ;
76721: LD_VAR 0 3
76725: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
76726: LD_INT 0
76728: PPUSH
76729: PPUSH
76730: PPUSH
76731: PPUSH
76732: PPUSH
76733: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
76734: LD_VAR 0 1
76738: NOT
76739: PUSH
76740: LD_VAR 0 1
76744: PPUSH
76745: CALL_OW 263
76749: PUSH
76750: LD_INT 2
76752: NONEQUAL
76753: OR
76754: IFFALSE 76758
// exit ;
76756: GO 77074
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
76758: LD_ADDR_VAR 0 6
76762: PUSH
76763: LD_INT 22
76765: PUSH
76766: LD_VAR 0 1
76770: PPUSH
76771: CALL_OW 255
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 2
76782: PUSH
76783: LD_INT 30
76785: PUSH
76786: LD_INT 36
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 34
76795: PUSH
76796: LD_INT 31
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: LIST
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PPUSH
76812: CALL_OW 69
76816: ST_TO_ADDR
// if not tmp then
76817: LD_VAR 0 6
76821: NOT
76822: IFFALSE 76826
// exit ;
76824: GO 77074
// result := [ ] ;
76826: LD_ADDR_VAR 0 2
76830: PUSH
76831: EMPTY
76832: ST_TO_ADDR
// for i in tmp do
76833: LD_ADDR_VAR 0 3
76837: PUSH
76838: LD_VAR 0 6
76842: PUSH
76843: FOR_IN
76844: IFFALSE 76915
// begin t := UnitsInside ( i ) ;
76846: LD_ADDR_VAR 0 4
76850: PUSH
76851: LD_VAR 0 3
76855: PPUSH
76856: CALL_OW 313
76860: ST_TO_ADDR
// if t then
76861: LD_VAR 0 4
76865: IFFALSE 76913
// for j in t do
76867: LD_ADDR_VAR 0 7
76871: PUSH
76872: LD_VAR 0 4
76876: PUSH
76877: FOR_IN
76878: IFFALSE 76911
// result := Replace ( result , result + 1 , j ) ;
76880: LD_ADDR_VAR 0 2
76884: PUSH
76885: LD_VAR 0 2
76889: PPUSH
76890: LD_VAR 0 2
76894: PUSH
76895: LD_INT 1
76897: PLUS
76898: PPUSH
76899: LD_VAR 0 7
76903: PPUSH
76904: CALL_OW 1
76908: ST_TO_ADDR
76909: GO 76877
76911: POP
76912: POP
// end ;
76913: GO 76843
76915: POP
76916: POP
// if not result then
76917: LD_VAR 0 2
76921: NOT
76922: IFFALSE 76926
// exit ;
76924: GO 77074
// mech := result [ 1 ] ;
76926: LD_ADDR_VAR 0 5
76930: PUSH
76931: LD_VAR 0 2
76935: PUSH
76936: LD_INT 1
76938: ARRAY
76939: ST_TO_ADDR
// if result > 1 then
76940: LD_VAR 0 2
76944: PUSH
76945: LD_INT 1
76947: GREATER
76948: IFFALSE 77060
// begin for i = 2 to result do
76950: LD_ADDR_VAR 0 3
76954: PUSH
76955: DOUBLE
76956: LD_INT 2
76958: DEC
76959: ST_TO_ADDR
76960: LD_VAR 0 2
76964: PUSH
76965: FOR_TO
76966: IFFALSE 77058
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
76968: LD_ADDR_VAR 0 4
76972: PUSH
76973: LD_VAR 0 2
76977: PUSH
76978: LD_VAR 0 3
76982: ARRAY
76983: PPUSH
76984: LD_INT 3
76986: PPUSH
76987: CALL_OW 259
76991: PUSH
76992: LD_VAR 0 2
76996: PUSH
76997: LD_VAR 0 3
77001: ARRAY
77002: PPUSH
77003: CALL_OW 432
77007: MINUS
77008: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
77009: LD_VAR 0 4
77013: PUSH
77014: LD_VAR 0 5
77018: PPUSH
77019: LD_INT 3
77021: PPUSH
77022: CALL_OW 259
77026: PUSH
77027: LD_VAR 0 5
77031: PPUSH
77032: CALL_OW 432
77036: MINUS
77037: GREATEREQUAL
77038: IFFALSE 77056
// mech := result [ i ] ;
77040: LD_ADDR_VAR 0 5
77044: PUSH
77045: LD_VAR 0 2
77049: PUSH
77050: LD_VAR 0 3
77054: ARRAY
77055: ST_TO_ADDR
// end ;
77056: GO 76965
77058: POP
77059: POP
// end ; ComLinkTo ( vehicle , mech ) ;
77060: LD_VAR 0 1
77064: PPUSH
77065: LD_VAR 0 5
77069: PPUSH
77070: CALL_OW 135
// end ;
77074: LD_VAR 0 2
77078: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
77079: LD_INT 0
77081: PPUSH
77082: PPUSH
77083: PPUSH
77084: PPUSH
77085: PPUSH
77086: PPUSH
77087: PPUSH
77088: PPUSH
77089: PPUSH
77090: PPUSH
77091: PPUSH
77092: PPUSH
77093: PPUSH
// result := [ ] ;
77094: LD_ADDR_VAR 0 7
77098: PUSH
77099: EMPTY
77100: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
77101: LD_VAR 0 1
77105: PPUSH
77106: CALL_OW 266
77110: PUSH
77111: LD_INT 0
77113: PUSH
77114: LD_INT 1
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: IN
77121: NOT
77122: IFFALSE 77126
// exit ;
77124: GO 78760
// if name then
77126: LD_VAR 0 3
77130: IFFALSE 77146
// SetBName ( base_dep , name ) ;
77132: LD_VAR 0 1
77136: PPUSH
77137: LD_VAR 0 3
77141: PPUSH
77142: CALL_OW 500
// base := GetBase ( base_dep ) ;
77146: LD_ADDR_VAR 0 15
77150: PUSH
77151: LD_VAR 0 1
77155: PPUSH
77156: CALL_OW 274
77160: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
77161: LD_ADDR_VAR 0 16
77165: PUSH
77166: LD_VAR 0 1
77170: PPUSH
77171: CALL_OW 255
77175: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
77176: LD_ADDR_VAR 0 17
77180: PUSH
77181: LD_VAR 0 1
77185: PPUSH
77186: CALL_OW 248
77190: ST_TO_ADDR
// if sources then
77191: LD_VAR 0 5
77195: IFFALSE 77242
// for i = 1 to 3 do
77197: LD_ADDR_VAR 0 8
77201: PUSH
77202: DOUBLE
77203: LD_INT 1
77205: DEC
77206: ST_TO_ADDR
77207: LD_INT 3
77209: PUSH
77210: FOR_TO
77211: IFFALSE 77240
// AddResourceType ( base , i , sources [ i ] ) ;
77213: LD_VAR 0 15
77217: PPUSH
77218: LD_VAR 0 8
77222: PPUSH
77223: LD_VAR 0 5
77227: PUSH
77228: LD_VAR 0 8
77232: ARRAY
77233: PPUSH
77234: CALL_OW 276
77238: GO 77210
77240: POP
77241: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
77242: LD_ADDR_VAR 0 18
77246: PUSH
77247: LD_VAR 0 15
77251: PPUSH
77252: LD_VAR 0 2
77256: PPUSH
77257: LD_INT 1
77259: PPUSH
77260: CALL 76503 0 3
77264: ST_TO_ADDR
// InitHc ;
77265: CALL_OW 19
// InitUc ;
77269: CALL_OW 18
// uc_side := side ;
77273: LD_ADDR_OWVAR 20
77277: PUSH
77278: LD_VAR 0 16
77282: ST_TO_ADDR
// uc_nation := nation ;
77283: LD_ADDR_OWVAR 21
77287: PUSH
77288: LD_VAR 0 17
77292: ST_TO_ADDR
// if buildings then
77293: LD_VAR 0 18
77297: IFFALSE 78619
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
77299: LD_ADDR_VAR 0 19
77303: PUSH
77304: LD_VAR 0 18
77308: PPUSH
77309: LD_INT 2
77311: PUSH
77312: LD_INT 30
77314: PUSH
77315: LD_INT 29
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 30
77324: PUSH
77325: LD_INT 30
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: LIST
77336: PPUSH
77337: CALL_OW 72
77341: ST_TO_ADDR
// if tmp then
77342: LD_VAR 0 19
77346: IFFALSE 77394
// for i in tmp do
77348: LD_ADDR_VAR 0 8
77352: PUSH
77353: LD_VAR 0 19
77357: PUSH
77358: FOR_IN
77359: IFFALSE 77392
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
77361: LD_VAR 0 8
77365: PPUSH
77366: CALL_OW 250
77370: PPUSH
77371: LD_VAR 0 8
77375: PPUSH
77376: CALL_OW 251
77380: PPUSH
77381: LD_VAR 0 16
77385: PPUSH
77386: CALL_OW 441
77390: GO 77358
77392: POP
77393: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
77394: LD_VAR 0 18
77398: PPUSH
77399: LD_INT 2
77401: PUSH
77402: LD_INT 30
77404: PUSH
77405: LD_INT 32
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 30
77414: PUSH
77415: LD_INT 33
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: LIST
77426: PPUSH
77427: CALL_OW 72
77431: IFFALSE 77519
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
77433: LD_ADDR_VAR 0 8
77437: PUSH
77438: LD_VAR 0 18
77442: PPUSH
77443: LD_INT 2
77445: PUSH
77446: LD_INT 30
77448: PUSH
77449: LD_INT 32
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 30
77458: PUSH
77459: LD_INT 33
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: LIST
77470: PPUSH
77471: CALL_OW 72
77475: PUSH
77476: FOR_IN
77477: IFFALSE 77517
// begin if not GetBWeapon ( i ) then
77479: LD_VAR 0 8
77483: PPUSH
77484: CALL_OW 269
77488: NOT
77489: IFFALSE 77515
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
77491: LD_VAR 0 8
77495: PPUSH
77496: LD_VAR 0 8
77500: PPUSH
77501: LD_VAR 0 2
77505: PPUSH
77506: CALL 78765 0 2
77510: PPUSH
77511: CALL_OW 431
// end ;
77515: GO 77476
77517: POP
77518: POP
// end ; for i = 1 to personel do
77519: LD_ADDR_VAR 0 8
77523: PUSH
77524: DOUBLE
77525: LD_INT 1
77527: DEC
77528: ST_TO_ADDR
77529: LD_VAR 0 6
77533: PUSH
77534: FOR_TO
77535: IFFALSE 78599
// begin if i > 4 then
77537: LD_VAR 0 8
77541: PUSH
77542: LD_INT 4
77544: GREATER
77545: IFFALSE 77549
// break ;
77547: GO 78599
// case i of 1 :
77549: LD_VAR 0 8
77553: PUSH
77554: LD_INT 1
77556: DOUBLE
77557: EQUAL
77558: IFTRUE 77562
77560: GO 77642
77562: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
77563: LD_ADDR_VAR 0 12
77567: PUSH
77568: LD_VAR 0 18
77572: PPUSH
77573: LD_INT 22
77575: PUSH
77576: LD_VAR 0 16
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 58
77587: PUSH
77588: EMPTY
77589: LIST
77590: PUSH
77591: LD_INT 2
77593: PUSH
77594: LD_INT 30
77596: PUSH
77597: LD_INT 32
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 30
77606: PUSH
77607: LD_INT 4
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 30
77616: PUSH
77617: LD_INT 5
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: LIST
77634: PPUSH
77635: CALL_OW 72
77639: ST_TO_ADDR
77640: GO 77864
77642: LD_INT 2
77644: DOUBLE
77645: EQUAL
77646: IFTRUE 77650
77648: GO 77712
77650: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
77651: LD_ADDR_VAR 0 12
77655: PUSH
77656: LD_VAR 0 18
77660: PPUSH
77661: LD_INT 22
77663: PUSH
77664: LD_VAR 0 16
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 2
77675: PUSH
77676: LD_INT 30
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 30
77688: PUSH
77689: LD_INT 1
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: LIST
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PPUSH
77705: CALL_OW 72
77709: ST_TO_ADDR
77710: GO 77864
77712: LD_INT 3
77714: DOUBLE
77715: EQUAL
77716: IFTRUE 77720
77718: GO 77782
77720: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
77721: LD_ADDR_VAR 0 12
77725: PUSH
77726: LD_VAR 0 18
77730: PPUSH
77731: LD_INT 22
77733: PUSH
77734: LD_VAR 0 16
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 2
77745: PUSH
77746: LD_INT 30
77748: PUSH
77749: LD_INT 2
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 30
77758: PUSH
77759: LD_INT 3
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: LIST
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PPUSH
77775: CALL_OW 72
77779: ST_TO_ADDR
77780: GO 77864
77782: LD_INT 4
77784: DOUBLE
77785: EQUAL
77786: IFTRUE 77790
77788: GO 77863
77790: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
77791: LD_ADDR_VAR 0 12
77795: PUSH
77796: LD_VAR 0 18
77800: PPUSH
77801: LD_INT 22
77803: PUSH
77804: LD_VAR 0 16
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 2
77815: PUSH
77816: LD_INT 30
77818: PUSH
77819: LD_INT 6
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 30
77828: PUSH
77829: LD_INT 7
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 30
77838: PUSH
77839: LD_INT 8
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PPUSH
77856: CALL_OW 72
77860: ST_TO_ADDR
77861: GO 77864
77863: POP
// if i = 1 then
77864: LD_VAR 0 8
77868: PUSH
77869: LD_INT 1
77871: EQUAL
77872: IFFALSE 77983
// begin tmp := [ ] ;
77874: LD_ADDR_VAR 0 19
77878: PUSH
77879: EMPTY
77880: ST_TO_ADDR
// for j in f do
77881: LD_ADDR_VAR 0 9
77885: PUSH
77886: LD_VAR 0 12
77890: PUSH
77891: FOR_IN
77892: IFFALSE 77965
// if GetBType ( j ) = b_bunker then
77894: LD_VAR 0 9
77898: PPUSH
77899: CALL_OW 266
77903: PUSH
77904: LD_INT 32
77906: EQUAL
77907: IFFALSE 77934
// tmp := Insert ( tmp , 1 , j ) else
77909: LD_ADDR_VAR 0 19
77913: PUSH
77914: LD_VAR 0 19
77918: PPUSH
77919: LD_INT 1
77921: PPUSH
77922: LD_VAR 0 9
77926: PPUSH
77927: CALL_OW 2
77931: ST_TO_ADDR
77932: GO 77963
// tmp := Insert ( tmp , tmp + 1 , j ) ;
77934: LD_ADDR_VAR 0 19
77938: PUSH
77939: LD_VAR 0 19
77943: PPUSH
77944: LD_VAR 0 19
77948: PUSH
77949: LD_INT 1
77951: PLUS
77952: PPUSH
77953: LD_VAR 0 9
77957: PPUSH
77958: CALL_OW 2
77962: ST_TO_ADDR
77963: GO 77891
77965: POP
77966: POP
// if tmp then
77967: LD_VAR 0 19
77971: IFFALSE 77983
// f := tmp ;
77973: LD_ADDR_VAR 0 12
77977: PUSH
77978: LD_VAR 0 19
77982: ST_TO_ADDR
// end ; x := personel [ i ] ;
77983: LD_ADDR_VAR 0 13
77987: PUSH
77988: LD_VAR 0 6
77992: PUSH
77993: LD_VAR 0 8
77997: ARRAY
77998: ST_TO_ADDR
// if x = - 1 then
77999: LD_VAR 0 13
78003: PUSH
78004: LD_INT 1
78006: NEG
78007: EQUAL
78008: IFFALSE 78217
// begin for j in f do
78010: LD_ADDR_VAR 0 9
78014: PUSH
78015: LD_VAR 0 12
78019: PUSH
78020: FOR_IN
78021: IFFALSE 78213
// repeat InitHc ;
78023: CALL_OW 19
// if GetBType ( j ) = b_barracks then
78027: LD_VAR 0 9
78031: PPUSH
78032: CALL_OW 266
78036: PUSH
78037: LD_INT 5
78039: EQUAL
78040: IFFALSE 78110
// begin if UnitsInside ( j ) < 3 then
78042: LD_VAR 0 9
78046: PPUSH
78047: CALL_OW 313
78051: PUSH
78052: LD_INT 3
78054: LESS
78055: IFFALSE 78091
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
78057: LD_INT 0
78059: PPUSH
78060: LD_INT 5
78062: PUSH
78063: LD_INT 8
78065: PUSH
78066: LD_INT 9
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: LIST
78073: PUSH
78074: LD_VAR 0 17
78078: ARRAY
78079: PPUSH
78080: LD_VAR 0 4
78084: PPUSH
78085: CALL_OW 380
78089: GO 78108
// PrepareHuman ( false , i , skill ) ;
78091: LD_INT 0
78093: PPUSH
78094: LD_VAR 0 8
78098: PPUSH
78099: LD_VAR 0 4
78103: PPUSH
78104: CALL_OW 380
// end else
78108: GO 78127
// PrepareHuman ( false , i , skill ) ;
78110: LD_INT 0
78112: PPUSH
78113: LD_VAR 0 8
78117: PPUSH
78118: LD_VAR 0 4
78122: PPUSH
78123: CALL_OW 380
// un := CreateHuman ;
78127: LD_ADDR_VAR 0 14
78131: PUSH
78132: CALL_OW 44
78136: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78137: LD_ADDR_VAR 0 7
78141: PUSH
78142: LD_VAR 0 7
78146: PPUSH
78147: LD_INT 1
78149: PPUSH
78150: LD_VAR 0 14
78154: PPUSH
78155: CALL_OW 2
78159: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
78160: LD_VAR 0 14
78164: PPUSH
78165: LD_VAR 0 9
78169: PPUSH
78170: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
78174: LD_VAR 0 9
78178: PPUSH
78179: CALL_OW 313
78183: PUSH
78184: LD_INT 6
78186: EQUAL
78187: PUSH
78188: LD_VAR 0 9
78192: PPUSH
78193: CALL_OW 266
78197: PUSH
78198: LD_INT 32
78200: PUSH
78201: LD_INT 31
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: IN
78208: OR
78209: IFFALSE 78023
78211: GO 78020
78213: POP
78214: POP
// end else
78215: GO 78597
// for j = 1 to x do
78217: LD_ADDR_VAR 0 9
78221: PUSH
78222: DOUBLE
78223: LD_INT 1
78225: DEC
78226: ST_TO_ADDR
78227: LD_VAR 0 13
78231: PUSH
78232: FOR_TO
78233: IFFALSE 78595
// begin InitHc ;
78235: CALL_OW 19
// if not f then
78239: LD_VAR 0 12
78243: NOT
78244: IFFALSE 78333
// begin PrepareHuman ( false , i , skill ) ;
78246: LD_INT 0
78248: PPUSH
78249: LD_VAR 0 8
78253: PPUSH
78254: LD_VAR 0 4
78258: PPUSH
78259: CALL_OW 380
// un := CreateHuman ;
78263: LD_ADDR_VAR 0 14
78267: PUSH
78268: CALL_OW 44
78272: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78273: LD_ADDR_VAR 0 7
78277: PUSH
78278: LD_VAR 0 7
78282: PPUSH
78283: LD_INT 1
78285: PPUSH
78286: LD_VAR 0 14
78290: PPUSH
78291: CALL_OW 2
78295: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78296: LD_VAR 0 14
78300: PPUSH
78301: LD_VAR 0 1
78305: PPUSH
78306: CALL_OW 250
78310: PPUSH
78311: LD_VAR 0 1
78315: PPUSH
78316: CALL_OW 251
78320: PPUSH
78321: LD_INT 10
78323: PPUSH
78324: LD_INT 0
78326: PPUSH
78327: CALL_OW 50
// continue ;
78331: GO 78232
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
78333: LD_VAR 0 12
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: PPUSH
78342: CALL_OW 313
78346: PUSH
78347: LD_VAR 0 12
78351: PUSH
78352: LD_INT 1
78354: ARRAY
78355: PPUSH
78356: CALL_OW 266
78360: PUSH
78361: LD_INT 32
78363: PUSH
78364: LD_INT 31
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: IN
78371: AND
78372: PUSH
78373: LD_VAR 0 12
78377: PUSH
78378: LD_INT 1
78380: ARRAY
78381: PPUSH
78382: CALL_OW 313
78386: PUSH
78387: LD_INT 6
78389: EQUAL
78390: OR
78391: IFFALSE 78411
// f := Delete ( f , 1 ) ;
78393: LD_ADDR_VAR 0 12
78397: PUSH
78398: LD_VAR 0 12
78402: PPUSH
78403: LD_INT 1
78405: PPUSH
78406: CALL_OW 3
78410: ST_TO_ADDR
// if not f then
78411: LD_VAR 0 12
78415: NOT
78416: IFFALSE 78434
// begin x := x + 2 ;
78418: LD_ADDR_VAR 0 13
78422: PUSH
78423: LD_VAR 0 13
78427: PUSH
78428: LD_INT 2
78430: PLUS
78431: ST_TO_ADDR
// continue ;
78432: GO 78232
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
78434: LD_VAR 0 12
78438: PUSH
78439: LD_INT 1
78441: ARRAY
78442: PPUSH
78443: CALL_OW 266
78447: PUSH
78448: LD_INT 5
78450: EQUAL
78451: IFFALSE 78525
// begin if UnitsInside ( f [ 1 ] ) < 3 then
78453: LD_VAR 0 12
78457: PUSH
78458: LD_INT 1
78460: ARRAY
78461: PPUSH
78462: CALL_OW 313
78466: PUSH
78467: LD_INT 3
78469: LESS
78470: IFFALSE 78506
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
78472: LD_INT 0
78474: PPUSH
78475: LD_INT 5
78477: PUSH
78478: LD_INT 8
78480: PUSH
78481: LD_INT 9
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: LIST
78488: PUSH
78489: LD_VAR 0 17
78493: ARRAY
78494: PPUSH
78495: LD_VAR 0 4
78499: PPUSH
78500: CALL_OW 380
78504: GO 78523
// PrepareHuman ( false , i , skill ) ;
78506: LD_INT 0
78508: PPUSH
78509: LD_VAR 0 8
78513: PPUSH
78514: LD_VAR 0 4
78518: PPUSH
78519: CALL_OW 380
// end else
78523: GO 78542
// PrepareHuman ( false , i , skill ) ;
78525: LD_INT 0
78527: PPUSH
78528: LD_VAR 0 8
78532: PPUSH
78533: LD_VAR 0 4
78537: PPUSH
78538: CALL_OW 380
// un := CreateHuman ;
78542: LD_ADDR_VAR 0 14
78546: PUSH
78547: CALL_OW 44
78551: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78552: LD_ADDR_VAR 0 7
78556: PUSH
78557: LD_VAR 0 7
78561: PPUSH
78562: LD_INT 1
78564: PPUSH
78565: LD_VAR 0 14
78569: PPUSH
78570: CALL_OW 2
78574: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
78575: LD_VAR 0 14
78579: PPUSH
78580: LD_VAR 0 12
78584: PUSH
78585: LD_INT 1
78587: ARRAY
78588: PPUSH
78589: CALL_OW 52
// end ;
78593: GO 78232
78595: POP
78596: POP
// end ;
78597: GO 77534
78599: POP
78600: POP
// result := result ^ buildings ;
78601: LD_ADDR_VAR 0 7
78605: PUSH
78606: LD_VAR 0 7
78610: PUSH
78611: LD_VAR 0 18
78615: ADD
78616: ST_TO_ADDR
// end else
78617: GO 78760
// begin for i = 1 to personel do
78619: LD_ADDR_VAR 0 8
78623: PUSH
78624: DOUBLE
78625: LD_INT 1
78627: DEC
78628: ST_TO_ADDR
78629: LD_VAR 0 6
78633: PUSH
78634: FOR_TO
78635: IFFALSE 78758
// begin if i > 4 then
78637: LD_VAR 0 8
78641: PUSH
78642: LD_INT 4
78644: GREATER
78645: IFFALSE 78649
// break ;
78647: GO 78758
// x := personel [ i ] ;
78649: LD_ADDR_VAR 0 13
78653: PUSH
78654: LD_VAR 0 6
78658: PUSH
78659: LD_VAR 0 8
78663: ARRAY
78664: ST_TO_ADDR
// if x = - 1 then
78665: LD_VAR 0 13
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: EQUAL
78674: IFFALSE 78678
// continue ;
78676: GO 78634
// PrepareHuman ( false , i , skill ) ;
78678: LD_INT 0
78680: PPUSH
78681: LD_VAR 0 8
78685: PPUSH
78686: LD_VAR 0 4
78690: PPUSH
78691: CALL_OW 380
// un := CreateHuman ;
78695: LD_ADDR_VAR 0 14
78699: PUSH
78700: CALL_OW 44
78704: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78705: LD_VAR 0 14
78709: PPUSH
78710: LD_VAR 0 1
78714: PPUSH
78715: CALL_OW 250
78719: PPUSH
78720: LD_VAR 0 1
78724: PPUSH
78725: CALL_OW 251
78729: PPUSH
78730: LD_INT 10
78732: PPUSH
78733: LD_INT 0
78735: PPUSH
78736: CALL_OW 50
// result := result ^ un ;
78740: LD_ADDR_VAR 0 7
78744: PUSH
78745: LD_VAR 0 7
78749: PUSH
78750: LD_VAR 0 14
78754: ADD
78755: ST_TO_ADDR
// end ;
78756: GO 78634
78758: POP
78759: POP
// end ; end ;
78760: LD_VAR 0 7
78764: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
78765: LD_INT 0
78767: PPUSH
78768: PPUSH
78769: PPUSH
78770: PPUSH
78771: PPUSH
78772: PPUSH
78773: PPUSH
78774: PPUSH
78775: PPUSH
78776: PPUSH
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
78781: PPUSH
78782: PPUSH
// result := false ;
78783: LD_ADDR_VAR 0 3
78787: PUSH
78788: LD_INT 0
78790: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
78791: LD_VAR 0 1
78795: NOT
78796: PUSH
78797: LD_VAR 0 1
78801: PPUSH
78802: CALL_OW 266
78806: PUSH
78807: LD_INT 32
78809: PUSH
78810: LD_INT 33
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: IN
78817: NOT
78818: OR
78819: IFFALSE 78823
// exit ;
78821: GO 79932
// nat := GetNation ( tower ) ;
78823: LD_ADDR_VAR 0 12
78827: PUSH
78828: LD_VAR 0 1
78832: PPUSH
78833: CALL_OW 248
78837: ST_TO_ADDR
// side := GetSide ( tower ) ;
78838: LD_ADDR_VAR 0 16
78842: PUSH
78843: LD_VAR 0 1
78847: PPUSH
78848: CALL_OW 255
78852: ST_TO_ADDR
// x := GetX ( tower ) ;
78853: LD_ADDR_VAR 0 10
78857: PUSH
78858: LD_VAR 0 1
78862: PPUSH
78863: CALL_OW 250
78867: ST_TO_ADDR
// y := GetY ( tower ) ;
78868: LD_ADDR_VAR 0 11
78872: PUSH
78873: LD_VAR 0 1
78877: PPUSH
78878: CALL_OW 251
78882: ST_TO_ADDR
// if not x or not y then
78883: LD_VAR 0 10
78887: NOT
78888: PUSH
78889: LD_VAR 0 11
78893: NOT
78894: OR
78895: IFFALSE 78899
// exit ;
78897: GO 79932
// weapon := 0 ;
78899: LD_ADDR_VAR 0 18
78903: PUSH
78904: LD_INT 0
78906: ST_TO_ADDR
// fac_list := [ ] ;
78907: LD_ADDR_VAR 0 17
78911: PUSH
78912: EMPTY
78913: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
78914: LD_ADDR_VAR 0 6
78918: PUSH
78919: LD_VAR 0 1
78923: PPUSH
78924: CALL_OW 274
78928: PPUSH
78929: LD_VAR 0 2
78933: PPUSH
78934: LD_INT 0
78936: PPUSH
78937: CALL 76503 0 3
78941: PPUSH
78942: LD_INT 30
78944: PUSH
78945: LD_INT 3
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PPUSH
78952: CALL_OW 72
78956: ST_TO_ADDR
// if not factories then
78957: LD_VAR 0 6
78961: NOT
78962: IFFALSE 78966
// exit ;
78964: GO 79932
// for i in factories do
78966: LD_ADDR_VAR 0 8
78970: PUSH
78971: LD_VAR 0 6
78975: PUSH
78976: FOR_IN
78977: IFFALSE 79002
// fac_list := fac_list union AvailableWeaponList ( i ) ;
78979: LD_ADDR_VAR 0 17
78983: PUSH
78984: LD_VAR 0 17
78988: PUSH
78989: LD_VAR 0 8
78993: PPUSH
78994: CALL_OW 478
78998: UNION
78999: ST_TO_ADDR
79000: GO 78976
79002: POP
79003: POP
// if not fac_list then
79004: LD_VAR 0 17
79008: NOT
79009: IFFALSE 79013
// exit ;
79011: GO 79932
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
79013: LD_ADDR_VAR 0 5
79017: PUSH
79018: LD_INT 4
79020: PUSH
79021: LD_INT 5
79023: PUSH
79024: LD_INT 9
79026: PUSH
79027: LD_INT 10
79029: PUSH
79030: LD_INT 6
79032: PUSH
79033: LD_INT 7
79035: PUSH
79036: LD_INT 11
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: LIST
79043: LIST
79044: LIST
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 27
79050: PUSH
79051: LD_INT 28
79053: PUSH
79054: LD_INT 26
79056: PUSH
79057: LD_INT 30
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: PUSH
79066: LD_INT 43
79068: PUSH
79069: LD_INT 44
79071: PUSH
79072: LD_INT 46
79074: PUSH
79075: LD_INT 45
79077: PUSH
79078: LD_INT 47
79080: PUSH
79081: LD_INT 49
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: LIST
79096: PUSH
79097: LD_VAR 0 12
79101: ARRAY
79102: ST_TO_ADDR
// list := list isect fac_list ;
79103: LD_ADDR_VAR 0 5
79107: PUSH
79108: LD_VAR 0 5
79112: PUSH
79113: LD_VAR 0 17
79117: ISECT
79118: ST_TO_ADDR
// if not list then
79119: LD_VAR 0 5
79123: NOT
79124: IFFALSE 79128
// exit ;
79126: GO 79932
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
79128: LD_VAR 0 12
79132: PUSH
79133: LD_INT 3
79135: EQUAL
79136: PUSH
79137: LD_INT 49
79139: PUSH
79140: LD_VAR 0 5
79144: IN
79145: AND
79146: PUSH
79147: LD_INT 31
79149: PPUSH
79150: LD_VAR 0 16
79154: PPUSH
79155: CALL_OW 321
79159: PUSH
79160: LD_INT 2
79162: EQUAL
79163: AND
79164: IFFALSE 79224
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
79166: LD_INT 22
79168: PUSH
79169: LD_VAR 0 16
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 35
79180: PUSH
79181: LD_INT 49
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 91
79190: PUSH
79191: LD_VAR 0 1
79195: PUSH
79196: LD_INT 10
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: LIST
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: LIST
79208: PPUSH
79209: CALL_OW 69
79213: NOT
79214: IFFALSE 79224
// weapon := ru_time_lapser ;
79216: LD_ADDR_VAR 0 18
79220: PUSH
79221: LD_INT 49
79223: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
79224: LD_VAR 0 12
79228: PUSH
79229: LD_INT 1
79231: PUSH
79232: LD_INT 2
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: IN
79239: PUSH
79240: LD_INT 11
79242: PUSH
79243: LD_VAR 0 5
79247: IN
79248: PUSH
79249: LD_INT 30
79251: PUSH
79252: LD_VAR 0 5
79256: IN
79257: OR
79258: AND
79259: PUSH
79260: LD_INT 6
79262: PPUSH
79263: LD_VAR 0 16
79267: PPUSH
79268: CALL_OW 321
79272: PUSH
79273: LD_INT 2
79275: EQUAL
79276: AND
79277: IFFALSE 79442
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
79279: LD_INT 22
79281: PUSH
79282: LD_VAR 0 16
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 2
79293: PUSH
79294: LD_INT 35
79296: PUSH
79297: LD_INT 11
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: PUSH
79304: LD_INT 35
79306: PUSH
79307: LD_INT 30
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 91
79321: PUSH
79322: LD_VAR 0 1
79326: PUSH
79327: LD_INT 18
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: LIST
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: LIST
79339: PPUSH
79340: CALL_OW 69
79344: NOT
79345: PUSH
79346: LD_INT 22
79348: PUSH
79349: LD_VAR 0 16
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 2
79360: PUSH
79361: LD_INT 30
79363: PUSH
79364: LD_INT 32
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 30
79373: PUSH
79374: LD_INT 33
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 91
79388: PUSH
79389: LD_VAR 0 1
79393: PUSH
79394: LD_INT 12
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: LIST
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: LIST
79406: PUSH
79407: EMPTY
79408: LIST
79409: PPUSH
79410: CALL_OW 69
79414: PUSH
79415: LD_INT 2
79417: GREATER
79418: AND
79419: IFFALSE 79442
// weapon := [ us_radar , ar_radar ] [ nat ] ;
79421: LD_ADDR_VAR 0 18
79425: PUSH
79426: LD_INT 11
79428: PUSH
79429: LD_INT 30
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_VAR 0 12
79440: ARRAY
79441: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
79442: LD_VAR 0 18
79446: NOT
79447: PUSH
79448: LD_INT 40
79450: PPUSH
79451: LD_VAR 0 16
79455: PPUSH
79456: CALL_OW 321
79460: PUSH
79461: LD_INT 2
79463: EQUAL
79464: AND
79465: PUSH
79466: LD_INT 7
79468: PUSH
79469: LD_VAR 0 5
79473: IN
79474: PUSH
79475: LD_INT 28
79477: PUSH
79478: LD_VAR 0 5
79482: IN
79483: OR
79484: PUSH
79485: LD_INT 45
79487: PUSH
79488: LD_VAR 0 5
79492: IN
79493: OR
79494: AND
79495: IFFALSE 79749
// begin hex := GetHexInfo ( x , y ) ;
79497: LD_ADDR_VAR 0 4
79501: PUSH
79502: LD_VAR 0 10
79506: PPUSH
79507: LD_VAR 0 11
79511: PPUSH
79512: CALL_OW 546
79516: ST_TO_ADDR
// if hex [ 1 ] then
79517: LD_VAR 0 4
79521: PUSH
79522: LD_INT 1
79524: ARRAY
79525: IFFALSE 79529
// exit ;
79527: GO 79932
// height := hex [ 2 ] ;
79529: LD_ADDR_VAR 0 15
79533: PUSH
79534: LD_VAR 0 4
79538: PUSH
79539: LD_INT 2
79541: ARRAY
79542: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
79543: LD_ADDR_VAR 0 14
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: LD_INT 2
79553: PUSH
79554: LD_INT 3
79556: PUSH
79557: LD_INT 5
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: ST_TO_ADDR
// for i in tmp do
79566: LD_ADDR_VAR 0 8
79570: PUSH
79571: LD_VAR 0 14
79575: PUSH
79576: FOR_IN
79577: IFFALSE 79747
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
79579: LD_ADDR_VAR 0 9
79583: PUSH
79584: LD_VAR 0 10
79588: PPUSH
79589: LD_VAR 0 8
79593: PPUSH
79594: LD_INT 5
79596: PPUSH
79597: CALL_OW 272
79601: PUSH
79602: LD_VAR 0 11
79606: PPUSH
79607: LD_VAR 0 8
79611: PPUSH
79612: LD_INT 5
79614: PPUSH
79615: CALL_OW 273
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79624: LD_VAR 0 9
79628: PUSH
79629: LD_INT 1
79631: ARRAY
79632: PPUSH
79633: LD_VAR 0 9
79637: PUSH
79638: LD_INT 2
79640: ARRAY
79641: PPUSH
79642: CALL_OW 488
79646: IFFALSE 79745
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
79648: LD_ADDR_VAR 0 4
79652: PUSH
79653: LD_VAR 0 9
79657: PUSH
79658: LD_INT 1
79660: ARRAY
79661: PPUSH
79662: LD_VAR 0 9
79666: PUSH
79667: LD_INT 2
79669: ARRAY
79670: PPUSH
79671: CALL_OW 546
79675: ST_TO_ADDR
// if hex [ 1 ] then
79676: LD_VAR 0 4
79680: PUSH
79681: LD_INT 1
79683: ARRAY
79684: IFFALSE 79688
// continue ;
79686: GO 79576
// h := hex [ 2 ] ;
79688: LD_ADDR_VAR 0 13
79692: PUSH
79693: LD_VAR 0 4
79697: PUSH
79698: LD_INT 2
79700: ARRAY
79701: ST_TO_ADDR
// if h + 7 < height then
79702: LD_VAR 0 13
79706: PUSH
79707: LD_INT 7
79709: PLUS
79710: PUSH
79711: LD_VAR 0 15
79715: LESS
79716: IFFALSE 79745
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
79718: LD_ADDR_VAR 0 18
79722: PUSH
79723: LD_INT 7
79725: PUSH
79726: LD_INT 28
79728: PUSH
79729: LD_INT 45
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: LIST
79736: PUSH
79737: LD_VAR 0 12
79741: ARRAY
79742: ST_TO_ADDR
// break ;
79743: GO 79747
// end ; end ; end ;
79745: GO 79576
79747: POP
79748: POP
// end ; if not weapon then
79749: LD_VAR 0 18
79753: NOT
79754: IFFALSE 79814
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
79756: LD_ADDR_VAR 0 5
79760: PUSH
79761: LD_VAR 0 5
79765: PUSH
79766: LD_INT 11
79768: PUSH
79769: LD_INT 30
79771: PUSH
79772: LD_INT 49
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: LIST
79779: DIFF
79780: ST_TO_ADDR
// if not list then
79781: LD_VAR 0 5
79785: NOT
79786: IFFALSE 79790
// exit ;
79788: GO 79932
// weapon := list [ rand ( 1 , list ) ] ;
79790: LD_ADDR_VAR 0 18
79794: PUSH
79795: LD_VAR 0 5
79799: PUSH
79800: LD_INT 1
79802: PPUSH
79803: LD_VAR 0 5
79807: PPUSH
79808: CALL_OW 12
79812: ARRAY
79813: ST_TO_ADDR
// end ; if weapon then
79814: LD_VAR 0 18
79818: IFFALSE 79932
// begin tmp := CostOfWeapon ( weapon ) ;
79820: LD_ADDR_VAR 0 14
79824: PUSH
79825: LD_VAR 0 18
79829: PPUSH
79830: CALL_OW 451
79834: ST_TO_ADDR
// j := GetBase ( tower ) ;
79835: LD_ADDR_VAR 0 9
79839: PUSH
79840: LD_VAR 0 1
79844: PPUSH
79845: CALL_OW 274
79849: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
79850: LD_VAR 0 9
79854: PPUSH
79855: LD_INT 1
79857: PPUSH
79858: CALL_OW 275
79862: PUSH
79863: LD_VAR 0 14
79867: PUSH
79868: LD_INT 1
79870: ARRAY
79871: GREATEREQUAL
79872: PUSH
79873: LD_VAR 0 9
79877: PPUSH
79878: LD_INT 2
79880: PPUSH
79881: CALL_OW 275
79885: PUSH
79886: LD_VAR 0 14
79890: PUSH
79891: LD_INT 2
79893: ARRAY
79894: GREATEREQUAL
79895: AND
79896: PUSH
79897: LD_VAR 0 9
79901: PPUSH
79902: LD_INT 3
79904: PPUSH
79905: CALL_OW 275
79909: PUSH
79910: LD_VAR 0 14
79914: PUSH
79915: LD_INT 3
79917: ARRAY
79918: GREATEREQUAL
79919: AND
79920: IFFALSE 79932
// result := weapon ;
79922: LD_ADDR_VAR 0 3
79926: PUSH
79927: LD_VAR 0 18
79931: ST_TO_ADDR
// end ; end ;
79932: LD_VAR 0 3
79936: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
79937: LD_INT 0
79939: PPUSH
79940: PPUSH
// result := true ;
79941: LD_ADDR_VAR 0 3
79945: PUSH
79946: LD_INT 1
79948: ST_TO_ADDR
// if array1 = array2 then
79949: LD_VAR 0 1
79953: PUSH
79954: LD_VAR 0 2
79958: EQUAL
79959: IFFALSE 80019
// begin for i = 1 to array1 do
79961: LD_ADDR_VAR 0 4
79965: PUSH
79966: DOUBLE
79967: LD_INT 1
79969: DEC
79970: ST_TO_ADDR
79971: LD_VAR 0 1
79975: PUSH
79976: FOR_TO
79977: IFFALSE 80015
// if array1 [ i ] <> array2 [ i ] then
79979: LD_VAR 0 1
79983: PUSH
79984: LD_VAR 0 4
79988: ARRAY
79989: PUSH
79990: LD_VAR 0 2
79994: PUSH
79995: LD_VAR 0 4
79999: ARRAY
80000: NONEQUAL
80001: IFFALSE 80013
// begin result := false ;
80003: LD_ADDR_VAR 0 3
80007: PUSH
80008: LD_INT 0
80010: ST_TO_ADDR
// break ;
80011: GO 80015
// end ;
80013: GO 79976
80015: POP
80016: POP
// end else
80017: GO 80027
// result := false ;
80019: LD_ADDR_VAR 0 3
80023: PUSH
80024: LD_INT 0
80026: ST_TO_ADDR
// end ;
80027: LD_VAR 0 3
80031: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
80032: LD_INT 0
80034: PPUSH
80035: PPUSH
// if not array1 or not array2 then
80036: LD_VAR 0 1
80040: NOT
80041: PUSH
80042: LD_VAR 0 2
80046: NOT
80047: OR
80048: IFFALSE 80052
// exit ;
80050: GO 80116
// result := true ;
80052: LD_ADDR_VAR 0 3
80056: PUSH
80057: LD_INT 1
80059: ST_TO_ADDR
// for i = 1 to array1 do
80060: LD_ADDR_VAR 0 4
80064: PUSH
80065: DOUBLE
80066: LD_INT 1
80068: DEC
80069: ST_TO_ADDR
80070: LD_VAR 0 1
80074: PUSH
80075: FOR_TO
80076: IFFALSE 80114
// if array1 [ i ] <> array2 [ i ] then
80078: LD_VAR 0 1
80082: PUSH
80083: LD_VAR 0 4
80087: ARRAY
80088: PUSH
80089: LD_VAR 0 2
80093: PUSH
80094: LD_VAR 0 4
80098: ARRAY
80099: NONEQUAL
80100: IFFALSE 80112
// begin result := false ;
80102: LD_ADDR_VAR 0 3
80106: PUSH
80107: LD_INT 0
80109: ST_TO_ADDR
// break ;
80110: GO 80114
// end ;
80112: GO 80075
80114: POP
80115: POP
// end ;
80116: LD_VAR 0 3
80120: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
80121: LD_INT 0
80123: PPUSH
80124: PPUSH
80125: PPUSH
// pom := GetBase ( fac ) ;
80126: LD_ADDR_VAR 0 5
80130: PUSH
80131: LD_VAR 0 1
80135: PPUSH
80136: CALL_OW 274
80140: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
80141: LD_ADDR_VAR 0 4
80145: PUSH
80146: LD_VAR 0 2
80150: PUSH
80151: LD_INT 1
80153: ARRAY
80154: PPUSH
80155: LD_VAR 0 2
80159: PUSH
80160: LD_INT 2
80162: ARRAY
80163: PPUSH
80164: LD_VAR 0 2
80168: PUSH
80169: LD_INT 3
80171: ARRAY
80172: PPUSH
80173: LD_VAR 0 2
80177: PUSH
80178: LD_INT 4
80180: ARRAY
80181: PPUSH
80182: CALL_OW 449
80186: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80187: LD_ADDR_VAR 0 3
80191: PUSH
80192: LD_VAR 0 5
80196: PPUSH
80197: LD_INT 1
80199: PPUSH
80200: CALL_OW 275
80204: PUSH
80205: LD_VAR 0 4
80209: PUSH
80210: LD_INT 1
80212: ARRAY
80213: GREATEREQUAL
80214: PUSH
80215: LD_VAR 0 5
80219: PPUSH
80220: LD_INT 2
80222: PPUSH
80223: CALL_OW 275
80227: PUSH
80228: LD_VAR 0 4
80232: PUSH
80233: LD_INT 2
80235: ARRAY
80236: GREATEREQUAL
80237: AND
80238: PUSH
80239: LD_VAR 0 5
80243: PPUSH
80244: LD_INT 3
80246: PPUSH
80247: CALL_OW 275
80251: PUSH
80252: LD_VAR 0 4
80256: PUSH
80257: LD_INT 3
80259: ARRAY
80260: GREATEREQUAL
80261: AND
80262: ST_TO_ADDR
// end ;
80263: LD_VAR 0 3
80267: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
80268: LD_INT 0
80270: PPUSH
80271: PPUSH
80272: PPUSH
80273: PPUSH
// pom := GetBase ( building ) ;
80274: LD_ADDR_VAR 0 3
80278: PUSH
80279: LD_VAR 0 1
80283: PPUSH
80284: CALL_OW 274
80288: ST_TO_ADDR
// if not pom then
80289: LD_VAR 0 3
80293: NOT
80294: IFFALSE 80298
// exit ;
80296: GO 80468
// btype := GetBType ( building ) ;
80298: LD_ADDR_VAR 0 5
80302: PUSH
80303: LD_VAR 0 1
80307: PPUSH
80308: CALL_OW 266
80312: ST_TO_ADDR
// if btype = b_armoury then
80313: LD_VAR 0 5
80317: PUSH
80318: LD_INT 4
80320: EQUAL
80321: IFFALSE 80331
// btype := b_barracks ;
80323: LD_ADDR_VAR 0 5
80327: PUSH
80328: LD_INT 5
80330: ST_TO_ADDR
// if btype = b_depot then
80331: LD_VAR 0 5
80335: PUSH
80336: LD_INT 0
80338: EQUAL
80339: IFFALSE 80349
// btype := b_warehouse ;
80341: LD_ADDR_VAR 0 5
80345: PUSH
80346: LD_INT 1
80348: ST_TO_ADDR
// if btype = b_workshop then
80349: LD_VAR 0 5
80353: PUSH
80354: LD_INT 2
80356: EQUAL
80357: IFFALSE 80367
// btype := b_factory ;
80359: LD_ADDR_VAR 0 5
80363: PUSH
80364: LD_INT 3
80366: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
80367: LD_ADDR_VAR 0 4
80371: PUSH
80372: LD_VAR 0 5
80376: PPUSH
80377: LD_VAR 0 1
80381: PPUSH
80382: CALL_OW 248
80386: PPUSH
80387: CALL_OW 450
80391: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80392: LD_ADDR_VAR 0 2
80396: PUSH
80397: LD_VAR 0 3
80401: PPUSH
80402: LD_INT 1
80404: PPUSH
80405: CALL_OW 275
80409: PUSH
80410: LD_VAR 0 4
80414: PUSH
80415: LD_INT 1
80417: ARRAY
80418: GREATEREQUAL
80419: PUSH
80420: LD_VAR 0 3
80424: PPUSH
80425: LD_INT 2
80427: PPUSH
80428: CALL_OW 275
80432: PUSH
80433: LD_VAR 0 4
80437: PUSH
80438: LD_INT 2
80440: ARRAY
80441: GREATEREQUAL
80442: AND
80443: PUSH
80444: LD_VAR 0 3
80448: PPUSH
80449: LD_INT 3
80451: PPUSH
80452: CALL_OW 275
80456: PUSH
80457: LD_VAR 0 4
80461: PUSH
80462: LD_INT 3
80464: ARRAY
80465: GREATEREQUAL
80466: AND
80467: ST_TO_ADDR
// end ;
80468: LD_VAR 0 2
80472: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
80473: LD_INT 0
80475: PPUSH
80476: PPUSH
80477: PPUSH
// pom := GetBase ( building ) ;
80478: LD_ADDR_VAR 0 4
80482: PUSH
80483: LD_VAR 0 1
80487: PPUSH
80488: CALL_OW 274
80492: ST_TO_ADDR
// if not pom then
80493: LD_VAR 0 4
80497: NOT
80498: IFFALSE 80502
// exit ;
80500: GO 80603
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
80502: LD_ADDR_VAR 0 5
80506: PUSH
80507: LD_VAR 0 2
80511: PPUSH
80512: LD_VAR 0 1
80516: PPUSH
80517: CALL_OW 248
80521: PPUSH
80522: CALL_OW 450
80526: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80527: LD_ADDR_VAR 0 3
80531: PUSH
80532: LD_VAR 0 4
80536: PPUSH
80537: LD_INT 1
80539: PPUSH
80540: CALL_OW 275
80544: PUSH
80545: LD_VAR 0 5
80549: PUSH
80550: LD_INT 1
80552: ARRAY
80553: GREATEREQUAL
80554: PUSH
80555: LD_VAR 0 4
80559: PPUSH
80560: LD_INT 2
80562: PPUSH
80563: CALL_OW 275
80567: PUSH
80568: LD_VAR 0 5
80572: PUSH
80573: LD_INT 2
80575: ARRAY
80576: GREATEREQUAL
80577: AND
80578: PUSH
80579: LD_VAR 0 4
80583: PPUSH
80584: LD_INT 3
80586: PPUSH
80587: CALL_OW 275
80591: PUSH
80592: LD_VAR 0 5
80596: PUSH
80597: LD_INT 3
80599: ARRAY
80600: GREATEREQUAL
80601: AND
80602: ST_TO_ADDR
// end ;
80603: LD_VAR 0 3
80607: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
80608: LD_INT 0
80610: PPUSH
80611: PPUSH
80612: PPUSH
80613: PPUSH
80614: PPUSH
80615: PPUSH
80616: PPUSH
80617: PPUSH
80618: PPUSH
80619: PPUSH
80620: PPUSH
// result := false ;
80621: LD_ADDR_VAR 0 8
80625: PUSH
80626: LD_INT 0
80628: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
80629: LD_VAR 0 5
80633: NOT
80634: PUSH
80635: LD_VAR 0 1
80639: NOT
80640: OR
80641: PUSH
80642: LD_VAR 0 2
80646: NOT
80647: OR
80648: PUSH
80649: LD_VAR 0 3
80653: NOT
80654: OR
80655: IFFALSE 80659
// exit ;
80657: GO 81473
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
80659: LD_ADDR_VAR 0 14
80663: PUSH
80664: LD_VAR 0 1
80668: PPUSH
80669: LD_VAR 0 2
80673: PPUSH
80674: LD_VAR 0 3
80678: PPUSH
80679: LD_VAR 0 4
80683: PPUSH
80684: LD_VAR 0 5
80688: PUSH
80689: LD_INT 1
80691: ARRAY
80692: PPUSH
80693: CALL_OW 248
80697: PPUSH
80698: LD_INT 0
80700: PPUSH
80701: CALL 82706 0 6
80705: ST_TO_ADDR
// if not hexes then
80706: LD_VAR 0 14
80710: NOT
80711: IFFALSE 80715
// exit ;
80713: GO 81473
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
80715: LD_ADDR_VAR 0 17
80719: PUSH
80720: LD_VAR 0 5
80724: PPUSH
80725: LD_INT 22
80727: PUSH
80728: LD_VAR 0 13
80732: PPUSH
80733: CALL_OW 255
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 2
80744: PUSH
80745: LD_INT 30
80747: PUSH
80748: LD_INT 0
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 30
80757: PUSH
80758: LD_INT 1
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: LIST
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PPUSH
80774: CALL_OW 72
80778: ST_TO_ADDR
// for i = 1 to hexes do
80779: LD_ADDR_VAR 0 9
80783: PUSH
80784: DOUBLE
80785: LD_INT 1
80787: DEC
80788: ST_TO_ADDR
80789: LD_VAR 0 14
80793: PUSH
80794: FOR_TO
80795: IFFALSE 81471
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80797: LD_ADDR_VAR 0 13
80801: PUSH
80802: LD_VAR 0 14
80806: PUSH
80807: LD_VAR 0 9
80811: ARRAY
80812: PUSH
80813: LD_INT 1
80815: ARRAY
80816: PPUSH
80817: LD_VAR 0 14
80821: PUSH
80822: LD_VAR 0 9
80826: ARRAY
80827: PUSH
80828: LD_INT 2
80830: ARRAY
80831: PPUSH
80832: CALL_OW 428
80836: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
80837: LD_VAR 0 14
80841: PUSH
80842: LD_VAR 0 9
80846: ARRAY
80847: PUSH
80848: LD_INT 1
80850: ARRAY
80851: PPUSH
80852: LD_VAR 0 14
80856: PUSH
80857: LD_VAR 0 9
80861: ARRAY
80862: PUSH
80863: LD_INT 2
80865: ARRAY
80866: PPUSH
80867: CALL_OW 351
80871: PUSH
80872: LD_VAR 0 14
80876: PUSH
80877: LD_VAR 0 9
80881: ARRAY
80882: PUSH
80883: LD_INT 1
80885: ARRAY
80886: PPUSH
80887: LD_VAR 0 14
80891: PUSH
80892: LD_VAR 0 9
80896: ARRAY
80897: PUSH
80898: LD_INT 2
80900: ARRAY
80901: PPUSH
80902: CALL_OW 488
80906: NOT
80907: OR
80908: PUSH
80909: LD_VAR 0 13
80913: PPUSH
80914: CALL_OW 247
80918: PUSH
80919: LD_INT 3
80921: EQUAL
80922: OR
80923: IFFALSE 80929
// exit ;
80925: POP
80926: POP
80927: GO 81473
// if not tmp then
80929: LD_VAR 0 13
80933: NOT
80934: IFFALSE 80938
// continue ;
80936: GO 80794
// result := true ;
80938: LD_ADDR_VAR 0 8
80942: PUSH
80943: LD_INT 1
80945: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
80946: LD_VAR 0 6
80950: PUSH
80951: LD_VAR 0 13
80955: PPUSH
80956: CALL_OW 247
80960: PUSH
80961: LD_INT 2
80963: EQUAL
80964: AND
80965: PUSH
80966: LD_VAR 0 13
80970: PPUSH
80971: CALL_OW 263
80975: PUSH
80976: LD_INT 1
80978: EQUAL
80979: AND
80980: IFFALSE 81144
// begin if IsDrivenBy ( tmp ) then
80982: LD_VAR 0 13
80986: PPUSH
80987: CALL_OW 311
80991: IFFALSE 80995
// continue ;
80993: GO 80794
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
80995: LD_VAR 0 6
80999: PPUSH
81000: LD_INT 3
81002: PUSH
81003: LD_INT 60
81005: PUSH
81006: EMPTY
81007: LIST
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 3
81015: PUSH
81016: LD_INT 55
81018: PUSH
81019: EMPTY
81020: LIST
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PPUSH
81030: CALL_OW 72
81034: IFFALSE 81142
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
81036: LD_ADDR_VAR 0 18
81040: PUSH
81041: LD_VAR 0 6
81045: PPUSH
81046: LD_INT 3
81048: PUSH
81049: LD_INT 60
81051: PUSH
81052: EMPTY
81053: LIST
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 3
81061: PUSH
81062: LD_INT 55
81064: PUSH
81065: EMPTY
81066: LIST
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PPUSH
81076: CALL_OW 72
81080: PUSH
81081: LD_INT 1
81083: ARRAY
81084: ST_TO_ADDR
// if IsInUnit ( driver ) then
81085: LD_VAR 0 18
81089: PPUSH
81090: CALL_OW 310
81094: IFFALSE 81105
// ComExit ( driver ) ;
81096: LD_VAR 0 18
81100: PPUSH
81101: CALL 106485 0 1
// AddComEnterUnit ( driver , tmp ) ;
81105: LD_VAR 0 18
81109: PPUSH
81110: LD_VAR 0 13
81114: PPUSH
81115: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
81119: LD_VAR 0 18
81123: PPUSH
81124: LD_VAR 0 7
81128: PPUSH
81129: CALL_OW 173
// AddComExitVehicle ( driver ) ;
81133: LD_VAR 0 18
81137: PPUSH
81138: CALL_OW 181
// end ; continue ;
81142: GO 80794
// end ; if not cleaners or not tmp in cleaners then
81144: LD_VAR 0 6
81148: NOT
81149: PUSH
81150: LD_VAR 0 13
81154: PUSH
81155: LD_VAR 0 6
81159: IN
81160: NOT
81161: OR
81162: IFFALSE 81469
// begin if dep then
81164: LD_VAR 0 17
81168: IFFALSE 81304
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
81170: LD_ADDR_VAR 0 16
81174: PUSH
81175: LD_VAR 0 17
81179: PUSH
81180: LD_INT 1
81182: ARRAY
81183: PPUSH
81184: CALL_OW 250
81188: PPUSH
81189: LD_VAR 0 17
81193: PUSH
81194: LD_INT 1
81196: ARRAY
81197: PPUSH
81198: CALL_OW 254
81202: PPUSH
81203: LD_INT 5
81205: PPUSH
81206: CALL_OW 272
81210: PUSH
81211: LD_VAR 0 17
81215: PUSH
81216: LD_INT 1
81218: ARRAY
81219: PPUSH
81220: CALL_OW 251
81224: PPUSH
81225: LD_VAR 0 17
81229: PUSH
81230: LD_INT 1
81232: ARRAY
81233: PPUSH
81234: CALL_OW 254
81238: PPUSH
81239: LD_INT 5
81241: PPUSH
81242: CALL_OW 273
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
81251: LD_VAR 0 16
81255: PUSH
81256: LD_INT 1
81258: ARRAY
81259: PPUSH
81260: LD_VAR 0 16
81264: PUSH
81265: LD_INT 2
81267: ARRAY
81268: PPUSH
81269: CALL_OW 488
81273: IFFALSE 81304
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
81275: LD_VAR 0 13
81279: PPUSH
81280: LD_VAR 0 16
81284: PUSH
81285: LD_INT 1
81287: ARRAY
81288: PPUSH
81289: LD_VAR 0 16
81293: PUSH
81294: LD_INT 2
81296: ARRAY
81297: PPUSH
81298: CALL_OW 111
// continue ;
81302: GO 80794
// end ; end ; r := GetDir ( tmp ) ;
81304: LD_ADDR_VAR 0 15
81308: PUSH
81309: LD_VAR 0 13
81313: PPUSH
81314: CALL_OW 254
81318: ST_TO_ADDR
// if r = 5 then
81319: LD_VAR 0 15
81323: PUSH
81324: LD_INT 5
81326: EQUAL
81327: IFFALSE 81337
// r := 0 ;
81329: LD_ADDR_VAR 0 15
81333: PUSH
81334: LD_INT 0
81336: ST_TO_ADDR
// for j = r to 5 do
81337: LD_ADDR_VAR 0 10
81341: PUSH
81342: DOUBLE
81343: LD_VAR 0 15
81347: DEC
81348: ST_TO_ADDR
81349: LD_INT 5
81351: PUSH
81352: FOR_TO
81353: IFFALSE 81467
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
81355: LD_ADDR_VAR 0 11
81359: PUSH
81360: LD_VAR 0 13
81364: PPUSH
81365: CALL_OW 250
81369: PPUSH
81370: LD_VAR 0 10
81374: PPUSH
81375: LD_INT 2
81377: PPUSH
81378: CALL_OW 272
81382: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
81383: LD_ADDR_VAR 0 12
81387: PUSH
81388: LD_VAR 0 13
81392: PPUSH
81393: CALL_OW 251
81397: PPUSH
81398: LD_VAR 0 10
81402: PPUSH
81403: LD_INT 2
81405: PPUSH
81406: CALL_OW 273
81410: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
81411: LD_VAR 0 11
81415: PPUSH
81416: LD_VAR 0 12
81420: PPUSH
81421: CALL_OW 488
81425: PUSH
81426: LD_VAR 0 11
81430: PPUSH
81431: LD_VAR 0 12
81435: PPUSH
81436: CALL_OW 428
81440: NOT
81441: AND
81442: IFFALSE 81465
// begin ComMoveXY ( tmp , _x , _y ) ;
81444: LD_VAR 0 13
81448: PPUSH
81449: LD_VAR 0 11
81453: PPUSH
81454: LD_VAR 0 12
81458: PPUSH
81459: CALL_OW 111
// break ;
81463: GO 81467
// end ; end ;
81465: GO 81352
81467: POP
81468: POP
// end ; end ;
81469: GO 80794
81471: POP
81472: POP
// end ;
81473: LD_VAR 0 8
81477: RET
// export function BuildingTechInvented ( side , btype ) ; begin
81478: LD_INT 0
81480: PPUSH
// result := true ;
81481: LD_ADDR_VAR 0 3
81485: PUSH
81486: LD_INT 1
81488: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
81489: LD_VAR 0 2
81493: PUSH
81494: LD_INT 24
81496: DOUBLE
81497: EQUAL
81498: IFTRUE 81508
81500: LD_INT 33
81502: DOUBLE
81503: EQUAL
81504: IFTRUE 81508
81506: GO 81533
81508: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
81509: LD_ADDR_VAR 0 3
81513: PUSH
81514: LD_INT 32
81516: PPUSH
81517: LD_VAR 0 1
81521: PPUSH
81522: CALL_OW 321
81526: PUSH
81527: LD_INT 2
81529: EQUAL
81530: ST_TO_ADDR
81531: GO 81849
81533: LD_INT 20
81535: DOUBLE
81536: EQUAL
81537: IFTRUE 81541
81539: GO 81566
81541: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
81542: LD_ADDR_VAR 0 3
81546: PUSH
81547: LD_INT 6
81549: PPUSH
81550: LD_VAR 0 1
81554: PPUSH
81555: CALL_OW 321
81559: PUSH
81560: LD_INT 2
81562: EQUAL
81563: ST_TO_ADDR
81564: GO 81849
81566: LD_INT 22
81568: DOUBLE
81569: EQUAL
81570: IFTRUE 81580
81572: LD_INT 36
81574: DOUBLE
81575: EQUAL
81576: IFTRUE 81580
81578: GO 81605
81580: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
81581: LD_ADDR_VAR 0 3
81585: PUSH
81586: LD_INT 15
81588: PPUSH
81589: LD_VAR 0 1
81593: PPUSH
81594: CALL_OW 321
81598: PUSH
81599: LD_INT 2
81601: EQUAL
81602: ST_TO_ADDR
81603: GO 81849
81605: LD_INT 30
81607: DOUBLE
81608: EQUAL
81609: IFTRUE 81613
81611: GO 81638
81613: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
81614: LD_ADDR_VAR 0 3
81618: PUSH
81619: LD_INT 20
81621: PPUSH
81622: LD_VAR 0 1
81626: PPUSH
81627: CALL_OW 321
81631: PUSH
81632: LD_INT 2
81634: EQUAL
81635: ST_TO_ADDR
81636: GO 81849
81638: LD_INT 28
81640: DOUBLE
81641: EQUAL
81642: IFTRUE 81652
81644: LD_INT 21
81646: DOUBLE
81647: EQUAL
81648: IFTRUE 81652
81650: GO 81677
81652: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
81653: LD_ADDR_VAR 0 3
81657: PUSH
81658: LD_INT 21
81660: PPUSH
81661: LD_VAR 0 1
81665: PPUSH
81666: CALL_OW 321
81670: PUSH
81671: LD_INT 2
81673: EQUAL
81674: ST_TO_ADDR
81675: GO 81849
81677: LD_INT 16
81679: DOUBLE
81680: EQUAL
81681: IFTRUE 81685
81683: GO 81710
81685: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
81686: LD_ADDR_VAR 0 3
81690: PUSH
81691: LD_INT 84
81693: PPUSH
81694: LD_VAR 0 1
81698: PPUSH
81699: CALL_OW 321
81703: PUSH
81704: LD_INT 2
81706: EQUAL
81707: ST_TO_ADDR
81708: GO 81849
81710: LD_INT 19
81712: DOUBLE
81713: EQUAL
81714: IFTRUE 81724
81716: LD_INT 23
81718: DOUBLE
81719: EQUAL
81720: IFTRUE 81724
81722: GO 81749
81724: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
81725: LD_ADDR_VAR 0 3
81729: PUSH
81730: LD_INT 83
81732: PPUSH
81733: LD_VAR 0 1
81737: PPUSH
81738: CALL_OW 321
81742: PUSH
81743: LD_INT 2
81745: EQUAL
81746: ST_TO_ADDR
81747: GO 81849
81749: LD_INT 17
81751: DOUBLE
81752: EQUAL
81753: IFTRUE 81757
81755: GO 81782
81757: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
81758: LD_ADDR_VAR 0 3
81762: PUSH
81763: LD_INT 39
81765: PPUSH
81766: LD_VAR 0 1
81770: PPUSH
81771: CALL_OW 321
81775: PUSH
81776: LD_INT 2
81778: EQUAL
81779: ST_TO_ADDR
81780: GO 81849
81782: LD_INT 18
81784: DOUBLE
81785: EQUAL
81786: IFTRUE 81790
81788: GO 81815
81790: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
81791: LD_ADDR_VAR 0 3
81795: PUSH
81796: LD_INT 40
81798: PPUSH
81799: LD_VAR 0 1
81803: PPUSH
81804: CALL_OW 321
81808: PUSH
81809: LD_INT 2
81811: EQUAL
81812: ST_TO_ADDR
81813: GO 81849
81815: LD_INT 27
81817: DOUBLE
81818: EQUAL
81819: IFTRUE 81823
81821: GO 81848
81823: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
81824: LD_ADDR_VAR 0 3
81828: PUSH
81829: LD_INT 35
81831: PPUSH
81832: LD_VAR 0 1
81836: PPUSH
81837: CALL_OW 321
81841: PUSH
81842: LD_INT 2
81844: EQUAL
81845: ST_TO_ADDR
81846: GO 81849
81848: POP
// end ;
81849: LD_VAR 0 3
81853: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
81854: LD_INT 0
81856: PPUSH
81857: PPUSH
81858: PPUSH
81859: PPUSH
81860: PPUSH
81861: PPUSH
81862: PPUSH
81863: PPUSH
81864: PPUSH
81865: PPUSH
81866: PPUSH
// result := false ;
81867: LD_ADDR_VAR 0 6
81871: PUSH
81872: LD_INT 0
81874: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
81875: LD_VAR 0 1
81879: NOT
81880: PUSH
81881: LD_VAR 0 1
81885: PPUSH
81886: CALL_OW 266
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: LD_INT 1
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: IN
81901: NOT
81902: OR
81903: PUSH
81904: LD_VAR 0 2
81908: NOT
81909: OR
81910: PUSH
81911: LD_VAR 0 5
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: LD_INT 1
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: LD_INT 3
81927: PUSH
81928: LD_INT 4
81930: PUSH
81931: LD_INT 5
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: IN
81942: NOT
81943: OR
81944: PUSH
81945: LD_VAR 0 3
81949: PPUSH
81950: LD_VAR 0 4
81954: PPUSH
81955: CALL_OW 488
81959: NOT
81960: OR
81961: IFFALSE 81965
// exit ;
81963: GO 82701
// side := GetSide ( depot ) ;
81965: LD_ADDR_VAR 0 9
81969: PUSH
81970: LD_VAR 0 1
81974: PPUSH
81975: CALL_OW 255
81979: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
81980: LD_VAR 0 9
81984: PPUSH
81985: LD_VAR 0 2
81989: PPUSH
81990: CALL 81478 0 2
81994: NOT
81995: IFFALSE 81999
// exit ;
81997: GO 82701
// pom := GetBase ( depot ) ;
81999: LD_ADDR_VAR 0 10
82003: PUSH
82004: LD_VAR 0 1
82008: PPUSH
82009: CALL_OW 274
82013: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
82014: LD_ADDR_VAR 0 11
82018: PUSH
82019: LD_VAR 0 2
82023: PPUSH
82024: LD_VAR 0 1
82028: PPUSH
82029: CALL_OW 248
82033: PPUSH
82034: CALL_OW 450
82038: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
82039: LD_VAR 0 10
82043: PPUSH
82044: LD_INT 1
82046: PPUSH
82047: CALL_OW 275
82051: PUSH
82052: LD_VAR 0 11
82056: PUSH
82057: LD_INT 1
82059: ARRAY
82060: GREATEREQUAL
82061: PUSH
82062: LD_VAR 0 10
82066: PPUSH
82067: LD_INT 2
82069: PPUSH
82070: CALL_OW 275
82074: PUSH
82075: LD_VAR 0 11
82079: PUSH
82080: LD_INT 2
82082: ARRAY
82083: GREATEREQUAL
82084: AND
82085: PUSH
82086: LD_VAR 0 10
82090: PPUSH
82091: LD_INT 3
82093: PPUSH
82094: CALL_OW 275
82098: PUSH
82099: LD_VAR 0 11
82103: PUSH
82104: LD_INT 3
82106: ARRAY
82107: GREATEREQUAL
82108: AND
82109: NOT
82110: IFFALSE 82114
// exit ;
82112: GO 82701
// if GetBType ( depot ) = b_depot then
82114: LD_VAR 0 1
82118: PPUSH
82119: CALL_OW 266
82123: PUSH
82124: LD_INT 0
82126: EQUAL
82127: IFFALSE 82139
// dist := 28 else
82129: LD_ADDR_VAR 0 14
82133: PUSH
82134: LD_INT 28
82136: ST_TO_ADDR
82137: GO 82147
// dist := 36 ;
82139: LD_ADDR_VAR 0 14
82143: PUSH
82144: LD_INT 36
82146: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
82147: LD_VAR 0 1
82151: PPUSH
82152: LD_VAR 0 3
82156: PPUSH
82157: LD_VAR 0 4
82161: PPUSH
82162: CALL_OW 297
82166: PUSH
82167: LD_VAR 0 14
82171: GREATER
82172: IFFALSE 82176
// exit ;
82174: GO 82701
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
82176: LD_ADDR_VAR 0 12
82180: PUSH
82181: LD_VAR 0 2
82185: PPUSH
82186: LD_VAR 0 3
82190: PPUSH
82191: LD_VAR 0 4
82195: PPUSH
82196: LD_VAR 0 5
82200: PPUSH
82201: LD_VAR 0 1
82205: PPUSH
82206: CALL_OW 248
82210: PPUSH
82211: LD_INT 0
82213: PPUSH
82214: CALL 82706 0 6
82218: ST_TO_ADDR
// if not hexes then
82219: LD_VAR 0 12
82223: NOT
82224: IFFALSE 82228
// exit ;
82226: GO 82701
// hex := GetHexInfo ( x , y ) ;
82228: LD_ADDR_VAR 0 15
82232: PUSH
82233: LD_VAR 0 3
82237: PPUSH
82238: LD_VAR 0 4
82242: PPUSH
82243: CALL_OW 546
82247: ST_TO_ADDR
// if hex [ 1 ] then
82248: LD_VAR 0 15
82252: PUSH
82253: LD_INT 1
82255: ARRAY
82256: IFFALSE 82260
// exit ;
82258: GO 82701
// height := hex [ 2 ] ;
82260: LD_ADDR_VAR 0 13
82264: PUSH
82265: LD_VAR 0 15
82269: PUSH
82270: LD_INT 2
82272: ARRAY
82273: ST_TO_ADDR
// for i = 1 to hexes do
82274: LD_ADDR_VAR 0 7
82278: PUSH
82279: DOUBLE
82280: LD_INT 1
82282: DEC
82283: ST_TO_ADDR
82284: LD_VAR 0 12
82288: PUSH
82289: FOR_TO
82290: IFFALSE 82620
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
82292: LD_VAR 0 12
82296: PUSH
82297: LD_VAR 0 7
82301: ARRAY
82302: PUSH
82303: LD_INT 1
82305: ARRAY
82306: PPUSH
82307: LD_VAR 0 12
82311: PUSH
82312: LD_VAR 0 7
82316: ARRAY
82317: PUSH
82318: LD_INT 2
82320: ARRAY
82321: PPUSH
82322: CALL_OW 488
82326: NOT
82327: PUSH
82328: LD_VAR 0 12
82332: PUSH
82333: LD_VAR 0 7
82337: ARRAY
82338: PUSH
82339: LD_INT 1
82341: ARRAY
82342: PPUSH
82343: LD_VAR 0 12
82347: PUSH
82348: LD_VAR 0 7
82352: ARRAY
82353: PUSH
82354: LD_INT 2
82356: ARRAY
82357: PPUSH
82358: CALL_OW 428
82362: PUSH
82363: LD_INT 0
82365: GREATER
82366: OR
82367: PUSH
82368: LD_VAR 0 12
82372: PUSH
82373: LD_VAR 0 7
82377: ARRAY
82378: PUSH
82379: LD_INT 1
82381: ARRAY
82382: PPUSH
82383: LD_VAR 0 12
82387: PUSH
82388: LD_VAR 0 7
82392: ARRAY
82393: PUSH
82394: LD_INT 2
82396: ARRAY
82397: PPUSH
82398: CALL_OW 351
82402: OR
82403: IFFALSE 82409
// exit ;
82405: POP
82406: POP
82407: GO 82701
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82409: LD_ADDR_VAR 0 8
82413: PUSH
82414: LD_VAR 0 12
82418: PUSH
82419: LD_VAR 0 7
82423: ARRAY
82424: PUSH
82425: LD_INT 1
82427: ARRAY
82428: PPUSH
82429: LD_VAR 0 12
82433: PUSH
82434: LD_VAR 0 7
82438: ARRAY
82439: PUSH
82440: LD_INT 2
82442: ARRAY
82443: PPUSH
82444: CALL_OW 546
82448: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
82449: LD_VAR 0 8
82453: PUSH
82454: LD_INT 1
82456: ARRAY
82457: PUSH
82458: LD_VAR 0 8
82462: PUSH
82463: LD_INT 2
82465: ARRAY
82466: PUSH
82467: LD_VAR 0 13
82471: PUSH
82472: LD_INT 2
82474: PLUS
82475: GREATER
82476: OR
82477: PUSH
82478: LD_VAR 0 8
82482: PUSH
82483: LD_INT 2
82485: ARRAY
82486: PUSH
82487: LD_VAR 0 13
82491: PUSH
82492: LD_INT 2
82494: MINUS
82495: LESS
82496: OR
82497: PUSH
82498: LD_VAR 0 8
82502: PUSH
82503: LD_INT 3
82505: ARRAY
82506: PUSH
82507: LD_INT 0
82509: PUSH
82510: LD_INT 8
82512: PUSH
82513: LD_INT 9
82515: PUSH
82516: LD_INT 10
82518: PUSH
82519: LD_INT 11
82521: PUSH
82522: LD_INT 12
82524: PUSH
82525: LD_INT 13
82527: PUSH
82528: LD_INT 16
82530: PUSH
82531: LD_INT 17
82533: PUSH
82534: LD_INT 18
82536: PUSH
82537: LD_INT 19
82539: PUSH
82540: LD_INT 20
82542: PUSH
82543: LD_INT 21
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: IN
82561: NOT
82562: OR
82563: PUSH
82564: LD_VAR 0 8
82568: PUSH
82569: LD_INT 5
82571: ARRAY
82572: NOT
82573: OR
82574: PUSH
82575: LD_VAR 0 8
82579: PUSH
82580: LD_INT 6
82582: ARRAY
82583: PUSH
82584: LD_INT 1
82586: PUSH
82587: LD_INT 2
82589: PUSH
82590: LD_INT 7
82592: PUSH
82593: LD_INT 9
82595: PUSH
82596: LD_INT 10
82598: PUSH
82599: LD_INT 11
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: IN
82610: NOT
82611: OR
82612: IFFALSE 82618
// exit ;
82614: POP
82615: POP
82616: GO 82701
// end ;
82618: GO 82289
82620: POP
82621: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
82622: LD_VAR 0 9
82626: PPUSH
82627: LD_VAR 0 3
82631: PPUSH
82632: LD_VAR 0 4
82636: PPUSH
82637: LD_INT 20
82639: PPUSH
82640: CALL 74653 0 4
82644: PUSH
82645: LD_INT 4
82647: ARRAY
82648: IFFALSE 82652
// exit ;
82650: GO 82701
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
82652: LD_VAR 0 2
82656: PUSH
82657: LD_INT 29
82659: PUSH
82660: LD_INT 30
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: IN
82667: PUSH
82668: LD_VAR 0 3
82672: PPUSH
82673: LD_VAR 0 4
82677: PPUSH
82678: LD_VAR 0 9
82682: PPUSH
82683: CALL_OW 440
82687: NOT
82688: AND
82689: IFFALSE 82693
// exit ;
82691: GO 82701
// result := true ;
82693: LD_ADDR_VAR 0 6
82697: PUSH
82698: LD_INT 1
82700: ST_TO_ADDR
// end ;
82701: LD_VAR 0 6
82705: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
82706: LD_INT 0
82708: PPUSH
82709: PPUSH
82710: PPUSH
82711: PPUSH
82712: PPUSH
82713: PPUSH
82714: PPUSH
82715: PPUSH
82716: PPUSH
82717: PPUSH
82718: PPUSH
82719: PPUSH
82720: PPUSH
82721: PPUSH
82722: PPUSH
82723: PPUSH
82724: PPUSH
82725: PPUSH
82726: PPUSH
82727: PPUSH
82728: PPUSH
82729: PPUSH
82730: PPUSH
82731: PPUSH
82732: PPUSH
82733: PPUSH
82734: PPUSH
82735: PPUSH
82736: PPUSH
82737: PPUSH
82738: PPUSH
82739: PPUSH
82740: PPUSH
82741: PPUSH
82742: PPUSH
82743: PPUSH
82744: PPUSH
82745: PPUSH
82746: PPUSH
82747: PPUSH
82748: PPUSH
82749: PPUSH
82750: PPUSH
82751: PPUSH
82752: PPUSH
82753: PPUSH
82754: PPUSH
82755: PPUSH
82756: PPUSH
82757: PPUSH
82758: PPUSH
82759: PPUSH
82760: PPUSH
82761: PPUSH
82762: PPUSH
82763: PPUSH
82764: PPUSH
82765: PPUSH
// result = [ ] ;
82766: LD_ADDR_VAR 0 7
82770: PUSH
82771: EMPTY
82772: ST_TO_ADDR
// temp_list = [ ] ;
82773: LD_ADDR_VAR 0 9
82777: PUSH
82778: EMPTY
82779: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
82780: LD_VAR 0 4
82784: PUSH
82785: LD_INT 0
82787: PUSH
82788: LD_INT 1
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: LD_INT 3
82796: PUSH
82797: LD_INT 4
82799: PUSH
82800: LD_INT 5
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: IN
82811: NOT
82812: PUSH
82813: LD_VAR 0 1
82817: PUSH
82818: LD_INT 0
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: IN
82828: PUSH
82829: LD_VAR 0 5
82833: PUSH
82834: LD_INT 1
82836: PUSH
82837: LD_INT 2
82839: PUSH
82840: LD_INT 3
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: LIST
82847: IN
82848: NOT
82849: AND
82850: OR
82851: IFFALSE 82855
// exit ;
82853: GO 101246
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
82855: LD_VAR 0 1
82859: PUSH
82860: LD_INT 6
82862: PUSH
82863: LD_INT 7
82865: PUSH
82866: LD_INT 8
82868: PUSH
82869: LD_INT 13
82871: PUSH
82872: LD_INT 12
82874: PUSH
82875: LD_INT 15
82877: PUSH
82878: LD_INT 11
82880: PUSH
82881: LD_INT 14
82883: PUSH
82884: LD_INT 10
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: IN
82898: IFFALSE 82908
// btype = b_lab ;
82900: LD_ADDR_VAR 0 1
82904: PUSH
82905: LD_INT 6
82907: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
82908: LD_VAR 0 6
82912: PUSH
82913: LD_INT 0
82915: PUSH
82916: LD_INT 1
82918: PUSH
82919: LD_INT 2
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: LIST
82926: IN
82927: NOT
82928: PUSH
82929: LD_VAR 0 1
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: LD_INT 2
82942: PUSH
82943: LD_INT 3
82945: PUSH
82946: LD_INT 6
82948: PUSH
82949: LD_INT 36
82951: PUSH
82952: LD_INT 4
82954: PUSH
82955: LD_INT 5
82957: PUSH
82958: LD_INT 31
82960: PUSH
82961: LD_INT 32
82963: PUSH
82964: LD_INT 33
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: IN
82980: NOT
82981: PUSH
82982: LD_VAR 0 6
82986: PUSH
82987: LD_INT 1
82989: EQUAL
82990: AND
82991: OR
82992: PUSH
82993: LD_VAR 0 1
82997: PUSH
82998: LD_INT 2
83000: PUSH
83001: LD_INT 3
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: IN
83008: NOT
83009: PUSH
83010: LD_VAR 0 6
83014: PUSH
83015: LD_INT 2
83017: EQUAL
83018: AND
83019: OR
83020: IFFALSE 83030
// mode = 0 ;
83022: LD_ADDR_VAR 0 6
83026: PUSH
83027: LD_INT 0
83029: ST_TO_ADDR
// case mode of 0 :
83030: LD_VAR 0 6
83034: PUSH
83035: LD_INT 0
83037: DOUBLE
83038: EQUAL
83039: IFTRUE 83043
83041: GO 94496
83043: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83044: LD_ADDR_VAR 0 11
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: LD_INT 0
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 0
83061: PUSH
83062: LD_INT 1
83064: NEG
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: LD_INT 0
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 1
83082: PUSH
83083: LD_INT 1
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: LD_INT 1
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 1
83102: NEG
83103: PUSH
83104: LD_INT 0
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 1
83113: NEG
83114: PUSH
83115: LD_INT 1
83117: NEG
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PUSH
83123: LD_INT 1
83125: NEG
83126: PUSH
83127: LD_INT 2
83129: NEG
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 0
83137: PUSH
83138: LD_INT 2
83140: NEG
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 1
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: PUSH
83160: LD_INT 2
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 0
83169: PUSH
83170: LD_INT 2
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 1
83179: NEG
83180: PUSH
83181: LD_INT 1
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: PUSH
83191: LD_INT 3
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 0
83200: PUSH
83201: LD_INT 3
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 1
83210: NEG
83211: PUSH
83212: LD_INT 2
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83237: LD_ADDR_VAR 0 12
83241: PUSH
83242: LD_INT 0
83244: PUSH
83245: LD_INT 0
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 0
83254: PUSH
83255: LD_INT 1
83257: NEG
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 1
83265: PUSH
83266: LD_INT 0
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 1
83275: PUSH
83276: LD_INT 1
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: LD_INT 1
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: LD_INT 0
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 1
83306: NEG
83307: PUSH
83308: LD_INT 1
83310: NEG
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 1
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 2
83339: PUSH
83340: LD_INT 1
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 1
83349: NEG
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 2
83360: NEG
83361: PUSH
83362: LD_INT 0
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 2
83371: NEG
83372: PUSH
83373: LD_INT 1
83375: NEG
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: LD_INT 2
83383: NEG
83384: PUSH
83385: LD_INT 1
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 3
83394: NEG
83395: PUSH
83396: LD_INT 0
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 3
83405: NEG
83406: PUSH
83407: LD_INT 1
83409: NEG
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83433: LD_ADDR_VAR 0 13
83437: PUSH
83438: LD_INT 0
83440: PUSH
83441: LD_INT 0
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: LD_INT 1
83453: NEG
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 1
83461: PUSH
83462: LD_INT 0
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 1
83471: PUSH
83472: LD_INT 1
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 0
83481: PUSH
83482: LD_INT 1
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: NEG
83492: PUSH
83493: LD_INT 0
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 1
83502: NEG
83503: PUSH
83504: LD_INT 1
83506: NEG
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 1
83514: NEG
83515: PUSH
83516: LD_INT 2
83518: NEG
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 2
83526: PUSH
83527: LD_INT 1
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 2
83536: PUSH
83537: LD_INT 2
83539: PUSH
83540: EMPTY
83541: LIST
83542: LIST
83543: PUSH
83544: LD_INT 1
83546: PUSH
83547: LD_INT 2
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 2
83556: NEG
83557: PUSH
83558: LD_INT 1
83560: NEG
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 2
83568: NEG
83569: PUSH
83570: LD_INT 2
83572: NEG
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 2
83580: NEG
83581: PUSH
83582: LD_INT 3
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 3
83592: NEG
83593: PUSH
83594: LD_INT 2
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 3
83604: NEG
83605: PUSH
83606: LD_INT 3
83608: NEG
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
83632: LD_ADDR_VAR 0 14
83636: PUSH
83637: LD_INT 0
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 0
83649: PUSH
83650: LD_INT 1
83652: NEG
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 1
83660: PUSH
83661: LD_INT 0
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: PUSH
83668: LD_INT 1
83670: PUSH
83671: LD_INT 1
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: PUSH
83678: LD_INT 0
83680: PUSH
83681: LD_INT 1
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 1
83690: NEG
83691: PUSH
83692: LD_INT 0
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: LD_INT 1
83705: NEG
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 1
83713: NEG
83714: PUSH
83715: LD_INT 2
83717: NEG
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 0
83725: PUSH
83726: LD_INT 2
83728: NEG
83729: PUSH
83730: EMPTY
83731: LIST
83732: LIST
83733: PUSH
83734: LD_INT 1
83736: PUSH
83737: LD_INT 1
83739: NEG
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 1
83747: PUSH
83748: LD_INT 2
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 0
83757: PUSH
83758: LD_INT 2
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 1
83767: NEG
83768: PUSH
83769: LD_INT 1
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: NEG
83779: PUSH
83780: LD_INT 3
83782: NEG
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 0
83790: PUSH
83791: LD_INT 3
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 1
83801: PUSH
83802: LD_INT 2
83804: NEG
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83828: LD_ADDR_VAR 0 15
83832: PUSH
83833: LD_INT 0
83835: PUSH
83836: LD_INT 0
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 0
83845: PUSH
83846: LD_INT 1
83848: NEG
83849: PUSH
83850: EMPTY
83851: LIST
83852: LIST
83853: PUSH
83854: LD_INT 1
83856: PUSH
83857: LD_INT 0
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: PUSH
83864: LD_INT 1
83866: PUSH
83867: LD_INT 1
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: PUSH
83874: LD_INT 0
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: EMPTY
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 1
83886: NEG
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 1
83897: NEG
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 1
83909: PUSH
83910: LD_INT 1
83912: NEG
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 2
83920: PUSH
83921: LD_INT 0
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 2
83930: PUSH
83931: LD_INT 1
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 1
83940: NEG
83941: PUSH
83942: LD_INT 1
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 2
83951: NEG
83952: PUSH
83953: LD_INT 0
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: LD_INT 2
83962: NEG
83963: PUSH
83964: LD_INT 1
83966: NEG
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 2
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 3
83985: PUSH
83986: LD_INT 0
83988: PUSH
83989: EMPTY
83990: LIST
83991: LIST
83992: PUSH
83993: LD_INT 3
83995: PUSH
83996: LD_INT 1
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
84021: LD_ADDR_VAR 0 16
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: LD_INT 0
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 0
84038: PUSH
84039: LD_INT 1
84041: NEG
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 1
84049: PUSH
84050: LD_INT 0
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 1
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 0
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 1
84079: NEG
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 1
84090: NEG
84091: PUSH
84092: LD_INT 1
84094: NEG
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PUSH
84100: LD_INT 1
84102: NEG
84103: PUSH
84104: LD_INT 2
84106: NEG
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 2
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 2
84124: PUSH
84125: LD_INT 2
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: LD_INT 2
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 2
84144: NEG
84145: PUSH
84146: LD_INT 1
84148: NEG
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 2
84156: NEG
84157: PUSH
84158: LD_INT 2
84160: NEG
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 3
84168: PUSH
84169: LD_INT 2
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 3
84178: PUSH
84179: LD_INT 3
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 2
84188: PUSH
84189: LD_INT 3
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84214: LD_ADDR_VAR 0 17
84218: PUSH
84219: LD_INT 0
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 1
84234: NEG
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: LD_INT 0
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 1
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 0
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 1
84272: NEG
84273: PUSH
84274: LD_INT 0
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 1
84283: NEG
84284: PUSH
84285: LD_INT 1
84287: NEG
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 1
84295: NEG
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 0
84307: PUSH
84308: LD_INT 2
84310: NEG
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: PUSH
84319: LD_INT 1
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 2
84329: PUSH
84330: LD_INT 0
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 2
84339: PUSH
84340: LD_INT 1
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 2
84349: PUSH
84350: LD_INT 2
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 1
84359: PUSH
84360: LD_INT 2
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 0
84369: PUSH
84370: LD_INT 2
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 1
84379: NEG
84380: PUSH
84381: LD_INT 1
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 2
84390: NEG
84391: PUSH
84392: LD_INT 0
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 2
84401: NEG
84402: PUSH
84403: LD_INT 1
84405: NEG
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 2
84413: NEG
84414: PUSH
84415: LD_INT 2
84417: NEG
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84444: LD_ADDR_VAR 0 18
84448: PUSH
84449: LD_INT 0
84451: PUSH
84452: LD_INT 0
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 0
84461: PUSH
84462: LD_INT 1
84464: NEG
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 1
84472: PUSH
84473: LD_INT 0
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: PUSH
84483: LD_INT 1
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 0
84492: PUSH
84493: LD_INT 1
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 1
84502: NEG
84503: PUSH
84504: LD_INT 0
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 1
84513: NEG
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 1
84525: NEG
84526: PUSH
84527: LD_INT 2
84529: NEG
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 0
84537: PUSH
84538: LD_INT 2
84540: NEG
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 1
84551: NEG
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 2
84559: PUSH
84560: LD_INT 0
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 2
84569: PUSH
84570: LD_INT 1
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 2
84579: PUSH
84580: LD_INT 2
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 1
84589: PUSH
84590: LD_INT 2
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: PUSH
84597: LD_INT 0
84599: PUSH
84600: LD_INT 2
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 1
84609: NEG
84610: PUSH
84611: LD_INT 1
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 2
84620: NEG
84621: PUSH
84622: LD_INT 0
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 2
84631: NEG
84632: PUSH
84633: LD_INT 1
84635: NEG
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 2
84643: NEG
84644: PUSH
84645: LD_INT 2
84647: NEG
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84674: LD_ADDR_VAR 0 19
84678: PUSH
84679: LD_INT 0
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 0
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: LD_INT 0
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: LD_INT 1
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: LD_INT 1
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 1
84732: NEG
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 1
84743: NEG
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: EMPTY
84750: LIST
84751: LIST
84752: PUSH
84753: LD_INT 1
84755: NEG
84756: PUSH
84757: LD_INT 2
84759: NEG
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: LD_INT 2
84770: NEG
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 1
84778: PUSH
84779: LD_INT 1
84781: NEG
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: PUSH
84787: LD_INT 2
84789: PUSH
84790: LD_INT 0
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: LD_INT 2
84799: PUSH
84800: LD_INT 1
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: LD_INT 2
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 1
84819: PUSH
84820: LD_INT 2
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 0
84829: PUSH
84830: LD_INT 2
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 1
84839: NEG
84840: PUSH
84841: LD_INT 1
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 2
84850: NEG
84851: PUSH
84852: LD_INT 0
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 2
84861: NEG
84862: PUSH
84863: LD_INT 1
84865: NEG
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 2
84873: NEG
84874: PUSH
84875: LD_INT 2
84877: NEG
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84904: LD_ADDR_VAR 0 20
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: LD_INT 0
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: LD_INT 1
84924: NEG
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: LD_INT 0
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 1
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 1
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: NEG
84963: PUSH
84964: LD_INT 0
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: LD_INT 1
84977: NEG
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: NEG
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 0
84997: PUSH
84998: LD_INT 2
85000: NEG
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: LD_INT 1
85011: NEG
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 2
85019: PUSH
85020: LD_INT 0
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 2
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 2
85039: PUSH
85040: LD_INT 2
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 1
85049: PUSH
85050: LD_INT 2
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 0
85059: PUSH
85060: LD_INT 2
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 1
85069: NEG
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 2
85080: NEG
85081: PUSH
85082: LD_INT 0
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_INT 2
85091: NEG
85092: PUSH
85093: LD_INT 1
85095: NEG
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 2
85103: NEG
85104: PUSH
85105: LD_INT 2
85107: NEG
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85134: LD_ADDR_VAR 0 21
85138: PUSH
85139: LD_INT 0
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 0
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: PUSH
85163: LD_INT 0
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: LD_INT 1
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: LD_INT 1
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: LD_INT 0
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 1
85203: NEG
85204: PUSH
85205: LD_INT 1
85207: NEG
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: LD_INT 2
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: LD_INT 2
85230: NEG
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 1
85238: PUSH
85239: LD_INT 1
85241: NEG
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 2
85249: PUSH
85250: LD_INT 0
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 2
85259: PUSH
85260: LD_INT 1
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 2
85269: PUSH
85270: LD_INT 2
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 1
85279: PUSH
85280: LD_INT 2
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 0
85289: PUSH
85290: LD_INT 2
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: PUSH
85297: LD_INT 1
85299: NEG
85300: PUSH
85301: LD_INT 1
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 2
85310: NEG
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 2
85321: NEG
85322: PUSH
85323: LD_INT 1
85325: NEG
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 2
85333: NEG
85334: PUSH
85335: LD_INT 2
85337: NEG
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85364: LD_ADDR_VAR 0 22
85368: PUSH
85369: LD_INT 0
85371: PUSH
85372: LD_INT 0
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 0
85381: PUSH
85382: LD_INT 1
85384: NEG
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 1
85392: PUSH
85393: LD_INT 0
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 1
85402: PUSH
85403: LD_INT 1
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 0
85412: PUSH
85413: LD_INT 1
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 1
85422: NEG
85423: PUSH
85424: LD_INT 0
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 1
85433: NEG
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 1
85445: NEG
85446: PUSH
85447: LD_INT 2
85449: NEG
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: PUSH
85455: LD_INT 0
85457: PUSH
85458: LD_INT 2
85460: NEG
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PUSH
85466: LD_INT 1
85468: PUSH
85469: LD_INT 1
85471: NEG
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 2
85479: PUSH
85480: LD_INT 0
85482: PUSH
85483: EMPTY
85484: LIST
85485: LIST
85486: PUSH
85487: LD_INT 2
85489: PUSH
85490: LD_INT 1
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 2
85499: PUSH
85500: LD_INT 2
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: LD_INT 2
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 0
85519: PUSH
85520: LD_INT 2
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 1
85529: NEG
85530: PUSH
85531: LD_INT 1
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 2
85540: NEG
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 2
85551: NEG
85552: PUSH
85553: LD_INT 1
85555: NEG
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 2
85563: NEG
85564: PUSH
85565: LD_INT 2
85567: NEG
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
85594: LD_ADDR_VAR 0 23
85598: PUSH
85599: LD_INT 0
85601: PUSH
85602: LD_INT 0
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 0
85611: PUSH
85612: LD_INT 1
85614: NEG
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 1
85622: PUSH
85623: LD_INT 0
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 1
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 0
85642: PUSH
85643: LD_INT 1
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: LD_INT 0
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 1
85663: NEG
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 1
85675: NEG
85676: PUSH
85677: LD_INT 2
85679: NEG
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 0
85687: PUSH
85688: LD_INT 2
85690: NEG
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: LD_INT 1
85701: NEG
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 2
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 2
85719: PUSH
85720: LD_INT 1
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 2
85729: PUSH
85730: LD_INT 2
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 1
85739: PUSH
85740: LD_INT 2
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: LD_INT 2
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 1
85759: NEG
85760: PUSH
85761: LD_INT 1
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 2
85770: NEG
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 2
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: NEG
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 2
85793: NEG
85794: PUSH
85795: LD_INT 2
85797: NEG
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 2
85805: NEG
85806: PUSH
85807: LD_INT 3
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: LD_INT 3
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 1
85829: PUSH
85830: LD_INT 2
85832: NEG
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 2
85840: PUSH
85841: LD_INT 1
85843: NEG
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
85874: LD_ADDR_VAR 0 24
85878: PUSH
85879: LD_INT 0
85881: PUSH
85882: LD_INT 0
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 0
85891: PUSH
85892: LD_INT 1
85894: NEG
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: PUSH
85903: LD_INT 0
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 1
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: LD_INT 1
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 1
85932: NEG
85933: PUSH
85934: LD_INT 0
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 1
85943: NEG
85944: PUSH
85945: LD_INT 1
85947: NEG
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: PUSH
85953: LD_INT 1
85955: NEG
85956: PUSH
85957: LD_INT 2
85959: NEG
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: LD_INT 0
85967: PUSH
85968: LD_INT 2
85970: NEG
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 1
85978: PUSH
85979: LD_INT 1
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 2
85989: PUSH
85990: LD_INT 0
85992: PUSH
85993: EMPTY
85994: LIST
85995: LIST
85996: PUSH
85997: LD_INT 2
85999: PUSH
86000: LD_INT 1
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 2
86009: PUSH
86010: LD_INT 2
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 1
86019: PUSH
86020: LD_INT 2
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 0
86029: PUSH
86030: LD_INT 2
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 1
86039: NEG
86040: PUSH
86041: LD_INT 1
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 2
86050: NEG
86051: PUSH
86052: LD_INT 0
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 2
86061: NEG
86062: PUSH
86063: LD_INT 1
86065: NEG
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 2
86073: NEG
86074: PUSH
86075: LD_INT 2
86077: NEG
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: PUSH
86086: LD_INT 2
86088: NEG
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 2
86096: PUSH
86097: LD_INT 1
86099: NEG
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 3
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 3
86117: PUSH
86118: LD_INT 2
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
86150: LD_ADDR_VAR 0 25
86154: PUSH
86155: LD_INT 0
86157: PUSH
86158: LD_INT 0
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 0
86167: PUSH
86168: LD_INT 1
86170: NEG
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 1
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 1
86188: PUSH
86189: LD_INT 1
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 0
86198: PUSH
86199: LD_INT 1
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 1
86208: NEG
86209: PUSH
86210: LD_INT 0
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 1
86219: NEG
86220: PUSH
86221: LD_INT 1
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 1
86231: NEG
86232: PUSH
86233: LD_INT 2
86235: NEG
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 0
86243: PUSH
86244: LD_INT 2
86246: NEG
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 1
86254: PUSH
86255: LD_INT 1
86257: NEG
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 2
86265: PUSH
86266: LD_INT 0
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 2
86275: PUSH
86276: LD_INT 1
86278: PUSH
86279: EMPTY
86280: LIST
86281: LIST
86282: PUSH
86283: LD_INT 2
86285: PUSH
86286: LD_INT 2
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 1
86295: PUSH
86296: LD_INT 2
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 0
86305: PUSH
86306: LD_INT 2
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: LD_INT 1
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 2
86326: NEG
86327: PUSH
86328: LD_INT 0
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 2
86337: NEG
86338: PUSH
86339: LD_INT 1
86341: NEG
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: NEG
86350: PUSH
86351: LD_INT 2
86353: NEG
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 3
86361: PUSH
86362: LD_INT 1
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 3
86371: PUSH
86372: LD_INT 2
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 2
86381: PUSH
86382: LD_INT 3
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 1
86391: PUSH
86392: LD_INT 3
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
86424: LD_ADDR_VAR 0 26
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: LD_INT 0
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 0
86441: PUSH
86442: LD_INT 1
86444: NEG
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 1
86452: PUSH
86453: LD_INT 0
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: LD_INT 1
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: LD_INT 1
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 1
86482: NEG
86483: PUSH
86484: LD_INT 0
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: LD_INT 1
86497: NEG
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 1
86505: NEG
86506: PUSH
86507: LD_INT 2
86509: NEG
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PUSH
86515: LD_INT 0
86517: PUSH
86518: LD_INT 2
86520: NEG
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: LD_INT 1
86528: PUSH
86529: LD_INT 1
86531: NEG
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 2
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 2
86549: PUSH
86550: LD_INT 1
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: PUSH
86557: LD_INT 2
86559: PUSH
86560: LD_INT 2
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 1
86569: PUSH
86570: LD_INT 2
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 0
86579: PUSH
86580: LD_INT 2
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 1
86589: NEG
86590: PUSH
86591: LD_INT 1
86593: PUSH
86594: EMPTY
86595: LIST
86596: LIST
86597: PUSH
86598: LD_INT 2
86600: NEG
86601: PUSH
86602: LD_INT 0
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 2
86611: NEG
86612: PUSH
86613: LD_INT 1
86615: NEG
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 2
86623: NEG
86624: PUSH
86625: LD_INT 2
86627: NEG
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: PUSH
86633: LD_INT 2
86635: PUSH
86636: LD_INT 3
86638: PUSH
86639: EMPTY
86640: LIST
86641: LIST
86642: PUSH
86643: LD_INT 1
86645: PUSH
86646: LD_INT 3
86648: PUSH
86649: EMPTY
86650: LIST
86651: LIST
86652: PUSH
86653: LD_INT 1
86655: NEG
86656: PUSH
86657: LD_INT 2
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: LD_INT 2
86666: NEG
86667: PUSH
86668: LD_INT 1
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
86700: LD_ADDR_VAR 0 27
86704: PUSH
86705: LD_INT 0
86707: PUSH
86708: LD_INT 0
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 0
86717: PUSH
86718: LD_INT 1
86720: NEG
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 1
86728: PUSH
86729: LD_INT 0
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: LD_INT 1
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 0
86748: PUSH
86749: LD_INT 1
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: LD_INT 0
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: LD_INT 1
86773: NEG
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 1
86781: NEG
86782: PUSH
86783: LD_INT 2
86785: NEG
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 0
86793: PUSH
86794: LD_INT 2
86796: NEG
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 1
86804: PUSH
86805: LD_INT 1
86807: NEG
86808: PUSH
86809: EMPTY
86810: LIST
86811: LIST
86812: PUSH
86813: LD_INT 2
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 2
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 2
86835: PUSH
86836: LD_INT 2
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 1
86845: PUSH
86846: LD_INT 2
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PUSH
86853: LD_INT 0
86855: PUSH
86856: LD_INT 2
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 1
86865: NEG
86866: PUSH
86867: LD_INT 1
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: PUSH
86874: LD_INT 2
86876: NEG
86877: PUSH
86878: LD_INT 0
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 2
86887: NEG
86888: PUSH
86889: LD_INT 1
86891: NEG
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 2
86899: NEG
86900: PUSH
86901: LD_INT 2
86903: NEG
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 1
86911: NEG
86912: PUSH
86913: LD_INT 2
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 2
86922: NEG
86923: PUSH
86924: LD_INT 1
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 3
86933: NEG
86934: PUSH
86935: LD_INT 1
86937: NEG
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 3
86945: NEG
86946: PUSH
86947: LD_INT 2
86949: NEG
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
86980: LD_ADDR_VAR 0 28
86984: PUSH
86985: LD_INT 0
86987: PUSH
86988: LD_INT 0
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 0
86997: PUSH
86998: LD_INT 1
87000: NEG
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: PUSH
87006: LD_INT 1
87008: PUSH
87009: LD_INT 0
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 1
87018: PUSH
87019: LD_INT 1
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PUSH
87026: LD_INT 0
87028: PUSH
87029: LD_INT 1
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 1
87038: NEG
87039: PUSH
87040: LD_INT 0
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 1
87049: NEG
87050: PUSH
87051: LD_INT 1
87053: NEG
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 1
87061: NEG
87062: PUSH
87063: LD_INT 2
87065: NEG
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 0
87073: PUSH
87074: LD_INT 2
87076: NEG
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 1
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 2
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 2
87105: PUSH
87106: LD_INT 1
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 2
87115: PUSH
87116: LD_INT 2
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: LD_INT 2
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 0
87135: PUSH
87136: LD_INT 2
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 1
87145: NEG
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 2
87156: NEG
87157: PUSH
87158: LD_INT 0
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 2
87167: NEG
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 2
87179: NEG
87180: PUSH
87181: LD_INT 2
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: LD_INT 3
87195: NEG
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: NEG
87204: PUSH
87205: LD_INT 3
87207: NEG
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PUSH
87213: LD_INT 3
87215: NEG
87216: PUSH
87217: LD_INT 1
87219: NEG
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 3
87227: NEG
87228: PUSH
87229: LD_INT 2
87231: NEG
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87262: LD_ADDR_VAR 0 29
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: LD_INT 0
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 0
87279: PUSH
87280: LD_INT 1
87282: NEG
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 1
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: LD_INT 1
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 1
87320: NEG
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 1
87331: NEG
87332: PUSH
87333: LD_INT 1
87335: NEG
87336: PUSH
87337: EMPTY
87338: LIST
87339: LIST
87340: PUSH
87341: LD_INT 1
87343: NEG
87344: PUSH
87345: LD_INT 2
87347: NEG
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: LD_INT 0
87355: PUSH
87356: LD_INT 2
87358: NEG
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: PUSH
87364: LD_INT 1
87366: PUSH
87367: LD_INT 1
87369: NEG
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 2
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 2
87387: PUSH
87388: LD_INT 1
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: LD_INT 2
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: LD_INT 2
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: NEG
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 2
87428: NEG
87429: PUSH
87430: LD_INT 1
87432: NEG
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 2
87440: NEG
87441: PUSH
87442: LD_INT 2
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 2
87452: NEG
87453: PUSH
87454: LD_INT 3
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 2
87464: PUSH
87465: LD_INT 1
87467: NEG
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 3
87475: PUSH
87476: LD_INT 1
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 1
87485: PUSH
87486: LD_INT 3
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 1
87495: NEG
87496: PUSH
87497: LD_INT 2
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 3
87506: NEG
87507: PUSH
87508: LD_INT 2
87510: NEG
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87541: LD_ADDR_VAR 0 30
87545: PUSH
87546: LD_INT 0
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 0
87558: PUSH
87559: LD_INT 1
87561: NEG
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 1
87569: PUSH
87570: LD_INT 0
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 1
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 0
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 1
87599: NEG
87600: PUSH
87601: LD_INT 0
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 1
87610: NEG
87611: PUSH
87612: LD_INT 1
87614: NEG
87615: PUSH
87616: EMPTY
87617: LIST
87618: LIST
87619: PUSH
87620: LD_INT 1
87622: NEG
87623: PUSH
87624: LD_INT 2
87626: NEG
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 0
87634: PUSH
87635: LD_INT 2
87637: NEG
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: LD_INT 1
87648: NEG
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 2
87656: PUSH
87657: LD_INT 0
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 2
87666: PUSH
87667: LD_INT 1
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 2
87676: PUSH
87677: LD_INT 2
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 1
87686: PUSH
87687: LD_INT 2
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 1
87696: NEG
87697: PUSH
87698: LD_INT 1
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 2
87707: NEG
87708: PUSH
87709: LD_INT 0
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 2
87718: NEG
87719: PUSH
87720: LD_INT 1
87722: NEG
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 1
87730: NEG
87731: PUSH
87732: LD_INT 3
87734: NEG
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 1
87742: PUSH
87743: LD_INT 2
87745: NEG
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 3
87753: PUSH
87754: LD_INT 2
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 2
87763: PUSH
87764: LD_INT 3
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 2
87773: NEG
87774: PUSH
87775: LD_INT 1
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 3
87784: NEG
87785: PUSH
87786: LD_INT 1
87788: NEG
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87819: LD_ADDR_VAR 0 31
87823: PUSH
87824: LD_INT 0
87826: PUSH
87827: LD_INT 0
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 0
87836: PUSH
87837: LD_INT 1
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 1
87847: PUSH
87848: LD_INT 0
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 1
87857: PUSH
87858: LD_INT 1
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: LD_INT 1
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 1
87877: NEG
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 1
87888: NEG
87889: PUSH
87890: LD_INT 1
87892: NEG
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 1
87900: NEG
87901: PUSH
87902: LD_INT 2
87904: NEG
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 1
87912: PUSH
87913: LD_INT 1
87915: NEG
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 2
87923: PUSH
87924: LD_INT 0
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: PUSH
87931: LD_INT 2
87933: PUSH
87934: LD_INT 1
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 2
87943: PUSH
87944: LD_INT 2
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 1
87953: PUSH
87954: LD_INT 2
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 0
87963: PUSH
87964: LD_INT 2
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: PUSH
87971: LD_INT 1
87973: NEG
87974: PUSH
87975: LD_INT 1
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 2
87984: NEG
87985: PUSH
87986: LD_INT 1
87988: NEG
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 2
87996: NEG
87997: PUSH
87998: LD_INT 2
88000: NEG
88001: PUSH
88002: EMPTY
88003: LIST
88004: LIST
88005: PUSH
88006: LD_INT 2
88008: NEG
88009: PUSH
88010: LD_INT 3
88012: NEG
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 2
88020: PUSH
88021: LD_INT 1
88023: NEG
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 3
88031: PUSH
88032: LD_INT 1
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 1
88041: PUSH
88042: LD_INT 3
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 1
88051: NEG
88052: PUSH
88053: LD_INT 2
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 3
88062: NEG
88063: PUSH
88064: LD_INT 2
88066: NEG
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88097: LD_ADDR_VAR 0 32
88101: PUSH
88102: LD_INT 0
88104: PUSH
88105: LD_INT 0
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: LD_INT 1
88117: NEG
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: LD_INT 1
88125: PUSH
88126: LD_INT 0
88128: PUSH
88129: EMPTY
88130: LIST
88131: LIST
88132: PUSH
88133: LD_INT 1
88135: PUSH
88136: LD_INT 1
88138: PUSH
88139: EMPTY
88140: LIST
88141: LIST
88142: PUSH
88143: LD_INT 0
88145: PUSH
88146: LD_INT 1
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: NEG
88156: PUSH
88157: LD_INT 0
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: NEG
88167: PUSH
88168: LD_INT 1
88170: NEG
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 1
88178: NEG
88179: PUSH
88180: LD_INT 2
88182: NEG
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 2
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: LD_INT 1
88204: NEG
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 2
88212: PUSH
88213: LD_INT 1
88215: PUSH
88216: EMPTY
88217: LIST
88218: LIST
88219: PUSH
88220: LD_INT 2
88222: PUSH
88223: LD_INT 2
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: PUSH
88230: LD_INT 1
88232: PUSH
88233: LD_INT 2
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: LD_INT 2
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: NEG
88253: PUSH
88254: LD_INT 1
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_INT 2
88263: NEG
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 2
88274: NEG
88275: PUSH
88276: LD_INT 1
88278: NEG
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: PUSH
88284: LD_INT 1
88286: NEG
88287: PUSH
88288: LD_INT 3
88290: NEG
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 1
88298: PUSH
88299: LD_INT 2
88301: NEG
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 3
88309: PUSH
88310: LD_INT 2
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 2
88319: PUSH
88320: LD_INT 3
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 2
88329: NEG
88330: PUSH
88331: LD_INT 1
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: PUSH
88338: LD_INT 3
88340: NEG
88341: PUSH
88342: LD_INT 1
88344: NEG
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88375: LD_ADDR_VAR 0 33
88379: PUSH
88380: LD_INT 0
88382: PUSH
88383: LD_INT 0
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 0
88392: PUSH
88393: LD_INT 1
88395: NEG
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 1
88403: PUSH
88404: LD_INT 0
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 1
88413: PUSH
88414: LD_INT 1
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 0
88423: PUSH
88424: LD_INT 1
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 1
88433: NEG
88434: PUSH
88435: LD_INT 0
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 1
88444: NEG
88445: PUSH
88446: LD_INT 1
88448: NEG
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 1
88456: NEG
88457: PUSH
88458: LD_INT 2
88460: NEG
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: LD_INT 1
88468: PUSH
88469: LD_INT 1
88471: NEG
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 2
88479: PUSH
88480: LD_INT 0
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 2
88489: PUSH
88490: LD_INT 1
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 1
88499: PUSH
88500: LD_INT 2
88502: PUSH
88503: EMPTY
88504: LIST
88505: LIST
88506: PUSH
88507: LD_INT 0
88509: PUSH
88510: LD_INT 2
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 1
88519: NEG
88520: PUSH
88521: LD_INT 1
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: NEG
88531: PUSH
88532: LD_INT 0
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 2
88541: NEG
88542: PUSH
88543: LD_INT 1
88545: NEG
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: PUSH
88551: LD_INT 2
88553: NEG
88554: PUSH
88555: LD_INT 2
88557: NEG
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 2
88565: NEG
88566: PUSH
88567: LD_INT 3
88569: NEG
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: PUSH
88575: LD_INT 2
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 3
88588: PUSH
88589: LD_INT 1
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 1
88598: PUSH
88599: LD_INT 3
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 1
88608: NEG
88609: PUSH
88610: LD_INT 2
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 3
88619: NEG
88620: PUSH
88621: LD_INT 2
88623: NEG
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: EMPTY
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88654: LD_ADDR_VAR 0 34
88658: PUSH
88659: LD_INT 0
88661: PUSH
88662: LD_INT 0
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: LD_INT 0
88671: PUSH
88672: LD_INT 1
88674: NEG
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 1
88682: PUSH
88683: LD_INT 0
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: PUSH
88690: LD_INT 1
88692: PUSH
88693: LD_INT 1
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 0
88702: PUSH
88703: LD_INT 1
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 1
88712: NEG
88713: PUSH
88714: LD_INT 0
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 1
88723: NEG
88724: PUSH
88725: LD_INT 1
88727: NEG
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 1
88735: NEG
88736: PUSH
88737: LD_INT 2
88739: NEG
88740: PUSH
88741: EMPTY
88742: LIST
88743: LIST
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: LD_INT 2
88750: NEG
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 1
88758: PUSH
88759: LD_INT 1
88761: NEG
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 2
88769: PUSH
88770: LD_INT 1
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 2
88779: PUSH
88780: LD_INT 2
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: LD_INT 2
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 1
88799: NEG
88800: PUSH
88801: LD_INT 1
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 2
88810: NEG
88811: PUSH
88812: LD_INT 0
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 2
88821: NEG
88822: PUSH
88823: LD_INT 1
88825: NEG
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: LD_INT 2
88837: NEG
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: LD_INT 1
88845: NEG
88846: PUSH
88847: LD_INT 3
88849: NEG
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 1
88857: PUSH
88858: LD_INT 2
88860: NEG
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: PUSH
88866: LD_INT 3
88868: PUSH
88869: LD_INT 2
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 2
88878: PUSH
88879: LD_INT 3
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: PUSH
88886: LD_INT 2
88888: NEG
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: PUSH
88897: LD_INT 3
88899: NEG
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88934: LD_ADDR_VAR 0 35
88938: PUSH
88939: LD_INT 0
88941: PUSH
88942: LD_INT 0
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 0
88951: PUSH
88952: LD_INT 1
88954: NEG
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 1
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 1
88972: PUSH
88973: LD_INT 1
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: LD_INT 1
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: LD_INT 1
88992: NEG
88993: PUSH
88994: LD_INT 0
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 1
89003: NEG
89004: PUSH
89005: LD_INT 1
89007: NEG
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 2
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PUSH
89023: LD_INT 2
89025: NEG
89026: PUSH
89027: LD_INT 1
89029: NEG
89030: PUSH
89031: EMPTY
89032: LIST
89033: LIST
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
89046: LD_ADDR_VAR 0 36
89050: PUSH
89051: LD_INT 0
89053: PUSH
89054: LD_INT 0
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: LD_INT 1
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 1
89074: PUSH
89075: LD_INT 0
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 1
89084: PUSH
89085: LD_INT 1
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 0
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 1
89104: NEG
89105: PUSH
89106: LD_INT 0
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 1
89115: NEG
89116: PUSH
89117: LD_INT 1
89119: NEG
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: LD_INT 1
89127: NEG
89128: PUSH
89129: LD_INT 2
89131: NEG
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: LD_INT 1
89139: PUSH
89140: LD_INT 2
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
89158: LD_ADDR_VAR 0 37
89162: PUSH
89163: LD_INT 0
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: LD_INT 0
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 1
89186: PUSH
89187: LD_INT 0
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 1
89196: PUSH
89197: LD_INT 1
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: LD_INT 1
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: LD_INT 0
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 1
89227: NEG
89228: PUSH
89229: LD_INT 1
89231: NEG
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 1
89239: PUSH
89240: LD_INT 1
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: NEG
89251: PUSH
89252: LD_INT 1
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89270: LD_ADDR_VAR 0 38
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 1
89298: PUSH
89299: LD_INT 0
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: LD_INT 1
89308: PUSH
89309: LD_INT 1
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: LD_INT 1
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 1
89328: NEG
89329: PUSH
89330: LD_INT 0
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 1
89339: NEG
89340: PUSH
89341: LD_INT 1
89343: NEG
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 2
89351: PUSH
89352: LD_INT 1
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 2
89361: NEG
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
89382: LD_ADDR_VAR 0 39
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: LD_INT 0
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 0
89399: PUSH
89400: LD_INT 1
89402: NEG
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 1
89410: PUSH
89411: LD_INT 0
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 1
89420: PUSH
89421: LD_INT 1
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 0
89430: PUSH
89431: LD_INT 1
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 1
89440: NEG
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 1
89451: NEG
89452: PUSH
89453: LD_INT 1
89455: NEG
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: PUSH
89461: LD_INT 1
89463: NEG
89464: PUSH
89465: LD_INT 2
89467: NEG
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 1
89475: PUSH
89476: LD_INT 2
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
89494: LD_ADDR_VAR 0 40
89498: PUSH
89499: LD_INT 0
89501: PUSH
89502: LD_INT 0
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 0
89511: PUSH
89512: LD_INT 1
89514: NEG
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 1
89522: PUSH
89523: LD_INT 0
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 1
89532: PUSH
89533: LD_INT 1
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 0
89542: PUSH
89543: LD_INT 1
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 1
89552: NEG
89553: PUSH
89554: LD_INT 0
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 1
89563: NEG
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: LD_INT 1
89578: NEG
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PUSH
89584: LD_INT 1
89586: NEG
89587: PUSH
89588: LD_INT 1
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89606: LD_ADDR_VAR 0 41
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 0
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 1
89634: PUSH
89635: LD_INT 0
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 0
89654: PUSH
89655: LD_INT 1
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 1
89664: NEG
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 1
89675: NEG
89676: PUSH
89677: LD_INT 1
89679: NEG
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: LD_INT 1
89687: NEG
89688: PUSH
89689: LD_INT 2
89691: NEG
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 1
89699: PUSH
89700: LD_INT 1
89702: NEG
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 2
89710: PUSH
89711: LD_INT 0
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 2
89720: PUSH
89721: LD_INT 1
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 2
89730: PUSH
89731: LD_INT 2
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: LD_INT 1
89740: PUSH
89741: LD_INT 2
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 1
89750: NEG
89751: PUSH
89752: LD_INT 1
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 2
89761: NEG
89762: PUSH
89763: LD_INT 0
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 2
89772: NEG
89773: PUSH
89774: LD_INT 1
89776: NEG
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 2
89784: NEG
89785: PUSH
89786: LD_INT 2
89788: NEG
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: LD_INT 2
89796: NEG
89797: PUSH
89798: LD_INT 3
89800: NEG
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: PUSH
89806: LD_INT 2
89808: PUSH
89809: LD_INT 1
89811: NEG
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: PUSH
89817: LD_INT 3
89819: PUSH
89820: LD_INT 0
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 3
89829: PUSH
89830: LD_INT 1
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 3
89839: PUSH
89840: LD_INT 2
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 3
89849: PUSH
89850: LD_INT 3
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 2
89859: PUSH
89860: LD_INT 3
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 2
89869: NEG
89870: PUSH
89871: LD_INT 1
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 3
89880: NEG
89881: PUSH
89882: LD_INT 0
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 3
89891: NEG
89892: PUSH
89893: LD_INT 1
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 3
89903: NEG
89904: PUSH
89905: LD_INT 2
89907: NEG
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 3
89915: NEG
89916: PUSH
89917: LD_INT 3
89919: NEG
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89956: LD_ADDR_VAR 0 42
89960: PUSH
89961: LD_INT 0
89963: PUSH
89964: LD_INT 0
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: LD_INT 1
89976: NEG
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: LD_INT 1
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 1
90014: NEG
90015: PUSH
90016: LD_INT 0
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: NEG
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 1
90037: NEG
90038: PUSH
90039: LD_INT 2
90041: NEG
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 0
90049: PUSH
90050: LD_INT 2
90052: NEG
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 1
90060: PUSH
90061: LD_INT 1
90063: NEG
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 2
90071: PUSH
90072: LD_INT 1
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 1
90091: PUSH
90092: LD_INT 2
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 0
90101: PUSH
90102: LD_INT 2
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 1
90111: NEG
90112: PUSH
90113: LD_INT 1
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 2
90122: NEG
90123: PUSH
90124: LD_INT 1
90126: NEG
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 2
90134: NEG
90135: PUSH
90136: LD_INT 2
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 2
90146: NEG
90147: PUSH
90148: LD_INT 3
90150: NEG
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 1
90158: NEG
90159: PUSH
90160: LD_INT 3
90162: NEG
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 0
90170: PUSH
90171: LD_INT 3
90173: NEG
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 1
90181: PUSH
90182: LD_INT 2
90184: NEG
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 3
90192: PUSH
90193: LD_INT 2
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 3
90202: PUSH
90203: LD_INT 3
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 2
90212: PUSH
90213: LD_INT 3
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 1
90222: PUSH
90223: LD_INT 3
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 0
90232: PUSH
90233: LD_INT 3
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 1
90242: NEG
90243: PUSH
90244: LD_INT 2
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: PUSH
90251: LD_INT 3
90253: NEG
90254: PUSH
90255: LD_INT 2
90257: NEG
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 3
90265: NEG
90266: PUSH
90267: LD_INT 3
90269: NEG
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90306: LD_ADDR_VAR 0 43
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: LD_INT 0
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 0
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 1
90334: PUSH
90335: LD_INT 0
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 1
90344: PUSH
90345: LD_INT 1
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 0
90354: PUSH
90355: LD_INT 1
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 1
90364: NEG
90365: PUSH
90366: LD_INT 0
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 1
90375: NEG
90376: PUSH
90377: LD_INT 1
90379: NEG
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 1
90387: NEG
90388: PUSH
90389: LD_INT 2
90391: NEG
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 0
90399: PUSH
90400: LD_INT 2
90402: NEG
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: LD_INT 1
90413: NEG
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 2
90421: PUSH
90422: LD_INT 0
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 2
90431: PUSH
90432: LD_INT 1
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PUSH
90439: LD_INT 1
90441: PUSH
90442: LD_INT 2
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 0
90451: PUSH
90452: LD_INT 2
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 1
90461: NEG
90462: PUSH
90463: LD_INT 1
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 2
90472: NEG
90473: PUSH
90474: LD_INT 0
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 2
90483: NEG
90484: PUSH
90485: LD_INT 1
90487: NEG
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: NEG
90496: PUSH
90497: LD_INT 3
90499: NEG
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: LD_INT 3
90510: NEG
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: LD_INT 1
90518: PUSH
90519: LD_INT 2
90521: NEG
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 2
90529: PUSH
90530: LD_INT 1
90532: NEG
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PUSH
90538: LD_INT 3
90540: PUSH
90541: LD_INT 0
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 3
90550: PUSH
90551: LD_INT 1
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 1
90560: PUSH
90561: LD_INT 3
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 0
90570: PUSH
90571: LD_INT 3
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 1
90580: NEG
90581: PUSH
90582: LD_INT 2
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 2
90591: NEG
90592: PUSH
90593: LD_INT 1
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 3
90602: NEG
90603: PUSH
90604: LD_INT 0
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 3
90613: NEG
90614: PUSH
90615: LD_INT 1
90617: NEG
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90654: LD_ADDR_VAR 0 44
90658: PUSH
90659: LD_INT 0
90661: PUSH
90662: LD_INT 0
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 0
90671: PUSH
90672: LD_INT 1
90674: NEG
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: PUSH
90680: LD_INT 1
90682: PUSH
90683: LD_INT 0
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: PUSH
90690: LD_INT 1
90692: PUSH
90693: LD_INT 1
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 0
90702: PUSH
90703: LD_INT 1
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 1
90712: NEG
90713: PUSH
90714: LD_INT 0
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: PUSH
90721: LD_INT 1
90723: NEG
90724: PUSH
90725: LD_INT 1
90727: NEG
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: LD_INT 2
90739: NEG
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 1
90747: PUSH
90748: LD_INT 1
90750: NEG
90751: PUSH
90752: EMPTY
90753: LIST
90754: LIST
90755: PUSH
90756: LD_INT 2
90758: PUSH
90759: LD_INT 0
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: LD_INT 2
90768: PUSH
90769: LD_INT 1
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 2
90778: PUSH
90779: LD_INT 2
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PUSH
90786: LD_INT 1
90788: PUSH
90789: LD_INT 2
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 1
90798: NEG
90799: PUSH
90800: LD_INT 1
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 2
90809: NEG
90810: PUSH
90811: LD_INT 0
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 2
90820: NEG
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 2
90832: NEG
90833: PUSH
90834: LD_INT 2
90836: NEG
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 2
90844: NEG
90845: PUSH
90846: LD_INT 3
90848: NEG
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 2
90856: PUSH
90857: LD_INT 1
90859: NEG
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 3
90867: PUSH
90868: LD_INT 0
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 3
90877: PUSH
90878: LD_INT 1
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 3
90887: PUSH
90888: LD_INT 2
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 3
90897: PUSH
90898: LD_INT 3
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 2
90907: PUSH
90908: LD_INT 3
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 2
90917: NEG
90918: PUSH
90919: LD_INT 1
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 3
90928: NEG
90929: PUSH
90930: LD_INT 0
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 3
90939: NEG
90940: PUSH
90941: LD_INT 1
90943: NEG
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 3
90951: NEG
90952: PUSH
90953: LD_INT 2
90955: NEG
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 3
90963: NEG
90964: PUSH
90965: LD_INT 3
90967: NEG
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91004: LD_ADDR_VAR 0 45
91008: PUSH
91009: LD_INT 0
91011: PUSH
91012: LD_INT 0
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 0
91021: PUSH
91022: LD_INT 1
91024: NEG
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 1
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 1
91042: PUSH
91043: LD_INT 1
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 0
91052: PUSH
91053: LD_INT 1
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 1
91062: NEG
91063: PUSH
91064: LD_INT 0
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 1
91073: NEG
91074: PUSH
91075: LD_INT 1
91077: NEG
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 1
91085: NEG
91086: PUSH
91087: LD_INT 2
91089: NEG
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: LD_INT 2
91100: NEG
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 1
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: PUSH
91117: LD_INT 2
91119: PUSH
91120: LD_INT 1
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 2
91129: PUSH
91130: LD_INT 2
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 1
91139: PUSH
91140: LD_INT 2
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 0
91149: PUSH
91150: LD_INT 2
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: LD_INT 1
91159: NEG
91160: PUSH
91161: LD_INT 1
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: LD_INT 2
91170: NEG
91171: PUSH
91172: LD_INT 1
91174: NEG
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 2
91182: NEG
91183: PUSH
91184: LD_INT 2
91186: NEG
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 2
91194: NEG
91195: PUSH
91196: LD_INT 3
91198: NEG
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 1
91206: NEG
91207: PUSH
91208: LD_INT 3
91210: NEG
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 0
91218: PUSH
91219: LD_INT 3
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 1
91229: PUSH
91230: LD_INT 2
91232: NEG
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 3
91240: PUSH
91241: LD_INT 2
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 3
91250: PUSH
91251: LD_INT 3
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: LD_INT 2
91260: PUSH
91261: LD_INT 3
91263: PUSH
91264: EMPTY
91265: LIST
91266: LIST
91267: PUSH
91268: LD_INT 1
91270: PUSH
91271: LD_INT 3
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: PUSH
91278: LD_INT 0
91280: PUSH
91281: LD_INT 3
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 1
91290: NEG
91291: PUSH
91292: LD_INT 2
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 3
91301: NEG
91302: PUSH
91303: LD_INT 2
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 3
91313: NEG
91314: PUSH
91315: LD_INT 3
91317: NEG
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91354: LD_ADDR_VAR 0 46
91358: PUSH
91359: LD_INT 0
91361: PUSH
91362: LD_INT 0
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: PUSH
91369: LD_INT 0
91371: PUSH
91372: LD_INT 1
91374: NEG
91375: PUSH
91376: EMPTY
91377: LIST
91378: LIST
91379: PUSH
91380: LD_INT 1
91382: PUSH
91383: LD_INT 0
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 1
91392: PUSH
91393: LD_INT 1
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: LD_INT 0
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 1
91412: NEG
91413: PUSH
91414: LD_INT 0
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 1
91423: NEG
91424: PUSH
91425: LD_INT 1
91427: NEG
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 1
91435: NEG
91436: PUSH
91437: LD_INT 2
91439: NEG
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 2
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: PUSH
91459: LD_INT 1
91461: NEG
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: PUSH
91467: LD_INT 2
91469: PUSH
91470: LD_INT 0
91472: PUSH
91473: EMPTY
91474: LIST
91475: LIST
91476: PUSH
91477: LD_INT 2
91479: PUSH
91480: LD_INT 1
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: LD_INT 2
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 0
91499: PUSH
91500: LD_INT 2
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: PUSH
91507: LD_INT 1
91509: NEG
91510: PUSH
91511: LD_INT 1
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: LD_INT 2
91520: NEG
91521: PUSH
91522: LD_INT 0
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: LD_INT 2
91531: NEG
91532: PUSH
91533: LD_INT 1
91535: NEG
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 1
91543: NEG
91544: PUSH
91545: LD_INT 3
91547: NEG
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 0
91555: PUSH
91556: LD_INT 3
91558: NEG
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 1
91566: PUSH
91567: LD_INT 2
91569: NEG
91570: PUSH
91571: EMPTY
91572: LIST
91573: LIST
91574: PUSH
91575: LD_INT 2
91577: PUSH
91578: LD_INT 1
91580: NEG
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 3
91588: PUSH
91589: LD_INT 0
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 3
91598: PUSH
91599: LD_INT 1
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: LD_INT 1
91608: PUSH
91609: LD_INT 3
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 0
91618: PUSH
91619: LD_INT 3
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 1
91628: NEG
91629: PUSH
91630: LD_INT 2
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: PUSH
91637: LD_INT 2
91639: NEG
91640: PUSH
91641: LD_INT 1
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 3
91650: NEG
91651: PUSH
91652: LD_INT 0
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PUSH
91659: LD_INT 3
91661: NEG
91662: PUSH
91663: LD_INT 1
91665: NEG
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: EMPTY
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91702: LD_ADDR_VAR 0 47
91706: PUSH
91707: LD_INT 0
91709: PUSH
91710: LD_INT 0
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 0
91719: PUSH
91720: LD_INT 1
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 1
91730: PUSH
91731: LD_INT 0
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 1
91740: PUSH
91741: LD_INT 1
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: LD_INT 0
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 1
91760: NEG
91761: PUSH
91762: LD_INT 0
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: LD_INT 1
91783: NEG
91784: PUSH
91785: LD_INT 2
91787: NEG
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 0
91795: PUSH
91796: LD_INT 2
91798: NEG
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: PUSH
91804: LD_INT 1
91806: PUSH
91807: LD_INT 1
91809: NEG
91810: PUSH
91811: EMPTY
91812: LIST
91813: LIST
91814: PUSH
91815: LD_INT 2
91817: NEG
91818: PUSH
91819: LD_INT 1
91821: NEG
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: PUSH
91827: LD_INT 2
91829: NEG
91830: PUSH
91831: LD_INT 2
91833: NEG
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91853: LD_ADDR_VAR 0 48
91857: PUSH
91858: LD_INT 0
91860: PUSH
91861: LD_INT 0
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 0
91870: PUSH
91871: LD_INT 1
91873: NEG
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: LD_INT 1
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: LD_INT 1
91891: PUSH
91892: LD_INT 1
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PUSH
91899: LD_INT 0
91901: PUSH
91902: LD_INT 1
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 1
91911: NEG
91912: PUSH
91913: LD_INT 0
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 1
91922: NEG
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: NEG
91935: PUSH
91936: LD_INT 2
91938: NEG
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: PUSH
91944: LD_INT 0
91946: PUSH
91947: LD_INT 2
91949: NEG
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: LD_INT 1
91957: PUSH
91958: LD_INT 1
91960: NEG
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: LD_INT 0
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 2
91978: PUSH
91979: LD_INT 1
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: EMPTY
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92000: LD_ADDR_VAR 0 49
92004: PUSH
92005: LD_INT 0
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 0
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 1
92028: PUSH
92029: LD_INT 0
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 1
92038: PUSH
92039: LD_INT 1
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 0
92048: PUSH
92049: LD_INT 1
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: PUSH
92056: LD_INT 1
92058: NEG
92059: PUSH
92060: LD_INT 0
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: LD_INT 1
92069: NEG
92070: PUSH
92071: LD_INT 1
92073: NEG
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 1
92081: PUSH
92082: LD_INT 1
92084: NEG
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PUSH
92090: LD_INT 2
92092: PUSH
92093: LD_INT 0
92095: PUSH
92096: EMPTY
92097: LIST
92098: LIST
92099: PUSH
92100: LD_INT 2
92102: PUSH
92103: LD_INT 1
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: PUSH
92110: LD_INT 2
92112: PUSH
92113: LD_INT 2
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: LD_INT 1
92122: PUSH
92123: LD_INT 2
92125: PUSH
92126: EMPTY
92127: LIST
92128: LIST
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92144: LD_ADDR_VAR 0 50
92148: PUSH
92149: LD_INT 0
92151: PUSH
92152: LD_INT 0
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 0
92161: PUSH
92162: LD_INT 1
92164: NEG
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PUSH
92170: LD_INT 1
92172: PUSH
92173: LD_INT 0
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 1
92182: PUSH
92183: LD_INT 1
92185: PUSH
92186: EMPTY
92187: LIST
92188: LIST
92189: PUSH
92190: LD_INT 0
92192: PUSH
92193: LD_INT 1
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: LD_INT 1
92202: NEG
92203: PUSH
92204: LD_INT 0
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 1
92213: NEG
92214: PUSH
92215: LD_INT 1
92217: NEG
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 2
92225: PUSH
92226: LD_INT 1
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 2
92235: PUSH
92236: LD_INT 2
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: LD_INT 1
92245: PUSH
92246: LD_INT 2
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 0
92255: PUSH
92256: LD_INT 2
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 1
92265: NEG
92266: PUSH
92267: LD_INT 1
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92288: LD_ADDR_VAR 0 51
92292: PUSH
92293: LD_INT 0
92295: PUSH
92296: LD_INT 0
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 0
92305: PUSH
92306: LD_INT 1
92308: NEG
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 1
92316: PUSH
92317: LD_INT 0
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 1
92326: PUSH
92327: LD_INT 1
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 0
92336: PUSH
92337: LD_INT 1
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 1
92346: NEG
92347: PUSH
92348: LD_INT 0
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: LD_INT 1
92361: NEG
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 1
92369: PUSH
92370: LD_INT 2
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 0
92379: PUSH
92380: LD_INT 2
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 1
92389: NEG
92390: PUSH
92391: LD_INT 1
92393: PUSH
92394: EMPTY
92395: LIST
92396: LIST
92397: PUSH
92398: LD_INT 2
92400: NEG
92401: PUSH
92402: LD_INT 0
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 2
92411: NEG
92412: PUSH
92413: LD_INT 1
92415: NEG
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92435: LD_ADDR_VAR 0 52
92439: PUSH
92440: LD_INT 0
92442: PUSH
92443: LD_INT 0
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 0
92452: PUSH
92453: LD_INT 1
92455: NEG
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 1
92463: PUSH
92464: LD_INT 0
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: LD_INT 1
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 0
92483: PUSH
92484: LD_INT 1
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 1
92493: NEG
92494: PUSH
92495: LD_INT 0
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: PUSH
92502: LD_INT 1
92504: NEG
92505: PUSH
92506: LD_INT 1
92508: NEG
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 1
92516: NEG
92517: PUSH
92518: LD_INT 2
92520: NEG
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: LD_INT 1
92528: NEG
92529: PUSH
92530: LD_INT 1
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 2
92539: NEG
92540: PUSH
92541: LD_INT 0
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: LD_INT 2
92550: NEG
92551: PUSH
92552: LD_INT 1
92554: NEG
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 2
92562: NEG
92563: PUSH
92564: LD_INT 2
92566: NEG
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92586: LD_ADDR_VAR 0 53
92590: PUSH
92591: LD_INT 0
92593: PUSH
92594: LD_INT 0
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 0
92603: PUSH
92604: LD_INT 1
92606: NEG
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: LD_INT 1
92614: PUSH
92615: LD_INT 0
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 1
92624: PUSH
92625: LD_INT 1
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 0
92634: PUSH
92635: LD_INT 1
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 1
92644: NEG
92645: PUSH
92646: LD_INT 0
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: LD_INT 1
92655: NEG
92656: PUSH
92657: LD_INT 1
92659: NEG
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: NEG
92668: PUSH
92669: LD_INT 2
92671: NEG
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 0
92679: PUSH
92680: LD_INT 2
92682: NEG
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: PUSH
92691: LD_INT 1
92693: NEG
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: LD_INT 0
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 2
92711: PUSH
92712: LD_INT 1
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: LD_INT 2
92721: PUSH
92722: LD_INT 2
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: PUSH
92729: LD_INT 1
92731: PUSH
92732: LD_INT 2
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 0
92741: PUSH
92742: LD_INT 2
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 1
92751: NEG
92752: PUSH
92753: LD_INT 1
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 2
92762: NEG
92763: PUSH
92764: LD_INT 0
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 2
92773: NEG
92774: PUSH
92775: LD_INT 1
92777: NEG
92778: PUSH
92779: EMPTY
92780: LIST
92781: LIST
92782: PUSH
92783: LD_INT 2
92785: NEG
92786: PUSH
92787: LD_INT 2
92789: NEG
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92816: LD_ADDR_VAR 0 54
92820: PUSH
92821: LD_INT 0
92823: PUSH
92824: LD_INT 0
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 0
92833: PUSH
92834: LD_INT 1
92836: NEG
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: PUSH
92842: LD_INT 1
92844: PUSH
92845: LD_INT 0
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 1
92854: PUSH
92855: LD_INT 1
92857: PUSH
92858: EMPTY
92859: LIST
92860: LIST
92861: PUSH
92862: LD_INT 0
92864: PUSH
92865: LD_INT 1
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 1
92874: NEG
92875: PUSH
92876: LD_INT 0
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 1
92885: NEG
92886: PUSH
92887: LD_INT 1
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 1
92897: NEG
92898: PUSH
92899: LD_INT 2
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: LD_INT 2
92912: NEG
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 1
92920: PUSH
92921: LD_INT 1
92923: NEG
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 2
92931: PUSH
92932: LD_INT 0
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: LD_INT 2
92941: PUSH
92942: LD_INT 1
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 2
92951: PUSH
92952: LD_INT 2
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 1
92961: PUSH
92962: LD_INT 2
92964: PUSH
92965: EMPTY
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 0
92971: PUSH
92972: LD_INT 2
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 1
92981: NEG
92982: PUSH
92983: LD_INT 1
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 2
92992: NEG
92993: PUSH
92994: LD_INT 0
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 2
93003: NEG
93004: PUSH
93005: LD_INT 1
93007: NEG
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: PUSH
93013: LD_INT 2
93015: NEG
93016: PUSH
93017: LD_INT 2
93019: NEG
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93046: LD_ADDR_VAR 0 55
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: LD_INT 0
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 0
93063: PUSH
93064: LD_INT 1
93066: NEG
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: PUSH
93075: LD_INT 0
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 1
93084: PUSH
93085: LD_INT 1
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 0
93094: PUSH
93095: LD_INT 1
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 1
93104: NEG
93105: PUSH
93106: LD_INT 0
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 1
93115: NEG
93116: PUSH
93117: LD_INT 1
93119: NEG
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 1
93127: NEG
93128: PUSH
93129: LD_INT 2
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 0
93139: PUSH
93140: LD_INT 2
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 1
93150: PUSH
93151: LD_INT 1
93153: NEG
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: LD_INT 2
93161: PUSH
93162: LD_INT 0
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: PUSH
93169: LD_INT 2
93171: PUSH
93172: LD_INT 1
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: LD_INT 2
93181: PUSH
93182: LD_INT 2
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 1
93191: PUSH
93192: LD_INT 2
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 0
93201: PUSH
93202: LD_INT 2
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 1
93211: NEG
93212: PUSH
93213: LD_INT 1
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 2
93222: NEG
93223: PUSH
93224: LD_INT 0
93226: PUSH
93227: EMPTY
93228: LIST
93229: LIST
93230: PUSH
93231: LD_INT 2
93233: NEG
93234: PUSH
93235: LD_INT 1
93237: NEG
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 2
93245: NEG
93246: PUSH
93247: LD_INT 2
93249: NEG
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93276: LD_ADDR_VAR 0 56
93280: PUSH
93281: LD_INT 0
93283: PUSH
93284: LD_INT 0
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: PUSH
93291: LD_INT 0
93293: PUSH
93294: LD_INT 1
93296: NEG
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 1
93304: PUSH
93305: LD_INT 0
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 1
93314: PUSH
93315: LD_INT 1
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 0
93324: PUSH
93325: LD_INT 1
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 1
93334: NEG
93335: PUSH
93336: LD_INT 0
93338: PUSH
93339: EMPTY
93340: LIST
93341: LIST
93342: PUSH
93343: LD_INT 1
93345: NEG
93346: PUSH
93347: LD_INT 1
93349: NEG
93350: PUSH
93351: EMPTY
93352: LIST
93353: LIST
93354: PUSH
93355: LD_INT 1
93357: NEG
93358: PUSH
93359: LD_INT 2
93361: NEG
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: PUSH
93367: LD_INT 0
93369: PUSH
93370: LD_INT 2
93372: NEG
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 1
93380: PUSH
93381: LD_INT 1
93383: NEG
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: LD_INT 2
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 2
93401: PUSH
93402: LD_INT 1
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 2
93411: PUSH
93412: LD_INT 2
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: LD_INT 1
93421: PUSH
93422: LD_INT 2
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: PUSH
93429: LD_INT 0
93431: PUSH
93432: LD_INT 2
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: PUSH
93439: LD_INT 1
93441: NEG
93442: PUSH
93443: LD_INT 1
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: LD_INT 2
93452: NEG
93453: PUSH
93454: LD_INT 0
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 2
93463: NEG
93464: PUSH
93465: LD_INT 1
93467: NEG
93468: PUSH
93469: EMPTY
93470: LIST
93471: LIST
93472: PUSH
93473: LD_INT 2
93475: NEG
93476: PUSH
93477: LD_INT 2
93479: NEG
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93506: LD_ADDR_VAR 0 57
93510: PUSH
93511: LD_INT 0
93513: PUSH
93514: LD_INT 0
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 0
93523: PUSH
93524: LD_INT 1
93526: NEG
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 1
93534: PUSH
93535: LD_INT 0
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 1
93544: PUSH
93545: LD_INT 1
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: LD_INT 0
93554: PUSH
93555: LD_INT 1
93557: PUSH
93558: EMPTY
93559: LIST
93560: LIST
93561: PUSH
93562: LD_INT 1
93564: NEG
93565: PUSH
93566: LD_INT 0
93568: PUSH
93569: EMPTY
93570: LIST
93571: LIST
93572: PUSH
93573: LD_INT 1
93575: NEG
93576: PUSH
93577: LD_INT 1
93579: NEG
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PUSH
93585: LD_INT 1
93587: NEG
93588: PUSH
93589: LD_INT 2
93591: NEG
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 0
93599: PUSH
93600: LD_INT 2
93602: NEG
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: PUSH
93611: LD_INT 1
93613: NEG
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: PUSH
93622: LD_INT 0
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 2
93631: PUSH
93632: LD_INT 1
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 2
93641: PUSH
93642: LD_INT 2
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_INT 1
93651: PUSH
93652: LD_INT 2
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 0
93661: PUSH
93662: LD_INT 2
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 1
93671: NEG
93672: PUSH
93673: LD_INT 1
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 2
93682: NEG
93683: PUSH
93684: LD_INT 0
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 2
93693: NEG
93694: PUSH
93695: LD_INT 1
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 2
93705: NEG
93706: PUSH
93707: LD_INT 2
93709: NEG
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93736: LD_ADDR_VAR 0 58
93740: PUSH
93741: LD_INT 0
93743: PUSH
93744: LD_INT 0
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 0
93753: PUSH
93754: LD_INT 1
93756: NEG
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 1
93764: PUSH
93765: LD_INT 0
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: LD_INT 1
93774: PUSH
93775: LD_INT 1
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: LD_INT 0
93784: PUSH
93785: LD_INT 1
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 1
93794: NEG
93795: PUSH
93796: LD_INT 0
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 1
93805: NEG
93806: PUSH
93807: LD_INT 1
93809: NEG
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 1
93817: NEG
93818: PUSH
93819: LD_INT 2
93821: NEG
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 0
93829: PUSH
93830: LD_INT 2
93832: NEG
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: LD_INT 1
93840: PUSH
93841: LD_INT 1
93843: NEG
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 2
93851: PUSH
93852: LD_INT 0
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 2
93861: PUSH
93862: LD_INT 1
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: LD_INT 2
93871: PUSH
93872: LD_INT 2
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: PUSH
93879: LD_INT 1
93881: PUSH
93882: LD_INT 2
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: LD_INT 0
93891: PUSH
93892: LD_INT 2
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 1
93901: NEG
93902: PUSH
93903: LD_INT 1
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 2
93912: NEG
93913: PUSH
93914: LD_INT 0
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 2
93923: NEG
93924: PUSH
93925: LD_INT 1
93927: NEG
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 2
93935: NEG
93936: PUSH
93937: LD_INT 2
93939: NEG
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93966: LD_ADDR_VAR 0 59
93970: PUSH
93971: LD_INT 0
93973: PUSH
93974: LD_INT 0
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 0
93983: PUSH
93984: LD_INT 1
93986: NEG
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 1
93994: PUSH
93995: LD_INT 0
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PUSH
94002: LD_INT 1
94004: PUSH
94005: LD_INT 1
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: LD_INT 0
94014: PUSH
94015: LD_INT 1
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: PUSH
94022: LD_INT 1
94024: NEG
94025: PUSH
94026: LD_INT 0
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 1
94035: NEG
94036: PUSH
94037: LD_INT 1
94039: NEG
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94054: LD_ADDR_VAR 0 60
94058: PUSH
94059: LD_INT 0
94061: PUSH
94062: LD_INT 0
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 0
94071: PUSH
94072: LD_INT 1
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 1
94082: PUSH
94083: LD_INT 0
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: PUSH
94090: LD_INT 1
94092: PUSH
94093: LD_INT 1
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 0
94102: PUSH
94103: LD_INT 1
94105: PUSH
94106: EMPTY
94107: LIST
94108: LIST
94109: PUSH
94110: LD_INT 1
94112: NEG
94113: PUSH
94114: LD_INT 0
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 1
94123: NEG
94124: PUSH
94125: LD_INT 1
94127: NEG
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94142: LD_ADDR_VAR 0 61
94146: PUSH
94147: LD_INT 0
94149: PUSH
94150: LD_INT 0
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 0
94159: PUSH
94160: LD_INT 1
94162: NEG
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 1
94170: PUSH
94171: LD_INT 0
94173: PUSH
94174: EMPTY
94175: LIST
94176: LIST
94177: PUSH
94178: LD_INT 1
94180: PUSH
94181: LD_INT 1
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: PUSH
94188: LD_INT 0
94190: PUSH
94191: LD_INT 1
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 1
94200: NEG
94201: PUSH
94202: LD_INT 0
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 1
94211: NEG
94212: PUSH
94213: LD_INT 1
94215: NEG
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94230: LD_ADDR_VAR 0 62
94234: PUSH
94235: LD_INT 0
94237: PUSH
94238: LD_INT 0
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 0
94247: PUSH
94248: LD_INT 1
94250: NEG
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: PUSH
94256: LD_INT 1
94258: PUSH
94259: LD_INT 0
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 1
94268: PUSH
94269: LD_INT 1
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 0
94278: PUSH
94279: LD_INT 1
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_INT 1
94288: NEG
94289: PUSH
94290: LD_INT 0
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 1
94299: NEG
94300: PUSH
94301: LD_INT 1
94303: NEG
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94318: LD_ADDR_VAR 0 63
94322: PUSH
94323: LD_INT 0
94325: PUSH
94326: LD_INT 0
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 0
94335: PUSH
94336: LD_INT 1
94338: NEG
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: LD_INT 0
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 1
94356: PUSH
94357: LD_INT 1
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 0
94366: PUSH
94367: LD_INT 1
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: LD_INT 1
94376: NEG
94377: PUSH
94378: LD_INT 0
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 1
94387: NEG
94388: PUSH
94389: LD_INT 1
94391: NEG
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94406: LD_ADDR_VAR 0 64
94410: PUSH
94411: LD_INT 0
94413: PUSH
94414: LD_INT 0
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 0
94423: PUSH
94424: LD_INT 1
94426: NEG
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 1
94434: PUSH
94435: LD_INT 0
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 1
94444: PUSH
94445: LD_INT 1
94447: PUSH
94448: EMPTY
94449: LIST
94450: LIST
94451: PUSH
94452: LD_INT 0
94454: PUSH
94455: LD_INT 1
94457: PUSH
94458: EMPTY
94459: LIST
94460: LIST
94461: PUSH
94462: LD_INT 1
94464: NEG
94465: PUSH
94466: LD_INT 0
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 1
94475: NEG
94476: PUSH
94477: LD_INT 1
94479: NEG
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: ST_TO_ADDR
// end ; 1 :
94494: GO 100391
94496: LD_INT 1
94498: DOUBLE
94499: EQUAL
94500: IFTRUE 94504
94502: GO 97127
94504: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94505: LD_ADDR_VAR 0 11
94509: PUSH
94510: LD_INT 1
94512: NEG
94513: PUSH
94514: LD_INT 3
94516: NEG
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 0
94524: PUSH
94525: LD_INT 3
94527: NEG
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 1
94535: PUSH
94536: LD_INT 2
94538: NEG
94539: PUSH
94540: EMPTY
94541: LIST
94542: LIST
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: LIST
94548: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94549: LD_ADDR_VAR 0 12
94553: PUSH
94554: LD_INT 2
94556: PUSH
94557: LD_INT 1
94559: NEG
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 3
94567: PUSH
94568: LD_INT 0
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: LD_INT 3
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: EMPTY
94586: LIST
94587: LIST
94588: LIST
94589: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94590: LD_ADDR_VAR 0 13
94594: PUSH
94595: LD_INT 3
94597: PUSH
94598: LD_INT 2
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 3
94607: PUSH
94608: LD_INT 3
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 2
94617: PUSH
94618: LD_INT 3
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: LIST
94629: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94630: LD_ADDR_VAR 0 14
94634: PUSH
94635: LD_INT 1
94637: PUSH
94638: LD_INT 3
94640: PUSH
94641: EMPTY
94642: LIST
94643: LIST
94644: PUSH
94645: LD_INT 0
94647: PUSH
94648: LD_INT 3
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 1
94657: NEG
94658: PUSH
94659: LD_INT 2
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: LIST
94670: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94671: LD_ADDR_VAR 0 15
94675: PUSH
94676: LD_INT 2
94678: NEG
94679: PUSH
94680: LD_INT 1
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 3
94689: NEG
94690: PUSH
94691: LD_INT 0
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 3
94700: NEG
94701: PUSH
94702: LD_INT 1
94704: NEG
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: LIST
94714: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94715: LD_ADDR_VAR 0 16
94719: PUSH
94720: LD_INT 2
94722: NEG
94723: PUSH
94724: LD_INT 3
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 3
94734: NEG
94735: PUSH
94736: LD_INT 2
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 3
94746: NEG
94747: PUSH
94748: LD_INT 3
94750: NEG
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: LIST
94760: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94761: LD_ADDR_VAR 0 17
94765: PUSH
94766: LD_INT 1
94768: NEG
94769: PUSH
94770: LD_INT 3
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 0
94780: PUSH
94781: LD_INT 3
94783: NEG
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 1
94791: PUSH
94792: LD_INT 2
94794: NEG
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: LIST
94804: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94805: LD_ADDR_VAR 0 18
94809: PUSH
94810: LD_INT 2
94812: PUSH
94813: LD_INT 1
94815: NEG
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 3
94823: PUSH
94824: LD_INT 0
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 3
94833: PUSH
94834: LD_INT 1
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: LIST
94845: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94846: LD_ADDR_VAR 0 19
94850: PUSH
94851: LD_INT 3
94853: PUSH
94854: LD_INT 2
94856: PUSH
94857: EMPTY
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 3
94863: PUSH
94864: LD_INT 3
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 2
94873: PUSH
94874: LD_INT 3
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94886: LD_ADDR_VAR 0 20
94890: PUSH
94891: LD_INT 1
94893: PUSH
94894: LD_INT 3
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 0
94903: PUSH
94904: LD_INT 3
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 1
94913: NEG
94914: PUSH
94915: LD_INT 2
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: LIST
94926: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94927: LD_ADDR_VAR 0 21
94931: PUSH
94932: LD_INT 2
94934: NEG
94935: PUSH
94936: LD_INT 1
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: PUSH
94943: LD_INT 3
94945: NEG
94946: PUSH
94947: LD_INT 0
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PUSH
94954: LD_INT 3
94956: NEG
94957: PUSH
94958: LD_INT 1
94960: NEG
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: LIST
94970: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94971: LD_ADDR_VAR 0 22
94975: PUSH
94976: LD_INT 2
94978: NEG
94979: PUSH
94980: LD_INT 3
94982: NEG
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 3
94990: NEG
94991: PUSH
94992: LD_INT 2
94994: NEG
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 3
95002: NEG
95003: PUSH
95004: LD_INT 3
95006: NEG
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: LIST
95016: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
95017: LD_ADDR_VAR 0 23
95021: PUSH
95022: LD_INT 0
95024: PUSH
95025: LD_INT 3
95027: NEG
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 1
95035: NEG
95036: PUSH
95037: LD_INT 4
95039: NEG
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 1
95047: PUSH
95048: LD_INT 3
95050: NEG
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: LIST
95060: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
95061: LD_ADDR_VAR 0 24
95065: PUSH
95066: LD_INT 3
95068: PUSH
95069: LD_INT 0
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 3
95078: PUSH
95079: LD_INT 1
95081: NEG
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 4
95089: PUSH
95090: LD_INT 1
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: LIST
95101: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
95102: LD_ADDR_VAR 0 25
95106: PUSH
95107: LD_INT 3
95109: PUSH
95110: LD_INT 3
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 4
95119: PUSH
95120: LD_INT 3
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 3
95129: PUSH
95130: LD_INT 4
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: LIST
95141: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
95142: LD_ADDR_VAR 0 26
95146: PUSH
95147: LD_INT 0
95149: PUSH
95150: LD_INT 3
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 1
95159: PUSH
95160: LD_INT 4
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 1
95169: NEG
95170: PUSH
95171: LD_INT 3
95173: PUSH
95174: EMPTY
95175: LIST
95176: LIST
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: LIST
95182: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
95183: LD_ADDR_VAR 0 27
95187: PUSH
95188: LD_INT 3
95190: NEG
95191: PUSH
95192: LD_INT 0
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 3
95201: NEG
95202: PUSH
95203: LD_INT 1
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: LD_INT 4
95212: NEG
95213: PUSH
95214: LD_INT 1
95216: NEG
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: LIST
95226: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
95227: LD_ADDR_VAR 0 28
95231: PUSH
95232: LD_INT 3
95234: NEG
95235: PUSH
95236: LD_INT 3
95238: NEG
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 3
95246: NEG
95247: PUSH
95248: LD_INT 4
95250: NEG
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 4
95258: NEG
95259: PUSH
95260: LD_INT 3
95262: NEG
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: EMPTY
95269: LIST
95270: LIST
95271: LIST
95272: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
95273: LD_ADDR_VAR 0 29
95277: PUSH
95278: LD_INT 1
95280: NEG
95281: PUSH
95282: LD_INT 3
95284: NEG
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 0
95292: PUSH
95293: LD_INT 3
95295: NEG
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: PUSH
95301: LD_INT 1
95303: PUSH
95304: LD_INT 2
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 1
95314: NEG
95315: PUSH
95316: LD_INT 4
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 0
95326: PUSH
95327: LD_INT 4
95329: NEG
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 1
95337: PUSH
95338: LD_INT 3
95340: NEG
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 1
95348: NEG
95349: PUSH
95350: LD_INT 5
95352: NEG
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 0
95360: PUSH
95361: LD_INT 5
95363: NEG
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 1
95371: PUSH
95372: LD_INT 4
95374: NEG
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 1
95382: NEG
95383: PUSH
95384: LD_INT 6
95386: NEG
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 0
95394: PUSH
95395: LD_INT 6
95397: NEG
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 1
95405: PUSH
95406: LD_INT 5
95408: NEG
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
95428: LD_ADDR_VAR 0 30
95432: PUSH
95433: LD_INT 2
95435: PUSH
95436: LD_INT 1
95438: NEG
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: PUSH
95444: LD_INT 3
95446: PUSH
95447: LD_INT 0
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 3
95456: PUSH
95457: LD_INT 1
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: PUSH
95464: LD_INT 3
95466: PUSH
95467: LD_INT 1
95469: NEG
95470: PUSH
95471: EMPTY
95472: LIST
95473: LIST
95474: PUSH
95475: LD_INT 4
95477: PUSH
95478: LD_INT 0
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 4
95487: PUSH
95488: LD_INT 1
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 4
95497: PUSH
95498: LD_INT 1
95500: NEG
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: PUSH
95506: LD_INT 5
95508: PUSH
95509: LD_INT 0
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: PUSH
95516: LD_INT 5
95518: PUSH
95519: LD_INT 1
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PUSH
95526: LD_INT 5
95528: PUSH
95529: LD_INT 1
95531: NEG
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 6
95539: PUSH
95540: LD_INT 0
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 6
95549: PUSH
95550: LD_INT 1
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
95571: LD_ADDR_VAR 0 31
95575: PUSH
95576: LD_INT 3
95578: PUSH
95579: LD_INT 2
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: PUSH
95586: LD_INT 3
95588: PUSH
95589: LD_INT 3
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 2
95598: PUSH
95599: LD_INT 3
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: PUSH
95606: LD_INT 4
95608: PUSH
95609: LD_INT 3
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 4
95618: PUSH
95619: LD_INT 4
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 3
95628: PUSH
95629: LD_INT 4
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: PUSH
95636: LD_INT 5
95638: PUSH
95639: LD_INT 4
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 5
95648: PUSH
95649: LD_INT 5
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: LD_INT 4
95658: PUSH
95659: LD_INT 5
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: LD_INT 6
95668: PUSH
95669: LD_INT 5
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 6
95678: PUSH
95679: LD_INT 6
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: PUSH
95686: LD_INT 5
95688: PUSH
95689: LD_INT 6
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
95710: LD_ADDR_VAR 0 32
95714: PUSH
95715: LD_INT 1
95717: PUSH
95718: LD_INT 3
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 0
95727: PUSH
95728: LD_INT 3
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 1
95737: NEG
95738: PUSH
95739: LD_INT 2
95741: PUSH
95742: EMPTY
95743: LIST
95744: LIST
95745: PUSH
95746: LD_INT 1
95748: PUSH
95749: LD_INT 4
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: LD_INT 0
95758: PUSH
95759: LD_INT 4
95761: PUSH
95762: EMPTY
95763: LIST
95764: LIST
95765: PUSH
95766: LD_INT 1
95768: NEG
95769: PUSH
95770: LD_INT 3
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: LD_INT 5
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 0
95789: PUSH
95790: LD_INT 5
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 1
95799: NEG
95800: PUSH
95801: LD_INT 4
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: PUSH
95808: LD_INT 1
95810: PUSH
95811: LD_INT 6
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: PUSH
95818: LD_INT 0
95820: PUSH
95821: LD_INT 6
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: PUSH
95828: LD_INT 1
95830: NEG
95831: PUSH
95832: LD_INT 5
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
95853: LD_ADDR_VAR 0 33
95857: PUSH
95858: LD_INT 2
95860: NEG
95861: PUSH
95862: LD_INT 1
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 3
95871: NEG
95872: PUSH
95873: LD_INT 0
95875: PUSH
95876: EMPTY
95877: LIST
95878: LIST
95879: PUSH
95880: LD_INT 3
95882: NEG
95883: PUSH
95884: LD_INT 1
95886: NEG
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: PUSH
95892: LD_INT 3
95894: NEG
95895: PUSH
95896: LD_INT 1
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: PUSH
95903: LD_INT 4
95905: NEG
95906: PUSH
95907: LD_INT 0
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: LD_INT 4
95916: NEG
95917: PUSH
95918: LD_INT 1
95920: NEG
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: PUSH
95926: LD_INT 4
95928: NEG
95929: PUSH
95930: LD_INT 1
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 5
95939: NEG
95940: PUSH
95941: LD_INT 0
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 5
95950: NEG
95951: PUSH
95952: LD_INT 1
95954: NEG
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 5
95962: NEG
95963: PUSH
95964: LD_INT 1
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 6
95973: NEG
95974: PUSH
95975: LD_INT 0
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: PUSH
95982: LD_INT 6
95984: NEG
95985: PUSH
95986: LD_INT 1
95988: NEG
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
96008: LD_ADDR_VAR 0 34
96012: PUSH
96013: LD_INT 2
96015: NEG
96016: PUSH
96017: LD_INT 3
96019: NEG
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 3
96027: NEG
96028: PUSH
96029: LD_INT 2
96031: NEG
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 3
96039: NEG
96040: PUSH
96041: LD_INT 3
96043: NEG
96044: PUSH
96045: EMPTY
96046: LIST
96047: LIST
96048: PUSH
96049: LD_INT 3
96051: NEG
96052: PUSH
96053: LD_INT 4
96055: NEG
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: PUSH
96061: LD_INT 4
96063: NEG
96064: PUSH
96065: LD_INT 3
96067: NEG
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: PUSH
96073: LD_INT 4
96075: NEG
96076: PUSH
96077: LD_INT 4
96079: NEG
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 4
96087: NEG
96088: PUSH
96089: LD_INT 5
96091: NEG
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 5
96099: NEG
96100: PUSH
96101: LD_INT 4
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 5
96111: NEG
96112: PUSH
96113: LD_INT 5
96115: NEG
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 5
96123: NEG
96124: PUSH
96125: LD_INT 6
96127: NEG
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 6
96135: NEG
96136: PUSH
96137: LD_INT 5
96139: NEG
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 6
96147: NEG
96148: PUSH
96149: LD_INT 6
96151: NEG
96152: PUSH
96153: EMPTY
96154: LIST
96155: LIST
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
96171: LD_ADDR_VAR 0 41
96175: PUSH
96176: LD_INT 0
96178: PUSH
96179: LD_INT 2
96181: NEG
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PUSH
96187: LD_INT 1
96189: NEG
96190: PUSH
96191: LD_INT 3
96193: NEG
96194: PUSH
96195: EMPTY
96196: LIST
96197: LIST
96198: PUSH
96199: LD_INT 1
96201: PUSH
96202: LD_INT 2
96204: NEG
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: EMPTY
96211: LIST
96212: LIST
96213: LIST
96214: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
96215: LD_ADDR_VAR 0 42
96219: PUSH
96220: LD_INT 2
96222: PUSH
96223: LD_INT 0
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: PUSH
96230: LD_INT 2
96232: PUSH
96233: LD_INT 1
96235: NEG
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 3
96243: PUSH
96244: LD_INT 1
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: LIST
96255: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
96256: LD_ADDR_VAR 0 43
96260: PUSH
96261: LD_INT 2
96263: PUSH
96264: LD_INT 2
96266: PUSH
96267: EMPTY
96268: LIST
96269: LIST
96270: PUSH
96271: LD_INT 3
96273: PUSH
96274: LD_INT 2
96276: PUSH
96277: EMPTY
96278: LIST
96279: LIST
96280: PUSH
96281: LD_INT 2
96283: PUSH
96284: LD_INT 3
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: LIST
96295: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
96296: LD_ADDR_VAR 0 44
96300: PUSH
96301: LD_INT 0
96303: PUSH
96304: LD_INT 2
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 1
96313: PUSH
96314: LD_INT 3
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 1
96323: NEG
96324: PUSH
96325: LD_INT 2
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: LIST
96336: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
96337: LD_ADDR_VAR 0 45
96341: PUSH
96342: LD_INT 2
96344: NEG
96345: PUSH
96346: LD_INT 0
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 2
96355: NEG
96356: PUSH
96357: LD_INT 1
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 3
96366: NEG
96367: PUSH
96368: LD_INT 1
96370: NEG
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: LIST
96380: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
96381: LD_ADDR_VAR 0 46
96385: PUSH
96386: LD_INT 2
96388: NEG
96389: PUSH
96390: LD_INT 2
96392: NEG
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 2
96400: NEG
96401: PUSH
96402: LD_INT 3
96404: NEG
96405: PUSH
96406: EMPTY
96407: LIST
96408: LIST
96409: PUSH
96410: LD_INT 3
96412: NEG
96413: PUSH
96414: LD_INT 2
96416: NEG
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: LIST
96426: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
96427: LD_ADDR_VAR 0 47
96431: PUSH
96432: LD_INT 2
96434: NEG
96435: PUSH
96436: LD_INT 3
96438: NEG
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 1
96446: NEG
96447: PUSH
96448: LD_INT 3
96450: NEG
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
96460: LD_ADDR_VAR 0 48
96464: PUSH
96465: LD_INT 1
96467: PUSH
96468: LD_INT 2
96470: NEG
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_INT 2
96478: PUSH
96479: LD_INT 1
96481: NEG
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
96491: LD_ADDR_VAR 0 49
96495: PUSH
96496: LD_INT 3
96498: PUSH
96499: LD_INT 1
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 3
96508: PUSH
96509: LD_INT 2
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: EMPTY
96517: LIST
96518: LIST
96519: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
96520: LD_ADDR_VAR 0 50
96524: PUSH
96525: LD_INT 2
96527: PUSH
96528: LD_INT 3
96530: PUSH
96531: EMPTY
96532: LIST
96533: LIST
96534: PUSH
96535: LD_INT 1
96537: PUSH
96538: LD_INT 3
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
96549: LD_ADDR_VAR 0 51
96553: PUSH
96554: LD_INT 1
96556: NEG
96557: PUSH
96558: LD_INT 2
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 2
96567: NEG
96568: PUSH
96569: LD_INT 1
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
96580: LD_ADDR_VAR 0 52
96584: PUSH
96585: LD_INT 3
96587: NEG
96588: PUSH
96589: LD_INT 1
96591: NEG
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 3
96599: NEG
96600: PUSH
96601: LD_INT 2
96603: NEG
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96613: LD_ADDR_VAR 0 53
96617: PUSH
96618: LD_INT 1
96620: NEG
96621: PUSH
96622: LD_INT 3
96624: NEG
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 0
96632: PUSH
96633: LD_INT 3
96635: NEG
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: LD_INT 1
96643: PUSH
96644: LD_INT 2
96646: NEG
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: LIST
96656: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96657: LD_ADDR_VAR 0 54
96661: PUSH
96662: LD_INT 2
96664: PUSH
96665: LD_INT 1
96667: NEG
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 3
96675: PUSH
96676: LD_INT 0
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: PUSH
96683: LD_INT 3
96685: PUSH
96686: LD_INT 1
96688: PUSH
96689: EMPTY
96690: LIST
96691: LIST
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: LIST
96697: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96698: LD_ADDR_VAR 0 55
96702: PUSH
96703: LD_INT 3
96705: PUSH
96706: LD_INT 2
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 3
96715: PUSH
96716: LD_INT 3
96718: PUSH
96719: EMPTY
96720: LIST
96721: LIST
96722: PUSH
96723: LD_INT 2
96725: PUSH
96726: LD_INT 3
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: LIST
96737: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96738: LD_ADDR_VAR 0 56
96742: PUSH
96743: LD_INT 1
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: PUSH
96753: LD_INT 0
96755: PUSH
96756: LD_INT 3
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: PUSH
96763: LD_INT 1
96765: NEG
96766: PUSH
96767: LD_INT 2
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: LIST
96778: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96779: LD_ADDR_VAR 0 57
96783: PUSH
96784: LD_INT 2
96786: NEG
96787: PUSH
96788: LD_INT 1
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: LD_INT 3
96797: NEG
96798: PUSH
96799: LD_INT 0
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 3
96808: NEG
96809: PUSH
96810: LD_INT 1
96812: NEG
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: EMPTY
96819: LIST
96820: LIST
96821: LIST
96822: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96823: LD_ADDR_VAR 0 58
96827: PUSH
96828: LD_INT 2
96830: NEG
96831: PUSH
96832: LD_INT 3
96834: NEG
96835: PUSH
96836: EMPTY
96837: LIST
96838: LIST
96839: PUSH
96840: LD_INT 3
96842: NEG
96843: PUSH
96844: LD_INT 2
96846: NEG
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: LD_INT 3
96854: NEG
96855: PUSH
96856: LD_INT 3
96858: NEG
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: LIST
96868: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
96869: LD_ADDR_VAR 0 59
96873: PUSH
96874: LD_INT 1
96876: NEG
96877: PUSH
96878: LD_INT 2
96880: NEG
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 0
96888: PUSH
96889: LD_INT 2
96891: NEG
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: LD_INT 1
96899: PUSH
96900: LD_INT 1
96902: NEG
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: EMPTY
96909: LIST
96910: LIST
96911: LIST
96912: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
96913: LD_ADDR_VAR 0 60
96917: PUSH
96918: LD_INT 1
96920: PUSH
96921: LD_INT 1
96923: NEG
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: PUSH
96929: LD_INT 2
96931: PUSH
96932: LD_INT 0
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: PUSH
96939: LD_INT 2
96941: PUSH
96942: LD_INT 1
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: LIST
96953: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
96954: LD_ADDR_VAR 0 61
96958: PUSH
96959: LD_INT 2
96961: PUSH
96962: LD_INT 1
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: PUSH
96969: LD_INT 2
96971: PUSH
96972: LD_INT 2
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: LD_INT 1
96981: PUSH
96982: LD_INT 2
96984: PUSH
96985: EMPTY
96986: LIST
96987: LIST
96988: PUSH
96989: EMPTY
96990: LIST
96991: LIST
96992: LIST
96993: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
96994: LD_ADDR_VAR 0 62
96998: PUSH
96999: LD_INT 1
97001: PUSH
97002: LD_INT 2
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PUSH
97009: LD_INT 0
97011: PUSH
97012: LD_INT 2
97014: PUSH
97015: EMPTY
97016: LIST
97017: LIST
97018: PUSH
97019: LD_INT 1
97021: NEG
97022: PUSH
97023: LD_INT 1
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: LIST
97034: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
97035: LD_ADDR_VAR 0 63
97039: PUSH
97040: LD_INT 1
97042: NEG
97043: PUSH
97044: LD_INT 1
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 2
97053: NEG
97054: PUSH
97055: LD_INT 0
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: LD_INT 2
97064: NEG
97065: PUSH
97066: LD_INT 1
97068: NEG
97069: PUSH
97070: EMPTY
97071: LIST
97072: LIST
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: LIST
97078: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
97079: LD_ADDR_VAR 0 64
97083: PUSH
97084: LD_INT 1
97086: NEG
97087: PUSH
97088: LD_INT 2
97090: NEG
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 2
97098: NEG
97099: PUSH
97100: LD_INT 1
97102: NEG
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: PUSH
97108: LD_INT 2
97110: NEG
97111: PUSH
97112: LD_INT 2
97114: NEG
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: LIST
97124: ST_TO_ADDR
// end ; 2 :
97125: GO 100391
97127: LD_INT 2
97129: DOUBLE
97130: EQUAL
97131: IFTRUE 97135
97133: GO 100390
97135: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
97136: LD_ADDR_VAR 0 29
97140: PUSH
97141: LD_INT 4
97143: PUSH
97144: LD_INT 0
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: PUSH
97151: LD_INT 4
97153: PUSH
97154: LD_INT 1
97156: NEG
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: LD_INT 5
97164: PUSH
97165: LD_INT 0
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 5
97174: PUSH
97175: LD_INT 1
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 4
97184: PUSH
97185: LD_INT 1
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 3
97194: PUSH
97195: LD_INT 0
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: PUSH
97202: LD_INT 3
97204: PUSH
97205: LD_INT 1
97207: NEG
97208: PUSH
97209: EMPTY
97210: LIST
97211: LIST
97212: PUSH
97213: LD_INT 3
97215: PUSH
97216: LD_INT 2
97218: NEG
97219: PUSH
97220: EMPTY
97221: LIST
97222: LIST
97223: PUSH
97224: LD_INT 5
97226: PUSH
97227: LD_INT 2
97229: PUSH
97230: EMPTY
97231: LIST
97232: LIST
97233: PUSH
97234: LD_INT 3
97236: PUSH
97237: LD_INT 3
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PUSH
97244: LD_INT 3
97246: PUSH
97247: LD_INT 2
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 4
97256: PUSH
97257: LD_INT 3
97259: PUSH
97260: EMPTY
97261: LIST
97262: LIST
97263: PUSH
97264: LD_INT 4
97266: PUSH
97267: LD_INT 4
97269: PUSH
97270: EMPTY
97271: LIST
97272: LIST
97273: PUSH
97274: LD_INT 3
97276: PUSH
97277: LD_INT 4
97279: PUSH
97280: EMPTY
97281: LIST
97282: LIST
97283: PUSH
97284: LD_INT 2
97286: PUSH
97287: LD_INT 3
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: PUSH
97294: LD_INT 2
97296: PUSH
97297: LD_INT 2
97299: PUSH
97300: EMPTY
97301: LIST
97302: LIST
97303: PUSH
97304: LD_INT 4
97306: PUSH
97307: LD_INT 2
97309: PUSH
97310: EMPTY
97311: LIST
97312: LIST
97313: PUSH
97314: LD_INT 2
97316: PUSH
97317: LD_INT 4
97319: PUSH
97320: EMPTY
97321: LIST
97322: LIST
97323: PUSH
97324: LD_INT 0
97326: PUSH
97327: LD_INT 4
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: PUSH
97334: LD_INT 0
97336: PUSH
97337: LD_INT 3
97339: PUSH
97340: EMPTY
97341: LIST
97342: LIST
97343: PUSH
97344: LD_INT 1
97346: PUSH
97347: LD_INT 4
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: PUSH
97354: LD_INT 1
97356: PUSH
97357: LD_INT 5
97359: PUSH
97360: EMPTY
97361: LIST
97362: LIST
97363: PUSH
97364: LD_INT 0
97366: PUSH
97367: LD_INT 5
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 1
97376: NEG
97377: PUSH
97378: LD_INT 4
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 1
97387: NEG
97388: PUSH
97389: LD_INT 3
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 2
97398: PUSH
97399: LD_INT 5
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: PUSH
97406: LD_INT 2
97408: NEG
97409: PUSH
97410: LD_INT 3
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 3
97419: NEG
97420: PUSH
97421: LD_INT 0
97423: PUSH
97424: EMPTY
97425: LIST
97426: LIST
97427: PUSH
97428: LD_INT 3
97430: NEG
97431: PUSH
97432: LD_INT 1
97434: NEG
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 2
97442: NEG
97443: PUSH
97444: LD_INT 0
97446: PUSH
97447: EMPTY
97448: LIST
97449: LIST
97450: PUSH
97451: LD_INT 2
97453: NEG
97454: PUSH
97455: LD_INT 1
97457: PUSH
97458: EMPTY
97459: LIST
97460: LIST
97461: PUSH
97462: LD_INT 3
97464: NEG
97465: PUSH
97466: LD_INT 1
97468: PUSH
97469: EMPTY
97470: LIST
97471: LIST
97472: PUSH
97473: LD_INT 4
97475: NEG
97476: PUSH
97477: LD_INT 0
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PUSH
97484: LD_INT 4
97486: NEG
97487: PUSH
97488: LD_INT 1
97490: NEG
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_INT 4
97498: NEG
97499: PUSH
97500: LD_INT 2
97502: NEG
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: PUSH
97508: LD_INT 2
97510: NEG
97511: PUSH
97512: LD_INT 2
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 4
97521: NEG
97522: PUSH
97523: LD_INT 4
97525: NEG
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 4
97533: NEG
97534: PUSH
97535: LD_INT 5
97537: NEG
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 3
97545: NEG
97546: PUSH
97547: LD_INT 4
97549: NEG
97550: PUSH
97551: EMPTY
97552: LIST
97553: LIST
97554: PUSH
97555: LD_INT 3
97557: NEG
97558: PUSH
97559: LD_INT 3
97561: NEG
97562: PUSH
97563: EMPTY
97564: LIST
97565: LIST
97566: PUSH
97567: LD_INT 4
97569: NEG
97570: PUSH
97571: LD_INT 3
97573: NEG
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PUSH
97579: LD_INT 5
97581: NEG
97582: PUSH
97583: LD_INT 4
97585: NEG
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: LD_INT 5
97593: NEG
97594: PUSH
97595: LD_INT 5
97597: NEG
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: PUSH
97603: LD_INT 3
97605: NEG
97606: PUSH
97607: LD_INT 5
97609: NEG
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: PUSH
97615: LD_INT 5
97617: NEG
97618: PUSH
97619: LD_INT 3
97621: NEG
97622: PUSH
97623: EMPTY
97624: LIST
97625: LIST
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
97674: LD_ADDR_VAR 0 30
97678: PUSH
97679: LD_INT 4
97681: PUSH
97682: LD_INT 4
97684: PUSH
97685: EMPTY
97686: LIST
97687: LIST
97688: PUSH
97689: LD_INT 4
97691: PUSH
97692: LD_INT 3
97694: PUSH
97695: EMPTY
97696: LIST
97697: LIST
97698: PUSH
97699: LD_INT 5
97701: PUSH
97702: LD_INT 4
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: PUSH
97709: LD_INT 5
97711: PUSH
97712: LD_INT 5
97714: PUSH
97715: EMPTY
97716: LIST
97717: LIST
97718: PUSH
97719: LD_INT 4
97721: PUSH
97722: LD_INT 5
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: PUSH
97729: LD_INT 3
97731: PUSH
97732: LD_INT 4
97734: PUSH
97735: EMPTY
97736: LIST
97737: LIST
97738: PUSH
97739: LD_INT 3
97741: PUSH
97742: LD_INT 3
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: PUSH
97749: LD_INT 5
97751: PUSH
97752: LD_INT 3
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: LD_INT 3
97761: PUSH
97762: LD_INT 5
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: LD_INT 0
97771: PUSH
97772: LD_INT 3
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: LD_INT 0
97781: PUSH
97782: LD_INT 2
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: PUSH
97789: LD_INT 1
97791: PUSH
97792: LD_INT 3
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: PUSH
97799: LD_INT 1
97801: PUSH
97802: LD_INT 4
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: LD_INT 0
97811: PUSH
97812: LD_INT 4
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: PUSH
97819: LD_INT 1
97821: NEG
97822: PUSH
97823: LD_INT 3
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 1
97832: NEG
97833: PUSH
97834: LD_INT 2
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: PUSH
97841: LD_INT 2
97843: PUSH
97844: LD_INT 4
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 2
97853: NEG
97854: PUSH
97855: LD_INT 2
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 4
97864: NEG
97865: PUSH
97866: LD_INT 0
97868: PUSH
97869: EMPTY
97870: LIST
97871: LIST
97872: PUSH
97873: LD_INT 4
97875: NEG
97876: PUSH
97877: LD_INT 1
97879: NEG
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: PUSH
97885: LD_INT 3
97887: NEG
97888: PUSH
97889: LD_INT 0
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: LD_INT 3
97898: NEG
97899: PUSH
97900: LD_INT 1
97902: PUSH
97903: EMPTY
97904: LIST
97905: LIST
97906: PUSH
97907: LD_INT 4
97909: NEG
97910: PUSH
97911: LD_INT 1
97913: PUSH
97914: EMPTY
97915: LIST
97916: LIST
97917: PUSH
97918: LD_INT 5
97920: NEG
97921: PUSH
97922: LD_INT 0
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: PUSH
97929: LD_INT 5
97931: NEG
97932: PUSH
97933: LD_INT 1
97935: NEG
97936: PUSH
97937: EMPTY
97938: LIST
97939: LIST
97940: PUSH
97941: LD_INT 5
97943: NEG
97944: PUSH
97945: LD_INT 2
97947: NEG
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PUSH
97953: LD_INT 3
97955: NEG
97956: PUSH
97957: LD_INT 2
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PUSH
97964: LD_INT 3
97966: NEG
97967: PUSH
97968: LD_INT 3
97970: NEG
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: LD_INT 3
97978: NEG
97979: PUSH
97980: LD_INT 4
97982: NEG
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: PUSH
97988: LD_INT 2
97990: NEG
97991: PUSH
97992: LD_INT 3
97994: NEG
97995: PUSH
97996: EMPTY
97997: LIST
97998: LIST
97999: PUSH
98000: LD_INT 2
98002: NEG
98003: PUSH
98004: LD_INT 2
98006: NEG
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: PUSH
98012: LD_INT 3
98014: NEG
98015: PUSH
98016: LD_INT 2
98018: NEG
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: PUSH
98024: LD_INT 4
98026: NEG
98027: PUSH
98028: LD_INT 3
98030: NEG
98031: PUSH
98032: EMPTY
98033: LIST
98034: LIST
98035: PUSH
98036: LD_INT 4
98038: NEG
98039: PUSH
98040: LD_INT 4
98042: NEG
98043: PUSH
98044: EMPTY
98045: LIST
98046: LIST
98047: PUSH
98048: LD_INT 2
98050: NEG
98051: PUSH
98052: LD_INT 4
98054: NEG
98055: PUSH
98056: EMPTY
98057: LIST
98058: LIST
98059: PUSH
98060: LD_INT 4
98062: NEG
98063: PUSH
98064: LD_INT 2
98066: NEG
98067: PUSH
98068: EMPTY
98069: LIST
98070: LIST
98071: PUSH
98072: LD_INT 0
98074: PUSH
98075: LD_INT 4
98077: NEG
98078: PUSH
98079: EMPTY
98080: LIST
98081: LIST
98082: PUSH
98083: LD_INT 0
98085: PUSH
98086: LD_INT 5
98088: NEG
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: PUSH
98094: LD_INT 1
98096: PUSH
98097: LD_INT 4
98099: NEG
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: LD_INT 1
98107: PUSH
98108: LD_INT 3
98110: NEG
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: LD_INT 0
98118: PUSH
98119: LD_INT 3
98121: NEG
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: PUSH
98127: LD_INT 1
98129: NEG
98130: PUSH
98131: LD_INT 4
98133: NEG
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: PUSH
98139: LD_INT 1
98141: NEG
98142: PUSH
98143: LD_INT 5
98145: NEG
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 2
98153: PUSH
98154: LD_INT 3
98156: NEG
98157: PUSH
98158: EMPTY
98159: LIST
98160: LIST
98161: PUSH
98162: LD_INT 2
98164: NEG
98165: PUSH
98166: LD_INT 5
98168: NEG
98169: PUSH
98170: EMPTY
98171: LIST
98172: LIST
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
98221: LD_ADDR_VAR 0 31
98225: PUSH
98226: LD_INT 0
98228: PUSH
98229: LD_INT 4
98231: PUSH
98232: EMPTY
98233: LIST
98234: LIST
98235: PUSH
98236: LD_INT 0
98238: PUSH
98239: LD_INT 3
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: LD_INT 1
98248: PUSH
98249: LD_INT 4
98251: PUSH
98252: EMPTY
98253: LIST
98254: LIST
98255: PUSH
98256: LD_INT 1
98258: PUSH
98259: LD_INT 5
98261: PUSH
98262: EMPTY
98263: LIST
98264: LIST
98265: PUSH
98266: LD_INT 0
98268: PUSH
98269: LD_INT 5
98271: PUSH
98272: EMPTY
98273: LIST
98274: LIST
98275: PUSH
98276: LD_INT 1
98278: NEG
98279: PUSH
98280: LD_INT 4
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: PUSH
98287: LD_INT 1
98289: NEG
98290: PUSH
98291: LD_INT 3
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: PUSH
98298: LD_INT 2
98300: PUSH
98301: LD_INT 5
98303: PUSH
98304: EMPTY
98305: LIST
98306: LIST
98307: PUSH
98308: LD_INT 2
98310: NEG
98311: PUSH
98312: LD_INT 3
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: PUSH
98319: LD_INT 3
98321: NEG
98322: PUSH
98323: LD_INT 0
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: PUSH
98330: LD_INT 3
98332: NEG
98333: PUSH
98334: LD_INT 1
98336: NEG
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: PUSH
98342: LD_INT 2
98344: NEG
98345: PUSH
98346: LD_INT 0
98348: PUSH
98349: EMPTY
98350: LIST
98351: LIST
98352: PUSH
98353: LD_INT 2
98355: NEG
98356: PUSH
98357: LD_INT 1
98359: PUSH
98360: EMPTY
98361: LIST
98362: LIST
98363: PUSH
98364: LD_INT 3
98366: NEG
98367: PUSH
98368: LD_INT 1
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: PUSH
98375: LD_INT 4
98377: NEG
98378: PUSH
98379: LD_INT 0
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: PUSH
98386: LD_INT 4
98388: NEG
98389: PUSH
98390: LD_INT 1
98392: NEG
98393: PUSH
98394: EMPTY
98395: LIST
98396: LIST
98397: PUSH
98398: LD_INT 4
98400: NEG
98401: PUSH
98402: LD_INT 2
98404: NEG
98405: PUSH
98406: EMPTY
98407: LIST
98408: LIST
98409: PUSH
98410: LD_INT 2
98412: NEG
98413: PUSH
98414: LD_INT 2
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PUSH
98421: LD_INT 4
98423: NEG
98424: PUSH
98425: LD_INT 4
98427: NEG
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: PUSH
98433: LD_INT 4
98435: NEG
98436: PUSH
98437: LD_INT 5
98439: NEG
98440: PUSH
98441: EMPTY
98442: LIST
98443: LIST
98444: PUSH
98445: LD_INT 3
98447: NEG
98448: PUSH
98449: LD_INT 4
98451: NEG
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: PUSH
98457: LD_INT 3
98459: NEG
98460: PUSH
98461: LD_INT 3
98463: NEG
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 4
98471: NEG
98472: PUSH
98473: LD_INT 3
98475: NEG
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: LD_INT 5
98483: NEG
98484: PUSH
98485: LD_INT 4
98487: NEG
98488: PUSH
98489: EMPTY
98490: LIST
98491: LIST
98492: PUSH
98493: LD_INT 5
98495: NEG
98496: PUSH
98497: LD_INT 5
98499: NEG
98500: PUSH
98501: EMPTY
98502: LIST
98503: LIST
98504: PUSH
98505: LD_INT 3
98507: NEG
98508: PUSH
98509: LD_INT 5
98511: NEG
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: LD_INT 5
98519: NEG
98520: PUSH
98521: LD_INT 3
98523: NEG
98524: PUSH
98525: EMPTY
98526: LIST
98527: LIST
98528: PUSH
98529: LD_INT 0
98531: PUSH
98532: LD_INT 3
98534: NEG
98535: PUSH
98536: EMPTY
98537: LIST
98538: LIST
98539: PUSH
98540: LD_INT 0
98542: PUSH
98543: LD_INT 4
98545: NEG
98546: PUSH
98547: EMPTY
98548: LIST
98549: LIST
98550: PUSH
98551: LD_INT 1
98553: PUSH
98554: LD_INT 3
98556: NEG
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: LD_INT 1
98564: PUSH
98565: LD_INT 2
98567: NEG
98568: PUSH
98569: EMPTY
98570: LIST
98571: LIST
98572: PUSH
98573: LD_INT 0
98575: PUSH
98576: LD_INT 2
98578: NEG
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: PUSH
98584: LD_INT 1
98586: NEG
98587: PUSH
98588: LD_INT 3
98590: NEG
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: PUSH
98596: LD_INT 1
98598: NEG
98599: PUSH
98600: LD_INT 4
98602: NEG
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PUSH
98608: LD_INT 2
98610: PUSH
98611: LD_INT 2
98613: NEG
98614: PUSH
98615: EMPTY
98616: LIST
98617: LIST
98618: PUSH
98619: LD_INT 2
98621: NEG
98622: PUSH
98623: LD_INT 4
98625: NEG
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: LD_INT 4
98633: PUSH
98634: LD_INT 0
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: PUSH
98641: LD_INT 4
98643: PUSH
98644: LD_INT 1
98646: NEG
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: PUSH
98652: LD_INT 5
98654: PUSH
98655: LD_INT 0
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: PUSH
98662: LD_INT 5
98664: PUSH
98665: LD_INT 1
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 4
98674: PUSH
98675: LD_INT 1
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: LD_INT 3
98684: PUSH
98685: LD_INT 0
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: PUSH
98692: LD_INT 3
98694: PUSH
98695: LD_INT 1
98697: NEG
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: PUSH
98703: LD_INT 3
98705: PUSH
98706: LD_INT 2
98708: NEG
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: PUSH
98714: LD_INT 5
98716: PUSH
98717: LD_INT 2
98719: PUSH
98720: EMPTY
98721: LIST
98722: LIST
98723: PUSH
98724: EMPTY
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
98771: LD_ADDR_VAR 0 32
98775: PUSH
98776: LD_INT 4
98778: NEG
98779: PUSH
98780: LD_INT 0
98782: PUSH
98783: EMPTY
98784: LIST
98785: LIST
98786: PUSH
98787: LD_INT 4
98789: NEG
98790: PUSH
98791: LD_INT 1
98793: NEG
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PUSH
98799: LD_INT 3
98801: NEG
98802: PUSH
98803: LD_INT 0
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 3
98812: NEG
98813: PUSH
98814: LD_INT 1
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 4
98823: NEG
98824: PUSH
98825: LD_INT 1
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 5
98834: NEG
98835: PUSH
98836: LD_INT 0
98838: PUSH
98839: EMPTY
98840: LIST
98841: LIST
98842: PUSH
98843: LD_INT 5
98845: NEG
98846: PUSH
98847: LD_INT 1
98849: NEG
98850: PUSH
98851: EMPTY
98852: LIST
98853: LIST
98854: PUSH
98855: LD_INT 5
98857: NEG
98858: PUSH
98859: LD_INT 2
98861: NEG
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_INT 3
98869: NEG
98870: PUSH
98871: LD_INT 2
98873: PUSH
98874: EMPTY
98875: LIST
98876: LIST
98877: PUSH
98878: LD_INT 3
98880: NEG
98881: PUSH
98882: LD_INT 3
98884: NEG
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: PUSH
98890: LD_INT 3
98892: NEG
98893: PUSH
98894: LD_INT 4
98896: NEG
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: PUSH
98902: LD_INT 2
98904: NEG
98905: PUSH
98906: LD_INT 3
98908: NEG
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 2
98916: NEG
98917: PUSH
98918: LD_INT 2
98920: NEG
98921: PUSH
98922: EMPTY
98923: LIST
98924: LIST
98925: PUSH
98926: LD_INT 3
98928: NEG
98929: PUSH
98930: LD_INT 2
98932: NEG
98933: PUSH
98934: EMPTY
98935: LIST
98936: LIST
98937: PUSH
98938: LD_INT 4
98940: NEG
98941: PUSH
98942: LD_INT 3
98944: NEG
98945: PUSH
98946: EMPTY
98947: LIST
98948: LIST
98949: PUSH
98950: LD_INT 4
98952: NEG
98953: PUSH
98954: LD_INT 4
98956: NEG
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 2
98964: NEG
98965: PUSH
98966: LD_INT 4
98968: NEG
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: PUSH
98974: LD_INT 4
98976: NEG
98977: PUSH
98978: LD_INT 2
98980: NEG
98981: PUSH
98982: EMPTY
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 0
98988: PUSH
98989: LD_INT 4
98991: NEG
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: PUSH
98997: LD_INT 0
98999: PUSH
99000: LD_INT 5
99002: NEG
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: PUSH
99008: LD_INT 1
99010: PUSH
99011: LD_INT 4
99013: NEG
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: PUSH
99019: LD_INT 1
99021: PUSH
99022: LD_INT 3
99024: NEG
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: PUSH
99030: LD_INT 0
99032: PUSH
99033: LD_INT 3
99035: NEG
99036: PUSH
99037: EMPTY
99038: LIST
99039: LIST
99040: PUSH
99041: LD_INT 1
99043: NEG
99044: PUSH
99045: LD_INT 4
99047: NEG
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: PUSH
99053: LD_INT 1
99055: NEG
99056: PUSH
99057: LD_INT 5
99059: NEG
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: PUSH
99065: LD_INT 2
99067: PUSH
99068: LD_INT 3
99070: NEG
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: LD_INT 2
99078: NEG
99079: PUSH
99080: LD_INT 5
99082: NEG
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: PUSH
99088: LD_INT 3
99090: PUSH
99091: LD_INT 0
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: PUSH
99098: LD_INT 3
99100: PUSH
99101: LD_INT 1
99103: NEG
99104: PUSH
99105: EMPTY
99106: LIST
99107: LIST
99108: PUSH
99109: LD_INT 4
99111: PUSH
99112: LD_INT 0
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: PUSH
99119: LD_INT 4
99121: PUSH
99122: LD_INT 1
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 3
99131: PUSH
99132: LD_INT 1
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 2
99141: PUSH
99142: LD_INT 0
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 2
99151: PUSH
99152: LD_INT 1
99154: NEG
99155: PUSH
99156: EMPTY
99157: LIST
99158: LIST
99159: PUSH
99160: LD_INT 2
99162: PUSH
99163: LD_INT 2
99165: NEG
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: PUSH
99171: LD_INT 4
99173: PUSH
99174: LD_INT 2
99176: PUSH
99177: EMPTY
99178: LIST
99179: LIST
99180: PUSH
99181: LD_INT 4
99183: PUSH
99184: LD_INT 4
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: PUSH
99191: LD_INT 4
99193: PUSH
99194: LD_INT 3
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: LD_INT 5
99203: PUSH
99204: LD_INT 4
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 5
99213: PUSH
99214: LD_INT 5
99216: PUSH
99217: EMPTY
99218: LIST
99219: LIST
99220: PUSH
99221: LD_INT 4
99223: PUSH
99224: LD_INT 5
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: PUSH
99231: LD_INT 3
99233: PUSH
99234: LD_INT 4
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PUSH
99241: LD_INT 3
99243: PUSH
99244: LD_INT 3
99246: PUSH
99247: EMPTY
99248: LIST
99249: LIST
99250: PUSH
99251: LD_INT 5
99253: PUSH
99254: LD_INT 3
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: PUSH
99261: LD_INT 3
99263: PUSH
99264: LD_INT 5
99266: PUSH
99267: EMPTY
99268: LIST
99269: LIST
99270: PUSH
99271: EMPTY
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: LIST
99285: LIST
99286: LIST
99287: LIST
99288: LIST
99289: LIST
99290: LIST
99291: LIST
99292: LIST
99293: LIST
99294: LIST
99295: LIST
99296: LIST
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: LIST
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
99318: LD_ADDR_VAR 0 33
99322: PUSH
99323: LD_INT 4
99325: NEG
99326: PUSH
99327: LD_INT 4
99329: NEG
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PUSH
99335: LD_INT 4
99337: NEG
99338: PUSH
99339: LD_INT 5
99341: NEG
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: PUSH
99347: LD_INT 3
99349: NEG
99350: PUSH
99351: LD_INT 4
99353: NEG
99354: PUSH
99355: EMPTY
99356: LIST
99357: LIST
99358: PUSH
99359: LD_INT 3
99361: NEG
99362: PUSH
99363: LD_INT 3
99365: NEG
99366: PUSH
99367: EMPTY
99368: LIST
99369: LIST
99370: PUSH
99371: LD_INT 4
99373: NEG
99374: PUSH
99375: LD_INT 3
99377: NEG
99378: PUSH
99379: EMPTY
99380: LIST
99381: LIST
99382: PUSH
99383: LD_INT 5
99385: NEG
99386: PUSH
99387: LD_INT 4
99389: NEG
99390: PUSH
99391: EMPTY
99392: LIST
99393: LIST
99394: PUSH
99395: LD_INT 5
99397: NEG
99398: PUSH
99399: LD_INT 5
99401: NEG
99402: PUSH
99403: EMPTY
99404: LIST
99405: LIST
99406: PUSH
99407: LD_INT 3
99409: NEG
99410: PUSH
99411: LD_INT 5
99413: NEG
99414: PUSH
99415: EMPTY
99416: LIST
99417: LIST
99418: PUSH
99419: LD_INT 5
99421: NEG
99422: PUSH
99423: LD_INT 3
99425: NEG
99426: PUSH
99427: EMPTY
99428: LIST
99429: LIST
99430: PUSH
99431: LD_INT 0
99433: PUSH
99434: LD_INT 3
99436: NEG
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: PUSH
99442: LD_INT 0
99444: PUSH
99445: LD_INT 4
99447: NEG
99448: PUSH
99449: EMPTY
99450: LIST
99451: LIST
99452: PUSH
99453: LD_INT 1
99455: PUSH
99456: LD_INT 3
99458: NEG
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: PUSH
99464: LD_INT 1
99466: PUSH
99467: LD_INT 2
99469: NEG
99470: PUSH
99471: EMPTY
99472: LIST
99473: LIST
99474: PUSH
99475: LD_INT 0
99477: PUSH
99478: LD_INT 2
99480: NEG
99481: PUSH
99482: EMPTY
99483: LIST
99484: LIST
99485: PUSH
99486: LD_INT 1
99488: NEG
99489: PUSH
99490: LD_INT 3
99492: NEG
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PUSH
99498: LD_INT 1
99500: NEG
99501: PUSH
99502: LD_INT 4
99504: NEG
99505: PUSH
99506: EMPTY
99507: LIST
99508: LIST
99509: PUSH
99510: LD_INT 2
99512: PUSH
99513: LD_INT 2
99515: NEG
99516: PUSH
99517: EMPTY
99518: LIST
99519: LIST
99520: PUSH
99521: LD_INT 2
99523: NEG
99524: PUSH
99525: LD_INT 4
99527: NEG
99528: PUSH
99529: EMPTY
99530: LIST
99531: LIST
99532: PUSH
99533: LD_INT 4
99535: PUSH
99536: LD_INT 0
99538: PUSH
99539: EMPTY
99540: LIST
99541: LIST
99542: PUSH
99543: LD_INT 4
99545: PUSH
99546: LD_INT 1
99548: NEG
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: PUSH
99554: LD_INT 5
99556: PUSH
99557: LD_INT 0
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: LD_INT 5
99566: PUSH
99567: LD_INT 1
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: LD_INT 4
99576: PUSH
99577: LD_INT 1
99579: PUSH
99580: EMPTY
99581: LIST
99582: LIST
99583: PUSH
99584: LD_INT 3
99586: PUSH
99587: LD_INT 0
99589: PUSH
99590: EMPTY
99591: LIST
99592: LIST
99593: PUSH
99594: LD_INT 3
99596: PUSH
99597: LD_INT 1
99599: NEG
99600: PUSH
99601: EMPTY
99602: LIST
99603: LIST
99604: PUSH
99605: LD_INT 3
99607: PUSH
99608: LD_INT 2
99610: NEG
99611: PUSH
99612: EMPTY
99613: LIST
99614: LIST
99615: PUSH
99616: LD_INT 5
99618: PUSH
99619: LD_INT 2
99621: PUSH
99622: EMPTY
99623: LIST
99624: LIST
99625: PUSH
99626: LD_INT 3
99628: PUSH
99629: LD_INT 3
99631: PUSH
99632: EMPTY
99633: LIST
99634: LIST
99635: PUSH
99636: LD_INT 3
99638: PUSH
99639: LD_INT 2
99641: PUSH
99642: EMPTY
99643: LIST
99644: LIST
99645: PUSH
99646: LD_INT 4
99648: PUSH
99649: LD_INT 3
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: PUSH
99656: LD_INT 4
99658: PUSH
99659: LD_INT 4
99661: PUSH
99662: EMPTY
99663: LIST
99664: LIST
99665: PUSH
99666: LD_INT 3
99668: PUSH
99669: LD_INT 4
99671: PUSH
99672: EMPTY
99673: LIST
99674: LIST
99675: PUSH
99676: LD_INT 2
99678: PUSH
99679: LD_INT 3
99681: PUSH
99682: EMPTY
99683: LIST
99684: LIST
99685: PUSH
99686: LD_INT 2
99688: PUSH
99689: LD_INT 2
99691: PUSH
99692: EMPTY
99693: LIST
99694: LIST
99695: PUSH
99696: LD_INT 4
99698: PUSH
99699: LD_INT 2
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: PUSH
99706: LD_INT 2
99708: PUSH
99709: LD_INT 4
99711: PUSH
99712: EMPTY
99713: LIST
99714: LIST
99715: PUSH
99716: LD_INT 0
99718: PUSH
99719: LD_INT 4
99721: PUSH
99722: EMPTY
99723: LIST
99724: LIST
99725: PUSH
99726: LD_INT 0
99728: PUSH
99729: LD_INT 3
99731: PUSH
99732: EMPTY
99733: LIST
99734: LIST
99735: PUSH
99736: LD_INT 1
99738: PUSH
99739: LD_INT 4
99741: PUSH
99742: EMPTY
99743: LIST
99744: LIST
99745: PUSH
99746: LD_INT 1
99748: PUSH
99749: LD_INT 5
99751: PUSH
99752: EMPTY
99753: LIST
99754: LIST
99755: PUSH
99756: LD_INT 0
99758: PUSH
99759: LD_INT 5
99761: PUSH
99762: EMPTY
99763: LIST
99764: LIST
99765: PUSH
99766: LD_INT 1
99768: NEG
99769: PUSH
99770: LD_INT 4
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: PUSH
99777: LD_INT 1
99779: NEG
99780: PUSH
99781: LD_INT 3
99783: PUSH
99784: EMPTY
99785: LIST
99786: LIST
99787: PUSH
99788: LD_INT 2
99790: PUSH
99791: LD_INT 5
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: PUSH
99798: LD_INT 2
99800: NEG
99801: PUSH
99802: LD_INT 3
99804: PUSH
99805: EMPTY
99806: LIST
99807: LIST
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: LIST
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: LIST
99848: LIST
99849: LIST
99850: LIST
99851: LIST
99852: LIST
99853: LIST
99854: LIST
99855: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
99856: LD_ADDR_VAR 0 34
99860: PUSH
99861: LD_INT 0
99863: PUSH
99864: LD_INT 4
99866: NEG
99867: PUSH
99868: EMPTY
99869: LIST
99870: LIST
99871: PUSH
99872: LD_INT 0
99874: PUSH
99875: LD_INT 5
99877: NEG
99878: PUSH
99879: EMPTY
99880: LIST
99881: LIST
99882: PUSH
99883: LD_INT 1
99885: PUSH
99886: LD_INT 4
99888: NEG
99889: PUSH
99890: EMPTY
99891: LIST
99892: LIST
99893: PUSH
99894: LD_INT 1
99896: PUSH
99897: LD_INT 3
99899: NEG
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: PUSH
99905: LD_INT 0
99907: PUSH
99908: LD_INT 3
99910: NEG
99911: PUSH
99912: EMPTY
99913: LIST
99914: LIST
99915: PUSH
99916: LD_INT 1
99918: NEG
99919: PUSH
99920: LD_INT 4
99922: NEG
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PUSH
99928: LD_INT 1
99930: NEG
99931: PUSH
99932: LD_INT 5
99934: NEG
99935: PUSH
99936: EMPTY
99937: LIST
99938: LIST
99939: PUSH
99940: LD_INT 2
99942: PUSH
99943: LD_INT 3
99945: NEG
99946: PUSH
99947: EMPTY
99948: LIST
99949: LIST
99950: PUSH
99951: LD_INT 2
99953: NEG
99954: PUSH
99955: LD_INT 5
99957: NEG
99958: PUSH
99959: EMPTY
99960: LIST
99961: LIST
99962: PUSH
99963: LD_INT 3
99965: PUSH
99966: LD_INT 0
99968: PUSH
99969: EMPTY
99970: LIST
99971: LIST
99972: PUSH
99973: LD_INT 3
99975: PUSH
99976: LD_INT 1
99978: NEG
99979: PUSH
99980: EMPTY
99981: LIST
99982: LIST
99983: PUSH
99984: LD_INT 4
99986: PUSH
99987: LD_INT 0
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PUSH
99994: LD_INT 4
99996: PUSH
99997: LD_INT 1
99999: PUSH
100000: EMPTY
100001: LIST
100002: LIST
100003: PUSH
100004: LD_INT 3
100006: PUSH
100007: LD_INT 1
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: PUSH
100014: LD_INT 2
100016: PUSH
100017: LD_INT 0
100019: PUSH
100020: EMPTY
100021: LIST
100022: LIST
100023: PUSH
100024: LD_INT 2
100026: PUSH
100027: LD_INT 1
100029: NEG
100030: PUSH
100031: EMPTY
100032: LIST
100033: LIST
100034: PUSH
100035: LD_INT 2
100037: PUSH
100038: LD_INT 2
100040: NEG
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PUSH
100046: LD_INT 4
100048: PUSH
100049: LD_INT 2
100051: PUSH
100052: EMPTY
100053: LIST
100054: LIST
100055: PUSH
100056: LD_INT 4
100058: PUSH
100059: LD_INT 4
100061: PUSH
100062: EMPTY
100063: LIST
100064: LIST
100065: PUSH
100066: LD_INT 4
100068: PUSH
100069: LD_INT 3
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PUSH
100076: LD_INT 5
100078: PUSH
100079: LD_INT 4
100081: PUSH
100082: EMPTY
100083: LIST
100084: LIST
100085: PUSH
100086: LD_INT 5
100088: PUSH
100089: LD_INT 5
100091: PUSH
100092: EMPTY
100093: LIST
100094: LIST
100095: PUSH
100096: LD_INT 4
100098: PUSH
100099: LD_INT 5
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PUSH
100106: LD_INT 3
100108: PUSH
100109: LD_INT 4
100111: PUSH
100112: EMPTY
100113: LIST
100114: LIST
100115: PUSH
100116: LD_INT 3
100118: PUSH
100119: LD_INT 3
100121: PUSH
100122: EMPTY
100123: LIST
100124: LIST
100125: PUSH
100126: LD_INT 5
100128: PUSH
100129: LD_INT 3
100131: PUSH
100132: EMPTY
100133: LIST
100134: LIST
100135: PUSH
100136: LD_INT 3
100138: PUSH
100139: LD_INT 5
100141: PUSH
100142: EMPTY
100143: LIST
100144: LIST
100145: PUSH
100146: LD_INT 0
100148: PUSH
100149: LD_INT 3
100151: PUSH
100152: EMPTY
100153: LIST
100154: LIST
100155: PUSH
100156: LD_INT 0
100158: PUSH
100159: LD_INT 2
100161: PUSH
100162: EMPTY
100163: LIST
100164: LIST
100165: PUSH
100166: LD_INT 1
100168: PUSH
100169: LD_INT 3
100171: PUSH
100172: EMPTY
100173: LIST
100174: LIST
100175: PUSH
100176: LD_INT 1
100178: PUSH
100179: LD_INT 4
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: PUSH
100186: LD_INT 0
100188: PUSH
100189: LD_INT 4
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PUSH
100196: LD_INT 1
100198: NEG
100199: PUSH
100200: LD_INT 3
100202: PUSH
100203: EMPTY
100204: LIST
100205: LIST
100206: PUSH
100207: LD_INT 1
100209: NEG
100210: PUSH
100211: LD_INT 2
100213: PUSH
100214: EMPTY
100215: LIST
100216: LIST
100217: PUSH
100218: LD_INT 2
100220: PUSH
100221: LD_INT 4
100223: PUSH
100224: EMPTY
100225: LIST
100226: LIST
100227: PUSH
100228: LD_INT 2
100230: NEG
100231: PUSH
100232: LD_INT 2
100234: PUSH
100235: EMPTY
100236: LIST
100237: LIST
100238: PUSH
100239: LD_INT 4
100241: NEG
100242: PUSH
100243: LD_INT 0
100245: PUSH
100246: EMPTY
100247: LIST
100248: LIST
100249: PUSH
100250: LD_INT 4
100252: NEG
100253: PUSH
100254: LD_INT 1
100256: NEG
100257: PUSH
100258: EMPTY
100259: LIST
100260: LIST
100261: PUSH
100262: LD_INT 3
100264: NEG
100265: PUSH
100266: LD_INT 0
100268: PUSH
100269: EMPTY
100270: LIST
100271: LIST
100272: PUSH
100273: LD_INT 3
100275: NEG
100276: PUSH
100277: LD_INT 1
100279: PUSH
100280: EMPTY
100281: LIST
100282: LIST
100283: PUSH
100284: LD_INT 4
100286: NEG
100287: PUSH
100288: LD_INT 1
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: PUSH
100295: LD_INT 5
100297: NEG
100298: PUSH
100299: LD_INT 0
100301: PUSH
100302: EMPTY
100303: LIST
100304: LIST
100305: PUSH
100306: LD_INT 5
100308: NEG
100309: PUSH
100310: LD_INT 1
100312: NEG
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PUSH
100318: LD_INT 5
100320: NEG
100321: PUSH
100322: LD_INT 2
100324: NEG
100325: PUSH
100326: EMPTY
100327: LIST
100328: LIST
100329: PUSH
100330: LD_INT 3
100332: NEG
100333: PUSH
100334: LD_INT 2
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PUSH
100341: EMPTY
100342: LIST
100343: LIST
100344: LIST
100345: LIST
100346: LIST
100347: LIST
100348: LIST
100349: LIST
100350: LIST
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: LIST
100367: LIST
100368: LIST
100369: LIST
100370: LIST
100371: LIST
100372: LIST
100373: LIST
100374: LIST
100375: LIST
100376: LIST
100377: LIST
100378: LIST
100379: LIST
100380: LIST
100381: LIST
100382: LIST
100383: LIST
100384: LIST
100385: LIST
100386: LIST
100387: ST_TO_ADDR
// end ; end ;
100388: GO 100391
100390: POP
// case btype of b_depot , b_warehouse :
100391: LD_VAR 0 1
100395: PUSH
100396: LD_INT 0
100398: DOUBLE
100399: EQUAL
100400: IFTRUE 100410
100402: LD_INT 1
100404: DOUBLE
100405: EQUAL
100406: IFTRUE 100410
100408: GO 100611
100410: POP
// case nation of nation_american :
100411: LD_VAR 0 5
100415: PUSH
100416: LD_INT 1
100418: DOUBLE
100419: EQUAL
100420: IFTRUE 100424
100422: GO 100480
100424: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
100425: LD_ADDR_VAR 0 9
100429: PUSH
100430: LD_VAR 0 11
100434: PUSH
100435: LD_VAR 0 12
100439: PUSH
100440: LD_VAR 0 13
100444: PUSH
100445: LD_VAR 0 14
100449: PUSH
100450: LD_VAR 0 15
100454: PUSH
100455: LD_VAR 0 16
100459: PUSH
100460: EMPTY
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: PUSH
100468: LD_VAR 0 4
100472: PUSH
100473: LD_INT 1
100475: PLUS
100476: ARRAY
100477: ST_TO_ADDR
100478: GO 100609
100480: LD_INT 2
100482: DOUBLE
100483: EQUAL
100484: IFTRUE 100488
100486: GO 100544
100488: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
100489: LD_ADDR_VAR 0 9
100493: PUSH
100494: LD_VAR 0 17
100498: PUSH
100499: LD_VAR 0 18
100503: PUSH
100504: LD_VAR 0 19
100508: PUSH
100509: LD_VAR 0 20
100513: PUSH
100514: LD_VAR 0 21
100518: PUSH
100519: LD_VAR 0 22
100523: PUSH
100524: EMPTY
100525: LIST
100526: LIST
100527: LIST
100528: LIST
100529: LIST
100530: LIST
100531: PUSH
100532: LD_VAR 0 4
100536: PUSH
100537: LD_INT 1
100539: PLUS
100540: ARRAY
100541: ST_TO_ADDR
100542: GO 100609
100544: LD_INT 3
100546: DOUBLE
100547: EQUAL
100548: IFTRUE 100552
100550: GO 100608
100552: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
100553: LD_ADDR_VAR 0 9
100557: PUSH
100558: LD_VAR 0 23
100562: PUSH
100563: LD_VAR 0 24
100567: PUSH
100568: LD_VAR 0 25
100572: PUSH
100573: LD_VAR 0 26
100577: PUSH
100578: LD_VAR 0 27
100582: PUSH
100583: LD_VAR 0 28
100587: PUSH
100588: EMPTY
100589: LIST
100590: LIST
100591: LIST
100592: LIST
100593: LIST
100594: LIST
100595: PUSH
100596: LD_VAR 0 4
100600: PUSH
100601: LD_INT 1
100603: PLUS
100604: ARRAY
100605: ST_TO_ADDR
100606: GO 100609
100608: POP
100609: GO 101164
100611: LD_INT 2
100613: DOUBLE
100614: EQUAL
100615: IFTRUE 100625
100617: LD_INT 3
100619: DOUBLE
100620: EQUAL
100621: IFTRUE 100625
100623: GO 100681
100625: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
100626: LD_ADDR_VAR 0 9
100630: PUSH
100631: LD_VAR 0 29
100635: PUSH
100636: LD_VAR 0 30
100640: PUSH
100641: LD_VAR 0 31
100645: PUSH
100646: LD_VAR 0 32
100650: PUSH
100651: LD_VAR 0 33
100655: PUSH
100656: LD_VAR 0 34
100660: PUSH
100661: EMPTY
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: LIST
100668: PUSH
100669: LD_VAR 0 4
100673: PUSH
100674: LD_INT 1
100676: PLUS
100677: ARRAY
100678: ST_TO_ADDR
100679: GO 101164
100681: LD_INT 16
100683: DOUBLE
100684: EQUAL
100685: IFTRUE 100743
100687: LD_INT 17
100689: DOUBLE
100690: EQUAL
100691: IFTRUE 100743
100693: LD_INT 18
100695: DOUBLE
100696: EQUAL
100697: IFTRUE 100743
100699: LD_INT 19
100701: DOUBLE
100702: EQUAL
100703: IFTRUE 100743
100705: LD_INT 22
100707: DOUBLE
100708: EQUAL
100709: IFTRUE 100743
100711: LD_INT 20
100713: DOUBLE
100714: EQUAL
100715: IFTRUE 100743
100717: LD_INT 21
100719: DOUBLE
100720: EQUAL
100721: IFTRUE 100743
100723: LD_INT 23
100725: DOUBLE
100726: EQUAL
100727: IFTRUE 100743
100729: LD_INT 24
100731: DOUBLE
100732: EQUAL
100733: IFTRUE 100743
100735: LD_INT 25
100737: DOUBLE
100738: EQUAL
100739: IFTRUE 100743
100741: GO 100799
100743: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
100744: LD_ADDR_VAR 0 9
100748: PUSH
100749: LD_VAR 0 35
100753: PUSH
100754: LD_VAR 0 36
100758: PUSH
100759: LD_VAR 0 37
100763: PUSH
100764: LD_VAR 0 38
100768: PUSH
100769: LD_VAR 0 39
100773: PUSH
100774: LD_VAR 0 40
100778: PUSH
100779: EMPTY
100780: LIST
100781: LIST
100782: LIST
100783: LIST
100784: LIST
100785: LIST
100786: PUSH
100787: LD_VAR 0 4
100791: PUSH
100792: LD_INT 1
100794: PLUS
100795: ARRAY
100796: ST_TO_ADDR
100797: GO 101164
100799: LD_INT 6
100801: DOUBLE
100802: EQUAL
100803: IFTRUE 100855
100805: LD_INT 7
100807: DOUBLE
100808: EQUAL
100809: IFTRUE 100855
100811: LD_INT 8
100813: DOUBLE
100814: EQUAL
100815: IFTRUE 100855
100817: LD_INT 13
100819: DOUBLE
100820: EQUAL
100821: IFTRUE 100855
100823: LD_INT 12
100825: DOUBLE
100826: EQUAL
100827: IFTRUE 100855
100829: LD_INT 15
100831: DOUBLE
100832: EQUAL
100833: IFTRUE 100855
100835: LD_INT 11
100837: DOUBLE
100838: EQUAL
100839: IFTRUE 100855
100841: LD_INT 14
100843: DOUBLE
100844: EQUAL
100845: IFTRUE 100855
100847: LD_INT 10
100849: DOUBLE
100850: EQUAL
100851: IFTRUE 100855
100853: GO 100911
100855: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
100856: LD_ADDR_VAR 0 9
100860: PUSH
100861: LD_VAR 0 41
100865: PUSH
100866: LD_VAR 0 42
100870: PUSH
100871: LD_VAR 0 43
100875: PUSH
100876: LD_VAR 0 44
100880: PUSH
100881: LD_VAR 0 45
100885: PUSH
100886: LD_VAR 0 46
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: PUSH
100899: LD_VAR 0 4
100903: PUSH
100904: LD_INT 1
100906: PLUS
100907: ARRAY
100908: ST_TO_ADDR
100909: GO 101164
100911: LD_INT 36
100913: DOUBLE
100914: EQUAL
100915: IFTRUE 100919
100917: GO 100975
100919: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
100920: LD_ADDR_VAR 0 9
100924: PUSH
100925: LD_VAR 0 47
100929: PUSH
100930: LD_VAR 0 48
100934: PUSH
100935: LD_VAR 0 49
100939: PUSH
100940: LD_VAR 0 50
100944: PUSH
100945: LD_VAR 0 51
100949: PUSH
100950: LD_VAR 0 52
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: LIST
100959: LIST
100960: LIST
100961: LIST
100962: PUSH
100963: LD_VAR 0 4
100967: PUSH
100968: LD_INT 1
100970: PLUS
100971: ARRAY
100972: ST_TO_ADDR
100973: GO 101164
100975: LD_INT 4
100977: DOUBLE
100978: EQUAL
100979: IFTRUE 101001
100981: LD_INT 5
100983: DOUBLE
100984: EQUAL
100985: IFTRUE 101001
100987: LD_INT 34
100989: DOUBLE
100990: EQUAL
100991: IFTRUE 101001
100993: LD_INT 37
100995: DOUBLE
100996: EQUAL
100997: IFTRUE 101001
100999: GO 101057
101001: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
101002: LD_ADDR_VAR 0 9
101006: PUSH
101007: LD_VAR 0 53
101011: PUSH
101012: LD_VAR 0 54
101016: PUSH
101017: LD_VAR 0 55
101021: PUSH
101022: LD_VAR 0 56
101026: PUSH
101027: LD_VAR 0 57
101031: PUSH
101032: LD_VAR 0 58
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: LIST
101044: PUSH
101045: LD_VAR 0 4
101049: PUSH
101050: LD_INT 1
101052: PLUS
101053: ARRAY
101054: ST_TO_ADDR
101055: GO 101164
101057: LD_INT 31
101059: DOUBLE
101060: EQUAL
101061: IFTRUE 101107
101063: LD_INT 32
101065: DOUBLE
101066: EQUAL
101067: IFTRUE 101107
101069: LD_INT 33
101071: DOUBLE
101072: EQUAL
101073: IFTRUE 101107
101075: LD_INT 27
101077: DOUBLE
101078: EQUAL
101079: IFTRUE 101107
101081: LD_INT 26
101083: DOUBLE
101084: EQUAL
101085: IFTRUE 101107
101087: LD_INT 28
101089: DOUBLE
101090: EQUAL
101091: IFTRUE 101107
101093: LD_INT 29
101095: DOUBLE
101096: EQUAL
101097: IFTRUE 101107
101099: LD_INT 30
101101: DOUBLE
101102: EQUAL
101103: IFTRUE 101107
101105: GO 101163
101107: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
101108: LD_ADDR_VAR 0 9
101112: PUSH
101113: LD_VAR 0 59
101117: PUSH
101118: LD_VAR 0 60
101122: PUSH
101123: LD_VAR 0 61
101127: PUSH
101128: LD_VAR 0 62
101132: PUSH
101133: LD_VAR 0 63
101137: PUSH
101138: LD_VAR 0 64
101142: PUSH
101143: EMPTY
101144: LIST
101145: LIST
101146: LIST
101147: LIST
101148: LIST
101149: LIST
101150: PUSH
101151: LD_VAR 0 4
101155: PUSH
101156: LD_INT 1
101158: PLUS
101159: ARRAY
101160: ST_TO_ADDR
101161: GO 101164
101163: POP
// temp_list2 = [ ] ;
101164: LD_ADDR_VAR 0 10
101168: PUSH
101169: EMPTY
101170: ST_TO_ADDR
// for i in temp_list do
101171: LD_ADDR_VAR 0 8
101175: PUSH
101176: LD_VAR 0 9
101180: PUSH
101181: FOR_IN
101182: IFFALSE 101234
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
101184: LD_ADDR_VAR 0 10
101188: PUSH
101189: LD_VAR 0 10
101193: PUSH
101194: LD_VAR 0 8
101198: PUSH
101199: LD_INT 1
101201: ARRAY
101202: PUSH
101203: LD_VAR 0 2
101207: PLUS
101208: PUSH
101209: LD_VAR 0 8
101213: PUSH
101214: LD_INT 2
101216: ARRAY
101217: PUSH
101218: LD_VAR 0 3
101222: PLUS
101223: PUSH
101224: EMPTY
101225: LIST
101226: LIST
101227: PUSH
101228: EMPTY
101229: LIST
101230: ADD
101231: ST_TO_ADDR
101232: GO 101181
101234: POP
101235: POP
// result = temp_list2 ;
101236: LD_ADDR_VAR 0 7
101240: PUSH
101241: LD_VAR 0 10
101245: ST_TO_ADDR
// end ;
101246: LD_VAR 0 7
101250: RET
// export function EnemyInRange ( unit , dist ) ; begin
101251: LD_INT 0
101253: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
101254: LD_ADDR_VAR 0 3
101258: PUSH
101259: LD_VAR 0 1
101263: PPUSH
101264: CALL_OW 255
101268: PPUSH
101269: LD_VAR 0 1
101273: PPUSH
101274: CALL_OW 250
101278: PPUSH
101279: LD_VAR 0 1
101283: PPUSH
101284: CALL_OW 251
101288: PPUSH
101289: LD_VAR 0 2
101293: PPUSH
101294: CALL 74653 0 4
101298: PUSH
101299: LD_INT 4
101301: ARRAY
101302: ST_TO_ADDR
// end ;
101303: LD_VAR 0 3
101307: RET
// export function PlayerSeeMe ( unit ) ; begin
101308: LD_INT 0
101310: PPUSH
// result := See ( your_side , unit ) ;
101311: LD_ADDR_VAR 0 2
101315: PUSH
101316: LD_OWVAR 2
101320: PPUSH
101321: LD_VAR 0 1
101325: PPUSH
101326: CALL_OW 292
101330: ST_TO_ADDR
// end ;
101331: LD_VAR 0 2
101335: RET
// export function ReverseDir ( unit ) ; begin
101336: LD_INT 0
101338: PPUSH
// if not unit then
101339: LD_VAR 0 1
101343: NOT
101344: IFFALSE 101348
// exit ;
101346: GO 101371
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
101348: LD_ADDR_VAR 0 2
101352: PUSH
101353: LD_VAR 0 1
101357: PPUSH
101358: CALL_OW 254
101362: PUSH
101363: LD_INT 3
101365: PLUS
101366: PUSH
101367: LD_INT 6
101369: MOD
101370: ST_TO_ADDR
// end ;
101371: LD_VAR 0 2
101375: RET
// export function ReverseArray ( array ) ; var i ; begin
101376: LD_INT 0
101378: PPUSH
101379: PPUSH
// if not array then
101380: LD_VAR 0 1
101384: NOT
101385: IFFALSE 101389
// exit ;
101387: GO 101444
// result := [ ] ;
101389: LD_ADDR_VAR 0 2
101393: PUSH
101394: EMPTY
101395: ST_TO_ADDR
// for i := array downto 1 do
101396: LD_ADDR_VAR 0 3
101400: PUSH
101401: DOUBLE
101402: LD_VAR 0 1
101406: INC
101407: ST_TO_ADDR
101408: LD_INT 1
101410: PUSH
101411: FOR_DOWNTO
101412: IFFALSE 101442
// result := Join ( result , array [ i ] ) ;
101414: LD_ADDR_VAR 0 2
101418: PUSH
101419: LD_VAR 0 2
101423: PPUSH
101424: LD_VAR 0 1
101428: PUSH
101429: LD_VAR 0 3
101433: ARRAY
101434: PPUSH
101435: CALL 106087 0 2
101439: ST_TO_ADDR
101440: GO 101411
101442: POP
101443: POP
// end ;
101444: LD_VAR 0 2
101448: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
101449: LD_INT 0
101451: PPUSH
101452: PPUSH
101453: PPUSH
101454: PPUSH
101455: PPUSH
101456: PPUSH
// if not unit or not hexes then
101457: LD_VAR 0 1
101461: NOT
101462: PUSH
101463: LD_VAR 0 2
101467: NOT
101468: OR
101469: IFFALSE 101473
// exit ;
101471: GO 101596
// dist := 9999 ;
101473: LD_ADDR_VAR 0 5
101477: PUSH
101478: LD_INT 9999
101480: ST_TO_ADDR
// for i = 1 to hexes do
101481: LD_ADDR_VAR 0 4
101485: PUSH
101486: DOUBLE
101487: LD_INT 1
101489: DEC
101490: ST_TO_ADDR
101491: LD_VAR 0 2
101495: PUSH
101496: FOR_TO
101497: IFFALSE 101584
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
101499: LD_ADDR_VAR 0 6
101503: PUSH
101504: LD_VAR 0 1
101508: PPUSH
101509: LD_VAR 0 2
101513: PUSH
101514: LD_VAR 0 4
101518: ARRAY
101519: PUSH
101520: LD_INT 1
101522: ARRAY
101523: PPUSH
101524: LD_VAR 0 2
101528: PUSH
101529: LD_VAR 0 4
101533: ARRAY
101534: PUSH
101535: LD_INT 2
101537: ARRAY
101538: PPUSH
101539: CALL_OW 297
101543: ST_TO_ADDR
// if tdist < dist then
101544: LD_VAR 0 6
101548: PUSH
101549: LD_VAR 0 5
101553: LESS
101554: IFFALSE 101582
// begin hex := hexes [ i ] ;
101556: LD_ADDR_VAR 0 8
101560: PUSH
101561: LD_VAR 0 2
101565: PUSH
101566: LD_VAR 0 4
101570: ARRAY
101571: ST_TO_ADDR
// dist := tdist ;
101572: LD_ADDR_VAR 0 5
101576: PUSH
101577: LD_VAR 0 6
101581: ST_TO_ADDR
// end ; end ;
101582: GO 101496
101584: POP
101585: POP
// result := hex ;
101586: LD_ADDR_VAR 0 3
101590: PUSH
101591: LD_VAR 0 8
101595: ST_TO_ADDR
// end ;
101596: LD_VAR 0 3
101600: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
101601: LD_INT 0
101603: PPUSH
101604: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
101605: LD_VAR 0 1
101609: NOT
101610: PUSH
101611: LD_VAR 0 1
101615: PUSH
101616: LD_INT 21
101618: PUSH
101619: LD_INT 2
101621: PUSH
101622: EMPTY
101623: LIST
101624: LIST
101625: PUSH
101626: LD_INT 23
101628: PUSH
101629: LD_INT 2
101631: PUSH
101632: EMPTY
101633: LIST
101634: LIST
101635: PUSH
101636: EMPTY
101637: LIST
101638: LIST
101639: PPUSH
101640: CALL_OW 69
101644: IN
101645: NOT
101646: OR
101647: IFFALSE 101651
// exit ;
101649: GO 101698
// for i = 1 to 3 do
101651: LD_ADDR_VAR 0 3
101655: PUSH
101656: DOUBLE
101657: LD_INT 1
101659: DEC
101660: ST_TO_ADDR
101661: LD_INT 3
101663: PUSH
101664: FOR_TO
101665: IFFALSE 101696
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
101667: LD_VAR 0 1
101671: PPUSH
101672: CALL_OW 250
101676: PPUSH
101677: LD_VAR 0 1
101681: PPUSH
101682: CALL_OW 251
101686: PPUSH
101687: LD_INT 1
101689: PPUSH
101690: CALL_OW 453
101694: GO 101664
101696: POP
101697: POP
// end ;
101698: LD_VAR 0 2
101702: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
101703: LD_INT 0
101705: PPUSH
101706: PPUSH
101707: PPUSH
101708: PPUSH
101709: PPUSH
101710: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
101711: LD_VAR 0 1
101715: NOT
101716: PUSH
101717: LD_VAR 0 2
101721: NOT
101722: OR
101723: PUSH
101724: LD_VAR 0 1
101728: PPUSH
101729: CALL_OW 314
101733: OR
101734: IFFALSE 101738
// exit ;
101736: GO 102205
// if GetLives ( i ) < 250 then
101738: LD_VAR 0 4
101742: PPUSH
101743: CALL_OW 256
101747: PUSH
101748: LD_INT 250
101750: LESS
101751: IFFALSE 101764
// begin ComAutodestruct ( i ) ;
101753: LD_VAR 0 4
101757: PPUSH
101758: CALL 101601 0 1
// exit ;
101762: GO 102205
// end ; x := GetX ( enemy_unit ) ;
101764: LD_ADDR_VAR 0 7
101768: PUSH
101769: LD_VAR 0 2
101773: PPUSH
101774: CALL_OW 250
101778: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
101779: LD_ADDR_VAR 0 8
101783: PUSH
101784: LD_VAR 0 2
101788: PPUSH
101789: CALL_OW 251
101793: ST_TO_ADDR
// if not x or not y then
101794: LD_VAR 0 7
101798: NOT
101799: PUSH
101800: LD_VAR 0 8
101804: NOT
101805: OR
101806: IFFALSE 101810
// exit ;
101808: GO 102205
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
101810: LD_ADDR_VAR 0 6
101814: PUSH
101815: LD_VAR 0 7
101819: PPUSH
101820: LD_INT 0
101822: PPUSH
101823: LD_INT 4
101825: PPUSH
101826: CALL_OW 272
101830: PUSH
101831: LD_VAR 0 8
101835: PPUSH
101836: LD_INT 0
101838: PPUSH
101839: LD_INT 4
101841: PPUSH
101842: CALL_OW 273
101846: PUSH
101847: EMPTY
101848: LIST
101849: LIST
101850: PUSH
101851: LD_VAR 0 7
101855: PPUSH
101856: LD_INT 1
101858: PPUSH
101859: LD_INT 4
101861: PPUSH
101862: CALL_OW 272
101866: PUSH
101867: LD_VAR 0 8
101871: PPUSH
101872: LD_INT 1
101874: PPUSH
101875: LD_INT 4
101877: PPUSH
101878: CALL_OW 273
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: PUSH
101887: LD_VAR 0 7
101891: PPUSH
101892: LD_INT 2
101894: PPUSH
101895: LD_INT 4
101897: PPUSH
101898: CALL_OW 272
101902: PUSH
101903: LD_VAR 0 8
101907: PPUSH
101908: LD_INT 2
101910: PPUSH
101911: LD_INT 4
101913: PPUSH
101914: CALL_OW 273
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: PUSH
101923: LD_VAR 0 7
101927: PPUSH
101928: LD_INT 3
101930: PPUSH
101931: LD_INT 4
101933: PPUSH
101934: CALL_OW 272
101938: PUSH
101939: LD_VAR 0 8
101943: PPUSH
101944: LD_INT 3
101946: PPUSH
101947: LD_INT 4
101949: PPUSH
101950: CALL_OW 273
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: PUSH
101959: LD_VAR 0 7
101963: PPUSH
101964: LD_INT 4
101966: PPUSH
101967: LD_INT 4
101969: PPUSH
101970: CALL_OW 272
101974: PUSH
101975: LD_VAR 0 8
101979: PPUSH
101980: LD_INT 4
101982: PPUSH
101983: LD_INT 4
101985: PPUSH
101986: CALL_OW 273
101990: PUSH
101991: EMPTY
101992: LIST
101993: LIST
101994: PUSH
101995: LD_VAR 0 7
101999: PPUSH
102000: LD_INT 5
102002: PPUSH
102003: LD_INT 4
102005: PPUSH
102006: CALL_OW 272
102010: PUSH
102011: LD_VAR 0 8
102015: PPUSH
102016: LD_INT 5
102018: PPUSH
102019: LD_INT 4
102021: PPUSH
102022: CALL_OW 273
102026: PUSH
102027: EMPTY
102028: LIST
102029: LIST
102030: PUSH
102031: EMPTY
102032: LIST
102033: LIST
102034: LIST
102035: LIST
102036: LIST
102037: LIST
102038: ST_TO_ADDR
// for i = tmp downto 1 do
102039: LD_ADDR_VAR 0 4
102043: PUSH
102044: DOUBLE
102045: LD_VAR 0 6
102049: INC
102050: ST_TO_ADDR
102051: LD_INT 1
102053: PUSH
102054: FOR_DOWNTO
102055: IFFALSE 102156
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
102057: LD_VAR 0 6
102061: PUSH
102062: LD_VAR 0 4
102066: ARRAY
102067: PUSH
102068: LD_INT 1
102070: ARRAY
102071: PPUSH
102072: LD_VAR 0 6
102076: PUSH
102077: LD_VAR 0 4
102081: ARRAY
102082: PUSH
102083: LD_INT 2
102085: ARRAY
102086: PPUSH
102087: CALL_OW 488
102091: NOT
102092: PUSH
102093: LD_VAR 0 6
102097: PUSH
102098: LD_VAR 0 4
102102: ARRAY
102103: PUSH
102104: LD_INT 1
102106: ARRAY
102107: PPUSH
102108: LD_VAR 0 6
102112: PUSH
102113: LD_VAR 0 4
102117: ARRAY
102118: PUSH
102119: LD_INT 2
102121: ARRAY
102122: PPUSH
102123: CALL_OW 428
102127: PUSH
102128: LD_INT 0
102130: NONEQUAL
102131: OR
102132: IFFALSE 102154
// tmp := Delete ( tmp , i ) ;
102134: LD_ADDR_VAR 0 6
102138: PUSH
102139: LD_VAR 0 6
102143: PPUSH
102144: LD_VAR 0 4
102148: PPUSH
102149: CALL_OW 3
102153: ST_TO_ADDR
102154: GO 102054
102156: POP
102157: POP
// j := GetClosestHex ( unit , tmp ) ;
102158: LD_ADDR_VAR 0 5
102162: PUSH
102163: LD_VAR 0 1
102167: PPUSH
102168: LD_VAR 0 6
102172: PPUSH
102173: CALL 101449 0 2
102177: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
102178: LD_VAR 0 1
102182: PPUSH
102183: LD_VAR 0 5
102187: PUSH
102188: LD_INT 1
102190: ARRAY
102191: PPUSH
102192: LD_VAR 0 5
102196: PUSH
102197: LD_INT 2
102199: ARRAY
102200: PPUSH
102201: CALL_OW 111
// end ;
102205: LD_VAR 0 3
102209: RET
// export function PrepareApemanSoldier ( ) ; begin
102210: LD_INT 0
102212: PPUSH
// uc_nation := 0 ;
102213: LD_ADDR_OWVAR 21
102217: PUSH
102218: LD_INT 0
102220: ST_TO_ADDR
// hc_sex := sex_male ;
102221: LD_ADDR_OWVAR 27
102225: PUSH
102226: LD_INT 1
102228: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
102229: LD_ADDR_OWVAR 28
102233: PUSH
102234: LD_INT 15
102236: ST_TO_ADDR
// hc_gallery :=  ;
102237: LD_ADDR_OWVAR 33
102241: PUSH
102242: LD_STRING 
102244: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102245: LD_ADDR_OWVAR 31
102249: PUSH
102250: LD_INT 0
102252: PPUSH
102253: LD_INT 3
102255: PPUSH
102256: CALL_OW 12
102260: PUSH
102261: LD_INT 0
102263: PPUSH
102264: LD_INT 3
102266: PPUSH
102267: CALL_OW 12
102271: PUSH
102272: LD_INT 0
102274: PUSH
102275: LD_INT 0
102277: PUSH
102278: EMPTY
102279: LIST
102280: LIST
102281: LIST
102282: LIST
102283: ST_TO_ADDR
// end ;
102284: LD_VAR 0 1
102288: RET
// export function PrepareApemanEngineer ( ) ; begin
102289: LD_INT 0
102291: PPUSH
// uc_nation := 0 ;
102292: LD_ADDR_OWVAR 21
102296: PUSH
102297: LD_INT 0
102299: ST_TO_ADDR
// hc_sex := sex_male ;
102300: LD_ADDR_OWVAR 27
102304: PUSH
102305: LD_INT 1
102307: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
102308: LD_ADDR_OWVAR 28
102312: PUSH
102313: LD_INT 16
102315: ST_TO_ADDR
// hc_gallery :=  ;
102316: LD_ADDR_OWVAR 33
102320: PUSH
102321: LD_STRING 
102323: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102324: LD_ADDR_OWVAR 31
102328: PUSH
102329: LD_INT 0
102331: PPUSH
102332: LD_INT 3
102334: PPUSH
102335: CALL_OW 12
102339: PUSH
102340: LD_INT 0
102342: PPUSH
102343: LD_INT 3
102345: PPUSH
102346: CALL_OW 12
102350: PUSH
102351: LD_INT 0
102353: PUSH
102354: LD_INT 0
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: ST_TO_ADDR
// end ;
102363: LD_VAR 0 1
102367: RET
// export function PrepareApeman ( agressivity ) ; begin
102368: LD_INT 0
102370: PPUSH
// uc_side := 0 ;
102371: LD_ADDR_OWVAR 20
102375: PUSH
102376: LD_INT 0
102378: ST_TO_ADDR
// uc_nation := 0 ;
102379: LD_ADDR_OWVAR 21
102383: PUSH
102384: LD_INT 0
102386: ST_TO_ADDR
// hc_sex := sex_male ;
102387: LD_ADDR_OWVAR 27
102391: PUSH
102392: LD_INT 1
102394: ST_TO_ADDR
// hc_class := class_apeman ;
102395: LD_ADDR_OWVAR 28
102399: PUSH
102400: LD_INT 12
102402: ST_TO_ADDR
// hc_gallery :=  ;
102403: LD_ADDR_OWVAR 33
102407: PUSH
102408: LD_STRING 
102410: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
102411: LD_ADDR_OWVAR 35
102415: PUSH
102416: LD_VAR 0 1
102420: NEG
102421: PPUSH
102422: LD_VAR 0 1
102426: PPUSH
102427: CALL_OW 12
102431: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102432: LD_ADDR_OWVAR 31
102436: PUSH
102437: LD_INT 0
102439: PPUSH
102440: LD_INT 3
102442: PPUSH
102443: CALL_OW 12
102447: PUSH
102448: LD_INT 0
102450: PPUSH
102451: LD_INT 3
102453: PPUSH
102454: CALL_OW 12
102458: PUSH
102459: LD_INT 0
102461: PUSH
102462: LD_INT 0
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: LIST
102469: LIST
102470: ST_TO_ADDR
// end ;
102471: LD_VAR 0 2
102475: RET
// export function PrepareTiger ( agressivity ) ; begin
102476: LD_INT 0
102478: PPUSH
// uc_side := 0 ;
102479: LD_ADDR_OWVAR 20
102483: PUSH
102484: LD_INT 0
102486: ST_TO_ADDR
// uc_nation := 0 ;
102487: LD_ADDR_OWVAR 21
102491: PUSH
102492: LD_INT 0
102494: ST_TO_ADDR
// hc_class := class_tiger ;
102495: LD_ADDR_OWVAR 28
102499: PUSH
102500: LD_INT 14
102502: ST_TO_ADDR
// hc_gallery :=  ;
102503: LD_ADDR_OWVAR 33
102507: PUSH
102508: LD_STRING 
102510: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
102511: LD_ADDR_OWVAR 35
102515: PUSH
102516: LD_VAR 0 1
102520: NEG
102521: PPUSH
102522: LD_VAR 0 1
102526: PPUSH
102527: CALL_OW 12
102531: ST_TO_ADDR
// end ;
102532: LD_VAR 0 2
102536: RET
// export function PrepareEnchidna ( ) ; begin
102537: LD_INT 0
102539: PPUSH
// uc_side := 0 ;
102540: LD_ADDR_OWVAR 20
102544: PUSH
102545: LD_INT 0
102547: ST_TO_ADDR
// uc_nation := 0 ;
102548: LD_ADDR_OWVAR 21
102552: PUSH
102553: LD_INT 0
102555: ST_TO_ADDR
// hc_class := class_baggie ;
102556: LD_ADDR_OWVAR 28
102560: PUSH
102561: LD_INT 13
102563: ST_TO_ADDR
// hc_gallery :=  ;
102564: LD_ADDR_OWVAR 33
102568: PUSH
102569: LD_STRING 
102571: ST_TO_ADDR
// end ;
102572: LD_VAR 0 1
102576: RET
// export function PrepareFrog ( ) ; begin
102577: LD_INT 0
102579: PPUSH
// uc_side := 0 ;
102580: LD_ADDR_OWVAR 20
102584: PUSH
102585: LD_INT 0
102587: ST_TO_ADDR
// uc_nation := 0 ;
102588: LD_ADDR_OWVAR 21
102592: PUSH
102593: LD_INT 0
102595: ST_TO_ADDR
// hc_class := class_frog ;
102596: LD_ADDR_OWVAR 28
102600: PUSH
102601: LD_INT 19
102603: ST_TO_ADDR
// hc_gallery :=  ;
102604: LD_ADDR_OWVAR 33
102608: PUSH
102609: LD_STRING 
102611: ST_TO_ADDR
// end ;
102612: LD_VAR 0 1
102616: RET
// export function PrepareFish ( ) ; begin
102617: LD_INT 0
102619: PPUSH
// uc_side := 0 ;
102620: LD_ADDR_OWVAR 20
102624: PUSH
102625: LD_INT 0
102627: ST_TO_ADDR
// uc_nation := 0 ;
102628: LD_ADDR_OWVAR 21
102632: PUSH
102633: LD_INT 0
102635: ST_TO_ADDR
// hc_class := class_fish ;
102636: LD_ADDR_OWVAR 28
102640: PUSH
102641: LD_INT 20
102643: ST_TO_ADDR
// hc_gallery :=  ;
102644: LD_ADDR_OWVAR 33
102648: PUSH
102649: LD_STRING 
102651: ST_TO_ADDR
// end ;
102652: LD_VAR 0 1
102656: RET
// export function PrepareBird ( ) ; begin
102657: LD_INT 0
102659: PPUSH
// uc_side := 0 ;
102660: LD_ADDR_OWVAR 20
102664: PUSH
102665: LD_INT 0
102667: ST_TO_ADDR
// uc_nation := 0 ;
102668: LD_ADDR_OWVAR 21
102672: PUSH
102673: LD_INT 0
102675: ST_TO_ADDR
// hc_class := class_phororhacos ;
102676: LD_ADDR_OWVAR 28
102680: PUSH
102681: LD_INT 18
102683: ST_TO_ADDR
// hc_gallery :=  ;
102684: LD_ADDR_OWVAR 33
102688: PUSH
102689: LD_STRING 
102691: ST_TO_ADDR
// end ;
102692: LD_VAR 0 1
102696: RET
// export function PrepareHorse ( ) ; begin
102697: LD_INT 0
102699: PPUSH
// uc_side := 0 ;
102700: LD_ADDR_OWVAR 20
102704: PUSH
102705: LD_INT 0
102707: ST_TO_ADDR
// uc_nation := 0 ;
102708: LD_ADDR_OWVAR 21
102712: PUSH
102713: LD_INT 0
102715: ST_TO_ADDR
// hc_class := class_horse ;
102716: LD_ADDR_OWVAR 28
102720: PUSH
102721: LD_INT 21
102723: ST_TO_ADDR
// hc_gallery :=  ;
102724: LD_ADDR_OWVAR 33
102728: PUSH
102729: LD_STRING 
102731: ST_TO_ADDR
// end ;
102732: LD_VAR 0 1
102736: RET
// export function PrepareMastodont ( ) ; begin
102737: LD_INT 0
102739: PPUSH
// uc_side := 0 ;
102740: LD_ADDR_OWVAR 20
102744: PUSH
102745: LD_INT 0
102747: ST_TO_ADDR
// uc_nation := 0 ;
102748: LD_ADDR_OWVAR 21
102752: PUSH
102753: LD_INT 0
102755: ST_TO_ADDR
// vc_chassis := class_mastodont ;
102756: LD_ADDR_OWVAR 37
102760: PUSH
102761: LD_INT 31
102763: ST_TO_ADDR
// vc_control := control_rider ;
102764: LD_ADDR_OWVAR 38
102768: PUSH
102769: LD_INT 4
102771: ST_TO_ADDR
// end ;
102772: LD_VAR 0 1
102776: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
102777: LD_INT 0
102779: PPUSH
102780: PPUSH
102781: PPUSH
// uc_side = 0 ;
102782: LD_ADDR_OWVAR 20
102786: PUSH
102787: LD_INT 0
102789: ST_TO_ADDR
// uc_nation = 0 ;
102790: LD_ADDR_OWVAR 21
102794: PUSH
102795: LD_INT 0
102797: ST_TO_ADDR
// InitHc_All ( ) ;
102798: CALL_OW 584
// InitVc ;
102802: CALL_OW 20
// if mastodonts then
102806: LD_VAR 0 6
102810: IFFALSE 102877
// for i = 1 to mastodonts do
102812: LD_ADDR_VAR 0 11
102816: PUSH
102817: DOUBLE
102818: LD_INT 1
102820: DEC
102821: ST_TO_ADDR
102822: LD_VAR 0 6
102826: PUSH
102827: FOR_TO
102828: IFFALSE 102875
// begin vc_chassis := 31 ;
102830: LD_ADDR_OWVAR 37
102834: PUSH
102835: LD_INT 31
102837: ST_TO_ADDR
// vc_control := control_rider ;
102838: LD_ADDR_OWVAR 38
102842: PUSH
102843: LD_INT 4
102845: ST_TO_ADDR
// animal := CreateVehicle ;
102846: LD_ADDR_VAR 0 12
102850: PUSH
102851: CALL_OW 45
102855: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102856: LD_VAR 0 12
102860: PPUSH
102861: LD_VAR 0 8
102865: PPUSH
102866: LD_INT 0
102868: PPUSH
102869: CALL 105005 0 3
// end ;
102873: GO 102827
102875: POP
102876: POP
// if horses then
102877: LD_VAR 0 5
102881: IFFALSE 102948
// for i = 1 to horses do
102883: LD_ADDR_VAR 0 11
102887: PUSH
102888: DOUBLE
102889: LD_INT 1
102891: DEC
102892: ST_TO_ADDR
102893: LD_VAR 0 5
102897: PUSH
102898: FOR_TO
102899: IFFALSE 102946
// begin hc_class := 21 ;
102901: LD_ADDR_OWVAR 28
102905: PUSH
102906: LD_INT 21
102908: ST_TO_ADDR
// hc_gallery :=  ;
102909: LD_ADDR_OWVAR 33
102913: PUSH
102914: LD_STRING 
102916: ST_TO_ADDR
// animal := CreateHuman ;
102917: LD_ADDR_VAR 0 12
102921: PUSH
102922: CALL_OW 44
102926: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102927: LD_VAR 0 12
102931: PPUSH
102932: LD_VAR 0 8
102936: PPUSH
102937: LD_INT 0
102939: PPUSH
102940: CALL 105005 0 3
// end ;
102944: GO 102898
102946: POP
102947: POP
// if birds then
102948: LD_VAR 0 1
102952: IFFALSE 103019
// for i = 1 to birds do
102954: LD_ADDR_VAR 0 11
102958: PUSH
102959: DOUBLE
102960: LD_INT 1
102962: DEC
102963: ST_TO_ADDR
102964: LD_VAR 0 1
102968: PUSH
102969: FOR_TO
102970: IFFALSE 103017
// begin hc_class = 18 ;
102972: LD_ADDR_OWVAR 28
102976: PUSH
102977: LD_INT 18
102979: ST_TO_ADDR
// hc_gallery =  ;
102980: LD_ADDR_OWVAR 33
102984: PUSH
102985: LD_STRING 
102987: ST_TO_ADDR
// animal := CreateHuman ;
102988: LD_ADDR_VAR 0 12
102992: PUSH
102993: CALL_OW 44
102997: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102998: LD_VAR 0 12
103002: PPUSH
103003: LD_VAR 0 8
103007: PPUSH
103008: LD_INT 0
103010: PPUSH
103011: CALL 105005 0 3
// end ;
103015: GO 102969
103017: POP
103018: POP
// if tigers then
103019: LD_VAR 0 2
103023: IFFALSE 103107
// for i = 1 to tigers do
103025: LD_ADDR_VAR 0 11
103029: PUSH
103030: DOUBLE
103031: LD_INT 1
103033: DEC
103034: ST_TO_ADDR
103035: LD_VAR 0 2
103039: PUSH
103040: FOR_TO
103041: IFFALSE 103105
// begin hc_class = class_tiger ;
103043: LD_ADDR_OWVAR 28
103047: PUSH
103048: LD_INT 14
103050: ST_TO_ADDR
// hc_gallery =  ;
103051: LD_ADDR_OWVAR 33
103055: PUSH
103056: LD_STRING 
103058: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
103059: LD_ADDR_OWVAR 35
103063: PUSH
103064: LD_INT 7
103066: NEG
103067: PPUSH
103068: LD_INT 7
103070: PPUSH
103071: CALL_OW 12
103075: ST_TO_ADDR
// animal := CreateHuman ;
103076: LD_ADDR_VAR 0 12
103080: PUSH
103081: CALL_OW 44
103085: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103086: LD_VAR 0 12
103090: PPUSH
103091: LD_VAR 0 8
103095: PPUSH
103096: LD_INT 0
103098: PPUSH
103099: CALL 105005 0 3
// end ;
103103: GO 103040
103105: POP
103106: POP
// if apemans then
103107: LD_VAR 0 3
103111: IFFALSE 103234
// for i = 1 to apemans do
103113: LD_ADDR_VAR 0 11
103117: PUSH
103118: DOUBLE
103119: LD_INT 1
103121: DEC
103122: ST_TO_ADDR
103123: LD_VAR 0 3
103127: PUSH
103128: FOR_TO
103129: IFFALSE 103232
// begin hc_class = class_apeman ;
103131: LD_ADDR_OWVAR 28
103135: PUSH
103136: LD_INT 12
103138: ST_TO_ADDR
// hc_gallery =  ;
103139: LD_ADDR_OWVAR 33
103143: PUSH
103144: LD_STRING 
103146: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
103147: LD_ADDR_OWVAR 35
103151: PUSH
103152: LD_INT 2
103154: NEG
103155: PPUSH
103156: LD_INT 2
103158: PPUSH
103159: CALL_OW 12
103163: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
103164: LD_ADDR_OWVAR 31
103168: PUSH
103169: LD_INT 1
103171: PPUSH
103172: LD_INT 3
103174: PPUSH
103175: CALL_OW 12
103179: PUSH
103180: LD_INT 1
103182: PPUSH
103183: LD_INT 3
103185: PPUSH
103186: CALL_OW 12
103190: PUSH
103191: LD_INT 0
103193: PUSH
103194: LD_INT 0
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: LIST
103201: LIST
103202: ST_TO_ADDR
// animal := CreateHuman ;
103203: LD_ADDR_VAR 0 12
103207: PUSH
103208: CALL_OW 44
103212: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103213: LD_VAR 0 12
103217: PPUSH
103218: LD_VAR 0 8
103222: PPUSH
103223: LD_INT 0
103225: PPUSH
103226: CALL 105005 0 3
// end ;
103230: GO 103128
103232: POP
103233: POP
// if enchidnas then
103234: LD_VAR 0 4
103238: IFFALSE 103305
// for i = 1 to enchidnas do
103240: LD_ADDR_VAR 0 11
103244: PUSH
103245: DOUBLE
103246: LD_INT 1
103248: DEC
103249: ST_TO_ADDR
103250: LD_VAR 0 4
103254: PUSH
103255: FOR_TO
103256: IFFALSE 103303
// begin hc_class = 13 ;
103258: LD_ADDR_OWVAR 28
103262: PUSH
103263: LD_INT 13
103265: ST_TO_ADDR
// hc_gallery =  ;
103266: LD_ADDR_OWVAR 33
103270: PUSH
103271: LD_STRING 
103273: ST_TO_ADDR
// animal := CreateHuman ;
103274: LD_ADDR_VAR 0 12
103278: PUSH
103279: CALL_OW 44
103283: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103284: LD_VAR 0 12
103288: PPUSH
103289: LD_VAR 0 8
103293: PPUSH
103294: LD_INT 0
103296: PPUSH
103297: CALL 105005 0 3
// end ;
103301: GO 103255
103303: POP
103304: POP
// if fishes then
103305: LD_VAR 0 7
103309: IFFALSE 103376
// for i = 1 to fishes do
103311: LD_ADDR_VAR 0 11
103315: PUSH
103316: DOUBLE
103317: LD_INT 1
103319: DEC
103320: ST_TO_ADDR
103321: LD_VAR 0 7
103325: PUSH
103326: FOR_TO
103327: IFFALSE 103374
// begin hc_class = 20 ;
103329: LD_ADDR_OWVAR 28
103333: PUSH
103334: LD_INT 20
103336: ST_TO_ADDR
// hc_gallery =  ;
103337: LD_ADDR_OWVAR 33
103341: PUSH
103342: LD_STRING 
103344: ST_TO_ADDR
// animal := CreateHuman ;
103345: LD_ADDR_VAR 0 12
103349: PUSH
103350: CALL_OW 44
103354: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
103355: LD_VAR 0 12
103359: PPUSH
103360: LD_VAR 0 9
103364: PPUSH
103365: LD_INT 0
103367: PPUSH
103368: CALL 105005 0 3
// end ;
103372: GO 103326
103374: POP
103375: POP
// end ;
103376: LD_VAR 0 10
103380: RET
// export function WantHeal ( sci , unit ) ; begin
103381: LD_INT 0
103383: PPUSH
// if GetTaskList ( sci ) > 0 then
103384: LD_VAR 0 1
103388: PPUSH
103389: CALL_OW 437
103393: PUSH
103394: LD_INT 0
103396: GREATER
103397: IFFALSE 103467
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
103399: LD_VAR 0 1
103403: PPUSH
103404: CALL_OW 437
103408: PUSH
103409: LD_INT 1
103411: ARRAY
103412: PUSH
103413: LD_INT 1
103415: ARRAY
103416: PUSH
103417: LD_STRING l
103419: EQUAL
103420: PUSH
103421: LD_VAR 0 1
103425: PPUSH
103426: CALL_OW 437
103430: PUSH
103431: LD_INT 1
103433: ARRAY
103434: PUSH
103435: LD_INT 4
103437: ARRAY
103438: PUSH
103439: LD_VAR 0 2
103443: EQUAL
103444: AND
103445: IFFALSE 103457
// result := true else
103447: LD_ADDR_VAR 0 3
103451: PUSH
103452: LD_INT 1
103454: ST_TO_ADDR
103455: GO 103465
// result := false ;
103457: LD_ADDR_VAR 0 3
103461: PUSH
103462: LD_INT 0
103464: ST_TO_ADDR
// end else
103465: GO 103475
// result := false ;
103467: LD_ADDR_VAR 0 3
103471: PUSH
103472: LD_INT 0
103474: ST_TO_ADDR
// end ;
103475: LD_VAR 0 3
103479: RET
// export function HealTarget ( sci ) ; begin
103480: LD_INT 0
103482: PPUSH
// if not sci then
103483: LD_VAR 0 1
103487: NOT
103488: IFFALSE 103492
// exit ;
103490: GO 103557
// result := 0 ;
103492: LD_ADDR_VAR 0 2
103496: PUSH
103497: LD_INT 0
103499: ST_TO_ADDR
// if GetTaskList ( sci ) then
103500: LD_VAR 0 1
103504: PPUSH
103505: CALL_OW 437
103509: IFFALSE 103557
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
103511: LD_VAR 0 1
103515: PPUSH
103516: CALL_OW 437
103520: PUSH
103521: LD_INT 1
103523: ARRAY
103524: PUSH
103525: LD_INT 1
103527: ARRAY
103528: PUSH
103529: LD_STRING l
103531: EQUAL
103532: IFFALSE 103557
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
103534: LD_ADDR_VAR 0 2
103538: PUSH
103539: LD_VAR 0 1
103543: PPUSH
103544: CALL_OW 437
103548: PUSH
103549: LD_INT 1
103551: ARRAY
103552: PUSH
103553: LD_INT 4
103555: ARRAY
103556: ST_TO_ADDR
// end ;
103557: LD_VAR 0 2
103561: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
103562: LD_INT 0
103564: PPUSH
103565: PPUSH
103566: PPUSH
103567: PPUSH
// if not base_units then
103568: LD_VAR 0 1
103572: NOT
103573: IFFALSE 103577
// exit ;
103575: GO 103664
// result := false ;
103577: LD_ADDR_VAR 0 2
103581: PUSH
103582: LD_INT 0
103584: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
103585: LD_ADDR_VAR 0 5
103589: PUSH
103590: LD_VAR 0 1
103594: PPUSH
103595: LD_INT 21
103597: PUSH
103598: LD_INT 3
103600: PUSH
103601: EMPTY
103602: LIST
103603: LIST
103604: PPUSH
103605: CALL_OW 72
103609: ST_TO_ADDR
// if not tmp then
103610: LD_VAR 0 5
103614: NOT
103615: IFFALSE 103619
// exit ;
103617: GO 103664
// for i in tmp do
103619: LD_ADDR_VAR 0 3
103623: PUSH
103624: LD_VAR 0 5
103628: PUSH
103629: FOR_IN
103630: IFFALSE 103662
// begin result := EnemyInRange ( i , 22 ) ;
103632: LD_ADDR_VAR 0 2
103636: PUSH
103637: LD_VAR 0 3
103641: PPUSH
103642: LD_INT 22
103644: PPUSH
103645: CALL 101251 0 2
103649: ST_TO_ADDR
// if result then
103650: LD_VAR 0 2
103654: IFFALSE 103660
// exit ;
103656: POP
103657: POP
103658: GO 103664
// end ;
103660: GO 103629
103662: POP
103663: POP
// end ;
103664: LD_VAR 0 2
103668: RET
// export function FilterByTag ( units , tag ) ; begin
103669: LD_INT 0
103671: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
103672: LD_ADDR_VAR 0 3
103676: PUSH
103677: LD_VAR 0 1
103681: PPUSH
103682: LD_INT 120
103684: PUSH
103685: LD_VAR 0 2
103689: PUSH
103690: EMPTY
103691: LIST
103692: LIST
103693: PPUSH
103694: CALL_OW 72
103698: ST_TO_ADDR
// end ;
103699: LD_VAR 0 3
103703: RET
// export function IsDriver ( un ) ; begin
103704: LD_INT 0
103706: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103707: LD_ADDR_VAR 0 2
103711: PUSH
103712: LD_VAR 0 1
103716: PUSH
103717: LD_INT 55
103719: PUSH
103720: EMPTY
103721: LIST
103722: PPUSH
103723: CALL_OW 69
103727: IN
103728: ST_TO_ADDR
// end ;
103729: LD_VAR 0 2
103733: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103734: LD_INT 0
103736: PPUSH
103737: PPUSH
// list := [ ] ;
103738: LD_ADDR_VAR 0 5
103742: PUSH
103743: EMPTY
103744: ST_TO_ADDR
// case d of 0 :
103745: LD_VAR 0 3
103749: PUSH
103750: LD_INT 0
103752: DOUBLE
103753: EQUAL
103754: IFTRUE 103758
103756: GO 103891
103758: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103759: LD_ADDR_VAR 0 5
103763: PUSH
103764: LD_VAR 0 1
103768: PUSH
103769: LD_INT 4
103771: MINUS
103772: PUSH
103773: LD_VAR 0 2
103777: PUSH
103778: LD_INT 4
103780: MINUS
103781: PUSH
103782: LD_INT 2
103784: PUSH
103785: EMPTY
103786: LIST
103787: LIST
103788: LIST
103789: PUSH
103790: LD_VAR 0 1
103794: PUSH
103795: LD_INT 3
103797: MINUS
103798: PUSH
103799: LD_VAR 0 2
103803: PUSH
103804: LD_INT 1
103806: PUSH
103807: EMPTY
103808: LIST
103809: LIST
103810: LIST
103811: PUSH
103812: LD_VAR 0 1
103816: PUSH
103817: LD_INT 4
103819: PLUS
103820: PUSH
103821: LD_VAR 0 2
103825: PUSH
103826: LD_INT 4
103828: PUSH
103829: EMPTY
103830: LIST
103831: LIST
103832: LIST
103833: PUSH
103834: LD_VAR 0 1
103838: PUSH
103839: LD_INT 3
103841: PLUS
103842: PUSH
103843: LD_VAR 0 2
103847: PUSH
103848: LD_INT 3
103850: PLUS
103851: PUSH
103852: LD_INT 5
103854: PUSH
103855: EMPTY
103856: LIST
103857: LIST
103858: LIST
103859: PUSH
103860: LD_VAR 0 1
103864: PUSH
103865: LD_VAR 0 2
103869: PUSH
103870: LD_INT 4
103872: PLUS
103873: PUSH
103874: LD_INT 0
103876: PUSH
103877: EMPTY
103878: LIST
103879: LIST
103880: LIST
103881: PUSH
103882: EMPTY
103883: LIST
103884: LIST
103885: LIST
103886: LIST
103887: LIST
103888: ST_TO_ADDR
// end ; 1 :
103889: GO 104589
103891: LD_INT 1
103893: DOUBLE
103894: EQUAL
103895: IFTRUE 103899
103897: GO 104032
103899: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103900: LD_ADDR_VAR 0 5
103904: PUSH
103905: LD_VAR 0 1
103909: PUSH
103910: LD_VAR 0 2
103914: PUSH
103915: LD_INT 4
103917: MINUS
103918: PUSH
103919: LD_INT 3
103921: PUSH
103922: EMPTY
103923: LIST
103924: LIST
103925: LIST
103926: PUSH
103927: LD_VAR 0 1
103931: PUSH
103932: LD_INT 3
103934: MINUS
103935: PUSH
103936: LD_VAR 0 2
103940: PUSH
103941: LD_INT 3
103943: MINUS
103944: PUSH
103945: LD_INT 2
103947: PUSH
103948: EMPTY
103949: LIST
103950: LIST
103951: LIST
103952: PUSH
103953: LD_VAR 0 1
103957: PUSH
103958: LD_INT 4
103960: MINUS
103961: PUSH
103962: LD_VAR 0 2
103966: PUSH
103967: LD_INT 1
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: LIST
103974: PUSH
103975: LD_VAR 0 1
103979: PUSH
103980: LD_VAR 0 2
103984: PUSH
103985: LD_INT 3
103987: PLUS
103988: PUSH
103989: LD_INT 0
103991: PUSH
103992: EMPTY
103993: LIST
103994: LIST
103995: LIST
103996: PUSH
103997: LD_VAR 0 1
104001: PUSH
104002: LD_INT 4
104004: PLUS
104005: PUSH
104006: LD_VAR 0 2
104010: PUSH
104011: LD_INT 4
104013: PLUS
104014: PUSH
104015: LD_INT 5
104017: PUSH
104018: EMPTY
104019: LIST
104020: LIST
104021: LIST
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: LIST
104027: LIST
104028: LIST
104029: ST_TO_ADDR
// end ; 2 :
104030: GO 104589
104032: LD_INT 2
104034: DOUBLE
104035: EQUAL
104036: IFTRUE 104040
104038: GO 104169
104040: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104041: LD_ADDR_VAR 0 5
104045: PUSH
104046: LD_VAR 0 1
104050: PUSH
104051: LD_VAR 0 2
104055: PUSH
104056: LD_INT 3
104058: MINUS
104059: PUSH
104060: LD_INT 3
104062: PUSH
104063: EMPTY
104064: LIST
104065: LIST
104066: LIST
104067: PUSH
104068: LD_VAR 0 1
104072: PUSH
104073: LD_INT 4
104075: PLUS
104076: PUSH
104077: LD_VAR 0 2
104081: PUSH
104082: LD_INT 4
104084: PUSH
104085: EMPTY
104086: LIST
104087: LIST
104088: LIST
104089: PUSH
104090: LD_VAR 0 1
104094: PUSH
104095: LD_VAR 0 2
104099: PUSH
104100: LD_INT 4
104102: PLUS
104103: PUSH
104104: LD_INT 0
104106: PUSH
104107: EMPTY
104108: LIST
104109: LIST
104110: LIST
104111: PUSH
104112: LD_VAR 0 1
104116: PUSH
104117: LD_INT 3
104119: MINUS
104120: PUSH
104121: LD_VAR 0 2
104125: PUSH
104126: LD_INT 1
104128: PUSH
104129: EMPTY
104130: LIST
104131: LIST
104132: LIST
104133: PUSH
104134: LD_VAR 0 1
104138: PUSH
104139: LD_INT 4
104141: MINUS
104142: PUSH
104143: LD_VAR 0 2
104147: PUSH
104148: LD_INT 4
104150: MINUS
104151: PUSH
104152: LD_INT 2
104154: PUSH
104155: EMPTY
104156: LIST
104157: LIST
104158: LIST
104159: PUSH
104160: EMPTY
104161: LIST
104162: LIST
104163: LIST
104164: LIST
104165: LIST
104166: ST_TO_ADDR
// end ; 3 :
104167: GO 104589
104169: LD_INT 3
104171: DOUBLE
104172: EQUAL
104173: IFTRUE 104177
104175: GO 104310
104177: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
104178: LD_ADDR_VAR 0 5
104182: PUSH
104183: LD_VAR 0 1
104187: PUSH
104188: LD_INT 3
104190: PLUS
104191: PUSH
104192: LD_VAR 0 2
104196: PUSH
104197: LD_INT 4
104199: PUSH
104200: EMPTY
104201: LIST
104202: LIST
104203: LIST
104204: PUSH
104205: LD_VAR 0 1
104209: PUSH
104210: LD_INT 4
104212: PLUS
104213: PUSH
104214: LD_VAR 0 2
104218: PUSH
104219: LD_INT 4
104221: PLUS
104222: PUSH
104223: LD_INT 5
104225: PUSH
104226: EMPTY
104227: LIST
104228: LIST
104229: LIST
104230: PUSH
104231: LD_VAR 0 1
104235: PUSH
104236: LD_INT 4
104238: MINUS
104239: PUSH
104240: LD_VAR 0 2
104244: PUSH
104245: LD_INT 1
104247: PUSH
104248: EMPTY
104249: LIST
104250: LIST
104251: LIST
104252: PUSH
104253: LD_VAR 0 1
104257: PUSH
104258: LD_VAR 0 2
104262: PUSH
104263: LD_INT 4
104265: MINUS
104266: PUSH
104267: LD_INT 3
104269: PUSH
104270: EMPTY
104271: LIST
104272: LIST
104273: LIST
104274: PUSH
104275: LD_VAR 0 1
104279: PUSH
104280: LD_INT 3
104282: MINUS
104283: PUSH
104284: LD_VAR 0 2
104288: PUSH
104289: LD_INT 3
104291: MINUS
104292: PUSH
104293: LD_INT 2
104295: PUSH
104296: EMPTY
104297: LIST
104298: LIST
104299: LIST
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: LIST
104305: LIST
104306: LIST
104307: ST_TO_ADDR
// end ; 4 :
104308: GO 104589
104310: LD_INT 4
104312: DOUBLE
104313: EQUAL
104314: IFTRUE 104318
104316: GO 104451
104318: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104319: LD_ADDR_VAR 0 5
104323: PUSH
104324: LD_VAR 0 1
104328: PUSH
104329: LD_VAR 0 2
104333: PUSH
104334: LD_INT 4
104336: PLUS
104337: PUSH
104338: LD_INT 0
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: LIST
104345: PUSH
104346: LD_VAR 0 1
104350: PUSH
104351: LD_INT 3
104353: PLUS
104354: PUSH
104355: LD_VAR 0 2
104359: PUSH
104360: LD_INT 3
104362: PLUS
104363: PUSH
104364: LD_INT 5
104366: PUSH
104367: EMPTY
104368: LIST
104369: LIST
104370: LIST
104371: PUSH
104372: LD_VAR 0 1
104376: PUSH
104377: LD_INT 4
104379: PLUS
104380: PUSH
104381: LD_VAR 0 2
104385: PUSH
104386: LD_INT 4
104388: PUSH
104389: EMPTY
104390: LIST
104391: LIST
104392: LIST
104393: PUSH
104394: LD_VAR 0 1
104398: PUSH
104399: LD_VAR 0 2
104403: PUSH
104404: LD_INT 3
104406: MINUS
104407: PUSH
104408: LD_INT 3
104410: PUSH
104411: EMPTY
104412: LIST
104413: LIST
104414: LIST
104415: PUSH
104416: LD_VAR 0 1
104420: PUSH
104421: LD_INT 4
104423: MINUS
104424: PUSH
104425: LD_VAR 0 2
104429: PUSH
104430: LD_INT 4
104432: MINUS
104433: PUSH
104434: LD_INT 2
104436: PUSH
104437: EMPTY
104438: LIST
104439: LIST
104440: LIST
104441: PUSH
104442: EMPTY
104443: LIST
104444: LIST
104445: LIST
104446: LIST
104447: LIST
104448: ST_TO_ADDR
// end ; 5 :
104449: GO 104589
104451: LD_INT 5
104453: DOUBLE
104454: EQUAL
104455: IFTRUE 104459
104457: GO 104588
104459: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
104460: LD_ADDR_VAR 0 5
104464: PUSH
104465: LD_VAR 0 1
104469: PUSH
104470: LD_INT 4
104472: MINUS
104473: PUSH
104474: LD_VAR 0 2
104478: PUSH
104479: LD_INT 1
104481: PUSH
104482: EMPTY
104483: LIST
104484: LIST
104485: LIST
104486: PUSH
104487: LD_VAR 0 1
104491: PUSH
104492: LD_VAR 0 2
104496: PUSH
104497: LD_INT 4
104499: MINUS
104500: PUSH
104501: LD_INT 3
104503: PUSH
104504: EMPTY
104505: LIST
104506: LIST
104507: LIST
104508: PUSH
104509: LD_VAR 0 1
104513: PUSH
104514: LD_INT 4
104516: PLUS
104517: PUSH
104518: LD_VAR 0 2
104522: PUSH
104523: LD_INT 4
104525: PLUS
104526: PUSH
104527: LD_INT 5
104529: PUSH
104530: EMPTY
104531: LIST
104532: LIST
104533: LIST
104534: PUSH
104535: LD_VAR 0 1
104539: PUSH
104540: LD_INT 3
104542: PLUS
104543: PUSH
104544: LD_VAR 0 2
104548: PUSH
104549: LD_INT 4
104551: PUSH
104552: EMPTY
104553: LIST
104554: LIST
104555: LIST
104556: PUSH
104557: LD_VAR 0 1
104561: PUSH
104562: LD_VAR 0 2
104566: PUSH
104567: LD_INT 3
104569: PLUS
104570: PUSH
104571: LD_INT 0
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: LIST
104578: PUSH
104579: EMPTY
104580: LIST
104581: LIST
104582: LIST
104583: LIST
104584: LIST
104585: ST_TO_ADDR
// end ; end ;
104586: GO 104589
104588: POP
// result := list ;
104589: LD_ADDR_VAR 0 4
104593: PUSH
104594: LD_VAR 0 5
104598: ST_TO_ADDR
// end ;
104599: LD_VAR 0 4
104603: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
104604: LD_INT 0
104606: PPUSH
104607: PPUSH
104608: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
104609: LD_VAR 0 1
104613: NOT
104614: PUSH
104615: LD_VAR 0 2
104619: PUSH
104620: LD_INT 1
104622: PUSH
104623: LD_INT 2
104625: PUSH
104626: LD_INT 3
104628: PUSH
104629: LD_INT 4
104631: PUSH
104632: EMPTY
104633: LIST
104634: LIST
104635: LIST
104636: LIST
104637: IN
104638: NOT
104639: OR
104640: IFFALSE 104644
// exit ;
104642: GO 104727
// tmp := [ ] ;
104644: LD_ADDR_VAR 0 5
104648: PUSH
104649: EMPTY
104650: ST_TO_ADDR
// for i in units do
104651: LD_ADDR_VAR 0 4
104655: PUSH
104656: LD_VAR 0 1
104660: PUSH
104661: FOR_IN
104662: IFFALSE 104696
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
104664: LD_ADDR_VAR 0 5
104668: PUSH
104669: LD_VAR 0 5
104673: PPUSH
104674: LD_VAR 0 4
104678: PPUSH
104679: LD_VAR 0 2
104683: PPUSH
104684: CALL_OW 259
104688: PPUSH
104689: CALL 106087 0 2
104693: ST_TO_ADDR
104694: GO 104661
104696: POP
104697: POP
// if not tmp then
104698: LD_VAR 0 5
104702: NOT
104703: IFFALSE 104707
// exit ;
104705: GO 104727
// result := SortListByListDesc ( units , tmp ) ;
104707: LD_ADDR_VAR 0 3
104711: PUSH
104712: LD_VAR 0 1
104716: PPUSH
104717: LD_VAR 0 5
104721: PPUSH
104722: CALL_OW 77
104726: ST_TO_ADDR
// end ;
104727: LD_VAR 0 3
104731: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104732: LD_INT 0
104734: PPUSH
104735: PPUSH
104736: PPUSH
// result := false ;
104737: LD_ADDR_VAR 0 3
104741: PUSH
104742: LD_INT 0
104744: ST_TO_ADDR
// if not building then
104745: LD_VAR 0 2
104749: NOT
104750: IFFALSE 104754
// exit ;
104752: GO 104892
// x := GetX ( building ) ;
104754: LD_ADDR_VAR 0 4
104758: PUSH
104759: LD_VAR 0 2
104763: PPUSH
104764: CALL_OW 250
104768: ST_TO_ADDR
// y := GetY ( building ) ;
104769: LD_ADDR_VAR 0 5
104773: PUSH
104774: LD_VAR 0 2
104778: PPUSH
104779: CALL_OW 251
104783: ST_TO_ADDR
// if not x or not y then
104784: LD_VAR 0 4
104788: NOT
104789: PUSH
104790: LD_VAR 0 5
104794: NOT
104795: OR
104796: IFFALSE 104800
// exit ;
104798: GO 104892
// if GetTaskList ( unit ) then
104800: LD_VAR 0 1
104804: PPUSH
104805: CALL_OW 437
104809: IFFALSE 104892
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104811: LD_STRING e
104813: PUSH
104814: LD_VAR 0 1
104818: PPUSH
104819: CALL_OW 437
104823: PUSH
104824: LD_INT 1
104826: ARRAY
104827: PUSH
104828: LD_INT 1
104830: ARRAY
104831: EQUAL
104832: PUSH
104833: LD_VAR 0 4
104837: PUSH
104838: LD_VAR 0 1
104842: PPUSH
104843: CALL_OW 437
104847: PUSH
104848: LD_INT 1
104850: ARRAY
104851: PUSH
104852: LD_INT 2
104854: ARRAY
104855: EQUAL
104856: AND
104857: PUSH
104858: LD_VAR 0 5
104862: PUSH
104863: LD_VAR 0 1
104867: PPUSH
104868: CALL_OW 437
104872: PUSH
104873: LD_INT 1
104875: ARRAY
104876: PUSH
104877: LD_INT 3
104879: ARRAY
104880: EQUAL
104881: AND
104882: IFFALSE 104892
// result := true end ;
104884: LD_ADDR_VAR 0 3
104888: PUSH
104889: LD_INT 1
104891: ST_TO_ADDR
// end ;
104892: LD_VAR 0 3
104896: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
104897: LD_INT 0
104899: PPUSH
// result := false ;
104900: LD_ADDR_VAR 0 4
104904: PUSH
104905: LD_INT 0
104907: ST_TO_ADDR
// if GetTaskList ( unit ) then
104908: LD_VAR 0 1
104912: PPUSH
104913: CALL_OW 437
104917: IFFALSE 105000
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104919: LD_STRING M
104921: PUSH
104922: LD_VAR 0 1
104926: PPUSH
104927: CALL_OW 437
104931: PUSH
104932: LD_INT 1
104934: ARRAY
104935: PUSH
104936: LD_INT 1
104938: ARRAY
104939: EQUAL
104940: PUSH
104941: LD_VAR 0 2
104945: PUSH
104946: LD_VAR 0 1
104950: PPUSH
104951: CALL_OW 437
104955: PUSH
104956: LD_INT 1
104958: ARRAY
104959: PUSH
104960: LD_INT 2
104962: ARRAY
104963: EQUAL
104964: AND
104965: PUSH
104966: LD_VAR 0 3
104970: PUSH
104971: LD_VAR 0 1
104975: PPUSH
104976: CALL_OW 437
104980: PUSH
104981: LD_INT 1
104983: ARRAY
104984: PUSH
104985: LD_INT 3
104987: ARRAY
104988: EQUAL
104989: AND
104990: IFFALSE 105000
// result := true ;
104992: LD_ADDR_VAR 0 4
104996: PUSH
104997: LD_INT 1
104999: ST_TO_ADDR
// end ; end ;
105000: LD_VAR 0 4
105004: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105005: LD_INT 0
105007: PPUSH
105008: PPUSH
105009: PPUSH
105010: PPUSH
// if not unit or not area then
105011: LD_VAR 0 1
105015: NOT
105016: PUSH
105017: LD_VAR 0 2
105021: NOT
105022: OR
105023: IFFALSE 105027
// exit ;
105025: GO 105190
// tmp := AreaToList ( area , i ) ;
105027: LD_ADDR_VAR 0 6
105031: PUSH
105032: LD_VAR 0 2
105036: PPUSH
105037: LD_VAR 0 5
105041: PPUSH
105042: CALL_OW 517
105046: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105047: LD_ADDR_VAR 0 5
105051: PUSH
105052: DOUBLE
105053: LD_INT 1
105055: DEC
105056: ST_TO_ADDR
105057: LD_VAR 0 6
105061: PUSH
105062: LD_INT 1
105064: ARRAY
105065: PUSH
105066: FOR_TO
105067: IFFALSE 105188
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105069: LD_ADDR_VAR 0 7
105073: PUSH
105074: LD_VAR 0 6
105078: PUSH
105079: LD_INT 1
105081: ARRAY
105082: PUSH
105083: LD_VAR 0 5
105087: ARRAY
105088: PUSH
105089: LD_VAR 0 6
105093: PUSH
105094: LD_INT 2
105096: ARRAY
105097: PUSH
105098: LD_VAR 0 5
105102: ARRAY
105103: PUSH
105104: EMPTY
105105: LIST
105106: LIST
105107: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
105108: LD_INT 92
105110: PUSH
105111: LD_VAR 0 7
105115: PUSH
105116: LD_INT 1
105118: ARRAY
105119: PUSH
105120: LD_VAR 0 7
105124: PUSH
105125: LD_INT 2
105127: ARRAY
105128: PUSH
105129: LD_INT 3
105131: PUSH
105132: EMPTY
105133: LIST
105134: LIST
105135: LIST
105136: LIST
105137: PPUSH
105138: CALL_OW 69
105142: PUSH
105143: LD_INT 0
105145: EQUAL
105146: IFFALSE 105186
// begin PlaceUnitArea ( unit , area , mode ) ;
105148: LD_VAR 0 1
105152: PPUSH
105153: LD_VAR 0 2
105157: PPUSH
105158: LD_VAR 0 3
105162: PPUSH
105163: CALL_OW 49
// result := IsPlaced ( unit ) ;
105167: LD_ADDR_VAR 0 4
105171: PUSH
105172: LD_VAR 0 1
105176: PPUSH
105177: CALL_OW 305
105181: ST_TO_ADDR
// exit ;
105182: POP
105183: POP
105184: GO 105190
// end ; end ;
105186: GO 105066
105188: POP
105189: POP
// end ;
105190: LD_VAR 0 4
105194: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105195: LD_INT 0
105197: PPUSH
105198: PPUSH
105199: PPUSH
// if not side or side > 8 then
105200: LD_VAR 0 1
105204: NOT
105205: PUSH
105206: LD_VAR 0 1
105210: PUSH
105211: LD_INT 8
105213: GREATER
105214: OR
105215: IFFALSE 105219
// exit ;
105217: GO 105406
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105219: LD_ADDR_VAR 0 4
105223: PUSH
105224: LD_INT 22
105226: PUSH
105227: LD_VAR 0 1
105231: PUSH
105232: EMPTY
105233: LIST
105234: LIST
105235: PUSH
105236: LD_INT 21
105238: PUSH
105239: LD_INT 3
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: PUSH
105246: EMPTY
105247: LIST
105248: LIST
105249: PPUSH
105250: CALL_OW 69
105254: ST_TO_ADDR
// if not tmp then
105255: LD_VAR 0 4
105259: NOT
105260: IFFALSE 105264
// exit ;
105262: GO 105406
// enable_addtolog := true ;
105264: LD_ADDR_OWVAR 81
105268: PUSH
105269: LD_INT 1
105271: ST_TO_ADDR
// AddToLog ( [ ) ;
105272: LD_STRING [
105274: PPUSH
105275: CALL_OW 561
// for i in tmp do
105279: LD_ADDR_VAR 0 3
105283: PUSH
105284: LD_VAR 0 4
105288: PUSH
105289: FOR_IN
105290: IFFALSE 105397
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105292: LD_STRING [
105294: PUSH
105295: LD_VAR 0 3
105299: PPUSH
105300: CALL_OW 266
105304: STR
105305: PUSH
105306: LD_STRING , 
105308: STR
105309: PUSH
105310: LD_VAR 0 3
105314: PPUSH
105315: CALL_OW 250
105319: STR
105320: PUSH
105321: LD_STRING , 
105323: STR
105324: PUSH
105325: LD_VAR 0 3
105329: PPUSH
105330: CALL_OW 251
105334: STR
105335: PUSH
105336: LD_STRING , 
105338: STR
105339: PUSH
105340: LD_VAR 0 3
105344: PPUSH
105345: CALL_OW 254
105349: STR
105350: PUSH
105351: LD_STRING , 
105353: STR
105354: PUSH
105355: LD_VAR 0 3
105359: PPUSH
105360: LD_INT 1
105362: PPUSH
105363: CALL_OW 268
105367: STR
105368: PUSH
105369: LD_STRING , 
105371: STR
105372: PUSH
105373: LD_VAR 0 3
105377: PPUSH
105378: LD_INT 2
105380: PPUSH
105381: CALL_OW 268
105385: STR
105386: PUSH
105387: LD_STRING ],
105389: STR
105390: PPUSH
105391: CALL_OW 561
// end ;
105395: GO 105289
105397: POP
105398: POP
// AddToLog ( ]; ) ;
105399: LD_STRING ];
105401: PPUSH
105402: CALL_OW 561
// end ;
105406: LD_VAR 0 2
105410: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
105411: LD_INT 0
105413: PPUSH
105414: PPUSH
105415: PPUSH
105416: PPUSH
105417: PPUSH
// if not area or not rate or not max then
105418: LD_VAR 0 1
105422: NOT
105423: PUSH
105424: LD_VAR 0 2
105428: NOT
105429: OR
105430: PUSH
105431: LD_VAR 0 4
105435: NOT
105436: OR
105437: IFFALSE 105441
// exit ;
105439: GO 105630
// while 1 do
105441: LD_INT 1
105443: IFFALSE 105630
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
105445: LD_ADDR_VAR 0 9
105449: PUSH
105450: LD_VAR 0 1
105454: PPUSH
105455: LD_INT 1
105457: PPUSH
105458: CALL_OW 287
105462: PUSH
105463: LD_INT 10
105465: MUL
105466: ST_TO_ADDR
// r := rate / 10 ;
105467: LD_ADDR_VAR 0 7
105471: PUSH
105472: LD_VAR 0 2
105476: PUSH
105477: LD_INT 10
105479: DIVREAL
105480: ST_TO_ADDR
// time := 1 1$00 ;
105481: LD_ADDR_VAR 0 8
105485: PUSH
105486: LD_INT 2100
105488: ST_TO_ADDR
// if amount < min then
105489: LD_VAR 0 9
105493: PUSH
105494: LD_VAR 0 3
105498: LESS
105499: IFFALSE 105517
// r := r * 2 else
105501: LD_ADDR_VAR 0 7
105505: PUSH
105506: LD_VAR 0 7
105510: PUSH
105511: LD_INT 2
105513: MUL
105514: ST_TO_ADDR
105515: GO 105543
// if amount > max then
105517: LD_VAR 0 9
105521: PUSH
105522: LD_VAR 0 4
105526: GREATER
105527: IFFALSE 105543
// r := r / 2 ;
105529: LD_ADDR_VAR 0 7
105533: PUSH
105534: LD_VAR 0 7
105538: PUSH
105539: LD_INT 2
105541: DIVREAL
105542: ST_TO_ADDR
// time := time / r ;
105543: LD_ADDR_VAR 0 8
105547: PUSH
105548: LD_VAR 0 8
105552: PUSH
105553: LD_VAR 0 7
105557: DIVREAL
105558: ST_TO_ADDR
// if time < 0 then
105559: LD_VAR 0 8
105563: PUSH
105564: LD_INT 0
105566: LESS
105567: IFFALSE 105584
// time := time * - 1 ;
105569: LD_ADDR_VAR 0 8
105573: PUSH
105574: LD_VAR 0 8
105578: PUSH
105579: LD_INT 1
105581: NEG
105582: MUL
105583: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
105584: LD_VAR 0 8
105588: PUSH
105589: LD_INT 35
105591: PPUSH
105592: LD_INT 875
105594: PPUSH
105595: CALL_OW 12
105599: PLUS
105600: PPUSH
105601: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
105605: LD_INT 1
105607: PPUSH
105608: LD_INT 5
105610: PPUSH
105611: CALL_OW 12
105615: PPUSH
105616: LD_VAR 0 1
105620: PPUSH
105621: LD_INT 1
105623: PPUSH
105624: CALL_OW 55
// end ;
105628: GO 105441
// end ;
105630: LD_VAR 0 5
105634: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
105635: LD_INT 0
105637: PPUSH
105638: PPUSH
105639: PPUSH
105640: PPUSH
105641: PPUSH
105642: PPUSH
105643: PPUSH
105644: PPUSH
// if not turrets or not factories then
105645: LD_VAR 0 1
105649: NOT
105650: PUSH
105651: LD_VAR 0 2
105655: NOT
105656: OR
105657: IFFALSE 105661
// exit ;
105659: GO 105968
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
105661: LD_ADDR_VAR 0 10
105665: PUSH
105666: LD_INT 5
105668: PUSH
105669: LD_INT 6
105671: PUSH
105672: EMPTY
105673: LIST
105674: LIST
105675: PUSH
105676: LD_INT 2
105678: PUSH
105679: LD_INT 4
105681: PUSH
105682: EMPTY
105683: LIST
105684: LIST
105685: PUSH
105686: LD_INT 3
105688: PUSH
105689: LD_INT 5
105691: PUSH
105692: EMPTY
105693: LIST
105694: LIST
105695: PUSH
105696: EMPTY
105697: LIST
105698: LIST
105699: LIST
105700: PUSH
105701: LD_INT 24
105703: PUSH
105704: LD_INT 25
105706: PUSH
105707: EMPTY
105708: LIST
105709: LIST
105710: PUSH
105711: LD_INT 23
105713: PUSH
105714: LD_INT 27
105716: PUSH
105717: EMPTY
105718: LIST
105719: LIST
105720: PUSH
105721: EMPTY
105722: LIST
105723: LIST
105724: PUSH
105725: LD_INT 42
105727: PUSH
105728: LD_INT 43
105730: PUSH
105731: EMPTY
105732: LIST
105733: LIST
105734: PUSH
105735: LD_INT 44
105737: PUSH
105738: LD_INT 46
105740: PUSH
105741: EMPTY
105742: LIST
105743: LIST
105744: PUSH
105745: LD_INT 45
105747: PUSH
105748: LD_INT 47
105750: PUSH
105751: EMPTY
105752: LIST
105753: LIST
105754: PUSH
105755: EMPTY
105756: LIST
105757: LIST
105758: LIST
105759: PUSH
105760: EMPTY
105761: LIST
105762: LIST
105763: LIST
105764: ST_TO_ADDR
// result := [ ] ;
105765: LD_ADDR_VAR 0 3
105769: PUSH
105770: EMPTY
105771: ST_TO_ADDR
// for i in turrets do
105772: LD_ADDR_VAR 0 4
105776: PUSH
105777: LD_VAR 0 1
105781: PUSH
105782: FOR_IN
105783: IFFALSE 105966
// begin nat := GetNation ( i ) ;
105785: LD_ADDR_VAR 0 7
105789: PUSH
105790: LD_VAR 0 4
105794: PPUSH
105795: CALL_OW 248
105799: ST_TO_ADDR
// weapon := 0 ;
105800: LD_ADDR_VAR 0 8
105804: PUSH
105805: LD_INT 0
105807: ST_TO_ADDR
// if not nat then
105808: LD_VAR 0 7
105812: NOT
105813: IFFALSE 105817
// continue ;
105815: GO 105782
// for j in list [ nat ] do
105817: LD_ADDR_VAR 0 5
105821: PUSH
105822: LD_VAR 0 10
105826: PUSH
105827: LD_VAR 0 7
105831: ARRAY
105832: PUSH
105833: FOR_IN
105834: IFFALSE 105875
// if GetBWeapon ( i ) = j [ 1 ] then
105836: LD_VAR 0 4
105840: PPUSH
105841: CALL_OW 269
105845: PUSH
105846: LD_VAR 0 5
105850: PUSH
105851: LD_INT 1
105853: ARRAY
105854: EQUAL
105855: IFFALSE 105873
// begin weapon := j [ 2 ] ;
105857: LD_ADDR_VAR 0 8
105861: PUSH
105862: LD_VAR 0 5
105866: PUSH
105867: LD_INT 2
105869: ARRAY
105870: ST_TO_ADDR
// break ;
105871: GO 105875
// end ;
105873: GO 105833
105875: POP
105876: POP
// if not weapon then
105877: LD_VAR 0 8
105881: NOT
105882: IFFALSE 105886
// continue ;
105884: GO 105782
// for k in factories do
105886: LD_ADDR_VAR 0 6
105890: PUSH
105891: LD_VAR 0 2
105895: PUSH
105896: FOR_IN
105897: IFFALSE 105962
// begin weapons := AvailableWeaponList ( k ) ;
105899: LD_ADDR_VAR 0 9
105903: PUSH
105904: LD_VAR 0 6
105908: PPUSH
105909: CALL_OW 478
105913: ST_TO_ADDR
// if not weapons then
105914: LD_VAR 0 9
105918: NOT
105919: IFFALSE 105923
// continue ;
105921: GO 105896
// if weapon in weapons then
105923: LD_VAR 0 8
105927: PUSH
105928: LD_VAR 0 9
105932: IN
105933: IFFALSE 105960
// begin result := [ i , weapon ] ;
105935: LD_ADDR_VAR 0 3
105939: PUSH
105940: LD_VAR 0 4
105944: PUSH
105945: LD_VAR 0 8
105949: PUSH
105950: EMPTY
105951: LIST
105952: LIST
105953: ST_TO_ADDR
// exit ;
105954: POP
105955: POP
105956: POP
105957: POP
105958: GO 105968
// end ; end ;
105960: GO 105896
105962: POP
105963: POP
// end ;
105964: GO 105782
105966: POP
105967: POP
// end ;
105968: LD_VAR 0 3
105972: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105973: LD_INT 0
105975: PPUSH
// if not side or side > 8 then
105976: LD_VAR 0 3
105980: NOT
105981: PUSH
105982: LD_VAR 0 3
105986: PUSH
105987: LD_INT 8
105989: GREATER
105990: OR
105991: IFFALSE 105995
// exit ;
105993: GO 106054
// if not range then
105995: LD_VAR 0 4
105999: NOT
106000: IFFALSE 106011
// range := - 12 ;
106002: LD_ADDR_VAR 0 4
106006: PUSH
106007: LD_INT 12
106009: NEG
106010: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106011: LD_VAR 0 1
106015: PPUSH
106016: LD_VAR 0 2
106020: PPUSH
106021: LD_VAR 0 3
106025: PPUSH
106026: LD_VAR 0 4
106030: PPUSH
106031: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106035: LD_VAR 0 1
106039: PPUSH
106040: LD_VAR 0 2
106044: PPUSH
106045: LD_VAR 0 3
106049: PPUSH
106050: CALL_OW 331
// end ;
106054: LD_VAR 0 5
106058: RET
// export function Video ( mode ) ; begin
106059: LD_INT 0
106061: PPUSH
// ingame_video = mode ;
106062: LD_ADDR_OWVAR 52
106066: PUSH
106067: LD_VAR 0 1
106071: ST_TO_ADDR
// interface_hidden = mode ;
106072: LD_ADDR_OWVAR 54
106076: PUSH
106077: LD_VAR 0 1
106081: ST_TO_ADDR
// end ;
106082: LD_VAR 0 2
106086: RET
// export function Join ( array , element ) ; begin
106087: LD_INT 0
106089: PPUSH
// result := Replace ( array , array + 1 , element ) ;
106090: LD_ADDR_VAR 0 3
106094: PUSH
106095: LD_VAR 0 1
106099: PPUSH
106100: LD_VAR 0 1
106104: PUSH
106105: LD_INT 1
106107: PLUS
106108: PPUSH
106109: LD_VAR 0 2
106113: PPUSH
106114: CALL_OW 1
106118: ST_TO_ADDR
// end ;
106119: LD_VAR 0 3
106123: RET
// export function JoinUnion ( array , element ) ; begin
106124: LD_INT 0
106126: PPUSH
// result := array union element ;
106127: LD_ADDR_VAR 0 3
106131: PUSH
106132: LD_VAR 0 1
106136: PUSH
106137: LD_VAR 0 2
106141: UNION
106142: ST_TO_ADDR
// end ;
106143: LD_VAR 0 3
106147: RET
// export function GetBehemoths ( side ) ; begin
106148: LD_INT 0
106150: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
106151: LD_ADDR_VAR 0 2
106155: PUSH
106156: LD_INT 22
106158: PUSH
106159: LD_VAR 0 1
106163: PUSH
106164: EMPTY
106165: LIST
106166: LIST
106167: PUSH
106168: LD_INT 31
106170: PUSH
106171: LD_INT 25
106173: PUSH
106174: EMPTY
106175: LIST
106176: LIST
106177: PUSH
106178: EMPTY
106179: LIST
106180: LIST
106181: PPUSH
106182: CALL_OW 69
106186: ST_TO_ADDR
// end ;
106187: LD_VAR 0 2
106191: RET
// export function Shuffle ( array ) ; var i , index ; begin
106192: LD_INT 0
106194: PPUSH
106195: PPUSH
106196: PPUSH
// result := [ ] ;
106197: LD_ADDR_VAR 0 2
106201: PUSH
106202: EMPTY
106203: ST_TO_ADDR
// if not array then
106204: LD_VAR 0 1
106208: NOT
106209: IFFALSE 106213
// exit ;
106211: GO 106312
// Randomize ;
106213: CALL_OW 10
// for i = array downto 1 do
106217: LD_ADDR_VAR 0 3
106221: PUSH
106222: DOUBLE
106223: LD_VAR 0 1
106227: INC
106228: ST_TO_ADDR
106229: LD_INT 1
106231: PUSH
106232: FOR_DOWNTO
106233: IFFALSE 106310
// begin index := rand ( 1 , array ) ;
106235: LD_ADDR_VAR 0 4
106239: PUSH
106240: LD_INT 1
106242: PPUSH
106243: LD_VAR 0 1
106247: PPUSH
106248: CALL_OW 12
106252: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106253: LD_ADDR_VAR 0 2
106257: PUSH
106258: LD_VAR 0 2
106262: PPUSH
106263: LD_VAR 0 2
106267: PUSH
106268: LD_INT 1
106270: PLUS
106271: PPUSH
106272: LD_VAR 0 1
106276: PUSH
106277: LD_VAR 0 4
106281: ARRAY
106282: PPUSH
106283: CALL_OW 2
106287: ST_TO_ADDR
// array := Delete ( array , index ) ;
106288: LD_ADDR_VAR 0 1
106292: PUSH
106293: LD_VAR 0 1
106297: PPUSH
106298: LD_VAR 0 4
106302: PPUSH
106303: CALL_OW 3
106307: ST_TO_ADDR
// end ;
106308: GO 106232
106310: POP
106311: POP
// end ;
106312: LD_VAR 0 2
106316: RET
// export function GetBaseMaterials ( base ) ; begin
106317: LD_INT 0
106319: PPUSH
// result := [ 0 , 0 , 0 ] ;
106320: LD_ADDR_VAR 0 2
106324: PUSH
106325: LD_INT 0
106327: PUSH
106328: LD_INT 0
106330: PUSH
106331: LD_INT 0
106333: PUSH
106334: EMPTY
106335: LIST
106336: LIST
106337: LIST
106338: ST_TO_ADDR
// if not base then
106339: LD_VAR 0 1
106343: NOT
106344: IFFALSE 106348
// exit ;
106346: GO 106397
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
106348: LD_ADDR_VAR 0 2
106352: PUSH
106353: LD_VAR 0 1
106357: PPUSH
106358: LD_INT 1
106360: PPUSH
106361: CALL_OW 275
106365: PUSH
106366: LD_VAR 0 1
106370: PPUSH
106371: LD_INT 2
106373: PPUSH
106374: CALL_OW 275
106378: PUSH
106379: LD_VAR 0 1
106383: PPUSH
106384: LD_INT 3
106386: PPUSH
106387: CALL_OW 275
106391: PUSH
106392: EMPTY
106393: LIST
106394: LIST
106395: LIST
106396: ST_TO_ADDR
// end ;
106397: LD_VAR 0 2
106401: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
106402: LD_INT 0
106404: PPUSH
106405: PPUSH
// result := array ;
106406: LD_ADDR_VAR 0 3
106410: PUSH
106411: LD_VAR 0 1
106415: ST_TO_ADDR
// if size >= result then
106416: LD_VAR 0 2
106420: PUSH
106421: LD_VAR 0 3
106425: GREATEREQUAL
106426: IFFALSE 106430
// exit ;
106428: GO 106480
// if size then
106430: LD_VAR 0 2
106434: IFFALSE 106480
// for i := array downto size do
106436: LD_ADDR_VAR 0 4
106440: PUSH
106441: DOUBLE
106442: LD_VAR 0 1
106446: INC
106447: ST_TO_ADDR
106448: LD_VAR 0 2
106452: PUSH
106453: FOR_DOWNTO
106454: IFFALSE 106478
// result := Delete ( result , result ) ;
106456: LD_ADDR_VAR 0 3
106460: PUSH
106461: LD_VAR 0 3
106465: PPUSH
106466: LD_VAR 0 3
106470: PPUSH
106471: CALL_OW 3
106475: ST_TO_ADDR
106476: GO 106453
106478: POP
106479: POP
// end ;
106480: LD_VAR 0 3
106484: RET
// export function ComExit ( unit ) ; var tmp ; begin
106485: LD_INT 0
106487: PPUSH
106488: PPUSH
// if not IsInUnit ( unit ) then
106489: LD_VAR 0 1
106493: PPUSH
106494: CALL_OW 310
106498: NOT
106499: IFFALSE 106503
// exit ;
106501: GO 106563
// tmp := IsInUnit ( unit ) ;
106503: LD_ADDR_VAR 0 3
106507: PUSH
106508: LD_VAR 0 1
106512: PPUSH
106513: CALL_OW 310
106517: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
106518: LD_VAR 0 3
106522: PPUSH
106523: CALL_OW 247
106527: PUSH
106528: LD_INT 2
106530: EQUAL
106531: IFFALSE 106544
// ComExitVehicle ( unit ) else
106533: LD_VAR 0 1
106537: PPUSH
106538: CALL_OW 121
106542: GO 106553
// ComExitBuilding ( unit ) ;
106544: LD_VAR 0 1
106548: PPUSH
106549: CALL_OW 122
// result := tmp ;
106553: LD_ADDR_VAR 0 2
106557: PUSH
106558: LD_VAR 0 3
106562: ST_TO_ADDR
// end ;
106563: LD_VAR 0 2
106567: RET
// export function ComExitAll ( units ) ; var i ; begin
106568: LD_INT 0
106570: PPUSH
106571: PPUSH
// if not units then
106572: LD_VAR 0 1
106576: NOT
106577: IFFALSE 106581
// exit ;
106579: GO 106607
// for i in units do
106581: LD_ADDR_VAR 0 3
106585: PUSH
106586: LD_VAR 0 1
106590: PUSH
106591: FOR_IN
106592: IFFALSE 106605
// ComExit ( i ) ;
106594: LD_VAR 0 3
106598: PPUSH
106599: CALL 106485 0 1
106603: GO 106591
106605: POP
106606: POP
// end ;
106607: LD_VAR 0 2
106611: RET
// export function ResetHc ; begin
106612: LD_INT 0
106614: PPUSH
// InitHc ;
106615: CALL_OW 19
// hc_importance := 0 ;
106619: LD_ADDR_OWVAR 32
106623: PUSH
106624: LD_INT 0
106626: ST_TO_ADDR
// end ;
106627: LD_VAR 0 1
106631: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
106632: LD_INT 0
106634: PPUSH
106635: PPUSH
106636: PPUSH
// _x := ( x1 + x2 ) div 2 ;
106637: LD_ADDR_VAR 0 6
106641: PUSH
106642: LD_VAR 0 1
106646: PUSH
106647: LD_VAR 0 3
106651: PLUS
106652: PUSH
106653: LD_INT 2
106655: DIV
106656: ST_TO_ADDR
// if _x < 0 then
106657: LD_VAR 0 6
106661: PUSH
106662: LD_INT 0
106664: LESS
106665: IFFALSE 106682
// _x := _x * - 1 ;
106667: LD_ADDR_VAR 0 6
106671: PUSH
106672: LD_VAR 0 6
106676: PUSH
106677: LD_INT 1
106679: NEG
106680: MUL
106681: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
106682: LD_ADDR_VAR 0 7
106686: PUSH
106687: LD_VAR 0 2
106691: PUSH
106692: LD_VAR 0 4
106696: PLUS
106697: PUSH
106698: LD_INT 2
106700: DIV
106701: ST_TO_ADDR
// if _y < 0 then
106702: LD_VAR 0 7
106706: PUSH
106707: LD_INT 0
106709: LESS
106710: IFFALSE 106727
// _y := _y * - 1 ;
106712: LD_ADDR_VAR 0 7
106716: PUSH
106717: LD_VAR 0 7
106721: PUSH
106722: LD_INT 1
106724: NEG
106725: MUL
106726: ST_TO_ADDR
// result := [ _x , _y ] ;
106727: LD_ADDR_VAR 0 5
106731: PUSH
106732: LD_VAR 0 6
106736: PUSH
106737: LD_VAR 0 7
106741: PUSH
106742: EMPTY
106743: LIST
106744: LIST
106745: ST_TO_ADDR
// end ;
106746: LD_VAR 0 5
106750: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
106751: LD_INT 0
106753: PPUSH
106754: PPUSH
106755: PPUSH
106756: PPUSH
// task := GetTaskList ( unit ) ;
106757: LD_ADDR_VAR 0 7
106761: PUSH
106762: LD_VAR 0 1
106766: PPUSH
106767: CALL_OW 437
106771: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
106772: LD_VAR 0 7
106776: NOT
106777: PUSH
106778: LD_VAR 0 1
106782: PPUSH
106783: LD_VAR 0 2
106787: PPUSH
106788: CALL_OW 308
106792: NOT
106793: AND
106794: IFFALSE 106798
// exit ;
106796: GO 106916
// if IsInArea ( unit , area ) then
106798: LD_VAR 0 1
106802: PPUSH
106803: LD_VAR 0 2
106807: PPUSH
106808: CALL_OW 308
106812: IFFALSE 106830
// begin ComMoveToArea ( unit , goAway ) ;
106814: LD_VAR 0 1
106818: PPUSH
106819: LD_VAR 0 3
106823: PPUSH
106824: CALL_OW 113
// exit ;
106828: GO 106916
// end ; if task [ 1 ] [ 1 ] <> M then
106830: LD_VAR 0 7
106834: PUSH
106835: LD_INT 1
106837: ARRAY
106838: PUSH
106839: LD_INT 1
106841: ARRAY
106842: PUSH
106843: LD_STRING M
106845: NONEQUAL
106846: IFFALSE 106850
// exit ;
106848: GO 106916
// x := task [ 1 ] [ 2 ] ;
106850: LD_ADDR_VAR 0 5
106854: PUSH
106855: LD_VAR 0 7
106859: PUSH
106860: LD_INT 1
106862: ARRAY
106863: PUSH
106864: LD_INT 2
106866: ARRAY
106867: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
106868: LD_ADDR_VAR 0 6
106872: PUSH
106873: LD_VAR 0 7
106877: PUSH
106878: LD_INT 1
106880: ARRAY
106881: PUSH
106882: LD_INT 3
106884: ARRAY
106885: ST_TO_ADDR
// if InArea ( x , y , area ) then
106886: LD_VAR 0 5
106890: PPUSH
106891: LD_VAR 0 6
106895: PPUSH
106896: LD_VAR 0 2
106900: PPUSH
106901: CALL_OW 309
106905: IFFALSE 106916
// ComStop ( unit ) ;
106907: LD_VAR 0 1
106911: PPUSH
106912: CALL_OW 141
// end ;
106916: LD_VAR 0 4
106920: RET
// export function Abs ( value ) ; begin
106921: LD_INT 0
106923: PPUSH
// result := value ;
106924: LD_ADDR_VAR 0 2
106928: PUSH
106929: LD_VAR 0 1
106933: ST_TO_ADDR
// if value < 0 then
106934: LD_VAR 0 1
106938: PUSH
106939: LD_INT 0
106941: LESS
106942: IFFALSE 106959
// result := value * - 1 ;
106944: LD_ADDR_VAR 0 2
106948: PUSH
106949: LD_VAR 0 1
106953: PUSH
106954: LD_INT 1
106956: NEG
106957: MUL
106958: ST_TO_ADDR
// end ;
106959: LD_VAR 0 2
106963: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
106964: LD_INT 0
106966: PPUSH
106967: PPUSH
106968: PPUSH
106969: PPUSH
106970: PPUSH
106971: PPUSH
106972: PPUSH
106973: PPUSH
// if not unit or not building then
106974: LD_VAR 0 1
106978: NOT
106979: PUSH
106980: LD_VAR 0 2
106984: NOT
106985: OR
106986: IFFALSE 106990
// exit ;
106988: GO 107216
// x := GetX ( building ) ;
106990: LD_ADDR_VAR 0 4
106994: PUSH
106995: LD_VAR 0 2
106999: PPUSH
107000: CALL_OW 250
107004: ST_TO_ADDR
// y := GetY ( building ) ;
107005: LD_ADDR_VAR 0 6
107009: PUSH
107010: LD_VAR 0 2
107014: PPUSH
107015: CALL_OW 251
107019: ST_TO_ADDR
// d := GetDir ( building ) ;
107020: LD_ADDR_VAR 0 8
107024: PUSH
107025: LD_VAR 0 2
107029: PPUSH
107030: CALL_OW 254
107034: ST_TO_ADDR
// r := 4 ;
107035: LD_ADDR_VAR 0 9
107039: PUSH
107040: LD_INT 4
107042: ST_TO_ADDR
// for i := 1 to 5 do
107043: LD_ADDR_VAR 0 10
107047: PUSH
107048: DOUBLE
107049: LD_INT 1
107051: DEC
107052: ST_TO_ADDR
107053: LD_INT 5
107055: PUSH
107056: FOR_TO
107057: IFFALSE 107214
// begin _x := ShiftX ( x , d , r + i ) ;
107059: LD_ADDR_VAR 0 5
107063: PUSH
107064: LD_VAR 0 4
107068: PPUSH
107069: LD_VAR 0 8
107073: PPUSH
107074: LD_VAR 0 9
107078: PUSH
107079: LD_VAR 0 10
107083: PLUS
107084: PPUSH
107085: CALL_OW 272
107089: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
107090: LD_ADDR_VAR 0 7
107094: PUSH
107095: LD_VAR 0 6
107099: PPUSH
107100: LD_VAR 0 8
107104: PPUSH
107105: LD_VAR 0 9
107109: PUSH
107110: LD_VAR 0 10
107114: PLUS
107115: PPUSH
107116: CALL_OW 273
107120: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
107121: LD_VAR 0 5
107125: PPUSH
107126: LD_VAR 0 7
107130: PPUSH
107131: CALL_OW 488
107135: PUSH
107136: LD_VAR 0 5
107140: PPUSH
107141: LD_VAR 0 7
107145: PPUSH
107146: CALL_OW 428
107150: PPUSH
107151: CALL_OW 247
107155: PUSH
107156: LD_INT 3
107158: PUSH
107159: LD_INT 2
107161: PUSH
107162: EMPTY
107163: LIST
107164: LIST
107165: IN
107166: NOT
107167: AND
107168: IFFALSE 107212
// begin ComMoveXY ( unit , _x , _y ) ;
107170: LD_VAR 0 1
107174: PPUSH
107175: LD_VAR 0 5
107179: PPUSH
107180: LD_VAR 0 7
107184: PPUSH
107185: CALL_OW 111
// result := [ _x , _y ] ;
107189: LD_ADDR_VAR 0 3
107193: PUSH
107194: LD_VAR 0 5
107198: PUSH
107199: LD_VAR 0 7
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: ST_TO_ADDR
// exit ;
107208: POP
107209: POP
107210: GO 107216
// end ; end ;
107212: GO 107056
107214: POP
107215: POP
// end ;
107216: LD_VAR 0 3
107220: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
107221: LD_INT 0
107223: PPUSH
107224: PPUSH
107225: PPUSH
// result := 0 ;
107226: LD_ADDR_VAR 0 3
107230: PUSH
107231: LD_INT 0
107233: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
107234: LD_VAR 0 1
107238: PUSH
107239: LD_INT 0
107241: LESS
107242: PUSH
107243: LD_VAR 0 1
107247: PUSH
107248: LD_INT 8
107250: GREATER
107251: OR
107252: PUSH
107253: LD_VAR 0 2
107257: PUSH
107258: LD_INT 0
107260: LESS
107261: OR
107262: PUSH
107263: LD_VAR 0 2
107267: PUSH
107268: LD_INT 8
107270: GREATER
107271: OR
107272: IFFALSE 107276
// exit ;
107274: GO 107351
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
107276: LD_ADDR_VAR 0 4
107280: PUSH
107281: LD_INT 22
107283: PUSH
107284: LD_VAR 0 2
107288: PUSH
107289: EMPTY
107290: LIST
107291: LIST
107292: PPUSH
107293: CALL_OW 69
107297: PUSH
107298: FOR_IN
107299: IFFALSE 107349
// begin un := UnitShoot ( i ) ;
107301: LD_ADDR_VAR 0 5
107305: PUSH
107306: LD_VAR 0 4
107310: PPUSH
107311: CALL_OW 504
107315: ST_TO_ADDR
// if GetSide ( un ) = side1 then
107316: LD_VAR 0 5
107320: PPUSH
107321: CALL_OW 255
107325: PUSH
107326: LD_VAR 0 1
107330: EQUAL
107331: IFFALSE 107347
// begin result := un ;
107333: LD_ADDR_VAR 0 3
107337: PUSH
107338: LD_VAR 0 5
107342: ST_TO_ADDR
// exit ;
107343: POP
107344: POP
107345: GO 107351
// end ; end ;
107347: GO 107298
107349: POP
107350: POP
// end ;
107351: LD_VAR 0 3
107355: RET
// export function GetCargoBay ( units ) ; begin
107356: LD_INT 0
107358: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
107359: LD_ADDR_VAR 0 2
107363: PUSH
107364: LD_VAR 0 1
107368: PPUSH
107369: LD_INT 2
107371: PUSH
107372: LD_INT 34
107374: PUSH
107375: LD_INT 12
107377: PUSH
107378: EMPTY
107379: LIST
107380: LIST
107381: PUSH
107382: LD_INT 34
107384: PUSH
107385: LD_INT 51
107387: PUSH
107388: EMPTY
107389: LIST
107390: LIST
107391: PUSH
107392: LD_INT 34
107394: PUSH
107395: LD_INT 32
107397: PUSH
107398: EMPTY
107399: LIST
107400: LIST
107401: PUSH
107402: LD_INT 34
107404: PUSH
107405: LD_INT 89
107407: PUSH
107408: EMPTY
107409: LIST
107410: LIST
107411: PUSH
107412: EMPTY
107413: LIST
107414: LIST
107415: LIST
107416: LIST
107417: LIST
107418: PPUSH
107419: CALL_OW 72
107423: ST_TO_ADDR
// end ;
107424: LD_VAR 0 2
107428: RET
// export function Negate ( value ) ; begin
107429: LD_INT 0
107431: PPUSH
// result := not value ;
107432: LD_ADDR_VAR 0 2
107436: PUSH
107437: LD_VAR 0 1
107441: NOT
107442: ST_TO_ADDR
// end ;
107443: LD_VAR 0 2
107447: RET
// export function Inc ( value ) ; begin
107448: LD_INT 0
107450: PPUSH
// result := value + 1 ;
107451: LD_ADDR_VAR 0 2
107455: PUSH
107456: LD_VAR 0 1
107460: PUSH
107461: LD_INT 1
107463: PLUS
107464: ST_TO_ADDR
// end ;
107465: LD_VAR 0 2
107469: RET
// export function Dec ( value ) ; begin
107470: LD_INT 0
107472: PPUSH
// result := value - 1 ;
107473: LD_ADDR_VAR 0 2
107477: PUSH
107478: LD_VAR 0 1
107482: PUSH
107483: LD_INT 1
107485: MINUS
107486: ST_TO_ADDR
// end ;
107487: LD_VAR 0 2
107491: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
107492: LD_INT 0
107494: PPUSH
107495: PPUSH
107496: PPUSH
107497: PPUSH
107498: PPUSH
107499: PPUSH
107500: PPUSH
107501: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
107502: LD_VAR 0 1
107506: PPUSH
107507: LD_VAR 0 2
107511: PPUSH
107512: CALL_OW 488
107516: NOT
107517: PUSH
107518: LD_VAR 0 3
107522: PPUSH
107523: LD_VAR 0 4
107527: PPUSH
107528: CALL_OW 488
107532: NOT
107533: OR
107534: IFFALSE 107547
// begin result := - 1 ;
107536: LD_ADDR_VAR 0 5
107540: PUSH
107541: LD_INT 1
107543: NEG
107544: ST_TO_ADDR
// exit ;
107545: GO 107782
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
107547: LD_ADDR_VAR 0 12
107551: PUSH
107552: LD_VAR 0 1
107556: PPUSH
107557: LD_VAR 0 2
107561: PPUSH
107562: LD_VAR 0 3
107566: PPUSH
107567: LD_VAR 0 4
107571: PPUSH
107572: CALL 106632 0 4
107576: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
107577: LD_ADDR_VAR 0 11
107581: PUSH
107582: LD_VAR 0 1
107586: PPUSH
107587: LD_VAR 0 2
107591: PPUSH
107592: LD_VAR 0 12
107596: PUSH
107597: LD_INT 1
107599: ARRAY
107600: PPUSH
107601: LD_VAR 0 12
107605: PUSH
107606: LD_INT 2
107608: ARRAY
107609: PPUSH
107610: CALL_OW 298
107614: ST_TO_ADDR
// distance := 9999 ;
107615: LD_ADDR_VAR 0 10
107619: PUSH
107620: LD_INT 9999
107622: ST_TO_ADDR
// for i := 0 to 5 do
107623: LD_ADDR_VAR 0 6
107627: PUSH
107628: DOUBLE
107629: LD_INT 0
107631: DEC
107632: ST_TO_ADDR
107633: LD_INT 5
107635: PUSH
107636: FOR_TO
107637: IFFALSE 107780
// begin _x := ShiftX ( x1 , i , centerDist ) ;
107639: LD_ADDR_VAR 0 7
107643: PUSH
107644: LD_VAR 0 1
107648: PPUSH
107649: LD_VAR 0 6
107653: PPUSH
107654: LD_VAR 0 11
107658: PPUSH
107659: CALL_OW 272
107663: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
107664: LD_ADDR_VAR 0 8
107668: PUSH
107669: LD_VAR 0 2
107673: PPUSH
107674: LD_VAR 0 6
107678: PPUSH
107679: LD_VAR 0 11
107683: PPUSH
107684: CALL_OW 273
107688: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107689: LD_VAR 0 7
107693: PPUSH
107694: LD_VAR 0 8
107698: PPUSH
107699: CALL_OW 488
107703: NOT
107704: IFFALSE 107708
// continue ;
107706: GO 107636
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
107708: LD_ADDR_VAR 0 9
107712: PUSH
107713: LD_VAR 0 12
107717: PUSH
107718: LD_INT 1
107720: ARRAY
107721: PPUSH
107722: LD_VAR 0 12
107726: PUSH
107727: LD_INT 2
107729: ARRAY
107730: PPUSH
107731: LD_VAR 0 7
107735: PPUSH
107736: LD_VAR 0 8
107740: PPUSH
107741: CALL_OW 298
107745: ST_TO_ADDR
// if tmp < distance then
107746: LD_VAR 0 9
107750: PUSH
107751: LD_VAR 0 10
107755: LESS
107756: IFFALSE 107778
// begin result := i ;
107758: LD_ADDR_VAR 0 5
107762: PUSH
107763: LD_VAR 0 6
107767: ST_TO_ADDR
// distance := tmp ;
107768: LD_ADDR_VAR 0 10
107772: PUSH
107773: LD_VAR 0 9
107777: ST_TO_ADDR
// end ; end ;
107778: GO 107636
107780: POP
107781: POP
// end ;
107782: LD_VAR 0 5
107786: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
107787: LD_INT 0
107789: PPUSH
107790: PPUSH
// if not driver or not IsInUnit ( driver ) then
107791: LD_VAR 0 1
107795: NOT
107796: PUSH
107797: LD_VAR 0 1
107801: PPUSH
107802: CALL_OW 310
107806: NOT
107807: OR
107808: IFFALSE 107812
// exit ;
107810: GO 107902
// vehicle := IsInUnit ( driver ) ;
107812: LD_ADDR_VAR 0 3
107816: PUSH
107817: LD_VAR 0 1
107821: PPUSH
107822: CALL_OW 310
107826: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107827: LD_VAR 0 1
107831: PPUSH
107832: LD_STRING \
107834: PUSH
107835: LD_INT 0
107837: PUSH
107838: LD_INT 0
107840: PUSH
107841: LD_INT 0
107843: PUSH
107844: LD_INT 0
107846: PUSH
107847: LD_INT 0
107849: PUSH
107850: LD_INT 0
107852: PUSH
107853: EMPTY
107854: LIST
107855: LIST
107856: LIST
107857: LIST
107858: LIST
107859: LIST
107860: LIST
107861: PUSH
107862: LD_STRING E
107864: PUSH
107865: LD_INT 0
107867: PUSH
107868: LD_INT 0
107870: PUSH
107871: LD_VAR 0 3
107875: PUSH
107876: LD_INT 0
107878: PUSH
107879: LD_INT 0
107881: PUSH
107882: LD_INT 0
107884: PUSH
107885: EMPTY
107886: LIST
107887: LIST
107888: LIST
107889: LIST
107890: LIST
107891: LIST
107892: LIST
107893: PUSH
107894: EMPTY
107895: LIST
107896: LIST
107897: PPUSH
107898: CALL_OW 446
// end ;
107902: LD_VAR 0 2
107906: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
107907: LD_INT 0
107909: PPUSH
107910: PPUSH
// if not driver or not IsInUnit ( driver ) then
107911: LD_VAR 0 1
107915: NOT
107916: PUSH
107917: LD_VAR 0 1
107921: PPUSH
107922: CALL_OW 310
107926: NOT
107927: OR
107928: IFFALSE 107932
// exit ;
107930: GO 108022
// vehicle := IsInUnit ( driver ) ;
107932: LD_ADDR_VAR 0 3
107936: PUSH
107937: LD_VAR 0 1
107941: PPUSH
107942: CALL_OW 310
107946: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107947: LD_VAR 0 1
107951: PPUSH
107952: LD_STRING \
107954: PUSH
107955: LD_INT 0
107957: PUSH
107958: LD_INT 0
107960: PUSH
107961: LD_INT 0
107963: PUSH
107964: LD_INT 0
107966: PUSH
107967: LD_INT 0
107969: PUSH
107970: LD_INT 0
107972: PUSH
107973: EMPTY
107974: LIST
107975: LIST
107976: LIST
107977: LIST
107978: LIST
107979: LIST
107980: LIST
107981: PUSH
107982: LD_STRING E
107984: PUSH
107985: LD_INT 0
107987: PUSH
107988: LD_INT 0
107990: PUSH
107991: LD_VAR 0 3
107995: PUSH
107996: LD_INT 0
107998: PUSH
107999: LD_INT 0
108001: PUSH
108002: LD_INT 0
108004: PUSH
108005: EMPTY
108006: LIST
108007: LIST
108008: LIST
108009: LIST
108010: LIST
108011: LIST
108012: LIST
108013: PUSH
108014: EMPTY
108015: LIST
108016: LIST
108017: PPUSH
108018: CALL_OW 447
// end ;
108022: LD_VAR 0 2
108026: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
108027: LD_INT 0
108029: PPUSH
108030: PPUSH
108031: PPUSH
// tmp := [ ] ;
108032: LD_ADDR_VAR 0 5
108036: PUSH
108037: EMPTY
108038: ST_TO_ADDR
// for i in units do
108039: LD_ADDR_VAR 0 4
108043: PUSH
108044: LD_VAR 0 1
108048: PUSH
108049: FOR_IN
108050: IFFALSE 108088
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
108052: LD_ADDR_VAR 0 5
108056: PUSH
108057: LD_VAR 0 5
108061: PPUSH
108062: LD_VAR 0 5
108066: PUSH
108067: LD_INT 1
108069: PLUS
108070: PPUSH
108071: LD_VAR 0 4
108075: PPUSH
108076: CALL_OW 256
108080: PPUSH
108081: CALL_OW 2
108085: ST_TO_ADDR
108086: GO 108049
108088: POP
108089: POP
// if not tmp then
108090: LD_VAR 0 5
108094: NOT
108095: IFFALSE 108099
// exit ;
108097: GO 108147
// if asc then
108099: LD_VAR 0 2
108103: IFFALSE 108127
// result := SortListByListAsc ( units , tmp ) else
108105: LD_ADDR_VAR 0 3
108109: PUSH
108110: LD_VAR 0 1
108114: PPUSH
108115: LD_VAR 0 5
108119: PPUSH
108120: CALL_OW 76
108124: ST_TO_ADDR
108125: GO 108147
// result := SortListByListDesc ( units , tmp ) ;
108127: LD_ADDR_VAR 0 3
108131: PUSH
108132: LD_VAR 0 1
108136: PPUSH
108137: LD_VAR 0 5
108141: PPUSH
108142: CALL_OW 77
108146: ST_TO_ADDR
// end ;
108147: LD_VAR 0 3
108151: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
108152: LD_INT 0
108154: PPUSH
108155: PPUSH
// task := GetTaskList ( mech ) ;
108156: LD_ADDR_VAR 0 4
108160: PUSH
108161: LD_VAR 0 1
108165: PPUSH
108166: CALL_OW 437
108170: ST_TO_ADDR
// if not task then
108171: LD_VAR 0 4
108175: NOT
108176: IFFALSE 108180
// exit ;
108178: GO 108222
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
108180: LD_ADDR_VAR 0 3
108184: PUSH
108185: LD_VAR 0 4
108189: PUSH
108190: LD_INT 1
108192: ARRAY
108193: PUSH
108194: LD_INT 1
108196: ARRAY
108197: PUSH
108198: LD_STRING r
108200: EQUAL
108201: PUSH
108202: LD_VAR 0 4
108206: PUSH
108207: LD_INT 1
108209: ARRAY
108210: PUSH
108211: LD_INT 4
108213: ARRAY
108214: PUSH
108215: LD_VAR 0 2
108219: EQUAL
108220: AND
108221: ST_TO_ADDR
// end ;
108222: LD_VAR 0 3
108226: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
108227: LD_INT 0
108229: PPUSH
// SetDir ( unit , d ) ;
108230: LD_VAR 0 1
108234: PPUSH
108235: LD_VAR 0 4
108239: PPUSH
108240: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
108244: LD_VAR 0 1
108248: PPUSH
108249: LD_VAR 0 2
108253: PPUSH
108254: LD_VAR 0 3
108258: PPUSH
108259: LD_VAR 0 5
108263: PPUSH
108264: CALL_OW 48
// end ;
108268: LD_VAR 0 6
108272: RET
// export function ToNaturalNumber ( number ) ; begin
108273: LD_INT 0
108275: PPUSH
// result := number div 1 ;
108276: LD_ADDR_VAR 0 2
108280: PUSH
108281: LD_VAR 0 1
108285: PUSH
108286: LD_INT 1
108288: DIV
108289: ST_TO_ADDR
// if number < 0 then
108290: LD_VAR 0 1
108294: PUSH
108295: LD_INT 0
108297: LESS
108298: IFFALSE 108308
// result := 0 ;
108300: LD_ADDR_VAR 0 2
108304: PUSH
108305: LD_INT 0
108307: ST_TO_ADDR
// end ;
108308: LD_VAR 0 2
108312: RET
// export function SortByClass ( units , class ) ; var un ; begin
108313: LD_INT 0
108315: PPUSH
108316: PPUSH
// if not units or not class then
108317: LD_VAR 0 1
108321: NOT
108322: PUSH
108323: LD_VAR 0 2
108327: NOT
108328: OR
108329: IFFALSE 108333
// exit ;
108331: GO 108428
// result := [ ] ;
108333: LD_ADDR_VAR 0 3
108337: PUSH
108338: EMPTY
108339: ST_TO_ADDR
// for un in units do
108340: LD_ADDR_VAR 0 4
108344: PUSH
108345: LD_VAR 0 1
108349: PUSH
108350: FOR_IN
108351: IFFALSE 108426
// if GetClass ( un ) = class then
108353: LD_VAR 0 4
108357: PPUSH
108358: CALL_OW 257
108362: PUSH
108363: LD_VAR 0 2
108367: EQUAL
108368: IFFALSE 108395
// result := Insert ( result , 1 , un ) else
108370: LD_ADDR_VAR 0 3
108374: PUSH
108375: LD_VAR 0 3
108379: PPUSH
108380: LD_INT 1
108382: PPUSH
108383: LD_VAR 0 4
108387: PPUSH
108388: CALL_OW 2
108392: ST_TO_ADDR
108393: GO 108424
// result := Replace ( result , result + 1 , un ) ;
108395: LD_ADDR_VAR 0 3
108399: PUSH
108400: LD_VAR 0 3
108404: PPUSH
108405: LD_VAR 0 3
108409: PUSH
108410: LD_INT 1
108412: PLUS
108413: PPUSH
108414: LD_VAR 0 4
108418: PPUSH
108419: CALL_OW 1
108423: ST_TO_ADDR
108424: GO 108350
108426: POP
108427: POP
// end ;
108428: LD_VAR 0 3
108432: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
108433: LD_INT 0
108435: PPUSH
108436: PPUSH
108437: PPUSH
108438: PPUSH
108439: PPUSH
108440: PPUSH
108441: PPUSH
// result := [ ] ;
108442: LD_ADDR_VAR 0 4
108446: PUSH
108447: EMPTY
108448: ST_TO_ADDR
// if x - r < 0 then
108449: LD_VAR 0 1
108453: PUSH
108454: LD_VAR 0 3
108458: MINUS
108459: PUSH
108460: LD_INT 0
108462: LESS
108463: IFFALSE 108475
// min_x := 0 else
108465: LD_ADDR_VAR 0 8
108469: PUSH
108470: LD_INT 0
108472: ST_TO_ADDR
108473: GO 108491
// min_x := x - r ;
108475: LD_ADDR_VAR 0 8
108479: PUSH
108480: LD_VAR 0 1
108484: PUSH
108485: LD_VAR 0 3
108489: MINUS
108490: ST_TO_ADDR
// if y - r < 0 then
108491: LD_VAR 0 2
108495: PUSH
108496: LD_VAR 0 3
108500: MINUS
108501: PUSH
108502: LD_INT 0
108504: LESS
108505: IFFALSE 108517
// min_y := 0 else
108507: LD_ADDR_VAR 0 7
108511: PUSH
108512: LD_INT 0
108514: ST_TO_ADDR
108515: GO 108533
// min_y := y - r ;
108517: LD_ADDR_VAR 0 7
108521: PUSH
108522: LD_VAR 0 2
108526: PUSH
108527: LD_VAR 0 3
108531: MINUS
108532: ST_TO_ADDR
// max_x := x + r ;
108533: LD_ADDR_VAR 0 9
108537: PUSH
108538: LD_VAR 0 1
108542: PUSH
108543: LD_VAR 0 3
108547: PLUS
108548: ST_TO_ADDR
// max_y := y + r ;
108549: LD_ADDR_VAR 0 10
108553: PUSH
108554: LD_VAR 0 2
108558: PUSH
108559: LD_VAR 0 3
108563: PLUS
108564: ST_TO_ADDR
// for _x = min_x to max_x do
108565: LD_ADDR_VAR 0 5
108569: PUSH
108570: DOUBLE
108571: LD_VAR 0 8
108575: DEC
108576: ST_TO_ADDR
108577: LD_VAR 0 9
108581: PUSH
108582: FOR_TO
108583: IFFALSE 108684
// for _y = min_y to max_y do
108585: LD_ADDR_VAR 0 6
108589: PUSH
108590: DOUBLE
108591: LD_VAR 0 7
108595: DEC
108596: ST_TO_ADDR
108597: LD_VAR 0 10
108601: PUSH
108602: FOR_TO
108603: IFFALSE 108680
// begin if not ValidHex ( _x , _y ) then
108605: LD_VAR 0 5
108609: PPUSH
108610: LD_VAR 0 6
108614: PPUSH
108615: CALL_OW 488
108619: NOT
108620: IFFALSE 108624
// continue ;
108622: GO 108602
// if GetResourceTypeXY ( _x , _y ) then
108624: LD_VAR 0 5
108628: PPUSH
108629: LD_VAR 0 6
108633: PPUSH
108634: CALL_OW 283
108638: IFFALSE 108678
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
108640: LD_ADDR_VAR 0 4
108644: PUSH
108645: LD_VAR 0 4
108649: PPUSH
108650: LD_VAR 0 4
108654: PUSH
108655: LD_INT 1
108657: PLUS
108658: PPUSH
108659: LD_VAR 0 5
108663: PUSH
108664: LD_VAR 0 6
108668: PUSH
108669: EMPTY
108670: LIST
108671: LIST
108672: PPUSH
108673: CALL_OW 1
108677: ST_TO_ADDR
// end ;
108678: GO 108602
108680: POP
108681: POP
108682: GO 108582
108684: POP
108685: POP
// end ;
108686: LD_VAR 0 4
108690: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
108691: LD_INT 0
108693: PPUSH
108694: PPUSH
108695: PPUSH
108696: PPUSH
108697: PPUSH
108698: PPUSH
108699: PPUSH
108700: PPUSH
// if not units then
108701: LD_VAR 0 1
108705: NOT
108706: IFFALSE 108710
// exit ;
108708: GO 109234
// result := UnitFilter ( units , [ f_ok ] ) ;
108710: LD_ADDR_VAR 0 3
108714: PUSH
108715: LD_VAR 0 1
108719: PPUSH
108720: LD_INT 50
108722: PUSH
108723: EMPTY
108724: LIST
108725: PPUSH
108726: CALL_OW 72
108730: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
108731: LD_ADDR_VAR 0 8
108735: PUSH
108736: LD_VAR 0 1
108740: PUSH
108741: LD_INT 1
108743: ARRAY
108744: PPUSH
108745: CALL_OW 255
108749: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
108750: LD_ADDR_VAR 0 10
108754: PUSH
108755: LD_INT 29
108757: PUSH
108758: LD_INT 91
108760: PUSH
108761: LD_INT 49
108763: PUSH
108764: EMPTY
108765: LIST
108766: LIST
108767: LIST
108768: ST_TO_ADDR
// if not result then
108769: LD_VAR 0 3
108773: NOT
108774: IFFALSE 108778
// exit ;
108776: GO 109234
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
108778: LD_ADDR_VAR 0 5
108782: PUSH
108783: LD_INT 81
108785: PUSH
108786: LD_VAR 0 8
108790: PUSH
108791: EMPTY
108792: LIST
108793: LIST
108794: PPUSH
108795: CALL_OW 69
108799: ST_TO_ADDR
// for i in result do
108800: LD_ADDR_VAR 0 4
108804: PUSH
108805: LD_VAR 0 3
108809: PUSH
108810: FOR_IN
108811: IFFALSE 109232
// begin tag := GetTag ( i ) + 1 ;
108813: LD_ADDR_VAR 0 9
108817: PUSH
108818: LD_VAR 0 4
108822: PPUSH
108823: CALL_OW 110
108827: PUSH
108828: LD_INT 1
108830: PLUS
108831: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
108832: LD_ADDR_VAR 0 7
108836: PUSH
108837: LD_VAR 0 4
108841: PPUSH
108842: CALL_OW 250
108846: PPUSH
108847: LD_VAR 0 4
108851: PPUSH
108852: CALL_OW 251
108856: PPUSH
108857: LD_INT 6
108859: PPUSH
108860: CALL 108433 0 3
108864: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
108865: LD_VAR 0 4
108869: PPUSH
108870: CALL_OW 247
108874: PUSH
108875: LD_INT 2
108877: EQUAL
108878: PUSH
108879: LD_VAR 0 7
108883: AND
108884: PUSH
108885: LD_VAR 0 4
108889: PPUSH
108890: CALL_OW 264
108894: PUSH
108895: LD_VAR 0 10
108899: IN
108900: NOT
108901: AND
108902: IFFALSE 108941
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
108904: LD_VAR 0 4
108908: PPUSH
108909: LD_VAR 0 7
108913: PUSH
108914: LD_INT 1
108916: ARRAY
108917: PUSH
108918: LD_INT 1
108920: ARRAY
108921: PPUSH
108922: LD_VAR 0 7
108926: PUSH
108927: LD_INT 1
108929: ARRAY
108930: PUSH
108931: LD_INT 2
108933: ARRAY
108934: PPUSH
108935: CALL_OW 116
108939: GO 109230
// if path > tag then
108941: LD_VAR 0 2
108945: PUSH
108946: LD_VAR 0 9
108950: GREATER
108951: IFFALSE 109159
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
108953: LD_ADDR_VAR 0 6
108957: PUSH
108958: LD_VAR 0 5
108962: PPUSH
108963: LD_INT 91
108965: PUSH
108966: LD_VAR 0 4
108970: PUSH
108971: LD_INT 8
108973: PUSH
108974: EMPTY
108975: LIST
108976: LIST
108977: LIST
108978: PPUSH
108979: CALL_OW 72
108983: ST_TO_ADDR
// if nearEnemy then
108984: LD_VAR 0 6
108988: IFFALSE 109057
// begin if GetWeapon ( i ) = ru_time_lapser then
108990: LD_VAR 0 4
108994: PPUSH
108995: CALL_OW 264
108999: PUSH
109000: LD_INT 49
109002: EQUAL
109003: IFFALSE 109031
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
109005: LD_VAR 0 4
109009: PPUSH
109010: LD_VAR 0 6
109014: PPUSH
109015: LD_VAR 0 4
109019: PPUSH
109020: CALL_OW 74
109024: PPUSH
109025: CALL_OW 112
109029: GO 109055
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
109031: LD_VAR 0 4
109035: PPUSH
109036: LD_VAR 0 6
109040: PPUSH
109041: LD_VAR 0 4
109045: PPUSH
109046: CALL_OW 74
109050: PPUSH
109051: CALL_OW 115
// end else
109055: GO 109157
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
109057: LD_VAR 0 4
109061: PPUSH
109062: LD_VAR 0 2
109066: PUSH
109067: LD_VAR 0 9
109071: ARRAY
109072: PUSH
109073: LD_INT 1
109075: ARRAY
109076: PPUSH
109077: LD_VAR 0 2
109081: PUSH
109082: LD_VAR 0 9
109086: ARRAY
109087: PUSH
109088: LD_INT 2
109090: ARRAY
109091: PPUSH
109092: CALL_OW 297
109096: PUSH
109097: LD_INT 6
109099: GREATER
109100: IFFALSE 109143
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
109102: LD_VAR 0 4
109106: PPUSH
109107: LD_VAR 0 2
109111: PUSH
109112: LD_VAR 0 9
109116: ARRAY
109117: PUSH
109118: LD_INT 1
109120: ARRAY
109121: PPUSH
109122: LD_VAR 0 2
109126: PUSH
109127: LD_VAR 0 9
109131: ARRAY
109132: PUSH
109133: LD_INT 2
109135: ARRAY
109136: PPUSH
109137: CALL_OW 114
109141: GO 109157
// SetTag ( i , tag ) ;
109143: LD_VAR 0 4
109147: PPUSH
109148: LD_VAR 0 9
109152: PPUSH
109153: CALL_OW 109
// end else
109157: GO 109230
// if enemy then
109159: LD_VAR 0 5
109163: IFFALSE 109230
// begin if GetWeapon ( i ) = ru_time_lapser then
109165: LD_VAR 0 4
109169: PPUSH
109170: CALL_OW 264
109174: PUSH
109175: LD_INT 49
109177: EQUAL
109178: IFFALSE 109206
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
109180: LD_VAR 0 4
109184: PPUSH
109185: LD_VAR 0 5
109189: PPUSH
109190: LD_VAR 0 4
109194: PPUSH
109195: CALL_OW 74
109199: PPUSH
109200: CALL_OW 112
109204: GO 109230
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
109206: LD_VAR 0 4
109210: PPUSH
109211: LD_VAR 0 5
109215: PPUSH
109216: LD_VAR 0 4
109220: PPUSH
109221: CALL_OW 74
109225: PPUSH
109226: CALL_OW 115
// end ; end ;
109230: GO 108810
109232: POP
109233: POP
// end ;
109234: LD_VAR 0 3
109238: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
109239: LD_INT 0
109241: PPUSH
109242: PPUSH
109243: PPUSH
// if not unit or IsInUnit ( unit ) then
109244: LD_VAR 0 1
109248: NOT
109249: PUSH
109250: LD_VAR 0 1
109254: PPUSH
109255: CALL_OW 310
109259: OR
109260: IFFALSE 109264
// exit ;
109262: GO 109355
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
109264: LD_ADDR_VAR 0 4
109268: PUSH
109269: LD_VAR 0 1
109273: PPUSH
109274: CALL_OW 250
109278: PPUSH
109279: LD_VAR 0 2
109283: PPUSH
109284: LD_INT 1
109286: PPUSH
109287: CALL_OW 272
109291: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
109292: LD_ADDR_VAR 0 5
109296: PUSH
109297: LD_VAR 0 1
109301: PPUSH
109302: CALL_OW 251
109306: PPUSH
109307: LD_VAR 0 2
109311: PPUSH
109312: LD_INT 1
109314: PPUSH
109315: CALL_OW 273
109319: ST_TO_ADDR
// if ValidHex ( x , y ) then
109320: LD_VAR 0 4
109324: PPUSH
109325: LD_VAR 0 5
109329: PPUSH
109330: CALL_OW 488
109334: IFFALSE 109355
// ComTurnXY ( unit , x , y ) ;
109336: LD_VAR 0 1
109340: PPUSH
109341: LD_VAR 0 4
109345: PPUSH
109346: LD_VAR 0 5
109350: PPUSH
109351: CALL_OW 118
// end ;
109355: LD_VAR 0 3
109359: RET
// export function SeeUnits ( side , units ) ; var i ; begin
109360: LD_INT 0
109362: PPUSH
109363: PPUSH
// result := false ;
109364: LD_ADDR_VAR 0 3
109368: PUSH
109369: LD_INT 0
109371: ST_TO_ADDR
// if not units then
109372: LD_VAR 0 2
109376: NOT
109377: IFFALSE 109381
// exit ;
109379: GO 109426
// for i in units do
109381: LD_ADDR_VAR 0 4
109385: PUSH
109386: LD_VAR 0 2
109390: PUSH
109391: FOR_IN
109392: IFFALSE 109424
// if See ( side , i ) then
109394: LD_VAR 0 1
109398: PPUSH
109399: LD_VAR 0 4
109403: PPUSH
109404: CALL_OW 292
109408: IFFALSE 109422
// begin result := true ;
109410: LD_ADDR_VAR 0 3
109414: PUSH
109415: LD_INT 1
109417: ST_TO_ADDR
// exit ;
109418: POP
109419: POP
109420: GO 109426
// end ;
109422: GO 109391
109424: POP
109425: POP
// end ;
109426: LD_VAR 0 3
109430: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
109431: LD_INT 0
109433: PPUSH
109434: PPUSH
109435: PPUSH
109436: PPUSH
// if not unit or not points then
109437: LD_VAR 0 1
109441: NOT
109442: PUSH
109443: LD_VAR 0 2
109447: NOT
109448: OR
109449: IFFALSE 109453
// exit ;
109451: GO 109543
// dist := 99999 ;
109453: LD_ADDR_VAR 0 5
109457: PUSH
109458: LD_INT 99999
109460: ST_TO_ADDR
// for i in points do
109461: LD_ADDR_VAR 0 4
109465: PUSH
109466: LD_VAR 0 2
109470: PUSH
109471: FOR_IN
109472: IFFALSE 109541
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
109474: LD_ADDR_VAR 0 6
109478: PUSH
109479: LD_VAR 0 1
109483: PPUSH
109484: LD_VAR 0 4
109488: PUSH
109489: LD_INT 1
109491: ARRAY
109492: PPUSH
109493: LD_VAR 0 4
109497: PUSH
109498: LD_INT 2
109500: ARRAY
109501: PPUSH
109502: CALL_OW 297
109506: ST_TO_ADDR
// if tmpDist < dist then
109507: LD_VAR 0 6
109511: PUSH
109512: LD_VAR 0 5
109516: LESS
109517: IFFALSE 109539
// begin result := i ;
109519: LD_ADDR_VAR 0 3
109523: PUSH
109524: LD_VAR 0 4
109528: ST_TO_ADDR
// dist := tmpDist ;
109529: LD_ADDR_VAR 0 5
109533: PUSH
109534: LD_VAR 0 6
109538: ST_TO_ADDR
// end ; end ;
109539: GO 109471
109541: POP
109542: POP
// end ;
109543: LD_VAR 0 3
109547: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
109548: LD_INT 0
109550: PPUSH
// uc_side := side ;
109551: LD_ADDR_OWVAR 20
109555: PUSH
109556: LD_VAR 0 1
109560: ST_TO_ADDR
// uc_nation := 3 ;
109561: LD_ADDR_OWVAR 21
109565: PUSH
109566: LD_INT 3
109568: ST_TO_ADDR
// vc_chassis := 25 ;
109569: LD_ADDR_OWVAR 37
109573: PUSH
109574: LD_INT 25
109576: ST_TO_ADDR
// vc_engine := engine_siberite ;
109577: LD_ADDR_OWVAR 39
109581: PUSH
109582: LD_INT 3
109584: ST_TO_ADDR
// vc_control := control_computer ;
109585: LD_ADDR_OWVAR 38
109589: PUSH
109590: LD_INT 3
109592: ST_TO_ADDR
// vc_weapon := 59 ;
109593: LD_ADDR_OWVAR 40
109597: PUSH
109598: LD_INT 59
109600: ST_TO_ADDR
// result := CreateVehicle ;
109601: LD_ADDR_VAR 0 5
109605: PUSH
109606: CALL_OW 45
109610: ST_TO_ADDR
// SetDir ( result , d ) ;
109611: LD_VAR 0 5
109615: PPUSH
109616: LD_VAR 0 4
109620: PPUSH
109621: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
109625: LD_VAR 0 5
109629: PPUSH
109630: LD_VAR 0 2
109634: PPUSH
109635: LD_VAR 0 3
109639: PPUSH
109640: LD_INT 0
109642: PPUSH
109643: CALL_OW 48
// end ;
109647: LD_VAR 0 5
109651: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
109652: LD_INT 0
109654: PPUSH
109655: PPUSH
109656: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
109657: LD_ADDR_VAR 0 2
109661: PUSH
109662: LD_INT 0
109664: PUSH
109665: LD_INT 0
109667: PUSH
109668: LD_INT 0
109670: PUSH
109671: LD_INT 0
109673: PUSH
109674: EMPTY
109675: LIST
109676: LIST
109677: LIST
109678: LIST
109679: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
109680: LD_VAR 0 1
109684: NOT
109685: PUSH
109686: LD_VAR 0 1
109690: PPUSH
109691: CALL_OW 264
109695: PUSH
109696: LD_INT 12
109698: PUSH
109699: LD_INT 51
109701: PUSH
109702: LD_INT 32
109704: PUSH
109705: LD_INT 89
109707: PUSH
109708: EMPTY
109709: LIST
109710: LIST
109711: LIST
109712: LIST
109713: IN
109714: NOT
109715: OR
109716: IFFALSE 109720
// exit ;
109718: GO 109818
// for i := 1 to 3 do
109720: LD_ADDR_VAR 0 3
109724: PUSH
109725: DOUBLE
109726: LD_INT 1
109728: DEC
109729: ST_TO_ADDR
109730: LD_INT 3
109732: PUSH
109733: FOR_TO
109734: IFFALSE 109816
// begin tmp := GetCargo ( cargo , i ) ;
109736: LD_ADDR_VAR 0 4
109740: PUSH
109741: LD_VAR 0 1
109745: PPUSH
109746: LD_VAR 0 3
109750: PPUSH
109751: CALL_OW 289
109755: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
109756: LD_ADDR_VAR 0 2
109760: PUSH
109761: LD_VAR 0 2
109765: PPUSH
109766: LD_VAR 0 3
109770: PPUSH
109771: LD_VAR 0 4
109775: PPUSH
109776: CALL_OW 1
109780: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
109781: LD_ADDR_VAR 0 2
109785: PUSH
109786: LD_VAR 0 2
109790: PPUSH
109791: LD_INT 4
109793: PPUSH
109794: LD_VAR 0 2
109798: PUSH
109799: LD_INT 4
109801: ARRAY
109802: PUSH
109803: LD_VAR 0 4
109807: PLUS
109808: PPUSH
109809: CALL_OW 1
109813: ST_TO_ADDR
// end ;
109814: GO 109733
109816: POP
109817: POP
// end ;
109818: LD_VAR 0 2
109822: RET
// export function Length ( array ) ; begin
109823: LD_INT 0
109825: PPUSH
// result := array + 0 ;
109826: LD_ADDR_VAR 0 2
109830: PUSH
109831: LD_VAR 0 1
109835: PUSH
109836: LD_INT 0
109838: PLUS
109839: ST_TO_ADDR
// end ;
109840: LD_VAR 0 2
109844: RET
// export function PrepareArray ( array ) ; begin
109845: LD_INT 0
109847: PPUSH
// result := array diff 0 ;
109848: LD_ADDR_VAR 0 2
109852: PUSH
109853: LD_VAR 0 1
109857: PUSH
109858: LD_INT 0
109860: DIFF
109861: ST_TO_ADDR
// if not result [ 1 ] then
109862: LD_VAR 0 2
109866: PUSH
109867: LD_INT 1
109869: ARRAY
109870: NOT
109871: IFFALSE 109891
// result := Delete ( result , 1 ) ;
109873: LD_ADDR_VAR 0 2
109877: PUSH
109878: LD_VAR 0 2
109882: PPUSH
109883: LD_INT 1
109885: PPUSH
109886: CALL_OW 3
109890: ST_TO_ADDR
// end ;
109891: LD_VAR 0 2
109895: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
109896: LD_INT 0
109898: PPUSH
109899: PPUSH
109900: PPUSH
109901: PPUSH
// sibRocketRange := 25 ;
109902: LD_ADDR_VAR 0 6
109906: PUSH
109907: LD_INT 25
109909: ST_TO_ADDR
// result := false ;
109910: LD_ADDR_VAR 0 4
109914: PUSH
109915: LD_INT 0
109917: ST_TO_ADDR
// for i := 0 to 5 do
109918: LD_ADDR_VAR 0 5
109922: PUSH
109923: DOUBLE
109924: LD_INT 0
109926: DEC
109927: ST_TO_ADDR
109928: LD_INT 5
109930: PUSH
109931: FOR_TO
109932: IFFALSE 109999
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
109934: LD_VAR 0 1
109938: PPUSH
109939: LD_VAR 0 5
109943: PPUSH
109944: LD_VAR 0 6
109948: PPUSH
109949: CALL_OW 272
109953: PPUSH
109954: LD_VAR 0 2
109958: PPUSH
109959: LD_VAR 0 5
109963: PPUSH
109964: LD_VAR 0 6
109968: PPUSH
109969: CALL_OW 273
109973: PPUSH
109974: LD_VAR 0 3
109978: PPUSH
109979: CALL_OW 309
109983: IFFALSE 109997
// begin result := true ;
109985: LD_ADDR_VAR 0 4
109989: PUSH
109990: LD_INT 1
109992: ST_TO_ADDR
// exit ;
109993: POP
109994: POP
109995: GO 110001
// end ;
109997: GO 109931
109999: POP
110000: POP
// end ;
110001: LD_VAR 0 4
110005: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
110006: LD_INT 0
110008: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
110009: LD_VAR 0 1
110013: PPUSH
110014: LD_VAR 0 2
110018: PPUSH
110019: LD_INT 0
110021: PPUSH
110022: LD_INT 0
110024: PPUSH
110025: LD_INT 1
110027: PPUSH
110028: LD_INT 0
110030: PPUSH
110031: CALL_OW 587
// end ;
110035: LD_VAR 0 3
110039: RET
// export function CenterOnNow ( unit ) ; begin
110040: LD_INT 0
110042: PPUSH
// result := IsInUnit ( unit ) ;
110043: LD_ADDR_VAR 0 2
110047: PUSH
110048: LD_VAR 0 1
110052: PPUSH
110053: CALL_OW 310
110057: ST_TO_ADDR
// if not result then
110058: LD_VAR 0 2
110062: NOT
110063: IFFALSE 110075
// result := unit ;
110065: LD_ADDR_VAR 0 2
110069: PUSH
110070: LD_VAR 0 1
110074: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
110075: LD_VAR 0 1
110079: PPUSH
110080: CALL_OW 87
// end ;
110084: LD_VAR 0 2
110088: RET
// export function ComMoveHex ( unit , hex ) ; begin
110089: LD_INT 0
110091: PPUSH
// if not hex then
110092: LD_VAR 0 2
110096: NOT
110097: IFFALSE 110101
// exit ;
110099: GO 110154
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
110101: LD_VAR 0 2
110105: PUSH
110106: LD_INT 1
110108: ARRAY
110109: PPUSH
110110: LD_VAR 0 2
110114: PUSH
110115: LD_INT 2
110117: ARRAY
110118: PPUSH
110119: CALL_OW 428
110123: IFFALSE 110127
// exit ;
110125: GO 110154
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
110127: LD_VAR 0 1
110131: PPUSH
110132: LD_VAR 0 2
110136: PUSH
110137: LD_INT 1
110139: ARRAY
110140: PPUSH
110141: LD_VAR 0 2
110145: PUSH
110146: LD_INT 2
110148: ARRAY
110149: PPUSH
110150: CALL_OW 111
// end ; end_of_file end_of_file
110154: LD_VAR 0 3
110158: RET
// export globalGameSaveCounter ; every 0 0$1 do
110159: GO 110161
110161: DISABLE
// begin enable ;
110162: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
110163: LD_STRING updateTimer(
110165: PUSH
110166: LD_OWVAR 1
110170: STR
110171: PUSH
110172: LD_STRING );
110174: STR
110175: PPUSH
110176: CALL_OW 559
// end ;
110180: END
// every 0 0$1 do
110181: GO 110183
110183: DISABLE
// begin globalGameSaveCounter := 0 ;
110184: LD_ADDR_EXP 145
110188: PUSH
110189: LD_INT 0
110191: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
110192: LD_STRING setGameSaveCounter(0)
110194: PPUSH
110195: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
110199: LD_STRING initStreamRollete();
110201: PPUSH
110202: CALL_OW 559
// InitStreamMode ;
110206: CALL 111532 0 0
// DefineStreamItems ( false ) ;
110210: LD_INT 0
110212: PPUSH
110213: CALL 111996 0 1
// end ;
110217: END
// export function SOS_MapStart ( ) ; begin
110218: LD_INT 0
110220: PPUSH
// if streamModeActive then
110221: LD_EXP 146
110225: IFFALSE 110234
// DefineStreamItems ( true ) ;
110227: LD_INT 1
110229: PPUSH
110230: CALL 111996 0 1
// UpdateLuaVariables ( ) ;
110234: CALL 110251 0 0
// UpdateFactoryWaypoints ( ) ;
110238: CALL 124865 0 0
// UpdateWarehouseGatheringPoints ( ) ;
110242: CALL 125122 0 0
// end ;
110246: LD_VAR 0 1
110250: RET
// function UpdateLuaVariables ( ) ; begin
110251: LD_INT 0
110253: PPUSH
// if globalGameSaveCounter then
110254: LD_EXP 145
110258: IFFALSE 110292
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
110260: LD_ADDR_EXP 145
110264: PUSH
110265: LD_EXP 145
110269: PPUSH
110270: CALL 107448 0 1
110274: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
110275: LD_STRING setGameSaveCounter(
110277: PUSH
110278: LD_EXP 145
110282: STR
110283: PUSH
110284: LD_STRING )
110286: STR
110287: PPUSH
110288: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
110292: LD_STRING setGameDifficulty(
110294: PUSH
110295: LD_OWVAR 67
110299: STR
110300: PUSH
110301: LD_STRING )
110303: STR
110304: PPUSH
110305: CALL_OW 559
// end ;
110309: LD_VAR 0 1
110313: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
110314: LD_INT 0
110316: PPUSH
// if p2 = stream_mode then
110317: LD_VAR 0 2
110321: PUSH
110322: LD_INT 100
110324: EQUAL
110325: IFFALSE 111328
// begin if not StreamModeActive then
110327: LD_EXP 146
110331: NOT
110332: IFFALSE 110342
// StreamModeActive := true ;
110334: LD_ADDR_EXP 146
110338: PUSH
110339: LD_INT 1
110341: ST_TO_ADDR
// if p3 = 0 then
110342: LD_VAR 0 3
110346: PUSH
110347: LD_INT 0
110349: EQUAL
110350: IFFALSE 110356
// InitStreamMode ;
110352: CALL 111532 0 0
// if p3 = 1 then
110356: LD_VAR 0 3
110360: PUSH
110361: LD_INT 1
110363: EQUAL
110364: IFFALSE 110374
// sRocket := true ;
110366: LD_ADDR_EXP 151
110370: PUSH
110371: LD_INT 1
110373: ST_TO_ADDR
// if p3 = 2 then
110374: LD_VAR 0 3
110378: PUSH
110379: LD_INT 2
110381: EQUAL
110382: IFFALSE 110392
// sSpeed := true ;
110384: LD_ADDR_EXP 150
110388: PUSH
110389: LD_INT 1
110391: ST_TO_ADDR
// if p3 = 3 then
110392: LD_VAR 0 3
110396: PUSH
110397: LD_INT 3
110399: EQUAL
110400: IFFALSE 110410
// sEngine := true ;
110402: LD_ADDR_EXP 152
110406: PUSH
110407: LD_INT 1
110409: ST_TO_ADDR
// if p3 = 4 then
110410: LD_VAR 0 3
110414: PUSH
110415: LD_INT 4
110417: EQUAL
110418: IFFALSE 110428
// sSpec := true ;
110420: LD_ADDR_EXP 149
110424: PUSH
110425: LD_INT 1
110427: ST_TO_ADDR
// if p3 = 5 then
110428: LD_VAR 0 3
110432: PUSH
110433: LD_INT 5
110435: EQUAL
110436: IFFALSE 110446
// sLevel := true ;
110438: LD_ADDR_EXP 153
110442: PUSH
110443: LD_INT 1
110445: ST_TO_ADDR
// if p3 = 6 then
110446: LD_VAR 0 3
110450: PUSH
110451: LD_INT 6
110453: EQUAL
110454: IFFALSE 110464
// sArmoury := true ;
110456: LD_ADDR_EXP 154
110460: PUSH
110461: LD_INT 1
110463: ST_TO_ADDR
// if p3 = 7 then
110464: LD_VAR 0 3
110468: PUSH
110469: LD_INT 7
110471: EQUAL
110472: IFFALSE 110482
// sRadar := true ;
110474: LD_ADDR_EXP 155
110478: PUSH
110479: LD_INT 1
110481: ST_TO_ADDR
// if p3 = 8 then
110482: LD_VAR 0 3
110486: PUSH
110487: LD_INT 8
110489: EQUAL
110490: IFFALSE 110500
// sBunker := true ;
110492: LD_ADDR_EXP 156
110496: PUSH
110497: LD_INT 1
110499: ST_TO_ADDR
// if p3 = 9 then
110500: LD_VAR 0 3
110504: PUSH
110505: LD_INT 9
110507: EQUAL
110508: IFFALSE 110518
// sHack := true ;
110510: LD_ADDR_EXP 157
110514: PUSH
110515: LD_INT 1
110517: ST_TO_ADDR
// if p3 = 10 then
110518: LD_VAR 0 3
110522: PUSH
110523: LD_INT 10
110525: EQUAL
110526: IFFALSE 110536
// sFire := true ;
110528: LD_ADDR_EXP 158
110532: PUSH
110533: LD_INT 1
110535: ST_TO_ADDR
// if p3 = 11 then
110536: LD_VAR 0 3
110540: PUSH
110541: LD_INT 11
110543: EQUAL
110544: IFFALSE 110554
// sRefresh := true ;
110546: LD_ADDR_EXP 159
110550: PUSH
110551: LD_INT 1
110553: ST_TO_ADDR
// if p3 = 12 then
110554: LD_VAR 0 3
110558: PUSH
110559: LD_INT 12
110561: EQUAL
110562: IFFALSE 110572
// sExp := true ;
110564: LD_ADDR_EXP 160
110568: PUSH
110569: LD_INT 1
110571: ST_TO_ADDR
// if p3 = 13 then
110572: LD_VAR 0 3
110576: PUSH
110577: LD_INT 13
110579: EQUAL
110580: IFFALSE 110590
// sDepot := true ;
110582: LD_ADDR_EXP 161
110586: PUSH
110587: LD_INT 1
110589: ST_TO_ADDR
// if p3 = 14 then
110590: LD_VAR 0 3
110594: PUSH
110595: LD_INT 14
110597: EQUAL
110598: IFFALSE 110608
// sFlag := true ;
110600: LD_ADDR_EXP 162
110604: PUSH
110605: LD_INT 1
110607: ST_TO_ADDR
// if p3 = 15 then
110608: LD_VAR 0 3
110612: PUSH
110613: LD_INT 15
110615: EQUAL
110616: IFFALSE 110626
// sKamikadze := true ;
110618: LD_ADDR_EXP 170
110622: PUSH
110623: LD_INT 1
110625: ST_TO_ADDR
// if p3 = 16 then
110626: LD_VAR 0 3
110630: PUSH
110631: LD_INT 16
110633: EQUAL
110634: IFFALSE 110644
// sTroll := true ;
110636: LD_ADDR_EXP 171
110640: PUSH
110641: LD_INT 1
110643: ST_TO_ADDR
// if p3 = 17 then
110644: LD_VAR 0 3
110648: PUSH
110649: LD_INT 17
110651: EQUAL
110652: IFFALSE 110662
// sSlow := true ;
110654: LD_ADDR_EXP 172
110658: PUSH
110659: LD_INT 1
110661: ST_TO_ADDR
// if p3 = 18 then
110662: LD_VAR 0 3
110666: PUSH
110667: LD_INT 18
110669: EQUAL
110670: IFFALSE 110680
// sLack := true ;
110672: LD_ADDR_EXP 173
110676: PUSH
110677: LD_INT 1
110679: ST_TO_ADDR
// if p3 = 19 then
110680: LD_VAR 0 3
110684: PUSH
110685: LD_INT 19
110687: EQUAL
110688: IFFALSE 110698
// sTank := true ;
110690: LD_ADDR_EXP 175
110694: PUSH
110695: LD_INT 1
110697: ST_TO_ADDR
// if p3 = 20 then
110698: LD_VAR 0 3
110702: PUSH
110703: LD_INT 20
110705: EQUAL
110706: IFFALSE 110716
// sRemote := true ;
110708: LD_ADDR_EXP 176
110712: PUSH
110713: LD_INT 1
110715: ST_TO_ADDR
// if p3 = 21 then
110716: LD_VAR 0 3
110720: PUSH
110721: LD_INT 21
110723: EQUAL
110724: IFFALSE 110734
// sPowell := true ;
110726: LD_ADDR_EXP 177
110730: PUSH
110731: LD_INT 1
110733: ST_TO_ADDR
// if p3 = 22 then
110734: LD_VAR 0 3
110738: PUSH
110739: LD_INT 22
110741: EQUAL
110742: IFFALSE 110752
// sTeleport := true ;
110744: LD_ADDR_EXP 180
110748: PUSH
110749: LD_INT 1
110751: ST_TO_ADDR
// if p3 = 23 then
110752: LD_VAR 0 3
110756: PUSH
110757: LD_INT 23
110759: EQUAL
110760: IFFALSE 110770
// sOilTower := true ;
110762: LD_ADDR_EXP 182
110766: PUSH
110767: LD_INT 1
110769: ST_TO_ADDR
// if p3 = 24 then
110770: LD_VAR 0 3
110774: PUSH
110775: LD_INT 24
110777: EQUAL
110778: IFFALSE 110788
// sShovel := true ;
110780: LD_ADDR_EXP 183
110784: PUSH
110785: LD_INT 1
110787: ST_TO_ADDR
// if p3 = 25 then
110788: LD_VAR 0 3
110792: PUSH
110793: LD_INT 25
110795: EQUAL
110796: IFFALSE 110806
// sSheik := true ;
110798: LD_ADDR_EXP 184
110802: PUSH
110803: LD_INT 1
110805: ST_TO_ADDR
// if p3 = 26 then
110806: LD_VAR 0 3
110810: PUSH
110811: LD_INT 26
110813: EQUAL
110814: IFFALSE 110824
// sEarthquake := true ;
110816: LD_ADDR_EXP 186
110820: PUSH
110821: LD_INT 1
110823: ST_TO_ADDR
// if p3 = 27 then
110824: LD_VAR 0 3
110828: PUSH
110829: LD_INT 27
110831: EQUAL
110832: IFFALSE 110842
// sAI := true ;
110834: LD_ADDR_EXP 187
110838: PUSH
110839: LD_INT 1
110841: ST_TO_ADDR
// if p3 = 28 then
110842: LD_VAR 0 3
110846: PUSH
110847: LD_INT 28
110849: EQUAL
110850: IFFALSE 110860
// sCargo := true ;
110852: LD_ADDR_EXP 190
110856: PUSH
110857: LD_INT 1
110859: ST_TO_ADDR
// if p3 = 29 then
110860: LD_VAR 0 3
110864: PUSH
110865: LD_INT 29
110867: EQUAL
110868: IFFALSE 110878
// sDLaser := true ;
110870: LD_ADDR_EXP 191
110874: PUSH
110875: LD_INT 1
110877: ST_TO_ADDR
// if p3 = 30 then
110878: LD_VAR 0 3
110882: PUSH
110883: LD_INT 30
110885: EQUAL
110886: IFFALSE 110896
// sExchange := true ;
110888: LD_ADDR_EXP 192
110892: PUSH
110893: LD_INT 1
110895: ST_TO_ADDR
// if p3 = 31 then
110896: LD_VAR 0 3
110900: PUSH
110901: LD_INT 31
110903: EQUAL
110904: IFFALSE 110914
// sFac := true ;
110906: LD_ADDR_EXP 193
110910: PUSH
110911: LD_INT 1
110913: ST_TO_ADDR
// if p3 = 32 then
110914: LD_VAR 0 3
110918: PUSH
110919: LD_INT 32
110921: EQUAL
110922: IFFALSE 110932
// sPower := true ;
110924: LD_ADDR_EXP 194
110928: PUSH
110929: LD_INT 1
110931: ST_TO_ADDR
// if p3 = 33 then
110932: LD_VAR 0 3
110936: PUSH
110937: LD_INT 33
110939: EQUAL
110940: IFFALSE 110950
// sRandom := true ;
110942: LD_ADDR_EXP 195
110946: PUSH
110947: LD_INT 1
110949: ST_TO_ADDR
// if p3 = 34 then
110950: LD_VAR 0 3
110954: PUSH
110955: LD_INT 34
110957: EQUAL
110958: IFFALSE 110968
// sShield := true ;
110960: LD_ADDR_EXP 196
110964: PUSH
110965: LD_INT 1
110967: ST_TO_ADDR
// if p3 = 35 then
110968: LD_VAR 0 3
110972: PUSH
110973: LD_INT 35
110975: EQUAL
110976: IFFALSE 110986
// sTime := true ;
110978: LD_ADDR_EXP 197
110982: PUSH
110983: LD_INT 1
110985: ST_TO_ADDR
// if p3 = 36 then
110986: LD_VAR 0 3
110990: PUSH
110991: LD_INT 36
110993: EQUAL
110994: IFFALSE 111004
// sTools := true ;
110996: LD_ADDR_EXP 198
111000: PUSH
111001: LD_INT 1
111003: ST_TO_ADDR
// if p3 = 101 then
111004: LD_VAR 0 3
111008: PUSH
111009: LD_INT 101
111011: EQUAL
111012: IFFALSE 111022
// sSold := true ;
111014: LD_ADDR_EXP 163
111018: PUSH
111019: LD_INT 1
111021: ST_TO_ADDR
// if p3 = 102 then
111022: LD_VAR 0 3
111026: PUSH
111027: LD_INT 102
111029: EQUAL
111030: IFFALSE 111040
// sDiff := true ;
111032: LD_ADDR_EXP 164
111036: PUSH
111037: LD_INT 1
111039: ST_TO_ADDR
// if p3 = 103 then
111040: LD_VAR 0 3
111044: PUSH
111045: LD_INT 103
111047: EQUAL
111048: IFFALSE 111058
// sFog := true ;
111050: LD_ADDR_EXP 167
111054: PUSH
111055: LD_INT 1
111057: ST_TO_ADDR
// if p3 = 104 then
111058: LD_VAR 0 3
111062: PUSH
111063: LD_INT 104
111065: EQUAL
111066: IFFALSE 111076
// sReset := true ;
111068: LD_ADDR_EXP 168
111072: PUSH
111073: LD_INT 1
111075: ST_TO_ADDR
// if p3 = 105 then
111076: LD_VAR 0 3
111080: PUSH
111081: LD_INT 105
111083: EQUAL
111084: IFFALSE 111094
// sSun := true ;
111086: LD_ADDR_EXP 169
111090: PUSH
111091: LD_INT 1
111093: ST_TO_ADDR
// if p3 = 106 then
111094: LD_VAR 0 3
111098: PUSH
111099: LD_INT 106
111101: EQUAL
111102: IFFALSE 111112
// sTiger := true ;
111104: LD_ADDR_EXP 165
111108: PUSH
111109: LD_INT 1
111111: ST_TO_ADDR
// if p3 = 107 then
111112: LD_VAR 0 3
111116: PUSH
111117: LD_INT 107
111119: EQUAL
111120: IFFALSE 111130
// sBomb := true ;
111122: LD_ADDR_EXP 166
111126: PUSH
111127: LD_INT 1
111129: ST_TO_ADDR
// if p3 = 108 then
111130: LD_VAR 0 3
111134: PUSH
111135: LD_INT 108
111137: EQUAL
111138: IFFALSE 111148
// sWound := true ;
111140: LD_ADDR_EXP 174
111144: PUSH
111145: LD_INT 1
111147: ST_TO_ADDR
// if p3 = 109 then
111148: LD_VAR 0 3
111152: PUSH
111153: LD_INT 109
111155: EQUAL
111156: IFFALSE 111166
// sBetray := true ;
111158: LD_ADDR_EXP 178
111162: PUSH
111163: LD_INT 1
111165: ST_TO_ADDR
// if p3 = 110 then
111166: LD_VAR 0 3
111170: PUSH
111171: LD_INT 110
111173: EQUAL
111174: IFFALSE 111184
// sContamin := true ;
111176: LD_ADDR_EXP 179
111180: PUSH
111181: LD_INT 1
111183: ST_TO_ADDR
// if p3 = 111 then
111184: LD_VAR 0 3
111188: PUSH
111189: LD_INT 111
111191: EQUAL
111192: IFFALSE 111202
// sOil := true ;
111194: LD_ADDR_EXP 181
111198: PUSH
111199: LD_INT 1
111201: ST_TO_ADDR
// if p3 = 112 then
111202: LD_VAR 0 3
111206: PUSH
111207: LD_INT 112
111209: EQUAL
111210: IFFALSE 111220
// sStu := true ;
111212: LD_ADDR_EXP 185
111216: PUSH
111217: LD_INT 1
111219: ST_TO_ADDR
// if p3 = 113 then
111220: LD_VAR 0 3
111224: PUSH
111225: LD_INT 113
111227: EQUAL
111228: IFFALSE 111238
// sBazooka := true ;
111230: LD_ADDR_EXP 188
111234: PUSH
111235: LD_INT 1
111237: ST_TO_ADDR
// if p3 = 114 then
111238: LD_VAR 0 3
111242: PUSH
111243: LD_INT 114
111245: EQUAL
111246: IFFALSE 111256
// sMortar := true ;
111248: LD_ADDR_EXP 189
111252: PUSH
111253: LD_INT 1
111255: ST_TO_ADDR
// if p3 = 115 then
111256: LD_VAR 0 3
111260: PUSH
111261: LD_INT 115
111263: EQUAL
111264: IFFALSE 111274
// sRanger := true ;
111266: LD_ADDR_EXP 199
111270: PUSH
111271: LD_INT 1
111273: ST_TO_ADDR
// if p3 = 116 then
111274: LD_VAR 0 3
111278: PUSH
111279: LD_INT 116
111281: EQUAL
111282: IFFALSE 111292
// sComputer := true ;
111284: LD_ADDR_EXP 200
111288: PUSH
111289: LD_INT 1
111291: ST_TO_ADDR
// if p3 = 117 then
111292: LD_VAR 0 3
111296: PUSH
111297: LD_INT 117
111299: EQUAL
111300: IFFALSE 111310
// s30 := true ;
111302: LD_ADDR_EXP 201
111306: PUSH
111307: LD_INT 1
111309: ST_TO_ADDR
// if p3 = 118 then
111310: LD_VAR 0 3
111314: PUSH
111315: LD_INT 118
111317: EQUAL
111318: IFFALSE 111328
// s60 := true ;
111320: LD_ADDR_EXP 202
111324: PUSH
111325: LD_INT 1
111327: ST_TO_ADDR
// end ; if p2 = hack_mode then
111328: LD_VAR 0 2
111332: PUSH
111333: LD_INT 101
111335: EQUAL
111336: IFFALSE 111464
// begin case p3 of 1 :
111338: LD_VAR 0 3
111342: PUSH
111343: LD_INT 1
111345: DOUBLE
111346: EQUAL
111347: IFTRUE 111351
111349: GO 111358
111351: POP
// hHackUnlimitedResources ; 2 :
111352: CALL 123611 0 0
111356: GO 111464
111358: LD_INT 2
111360: DOUBLE
111361: EQUAL
111362: IFTRUE 111366
111364: GO 111373
111366: POP
// hHackSetLevel10 ; 3 :
111367: CALL 123744 0 0
111371: GO 111464
111373: LD_INT 3
111375: DOUBLE
111376: EQUAL
111377: IFTRUE 111381
111379: GO 111388
111381: POP
// hHackSetLevel10YourUnits ; 4 :
111382: CALL 123829 0 0
111386: GO 111464
111388: LD_INT 4
111390: DOUBLE
111391: EQUAL
111392: IFTRUE 111396
111394: GO 111403
111396: POP
// hHackInvincible ; 5 :
111397: CALL 124277 0 0
111401: GO 111464
111403: LD_INT 5
111405: DOUBLE
111406: EQUAL
111407: IFTRUE 111411
111409: GO 111418
111411: POP
// hHackInvisible ; 6 :
111412: CALL 124388 0 0
111416: GO 111464
111418: LD_INT 6
111420: DOUBLE
111421: EQUAL
111422: IFTRUE 111426
111424: GO 111433
111426: POP
// hHackChangeYourSide ; 7 :
111427: CALL 124445 0 0
111431: GO 111464
111433: LD_INT 7
111435: DOUBLE
111436: EQUAL
111437: IFTRUE 111441
111439: GO 111448
111441: POP
// hHackChangeUnitSide ; 8 :
111442: CALL 124487 0 0
111446: GO 111464
111448: LD_INT 8
111450: DOUBLE
111451: EQUAL
111452: IFTRUE 111456
111454: GO 111463
111456: POP
// hHackFog ; end ;
111457: CALL 124588 0 0
111461: GO 111464
111463: POP
// end ; if p2 = game_save_mode then
111464: LD_VAR 0 2
111468: PUSH
111469: LD_INT 102
111471: EQUAL
111472: IFFALSE 111527
// begin if p3 = 1 then
111474: LD_VAR 0 3
111478: PUSH
111479: LD_INT 1
111481: EQUAL
111482: IFFALSE 111494
// globalGameSaveCounter := p4 ;
111484: LD_ADDR_EXP 145
111488: PUSH
111489: LD_VAR 0 4
111493: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
111494: LD_VAR 0 3
111498: PUSH
111499: LD_INT 2
111501: EQUAL
111502: PUSH
111503: LD_EXP 145
111507: AND
111508: IFFALSE 111527
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
111510: LD_STRING setGameSaveCounter(
111512: PUSH
111513: LD_EXP 145
111517: STR
111518: PUSH
111519: LD_STRING )
111521: STR
111522: PPUSH
111523: CALL_OW 559
// end ; end ;
111527: LD_VAR 0 7
111531: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
111532: LD_INT 0
111534: PPUSH
// streamModeActive := false ;
111535: LD_ADDR_EXP 146
111539: PUSH
111540: LD_INT 0
111542: ST_TO_ADDR
// normalCounter := 36 ;
111543: LD_ADDR_EXP 147
111547: PUSH
111548: LD_INT 36
111550: ST_TO_ADDR
// hardcoreCounter := 18 ;
111551: LD_ADDR_EXP 148
111555: PUSH
111556: LD_INT 18
111558: ST_TO_ADDR
// sRocket := false ;
111559: LD_ADDR_EXP 151
111563: PUSH
111564: LD_INT 0
111566: ST_TO_ADDR
// sSpeed := false ;
111567: LD_ADDR_EXP 150
111571: PUSH
111572: LD_INT 0
111574: ST_TO_ADDR
// sEngine := false ;
111575: LD_ADDR_EXP 152
111579: PUSH
111580: LD_INT 0
111582: ST_TO_ADDR
// sSpec := false ;
111583: LD_ADDR_EXP 149
111587: PUSH
111588: LD_INT 0
111590: ST_TO_ADDR
// sLevel := false ;
111591: LD_ADDR_EXP 153
111595: PUSH
111596: LD_INT 0
111598: ST_TO_ADDR
// sArmoury := false ;
111599: LD_ADDR_EXP 154
111603: PUSH
111604: LD_INT 0
111606: ST_TO_ADDR
// sRadar := false ;
111607: LD_ADDR_EXP 155
111611: PUSH
111612: LD_INT 0
111614: ST_TO_ADDR
// sBunker := false ;
111615: LD_ADDR_EXP 156
111619: PUSH
111620: LD_INT 0
111622: ST_TO_ADDR
// sHack := false ;
111623: LD_ADDR_EXP 157
111627: PUSH
111628: LD_INT 0
111630: ST_TO_ADDR
// sFire := false ;
111631: LD_ADDR_EXP 158
111635: PUSH
111636: LD_INT 0
111638: ST_TO_ADDR
// sRefresh := false ;
111639: LD_ADDR_EXP 159
111643: PUSH
111644: LD_INT 0
111646: ST_TO_ADDR
// sExp := false ;
111647: LD_ADDR_EXP 160
111651: PUSH
111652: LD_INT 0
111654: ST_TO_ADDR
// sDepot := false ;
111655: LD_ADDR_EXP 161
111659: PUSH
111660: LD_INT 0
111662: ST_TO_ADDR
// sFlag := false ;
111663: LD_ADDR_EXP 162
111667: PUSH
111668: LD_INT 0
111670: ST_TO_ADDR
// sKamikadze := false ;
111671: LD_ADDR_EXP 170
111675: PUSH
111676: LD_INT 0
111678: ST_TO_ADDR
// sTroll := false ;
111679: LD_ADDR_EXP 171
111683: PUSH
111684: LD_INT 0
111686: ST_TO_ADDR
// sSlow := false ;
111687: LD_ADDR_EXP 172
111691: PUSH
111692: LD_INT 0
111694: ST_TO_ADDR
// sLack := false ;
111695: LD_ADDR_EXP 173
111699: PUSH
111700: LD_INT 0
111702: ST_TO_ADDR
// sTank := false ;
111703: LD_ADDR_EXP 175
111707: PUSH
111708: LD_INT 0
111710: ST_TO_ADDR
// sRemote := false ;
111711: LD_ADDR_EXP 176
111715: PUSH
111716: LD_INT 0
111718: ST_TO_ADDR
// sPowell := false ;
111719: LD_ADDR_EXP 177
111723: PUSH
111724: LD_INT 0
111726: ST_TO_ADDR
// sTeleport := false ;
111727: LD_ADDR_EXP 180
111731: PUSH
111732: LD_INT 0
111734: ST_TO_ADDR
// sOilTower := false ;
111735: LD_ADDR_EXP 182
111739: PUSH
111740: LD_INT 0
111742: ST_TO_ADDR
// sShovel := false ;
111743: LD_ADDR_EXP 183
111747: PUSH
111748: LD_INT 0
111750: ST_TO_ADDR
// sSheik := false ;
111751: LD_ADDR_EXP 184
111755: PUSH
111756: LD_INT 0
111758: ST_TO_ADDR
// sEarthquake := false ;
111759: LD_ADDR_EXP 186
111763: PUSH
111764: LD_INT 0
111766: ST_TO_ADDR
// sAI := false ;
111767: LD_ADDR_EXP 187
111771: PUSH
111772: LD_INT 0
111774: ST_TO_ADDR
// sCargo := false ;
111775: LD_ADDR_EXP 190
111779: PUSH
111780: LD_INT 0
111782: ST_TO_ADDR
// sDLaser := false ;
111783: LD_ADDR_EXP 191
111787: PUSH
111788: LD_INT 0
111790: ST_TO_ADDR
// sExchange := false ;
111791: LD_ADDR_EXP 192
111795: PUSH
111796: LD_INT 0
111798: ST_TO_ADDR
// sFac := false ;
111799: LD_ADDR_EXP 193
111803: PUSH
111804: LD_INT 0
111806: ST_TO_ADDR
// sPower := false ;
111807: LD_ADDR_EXP 194
111811: PUSH
111812: LD_INT 0
111814: ST_TO_ADDR
// sRandom := false ;
111815: LD_ADDR_EXP 195
111819: PUSH
111820: LD_INT 0
111822: ST_TO_ADDR
// sShield := false ;
111823: LD_ADDR_EXP 196
111827: PUSH
111828: LD_INT 0
111830: ST_TO_ADDR
// sTime := false ;
111831: LD_ADDR_EXP 197
111835: PUSH
111836: LD_INT 0
111838: ST_TO_ADDR
// sTools := false ;
111839: LD_ADDR_EXP 198
111843: PUSH
111844: LD_INT 0
111846: ST_TO_ADDR
// sSold := false ;
111847: LD_ADDR_EXP 163
111851: PUSH
111852: LD_INT 0
111854: ST_TO_ADDR
// sDiff := false ;
111855: LD_ADDR_EXP 164
111859: PUSH
111860: LD_INT 0
111862: ST_TO_ADDR
// sFog := false ;
111863: LD_ADDR_EXP 167
111867: PUSH
111868: LD_INT 0
111870: ST_TO_ADDR
// sReset := false ;
111871: LD_ADDR_EXP 168
111875: PUSH
111876: LD_INT 0
111878: ST_TO_ADDR
// sSun := false ;
111879: LD_ADDR_EXP 169
111883: PUSH
111884: LD_INT 0
111886: ST_TO_ADDR
// sTiger := false ;
111887: LD_ADDR_EXP 165
111891: PUSH
111892: LD_INT 0
111894: ST_TO_ADDR
// sBomb := false ;
111895: LD_ADDR_EXP 166
111899: PUSH
111900: LD_INT 0
111902: ST_TO_ADDR
// sWound := false ;
111903: LD_ADDR_EXP 174
111907: PUSH
111908: LD_INT 0
111910: ST_TO_ADDR
// sBetray := false ;
111911: LD_ADDR_EXP 178
111915: PUSH
111916: LD_INT 0
111918: ST_TO_ADDR
// sContamin := false ;
111919: LD_ADDR_EXP 179
111923: PUSH
111924: LD_INT 0
111926: ST_TO_ADDR
// sOil := false ;
111927: LD_ADDR_EXP 181
111931: PUSH
111932: LD_INT 0
111934: ST_TO_ADDR
// sStu := false ;
111935: LD_ADDR_EXP 185
111939: PUSH
111940: LD_INT 0
111942: ST_TO_ADDR
// sBazooka := false ;
111943: LD_ADDR_EXP 188
111947: PUSH
111948: LD_INT 0
111950: ST_TO_ADDR
// sMortar := false ;
111951: LD_ADDR_EXP 189
111955: PUSH
111956: LD_INT 0
111958: ST_TO_ADDR
// sRanger := false ;
111959: LD_ADDR_EXP 199
111963: PUSH
111964: LD_INT 0
111966: ST_TO_ADDR
// sComputer := false ;
111967: LD_ADDR_EXP 200
111971: PUSH
111972: LD_INT 0
111974: ST_TO_ADDR
// s30 := false ;
111975: LD_ADDR_EXP 201
111979: PUSH
111980: LD_INT 0
111982: ST_TO_ADDR
// s60 := false ;
111983: LD_ADDR_EXP 202
111987: PUSH
111988: LD_INT 0
111990: ST_TO_ADDR
// end ;
111991: LD_VAR 0 1
111995: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
111996: LD_INT 0
111998: PPUSH
111999: PPUSH
112000: PPUSH
112001: PPUSH
112002: PPUSH
112003: PPUSH
112004: PPUSH
// result := [ ] ;
112005: LD_ADDR_VAR 0 2
112009: PUSH
112010: EMPTY
112011: ST_TO_ADDR
// if campaign_id = 1 then
112012: LD_OWVAR 69
112016: PUSH
112017: LD_INT 1
112019: EQUAL
112020: IFFALSE 115186
// begin case mission_number of 1 :
112022: LD_OWVAR 70
112026: PUSH
112027: LD_INT 1
112029: DOUBLE
112030: EQUAL
112031: IFTRUE 112035
112033: GO 112111
112035: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
112036: LD_ADDR_VAR 0 2
112040: PUSH
112041: LD_INT 2
112043: PUSH
112044: LD_INT 4
112046: PUSH
112047: LD_INT 11
112049: PUSH
112050: LD_INT 12
112052: PUSH
112053: LD_INT 15
112055: PUSH
112056: LD_INT 16
112058: PUSH
112059: LD_INT 22
112061: PUSH
112062: LD_INT 23
112064: PUSH
112065: LD_INT 26
112067: PUSH
112068: EMPTY
112069: LIST
112070: LIST
112071: LIST
112072: LIST
112073: LIST
112074: LIST
112075: LIST
112076: LIST
112077: LIST
112078: PUSH
112079: LD_INT 101
112081: PUSH
112082: LD_INT 102
112084: PUSH
112085: LD_INT 106
112087: PUSH
112088: LD_INT 116
112090: PUSH
112091: LD_INT 117
112093: PUSH
112094: LD_INT 118
112096: PUSH
112097: EMPTY
112098: LIST
112099: LIST
112100: LIST
112101: LIST
112102: LIST
112103: LIST
112104: PUSH
112105: EMPTY
112106: LIST
112107: LIST
112108: ST_TO_ADDR
112109: GO 115184
112111: LD_INT 2
112113: DOUBLE
112114: EQUAL
112115: IFTRUE 112119
112117: GO 112203
112119: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
112120: LD_ADDR_VAR 0 2
112124: PUSH
112125: LD_INT 2
112127: PUSH
112128: LD_INT 4
112130: PUSH
112131: LD_INT 11
112133: PUSH
112134: LD_INT 12
112136: PUSH
112137: LD_INT 15
112139: PUSH
112140: LD_INT 16
112142: PUSH
112143: LD_INT 22
112145: PUSH
112146: LD_INT 23
112148: PUSH
112149: LD_INT 26
112151: PUSH
112152: EMPTY
112153: LIST
112154: LIST
112155: LIST
112156: LIST
112157: LIST
112158: LIST
112159: LIST
112160: LIST
112161: LIST
112162: PUSH
112163: LD_INT 101
112165: PUSH
112166: LD_INT 102
112168: PUSH
112169: LD_INT 105
112171: PUSH
112172: LD_INT 106
112174: PUSH
112175: LD_INT 108
112177: PUSH
112178: LD_INT 116
112180: PUSH
112181: LD_INT 117
112183: PUSH
112184: LD_INT 118
112186: PUSH
112187: EMPTY
112188: LIST
112189: LIST
112190: LIST
112191: LIST
112192: LIST
112193: LIST
112194: LIST
112195: LIST
112196: PUSH
112197: EMPTY
112198: LIST
112199: LIST
112200: ST_TO_ADDR
112201: GO 115184
112203: LD_INT 3
112205: DOUBLE
112206: EQUAL
112207: IFTRUE 112211
112209: GO 112299
112211: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
112212: LD_ADDR_VAR 0 2
112216: PUSH
112217: LD_INT 2
112219: PUSH
112220: LD_INT 4
112222: PUSH
112223: LD_INT 5
112225: PUSH
112226: LD_INT 11
112228: PUSH
112229: LD_INT 12
112231: PUSH
112232: LD_INT 15
112234: PUSH
112235: LD_INT 16
112237: PUSH
112238: LD_INT 22
112240: PUSH
112241: LD_INT 26
112243: PUSH
112244: LD_INT 36
112246: PUSH
112247: EMPTY
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: PUSH
112259: LD_INT 101
112261: PUSH
112262: LD_INT 102
112264: PUSH
112265: LD_INT 105
112267: PUSH
112268: LD_INT 106
112270: PUSH
112271: LD_INT 108
112273: PUSH
112274: LD_INT 116
112276: PUSH
112277: LD_INT 117
112279: PUSH
112280: LD_INT 118
112282: PUSH
112283: EMPTY
112284: LIST
112285: LIST
112286: LIST
112287: LIST
112288: LIST
112289: LIST
112290: LIST
112291: LIST
112292: PUSH
112293: EMPTY
112294: LIST
112295: LIST
112296: ST_TO_ADDR
112297: GO 115184
112299: LD_INT 4
112301: DOUBLE
112302: EQUAL
112303: IFTRUE 112307
112305: GO 112403
112307: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
112308: LD_ADDR_VAR 0 2
112312: PUSH
112313: LD_INT 2
112315: PUSH
112316: LD_INT 4
112318: PUSH
112319: LD_INT 5
112321: PUSH
112322: LD_INT 8
112324: PUSH
112325: LD_INT 11
112327: PUSH
112328: LD_INT 12
112330: PUSH
112331: LD_INT 15
112333: PUSH
112334: LD_INT 16
112336: PUSH
112337: LD_INT 22
112339: PUSH
112340: LD_INT 23
112342: PUSH
112343: LD_INT 26
112345: PUSH
112346: LD_INT 36
112348: PUSH
112349: EMPTY
112350: LIST
112351: LIST
112352: LIST
112353: LIST
112354: LIST
112355: LIST
112356: LIST
112357: LIST
112358: LIST
112359: LIST
112360: LIST
112361: LIST
112362: PUSH
112363: LD_INT 101
112365: PUSH
112366: LD_INT 102
112368: PUSH
112369: LD_INT 105
112371: PUSH
112372: LD_INT 106
112374: PUSH
112375: LD_INT 108
112377: PUSH
112378: LD_INT 116
112380: PUSH
112381: LD_INT 117
112383: PUSH
112384: LD_INT 118
112386: PUSH
112387: EMPTY
112388: LIST
112389: LIST
112390: LIST
112391: LIST
112392: LIST
112393: LIST
112394: LIST
112395: LIST
112396: PUSH
112397: EMPTY
112398: LIST
112399: LIST
112400: ST_TO_ADDR
112401: GO 115184
112403: LD_INT 5
112405: DOUBLE
112406: EQUAL
112407: IFTRUE 112411
112409: GO 112523
112411: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
112412: LD_ADDR_VAR 0 2
112416: PUSH
112417: LD_INT 2
112419: PUSH
112420: LD_INT 4
112422: PUSH
112423: LD_INT 5
112425: PUSH
112426: LD_INT 6
112428: PUSH
112429: LD_INT 8
112431: PUSH
112432: LD_INT 11
112434: PUSH
112435: LD_INT 12
112437: PUSH
112438: LD_INT 15
112440: PUSH
112441: LD_INT 16
112443: PUSH
112444: LD_INT 22
112446: PUSH
112447: LD_INT 23
112449: PUSH
112450: LD_INT 25
112452: PUSH
112453: LD_INT 26
112455: PUSH
112456: LD_INT 36
112458: PUSH
112459: EMPTY
112460: LIST
112461: LIST
112462: LIST
112463: LIST
112464: LIST
112465: LIST
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: PUSH
112475: LD_INT 101
112477: PUSH
112478: LD_INT 102
112480: PUSH
112481: LD_INT 105
112483: PUSH
112484: LD_INT 106
112486: PUSH
112487: LD_INT 108
112489: PUSH
112490: LD_INT 109
112492: PUSH
112493: LD_INT 112
112495: PUSH
112496: LD_INT 116
112498: PUSH
112499: LD_INT 117
112501: PUSH
112502: LD_INT 118
112504: PUSH
112505: EMPTY
112506: LIST
112507: LIST
112508: LIST
112509: LIST
112510: LIST
112511: LIST
112512: LIST
112513: LIST
112514: LIST
112515: LIST
112516: PUSH
112517: EMPTY
112518: LIST
112519: LIST
112520: ST_TO_ADDR
112521: GO 115184
112523: LD_INT 6
112525: DOUBLE
112526: EQUAL
112527: IFTRUE 112531
112529: GO 112663
112531: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
112532: LD_ADDR_VAR 0 2
112536: PUSH
112537: LD_INT 2
112539: PUSH
112540: LD_INT 4
112542: PUSH
112543: LD_INT 5
112545: PUSH
112546: LD_INT 6
112548: PUSH
112549: LD_INT 8
112551: PUSH
112552: LD_INT 11
112554: PUSH
112555: LD_INT 12
112557: PUSH
112558: LD_INT 15
112560: PUSH
112561: LD_INT 16
112563: PUSH
112564: LD_INT 20
112566: PUSH
112567: LD_INT 21
112569: PUSH
112570: LD_INT 22
112572: PUSH
112573: LD_INT 23
112575: PUSH
112576: LD_INT 25
112578: PUSH
112579: LD_INT 26
112581: PUSH
112582: LD_INT 30
112584: PUSH
112585: LD_INT 31
112587: PUSH
112588: LD_INT 32
112590: PUSH
112591: LD_INT 36
112593: PUSH
112594: EMPTY
112595: LIST
112596: LIST
112597: LIST
112598: LIST
112599: LIST
112600: LIST
112601: LIST
112602: LIST
112603: LIST
112604: LIST
112605: LIST
112606: LIST
112607: LIST
112608: LIST
112609: LIST
112610: LIST
112611: LIST
112612: LIST
112613: LIST
112614: PUSH
112615: LD_INT 101
112617: PUSH
112618: LD_INT 102
112620: PUSH
112621: LD_INT 105
112623: PUSH
112624: LD_INT 106
112626: PUSH
112627: LD_INT 108
112629: PUSH
112630: LD_INT 109
112632: PUSH
112633: LD_INT 112
112635: PUSH
112636: LD_INT 116
112638: PUSH
112639: LD_INT 117
112641: PUSH
112642: LD_INT 118
112644: PUSH
112645: EMPTY
112646: LIST
112647: LIST
112648: LIST
112649: LIST
112650: LIST
112651: LIST
112652: LIST
112653: LIST
112654: LIST
112655: LIST
112656: PUSH
112657: EMPTY
112658: LIST
112659: LIST
112660: ST_TO_ADDR
112661: GO 115184
112663: LD_INT 7
112665: DOUBLE
112666: EQUAL
112667: IFTRUE 112671
112669: GO 112783
112671: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
112672: LD_ADDR_VAR 0 2
112676: PUSH
112677: LD_INT 2
112679: PUSH
112680: LD_INT 4
112682: PUSH
112683: LD_INT 5
112685: PUSH
112686: LD_INT 7
112688: PUSH
112689: LD_INT 11
112691: PUSH
112692: LD_INT 12
112694: PUSH
112695: LD_INT 15
112697: PUSH
112698: LD_INT 16
112700: PUSH
112701: LD_INT 20
112703: PUSH
112704: LD_INT 21
112706: PUSH
112707: LD_INT 22
112709: PUSH
112710: LD_INT 23
112712: PUSH
112713: LD_INT 25
112715: PUSH
112716: LD_INT 26
112718: PUSH
112719: EMPTY
112720: LIST
112721: LIST
112722: LIST
112723: LIST
112724: LIST
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: LIST
112734: PUSH
112735: LD_INT 101
112737: PUSH
112738: LD_INT 102
112740: PUSH
112741: LD_INT 103
112743: PUSH
112744: LD_INT 105
112746: PUSH
112747: LD_INT 106
112749: PUSH
112750: LD_INT 108
112752: PUSH
112753: LD_INT 112
112755: PUSH
112756: LD_INT 116
112758: PUSH
112759: LD_INT 117
112761: PUSH
112762: LD_INT 118
112764: PUSH
112765: EMPTY
112766: LIST
112767: LIST
112768: LIST
112769: LIST
112770: LIST
112771: LIST
112772: LIST
112773: LIST
112774: LIST
112775: LIST
112776: PUSH
112777: EMPTY
112778: LIST
112779: LIST
112780: ST_TO_ADDR
112781: GO 115184
112783: LD_INT 8
112785: DOUBLE
112786: EQUAL
112787: IFTRUE 112791
112789: GO 112931
112791: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
112792: LD_ADDR_VAR 0 2
112796: PUSH
112797: LD_INT 2
112799: PUSH
112800: LD_INT 4
112802: PUSH
112803: LD_INT 5
112805: PUSH
112806: LD_INT 6
112808: PUSH
112809: LD_INT 7
112811: PUSH
112812: LD_INT 8
112814: PUSH
112815: LD_INT 11
112817: PUSH
112818: LD_INT 12
112820: PUSH
112821: LD_INT 15
112823: PUSH
112824: LD_INT 16
112826: PUSH
112827: LD_INT 20
112829: PUSH
112830: LD_INT 21
112832: PUSH
112833: LD_INT 22
112835: PUSH
112836: LD_INT 23
112838: PUSH
112839: LD_INT 25
112841: PUSH
112842: LD_INT 26
112844: PUSH
112845: LD_INT 30
112847: PUSH
112848: LD_INT 31
112850: PUSH
112851: LD_INT 32
112853: PUSH
112854: LD_INT 36
112856: PUSH
112857: EMPTY
112858: LIST
112859: LIST
112860: LIST
112861: LIST
112862: LIST
112863: LIST
112864: LIST
112865: LIST
112866: LIST
112867: LIST
112868: LIST
112869: LIST
112870: LIST
112871: LIST
112872: LIST
112873: LIST
112874: LIST
112875: LIST
112876: LIST
112877: LIST
112878: PUSH
112879: LD_INT 101
112881: PUSH
112882: LD_INT 102
112884: PUSH
112885: LD_INT 103
112887: PUSH
112888: LD_INT 105
112890: PUSH
112891: LD_INT 106
112893: PUSH
112894: LD_INT 108
112896: PUSH
112897: LD_INT 109
112899: PUSH
112900: LD_INT 112
112902: PUSH
112903: LD_INT 116
112905: PUSH
112906: LD_INT 117
112908: PUSH
112909: LD_INT 118
112911: PUSH
112912: EMPTY
112913: LIST
112914: LIST
112915: LIST
112916: LIST
112917: LIST
112918: LIST
112919: LIST
112920: LIST
112921: LIST
112922: LIST
112923: LIST
112924: PUSH
112925: EMPTY
112926: LIST
112927: LIST
112928: ST_TO_ADDR
112929: GO 115184
112931: LD_INT 9
112933: DOUBLE
112934: EQUAL
112935: IFTRUE 112939
112937: GO 113087
112939: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
112940: LD_ADDR_VAR 0 2
112944: PUSH
112945: LD_INT 2
112947: PUSH
112948: LD_INT 4
112950: PUSH
112951: LD_INT 5
112953: PUSH
112954: LD_INT 6
112956: PUSH
112957: LD_INT 7
112959: PUSH
112960: LD_INT 8
112962: PUSH
112963: LD_INT 11
112965: PUSH
112966: LD_INT 12
112968: PUSH
112969: LD_INT 15
112971: PUSH
112972: LD_INT 16
112974: PUSH
112975: LD_INT 20
112977: PUSH
112978: LD_INT 21
112980: PUSH
112981: LD_INT 22
112983: PUSH
112984: LD_INT 23
112986: PUSH
112987: LD_INT 25
112989: PUSH
112990: LD_INT 26
112992: PUSH
112993: LD_INT 28
112995: PUSH
112996: LD_INT 30
112998: PUSH
112999: LD_INT 31
113001: PUSH
113002: LD_INT 32
113004: PUSH
113005: LD_INT 36
113007: PUSH
113008: EMPTY
113009: LIST
113010: LIST
113011: LIST
113012: LIST
113013: LIST
113014: LIST
113015: LIST
113016: LIST
113017: LIST
113018: LIST
113019: LIST
113020: LIST
113021: LIST
113022: LIST
113023: LIST
113024: LIST
113025: LIST
113026: LIST
113027: LIST
113028: LIST
113029: LIST
113030: PUSH
113031: LD_INT 101
113033: PUSH
113034: LD_INT 102
113036: PUSH
113037: LD_INT 103
113039: PUSH
113040: LD_INT 105
113042: PUSH
113043: LD_INT 106
113045: PUSH
113046: LD_INT 108
113048: PUSH
113049: LD_INT 109
113051: PUSH
113052: LD_INT 112
113054: PUSH
113055: LD_INT 114
113057: PUSH
113058: LD_INT 116
113060: PUSH
113061: LD_INT 117
113063: PUSH
113064: LD_INT 118
113066: PUSH
113067: EMPTY
113068: LIST
113069: LIST
113070: LIST
113071: LIST
113072: LIST
113073: LIST
113074: LIST
113075: LIST
113076: LIST
113077: LIST
113078: LIST
113079: LIST
113080: PUSH
113081: EMPTY
113082: LIST
113083: LIST
113084: ST_TO_ADDR
113085: GO 115184
113087: LD_INT 10
113089: DOUBLE
113090: EQUAL
113091: IFTRUE 113095
113093: GO 113291
113095: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
113096: LD_ADDR_VAR 0 2
113100: PUSH
113101: LD_INT 2
113103: PUSH
113104: LD_INT 4
113106: PUSH
113107: LD_INT 5
113109: PUSH
113110: LD_INT 6
113112: PUSH
113113: LD_INT 7
113115: PUSH
113116: LD_INT 8
113118: PUSH
113119: LD_INT 9
113121: PUSH
113122: LD_INT 10
113124: PUSH
113125: LD_INT 11
113127: PUSH
113128: LD_INT 12
113130: PUSH
113131: LD_INT 13
113133: PUSH
113134: LD_INT 14
113136: PUSH
113137: LD_INT 15
113139: PUSH
113140: LD_INT 16
113142: PUSH
113143: LD_INT 17
113145: PUSH
113146: LD_INT 18
113148: PUSH
113149: LD_INT 19
113151: PUSH
113152: LD_INT 20
113154: PUSH
113155: LD_INT 21
113157: PUSH
113158: LD_INT 22
113160: PUSH
113161: LD_INT 23
113163: PUSH
113164: LD_INT 24
113166: PUSH
113167: LD_INT 25
113169: PUSH
113170: LD_INT 26
113172: PUSH
113173: LD_INT 28
113175: PUSH
113176: LD_INT 30
113178: PUSH
113179: LD_INT 31
113181: PUSH
113182: LD_INT 32
113184: PUSH
113185: LD_INT 36
113187: PUSH
113188: EMPTY
113189: LIST
113190: LIST
113191: LIST
113192: LIST
113193: LIST
113194: LIST
113195: LIST
113196: LIST
113197: LIST
113198: LIST
113199: LIST
113200: LIST
113201: LIST
113202: LIST
113203: LIST
113204: LIST
113205: LIST
113206: LIST
113207: LIST
113208: LIST
113209: LIST
113210: LIST
113211: LIST
113212: LIST
113213: LIST
113214: LIST
113215: LIST
113216: LIST
113217: LIST
113218: PUSH
113219: LD_INT 101
113221: PUSH
113222: LD_INT 102
113224: PUSH
113225: LD_INT 103
113227: PUSH
113228: LD_INT 104
113230: PUSH
113231: LD_INT 105
113233: PUSH
113234: LD_INT 106
113236: PUSH
113237: LD_INT 107
113239: PUSH
113240: LD_INT 108
113242: PUSH
113243: LD_INT 109
113245: PUSH
113246: LD_INT 110
113248: PUSH
113249: LD_INT 111
113251: PUSH
113252: LD_INT 112
113254: PUSH
113255: LD_INT 114
113257: PUSH
113258: LD_INT 116
113260: PUSH
113261: LD_INT 117
113263: PUSH
113264: LD_INT 118
113266: PUSH
113267: EMPTY
113268: LIST
113269: LIST
113270: LIST
113271: LIST
113272: LIST
113273: LIST
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: LIST
113280: LIST
113281: LIST
113282: LIST
113283: LIST
113284: PUSH
113285: EMPTY
113286: LIST
113287: LIST
113288: ST_TO_ADDR
113289: GO 115184
113291: LD_INT 11
113293: DOUBLE
113294: EQUAL
113295: IFTRUE 113299
113297: GO 113503
113299: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
113300: LD_ADDR_VAR 0 2
113304: PUSH
113305: LD_INT 2
113307: PUSH
113308: LD_INT 3
113310: PUSH
113311: LD_INT 4
113313: PUSH
113314: LD_INT 5
113316: PUSH
113317: LD_INT 6
113319: PUSH
113320: LD_INT 7
113322: PUSH
113323: LD_INT 8
113325: PUSH
113326: LD_INT 9
113328: PUSH
113329: LD_INT 10
113331: PUSH
113332: LD_INT 11
113334: PUSH
113335: LD_INT 12
113337: PUSH
113338: LD_INT 13
113340: PUSH
113341: LD_INT 14
113343: PUSH
113344: LD_INT 15
113346: PUSH
113347: LD_INT 16
113349: PUSH
113350: LD_INT 17
113352: PUSH
113353: LD_INT 18
113355: PUSH
113356: LD_INT 19
113358: PUSH
113359: LD_INT 20
113361: PUSH
113362: LD_INT 21
113364: PUSH
113365: LD_INT 22
113367: PUSH
113368: LD_INT 23
113370: PUSH
113371: LD_INT 24
113373: PUSH
113374: LD_INT 25
113376: PUSH
113377: LD_INT 26
113379: PUSH
113380: LD_INT 28
113382: PUSH
113383: LD_INT 30
113385: PUSH
113386: LD_INT 31
113388: PUSH
113389: LD_INT 32
113391: PUSH
113392: LD_INT 34
113394: PUSH
113395: LD_INT 36
113397: PUSH
113398: EMPTY
113399: LIST
113400: LIST
113401: LIST
113402: LIST
113403: LIST
113404: LIST
113405: LIST
113406: LIST
113407: LIST
113408: LIST
113409: LIST
113410: LIST
113411: LIST
113412: LIST
113413: LIST
113414: LIST
113415: LIST
113416: LIST
113417: LIST
113418: LIST
113419: LIST
113420: LIST
113421: LIST
113422: LIST
113423: LIST
113424: LIST
113425: LIST
113426: LIST
113427: LIST
113428: LIST
113429: LIST
113430: PUSH
113431: LD_INT 101
113433: PUSH
113434: LD_INT 102
113436: PUSH
113437: LD_INT 103
113439: PUSH
113440: LD_INT 104
113442: PUSH
113443: LD_INT 105
113445: PUSH
113446: LD_INT 106
113448: PUSH
113449: LD_INT 107
113451: PUSH
113452: LD_INT 108
113454: PUSH
113455: LD_INT 109
113457: PUSH
113458: LD_INT 110
113460: PUSH
113461: LD_INT 111
113463: PUSH
113464: LD_INT 112
113466: PUSH
113467: LD_INT 114
113469: PUSH
113470: LD_INT 116
113472: PUSH
113473: LD_INT 117
113475: PUSH
113476: LD_INT 118
113478: PUSH
113479: EMPTY
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: LIST
113495: LIST
113496: PUSH
113497: EMPTY
113498: LIST
113499: LIST
113500: ST_TO_ADDR
113501: GO 115184
113503: LD_INT 12
113505: DOUBLE
113506: EQUAL
113507: IFTRUE 113511
113509: GO 113731
113511: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
113512: LD_ADDR_VAR 0 2
113516: PUSH
113517: LD_INT 1
113519: PUSH
113520: LD_INT 2
113522: PUSH
113523: LD_INT 3
113525: PUSH
113526: LD_INT 4
113528: PUSH
113529: LD_INT 5
113531: PUSH
113532: LD_INT 6
113534: PUSH
113535: LD_INT 7
113537: PUSH
113538: LD_INT 8
113540: PUSH
113541: LD_INT 9
113543: PUSH
113544: LD_INT 10
113546: PUSH
113547: LD_INT 11
113549: PUSH
113550: LD_INT 12
113552: PUSH
113553: LD_INT 13
113555: PUSH
113556: LD_INT 14
113558: PUSH
113559: LD_INT 15
113561: PUSH
113562: LD_INT 16
113564: PUSH
113565: LD_INT 17
113567: PUSH
113568: LD_INT 18
113570: PUSH
113571: LD_INT 19
113573: PUSH
113574: LD_INT 20
113576: PUSH
113577: LD_INT 21
113579: PUSH
113580: LD_INT 22
113582: PUSH
113583: LD_INT 23
113585: PUSH
113586: LD_INT 24
113588: PUSH
113589: LD_INT 25
113591: PUSH
113592: LD_INT 26
113594: PUSH
113595: LD_INT 27
113597: PUSH
113598: LD_INT 28
113600: PUSH
113601: LD_INT 30
113603: PUSH
113604: LD_INT 31
113606: PUSH
113607: LD_INT 32
113609: PUSH
113610: LD_INT 33
113612: PUSH
113613: LD_INT 34
113615: PUSH
113616: LD_INT 36
113618: PUSH
113619: EMPTY
113620: LIST
113621: LIST
113622: LIST
113623: LIST
113624: LIST
113625: LIST
113626: LIST
113627: LIST
113628: LIST
113629: LIST
113630: LIST
113631: LIST
113632: LIST
113633: LIST
113634: LIST
113635: LIST
113636: LIST
113637: LIST
113638: LIST
113639: LIST
113640: LIST
113641: LIST
113642: LIST
113643: LIST
113644: LIST
113645: LIST
113646: LIST
113647: LIST
113648: LIST
113649: LIST
113650: LIST
113651: LIST
113652: LIST
113653: LIST
113654: PUSH
113655: LD_INT 101
113657: PUSH
113658: LD_INT 102
113660: PUSH
113661: LD_INT 103
113663: PUSH
113664: LD_INT 104
113666: PUSH
113667: LD_INT 105
113669: PUSH
113670: LD_INT 106
113672: PUSH
113673: LD_INT 107
113675: PUSH
113676: LD_INT 108
113678: PUSH
113679: LD_INT 109
113681: PUSH
113682: LD_INT 110
113684: PUSH
113685: LD_INT 111
113687: PUSH
113688: LD_INT 112
113690: PUSH
113691: LD_INT 113
113693: PUSH
113694: LD_INT 114
113696: PUSH
113697: LD_INT 116
113699: PUSH
113700: LD_INT 117
113702: PUSH
113703: LD_INT 118
113705: PUSH
113706: EMPTY
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: LIST
113712: LIST
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: PUSH
113725: EMPTY
113726: LIST
113727: LIST
113728: ST_TO_ADDR
113729: GO 115184
113731: LD_INT 13
113733: DOUBLE
113734: EQUAL
113735: IFTRUE 113739
113737: GO 113947
113739: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
113740: LD_ADDR_VAR 0 2
113744: PUSH
113745: LD_INT 1
113747: PUSH
113748: LD_INT 2
113750: PUSH
113751: LD_INT 3
113753: PUSH
113754: LD_INT 4
113756: PUSH
113757: LD_INT 5
113759: PUSH
113760: LD_INT 8
113762: PUSH
113763: LD_INT 9
113765: PUSH
113766: LD_INT 10
113768: PUSH
113769: LD_INT 11
113771: PUSH
113772: LD_INT 12
113774: PUSH
113775: LD_INT 14
113777: PUSH
113778: LD_INT 15
113780: PUSH
113781: LD_INT 16
113783: PUSH
113784: LD_INT 17
113786: PUSH
113787: LD_INT 18
113789: PUSH
113790: LD_INT 19
113792: PUSH
113793: LD_INT 20
113795: PUSH
113796: LD_INT 21
113798: PUSH
113799: LD_INT 22
113801: PUSH
113802: LD_INT 23
113804: PUSH
113805: LD_INT 24
113807: PUSH
113808: LD_INT 25
113810: PUSH
113811: LD_INT 26
113813: PUSH
113814: LD_INT 27
113816: PUSH
113817: LD_INT 28
113819: PUSH
113820: LD_INT 30
113822: PUSH
113823: LD_INT 31
113825: PUSH
113826: LD_INT 32
113828: PUSH
113829: LD_INT 33
113831: PUSH
113832: LD_INT 34
113834: PUSH
113835: LD_INT 36
113837: PUSH
113838: EMPTY
113839: LIST
113840: LIST
113841: LIST
113842: LIST
113843: LIST
113844: LIST
113845: LIST
113846: LIST
113847: LIST
113848: LIST
113849: LIST
113850: LIST
113851: LIST
113852: LIST
113853: LIST
113854: LIST
113855: LIST
113856: LIST
113857: LIST
113858: LIST
113859: LIST
113860: LIST
113861: LIST
113862: LIST
113863: LIST
113864: LIST
113865: LIST
113866: LIST
113867: LIST
113868: LIST
113869: LIST
113870: PUSH
113871: LD_INT 101
113873: PUSH
113874: LD_INT 102
113876: PUSH
113877: LD_INT 103
113879: PUSH
113880: LD_INT 104
113882: PUSH
113883: LD_INT 105
113885: PUSH
113886: LD_INT 106
113888: PUSH
113889: LD_INT 107
113891: PUSH
113892: LD_INT 108
113894: PUSH
113895: LD_INT 109
113897: PUSH
113898: LD_INT 110
113900: PUSH
113901: LD_INT 111
113903: PUSH
113904: LD_INT 112
113906: PUSH
113907: LD_INT 113
113909: PUSH
113910: LD_INT 114
113912: PUSH
113913: LD_INT 116
113915: PUSH
113916: LD_INT 117
113918: PUSH
113919: LD_INT 118
113921: PUSH
113922: EMPTY
113923: LIST
113924: LIST
113925: LIST
113926: LIST
113927: LIST
113928: LIST
113929: LIST
113930: LIST
113931: LIST
113932: LIST
113933: LIST
113934: LIST
113935: LIST
113936: LIST
113937: LIST
113938: LIST
113939: LIST
113940: PUSH
113941: EMPTY
113942: LIST
113943: LIST
113944: ST_TO_ADDR
113945: GO 115184
113947: LD_INT 14
113949: DOUBLE
113950: EQUAL
113951: IFTRUE 113955
113953: GO 114179
113955: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
113956: LD_ADDR_VAR 0 2
113960: PUSH
113961: LD_INT 1
113963: PUSH
113964: LD_INT 2
113966: PUSH
113967: LD_INT 3
113969: PUSH
113970: LD_INT 4
113972: PUSH
113973: LD_INT 5
113975: PUSH
113976: LD_INT 6
113978: PUSH
113979: LD_INT 7
113981: PUSH
113982: LD_INT 8
113984: PUSH
113985: LD_INT 9
113987: PUSH
113988: LD_INT 10
113990: PUSH
113991: LD_INT 11
113993: PUSH
113994: LD_INT 12
113996: PUSH
113997: LD_INT 13
113999: PUSH
114000: LD_INT 14
114002: PUSH
114003: LD_INT 15
114005: PUSH
114006: LD_INT 16
114008: PUSH
114009: LD_INT 17
114011: PUSH
114012: LD_INT 18
114014: PUSH
114015: LD_INT 19
114017: PUSH
114018: LD_INT 20
114020: PUSH
114021: LD_INT 21
114023: PUSH
114024: LD_INT 22
114026: PUSH
114027: LD_INT 23
114029: PUSH
114030: LD_INT 24
114032: PUSH
114033: LD_INT 25
114035: PUSH
114036: LD_INT 26
114038: PUSH
114039: LD_INT 27
114041: PUSH
114042: LD_INT 28
114044: PUSH
114045: LD_INT 29
114047: PUSH
114048: LD_INT 30
114050: PUSH
114051: LD_INT 31
114053: PUSH
114054: LD_INT 32
114056: PUSH
114057: LD_INT 33
114059: PUSH
114060: LD_INT 34
114062: PUSH
114063: LD_INT 36
114065: PUSH
114066: EMPTY
114067: LIST
114068: LIST
114069: LIST
114070: LIST
114071: LIST
114072: LIST
114073: LIST
114074: LIST
114075: LIST
114076: LIST
114077: LIST
114078: LIST
114079: LIST
114080: LIST
114081: LIST
114082: LIST
114083: LIST
114084: LIST
114085: LIST
114086: LIST
114087: LIST
114088: LIST
114089: LIST
114090: LIST
114091: LIST
114092: LIST
114093: LIST
114094: LIST
114095: LIST
114096: LIST
114097: LIST
114098: LIST
114099: LIST
114100: LIST
114101: LIST
114102: PUSH
114103: LD_INT 101
114105: PUSH
114106: LD_INT 102
114108: PUSH
114109: LD_INT 103
114111: PUSH
114112: LD_INT 104
114114: PUSH
114115: LD_INT 105
114117: PUSH
114118: LD_INT 106
114120: PUSH
114121: LD_INT 107
114123: PUSH
114124: LD_INT 108
114126: PUSH
114127: LD_INT 109
114129: PUSH
114130: LD_INT 110
114132: PUSH
114133: LD_INT 111
114135: PUSH
114136: LD_INT 112
114138: PUSH
114139: LD_INT 113
114141: PUSH
114142: LD_INT 114
114144: PUSH
114145: LD_INT 116
114147: PUSH
114148: LD_INT 117
114150: PUSH
114151: LD_INT 118
114153: PUSH
114154: EMPTY
114155: LIST
114156: LIST
114157: LIST
114158: LIST
114159: LIST
114160: LIST
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: LIST
114168: LIST
114169: LIST
114170: LIST
114171: LIST
114172: PUSH
114173: EMPTY
114174: LIST
114175: LIST
114176: ST_TO_ADDR
114177: GO 115184
114179: LD_INT 15
114181: DOUBLE
114182: EQUAL
114183: IFTRUE 114187
114185: GO 114411
114187: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
114188: LD_ADDR_VAR 0 2
114192: PUSH
114193: LD_INT 1
114195: PUSH
114196: LD_INT 2
114198: PUSH
114199: LD_INT 3
114201: PUSH
114202: LD_INT 4
114204: PUSH
114205: LD_INT 5
114207: PUSH
114208: LD_INT 6
114210: PUSH
114211: LD_INT 7
114213: PUSH
114214: LD_INT 8
114216: PUSH
114217: LD_INT 9
114219: PUSH
114220: LD_INT 10
114222: PUSH
114223: LD_INT 11
114225: PUSH
114226: LD_INT 12
114228: PUSH
114229: LD_INT 13
114231: PUSH
114232: LD_INT 14
114234: PUSH
114235: LD_INT 15
114237: PUSH
114238: LD_INT 16
114240: PUSH
114241: LD_INT 17
114243: PUSH
114244: LD_INT 18
114246: PUSH
114247: LD_INT 19
114249: PUSH
114250: LD_INT 20
114252: PUSH
114253: LD_INT 21
114255: PUSH
114256: LD_INT 22
114258: PUSH
114259: LD_INT 23
114261: PUSH
114262: LD_INT 24
114264: PUSH
114265: LD_INT 25
114267: PUSH
114268: LD_INT 26
114270: PUSH
114271: LD_INT 27
114273: PUSH
114274: LD_INT 28
114276: PUSH
114277: LD_INT 29
114279: PUSH
114280: LD_INT 30
114282: PUSH
114283: LD_INT 31
114285: PUSH
114286: LD_INT 32
114288: PUSH
114289: LD_INT 33
114291: PUSH
114292: LD_INT 34
114294: PUSH
114295: LD_INT 36
114297: PUSH
114298: EMPTY
114299: LIST
114300: LIST
114301: LIST
114302: LIST
114303: LIST
114304: LIST
114305: LIST
114306: LIST
114307: LIST
114308: LIST
114309: LIST
114310: LIST
114311: LIST
114312: LIST
114313: LIST
114314: LIST
114315: LIST
114316: LIST
114317: LIST
114318: LIST
114319: LIST
114320: LIST
114321: LIST
114322: LIST
114323: LIST
114324: LIST
114325: LIST
114326: LIST
114327: LIST
114328: LIST
114329: LIST
114330: LIST
114331: LIST
114332: LIST
114333: LIST
114334: PUSH
114335: LD_INT 101
114337: PUSH
114338: LD_INT 102
114340: PUSH
114341: LD_INT 103
114343: PUSH
114344: LD_INT 104
114346: PUSH
114347: LD_INT 105
114349: PUSH
114350: LD_INT 106
114352: PUSH
114353: LD_INT 107
114355: PUSH
114356: LD_INT 108
114358: PUSH
114359: LD_INT 109
114361: PUSH
114362: LD_INT 110
114364: PUSH
114365: LD_INT 111
114367: PUSH
114368: LD_INT 112
114370: PUSH
114371: LD_INT 113
114373: PUSH
114374: LD_INT 114
114376: PUSH
114377: LD_INT 116
114379: PUSH
114380: LD_INT 117
114382: PUSH
114383: LD_INT 118
114385: PUSH
114386: EMPTY
114387: LIST
114388: LIST
114389: LIST
114390: LIST
114391: LIST
114392: LIST
114393: LIST
114394: LIST
114395: LIST
114396: LIST
114397: LIST
114398: LIST
114399: LIST
114400: LIST
114401: LIST
114402: LIST
114403: LIST
114404: PUSH
114405: EMPTY
114406: LIST
114407: LIST
114408: ST_TO_ADDR
114409: GO 115184
114411: LD_INT 16
114413: DOUBLE
114414: EQUAL
114415: IFTRUE 114419
114417: GO 114555
114419: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
114420: LD_ADDR_VAR 0 2
114424: PUSH
114425: LD_INT 2
114427: PUSH
114428: LD_INT 4
114430: PUSH
114431: LD_INT 5
114433: PUSH
114434: LD_INT 7
114436: PUSH
114437: LD_INT 11
114439: PUSH
114440: LD_INT 12
114442: PUSH
114443: LD_INT 15
114445: PUSH
114446: LD_INT 16
114448: PUSH
114449: LD_INT 20
114451: PUSH
114452: LD_INT 21
114454: PUSH
114455: LD_INT 22
114457: PUSH
114458: LD_INT 23
114460: PUSH
114461: LD_INT 25
114463: PUSH
114464: LD_INT 26
114466: PUSH
114467: LD_INT 30
114469: PUSH
114470: LD_INT 31
114472: PUSH
114473: LD_INT 32
114475: PUSH
114476: LD_INT 33
114478: PUSH
114479: LD_INT 34
114481: PUSH
114482: EMPTY
114483: LIST
114484: LIST
114485: LIST
114486: LIST
114487: LIST
114488: LIST
114489: LIST
114490: LIST
114491: LIST
114492: LIST
114493: LIST
114494: LIST
114495: LIST
114496: LIST
114497: LIST
114498: LIST
114499: LIST
114500: LIST
114501: LIST
114502: PUSH
114503: LD_INT 101
114505: PUSH
114506: LD_INT 102
114508: PUSH
114509: LD_INT 103
114511: PUSH
114512: LD_INT 106
114514: PUSH
114515: LD_INT 108
114517: PUSH
114518: LD_INT 112
114520: PUSH
114521: LD_INT 113
114523: PUSH
114524: LD_INT 114
114526: PUSH
114527: LD_INT 116
114529: PUSH
114530: LD_INT 117
114532: PUSH
114533: LD_INT 118
114535: PUSH
114536: EMPTY
114537: LIST
114538: LIST
114539: LIST
114540: LIST
114541: LIST
114542: LIST
114543: LIST
114544: LIST
114545: LIST
114546: LIST
114547: LIST
114548: PUSH
114549: EMPTY
114550: LIST
114551: LIST
114552: ST_TO_ADDR
114553: GO 115184
114555: LD_INT 17
114557: DOUBLE
114558: EQUAL
114559: IFTRUE 114563
114561: GO 114787
114563: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
114564: LD_ADDR_VAR 0 2
114568: PUSH
114569: LD_INT 1
114571: PUSH
114572: LD_INT 2
114574: PUSH
114575: LD_INT 3
114577: PUSH
114578: LD_INT 4
114580: PUSH
114581: LD_INT 5
114583: PUSH
114584: LD_INT 6
114586: PUSH
114587: LD_INT 7
114589: PUSH
114590: LD_INT 8
114592: PUSH
114593: LD_INT 9
114595: PUSH
114596: LD_INT 10
114598: PUSH
114599: LD_INT 11
114601: PUSH
114602: LD_INT 12
114604: PUSH
114605: LD_INT 13
114607: PUSH
114608: LD_INT 14
114610: PUSH
114611: LD_INT 15
114613: PUSH
114614: LD_INT 16
114616: PUSH
114617: LD_INT 17
114619: PUSH
114620: LD_INT 18
114622: PUSH
114623: LD_INT 19
114625: PUSH
114626: LD_INT 20
114628: PUSH
114629: LD_INT 21
114631: PUSH
114632: LD_INT 22
114634: PUSH
114635: LD_INT 23
114637: PUSH
114638: LD_INT 24
114640: PUSH
114641: LD_INT 25
114643: PUSH
114644: LD_INT 26
114646: PUSH
114647: LD_INT 27
114649: PUSH
114650: LD_INT 28
114652: PUSH
114653: LD_INT 29
114655: PUSH
114656: LD_INT 30
114658: PUSH
114659: LD_INT 31
114661: PUSH
114662: LD_INT 32
114664: PUSH
114665: LD_INT 33
114667: PUSH
114668: LD_INT 34
114670: PUSH
114671: LD_INT 36
114673: PUSH
114674: EMPTY
114675: LIST
114676: LIST
114677: LIST
114678: LIST
114679: LIST
114680: LIST
114681: LIST
114682: LIST
114683: LIST
114684: LIST
114685: LIST
114686: LIST
114687: LIST
114688: LIST
114689: LIST
114690: LIST
114691: LIST
114692: LIST
114693: LIST
114694: LIST
114695: LIST
114696: LIST
114697: LIST
114698: LIST
114699: LIST
114700: LIST
114701: LIST
114702: LIST
114703: LIST
114704: LIST
114705: LIST
114706: LIST
114707: LIST
114708: LIST
114709: LIST
114710: PUSH
114711: LD_INT 101
114713: PUSH
114714: LD_INT 102
114716: PUSH
114717: LD_INT 103
114719: PUSH
114720: LD_INT 104
114722: PUSH
114723: LD_INT 105
114725: PUSH
114726: LD_INT 106
114728: PUSH
114729: LD_INT 107
114731: PUSH
114732: LD_INT 108
114734: PUSH
114735: LD_INT 109
114737: PUSH
114738: LD_INT 110
114740: PUSH
114741: LD_INT 111
114743: PUSH
114744: LD_INT 112
114746: PUSH
114747: LD_INT 113
114749: PUSH
114750: LD_INT 114
114752: PUSH
114753: LD_INT 116
114755: PUSH
114756: LD_INT 117
114758: PUSH
114759: LD_INT 118
114761: PUSH
114762: EMPTY
114763: LIST
114764: LIST
114765: LIST
114766: LIST
114767: LIST
114768: LIST
114769: LIST
114770: LIST
114771: LIST
114772: LIST
114773: LIST
114774: LIST
114775: LIST
114776: LIST
114777: LIST
114778: LIST
114779: LIST
114780: PUSH
114781: EMPTY
114782: LIST
114783: LIST
114784: ST_TO_ADDR
114785: GO 115184
114787: LD_INT 18
114789: DOUBLE
114790: EQUAL
114791: IFTRUE 114795
114793: GO 114943
114795: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
114796: LD_ADDR_VAR 0 2
114800: PUSH
114801: LD_INT 2
114803: PUSH
114804: LD_INT 4
114806: PUSH
114807: LD_INT 5
114809: PUSH
114810: LD_INT 7
114812: PUSH
114813: LD_INT 11
114815: PUSH
114816: LD_INT 12
114818: PUSH
114819: LD_INT 15
114821: PUSH
114822: LD_INT 16
114824: PUSH
114825: LD_INT 20
114827: PUSH
114828: LD_INT 21
114830: PUSH
114831: LD_INT 22
114833: PUSH
114834: LD_INT 23
114836: PUSH
114837: LD_INT 25
114839: PUSH
114840: LD_INT 26
114842: PUSH
114843: LD_INT 30
114845: PUSH
114846: LD_INT 31
114848: PUSH
114849: LD_INT 32
114851: PUSH
114852: LD_INT 33
114854: PUSH
114855: LD_INT 34
114857: PUSH
114858: LD_INT 35
114860: PUSH
114861: LD_INT 36
114863: PUSH
114864: EMPTY
114865: LIST
114866: LIST
114867: LIST
114868: LIST
114869: LIST
114870: LIST
114871: LIST
114872: LIST
114873: LIST
114874: LIST
114875: LIST
114876: LIST
114877: LIST
114878: LIST
114879: LIST
114880: LIST
114881: LIST
114882: LIST
114883: LIST
114884: LIST
114885: LIST
114886: PUSH
114887: LD_INT 101
114889: PUSH
114890: LD_INT 102
114892: PUSH
114893: LD_INT 103
114895: PUSH
114896: LD_INT 106
114898: PUSH
114899: LD_INT 108
114901: PUSH
114902: LD_INT 112
114904: PUSH
114905: LD_INT 113
114907: PUSH
114908: LD_INT 114
114910: PUSH
114911: LD_INT 115
114913: PUSH
114914: LD_INT 116
114916: PUSH
114917: LD_INT 117
114919: PUSH
114920: LD_INT 118
114922: PUSH
114923: EMPTY
114924: LIST
114925: LIST
114926: LIST
114927: LIST
114928: LIST
114929: LIST
114930: LIST
114931: LIST
114932: LIST
114933: LIST
114934: LIST
114935: LIST
114936: PUSH
114937: EMPTY
114938: LIST
114939: LIST
114940: ST_TO_ADDR
114941: GO 115184
114943: LD_INT 19
114945: DOUBLE
114946: EQUAL
114947: IFTRUE 114951
114949: GO 115183
114951: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
114952: LD_ADDR_VAR 0 2
114956: PUSH
114957: LD_INT 1
114959: PUSH
114960: LD_INT 2
114962: PUSH
114963: LD_INT 3
114965: PUSH
114966: LD_INT 4
114968: PUSH
114969: LD_INT 5
114971: PUSH
114972: LD_INT 6
114974: PUSH
114975: LD_INT 7
114977: PUSH
114978: LD_INT 8
114980: PUSH
114981: LD_INT 9
114983: PUSH
114984: LD_INT 10
114986: PUSH
114987: LD_INT 11
114989: PUSH
114990: LD_INT 12
114992: PUSH
114993: LD_INT 13
114995: PUSH
114996: LD_INT 14
114998: PUSH
114999: LD_INT 15
115001: PUSH
115002: LD_INT 16
115004: PUSH
115005: LD_INT 17
115007: PUSH
115008: LD_INT 18
115010: PUSH
115011: LD_INT 19
115013: PUSH
115014: LD_INT 20
115016: PUSH
115017: LD_INT 21
115019: PUSH
115020: LD_INT 22
115022: PUSH
115023: LD_INT 23
115025: PUSH
115026: LD_INT 24
115028: PUSH
115029: LD_INT 25
115031: PUSH
115032: LD_INT 26
115034: PUSH
115035: LD_INT 27
115037: PUSH
115038: LD_INT 28
115040: PUSH
115041: LD_INT 29
115043: PUSH
115044: LD_INT 30
115046: PUSH
115047: LD_INT 31
115049: PUSH
115050: LD_INT 32
115052: PUSH
115053: LD_INT 33
115055: PUSH
115056: LD_INT 34
115058: PUSH
115059: LD_INT 35
115061: PUSH
115062: LD_INT 36
115064: PUSH
115065: EMPTY
115066: LIST
115067: LIST
115068: LIST
115069: LIST
115070: LIST
115071: LIST
115072: LIST
115073: LIST
115074: LIST
115075: LIST
115076: LIST
115077: LIST
115078: LIST
115079: LIST
115080: LIST
115081: LIST
115082: LIST
115083: LIST
115084: LIST
115085: LIST
115086: LIST
115087: LIST
115088: LIST
115089: LIST
115090: LIST
115091: LIST
115092: LIST
115093: LIST
115094: LIST
115095: LIST
115096: LIST
115097: LIST
115098: LIST
115099: LIST
115100: LIST
115101: LIST
115102: PUSH
115103: LD_INT 101
115105: PUSH
115106: LD_INT 102
115108: PUSH
115109: LD_INT 103
115111: PUSH
115112: LD_INT 104
115114: PUSH
115115: LD_INT 105
115117: PUSH
115118: LD_INT 106
115120: PUSH
115121: LD_INT 107
115123: PUSH
115124: LD_INT 108
115126: PUSH
115127: LD_INT 109
115129: PUSH
115130: LD_INT 110
115132: PUSH
115133: LD_INT 111
115135: PUSH
115136: LD_INT 112
115138: PUSH
115139: LD_INT 113
115141: PUSH
115142: LD_INT 114
115144: PUSH
115145: LD_INT 115
115147: PUSH
115148: LD_INT 116
115150: PUSH
115151: LD_INT 117
115153: PUSH
115154: LD_INT 118
115156: PUSH
115157: EMPTY
115158: LIST
115159: LIST
115160: LIST
115161: LIST
115162: LIST
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: LIST
115169: LIST
115170: LIST
115171: LIST
115172: LIST
115173: LIST
115174: LIST
115175: LIST
115176: PUSH
115177: EMPTY
115178: LIST
115179: LIST
115180: ST_TO_ADDR
115181: GO 115184
115183: POP
// end else
115184: GO 115415
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
115186: LD_ADDR_VAR 0 2
115190: PUSH
115191: LD_INT 1
115193: PUSH
115194: LD_INT 2
115196: PUSH
115197: LD_INT 3
115199: PUSH
115200: LD_INT 4
115202: PUSH
115203: LD_INT 5
115205: PUSH
115206: LD_INT 6
115208: PUSH
115209: LD_INT 7
115211: PUSH
115212: LD_INT 8
115214: PUSH
115215: LD_INT 9
115217: PUSH
115218: LD_INT 10
115220: PUSH
115221: LD_INT 11
115223: PUSH
115224: LD_INT 12
115226: PUSH
115227: LD_INT 13
115229: PUSH
115230: LD_INT 14
115232: PUSH
115233: LD_INT 15
115235: PUSH
115236: LD_INT 16
115238: PUSH
115239: LD_INT 17
115241: PUSH
115242: LD_INT 18
115244: PUSH
115245: LD_INT 19
115247: PUSH
115248: LD_INT 20
115250: PUSH
115251: LD_INT 21
115253: PUSH
115254: LD_INT 22
115256: PUSH
115257: LD_INT 23
115259: PUSH
115260: LD_INT 24
115262: PUSH
115263: LD_INT 25
115265: PUSH
115266: LD_INT 26
115268: PUSH
115269: LD_INT 27
115271: PUSH
115272: LD_INT 28
115274: PUSH
115275: LD_INT 29
115277: PUSH
115278: LD_INT 30
115280: PUSH
115281: LD_INT 31
115283: PUSH
115284: LD_INT 32
115286: PUSH
115287: LD_INT 33
115289: PUSH
115290: LD_INT 34
115292: PUSH
115293: LD_INT 35
115295: PUSH
115296: LD_INT 36
115298: PUSH
115299: EMPTY
115300: LIST
115301: LIST
115302: LIST
115303: LIST
115304: LIST
115305: LIST
115306: LIST
115307: LIST
115308: LIST
115309: LIST
115310: LIST
115311: LIST
115312: LIST
115313: LIST
115314: LIST
115315: LIST
115316: LIST
115317: LIST
115318: LIST
115319: LIST
115320: LIST
115321: LIST
115322: LIST
115323: LIST
115324: LIST
115325: LIST
115326: LIST
115327: LIST
115328: LIST
115329: LIST
115330: LIST
115331: LIST
115332: LIST
115333: LIST
115334: LIST
115335: LIST
115336: PUSH
115337: LD_INT 101
115339: PUSH
115340: LD_INT 102
115342: PUSH
115343: LD_INT 103
115345: PUSH
115346: LD_INT 104
115348: PUSH
115349: LD_INT 105
115351: PUSH
115352: LD_INT 106
115354: PUSH
115355: LD_INT 107
115357: PUSH
115358: LD_INT 108
115360: PUSH
115361: LD_INT 109
115363: PUSH
115364: LD_INT 110
115366: PUSH
115367: LD_INT 111
115369: PUSH
115370: LD_INT 112
115372: PUSH
115373: LD_INT 113
115375: PUSH
115376: LD_INT 114
115378: PUSH
115379: LD_INT 115
115381: PUSH
115382: LD_INT 116
115384: PUSH
115385: LD_INT 117
115387: PUSH
115388: LD_INT 118
115390: PUSH
115391: EMPTY
115392: LIST
115393: LIST
115394: LIST
115395: LIST
115396: LIST
115397: LIST
115398: LIST
115399: LIST
115400: LIST
115401: LIST
115402: LIST
115403: LIST
115404: LIST
115405: LIST
115406: LIST
115407: LIST
115408: LIST
115409: LIST
115410: PUSH
115411: EMPTY
115412: LIST
115413: LIST
115414: ST_TO_ADDR
// if result then
115415: LD_VAR 0 2
115419: IFFALSE 116205
// begin normal :=  ;
115421: LD_ADDR_VAR 0 5
115425: PUSH
115426: LD_STRING 
115428: ST_TO_ADDR
// hardcore :=  ;
115429: LD_ADDR_VAR 0 6
115433: PUSH
115434: LD_STRING 
115436: ST_TO_ADDR
// active :=  ;
115437: LD_ADDR_VAR 0 7
115441: PUSH
115442: LD_STRING 
115444: ST_TO_ADDR
// for i = 1 to normalCounter do
115445: LD_ADDR_VAR 0 8
115449: PUSH
115450: DOUBLE
115451: LD_INT 1
115453: DEC
115454: ST_TO_ADDR
115455: LD_EXP 147
115459: PUSH
115460: FOR_TO
115461: IFFALSE 115562
// begin tmp := 0 ;
115463: LD_ADDR_VAR 0 3
115467: PUSH
115468: LD_STRING 0
115470: ST_TO_ADDR
// if result [ 1 ] then
115471: LD_VAR 0 2
115475: PUSH
115476: LD_INT 1
115478: ARRAY
115479: IFFALSE 115544
// if result [ 1 ] [ 1 ] = i then
115481: LD_VAR 0 2
115485: PUSH
115486: LD_INT 1
115488: ARRAY
115489: PUSH
115490: LD_INT 1
115492: ARRAY
115493: PUSH
115494: LD_VAR 0 8
115498: EQUAL
115499: IFFALSE 115544
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
115501: LD_ADDR_VAR 0 2
115505: PUSH
115506: LD_VAR 0 2
115510: PPUSH
115511: LD_INT 1
115513: PPUSH
115514: LD_VAR 0 2
115518: PUSH
115519: LD_INT 1
115521: ARRAY
115522: PPUSH
115523: LD_INT 1
115525: PPUSH
115526: CALL_OW 3
115530: PPUSH
115531: CALL_OW 1
115535: ST_TO_ADDR
// tmp := 1 ;
115536: LD_ADDR_VAR 0 3
115540: PUSH
115541: LD_STRING 1
115543: ST_TO_ADDR
// end ; normal := normal & tmp ;
115544: LD_ADDR_VAR 0 5
115548: PUSH
115549: LD_VAR 0 5
115553: PUSH
115554: LD_VAR 0 3
115558: STR
115559: ST_TO_ADDR
// end ;
115560: GO 115460
115562: POP
115563: POP
// for i = 1 to hardcoreCounter do
115564: LD_ADDR_VAR 0 8
115568: PUSH
115569: DOUBLE
115570: LD_INT 1
115572: DEC
115573: ST_TO_ADDR
115574: LD_EXP 148
115578: PUSH
115579: FOR_TO
115580: IFFALSE 115685
// begin tmp := 0 ;
115582: LD_ADDR_VAR 0 3
115586: PUSH
115587: LD_STRING 0
115589: ST_TO_ADDR
// if result [ 2 ] then
115590: LD_VAR 0 2
115594: PUSH
115595: LD_INT 2
115597: ARRAY
115598: IFFALSE 115667
// if result [ 2 ] [ 1 ] = 100 + i then
115600: LD_VAR 0 2
115604: PUSH
115605: LD_INT 2
115607: ARRAY
115608: PUSH
115609: LD_INT 1
115611: ARRAY
115612: PUSH
115613: LD_INT 100
115615: PUSH
115616: LD_VAR 0 8
115620: PLUS
115621: EQUAL
115622: IFFALSE 115667
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
115624: LD_ADDR_VAR 0 2
115628: PUSH
115629: LD_VAR 0 2
115633: PPUSH
115634: LD_INT 2
115636: PPUSH
115637: LD_VAR 0 2
115641: PUSH
115642: LD_INT 2
115644: ARRAY
115645: PPUSH
115646: LD_INT 1
115648: PPUSH
115649: CALL_OW 3
115653: PPUSH
115654: CALL_OW 1
115658: ST_TO_ADDR
// tmp := 1 ;
115659: LD_ADDR_VAR 0 3
115663: PUSH
115664: LD_STRING 1
115666: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
115667: LD_ADDR_VAR 0 6
115671: PUSH
115672: LD_VAR 0 6
115676: PUSH
115677: LD_VAR 0 3
115681: STR
115682: ST_TO_ADDR
// end ;
115683: GO 115579
115685: POP
115686: POP
// if isGameLoad then
115687: LD_VAR 0 1
115691: IFFALSE 116166
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
115693: LD_ADDR_VAR 0 4
115697: PUSH
115698: LD_EXP 151
115702: PUSH
115703: LD_EXP 150
115707: PUSH
115708: LD_EXP 152
115712: PUSH
115713: LD_EXP 149
115717: PUSH
115718: LD_EXP 153
115722: PUSH
115723: LD_EXP 154
115727: PUSH
115728: LD_EXP 155
115732: PUSH
115733: LD_EXP 156
115737: PUSH
115738: LD_EXP 157
115742: PUSH
115743: LD_EXP 158
115747: PUSH
115748: LD_EXP 159
115752: PUSH
115753: LD_EXP 160
115757: PUSH
115758: LD_EXP 161
115762: PUSH
115763: LD_EXP 162
115767: PUSH
115768: LD_EXP 170
115772: PUSH
115773: LD_EXP 171
115777: PUSH
115778: LD_EXP 172
115782: PUSH
115783: LD_EXP 173
115787: PUSH
115788: LD_EXP 175
115792: PUSH
115793: LD_EXP 176
115797: PUSH
115798: LD_EXP 177
115802: PUSH
115803: LD_EXP 180
115807: PUSH
115808: LD_EXP 182
115812: PUSH
115813: LD_EXP 183
115817: PUSH
115818: LD_EXP 184
115822: PUSH
115823: LD_EXP 186
115827: PUSH
115828: LD_EXP 187
115832: PUSH
115833: LD_EXP 190
115837: PUSH
115838: LD_EXP 191
115842: PUSH
115843: LD_EXP 192
115847: PUSH
115848: LD_EXP 193
115852: PUSH
115853: LD_EXP 194
115857: PUSH
115858: LD_EXP 195
115862: PUSH
115863: LD_EXP 196
115867: PUSH
115868: LD_EXP 197
115872: PUSH
115873: LD_EXP 198
115877: PUSH
115878: LD_EXP 163
115882: PUSH
115883: LD_EXP 164
115887: PUSH
115888: LD_EXP 167
115892: PUSH
115893: LD_EXP 168
115897: PUSH
115898: LD_EXP 169
115902: PUSH
115903: LD_EXP 165
115907: PUSH
115908: LD_EXP 166
115912: PUSH
115913: LD_EXP 174
115917: PUSH
115918: LD_EXP 178
115922: PUSH
115923: LD_EXP 179
115927: PUSH
115928: LD_EXP 181
115932: PUSH
115933: LD_EXP 185
115937: PUSH
115938: LD_EXP 188
115942: PUSH
115943: LD_EXP 189
115947: PUSH
115948: LD_EXP 199
115952: PUSH
115953: LD_EXP 200
115957: PUSH
115958: LD_EXP 201
115962: PUSH
115963: LD_EXP 202
115967: PUSH
115968: EMPTY
115969: LIST
115970: LIST
115971: LIST
115972: LIST
115973: LIST
115974: LIST
115975: LIST
115976: LIST
115977: LIST
115978: LIST
115979: LIST
115980: LIST
115981: LIST
115982: LIST
115983: LIST
115984: LIST
115985: LIST
115986: LIST
115987: LIST
115988: LIST
115989: LIST
115990: LIST
115991: LIST
115992: LIST
115993: LIST
115994: LIST
115995: LIST
115996: LIST
115997: LIST
115998: LIST
115999: LIST
116000: LIST
116001: LIST
116002: LIST
116003: LIST
116004: LIST
116005: LIST
116006: LIST
116007: LIST
116008: LIST
116009: LIST
116010: LIST
116011: LIST
116012: LIST
116013: LIST
116014: LIST
116015: LIST
116016: LIST
116017: LIST
116018: LIST
116019: LIST
116020: LIST
116021: LIST
116022: LIST
116023: ST_TO_ADDR
// tmp :=  ;
116024: LD_ADDR_VAR 0 3
116028: PUSH
116029: LD_STRING 
116031: ST_TO_ADDR
// for i = 1 to normalCounter do
116032: LD_ADDR_VAR 0 8
116036: PUSH
116037: DOUBLE
116038: LD_INT 1
116040: DEC
116041: ST_TO_ADDR
116042: LD_EXP 147
116046: PUSH
116047: FOR_TO
116048: IFFALSE 116084
// begin if flags [ i ] then
116050: LD_VAR 0 4
116054: PUSH
116055: LD_VAR 0 8
116059: ARRAY
116060: IFFALSE 116082
// tmp := tmp & i & ; ;
116062: LD_ADDR_VAR 0 3
116066: PUSH
116067: LD_VAR 0 3
116071: PUSH
116072: LD_VAR 0 8
116076: STR
116077: PUSH
116078: LD_STRING ;
116080: STR
116081: ST_TO_ADDR
// end ;
116082: GO 116047
116084: POP
116085: POP
// for i = 1 to hardcoreCounter do
116086: LD_ADDR_VAR 0 8
116090: PUSH
116091: DOUBLE
116092: LD_INT 1
116094: DEC
116095: ST_TO_ADDR
116096: LD_EXP 148
116100: PUSH
116101: FOR_TO
116102: IFFALSE 116148
// begin if flags [ normalCounter + i ] then
116104: LD_VAR 0 4
116108: PUSH
116109: LD_EXP 147
116113: PUSH
116114: LD_VAR 0 8
116118: PLUS
116119: ARRAY
116120: IFFALSE 116146
// tmp := tmp & ( 100 + i ) & ; ;
116122: LD_ADDR_VAR 0 3
116126: PUSH
116127: LD_VAR 0 3
116131: PUSH
116132: LD_INT 100
116134: PUSH
116135: LD_VAR 0 8
116139: PLUS
116140: STR
116141: PUSH
116142: LD_STRING ;
116144: STR
116145: ST_TO_ADDR
// end ;
116146: GO 116101
116148: POP
116149: POP
// if tmp then
116150: LD_VAR 0 3
116154: IFFALSE 116166
// active := tmp ;
116156: LD_ADDR_VAR 0 7
116160: PUSH
116161: LD_VAR 0 3
116165: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
116166: LD_STRING getStreamItemsFromMission("
116168: PUSH
116169: LD_VAR 0 5
116173: STR
116174: PUSH
116175: LD_STRING ","
116177: STR
116178: PUSH
116179: LD_VAR 0 6
116183: STR
116184: PUSH
116185: LD_STRING ","
116187: STR
116188: PUSH
116189: LD_VAR 0 7
116193: STR
116194: PUSH
116195: LD_STRING ")
116197: STR
116198: PPUSH
116199: CALL_OW 559
// end else
116203: GO 116212
// ToLua ( getStreamItemsFromMission("","","") ) ;
116205: LD_STRING getStreamItemsFromMission("","","")
116207: PPUSH
116208: CALL_OW 559
// end ;
116212: LD_VAR 0 2
116216: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
116217: LD_EXP 146
116221: PUSH
116222: LD_EXP 151
116226: AND
116227: IFFALSE 116351
116229: GO 116231
116231: DISABLE
116232: LD_INT 0
116234: PPUSH
116235: PPUSH
// begin enable ;
116236: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
116237: LD_ADDR_VAR 0 2
116241: PUSH
116242: LD_INT 22
116244: PUSH
116245: LD_OWVAR 2
116249: PUSH
116250: EMPTY
116251: LIST
116252: LIST
116253: PUSH
116254: LD_INT 2
116256: PUSH
116257: LD_INT 34
116259: PUSH
116260: LD_INT 7
116262: PUSH
116263: EMPTY
116264: LIST
116265: LIST
116266: PUSH
116267: LD_INT 34
116269: PUSH
116270: LD_INT 45
116272: PUSH
116273: EMPTY
116274: LIST
116275: LIST
116276: PUSH
116277: LD_INT 34
116279: PUSH
116280: LD_INT 28
116282: PUSH
116283: EMPTY
116284: LIST
116285: LIST
116286: PUSH
116287: LD_INT 34
116289: PUSH
116290: LD_INT 47
116292: PUSH
116293: EMPTY
116294: LIST
116295: LIST
116296: PUSH
116297: EMPTY
116298: LIST
116299: LIST
116300: LIST
116301: LIST
116302: LIST
116303: PUSH
116304: EMPTY
116305: LIST
116306: LIST
116307: PPUSH
116308: CALL_OW 69
116312: ST_TO_ADDR
// if not tmp then
116313: LD_VAR 0 2
116317: NOT
116318: IFFALSE 116322
// exit ;
116320: GO 116351
// for i in tmp do
116322: LD_ADDR_VAR 0 1
116326: PUSH
116327: LD_VAR 0 2
116331: PUSH
116332: FOR_IN
116333: IFFALSE 116349
// begin SetLives ( i , 0 ) ;
116335: LD_VAR 0 1
116339: PPUSH
116340: LD_INT 0
116342: PPUSH
116343: CALL_OW 234
// end ;
116347: GO 116332
116349: POP
116350: POP
// end ;
116351: PPOPN 2
116353: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
116354: LD_EXP 146
116358: PUSH
116359: LD_EXP 152
116363: AND
116364: IFFALSE 116448
116366: GO 116368
116368: DISABLE
116369: LD_INT 0
116371: PPUSH
116372: PPUSH
// begin enable ;
116373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
116374: LD_ADDR_VAR 0 2
116378: PUSH
116379: LD_INT 22
116381: PUSH
116382: LD_OWVAR 2
116386: PUSH
116387: EMPTY
116388: LIST
116389: LIST
116390: PUSH
116391: LD_INT 32
116393: PUSH
116394: LD_INT 3
116396: PUSH
116397: EMPTY
116398: LIST
116399: LIST
116400: PUSH
116401: EMPTY
116402: LIST
116403: LIST
116404: PPUSH
116405: CALL_OW 69
116409: ST_TO_ADDR
// if not tmp then
116410: LD_VAR 0 2
116414: NOT
116415: IFFALSE 116419
// exit ;
116417: GO 116448
// for i in tmp do
116419: LD_ADDR_VAR 0 1
116423: PUSH
116424: LD_VAR 0 2
116428: PUSH
116429: FOR_IN
116430: IFFALSE 116446
// begin SetLives ( i , 0 ) ;
116432: LD_VAR 0 1
116436: PPUSH
116437: LD_INT 0
116439: PPUSH
116440: CALL_OW 234
// end ;
116444: GO 116429
116446: POP
116447: POP
// end ;
116448: PPOPN 2
116450: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
116451: LD_EXP 146
116455: PUSH
116456: LD_EXP 149
116460: AND
116461: IFFALSE 116554
116463: GO 116465
116465: DISABLE
116466: LD_INT 0
116468: PPUSH
// begin enable ;
116469: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
116470: LD_ADDR_VAR 0 1
116474: PUSH
116475: LD_INT 22
116477: PUSH
116478: LD_OWVAR 2
116482: PUSH
116483: EMPTY
116484: LIST
116485: LIST
116486: PUSH
116487: LD_INT 2
116489: PUSH
116490: LD_INT 25
116492: PUSH
116493: LD_INT 5
116495: PUSH
116496: EMPTY
116497: LIST
116498: LIST
116499: PUSH
116500: LD_INT 25
116502: PUSH
116503: LD_INT 9
116505: PUSH
116506: EMPTY
116507: LIST
116508: LIST
116509: PUSH
116510: LD_INT 25
116512: PUSH
116513: LD_INT 8
116515: PUSH
116516: EMPTY
116517: LIST
116518: LIST
116519: PUSH
116520: EMPTY
116521: LIST
116522: LIST
116523: LIST
116524: LIST
116525: PUSH
116526: EMPTY
116527: LIST
116528: LIST
116529: PPUSH
116530: CALL_OW 69
116534: PUSH
116535: FOR_IN
116536: IFFALSE 116552
// begin SetClass ( i , 1 ) ;
116538: LD_VAR 0 1
116542: PPUSH
116543: LD_INT 1
116545: PPUSH
116546: CALL_OW 336
// end ;
116550: GO 116535
116552: POP
116553: POP
// end ;
116554: PPOPN 1
116556: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
116557: LD_EXP 146
116561: PUSH
116562: LD_EXP 150
116566: AND
116567: PUSH
116568: LD_OWVAR 65
116572: PUSH
116573: LD_INT 7
116575: LESS
116576: AND
116577: IFFALSE 116591
116579: GO 116581
116581: DISABLE
// begin enable ;
116582: ENABLE
// game_speed := 7 ;
116583: LD_ADDR_OWVAR 65
116587: PUSH
116588: LD_INT 7
116590: ST_TO_ADDR
// end ;
116591: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
116592: LD_EXP 146
116596: PUSH
116597: LD_EXP 153
116601: AND
116602: IFFALSE 116804
116604: GO 116606
116606: DISABLE
116607: LD_INT 0
116609: PPUSH
116610: PPUSH
116611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
116612: LD_ADDR_VAR 0 3
116616: PUSH
116617: LD_INT 81
116619: PUSH
116620: LD_OWVAR 2
116624: PUSH
116625: EMPTY
116626: LIST
116627: LIST
116628: PUSH
116629: LD_INT 21
116631: PUSH
116632: LD_INT 1
116634: PUSH
116635: EMPTY
116636: LIST
116637: LIST
116638: PUSH
116639: EMPTY
116640: LIST
116641: LIST
116642: PPUSH
116643: CALL_OW 69
116647: ST_TO_ADDR
// if not tmp then
116648: LD_VAR 0 3
116652: NOT
116653: IFFALSE 116657
// exit ;
116655: GO 116804
// if tmp > 5 then
116657: LD_VAR 0 3
116661: PUSH
116662: LD_INT 5
116664: GREATER
116665: IFFALSE 116677
// k := 5 else
116667: LD_ADDR_VAR 0 2
116671: PUSH
116672: LD_INT 5
116674: ST_TO_ADDR
116675: GO 116687
// k := tmp ;
116677: LD_ADDR_VAR 0 2
116681: PUSH
116682: LD_VAR 0 3
116686: ST_TO_ADDR
// for i := 1 to k do
116687: LD_ADDR_VAR 0 1
116691: PUSH
116692: DOUBLE
116693: LD_INT 1
116695: DEC
116696: ST_TO_ADDR
116697: LD_VAR 0 2
116701: PUSH
116702: FOR_TO
116703: IFFALSE 116802
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
116705: LD_VAR 0 3
116709: PUSH
116710: LD_VAR 0 1
116714: ARRAY
116715: PPUSH
116716: LD_VAR 0 1
116720: PUSH
116721: LD_INT 4
116723: MOD
116724: PUSH
116725: LD_INT 1
116727: PLUS
116728: PPUSH
116729: CALL_OW 259
116733: PUSH
116734: LD_INT 10
116736: LESS
116737: IFFALSE 116800
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
116739: LD_VAR 0 3
116743: PUSH
116744: LD_VAR 0 1
116748: ARRAY
116749: PPUSH
116750: LD_VAR 0 1
116754: PUSH
116755: LD_INT 4
116757: MOD
116758: PUSH
116759: LD_INT 1
116761: PLUS
116762: PPUSH
116763: LD_VAR 0 3
116767: PUSH
116768: LD_VAR 0 1
116772: ARRAY
116773: PPUSH
116774: LD_VAR 0 1
116778: PUSH
116779: LD_INT 4
116781: MOD
116782: PUSH
116783: LD_INT 1
116785: PLUS
116786: PPUSH
116787: CALL_OW 259
116791: PUSH
116792: LD_INT 1
116794: PLUS
116795: PPUSH
116796: CALL_OW 237
116800: GO 116702
116802: POP
116803: POP
// end ;
116804: PPOPN 3
116806: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
116807: LD_EXP 146
116811: PUSH
116812: LD_EXP 154
116816: AND
116817: IFFALSE 116837
116819: GO 116821
116821: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
116822: LD_INT 4
116824: PPUSH
116825: LD_OWVAR 2
116829: PPUSH
116830: LD_INT 0
116832: PPUSH
116833: CALL_OW 324
116837: END
// every 0 0$1 trigger StreamModeActive and sShovel do
116838: LD_EXP 146
116842: PUSH
116843: LD_EXP 183
116847: AND
116848: IFFALSE 116868
116850: GO 116852
116852: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
116853: LD_INT 19
116855: PPUSH
116856: LD_OWVAR 2
116860: PPUSH
116861: LD_INT 0
116863: PPUSH
116864: CALL_OW 324
116868: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
116869: LD_EXP 146
116873: PUSH
116874: LD_EXP 155
116878: AND
116879: IFFALSE 116981
116881: GO 116883
116883: DISABLE
116884: LD_INT 0
116886: PPUSH
116887: PPUSH
// begin enable ;
116888: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
116889: LD_ADDR_VAR 0 2
116893: PUSH
116894: LD_INT 22
116896: PUSH
116897: LD_OWVAR 2
116901: PUSH
116902: EMPTY
116903: LIST
116904: LIST
116905: PUSH
116906: LD_INT 2
116908: PUSH
116909: LD_INT 34
116911: PUSH
116912: LD_INT 11
116914: PUSH
116915: EMPTY
116916: LIST
116917: LIST
116918: PUSH
116919: LD_INT 34
116921: PUSH
116922: LD_INT 30
116924: PUSH
116925: EMPTY
116926: LIST
116927: LIST
116928: PUSH
116929: EMPTY
116930: LIST
116931: LIST
116932: LIST
116933: PUSH
116934: EMPTY
116935: LIST
116936: LIST
116937: PPUSH
116938: CALL_OW 69
116942: ST_TO_ADDR
// if not tmp then
116943: LD_VAR 0 2
116947: NOT
116948: IFFALSE 116952
// exit ;
116950: GO 116981
// for i in tmp do
116952: LD_ADDR_VAR 0 1
116956: PUSH
116957: LD_VAR 0 2
116961: PUSH
116962: FOR_IN
116963: IFFALSE 116979
// begin SetLives ( i , 0 ) ;
116965: LD_VAR 0 1
116969: PPUSH
116970: LD_INT 0
116972: PPUSH
116973: CALL_OW 234
// end ;
116977: GO 116962
116979: POP
116980: POP
// end ;
116981: PPOPN 2
116983: END
// every 0 0$1 trigger StreamModeActive and sBunker do
116984: LD_EXP 146
116988: PUSH
116989: LD_EXP 156
116993: AND
116994: IFFALSE 117014
116996: GO 116998
116998: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
116999: LD_INT 32
117001: PPUSH
117002: LD_OWVAR 2
117006: PPUSH
117007: LD_INT 0
117009: PPUSH
117010: CALL_OW 324
117014: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
117015: LD_EXP 146
117019: PUSH
117020: LD_EXP 157
117024: AND
117025: IFFALSE 117206
117027: GO 117029
117029: DISABLE
117030: LD_INT 0
117032: PPUSH
117033: PPUSH
117034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
117035: LD_ADDR_VAR 0 2
117039: PUSH
117040: LD_INT 22
117042: PUSH
117043: LD_OWVAR 2
117047: PUSH
117048: EMPTY
117049: LIST
117050: LIST
117051: PUSH
117052: LD_INT 33
117054: PUSH
117055: LD_INT 3
117057: PUSH
117058: EMPTY
117059: LIST
117060: LIST
117061: PUSH
117062: EMPTY
117063: LIST
117064: LIST
117065: PPUSH
117066: CALL_OW 69
117070: ST_TO_ADDR
// if not tmp then
117071: LD_VAR 0 2
117075: NOT
117076: IFFALSE 117080
// exit ;
117078: GO 117206
// side := 0 ;
117080: LD_ADDR_VAR 0 3
117084: PUSH
117085: LD_INT 0
117087: ST_TO_ADDR
// for i := 1 to 8 do
117088: LD_ADDR_VAR 0 1
117092: PUSH
117093: DOUBLE
117094: LD_INT 1
117096: DEC
117097: ST_TO_ADDR
117098: LD_INT 8
117100: PUSH
117101: FOR_TO
117102: IFFALSE 117150
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
117104: LD_OWVAR 2
117108: PUSH
117109: LD_VAR 0 1
117113: NONEQUAL
117114: PUSH
117115: LD_OWVAR 2
117119: PPUSH
117120: LD_VAR 0 1
117124: PPUSH
117125: CALL_OW 81
117129: PUSH
117130: LD_INT 2
117132: EQUAL
117133: AND
117134: IFFALSE 117148
// begin side := i ;
117136: LD_ADDR_VAR 0 3
117140: PUSH
117141: LD_VAR 0 1
117145: ST_TO_ADDR
// break ;
117146: GO 117150
// end ;
117148: GO 117101
117150: POP
117151: POP
// if not side then
117152: LD_VAR 0 3
117156: NOT
117157: IFFALSE 117161
// exit ;
117159: GO 117206
// for i := 1 to tmp do
117161: LD_ADDR_VAR 0 1
117165: PUSH
117166: DOUBLE
117167: LD_INT 1
117169: DEC
117170: ST_TO_ADDR
117171: LD_VAR 0 2
117175: PUSH
117176: FOR_TO
117177: IFFALSE 117204
// if Prob ( 60 ) then
117179: LD_INT 60
117181: PPUSH
117182: CALL_OW 13
117186: IFFALSE 117202
// SetSide ( i , side ) ;
117188: LD_VAR 0 1
117192: PPUSH
117193: LD_VAR 0 3
117197: PPUSH
117198: CALL_OW 235
117202: GO 117176
117204: POP
117205: POP
// end ;
117206: PPOPN 3
117208: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
117209: LD_EXP 146
117213: PUSH
117214: LD_EXP 159
117218: AND
117219: IFFALSE 117338
117221: GO 117223
117223: DISABLE
117224: LD_INT 0
117226: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
117227: LD_ADDR_VAR 0 1
117231: PUSH
117232: LD_INT 22
117234: PUSH
117235: LD_OWVAR 2
117239: PUSH
117240: EMPTY
117241: LIST
117242: LIST
117243: PUSH
117244: LD_INT 21
117246: PUSH
117247: LD_INT 1
117249: PUSH
117250: EMPTY
117251: LIST
117252: LIST
117253: PUSH
117254: LD_INT 3
117256: PUSH
117257: LD_INT 23
117259: PUSH
117260: LD_INT 0
117262: PUSH
117263: EMPTY
117264: LIST
117265: LIST
117266: PUSH
117267: EMPTY
117268: LIST
117269: LIST
117270: PUSH
117271: EMPTY
117272: LIST
117273: LIST
117274: LIST
117275: PPUSH
117276: CALL_OW 69
117280: PUSH
117281: FOR_IN
117282: IFFALSE 117336
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
117284: LD_VAR 0 1
117288: PPUSH
117289: CALL_OW 257
117293: PUSH
117294: LD_INT 1
117296: PUSH
117297: LD_INT 2
117299: PUSH
117300: LD_INT 3
117302: PUSH
117303: LD_INT 4
117305: PUSH
117306: EMPTY
117307: LIST
117308: LIST
117309: LIST
117310: LIST
117311: IN
117312: IFFALSE 117334
// SetClass ( un , rand ( 1 , 4 ) ) ;
117314: LD_VAR 0 1
117318: PPUSH
117319: LD_INT 1
117321: PPUSH
117322: LD_INT 4
117324: PPUSH
117325: CALL_OW 12
117329: PPUSH
117330: CALL_OW 336
117334: GO 117281
117336: POP
117337: POP
// end ;
117338: PPOPN 1
117340: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
117341: LD_EXP 146
117345: PUSH
117346: LD_EXP 158
117350: AND
117351: IFFALSE 117430
117353: GO 117355
117355: DISABLE
117356: LD_INT 0
117358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
117359: LD_ADDR_VAR 0 1
117363: PUSH
117364: LD_INT 22
117366: PUSH
117367: LD_OWVAR 2
117371: PUSH
117372: EMPTY
117373: LIST
117374: LIST
117375: PUSH
117376: LD_INT 21
117378: PUSH
117379: LD_INT 3
117381: PUSH
117382: EMPTY
117383: LIST
117384: LIST
117385: PUSH
117386: EMPTY
117387: LIST
117388: LIST
117389: PPUSH
117390: CALL_OW 69
117394: ST_TO_ADDR
// if not tmp then
117395: LD_VAR 0 1
117399: NOT
117400: IFFALSE 117404
// exit ;
117402: GO 117430
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
117404: LD_VAR 0 1
117408: PUSH
117409: LD_INT 1
117411: PPUSH
117412: LD_VAR 0 1
117416: PPUSH
117417: CALL_OW 12
117421: ARRAY
117422: PPUSH
117423: LD_INT 100
117425: PPUSH
117426: CALL_OW 234
// end ;
117430: PPOPN 1
117432: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
117433: LD_EXP 146
117437: PUSH
117438: LD_EXP 160
117442: AND
117443: IFFALSE 117541
117445: GO 117447
117447: DISABLE
117448: LD_INT 0
117450: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117451: LD_ADDR_VAR 0 1
117455: PUSH
117456: LD_INT 22
117458: PUSH
117459: LD_OWVAR 2
117463: PUSH
117464: EMPTY
117465: LIST
117466: LIST
117467: PUSH
117468: LD_INT 21
117470: PUSH
117471: LD_INT 1
117473: PUSH
117474: EMPTY
117475: LIST
117476: LIST
117477: PUSH
117478: EMPTY
117479: LIST
117480: LIST
117481: PPUSH
117482: CALL_OW 69
117486: ST_TO_ADDR
// if not tmp then
117487: LD_VAR 0 1
117491: NOT
117492: IFFALSE 117496
// exit ;
117494: GO 117541
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
117496: LD_VAR 0 1
117500: PUSH
117501: LD_INT 1
117503: PPUSH
117504: LD_VAR 0 1
117508: PPUSH
117509: CALL_OW 12
117513: ARRAY
117514: PPUSH
117515: LD_INT 1
117517: PPUSH
117518: LD_INT 4
117520: PPUSH
117521: CALL_OW 12
117525: PPUSH
117526: LD_INT 3000
117528: PPUSH
117529: LD_INT 9000
117531: PPUSH
117532: CALL_OW 12
117536: PPUSH
117537: CALL_OW 492
// end ;
117541: PPOPN 1
117543: END
// every 0 0$1 trigger StreamModeActive and sDepot do
117544: LD_EXP 146
117548: PUSH
117549: LD_EXP 161
117553: AND
117554: IFFALSE 117574
117556: GO 117558
117558: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
117559: LD_INT 1
117561: PPUSH
117562: LD_OWVAR 2
117566: PPUSH
117567: LD_INT 0
117569: PPUSH
117570: CALL_OW 324
117574: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
117575: LD_EXP 146
117579: PUSH
117580: LD_EXP 162
117584: AND
117585: IFFALSE 117668
117587: GO 117589
117589: DISABLE
117590: LD_INT 0
117592: PPUSH
117593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
117594: LD_ADDR_VAR 0 2
117598: PUSH
117599: LD_INT 22
117601: PUSH
117602: LD_OWVAR 2
117606: PUSH
117607: EMPTY
117608: LIST
117609: LIST
117610: PUSH
117611: LD_INT 21
117613: PUSH
117614: LD_INT 3
117616: PUSH
117617: EMPTY
117618: LIST
117619: LIST
117620: PUSH
117621: EMPTY
117622: LIST
117623: LIST
117624: PPUSH
117625: CALL_OW 69
117629: ST_TO_ADDR
// if not tmp then
117630: LD_VAR 0 2
117634: NOT
117635: IFFALSE 117639
// exit ;
117637: GO 117668
// for i in tmp do
117639: LD_ADDR_VAR 0 1
117643: PUSH
117644: LD_VAR 0 2
117648: PUSH
117649: FOR_IN
117650: IFFALSE 117666
// SetBLevel ( i , 10 ) ;
117652: LD_VAR 0 1
117656: PPUSH
117657: LD_INT 10
117659: PPUSH
117660: CALL_OW 241
117664: GO 117649
117666: POP
117667: POP
// end ;
117668: PPOPN 2
117670: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
117671: LD_EXP 146
117675: PUSH
117676: LD_EXP 163
117680: AND
117681: IFFALSE 117792
117683: GO 117685
117685: DISABLE
117686: LD_INT 0
117688: PPUSH
117689: PPUSH
117690: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117691: LD_ADDR_VAR 0 3
117695: PUSH
117696: LD_INT 22
117698: PUSH
117699: LD_OWVAR 2
117703: PUSH
117704: EMPTY
117705: LIST
117706: LIST
117707: PUSH
117708: LD_INT 25
117710: PUSH
117711: LD_INT 1
117713: PUSH
117714: EMPTY
117715: LIST
117716: LIST
117717: PUSH
117718: EMPTY
117719: LIST
117720: LIST
117721: PPUSH
117722: CALL_OW 69
117726: ST_TO_ADDR
// if not tmp then
117727: LD_VAR 0 3
117731: NOT
117732: IFFALSE 117736
// exit ;
117734: GO 117792
// un := tmp [ rand ( 1 , tmp ) ] ;
117736: LD_ADDR_VAR 0 2
117740: PUSH
117741: LD_VAR 0 3
117745: PUSH
117746: LD_INT 1
117748: PPUSH
117749: LD_VAR 0 3
117753: PPUSH
117754: CALL_OW 12
117758: ARRAY
117759: ST_TO_ADDR
// if Crawls ( un ) then
117760: LD_VAR 0 2
117764: PPUSH
117765: CALL_OW 318
117769: IFFALSE 117780
// ComWalk ( un ) ;
117771: LD_VAR 0 2
117775: PPUSH
117776: CALL_OW 138
// SetClass ( un , class_sniper ) ;
117780: LD_VAR 0 2
117784: PPUSH
117785: LD_INT 5
117787: PPUSH
117788: CALL_OW 336
// end ;
117792: PPOPN 3
117794: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
117795: LD_EXP 146
117799: PUSH
117800: LD_EXP 164
117804: AND
117805: PUSH
117806: LD_OWVAR 67
117810: PUSH
117811: LD_INT 4
117813: LESS
117814: AND
117815: IFFALSE 117834
117817: GO 117819
117819: DISABLE
// begin Difficulty := Difficulty + 1 ;
117820: LD_ADDR_OWVAR 67
117824: PUSH
117825: LD_OWVAR 67
117829: PUSH
117830: LD_INT 1
117832: PLUS
117833: ST_TO_ADDR
// end ;
117834: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
117835: LD_EXP 146
117839: PUSH
117840: LD_EXP 165
117844: AND
117845: IFFALSE 117948
117847: GO 117849
117849: DISABLE
117850: LD_INT 0
117852: PPUSH
// begin for i := 1 to 5 do
117853: LD_ADDR_VAR 0 1
117857: PUSH
117858: DOUBLE
117859: LD_INT 1
117861: DEC
117862: ST_TO_ADDR
117863: LD_INT 5
117865: PUSH
117866: FOR_TO
117867: IFFALSE 117946
// begin uc_nation := nation_nature ;
117869: LD_ADDR_OWVAR 21
117873: PUSH
117874: LD_INT 0
117876: ST_TO_ADDR
// uc_side := 0 ;
117877: LD_ADDR_OWVAR 20
117881: PUSH
117882: LD_INT 0
117884: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117885: LD_ADDR_OWVAR 29
117889: PUSH
117890: LD_INT 12
117892: PUSH
117893: LD_INT 12
117895: PUSH
117896: EMPTY
117897: LIST
117898: LIST
117899: ST_TO_ADDR
// hc_agressivity := 20 ;
117900: LD_ADDR_OWVAR 35
117904: PUSH
117905: LD_INT 20
117907: ST_TO_ADDR
// hc_class := class_tiger ;
117908: LD_ADDR_OWVAR 28
117912: PUSH
117913: LD_INT 14
117915: ST_TO_ADDR
// hc_gallery :=  ;
117916: LD_ADDR_OWVAR 33
117920: PUSH
117921: LD_STRING 
117923: ST_TO_ADDR
// hc_name :=  ;
117924: LD_ADDR_OWVAR 26
117928: PUSH
117929: LD_STRING 
117931: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
117932: CALL_OW 44
117936: PPUSH
117937: LD_INT 0
117939: PPUSH
117940: CALL_OW 51
// end ;
117944: GO 117866
117946: POP
117947: POP
// end ;
117948: PPOPN 1
117950: END
// every 0 0$1 trigger StreamModeActive and sBomb do
117951: LD_EXP 146
117955: PUSH
117956: LD_EXP 166
117960: AND
117961: IFFALSE 117970
117963: GO 117965
117965: DISABLE
// StreamSibBomb ;
117966: CALL 117971 0 0
117970: END
// export function StreamSibBomb ; var i , x , y ; begin
117971: LD_INT 0
117973: PPUSH
117974: PPUSH
117975: PPUSH
117976: PPUSH
// result := false ;
117977: LD_ADDR_VAR 0 1
117981: PUSH
117982: LD_INT 0
117984: ST_TO_ADDR
// for i := 1 to 16 do
117985: LD_ADDR_VAR 0 2
117989: PUSH
117990: DOUBLE
117991: LD_INT 1
117993: DEC
117994: ST_TO_ADDR
117995: LD_INT 16
117997: PUSH
117998: FOR_TO
117999: IFFALSE 118198
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
118001: LD_ADDR_VAR 0 3
118005: PUSH
118006: LD_INT 10
118008: PUSH
118009: LD_INT 20
118011: PUSH
118012: LD_INT 30
118014: PUSH
118015: LD_INT 40
118017: PUSH
118018: LD_INT 50
118020: PUSH
118021: LD_INT 60
118023: PUSH
118024: LD_INT 70
118026: PUSH
118027: LD_INT 80
118029: PUSH
118030: LD_INT 90
118032: PUSH
118033: LD_INT 100
118035: PUSH
118036: LD_INT 110
118038: PUSH
118039: LD_INT 120
118041: PUSH
118042: LD_INT 130
118044: PUSH
118045: LD_INT 140
118047: PUSH
118048: LD_INT 150
118050: PUSH
118051: EMPTY
118052: LIST
118053: LIST
118054: LIST
118055: LIST
118056: LIST
118057: LIST
118058: LIST
118059: LIST
118060: LIST
118061: LIST
118062: LIST
118063: LIST
118064: LIST
118065: LIST
118066: LIST
118067: PUSH
118068: LD_INT 1
118070: PPUSH
118071: LD_INT 15
118073: PPUSH
118074: CALL_OW 12
118078: ARRAY
118079: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
118080: LD_ADDR_VAR 0 4
118084: PUSH
118085: LD_INT 10
118087: PUSH
118088: LD_INT 20
118090: PUSH
118091: LD_INT 30
118093: PUSH
118094: LD_INT 40
118096: PUSH
118097: LD_INT 50
118099: PUSH
118100: LD_INT 60
118102: PUSH
118103: LD_INT 70
118105: PUSH
118106: LD_INT 80
118108: PUSH
118109: LD_INT 90
118111: PUSH
118112: LD_INT 100
118114: PUSH
118115: LD_INT 110
118117: PUSH
118118: LD_INT 120
118120: PUSH
118121: LD_INT 130
118123: PUSH
118124: LD_INT 140
118126: PUSH
118127: LD_INT 150
118129: PUSH
118130: EMPTY
118131: LIST
118132: LIST
118133: LIST
118134: LIST
118135: LIST
118136: LIST
118137: LIST
118138: LIST
118139: LIST
118140: LIST
118141: LIST
118142: LIST
118143: LIST
118144: LIST
118145: LIST
118146: PUSH
118147: LD_INT 1
118149: PPUSH
118150: LD_INT 15
118152: PPUSH
118153: CALL_OW 12
118157: ARRAY
118158: ST_TO_ADDR
// if ValidHex ( x , y ) then
118159: LD_VAR 0 3
118163: PPUSH
118164: LD_VAR 0 4
118168: PPUSH
118169: CALL_OW 488
118173: IFFALSE 118196
// begin result := [ x , y ] ;
118175: LD_ADDR_VAR 0 1
118179: PUSH
118180: LD_VAR 0 3
118184: PUSH
118185: LD_VAR 0 4
118189: PUSH
118190: EMPTY
118191: LIST
118192: LIST
118193: ST_TO_ADDR
// break ;
118194: GO 118198
// end ; end ;
118196: GO 117998
118198: POP
118199: POP
// if result then
118200: LD_VAR 0 1
118204: IFFALSE 118264
// begin ToLua ( playSibBomb() ) ;
118206: LD_STRING playSibBomb()
118208: PPUSH
118209: CALL_OW 559
// wait ( 0 0$14 ) ;
118213: LD_INT 490
118215: PPUSH
118216: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
118220: LD_VAR 0 1
118224: PUSH
118225: LD_INT 1
118227: ARRAY
118228: PPUSH
118229: LD_VAR 0 1
118233: PUSH
118234: LD_INT 2
118236: ARRAY
118237: PPUSH
118238: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
118242: LD_VAR 0 1
118246: PUSH
118247: LD_INT 1
118249: ARRAY
118250: PPUSH
118251: LD_VAR 0 1
118255: PUSH
118256: LD_INT 2
118258: ARRAY
118259: PPUSH
118260: CALL_OW 429
// end ; end ;
118264: LD_VAR 0 1
118268: RET
// every 0 0$1 trigger StreamModeActive and sReset do
118269: LD_EXP 146
118273: PUSH
118274: LD_EXP 168
118278: AND
118279: IFFALSE 118291
118281: GO 118283
118283: DISABLE
// YouLost (  ) ;
118284: LD_STRING 
118286: PPUSH
118287: CALL_OW 104
118291: END
// every 0 0$1 trigger StreamModeActive and sFog do
118292: LD_EXP 146
118296: PUSH
118297: LD_EXP 167
118301: AND
118302: IFFALSE 118316
118304: GO 118306
118306: DISABLE
// FogOff ( your_side ) ;
118307: LD_OWVAR 2
118311: PPUSH
118312: CALL_OW 344
118316: END
// every 0 0$1 trigger StreamModeActive and sSun do
118317: LD_EXP 146
118321: PUSH
118322: LD_EXP 169
118326: AND
118327: IFFALSE 118355
118329: GO 118331
118331: DISABLE
// begin solar_recharge_percent := 0 ;
118332: LD_ADDR_OWVAR 79
118336: PUSH
118337: LD_INT 0
118339: ST_TO_ADDR
// wait ( 5 5$00 ) ;
118340: LD_INT 10500
118342: PPUSH
118343: CALL_OW 67
// solar_recharge_percent := 100 ;
118347: LD_ADDR_OWVAR 79
118351: PUSH
118352: LD_INT 100
118354: ST_TO_ADDR
// end ;
118355: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
118356: LD_EXP 146
118360: PUSH
118361: LD_EXP 170
118365: AND
118366: IFFALSE 118605
118368: GO 118370
118370: DISABLE
118371: LD_INT 0
118373: PPUSH
118374: PPUSH
118375: PPUSH
// begin tmp := [ ] ;
118376: LD_ADDR_VAR 0 3
118380: PUSH
118381: EMPTY
118382: ST_TO_ADDR
// for i := 1 to 6 do
118383: LD_ADDR_VAR 0 1
118387: PUSH
118388: DOUBLE
118389: LD_INT 1
118391: DEC
118392: ST_TO_ADDR
118393: LD_INT 6
118395: PUSH
118396: FOR_TO
118397: IFFALSE 118502
// begin uc_nation := nation_nature ;
118399: LD_ADDR_OWVAR 21
118403: PUSH
118404: LD_INT 0
118406: ST_TO_ADDR
// uc_side := 0 ;
118407: LD_ADDR_OWVAR 20
118411: PUSH
118412: LD_INT 0
118414: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
118415: LD_ADDR_OWVAR 29
118419: PUSH
118420: LD_INT 12
118422: PUSH
118423: LD_INT 12
118425: PUSH
118426: EMPTY
118427: LIST
118428: LIST
118429: ST_TO_ADDR
// hc_agressivity := 20 ;
118430: LD_ADDR_OWVAR 35
118434: PUSH
118435: LD_INT 20
118437: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
118438: LD_ADDR_OWVAR 28
118442: PUSH
118443: LD_INT 17
118445: ST_TO_ADDR
// hc_gallery :=  ;
118446: LD_ADDR_OWVAR 33
118450: PUSH
118451: LD_STRING 
118453: ST_TO_ADDR
// hc_name :=  ;
118454: LD_ADDR_OWVAR 26
118458: PUSH
118459: LD_STRING 
118461: ST_TO_ADDR
// un := CreateHuman ;
118462: LD_ADDR_VAR 0 2
118466: PUSH
118467: CALL_OW 44
118471: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
118472: LD_VAR 0 2
118476: PPUSH
118477: LD_INT 1
118479: PPUSH
118480: CALL_OW 51
// tmp := tmp ^ un ;
118484: LD_ADDR_VAR 0 3
118488: PUSH
118489: LD_VAR 0 3
118493: PUSH
118494: LD_VAR 0 2
118498: ADD
118499: ST_TO_ADDR
// end ;
118500: GO 118396
118502: POP
118503: POP
// repeat wait ( 0 0$1 ) ;
118504: LD_INT 35
118506: PPUSH
118507: CALL_OW 67
// for un in tmp do
118511: LD_ADDR_VAR 0 2
118515: PUSH
118516: LD_VAR 0 3
118520: PUSH
118521: FOR_IN
118522: IFFALSE 118596
// begin if IsDead ( un ) then
118524: LD_VAR 0 2
118528: PPUSH
118529: CALL_OW 301
118533: IFFALSE 118553
// begin tmp := tmp diff un ;
118535: LD_ADDR_VAR 0 3
118539: PUSH
118540: LD_VAR 0 3
118544: PUSH
118545: LD_VAR 0 2
118549: DIFF
118550: ST_TO_ADDR
// continue ;
118551: GO 118521
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
118553: LD_VAR 0 2
118557: PPUSH
118558: LD_INT 3
118560: PUSH
118561: LD_INT 22
118563: PUSH
118564: LD_INT 0
118566: PUSH
118567: EMPTY
118568: LIST
118569: LIST
118570: PUSH
118571: EMPTY
118572: LIST
118573: LIST
118574: PPUSH
118575: CALL_OW 69
118579: PPUSH
118580: LD_VAR 0 2
118584: PPUSH
118585: CALL_OW 74
118589: PPUSH
118590: CALL_OW 115
// end ;
118594: GO 118521
118596: POP
118597: POP
// until not tmp ;
118598: LD_VAR 0 3
118602: NOT
118603: IFFALSE 118504
// end ;
118605: PPOPN 3
118607: END
// every 0 0$1 trigger StreamModeActive and sTroll do
118608: LD_EXP 146
118612: PUSH
118613: LD_EXP 171
118617: AND
118618: IFFALSE 118672
118620: GO 118622
118622: DISABLE
// begin ToLua ( displayTroll(); ) ;
118623: LD_STRING displayTroll();
118625: PPUSH
118626: CALL_OW 559
// wait ( 3 3$00 ) ;
118630: LD_INT 6300
118632: PPUSH
118633: CALL_OW 67
// ToLua ( hideTroll(); ) ;
118637: LD_STRING hideTroll();
118639: PPUSH
118640: CALL_OW 559
// wait ( 1 1$00 ) ;
118644: LD_INT 2100
118646: PPUSH
118647: CALL_OW 67
// ToLua ( displayTroll(); ) ;
118651: LD_STRING displayTroll();
118653: PPUSH
118654: CALL_OW 559
// wait ( 1 1$00 ) ;
118658: LD_INT 2100
118660: PPUSH
118661: CALL_OW 67
// ToLua ( hideTroll(); ) ;
118665: LD_STRING hideTroll();
118667: PPUSH
118668: CALL_OW 559
// end ;
118672: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
118673: LD_EXP 146
118677: PUSH
118678: LD_EXP 172
118682: AND
118683: IFFALSE 118746
118685: GO 118687
118687: DISABLE
118688: LD_INT 0
118690: PPUSH
// begin p := 0 ;
118691: LD_ADDR_VAR 0 1
118695: PUSH
118696: LD_INT 0
118698: ST_TO_ADDR
// repeat game_speed := 1 ;
118699: LD_ADDR_OWVAR 65
118703: PUSH
118704: LD_INT 1
118706: ST_TO_ADDR
// wait ( 0 0$1 ) ;
118707: LD_INT 35
118709: PPUSH
118710: CALL_OW 67
// p := p + 1 ;
118714: LD_ADDR_VAR 0 1
118718: PUSH
118719: LD_VAR 0 1
118723: PUSH
118724: LD_INT 1
118726: PLUS
118727: ST_TO_ADDR
// until p >= 60 ;
118728: LD_VAR 0 1
118732: PUSH
118733: LD_INT 60
118735: GREATEREQUAL
118736: IFFALSE 118699
// game_speed := 4 ;
118738: LD_ADDR_OWVAR 65
118742: PUSH
118743: LD_INT 4
118745: ST_TO_ADDR
// end ;
118746: PPOPN 1
118748: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
118749: LD_EXP 146
118753: PUSH
118754: LD_EXP 173
118758: AND
118759: IFFALSE 118905
118761: GO 118763
118763: DISABLE
118764: LD_INT 0
118766: PPUSH
118767: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118768: LD_ADDR_VAR 0 1
118772: PUSH
118773: LD_INT 22
118775: PUSH
118776: LD_OWVAR 2
118780: PUSH
118781: EMPTY
118782: LIST
118783: LIST
118784: PUSH
118785: LD_INT 2
118787: PUSH
118788: LD_INT 30
118790: PUSH
118791: LD_INT 0
118793: PUSH
118794: EMPTY
118795: LIST
118796: LIST
118797: PUSH
118798: LD_INT 30
118800: PUSH
118801: LD_INT 1
118803: PUSH
118804: EMPTY
118805: LIST
118806: LIST
118807: PUSH
118808: EMPTY
118809: LIST
118810: LIST
118811: LIST
118812: PUSH
118813: EMPTY
118814: LIST
118815: LIST
118816: PPUSH
118817: CALL_OW 69
118821: ST_TO_ADDR
// if not depot then
118822: LD_VAR 0 1
118826: NOT
118827: IFFALSE 118831
// exit ;
118829: GO 118905
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
118831: LD_ADDR_VAR 0 2
118835: PUSH
118836: LD_VAR 0 1
118840: PUSH
118841: LD_INT 1
118843: PPUSH
118844: LD_VAR 0 1
118848: PPUSH
118849: CALL_OW 12
118853: ARRAY
118854: PPUSH
118855: CALL_OW 274
118859: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
118860: LD_VAR 0 2
118864: PPUSH
118865: LD_INT 1
118867: PPUSH
118868: LD_INT 0
118870: PPUSH
118871: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
118875: LD_VAR 0 2
118879: PPUSH
118880: LD_INT 2
118882: PPUSH
118883: LD_INT 0
118885: PPUSH
118886: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
118890: LD_VAR 0 2
118894: PPUSH
118895: LD_INT 3
118897: PPUSH
118898: LD_INT 0
118900: PPUSH
118901: CALL_OW 277
// end ;
118905: PPOPN 2
118907: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
118908: LD_EXP 146
118912: PUSH
118913: LD_EXP 174
118917: AND
118918: IFFALSE 119015
118920: GO 118922
118922: DISABLE
118923: LD_INT 0
118925: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118926: LD_ADDR_VAR 0 1
118930: PUSH
118931: LD_INT 22
118933: PUSH
118934: LD_OWVAR 2
118938: PUSH
118939: EMPTY
118940: LIST
118941: LIST
118942: PUSH
118943: LD_INT 21
118945: PUSH
118946: LD_INT 1
118948: PUSH
118949: EMPTY
118950: LIST
118951: LIST
118952: PUSH
118953: LD_INT 3
118955: PUSH
118956: LD_INT 23
118958: PUSH
118959: LD_INT 0
118961: PUSH
118962: EMPTY
118963: LIST
118964: LIST
118965: PUSH
118966: EMPTY
118967: LIST
118968: LIST
118969: PUSH
118970: EMPTY
118971: LIST
118972: LIST
118973: LIST
118974: PPUSH
118975: CALL_OW 69
118979: ST_TO_ADDR
// if not tmp then
118980: LD_VAR 0 1
118984: NOT
118985: IFFALSE 118989
// exit ;
118987: GO 119015
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
118989: LD_VAR 0 1
118993: PUSH
118994: LD_INT 1
118996: PPUSH
118997: LD_VAR 0 1
119001: PPUSH
119002: CALL_OW 12
119006: ARRAY
119007: PPUSH
119008: LD_INT 200
119010: PPUSH
119011: CALL_OW 234
// end ;
119015: PPOPN 1
119017: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
119018: LD_EXP 146
119022: PUSH
119023: LD_EXP 175
119027: AND
119028: IFFALSE 119107
119030: GO 119032
119032: DISABLE
119033: LD_INT 0
119035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
119036: LD_ADDR_VAR 0 1
119040: PUSH
119041: LD_INT 22
119043: PUSH
119044: LD_OWVAR 2
119048: PUSH
119049: EMPTY
119050: LIST
119051: LIST
119052: PUSH
119053: LD_INT 21
119055: PUSH
119056: LD_INT 2
119058: PUSH
119059: EMPTY
119060: LIST
119061: LIST
119062: PUSH
119063: EMPTY
119064: LIST
119065: LIST
119066: PPUSH
119067: CALL_OW 69
119071: ST_TO_ADDR
// if not tmp then
119072: LD_VAR 0 1
119076: NOT
119077: IFFALSE 119081
// exit ;
119079: GO 119107
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
119081: LD_VAR 0 1
119085: PUSH
119086: LD_INT 1
119088: PPUSH
119089: LD_VAR 0 1
119093: PPUSH
119094: CALL_OW 12
119098: ARRAY
119099: PPUSH
119100: LD_INT 60
119102: PPUSH
119103: CALL_OW 234
// end ;
119107: PPOPN 1
119109: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
119110: LD_EXP 146
119114: PUSH
119115: LD_EXP 176
119119: AND
119120: IFFALSE 119219
119122: GO 119124
119124: DISABLE
119125: LD_INT 0
119127: PPUSH
119128: PPUSH
// begin enable ;
119129: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
119130: LD_ADDR_VAR 0 1
119134: PUSH
119135: LD_INT 22
119137: PUSH
119138: LD_OWVAR 2
119142: PUSH
119143: EMPTY
119144: LIST
119145: LIST
119146: PUSH
119147: LD_INT 61
119149: PUSH
119150: EMPTY
119151: LIST
119152: PUSH
119153: LD_INT 33
119155: PUSH
119156: LD_INT 2
119158: PUSH
119159: EMPTY
119160: LIST
119161: LIST
119162: PUSH
119163: EMPTY
119164: LIST
119165: LIST
119166: LIST
119167: PPUSH
119168: CALL_OW 69
119172: ST_TO_ADDR
// if not tmp then
119173: LD_VAR 0 1
119177: NOT
119178: IFFALSE 119182
// exit ;
119180: GO 119219
// for i in tmp do
119182: LD_ADDR_VAR 0 2
119186: PUSH
119187: LD_VAR 0 1
119191: PUSH
119192: FOR_IN
119193: IFFALSE 119217
// if IsControledBy ( i ) then
119195: LD_VAR 0 2
119199: PPUSH
119200: CALL_OW 312
119204: IFFALSE 119215
// ComUnlink ( i ) ;
119206: LD_VAR 0 2
119210: PPUSH
119211: CALL_OW 136
119215: GO 119192
119217: POP
119218: POP
// end ;
119219: PPOPN 2
119221: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
119222: LD_EXP 146
119226: PUSH
119227: LD_EXP 177
119231: AND
119232: IFFALSE 119372
119234: GO 119236
119236: DISABLE
119237: LD_INT 0
119239: PPUSH
119240: PPUSH
// begin ToLua ( displayPowell(); ) ;
119241: LD_STRING displayPowell();
119243: PPUSH
119244: CALL_OW 559
// uc_side := 0 ;
119248: LD_ADDR_OWVAR 20
119252: PUSH
119253: LD_INT 0
119255: ST_TO_ADDR
// uc_nation := 2 ;
119256: LD_ADDR_OWVAR 21
119260: PUSH
119261: LD_INT 2
119263: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
119264: LD_ADDR_OWVAR 37
119268: PUSH
119269: LD_INT 14
119271: ST_TO_ADDR
// vc_engine := engine_siberite ;
119272: LD_ADDR_OWVAR 39
119276: PUSH
119277: LD_INT 3
119279: ST_TO_ADDR
// vc_control := control_apeman ;
119280: LD_ADDR_OWVAR 38
119284: PUSH
119285: LD_INT 5
119287: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
119288: LD_ADDR_OWVAR 40
119292: PUSH
119293: LD_INT 29
119295: ST_TO_ADDR
// un := CreateVehicle ;
119296: LD_ADDR_VAR 0 2
119300: PUSH
119301: CALL_OW 45
119305: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119306: LD_VAR 0 2
119310: PPUSH
119311: LD_INT 1
119313: PPUSH
119314: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
119318: LD_INT 35
119320: PPUSH
119321: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
119325: LD_VAR 0 2
119329: PPUSH
119330: LD_INT 22
119332: PUSH
119333: LD_OWVAR 2
119337: PUSH
119338: EMPTY
119339: LIST
119340: LIST
119341: PPUSH
119342: CALL_OW 69
119346: PPUSH
119347: LD_VAR 0 2
119351: PPUSH
119352: CALL_OW 74
119356: PPUSH
119357: CALL_OW 115
// until IsDead ( un ) ;
119361: LD_VAR 0 2
119365: PPUSH
119366: CALL_OW 301
119370: IFFALSE 119318
// end ;
119372: PPOPN 2
119374: END
// every 0 0$1 trigger StreamModeActive and sStu do
119375: LD_EXP 146
119379: PUSH
119380: LD_EXP 185
119384: AND
119385: IFFALSE 119401
119387: GO 119389
119389: DISABLE
// begin ToLua ( displayStucuk(); ) ;
119390: LD_STRING displayStucuk();
119392: PPUSH
119393: CALL_OW 559
// ResetFog ;
119397: CALL_OW 335
// end ;
119401: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
119402: LD_EXP 146
119406: PUSH
119407: LD_EXP 178
119411: AND
119412: IFFALSE 119553
119414: GO 119416
119416: DISABLE
119417: LD_INT 0
119419: PPUSH
119420: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119421: LD_ADDR_VAR 0 2
119425: PUSH
119426: LD_INT 22
119428: PUSH
119429: LD_OWVAR 2
119433: PUSH
119434: EMPTY
119435: LIST
119436: LIST
119437: PUSH
119438: LD_INT 21
119440: PUSH
119441: LD_INT 1
119443: PUSH
119444: EMPTY
119445: LIST
119446: LIST
119447: PUSH
119448: EMPTY
119449: LIST
119450: LIST
119451: PPUSH
119452: CALL_OW 69
119456: ST_TO_ADDR
// if not tmp then
119457: LD_VAR 0 2
119461: NOT
119462: IFFALSE 119466
// exit ;
119464: GO 119553
// un := tmp [ rand ( 1 , tmp ) ] ;
119466: LD_ADDR_VAR 0 1
119470: PUSH
119471: LD_VAR 0 2
119475: PUSH
119476: LD_INT 1
119478: PPUSH
119479: LD_VAR 0 2
119483: PPUSH
119484: CALL_OW 12
119488: ARRAY
119489: ST_TO_ADDR
// SetSide ( un , 0 ) ;
119490: LD_VAR 0 1
119494: PPUSH
119495: LD_INT 0
119497: PPUSH
119498: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
119502: LD_VAR 0 1
119506: PPUSH
119507: LD_OWVAR 3
119511: PUSH
119512: LD_VAR 0 1
119516: DIFF
119517: PPUSH
119518: LD_VAR 0 1
119522: PPUSH
119523: CALL_OW 74
119527: PPUSH
119528: CALL_OW 115
// wait ( 0 0$20 ) ;
119532: LD_INT 700
119534: PPUSH
119535: CALL_OW 67
// SetSide ( un , your_side ) ;
119539: LD_VAR 0 1
119543: PPUSH
119544: LD_OWVAR 2
119548: PPUSH
119549: CALL_OW 235
// end ;
119553: PPOPN 2
119555: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
119556: LD_EXP 146
119560: PUSH
119561: LD_EXP 179
119565: AND
119566: IFFALSE 119672
119568: GO 119570
119570: DISABLE
119571: LD_INT 0
119573: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
119574: LD_ADDR_VAR 0 1
119578: PUSH
119579: LD_INT 22
119581: PUSH
119582: LD_OWVAR 2
119586: PUSH
119587: EMPTY
119588: LIST
119589: LIST
119590: PUSH
119591: LD_INT 2
119593: PUSH
119594: LD_INT 30
119596: PUSH
119597: LD_INT 0
119599: PUSH
119600: EMPTY
119601: LIST
119602: LIST
119603: PUSH
119604: LD_INT 30
119606: PUSH
119607: LD_INT 1
119609: PUSH
119610: EMPTY
119611: LIST
119612: LIST
119613: PUSH
119614: EMPTY
119615: LIST
119616: LIST
119617: LIST
119618: PUSH
119619: EMPTY
119620: LIST
119621: LIST
119622: PPUSH
119623: CALL_OW 69
119627: ST_TO_ADDR
// if not depot then
119628: LD_VAR 0 1
119632: NOT
119633: IFFALSE 119637
// exit ;
119635: GO 119672
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
119637: LD_VAR 0 1
119641: PUSH
119642: LD_INT 1
119644: ARRAY
119645: PPUSH
119646: CALL_OW 250
119650: PPUSH
119651: LD_VAR 0 1
119655: PUSH
119656: LD_INT 1
119658: ARRAY
119659: PPUSH
119660: CALL_OW 251
119664: PPUSH
119665: LD_INT 70
119667: PPUSH
119668: CALL_OW 495
// end ;
119672: PPOPN 1
119674: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
119675: LD_EXP 146
119679: PUSH
119680: LD_EXP 180
119684: AND
119685: IFFALSE 119896
119687: GO 119689
119689: DISABLE
119690: LD_INT 0
119692: PPUSH
119693: PPUSH
119694: PPUSH
119695: PPUSH
119696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119697: LD_ADDR_VAR 0 5
119701: PUSH
119702: LD_INT 22
119704: PUSH
119705: LD_OWVAR 2
119709: PUSH
119710: EMPTY
119711: LIST
119712: LIST
119713: PUSH
119714: LD_INT 21
119716: PUSH
119717: LD_INT 1
119719: PUSH
119720: EMPTY
119721: LIST
119722: LIST
119723: PUSH
119724: EMPTY
119725: LIST
119726: LIST
119727: PPUSH
119728: CALL_OW 69
119732: ST_TO_ADDR
// if not tmp then
119733: LD_VAR 0 5
119737: NOT
119738: IFFALSE 119742
// exit ;
119740: GO 119896
// for i in tmp do
119742: LD_ADDR_VAR 0 1
119746: PUSH
119747: LD_VAR 0 5
119751: PUSH
119752: FOR_IN
119753: IFFALSE 119894
// begin d := rand ( 0 , 5 ) ;
119755: LD_ADDR_VAR 0 4
119759: PUSH
119760: LD_INT 0
119762: PPUSH
119763: LD_INT 5
119765: PPUSH
119766: CALL_OW 12
119770: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
119771: LD_ADDR_VAR 0 2
119775: PUSH
119776: LD_VAR 0 1
119780: PPUSH
119781: CALL_OW 250
119785: PPUSH
119786: LD_VAR 0 4
119790: PPUSH
119791: LD_INT 3
119793: PPUSH
119794: LD_INT 12
119796: PPUSH
119797: CALL_OW 12
119801: PPUSH
119802: CALL_OW 272
119806: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
119807: LD_ADDR_VAR 0 3
119811: PUSH
119812: LD_VAR 0 1
119816: PPUSH
119817: CALL_OW 251
119821: PPUSH
119822: LD_VAR 0 4
119826: PPUSH
119827: LD_INT 3
119829: PPUSH
119830: LD_INT 12
119832: PPUSH
119833: CALL_OW 12
119837: PPUSH
119838: CALL_OW 273
119842: ST_TO_ADDR
// if ValidHex ( x , y ) then
119843: LD_VAR 0 2
119847: PPUSH
119848: LD_VAR 0 3
119852: PPUSH
119853: CALL_OW 488
119857: IFFALSE 119892
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
119859: LD_VAR 0 1
119863: PPUSH
119864: LD_VAR 0 2
119868: PPUSH
119869: LD_VAR 0 3
119873: PPUSH
119874: LD_INT 3
119876: PPUSH
119877: LD_INT 6
119879: PPUSH
119880: CALL_OW 12
119884: PPUSH
119885: LD_INT 1
119887: PPUSH
119888: CALL_OW 483
// end ;
119892: GO 119752
119894: POP
119895: POP
// end ;
119896: PPOPN 5
119898: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
119899: LD_EXP 146
119903: PUSH
119904: LD_EXP 181
119908: AND
119909: IFFALSE 120003
119911: GO 119913
119913: DISABLE
119914: LD_INT 0
119916: PPUSH
119917: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
119918: LD_ADDR_VAR 0 2
119922: PUSH
119923: LD_INT 22
119925: PUSH
119926: LD_OWVAR 2
119930: PUSH
119931: EMPTY
119932: LIST
119933: LIST
119934: PUSH
119935: LD_INT 32
119937: PUSH
119938: LD_INT 1
119940: PUSH
119941: EMPTY
119942: LIST
119943: LIST
119944: PUSH
119945: LD_INT 21
119947: PUSH
119948: LD_INT 2
119950: PUSH
119951: EMPTY
119952: LIST
119953: LIST
119954: PUSH
119955: EMPTY
119956: LIST
119957: LIST
119958: LIST
119959: PPUSH
119960: CALL_OW 69
119964: ST_TO_ADDR
// if not tmp then
119965: LD_VAR 0 2
119969: NOT
119970: IFFALSE 119974
// exit ;
119972: GO 120003
// for i in tmp do
119974: LD_ADDR_VAR 0 1
119978: PUSH
119979: LD_VAR 0 2
119983: PUSH
119984: FOR_IN
119985: IFFALSE 120001
// SetFuel ( i , 0 ) ;
119987: LD_VAR 0 1
119991: PPUSH
119992: LD_INT 0
119994: PPUSH
119995: CALL_OW 240
119999: GO 119984
120001: POP
120002: POP
// end ;
120003: PPOPN 2
120005: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
120006: LD_EXP 146
120010: PUSH
120011: LD_EXP 182
120015: AND
120016: IFFALSE 120082
120018: GO 120020
120020: DISABLE
120021: LD_INT 0
120023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120024: LD_ADDR_VAR 0 1
120028: PUSH
120029: LD_INT 22
120031: PUSH
120032: LD_OWVAR 2
120036: PUSH
120037: EMPTY
120038: LIST
120039: LIST
120040: PUSH
120041: LD_INT 30
120043: PUSH
120044: LD_INT 29
120046: PUSH
120047: EMPTY
120048: LIST
120049: LIST
120050: PUSH
120051: EMPTY
120052: LIST
120053: LIST
120054: PPUSH
120055: CALL_OW 69
120059: ST_TO_ADDR
// if not tmp then
120060: LD_VAR 0 1
120064: NOT
120065: IFFALSE 120069
// exit ;
120067: GO 120082
// DestroyUnit ( tmp [ 1 ] ) ;
120069: LD_VAR 0 1
120073: PUSH
120074: LD_INT 1
120076: ARRAY
120077: PPUSH
120078: CALL_OW 65
// end ;
120082: PPOPN 1
120084: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
120085: LD_EXP 146
120089: PUSH
120090: LD_EXP 184
120094: AND
120095: IFFALSE 120224
120097: GO 120099
120099: DISABLE
120100: LD_INT 0
120102: PPUSH
// begin uc_side := 0 ;
120103: LD_ADDR_OWVAR 20
120107: PUSH
120108: LD_INT 0
120110: ST_TO_ADDR
// uc_nation := nation_arabian ;
120111: LD_ADDR_OWVAR 21
120115: PUSH
120116: LD_INT 2
120118: ST_TO_ADDR
// hc_gallery :=  ;
120119: LD_ADDR_OWVAR 33
120123: PUSH
120124: LD_STRING 
120126: ST_TO_ADDR
// hc_name :=  ;
120127: LD_ADDR_OWVAR 26
120131: PUSH
120132: LD_STRING 
120134: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
120135: LD_INT 1
120137: PPUSH
120138: LD_INT 11
120140: PPUSH
120141: LD_INT 10
120143: PPUSH
120144: CALL_OW 380
// un := CreateHuman ;
120148: LD_ADDR_VAR 0 1
120152: PUSH
120153: CALL_OW 44
120157: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120158: LD_VAR 0 1
120162: PPUSH
120163: LD_INT 1
120165: PPUSH
120166: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
120170: LD_INT 35
120172: PPUSH
120173: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
120177: LD_VAR 0 1
120181: PPUSH
120182: LD_INT 22
120184: PUSH
120185: LD_OWVAR 2
120189: PUSH
120190: EMPTY
120191: LIST
120192: LIST
120193: PPUSH
120194: CALL_OW 69
120198: PPUSH
120199: LD_VAR 0 1
120203: PPUSH
120204: CALL_OW 74
120208: PPUSH
120209: CALL_OW 115
// until IsDead ( un ) ;
120213: LD_VAR 0 1
120217: PPUSH
120218: CALL_OW 301
120222: IFFALSE 120170
// end ;
120224: PPOPN 1
120226: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
120227: LD_EXP 146
120231: PUSH
120232: LD_EXP 186
120236: AND
120237: IFFALSE 120249
120239: GO 120241
120241: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
120242: LD_STRING earthquake(getX(game), 0, 32)
120244: PPUSH
120245: CALL_OW 559
120249: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
120250: LD_EXP 146
120254: PUSH
120255: LD_EXP 187
120259: AND
120260: IFFALSE 120351
120262: GO 120264
120264: DISABLE
120265: LD_INT 0
120267: PPUSH
// begin enable ;
120268: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
120269: LD_ADDR_VAR 0 1
120273: PUSH
120274: LD_INT 22
120276: PUSH
120277: LD_OWVAR 2
120281: PUSH
120282: EMPTY
120283: LIST
120284: LIST
120285: PUSH
120286: LD_INT 21
120288: PUSH
120289: LD_INT 2
120291: PUSH
120292: EMPTY
120293: LIST
120294: LIST
120295: PUSH
120296: LD_INT 33
120298: PUSH
120299: LD_INT 3
120301: PUSH
120302: EMPTY
120303: LIST
120304: LIST
120305: PUSH
120306: EMPTY
120307: LIST
120308: LIST
120309: LIST
120310: PPUSH
120311: CALL_OW 69
120315: ST_TO_ADDR
// if not tmp then
120316: LD_VAR 0 1
120320: NOT
120321: IFFALSE 120325
// exit ;
120323: GO 120351
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
120325: LD_VAR 0 1
120329: PUSH
120330: LD_INT 1
120332: PPUSH
120333: LD_VAR 0 1
120337: PPUSH
120338: CALL_OW 12
120342: ARRAY
120343: PPUSH
120344: LD_INT 1
120346: PPUSH
120347: CALL_OW 234
// end ;
120351: PPOPN 1
120353: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
120354: LD_EXP 146
120358: PUSH
120359: LD_EXP 188
120363: AND
120364: IFFALSE 120505
120366: GO 120368
120368: DISABLE
120369: LD_INT 0
120371: PPUSH
120372: PPUSH
120373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120374: LD_ADDR_VAR 0 3
120378: PUSH
120379: LD_INT 22
120381: PUSH
120382: LD_OWVAR 2
120386: PUSH
120387: EMPTY
120388: LIST
120389: LIST
120390: PUSH
120391: LD_INT 25
120393: PUSH
120394: LD_INT 1
120396: PUSH
120397: EMPTY
120398: LIST
120399: LIST
120400: PUSH
120401: EMPTY
120402: LIST
120403: LIST
120404: PPUSH
120405: CALL_OW 69
120409: ST_TO_ADDR
// if not tmp then
120410: LD_VAR 0 3
120414: NOT
120415: IFFALSE 120419
// exit ;
120417: GO 120505
// un := tmp [ rand ( 1 , tmp ) ] ;
120419: LD_ADDR_VAR 0 2
120423: PUSH
120424: LD_VAR 0 3
120428: PUSH
120429: LD_INT 1
120431: PPUSH
120432: LD_VAR 0 3
120436: PPUSH
120437: CALL_OW 12
120441: ARRAY
120442: ST_TO_ADDR
// if Crawls ( un ) then
120443: LD_VAR 0 2
120447: PPUSH
120448: CALL_OW 318
120452: IFFALSE 120463
// ComWalk ( un ) ;
120454: LD_VAR 0 2
120458: PPUSH
120459: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
120463: LD_VAR 0 2
120467: PPUSH
120468: LD_INT 9
120470: PPUSH
120471: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
120475: LD_INT 28
120477: PPUSH
120478: LD_OWVAR 2
120482: PPUSH
120483: LD_INT 2
120485: PPUSH
120486: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
120490: LD_INT 29
120492: PPUSH
120493: LD_OWVAR 2
120497: PPUSH
120498: LD_INT 2
120500: PPUSH
120501: CALL_OW 322
// end ;
120505: PPOPN 3
120507: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
120508: LD_EXP 146
120512: PUSH
120513: LD_EXP 189
120517: AND
120518: IFFALSE 120629
120520: GO 120522
120522: DISABLE
120523: LD_INT 0
120525: PPUSH
120526: PPUSH
120527: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120528: LD_ADDR_VAR 0 3
120532: PUSH
120533: LD_INT 22
120535: PUSH
120536: LD_OWVAR 2
120540: PUSH
120541: EMPTY
120542: LIST
120543: LIST
120544: PUSH
120545: LD_INT 25
120547: PUSH
120548: LD_INT 1
120550: PUSH
120551: EMPTY
120552: LIST
120553: LIST
120554: PUSH
120555: EMPTY
120556: LIST
120557: LIST
120558: PPUSH
120559: CALL_OW 69
120563: ST_TO_ADDR
// if not tmp then
120564: LD_VAR 0 3
120568: NOT
120569: IFFALSE 120573
// exit ;
120571: GO 120629
// un := tmp [ rand ( 1 , tmp ) ] ;
120573: LD_ADDR_VAR 0 2
120577: PUSH
120578: LD_VAR 0 3
120582: PUSH
120583: LD_INT 1
120585: PPUSH
120586: LD_VAR 0 3
120590: PPUSH
120591: CALL_OW 12
120595: ARRAY
120596: ST_TO_ADDR
// if Crawls ( un ) then
120597: LD_VAR 0 2
120601: PPUSH
120602: CALL_OW 318
120606: IFFALSE 120617
// ComWalk ( un ) ;
120608: LD_VAR 0 2
120612: PPUSH
120613: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120617: LD_VAR 0 2
120621: PPUSH
120622: LD_INT 8
120624: PPUSH
120625: CALL_OW 336
// end ;
120629: PPOPN 3
120631: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
120632: LD_EXP 146
120636: PUSH
120637: LD_EXP 190
120641: AND
120642: IFFALSE 120786
120644: GO 120646
120646: DISABLE
120647: LD_INT 0
120649: PPUSH
120650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
120651: LD_ADDR_VAR 0 2
120655: PUSH
120656: LD_INT 22
120658: PUSH
120659: LD_OWVAR 2
120663: PUSH
120664: EMPTY
120665: LIST
120666: LIST
120667: PUSH
120668: LD_INT 21
120670: PUSH
120671: LD_INT 2
120673: PUSH
120674: EMPTY
120675: LIST
120676: LIST
120677: PUSH
120678: LD_INT 2
120680: PUSH
120681: LD_INT 34
120683: PUSH
120684: LD_INT 12
120686: PUSH
120687: EMPTY
120688: LIST
120689: LIST
120690: PUSH
120691: LD_INT 34
120693: PUSH
120694: LD_INT 51
120696: PUSH
120697: EMPTY
120698: LIST
120699: LIST
120700: PUSH
120701: LD_INT 34
120703: PUSH
120704: LD_INT 32
120706: PUSH
120707: EMPTY
120708: LIST
120709: LIST
120710: PUSH
120711: EMPTY
120712: LIST
120713: LIST
120714: LIST
120715: LIST
120716: PUSH
120717: EMPTY
120718: LIST
120719: LIST
120720: LIST
120721: PPUSH
120722: CALL_OW 69
120726: ST_TO_ADDR
// if not tmp then
120727: LD_VAR 0 2
120731: NOT
120732: IFFALSE 120736
// exit ;
120734: GO 120786
// for i in tmp do
120736: LD_ADDR_VAR 0 1
120740: PUSH
120741: LD_VAR 0 2
120745: PUSH
120746: FOR_IN
120747: IFFALSE 120784
// if GetCargo ( i , mat_artifact ) = 0 then
120749: LD_VAR 0 1
120753: PPUSH
120754: LD_INT 4
120756: PPUSH
120757: CALL_OW 289
120761: PUSH
120762: LD_INT 0
120764: EQUAL
120765: IFFALSE 120782
// SetCargo ( i , mat_siberit , 100 ) ;
120767: LD_VAR 0 1
120771: PPUSH
120772: LD_INT 3
120774: PPUSH
120775: LD_INT 100
120777: PPUSH
120778: CALL_OW 290
120782: GO 120746
120784: POP
120785: POP
// end ;
120786: PPOPN 2
120788: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
120789: LD_EXP 146
120793: PUSH
120794: LD_EXP 191
120798: AND
120799: IFFALSE 120982
120801: GO 120803
120803: DISABLE
120804: LD_INT 0
120806: PPUSH
120807: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120808: LD_ADDR_VAR 0 2
120812: PUSH
120813: LD_INT 22
120815: PUSH
120816: LD_OWVAR 2
120820: PUSH
120821: EMPTY
120822: LIST
120823: LIST
120824: PPUSH
120825: CALL_OW 69
120829: ST_TO_ADDR
// if not tmp then
120830: LD_VAR 0 2
120834: NOT
120835: IFFALSE 120839
// exit ;
120837: GO 120982
// for i := 1 to 2 do
120839: LD_ADDR_VAR 0 1
120843: PUSH
120844: DOUBLE
120845: LD_INT 1
120847: DEC
120848: ST_TO_ADDR
120849: LD_INT 2
120851: PUSH
120852: FOR_TO
120853: IFFALSE 120980
// begin uc_side := your_side ;
120855: LD_ADDR_OWVAR 20
120859: PUSH
120860: LD_OWVAR 2
120864: ST_TO_ADDR
// uc_nation := nation_american ;
120865: LD_ADDR_OWVAR 21
120869: PUSH
120870: LD_INT 1
120872: ST_TO_ADDR
// vc_chassis := us_morphling ;
120873: LD_ADDR_OWVAR 37
120877: PUSH
120878: LD_INT 5
120880: ST_TO_ADDR
// vc_engine := engine_siberite ;
120881: LD_ADDR_OWVAR 39
120885: PUSH
120886: LD_INT 3
120888: ST_TO_ADDR
// vc_control := control_computer ;
120889: LD_ADDR_OWVAR 38
120893: PUSH
120894: LD_INT 3
120896: ST_TO_ADDR
// vc_weapon := us_double_laser ;
120897: LD_ADDR_OWVAR 40
120901: PUSH
120902: LD_INT 10
120904: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
120905: LD_VAR 0 2
120909: PUSH
120910: LD_INT 1
120912: ARRAY
120913: PPUSH
120914: CALL_OW 310
120918: NOT
120919: IFFALSE 120966
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
120921: CALL_OW 45
120925: PPUSH
120926: LD_VAR 0 2
120930: PUSH
120931: LD_INT 1
120933: ARRAY
120934: PPUSH
120935: CALL_OW 250
120939: PPUSH
120940: LD_VAR 0 2
120944: PUSH
120945: LD_INT 1
120947: ARRAY
120948: PPUSH
120949: CALL_OW 251
120953: PPUSH
120954: LD_INT 12
120956: PPUSH
120957: LD_INT 1
120959: PPUSH
120960: CALL_OW 50
120964: GO 120978
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
120966: CALL_OW 45
120970: PPUSH
120971: LD_INT 1
120973: PPUSH
120974: CALL_OW 51
// end ;
120978: GO 120852
120980: POP
120981: POP
// end ;
120982: PPOPN 2
120984: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
120985: LD_EXP 146
120989: PUSH
120990: LD_EXP 192
120994: AND
120995: IFFALSE 121217
120997: GO 120999
120999: DISABLE
121000: LD_INT 0
121002: PPUSH
121003: PPUSH
121004: PPUSH
121005: PPUSH
121006: PPUSH
121007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121008: LD_ADDR_VAR 0 6
121012: PUSH
121013: LD_INT 22
121015: PUSH
121016: LD_OWVAR 2
121020: PUSH
121021: EMPTY
121022: LIST
121023: LIST
121024: PUSH
121025: LD_INT 21
121027: PUSH
121028: LD_INT 1
121030: PUSH
121031: EMPTY
121032: LIST
121033: LIST
121034: PUSH
121035: LD_INT 3
121037: PUSH
121038: LD_INT 23
121040: PUSH
121041: LD_INT 0
121043: PUSH
121044: EMPTY
121045: LIST
121046: LIST
121047: PUSH
121048: EMPTY
121049: LIST
121050: LIST
121051: PUSH
121052: EMPTY
121053: LIST
121054: LIST
121055: LIST
121056: PPUSH
121057: CALL_OW 69
121061: ST_TO_ADDR
// if not tmp then
121062: LD_VAR 0 6
121066: NOT
121067: IFFALSE 121071
// exit ;
121069: GO 121217
// s1 := rand ( 1 , 4 ) ;
121071: LD_ADDR_VAR 0 2
121075: PUSH
121076: LD_INT 1
121078: PPUSH
121079: LD_INT 4
121081: PPUSH
121082: CALL_OW 12
121086: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
121087: LD_ADDR_VAR 0 4
121091: PUSH
121092: LD_VAR 0 6
121096: PUSH
121097: LD_INT 1
121099: ARRAY
121100: PPUSH
121101: LD_VAR 0 2
121105: PPUSH
121106: CALL_OW 259
121110: ST_TO_ADDR
// if s1 = 1 then
121111: LD_VAR 0 2
121115: PUSH
121116: LD_INT 1
121118: EQUAL
121119: IFFALSE 121139
// s2 := rand ( 2 , 4 ) else
121121: LD_ADDR_VAR 0 3
121125: PUSH
121126: LD_INT 2
121128: PPUSH
121129: LD_INT 4
121131: PPUSH
121132: CALL_OW 12
121136: ST_TO_ADDR
121137: GO 121147
// s2 := 1 ;
121139: LD_ADDR_VAR 0 3
121143: PUSH
121144: LD_INT 1
121146: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
121147: LD_ADDR_VAR 0 5
121151: PUSH
121152: LD_VAR 0 6
121156: PUSH
121157: LD_INT 1
121159: ARRAY
121160: PPUSH
121161: LD_VAR 0 3
121165: PPUSH
121166: CALL_OW 259
121170: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
121171: LD_VAR 0 6
121175: PUSH
121176: LD_INT 1
121178: ARRAY
121179: PPUSH
121180: LD_VAR 0 2
121184: PPUSH
121185: LD_VAR 0 5
121189: PPUSH
121190: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
121194: LD_VAR 0 6
121198: PUSH
121199: LD_INT 1
121201: ARRAY
121202: PPUSH
121203: LD_VAR 0 3
121207: PPUSH
121208: LD_VAR 0 4
121212: PPUSH
121213: CALL_OW 237
// end ;
121217: PPOPN 6
121219: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
121220: LD_EXP 146
121224: PUSH
121225: LD_EXP 193
121229: AND
121230: IFFALSE 121309
121232: GO 121234
121234: DISABLE
121235: LD_INT 0
121237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
121238: LD_ADDR_VAR 0 1
121242: PUSH
121243: LD_INT 22
121245: PUSH
121246: LD_OWVAR 2
121250: PUSH
121251: EMPTY
121252: LIST
121253: LIST
121254: PUSH
121255: LD_INT 30
121257: PUSH
121258: LD_INT 3
121260: PUSH
121261: EMPTY
121262: LIST
121263: LIST
121264: PUSH
121265: EMPTY
121266: LIST
121267: LIST
121268: PPUSH
121269: CALL_OW 69
121273: ST_TO_ADDR
// if not tmp then
121274: LD_VAR 0 1
121278: NOT
121279: IFFALSE 121283
// exit ;
121281: GO 121309
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
121283: LD_VAR 0 1
121287: PUSH
121288: LD_INT 1
121290: PPUSH
121291: LD_VAR 0 1
121295: PPUSH
121296: CALL_OW 12
121300: ARRAY
121301: PPUSH
121302: LD_INT 1
121304: PPUSH
121305: CALL_OW 234
// end ;
121309: PPOPN 1
121311: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
121312: LD_EXP 146
121316: PUSH
121317: LD_EXP 194
121321: AND
121322: IFFALSE 121434
121324: GO 121326
121326: DISABLE
121327: LD_INT 0
121329: PPUSH
121330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
121331: LD_ADDR_VAR 0 2
121335: PUSH
121336: LD_INT 22
121338: PUSH
121339: LD_OWVAR 2
121343: PUSH
121344: EMPTY
121345: LIST
121346: LIST
121347: PUSH
121348: LD_INT 2
121350: PUSH
121351: LD_INT 30
121353: PUSH
121354: LD_INT 27
121356: PUSH
121357: EMPTY
121358: LIST
121359: LIST
121360: PUSH
121361: LD_INT 30
121363: PUSH
121364: LD_INT 26
121366: PUSH
121367: EMPTY
121368: LIST
121369: LIST
121370: PUSH
121371: LD_INT 30
121373: PUSH
121374: LD_INT 28
121376: PUSH
121377: EMPTY
121378: LIST
121379: LIST
121380: PUSH
121381: EMPTY
121382: LIST
121383: LIST
121384: LIST
121385: LIST
121386: PUSH
121387: EMPTY
121388: LIST
121389: LIST
121390: PPUSH
121391: CALL_OW 69
121395: ST_TO_ADDR
// if not tmp then
121396: LD_VAR 0 2
121400: NOT
121401: IFFALSE 121405
// exit ;
121403: GO 121434
// for i in tmp do
121405: LD_ADDR_VAR 0 1
121409: PUSH
121410: LD_VAR 0 2
121414: PUSH
121415: FOR_IN
121416: IFFALSE 121432
// SetLives ( i , 1 ) ;
121418: LD_VAR 0 1
121422: PPUSH
121423: LD_INT 1
121425: PPUSH
121426: CALL_OW 234
121430: GO 121415
121432: POP
121433: POP
// end ;
121434: PPOPN 2
121436: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
121437: LD_EXP 146
121441: PUSH
121442: LD_EXP 195
121446: AND
121447: IFFALSE 121734
121449: GO 121451
121451: DISABLE
121452: LD_INT 0
121454: PPUSH
121455: PPUSH
121456: PPUSH
// begin i := rand ( 1 , 7 ) ;
121457: LD_ADDR_VAR 0 1
121461: PUSH
121462: LD_INT 1
121464: PPUSH
121465: LD_INT 7
121467: PPUSH
121468: CALL_OW 12
121472: ST_TO_ADDR
// case i of 1 :
121473: LD_VAR 0 1
121477: PUSH
121478: LD_INT 1
121480: DOUBLE
121481: EQUAL
121482: IFTRUE 121486
121484: GO 121496
121486: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
121487: LD_STRING earthquake(getX(game), 0, 32)
121489: PPUSH
121490: CALL_OW 559
121494: GO 121734
121496: LD_INT 2
121498: DOUBLE
121499: EQUAL
121500: IFTRUE 121504
121502: GO 121518
121504: POP
// begin ToLua ( displayStucuk(); ) ;
121505: LD_STRING displayStucuk();
121507: PPUSH
121508: CALL_OW 559
// ResetFog ;
121512: CALL_OW 335
// end ; 3 :
121516: GO 121734
121518: LD_INT 3
121520: DOUBLE
121521: EQUAL
121522: IFTRUE 121526
121524: GO 121630
121526: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121527: LD_ADDR_VAR 0 2
121531: PUSH
121532: LD_INT 22
121534: PUSH
121535: LD_OWVAR 2
121539: PUSH
121540: EMPTY
121541: LIST
121542: LIST
121543: PUSH
121544: LD_INT 25
121546: PUSH
121547: LD_INT 1
121549: PUSH
121550: EMPTY
121551: LIST
121552: LIST
121553: PUSH
121554: EMPTY
121555: LIST
121556: LIST
121557: PPUSH
121558: CALL_OW 69
121562: ST_TO_ADDR
// if not tmp then
121563: LD_VAR 0 2
121567: NOT
121568: IFFALSE 121572
// exit ;
121570: GO 121734
// un := tmp [ rand ( 1 , tmp ) ] ;
121572: LD_ADDR_VAR 0 3
121576: PUSH
121577: LD_VAR 0 2
121581: PUSH
121582: LD_INT 1
121584: PPUSH
121585: LD_VAR 0 2
121589: PPUSH
121590: CALL_OW 12
121594: ARRAY
121595: ST_TO_ADDR
// if Crawls ( un ) then
121596: LD_VAR 0 3
121600: PPUSH
121601: CALL_OW 318
121605: IFFALSE 121616
// ComWalk ( un ) ;
121607: LD_VAR 0 3
121611: PPUSH
121612: CALL_OW 138
// SetClass ( un , class_mortar ) ;
121616: LD_VAR 0 3
121620: PPUSH
121621: LD_INT 8
121623: PPUSH
121624: CALL_OW 336
// end ; 4 :
121628: GO 121734
121630: LD_INT 4
121632: DOUBLE
121633: EQUAL
121634: IFTRUE 121638
121636: GO 121712
121638: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
121639: LD_ADDR_VAR 0 2
121643: PUSH
121644: LD_INT 22
121646: PUSH
121647: LD_OWVAR 2
121651: PUSH
121652: EMPTY
121653: LIST
121654: LIST
121655: PUSH
121656: LD_INT 30
121658: PUSH
121659: LD_INT 29
121661: PUSH
121662: EMPTY
121663: LIST
121664: LIST
121665: PUSH
121666: EMPTY
121667: LIST
121668: LIST
121669: PPUSH
121670: CALL_OW 69
121674: ST_TO_ADDR
// if not tmp then
121675: LD_VAR 0 2
121679: NOT
121680: IFFALSE 121684
// exit ;
121682: GO 121734
// CenterNowOnUnits ( tmp [ 1 ] ) ;
121684: LD_VAR 0 2
121688: PUSH
121689: LD_INT 1
121691: ARRAY
121692: PPUSH
121693: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
121697: LD_VAR 0 2
121701: PUSH
121702: LD_INT 1
121704: ARRAY
121705: PPUSH
121706: CALL_OW 65
// end ; 5 .. 7 :
121710: GO 121734
121712: LD_INT 5
121714: DOUBLE
121715: GREATEREQUAL
121716: IFFALSE 121724
121718: LD_INT 7
121720: DOUBLE
121721: LESSEQUAL
121722: IFTRUE 121726
121724: GO 121733
121726: POP
// StreamSibBomb ; end ;
121727: CALL 117971 0 0
121731: GO 121734
121733: POP
// end ;
121734: PPOPN 3
121736: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
121737: LD_EXP 146
121741: PUSH
121742: LD_EXP 196
121746: AND
121747: IFFALSE 121903
121749: GO 121751
121751: DISABLE
121752: LD_INT 0
121754: PPUSH
121755: PPUSH
121756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
121757: LD_ADDR_VAR 0 2
121761: PUSH
121762: LD_INT 81
121764: PUSH
121765: LD_OWVAR 2
121769: PUSH
121770: EMPTY
121771: LIST
121772: LIST
121773: PUSH
121774: LD_INT 2
121776: PUSH
121777: LD_INT 21
121779: PUSH
121780: LD_INT 1
121782: PUSH
121783: EMPTY
121784: LIST
121785: LIST
121786: PUSH
121787: LD_INT 21
121789: PUSH
121790: LD_INT 2
121792: PUSH
121793: EMPTY
121794: LIST
121795: LIST
121796: PUSH
121797: EMPTY
121798: LIST
121799: LIST
121800: LIST
121801: PUSH
121802: EMPTY
121803: LIST
121804: LIST
121805: PPUSH
121806: CALL_OW 69
121810: ST_TO_ADDR
// if not tmp then
121811: LD_VAR 0 2
121815: NOT
121816: IFFALSE 121820
// exit ;
121818: GO 121903
// p := 0 ;
121820: LD_ADDR_VAR 0 3
121824: PUSH
121825: LD_INT 0
121827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121828: LD_INT 35
121830: PPUSH
121831: CALL_OW 67
// p := p + 1 ;
121835: LD_ADDR_VAR 0 3
121839: PUSH
121840: LD_VAR 0 3
121844: PUSH
121845: LD_INT 1
121847: PLUS
121848: ST_TO_ADDR
// for i in tmp do
121849: LD_ADDR_VAR 0 1
121853: PUSH
121854: LD_VAR 0 2
121858: PUSH
121859: FOR_IN
121860: IFFALSE 121891
// if GetLives ( i ) < 1000 then
121862: LD_VAR 0 1
121866: PPUSH
121867: CALL_OW 256
121871: PUSH
121872: LD_INT 1000
121874: LESS
121875: IFFALSE 121889
// SetLives ( i , 1000 ) ;
121877: LD_VAR 0 1
121881: PPUSH
121882: LD_INT 1000
121884: PPUSH
121885: CALL_OW 234
121889: GO 121859
121891: POP
121892: POP
// until p > 20 ;
121893: LD_VAR 0 3
121897: PUSH
121898: LD_INT 20
121900: GREATER
121901: IFFALSE 121828
// end ;
121903: PPOPN 3
121905: END
// every 0 0$1 trigger StreamModeActive and sTime do
121906: LD_EXP 146
121910: PUSH
121911: LD_EXP 197
121915: AND
121916: IFFALSE 121951
121918: GO 121920
121920: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
121921: LD_INT 28
121923: PPUSH
121924: LD_OWVAR 2
121928: PPUSH
121929: LD_INT 2
121931: PPUSH
121932: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
121936: LD_INT 30
121938: PPUSH
121939: LD_OWVAR 2
121943: PPUSH
121944: LD_INT 2
121946: PPUSH
121947: CALL_OW 322
// end ;
121951: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
121952: LD_EXP 146
121956: PUSH
121957: LD_EXP 198
121961: AND
121962: IFFALSE 122083
121964: GO 121966
121966: DISABLE
121967: LD_INT 0
121969: PPUSH
121970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121971: LD_ADDR_VAR 0 2
121975: PUSH
121976: LD_INT 22
121978: PUSH
121979: LD_OWVAR 2
121983: PUSH
121984: EMPTY
121985: LIST
121986: LIST
121987: PUSH
121988: LD_INT 21
121990: PUSH
121991: LD_INT 1
121993: PUSH
121994: EMPTY
121995: LIST
121996: LIST
121997: PUSH
121998: LD_INT 3
122000: PUSH
122001: LD_INT 23
122003: PUSH
122004: LD_INT 0
122006: PUSH
122007: EMPTY
122008: LIST
122009: LIST
122010: PUSH
122011: EMPTY
122012: LIST
122013: LIST
122014: PUSH
122015: EMPTY
122016: LIST
122017: LIST
122018: LIST
122019: PPUSH
122020: CALL_OW 69
122024: ST_TO_ADDR
// if not tmp then
122025: LD_VAR 0 2
122029: NOT
122030: IFFALSE 122034
// exit ;
122032: GO 122083
// for i in tmp do
122034: LD_ADDR_VAR 0 1
122038: PUSH
122039: LD_VAR 0 2
122043: PUSH
122044: FOR_IN
122045: IFFALSE 122081
// begin if Crawls ( i ) then
122047: LD_VAR 0 1
122051: PPUSH
122052: CALL_OW 318
122056: IFFALSE 122067
// ComWalk ( i ) ;
122058: LD_VAR 0 1
122062: PPUSH
122063: CALL_OW 138
// SetClass ( i , 2 ) ;
122067: LD_VAR 0 1
122071: PPUSH
122072: LD_INT 2
122074: PPUSH
122075: CALL_OW 336
// end ;
122079: GO 122044
122081: POP
122082: POP
// end ;
122083: PPOPN 2
122085: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
122086: LD_EXP 146
122090: PUSH
122091: LD_EXP 199
122095: AND
122096: IFFALSE 122384
122098: GO 122100
122100: DISABLE
122101: LD_INT 0
122103: PPUSH
122104: PPUSH
122105: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
122106: LD_OWVAR 2
122110: PPUSH
122111: LD_INT 9
122113: PPUSH
122114: LD_INT 1
122116: PPUSH
122117: LD_INT 1
122119: PPUSH
122120: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
122124: LD_INT 9
122126: PPUSH
122127: LD_OWVAR 2
122131: PPUSH
122132: CALL_OW 343
// uc_side := 9 ;
122136: LD_ADDR_OWVAR 20
122140: PUSH
122141: LD_INT 9
122143: ST_TO_ADDR
// uc_nation := 2 ;
122144: LD_ADDR_OWVAR 21
122148: PUSH
122149: LD_INT 2
122151: ST_TO_ADDR
// hc_name := Dark Warrior ;
122152: LD_ADDR_OWVAR 26
122156: PUSH
122157: LD_STRING Dark Warrior
122159: ST_TO_ADDR
// hc_gallery :=  ;
122160: LD_ADDR_OWVAR 33
122164: PUSH
122165: LD_STRING 
122167: ST_TO_ADDR
// hc_noskilllimit := true ;
122168: LD_ADDR_OWVAR 76
122172: PUSH
122173: LD_INT 1
122175: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
122176: LD_ADDR_OWVAR 31
122180: PUSH
122181: LD_INT 30
122183: PUSH
122184: LD_INT 30
122186: PUSH
122187: LD_INT 30
122189: PUSH
122190: LD_INT 30
122192: PUSH
122193: EMPTY
122194: LIST
122195: LIST
122196: LIST
122197: LIST
122198: ST_TO_ADDR
// un := CreateHuman ;
122199: LD_ADDR_VAR 0 3
122203: PUSH
122204: CALL_OW 44
122208: ST_TO_ADDR
// hc_noskilllimit := false ;
122209: LD_ADDR_OWVAR 76
122213: PUSH
122214: LD_INT 0
122216: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122217: LD_VAR 0 3
122221: PPUSH
122222: LD_INT 1
122224: PPUSH
122225: CALL_OW 51
// ToLua ( playRanger() ) ;
122229: LD_STRING playRanger()
122231: PPUSH
122232: CALL_OW 559
// p := 0 ;
122236: LD_ADDR_VAR 0 2
122240: PUSH
122241: LD_INT 0
122243: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
122244: LD_INT 35
122246: PPUSH
122247: CALL_OW 67
// p := p + 1 ;
122251: LD_ADDR_VAR 0 2
122255: PUSH
122256: LD_VAR 0 2
122260: PUSH
122261: LD_INT 1
122263: PLUS
122264: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
122265: LD_VAR 0 3
122269: PPUSH
122270: CALL_OW 256
122274: PUSH
122275: LD_INT 1000
122277: LESS
122278: IFFALSE 122292
// SetLives ( un , 1000 ) ;
122280: LD_VAR 0 3
122284: PPUSH
122285: LD_INT 1000
122287: PPUSH
122288: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
122292: LD_VAR 0 3
122296: PPUSH
122297: LD_INT 81
122299: PUSH
122300: LD_OWVAR 2
122304: PUSH
122305: EMPTY
122306: LIST
122307: LIST
122308: PUSH
122309: LD_INT 91
122311: PUSH
122312: LD_VAR 0 3
122316: PUSH
122317: LD_INT 30
122319: PUSH
122320: EMPTY
122321: LIST
122322: LIST
122323: LIST
122324: PUSH
122325: EMPTY
122326: LIST
122327: LIST
122328: PPUSH
122329: CALL_OW 69
122333: PPUSH
122334: LD_VAR 0 3
122338: PPUSH
122339: CALL_OW 74
122343: PPUSH
122344: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
122348: LD_VAR 0 2
122352: PUSH
122353: LD_INT 80
122355: GREATER
122356: PUSH
122357: LD_VAR 0 3
122361: PPUSH
122362: CALL_OW 301
122366: OR
122367: IFFALSE 122244
// if un then
122369: LD_VAR 0 3
122373: IFFALSE 122384
// RemoveUnit ( un ) ;
122375: LD_VAR 0 3
122379: PPUSH
122380: CALL_OW 64
// end ;
122384: PPOPN 3
122386: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
122387: LD_EXP 200
122391: IFFALSE 122507
122393: GO 122395
122395: DISABLE
122396: LD_INT 0
122398: PPUSH
122399: PPUSH
122400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
122401: LD_ADDR_VAR 0 2
122405: PUSH
122406: LD_INT 81
122408: PUSH
122409: LD_OWVAR 2
122413: PUSH
122414: EMPTY
122415: LIST
122416: LIST
122417: PUSH
122418: LD_INT 21
122420: PUSH
122421: LD_INT 1
122423: PUSH
122424: EMPTY
122425: LIST
122426: LIST
122427: PUSH
122428: EMPTY
122429: LIST
122430: LIST
122431: PPUSH
122432: CALL_OW 69
122436: ST_TO_ADDR
// ToLua ( playComputer() ) ;
122437: LD_STRING playComputer()
122439: PPUSH
122440: CALL_OW 559
// if not tmp then
122444: LD_VAR 0 2
122448: NOT
122449: IFFALSE 122453
// exit ;
122451: GO 122507
// for i in tmp do
122453: LD_ADDR_VAR 0 1
122457: PUSH
122458: LD_VAR 0 2
122462: PUSH
122463: FOR_IN
122464: IFFALSE 122505
// for j := 1 to 4 do
122466: LD_ADDR_VAR 0 3
122470: PUSH
122471: DOUBLE
122472: LD_INT 1
122474: DEC
122475: ST_TO_ADDR
122476: LD_INT 4
122478: PUSH
122479: FOR_TO
122480: IFFALSE 122501
// SetSkill ( i , j , 10 ) ;
122482: LD_VAR 0 1
122486: PPUSH
122487: LD_VAR 0 3
122491: PPUSH
122492: LD_INT 10
122494: PPUSH
122495: CALL_OW 237
122499: GO 122479
122501: POP
122502: POP
122503: GO 122463
122505: POP
122506: POP
// end ;
122507: PPOPN 3
122509: END
// every 0 0$1 trigger s30 do var i , tmp ;
122510: LD_EXP 201
122514: IFFALSE 122583
122516: GO 122518
122518: DISABLE
122519: LD_INT 0
122521: PPUSH
122522: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122523: LD_ADDR_VAR 0 2
122527: PUSH
122528: LD_INT 22
122530: PUSH
122531: LD_OWVAR 2
122535: PUSH
122536: EMPTY
122537: LIST
122538: LIST
122539: PPUSH
122540: CALL_OW 69
122544: ST_TO_ADDR
// if not tmp then
122545: LD_VAR 0 2
122549: NOT
122550: IFFALSE 122554
// exit ;
122552: GO 122583
// for i in tmp do
122554: LD_ADDR_VAR 0 1
122558: PUSH
122559: LD_VAR 0 2
122563: PUSH
122564: FOR_IN
122565: IFFALSE 122581
// SetLives ( i , 300 ) ;
122567: LD_VAR 0 1
122571: PPUSH
122572: LD_INT 300
122574: PPUSH
122575: CALL_OW 234
122579: GO 122564
122581: POP
122582: POP
// end ;
122583: PPOPN 2
122585: END
// every 0 0$1 trigger s60 do var i , tmp ;
122586: LD_EXP 202
122590: IFFALSE 122659
122592: GO 122594
122594: DISABLE
122595: LD_INT 0
122597: PPUSH
122598: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122599: LD_ADDR_VAR 0 2
122603: PUSH
122604: LD_INT 22
122606: PUSH
122607: LD_OWVAR 2
122611: PUSH
122612: EMPTY
122613: LIST
122614: LIST
122615: PPUSH
122616: CALL_OW 69
122620: ST_TO_ADDR
// if not tmp then
122621: LD_VAR 0 2
122625: NOT
122626: IFFALSE 122630
// exit ;
122628: GO 122659
// for i in tmp do
122630: LD_ADDR_VAR 0 1
122634: PUSH
122635: LD_VAR 0 2
122639: PUSH
122640: FOR_IN
122641: IFFALSE 122657
// SetLives ( i , 600 ) ;
122643: LD_VAR 0 1
122647: PPUSH
122648: LD_INT 600
122650: PPUSH
122651: CALL_OW 234
122655: GO 122640
122657: POP
122658: POP
// end ;
122659: PPOPN 2
122661: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
122662: LD_INT 0
122664: PPUSH
// case cmd of 301 :
122665: LD_VAR 0 1
122669: PUSH
122670: LD_INT 301
122672: DOUBLE
122673: EQUAL
122674: IFTRUE 122678
122676: GO 122710
122678: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
122679: LD_VAR 0 6
122683: PPUSH
122684: LD_VAR 0 7
122688: PPUSH
122689: LD_VAR 0 8
122693: PPUSH
122694: LD_VAR 0 4
122698: PPUSH
122699: LD_VAR 0 5
122703: PPUSH
122704: CALL 123919 0 5
122708: GO 122831
122710: LD_INT 302
122712: DOUBLE
122713: EQUAL
122714: IFTRUE 122718
122716: GO 122755
122718: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
122719: LD_VAR 0 6
122723: PPUSH
122724: LD_VAR 0 7
122728: PPUSH
122729: LD_VAR 0 8
122733: PPUSH
122734: LD_VAR 0 9
122738: PPUSH
122739: LD_VAR 0 4
122743: PPUSH
122744: LD_VAR 0 5
122748: PPUSH
122749: CALL 124010 0 6
122753: GO 122831
122755: LD_INT 303
122757: DOUBLE
122758: EQUAL
122759: IFTRUE 122763
122761: GO 122800
122763: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
122764: LD_VAR 0 6
122768: PPUSH
122769: LD_VAR 0 7
122773: PPUSH
122774: LD_VAR 0 8
122778: PPUSH
122779: LD_VAR 0 9
122783: PPUSH
122784: LD_VAR 0 4
122788: PPUSH
122789: LD_VAR 0 5
122793: PPUSH
122794: CALL 122836 0 6
122798: GO 122831
122800: LD_INT 304
122802: DOUBLE
122803: EQUAL
122804: IFTRUE 122808
122806: GO 122830
122808: POP
// hHackTeleport ( unit , x , y ) ; end ;
122809: LD_VAR 0 2
122813: PPUSH
122814: LD_VAR 0 4
122818: PPUSH
122819: LD_VAR 0 5
122823: PPUSH
122824: CALL 124603 0 3
122828: GO 122831
122830: POP
// end ;
122831: LD_VAR 0 12
122835: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
122836: LD_INT 0
122838: PPUSH
122839: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
122840: LD_VAR 0 1
122844: PUSH
122845: LD_INT 1
122847: LESS
122848: PUSH
122849: LD_VAR 0 1
122853: PUSH
122854: LD_INT 3
122856: GREATER
122857: OR
122858: PUSH
122859: LD_VAR 0 5
122863: PPUSH
122864: LD_VAR 0 6
122868: PPUSH
122869: CALL_OW 428
122873: OR
122874: IFFALSE 122878
// exit ;
122876: GO 123606
// uc_side := your_side ;
122878: LD_ADDR_OWVAR 20
122882: PUSH
122883: LD_OWVAR 2
122887: ST_TO_ADDR
// uc_nation := nation ;
122888: LD_ADDR_OWVAR 21
122892: PUSH
122893: LD_VAR 0 1
122897: ST_TO_ADDR
// bc_level = 1 ;
122898: LD_ADDR_OWVAR 43
122902: PUSH
122903: LD_INT 1
122905: ST_TO_ADDR
// case btype of 1 :
122906: LD_VAR 0 2
122910: PUSH
122911: LD_INT 1
122913: DOUBLE
122914: EQUAL
122915: IFTRUE 122919
122917: GO 122930
122919: POP
// bc_type := b_depot ; 2 :
122920: LD_ADDR_OWVAR 42
122924: PUSH
122925: LD_INT 0
122927: ST_TO_ADDR
122928: GO 123550
122930: LD_INT 2
122932: DOUBLE
122933: EQUAL
122934: IFTRUE 122938
122936: GO 122949
122938: POP
// bc_type := b_warehouse ; 3 :
122939: LD_ADDR_OWVAR 42
122943: PUSH
122944: LD_INT 1
122946: ST_TO_ADDR
122947: GO 123550
122949: LD_INT 3
122951: DOUBLE
122952: EQUAL
122953: IFTRUE 122957
122955: GO 122968
122957: POP
// bc_type := b_lab ; 4 .. 9 :
122958: LD_ADDR_OWVAR 42
122962: PUSH
122963: LD_INT 6
122965: ST_TO_ADDR
122966: GO 123550
122968: LD_INT 4
122970: DOUBLE
122971: GREATEREQUAL
122972: IFFALSE 122980
122974: LD_INT 9
122976: DOUBLE
122977: LESSEQUAL
122978: IFTRUE 122982
122980: GO 123042
122982: POP
// begin bc_type := b_lab_half ;
122983: LD_ADDR_OWVAR 42
122987: PUSH
122988: LD_INT 7
122990: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
122991: LD_ADDR_OWVAR 44
122995: PUSH
122996: LD_INT 10
122998: PUSH
122999: LD_INT 11
123001: PUSH
123002: LD_INT 12
123004: PUSH
123005: LD_INT 15
123007: PUSH
123008: LD_INT 14
123010: PUSH
123011: LD_INT 13
123013: PUSH
123014: EMPTY
123015: LIST
123016: LIST
123017: LIST
123018: LIST
123019: LIST
123020: LIST
123021: PUSH
123022: LD_VAR 0 2
123026: PUSH
123027: LD_INT 3
123029: MINUS
123030: ARRAY
123031: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
123032: LD_ADDR_OWVAR 45
123036: PUSH
123037: LD_INT 9
123039: ST_TO_ADDR
// end ; 10 .. 13 :
123040: GO 123550
123042: LD_INT 10
123044: DOUBLE
123045: GREATEREQUAL
123046: IFFALSE 123054
123048: LD_INT 13
123050: DOUBLE
123051: LESSEQUAL
123052: IFTRUE 123056
123054: GO 123133
123056: POP
// begin bc_type := b_lab_full ;
123057: LD_ADDR_OWVAR 42
123061: PUSH
123062: LD_INT 8
123064: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
123065: LD_ADDR_OWVAR 44
123069: PUSH
123070: LD_INT 10
123072: PUSH
123073: LD_INT 12
123075: PUSH
123076: LD_INT 14
123078: PUSH
123079: LD_INT 13
123081: PUSH
123082: EMPTY
123083: LIST
123084: LIST
123085: LIST
123086: LIST
123087: PUSH
123088: LD_VAR 0 2
123092: PUSH
123093: LD_INT 9
123095: MINUS
123096: ARRAY
123097: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
123098: LD_ADDR_OWVAR 45
123102: PUSH
123103: LD_INT 11
123105: PUSH
123106: LD_INT 15
123108: PUSH
123109: LD_INT 12
123111: PUSH
123112: LD_INT 15
123114: PUSH
123115: EMPTY
123116: LIST
123117: LIST
123118: LIST
123119: LIST
123120: PUSH
123121: LD_VAR 0 2
123125: PUSH
123126: LD_INT 9
123128: MINUS
123129: ARRAY
123130: ST_TO_ADDR
// end ; 14 :
123131: GO 123550
123133: LD_INT 14
123135: DOUBLE
123136: EQUAL
123137: IFTRUE 123141
123139: GO 123152
123141: POP
// bc_type := b_workshop ; 15 :
123142: LD_ADDR_OWVAR 42
123146: PUSH
123147: LD_INT 2
123149: ST_TO_ADDR
123150: GO 123550
123152: LD_INT 15
123154: DOUBLE
123155: EQUAL
123156: IFTRUE 123160
123158: GO 123171
123160: POP
// bc_type := b_factory ; 16 :
123161: LD_ADDR_OWVAR 42
123165: PUSH
123166: LD_INT 3
123168: ST_TO_ADDR
123169: GO 123550
123171: LD_INT 16
123173: DOUBLE
123174: EQUAL
123175: IFTRUE 123179
123177: GO 123190
123179: POP
// bc_type := b_ext_gun ; 17 :
123180: LD_ADDR_OWVAR 42
123184: PUSH
123185: LD_INT 17
123187: ST_TO_ADDR
123188: GO 123550
123190: LD_INT 17
123192: DOUBLE
123193: EQUAL
123194: IFTRUE 123198
123196: GO 123226
123198: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
123199: LD_ADDR_OWVAR 42
123203: PUSH
123204: LD_INT 19
123206: PUSH
123207: LD_INT 23
123209: PUSH
123210: LD_INT 19
123212: PUSH
123213: EMPTY
123214: LIST
123215: LIST
123216: LIST
123217: PUSH
123218: LD_VAR 0 1
123222: ARRAY
123223: ST_TO_ADDR
123224: GO 123550
123226: LD_INT 18
123228: DOUBLE
123229: EQUAL
123230: IFTRUE 123234
123232: GO 123245
123234: POP
// bc_type := b_ext_radar ; 19 :
123235: LD_ADDR_OWVAR 42
123239: PUSH
123240: LD_INT 20
123242: ST_TO_ADDR
123243: GO 123550
123245: LD_INT 19
123247: DOUBLE
123248: EQUAL
123249: IFTRUE 123253
123251: GO 123264
123253: POP
// bc_type := b_ext_radio ; 20 :
123254: LD_ADDR_OWVAR 42
123258: PUSH
123259: LD_INT 22
123261: ST_TO_ADDR
123262: GO 123550
123264: LD_INT 20
123266: DOUBLE
123267: EQUAL
123268: IFTRUE 123272
123270: GO 123283
123272: POP
// bc_type := b_ext_siberium ; 21 :
123273: LD_ADDR_OWVAR 42
123277: PUSH
123278: LD_INT 21
123280: ST_TO_ADDR
123281: GO 123550
123283: LD_INT 21
123285: DOUBLE
123286: EQUAL
123287: IFTRUE 123291
123289: GO 123302
123291: POP
// bc_type := b_ext_computer ; 22 :
123292: LD_ADDR_OWVAR 42
123296: PUSH
123297: LD_INT 24
123299: ST_TO_ADDR
123300: GO 123550
123302: LD_INT 22
123304: DOUBLE
123305: EQUAL
123306: IFTRUE 123310
123308: GO 123321
123310: POP
// bc_type := b_ext_track ; 23 :
123311: LD_ADDR_OWVAR 42
123315: PUSH
123316: LD_INT 16
123318: ST_TO_ADDR
123319: GO 123550
123321: LD_INT 23
123323: DOUBLE
123324: EQUAL
123325: IFTRUE 123329
123327: GO 123340
123329: POP
// bc_type := b_ext_laser ; 24 :
123330: LD_ADDR_OWVAR 42
123334: PUSH
123335: LD_INT 25
123337: ST_TO_ADDR
123338: GO 123550
123340: LD_INT 24
123342: DOUBLE
123343: EQUAL
123344: IFTRUE 123348
123346: GO 123359
123348: POP
// bc_type := b_control_tower ; 25 :
123349: LD_ADDR_OWVAR 42
123353: PUSH
123354: LD_INT 36
123356: ST_TO_ADDR
123357: GO 123550
123359: LD_INT 25
123361: DOUBLE
123362: EQUAL
123363: IFTRUE 123367
123365: GO 123378
123367: POP
// bc_type := b_breastwork ; 26 :
123368: LD_ADDR_OWVAR 42
123372: PUSH
123373: LD_INT 31
123375: ST_TO_ADDR
123376: GO 123550
123378: LD_INT 26
123380: DOUBLE
123381: EQUAL
123382: IFTRUE 123386
123384: GO 123397
123386: POP
// bc_type := b_bunker ; 27 :
123387: LD_ADDR_OWVAR 42
123391: PUSH
123392: LD_INT 32
123394: ST_TO_ADDR
123395: GO 123550
123397: LD_INT 27
123399: DOUBLE
123400: EQUAL
123401: IFTRUE 123405
123403: GO 123416
123405: POP
// bc_type := b_turret ; 28 :
123406: LD_ADDR_OWVAR 42
123410: PUSH
123411: LD_INT 33
123413: ST_TO_ADDR
123414: GO 123550
123416: LD_INT 28
123418: DOUBLE
123419: EQUAL
123420: IFTRUE 123424
123422: GO 123435
123424: POP
// bc_type := b_armoury ; 29 :
123425: LD_ADDR_OWVAR 42
123429: PUSH
123430: LD_INT 4
123432: ST_TO_ADDR
123433: GO 123550
123435: LD_INT 29
123437: DOUBLE
123438: EQUAL
123439: IFTRUE 123443
123441: GO 123454
123443: POP
// bc_type := b_barracks ; 30 :
123444: LD_ADDR_OWVAR 42
123448: PUSH
123449: LD_INT 5
123451: ST_TO_ADDR
123452: GO 123550
123454: LD_INT 30
123456: DOUBLE
123457: EQUAL
123458: IFTRUE 123462
123460: GO 123473
123462: POP
// bc_type := b_solar_power ; 31 :
123463: LD_ADDR_OWVAR 42
123467: PUSH
123468: LD_INT 27
123470: ST_TO_ADDR
123471: GO 123550
123473: LD_INT 31
123475: DOUBLE
123476: EQUAL
123477: IFTRUE 123481
123479: GO 123492
123481: POP
// bc_type := b_oil_power ; 32 :
123482: LD_ADDR_OWVAR 42
123486: PUSH
123487: LD_INT 26
123489: ST_TO_ADDR
123490: GO 123550
123492: LD_INT 32
123494: DOUBLE
123495: EQUAL
123496: IFTRUE 123500
123498: GO 123511
123500: POP
// bc_type := b_siberite_power ; 33 :
123501: LD_ADDR_OWVAR 42
123505: PUSH
123506: LD_INT 28
123508: ST_TO_ADDR
123509: GO 123550
123511: LD_INT 33
123513: DOUBLE
123514: EQUAL
123515: IFTRUE 123519
123517: GO 123530
123519: POP
// bc_type := b_oil_mine ; 34 :
123520: LD_ADDR_OWVAR 42
123524: PUSH
123525: LD_INT 29
123527: ST_TO_ADDR
123528: GO 123550
123530: LD_INT 34
123532: DOUBLE
123533: EQUAL
123534: IFTRUE 123538
123536: GO 123549
123538: POP
// bc_type := b_siberite_mine ; end ;
123539: LD_ADDR_OWVAR 42
123543: PUSH
123544: LD_INT 30
123546: ST_TO_ADDR
123547: GO 123550
123549: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
123550: LD_ADDR_VAR 0 8
123554: PUSH
123555: LD_VAR 0 5
123559: PPUSH
123560: LD_VAR 0 6
123564: PPUSH
123565: LD_VAR 0 3
123569: PPUSH
123570: CALL_OW 47
123574: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
123575: LD_OWVAR 42
123579: PUSH
123580: LD_INT 32
123582: PUSH
123583: LD_INT 33
123585: PUSH
123586: EMPTY
123587: LIST
123588: LIST
123589: IN
123590: IFFALSE 123606
// PlaceWeaponTurret ( b , weapon ) ;
123592: LD_VAR 0 8
123596: PPUSH
123597: LD_VAR 0 4
123601: PPUSH
123602: CALL_OW 431
// end ;
123606: LD_VAR 0 7
123610: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
123611: LD_INT 0
123613: PPUSH
123614: PPUSH
123615: PPUSH
123616: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123617: LD_ADDR_VAR 0 4
123621: PUSH
123622: LD_INT 22
123624: PUSH
123625: LD_OWVAR 2
123629: PUSH
123630: EMPTY
123631: LIST
123632: LIST
123633: PUSH
123634: LD_INT 2
123636: PUSH
123637: LD_INT 30
123639: PUSH
123640: LD_INT 0
123642: PUSH
123643: EMPTY
123644: LIST
123645: LIST
123646: PUSH
123647: LD_INT 30
123649: PUSH
123650: LD_INT 1
123652: PUSH
123653: EMPTY
123654: LIST
123655: LIST
123656: PUSH
123657: EMPTY
123658: LIST
123659: LIST
123660: LIST
123661: PUSH
123662: EMPTY
123663: LIST
123664: LIST
123665: PPUSH
123666: CALL_OW 69
123670: ST_TO_ADDR
// if not tmp then
123671: LD_VAR 0 4
123675: NOT
123676: IFFALSE 123680
// exit ;
123678: GO 123739
// for i in tmp do
123680: LD_ADDR_VAR 0 2
123684: PUSH
123685: LD_VAR 0 4
123689: PUSH
123690: FOR_IN
123691: IFFALSE 123737
// for j = 1 to 3 do
123693: LD_ADDR_VAR 0 3
123697: PUSH
123698: DOUBLE
123699: LD_INT 1
123701: DEC
123702: ST_TO_ADDR
123703: LD_INT 3
123705: PUSH
123706: FOR_TO
123707: IFFALSE 123733
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
123709: LD_VAR 0 2
123713: PPUSH
123714: CALL_OW 274
123718: PPUSH
123719: LD_VAR 0 3
123723: PPUSH
123724: LD_INT 99999
123726: PPUSH
123727: CALL_OW 277
123731: GO 123706
123733: POP
123734: POP
123735: GO 123690
123737: POP
123738: POP
// end ;
123739: LD_VAR 0 1
123743: RET
// export function hHackSetLevel10 ; var i , j ; begin
123744: LD_INT 0
123746: PPUSH
123747: PPUSH
123748: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123749: LD_ADDR_VAR 0 2
123753: PUSH
123754: LD_INT 21
123756: PUSH
123757: LD_INT 1
123759: PUSH
123760: EMPTY
123761: LIST
123762: LIST
123763: PPUSH
123764: CALL_OW 69
123768: PUSH
123769: FOR_IN
123770: IFFALSE 123822
// if IsSelected ( i ) then
123772: LD_VAR 0 2
123776: PPUSH
123777: CALL_OW 306
123781: IFFALSE 123820
// begin for j := 1 to 4 do
123783: LD_ADDR_VAR 0 3
123787: PUSH
123788: DOUBLE
123789: LD_INT 1
123791: DEC
123792: ST_TO_ADDR
123793: LD_INT 4
123795: PUSH
123796: FOR_TO
123797: IFFALSE 123818
// SetSkill ( i , j , 10 ) ;
123799: LD_VAR 0 2
123803: PPUSH
123804: LD_VAR 0 3
123808: PPUSH
123809: LD_INT 10
123811: PPUSH
123812: CALL_OW 237
123816: GO 123796
123818: POP
123819: POP
// end ;
123820: GO 123769
123822: POP
123823: POP
// end ;
123824: LD_VAR 0 1
123828: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
123829: LD_INT 0
123831: PPUSH
123832: PPUSH
123833: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
123834: LD_ADDR_VAR 0 2
123838: PUSH
123839: LD_INT 22
123841: PUSH
123842: LD_OWVAR 2
123846: PUSH
123847: EMPTY
123848: LIST
123849: LIST
123850: PUSH
123851: LD_INT 21
123853: PUSH
123854: LD_INT 1
123856: PUSH
123857: EMPTY
123858: LIST
123859: LIST
123860: PUSH
123861: EMPTY
123862: LIST
123863: LIST
123864: PPUSH
123865: CALL_OW 69
123869: PUSH
123870: FOR_IN
123871: IFFALSE 123912
// begin for j := 1 to 4 do
123873: LD_ADDR_VAR 0 3
123877: PUSH
123878: DOUBLE
123879: LD_INT 1
123881: DEC
123882: ST_TO_ADDR
123883: LD_INT 4
123885: PUSH
123886: FOR_TO
123887: IFFALSE 123908
// SetSkill ( i , j , 10 ) ;
123889: LD_VAR 0 2
123893: PPUSH
123894: LD_VAR 0 3
123898: PPUSH
123899: LD_INT 10
123901: PPUSH
123902: CALL_OW 237
123906: GO 123886
123908: POP
123909: POP
// end ;
123910: GO 123870
123912: POP
123913: POP
// end ;
123914: LD_VAR 0 1
123918: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
123919: LD_INT 0
123921: PPUSH
// uc_side := your_side ;
123922: LD_ADDR_OWVAR 20
123926: PUSH
123927: LD_OWVAR 2
123931: ST_TO_ADDR
// uc_nation := nation ;
123932: LD_ADDR_OWVAR 21
123936: PUSH
123937: LD_VAR 0 1
123941: ST_TO_ADDR
// InitHc ;
123942: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
123946: LD_INT 0
123948: PPUSH
123949: LD_VAR 0 2
123953: PPUSH
123954: LD_VAR 0 3
123958: PPUSH
123959: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
123963: LD_VAR 0 4
123967: PPUSH
123968: LD_VAR 0 5
123972: PPUSH
123973: CALL_OW 428
123977: PUSH
123978: LD_INT 0
123980: EQUAL
123981: IFFALSE 124005
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
123983: CALL_OW 44
123987: PPUSH
123988: LD_VAR 0 4
123992: PPUSH
123993: LD_VAR 0 5
123997: PPUSH
123998: LD_INT 1
124000: PPUSH
124001: CALL_OW 48
// end ;
124005: LD_VAR 0 6
124009: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
124010: LD_INT 0
124012: PPUSH
124013: PPUSH
// uc_side := your_side ;
124014: LD_ADDR_OWVAR 20
124018: PUSH
124019: LD_OWVAR 2
124023: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
124024: LD_VAR 0 1
124028: PUSH
124029: LD_INT 1
124031: PUSH
124032: LD_INT 2
124034: PUSH
124035: LD_INT 3
124037: PUSH
124038: LD_INT 4
124040: PUSH
124041: LD_INT 5
124043: PUSH
124044: EMPTY
124045: LIST
124046: LIST
124047: LIST
124048: LIST
124049: LIST
124050: IN
124051: IFFALSE 124063
// uc_nation := nation_american else
124053: LD_ADDR_OWVAR 21
124057: PUSH
124058: LD_INT 1
124060: ST_TO_ADDR
124061: GO 124106
// if chassis in [ 11 , 12 , 13 , 14 ] then
124063: LD_VAR 0 1
124067: PUSH
124068: LD_INT 11
124070: PUSH
124071: LD_INT 12
124073: PUSH
124074: LD_INT 13
124076: PUSH
124077: LD_INT 14
124079: PUSH
124080: EMPTY
124081: LIST
124082: LIST
124083: LIST
124084: LIST
124085: IN
124086: IFFALSE 124098
// uc_nation := nation_arabian else
124088: LD_ADDR_OWVAR 21
124092: PUSH
124093: LD_INT 2
124095: ST_TO_ADDR
124096: GO 124106
// uc_nation := nation_russian ;
124098: LD_ADDR_OWVAR 21
124102: PUSH
124103: LD_INT 3
124105: ST_TO_ADDR
// vc_chassis := chassis ;
124106: LD_ADDR_OWVAR 37
124110: PUSH
124111: LD_VAR 0 1
124115: ST_TO_ADDR
// vc_engine := engine ;
124116: LD_ADDR_OWVAR 39
124120: PUSH
124121: LD_VAR 0 2
124125: ST_TO_ADDR
// vc_control := control ;
124126: LD_ADDR_OWVAR 38
124130: PUSH
124131: LD_VAR 0 3
124135: ST_TO_ADDR
// vc_weapon := weapon ;
124136: LD_ADDR_OWVAR 40
124140: PUSH
124141: LD_VAR 0 4
124145: ST_TO_ADDR
// un := CreateVehicle ;
124146: LD_ADDR_VAR 0 8
124150: PUSH
124151: CALL_OW 45
124155: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
124156: LD_VAR 0 8
124160: PPUSH
124161: LD_INT 0
124163: PPUSH
124164: LD_INT 5
124166: PPUSH
124167: CALL_OW 12
124171: PPUSH
124172: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
124176: LD_VAR 0 8
124180: PPUSH
124181: LD_VAR 0 5
124185: PPUSH
124186: LD_VAR 0 6
124190: PPUSH
124191: LD_INT 1
124193: PPUSH
124194: CALL_OW 48
// end ;
124198: LD_VAR 0 7
124202: RET
// export hInvincible ; every 1 do
124203: GO 124205
124205: DISABLE
// hInvincible := [ ] ;
124206: LD_ADDR_EXP 203
124210: PUSH
124211: EMPTY
124212: ST_TO_ADDR
124213: END
// every 10 do var i ;
124214: GO 124216
124216: DISABLE
124217: LD_INT 0
124219: PPUSH
// begin enable ;
124220: ENABLE
// if not hInvincible then
124221: LD_EXP 203
124225: NOT
124226: IFFALSE 124230
// exit ;
124228: GO 124274
// for i in hInvincible do
124230: LD_ADDR_VAR 0 1
124234: PUSH
124235: LD_EXP 203
124239: PUSH
124240: FOR_IN
124241: IFFALSE 124272
// if GetLives ( i ) < 1000 then
124243: LD_VAR 0 1
124247: PPUSH
124248: CALL_OW 256
124252: PUSH
124253: LD_INT 1000
124255: LESS
124256: IFFALSE 124270
// SetLives ( i , 1000 ) ;
124258: LD_VAR 0 1
124262: PPUSH
124263: LD_INT 1000
124265: PPUSH
124266: CALL_OW 234
124270: GO 124240
124272: POP
124273: POP
// end ;
124274: PPOPN 1
124276: END
// export function hHackInvincible ; var i ; begin
124277: LD_INT 0
124279: PPUSH
124280: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
124281: LD_ADDR_VAR 0 2
124285: PUSH
124286: LD_INT 2
124288: PUSH
124289: LD_INT 21
124291: PUSH
124292: LD_INT 1
124294: PUSH
124295: EMPTY
124296: LIST
124297: LIST
124298: PUSH
124299: LD_INT 21
124301: PUSH
124302: LD_INT 2
124304: PUSH
124305: EMPTY
124306: LIST
124307: LIST
124308: PUSH
124309: EMPTY
124310: LIST
124311: LIST
124312: LIST
124313: PPUSH
124314: CALL_OW 69
124318: PUSH
124319: FOR_IN
124320: IFFALSE 124381
// if IsSelected ( i ) then
124322: LD_VAR 0 2
124326: PPUSH
124327: CALL_OW 306
124331: IFFALSE 124379
// begin if i in hInvincible then
124333: LD_VAR 0 2
124337: PUSH
124338: LD_EXP 203
124342: IN
124343: IFFALSE 124363
// hInvincible := hInvincible diff i else
124345: LD_ADDR_EXP 203
124349: PUSH
124350: LD_EXP 203
124354: PUSH
124355: LD_VAR 0 2
124359: DIFF
124360: ST_TO_ADDR
124361: GO 124379
// hInvincible := hInvincible union i ;
124363: LD_ADDR_EXP 203
124367: PUSH
124368: LD_EXP 203
124372: PUSH
124373: LD_VAR 0 2
124377: UNION
124378: ST_TO_ADDR
// end ;
124379: GO 124319
124381: POP
124382: POP
// end ;
124383: LD_VAR 0 1
124387: RET
// export function hHackInvisible ; var i , j ; begin
124388: LD_INT 0
124390: PPUSH
124391: PPUSH
124392: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
124393: LD_ADDR_VAR 0 2
124397: PUSH
124398: LD_INT 21
124400: PUSH
124401: LD_INT 1
124403: PUSH
124404: EMPTY
124405: LIST
124406: LIST
124407: PPUSH
124408: CALL_OW 69
124412: PUSH
124413: FOR_IN
124414: IFFALSE 124438
// if IsSelected ( i ) then
124416: LD_VAR 0 2
124420: PPUSH
124421: CALL_OW 306
124425: IFFALSE 124436
// ComForceInvisible ( i ) ;
124427: LD_VAR 0 2
124431: PPUSH
124432: CALL_OW 496
124436: GO 124413
124438: POP
124439: POP
// end ;
124440: LD_VAR 0 1
124444: RET
// export function hHackChangeYourSide ; begin
124445: LD_INT 0
124447: PPUSH
// if your_side = 8 then
124448: LD_OWVAR 2
124452: PUSH
124453: LD_INT 8
124455: EQUAL
124456: IFFALSE 124468
// your_side := 0 else
124458: LD_ADDR_OWVAR 2
124462: PUSH
124463: LD_INT 0
124465: ST_TO_ADDR
124466: GO 124482
// your_side := your_side + 1 ;
124468: LD_ADDR_OWVAR 2
124472: PUSH
124473: LD_OWVAR 2
124477: PUSH
124478: LD_INT 1
124480: PLUS
124481: ST_TO_ADDR
// end ;
124482: LD_VAR 0 1
124486: RET
// export function hHackChangeUnitSide ; var i , j ; begin
124487: LD_INT 0
124489: PPUSH
124490: PPUSH
124491: PPUSH
// for i in all_units do
124492: LD_ADDR_VAR 0 2
124496: PUSH
124497: LD_OWVAR 3
124501: PUSH
124502: FOR_IN
124503: IFFALSE 124581
// if IsSelected ( i ) then
124505: LD_VAR 0 2
124509: PPUSH
124510: CALL_OW 306
124514: IFFALSE 124579
// begin j := GetSide ( i ) ;
124516: LD_ADDR_VAR 0 3
124520: PUSH
124521: LD_VAR 0 2
124525: PPUSH
124526: CALL_OW 255
124530: ST_TO_ADDR
// if j = 8 then
124531: LD_VAR 0 3
124535: PUSH
124536: LD_INT 8
124538: EQUAL
124539: IFFALSE 124551
// j := 0 else
124541: LD_ADDR_VAR 0 3
124545: PUSH
124546: LD_INT 0
124548: ST_TO_ADDR
124549: GO 124565
// j := j + 1 ;
124551: LD_ADDR_VAR 0 3
124555: PUSH
124556: LD_VAR 0 3
124560: PUSH
124561: LD_INT 1
124563: PLUS
124564: ST_TO_ADDR
// SetSide ( i , j ) ;
124565: LD_VAR 0 2
124569: PPUSH
124570: LD_VAR 0 3
124574: PPUSH
124575: CALL_OW 235
// end ;
124579: GO 124502
124581: POP
124582: POP
// end ;
124583: LD_VAR 0 1
124587: RET
// export function hHackFog ; begin
124588: LD_INT 0
124590: PPUSH
// FogOff ( true ) ;
124591: LD_INT 1
124593: PPUSH
124594: CALL_OW 344
// end ;
124598: LD_VAR 0 1
124602: RET
// export function hHackTeleport ( unit , x , y ) ; begin
124603: LD_INT 0
124605: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
124606: LD_VAR 0 1
124610: PPUSH
124611: LD_VAR 0 2
124615: PPUSH
124616: LD_VAR 0 3
124620: PPUSH
124621: LD_INT 1
124623: PPUSH
124624: LD_INT 1
124626: PPUSH
124627: CALL_OW 483
// CenterOnXY ( x , y ) ;
124631: LD_VAR 0 2
124635: PPUSH
124636: LD_VAR 0 3
124640: PPUSH
124641: CALL_OW 84
// end ;
124645: LD_VAR 0 4
124649: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
124650: LD_INT 0
124652: PPUSH
124653: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
124654: LD_VAR 0 1
124658: NOT
124659: PUSH
124660: LD_VAR 0 2
124664: PPUSH
124665: LD_VAR 0 3
124669: PPUSH
124670: CALL_OW 488
124674: NOT
124675: OR
124676: PUSH
124677: LD_VAR 0 1
124681: PPUSH
124682: CALL_OW 266
124686: PUSH
124687: LD_INT 3
124689: NONEQUAL
124690: PUSH
124691: LD_VAR 0 1
124695: PPUSH
124696: CALL_OW 247
124700: PUSH
124701: LD_INT 1
124703: EQUAL
124704: NOT
124705: AND
124706: OR
124707: IFFALSE 124711
// exit ;
124709: GO 124860
// if GetType ( factory ) = unit_human then
124711: LD_VAR 0 1
124715: PPUSH
124716: CALL_OW 247
124720: PUSH
124721: LD_INT 1
124723: EQUAL
124724: IFFALSE 124741
// factory := IsInUnit ( factory ) ;
124726: LD_ADDR_VAR 0 1
124730: PUSH
124731: LD_VAR 0 1
124735: PPUSH
124736: CALL_OW 310
124740: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
124741: LD_VAR 0 1
124745: PPUSH
124746: CALL_OW 266
124750: PUSH
124751: LD_INT 3
124753: NONEQUAL
124754: IFFALSE 124758
// exit ;
124756: GO 124860
// if HexInfo ( x , y ) = factory then
124758: LD_VAR 0 2
124762: PPUSH
124763: LD_VAR 0 3
124767: PPUSH
124768: CALL_OW 428
124772: PUSH
124773: LD_VAR 0 1
124777: EQUAL
124778: IFFALSE 124805
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
124780: LD_ADDR_EXP 204
124784: PUSH
124785: LD_EXP 204
124789: PPUSH
124790: LD_VAR 0 1
124794: PPUSH
124795: LD_INT 0
124797: PPUSH
124798: CALL_OW 1
124802: ST_TO_ADDR
124803: GO 124856
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
124805: LD_ADDR_EXP 204
124809: PUSH
124810: LD_EXP 204
124814: PPUSH
124815: LD_VAR 0 1
124819: PPUSH
124820: LD_VAR 0 1
124824: PPUSH
124825: CALL_OW 255
124829: PUSH
124830: LD_VAR 0 1
124834: PUSH
124835: LD_VAR 0 2
124839: PUSH
124840: LD_VAR 0 3
124844: PUSH
124845: EMPTY
124846: LIST
124847: LIST
124848: LIST
124849: LIST
124850: PPUSH
124851: CALL_OW 1
124855: ST_TO_ADDR
// UpdateFactoryWaypoints ;
124856: CALL 124865 0 0
// end ;
124860: LD_VAR 0 4
124864: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
124865: LD_INT 0
124867: PPUSH
124868: PPUSH
124869: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
124870: LD_STRING resetFactoryWaypoint();
124872: PPUSH
124873: CALL_OW 559
// if factoryWaypoints then
124877: LD_EXP 204
124881: IFFALSE 125007
// begin list := PrepareArray ( factoryWaypoints ) ;
124883: LD_ADDR_VAR 0 3
124887: PUSH
124888: LD_EXP 204
124892: PPUSH
124893: CALL 109845 0 1
124897: ST_TO_ADDR
// for i := 1 to list do
124898: LD_ADDR_VAR 0 2
124902: PUSH
124903: DOUBLE
124904: LD_INT 1
124906: DEC
124907: ST_TO_ADDR
124908: LD_VAR 0 3
124912: PUSH
124913: FOR_TO
124914: IFFALSE 125005
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
124916: LD_STRING setFactoryWaypointXY(
124918: PUSH
124919: LD_VAR 0 3
124923: PUSH
124924: LD_VAR 0 2
124928: ARRAY
124929: PUSH
124930: LD_INT 1
124932: ARRAY
124933: STR
124934: PUSH
124935: LD_STRING ,
124937: STR
124938: PUSH
124939: LD_VAR 0 3
124943: PUSH
124944: LD_VAR 0 2
124948: ARRAY
124949: PUSH
124950: LD_INT 2
124952: ARRAY
124953: STR
124954: PUSH
124955: LD_STRING ,
124957: STR
124958: PUSH
124959: LD_VAR 0 3
124963: PUSH
124964: LD_VAR 0 2
124968: ARRAY
124969: PUSH
124970: LD_INT 3
124972: ARRAY
124973: STR
124974: PUSH
124975: LD_STRING ,
124977: STR
124978: PUSH
124979: LD_VAR 0 3
124983: PUSH
124984: LD_VAR 0 2
124988: ARRAY
124989: PUSH
124990: LD_INT 4
124992: ARRAY
124993: STR
124994: PUSH
124995: LD_STRING )
124997: STR
124998: PPUSH
124999: CALL_OW 559
125003: GO 124913
125005: POP
125006: POP
// end ; end ;
125007: LD_VAR 0 1
125011: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
125012: LD_INT 0
125014: PPUSH
// if HexInfo ( x , y ) = warehouse then
125015: LD_VAR 0 2
125019: PPUSH
125020: LD_VAR 0 3
125024: PPUSH
125025: CALL_OW 428
125029: PUSH
125030: LD_VAR 0 1
125034: EQUAL
125035: IFFALSE 125062
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
125037: LD_ADDR_EXP 205
125041: PUSH
125042: LD_EXP 205
125046: PPUSH
125047: LD_VAR 0 1
125051: PPUSH
125052: LD_INT 0
125054: PPUSH
125055: CALL_OW 1
125059: ST_TO_ADDR
125060: GO 125113
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
125062: LD_ADDR_EXP 205
125066: PUSH
125067: LD_EXP 205
125071: PPUSH
125072: LD_VAR 0 1
125076: PPUSH
125077: LD_VAR 0 1
125081: PPUSH
125082: CALL_OW 255
125086: PUSH
125087: LD_VAR 0 1
125091: PUSH
125092: LD_VAR 0 2
125096: PUSH
125097: LD_VAR 0 3
125101: PUSH
125102: EMPTY
125103: LIST
125104: LIST
125105: LIST
125106: LIST
125107: PPUSH
125108: CALL_OW 1
125112: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
125113: CALL 125122 0 0
// end ;
125117: LD_VAR 0 4
125121: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
125122: LD_INT 0
125124: PPUSH
125125: PPUSH
125126: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
125127: LD_STRING resetWarehouseGatheringPoints();
125129: PPUSH
125130: CALL_OW 559
// if warehouseGatheringPoints then
125134: LD_EXP 205
125138: IFFALSE 125264
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
125140: LD_ADDR_VAR 0 3
125144: PUSH
125145: LD_EXP 205
125149: PPUSH
125150: CALL 109845 0 1
125154: ST_TO_ADDR
// for i := 1 to list do
125155: LD_ADDR_VAR 0 2
125159: PUSH
125160: DOUBLE
125161: LD_INT 1
125163: DEC
125164: ST_TO_ADDR
125165: LD_VAR 0 3
125169: PUSH
125170: FOR_TO
125171: IFFALSE 125262
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
125173: LD_STRING setWarehouseGatheringPointXY(
125175: PUSH
125176: LD_VAR 0 3
125180: PUSH
125181: LD_VAR 0 2
125185: ARRAY
125186: PUSH
125187: LD_INT 1
125189: ARRAY
125190: STR
125191: PUSH
125192: LD_STRING ,
125194: STR
125195: PUSH
125196: LD_VAR 0 3
125200: PUSH
125201: LD_VAR 0 2
125205: ARRAY
125206: PUSH
125207: LD_INT 2
125209: ARRAY
125210: STR
125211: PUSH
125212: LD_STRING ,
125214: STR
125215: PUSH
125216: LD_VAR 0 3
125220: PUSH
125221: LD_VAR 0 2
125225: ARRAY
125226: PUSH
125227: LD_INT 3
125229: ARRAY
125230: STR
125231: PUSH
125232: LD_STRING ,
125234: STR
125235: PUSH
125236: LD_VAR 0 3
125240: PUSH
125241: LD_VAR 0 2
125245: ARRAY
125246: PUSH
125247: LD_INT 4
125249: ARRAY
125250: STR
125251: PUSH
125252: LD_STRING )
125254: STR
125255: PPUSH
125256: CALL_OW 559
125260: GO 125170
125262: POP
125263: POP
// end ; end ;
125264: LD_VAR 0 1
125268: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
125269: LD_EXP 205
125273: IFFALSE 125958
125275: GO 125277
125277: DISABLE
125278: LD_INT 0
125280: PPUSH
125281: PPUSH
125282: PPUSH
125283: PPUSH
125284: PPUSH
125285: PPUSH
125286: PPUSH
125287: PPUSH
125288: PPUSH
// begin enable ;
125289: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
125290: LD_ADDR_VAR 0 3
125294: PUSH
125295: LD_EXP 205
125299: PPUSH
125300: CALL 109845 0 1
125304: ST_TO_ADDR
// if not list then
125305: LD_VAR 0 3
125309: NOT
125310: IFFALSE 125314
// exit ;
125312: GO 125958
// for i := 1 to list do
125314: LD_ADDR_VAR 0 1
125318: PUSH
125319: DOUBLE
125320: LD_INT 1
125322: DEC
125323: ST_TO_ADDR
125324: LD_VAR 0 3
125328: PUSH
125329: FOR_TO
125330: IFFALSE 125956
// begin depot := list [ i ] [ 2 ] ;
125332: LD_ADDR_VAR 0 8
125336: PUSH
125337: LD_VAR 0 3
125341: PUSH
125342: LD_VAR 0 1
125346: ARRAY
125347: PUSH
125348: LD_INT 2
125350: ARRAY
125351: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
125352: LD_ADDR_VAR 0 5
125356: PUSH
125357: LD_VAR 0 3
125361: PUSH
125362: LD_VAR 0 1
125366: ARRAY
125367: PUSH
125368: LD_INT 1
125370: ARRAY
125371: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
125372: LD_VAR 0 8
125376: PPUSH
125377: CALL_OW 301
125381: PUSH
125382: LD_VAR 0 5
125386: PUSH
125387: LD_VAR 0 8
125391: PPUSH
125392: CALL_OW 255
125396: NONEQUAL
125397: OR
125398: IFFALSE 125427
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
125400: LD_ADDR_EXP 205
125404: PUSH
125405: LD_EXP 205
125409: PPUSH
125410: LD_VAR 0 8
125414: PPUSH
125415: LD_INT 0
125417: PPUSH
125418: CALL_OW 1
125422: ST_TO_ADDR
// exit ;
125423: POP
125424: POP
125425: GO 125958
// end ; x := list [ i ] [ 3 ] ;
125427: LD_ADDR_VAR 0 6
125431: PUSH
125432: LD_VAR 0 3
125436: PUSH
125437: LD_VAR 0 1
125441: ARRAY
125442: PUSH
125443: LD_INT 3
125445: ARRAY
125446: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
125447: LD_ADDR_VAR 0 7
125451: PUSH
125452: LD_VAR 0 3
125456: PUSH
125457: LD_VAR 0 1
125461: ARRAY
125462: PUSH
125463: LD_INT 4
125465: ARRAY
125466: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
125467: LD_ADDR_VAR 0 9
125471: PUSH
125472: LD_VAR 0 6
125476: PPUSH
125477: LD_VAR 0 7
125481: PPUSH
125482: LD_INT 16
125484: PPUSH
125485: CALL 108433 0 3
125489: ST_TO_ADDR
// if not cratesNearbyPoint then
125490: LD_VAR 0 9
125494: NOT
125495: IFFALSE 125501
// exit ;
125497: POP
125498: POP
125499: GO 125958
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
125501: LD_ADDR_VAR 0 4
125505: PUSH
125506: LD_INT 22
125508: PUSH
125509: LD_VAR 0 5
125513: PUSH
125514: EMPTY
125515: LIST
125516: LIST
125517: PUSH
125518: LD_INT 3
125520: PUSH
125521: LD_INT 60
125523: PUSH
125524: EMPTY
125525: LIST
125526: PUSH
125527: EMPTY
125528: LIST
125529: LIST
125530: PUSH
125531: LD_INT 91
125533: PUSH
125534: LD_VAR 0 8
125538: PUSH
125539: LD_INT 6
125541: PUSH
125542: EMPTY
125543: LIST
125544: LIST
125545: LIST
125546: PUSH
125547: LD_INT 2
125549: PUSH
125550: LD_INT 25
125552: PUSH
125553: LD_INT 2
125555: PUSH
125556: EMPTY
125557: LIST
125558: LIST
125559: PUSH
125560: LD_INT 25
125562: PUSH
125563: LD_INT 16
125565: PUSH
125566: EMPTY
125567: LIST
125568: LIST
125569: PUSH
125570: EMPTY
125571: LIST
125572: LIST
125573: LIST
125574: PUSH
125575: EMPTY
125576: LIST
125577: LIST
125578: LIST
125579: LIST
125580: PPUSH
125581: CALL_OW 69
125585: PUSH
125586: LD_VAR 0 8
125590: PPUSH
125591: CALL_OW 313
125595: PPUSH
125596: LD_INT 3
125598: PUSH
125599: LD_INT 60
125601: PUSH
125602: EMPTY
125603: LIST
125604: PUSH
125605: EMPTY
125606: LIST
125607: LIST
125608: PUSH
125609: LD_INT 2
125611: PUSH
125612: LD_INT 25
125614: PUSH
125615: LD_INT 2
125617: PUSH
125618: EMPTY
125619: LIST
125620: LIST
125621: PUSH
125622: LD_INT 25
125624: PUSH
125625: LD_INT 16
125627: PUSH
125628: EMPTY
125629: LIST
125630: LIST
125631: PUSH
125632: EMPTY
125633: LIST
125634: LIST
125635: LIST
125636: PUSH
125637: EMPTY
125638: LIST
125639: LIST
125640: PPUSH
125641: CALL_OW 72
125645: UNION
125646: ST_TO_ADDR
// if tmp then
125647: LD_VAR 0 4
125651: IFFALSE 125731
// begin tmp := ShrinkArray ( tmp , 3 ) ;
125653: LD_ADDR_VAR 0 4
125657: PUSH
125658: LD_VAR 0 4
125662: PPUSH
125663: LD_INT 3
125665: PPUSH
125666: CALL 106402 0 2
125670: ST_TO_ADDR
// for j in tmp do
125671: LD_ADDR_VAR 0 2
125675: PUSH
125676: LD_VAR 0 4
125680: PUSH
125681: FOR_IN
125682: IFFALSE 125725
// begin if IsInUnit ( j ) then
125684: LD_VAR 0 2
125688: PPUSH
125689: CALL_OW 310
125693: IFFALSE 125704
// ComExit ( j ) ;
125695: LD_VAR 0 2
125699: PPUSH
125700: CALL 106485 0 1
// AddComCollect ( j , x , y ) ;
125704: LD_VAR 0 2
125708: PPUSH
125709: LD_VAR 0 6
125713: PPUSH
125714: LD_VAR 0 7
125718: PPUSH
125719: CALL_OW 177
// end ;
125723: GO 125681
125725: POP
125726: POP
// exit ;
125727: POP
125728: POP
125729: GO 125958
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
125731: LD_ADDR_VAR 0 4
125735: PUSH
125736: LD_INT 22
125738: PUSH
125739: LD_VAR 0 5
125743: PUSH
125744: EMPTY
125745: LIST
125746: LIST
125747: PUSH
125748: LD_INT 91
125750: PUSH
125751: LD_VAR 0 8
125755: PUSH
125756: LD_INT 8
125758: PUSH
125759: EMPTY
125760: LIST
125761: LIST
125762: LIST
125763: PUSH
125764: LD_INT 2
125766: PUSH
125767: LD_INT 34
125769: PUSH
125770: LD_INT 12
125772: PUSH
125773: EMPTY
125774: LIST
125775: LIST
125776: PUSH
125777: LD_INT 34
125779: PUSH
125780: LD_INT 51
125782: PUSH
125783: EMPTY
125784: LIST
125785: LIST
125786: PUSH
125787: LD_INT 34
125789: PUSH
125790: LD_INT 32
125792: PUSH
125793: EMPTY
125794: LIST
125795: LIST
125796: PUSH
125797: LD_INT 34
125799: PUSH
125800: LD_INT 89
125802: PUSH
125803: EMPTY
125804: LIST
125805: LIST
125806: PUSH
125807: EMPTY
125808: LIST
125809: LIST
125810: LIST
125811: LIST
125812: LIST
125813: PUSH
125814: EMPTY
125815: LIST
125816: LIST
125817: LIST
125818: PPUSH
125819: CALL_OW 69
125823: ST_TO_ADDR
// if tmp then
125824: LD_VAR 0 4
125828: IFFALSE 125954
// begin for j in tmp do
125830: LD_ADDR_VAR 0 2
125834: PUSH
125835: LD_VAR 0 4
125839: PUSH
125840: FOR_IN
125841: IFFALSE 125952
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
125843: LD_VAR 0 2
125847: PPUSH
125848: CALL_OW 262
125852: PUSH
125853: LD_INT 3
125855: EQUAL
125856: PUSH
125857: LD_VAR 0 2
125861: PPUSH
125862: CALL_OW 261
125866: PUSH
125867: LD_INT 20
125869: GREATER
125870: OR
125871: PUSH
125872: LD_VAR 0 2
125876: PPUSH
125877: CALL_OW 314
125881: NOT
125882: AND
125883: PUSH
125884: LD_VAR 0 2
125888: PPUSH
125889: CALL_OW 263
125893: PUSH
125894: LD_INT 1
125896: NONEQUAL
125897: PUSH
125898: LD_VAR 0 2
125902: PPUSH
125903: CALL_OW 311
125907: OR
125908: AND
125909: IFFALSE 125950
// begin ComCollect ( j , x , y ) ;
125911: LD_VAR 0 2
125915: PPUSH
125916: LD_VAR 0 6
125920: PPUSH
125921: LD_VAR 0 7
125925: PPUSH
125926: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
125930: LD_VAR 0 2
125934: PPUSH
125935: LD_VAR 0 8
125939: PPUSH
125940: CALL_OW 172
// exit ;
125944: POP
125945: POP
125946: POP
125947: POP
125948: GO 125958
// end ;
125950: GO 125840
125952: POP
125953: POP
// end ; end ;
125954: GO 125329
125956: POP
125957: POP
// end ; end_of_file
125958: PPOPN 9
125960: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
125961: LD_INT 0
125963: PPUSH
125964: PPUSH
125965: PPUSH
125966: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
125967: LD_VAR 0 1
125971: PPUSH
125972: CALL_OW 264
125976: PUSH
125977: LD_INT 91
125979: EQUAL
125980: IFFALSE 126052
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
125982: LD_INT 68
125984: PPUSH
125985: LD_VAR 0 1
125989: PPUSH
125990: CALL_OW 255
125994: PPUSH
125995: CALL_OW 321
125999: PUSH
126000: LD_INT 2
126002: EQUAL
126003: IFFALSE 126015
// eff := 70 else
126005: LD_ADDR_VAR 0 4
126009: PUSH
126010: LD_INT 70
126012: ST_TO_ADDR
126013: GO 126023
// eff := 30 ;
126015: LD_ADDR_VAR 0 4
126019: PUSH
126020: LD_INT 30
126022: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
126023: LD_VAR 0 1
126027: PPUSH
126028: CALL_OW 250
126032: PPUSH
126033: LD_VAR 0 1
126037: PPUSH
126038: CALL_OW 251
126042: PPUSH
126043: LD_VAR 0 4
126047: PPUSH
126048: CALL_OW 495
// end ; end ;
126052: LD_VAR 0 2
126056: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
126057: LD_INT 0
126059: PPUSH
// end ;
126060: LD_VAR 0 4
126064: RET
// export function SOS_Command ( cmd ) ; begin
126065: LD_INT 0
126067: PPUSH
// end ;
126068: LD_VAR 0 2
126072: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
126073: LD_INT 0
126075: PPUSH
// end ;
126076: LD_VAR 0 6
126080: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
126081: LD_INT 0
126083: PPUSH
126084: PPUSH
// if not vehicle or not factory then
126085: LD_VAR 0 1
126089: NOT
126090: PUSH
126091: LD_VAR 0 2
126095: NOT
126096: OR
126097: IFFALSE 126101
// exit ;
126099: GO 126332
// if factoryWaypoints >= factory then
126101: LD_EXP 204
126105: PUSH
126106: LD_VAR 0 2
126110: GREATEREQUAL
126111: IFFALSE 126332
// if factoryWaypoints [ factory ] then
126113: LD_EXP 204
126117: PUSH
126118: LD_VAR 0 2
126122: ARRAY
126123: IFFALSE 126332
// begin if GetControl ( vehicle ) = control_manual then
126125: LD_VAR 0 1
126129: PPUSH
126130: CALL_OW 263
126134: PUSH
126135: LD_INT 1
126137: EQUAL
126138: IFFALSE 126219
// begin driver := IsDrivenBy ( vehicle ) ;
126140: LD_ADDR_VAR 0 4
126144: PUSH
126145: LD_VAR 0 1
126149: PPUSH
126150: CALL_OW 311
126154: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126155: LD_VAR 0 4
126159: PPUSH
126160: LD_EXP 204
126164: PUSH
126165: LD_VAR 0 2
126169: ARRAY
126170: PUSH
126171: LD_INT 3
126173: ARRAY
126174: PPUSH
126175: LD_EXP 204
126179: PUSH
126180: LD_VAR 0 2
126184: ARRAY
126185: PUSH
126186: LD_INT 4
126188: ARRAY
126189: PPUSH
126190: CALL_OW 171
// AddComExitVehicle ( driver ) ;
126194: LD_VAR 0 4
126198: PPUSH
126199: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
126203: LD_VAR 0 4
126207: PPUSH
126208: LD_VAR 0 2
126212: PPUSH
126213: CALL_OW 180
// end else
126217: GO 126332
// if GetControl ( vehicle ) = control_remote then
126219: LD_VAR 0 1
126223: PPUSH
126224: CALL_OW 263
126228: PUSH
126229: LD_INT 2
126231: EQUAL
126232: IFFALSE 126293
// begin wait ( 0 0$2 ) ;
126234: LD_INT 70
126236: PPUSH
126237: CALL_OW 67
// if Connect ( vehicle ) then
126241: LD_VAR 0 1
126245: PPUSH
126246: CALL 76726 0 1
126250: IFFALSE 126291
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126252: LD_VAR 0 1
126256: PPUSH
126257: LD_EXP 204
126261: PUSH
126262: LD_VAR 0 2
126266: ARRAY
126267: PUSH
126268: LD_INT 3
126270: ARRAY
126271: PPUSH
126272: LD_EXP 204
126276: PUSH
126277: LD_VAR 0 2
126281: ARRAY
126282: PUSH
126283: LD_INT 4
126285: ARRAY
126286: PPUSH
126287: CALL_OW 171
// end else
126291: GO 126332
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126293: LD_VAR 0 1
126297: PPUSH
126298: LD_EXP 204
126302: PUSH
126303: LD_VAR 0 2
126307: ARRAY
126308: PUSH
126309: LD_INT 3
126311: ARRAY
126312: PPUSH
126313: LD_EXP 204
126317: PUSH
126318: LD_VAR 0 2
126322: ARRAY
126323: PUSH
126324: LD_INT 4
126326: ARRAY
126327: PPUSH
126328: CALL_OW 171
// end ; end ;
126332: LD_VAR 0 3
126336: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
126337: LD_INT 0
126339: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
126340: LD_VAR 0 1
126344: PUSH
126345: LD_INT 250
126347: EQUAL
126348: PUSH
126349: LD_VAR 0 2
126353: PPUSH
126354: CALL_OW 264
126358: PUSH
126359: LD_INT 81
126361: EQUAL
126362: AND
126363: IFFALSE 126384
// MinerPlaceMine ( unit , x , y ) ;
126365: LD_VAR 0 2
126369: PPUSH
126370: LD_VAR 0 4
126374: PPUSH
126375: LD_VAR 0 5
126379: PPUSH
126380: CALL 128769 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
126384: LD_VAR 0 1
126388: PUSH
126389: LD_INT 251
126391: EQUAL
126392: PUSH
126393: LD_VAR 0 2
126397: PPUSH
126398: CALL_OW 264
126402: PUSH
126403: LD_INT 81
126405: EQUAL
126406: AND
126407: IFFALSE 126428
// MinerDetonateMine ( unit , x , y ) ;
126409: LD_VAR 0 2
126413: PPUSH
126414: LD_VAR 0 4
126418: PPUSH
126419: LD_VAR 0 5
126423: PPUSH
126424: CALL 129044 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
126428: LD_VAR 0 1
126432: PUSH
126433: LD_INT 252
126435: EQUAL
126436: PUSH
126437: LD_VAR 0 2
126441: PPUSH
126442: CALL_OW 264
126446: PUSH
126447: LD_INT 81
126449: EQUAL
126450: AND
126451: IFFALSE 126472
// MinerCreateMinefield ( unit , x , y ) ;
126453: LD_VAR 0 2
126457: PPUSH
126458: LD_VAR 0 4
126462: PPUSH
126463: LD_VAR 0 5
126467: PPUSH
126468: CALL 129461 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
126472: LD_VAR 0 1
126476: PUSH
126477: LD_INT 253
126479: EQUAL
126480: PUSH
126481: LD_VAR 0 2
126485: PPUSH
126486: CALL_OW 257
126490: PUSH
126491: LD_INT 5
126493: EQUAL
126494: AND
126495: IFFALSE 126516
// ComBinocular ( unit , x , y ) ;
126497: LD_VAR 0 2
126501: PPUSH
126502: LD_VAR 0 4
126506: PPUSH
126507: LD_VAR 0 5
126511: PPUSH
126512: CALL 129830 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
126516: LD_VAR 0 1
126520: PUSH
126521: LD_INT 254
126523: EQUAL
126524: PUSH
126525: LD_VAR 0 2
126529: PPUSH
126530: CALL_OW 264
126534: PUSH
126535: LD_INT 99
126537: EQUAL
126538: AND
126539: PUSH
126540: LD_VAR 0 3
126544: PPUSH
126545: CALL_OW 263
126549: PUSH
126550: LD_INT 3
126552: EQUAL
126553: AND
126554: IFFALSE 126570
// HackDestroyVehicle ( unit , selectedUnit ) ;
126556: LD_VAR 0 2
126560: PPUSH
126561: LD_VAR 0 3
126565: PPUSH
126566: CALL 128133 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
126570: LD_VAR 0 1
126574: PUSH
126575: LD_INT 255
126577: EQUAL
126578: PUSH
126579: LD_VAR 0 2
126583: PPUSH
126584: CALL_OW 264
126588: PUSH
126589: LD_INT 14
126591: PUSH
126592: LD_INT 53
126594: PUSH
126595: EMPTY
126596: LIST
126597: LIST
126598: IN
126599: AND
126600: PUSH
126601: LD_VAR 0 4
126605: PPUSH
126606: LD_VAR 0 5
126610: PPUSH
126611: CALL_OW 488
126615: AND
126616: IFFALSE 126640
// CutTreeXYR ( unit , x , y , 12 ) ;
126618: LD_VAR 0 2
126622: PPUSH
126623: LD_VAR 0 4
126627: PPUSH
126628: LD_VAR 0 5
126632: PPUSH
126633: LD_INT 12
126635: PPUSH
126636: CALL 126703 0 4
// if cmd = 256 then
126640: LD_VAR 0 1
126644: PUSH
126645: LD_INT 256
126647: EQUAL
126648: IFFALSE 126669
// SetFactoryWaypoint ( unit , x , y ) ;
126650: LD_VAR 0 2
126654: PPUSH
126655: LD_VAR 0 4
126659: PPUSH
126660: LD_VAR 0 5
126664: PPUSH
126665: CALL 124650 0 3
// if cmd = 257 then
126669: LD_VAR 0 1
126673: PUSH
126674: LD_INT 257
126676: EQUAL
126677: IFFALSE 126698
// SetWarehouseGatheringPoint ( unit , x , y ) ;
126679: LD_VAR 0 2
126683: PPUSH
126684: LD_VAR 0 4
126688: PPUSH
126689: LD_VAR 0 5
126693: PPUSH
126694: CALL 125012 0 3
// end ;
126698: LD_VAR 0 6
126702: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
126703: LD_INT 0
126705: PPUSH
126706: PPUSH
126707: PPUSH
126708: PPUSH
126709: PPUSH
126710: PPUSH
126711: PPUSH
126712: PPUSH
126713: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
126714: LD_VAR 0 1
126718: NOT
126719: PUSH
126720: LD_VAR 0 2
126724: PPUSH
126725: LD_VAR 0 3
126729: PPUSH
126730: CALL_OW 488
126734: NOT
126735: OR
126736: PUSH
126737: LD_VAR 0 4
126741: NOT
126742: OR
126743: IFFALSE 126747
// exit ;
126745: GO 127087
// list := [ ] ;
126747: LD_ADDR_VAR 0 13
126751: PUSH
126752: EMPTY
126753: ST_TO_ADDR
// if x - r < 0 then
126754: LD_VAR 0 2
126758: PUSH
126759: LD_VAR 0 4
126763: MINUS
126764: PUSH
126765: LD_INT 0
126767: LESS
126768: IFFALSE 126780
// min_x := 0 else
126770: LD_ADDR_VAR 0 7
126774: PUSH
126775: LD_INT 0
126777: ST_TO_ADDR
126778: GO 126796
// min_x := x - r ;
126780: LD_ADDR_VAR 0 7
126784: PUSH
126785: LD_VAR 0 2
126789: PUSH
126790: LD_VAR 0 4
126794: MINUS
126795: ST_TO_ADDR
// if y - r < 0 then
126796: LD_VAR 0 3
126800: PUSH
126801: LD_VAR 0 4
126805: MINUS
126806: PUSH
126807: LD_INT 0
126809: LESS
126810: IFFALSE 126822
// min_y := 0 else
126812: LD_ADDR_VAR 0 8
126816: PUSH
126817: LD_INT 0
126819: ST_TO_ADDR
126820: GO 126838
// min_y := y - r ;
126822: LD_ADDR_VAR 0 8
126826: PUSH
126827: LD_VAR 0 3
126831: PUSH
126832: LD_VAR 0 4
126836: MINUS
126837: ST_TO_ADDR
// max_x := x + r ;
126838: LD_ADDR_VAR 0 9
126842: PUSH
126843: LD_VAR 0 2
126847: PUSH
126848: LD_VAR 0 4
126852: PLUS
126853: ST_TO_ADDR
// max_y := y + r ;
126854: LD_ADDR_VAR 0 10
126858: PUSH
126859: LD_VAR 0 3
126863: PUSH
126864: LD_VAR 0 4
126868: PLUS
126869: ST_TO_ADDR
// for _x = min_x to max_x do
126870: LD_ADDR_VAR 0 11
126874: PUSH
126875: DOUBLE
126876: LD_VAR 0 7
126880: DEC
126881: ST_TO_ADDR
126882: LD_VAR 0 9
126886: PUSH
126887: FOR_TO
126888: IFFALSE 127005
// for _y = min_y to max_y do
126890: LD_ADDR_VAR 0 12
126894: PUSH
126895: DOUBLE
126896: LD_VAR 0 8
126900: DEC
126901: ST_TO_ADDR
126902: LD_VAR 0 10
126906: PUSH
126907: FOR_TO
126908: IFFALSE 127001
// begin if not ValidHex ( _x , _y ) then
126910: LD_VAR 0 11
126914: PPUSH
126915: LD_VAR 0 12
126919: PPUSH
126920: CALL_OW 488
126924: NOT
126925: IFFALSE 126929
// continue ;
126927: GO 126907
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
126929: LD_VAR 0 11
126933: PPUSH
126934: LD_VAR 0 12
126938: PPUSH
126939: CALL_OW 351
126943: PUSH
126944: LD_VAR 0 11
126948: PPUSH
126949: LD_VAR 0 12
126953: PPUSH
126954: CALL_OW 554
126958: AND
126959: IFFALSE 126999
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
126961: LD_ADDR_VAR 0 13
126965: PUSH
126966: LD_VAR 0 13
126970: PPUSH
126971: LD_VAR 0 13
126975: PUSH
126976: LD_INT 1
126978: PLUS
126979: PPUSH
126980: LD_VAR 0 11
126984: PUSH
126985: LD_VAR 0 12
126989: PUSH
126990: EMPTY
126991: LIST
126992: LIST
126993: PPUSH
126994: CALL_OW 2
126998: ST_TO_ADDR
// end ;
126999: GO 126907
127001: POP
127002: POP
127003: GO 126887
127005: POP
127006: POP
// if not list then
127007: LD_VAR 0 13
127011: NOT
127012: IFFALSE 127016
// exit ;
127014: GO 127087
// for i in list do
127016: LD_ADDR_VAR 0 6
127020: PUSH
127021: LD_VAR 0 13
127025: PUSH
127026: FOR_IN
127027: IFFALSE 127085
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
127029: LD_VAR 0 1
127033: PPUSH
127034: LD_STRING M
127036: PUSH
127037: LD_VAR 0 6
127041: PUSH
127042: LD_INT 1
127044: ARRAY
127045: PUSH
127046: LD_VAR 0 6
127050: PUSH
127051: LD_INT 2
127053: ARRAY
127054: PUSH
127055: LD_INT 0
127057: PUSH
127058: LD_INT 0
127060: PUSH
127061: LD_INT 0
127063: PUSH
127064: LD_INT 0
127066: PUSH
127067: EMPTY
127068: LIST
127069: LIST
127070: LIST
127071: LIST
127072: LIST
127073: LIST
127074: LIST
127075: PUSH
127076: EMPTY
127077: LIST
127078: PPUSH
127079: CALL_OW 447
127083: GO 127026
127085: POP
127086: POP
// end ;
127087: LD_VAR 0 5
127091: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
127092: LD_EXP 207
127096: NOT
127097: IFFALSE 127147
127099: GO 127101
127101: DISABLE
// begin initHack := true ;
127102: LD_ADDR_EXP 207
127106: PUSH
127107: LD_INT 1
127109: ST_TO_ADDR
// hackTanks := [ ] ;
127110: LD_ADDR_EXP 208
127114: PUSH
127115: EMPTY
127116: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
127117: LD_ADDR_EXP 209
127121: PUSH
127122: EMPTY
127123: ST_TO_ADDR
// hackLimit := 3 ;
127124: LD_ADDR_EXP 210
127128: PUSH
127129: LD_INT 3
127131: ST_TO_ADDR
// hackDist := 12 ;
127132: LD_ADDR_EXP 211
127136: PUSH
127137: LD_INT 12
127139: ST_TO_ADDR
// hackCounter := [ ] ;
127140: LD_ADDR_EXP 212
127144: PUSH
127145: EMPTY
127146: ST_TO_ADDR
// end ;
127147: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
127148: LD_EXP 207
127152: PUSH
127153: LD_INT 34
127155: PUSH
127156: LD_INT 99
127158: PUSH
127159: EMPTY
127160: LIST
127161: LIST
127162: PPUSH
127163: CALL_OW 69
127167: AND
127168: IFFALSE 127421
127170: GO 127172
127172: DISABLE
127173: LD_INT 0
127175: PPUSH
127176: PPUSH
// begin enable ;
127177: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
127178: LD_ADDR_VAR 0 1
127182: PUSH
127183: LD_INT 34
127185: PUSH
127186: LD_INT 99
127188: PUSH
127189: EMPTY
127190: LIST
127191: LIST
127192: PPUSH
127193: CALL_OW 69
127197: PUSH
127198: FOR_IN
127199: IFFALSE 127419
// begin if not i in hackTanks then
127201: LD_VAR 0 1
127205: PUSH
127206: LD_EXP 208
127210: IN
127211: NOT
127212: IFFALSE 127295
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
127214: LD_ADDR_EXP 208
127218: PUSH
127219: LD_EXP 208
127223: PPUSH
127224: LD_EXP 208
127228: PUSH
127229: LD_INT 1
127231: PLUS
127232: PPUSH
127233: LD_VAR 0 1
127237: PPUSH
127238: CALL_OW 1
127242: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
127243: LD_ADDR_EXP 209
127247: PUSH
127248: LD_EXP 209
127252: PPUSH
127253: LD_EXP 209
127257: PUSH
127258: LD_INT 1
127260: PLUS
127261: PPUSH
127262: EMPTY
127263: PPUSH
127264: CALL_OW 1
127268: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
127269: LD_ADDR_EXP 212
127273: PUSH
127274: LD_EXP 212
127278: PPUSH
127279: LD_EXP 212
127283: PUSH
127284: LD_INT 1
127286: PLUS
127287: PPUSH
127288: EMPTY
127289: PPUSH
127290: CALL_OW 1
127294: ST_TO_ADDR
// end ; if not IsOk ( i ) then
127295: LD_VAR 0 1
127299: PPUSH
127300: CALL_OW 302
127304: NOT
127305: IFFALSE 127318
// begin HackUnlinkAll ( i ) ;
127307: LD_VAR 0 1
127311: PPUSH
127312: CALL 127424 0 1
// continue ;
127316: GO 127198
// end ; HackCheckCapturedStatus ( i ) ;
127318: LD_VAR 0 1
127322: PPUSH
127323: CALL 127867 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
127327: LD_ADDR_VAR 0 2
127331: PUSH
127332: LD_INT 81
127334: PUSH
127335: LD_VAR 0 1
127339: PPUSH
127340: CALL_OW 255
127344: PUSH
127345: EMPTY
127346: LIST
127347: LIST
127348: PUSH
127349: LD_INT 33
127351: PUSH
127352: LD_INT 3
127354: PUSH
127355: EMPTY
127356: LIST
127357: LIST
127358: PUSH
127359: LD_INT 91
127361: PUSH
127362: LD_VAR 0 1
127366: PUSH
127367: LD_EXP 211
127371: PUSH
127372: EMPTY
127373: LIST
127374: LIST
127375: LIST
127376: PUSH
127377: LD_INT 50
127379: PUSH
127380: EMPTY
127381: LIST
127382: PUSH
127383: EMPTY
127384: LIST
127385: LIST
127386: LIST
127387: LIST
127388: PPUSH
127389: CALL_OW 69
127393: ST_TO_ADDR
// if not tmp then
127394: LD_VAR 0 2
127398: NOT
127399: IFFALSE 127403
// continue ;
127401: GO 127198
// HackLink ( i , tmp ) ;
127403: LD_VAR 0 1
127407: PPUSH
127408: LD_VAR 0 2
127412: PPUSH
127413: CALL 127560 0 2
// end ;
127417: GO 127198
127419: POP
127420: POP
// end ;
127421: PPOPN 2
127423: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
127424: LD_INT 0
127426: PPUSH
127427: PPUSH
127428: PPUSH
// if not hack in hackTanks then
127429: LD_VAR 0 1
127433: PUSH
127434: LD_EXP 208
127438: IN
127439: NOT
127440: IFFALSE 127444
// exit ;
127442: GO 127555
// index := GetElementIndex ( hackTanks , hack ) ;
127444: LD_ADDR_VAR 0 4
127448: PUSH
127449: LD_EXP 208
127453: PPUSH
127454: LD_VAR 0 1
127458: PPUSH
127459: CALL 73542 0 2
127463: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
127464: LD_EXP 209
127468: PUSH
127469: LD_VAR 0 4
127473: ARRAY
127474: IFFALSE 127555
// begin for i in hackTanksCaptured [ index ] do
127476: LD_ADDR_VAR 0 3
127480: PUSH
127481: LD_EXP 209
127485: PUSH
127486: LD_VAR 0 4
127490: ARRAY
127491: PUSH
127492: FOR_IN
127493: IFFALSE 127519
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
127495: LD_VAR 0 3
127499: PUSH
127500: LD_INT 1
127502: ARRAY
127503: PPUSH
127504: LD_VAR 0 3
127508: PUSH
127509: LD_INT 2
127511: ARRAY
127512: PPUSH
127513: CALL_OW 235
127517: GO 127492
127519: POP
127520: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
127521: LD_ADDR_EXP 209
127525: PUSH
127526: LD_EXP 209
127530: PPUSH
127531: LD_VAR 0 4
127535: PPUSH
127536: EMPTY
127537: PPUSH
127538: CALL_OW 1
127542: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
127543: LD_VAR 0 1
127547: PPUSH
127548: LD_INT 0
127550: PPUSH
127551: CALL_OW 505
// end ; end ;
127555: LD_VAR 0 2
127559: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
127560: LD_INT 0
127562: PPUSH
127563: PPUSH
127564: PPUSH
// if not hack in hackTanks or not vehicles then
127565: LD_VAR 0 1
127569: PUSH
127570: LD_EXP 208
127574: IN
127575: NOT
127576: PUSH
127577: LD_VAR 0 2
127581: NOT
127582: OR
127583: IFFALSE 127587
// exit ;
127585: GO 127862
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
127587: LD_ADDR_VAR 0 2
127591: PUSH
127592: LD_VAR 0 1
127596: PPUSH
127597: LD_VAR 0 2
127601: PPUSH
127602: LD_INT 1
127604: PPUSH
127605: LD_INT 1
127607: PPUSH
127608: CALL 74192 0 4
127612: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
127613: LD_ADDR_VAR 0 5
127617: PUSH
127618: LD_EXP 208
127622: PPUSH
127623: LD_VAR 0 1
127627: PPUSH
127628: CALL 73542 0 2
127632: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
127633: LD_EXP 209
127637: PUSH
127638: LD_VAR 0 5
127642: ARRAY
127643: PUSH
127644: LD_EXP 210
127648: LESS
127649: IFFALSE 127838
// begin for i := 1 to vehicles do
127651: LD_ADDR_VAR 0 4
127655: PUSH
127656: DOUBLE
127657: LD_INT 1
127659: DEC
127660: ST_TO_ADDR
127661: LD_VAR 0 2
127665: PUSH
127666: FOR_TO
127667: IFFALSE 127836
// begin if hackTanksCaptured [ index ] = hackLimit then
127669: LD_EXP 209
127673: PUSH
127674: LD_VAR 0 5
127678: ARRAY
127679: PUSH
127680: LD_EXP 210
127684: EQUAL
127685: IFFALSE 127689
// break ;
127687: GO 127836
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
127689: LD_ADDR_EXP 212
127693: PUSH
127694: LD_EXP 212
127698: PPUSH
127699: LD_VAR 0 5
127703: PPUSH
127704: LD_EXP 212
127708: PUSH
127709: LD_VAR 0 5
127713: ARRAY
127714: PUSH
127715: LD_INT 1
127717: PLUS
127718: PPUSH
127719: CALL_OW 1
127723: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
127724: LD_ADDR_EXP 209
127728: PUSH
127729: LD_EXP 209
127733: PPUSH
127734: LD_VAR 0 5
127738: PUSH
127739: LD_EXP 209
127743: PUSH
127744: LD_VAR 0 5
127748: ARRAY
127749: PUSH
127750: LD_INT 1
127752: PLUS
127753: PUSH
127754: EMPTY
127755: LIST
127756: LIST
127757: PPUSH
127758: LD_VAR 0 2
127762: PUSH
127763: LD_VAR 0 4
127767: ARRAY
127768: PUSH
127769: LD_VAR 0 2
127773: PUSH
127774: LD_VAR 0 4
127778: ARRAY
127779: PPUSH
127780: CALL_OW 255
127784: PUSH
127785: EMPTY
127786: LIST
127787: LIST
127788: PPUSH
127789: CALL 73757 0 3
127793: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
127794: LD_VAR 0 2
127798: PUSH
127799: LD_VAR 0 4
127803: ARRAY
127804: PPUSH
127805: LD_VAR 0 1
127809: PPUSH
127810: CALL_OW 255
127814: PPUSH
127815: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
127819: LD_VAR 0 2
127823: PUSH
127824: LD_VAR 0 4
127828: ARRAY
127829: PPUSH
127830: CALL_OW 141
// end ;
127834: GO 127666
127836: POP
127837: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
127838: LD_VAR 0 1
127842: PPUSH
127843: LD_EXP 209
127847: PUSH
127848: LD_VAR 0 5
127852: ARRAY
127853: PUSH
127854: LD_INT 0
127856: PLUS
127857: PPUSH
127858: CALL_OW 505
// end ;
127862: LD_VAR 0 3
127866: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
127867: LD_INT 0
127869: PPUSH
127870: PPUSH
127871: PPUSH
127872: PPUSH
// if not hack in hackTanks then
127873: LD_VAR 0 1
127877: PUSH
127878: LD_EXP 208
127882: IN
127883: NOT
127884: IFFALSE 127888
// exit ;
127886: GO 128128
// index := GetElementIndex ( hackTanks , hack ) ;
127888: LD_ADDR_VAR 0 4
127892: PUSH
127893: LD_EXP 208
127897: PPUSH
127898: LD_VAR 0 1
127902: PPUSH
127903: CALL 73542 0 2
127907: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
127908: LD_ADDR_VAR 0 3
127912: PUSH
127913: DOUBLE
127914: LD_EXP 209
127918: PUSH
127919: LD_VAR 0 4
127923: ARRAY
127924: INC
127925: ST_TO_ADDR
127926: LD_INT 1
127928: PUSH
127929: FOR_DOWNTO
127930: IFFALSE 128102
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
127932: LD_ADDR_VAR 0 5
127936: PUSH
127937: LD_EXP 209
127941: PUSH
127942: LD_VAR 0 4
127946: ARRAY
127947: PUSH
127948: LD_VAR 0 3
127952: ARRAY
127953: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
127954: LD_VAR 0 5
127958: PUSH
127959: LD_INT 1
127961: ARRAY
127962: PPUSH
127963: CALL_OW 302
127967: NOT
127968: PUSH
127969: LD_VAR 0 5
127973: PUSH
127974: LD_INT 1
127976: ARRAY
127977: PPUSH
127978: CALL_OW 255
127982: PUSH
127983: LD_VAR 0 1
127987: PPUSH
127988: CALL_OW 255
127992: NONEQUAL
127993: OR
127994: IFFALSE 128100
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
127996: LD_VAR 0 5
128000: PUSH
128001: LD_INT 1
128003: ARRAY
128004: PPUSH
128005: CALL_OW 305
128009: PUSH
128010: LD_VAR 0 5
128014: PUSH
128015: LD_INT 1
128017: ARRAY
128018: PPUSH
128019: CALL_OW 255
128023: PUSH
128024: LD_VAR 0 1
128028: PPUSH
128029: CALL_OW 255
128033: EQUAL
128034: AND
128035: IFFALSE 128059
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
128037: LD_VAR 0 5
128041: PUSH
128042: LD_INT 1
128044: ARRAY
128045: PPUSH
128046: LD_VAR 0 5
128050: PUSH
128051: LD_INT 2
128053: ARRAY
128054: PPUSH
128055: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
128059: LD_ADDR_EXP 209
128063: PUSH
128064: LD_EXP 209
128068: PPUSH
128069: LD_VAR 0 4
128073: PPUSH
128074: LD_EXP 209
128078: PUSH
128079: LD_VAR 0 4
128083: ARRAY
128084: PPUSH
128085: LD_VAR 0 3
128089: PPUSH
128090: CALL_OW 3
128094: PPUSH
128095: CALL_OW 1
128099: ST_TO_ADDR
// end ; end ;
128100: GO 127929
128102: POP
128103: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
128104: LD_VAR 0 1
128108: PPUSH
128109: LD_EXP 209
128113: PUSH
128114: LD_VAR 0 4
128118: ARRAY
128119: PUSH
128120: LD_INT 0
128122: PLUS
128123: PPUSH
128124: CALL_OW 505
// end ;
128128: LD_VAR 0 2
128132: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
128133: LD_INT 0
128135: PPUSH
128136: PPUSH
128137: PPUSH
128138: PPUSH
// if not hack in hackTanks then
128139: LD_VAR 0 1
128143: PUSH
128144: LD_EXP 208
128148: IN
128149: NOT
128150: IFFALSE 128154
// exit ;
128152: GO 128239
// index := GetElementIndex ( hackTanks , hack ) ;
128154: LD_ADDR_VAR 0 5
128158: PUSH
128159: LD_EXP 208
128163: PPUSH
128164: LD_VAR 0 1
128168: PPUSH
128169: CALL 73542 0 2
128173: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
128174: LD_ADDR_VAR 0 4
128178: PUSH
128179: DOUBLE
128180: LD_INT 1
128182: DEC
128183: ST_TO_ADDR
128184: LD_EXP 209
128188: PUSH
128189: LD_VAR 0 5
128193: ARRAY
128194: PUSH
128195: FOR_TO
128196: IFFALSE 128237
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
128198: LD_EXP 209
128202: PUSH
128203: LD_VAR 0 5
128207: ARRAY
128208: PUSH
128209: LD_VAR 0 4
128213: ARRAY
128214: PUSH
128215: LD_INT 1
128217: ARRAY
128218: PUSH
128219: LD_VAR 0 2
128223: EQUAL
128224: IFFALSE 128235
// KillUnit ( vehicle ) ;
128226: LD_VAR 0 2
128230: PPUSH
128231: CALL_OW 66
128235: GO 128195
128237: POP
128238: POP
// end ;
128239: LD_VAR 0 3
128243: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
128244: LD_EXP 213
128248: NOT
128249: IFFALSE 128284
128251: GO 128253
128253: DISABLE
// begin initMiner := true ;
128254: LD_ADDR_EXP 213
128258: PUSH
128259: LD_INT 1
128261: ST_TO_ADDR
// minersList := [ ] ;
128262: LD_ADDR_EXP 214
128266: PUSH
128267: EMPTY
128268: ST_TO_ADDR
// minerMinesList := [ ] ;
128269: LD_ADDR_EXP 215
128273: PUSH
128274: EMPTY
128275: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
128276: LD_ADDR_EXP 216
128280: PUSH
128281: LD_INT 5
128283: ST_TO_ADDR
// end ;
128284: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
128285: LD_EXP 213
128289: PUSH
128290: LD_INT 34
128292: PUSH
128293: LD_INT 81
128295: PUSH
128296: EMPTY
128297: LIST
128298: LIST
128299: PPUSH
128300: CALL_OW 69
128304: AND
128305: IFFALSE 128766
128307: GO 128309
128309: DISABLE
128310: LD_INT 0
128312: PPUSH
128313: PPUSH
128314: PPUSH
128315: PPUSH
// begin enable ;
128316: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
128317: LD_ADDR_VAR 0 1
128321: PUSH
128322: LD_INT 34
128324: PUSH
128325: LD_INT 81
128327: PUSH
128328: EMPTY
128329: LIST
128330: LIST
128331: PPUSH
128332: CALL_OW 69
128336: PUSH
128337: FOR_IN
128338: IFFALSE 128410
// begin if not i in minersList then
128340: LD_VAR 0 1
128344: PUSH
128345: LD_EXP 214
128349: IN
128350: NOT
128351: IFFALSE 128408
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
128353: LD_ADDR_EXP 214
128357: PUSH
128358: LD_EXP 214
128362: PPUSH
128363: LD_EXP 214
128367: PUSH
128368: LD_INT 1
128370: PLUS
128371: PPUSH
128372: LD_VAR 0 1
128376: PPUSH
128377: CALL_OW 1
128381: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
128382: LD_ADDR_EXP 215
128386: PUSH
128387: LD_EXP 215
128391: PPUSH
128392: LD_EXP 215
128396: PUSH
128397: LD_INT 1
128399: PLUS
128400: PPUSH
128401: EMPTY
128402: PPUSH
128403: CALL_OW 1
128407: ST_TO_ADDR
// end end ;
128408: GO 128337
128410: POP
128411: POP
// for i := minerMinesList downto 1 do
128412: LD_ADDR_VAR 0 1
128416: PUSH
128417: DOUBLE
128418: LD_EXP 215
128422: INC
128423: ST_TO_ADDR
128424: LD_INT 1
128426: PUSH
128427: FOR_DOWNTO
128428: IFFALSE 128764
// begin if IsLive ( minersList [ i ] ) then
128430: LD_EXP 214
128434: PUSH
128435: LD_VAR 0 1
128439: ARRAY
128440: PPUSH
128441: CALL_OW 300
128445: IFFALSE 128473
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
128447: LD_EXP 214
128451: PUSH
128452: LD_VAR 0 1
128456: ARRAY
128457: PPUSH
128458: LD_EXP 215
128462: PUSH
128463: LD_VAR 0 1
128467: ARRAY
128468: PPUSH
128469: CALL_OW 505
// if not minerMinesList [ i ] then
128473: LD_EXP 215
128477: PUSH
128478: LD_VAR 0 1
128482: ARRAY
128483: NOT
128484: IFFALSE 128488
// continue ;
128486: GO 128427
// for j := minerMinesList [ i ] downto 1 do
128488: LD_ADDR_VAR 0 2
128492: PUSH
128493: DOUBLE
128494: LD_EXP 215
128498: PUSH
128499: LD_VAR 0 1
128503: ARRAY
128504: INC
128505: ST_TO_ADDR
128506: LD_INT 1
128508: PUSH
128509: FOR_DOWNTO
128510: IFFALSE 128760
// begin side := GetSide ( minersList [ i ] ) ;
128512: LD_ADDR_VAR 0 3
128516: PUSH
128517: LD_EXP 214
128521: PUSH
128522: LD_VAR 0 1
128526: ARRAY
128527: PPUSH
128528: CALL_OW 255
128532: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
128533: LD_ADDR_VAR 0 4
128537: PUSH
128538: LD_EXP 215
128542: PUSH
128543: LD_VAR 0 1
128547: ARRAY
128548: PUSH
128549: LD_VAR 0 2
128553: ARRAY
128554: PUSH
128555: LD_INT 1
128557: ARRAY
128558: PPUSH
128559: LD_EXP 215
128563: PUSH
128564: LD_VAR 0 1
128568: ARRAY
128569: PUSH
128570: LD_VAR 0 2
128574: ARRAY
128575: PUSH
128576: LD_INT 2
128578: ARRAY
128579: PPUSH
128580: CALL_OW 428
128584: ST_TO_ADDR
// if not tmp then
128585: LD_VAR 0 4
128589: NOT
128590: IFFALSE 128594
// continue ;
128592: GO 128509
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
128594: LD_VAR 0 4
128598: PUSH
128599: LD_INT 81
128601: PUSH
128602: LD_VAR 0 3
128606: PUSH
128607: EMPTY
128608: LIST
128609: LIST
128610: PPUSH
128611: CALL_OW 69
128615: IN
128616: PUSH
128617: LD_EXP 215
128621: PUSH
128622: LD_VAR 0 1
128626: ARRAY
128627: PUSH
128628: LD_VAR 0 2
128632: ARRAY
128633: PUSH
128634: LD_INT 1
128636: ARRAY
128637: PPUSH
128638: LD_EXP 215
128642: PUSH
128643: LD_VAR 0 1
128647: ARRAY
128648: PUSH
128649: LD_VAR 0 2
128653: ARRAY
128654: PUSH
128655: LD_INT 2
128657: ARRAY
128658: PPUSH
128659: CALL_OW 458
128663: AND
128664: IFFALSE 128758
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
128666: LD_EXP 215
128670: PUSH
128671: LD_VAR 0 1
128675: ARRAY
128676: PUSH
128677: LD_VAR 0 2
128681: ARRAY
128682: PUSH
128683: LD_INT 1
128685: ARRAY
128686: PPUSH
128687: LD_EXP 215
128691: PUSH
128692: LD_VAR 0 1
128696: ARRAY
128697: PUSH
128698: LD_VAR 0 2
128702: ARRAY
128703: PUSH
128704: LD_INT 2
128706: ARRAY
128707: PPUSH
128708: LD_VAR 0 3
128712: PPUSH
128713: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
128717: LD_ADDR_EXP 215
128721: PUSH
128722: LD_EXP 215
128726: PPUSH
128727: LD_VAR 0 1
128731: PPUSH
128732: LD_EXP 215
128736: PUSH
128737: LD_VAR 0 1
128741: ARRAY
128742: PPUSH
128743: LD_VAR 0 2
128747: PPUSH
128748: CALL_OW 3
128752: PPUSH
128753: CALL_OW 1
128757: ST_TO_ADDR
// end ; end ;
128758: GO 128509
128760: POP
128761: POP
// end ;
128762: GO 128427
128764: POP
128765: POP
// end ;
128766: PPOPN 4
128768: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
128769: LD_INT 0
128771: PPUSH
128772: PPUSH
// result := false ;
128773: LD_ADDR_VAR 0 4
128777: PUSH
128778: LD_INT 0
128780: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
128781: LD_VAR 0 1
128785: PPUSH
128786: CALL_OW 264
128790: PUSH
128791: LD_INT 81
128793: EQUAL
128794: NOT
128795: IFFALSE 128799
// exit ;
128797: GO 129039
// index := GetElementIndex ( minersList , unit ) ;
128799: LD_ADDR_VAR 0 5
128803: PUSH
128804: LD_EXP 214
128808: PPUSH
128809: LD_VAR 0 1
128813: PPUSH
128814: CALL 73542 0 2
128818: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
128819: LD_EXP 215
128823: PUSH
128824: LD_VAR 0 5
128828: ARRAY
128829: PUSH
128830: LD_EXP 216
128834: GREATEREQUAL
128835: IFFALSE 128839
// exit ;
128837: GO 129039
// ComMoveXY ( unit , x , y ) ;
128839: LD_VAR 0 1
128843: PPUSH
128844: LD_VAR 0 2
128848: PPUSH
128849: LD_VAR 0 3
128853: PPUSH
128854: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128858: LD_INT 35
128860: PPUSH
128861: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
128865: LD_VAR 0 1
128869: PPUSH
128870: LD_VAR 0 2
128874: PPUSH
128875: LD_VAR 0 3
128879: PPUSH
128880: CALL 104897 0 3
128884: NOT
128885: PUSH
128886: LD_VAR 0 1
128890: PPUSH
128891: CALL_OW 314
128895: AND
128896: IFFALSE 128900
// exit ;
128898: GO 129039
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
128900: LD_VAR 0 2
128904: PPUSH
128905: LD_VAR 0 3
128909: PPUSH
128910: CALL_OW 428
128914: PUSH
128915: LD_VAR 0 1
128919: EQUAL
128920: PUSH
128921: LD_VAR 0 1
128925: PPUSH
128926: CALL_OW 314
128930: NOT
128931: AND
128932: IFFALSE 128858
// PlaySoundXY ( x , y , PlantMine ) ;
128934: LD_VAR 0 2
128938: PPUSH
128939: LD_VAR 0 3
128943: PPUSH
128944: LD_STRING PlantMine
128946: PPUSH
128947: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
128951: LD_VAR 0 2
128955: PPUSH
128956: LD_VAR 0 3
128960: PPUSH
128961: LD_VAR 0 1
128965: PPUSH
128966: CALL_OW 255
128970: PPUSH
128971: LD_INT 0
128973: PPUSH
128974: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
128978: LD_ADDR_EXP 215
128982: PUSH
128983: LD_EXP 215
128987: PPUSH
128988: LD_VAR 0 5
128992: PUSH
128993: LD_EXP 215
128997: PUSH
128998: LD_VAR 0 5
129002: ARRAY
129003: PUSH
129004: LD_INT 1
129006: PLUS
129007: PUSH
129008: EMPTY
129009: LIST
129010: LIST
129011: PPUSH
129012: LD_VAR 0 2
129016: PUSH
129017: LD_VAR 0 3
129021: PUSH
129022: EMPTY
129023: LIST
129024: LIST
129025: PPUSH
129026: CALL 73757 0 3
129030: ST_TO_ADDR
// result := true ;
129031: LD_ADDR_VAR 0 4
129035: PUSH
129036: LD_INT 1
129038: ST_TO_ADDR
// end ;
129039: LD_VAR 0 4
129043: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
129044: LD_INT 0
129046: PPUSH
129047: PPUSH
129048: PPUSH
// if not unit in minersList then
129049: LD_VAR 0 1
129053: PUSH
129054: LD_EXP 214
129058: IN
129059: NOT
129060: IFFALSE 129064
// exit ;
129062: GO 129456
// index := GetElementIndex ( minersList , unit ) ;
129064: LD_ADDR_VAR 0 6
129068: PUSH
129069: LD_EXP 214
129073: PPUSH
129074: LD_VAR 0 1
129078: PPUSH
129079: CALL 73542 0 2
129083: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
129084: LD_ADDR_VAR 0 5
129088: PUSH
129089: DOUBLE
129090: LD_EXP 215
129094: PUSH
129095: LD_VAR 0 6
129099: ARRAY
129100: INC
129101: ST_TO_ADDR
129102: LD_INT 1
129104: PUSH
129105: FOR_DOWNTO
129106: IFFALSE 129267
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
129108: LD_EXP 215
129112: PUSH
129113: LD_VAR 0 6
129117: ARRAY
129118: PUSH
129119: LD_VAR 0 5
129123: ARRAY
129124: PUSH
129125: LD_INT 1
129127: ARRAY
129128: PUSH
129129: LD_VAR 0 2
129133: EQUAL
129134: PUSH
129135: LD_EXP 215
129139: PUSH
129140: LD_VAR 0 6
129144: ARRAY
129145: PUSH
129146: LD_VAR 0 5
129150: ARRAY
129151: PUSH
129152: LD_INT 2
129154: ARRAY
129155: PUSH
129156: LD_VAR 0 3
129160: EQUAL
129161: AND
129162: IFFALSE 129265
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
129164: LD_EXP 215
129168: PUSH
129169: LD_VAR 0 6
129173: ARRAY
129174: PUSH
129175: LD_VAR 0 5
129179: ARRAY
129180: PUSH
129181: LD_INT 1
129183: ARRAY
129184: PPUSH
129185: LD_EXP 215
129189: PUSH
129190: LD_VAR 0 6
129194: ARRAY
129195: PUSH
129196: LD_VAR 0 5
129200: ARRAY
129201: PUSH
129202: LD_INT 2
129204: ARRAY
129205: PPUSH
129206: LD_VAR 0 1
129210: PPUSH
129211: CALL_OW 255
129215: PPUSH
129216: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
129220: LD_ADDR_EXP 215
129224: PUSH
129225: LD_EXP 215
129229: PPUSH
129230: LD_VAR 0 6
129234: PPUSH
129235: LD_EXP 215
129239: PUSH
129240: LD_VAR 0 6
129244: ARRAY
129245: PPUSH
129246: LD_VAR 0 5
129250: PPUSH
129251: CALL_OW 3
129255: PPUSH
129256: CALL_OW 1
129260: ST_TO_ADDR
// exit ;
129261: POP
129262: POP
129263: GO 129456
// end ; end ;
129265: GO 129105
129267: POP
129268: POP
// for i := minerMinesList [ index ] downto 1 do
129269: LD_ADDR_VAR 0 5
129273: PUSH
129274: DOUBLE
129275: LD_EXP 215
129279: PUSH
129280: LD_VAR 0 6
129284: ARRAY
129285: INC
129286: ST_TO_ADDR
129287: LD_INT 1
129289: PUSH
129290: FOR_DOWNTO
129291: IFFALSE 129454
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
129293: LD_EXP 215
129297: PUSH
129298: LD_VAR 0 6
129302: ARRAY
129303: PUSH
129304: LD_VAR 0 5
129308: ARRAY
129309: PUSH
129310: LD_INT 1
129312: ARRAY
129313: PPUSH
129314: LD_EXP 215
129318: PUSH
129319: LD_VAR 0 6
129323: ARRAY
129324: PUSH
129325: LD_VAR 0 5
129329: ARRAY
129330: PUSH
129331: LD_INT 2
129333: ARRAY
129334: PPUSH
129335: LD_VAR 0 2
129339: PPUSH
129340: LD_VAR 0 3
129344: PPUSH
129345: CALL_OW 298
129349: PUSH
129350: LD_INT 6
129352: LESS
129353: IFFALSE 129452
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
129355: LD_EXP 215
129359: PUSH
129360: LD_VAR 0 6
129364: ARRAY
129365: PUSH
129366: LD_VAR 0 5
129370: ARRAY
129371: PUSH
129372: LD_INT 1
129374: ARRAY
129375: PPUSH
129376: LD_EXP 215
129380: PUSH
129381: LD_VAR 0 6
129385: ARRAY
129386: PUSH
129387: LD_VAR 0 5
129391: ARRAY
129392: PUSH
129393: LD_INT 2
129395: ARRAY
129396: PPUSH
129397: LD_VAR 0 1
129401: PPUSH
129402: CALL_OW 255
129406: PPUSH
129407: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
129411: LD_ADDR_EXP 215
129415: PUSH
129416: LD_EXP 215
129420: PPUSH
129421: LD_VAR 0 6
129425: PPUSH
129426: LD_EXP 215
129430: PUSH
129431: LD_VAR 0 6
129435: ARRAY
129436: PPUSH
129437: LD_VAR 0 5
129441: PPUSH
129442: CALL_OW 3
129446: PPUSH
129447: CALL_OW 1
129451: ST_TO_ADDR
// end ; end ;
129452: GO 129290
129454: POP
129455: POP
// end ;
129456: LD_VAR 0 4
129460: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
129461: LD_INT 0
129463: PPUSH
129464: PPUSH
129465: PPUSH
129466: PPUSH
129467: PPUSH
129468: PPUSH
129469: PPUSH
129470: PPUSH
129471: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
129472: LD_VAR 0 1
129476: PPUSH
129477: CALL_OW 264
129481: PUSH
129482: LD_INT 81
129484: EQUAL
129485: NOT
129486: PUSH
129487: LD_VAR 0 1
129491: PUSH
129492: LD_EXP 214
129496: IN
129497: NOT
129498: OR
129499: IFFALSE 129503
// exit ;
129501: GO 129825
// index := GetElementIndex ( minersList , unit ) ;
129503: LD_ADDR_VAR 0 6
129507: PUSH
129508: LD_EXP 214
129512: PPUSH
129513: LD_VAR 0 1
129517: PPUSH
129518: CALL 73542 0 2
129522: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
129523: LD_ADDR_VAR 0 8
129527: PUSH
129528: LD_EXP 216
129532: PUSH
129533: LD_EXP 215
129537: PUSH
129538: LD_VAR 0 6
129542: ARRAY
129543: MINUS
129544: ST_TO_ADDR
// if not minesFreeAmount then
129545: LD_VAR 0 8
129549: NOT
129550: IFFALSE 129554
// exit ;
129552: GO 129825
// tmp := [ ] ;
129554: LD_ADDR_VAR 0 7
129558: PUSH
129559: EMPTY
129560: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
129561: LD_ADDR_VAR 0 5
129565: PUSH
129566: DOUBLE
129567: LD_INT 1
129569: DEC
129570: ST_TO_ADDR
129571: LD_VAR 0 8
129575: PUSH
129576: FOR_TO
129577: IFFALSE 129772
// begin _d := rand ( 0 , 5 ) ;
129579: LD_ADDR_VAR 0 11
129583: PUSH
129584: LD_INT 0
129586: PPUSH
129587: LD_INT 5
129589: PPUSH
129590: CALL_OW 12
129594: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
129595: LD_ADDR_VAR 0 12
129599: PUSH
129600: LD_INT 2
129602: PPUSH
129603: LD_INT 6
129605: PPUSH
129606: CALL_OW 12
129610: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
129611: LD_ADDR_VAR 0 9
129615: PUSH
129616: LD_VAR 0 2
129620: PPUSH
129621: LD_VAR 0 11
129625: PPUSH
129626: LD_VAR 0 12
129630: PPUSH
129631: CALL_OW 272
129635: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
129636: LD_ADDR_VAR 0 10
129640: PUSH
129641: LD_VAR 0 3
129645: PPUSH
129646: LD_VAR 0 11
129650: PPUSH
129651: LD_VAR 0 12
129655: PPUSH
129656: CALL_OW 273
129660: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
129661: LD_VAR 0 9
129665: PPUSH
129666: LD_VAR 0 10
129670: PPUSH
129671: CALL_OW 488
129675: PUSH
129676: LD_VAR 0 9
129680: PUSH
129681: LD_VAR 0 10
129685: PUSH
129686: EMPTY
129687: LIST
129688: LIST
129689: PUSH
129690: LD_VAR 0 7
129694: IN
129695: NOT
129696: AND
129697: PUSH
129698: LD_VAR 0 9
129702: PPUSH
129703: LD_VAR 0 10
129707: PPUSH
129708: CALL_OW 458
129712: NOT
129713: AND
129714: IFFALSE 129756
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
129716: LD_ADDR_VAR 0 7
129720: PUSH
129721: LD_VAR 0 7
129725: PPUSH
129726: LD_VAR 0 7
129730: PUSH
129731: LD_INT 1
129733: PLUS
129734: PPUSH
129735: LD_VAR 0 9
129739: PUSH
129740: LD_VAR 0 10
129744: PUSH
129745: EMPTY
129746: LIST
129747: LIST
129748: PPUSH
129749: CALL_OW 1
129753: ST_TO_ADDR
129754: GO 129770
// i := i - 1 ;
129756: LD_ADDR_VAR 0 5
129760: PUSH
129761: LD_VAR 0 5
129765: PUSH
129766: LD_INT 1
129768: MINUS
129769: ST_TO_ADDR
// end ;
129770: GO 129576
129772: POP
129773: POP
// for i in tmp do
129774: LD_ADDR_VAR 0 5
129778: PUSH
129779: LD_VAR 0 7
129783: PUSH
129784: FOR_IN
129785: IFFALSE 129823
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
129787: LD_VAR 0 1
129791: PPUSH
129792: LD_VAR 0 5
129796: PUSH
129797: LD_INT 1
129799: ARRAY
129800: PPUSH
129801: LD_VAR 0 5
129805: PUSH
129806: LD_INT 2
129808: ARRAY
129809: PPUSH
129810: CALL 128769 0 3
129814: NOT
129815: IFFALSE 129821
// exit ;
129817: POP
129818: POP
129819: GO 129825
129821: GO 129784
129823: POP
129824: POP
// end ;
129825: LD_VAR 0 4
129829: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
129830: LD_INT 0
129832: PPUSH
129833: PPUSH
129834: PPUSH
129835: PPUSH
129836: PPUSH
129837: PPUSH
129838: PPUSH
// if not GetClass ( unit ) = class_sniper then
129839: LD_VAR 0 1
129843: PPUSH
129844: CALL_OW 257
129848: PUSH
129849: LD_INT 5
129851: EQUAL
129852: NOT
129853: IFFALSE 129857
// exit ;
129855: GO 130245
// dist := 8 ;
129857: LD_ADDR_VAR 0 5
129861: PUSH
129862: LD_INT 8
129864: ST_TO_ADDR
// viewRange := 12 ;
129865: LD_ADDR_VAR 0 7
129869: PUSH
129870: LD_INT 12
129872: ST_TO_ADDR
// side := GetSide ( unit ) ;
129873: LD_ADDR_VAR 0 6
129877: PUSH
129878: LD_VAR 0 1
129882: PPUSH
129883: CALL_OW 255
129887: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
129888: LD_INT 61
129890: PPUSH
129891: LD_VAR 0 6
129895: PPUSH
129896: CALL_OW 321
129900: PUSH
129901: LD_INT 2
129903: EQUAL
129904: IFFALSE 129914
// viewRange := 16 ;
129906: LD_ADDR_VAR 0 7
129910: PUSH
129911: LD_INT 16
129913: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
129914: LD_VAR 0 1
129918: PPUSH
129919: LD_VAR 0 2
129923: PPUSH
129924: LD_VAR 0 3
129928: PPUSH
129929: CALL_OW 297
129933: PUSH
129934: LD_VAR 0 5
129938: GREATER
129939: IFFALSE 130018
// begin ComMoveXY ( unit , x , y ) ;
129941: LD_VAR 0 1
129945: PPUSH
129946: LD_VAR 0 2
129950: PPUSH
129951: LD_VAR 0 3
129955: PPUSH
129956: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
129960: LD_INT 35
129962: PPUSH
129963: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
129967: LD_VAR 0 1
129971: PPUSH
129972: LD_VAR 0 2
129976: PPUSH
129977: LD_VAR 0 3
129981: PPUSH
129982: CALL 104897 0 3
129986: NOT
129987: IFFALSE 129991
// exit ;
129989: GO 130245
// until GetDistUnitXY ( unit , x , y ) < dist ;
129991: LD_VAR 0 1
129995: PPUSH
129996: LD_VAR 0 2
130000: PPUSH
130001: LD_VAR 0 3
130005: PPUSH
130006: CALL_OW 297
130010: PUSH
130011: LD_VAR 0 5
130015: LESS
130016: IFFALSE 129960
// end ; ComTurnXY ( unit , x , y ) ;
130018: LD_VAR 0 1
130022: PPUSH
130023: LD_VAR 0 2
130027: PPUSH
130028: LD_VAR 0 3
130032: PPUSH
130033: CALL_OW 118
// wait ( 5 ) ;
130037: LD_INT 5
130039: PPUSH
130040: CALL_OW 67
// _d := GetDir ( unit ) ;
130044: LD_ADDR_VAR 0 10
130048: PUSH
130049: LD_VAR 0 1
130053: PPUSH
130054: CALL_OW 254
130058: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
130059: LD_ADDR_VAR 0 8
130063: PUSH
130064: LD_VAR 0 1
130068: PPUSH
130069: CALL_OW 250
130073: PPUSH
130074: LD_VAR 0 10
130078: PPUSH
130079: LD_VAR 0 5
130083: PPUSH
130084: CALL_OW 272
130088: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
130089: LD_ADDR_VAR 0 9
130093: PUSH
130094: LD_VAR 0 1
130098: PPUSH
130099: CALL_OW 251
130103: PPUSH
130104: LD_VAR 0 10
130108: PPUSH
130109: LD_VAR 0 5
130113: PPUSH
130114: CALL_OW 273
130118: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
130119: LD_VAR 0 8
130123: PPUSH
130124: LD_VAR 0 9
130128: PPUSH
130129: CALL_OW 488
130133: NOT
130134: IFFALSE 130138
// exit ;
130136: GO 130245
// ComAnimCustom ( unit , 1 ) ;
130138: LD_VAR 0 1
130142: PPUSH
130143: LD_INT 1
130145: PPUSH
130146: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
130150: LD_VAR 0 8
130154: PPUSH
130155: LD_VAR 0 9
130159: PPUSH
130160: LD_VAR 0 6
130164: PPUSH
130165: LD_VAR 0 7
130169: PPUSH
130170: CALL_OW 330
// repeat wait ( 1 ) ;
130174: LD_INT 1
130176: PPUSH
130177: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
130181: LD_VAR 0 1
130185: PPUSH
130186: CALL_OW 316
130190: PUSH
130191: LD_VAR 0 1
130195: PPUSH
130196: CALL_OW 314
130200: OR
130201: PUSH
130202: LD_VAR 0 1
130206: PPUSH
130207: CALL_OW 302
130211: NOT
130212: OR
130213: PUSH
130214: LD_VAR 0 1
130218: PPUSH
130219: CALL_OW 301
130223: OR
130224: IFFALSE 130174
// RemoveSeeing ( _x , _y , side ) ;
130226: LD_VAR 0 8
130230: PPUSH
130231: LD_VAR 0 9
130235: PPUSH
130236: LD_VAR 0 6
130240: PPUSH
130241: CALL_OW 331
// end ; end_of_file
130245: LD_VAR 0 4
130249: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
130250: LD_INT 0
130252: PPUSH
130253: PPUSH
130254: PPUSH
130255: PPUSH
130256: PPUSH
130257: PPUSH
130258: PPUSH
130259: PPUSH
130260: PPUSH
130261: PPUSH
130262: PPUSH
130263: PPUSH
130264: PPUSH
130265: PPUSH
130266: PPUSH
130267: PPUSH
130268: PPUSH
130269: PPUSH
130270: PPUSH
130271: PPUSH
130272: PPUSH
130273: PPUSH
130274: PPUSH
130275: PPUSH
130276: PPUSH
130277: PPUSH
130278: PPUSH
130279: PPUSH
130280: PPUSH
130281: PPUSH
130282: PPUSH
130283: PPUSH
130284: PPUSH
130285: PPUSH
// if not list then
130286: LD_VAR 0 1
130290: NOT
130291: IFFALSE 130295
// exit ;
130293: GO 134954
// base := list [ 1 ] ;
130295: LD_ADDR_VAR 0 3
130299: PUSH
130300: LD_VAR 0 1
130304: PUSH
130305: LD_INT 1
130307: ARRAY
130308: ST_TO_ADDR
// group := list [ 2 ] ;
130309: LD_ADDR_VAR 0 4
130313: PUSH
130314: LD_VAR 0 1
130318: PUSH
130319: LD_INT 2
130321: ARRAY
130322: ST_TO_ADDR
// path := list [ 3 ] ;
130323: LD_ADDR_VAR 0 5
130327: PUSH
130328: LD_VAR 0 1
130332: PUSH
130333: LD_INT 3
130335: ARRAY
130336: ST_TO_ADDR
// flags := list [ 4 ] ;
130337: LD_ADDR_VAR 0 6
130341: PUSH
130342: LD_VAR 0 1
130346: PUSH
130347: LD_INT 4
130349: ARRAY
130350: ST_TO_ADDR
// mined := [ ] ;
130351: LD_ADDR_VAR 0 27
130355: PUSH
130356: EMPTY
130357: ST_TO_ADDR
// bombed := [ ] ;
130358: LD_ADDR_VAR 0 28
130362: PUSH
130363: EMPTY
130364: ST_TO_ADDR
// healers := [ ] ;
130365: LD_ADDR_VAR 0 31
130369: PUSH
130370: EMPTY
130371: ST_TO_ADDR
// to_heal := [ ] ;
130372: LD_ADDR_VAR 0 30
130376: PUSH
130377: EMPTY
130378: ST_TO_ADDR
// repairs := [ ] ;
130379: LD_ADDR_VAR 0 33
130383: PUSH
130384: EMPTY
130385: ST_TO_ADDR
// to_repair := [ ] ;
130386: LD_ADDR_VAR 0 32
130390: PUSH
130391: EMPTY
130392: ST_TO_ADDR
// if not group or not path then
130393: LD_VAR 0 4
130397: NOT
130398: PUSH
130399: LD_VAR 0 5
130403: NOT
130404: OR
130405: IFFALSE 130409
// exit ;
130407: GO 134954
// side := GetSide ( group [ 1 ] ) ;
130409: LD_ADDR_VAR 0 35
130413: PUSH
130414: LD_VAR 0 4
130418: PUSH
130419: LD_INT 1
130421: ARRAY
130422: PPUSH
130423: CALL_OW 255
130427: ST_TO_ADDR
// if flags then
130428: LD_VAR 0 6
130432: IFFALSE 130576
// begin f_ignore_area := flags [ 1 ] ;
130434: LD_ADDR_VAR 0 17
130438: PUSH
130439: LD_VAR 0 6
130443: PUSH
130444: LD_INT 1
130446: ARRAY
130447: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
130448: LD_ADDR_VAR 0 18
130452: PUSH
130453: LD_VAR 0 6
130457: PUSH
130458: LD_INT 2
130460: ARRAY
130461: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
130462: LD_ADDR_VAR 0 19
130466: PUSH
130467: LD_VAR 0 6
130471: PUSH
130472: LD_INT 3
130474: ARRAY
130475: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
130476: LD_ADDR_VAR 0 20
130480: PUSH
130481: LD_VAR 0 6
130485: PUSH
130486: LD_INT 4
130488: ARRAY
130489: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
130490: LD_ADDR_VAR 0 21
130494: PUSH
130495: LD_VAR 0 6
130499: PUSH
130500: LD_INT 5
130502: ARRAY
130503: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
130504: LD_ADDR_VAR 0 22
130508: PUSH
130509: LD_VAR 0 6
130513: PUSH
130514: LD_INT 6
130516: ARRAY
130517: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
130518: LD_ADDR_VAR 0 23
130522: PUSH
130523: LD_VAR 0 6
130527: PUSH
130528: LD_INT 7
130530: ARRAY
130531: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
130532: LD_ADDR_VAR 0 24
130536: PUSH
130537: LD_VAR 0 6
130541: PUSH
130542: LD_INT 8
130544: ARRAY
130545: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
130546: LD_ADDR_VAR 0 25
130550: PUSH
130551: LD_VAR 0 6
130555: PUSH
130556: LD_INT 9
130558: ARRAY
130559: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
130560: LD_ADDR_VAR 0 26
130564: PUSH
130565: LD_VAR 0 6
130569: PUSH
130570: LD_INT 10
130572: ARRAY
130573: ST_TO_ADDR
// end else
130574: GO 130656
// begin f_ignore_area := false ;
130576: LD_ADDR_VAR 0 17
130580: PUSH
130581: LD_INT 0
130583: ST_TO_ADDR
// f_capture := false ;
130584: LD_ADDR_VAR 0 18
130588: PUSH
130589: LD_INT 0
130591: ST_TO_ADDR
// f_ignore_civ := false ;
130592: LD_ADDR_VAR 0 19
130596: PUSH
130597: LD_INT 0
130599: ST_TO_ADDR
// f_murder := false ;
130600: LD_ADDR_VAR 0 20
130604: PUSH
130605: LD_INT 0
130607: ST_TO_ADDR
// f_mines := false ;
130608: LD_ADDR_VAR 0 21
130612: PUSH
130613: LD_INT 0
130615: ST_TO_ADDR
// f_repair := false ;
130616: LD_ADDR_VAR 0 22
130620: PUSH
130621: LD_INT 0
130623: ST_TO_ADDR
// f_heal := false ;
130624: LD_ADDR_VAR 0 23
130628: PUSH
130629: LD_INT 0
130631: ST_TO_ADDR
// f_spacetime := false ;
130632: LD_ADDR_VAR 0 24
130636: PUSH
130637: LD_INT 0
130639: ST_TO_ADDR
// f_attack_depot := false ;
130640: LD_ADDR_VAR 0 25
130644: PUSH
130645: LD_INT 0
130647: ST_TO_ADDR
// f_crawl := false ;
130648: LD_ADDR_VAR 0 26
130652: PUSH
130653: LD_INT 0
130655: ST_TO_ADDR
// end ; if f_heal then
130656: LD_VAR 0 23
130660: IFFALSE 130687
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
130662: LD_ADDR_VAR 0 31
130666: PUSH
130667: LD_VAR 0 4
130671: PPUSH
130672: LD_INT 25
130674: PUSH
130675: LD_INT 4
130677: PUSH
130678: EMPTY
130679: LIST
130680: LIST
130681: PPUSH
130682: CALL_OW 72
130686: ST_TO_ADDR
// if f_repair then
130687: LD_VAR 0 22
130691: IFFALSE 130718
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
130693: LD_ADDR_VAR 0 33
130697: PUSH
130698: LD_VAR 0 4
130702: PPUSH
130703: LD_INT 25
130705: PUSH
130706: LD_INT 3
130708: PUSH
130709: EMPTY
130710: LIST
130711: LIST
130712: PPUSH
130713: CALL_OW 72
130717: ST_TO_ADDR
// units_path := [ ] ;
130718: LD_ADDR_VAR 0 16
130722: PUSH
130723: EMPTY
130724: ST_TO_ADDR
// for i = 1 to group do
130725: LD_ADDR_VAR 0 7
130729: PUSH
130730: DOUBLE
130731: LD_INT 1
130733: DEC
130734: ST_TO_ADDR
130735: LD_VAR 0 4
130739: PUSH
130740: FOR_TO
130741: IFFALSE 130770
// units_path := Replace ( units_path , i , path ) ;
130743: LD_ADDR_VAR 0 16
130747: PUSH
130748: LD_VAR 0 16
130752: PPUSH
130753: LD_VAR 0 7
130757: PPUSH
130758: LD_VAR 0 5
130762: PPUSH
130763: CALL_OW 1
130767: ST_TO_ADDR
130768: GO 130740
130770: POP
130771: POP
// repeat for i = group downto 1 do
130772: LD_ADDR_VAR 0 7
130776: PUSH
130777: DOUBLE
130778: LD_VAR 0 4
130782: INC
130783: ST_TO_ADDR
130784: LD_INT 1
130786: PUSH
130787: FOR_DOWNTO
130788: IFFALSE 134910
// begin wait ( 5 ) ;
130790: LD_INT 5
130792: PPUSH
130793: CALL_OW 67
// tmp := [ ] ;
130797: LD_ADDR_VAR 0 14
130801: PUSH
130802: EMPTY
130803: ST_TO_ADDR
// attacking := false ;
130804: LD_ADDR_VAR 0 29
130808: PUSH
130809: LD_INT 0
130811: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
130812: LD_VAR 0 4
130816: PUSH
130817: LD_VAR 0 7
130821: ARRAY
130822: PPUSH
130823: CALL_OW 301
130827: PUSH
130828: LD_VAR 0 4
130832: PUSH
130833: LD_VAR 0 7
130837: ARRAY
130838: NOT
130839: OR
130840: IFFALSE 130949
// begin if GetType ( group [ i ] ) = unit_human then
130842: LD_VAR 0 4
130846: PUSH
130847: LD_VAR 0 7
130851: ARRAY
130852: PPUSH
130853: CALL_OW 247
130857: PUSH
130858: LD_INT 1
130860: EQUAL
130861: IFFALSE 130907
// begin to_heal := to_heal diff group [ i ] ;
130863: LD_ADDR_VAR 0 30
130867: PUSH
130868: LD_VAR 0 30
130872: PUSH
130873: LD_VAR 0 4
130877: PUSH
130878: LD_VAR 0 7
130882: ARRAY
130883: DIFF
130884: ST_TO_ADDR
// healers := healers diff group [ i ] ;
130885: LD_ADDR_VAR 0 31
130889: PUSH
130890: LD_VAR 0 31
130894: PUSH
130895: LD_VAR 0 4
130899: PUSH
130900: LD_VAR 0 7
130904: ARRAY
130905: DIFF
130906: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
130907: LD_ADDR_VAR 0 4
130911: PUSH
130912: LD_VAR 0 4
130916: PPUSH
130917: LD_VAR 0 7
130921: PPUSH
130922: CALL_OW 3
130926: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
130927: LD_ADDR_VAR 0 16
130931: PUSH
130932: LD_VAR 0 16
130936: PPUSH
130937: LD_VAR 0 7
130941: PPUSH
130942: CALL_OW 3
130946: ST_TO_ADDR
// continue ;
130947: GO 130787
// end ; if f_repair then
130949: LD_VAR 0 22
130953: IFFALSE 131442
// begin if GetType ( group [ i ] ) = unit_vehicle then
130955: LD_VAR 0 4
130959: PUSH
130960: LD_VAR 0 7
130964: ARRAY
130965: PPUSH
130966: CALL_OW 247
130970: PUSH
130971: LD_INT 2
130973: EQUAL
130974: IFFALSE 131164
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
130976: LD_VAR 0 4
130980: PUSH
130981: LD_VAR 0 7
130985: ARRAY
130986: PPUSH
130987: CALL_OW 256
130991: PUSH
130992: LD_INT 700
130994: LESS
130995: PUSH
130996: LD_VAR 0 4
131000: PUSH
131001: LD_VAR 0 7
131005: ARRAY
131006: PUSH
131007: LD_VAR 0 32
131011: IN
131012: NOT
131013: AND
131014: IFFALSE 131038
// to_repair := to_repair union group [ i ] ;
131016: LD_ADDR_VAR 0 32
131020: PUSH
131021: LD_VAR 0 32
131025: PUSH
131026: LD_VAR 0 4
131030: PUSH
131031: LD_VAR 0 7
131035: ARRAY
131036: UNION
131037: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
131038: LD_VAR 0 4
131042: PUSH
131043: LD_VAR 0 7
131047: ARRAY
131048: PPUSH
131049: CALL_OW 256
131053: PUSH
131054: LD_INT 1000
131056: EQUAL
131057: PUSH
131058: LD_VAR 0 4
131062: PUSH
131063: LD_VAR 0 7
131067: ARRAY
131068: PUSH
131069: LD_VAR 0 32
131073: IN
131074: AND
131075: IFFALSE 131099
// to_repair := to_repair diff group [ i ] ;
131077: LD_ADDR_VAR 0 32
131081: PUSH
131082: LD_VAR 0 32
131086: PUSH
131087: LD_VAR 0 4
131091: PUSH
131092: LD_VAR 0 7
131096: ARRAY
131097: DIFF
131098: ST_TO_ADDR
// if group [ i ] in to_repair then
131099: LD_VAR 0 4
131103: PUSH
131104: LD_VAR 0 7
131108: ARRAY
131109: PUSH
131110: LD_VAR 0 32
131114: IN
131115: IFFALSE 131162
// begin if not IsInArea ( group [ i ] , f_repair ) then
131117: LD_VAR 0 4
131121: PUSH
131122: LD_VAR 0 7
131126: ARRAY
131127: PPUSH
131128: LD_VAR 0 22
131132: PPUSH
131133: CALL_OW 308
131137: NOT
131138: IFFALSE 131160
// ComMoveToArea ( group [ i ] , f_repair ) ;
131140: LD_VAR 0 4
131144: PUSH
131145: LD_VAR 0 7
131149: ARRAY
131150: PPUSH
131151: LD_VAR 0 22
131155: PPUSH
131156: CALL_OW 113
// continue ;
131160: GO 130787
// end ; end else
131162: GO 131442
// if group [ i ] in repairs then
131164: LD_VAR 0 4
131168: PUSH
131169: LD_VAR 0 7
131173: ARRAY
131174: PUSH
131175: LD_VAR 0 33
131179: IN
131180: IFFALSE 131442
// begin if IsInUnit ( group [ i ] ) then
131182: LD_VAR 0 4
131186: PUSH
131187: LD_VAR 0 7
131191: ARRAY
131192: PPUSH
131193: CALL_OW 310
131197: IFFALSE 131265
// begin z := IsInUnit ( group [ i ] ) ;
131199: LD_ADDR_VAR 0 13
131203: PUSH
131204: LD_VAR 0 4
131208: PUSH
131209: LD_VAR 0 7
131213: ARRAY
131214: PPUSH
131215: CALL_OW 310
131219: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
131220: LD_VAR 0 13
131224: PUSH
131225: LD_VAR 0 32
131229: IN
131230: PUSH
131231: LD_VAR 0 13
131235: PPUSH
131236: LD_VAR 0 22
131240: PPUSH
131241: CALL_OW 308
131245: AND
131246: IFFALSE 131263
// ComExitVehicle ( group [ i ] ) ;
131248: LD_VAR 0 4
131252: PUSH
131253: LD_VAR 0 7
131257: ARRAY
131258: PPUSH
131259: CALL_OW 121
// end else
131263: GO 131442
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
131265: LD_ADDR_VAR 0 13
131269: PUSH
131270: LD_VAR 0 4
131274: PPUSH
131275: LD_INT 95
131277: PUSH
131278: LD_VAR 0 22
131282: PUSH
131283: EMPTY
131284: LIST
131285: LIST
131286: PUSH
131287: LD_INT 58
131289: PUSH
131290: EMPTY
131291: LIST
131292: PUSH
131293: EMPTY
131294: LIST
131295: LIST
131296: PPUSH
131297: CALL_OW 72
131301: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
131302: LD_VAR 0 4
131306: PUSH
131307: LD_VAR 0 7
131311: ARRAY
131312: PPUSH
131313: CALL_OW 314
131317: NOT
131318: IFFALSE 131440
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
131320: LD_ADDR_VAR 0 10
131324: PUSH
131325: LD_VAR 0 13
131329: PPUSH
131330: LD_VAR 0 4
131334: PUSH
131335: LD_VAR 0 7
131339: ARRAY
131340: PPUSH
131341: CALL_OW 74
131345: ST_TO_ADDR
// if not x then
131346: LD_VAR 0 10
131350: NOT
131351: IFFALSE 131355
// continue ;
131353: GO 130787
// if GetLives ( x ) < 1000 then
131355: LD_VAR 0 10
131359: PPUSH
131360: CALL_OW 256
131364: PUSH
131365: LD_INT 1000
131367: LESS
131368: IFFALSE 131392
// ComRepairVehicle ( group [ i ] , x ) else
131370: LD_VAR 0 4
131374: PUSH
131375: LD_VAR 0 7
131379: ARRAY
131380: PPUSH
131381: LD_VAR 0 10
131385: PPUSH
131386: CALL_OW 129
131390: GO 131440
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
131392: LD_VAR 0 23
131396: PUSH
131397: LD_VAR 0 4
131401: PUSH
131402: LD_VAR 0 7
131406: ARRAY
131407: PPUSH
131408: CALL_OW 256
131412: PUSH
131413: LD_INT 1000
131415: LESS
131416: AND
131417: NOT
131418: IFFALSE 131440
// ComEnterUnit ( group [ i ] , x ) ;
131420: LD_VAR 0 4
131424: PUSH
131425: LD_VAR 0 7
131429: ARRAY
131430: PPUSH
131431: LD_VAR 0 10
131435: PPUSH
131436: CALL_OW 120
// end ; continue ;
131440: GO 130787
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
131442: LD_VAR 0 23
131446: PUSH
131447: LD_VAR 0 4
131451: PUSH
131452: LD_VAR 0 7
131456: ARRAY
131457: PPUSH
131458: CALL_OW 247
131462: PUSH
131463: LD_INT 1
131465: EQUAL
131466: AND
131467: IFFALSE 131945
// begin if group [ i ] in healers then
131469: LD_VAR 0 4
131473: PUSH
131474: LD_VAR 0 7
131478: ARRAY
131479: PUSH
131480: LD_VAR 0 31
131484: IN
131485: IFFALSE 131758
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
131487: LD_VAR 0 4
131491: PUSH
131492: LD_VAR 0 7
131496: ARRAY
131497: PPUSH
131498: LD_VAR 0 23
131502: PPUSH
131503: CALL_OW 308
131507: NOT
131508: PUSH
131509: LD_VAR 0 4
131513: PUSH
131514: LD_VAR 0 7
131518: ARRAY
131519: PPUSH
131520: CALL_OW 314
131524: NOT
131525: AND
131526: IFFALSE 131550
// ComMoveToArea ( group [ i ] , f_heal ) else
131528: LD_VAR 0 4
131532: PUSH
131533: LD_VAR 0 7
131537: ARRAY
131538: PPUSH
131539: LD_VAR 0 23
131543: PPUSH
131544: CALL_OW 113
131548: GO 131756
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
131550: LD_VAR 0 4
131554: PUSH
131555: LD_VAR 0 7
131559: ARRAY
131560: PPUSH
131561: CALL 103480 0 1
131565: PPUSH
131566: CALL_OW 256
131570: PUSH
131571: LD_INT 1000
131573: EQUAL
131574: IFFALSE 131593
// ComStop ( group [ i ] ) else
131576: LD_VAR 0 4
131580: PUSH
131581: LD_VAR 0 7
131585: ARRAY
131586: PPUSH
131587: CALL_OW 141
131591: GO 131756
// if not HasTask ( group [ i ] ) and to_heal then
131593: LD_VAR 0 4
131597: PUSH
131598: LD_VAR 0 7
131602: ARRAY
131603: PPUSH
131604: CALL_OW 314
131608: NOT
131609: PUSH
131610: LD_VAR 0 30
131614: AND
131615: IFFALSE 131756
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
131617: LD_ADDR_VAR 0 13
131621: PUSH
131622: LD_VAR 0 30
131626: PPUSH
131627: LD_INT 3
131629: PUSH
131630: LD_INT 54
131632: PUSH
131633: EMPTY
131634: LIST
131635: PUSH
131636: EMPTY
131637: LIST
131638: LIST
131639: PPUSH
131640: CALL_OW 72
131644: PPUSH
131645: LD_VAR 0 4
131649: PUSH
131650: LD_VAR 0 7
131654: ARRAY
131655: PPUSH
131656: CALL_OW 74
131660: ST_TO_ADDR
// if z then
131661: LD_VAR 0 13
131665: IFFALSE 131756
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
131667: LD_INT 91
131669: PUSH
131670: LD_VAR 0 13
131674: PUSH
131675: LD_INT 10
131677: PUSH
131678: EMPTY
131679: LIST
131680: LIST
131681: LIST
131682: PUSH
131683: LD_INT 81
131685: PUSH
131686: LD_VAR 0 13
131690: PPUSH
131691: CALL_OW 255
131695: PUSH
131696: EMPTY
131697: LIST
131698: LIST
131699: PUSH
131700: EMPTY
131701: LIST
131702: LIST
131703: PPUSH
131704: CALL_OW 69
131708: PUSH
131709: LD_INT 0
131711: EQUAL
131712: IFFALSE 131736
// ComHeal ( group [ i ] , z ) else
131714: LD_VAR 0 4
131718: PUSH
131719: LD_VAR 0 7
131723: ARRAY
131724: PPUSH
131725: LD_VAR 0 13
131729: PPUSH
131730: CALL_OW 128
131734: GO 131756
// ComMoveToArea ( group [ i ] , f_heal ) ;
131736: LD_VAR 0 4
131740: PUSH
131741: LD_VAR 0 7
131745: ARRAY
131746: PPUSH
131747: LD_VAR 0 23
131751: PPUSH
131752: CALL_OW 113
// end ; continue ;
131756: GO 130787
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
131758: LD_VAR 0 4
131762: PUSH
131763: LD_VAR 0 7
131767: ARRAY
131768: PPUSH
131769: CALL_OW 256
131773: PUSH
131774: LD_INT 700
131776: LESS
131777: PUSH
131778: LD_VAR 0 4
131782: PUSH
131783: LD_VAR 0 7
131787: ARRAY
131788: PUSH
131789: LD_VAR 0 30
131793: IN
131794: NOT
131795: AND
131796: IFFALSE 131820
// to_heal := to_heal union group [ i ] ;
131798: LD_ADDR_VAR 0 30
131802: PUSH
131803: LD_VAR 0 30
131807: PUSH
131808: LD_VAR 0 4
131812: PUSH
131813: LD_VAR 0 7
131817: ARRAY
131818: UNION
131819: ST_TO_ADDR
// if group [ i ] in to_heal then
131820: LD_VAR 0 4
131824: PUSH
131825: LD_VAR 0 7
131829: ARRAY
131830: PUSH
131831: LD_VAR 0 30
131835: IN
131836: IFFALSE 131945
// begin if GetLives ( group [ i ] ) = 1000 then
131838: LD_VAR 0 4
131842: PUSH
131843: LD_VAR 0 7
131847: ARRAY
131848: PPUSH
131849: CALL_OW 256
131853: PUSH
131854: LD_INT 1000
131856: EQUAL
131857: IFFALSE 131883
// to_heal := to_heal diff group [ i ] else
131859: LD_ADDR_VAR 0 30
131863: PUSH
131864: LD_VAR 0 30
131868: PUSH
131869: LD_VAR 0 4
131873: PUSH
131874: LD_VAR 0 7
131878: ARRAY
131879: DIFF
131880: ST_TO_ADDR
131881: GO 131945
// begin if not IsInArea ( group [ i ] , to_heal ) then
131883: LD_VAR 0 4
131887: PUSH
131888: LD_VAR 0 7
131892: ARRAY
131893: PPUSH
131894: LD_VAR 0 30
131898: PPUSH
131899: CALL_OW 308
131903: NOT
131904: IFFALSE 131928
// ComMoveToArea ( group [ i ] , f_heal ) else
131906: LD_VAR 0 4
131910: PUSH
131911: LD_VAR 0 7
131915: ARRAY
131916: PPUSH
131917: LD_VAR 0 23
131921: PPUSH
131922: CALL_OW 113
131926: GO 131943
// ComHold ( group [ i ] ) ;
131928: LD_VAR 0 4
131932: PUSH
131933: LD_VAR 0 7
131937: ARRAY
131938: PPUSH
131939: CALL_OW 140
// continue ;
131943: GO 130787
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
131945: LD_VAR 0 4
131949: PUSH
131950: LD_VAR 0 7
131954: ARRAY
131955: PPUSH
131956: LD_INT 10
131958: PPUSH
131959: CALL 101251 0 2
131963: NOT
131964: PUSH
131965: LD_VAR 0 16
131969: PUSH
131970: LD_VAR 0 7
131974: ARRAY
131975: PUSH
131976: EMPTY
131977: EQUAL
131978: NOT
131979: AND
131980: IFFALSE 132246
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
131982: LD_VAR 0 4
131986: PUSH
131987: LD_VAR 0 7
131991: ARRAY
131992: PPUSH
131993: CALL_OW 262
131997: PUSH
131998: LD_INT 1
132000: PUSH
132001: LD_INT 2
132003: PUSH
132004: EMPTY
132005: LIST
132006: LIST
132007: IN
132008: IFFALSE 132049
// if GetFuel ( group [ i ] ) < 10 then
132010: LD_VAR 0 4
132014: PUSH
132015: LD_VAR 0 7
132019: ARRAY
132020: PPUSH
132021: CALL_OW 261
132025: PUSH
132026: LD_INT 10
132028: LESS
132029: IFFALSE 132049
// SetFuel ( group [ i ] , 12 ) ;
132031: LD_VAR 0 4
132035: PUSH
132036: LD_VAR 0 7
132040: ARRAY
132041: PPUSH
132042: LD_INT 12
132044: PPUSH
132045: CALL_OW 240
// if units_path [ i ] then
132049: LD_VAR 0 16
132053: PUSH
132054: LD_VAR 0 7
132058: ARRAY
132059: IFFALSE 132244
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
132061: LD_VAR 0 4
132065: PUSH
132066: LD_VAR 0 7
132070: ARRAY
132071: PPUSH
132072: LD_VAR 0 16
132076: PUSH
132077: LD_VAR 0 7
132081: ARRAY
132082: PUSH
132083: LD_INT 1
132085: ARRAY
132086: PUSH
132087: LD_INT 1
132089: ARRAY
132090: PPUSH
132091: LD_VAR 0 16
132095: PUSH
132096: LD_VAR 0 7
132100: ARRAY
132101: PUSH
132102: LD_INT 1
132104: ARRAY
132105: PUSH
132106: LD_INT 2
132108: ARRAY
132109: PPUSH
132110: CALL_OW 297
132114: PUSH
132115: LD_INT 6
132117: GREATER
132118: IFFALSE 132193
// begin if not HasTask ( group [ i ] ) then
132120: LD_VAR 0 4
132124: PUSH
132125: LD_VAR 0 7
132129: ARRAY
132130: PPUSH
132131: CALL_OW 314
132135: NOT
132136: IFFALSE 132191
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
132138: LD_VAR 0 4
132142: PUSH
132143: LD_VAR 0 7
132147: ARRAY
132148: PPUSH
132149: LD_VAR 0 16
132153: PUSH
132154: LD_VAR 0 7
132158: ARRAY
132159: PUSH
132160: LD_INT 1
132162: ARRAY
132163: PUSH
132164: LD_INT 1
132166: ARRAY
132167: PPUSH
132168: LD_VAR 0 16
132172: PUSH
132173: LD_VAR 0 7
132177: ARRAY
132178: PUSH
132179: LD_INT 1
132181: ARRAY
132182: PUSH
132183: LD_INT 2
132185: ARRAY
132186: PPUSH
132187: CALL_OW 114
// end else
132191: GO 132244
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
132193: LD_ADDR_VAR 0 15
132197: PUSH
132198: LD_VAR 0 16
132202: PUSH
132203: LD_VAR 0 7
132207: ARRAY
132208: PPUSH
132209: LD_INT 1
132211: PPUSH
132212: CALL_OW 3
132216: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
132217: LD_ADDR_VAR 0 16
132221: PUSH
132222: LD_VAR 0 16
132226: PPUSH
132227: LD_VAR 0 7
132231: PPUSH
132232: LD_VAR 0 15
132236: PPUSH
132237: CALL_OW 1
132241: ST_TO_ADDR
// continue ;
132242: GO 130787
// end ; end ; end else
132244: GO 134908
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
132246: LD_ADDR_VAR 0 14
132250: PUSH
132251: LD_INT 81
132253: PUSH
132254: LD_VAR 0 4
132258: PUSH
132259: LD_VAR 0 7
132263: ARRAY
132264: PPUSH
132265: CALL_OW 255
132269: PUSH
132270: EMPTY
132271: LIST
132272: LIST
132273: PPUSH
132274: CALL_OW 69
132278: ST_TO_ADDR
// if not tmp then
132279: LD_VAR 0 14
132283: NOT
132284: IFFALSE 132288
// continue ;
132286: GO 130787
// if f_ignore_area then
132288: LD_VAR 0 17
132292: IFFALSE 132380
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
132294: LD_ADDR_VAR 0 15
132298: PUSH
132299: LD_VAR 0 14
132303: PPUSH
132304: LD_INT 3
132306: PUSH
132307: LD_INT 92
132309: PUSH
132310: LD_VAR 0 17
132314: PUSH
132315: LD_INT 1
132317: ARRAY
132318: PUSH
132319: LD_VAR 0 17
132323: PUSH
132324: LD_INT 2
132326: ARRAY
132327: PUSH
132328: LD_VAR 0 17
132332: PUSH
132333: LD_INT 3
132335: ARRAY
132336: PUSH
132337: EMPTY
132338: LIST
132339: LIST
132340: LIST
132341: LIST
132342: PUSH
132343: EMPTY
132344: LIST
132345: LIST
132346: PPUSH
132347: CALL_OW 72
132351: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
132352: LD_VAR 0 14
132356: PUSH
132357: LD_VAR 0 15
132361: DIFF
132362: IFFALSE 132380
// tmp := tmp diff tmp2 ;
132364: LD_ADDR_VAR 0 14
132368: PUSH
132369: LD_VAR 0 14
132373: PUSH
132374: LD_VAR 0 15
132378: DIFF
132379: ST_TO_ADDR
// end ; if not f_murder then
132380: LD_VAR 0 20
132384: NOT
132385: IFFALSE 132443
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
132387: LD_ADDR_VAR 0 15
132391: PUSH
132392: LD_VAR 0 14
132396: PPUSH
132397: LD_INT 3
132399: PUSH
132400: LD_INT 50
132402: PUSH
132403: EMPTY
132404: LIST
132405: PUSH
132406: EMPTY
132407: LIST
132408: LIST
132409: PPUSH
132410: CALL_OW 72
132414: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
132415: LD_VAR 0 14
132419: PUSH
132420: LD_VAR 0 15
132424: DIFF
132425: IFFALSE 132443
// tmp := tmp diff tmp2 ;
132427: LD_ADDR_VAR 0 14
132431: PUSH
132432: LD_VAR 0 14
132436: PUSH
132437: LD_VAR 0 15
132441: DIFF
132442: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
132443: LD_ADDR_VAR 0 14
132447: PUSH
132448: LD_VAR 0 4
132452: PUSH
132453: LD_VAR 0 7
132457: ARRAY
132458: PPUSH
132459: LD_VAR 0 14
132463: PPUSH
132464: LD_INT 1
132466: PPUSH
132467: LD_INT 1
132469: PPUSH
132470: CALL 74192 0 4
132474: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
132475: LD_VAR 0 4
132479: PUSH
132480: LD_VAR 0 7
132484: ARRAY
132485: PPUSH
132486: CALL_OW 257
132490: PUSH
132491: LD_INT 1
132493: EQUAL
132494: IFFALSE 132942
// begin if WantPlant ( group [ i ] ) then
132496: LD_VAR 0 4
132500: PUSH
132501: LD_VAR 0 7
132505: ARRAY
132506: PPUSH
132507: CALL 73693 0 1
132511: IFFALSE 132515
// continue ;
132513: GO 130787
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
132515: LD_VAR 0 18
132519: PUSH
132520: LD_VAR 0 4
132524: PUSH
132525: LD_VAR 0 7
132529: ARRAY
132530: PPUSH
132531: CALL_OW 310
132535: NOT
132536: AND
132537: PUSH
132538: LD_VAR 0 14
132542: PUSH
132543: LD_INT 1
132545: ARRAY
132546: PUSH
132547: LD_VAR 0 14
132551: PPUSH
132552: LD_INT 21
132554: PUSH
132555: LD_INT 2
132557: PUSH
132558: EMPTY
132559: LIST
132560: LIST
132561: PUSH
132562: LD_INT 58
132564: PUSH
132565: EMPTY
132566: LIST
132567: PUSH
132568: EMPTY
132569: LIST
132570: LIST
132571: PPUSH
132572: CALL_OW 72
132576: IN
132577: AND
132578: IFFALSE 132614
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
132580: LD_VAR 0 4
132584: PUSH
132585: LD_VAR 0 7
132589: ARRAY
132590: PPUSH
132591: LD_VAR 0 14
132595: PUSH
132596: LD_INT 1
132598: ARRAY
132599: PPUSH
132600: CALL_OW 120
// attacking := true ;
132604: LD_ADDR_VAR 0 29
132608: PUSH
132609: LD_INT 1
132611: ST_TO_ADDR
// continue ;
132612: GO 130787
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
132614: LD_VAR 0 26
132618: PUSH
132619: LD_VAR 0 4
132623: PUSH
132624: LD_VAR 0 7
132628: ARRAY
132629: PPUSH
132630: CALL_OW 257
132634: PUSH
132635: LD_INT 1
132637: EQUAL
132638: AND
132639: PUSH
132640: LD_VAR 0 4
132644: PUSH
132645: LD_VAR 0 7
132649: ARRAY
132650: PPUSH
132651: CALL_OW 256
132655: PUSH
132656: LD_INT 800
132658: LESS
132659: AND
132660: PUSH
132661: LD_VAR 0 4
132665: PUSH
132666: LD_VAR 0 7
132670: ARRAY
132671: PPUSH
132672: CALL_OW 318
132676: NOT
132677: AND
132678: IFFALSE 132695
// ComCrawl ( group [ i ] ) ;
132680: LD_VAR 0 4
132684: PUSH
132685: LD_VAR 0 7
132689: ARRAY
132690: PPUSH
132691: CALL_OW 137
// if f_mines then
132695: LD_VAR 0 21
132699: IFFALSE 132942
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
132701: LD_VAR 0 14
132705: PUSH
132706: LD_INT 1
132708: ARRAY
132709: PPUSH
132710: CALL_OW 247
132714: PUSH
132715: LD_INT 3
132717: EQUAL
132718: PUSH
132719: LD_VAR 0 14
132723: PUSH
132724: LD_INT 1
132726: ARRAY
132727: PUSH
132728: LD_VAR 0 27
132732: IN
132733: NOT
132734: AND
132735: IFFALSE 132942
// begin x := GetX ( tmp [ 1 ] ) ;
132737: LD_ADDR_VAR 0 10
132741: PUSH
132742: LD_VAR 0 14
132746: PUSH
132747: LD_INT 1
132749: ARRAY
132750: PPUSH
132751: CALL_OW 250
132755: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
132756: LD_ADDR_VAR 0 11
132760: PUSH
132761: LD_VAR 0 14
132765: PUSH
132766: LD_INT 1
132768: ARRAY
132769: PPUSH
132770: CALL_OW 251
132774: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
132775: LD_ADDR_VAR 0 12
132779: PUSH
132780: LD_VAR 0 4
132784: PUSH
132785: LD_VAR 0 7
132789: ARRAY
132790: PPUSH
132791: CALL 101336 0 1
132795: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
132796: LD_VAR 0 4
132800: PUSH
132801: LD_VAR 0 7
132805: ARRAY
132806: PPUSH
132807: LD_VAR 0 10
132811: PPUSH
132812: LD_VAR 0 11
132816: PPUSH
132817: LD_VAR 0 14
132821: PUSH
132822: LD_INT 1
132824: ARRAY
132825: PPUSH
132826: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
132830: LD_VAR 0 4
132834: PUSH
132835: LD_VAR 0 7
132839: ARRAY
132840: PPUSH
132841: LD_VAR 0 10
132845: PPUSH
132846: LD_VAR 0 12
132850: PPUSH
132851: LD_INT 7
132853: PPUSH
132854: CALL_OW 272
132858: PPUSH
132859: LD_VAR 0 11
132863: PPUSH
132864: LD_VAR 0 12
132868: PPUSH
132869: LD_INT 7
132871: PPUSH
132872: CALL_OW 273
132876: PPUSH
132877: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
132881: LD_VAR 0 4
132885: PUSH
132886: LD_VAR 0 7
132890: ARRAY
132891: PPUSH
132892: LD_INT 71
132894: PPUSH
132895: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
132899: LD_ADDR_VAR 0 27
132903: PUSH
132904: LD_VAR 0 27
132908: PPUSH
132909: LD_VAR 0 27
132913: PUSH
132914: LD_INT 1
132916: PLUS
132917: PPUSH
132918: LD_VAR 0 14
132922: PUSH
132923: LD_INT 1
132925: ARRAY
132926: PPUSH
132927: CALL_OW 1
132931: ST_TO_ADDR
// attacking := true ;
132932: LD_ADDR_VAR 0 29
132936: PUSH
132937: LD_INT 1
132939: ST_TO_ADDR
// continue ;
132940: GO 130787
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
132942: LD_VAR 0 4
132946: PUSH
132947: LD_VAR 0 7
132951: ARRAY
132952: PPUSH
132953: CALL_OW 257
132957: PUSH
132958: LD_INT 17
132960: EQUAL
132961: PUSH
132962: LD_VAR 0 4
132966: PUSH
132967: LD_VAR 0 7
132971: ARRAY
132972: PPUSH
132973: CALL_OW 110
132977: PUSH
132978: LD_INT 71
132980: EQUAL
132981: NOT
132982: AND
132983: IFFALSE 133129
// begin attacking := false ;
132985: LD_ADDR_VAR 0 29
132989: PUSH
132990: LD_INT 0
132992: ST_TO_ADDR
// k := 5 ;
132993: LD_ADDR_VAR 0 9
132997: PUSH
132998: LD_INT 5
133000: ST_TO_ADDR
// if tmp < k then
133001: LD_VAR 0 14
133005: PUSH
133006: LD_VAR 0 9
133010: LESS
133011: IFFALSE 133023
// k := tmp ;
133013: LD_ADDR_VAR 0 9
133017: PUSH
133018: LD_VAR 0 14
133022: ST_TO_ADDR
// for j = 1 to k do
133023: LD_ADDR_VAR 0 8
133027: PUSH
133028: DOUBLE
133029: LD_INT 1
133031: DEC
133032: ST_TO_ADDR
133033: LD_VAR 0 9
133037: PUSH
133038: FOR_TO
133039: IFFALSE 133127
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
133041: LD_VAR 0 14
133045: PUSH
133046: LD_VAR 0 8
133050: ARRAY
133051: PUSH
133052: LD_VAR 0 14
133056: PPUSH
133057: LD_INT 58
133059: PUSH
133060: EMPTY
133061: LIST
133062: PPUSH
133063: CALL_OW 72
133067: IN
133068: NOT
133069: IFFALSE 133125
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133071: LD_VAR 0 4
133075: PUSH
133076: LD_VAR 0 7
133080: ARRAY
133081: PPUSH
133082: LD_VAR 0 14
133086: PUSH
133087: LD_VAR 0 8
133091: ARRAY
133092: PPUSH
133093: CALL_OW 115
// attacking := true ;
133097: LD_ADDR_VAR 0 29
133101: PUSH
133102: LD_INT 1
133104: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
133105: LD_VAR 0 4
133109: PUSH
133110: LD_VAR 0 7
133114: ARRAY
133115: PPUSH
133116: LD_INT 71
133118: PPUSH
133119: CALL_OW 109
// continue ;
133123: GO 133038
// end ; end ;
133125: GO 133038
133127: POP
133128: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
133129: LD_VAR 0 4
133133: PUSH
133134: LD_VAR 0 7
133138: ARRAY
133139: PPUSH
133140: CALL_OW 257
133144: PUSH
133145: LD_INT 8
133147: EQUAL
133148: PUSH
133149: LD_VAR 0 4
133153: PUSH
133154: LD_VAR 0 7
133158: ARRAY
133159: PPUSH
133160: CALL_OW 264
133164: PUSH
133165: LD_INT 28
133167: PUSH
133168: LD_INT 45
133170: PUSH
133171: LD_INT 7
133173: PUSH
133174: LD_INT 47
133176: PUSH
133177: EMPTY
133178: LIST
133179: LIST
133180: LIST
133181: LIST
133182: IN
133183: OR
133184: IFFALSE 133440
// begin attacking := false ;
133186: LD_ADDR_VAR 0 29
133190: PUSH
133191: LD_INT 0
133193: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
133194: LD_VAR 0 14
133198: PUSH
133199: LD_INT 1
133201: ARRAY
133202: PPUSH
133203: CALL_OW 266
133207: PUSH
133208: LD_INT 32
133210: PUSH
133211: LD_INT 31
133213: PUSH
133214: LD_INT 33
133216: PUSH
133217: LD_INT 4
133219: PUSH
133220: LD_INT 5
133222: PUSH
133223: EMPTY
133224: LIST
133225: LIST
133226: LIST
133227: LIST
133228: LIST
133229: IN
133230: IFFALSE 133416
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
133232: LD_ADDR_VAR 0 9
133236: PUSH
133237: LD_VAR 0 14
133241: PUSH
133242: LD_INT 1
133244: ARRAY
133245: PPUSH
133246: CALL_OW 266
133250: PPUSH
133251: LD_VAR 0 14
133255: PUSH
133256: LD_INT 1
133258: ARRAY
133259: PPUSH
133260: CALL_OW 250
133264: PPUSH
133265: LD_VAR 0 14
133269: PUSH
133270: LD_INT 1
133272: ARRAY
133273: PPUSH
133274: CALL_OW 251
133278: PPUSH
133279: LD_VAR 0 14
133283: PUSH
133284: LD_INT 1
133286: ARRAY
133287: PPUSH
133288: CALL_OW 254
133292: PPUSH
133293: LD_VAR 0 14
133297: PUSH
133298: LD_INT 1
133300: ARRAY
133301: PPUSH
133302: CALL_OW 248
133306: PPUSH
133307: LD_INT 0
133309: PPUSH
133310: CALL 82706 0 6
133314: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
133315: LD_ADDR_VAR 0 8
133319: PUSH
133320: LD_VAR 0 4
133324: PUSH
133325: LD_VAR 0 7
133329: ARRAY
133330: PPUSH
133331: LD_VAR 0 9
133335: PPUSH
133336: CALL 101449 0 2
133340: ST_TO_ADDR
// if j then
133341: LD_VAR 0 8
133345: IFFALSE 133414
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
133347: LD_VAR 0 8
133351: PUSH
133352: LD_INT 1
133354: ARRAY
133355: PPUSH
133356: LD_VAR 0 8
133360: PUSH
133361: LD_INT 2
133363: ARRAY
133364: PPUSH
133365: CALL_OW 488
133369: IFFALSE 133414
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
133371: LD_VAR 0 4
133375: PUSH
133376: LD_VAR 0 7
133380: ARRAY
133381: PPUSH
133382: LD_VAR 0 8
133386: PUSH
133387: LD_INT 1
133389: ARRAY
133390: PPUSH
133391: LD_VAR 0 8
133395: PUSH
133396: LD_INT 2
133398: ARRAY
133399: PPUSH
133400: CALL_OW 116
// attacking := true ;
133404: LD_ADDR_VAR 0 29
133408: PUSH
133409: LD_INT 1
133411: ST_TO_ADDR
// continue ;
133412: GO 130787
// end ; end else
133414: GO 133440
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133416: LD_VAR 0 4
133420: PUSH
133421: LD_VAR 0 7
133425: ARRAY
133426: PPUSH
133427: LD_VAR 0 14
133431: PUSH
133432: LD_INT 1
133434: ARRAY
133435: PPUSH
133436: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
133440: LD_VAR 0 4
133444: PUSH
133445: LD_VAR 0 7
133449: ARRAY
133450: PPUSH
133451: CALL_OW 265
133455: PUSH
133456: LD_INT 11
133458: EQUAL
133459: IFFALSE 133737
// begin k := 10 ;
133461: LD_ADDR_VAR 0 9
133465: PUSH
133466: LD_INT 10
133468: ST_TO_ADDR
// x := 0 ;
133469: LD_ADDR_VAR 0 10
133473: PUSH
133474: LD_INT 0
133476: ST_TO_ADDR
// if tmp < k then
133477: LD_VAR 0 14
133481: PUSH
133482: LD_VAR 0 9
133486: LESS
133487: IFFALSE 133499
// k := tmp ;
133489: LD_ADDR_VAR 0 9
133493: PUSH
133494: LD_VAR 0 14
133498: ST_TO_ADDR
// for j = k downto 1 do
133499: LD_ADDR_VAR 0 8
133503: PUSH
133504: DOUBLE
133505: LD_VAR 0 9
133509: INC
133510: ST_TO_ADDR
133511: LD_INT 1
133513: PUSH
133514: FOR_DOWNTO
133515: IFFALSE 133590
// begin if GetType ( tmp [ j ] ) = unit_human then
133517: LD_VAR 0 14
133521: PUSH
133522: LD_VAR 0 8
133526: ARRAY
133527: PPUSH
133528: CALL_OW 247
133532: PUSH
133533: LD_INT 1
133535: EQUAL
133536: IFFALSE 133588
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
133538: LD_VAR 0 4
133542: PUSH
133543: LD_VAR 0 7
133547: ARRAY
133548: PPUSH
133549: LD_VAR 0 14
133553: PUSH
133554: LD_VAR 0 8
133558: ARRAY
133559: PPUSH
133560: CALL 101703 0 2
// x := tmp [ j ] ;
133564: LD_ADDR_VAR 0 10
133568: PUSH
133569: LD_VAR 0 14
133573: PUSH
133574: LD_VAR 0 8
133578: ARRAY
133579: ST_TO_ADDR
// attacking := true ;
133580: LD_ADDR_VAR 0 29
133584: PUSH
133585: LD_INT 1
133587: ST_TO_ADDR
// end ; end ;
133588: GO 133514
133590: POP
133591: POP
// if not x then
133592: LD_VAR 0 10
133596: NOT
133597: IFFALSE 133737
// begin attacking := true ;
133599: LD_ADDR_VAR 0 29
133603: PUSH
133604: LD_INT 1
133606: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
133607: LD_VAR 0 4
133611: PUSH
133612: LD_VAR 0 7
133616: ARRAY
133617: PPUSH
133618: CALL_OW 250
133622: PPUSH
133623: LD_VAR 0 4
133627: PUSH
133628: LD_VAR 0 7
133632: ARRAY
133633: PPUSH
133634: CALL_OW 251
133638: PPUSH
133639: CALL_OW 546
133643: PUSH
133644: LD_INT 2
133646: ARRAY
133647: PUSH
133648: LD_VAR 0 14
133652: PUSH
133653: LD_INT 1
133655: ARRAY
133656: PPUSH
133657: CALL_OW 250
133661: PPUSH
133662: LD_VAR 0 14
133666: PUSH
133667: LD_INT 1
133669: ARRAY
133670: PPUSH
133671: CALL_OW 251
133675: PPUSH
133676: CALL_OW 546
133680: PUSH
133681: LD_INT 2
133683: ARRAY
133684: EQUAL
133685: IFFALSE 133713
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
133687: LD_VAR 0 4
133691: PUSH
133692: LD_VAR 0 7
133696: ARRAY
133697: PPUSH
133698: LD_VAR 0 14
133702: PUSH
133703: LD_INT 1
133705: ARRAY
133706: PPUSH
133707: CALL 101703 0 2
133711: GO 133737
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133713: LD_VAR 0 4
133717: PUSH
133718: LD_VAR 0 7
133722: ARRAY
133723: PPUSH
133724: LD_VAR 0 14
133728: PUSH
133729: LD_INT 1
133731: ARRAY
133732: PPUSH
133733: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
133737: LD_VAR 0 4
133741: PUSH
133742: LD_VAR 0 7
133746: ARRAY
133747: PPUSH
133748: CALL_OW 264
133752: PUSH
133753: LD_INT 29
133755: EQUAL
133756: IFFALSE 134122
// begin if WantsToAttack ( group [ i ] ) in bombed then
133758: LD_VAR 0 4
133762: PUSH
133763: LD_VAR 0 7
133767: ARRAY
133768: PPUSH
133769: CALL_OW 319
133773: PUSH
133774: LD_VAR 0 28
133778: IN
133779: IFFALSE 133783
// continue ;
133781: GO 130787
// k := 8 ;
133783: LD_ADDR_VAR 0 9
133787: PUSH
133788: LD_INT 8
133790: ST_TO_ADDR
// x := 0 ;
133791: LD_ADDR_VAR 0 10
133795: PUSH
133796: LD_INT 0
133798: ST_TO_ADDR
// if tmp < k then
133799: LD_VAR 0 14
133803: PUSH
133804: LD_VAR 0 9
133808: LESS
133809: IFFALSE 133821
// k := tmp ;
133811: LD_ADDR_VAR 0 9
133815: PUSH
133816: LD_VAR 0 14
133820: ST_TO_ADDR
// for j = 1 to k do
133821: LD_ADDR_VAR 0 8
133825: PUSH
133826: DOUBLE
133827: LD_INT 1
133829: DEC
133830: ST_TO_ADDR
133831: LD_VAR 0 9
133835: PUSH
133836: FOR_TO
133837: IFFALSE 133969
// begin if GetType ( tmp [ j ] ) = unit_building then
133839: LD_VAR 0 14
133843: PUSH
133844: LD_VAR 0 8
133848: ARRAY
133849: PPUSH
133850: CALL_OW 247
133854: PUSH
133855: LD_INT 3
133857: EQUAL
133858: IFFALSE 133967
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
133860: LD_VAR 0 14
133864: PUSH
133865: LD_VAR 0 8
133869: ARRAY
133870: PUSH
133871: LD_VAR 0 28
133875: IN
133876: NOT
133877: PUSH
133878: LD_VAR 0 14
133882: PUSH
133883: LD_VAR 0 8
133887: ARRAY
133888: PPUSH
133889: CALL_OW 313
133893: AND
133894: IFFALSE 133967
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133896: LD_VAR 0 4
133900: PUSH
133901: LD_VAR 0 7
133905: ARRAY
133906: PPUSH
133907: LD_VAR 0 14
133911: PUSH
133912: LD_VAR 0 8
133916: ARRAY
133917: PPUSH
133918: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
133922: LD_ADDR_VAR 0 28
133926: PUSH
133927: LD_VAR 0 28
133931: PPUSH
133932: LD_VAR 0 28
133936: PUSH
133937: LD_INT 1
133939: PLUS
133940: PPUSH
133941: LD_VAR 0 14
133945: PUSH
133946: LD_VAR 0 8
133950: ARRAY
133951: PPUSH
133952: CALL_OW 1
133956: ST_TO_ADDR
// attacking := true ;
133957: LD_ADDR_VAR 0 29
133961: PUSH
133962: LD_INT 1
133964: ST_TO_ADDR
// break ;
133965: GO 133969
// end ; end ;
133967: GO 133836
133969: POP
133970: POP
// if not attacking and f_attack_depot then
133971: LD_VAR 0 29
133975: NOT
133976: PUSH
133977: LD_VAR 0 25
133981: AND
133982: IFFALSE 134077
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
133984: LD_ADDR_VAR 0 13
133988: PUSH
133989: LD_VAR 0 14
133993: PPUSH
133994: LD_INT 2
133996: PUSH
133997: LD_INT 30
133999: PUSH
134000: LD_INT 0
134002: PUSH
134003: EMPTY
134004: LIST
134005: LIST
134006: PUSH
134007: LD_INT 30
134009: PUSH
134010: LD_INT 1
134012: PUSH
134013: EMPTY
134014: LIST
134015: LIST
134016: PUSH
134017: EMPTY
134018: LIST
134019: LIST
134020: LIST
134021: PPUSH
134022: CALL_OW 72
134026: ST_TO_ADDR
// if z then
134027: LD_VAR 0 13
134031: IFFALSE 134077
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
134033: LD_VAR 0 4
134037: PUSH
134038: LD_VAR 0 7
134042: ARRAY
134043: PPUSH
134044: LD_VAR 0 13
134048: PPUSH
134049: LD_VAR 0 4
134053: PUSH
134054: LD_VAR 0 7
134058: ARRAY
134059: PPUSH
134060: CALL_OW 74
134064: PPUSH
134065: CALL_OW 115
// attacking := true ;
134069: LD_ADDR_VAR 0 29
134073: PUSH
134074: LD_INT 1
134076: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
134077: LD_VAR 0 4
134081: PUSH
134082: LD_VAR 0 7
134086: ARRAY
134087: PPUSH
134088: CALL_OW 256
134092: PUSH
134093: LD_INT 500
134095: LESS
134096: IFFALSE 134122
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134098: LD_VAR 0 4
134102: PUSH
134103: LD_VAR 0 7
134107: ARRAY
134108: PPUSH
134109: LD_VAR 0 14
134113: PUSH
134114: LD_INT 1
134116: ARRAY
134117: PPUSH
134118: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
134122: LD_VAR 0 4
134126: PUSH
134127: LD_VAR 0 7
134131: ARRAY
134132: PPUSH
134133: CALL_OW 264
134137: PUSH
134138: LD_INT 49
134140: EQUAL
134141: IFFALSE 134262
// begin if not HasTask ( group [ i ] ) then
134143: LD_VAR 0 4
134147: PUSH
134148: LD_VAR 0 7
134152: ARRAY
134153: PPUSH
134154: CALL_OW 314
134158: NOT
134159: IFFALSE 134262
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
134161: LD_ADDR_VAR 0 9
134165: PUSH
134166: LD_INT 81
134168: PUSH
134169: LD_VAR 0 4
134173: PUSH
134174: LD_VAR 0 7
134178: ARRAY
134179: PPUSH
134180: CALL_OW 255
134184: PUSH
134185: EMPTY
134186: LIST
134187: LIST
134188: PPUSH
134189: CALL_OW 69
134193: PPUSH
134194: LD_VAR 0 4
134198: PUSH
134199: LD_VAR 0 7
134203: ARRAY
134204: PPUSH
134205: CALL_OW 74
134209: ST_TO_ADDR
// if k then
134210: LD_VAR 0 9
134214: IFFALSE 134262
// if GetDistUnits ( group [ i ] , k ) > 10 then
134216: LD_VAR 0 4
134220: PUSH
134221: LD_VAR 0 7
134225: ARRAY
134226: PPUSH
134227: LD_VAR 0 9
134231: PPUSH
134232: CALL_OW 296
134236: PUSH
134237: LD_INT 10
134239: GREATER
134240: IFFALSE 134262
// ComMoveUnit ( group [ i ] , k ) ;
134242: LD_VAR 0 4
134246: PUSH
134247: LD_VAR 0 7
134251: ARRAY
134252: PPUSH
134253: LD_VAR 0 9
134257: PPUSH
134258: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
134262: LD_VAR 0 4
134266: PUSH
134267: LD_VAR 0 7
134271: ARRAY
134272: PPUSH
134273: CALL_OW 256
134277: PUSH
134278: LD_INT 250
134280: LESS
134281: PUSH
134282: LD_VAR 0 4
134286: PUSH
134287: LD_VAR 0 7
134291: ARRAY
134292: PUSH
134293: LD_INT 21
134295: PUSH
134296: LD_INT 2
134298: PUSH
134299: EMPTY
134300: LIST
134301: LIST
134302: PUSH
134303: LD_INT 23
134305: PUSH
134306: LD_INT 2
134308: PUSH
134309: EMPTY
134310: LIST
134311: LIST
134312: PUSH
134313: EMPTY
134314: LIST
134315: LIST
134316: PPUSH
134317: CALL_OW 69
134321: IN
134322: AND
134323: IFFALSE 134448
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
134325: LD_ADDR_VAR 0 9
134329: PUSH
134330: LD_OWVAR 3
134334: PUSH
134335: LD_VAR 0 4
134339: PUSH
134340: LD_VAR 0 7
134344: ARRAY
134345: DIFF
134346: PPUSH
134347: LD_VAR 0 4
134351: PUSH
134352: LD_VAR 0 7
134356: ARRAY
134357: PPUSH
134358: CALL_OW 74
134362: ST_TO_ADDR
// if not k then
134363: LD_VAR 0 9
134367: NOT
134368: IFFALSE 134372
// continue ;
134370: GO 130787
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
134372: LD_VAR 0 9
134376: PUSH
134377: LD_INT 81
134379: PUSH
134380: LD_VAR 0 4
134384: PUSH
134385: LD_VAR 0 7
134389: ARRAY
134390: PPUSH
134391: CALL_OW 255
134395: PUSH
134396: EMPTY
134397: LIST
134398: LIST
134399: PPUSH
134400: CALL_OW 69
134404: IN
134405: PUSH
134406: LD_VAR 0 9
134410: PPUSH
134411: LD_VAR 0 4
134415: PUSH
134416: LD_VAR 0 7
134420: ARRAY
134421: PPUSH
134422: CALL_OW 296
134426: PUSH
134427: LD_INT 5
134429: LESS
134430: AND
134431: IFFALSE 134448
// ComAutodestruct ( group [ i ] ) ;
134433: LD_VAR 0 4
134437: PUSH
134438: LD_VAR 0 7
134442: ARRAY
134443: PPUSH
134444: CALL 101601 0 1
// end ; if f_attack_depot then
134448: LD_VAR 0 25
134452: IFFALSE 134564
// begin k := 6 ;
134454: LD_ADDR_VAR 0 9
134458: PUSH
134459: LD_INT 6
134461: ST_TO_ADDR
// if tmp < k then
134462: LD_VAR 0 14
134466: PUSH
134467: LD_VAR 0 9
134471: LESS
134472: IFFALSE 134484
// k := tmp ;
134474: LD_ADDR_VAR 0 9
134478: PUSH
134479: LD_VAR 0 14
134483: ST_TO_ADDR
// for j = 1 to k do
134484: LD_ADDR_VAR 0 8
134488: PUSH
134489: DOUBLE
134490: LD_INT 1
134492: DEC
134493: ST_TO_ADDR
134494: LD_VAR 0 9
134498: PUSH
134499: FOR_TO
134500: IFFALSE 134562
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
134502: LD_VAR 0 8
134506: PPUSH
134507: CALL_OW 266
134511: PUSH
134512: LD_INT 0
134514: PUSH
134515: LD_INT 1
134517: PUSH
134518: EMPTY
134519: LIST
134520: LIST
134521: IN
134522: IFFALSE 134560
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
134524: LD_VAR 0 4
134528: PUSH
134529: LD_VAR 0 7
134533: ARRAY
134534: PPUSH
134535: LD_VAR 0 14
134539: PUSH
134540: LD_VAR 0 8
134544: ARRAY
134545: PPUSH
134546: CALL_OW 115
// attacking := true ;
134550: LD_ADDR_VAR 0 29
134554: PUSH
134555: LD_INT 1
134557: ST_TO_ADDR
// break ;
134558: GO 134562
// end ;
134560: GO 134499
134562: POP
134563: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
134564: LD_VAR 0 4
134568: PUSH
134569: LD_VAR 0 7
134573: ARRAY
134574: PPUSH
134575: CALL_OW 302
134579: PUSH
134580: LD_VAR 0 29
134584: NOT
134585: AND
134586: IFFALSE 134908
// begin if GetTag ( group [ i ] ) = 71 then
134588: LD_VAR 0 4
134592: PUSH
134593: LD_VAR 0 7
134597: ARRAY
134598: PPUSH
134599: CALL_OW 110
134603: PUSH
134604: LD_INT 71
134606: EQUAL
134607: IFFALSE 134648
// begin if HasTask ( group [ i ] ) then
134609: LD_VAR 0 4
134613: PUSH
134614: LD_VAR 0 7
134618: ARRAY
134619: PPUSH
134620: CALL_OW 314
134624: IFFALSE 134630
// continue else
134626: GO 130787
134628: GO 134648
// SetTag ( group [ i ] , 0 ) ;
134630: LD_VAR 0 4
134634: PUSH
134635: LD_VAR 0 7
134639: ARRAY
134640: PPUSH
134641: LD_INT 0
134643: PPUSH
134644: CALL_OW 109
// end ; k := 8 ;
134648: LD_ADDR_VAR 0 9
134652: PUSH
134653: LD_INT 8
134655: ST_TO_ADDR
// x := 0 ;
134656: LD_ADDR_VAR 0 10
134660: PUSH
134661: LD_INT 0
134663: ST_TO_ADDR
// if tmp < k then
134664: LD_VAR 0 14
134668: PUSH
134669: LD_VAR 0 9
134673: LESS
134674: IFFALSE 134686
// k := tmp ;
134676: LD_ADDR_VAR 0 9
134680: PUSH
134681: LD_VAR 0 14
134685: ST_TO_ADDR
// for j = 1 to k do
134686: LD_ADDR_VAR 0 8
134690: PUSH
134691: DOUBLE
134692: LD_INT 1
134694: DEC
134695: ST_TO_ADDR
134696: LD_VAR 0 9
134700: PUSH
134701: FOR_TO
134702: IFFALSE 134800
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
134704: LD_VAR 0 14
134708: PUSH
134709: LD_VAR 0 8
134713: ARRAY
134714: PPUSH
134715: CALL_OW 247
134719: PUSH
134720: LD_INT 1
134722: EQUAL
134723: PUSH
134724: LD_VAR 0 14
134728: PUSH
134729: LD_VAR 0 8
134733: ARRAY
134734: PPUSH
134735: CALL_OW 256
134739: PUSH
134740: LD_INT 250
134742: LESS
134743: PUSH
134744: LD_VAR 0 20
134748: AND
134749: PUSH
134750: LD_VAR 0 20
134754: NOT
134755: PUSH
134756: LD_VAR 0 14
134760: PUSH
134761: LD_VAR 0 8
134765: ARRAY
134766: PPUSH
134767: CALL_OW 256
134771: PUSH
134772: LD_INT 250
134774: GREATEREQUAL
134775: AND
134776: OR
134777: AND
134778: IFFALSE 134798
// begin x := tmp [ j ] ;
134780: LD_ADDR_VAR 0 10
134784: PUSH
134785: LD_VAR 0 14
134789: PUSH
134790: LD_VAR 0 8
134794: ARRAY
134795: ST_TO_ADDR
// break ;
134796: GO 134800
// end ;
134798: GO 134701
134800: POP
134801: POP
// if x then
134802: LD_VAR 0 10
134806: IFFALSE 134830
// ComAttackUnit ( group [ i ] , x ) else
134808: LD_VAR 0 4
134812: PUSH
134813: LD_VAR 0 7
134817: ARRAY
134818: PPUSH
134819: LD_VAR 0 10
134823: PPUSH
134824: CALL_OW 115
134828: GO 134854
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134830: LD_VAR 0 4
134834: PUSH
134835: LD_VAR 0 7
134839: ARRAY
134840: PPUSH
134841: LD_VAR 0 14
134845: PUSH
134846: LD_INT 1
134848: ARRAY
134849: PPUSH
134850: CALL_OW 115
// if not HasTask ( group [ i ] ) then
134854: LD_VAR 0 4
134858: PUSH
134859: LD_VAR 0 7
134863: ARRAY
134864: PPUSH
134865: CALL_OW 314
134869: NOT
134870: IFFALSE 134908
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
134872: LD_VAR 0 4
134876: PUSH
134877: LD_VAR 0 7
134881: ARRAY
134882: PPUSH
134883: LD_VAR 0 14
134887: PPUSH
134888: LD_VAR 0 4
134892: PUSH
134893: LD_VAR 0 7
134897: ARRAY
134898: PPUSH
134899: CALL_OW 74
134903: PPUSH
134904: CALL_OW 115
// end ; end ; end ;
134908: GO 130787
134910: POP
134911: POP
// wait ( 0 0$2 ) ;
134912: LD_INT 70
134914: PPUSH
134915: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
134919: LD_VAR 0 4
134923: NOT
134924: PUSH
134925: LD_VAR 0 4
134929: PUSH
134930: EMPTY
134931: EQUAL
134932: OR
134933: PUSH
134934: LD_INT 81
134936: PUSH
134937: LD_VAR 0 35
134941: PUSH
134942: EMPTY
134943: LIST
134944: LIST
134945: PPUSH
134946: CALL_OW 69
134950: NOT
134951: OR
134952: IFFALSE 130772
// end ;
134954: LD_VAR 0 2
134958: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
134959: LD_INT 0
134961: PPUSH
134962: PPUSH
134963: PPUSH
134964: PPUSH
134965: PPUSH
134966: PPUSH
// if not base or not mc_bases [ base ] or not solds then
134967: LD_VAR 0 1
134971: NOT
134972: PUSH
134973: LD_EXP 100
134977: PUSH
134978: LD_VAR 0 1
134982: ARRAY
134983: NOT
134984: OR
134985: PUSH
134986: LD_VAR 0 2
134990: NOT
134991: OR
134992: IFFALSE 134996
// exit ;
134994: GO 135550
// side := mc_sides [ base ] ;
134996: LD_ADDR_VAR 0 6
135000: PUSH
135001: LD_EXP 126
135005: PUSH
135006: LD_VAR 0 1
135010: ARRAY
135011: ST_TO_ADDR
// if not side then
135012: LD_VAR 0 6
135016: NOT
135017: IFFALSE 135021
// exit ;
135019: GO 135550
// for i in solds do
135021: LD_ADDR_VAR 0 7
135025: PUSH
135026: LD_VAR 0 2
135030: PUSH
135031: FOR_IN
135032: IFFALSE 135093
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
135034: LD_VAR 0 7
135038: PPUSH
135039: CALL_OW 310
135043: PPUSH
135044: CALL_OW 266
135048: PUSH
135049: LD_INT 32
135051: PUSH
135052: LD_INT 31
135054: PUSH
135055: EMPTY
135056: LIST
135057: LIST
135058: IN
135059: IFFALSE 135079
// solds := solds diff i else
135061: LD_ADDR_VAR 0 2
135065: PUSH
135066: LD_VAR 0 2
135070: PUSH
135071: LD_VAR 0 7
135075: DIFF
135076: ST_TO_ADDR
135077: GO 135091
// SetTag ( i , 18 ) ;
135079: LD_VAR 0 7
135083: PPUSH
135084: LD_INT 18
135086: PPUSH
135087: CALL_OW 109
135091: GO 135031
135093: POP
135094: POP
// if not solds then
135095: LD_VAR 0 2
135099: NOT
135100: IFFALSE 135104
// exit ;
135102: GO 135550
// repeat wait ( 0 0$2 ) ;
135104: LD_INT 70
135106: PPUSH
135107: CALL_OW 67
// enemy := mc_scan [ base ] ;
135111: LD_ADDR_VAR 0 4
135115: PUSH
135116: LD_EXP 123
135120: PUSH
135121: LD_VAR 0 1
135125: ARRAY
135126: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135127: LD_EXP 100
135131: PUSH
135132: LD_VAR 0 1
135136: ARRAY
135137: NOT
135138: PUSH
135139: LD_EXP 100
135143: PUSH
135144: LD_VAR 0 1
135148: ARRAY
135149: PUSH
135150: EMPTY
135151: EQUAL
135152: OR
135153: IFFALSE 135190
// begin for i in solds do
135155: LD_ADDR_VAR 0 7
135159: PUSH
135160: LD_VAR 0 2
135164: PUSH
135165: FOR_IN
135166: IFFALSE 135179
// ComStop ( i ) ;
135168: LD_VAR 0 7
135172: PPUSH
135173: CALL_OW 141
135177: GO 135165
135179: POP
135180: POP
// solds := [ ] ;
135181: LD_ADDR_VAR 0 2
135185: PUSH
135186: EMPTY
135187: ST_TO_ADDR
// exit ;
135188: GO 135550
// end ; for i in solds do
135190: LD_ADDR_VAR 0 7
135194: PUSH
135195: LD_VAR 0 2
135199: PUSH
135200: FOR_IN
135201: IFFALSE 135522
// begin if IsInUnit ( i ) then
135203: LD_VAR 0 7
135207: PPUSH
135208: CALL_OW 310
135212: IFFALSE 135223
// ComExitBuilding ( i ) ;
135214: LD_VAR 0 7
135218: PPUSH
135219: CALL_OW 122
// if GetLives ( i ) > 500 then
135223: LD_VAR 0 7
135227: PPUSH
135228: CALL_OW 256
135232: PUSH
135233: LD_INT 500
135235: GREATER
135236: IFFALSE 135289
// begin e := NearestUnitToUnit ( enemy , i ) ;
135238: LD_ADDR_VAR 0 5
135242: PUSH
135243: LD_VAR 0 4
135247: PPUSH
135248: LD_VAR 0 7
135252: PPUSH
135253: CALL_OW 74
135257: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
135258: LD_VAR 0 7
135262: PPUSH
135263: LD_VAR 0 5
135267: PPUSH
135268: CALL_OW 250
135272: PPUSH
135273: LD_VAR 0 5
135277: PPUSH
135278: CALL_OW 251
135282: PPUSH
135283: CALL_OW 114
// end else
135287: GO 135520
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
135289: LD_VAR 0 7
135293: PPUSH
135294: LD_EXP 100
135298: PUSH
135299: LD_VAR 0 1
135303: ARRAY
135304: PPUSH
135305: LD_INT 2
135307: PUSH
135308: LD_INT 30
135310: PUSH
135311: LD_INT 0
135313: PUSH
135314: EMPTY
135315: LIST
135316: LIST
135317: PUSH
135318: LD_INT 30
135320: PUSH
135321: LD_INT 1
135323: PUSH
135324: EMPTY
135325: LIST
135326: LIST
135327: PUSH
135328: LD_INT 30
135330: PUSH
135331: LD_INT 6
135333: PUSH
135334: EMPTY
135335: LIST
135336: LIST
135337: PUSH
135338: EMPTY
135339: LIST
135340: LIST
135341: LIST
135342: LIST
135343: PPUSH
135344: CALL_OW 72
135348: PPUSH
135349: LD_VAR 0 7
135353: PPUSH
135354: CALL_OW 74
135358: PPUSH
135359: CALL_OW 296
135363: PUSH
135364: LD_INT 10
135366: GREATER
135367: IFFALSE 135520
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
135369: LD_ADDR_VAR 0 8
135373: PUSH
135374: LD_EXP 100
135378: PUSH
135379: LD_VAR 0 1
135383: ARRAY
135384: PPUSH
135385: LD_INT 2
135387: PUSH
135388: LD_INT 30
135390: PUSH
135391: LD_INT 0
135393: PUSH
135394: EMPTY
135395: LIST
135396: LIST
135397: PUSH
135398: LD_INT 30
135400: PUSH
135401: LD_INT 1
135403: PUSH
135404: EMPTY
135405: LIST
135406: LIST
135407: PUSH
135408: LD_INT 30
135410: PUSH
135411: LD_INT 6
135413: PUSH
135414: EMPTY
135415: LIST
135416: LIST
135417: PUSH
135418: EMPTY
135419: LIST
135420: LIST
135421: LIST
135422: LIST
135423: PPUSH
135424: CALL_OW 72
135428: PPUSH
135429: LD_VAR 0 7
135433: PPUSH
135434: CALL_OW 74
135438: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
135439: LD_VAR 0 7
135443: PPUSH
135444: LD_VAR 0 8
135448: PPUSH
135449: CALL_OW 250
135453: PPUSH
135454: LD_INT 3
135456: PPUSH
135457: LD_INT 5
135459: PPUSH
135460: CALL_OW 272
135464: PPUSH
135465: LD_VAR 0 8
135469: PPUSH
135470: CALL_OW 251
135474: PPUSH
135475: LD_INT 3
135477: PPUSH
135478: LD_INT 5
135480: PPUSH
135481: CALL_OW 273
135485: PPUSH
135486: CALL_OW 111
// SetTag ( i , 0 ) ;
135490: LD_VAR 0 7
135494: PPUSH
135495: LD_INT 0
135497: PPUSH
135498: CALL_OW 109
// solds := solds diff i ;
135502: LD_ADDR_VAR 0 2
135506: PUSH
135507: LD_VAR 0 2
135511: PUSH
135512: LD_VAR 0 7
135516: DIFF
135517: ST_TO_ADDR
// continue ;
135518: GO 135200
// end ; end ;
135520: GO 135200
135522: POP
135523: POP
// until not solds or not enemy ;
135524: LD_VAR 0 2
135528: NOT
135529: PUSH
135530: LD_VAR 0 4
135534: NOT
135535: OR
135536: IFFALSE 135104
// MC_Reset ( base , 18 ) ;
135538: LD_VAR 0 1
135542: PPUSH
135543: LD_INT 18
135545: PPUSH
135546: CALL 42270 0 2
// end ;
135550: LD_VAR 0 3
135554: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
135555: LD_INT 0
135557: PPUSH
135558: PPUSH
135559: PPUSH
135560: PPUSH
135561: PPUSH
135562: PPUSH
135563: PPUSH
135564: PPUSH
135565: PPUSH
135566: PPUSH
135567: PPUSH
135568: PPUSH
135569: PPUSH
135570: PPUSH
135571: PPUSH
135572: PPUSH
135573: PPUSH
135574: PPUSH
135575: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
135576: LD_ADDR_VAR 0 12
135580: PUSH
135581: LD_EXP 100
135585: PUSH
135586: LD_VAR 0 1
135590: ARRAY
135591: PPUSH
135592: LD_INT 25
135594: PUSH
135595: LD_INT 3
135597: PUSH
135598: EMPTY
135599: LIST
135600: LIST
135601: PPUSH
135602: CALL_OW 72
135606: ST_TO_ADDR
// if mc_remote_driver [ base ] then
135607: LD_EXP 140
135611: PUSH
135612: LD_VAR 0 1
135616: ARRAY
135617: IFFALSE 135641
// mechs := mechs diff mc_remote_driver [ base ] ;
135619: LD_ADDR_VAR 0 12
135623: PUSH
135624: LD_VAR 0 12
135628: PUSH
135629: LD_EXP 140
135633: PUSH
135634: LD_VAR 0 1
135638: ARRAY
135639: DIFF
135640: ST_TO_ADDR
// for i in mechs do
135641: LD_ADDR_VAR 0 4
135645: PUSH
135646: LD_VAR 0 12
135650: PUSH
135651: FOR_IN
135652: IFFALSE 135687
// if GetTag ( i ) > 0 then
135654: LD_VAR 0 4
135658: PPUSH
135659: CALL_OW 110
135663: PUSH
135664: LD_INT 0
135666: GREATER
135667: IFFALSE 135685
// mechs := mechs diff i ;
135669: LD_ADDR_VAR 0 12
135673: PUSH
135674: LD_VAR 0 12
135678: PUSH
135679: LD_VAR 0 4
135683: DIFF
135684: ST_TO_ADDR
135685: GO 135651
135687: POP
135688: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135689: LD_ADDR_VAR 0 8
135693: PUSH
135694: LD_EXP 100
135698: PUSH
135699: LD_VAR 0 1
135703: ARRAY
135704: PPUSH
135705: LD_INT 2
135707: PUSH
135708: LD_INT 25
135710: PUSH
135711: LD_INT 1
135713: PUSH
135714: EMPTY
135715: LIST
135716: LIST
135717: PUSH
135718: LD_INT 25
135720: PUSH
135721: LD_INT 5
135723: PUSH
135724: EMPTY
135725: LIST
135726: LIST
135727: PUSH
135728: LD_INT 25
135730: PUSH
135731: LD_INT 8
135733: PUSH
135734: EMPTY
135735: LIST
135736: LIST
135737: PUSH
135738: LD_INT 25
135740: PUSH
135741: LD_INT 9
135743: PUSH
135744: EMPTY
135745: LIST
135746: LIST
135747: PUSH
135748: EMPTY
135749: LIST
135750: LIST
135751: LIST
135752: LIST
135753: LIST
135754: PPUSH
135755: CALL_OW 72
135759: ST_TO_ADDR
// if not defenders and not solds then
135760: LD_VAR 0 2
135764: NOT
135765: PUSH
135766: LD_VAR 0 8
135770: NOT
135771: AND
135772: IFFALSE 135776
// exit ;
135774: GO 137546
// depot_under_attack := false ;
135776: LD_ADDR_VAR 0 16
135780: PUSH
135781: LD_INT 0
135783: ST_TO_ADDR
// sold_defenders := [ ] ;
135784: LD_ADDR_VAR 0 17
135788: PUSH
135789: EMPTY
135790: ST_TO_ADDR
// if mechs then
135791: LD_VAR 0 12
135795: IFFALSE 135948
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
135797: LD_ADDR_VAR 0 4
135801: PUSH
135802: LD_VAR 0 2
135806: PPUSH
135807: LD_INT 21
135809: PUSH
135810: LD_INT 2
135812: PUSH
135813: EMPTY
135814: LIST
135815: LIST
135816: PPUSH
135817: CALL_OW 72
135821: PUSH
135822: FOR_IN
135823: IFFALSE 135946
// begin if GetTag ( i ) <> 20 then
135825: LD_VAR 0 4
135829: PPUSH
135830: CALL_OW 110
135834: PUSH
135835: LD_INT 20
135837: NONEQUAL
135838: IFFALSE 135852
// SetTag ( i , 20 ) ;
135840: LD_VAR 0 4
135844: PPUSH
135845: LD_INT 20
135847: PPUSH
135848: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
135852: LD_VAR 0 4
135856: PPUSH
135857: CALL_OW 263
135861: PUSH
135862: LD_INT 1
135864: EQUAL
135865: PUSH
135866: LD_VAR 0 4
135870: PPUSH
135871: CALL_OW 311
135875: NOT
135876: AND
135877: IFFALSE 135944
// begin un := mechs [ 1 ] ;
135879: LD_ADDR_VAR 0 10
135883: PUSH
135884: LD_VAR 0 12
135888: PUSH
135889: LD_INT 1
135891: ARRAY
135892: ST_TO_ADDR
// ComExit ( un ) ;
135893: LD_VAR 0 10
135897: PPUSH
135898: CALL 106485 0 1
// AddComEnterUnit ( un , i ) ;
135902: LD_VAR 0 10
135906: PPUSH
135907: LD_VAR 0 4
135911: PPUSH
135912: CALL_OW 180
// SetTag ( un , 19 ) ;
135916: LD_VAR 0 10
135920: PPUSH
135921: LD_INT 19
135923: PPUSH
135924: CALL_OW 109
// mechs := mechs diff un ;
135928: LD_ADDR_VAR 0 12
135932: PUSH
135933: LD_VAR 0 12
135937: PUSH
135938: LD_VAR 0 10
135942: DIFF
135943: ST_TO_ADDR
// end ; end ;
135944: GO 135822
135946: POP
135947: POP
// if solds then
135948: LD_VAR 0 8
135952: IFFALSE 136011
// for i in solds do
135954: LD_ADDR_VAR 0 4
135958: PUSH
135959: LD_VAR 0 8
135963: PUSH
135964: FOR_IN
135965: IFFALSE 136009
// if not GetTag ( i ) then
135967: LD_VAR 0 4
135971: PPUSH
135972: CALL_OW 110
135976: NOT
135977: IFFALSE 136007
// begin defenders := defenders union i ;
135979: LD_ADDR_VAR 0 2
135983: PUSH
135984: LD_VAR 0 2
135988: PUSH
135989: LD_VAR 0 4
135993: UNION
135994: ST_TO_ADDR
// SetTag ( i , 18 ) ;
135995: LD_VAR 0 4
135999: PPUSH
136000: LD_INT 18
136002: PPUSH
136003: CALL_OW 109
// end ;
136007: GO 135964
136009: POP
136010: POP
// repeat wait ( 0 0$2 ) ;
136011: LD_INT 70
136013: PPUSH
136014: CALL_OW 67
// enemy := mc_scan [ base ] ;
136018: LD_ADDR_VAR 0 21
136022: PUSH
136023: LD_EXP 123
136027: PUSH
136028: LD_VAR 0 1
136032: ARRAY
136033: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
136034: LD_EXP 100
136038: PUSH
136039: LD_VAR 0 1
136043: ARRAY
136044: NOT
136045: PUSH
136046: LD_EXP 100
136050: PUSH
136051: LD_VAR 0 1
136055: ARRAY
136056: PUSH
136057: EMPTY
136058: EQUAL
136059: OR
136060: IFFALSE 136097
// begin for i in defenders do
136062: LD_ADDR_VAR 0 4
136066: PUSH
136067: LD_VAR 0 2
136071: PUSH
136072: FOR_IN
136073: IFFALSE 136086
// ComStop ( i ) ;
136075: LD_VAR 0 4
136079: PPUSH
136080: CALL_OW 141
136084: GO 136072
136086: POP
136087: POP
// defenders := [ ] ;
136088: LD_ADDR_VAR 0 2
136092: PUSH
136093: EMPTY
136094: ST_TO_ADDR
// exit ;
136095: GO 137546
// end ; for i in defenders do
136097: LD_ADDR_VAR 0 4
136101: PUSH
136102: LD_VAR 0 2
136106: PUSH
136107: FOR_IN
136108: IFFALSE 137006
// begin e := NearestUnitToUnit ( enemy , i ) ;
136110: LD_ADDR_VAR 0 13
136114: PUSH
136115: LD_VAR 0 21
136119: PPUSH
136120: LD_VAR 0 4
136124: PPUSH
136125: CALL_OW 74
136129: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136130: LD_ADDR_VAR 0 7
136134: PUSH
136135: LD_EXP 100
136139: PUSH
136140: LD_VAR 0 1
136144: ARRAY
136145: PPUSH
136146: LD_INT 2
136148: PUSH
136149: LD_INT 30
136151: PUSH
136152: LD_INT 0
136154: PUSH
136155: EMPTY
136156: LIST
136157: LIST
136158: PUSH
136159: LD_INT 30
136161: PUSH
136162: LD_INT 1
136164: PUSH
136165: EMPTY
136166: LIST
136167: LIST
136168: PUSH
136169: EMPTY
136170: LIST
136171: LIST
136172: LIST
136173: PPUSH
136174: CALL_OW 72
136178: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
136179: LD_ADDR_VAR 0 16
136183: PUSH
136184: LD_VAR 0 7
136188: NOT
136189: PUSH
136190: LD_VAR 0 7
136194: PPUSH
136195: LD_INT 3
136197: PUSH
136198: LD_INT 24
136200: PUSH
136201: LD_INT 600
136203: PUSH
136204: EMPTY
136205: LIST
136206: LIST
136207: PUSH
136208: EMPTY
136209: LIST
136210: LIST
136211: PPUSH
136212: CALL_OW 72
136216: OR
136217: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
136218: LD_VAR 0 4
136222: PPUSH
136223: CALL_OW 247
136227: PUSH
136228: LD_INT 2
136230: DOUBLE
136231: EQUAL
136232: IFTRUE 136236
136234: GO 136632
136236: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
136237: LD_VAR 0 4
136241: PPUSH
136242: CALL_OW 256
136246: PUSH
136247: LD_INT 1000
136249: EQUAL
136250: PUSH
136251: LD_VAR 0 4
136255: PPUSH
136256: LD_VAR 0 13
136260: PPUSH
136261: CALL_OW 296
136265: PUSH
136266: LD_INT 40
136268: LESS
136269: PUSH
136270: LD_VAR 0 13
136274: PPUSH
136275: LD_EXP 125
136279: PUSH
136280: LD_VAR 0 1
136284: ARRAY
136285: PPUSH
136286: CALL_OW 308
136290: OR
136291: AND
136292: IFFALSE 136414
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
136294: LD_VAR 0 4
136298: PPUSH
136299: CALL_OW 262
136303: PUSH
136304: LD_INT 1
136306: EQUAL
136307: PUSH
136308: LD_VAR 0 4
136312: PPUSH
136313: CALL_OW 261
136317: PUSH
136318: LD_INT 30
136320: LESS
136321: AND
136322: PUSH
136323: LD_VAR 0 7
136327: AND
136328: IFFALSE 136398
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
136330: LD_VAR 0 4
136334: PPUSH
136335: LD_VAR 0 7
136339: PPUSH
136340: LD_VAR 0 4
136344: PPUSH
136345: CALL_OW 74
136349: PPUSH
136350: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
136354: LD_VAR 0 4
136358: PPUSH
136359: LD_VAR 0 7
136363: PPUSH
136364: LD_VAR 0 4
136368: PPUSH
136369: CALL_OW 74
136373: PPUSH
136374: CALL_OW 296
136378: PUSH
136379: LD_INT 6
136381: LESS
136382: IFFALSE 136396
// SetFuel ( i , 100 ) ;
136384: LD_VAR 0 4
136388: PPUSH
136389: LD_INT 100
136391: PPUSH
136392: CALL_OW 240
// end else
136396: GO 136412
// ComAttackUnit ( i , e ) ;
136398: LD_VAR 0 4
136402: PPUSH
136403: LD_VAR 0 13
136407: PPUSH
136408: CALL_OW 115
// end else
136412: GO 136515
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
136414: LD_VAR 0 13
136418: PPUSH
136419: LD_EXP 125
136423: PUSH
136424: LD_VAR 0 1
136428: ARRAY
136429: PPUSH
136430: CALL_OW 308
136434: NOT
136435: PUSH
136436: LD_VAR 0 4
136440: PPUSH
136441: LD_VAR 0 13
136445: PPUSH
136446: CALL_OW 296
136450: PUSH
136451: LD_INT 40
136453: GREATEREQUAL
136454: AND
136455: PUSH
136456: LD_VAR 0 4
136460: PPUSH
136461: CALL_OW 256
136465: PUSH
136466: LD_INT 650
136468: LESSEQUAL
136469: OR
136470: PUSH
136471: LD_VAR 0 4
136475: PPUSH
136476: LD_EXP 124
136480: PUSH
136481: LD_VAR 0 1
136485: ARRAY
136486: PPUSH
136487: CALL_OW 308
136491: NOT
136492: AND
136493: IFFALSE 136515
// ComMoveToArea ( i , mc_parking [ base ] ) ;
136495: LD_VAR 0 4
136499: PPUSH
136500: LD_EXP 124
136504: PUSH
136505: LD_VAR 0 1
136509: ARRAY
136510: PPUSH
136511: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
136515: LD_VAR 0 4
136519: PPUSH
136520: CALL_OW 256
136524: PUSH
136525: LD_INT 1000
136527: LESS
136528: PUSH
136529: LD_VAR 0 4
136533: PPUSH
136534: CALL_OW 263
136538: PUSH
136539: LD_INT 1
136541: EQUAL
136542: AND
136543: PUSH
136544: LD_VAR 0 4
136548: PPUSH
136549: CALL_OW 311
136553: AND
136554: PUSH
136555: LD_VAR 0 4
136559: PPUSH
136560: LD_EXP 124
136564: PUSH
136565: LD_VAR 0 1
136569: ARRAY
136570: PPUSH
136571: CALL_OW 308
136575: AND
136576: IFFALSE 136630
// begin mech := IsDrivenBy ( i ) ;
136578: LD_ADDR_VAR 0 9
136582: PUSH
136583: LD_VAR 0 4
136587: PPUSH
136588: CALL_OW 311
136592: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
136593: LD_VAR 0 9
136597: PPUSH
136598: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
136602: LD_VAR 0 9
136606: PPUSH
136607: LD_VAR 0 4
136611: PPUSH
136612: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
136616: LD_VAR 0 9
136620: PPUSH
136621: LD_VAR 0 4
136625: PPUSH
136626: CALL_OW 180
// end ; end ; unit_human :
136630: GO 136977
136632: LD_INT 1
136634: DOUBLE
136635: EQUAL
136636: IFTRUE 136640
136638: GO 136976
136640: POP
// begin b := IsInUnit ( i ) ;
136641: LD_ADDR_VAR 0 18
136645: PUSH
136646: LD_VAR 0 4
136650: PPUSH
136651: CALL_OW 310
136655: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
136656: LD_ADDR_VAR 0 19
136660: PUSH
136661: LD_VAR 0 18
136665: NOT
136666: PUSH
136667: LD_VAR 0 18
136671: PPUSH
136672: CALL_OW 266
136676: PUSH
136677: LD_INT 32
136679: PUSH
136680: LD_INT 31
136682: PUSH
136683: EMPTY
136684: LIST
136685: LIST
136686: IN
136687: OR
136688: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
136689: LD_VAR 0 18
136693: PPUSH
136694: CALL_OW 266
136698: PUSH
136699: LD_INT 5
136701: EQUAL
136702: PUSH
136703: LD_VAR 0 4
136707: PPUSH
136708: CALL_OW 257
136712: PUSH
136713: LD_INT 1
136715: PUSH
136716: LD_INT 2
136718: PUSH
136719: LD_INT 3
136721: PUSH
136722: LD_INT 4
136724: PUSH
136725: EMPTY
136726: LIST
136727: LIST
136728: LIST
136729: LIST
136730: IN
136731: AND
136732: IFFALSE 136769
// begin class := AllowSpecClass ( i ) ;
136734: LD_ADDR_VAR 0 20
136738: PUSH
136739: LD_VAR 0 4
136743: PPUSH
136744: CALL 70581 0 1
136748: ST_TO_ADDR
// if class then
136749: LD_VAR 0 20
136753: IFFALSE 136769
// ComChangeProfession ( i , class ) ;
136755: LD_VAR 0 4
136759: PPUSH
136760: LD_VAR 0 20
136764: PPUSH
136765: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
136769: LD_VAR 0 16
136773: PUSH
136774: LD_VAR 0 2
136778: PPUSH
136779: LD_INT 21
136781: PUSH
136782: LD_INT 2
136784: PUSH
136785: EMPTY
136786: LIST
136787: LIST
136788: PPUSH
136789: CALL_OW 72
136793: PUSH
136794: LD_INT 1
136796: LESSEQUAL
136797: OR
136798: PUSH
136799: LD_VAR 0 19
136803: AND
136804: PUSH
136805: LD_VAR 0 4
136809: PUSH
136810: LD_VAR 0 17
136814: IN
136815: NOT
136816: AND
136817: IFFALSE 136910
// begin if b then
136819: LD_VAR 0 18
136823: IFFALSE 136872
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
136825: LD_VAR 0 18
136829: PPUSH
136830: LD_VAR 0 21
136834: PPUSH
136835: LD_VAR 0 18
136839: PPUSH
136840: CALL_OW 74
136844: PPUSH
136845: CALL_OW 296
136849: PUSH
136850: LD_INT 10
136852: LESS
136853: PUSH
136854: LD_VAR 0 18
136858: PPUSH
136859: CALL_OW 461
136863: PUSH
136864: LD_INT 7
136866: NONEQUAL
136867: AND
136868: IFFALSE 136872
// continue ;
136870: GO 136107
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
136872: LD_ADDR_VAR 0 17
136876: PUSH
136877: LD_VAR 0 17
136881: PPUSH
136882: LD_VAR 0 17
136886: PUSH
136887: LD_INT 1
136889: PLUS
136890: PPUSH
136891: LD_VAR 0 4
136895: PPUSH
136896: CALL_OW 1
136900: ST_TO_ADDR
// ComExitBuilding ( i ) ;
136901: LD_VAR 0 4
136905: PPUSH
136906: CALL_OW 122
// end ; if sold_defenders then
136910: LD_VAR 0 17
136914: IFFALSE 136974
// if i in sold_defenders then
136916: LD_VAR 0 4
136920: PUSH
136921: LD_VAR 0 17
136925: IN
136926: IFFALSE 136974
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
136928: LD_VAR 0 4
136932: PPUSH
136933: CALL_OW 314
136937: NOT
136938: PUSH
136939: LD_VAR 0 4
136943: PPUSH
136944: LD_VAR 0 13
136948: PPUSH
136949: CALL_OW 296
136953: PUSH
136954: LD_INT 30
136956: LESS
136957: AND
136958: IFFALSE 136974
// ComAttackUnit ( i , e ) ;
136960: LD_VAR 0 4
136964: PPUSH
136965: LD_VAR 0 13
136969: PPUSH
136970: CALL_OW 115
// end ; end ; end ;
136974: GO 136977
136976: POP
// if IsDead ( i ) then
136977: LD_VAR 0 4
136981: PPUSH
136982: CALL_OW 301
136986: IFFALSE 137004
// defenders := defenders diff i ;
136988: LD_ADDR_VAR 0 2
136992: PUSH
136993: LD_VAR 0 2
136997: PUSH
136998: LD_VAR 0 4
137002: DIFF
137003: ST_TO_ADDR
// end ;
137004: GO 136107
137006: POP
137007: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
137008: LD_VAR 0 21
137012: NOT
137013: PUSH
137014: LD_VAR 0 2
137018: NOT
137019: OR
137020: PUSH
137021: LD_EXP 100
137025: PUSH
137026: LD_VAR 0 1
137030: ARRAY
137031: NOT
137032: OR
137033: IFFALSE 136011
// MC_Reset ( base , 18 ) ;
137035: LD_VAR 0 1
137039: PPUSH
137040: LD_INT 18
137042: PPUSH
137043: CALL 42270 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
137047: LD_ADDR_VAR 0 2
137051: PUSH
137052: LD_VAR 0 2
137056: PUSH
137057: LD_VAR 0 2
137061: PPUSH
137062: LD_INT 2
137064: PUSH
137065: LD_INT 25
137067: PUSH
137068: LD_INT 1
137070: PUSH
137071: EMPTY
137072: LIST
137073: LIST
137074: PUSH
137075: LD_INT 25
137077: PUSH
137078: LD_INT 5
137080: PUSH
137081: EMPTY
137082: LIST
137083: LIST
137084: PUSH
137085: LD_INT 25
137087: PUSH
137088: LD_INT 8
137090: PUSH
137091: EMPTY
137092: LIST
137093: LIST
137094: PUSH
137095: LD_INT 25
137097: PUSH
137098: LD_INT 9
137100: PUSH
137101: EMPTY
137102: LIST
137103: LIST
137104: PUSH
137105: EMPTY
137106: LIST
137107: LIST
137108: LIST
137109: LIST
137110: LIST
137111: PPUSH
137112: CALL_OW 72
137116: DIFF
137117: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
137118: LD_VAR 0 21
137122: NOT
137123: PUSH
137124: LD_VAR 0 2
137128: PPUSH
137129: LD_INT 21
137131: PUSH
137132: LD_INT 2
137134: PUSH
137135: EMPTY
137136: LIST
137137: LIST
137138: PPUSH
137139: CALL_OW 72
137143: AND
137144: IFFALSE 137482
// begin tmp := FilterByTag ( defenders , 19 ) ;
137146: LD_ADDR_VAR 0 11
137150: PUSH
137151: LD_VAR 0 2
137155: PPUSH
137156: LD_INT 19
137158: PPUSH
137159: CALL 103669 0 2
137163: ST_TO_ADDR
// if tmp then
137164: LD_VAR 0 11
137168: IFFALSE 137238
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
137170: LD_ADDR_VAR 0 11
137174: PUSH
137175: LD_VAR 0 11
137179: PPUSH
137180: LD_INT 25
137182: PUSH
137183: LD_INT 3
137185: PUSH
137186: EMPTY
137187: LIST
137188: LIST
137189: PPUSH
137190: CALL_OW 72
137194: ST_TO_ADDR
// if tmp then
137195: LD_VAR 0 11
137199: IFFALSE 137238
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
137201: LD_ADDR_EXP 112
137205: PUSH
137206: LD_EXP 112
137210: PPUSH
137211: LD_VAR 0 1
137215: PPUSH
137216: LD_EXP 112
137220: PUSH
137221: LD_VAR 0 1
137225: ARRAY
137226: PUSH
137227: LD_VAR 0 11
137231: UNION
137232: PPUSH
137233: CALL_OW 1
137237: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
137238: LD_VAR 0 1
137242: PPUSH
137243: LD_INT 19
137245: PPUSH
137246: CALL 42270 0 2
// repeat wait ( 0 0$1 ) ;
137250: LD_INT 35
137252: PPUSH
137253: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137257: LD_EXP 100
137261: PUSH
137262: LD_VAR 0 1
137266: ARRAY
137267: NOT
137268: PUSH
137269: LD_EXP 100
137273: PUSH
137274: LD_VAR 0 1
137278: ARRAY
137279: PUSH
137280: EMPTY
137281: EQUAL
137282: OR
137283: IFFALSE 137320
// begin for i in defenders do
137285: LD_ADDR_VAR 0 4
137289: PUSH
137290: LD_VAR 0 2
137294: PUSH
137295: FOR_IN
137296: IFFALSE 137309
// ComStop ( i ) ;
137298: LD_VAR 0 4
137302: PPUSH
137303: CALL_OW 141
137307: GO 137295
137309: POP
137310: POP
// defenders := [ ] ;
137311: LD_ADDR_VAR 0 2
137315: PUSH
137316: EMPTY
137317: ST_TO_ADDR
// exit ;
137318: GO 137546
// end ; for i in defenders do
137320: LD_ADDR_VAR 0 4
137324: PUSH
137325: LD_VAR 0 2
137329: PUSH
137330: FOR_IN
137331: IFFALSE 137420
// begin if not IsInArea ( i , mc_parking [ base ] ) then
137333: LD_VAR 0 4
137337: PPUSH
137338: LD_EXP 124
137342: PUSH
137343: LD_VAR 0 1
137347: ARRAY
137348: PPUSH
137349: CALL_OW 308
137353: NOT
137354: IFFALSE 137378
// ComMoveToArea ( i , mc_parking [ base ] ) else
137356: LD_VAR 0 4
137360: PPUSH
137361: LD_EXP 124
137365: PUSH
137366: LD_VAR 0 1
137370: ARRAY
137371: PPUSH
137372: CALL_OW 113
137376: GO 137418
// if GetControl ( i ) = control_manual then
137378: LD_VAR 0 4
137382: PPUSH
137383: CALL_OW 263
137387: PUSH
137388: LD_INT 1
137390: EQUAL
137391: IFFALSE 137418
// if IsDrivenBy ( i ) then
137393: LD_VAR 0 4
137397: PPUSH
137398: CALL_OW 311
137402: IFFALSE 137418
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
137404: LD_VAR 0 4
137408: PPUSH
137409: CALL_OW 311
137413: PPUSH
137414: CALL_OW 121
// end ;
137418: GO 137330
137420: POP
137421: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
137422: LD_VAR 0 2
137426: PPUSH
137427: LD_INT 95
137429: PUSH
137430: LD_EXP 124
137434: PUSH
137435: LD_VAR 0 1
137439: ARRAY
137440: PUSH
137441: EMPTY
137442: LIST
137443: LIST
137444: PPUSH
137445: CALL_OW 72
137449: PUSH
137450: LD_VAR 0 2
137454: EQUAL
137455: PUSH
137456: LD_EXP 123
137460: PUSH
137461: LD_VAR 0 1
137465: ARRAY
137466: OR
137467: PUSH
137468: LD_EXP 100
137472: PUSH
137473: LD_VAR 0 1
137477: ARRAY
137478: NOT
137479: OR
137480: IFFALSE 137250
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
137482: LD_ADDR_EXP 122
137486: PUSH
137487: LD_EXP 122
137491: PPUSH
137492: LD_VAR 0 1
137496: PPUSH
137497: LD_VAR 0 2
137501: PPUSH
137502: LD_INT 21
137504: PUSH
137505: LD_INT 2
137507: PUSH
137508: EMPTY
137509: LIST
137510: LIST
137511: PPUSH
137512: CALL_OW 72
137516: PPUSH
137517: CALL_OW 1
137521: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
137522: LD_VAR 0 1
137526: PPUSH
137527: LD_INT 19
137529: PPUSH
137530: CALL 42270 0 2
// MC_Reset ( base , 20 ) ;
137534: LD_VAR 0 1
137538: PPUSH
137539: LD_INT 20
137541: PPUSH
137542: CALL 42270 0 2
// end ; end_of_file
137546: LD_VAR 0 3
137550: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
137551: LD_VAR 0 1
137555: PUSH
137556: LD_INT 200
137558: DOUBLE
137559: GREATEREQUAL
137560: IFFALSE 137568
137562: LD_INT 299
137564: DOUBLE
137565: LESSEQUAL
137566: IFTRUE 137570
137568: GO 137602
137570: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
137571: LD_VAR 0 1
137575: PPUSH
137576: LD_VAR 0 2
137580: PPUSH
137581: LD_VAR 0 3
137585: PPUSH
137586: LD_VAR 0 4
137590: PPUSH
137591: LD_VAR 0 5
137595: PPUSH
137596: CALL 126337 0 5
137600: GO 137679
137602: LD_INT 300
137604: DOUBLE
137605: GREATEREQUAL
137606: IFFALSE 137614
137608: LD_INT 399
137610: DOUBLE
137611: LESSEQUAL
137612: IFTRUE 137616
137614: GO 137678
137616: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
137617: LD_VAR 0 1
137621: PPUSH
137622: LD_VAR 0 2
137626: PPUSH
137627: LD_VAR 0 3
137631: PPUSH
137632: LD_VAR 0 4
137636: PPUSH
137637: LD_VAR 0 5
137641: PPUSH
137642: LD_VAR 0 6
137646: PPUSH
137647: LD_VAR 0 7
137651: PPUSH
137652: LD_VAR 0 8
137656: PPUSH
137657: LD_VAR 0 9
137661: PPUSH
137662: LD_VAR 0 10
137666: PPUSH
137667: LD_VAR 0 11
137671: PPUSH
137672: CALL 122662 0 11
137676: GO 137679
137678: POP
// end ;
137679: PPOPN 11
137681: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
137682: LD_VAR 0 1
137686: PPUSH
137687: LD_VAR 0 2
137691: PPUSH
137692: LD_VAR 0 3
137696: PPUSH
137697: LD_VAR 0 4
137701: PPUSH
137702: LD_VAR 0 5
137706: PPUSH
137707: CALL 126073 0 5
// end ; end_of_file
137711: PPOPN 5
137713: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
137714: LD_VAR 0 1
137718: PPUSH
137719: LD_VAR 0 2
137723: PPUSH
137724: LD_VAR 0 3
137728: PPUSH
137729: LD_VAR 0 4
137733: PPUSH
137734: LD_VAR 0 5
137738: PPUSH
137739: LD_VAR 0 6
137743: PPUSH
137744: CALL 110314 0 6
// end ;
137748: PPOPN 6
137750: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
137751: LD_INT 0
137753: PPUSH
// begin if not units then
137754: LD_VAR 0 1
137758: NOT
137759: IFFALSE 137763
// exit ;
137761: GO 137763
// end ;
137763: PPOPN 7
137765: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
137766: CALL 110218 0 0
// end ;
137770: PPOPN 1
137772: END
