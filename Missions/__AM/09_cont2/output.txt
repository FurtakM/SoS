// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13721 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2966 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := 0 ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// hc_name := Peter McCreery ;
2391: LD_ADDR_OWVAR 26
2395: PUSH
2396: LD_STRING Peter McCreery
2398: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2399: LD_ADDR_OWVAR 33
2403: PUSH
2404: LD_STRING SecondCharsGal
2406: ST_TO_ADDR
// hc_face_number := 58 ;
2407: LD_ADDR_OWVAR 34
2411: PUSH
2412: LD_INT 58
2414: ST_TO_ADDR
// hc_sex := sex_male ;
2415: LD_ADDR_OWVAR 27
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// hc_class := 4 ;
2423: LD_ADDR_OWVAR 28
2427: PUSH
2428: LD_INT 4
2430: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 2 ] ;
2431: LD_ADDR_OWVAR 30
2435: PUSH
2436: LD_INT 0
2438: PUSH
2439: LD_INT 0
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 6 ] ;
2454: LD_ADDR_OWVAR 31
2458: PUSH
2459: LD_INT 1
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 3
2467: PUSH
2468: LD_INT 6
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// un := CreateHuman ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// SetTag ( un , 11 ) ;
2487: LD_VAR 0 5
2491: PPUSH
2492: LD_INT 11
2494: PPUSH
2495: CALL_OW 109
// tmp := tmp ^ un ;
2499: LD_ADDR_VAR 0 4
2503: PUSH
2504: LD_VAR 0 4
2508: PUSH
2509: LD_VAR 0 5
2513: ADD
2514: ST_TO_ADDR
// tmp := tmp diff 0 ;
2515: LD_ADDR_VAR 0 4
2519: PUSH
2520: LD_VAR 0 4
2524: PUSH
2525: LD_INT 0
2527: DIFF
2528: ST_TO_ADDR
// InitHc ;
2529: CALL_OW 19
// hc_name :=  ;
2533: LD_ADDR_OWVAR 26
2537: PUSH
2538: LD_STRING 
2540: ST_TO_ADDR
// hc_gallery :=  ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING 
2548: ST_TO_ADDR
// if debug then
2549: LD_EXP 2
2553: IFFALSE 2604
// begin for i = 1 to 6 do
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: DOUBLE
2561: LD_INT 1
2563: DEC
2564: ST_TO_ADDR
2565: LD_INT 6
2567: PUSH
2568: FOR_TO
2569: IFFALSE 2602
// begin PrepareHuman ( false , 1 , 6 ) ;
2571: LD_INT 0
2573: PPUSH
2574: LD_INT 1
2576: PPUSH
2577: LD_INT 6
2579: PPUSH
2580: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_VAR 0 4
2593: PUSH
2594: CALL_OW 44
2598: ADD
2599: ST_TO_ADDR
// end ;
2600: GO 2568
2602: POP
2603: POP
// end ; for i in tmp do
2604: LD_ADDR_VAR 0 2
2608: PUSH
2609: LD_VAR 0 4
2613: PUSH
2614: FOR_IN
2615: IFFALSE 2674
// begin if GetClass ( i ) in [ 2 , 3 ] then
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 257
2626: PUSH
2627: LD_INT 2
2629: PUSH
2630: LD_INT 3
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: IN
2637: IFFALSE 2651
// SetClass ( i , 1 ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 1
2646: PPUSH
2647: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 106
2658: PPUSH
2659: LD_INT 122
2661: PPUSH
2662: LD_INT 5
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 50
// end ;
2672: GO 2614
2674: POP
2675: POP
// tmp := tmp diff Gary ;
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_EXP 22
2690: DIFF
2691: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 30
2709: PUSH
2710: LD_INT 31
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PPUSH
2721: CALL_OW 69
2725: ST_TO_ADDR
// for i = 1 to b do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: DOUBLE
2732: LD_INT 1
2734: DEC
2735: ST_TO_ADDR
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_TO
2742: IFFALSE 2787
// ComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) [ i ] , b [ i ] ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_INT 25
2751: PUSH
2752: LD_INT 1
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 72
2763: PUSH
2764: LD_VAR 0 2
2768: ARRAY
2769: PPUSH
2770: LD_VAR 0 3
2774: PUSH
2775: LD_VAR 0 2
2779: ARRAY
2780: PPUSH
2781: CALL_OW 120
2785: GO 2741
2787: POP
2788: POP
// InitHc ;
2789: CALL_OW 19
// InitUc ;
2793: CALL_OW 18
// end ;
2797: LD_VAR 0 1
2801: RET
// export function PowellTransport ; var i , un ; begin
2802: LD_INT 0
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side := 4 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 4
2814: ST_TO_ADDR
// uc_nation := 1 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2823: LD_INT 1
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: LD_INT 6
2831: PPUSH
2832: CALL_OW 380
// hc_name :=  ;
2836: LD_ADDR_OWVAR 26
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING SecondCharsGal
2851: ST_TO_ADDR
// hc_face_number := 30 ;
2852: LD_ADDR_OWVAR 34
2856: PUSH
2857: LD_INT 30
2859: ST_TO_ADDR
// powell_trans := CreateHuman ;
2860: LD_ADDR_EXP 27
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// hc_face_number := 31 ;
2870: LD_ADDR_OWVAR 34
2874: PUSH
2875: LD_INT 31
2877: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2878: LD_ADDR_EXP 27
2882: PUSH
2883: LD_EXP 27
2887: PUSH
2888: CALL_OW 44
2892: ADD
2893: ST_TO_ADDR
// for i = 1 to 2 do
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: DOUBLE
2900: LD_INT 1
2902: DEC
2903: ST_TO_ADDR
2904: LD_INT 2
2906: PUSH
2907: FOR_TO
2908: IFFALSE 2959
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2910: LD_ADDR_VAR 0 3
2914: PUSH
2915: LD_INT 4
2917: PPUSH
2918: LD_INT 1
2920: PPUSH
2921: LD_INT 3
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: LD_INT 12
2932: PPUSH
2933: LD_INT 66
2935: PPUSH
2936: CALL 423 0 7
2940: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2941: LD_ADDR_EXP 27
2945: PUSH
2946: LD_EXP 27
2950: PUSH
2951: LD_VAR 0 3
2955: ADD
2956: ST_TO_ADDR
// end ;
2957: GO 2907
2959: POP
2960: POP
// end ; end_of_file
2961: LD_VAR 0 1
2965: RET
// export function Action ; var i , veh ; begin
2966: LD_INT 0
2968: PPUSH
2969: PPUSH
2970: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2971: LD_EXP 26
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: LD_INT 50
2981: PPUSH
2982: LD_INT 38
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: CALL_OW 145
// InGameOn ;
2992: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2996: LD_INT 43
2998: PPUSH
2999: LD_INT 9
3001: PPUSH
3002: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
3006: LD_EXP 21
3010: PPUSH
3011: LD_INT 54
3013: PPUSH
3014: LD_INT 34
3016: PPUSH
3017: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
3021: LD_EXP 21
3025: PPUSH
3026: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
3030: LD_EXP 21
3034: PPUSH
3035: LD_EXP 26
3039: PUSH
3040: LD_INT 1
3042: ARRAY
3043: PPUSH
3044: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// until See ( 4 , JMM ) ;
3055: LD_INT 4
3057: PPUSH
3058: LD_EXP 21
3062: PPUSH
3063: CALL_OW 292
3067: IFFALSE 3048
// CenterNowOnUnits ( JMM ) ;
3069: LD_EXP 21
3073: PPUSH
3074: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
3078: LD_EXP 21
3082: PPUSH
3083: LD_STRING D2-JMM-1
3085: PPUSH
3086: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
3090: LD_EXP 26
3094: PUSH
3095: LD_INT 3
3097: ARRAY
3098: PPUSH
3099: LD_EXP 21
3103: PPUSH
3104: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
3108: LD_EXP 26
3112: PUSH
3113: LD_INT 3
3115: ARRAY
3116: PPUSH
3117: LD_STRING D2-Eng1-1
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3124: LD_EXP 21
3128: PPUSH
3129: LD_STRING D2-JMM-2
3131: PPUSH
3132: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
3136: LD_EXP 26
3140: PUSH
3141: LD_INT 3
3143: ARRAY
3144: PPUSH
3145: LD_STRING D2-Eng1-2
3147: PPUSH
3148: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3152: LD_EXP 21
3156: PPUSH
3157: LD_STRING D2-JMM-3
3159: PPUSH
3160: CALL_OW 88
// if Houten then
3164: LD_EXP 25
3168: IFFALSE 3366
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3170: LD_ADDR_VAR 0 3
3174: PUSH
3175: LD_INT 4
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 4
3192: PPUSH
3193: LD_INT 55
3195: PPUSH
3196: CALL 423 0 7
3200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3201: LD_VAR 0 3
3205: PPUSH
3206: LD_INT 3
3208: PPUSH
3209: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3213: LD_VAR 0 3
3217: PPUSH
3218: LD_INT 46
3220: PPUSH
3221: LD_INT 19
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3231: LD_EXP 25
3235: PPUSH
3236: LD_VAR 0 3
3240: PPUSH
3241: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3245: LD_EXP 25
3249: PPUSH
3250: LD_INT 49
3252: PPUSH
3253: LD_INT 33
3255: PPUSH
3256: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3260: LD_EXP 25
3264: PPUSH
3265: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3269: LD_EXP 25
3273: PPUSH
3274: LD_EXP 21
3278: PPUSH
3279: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3283: LD_INT 35
3285: PPUSH
3286: CALL_OW 67
// until See ( 1 , Houten ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_EXP 25
3297: PPUSH
3298: CALL_OW 292
3302: IFFALSE 3283
// ComTurnUnit ( JMM , Houten ) ;
3304: LD_EXP 21
3308: PPUSH
3309: LD_EXP 25
3313: PPUSH
3314: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3318: LD_EXP 21
3322: PPUSH
3323: LD_STRING D1d-JMM-1
3325: PPUSH
3326: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3330: LD_EXP 25
3334: PPUSH
3335: LD_STRING D1-VanH-1
3337: PPUSH
3338: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3342: LD_EXP 21
3346: PPUSH
3347: LD_STRING D1-JMM-1v
3349: PPUSH
3350: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3354: LD_EXP 21
3358: PPUSH
3359: LD_STRING D1-JMM-2v
3361: PPUSH
3362: CALL_OW 88
// end ; InGameOff ;
3366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3370: LD_STRING M1
3372: PPUSH
3373: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3377: LD_INT 22
3379: PUSH
3380: LD_INT 4
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 92
3389: PUSH
3390: LD_EXP 21
3394: PPUSH
3395: CALL_OW 250
3399: PUSH
3400: LD_EXP 21
3404: PPUSH
3405: CALL_OW 251
3409: PUSH
3410: LD_INT 15
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3435: LD_EXP 26
3439: PUSH
3440: LD_EXP 21
3444: ADD
3445: PUSH
3446: LD_EXP 25
3450: ADD
3451: PPUSH
3452: CALL_OW 141
// end ;
3456: LD_VAR 0 1
3460: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3461: LD_INT 1
3463: PPUSH
3464: LD_EXP 22
3468: PPUSH
3469: CALL_OW 292
3473: PUSH
3474: LD_EXP 21
3478: PPUSH
3479: LD_EXP 22
3483: PPUSH
3484: CALL_OW 296
3488: PUSH
3489: LD_INT 6
3491: LESS
3492: AND
3493: IFFALSE 4366
3495: GO 3497
3497: DISABLE
3498: LD_INT 0
3500: PPUSH
3501: PPUSH
3502: PPUSH
3503: PPUSH
3504: PPUSH
// begin InGameOn ;
3505: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PPUSH
3519: CALL_OW 69
3523: PPUSH
3524: LD_INT 1
3526: PPUSH
3527: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3531: LD_ADDR_VAR 0 4
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 1
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 25
3561: PUSH
3562: LD_INT 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 25
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 25
3581: PUSH
3582: LD_INT 4
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// ComHold ( tmp ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3614: LD_EXP 21
3618: PPUSH
3619: LD_STRING D2-JMM-3a
3621: PPUSH
3622: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3626: LD_EXP 22
3630: PPUSH
3631: LD_EXP 21
3635: PPUSH
3636: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3640: LD_EXP 22
3644: PPUSH
3645: LD_STRING D2-Gary-3
3647: PPUSH
3648: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3652: LD_EXP 21
3656: PPUSH
3657: LD_EXP 22
3661: PPUSH
3662: CALL_OW 119
// for i in tmp do
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: LD_VAR 0 4
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3722
// begin if IsInUnit ( i ) then
3679: LD_VAR 0 5
3683: PPUSH
3684: CALL_OW 310
3688: IFFALSE 3699
// ComExitBuilding ( i ) ;
3690: LD_VAR 0 5
3694: PPUSH
3695: CALL_OW 122
// wait ( 1 ) ;
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_EXP 21
3715: PPUSH
3716: CALL_OW 119
// end ;
3720: GO 3676
3722: POP
3723: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3724: LD_ADDR_VAR 0 4
3728: PUSH
3729: LD_VAR 0 4
3733: PUSH
3734: LD_EXP 21
3738: PUSH
3739: LD_EXP 25
3743: PUSH
3744: LD_EXP 22
3748: PUSH
3749: LD_EXP 24
3753: PUSH
3754: LD_EXP 23
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: PUSH
3766: LD_EXP 26
3770: ADD
3771: DIFF
3772: ST_TO_ADDR
// if Bobby then
3773: LD_EXP 23
3777: IFFALSE 3791
// Say ( Bobby , D2-Bobby-3 ) ;
3779: LD_EXP 23
3783: PPUSH
3784: LD_STRING D2-Bobby-3
3786: PPUSH
3787: CALL_OW 88
// if Cyrus then
3791: LD_EXP 24
3795: IFFALSE 3809
// Say ( Cyrus , D2-Cyrus-3 ) ;
3797: LD_EXP 24
3801: PPUSH
3802: LD_STRING D2-Cyrus-3
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3809: LD_EXP 21
3813: PPUSH
3814: LD_STRING D2-JMM-4
3816: PPUSH
3817: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3821: LD_EXP 22
3825: PPUSH
3826: LD_STRING D2-Gary-4
3828: PPUSH
3829: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3833: LD_ADDR_VAR 0 1
3837: PUSH
3838: LD_VAR 0 4
3842: PPUSH
3843: LD_INT 26
3845: PUSH
3846: LD_INT 1
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 72
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// if Cyrus then
3862: LD_EXP 24
3866: IFFALSE 3882
// Say ( Cyrus , D2-Cyrus-4 ) else
3868: LD_EXP 24
3872: PPUSH
3873: LD_STRING D2-Cyrus-4
3875: PPUSH
3876: CALL_OW 88
3880: GO 3894
// Say ( un1 , D2-Sol1-4 ) ;
3882: LD_VAR 0 1
3886: PPUSH
3887: LD_STRING D2-Sol1-4
3889: PPUSH
3890: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3894: LD_EXP 21
3898: PPUSH
3899: LD_STRING D2-JMM-5
3901: PPUSH
3902: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3906: LD_ADDR_VAR 0 2
3910: PUSH
3911: LD_EXP 26
3915: PPUSH
3916: LD_INT 91
3918: PUSH
3919: LD_EXP 21
3923: PUSH
3924: LD_INT 10
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: LIST
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 72
3950: ST_TO_ADDR
// if un2 then
3951: LD_VAR 0 2
3955: IFFALSE 4009
// begin un2 := un2 [ un2 ] ;
3957: LD_ADDR_VAR 0 2
3961: PUSH
3962: LD_VAR 0 2
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3973: LD_VAR 0 2
3977: PPUSH
3978: LD_STRING D2-FEng1-5
3980: PPUSH
3981: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3985: LD_EXP 21
3989: PPUSH
3990: LD_STRING D2-JMM-6
3992: PPUSH
3993: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_STRING D2-FEng1-6
4004: PPUSH
4005: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_EXP 26
4018: PPUSH
4019: LD_INT 91
4021: PUSH
4022: LD_EXP 21
4026: PUSH
4027: LD_INT 10
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 72
4053: ST_TO_ADDR
// if un3 then
4054: LD_VAR 0 3
4058: IFFALSE 4113
// begin un3 := un3 [ 1 ] ;
4060: LD_ADDR_VAR 0 3
4064: PUSH
4065: LD_VAR 0 3
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
4074: LD_VAR 0 3
4078: PPUSH
4079: LD_INT 114
4081: PPUSH
4082: LD_INT 122
4084: PPUSH
4085: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
4089: LD_VAR 0 3
4093: PPUSH
4094: LD_STRING D2-Eng1-6
4096: PPUSH
4097: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4101: LD_EXP 21
4105: PPUSH
4106: LD_STRING D2-JMM-7
4108: PPUSH
4109: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
4113: LD_EXP 22
4117: PPUSH
4118: LD_STRING D2-Gary-7
4120: PPUSH
4121: CALL_OW 88
// if un2 then
4125: LD_VAR 0 2
4129: IFFALSE 4143
// Say ( un2 , D2-FEng1-7 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING D2-FEng1-7
4138: PPUSH
4139: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
4143: LD_VAR 0 1
4147: PPUSH
4148: LD_STRING D2-Sol1-7
4150: PPUSH
4151: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
4155: LD_EXP 21
4159: PPUSH
4160: LD_STRING D2-JMM-8
4162: PPUSH
4163: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PPUSH
4182: CALL_OW 141
// InGameOff ;
4186: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4190: LD_STRING M1a
4192: PPUSH
4193: CALL_OW 337
// jmm_in_ovsyenko := true ;
4197: LD_ADDR_EXP 4
4201: PUSH
4202: LD_INT 1
4204: ST_TO_ADDR
// if debug then
4205: LD_EXP 2
4209: IFFALSE 4315
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PPUSH
4244: CALL_OW 274
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_INT 1000
4254: PPUSH
4255: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4259: LD_INT 22
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 30
4271: PUSH
4272: LD_INT 0
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PPUSH
4283: CALL_OW 69
4287: PUSH
4288: LD_INT 1
4290: ARRAY
4291: PPUSH
4292: CALL_OW 274
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 1000
4302: PPUSH
4303: CALL_OW 277
// ar_can_arrive := true ;
4307: LD_ADDR_EXP 10
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4315: LD_INT 1050
4317: PPUSH
4318: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4322: LD_ADDR_VAR 0 4
4326: PUSH
4327: LD_INT 25
4329: PUSH
4330: LD_INT 14
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// if not tmp then
4342: LD_VAR 0 4
4346: NOT
4347: IFFALSE 4351
// exit ;
4349: GO 4366
// ComMoveXY ( tmp , 75 , 75 ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_INT 75
4358: PPUSH
4359: LD_INT 75
4361: PPUSH
4362: CALL_OW 111
// end ;
4366: PPOPN 5
4368: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 30
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: LD_INT 57
4394: PUSH
4395: EMPTY
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: IFFALSE 4453
4413: GO 4415
4415: DISABLE
4416: LD_INT 0
4418: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4419: LD_ADDR_VAR 0 1
4423: PUSH
4424: LD_STRING M2easy
4426: PUSH
4427: LD_STRING M2
4429: PUSH
4430: LD_STRING M2hard
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4438: LD_VAR 0 1
4442: PUSH
4443: LD_OWVAR 67
4447: ARRAY
4448: PPUSH
4449: CALL_OW 337
// end ;
4453: PPOPN 1
4455: END
// every 3 3$00 do
4456: GO 4458
4458: DISABLE
// begin DialogueOn ;
4459: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4463: LD_EXP 28
4467: PPUSH
4468: LD_STRING D3-Pow-1
4470: PPUSH
4471: CALL_OW 94
// if jmm_in_ovsyenko then
4475: LD_EXP 4
4479: IFFALSE 4507
// begin Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 21
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4493: LD_EXP 21
4497: PPUSH
4498: LD_STRING D3-JMM-1b
4500: PPUSH
4501: CALL_OW 88
// end else
4505: GO 4519
// Say ( JMM , D3-JMM-1a ) ;
4507: LD_EXP 21
4511: PPUSH
4512: LD_STRING D3-JMM-1a
4514: PPUSH
4515: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4519: LD_EXP 28
4523: PPUSH
4524: LD_STRING D3-Pow-2
4526: PPUSH
4527: CALL_OW 94
// DialogueOff ;
4531: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4535: LD_STRING M3
4537: PPUSH
4538: CALL_OW 337
// powell_want_sib := true ;
4542: LD_ADDR_EXP 5
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end ;
4550: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4551: LD_EXP 6
4555: PUSH
4556: LD_INT 0
4558: EQUAL
4559: IFFALSE 6020
4561: GO 4563
4563: DISABLE
4564: LD_INT 0
4566: PPUSH
4567: PPUSH
4568: PPUSH
4569: PPUSH
4570: PPUSH
4571: PPUSH
4572: PPUSH
4573: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4574: LD_INT 4
4576: PPUSH
4577: LD_INT 1
4579: PPUSH
4580: CALL_OW 343
// PowellTransport ;
4584: CALL 2802 0 0
// for i = 1 to 3 do
4588: LD_ADDR_VAR 0 4
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_INT 3
4600: PUSH
4601: FOR_TO
4602: IFFALSE 4669
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 6
4611: PPUSH
4612: LD_VAR 0 4
4616: PPUSH
4617: CALL_OW 287
4621: ST_TO_ADDR
// if not tmp then
4622: LD_VAR 0 1
4626: NOT
4627: IFFALSE 4631
// continue ;
4629: GO 4601
// EraseResourceArea ( terminalArea , i ) ;
4631: LD_INT 6
4633: PPUSH
4634: LD_VAR 0 4
4638: PPUSH
4639: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4643: LD_EXP 3
4647: PPUSH
4648: CALL_OW 274
4652: PPUSH
4653: LD_VAR 0 4
4657: PPUSH
4658: LD_VAR 0 1
4662: PPUSH
4663: CALL_OW 276
// end ;
4667: GO 4601
4669: POP
4670: POP
// x := 43 ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_INT 43
4678: ST_TO_ADDR
// y := 3 ;
4679: LD_ADDR_VAR 0 3
4683: PUSH
4684: LD_INT 3
4686: ST_TO_ADDR
// for i = 3 to 4 do
4687: LD_ADDR_VAR 0 4
4691: PUSH
4692: DOUBLE
4693: LD_INT 3
4695: DEC
4696: ST_TO_ADDR
4697: LD_INT 4
4699: PUSH
4700: FOR_TO
4701: IFFALSE 4892
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4703: LD_EXP 27
4707: PUSH
4708: LD_VAR 0 4
4712: ARRAY
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4721: LD_EXP 27
4725: PUSH
4726: LD_VAR 0 4
4730: ARRAY
4731: PPUSH
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_VAR 0 3
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4749: LD_EXP 27
4753: PUSH
4754: LD_VAR 0 4
4758: PUSH
4759: LD_INT 2
4761: MINUS
4762: ARRAY
4763: PPUSH
4764: LD_EXP 27
4768: PUSH
4769: LD_VAR 0 4
4773: ARRAY
4774: PPUSH
4775: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4779: LD_EXP 27
4783: PUSH
4784: LD_VAR 0 4
4788: ARRAY
4789: PPUSH
4790: LD_INT 1
4792: PPUSH
4793: LD_INT 100
4795: PPUSH
4796: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4800: LD_EXP 27
4804: PUSH
4805: LD_VAR 0 4
4809: PUSH
4810: LD_INT 2
4812: MINUS
4813: ARRAY
4814: PPUSH
4815: LD_INT 54
4817: PPUSH
4818: LD_INT 42
4820: PPUSH
4821: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4825: LD_EXP 27
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_INT 2
4837: MINUS
4838: ARRAY
4839: PPUSH
4840: LD_EXP 3
4844: PPUSH
4845: CALL_OW 250
4849: PPUSH
4850: LD_EXP 3
4854: PPUSH
4855: CALL_OW 251
4859: PPUSH
4860: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4864: LD_EXP 27
4868: PUSH
4869: LD_VAR 0 4
4873: PUSH
4874: LD_INT 2
4876: MINUS
4877: ARRAY
4878: PPUSH
4879: CALL_OW 200
// Wait ( 0 0$02 ) ;
4883: LD_INT 70
4885: PPUSH
4886: CALL_OW 67
// end ;
4890: GO 4700
4892: POP
4893: POP
// time := 0 0$20 ;
4894: LD_ADDR_VAR 0 8
4898: PUSH
4899: LD_INT 700
4901: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4902: LD_INT 35
4904: PPUSH
4905: CALL_OW 67
// time := time - 0 0$01 ;
4909: LD_ADDR_VAR 0 8
4913: PUSH
4914: LD_VAR 0 8
4918: PUSH
4919: LD_INT 35
4921: MINUS
4922: ST_TO_ADDR
// for i = 3 to 4 do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 3
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 5072
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4939: LD_EXP 27
4943: PUSH
4944: LD_VAR 0 4
4948: ARRAY
4949: PPUSH
4950: LD_INT 1
4952: PPUSH
4953: CALL_OW 289
4957: PUSH
4958: LD_INT 0
4960: GREATER
4961: PUSH
4962: LD_EXP 27
4966: PUSH
4967: LD_VAR 0 4
4971: ARRAY
4972: PPUSH
4973: CALL_OW 314
4977: NOT
4978: AND
4979: IFFALSE 5070
// begin x := rand ( 0 , 5 ) ;
4981: LD_ADDR_VAR 0 2
4985: PUSH
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 5
4991: PPUSH
4992: CALL_OW 12
4996: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4997: LD_EXP 27
5001: PUSH
5002: LD_VAR 0 4
5006: ARRAY
5007: PPUSH
5008: LD_EXP 27
5012: PUSH
5013: LD_VAR 0 4
5017: ARRAY
5018: PPUSH
5019: CALL_OW 250
5023: PPUSH
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 3
5031: PPUSH
5032: CALL_OW 272
5036: PPUSH
5037: LD_EXP 27
5041: PUSH
5042: LD_VAR 0 4
5046: ARRAY
5047: PPUSH
5048: CALL_OW 251
5052: PPUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: CALL_OW 273
5065: PPUSH
5066: CALL_OW 171
// end ;
5070: GO 4936
5072: POP
5073: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 1
5081: ARRAY
5082: PPUSH
5083: LD_INT 54
5085: PPUSH
5086: LD_INT 42
5088: PPUSH
5089: CALL_OW 297
5093: PUSH
5094: LD_INT 4
5096: LESS
5097: PUSH
5098: LD_VAR 0 8
5102: PUSH
5103: LD_INT 0
5105: EQUAL
5106: OR
5107: IFFALSE 4902
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
5109: LD_EXP 27
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
5128: LD_EXP 27
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: LD_INT 0
5142: PPUSH
5143: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
5147: LD_EXP 3
5151: PPUSH
5152: CALL_OW 274
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 200
5162: PPUSH
5163: CALL_OW 276
// DialogueOn ;
5167: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5171: LD_INT 53
5173: PPUSH
5174: LD_INT 35
5176: PPUSH
5177: CALL_OW 86
// un := powell_trans [ 1 ] ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_EXP 27
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D4-Mech1-1
5202: PPUSH
5203: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5207: LD_EXP 21
5211: PPUSH
5212: LD_STRING D4-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5219: LD_VAR 0 5
5223: PPUSH
5224: LD_STRING D4-Mech1-2
5226: PPUSH
5227: CALL_OW 88
// powell_happy := false ;
5231: LD_ADDR_VAR 0 6
5235: PUSH
5236: LD_INT 0
5238: ST_TO_ADDR
// take_cargo := false ;
5239: LD_ADDR_VAR 0 7
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5247: CALL 943 0 0
5251: PUSH
5252: LD_INT 60
5254: GREATEREQUAL
5255: IFFALSE 5303
// begin Say ( JMM , D5-JMM-1 ) ;
5257: LD_EXP 21
5261: PPUSH
5262: LD_STRING D5-JMM-1
5264: PPUSH
5265: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5269: LD_VAR 0 5
5273: PPUSH
5274: LD_STRING D6-Mech1-1
5276: PPUSH
5277: CALL_OW 88
// powell_happy := true ;
5281: LD_ADDR_VAR 0 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// take_cargo := true ;
5289: LD_ADDR_VAR 0 7
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// DialogueOff ;
5297: CALL_OW 7
// end else
5301: GO 5537
// if GetTerminalCargo > 0 then
5303: CALL 943 0 0
5307: PUSH
5308: LD_INT 0
5310: GREATER
5311: IFFALSE 5509
// begin case Query ( QWait ) of 1 :
5313: LD_STRING QWait
5315: PPUSH
5316: CALL_OW 97
5320: PUSH
5321: LD_INT 1
5323: DOUBLE
5324: EQUAL
5325: IFTRUE 5329
5327: GO 5420
5329: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5330: LD_EXP 21
5334: PPUSH
5335: LD_STRING D5a-JMM-1
5337: PPUSH
5338: CALL_OW 88
// DialogueOff ;
5342: CALL_OW 7
// wait ( 5 5$00 ) ;
5346: LD_INT 10500
5348: PPUSH
5349: CALL_OW 67
// if GetTerminalCargo < 60 then
5353: CALL 943 0 0
5357: PUSH
5358: LD_INT 60
5360: LESS
5361: IFFALSE 5402
// begin DialogueOn ;
5363: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5367: LD_EXP 3
5371: PPUSH
5372: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_STRING D6-Mech1-1a
5383: PPUSH
5384: CALL_OW 88
// DialogueOff ;
5388: CALL_OW 7
// powell_happy := false ;
5392: LD_ADDR_VAR 0 6
5396: PUSH
5397: LD_INT 0
5399: ST_TO_ADDR
// end else
5400: GO 5418
// begin powell_happy := true ;
5402: LD_ADDR_VAR 0 6
5406: PUSH
5407: LD_INT 1
5409: ST_TO_ADDR
// take_cargo := true ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// end ; end ; 2 :
5418: GO 5507
5420: LD_INT 2
5422: DOUBLE
5423: EQUAL
5424: IFTRUE 5428
5426: GO 5467
5428: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5429: LD_EXP 21
5433: PPUSH
5434: LD_STRING D5b-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_STRING D6-Mech1-1a
5448: PPUSH
5449: CALL_OW 88
// DialogueOff ;
5453: CALL_OW 7
// take_cargo := true ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// end ; 3 :
5465: GO 5507
5467: LD_INT 3
5469: DOUBLE
5470: EQUAL
5471: IFTRUE 5475
5473: GO 5506
5475: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5476: LD_EXP 21
5480: PPUSH
5481: LD_STRING D5c-JMM-1
5483: PPUSH
5484: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5488: LD_VAR 0 5
5492: PPUSH
5493: LD_STRING D6-Mech1-1b
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ; end ;
5504: GO 5507
5506: POP
// end else
5507: GO 5537
// begin Say ( JMM , D5c-JMM-1 ) ;
5509: LD_EXP 21
5513: PPUSH
5514: LD_STRING D5c-JMM-1
5516: PPUSH
5517: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_STRING D6-Mech1-1b
5528: PPUSH
5529: CALL_OW 88
// DialogueOff ;
5533: CALL_OW 7
// end ; if take_cargo then
5537: LD_VAR 0 7
5541: IFFALSE 5620
// begin x := GetTerminalCargo ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL 943 0 0
5552: ST_TO_ADDR
// if x > 60 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 60
5560: GREATER
5561: IFFALSE 5571
// x := 60 ;
5563: LD_ADDR_VAR 0 2
5567: PUSH
5568: LD_INT 60
5570: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5571: LD_EXP 3
5575: PPUSH
5576: CALL_OW 274
5580: PPUSH
5581: LD_INT 3
5583: PPUSH
5584: CALL 943 0 0
5588: PUSH
5589: LD_VAR 0 2
5593: MINUS
5594: PPUSH
5595: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5599: LD_EXP 27
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PPUSH
5608: LD_INT 3
5610: PPUSH
5611: LD_VAR 0 2
5615: PPUSH
5616: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5620: LD_EXP 27
5624: PPUSH
5625: LD_INT 43
5627: PPUSH
5628: LD_INT 3
5630: PPUSH
5631: CALL_OW 171
// x := 0 0$20 ;
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_INT 700
5642: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5643: LD_INT 35
5645: PPUSH
5646: CALL_OW 67
// x := x - 0 0$01 ;
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 35
5662: MINUS
5663: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5664: LD_VAR 0 2
5668: PUSH
5669: LD_INT 0
5671: EQUAL
5672: PUSH
5673: LD_EXP 27
5677: PUSH
5678: LD_INT 3
5680: ARRAY
5681: PPUSH
5682: LD_INT 43
5684: PPUSH
5685: LD_INT 3
5687: PPUSH
5688: CALL_OW 297
5692: PUSH
5693: LD_INT 4
5695: LESS
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ARRAY
5705: PPUSH
5706: LD_INT 43
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: CALL_OW 297
5716: PUSH
5717: LD_INT 4
5719: LESS
5720: AND
5721: OR
5722: IFFALSE 5643
// for i in powell_trans do
5724: LD_ADDR_VAR 0 4
5728: PUSH
5729: LD_EXP 27
5733: PUSH
5734: FOR_IN
5735: IFFALSE 5748
// RemoveUnit ( i ) ;
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 64
5746: GO 5734
5748: POP
5749: POP
// if not powell_happy then
5750: LD_VAR 0 6
5754: NOT
5755: IFFALSE 5766
// powell_happy := - 1 ;
5757: LD_ADDR_VAR 0 6
5761: PUSH
5762: LD_INT 1
5764: NEG
5765: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5766: LD_STRING EarlySiberite
5768: PPUSH
5769: LD_VAR 0 6
5773: PPUSH
5774: CALL_OW 101
// if powell_happy then
5778: LD_VAR 0 6
5782: IFFALSE 5792
// earlySib := true ;
5784: LD_ADDR_EXP 19
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// if powell_happy then
5792: LD_VAR 0 6
5796: IFFALSE 5807
// ChangeMissionObjectives ( M3a ) else
5798: LD_STRING M3a
5800: PPUSH
5801: CALL_OW 337
5805: GO 5814
// ChangeMissionObjectives ( M3b ) ;
5807: LD_STRING M3b
5809: PPUSH
5810: CALL_OW 337
// ru_can_attack_terminal := true ;
5814: LD_ADDR_EXP 9
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5822: LD_INT 25200
5824: PPUSH
5825: CALL_OW 67
// time := 2 2$00 ;
5829: LD_ADDR_VAR 0 8
5833: PUSH
5834: LD_INT 4200
5836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5837: LD_INT 35
5839: PPUSH
5840: CALL_OW 67
// time := time - 0 0$1 ;
5844: LD_ADDR_VAR 0 8
5848: PUSH
5849: LD_VAR 0 8
5853: PUSH
5854: LD_INT 35
5856: MINUS
5857: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5858: LD_EXP 8
5862: NOT
5863: PUSH
5864: LD_EXP 38
5868: PUSH
5869: LD_INT 0
5871: EQUAL
5872: OR
5873: PUSH
5874: LD_VAR 0 8
5878: PUSH
5879: LD_INT 0
5881: EQUAL
5882: OR
5883: IFFALSE 5837
// if ru_force then
5885: LD_EXP 38
5889: IFFALSE 5988
// for i in ru_force do
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_EXP 38
5900: PUSH
5901: FOR_IN
5902: IFFALSE 5986
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 4
5911: PPUSH
5912: CALL_OW 292
5916: NOT
5917: PUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: LD_INT 81
5925: PUSH
5926: LD_INT 3
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PPUSH
5938: LD_VAR 0 4
5942: PPUSH
5943: CALL_OW 74
5947: PPUSH
5948: CALL_OW 296
5952: PUSH
5953: LD_INT 10
5955: GREATER
5956: AND
5957: IFFALSE 5984
// begin RemoveUnit ( i ) ;
5959: LD_VAR 0 4
5963: PPUSH
5964: CALL_OW 64
// ru_force := ru_force diff i ;
5968: LD_ADDR_EXP 38
5972: PUSH
5973: LD_EXP 38
5977: PUSH
5978: LD_VAR 0 4
5982: DIFF
5983: ST_TO_ADDR
// end ;
5984: GO 5901
5986: POP
5987: POP
// repeat wait ( 0 0$03 ) ;
5988: LD_INT 105
5990: PPUSH
5991: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5995: LD_EXP 8
5999: NOT
6000: PUSH
6001: LD_EXP 38
6005: PUSH
6006: LD_INT 3
6008: LESS
6009: OR
6010: IFFALSE 5988
// ar_can_arrive := true ;
6012: LD_ADDR_EXP 10
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// end ;
6020: PPOPN 8
6022: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 20
6028: PPUSH
6029: CALL_OW 325
6033: IFFALSE 6180
6035: GO 6037
6037: DISABLE
6038: LD_INT 0
6040: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Gary , Cyrus , Bobby , Houten ] ;
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_INT 22
6048: PUSH
6049: LD_INT 1
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PUSH
6056: LD_INT 26
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 25
6068: PUSH
6069: LD_INT 4
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: LD_EXP 22
6095: PUSH
6096: LD_EXP 24
6100: PUSH
6101: LD_EXP 23
6105: PUSH
6106: LD_EXP 25
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: DIFF
6118: ST_TO_ADDR
// if not un then
6119: LD_VAR 0 1
6123: NOT
6124: IFFALSE 6128
// exit ;
6126: GO 6180
// DialogueOn ;
6128: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
6132: LD_VAR 0 1
6136: PUSH
6137: LD_INT 1
6139: ARRAY
6140: PPUSH
6141: LD_STRING D13-Sci1-1
6143: PPUSH
6144: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
6148: LD_EXP 21
6152: PPUSH
6153: LD_STRING D13-JMM-1
6155: PPUSH
6156: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
6160: LD_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: ARRAY
6168: PPUSH
6169: LD_STRING D13-Sci1-2
6171: PPUSH
6172: CALL_OW 88
// DialogueOff ;
6176: CALL_OW 7
// end ;
6180: PPOPN 1
6182: END
// every 0 0$1 trigger GetTerminalCargo > 77 and not InBattle ( 1 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6183: CALL 943 0 0
6187: PUSH
6188: LD_INT 77
6190: GREATER
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 463
6199: NOT
6200: AND
6201: PUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 25
6214: PUSH
6215: LD_INT 4
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 26
6224: PUSH
6225: LD_INT 1
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: PUSH
6242: LD_EXP 21
6246: PUSH
6247: LD_EXP 23
6251: PUSH
6252: LD_EXP 24
6256: PUSH
6257: LD_EXP 22
6261: PUSH
6262: LD_EXP 25
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: AND
6275: IFFALSE 6453
6277: GO 6279
6279: DISABLE
6280: LD_INT 0
6282: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: LD_INT 22
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 25
6300: PUSH
6301: LD_INT 4
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: PUSH
6308: LD_INT 26
6310: PUSH
6311: LD_INT 1
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: PUSH
6328: LD_EXP 21
6332: PUSH
6333: LD_EXP 23
6337: PUSH
6338: LD_EXP 24
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: LD_EXP 25
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: DIFF
6360: ST_TO_ADDR
// DialogueOn ;
6361: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: ARRAY
6373: PPUSH
6374: LD_STRING D7-Sci1-1
6376: PPUSH
6377: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6381: LD_EXP 21
6385: PPUSH
6386: LD_STRING D7-JMM-1
6388: PPUSH
6389: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6393: LD_VAR 0 1
6397: PUSH
6398: LD_INT 1
6400: ARRAY
6401: PPUSH
6402: LD_STRING D7-Sci1-2
6404: PPUSH
6405: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6409: LD_EXP 21
6413: PPUSH
6414: LD_STRING D7-JMM-2
6416: PPUSH
6417: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 1
6428: ARRAY
6429: PPUSH
6430: LD_STRING D7-Sci1-3
6432: PPUSH
6433: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6437: LD_EXP 21
6441: PPUSH
6442: LD_STRING D7-JMM-3
6444: PPUSH
6445: CALL_OW 88
// DialogueOff ;
6449: CALL_OW 7
// end ;
6453: PPOPN 1
6455: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6456: LD_EXP 10
6460: IFFALSE 10083
6462: GO 6464
6464: DISABLE
6465: LD_INT 0
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
// begin PrepareArabian ;
6477: CALL 12827 0 0
// blocked := false ;
6481: LD_ADDR_EXP 18
6485: PUSH
6486: LD_INT 0
6488: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6489: LD_INT 35
6491: PPUSH
6492: CALL_OW 67
// until ar_spawned ;
6496: LD_EXP 11
6500: IFFALSE 6489
// have_crates := true ;
6502: LD_ADDR_VAR 0 9
6506: PUSH
6507: LD_INT 1
6509: ST_TO_ADDR
// player_want_info := 2 ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 2
6517: ST_TO_ADDR
// DialogueOn ;
6518: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6522: LD_EXP 29
6526: PPUSH
6527: LD_STRING D8-Ar1-1
6529: PPUSH
6530: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6534: LD_EXP 21
6538: PPUSH
6539: LD_STRING D8-JMM-1
6541: PPUSH
6542: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6546: LD_EXP 29
6550: PPUSH
6551: LD_STRING D8-Ar1-2
6553: PPUSH
6554: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6558: LD_EXP 21
6562: PPUSH
6563: LD_STRING D8-JMM-2
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6570: LD_EXP 29
6574: PPUSH
6575: LD_STRING D8-Ar1-3
6577: PPUSH
6578: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6582: LD_EXP 21
6586: PPUSH
6587: LD_STRING D8-JMM-3
6589: PPUSH
6590: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6594: LD_EXP 29
6598: PPUSH
6599: LD_STRING D8-Ar1-4
6601: PPUSH
6602: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6606: LD_EXP 21
6610: PPUSH
6611: LD_STRING D8-JMM-4
6613: PPUSH
6614: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6618: LD_EXP 29
6622: PPUSH
6623: LD_STRING D8-Ar1-5
6625: PPUSH
6626: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6630: LD_EXP 21
6634: PPUSH
6635: LD_STRING D8-JMM-5
6637: PPUSH
6638: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6642: LD_EXP 29
6646: PPUSH
6647: LD_STRING D8-Ar1-6
6649: PPUSH
6650: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6654: LD_EXP 30
6658: PPUSH
6659: LD_STRING D8-Ar2-6
6661: PPUSH
6662: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6666: LD_EXP 21
6670: PPUSH
6671: LD_STRING D8-JMM-6
6673: PPUSH
6674: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6678: LD_EXP 30
6682: PPUSH
6683: LD_STRING D8-Ar2-7
6685: PPUSH
6686: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6690: LD_STRING QBarracks
6692: PPUSH
6693: CALL_OW 97
6697: PUSH
6698: LD_INT 1
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6741
6706: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6707: LD_EXP 21
6711: PPUSH
6712: LD_STRING D8a-JMM-1
6714: PPUSH
6715: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6719: LD_EXP 29
6723: PPUSH
6724: LD_STRING D8a-Ar1-1
6726: PPUSH
6727: CALL_OW 94
// player_want_mortar := true ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 1
6738: ST_TO_ADDR
// end ; 2 :
6739: GO 6915
6741: LD_INT 2
6743: DOUBLE
6744: EQUAL
6745: IFTRUE 6749
6747: GO 6871
6749: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6750: LD_EXP 21
6754: PPUSH
6755: LD_STRING D8b-JMM-1
6757: PPUSH
6758: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6762: LD_EXP 29
6766: PPUSH
6767: LD_STRING D8b-Ar1-1
6769: PPUSH
6770: CALL_OW 94
// case Query ( QInfo ) of 1 :
6774: LD_STRING QInfo
6776: PPUSH
6777: CALL_OW 97
6781: PUSH
6782: LD_INT 1
6784: DOUBLE
6785: EQUAL
6786: IFTRUE 6790
6788: GO 6825
6790: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6791: LD_EXP 21
6795: PPUSH
6796: LD_STRING D8b1-JMM-1
6798: PPUSH
6799: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6803: LD_EXP 29
6807: PPUSH
6808: LD_STRING D8b1-Ar1-1
6810: PPUSH
6811: CALL_OW 94
// player_want_info := 2 ;
6815: LD_ADDR_EXP 13
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
// end ; 2 :
6823: GO 6869
6825: LD_INT 2
6827: DOUBLE
6828: EQUAL
6829: IFTRUE 6833
6831: GO 6868
6833: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6834: LD_EXP 21
6838: PPUSH
6839: LD_STRING D8b2-JMM-1
6841: PPUSH
6842: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6846: LD_EXP 29
6850: PPUSH
6851: LD_STRING D8b2-Ar1-1
6853: PPUSH
6854: CALL_OW 94
// player_want_info := 0 ;
6858: LD_ADDR_EXP 13
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ; end ;
6866: GO 6869
6868: POP
// end ; 3 :
6869: GO 6915
6871: LD_INT 3
6873: DOUBLE
6874: EQUAL
6875: IFTRUE 6879
6877: GO 6914
6879: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6880: LD_EXP 21
6884: PPUSH
6885: LD_STRING D8c-JMM-1
6887: PPUSH
6888: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6892: LD_EXP 29
6896: PPUSH
6897: LD_STRING D8c-Ar1-1
6899: PPUSH
6900: CALL_OW 94
// player_want_info := 0 ;
6904: LD_ADDR_EXP 13
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// end ; end ;
6912: GO 6915
6914: POP
// DialogueOff ;
6915: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: LD_INT 9
6926: PPUSH
6927: LD_INT 2
6929: PUSH
6930: LD_INT 30
6932: PUSH
6933: LD_INT 0
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 30
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 70
6959: ST_TO_ADDR
// if dep then
6960: LD_VAR 0 4
6964: IFFALSE 6980
// dep := dep [ 1 ] ;
6966: LD_ADDR_VAR 0 4
6970: PUSH
6971: LD_VAR 0 4
6975: PUSH
6976: LD_INT 1
6978: ARRAY
6979: ST_TO_ADDR
// if not dep then
6980: LD_VAR 0 4
6984: NOT
6985: IFFALSE 7023
// begin case Query ( QInfoNothing ) of 1 :
6987: LD_STRING QInfoNothing
6989: PPUSH
6990: CALL_OW 97
6994: PUSH
6995: LD_INT 1
6997: DOUBLE
6998: EQUAL
6999: IFTRUE 7003
7001: GO 7006
7003: POP
// ; end ;
7004: GO 7007
7006: POP
// player_want_info := false ;
7007: LD_ADDR_EXP 13
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
// player_want_mortar := false ;
7015: LD_ADDR_EXP 12
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
7023: LD_ADDR_VAR 0 3
7027: PUSH
7028: LD_INT 22
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 21
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PPUSH
7052: CALL_OW 69
7056: ST_TO_ADDR
// time := 1 1$55 ;
7057: LD_ADDR_VAR 0 5
7061: PUSH
7062: LD_INT 4025
7064: ST_TO_ADDR
// no_oil_gain := false ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// first_warn := false ;
7073: LD_ADDR_VAR 0 7
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// if player_want_mortar or player_want_info then
7081: LD_EXP 12
7085: PUSH
7086: LD_EXP 13
7090: OR
7091: IFFALSE 7196
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
7093: LD_EXP 36
7097: PPUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: CALL_OW 250
7122: PPUSH
7123: LD_VAR 0 4
7127: PPUSH
7128: CALL_OW 251
7132: PPUSH
7133: LD_VAR 0 4
7137: PPUSH
7138: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
7142: LD_EXP 36
7146: PPUSH
7147: LD_INT 25
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PPUSH
7162: LD_INT 86
7164: PPUSH
7165: LD_INT 121
7167: PPUSH
7168: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7172: LD_EXP 36
7176: PPUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 72
7191: PPUSH
7192: CALL_OW 200
// end ; if player_attacked_ar then
7196: LD_EXP 16
7200: IFFALSE 7204
// exit ;
7202: GO 10083
// if player_want_mortar then
7204: LD_EXP 12
7208: IFFALSE 8745
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7210: LD_EXP 30
7214: PPUSH
7215: LD_VAR 0 4
7219: PPUSH
7220: CALL_OW 250
7224: PUSH
7225: LD_INT 1
7227: PLUS
7228: PPUSH
7229: LD_VAR 0 4
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 1
7241: PLUS
7242: PPUSH
7243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7247: LD_INT 35
7249: PPUSH
7250: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7254: LD_EXP 30
7258: PPUSH
7259: LD_VAR 0 4
7263: PPUSH
7264: CALL_OW 296
7268: PUSH
7269: LD_INT 4
7271: LESS
7272: IFFALSE 7247
// for i = 1 to 6 do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: DOUBLE
7280: LD_INT 1
7282: DEC
7283: ST_TO_ADDR
7284: LD_INT 6
7286: PUSH
7287: FOR_TO
7288: IFFALSE 7492
// begin if player_attacked_ar then
7290: LD_EXP 16
7294: IFFALSE 7300
// exit ;
7296: POP
7297: POP
7298: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7300: LD_VAR 0 4
7304: PPUSH
7305: CALL_OW 274
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 275
7317: PUSH
7318: LD_INT 10
7320: LESS
7321: PUSH
7322: LD_VAR 0 7
7326: NOT
7327: AND
7328: IFFALSE 7391
// begin first_warn := true ;
7330: LD_ADDR_VAR 0 7
7334: PUSH
7335: LD_INT 1
7337: ST_TO_ADDR
// DialogueOn ;
7338: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7342: LD_EXP 31
7346: PPUSH
7347: LD_STRING D9a-FAr1-1
7349: PPUSH
7350: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7354: LD_EXP 21
7358: PPUSH
7359: LD_STRING D9a-JMM-1
7361: PPUSH
7362: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7366: LD_EXP 29
7370: PPUSH
7371: LD_STRING D9a2-Ar1-1
7373: PPUSH
7374: CALL_OW 88
// DialogueOff ;
7378: CALL_OW 7
// wait ( time ) ;
7382: LD_VAR 0 5
7386: PPUSH
7387: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7391: LD_VAR 0 4
7395: PPUSH
7396: CALL_OW 274
7400: PPUSH
7401: LD_INT 2
7403: PPUSH
7404: CALL_OW 275
7408: PUSH
7409: LD_INT 10
7411: LESS
7412: IFFALSE 7438
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7414: LD_EXP 29
7418: PPUSH
7419: LD_STRING D9a3-Ar1-1
7421: PPUSH
7422: CALL_OW 88
// no_oil_gain := true ;
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// break ;
7434: GO 7492
// end else
7436: GO 7490
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7438: LD_EXP 30
7442: PPUSH
7443: LD_VAR 0 4
7447: PPUSH
7448: LD_INT 2
7450: PPUSH
7451: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7455: LD_EXP 30
7459: PPUSH
7460: LD_VAR 0 3
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: MOD
7473: PUSH
7474: LD_INT 1
7476: PLUS
7477: ARRAY
7478: PPUSH
7479: CALL_OW 210
// wait ( 0 0$10 ) ;
7483: LD_INT 350
7485: PPUSH
7486: CALL_OW 67
// end ; end ;
7490: GO 7287
7492: POP
7493: POP
// if not no_oil_gain then
7494: LD_VAR 0 6
7498: NOT
7499: IFFALSE 8745
// begin repeat wait ( 0 0$01 ) ;
7501: LD_INT 35
7503: PPUSH
7504: CALL_OW 67
// if player_attacked_ar then
7508: LD_EXP 16
7512: IFFALSE 7516
// exit ;
7514: GO 10083
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7516: LD_VAR 0 3
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: CALL_OW 261
7529: PUSH
7530: LD_INT 80
7532: GREATER
7533: PUSH
7534: LD_VAR 0 3
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: PPUSH
7543: CALL_OW 261
7547: PUSH
7548: LD_INT 80
7550: GREATER
7551: AND
7552: PUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 3
7560: ARRAY
7561: PPUSH
7562: CALL_OW 261
7566: PUSH
7567: LD_INT 80
7569: GREATER
7570: AND
7571: IFFALSE 7501
// ComMoveXY ( Gali , 105 , 127 ) ;
7573: LD_EXP 30
7577: PPUSH
7578: LD_INT 105
7580: PPUSH
7581: LD_INT 127
7583: PPUSH
7584: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7588: LD_EXP 30
7592: PPUSH
7593: LD_INT 2
7595: PPUSH
7596: CALL_OW 173
// AddComHold ( Gali ) ;
7600: LD_EXP 30
7604: PPUSH
7605: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 10083
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7624: LD_EXP 30
7628: PPUSH
7629: LD_INT 105
7631: PPUSH
7632: LD_INT 127
7634: PPUSH
7635: CALL_OW 297
7639: PUSH
7640: LD_INT 4
7642: LESS
7643: IFFALSE 7609
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7645: LD_VAR 0 4
7649: PPUSH
7650: CALL_OW 274
7654: PPUSH
7655: LD_INT 1
7657: PPUSH
7658: CALL_OW 275
7662: PUSH
7663: LD_INT 50
7665: LESS
7666: IFFALSE 7968
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7668: LD_VAR 0 4
7672: PPUSH
7673: CALL_OW 274
7677: PPUSH
7678: LD_INT 1
7680: PPUSH
7681: CALL_OW 275
7685: PUSH
7686: LD_INT 0
7688: DOUBLE
7689: GREATEREQUAL
7690: IFFALSE 7698
7692: LD_INT 24
7694: DOUBLE
7695: LESSEQUAL
7696: IFTRUE 7700
7698: GO 7715
7700: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7701: LD_EXP 30
7705: PPUSH
7706: LD_STRING D9b-Ar2-1
7708: PPUSH
7709: CALL_OW 88
7713: GO 7745
7715: LD_INT 25
7717: DOUBLE
7718: GREATEREQUAL
7719: IFFALSE 7727
7721: LD_INT 49
7723: DOUBLE
7724: LESSEQUAL
7725: IFTRUE 7729
7727: GO 7744
7729: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7730: LD_EXP 30
7734: PPUSH
7735: LD_STRING D9b-Ar2-1a
7737: PPUSH
7738: CALL_OW 88
7742: GO 7745
7744: POP
// Say ( JMM , D9b-JMM-1 ) ;
7745: LD_EXP 21
7749: PPUSH
7750: LD_STRING D9b-JMM-1
7752: PPUSH
7753: CALL_OW 88
// x := 0 0$0 ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: LD_INT 0
7764: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7765: LD_INT 35
7767: PPUSH
7768: CALL_OW 67
// x := x + 0 0$1 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 35
7784: PLUS
7785: ST_TO_ADDR
// if player_attacked_ar then
7786: LD_EXP 16
7790: IFFALSE 7794
// exit ;
7792: GO 10083
// until x >= time ;
7794: LD_VAR 0 2
7798: PUSH
7799: LD_VAR 0 5
7803: GREATEREQUAL
7804: IFFALSE 7765
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7806: LD_VAR 0 4
7810: PPUSH
7811: CALL_OW 274
7815: PPUSH
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 275
7823: PUSH
7824: LD_INT 50
7826: LESS
7827: IFFALSE 7968
// begin have_crates := false ;
7829: LD_ADDR_VAR 0 9
7833: PUSH
7834: LD_INT 0
7836: ST_TO_ADDR
// DialogueOn ;
7837: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7841: LD_EXP 29
7845: PPUSH
7846: LD_STRING D9c-Ar1-1
7848: PPUSH
7849: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7853: LD_EXP 21
7857: PPUSH
7858: LD_STRING D9c-JMM-1
7860: PPUSH
7861: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7865: LD_EXP 29
7869: PPUSH
7870: LD_STRING D9c-Ar1-2
7872: PPUSH
7873: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7877: LD_EXP 31
7881: PPUSH
7882: LD_STRING D9c-FAr1-2
7884: PPUSH
7885: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7889: LD_EXP 29
7893: PPUSH
7894: LD_STRING D9c-Ar1-3
7896: PPUSH
7897: CALL_OW 88
// case Query ( QInfo ) of 1 :
7901: LD_STRING QInfo
7903: PPUSH
7904: CALL_OW 97
7908: PUSH
7909: LD_INT 1
7911: DOUBLE
7912: EQUAL
7913: IFTRUE 7917
7915: GO 7940
7917: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7918: LD_EXP 21
7922: PPUSH
7923: LD_STRING D8b1-JMM-1
7925: PPUSH
7926: CALL_OW 88
// player_want_info := 2 ;
7930: LD_ADDR_EXP 13
7934: PUSH
7935: LD_INT 2
7937: ST_TO_ADDR
// end ; 2 :
7938: GO 7964
7940: LD_INT 2
7942: DOUBLE
7943: EQUAL
7944: IFTRUE 7948
7946: GO 7963
7948: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7949: LD_EXP 29
7953: PPUSH
7954: LD_STRING D8b2-Ar1-1
7956: PPUSH
7957: CALL_OW 88
// end ; end ;
7961: GO 7964
7963: POP
// DialogueOff ;
7964: CALL_OW 7
// end ; end ; if have_crates then
7968: LD_VAR 0 9
7972: IFFALSE 8745
// begin RemoveEnvironmentArea ( mortarArea ) ;
7974: LD_INT 2
7976: PPUSH
7977: CALL_OW 355
// wait ( 1 ) ;
7981: LD_INT 1
7983: PPUSH
7984: CALL_OW 67
// InGameOn ;
7988: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7992: LD_EXP 30
7996: PPUSH
7997: CALL_OW 87
// SetSide ( Gali , 1 ) ;
8001: LD_EXP 30
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
8013: LD_ADDR_VAR 0 10
8017: PUSH
8018: LD_INT 22
8020: PUSH
8021: LD_INT 1
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 23
8033: PUSH
8034: LD_INT 2
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 21
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 92
8057: PUSH
8058: LD_INT 107
8060: PUSH
8061: LD_INT 131
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: ST_TO_ADDR
// if filter then
8084: LD_VAR 0 10
8088: IFFALSE 8122
// for i in filter do
8090: LD_ADDR_VAR 0 1
8094: PUSH
8095: LD_VAR 0 10
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8120
// ComMoveXY ( i , 107 , 121 ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_INT 107
8110: PPUSH
8111: LD_INT 121
8113: PPUSH
8114: CALL_OW 111
8118: GO 8100
8120: POP
8121: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
8122: LD_EXP 30
8126: PPUSH
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 131
8135: PPUSH
8136: LD_INT 0
8138: PPUSH
8139: CALL_OW 145
// wait ( 0 0$1 ) ;
8143: LD_INT 35
8145: PPUSH
8146: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
8150: LD_INT 30
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 23
8162: PUSH
8163: LD_INT 2
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: IFFALSE 8013
// SetSide ( Gali , 2 ) ;
8180: LD_EXP 30
8184: PPUSH
8185: LD_INT 2
8187: PPUSH
8188: CALL_OW 235
// InGameOff ;
8192: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8196: LD_ADDR_VAR 0 8
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 4
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 23
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8234: LD_INT 35
8236: PPUSH
8237: CALL_OW 67
// if player_attacked_ar then
8241: LD_EXP 16
8245: IFFALSE 8249
// exit ;
8247: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8249: LD_VAR 0 8
8253: PPUSH
8254: CALL_OW 461
8258: PUSH
8259: LD_INT 1
8261: NONEQUAL
8262: IFFALSE 8234
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8264: LD_VAR 0 8
8268: PPUSH
8269: CALL_OW 302
8273: PUSH
8274: LD_VAR 0 4
8278: PPUSH
8279: CALL_OW 274
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 275
8291: PUSH
8292: LD_INT 25
8294: GREATEREQUAL
8295: AND
8296: IFFALSE 8395
// begin ComUpgrade ( b ) ;
8298: LD_VAR 0 8
8302: PPUSH
8303: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8307: LD_EXP 30
8311: PPUSH
8312: LD_STRING h
8314: PUSH
8315: LD_VAR 0 8
8319: PPUSH
8320: CALL_OW 250
8324: PUSH
8325: LD_VAR 0 8
8329: PPUSH
8330: CALL_OW 251
8334: PUSH
8335: LD_VAR 0 8
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: PPUSH
8361: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// if player_attacked_ar then
8372: LD_EXP 16
8376: IFFALSE 8380
// exit ;
8378: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8380: LD_VAR 0 8
8384: PPUSH
8385: CALL_OW 461
8389: PUSH
8390: LD_INT 1
8392: NONEQUAL
8393: IFFALSE 8365
// end ; if b then
8395: LD_VAR 0 8
8399: IFFALSE 8410
// CenterNowOnUnits ( b ) ;
8401: LD_VAR 0 8
8405: PPUSH
8406: CALL_OW 87
// DialogueOn ;
8410: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8414: LD_EXP 30
8418: PPUSH
8419: LD_STRING D9d-Ar2-1
8421: PPUSH
8422: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8426: LD_EXP 29
8430: PPUSH
8431: LD_STRING D9d-Ar1-1
8433: PPUSH
8434: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8438: LD_EXP 21
8442: PPUSH
8443: LD_STRING D9d-JMM-1
8445: PPUSH
8446: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8450: LD_EXP 29
8454: PPUSH
8455: LD_STRING D9d-Ar1-2
8457: PPUSH
8458: CALL_OW 88
// DialogueOff ;
8462: CALL_OW 7
// i := [ ] ;
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: EMPTY
8472: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8473: LD_VAR 0 4
8477: PPUSH
8478: CALL_OW 274
8482: PPUSH
8483: LD_INT 3
8485: PPUSH
8486: CALL_OW 275
8490: PUSH
8491: LD_INT 20
8493: GREATEREQUAL
8494: IFFALSE 8513
// i := i ^ [ 1 ] ;
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_VAR 0 1
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: EMPTY
8510: LIST
8511: ADD
8512: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8513: LD_VAR 0 4
8517: PPUSH
8518: CALL_OW 274
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_INT 50
8533: GREATEREQUAL
8534: IFFALSE 8553
// i := i ^ [ 2 ] ;
8536: LD_ADDR_VAR 0 1
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: EMPTY
8550: LIST
8551: ADD
8552: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL_OW 274
8562: PPUSH
8563: LD_INT 2
8565: PPUSH
8566: CALL_OW 275
8570: PUSH
8571: LD_INT 80
8573: GREATEREQUAL
8574: IFFALSE 8593
// i := i ^ [ 3 ] ;
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: LD_VAR 0 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: ADD
8592: ST_TO_ADDR
// i := i diff 0 ;
8593: LD_ADDR_VAR 0 1
8597: PUSH
8598: LD_VAR 0 1
8602: PUSH
8603: LD_INT 0
8605: DIFF
8606: ST_TO_ADDR
// if i then
8607: LD_VAR 0 1
8611: IFFALSE 8717
// begin i := i ^ [ 4 ] ;
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 4
8625: PUSH
8626: EMPTY
8627: LIST
8628: ADD
8629: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8630: LD_STRING QInfo2
8632: PPUSH
8633: CALL_OW 97
8637: PUSH
8638: LD_INT 1
8640: DOUBLE
8641: EQUAL
8642: IFTRUE 8646
8644: GO 8657
8646: POP
// player_want_info := 3 ; 2 :
8647: LD_ADDR_EXP 13
8651: PUSH
8652: LD_INT 3
8654: ST_TO_ADDR
8655: GO 8715
8657: LD_INT 2
8659: DOUBLE
8660: EQUAL
8661: IFTRUE 8665
8663: GO 8676
8665: POP
// player_want_info := 1 ; 3 :
8666: LD_ADDR_EXP 13
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
8674: GO 8715
8676: LD_INT 3
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8695
8684: POP
// player_want_info := 2 ; 4 :
8685: LD_ADDR_EXP 13
8689: PUSH
8690: LD_INT 2
8692: ST_TO_ADDR
8693: GO 8715
8695: LD_INT 4
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8714
8703: POP
// player_want_info := 0 ; end ;
8704: LD_ADDR_EXP 13
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
8712: GO 8715
8714: POP
// end else
8715: GO 8745
// case Query ( QInfoNothing ) of 1 :
8717: LD_STRING QInfoNothing
8719: PPUSH
8720: CALL_OW 97
8724: PUSH
8725: LD_INT 1
8727: DOUBLE
8728: EQUAL
8729: IFTRUE 8733
8731: GO 8744
8733: POP
// player_want_info := 0 ; end ;
8734: LD_ADDR_EXP 13
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
8742: GO 8745
8744: POP
// end ; end ; end ; if player_want_info then
8745: LD_EXP 13
8749: IFFALSE 9903
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8751: LD_ADDR_VAR 0 3
8755: PUSH
8756: LD_VAR 0 3
8760: PPUSH
8761: LD_INT 34
8763: PUSH
8764: LD_INT 32
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 72
8775: ST_TO_ADDR
// if player_want_mortar then
8776: LD_EXP 12
8780: IFFALSE 9135
// begin case player_want_info of 1 :
8782: LD_EXP 13
8786: PUSH
8787: LD_INT 1
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8806
8795: POP
// x := 5 ; 2 :
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: LD_INT 5
8803: ST_TO_ADDR
8804: GO 8845
8806: LD_INT 2
8808: DOUBLE
8809: EQUAL
8810: IFTRUE 8814
8812: GO 8825
8814: POP
// x := 8 ; 3 :
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 8
8822: ST_TO_ADDR
8823: GO 8845
8825: LD_INT 3
8827: DOUBLE
8828: EQUAL
8829: IFTRUE 8833
8831: GO 8844
8833: POP
// x := 2 ; end ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_INT 2
8841: ST_TO_ADDR
8842: GO 8845
8844: POP
// repeat wait ( 0 0$1 ) ;
8845: LD_INT 35
8847: PPUSH
8848: CALL_OW 67
// until not HasTask ( Gali ) ;
8852: LD_EXP 30
8856: PPUSH
8857: CALL_OW 314
8861: NOT
8862: IFFALSE 8845
// time := 0 0$00 ;
8864: LD_ADDR_VAR 0 5
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// time := time + 0 0$1 ;
8879: LD_ADDR_VAR 0 5
8883: PUSH
8884: LD_VAR 0 5
8888: PUSH
8889: LD_INT 35
8891: PLUS
8892: ST_TO_ADDR
// if debug then
8893: LD_EXP 2
8897: IFFALSE 8916
// debug_strings := [ time: & time ] ;
8899: LD_ADDR_OWVAR 48
8903: PUSH
8904: LD_STRING time:
8906: PUSH
8907: LD_VAR 0 5
8911: STR
8912: PUSH
8913: EMPTY
8914: LIST
8915: ST_TO_ADDR
// if time > 8 8$00 then
8916: LD_VAR 0 5
8920: PUSH
8921: LD_INT 16800
8923: GREATER
8924: IFFALSE 8936
// begin blocked := true ;
8926: LD_ADDR_EXP 18
8930: PUSH
8931: LD_INT 1
8933: ST_TO_ADDR
// exit ;
8934: GO 10083
// end ; if not Carry ( Gali ) then
8936: LD_EXP 30
8940: PPUSH
8941: CALL_OW 281
8945: NOT
8946: IFFALSE 8969
// ComTransport ( Gali , dep , player_want_info ) else
8948: LD_EXP 30
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: LD_EXP 13
8962: PPUSH
8963: CALL_OW 151
8967: GO 9087
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8969: LD_EXP 30
8973: PPUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: CALL_OW 296
8987: PUSH
8988: LD_INT 4
8990: LESS
8991: PUSH
8992: LD_EXP 30
8996: PPUSH
8997: LD_EXP 13
9001: PPUSH
9002: CALL_OW 289
9006: AND
9007: IFFALSE 9069
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_EXP 13
9022: PPUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ARRAY
9031: PPUSH
9032: LD_EXP 13
9036: PPUSH
9037: CALL_OW 289
9041: PUSH
9042: LD_INT 10
9044: PLUS
9045: PPUSH
9046: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
9050: LD_EXP 30
9054: PPUSH
9055: LD_EXP 13
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 290
// end else
9067: GO 9087
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
9069: LD_EXP 30
9073: PPUSH
9074: LD_VAR 0 3
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: CALL_OW 112
// end ; if player_attacked_ar then
9087: LD_EXP 16
9091: IFFALSE 9095
// exit ;
9093: GO 10083
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: PPUSH
9104: LD_EXP 13
9108: PPUSH
9109: CALL_OW 289
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 10
9121: MUL
9122: GREATEREQUAL
9123: IFFALSE 8872
// no_oil_gain := false ;
9125: LD_ADDR_VAR 0 6
9129: PUSH
9130: LD_INT 0
9132: ST_TO_ADDR
// end else
9133: GO 9724
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
9135: LD_ADDR_VAR 0 3
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 21
9152: PUSH
9153: LD_INT 2
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9169: LD_EXP 30
9173: PPUSH
9174: LD_VAR 0 4
9178: PPUSH
9179: CALL_OW 250
9183: PUSH
9184: LD_INT 1
9186: PLUS
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: CALL_OW 251
9197: PUSH
9198: LD_INT 1
9200: PLUS
9201: PPUSH
9202: CALL_OW 111
// time := 0 0$00 ;
9206: LD_ADDR_VAR 0 5
9210: PUSH
9211: LD_INT 0
9213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// time := time + 0 0$1 ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: LD_VAR 0 5
9230: PUSH
9231: LD_INT 35
9233: PLUS
9234: ST_TO_ADDR
// if time > 1 1$45 then
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 3675
9242: GREATER
9243: IFFALSE 9247
// break ;
9245: GO 9267
// until GetDistUnits ( Gali , dep ) < 4 ;
9247: LD_EXP 30
9251: PPUSH
9252: LD_VAR 0 4
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 4
9264: LESS
9265: IFFALSE 9214
// for i = 1 to 6 do
9267: LD_ADDR_VAR 0 1
9271: PUSH
9272: DOUBLE
9273: LD_INT 1
9275: DEC
9276: ST_TO_ADDR
9277: LD_INT 6
9279: PUSH
9280: FOR_TO
9281: IFFALSE 9485
// begin if player_attacked_ar then
9283: LD_EXP 16
9287: IFFALSE 9293
// exit ;
9289: POP
9290: POP
9291: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9293: LD_VAR 0 4
9297: PPUSH
9298: CALL_OW 274
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 275
9310: PUSH
9311: LD_INT 10
9313: LESS
9314: PUSH
9315: LD_VAR 0 7
9319: NOT
9320: AND
9321: IFFALSE 9384
// begin first_warn := true ;
9323: LD_ADDR_VAR 0 7
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// DialogueOn ;
9331: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9335: LD_EXP 31
9339: PPUSH
9340: LD_STRING D9a-FAr1-1
9342: PPUSH
9343: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9347: LD_EXP 21
9351: PPUSH
9352: LD_STRING D9a-JMM-1
9354: PPUSH
9355: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9359: LD_EXP 29
9363: PPUSH
9364: LD_STRING D9a2-Ar1-1
9366: PPUSH
9367: CALL_OW 88
// DialogueOff ;
9371: CALL_OW 7
// wait ( time ) ;
9375: LD_VAR 0 5
9379: PPUSH
9380: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9384: LD_VAR 0 4
9388: PPUSH
9389: CALL_OW 274
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 275
9401: PUSH
9402: LD_INT 10
9404: LESS
9405: IFFALSE 9431
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9407: LD_EXP 29
9411: PPUSH
9412: LD_STRING D9a3-Ar1-1
9414: PPUSH
9415: CALL_OW 88
// no_oil_gain := true ;
9419: LD_ADDR_VAR 0 6
9423: PUSH
9424: LD_INT 1
9426: ST_TO_ADDR
// break ;
9427: GO 9485
// end else
9429: GO 9483
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9431: LD_EXP 30
9435: PPUSH
9436: LD_VAR 0 4
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9448: LD_EXP 30
9452: PPUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 3
9465: MOD
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: ARRAY
9471: PPUSH
9472: CALL_OW 210
// wait ( 0 0$10 ) ;
9476: LD_INT 350
9478: PPUSH
9479: CALL_OW 67
// end ; end ;
9483: GO 9280
9485: POP
9486: POP
// time := 0 0$00 ;
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 0
9494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9495: LD_INT 35
9497: PPUSH
9498: CALL_OW 67
// if not HasTask ( Gali ) then
9502: LD_EXP 30
9506: PPUSH
9507: CALL_OW 314
9511: NOT
9512: IFFALSE 9528
// time := time + 0 0$1 ;
9514: LD_ADDR_VAR 0 5
9518: PUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_INT 35
9526: PLUS
9527: ST_TO_ADDR
// if time > 1 1$25 then
9528: LD_VAR 0 5
9532: PUSH
9533: LD_INT 2975
9535: GREATER
9536: IFFALSE 9560
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING D9a3-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// no_oil_gain := true ;
9550: LD_ADDR_VAR 0 6
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// break ;
9558: GO 9724
// end ; if player_attacked_ar then
9560: LD_EXP 16
9564: IFFALSE 9568
// exit ;
9566: GO 10083
// for i in tmp do
9568: LD_ADDR_VAR 0 1
9572: PUSH
9573: LD_VAR 0 3
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9610
// if GetFuel ( i ) < 100 then
9581: LD_VAR 0 1
9585: PPUSH
9586: CALL_OW 261
9590: PUSH
9591: LD_INT 100
9593: LESS
9594: IFFALSE 9608
// begin x := i ;
9596: LD_ADDR_VAR 0 2
9600: PUSH
9601: LD_VAR 0 1
9605: ST_TO_ADDR
// break ;
9606: GO 9610
// end ;
9608: GO 9578
9610: POP
9611: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9612: LD_EXP 30
9616: PPUSH
9617: CALL_OW 314
9621: NOT
9622: PUSH
9623: LD_EXP 30
9627: PPUSH
9628: CALL_OW 281
9632: NOT
9633: AND
9634: IFFALSE 9667
// begin ComTransport ( Gali , dep , mat_oil ) ;
9636: LD_EXP 30
9640: PPUSH
9641: LD_VAR 0 4
9645: PPUSH
9646: LD_INT 2
9648: PPUSH
9649: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9653: LD_EXP 30
9657: PPUSH
9658: LD_VAR 0 2
9662: PPUSH
9663: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9667: LD_VAR 0 3
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: CALL_OW 261
9680: PUSH
9681: LD_INT 80
9683: GREATER
9684: PUSH
9685: LD_VAR 0 3
9689: PUSH
9690: LD_INT 2
9692: ARRAY
9693: PPUSH
9694: CALL_OW 261
9698: PUSH
9699: LD_INT 80
9701: GREATER
9702: AND
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_INT 3
9711: ARRAY
9712: PPUSH
9713: CALL_OW 261
9717: PUSH
9718: LD_INT 80
9720: GREATER
9721: AND
9722: IFFALSE 9495
// end ; ComHold ( Gali ) ;
9724: LD_EXP 30
9728: PPUSH
9729: CALL_OW 140
// if not no_oil_gain then
9733: LD_VAR 0 6
9737: NOT
9738: IFFALSE 9903
// begin DialogueOn ;
9740: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9744: LD_EXP 29
9748: PPUSH
9749: CALL_OW 87
// if player_want_mortar then
9753: LD_EXP 12
9757: IFFALSE 9783
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9759: LD_EXP 29
9763: PPUSH
9764: LD_STRING D9e-Ar1-1
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9771: LD_EXP 21
9775: PPUSH
9776: LD_STRING D10a-JMM-1
9778: PPUSH
9779: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9783: LD_EXP 29
9787: PPUSH
9788: LD_STRING D10a-Ar1-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9795: LD_EXP 30
9799: PPUSH
9800: LD_STRING D10a-Ar2-1
9802: PPUSH
9803: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9807: LD_EXP 31
9811: PPUSH
9812: LD_STRING D10a-FAr1-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9819: LD_EXP 30
9823: PPUSH
9824: LD_STRING D10a-Ar2-2
9826: PPUSH
9827: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9831: LD_EXP 31
9835: PPUSH
9836: LD_STRING D10a-FAr1-2
9838: PPUSH
9839: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9843: LD_EXP 29
9847: PPUSH
9848: LD_STRING D10a-Ar1-2
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9855: LD_EXP 21
9859: PPUSH
9860: LD_STRING D10a-JMM-2
9862: PPUSH
9863: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9867: LD_EXP 29
9871: PPUSH
9872: LD_STRING D10a-Ar1-3
9874: PPUSH
9875: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9879: LD_EXP 21
9883: PPUSH
9884: LD_STRING D10a-JMM-3
9886: PPUSH
9887: CALL_OW 88
// player_get_info := true ;
9891: LD_ADDR_EXP 15
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// DialogueOff ;
9899: CALL_OW 7
// end ; end ; if player_attacked_ar then
9903: LD_EXP 16
9907: IFFALSE 9911
// exit ;
9909: GO 10083
// if player_want_mortar or player_want_info then
9911: LD_EXP 12
9915: PUSH
9916: LD_EXP 13
9920: OR
9921: IFFALSE 9935
// Say ( Vervecken , D9f-Ar1-1 ) ;
9923: LD_EXP 29
9927: PPUSH
9928: LD_STRING D9f-Ar1-1
9930: PPUSH
9931: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9935: LD_INT 22
9937: PUSH
9938: LD_INT 2
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: PPUSH
9950: LD_INT 51
9952: PPUSH
9953: LD_INT 99
9955: PPUSH
9956: CALL_OW 111
// wait ( 0 0$1 ) ;
9960: LD_INT 35
9962: PPUSH
9963: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9967: LD_INT 22
9969: PUSH
9970: LD_INT 2
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 92
9979: PUSH
9980: LD_INT 51
9982: PUSH
9983: LD_INT 99
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IFFALSE 10063
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 2
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 92
10022: PUSH
10023: LD_INT 51
10025: PUSH
10026: LD_INT 99
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 69
10046: PUSH
10047: FOR_IN
10048: IFFALSE 10061
// RemoveUnit ( i ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: CALL_OW 64
10059: GO 10047
10061: POP
10062: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: PUSH
10078: LD_INT 0
10080: EQUAL
10081: IFFALSE 9935
// end ;
10083: PPOPN 10
10085: END
// every 0 0$01 trigger blocked do var i ;
10086: LD_EXP 18
10090: IFFALSE 10258
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
10098: LD_EXP 29
10102: PPUSH
10103: LD_STRING D9f-Ar1-1
10105: PPUSH
10106: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10110: LD_INT 22
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_INT 51
10127: PPUSH
10128: LD_INT 99
10130: PPUSH
10131: CALL_OW 111
// wait ( 0 0$1 ) ;
10135: LD_INT 35
10137: PPUSH
10138: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10142: LD_INT 22
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 92
10154: PUSH
10155: LD_INT 51
10157: PUSH
10158: LD_INT 99
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: IFFALSE 10238
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10180: LD_ADDR_VAR 0 1
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 92
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 99
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PPUSH
10217: CALL_OW 69
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// RemoveUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 64
10234: GO 10222
10236: POP
10237: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10238: LD_INT 22
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: IFFALSE 10110
// end ;
10258: PPOPN 1
10260: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10261: LD_EXP 16
10265: IFFALSE 10618
10267: GO 10269
10269: DISABLE
10270: LD_INT 0
10272: PPUSH
10273: PPUSH
10274: PPUSH
10275: PPUSH
// begin ru_can_attack := true ;
10276: LD_ADDR_EXP 8
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// mine_launched := false ;
10284: LD_ADDR_VAR 0 3
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PPUSH
10307: LD_INT 51
10309: PPUSH
10310: LD_INT 99
10312: PPUSH
10313: CALL_OW 111
// if IsOk ( Vervecken ) then
10317: LD_EXP 29
10321: PPUSH
10322: CALL_OW 302
10326: IFFALSE 10340
// Say ( Vervecken , D11a-Ar1-1 ) ;
10328: LD_EXP 29
10332: PPUSH
10333: LD_STRING D11a-Ar1-1
10335: PPUSH
10336: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10340: LD_ADDR_VAR 0 2
10344: PUSH
10345: LD_EXP 36
10349: PPUSH
10350: LD_INT 25
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 72
10364: ST_TO_ADDR
// for i in tmp do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10439
// if MineOfUnit ( i ) then
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 459
10387: IFFALSE 10437
// begin x := MineOfUnit ( i ) ;
10389: LD_ADDR_VAR 0 4
10393: PUSH
10394: LD_VAR 0 1
10398: PPUSH
10399: CALL_OW 459
10403: ST_TO_ADDR
// mine_launched := true ;
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10412: LD_VAR 0 4
10416: PUSH
10417: LD_INT 1
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_INT 2
10428: ARRAY
10429: PPUSH
10430: LD_INT 2
10432: PPUSH
10433: CALL_OW 456
// end ;
10437: GO 10375
10439: POP
10440: POP
// if mine_launched and IsOk ( Vervecken ) then
10441: LD_VAR 0 3
10445: PUSH
10446: LD_EXP 29
10450: PPUSH
10451: CALL_OW 302
10455: AND
10456: IFFALSE 10470
// Say ( Vervecken , D11b-Ar1-1 ) ;
10458: LD_EXP 29
10462: PPUSH
10463: LD_STRING D11b-Ar1-1
10465: PPUSH
10466: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10470: LD_INT 22
10472: PUSH
10473: LD_INT 2
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: PPUSH
10485: LD_INT 51
10487: PPUSH
10488: LD_INT 99
10490: PPUSH
10491: CALL_OW 111
// wait ( 0 0$1 ) ;
10495: LD_INT 35
10497: PPUSH
10498: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10502: LD_INT 22
10504: PUSH
10505: LD_INT 2
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 92
10514: PUSH
10515: LD_INT 51
10517: PUSH
10518: LD_INT 99
10520: PUSH
10521: LD_INT 2
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IFFALSE 10598
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 22
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 92
10557: PUSH
10558: LD_INT 51
10560: PUSH
10561: LD_INT 99
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: PUSH
10582: FOR_IN
10583: IFFALSE 10596
// RemoveUnit ( i ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: CALL_OW 64
10594: GO 10582
10596: POP
10597: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PUSH
10613: LD_INT 0
10615: EQUAL
10616: IFFALSE 10470
// end ;
10618: PPOPN 4
10620: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10621: LD_EXP 10
10625: IFFALSE 10804
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
// begin Wait ( 10 10$00 ) ;
10633: LD_INT 21000
10635: PPUSH
10636: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10640: LD_INT 22
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: IFFALSE 10804
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: PPUSH
10671: LD_INT 51
10673: PPUSH
10674: LD_INT 99
10676: PPUSH
10677: CALL_OW 114
// wait ( 0 0$1 ) ;
10681: LD_INT 35
10683: PPUSH
10684: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10688: LD_INT 22
10690: PUSH
10691: LD_INT 2
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 92
10700: PUSH
10701: LD_INT 51
10703: PUSH
10704: LD_INT 99
10706: PUSH
10707: LD_INT 2
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: IFFALSE 10784
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 92
10743: PUSH
10744: LD_INT 51
10746: PUSH
10747: LD_INT 99
10749: PUSH
10750: LD_INT 2
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10782
// RemoveUnit ( i ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 64
10780: GO 10768
10782: POP
10783: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10784: LD_INT 22
10786: PUSH
10787: LD_INT 2
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: PUSH
10799: LD_INT 0
10801: EQUAL
10802: IFFALSE 10656
// end ; end ;
10804: PPOPN 1
10806: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10807: LD_EXP 4
10811: IFFALSE 11866
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
10819: PPUSH
10820: PPUSH
10821: PPUSH
10822: PPUSH
10823: PPUSH
// begin Wait ( game_time ) ;
10824: LD_EXP 7
10828: PPUSH
10829: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10833: LD_INT 35
10835: PPUSH
10836: CALL_OW 67
// until ( not ru_can_attack ) ;
10840: LD_EXP 8
10844: NOT
10845: IFFALSE 10833
// Wait ( 0 0$35 ) ;
10847: LD_INT 1225
10849: PPUSH
10850: CALL_OW 67
// DialogueOn ;
10854: CALL_OW 6
// InGameOn ;
10858: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10862: LD_EXP 28
10866: PPUSH
10867: LD_STRING D12-Pow-1
10869: PPUSH
10870: CALL_OW 94
// InGameOff ;
10874: CALL_OW 9
// DialogueOff ;
10878: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10882: LD_STRING M4
10884: PPUSH
10885: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10889: LD_INT 5
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 424
// can_end := true ;
10899: LD_ADDR_EXP 17
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10907: LD_INT 35
10909: PPUSH
10910: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10914: CALL 943 0 0
10918: PUSH
10919: LD_INT 20
10921: GREATEREQUAL
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_INT 1
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 21
10935: PUSH
10936: LD_INT 1
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PPUSH
10947: CALL_OW 69
10951: PUSH
10952: LD_INT 5
10954: PPUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 70
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 1
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 55
10996: PUSH
10997: EMPTY
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PLUS
11009: LESSEQUAL
11010: AND
11011: IFFALSE 10907
// if not player_get_info then
11013: LD_EXP 15
11017: NOT
11018: IFFALSE 11029
// player_get_info := - 1 ;
11020: LD_ADDR_EXP 15
11024: PUSH
11025: LD_INT 1
11027: NEG
11028: ST_TO_ADDR
// m1 := player_get_info > 0 ;
11029: LD_ADDR_VAR 0 4
11033: PUSH
11034: LD_EXP 15
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: ST_TO_ADDR
// m2 := false ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// m3 := earlySib ;
11051: LD_ADDR_VAR 0 6
11055: PUSH
11056: LD_EXP 19
11060: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
11061: LD_STRING Information
11063: PPUSH
11064: LD_EXP 15
11068: PPUSH
11069: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
11073: LD_ADDR_VAR 0 2
11077: PUSH
11078: LD_INT 22
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 2
11090: PUSH
11091: LD_INT 25
11093: PUSH
11094: LD_INT 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 25
11103: PUSH
11104: LD_INT 16
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 34
11113: PUSH
11114: LD_INT 12
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PPUSH
11131: CALL_OW 69
11135: ST_TO_ADDR
// sib := GetTerminalCargo ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: CALL 943 0 0
11145: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
11146: LD_ADDR_VAR 0 3
11150: PUSH
11151: LD_VAR 0 3
11155: PUSH
11156: LD_INT 6
11158: PPUSH
11159: LD_INT 3
11161: PPUSH
11162: CALL_OW 287
11166: PLUS
11167: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11168: LD_ADDR_VAR 0 3
11172: PUSH
11173: LD_VAR 0 3
11177: PUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: LD_INT 3
11185: PPUSH
11186: CALL_OW 289
11190: PLUS
11191: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11192: LD_VAR 0 3
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_OWVAR 67
11204: PLUS
11205: PUSH
11206: LD_INT 50
11208: MUL
11209: LESS
11210: IFFALSE 11235
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11212: LD_STRING MuchSiberite
11214: PPUSH
11215: LD_INT 2
11217: NEG
11218: PUSH
11219: LD_OWVAR 67
11223: MUL
11224: PUSH
11225: LD_INT 1
11227: PLUS
11228: PPUSH
11229: CALL_OW 101
11233: GO 11253
// begin AddMedal ( MuchSiberite , 1 ) ;
11235: LD_STRING MuchSiberite
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 101
// m2 := true ;
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 1
11252: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11253: LD_VAR 0 4
11257: PUSH
11258: LD_VAR 0 5
11262: AND
11263: PUSH
11264: LD_VAR 0 6
11268: AND
11269: PUSH
11270: LD_OWVAR 67
11274: PUSH
11275: LD_INT 3
11277: EQUAL
11278: AND
11279: IFFALSE 11291
// SetAchievementEX ( ACH_AMER , 9 ) ;
11281: LD_STRING ACH_AMER
11283: PPUSH
11284: LD_INT 9
11286: PPUSH
11287: CALL_OW 564
// if tick <= 55 55$00 then
11291: LD_OWVAR 1
11295: PUSH
11296: LD_INT 115500
11298: LESSEQUAL
11299: IFFALSE 11308
// SetAchievement ( ACH_ASPEED_9 ) ;
11301: LD_STRING ACH_ASPEED_9
11303: PPUSH
11304: CALL_OW 543
// GiveMedals ( MAIN ) ;
11308: LD_STRING MAIN
11310: PPUSH
11311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PUSH
11325: LD_INT 2
11327: PUSH
11328: LD_INT 25
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 25
11340: PUSH
11341: LD_INT 2
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 25
11350: PUSH
11351: LD_INT 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: LD_INT 25
11360: PUSH
11361: LD_INT 4
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 25
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PPUSH
11395: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11399: LD_ADDR_VAR 0 2
11403: PUSH
11404: LD_INT 22
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 25
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 69
11432: ST_TO_ADDR
// if tmp then
11433: LD_VAR 0 2
11437: IFFALSE 11468
// for i in tmp do
11439: LD_ADDR_VAR 0 1
11443: PUSH
11444: LD_VAR 0 2
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11466
// SetClass ( i , 1 ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 336
11464: GO 11449
11466: POP
11467: POP
// SaveVariable ( sib , 09_sibRes ) ;
11468: LD_VAR 0 3
11472: PPUSH
11473: LD_STRING 09_sibRes
11475: PPUSH
11476: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11480: LD_EXP 15
11484: PPUSH
11485: LD_STRING 09_arInfo
11487: PPUSH
11488: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11492: LD_EXP 21
11496: PPUSH
11497: LD_EXP 1
11501: PUSH
11502: LD_STRING JMM
11504: STR
11505: PPUSH
11506: CALL_OW 38
// if IsLive ( Gary ) then
11510: LD_EXP 22
11514: PPUSH
11515: CALL_OW 300
11519: IFFALSE 11539
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11521: LD_EXP 22
11525: PPUSH
11526: LD_EXP 1
11530: PUSH
11531: LD_STRING Gary
11533: STR
11534: PPUSH
11535: CALL_OW 38
// if IsLive ( Bobby ) then
11539: LD_EXP 23
11543: PPUSH
11544: CALL_OW 300
11548: IFFALSE 11568
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11550: LD_EXP 23
11554: PPUSH
11555: LD_EXP 1
11559: PUSH
11560: LD_STRING Bobby
11562: STR
11563: PPUSH
11564: CALL_OW 38
// if IsLive ( Cyrus ) then
11568: LD_EXP 24
11572: PPUSH
11573: CALL_OW 300
11577: IFFALSE 11597
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11579: LD_EXP 24
11583: PPUSH
11584: LD_EXP 1
11588: PUSH
11589: LD_STRING Cyrus
11591: STR
11592: PPUSH
11593: CALL_OW 38
// if IsLive ( Houten ) then
11597: LD_EXP 25
11601: PPUSH
11602: CALL_OW 300
11606: IFFALSE 11626
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11608: LD_EXP 25
11612: PPUSH
11613: LD_EXP 1
11617: PUSH
11618: LD_STRING Houten
11620: STR
11621: PPUSH
11622: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 25
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 4
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 21
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 23
11714: PUSH
11715: LD_EXP 25
11719: PUSH
11720: LD_EXP 22
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: DIFF
11732: ST_TO_ADDR
// if tmp then
11733: LD_VAR 0 2
11737: IFFALSE 11757
// SaveCharacters ( tmp , mission_prefix & others ) ;
11739: LD_VAR 0 2
11743: PPUSH
11744: LD_EXP 1
11748: PUSH
11749: LD_STRING others
11751: STR
11752: PPUSH
11753: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11757: LD_ADDR_VAR 0 2
11761: PUSH
11762: LD_INT 22
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 12
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: LD_INT 25
11787: PUSH
11788: LD_INT 16
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PPUSH
11804: CALL_OW 69
11808: ST_TO_ADDR
// if tmp then
11809: LD_VAR 0 2
11813: IFFALSE 11833
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11815: LD_VAR 0 2
11819: PPUSH
11820: LD_EXP 1
11824: PUSH
11825: LD_STRING apes
11827: STR
11828: PPUSH
11829: CALL_OW 38
// if IsLive ( Yakotich ) then
11833: LD_EXP 37
11837: PPUSH
11838: CALL_OW 300
11842: IFFALSE 11862
// SaveCharacters ( Yakotich , mission_prefix & Yakotich ) ;
11844: LD_EXP 37
11848: PPUSH
11849: LD_EXP 1
11853: PUSH
11854: LD_STRING Yakotich
11856: STR
11857: PPUSH
11858: CALL_OW 38
// YouWin ;
11862: CALL_OW 103
// end ; end_of_file
11866: PPOPN 6
11868: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11869: LD_VAR 0 1
11873: PPUSH
11874: CALL_OW 266
11878: PUSH
11879: LD_INT 0
11881: EQUAL
11882: PUSH
11883: LD_EXP 3
11887: NOT
11888: AND
11889: IFFALSE 11913
// begin terminal := b ;
11891: LD_ADDR_EXP 3
11895: PUSH
11896: LD_VAR 0 1
11900: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11901: LD_EXP 3
11905: PPUSH
11906: LD_STRING terminal
11908: PPUSH
11909: CALL_OW 500
// end ; end ;
11913: PPOPN 2
11915: END
// on BuildingComplete ( b ) do var i ;
11916: LD_INT 0
11918: PPUSH
// begin if GetSide ( b ) = 3 then
11919: LD_VAR 0 1
11923: PPUSH
11924: CALL_OW 255
11928: PUSH
11929: LD_INT 3
11931: EQUAL
11932: IFFALSE 11972
// for i = 1 to 4 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 4
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11970
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11950: LD_ADDR_EXP 39
11954: PUSH
11955: LD_EXP 39
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 3
11967: ST_TO_ADDR
11968: GO 11947
11970: POP
11971: POP
// end ;
11972: PPOPN 2
11974: END
// on VehicleConstructed ( veh , fac ) do var i ;
11975: LD_INT 0
11977: PPUSH
// begin if GetSide ( veh ) = 3 then
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 255
11987: PUSH
11988: LD_INT 3
11990: EQUAL
11991: IFFALSE 12116
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 264
12002: PUSH
12003: LD_INT 53
12005: PUSH
12006: LD_INT 52
12008: PUSH
12009: LD_INT 51
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: LIST
12016: IN
12017: NOT
12018: IFFALSE 12036
// ru_force := ru_force ^ veh ;
12020: LD_ADDR_EXP 38
12024: PUSH
12025: LD_EXP 38
12029: PUSH
12030: LD_VAR 0 1
12034: ADD
12035: ST_TO_ADDR
// for i = 1 to 4 do
12036: LD_ADDR_VAR 0 3
12040: PUSH
12041: DOUBLE
12042: LD_INT 1
12044: DEC
12045: ST_TO_ADDR
12046: LD_INT 4
12048: PUSH
12049: FOR_TO
12050: IFFALSE 12072
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
12052: LD_ADDR_EXP 40
12056: PUSH
12057: LD_EXP 40
12061: PPUSH
12062: LD_INT 1
12064: PPUSH
12065: CALL_OW 3
12069: ST_TO_ADDR
12070: GO 12049
12072: POP
12073: POP
// if GetWeapon ( veh ) = ru_bulldozer then
12074: LD_VAR 0 1
12078: PPUSH
12079: CALL_OW 264
12083: PUSH
12084: LD_INT 53
12086: EQUAL
12087: IFFALSE 12116
// begin CutTreeInArea ( veh , cutTreeArea ) ;
12089: LD_VAR 0 1
12093: PPUSH
12094: LD_INT 7
12096: PPUSH
12097: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
12101: LD_VAR 0 1
12105: PPUSH
12106: LD_INT 170
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 171
// end ; end ; end ;
12116: PPOPN 3
12118: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
12119: LD_VAR 0 1
12123: PUSH
12124: LD_INT 1
12126: EQUAL
12127: PUSH
12128: LD_VAR 0 2
12132: PUSH
12133: LD_INT 2
12135: EQUAL
12136: AND
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 2
12145: EQUAL
12146: PUSH
12147: LD_VAR 0 2
12151: PUSH
12152: LD_INT 1
12154: EQUAL
12155: AND
12156: OR
12157: IFFALSE 12167
// player_attacked_ar := true ;
12159: LD_ADDR_EXP 16
12163: PUSH
12164: LD_INT 1
12166: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
12167: LD_VAR 0 1
12171: PUSH
12172: LD_INT 1
12174: EQUAL
12175: PUSH
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 4
12183: EQUAL
12184: AND
12185: PUSH
12186: LD_VAR 0 1
12190: PUSH
12191: LD_INT 4
12193: EQUAL
12194: PUSH
12195: LD_VAR 0 2
12199: PUSH
12200: LD_INT 1
12202: EQUAL
12203: AND
12204: OR
12205: IFFALSE 12214
// YouLost ( Traitor ) ;
12207: LD_STRING Traitor
12209: PPUSH
12210: CALL_OW 104
// end ;
12214: PPOPN 2
12216: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12217: LD_VAR 0 1
12221: PUSH
12222: LD_EXP 21
12226: EQUAL
12227: IFFALSE 12236
// YouLost ( JMM ) ;
12229: LD_STRING JMM
12231: PPUSH
12232: CALL_OW 104
// if un = terminal then
12236: LD_VAR 0 1
12240: PUSH
12241: LD_EXP 3
12245: EQUAL
12246: IFFALSE 12255
// YouLost ( Terminal ) ;
12248: LD_STRING Terminal
12250: PPUSH
12251: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 264
12264: PUSH
12265: LD_INT 53
12267: EQUAL
12268: IFFALSE 12284
// bulldozerCounter := bulldozerCounter + 1 ;
12270: LD_ADDR_EXP 20
12274: PUSH
12275: LD_EXP 20
12279: PUSH
12280: LD_INT 1
12282: PLUS
12283: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12284: LD_VAR 0 1
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 3
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 21
12301: PUSH
12302: LD_INT 3
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PPUSH
12313: CALL_OW 69
12317: IN
12318: IFFALSE 12464
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 266
12329: PUSH
12330: LD_INT 33
12332: PUSH
12333: LD_INT 26
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: IN
12340: IFFALSE 12399
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12342: LD_ADDR_EXP 39
12346: PUSH
12347: LD_EXP 39
12351: PUSH
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 266
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 250
12371: PUSH
12372: LD_VAR 0 1
12376: PPUSH
12377: CALL_OW 251
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 254
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: ADD
12398: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12399: LD_VAR 0 1
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_INT 5
12411: EQUAL
12412: IFFALSE 12464
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12414: LD_ADDR_EXP 39
12418: PUSH
12419: LD_EXP 39
12423: PUSH
12424: LD_INT 4
12426: PUSH
12427: LD_VAR 0 1
12431: PPUSH
12432: CALL_OW 250
12436: PUSH
12437: LD_VAR 0 1
12441: PPUSH
12442: CALL_OW 251
12446: PUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: ADD
12463: ST_TO_ADDR
// end ; if un in ru_force then
12464: LD_VAR 0 1
12468: PUSH
12469: LD_EXP 38
12473: IN
12474: IFFALSE 12510
// begin ru_force := ru_force diff un ;
12476: LD_ADDR_EXP 38
12480: PUSH
12481: LD_EXP 38
12485: PUSH
12486: LD_VAR 0 1
12490: DIFF
12491: ST_TO_ADDR
// if ru_force = 0 then
12492: LD_EXP 38
12496: PUSH
12497: LD_INT 0
12499: EQUAL
12500: IFFALSE 12510
// ru_can_attack := false ;
12502: LD_ADDR_EXP 8
12506: PUSH
12507: LD_INT 0
12509: ST_TO_ADDR
// end ; end ;
12510: PPOPN 1
12512: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12513: LD_VAR 0 1
12517: PPUSH
12518: CALL 29156 0 1
// end ; end_of_file
12522: PPOPN 1
12524: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12525: LD_EXP 5
12529: PUSH
12530: LD_EXP 6
12534: AND
12535: IFFALSE 12620
12537: GO 12539
12539: DISABLE
12540: LD_INT 0
12542: PPUSH
// begin enable ;
12543: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12544: LD_ADDR_VAR 0 1
12548: PUSH
12549: LD_INT 60
12551: PUSH
12552: CALL 943 0 0
12556: MINUS
12557: ST_TO_ADDR
// if sib < 0 then
12558: LD_VAR 0 1
12562: PUSH
12563: LD_INT 0
12565: LESS
12566: IFFALSE 12576
// sib := 0 ;
12568: LD_ADDR_VAR 0 1
12572: PUSH
12573: LD_INT 0
12575: ST_TO_ADDR
// if not debug then
12576: LD_EXP 2
12580: NOT
12581: IFFALSE 12606
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12583: LD_ADDR_OWVAR 47
12587: PUSH
12588: LD_STRING #Am09-1
12590: PUSH
12591: LD_VAR 0 1
12595: PUSH
12596: LD_EXP 6
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: LIST
12605: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12606: LD_ADDR_EXP 6
12610: PUSH
12611: LD_EXP 6
12615: PUSH
12616: LD_INT 35
12618: MINUS
12619: ST_TO_ADDR
// end ;
12620: PPOPN 1
12622: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12623: LD_EXP 6
12627: PUSH
12628: LD_INT 0
12630: EQUAL
12631: IFFALSE 12643
12633: GO 12635
12635: DISABLE
// display_strings := [ ] ;
12636: LD_ADDR_OWVAR 47
12640: PUSH
12641: EMPTY
12642: ST_TO_ADDR
12643: END
// every 1 1$35 do var i , tmp ;
12644: GO 12646
12646: DISABLE
12647: LD_INT 0
12649: PPUSH
12650: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: LD_INT 1155
12658: PUSH
12659: LD_INT 1225
12661: PUSH
12662: LD_INT 1435
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: LD_OWVAR 67
12674: ARRAY
12675: ST_TO_ADDR
// i := 0 ;
12676: LD_ADDR_VAR 0 1
12680: PUSH
12681: LD_INT 0
12683: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12684: LD_INT 1
12686: PPUSH
12687: LD_INT 5
12689: PPUSH
12690: CALL_OW 12
12694: PPUSH
12695: LD_INT 75
12697: PPUSH
12698: LD_INT 75
12700: PPUSH
12701: LD_INT 20
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL_OW 56
// wait ( tmp ) ;
12711: LD_VAR 0 2
12715: PPUSH
12716: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12720: LD_ADDR_VAR 0 2
12724: PUSH
12725: LD_VAR 0 2
12729: PUSH
12730: LD_INT 105
12732: PPUSH
12733: LD_INT 315
12735: PPUSH
12736: CALL_OW 12
12740: PLUS
12741: ST_TO_ADDR
// i := i + 1 ;
12742: LD_ADDR_VAR 0 1
12746: PUSH
12747: LD_VAR 0 1
12751: PUSH
12752: LD_INT 1
12754: PLUS
12755: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12756: LD_VAR 0 1
12760: PUSH
12761: LD_INT 3
12763: MOD
12764: PUSH
12765: LD_INT 0
12767: EQUAL
12768: PUSH
12769: LD_EXP 4
12773: AND
12774: IFFALSE 12812
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12776: LD_INT 2
12778: PPUSH
12779: LD_INT 5
12781: PPUSH
12782: CALL_OW 12
12786: PPUSH
12787: LD_INT 8
12789: PPUSH
12790: LD_INT 1
12792: PPUSH
12793: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12797: LD_INT 665
12799: PPUSH
12800: LD_INT 735
12802: PPUSH
12803: CALL_OW 12
12807: PPUSH
12808: CALL_OW 67
// end ; until tick > game_time ;
12812: LD_OWVAR 1
12816: PUSH
12817: LD_EXP 7
12821: GREATER
12822: IFFALSE 12684
// end ; end_of_file
12824: PPOPN 2
12826: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12827: LD_INT 0
12829: PPUSH
12830: PPUSH
12831: PPUSH
12832: PPUSH
12833: PPUSH
12834: PPUSH
// x := 76 ;
12835: LD_ADDR_VAR 0 5
12839: PUSH
12840: LD_INT 76
12842: ST_TO_ADDR
// y := 147 ;
12843: LD_ADDR_VAR 0 6
12847: PUSH
12848: LD_INT 147
12850: ST_TO_ADDR
// uc_side := 2 ;
12851: LD_ADDR_OWVAR 20
12855: PUSH
12856: LD_INT 2
12858: ST_TO_ADDR
// uc_nation := 2 ;
12859: LD_ADDR_OWVAR 21
12863: PUSH
12864: LD_INT 2
12866: ST_TO_ADDR
// InitHc ;
12867: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 6
12879: PPUSH
12880: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12884: LD_ADDR_OWVAR 26
12888: PUSH
12889: LD_STRING Nicolas Vervecken
12891: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12892: LD_ADDR_OWVAR 33
12896: PUSH
12897: LD_STRING SecondCharsGal
12899: ST_TO_ADDR
// hc_face_number := 3 ;
12900: LD_ADDR_OWVAR 34
12904: PUSH
12905: LD_INT 3
12907: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12908: LD_ADDR_OWVAR 29
12912: PUSH
12913: LD_INT 11
12915: PUSH
12916: LD_INT 10
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: ST_TO_ADDR
// Vervecken := CreateHuman ;
12923: LD_ADDR_EXP 29
12927: PUSH
12928: CALL_OW 44
12932: ST_TO_ADDR
// ar_force := Vervecken ;
12933: LD_ADDR_EXP 36
12937: PUSH
12938: LD_EXP 29
12942: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 2
12948: PPUSH
12949: LD_INT 6
12951: PPUSH
12952: CALL_OW 380
// hc_name := Louis Gali ;
12956: LD_ADDR_OWVAR 26
12960: PUSH
12961: LD_STRING Louis Gali
12963: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12964: LD_ADDR_OWVAR 33
12968: PUSH
12969: LD_STRING SecondCharsGal
12971: ST_TO_ADDR
// hc_face_number := 2 ;
12972: LD_ADDR_OWVAR 34
12976: PUSH
12977: LD_INT 2
12979: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12980: LD_ADDR_OWVAR 29
12984: PUSH
12985: LD_INT 10
12987: PUSH
12988: LD_INT 11
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// Gali := CreateHuman ;
12995: LD_ADDR_EXP 30
12999: PUSH
13000: CALL_OW 44
13004: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
13005: LD_ADDR_EXP 36
13009: PUSH
13010: LD_EXP 36
13014: PUSH
13015: LD_EXP 30
13019: ADD
13020: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
13021: LD_INT 2
13023: PPUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_INT 6
13029: PPUSH
13030: CALL_OW 380
// hc_name := Maria Bogdanovic ;
13034: LD_ADDR_OWVAR 26
13038: PUSH
13039: LD_STRING Maria Bogdanovic
13041: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13042: LD_ADDR_OWVAR 33
13046: PUSH
13047: LD_STRING SecondCharsGal
13049: ST_TO_ADDR
// hc_face_number := 14 ;
13050: LD_ADDR_OWVAR 34
13054: PUSH
13055: LD_INT 14
13057: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
13058: LD_ADDR_OWVAR 29
13062: PUSH
13063: LD_INT 12
13065: PUSH
13066: LD_INT 9
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
13073: LD_ADDR_EXP 31
13077: PUSH
13078: CALL_OW 44
13082: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
13083: LD_ADDR_EXP 36
13087: PUSH
13088: LD_EXP 36
13092: PUSH
13093: LD_EXP 31
13097: ADD
13098: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13099: LD_INT 1
13101: PPUSH
13102: LD_INT 3
13104: PPUSH
13105: LD_INT 6
13107: PPUSH
13108: CALL_OW 380
// hc_name = Kntor Radomr ;
13112: LD_ADDR_OWVAR 26
13116: PUSH
13117: LD_STRING Kntor Radomr
13119: ST_TO_ADDR
// hc_gallery = sandar ;
13120: LD_ADDR_OWVAR 33
13124: PUSH
13125: LD_STRING sandar
13127: ST_TO_ADDR
// hc_face_number = 12 ;
13128: LD_ADDR_OWVAR 34
13132: PUSH
13133: LD_INT 12
13135: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
13136: LD_ADDR_OWVAR 29
13140: PUSH
13141: LD_INT 9
13143: PUSH
13144: LD_INT 9
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: ST_TO_ADDR
// Kantor = CreateHuman ;
13151: LD_ADDR_EXP 32
13155: PUSH
13156: CALL_OW 44
13160: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
13161: LD_ADDR_EXP 36
13165: PUSH
13166: LD_EXP 36
13170: PUSH
13171: LD_EXP 32
13175: ADD
13176: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 3
13182: PPUSH
13183: LD_INT 6
13185: PPUSH
13186: CALL_OW 380
// hc_name = Herczeg Farkas ;
13190: LD_ADDR_OWVAR 26
13194: PUSH
13195: LD_STRING Herczeg Farkas
13197: ST_TO_ADDR
// hc_gallery = sandar ;
13198: LD_ADDR_OWVAR 33
13202: PUSH
13203: LD_STRING sandar
13205: ST_TO_ADDR
// hc_face_number = 28 ;
13206: LD_ADDR_OWVAR 34
13210: PUSH
13211: LD_INT 28
13213: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13214: LD_ADDR_OWVAR 29
13218: PUSH
13219: LD_INT 10
13221: PUSH
13222: LD_INT 9
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: ST_TO_ADDR
// Herczeg = CreateHuman ;
13229: LD_ADDR_EXP 33
13233: PUSH
13234: CALL_OW 44
13238: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13239: LD_ADDR_EXP 36
13243: PUSH
13244: LD_EXP 36
13248: PUSH
13249: LD_EXP 33
13253: ADD
13254: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13255: LD_INT 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: LD_INT 6
13263: PPUSH
13264: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13268: LD_ADDR_OWVAR 26
13272: PUSH
13273: LD_STRING Ronn Horntvedt
13275: ST_TO_ADDR
// hc_gallery = sandar ;
13276: LD_ADDR_OWVAR 33
13280: PUSH
13281: LD_STRING sandar
13283: ST_TO_ADDR
// hc_face_number = 29 ;
13284: LD_ADDR_OWVAR 34
13288: PUSH
13289: LD_INT 29
13291: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13292: LD_ADDR_OWVAR 29
13296: PUSH
13297: LD_INT 11
13299: PUSH
13300: LD_INT 11
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: ST_TO_ADDR
// Ronn = CreateHuman ;
13307: LD_ADDR_EXP 34
13311: PUSH
13312: CALL_OW 44
13316: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13317: LD_ADDR_EXP 36
13321: PUSH
13322: LD_EXP 36
13326: PUSH
13327: LD_EXP 34
13331: ADD
13332: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13333: LD_INT 2
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 6
13341: PPUSH
13342: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13346: LD_ADDR_OWVAR 26
13350: PUSH
13351: LD_STRING Mia D. Mathiasen
13353: ST_TO_ADDR
// hc_gallery = sandar ;
13354: LD_ADDR_OWVAR 33
13358: PUSH
13359: LD_STRING sandar
13361: ST_TO_ADDR
// hc_face_number = 31 ;
13362: LD_ADDR_OWVAR 34
13366: PUSH
13367: LD_INT 31
13369: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13370: LD_ADDR_OWVAR 29
13374: PUSH
13375: LD_INT 10
13377: PUSH
13378: LD_INT 10
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: ST_TO_ADDR
// Mia = CreateHuman ;
13385: LD_ADDR_EXP 35
13389: PUSH
13390: CALL_OW 44
13394: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13395: LD_ADDR_EXP 36
13399: PUSH
13400: LD_EXP 36
13404: PUSH
13405: LD_EXP 35
13409: ADD
13410: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13411: LD_ADDR_VAR 0 3
13415: PUSH
13416: LD_VAR 0 3
13420: PUSH
13421: LD_INT 2
13423: PPUSH
13424: LD_INT 2
13426: PPUSH
13427: LD_INT 14
13429: PPUSH
13430: LD_INT 1
13432: PPUSH
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 32
13438: PPUSH
13439: LD_INT 30
13441: PPUSH
13442: CALL 423 0 7
13446: ADD
13447: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_INT 2
13460: PPUSH
13461: LD_INT 2
13463: PPUSH
13464: LD_INT 14
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: LD_INT 1
13472: PPUSH
13473: LD_INT 27
13475: PPUSH
13476: LD_INT 30
13478: PPUSH
13479: CALL 423 0 7
13483: ADD
13484: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_VAR 0 3
13494: PUSH
13495: LD_INT 2
13497: PPUSH
13498: LD_INT 2
13500: PPUSH
13501: LD_INT 14
13503: PPUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_INT 25
13512: PPUSH
13513: LD_INT 33
13515: PPUSH
13516: CALL 423 0 7
13520: ADD
13521: ST_TO_ADDR
// tmp := tmp diff 0 ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_INT 0
13534: DIFF
13535: ST_TO_ADDR
// for i in ar_force do
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_EXP 36
13545: PUSH
13546: FOR_IN
13547: IFFALSE 13690
// begin if GetClass ( i ) = 3 then
13549: LD_VAR 0 4
13553: PPUSH
13554: CALL_OW 257
13558: PUSH
13559: LD_INT 3
13561: EQUAL
13562: IFFALSE 13644
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13564: LD_VAR 0 3
13568: PUSH
13569: LD_INT 1
13571: ARRAY
13572: PPUSH
13573: LD_INT 1
13575: PPUSH
13576: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: PPUSH
13589: LD_VAR 0 5
13593: PPUSH
13594: LD_VAR 0 6
13598: PPUSH
13599: LD_INT 0
13601: PPUSH
13602: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13606: LD_VAR 0 4
13610: PPUSH
13611: LD_VAR 0 3
13615: PUSH
13616: LD_INT 1
13618: ARRAY
13619: PPUSH
13620: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13624: LD_ADDR_VAR 0 3
13628: PUSH
13629: LD_VAR 0 3
13633: PPUSH
13634: LD_INT 1
13636: PPUSH
13637: CALL_OW 3
13641: ST_TO_ADDR
// end else
13642: GO 13666
// PlaceUnitXY ( i , x , y , false ) ;
13644: LD_VAR 0 4
13648: PPUSH
13649: LD_VAR 0 5
13653: PPUSH
13654: LD_VAR 0 6
13658: PPUSH
13659: LD_INT 0
13661: PPUSH
13662: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13666: LD_VAR 0 4
13670: PPUSH
13671: LD_INT 86
13673: PPUSH
13674: LD_INT 121
13676: PPUSH
13677: CALL_OW 111
// wait ( 0 0$2 ) ;
13681: LD_INT 70
13683: PPUSH
13684: CALL_OW 67
// end ;
13688: GO 13546
13690: POP
13691: POP
// ar_force := ar_force ^ tmp ;
13692: LD_ADDR_EXP 36
13696: PUSH
13697: LD_EXP 36
13701: PUSH
13702: LD_VAR 0 3
13706: ADD
13707: ST_TO_ADDR
// ar_spawned := true ;
13708: LD_ADDR_EXP 11
13712: PUSH
13713: LD_INT 1
13715: ST_TO_ADDR
// end ; end_of_file
13716: LD_VAR 0 1
13720: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13721: LD_INT 0
13723: PPUSH
13724: PPUSH
13725: PPUSH
13726: PPUSH
13727: PPUSH
13728: PPUSH
13729: PPUSH
// InitHc ;
13730: CALL_OW 19
// uc_side := 3 ;
13734: LD_ADDR_OWVAR 20
13738: PUSH
13739: LD_INT 3
13741: ST_TO_ADDR
// uc_nation := 3 ;
13742: LD_ADDR_OWVAR 21
13746: PUSH
13747: LD_INT 3
13749: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13750: LD_ADDR_VAR 0 5
13754: PUSH
13755: LD_INT 5
13757: PUSH
13758: LD_INT 6
13760: PUSH
13761: LD_INT 7
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: ST_TO_ADDR
// ru_force := [ ] ;
13775: LD_ADDR_EXP 38
13779: PUSH
13780: EMPTY
13781: ST_TO_ADDR
// ru_rebuild := [ ] ;
13782: LD_ADDR_EXP 39
13786: PUSH
13787: EMPTY
13788: ST_TO_ADDR
// ru_produce_list := [ ] ;
13789: LD_ADDR_EXP 40
13793: PUSH
13794: EMPTY
13795: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13796: LD_ADDR_VAR 0 6
13800: PUSH
13801: LD_INT 22
13803: PUSH
13804: LD_INT 3
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: PUSH
13811: LD_INT 30
13813: PUSH
13814: LD_INT 8
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PPUSH
13825: CALL_OW 69
13829: PUSH
13830: LD_INT 1
13832: ARRAY
13833: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13834: LD_ADDR_VAR 0 4
13838: PUSH
13839: LD_INT 43
13841: PUSH
13842: LD_INT 46
13844: PUSH
13845: LD_INT 45
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13853: LD_ADDR_VAR 0 7
13857: PUSH
13858: LD_INT 22
13860: PUSH
13861: LD_INT 3
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: LD_INT 30
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 69
13886: PUSH
13887: LD_INT 1
13889: ARRAY
13890: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13891: LD_VAR 0 7
13895: PPUSH
13896: CALL_OW 274
13900: PPUSH
13901: LD_INT 1
13903: PPUSH
13904: LD_INT 5000
13906: PPUSH
13907: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13911: LD_VAR 0 7
13915: PPUSH
13916: CALL_OW 274
13920: PPUSH
13921: LD_INT 2
13923: PPUSH
13924: LD_INT 1000
13926: PPUSH
13927: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13931: LD_VAR 0 7
13935: PPUSH
13936: CALL_OW 274
13940: PPUSH
13941: LD_INT 3
13943: PPUSH
13944: LD_INT 30
13946: PPUSH
13947: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 3
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: PUSH
13985: FOR_IN
13986: IFFALSE 14019
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
13988: LD_VAR 0 2
13992: PPUSH
13993: LD_INT 5
13995: PUSH
13996: LD_INT 6
13998: PUSH
13999: LD_INT 7
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: LIST
14006: PUSH
14007: LD_OWVAR 67
14011: ARRAY
14012: PPUSH
14013: CALL_OW 241
14017: GO 13985
14019: POP
14020: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 22
14028: PUSH
14029: LD_INT 3
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 30
14038: PUSH
14039: LD_INT 33
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: CALL_OW 69
14054: PUSH
14055: FOR_IN
14056: IFFALSE 14088
// PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
14058: LD_VAR 0 2
14062: PPUSH
14063: LD_VAR 0 4
14067: PUSH
14068: LD_VAR 0 2
14072: PUSH
14073: LD_INT 3
14075: MOD
14076: PUSH
14077: LD_INT 1
14079: PLUS
14080: ARRAY
14081: PPUSH
14082: CALL_OW 431
14086: GO 14055
14088: POP
14089: POP
// for i = 1 to 4 do
14090: LD_ADDR_VAR 0 2
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 4
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14165
// begin PrepareHuman ( false , class_bazooker , skill ) ;
14106: LD_INT 0
14108: PPUSH
14109: LD_INT 9
14111: PPUSH
14112: LD_VAR 0 5
14116: PPUSH
14117: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
14121: CALL_OW 44
14125: PPUSH
14126: LD_INT 22
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 30
14138: PUSH
14139: LD_INT 5
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PPUSH
14150: CALL_OW 69
14154: PUSH
14155: LD_INT 1
14157: ARRAY
14158: PPUSH
14159: CALL_OW 52
// end ;
14163: GO 14103
14165: POP
14166: POP
// for i = 1 to 5 do
14167: LD_ADDR_VAR 0 2
14171: PUSH
14172: DOUBLE
14173: LD_INT 1
14175: DEC
14176: ST_TO_ADDR
14177: LD_INT 5
14179: PUSH
14180: FOR_TO
14181: IFFALSE 14242
// begin PrepareHuman ( false , class_mechanic , skill ) ;
14183: LD_INT 0
14185: PPUSH
14186: LD_INT 3
14188: PPUSH
14189: LD_VAR 0 5
14193: PPUSH
14194: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
14198: CALL_OW 44
14202: PPUSH
14203: LD_INT 22
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 3
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 69
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: PPUSH
14236: CALL_OW 52
// end ;
14240: GO 14180
14242: POP
14243: POP
// for i = 1 to 4 do
14244: LD_ADDR_VAR 0 2
14248: PUSH
14249: DOUBLE
14250: LD_INT 1
14252: DEC
14253: ST_TO_ADDR
14254: LD_INT 4
14256: PUSH
14257: FOR_TO
14258: IFFALSE 14319
// begin PrepareHuman ( false , class_engineer , skill ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 2
14265: PPUSH
14266: LD_VAR 0 5
14270: PPUSH
14271: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_INT 22
14282: PUSH
14283: LD_INT 3
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: PUSH
14290: LD_INT 30
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: PPUSH
14304: CALL_OW 69
14308: PUSH
14309: LD_INT 1
14311: ARRAY
14312: PPUSH
14313: CALL_OW 52
// end ;
14317: GO 14257
14319: POP
14320: POP
// for i = 1 to 3 do
14321: LD_ADDR_VAR 0 2
14325: PUSH
14326: DOUBLE
14327: LD_INT 1
14329: DEC
14330: ST_TO_ADDR
14331: LD_INT 3
14333: PUSH
14334: FOR_TO
14335: IFFALSE 14368
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 4
14342: PPUSH
14343: LD_VAR 0 5
14347: PPUSH
14348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14352: CALL_OW 44
14356: PPUSH
14357: LD_VAR 0 6
14361: PPUSH
14362: CALL_OW 52
// end ;
14366: GO 14334
14368: POP
14369: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14370: LD_ADDR_EXP 37
14374: PUSH
14375: LD_STRING Yakotich
14377: PPUSH
14378: LD_EXP 2
14382: NOT
14383: PPUSH
14384: LD_STRING 
14386: PPUSH
14387: CALL 360 0 3
14391: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14392: LD_EXP 37
14396: PPUSH
14397: LD_INT 74
14399: PPUSH
14400: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14404: LD_VAR 0 6
14408: PPUSH
14409: LD_INT 49
14411: PPUSH
14412: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14416: LD_VAR 0 6
14420: PPUSH
14421: LD_INT 50
14423: PPUSH
14424: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14428: LD_VAR 0 6
14432: PPUSH
14433: LD_INT 51
14435: PPUSH
14436: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14440: LD_VAR 0 6
14444: PPUSH
14445: LD_INT 52
14447: PPUSH
14448: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14452: LD_VAR 0 6
14456: PPUSH
14457: LD_INT 69
14459: PPUSH
14460: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14464: LD_VAR 0 6
14468: PPUSH
14469: LD_INT 39
14471: PPUSH
14472: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14476: LD_VAR 0 6
14480: PPUSH
14481: LD_INT 34
14483: PPUSH
14484: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14488: LD_VAR 0 6
14492: PPUSH
14493: LD_INT 40
14495: PPUSH
14496: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14500: LD_VAR 0 6
14504: PPUSH
14505: LD_INT 57
14507: PPUSH
14508: CALL_OW 184
// if Difficulty > 1 then
14512: LD_OWVAR 67
14516: PUSH
14517: LD_INT 1
14519: GREATER
14520: IFFALSE 14534
// AddComResearch ( lab , tech_comp2 ) ;
14522: LD_VAR 0 6
14526: PPUSH
14527: LD_INT 58
14529: PPUSH
14530: CALL_OW 184
// end ;
14534: LD_VAR 0 1
14538: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14539: LD_INT 7
14541: PPUSH
14542: CALL_OW 353
14546: PUSH
14547: LD_INT 3
14549: GREATER
14550: PUSH
14551: LD_INT 22
14553: PUSH
14554: LD_INT 3
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PUSH
14561: LD_INT 34
14563: PUSH
14564: LD_INT 53
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: PPUSH
14575: CALL_OW 69
14579: NOT
14580: AND
14581: IFFALSE 14616
14583: GO 14585
14585: DISABLE
// begin enable ;
14586: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14587: LD_ADDR_EXP 40
14591: PUSH
14592: LD_EXP 40
14596: PUSH
14597: LD_INT 24
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 3
14605: PUSH
14606: LD_INT 53
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ADD
14615: ST_TO_ADDR
// end ;
14616: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14617: LD_INT 22
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 3
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: IFFALSE 15423
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
14658: PPUSH
14659: PPUSH
// begin enable ;
14660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14661: LD_ADDR_VAR 0 3
14665: PUSH
14666: LD_INT 22
14668: PUSH
14669: LD_INT 3
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 21
14678: PUSH
14679: LD_INT 3
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 3
14688: PUSH
14689: LD_INT 24
14691: PUSH
14692: LD_INT 1000
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14713: LD_ADDR_VAR 0 4
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: LD_INT 25
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PPUSH
14742: CALL_OW 69
14746: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14747: LD_ADDR_VAR 0 5
14751: PUSH
14752: LD_INT 22
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 30
14764: PUSH
14765: LD_INT 1
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PPUSH
14776: CALL_OW 69
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14785: LD_ADDR_VAR 0 8
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 3
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 6
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 30
14815: PUSH
14816: LD_INT 7
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 30
14825: PUSH
14826: LD_INT 8
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 1
14850: ARRAY
14851: ST_TO_ADDR
// if not engs then
14852: LD_VAR 0 4
14856: NOT
14857: IFFALSE 14861
// exit ;
14859: GO 15423
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14861: LD_ADDR_VAR 0 6
14865: PUSH
14866: LD_VAR 0 4
14870: PPUSH
14871: LD_INT 3
14873: PUSH
14874: LD_INT 24
14876: PUSH
14877: LD_INT 600
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 72
14892: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14893: LD_ADDR_VAR 0 7
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 3
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 4
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14927: LD_VAR 0 3
14931: NOT
14932: PUSH
14933: LD_EXP 39
14937: NOT
14938: AND
14939: IFFALSE 14999
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14941: LD_VAR 0 4
14945: PPUSH
14946: LD_INT 3
14948: PUSH
14949: LD_INT 54
14951: PUSH
14952: EMPTY
14953: LIST
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PPUSH
14959: CALL_OW 72
14963: IFFALSE 14997
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14965: LD_VAR 0 4
14969: PPUSH
14970: LD_INT 3
14972: PUSH
14973: LD_INT 54
14975: PUSH
14976: EMPTY
14977: LIST
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: CALL_OW 72
14987: PPUSH
14988: LD_VAR 0 5
14992: PPUSH
14993: CALL_OW 120
// exit ;
14997: GO 15423
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14999: LD_VAR 0 4
15003: PPUSH
15004: LD_INT 54
15006: PUSH
15007: EMPTY
15008: LIST
15009: PPUSH
15010: CALL_OW 72
15014: IFFALSE 15036
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
15016: LD_VAR 0 4
15020: PPUSH
15021: LD_INT 54
15023: PUSH
15024: EMPTY
15025: LIST
15026: PPUSH
15027: CALL_OW 72
15031: PPUSH
15032: CALL_OW 122
// if not tmp then
15036: LD_VAR 0 3
15040: NOT
15041: IFFALSE 15173
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
15043: LD_INT 81
15045: PUSH
15046: LD_INT 3
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 92
15055: PUSH
15056: LD_INT 147
15058: PUSH
15059: LD_INT 212
15061: PUSH
15062: LD_INT 30
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PPUSH
15075: CALL_OW 69
15079: NOT
15080: IFFALSE 15173
// begin if not HasTask ( engs [ 1 ] ) then
15082: LD_VAR 0 4
15086: PUSH
15087: LD_INT 1
15089: ARRAY
15090: PPUSH
15091: CALL_OW 314
15095: NOT
15096: IFFALSE 15173
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
15098: LD_ADDR_VAR 0 2
15102: PUSH
15103: LD_VAR 0 4
15107: PPUSH
15108: LD_EXP 39
15112: PUSH
15113: LD_INT 1
15115: ARRAY
15116: PPUSH
15117: LD_EXP 39
15121: PUSH
15122: LD_INT 2
15124: ARRAY
15125: PPUSH
15126: LD_EXP 39
15130: PUSH
15131: LD_INT 3
15133: ARRAY
15134: PPUSH
15135: LD_EXP 39
15139: PUSH
15140: LD_INT 4
15142: ARRAY
15143: PPUSH
15144: CALL_OW 145
15148: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
15149: LD_VAR 0 2
15153: PPUSH
15154: CALL_OW 266
15158: PUSH
15159: LD_INT 4
15161: EQUAL
15162: IFFALSE 15173
// AddComUpgrade ( i ) ;
15164: LD_VAR 0 2
15168: PPUSH
15169: CALL_OW 206
// end ; end ; end ; for i in engs do
15173: LD_ADDR_VAR 0 2
15177: PUSH
15178: LD_VAR 0 4
15182: PUSH
15183: FOR_IN
15184: IFFALSE 15302
// begin if i in to_heal and sci then
15186: LD_VAR 0 2
15190: PUSH
15191: LD_VAR 0 6
15195: IN
15196: PUSH
15197: LD_VAR 0 7
15201: AND
15202: IFFALSE 15253
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
15204: LD_VAR 0 2
15208: PPUSH
15209: LD_INT 149
15211: PPUSH
15212: LD_INT 220
15214: PPUSH
15215: CALL_OW 297
15219: PUSH
15220: LD_INT 5
15222: LESS
15223: IFFALSE 15227
// continue ;
15225: GO 15183
// ComMoveXY ( i , 149 , 220 ) ;
15227: LD_VAR 0 2
15231: PPUSH
15232: LD_INT 149
15234: PPUSH
15235: LD_INT 220
15237: PPUSH
15238: CALL_OW 111
// AddComHold ( i ) ;
15242: LD_VAR 0 2
15246: PPUSH
15247: CALL_OW 200
// end else
15251: GO 15300
// if not HasTask ( i ) or WantsToAttack ( i ) then
15253: LD_VAR 0 2
15257: PPUSH
15258: CALL_OW 314
15262: NOT
15263: PUSH
15264: LD_VAR 0 2
15268: PPUSH
15269: CALL_OW 319
15273: OR
15274: IFFALSE 15300
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15276: LD_VAR 0 2
15280: PPUSH
15281: LD_VAR 0 3
15285: PPUSH
15286: LD_VAR 0 2
15290: PPUSH
15291: CALL_OW 74
15295: PPUSH
15296: CALL_OW 130
// end ;
15300: GO 15183
15302: POP
15303: POP
// if to_heal and sci then
15304: LD_VAR 0 6
15308: PUSH
15309: LD_VAR 0 7
15313: AND
15314: IFFALSE 15375
// begin if UnitFilter ( sci , [ f_inside ] ) then
15316: LD_VAR 0 7
15320: PPUSH
15321: LD_INT 54
15323: PUSH
15324: EMPTY
15325: LIST
15326: PPUSH
15327: CALL_OW 72
15331: IFFALSE 15355
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15333: LD_VAR 0 7
15337: PPUSH
15338: LD_INT 54
15340: PUSH
15341: EMPTY
15342: LIST
15343: PPUSH
15344: CALL_OW 72
15348: PPUSH
15349: CALL_OW 122
15353: GO 15373
// ComHeal ( sci , to_heal [ 1 ] ) ;
15355: LD_VAR 0 7
15359: PPUSH
15360: LD_VAR 0 6
15364: PUSH
15365: LD_INT 1
15367: ARRAY
15368: PPUSH
15369: CALL_OW 128
// end else
15373: GO 15423
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 56
15382: PUSH
15383: EMPTY
15384: LIST
15385: PPUSH
15386: CALL_OW 72
15390: PUSH
15391: LD_VAR 0 8
15395: AND
15396: IFFALSE 15423
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15398: LD_VAR 0 7
15402: PPUSH
15403: LD_INT 56
15405: PUSH
15406: EMPTY
15407: LIST
15408: PPUSH
15409: CALL_OW 72
15413: PPUSH
15414: LD_VAR 0 8
15418: PPUSH
15419: CALL_OW 120
// end ;
15423: PPOPN 8
15425: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15426: LD_INT 22
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PPUSH
15450: CALL_OW 69
15454: PUSH
15455: LD_EXP 40
15459: AND
15460: IFFALSE 15586
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
15468: PPUSH
15469: PPUSH
// begin enable ;
15470: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 22
15478: PUSH
15479: LD_INT 3
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: LD_INT 30
15488: PUSH
15489: LD_INT 3
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PPUSH
15500: CALL_OW 69
15504: PUSH
15505: LD_INT 1
15507: ARRAY
15508: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15509: LD_VAR 0 3
15513: PPUSH
15514: CALL_OW 313
15518: PUSH
15519: LD_INT 0
15521: EQUAL
15522: IFFALSE 15526
// exit ;
15524: GO 15586
// if BuildingStatus ( fac ) = bs_idle then
15526: LD_VAR 0 3
15530: PPUSH
15531: CALL_OW 461
15535: PUSH
15536: LD_INT 2
15538: EQUAL
15539: IFFALSE 15586
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_EXP 40
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_EXP 40
15559: PUSH
15560: LD_INT 2
15562: ARRAY
15563: PPUSH
15564: LD_EXP 40
15568: PUSH
15569: LD_INT 3
15571: ARRAY
15572: PPUSH
15573: LD_EXP 40
15577: PUSH
15578: LD_INT 4
15580: ARRAY
15581: PPUSH
15582: CALL_OW 125
// end ;
15586: PPOPN 3
15588: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15589: LD_INT 0
15591: PPUSH
15592: PPUSH
15593: PPUSH
15594: PPUSH
15595: PPUSH
// uc_side := 3 ;
15596: LD_ADDR_OWVAR 20
15600: PUSH
15601: LD_INT 3
15603: ST_TO_ADDR
// uc_nation := 3 ;
15604: LD_ADDR_OWVAR 21
15608: PUSH
15609: LD_INT 3
15611: ST_TO_ADDR
// ru_can_attack := false ;
15612: LD_ADDR_EXP 8
15616: PUSH
15617: LD_INT 0
15619: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15620: LD_ADDR_VAR 0 6
15624: PUSH
15625: LD_INT 22
15627: PUSH
15628: LD_INT 3
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: LD_INT 30
15637: PUSH
15638: LD_INT 3
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL_OW 69
15653: ST_TO_ADDR
// if fac then
15654: LD_VAR 0 6
15658: IFFALSE 15810
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15660: LD_ADDR_EXP 40
15664: PUSH
15665: LD_INT 24
15667: PUSH
15668: LD_INT 1
15670: PUSH
15671: LD_INT 3
15673: PUSH
15674: LD_INT 43
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: ST_TO_ADDR
// if wave > 1 then
15683: LD_VAR 0 1
15687: PUSH
15688: LD_INT 1
15690: GREATER
15691: IFFALSE 15744
// for i = 1 to Difficulty do
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: DOUBLE
15699: LD_INT 1
15701: DEC
15702: ST_TO_ADDR
15703: LD_OWVAR 67
15707: PUSH
15708: FOR_TO
15709: IFFALSE 15742
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15711: LD_ADDR_EXP 40
15715: PUSH
15716: LD_EXP 40
15720: PUSH
15721: LD_INT 24
15723: PUSH
15724: LD_INT 1
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: LD_INT 45
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: LIST
15737: LIST
15738: ADD
15739: ST_TO_ADDR
15740: GO 15708
15742: POP
15743: POP
// repeat wait ( 0 0$1 ) ;
15744: LD_INT 35
15746: PPUSH
15747: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15751: LD_EXP 40
15755: PUSH
15756: LD_INT 4
15758: LESS
15759: PUSH
15760: LD_VAR 0 6
15764: PUSH
15765: LD_INT 1
15767: ARRAY
15768: PPUSH
15769: CALL_OW 313
15773: PUSH
15774: LD_INT 0
15776: EQUAL
15777: OR
15778: PUSH
15779: LD_VAR 0 6
15783: PUSH
15784: LD_INT 1
15786: ARRAY
15787: PPUSH
15788: CALL_OW 461
15792: PUSH
15793: LD_INT 8
15795: PUSH
15796: LD_INT 6
15798: PUSH
15799: LD_INT 7
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: IN
15807: OR
15808: IFFALSE 15744
// end ; case wave of 1 :
15810: LD_VAR 0 1
15814: PUSH
15815: LD_INT 1
15817: DOUBLE
15818: EQUAL
15819: IFTRUE 15823
15821: GO 15908
15823: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15824: LD_ADDR_VAR 0 3
15828: PUSH
15829: DOUBLE
15830: LD_INT 1
15832: DEC
15833: ST_TO_ADDR
15834: LD_INT 2
15836: PUSH
15837: LD_INT 3
15839: PUSH
15840: LD_INT 4
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: LIST
15847: PUSH
15848: LD_OWVAR 67
15852: ARRAY
15853: PUSH
15854: FOR_TO
15855: IFFALSE 15863
// Sold ;
15857: CALL 16134 0 0
15861: GO 15854
15863: POP
15864: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15865: LD_ADDR_VAR 0 3
15869: PUSH
15870: DOUBLE
15871: LD_INT 1
15873: DEC
15874: ST_TO_ADDR
15875: LD_INT 2
15877: PUSH
15878: LD_INT 3
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: PUSH
15889: LD_OWVAR 67
15893: ARRAY
15894: PUSH
15895: FOR_TO
15896: IFFALSE 15904
// Tank ;
15898: CALL 16264 0 0
15902: GO 15895
15904: POP
15905: POP
// end ; 2 .. 9 :
15906: GO 16121
15908: LD_INT 2
15910: DOUBLE
15911: GREATEREQUAL
15912: IFFALSE 15920
15914: LD_INT 9
15916: DOUBLE
15917: LESSEQUAL
15918: IFTRUE 15922
15920: GO 16027
15922: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15923: LD_ADDR_VAR 0 3
15927: PUSH
15928: DOUBLE
15929: LD_INT 1
15931: DEC
15932: ST_TO_ADDR
15933: LD_INT 2
15935: PUSH
15936: LD_INT 4
15938: PUSH
15939: LD_INT 5
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: PUSH
15947: LD_OWVAR 67
15951: ARRAY
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: LD_INT 2
15960: DIV
15961: PLUS
15962: PUSH
15963: FOR_TO
15964: IFFALSE 15972
// Sold ;
15966: CALL 16134 0 0
15970: GO 15963
15972: POP
15973: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15974: LD_ADDR_VAR 0 3
15978: PUSH
15979: DOUBLE
15980: LD_INT 1
15982: DEC
15983: ST_TO_ADDR
15984: LD_INT 2
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: PUSH
15998: LD_OWVAR 67
16002: ARRAY
16003: PUSH
16004: LD_VAR 0 1
16008: PUSH
16009: LD_INT 2
16011: DIV
16012: PLUS
16013: PUSH
16014: FOR_TO
16015: IFFALSE 16023
// Tank ;
16017: CALL 16264 0 0
16021: GO 16014
16023: POP
16024: POP
// end ; 10 :
16025: GO 16121
16027: LD_INT 10
16029: DOUBLE
16030: EQUAL
16031: IFTRUE 16035
16033: GO 16120
16035: POP
// begin for i = 1 to [ 12 , 14 , 16 ] [ Difficulty ] do
16036: LD_ADDR_VAR 0 3
16040: PUSH
16041: DOUBLE
16042: LD_INT 1
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 12
16048: PUSH
16049: LD_INT 14
16051: PUSH
16052: LD_INT 16
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: PUSH
16060: LD_OWVAR 67
16064: ARRAY
16065: PUSH
16066: FOR_TO
16067: IFFALSE 16075
// Sold ;
16069: CALL 16134 0 0
16073: GO 16066
16075: POP
16076: POP
// for i = 1 to [ 13 , 15 , 17 ] [ Difficulty ] do
16077: LD_ADDR_VAR 0 3
16081: PUSH
16082: DOUBLE
16083: LD_INT 1
16085: DEC
16086: ST_TO_ADDR
16087: LD_INT 13
16089: PUSH
16090: LD_INT 15
16092: PUSH
16093: LD_INT 17
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: LIST
16100: PUSH
16101: LD_OWVAR 67
16105: ARRAY
16106: PUSH
16107: FOR_TO
16108: IFFALSE 16116
// Tank ;
16110: CALL 16264 0 0
16114: GO 16107
16116: POP
16117: POP
// end ; end ;
16118: GO 16121
16120: POP
// ru_can_attack := true ;
16121: LD_ADDR_EXP 8
16125: PUSH
16126: LD_INT 1
16128: ST_TO_ADDR
// end ;
16129: LD_VAR 0 2
16133: RET
// function Sold ( ) ; var un , skill ; begin
16134: LD_INT 0
16136: PPUSH
16137: PPUSH
16138: PPUSH
// uc_side := 3 ;
16139: LD_ADDR_OWVAR 20
16143: PUSH
16144: LD_INT 3
16146: ST_TO_ADDR
// uc_nation := 3 ;
16147: LD_ADDR_OWVAR 21
16151: PUSH
16152: LD_INT 3
16154: ST_TO_ADDR
// InitHc ;
16155: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16159: LD_ADDR_VAR 0 3
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 6
16169: PUSH
16170: LD_INT 7
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: PUSH
16178: LD_OWVAR 67
16182: ARRAY
16183: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
16184: LD_INT 0
16186: PPUSH
16187: LD_INT 1
16189: PUSH
16190: LD_INT 9
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: LD_INT 1
16199: PPUSH
16200: LD_INT 2
16202: PPUSH
16203: CALL_OW 12
16207: ARRAY
16208: PPUSH
16209: LD_VAR 0 3
16213: PPUSH
16214: CALL_OW 380
// un := CreateHuman ;
16218: LD_ADDR_VAR 0 2
16222: PUSH
16223: CALL_OW 44
16227: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: LD_INT 4
16235: PPUSH
16236: LD_INT 0
16238: PPUSH
16239: CALL_OW 49
// ru_force := ru_force ^ un ;
16243: LD_ADDR_EXP 38
16247: PUSH
16248: LD_EXP 38
16252: PUSH
16253: LD_VAR 0 2
16257: ADD
16258: ST_TO_ADDR
// end ;
16259: LD_VAR 0 1
16263: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16264: LD_INT 0
16266: PPUSH
16267: PPUSH
16268: PPUSH
16269: PPUSH
16270: PPUSH
// uc_side := 3 ;
16271: LD_ADDR_OWVAR 20
16275: PUSH
16276: LD_INT 3
16278: ST_TO_ADDR
// uc_nation := 3 ;
16279: LD_ADDR_OWVAR 21
16283: PUSH
16284: LD_INT 3
16286: ST_TO_ADDR
// InitHc ;
16287: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16291: LD_ADDR_VAR 0 5
16295: PUSH
16296: LD_INT 5
16298: PUSH
16299: LD_INT 6
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: LIST
16309: PUSH
16310: LD_OWVAR 67
16314: ARRAY
16315: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16316: LD_ADDR_VAR 0 3
16320: PUSH
16321: LD_INT 22
16323: PUSH
16324: LD_INT 24
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: LD_INT 1
16333: PPUSH
16334: LD_INT 2
16336: PPUSH
16337: CALL_OW 12
16341: ARRAY
16342: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16343: LD_VAR 0 3
16347: PUSH
16348: LD_INT 22
16350: EQUAL
16351: IFFALSE 16386
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16353: LD_ADDR_VAR 0 4
16357: PUSH
16358: LD_INT 45
16360: PUSH
16361: LD_INT 43
16363: PUSH
16364: LD_INT 44
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 1
16374: PPUSH
16375: LD_INT 3
16377: PPUSH
16378: CALL_OW 12
16382: ARRAY
16383: ST_TO_ADDR
16384: GO 16417
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16386: LD_ADDR_VAR 0 4
16390: PUSH
16391: LD_INT 46
16393: PUSH
16394: LD_INT 44
16396: PUSH
16397: LD_INT 45
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 3
16410: PPUSH
16411: CALL_OW 12
16415: ARRAY
16416: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 3
16427: PPUSH
16428: LD_VAR 0 3
16432: PPUSH
16433: LD_INT 1
16435: PPUSH
16436: LD_INT 3
16438: PUSH
16439: LD_INT 3
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: LD_INT 1
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_INT 4
16459: PPUSH
16460: CALL_OW 12
16464: ARRAY
16465: PPUSH
16466: LD_VAR 0 4
16470: PPUSH
16471: LD_INT 99
16473: PPUSH
16474: CALL 423 0 7
16478: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 263
16488: PUSH
16489: LD_INT 1
16491: EQUAL
16492: IFFALSE 16523
// begin PrepareHuman ( false , 3 , skill ) ;
16494: LD_INT 0
16496: PPUSH
16497: LD_INT 3
16499: PPUSH
16500: LD_VAR 0 5
16504: PPUSH
16505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16509: CALL_OW 44
16513: PPUSH
16514: LD_VAR 0 2
16518: PPUSH
16519: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16523: LD_VAR 0 2
16527: PPUSH
16528: LD_INT 3
16530: PPUSH
16531: LD_INT 0
16533: PPUSH
16534: CALL_OW 49
// ru_force := ru_force ^ un ;
16538: LD_ADDR_EXP 38
16542: PUSH
16543: LD_EXP 38
16547: PUSH
16548: LD_VAR 0 2
16552: ADD
16553: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16554: LD_VAR 0 2
16558: PPUSH
16559: LD_INT 126
16561: PPUSH
16562: LD_INT 158
16564: PPUSH
16565: CALL_OW 111
// Wait ( 0 0$3 ) ;
16569: LD_INT 105
16571: PPUSH
16572: CALL_OW 67
// ComStop ( un ) ;
16576: LD_VAR 0 2
16580: PPUSH
16581: CALL_OW 141
// end ;
16585: LD_VAR 0 1
16589: RET
// every 0 0$1 do var i , time , wave ;
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16598: LD_ADDR_VAR 0 2
16602: PUSH
16603: LD_INT 25200
16605: PUSH
16606: LD_INT 24150
16608: PUSH
16609: LD_INT 23100
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: LD_OWVAR 67
16621: ARRAY
16622: ST_TO_ADDR
// wait ( time ) ;
16623: LD_VAR 0 2
16627: PPUSH
16628: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16632: LD_ADDR_VAR 0 2
16636: PUSH
16637: LD_INT 15750
16639: PUSH
16640: LD_INT 15400
16642: PUSH
16643: LD_INT 15050
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: LIST
16650: PUSH
16651: LD_OWVAR 67
16655: ARRAY
16656: ST_TO_ADDR
// wave := 0 ;
16657: LD_ADDR_VAR 0 3
16661: PUSH
16662: LD_INT 0
16664: ST_TO_ADDR
// while true do
16665: LD_INT 1
16667: IFFALSE 16771
// begin wave := wave + 1 ;
16669: LD_ADDR_VAR 0 3
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_INT 1
16681: PLUS
16682: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16683: LD_INT 22
16685: PUSH
16686: LD_INT 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: IFFALSE 16733
// begin repeat wait ( 0 0$1 ) ;
16699: LD_INT 35
16701: PPUSH
16702: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16706: LD_INT 22
16708: PUSH
16709: LD_INT 2
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: PPUSH
16716: CALL_OW 69
16720: PUSH
16721: LD_INT 0
16723: EQUAL
16724: IFFALSE 16699
// wait ( 1 1$30 ) ;
16726: LD_INT 3150
16728: PPUSH
16729: CALL_OW 67
// end ; if ru_force < 20 then
16733: LD_EXP 38
16737: PUSH
16738: LD_INT 20
16740: LESS
16741: IFFALSE 16752
// PrepareAttack ( wave ) ;
16743: LD_VAR 0 3
16747: PPUSH
16748: CALL 15589 0 1
// ru_can_attack := true ;
16752: LD_ADDR_EXP 8
16756: PUSH
16757: LD_INT 1
16759: ST_TO_ADDR
// wait ( time ) ;
16760: LD_VAR 0 2
16764: PPUSH
16765: CALL_OW 67
// end ;
16769: GO 16665
// end ;
16771: PPOPN 3
16773: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16774: LD_EXP 8
16778: PUSH
16779: LD_EXP 38
16783: AND
16784: IFFALSE 17618
16786: GO 16788
16788: DISABLE
16789: LD_INT 0
16791: PPUSH
16792: PPUSH
16793: PPUSH
16794: PPUSH
16795: PPUSH
16796: PPUSH
16797: PPUSH
16798: PPUSH
16799: PPUSH
// begin enable ;
16800: ENABLE
// points1 := [ 107 , 123 ] ;
16801: LD_ADDR_VAR 0 4
16805: PUSH
16806: LD_INT 107
16808: PUSH
16809: LD_INT 123
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: LD_INT 55
16823: PUSH
16824: LD_INT 42
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16831: LD_ADDR_VAR 0 6
16835: PUSH
16836: LD_INT 102
16838: PUSH
16839: LD_INT 140
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PUSH
16846: LD_INT 105
16848: PUSH
16849: LD_INT 142
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 129
16858: PUSH
16859: LD_INT 131
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: ST_TO_ADDR
// for i in ru_force do
16871: LD_ADDR_VAR 0 1
16875: PUSH
16876: LD_EXP 38
16880: PUSH
16881: FOR_IN
16882: IFFALSE 17616
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16884: LD_ADDR_VAR 0 3
16888: PUSH
16889: LD_INT 81
16891: PUSH
16892: LD_INT 3
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: PPUSH
16899: CALL_OW 69
16903: PPUSH
16904: LD_VAR 0 1
16908: PPUSH
16909: CALL_OW 74
16913: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16914: LD_VAR 0 1
16918: PPUSH
16919: LD_VAR 0 3
16923: PPUSH
16924: CALL_OW 296
16928: PUSH
16929: LD_INT 12
16931: LESS
16932: IFFALSE 17077
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16934: LD_VAR 0 1
16938: PPUSH
16939: CALL_OW 247
16943: PUSH
16944: LD_INT 1
16946: EQUAL
16947: PUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 257
16957: PUSH
16958: LD_INT 1
16960: EQUAL
16961: AND
16962: PUSH
16963: LD_VAR 0 3
16967: PUSH
16968: LD_INT 21
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 58
16980: PUSH
16981: EMPTY
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PPUSH
16988: CALL_OW 69
16992: IN
16993: AND
16994: IFFALSE 17012
// ComEnterUnit ( i , un ) else
16996: LD_VAR 0 1
17000: PPUSH
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 120
17010: GO 17075
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
17012: LD_VAR 0 3
17016: PUSH
17017: LD_INT 21
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 58
17029: PUSH
17030: EMPTY
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: PPUSH
17037: CALL_OW 69
17041: IN
17042: NOT
17043: IFFALSE 17061
// ComAttackUnit ( i , un ) else
17045: LD_VAR 0 1
17049: PPUSH
17050: LD_VAR 0 3
17054: PPUSH
17055: CALL_OW 115
17059: GO 17075
// ComAttackUnit ( i , JMM ) ;
17061: LD_VAR 0 1
17065: PPUSH
17066: LD_EXP 21
17070: PPUSH
17071: CALL_OW 115
// end else
17075: GO 17614
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
17077: LD_VAR 0 1
17081: PPUSH
17082: LD_VAR 0 4
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_VAR 0 4
17095: PUSH
17096: LD_INT 2
17098: ARRAY
17099: PPUSH
17100: CALL_OW 297
17104: PUSH
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 5
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 2
17126: ARRAY
17127: PPUSH
17128: CALL_OW 297
17132: GREATER
17133: PUSH
17134: LD_EXP 9
17138: AND
17139: PUSH
17140: LD_INT 9
17142: PPUSH
17143: LD_INT 81
17145: PUSH
17146: LD_INT 3
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PPUSH
17153: CALL_OW 70
17157: PUSH
17158: LD_INT 0
17160: EQUAL
17161: OR
17162: IFFALSE 17200
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
17164: LD_VAR 0 1
17168: PPUSH
17169: LD_INT 81
17171: PUSH
17172: LD_INT 3
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PPUSH
17179: CALL_OW 69
17183: PPUSH
17184: LD_VAR 0 1
17188: PPUSH
17189: CALL_OW 74
17193: PPUSH
17194: CALL_OW 115
17198: GO 17614
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 264
17209: PUSH
17210: LD_INT 45
17212: EQUAL
17213: PUSH
17214: LD_EXP 38
17218: PPUSH
17219: LD_INT 3
17221: PUSH
17222: LD_INT 34
17224: PUSH
17225: LD_INT 45
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PPUSH
17236: CALL_OW 72
17240: PUSH
17241: LD_INT 6
17243: GREATER
17244: AND
17245: IFFALSE 17426
// begin dist := 9999 ;
17247: LD_ADDR_VAR 0 8
17251: PUSH
17252: LD_INT 9999
17254: ST_TO_ADDR
// xy := 0 ;
17255: LD_ADDR_VAR 0 9
17259: PUSH
17260: LD_INT 0
17262: ST_TO_ADDR
// for x in pointsr do
17263: LD_ADDR_VAR 0 7
17267: PUSH
17268: LD_VAR 0 6
17272: PUSH
17273: FOR_IN
17274: IFFALSE 17422
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17276: LD_VAR 0 1
17280: PPUSH
17281: LD_VAR 0 7
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: LD_VAR 0 7
17294: PUSH
17295: LD_INT 2
17297: ARRAY
17298: PPUSH
17299: CALL_OW 297
17303: PUSH
17304: LD_VAR 0 8
17308: LESS
17309: IFFALSE 17354
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17311: LD_ADDR_VAR 0 8
17315: PUSH
17316: LD_VAR 0 1
17320: PPUSH
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: LD_VAR 0 7
17334: PUSH
17335: LD_INT 2
17337: ARRAY
17338: PPUSH
17339: CALL_OW 297
17343: ST_TO_ADDR
// xy := x ;
17344: LD_ADDR_VAR 0 9
17348: PUSH
17349: LD_VAR 0 7
17353: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17354: LD_VAR 0 9
17358: PUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: LD_VAR 0 9
17368: PUSH
17369: LD_INT 1
17371: ARRAY
17372: PPUSH
17373: LD_VAR 0 9
17377: PUSH
17378: LD_INT 2
17380: ARRAY
17381: PPUSH
17382: CALL_OW 297
17386: PUSH
17387: LD_INT 9
17389: GREATER
17390: AND
17391: IFFALSE 17420
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17393: LD_VAR 0 1
17397: PPUSH
17398: LD_VAR 0 9
17402: PUSH
17403: LD_INT 1
17405: ARRAY
17406: PPUSH
17407: LD_VAR 0 9
17411: PUSH
17412: LD_INT 2
17414: ARRAY
17415: PPUSH
17416: CALL_OW 114
// end ;
17420: GO 17273
17422: POP
17423: POP
// end else
17424: GO 17614
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_OWVAR 3
17435: PUSH
17436: LD_VAR 0 1
17440: DIFF
17441: PPUSH
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 74
17451: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 320
17461: NOT
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_INT 21
17470: PUSH
17471: LD_INT 2
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PUSH
17478: LD_INT 33
17480: PUSH
17481: LD_INT 1
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: LD_INT 58
17490: PUSH
17491: EMPTY
17492: LIST
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: PPUSH
17499: CALL_OW 69
17503: IN
17504: PUSH
17505: LD_VAR 0 3
17509: PUSH
17510: LD_INT 22
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: EMPTY
17517: LIST
17518: LIST
17519: PUSH
17520: LD_INT 21
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: PUSH
17530: LD_INT 3
17532: PUSH
17533: LD_INT 24
17535: PUSH
17536: LD_INT 249
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 69
17556: IN
17557: OR
17558: AND
17559: IFFALSE 17577
// ComAttackUnit ( i , un ) else
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_VAR 0 3
17570: PPUSH
17571: CALL_OW 115
17575: GO 17614
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17577: LD_VAR 0 1
17581: PPUSH
17582: LD_INT 9
17584: PPUSH
17585: LD_INT 81
17587: PUSH
17588: LD_INT 3
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 70
17599: PPUSH
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL_OW 74
17609: PPUSH
17610: CALL_OW 115
// end ; end ; end ; end ;
17614: GO 16881
17616: POP
17617: POP
// end ;
17618: PPOPN 9
17620: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17621: LD_INT 22
17623: PUSH
17624: LD_INT 3
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 32
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: IFFALSE 17737
17651: GO 17653
17653: DISABLE
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// begin enable ;
17658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17659: LD_ADDR_VAR 0 2
17663: PUSH
17664: LD_INT 22
17666: PUSH
17667: LD_INT 3
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: LD_INT 32
17676: PUSH
17677: LD_INT 1
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PPUSH
17688: CALL_OW 69
17692: ST_TO_ADDR
// for i in tmp do
17693: LD_ADDR_VAR 0 1
17697: PUSH
17698: LD_VAR 0 2
17702: PUSH
17703: FOR_IN
17704: IFFALSE 17735
// if GetFuel ( i ) < 12 then
17706: LD_VAR 0 1
17710: PPUSH
17711: CALL_OW 261
17715: PUSH
17716: LD_INT 12
17718: LESS
17719: IFFALSE 17733
// SetFuel ( i , 12 ) ;
17721: LD_VAR 0 1
17725: PPUSH
17726: LD_INT 12
17728: PPUSH
17729: CALL_OW 240
17733: GO 17703
17735: POP
17736: POP
// end ;
17737: PPOPN 2
17739: END
// every 0 0$1 trigger can_end do var i , un , wave ;
17740: LD_EXP 17
17744: IFFALSE 17918
17746: GO 17748
17748: DISABLE
17749: LD_INT 0
17751: PPUSH
17752: PPUSH
17753: PPUSH
// begin wave := 0 ;
17754: LD_ADDR_VAR 0 3
17758: PUSH
17759: LD_INT 0
17761: ST_TO_ADDR
// repeat wait ( 1 1$35 ) ;
17762: LD_INT 3325
17764: PPUSH
17765: CALL_OW 67
// PrepareAttack ( 10 ) ;
17769: LD_INT 10
17771: PPUSH
17772: CALL 15589 0 1
// wave := wave + 1 ;
17776: LD_ADDR_VAR 0 3
17780: PUSH
17781: LD_VAR 0 3
17785: PUSH
17786: LD_INT 1
17788: PLUS
17789: ST_TO_ADDR
// if wave > 1 then
17790: LD_VAR 0 3
17794: PUSH
17795: LD_INT 1
17797: GREATER
17798: IFFALSE 17914
// begin for i := 1 to 6 do
17800: LD_ADDR_VAR 0 1
17804: PUSH
17805: DOUBLE
17806: LD_INT 1
17808: DEC
17809: ST_TO_ADDR
17810: LD_INT 6
17812: PUSH
17813: FOR_TO
17814: IFFALSE 17912
// begin uc_side := 3 ;
17816: LD_ADDR_OWVAR 20
17820: PUSH
17821: LD_INT 3
17823: ST_TO_ADDR
// uc_nation := 3 ;
17824: LD_ADDR_OWVAR 21
17828: PUSH
17829: LD_INT 3
17831: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , 9 ) ;
17832: LD_INT 0
17834: PPUSH
17835: LD_INT 1
17837: PUSH
17838: LD_INT 9
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: PUSH
17845: LD_INT 1
17847: PPUSH
17848: LD_INT 2
17850: PPUSH
17851: CALL_OW 12
17855: ARRAY
17856: PPUSH
17857: LD_INT 9
17859: PPUSH
17860: CALL_OW 380
// un := CreateHuman ;
17864: LD_ADDR_VAR 0 2
17868: PUSH
17869: CALL_OW 44
17873: ST_TO_ADDR
// PlaceUnitXYR ( un , 12 , 20 , 4 , false ) ;
17874: LD_VAR 0 2
17878: PPUSH
17879: LD_INT 12
17881: PPUSH
17882: LD_INT 20
17884: PPUSH
17885: LD_INT 4
17887: PPUSH
17888: LD_INT 0
17890: PPUSH
17891: CALL_OW 50
// ComAgressiveMove ( un , 49 , 32 ) ;
17895: LD_VAR 0 2
17899: PPUSH
17900: LD_INT 49
17902: PPUSH
17903: LD_INT 32
17905: PPUSH
17906: CALL_OW 114
// end ;
17910: GO 17813
17912: POP
17913: POP
// end ; until false ;
17914: LD_INT 0
17916: IFFALSE 17762
// end ; end_of_file
17918: PPOPN 3
17920: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
17921: GO 17923
17923: DISABLE
// begin ru_radar := 98 ;
17924: LD_ADDR_EXP 41
17928: PUSH
17929: LD_INT 98
17931: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17932: LD_ADDR_EXP 42
17936: PUSH
17937: LD_INT 89
17939: ST_TO_ADDR
// us_hack := 99 ;
17940: LD_ADDR_EXP 43
17944: PUSH
17945: LD_INT 99
17947: ST_TO_ADDR
// us_artillery := 97 ;
17948: LD_ADDR_EXP 44
17952: PUSH
17953: LD_INT 97
17955: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17956: LD_ADDR_EXP 45
17960: PUSH
17961: LD_INT 91
17963: ST_TO_ADDR
// tech_Artillery := 80 ;
17964: LD_ADDR_EXP 46
17968: PUSH
17969: LD_INT 80
17971: ST_TO_ADDR
// tech_RadMat := 81 ;
17972: LD_ADDR_EXP 47
17976: PUSH
17977: LD_INT 81
17979: ST_TO_ADDR
// tech_BasicTools := 82 ;
17980: LD_ADDR_EXP 48
17984: PUSH
17985: LD_INT 82
17987: ST_TO_ADDR
// tech_Cargo := 83 ;
17988: LD_ADDR_EXP 49
17992: PUSH
17993: LD_INT 83
17995: ST_TO_ADDR
// tech_Track := 84 ;
17996: LD_ADDR_EXP 50
18000: PUSH
18001: LD_INT 84
18003: ST_TO_ADDR
// tech_Crane := 85 ;
18004: LD_ADDR_EXP 51
18008: PUSH
18009: LD_INT 85
18011: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18012: LD_ADDR_EXP 52
18016: PUSH
18017: LD_INT 86
18019: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18020: LD_ADDR_EXP 53
18024: PUSH
18025: LD_INT 87
18027: ST_TO_ADDR
// end ; end_of_file end_of_file
18028: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18029: GO 18031
18031: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18032: LD_STRING initStreamRollete();
18034: PPUSH
18035: CALL_OW 559
// InitStreamMode ;
18039: CALL 18048 0 0
// DefineStreamItems ( ) ;
18043: CALL 18488 0 0
// end ;
18047: END
// function InitStreamMode ; begin
18048: LD_INT 0
18050: PPUSH
// streamModeActive := false ;
18051: LD_ADDR_EXP 54
18055: PUSH
18056: LD_INT 0
18058: ST_TO_ADDR
// normalCounter := 36 ;
18059: LD_ADDR_EXP 55
18063: PUSH
18064: LD_INT 36
18066: ST_TO_ADDR
// hardcoreCounter := 16 ;
18067: LD_ADDR_EXP 56
18071: PUSH
18072: LD_INT 16
18074: ST_TO_ADDR
// sRocket := false ;
18075: LD_ADDR_EXP 59
18079: PUSH
18080: LD_INT 0
18082: ST_TO_ADDR
// sSpeed := false ;
18083: LD_ADDR_EXP 58
18087: PUSH
18088: LD_INT 0
18090: ST_TO_ADDR
// sEngine := false ;
18091: LD_ADDR_EXP 60
18095: PUSH
18096: LD_INT 0
18098: ST_TO_ADDR
// sSpec := false ;
18099: LD_ADDR_EXP 57
18103: PUSH
18104: LD_INT 0
18106: ST_TO_ADDR
// sLevel := false ;
18107: LD_ADDR_EXP 61
18111: PUSH
18112: LD_INT 0
18114: ST_TO_ADDR
// sArmoury := false ;
18115: LD_ADDR_EXP 62
18119: PUSH
18120: LD_INT 0
18122: ST_TO_ADDR
// sRadar := false ;
18123: LD_ADDR_EXP 63
18127: PUSH
18128: LD_INT 0
18130: ST_TO_ADDR
// sBunker := false ;
18131: LD_ADDR_EXP 64
18135: PUSH
18136: LD_INT 0
18138: ST_TO_ADDR
// sHack := false ;
18139: LD_ADDR_EXP 65
18143: PUSH
18144: LD_INT 0
18146: ST_TO_ADDR
// sFire := false ;
18147: LD_ADDR_EXP 66
18151: PUSH
18152: LD_INT 0
18154: ST_TO_ADDR
// sRefresh := false ;
18155: LD_ADDR_EXP 67
18159: PUSH
18160: LD_INT 0
18162: ST_TO_ADDR
// sExp := false ;
18163: LD_ADDR_EXP 68
18167: PUSH
18168: LD_INT 0
18170: ST_TO_ADDR
// sDepot := false ;
18171: LD_ADDR_EXP 69
18175: PUSH
18176: LD_INT 0
18178: ST_TO_ADDR
// sFlag := false ;
18179: LD_ADDR_EXP 70
18183: PUSH
18184: LD_INT 0
18186: ST_TO_ADDR
// sKamikadze := false ;
18187: LD_ADDR_EXP 78
18191: PUSH
18192: LD_INT 0
18194: ST_TO_ADDR
// sTroll := false ;
18195: LD_ADDR_EXP 79
18199: PUSH
18200: LD_INT 0
18202: ST_TO_ADDR
// sSlow := false ;
18203: LD_ADDR_EXP 80
18207: PUSH
18208: LD_INT 0
18210: ST_TO_ADDR
// sLack := false ;
18211: LD_ADDR_EXP 81
18215: PUSH
18216: LD_INT 0
18218: ST_TO_ADDR
// sTank := false ;
18219: LD_ADDR_EXP 83
18223: PUSH
18224: LD_INT 0
18226: ST_TO_ADDR
// sRemote := false ;
18227: LD_ADDR_EXP 84
18231: PUSH
18232: LD_INT 0
18234: ST_TO_ADDR
// sPowell := false ;
18235: LD_ADDR_EXP 85
18239: PUSH
18240: LD_INT 0
18242: ST_TO_ADDR
// sTeleport := false ;
18243: LD_ADDR_EXP 88
18247: PUSH
18248: LD_INT 0
18250: ST_TO_ADDR
// sOilTower := false ;
18251: LD_ADDR_EXP 90
18255: PUSH
18256: LD_INT 0
18258: ST_TO_ADDR
// sShovel := false ;
18259: LD_ADDR_EXP 91
18263: PUSH
18264: LD_INT 0
18266: ST_TO_ADDR
// sSheik := false ;
18267: LD_ADDR_EXP 92
18271: PUSH
18272: LD_INT 0
18274: ST_TO_ADDR
// sEarthquake := false ;
18275: LD_ADDR_EXP 94
18279: PUSH
18280: LD_INT 0
18282: ST_TO_ADDR
// sAI := false ;
18283: LD_ADDR_EXP 95
18287: PUSH
18288: LD_INT 0
18290: ST_TO_ADDR
// sCargo := false ;
18291: LD_ADDR_EXP 98
18295: PUSH
18296: LD_INT 0
18298: ST_TO_ADDR
// sDLaser := false ;
18299: LD_ADDR_EXP 99
18303: PUSH
18304: LD_INT 0
18306: ST_TO_ADDR
// sExchange := false ;
18307: LD_ADDR_EXP 100
18311: PUSH
18312: LD_INT 0
18314: ST_TO_ADDR
// sFac := false ;
18315: LD_ADDR_EXP 101
18319: PUSH
18320: LD_INT 0
18322: ST_TO_ADDR
// sPower := false ;
18323: LD_ADDR_EXP 102
18327: PUSH
18328: LD_INT 0
18330: ST_TO_ADDR
// sRandom := false ;
18331: LD_ADDR_EXP 103
18335: PUSH
18336: LD_INT 0
18338: ST_TO_ADDR
// sShield := false ;
18339: LD_ADDR_EXP 104
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// sTime := false ;
18347: LD_ADDR_EXP 105
18351: PUSH
18352: LD_INT 0
18354: ST_TO_ADDR
// sTools := false ;
18355: LD_ADDR_EXP 106
18359: PUSH
18360: LD_INT 0
18362: ST_TO_ADDR
// sSold := false ;
18363: LD_ADDR_EXP 71
18367: PUSH
18368: LD_INT 0
18370: ST_TO_ADDR
// sDiff := false ;
18371: LD_ADDR_EXP 72
18375: PUSH
18376: LD_INT 0
18378: ST_TO_ADDR
// sFog := false ;
18379: LD_ADDR_EXP 75
18383: PUSH
18384: LD_INT 0
18386: ST_TO_ADDR
// sReset := false ;
18387: LD_ADDR_EXP 76
18391: PUSH
18392: LD_INT 0
18394: ST_TO_ADDR
// sSun := false ;
18395: LD_ADDR_EXP 77
18399: PUSH
18400: LD_INT 0
18402: ST_TO_ADDR
// sTiger := false ;
18403: LD_ADDR_EXP 73
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// sBomb := false ;
18411: LD_ADDR_EXP 74
18415: PUSH
18416: LD_INT 0
18418: ST_TO_ADDR
// sWound := false ;
18419: LD_ADDR_EXP 82
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// sBetray := false ;
18427: LD_ADDR_EXP 86
18431: PUSH
18432: LD_INT 0
18434: ST_TO_ADDR
// sContamin := false ;
18435: LD_ADDR_EXP 87
18439: PUSH
18440: LD_INT 0
18442: ST_TO_ADDR
// sOil := false ;
18443: LD_ADDR_EXP 89
18447: PUSH
18448: LD_INT 0
18450: ST_TO_ADDR
// sStu := false ;
18451: LD_ADDR_EXP 93
18455: PUSH
18456: LD_INT 0
18458: ST_TO_ADDR
// sBazooka := false ;
18459: LD_ADDR_EXP 96
18463: PUSH
18464: LD_INT 0
18466: ST_TO_ADDR
// sMortar := false ;
18467: LD_ADDR_EXP 97
18471: PUSH
18472: LD_INT 0
18474: ST_TO_ADDR
// sRanger := false ;
18475: LD_ADDR_EXP 107
18479: PUSH
18480: LD_INT 0
18482: ST_TO_ADDR
// end ;
18483: LD_VAR 0 1
18487: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
18488: LD_INT 0
18490: PPUSH
18491: PPUSH
18492: PPUSH
18493: PPUSH
18494: PPUSH
// result := [ ] ;
18495: LD_ADDR_VAR 0 1
18499: PUSH
18500: EMPTY
18501: ST_TO_ADDR
// if campaign_id = 1 then
18502: LD_OWVAR 69
18506: PUSH
18507: LD_INT 1
18509: EQUAL
18510: IFFALSE 21448
// begin case mission_number of 1 :
18512: LD_OWVAR 70
18516: PUSH
18517: LD_INT 1
18519: DOUBLE
18520: EQUAL
18521: IFTRUE 18525
18523: GO 18589
18525: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
18526: LD_ADDR_VAR 0 1
18530: PUSH
18531: LD_INT 2
18533: PUSH
18534: LD_INT 4
18536: PUSH
18537: LD_INT 11
18539: PUSH
18540: LD_INT 12
18542: PUSH
18543: LD_INT 15
18545: PUSH
18546: LD_INT 16
18548: PUSH
18549: LD_INT 22
18551: PUSH
18552: LD_INT 23
18554: PUSH
18555: LD_INT 26
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: LIST
18562: LIST
18563: LIST
18564: LIST
18565: LIST
18566: LIST
18567: LIST
18568: PUSH
18569: LD_INT 101
18571: PUSH
18572: LD_INT 102
18574: PUSH
18575: LD_INT 106
18577: PUSH
18578: EMPTY
18579: LIST
18580: LIST
18581: LIST
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: ST_TO_ADDR
18587: GO 21446
18589: LD_INT 2
18591: DOUBLE
18592: EQUAL
18593: IFTRUE 18597
18595: GO 18669
18597: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
18598: LD_ADDR_VAR 0 1
18602: PUSH
18603: LD_INT 2
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: LD_INT 11
18611: PUSH
18612: LD_INT 12
18614: PUSH
18615: LD_INT 15
18617: PUSH
18618: LD_INT 16
18620: PUSH
18621: LD_INT 22
18623: PUSH
18624: LD_INT 23
18626: PUSH
18627: LD_INT 26
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: LIST
18634: LIST
18635: LIST
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 101
18643: PUSH
18644: LD_INT 102
18646: PUSH
18647: LD_INT 105
18649: PUSH
18650: LD_INT 106
18652: PUSH
18653: LD_INT 108
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: LIST
18660: LIST
18661: LIST
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: ST_TO_ADDR
18667: GO 21446
18669: LD_INT 3
18671: DOUBLE
18672: EQUAL
18673: IFTRUE 18677
18675: GO 18753
18677: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
18678: LD_ADDR_VAR 0 1
18682: PUSH
18683: LD_INT 2
18685: PUSH
18686: LD_INT 4
18688: PUSH
18689: LD_INT 5
18691: PUSH
18692: LD_INT 11
18694: PUSH
18695: LD_INT 12
18697: PUSH
18698: LD_INT 15
18700: PUSH
18701: LD_INT 16
18703: PUSH
18704: LD_INT 22
18706: PUSH
18707: LD_INT 26
18709: PUSH
18710: LD_INT 36
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: LIST
18717: LIST
18718: LIST
18719: LIST
18720: LIST
18721: LIST
18722: LIST
18723: LIST
18724: PUSH
18725: LD_INT 101
18727: PUSH
18728: LD_INT 102
18730: PUSH
18731: LD_INT 105
18733: PUSH
18734: LD_INT 106
18736: PUSH
18737: LD_INT 108
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: LIST
18744: LIST
18745: LIST
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: ST_TO_ADDR
18751: GO 21446
18753: LD_INT 4
18755: DOUBLE
18756: EQUAL
18757: IFTRUE 18761
18759: GO 18845
18761: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
18762: LD_ADDR_VAR 0 1
18766: PUSH
18767: LD_INT 2
18769: PUSH
18770: LD_INT 4
18772: PUSH
18773: LD_INT 5
18775: PUSH
18776: LD_INT 8
18778: PUSH
18779: LD_INT 11
18781: PUSH
18782: LD_INT 12
18784: PUSH
18785: LD_INT 15
18787: PUSH
18788: LD_INT 16
18790: PUSH
18791: LD_INT 22
18793: PUSH
18794: LD_INT 23
18796: PUSH
18797: LD_INT 26
18799: PUSH
18800: LD_INT 36
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 101
18819: PUSH
18820: LD_INT 102
18822: PUSH
18823: LD_INT 105
18825: PUSH
18826: LD_INT 106
18828: PUSH
18829: LD_INT 108
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: LIST
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: ST_TO_ADDR
18843: GO 21446
18845: LD_INT 5
18847: DOUBLE
18848: EQUAL
18849: IFTRUE 18853
18851: GO 18953
18853: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
18854: LD_ADDR_VAR 0 1
18858: PUSH
18859: LD_INT 2
18861: PUSH
18862: LD_INT 4
18864: PUSH
18865: LD_INT 5
18867: PUSH
18868: LD_INT 6
18870: PUSH
18871: LD_INT 8
18873: PUSH
18874: LD_INT 11
18876: PUSH
18877: LD_INT 12
18879: PUSH
18880: LD_INT 15
18882: PUSH
18883: LD_INT 16
18885: PUSH
18886: LD_INT 22
18888: PUSH
18889: LD_INT 23
18891: PUSH
18892: LD_INT 25
18894: PUSH
18895: LD_INT 26
18897: PUSH
18898: LD_INT 36
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: LIST
18905: LIST
18906: LIST
18907: LIST
18908: LIST
18909: LIST
18910: LIST
18911: LIST
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 101
18919: PUSH
18920: LD_INT 102
18922: PUSH
18923: LD_INT 105
18925: PUSH
18926: LD_INT 106
18928: PUSH
18929: LD_INT 108
18931: PUSH
18932: LD_INT 109
18934: PUSH
18935: LD_INT 112
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: ST_TO_ADDR
18951: GO 21446
18953: LD_INT 6
18955: DOUBLE
18956: EQUAL
18957: IFTRUE 18961
18959: GO 19081
18961: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
18962: LD_ADDR_VAR 0 1
18966: PUSH
18967: LD_INT 2
18969: PUSH
18970: LD_INT 4
18972: PUSH
18973: LD_INT 5
18975: PUSH
18976: LD_INT 6
18978: PUSH
18979: LD_INT 8
18981: PUSH
18982: LD_INT 11
18984: PUSH
18985: LD_INT 12
18987: PUSH
18988: LD_INT 15
18990: PUSH
18991: LD_INT 16
18993: PUSH
18994: LD_INT 20
18996: PUSH
18997: LD_INT 21
18999: PUSH
19000: LD_INT 22
19002: PUSH
19003: LD_INT 23
19005: PUSH
19006: LD_INT 25
19008: PUSH
19009: LD_INT 26
19011: PUSH
19012: LD_INT 30
19014: PUSH
19015: LD_INT 31
19017: PUSH
19018: LD_INT 32
19020: PUSH
19021: LD_INT 36
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: LIST
19028: LIST
19029: LIST
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: PUSH
19045: LD_INT 101
19047: PUSH
19048: LD_INT 102
19050: PUSH
19051: LD_INT 105
19053: PUSH
19054: LD_INT 106
19056: PUSH
19057: LD_INT 108
19059: PUSH
19060: LD_INT 109
19062: PUSH
19063: LD_INT 112
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: LIST
19070: LIST
19071: LIST
19072: LIST
19073: LIST
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: ST_TO_ADDR
19079: GO 21446
19081: LD_INT 7
19083: DOUBLE
19084: EQUAL
19085: IFTRUE 19089
19087: GO 19189
19089: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19090: LD_ADDR_VAR 0 1
19094: PUSH
19095: LD_INT 2
19097: PUSH
19098: LD_INT 4
19100: PUSH
19101: LD_INT 5
19103: PUSH
19104: LD_INT 7
19106: PUSH
19107: LD_INT 11
19109: PUSH
19110: LD_INT 12
19112: PUSH
19113: LD_INT 15
19115: PUSH
19116: LD_INT 16
19118: PUSH
19119: LD_INT 20
19121: PUSH
19122: LD_INT 21
19124: PUSH
19125: LD_INT 22
19127: PUSH
19128: LD_INT 23
19130: PUSH
19131: LD_INT 25
19133: PUSH
19134: LD_INT 26
19136: PUSH
19137: EMPTY
19138: LIST
19139: LIST
19140: LIST
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: LIST
19146: LIST
19147: LIST
19148: LIST
19149: LIST
19150: LIST
19151: LIST
19152: PUSH
19153: LD_INT 101
19155: PUSH
19156: LD_INT 102
19158: PUSH
19159: LD_INT 103
19161: PUSH
19162: LD_INT 105
19164: PUSH
19165: LD_INT 106
19167: PUSH
19168: LD_INT 108
19170: PUSH
19171: LD_INT 112
19173: PUSH
19174: EMPTY
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: PUSH
19183: EMPTY
19184: LIST
19185: LIST
19186: ST_TO_ADDR
19187: GO 21446
19189: LD_INT 8
19191: DOUBLE
19192: EQUAL
19193: IFTRUE 19197
19195: GO 19325
19197: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19198: LD_ADDR_VAR 0 1
19202: PUSH
19203: LD_INT 2
19205: PUSH
19206: LD_INT 4
19208: PUSH
19209: LD_INT 5
19211: PUSH
19212: LD_INT 6
19214: PUSH
19215: LD_INT 7
19217: PUSH
19218: LD_INT 8
19220: PUSH
19221: LD_INT 11
19223: PUSH
19224: LD_INT 12
19226: PUSH
19227: LD_INT 15
19229: PUSH
19230: LD_INT 16
19232: PUSH
19233: LD_INT 20
19235: PUSH
19236: LD_INT 21
19238: PUSH
19239: LD_INT 22
19241: PUSH
19242: LD_INT 23
19244: PUSH
19245: LD_INT 25
19247: PUSH
19248: LD_INT 26
19250: PUSH
19251: LD_INT 30
19253: PUSH
19254: LD_INT 31
19256: PUSH
19257: LD_INT 32
19259: PUSH
19260: LD_INT 36
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: LIST
19268: LIST
19269: LIST
19270: LIST
19271: LIST
19272: LIST
19273: LIST
19274: LIST
19275: LIST
19276: LIST
19277: LIST
19278: LIST
19279: LIST
19280: LIST
19281: LIST
19282: LIST
19283: LIST
19284: PUSH
19285: LD_INT 101
19287: PUSH
19288: LD_INT 102
19290: PUSH
19291: LD_INT 103
19293: PUSH
19294: LD_INT 105
19296: PUSH
19297: LD_INT 106
19299: PUSH
19300: LD_INT 108
19302: PUSH
19303: LD_INT 109
19305: PUSH
19306: LD_INT 112
19308: PUSH
19309: EMPTY
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: LIST
19318: PUSH
19319: EMPTY
19320: LIST
19321: LIST
19322: ST_TO_ADDR
19323: GO 21446
19325: LD_INT 9
19327: DOUBLE
19328: EQUAL
19329: IFTRUE 19333
19331: GO 19469
19333: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19334: LD_ADDR_VAR 0 1
19338: PUSH
19339: LD_INT 2
19341: PUSH
19342: LD_INT 4
19344: PUSH
19345: LD_INT 5
19347: PUSH
19348: LD_INT 6
19350: PUSH
19351: LD_INT 7
19353: PUSH
19354: LD_INT 8
19356: PUSH
19357: LD_INT 11
19359: PUSH
19360: LD_INT 12
19362: PUSH
19363: LD_INT 15
19365: PUSH
19366: LD_INT 16
19368: PUSH
19369: LD_INT 20
19371: PUSH
19372: LD_INT 21
19374: PUSH
19375: LD_INT 22
19377: PUSH
19378: LD_INT 23
19380: PUSH
19381: LD_INT 25
19383: PUSH
19384: LD_INT 26
19386: PUSH
19387: LD_INT 28
19389: PUSH
19390: LD_INT 30
19392: PUSH
19393: LD_INT 31
19395: PUSH
19396: LD_INT 32
19398: PUSH
19399: LD_INT 36
19401: PUSH
19402: EMPTY
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: PUSH
19425: LD_INT 101
19427: PUSH
19428: LD_INT 102
19430: PUSH
19431: LD_INT 103
19433: PUSH
19434: LD_INT 105
19436: PUSH
19437: LD_INT 106
19439: PUSH
19440: LD_INT 108
19442: PUSH
19443: LD_INT 109
19445: PUSH
19446: LD_INT 112
19448: PUSH
19449: LD_INT 114
19451: PUSH
19452: EMPTY
19453: LIST
19454: LIST
19455: LIST
19456: LIST
19457: LIST
19458: LIST
19459: LIST
19460: LIST
19461: LIST
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: ST_TO_ADDR
19467: GO 21446
19469: LD_INT 10
19471: DOUBLE
19472: EQUAL
19473: IFTRUE 19477
19475: GO 19661
19477: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
19478: LD_ADDR_VAR 0 1
19482: PUSH
19483: LD_INT 2
19485: PUSH
19486: LD_INT 4
19488: PUSH
19489: LD_INT 5
19491: PUSH
19492: LD_INT 6
19494: PUSH
19495: LD_INT 7
19497: PUSH
19498: LD_INT 8
19500: PUSH
19501: LD_INT 9
19503: PUSH
19504: LD_INT 10
19506: PUSH
19507: LD_INT 11
19509: PUSH
19510: LD_INT 12
19512: PUSH
19513: LD_INT 13
19515: PUSH
19516: LD_INT 14
19518: PUSH
19519: LD_INT 15
19521: PUSH
19522: LD_INT 16
19524: PUSH
19525: LD_INT 17
19527: PUSH
19528: LD_INT 18
19530: PUSH
19531: LD_INT 19
19533: PUSH
19534: LD_INT 20
19536: PUSH
19537: LD_INT 21
19539: PUSH
19540: LD_INT 22
19542: PUSH
19543: LD_INT 23
19545: PUSH
19546: LD_INT 24
19548: PUSH
19549: LD_INT 25
19551: PUSH
19552: LD_INT 26
19554: PUSH
19555: LD_INT 28
19557: PUSH
19558: LD_INT 30
19560: PUSH
19561: LD_INT 31
19563: PUSH
19564: LD_INT 32
19566: PUSH
19567: LD_INT 36
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: LIST
19587: LIST
19588: LIST
19589: LIST
19590: LIST
19591: LIST
19592: LIST
19593: LIST
19594: LIST
19595: LIST
19596: LIST
19597: LIST
19598: LIST
19599: LIST
19600: PUSH
19601: LD_INT 101
19603: PUSH
19604: LD_INT 102
19606: PUSH
19607: LD_INT 103
19609: PUSH
19610: LD_INT 104
19612: PUSH
19613: LD_INT 105
19615: PUSH
19616: LD_INT 106
19618: PUSH
19619: LD_INT 107
19621: PUSH
19622: LD_INT 108
19624: PUSH
19625: LD_INT 109
19627: PUSH
19628: LD_INT 110
19630: PUSH
19631: LD_INT 111
19633: PUSH
19634: LD_INT 112
19636: PUSH
19637: LD_INT 114
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: PUSH
19655: EMPTY
19656: LIST
19657: LIST
19658: ST_TO_ADDR
19659: GO 21446
19661: LD_INT 11
19663: DOUBLE
19664: EQUAL
19665: IFTRUE 19669
19667: GO 19861
19669: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
19670: LD_ADDR_VAR 0 1
19674: PUSH
19675: LD_INT 2
19677: PUSH
19678: LD_INT 3
19680: PUSH
19681: LD_INT 4
19683: PUSH
19684: LD_INT 5
19686: PUSH
19687: LD_INT 6
19689: PUSH
19690: LD_INT 7
19692: PUSH
19693: LD_INT 8
19695: PUSH
19696: LD_INT 9
19698: PUSH
19699: LD_INT 10
19701: PUSH
19702: LD_INT 11
19704: PUSH
19705: LD_INT 12
19707: PUSH
19708: LD_INT 13
19710: PUSH
19711: LD_INT 14
19713: PUSH
19714: LD_INT 15
19716: PUSH
19717: LD_INT 16
19719: PUSH
19720: LD_INT 17
19722: PUSH
19723: LD_INT 18
19725: PUSH
19726: LD_INT 19
19728: PUSH
19729: LD_INT 20
19731: PUSH
19732: LD_INT 21
19734: PUSH
19735: LD_INT 22
19737: PUSH
19738: LD_INT 23
19740: PUSH
19741: LD_INT 24
19743: PUSH
19744: LD_INT 25
19746: PUSH
19747: LD_INT 26
19749: PUSH
19750: LD_INT 28
19752: PUSH
19753: LD_INT 30
19755: PUSH
19756: LD_INT 31
19758: PUSH
19759: LD_INT 32
19761: PUSH
19762: LD_INT 34
19764: PUSH
19765: LD_INT 36
19767: PUSH
19768: EMPTY
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: PUSH
19801: LD_INT 101
19803: PUSH
19804: LD_INT 102
19806: PUSH
19807: LD_INT 103
19809: PUSH
19810: LD_INT 104
19812: PUSH
19813: LD_INT 105
19815: PUSH
19816: LD_INT 106
19818: PUSH
19819: LD_INT 107
19821: PUSH
19822: LD_INT 108
19824: PUSH
19825: LD_INT 109
19827: PUSH
19828: LD_INT 110
19830: PUSH
19831: LD_INT 111
19833: PUSH
19834: LD_INT 112
19836: PUSH
19837: LD_INT 114
19839: PUSH
19840: EMPTY
19841: LIST
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: LIST
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: ST_TO_ADDR
19859: GO 21446
19861: LD_INT 12
19863: DOUBLE
19864: EQUAL
19865: IFTRUE 19869
19867: GO 20077
19869: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
19870: LD_ADDR_VAR 0 1
19874: PUSH
19875: LD_INT 1
19877: PUSH
19878: LD_INT 2
19880: PUSH
19881: LD_INT 3
19883: PUSH
19884: LD_INT 4
19886: PUSH
19887: LD_INT 5
19889: PUSH
19890: LD_INT 6
19892: PUSH
19893: LD_INT 7
19895: PUSH
19896: LD_INT 8
19898: PUSH
19899: LD_INT 9
19901: PUSH
19902: LD_INT 10
19904: PUSH
19905: LD_INT 11
19907: PUSH
19908: LD_INT 12
19910: PUSH
19911: LD_INT 13
19913: PUSH
19914: LD_INT 14
19916: PUSH
19917: LD_INT 15
19919: PUSH
19920: LD_INT 16
19922: PUSH
19923: LD_INT 17
19925: PUSH
19926: LD_INT 18
19928: PUSH
19929: LD_INT 19
19931: PUSH
19932: LD_INT 20
19934: PUSH
19935: LD_INT 21
19937: PUSH
19938: LD_INT 22
19940: PUSH
19941: LD_INT 23
19943: PUSH
19944: LD_INT 24
19946: PUSH
19947: LD_INT 25
19949: PUSH
19950: LD_INT 26
19952: PUSH
19953: LD_INT 27
19955: PUSH
19956: LD_INT 28
19958: PUSH
19959: LD_INT 30
19961: PUSH
19962: LD_INT 31
19964: PUSH
19965: LD_INT 32
19967: PUSH
19968: LD_INT 33
19970: PUSH
19971: LD_INT 34
19973: PUSH
19974: LD_INT 36
19976: PUSH
19977: EMPTY
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 101
20015: PUSH
20016: LD_INT 102
20018: PUSH
20019: LD_INT 103
20021: PUSH
20022: LD_INT 104
20024: PUSH
20025: LD_INT 105
20027: PUSH
20028: LD_INT 106
20030: PUSH
20031: LD_INT 107
20033: PUSH
20034: LD_INT 108
20036: PUSH
20037: LD_INT 109
20039: PUSH
20040: LD_INT 110
20042: PUSH
20043: LD_INT 111
20045: PUSH
20046: LD_INT 112
20048: PUSH
20049: LD_INT 113
20051: PUSH
20052: LD_INT 114
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: LIST
20059: LIST
20060: LIST
20061: LIST
20062: LIST
20063: LIST
20064: LIST
20065: LIST
20066: LIST
20067: LIST
20068: LIST
20069: LIST
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: ST_TO_ADDR
20075: GO 21446
20077: LD_INT 13
20079: DOUBLE
20080: EQUAL
20081: IFTRUE 20085
20083: GO 20281
20085: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20086: LD_ADDR_VAR 0 1
20090: PUSH
20091: LD_INT 1
20093: PUSH
20094: LD_INT 2
20096: PUSH
20097: LD_INT 3
20099: PUSH
20100: LD_INT 4
20102: PUSH
20103: LD_INT 5
20105: PUSH
20106: LD_INT 8
20108: PUSH
20109: LD_INT 9
20111: PUSH
20112: LD_INT 10
20114: PUSH
20115: LD_INT 11
20117: PUSH
20118: LD_INT 12
20120: PUSH
20121: LD_INT 14
20123: PUSH
20124: LD_INT 15
20126: PUSH
20127: LD_INT 16
20129: PUSH
20130: LD_INT 17
20132: PUSH
20133: LD_INT 18
20135: PUSH
20136: LD_INT 19
20138: PUSH
20139: LD_INT 20
20141: PUSH
20142: LD_INT 21
20144: PUSH
20145: LD_INT 22
20147: PUSH
20148: LD_INT 23
20150: PUSH
20151: LD_INT 24
20153: PUSH
20154: LD_INT 25
20156: PUSH
20157: LD_INT 26
20159: PUSH
20160: LD_INT 27
20162: PUSH
20163: LD_INT 28
20165: PUSH
20166: LD_INT 30
20168: PUSH
20169: LD_INT 31
20171: PUSH
20172: LD_INT 32
20174: PUSH
20175: LD_INT 33
20177: PUSH
20178: LD_INT 34
20180: PUSH
20181: LD_INT 36
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: PUSH
20217: LD_INT 101
20219: PUSH
20220: LD_INT 102
20222: PUSH
20223: LD_INT 103
20225: PUSH
20226: LD_INT 104
20228: PUSH
20229: LD_INT 105
20231: PUSH
20232: LD_INT 106
20234: PUSH
20235: LD_INT 107
20237: PUSH
20238: LD_INT 108
20240: PUSH
20241: LD_INT 109
20243: PUSH
20244: LD_INT 110
20246: PUSH
20247: LD_INT 111
20249: PUSH
20250: LD_INT 112
20252: PUSH
20253: LD_INT 113
20255: PUSH
20256: LD_INT 114
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: LIST
20267: LIST
20268: LIST
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: PUSH
20275: EMPTY
20276: LIST
20277: LIST
20278: ST_TO_ADDR
20279: GO 21446
20281: LD_INT 14
20283: DOUBLE
20284: EQUAL
20285: IFTRUE 20289
20287: GO 20501
20289: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20290: LD_ADDR_VAR 0 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 2
20300: PUSH
20301: LD_INT 3
20303: PUSH
20304: LD_INT 4
20306: PUSH
20307: LD_INT 5
20309: PUSH
20310: LD_INT 6
20312: PUSH
20313: LD_INT 7
20315: PUSH
20316: LD_INT 8
20318: PUSH
20319: LD_INT 9
20321: PUSH
20322: LD_INT 10
20324: PUSH
20325: LD_INT 11
20327: PUSH
20328: LD_INT 12
20330: PUSH
20331: LD_INT 13
20333: PUSH
20334: LD_INT 14
20336: PUSH
20337: LD_INT 15
20339: PUSH
20340: LD_INT 16
20342: PUSH
20343: LD_INT 17
20345: PUSH
20346: LD_INT 18
20348: PUSH
20349: LD_INT 19
20351: PUSH
20352: LD_INT 20
20354: PUSH
20355: LD_INT 21
20357: PUSH
20358: LD_INT 22
20360: PUSH
20361: LD_INT 23
20363: PUSH
20364: LD_INT 24
20366: PUSH
20367: LD_INT 25
20369: PUSH
20370: LD_INT 26
20372: PUSH
20373: LD_INT 27
20375: PUSH
20376: LD_INT 28
20378: PUSH
20379: LD_INT 29
20381: PUSH
20382: LD_INT 30
20384: PUSH
20385: LD_INT 31
20387: PUSH
20388: LD_INT 32
20390: PUSH
20391: LD_INT 33
20393: PUSH
20394: LD_INT 34
20396: PUSH
20397: LD_INT 36
20399: PUSH
20400: EMPTY
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: LIST
20436: PUSH
20437: LD_INT 101
20439: PUSH
20440: LD_INT 102
20442: PUSH
20443: LD_INT 103
20445: PUSH
20446: LD_INT 104
20448: PUSH
20449: LD_INT 105
20451: PUSH
20452: LD_INT 106
20454: PUSH
20455: LD_INT 107
20457: PUSH
20458: LD_INT 108
20460: PUSH
20461: LD_INT 109
20463: PUSH
20464: LD_INT 110
20466: PUSH
20467: LD_INT 111
20469: PUSH
20470: LD_INT 112
20472: PUSH
20473: LD_INT 113
20475: PUSH
20476: LD_INT 114
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: LIST
20488: LIST
20489: LIST
20490: LIST
20491: LIST
20492: LIST
20493: LIST
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: ST_TO_ADDR
20499: GO 21446
20501: LD_INT 15
20503: DOUBLE
20504: EQUAL
20505: IFTRUE 20509
20507: GO 20721
20509: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
20510: LD_ADDR_VAR 0 1
20514: PUSH
20515: LD_INT 1
20517: PUSH
20518: LD_INT 2
20520: PUSH
20521: LD_INT 3
20523: PUSH
20524: LD_INT 4
20526: PUSH
20527: LD_INT 5
20529: PUSH
20530: LD_INT 6
20532: PUSH
20533: LD_INT 7
20535: PUSH
20536: LD_INT 8
20538: PUSH
20539: LD_INT 9
20541: PUSH
20542: LD_INT 10
20544: PUSH
20545: LD_INT 11
20547: PUSH
20548: LD_INT 12
20550: PUSH
20551: LD_INT 13
20553: PUSH
20554: LD_INT 14
20556: PUSH
20557: LD_INT 15
20559: PUSH
20560: LD_INT 16
20562: PUSH
20563: LD_INT 17
20565: PUSH
20566: LD_INT 18
20568: PUSH
20569: LD_INT 19
20571: PUSH
20572: LD_INT 20
20574: PUSH
20575: LD_INT 21
20577: PUSH
20578: LD_INT 22
20580: PUSH
20581: LD_INT 23
20583: PUSH
20584: LD_INT 24
20586: PUSH
20587: LD_INT 25
20589: PUSH
20590: LD_INT 26
20592: PUSH
20593: LD_INT 27
20595: PUSH
20596: LD_INT 28
20598: PUSH
20599: LD_INT 29
20601: PUSH
20602: LD_INT 30
20604: PUSH
20605: LD_INT 31
20607: PUSH
20608: LD_INT 32
20610: PUSH
20611: LD_INT 33
20613: PUSH
20614: LD_INT 34
20616: PUSH
20617: LD_INT 36
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: PUSH
20657: LD_INT 101
20659: PUSH
20660: LD_INT 102
20662: PUSH
20663: LD_INT 103
20665: PUSH
20666: LD_INT 104
20668: PUSH
20669: LD_INT 105
20671: PUSH
20672: LD_INT 106
20674: PUSH
20675: LD_INT 107
20677: PUSH
20678: LD_INT 108
20680: PUSH
20681: LD_INT 109
20683: PUSH
20684: LD_INT 110
20686: PUSH
20687: LD_INT 111
20689: PUSH
20690: LD_INT 112
20692: PUSH
20693: LD_INT 113
20695: PUSH
20696: LD_INT 114
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: LIST
20703: LIST
20704: LIST
20705: LIST
20706: LIST
20707: LIST
20708: LIST
20709: LIST
20710: LIST
20711: LIST
20712: LIST
20713: LIST
20714: PUSH
20715: EMPTY
20716: LIST
20717: LIST
20718: ST_TO_ADDR
20719: GO 21446
20721: LD_INT 16
20723: DOUBLE
20724: EQUAL
20725: IFTRUE 20729
20727: GO 20853
20729: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
20730: LD_ADDR_VAR 0 1
20734: PUSH
20735: LD_INT 2
20737: PUSH
20738: LD_INT 4
20740: PUSH
20741: LD_INT 5
20743: PUSH
20744: LD_INT 7
20746: PUSH
20747: LD_INT 11
20749: PUSH
20750: LD_INT 12
20752: PUSH
20753: LD_INT 15
20755: PUSH
20756: LD_INT 16
20758: PUSH
20759: LD_INT 20
20761: PUSH
20762: LD_INT 21
20764: PUSH
20765: LD_INT 22
20767: PUSH
20768: LD_INT 23
20770: PUSH
20771: LD_INT 25
20773: PUSH
20774: LD_INT 26
20776: PUSH
20777: LD_INT 30
20779: PUSH
20780: LD_INT 31
20782: PUSH
20783: LD_INT 32
20785: PUSH
20786: LD_INT 33
20788: PUSH
20789: LD_INT 34
20791: PUSH
20792: EMPTY
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: PUSH
20813: LD_INT 101
20815: PUSH
20816: LD_INT 102
20818: PUSH
20819: LD_INT 103
20821: PUSH
20822: LD_INT 106
20824: PUSH
20825: LD_INT 108
20827: PUSH
20828: LD_INT 112
20830: PUSH
20831: LD_INT 113
20833: PUSH
20834: LD_INT 114
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: LIST
20845: LIST
20846: PUSH
20847: EMPTY
20848: LIST
20849: LIST
20850: ST_TO_ADDR
20851: GO 21446
20853: LD_INT 17
20855: DOUBLE
20856: EQUAL
20857: IFTRUE 20861
20859: GO 21073
20861: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
20862: LD_ADDR_VAR 0 1
20866: PUSH
20867: LD_INT 1
20869: PUSH
20870: LD_INT 2
20872: PUSH
20873: LD_INT 3
20875: PUSH
20876: LD_INT 4
20878: PUSH
20879: LD_INT 5
20881: PUSH
20882: LD_INT 6
20884: PUSH
20885: LD_INT 7
20887: PUSH
20888: LD_INT 8
20890: PUSH
20891: LD_INT 9
20893: PUSH
20894: LD_INT 10
20896: PUSH
20897: LD_INT 11
20899: PUSH
20900: LD_INT 12
20902: PUSH
20903: LD_INT 13
20905: PUSH
20906: LD_INT 14
20908: PUSH
20909: LD_INT 15
20911: PUSH
20912: LD_INT 16
20914: PUSH
20915: LD_INT 17
20917: PUSH
20918: LD_INT 18
20920: PUSH
20921: LD_INT 19
20923: PUSH
20924: LD_INT 20
20926: PUSH
20927: LD_INT 21
20929: PUSH
20930: LD_INT 22
20932: PUSH
20933: LD_INT 23
20935: PUSH
20936: LD_INT 24
20938: PUSH
20939: LD_INT 25
20941: PUSH
20942: LD_INT 26
20944: PUSH
20945: LD_INT 27
20947: PUSH
20948: LD_INT 28
20950: PUSH
20951: LD_INT 29
20953: PUSH
20954: LD_INT 30
20956: PUSH
20957: LD_INT 31
20959: PUSH
20960: LD_INT 32
20962: PUSH
20963: LD_INT 33
20965: PUSH
20966: LD_INT 34
20968: PUSH
20969: LD_INT 36
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: LIST
20980: LIST
20981: LIST
20982: LIST
20983: LIST
20984: LIST
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: LIST
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: LIST
21007: LIST
21008: PUSH
21009: LD_INT 101
21011: PUSH
21012: LD_INT 102
21014: PUSH
21015: LD_INT 103
21017: PUSH
21018: LD_INT 104
21020: PUSH
21021: LD_INT 105
21023: PUSH
21024: LD_INT 106
21026: PUSH
21027: LD_INT 107
21029: PUSH
21030: LD_INT 108
21032: PUSH
21033: LD_INT 109
21035: PUSH
21036: LD_INT 110
21038: PUSH
21039: LD_INT 111
21041: PUSH
21042: LD_INT 112
21044: PUSH
21045: LD_INT 113
21047: PUSH
21048: LD_INT 114
21050: PUSH
21051: EMPTY
21052: LIST
21053: LIST
21054: LIST
21055: LIST
21056: LIST
21057: LIST
21058: LIST
21059: LIST
21060: LIST
21061: LIST
21062: LIST
21063: LIST
21064: LIST
21065: LIST
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: ST_TO_ADDR
21071: GO 21446
21073: LD_INT 18
21075: DOUBLE
21076: EQUAL
21077: IFTRUE 21081
21079: GO 21217
21081: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21082: LD_ADDR_VAR 0 1
21086: PUSH
21087: LD_INT 2
21089: PUSH
21090: LD_INT 4
21092: PUSH
21093: LD_INT 5
21095: PUSH
21096: LD_INT 7
21098: PUSH
21099: LD_INT 11
21101: PUSH
21102: LD_INT 12
21104: PUSH
21105: LD_INT 15
21107: PUSH
21108: LD_INT 16
21110: PUSH
21111: LD_INT 20
21113: PUSH
21114: LD_INT 21
21116: PUSH
21117: LD_INT 22
21119: PUSH
21120: LD_INT 23
21122: PUSH
21123: LD_INT 25
21125: PUSH
21126: LD_INT 26
21128: PUSH
21129: LD_INT 30
21131: PUSH
21132: LD_INT 31
21134: PUSH
21135: LD_INT 32
21137: PUSH
21138: LD_INT 33
21140: PUSH
21141: LD_INT 34
21143: PUSH
21144: LD_INT 35
21146: PUSH
21147: LD_INT 36
21149: PUSH
21150: EMPTY
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PUSH
21173: LD_INT 101
21175: PUSH
21176: LD_INT 102
21178: PUSH
21179: LD_INT 103
21181: PUSH
21182: LD_INT 106
21184: PUSH
21185: LD_INT 108
21187: PUSH
21188: LD_INT 112
21190: PUSH
21191: LD_INT 113
21193: PUSH
21194: LD_INT 114
21196: PUSH
21197: LD_INT 115
21199: PUSH
21200: EMPTY
21201: LIST
21202: LIST
21203: LIST
21204: LIST
21205: LIST
21206: LIST
21207: LIST
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: ST_TO_ADDR
21215: GO 21446
21217: LD_INT 19
21219: DOUBLE
21220: EQUAL
21221: IFTRUE 21225
21223: GO 21445
21225: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21226: LD_ADDR_VAR 0 1
21230: PUSH
21231: LD_INT 1
21233: PUSH
21234: LD_INT 2
21236: PUSH
21237: LD_INT 3
21239: PUSH
21240: LD_INT 4
21242: PUSH
21243: LD_INT 5
21245: PUSH
21246: LD_INT 6
21248: PUSH
21249: LD_INT 7
21251: PUSH
21252: LD_INT 8
21254: PUSH
21255: LD_INT 9
21257: PUSH
21258: LD_INT 10
21260: PUSH
21261: LD_INT 11
21263: PUSH
21264: LD_INT 12
21266: PUSH
21267: LD_INT 13
21269: PUSH
21270: LD_INT 14
21272: PUSH
21273: LD_INT 15
21275: PUSH
21276: LD_INT 16
21278: PUSH
21279: LD_INT 17
21281: PUSH
21282: LD_INT 18
21284: PUSH
21285: LD_INT 19
21287: PUSH
21288: LD_INT 20
21290: PUSH
21291: LD_INT 21
21293: PUSH
21294: LD_INT 22
21296: PUSH
21297: LD_INT 23
21299: PUSH
21300: LD_INT 24
21302: PUSH
21303: LD_INT 25
21305: PUSH
21306: LD_INT 26
21308: PUSH
21309: LD_INT 27
21311: PUSH
21312: LD_INT 28
21314: PUSH
21315: LD_INT 29
21317: PUSH
21318: LD_INT 30
21320: PUSH
21321: LD_INT 31
21323: PUSH
21324: LD_INT 32
21326: PUSH
21327: LD_INT 33
21329: PUSH
21330: LD_INT 34
21332: PUSH
21333: LD_INT 35
21335: PUSH
21336: LD_INT 36
21338: PUSH
21339: EMPTY
21340: LIST
21341: LIST
21342: LIST
21343: LIST
21344: LIST
21345: LIST
21346: LIST
21347: LIST
21348: LIST
21349: LIST
21350: LIST
21351: LIST
21352: LIST
21353: LIST
21354: LIST
21355: LIST
21356: LIST
21357: LIST
21358: LIST
21359: LIST
21360: LIST
21361: LIST
21362: LIST
21363: LIST
21364: LIST
21365: LIST
21366: LIST
21367: LIST
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: PUSH
21377: LD_INT 101
21379: PUSH
21380: LD_INT 102
21382: PUSH
21383: LD_INT 103
21385: PUSH
21386: LD_INT 104
21388: PUSH
21389: LD_INT 105
21391: PUSH
21392: LD_INT 106
21394: PUSH
21395: LD_INT 107
21397: PUSH
21398: LD_INT 108
21400: PUSH
21401: LD_INT 109
21403: PUSH
21404: LD_INT 110
21406: PUSH
21407: LD_INT 111
21409: PUSH
21410: LD_INT 112
21412: PUSH
21413: LD_INT 113
21415: PUSH
21416: LD_INT 114
21418: PUSH
21419: LD_INT 115
21421: PUSH
21422: EMPTY
21423: LIST
21424: LIST
21425: LIST
21426: LIST
21427: LIST
21428: LIST
21429: LIST
21430: LIST
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: ST_TO_ADDR
21443: GO 21446
21445: POP
// end else
21446: GO 21665
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
21448: LD_ADDR_VAR 0 1
21452: PUSH
21453: LD_INT 1
21455: PUSH
21456: LD_INT 2
21458: PUSH
21459: LD_INT 3
21461: PUSH
21462: LD_INT 4
21464: PUSH
21465: LD_INT 5
21467: PUSH
21468: LD_INT 6
21470: PUSH
21471: LD_INT 7
21473: PUSH
21474: LD_INT 8
21476: PUSH
21477: LD_INT 9
21479: PUSH
21480: LD_INT 10
21482: PUSH
21483: LD_INT 11
21485: PUSH
21486: LD_INT 12
21488: PUSH
21489: LD_INT 13
21491: PUSH
21492: LD_INT 14
21494: PUSH
21495: LD_INT 15
21497: PUSH
21498: LD_INT 16
21500: PUSH
21501: LD_INT 17
21503: PUSH
21504: LD_INT 18
21506: PUSH
21507: LD_INT 19
21509: PUSH
21510: LD_INT 20
21512: PUSH
21513: LD_INT 21
21515: PUSH
21516: LD_INT 22
21518: PUSH
21519: LD_INT 23
21521: PUSH
21522: LD_INT 24
21524: PUSH
21525: LD_INT 25
21527: PUSH
21528: LD_INT 26
21530: PUSH
21531: LD_INT 27
21533: PUSH
21534: LD_INT 28
21536: PUSH
21537: LD_INT 29
21539: PUSH
21540: LD_INT 30
21542: PUSH
21543: LD_INT 31
21545: PUSH
21546: LD_INT 32
21548: PUSH
21549: LD_INT 33
21551: PUSH
21552: LD_INT 34
21554: PUSH
21555: LD_INT 35
21557: PUSH
21558: LD_INT 36
21560: PUSH
21561: EMPTY
21562: LIST
21563: LIST
21564: LIST
21565: LIST
21566: LIST
21567: LIST
21568: LIST
21569: LIST
21570: LIST
21571: LIST
21572: LIST
21573: LIST
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 101
21601: PUSH
21602: LD_INT 102
21604: PUSH
21605: LD_INT 103
21607: PUSH
21608: LD_INT 104
21610: PUSH
21611: LD_INT 105
21613: PUSH
21614: LD_INT 106
21616: PUSH
21617: LD_INT 107
21619: PUSH
21620: LD_INT 108
21622: PUSH
21623: LD_INT 109
21625: PUSH
21626: LD_INT 110
21628: PUSH
21629: LD_INT 111
21631: PUSH
21632: LD_INT 112
21634: PUSH
21635: LD_INT 113
21637: PUSH
21638: LD_INT 114
21640: PUSH
21641: LD_INT 115
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: ST_TO_ADDR
// if result then
21665: LD_VAR 0 1
21669: IFFALSE 21958
// begin normal :=  ;
21671: LD_ADDR_VAR 0 3
21675: PUSH
21676: LD_STRING 
21678: ST_TO_ADDR
// hardcore :=  ;
21679: LD_ADDR_VAR 0 4
21683: PUSH
21684: LD_STRING 
21686: ST_TO_ADDR
// for i = 1 to normalCounter do
21687: LD_ADDR_VAR 0 5
21691: PUSH
21692: DOUBLE
21693: LD_INT 1
21695: DEC
21696: ST_TO_ADDR
21697: LD_EXP 55
21701: PUSH
21702: FOR_TO
21703: IFFALSE 21804
// begin tmp := 0 ;
21705: LD_ADDR_VAR 0 2
21709: PUSH
21710: LD_STRING 0
21712: ST_TO_ADDR
// if result [ 1 ] then
21713: LD_VAR 0 1
21717: PUSH
21718: LD_INT 1
21720: ARRAY
21721: IFFALSE 21786
// if result [ 1 ] [ 1 ] = i then
21723: LD_VAR 0 1
21727: PUSH
21728: LD_INT 1
21730: ARRAY
21731: PUSH
21732: LD_INT 1
21734: ARRAY
21735: PUSH
21736: LD_VAR 0 5
21740: EQUAL
21741: IFFALSE 21786
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
21743: LD_ADDR_VAR 0 1
21747: PUSH
21748: LD_VAR 0 1
21752: PPUSH
21753: LD_INT 1
21755: PPUSH
21756: LD_VAR 0 1
21760: PUSH
21761: LD_INT 1
21763: ARRAY
21764: PPUSH
21765: LD_INT 1
21767: PPUSH
21768: CALL_OW 3
21772: PPUSH
21773: CALL_OW 1
21777: ST_TO_ADDR
// tmp := 1 ;
21778: LD_ADDR_VAR 0 2
21782: PUSH
21783: LD_STRING 1
21785: ST_TO_ADDR
// end ; normal := normal & tmp ;
21786: LD_ADDR_VAR 0 3
21790: PUSH
21791: LD_VAR 0 3
21795: PUSH
21796: LD_VAR 0 2
21800: STR
21801: ST_TO_ADDR
// end ;
21802: GO 21702
21804: POP
21805: POP
// for i = 1 to hardcoreCounter do
21806: LD_ADDR_VAR 0 5
21810: PUSH
21811: DOUBLE
21812: LD_INT 1
21814: DEC
21815: ST_TO_ADDR
21816: LD_EXP 56
21820: PUSH
21821: FOR_TO
21822: IFFALSE 21927
// begin tmp := 0 ;
21824: LD_ADDR_VAR 0 2
21828: PUSH
21829: LD_STRING 0
21831: ST_TO_ADDR
// if result [ 2 ] then
21832: LD_VAR 0 1
21836: PUSH
21837: LD_INT 2
21839: ARRAY
21840: IFFALSE 21909
// if result [ 2 ] [ 1 ] = 100 + i then
21842: LD_VAR 0 1
21846: PUSH
21847: LD_INT 2
21849: ARRAY
21850: PUSH
21851: LD_INT 1
21853: ARRAY
21854: PUSH
21855: LD_INT 100
21857: PUSH
21858: LD_VAR 0 5
21862: PLUS
21863: EQUAL
21864: IFFALSE 21909
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
21866: LD_ADDR_VAR 0 1
21870: PUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 2
21878: PPUSH
21879: LD_VAR 0 1
21883: PUSH
21884: LD_INT 2
21886: ARRAY
21887: PPUSH
21888: LD_INT 1
21890: PPUSH
21891: CALL_OW 3
21895: PPUSH
21896: CALL_OW 1
21900: ST_TO_ADDR
// tmp := 1 ;
21901: LD_ADDR_VAR 0 2
21905: PUSH
21906: LD_STRING 1
21908: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
21909: LD_ADDR_VAR 0 4
21913: PUSH
21914: LD_VAR 0 4
21918: PUSH
21919: LD_VAR 0 2
21923: STR
21924: ST_TO_ADDR
// end ;
21925: GO 21821
21927: POP
21928: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
21929: LD_STRING getStreamItemsFromMission("
21931: PUSH
21932: LD_VAR 0 3
21936: STR
21937: PUSH
21938: LD_STRING ","
21940: STR
21941: PUSH
21942: LD_VAR 0 4
21946: STR
21947: PUSH
21948: LD_STRING ")
21950: STR
21951: PPUSH
21952: CALL_OW 559
// end else
21956: GO 21965
// ToLua ( getStreamItemsFromMission("","") ) ;
21958: LD_STRING getStreamItemsFromMission("","")
21960: PPUSH
21961: CALL_OW 559
// end ;
21965: LD_VAR 0 1
21969: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
21970: LD_VAR 0 2
21974: PUSH
21975: LD_INT 100
21977: EQUAL
21978: IFFALSE 22927
// begin if not StreamModeActive then
21980: LD_EXP 54
21984: NOT
21985: IFFALSE 21995
// StreamModeActive := true ;
21987: LD_ADDR_EXP 54
21991: PUSH
21992: LD_INT 1
21994: ST_TO_ADDR
// if p3 = 0 then
21995: LD_VAR 0 3
21999: PUSH
22000: LD_INT 0
22002: EQUAL
22003: IFFALSE 22009
// InitStreamMode ;
22005: CALL 18048 0 0
// if p3 = 1 then
22009: LD_VAR 0 3
22013: PUSH
22014: LD_INT 1
22016: EQUAL
22017: IFFALSE 22027
// sRocket := true ;
22019: LD_ADDR_EXP 59
22023: PUSH
22024: LD_INT 1
22026: ST_TO_ADDR
// if p3 = 2 then
22027: LD_VAR 0 3
22031: PUSH
22032: LD_INT 2
22034: EQUAL
22035: IFFALSE 22045
// sSpeed := true ;
22037: LD_ADDR_EXP 58
22041: PUSH
22042: LD_INT 1
22044: ST_TO_ADDR
// if p3 = 3 then
22045: LD_VAR 0 3
22049: PUSH
22050: LD_INT 3
22052: EQUAL
22053: IFFALSE 22063
// sEngine := true ;
22055: LD_ADDR_EXP 60
22059: PUSH
22060: LD_INT 1
22062: ST_TO_ADDR
// if p3 = 4 then
22063: LD_VAR 0 3
22067: PUSH
22068: LD_INT 4
22070: EQUAL
22071: IFFALSE 22081
// sSpec := true ;
22073: LD_ADDR_EXP 57
22077: PUSH
22078: LD_INT 1
22080: ST_TO_ADDR
// if p3 = 5 then
22081: LD_VAR 0 3
22085: PUSH
22086: LD_INT 5
22088: EQUAL
22089: IFFALSE 22099
// sLevel := true ;
22091: LD_ADDR_EXP 61
22095: PUSH
22096: LD_INT 1
22098: ST_TO_ADDR
// if p3 = 6 then
22099: LD_VAR 0 3
22103: PUSH
22104: LD_INT 6
22106: EQUAL
22107: IFFALSE 22117
// sArmoury := true ;
22109: LD_ADDR_EXP 62
22113: PUSH
22114: LD_INT 1
22116: ST_TO_ADDR
// if p3 = 7 then
22117: LD_VAR 0 3
22121: PUSH
22122: LD_INT 7
22124: EQUAL
22125: IFFALSE 22135
// sRadar := true ;
22127: LD_ADDR_EXP 63
22131: PUSH
22132: LD_INT 1
22134: ST_TO_ADDR
// if p3 = 8 then
22135: LD_VAR 0 3
22139: PUSH
22140: LD_INT 8
22142: EQUAL
22143: IFFALSE 22153
// sBunker := true ;
22145: LD_ADDR_EXP 64
22149: PUSH
22150: LD_INT 1
22152: ST_TO_ADDR
// if p3 = 9 then
22153: LD_VAR 0 3
22157: PUSH
22158: LD_INT 9
22160: EQUAL
22161: IFFALSE 22171
// sHack := true ;
22163: LD_ADDR_EXP 65
22167: PUSH
22168: LD_INT 1
22170: ST_TO_ADDR
// if p3 = 10 then
22171: LD_VAR 0 3
22175: PUSH
22176: LD_INT 10
22178: EQUAL
22179: IFFALSE 22189
// sFire := true ;
22181: LD_ADDR_EXP 66
22185: PUSH
22186: LD_INT 1
22188: ST_TO_ADDR
// if p3 = 11 then
22189: LD_VAR 0 3
22193: PUSH
22194: LD_INT 11
22196: EQUAL
22197: IFFALSE 22207
// sRefresh := true ;
22199: LD_ADDR_EXP 67
22203: PUSH
22204: LD_INT 1
22206: ST_TO_ADDR
// if p3 = 12 then
22207: LD_VAR 0 3
22211: PUSH
22212: LD_INT 12
22214: EQUAL
22215: IFFALSE 22225
// sExp := true ;
22217: LD_ADDR_EXP 68
22221: PUSH
22222: LD_INT 1
22224: ST_TO_ADDR
// if p3 = 13 then
22225: LD_VAR 0 3
22229: PUSH
22230: LD_INT 13
22232: EQUAL
22233: IFFALSE 22243
// sDepot := true ;
22235: LD_ADDR_EXP 69
22239: PUSH
22240: LD_INT 1
22242: ST_TO_ADDR
// if p3 = 14 then
22243: LD_VAR 0 3
22247: PUSH
22248: LD_INT 14
22250: EQUAL
22251: IFFALSE 22261
// sFlag := true ;
22253: LD_ADDR_EXP 70
22257: PUSH
22258: LD_INT 1
22260: ST_TO_ADDR
// if p3 = 15 then
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 15
22268: EQUAL
22269: IFFALSE 22279
// sKamikadze := true ;
22271: LD_ADDR_EXP 78
22275: PUSH
22276: LD_INT 1
22278: ST_TO_ADDR
// if p3 = 16 then
22279: LD_VAR 0 3
22283: PUSH
22284: LD_INT 16
22286: EQUAL
22287: IFFALSE 22297
// sTroll := true ;
22289: LD_ADDR_EXP 79
22293: PUSH
22294: LD_INT 1
22296: ST_TO_ADDR
// if p3 = 17 then
22297: LD_VAR 0 3
22301: PUSH
22302: LD_INT 17
22304: EQUAL
22305: IFFALSE 22315
// sSlow := true ;
22307: LD_ADDR_EXP 80
22311: PUSH
22312: LD_INT 1
22314: ST_TO_ADDR
// if p3 = 18 then
22315: LD_VAR 0 3
22319: PUSH
22320: LD_INT 18
22322: EQUAL
22323: IFFALSE 22333
// sLack := true ;
22325: LD_ADDR_EXP 81
22329: PUSH
22330: LD_INT 1
22332: ST_TO_ADDR
// if p3 = 19 then
22333: LD_VAR 0 3
22337: PUSH
22338: LD_INT 19
22340: EQUAL
22341: IFFALSE 22351
// sTank := true ;
22343: LD_ADDR_EXP 83
22347: PUSH
22348: LD_INT 1
22350: ST_TO_ADDR
// if p3 = 20 then
22351: LD_VAR 0 3
22355: PUSH
22356: LD_INT 20
22358: EQUAL
22359: IFFALSE 22369
// sRemote := true ;
22361: LD_ADDR_EXP 84
22365: PUSH
22366: LD_INT 1
22368: ST_TO_ADDR
// if p3 = 21 then
22369: LD_VAR 0 3
22373: PUSH
22374: LD_INT 21
22376: EQUAL
22377: IFFALSE 22387
// sPowell := true ;
22379: LD_ADDR_EXP 85
22383: PUSH
22384: LD_INT 1
22386: ST_TO_ADDR
// if p3 = 22 then
22387: LD_VAR 0 3
22391: PUSH
22392: LD_INT 22
22394: EQUAL
22395: IFFALSE 22405
// sTeleport := true ;
22397: LD_ADDR_EXP 88
22401: PUSH
22402: LD_INT 1
22404: ST_TO_ADDR
// if p3 = 23 then
22405: LD_VAR 0 3
22409: PUSH
22410: LD_INT 23
22412: EQUAL
22413: IFFALSE 22423
// sOilTower := true ;
22415: LD_ADDR_EXP 90
22419: PUSH
22420: LD_INT 1
22422: ST_TO_ADDR
// if p3 = 24 then
22423: LD_VAR 0 3
22427: PUSH
22428: LD_INT 24
22430: EQUAL
22431: IFFALSE 22441
// sShovel := true ;
22433: LD_ADDR_EXP 91
22437: PUSH
22438: LD_INT 1
22440: ST_TO_ADDR
// if p3 = 25 then
22441: LD_VAR 0 3
22445: PUSH
22446: LD_INT 25
22448: EQUAL
22449: IFFALSE 22459
// sSheik := true ;
22451: LD_ADDR_EXP 92
22455: PUSH
22456: LD_INT 1
22458: ST_TO_ADDR
// if p3 = 26 then
22459: LD_VAR 0 3
22463: PUSH
22464: LD_INT 26
22466: EQUAL
22467: IFFALSE 22477
// sEarthquake := true ;
22469: LD_ADDR_EXP 94
22473: PUSH
22474: LD_INT 1
22476: ST_TO_ADDR
// if p3 = 27 then
22477: LD_VAR 0 3
22481: PUSH
22482: LD_INT 27
22484: EQUAL
22485: IFFALSE 22495
// sAI := true ;
22487: LD_ADDR_EXP 95
22491: PUSH
22492: LD_INT 1
22494: ST_TO_ADDR
// if p3 = 28 then
22495: LD_VAR 0 3
22499: PUSH
22500: LD_INT 28
22502: EQUAL
22503: IFFALSE 22513
// sCargo := true ;
22505: LD_ADDR_EXP 98
22509: PUSH
22510: LD_INT 1
22512: ST_TO_ADDR
// if p3 = 29 then
22513: LD_VAR 0 3
22517: PUSH
22518: LD_INT 29
22520: EQUAL
22521: IFFALSE 22531
// sDLaser := true ;
22523: LD_ADDR_EXP 99
22527: PUSH
22528: LD_INT 1
22530: ST_TO_ADDR
// if p3 = 30 then
22531: LD_VAR 0 3
22535: PUSH
22536: LD_INT 30
22538: EQUAL
22539: IFFALSE 22549
// sExchange := true ;
22541: LD_ADDR_EXP 100
22545: PUSH
22546: LD_INT 1
22548: ST_TO_ADDR
// if p3 = 31 then
22549: LD_VAR 0 3
22553: PUSH
22554: LD_INT 31
22556: EQUAL
22557: IFFALSE 22567
// sFac := true ;
22559: LD_ADDR_EXP 101
22563: PUSH
22564: LD_INT 1
22566: ST_TO_ADDR
// if p3 = 32 then
22567: LD_VAR 0 3
22571: PUSH
22572: LD_INT 32
22574: EQUAL
22575: IFFALSE 22585
// sPower := true ;
22577: LD_ADDR_EXP 102
22581: PUSH
22582: LD_INT 1
22584: ST_TO_ADDR
// if p3 = 33 then
22585: LD_VAR 0 3
22589: PUSH
22590: LD_INT 33
22592: EQUAL
22593: IFFALSE 22603
// sRandom := true ;
22595: LD_ADDR_EXP 103
22599: PUSH
22600: LD_INT 1
22602: ST_TO_ADDR
// if p3 = 34 then
22603: LD_VAR 0 3
22607: PUSH
22608: LD_INT 34
22610: EQUAL
22611: IFFALSE 22621
// sShield := true ;
22613: LD_ADDR_EXP 104
22617: PUSH
22618: LD_INT 1
22620: ST_TO_ADDR
// if p3 = 35 then
22621: LD_VAR 0 3
22625: PUSH
22626: LD_INT 35
22628: EQUAL
22629: IFFALSE 22639
// sTime := true ;
22631: LD_ADDR_EXP 105
22635: PUSH
22636: LD_INT 1
22638: ST_TO_ADDR
// if p3 = 36 then
22639: LD_VAR 0 3
22643: PUSH
22644: LD_INT 36
22646: EQUAL
22647: IFFALSE 22657
// sTools := true ;
22649: LD_ADDR_EXP 106
22653: PUSH
22654: LD_INT 1
22656: ST_TO_ADDR
// if p3 = 101 then
22657: LD_VAR 0 3
22661: PUSH
22662: LD_INT 101
22664: EQUAL
22665: IFFALSE 22675
// sSold := true ;
22667: LD_ADDR_EXP 71
22671: PUSH
22672: LD_INT 1
22674: ST_TO_ADDR
// if p3 = 102 then
22675: LD_VAR 0 3
22679: PUSH
22680: LD_INT 102
22682: EQUAL
22683: IFFALSE 22693
// sDiff := true ;
22685: LD_ADDR_EXP 72
22689: PUSH
22690: LD_INT 1
22692: ST_TO_ADDR
// if p3 = 103 then
22693: LD_VAR 0 3
22697: PUSH
22698: LD_INT 103
22700: EQUAL
22701: IFFALSE 22711
// sFog := true ;
22703: LD_ADDR_EXP 75
22707: PUSH
22708: LD_INT 1
22710: ST_TO_ADDR
// if p3 = 104 then
22711: LD_VAR 0 3
22715: PUSH
22716: LD_INT 104
22718: EQUAL
22719: IFFALSE 22729
// sReset := true ;
22721: LD_ADDR_EXP 76
22725: PUSH
22726: LD_INT 1
22728: ST_TO_ADDR
// if p3 = 105 then
22729: LD_VAR 0 3
22733: PUSH
22734: LD_INT 105
22736: EQUAL
22737: IFFALSE 22747
// sSun := true ;
22739: LD_ADDR_EXP 77
22743: PUSH
22744: LD_INT 1
22746: ST_TO_ADDR
// if p3 = 106 then
22747: LD_VAR 0 3
22751: PUSH
22752: LD_INT 106
22754: EQUAL
22755: IFFALSE 22765
// sTiger := true ;
22757: LD_ADDR_EXP 73
22761: PUSH
22762: LD_INT 1
22764: ST_TO_ADDR
// if p3 = 107 then
22765: LD_VAR 0 3
22769: PUSH
22770: LD_INT 107
22772: EQUAL
22773: IFFALSE 22783
// sBomb := true ;
22775: LD_ADDR_EXP 74
22779: PUSH
22780: LD_INT 1
22782: ST_TO_ADDR
// if p3 = 108 then
22783: LD_VAR 0 3
22787: PUSH
22788: LD_INT 108
22790: EQUAL
22791: IFFALSE 22801
// sWound := true ;
22793: LD_ADDR_EXP 82
22797: PUSH
22798: LD_INT 1
22800: ST_TO_ADDR
// if p3 = 109 then
22801: LD_VAR 0 3
22805: PUSH
22806: LD_INT 109
22808: EQUAL
22809: IFFALSE 22819
// sBetray := true ;
22811: LD_ADDR_EXP 86
22815: PUSH
22816: LD_INT 1
22818: ST_TO_ADDR
// if p3 = 110 then
22819: LD_VAR 0 3
22823: PUSH
22824: LD_INT 110
22826: EQUAL
22827: IFFALSE 22837
// sContamin := true ;
22829: LD_ADDR_EXP 87
22833: PUSH
22834: LD_INT 1
22836: ST_TO_ADDR
// if p3 = 111 then
22837: LD_VAR 0 3
22841: PUSH
22842: LD_INT 111
22844: EQUAL
22845: IFFALSE 22855
// sOil := true ;
22847: LD_ADDR_EXP 89
22851: PUSH
22852: LD_INT 1
22854: ST_TO_ADDR
// if p3 = 112 then
22855: LD_VAR 0 3
22859: PUSH
22860: LD_INT 112
22862: EQUAL
22863: IFFALSE 22873
// sStu := true ;
22865: LD_ADDR_EXP 93
22869: PUSH
22870: LD_INT 1
22872: ST_TO_ADDR
// if p3 = 113 then
22873: LD_VAR 0 3
22877: PUSH
22878: LD_INT 113
22880: EQUAL
22881: IFFALSE 22891
// sBazooka := true ;
22883: LD_ADDR_EXP 96
22887: PUSH
22888: LD_INT 1
22890: ST_TO_ADDR
// if p3 = 114 then
22891: LD_VAR 0 3
22895: PUSH
22896: LD_INT 114
22898: EQUAL
22899: IFFALSE 22909
// sMortar := true ;
22901: LD_ADDR_EXP 97
22905: PUSH
22906: LD_INT 1
22908: ST_TO_ADDR
// if p3 = 115 then
22909: LD_VAR 0 3
22913: PUSH
22914: LD_INT 115
22916: EQUAL
22917: IFFALSE 22927
// sRanger := true ;
22919: LD_ADDR_EXP 107
22923: PUSH
22924: LD_INT 1
22926: ST_TO_ADDR
// end ; end ;
22927: PPOPN 6
22929: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
22930: LD_EXP 54
22934: PUSH
22935: LD_EXP 59
22939: AND
22940: IFFALSE 23064
22942: GO 22944
22944: DISABLE
22945: LD_INT 0
22947: PPUSH
22948: PPUSH
// begin enable ;
22949: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
22950: LD_ADDR_VAR 0 2
22954: PUSH
22955: LD_INT 22
22957: PUSH
22958: LD_OWVAR 2
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: PUSH
22967: LD_INT 2
22969: PUSH
22970: LD_INT 34
22972: PUSH
22973: LD_INT 7
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: PUSH
22980: LD_INT 34
22982: PUSH
22983: LD_INT 45
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_INT 34
22992: PUSH
22993: LD_INT 28
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: LD_INT 34
23002: PUSH
23003: LD_INT 47
23005: PUSH
23006: EMPTY
23007: LIST
23008: LIST
23009: PUSH
23010: EMPTY
23011: LIST
23012: LIST
23013: LIST
23014: LIST
23015: LIST
23016: PUSH
23017: EMPTY
23018: LIST
23019: LIST
23020: PPUSH
23021: CALL_OW 69
23025: ST_TO_ADDR
// if not tmp then
23026: LD_VAR 0 2
23030: NOT
23031: IFFALSE 23035
// exit ;
23033: GO 23064
// for i in tmp do
23035: LD_ADDR_VAR 0 1
23039: PUSH
23040: LD_VAR 0 2
23044: PUSH
23045: FOR_IN
23046: IFFALSE 23062
// begin SetLives ( i , 0 ) ;
23048: LD_VAR 0 1
23052: PPUSH
23053: LD_INT 0
23055: PPUSH
23056: CALL_OW 234
// end ;
23060: GO 23045
23062: POP
23063: POP
// end ;
23064: PPOPN 2
23066: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23067: LD_EXP 54
23071: PUSH
23072: LD_EXP 60
23076: AND
23077: IFFALSE 23161
23079: GO 23081
23081: DISABLE
23082: LD_INT 0
23084: PPUSH
23085: PPUSH
// begin enable ;
23086: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23087: LD_ADDR_VAR 0 2
23091: PUSH
23092: LD_INT 22
23094: PUSH
23095: LD_OWVAR 2
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: LD_INT 32
23106: PUSH
23107: LD_INT 3
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: PUSH
23114: EMPTY
23115: LIST
23116: LIST
23117: PPUSH
23118: CALL_OW 69
23122: ST_TO_ADDR
// if not tmp then
23123: LD_VAR 0 2
23127: NOT
23128: IFFALSE 23132
// exit ;
23130: GO 23161
// for i in tmp do
23132: LD_ADDR_VAR 0 1
23136: PUSH
23137: LD_VAR 0 2
23141: PUSH
23142: FOR_IN
23143: IFFALSE 23159
// begin SetLives ( i , 0 ) ;
23145: LD_VAR 0 1
23149: PPUSH
23150: LD_INT 0
23152: PPUSH
23153: CALL_OW 234
// end ;
23157: GO 23142
23159: POP
23160: POP
// end ;
23161: PPOPN 2
23163: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23164: LD_EXP 54
23168: PUSH
23169: LD_EXP 57
23173: AND
23174: IFFALSE 23267
23176: GO 23178
23178: DISABLE
23179: LD_INT 0
23181: PPUSH
// begin enable ;
23182: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23183: LD_ADDR_VAR 0 1
23187: PUSH
23188: LD_INT 22
23190: PUSH
23191: LD_OWVAR 2
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 2
23202: PUSH
23203: LD_INT 25
23205: PUSH
23206: LD_INT 5
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: PUSH
23213: LD_INT 25
23215: PUSH
23216: LD_INT 9
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: PUSH
23223: LD_INT 25
23225: PUSH
23226: LD_INT 8
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PPUSH
23243: CALL_OW 69
23247: PUSH
23248: FOR_IN
23249: IFFALSE 23265
// begin SetClass ( i , 1 ) ;
23251: LD_VAR 0 1
23255: PPUSH
23256: LD_INT 1
23258: PPUSH
23259: CALL_OW 336
// end ;
23263: GO 23248
23265: POP
23266: POP
// end ;
23267: PPOPN 1
23269: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23270: LD_EXP 54
23274: PUSH
23275: LD_EXP 58
23279: AND
23280: PUSH
23281: LD_OWVAR 65
23285: PUSH
23286: LD_INT 7
23288: LESS
23289: AND
23290: IFFALSE 23304
23292: GO 23294
23294: DISABLE
// begin enable ;
23295: ENABLE
// game_speed := 7 ;
23296: LD_ADDR_OWVAR 65
23300: PUSH
23301: LD_INT 7
23303: ST_TO_ADDR
// end ;
23304: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23305: LD_EXP 54
23309: PUSH
23310: LD_EXP 61
23314: AND
23315: IFFALSE 23517
23317: GO 23319
23319: DISABLE
23320: LD_INT 0
23322: PPUSH
23323: PPUSH
23324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23325: LD_ADDR_VAR 0 3
23329: PUSH
23330: LD_INT 81
23332: PUSH
23333: LD_OWVAR 2
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: PUSH
23342: LD_INT 21
23344: PUSH
23345: LD_INT 1
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: PUSH
23352: EMPTY
23353: LIST
23354: LIST
23355: PPUSH
23356: CALL_OW 69
23360: ST_TO_ADDR
// if not tmp then
23361: LD_VAR 0 3
23365: NOT
23366: IFFALSE 23370
// exit ;
23368: GO 23517
// if tmp > 5 then
23370: LD_VAR 0 3
23374: PUSH
23375: LD_INT 5
23377: GREATER
23378: IFFALSE 23390
// k := 5 else
23380: LD_ADDR_VAR 0 2
23384: PUSH
23385: LD_INT 5
23387: ST_TO_ADDR
23388: GO 23400
// k := tmp ;
23390: LD_ADDR_VAR 0 2
23394: PUSH
23395: LD_VAR 0 3
23399: ST_TO_ADDR
// for i := 1 to k do
23400: LD_ADDR_VAR 0 1
23404: PUSH
23405: DOUBLE
23406: LD_INT 1
23408: DEC
23409: ST_TO_ADDR
23410: LD_VAR 0 2
23414: PUSH
23415: FOR_TO
23416: IFFALSE 23515
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23418: LD_VAR 0 3
23422: PUSH
23423: LD_VAR 0 1
23427: ARRAY
23428: PPUSH
23429: LD_VAR 0 1
23433: PUSH
23434: LD_INT 4
23436: MOD
23437: PUSH
23438: LD_INT 1
23440: PLUS
23441: PPUSH
23442: CALL_OW 259
23446: PUSH
23447: LD_INT 10
23449: LESS
23450: IFFALSE 23513
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23452: LD_VAR 0 3
23456: PUSH
23457: LD_VAR 0 1
23461: ARRAY
23462: PPUSH
23463: LD_VAR 0 1
23467: PUSH
23468: LD_INT 4
23470: MOD
23471: PUSH
23472: LD_INT 1
23474: PLUS
23475: PPUSH
23476: LD_VAR 0 3
23480: PUSH
23481: LD_VAR 0 1
23485: ARRAY
23486: PPUSH
23487: LD_VAR 0 1
23491: PUSH
23492: LD_INT 4
23494: MOD
23495: PUSH
23496: LD_INT 1
23498: PLUS
23499: PPUSH
23500: CALL_OW 259
23504: PUSH
23505: LD_INT 1
23507: PLUS
23508: PPUSH
23509: CALL_OW 237
23513: GO 23415
23515: POP
23516: POP
// end ;
23517: PPOPN 3
23519: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23520: LD_EXP 54
23524: PUSH
23525: LD_EXP 62
23529: AND
23530: IFFALSE 23550
23532: GO 23534
23534: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23535: LD_INT 4
23537: PPUSH
23538: LD_OWVAR 2
23542: PPUSH
23543: LD_INT 0
23545: PPUSH
23546: CALL_OW 324
23550: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23551: LD_EXP 54
23555: PUSH
23556: LD_EXP 91
23560: AND
23561: IFFALSE 23581
23563: GO 23565
23565: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23566: LD_INT 19
23568: PPUSH
23569: LD_OWVAR 2
23573: PPUSH
23574: LD_INT 0
23576: PPUSH
23577: CALL_OW 324
23581: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23582: LD_EXP 54
23586: PUSH
23587: LD_EXP 63
23591: AND
23592: IFFALSE 23694
23594: GO 23596
23596: DISABLE
23597: LD_INT 0
23599: PPUSH
23600: PPUSH
// begin enable ;
23601: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23602: LD_ADDR_VAR 0 2
23606: PUSH
23607: LD_INT 22
23609: PUSH
23610: LD_OWVAR 2
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: PUSH
23619: LD_INT 2
23621: PUSH
23622: LD_INT 34
23624: PUSH
23625: LD_INT 11
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 34
23634: PUSH
23635: LD_INT 30
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: LIST
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: PPUSH
23651: CALL_OW 69
23655: ST_TO_ADDR
// if not tmp then
23656: LD_VAR 0 2
23660: NOT
23661: IFFALSE 23665
// exit ;
23663: GO 23694
// for i in tmp do
23665: LD_ADDR_VAR 0 1
23669: PUSH
23670: LD_VAR 0 2
23674: PUSH
23675: FOR_IN
23676: IFFALSE 23692
// begin SetLives ( i , 0 ) ;
23678: LD_VAR 0 1
23682: PPUSH
23683: LD_INT 0
23685: PPUSH
23686: CALL_OW 234
// end ;
23690: GO 23675
23692: POP
23693: POP
// end ;
23694: PPOPN 2
23696: END
// every 0 0$1 trigger StreamModeActive and sBunker do
23697: LD_EXP 54
23701: PUSH
23702: LD_EXP 64
23706: AND
23707: IFFALSE 23727
23709: GO 23711
23711: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
23712: LD_INT 32
23714: PPUSH
23715: LD_OWVAR 2
23719: PPUSH
23720: LD_INT 0
23722: PPUSH
23723: CALL_OW 324
23727: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
23728: LD_EXP 54
23732: PUSH
23733: LD_EXP 65
23737: AND
23738: IFFALSE 23919
23740: GO 23742
23742: DISABLE
23743: LD_INT 0
23745: PPUSH
23746: PPUSH
23747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
23748: LD_ADDR_VAR 0 2
23752: PUSH
23753: LD_INT 22
23755: PUSH
23756: LD_OWVAR 2
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: PUSH
23765: LD_INT 33
23767: PUSH
23768: LD_INT 3
23770: PUSH
23771: EMPTY
23772: LIST
23773: LIST
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PPUSH
23779: CALL_OW 69
23783: ST_TO_ADDR
// if not tmp then
23784: LD_VAR 0 2
23788: NOT
23789: IFFALSE 23793
// exit ;
23791: GO 23919
// side := 0 ;
23793: LD_ADDR_VAR 0 3
23797: PUSH
23798: LD_INT 0
23800: ST_TO_ADDR
// for i := 1 to 8 do
23801: LD_ADDR_VAR 0 1
23805: PUSH
23806: DOUBLE
23807: LD_INT 1
23809: DEC
23810: ST_TO_ADDR
23811: LD_INT 8
23813: PUSH
23814: FOR_TO
23815: IFFALSE 23863
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
23817: LD_OWVAR 2
23821: PUSH
23822: LD_VAR 0 1
23826: NONEQUAL
23827: PUSH
23828: LD_OWVAR 2
23832: PPUSH
23833: LD_VAR 0 1
23837: PPUSH
23838: CALL_OW 81
23842: PUSH
23843: LD_INT 2
23845: EQUAL
23846: AND
23847: IFFALSE 23861
// begin side := i ;
23849: LD_ADDR_VAR 0 3
23853: PUSH
23854: LD_VAR 0 1
23858: ST_TO_ADDR
// break ;
23859: GO 23863
// end ;
23861: GO 23814
23863: POP
23864: POP
// if not side then
23865: LD_VAR 0 3
23869: NOT
23870: IFFALSE 23874
// exit ;
23872: GO 23919
// for i := 1 to tmp do
23874: LD_ADDR_VAR 0 1
23878: PUSH
23879: DOUBLE
23880: LD_INT 1
23882: DEC
23883: ST_TO_ADDR
23884: LD_VAR 0 2
23888: PUSH
23889: FOR_TO
23890: IFFALSE 23917
// if Prob ( 60 ) then
23892: LD_INT 60
23894: PPUSH
23895: CALL_OW 13
23899: IFFALSE 23915
// SetSide ( i , side ) ;
23901: LD_VAR 0 1
23905: PPUSH
23906: LD_VAR 0 3
23910: PPUSH
23911: CALL_OW 235
23915: GO 23889
23917: POP
23918: POP
// end ;
23919: PPOPN 3
23921: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
23922: LD_EXP 54
23926: PUSH
23927: LD_EXP 67
23931: AND
23932: IFFALSE 24051
23934: GO 23936
23936: DISABLE
23937: LD_INT 0
23939: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
23940: LD_ADDR_VAR 0 1
23944: PUSH
23945: LD_INT 22
23947: PUSH
23948: LD_OWVAR 2
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PUSH
23957: LD_INT 21
23959: PUSH
23960: LD_INT 1
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: PUSH
23967: LD_INT 3
23969: PUSH
23970: LD_INT 23
23972: PUSH
23973: LD_INT 0
23975: PUSH
23976: EMPTY
23977: LIST
23978: LIST
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 69
23993: PUSH
23994: FOR_IN
23995: IFFALSE 24049
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
23997: LD_VAR 0 1
24001: PPUSH
24002: CALL_OW 257
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: LD_INT 2
24012: PUSH
24013: LD_INT 3
24015: PUSH
24016: LD_INT 4
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: LIST
24023: LIST
24024: IN
24025: IFFALSE 24047
// SetClass ( un , rand ( 1 , 4 ) ) ;
24027: LD_VAR 0 1
24031: PPUSH
24032: LD_INT 1
24034: PPUSH
24035: LD_INT 4
24037: PPUSH
24038: CALL_OW 12
24042: PPUSH
24043: CALL_OW 336
24047: GO 23994
24049: POP
24050: POP
// end ;
24051: PPOPN 1
24053: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24054: LD_EXP 54
24058: PUSH
24059: LD_EXP 66
24063: AND
24064: IFFALSE 24143
24066: GO 24068
24068: DISABLE
24069: LD_INT 0
24071: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24072: LD_ADDR_VAR 0 1
24076: PUSH
24077: LD_INT 22
24079: PUSH
24080: LD_OWVAR 2
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PUSH
24089: LD_INT 21
24091: PUSH
24092: LD_INT 3
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: PPUSH
24103: CALL_OW 69
24107: ST_TO_ADDR
// if not tmp then
24108: LD_VAR 0 1
24112: NOT
24113: IFFALSE 24117
// exit ;
24115: GO 24143
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24117: LD_VAR 0 1
24121: PUSH
24122: LD_INT 1
24124: PPUSH
24125: LD_VAR 0 1
24129: PPUSH
24130: CALL_OW 12
24134: ARRAY
24135: PPUSH
24136: LD_INT 100
24138: PPUSH
24139: CALL_OW 234
// end ;
24143: PPOPN 1
24145: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24146: LD_EXP 54
24150: PUSH
24151: LD_EXP 68
24155: AND
24156: IFFALSE 24254
24158: GO 24160
24160: DISABLE
24161: LD_INT 0
24163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24164: LD_ADDR_VAR 0 1
24168: PUSH
24169: LD_INT 22
24171: PUSH
24172: LD_OWVAR 2
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: LD_INT 21
24183: PUSH
24184: LD_INT 1
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: PPUSH
24195: CALL_OW 69
24199: ST_TO_ADDR
// if not tmp then
24200: LD_VAR 0 1
24204: NOT
24205: IFFALSE 24209
// exit ;
24207: GO 24254
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24209: LD_VAR 0 1
24213: PUSH
24214: LD_INT 1
24216: PPUSH
24217: LD_VAR 0 1
24221: PPUSH
24222: CALL_OW 12
24226: ARRAY
24227: PPUSH
24228: LD_INT 1
24230: PPUSH
24231: LD_INT 4
24233: PPUSH
24234: CALL_OW 12
24238: PPUSH
24239: LD_INT 3000
24241: PPUSH
24242: LD_INT 9000
24244: PPUSH
24245: CALL_OW 12
24249: PPUSH
24250: CALL_OW 492
// end ;
24254: PPOPN 1
24256: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24257: LD_EXP 54
24261: PUSH
24262: LD_EXP 69
24266: AND
24267: IFFALSE 24287
24269: GO 24271
24271: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24272: LD_INT 1
24274: PPUSH
24275: LD_OWVAR 2
24279: PPUSH
24280: LD_INT 0
24282: PPUSH
24283: CALL_OW 324
24287: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24288: LD_EXP 54
24292: PUSH
24293: LD_EXP 70
24297: AND
24298: IFFALSE 24381
24300: GO 24302
24302: DISABLE
24303: LD_INT 0
24305: PPUSH
24306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24307: LD_ADDR_VAR 0 2
24311: PUSH
24312: LD_INT 22
24314: PUSH
24315: LD_OWVAR 2
24319: PUSH
24320: EMPTY
24321: LIST
24322: LIST
24323: PUSH
24324: LD_INT 21
24326: PUSH
24327: LD_INT 3
24329: PUSH
24330: EMPTY
24331: LIST
24332: LIST
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PPUSH
24338: CALL_OW 69
24342: ST_TO_ADDR
// if not tmp then
24343: LD_VAR 0 2
24347: NOT
24348: IFFALSE 24352
// exit ;
24350: GO 24381
// for i in tmp do
24352: LD_ADDR_VAR 0 1
24356: PUSH
24357: LD_VAR 0 2
24361: PUSH
24362: FOR_IN
24363: IFFALSE 24379
// SetBLevel ( i , 10 ) ;
24365: LD_VAR 0 1
24369: PPUSH
24370: LD_INT 10
24372: PPUSH
24373: CALL_OW 241
24377: GO 24362
24379: POP
24380: POP
// end ;
24381: PPOPN 2
24383: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
24384: LD_EXP 54
24388: PUSH
24389: LD_EXP 71
24393: AND
24394: IFFALSE 24505
24396: GO 24398
24398: DISABLE
24399: LD_INT 0
24401: PPUSH
24402: PPUSH
24403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24404: LD_ADDR_VAR 0 3
24408: PUSH
24409: LD_INT 22
24411: PUSH
24412: LD_OWVAR 2
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: PUSH
24421: LD_INT 25
24423: PUSH
24424: LD_INT 1
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: EMPTY
24432: LIST
24433: LIST
24434: PPUSH
24435: CALL_OW 69
24439: ST_TO_ADDR
// if not tmp then
24440: LD_VAR 0 3
24444: NOT
24445: IFFALSE 24449
// exit ;
24447: GO 24505
// un := tmp [ rand ( 1 , tmp ) ] ;
24449: LD_ADDR_VAR 0 2
24453: PUSH
24454: LD_VAR 0 3
24458: PUSH
24459: LD_INT 1
24461: PPUSH
24462: LD_VAR 0 3
24466: PPUSH
24467: CALL_OW 12
24471: ARRAY
24472: ST_TO_ADDR
// if Crawls ( un ) then
24473: LD_VAR 0 2
24477: PPUSH
24478: CALL_OW 318
24482: IFFALSE 24493
// ComWalk ( un ) ;
24484: LD_VAR 0 2
24488: PPUSH
24489: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24493: LD_VAR 0 2
24497: PPUSH
24498: LD_INT 5
24500: PPUSH
24501: CALL_OW 336
// end ;
24505: PPOPN 3
24507: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24508: LD_EXP 54
24512: PUSH
24513: LD_EXP 72
24517: AND
24518: PUSH
24519: LD_OWVAR 67
24523: PUSH
24524: LD_INT 3
24526: LESS
24527: AND
24528: IFFALSE 24547
24530: GO 24532
24532: DISABLE
// Difficulty := Difficulty + 1 ;
24533: LD_ADDR_OWVAR 67
24537: PUSH
24538: LD_OWVAR 67
24542: PUSH
24543: LD_INT 1
24545: PLUS
24546: ST_TO_ADDR
24547: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24548: LD_EXP 54
24552: PUSH
24553: LD_EXP 73
24557: AND
24558: IFFALSE 24661
24560: GO 24562
24562: DISABLE
24563: LD_INT 0
24565: PPUSH
// begin for i := 1 to 5 do
24566: LD_ADDR_VAR 0 1
24570: PUSH
24571: DOUBLE
24572: LD_INT 1
24574: DEC
24575: ST_TO_ADDR
24576: LD_INT 5
24578: PUSH
24579: FOR_TO
24580: IFFALSE 24659
// begin uc_nation := nation_nature ;
24582: LD_ADDR_OWVAR 21
24586: PUSH
24587: LD_INT 0
24589: ST_TO_ADDR
// uc_side := 0 ;
24590: LD_ADDR_OWVAR 20
24594: PUSH
24595: LD_INT 0
24597: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24598: LD_ADDR_OWVAR 29
24602: PUSH
24603: LD_INT 12
24605: PUSH
24606: LD_INT 12
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: ST_TO_ADDR
// hc_agressivity := 20 ;
24613: LD_ADDR_OWVAR 35
24617: PUSH
24618: LD_INT 20
24620: ST_TO_ADDR
// hc_class := class_tiger ;
24621: LD_ADDR_OWVAR 28
24625: PUSH
24626: LD_INT 14
24628: ST_TO_ADDR
// hc_gallery :=  ;
24629: LD_ADDR_OWVAR 33
24633: PUSH
24634: LD_STRING 
24636: ST_TO_ADDR
// hc_name :=  ;
24637: LD_ADDR_OWVAR 26
24641: PUSH
24642: LD_STRING 
24644: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
24645: CALL_OW 44
24649: PPUSH
24650: LD_INT 0
24652: PPUSH
24653: CALL_OW 51
// end ;
24657: GO 24579
24659: POP
24660: POP
// end ;
24661: PPOPN 1
24663: END
// every 0 0$1 trigger StreamModeActive and sBomb do
24664: LD_EXP 54
24668: PUSH
24669: LD_EXP 74
24673: AND
24674: IFFALSE 24683
24676: GO 24678
24678: DISABLE
// StreamSibBomb ;
24679: CALL 24684 0 0
24683: END
// export function StreamSibBomb ; var i , x , y ; begin
24684: LD_INT 0
24686: PPUSH
24687: PPUSH
24688: PPUSH
24689: PPUSH
// result := false ;
24690: LD_ADDR_VAR 0 1
24694: PUSH
24695: LD_INT 0
24697: ST_TO_ADDR
// for i := 1 to 16 do
24698: LD_ADDR_VAR 0 2
24702: PUSH
24703: DOUBLE
24704: LD_INT 1
24706: DEC
24707: ST_TO_ADDR
24708: LD_INT 16
24710: PUSH
24711: FOR_TO
24712: IFFALSE 24911
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24714: LD_ADDR_VAR 0 3
24718: PUSH
24719: LD_INT 10
24721: PUSH
24722: LD_INT 20
24724: PUSH
24725: LD_INT 30
24727: PUSH
24728: LD_INT 40
24730: PUSH
24731: LD_INT 50
24733: PUSH
24734: LD_INT 60
24736: PUSH
24737: LD_INT 70
24739: PUSH
24740: LD_INT 80
24742: PUSH
24743: LD_INT 90
24745: PUSH
24746: LD_INT 100
24748: PUSH
24749: LD_INT 110
24751: PUSH
24752: LD_INT 120
24754: PUSH
24755: LD_INT 130
24757: PUSH
24758: LD_INT 140
24760: PUSH
24761: LD_INT 150
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: LIST
24768: LIST
24769: LIST
24770: LIST
24771: LIST
24772: LIST
24773: LIST
24774: LIST
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: PUSH
24781: LD_INT 1
24783: PPUSH
24784: LD_INT 15
24786: PPUSH
24787: CALL_OW 12
24791: ARRAY
24792: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24793: LD_ADDR_VAR 0 4
24797: PUSH
24798: LD_INT 10
24800: PUSH
24801: LD_INT 20
24803: PUSH
24804: LD_INT 30
24806: PUSH
24807: LD_INT 40
24809: PUSH
24810: LD_INT 50
24812: PUSH
24813: LD_INT 60
24815: PUSH
24816: LD_INT 70
24818: PUSH
24819: LD_INT 80
24821: PUSH
24822: LD_INT 90
24824: PUSH
24825: LD_INT 100
24827: PUSH
24828: LD_INT 110
24830: PUSH
24831: LD_INT 120
24833: PUSH
24834: LD_INT 130
24836: PUSH
24837: LD_INT 140
24839: PUSH
24840: LD_INT 150
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: PUSH
24860: LD_INT 1
24862: PPUSH
24863: LD_INT 15
24865: PPUSH
24866: CALL_OW 12
24870: ARRAY
24871: ST_TO_ADDR
// if ValidHex ( x , y ) then
24872: LD_VAR 0 3
24876: PPUSH
24877: LD_VAR 0 4
24881: PPUSH
24882: CALL_OW 488
24886: IFFALSE 24909
// begin result := [ x , y ] ;
24888: LD_ADDR_VAR 0 1
24892: PUSH
24893: LD_VAR 0 3
24897: PUSH
24898: LD_VAR 0 4
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: ST_TO_ADDR
// break ;
24907: GO 24911
// end ; end ;
24909: GO 24711
24911: POP
24912: POP
// if result then
24913: LD_VAR 0 1
24917: IFFALSE 24977
// begin ToLua ( playSibBomb() ) ;
24919: LD_STRING playSibBomb()
24921: PPUSH
24922: CALL_OW 559
// wait ( 0 0$14 ) ;
24926: LD_INT 490
24928: PPUSH
24929: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
24933: LD_VAR 0 1
24937: PUSH
24938: LD_INT 1
24940: ARRAY
24941: PPUSH
24942: LD_VAR 0 1
24946: PUSH
24947: LD_INT 2
24949: ARRAY
24950: PPUSH
24951: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
24955: LD_VAR 0 1
24959: PUSH
24960: LD_INT 1
24962: ARRAY
24963: PPUSH
24964: LD_VAR 0 1
24968: PUSH
24969: LD_INT 2
24971: ARRAY
24972: PPUSH
24973: CALL_OW 429
// end ; end ;
24977: LD_VAR 0 1
24981: RET
// every 0 0$1 trigger StreamModeActive and sReset do
24982: LD_EXP 54
24986: PUSH
24987: LD_EXP 76
24991: AND
24992: IFFALSE 25004
24994: GO 24996
24996: DISABLE
// YouLost (  ) ;
24997: LD_STRING 
24999: PPUSH
25000: CALL_OW 104
25004: END
// every 0 0$1 trigger StreamModeActive and sFog do
25005: LD_EXP 54
25009: PUSH
25010: LD_EXP 75
25014: AND
25015: IFFALSE 25029
25017: GO 25019
25019: DISABLE
// FogOff ( your_side ) ;
25020: LD_OWVAR 2
25024: PPUSH
25025: CALL_OW 344
25029: END
// every 0 0$1 trigger StreamModeActive and sSun do
25030: LD_EXP 54
25034: PUSH
25035: LD_EXP 77
25039: AND
25040: IFFALSE 25068
25042: GO 25044
25044: DISABLE
// begin solar_recharge_percent := 0 ;
25045: LD_ADDR_OWVAR 79
25049: PUSH
25050: LD_INT 0
25052: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25053: LD_INT 10500
25055: PPUSH
25056: CALL_OW 67
// solar_recharge_percent := 100 ;
25060: LD_ADDR_OWVAR 79
25064: PUSH
25065: LD_INT 100
25067: ST_TO_ADDR
// end ;
25068: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25069: LD_EXP 54
25073: PUSH
25074: LD_EXP 78
25078: AND
25079: IFFALSE 25318
25081: GO 25083
25083: DISABLE
25084: LD_INT 0
25086: PPUSH
25087: PPUSH
25088: PPUSH
// begin tmp := [ ] ;
25089: LD_ADDR_VAR 0 3
25093: PUSH
25094: EMPTY
25095: ST_TO_ADDR
// for i := 1 to 6 do
25096: LD_ADDR_VAR 0 1
25100: PUSH
25101: DOUBLE
25102: LD_INT 1
25104: DEC
25105: ST_TO_ADDR
25106: LD_INT 6
25108: PUSH
25109: FOR_TO
25110: IFFALSE 25215
// begin uc_nation := nation_nature ;
25112: LD_ADDR_OWVAR 21
25116: PUSH
25117: LD_INT 0
25119: ST_TO_ADDR
// uc_side := 0 ;
25120: LD_ADDR_OWVAR 20
25124: PUSH
25125: LD_INT 0
25127: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25128: LD_ADDR_OWVAR 29
25132: PUSH
25133: LD_INT 12
25135: PUSH
25136: LD_INT 12
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: ST_TO_ADDR
// hc_agressivity := 20 ;
25143: LD_ADDR_OWVAR 35
25147: PUSH
25148: LD_INT 20
25150: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25151: LD_ADDR_OWVAR 28
25155: PUSH
25156: LD_INT 17
25158: ST_TO_ADDR
// hc_gallery :=  ;
25159: LD_ADDR_OWVAR 33
25163: PUSH
25164: LD_STRING 
25166: ST_TO_ADDR
// hc_name :=  ;
25167: LD_ADDR_OWVAR 26
25171: PUSH
25172: LD_STRING 
25174: ST_TO_ADDR
// un := CreateHuman ;
25175: LD_ADDR_VAR 0 2
25179: PUSH
25180: CALL_OW 44
25184: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25185: LD_VAR 0 2
25189: PPUSH
25190: LD_INT 1
25192: PPUSH
25193: CALL_OW 51
// tmp := tmp ^ un ;
25197: LD_ADDR_VAR 0 3
25201: PUSH
25202: LD_VAR 0 3
25206: PUSH
25207: LD_VAR 0 2
25211: ADD
25212: ST_TO_ADDR
// end ;
25213: GO 25109
25215: POP
25216: POP
// repeat wait ( 0 0$1 ) ;
25217: LD_INT 35
25219: PPUSH
25220: CALL_OW 67
// for un in tmp do
25224: LD_ADDR_VAR 0 2
25228: PUSH
25229: LD_VAR 0 3
25233: PUSH
25234: FOR_IN
25235: IFFALSE 25309
// begin if IsDead ( un ) then
25237: LD_VAR 0 2
25241: PPUSH
25242: CALL_OW 301
25246: IFFALSE 25266
// begin tmp := tmp diff un ;
25248: LD_ADDR_VAR 0 3
25252: PUSH
25253: LD_VAR 0 3
25257: PUSH
25258: LD_VAR 0 2
25262: DIFF
25263: ST_TO_ADDR
// continue ;
25264: GO 25234
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25266: LD_VAR 0 2
25270: PPUSH
25271: LD_INT 3
25273: PUSH
25274: LD_INT 22
25276: PUSH
25277: LD_INT 0
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PPUSH
25288: CALL_OW 69
25292: PPUSH
25293: LD_VAR 0 2
25297: PPUSH
25298: CALL_OW 74
25302: PPUSH
25303: CALL_OW 115
// end ;
25307: GO 25234
25309: POP
25310: POP
// until not tmp ;
25311: LD_VAR 0 3
25315: NOT
25316: IFFALSE 25217
// end ;
25318: PPOPN 3
25320: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25321: LD_EXP 54
25325: PUSH
25326: LD_EXP 79
25330: AND
25331: IFFALSE 25385
25333: GO 25335
25335: DISABLE
// begin ToLua ( displayTroll(); ) ;
25336: LD_STRING displayTroll();
25338: PPUSH
25339: CALL_OW 559
// wait ( 3 3$00 ) ;
25343: LD_INT 6300
25345: PPUSH
25346: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25350: LD_STRING hideTroll();
25352: PPUSH
25353: CALL_OW 559
// wait ( 1 1$00 ) ;
25357: LD_INT 2100
25359: PPUSH
25360: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25364: LD_STRING displayTroll();
25366: PPUSH
25367: CALL_OW 559
// wait ( 1 1$00 ) ;
25371: LD_INT 2100
25373: PPUSH
25374: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25378: LD_STRING hideTroll();
25380: PPUSH
25381: CALL_OW 559
// end ;
25385: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25386: LD_EXP 54
25390: PUSH
25391: LD_EXP 80
25395: AND
25396: IFFALSE 25459
25398: GO 25400
25400: DISABLE
25401: LD_INT 0
25403: PPUSH
// begin p := 0 ;
25404: LD_ADDR_VAR 0 1
25408: PUSH
25409: LD_INT 0
25411: ST_TO_ADDR
// repeat game_speed := 1 ;
25412: LD_ADDR_OWVAR 65
25416: PUSH
25417: LD_INT 1
25419: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25420: LD_INT 35
25422: PPUSH
25423: CALL_OW 67
// p := p + 1 ;
25427: LD_ADDR_VAR 0 1
25431: PUSH
25432: LD_VAR 0 1
25436: PUSH
25437: LD_INT 1
25439: PLUS
25440: ST_TO_ADDR
// until p >= 60 ;
25441: LD_VAR 0 1
25445: PUSH
25446: LD_INT 60
25448: GREATEREQUAL
25449: IFFALSE 25412
// game_speed := 4 ;
25451: LD_ADDR_OWVAR 65
25455: PUSH
25456: LD_INT 4
25458: ST_TO_ADDR
// end ;
25459: PPOPN 1
25461: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25462: LD_EXP 54
25466: PUSH
25467: LD_EXP 81
25471: AND
25472: IFFALSE 25618
25474: GO 25476
25476: DISABLE
25477: LD_INT 0
25479: PPUSH
25480: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25481: LD_ADDR_VAR 0 1
25485: PUSH
25486: LD_INT 22
25488: PUSH
25489: LD_OWVAR 2
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 2
25500: PUSH
25501: LD_INT 30
25503: PUSH
25504: LD_INT 0
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: PUSH
25511: LD_INT 30
25513: PUSH
25514: LD_INT 1
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: LIST
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PPUSH
25530: CALL_OW 69
25534: ST_TO_ADDR
// if not depot then
25535: LD_VAR 0 1
25539: NOT
25540: IFFALSE 25544
// exit ;
25542: GO 25618
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25544: LD_ADDR_VAR 0 2
25548: PUSH
25549: LD_VAR 0 1
25553: PUSH
25554: LD_INT 1
25556: PPUSH
25557: LD_VAR 0 1
25561: PPUSH
25562: CALL_OW 12
25566: ARRAY
25567: PPUSH
25568: CALL_OW 274
25572: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25573: LD_VAR 0 2
25577: PPUSH
25578: LD_INT 1
25580: PPUSH
25581: LD_INT 0
25583: PPUSH
25584: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25588: LD_VAR 0 2
25592: PPUSH
25593: LD_INT 2
25595: PPUSH
25596: LD_INT 0
25598: PPUSH
25599: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25603: LD_VAR 0 2
25607: PPUSH
25608: LD_INT 3
25610: PPUSH
25611: LD_INT 0
25613: PPUSH
25614: CALL_OW 277
// end ;
25618: PPOPN 2
25620: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
25621: LD_EXP 54
25625: PUSH
25626: LD_EXP 82
25630: AND
25631: IFFALSE 25728
25633: GO 25635
25635: DISABLE
25636: LD_INT 0
25638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25639: LD_ADDR_VAR 0 1
25643: PUSH
25644: LD_INT 22
25646: PUSH
25647: LD_OWVAR 2
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PUSH
25656: LD_INT 21
25658: PUSH
25659: LD_INT 1
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: LD_INT 3
25668: PUSH
25669: LD_INT 23
25671: PUSH
25672: LD_INT 0
25674: PUSH
25675: EMPTY
25676: LIST
25677: LIST
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: LIST
25687: PPUSH
25688: CALL_OW 69
25692: ST_TO_ADDR
// if not tmp then
25693: LD_VAR 0 1
25697: NOT
25698: IFFALSE 25702
// exit ;
25700: GO 25728
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
25702: LD_VAR 0 1
25706: PUSH
25707: LD_INT 1
25709: PPUSH
25710: LD_VAR 0 1
25714: PPUSH
25715: CALL_OW 12
25719: ARRAY
25720: PPUSH
25721: LD_INT 200
25723: PPUSH
25724: CALL_OW 234
// end ;
25728: PPOPN 1
25730: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
25731: LD_EXP 54
25735: PUSH
25736: LD_EXP 83
25740: AND
25741: IFFALSE 25820
25743: GO 25745
25745: DISABLE
25746: LD_INT 0
25748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
25749: LD_ADDR_VAR 0 1
25753: PUSH
25754: LD_INT 22
25756: PUSH
25757: LD_OWVAR 2
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 21
25768: PUSH
25769: LD_INT 2
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: PPUSH
25780: CALL_OW 69
25784: ST_TO_ADDR
// if not tmp then
25785: LD_VAR 0 1
25789: NOT
25790: IFFALSE 25794
// exit ;
25792: GO 25820
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
25794: LD_VAR 0 1
25798: PUSH
25799: LD_INT 1
25801: PPUSH
25802: LD_VAR 0 1
25806: PPUSH
25807: CALL_OW 12
25811: ARRAY
25812: PPUSH
25813: LD_INT 60
25815: PPUSH
25816: CALL_OW 234
// end ;
25820: PPOPN 1
25822: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
25823: LD_EXP 54
25827: PUSH
25828: LD_EXP 84
25832: AND
25833: IFFALSE 25932
25835: GO 25837
25837: DISABLE
25838: LD_INT 0
25840: PPUSH
25841: PPUSH
// begin enable ;
25842: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
25843: LD_ADDR_VAR 0 1
25847: PUSH
25848: LD_INT 22
25850: PUSH
25851: LD_OWVAR 2
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 61
25862: PUSH
25863: EMPTY
25864: LIST
25865: PUSH
25866: LD_INT 33
25868: PUSH
25869: LD_INT 2
25871: PUSH
25872: EMPTY
25873: LIST
25874: LIST
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: LIST
25880: PPUSH
25881: CALL_OW 69
25885: ST_TO_ADDR
// if not tmp then
25886: LD_VAR 0 1
25890: NOT
25891: IFFALSE 25895
// exit ;
25893: GO 25932
// for i in tmp do
25895: LD_ADDR_VAR 0 2
25899: PUSH
25900: LD_VAR 0 1
25904: PUSH
25905: FOR_IN
25906: IFFALSE 25930
// if IsControledBy ( i ) then
25908: LD_VAR 0 2
25912: PPUSH
25913: CALL_OW 312
25917: IFFALSE 25928
// ComUnlink ( i ) ;
25919: LD_VAR 0 2
25923: PPUSH
25924: CALL_OW 136
25928: GO 25905
25930: POP
25931: POP
// end ;
25932: PPOPN 2
25934: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
25935: LD_EXP 54
25939: PUSH
25940: LD_EXP 85
25944: AND
25945: IFFALSE 26085
25947: GO 25949
25949: DISABLE
25950: LD_INT 0
25952: PPUSH
25953: PPUSH
// begin ToLua ( displayPowell(); ) ;
25954: LD_STRING displayPowell();
25956: PPUSH
25957: CALL_OW 559
// uc_side := 0 ;
25961: LD_ADDR_OWVAR 20
25965: PUSH
25966: LD_INT 0
25968: ST_TO_ADDR
// uc_nation := 2 ;
25969: LD_ADDR_OWVAR 21
25973: PUSH
25974: LD_INT 2
25976: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
25977: LD_ADDR_OWVAR 37
25981: PUSH
25982: LD_INT 14
25984: ST_TO_ADDR
// vc_engine := engine_siberite ;
25985: LD_ADDR_OWVAR 39
25989: PUSH
25990: LD_INT 3
25992: ST_TO_ADDR
// vc_control := control_apeman ;
25993: LD_ADDR_OWVAR 38
25997: PUSH
25998: LD_INT 5
26000: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26001: LD_ADDR_OWVAR 40
26005: PUSH
26006: LD_INT 29
26008: ST_TO_ADDR
// un := CreateVehicle ;
26009: LD_ADDR_VAR 0 2
26013: PUSH
26014: CALL_OW 45
26018: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26019: LD_VAR 0 2
26023: PPUSH
26024: LD_INT 1
26026: PPUSH
26027: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26031: LD_INT 35
26033: PPUSH
26034: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26038: LD_VAR 0 2
26042: PPUSH
26043: LD_INT 22
26045: PUSH
26046: LD_OWVAR 2
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PPUSH
26055: CALL_OW 69
26059: PPUSH
26060: LD_VAR 0 2
26064: PPUSH
26065: CALL_OW 74
26069: PPUSH
26070: CALL_OW 115
// until IsDead ( un ) ;
26074: LD_VAR 0 2
26078: PPUSH
26079: CALL_OW 301
26083: IFFALSE 26031
// end ;
26085: PPOPN 2
26087: END
// every 0 0$1 trigger StreamModeActive and sStu do
26088: LD_EXP 54
26092: PUSH
26093: LD_EXP 93
26097: AND
26098: IFFALSE 26114
26100: GO 26102
26102: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26103: LD_STRING displayStucuk();
26105: PPUSH
26106: CALL_OW 559
// ResetFog ;
26110: CALL_OW 335
// end ;
26114: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26115: LD_EXP 54
26119: PUSH
26120: LD_EXP 86
26124: AND
26125: IFFALSE 26266
26127: GO 26129
26129: DISABLE
26130: LD_INT 0
26132: PPUSH
26133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26134: LD_ADDR_VAR 0 2
26138: PUSH
26139: LD_INT 22
26141: PUSH
26142: LD_OWVAR 2
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: PUSH
26151: LD_INT 21
26153: PUSH
26154: LD_INT 1
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PPUSH
26165: CALL_OW 69
26169: ST_TO_ADDR
// if not tmp then
26170: LD_VAR 0 2
26174: NOT
26175: IFFALSE 26179
// exit ;
26177: GO 26266
// un := tmp [ rand ( 1 , tmp ) ] ;
26179: LD_ADDR_VAR 0 1
26183: PUSH
26184: LD_VAR 0 2
26188: PUSH
26189: LD_INT 1
26191: PPUSH
26192: LD_VAR 0 2
26196: PPUSH
26197: CALL_OW 12
26201: ARRAY
26202: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26203: LD_VAR 0 1
26207: PPUSH
26208: LD_INT 0
26210: PPUSH
26211: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26215: LD_VAR 0 1
26219: PPUSH
26220: LD_OWVAR 3
26224: PUSH
26225: LD_VAR 0 1
26229: DIFF
26230: PPUSH
26231: LD_VAR 0 1
26235: PPUSH
26236: CALL_OW 74
26240: PPUSH
26241: CALL_OW 115
// wait ( 0 0$20 ) ;
26245: LD_INT 700
26247: PPUSH
26248: CALL_OW 67
// SetSide ( un , your_side ) ;
26252: LD_VAR 0 1
26256: PPUSH
26257: LD_OWVAR 2
26261: PPUSH
26262: CALL_OW 235
// end ;
26266: PPOPN 2
26268: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26269: LD_EXP 54
26273: PUSH
26274: LD_EXP 87
26278: AND
26279: IFFALSE 26385
26281: GO 26283
26283: DISABLE
26284: LD_INT 0
26286: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26287: LD_ADDR_VAR 0 1
26291: PUSH
26292: LD_INT 22
26294: PUSH
26295: LD_OWVAR 2
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: PUSH
26304: LD_INT 2
26306: PUSH
26307: LD_INT 30
26309: PUSH
26310: LD_INT 0
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: LD_INT 30
26319: PUSH
26320: LD_INT 1
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: LIST
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PPUSH
26336: CALL_OW 69
26340: ST_TO_ADDR
// if not depot then
26341: LD_VAR 0 1
26345: NOT
26346: IFFALSE 26350
// exit ;
26348: GO 26385
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26350: LD_VAR 0 1
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 250
26363: PPUSH
26364: LD_VAR 0 1
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 251
26377: PPUSH
26378: LD_INT 70
26380: PPUSH
26381: CALL_OW 495
// end ;
26385: PPOPN 1
26387: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26388: LD_EXP 54
26392: PUSH
26393: LD_EXP 88
26397: AND
26398: IFFALSE 26609
26400: GO 26402
26402: DISABLE
26403: LD_INT 0
26405: PPUSH
26406: PPUSH
26407: PPUSH
26408: PPUSH
26409: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26410: LD_ADDR_VAR 0 5
26414: PUSH
26415: LD_INT 22
26417: PUSH
26418: LD_OWVAR 2
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PUSH
26427: LD_INT 21
26429: PUSH
26430: LD_INT 1
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PPUSH
26441: CALL_OW 69
26445: ST_TO_ADDR
// if not tmp then
26446: LD_VAR 0 5
26450: NOT
26451: IFFALSE 26455
// exit ;
26453: GO 26609
// for i in tmp do
26455: LD_ADDR_VAR 0 1
26459: PUSH
26460: LD_VAR 0 5
26464: PUSH
26465: FOR_IN
26466: IFFALSE 26607
// begin d := rand ( 0 , 5 ) ;
26468: LD_ADDR_VAR 0 4
26472: PUSH
26473: LD_INT 0
26475: PPUSH
26476: LD_INT 5
26478: PPUSH
26479: CALL_OW 12
26483: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26484: LD_ADDR_VAR 0 2
26488: PUSH
26489: LD_VAR 0 1
26493: PPUSH
26494: CALL_OW 250
26498: PPUSH
26499: LD_VAR 0 4
26503: PPUSH
26504: LD_INT 3
26506: PPUSH
26507: LD_INT 12
26509: PPUSH
26510: CALL_OW 12
26514: PPUSH
26515: CALL_OW 272
26519: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26520: LD_ADDR_VAR 0 3
26524: PUSH
26525: LD_VAR 0 1
26529: PPUSH
26530: CALL_OW 251
26534: PPUSH
26535: LD_VAR 0 4
26539: PPUSH
26540: LD_INT 3
26542: PPUSH
26543: LD_INT 12
26545: PPUSH
26546: CALL_OW 12
26550: PPUSH
26551: CALL_OW 273
26555: ST_TO_ADDR
// if ValidHex ( x , y ) then
26556: LD_VAR 0 2
26560: PPUSH
26561: LD_VAR 0 3
26565: PPUSH
26566: CALL_OW 488
26570: IFFALSE 26605
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_VAR 0 2
26581: PPUSH
26582: LD_VAR 0 3
26586: PPUSH
26587: LD_INT 3
26589: PPUSH
26590: LD_INT 6
26592: PPUSH
26593: CALL_OW 12
26597: PPUSH
26598: LD_INT 1
26600: PPUSH
26601: CALL_OW 483
// end ;
26605: GO 26465
26607: POP
26608: POP
// end ;
26609: PPOPN 5
26611: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26612: LD_EXP 54
26616: PUSH
26617: LD_EXP 89
26621: AND
26622: IFFALSE 26716
26624: GO 26626
26626: DISABLE
26627: LD_INT 0
26629: PPUSH
26630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
26631: LD_ADDR_VAR 0 2
26635: PUSH
26636: LD_INT 22
26638: PUSH
26639: LD_OWVAR 2
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PUSH
26648: LD_INT 32
26650: PUSH
26651: LD_INT 1
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 21
26660: PUSH
26661: LD_INT 2
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: EMPTY
26669: LIST
26670: LIST
26671: LIST
26672: PPUSH
26673: CALL_OW 69
26677: ST_TO_ADDR
// if not tmp then
26678: LD_VAR 0 2
26682: NOT
26683: IFFALSE 26687
// exit ;
26685: GO 26716
// for i in tmp do
26687: LD_ADDR_VAR 0 1
26691: PUSH
26692: LD_VAR 0 2
26696: PUSH
26697: FOR_IN
26698: IFFALSE 26714
// SetFuel ( i , 0 ) ;
26700: LD_VAR 0 1
26704: PPUSH
26705: LD_INT 0
26707: PPUSH
26708: CALL_OW 240
26712: GO 26697
26714: POP
26715: POP
// end ;
26716: PPOPN 2
26718: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
26719: LD_EXP 54
26723: PUSH
26724: LD_EXP 90
26728: AND
26729: IFFALSE 26795
26731: GO 26733
26733: DISABLE
26734: LD_INT 0
26736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
26737: LD_ADDR_VAR 0 1
26741: PUSH
26742: LD_INT 22
26744: PUSH
26745: LD_OWVAR 2
26749: PUSH
26750: EMPTY
26751: LIST
26752: LIST
26753: PUSH
26754: LD_INT 30
26756: PUSH
26757: LD_INT 29
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: PPUSH
26768: CALL_OW 69
26772: ST_TO_ADDR
// if not tmp then
26773: LD_VAR 0 1
26777: NOT
26778: IFFALSE 26782
// exit ;
26780: GO 26795
// DestroyUnit ( tmp [ 1 ] ) ;
26782: LD_VAR 0 1
26786: PUSH
26787: LD_INT 1
26789: ARRAY
26790: PPUSH
26791: CALL_OW 65
// end ;
26795: PPOPN 1
26797: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
26798: LD_EXP 54
26802: PUSH
26803: LD_EXP 92
26807: AND
26808: IFFALSE 26937
26810: GO 26812
26812: DISABLE
26813: LD_INT 0
26815: PPUSH
// begin uc_side := 0 ;
26816: LD_ADDR_OWVAR 20
26820: PUSH
26821: LD_INT 0
26823: ST_TO_ADDR
// uc_nation := nation_arabian ;
26824: LD_ADDR_OWVAR 21
26828: PUSH
26829: LD_INT 2
26831: ST_TO_ADDR
// hc_gallery :=  ;
26832: LD_ADDR_OWVAR 33
26836: PUSH
26837: LD_STRING 
26839: ST_TO_ADDR
// hc_name :=  ;
26840: LD_ADDR_OWVAR 26
26844: PUSH
26845: LD_STRING 
26847: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
26848: LD_INT 1
26850: PPUSH
26851: LD_INT 11
26853: PPUSH
26854: LD_INT 10
26856: PPUSH
26857: CALL_OW 380
// un := CreateHuman ;
26861: LD_ADDR_VAR 0 1
26865: PUSH
26866: CALL_OW 44
26870: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26871: LD_VAR 0 1
26875: PPUSH
26876: LD_INT 1
26878: PPUSH
26879: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26883: LD_INT 35
26885: PPUSH
26886: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26890: LD_VAR 0 1
26894: PPUSH
26895: LD_INT 22
26897: PUSH
26898: LD_OWVAR 2
26902: PUSH
26903: EMPTY
26904: LIST
26905: LIST
26906: PPUSH
26907: CALL_OW 69
26911: PPUSH
26912: LD_VAR 0 1
26916: PPUSH
26917: CALL_OW 74
26921: PPUSH
26922: CALL_OW 115
// until IsDead ( un ) ;
26926: LD_VAR 0 1
26930: PPUSH
26931: CALL_OW 301
26935: IFFALSE 26883
// end ;
26937: PPOPN 1
26939: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
26940: LD_EXP 54
26944: PUSH
26945: LD_EXP 94
26949: AND
26950: IFFALSE 26962
26952: GO 26954
26954: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
26955: LD_STRING earthquake(getX(game), 0, 32)
26957: PPUSH
26958: CALL_OW 559
26962: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
26963: LD_EXP 54
26967: PUSH
26968: LD_EXP 95
26972: AND
26973: IFFALSE 27064
26975: GO 26977
26977: DISABLE
26978: LD_INT 0
26980: PPUSH
// begin enable ;
26981: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
26982: LD_ADDR_VAR 0 1
26986: PUSH
26987: LD_INT 22
26989: PUSH
26990: LD_OWVAR 2
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 21
27001: PUSH
27002: LD_INT 2
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PUSH
27009: LD_INT 33
27011: PUSH
27012: LD_INT 3
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: LIST
27023: PPUSH
27024: CALL_OW 69
27028: ST_TO_ADDR
// if not tmp then
27029: LD_VAR 0 1
27033: NOT
27034: IFFALSE 27038
// exit ;
27036: GO 27064
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27038: LD_VAR 0 1
27042: PUSH
27043: LD_INT 1
27045: PPUSH
27046: LD_VAR 0 1
27050: PPUSH
27051: CALL_OW 12
27055: ARRAY
27056: PPUSH
27057: LD_INT 1
27059: PPUSH
27060: CALL_OW 234
// end ;
27064: PPOPN 1
27066: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27067: LD_EXP 54
27071: PUSH
27072: LD_EXP 96
27076: AND
27077: IFFALSE 27218
27079: GO 27081
27081: DISABLE
27082: LD_INT 0
27084: PPUSH
27085: PPUSH
27086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27087: LD_ADDR_VAR 0 3
27091: PUSH
27092: LD_INT 22
27094: PUSH
27095: LD_OWVAR 2
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PUSH
27104: LD_INT 25
27106: PUSH
27107: LD_INT 1
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PPUSH
27118: CALL_OW 69
27122: ST_TO_ADDR
// if not tmp then
27123: LD_VAR 0 3
27127: NOT
27128: IFFALSE 27132
// exit ;
27130: GO 27218
// un := tmp [ rand ( 1 , tmp ) ] ;
27132: LD_ADDR_VAR 0 2
27136: PUSH
27137: LD_VAR 0 3
27141: PUSH
27142: LD_INT 1
27144: PPUSH
27145: LD_VAR 0 3
27149: PPUSH
27150: CALL_OW 12
27154: ARRAY
27155: ST_TO_ADDR
// if Crawls ( un ) then
27156: LD_VAR 0 2
27160: PPUSH
27161: CALL_OW 318
27165: IFFALSE 27176
// ComWalk ( un ) ;
27167: LD_VAR 0 2
27171: PPUSH
27172: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27176: LD_VAR 0 2
27180: PPUSH
27181: LD_INT 9
27183: PPUSH
27184: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27188: LD_INT 28
27190: PPUSH
27191: LD_OWVAR 2
27195: PPUSH
27196: LD_INT 2
27198: PPUSH
27199: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27203: LD_INT 29
27205: PPUSH
27206: LD_OWVAR 2
27210: PPUSH
27211: LD_INT 2
27213: PPUSH
27214: CALL_OW 322
// end ;
27218: PPOPN 3
27220: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27221: LD_EXP 54
27225: PUSH
27226: LD_EXP 97
27230: AND
27231: IFFALSE 27342
27233: GO 27235
27235: DISABLE
27236: LD_INT 0
27238: PPUSH
27239: PPUSH
27240: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27241: LD_ADDR_VAR 0 3
27245: PUSH
27246: LD_INT 22
27248: PUSH
27249: LD_OWVAR 2
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 25
27260: PUSH
27261: LD_INT 1
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PPUSH
27272: CALL_OW 69
27276: ST_TO_ADDR
// if not tmp then
27277: LD_VAR 0 3
27281: NOT
27282: IFFALSE 27286
// exit ;
27284: GO 27342
// un := tmp [ rand ( 1 , tmp ) ] ;
27286: LD_ADDR_VAR 0 2
27290: PUSH
27291: LD_VAR 0 3
27295: PUSH
27296: LD_INT 1
27298: PPUSH
27299: LD_VAR 0 3
27303: PPUSH
27304: CALL_OW 12
27308: ARRAY
27309: ST_TO_ADDR
// if Crawls ( un ) then
27310: LD_VAR 0 2
27314: PPUSH
27315: CALL_OW 318
27319: IFFALSE 27330
// ComWalk ( un ) ;
27321: LD_VAR 0 2
27325: PPUSH
27326: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27330: LD_VAR 0 2
27334: PPUSH
27335: LD_INT 8
27337: PPUSH
27338: CALL_OW 336
// end ;
27342: PPOPN 3
27344: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27345: LD_EXP 54
27349: PUSH
27350: LD_EXP 98
27354: AND
27355: IFFALSE 27499
27357: GO 27359
27359: DISABLE
27360: LD_INT 0
27362: PPUSH
27363: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27364: LD_ADDR_VAR 0 2
27368: PUSH
27369: LD_INT 22
27371: PUSH
27372: LD_OWVAR 2
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 21
27383: PUSH
27384: LD_INT 2
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: LD_INT 2
27393: PUSH
27394: LD_INT 34
27396: PUSH
27397: LD_INT 12
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 34
27406: PUSH
27407: LD_INT 51
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: LD_INT 34
27416: PUSH
27417: LD_INT 32
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: LIST
27434: PPUSH
27435: CALL_OW 69
27439: ST_TO_ADDR
// if not tmp then
27440: LD_VAR 0 2
27444: NOT
27445: IFFALSE 27449
// exit ;
27447: GO 27499
// for i in tmp do
27449: LD_ADDR_VAR 0 1
27453: PUSH
27454: LD_VAR 0 2
27458: PUSH
27459: FOR_IN
27460: IFFALSE 27497
// if GetCargo ( i , mat_artifact ) = 0 then
27462: LD_VAR 0 1
27466: PPUSH
27467: LD_INT 4
27469: PPUSH
27470: CALL_OW 289
27474: PUSH
27475: LD_INT 0
27477: EQUAL
27478: IFFALSE 27495
// SetCargo ( i , mat_siberit , 100 ) ;
27480: LD_VAR 0 1
27484: PPUSH
27485: LD_INT 3
27487: PPUSH
27488: LD_INT 100
27490: PPUSH
27491: CALL_OW 290
27495: GO 27459
27497: POP
27498: POP
// end ;
27499: PPOPN 2
27501: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27502: LD_EXP 54
27506: PUSH
27507: LD_EXP 99
27511: AND
27512: IFFALSE 27665
27514: GO 27516
27516: DISABLE
27517: LD_INT 0
27519: PPUSH
27520: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27521: LD_ADDR_VAR 0 2
27525: PUSH
27526: LD_INT 22
27528: PUSH
27529: LD_OWVAR 2
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PPUSH
27538: CALL_OW 69
27542: ST_TO_ADDR
// if not tmp then
27543: LD_VAR 0 2
27547: NOT
27548: IFFALSE 27552
// exit ;
27550: GO 27665
// for i := 1 to 2 do
27552: LD_ADDR_VAR 0 1
27556: PUSH
27557: DOUBLE
27558: LD_INT 1
27560: DEC
27561: ST_TO_ADDR
27562: LD_INT 2
27564: PUSH
27565: FOR_TO
27566: IFFALSE 27663
// begin uc_side := your_side ;
27568: LD_ADDR_OWVAR 20
27572: PUSH
27573: LD_OWVAR 2
27577: ST_TO_ADDR
// uc_nation := nation_american ;
27578: LD_ADDR_OWVAR 21
27582: PUSH
27583: LD_INT 1
27585: ST_TO_ADDR
// vc_chassis := us_morphling ;
27586: LD_ADDR_OWVAR 37
27590: PUSH
27591: LD_INT 5
27593: ST_TO_ADDR
// vc_engine := engine_siberite ;
27594: LD_ADDR_OWVAR 39
27598: PUSH
27599: LD_INT 3
27601: ST_TO_ADDR
// vc_control := control_computer ;
27602: LD_ADDR_OWVAR 38
27606: PUSH
27607: LD_INT 3
27609: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27610: LD_ADDR_OWVAR 40
27614: PUSH
27615: LD_INT 10
27617: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
27618: CALL_OW 45
27622: PPUSH
27623: LD_VAR 0 2
27627: PUSH
27628: LD_INT 1
27630: ARRAY
27631: PPUSH
27632: CALL_OW 250
27636: PPUSH
27637: LD_VAR 0 2
27641: PUSH
27642: LD_INT 1
27644: ARRAY
27645: PPUSH
27646: CALL_OW 251
27650: PPUSH
27651: LD_INT 12
27653: PPUSH
27654: LD_INT 1
27656: PPUSH
27657: CALL_OW 50
// end ;
27661: GO 27565
27663: POP
27664: POP
// end ;
27665: PPOPN 2
27667: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
27668: LD_EXP 54
27672: PUSH
27673: LD_EXP 100
27677: AND
27678: IFFALSE 27900
27680: GO 27682
27682: DISABLE
27683: LD_INT 0
27685: PPUSH
27686: PPUSH
27687: PPUSH
27688: PPUSH
27689: PPUSH
27690: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27691: LD_ADDR_VAR 0 6
27695: PUSH
27696: LD_INT 22
27698: PUSH
27699: LD_OWVAR 2
27703: PUSH
27704: EMPTY
27705: LIST
27706: LIST
27707: PUSH
27708: LD_INT 21
27710: PUSH
27711: LD_INT 1
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 3
27720: PUSH
27721: LD_INT 23
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PUSH
27731: EMPTY
27732: LIST
27733: LIST
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: LIST
27739: PPUSH
27740: CALL_OW 69
27744: ST_TO_ADDR
// if not tmp then
27745: LD_VAR 0 6
27749: NOT
27750: IFFALSE 27754
// exit ;
27752: GO 27900
// s1 := rand ( 1 , 4 ) ;
27754: LD_ADDR_VAR 0 2
27758: PUSH
27759: LD_INT 1
27761: PPUSH
27762: LD_INT 4
27764: PPUSH
27765: CALL_OW 12
27769: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
27770: LD_ADDR_VAR 0 4
27774: PUSH
27775: LD_VAR 0 6
27779: PUSH
27780: LD_INT 1
27782: ARRAY
27783: PPUSH
27784: LD_VAR 0 2
27788: PPUSH
27789: CALL_OW 259
27793: ST_TO_ADDR
// if s1 = 1 then
27794: LD_VAR 0 2
27798: PUSH
27799: LD_INT 1
27801: EQUAL
27802: IFFALSE 27822
// s2 := rand ( 2 , 4 ) else
27804: LD_ADDR_VAR 0 3
27808: PUSH
27809: LD_INT 2
27811: PPUSH
27812: LD_INT 4
27814: PPUSH
27815: CALL_OW 12
27819: ST_TO_ADDR
27820: GO 27830
// s2 := 1 ;
27822: LD_ADDR_VAR 0 3
27826: PUSH
27827: LD_INT 1
27829: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
27830: LD_ADDR_VAR 0 5
27834: PUSH
27835: LD_VAR 0 6
27839: PUSH
27840: LD_INT 1
27842: ARRAY
27843: PPUSH
27844: LD_VAR 0 3
27848: PPUSH
27849: CALL_OW 259
27853: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
27854: LD_VAR 0 6
27858: PUSH
27859: LD_INT 1
27861: ARRAY
27862: PPUSH
27863: LD_VAR 0 2
27867: PPUSH
27868: LD_VAR 0 5
27872: PPUSH
27873: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
27877: LD_VAR 0 6
27881: PUSH
27882: LD_INT 1
27884: ARRAY
27885: PPUSH
27886: LD_VAR 0 3
27890: PPUSH
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 237
// end ;
27900: PPOPN 6
27902: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
27903: LD_EXP 54
27907: PUSH
27908: LD_EXP 101
27912: AND
27913: IFFALSE 27992
27915: GO 27917
27917: DISABLE
27918: LD_INT 0
27920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
27921: LD_ADDR_VAR 0 1
27925: PUSH
27926: LD_INT 22
27928: PUSH
27929: LD_OWVAR 2
27933: PUSH
27934: EMPTY
27935: LIST
27936: LIST
27937: PUSH
27938: LD_INT 30
27940: PUSH
27941: LD_INT 3
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: EMPTY
27949: LIST
27950: LIST
27951: PPUSH
27952: CALL_OW 69
27956: ST_TO_ADDR
// if not tmp then
27957: LD_VAR 0 1
27961: NOT
27962: IFFALSE 27966
// exit ;
27964: GO 27992
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27966: LD_VAR 0 1
27970: PUSH
27971: LD_INT 1
27973: PPUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 12
27983: ARRAY
27984: PPUSH
27985: LD_INT 1
27987: PPUSH
27988: CALL_OW 234
// end ;
27992: PPOPN 1
27994: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
27995: LD_EXP 54
27999: PUSH
28000: LD_EXP 102
28004: AND
28005: IFFALSE 28117
28007: GO 28009
28009: DISABLE
28010: LD_INT 0
28012: PPUSH
28013: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28014: LD_ADDR_VAR 0 2
28018: PUSH
28019: LD_INT 22
28021: PUSH
28022: LD_OWVAR 2
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 2
28033: PUSH
28034: LD_INT 30
28036: PUSH
28037: LD_INT 27
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 30
28046: PUSH
28047: LD_INT 26
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 30
28056: PUSH
28057: LD_INT 28
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PPUSH
28074: CALL_OW 69
28078: ST_TO_ADDR
// if not tmp then
28079: LD_VAR 0 2
28083: NOT
28084: IFFALSE 28088
// exit ;
28086: GO 28117
// for i in tmp do
28088: LD_ADDR_VAR 0 1
28092: PUSH
28093: LD_VAR 0 2
28097: PUSH
28098: FOR_IN
28099: IFFALSE 28115
// SetLives ( i , 1 ) ;
28101: LD_VAR 0 1
28105: PPUSH
28106: LD_INT 1
28108: PPUSH
28109: CALL_OW 234
28113: GO 28098
28115: POP
28116: POP
// end ;
28117: PPOPN 2
28119: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28120: LD_EXP 54
28124: PUSH
28125: LD_EXP 103
28129: AND
28130: IFFALSE 28404
28132: GO 28134
28134: DISABLE
28135: LD_INT 0
28137: PPUSH
28138: PPUSH
28139: PPUSH
// begin i := rand ( 1 , 7 ) ;
28140: LD_ADDR_VAR 0 1
28144: PUSH
28145: LD_INT 1
28147: PPUSH
28148: LD_INT 7
28150: PPUSH
28151: CALL_OW 12
28155: ST_TO_ADDR
// case i of 1 :
28156: LD_VAR 0 1
28160: PUSH
28161: LD_INT 1
28163: DOUBLE
28164: EQUAL
28165: IFTRUE 28169
28167: GO 28179
28169: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28170: LD_STRING earthquake(getX(game), 0, 32)
28172: PPUSH
28173: CALL_OW 559
28177: GO 28404
28179: LD_INT 2
28181: DOUBLE
28182: EQUAL
28183: IFTRUE 28187
28185: GO 28201
28187: POP
// begin ToLua ( displayStucuk(); ) ;
28188: LD_STRING displayStucuk();
28190: PPUSH
28191: CALL_OW 559
// ResetFog ;
28195: CALL_OW 335
// end ; 3 :
28199: GO 28404
28201: LD_INT 3
28203: DOUBLE
28204: EQUAL
28205: IFTRUE 28209
28207: GO 28313
28209: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28210: LD_ADDR_VAR 0 2
28214: PUSH
28215: LD_INT 22
28217: PUSH
28218: LD_OWVAR 2
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 25
28229: PUSH
28230: LD_INT 1
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PPUSH
28241: CALL_OW 69
28245: ST_TO_ADDR
// if not tmp then
28246: LD_VAR 0 2
28250: NOT
28251: IFFALSE 28255
// exit ;
28253: GO 28404
// un := tmp [ rand ( 1 , tmp ) ] ;
28255: LD_ADDR_VAR 0 3
28259: PUSH
28260: LD_VAR 0 2
28264: PUSH
28265: LD_INT 1
28267: PPUSH
28268: LD_VAR 0 2
28272: PPUSH
28273: CALL_OW 12
28277: ARRAY
28278: ST_TO_ADDR
// if Crawls ( un ) then
28279: LD_VAR 0 3
28283: PPUSH
28284: CALL_OW 318
28288: IFFALSE 28299
// ComWalk ( un ) ;
28290: LD_VAR 0 3
28294: PPUSH
28295: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28299: LD_VAR 0 3
28303: PPUSH
28304: LD_INT 8
28306: PPUSH
28307: CALL_OW 336
// end ; 4 :
28311: GO 28404
28313: LD_INT 4
28315: DOUBLE
28316: EQUAL
28317: IFTRUE 28321
28319: GO 28382
28321: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28322: LD_ADDR_VAR 0 2
28326: PUSH
28327: LD_INT 22
28329: PUSH
28330: LD_OWVAR 2
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: LD_INT 30
28341: PUSH
28342: LD_INT 29
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: EMPTY
28350: LIST
28351: LIST
28352: PPUSH
28353: CALL_OW 69
28357: ST_TO_ADDR
// if not tmp then
28358: LD_VAR 0 2
28362: NOT
28363: IFFALSE 28367
// exit ;
28365: GO 28404
// DestroyUnit ( tmp [ 1 ] ) ;
28367: LD_VAR 0 2
28371: PUSH
28372: LD_INT 1
28374: ARRAY
28375: PPUSH
28376: CALL_OW 65
// end ; 5 .. 7 :
28380: GO 28404
28382: LD_INT 5
28384: DOUBLE
28385: GREATEREQUAL
28386: IFFALSE 28394
28388: LD_INT 7
28390: DOUBLE
28391: LESSEQUAL
28392: IFTRUE 28396
28394: GO 28403
28396: POP
// StreamSibBomb ; end ;
28397: CALL 24684 0 0
28401: GO 28404
28403: POP
// end ;
28404: PPOPN 3
28406: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28407: LD_EXP 54
28411: PUSH
28412: LD_EXP 104
28416: AND
28417: IFFALSE 28573
28419: GO 28421
28421: DISABLE
28422: LD_INT 0
28424: PPUSH
28425: PPUSH
28426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28427: LD_ADDR_VAR 0 2
28431: PUSH
28432: LD_INT 81
28434: PUSH
28435: LD_OWVAR 2
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 2
28446: PUSH
28447: LD_INT 21
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 21
28459: PUSH
28460: LD_INT 2
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: LIST
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PPUSH
28476: CALL_OW 69
28480: ST_TO_ADDR
// if not tmp then
28481: LD_VAR 0 2
28485: NOT
28486: IFFALSE 28490
// exit ;
28488: GO 28573
// p := 0 ;
28490: LD_ADDR_VAR 0 3
28494: PUSH
28495: LD_INT 0
28497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28498: LD_INT 35
28500: PPUSH
28501: CALL_OW 67
// p := p + 1 ;
28505: LD_ADDR_VAR 0 3
28509: PUSH
28510: LD_VAR 0 3
28514: PUSH
28515: LD_INT 1
28517: PLUS
28518: ST_TO_ADDR
// for i in tmp do
28519: LD_ADDR_VAR 0 1
28523: PUSH
28524: LD_VAR 0 2
28528: PUSH
28529: FOR_IN
28530: IFFALSE 28561
// if GetLives ( i ) < 1000 then
28532: LD_VAR 0 1
28536: PPUSH
28537: CALL_OW 256
28541: PUSH
28542: LD_INT 1000
28544: LESS
28545: IFFALSE 28559
// SetLives ( i , 1000 ) ;
28547: LD_VAR 0 1
28551: PPUSH
28552: LD_INT 1000
28554: PPUSH
28555: CALL_OW 234
28559: GO 28529
28561: POP
28562: POP
// until p > 20 ;
28563: LD_VAR 0 3
28567: PUSH
28568: LD_INT 20
28570: GREATER
28571: IFFALSE 28498
// end ;
28573: PPOPN 3
28575: END
// every 0 0$1 trigger StreamModeActive and sTime do
28576: LD_EXP 54
28580: PUSH
28581: LD_EXP 105
28585: AND
28586: IFFALSE 28621
28588: GO 28590
28590: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28591: LD_INT 28
28593: PPUSH
28594: LD_OWVAR 2
28598: PPUSH
28599: LD_INT 2
28601: PPUSH
28602: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28606: LD_INT 30
28608: PPUSH
28609: LD_OWVAR 2
28613: PPUSH
28614: LD_INT 2
28616: PPUSH
28617: CALL_OW 322
// end ;
28621: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28622: LD_EXP 54
28626: PUSH
28627: LD_EXP 106
28631: AND
28632: IFFALSE 28753
28634: GO 28636
28636: DISABLE
28637: LD_INT 0
28639: PPUSH
28640: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28641: LD_ADDR_VAR 0 2
28645: PUSH
28646: LD_INT 22
28648: PUSH
28649: LD_OWVAR 2
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 21
28660: PUSH
28661: LD_INT 1
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 3
28670: PUSH
28671: LD_INT 23
28673: PUSH
28674: LD_INT 0
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: EMPTY
28682: LIST
28683: LIST
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: LIST
28689: PPUSH
28690: CALL_OW 69
28694: ST_TO_ADDR
// if not tmp then
28695: LD_VAR 0 2
28699: NOT
28700: IFFALSE 28704
// exit ;
28702: GO 28753
// for i in tmp do
28704: LD_ADDR_VAR 0 1
28708: PUSH
28709: LD_VAR 0 2
28713: PUSH
28714: FOR_IN
28715: IFFALSE 28751
// begin if Crawls ( i ) then
28717: LD_VAR 0 1
28721: PPUSH
28722: CALL_OW 318
28726: IFFALSE 28737
// ComWalk ( i ) ;
28728: LD_VAR 0 1
28732: PPUSH
28733: CALL_OW 138
// SetClass ( i , 2 ) ;
28737: LD_VAR 0 1
28741: PPUSH
28742: LD_INT 2
28744: PPUSH
28745: CALL_OW 336
// end ;
28749: GO 28714
28751: POP
28752: POP
// end ;
28753: PPOPN 2
28755: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
28756: LD_EXP 54
28760: PUSH
28761: LD_EXP 107
28765: AND
28766: IFFALSE 29047
28768: GO 28770
28770: DISABLE
28771: LD_INT 0
28773: PPUSH
28774: PPUSH
28775: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
28776: LD_OWVAR 2
28780: PPUSH
28781: LD_INT 9
28783: PPUSH
28784: LD_INT 1
28786: PPUSH
28787: LD_INT 1
28789: PPUSH
28790: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
28794: LD_INT 9
28796: PPUSH
28797: LD_OWVAR 2
28801: PPUSH
28802: CALL_OW 343
// uc_side := 9 ;
28806: LD_ADDR_OWVAR 20
28810: PUSH
28811: LD_INT 9
28813: ST_TO_ADDR
// uc_nation := 2 ;
28814: LD_ADDR_OWVAR 21
28818: PUSH
28819: LD_INT 2
28821: ST_TO_ADDR
// hc_name := Dark Warrior ;
28822: LD_ADDR_OWVAR 26
28826: PUSH
28827: LD_STRING Dark Warrior
28829: ST_TO_ADDR
// hc_gallery :=  ;
28830: LD_ADDR_OWVAR 33
28834: PUSH
28835: LD_STRING 
28837: ST_TO_ADDR
// hc_noskilllimit := true ;
28838: LD_ADDR_OWVAR 76
28842: PUSH
28843: LD_INT 1
28845: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
28846: LD_ADDR_OWVAR 31
28850: PUSH
28851: LD_INT 30
28853: PUSH
28854: LD_INT 30
28856: PUSH
28857: LD_INT 30
28859: PUSH
28860: LD_INT 30
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: LIST
28867: LIST
28868: ST_TO_ADDR
// un := CreateHuman ;
28869: LD_ADDR_VAR 0 3
28873: PUSH
28874: CALL_OW 44
28878: ST_TO_ADDR
// hc_noskilllimit := false ;
28879: LD_ADDR_OWVAR 76
28883: PUSH
28884: LD_INT 0
28886: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28887: LD_VAR 0 3
28891: PPUSH
28892: LD_INT 1
28894: PPUSH
28895: CALL_OW 51
// p := 0 ;
28899: LD_ADDR_VAR 0 2
28903: PUSH
28904: LD_INT 0
28906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28907: LD_INT 35
28909: PPUSH
28910: CALL_OW 67
// p := p + 1 ;
28914: LD_ADDR_VAR 0 2
28918: PUSH
28919: LD_VAR 0 2
28923: PUSH
28924: LD_INT 1
28926: PLUS
28927: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
28928: LD_VAR 0 3
28932: PPUSH
28933: CALL_OW 256
28937: PUSH
28938: LD_INT 1000
28940: LESS
28941: IFFALSE 28955
// SetLives ( un , 1000 ) ;
28943: LD_VAR 0 3
28947: PPUSH
28948: LD_INT 1000
28950: PPUSH
28951: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
28955: LD_VAR 0 3
28959: PPUSH
28960: LD_INT 81
28962: PUSH
28963: LD_OWVAR 2
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 91
28974: PUSH
28975: LD_VAR 0 3
28979: PUSH
28980: LD_INT 30
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: LIST
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PPUSH
28992: CALL_OW 69
28996: PPUSH
28997: LD_VAR 0 3
29001: PPUSH
29002: CALL_OW 74
29006: PPUSH
29007: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29011: LD_VAR 0 2
29015: PUSH
29016: LD_INT 60
29018: GREATER
29019: PUSH
29020: LD_VAR 0 3
29024: PPUSH
29025: CALL_OW 301
29029: OR
29030: IFFALSE 28907
// if un then
29032: LD_VAR 0 3
29036: IFFALSE 29047
// RemoveUnit ( un ) ;
29038: LD_VAR 0 3
29042: PPUSH
29043: CALL_OW 64
// end ; end_of_file
29047: PPOPN 3
29049: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29050: LD_INT 0
29052: PPUSH
29053: PPUSH
29054: PPUSH
29055: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29056: LD_VAR 0 1
29060: PPUSH
29061: CALL_OW 264
29065: PUSH
29066: LD_EXP 45
29070: EQUAL
29071: IFFALSE 29143
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29073: LD_INT 68
29075: PPUSH
29076: LD_VAR 0 1
29080: PPUSH
29081: CALL_OW 255
29085: PPUSH
29086: CALL_OW 321
29090: PUSH
29091: LD_INT 2
29093: EQUAL
29094: IFFALSE 29106
// eff := 70 else
29096: LD_ADDR_VAR 0 4
29100: PUSH
29101: LD_INT 70
29103: ST_TO_ADDR
29104: GO 29114
// eff := 30 ;
29106: LD_ADDR_VAR 0 4
29110: PUSH
29111: LD_INT 30
29113: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29114: LD_VAR 0 1
29118: PPUSH
29119: CALL_OW 250
29123: PPUSH
29124: LD_VAR 0 1
29128: PPUSH
29129: CALL_OW 251
29133: PPUSH
29134: LD_VAR 0 4
29138: PPUSH
29139: CALL_OW 495
// end ; end ;
29143: LD_VAR 0 2
29147: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29148: LD_INT 0
29150: PPUSH
// end ;
29151: LD_VAR 0 4
29155: RET
// export function SOS_Command ( cmd ) ; begin
29156: LD_INT 0
29158: PPUSH
// end ;
29159: LD_VAR 0 2
29163: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29164: LD_VAR 0 1
29168: PUSH
29169: LD_INT 255
29171: EQUAL
29172: PUSH
29173: LD_VAR 0 2
29177: PPUSH
29178: CALL_OW 264
29182: PUSH
29183: LD_INT 14
29185: PUSH
29186: LD_INT 53
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: IN
29193: AND
29194: PUSH
29195: LD_VAR 0 4
29199: PPUSH
29200: LD_VAR 0 5
29204: PPUSH
29205: CALL_OW 488
29209: AND
29210: IFFALSE 29234
// CutTreeXYR ( unit , x , y , 12 ) ;
29212: LD_VAR 0 2
29216: PPUSH
29217: LD_VAR 0 4
29221: PPUSH
29222: LD_VAR 0 5
29226: PPUSH
29227: LD_INT 12
29229: PPUSH
29230: CALL 29237 0 4
// end ;
29234: PPOPN 5
29236: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29237: LD_INT 0
29239: PPUSH
29240: PPUSH
29241: PPUSH
29242: PPUSH
29243: PPUSH
29244: PPUSH
29245: PPUSH
29246: PPUSH
29247: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29248: LD_VAR 0 1
29252: NOT
29253: PUSH
29254: LD_VAR 0 2
29258: PPUSH
29259: LD_VAR 0 3
29263: PPUSH
29264: CALL_OW 488
29268: NOT
29269: OR
29270: PUSH
29271: LD_VAR 0 4
29275: NOT
29276: OR
29277: IFFALSE 29281
// exit ;
29279: GO 29621
// list := [ ] ;
29281: LD_ADDR_VAR 0 13
29285: PUSH
29286: EMPTY
29287: ST_TO_ADDR
// if x - r < 0 then
29288: LD_VAR 0 2
29292: PUSH
29293: LD_VAR 0 4
29297: MINUS
29298: PUSH
29299: LD_INT 0
29301: LESS
29302: IFFALSE 29314
// min_x := 0 else
29304: LD_ADDR_VAR 0 7
29308: PUSH
29309: LD_INT 0
29311: ST_TO_ADDR
29312: GO 29330
// min_x := x - r ;
29314: LD_ADDR_VAR 0 7
29318: PUSH
29319: LD_VAR 0 2
29323: PUSH
29324: LD_VAR 0 4
29328: MINUS
29329: ST_TO_ADDR
// if y - r < 0 then
29330: LD_VAR 0 3
29334: PUSH
29335: LD_VAR 0 4
29339: MINUS
29340: PUSH
29341: LD_INT 0
29343: LESS
29344: IFFALSE 29356
// min_y := 0 else
29346: LD_ADDR_VAR 0 8
29350: PUSH
29351: LD_INT 0
29353: ST_TO_ADDR
29354: GO 29372
// min_y := y - r ;
29356: LD_ADDR_VAR 0 8
29360: PUSH
29361: LD_VAR 0 3
29365: PUSH
29366: LD_VAR 0 4
29370: MINUS
29371: ST_TO_ADDR
// max_x := x + r ;
29372: LD_ADDR_VAR 0 9
29376: PUSH
29377: LD_VAR 0 2
29381: PUSH
29382: LD_VAR 0 4
29386: PLUS
29387: ST_TO_ADDR
// max_y := y + r ;
29388: LD_ADDR_VAR 0 10
29392: PUSH
29393: LD_VAR 0 3
29397: PUSH
29398: LD_VAR 0 4
29402: PLUS
29403: ST_TO_ADDR
// for _x = min_x to max_x do
29404: LD_ADDR_VAR 0 11
29408: PUSH
29409: DOUBLE
29410: LD_VAR 0 7
29414: DEC
29415: ST_TO_ADDR
29416: LD_VAR 0 9
29420: PUSH
29421: FOR_TO
29422: IFFALSE 29539
// for _y = min_y to max_y do
29424: LD_ADDR_VAR 0 12
29428: PUSH
29429: DOUBLE
29430: LD_VAR 0 8
29434: DEC
29435: ST_TO_ADDR
29436: LD_VAR 0 10
29440: PUSH
29441: FOR_TO
29442: IFFALSE 29535
// begin if not ValidHex ( _x , _y ) then
29444: LD_VAR 0 11
29448: PPUSH
29449: LD_VAR 0 12
29453: PPUSH
29454: CALL_OW 488
29458: NOT
29459: IFFALSE 29463
// continue ;
29461: GO 29441
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29463: LD_VAR 0 11
29467: PPUSH
29468: LD_VAR 0 12
29472: PPUSH
29473: CALL_OW 351
29477: PUSH
29478: LD_VAR 0 11
29482: PPUSH
29483: LD_VAR 0 12
29487: PPUSH
29488: CALL_OW 554
29492: AND
29493: IFFALSE 29533
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29495: LD_ADDR_VAR 0 13
29499: PUSH
29500: LD_VAR 0 13
29504: PPUSH
29505: LD_VAR 0 13
29509: PUSH
29510: LD_INT 1
29512: PLUS
29513: PPUSH
29514: LD_VAR 0 11
29518: PUSH
29519: LD_VAR 0 12
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PPUSH
29528: CALL_OW 2
29532: ST_TO_ADDR
// end ;
29533: GO 29441
29535: POP
29536: POP
29537: GO 29421
29539: POP
29540: POP
// if not list then
29541: LD_VAR 0 13
29545: NOT
29546: IFFALSE 29550
// exit ;
29548: GO 29621
// for i in list do
29550: LD_ADDR_VAR 0 6
29554: PUSH
29555: LD_VAR 0 13
29559: PUSH
29560: FOR_IN
29561: IFFALSE 29619
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29563: LD_VAR 0 1
29567: PPUSH
29568: LD_STRING M
29570: PUSH
29571: LD_VAR 0 6
29575: PUSH
29576: LD_INT 1
29578: ARRAY
29579: PUSH
29580: LD_VAR 0 6
29584: PUSH
29585: LD_INT 2
29587: ARRAY
29588: PUSH
29589: LD_INT 0
29591: PUSH
29592: LD_INT 0
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: LD_INT 0
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: PUSH
29610: EMPTY
29611: LIST
29612: PPUSH
29613: CALL_OW 447
29617: GO 29560
29619: POP
29620: POP
// end ;
29621: LD_VAR 0 5
29625: RET
