// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 217 0 0
// PrepareNature ;
  23: CALL 392 0 0
// PrepareRussian ;
  27: CALL 13362 0 0
// PrepareAmerican ;
  31: CALL 1125 0 0
// PrepareOvsyenko ;
  35: CALL 1748 0 0
// Action ;
  39: CALL 2688 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// function DebugMode ; begin
 217: LD_INT 0
 219: PPUSH
// if not debug then
 220: LD_EXP 2
 224: NOT
 225: IFFALSE 229
// exit ;
 227: GO 236
// FogOff ( 1 ) ;
 229: LD_INT 1
 231: PPUSH
 232: CALL_OW 344
// end ; end_of_file
 236: LD_VAR 0 1
 240: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 241: LD_INT 0
 243: PPUSH
 244: PPUSH
// if exist_mode then
 245: LD_VAR 0 2
 249: IFFALSE 274
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 251: LD_ADDR_VAR 0 5
 255: PUSH
 256: LD_VAR 0 3
 260: PUSH
 261: LD_VAR 0 1
 265: STR
 266: PPUSH
 267: CALL_OW 34
 271: ST_TO_ADDR
 272: GO 289
// unit := NewCharacter ( ident ) ;
 274: LD_ADDR_VAR 0 5
 278: PUSH
 279: LD_VAR 0 1
 283: PPUSH
 284: CALL_OW 25
 288: ST_TO_ADDR
// result := unit ;
 289: LD_ADDR_VAR 0 4
 293: PUSH
 294: LD_VAR 0 5
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 4
 303: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 304: LD_INT 0
 306: PPUSH
// uc_side := side ;
 307: LD_ADDR_OWVAR 20
 311: PUSH
 312: LD_VAR 0 1
 316: ST_TO_ADDR
// uc_nation := nation ;
 317: LD_ADDR_OWVAR 21
 321: PUSH
 322: LD_VAR 0 2
 326: ST_TO_ADDR
// vc_chassis := chassis ;
 327: LD_ADDR_OWVAR 37
 331: PUSH
 332: LD_VAR 0 3
 336: ST_TO_ADDR
// vc_engine := engine ;
 337: LD_ADDR_OWVAR 39
 341: PUSH
 342: LD_VAR 0 4
 346: ST_TO_ADDR
// vc_control := control ;
 347: LD_ADDR_OWVAR 38
 351: PUSH
 352: LD_VAR 0 5
 356: ST_TO_ADDR
// vc_weapon := weapon ;
 357: LD_ADDR_OWVAR 40
 361: PUSH
 362: LD_VAR 0 6
 366: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 367: LD_ADDR_OWVAR 41
 371: PUSH
 372: LD_VAR 0 7
 376: ST_TO_ADDR
// result := CreateVehicle ;
 377: LD_ADDR_VAR 0 8
 381: PUSH
 382: CALL_OW 45
 386: ST_TO_ADDR
// end ;
 387: LD_VAR 0 8
 391: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 392: LD_INT 0
 394: PPUSH
 395: PPUSH
 396: PPUSH
 397: PPUSH
// uc_side = 0 ;
 398: LD_ADDR_OWVAR 20
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// uc_nation = 0 ;
 406: LD_ADDR_OWVAR 21
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// nat_area := natureArea ;
 414: LD_ADDR_VAR 0 4
 418: PUSH
 419: LD_INT 1
 421: ST_TO_ADDR
// InitHc ;
 422: CALL_OW 19
// for i = 1 to 4 do
 426: LD_ADDR_VAR 0 2
 430: PUSH
 431: DOUBLE
 432: LD_INT 1
 434: DEC
 435: ST_TO_ADDR
 436: LD_INT 4
 438: PUSH
 439: FOR_TO
 440: IFFALSE 495
// begin hc_class = 18 ;
 442: LD_ADDR_OWVAR 28
 446: PUSH
 447: LD_INT 18
 449: ST_TO_ADDR
// hc_gallery =  ;
 450: LD_ADDR_OWVAR 33
 454: PUSH
 455: LD_STRING 
 457: ST_TO_ADDR
// hc_face_number = 1 ;
 458: LD_ADDR_OWVAR 34
 462: PUSH
 463: LD_INT 1
 465: ST_TO_ADDR
// animal := CreateHuman ;
 466: LD_ADDR_VAR 0 3
 470: PUSH
 471: CALL_OW 44
 475: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 476: LD_VAR 0 3
 480: PPUSH
 481: LD_VAR 0 4
 485: PPUSH
 486: LD_INT 0
 488: PPUSH
 489: CALL_OW 49
// end ;
 493: GO 439
 495: POP
 496: POP
// for i = 1 to 4 do
 497: LD_ADDR_VAR 0 2
 501: PUSH
 502: DOUBLE
 503: LD_INT 1
 505: DEC
 506: ST_TO_ADDR
 507: LD_INT 4
 509: PUSH
 510: FOR_TO
 511: IFFALSE 583
// begin hc_class = class_tiger ;
 513: LD_ADDR_OWVAR 28
 517: PUSH
 518: LD_INT 14
 520: ST_TO_ADDR
// hc_gallery =  ;
 521: LD_ADDR_OWVAR 33
 525: PUSH
 526: LD_STRING 
 528: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 529: LD_ADDR_OWVAR 35
 533: PUSH
 534: LD_INT 5
 536: NEG
 537: PPUSH
 538: LD_INT 5
 540: PPUSH
 541: CALL_OW 12
 545: ST_TO_ADDR
// hc_face_number = 3 ;
 546: LD_ADDR_OWVAR 34
 550: PUSH
 551: LD_INT 3
 553: ST_TO_ADDR
// animal := CreateHuman ;
 554: LD_ADDR_VAR 0 3
 558: PUSH
 559: CALL_OW 44
 563: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 564: LD_VAR 0 3
 568: PPUSH
 569: LD_VAR 0 4
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 510
 583: POP
 584: POP
// for i = 1 to 8 do
 585: LD_ADDR_VAR 0 2
 589: PUSH
 590: DOUBLE
 591: LD_INT 1
 593: DEC
 594: ST_TO_ADDR
 595: LD_INT 8
 597: PUSH
 598: FOR_TO
 599: IFFALSE 702
// begin hc_class = class_apeman ;
 601: LD_ADDR_OWVAR 28
 605: PUSH
 606: LD_INT 12
 608: ST_TO_ADDR
// hc_gallery =  ;
 609: LD_ADDR_OWVAR 33
 613: PUSH
 614: LD_STRING 
 616: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 617: LD_ADDR_OWVAR 35
 621: PUSH
 622: LD_INT 2
 624: NEG
 625: PPUSH
 626: LD_INT 2
 628: PPUSH
 629: CALL_OW 12
 633: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 634: LD_ADDR_OWVAR 31
 638: PUSH
 639: LD_INT 1
 641: PPUSH
 642: LD_INT 3
 644: PPUSH
 645: CALL_OW 12
 649: PUSH
 650: LD_INT 1
 652: PPUSH
 653: LD_INT 3
 655: PPUSH
 656: CALL_OW 12
 660: PUSH
 661: LD_INT 0
 663: PUSH
 664: LD_INT 0
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: LIST
 671: LIST
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 598
 702: POP
 703: POP
// for i = 1 to 6 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 6
 716: PUSH
 717: FOR_TO
 718: IFFALSE 773
// begin hc_class = 13 ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 13
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_face_number = 4 ;
 736: LD_ADDR_OWVAR 34
 740: PUSH
 741: LD_INT 4
 743: ST_TO_ADDR
// animal := CreateHuman ;
 744: LD_ADDR_VAR 0 3
 748: PUSH
 749: CALL_OW 44
 753: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 754: LD_VAR 0 3
 758: PPUSH
 759: LD_VAR 0 4
 763: PPUSH
 764: LD_INT 0
 766: PPUSH
 767: CALL_OW 49
// end ;
 771: GO 717
 773: POP
 774: POP
// vc_chassis := 31 ;
 775: LD_ADDR_OWVAR 37
 779: PUSH
 780: LD_INT 31
 782: ST_TO_ADDR
// vc_control := control_rider ;
 783: LD_ADDR_OWVAR 38
 787: PUSH
 788: LD_INT 4
 790: ST_TO_ADDR
// animal := CreateVehicle ;
 791: LD_ADDR_VAR 0 3
 795: PUSH
 796: CALL_OW 45
 800: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 801: LD_VAR 0 3
 805: PPUSH
 806: LD_INT 21
 808: PPUSH
 809: LD_INT 22
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 48
// end ;
 819: LD_VAR 0 1
 823: RET
// export function GetTerminalCargo ; begin
 824: LD_INT 0
 826: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 827: LD_ADDR_VAR 0 1
 831: PUSH
 832: LD_EXP 3
 836: PPUSH
 837: CALL_OW 274
 841: PPUSH
 842: LD_INT 3
 844: PPUSH
 845: CALL_OW 275
 849: ST_TO_ADDR
// end ;
 850: LD_VAR 0 1
 854: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 855: LD_INT 0
 857: PPUSH
 858: PPUSH
 859: PPUSH
// result := 0 ;
 860: LD_ADDR_VAR 0 2
 864: PUSH
 865: LD_INT 0
 867: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 868: LD_ADDR_VAR 0 4
 872: PUSH
 873: LD_INT 22
 875: PUSH
 876: LD_VAR 0 1
 880: PUSH
 881: EMPTY
 882: LIST
 883: LIST
 884: PUSH
 885: LD_INT 2
 887: PUSH
 888: LD_INT 30
 890: PUSH
 891: LD_INT 0
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 30
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PUSH
 908: EMPTY
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL_OW 69
 921: ST_TO_ADDR
// if not tmp then
 922: LD_VAR 0 4
 926: NOT
 927: IFFALSE 931
// exit ;
 929: GO 977
// for i in tmp do
 931: LD_ADDR_VAR 0 3
 935: PUSH
 936: LD_VAR 0 4
 940: PUSH
 941: FOR_IN
 942: IFFALSE 975
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 944: LD_ADDR_VAR 0 2
 948: PUSH
 949: LD_VAR 0 2
 953: PUSH
 954: LD_VAR 0 3
 958: PPUSH
 959: CALL_OW 274
 963: PPUSH
 964: LD_INT 3
 966: PPUSH
 967: CALL_OW 275
 971: PLUS
 972: ST_TO_ADDR
 973: GO 941
 975: POP
 976: POP
// end ;
 977: LD_VAR 0 2
 981: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 982: LD_INT 0
 984: PPUSH
 985: PPUSH
// area = ListEnvironmentArea ( area ) ;
 986: LD_ADDR_VAR 0 2
 990: PUSH
 991: LD_VAR 0 2
 995: PPUSH
 996: CALL_OW 353
1000: ST_TO_ADDR
// if bulldozer > 0 then
1001: LD_VAR 0 1
1005: PUSH
1006: LD_INT 0
1008: GREATER
1009: IFFALSE 1120
// for i = area downto 1 do
1011: LD_ADDR_VAR 0 4
1015: PUSH
1016: DOUBLE
1017: LD_VAR 0 2
1021: INC
1022: ST_TO_ADDR
1023: LD_INT 1
1025: PUSH
1026: FOR_DOWNTO
1027: IFFALSE 1118
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1029: LD_VAR 0 2
1033: PUSH
1034: LD_VAR 0 4
1038: ARRAY
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_VAR 0 4
1053: ARRAY
1054: PUSH
1055: LD_INT 2
1057: ARRAY
1058: PPUSH
1059: CALL_OW 351
1063: IFFALSE 1116
// if not HasTask ( bulldozer ) then
1065: LD_VAR 0 1
1069: PPUSH
1070: CALL_OW 314
1074: NOT
1075: IFFALSE 1116
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1077: LD_VAR 0 1
1081: PPUSH
1082: LD_VAR 0 2
1086: PUSH
1087: LD_VAR 0 4
1091: ARRAY
1092: PUSH
1093: LD_INT 1
1095: ARRAY
1096: PPUSH
1097: LD_VAR 0 2
1101: PUSH
1102: LD_VAR 0 4
1106: ARRAY
1107: PUSH
1108: LD_INT 2
1110: ARRAY
1111: PPUSH
1112: CALL_OW 171
1116: GO 1026
1118: POP
1119: POP
// end ; end_of_file
1120: LD_VAR 0 3
1124: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1125: LD_INT 0
1127: PPUSH
1128: PPUSH
1129: PPUSH
1130: PPUSH
1131: PPUSH
// uc_side := 1 ;
1132: LD_ADDR_OWVAR 20
1136: PUSH
1137: LD_INT 1
1139: ST_TO_ADDR
// uc_nation := 1 ;
1140: LD_ADDR_OWVAR 21
1144: PUSH
1145: LD_INT 1
1147: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1148: LD_ADDR_EXP 20
1152: PUSH
1153: LD_STRING JMM
1155: PPUSH
1156: LD_EXP 2
1160: NOT
1161: PPUSH
1162: LD_STRING 08_
1164: PPUSH
1165: CALL 241 0 3
1169: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1170: LD_ADDR_VAR 0 4
1174: PUSH
1175: LD_INT 1
1177: PPUSH
1178: LD_INT 1
1180: PPUSH
1181: LD_INT 3
1183: PPUSH
1184: LD_INT 2
1186: PPUSH
1187: LD_INT 1
1189: PPUSH
1190: LD_INT 5
1192: PPUSH
1193: LD_INT 55
1195: PPUSH
1196: CALL 304 0 7
1200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1201: LD_VAR 0 4
1205: PPUSH
1206: LD_INT 3
1208: PPUSH
1209: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1213: LD_VAR 0 4
1217: PPUSH
1218: LD_INT 43
1220: PPUSH
1221: LD_INT 3
1223: PPUSH
1224: LD_INT 0
1226: PPUSH
1227: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1231: LD_EXP 20
1235: PPUSH
1236: LD_VAR 0 4
1240: PPUSH
1241: CALL_OW 52
// tmp := [ ] ;
1245: LD_ADDR_VAR 0 2
1249: PUSH
1250: EMPTY
1251: ST_TO_ADDR
// uc_side := 4 ;
1252: LD_ADDR_OWVAR 20
1256: PUSH
1257: LD_INT 4
1259: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1260: LD_ADDR_OWVAR 33
1264: PUSH
1265: LD_STRING SecondCharsGal
1267: ST_TO_ADDR
// hc_class := 2 ;
1268: LD_ADDR_OWVAR 28
1272: PUSH
1273: LD_INT 2
1275: ST_TO_ADDR
// hc_sex := sex_female ;
1276: LD_ADDR_OWVAR 27
1280: PUSH
1281: LD_INT 2
1283: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1284: LD_ADDR_OWVAR 30
1288: PUSH
1289: LD_INT 0
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 0
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: LIST
1305: LIST
1306: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1307: LD_ADDR_OWVAR 31
1311: PUSH
1312: LD_INT 3
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: LD_INT 2
1320: PUSH
1321: LD_INT 1
1323: PUSH
1324: EMPTY
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1330: LD_ADDR_OWVAR 29
1334: PUSH
1335: LD_INT 10
1337: PUSH
1338: LD_INT 11
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1345: LD_ADDR_OWVAR 26
1349: PUSH
1350: LD_STRING Naoma Goichman
1352: ST_TO_ADDR
// hc_face_number := 43 ;
1353: LD_ADDR_OWVAR 34
1357: PUSH
1358: LD_INT 43
1360: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1361: LD_ADDR_VAR 0 2
1365: PUSH
1366: LD_VAR 0 2
1370: PUSH
1371: CALL_OW 44
1375: ADD
1376: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1377: LD_ADDR_OWVAR 30
1381: PUSH
1382: LD_INT 0
1384: PUSH
1385: LD_INT 2
1387: PUSH
1388: LD_INT 0
1390: PUSH
1391: LD_INT 1
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1400: LD_ADDR_OWVAR 31
1404: PUSH
1405: LD_INT 0
1407: PUSH
1408: LD_INT 5
1410: PUSH
1411: LD_INT 3
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1423: LD_ADDR_OWVAR 29
1427: PUSH
1428: LD_INT 10
1430: PUSH
1431: LD_INT 10
1433: PUSH
1434: EMPTY
1435: LIST
1436: LIST
1437: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1438: LD_ADDR_OWVAR 26
1442: PUSH
1443: LD_STRING Magdalene Glance
1445: ST_TO_ADDR
// hc_face_number := 44 ;
1446: LD_ADDR_OWVAR 34
1450: PUSH
1451: LD_INT 44
1453: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: LD_VAR 0 2
1463: PUSH
1464: CALL_OW 44
1468: ADD
1469: ST_TO_ADDR
// hc_sex := sex_male ;
1470: LD_ADDR_OWVAR 27
1474: PUSH
1475: LD_INT 1
1477: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1478: LD_ADDR_OWVAR 30
1482: PUSH
1483: LD_INT 2
1485: PUSH
1486: LD_INT 2
1488: PUSH
1489: LD_INT 0
1491: PUSH
1492: LD_INT 0
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1501: LD_ADDR_OWVAR 31
1505: PUSH
1506: LD_INT 3
1508: PUSH
1509: LD_INT 4
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 0
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1524: LD_ADDR_OWVAR 29
1528: PUSH
1529: LD_INT 12
1531: PUSH
1532: LD_INT 10
1534: PUSH
1535: EMPTY
1536: LIST
1537: LIST
1538: ST_TO_ADDR
// hc_name := Steve Holland ;
1539: LD_ADDR_OWVAR 26
1543: PUSH
1544: LD_STRING Steve Holland
1546: ST_TO_ADDR
// hc_face_number := 60 ;
1547: LD_ADDR_OWVAR 34
1551: PUSH
1552: LD_INT 60
1554: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1555: LD_ADDR_VAR 0 2
1559: PUSH
1560: LD_VAR 0 2
1564: PUSH
1565: CALL_OW 44
1569: ADD
1570: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1571: LD_ADDR_EXP 25
1575: PUSH
1576: LD_VAR 0 2
1580: PUSH
1581: LD_INT 0
1583: DIFF
1584: ST_TO_ADDR
// for un in alpha_engs do
1585: LD_ADDR_VAR 0 3
1589: PUSH
1590: LD_EXP 25
1594: PUSH
1595: FOR_IN
1596: IFFALSE 1621
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1598: LD_VAR 0 3
1602: PPUSH
1603: LD_INT 52
1605: PPUSH
1606: LD_INT 35
1608: PPUSH
1609: LD_INT 3
1611: PPUSH
1612: LD_INT 0
1614: PPUSH
1615: CALL_OW 50
1619: GO 1595
1621: POP
1622: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_INT 1
1635: PUSH
1636: LD_STRING 06_crates_1
1638: PPUSH
1639: LD_INT 0
1641: PPUSH
1642: CALL_OW 30
1646: PLUS
1647: PUSH
1648: LD_INT 2
1650: MUL
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1679
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1655: LD_INT 1
1657: PPUSH
1658: LD_INT 5
1660: PPUSH
1661: LD_INT 56
1663: PPUSH
1664: LD_INT 40
1666: PPUSH
1667: LD_INT 2
1669: PPUSH
1670: LD_INT 0
1672: PPUSH
1673: CALL_OW 60
1677: GO 1652
1679: POP
1680: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1681: LD_STRING GammaCommander
1683: PPUSH
1684: LD_INT 0
1686: PPUSH
1687: CALL_OW 30
1691: PUSH
1692: LD_INT 3
1694: LESS
1695: IFFALSE 1716
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1697: LD_ADDR_EXP 24
1701: PUSH
1702: LD_STRING VanHouten
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: LD_STRING 
1710: PPUSH
1711: CALL 241 0 3
1715: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1716: LD_ADDR_EXP 27
1720: PUSH
1721: LD_STRING Powell
1723: PPUSH
1724: LD_INT 0
1726: PPUSH
1727: LD_STRING 
1729: PPUSH
1730: CALL 241 0 3
1734: ST_TO_ADDR
// InitHc ;
1735: CALL_OW 19
// InitUc ;
1739: CALL_OW 18
// end ;
1743: LD_VAR 0 1
1747: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1748: LD_INT 0
1750: PPUSH
1751: PPUSH
1752: PPUSH
1753: PPUSH
1754: PPUSH
// uc_side := 4 ;
1755: LD_ADDR_OWVAR 20
1759: PUSH
1760: LD_INT 4
1762: ST_TO_ADDR
// uc_nation := 3 ;
1763: LD_ADDR_OWVAR 21
1767: PUSH
1768: LD_INT 3
1770: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1771: LD_ADDR_VAR 0 4
1775: PUSH
1776: LD_STRING 09_ovsyenko_base
1778: PPUSH
1779: LD_INT 0
1781: PUSH
1782: LD_INT 101
1784: PUSH
1785: LD_INT 118
1787: PUSH
1788: LD_INT 2
1790: PUSH
1791: LD_INT 500
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: PUSH
1801: LD_INT 31
1803: PUSH
1804: LD_INT 109
1806: PUSH
1807: LD_INT 114
1809: PUSH
1810: LD_INT 4
1812: PUSH
1813: LD_INT 500
1815: PUSH
1816: EMPTY
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 31
1825: PUSH
1826: LD_INT 115
1828: PUSH
1829: LD_INT 132
1831: PUSH
1832: LD_INT 5
1834: PUSH
1835: LD_INT 500
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PUSH
1845: LD_INT 31
1847: PUSH
1848: LD_INT 98
1850: PUSH
1851: LD_INT 120
1853: PUSH
1854: LD_INT 1
1856: PUSH
1857: LD_INT 500
1859: PUSH
1860: EMPTY
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL_OW 30
1877: ST_TO_ADDR
// for i in tmp do
1878: LD_ADDR_VAR 0 2
1882: PUSH
1883: LD_VAR 0 4
1887: PUSH
1888: FOR_IN
1889: IFFALSE 2045
// begin bc_type := i [ 1 ] ;
1891: LD_ADDR_OWVAR 42
1895: PUSH
1896: LD_VAR 0 2
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: ST_TO_ADDR
// bc_level := 3 ;
1905: LD_ADDR_OWVAR 43
1909: PUSH
1910: LD_INT 3
1912: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1913: LD_ADDR_VAR 0 3
1917: PUSH
1918: LD_VAR 0 2
1922: PUSH
1923: LD_INT 2
1925: ARRAY
1926: PPUSH
1927: LD_VAR 0 2
1931: PUSH
1932: LD_INT 3
1934: ARRAY
1935: PPUSH
1936: LD_VAR 0 2
1940: PUSH
1941: LD_INT 4
1943: ARRAY
1944: PPUSH
1945: CALL_OW 47
1949: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 266
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1997
// begin SetBName ( b , ovsyenko ) ;
1965: LD_VAR 0 3
1969: PPUSH
1970: LD_STRING ovsyenko
1972: PPUSH
1973: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1977: LD_VAR 0 3
1981: PPUSH
1982: CALL_OW 274
1986: PPUSH
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 50
1992: PPUSH
1993: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1997: LD_VAR 0 2
2001: PUSH
2002: LD_INT 5
2004: ARRAY
2005: PUSH
2006: LD_INT 250
2008: LESS
2009: IFFALSE 2025
// SetLives ( b , 333 ) else
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 333
2018: PPUSH
2019: CALL_OW 234
2023: GO 2043
// SetLives ( b , i [ 5 ] ) ;
2025: LD_VAR 0 3
2029: PPUSH
2030: LD_VAR 0 2
2034: PUSH
2035: LD_INT 5
2037: ARRAY
2038: PPUSH
2039: CALL_OW 234
// end ;
2043: GO 1888
2045: POP
2046: POP
// uc_nation := 1 ;
2047: LD_ADDR_OWVAR 21
2051: PUSH
2052: LD_INT 1
2054: ST_TO_ADDR
// tmp := [ ] ;
2055: LD_ADDR_VAR 0 4
2059: PUSH
2060: EMPTY
2061: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2062: LD_ADDR_EXP 21
2066: PUSH
2067: LD_STRING Gary
2069: PPUSH
2070: LD_EXP 2
2074: NOT
2075: PPUSH
2076: LD_STRING 
2078: PPUSH
2079: CALL 241 0 3
2083: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2084: LD_ADDR_VAR 0 4
2088: PUSH
2089: LD_VAR 0 4
2093: PUSH
2094: LD_EXP 21
2098: ADD
2099: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2100: LD_ADDR_EXP 22
2104: PUSH
2105: LD_STRING Bobby
2107: PPUSH
2108: LD_EXP 2
2112: NOT
2113: PPUSH
2114: LD_STRING 08_
2116: PPUSH
2117: CALL 241 0 3
2121: ST_TO_ADDR
// if not Bobby then
2122: LD_EXP 22
2126: NOT
2127: IFFALSE 2151
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2129: LD_ADDR_EXP 22
2133: PUSH
2134: LD_STRING Bobby
2136: PPUSH
2137: LD_EXP 2
2141: NOT
2142: PPUSH
2143: LD_STRING 03_
2145: PPUSH
2146: CALL 241 0 3
2150: ST_TO_ADDR
// if Bobby then
2151: LD_EXP 22
2155: IFFALSE 2173
// tmp := tmp ^ Bobby ;
2157: LD_ADDR_VAR 0 4
2161: PUSH
2162: LD_VAR 0 4
2166: PUSH
2167: LD_EXP 22
2171: ADD
2172: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2173: LD_ADDR_EXP 23
2177: PUSH
2178: LD_STRING Cyrus
2180: PPUSH
2181: LD_EXP 2
2185: NOT
2186: PPUSH
2187: LD_STRING 08_
2189: PPUSH
2190: CALL 241 0 3
2194: ST_TO_ADDR
// if not Cyrus then
2195: LD_EXP 23
2199: NOT
2200: IFFALSE 2224
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2202: LD_ADDR_EXP 23
2206: PUSH
2207: LD_STRING Cyrus
2209: PPUSH
2210: LD_EXP 2
2214: NOT
2215: PPUSH
2216: LD_STRING 03_
2218: PPUSH
2219: CALL 241 0 3
2223: ST_TO_ADDR
// if Cyrus then
2224: LD_EXP 23
2228: IFFALSE 2246
// tmp := tmp ^ Cyrus ;
2230: LD_ADDR_VAR 0 4
2234: PUSH
2235: LD_VAR 0 4
2239: PUSH
2240: LD_EXP 23
2244: ADD
2245: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2246: LD_ADDR_VAR 0 4
2250: PUSH
2251: LD_VAR 0 4
2255: PUSH
2256: LD_STRING 09_prev_squad
2258: PPUSH
2259: CALL_OW 31
2263: ADD
2264: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2265: LD_STRING 09_prev_squad
2267: PPUSH
2268: CALL_OW 40
// tmp := tmp diff 0 ;
2272: LD_ADDR_VAR 0 4
2276: PUSH
2277: LD_VAR 0 4
2281: PUSH
2282: LD_INT 0
2284: DIFF
2285: ST_TO_ADDR
// if debug then
2286: LD_EXP 2
2290: IFFALSE 2341
// begin for i = 1 to 6 do
2292: LD_ADDR_VAR 0 2
2296: PUSH
2297: DOUBLE
2298: LD_INT 1
2300: DEC
2301: ST_TO_ADDR
2302: LD_INT 6
2304: PUSH
2305: FOR_TO
2306: IFFALSE 2339
// begin PrepareHuman ( false , 1 , 6 ) ;
2308: LD_INT 0
2310: PPUSH
2311: LD_INT 1
2313: PPUSH
2314: LD_INT 6
2316: PPUSH
2317: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2321: LD_ADDR_VAR 0 4
2325: PUSH
2326: LD_VAR 0 4
2330: PUSH
2331: CALL_OW 44
2335: ADD
2336: ST_TO_ADDR
// end ;
2337: GO 2305
2339: POP
2340: POP
// end ; for i in tmp do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: LD_VAR 0 4
2350: PUSH
2351: FOR_IN
2352: IFFALSE 2411
// begin if GetClass ( i ) in [ 2 , 3 ] then
2354: LD_VAR 0 2
2358: PPUSH
2359: CALL_OW 257
2363: PUSH
2364: LD_INT 2
2366: PUSH
2367: LD_INT 3
2369: PUSH
2370: EMPTY
2371: LIST
2372: LIST
2373: IN
2374: IFFALSE 2388
// SetClass ( i , 1 ) ;
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 1
2383: PPUSH
2384: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2388: LD_VAR 0 2
2392: PPUSH
2393: LD_INT 106
2395: PPUSH
2396: LD_INT 122
2398: PPUSH
2399: LD_INT 5
2401: PPUSH
2402: LD_INT 0
2404: PPUSH
2405: CALL_OW 50
// end ;
2409: GO 2351
2411: POP
2412: POP
// tmp := tmp diff Gary ;
2413: LD_ADDR_VAR 0 4
2417: PUSH
2418: LD_VAR 0 4
2422: PUSH
2423: LD_EXP 21
2427: DIFF
2428: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2429: LD_ADDR_VAR 0 3
2433: PUSH
2434: LD_INT 22
2436: PUSH
2437: LD_INT 4
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 30
2446: PUSH
2447: LD_INT 31
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PPUSH
2458: CALL_OW 69
2462: ST_TO_ADDR
// for i = 1 to b do
2463: LD_ADDR_VAR 0 2
2467: PUSH
2468: DOUBLE
2469: LD_INT 1
2471: DEC
2472: ST_TO_ADDR
2473: LD_VAR 0 3
2477: PUSH
2478: FOR_TO
2479: IFFALSE 2509
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2481: LD_VAR 0 4
2485: PUSH
2486: LD_VAR 0 2
2490: ARRAY
2491: PPUSH
2492: LD_VAR 0 3
2496: PUSH
2497: LD_VAR 0 2
2501: ARRAY
2502: PPUSH
2503: CALL_OW 120
// end ;
2507: GO 2478
2509: POP
2510: POP
// InitHc ;
2511: CALL_OW 19
// InitUc ;
2515: CALL_OW 18
// end ;
2519: LD_VAR 0 1
2523: RET
// export function PowellTransport ; var i , un ; begin
2524: LD_INT 0
2526: PPUSH
2527: PPUSH
2528: PPUSH
// uc_side := 4 ;
2529: LD_ADDR_OWVAR 20
2533: PUSH
2534: LD_INT 4
2536: ST_TO_ADDR
// uc_nation := 1 ;
2537: LD_ADDR_OWVAR 21
2541: PUSH
2542: LD_INT 1
2544: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2545: LD_INT 1
2547: PPUSH
2548: LD_INT 3
2550: PPUSH
2551: LD_INT 6
2553: PPUSH
2554: CALL_OW 380
// hc_name :=  ;
2558: LD_ADDR_OWVAR 26
2562: PUSH
2563: LD_STRING 
2565: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2566: LD_ADDR_OWVAR 33
2570: PUSH
2571: LD_STRING SecondCharsGal
2573: ST_TO_ADDR
// hc_face_number := 30 ;
2574: LD_ADDR_OWVAR 34
2578: PUSH
2579: LD_INT 30
2581: ST_TO_ADDR
// powell_trans := CreateHuman ;
2582: LD_ADDR_EXP 26
2586: PUSH
2587: CALL_OW 44
2591: ST_TO_ADDR
// hc_face_number := 31 ;
2592: LD_ADDR_OWVAR 34
2596: PUSH
2597: LD_INT 31
2599: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2600: LD_ADDR_EXP 26
2604: PUSH
2605: LD_EXP 26
2609: PUSH
2610: CALL_OW 44
2614: ADD
2615: ST_TO_ADDR
// for i = 1 to 2 do
2616: LD_ADDR_VAR 0 2
2620: PUSH
2621: DOUBLE
2622: LD_INT 1
2624: DEC
2625: ST_TO_ADDR
2626: LD_INT 2
2628: PUSH
2629: FOR_TO
2630: IFFALSE 2681
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2632: LD_ADDR_VAR 0 3
2636: PUSH
2637: LD_INT 4
2639: PPUSH
2640: LD_INT 1
2642: PPUSH
2643: LD_INT 3
2645: PPUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 1
2651: PPUSH
2652: LD_INT 12
2654: PPUSH
2655: LD_INT 66
2657: PPUSH
2658: CALL 304 0 7
2662: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2663: LD_ADDR_EXP 26
2667: PUSH
2668: LD_EXP 26
2672: PUSH
2673: LD_VAR 0 3
2677: ADD
2678: ST_TO_ADDR
// end ;
2679: GO 2629
2681: POP
2682: POP
// end ; end_of_file
2683: LD_VAR 0 1
2687: RET
// export function Action ; var i , veh ; begin
2688: LD_INT 0
2690: PPUSH
2691: PPUSH
2692: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2693: LD_EXP 25
2697: PPUSH
2698: LD_INT 0
2700: PPUSH
2701: LD_INT 50
2703: PPUSH
2704: LD_INT 38
2706: PPUSH
2707: LD_INT 2
2709: PPUSH
2710: CALL_OW 145
// InGameOn ;
2714: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2718: LD_INT 43
2720: PPUSH
2721: LD_INT 9
2723: PPUSH
2724: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2728: LD_EXP 20
2732: PPUSH
2733: LD_INT 54
2735: PPUSH
2736: LD_INT 34
2738: PPUSH
2739: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2743: LD_EXP 20
2747: PPUSH
2748: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2752: LD_EXP 20
2756: PPUSH
2757: LD_EXP 25
2761: PUSH
2762: LD_INT 1
2764: ARRAY
2765: PPUSH
2766: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2770: LD_INT 35
2772: PPUSH
2773: CALL_OW 67
// until See ( 4 , JMM ) ;
2777: LD_INT 4
2779: PPUSH
2780: LD_EXP 20
2784: PPUSH
2785: CALL_OW 292
2789: IFFALSE 2770
// CenterNowOnUnits ( JMM ) ;
2791: LD_EXP 20
2795: PPUSH
2796: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2800: LD_EXP 20
2804: PPUSH
2805: LD_STRING D2-JMM-1
2807: PPUSH
2808: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2812: LD_EXP 25
2816: PUSH
2817: LD_INT 3
2819: ARRAY
2820: PPUSH
2821: LD_EXP 20
2825: PPUSH
2826: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2830: LD_EXP 25
2834: PUSH
2835: LD_INT 3
2837: ARRAY
2838: PPUSH
2839: LD_STRING D2-Eng1-1
2841: PPUSH
2842: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2846: LD_EXP 20
2850: PPUSH
2851: LD_STRING D2-JMM-2
2853: PPUSH
2854: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2858: LD_EXP 25
2862: PUSH
2863: LD_INT 3
2865: ARRAY
2866: PPUSH
2867: LD_STRING D2-Eng1-2
2869: PPUSH
2870: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2874: LD_EXP 20
2878: PPUSH
2879: LD_STRING D2-JMM-3
2881: PPUSH
2882: CALL_OW 88
// if Houten then
2886: LD_EXP 24
2890: IFFALSE 3088
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2892: LD_ADDR_VAR 0 3
2896: PUSH
2897: LD_INT 4
2899: PPUSH
2900: LD_INT 1
2902: PPUSH
2903: LD_INT 3
2905: PPUSH
2906: LD_INT 2
2908: PPUSH
2909: LD_INT 1
2911: PPUSH
2912: LD_INT 4
2914: PPUSH
2915: LD_INT 55
2917: PPUSH
2918: CALL 304 0 7
2922: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2923: LD_VAR 0 3
2927: PPUSH
2928: LD_INT 3
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2935: LD_VAR 0 3
2939: PPUSH
2940: LD_INT 46
2942: PPUSH
2943: LD_INT 19
2945: PPUSH
2946: LD_INT 0
2948: PPUSH
2949: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2953: LD_EXP 24
2957: PPUSH
2958: LD_VAR 0 3
2962: PPUSH
2963: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2967: LD_EXP 24
2971: PPUSH
2972: LD_INT 49
2974: PPUSH
2975: LD_INT 33
2977: PPUSH
2978: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2982: LD_EXP 24
2986: PPUSH
2987: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2991: LD_EXP 24
2995: PPUSH
2996: LD_EXP 20
3000: PPUSH
3001: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3005: LD_INT 35
3007: PPUSH
3008: CALL_OW 67
// until See ( 1 , Houten ) ;
3012: LD_INT 1
3014: PPUSH
3015: LD_EXP 24
3019: PPUSH
3020: CALL_OW 292
3024: IFFALSE 3005
// ComTurnUnit ( JMM , Houten ) ;
3026: LD_EXP 20
3030: PPUSH
3031: LD_EXP 24
3035: PPUSH
3036: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3040: LD_EXP 20
3044: PPUSH
3045: LD_STRING D1d-JMM-1
3047: PPUSH
3048: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3052: LD_EXP 24
3056: PPUSH
3057: LD_STRING D1-VanH-1
3059: PPUSH
3060: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3064: LD_EXP 20
3068: PPUSH
3069: LD_STRING D1-JMM-1v
3071: PPUSH
3072: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3076: LD_EXP 20
3080: PPUSH
3081: LD_STRING D1-JMM-2v
3083: PPUSH
3084: CALL_OW 88
// end ; InGameOff ;
3088: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3092: LD_STRING M1
3094: PPUSH
3095: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3099: LD_INT 22
3101: PUSH
3102: LD_INT 4
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PUSH
3109: LD_INT 92
3111: PUSH
3112: LD_EXP 20
3116: PPUSH
3117: CALL_OW 250
3121: PUSH
3122: LD_EXP 20
3126: PPUSH
3127: CALL_OW 251
3131: PUSH
3132: LD_INT 15
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: PPUSH
3145: CALL_OW 69
3149: PPUSH
3150: LD_INT 1
3152: PPUSH
3153: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3157: LD_EXP 25
3161: PUSH
3162: LD_EXP 20
3166: ADD
3167: PUSH
3168: LD_EXP 24
3172: ADD
3173: PPUSH
3174: CALL_OW 141
// end ;
3178: LD_VAR 0 1
3182: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3183: LD_INT 1
3185: PPUSH
3186: LD_EXP 21
3190: PPUSH
3191: CALL_OW 292
3195: PUSH
3196: LD_EXP 20
3200: PPUSH
3201: LD_EXP 21
3205: PPUSH
3206: CALL_OW 296
3210: PUSH
3211: LD_INT 6
3213: LESS
3214: AND
3215: IFFALSE 4088
3217: GO 3219
3219: DISABLE
3220: LD_INT 0
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
3226: PPUSH
// begin InGameOn ;
3227: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3231: LD_INT 22
3233: PUSH
3234: LD_INT 4
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: PPUSH
3241: CALL_OW 69
3245: PPUSH
3246: LD_INT 1
3248: PPUSH
3249: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3253: LD_ADDR_VAR 0 4
3257: PUSH
3258: LD_INT 22
3260: PUSH
3261: LD_INT 1
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: LD_INT 2
3270: PUSH
3271: LD_INT 25
3273: PUSH
3274: LD_INT 1
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 25
3283: PUSH
3284: LD_INT 2
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: PUSH
3291: LD_INT 25
3293: PUSH
3294: LD_INT 3
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 25
3303: PUSH
3304: LD_INT 4
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: LIST
3316: LIST
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: ST_TO_ADDR
// ComHold ( tmp ) ;
3327: LD_VAR 0 4
3331: PPUSH
3332: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3336: LD_EXP 20
3340: PPUSH
3341: LD_STRING D2-JMM-3a
3343: PPUSH
3344: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3348: LD_EXP 21
3352: PPUSH
3353: LD_EXP 20
3357: PPUSH
3358: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3362: LD_EXP 21
3366: PPUSH
3367: LD_STRING D2-Gary-3
3369: PPUSH
3370: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3374: LD_EXP 20
3378: PPUSH
3379: LD_EXP 21
3383: PPUSH
3384: CALL_OW 119
// for i in tmp do
3388: LD_ADDR_VAR 0 5
3392: PUSH
3393: LD_VAR 0 4
3397: PUSH
3398: FOR_IN
3399: IFFALSE 3444
// begin if IsInUnit ( i ) then
3401: LD_VAR 0 5
3405: PPUSH
3406: CALL_OW 310
3410: IFFALSE 3421
// ComExitBuilding ( i ) ;
3412: LD_VAR 0 5
3416: PPUSH
3417: CALL_OW 122
// wait ( 1 ) ;
3421: LD_INT 1
3423: PPUSH
3424: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3428: LD_VAR 0 5
3432: PPUSH
3433: LD_EXP 20
3437: PPUSH
3438: CALL_OW 119
// end ;
3442: GO 3398
3444: POP
3445: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3446: LD_ADDR_VAR 0 4
3450: PUSH
3451: LD_VAR 0 4
3455: PUSH
3456: LD_EXP 20
3460: PUSH
3461: LD_EXP 24
3465: PUSH
3466: LD_EXP 21
3470: PUSH
3471: LD_EXP 23
3475: PUSH
3476: LD_EXP 22
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: PUSH
3488: LD_EXP 25
3492: ADD
3493: DIFF
3494: ST_TO_ADDR
// if Bobby then
3495: LD_EXP 22
3499: IFFALSE 3513
// Say ( Bobby , D2-Bobby-3 ) ;
3501: LD_EXP 22
3505: PPUSH
3506: LD_STRING D2-Bobby-3
3508: PPUSH
3509: CALL_OW 88
// if Cyrus then
3513: LD_EXP 23
3517: IFFALSE 3531
// Say ( Cyrus , D2-Cyrus-3 ) ;
3519: LD_EXP 23
3523: PPUSH
3524: LD_STRING D2-Cyrus-3
3526: PPUSH
3527: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3531: LD_EXP 20
3535: PPUSH
3536: LD_STRING D2-JMM-4
3538: PPUSH
3539: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3543: LD_EXP 21
3547: PPUSH
3548: LD_STRING D2-Gary-4
3550: PPUSH
3551: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3555: LD_ADDR_VAR 0 1
3559: PUSH
3560: LD_VAR 0 4
3564: PPUSH
3565: LD_INT 26
3567: PUSH
3568: LD_INT 1
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PPUSH
3575: CALL_OW 72
3579: PUSH
3580: LD_INT 1
3582: ARRAY
3583: ST_TO_ADDR
// if Cyrus then
3584: LD_EXP 23
3588: IFFALSE 3604
// Say ( Cyrus , D2-Cyrus-4 ) else
3590: LD_EXP 23
3594: PPUSH
3595: LD_STRING D2-Cyrus-4
3597: PPUSH
3598: CALL_OW 88
3602: GO 3616
// Say ( un1 , D2-Sol1-4 ) ;
3604: LD_VAR 0 1
3608: PPUSH
3609: LD_STRING D2-Sol1-4
3611: PPUSH
3612: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3616: LD_EXP 20
3620: PPUSH
3621: LD_STRING D2-JMM-5
3623: PPUSH
3624: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3628: LD_ADDR_VAR 0 2
3632: PUSH
3633: LD_EXP 25
3637: PPUSH
3638: LD_INT 91
3640: PUSH
3641: LD_EXP 20
3645: PUSH
3646: LD_INT 10
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: LIST
3653: PUSH
3654: LD_INT 26
3656: PUSH
3657: LD_INT 2
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: PPUSH
3668: CALL_OW 72
3672: ST_TO_ADDR
// if un2 then
3673: LD_VAR 0 2
3677: IFFALSE 3731
// begin un2 := un2 [ un2 ] ;
3679: LD_ADDR_VAR 0 2
3683: PUSH
3684: LD_VAR 0 2
3688: PUSH
3689: LD_VAR 0 2
3693: ARRAY
3694: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3695: LD_VAR 0 2
3699: PPUSH
3700: LD_STRING D2-FEng1-5
3702: PPUSH
3703: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3707: LD_EXP 20
3711: PPUSH
3712: LD_STRING D2-JMM-6
3714: PPUSH
3715: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3719: LD_VAR 0 2
3723: PPUSH
3724: LD_STRING D2-FEng1-6
3726: PPUSH
3727: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3731: LD_ADDR_VAR 0 3
3735: PUSH
3736: LD_EXP 25
3740: PPUSH
3741: LD_INT 91
3743: PUSH
3744: LD_EXP 20
3748: PUSH
3749: LD_INT 10
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 26
3759: PUSH
3760: LD_INT 1
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: CALL_OW 72
3775: ST_TO_ADDR
// if un3 then
3776: LD_VAR 0 3
3780: IFFALSE 3835
// begin un3 := un3 [ 1 ] ;
3782: LD_ADDR_VAR 0 3
3786: PUSH
3787: LD_VAR 0 3
3791: PUSH
3792: LD_INT 1
3794: ARRAY
3795: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3796: LD_VAR 0 3
3800: PPUSH
3801: LD_INT 114
3803: PPUSH
3804: LD_INT 122
3806: PPUSH
3807: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3811: LD_VAR 0 3
3815: PPUSH
3816: LD_STRING D2-Eng1-6
3818: PPUSH
3819: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3823: LD_EXP 20
3827: PPUSH
3828: LD_STRING D2-JMM-7
3830: PPUSH
3831: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3835: LD_EXP 21
3839: PPUSH
3840: LD_STRING D2-Gary-7
3842: PPUSH
3843: CALL_OW 88
// if un2 then
3847: LD_VAR 0 2
3851: IFFALSE 3865
// Say ( un2 , D2-FEng1-7 ) ;
3853: LD_VAR 0 2
3857: PPUSH
3858: LD_STRING D2-FEng1-7
3860: PPUSH
3861: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3865: LD_VAR 0 1
3869: PPUSH
3870: LD_STRING D2-Sol1-7
3872: PPUSH
3873: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3877: LD_EXP 20
3881: PPUSH
3882: LD_STRING D2-JMM-8
3884: PPUSH
3885: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3889: LD_INT 22
3891: PUSH
3892: LD_INT 1
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PPUSH
3899: CALL_OW 69
3903: PPUSH
3904: CALL_OW 141
// InGameOff ;
3908: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3912: LD_STRING M1a
3914: PPUSH
3915: CALL_OW 337
// jmm_in_ovsyenko := true ;
3919: LD_ADDR_EXP 4
3923: PUSH
3924: LD_INT 1
3926: ST_TO_ADDR
// if debug then
3927: LD_EXP 2
3931: IFFALSE 4037
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
3933: LD_INT 22
3935: PUSH
3936: LD_INT 1
3938: PUSH
3939: EMPTY
3940: LIST
3941: LIST
3942: PUSH
3943: LD_INT 30
3945: PUSH
3946: LD_INT 0
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PPUSH
3957: CALL_OW 69
3961: PUSH
3962: LD_INT 1
3964: ARRAY
3965: PPUSH
3966: CALL_OW 274
3970: PPUSH
3971: LD_INT 2
3973: PPUSH
3974: LD_INT 1000
3976: PPUSH
3977: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
3981: LD_INT 22
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: PUSH
3991: LD_INT 30
3993: PUSH
3994: LD_INT 0
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PPUSH
4005: CALL_OW 69
4009: PUSH
4010: LD_INT 1
4012: ARRAY
4013: PPUSH
4014: CALL_OW 274
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: LD_INT 1000
4024: PPUSH
4025: CALL_OW 277
// ar_can_arrive := true ;
4029: LD_ADDR_EXP 10
4033: PUSH
4034: LD_INT 1
4036: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4037: LD_INT 1050
4039: PPUSH
4040: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4044: LD_ADDR_VAR 0 4
4048: PUSH
4049: LD_INT 25
4051: PUSH
4052: LD_INT 14
4054: PUSH
4055: EMPTY
4056: LIST
4057: LIST
4058: PPUSH
4059: CALL_OW 69
4063: ST_TO_ADDR
// if not tmp then
4064: LD_VAR 0 4
4068: NOT
4069: IFFALSE 4073
// exit ;
4071: GO 4088
// ComMoveXY ( tmp , 75 , 75 ) ;
4073: LD_VAR 0 4
4077: PPUSH
4078: LD_INT 75
4080: PPUSH
4081: LD_INT 75
4083: PPUSH
4084: CALL_OW 111
// end ;
4088: PPOPN 5
4090: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4091: LD_INT 22
4093: PUSH
4094: LD_INT 1
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PUSH
4101: LD_INT 30
4103: PUSH
4104: LD_INT 30
4106: PUSH
4107: EMPTY
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 3
4113: PUSH
4114: LD_INT 57
4116: PUSH
4117: EMPTY
4118: LIST
4119: PUSH
4120: EMPTY
4121: LIST
4122: LIST
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: LIST
4128: PPUSH
4129: CALL_OW 69
4133: IFFALSE 4175
4135: GO 4137
4137: DISABLE
4138: LD_INT 0
4140: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4141: LD_ADDR_VAR 0 1
4145: PUSH
4146: LD_STRING M2easy
4148: PUSH
4149: LD_STRING M2
4151: PUSH
4152: LD_STRING M2hard
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4160: LD_VAR 0 1
4164: PUSH
4165: LD_OWVAR 67
4169: ARRAY
4170: PPUSH
4171: CALL_OW 337
// end ;
4175: PPOPN 1
4177: END
// every 3 3$00 do
4178: GO 4180
4180: DISABLE
// begin DialogueOn ;
4181: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4185: LD_EXP 27
4189: PPUSH
4190: LD_STRING D3-Pow-1
4192: PPUSH
4193: CALL_OW 94
// if jmm_in_ovsyenko then
4197: LD_EXP 4
4201: IFFALSE 4229
// begin Say ( JMM , D3-JMM-1 ) ;
4203: LD_EXP 20
4207: PPUSH
4208: LD_STRING D3-JMM-1
4210: PPUSH
4211: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4215: LD_EXP 20
4219: PPUSH
4220: LD_STRING D3-JMM-1b
4222: PPUSH
4223: CALL_OW 88
// end else
4227: GO 4241
// Say ( JMM , D3-JMM-1a ) ;
4229: LD_EXP 20
4233: PPUSH
4234: LD_STRING D3-JMM-1a
4236: PPUSH
4237: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4241: LD_EXP 27
4245: PPUSH
4246: LD_STRING D3-Pow-2
4248: PPUSH
4249: CALL_OW 94
// DialogueOff ;
4253: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4257: LD_STRING M3
4259: PPUSH
4260: CALL_OW 337
// powell_want_sib := true ;
4264: LD_ADDR_EXP 5
4268: PUSH
4269: LD_INT 1
4271: ST_TO_ADDR
// end ;
4272: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4273: LD_EXP 6
4277: PUSH
4278: LD_INT 0
4280: EQUAL
4281: IFFALSE 5742
4283: GO 4285
4285: DISABLE
4286: LD_INT 0
4288: PPUSH
4289: PPUSH
4290: PPUSH
4291: PPUSH
4292: PPUSH
4293: PPUSH
4294: PPUSH
4295: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4296: LD_INT 4
4298: PPUSH
4299: LD_INT 1
4301: PPUSH
4302: CALL_OW 343
// PowellTransport ;
4306: CALL 2524 0 0
// for i = 1 to 3 do
4310: LD_ADDR_VAR 0 4
4314: PUSH
4315: DOUBLE
4316: LD_INT 1
4318: DEC
4319: ST_TO_ADDR
4320: LD_INT 3
4322: PUSH
4323: FOR_TO
4324: IFFALSE 4391
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4326: LD_ADDR_VAR 0 1
4330: PUSH
4331: LD_INT 6
4333: PPUSH
4334: LD_VAR 0 4
4338: PPUSH
4339: CALL_OW 287
4343: ST_TO_ADDR
// if not tmp then
4344: LD_VAR 0 1
4348: NOT
4349: IFFALSE 4353
// continue ;
4351: GO 4323
// EraseResourceArea ( terminalArea , i ) ;
4353: LD_INT 6
4355: PPUSH
4356: LD_VAR 0 4
4360: PPUSH
4361: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4365: LD_EXP 3
4369: PPUSH
4370: CALL_OW 274
4374: PPUSH
4375: LD_VAR 0 4
4379: PPUSH
4380: LD_VAR 0 1
4384: PPUSH
4385: CALL_OW 276
// end ;
4389: GO 4323
4391: POP
4392: POP
// x := 43 ;
4393: LD_ADDR_VAR 0 2
4397: PUSH
4398: LD_INT 43
4400: ST_TO_ADDR
// y := 3 ;
4401: LD_ADDR_VAR 0 3
4405: PUSH
4406: LD_INT 3
4408: ST_TO_ADDR
// for i = 3 to 4 do
4409: LD_ADDR_VAR 0 4
4413: PUSH
4414: DOUBLE
4415: LD_INT 3
4417: DEC
4418: ST_TO_ADDR
4419: LD_INT 4
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4614
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4425: LD_EXP 26
4429: PUSH
4430: LD_VAR 0 4
4434: ARRAY
4435: PPUSH
4436: LD_INT 4
4438: PPUSH
4439: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4443: LD_EXP 26
4447: PUSH
4448: LD_VAR 0 4
4452: ARRAY
4453: PPUSH
4454: LD_VAR 0 2
4458: PPUSH
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 0
4466: PPUSH
4467: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4471: LD_EXP 26
4475: PUSH
4476: LD_VAR 0 4
4480: PUSH
4481: LD_INT 2
4483: MINUS
4484: ARRAY
4485: PPUSH
4486: LD_EXP 26
4490: PUSH
4491: LD_VAR 0 4
4495: ARRAY
4496: PPUSH
4497: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4501: LD_EXP 26
4505: PUSH
4506: LD_VAR 0 4
4510: ARRAY
4511: PPUSH
4512: LD_INT 1
4514: PPUSH
4515: LD_INT 100
4517: PPUSH
4518: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4522: LD_EXP 26
4526: PUSH
4527: LD_VAR 0 4
4531: PUSH
4532: LD_INT 2
4534: MINUS
4535: ARRAY
4536: PPUSH
4537: LD_INT 54
4539: PPUSH
4540: LD_INT 42
4542: PPUSH
4543: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4547: LD_EXP 26
4551: PUSH
4552: LD_VAR 0 4
4556: PUSH
4557: LD_INT 2
4559: MINUS
4560: ARRAY
4561: PPUSH
4562: LD_EXP 3
4566: PPUSH
4567: CALL_OW 250
4571: PPUSH
4572: LD_EXP 3
4576: PPUSH
4577: CALL_OW 251
4581: PPUSH
4582: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4586: LD_EXP 26
4590: PUSH
4591: LD_VAR 0 4
4595: PUSH
4596: LD_INT 2
4598: MINUS
4599: ARRAY
4600: PPUSH
4601: CALL_OW 200
// Wait ( 0 0$02 ) ;
4605: LD_INT 70
4607: PPUSH
4608: CALL_OW 67
// end ;
4612: GO 4422
4614: POP
4615: POP
// time := 0 0$20 ;
4616: LD_ADDR_VAR 0 8
4620: PUSH
4621: LD_INT 700
4623: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4624: LD_INT 35
4626: PPUSH
4627: CALL_OW 67
// time := time - 0 0$01 ;
4631: LD_ADDR_VAR 0 8
4635: PUSH
4636: LD_VAR 0 8
4640: PUSH
4641: LD_INT 35
4643: MINUS
4644: ST_TO_ADDR
// for i = 3 to 4 do
4645: LD_ADDR_VAR 0 4
4649: PUSH
4650: DOUBLE
4651: LD_INT 3
4653: DEC
4654: ST_TO_ADDR
4655: LD_INT 4
4657: PUSH
4658: FOR_TO
4659: IFFALSE 4794
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4661: LD_EXP 26
4665: PUSH
4666: LD_VAR 0 4
4670: ARRAY
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: CALL_OW 289
4679: PUSH
4680: LD_INT 0
4682: GREATER
4683: PUSH
4684: LD_EXP 26
4688: PUSH
4689: LD_VAR 0 4
4693: ARRAY
4694: PPUSH
4695: CALL_OW 314
4699: NOT
4700: AND
4701: IFFALSE 4792
// begin x := rand ( 0 , 5 ) ;
4703: LD_ADDR_VAR 0 2
4707: PUSH
4708: LD_INT 0
4710: PPUSH
4711: LD_INT 5
4713: PPUSH
4714: CALL_OW 12
4718: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4719: LD_EXP 26
4723: PUSH
4724: LD_VAR 0 4
4728: ARRAY
4729: PPUSH
4730: LD_EXP 26
4734: PUSH
4735: LD_VAR 0 4
4739: ARRAY
4740: PPUSH
4741: CALL_OW 250
4745: PPUSH
4746: LD_VAR 0 2
4750: PPUSH
4751: LD_INT 3
4753: PPUSH
4754: CALL_OW 272
4758: PPUSH
4759: LD_EXP 26
4763: PUSH
4764: LD_VAR 0 4
4768: ARRAY
4769: PPUSH
4770: CALL_OW 251
4774: PPUSH
4775: LD_VAR 0 2
4779: PPUSH
4780: LD_INT 3
4782: PPUSH
4783: CALL_OW 273
4787: PPUSH
4788: CALL_OW 171
// end ;
4792: GO 4658
4794: POP
4795: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4796: LD_EXP 26
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 54
4807: PPUSH
4808: LD_INT 42
4810: PPUSH
4811: CALL_OW 297
4815: PUSH
4816: LD_INT 4
4818: LESS
4819: PUSH
4820: LD_VAR 0 8
4824: PUSH
4825: LD_INT 0
4827: EQUAL
4828: OR
4829: IFFALSE 4624
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4831: LD_EXP 26
4835: PUSH
4836: LD_INT 3
4838: ARRAY
4839: PPUSH
4840: LD_INT 1
4842: PPUSH
4843: LD_INT 0
4845: PPUSH
4846: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4850: LD_EXP 26
4854: PUSH
4855: LD_INT 4
4857: ARRAY
4858: PPUSH
4859: LD_INT 1
4861: PPUSH
4862: LD_INT 0
4864: PPUSH
4865: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4869: LD_EXP 3
4873: PPUSH
4874: CALL_OW 274
4878: PPUSH
4879: LD_INT 1
4881: PPUSH
4882: LD_INT 200
4884: PPUSH
4885: CALL_OW 276
// DialogueOn ;
4889: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4893: LD_INT 53
4895: PPUSH
4896: LD_INT 35
4898: PPUSH
4899: CALL_OW 86
// un := powell_trans [ 1 ] ;
4903: LD_ADDR_VAR 0 5
4907: PUSH
4908: LD_EXP 26
4912: PUSH
4913: LD_INT 1
4915: ARRAY
4916: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4917: LD_VAR 0 5
4921: PPUSH
4922: LD_STRING D4-Mech1-1
4924: PPUSH
4925: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4929: LD_EXP 20
4933: PPUSH
4934: LD_STRING D4-JMM-1
4936: PPUSH
4937: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4941: LD_VAR 0 5
4945: PPUSH
4946: LD_STRING D4-Mech1-2
4948: PPUSH
4949: CALL_OW 88
// powell_happy := false ;
4953: LD_ADDR_VAR 0 6
4957: PUSH
4958: LD_INT 0
4960: ST_TO_ADDR
// take_cargo := false ;
4961: LD_ADDR_VAR 0 7
4965: PUSH
4966: LD_INT 0
4968: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4969: CALL 824 0 0
4973: PUSH
4974: LD_INT 60
4976: GREATEREQUAL
4977: IFFALSE 5025
// begin Say ( JMM , D5-JMM-1 ) ;
4979: LD_EXP 20
4983: PPUSH
4984: LD_STRING D5-JMM-1
4986: PPUSH
4987: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4991: LD_VAR 0 5
4995: PPUSH
4996: LD_STRING D6-Mech1-1
4998: PPUSH
4999: CALL_OW 88
// powell_happy := true ;
5003: LD_ADDR_VAR 0 6
5007: PUSH
5008: LD_INT 1
5010: ST_TO_ADDR
// take_cargo := true ;
5011: LD_ADDR_VAR 0 7
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// DialogueOff ;
5019: CALL_OW 7
// end else
5023: GO 5259
// if GetTerminalCargo > 0 then
5025: CALL 824 0 0
5029: PUSH
5030: LD_INT 0
5032: GREATER
5033: IFFALSE 5231
// begin case Query ( QWait ) of 1 :
5035: LD_STRING QWait
5037: PPUSH
5038: CALL_OW 97
5042: PUSH
5043: LD_INT 1
5045: DOUBLE
5046: EQUAL
5047: IFTRUE 5051
5049: GO 5142
5051: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5052: LD_EXP 20
5056: PPUSH
5057: LD_STRING D5a-JMM-1
5059: PPUSH
5060: CALL_OW 88
// DialogueOff ;
5064: CALL_OW 7
// wait ( 5 5$00 ) ;
5068: LD_INT 10500
5070: PPUSH
5071: CALL_OW 67
// if GetTerminalCargo < 60 then
5075: CALL 824 0 0
5079: PUSH
5080: LD_INT 60
5082: LESS
5083: IFFALSE 5124
// begin DialogueOn ;
5085: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5089: LD_EXP 3
5093: PPUSH
5094: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5098: LD_VAR 0 5
5102: PPUSH
5103: LD_STRING D6-Mech1-1a
5105: PPUSH
5106: CALL_OW 88
// DialogueOff ;
5110: CALL_OW 7
// powell_happy := false ;
5114: LD_ADDR_VAR 0 6
5118: PUSH
5119: LD_INT 0
5121: ST_TO_ADDR
// end else
5122: GO 5140
// begin powell_happy := true ;
5124: LD_ADDR_VAR 0 6
5128: PUSH
5129: LD_INT 1
5131: ST_TO_ADDR
// take_cargo := true ;
5132: LD_ADDR_VAR 0 7
5136: PUSH
5137: LD_INT 1
5139: ST_TO_ADDR
// end ; end ; 2 :
5140: GO 5229
5142: LD_INT 2
5144: DOUBLE
5145: EQUAL
5146: IFTRUE 5150
5148: GO 5189
5150: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5151: LD_EXP 20
5155: PPUSH
5156: LD_STRING D5b-JMM-1
5158: PPUSH
5159: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5163: LD_VAR 0 5
5167: PPUSH
5168: LD_STRING D6-Mech1-1a
5170: PPUSH
5171: CALL_OW 88
// DialogueOff ;
5175: CALL_OW 7
// take_cargo := true ;
5179: LD_ADDR_VAR 0 7
5183: PUSH
5184: LD_INT 1
5186: ST_TO_ADDR
// end ; 3 :
5187: GO 5229
5189: LD_INT 3
5191: DOUBLE
5192: EQUAL
5193: IFTRUE 5197
5195: GO 5228
5197: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5198: LD_EXP 20
5202: PPUSH
5203: LD_STRING D5c-JMM-1
5205: PPUSH
5206: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5210: LD_VAR 0 5
5214: PPUSH
5215: LD_STRING D6-Mech1-1b
5217: PPUSH
5218: CALL_OW 88
// DialogueOff ;
5222: CALL_OW 7
// end ; end ;
5226: GO 5229
5228: POP
// end else
5229: GO 5259
// begin Say ( JMM , D5c-JMM-1 ) ;
5231: LD_EXP 20
5235: PPUSH
5236: LD_STRING D5c-JMM-1
5238: PPUSH
5239: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5243: LD_VAR 0 5
5247: PPUSH
5248: LD_STRING D6-Mech1-1b
5250: PPUSH
5251: CALL_OW 88
// DialogueOff ;
5255: CALL_OW 7
// end ; if take_cargo then
5259: LD_VAR 0 7
5263: IFFALSE 5342
// begin x := GetTerminalCargo ;
5265: LD_ADDR_VAR 0 2
5269: PUSH
5270: CALL 824 0 0
5274: ST_TO_ADDR
// if x > 60 then
5275: LD_VAR 0 2
5279: PUSH
5280: LD_INT 60
5282: GREATER
5283: IFFALSE 5293
// x := 60 ;
5285: LD_ADDR_VAR 0 2
5289: PUSH
5290: LD_INT 60
5292: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5293: LD_EXP 3
5297: PPUSH
5298: CALL_OW 274
5302: PPUSH
5303: LD_INT 3
5305: PPUSH
5306: CALL 824 0 0
5310: PUSH
5311: LD_VAR 0 2
5315: MINUS
5316: PPUSH
5317: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5321: LD_EXP 26
5325: PUSH
5326: LD_INT 3
5328: ARRAY
5329: PPUSH
5330: LD_INT 3
5332: PPUSH
5333: LD_VAR 0 2
5337: PPUSH
5338: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5342: LD_EXP 26
5346: PPUSH
5347: LD_INT 43
5349: PPUSH
5350: LD_INT 3
5352: PPUSH
5353: CALL_OW 171
// x := 0 0$20 ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_INT 700
5364: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5365: LD_INT 35
5367: PPUSH
5368: CALL_OW 67
// x := x - 0 0$01 ;
5372: LD_ADDR_VAR 0 2
5376: PUSH
5377: LD_VAR 0 2
5381: PUSH
5382: LD_INT 35
5384: MINUS
5385: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5386: LD_VAR 0 2
5390: PUSH
5391: LD_INT 0
5393: EQUAL
5394: PUSH
5395: LD_EXP 26
5399: PUSH
5400: LD_INT 3
5402: ARRAY
5403: PPUSH
5404: LD_INT 43
5406: PPUSH
5407: LD_INT 3
5409: PPUSH
5410: CALL_OW 297
5414: PUSH
5415: LD_INT 4
5417: LESS
5418: PUSH
5419: LD_EXP 26
5423: PUSH
5424: LD_INT 3
5426: ARRAY
5427: PPUSH
5428: LD_INT 43
5430: PPUSH
5431: LD_INT 3
5433: PPUSH
5434: CALL_OW 297
5438: PUSH
5439: LD_INT 4
5441: LESS
5442: AND
5443: OR
5444: IFFALSE 5365
// for i in powell_trans do
5446: LD_ADDR_VAR 0 4
5450: PUSH
5451: LD_EXP 26
5455: PUSH
5456: FOR_IN
5457: IFFALSE 5470
// RemoveUnit ( i ) ;
5459: LD_VAR 0 4
5463: PPUSH
5464: CALL_OW 64
5468: GO 5456
5470: POP
5471: POP
// if not powell_happy then
5472: LD_VAR 0 6
5476: NOT
5477: IFFALSE 5488
// powell_happy := - 1 ;
5479: LD_ADDR_VAR 0 6
5483: PUSH
5484: LD_INT 1
5486: NEG
5487: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5488: LD_STRING EarlySiberite
5490: PPUSH
5491: LD_VAR 0 6
5495: PPUSH
5496: CALL_OW 101
// if powell_happy then
5500: LD_VAR 0 6
5504: IFFALSE 5514
// earlySib := true ;
5506: LD_ADDR_EXP 19
5510: PUSH
5511: LD_INT 1
5513: ST_TO_ADDR
// if powell_happy then
5514: LD_VAR 0 6
5518: IFFALSE 5529
// ChangeMissionObjectives ( M3a ) else
5520: LD_STRING M3a
5522: PPUSH
5523: CALL_OW 337
5527: GO 5536
// ChangeMissionObjectives ( M3b ) ;
5529: LD_STRING M3b
5531: PPUSH
5532: CALL_OW 337
// ru_can_attack_terminal := true ;
5536: LD_ADDR_EXP 9
5540: PUSH
5541: LD_INT 1
5543: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5544: LD_INT 25200
5546: PPUSH
5547: CALL_OW 67
// time := 2 2$00 ;
5551: LD_ADDR_VAR 0 8
5555: PUSH
5556: LD_INT 4200
5558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5559: LD_INT 35
5561: PPUSH
5562: CALL_OW 67
// time := time - 0 0$1 ;
5566: LD_ADDR_VAR 0 8
5570: PUSH
5571: LD_VAR 0 8
5575: PUSH
5576: LD_INT 35
5578: MINUS
5579: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5580: LD_EXP 8
5584: NOT
5585: PUSH
5586: LD_EXP 37
5590: PUSH
5591: LD_INT 0
5593: EQUAL
5594: OR
5595: PUSH
5596: LD_VAR 0 8
5600: PUSH
5601: LD_INT 0
5603: EQUAL
5604: OR
5605: IFFALSE 5559
// if ru_force then
5607: LD_EXP 37
5611: IFFALSE 5710
// for i in ru_force do
5613: LD_ADDR_VAR 0 4
5617: PUSH
5618: LD_EXP 37
5622: PUSH
5623: FOR_IN
5624: IFFALSE 5708
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5626: LD_INT 1
5628: PPUSH
5629: LD_VAR 0 4
5633: PPUSH
5634: CALL_OW 292
5638: NOT
5639: PUSH
5640: LD_VAR 0 4
5644: PPUSH
5645: LD_INT 81
5647: PUSH
5648: LD_INT 3
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PPUSH
5655: CALL_OW 69
5659: PPUSH
5660: LD_VAR 0 4
5664: PPUSH
5665: CALL_OW 74
5669: PPUSH
5670: CALL_OW 296
5674: PUSH
5675: LD_INT 10
5677: GREATER
5678: AND
5679: IFFALSE 5706
// begin RemoveUnit ( i ) ;
5681: LD_VAR 0 4
5685: PPUSH
5686: CALL_OW 64
// ru_force := ru_force diff i ;
5690: LD_ADDR_EXP 37
5694: PUSH
5695: LD_EXP 37
5699: PUSH
5700: LD_VAR 0 4
5704: DIFF
5705: ST_TO_ADDR
// end ;
5706: GO 5623
5708: POP
5709: POP
// repeat wait ( 0 0$03 ) ;
5710: LD_INT 105
5712: PPUSH
5713: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5717: LD_EXP 8
5721: NOT
5722: PUSH
5723: LD_EXP 37
5727: PUSH
5728: LD_INT 3
5730: LESS
5731: OR
5732: IFFALSE 5710
// ar_can_arrive := true ;
5734: LD_ADDR_EXP 10
5738: PUSH
5739: LD_INT 1
5741: ST_TO_ADDR
// end ;
5742: PPOPN 8
5744: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5745: LD_INT 1
5747: PPUSH
5748: LD_INT 20
5750: PPUSH
5751: CALL_OW 325
5755: IFFALSE 5896
5757: GO 5759
5759: DISABLE
5760: LD_INT 0
5762: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5763: LD_ADDR_VAR 0 1
5767: PUSH
5768: LD_INT 22
5770: PUSH
5771: LD_INT 1
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: PUSH
5778: LD_INT 26
5780: PUSH
5781: LD_INT 1
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_INT 25
5790: PUSH
5791: LD_INT 4
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PPUSH
5803: CALL_OW 69
5807: PUSH
5808: LD_EXP 20
5812: PUSH
5813: LD_EXP 23
5817: PUSH
5818: LD_EXP 22
5822: PUSH
5823: LD_EXP 24
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: DIFF
5834: ST_TO_ADDR
// if not un then
5835: LD_VAR 0 1
5839: NOT
5840: IFFALSE 5844
// exit ;
5842: GO 5896
// DialogueOn ;
5844: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5848: LD_VAR 0 1
5852: PUSH
5853: LD_INT 1
5855: ARRAY
5856: PPUSH
5857: LD_STRING D13-Sci1-1
5859: PPUSH
5860: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5864: LD_EXP 20
5868: PPUSH
5869: LD_STRING D13-JMM-1
5871: PPUSH
5872: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5876: LD_VAR 0 1
5880: PUSH
5881: LD_INT 1
5883: ARRAY
5884: PPUSH
5885: LD_STRING D13-Sci1-2
5887: PPUSH
5888: CALL_OW 88
// DialogueOff ;
5892: CALL_OW 7
// end ;
5896: PPOPN 1
5898: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5899: LD_INT 1
5901: PPUSH
5902: CALL 855 0 1
5906: PUSH
5907: LD_INT 77
5909: GREATER
5910: PUSH
5911: LD_EXP 8
5915: NOT
5916: AND
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 25
5930: PUSH
5931: LD_INT 4
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: LD_INT 26
5940: PUSH
5941: LD_INT 1
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: LIST
5952: PPUSH
5953: CALL_OW 69
5957: PUSH
5958: LD_EXP 20
5962: PUSH
5963: LD_EXP 22
5967: PUSH
5968: LD_EXP 23
5972: PUSH
5973: LD_EXP 21
5977: PUSH
5978: LD_EXP 24
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: DIFF
5990: AND
5991: IFFALSE 6169
5993: GO 5995
5995: DISABLE
5996: LD_INT 0
5998: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5999: LD_ADDR_VAR 0 1
6003: PUSH
6004: LD_INT 22
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: EMPTY
6011: LIST
6012: LIST
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: LD_INT 4
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: PUSH
6024: LD_INT 26
6026: PUSH
6027: LD_INT 1
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: PPUSH
6039: CALL_OW 69
6043: PUSH
6044: LD_EXP 20
6048: PUSH
6049: LD_EXP 22
6053: PUSH
6054: LD_EXP 23
6058: PUSH
6059: LD_EXP 21
6063: PUSH
6064: LD_EXP 24
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: LIST
6075: DIFF
6076: ST_TO_ADDR
// DialogueOn ;
6077: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6081: LD_VAR 0 1
6085: PUSH
6086: LD_INT 1
6088: ARRAY
6089: PPUSH
6090: LD_STRING D7-Sci1-1
6092: PPUSH
6093: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6097: LD_EXP 20
6101: PPUSH
6102: LD_STRING D7-JMM-1
6104: PPUSH
6105: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6109: LD_VAR 0 1
6113: PUSH
6114: LD_INT 1
6116: ARRAY
6117: PPUSH
6118: LD_STRING D7-Sci1-2
6120: PPUSH
6121: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6125: LD_EXP 20
6129: PPUSH
6130: LD_STRING D7-JMM-2
6132: PPUSH
6133: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6137: LD_VAR 0 1
6141: PUSH
6142: LD_INT 1
6144: ARRAY
6145: PPUSH
6146: LD_STRING D7-Sci1-3
6148: PPUSH
6149: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6153: LD_EXP 20
6157: PPUSH
6158: LD_STRING D7-JMM-3
6160: PPUSH
6161: CALL_OW 88
// DialogueOff ;
6165: CALL_OW 7
// end ;
6169: PPOPN 1
6171: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6172: LD_EXP 10
6176: IFFALSE 9799
6178: GO 6180
6180: DISABLE
6181: LD_INT 0
6183: PPUSH
6184: PPUSH
6185: PPUSH
6186: PPUSH
6187: PPUSH
6188: PPUSH
6189: PPUSH
6190: PPUSH
6191: PPUSH
6192: PPUSH
// begin PrepareArabian ;
6193: CALL 12468 0 0
// blocked := false ;
6197: LD_ADDR_EXP 18
6201: PUSH
6202: LD_INT 0
6204: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6205: LD_INT 35
6207: PPUSH
6208: CALL_OW 67
// until ar_spawned ;
6212: LD_EXP 11
6216: IFFALSE 6205
// have_crates := true ;
6218: LD_ADDR_VAR 0 9
6222: PUSH
6223: LD_INT 1
6225: ST_TO_ADDR
// player_want_info := 2 ;
6226: LD_ADDR_EXP 13
6230: PUSH
6231: LD_INT 2
6233: ST_TO_ADDR
// DialogueOn ;
6234: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6238: LD_EXP 28
6242: PPUSH
6243: LD_STRING D8-Ar1-1
6245: PPUSH
6246: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6250: LD_EXP 20
6254: PPUSH
6255: LD_STRING D8-JMM-1
6257: PPUSH
6258: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6262: LD_EXP 28
6266: PPUSH
6267: LD_STRING D8-Ar1-2
6269: PPUSH
6270: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6274: LD_EXP 20
6278: PPUSH
6279: LD_STRING D8-JMM-2
6281: PPUSH
6282: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6286: LD_EXP 28
6290: PPUSH
6291: LD_STRING D8-Ar1-3
6293: PPUSH
6294: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6298: LD_EXP 20
6302: PPUSH
6303: LD_STRING D8-JMM-3
6305: PPUSH
6306: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6310: LD_EXP 28
6314: PPUSH
6315: LD_STRING D8-Ar1-4
6317: PPUSH
6318: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6322: LD_EXP 20
6326: PPUSH
6327: LD_STRING D8-JMM-4
6329: PPUSH
6330: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6334: LD_EXP 28
6338: PPUSH
6339: LD_STRING D8-Ar1-5
6341: PPUSH
6342: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6346: LD_EXP 20
6350: PPUSH
6351: LD_STRING D8-JMM-5
6353: PPUSH
6354: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6358: LD_EXP 28
6362: PPUSH
6363: LD_STRING D8-Ar1-6
6365: PPUSH
6366: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6370: LD_EXP 29
6374: PPUSH
6375: LD_STRING D8-Ar2-6
6377: PPUSH
6378: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6382: LD_EXP 20
6386: PPUSH
6387: LD_STRING D8-JMM-6
6389: PPUSH
6390: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6394: LD_EXP 29
6398: PPUSH
6399: LD_STRING D8-Ar2-7
6401: PPUSH
6402: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6406: LD_STRING QBarracks
6408: PPUSH
6409: CALL_OW 97
6413: PUSH
6414: LD_INT 1
6416: DOUBLE
6417: EQUAL
6418: IFTRUE 6422
6420: GO 6457
6422: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6423: LD_EXP 20
6427: PPUSH
6428: LD_STRING D8a-JMM-1
6430: PPUSH
6431: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6435: LD_EXP 28
6439: PPUSH
6440: LD_STRING D8a-Ar1-1
6442: PPUSH
6443: CALL_OW 94
// player_want_mortar := true ;
6447: LD_ADDR_EXP 12
6451: PUSH
6452: LD_INT 1
6454: ST_TO_ADDR
// end ; 2 :
6455: GO 6631
6457: LD_INT 2
6459: DOUBLE
6460: EQUAL
6461: IFTRUE 6465
6463: GO 6587
6465: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6466: LD_EXP 20
6470: PPUSH
6471: LD_STRING D8b-JMM-1
6473: PPUSH
6474: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6478: LD_EXP 28
6482: PPUSH
6483: LD_STRING D8b-Ar1-1
6485: PPUSH
6486: CALL_OW 94
// case Query ( QInfo ) of 1 :
6490: LD_STRING QInfo
6492: PPUSH
6493: CALL_OW 97
6497: PUSH
6498: LD_INT 1
6500: DOUBLE
6501: EQUAL
6502: IFTRUE 6506
6504: GO 6541
6506: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6507: LD_EXP 20
6511: PPUSH
6512: LD_STRING D8b1-JMM-1
6514: PPUSH
6515: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6519: LD_EXP 28
6523: PPUSH
6524: LD_STRING D8b1-Ar1-1
6526: PPUSH
6527: CALL_OW 94
// player_want_info := 2 ;
6531: LD_ADDR_EXP 13
6535: PUSH
6536: LD_INT 2
6538: ST_TO_ADDR
// end ; 2 :
6539: GO 6585
6541: LD_INT 2
6543: DOUBLE
6544: EQUAL
6545: IFTRUE 6549
6547: GO 6584
6549: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6550: LD_EXP 20
6554: PPUSH
6555: LD_STRING D8b2-JMM-1
6557: PPUSH
6558: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6562: LD_EXP 28
6566: PPUSH
6567: LD_STRING D8b2-Ar1-1
6569: PPUSH
6570: CALL_OW 94
// player_want_info := 0 ;
6574: LD_ADDR_EXP 13
6578: PUSH
6579: LD_INT 0
6581: ST_TO_ADDR
// end ; end ;
6582: GO 6585
6584: POP
// end ; 3 :
6585: GO 6631
6587: LD_INT 3
6589: DOUBLE
6590: EQUAL
6591: IFTRUE 6595
6593: GO 6630
6595: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6596: LD_EXP 20
6600: PPUSH
6601: LD_STRING D8c-JMM-1
6603: PPUSH
6604: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6608: LD_EXP 28
6612: PPUSH
6613: LD_STRING D8c-Ar1-1
6615: PPUSH
6616: CALL_OW 94
// player_want_info := 0 ;
6620: LD_ADDR_EXP 13
6624: PUSH
6625: LD_INT 0
6627: ST_TO_ADDR
// end ; end ;
6628: GO 6631
6630: POP
// DialogueOff ;
6631: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6635: LD_ADDR_VAR 0 4
6639: PUSH
6640: LD_INT 9
6642: PPUSH
6643: LD_INT 2
6645: PUSH
6646: LD_INT 30
6648: PUSH
6649: LD_INT 0
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PUSH
6656: LD_INT 30
6658: PUSH
6659: LD_INT 1
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: PPUSH
6671: CALL_OW 70
6675: ST_TO_ADDR
// if dep then
6676: LD_VAR 0 4
6680: IFFALSE 6696
// dep := dep [ 1 ] ;
6682: LD_ADDR_VAR 0 4
6686: PUSH
6687: LD_VAR 0 4
6691: PUSH
6692: LD_INT 1
6694: ARRAY
6695: ST_TO_ADDR
// if not dep then
6696: LD_VAR 0 4
6700: NOT
6701: IFFALSE 6739
// begin case Query ( QInfoNothing ) of 1 :
6703: LD_STRING QInfoNothing
6705: PPUSH
6706: CALL_OW 97
6710: PUSH
6711: LD_INT 1
6713: DOUBLE
6714: EQUAL
6715: IFTRUE 6719
6717: GO 6722
6719: POP
// ; end ;
6720: GO 6723
6722: POP
// player_want_info := false ;
6723: LD_ADDR_EXP 13
6727: PUSH
6728: LD_INT 0
6730: ST_TO_ADDR
// player_want_mortar := false ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 0
6738: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6739: LD_ADDR_VAR 0 3
6743: PUSH
6744: LD_INT 22
6746: PUSH
6747: LD_INT 2
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 21
6756: PUSH
6757: LD_INT 2
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: PPUSH
6768: CALL_OW 69
6772: ST_TO_ADDR
// time := 1 1$55 ;
6773: LD_ADDR_VAR 0 5
6777: PUSH
6778: LD_INT 4025
6780: ST_TO_ADDR
// no_oil_gain := false ;
6781: LD_ADDR_VAR 0 6
6785: PUSH
6786: LD_INT 0
6788: ST_TO_ADDR
// first_warn := false ;
6789: LD_ADDR_VAR 0 7
6793: PUSH
6794: LD_INT 0
6796: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6797: LD_EXP 12
6801: PUSH
6802: LD_EXP 13
6806: OR
6807: IFFALSE 6912
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6809: LD_EXP 35
6813: PPUSH
6814: LD_INT 25
6816: PUSH
6817: LD_INT 1
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: PPUSH
6824: CALL_OW 72
6828: PPUSH
6829: LD_VAR 0 4
6833: PPUSH
6834: CALL_OW 250
6838: PPUSH
6839: LD_VAR 0 4
6843: PPUSH
6844: CALL_OW 251
6848: PPUSH
6849: LD_VAR 0 4
6853: PPUSH
6854: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6858: LD_EXP 35
6862: PPUSH
6863: LD_INT 25
6865: PUSH
6866: LD_INT 1
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PPUSH
6873: CALL_OW 72
6877: PPUSH
6878: LD_INT 86
6880: PPUSH
6881: LD_INT 121
6883: PPUSH
6884: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6888: LD_EXP 35
6892: PPUSH
6893: LD_INT 25
6895: PUSH
6896: LD_INT 1
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PPUSH
6903: CALL_OW 72
6907: PPUSH
6908: CALL_OW 200
// end ; if player_attacked_ar then
6912: LD_EXP 16
6916: IFFALSE 6920
// exit ;
6918: GO 9799
// if player_want_mortar then
6920: LD_EXP 12
6924: IFFALSE 8461
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6926: LD_EXP 29
6930: PPUSH
6931: LD_VAR 0 4
6935: PPUSH
6936: CALL_OW 250
6940: PUSH
6941: LD_INT 1
6943: PLUS
6944: PPUSH
6945: LD_VAR 0 4
6949: PPUSH
6950: CALL_OW 251
6954: PUSH
6955: LD_INT 1
6957: PLUS
6958: PPUSH
6959: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6963: LD_INT 35
6965: PPUSH
6966: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6970: LD_EXP 29
6974: PPUSH
6975: LD_VAR 0 4
6979: PPUSH
6980: CALL_OW 296
6984: PUSH
6985: LD_INT 4
6987: LESS
6988: IFFALSE 6963
// for i = 1 to 6 do
6990: LD_ADDR_VAR 0 1
6994: PUSH
6995: DOUBLE
6996: LD_INT 1
6998: DEC
6999: ST_TO_ADDR
7000: LD_INT 6
7002: PUSH
7003: FOR_TO
7004: IFFALSE 7208
// begin if player_attacked_ar then
7006: LD_EXP 16
7010: IFFALSE 7016
// exit ;
7012: POP
7013: POP
7014: GO 9799
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7016: LD_VAR 0 4
7020: PPUSH
7021: CALL_OW 274
7025: PPUSH
7026: LD_INT 2
7028: PPUSH
7029: CALL_OW 275
7033: PUSH
7034: LD_INT 10
7036: LESS
7037: PUSH
7038: LD_VAR 0 7
7042: NOT
7043: AND
7044: IFFALSE 7107
// begin first_warn := true ;
7046: LD_ADDR_VAR 0 7
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// DialogueOn ;
7054: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7058: LD_EXP 30
7062: PPUSH
7063: LD_STRING D9a-FAr1-1
7065: PPUSH
7066: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7070: LD_EXP 20
7074: PPUSH
7075: LD_STRING D9a-JMM-1
7077: PPUSH
7078: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7082: LD_EXP 28
7086: PPUSH
7087: LD_STRING D9a2-Ar1-1
7089: PPUSH
7090: CALL_OW 88
// DialogueOff ;
7094: CALL_OW 7
// wait ( time ) ;
7098: LD_VAR 0 5
7102: PPUSH
7103: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7107: LD_VAR 0 4
7111: PPUSH
7112: CALL_OW 274
7116: PPUSH
7117: LD_INT 2
7119: PPUSH
7120: CALL_OW 275
7124: PUSH
7125: LD_INT 10
7127: LESS
7128: IFFALSE 7154
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7130: LD_EXP 28
7134: PPUSH
7135: LD_STRING D9a3-Ar1-1
7137: PPUSH
7138: CALL_OW 88
// no_oil_gain := true ;
7142: LD_ADDR_VAR 0 6
7146: PUSH
7147: LD_INT 1
7149: ST_TO_ADDR
// break ;
7150: GO 7208
// end else
7152: GO 7206
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7154: LD_EXP 29
7158: PPUSH
7159: LD_VAR 0 4
7163: PPUSH
7164: LD_INT 2
7166: PPUSH
7167: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7171: LD_EXP 29
7175: PPUSH
7176: LD_VAR 0 3
7180: PUSH
7181: LD_VAR 0 1
7185: PUSH
7186: LD_INT 3
7188: MOD
7189: PUSH
7190: LD_INT 1
7192: PLUS
7193: ARRAY
7194: PPUSH
7195: CALL_OW 210
// wait ( 0 0$10 ) ;
7199: LD_INT 350
7201: PPUSH
7202: CALL_OW 67
// end ; end ;
7206: GO 7003
7208: POP
7209: POP
// if not no_oil_gain then
7210: LD_VAR 0 6
7214: NOT
7215: IFFALSE 8461
// begin repeat wait ( 0 0$01 ) ;
7217: LD_INT 35
7219: PPUSH
7220: CALL_OW 67
// if player_attacked_ar then
7224: LD_EXP 16
7228: IFFALSE 7232
// exit ;
7230: GO 9799
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7232: LD_VAR 0 3
7236: PUSH
7237: LD_INT 1
7239: ARRAY
7240: PPUSH
7241: CALL_OW 261
7245: PUSH
7246: LD_INT 80
7248: GREATER
7249: PUSH
7250: LD_VAR 0 3
7254: PUSH
7255: LD_INT 2
7257: ARRAY
7258: PPUSH
7259: CALL_OW 261
7263: PUSH
7264: LD_INT 80
7266: GREATER
7267: AND
7268: PUSH
7269: LD_VAR 0 3
7273: PUSH
7274: LD_INT 3
7276: ARRAY
7277: PPUSH
7278: CALL_OW 261
7282: PUSH
7283: LD_INT 80
7285: GREATER
7286: AND
7287: IFFALSE 7217
// ComMoveXY ( Gali , 105 , 127 ) ;
7289: LD_EXP 29
7293: PPUSH
7294: LD_INT 105
7296: PPUSH
7297: LD_INT 127
7299: PPUSH
7300: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7304: LD_EXP 29
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: CALL_OW 173
// AddComHold ( Gali ) ;
7316: LD_EXP 29
7320: PPUSH
7321: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7325: LD_INT 35
7327: PPUSH
7328: CALL_OW 67
// if player_attacked_ar then
7332: LD_EXP 16
7336: IFFALSE 7340
// exit ;
7338: GO 9799
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7340: LD_EXP 29
7344: PPUSH
7345: LD_INT 105
7347: PPUSH
7348: LD_INT 127
7350: PPUSH
7351: CALL_OW 297
7355: PUSH
7356: LD_INT 4
7358: LESS
7359: IFFALSE 7325
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7361: LD_VAR 0 4
7365: PPUSH
7366: CALL_OW 274
7370: PPUSH
7371: LD_INT 1
7373: PPUSH
7374: CALL_OW 275
7378: PUSH
7379: LD_INT 50
7381: LESS
7382: IFFALSE 7684
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7384: LD_VAR 0 4
7388: PPUSH
7389: CALL_OW 274
7393: PPUSH
7394: LD_INT 1
7396: PPUSH
7397: CALL_OW 275
7401: PUSH
7402: LD_INT 0
7404: DOUBLE
7405: GREATEREQUAL
7406: IFFALSE 7414
7408: LD_INT 24
7410: DOUBLE
7411: LESSEQUAL
7412: IFTRUE 7416
7414: GO 7431
7416: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7417: LD_EXP 29
7421: PPUSH
7422: LD_STRING D9b-Ar2-1
7424: PPUSH
7425: CALL_OW 88
7429: GO 7461
7431: LD_INT 25
7433: DOUBLE
7434: GREATEREQUAL
7435: IFFALSE 7443
7437: LD_INT 49
7439: DOUBLE
7440: LESSEQUAL
7441: IFTRUE 7445
7443: GO 7460
7445: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7446: LD_EXP 29
7450: PPUSH
7451: LD_STRING D9b-Ar2-1a
7453: PPUSH
7454: CALL_OW 88
7458: GO 7461
7460: POP
// Say ( JMM , D9b-JMM-1 ) ;
7461: LD_EXP 20
7465: PPUSH
7466: LD_STRING D9b-JMM-1
7468: PPUSH
7469: CALL_OW 88
// x := 0 0$0 ;
7473: LD_ADDR_VAR 0 2
7477: PUSH
7478: LD_INT 0
7480: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7481: LD_INT 35
7483: PPUSH
7484: CALL_OW 67
// x := x + 0 0$1 ;
7488: LD_ADDR_VAR 0 2
7492: PUSH
7493: LD_VAR 0 2
7497: PUSH
7498: LD_INT 35
7500: PLUS
7501: ST_TO_ADDR
// if player_attacked_ar then
7502: LD_EXP 16
7506: IFFALSE 7510
// exit ;
7508: GO 9799
// until x >= time ;
7510: LD_VAR 0 2
7514: PUSH
7515: LD_VAR 0 5
7519: GREATEREQUAL
7520: IFFALSE 7481
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7522: LD_VAR 0 4
7526: PPUSH
7527: CALL_OW 274
7531: PPUSH
7532: LD_INT 1
7534: PPUSH
7535: CALL_OW 275
7539: PUSH
7540: LD_INT 50
7542: LESS
7543: IFFALSE 7684
// begin have_crates := false ;
7545: LD_ADDR_VAR 0 9
7549: PUSH
7550: LD_INT 0
7552: ST_TO_ADDR
// DialogueOn ;
7553: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7557: LD_EXP 28
7561: PPUSH
7562: LD_STRING D9c-Ar1-1
7564: PPUSH
7565: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7569: LD_EXP 20
7573: PPUSH
7574: LD_STRING D9c-JMM-1
7576: PPUSH
7577: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7581: LD_EXP 28
7585: PPUSH
7586: LD_STRING D9c-Ar1-2
7588: PPUSH
7589: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7593: LD_EXP 30
7597: PPUSH
7598: LD_STRING D9c-FAr1-2
7600: PPUSH
7601: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7605: LD_EXP 28
7609: PPUSH
7610: LD_STRING D9c-Ar1-3
7612: PPUSH
7613: CALL_OW 88
// case Query ( QInfo ) of 1 :
7617: LD_STRING QInfo
7619: PPUSH
7620: CALL_OW 97
7624: PUSH
7625: LD_INT 1
7627: DOUBLE
7628: EQUAL
7629: IFTRUE 7633
7631: GO 7656
7633: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7634: LD_EXP 20
7638: PPUSH
7639: LD_STRING D8b1-JMM-1
7641: PPUSH
7642: CALL_OW 88
// player_want_info := 2 ;
7646: LD_ADDR_EXP 13
7650: PUSH
7651: LD_INT 2
7653: ST_TO_ADDR
// end ; 2 :
7654: GO 7680
7656: LD_INT 2
7658: DOUBLE
7659: EQUAL
7660: IFTRUE 7664
7662: GO 7679
7664: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7665: LD_EXP 28
7669: PPUSH
7670: LD_STRING D8b2-Ar1-1
7672: PPUSH
7673: CALL_OW 88
// end ; end ;
7677: GO 7680
7679: POP
// DialogueOff ;
7680: CALL_OW 7
// end ; end ; if have_crates then
7684: LD_VAR 0 9
7688: IFFALSE 8461
// begin RemoveEnvironmentArea ( mortarArea ) ;
7690: LD_INT 2
7692: PPUSH
7693: CALL_OW 355
// wait ( 1 ) ;
7697: LD_INT 1
7699: PPUSH
7700: CALL_OW 67
// InGameOn ;
7704: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7708: LD_EXP 29
7712: PPUSH
7713: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7717: LD_EXP 29
7721: PPUSH
7722: LD_INT 1
7724: PPUSH
7725: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
7729: LD_ADDR_VAR 0 10
7733: PUSH
7734: LD_INT 22
7736: PUSH
7737: LD_INT 1
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: LD_INT 3
7746: PUSH
7747: LD_INT 23
7749: PUSH
7750: LD_INT 2
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: PUSH
7761: LD_INT 21
7763: PUSH
7764: LD_INT 1
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: PUSH
7771: LD_INT 92
7773: PUSH
7774: LD_INT 107
7776: PUSH
7777: LD_INT 131
7779: PUSH
7780: LD_INT 6
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: PUSH
7789: EMPTY
7790: LIST
7791: LIST
7792: LIST
7793: LIST
7794: PPUSH
7795: CALL_OW 69
7799: ST_TO_ADDR
// if filter then
7800: LD_VAR 0 10
7804: IFFALSE 7838
// for i in filter do
7806: LD_ADDR_VAR 0 1
7810: PUSH
7811: LD_VAR 0 10
7815: PUSH
7816: FOR_IN
7817: IFFALSE 7836
// ComMoveXY ( i , 107 , 121 ) ;
7819: LD_VAR 0 1
7823: PPUSH
7824: LD_INT 107
7826: PPUSH
7827: LD_INT 121
7829: PPUSH
7830: CALL_OW 111
7834: GO 7816
7836: POP
7837: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7838: LD_EXP 29
7842: PPUSH
7843: LD_INT 4
7845: PPUSH
7846: LD_INT 107
7848: PPUSH
7849: LD_INT 131
7851: PPUSH
7852: LD_INT 0
7854: PPUSH
7855: CALL_OW 145
// wait ( 0 0$1 ) ;
7859: LD_INT 35
7861: PPUSH
7862: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7866: LD_INT 30
7868: PUSH
7869: LD_INT 4
7871: PUSH
7872: EMPTY
7873: LIST
7874: LIST
7875: PUSH
7876: LD_INT 23
7878: PUSH
7879: LD_INT 2
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PPUSH
7890: CALL_OW 69
7894: IFFALSE 7729
// SetSide ( Gali , 2 ) ;
7896: LD_EXP 29
7900: PPUSH
7901: LD_INT 2
7903: PPUSH
7904: CALL_OW 235
// InGameOff ;
7908: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7912: LD_ADDR_VAR 0 8
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 4
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: LD_INT 23
7929: PUSH
7930: LD_INT 2
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: PUSH
7946: LD_INT 1
7948: ARRAY
7949: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7950: LD_INT 35
7952: PPUSH
7953: CALL_OW 67
// if player_attacked_ar then
7957: LD_EXP 16
7961: IFFALSE 7965
// exit ;
7963: GO 9799
// until BuildingStatus ( b ) <> bs_build ;
7965: LD_VAR 0 8
7969: PPUSH
7970: CALL_OW 461
7974: PUSH
7975: LD_INT 1
7977: NONEQUAL
7978: IFFALSE 7950
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7980: LD_VAR 0 8
7984: PPUSH
7985: CALL_OW 302
7989: PUSH
7990: LD_VAR 0 4
7994: PPUSH
7995: CALL_OW 274
7999: PPUSH
8000: LD_INT 1
8002: PPUSH
8003: CALL_OW 275
8007: PUSH
8008: LD_INT 25
8010: GREATEREQUAL
8011: AND
8012: IFFALSE 8111
// begin ComUpgrade ( b ) ;
8014: LD_VAR 0 8
8018: PPUSH
8019: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8023: LD_EXP 29
8027: PPUSH
8028: LD_STRING h
8030: PUSH
8031: LD_VAR 0 8
8035: PPUSH
8036: CALL_OW 250
8040: PUSH
8041: LD_VAR 0 8
8045: PPUSH
8046: CALL_OW 251
8050: PUSH
8051: LD_VAR 0 8
8055: PUSH
8056: LD_INT 0
8058: PUSH
8059: LD_INT 0
8061: PUSH
8062: LD_INT 0
8064: PUSH
8065: EMPTY
8066: LIST
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: EMPTY
8075: LIST
8076: PPUSH
8077: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8081: LD_INT 35
8083: PPUSH
8084: CALL_OW 67
// if player_attacked_ar then
8088: LD_EXP 16
8092: IFFALSE 8096
// exit ;
8094: GO 9799
// until BuildingStatus ( b ) <> bs_build ;
8096: LD_VAR 0 8
8100: PPUSH
8101: CALL_OW 461
8105: PUSH
8106: LD_INT 1
8108: NONEQUAL
8109: IFFALSE 8081
// end ; if b then
8111: LD_VAR 0 8
8115: IFFALSE 8126
// CenterNowOnUnits ( b ) ;
8117: LD_VAR 0 8
8121: PPUSH
8122: CALL_OW 87
// DialogueOn ;
8126: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8130: LD_EXP 29
8134: PPUSH
8135: LD_STRING D9d-Ar2-1
8137: PPUSH
8138: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8142: LD_EXP 28
8146: PPUSH
8147: LD_STRING D9d-Ar1-1
8149: PPUSH
8150: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8154: LD_EXP 20
8158: PPUSH
8159: LD_STRING D9d-JMM-1
8161: PPUSH
8162: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8166: LD_EXP 28
8170: PPUSH
8171: LD_STRING D9d-Ar1-2
8173: PPUSH
8174: CALL_OW 88
// DialogueOff ;
8178: CALL_OW 7
// i := [ ] ;
8182: LD_ADDR_VAR 0 1
8186: PUSH
8187: EMPTY
8188: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8189: LD_VAR 0 4
8193: PPUSH
8194: CALL_OW 274
8198: PPUSH
8199: LD_INT 3
8201: PPUSH
8202: CALL_OW 275
8206: PUSH
8207: LD_INT 20
8209: GREATEREQUAL
8210: IFFALSE 8229
// i := i ^ [ 1 ] ;
8212: LD_ADDR_VAR 0 1
8216: PUSH
8217: LD_VAR 0 1
8221: PUSH
8222: LD_INT 1
8224: PUSH
8225: EMPTY
8226: LIST
8227: ADD
8228: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8229: LD_VAR 0 4
8233: PPUSH
8234: CALL_OW 274
8238: PPUSH
8239: LD_INT 1
8241: PPUSH
8242: CALL_OW 275
8246: PUSH
8247: LD_INT 50
8249: GREATEREQUAL
8250: IFFALSE 8269
// i := i ^ [ 2 ] ;
8252: LD_ADDR_VAR 0 1
8256: PUSH
8257: LD_VAR 0 1
8261: PUSH
8262: LD_INT 2
8264: PUSH
8265: EMPTY
8266: LIST
8267: ADD
8268: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8269: LD_VAR 0 4
8273: PPUSH
8274: CALL_OW 274
8278: PPUSH
8279: LD_INT 2
8281: PPUSH
8282: CALL_OW 275
8286: PUSH
8287: LD_INT 80
8289: GREATEREQUAL
8290: IFFALSE 8309
// i := i ^ [ 3 ] ;
8292: LD_ADDR_VAR 0 1
8296: PUSH
8297: LD_VAR 0 1
8301: PUSH
8302: LD_INT 3
8304: PUSH
8305: EMPTY
8306: LIST
8307: ADD
8308: ST_TO_ADDR
// i := i diff 0 ;
8309: LD_ADDR_VAR 0 1
8313: PUSH
8314: LD_VAR 0 1
8318: PUSH
8319: LD_INT 0
8321: DIFF
8322: ST_TO_ADDR
// if i then
8323: LD_VAR 0 1
8327: IFFALSE 8433
// begin i := i ^ [ 4 ] ;
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_VAR 0 1
8338: PUSH
8339: LD_INT 4
8341: PUSH
8342: EMPTY
8343: LIST
8344: ADD
8345: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8346: LD_STRING QInfo2
8348: PPUSH
8349: CALL_OW 97
8353: PUSH
8354: LD_INT 1
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8373
8362: POP
// player_want_info := 3 ; 2 :
8363: LD_ADDR_EXP 13
8367: PUSH
8368: LD_INT 3
8370: ST_TO_ADDR
8371: GO 8431
8373: LD_INT 2
8375: DOUBLE
8376: EQUAL
8377: IFTRUE 8381
8379: GO 8392
8381: POP
// player_want_info := 1 ; 3 :
8382: LD_ADDR_EXP 13
8386: PUSH
8387: LD_INT 1
8389: ST_TO_ADDR
8390: GO 8431
8392: LD_INT 3
8394: DOUBLE
8395: EQUAL
8396: IFTRUE 8400
8398: GO 8411
8400: POP
// player_want_info := 2 ; 4 :
8401: LD_ADDR_EXP 13
8405: PUSH
8406: LD_INT 2
8408: ST_TO_ADDR
8409: GO 8431
8411: LD_INT 4
8413: DOUBLE
8414: EQUAL
8415: IFTRUE 8419
8417: GO 8430
8419: POP
// player_want_info := 0 ; end ;
8420: LD_ADDR_EXP 13
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
8428: GO 8431
8430: POP
// end else
8431: GO 8461
// case Query ( QInfoNothing ) of 1 :
8433: LD_STRING QInfoNothing
8435: PPUSH
8436: CALL_OW 97
8440: PUSH
8441: LD_INT 1
8443: DOUBLE
8444: EQUAL
8445: IFTRUE 8449
8447: GO 8460
8449: POP
// player_want_info := 0 ; end ;
8450: LD_ADDR_EXP 13
8454: PUSH
8455: LD_INT 0
8457: ST_TO_ADDR
8458: GO 8461
8460: POP
// end ; end ; end ; if player_want_info then
8461: LD_EXP 13
8465: IFFALSE 9619
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8467: LD_ADDR_VAR 0 3
8471: PUSH
8472: LD_VAR 0 3
8476: PPUSH
8477: LD_INT 34
8479: PUSH
8480: LD_INT 32
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 72
8491: ST_TO_ADDR
// if player_want_mortar then
8492: LD_EXP 12
8496: IFFALSE 8851
// begin case player_want_info of 1 :
8498: LD_EXP 13
8502: PUSH
8503: LD_INT 1
8505: DOUBLE
8506: EQUAL
8507: IFTRUE 8511
8509: GO 8522
8511: POP
// x := 5 ; 2 :
8512: LD_ADDR_VAR 0 2
8516: PUSH
8517: LD_INT 5
8519: ST_TO_ADDR
8520: GO 8561
8522: LD_INT 2
8524: DOUBLE
8525: EQUAL
8526: IFTRUE 8530
8528: GO 8541
8530: POP
// x := 8 ; 3 :
8531: LD_ADDR_VAR 0 2
8535: PUSH
8536: LD_INT 8
8538: ST_TO_ADDR
8539: GO 8561
8541: LD_INT 3
8543: DOUBLE
8544: EQUAL
8545: IFTRUE 8549
8547: GO 8560
8549: POP
// x := 2 ; end ;
8550: LD_ADDR_VAR 0 2
8554: PUSH
8555: LD_INT 2
8557: ST_TO_ADDR
8558: GO 8561
8560: POP
// repeat wait ( 0 0$1 ) ;
8561: LD_INT 35
8563: PPUSH
8564: CALL_OW 67
// until not HasTask ( Gali ) ;
8568: LD_EXP 29
8572: PPUSH
8573: CALL_OW 314
8577: NOT
8578: IFFALSE 8561
// time := 0 0$00 ;
8580: LD_ADDR_VAR 0 5
8584: PUSH
8585: LD_INT 0
8587: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8588: LD_INT 35
8590: PPUSH
8591: CALL_OW 67
// time := time + 0 0$1 ;
8595: LD_ADDR_VAR 0 5
8599: PUSH
8600: LD_VAR 0 5
8604: PUSH
8605: LD_INT 35
8607: PLUS
8608: ST_TO_ADDR
// if debug then
8609: LD_EXP 2
8613: IFFALSE 8632
// debug_strings := [ time: & time ] ;
8615: LD_ADDR_OWVAR 48
8619: PUSH
8620: LD_STRING time:
8622: PUSH
8623: LD_VAR 0 5
8627: STR
8628: PUSH
8629: EMPTY
8630: LIST
8631: ST_TO_ADDR
// if time > 8 8$00 then
8632: LD_VAR 0 5
8636: PUSH
8637: LD_INT 16800
8639: GREATER
8640: IFFALSE 8652
// begin blocked := true ;
8642: LD_ADDR_EXP 18
8646: PUSH
8647: LD_INT 1
8649: ST_TO_ADDR
// exit ;
8650: GO 9799
// end ; if not Carry ( Gali ) then
8652: LD_EXP 29
8656: PPUSH
8657: CALL_OW 281
8661: NOT
8662: IFFALSE 8685
// ComTransport ( Gali , dep , player_want_info ) else
8664: LD_EXP 29
8668: PPUSH
8669: LD_VAR 0 4
8673: PPUSH
8674: LD_EXP 13
8678: PPUSH
8679: CALL_OW 151
8683: GO 8803
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8685: LD_EXP 29
8689: PPUSH
8690: LD_VAR 0 3
8694: PUSH
8695: LD_INT 1
8697: ARRAY
8698: PPUSH
8699: CALL_OW 296
8703: PUSH
8704: LD_INT 4
8706: LESS
8707: PUSH
8708: LD_EXP 29
8712: PPUSH
8713: LD_EXP 13
8717: PPUSH
8718: CALL_OW 289
8722: AND
8723: IFFALSE 8785
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8725: LD_VAR 0 3
8729: PUSH
8730: LD_INT 1
8732: ARRAY
8733: PPUSH
8734: LD_EXP 13
8738: PPUSH
8739: LD_VAR 0 3
8743: PUSH
8744: LD_INT 1
8746: ARRAY
8747: PPUSH
8748: LD_EXP 13
8752: PPUSH
8753: CALL_OW 289
8757: PUSH
8758: LD_INT 10
8760: PLUS
8761: PPUSH
8762: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8766: LD_EXP 29
8770: PPUSH
8771: LD_EXP 13
8775: PPUSH
8776: LD_INT 0
8778: PPUSH
8779: CALL_OW 290
// end else
8783: GO 8803
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8785: LD_EXP 29
8789: PPUSH
8790: LD_VAR 0 3
8794: PUSH
8795: LD_INT 1
8797: ARRAY
8798: PPUSH
8799: CALL_OW 112
// end ; if player_attacked_ar then
8803: LD_EXP 16
8807: IFFALSE 8811
// exit ;
8809: GO 9799
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
8811: LD_VAR 0 3
8815: PUSH
8816: LD_INT 1
8818: ARRAY
8819: PPUSH
8820: LD_EXP 13
8824: PPUSH
8825: CALL_OW 289
8829: PUSH
8830: LD_VAR 0 2
8834: PUSH
8835: LD_INT 10
8837: MUL
8838: GREATEREQUAL
8839: IFFALSE 8588
// no_oil_gain := false ;
8841: LD_ADDR_VAR 0 6
8845: PUSH
8846: LD_INT 0
8848: ST_TO_ADDR
// end else
8849: GO 9440
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8851: LD_ADDR_VAR 0 3
8855: PUSH
8856: LD_INT 22
8858: PUSH
8859: LD_INT 2
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: PUSH
8866: LD_INT 21
8868: PUSH
8869: LD_INT 2
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PPUSH
8880: CALL_OW 69
8884: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8885: LD_EXP 29
8889: PPUSH
8890: LD_VAR 0 4
8894: PPUSH
8895: CALL_OW 250
8899: PUSH
8900: LD_INT 1
8902: PLUS
8903: PPUSH
8904: LD_VAR 0 4
8908: PPUSH
8909: CALL_OW 251
8913: PUSH
8914: LD_INT 1
8916: PLUS
8917: PPUSH
8918: CALL_OW 111
// time := 0 0$00 ;
8922: LD_ADDR_VAR 0 5
8926: PUSH
8927: LD_INT 0
8929: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// time := time + 0 0$1 ;
8937: LD_ADDR_VAR 0 5
8941: PUSH
8942: LD_VAR 0 5
8946: PUSH
8947: LD_INT 35
8949: PLUS
8950: ST_TO_ADDR
// if time > 1 1$45 then
8951: LD_VAR 0 5
8955: PUSH
8956: LD_INT 3675
8958: GREATER
8959: IFFALSE 8963
// break ;
8961: GO 8983
// until GetDistUnits ( Gali , dep ) < 4 ;
8963: LD_EXP 29
8967: PPUSH
8968: LD_VAR 0 4
8972: PPUSH
8973: CALL_OW 296
8977: PUSH
8978: LD_INT 4
8980: LESS
8981: IFFALSE 8930
// for i = 1 to 6 do
8983: LD_ADDR_VAR 0 1
8987: PUSH
8988: DOUBLE
8989: LD_INT 1
8991: DEC
8992: ST_TO_ADDR
8993: LD_INT 6
8995: PUSH
8996: FOR_TO
8997: IFFALSE 9201
// begin if player_attacked_ar then
8999: LD_EXP 16
9003: IFFALSE 9009
// exit ;
9005: POP
9006: POP
9007: GO 9799
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 274
9018: PPUSH
9019: LD_INT 2
9021: PPUSH
9022: CALL_OW 275
9026: PUSH
9027: LD_INT 10
9029: LESS
9030: PUSH
9031: LD_VAR 0 7
9035: NOT
9036: AND
9037: IFFALSE 9100
// begin first_warn := true ;
9039: LD_ADDR_VAR 0 7
9043: PUSH
9044: LD_INT 1
9046: ST_TO_ADDR
// DialogueOn ;
9047: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9051: LD_EXP 30
9055: PPUSH
9056: LD_STRING D9a-FAr1-1
9058: PPUSH
9059: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9063: LD_EXP 20
9067: PPUSH
9068: LD_STRING D9a-JMM-1
9070: PPUSH
9071: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9075: LD_EXP 28
9079: PPUSH
9080: LD_STRING D9a2-Ar1-1
9082: PPUSH
9083: CALL_OW 88
// DialogueOff ;
9087: CALL_OW 7
// wait ( time ) ;
9091: LD_VAR 0 5
9095: PPUSH
9096: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9100: LD_VAR 0 4
9104: PPUSH
9105: CALL_OW 274
9109: PPUSH
9110: LD_INT 2
9112: PPUSH
9113: CALL_OW 275
9117: PUSH
9118: LD_INT 10
9120: LESS
9121: IFFALSE 9147
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9123: LD_EXP 28
9127: PPUSH
9128: LD_STRING D9a3-Ar1-1
9130: PPUSH
9131: CALL_OW 88
// no_oil_gain := true ;
9135: LD_ADDR_VAR 0 6
9139: PUSH
9140: LD_INT 1
9142: ST_TO_ADDR
// break ;
9143: GO 9201
// end else
9145: GO 9199
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9147: LD_EXP 29
9151: PPUSH
9152: LD_VAR 0 4
9156: PPUSH
9157: LD_INT 2
9159: PPUSH
9160: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9164: LD_EXP 29
9168: PPUSH
9169: LD_VAR 0 3
9173: PUSH
9174: LD_VAR 0 1
9178: PUSH
9179: LD_INT 3
9181: MOD
9182: PUSH
9183: LD_INT 1
9185: PLUS
9186: ARRAY
9187: PPUSH
9188: CALL_OW 210
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// end ; end ;
9199: GO 8996
9201: POP
9202: POP
// time := 0 0$00 ;
9203: LD_ADDR_VAR 0 5
9207: PUSH
9208: LD_INT 0
9210: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9211: LD_INT 35
9213: PPUSH
9214: CALL_OW 67
// if not HasTask ( Gali ) then
9218: LD_EXP 29
9222: PPUSH
9223: CALL_OW 314
9227: NOT
9228: IFFALSE 9244
// time := time + 0 0$1 ;
9230: LD_ADDR_VAR 0 5
9234: PUSH
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 35
9242: PLUS
9243: ST_TO_ADDR
// if time > 1 1$25 then
9244: LD_VAR 0 5
9248: PUSH
9249: LD_INT 2975
9251: GREATER
9252: IFFALSE 9276
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9254: LD_EXP 28
9258: PPUSH
9259: LD_STRING D9a3-Ar1-1
9261: PPUSH
9262: CALL_OW 88
// no_oil_gain := true ;
9266: LD_ADDR_VAR 0 6
9270: PUSH
9271: LD_INT 1
9273: ST_TO_ADDR
// break ;
9274: GO 9440
// end ; if player_attacked_ar then
9276: LD_EXP 16
9280: IFFALSE 9284
// exit ;
9282: GO 9799
// for i in tmp do
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 3
9293: PUSH
9294: FOR_IN
9295: IFFALSE 9326
// if GetFuel ( i ) < 100 then
9297: LD_VAR 0 1
9301: PPUSH
9302: CALL_OW 261
9306: PUSH
9307: LD_INT 100
9309: LESS
9310: IFFALSE 9324
// begin x := i ;
9312: LD_ADDR_VAR 0 2
9316: PUSH
9317: LD_VAR 0 1
9321: ST_TO_ADDR
// break ;
9322: GO 9326
// end ;
9324: GO 9294
9326: POP
9327: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9328: LD_EXP 29
9332: PPUSH
9333: CALL_OW 314
9337: NOT
9338: PUSH
9339: LD_EXP 29
9343: PPUSH
9344: CALL_OW 281
9348: NOT
9349: AND
9350: IFFALSE 9383
// begin ComTransport ( Gali , dep , mat_oil ) ;
9352: LD_EXP 29
9356: PPUSH
9357: LD_VAR 0 4
9361: PPUSH
9362: LD_INT 2
9364: PPUSH
9365: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9369: LD_EXP 29
9373: PPUSH
9374: LD_VAR 0 2
9378: PPUSH
9379: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9383: LD_VAR 0 3
9387: PUSH
9388: LD_INT 1
9390: ARRAY
9391: PPUSH
9392: CALL_OW 261
9396: PUSH
9397: LD_INT 80
9399: GREATER
9400: PUSH
9401: LD_VAR 0 3
9405: PUSH
9406: LD_INT 2
9408: ARRAY
9409: PPUSH
9410: CALL_OW 261
9414: PUSH
9415: LD_INT 80
9417: GREATER
9418: AND
9419: PUSH
9420: LD_VAR 0 3
9424: PUSH
9425: LD_INT 3
9427: ARRAY
9428: PPUSH
9429: CALL_OW 261
9433: PUSH
9434: LD_INT 80
9436: GREATER
9437: AND
9438: IFFALSE 9211
// end ; ComHold ( Gali ) ;
9440: LD_EXP 29
9444: PPUSH
9445: CALL_OW 140
// if not no_oil_gain then
9449: LD_VAR 0 6
9453: NOT
9454: IFFALSE 9619
// begin DialogueOn ;
9456: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9460: LD_EXP 28
9464: PPUSH
9465: CALL_OW 87
// if player_want_mortar then
9469: LD_EXP 12
9473: IFFALSE 9499
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9475: LD_EXP 28
9479: PPUSH
9480: LD_STRING D9e-Ar1-1
9482: PPUSH
9483: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9487: LD_EXP 20
9491: PPUSH
9492: LD_STRING D10a-JMM-1
9494: PPUSH
9495: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9499: LD_EXP 28
9503: PPUSH
9504: LD_STRING D10a-Ar1-1
9506: PPUSH
9507: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9511: LD_EXP 29
9515: PPUSH
9516: LD_STRING D10a-Ar2-1
9518: PPUSH
9519: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9523: LD_EXP 30
9527: PPUSH
9528: LD_STRING D10a-FAr1-1
9530: PPUSH
9531: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9535: LD_EXP 29
9539: PPUSH
9540: LD_STRING D10a-Ar2-2
9542: PPUSH
9543: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9547: LD_EXP 30
9551: PPUSH
9552: LD_STRING D10a-FAr1-2
9554: PPUSH
9555: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9559: LD_EXP 28
9563: PPUSH
9564: LD_STRING D10a-Ar1-2
9566: PPUSH
9567: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9571: LD_EXP 20
9575: PPUSH
9576: LD_STRING D10a-JMM-2
9578: PPUSH
9579: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9583: LD_EXP 28
9587: PPUSH
9588: LD_STRING D10a-Ar1-3
9590: PPUSH
9591: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9595: LD_EXP 20
9599: PPUSH
9600: LD_STRING D10a-JMM-3
9602: PPUSH
9603: CALL_OW 88
// player_get_info := true ;
9607: LD_ADDR_EXP 15
9611: PUSH
9612: LD_INT 1
9614: ST_TO_ADDR
// DialogueOff ;
9615: CALL_OW 7
// end ; end ; if player_attacked_ar then
9619: LD_EXP 16
9623: IFFALSE 9627
// exit ;
9625: GO 9799
// if player_want_mortar or player_want_info then
9627: LD_EXP 12
9631: PUSH
9632: LD_EXP 13
9636: OR
9637: IFFALSE 9651
// Say ( Vervecken , D9f-Ar1-1 ) ;
9639: LD_EXP 28
9643: PPUSH
9644: LD_STRING D9f-Ar1-1
9646: PPUSH
9647: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9651: LD_INT 22
9653: PUSH
9654: LD_INT 2
9656: PUSH
9657: EMPTY
9658: LIST
9659: LIST
9660: PPUSH
9661: CALL_OW 69
9665: PPUSH
9666: LD_INT 51
9668: PPUSH
9669: LD_INT 99
9671: PPUSH
9672: CALL_OW 111
// wait ( 0 0$1 ) ;
9676: LD_INT 35
9678: PPUSH
9679: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9683: LD_INT 22
9685: PUSH
9686: LD_INT 2
9688: PUSH
9689: EMPTY
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 92
9695: PUSH
9696: LD_INT 51
9698: PUSH
9699: LD_INT 99
9701: PUSH
9702: LD_INT 2
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PPUSH
9715: CALL_OW 69
9719: IFFALSE 9779
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9721: LD_ADDR_VAR 0 1
9725: PUSH
9726: LD_INT 22
9728: PUSH
9729: LD_INT 2
9731: PUSH
9732: EMPTY
9733: LIST
9734: LIST
9735: PUSH
9736: LD_INT 92
9738: PUSH
9739: LD_INT 51
9741: PUSH
9742: LD_INT 99
9744: PUSH
9745: LD_INT 2
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: PPUSH
9758: CALL_OW 69
9762: PUSH
9763: FOR_IN
9764: IFFALSE 9777
// RemoveUnit ( i ) ;
9766: LD_VAR 0 1
9770: PPUSH
9771: CALL_OW 64
9775: GO 9763
9777: POP
9778: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9779: LD_INT 22
9781: PUSH
9782: LD_INT 2
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PPUSH
9789: CALL_OW 69
9793: PUSH
9794: LD_INT 0
9796: EQUAL
9797: IFFALSE 9651
// end ;
9799: PPOPN 10
9801: END
// every 0 0$01 trigger blocked do var i ;
9802: LD_EXP 18
9806: IFFALSE 9974
9808: GO 9810
9810: DISABLE
9811: LD_INT 0
9813: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9814: LD_EXP 28
9818: PPUSH
9819: LD_STRING D9f-Ar1-1
9821: PPUSH
9822: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9826: LD_INT 22
9828: PUSH
9829: LD_INT 2
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: CALL_OW 69
9840: PPUSH
9841: LD_INT 51
9843: PPUSH
9844: LD_INT 99
9846: PPUSH
9847: CALL_OW 111
// wait ( 0 0$1 ) ;
9851: LD_INT 35
9853: PPUSH
9854: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9858: LD_INT 22
9860: PUSH
9861: LD_INT 2
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PUSH
9868: LD_INT 92
9870: PUSH
9871: LD_INT 51
9873: PUSH
9874: LD_INT 99
9876: PUSH
9877: LD_INT 2
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: LIST
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PPUSH
9890: CALL_OW 69
9894: IFFALSE 9954
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9896: LD_ADDR_VAR 0 1
9900: PUSH
9901: LD_INT 22
9903: PUSH
9904: LD_INT 2
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: PUSH
9911: LD_INT 92
9913: PUSH
9914: LD_INT 51
9916: PUSH
9917: LD_INT 99
9919: PUSH
9920: LD_INT 2
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL_OW 69
9937: PUSH
9938: FOR_IN
9939: IFFALSE 9952
// RemoveUnit ( i ) ;
9941: LD_VAR 0 1
9945: PPUSH
9946: CALL_OW 64
9950: GO 9938
9952: POP
9953: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9954: LD_INT 22
9956: PUSH
9957: LD_INT 2
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PPUSH
9964: CALL_OW 69
9968: PUSH
9969: LD_INT 0
9971: EQUAL
9972: IFFALSE 9826
// end ;
9974: PPOPN 1
9976: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9977: LD_EXP 16
9981: IFFALSE 10334
9983: GO 9985
9985: DISABLE
9986: LD_INT 0
9988: PPUSH
9989: PPUSH
9990: PPUSH
9991: PPUSH
// begin ru_can_attack := true ;
9992: LD_ADDR_EXP 8
9996: PUSH
9997: LD_INT 1
9999: ST_TO_ADDR
// mine_launched := false ;
10000: LD_ADDR_VAR 0 3
10004: PUSH
10005: LD_INT 0
10007: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10008: LD_INT 22
10010: PUSH
10011: LD_INT 2
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: PPUSH
10018: CALL_OW 69
10022: PPUSH
10023: LD_INT 51
10025: PPUSH
10026: LD_INT 99
10028: PPUSH
10029: CALL_OW 111
// if IsOk ( Vervecken ) then
10033: LD_EXP 28
10037: PPUSH
10038: CALL_OW 302
10042: IFFALSE 10056
// Say ( Vervecken , D11a-Ar1-1 ) ;
10044: LD_EXP 28
10048: PPUSH
10049: LD_STRING D11a-Ar1-1
10051: PPUSH
10052: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10056: LD_ADDR_VAR 0 2
10060: PUSH
10061: LD_EXP 35
10065: PPUSH
10066: LD_INT 25
10068: PUSH
10069: LD_INT 1
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PPUSH
10076: CALL_OW 72
10080: ST_TO_ADDR
// for i in tmp do
10081: LD_ADDR_VAR 0 1
10085: PUSH
10086: LD_VAR 0 2
10090: PUSH
10091: FOR_IN
10092: IFFALSE 10155
// if MineOfUnit ( i ) then
10094: LD_VAR 0 1
10098: PPUSH
10099: CALL_OW 459
10103: IFFALSE 10153
// begin x := MineOfUnit ( i ) ;
10105: LD_ADDR_VAR 0 4
10109: PUSH
10110: LD_VAR 0 1
10114: PPUSH
10115: CALL_OW 459
10119: ST_TO_ADDR
// mine_launched := true ;
10120: LD_ADDR_VAR 0 3
10124: PUSH
10125: LD_INT 1
10127: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10128: LD_VAR 0 4
10132: PUSH
10133: LD_INT 1
10135: ARRAY
10136: PPUSH
10137: LD_VAR 0 4
10141: PUSH
10142: LD_INT 2
10144: ARRAY
10145: PPUSH
10146: LD_INT 2
10148: PPUSH
10149: CALL_OW 456
// end ;
10153: GO 10091
10155: POP
10156: POP
// if mine_launched and IsOk ( Vervecken ) then
10157: LD_VAR 0 3
10161: PUSH
10162: LD_EXP 28
10166: PPUSH
10167: CALL_OW 302
10171: AND
10172: IFFALSE 10186
// Say ( Vervecken , D11b-Ar1-1 ) ;
10174: LD_EXP 28
10178: PPUSH
10179: LD_STRING D11b-Ar1-1
10181: PPUSH
10182: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10186: LD_INT 22
10188: PUSH
10189: LD_INT 2
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PPUSH
10196: CALL_OW 69
10200: PPUSH
10201: LD_INT 51
10203: PPUSH
10204: LD_INT 99
10206: PPUSH
10207: CALL_OW 111
// wait ( 0 0$1 ) ;
10211: LD_INT 35
10213: PPUSH
10214: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10218: LD_INT 22
10220: PUSH
10221: LD_INT 2
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 92
10230: PUSH
10231: LD_INT 51
10233: PUSH
10234: LD_INT 99
10236: PUSH
10237: LD_INT 2
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: IFFALSE 10314
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10256: LD_ADDR_VAR 0 1
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 92
10273: PUSH
10274: LD_INT 51
10276: PUSH
10277: LD_INT 99
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PPUSH
10293: CALL_OW 69
10297: PUSH
10298: FOR_IN
10299: IFFALSE 10312
// RemoveUnit ( i ) ;
10301: LD_VAR 0 1
10305: PPUSH
10306: CALL_OW 64
10310: GO 10298
10312: POP
10313: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10314: LD_INT 22
10316: PUSH
10317: LD_INT 2
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: CALL_OW 69
10328: PUSH
10329: LD_INT 0
10331: EQUAL
10332: IFFALSE 10186
// end ;
10334: PPOPN 4
10336: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10337: LD_EXP 10
10341: IFFALSE 10520
10343: GO 10345
10345: DISABLE
10346: LD_INT 0
10348: PPUSH
// begin Wait ( 10 10$00 ) ;
10349: LD_INT 21000
10351: PPUSH
10352: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10356: LD_INT 22
10358: PUSH
10359: LD_INT 2
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PPUSH
10366: CALL_OW 69
10370: IFFALSE 10520
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10372: LD_INT 22
10374: PUSH
10375: LD_INT 2
10377: PUSH
10378: EMPTY
10379: LIST
10380: LIST
10381: PPUSH
10382: CALL_OW 69
10386: PPUSH
10387: LD_INT 51
10389: PPUSH
10390: LD_INT 99
10392: PPUSH
10393: CALL_OW 114
// wait ( 0 0$1 ) ;
10397: LD_INT 35
10399: PPUSH
10400: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10404: LD_INT 22
10406: PUSH
10407: LD_INT 2
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: PUSH
10414: LD_INT 92
10416: PUSH
10417: LD_INT 51
10419: PUSH
10420: LD_INT 99
10422: PUSH
10423: LD_INT 2
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: PUSH
10432: EMPTY
10433: LIST
10434: LIST
10435: PPUSH
10436: CALL_OW 69
10440: IFFALSE 10500
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10442: LD_ADDR_VAR 0 1
10446: PUSH
10447: LD_INT 22
10449: PUSH
10450: LD_INT 2
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PUSH
10457: LD_INT 92
10459: PUSH
10460: LD_INT 51
10462: PUSH
10463: LD_INT 99
10465: PUSH
10466: LD_INT 2
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: LIST
10473: LIST
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PPUSH
10479: CALL_OW 69
10483: PUSH
10484: FOR_IN
10485: IFFALSE 10498
// RemoveUnit ( i ) ;
10487: LD_VAR 0 1
10491: PPUSH
10492: CALL_OW 64
10496: GO 10484
10498: POP
10499: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10500: LD_INT 22
10502: PUSH
10503: LD_INT 2
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: PPUSH
10510: CALL_OW 69
10514: PUSH
10515: LD_INT 0
10517: EQUAL
10518: IFFALSE 10372
// end ; end ;
10520: PPOPN 1
10522: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10523: LD_EXP 4
10527: IFFALSE 11536
10529: GO 10531
10531: DISABLE
10532: LD_INT 0
10534: PPUSH
10535: PPUSH
10536: PPUSH
10537: PPUSH
10538: PPUSH
10539: PPUSH
// begin Wait ( game_time ) ;
10540: LD_EXP 7
10544: PPUSH
10545: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10549: LD_INT 35
10551: PPUSH
10552: CALL_OW 67
// until ( not ru_can_attack ) ;
10556: LD_EXP 8
10560: NOT
10561: IFFALSE 10549
// Wait ( 0 0$35 ) ;
10563: LD_INT 1225
10565: PPUSH
10566: CALL_OW 67
// DialogueOn ;
10570: CALL_OW 6
// InGameOn ;
10574: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10578: LD_EXP 27
10582: PPUSH
10583: LD_STRING D12-Pow-1
10585: PPUSH
10586: CALL_OW 94
// InGameOff ;
10590: CALL_OW 9
// DialogueOff ;
10594: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10598: LD_STRING M4
10600: PPUSH
10601: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10605: LD_INT 5
10607: PPUSH
10608: LD_INT 1
10610: PPUSH
10611: CALL_OW 424
// can_end := true ;
10615: LD_ADDR_EXP 17
10619: PUSH
10620: LD_INT 1
10622: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10623: LD_INT 35
10625: PPUSH
10626: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10630: CALL 824 0 0
10634: PUSH
10635: LD_INT 20
10637: GREATEREQUAL
10638: PUSH
10639: LD_INT 22
10641: PUSH
10642: LD_INT 1
10644: PUSH
10645: EMPTY
10646: LIST
10647: LIST
10648: PUSH
10649: LD_INT 21
10651: PUSH
10652: LD_INT 1
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 69
10667: PUSH
10668: LD_INT 5
10670: PPUSH
10671: LD_INT 22
10673: PUSH
10674: LD_INT 1
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: PUSH
10681: LD_INT 21
10683: PUSH
10684: LD_INT 1
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PPUSH
10695: CALL_OW 70
10699: PUSH
10700: LD_INT 22
10702: PUSH
10703: LD_INT 1
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PUSH
10710: LD_INT 55
10712: PUSH
10713: EMPTY
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: PLUS
10725: LESSEQUAL
10726: AND
10727: IFFALSE 10623
// if not player_get_info then
10729: LD_EXP 15
10733: NOT
10734: IFFALSE 10745
// player_get_info := - 1 ;
10736: LD_ADDR_EXP 15
10740: PUSH
10741: LD_INT 1
10743: NEG
10744: ST_TO_ADDR
// m1 := player_get_info > 0 ;
10745: LD_ADDR_VAR 0 4
10749: PUSH
10750: LD_EXP 15
10754: PUSH
10755: LD_INT 0
10757: GREATER
10758: ST_TO_ADDR
// m2 := false ;
10759: LD_ADDR_VAR 0 5
10763: PUSH
10764: LD_INT 0
10766: ST_TO_ADDR
// m3 := earlySib ;
10767: LD_ADDR_VAR 0 6
10771: PUSH
10772: LD_EXP 19
10776: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10777: LD_STRING Information
10779: PPUSH
10780: LD_EXP 15
10784: PPUSH
10785: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10789: LD_ADDR_VAR 0 2
10793: PUSH
10794: LD_INT 22
10796: PUSH
10797: LD_INT 1
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 2
10806: PUSH
10807: LD_INT 25
10809: PUSH
10810: LD_INT 2
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: LD_INT 25
10819: PUSH
10820: LD_INT 16
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: LD_INT 34
10829: PUSH
10830: LD_INT 12
10832: PUSH
10833: EMPTY
10834: LIST
10835: LIST
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: LIST
10841: LIST
10842: PUSH
10843: EMPTY
10844: LIST
10845: LIST
10846: PPUSH
10847: CALL_OW 69
10851: ST_TO_ADDR
// sib := GetTerminalCargo ;
10852: LD_ADDR_VAR 0 3
10856: PUSH
10857: CALL 824 0 0
10861: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10862: LD_ADDR_VAR 0 3
10866: PUSH
10867: LD_VAR 0 3
10871: PUSH
10872: LD_INT 6
10874: PPUSH
10875: LD_INT 3
10877: PPUSH
10878: CALL_OW 287
10882: PLUS
10883: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10884: LD_ADDR_VAR 0 3
10888: PUSH
10889: LD_VAR 0 3
10893: PUSH
10894: LD_VAR 0 2
10898: PPUSH
10899: LD_INT 3
10901: PPUSH
10902: CALL_OW 289
10906: PLUS
10907: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10908: LD_VAR 0 3
10912: PUSH
10913: LD_INT 2
10915: PUSH
10916: LD_OWVAR 67
10920: PLUS
10921: PUSH
10922: LD_INT 50
10924: MUL
10925: LESS
10926: IFFALSE 10951
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10928: LD_STRING MuchSiberite
10930: PPUSH
10931: LD_INT 2
10933: NEG
10934: PUSH
10935: LD_OWVAR 67
10939: MUL
10940: PUSH
10941: LD_INT 1
10943: PLUS
10944: PPUSH
10945: CALL_OW 101
10949: GO 10969
// begin AddMedal ( MuchSiberite , 1 ) ;
10951: LD_STRING MuchSiberite
10953: PPUSH
10954: LD_INT 1
10956: PPUSH
10957: CALL_OW 101
// m2 := true ;
10961: LD_ADDR_VAR 0 5
10965: PUSH
10966: LD_INT 1
10968: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
10969: LD_VAR 0 4
10973: PUSH
10974: LD_VAR 0 5
10978: AND
10979: PUSH
10980: LD_VAR 0 6
10984: AND
10985: PUSH
10986: LD_OWVAR 67
10990: PUSH
10991: LD_INT 3
10993: EQUAL
10994: AND
10995: IFFALSE 11007
// SetAchievementEX ( ACH_AMER , 9 ) ;
10997: LD_STRING ACH_AMER
10999: PPUSH
11000: LD_INT 9
11002: PPUSH
11003: CALL_OW 564
// GiveMedals ( MAIN ) ;
11007: LD_STRING MAIN
11009: PPUSH
11010: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11014: LD_INT 22
11016: PUSH
11017: LD_INT 1
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 2
11026: PUSH
11027: LD_INT 25
11029: PUSH
11030: LD_INT 1
11032: PUSH
11033: EMPTY
11034: LIST
11035: LIST
11036: PUSH
11037: LD_INT 25
11039: PUSH
11040: LD_INT 2
11042: PUSH
11043: EMPTY
11044: LIST
11045: LIST
11046: PUSH
11047: LD_INT 25
11049: PUSH
11050: LD_INT 3
11052: PUSH
11053: EMPTY
11054: LIST
11055: LIST
11056: PUSH
11057: LD_INT 25
11059: PUSH
11060: LD_INT 4
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PUSH
11067: LD_INT 25
11069: PUSH
11070: LD_INT 8
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: PUSH
11077: EMPTY
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: PUSH
11085: EMPTY
11086: LIST
11087: LIST
11088: PPUSH
11089: CALL_OW 69
11093: PPUSH
11094: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11098: LD_ADDR_VAR 0 2
11102: PUSH
11103: LD_INT 22
11105: PUSH
11106: LD_INT 1
11108: PUSH
11109: EMPTY
11110: LIST
11111: LIST
11112: PUSH
11113: LD_INT 25
11115: PUSH
11116: LD_INT 8
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: PPUSH
11127: CALL_OW 69
11131: ST_TO_ADDR
// if tmp then
11132: LD_VAR 0 2
11136: IFFALSE 11167
// for i in tmp do
11138: LD_ADDR_VAR 0 1
11142: PUSH
11143: LD_VAR 0 2
11147: PUSH
11148: FOR_IN
11149: IFFALSE 11165
// SetClass ( i , 1 ) ;
11151: LD_VAR 0 1
11155: PPUSH
11156: LD_INT 1
11158: PPUSH
11159: CALL_OW 336
11163: GO 11148
11165: POP
11166: POP
// SaveVariable ( sib , 09_sibRes ) ;
11167: LD_VAR 0 3
11171: PPUSH
11172: LD_STRING 09_sibRes
11174: PPUSH
11175: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11179: LD_EXP 15
11183: PPUSH
11184: LD_STRING 09_arInfo
11186: PPUSH
11187: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11191: LD_EXP 20
11195: PPUSH
11196: LD_EXP 1
11200: PUSH
11201: LD_STRING JMM
11203: STR
11204: PPUSH
11205: CALL_OW 38
// if IsLive ( Gary ) then
11209: LD_EXP 21
11213: PPUSH
11214: CALL_OW 300
11218: IFFALSE 11238
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11220: LD_EXP 21
11224: PPUSH
11225: LD_EXP 1
11229: PUSH
11230: LD_STRING Gary
11232: STR
11233: PPUSH
11234: CALL_OW 38
// if IsLive ( Bobby ) then
11238: LD_EXP 22
11242: PPUSH
11243: CALL_OW 300
11247: IFFALSE 11267
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11249: LD_EXP 22
11253: PPUSH
11254: LD_EXP 1
11258: PUSH
11259: LD_STRING Bobby
11261: STR
11262: PPUSH
11263: CALL_OW 38
// if IsLive ( Cyrus ) then
11267: LD_EXP 23
11271: PPUSH
11272: CALL_OW 300
11276: IFFALSE 11296
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11278: LD_EXP 23
11282: PPUSH
11283: LD_EXP 1
11287: PUSH
11288: LD_STRING Cyrus
11290: STR
11291: PPUSH
11292: CALL_OW 38
// if IsLive ( Houten ) then
11296: LD_EXP 24
11300: PPUSH
11301: CALL_OW 300
11305: IFFALSE 11325
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11307: LD_EXP 24
11311: PPUSH
11312: LD_EXP 1
11316: PUSH
11317: LD_STRING Houten
11319: STR
11320: PPUSH
11321: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11325: LD_ADDR_VAR 0 2
11329: PUSH
11330: LD_INT 22
11332: PUSH
11333: LD_INT 1
11335: PUSH
11336: EMPTY
11337: LIST
11338: LIST
11339: PUSH
11340: LD_INT 2
11342: PUSH
11343: LD_INT 25
11345: PUSH
11346: LD_INT 1
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 3
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 25
11375: PUSH
11376: LD_INT 4
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PPUSH
11394: CALL_OW 69
11398: PUSH
11399: LD_EXP 20
11403: PUSH
11404: LD_EXP 23
11408: PUSH
11409: LD_EXP 22
11413: PUSH
11414: LD_EXP 24
11418: PUSH
11419: LD_EXP 21
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: DIFF
11431: ST_TO_ADDR
// if tmp then
11432: LD_VAR 0 2
11436: IFFALSE 11456
// SaveCharacters ( tmp , mission_prefix & others ) ;
11438: LD_VAR 0 2
11442: PPUSH
11443: LD_EXP 1
11447: PUSH
11448: LD_STRING others
11450: STR
11451: PPUSH
11452: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11456: LD_ADDR_VAR 0 2
11460: PUSH
11461: LD_INT 22
11463: PUSH
11464: LD_INT 1
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: PUSH
11471: LD_INT 2
11473: PUSH
11474: LD_INT 25
11476: PUSH
11477: LD_INT 12
11479: PUSH
11480: EMPTY
11481: LIST
11482: LIST
11483: PUSH
11484: LD_INT 25
11486: PUSH
11487: LD_INT 16
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: PPUSH
11503: CALL_OW 69
11507: ST_TO_ADDR
// if tmp then
11508: LD_VAR 0 2
11512: IFFALSE 11532
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11514: LD_VAR 0 2
11518: PPUSH
11519: LD_EXP 1
11523: PUSH
11524: LD_STRING apes
11526: STR
11527: PPUSH
11528: CALL_OW 38
// YouWin ;
11532: CALL_OW 103
// end ; end_of_file
11536: PPOPN 6
11538: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11539: LD_VAR 0 1
11543: PPUSH
11544: CALL_OW 266
11548: PUSH
11549: LD_INT 0
11551: EQUAL
11552: PUSH
11553: LD_EXP 3
11557: NOT
11558: AND
11559: IFFALSE 11583
// begin terminal := b ;
11561: LD_ADDR_EXP 3
11565: PUSH
11566: LD_VAR 0 1
11570: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11571: LD_EXP 3
11575: PPUSH
11576: LD_STRING terminal
11578: PPUSH
11579: CALL_OW 500
// end ; end ;
11583: PPOPN 2
11585: END
// on BuildingComplete ( b ) do var i ;
11586: LD_INT 0
11588: PPUSH
// begin if GetSide ( b ) = 3 then
11589: LD_VAR 0 1
11593: PPUSH
11594: CALL_OW 255
11598: PUSH
11599: LD_INT 3
11601: EQUAL
11602: IFFALSE 11642
// for i = 1 to 4 do
11604: LD_ADDR_VAR 0 2
11608: PUSH
11609: DOUBLE
11610: LD_INT 1
11612: DEC
11613: ST_TO_ADDR
11614: LD_INT 4
11616: PUSH
11617: FOR_TO
11618: IFFALSE 11640
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11620: LD_ADDR_EXP 38
11624: PUSH
11625: LD_EXP 38
11629: PPUSH
11630: LD_INT 1
11632: PPUSH
11633: CALL_OW 3
11637: ST_TO_ADDR
11638: GO 11617
11640: POP
11641: POP
// end ;
11642: PPOPN 2
11644: END
// on VehicleConstructed ( veh , fac ) do var i ;
11645: LD_INT 0
11647: PPUSH
// begin if GetSide ( veh ) = 3 then
11648: LD_VAR 0 1
11652: PPUSH
11653: CALL_OW 255
11657: PUSH
11658: LD_INT 3
11660: EQUAL
11661: IFFALSE 11786
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11663: LD_VAR 0 1
11667: PPUSH
11668: CALL_OW 264
11672: PUSH
11673: LD_INT 53
11675: PUSH
11676: LD_INT 52
11678: PUSH
11679: LD_INT 51
11681: PUSH
11682: EMPTY
11683: LIST
11684: LIST
11685: LIST
11686: IN
11687: NOT
11688: IFFALSE 11706
// ru_force := ru_force ^ veh ;
11690: LD_ADDR_EXP 37
11694: PUSH
11695: LD_EXP 37
11699: PUSH
11700: LD_VAR 0 1
11704: ADD
11705: ST_TO_ADDR
// for i = 1 to 4 do
11706: LD_ADDR_VAR 0 3
11710: PUSH
11711: DOUBLE
11712: LD_INT 1
11714: DEC
11715: ST_TO_ADDR
11716: LD_INT 4
11718: PUSH
11719: FOR_TO
11720: IFFALSE 11742
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11722: LD_ADDR_EXP 39
11726: PUSH
11727: LD_EXP 39
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: CALL_OW 3
11739: ST_TO_ADDR
11740: GO 11719
11742: POP
11743: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 264
11753: PUSH
11754: LD_INT 53
11756: EQUAL
11757: IFFALSE 11786
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: LD_INT 7
11766: PPUSH
11767: CALL 982 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11771: LD_VAR 0 1
11775: PPUSH
11776: LD_INT 170
11778: PPUSH
11779: LD_INT 235
11781: PPUSH
11782: CALL_OW 171
// end ; end ; end ;
11786: PPOPN 3
11788: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: EQUAL
11797: PUSH
11798: LD_VAR 0 2
11802: PUSH
11803: LD_INT 2
11805: EQUAL
11806: AND
11807: PUSH
11808: LD_VAR 0 1
11812: PUSH
11813: LD_INT 2
11815: EQUAL
11816: PUSH
11817: LD_VAR 0 2
11821: PUSH
11822: LD_INT 1
11824: EQUAL
11825: AND
11826: OR
11827: IFFALSE 11837
// player_attacked_ar := true ;
11829: LD_ADDR_EXP 16
11833: PUSH
11834: LD_INT 1
11836: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11837: LD_VAR 0 1
11841: PUSH
11842: LD_INT 1
11844: EQUAL
11845: PUSH
11846: LD_VAR 0 2
11850: PUSH
11851: LD_INT 4
11853: EQUAL
11854: AND
11855: PUSH
11856: LD_VAR 0 1
11860: PUSH
11861: LD_INT 4
11863: EQUAL
11864: PUSH
11865: LD_VAR 0 2
11869: PUSH
11870: LD_INT 1
11872: EQUAL
11873: AND
11874: OR
11875: IFFALSE 11884
// YouLost ( Traitor ) ;
11877: LD_STRING Traitor
11879: PPUSH
11880: CALL_OW 104
// end ;
11884: PPOPN 2
11886: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11887: LD_VAR 0 1
11891: PUSH
11892: LD_EXP 20
11896: EQUAL
11897: IFFALSE 11906
// YouLost ( JMM ) ;
11899: LD_STRING JMM
11901: PPUSH
11902: CALL_OW 104
// if un = terminal then
11906: LD_VAR 0 1
11910: PUSH
11911: LD_EXP 3
11915: EQUAL
11916: IFFALSE 11925
// YouLost ( Terminal ) ;
11918: LD_STRING Terminal
11920: PPUSH
11921: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11925: LD_VAR 0 1
11929: PUSH
11930: LD_INT 22
11932: PUSH
11933: LD_INT 3
11935: PUSH
11936: EMPTY
11937: LIST
11938: LIST
11939: PUSH
11940: LD_INT 21
11942: PUSH
11943: LD_INT 3
11945: PUSH
11946: EMPTY
11947: LIST
11948: LIST
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: PPUSH
11954: CALL_OW 69
11958: IN
11959: IFFALSE 12105
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 266
11970: PUSH
11971: LD_INT 33
11973: PUSH
11974: LD_INT 26
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: IN
11981: IFFALSE 12040
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11983: LD_ADDR_EXP 38
11987: PUSH
11988: LD_EXP 38
11992: PUSH
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 266
12002: PUSH
12003: LD_VAR 0 1
12007: PPUSH
12008: CALL_OW 250
12012: PUSH
12013: LD_VAR 0 1
12017: PPUSH
12018: CALL_OW 251
12022: PUSH
12023: LD_VAR 0 1
12027: PPUSH
12028: CALL_OW 254
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: ADD
12039: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12040: LD_VAR 0 1
12044: PPUSH
12045: CALL_OW 266
12049: PUSH
12050: LD_INT 5
12052: EQUAL
12053: IFFALSE 12105
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12055: LD_ADDR_EXP 38
12059: PUSH
12060: LD_EXP 38
12064: PUSH
12065: LD_INT 4
12067: PUSH
12068: LD_VAR 0 1
12072: PPUSH
12073: CALL_OW 250
12077: PUSH
12078: LD_VAR 0 1
12082: PPUSH
12083: CALL_OW 251
12087: PUSH
12088: LD_VAR 0 1
12092: PPUSH
12093: CALL_OW 254
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: LIST
12102: LIST
12103: ADD
12104: ST_TO_ADDR
// end ; if un in ru_force then
12105: LD_VAR 0 1
12109: PUSH
12110: LD_EXP 37
12114: IN
12115: IFFALSE 12151
// begin ru_force := ru_force diff un ;
12117: LD_ADDR_EXP 37
12121: PUSH
12122: LD_EXP 37
12126: PUSH
12127: LD_VAR 0 1
12131: DIFF
12132: ST_TO_ADDR
// if ru_force = 0 then
12133: LD_EXP 37
12137: PUSH
12138: LD_INT 0
12140: EQUAL
12141: IFFALSE 12151
// ru_can_attack := false ;
12143: LD_ADDR_EXP 8
12147: PUSH
12148: LD_INT 0
12150: ST_TO_ADDR
// end ; end ;
12151: PPOPN 1
12153: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12154: LD_VAR 0 1
12158: PPUSH
12159: CALL 17481 0 1
// end ; end_of_file
12163: PPOPN 1
12165: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12166: LD_EXP 5
12170: PUSH
12171: LD_EXP 6
12175: AND
12176: IFFALSE 12261
12178: GO 12180
12180: DISABLE
12181: LD_INT 0
12183: PPUSH
// begin enable ;
12184: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12185: LD_ADDR_VAR 0 1
12189: PUSH
12190: LD_INT 60
12192: PUSH
12193: CALL 824 0 0
12197: MINUS
12198: ST_TO_ADDR
// if sib < 0 then
12199: LD_VAR 0 1
12203: PUSH
12204: LD_INT 0
12206: LESS
12207: IFFALSE 12217
// sib := 0 ;
12209: LD_ADDR_VAR 0 1
12213: PUSH
12214: LD_INT 0
12216: ST_TO_ADDR
// if not debug then
12217: LD_EXP 2
12221: NOT
12222: IFFALSE 12247
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12224: LD_ADDR_OWVAR 47
12228: PUSH
12229: LD_STRING #Am09-1
12231: PUSH
12232: LD_VAR 0 1
12236: PUSH
12237: LD_EXP 6
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12247: LD_ADDR_EXP 6
12251: PUSH
12252: LD_EXP 6
12256: PUSH
12257: LD_INT 35
12259: MINUS
12260: ST_TO_ADDR
// end ;
12261: PPOPN 1
12263: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12264: LD_EXP 6
12268: PUSH
12269: LD_INT 0
12271: EQUAL
12272: IFFALSE 12284
12274: GO 12276
12276: DISABLE
// display_strings := [ ] ;
12277: LD_ADDR_OWVAR 47
12281: PUSH
12282: EMPTY
12283: ST_TO_ADDR
12284: END
// every 1 1$35 do var i , tmp ;
12285: GO 12287
12287: DISABLE
12288: LD_INT 0
12290: PPUSH
12291: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12292: LD_ADDR_VAR 0 2
12296: PUSH
12297: LD_INT 1155
12299: PUSH
12300: LD_INT 1225
12302: PUSH
12303: LD_INT 1435
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: LIST
12310: PUSH
12311: LD_OWVAR 67
12315: ARRAY
12316: ST_TO_ADDR
// i := 0 ;
12317: LD_ADDR_VAR 0 1
12321: PUSH
12322: LD_INT 0
12324: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12325: LD_INT 1
12327: PPUSH
12328: LD_INT 5
12330: PPUSH
12331: CALL_OW 12
12335: PPUSH
12336: LD_INT 75
12338: PPUSH
12339: LD_INT 75
12341: PPUSH
12342: LD_INT 20
12344: PPUSH
12345: LD_INT 1
12347: PPUSH
12348: CALL_OW 56
// wait ( tmp ) ;
12352: LD_VAR 0 2
12356: PPUSH
12357: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12361: LD_ADDR_VAR 0 2
12365: PUSH
12366: LD_VAR 0 2
12370: PUSH
12371: LD_INT 105
12373: PPUSH
12374: LD_INT 315
12376: PPUSH
12377: CALL_OW 12
12381: PLUS
12382: ST_TO_ADDR
// i := i + 1 ;
12383: LD_ADDR_VAR 0 1
12387: PUSH
12388: LD_VAR 0 1
12392: PUSH
12393: LD_INT 1
12395: PLUS
12396: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12397: LD_VAR 0 1
12401: PUSH
12402: LD_INT 3
12404: MOD
12405: PUSH
12406: LD_INT 0
12408: EQUAL
12409: PUSH
12410: LD_EXP 4
12414: AND
12415: IFFALSE 12453
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12417: LD_INT 2
12419: PPUSH
12420: LD_INT 5
12422: PPUSH
12423: CALL_OW 12
12427: PPUSH
12428: LD_INT 8
12430: PPUSH
12431: LD_INT 1
12433: PPUSH
12434: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12438: LD_INT 665
12440: PPUSH
12441: LD_INT 735
12443: PPUSH
12444: CALL_OW 12
12448: PPUSH
12449: CALL_OW 67
// end ; until tick > game_time ;
12453: LD_OWVAR 1
12457: PUSH
12458: LD_EXP 7
12462: GREATER
12463: IFFALSE 12325
// end ; end_of_file
12465: PPOPN 2
12467: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12468: LD_INT 0
12470: PPUSH
12471: PPUSH
12472: PPUSH
12473: PPUSH
12474: PPUSH
12475: PPUSH
// x := 76 ;
12476: LD_ADDR_VAR 0 5
12480: PUSH
12481: LD_INT 76
12483: ST_TO_ADDR
// y := 147 ;
12484: LD_ADDR_VAR 0 6
12488: PUSH
12489: LD_INT 147
12491: ST_TO_ADDR
// uc_side := 2 ;
12492: LD_ADDR_OWVAR 20
12496: PUSH
12497: LD_INT 2
12499: ST_TO_ADDR
// uc_nation := 2 ;
12500: LD_ADDR_OWVAR 21
12504: PUSH
12505: LD_INT 2
12507: ST_TO_ADDR
// InitHc ;
12508: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12512: LD_INT 1
12514: PPUSH
12515: LD_INT 1
12517: PPUSH
12518: LD_INT 6
12520: PPUSH
12521: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12525: LD_ADDR_OWVAR 26
12529: PUSH
12530: LD_STRING Nicolas Vervecken
12532: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12533: LD_ADDR_OWVAR 33
12537: PUSH
12538: LD_STRING SecondCharsGal
12540: ST_TO_ADDR
// hc_face_number := 3 ;
12541: LD_ADDR_OWVAR 34
12545: PUSH
12546: LD_INT 3
12548: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12549: LD_ADDR_OWVAR 29
12553: PUSH
12554: LD_INT 11
12556: PUSH
12557: LD_INT 10
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: ST_TO_ADDR
// Vervecken := CreateHuman ;
12564: LD_ADDR_EXP 28
12568: PUSH
12569: CALL_OW 44
12573: ST_TO_ADDR
// ar_force := Vervecken ;
12574: LD_ADDR_EXP 35
12578: PUSH
12579: LD_EXP 28
12583: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12584: LD_INT 1
12586: PPUSH
12587: LD_INT 2
12589: PPUSH
12590: LD_INT 6
12592: PPUSH
12593: CALL_OW 380
// hc_name := Louis Gali ;
12597: LD_ADDR_OWVAR 26
12601: PUSH
12602: LD_STRING Louis Gali
12604: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12605: LD_ADDR_OWVAR 33
12609: PUSH
12610: LD_STRING SecondCharsGal
12612: ST_TO_ADDR
// hc_face_number := 2 ;
12613: LD_ADDR_OWVAR 34
12617: PUSH
12618: LD_INT 2
12620: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12621: LD_ADDR_OWVAR 29
12625: PUSH
12626: LD_INT 10
12628: PUSH
12629: LD_INT 11
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: ST_TO_ADDR
// Gali := CreateHuman ;
12636: LD_ADDR_EXP 29
12640: PUSH
12641: CALL_OW 44
12645: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12646: LD_ADDR_EXP 35
12650: PUSH
12651: LD_EXP 35
12655: PUSH
12656: LD_EXP 29
12660: ADD
12661: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12662: LD_INT 2
12664: PPUSH
12665: LD_INT 1
12667: PPUSH
12668: LD_INT 6
12670: PPUSH
12671: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12675: LD_ADDR_OWVAR 26
12679: PUSH
12680: LD_STRING Maria Bogdanovic
12682: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12683: LD_ADDR_OWVAR 33
12687: PUSH
12688: LD_STRING SecondCharsGal
12690: ST_TO_ADDR
// hc_face_number := 14 ;
12691: LD_ADDR_OWVAR 34
12695: PUSH
12696: LD_INT 14
12698: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12699: LD_ADDR_OWVAR 29
12703: PUSH
12704: LD_INT 12
12706: PUSH
12707: LD_INT 9
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12714: LD_ADDR_EXP 30
12718: PUSH
12719: CALL_OW 44
12723: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12724: LD_ADDR_EXP 35
12728: PUSH
12729: LD_EXP 35
12733: PUSH
12734: LD_EXP 30
12738: ADD
12739: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12740: LD_INT 1
12742: PPUSH
12743: LD_INT 3
12745: PPUSH
12746: LD_INT 6
12748: PPUSH
12749: CALL_OW 380
// hc_name = Kntor Radomr ;
12753: LD_ADDR_OWVAR 26
12757: PUSH
12758: LD_STRING Kntor Radomr
12760: ST_TO_ADDR
// hc_gallery = sandar ;
12761: LD_ADDR_OWVAR 33
12765: PUSH
12766: LD_STRING sandar
12768: ST_TO_ADDR
// hc_face_number = 12 ;
12769: LD_ADDR_OWVAR 34
12773: PUSH
12774: LD_INT 12
12776: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12777: LD_ADDR_OWVAR 29
12781: PUSH
12782: LD_INT 9
12784: PUSH
12785: LD_INT 9
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: ST_TO_ADDR
// Kantor = CreateHuman ;
12792: LD_ADDR_EXP 31
12796: PUSH
12797: CALL_OW 44
12801: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12802: LD_ADDR_EXP 35
12806: PUSH
12807: LD_EXP 35
12811: PUSH
12812: LD_EXP 31
12816: ADD
12817: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12818: LD_INT 1
12820: PPUSH
12821: LD_INT 3
12823: PPUSH
12824: LD_INT 6
12826: PPUSH
12827: CALL_OW 380
// hc_name = Herczeg Farkas ;
12831: LD_ADDR_OWVAR 26
12835: PUSH
12836: LD_STRING Herczeg Farkas
12838: ST_TO_ADDR
// hc_gallery = sandar ;
12839: LD_ADDR_OWVAR 33
12843: PUSH
12844: LD_STRING sandar
12846: ST_TO_ADDR
// hc_face_number = 28 ;
12847: LD_ADDR_OWVAR 34
12851: PUSH
12852: LD_INT 28
12854: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12855: LD_ADDR_OWVAR 29
12859: PUSH
12860: LD_INT 10
12862: PUSH
12863: LD_INT 9
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: ST_TO_ADDR
// Herczeg = CreateHuman ;
12870: LD_ADDR_EXP 32
12874: PUSH
12875: CALL_OW 44
12879: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12880: LD_ADDR_EXP 35
12884: PUSH
12885: LD_EXP 35
12889: PUSH
12890: LD_EXP 32
12894: ADD
12895: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12896: LD_INT 1
12898: PPUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_INT 6
12904: PPUSH
12905: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12909: LD_ADDR_OWVAR 26
12913: PUSH
12914: LD_STRING Ronn Horntvedt
12916: ST_TO_ADDR
// hc_gallery = sandar ;
12917: LD_ADDR_OWVAR 33
12921: PUSH
12922: LD_STRING sandar
12924: ST_TO_ADDR
// hc_face_number = 29 ;
12925: LD_ADDR_OWVAR 34
12929: PUSH
12930: LD_INT 29
12932: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12933: LD_ADDR_OWVAR 29
12937: PUSH
12938: LD_INT 11
12940: PUSH
12941: LD_INT 11
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: ST_TO_ADDR
// Ronn = CreateHuman ;
12948: LD_ADDR_EXP 33
12952: PUSH
12953: CALL_OW 44
12957: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12958: LD_ADDR_EXP 35
12962: PUSH
12963: LD_EXP 35
12967: PUSH
12968: LD_EXP 33
12972: ADD
12973: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12974: LD_INT 2
12976: PPUSH
12977: LD_INT 3
12979: PPUSH
12980: LD_INT 6
12982: PPUSH
12983: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12987: LD_ADDR_OWVAR 26
12991: PUSH
12992: LD_STRING Mia D. Mathiasen
12994: ST_TO_ADDR
// hc_gallery = sandar ;
12995: LD_ADDR_OWVAR 33
12999: PUSH
13000: LD_STRING sandar
13002: ST_TO_ADDR
// hc_face_number = 31 ;
13003: LD_ADDR_OWVAR 34
13007: PUSH
13008: LD_INT 31
13010: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13011: LD_ADDR_OWVAR 29
13015: PUSH
13016: LD_INT 10
13018: PUSH
13019: LD_INT 10
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: ST_TO_ADDR
// Mia = CreateHuman ;
13026: LD_ADDR_EXP 34
13030: PUSH
13031: CALL_OW 44
13035: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13036: LD_ADDR_EXP 35
13040: PUSH
13041: LD_EXP 35
13045: PUSH
13046: LD_EXP 34
13050: ADD
13051: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13052: LD_ADDR_VAR 0 3
13056: PUSH
13057: LD_VAR 0 3
13061: PUSH
13062: LD_INT 2
13064: PPUSH
13065: LD_INT 2
13067: PPUSH
13068: LD_INT 14
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: LD_INT 1
13076: PPUSH
13077: LD_INT 32
13079: PPUSH
13080: LD_INT 30
13082: PPUSH
13083: CALL 304 0 7
13087: ADD
13088: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13089: LD_ADDR_VAR 0 3
13093: PUSH
13094: LD_VAR 0 3
13098: PUSH
13099: LD_INT 2
13101: PPUSH
13102: LD_INT 2
13104: PPUSH
13105: LD_INT 14
13107: PPUSH
13108: LD_INT 1
13110: PPUSH
13111: LD_INT 1
13113: PPUSH
13114: LD_INT 27
13116: PPUSH
13117: LD_INT 30
13119: PPUSH
13120: CALL 304 0 7
13124: ADD
13125: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13126: LD_ADDR_VAR 0 3
13130: PUSH
13131: LD_VAR 0 3
13135: PUSH
13136: LD_INT 2
13138: PPUSH
13139: LD_INT 2
13141: PPUSH
13142: LD_INT 14
13144: PPUSH
13145: LD_INT 1
13147: PPUSH
13148: LD_INT 1
13150: PPUSH
13151: LD_INT 25
13153: PPUSH
13154: LD_INT 33
13156: PPUSH
13157: CALL 304 0 7
13161: ADD
13162: ST_TO_ADDR
// tmp := tmp diff 0 ;
13163: LD_ADDR_VAR 0 3
13167: PUSH
13168: LD_VAR 0 3
13172: PUSH
13173: LD_INT 0
13175: DIFF
13176: ST_TO_ADDR
// for i in ar_force do
13177: LD_ADDR_VAR 0 4
13181: PUSH
13182: LD_EXP 35
13186: PUSH
13187: FOR_IN
13188: IFFALSE 13331
// begin if GetClass ( i ) = 3 then
13190: LD_VAR 0 4
13194: PPUSH
13195: CALL_OW 257
13199: PUSH
13200: LD_INT 3
13202: EQUAL
13203: IFFALSE 13285
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13205: LD_VAR 0 3
13209: PUSH
13210: LD_INT 1
13212: ARRAY
13213: PPUSH
13214: LD_INT 1
13216: PPUSH
13217: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13221: LD_VAR 0 3
13225: PUSH
13226: LD_INT 1
13228: ARRAY
13229: PPUSH
13230: LD_VAR 0 5
13234: PPUSH
13235: LD_VAR 0 6
13239: PPUSH
13240: LD_INT 0
13242: PPUSH
13243: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13247: LD_VAR 0 4
13251: PPUSH
13252: LD_VAR 0 3
13256: PUSH
13257: LD_INT 1
13259: ARRAY
13260: PPUSH
13261: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13265: LD_ADDR_VAR 0 3
13269: PUSH
13270: LD_VAR 0 3
13274: PPUSH
13275: LD_INT 1
13277: PPUSH
13278: CALL_OW 3
13282: ST_TO_ADDR
// end else
13283: GO 13307
// PlaceUnitXY ( i , x , y , false ) ;
13285: LD_VAR 0 4
13289: PPUSH
13290: LD_VAR 0 5
13294: PPUSH
13295: LD_VAR 0 6
13299: PPUSH
13300: LD_INT 0
13302: PPUSH
13303: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13307: LD_VAR 0 4
13311: PPUSH
13312: LD_INT 86
13314: PPUSH
13315: LD_INT 121
13317: PPUSH
13318: CALL_OW 111
// wait ( 0 0$2 ) ;
13322: LD_INT 70
13324: PPUSH
13325: CALL_OW 67
// end ;
13329: GO 13187
13331: POP
13332: POP
// ar_force := ar_force ^ tmp ;
13333: LD_ADDR_EXP 35
13337: PUSH
13338: LD_EXP 35
13342: PUSH
13343: LD_VAR 0 3
13347: ADD
13348: ST_TO_ADDR
// ar_spawned := true ;
13349: LD_ADDR_EXP 11
13353: PUSH
13354: LD_INT 1
13356: ST_TO_ADDR
// end ; end_of_file
13357: LD_VAR 0 1
13361: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13362: LD_INT 0
13364: PPUSH
13365: PPUSH
13366: PPUSH
13367: PPUSH
13368: PPUSH
13369: PPUSH
13370: PPUSH
// InitHc ;
13371: CALL_OW 19
// uc_side := 3 ;
13375: LD_ADDR_OWVAR 20
13379: PUSH
13380: LD_INT 3
13382: ST_TO_ADDR
// uc_nation := 3 ;
13383: LD_ADDR_OWVAR 21
13387: PUSH
13388: LD_INT 3
13390: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13391: LD_ADDR_VAR 0 5
13395: PUSH
13396: LD_INT 5
13398: PUSH
13399: LD_INT 6
13401: PUSH
13402: LD_INT 7
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: LIST
13409: PUSH
13410: LD_OWVAR 67
13414: ARRAY
13415: ST_TO_ADDR
// ru_force := [ ] ;
13416: LD_ADDR_EXP 37
13420: PUSH
13421: EMPTY
13422: ST_TO_ADDR
// ru_rebuild := [ ] ;
13423: LD_ADDR_EXP 38
13427: PUSH
13428: EMPTY
13429: ST_TO_ADDR
// ru_produce_list := [ ] ;
13430: LD_ADDR_EXP 39
13434: PUSH
13435: EMPTY
13436: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13437: LD_ADDR_VAR 0 6
13441: PUSH
13442: LD_INT 22
13444: PUSH
13445: LD_INT 3
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PUSH
13452: LD_INT 30
13454: PUSH
13455: LD_INT 8
13457: PUSH
13458: EMPTY
13459: LIST
13460: LIST
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PPUSH
13466: CALL_OW 69
13470: PUSH
13471: LD_INT 1
13473: ARRAY
13474: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13475: LD_ADDR_VAR 0 4
13479: PUSH
13480: LD_INT 43
13482: PUSH
13483: LD_INT 46
13485: PUSH
13486: LD_INT 45
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: LIST
13493: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13494: LD_ADDR_VAR 0 7
13498: PUSH
13499: LD_INT 22
13501: PUSH
13502: LD_INT 3
13504: PUSH
13505: EMPTY
13506: LIST
13507: LIST
13508: PUSH
13509: LD_INT 30
13511: PUSH
13512: LD_INT 1
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PPUSH
13523: CALL_OW 69
13527: PUSH
13528: LD_INT 1
13530: ARRAY
13531: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13532: LD_VAR 0 7
13536: PPUSH
13537: CALL_OW 274
13541: PPUSH
13542: LD_INT 1
13544: PPUSH
13545: LD_INT 5000
13547: PPUSH
13548: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13552: LD_VAR 0 7
13556: PPUSH
13557: CALL_OW 274
13561: PPUSH
13562: LD_INT 2
13564: PPUSH
13565: LD_INT 1000
13567: PPUSH
13568: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13572: LD_VAR 0 7
13576: PPUSH
13577: CALL_OW 274
13581: PPUSH
13582: LD_INT 3
13584: PPUSH
13585: LD_INT 30
13587: PPUSH
13588: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13592: LD_ADDR_VAR 0 2
13596: PUSH
13597: LD_INT 22
13599: PUSH
13600: LD_INT 3
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: LD_INT 30
13609: PUSH
13610: LD_INT 33
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PPUSH
13621: CALL_OW 69
13625: PUSH
13626: FOR_IN
13627: IFFALSE 13659
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13629: LD_VAR 0 2
13633: PPUSH
13634: LD_VAR 0 4
13638: PUSH
13639: LD_VAR 0 2
13643: PUSH
13644: LD_INT 3
13646: MOD
13647: PUSH
13648: LD_INT 1
13650: PLUS
13651: ARRAY
13652: PPUSH
13653: CALL_OW 431
// end ;
13657: GO 13626
13659: POP
13660: POP
// for i = 1 to 4 do
13661: LD_ADDR_VAR 0 2
13665: PUSH
13666: DOUBLE
13667: LD_INT 1
13669: DEC
13670: ST_TO_ADDR
13671: LD_INT 4
13673: PUSH
13674: FOR_TO
13675: IFFALSE 13736
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13677: LD_INT 0
13679: PPUSH
13680: LD_INT 9
13682: PPUSH
13683: LD_VAR 0 5
13687: PPUSH
13688: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13692: CALL_OW 44
13696: PPUSH
13697: LD_INT 22
13699: PUSH
13700: LD_INT 3
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PUSH
13707: LD_INT 30
13709: PUSH
13710: LD_INT 5
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PPUSH
13721: CALL_OW 69
13725: PUSH
13726: LD_INT 1
13728: ARRAY
13729: PPUSH
13730: CALL_OW 52
// end ;
13734: GO 13674
13736: POP
13737: POP
// for i = 1 to 5 do
13738: LD_ADDR_VAR 0 2
13742: PUSH
13743: DOUBLE
13744: LD_INT 1
13746: DEC
13747: ST_TO_ADDR
13748: LD_INT 5
13750: PUSH
13751: FOR_TO
13752: IFFALSE 13813
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13754: LD_INT 0
13756: PPUSH
13757: LD_INT 3
13759: PPUSH
13760: LD_VAR 0 5
13764: PPUSH
13765: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13769: CALL_OW 44
13773: PPUSH
13774: LD_INT 22
13776: PUSH
13777: LD_INT 3
13779: PUSH
13780: EMPTY
13781: LIST
13782: LIST
13783: PUSH
13784: LD_INT 30
13786: PUSH
13787: LD_INT 3
13789: PUSH
13790: EMPTY
13791: LIST
13792: LIST
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: PPUSH
13798: CALL_OW 69
13802: PUSH
13803: LD_INT 1
13805: ARRAY
13806: PPUSH
13807: CALL_OW 52
// end ;
13811: GO 13751
13813: POP
13814: POP
// for i = 1 to 4 do
13815: LD_ADDR_VAR 0 2
13819: PUSH
13820: DOUBLE
13821: LD_INT 1
13823: DEC
13824: ST_TO_ADDR
13825: LD_INT 4
13827: PUSH
13828: FOR_TO
13829: IFFALSE 13890
// begin PrepareHuman ( false , class_engineer , skill ) ;
13831: LD_INT 0
13833: PPUSH
13834: LD_INT 2
13836: PPUSH
13837: LD_VAR 0 5
13841: PPUSH
13842: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13846: CALL_OW 44
13850: PPUSH
13851: LD_INT 22
13853: PUSH
13854: LD_INT 3
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: PUSH
13861: LD_INT 30
13863: PUSH
13864: LD_INT 1
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: PPUSH
13875: CALL_OW 69
13879: PUSH
13880: LD_INT 1
13882: ARRAY
13883: PPUSH
13884: CALL_OW 52
// end ;
13888: GO 13828
13890: POP
13891: POP
// for i = 1 to 3 do
13892: LD_ADDR_VAR 0 2
13896: PUSH
13897: DOUBLE
13898: LD_INT 1
13900: DEC
13901: ST_TO_ADDR
13902: LD_INT 3
13904: PUSH
13905: FOR_TO
13906: IFFALSE 13939
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13908: LD_INT 0
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: LD_VAR 0 5
13918: PPUSH
13919: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13923: CALL_OW 44
13927: PPUSH
13928: LD_VAR 0 6
13932: PPUSH
13933: CALL_OW 52
// end ;
13937: GO 13905
13939: POP
13940: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13941: LD_ADDR_EXP 36
13945: PUSH
13946: LD_STRING Yakotich
13948: PPUSH
13949: LD_EXP 2
13953: NOT
13954: PPUSH
13955: LD_STRING 
13957: PPUSH
13958: CALL 241 0 3
13962: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13963: LD_EXP 36
13967: PPUSH
13968: LD_INT 74
13970: PPUSH
13971: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13975: LD_VAR 0 6
13979: PPUSH
13980: LD_INT 49
13982: PPUSH
13983: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13987: LD_VAR 0 6
13991: PPUSH
13992: LD_INT 50
13994: PPUSH
13995: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13999: LD_VAR 0 6
14003: PPUSH
14004: LD_INT 51
14006: PPUSH
14007: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14011: LD_VAR 0 6
14015: PPUSH
14016: LD_INT 52
14018: PPUSH
14019: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14023: LD_VAR 0 6
14027: PPUSH
14028: LD_INT 69
14030: PPUSH
14031: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14035: LD_VAR 0 6
14039: PPUSH
14040: LD_INT 39
14042: PPUSH
14043: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14047: LD_VAR 0 6
14051: PPUSH
14052: LD_INT 34
14054: PPUSH
14055: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14059: LD_VAR 0 6
14063: PPUSH
14064: LD_INT 40
14066: PPUSH
14067: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14071: LD_VAR 0 6
14075: PPUSH
14076: LD_INT 57
14078: PPUSH
14079: CALL_OW 184
// if Difficulty > 1 then
14083: LD_OWVAR 67
14087: PUSH
14088: LD_INT 1
14090: GREATER
14091: IFFALSE 14105
// AddComResearch ( lab , tech_comp2 ) ;
14093: LD_VAR 0 6
14097: PPUSH
14098: LD_INT 58
14100: PPUSH
14101: CALL_OW 184
// end ;
14105: LD_VAR 0 1
14109: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14110: LD_INT 7
14112: PPUSH
14113: CALL_OW 353
14117: PUSH
14118: LD_INT 3
14120: GREATER
14121: PUSH
14122: LD_INT 22
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: EMPTY
14129: LIST
14130: LIST
14131: PUSH
14132: LD_INT 34
14134: PUSH
14135: LD_INT 53
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PPUSH
14146: CALL_OW 69
14150: NOT
14151: AND
14152: IFFALSE 14187
14154: GO 14156
14156: DISABLE
// begin enable ;
14157: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14158: LD_ADDR_EXP 39
14162: PUSH
14163: LD_EXP 39
14167: PUSH
14168: LD_INT 24
14170: PUSH
14171: LD_INT 1
14173: PUSH
14174: LD_INT 3
14176: PUSH
14177: LD_INT 53
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: ADD
14186: ST_TO_ADDR
// end ;
14187: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14188: LD_INT 22
14190: PUSH
14191: LD_INT 3
14193: PUSH
14194: EMPTY
14195: LIST
14196: LIST
14197: PUSH
14198: LD_INT 21
14200: PUSH
14201: LD_INT 3
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: PPUSH
14212: CALL_OW 69
14216: IFFALSE 14994
14218: GO 14220
14220: DISABLE
14221: LD_INT 0
14223: PPUSH
14224: PPUSH
14225: PPUSH
14226: PPUSH
14227: PPUSH
14228: PPUSH
14229: PPUSH
14230: PPUSH
// begin enable ;
14231: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14232: LD_ADDR_VAR 0 3
14236: PUSH
14237: LD_INT 22
14239: PUSH
14240: LD_INT 3
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 21
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 3
14259: PUSH
14260: LD_INT 24
14262: PUSH
14263: LD_INT 1000
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: LIST
14278: PPUSH
14279: CALL_OW 69
14283: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14284: LD_ADDR_VAR 0 4
14288: PUSH
14289: LD_INT 22
14291: PUSH
14292: LD_INT 3
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: LD_INT 2
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: PPUSH
14313: CALL_OW 69
14317: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14318: LD_ADDR_VAR 0 5
14322: PUSH
14323: LD_INT 22
14325: PUSH
14326: LD_INT 3
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 30
14335: PUSH
14336: LD_INT 1
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: EMPTY
14344: LIST
14345: LIST
14346: PPUSH
14347: CALL_OW 69
14351: PUSH
14352: LD_INT 1
14354: ARRAY
14355: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14356: LD_ADDR_VAR 0 8
14360: PUSH
14361: LD_INT 22
14363: PUSH
14364: LD_INT 3
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: PUSH
14371: LD_INT 2
14373: PUSH
14374: LD_INT 30
14376: PUSH
14377: LD_INT 6
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: PUSH
14384: LD_INT 30
14386: PUSH
14387: LD_INT 7
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 30
14396: PUSH
14397: LD_INT 8
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PPUSH
14414: CALL_OW 69
14418: PUSH
14419: LD_INT 1
14421: ARRAY
14422: ST_TO_ADDR
// if not engs then
14423: LD_VAR 0 4
14427: NOT
14428: IFFALSE 14432
// exit ;
14430: GO 14994
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14432: LD_ADDR_VAR 0 6
14436: PUSH
14437: LD_VAR 0 4
14441: PPUSH
14442: LD_INT 3
14444: PUSH
14445: LD_INT 24
14447: PUSH
14448: LD_INT 600
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PPUSH
14459: CALL_OW 72
14463: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14464: LD_ADDR_VAR 0 7
14468: PUSH
14469: LD_INT 22
14471: PUSH
14472: LD_INT 3
14474: PUSH
14475: EMPTY
14476: LIST
14477: LIST
14478: PUSH
14479: LD_INT 25
14481: PUSH
14482: LD_INT 4
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: PPUSH
14493: CALL_OW 69
14497: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14498: LD_VAR 0 3
14502: NOT
14503: PUSH
14504: LD_EXP 38
14508: NOT
14509: AND
14510: IFFALSE 14570
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14512: LD_VAR 0 4
14516: PPUSH
14517: LD_INT 3
14519: PUSH
14520: LD_INT 54
14522: PUSH
14523: EMPTY
14524: LIST
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PPUSH
14530: CALL_OW 72
14534: IFFALSE 14568
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14536: LD_VAR 0 4
14540: PPUSH
14541: LD_INT 3
14543: PUSH
14544: LD_INT 54
14546: PUSH
14547: EMPTY
14548: LIST
14549: PUSH
14550: EMPTY
14551: LIST
14552: LIST
14553: PPUSH
14554: CALL_OW 72
14558: PPUSH
14559: LD_VAR 0 5
14563: PPUSH
14564: CALL_OW 120
// exit ;
14568: GO 14994
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14570: LD_VAR 0 4
14574: PPUSH
14575: LD_INT 54
14577: PUSH
14578: EMPTY
14579: LIST
14580: PPUSH
14581: CALL_OW 72
14585: IFFALSE 14607
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14587: LD_VAR 0 4
14591: PPUSH
14592: LD_INT 54
14594: PUSH
14595: EMPTY
14596: LIST
14597: PPUSH
14598: CALL_OW 72
14602: PPUSH
14603: CALL_OW 122
// if not tmp then
14607: LD_VAR 0 3
14611: NOT
14612: IFFALSE 14744
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14614: LD_INT 81
14616: PUSH
14617: LD_INT 3
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: PUSH
14624: LD_INT 92
14626: PUSH
14627: LD_INT 147
14629: PUSH
14630: LD_INT 212
14632: PUSH
14633: LD_INT 30
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: PUSH
14642: EMPTY
14643: LIST
14644: LIST
14645: PPUSH
14646: CALL_OW 69
14650: NOT
14651: IFFALSE 14744
// begin if not HasTask ( engs [ 1 ] ) then
14653: LD_VAR 0 4
14657: PUSH
14658: LD_INT 1
14660: ARRAY
14661: PPUSH
14662: CALL_OW 314
14666: NOT
14667: IFFALSE 14744
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14669: LD_ADDR_VAR 0 2
14673: PUSH
14674: LD_VAR 0 4
14678: PPUSH
14679: LD_EXP 38
14683: PUSH
14684: LD_INT 1
14686: ARRAY
14687: PPUSH
14688: LD_EXP 38
14692: PUSH
14693: LD_INT 2
14695: ARRAY
14696: PPUSH
14697: LD_EXP 38
14701: PUSH
14702: LD_INT 3
14704: ARRAY
14705: PPUSH
14706: LD_EXP 38
14710: PUSH
14711: LD_INT 4
14713: ARRAY
14714: PPUSH
14715: CALL_OW 145
14719: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14720: LD_VAR 0 2
14724: PPUSH
14725: CALL_OW 266
14729: PUSH
14730: LD_INT 4
14732: EQUAL
14733: IFFALSE 14744
// AddComUpgrade ( i ) ;
14735: LD_VAR 0 2
14739: PPUSH
14740: CALL_OW 206
// end ; end ; end ; for i in engs do
14744: LD_ADDR_VAR 0 2
14748: PUSH
14749: LD_VAR 0 4
14753: PUSH
14754: FOR_IN
14755: IFFALSE 14873
// begin if i in to_heal and sci then
14757: LD_VAR 0 2
14761: PUSH
14762: LD_VAR 0 6
14766: IN
14767: PUSH
14768: LD_VAR 0 7
14772: AND
14773: IFFALSE 14824
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14775: LD_VAR 0 2
14779: PPUSH
14780: LD_INT 149
14782: PPUSH
14783: LD_INT 220
14785: PPUSH
14786: CALL_OW 297
14790: PUSH
14791: LD_INT 5
14793: LESS
14794: IFFALSE 14798
// continue ;
14796: GO 14754
// ComMoveXY ( i , 149 , 220 ) ;
14798: LD_VAR 0 2
14802: PPUSH
14803: LD_INT 149
14805: PPUSH
14806: LD_INT 220
14808: PPUSH
14809: CALL_OW 111
// AddComHold ( i ) ;
14813: LD_VAR 0 2
14817: PPUSH
14818: CALL_OW 200
// end else
14822: GO 14871
// if not HasTask ( i ) or WantsToAttack ( i ) then
14824: LD_VAR 0 2
14828: PPUSH
14829: CALL_OW 314
14833: NOT
14834: PUSH
14835: LD_VAR 0 2
14839: PPUSH
14840: CALL_OW 319
14844: OR
14845: IFFALSE 14871
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14847: LD_VAR 0 2
14851: PPUSH
14852: LD_VAR 0 3
14856: PPUSH
14857: LD_VAR 0 2
14861: PPUSH
14862: CALL_OW 74
14866: PPUSH
14867: CALL_OW 130
// end ;
14871: GO 14754
14873: POP
14874: POP
// if to_heal and sci then
14875: LD_VAR 0 6
14879: PUSH
14880: LD_VAR 0 7
14884: AND
14885: IFFALSE 14946
// begin if UnitFilter ( sci , [ f_inside ] ) then
14887: LD_VAR 0 7
14891: PPUSH
14892: LD_INT 54
14894: PUSH
14895: EMPTY
14896: LIST
14897: PPUSH
14898: CALL_OW 72
14902: IFFALSE 14926
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14904: LD_VAR 0 7
14908: PPUSH
14909: LD_INT 54
14911: PUSH
14912: EMPTY
14913: LIST
14914: PPUSH
14915: CALL_OW 72
14919: PPUSH
14920: CALL_OW 122
14924: GO 14944
// ComHeal ( sci , to_heal [ 1 ] ) ;
14926: LD_VAR 0 7
14930: PPUSH
14931: LD_VAR 0 6
14935: PUSH
14936: LD_INT 1
14938: ARRAY
14939: PPUSH
14940: CALL_OW 128
// end else
14944: GO 14994
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14946: LD_VAR 0 7
14950: PPUSH
14951: LD_INT 56
14953: PUSH
14954: EMPTY
14955: LIST
14956: PPUSH
14957: CALL_OW 72
14961: PUSH
14962: LD_VAR 0 8
14966: AND
14967: IFFALSE 14994
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14969: LD_VAR 0 7
14973: PPUSH
14974: LD_INT 56
14976: PUSH
14977: EMPTY
14978: LIST
14979: PPUSH
14980: CALL_OW 72
14984: PPUSH
14985: LD_VAR 0 8
14989: PPUSH
14990: CALL_OW 120
// end ;
14994: PPOPN 8
14996: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14997: LD_INT 22
14999: PUSH
15000: LD_INT 3
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PUSH
15007: LD_INT 30
15009: PUSH
15010: LD_INT 3
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: PPUSH
15021: CALL_OW 69
15025: PUSH
15026: LD_EXP 39
15030: AND
15031: IFFALSE 15157
15033: GO 15035
15035: DISABLE
15036: LD_INT 0
15038: PPUSH
15039: PPUSH
15040: PPUSH
// begin enable ;
15041: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_INT 22
15049: PUSH
15050: LD_INT 3
15052: PUSH
15053: EMPTY
15054: LIST
15055: LIST
15056: PUSH
15057: LD_INT 30
15059: PUSH
15060: LD_INT 3
15062: PUSH
15063: EMPTY
15064: LIST
15065: LIST
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: PPUSH
15071: CALL_OW 69
15075: PUSH
15076: LD_INT 1
15078: ARRAY
15079: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15080: LD_VAR 0 3
15084: PPUSH
15085: CALL_OW 313
15089: PUSH
15090: LD_INT 0
15092: EQUAL
15093: IFFALSE 15097
// exit ;
15095: GO 15157
// if BuildingStatus ( fac ) = bs_idle then
15097: LD_VAR 0 3
15101: PPUSH
15102: CALL_OW 461
15106: PUSH
15107: LD_INT 2
15109: EQUAL
15110: IFFALSE 15157
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15112: LD_VAR 0 3
15116: PPUSH
15117: LD_EXP 39
15121: PUSH
15122: LD_INT 1
15124: ARRAY
15125: PPUSH
15126: LD_EXP 39
15130: PUSH
15131: LD_INT 2
15133: ARRAY
15134: PPUSH
15135: LD_EXP 39
15139: PUSH
15140: LD_INT 3
15142: ARRAY
15143: PPUSH
15144: LD_EXP 39
15148: PUSH
15149: LD_INT 4
15151: ARRAY
15152: PPUSH
15153: CALL_OW 125
// end ;
15157: PPOPN 3
15159: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15160: LD_INT 0
15162: PPUSH
15163: PPUSH
15164: PPUSH
15165: PPUSH
15166: PPUSH
// uc_side := 3 ;
15167: LD_ADDR_OWVAR 20
15171: PUSH
15172: LD_INT 3
15174: ST_TO_ADDR
// uc_nation := 3 ;
15175: LD_ADDR_OWVAR 21
15179: PUSH
15180: LD_INT 3
15182: ST_TO_ADDR
// ru_can_attack := false ;
15183: LD_ADDR_EXP 8
15187: PUSH
15188: LD_INT 0
15190: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15191: LD_ADDR_VAR 0 6
15195: PUSH
15196: LD_INT 22
15198: PUSH
15199: LD_INT 3
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PUSH
15206: LD_INT 30
15208: PUSH
15209: LD_INT 3
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL_OW 69
15224: ST_TO_ADDR
// if fac then
15225: LD_VAR 0 6
15229: IFFALSE 15381
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15231: LD_ADDR_EXP 39
15235: PUSH
15236: LD_INT 24
15238: PUSH
15239: LD_INT 1
15241: PUSH
15242: LD_INT 3
15244: PUSH
15245: LD_INT 43
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: ST_TO_ADDR
// if wave > 1 then
15254: LD_VAR 0 1
15258: PUSH
15259: LD_INT 1
15261: GREATER
15262: IFFALSE 15315
// for i = 1 to Difficulty do
15264: LD_ADDR_VAR 0 3
15268: PUSH
15269: DOUBLE
15270: LD_INT 1
15272: DEC
15273: ST_TO_ADDR
15274: LD_OWVAR 67
15278: PUSH
15279: FOR_TO
15280: IFFALSE 15313
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15282: LD_ADDR_EXP 39
15286: PUSH
15287: LD_EXP 39
15291: PUSH
15292: LD_INT 24
15294: PUSH
15295: LD_INT 1
15297: PUSH
15298: LD_INT 3
15300: PUSH
15301: LD_INT 45
15303: PUSH
15304: EMPTY
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: ADD
15310: ST_TO_ADDR
15311: GO 15279
15313: POP
15314: POP
// repeat wait ( 0 0$1 ) ;
15315: LD_INT 35
15317: PPUSH
15318: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15322: LD_EXP 39
15326: PUSH
15327: LD_INT 4
15329: LESS
15330: PUSH
15331: LD_VAR 0 6
15335: PUSH
15336: LD_INT 1
15338: ARRAY
15339: PPUSH
15340: CALL_OW 313
15344: PUSH
15345: LD_INT 0
15347: EQUAL
15348: OR
15349: PUSH
15350: LD_VAR 0 6
15354: PUSH
15355: LD_INT 1
15357: ARRAY
15358: PPUSH
15359: CALL_OW 461
15363: PUSH
15364: LD_INT 8
15366: PUSH
15367: LD_INT 6
15369: PUSH
15370: LD_INT 7
15372: PUSH
15373: EMPTY
15374: LIST
15375: LIST
15376: LIST
15377: IN
15378: OR
15379: IFFALSE 15315
// end ; case wave of 1 :
15381: LD_VAR 0 1
15385: PUSH
15386: LD_INT 1
15388: DOUBLE
15389: EQUAL
15390: IFTRUE 15394
15392: GO 15479
15394: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
15395: LD_ADDR_VAR 0 3
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_INT 3
15407: PUSH
15408: LD_INT 4
15410: PUSH
15411: LD_INT 5
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_OWVAR 67
15423: ARRAY
15424: PUSH
15425: FOR_TO
15426: IFFALSE 15434
// Sold ;
15428: CALL 15705 0 0
15432: GO 15425
15434: POP
15435: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: DOUBLE
15442: LD_INT 1
15444: DEC
15445: ST_TO_ADDR
15446: LD_INT 2
15448: PUSH
15449: LD_INT 3
15451: PUSH
15452: LD_INT 3
15454: PUSH
15455: EMPTY
15456: LIST
15457: LIST
15458: LIST
15459: PUSH
15460: LD_OWVAR 67
15464: ARRAY
15465: PUSH
15466: FOR_TO
15467: IFFALSE 15475
// Tank ;
15469: CALL 15835 0 0
15473: GO 15466
15475: POP
15476: POP
// end ; 2 .. 9 :
15477: GO 15692
15479: LD_INT 2
15481: DOUBLE
15482: GREATEREQUAL
15483: IFFALSE 15491
15485: LD_INT 9
15487: DOUBLE
15488: LESSEQUAL
15489: IFTRUE 15493
15491: GO 15598
15493: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15494: LD_ADDR_VAR 0 3
15498: PUSH
15499: DOUBLE
15500: LD_INT 1
15502: DEC
15503: ST_TO_ADDR
15504: LD_INT 3
15506: PUSH
15507: LD_INT 4
15509: PUSH
15510: LD_INT 5
15512: PUSH
15513: EMPTY
15514: LIST
15515: LIST
15516: LIST
15517: PUSH
15518: LD_OWVAR 67
15522: ARRAY
15523: PUSH
15524: LD_VAR 0 1
15528: PUSH
15529: LD_INT 2
15531: DIV
15532: PLUS
15533: PUSH
15534: FOR_TO
15535: IFFALSE 15543
// Sold ;
15537: CALL 15705 0 0
15541: GO 15534
15543: POP
15544: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15545: LD_ADDR_VAR 0 3
15549: PUSH
15550: DOUBLE
15551: LD_INT 1
15553: DEC
15554: ST_TO_ADDR
15555: LD_INT 2
15557: PUSH
15558: LD_INT 3
15560: PUSH
15561: LD_INT 3
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: LIST
15568: PUSH
15569: LD_OWVAR 67
15573: ARRAY
15574: PUSH
15575: LD_VAR 0 1
15579: PUSH
15580: LD_INT 2
15582: DIV
15583: PLUS
15584: PUSH
15585: FOR_TO
15586: IFFALSE 15594
// Tank ;
15588: CALL 15835 0 0
15592: GO 15585
15594: POP
15595: POP
// end ; 10 :
15596: GO 15692
15598: LD_INT 10
15600: DOUBLE
15601: EQUAL
15602: IFTRUE 15606
15604: GO 15691
15606: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15607: LD_ADDR_VAR 0 3
15611: PUSH
15612: DOUBLE
15613: LD_INT 1
15615: DEC
15616: ST_TO_ADDR
15617: LD_INT 10
15619: PUSH
15620: LD_INT 12
15622: PUSH
15623: LD_INT 14
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: LIST
15630: PUSH
15631: LD_OWVAR 67
15635: ARRAY
15636: PUSH
15637: FOR_TO
15638: IFFALSE 15646
// Sold ;
15640: CALL 15705 0 0
15644: GO 15637
15646: POP
15647: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15648: LD_ADDR_VAR 0 3
15652: PUSH
15653: DOUBLE
15654: LD_INT 1
15656: DEC
15657: ST_TO_ADDR
15658: LD_INT 11
15660: PUSH
15661: LD_INT 13
15663: PUSH
15664: LD_INT 15
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: LIST
15671: PUSH
15672: LD_OWVAR 67
15676: ARRAY
15677: PUSH
15678: FOR_TO
15679: IFFALSE 15687
// Tank ;
15681: CALL 15835 0 0
15685: GO 15678
15687: POP
15688: POP
// end ; end ;
15689: GO 15692
15691: POP
// ru_can_attack := true ;
15692: LD_ADDR_EXP 8
15696: PUSH
15697: LD_INT 1
15699: ST_TO_ADDR
// end ;
15700: LD_VAR 0 2
15704: RET
// function Sold ( ) ; var un , skill ; begin
15705: LD_INT 0
15707: PPUSH
15708: PPUSH
15709: PPUSH
// uc_side := 3 ;
15710: LD_ADDR_OWVAR 20
15714: PUSH
15715: LD_INT 3
15717: ST_TO_ADDR
// uc_nation := 3 ;
15718: LD_ADDR_OWVAR 21
15722: PUSH
15723: LD_INT 3
15725: ST_TO_ADDR
// InitHc ;
15726: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15730: LD_ADDR_VAR 0 3
15734: PUSH
15735: LD_INT 6
15737: PUSH
15738: LD_INT 7
15740: PUSH
15741: LD_INT 7
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: LIST
15748: PUSH
15749: LD_OWVAR 67
15753: ARRAY
15754: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15755: LD_INT 0
15757: PPUSH
15758: LD_INT 1
15760: PUSH
15761: LD_INT 9
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: PUSH
15768: LD_INT 1
15770: PPUSH
15771: LD_INT 2
15773: PPUSH
15774: CALL_OW 12
15778: ARRAY
15779: PPUSH
15780: LD_VAR 0 3
15784: PPUSH
15785: CALL_OW 380
// un := CreateHuman ;
15789: LD_ADDR_VAR 0 2
15793: PUSH
15794: CALL_OW 44
15798: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15799: LD_VAR 0 2
15803: PPUSH
15804: LD_INT 4
15806: PPUSH
15807: LD_INT 0
15809: PPUSH
15810: CALL_OW 49
// ru_force := ru_force ^ un ;
15814: LD_ADDR_EXP 37
15818: PUSH
15819: LD_EXP 37
15823: PUSH
15824: LD_VAR 0 2
15828: ADD
15829: ST_TO_ADDR
// end ;
15830: LD_VAR 0 1
15834: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15835: LD_INT 0
15837: PPUSH
15838: PPUSH
15839: PPUSH
15840: PPUSH
15841: PPUSH
// uc_side := 3 ;
15842: LD_ADDR_OWVAR 20
15846: PUSH
15847: LD_INT 3
15849: ST_TO_ADDR
// uc_nation := 3 ;
15850: LD_ADDR_OWVAR 21
15854: PUSH
15855: LD_INT 3
15857: ST_TO_ADDR
// InitHc ;
15858: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15862: LD_ADDR_VAR 0 5
15866: PUSH
15867: LD_INT 5
15869: PUSH
15870: LD_INT 6
15872: PUSH
15873: LD_INT 7
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PUSH
15881: LD_OWVAR 67
15885: ARRAY
15886: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15887: LD_ADDR_VAR 0 3
15891: PUSH
15892: LD_INT 22
15894: PUSH
15895: LD_INT 24
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: PUSH
15902: LD_INT 1
15904: PPUSH
15905: LD_INT 2
15907: PPUSH
15908: CALL_OW 12
15912: ARRAY
15913: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15914: LD_VAR 0 3
15918: PUSH
15919: LD_INT 22
15921: EQUAL
15922: IFFALSE 15957
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15924: LD_ADDR_VAR 0 4
15928: PUSH
15929: LD_INT 45
15931: PUSH
15932: LD_INT 43
15934: PUSH
15935: LD_INT 44
15937: PUSH
15938: EMPTY
15939: LIST
15940: LIST
15941: LIST
15942: PUSH
15943: LD_INT 1
15945: PPUSH
15946: LD_INT 3
15948: PPUSH
15949: CALL_OW 12
15953: ARRAY
15954: ST_TO_ADDR
15955: GO 15988
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15957: LD_ADDR_VAR 0 4
15961: PUSH
15962: LD_INT 46
15964: PUSH
15965: LD_INT 44
15967: PUSH
15968: LD_INT 45
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: LIST
15975: PUSH
15976: LD_INT 1
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL_OW 12
15986: ARRAY
15987: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15988: LD_ADDR_VAR 0 2
15992: PUSH
15993: LD_INT 3
15995: PPUSH
15996: LD_INT 3
15998: PPUSH
15999: LD_VAR 0 3
16003: PPUSH
16004: LD_INT 1
16006: PPUSH
16007: LD_INT 3
16009: PUSH
16010: LD_INT 3
16012: PUSH
16013: LD_INT 3
16015: PUSH
16016: LD_INT 1
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: LIST
16023: LIST
16024: PUSH
16025: LD_INT 1
16027: PPUSH
16028: LD_INT 4
16030: PPUSH
16031: CALL_OW 12
16035: ARRAY
16036: PPUSH
16037: LD_VAR 0 4
16041: PPUSH
16042: LD_INT 99
16044: PPUSH
16045: CALL 304 0 7
16049: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16050: LD_VAR 0 2
16054: PPUSH
16055: CALL_OW 263
16059: PUSH
16060: LD_INT 1
16062: EQUAL
16063: IFFALSE 16094
// begin PrepareHuman ( false , 3 , skill ) ;
16065: LD_INT 0
16067: PPUSH
16068: LD_INT 3
16070: PPUSH
16071: LD_VAR 0 5
16075: PPUSH
16076: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16080: CALL_OW 44
16084: PPUSH
16085: LD_VAR 0 2
16089: PPUSH
16090: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16094: LD_VAR 0 2
16098: PPUSH
16099: LD_INT 3
16101: PPUSH
16102: LD_INT 0
16104: PPUSH
16105: CALL_OW 49
// ru_force := ru_force ^ un ;
16109: LD_ADDR_EXP 37
16113: PUSH
16114: LD_EXP 37
16118: PUSH
16119: LD_VAR 0 2
16123: ADD
16124: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16125: LD_VAR 0 2
16129: PPUSH
16130: LD_INT 126
16132: PPUSH
16133: LD_INT 158
16135: PPUSH
16136: CALL_OW 111
// Wait ( 0 0$3 ) ;
16140: LD_INT 105
16142: PPUSH
16143: CALL_OW 67
// ComStop ( un ) ;
16147: LD_VAR 0 2
16151: PPUSH
16152: CALL_OW 141
// end ;
16156: LD_VAR 0 1
16160: RET
// every 0 0$1 do var i , time , wave ;
16161: GO 16163
16163: DISABLE
16164: LD_INT 0
16166: PPUSH
16167: PPUSH
16168: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16169: LD_ADDR_VAR 0 2
16173: PUSH
16174: LD_INT 25200
16176: PUSH
16177: LD_INT 24150
16179: PUSH
16180: LD_INT 23100
16182: PUSH
16183: EMPTY
16184: LIST
16185: LIST
16186: LIST
16187: PUSH
16188: LD_OWVAR 67
16192: ARRAY
16193: ST_TO_ADDR
// wait ( time ) ;
16194: LD_VAR 0 2
16198: PPUSH
16199: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16203: LD_ADDR_VAR 0 2
16207: PUSH
16208: LD_INT 15750
16210: PUSH
16211: LD_INT 15400
16213: PUSH
16214: LD_INT 15050
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: LIST
16221: PUSH
16222: LD_OWVAR 67
16226: ARRAY
16227: ST_TO_ADDR
// wave := 0 ;
16228: LD_ADDR_VAR 0 3
16232: PUSH
16233: LD_INT 0
16235: ST_TO_ADDR
// while true do
16236: LD_INT 1
16238: IFFALSE 16342
// begin wave := wave + 1 ;
16240: LD_ADDR_VAR 0 3
16244: PUSH
16245: LD_VAR 0 3
16249: PUSH
16250: LD_INT 1
16252: PLUS
16253: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16254: LD_INT 22
16256: PUSH
16257: LD_INT 2
16259: PUSH
16260: EMPTY
16261: LIST
16262: LIST
16263: PPUSH
16264: CALL_OW 69
16268: IFFALSE 16304
// begin repeat wait ( 0 0$1 ) ;
16270: LD_INT 35
16272: PPUSH
16273: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16277: LD_INT 22
16279: PUSH
16280: LD_INT 2
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: PPUSH
16287: CALL_OW 69
16291: PUSH
16292: LD_INT 0
16294: EQUAL
16295: IFFALSE 16270
// wait ( 1 1$30 ) ;
16297: LD_INT 3150
16299: PPUSH
16300: CALL_OW 67
// end ; if ru_force < 20 then
16304: LD_EXP 37
16308: PUSH
16309: LD_INT 20
16311: LESS
16312: IFFALSE 16323
// PrepareAttack ( wave ) ;
16314: LD_VAR 0 3
16318: PPUSH
16319: CALL 15160 0 1
// ru_can_attack := true ;
16323: LD_ADDR_EXP 8
16327: PUSH
16328: LD_INT 1
16330: ST_TO_ADDR
// wait ( time ) ;
16331: LD_VAR 0 2
16335: PPUSH
16336: CALL_OW 67
// end ;
16340: GO 16236
// end ;
16342: PPOPN 3
16344: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16345: LD_EXP 8
16349: PUSH
16350: LD_EXP 37
16354: AND
16355: IFFALSE 17189
16357: GO 16359
16359: DISABLE
16360: LD_INT 0
16362: PPUSH
16363: PPUSH
16364: PPUSH
16365: PPUSH
16366: PPUSH
16367: PPUSH
16368: PPUSH
16369: PPUSH
16370: PPUSH
// begin enable ;
16371: ENABLE
// points1 := [ 107 , 123 ] ;
16372: LD_ADDR_VAR 0 4
16376: PUSH
16377: LD_INT 107
16379: PUSH
16380: LD_INT 123
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16387: LD_ADDR_VAR 0 5
16391: PUSH
16392: LD_INT 55
16394: PUSH
16395: LD_INT 42
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16402: LD_ADDR_VAR 0 6
16406: PUSH
16407: LD_INT 102
16409: PUSH
16410: LD_INT 140
16412: PUSH
16413: EMPTY
16414: LIST
16415: LIST
16416: PUSH
16417: LD_INT 105
16419: PUSH
16420: LD_INT 142
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: PUSH
16427: LD_INT 129
16429: PUSH
16430: LD_INT 131
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: ST_TO_ADDR
// for i in ru_force do
16442: LD_ADDR_VAR 0 1
16446: PUSH
16447: LD_EXP 37
16451: PUSH
16452: FOR_IN
16453: IFFALSE 17187
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16455: LD_ADDR_VAR 0 3
16459: PUSH
16460: LD_INT 81
16462: PUSH
16463: LD_INT 3
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PPUSH
16470: CALL_OW 69
16474: PPUSH
16475: LD_VAR 0 1
16479: PPUSH
16480: CALL_OW 74
16484: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16485: LD_VAR 0 1
16489: PPUSH
16490: LD_VAR 0 3
16494: PPUSH
16495: CALL_OW 296
16499: PUSH
16500: LD_INT 12
16502: LESS
16503: IFFALSE 16648
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16505: LD_VAR 0 1
16509: PPUSH
16510: CALL_OW 247
16514: PUSH
16515: LD_INT 1
16517: EQUAL
16518: PUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: CALL_OW 257
16528: PUSH
16529: LD_INT 1
16531: EQUAL
16532: AND
16533: PUSH
16534: LD_VAR 0 3
16538: PUSH
16539: LD_INT 21
16541: PUSH
16542: LD_INT 2
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 58
16551: PUSH
16552: EMPTY
16553: LIST
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PPUSH
16559: CALL_OW 69
16563: IN
16564: AND
16565: IFFALSE 16583
// ComEnterUnit ( i , un ) else
16567: LD_VAR 0 1
16571: PPUSH
16572: LD_VAR 0 3
16576: PPUSH
16577: CALL_OW 120
16581: GO 16646
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16583: LD_VAR 0 3
16587: PUSH
16588: LD_INT 21
16590: PUSH
16591: LD_INT 2
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: PUSH
16598: LD_INT 58
16600: PUSH
16601: EMPTY
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: PPUSH
16608: CALL_OW 69
16612: IN
16613: NOT
16614: IFFALSE 16632
// ComAttackUnit ( i , un ) else
16616: LD_VAR 0 1
16620: PPUSH
16621: LD_VAR 0 3
16625: PPUSH
16626: CALL_OW 115
16630: GO 16646
// ComAttackUnit ( i , JMM ) ;
16632: LD_VAR 0 1
16636: PPUSH
16637: LD_EXP 20
16641: PPUSH
16642: CALL_OW 115
// end else
16646: GO 17185
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16648: LD_VAR 0 1
16652: PPUSH
16653: LD_VAR 0 4
16657: PUSH
16658: LD_INT 1
16660: ARRAY
16661: PPUSH
16662: LD_VAR 0 4
16666: PUSH
16667: LD_INT 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 297
16675: PUSH
16676: LD_VAR 0 1
16680: PPUSH
16681: LD_VAR 0 5
16685: PUSH
16686: LD_INT 1
16688: ARRAY
16689: PPUSH
16690: LD_VAR 0 5
16694: PUSH
16695: LD_INT 2
16697: ARRAY
16698: PPUSH
16699: CALL_OW 297
16703: GREATER
16704: PUSH
16705: LD_EXP 9
16709: AND
16710: PUSH
16711: LD_INT 9
16713: PPUSH
16714: LD_INT 81
16716: PUSH
16717: LD_INT 3
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PPUSH
16724: CALL_OW 70
16728: PUSH
16729: LD_INT 0
16731: EQUAL
16732: OR
16733: IFFALSE 16771
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16735: LD_VAR 0 1
16739: PPUSH
16740: LD_INT 81
16742: PUSH
16743: LD_INT 3
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: PPUSH
16750: CALL_OW 69
16754: PPUSH
16755: LD_VAR 0 1
16759: PPUSH
16760: CALL_OW 74
16764: PPUSH
16765: CALL_OW 115
16769: GO 17185
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16771: LD_VAR 0 1
16775: PPUSH
16776: CALL_OW 264
16780: PUSH
16781: LD_INT 45
16783: EQUAL
16784: PUSH
16785: LD_EXP 37
16789: PPUSH
16790: LD_INT 3
16792: PUSH
16793: LD_INT 34
16795: PUSH
16796: LD_INT 45
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PPUSH
16807: CALL_OW 72
16811: PUSH
16812: LD_INT 6
16814: GREATER
16815: AND
16816: IFFALSE 16997
// begin dist := 9999 ;
16818: LD_ADDR_VAR 0 8
16822: PUSH
16823: LD_INT 9999
16825: ST_TO_ADDR
// xy := 0 ;
16826: LD_ADDR_VAR 0 9
16830: PUSH
16831: LD_INT 0
16833: ST_TO_ADDR
// for x in pointsr do
16834: LD_ADDR_VAR 0 7
16838: PUSH
16839: LD_VAR 0 6
16843: PUSH
16844: FOR_IN
16845: IFFALSE 16993
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16847: LD_VAR 0 1
16851: PPUSH
16852: LD_VAR 0 7
16856: PUSH
16857: LD_INT 1
16859: ARRAY
16860: PPUSH
16861: LD_VAR 0 7
16865: PUSH
16866: LD_INT 2
16868: ARRAY
16869: PPUSH
16870: CALL_OW 297
16874: PUSH
16875: LD_VAR 0 8
16879: LESS
16880: IFFALSE 16925
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16882: LD_ADDR_VAR 0 8
16886: PUSH
16887: LD_VAR 0 1
16891: PPUSH
16892: LD_VAR 0 7
16896: PUSH
16897: LD_INT 1
16899: ARRAY
16900: PPUSH
16901: LD_VAR 0 7
16905: PUSH
16906: LD_INT 2
16908: ARRAY
16909: PPUSH
16910: CALL_OW 297
16914: ST_TO_ADDR
// xy := x ;
16915: LD_ADDR_VAR 0 9
16919: PUSH
16920: LD_VAR 0 7
16924: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16925: LD_VAR 0 9
16929: PUSH
16930: LD_VAR 0 1
16934: PPUSH
16935: LD_VAR 0 9
16939: PUSH
16940: LD_INT 1
16942: ARRAY
16943: PPUSH
16944: LD_VAR 0 9
16948: PUSH
16949: LD_INT 2
16951: ARRAY
16952: PPUSH
16953: CALL_OW 297
16957: PUSH
16958: LD_INT 9
16960: GREATER
16961: AND
16962: IFFALSE 16991
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16964: LD_VAR 0 1
16968: PPUSH
16969: LD_VAR 0 9
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 9
16982: PUSH
16983: LD_INT 2
16985: ARRAY
16986: PPUSH
16987: CALL_OW 114
// end ;
16991: GO 16844
16993: POP
16994: POP
// end else
16995: GO 17185
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16997: LD_ADDR_VAR 0 3
17001: PUSH
17002: LD_OWVAR 3
17006: PUSH
17007: LD_VAR 0 1
17011: DIFF
17012: PPUSH
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 74
17022: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17023: LD_VAR 0 1
17027: PPUSH
17028: CALL_OW 320
17032: NOT
17033: PUSH
17034: LD_VAR 0 3
17038: PUSH
17039: LD_INT 21
17041: PUSH
17042: LD_INT 2
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 33
17051: PUSH
17052: LD_INT 1
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PUSH
17059: LD_INT 58
17061: PUSH
17062: EMPTY
17063: LIST
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: LIST
17069: PPUSH
17070: CALL_OW 69
17074: IN
17075: PUSH
17076: LD_VAR 0 3
17080: PUSH
17081: LD_INT 22
17083: PUSH
17084: LD_INT 3
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: LD_INT 21
17093: PUSH
17094: LD_INT 2
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: PUSH
17101: LD_INT 3
17103: PUSH
17104: LD_INT 24
17106: PUSH
17107: LD_INT 249
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: LIST
17122: PPUSH
17123: CALL_OW 69
17127: IN
17128: OR
17129: AND
17130: IFFALSE 17148
// ComAttackUnit ( i , un ) else
17132: LD_VAR 0 1
17136: PPUSH
17137: LD_VAR 0 3
17141: PPUSH
17142: CALL_OW 115
17146: GO 17185
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17148: LD_VAR 0 1
17152: PPUSH
17153: LD_INT 9
17155: PPUSH
17156: LD_INT 81
17158: PUSH
17159: LD_INT 3
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PPUSH
17166: CALL_OW 70
17170: PPUSH
17171: LD_VAR 0 1
17175: PPUSH
17176: CALL_OW 74
17180: PPUSH
17181: CALL_OW 115
// end ; end ; end ; end ;
17185: GO 16452
17187: POP
17188: POP
// end ;
17189: PPOPN 9
17191: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17192: LD_INT 22
17194: PUSH
17195: LD_INT 3
17197: PUSH
17198: EMPTY
17199: LIST
17200: LIST
17201: PUSH
17202: LD_INT 32
17204: PUSH
17205: LD_INT 1
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PPUSH
17216: CALL_OW 69
17220: IFFALSE 17308
17222: GO 17224
17224: DISABLE
17225: LD_INT 0
17227: PPUSH
17228: PPUSH
// begin enable ;
17229: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17230: LD_ADDR_VAR 0 2
17234: PUSH
17235: LD_INT 22
17237: PUSH
17238: LD_INT 3
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: LD_INT 32
17247: PUSH
17248: LD_INT 1
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: PPUSH
17259: CALL_OW 69
17263: ST_TO_ADDR
// for i in tmp do
17264: LD_ADDR_VAR 0 1
17268: PUSH
17269: LD_VAR 0 2
17273: PUSH
17274: FOR_IN
17275: IFFALSE 17306
// if GetFuel ( i ) < 12 then
17277: LD_VAR 0 1
17281: PPUSH
17282: CALL_OW 261
17286: PUSH
17287: LD_INT 12
17289: LESS
17290: IFFALSE 17304
// SetFuel ( i , 12 ) ;
17292: LD_VAR 0 1
17296: PPUSH
17297: LD_INT 12
17299: PPUSH
17300: CALL_OW 240
17304: GO 17274
17306: POP
17307: POP
// end ;
17308: PPOPN 2
17310: END
// every 0 0$1 trigger can_end do
17311: LD_EXP 17
17315: IFFALSE 17338
17317: GO 17319
17319: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17320: LD_INT 3325
17322: PPUSH
17323: CALL_OW 67
// PrepareAttack ( 10 ) ;
17327: LD_INT 10
17329: PPUSH
17330: CALL 15160 0 1
// until false ;
17334: LD_INT 0
17336: IFFALSE 17320
// end ; end_of_file
17338: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17339: GO 17341
17341: DISABLE
// begin ru_radar := 98 ;
17342: LD_ADDR_EXP 40
17346: PUSH
17347: LD_INT 98
17349: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17350: LD_ADDR_EXP 41
17354: PUSH
17355: LD_INT 89
17357: ST_TO_ADDR
// us_hack := 99 ;
17358: LD_ADDR_EXP 42
17362: PUSH
17363: LD_INT 99
17365: ST_TO_ADDR
// us_artillery := 97 ;
17366: LD_ADDR_EXP 43
17370: PUSH
17371: LD_INT 97
17373: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17374: LD_ADDR_EXP 44
17378: PUSH
17379: LD_INT 91
17381: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
17382: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17383: LD_INT 0
17385: PPUSH
17386: PPUSH
17387: PPUSH
17388: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17389: LD_VAR 0 1
17393: PPUSH
17394: CALL_OW 264
17398: PUSH
17399: LD_EXP 44
17403: EQUAL
17404: IFFALSE 17476
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17406: LD_INT 68
17408: PPUSH
17409: LD_VAR 0 1
17413: PPUSH
17414: CALL_OW 255
17418: PPUSH
17419: CALL_OW 321
17423: PUSH
17424: LD_INT 2
17426: EQUAL
17427: IFFALSE 17439
// eff := 70 else
17429: LD_ADDR_VAR 0 6
17433: PUSH
17434: LD_INT 70
17436: ST_TO_ADDR
17437: GO 17447
// eff := 30 ;
17439: LD_ADDR_VAR 0 6
17443: PUSH
17444: LD_INT 30
17446: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17447: LD_VAR 0 1
17451: PPUSH
17452: CALL_OW 250
17456: PPUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 251
17466: PPUSH
17467: LD_VAR 0 6
17471: PPUSH
17472: CALL_OW 495
// end ; end ;
17476: LD_VAR 0 4
17480: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17481: LD_INT 0
17483: PPUSH
17484: PPUSH
17485: PPUSH
17486: PPUSH
17487: PPUSH
17488: PPUSH
// if cmd = 124 then
17489: LD_VAR 0 1
17493: PUSH
17494: LD_INT 124
17496: EQUAL
17497: IFFALSE 17703
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17499: LD_ADDR_VAR 0 5
17503: PUSH
17504: LD_INT 2
17506: PUSH
17507: LD_INT 34
17509: PUSH
17510: LD_INT 53
17512: PUSH
17513: EMPTY
17514: LIST
17515: LIST
17516: PUSH
17517: LD_INT 34
17519: PUSH
17520: LD_INT 14
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: LIST
17531: PPUSH
17532: CALL_OW 69
17536: ST_TO_ADDR
// if not tmp then
17537: LD_VAR 0 5
17541: NOT
17542: IFFALSE 17546
// exit ;
17544: GO 17703
// for i in tmp do
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_VAR 0 5
17555: PUSH
17556: FOR_IN
17557: IFFALSE 17701
// begin taskList := GetTaskList ( i ) ;
17559: LD_ADDR_VAR 0 6
17563: PUSH
17564: LD_VAR 0 3
17568: PPUSH
17569: CALL_OW 437
17573: ST_TO_ADDR
// if not taskList then
17574: LD_VAR 0 6
17578: NOT
17579: IFFALSE 17583
// continue ;
17581: GO 17556
// for j = 1 to taskList do
17583: LD_ADDR_VAR 0 4
17587: PUSH
17588: DOUBLE
17589: LD_INT 1
17591: DEC
17592: ST_TO_ADDR
17593: LD_VAR 0 6
17597: PUSH
17598: FOR_TO
17599: IFFALSE 17697
// if taskList [ j ] [ 1 ] = | then
17601: LD_VAR 0 6
17605: PUSH
17606: LD_VAR 0 4
17610: ARRAY
17611: PUSH
17612: LD_INT 1
17614: ARRAY
17615: PUSH
17616: LD_STRING |
17618: EQUAL
17619: IFFALSE 17695
// begin _taskList := Delete ( taskList , 1 ) ;
17621: LD_ADDR_VAR 0 7
17625: PUSH
17626: LD_VAR 0 6
17630: PPUSH
17631: LD_INT 1
17633: PPUSH
17634: CALL_OW 3
17638: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17639: LD_VAR 0 3
17643: PPUSH
17644: LD_VAR 0 7
17648: PPUSH
17649: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17653: LD_VAR 0 3
17657: PPUSH
17658: LD_VAR 0 6
17662: PUSH
17663: LD_VAR 0 4
17667: ARRAY
17668: PUSH
17669: LD_INT 2
17671: ARRAY
17672: PPUSH
17673: LD_VAR 0 6
17677: PUSH
17678: LD_VAR 0 4
17682: ARRAY
17683: PUSH
17684: LD_INT 3
17686: ARRAY
17687: PPUSH
17688: LD_INT 8
17690: PPUSH
17691: CALL 17708 0 4
// end ;
17695: GO 17598
17697: POP
17698: POP
// end ;
17699: GO 17556
17701: POP
17702: POP
// end ; end ;
17703: LD_VAR 0 2
17707: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17708: LD_INT 0
17710: PPUSH
17711: PPUSH
17712: PPUSH
17713: PPUSH
17714: PPUSH
17715: PPUSH
17716: PPUSH
17717: PPUSH
17718: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17719: LD_VAR 0 1
17723: NOT
17724: PUSH
17725: LD_VAR 0 2
17729: PPUSH
17730: LD_VAR 0 3
17734: PPUSH
17735: CALL_OW 488
17739: NOT
17740: OR
17741: PUSH
17742: LD_VAR 0 4
17746: NOT
17747: OR
17748: IFFALSE 17752
// exit ;
17750: GO 18092
// list := [ ] ;
17752: LD_ADDR_VAR 0 13
17756: PUSH
17757: EMPTY
17758: ST_TO_ADDR
// if x - r < 0 then
17759: LD_VAR 0 2
17763: PUSH
17764: LD_VAR 0 4
17768: MINUS
17769: PUSH
17770: LD_INT 0
17772: LESS
17773: IFFALSE 17785
// min_x := 0 else
17775: LD_ADDR_VAR 0 7
17779: PUSH
17780: LD_INT 0
17782: ST_TO_ADDR
17783: GO 17801
// min_x := x - r ;
17785: LD_ADDR_VAR 0 7
17789: PUSH
17790: LD_VAR 0 2
17794: PUSH
17795: LD_VAR 0 4
17799: MINUS
17800: ST_TO_ADDR
// if y - r < 0 then
17801: LD_VAR 0 3
17805: PUSH
17806: LD_VAR 0 4
17810: MINUS
17811: PUSH
17812: LD_INT 0
17814: LESS
17815: IFFALSE 17827
// min_y := 0 else
17817: LD_ADDR_VAR 0 8
17821: PUSH
17822: LD_INT 0
17824: ST_TO_ADDR
17825: GO 17843
// min_y := y - r ;
17827: LD_ADDR_VAR 0 8
17831: PUSH
17832: LD_VAR 0 3
17836: PUSH
17837: LD_VAR 0 4
17841: MINUS
17842: ST_TO_ADDR
// max_x := x + r ;
17843: LD_ADDR_VAR 0 9
17847: PUSH
17848: LD_VAR 0 2
17852: PUSH
17853: LD_VAR 0 4
17857: PLUS
17858: ST_TO_ADDR
// max_y := y + r ;
17859: LD_ADDR_VAR 0 10
17863: PUSH
17864: LD_VAR 0 3
17868: PUSH
17869: LD_VAR 0 4
17873: PLUS
17874: ST_TO_ADDR
// for _x = min_x to max_x do
17875: LD_ADDR_VAR 0 11
17879: PUSH
17880: DOUBLE
17881: LD_VAR 0 7
17885: DEC
17886: ST_TO_ADDR
17887: LD_VAR 0 9
17891: PUSH
17892: FOR_TO
17893: IFFALSE 18010
// for _y = min_y to max_y do
17895: LD_ADDR_VAR 0 12
17899: PUSH
17900: DOUBLE
17901: LD_VAR 0 8
17905: DEC
17906: ST_TO_ADDR
17907: LD_VAR 0 10
17911: PUSH
17912: FOR_TO
17913: IFFALSE 18006
// begin if not ValidHex ( _x , _y ) then
17915: LD_VAR 0 11
17919: PPUSH
17920: LD_VAR 0 12
17924: PPUSH
17925: CALL_OW 488
17929: NOT
17930: IFFALSE 17934
// continue ;
17932: GO 17912
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
17934: LD_VAR 0 11
17938: PPUSH
17939: LD_VAR 0 12
17943: PPUSH
17944: CALL_OW 351
17948: PUSH
17949: LD_VAR 0 11
17953: PPUSH
17954: LD_VAR 0 12
17958: PPUSH
17959: CALL_OW 554
17963: AND
17964: IFFALSE 18004
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
17966: LD_ADDR_VAR 0 13
17970: PUSH
17971: LD_VAR 0 13
17975: PPUSH
17976: LD_VAR 0 13
17980: PUSH
17981: LD_INT 1
17983: PLUS
17984: PPUSH
17985: LD_VAR 0 11
17989: PUSH
17990: LD_VAR 0 12
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: PPUSH
17999: CALL_OW 2
18003: ST_TO_ADDR
// end ;
18004: GO 17912
18006: POP
18007: POP
18008: GO 17892
18010: POP
18011: POP
// if not list then
18012: LD_VAR 0 13
18016: NOT
18017: IFFALSE 18021
// exit ;
18019: GO 18092
// for i in list do
18021: LD_ADDR_VAR 0 6
18025: PUSH
18026: LD_VAR 0 13
18030: PUSH
18031: FOR_IN
18032: IFFALSE 18090
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18034: LD_VAR 0 1
18038: PPUSH
18039: LD_STRING M
18041: PUSH
18042: LD_VAR 0 6
18046: PUSH
18047: LD_INT 1
18049: ARRAY
18050: PUSH
18051: LD_VAR 0 6
18055: PUSH
18056: LD_INT 2
18058: ARRAY
18059: PUSH
18060: LD_INT 0
18062: PUSH
18063: LD_INT 0
18065: PUSH
18066: LD_INT 0
18068: PUSH
18069: LD_INT 0
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: LIST
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: PPUSH
18084: CALL_OW 447
18088: GO 18031
18090: POP
18091: POP
// end ;
18092: LD_VAR 0 5
18096: RET
