// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13692 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2966 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := 0 ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// hc_name := Peter McCreery ;
2391: LD_ADDR_OWVAR 26
2395: PUSH
2396: LD_STRING Peter McCreery
2398: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2399: LD_ADDR_OWVAR 33
2403: PUSH
2404: LD_STRING SecondCharsGal
2406: ST_TO_ADDR
// hc_face_number := 58 ;
2407: LD_ADDR_OWVAR 34
2411: PUSH
2412: LD_INT 58
2414: ST_TO_ADDR
// hc_sex := sex_male ;
2415: LD_ADDR_OWVAR 27
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// hc_class := 4 ;
2423: LD_ADDR_OWVAR 28
2427: PUSH
2428: LD_INT 4
2430: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 2 ] ;
2431: LD_ADDR_OWVAR 30
2435: PUSH
2436: LD_INT 0
2438: PUSH
2439: LD_INT 0
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 6 ] ;
2454: LD_ADDR_OWVAR 31
2458: PUSH
2459: LD_INT 1
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 3
2467: PUSH
2468: LD_INT 6
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// un := CreateHuman ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// SetTag ( un , 11 ) ;
2487: LD_VAR 0 5
2491: PPUSH
2492: LD_INT 11
2494: PPUSH
2495: CALL_OW 109
// tmp := tmp ^ un ;
2499: LD_ADDR_VAR 0 4
2503: PUSH
2504: LD_VAR 0 4
2508: PUSH
2509: LD_VAR 0 5
2513: ADD
2514: ST_TO_ADDR
// tmp := tmp diff 0 ;
2515: LD_ADDR_VAR 0 4
2519: PUSH
2520: LD_VAR 0 4
2524: PUSH
2525: LD_INT 0
2527: DIFF
2528: ST_TO_ADDR
// InitHc ;
2529: CALL_OW 19
// hc_name :=  ;
2533: LD_ADDR_OWVAR 26
2537: PUSH
2538: LD_STRING 
2540: ST_TO_ADDR
// hc_gallery :=  ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING 
2548: ST_TO_ADDR
// if debug then
2549: LD_EXP 2
2553: IFFALSE 2604
// begin for i = 1 to 6 do
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: DOUBLE
2561: LD_INT 1
2563: DEC
2564: ST_TO_ADDR
2565: LD_INT 6
2567: PUSH
2568: FOR_TO
2569: IFFALSE 2602
// begin PrepareHuman ( false , 1 , 6 ) ;
2571: LD_INT 0
2573: PPUSH
2574: LD_INT 1
2576: PPUSH
2577: LD_INT 6
2579: PPUSH
2580: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_VAR 0 4
2593: PUSH
2594: CALL_OW 44
2598: ADD
2599: ST_TO_ADDR
// end ;
2600: GO 2568
2602: POP
2603: POP
// end ; for i in tmp do
2604: LD_ADDR_VAR 0 2
2608: PUSH
2609: LD_VAR 0 4
2613: PUSH
2614: FOR_IN
2615: IFFALSE 2674
// begin if GetClass ( i ) in [ 2 , 3 ] then
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 257
2626: PUSH
2627: LD_INT 2
2629: PUSH
2630: LD_INT 3
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: IN
2637: IFFALSE 2651
// SetClass ( i , 1 ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 1
2646: PPUSH
2647: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 106
2658: PPUSH
2659: LD_INT 122
2661: PPUSH
2662: LD_INT 5
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 50
// end ;
2672: GO 2614
2674: POP
2675: POP
// tmp := tmp diff Gary ;
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_EXP 22
2690: DIFF
2691: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 30
2709: PUSH
2710: LD_INT 31
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PPUSH
2721: CALL_OW 69
2725: ST_TO_ADDR
// for i = 1 to b do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: DOUBLE
2732: LD_INT 1
2734: DEC
2735: ST_TO_ADDR
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_TO
2742: IFFALSE 2787
// ComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) [ i ] , b [ i ] ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_INT 25
2751: PUSH
2752: LD_INT 1
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 72
2763: PUSH
2764: LD_VAR 0 2
2768: ARRAY
2769: PPUSH
2770: LD_VAR 0 3
2774: PUSH
2775: LD_VAR 0 2
2779: ARRAY
2780: PPUSH
2781: CALL_OW 120
2785: GO 2741
2787: POP
2788: POP
// InitHc ;
2789: CALL_OW 19
// InitUc ;
2793: CALL_OW 18
// end ;
2797: LD_VAR 0 1
2801: RET
// export function PowellTransport ; var i , un ; begin
2802: LD_INT 0
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side := 4 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 4
2814: ST_TO_ADDR
// uc_nation := 1 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2823: LD_INT 1
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: LD_INT 6
2831: PPUSH
2832: CALL_OW 380
// hc_name :=  ;
2836: LD_ADDR_OWVAR 26
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING SecondCharsGal
2851: ST_TO_ADDR
// hc_face_number := 30 ;
2852: LD_ADDR_OWVAR 34
2856: PUSH
2857: LD_INT 30
2859: ST_TO_ADDR
// powell_trans := CreateHuman ;
2860: LD_ADDR_EXP 27
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// hc_face_number := 31 ;
2870: LD_ADDR_OWVAR 34
2874: PUSH
2875: LD_INT 31
2877: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2878: LD_ADDR_EXP 27
2882: PUSH
2883: LD_EXP 27
2887: PUSH
2888: CALL_OW 44
2892: ADD
2893: ST_TO_ADDR
// for i = 1 to 2 do
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: DOUBLE
2900: LD_INT 1
2902: DEC
2903: ST_TO_ADDR
2904: LD_INT 2
2906: PUSH
2907: FOR_TO
2908: IFFALSE 2959
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2910: LD_ADDR_VAR 0 3
2914: PUSH
2915: LD_INT 4
2917: PPUSH
2918: LD_INT 1
2920: PPUSH
2921: LD_INT 3
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: LD_INT 12
2932: PPUSH
2933: LD_INT 66
2935: PPUSH
2936: CALL 423 0 7
2940: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2941: LD_ADDR_EXP 27
2945: PUSH
2946: LD_EXP 27
2950: PUSH
2951: LD_VAR 0 3
2955: ADD
2956: ST_TO_ADDR
// end ;
2957: GO 2907
2959: POP
2960: POP
// end ; end_of_file
2961: LD_VAR 0 1
2965: RET
// export function Action ; var i , veh ; begin
2966: LD_INT 0
2968: PPUSH
2969: PPUSH
2970: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2971: LD_EXP 26
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: LD_INT 50
2981: PPUSH
2982: LD_INT 38
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: CALL_OW 145
// InGameOn ;
2992: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2996: LD_INT 43
2998: PPUSH
2999: LD_INT 9
3001: PPUSH
3002: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
3006: LD_EXP 21
3010: PPUSH
3011: LD_INT 54
3013: PPUSH
3014: LD_INT 34
3016: PPUSH
3017: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
3021: LD_EXP 21
3025: PPUSH
3026: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
3030: LD_EXP 21
3034: PPUSH
3035: LD_EXP 26
3039: PUSH
3040: LD_INT 1
3042: ARRAY
3043: PPUSH
3044: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// until See ( 4 , JMM ) ;
3055: LD_INT 4
3057: PPUSH
3058: LD_EXP 21
3062: PPUSH
3063: CALL_OW 292
3067: IFFALSE 3048
// CenterNowOnUnits ( JMM ) ;
3069: LD_EXP 21
3073: PPUSH
3074: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
3078: LD_EXP 21
3082: PPUSH
3083: LD_STRING D2-JMM-1
3085: PPUSH
3086: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
3090: LD_EXP 26
3094: PUSH
3095: LD_INT 3
3097: ARRAY
3098: PPUSH
3099: LD_EXP 21
3103: PPUSH
3104: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
3108: LD_EXP 26
3112: PUSH
3113: LD_INT 3
3115: ARRAY
3116: PPUSH
3117: LD_STRING D2-Eng1-1
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3124: LD_EXP 21
3128: PPUSH
3129: LD_STRING D2-JMM-2
3131: PPUSH
3132: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
3136: LD_EXP 26
3140: PUSH
3141: LD_INT 3
3143: ARRAY
3144: PPUSH
3145: LD_STRING D2-Eng1-2
3147: PPUSH
3148: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3152: LD_EXP 21
3156: PPUSH
3157: LD_STRING D2-JMM-3
3159: PPUSH
3160: CALL_OW 88
// if Houten then
3164: LD_EXP 25
3168: IFFALSE 3366
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3170: LD_ADDR_VAR 0 3
3174: PUSH
3175: LD_INT 4
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 4
3192: PPUSH
3193: LD_INT 55
3195: PPUSH
3196: CALL 423 0 7
3200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3201: LD_VAR 0 3
3205: PPUSH
3206: LD_INT 3
3208: PPUSH
3209: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3213: LD_VAR 0 3
3217: PPUSH
3218: LD_INT 46
3220: PPUSH
3221: LD_INT 19
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3231: LD_EXP 25
3235: PPUSH
3236: LD_VAR 0 3
3240: PPUSH
3241: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3245: LD_EXP 25
3249: PPUSH
3250: LD_INT 49
3252: PPUSH
3253: LD_INT 33
3255: PPUSH
3256: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3260: LD_EXP 25
3264: PPUSH
3265: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3269: LD_EXP 25
3273: PPUSH
3274: LD_EXP 21
3278: PPUSH
3279: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3283: LD_INT 35
3285: PPUSH
3286: CALL_OW 67
// until See ( 1 , Houten ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_EXP 25
3297: PPUSH
3298: CALL_OW 292
3302: IFFALSE 3283
// ComTurnUnit ( JMM , Houten ) ;
3304: LD_EXP 21
3308: PPUSH
3309: LD_EXP 25
3313: PPUSH
3314: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3318: LD_EXP 21
3322: PPUSH
3323: LD_STRING D1d-JMM-1
3325: PPUSH
3326: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3330: LD_EXP 25
3334: PPUSH
3335: LD_STRING D1-VanH-1
3337: PPUSH
3338: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3342: LD_EXP 21
3346: PPUSH
3347: LD_STRING D1-JMM-1v
3349: PPUSH
3350: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3354: LD_EXP 21
3358: PPUSH
3359: LD_STRING D1-JMM-2v
3361: PPUSH
3362: CALL_OW 88
// end ; InGameOff ;
3366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3370: LD_STRING M1
3372: PPUSH
3373: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3377: LD_INT 22
3379: PUSH
3380: LD_INT 4
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 92
3389: PUSH
3390: LD_EXP 21
3394: PPUSH
3395: CALL_OW 250
3399: PUSH
3400: LD_EXP 21
3404: PPUSH
3405: CALL_OW 251
3409: PUSH
3410: LD_INT 15
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3435: LD_EXP 26
3439: PUSH
3440: LD_EXP 21
3444: ADD
3445: PUSH
3446: LD_EXP 25
3450: ADD
3451: PPUSH
3452: CALL_OW 141
// end ;
3456: LD_VAR 0 1
3460: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3461: LD_INT 1
3463: PPUSH
3464: LD_EXP 22
3468: PPUSH
3469: CALL_OW 292
3473: PUSH
3474: LD_EXP 21
3478: PPUSH
3479: LD_EXP 22
3483: PPUSH
3484: CALL_OW 296
3488: PUSH
3489: LD_INT 6
3491: LESS
3492: AND
3493: IFFALSE 4366
3495: GO 3497
3497: DISABLE
3498: LD_INT 0
3500: PPUSH
3501: PPUSH
3502: PPUSH
3503: PPUSH
3504: PPUSH
// begin InGameOn ;
3505: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PPUSH
3519: CALL_OW 69
3523: PPUSH
3524: LD_INT 1
3526: PPUSH
3527: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3531: LD_ADDR_VAR 0 4
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 1
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 25
3561: PUSH
3562: LD_INT 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 25
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 25
3581: PUSH
3582: LD_INT 4
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// ComHold ( tmp ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3614: LD_EXP 21
3618: PPUSH
3619: LD_STRING D2-JMM-3a
3621: PPUSH
3622: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3626: LD_EXP 22
3630: PPUSH
3631: LD_EXP 21
3635: PPUSH
3636: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3640: LD_EXP 22
3644: PPUSH
3645: LD_STRING D2-Gary-3
3647: PPUSH
3648: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3652: LD_EXP 21
3656: PPUSH
3657: LD_EXP 22
3661: PPUSH
3662: CALL_OW 119
// for i in tmp do
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: LD_VAR 0 4
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3722
// begin if IsInUnit ( i ) then
3679: LD_VAR 0 5
3683: PPUSH
3684: CALL_OW 310
3688: IFFALSE 3699
// ComExitBuilding ( i ) ;
3690: LD_VAR 0 5
3694: PPUSH
3695: CALL_OW 122
// wait ( 1 ) ;
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_EXP 21
3715: PPUSH
3716: CALL_OW 119
// end ;
3720: GO 3676
3722: POP
3723: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3724: LD_ADDR_VAR 0 4
3728: PUSH
3729: LD_VAR 0 4
3733: PUSH
3734: LD_EXP 21
3738: PUSH
3739: LD_EXP 25
3743: PUSH
3744: LD_EXP 22
3748: PUSH
3749: LD_EXP 24
3753: PUSH
3754: LD_EXP 23
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: PUSH
3766: LD_EXP 26
3770: ADD
3771: DIFF
3772: ST_TO_ADDR
// if Bobby then
3773: LD_EXP 23
3777: IFFALSE 3791
// Say ( Bobby , D2-Bobby-3 ) ;
3779: LD_EXP 23
3783: PPUSH
3784: LD_STRING D2-Bobby-3
3786: PPUSH
3787: CALL_OW 88
// if Cyrus then
3791: LD_EXP 24
3795: IFFALSE 3809
// Say ( Cyrus , D2-Cyrus-3 ) ;
3797: LD_EXP 24
3801: PPUSH
3802: LD_STRING D2-Cyrus-3
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3809: LD_EXP 21
3813: PPUSH
3814: LD_STRING D2-JMM-4
3816: PPUSH
3817: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3821: LD_EXP 22
3825: PPUSH
3826: LD_STRING D2-Gary-4
3828: PPUSH
3829: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3833: LD_ADDR_VAR 0 1
3837: PUSH
3838: LD_VAR 0 4
3842: PPUSH
3843: LD_INT 26
3845: PUSH
3846: LD_INT 1
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 72
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// if Cyrus then
3862: LD_EXP 24
3866: IFFALSE 3882
// Say ( Cyrus , D2-Cyrus-4 ) else
3868: LD_EXP 24
3872: PPUSH
3873: LD_STRING D2-Cyrus-4
3875: PPUSH
3876: CALL_OW 88
3880: GO 3894
// Say ( un1 , D2-Sol1-4 ) ;
3882: LD_VAR 0 1
3886: PPUSH
3887: LD_STRING D2-Sol1-4
3889: PPUSH
3890: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3894: LD_EXP 21
3898: PPUSH
3899: LD_STRING D2-JMM-5
3901: PPUSH
3902: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3906: LD_ADDR_VAR 0 2
3910: PUSH
3911: LD_EXP 26
3915: PPUSH
3916: LD_INT 91
3918: PUSH
3919: LD_EXP 21
3923: PUSH
3924: LD_INT 10
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: LIST
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 72
3950: ST_TO_ADDR
// if un2 then
3951: LD_VAR 0 2
3955: IFFALSE 4009
// begin un2 := un2 [ un2 ] ;
3957: LD_ADDR_VAR 0 2
3961: PUSH
3962: LD_VAR 0 2
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3973: LD_VAR 0 2
3977: PPUSH
3978: LD_STRING D2-FEng1-5
3980: PPUSH
3981: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3985: LD_EXP 21
3989: PPUSH
3990: LD_STRING D2-JMM-6
3992: PPUSH
3993: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_STRING D2-FEng1-6
4004: PPUSH
4005: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_EXP 26
4018: PPUSH
4019: LD_INT 91
4021: PUSH
4022: LD_EXP 21
4026: PUSH
4027: LD_INT 10
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 72
4053: ST_TO_ADDR
// if un3 then
4054: LD_VAR 0 3
4058: IFFALSE 4113
// begin un3 := un3 [ 1 ] ;
4060: LD_ADDR_VAR 0 3
4064: PUSH
4065: LD_VAR 0 3
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
4074: LD_VAR 0 3
4078: PPUSH
4079: LD_INT 114
4081: PPUSH
4082: LD_INT 122
4084: PPUSH
4085: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
4089: LD_VAR 0 3
4093: PPUSH
4094: LD_STRING D2-Eng1-6
4096: PPUSH
4097: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4101: LD_EXP 21
4105: PPUSH
4106: LD_STRING D2-JMM-7
4108: PPUSH
4109: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
4113: LD_EXP 22
4117: PPUSH
4118: LD_STRING D2-Gary-7
4120: PPUSH
4121: CALL_OW 88
// if un2 then
4125: LD_VAR 0 2
4129: IFFALSE 4143
// Say ( un2 , D2-FEng1-7 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING D2-FEng1-7
4138: PPUSH
4139: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
4143: LD_VAR 0 1
4147: PPUSH
4148: LD_STRING D2-Sol1-7
4150: PPUSH
4151: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
4155: LD_EXP 21
4159: PPUSH
4160: LD_STRING D2-JMM-8
4162: PPUSH
4163: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PPUSH
4182: CALL_OW 141
// InGameOff ;
4186: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4190: LD_STRING M1a
4192: PPUSH
4193: CALL_OW 337
// jmm_in_ovsyenko := true ;
4197: LD_ADDR_EXP 4
4201: PUSH
4202: LD_INT 1
4204: ST_TO_ADDR
// if debug then
4205: LD_EXP 2
4209: IFFALSE 4315
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PPUSH
4244: CALL_OW 274
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_INT 1000
4254: PPUSH
4255: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4259: LD_INT 22
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 30
4271: PUSH
4272: LD_INT 0
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PPUSH
4283: CALL_OW 69
4287: PUSH
4288: LD_INT 1
4290: ARRAY
4291: PPUSH
4292: CALL_OW 274
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 1000
4302: PPUSH
4303: CALL_OW 277
// ar_can_arrive := true ;
4307: LD_ADDR_EXP 10
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4315: LD_INT 1050
4317: PPUSH
4318: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4322: LD_ADDR_VAR 0 4
4326: PUSH
4327: LD_INT 25
4329: PUSH
4330: LD_INT 14
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// if not tmp then
4342: LD_VAR 0 4
4346: NOT
4347: IFFALSE 4351
// exit ;
4349: GO 4366
// ComMoveXY ( tmp , 75 , 75 ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_INT 75
4358: PPUSH
4359: LD_INT 75
4361: PPUSH
4362: CALL_OW 111
// end ;
4366: PPOPN 5
4368: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 30
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: LD_INT 57
4394: PUSH
4395: EMPTY
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: IFFALSE 4453
4413: GO 4415
4415: DISABLE
4416: LD_INT 0
4418: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4419: LD_ADDR_VAR 0 1
4423: PUSH
4424: LD_STRING M2easy
4426: PUSH
4427: LD_STRING M2
4429: PUSH
4430: LD_STRING M2hard
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4438: LD_VAR 0 1
4442: PUSH
4443: LD_OWVAR 67
4447: ARRAY
4448: PPUSH
4449: CALL_OW 337
// end ;
4453: PPOPN 1
4455: END
// every 3 3$00 do
4456: GO 4458
4458: DISABLE
// begin DialogueOn ;
4459: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4463: LD_EXP 28
4467: PPUSH
4468: LD_STRING D3-Pow-1
4470: PPUSH
4471: CALL_OW 94
// if jmm_in_ovsyenko then
4475: LD_EXP 4
4479: IFFALSE 4507
// begin Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 21
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4493: LD_EXP 21
4497: PPUSH
4498: LD_STRING D3-JMM-1b
4500: PPUSH
4501: CALL_OW 88
// end else
4505: GO 4519
// Say ( JMM , D3-JMM-1a ) ;
4507: LD_EXP 21
4511: PPUSH
4512: LD_STRING D3-JMM-1a
4514: PPUSH
4515: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4519: LD_EXP 28
4523: PPUSH
4524: LD_STRING D3-Pow-2
4526: PPUSH
4527: CALL_OW 94
// DialogueOff ;
4531: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4535: LD_STRING M3
4537: PPUSH
4538: CALL_OW 337
// powell_want_sib := true ;
4542: LD_ADDR_EXP 5
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end ;
4550: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4551: LD_EXP 6
4555: PUSH
4556: LD_INT 0
4558: EQUAL
4559: IFFALSE 6020
4561: GO 4563
4563: DISABLE
4564: LD_INT 0
4566: PPUSH
4567: PPUSH
4568: PPUSH
4569: PPUSH
4570: PPUSH
4571: PPUSH
4572: PPUSH
4573: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4574: LD_INT 4
4576: PPUSH
4577: LD_INT 1
4579: PPUSH
4580: CALL_OW 343
// PowellTransport ;
4584: CALL 2802 0 0
// for i = 1 to 3 do
4588: LD_ADDR_VAR 0 4
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_INT 3
4600: PUSH
4601: FOR_TO
4602: IFFALSE 4669
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 6
4611: PPUSH
4612: LD_VAR 0 4
4616: PPUSH
4617: CALL_OW 287
4621: ST_TO_ADDR
// if not tmp then
4622: LD_VAR 0 1
4626: NOT
4627: IFFALSE 4631
// continue ;
4629: GO 4601
// EraseResourceArea ( terminalArea , i ) ;
4631: LD_INT 6
4633: PPUSH
4634: LD_VAR 0 4
4638: PPUSH
4639: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4643: LD_EXP 3
4647: PPUSH
4648: CALL_OW 274
4652: PPUSH
4653: LD_VAR 0 4
4657: PPUSH
4658: LD_VAR 0 1
4662: PPUSH
4663: CALL_OW 276
// end ;
4667: GO 4601
4669: POP
4670: POP
// x := 43 ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_INT 43
4678: ST_TO_ADDR
// y := 3 ;
4679: LD_ADDR_VAR 0 3
4683: PUSH
4684: LD_INT 3
4686: ST_TO_ADDR
// for i = 3 to 4 do
4687: LD_ADDR_VAR 0 4
4691: PUSH
4692: DOUBLE
4693: LD_INT 3
4695: DEC
4696: ST_TO_ADDR
4697: LD_INT 4
4699: PUSH
4700: FOR_TO
4701: IFFALSE 4892
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4703: LD_EXP 27
4707: PUSH
4708: LD_VAR 0 4
4712: ARRAY
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4721: LD_EXP 27
4725: PUSH
4726: LD_VAR 0 4
4730: ARRAY
4731: PPUSH
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_VAR 0 3
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4749: LD_EXP 27
4753: PUSH
4754: LD_VAR 0 4
4758: PUSH
4759: LD_INT 2
4761: MINUS
4762: ARRAY
4763: PPUSH
4764: LD_EXP 27
4768: PUSH
4769: LD_VAR 0 4
4773: ARRAY
4774: PPUSH
4775: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4779: LD_EXP 27
4783: PUSH
4784: LD_VAR 0 4
4788: ARRAY
4789: PPUSH
4790: LD_INT 1
4792: PPUSH
4793: LD_INT 100
4795: PPUSH
4796: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4800: LD_EXP 27
4804: PUSH
4805: LD_VAR 0 4
4809: PUSH
4810: LD_INT 2
4812: MINUS
4813: ARRAY
4814: PPUSH
4815: LD_INT 54
4817: PPUSH
4818: LD_INT 42
4820: PPUSH
4821: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4825: LD_EXP 27
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_INT 2
4837: MINUS
4838: ARRAY
4839: PPUSH
4840: LD_EXP 3
4844: PPUSH
4845: CALL_OW 250
4849: PPUSH
4850: LD_EXP 3
4854: PPUSH
4855: CALL_OW 251
4859: PPUSH
4860: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4864: LD_EXP 27
4868: PUSH
4869: LD_VAR 0 4
4873: PUSH
4874: LD_INT 2
4876: MINUS
4877: ARRAY
4878: PPUSH
4879: CALL_OW 200
// Wait ( 0 0$02 ) ;
4883: LD_INT 70
4885: PPUSH
4886: CALL_OW 67
// end ;
4890: GO 4700
4892: POP
4893: POP
// time := 0 0$20 ;
4894: LD_ADDR_VAR 0 8
4898: PUSH
4899: LD_INT 700
4901: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4902: LD_INT 35
4904: PPUSH
4905: CALL_OW 67
// time := time - 0 0$01 ;
4909: LD_ADDR_VAR 0 8
4913: PUSH
4914: LD_VAR 0 8
4918: PUSH
4919: LD_INT 35
4921: MINUS
4922: ST_TO_ADDR
// for i = 3 to 4 do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 3
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 5072
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4939: LD_EXP 27
4943: PUSH
4944: LD_VAR 0 4
4948: ARRAY
4949: PPUSH
4950: LD_INT 1
4952: PPUSH
4953: CALL_OW 289
4957: PUSH
4958: LD_INT 0
4960: GREATER
4961: PUSH
4962: LD_EXP 27
4966: PUSH
4967: LD_VAR 0 4
4971: ARRAY
4972: PPUSH
4973: CALL_OW 314
4977: NOT
4978: AND
4979: IFFALSE 5070
// begin x := rand ( 0 , 5 ) ;
4981: LD_ADDR_VAR 0 2
4985: PUSH
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 5
4991: PPUSH
4992: CALL_OW 12
4996: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4997: LD_EXP 27
5001: PUSH
5002: LD_VAR 0 4
5006: ARRAY
5007: PPUSH
5008: LD_EXP 27
5012: PUSH
5013: LD_VAR 0 4
5017: ARRAY
5018: PPUSH
5019: CALL_OW 250
5023: PPUSH
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 3
5031: PPUSH
5032: CALL_OW 272
5036: PPUSH
5037: LD_EXP 27
5041: PUSH
5042: LD_VAR 0 4
5046: ARRAY
5047: PPUSH
5048: CALL_OW 251
5052: PPUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: CALL_OW 273
5065: PPUSH
5066: CALL_OW 171
// end ;
5070: GO 4936
5072: POP
5073: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 1
5081: ARRAY
5082: PPUSH
5083: LD_INT 54
5085: PPUSH
5086: LD_INT 42
5088: PPUSH
5089: CALL_OW 297
5093: PUSH
5094: LD_INT 4
5096: LESS
5097: PUSH
5098: LD_VAR 0 8
5102: PUSH
5103: LD_INT 0
5105: EQUAL
5106: OR
5107: IFFALSE 4902
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
5109: LD_EXP 27
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
5128: LD_EXP 27
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: LD_INT 0
5142: PPUSH
5143: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
5147: LD_EXP 3
5151: PPUSH
5152: CALL_OW 274
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 200
5162: PPUSH
5163: CALL_OW 276
// DialogueOn ;
5167: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5171: LD_INT 53
5173: PPUSH
5174: LD_INT 35
5176: PPUSH
5177: CALL_OW 86
// un := powell_trans [ 1 ] ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_EXP 27
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D4-Mech1-1
5202: PPUSH
5203: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5207: LD_EXP 21
5211: PPUSH
5212: LD_STRING D4-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5219: LD_VAR 0 5
5223: PPUSH
5224: LD_STRING D4-Mech1-2
5226: PPUSH
5227: CALL_OW 88
// powell_happy := false ;
5231: LD_ADDR_VAR 0 6
5235: PUSH
5236: LD_INT 0
5238: ST_TO_ADDR
// take_cargo := false ;
5239: LD_ADDR_VAR 0 7
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5247: CALL 943 0 0
5251: PUSH
5252: LD_INT 60
5254: GREATEREQUAL
5255: IFFALSE 5303
// begin Say ( JMM , D5-JMM-1 ) ;
5257: LD_EXP 21
5261: PPUSH
5262: LD_STRING D5-JMM-1
5264: PPUSH
5265: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5269: LD_VAR 0 5
5273: PPUSH
5274: LD_STRING D6-Mech1-1
5276: PPUSH
5277: CALL_OW 88
// powell_happy := true ;
5281: LD_ADDR_VAR 0 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// take_cargo := true ;
5289: LD_ADDR_VAR 0 7
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// DialogueOff ;
5297: CALL_OW 7
// end else
5301: GO 5537
// if GetTerminalCargo > 0 then
5303: CALL 943 0 0
5307: PUSH
5308: LD_INT 0
5310: GREATER
5311: IFFALSE 5509
// begin case Query ( QWait ) of 1 :
5313: LD_STRING QWait
5315: PPUSH
5316: CALL_OW 97
5320: PUSH
5321: LD_INT 1
5323: DOUBLE
5324: EQUAL
5325: IFTRUE 5329
5327: GO 5420
5329: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5330: LD_EXP 21
5334: PPUSH
5335: LD_STRING D5a-JMM-1
5337: PPUSH
5338: CALL_OW 88
// DialogueOff ;
5342: CALL_OW 7
// wait ( 5 5$00 ) ;
5346: LD_INT 10500
5348: PPUSH
5349: CALL_OW 67
// if GetTerminalCargo < 60 then
5353: CALL 943 0 0
5357: PUSH
5358: LD_INT 60
5360: LESS
5361: IFFALSE 5402
// begin DialogueOn ;
5363: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5367: LD_EXP 3
5371: PPUSH
5372: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_STRING D6-Mech1-1a
5383: PPUSH
5384: CALL_OW 88
// DialogueOff ;
5388: CALL_OW 7
// powell_happy := false ;
5392: LD_ADDR_VAR 0 6
5396: PUSH
5397: LD_INT 0
5399: ST_TO_ADDR
// end else
5400: GO 5418
// begin powell_happy := true ;
5402: LD_ADDR_VAR 0 6
5406: PUSH
5407: LD_INT 1
5409: ST_TO_ADDR
// take_cargo := true ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// end ; end ; 2 :
5418: GO 5507
5420: LD_INT 2
5422: DOUBLE
5423: EQUAL
5424: IFTRUE 5428
5426: GO 5467
5428: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5429: LD_EXP 21
5433: PPUSH
5434: LD_STRING D5b-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_STRING D6-Mech1-1a
5448: PPUSH
5449: CALL_OW 88
// DialogueOff ;
5453: CALL_OW 7
// take_cargo := true ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// end ; 3 :
5465: GO 5507
5467: LD_INT 3
5469: DOUBLE
5470: EQUAL
5471: IFTRUE 5475
5473: GO 5506
5475: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5476: LD_EXP 21
5480: PPUSH
5481: LD_STRING D5c-JMM-1
5483: PPUSH
5484: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5488: LD_VAR 0 5
5492: PPUSH
5493: LD_STRING D6-Mech1-1b
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ; end ;
5504: GO 5507
5506: POP
// end else
5507: GO 5537
// begin Say ( JMM , D5c-JMM-1 ) ;
5509: LD_EXP 21
5513: PPUSH
5514: LD_STRING D5c-JMM-1
5516: PPUSH
5517: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_STRING D6-Mech1-1b
5528: PPUSH
5529: CALL_OW 88
// DialogueOff ;
5533: CALL_OW 7
// end ; if take_cargo then
5537: LD_VAR 0 7
5541: IFFALSE 5620
// begin x := GetTerminalCargo ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL 943 0 0
5552: ST_TO_ADDR
// if x > 60 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 60
5560: GREATER
5561: IFFALSE 5571
// x := 60 ;
5563: LD_ADDR_VAR 0 2
5567: PUSH
5568: LD_INT 60
5570: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5571: LD_EXP 3
5575: PPUSH
5576: CALL_OW 274
5580: PPUSH
5581: LD_INT 3
5583: PPUSH
5584: CALL 943 0 0
5588: PUSH
5589: LD_VAR 0 2
5593: MINUS
5594: PPUSH
5595: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5599: LD_EXP 27
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PPUSH
5608: LD_INT 3
5610: PPUSH
5611: LD_VAR 0 2
5615: PPUSH
5616: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5620: LD_EXP 27
5624: PPUSH
5625: LD_INT 43
5627: PPUSH
5628: LD_INT 3
5630: PPUSH
5631: CALL_OW 171
// x := 0 0$20 ;
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_INT 700
5642: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5643: LD_INT 35
5645: PPUSH
5646: CALL_OW 67
// x := x - 0 0$01 ;
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 35
5662: MINUS
5663: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5664: LD_VAR 0 2
5668: PUSH
5669: LD_INT 0
5671: EQUAL
5672: PUSH
5673: LD_EXP 27
5677: PUSH
5678: LD_INT 3
5680: ARRAY
5681: PPUSH
5682: LD_INT 43
5684: PPUSH
5685: LD_INT 3
5687: PPUSH
5688: CALL_OW 297
5692: PUSH
5693: LD_INT 4
5695: LESS
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ARRAY
5705: PPUSH
5706: LD_INT 43
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: CALL_OW 297
5716: PUSH
5717: LD_INT 4
5719: LESS
5720: AND
5721: OR
5722: IFFALSE 5643
// for i in powell_trans do
5724: LD_ADDR_VAR 0 4
5728: PUSH
5729: LD_EXP 27
5733: PUSH
5734: FOR_IN
5735: IFFALSE 5748
// RemoveUnit ( i ) ;
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 64
5746: GO 5734
5748: POP
5749: POP
// if not powell_happy then
5750: LD_VAR 0 6
5754: NOT
5755: IFFALSE 5766
// powell_happy := - 1 ;
5757: LD_ADDR_VAR 0 6
5761: PUSH
5762: LD_INT 1
5764: NEG
5765: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5766: LD_STRING EarlySiberite
5768: PPUSH
5769: LD_VAR 0 6
5773: PPUSH
5774: CALL_OW 101
// if powell_happy then
5778: LD_VAR 0 6
5782: IFFALSE 5792
// earlySib := true ;
5784: LD_ADDR_EXP 19
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// if powell_happy then
5792: LD_VAR 0 6
5796: IFFALSE 5807
// ChangeMissionObjectives ( M3a ) else
5798: LD_STRING M3a
5800: PPUSH
5801: CALL_OW 337
5805: GO 5814
// ChangeMissionObjectives ( M3b ) ;
5807: LD_STRING M3b
5809: PPUSH
5810: CALL_OW 337
// ru_can_attack_terminal := true ;
5814: LD_ADDR_EXP 9
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5822: LD_INT 25200
5824: PPUSH
5825: CALL_OW 67
// time := 2 2$00 ;
5829: LD_ADDR_VAR 0 8
5833: PUSH
5834: LD_INT 4200
5836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5837: LD_INT 35
5839: PPUSH
5840: CALL_OW 67
// time := time - 0 0$1 ;
5844: LD_ADDR_VAR 0 8
5848: PUSH
5849: LD_VAR 0 8
5853: PUSH
5854: LD_INT 35
5856: MINUS
5857: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5858: LD_EXP 8
5862: NOT
5863: PUSH
5864: LD_EXP 38
5868: PUSH
5869: LD_INT 0
5871: EQUAL
5872: OR
5873: PUSH
5874: LD_VAR 0 8
5878: PUSH
5879: LD_INT 0
5881: EQUAL
5882: OR
5883: IFFALSE 5837
// if ru_force then
5885: LD_EXP 38
5889: IFFALSE 5988
// for i in ru_force do
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_EXP 38
5900: PUSH
5901: FOR_IN
5902: IFFALSE 5986
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 4
5911: PPUSH
5912: CALL_OW 292
5916: NOT
5917: PUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: LD_INT 81
5925: PUSH
5926: LD_INT 3
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PPUSH
5938: LD_VAR 0 4
5942: PPUSH
5943: CALL_OW 74
5947: PPUSH
5948: CALL_OW 296
5952: PUSH
5953: LD_INT 10
5955: GREATER
5956: AND
5957: IFFALSE 5984
// begin RemoveUnit ( i ) ;
5959: LD_VAR 0 4
5963: PPUSH
5964: CALL_OW 64
// ru_force := ru_force diff i ;
5968: LD_ADDR_EXP 38
5972: PUSH
5973: LD_EXP 38
5977: PUSH
5978: LD_VAR 0 4
5982: DIFF
5983: ST_TO_ADDR
// end ;
5984: GO 5901
5986: POP
5987: POP
// repeat wait ( 0 0$03 ) ;
5988: LD_INT 105
5990: PPUSH
5991: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5995: LD_EXP 8
5999: NOT
6000: PUSH
6001: LD_EXP 38
6005: PUSH
6006: LD_INT 3
6008: LESS
6009: OR
6010: IFFALSE 5988
// ar_can_arrive := true ;
6012: LD_ADDR_EXP 10
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// end ;
6020: PPOPN 8
6022: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 20
6028: PPUSH
6029: CALL_OW 325
6033: IFFALSE 6180
6035: GO 6037
6037: DISABLE
6038: LD_INT 0
6040: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Gary , Cyrus , Bobby , Houten ] ;
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_INT 22
6048: PUSH
6049: LD_INT 1
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PUSH
6056: LD_INT 26
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 25
6068: PUSH
6069: LD_INT 4
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: LD_EXP 22
6095: PUSH
6096: LD_EXP 24
6100: PUSH
6101: LD_EXP 23
6105: PUSH
6106: LD_EXP 25
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: DIFF
6118: ST_TO_ADDR
// if not un then
6119: LD_VAR 0 1
6123: NOT
6124: IFFALSE 6128
// exit ;
6126: GO 6180
// DialogueOn ;
6128: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
6132: LD_VAR 0 1
6136: PUSH
6137: LD_INT 1
6139: ARRAY
6140: PPUSH
6141: LD_STRING D13-Sci1-1
6143: PPUSH
6144: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
6148: LD_EXP 21
6152: PPUSH
6153: LD_STRING D13-JMM-1
6155: PPUSH
6156: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
6160: LD_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: ARRAY
6168: PPUSH
6169: LD_STRING D13-Sci1-2
6171: PPUSH
6172: CALL_OW 88
// DialogueOff ;
6176: CALL_OW 7
// end ;
6180: PPOPN 1
6182: END
// every 0 0$1 trigger GetTerminalCargo > 77 and not InBattle ( 1 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6183: CALL 943 0 0
6187: PUSH
6188: LD_INT 77
6190: GREATER
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 463
6199: NOT
6200: AND
6201: PUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 25
6214: PUSH
6215: LD_INT 4
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 26
6224: PUSH
6225: LD_INT 1
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: PUSH
6242: LD_EXP 21
6246: PUSH
6247: LD_EXP 23
6251: PUSH
6252: LD_EXP 24
6256: PUSH
6257: LD_EXP 22
6261: PUSH
6262: LD_EXP 25
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: AND
6275: IFFALSE 6453
6277: GO 6279
6279: DISABLE
6280: LD_INT 0
6282: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: LD_INT 22
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 25
6300: PUSH
6301: LD_INT 4
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: PUSH
6308: LD_INT 26
6310: PUSH
6311: LD_INT 1
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: PUSH
6328: LD_EXP 21
6332: PUSH
6333: LD_EXP 23
6337: PUSH
6338: LD_EXP 24
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: LD_EXP 25
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: DIFF
6360: ST_TO_ADDR
// DialogueOn ;
6361: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: ARRAY
6373: PPUSH
6374: LD_STRING D7-Sci1-1
6376: PPUSH
6377: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6381: LD_EXP 21
6385: PPUSH
6386: LD_STRING D7-JMM-1
6388: PPUSH
6389: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6393: LD_VAR 0 1
6397: PUSH
6398: LD_INT 1
6400: ARRAY
6401: PPUSH
6402: LD_STRING D7-Sci1-2
6404: PPUSH
6405: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6409: LD_EXP 21
6413: PPUSH
6414: LD_STRING D7-JMM-2
6416: PPUSH
6417: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 1
6428: ARRAY
6429: PPUSH
6430: LD_STRING D7-Sci1-3
6432: PPUSH
6433: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6437: LD_EXP 21
6441: PPUSH
6442: LD_STRING D7-JMM-3
6444: PPUSH
6445: CALL_OW 88
// DialogueOff ;
6449: CALL_OW 7
// end ;
6453: PPOPN 1
6455: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6456: LD_EXP 10
6460: IFFALSE 10083
6462: GO 6464
6464: DISABLE
6465: LD_INT 0
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
// begin PrepareArabian ;
6477: CALL 12798 0 0
// blocked := false ;
6481: LD_ADDR_EXP 18
6485: PUSH
6486: LD_INT 0
6488: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6489: LD_INT 35
6491: PPUSH
6492: CALL_OW 67
// until ar_spawned ;
6496: LD_EXP 11
6500: IFFALSE 6489
// have_crates := true ;
6502: LD_ADDR_VAR 0 9
6506: PUSH
6507: LD_INT 1
6509: ST_TO_ADDR
// player_want_info := 2 ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 2
6517: ST_TO_ADDR
// DialogueOn ;
6518: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6522: LD_EXP 29
6526: PPUSH
6527: LD_STRING D8-Ar1-1
6529: PPUSH
6530: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6534: LD_EXP 21
6538: PPUSH
6539: LD_STRING D8-JMM-1
6541: PPUSH
6542: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6546: LD_EXP 29
6550: PPUSH
6551: LD_STRING D8-Ar1-2
6553: PPUSH
6554: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6558: LD_EXP 21
6562: PPUSH
6563: LD_STRING D8-JMM-2
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6570: LD_EXP 29
6574: PPUSH
6575: LD_STRING D8-Ar1-3
6577: PPUSH
6578: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6582: LD_EXP 21
6586: PPUSH
6587: LD_STRING D8-JMM-3
6589: PPUSH
6590: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6594: LD_EXP 29
6598: PPUSH
6599: LD_STRING D8-Ar1-4
6601: PPUSH
6602: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6606: LD_EXP 21
6610: PPUSH
6611: LD_STRING D8-JMM-4
6613: PPUSH
6614: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6618: LD_EXP 29
6622: PPUSH
6623: LD_STRING D8-Ar1-5
6625: PPUSH
6626: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6630: LD_EXP 21
6634: PPUSH
6635: LD_STRING D8-JMM-5
6637: PPUSH
6638: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6642: LD_EXP 29
6646: PPUSH
6647: LD_STRING D8-Ar1-6
6649: PPUSH
6650: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6654: LD_EXP 30
6658: PPUSH
6659: LD_STRING D8-Ar2-6
6661: PPUSH
6662: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6666: LD_EXP 21
6670: PPUSH
6671: LD_STRING D8-JMM-6
6673: PPUSH
6674: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6678: LD_EXP 30
6682: PPUSH
6683: LD_STRING D8-Ar2-7
6685: PPUSH
6686: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6690: LD_STRING QBarracks
6692: PPUSH
6693: CALL_OW 97
6697: PUSH
6698: LD_INT 1
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6741
6706: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6707: LD_EXP 21
6711: PPUSH
6712: LD_STRING D8a-JMM-1
6714: PPUSH
6715: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6719: LD_EXP 29
6723: PPUSH
6724: LD_STRING D8a-Ar1-1
6726: PPUSH
6727: CALL_OW 94
// player_want_mortar := true ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 1
6738: ST_TO_ADDR
// end ; 2 :
6739: GO 6915
6741: LD_INT 2
6743: DOUBLE
6744: EQUAL
6745: IFTRUE 6749
6747: GO 6871
6749: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6750: LD_EXP 21
6754: PPUSH
6755: LD_STRING D8b-JMM-1
6757: PPUSH
6758: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6762: LD_EXP 29
6766: PPUSH
6767: LD_STRING D8b-Ar1-1
6769: PPUSH
6770: CALL_OW 94
// case Query ( QInfo ) of 1 :
6774: LD_STRING QInfo
6776: PPUSH
6777: CALL_OW 97
6781: PUSH
6782: LD_INT 1
6784: DOUBLE
6785: EQUAL
6786: IFTRUE 6790
6788: GO 6825
6790: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6791: LD_EXP 21
6795: PPUSH
6796: LD_STRING D8b1-JMM-1
6798: PPUSH
6799: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6803: LD_EXP 29
6807: PPUSH
6808: LD_STRING D8b1-Ar1-1
6810: PPUSH
6811: CALL_OW 94
// player_want_info := 2 ;
6815: LD_ADDR_EXP 13
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
// end ; 2 :
6823: GO 6869
6825: LD_INT 2
6827: DOUBLE
6828: EQUAL
6829: IFTRUE 6833
6831: GO 6868
6833: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6834: LD_EXP 21
6838: PPUSH
6839: LD_STRING D8b2-JMM-1
6841: PPUSH
6842: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6846: LD_EXP 29
6850: PPUSH
6851: LD_STRING D8b2-Ar1-1
6853: PPUSH
6854: CALL_OW 94
// player_want_info := 0 ;
6858: LD_ADDR_EXP 13
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ; end ;
6866: GO 6869
6868: POP
// end ; 3 :
6869: GO 6915
6871: LD_INT 3
6873: DOUBLE
6874: EQUAL
6875: IFTRUE 6879
6877: GO 6914
6879: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6880: LD_EXP 21
6884: PPUSH
6885: LD_STRING D8c-JMM-1
6887: PPUSH
6888: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6892: LD_EXP 29
6896: PPUSH
6897: LD_STRING D8c-Ar1-1
6899: PPUSH
6900: CALL_OW 94
// player_want_info := 0 ;
6904: LD_ADDR_EXP 13
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// end ; end ;
6912: GO 6915
6914: POP
// DialogueOff ;
6915: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: LD_INT 9
6926: PPUSH
6927: LD_INT 2
6929: PUSH
6930: LD_INT 30
6932: PUSH
6933: LD_INT 0
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 30
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 70
6959: ST_TO_ADDR
// if dep then
6960: LD_VAR 0 4
6964: IFFALSE 6980
// dep := dep [ 1 ] ;
6966: LD_ADDR_VAR 0 4
6970: PUSH
6971: LD_VAR 0 4
6975: PUSH
6976: LD_INT 1
6978: ARRAY
6979: ST_TO_ADDR
// if not dep then
6980: LD_VAR 0 4
6984: NOT
6985: IFFALSE 7023
// begin case Query ( QInfoNothing ) of 1 :
6987: LD_STRING QInfoNothing
6989: PPUSH
6990: CALL_OW 97
6994: PUSH
6995: LD_INT 1
6997: DOUBLE
6998: EQUAL
6999: IFTRUE 7003
7001: GO 7006
7003: POP
// ; end ;
7004: GO 7007
7006: POP
// player_want_info := false ;
7007: LD_ADDR_EXP 13
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
// player_want_mortar := false ;
7015: LD_ADDR_EXP 12
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
7023: LD_ADDR_VAR 0 3
7027: PUSH
7028: LD_INT 22
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 21
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PPUSH
7052: CALL_OW 69
7056: ST_TO_ADDR
// time := 1 1$55 ;
7057: LD_ADDR_VAR 0 5
7061: PUSH
7062: LD_INT 4025
7064: ST_TO_ADDR
// no_oil_gain := false ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// first_warn := false ;
7073: LD_ADDR_VAR 0 7
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// if player_want_mortar or player_want_info then
7081: LD_EXP 12
7085: PUSH
7086: LD_EXP 13
7090: OR
7091: IFFALSE 7196
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
7093: LD_EXP 36
7097: PPUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: CALL_OW 250
7122: PPUSH
7123: LD_VAR 0 4
7127: PPUSH
7128: CALL_OW 251
7132: PPUSH
7133: LD_VAR 0 4
7137: PPUSH
7138: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
7142: LD_EXP 36
7146: PPUSH
7147: LD_INT 25
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PPUSH
7162: LD_INT 86
7164: PPUSH
7165: LD_INT 121
7167: PPUSH
7168: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7172: LD_EXP 36
7176: PPUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 72
7191: PPUSH
7192: CALL_OW 200
// end ; if player_attacked_ar then
7196: LD_EXP 16
7200: IFFALSE 7204
// exit ;
7202: GO 10083
// if player_want_mortar then
7204: LD_EXP 12
7208: IFFALSE 8745
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7210: LD_EXP 30
7214: PPUSH
7215: LD_VAR 0 4
7219: PPUSH
7220: CALL_OW 250
7224: PUSH
7225: LD_INT 1
7227: PLUS
7228: PPUSH
7229: LD_VAR 0 4
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 1
7241: PLUS
7242: PPUSH
7243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7247: LD_INT 35
7249: PPUSH
7250: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7254: LD_EXP 30
7258: PPUSH
7259: LD_VAR 0 4
7263: PPUSH
7264: CALL_OW 296
7268: PUSH
7269: LD_INT 4
7271: LESS
7272: IFFALSE 7247
// for i = 1 to 6 do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: DOUBLE
7280: LD_INT 1
7282: DEC
7283: ST_TO_ADDR
7284: LD_INT 6
7286: PUSH
7287: FOR_TO
7288: IFFALSE 7492
// begin if player_attacked_ar then
7290: LD_EXP 16
7294: IFFALSE 7300
// exit ;
7296: POP
7297: POP
7298: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7300: LD_VAR 0 4
7304: PPUSH
7305: CALL_OW 274
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 275
7317: PUSH
7318: LD_INT 10
7320: LESS
7321: PUSH
7322: LD_VAR 0 7
7326: NOT
7327: AND
7328: IFFALSE 7391
// begin first_warn := true ;
7330: LD_ADDR_VAR 0 7
7334: PUSH
7335: LD_INT 1
7337: ST_TO_ADDR
// DialogueOn ;
7338: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7342: LD_EXP 31
7346: PPUSH
7347: LD_STRING D9a-FAr1-1
7349: PPUSH
7350: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7354: LD_EXP 21
7358: PPUSH
7359: LD_STRING D9a-JMM-1
7361: PPUSH
7362: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7366: LD_EXP 29
7370: PPUSH
7371: LD_STRING D9a2-Ar1-1
7373: PPUSH
7374: CALL_OW 88
// DialogueOff ;
7378: CALL_OW 7
// wait ( time ) ;
7382: LD_VAR 0 5
7386: PPUSH
7387: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7391: LD_VAR 0 4
7395: PPUSH
7396: CALL_OW 274
7400: PPUSH
7401: LD_INT 2
7403: PPUSH
7404: CALL_OW 275
7408: PUSH
7409: LD_INT 10
7411: LESS
7412: IFFALSE 7438
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7414: LD_EXP 29
7418: PPUSH
7419: LD_STRING D9a3-Ar1-1
7421: PPUSH
7422: CALL_OW 88
// no_oil_gain := true ;
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// break ;
7434: GO 7492
// end else
7436: GO 7490
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7438: LD_EXP 30
7442: PPUSH
7443: LD_VAR 0 4
7447: PPUSH
7448: LD_INT 2
7450: PPUSH
7451: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7455: LD_EXP 30
7459: PPUSH
7460: LD_VAR 0 3
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: MOD
7473: PUSH
7474: LD_INT 1
7476: PLUS
7477: ARRAY
7478: PPUSH
7479: CALL_OW 210
// wait ( 0 0$10 ) ;
7483: LD_INT 350
7485: PPUSH
7486: CALL_OW 67
// end ; end ;
7490: GO 7287
7492: POP
7493: POP
// if not no_oil_gain then
7494: LD_VAR 0 6
7498: NOT
7499: IFFALSE 8745
// begin repeat wait ( 0 0$01 ) ;
7501: LD_INT 35
7503: PPUSH
7504: CALL_OW 67
// if player_attacked_ar then
7508: LD_EXP 16
7512: IFFALSE 7516
// exit ;
7514: GO 10083
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7516: LD_VAR 0 3
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: CALL_OW 261
7529: PUSH
7530: LD_INT 80
7532: GREATER
7533: PUSH
7534: LD_VAR 0 3
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: PPUSH
7543: CALL_OW 261
7547: PUSH
7548: LD_INT 80
7550: GREATER
7551: AND
7552: PUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 3
7560: ARRAY
7561: PPUSH
7562: CALL_OW 261
7566: PUSH
7567: LD_INT 80
7569: GREATER
7570: AND
7571: IFFALSE 7501
// ComMoveXY ( Gali , 105 , 127 ) ;
7573: LD_EXP 30
7577: PPUSH
7578: LD_INT 105
7580: PPUSH
7581: LD_INT 127
7583: PPUSH
7584: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7588: LD_EXP 30
7592: PPUSH
7593: LD_INT 2
7595: PPUSH
7596: CALL_OW 173
// AddComHold ( Gali ) ;
7600: LD_EXP 30
7604: PPUSH
7605: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 10083
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7624: LD_EXP 30
7628: PPUSH
7629: LD_INT 105
7631: PPUSH
7632: LD_INT 127
7634: PPUSH
7635: CALL_OW 297
7639: PUSH
7640: LD_INT 4
7642: LESS
7643: IFFALSE 7609
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7645: LD_VAR 0 4
7649: PPUSH
7650: CALL_OW 274
7654: PPUSH
7655: LD_INT 1
7657: PPUSH
7658: CALL_OW 275
7662: PUSH
7663: LD_INT 50
7665: LESS
7666: IFFALSE 7968
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7668: LD_VAR 0 4
7672: PPUSH
7673: CALL_OW 274
7677: PPUSH
7678: LD_INT 1
7680: PPUSH
7681: CALL_OW 275
7685: PUSH
7686: LD_INT 0
7688: DOUBLE
7689: GREATEREQUAL
7690: IFFALSE 7698
7692: LD_INT 24
7694: DOUBLE
7695: LESSEQUAL
7696: IFTRUE 7700
7698: GO 7715
7700: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7701: LD_EXP 30
7705: PPUSH
7706: LD_STRING D9b-Ar2-1
7708: PPUSH
7709: CALL_OW 88
7713: GO 7745
7715: LD_INT 25
7717: DOUBLE
7718: GREATEREQUAL
7719: IFFALSE 7727
7721: LD_INT 49
7723: DOUBLE
7724: LESSEQUAL
7725: IFTRUE 7729
7727: GO 7744
7729: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7730: LD_EXP 30
7734: PPUSH
7735: LD_STRING D9b-Ar2-1a
7737: PPUSH
7738: CALL_OW 88
7742: GO 7745
7744: POP
// Say ( JMM , D9b-JMM-1 ) ;
7745: LD_EXP 21
7749: PPUSH
7750: LD_STRING D9b-JMM-1
7752: PPUSH
7753: CALL_OW 88
// x := 0 0$0 ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: LD_INT 0
7764: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7765: LD_INT 35
7767: PPUSH
7768: CALL_OW 67
// x := x + 0 0$1 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 35
7784: PLUS
7785: ST_TO_ADDR
// if player_attacked_ar then
7786: LD_EXP 16
7790: IFFALSE 7794
// exit ;
7792: GO 10083
// until x >= time ;
7794: LD_VAR 0 2
7798: PUSH
7799: LD_VAR 0 5
7803: GREATEREQUAL
7804: IFFALSE 7765
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7806: LD_VAR 0 4
7810: PPUSH
7811: CALL_OW 274
7815: PPUSH
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 275
7823: PUSH
7824: LD_INT 50
7826: LESS
7827: IFFALSE 7968
// begin have_crates := false ;
7829: LD_ADDR_VAR 0 9
7833: PUSH
7834: LD_INT 0
7836: ST_TO_ADDR
// DialogueOn ;
7837: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7841: LD_EXP 29
7845: PPUSH
7846: LD_STRING D9c-Ar1-1
7848: PPUSH
7849: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7853: LD_EXP 21
7857: PPUSH
7858: LD_STRING D9c-JMM-1
7860: PPUSH
7861: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7865: LD_EXP 29
7869: PPUSH
7870: LD_STRING D9c-Ar1-2
7872: PPUSH
7873: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7877: LD_EXP 31
7881: PPUSH
7882: LD_STRING D9c-FAr1-2
7884: PPUSH
7885: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7889: LD_EXP 29
7893: PPUSH
7894: LD_STRING D9c-Ar1-3
7896: PPUSH
7897: CALL_OW 88
// case Query ( QInfo ) of 1 :
7901: LD_STRING QInfo
7903: PPUSH
7904: CALL_OW 97
7908: PUSH
7909: LD_INT 1
7911: DOUBLE
7912: EQUAL
7913: IFTRUE 7917
7915: GO 7940
7917: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7918: LD_EXP 21
7922: PPUSH
7923: LD_STRING D8b1-JMM-1
7925: PPUSH
7926: CALL_OW 88
// player_want_info := 2 ;
7930: LD_ADDR_EXP 13
7934: PUSH
7935: LD_INT 2
7937: ST_TO_ADDR
// end ; 2 :
7938: GO 7964
7940: LD_INT 2
7942: DOUBLE
7943: EQUAL
7944: IFTRUE 7948
7946: GO 7963
7948: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7949: LD_EXP 29
7953: PPUSH
7954: LD_STRING D8b2-Ar1-1
7956: PPUSH
7957: CALL_OW 88
// end ; end ;
7961: GO 7964
7963: POP
// DialogueOff ;
7964: CALL_OW 7
// end ; end ; if have_crates then
7968: LD_VAR 0 9
7972: IFFALSE 8745
// begin RemoveEnvironmentArea ( mortarArea ) ;
7974: LD_INT 2
7976: PPUSH
7977: CALL_OW 355
// wait ( 1 ) ;
7981: LD_INT 1
7983: PPUSH
7984: CALL_OW 67
// InGameOn ;
7988: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7992: LD_EXP 30
7996: PPUSH
7997: CALL_OW 87
// SetSide ( Gali , 1 ) ;
8001: LD_EXP 30
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
8013: LD_ADDR_VAR 0 10
8017: PUSH
8018: LD_INT 22
8020: PUSH
8021: LD_INT 1
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 23
8033: PUSH
8034: LD_INT 2
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 21
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 92
8057: PUSH
8058: LD_INT 107
8060: PUSH
8061: LD_INT 131
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: ST_TO_ADDR
// if filter then
8084: LD_VAR 0 10
8088: IFFALSE 8122
// for i in filter do
8090: LD_ADDR_VAR 0 1
8094: PUSH
8095: LD_VAR 0 10
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8120
// ComMoveXY ( i , 107 , 121 ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_INT 107
8110: PPUSH
8111: LD_INT 121
8113: PPUSH
8114: CALL_OW 111
8118: GO 8100
8120: POP
8121: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
8122: LD_EXP 30
8126: PPUSH
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 131
8135: PPUSH
8136: LD_INT 0
8138: PPUSH
8139: CALL_OW 145
// wait ( 0 0$1 ) ;
8143: LD_INT 35
8145: PPUSH
8146: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
8150: LD_INT 30
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 23
8162: PUSH
8163: LD_INT 2
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: IFFALSE 8013
// SetSide ( Gali , 2 ) ;
8180: LD_EXP 30
8184: PPUSH
8185: LD_INT 2
8187: PPUSH
8188: CALL_OW 235
// InGameOff ;
8192: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8196: LD_ADDR_VAR 0 8
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 4
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 23
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8234: LD_INT 35
8236: PPUSH
8237: CALL_OW 67
// if player_attacked_ar then
8241: LD_EXP 16
8245: IFFALSE 8249
// exit ;
8247: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8249: LD_VAR 0 8
8253: PPUSH
8254: CALL_OW 461
8258: PUSH
8259: LD_INT 1
8261: NONEQUAL
8262: IFFALSE 8234
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8264: LD_VAR 0 8
8268: PPUSH
8269: CALL_OW 302
8273: PUSH
8274: LD_VAR 0 4
8278: PPUSH
8279: CALL_OW 274
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 275
8291: PUSH
8292: LD_INT 25
8294: GREATEREQUAL
8295: AND
8296: IFFALSE 8395
// begin ComUpgrade ( b ) ;
8298: LD_VAR 0 8
8302: PPUSH
8303: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8307: LD_EXP 30
8311: PPUSH
8312: LD_STRING h
8314: PUSH
8315: LD_VAR 0 8
8319: PPUSH
8320: CALL_OW 250
8324: PUSH
8325: LD_VAR 0 8
8329: PPUSH
8330: CALL_OW 251
8334: PUSH
8335: LD_VAR 0 8
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: PPUSH
8361: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// if player_attacked_ar then
8372: LD_EXP 16
8376: IFFALSE 8380
// exit ;
8378: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8380: LD_VAR 0 8
8384: PPUSH
8385: CALL_OW 461
8389: PUSH
8390: LD_INT 1
8392: NONEQUAL
8393: IFFALSE 8365
// end ; if b then
8395: LD_VAR 0 8
8399: IFFALSE 8410
// CenterNowOnUnits ( b ) ;
8401: LD_VAR 0 8
8405: PPUSH
8406: CALL_OW 87
// DialogueOn ;
8410: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8414: LD_EXP 30
8418: PPUSH
8419: LD_STRING D9d-Ar2-1
8421: PPUSH
8422: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8426: LD_EXP 29
8430: PPUSH
8431: LD_STRING D9d-Ar1-1
8433: PPUSH
8434: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8438: LD_EXP 21
8442: PPUSH
8443: LD_STRING D9d-JMM-1
8445: PPUSH
8446: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8450: LD_EXP 29
8454: PPUSH
8455: LD_STRING D9d-Ar1-2
8457: PPUSH
8458: CALL_OW 88
// DialogueOff ;
8462: CALL_OW 7
// i := [ ] ;
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: EMPTY
8472: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8473: LD_VAR 0 4
8477: PPUSH
8478: CALL_OW 274
8482: PPUSH
8483: LD_INT 3
8485: PPUSH
8486: CALL_OW 275
8490: PUSH
8491: LD_INT 20
8493: GREATEREQUAL
8494: IFFALSE 8513
// i := i ^ [ 1 ] ;
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_VAR 0 1
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: EMPTY
8510: LIST
8511: ADD
8512: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8513: LD_VAR 0 4
8517: PPUSH
8518: CALL_OW 274
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_INT 50
8533: GREATEREQUAL
8534: IFFALSE 8553
// i := i ^ [ 2 ] ;
8536: LD_ADDR_VAR 0 1
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: EMPTY
8550: LIST
8551: ADD
8552: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL_OW 274
8562: PPUSH
8563: LD_INT 2
8565: PPUSH
8566: CALL_OW 275
8570: PUSH
8571: LD_INT 80
8573: GREATEREQUAL
8574: IFFALSE 8593
// i := i ^ [ 3 ] ;
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: LD_VAR 0 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: ADD
8592: ST_TO_ADDR
// i := i diff 0 ;
8593: LD_ADDR_VAR 0 1
8597: PUSH
8598: LD_VAR 0 1
8602: PUSH
8603: LD_INT 0
8605: DIFF
8606: ST_TO_ADDR
// if i then
8607: LD_VAR 0 1
8611: IFFALSE 8717
// begin i := i ^ [ 4 ] ;
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 4
8625: PUSH
8626: EMPTY
8627: LIST
8628: ADD
8629: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8630: LD_STRING QInfo2
8632: PPUSH
8633: CALL_OW 97
8637: PUSH
8638: LD_INT 1
8640: DOUBLE
8641: EQUAL
8642: IFTRUE 8646
8644: GO 8657
8646: POP
// player_want_info := 3 ; 2 :
8647: LD_ADDR_EXP 13
8651: PUSH
8652: LD_INT 3
8654: ST_TO_ADDR
8655: GO 8715
8657: LD_INT 2
8659: DOUBLE
8660: EQUAL
8661: IFTRUE 8665
8663: GO 8676
8665: POP
// player_want_info := 1 ; 3 :
8666: LD_ADDR_EXP 13
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
8674: GO 8715
8676: LD_INT 3
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8695
8684: POP
// player_want_info := 2 ; 4 :
8685: LD_ADDR_EXP 13
8689: PUSH
8690: LD_INT 2
8692: ST_TO_ADDR
8693: GO 8715
8695: LD_INT 4
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8714
8703: POP
// player_want_info := 0 ; end ;
8704: LD_ADDR_EXP 13
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
8712: GO 8715
8714: POP
// end else
8715: GO 8745
// case Query ( QInfoNothing ) of 1 :
8717: LD_STRING QInfoNothing
8719: PPUSH
8720: CALL_OW 97
8724: PUSH
8725: LD_INT 1
8727: DOUBLE
8728: EQUAL
8729: IFTRUE 8733
8731: GO 8744
8733: POP
// player_want_info := 0 ; end ;
8734: LD_ADDR_EXP 13
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
8742: GO 8745
8744: POP
// end ; end ; end ; if player_want_info then
8745: LD_EXP 13
8749: IFFALSE 9903
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8751: LD_ADDR_VAR 0 3
8755: PUSH
8756: LD_VAR 0 3
8760: PPUSH
8761: LD_INT 34
8763: PUSH
8764: LD_INT 32
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 72
8775: ST_TO_ADDR
// if player_want_mortar then
8776: LD_EXP 12
8780: IFFALSE 9135
// begin case player_want_info of 1 :
8782: LD_EXP 13
8786: PUSH
8787: LD_INT 1
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8806
8795: POP
// x := 5 ; 2 :
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: LD_INT 5
8803: ST_TO_ADDR
8804: GO 8845
8806: LD_INT 2
8808: DOUBLE
8809: EQUAL
8810: IFTRUE 8814
8812: GO 8825
8814: POP
// x := 8 ; 3 :
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 8
8822: ST_TO_ADDR
8823: GO 8845
8825: LD_INT 3
8827: DOUBLE
8828: EQUAL
8829: IFTRUE 8833
8831: GO 8844
8833: POP
// x := 2 ; end ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_INT 2
8841: ST_TO_ADDR
8842: GO 8845
8844: POP
// repeat wait ( 0 0$1 ) ;
8845: LD_INT 35
8847: PPUSH
8848: CALL_OW 67
// until not HasTask ( Gali ) ;
8852: LD_EXP 30
8856: PPUSH
8857: CALL_OW 314
8861: NOT
8862: IFFALSE 8845
// time := 0 0$00 ;
8864: LD_ADDR_VAR 0 5
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// time := time + 0 0$1 ;
8879: LD_ADDR_VAR 0 5
8883: PUSH
8884: LD_VAR 0 5
8888: PUSH
8889: LD_INT 35
8891: PLUS
8892: ST_TO_ADDR
// if debug then
8893: LD_EXP 2
8897: IFFALSE 8916
// debug_strings := [ time: & time ] ;
8899: LD_ADDR_OWVAR 48
8903: PUSH
8904: LD_STRING time:
8906: PUSH
8907: LD_VAR 0 5
8911: STR
8912: PUSH
8913: EMPTY
8914: LIST
8915: ST_TO_ADDR
// if time > 8 8$00 then
8916: LD_VAR 0 5
8920: PUSH
8921: LD_INT 16800
8923: GREATER
8924: IFFALSE 8936
// begin blocked := true ;
8926: LD_ADDR_EXP 18
8930: PUSH
8931: LD_INT 1
8933: ST_TO_ADDR
// exit ;
8934: GO 10083
// end ; if not Carry ( Gali ) then
8936: LD_EXP 30
8940: PPUSH
8941: CALL_OW 281
8945: NOT
8946: IFFALSE 8969
// ComTransport ( Gali , dep , player_want_info ) else
8948: LD_EXP 30
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: LD_EXP 13
8962: PPUSH
8963: CALL_OW 151
8967: GO 9087
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8969: LD_EXP 30
8973: PPUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: CALL_OW 296
8987: PUSH
8988: LD_INT 4
8990: LESS
8991: PUSH
8992: LD_EXP 30
8996: PPUSH
8997: LD_EXP 13
9001: PPUSH
9002: CALL_OW 289
9006: AND
9007: IFFALSE 9069
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_EXP 13
9022: PPUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ARRAY
9031: PPUSH
9032: LD_EXP 13
9036: PPUSH
9037: CALL_OW 289
9041: PUSH
9042: LD_INT 10
9044: PLUS
9045: PPUSH
9046: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
9050: LD_EXP 30
9054: PPUSH
9055: LD_EXP 13
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 290
// end else
9067: GO 9087
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
9069: LD_EXP 30
9073: PPUSH
9074: LD_VAR 0 3
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: CALL_OW 112
// end ; if player_attacked_ar then
9087: LD_EXP 16
9091: IFFALSE 9095
// exit ;
9093: GO 10083
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: PPUSH
9104: LD_EXP 13
9108: PPUSH
9109: CALL_OW 289
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 10
9121: MUL
9122: GREATEREQUAL
9123: IFFALSE 8872
// no_oil_gain := false ;
9125: LD_ADDR_VAR 0 6
9129: PUSH
9130: LD_INT 0
9132: ST_TO_ADDR
// end else
9133: GO 9724
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
9135: LD_ADDR_VAR 0 3
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 21
9152: PUSH
9153: LD_INT 2
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9169: LD_EXP 30
9173: PPUSH
9174: LD_VAR 0 4
9178: PPUSH
9179: CALL_OW 250
9183: PUSH
9184: LD_INT 1
9186: PLUS
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: CALL_OW 251
9197: PUSH
9198: LD_INT 1
9200: PLUS
9201: PPUSH
9202: CALL_OW 111
// time := 0 0$00 ;
9206: LD_ADDR_VAR 0 5
9210: PUSH
9211: LD_INT 0
9213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// time := time + 0 0$1 ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: LD_VAR 0 5
9230: PUSH
9231: LD_INT 35
9233: PLUS
9234: ST_TO_ADDR
// if time > 1 1$45 then
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 3675
9242: GREATER
9243: IFFALSE 9247
// break ;
9245: GO 9267
// until GetDistUnits ( Gali , dep ) < 4 ;
9247: LD_EXP 30
9251: PPUSH
9252: LD_VAR 0 4
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 4
9264: LESS
9265: IFFALSE 9214
// for i = 1 to 6 do
9267: LD_ADDR_VAR 0 1
9271: PUSH
9272: DOUBLE
9273: LD_INT 1
9275: DEC
9276: ST_TO_ADDR
9277: LD_INT 6
9279: PUSH
9280: FOR_TO
9281: IFFALSE 9485
// begin if player_attacked_ar then
9283: LD_EXP 16
9287: IFFALSE 9293
// exit ;
9289: POP
9290: POP
9291: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9293: LD_VAR 0 4
9297: PPUSH
9298: CALL_OW 274
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 275
9310: PUSH
9311: LD_INT 10
9313: LESS
9314: PUSH
9315: LD_VAR 0 7
9319: NOT
9320: AND
9321: IFFALSE 9384
// begin first_warn := true ;
9323: LD_ADDR_VAR 0 7
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// DialogueOn ;
9331: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9335: LD_EXP 31
9339: PPUSH
9340: LD_STRING D9a-FAr1-1
9342: PPUSH
9343: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9347: LD_EXP 21
9351: PPUSH
9352: LD_STRING D9a-JMM-1
9354: PPUSH
9355: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9359: LD_EXP 29
9363: PPUSH
9364: LD_STRING D9a2-Ar1-1
9366: PPUSH
9367: CALL_OW 88
// DialogueOff ;
9371: CALL_OW 7
// wait ( time ) ;
9375: LD_VAR 0 5
9379: PPUSH
9380: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9384: LD_VAR 0 4
9388: PPUSH
9389: CALL_OW 274
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 275
9401: PUSH
9402: LD_INT 10
9404: LESS
9405: IFFALSE 9431
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9407: LD_EXP 29
9411: PPUSH
9412: LD_STRING D9a3-Ar1-1
9414: PPUSH
9415: CALL_OW 88
// no_oil_gain := true ;
9419: LD_ADDR_VAR 0 6
9423: PUSH
9424: LD_INT 1
9426: ST_TO_ADDR
// break ;
9427: GO 9485
// end else
9429: GO 9483
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9431: LD_EXP 30
9435: PPUSH
9436: LD_VAR 0 4
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9448: LD_EXP 30
9452: PPUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 3
9465: MOD
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: ARRAY
9471: PPUSH
9472: CALL_OW 210
// wait ( 0 0$10 ) ;
9476: LD_INT 350
9478: PPUSH
9479: CALL_OW 67
// end ; end ;
9483: GO 9280
9485: POP
9486: POP
// time := 0 0$00 ;
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 0
9494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9495: LD_INT 35
9497: PPUSH
9498: CALL_OW 67
// if not HasTask ( Gali ) then
9502: LD_EXP 30
9506: PPUSH
9507: CALL_OW 314
9511: NOT
9512: IFFALSE 9528
// time := time + 0 0$1 ;
9514: LD_ADDR_VAR 0 5
9518: PUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_INT 35
9526: PLUS
9527: ST_TO_ADDR
// if time > 1 1$25 then
9528: LD_VAR 0 5
9532: PUSH
9533: LD_INT 2975
9535: GREATER
9536: IFFALSE 9560
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING D9a3-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// no_oil_gain := true ;
9550: LD_ADDR_VAR 0 6
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// break ;
9558: GO 9724
// end ; if player_attacked_ar then
9560: LD_EXP 16
9564: IFFALSE 9568
// exit ;
9566: GO 10083
// for i in tmp do
9568: LD_ADDR_VAR 0 1
9572: PUSH
9573: LD_VAR 0 3
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9610
// if GetFuel ( i ) < 100 then
9581: LD_VAR 0 1
9585: PPUSH
9586: CALL_OW 261
9590: PUSH
9591: LD_INT 100
9593: LESS
9594: IFFALSE 9608
// begin x := i ;
9596: LD_ADDR_VAR 0 2
9600: PUSH
9601: LD_VAR 0 1
9605: ST_TO_ADDR
// break ;
9606: GO 9610
// end ;
9608: GO 9578
9610: POP
9611: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9612: LD_EXP 30
9616: PPUSH
9617: CALL_OW 314
9621: NOT
9622: PUSH
9623: LD_EXP 30
9627: PPUSH
9628: CALL_OW 281
9632: NOT
9633: AND
9634: IFFALSE 9667
// begin ComTransport ( Gali , dep , mat_oil ) ;
9636: LD_EXP 30
9640: PPUSH
9641: LD_VAR 0 4
9645: PPUSH
9646: LD_INT 2
9648: PPUSH
9649: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9653: LD_EXP 30
9657: PPUSH
9658: LD_VAR 0 2
9662: PPUSH
9663: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9667: LD_VAR 0 3
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: CALL_OW 261
9680: PUSH
9681: LD_INT 80
9683: GREATER
9684: PUSH
9685: LD_VAR 0 3
9689: PUSH
9690: LD_INT 2
9692: ARRAY
9693: PPUSH
9694: CALL_OW 261
9698: PUSH
9699: LD_INT 80
9701: GREATER
9702: AND
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_INT 3
9711: ARRAY
9712: PPUSH
9713: CALL_OW 261
9717: PUSH
9718: LD_INT 80
9720: GREATER
9721: AND
9722: IFFALSE 9495
// end ; ComHold ( Gali ) ;
9724: LD_EXP 30
9728: PPUSH
9729: CALL_OW 140
// if not no_oil_gain then
9733: LD_VAR 0 6
9737: NOT
9738: IFFALSE 9903
// begin DialogueOn ;
9740: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9744: LD_EXP 29
9748: PPUSH
9749: CALL_OW 87
// if player_want_mortar then
9753: LD_EXP 12
9757: IFFALSE 9783
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9759: LD_EXP 29
9763: PPUSH
9764: LD_STRING D9e-Ar1-1
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9771: LD_EXP 21
9775: PPUSH
9776: LD_STRING D10a-JMM-1
9778: PPUSH
9779: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9783: LD_EXP 29
9787: PPUSH
9788: LD_STRING D10a-Ar1-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9795: LD_EXP 30
9799: PPUSH
9800: LD_STRING D10a-Ar2-1
9802: PPUSH
9803: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9807: LD_EXP 31
9811: PPUSH
9812: LD_STRING D10a-FAr1-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9819: LD_EXP 30
9823: PPUSH
9824: LD_STRING D10a-Ar2-2
9826: PPUSH
9827: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9831: LD_EXP 31
9835: PPUSH
9836: LD_STRING D10a-FAr1-2
9838: PPUSH
9839: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9843: LD_EXP 29
9847: PPUSH
9848: LD_STRING D10a-Ar1-2
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9855: LD_EXP 21
9859: PPUSH
9860: LD_STRING D10a-JMM-2
9862: PPUSH
9863: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9867: LD_EXP 29
9871: PPUSH
9872: LD_STRING D10a-Ar1-3
9874: PPUSH
9875: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9879: LD_EXP 21
9883: PPUSH
9884: LD_STRING D10a-JMM-3
9886: PPUSH
9887: CALL_OW 88
// player_get_info := true ;
9891: LD_ADDR_EXP 15
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// DialogueOff ;
9899: CALL_OW 7
// end ; end ; if player_attacked_ar then
9903: LD_EXP 16
9907: IFFALSE 9911
// exit ;
9909: GO 10083
// if player_want_mortar or player_want_info then
9911: LD_EXP 12
9915: PUSH
9916: LD_EXP 13
9920: OR
9921: IFFALSE 9935
// Say ( Vervecken , D9f-Ar1-1 ) ;
9923: LD_EXP 29
9927: PPUSH
9928: LD_STRING D9f-Ar1-1
9930: PPUSH
9931: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9935: LD_INT 22
9937: PUSH
9938: LD_INT 2
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: PPUSH
9950: LD_INT 51
9952: PPUSH
9953: LD_INT 99
9955: PPUSH
9956: CALL_OW 111
// wait ( 0 0$1 ) ;
9960: LD_INT 35
9962: PPUSH
9963: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9967: LD_INT 22
9969: PUSH
9970: LD_INT 2
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 92
9979: PUSH
9980: LD_INT 51
9982: PUSH
9983: LD_INT 99
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IFFALSE 10063
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 2
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 92
10022: PUSH
10023: LD_INT 51
10025: PUSH
10026: LD_INT 99
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 69
10046: PUSH
10047: FOR_IN
10048: IFFALSE 10061
// RemoveUnit ( i ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: CALL_OW 64
10059: GO 10047
10061: POP
10062: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: PUSH
10078: LD_INT 0
10080: EQUAL
10081: IFFALSE 9935
// end ;
10083: PPOPN 10
10085: END
// every 0 0$01 trigger blocked do var i ;
10086: LD_EXP 18
10090: IFFALSE 10258
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
10098: LD_EXP 29
10102: PPUSH
10103: LD_STRING D9f-Ar1-1
10105: PPUSH
10106: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10110: LD_INT 22
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_INT 51
10127: PPUSH
10128: LD_INT 99
10130: PPUSH
10131: CALL_OW 111
// wait ( 0 0$1 ) ;
10135: LD_INT 35
10137: PPUSH
10138: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10142: LD_INT 22
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 92
10154: PUSH
10155: LD_INT 51
10157: PUSH
10158: LD_INT 99
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: IFFALSE 10238
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10180: LD_ADDR_VAR 0 1
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 92
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 99
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PPUSH
10217: CALL_OW 69
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// RemoveUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 64
10234: GO 10222
10236: POP
10237: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10238: LD_INT 22
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: IFFALSE 10110
// end ;
10258: PPOPN 1
10260: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10261: LD_EXP 16
10265: IFFALSE 10618
10267: GO 10269
10269: DISABLE
10270: LD_INT 0
10272: PPUSH
10273: PPUSH
10274: PPUSH
10275: PPUSH
// begin ru_can_attack := true ;
10276: LD_ADDR_EXP 8
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// mine_launched := false ;
10284: LD_ADDR_VAR 0 3
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PPUSH
10307: LD_INT 51
10309: PPUSH
10310: LD_INT 99
10312: PPUSH
10313: CALL_OW 111
// if IsOk ( Vervecken ) then
10317: LD_EXP 29
10321: PPUSH
10322: CALL_OW 302
10326: IFFALSE 10340
// Say ( Vervecken , D11a-Ar1-1 ) ;
10328: LD_EXP 29
10332: PPUSH
10333: LD_STRING D11a-Ar1-1
10335: PPUSH
10336: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10340: LD_ADDR_VAR 0 2
10344: PUSH
10345: LD_EXP 36
10349: PPUSH
10350: LD_INT 25
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 72
10364: ST_TO_ADDR
// for i in tmp do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10439
// if MineOfUnit ( i ) then
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 459
10387: IFFALSE 10437
// begin x := MineOfUnit ( i ) ;
10389: LD_ADDR_VAR 0 4
10393: PUSH
10394: LD_VAR 0 1
10398: PPUSH
10399: CALL_OW 459
10403: ST_TO_ADDR
// mine_launched := true ;
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10412: LD_VAR 0 4
10416: PUSH
10417: LD_INT 1
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_INT 2
10428: ARRAY
10429: PPUSH
10430: LD_INT 2
10432: PPUSH
10433: CALL_OW 456
// end ;
10437: GO 10375
10439: POP
10440: POP
// if mine_launched and IsOk ( Vervecken ) then
10441: LD_VAR 0 3
10445: PUSH
10446: LD_EXP 29
10450: PPUSH
10451: CALL_OW 302
10455: AND
10456: IFFALSE 10470
// Say ( Vervecken , D11b-Ar1-1 ) ;
10458: LD_EXP 29
10462: PPUSH
10463: LD_STRING D11b-Ar1-1
10465: PPUSH
10466: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10470: LD_INT 22
10472: PUSH
10473: LD_INT 2
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: PPUSH
10485: LD_INT 51
10487: PPUSH
10488: LD_INT 99
10490: PPUSH
10491: CALL_OW 111
// wait ( 0 0$1 ) ;
10495: LD_INT 35
10497: PPUSH
10498: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10502: LD_INT 22
10504: PUSH
10505: LD_INT 2
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 92
10514: PUSH
10515: LD_INT 51
10517: PUSH
10518: LD_INT 99
10520: PUSH
10521: LD_INT 2
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IFFALSE 10598
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 22
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 92
10557: PUSH
10558: LD_INT 51
10560: PUSH
10561: LD_INT 99
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: PUSH
10582: FOR_IN
10583: IFFALSE 10596
// RemoveUnit ( i ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: CALL_OW 64
10594: GO 10582
10596: POP
10597: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PUSH
10613: LD_INT 0
10615: EQUAL
10616: IFFALSE 10470
// end ;
10618: PPOPN 4
10620: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10621: LD_EXP 10
10625: IFFALSE 10804
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
// begin Wait ( 10 10$00 ) ;
10633: LD_INT 21000
10635: PPUSH
10636: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10640: LD_INT 22
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: IFFALSE 10804
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: PPUSH
10671: LD_INT 51
10673: PPUSH
10674: LD_INT 99
10676: PPUSH
10677: CALL_OW 114
// wait ( 0 0$1 ) ;
10681: LD_INT 35
10683: PPUSH
10684: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10688: LD_INT 22
10690: PUSH
10691: LD_INT 2
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 92
10700: PUSH
10701: LD_INT 51
10703: PUSH
10704: LD_INT 99
10706: PUSH
10707: LD_INT 2
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: IFFALSE 10784
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 92
10743: PUSH
10744: LD_INT 51
10746: PUSH
10747: LD_INT 99
10749: PUSH
10750: LD_INT 2
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10782
// RemoveUnit ( i ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 64
10780: GO 10768
10782: POP
10783: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10784: LD_INT 22
10786: PUSH
10787: LD_INT 2
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: PUSH
10799: LD_INT 0
10801: EQUAL
10802: IFFALSE 10656
// end ; end ;
10804: PPOPN 1
10806: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10807: LD_EXP 4
10811: IFFALSE 11837
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
10819: PPUSH
10820: PPUSH
10821: PPUSH
10822: PPUSH
10823: PPUSH
// begin Wait ( game_time ) ;
10824: LD_EXP 7
10828: PPUSH
10829: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10833: LD_INT 35
10835: PPUSH
10836: CALL_OW 67
// until ( not ru_can_attack ) ;
10840: LD_EXP 8
10844: NOT
10845: IFFALSE 10833
// Wait ( 0 0$35 ) ;
10847: LD_INT 1225
10849: PPUSH
10850: CALL_OW 67
// DialogueOn ;
10854: CALL_OW 6
// InGameOn ;
10858: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10862: LD_EXP 28
10866: PPUSH
10867: LD_STRING D12-Pow-1
10869: PPUSH
10870: CALL_OW 94
// InGameOff ;
10874: CALL_OW 9
// DialogueOff ;
10878: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10882: LD_STRING M4
10884: PPUSH
10885: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10889: LD_INT 5
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 424
// can_end := true ;
10899: LD_ADDR_EXP 17
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10907: LD_INT 35
10909: PPUSH
10910: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10914: CALL 943 0 0
10918: PUSH
10919: LD_INT 20
10921: GREATEREQUAL
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_INT 1
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 21
10935: PUSH
10936: LD_INT 1
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PPUSH
10947: CALL_OW 69
10951: PUSH
10952: LD_INT 5
10954: PPUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 70
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 1
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 55
10996: PUSH
10997: EMPTY
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PLUS
11009: LESSEQUAL
11010: AND
11011: IFFALSE 10907
// if not player_get_info then
11013: LD_EXP 15
11017: NOT
11018: IFFALSE 11029
// player_get_info := - 1 ;
11020: LD_ADDR_EXP 15
11024: PUSH
11025: LD_INT 1
11027: NEG
11028: ST_TO_ADDR
// m1 := player_get_info > 0 ;
11029: LD_ADDR_VAR 0 4
11033: PUSH
11034: LD_EXP 15
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: ST_TO_ADDR
// m2 := false ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// m3 := earlySib ;
11051: LD_ADDR_VAR 0 6
11055: PUSH
11056: LD_EXP 19
11060: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
11061: LD_STRING Information
11063: PPUSH
11064: LD_EXP 15
11068: PPUSH
11069: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
11073: LD_ADDR_VAR 0 2
11077: PUSH
11078: LD_INT 22
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 2
11090: PUSH
11091: LD_INT 25
11093: PUSH
11094: LD_INT 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 25
11103: PUSH
11104: LD_INT 16
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 34
11113: PUSH
11114: LD_INT 12
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PPUSH
11131: CALL_OW 69
11135: ST_TO_ADDR
// sib := GetTerminalCargo ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: CALL 943 0 0
11145: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
11146: LD_ADDR_VAR 0 3
11150: PUSH
11151: LD_VAR 0 3
11155: PUSH
11156: LD_INT 6
11158: PPUSH
11159: LD_INT 3
11161: PPUSH
11162: CALL_OW 287
11166: PLUS
11167: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11168: LD_ADDR_VAR 0 3
11172: PUSH
11173: LD_VAR 0 3
11177: PUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: LD_INT 3
11185: PPUSH
11186: CALL_OW 289
11190: PLUS
11191: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11192: LD_VAR 0 3
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_OWVAR 67
11204: PLUS
11205: PUSH
11206: LD_INT 50
11208: MUL
11209: LESS
11210: IFFALSE 11235
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11212: LD_STRING MuchSiberite
11214: PPUSH
11215: LD_INT 2
11217: NEG
11218: PUSH
11219: LD_OWVAR 67
11223: MUL
11224: PUSH
11225: LD_INT 1
11227: PLUS
11228: PPUSH
11229: CALL_OW 101
11233: GO 11253
// begin AddMedal ( MuchSiberite , 1 ) ;
11235: LD_STRING MuchSiberite
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 101
// m2 := true ;
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 1
11252: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11253: LD_VAR 0 4
11257: PUSH
11258: LD_VAR 0 5
11262: AND
11263: PUSH
11264: LD_VAR 0 6
11268: AND
11269: PUSH
11270: LD_OWVAR 67
11274: PUSH
11275: LD_INT 3
11277: EQUAL
11278: AND
11279: IFFALSE 11291
// SetAchievementEX ( ACH_AMER , 9 ) ;
11281: LD_STRING ACH_AMER
11283: PPUSH
11284: LD_INT 9
11286: PPUSH
11287: CALL_OW 564
// if tick <= 55 55$00 then
11291: LD_OWVAR 1
11295: PUSH
11296: LD_INT 115500
11298: LESSEQUAL
11299: IFFALSE 11308
// SetAchievement ( ACH_ASPEED_9 ) ;
11301: LD_STRING ACH_ASPEED_9
11303: PPUSH
11304: CALL_OW 543
// GiveMedals ( MAIN ) ;
11308: LD_STRING MAIN
11310: PPUSH
11311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PUSH
11325: LD_INT 2
11327: PUSH
11328: LD_INT 25
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 25
11340: PUSH
11341: LD_INT 2
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 25
11350: PUSH
11351: LD_INT 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: LD_INT 25
11360: PUSH
11361: LD_INT 4
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 25
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PPUSH
11395: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11399: LD_ADDR_VAR 0 2
11403: PUSH
11404: LD_INT 22
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 25
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 69
11432: ST_TO_ADDR
// if tmp then
11433: LD_VAR 0 2
11437: IFFALSE 11468
// for i in tmp do
11439: LD_ADDR_VAR 0 1
11443: PUSH
11444: LD_VAR 0 2
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11466
// SetClass ( i , 1 ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 336
11464: GO 11449
11466: POP
11467: POP
// SaveVariable ( sib , 09_sibRes ) ;
11468: LD_VAR 0 3
11472: PPUSH
11473: LD_STRING 09_sibRes
11475: PPUSH
11476: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11480: LD_EXP 15
11484: PPUSH
11485: LD_STRING 09_arInfo
11487: PPUSH
11488: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11492: LD_EXP 21
11496: PPUSH
11497: LD_EXP 1
11501: PUSH
11502: LD_STRING JMM
11504: STR
11505: PPUSH
11506: CALL_OW 38
// if IsLive ( Gary ) then
11510: LD_EXP 22
11514: PPUSH
11515: CALL_OW 300
11519: IFFALSE 11539
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11521: LD_EXP 22
11525: PPUSH
11526: LD_EXP 1
11530: PUSH
11531: LD_STRING Gary
11533: STR
11534: PPUSH
11535: CALL_OW 38
// if IsLive ( Bobby ) then
11539: LD_EXP 23
11543: PPUSH
11544: CALL_OW 300
11548: IFFALSE 11568
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11550: LD_EXP 23
11554: PPUSH
11555: LD_EXP 1
11559: PUSH
11560: LD_STRING Bobby
11562: STR
11563: PPUSH
11564: CALL_OW 38
// if IsLive ( Cyrus ) then
11568: LD_EXP 24
11572: PPUSH
11573: CALL_OW 300
11577: IFFALSE 11597
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11579: LD_EXP 24
11583: PPUSH
11584: LD_EXP 1
11588: PUSH
11589: LD_STRING Cyrus
11591: STR
11592: PPUSH
11593: CALL_OW 38
// if IsLive ( Houten ) then
11597: LD_EXP 25
11601: PPUSH
11602: CALL_OW 300
11606: IFFALSE 11626
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11608: LD_EXP 25
11612: PPUSH
11613: LD_EXP 1
11617: PUSH
11618: LD_STRING Houten
11620: STR
11621: PPUSH
11622: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 25
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 4
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 21
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 23
11714: PUSH
11715: LD_EXP 25
11719: PUSH
11720: LD_EXP 22
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: DIFF
11732: ST_TO_ADDR
// if tmp then
11733: LD_VAR 0 2
11737: IFFALSE 11757
// SaveCharacters ( tmp , mission_prefix & others ) ;
11739: LD_VAR 0 2
11743: PPUSH
11744: LD_EXP 1
11748: PUSH
11749: LD_STRING others
11751: STR
11752: PPUSH
11753: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11757: LD_ADDR_VAR 0 2
11761: PUSH
11762: LD_INT 22
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 12
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: LD_INT 25
11787: PUSH
11788: LD_INT 16
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PPUSH
11804: CALL_OW 69
11808: ST_TO_ADDR
// if tmp then
11809: LD_VAR 0 2
11813: IFFALSE 11833
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11815: LD_VAR 0 2
11819: PPUSH
11820: LD_EXP 1
11824: PUSH
11825: LD_STRING apes
11827: STR
11828: PPUSH
11829: CALL_OW 38
// YouWin ;
11833: CALL_OW 103
// end ; end_of_file
11837: PPOPN 6
11839: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11840: LD_VAR 0 1
11844: PPUSH
11845: CALL_OW 266
11849: PUSH
11850: LD_INT 0
11852: EQUAL
11853: PUSH
11854: LD_EXP 3
11858: NOT
11859: AND
11860: IFFALSE 11884
// begin terminal := b ;
11862: LD_ADDR_EXP 3
11866: PUSH
11867: LD_VAR 0 1
11871: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11872: LD_EXP 3
11876: PPUSH
11877: LD_STRING terminal
11879: PPUSH
11880: CALL_OW 500
// end ; end ;
11884: PPOPN 2
11886: END
// on BuildingComplete ( b ) do var i ;
11887: LD_INT 0
11889: PPUSH
// begin if GetSide ( b ) = 3 then
11890: LD_VAR 0 1
11894: PPUSH
11895: CALL_OW 255
11899: PUSH
11900: LD_INT 3
11902: EQUAL
11903: IFFALSE 11943
// for i = 1 to 4 do
11905: LD_ADDR_VAR 0 2
11909: PUSH
11910: DOUBLE
11911: LD_INT 1
11913: DEC
11914: ST_TO_ADDR
11915: LD_INT 4
11917: PUSH
11918: FOR_TO
11919: IFFALSE 11941
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11921: LD_ADDR_EXP 39
11925: PUSH
11926: LD_EXP 39
11930: PPUSH
11931: LD_INT 1
11933: PPUSH
11934: CALL_OW 3
11938: ST_TO_ADDR
11939: GO 11918
11941: POP
11942: POP
// end ;
11943: PPOPN 2
11945: END
// on VehicleConstructed ( veh , fac ) do var i ;
11946: LD_INT 0
11948: PPUSH
// begin if GetSide ( veh ) = 3 then
11949: LD_VAR 0 1
11953: PPUSH
11954: CALL_OW 255
11958: PUSH
11959: LD_INT 3
11961: EQUAL
11962: IFFALSE 12087
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11964: LD_VAR 0 1
11968: PPUSH
11969: CALL_OW 264
11973: PUSH
11974: LD_INT 53
11976: PUSH
11977: LD_INT 52
11979: PUSH
11980: LD_INT 51
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: LIST
11987: IN
11988: NOT
11989: IFFALSE 12007
// ru_force := ru_force ^ veh ;
11991: LD_ADDR_EXP 38
11995: PUSH
11996: LD_EXP 38
12000: PUSH
12001: LD_VAR 0 1
12005: ADD
12006: ST_TO_ADDR
// for i = 1 to 4 do
12007: LD_ADDR_VAR 0 3
12011: PUSH
12012: DOUBLE
12013: LD_INT 1
12015: DEC
12016: ST_TO_ADDR
12017: LD_INT 4
12019: PUSH
12020: FOR_TO
12021: IFFALSE 12043
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
12023: LD_ADDR_EXP 40
12027: PUSH
12028: LD_EXP 40
12032: PPUSH
12033: LD_INT 1
12035: PPUSH
12036: CALL_OW 3
12040: ST_TO_ADDR
12041: GO 12020
12043: POP
12044: POP
// if GetWeapon ( veh ) = ru_bulldozer then
12045: LD_VAR 0 1
12049: PPUSH
12050: CALL_OW 264
12054: PUSH
12055: LD_INT 53
12057: EQUAL
12058: IFFALSE 12087
// begin CutTreeInArea ( veh , cutTreeArea ) ;
12060: LD_VAR 0 1
12064: PPUSH
12065: LD_INT 7
12067: PPUSH
12068: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
12072: LD_VAR 0 1
12076: PPUSH
12077: LD_INT 170
12079: PPUSH
12080: LD_INT 235
12082: PPUSH
12083: CALL_OW 171
// end ; end ; end ;
12087: PPOPN 3
12089: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
12090: LD_VAR 0 1
12094: PUSH
12095: LD_INT 1
12097: EQUAL
12098: PUSH
12099: LD_VAR 0 2
12103: PUSH
12104: LD_INT 2
12106: EQUAL
12107: AND
12108: PUSH
12109: LD_VAR 0 1
12113: PUSH
12114: LD_INT 2
12116: EQUAL
12117: PUSH
12118: LD_VAR 0 2
12122: PUSH
12123: LD_INT 1
12125: EQUAL
12126: AND
12127: OR
12128: IFFALSE 12138
// player_attacked_ar := true ;
12130: LD_ADDR_EXP 16
12134: PUSH
12135: LD_INT 1
12137: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 1
12145: EQUAL
12146: PUSH
12147: LD_VAR 0 2
12151: PUSH
12152: LD_INT 4
12154: EQUAL
12155: AND
12156: PUSH
12157: LD_VAR 0 1
12161: PUSH
12162: LD_INT 4
12164: EQUAL
12165: PUSH
12166: LD_VAR 0 2
12170: PUSH
12171: LD_INT 1
12173: EQUAL
12174: AND
12175: OR
12176: IFFALSE 12185
// YouLost ( Traitor ) ;
12178: LD_STRING Traitor
12180: PPUSH
12181: CALL_OW 104
// end ;
12185: PPOPN 2
12187: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12188: LD_VAR 0 1
12192: PUSH
12193: LD_EXP 21
12197: EQUAL
12198: IFFALSE 12207
// YouLost ( JMM ) ;
12200: LD_STRING JMM
12202: PPUSH
12203: CALL_OW 104
// if un = terminal then
12207: LD_VAR 0 1
12211: PUSH
12212: LD_EXP 3
12216: EQUAL
12217: IFFALSE 12226
// YouLost ( Terminal ) ;
12219: LD_STRING Terminal
12221: PPUSH
12222: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12226: LD_VAR 0 1
12230: PPUSH
12231: CALL_OW 264
12235: PUSH
12236: LD_INT 53
12238: EQUAL
12239: IFFALSE 12255
// bulldozerCounter := bulldozerCounter + 1 ;
12241: LD_ADDR_EXP 20
12245: PUSH
12246: LD_EXP 20
12250: PUSH
12251: LD_INT 1
12253: PLUS
12254: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12255: LD_VAR 0 1
12259: PUSH
12260: LD_INT 22
12262: PUSH
12263: LD_INT 3
12265: PUSH
12266: EMPTY
12267: LIST
12268: LIST
12269: PUSH
12270: LD_INT 21
12272: PUSH
12273: LD_INT 3
12275: PUSH
12276: EMPTY
12277: LIST
12278: LIST
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: IN
12289: IFFALSE 12435
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12291: LD_VAR 0 1
12295: PPUSH
12296: CALL_OW 266
12300: PUSH
12301: LD_INT 33
12303: PUSH
12304: LD_INT 26
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: IN
12311: IFFALSE 12370
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12313: LD_ADDR_EXP 39
12317: PUSH
12318: LD_EXP 39
12322: PUSH
12323: LD_VAR 0 1
12327: PPUSH
12328: CALL_OW 266
12332: PUSH
12333: LD_VAR 0 1
12337: PPUSH
12338: CALL_OW 250
12342: PUSH
12343: LD_VAR 0 1
12347: PPUSH
12348: CALL_OW 251
12352: PUSH
12353: LD_VAR 0 1
12357: PPUSH
12358: CALL_OW 254
12362: PUSH
12363: EMPTY
12364: LIST
12365: LIST
12366: LIST
12367: LIST
12368: ADD
12369: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12370: LD_VAR 0 1
12374: PPUSH
12375: CALL_OW 266
12379: PUSH
12380: LD_INT 5
12382: EQUAL
12383: IFFALSE 12435
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12385: LD_ADDR_EXP 39
12389: PUSH
12390: LD_EXP 39
12394: PUSH
12395: LD_INT 4
12397: PUSH
12398: LD_VAR 0 1
12402: PPUSH
12403: CALL_OW 250
12407: PUSH
12408: LD_VAR 0 1
12412: PPUSH
12413: CALL_OW 251
12417: PUSH
12418: LD_VAR 0 1
12422: PPUSH
12423: CALL_OW 254
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: ADD
12434: ST_TO_ADDR
// end ; if un in ru_force then
12435: LD_VAR 0 1
12439: PUSH
12440: LD_EXP 38
12444: IN
12445: IFFALSE 12481
// begin ru_force := ru_force diff un ;
12447: LD_ADDR_EXP 38
12451: PUSH
12452: LD_EXP 38
12456: PUSH
12457: LD_VAR 0 1
12461: DIFF
12462: ST_TO_ADDR
// if ru_force = 0 then
12463: LD_EXP 38
12467: PUSH
12468: LD_INT 0
12470: EQUAL
12471: IFFALSE 12481
// ru_can_attack := false ;
12473: LD_ADDR_EXP 8
12477: PUSH
12478: LD_INT 0
12480: ST_TO_ADDR
// end ; end ;
12481: PPOPN 1
12483: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12484: LD_VAR 0 1
12488: PPUSH
12489: CALL 17811 0 1
// end ; end_of_file
12493: PPOPN 1
12495: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12496: LD_EXP 5
12500: PUSH
12501: LD_EXP 6
12505: AND
12506: IFFALSE 12591
12508: GO 12510
12510: DISABLE
12511: LD_INT 0
12513: PPUSH
// begin enable ;
12514: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12515: LD_ADDR_VAR 0 1
12519: PUSH
12520: LD_INT 60
12522: PUSH
12523: CALL 943 0 0
12527: MINUS
12528: ST_TO_ADDR
// if sib < 0 then
12529: LD_VAR 0 1
12533: PUSH
12534: LD_INT 0
12536: LESS
12537: IFFALSE 12547
// sib := 0 ;
12539: LD_ADDR_VAR 0 1
12543: PUSH
12544: LD_INT 0
12546: ST_TO_ADDR
// if not debug then
12547: LD_EXP 2
12551: NOT
12552: IFFALSE 12577
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12554: LD_ADDR_OWVAR 47
12558: PUSH
12559: LD_STRING #Am09-1
12561: PUSH
12562: LD_VAR 0 1
12566: PUSH
12567: LD_EXP 6
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: LIST
12576: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12577: LD_ADDR_EXP 6
12581: PUSH
12582: LD_EXP 6
12586: PUSH
12587: LD_INT 35
12589: MINUS
12590: ST_TO_ADDR
// end ;
12591: PPOPN 1
12593: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12594: LD_EXP 6
12598: PUSH
12599: LD_INT 0
12601: EQUAL
12602: IFFALSE 12614
12604: GO 12606
12606: DISABLE
// display_strings := [ ] ;
12607: LD_ADDR_OWVAR 47
12611: PUSH
12612: EMPTY
12613: ST_TO_ADDR
12614: END
// every 1 1$35 do var i , tmp ;
12615: GO 12617
12617: DISABLE
12618: LD_INT 0
12620: PPUSH
12621: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12622: LD_ADDR_VAR 0 2
12626: PUSH
12627: LD_INT 1155
12629: PUSH
12630: LD_INT 1225
12632: PUSH
12633: LD_INT 1435
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: LIST
12640: PUSH
12641: LD_OWVAR 67
12645: ARRAY
12646: ST_TO_ADDR
// i := 0 ;
12647: LD_ADDR_VAR 0 1
12651: PUSH
12652: LD_INT 0
12654: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12655: LD_INT 1
12657: PPUSH
12658: LD_INT 5
12660: PPUSH
12661: CALL_OW 12
12665: PPUSH
12666: LD_INT 75
12668: PPUSH
12669: LD_INT 75
12671: PPUSH
12672: LD_INT 20
12674: PPUSH
12675: LD_INT 1
12677: PPUSH
12678: CALL_OW 56
// wait ( tmp ) ;
12682: LD_VAR 0 2
12686: PPUSH
12687: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12691: LD_ADDR_VAR 0 2
12695: PUSH
12696: LD_VAR 0 2
12700: PUSH
12701: LD_INT 105
12703: PPUSH
12704: LD_INT 315
12706: PPUSH
12707: CALL_OW 12
12711: PLUS
12712: ST_TO_ADDR
// i := i + 1 ;
12713: LD_ADDR_VAR 0 1
12717: PUSH
12718: LD_VAR 0 1
12722: PUSH
12723: LD_INT 1
12725: PLUS
12726: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12727: LD_VAR 0 1
12731: PUSH
12732: LD_INT 3
12734: MOD
12735: PUSH
12736: LD_INT 0
12738: EQUAL
12739: PUSH
12740: LD_EXP 4
12744: AND
12745: IFFALSE 12783
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12747: LD_INT 2
12749: PPUSH
12750: LD_INT 5
12752: PPUSH
12753: CALL_OW 12
12757: PPUSH
12758: LD_INT 8
12760: PPUSH
12761: LD_INT 1
12763: PPUSH
12764: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12768: LD_INT 665
12770: PPUSH
12771: LD_INT 735
12773: PPUSH
12774: CALL_OW 12
12778: PPUSH
12779: CALL_OW 67
// end ; until tick > game_time ;
12783: LD_OWVAR 1
12787: PUSH
12788: LD_EXP 7
12792: GREATER
12793: IFFALSE 12655
// end ; end_of_file
12795: PPOPN 2
12797: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12798: LD_INT 0
12800: PPUSH
12801: PPUSH
12802: PPUSH
12803: PPUSH
12804: PPUSH
12805: PPUSH
// x := 76 ;
12806: LD_ADDR_VAR 0 5
12810: PUSH
12811: LD_INT 76
12813: ST_TO_ADDR
// y := 147 ;
12814: LD_ADDR_VAR 0 6
12818: PUSH
12819: LD_INT 147
12821: ST_TO_ADDR
// uc_side := 2 ;
12822: LD_ADDR_OWVAR 20
12826: PUSH
12827: LD_INT 2
12829: ST_TO_ADDR
// uc_nation := 2 ;
12830: LD_ADDR_OWVAR 21
12834: PUSH
12835: LD_INT 2
12837: ST_TO_ADDR
// InitHc ;
12838: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12842: LD_INT 1
12844: PPUSH
12845: LD_INT 1
12847: PPUSH
12848: LD_INT 6
12850: PPUSH
12851: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12855: LD_ADDR_OWVAR 26
12859: PUSH
12860: LD_STRING Nicolas Vervecken
12862: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12863: LD_ADDR_OWVAR 33
12867: PUSH
12868: LD_STRING SecondCharsGal
12870: ST_TO_ADDR
// hc_face_number := 3 ;
12871: LD_ADDR_OWVAR 34
12875: PUSH
12876: LD_INT 3
12878: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12879: LD_ADDR_OWVAR 29
12883: PUSH
12884: LD_INT 11
12886: PUSH
12887: LD_INT 10
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: ST_TO_ADDR
// Vervecken := CreateHuman ;
12894: LD_ADDR_EXP 29
12898: PUSH
12899: CALL_OW 44
12903: ST_TO_ADDR
// ar_force := Vervecken ;
12904: LD_ADDR_EXP 36
12908: PUSH
12909: LD_EXP 29
12913: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12914: LD_INT 1
12916: PPUSH
12917: LD_INT 2
12919: PPUSH
12920: LD_INT 6
12922: PPUSH
12923: CALL_OW 380
// hc_name := Louis Gali ;
12927: LD_ADDR_OWVAR 26
12931: PUSH
12932: LD_STRING Louis Gali
12934: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12935: LD_ADDR_OWVAR 33
12939: PUSH
12940: LD_STRING SecondCharsGal
12942: ST_TO_ADDR
// hc_face_number := 2 ;
12943: LD_ADDR_OWVAR 34
12947: PUSH
12948: LD_INT 2
12950: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12951: LD_ADDR_OWVAR 29
12955: PUSH
12956: LD_INT 10
12958: PUSH
12959: LD_INT 11
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: ST_TO_ADDR
// Gali := CreateHuman ;
12966: LD_ADDR_EXP 30
12970: PUSH
12971: CALL_OW 44
12975: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12976: LD_ADDR_EXP 36
12980: PUSH
12981: LD_EXP 36
12985: PUSH
12986: LD_EXP 30
12990: ADD
12991: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12992: LD_INT 2
12994: PPUSH
12995: LD_INT 1
12997: PPUSH
12998: LD_INT 6
13000: PPUSH
13001: CALL_OW 380
// hc_name := Maria Bogdanovic ;
13005: LD_ADDR_OWVAR 26
13009: PUSH
13010: LD_STRING Maria Bogdanovic
13012: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13013: LD_ADDR_OWVAR 33
13017: PUSH
13018: LD_STRING SecondCharsGal
13020: ST_TO_ADDR
// hc_face_number := 14 ;
13021: LD_ADDR_OWVAR 34
13025: PUSH
13026: LD_INT 14
13028: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
13029: LD_ADDR_OWVAR 29
13033: PUSH
13034: LD_INT 12
13036: PUSH
13037: LD_INT 9
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
13044: LD_ADDR_EXP 31
13048: PUSH
13049: CALL_OW 44
13053: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
13054: LD_ADDR_EXP 36
13058: PUSH
13059: LD_EXP 36
13063: PUSH
13064: LD_EXP 31
13068: ADD
13069: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13070: LD_INT 1
13072: PPUSH
13073: LD_INT 3
13075: PPUSH
13076: LD_INT 6
13078: PPUSH
13079: CALL_OW 380
// hc_name = Kntor Radomr ;
13083: LD_ADDR_OWVAR 26
13087: PUSH
13088: LD_STRING Kntor Radomr
13090: ST_TO_ADDR
// hc_gallery = sandar ;
13091: LD_ADDR_OWVAR 33
13095: PUSH
13096: LD_STRING sandar
13098: ST_TO_ADDR
// hc_face_number = 12 ;
13099: LD_ADDR_OWVAR 34
13103: PUSH
13104: LD_INT 12
13106: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
13107: LD_ADDR_OWVAR 29
13111: PUSH
13112: LD_INT 9
13114: PUSH
13115: LD_INT 9
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: ST_TO_ADDR
// Kantor = CreateHuman ;
13122: LD_ADDR_EXP 32
13126: PUSH
13127: CALL_OW 44
13131: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
13132: LD_ADDR_EXP 36
13136: PUSH
13137: LD_EXP 36
13141: PUSH
13142: LD_EXP 32
13146: ADD
13147: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13148: LD_INT 1
13150: PPUSH
13151: LD_INT 3
13153: PPUSH
13154: LD_INT 6
13156: PPUSH
13157: CALL_OW 380
// hc_name = Herczeg Farkas ;
13161: LD_ADDR_OWVAR 26
13165: PUSH
13166: LD_STRING Herczeg Farkas
13168: ST_TO_ADDR
// hc_gallery = sandar ;
13169: LD_ADDR_OWVAR 33
13173: PUSH
13174: LD_STRING sandar
13176: ST_TO_ADDR
// hc_face_number = 28 ;
13177: LD_ADDR_OWVAR 34
13181: PUSH
13182: LD_INT 28
13184: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13185: LD_ADDR_OWVAR 29
13189: PUSH
13190: LD_INT 10
13192: PUSH
13193: LD_INT 9
13195: PUSH
13196: EMPTY
13197: LIST
13198: LIST
13199: ST_TO_ADDR
// Herczeg = CreateHuman ;
13200: LD_ADDR_EXP 33
13204: PUSH
13205: CALL_OW 44
13209: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13210: LD_ADDR_EXP 36
13214: PUSH
13215: LD_EXP 36
13219: PUSH
13220: LD_EXP 33
13224: ADD
13225: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: LD_INT 6
13234: PPUSH
13235: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13239: LD_ADDR_OWVAR 26
13243: PUSH
13244: LD_STRING Ronn Horntvedt
13246: ST_TO_ADDR
// hc_gallery = sandar ;
13247: LD_ADDR_OWVAR 33
13251: PUSH
13252: LD_STRING sandar
13254: ST_TO_ADDR
// hc_face_number = 29 ;
13255: LD_ADDR_OWVAR 34
13259: PUSH
13260: LD_INT 29
13262: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13263: LD_ADDR_OWVAR 29
13267: PUSH
13268: LD_INT 11
13270: PUSH
13271: LD_INT 11
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: ST_TO_ADDR
// Ronn = CreateHuman ;
13278: LD_ADDR_EXP 34
13282: PUSH
13283: CALL_OW 44
13287: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13288: LD_ADDR_EXP 36
13292: PUSH
13293: LD_EXP 36
13297: PUSH
13298: LD_EXP 34
13302: ADD
13303: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13304: LD_INT 2
13306: PPUSH
13307: LD_INT 3
13309: PPUSH
13310: LD_INT 6
13312: PPUSH
13313: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13317: LD_ADDR_OWVAR 26
13321: PUSH
13322: LD_STRING Mia D. Mathiasen
13324: ST_TO_ADDR
// hc_gallery = sandar ;
13325: LD_ADDR_OWVAR 33
13329: PUSH
13330: LD_STRING sandar
13332: ST_TO_ADDR
// hc_face_number = 31 ;
13333: LD_ADDR_OWVAR 34
13337: PUSH
13338: LD_INT 31
13340: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13341: LD_ADDR_OWVAR 29
13345: PUSH
13346: LD_INT 10
13348: PUSH
13349: LD_INT 10
13351: PUSH
13352: EMPTY
13353: LIST
13354: LIST
13355: ST_TO_ADDR
// Mia = CreateHuman ;
13356: LD_ADDR_EXP 35
13360: PUSH
13361: CALL_OW 44
13365: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13366: LD_ADDR_EXP 36
13370: PUSH
13371: LD_EXP 36
13375: PUSH
13376: LD_EXP 35
13380: ADD
13381: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13382: LD_ADDR_VAR 0 3
13386: PUSH
13387: LD_VAR 0 3
13391: PUSH
13392: LD_INT 2
13394: PPUSH
13395: LD_INT 2
13397: PPUSH
13398: LD_INT 14
13400: PPUSH
13401: LD_INT 1
13403: PPUSH
13404: LD_INT 1
13406: PPUSH
13407: LD_INT 32
13409: PPUSH
13410: LD_INT 30
13412: PPUSH
13413: CALL 423 0 7
13417: ADD
13418: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13419: LD_ADDR_VAR 0 3
13423: PUSH
13424: LD_VAR 0 3
13428: PUSH
13429: LD_INT 2
13431: PPUSH
13432: LD_INT 2
13434: PPUSH
13435: LD_INT 14
13437: PPUSH
13438: LD_INT 1
13440: PPUSH
13441: LD_INT 1
13443: PPUSH
13444: LD_INT 27
13446: PPUSH
13447: LD_INT 30
13449: PPUSH
13450: CALL 423 0 7
13454: ADD
13455: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13456: LD_ADDR_VAR 0 3
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_INT 2
13468: PPUSH
13469: LD_INT 2
13471: PPUSH
13472: LD_INT 14
13474: PPUSH
13475: LD_INT 1
13477: PPUSH
13478: LD_INT 1
13480: PPUSH
13481: LD_INT 25
13483: PPUSH
13484: LD_INT 33
13486: PPUSH
13487: CALL 423 0 7
13491: ADD
13492: ST_TO_ADDR
// tmp := tmp diff 0 ;
13493: LD_ADDR_VAR 0 3
13497: PUSH
13498: LD_VAR 0 3
13502: PUSH
13503: LD_INT 0
13505: DIFF
13506: ST_TO_ADDR
// for i in ar_force do
13507: LD_ADDR_VAR 0 4
13511: PUSH
13512: LD_EXP 36
13516: PUSH
13517: FOR_IN
13518: IFFALSE 13661
// begin if GetClass ( i ) = 3 then
13520: LD_VAR 0 4
13524: PPUSH
13525: CALL_OW 257
13529: PUSH
13530: LD_INT 3
13532: EQUAL
13533: IFFALSE 13615
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13535: LD_VAR 0 3
13539: PUSH
13540: LD_INT 1
13542: ARRAY
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13551: LD_VAR 0 3
13555: PUSH
13556: LD_INT 1
13558: ARRAY
13559: PPUSH
13560: LD_VAR 0 5
13564: PPUSH
13565: LD_VAR 0 6
13569: PPUSH
13570: LD_INT 0
13572: PPUSH
13573: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13577: LD_VAR 0 4
13581: PPUSH
13582: LD_VAR 0 3
13586: PUSH
13587: LD_INT 1
13589: ARRAY
13590: PPUSH
13591: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13595: LD_ADDR_VAR 0 3
13599: PUSH
13600: LD_VAR 0 3
13604: PPUSH
13605: LD_INT 1
13607: PPUSH
13608: CALL_OW 3
13612: ST_TO_ADDR
// end else
13613: GO 13637
// PlaceUnitXY ( i , x , y , false ) ;
13615: LD_VAR 0 4
13619: PPUSH
13620: LD_VAR 0 5
13624: PPUSH
13625: LD_VAR 0 6
13629: PPUSH
13630: LD_INT 0
13632: PPUSH
13633: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13637: LD_VAR 0 4
13641: PPUSH
13642: LD_INT 86
13644: PPUSH
13645: LD_INT 121
13647: PPUSH
13648: CALL_OW 111
// wait ( 0 0$2 ) ;
13652: LD_INT 70
13654: PPUSH
13655: CALL_OW 67
// end ;
13659: GO 13517
13661: POP
13662: POP
// ar_force := ar_force ^ tmp ;
13663: LD_ADDR_EXP 36
13667: PUSH
13668: LD_EXP 36
13672: PUSH
13673: LD_VAR 0 3
13677: ADD
13678: ST_TO_ADDR
// ar_spawned := true ;
13679: LD_ADDR_EXP 11
13683: PUSH
13684: LD_INT 1
13686: ST_TO_ADDR
// end ; end_of_file
13687: LD_VAR 0 1
13691: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13692: LD_INT 0
13694: PPUSH
13695: PPUSH
13696: PPUSH
13697: PPUSH
13698: PPUSH
13699: PPUSH
13700: PPUSH
// InitHc ;
13701: CALL_OW 19
// uc_side := 3 ;
13705: LD_ADDR_OWVAR 20
13709: PUSH
13710: LD_INT 3
13712: ST_TO_ADDR
// uc_nation := 3 ;
13713: LD_ADDR_OWVAR 21
13717: PUSH
13718: LD_INT 3
13720: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13721: LD_ADDR_VAR 0 5
13725: PUSH
13726: LD_INT 5
13728: PUSH
13729: LD_INT 6
13731: PUSH
13732: LD_INT 7
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: LIST
13739: PUSH
13740: LD_OWVAR 67
13744: ARRAY
13745: ST_TO_ADDR
// ru_force := [ ] ;
13746: LD_ADDR_EXP 38
13750: PUSH
13751: EMPTY
13752: ST_TO_ADDR
// ru_rebuild := [ ] ;
13753: LD_ADDR_EXP 39
13757: PUSH
13758: EMPTY
13759: ST_TO_ADDR
// ru_produce_list := [ ] ;
13760: LD_ADDR_EXP 40
13764: PUSH
13765: EMPTY
13766: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13767: LD_ADDR_VAR 0 6
13771: PUSH
13772: LD_INT 22
13774: PUSH
13775: LD_INT 3
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PUSH
13782: LD_INT 30
13784: PUSH
13785: LD_INT 8
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: EMPTY
13793: LIST
13794: LIST
13795: PPUSH
13796: CALL_OW 69
13800: PUSH
13801: LD_INT 1
13803: ARRAY
13804: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: LD_INT 43
13812: PUSH
13813: LD_INT 46
13815: PUSH
13816: LD_INT 45
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: LIST
13823: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13824: LD_ADDR_VAR 0 7
13828: PUSH
13829: LD_INT 22
13831: PUSH
13832: LD_INT 3
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: LD_INT 30
13841: PUSH
13842: LD_INT 1
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: PUSH
13849: EMPTY
13850: LIST
13851: LIST
13852: PPUSH
13853: CALL_OW 69
13857: PUSH
13858: LD_INT 1
13860: ARRAY
13861: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13862: LD_VAR 0 7
13866: PPUSH
13867: CALL_OW 274
13871: PPUSH
13872: LD_INT 1
13874: PPUSH
13875: LD_INT 5000
13877: PPUSH
13878: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13882: LD_VAR 0 7
13886: PPUSH
13887: CALL_OW 274
13891: PPUSH
13892: LD_INT 2
13894: PPUSH
13895: LD_INT 1000
13897: PPUSH
13898: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13902: LD_VAR 0 7
13906: PPUSH
13907: CALL_OW 274
13911: PPUSH
13912: LD_INT 3
13914: PPUSH
13915: LD_INT 30
13917: PPUSH
13918: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13922: LD_ADDR_VAR 0 2
13926: PUSH
13927: LD_INT 22
13929: PUSH
13930: LD_INT 3
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: LD_INT 30
13939: PUSH
13940: LD_INT 33
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: PPUSH
13951: CALL_OW 69
13955: PUSH
13956: FOR_IN
13957: IFFALSE 13989
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13959: LD_VAR 0 2
13963: PPUSH
13964: LD_VAR 0 4
13968: PUSH
13969: LD_VAR 0 2
13973: PUSH
13974: LD_INT 3
13976: MOD
13977: PUSH
13978: LD_INT 1
13980: PLUS
13981: ARRAY
13982: PPUSH
13983: CALL_OW 431
// end ;
13987: GO 13956
13989: POP
13990: POP
// for i = 1 to 4 do
13991: LD_ADDR_VAR 0 2
13995: PUSH
13996: DOUBLE
13997: LD_INT 1
13999: DEC
14000: ST_TO_ADDR
14001: LD_INT 4
14003: PUSH
14004: FOR_TO
14005: IFFALSE 14066
// begin PrepareHuman ( false , class_bazooker , skill ) ;
14007: LD_INT 0
14009: PPUSH
14010: LD_INT 9
14012: PPUSH
14013: LD_VAR 0 5
14017: PPUSH
14018: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
14022: CALL_OW 44
14026: PPUSH
14027: LD_INT 22
14029: PUSH
14030: LD_INT 3
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: LD_INT 30
14039: PUSH
14040: LD_INT 5
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PPUSH
14051: CALL_OW 69
14055: PUSH
14056: LD_INT 1
14058: ARRAY
14059: PPUSH
14060: CALL_OW 52
// end ;
14064: GO 14004
14066: POP
14067: POP
// for i = 1 to 5 do
14068: LD_ADDR_VAR 0 2
14072: PUSH
14073: DOUBLE
14074: LD_INT 1
14076: DEC
14077: ST_TO_ADDR
14078: LD_INT 5
14080: PUSH
14081: FOR_TO
14082: IFFALSE 14143
// begin PrepareHuman ( false , class_mechanic , skill ) ;
14084: LD_INT 0
14086: PPUSH
14087: LD_INT 3
14089: PPUSH
14090: LD_VAR 0 5
14094: PPUSH
14095: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
14099: CALL_OW 44
14103: PPUSH
14104: LD_INT 22
14106: PUSH
14107: LD_INT 3
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: PUSH
14114: LD_INT 30
14116: PUSH
14117: LD_INT 3
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: PUSH
14124: EMPTY
14125: LIST
14126: LIST
14127: PPUSH
14128: CALL_OW 69
14132: PUSH
14133: LD_INT 1
14135: ARRAY
14136: PPUSH
14137: CALL_OW 52
// end ;
14141: GO 14081
14143: POP
14144: POP
// for i = 1 to 4 do
14145: LD_ADDR_VAR 0 2
14149: PUSH
14150: DOUBLE
14151: LD_INT 1
14153: DEC
14154: ST_TO_ADDR
14155: LD_INT 4
14157: PUSH
14158: FOR_TO
14159: IFFALSE 14220
// begin PrepareHuman ( false , class_engineer , skill ) ;
14161: LD_INT 0
14163: PPUSH
14164: LD_INT 2
14166: PPUSH
14167: LD_VAR 0 5
14171: PPUSH
14172: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14176: CALL_OW 44
14180: PPUSH
14181: LD_INT 22
14183: PUSH
14184: LD_INT 3
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: PUSH
14191: LD_INT 30
14193: PUSH
14194: LD_INT 1
14196: PUSH
14197: EMPTY
14198: LIST
14199: LIST
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PPUSH
14205: CALL_OW 69
14209: PUSH
14210: LD_INT 1
14212: ARRAY
14213: PPUSH
14214: CALL_OW 52
// end ;
14218: GO 14158
14220: POP
14221: POP
// for i = 1 to 3 do
14222: LD_ADDR_VAR 0 2
14226: PUSH
14227: DOUBLE
14228: LD_INT 1
14230: DEC
14231: ST_TO_ADDR
14232: LD_INT 3
14234: PUSH
14235: FOR_TO
14236: IFFALSE 14269
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14238: LD_INT 0
14240: PPUSH
14241: LD_INT 4
14243: PPUSH
14244: LD_VAR 0 5
14248: PPUSH
14249: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14253: CALL_OW 44
14257: PPUSH
14258: LD_VAR 0 6
14262: PPUSH
14263: CALL_OW 52
// end ;
14267: GO 14235
14269: POP
14270: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14271: LD_ADDR_EXP 37
14275: PUSH
14276: LD_STRING Yakotich
14278: PPUSH
14279: LD_EXP 2
14283: NOT
14284: PPUSH
14285: LD_STRING 
14287: PPUSH
14288: CALL 360 0 3
14292: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14293: LD_EXP 37
14297: PPUSH
14298: LD_INT 74
14300: PPUSH
14301: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14305: LD_VAR 0 6
14309: PPUSH
14310: LD_INT 49
14312: PPUSH
14313: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14317: LD_VAR 0 6
14321: PPUSH
14322: LD_INT 50
14324: PPUSH
14325: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14329: LD_VAR 0 6
14333: PPUSH
14334: LD_INT 51
14336: PPUSH
14337: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14341: LD_VAR 0 6
14345: PPUSH
14346: LD_INT 52
14348: PPUSH
14349: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14353: LD_VAR 0 6
14357: PPUSH
14358: LD_INT 69
14360: PPUSH
14361: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14365: LD_VAR 0 6
14369: PPUSH
14370: LD_INT 39
14372: PPUSH
14373: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14377: LD_VAR 0 6
14381: PPUSH
14382: LD_INT 34
14384: PPUSH
14385: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14389: LD_VAR 0 6
14393: PPUSH
14394: LD_INT 40
14396: PPUSH
14397: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14401: LD_VAR 0 6
14405: PPUSH
14406: LD_INT 57
14408: PPUSH
14409: CALL_OW 184
// if Difficulty > 1 then
14413: LD_OWVAR 67
14417: PUSH
14418: LD_INT 1
14420: GREATER
14421: IFFALSE 14435
// AddComResearch ( lab , tech_comp2 ) ;
14423: LD_VAR 0 6
14427: PPUSH
14428: LD_INT 58
14430: PPUSH
14431: CALL_OW 184
// end ;
14435: LD_VAR 0 1
14439: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14440: LD_INT 7
14442: PPUSH
14443: CALL_OW 353
14447: PUSH
14448: LD_INT 3
14450: GREATER
14451: PUSH
14452: LD_INT 22
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: LD_INT 34
14464: PUSH
14465: LD_INT 53
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PUSH
14472: EMPTY
14473: LIST
14474: LIST
14475: PPUSH
14476: CALL_OW 69
14480: NOT
14481: AND
14482: IFFALSE 14517
14484: GO 14486
14486: DISABLE
// begin enable ;
14487: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14488: LD_ADDR_EXP 40
14492: PUSH
14493: LD_EXP 40
14497: PUSH
14498: LD_INT 24
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: LD_INT 3
14506: PUSH
14507: LD_INT 53
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: ADD
14516: ST_TO_ADDR
// end ;
14517: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14518: LD_INT 22
14520: PUSH
14521: LD_INT 3
14523: PUSH
14524: EMPTY
14525: LIST
14526: LIST
14527: PUSH
14528: LD_INT 21
14530: PUSH
14531: LD_INT 3
14533: PUSH
14534: EMPTY
14535: LIST
14536: LIST
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PPUSH
14542: CALL_OW 69
14546: IFFALSE 15324
14548: GO 14550
14550: DISABLE
14551: LD_INT 0
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
14560: PPUSH
// begin enable ;
14561: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14562: LD_ADDR_VAR 0 3
14566: PUSH
14567: LD_INT 22
14569: PUSH
14570: LD_INT 3
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: LD_INT 21
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 3
14589: PUSH
14590: LD_INT 24
14592: PUSH
14593: LD_INT 1000
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: LIST
14608: PPUSH
14609: CALL_OW 69
14613: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14614: LD_ADDR_VAR 0 4
14618: PUSH
14619: LD_INT 22
14621: PUSH
14622: LD_INT 3
14624: PUSH
14625: EMPTY
14626: LIST
14627: LIST
14628: PUSH
14629: LD_INT 25
14631: PUSH
14632: LD_INT 2
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: PUSH
14639: EMPTY
14640: LIST
14641: LIST
14642: PPUSH
14643: CALL_OW 69
14647: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14648: LD_ADDR_VAR 0 5
14652: PUSH
14653: LD_INT 22
14655: PUSH
14656: LD_INT 3
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PUSH
14663: LD_INT 30
14665: PUSH
14666: LD_INT 1
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PPUSH
14677: CALL_OW 69
14681: PUSH
14682: LD_INT 1
14684: ARRAY
14685: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14686: LD_ADDR_VAR 0 8
14690: PUSH
14691: LD_INT 22
14693: PUSH
14694: LD_INT 3
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: PUSH
14701: LD_INT 2
14703: PUSH
14704: LD_INT 30
14706: PUSH
14707: LD_INT 6
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 30
14716: PUSH
14717: LD_INT 7
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: PUSH
14724: LD_INT 30
14726: PUSH
14727: LD_INT 8
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: PPUSH
14744: CALL_OW 69
14748: PUSH
14749: LD_INT 1
14751: ARRAY
14752: ST_TO_ADDR
// if not engs then
14753: LD_VAR 0 4
14757: NOT
14758: IFFALSE 14762
// exit ;
14760: GO 15324
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14762: LD_ADDR_VAR 0 6
14766: PUSH
14767: LD_VAR 0 4
14771: PPUSH
14772: LD_INT 3
14774: PUSH
14775: LD_INT 24
14777: PUSH
14778: LD_INT 600
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PPUSH
14789: CALL_OW 72
14793: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14794: LD_ADDR_VAR 0 7
14798: PUSH
14799: LD_INT 22
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: LD_INT 25
14811: PUSH
14812: LD_INT 4
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PPUSH
14823: CALL_OW 69
14827: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14828: LD_VAR 0 3
14832: NOT
14833: PUSH
14834: LD_EXP 39
14838: NOT
14839: AND
14840: IFFALSE 14900
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14842: LD_VAR 0 4
14846: PPUSH
14847: LD_INT 3
14849: PUSH
14850: LD_INT 54
14852: PUSH
14853: EMPTY
14854: LIST
14855: PUSH
14856: EMPTY
14857: LIST
14858: LIST
14859: PPUSH
14860: CALL_OW 72
14864: IFFALSE 14898
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14866: LD_VAR 0 4
14870: PPUSH
14871: LD_INT 3
14873: PUSH
14874: LD_INT 54
14876: PUSH
14877: EMPTY
14878: LIST
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PPUSH
14884: CALL_OW 72
14888: PPUSH
14889: LD_VAR 0 5
14893: PPUSH
14894: CALL_OW 120
// exit ;
14898: GO 15324
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14900: LD_VAR 0 4
14904: PPUSH
14905: LD_INT 54
14907: PUSH
14908: EMPTY
14909: LIST
14910: PPUSH
14911: CALL_OW 72
14915: IFFALSE 14937
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14917: LD_VAR 0 4
14921: PPUSH
14922: LD_INT 54
14924: PUSH
14925: EMPTY
14926: LIST
14927: PPUSH
14928: CALL_OW 72
14932: PPUSH
14933: CALL_OW 122
// if not tmp then
14937: LD_VAR 0 3
14941: NOT
14942: IFFALSE 15074
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14944: LD_INT 81
14946: PUSH
14947: LD_INT 3
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: PUSH
14954: LD_INT 92
14956: PUSH
14957: LD_INT 147
14959: PUSH
14960: LD_INT 212
14962: PUSH
14963: LD_INT 30
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: PPUSH
14976: CALL_OW 69
14980: NOT
14981: IFFALSE 15074
// begin if not HasTask ( engs [ 1 ] ) then
14983: LD_VAR 0 4
14987: PUSH
14988: LD_INT 1
14990: ARRAY
14991: PPUSH
14992: CALL_OW 314
14996: NOT
14997: IFFALSE 15074
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14999: LD_ADDR_VAR 0 2
15003: PUSH
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_EXP 39
15013: PUSH
15014: LD_INT 1
15016: ARRAY
15017: PPUSH
15018: LD_EXP 39
15022: PUSH
15023: LD_INT 2
15025: ARRAY
15026: PPUSH
15027: LD_EXP 39
15031: PUSH
15032: LD_INT 3
15034: ARRAY
15035: PPUSH
15036: LD_EXP 39
15040: PUSH
15041: LD_INT 4
15043: ARRAY
15044: PPUSH
15045: CALL_OW 145
15049: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
15050: LD_VAR 0 2
15054: PPUSH
15055: CALL_OW 266
15059: PUSH
15060: LD_INT 4
15062: EQUAL
15063: IFFALSE 15074
// AddComUpgrade ( i ) ;
15065: LD_VAR 0 2
15069: PPUSH
15070: CALL_OW 206
// end ; end ; end ; for i in engs do
15074: LD_ADDR_VAR 0 2
15078: PUSH
15079: LD_VAR 0 4
15083: PUSH
15084: FOR_IN
15085: IFFALSE 15203
// begin if i in to_heal and sci then
15087: LD_VAR 0 2
15091: PUSH
15092: LD_VAR 0 6
15096: IN
15097: PUSH
15098: LD_VAR 0 7
15102: AND
15103: IFFALSE 15154
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
15105: LD_VAR 0 2
15109: PPUSH
15110: LD_INT 149
15112: PPUSH
15113: LD_INT 220
15115: PPUSH
15116: CALL_OW 297
15120: PUSH
15121: LD_INT 5
15123: LESS
15124: IFFALSE 15128
// continue ;
15126: GO 15084
// ComMoveXY ( i , 149 , 220 ) ;
15128: LD_VAR 0 2
15132: PPUSH
15133: LD_INT 149
15135: PPUSH
15136: LD_INT 220
15138: PPUSH
15139: CALL_OW 111
// AddComHold ( i ) ;
15143: LD_VAR 0 2
15147: PPUSH
15148: CALL_OW 200
// end else
15152: GO 15201
// if not HasTask ( i ) or WantsToAttack ( i ) then
15154: LD_VAR 0 2
15158: PPUSH
15159: CALL_OW 314
15163: NOT
15164: PUSH
15165: LD_VAR 0 2
15169: PPUSH
15170: CALL_OW 319
15174: OR
15175: IFFALSE 15201
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15177: LD_VAR 0 2
15181: PPUSH
15182: LD_VAR 0 3
15186: PPUSH
15187: LD_VAR 0 2
15191: PPUSH
15192: CALL_OW 74
15196: PPUSH
15197: CALL_OW 130
// end ;
15201: GO 15084
15203: POP
15204: POP
// if to_heal and sci then
15205: LD_VAR 0 6
15209: PUSH
15210: LD_VAR 0 7
15214: AND
15215: IFFALSE 15276
// begin if UnitFilter ( sci , [ f_inside ] ) then
15217: LD_VAR 0 7
15221: PPUSH
15222: LD_INT 54
15224: PUSH
15225: EMPTY
15226: LIST
15227: PPUSH
15228: CALL_OW 72
15232: IFFALSE 15256
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15234: LD_VAR 0 7
15238: PPUSH
15239: LD_INT 54
15241: PUSH
15242: EMPTY
15243: LIST
15244: PPUSH
15245: CALL_OW 72
15249: PPUSH
15250: CALL_OW 122
15254: GO 15274
// ComHeal ( sci , to_heal [ 1 ] ) ;
15256: LD_VAR 0 7
15260: PPUSH
15261: LD_VAR 0 6
15265: PUSH
15266: LD_INT 1
15268: ARRAY
15269: PPUSH
15270: CALL_OW 128
// end else
15274: GO 15324
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15276: LD_VAR 0 7
15280: PPUSH
15281: LD_INT 56
15283: PUSH
15284: EMPTY
15285: LIST
15286: PPUSH
15287: CALL_OW 72
15291: PUSH
15292: LD_VAR 0 8
15296: AND
15297: IFFALSE 15324
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15299: LD_VAR 0 7
15303: PPUSH
15304: LD_INT 56
15306: PUSH
15307: EMPTY
15308: LIST
15309: PPUSH
15310: CALL_OW 72
15314: PPUSH
15315: LD_VAR 0 8
15319: PPUSH
15320: CALL_OW 120
// end ;
15324: PPOPN 8
15326: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 30
15339: PUSH
15340: LD_INT 3
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: PUSH
15356: LD_EXP 40
15360: AND
15361: IFFALSE 15487
15363: GO 15365
15365: DISABLE
15366: LD_INT 0
15368: PPUSH
15369: PPUSH
15370: PPUSH
// begin enable ;
15371: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15372: LD_ADDR_VAR 0 3
15376: PUSH
15377: LD_INT 22
15379: PUSH
15380: LD_INT 3
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PUSH
15387: LD_INT 30
15389: PUSH
15390: LD_INT 3
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PPUSH
15401: CALL_OW 69
15405: PUSH
15406: LD_INT 1
15408: ARRAY
15409: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15410: LD_VAR 0 3
15414: PPUSH
15415: CALL_OW 313
15419: PUSH
15420: LD_INT 0
15422: EQUAL
15423: IFFALSE 15427
// exit ;
15425: GO 15487
// if BuildingStatus ( fac ) = bs_idle then
15427: LD_VAR 0 3
15431: PPUSH
15432: CALL_OW 461
15436: PUSH
15437: LD_INT 2
15439: EQUAL
15440: IFFALSE 15487
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15442: LD_VAR 0 3
15446: PPUSH
15447: LD_EXP 40
15451: PUSH
15452: LD_INT 1
15454: ARRAY
15455: PPUSH
15456: LD_EXP 40
15460: PUSH
15461: LD_INT 2
15463: ARRAY
15464: PPUSH
15465: LD_EXP 40
15469: PUSH
15470: LD_INT 3
15472: ARRAY
15473: PPUSH
15474: LD_EXP 40
15478: PUSH
15479: LD_INT 4
15481: ARRAY
15482: PPUSH
15483: CALL_OW 125
// end ;
15487: PPOPN 3
15489: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15490: LD_INT 0
15492: PPUSH
15493: PPUSH
15494: PPUSH
15495: PPUSH
15496: PPUSH
// uc_side := 3 ;
15497: LD_ADDR_OWVAR 20
15501: PUSH
15502: LD_INT 3
15504: ST_TO_ADDR
// uc_nation := 3 ;
15505: LD_ADDR_OWVAR 21
15509: PUSH
15510: LD_INT 3
15512: ST_TO_ADDR
// ru_can_attack := false ;
15513: LD_ADDR_EXP 8
15517: PUSH
15518: LD_INT 0
15520: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15521: LD_ADDR_VAR 0 6
15525: PUSH
15526: LD_INT 22
15528: PUSH
15529: LD_INT 3
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PUSH
15536: LD_INT 30
15538: PUSH
15539: LD_INT 3
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: PPUSH
15550: CALL_OW 69
15554: ST_TO_ADDR
// if fac then
15555: LD_VAR 0 6
15559: IFFALSE 15711
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15561: LD_ADDR_EXP 40
15565: PUSH
15566: LD_INT 24
15568: PUSH
15569: LD_INT 1
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 43
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: LIST
15582: LIST
15583: ST_TO_ADDR
// if wave > 1 then
15584: LD_VAR 0 1
15588: PUSH
15589: LD_INT 1
15591: GREATER
15592: IFFALSE 15645
// for i = 1 to Difficulty do
15594: LD_ADDR_VAR 0 3
15598: PUSH
15599: DOUBLE
15600: LD_INT 1
15602: DEC
15603: ST_TO_ADDR
15604: LD_OWVAR 67
15608: PUSH
15609: FOR_TO
15610: IFFALSE 15643
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15612: LD_ADDR_EXP 40
15616: PUSH
15617: LD_EXP 40
15621: PUSH
15622: LD_INT 24
15624: PUSH
15625: LD_INT 1
15627: PUSH
15628: LD_INT 3
15630: PUSH
15631: LD_INT 45
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: LIST
15638: LIST
15639: ADD
15640: ST_TO_ADDR
15641: GO 15609
15643: POP
15644: POP
// repeat wait ( 0 0$1 ) ;
15645: LD_INT 35
15647: PPUSH
15648: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15652: LD_EXP 40
15656: PUSH
15657: LD_INT 4
15659: LESS
15660: PUSH
15661: LD_VAR 0 6
15665: PUSH
15666: LD_INT 1
15668: ARRAY
15669: PPUSH
15670: CALL_OW 313
15674: PUSH
15675: LD_INT 0
15677: EQUAL
15678: OR
15679: PUSH
15680: LD_VAR 0 6
15684: PUSH
15685: LD_INT 1
15687: ARRAY
15688: PPUSH
15689: CALL_OW 461
15693: PUSH
15694: LD_INT 8
15696: PUSH
15697: LD_INT 6
15699: PUSH
15700: LD_INT 7
15702: PUSH
15703: EMPTY
15704: LIST
15705: LIST
15706: LIST
15707: IN
15708: OR
15709: IFFALSE 15645
// end ; case wave of 1 :
15711: LD_VAR 0 1
15715: PUSH
15716: LD_INT 1
15718: DOUBLE
15719: EQUAL
15720: IFTRUE 15724
15722: GO 15809
15724: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: DOUBLE
15731: LD_INT 1
15733: DEC
15734: ST_TO_ADDR
15735: LD_INT 2
15737: PUSH
15738: LD_INT 3
15740: PUSH
15741: LD_INT 4
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: LIST
15748: PUSH
15749: LD_OWVAR 67
15753: ARRAY
15754: PUSH
15755: FOR_TO
15756: IFFALSE 15764
// Sold ;
15758: CALL 16035 0 0
15762: GO 15755
15764: POP
15765: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15766: LD_ADDR_VAR 0 3
15770: PUSH
15771: DOUBLE
15772: LD_INT 1
15774: DEC
15775: ST_TO_ADDR
15776: LD_INT 2
15778: PUSH
15779: LD_INT 3
15781: PUSH
15782: LD_INT 3
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: LIST
15789: PUSH
15790: LD_OWVAR 67
15794: ARRAY
15795: PUSH
15796: FOR_TO
15797: IFFALSE 15805
// Tank ;
15799: CALL 16165 0 0
15803: GO 15796
15805: POP
15806: POP
// end ; 2 .. 9 :
15807: GO 16022
15809: LD_INT 2
15811: DOUBLE
15812: GREATEREQUAL
15813: IFFALSE 15821
15815: LD_INT 9
15817: DOUBLE
15818: LESSEQUAL
15819: IFTRUE 15823
15821: GO 15928
15823: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15824: LD_ADDR_VAR 0 3
15828: PUSH
15829: DOUBLE
15830: LD_INT 1
15832: DEC
15833: ST_TO_ADDR
15834: LD_INT 2
15836: PUSH
15837: LD_INT 4
15839: PUSH
15840: LD_INT 5
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: LIST
15847: PUSH
15848: LD_OWVAR 67
15852: ARRAY
15853: PUSH
15854: LD_VAR 0 1
15858: PUSH
15859: LD_INT 2
15861: DIV
15862: PLUS
15863: PUSH
15864: FOR_TO
15865: IFFALSE 15873
// Sold ;
15867: CALL 16035 0 0
15871: GO 15864
15873: POP
15874: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15875: LD_ADDR_VAR 0 3
15879: PUSH
15880: DOUBLE
15881: LD_INT 1
15883: DEC
15884: ST_TO_ADDR
15885: LD_INT 2
15887: PUSH
15888: LD_INT 3
15890: PUSH
15891: LD_INT 3
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: LIST
15898: PUSH
15899: LD_OWVAR 67
15903: ARRAY
15904: PUSH
15905: LD_VAR 0 1
15909: PUSH
15910: LD_INT 2
15912: DIV
15913: PLUS
15914: PUSH
15915: FOR_TO
15916: IFFALSE 15924
// Tank ;
15918: CALL 16165 0 0
15922: GO 15915
15924: POP
15925: POP
// end ; 10 :
15926: GO 16022
15928: LD_INT 10
15930: DOUBLE
15931: EQUAL
15932: IFTRUE 15936
15934: GO 16021
15936: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15937: LD_ADDR_VAR 0 3
15941: PUSH
15942: DOUBLE
15943: LD_INT 1
15945: DEC
15946: ST_TO_ADDR
15947: LD_INT 10
15949: PUSH
15950: LD_INT 12
15952: PUSH
15953: LD_INT 14
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: LIST
15960: PUSH
15961: LD_OWVAR 67
15965: ARRAY
15966: PUSH
15967: FOR_TO
15968: IFFALSE 15976
// Sold ;
15970: CALL 16035 0 0
15974: GO 15967
15976: POP
15977: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15978: LD_ADDR_VAR 0 3
15982: PUSH
15983: DOUBLE
15984: LD_INT 1
15986: DEC
15987: ST_TO_ADDR
15988: LD_INT 11
15990: PUSH
15991: LD_INT 13
15993: PUSH
15994: LD_INT 15
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: LIST
16001: PUSH
16002: LD_OWVAR 67
16006: ARRAY
16007: PUSH
16008: FOR_TO
16009: IFFALSE 16017
// Tank ;
16011: CALL 16165 0 0
16015: GO 16008
16017: POP
16018: POP
// end ; end ;
16019: GO 16022
16021: POP
// ru_can_attack := true ;
16022: LD_ADDR_EXP 8
16026: PUSH
16027: LD_INT 1
16029: ST_TO_ADDR
// end ;
16030: LD_VAR 0 2
16034: RET
// function Sold ( ) ; var un , skill ; begin
16035: LD_INT 0
16037: PPUSH
16038: PPUSH
16039: PPUSH
// uc_side := 3 ;
16040: LD_ADDR_OWVAR 20
16044: PUSH
16045: LD_INT 3
16047: ST_TO_ADDR
// uc_nation := 3 ;
16048: LD_ADDR_OWVAR 21
16052: PUSH
16053: LD_INT 3
16055: ST_TO_ADDR
// InitHc ;
16056: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16060: LD_ADDR_VAR 0 3
16064: PUSH
16065: LD_INT 5
16067: PUSH
16068: LD_INT 6
16070: PUSH
16071: LD_INT 7
16073: PUSH
16074: EMPTY
16075: LIST
16076: LIST
16077: LIST
16078: PUSH
16079: LD_OWVAR 67
16083: ARRAY
16084: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
16085: LD_INT 0
16087: PPUSH
16088: LD_INT 1
16090: PUSH
16091: LD_INT 9
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: PUSH
16098: LD_INT 1
16100: PPUSH
16101: LD_INT 2
16103: PPUSH
16104: CALL_OW 12
16108: ARRAY
16109: PPUSH
16110: LD_VAR 0 3
16114: PPUSH
16115: CALL_OW 380
// un := CreateHuman ;
16119: LD_ADDR_VAR 0 2
16123: PUSH
16124: CALL_OW 44
16128: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
16129: LD_VAR 0 2
16133: PPUSH
16134: LD_INT 4
16136: PPUSH
16137: LD_INT 0
16139: PPUSH
16140: CALL_OW 49
// ru_force := ru_force ^ un ;
16144: LD_ADDR_EXP 38
16148: PUSH
16149: LD_EXP 38
16153: PUSH
16154: LD_VAR 0 2
16158: ADD
16159: ST_TO_ADDR
// end ;
16160: LD_VAR 0 1
16164: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16165: LD_INT 0
16167: PPUSH
16168: PPUSH
16169: PPUSH
16170: PPUSH
16171: PPUSH
// uc_side := 3 ;
16172: LD_ADDR_OWVAR 20
16176: PUSH
16177: LD_INT 3
16179: ST_TO_ADDR
// uc_nation := 3 ;
16180: LD_ADDR_OWVAR 21
16184: PUSH
16185: LD_INT 3
16187: ST_TO_ADDR
// InitHc ;
16188: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16192: LD_ADDR_VAR 0 5
16196: PUSH
16197: LD_INT 5
16199: PUSH
16200: LD_INT 6
16202: PUSH
16203: LD_INT 7
16205: PUSH
16206: EMPTY
16207: LIST
16208: LIST
16209: LIST
16210: PUSH
16211: LD_OWVAR 67
16215: ARRAY
16216: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16217: LD_ADDR_VAR 0 3
16221: PUSH
16222: LD_INT 22
16224: PUSH
16225: LD_INT 24
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: PUSH
16232: LD_INT 1
16234: PPUSH
16235: LD_INT 2
16237: PPUSH
16238: CALL_OW 12
16242: ARRAY
16243: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16244: LD_VAR 0 3
16248: PUSH
16249: LD_INT 22
16251: EQUAL
16252: IFFALSE 16287
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16254: LD_ADDR_VAR 0 4
16258: PUSH
16259: LD_INT 45
16261: PUSH
16262: LD_INT 43
16264: PUSH
16265: LD_INT 44
16267: PUSH
16268: EMPTY
16269: LIST
16270: LIST
16271: LIST
16272: PUSH
16273: LD_INT 1
16275: PPUSH
16276: LD_INT 3
16278: PPUSH
16279: CALL_OW 12
16283: ARRAY
16284: ST_TO_ADDR
16285: GO 16318
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16287: LD_ADDR_VAR 0 4
16291: PUSH
16292: LD_INT 46
16294: PUSH
16295: LD_INT 44
16297: PUSH
16298: LD_INT 45
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: LIST
16305: PUSH
16306: LD_INT 1
16308: PPUSH
16309: LD_INT 3
16311: PPUSH
16312: CALL_OW 12
16316: ARRAY
16317: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16318: LD_ADDR_VAR 0 2
16322: PUSH
16323: LD_INT 3
16325: PPUSH
16326: LD_INT 3
16328: PPUSH
16329: LD_VAR 0 3
16333: PPUSH
16334: LD_INT 1
16336: PPUSH
16337: LD_INT 3
16339: PUSH
16340: LD_INT 3
16342: PUSH
16343: LD_INT 3
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: LIST
16353: LIST
16354: PUSH
16355: LD_INT 1
16357: PPUSH
16358: LD_INT 4
16360: PPUSH
16361: CALL_OW 12
16365: ARRAY
16366: PPUSH
16367: LD_VAR 0 4
16371: PPUSH
16372: LD_INT 99
16374: PPUSH
16375: CALL 423 0 7
16379: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16380: LD_VAR 0 2
16384: PPUSH
16385: CALL_OW 263
16389: PUSH
16390: LD_INT 1
16392: EQUAL
16393: IFFALSE 16424
// begin PrepareHuman ( false , 3 , skill ) ;
16395: LD_INT 0
16397: PPUSH
16398: LD_INT 3
16400: PPUSH
16401: LD_VAR 0 5
16405: PPUSH
16406: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16410: CALL_OW 44
16414: PPUSH
16415: LD_VAR 0 2
16419: PPUSH
16420: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16424: LD_VAR 0 2
16428: PPUSH
16429: LD_INT 3
16431: PPUSH
16432: LD_INT 0
16434: PPUSH
16435: CALL_OW 49
// ru_force := ru_force ^ un ;
16439: LD_ADDR_EXP 38
16443: PUSH
16444: LD_EXP 38
16448: PUSH
16449: LD_VAR 0 2
16453: ADD
16454: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16455: LD_VAR 0 2
16459: PPUSH
16460: LD_INT 126
16462: PPUSH
16463: LD_INT 158
16465: PPUSH
16466: CALL_OW 111
// Wait ( 0 0$3 ) ;
16470: LD_INT 105
16472: PPUSH
16473: CALL_OW 67
// ComStop ( un ) ;
16477: LD_VAR 0 2
16481: PPUSH
16482: CALL_OW 141
// end ;
16486: LD_VAR 0 1
16490: RET
// every 0 0$1 do var i , time , wave ;
16491: GO 16493
16493: DISABLE
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16499: LD_ADDR_VAR 0 2
16503: PUSH
16504: LD_INT 25200
16506: PUSH
16507: LD_INT 24150
16509: PUSH
16510: LD_INT 23100
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: LIST
16517: PUSH
16518: LD_OWVAR 67
16522: ARRAY
16523: ST_TO_ADDR
// wait ( time ) ;
16524: LD_VAR 0 2
16528: PPUSH
16529: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16533: LD_ADDR_VAR 0 2
16537: PUSH
16538: LD_INT 15750
16540: PUSH
16541: LD_INT 15400
16543: PUSH
16544: LD_INT 15050
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: LIST
16551: PUSH
16552: LD_OWVAR 67
16556: ARRAY
16557: ST_TO_ADDR
// wave := 0 ;
16558: LD_ADDR_VAR 0 3
16562: PUSH
16563: LD_INT 0
16565: ST_TO_ADDR
// while true do
16566: LD_INT 1
16568: IFFALSE 16672
// begin wave := wave + 1 ;
16570: LD_ADDR_VAR 0 3
16574: PUSH
16575: LD_VAR 0 3
16579: PUSH
16580: LD_INT 1
16582: PLUS
16583: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16584: LD_INT 22
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PPUSH
16594: CALL_OW 69
16598: IFFALSE 16634
// begin repeat wait ( 0 0$1 ) ;
16600: LD_INT 35
16602: PPUSH
16603: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16607: LD_INT 22
16609: PUSH
16610: LD_INT 2
16612: PUSH
16613: EMPTY
16614: LIST
16615: LIST
16616: PPUSH
16617: CALL_OW 69
16621: PUSH
16622: LD_INT 0
16624: EQUAL
16625: IFFALSE 16600
// wait ( 1 1$30 ) ;
16627: LD_INT 3150
16629: PPUSH
16630: CALL_OW 67
// end ; if ru_force < 20 then
16634: LD_EXP 38
16638: PUSH
16639: LD_INT 20
16641: LESS
16642: IFFALSE 16653
// PrepareAttack ( wave ) ;
16644: LD_VAR 0 3
16648: PPUSH
16649: CALL 15490 0 1
// ru_can_attack := true ;
16653: LD_ADDR_EXP 8
16657: PUSH
16658: LD_INT 1
16660: ST_TO_ADDR
// wait ( time ) ;
16661: LD_VAR 0 2
16665: PPUSH
16666: CALL_OW 67
// end ;
16670: GO 16566
// end ;
16672: PPOPN 3
16674: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16675: LD_EXP 8
16679: PUSH
16680: LD_EXP 38
16684: AND
16685: IFFALSE 17519
16687: GO 16689
16689: DISABLE
16690: LD_INT 0
16692: PPUSH
16693: PPUSH
16694: PPUSH
16695: PPUSH
16696: PPUSH
16697: PPUSH
16698: PPUSH
16699: PPUSH
16700: PPUSH
// begin enable ;
16701: ENABLE
// points1 := [ 107 , 123 ] ;
16702: LD_ADDR_VAR 0 4
16706: PUSH
16707: LD_INT 107
16709: PUSH
16710: LD_INT 123
16712: PUSH
16713: EMPTY
16714: LIST
16715: LIST
16716: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16717: LD_ADDR_VAR 0 5
16721: PUSH
16722: LD_INT 55
16724: PUSH
16725: LD_INT 42
16727: PUSH
16728: EMPTY
16729: LIST
16730: LIST
16731: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16732: LD_ADDR_VAR 0 6
16736: PUSH
16737: LD_INT 102
16739: PUSH
16740: LD_INT 140
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: LD_INT 105
16749: PUSH
16750: LD_INT 142
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: PUSH
16757: LD_INT 129
16759: PUSH
16760: LD_INT 131
16762: PUSH
16763: EMPTY
16764: LIST
16765: LIST
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: LIST
16771: ST_TO_ADDR
// for i in ru_force do
16772: LD_ADDR_VAR 0 1
16776: PUSH
16777: LD_EXP 38
16781: PUSH
16782: FOR_IN
16783: IFFALSE 17517
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16785: LD_ADDR_VAR 0 3
16789: PUSH
16790: LD_INT 81
16792: PUSH
16793: LD_INT 3
16795: PUSH
16796: EMPTY
16797: LIST
16798: LIST
16799: PPUSH
16800: CALL_OW 69
16804: PPUSH
16805: LD_VAR 0 1
16809: PPUSH
16810: CALL_OW 74
16814: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16815: LD_VAR 0 1
16819: PPUSH
16820: LD_VAR 0 3
16824: PPUSH
16825: CALL_OW 296
16829: PUSH
16830: LD_INT 12
16832: LESS
16833: IFFALSE 16978
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16835: LD_VAR 0 1
16839: PPUSH
16840: CALL_OW 247
16844: PUSH
16845: LD_INT 1
16847: EQUAL
16848: PUSH
16849: LD_VAR 0 1
16853: PPUSH
16854: CALL_OW 257
16858: PUSH
16859: LD_INT 1
16861: EQUAL
16862: AND
16863: PUSH
16864: LD_VAR 0 3
16868: PUSH
16869: LD_INT 21
16871: PUSH
16872: LD_INT 2
16874: PUSH
16875: EMPTY
16876: LIST
16877: LIST
16878: PUSH
16879: LD_INT 58
16881: PUSH
16882: EMPTY
16883: LIST
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: PPUSH
16889: CALL_OW 69
16893: IN
16894: AND
16895: IFFALSE 16913
// ComEnterUnit ( i , un ) else
16897: LD_VAR 0 1
16901: PPUSH
16902: LD_VAR 0 3
16906: PPUSH
16907: CALL_OW 120
16911: GO 16976
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16913: LD_VAR 0 3
16917: PUSH
16918: LD_INT 21
16920: PUSH
16921: LD_INT 2
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 58
16930: PUSH
16931: EMPTY
16932: LIST
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PPUSH
16938: CALL_OW 69
16942: IN
16943: NOT
16944: IFFALSE 16962
// ComAttackUnit ( i , un ) else
16946: LD_VAR 0 1
16950: PPUSH
16951: LD_VAR 0 3
16955: PPUSH
16956: CALL_OW 115
16960: GO 16976
// ComAttackUnit ( i , JMM ) ;
16962: LD_VAR 0 1
16966: PPUSH
16967: LD_EXP 21
16971: PPUSH
16972: CALL_OW 115
// end else
16976: GO 17515
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16978: LD_VAR 0 1
16982: PPUSH
16983: LD_VAR 0 4
16987: PUSH
16988: LD_INT 1
16990: ARRAY
16991: PPUSH
16992: LD_VAR 0 4
16996: PUSH
16997: LD_INT 2
16999: ARRAY
17000: PPUSH
17001: CALL_OW 297
17005: PUSH
17006: LD_VAR 0 1
17010: PPUSH
17011: LD_VAR 0 5
17015: PUSH
17016: LD_INT 1
17018: ARRAY
17019: PPUSH
17020: LD_VAR 0 5
17024: PUSH
17025: LD_INT 2
17027: ARRAY
17028: PPUSH
17029: CALL_OW 297
17033: GREATER
17034: PUSH
17035: LD_EXP 9
17039: AND
17040: PUSH
17041: LD_INT 9
17043: PPUSH
17044: LD_INT 81
17046: PUSH
17047: LD_INT 3
17049: PUSH
17050: EMPTY
17051: LIST
17052: LIST
17053: PPUSH
17054: CALL_OW 70
17058: PUSH
17059: LD_INT 0
17061: EQUAL
17062: OR
17063: IFFALSE 17101
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
17065: LD_VAR 0 1
17069: PPUSH
17070: LD_INT 81
17072: PUSH
17073: LD_INT 3
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PPUSH
17080: CALL_OW 69
17084: PPUSH
17085: LD_VAR 0 1
17089: PPUSH
17090: CALL_OW 74
17094: PPUSH
17095: CALL_OW 115
17099: GO 17515
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
17101: LD_VAR 0 1
17105: PPUSH
17106: CALL_OW 264
17110: PUSH
17111: LD_INT 45
17113: EQUAL
17114: PUSH
17115: LD_EXP 38
17119: PPUSH
17120: LD_INT 3
17122: PUSH
17123: LD_INT 34
17125: PUSH
17126: LD_INT 45
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: PPUSH
17137: CALL_OW 72
17141: PUSH
17142: LD_INT 6
17144: GREATER
17145: AND
17146: IFFALSE 17327
// begin dist := 9999 ;
17148: LD_ADDR_VAR 0 8
17152: PUSH
17153: LD_INT 9999
17155: ST_TO_ADDR
// xy := 0 ;
17156: LD_ADDR_VAR 0 9
17160: PUSH
17161: LD_INT 0
17163: ST_TO_ADDR
// for x in pointsr do
17164: LD_ADDR_VAR 0 7
17168: PUSH
17169: LD_VAR 0 6
17173: PUSH
17174: FOR_IN
17175: IFFALSE 17323
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17177: LD_VAR 0 1
17181: PPUSH
17182: LD_VAR 0 7
17186: PUSH
17187: LD_INT 1
17189: ARRAY
17190: PPUSH
17191: LD_VAR 0 7
17195: PUSH
17196: LD_INT 2
17198: ARRAY
17199: PPUSH
17200: CALL_OW 297
17204: PUSH
17205: LD_VAR 0 8
17209: LESS
17210: IFFALSE 17255
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17212: LD_ADDR_VAR 0 8
17216: PUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: LD_VAR 0 7
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_VAR 0 7
17235: PUSH
17236: LD_INT 2
17238: ARRAY
17239: PPUSH
17240: CALL_OW 297
17244: ST_TO_ADDR
// xy := x ;
17245: LD_ADDR_VAR 0 9
17249: PUSH
17250: LD_VAR 0 7
17254: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17255: LD_VAR 0 9
17259: PUSH
17260: LD_VAR 0 1
17264: PPUSH
17265: LD_VAR 0 9
17269: PUSH
17270: LD_INT 1
17272: ARRAY
17273: PPUSH
17274: LD_VAR 0 9
17278: PUSH
17279: LD_INT 2
17281: ARRAY
17282: PPUSH
17283: CALL_OW 297
17287: PUSH
17288: LD_INT 9
17290: GREATER
17291: AND
17292: IFFALSE 17321
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17294: LD_VAR 0 1
17298: PPUSH
17299: LD_VAR 0 9
17303: PUSH
17304: LD_INT 1
17306: ARRAY
17307: PPUSH
17308: LD_VAR 0 9
17312: PUSH
17313: LD_INT 2
17315: ARRAY
17316: PPUSH
17317: CALL_OW 114
// end ;
17321: GO 17174
17323: POP
17324: POP
// end else
17325: GO 17515
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17327: LD_ADDR_VAR 0 3
17331: PUSH
17332: LD_OWVAR 3
17336: PUSH
17337: LD_VAR 0 1
17341: DIFF
17342: PPUSH
17343: LD_VAR 0 1
17347: PPUSH
17348: CALL_OW 74
17352: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17353: LD_VAR 0 1
17357: PPUSH
17358: CALL_OW 320
17362: NOT
17363: PUSH
17364: LD_VAR 0 3
17368: PUSH
17369: LD_INT 21
17371: PUSH
17372: LD_INT 2
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PUSH
17379: LD_INT 33
17381: PUSH
17382: LD_INT 1
17384: PUSH
17385: EMPTY
17386: LIST
17387: LIST
17388: PUSH
17389: LD_INT 58
17391: PUSH
17392: EMPTY
17393: LIST
17394: PUSH
17395: EMPTY
17396: LIST
17397: LIST
17398: LIST
17399: PPUSH
17400: CALL_OW 69
17404: IN
17405: PUSH
17406: LD_VAR 0 3
17410: PUSH
17411: LD_INT 22
17413: PUSH
17414: LD_INT 3
17416: PUSH
17417: EMPTY
17418: LIST
17419: LIST
17420: PUSH
17421: LD_INT 21
17423: PUSH
17424: LD_INT 2
17426: PUSH
17427: EMPTY
17428: LIST
17429: LIST
17430: PUSH
17431: LD_INT 3
17433: PUSH
17434: LD_INT 24
17436: PUSH
17437: LD_INT 249
17439: PUSH
17440: EMPTY
17441: LIST
17442: LIST
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: PPUSH
17453: CALL_OW 69
17457: IN
17458: OR
17459: AND
17460: IFFALSE 17478
// ComAttackUnit ( i , un ) else
17462: LD_VAR 0 1
17466: PPUSH
17467: LD_VAR 0 3
17471: PPUSH
17472: CALL_OW 115
17476: GO 17515
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17478: LD_VAR 0 1
17482: PPUSH
17483: LD_INT 9
17485: PPUSH
17486: LD_INT 81
17488: PUSH
17489: LD_INT 3
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PPUSH
17496: CALL_OW 70
17500: PPUSH
17501: LD_VAR 0 1
17505: PPUSH
17506: CALL_OW 74
17510: PPUSH
17511: CALL_OW 115
// end ; end ; end ; end ;
17515: GO 16782
17517: POP
17518: POP
// end ;
17519: PPOPN 9
17521: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17522: LD_INT 22
17524: PUSH
17525: LD_INT 3
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: PUSH
17532: LD_INT 32
17534: PUSH
17535: LD_INT 1
17537: PUSH
17538: EMPTY
17539: LIST
17540: LIST
17541: PUSH
17542: EMPTY
17543: LIST
17544: LIST
17545: PPUSH
17546: CALL_OW 69
17550: IFFALSE 17638
17552: GO 17554
17554: DISABLE
17555: LD_INT 0
17557: PPUSH
17558: PPUSH
// begin enable ;
17559: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17560: LD_ADDR_VAR 0 2
17564: PUSH
17565: LD_INT 22
17567: PUSH
17568: LD_INT 3
17570: PUSH
17571: EMPTY
17572: LIST
17573: LIST
17574: PUSH
17575: LD_INT 32
17577: PUSH
17578: LD_INT 1
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: PUSH
17585: EMPTY
17586: LIST
17587: LIST
17588: PPUSH
17589: CALL_OW 69
17593: ST_TO_ADDR
// for i in tmp do
17594: LD_ADDR_VAR 0 1
17598: PUSH
17599: LD_VAR 0 2
17603: PUSH
17604: FOR_IN
17605: IFFALSE 17636
// if GetFuel ( i ) < 12 then
17607: LD_VAR 0 1
17611: PPUSH
17612: CALL_OW 261
17616: PUSH
17617: LD_INT 12
17619: LESS
17620: IFFALSE 17634
// SetFuel ( i , 12 ) ;
17622: LD_VAR 0 1
17626: PPUSH
17627: LD_INT 12
17629: PPUSH
17630: CALL_OW 240
17634: GO 17604
17636: POP
17637: POP
// end ;
17638: PPOPN 2
17640: END
// every 0 0$1 trigger can_end do
17641: LD_EXP 17
17645: IFFALSE 17668
17647: GO 17649
17649: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17650: LD_INT 3325
17652: PPUSH
17653: CALL_OW 67
// PrepareAttack ( 10 ) ;
17657: LD_INT 10
17659: PPUSH
17660: CALL 15490 0 1
// until false ;
17664: LD_INT 0
17666: IFFALSE 17650
// end ; end_of_file
17668: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17669: GO 17671
17671: DISABLE
// begin ru_radar := 98 ;
17672: LD_ADDR_EXP 41
17676: PUSH
17677: LD_INT 98
17679: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17680: LD_ADDR_EXP 42
17684: PUSH
17685: LD_INT 89
17687: ST_TO_ADDR
// us_hack := 99 ;
17688: LD_ADDR_EXP 43
17692: PUSH
17693: LD_INT 99
17695: ST_TO_ADDR
// us_artillery := 97 ;
17696: LD_ADDR_EXP 44
17700: PUSH
17701: LD_INT 97
17703: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17704: LD_ADDR_EXP 45
17708: PUSH
17709: LD_INT 91
17711: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
17712: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17713: LD_INT 0
17715: PPUSH
17716: PPUSH
17717: PPUSH
17718: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17719: LD_VAR 0 1
17723: PPUSH
17724: CALL_OW 264
17728: PUSH
17729: LD_EXP 45
17733: EQUAL
17734: IFFALSE 17806
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17736: LD_INT 68
17738: PPUSH
17739: LD_VAR 0 1
17743: PPUSH
17744: CALL_OW 255
17748: PPUSH
17749: CALL_OW 321
17753: PUSH
17754: LD_INT 2
17756: EQUAL
17757: IFFALSE 17769
// eff := 70 else
17759: LD_ADDR_VAR 0 6
17763: PUSH
17764: LD_INT 70
17766: ST_TO_ADDR
17767: GO 17777
// eff := 30 ;
17769: LD_ADDR_VAR 0 6
17773: PUSH
17774: LD_INT 30
17776: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17777: LD_VAR 0 1
17781: PPUSH
17782: CALL_OW 250
17786: PPUSH
17787: LD_VAR 0 1
17791: PPUSH
17792: CALL_OW 251
17796: PPUSH
17797: LD_VAR 0 6
17801: PPUSH
17802: CALL_OW 495
// end ; end ;
17806: LD_VAR 0 4
17810: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17811: LD_INT 0
17813: PPUSH
17814: PPUSH
17815: PPUSH
17816: PPUSH
17817: PPUSH
17818: PPUSH
// if cmd = 124 then
17819: LD_VAR 0 1
17823: PUSH
17824: LD_INT 124
17826: EQUAL
17827: IFFALSE 18033
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17829: LD_ADDR_VAR 0 5
17833: PUSH
17834: LD_INT 2
17836: PUSH
17837: LD_INT 34
17839: PUSH
17840: LD_INT 53
17842: PUSH
17843: EMPTY
17844: LIST
17845: LIST
17846: PUSH
17847: LD_INT 34
17849: PUSH
17850: LD_INT 14
17852: PUSH
17853: EMPTY
17854: LIST
17855: LIST
17856: PUSH
17857: EMPTY
17858: LIST
17859: LIST
17860: LIST
17861: PPUSH
17862: CALL_OW 69
17866: ST_TO_ADDR
// if not tmp then
17867: LD_VAR 0 5
17871: NOT
17872: IFFALSE 17876
// exit ;
17874: GO 18033
// for i in tmp do
17876: LD_ADDR_VAR 0 3
17880: PUSH
17881: LD_VAR 0 5
17885: PUSH
17886: FOR_IN
17887: IFFALSE 18031
// begin taskList := GetTaskList ( i ) ;
17889: LD_ADDR_VAR 0 6
17893: PUSH
17894: LD_VAR 0 3
17898: PPUSH
17899: CALL_OW 437
17903: ST_TO_ADDR
// if not taskList then
17904: LD_VAR 0 6
17908: NOT
17909: IFFALSE 17913
// continue ;
17911: GO 17886
// for j = 1 to taskList do
17913: LD_ADDR_VAR 0 4
17917: PUSH
17918: DOUBLE
17919: LD_INT 1
17921: DEC
17922: ST_TO_ADDR
17923: LD_VAR 0 6
17927: PUSH
17928: FOR_TO
17929: IFFALSE 18027
// if taskList [ j ] [ 1 ] = | then
17931: LD_VAR 0 6
17935: PUSH
17936: LD_VAR 0 4
17940: ARRAY
17941: PUSH
17942: LD_INT 1
17944: ARRAY
17945: PUSH
17946: LD_STRING |
17948: EQUAL
17949: IFFALSE 18025
// begin _taskList := Delete ( taskList , 1 ) ;
17951: LD_ADDR_VAR 0 7
17955: PUSH
17956: LD_VAR 0 6
17960: PPUSH
17961: LD_INT 1
17963: PPUSH
17964: CALL_OW 3
17968: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17969: LD_VAR 0 3
17973: PPUSH
17974: LD_VAR 0 7
17978: PPUSH
17979: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17983: LD_VAR 0 3
17987: PPUSH
17988: LD_VAR 0 6
17992: PUSH
17993: LD_VAR 0 4
17997: ARRAY
17998: PUSH
17999: LD_INT 2
18001: ARRAY
18002: PPUSH
18003: LD_VAR 0 6
18007: PUSH
18008: LD_VAR 0 4
18012: ARRAY
18013: PUSH
18014: LD_INT 3
18016: ARRAY
18017: PPUSH
18018: LD_INT 8
18020: PPUSH
18021: CALL 18038 0 4
// end ;
18025: GO 17928
18027: POP
18028: POP
// end ;
18029: GO 17886
18031: POP
18032: POP
// end ; end ;
18033: LD_VAR 0 2
18037: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18038: LD_INT 0
18040: PPUSH
18041: PPUSH
18042: PPUSH
18043: PPUSH
18044: PPUSH
18045: PPUSH
18046: PPUSH
18047: PPUSH
18048: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18049: LD_VAR 0 1
18053: NOT
18054: PUSH
18055: LD_VAR 0 2
18059: PPUSH
18060: LD_VAR 0 3
18064: PPUSH
18065: CALL_OW 488
18069: NOT
18070: OR
18071: PUSH
18072: LD_VAR 0 4
18076: NOT
18077: OR
18078: IFFALSE 18082
// exit ;
18080: GO 18422
// list := [ ] ;
18082: LD_ADDR_VAR 0 13
18086: PUSH
18087: EMPTY
18088: ST_TO_ADDR
// if x - r < 0 then
18089: LD_VAR 0 2
18093: PUSH
18094: LD_VAR 0 4
18098: MINUS
18099: PUSH
18100: LD_INT 0
18102: LESS
18103: IFFALSE 18115
// min_x := 0 else
18105: LD_ADDR_VAR 0 7
18109: PUSH
18110: LD_INT 0
18112: ST_TO_ADDR
18113: GO 18131
// min_x := x - r ;
18115: LD_ADDR_VAR 0 7
18119: PUSH
18120: LD_VAR 0 2
18124: PUSH
18125: LD_VAR 0 4
18129: MINUS
18130: ST_TO_ADDR
// if y - r < 0 then
18131: LD_VAR 0 3
18135: PUSH
18136: LD_VAR 0 4
18140: MINUS
18141: PUSH
18142: LD_INT 0
18144: LESS
18145: IFFALSE 18157
// min_y := 0 else
18147: LD_ADDR_VAR 0 8
18151: PUSH
18152: LD_INT 0
18154: ST_TO_ADDR
18155: GO 18173
// min_y := y - r ;
18157: LD_ADDR_VAR 0 8
18161: PUSH
18162: LD_VAR 0 3
18166: PUSH
18167: LD_VAR 0 4
18171: MINUS
18172: ST_TO_ADDR
// max_x := x + r ;
18173: LD_ADDR_VAR 0 9
18177: PUSH
18178: LD_VAR 0 2
18182: PUSH
18183: LD_VAR 0 4
18187: PLUS
18188: ST_TO_ADDR
// max_y := y + r ;
18189: LD_ADDR_VAR 0 10
18193: PUSH
18194: LD_VAR 0 3
18198: PUSH
18199: LD_VAR 0 4
18203: PLUS
18204: ST_TO_ADDR
// for _x = min_x to max_x do
18205: LD_ADDR_VAR 0 11
18209: PUSH
18210: DOUBLE
18211: LD_VAR 0 7
18215: DEC
18216: ST_TO_ADDR
18217: LD_VAR 0 9
18221: PUSH
18222: FOR_TO
18223: IFFALSE 18340
// for _y = min_y to max_y do
18225: LD_ADDR_VAR 0 12
18229: PUSH
18230: DOUBLE
18231: LD_VAR 0 8
18235: DEC
18236: ST_TO_ADDR
18237: LD_VAR 0 10
18241: PUSH
18242: FOR_TO
18243: IFFALSE 18336
// begin if not ValidHex ( _x , _y ) then
18245: LD_VAR 0 11
18249: PPUSH
18250: LD_VAR 0 12
18254: PPUSH
18255: CALL_OW 488
18259: NOT
18260: IFFALSE 18264
// continue ;
18262: GO 18242
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18264: LD_VAR 0 11
18268: PPUSH
18269: LD_VAR 0 12
18273: PPUSH
18274: CALL_OW 351
18278: PUSH
18279: LD_VAR 0 11
18283: PPUSH
18284: LD_VAR 0 12
18288: PPUSH
18289: CALL_OW 554
18293: AND
18294: IFFALSE 18334
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18296: LD_ADDR_VAR 0 13
18300: PUSH
18301: LD_VAR 0 13
18305: PPUSH
18306: LD_VAR 0 13
18310: PUSH
18311: LD_INT 1
18313: PLUS
18314: PPUSH
18315: LD_VAR 0 11
18319: PUSH
18320: LD_VAR 0 12
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PPUSH
18329: CALL_OW 2
18333: ST_TO_ADDR
// end ;
18334: GO 18242
18336: POP
18337: POP
18338: GO 18222
18340: POP
18341: POP
// if not list then
18342: LD_VAR 0 13
18346: NOT
18347: IFFALSE 18351
// exit ;
18349: GO 18422
// for i in list do
18351: LD_ADDR_VAR 0 6
18355: PUSH
18356: LD_VAR 0 13
18360: PUSH
18361: FOR_IN
18362: IFFALSE 18420
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18364: LD_VAR 0 1
18368: PPUSH
18369: LD_STRING M
18371: PUSH
18372: LD_VAR 0 6
18376: PUSH
18377: LD_INT 1
18379: ARRAY
18380: PUSH
18381: LD_VAR 0 6
18385: PUSH
18386: LD_INT 2
18388: ARRAY
18389: PUSH
18390: LD_INT 0
18392: PUSH
18393: LD_INT 0
18395: PUSH
18396: LD_INT 0
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: EMPTY
18403: LIST
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: LIST
18409: LIST
18410: PUSH
18411: EMPTY
18412: LIST
18413: PPUSH
18414: CALL_OW 447
18418: GO 18361
18420: POP
18421: POP
// end ;
18422: LD_VAR 0 5
18426: RET
