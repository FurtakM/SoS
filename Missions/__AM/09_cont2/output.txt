// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13527 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2807 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// tmp := tmp diff 0 ;
2391: LD_ADDR_VAR 0 4
2395: PUSH
2396: LD_VAR 0 4
2400: PUSH
2401: LD_INT 0
2403: DIFF
2404: ST_TO_ADDR
// if debug then
2405: LD_EXP 2
2409: IFFALSE 2460
// begin for i = 1 to 6 do
2411: LD_ADDR_VAR 0 2
2415: PUSH
2416: DOUBLE
2417: LD_INT 1
2419: DEC
2420: ST_TO_ADDR
2421: LD_INT 6
2423: PUSH
2424: FOR_TO
2425: IFFALSE 2458
// begin PrepareHuman ( false , 1 , 6 ) ;
2427: LD_INT 0
2429: PPUSH
2430: LD_INT 1
2432: PPUSH
2433: LD_INT 6
2435: PPUSH
2436: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2440: LD_ADDR_VAR 0 4
2444: PUSH
2445: LD_VAR 0 4
2449: PUSH
2450: CALL_OW 44
2454: ADD
2455: ST_TO_ADDR
// end ;
2456: GO 2424
2458: POP
2459: POP
// end ; for i in tmp do
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 4
2469: PUSH
2470: FOR_IN
2471: IFFALSE 2530
// begin if GetClass ( i ) in [ 2 , 3 ] then
2473: LD_VAR 0 2
2477: PPUSH
2478: CALL_OW 257
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: LD_INT 3
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: IN
2493: IFFALSE 2507
// SetClass ( i , 1 ) ;
2495: LD_VAR 0 2
2499: PPUSH
2500: LD_INT 1
2502: PPUSH
2503: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2507: LD_VAR 0 2
2511: PPUSH
2512: LD_INT 106
2514: PPUSH
2515: LD_INT 122
2517: PPUSH
2518: LD_INT 5
2520: PPUSH
2521: LD_INT 0
2523: PPUSH
2524: CALL_OW 50
// end ;
2528: GO 2470
2530: POP
2531: POP
// tmp := tmp diff Gary ;
2532: LD_ADDR_VAR 0 4
2536: PUSH
2537: LD_VAR 0 4
2541: PUSH
2542: LD_EXP 22
2546: DIFF
2547: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2548: LD_ADDR_VAR 0 3
2552: PUSH
2553: LD_INT 22
2555: PUSH
2556: LD_INT 4
2558: PUSH
2559: EMPTY
2560: LIST
2561: LIST
2562: PUSH
2563: LD_INT 30
2565: PUSH
2566: LD_INT 31
2568: PUSH
2569: EMPTY
2570: LIST
2571: LIST
2572: PUSH
2573: EMPTY
2574: LIST
2575: LIST
2576: PPUSH
2577: CALL_OW 69
2581: ST_TO_ADDR
// for i = 1 to b do
2582: LD_ADDR_VAR 0 2
2586: PUSH
2587: DOUBLE
2588: LD_INT 1
2590: DEC
2591: ST_TO_ADDR
2592: LD_VAR 0 3
2596: PUSH
2597: FOR_TO
2598: IFFALSE 2628
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2600: LD_VAR 0 4
2604: PUSH
2605: LD_VAR 0 2
2609: ARRAY
2610: PPUSH
2611: LD_VAR 0 3
2615: PUSH
2616: LD_VAR 0 2
2620: ARRAY
2621: PPUSH
2622: CALL_OW 120
// end ;
2626: GO 2597
2628: POP
2629: POP
// InitHc ;
2630: CALL_OW 19
// InitUc ;
2634: CALL_OW 18
// end ;
2638: LD_VAR 0 1
2642: RET
// export function PowellTransport ; var i , un ; begin
2643: LD_INT 0
2645: PPUSH
2646: PPUSH
2647: PPUSH
// uc_side := 4 ;
2648: LD_ADDR_OWVAR 20
2652: PUSH
2653: LD_INT 4
2655: ST_TO_ADDR
// uc_nation := 1 ;
2656: LD_ADDR_OWVAR 21
2660: PUSH
2661: LD_INT 1
2663: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2664: LD_INT 1
2666: PPUSH
2667: LD_INT 3
2669: PPUSH
2670: LD_INT 6
2672: PPUSH
2673: CALL_OW 380
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2685: LD_ADDR_OWVAR 33
2689: PUSH
2690: LD_STRING SecondCharsGal
2692: ST_TO_ADDR
// hc_face_number := 30 ;
2693: LD_ADDR_OWVAR 34
2697: PUSH
2698: LD_INT 30
2700: ST_TO_ADDR
// powell_trans := CreateHuman ;
2701: LD_ADDR_EXP 27
2705: PUSH
2706: CALL_OW 44
2710: ST_TO_ADDR
// hc_face_number := 31 ;
2711: LD_ADDR_OWVAR 34
2715: PUSH
2716: LD_INT 31
2718: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2719: LD_ADDR_EXP 27
2723: PUSH
2724: LD_EXP 27
2728: PUSH
2729: CALL_OW 44
2733: ADD
2734: ST_TO_ADDR
// for i = 1 to 2 do
2735: LD_ADDR_VAR 0 2
2739: PUSH
2740: DOUBLE
2741: LD_INT 1
2743: DEC
2744: ST_TO_ADDR
2745: LD_INT 2
2747: PUSH
2748: FOR_TO
2749: IFFALSE 2800
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2751: LD_ADDR_VAR 0 3
2755: PUSH
2756: LD_INT 4
2758: PPUSH
2759: LD_INT 1
2761: PPUSH
2762: LD_INT 3
2764: PPUSH
2765: LD_INT 1
2767: PPUSH
2768: LD_INT 1
2770: PPUSH
2771: LD_INT 12
2773: PPUSH
2774: LD_INT 66
2776: PPUSH
2777: CALL 423 0 7
2781: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2782: LD_ADDR_EXP 27
2786: PUSH
2787: LD_EXP 27
2791: PUSH
2792: LD_VAR 0 3
2796: ADD
2797: ST_TO_ADDR
// end ;
2798: GO 2748
2800: POP
2801: POP
// end ; end_of_file
2802: LD_VAR 0 1
2806: RET
// export function Action ; var i , veh ; begin
2807: LD_INT 0
2809: PPUSH
2810: PPUSH
2811: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2812: LD_EXP 26
2816: PPUSH
2817: LD_INT 0
2819: PPUSH
2820: LD_INT 50
2822: PPUSH
2823: LD_INT 38
2825: PPUSH
2826: LD_INT 2
2828: PPUSH
2829: CALL_OW 145
// InGameOn ;
2833: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2837: LD_INT 43
2839: PPUSH
2840: LD_INT 9
2842: PPUSH
2843: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2847: LD_EXP 21
2851: PPUSH
2852: LD_INT 54
2854: PPUSH
2855: LD_INT 34
2857: PPUSH
2858: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2862: LD_EXP 21
2866: PPUSH
2867: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2871: LD_EXP 21
2875: PPUSH
2876: LD_EXP 26
2880: PUSH
2881: LD_INT 1
2883: ARRAY
2884: PPUSH
2885: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2889: LD_INT 35
2891: PPUSH
2892: CALL_OW 67
// until See ( 4 , JMM ) ;
2896: LD_INT 4
2898: PPUSH
2899: LD_EXP 21
2903: PPUSH
2904: CALL_OW 292
2908: IFFALSE 2889
// CenterNowOnUnits ( JMM ) ;
2910: LD_EXP 21
2914: PPUSH
2915: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2919: LD_EXP 21
2923: PPUSH
2924: LD_STRING D2-JMM-1
2926: PPUSH
2927: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2931: LD_EXP 26
2935: PUSH
2936: LD_INT 3
2938: ARRAY
2939: PPUSH
2940: LD_EXP 21
2944: PPUSH
2945: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2949: LD_EXP 26
2953: PUSH
2954: LD_INT 3
2956: ARRAY
2957: PPUSH
2958: LD_STRING D2-Eng1-1
2960: PPUSH
2961: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2965: LD_EXP 21
2969: PPUSH
2970: LD_STRING D2-JMM-2
2972: PPUSH
2973: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2977: LD_EXP 26
2981: PUSH
2982: LD_INT 3
2984: ARRAY
2985: PPUSH
2986: LD_STRING D2-Eng1-2
2988: PPUSH
2989: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2993: LD_EXP 21
2997: PPUSH
2998: LD_STRING D2-JMM-3
3000: PPUSH
3001: CALL_OW 88
// if Houten then
3005: LD_EXP 25
3009: IFFALSE 3207
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3011: LD_ADDR_VAR 0 3
3015: PUSH
3016: LD_INT 4
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 3
3024: PPUSH
3025: LD_INT 2
3027: PPUSH
3028: LD_INT 1
3030: PPUSH
3031: LD_INT 4
3033: PPUSH
3034: LD_INT 55
3036: PPUSH
3037: CALL 423 0 7
3041: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3042: LD_VAR 0 3
3046: PPUSH
3047: LD_INT 3
3049: PPUSH
3050: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3054: LD_VAR 0 3
3058: PPUSH
3059: LD_INT 46
3061: PPUSH
3062: LD_INT 19
3064: PPUSH
3065: LD_INT 0
3067: PPUSH
3068: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3072: LD_EXP 25
3076: PPUSH
3077: LD_VAR 0 3
3081: PPUSH
3082: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3086: LD_EXP 25
3090: PPUSH
3091: LD_INT 49
3093: PPUSH
3094: LD_INT 33
3096: PPUSH
3097: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3101: LD_EXP 25
3105: PPUSH
3106: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3110: LD_EXP 25
3114: PPUSH
3115: LD_EXP 21
3119: PPUSH
3120: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3124: LD_INT 35
3126: PPUSH
3127: CALL_OW 67
// until See ( 1 , Houten ) ;
3131: LD_INT 1
3133: PPUSH
3134: LD_EXP 25
3138: PPUSH
3139: CALL_OW 292
3143: IFFALSE 3124
// ComTurnUnit ( JMM , Houten ) ;
3145: LD_EXP 21
3149: PPUSH
3150: LD_EXP 25
3154: PPUSH
3155: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3159: LD_EXP 21
3163: PPUSH
3164: LD_STRING D1d-JMM-1
3166: PPUSH
3167: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3171: LD_EXP 25
3175: PPUSH
3176: LD_STRING D1-VanH-1
3178: PPUSH
3179: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3183: LD_EXP 21
3187: PPUSH
3188: LD_STRING D1-JMM-1v
3190: PPUSH
3191: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3195: LD_EXP 21
3199: PPUSH
3200: LD_STRING D1-JMM-2v
3202: PPUSH
3203: CALL_OW 88
// end ; InGameOff ;
3207: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3211: LD_STRING M1
3213: PPUSH
3214: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3218: LD_INT 22
3220: PUSH
3221: LD_INT 4
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: LD_INT 92
3230: PUSH
3231: LD_EXP 21
3235: PPUSH
3236: CALL_OW 250
3240: PUSH
3241: LD_EXP 21
3245: PPUSH
3246: CALL_OW 251
3250: PUSH
3251: LD_INT 15
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: PPUSH
3264: CALL_OW 69
3268: PPUSH
3269: LD_INT 1
3271: PPUSH
3272: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3276: LD_EXP 26
3280: PUSH
3281: LD_EXP 21
3285: ADD
3286: PUSH
3287: LD_EXP 25
3291: ADD
3292: PPUSH
3293: CALL_OW 141
// end ;
3297: LD_VAR 0 1
3301: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3302: LD_INT 1
3304: PPUSH
3305: LD_EXP 22
3309: PPUSH
3310: CALL_OW 292
3314: PUSH
3315: LD_EXP 21
3319: PPUSH
3320: LD_EXP 22
3324: PPUSH
3325: CALL_OW 296
3329: PUSH
3330: LD_INT 6
3332: LESS
3333: AND
3334: IFFALSE 4207
3336: GO 3338
3338: DISABLE
3339: LD_INT 0
3341: PPUSH
3342: PPUSH
3343: PPUSH
3344: PPUSH
3345: PPUSH
// begin InGameOn ;
3346: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3350: LD_INT 22
3352: PUSH
3353: LD_INT 4
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PPUSH
3360: CALL_OW 69
3364: PPUSH
3365: LD_INT 1
3367: PPUSH
3368: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3372: LD_ADDR_VAR 0 4
3376: PUSH
3377: LD_INT 22
3379: PUSH
3380: LD_INT 1
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 2
3389: PUSH
3390: LD_INT 25
3392: PUSH
3393: LD_INT 1
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: PUSH
3400: LD_INT 25
3402: PUSH
3403: LD_INT 2
3405: PUSH
3406: EMPTY
3407: LIST
3408: LIST
3409: PUSH
3410: LD_INT 25
3412: PUSH
3413: LD_INT 3
3415: PUSH
3416: EMPTY
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 25
3422: PUSH
3423: LD_INT 4
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: PUSH
3430: EMPTY
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: PPUSH
3441: CALL_OW 69
3445: ST_TO_ADDR
// ComHold ( tmp ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3455: LD_EXP 21
3459: PPUSH
3460: LD_STRING D2-JMM-3a
3462: PPUSH
3463: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3467: LD_EXP 22
3471: PPUSH
3472: LD_EXP 21
3476: PPUSH
3477: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3481: LD_EXP 22
3485: PPUSH
3486: LD_STRING D2-Gary-3
3488: PPUSH
3489: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3493: LD_EXP 21
3497: PPUSH
3498: LD_EXP 22
3502: PPUSH
3503: CALL_OW 119
// for i in tmp do
3507: LD_ADDR_VAR 0 5
3511: PUSH
3512: LD_VAR 0 4
3516: PUSH
3517: FOR_IN
3518: IFFALSE 3563
// begin if IsInUnit ( i ) then
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 310
3529: IFFALSE 3540
// ComExitBuilding ( i ) ;
3531: LD_VAR 0 5
3535: PPUSH
3536: CALL_OW 122
// wait ( 1 ) ;
3540: LD_INT 1
3542: PPUSH
3543: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3547: LD_VAR 0 5
3551: PPUSH
3552: LD_EXP 21
3556: PPUSH
3557: CALL_OW 119
// end ;
3561: GO 3517
3563: POP
3564: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3565: LD_ADDR_VAR 0 4
3569: PUSH
3570: LD_VAR 0 4
3574: PUSH
3575: LD_EXP 21
3579: PUSH
3580: LD_EXP 25
3584: PUSH
3585: LD_EXP 22
3589: PUSH
3590: LD_EXP 24
3594: PUSH
3595: LD_EXP 23
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: PUSH
3607: LD_EXP 26
3611: ADD
3612: DIFF
3613: ST_TO_ADDR
// if Bobby then
3614: LD_EXP 23
3618: IFFALSE 3632
// Say ( Bobby , D2-Bobby-3 ) ;
3620: LD_EXP 23
3624: PPUSH
3625: LD_STRING D2-Bobby-3
3627: PPUSH
3628: CALL_OW 88
// if Cyrus then
3632: LD_EXP 24
3636: IFFALSE 3650
// Say ( Cyrus , D2-Cyrus-3 ) ;
3638: LD_EXP 24
3642: PPUSH
3643: LD_STRING D2-Cyrus-3
3645: PPUSH
3646: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3650: LD_EXP 21
3654: PPUSH
3655: LD_STRING D2-JMM-4
3657: PPUSH
3658: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3662: LD_EXP 22
3666: PPUSH
3667: LD_STRING D2-Gary-4
3669: PPUSH
3670: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3674: LD_ADDR_VAR 0 1
3678: PUSH
3679: LD_VAR 0 4
3683: PPUSH
3684: LD_INT 26
3686: PUSH
3687: LD_INT 1
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: PPUSH
3694: CALL_OW 72
3698: PUSH
3699: LD_INT 1
3701: ARRAY
3702: ST_TO_ADDR
// if Cyrus then
3703: LD_EXP 24
3707: IFFALSE 3723
// Say ( Cyrus , D2-Cyrus-4 ) else
3709: LD_EXP 24
3713: PPUSH
3714: LD_STRING D2-Cyrus-4
3716: PPUSH
3717: CALL_OW 88
3721: GO 3735
// Say ( un1 , D2-Sol1-4 ) ;
3723: LD_VAR 0 1
3727: PPUSH
3728: LD_STRING D2-Sol1-4
3730: PPUSH
3731: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3735: LD_EXP 21
3739: PPUSH
3740: LD_STRING D2-JMM-5
3742: PPUSH
3743: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3747: LD_ADDR_VAR 0 2
3751: PUSH
3752: LD_EXP 26
3756: PPUSH
3757: LD_INT 91
3759: PUSH
3760: LD_EXP 21
3764: PUSH
3765: LD_INT 10
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 26
3775: PUSH
3776: LD_INT 2
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 72
3791: ST_TO_ADDR
// if un2 then
3792: LD_VAR 0 2
3796: IFFALSE 3850
// begin un2 := un2 [ un2 ] ;
3798: LD_ADDR_VAR 0 2
3802: PUSH
3803: LD_VAR 0 2
3807: PUSH
3808: LD_VAR 0 2
3812: ARRAY
3813: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3814: LD_VAR 0 2
3818: PPUSH
3819: LD_STRING D2-FEng1-5
3821: PPUSH
3822: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3826: LD_EXP 21
3830: PPUSH
3831: LD_STRING D2-JMM-6
3833: PPUSH
3834: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3838: LD_VAR 0 2
3842: PPUSH
3843: LD_STRING D2-FEng1-6
3845: PPUSH
3846: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3850: LD_ADDR_VAR 0 3
3854: PUSH
3855: LD_EXP 26
3859: PPUSH
3860: LD_INT 91
3862: PUSH
3863: LD_EXP 21
3867: PUSH
3868: LD_INT 10
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 26
3878: PUSH
3879: LD_INT 1
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PPUSH
3890: CALL_OW 72
3894: ST_TO_ADDR
// if un3 then
3895: LD_VAR 0 3
3899: IFFALSE 3954
// begin un3 := un3 [ 1 ] ;
3901: LD_ADDR_VAR 0 3
3905: PUSH
3906: LD_VAR 0 3
3910: PUSH
3911: LD_INT 1
3913: ARRAY
3914: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3915: LD_VAR 0 3
3919: PPUSH
3920: LD_INT 114
3922: PPUSH
3923: LD_INT 122
3925: PPUSH
3926: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3930: LD_VAR 0 3
3934: PPUSH
3935: LD_STRING D2-Eng1-6
3937: PPUSH
3938: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3942: LD_EXP 21
3946: PPUSH
3947: LD_STRING D2-JMM-7
3949: PPUSH
3950: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3954: LD_EXP 22
3958: PPUSH
3959: LD_STRING D2-Gary-7
3961: PPUSH
3962: CALL_OW 88
// if un2 then
3966: LD_VAR 0 2
3970: IFFALSE 3984
// Say ( un2 , D2-FEng1-7 ) ;
3972: LD_VAR 0 2
3976: PPUSH
3977: LD_STRING D2-FEng1-7
3979: PPUSH
3980: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3984: LD_VAR 0 1
3988: PPUSH
3989: LD_STRING D2-Sol1-7
3991: PPUSH
3992: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3996: LD_EXP 21
4000: PPUSH
4001: LD_STRING D2-JMM-8
4003: PPUSH
4004: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4008: LD_INT 22
4010: PUSH
4011: LD_INT 1
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: CALL_OW 69
4022: PPUSH
4023: CALL_OW 141
// InGameOff ;
4027: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4031: LD_STRING M1a
4033: PPUSH
4034: CALL_OW 337
// jmm_in_ovsyenko := true ;
4038: LD_ADDR_EXP 4
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// if debug then
4046: LD_EXP 2
4050: IFFALSE 4156
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4052: LD_INT 22
4054: PUSH
4055: LD_INT 1
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: PUSH
4062: LD_INT 30
4064: PUSH
4065: LD_INT 0
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PPUSH
4076: CALL_OW 69
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: PPUSH
4085: CALL_OW 274
4089: PPUSH
4090: LD_INT 2
4092: PPUSH
4093: LD_INT 1000
4095: PPUSH
4096: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4100: LD_INT 22
4102: PUSH
4103: LD_INT 1
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: LD_INT 30
4112: PUSH
4113: LD_INT 0
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: PUSH
4120: EMPTY
4121: LIST
4122: LIST
4123: PPUSH
4124: CALL_OW 69
4128: PUSH
4129: LD_INT 1
4131: ARRAY
4132: PPUSH
4133: CALL_OW 274
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 1000
4143: PPUSH
4144: CALL_OW 277
// ar_can_arrive := true ;
4148: LD_ADDR_EXP 10
4152: PUSH
4153: LD_INT 1
4155: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4156: LD_INT 1050
4158: PPUSH
4159: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4163: LD_ADDR_VAR 0 4
4167: PUSH
4168: LD_INT 25
4170: PUSH
4171: LD_INT 14
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: ST_TO_ADDR
// if not tmp then
4183: LD_VAR 0 4
4187: NOT
4188: IFFALSE 4192
// exit ;
4190: GO 4207
// ComMoveXY ( tmp , 75 , 75 ) ;
4192: LD_VAR 0 4
4196: PPUSH
4197: LD_INT 75
4199: PPUSH
4200: LD_INT 75
4202: PPUSH
4203: CALL_OW 111
// end ;
4207: PPOPN 5
4209: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4210: LD_INT 22
4212: PUSH
4213: LD_INT 1
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_INT 30
4222: PUSH
4223: LD_INT 30
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: PUSH
4230: LD_INT 3
4232: PUSH
4233: LD_INT 57
4235: PUSH
4236: EMPTY
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: LIST
4247: PPUSH
4248: CALL_OW 69
4252: IFFALSE 4294
4254: GO 4256
4256: DISABLE
4257: LD_INT 0
4259: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4260: LD_ADDR_VAR 0 1
4264: PUSH
4265: LD_STRING M2easy
4267: PUSH
4268: LD_STRING M2
4270: PUSH
4271: LD_STRING M2hard
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: LIST
4278: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4279: LD_VAR 0 1
4283: PUSH
4284: LD_OWVAR 67
4288: ARRAY
4289: PPUSH
4290: CALL_OW 337
// end ;
4294: PPOPN 1
4296: END
// every 3 3$00 do
4297: GO 4299
4299: DISABLE
// begin DialogueOn ;
4300: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4304: LD_EXP 28
4308: PPUSH
4309: LD_STRING D3-Pow-1
4311: PPUSH
4312: CALL_OW 94
// if jmm_in_ovsyenko then
4316: LD_EXP 4
4320: IFFALSE 4348
// begin Say ( JMM , D3-JMM-1 ) ;
4322: LD_EXP 21
4326: PPUSH
4327: LD_STRING D3-JMM-1
4329: PPUSH
4330: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4334: LD_EXP 21
4338: PPUSH
4339: LD_STRING D3-JMM-1b
4341: PPUSH
4342: CALL_OW 88
// end else
4346: GO 4360
// Say ( JMM , D3-JMM-1a ) ;
4348: LD_EXP 21
4352: PPUSH
4353: LD_STRING D3-JMM-1a
4355: PPUSH
4356: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4360: LD_EXP 28
4364: PPUSH
4365: LD_STRING D3-Pow-2
4367: PPUSH
4368: CALL_OW 94
// DialogueOff ;
4372: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4376: LD_STRING M3
4378: PPUSH
4379: CALL_OW 337
// powell_want_sib := true ;
4383: LD_ADDR_EXP 5
4387: PUSH
4388: LD_INT 1
4390: ST_TO_ADDR
// end ;
4391: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4392: LD_EXP 6
4396: PUSH
4397: LD_INT 0
4399: EQUAL
4400: IFFALSE 5861
4402: GO 4404
4404: DISABLE
4405: LD_INT 0
4407: PPUSH
4408: PPUSH
4409: PPUSH
4410: PPUSH
4411: PPUSH
4412: PPUSH
4413: PPUSH
4414: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4415: LD_INT 4
4417: PPUSH
4418: LD_INT 1
4420: PPUSH
4421: CALL_OW 343
// PowellTransport ;
4425: CALL 2643 0 0
// for i = 1 to 3 do
4429: LD_ADDR_VAR 0 4
4433: PUSH
4434: DOUBLE
4435: LD_INT 1
4437: DEC
4438: ST_TO_ADDR
4439: LD_INT 3
4441: PUSH
4442: FOR_TO
4443: IFFALSE 4510
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4445: LD_ADDR_VAR 0 1
4449: PUSH
4450: LD_INT 6
4452: PPUSH
4453: LD_VAR 0 4
4457: PPUSH
4458: CALL_OW 287
4462: ST_TO_ADDR
// if not tmp then
4463: LD_VAR 0 1
4467: NOT
4468: IFFALSE 4472
// continue ;
4470: GO 4442
// EraseResourceArea ( terminalArea , i ) ;
4472: LD_INT 6
4474: PPUSH
4475: LD_VAR 0 4
4479: PPUSH
4480: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4484: LD_EXP 3
4488: PPUSH
4489: CALL_OW 274
4493: PPUSH
4494: LD_VAR 0 4
4498: PPUSH
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 276
// end ;
4508: GO 4442
4510: POP
4511: POP
// x := 43 ;
4512: LD_ADDR_VAR 0 2
4516: PUSH
4517: LD_INT 43
4519: ST_TO_ADDR
// y := 3 ;
4520: LD_ADDR_VAR 0 3
4524: PUSH
4525: LD_INT 3
4527: ST_TO_ADDR
// for i = 3 to 4 do
4528: LD_ADDR_VAR 0 4
4532: PUSH
4533: DOUBLE
4534: LD_INT 3
4536: DEC
4537: ST_TO_ADDR
4538: LD_INT 4
4540: PUSH
4541: FOR_TO
4542: IFFALSE 4733
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4544: LD_EXP 27
4548: PUSH
4549: LD_VAR 0 4
4553: ARRAY
4554: PPUSH
4555: LD_INT 4
4557: PPUSH
4558: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4562: LD_EXP 27
4566: PUSH
4567: LD_VAR 0 4
4571: ARRAY
4572: PPUSH
4573: LD_VAR 0 2
4577: PPUSH
4578: LD_VAR 0 3
4582: PPUSH
4583: LD_INT 0
4585: PPUSH
4586: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4590: LD_EXP 27
4594: PUSH
4595: LD_VAR 0 4
4599: PUSH
4600: LD_INT 2
4602: MINUS
4603: ARRAY
4604: PPUSH
4605: LD_EXP 27
4609: PUSH
4610: LD_VAR 0 4
4614: ARRAY
4615: PPUSH
4616: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4620: LD_EXP 27
4624: PUSH
4625: LD_VAR 0 4
4629: ARRAY
4630: PPUSH
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 100
4636: PPUSH
4637: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4641: LD_EXP 27
4645: PUSH
4646: LD_VAR 0 4
4650: PUSH
4651: LD_INT 2
4653: MINUS
4654: ARRAY
4655: PPUSH
4656: LD_INT 54
4658: PPUSH
4659: LD_INT 42
4661: PPUSH
4662: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4666: LD_EXP 27
4670: PUSH
4671: LD_VAR 0 4
4675: PUSH
4676: LD_INT 2
4678: MINUS
4679: ARRAY
4680: PPUSH
4681: LD_EXP 3
4685: PPUSH
4686: CALL_OW 250
4690: PPUSH
4691: LD_EXP 3
4695: PPUSH
4696: CALL_OW 251
4700: PPUSH
4701: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4705: LD_EXP 27
4709: PUSH
4710: LD_VAR 0 4
4714: PUSH
4715: LD_INT 2
4717: MINUS
4718: ARRAY
4719: PPUSH
4720: CALL_OW 200
// Wait ( 0 0$02 ) ;
4724: LD_INT 70
4726: PPUSH
4727: CALL_OW 67
// end ;
4731: GO 4541
4733: POP
4734: POP
// time := 0 0$20 ;
4735: LD_ADDR_VAR 0 8
4739: PUSH
4740: LD_INT 700
4742: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4743: LD_INT 35
4745: PPUSH
4746: CALL_OW 67
// time := time - 0 0$01 ;
4750: LD_ADDR_VAR 0 8
4754: PUSH
4755: LD_VAR 0 8
4759: PUSH
4760: LD_INT 35
4762: MINUS
4763: ST_TO_ADDR
// for i = 3 to 4 do
4764: LD_ADDR_VAR 0 4
4768: PUSH
4769: DOUBLE
4770: LD_INT 3
4772: DEC
4773: ST_TO_ADDR
4774: LD_INT 4
4776: PUSH
4777: FOR_TO
4778: IFFALSE 4913
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4780: LD_EXP 27
4784: PUSH
4785: LD_VAR 0 4
4789: ARRAY
4790: PPUSH
4791: LD_INT 1
4793: PPUSH
4794: CALL_OW 289
4798: PUSH
4799: LD_INT 0
4801: GREATER
4802: PUSH
4803: LD_EXP 27
4807: PUSH
4808: LD_VAR 0 4
4812: ARRAY
4813: PPUSH
4814: CALL_OW 314
4818: NOT
4819: AND
4820: IFFALSE 4911
// begin x := rand ( 0 , 5 ) ;
4822: LD_ADDR_VAR 0 2
4826: PUSH
4827: LD_INT 0
4829: PPUSH
4830: LD_INT 5
4832: PPUSH
4833: CALL_OW 12
4837: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4838: LD_EXP 27
4842: PUSH
4843: LD_VAR 0 4
4847: ARRAY
4848: PPUSH
4849: LD_EXP 27
4853: PUSH
4854: LD_VAR 0 4
4858: ARRAY
4859: PPUSH
4860: CALL_OW 250
4864: PPUSH
4865: LD_VAR 0 2
4869: PPUSH
4870: LD_INT 3
4872: PPUSH
4873: CALL_OW 272
4877: PPUSH
4878: LD_EXP 27
4882: PUSH
4883: LD_VAR 0 4
4887: ARRAY
4888: PPUSH
4889: CALL_OW 251
4893: PPUSH
4894: LD_VAR 0 2
4898: PPUSH
4899: LD_INT 3
4901: PPUSH
4902: CALL_OW 273
4906: PPUSH
4907: CALL_OW 171
// end ;
4911: GO 4777
4913: POP
4914: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4915: LD_EXP 27
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 54
4926: PPUSH
4927: LD_INT 42
4929: PPUSH
4930: CALL_OW 297
4934: PUSH
4935: LD_INT 4
4937: LESS
4938: PUSH
4939: LD_VAR 0 8
4943: PUSH
4944: LD_INT 0
4946: EQUAL
4947: OR
4948: IFFALSE 4743
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4950: LD_EXP 27
4954: PUSH
4955: LD_INT 3
4957: ARRAY
4958: PPUSH
4959: LD_INT 1
4961: PPUSH
4962: LD_INT 0
4964: PPUSH
4965: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4969: LD_EXP 27
4973: PUSH
4974: LD_INT 4
4976: ARRAY
4977: PPUSH
4978: LD_INT 1
4980: PPUSH
4981: LD_INT 0
4983: PPUSH
4984: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4988: LD_EXP 3
4992: PPUSH
4993: CALL_OW 274
4997: PPUSH
4998: LD_INT 1
5000: PPUSH
5001: LD_INT 200
5003: PPUSH
5004: CALL_OW 276
// DialogueOn ;
5008: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5012: LD_INT 53
5014: PPUSH
5015: LD_INT 35
5017: PPUSH
5018: CALL_OW 86
// un := powell_trans [ 1 ] ;
5022: LD_ADDR_VAR 0 5
5026: PUSH
5027: LD_EXP 27
5031: PUSH
5032: LD_INT 1
5034: ARRAY
5035: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5036: LD_VAR 0 5
5040: PPUSH
5041: LD_STRING D4-Mech1-1
5043: PPUSH
5044: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5048: LD_EXP 21
5052: PPUSH
5053: LD_STRING D4-JMM-1
5055: PPUSH
5056: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5060: LD_VAR 0 5
5064: PPUSH
5065: LD_STRING D4-Mech1-2
5067: PPUSH
5068: CALL_OW 88
// powell_happy := false ;
5072: LD_ADDR_VAR 0 6
5076: PUSH
5077: LD_INT 0
5079: ST_TO_ADDR
// take_cargo := false ;
5080: LD_ADDR_VAR 0 7
5084: PUSH
5085: LD_INT 0
5087: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5088: CALL 943 0 0
5092: PUSH
5093: LD_INT 60
5095: GREATEREQUAL
5096: IFFALSE 5144
// begin Say ( JMM , D5-JMM-1 ) ;
5098: LD_EXP 21
5102: PPUSH
5103: LD_STRING D5-JMM-1
5105: PPUSH
5106: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5110: LD_VAR 0 5
5114: PPUSH
5115: LD_STRING D6-Mech1-1
5117: PPUSH
5118: CALL_OW 88
// powell_happy := true ;
5122: LD_ADDR_VAR 0 6
5126: PUSH
5127: LD_INT 1
5129: ST_TO_ADDR
// take_cargo := true ;
5130: LD_ADDR_VAR 0 7
5134: PUSH
5135: LD_INT 1
5137: ST_TO_ADDR
// DialogueOff ;
5138: CALL_OW 7
// end else
5142: GO 5378
// if GetTerminalCargo > 0 then
5144: CALL 943 0 0
5148: PUSH
5149: LD_INT 0
5151: GREATER
5152: IFFALSE 5350
// begin case Query ( QWait ) of 1 :
5154: LD_STRING QWait
5156: PPUSH
5157: CALL_OW 97
5161: PUSH
5162: LD_INT 1
5164: DOUBLE
5165: EQUAL
5166: IFTRUE 5170
5168: GO 5261
5170: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5171: LD_EXP 21
5175: PPUSH
5176: LD_STRING D5a-JMM-1
5178: PPUSH
5179: CALL_OW 88
// DialogueOff ;
5183: CALL_OW 7
// wait ( 5 5$00 ) ;
5187: LD_INT 10500
5189: PPUSH
5190: CALL_OW 67
// if GetTerminalCargo < 60 then
5194: CALL 943 0 0
5198: PUSH
5199: LD_INT 60
5201: LESS
5202: IFFALSE 5243
// begin DialogueOn ;
5204: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5208: LD_EXP 3
5212: PPUSH
5213: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5217: LD_VAR 0 5
5221: PPUSH
5222: LD_STRING D6-Mech1-1a
5224: PPUSH
5225: CALL_OW 88
// DialogueOff ;
5229: CALL_OW 7
// powell_happy := false ;
5233: LD_ADDR_VAR 0 6
5237: PUSH
5238: LD_INT 0
5240: ST_TO_ADDR
// end else
5241: GO 5259
// begin powell_happy := true ;
5243: LD_ADDR_VAR 0 6
5247: PUSH
5248: LD_INT 1
5250: ST_TO_ADDR
// take_cargo := true ;
5251: LD_ADDR_VAR 0 7
5255: PUSH
5256: LD_INT 1
5258: ST_TO_ADDR
// end ; end ; 2 :
5259: GO 5348
5261: LD_INT 2
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5308
5269: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5270: LD_EXP 21
5274: PPUSH
5275: LD_STRING D5b-JMM-1
5277: PPUSH
5278: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5282: LD_VAR 0 5
5286: PPUSH
5287: LD_STRING D6-Mech1-1a
5289: PPUSH
5290: CALL_OW 88
// DialogueOff ;
5294: CALL_OW 7
// take_cargo := true ;
5298: LD_ADDR_VAR 0 7
5302: PUSH
5303: LD_INT 1
5305: ST_TO_ADDR
// end ; 3 :
5306: GO 5348
5308: LD_INT 3
5310: DOUBLE
5311: EQUAL
5312: IFTRUE 5316
5314: GO 5347
5316: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5317: LD_EXP 21
5321: PPUSH
5322: LD_STRING D5c-JMM-1
5324: PPUSH
5325: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5329: LD_VAR 0 5
5333: PPUSH
5334: LD_STRING D6-Mech1-1b
5336: PPUSH
5337: CALL_OW 88
// DialogueOff ;
5341: CALL_OW 7
// end ; end ;
5345: GO 5348
5347: POP
// end else
5348: GO 5378
// begin Say ( JMM , D5c-JMM-1 ) ;
5350: LD_EXP 21
5354: PPUSH
5355: LD_STRING D5c-JMM-1
5357: PPUSH
5358: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5362: LD_VAR 0 5
5366: PPUSH
5367: LD_STRING D6-Mech1-1b
5369: PPUSH
5370: CALL_OW 88
// DialogueOff ;
5374: CALL_OW 7
// end ; if take_cargo then
5378: LD_VAR 0 7
5382: IFFALSE 5461
// begin x := GetTerminalCargo ;
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: CALL 943 0 0
5393: ST_TO_ADDR
// if x > 60 then
5394: LD_VAR 0 2
5398: PUSH
5399: LD_INT 60
5401: GREATER
5402: IFFALSE 5412
// x := 60 ;
5404: LD_ADDR_VAR 0 2
5408: PUSH
5409: LD_INT 60
5411: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5412: LD_EXP 3
5416: PPUSH
5417: CALL_OW 274
5421: PPUSH
5422: LD_INT 3
5424: PPUSH
5425: CALL 943 0 0
5429: PUSH
5430: LD_VAR 0 2
5434: MINUS
5435: PPUSH
5436: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5440: LD_EXP 27
5444: PUSH
5445: LD_INT 3
5447: ARRAY
5448: PPUSH
5449: LD_INT 3
5451: PPUSH
5452: LD_VAR 0 2
5456: PPUSH
5457: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5461: LD_EXP 27
5465: PPUSH
5466: LD_INT 43
5468: PPUSH
5469: LD_INT 3
5471: PPUSH
5472: CALL_OW 171
// x := 0 0$20 ;
5476: LD_ADDR_VAR 0 2
5480: PUSH
5481: LD_INT 700
5483: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5484: LD_INT 35
5486: PPUSH
5487: CALL_OW 67
// x := x - 0 0$01 ;
5491: LD_ADDR_VAR 0 2
5495: PUSH
5496: LD_VAR 0 2
5500: PUSH
5501: LD_INT 35
5503: MINUS
5504: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5505: LD_VAR 0 2
5509: PUSH
5510: LD_INT 0
5512: EQUAL
5513: PUSH
5514: LD_EXP 27
5518: PUSH
5519: LD_INT 3
5521: ARRAY
5522: PPUSH
5523: LD_INT 43
5525: PPUSH
5526: LD_INT 3
5528: PPUSH
5529: CALL_OW 297
5533: PUSH
5534: LD_INT 4
5536: LESS
5537: PUSH
5538: LD_EXP 27
5542: PUSH
5543: LD_INT 3
5545: ARRAY
5546: PPUSH
5547: LD_INT 43
5549: PPUSH
5550: LD_INT 3
5552: PPUSH
5553: CALL_OW 297
5557: PUSH
5558: LD_INT 4
5560: LESS
5561: AND
5562: OR
5563: IFFALSE 5484
// for i in powell_trans do
5565: LD_ADDR_VAR 0 4
5569: PUSH
5570: LD_EXP 27
5574: PUSH
5575: FOR_IN
5576: IFFALSE 5589
// RemoveUnit ( i ) ;
5578: LD_VAR 0 4
5582: PPUSH
5583: CALL_OW 64
5587: GO 5575
5589: POP
5590: POP
// if not powell_happy then
5591: LD_VAR 0 6
5595: NOT
5596: IFFALSE 5607
// powell_happy := - 1 ;
5598: LD_ADDR_VAR 0 6
5602: PUSH
5603: LD_INT 1
5605: NEG
5606: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5607: LD_STRING EarlySiberite
5609: PPUSH
5610: LD_VAR 0 6
5614: PPUSH
5615: CALL_OW 101
// if powell_happy then
5619: LD_VAR 0 6
5623: IFFALSE 5633
// earlySib := true ;
5625: LD_ADDR_EXP 19
5629: PUSH
5630: LD_INT 1
5632: ST_TO_ADDR
// if powell_happy then
5633: LD_VAR 0 6
5637: IFFALSE 5648
// ChangeMissionObjectives ( M3a ) else
5639: LD_STRING M3a
5641: PPUSH
5642: CALL_OW 337
5646: GO 5655
// ChangeMissionObjectives ( M3b ) ;
5648: LD_STRING M3b
5650: PPUSH
5651: CALL_OW 337
// ru_can_attack_terminal := true ;
5655: LD_ADDR_EXP 9
5659: PUSH
5660: LD_INT 1
5662: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5663: LD_INT 25200
5665: PPUSH
5666: CALL_OW 67
// time := 2 2$00 ;
5670: LD_ADDR_VAR 0 8
5674: PUSH
5675: LD_INT 4200
5677: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5678: LD_INT 35
5680: PPUSH
5681: CALL_OW 67
// time := time - 0 0$1 ;
5685: LD_ADDR_VAR 0 8
5689: PUSH
5690: LD_VAR 0 8
5694: PUSH
5695: LD_INT 35
5697: MINUS
5698: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5699: LD_EXP 8
5703: NOT
5704: PUSH
5705: LD_EXP 38
5709: PUSH
5710: LD_INT 0
5712: EQUAL
5713: OR
5714: PUSH
5715: LD_VAR 0 8
5719: PUSH
5720: LD_INT 0
5722: EQUAL
5723: OR
5724: IFFALSE 5678
// if ru_force then
5726: LD_EXP 38
5730: IFFALSE 5829
// for i in ru_force do
5732: LD_ADDR_VAR 0 4
5736: PUSH
5737: LD_EXP 38
5741: PUSH
5742: FOR_IN
5743: IFFALSE 5827
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5745: LD_INT 1
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL_OW 292
5757: NOT
5758: PUSH
5759: LD_VAR 0 4
5763: PPUSH
5764: LD_INT 81
5766: PUSH
5767: LD_INT 3
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 69
5778: PPUSH
5779: LD_VAR 0 4
5783: PPUSH
5784: CALL_OW 74
5788: PPUSH
5789: CALL_OW 296
5793: PUSH
5794: LD_INT 10
5796: GREATER
5797: AND
5798: IFFALSE 5825
// begin RemoveUnit ( i ) ;
5800: LD_VAR 0 4
5804: PPUSH
5805: CALL_OW 64
// ru_force := ru_force diff i ;
5809: LD_ADDR_EXP 38
5813: PUSH
5814: LD_EXP 38
5818: PUSH
5819: LD_VAR 0 4
5823: DIFF
5824: ST_TO_ADDR
// end ;
5825: GO 5742
5827: POP
5828: POP
// repeat wait ( 0 0$03 ) ;
5829: LD_INT 105
5831: PPUSH
5832: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5836: LD_EXP 8
5840: NOT
5841: PUSH
5842: LD_EXP 38
5846: PUSH
5847: LD_INT 3
5849: LESS
5850: OR
5851: IFFALSE 5829
// ar_can_arrive := true ;
5853: LD_ADDR_EXP 10
5857: PUSH
5858: LD_INT 1
5860: ST_TO_ADDR
// end ;
5861: PPOPN 8
5863: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5864: LD_INT 1
5866: PPUSH
5867: LD_INT 20
5869: PPUSH
5870: CALL_OW 325
5874: IFFALSE 6015
5876: GO 5878
5878: DISABLE
5879: LD_INT 0
5881: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5882: LD_ADDR_VAR 0 1
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: PUSH
5897: LD_INT 26
5899: PUSH
5900: LD_INT 1
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 25
5909: PUSH
5910: LD_INT 4
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: PPUSH
5922: CALL_OW 69
5926: PUSH
5927: LD_EXP 21
5931: PUSH
5932: LD_EXP 24
5936: PUSH
5937: LD_EXP 23
5941: PUSH
5942: LD_EXP 25
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: DIFF
5953: ST_TO_ADDR
// if not un then
5954: LD_VAR 0 1
5958: NOT
5959: IFFALSE 5963
// exit ;
5961: GO 6015
// DialogueOn ;
5963: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5967: LD_VAR 0 1
5971: PUSH
5972: LD_INT 1
5974: ARRAY
5975: PPUSH
5976: LD_STRING D13-Sci1-1
5978: PPUSH
5979: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5983: LD_EXP 21
5987: PPUSH
5988: LD_STRING D13-JMM-1
5990: PPUSH
5991: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5995: LD_VAR 0 1
5999: PUSH
6000: LD_INT 1
6002: ARRAY
6003: PPUSH
6004: LD_STRING D13-Sci1-2
6006: PPUSH
6007: CALL_OW 88
// DialogueOff ;
6011: CALL_OW 7
// end ;
6015: PPOPN 1
6017: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6018: LD_INT 1
6020: PPUSH
6021: CALL 974 0 1
6025: PUSH
6026: LD_INT 77
6028: GREATER
6029: PUSH
6030: LD_EXP 8
6034: NOT
6035: AND
6036: PUSH
6037: LD_INT 22
6039: PUSH
6040: LD_INT 1
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 25
6049: PUSH
6050: LD_INT 4
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: PUSH
6057: LD_INT 26
6059: PUSH
6060: LD_INT 1
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: LIST
6071: PPUSH
6072: CALL_OW 69
6076: PUSH
6077: LD_EXP 21
6081: PUSH
6082: LD_EXP 23
6086: PUSH
6087: LD_EXP 24
6091: PUSH
6092: LD_EXP 22
6096: PUSH
6097: LD_EXP 25
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: LIST
6108: DIFF
6109: AND
6110: IFFALSE 6288
6112: GO 6114
6114: DISABLE
6115: LD_INT 0
6117: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_INT 22
6125: PUSH
6126: LD_INT 1
6128: PUSH
6129: EMPTY
6130: LIST
6131: LIST
6132: PUSH
6133: LD_INT 25
6135: PUSH
6136: LD_INT 4
6138: PUSH
6139: EMPTY
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 26
6145: PUSH
6146: LD_INT 1
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: LIST
6157: PPUSH
6158: CALL_OW 69
6162: PUSH
6163: LD_EXP 21
6167: PUSH
6168: LD_EXP 23
6172: PUSH
6173: LD_EXP 24
6177: PUSH
6178: LD_EXP 22
6182: PUSH
6183: LD_EXP 25
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: LIST
6194: DIFF
6195: ST_TO_ADDR
// DialogueOn ;
6196: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6200: LD_VAR 0 1
6204: PUSH
6205: LD_INT 1
6207: ARRAY
6208: PPUSH
6209: LD_STRING D7-Sci1-1
6211: PPUSH
6212: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6216: LD_EXP 21
6220: PPUSH
6221: LD_STRING D7-JMM-1
6223: PPUSH
6224: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6228: LD_VAR 0 1
6232: PUSH
6233: LD_INT 1
6235: ARRAY
6236: PPUSH
6237: LD_STRING D7-Sci1-2
6239: PPUSH
6240: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6244: LD_EXP 21
6248: PPUSH
6249: LD_STRING D7-JMM-2
6251: PPUSH
6252: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6256: LD_VAR 0 1
6260: PUSH
6261: LD_INT 1
6263: ARRAY
6264: PPUSH
6265: LD_STRING D7-Sci1-3
6267: PPUSH
6268: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6272: LD_EXP 21
6276: PPUSH
6277: LD_STRING D7-JMM-3
6279: PPUSH
6280: CALL_OW 88
// DialogueOff ;
6284: CALL_OW 7
// end ;
6288: PPOPN 1
6290: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6291: LD_EXP 10
6295: IFFALSE 9918
6297: GO 6299
6299: DISABLE
6300: LD_INT 0
6302: PPUSH
6303: PPUSH
6304: PPUSH
6305: PPUSH
6306: PPUSH
6307: PPUSH
6308: PPUSH
6309: PPUSH
6310: PPUSH
6311: PPUSH
// begin PrepareArabian ;
6312: CALL 12633 0 0
// blocked := false ;
6316: LD_ADDR_EXP 18
6320: PUSH
6321: LD_INT 0
6323: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// until ar_spawned ;
6331: LD_EXP 11
6335: IFFALSE 6324
// have_crates := true ;
6337: LD_ADDR_VAR 0 9
6341: PUSH
6342: LD_INT 1
6344: ST_TO_ADDR
// player_want_info := 2 ;
6345: LD_ADDR_EXP 13
6349: PUSH
6350: LD_INT 2
6352: ST_TO_ADDR
// DialogueOn ;
6353: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6357: LD_EXP 29
6361: PPUSH
6362: LD_STRING D8-Ar1-1
6364: PPUSH
6365: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6369: LD_EXP 21
6373: PPUSH
6374: LD_STRING D8-JMM-1
6376: PPUSH
6377: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6381: LD_EXP 29
6385: PPUSH
6386: LD_STRING D8-Ar1-2
6388: PPUSH
6389: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6393: LD_EXP 21
6397: PPUSH
6398: LD_STRING D8-JMM-2
6400: PPUSH
6401: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6405: LD_EXP 29
6409: PPUSH
6410: LD_STRING D8-Ar1-3
6412: PPUSH
6413: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6417: LD_EXP 21
6421: PPUSH
6422: LD_STRING D8-JMM-3
6424: PPUSH
6425: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6429: LD_EXP 29
6433: PPUSH
6434: LD_STRING D8-Ar1-4
6436: PPUSH
6437: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6441: LD_EXP 21
6445: PPUSH
6446: LD_STRING D8-JMM-4
6448: PPUSH
6449: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6453: LD_EXP 29
6457: PPUSH
6458: LD_STRING D8-Ar1-5
6460: PPUSH
6461: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6465: LD_EXP 21
6469: PPUSH
6470: LD_STRING D8-JMM-5
6472: PPUSH
6473: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6477: LD_EXP 29
6481: PPUSH
6482: LD_STRING D8-Ar1-6
6484: PPUSH
6485: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6489: LD_EXP 30
6493: PPUSH
6494: LD_STRING D8-Ar2-6
6496: PPUSH
6497: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6501: LD_EXP 21
6505: PPUSH
6506: LD_STRING D8-JMM-6
6508: PPUSH
6509: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6513: LD_EXP 30
6517: PPUSH
6518: LD_STRING D8-Ar2-7
6520: PPUSH
6521: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6525: LD_STRING QBarracks
6527: PPUSH
6528: CALL_OW 97
6532: PUSH
6533: LD_INT 1
6535: DOUBLE
6536: EQUAL
6537: IFTRUE 6541
6539: GO 6576
6541: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6542: LD_EXP 21
6546: PPUSH
6547: LD_STRING D8a-JMM-1
6549: PPUSH
6550: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6554: LD_EXP 29
6558: PPUSH
6559: LD_STRING D8a-Ar1-1
6561: PPUSH
6562: CALL_OW 94
// player_want_mortar := true ;
6566: LD_ADDR_EXP 12
6570: PUSH
6571: LD_INT 1
6573: ST_TO_ADDR
// end ; 2 :
6574: GO 6750
6576: LD_INT 2
6578: DOUBLE
6579: EQUAL
6580: IFTRUE 6584
6582: GO 6706
6584: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6585: LD_EXP 21
6589: PPUSH
6590: LD_STRING D8b-JMM-1
6592: PPUSH
6593: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6597: LD_EXP 29
6601: PPUSH
6602: LD_STRING D8b-Ar1-1
6604: PPUSH
6605: CALL_OW 94
// case Query ( QInfo ) of 1 :
6609: LD_STRING QInfo
6611: PPUSH
6612: CALL_OW 97
6616: PUSH
6617: LD_INT 1
6619: DOUBLE
6620: EQUAL
6621: IFTRUE 6625
6623: GO 6660
6625: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6626: LD_EXP 21
6630: PPUSH
6631: LD_STRING D8b1-JMM-1
6633: PPUSH
6634: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6638: LD_EXP 29
6642: PPUSH
6643: LD_STRING D8b1-Ar1-1
6645: PPUSH
6646: CALL_OW 94
// player_want_info := 2 ;
6650: LD_ADDR_EXP 13
6654: PUSH
6655: LD_INT 2
6657: ST_TO_ADDR
// end ; 2 :
6658: GO 6704
6660: LD_INT 2
6662: DOUBLE
6663: EQUAL
6664: IFTRUE 6668
6666: GO 6703
6668: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6669: LD_EXP 21
6673: PPUSH
6674: LD_STRING D8b2-JMM-1
6676: PPUSH
6677: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6681: LD_EXP 29
6685: PPUSH
6686: LD_STRING D8b2-Ar1-1
6688: PPUSH
6689: CALL_OW 94
// player_want_info := 0 ;
6693: LD_ADDR_EXP 13
6697: PUSH
6698: LD_INT 0
6700: ST_TO_ADDR
// end ; end ;
6701: GO 6704
6703: POP
// end ; 3 :
6704: GO 6750
6706: LD_INT 3
6708: DOUBLE
6709: EQUAL
6710: IFTRUE 6714
6712: GO 6749
6714: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6715: LD_EXP 21
6719: PPUSH
6720: LD_STRING D8c-JMM-1
6722: PPUSH
6723: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6727: LD_EXP 29
6731: PPUSH
6732: LD_STRING D8c-Ar1-1
6734: PPUSH
6735: CALL_OW 94
// player_want_info := 0 ;
6739: LD_ADDR_EXP 13
6743: PUSH
6744: LD_INT 0
6746: ST_TO_ADDR
// end ; end ;
6747: GO 6750
6749: POP
// DialogueOff ;
6750: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6754: LD_ADDR_VAR 0 4
6758: PUSH
6759: LD_INT 9
6761: PPUSH
6762: LD_INT 2
6764: PUSH
6765: LD_INT 30
6767: PUSH
6768: LD_INT 0
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: LD_INT 30
6777: PUSH
6778: LD_INT 1
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: EMPTY
6786: LIST
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 70
6794: ST_TO_ADDR
// if dep then
6795: LD_VAR 0 4
6799: IFFALSE 6815
// dep := dep [ 1 ] ;
6801: LD_ADDR_VAR 0 4
6805: PUSH
6806: LD_VAR 0 4
6810: PUSH
6811: LD_INT 1
6813: ARRAY
6814: ST_TO_ADDR
// if not dep then
6815: LD_VAR 0 4
6819: NOT
6820: IFFALSE 6858
// begin case Query ( QInfoNothing ) of 1 :
6822: LD_STRING QInfoNothing
6824: PPUSH
6825: CALL_OW 97
6829: PUSH
6830: LD_INT 1
6832: DOUBLE
6833: EQUAL
6834: IFTRUE 6838
6836: GO 6841
6838: POP
// ; end ;
6839: GO 6842
6841: POP
// player_want_info := false ;
6842: LD_ADDR_EXP 13
6846: PUSH
6847: LD_INT 0
6849: ST_TO_ADDR
// player_want_mortar := false ;
6850: LD_ADDR_EXP 12
6854: PUSH
6855: LD_INT 0
6857: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6858: LD_ADDR_VAR 0 3
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_INT 2
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 21
6875: PUSH
6876: LD_INT 2
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PPUSH
6887: CALL_OW 69
6891: ST_TO_ADDR
// time := 1 1$55 ;
6892: LD_ADDR_VAR 0 5
6896: PUSH
6897: LD_INT 4025
6899: ST_TO_ADDR
// no_oil_gain := false ;
6900: LD_ADDR_VAR 0 6
6904: PUSH
6905: LD_INT 0
6907: ST_TO_ADDR
// first_warn := false ;
6908: LD_ADDR_VAR 0 7
6912: PUSH
6913: LD_INT 0
6915: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6916: LD_EXP 12
6920: PUSH
6921: LD_EXP 13
6925: OR
6926: IFFALSE 7031
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6928: LD_EXP 36
6932: PPUSH
6933: LD_INT 25
6935: PUSH
6936: LD_INT 1
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: PPUSH
6943: CALL_OW 72
6947: PPUSH
6948: LD_VAR 0 4
6952: PPUSH
6953: CALL_OW 250
6957: PPUSH
6958: LD_VAR 0 4
6962: PPUSH
6963: CALL_OW 251
6967: PPUSH
6968: LD_VAR 0 4
6972: PPUSH
6973: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6977: LD_EXP 36
6981: PPUSH
6982: LD_INT 25
6984: PUSH
6985: LD_INT 1
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PPUSH
6992: CALL_OW 72
6996: PPUSH
6997: LD_INT 86
6999: PPUSH
7000: LD_INT 121
7002: PPUSH
7003: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7007: LD_EXP 36
7011: PPUSH
7012: LD_INT 25
7014: PUSH
7015: LD_INT 1
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: PPUSH
7022: CALL_OW 72
7026: PPUSH
7027: CALL_OW 200
// end ; if player_attacked_ar then
7031: LD_EXP 16
7035: IFFALSE 7039
// exit ;
7037: GO 9918
// if player_want_mortar then
7039: LD_EXP 12
7043: IFFALSE 8580
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7045: LD_EXP 30
7049: PPUSH
7050: LD_VAR 0 4
7054: PPUSH
7055: CALL_OW 250
7059: PUSH
7060: LD_INT 1
7062: PLUS
7063: PPUSH
7064: LD_VAR 0 4
7068: PPUSH
7069: CALL_OW 251
7073: PUSH
7074: LD_INT 1
7076: PLUS
7077: PPUSH
7078: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7082: LD_INT 35
7084: PPUSH
7085: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7089: LD_EXP 30
7093: PPUSH
7094: LD_VAR 0 4
7098: PPUSH
7099: CALL_OW 296
7103: PUSH
7104: LD_INT 4
7106: LESS
7107: IFFALSE 7082
// for i = 1 to 6 do
7109: LD_ADDR_VAR 0 1
7113: PUSH
7114: DOUBLE
7115: LD_INT 1
7117: DEC
7118: ST_TO_ADDR
7119: LD_INT 6
7121: PUSH
7122: FOR_TO
7123: IFFALSE 7327
// begin if player_attacked_ar then
7125: LD_EXP 16
7129: IFFALSE 7135
// exit ;
7131: POP
7132: POP
7133: GO 9918
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7135: LD_VAR 0 4
7139: PPUSH
7140: CALL_OW 274
7144: PPUSH
7145: LD_INT 2
7147: PPUSH
7148: CALL_OW 275
7152: PUSH
7153: LD_INT 10
7155: LESS
7156: PUSH
7157: LD_VAR 0 7
7161: NOT
7162: AND
7163: IFFALSE 7226
// begin first_warn := true ;
7165: LD_ADDR_VAR 0 7
7169: PUSH
7170: LD_INT 1
7172: ST_TO_ADDR
// DialogueOn ;
7173: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7177: LD_EXP 31
7181: PPUSH
7182: LD_STRING D9a-FAr1-1
7184: PPUSH
7185: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7189: LD_EXP 21
7193: PPUSH
7194: LD_STRING D9a-JMM-1
7196: PPUSH
7197: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7201: LD_EXP 29
7205: PPUSH
7206: LD_STRING D9a2-Ar1-1
7208: PPUSH
7209: CALL_OW 88
// DialogueOff ;
7213: CALL_OW 7
// wait ( time ) ;
7217: LD_VAR 0 5
7221: PPUSH
7222: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7226: LD_VAR 0 4
7230: PPUSH
7231: CALL_OW 274
7235: PPUSH
7236: LD_INT 2
7238: PPUSH
7239: CALL_OW 275
7243: PUSH
7244: LD_INT 10
7246: LESS
7247: IFFALSE 7273
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7249: LD_EXP 29
7253: PPUSH
7254: LD_STRING D9a3-Ar1-1
7256: PPUSH
7257: CALL_OW 88
// no_oil_gain := true ;
7261: LD_ADDR_VAR 0 6
7265: PUSH
7266: LD_INT 1
7268: ST_TO_ADDR
// break ;
7269: GO 7327
// end else
7271: GO 7325
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7273: LD_EXP 30
7277: PPUSH
7278: LD_VAR 0 4
7282: PPUSH
7283: LD_INT 2
7285: PPUSH
7286: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7290: LD_EXP 30
7294: PPUSH
7295: LD_VAR 0 3
7299: PUSH
7300: LD_VAR 0 1
7304: PUSH
7305: LD_INT 3
7307: MOD
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: ARRAY
7313: PPUSH
7314: CALL_OW 210
// wait ( 0 0$10 ) ;
7318: LD_INT 350
7320: PPUSH
7321: CALL_OW 67
// end ; end ;
7325: GO 7122
7327: POP
7328: POP
// if not no_oil_gain then
7329: LD_VAR 0 6
7333: NOT
7334: IFFALSE 8580
// begin repeat wait ( 0 0$01 ) ;
7336: LD_INT 35
7338: PPUSH
7339: CALL_OW 67
// if player_attacked_ar then
7343: LD_EXP 16
7347: IFFALSE 7351
// exit ;
7349: GO 9918
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7351: LD_VAR 0 3
7355: PUSH
7356: LD_INT 1
7358: ARRAY
7359: PPUSH
7360: CALL_OW 261
7364: PUSH
7365: LD_INT 80
7367: GREATER
7368: PUSH
7369: LD_VAR 0 3
7373: PUSH
7374: LD_INT 2
7376: ARRAY
7377: PPUSH
7378: CALL_OW 261
7382: PUSH
7383: LD_INT 80
7385: GREATER
7386: AND
7387: PUSH
7388: LD_VAR 0 3
7392: PUSH
7393: LD_INT 3
7395: ARRAY
7396: PPUSH
7397: CALL_OW 261
7401: PUSH
7402: LD_INT 80
7404: GREATER
7405: AND
7406: IFFALSE 7336
// ComMoveXY ( Gali , 105 , 127 ) ;
7408: LD_EXP 30
7412: PPUSH
7413: LD_INT 105
7415: PPUSH
7416: LD_INT 127
7418: PPUSH
7419: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7423: LD_EXP 30
7427: PPUSH
7428: LD_INT 2
7430: PPUSH
7431: CALL_OW 173
// AddComHold ( Gali ) ;
7435: LD_EXP 30
7439: PPUSH
7440: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7444: LD_INT 35
7446: PPUSH
7447: CALL_OW 67
// if player_attacked_ar then
7451: LD_EXP 16
7455: IFFALSE 7459
// exit ;
7457: GO 9918
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7459: LD_EXP 30
7463: PPUSH
7464: LD_INT 105
7466: PPUSH
7467: LD_INT 127
7469: PPUSH
7470: CALL_OW 297
7474: PUSH
7475: LD_INT 4
7477: LESS
7478: IFFALSE 7444
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7480: LD_VAR 0 4
7484: PPUSH
7485: CALL_OW 274
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 275
7497: PUSH
7498: LD_INT 50
7500: LESS
7501: IFFALSE 7803
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7503: LD_VAR 0 4
7507: PPUSH
7508: CALL_OW 274
7512: PPUSH
7513: LD_INT 1
7515: PPUSH
7516: CALL_OW 275
7520: PUSH
7521: LD_INT 0
7523: DOUBLE
7524: GREATEREQUAL
7525: IFFALSE 7533
7527: LD_INT 24
7529: DOUBLE
7530: LESSEQUAL
7531: IFTRUE 7535
7533: GO 7550
7535: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7536: LD_EXP 30
7540: PPUSH
7541: LD_STRING D9b-Ar2-1
7543: PPUSH
7544: CALL_OW 88
7548: GO 7580
7550: LD_INT 25
7552: DOUBLE
7553: GREATEREQUAL
7554: IFFALSE 7562
7556: LD_INT 49
7558: DOUBLE
7559: LESSEQUAL
7560: IFTRUE 7564
7562: GO 7579
7564: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7565: LD_EXP 30
7569: PPUSH
7570: LD_STRING D9b-Ar2-1a
7572: PPUSH
7573: CALL_OW 88
7577: GO 7580
7579: POP
// Say ( JMM , D9b-JMM-1 ) ;
7580: LD_EXP 21
7584: PPUSH
7585: LD_STRING D9b-JMM-1
7587: PPUSH
7588: CALL_OW 88
// x := 0 0$0 ;
7592: LD_ADDR_VAR 0 2
7596: PUSH
7597: LD_INT 0
7599: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7600: LD_INT 35
7602: PPUSH
7603: CALL_OW 67
// x := x + 0 0$1 ;
7607: LD_ADDR_VAR 0 2
7611: PUSH
7612: LD_VAR 0 2
7616: PUSH
7617: LD_INT 35
7619: PLUS
7620: ST_TO_ADDR
// if player_attacked_ar then
7621: LD_EXP 16
7625: IFFALSE 7629
// exit ;
7627: GO 9918
// until x >= time ;
7629: LD_VAR 0 2
7633: PUSH
7634: LD_VAR 0 5
7638: GREATEREQUAL
7639: IFFALSE 7600
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7641: LD_VAR 0 4
7645: PPUSH
7646: CALL_OW 274
7650: PPUSH
7651: LD_INT 1
7653: PPUSH
7654: CALL_OW 275
7658: PUSH
7659: LD_INT 50
7661: LESS
7662: IFFALSE 7803
// begin have_crates := false ;
7664: LD_ADDR_VAR 0 9
7668: PUSH
7669: LD_INT 0
7671: ST_TO_ADDR
// DialogueOn ;
7672: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7676: LD_EXP 29
7680: PPUSH
7681: LD_STRING D9c-Ar1-1
7683: PPUSH
7684: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7688: LD_EXP 21
7692: PPUSH
7693: LD_STRING D9c-JMM-1
7695: PPUSH
7696: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7700: LD_EXP 29
7704: PPUSH
7705: LD_STRING D9c-Ar1-2
7707: PPUSH
7708: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7712: LD_EXP 31
7716: PPUSH
7717: LD_STRING D9c-FAr1-2
7719: PPUSH
7720: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7724: LD_EXP 29
7728: PPUSH
7729: LD_STRING D9c-Ar1-3
7731: PPUSH
7732: CALL_OW 88
// case Query ( QInfo ) of 1 :
7736: LD_STRING QInfo
7738: PPUSH
7739: CALL_OW 97
7743: PUSH
7744: LD_INT 1
7746: DOUBLE
7747: EQUAL
7748: IFTRUE 7752
7750: GO 7775
7752: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7753: LD_EXP 21
7757: PPUSH
7758: LD_STRING D8b1-JMM-1
7760: PPUSH
7761: CALL_OW 88
// player_want_info := 2 ;
7765: LD_ADDR_EXP 13
7769: PUSH
7770: LD_INT 2
7772: ST_TO_ADDR
// end ; 2 :
7773: GO 7799
7775: LD_INT 2
7777: DOUBLE
7778: EQUAL
7779: IFTRUE 7783
7781: GO 7798
7783: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7784: LD_EXP 29
7788: PPUSH
7789: LD_STRING D8b2-Ar1-1
7791: PPUSH
7792: CALL_OW 88
// end ; end ;
7796: GO 7799
7798: POP
// DialogueOff ;
7799: CALL_OW 7
// end ; end ; if have_crates then
7803: LD_VAR 0 9
7807: IFFALSE 8580
// begin RemoveEnvironmentArea ( mortarArea ) ;
7809: LD_INT 2
7811: PPUSH
7812: CALL_OW 355
// wait ( 1 ) ;
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 67
// InGameOn ;
7823: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7827: LD_EXP 30
7831: PPUSH
7832: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7836: LD_EXP 30
7840: PPUSH
7841: LD_INT 1
7843: PPUSH
7844: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
7848: LD_ADDR_VAR 0 10
7852: PUSH
7853: LD_INT 22
7855: PUSH
7856: LD_INT 1
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 3
7865: PUSH
7866: LD_INT 23
7868: PUSH
7869: LD_INT 2
7871: PUSH
7872: EMPTY
7873: LIST
7874: LIST
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: LD_INT 21
7882: PUSH
7883: LD_INT 1
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 92
7892: PUSH
7893: LD_INT 107
7895: PUSH
7896: LD_INT 131
7898: PUSH
7899: LD_INT 6
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: LIST
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: LIST
7912: LIST
7913: PPUSH
7914: CALL_OW 69
7918: ST_TO_ADDR
// if filter then
7919: LD_VAR 0 10
7923: IFFALSE 7957
// for i in filter do
7925: LD_ADDR_VAR 0 1
7929: PUSH
7930: LD_VAR 0 10
7934: PUSH
7935: FOR_IN
7936: IFFALSE 7955
// ComMoveXY ( i , 107 , 121 ) ;
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_INT 107
7945: PPUSH
7946: LD_INT 121
7948: PPUSH
7949: CALL_OW 111
7953: GO 7935
7955: POP
7956: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7957: LD_EXP 30
7961: PPUSH
7962: LD_INT 4
7964: PPUSH
7965: LD_INT 107
7967: PPUSH
7968: LD_INT 131
7970: PPUSH
7971: LD_INT 0
7973: PPUSH
7974: CALL_OW 145
// wait ( 0 0$1 ) ;
7978: LD_INT 35
7980: PPUSH
7981: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7985: LD_INT 30
7987: PUSH
7988: LD_INT 4
7990: PUSH
7991: EMPTY
7992: LIST
7993: LIST
7994: PUSH
7995: LD_INT 23
7997: PUSH
7998: LD_INT 2
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: EMPTY
8006: LIST
8007: LIST
8008: PPUSH
8009: CALL_OW 69
8013: IFFALSE 7848
// SetSide ( Gali , 2 ) ;
8015: LD_EXP 30
8019: PPUSH
8020: LD_INT 2
8022: PPUSH
8023: CALL_OW 235
// InGameOff ;
8027: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8031: LD_ADDR_VAR 0 8
8035: PUSH
8036: LD_INT 30
8038: PUSH
8039: LD_INT 4
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PUSH
8046: LD_INT 23
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PUSH
8065: LD_INT 1
8067: ARRAY
8068: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8069: LD_INT 35
8071: PPUSH
8072: CALL_OW 67
// if player_attacked_ar then
8076: LD_EXP 16
8080: IFFALSE 8084
// exit ;
8082: GO 9918
// until BuildingStatus ( b ) <> bs_build ;
8084: LD_VAR 0 8
8088: PPUSH
8089: CALL_OW 461
8093: PUSH
8094: LD_INT 1
8096: NONEQUAL
8097: IFFALSE 8069
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8099: LD_VAR 0 8
8103: PPUSH
8104: CALL_OW 302
8108: PUSH
8109: LD_VAR 0 4
8113: PPUSH
8114: CALL_OW 274
8118: PPUSH
8119: LD_INT 1
8121: PPUSH
8122: CALL_OW 275
8126: PUSH
8127: LD_INT 25
8129: GREATEREQUAL
8130: AND
8131: IFFALSE 8230
// begin ComUpgrade ( b ) ;
8133: LD_VAR 0 8
8137: PPUSH
8138: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8142: LD_EXP 30
8146: PPUSH
8147: LD_STRING h
8149: PUSH
8150: LD_VAR 0 8
8154: PPUSH
8155: CALL_OW 250
8159: PUSH
8160: LD_VAR 0 8
8164: PPUSH
8165: CALL_OW 251
8169: PUSH
8170: LD_VAR 0 8
8174: PUSH
8175: LD_INT 0
8177: PUSH
8178: LD_INT 0
8180: PUSH
8181: LD_INT 0
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: LIST
8188: LIST
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: EMPTY
8194: LIST
8195: PPUSH
8196: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8200: LD_INT 35
8202: PPUSH
8203: CALL_OW 67
// if player_attacked_ar then
8207: LD_EXP 16
8211: IFFALSE 8215
// exit ;
8213: GO 9918
// until BuildingStatus ( b ) <> bs_build ;
8215: LD_VAR 0 8
8219: PPUSH
8220: CALL_OW 461
8224: PUSH
8225: LD_INT 1
8227: NONEQUAL
8228: IFFALSE 8200
// end ; if b then
8230: LD_VAR 0 8
8234: IFFALSE 8245
// CenterNowOnUnits ( b ) ;
8236: LD_VAR 0 8
8240: PPUSH
8241: CALL_OW 87
// DialogueOn ;
8245: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8249: LD_EXP 30
8253: PPUSH
8254: LD_STRING D9d-Ar2-1
8256: PPUSH
8257: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8261: LD_EXP 29
8265: PPUSH
8266: LD_STRING D9d-Ar1-1
8268: PPUSH
8269: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8273: LD_EXP 21
8277: PPUSH
8278: LD_STRING D9d-JMM-1
8280: PPUSH
8281: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8285: LD_EXP 29
8289: PPUSH
8290: LD_STRING D9d-Ar1-2
8292: PPUSH
8293: CALL_OW 88
// DialogueOff ;
8297: CALL_OW 7
// i := [ ] ;
8301: LD_ADDR_VAR 0 1
8305: PUSH
8306: EMPTY
8307: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8308: LD_VAR 0 4
8312: PPUSH
8313: CALL_OW 274
8317: PPUSH
8318: LD_INT 3
8320: PPUSH
8321: CALL_OW 275
8325: PUSH
8326: LD_INT 20
8328: GREATEREQUAL
8329: IFFALSE 8348
// i := i ^ [ 1 ] ;
8331: LD_ADDR_VAR 0 1
8335: PUSH
8336: LD_VAR 0 1
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: EMPTY
8345: LIST
8346: ADD
8347: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8348: LD_VAR 0 4
8352: PPUSH
8353: CALL_OW 274
8357: PPUSH
8358: LD_INT 1
8360: PPUSH
8361: CALL_OW 275
8365: PUSH
8366: LD_INT 50
8368: GREATEREQUAL
8369: IFFALSE 8388
// i := i ^ [ 2 ] ;
8371: LD_ADDR_VAR 0 1
8375: PUSH
8376: LD_VAR 0 1
8380: PUSH
8381: LD_INT 2
8383: PUSH
8384: EMPTY
8385: LIST
8386: ADD
8387: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8388: LD_VAR 0 4
8392: PPUSH
8393: CALL_OW 274
8397: PPUSH
8398: LD_INT 2
8400: PPUSH
8401: CALL_OW 275
8405: PUSH
8406: LD_INT 80
8408: GREATEREQUAL
8409: IFFALSE 8428
// i := i ^ [ 3 ] ;
8411: LD_ADDR_VAR 0 1
8415: PUSH
8416: LD_VAR 0 1
8420: PUSH
8421: LD_INT 3
8423: PUSH
8424: EMPTY
8425: LIST
8426: ADD
8427: ST_TO_ADDR
// i := i diff 0 ;
8428: LD_ADDR_VAR 0 1
8432: PUSH
8433: LD_VAR 0 1
8437: PUSH
8438: LD_INT 0
8440: DIFF
8441: ST_TO_ADDR
// if i then
8442: LD_VAR 0 1
8446: IFFALSE 8552
// begin i := i ^ [ 4 ] ;
8448: LD_ADDR_VAR 0 1
8452: PUSH
8453: LD_VAR 0 1
8457: PUSH
8458: LD_INT 4
8460: PUSH
8461: EMPTY
8462: LIST
8463: ADD
8464: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8465: LD_STRING QInfo2
8467: PPUSH
8468: CALL_OW 97
8472: PUSH
8473: LD_INT 1
8475: DOUBLE
8476: EQUAL
8477: IFTRUE 8481
8479: GO 8492
8481: POP
// player_want_info := 3 ; 2 :
8482: LD_ADDR_EXP 13
8486: PUSH
8487: LD_INT 3
8489: ST_TO_ADDR
8490: GO 8550
8492: LD_INT 2
8494: DOUBLE
8495: EQUAL
8496: IFTRUE 8500
8498: GO 8511
8500: POP
// player_want_info := 1 ; 3 :
8501: LD_ADDR_EXP 13
8505: PUSH
8506: LD_INT 1
8508: ST_TO_ADDR
8509: GO 8550
8511: LD_INT 3
8513: DOUBLE
8514: EQUAL
8515: IFTRUE 8519
8517: GO 8530
8519: POP
// player_want_info := 2 ; 4 :
8520: LD_ADDR_EXP 13
8524: PUSH
8525: LD_INT 2
8527: ST_TO_ADDR
8528: GO 8550
8530: LD_INT 4
8532: DOUBLE
8533: EQUAL
8534: IFTRUE 8538
8536: GO 8549
8538: POP
// player_want_info := 0 ; end ;
8539: LD_ADDR_EXP 13
8543: PUSH
8544: LD_INT 0
8546: ST_TO_ADDR
8547: GO 8550
8549: POP
// end else
8550: GO 8580
// case Query ( QInfoNothing ) of 1 :
8552: LD_STRING QInfoNothing
8554: PPUSH
8555: CALL_OW 97
8559: PUSH
8560: LD_INT 1
8562: DOUBLE
8563: EQUAL
8564: IFTRUE 8568
8566: GO 8579
8568: POP
// player_want_info := 0 ; end ;
8569: LD_ADDR_EXP 13
8573: PUSH
8574: LD_INT 0
8576: ST_TO_ADDR
8577: GO 8580
8579: POP
// end ; end ; end ; if player_want_info then
8580: LD_EXP 13
8584: IFFALSE 9738
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8586: LD_ADDR_VAR 0 3
8590: PUSH
8591: LD_VAR 0 3
8595: PPUSH
8596: LD_INT 34
8598: PUSH
8599: LD_INT 32
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PPUSH
8606: CALL_OW 72
8610: ST_TO_ADDR
// if player_want_mortar then
8611: LD_EXP 12
8615: IFFALSE 8970
// begin case player_want_info of 1 :
8617: LD_EXP 13
8621: PUSH
8622: LD_INT 1
8624: DOUBLE
8625: EQUAL
8626: IFTRUE 8630
8628: GO 8641
8630: POP
// x := 5 ; 2 :
8631: LD_ADDR_VAR 0 2
8635: PUSH
8636: LD_INT 5
8638: ST_TO_ADDR
8639: GO 8680
8641: LD_INT 2
8643: DOUBLE
8644: EQUAL
8645: IFTRUE 8649
8647: GO 8660
8649: POP
// x := 8 ; 3 :
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: LD_INT 8
8657: ST_TO_ADDR
8658: GO 8680
8660: LD_INT 3
8662: DOUBLE
8663: EQUAL
8664: IFTRUE 8668
8666: GO 8679
8668: POP
// x := 2 ; end ;
8669: LD_ADDR_VAR 0 2
8673: PUSH
8674: LD_INT 2
8676: ST_TO_ADDR
8677: GO 8680
8679: POP
// repeat wait ( 0 0$1 ) ;
8680: LD_INT 35
8682: PPUSH
8683: CALL_OW 67
// until not HasTask ( Gali ) ;
8687: LD_EXP 30
8691: PPUSH
8692: CALL_OW 314
8696: NOT
8697: IFFALSE 8680
// time := 0 0$00 ;
8699: LD_ADDR_VAR 0 5
8703: PUSH
8704: LD_INT 0
8706: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8707: LD_INT 35
8709: PPUSH
8710: CALL_OW 67
// time := time + 0 0$1 ;
8714: LD_ADDR_VAR 0 5
8718: PUSH
8719: LD_VAR 0 5
8723: PUSH
8724: LD_INT 35
8726: PLUS
8727: ST_TO_ADDR
// if debug then
8728: LD_EXP 2
8732: IFFALSE 8751
// debug_strings := [ time: & time ] ;
8734: LD_ADDR_OWVAR 48
8738: PUSH
8739: LD_STRING time:
8741: PUSH
8742: LD_VAR 0 5
8746: STR
8747: PUSH
8748: EMPTY
8749: LIST
8750: ST_TO_ADDR
// if time > 8 8$00 then
8751: LD_VAR 0 5
8755: PUSH
8756: LD_INT 16800
8758: GREATER
8759: IFFALSE 8771
// begin blocked := true ;
8761: LD_ADDR_EXP 18
8765: PUSH
8766: LD_INT 1
8768: ST_TO_ADDR
// exit ;
8769: GO 9918
// end ; if not Carry ( Gali ) then
8771: LD_EXP 30
8775: PPUSH
8776: CALL_OW 281
8780: NOT
8781: IFFALSE 8804
// ComTransport ( Gali , dep , player_want_info ) else
8783: LD_EXP 30
8787: PPUSH
8788: LD_VAR 0 4
8792: PPUSH
8793: LD_EXP 13
8797: PPUSH
8798: CALL_OW 151
8802: GO 8922
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8804: LD_EXP 30
8808: PPUSH
8809: LD_VAR 0 3
8813: PUSH
8814: LD_INT 1
8816: ARRAY
8817: PPUSH
8818: CALL_OW 296
8822: PUSH
8823: LD_INT 4
8825: LESS
8826: PUSH
8827: LD_EXP 30
8831: PPUSH
8832: LD_EXP 13
8836: PPUSH
8837: CALL_OW 289
8841: AND
8842: IFFALSE 8904
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8844: LD_VAR 0 3
8848: PUSH
8849: LD_INT 1
8851: ARRAY
8852: PPUSH
8853: LD_EXP 13
8857: PPUSH
8858: LD_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ARRAY
8866: PPUSH
8867: LD_EXP 13
8871: PPUSH
8872: CALL_OW 289
8876: PUSH
8877: LD_INT 10
8879: PLUS
8880: PPUSH
8881: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8885: LD_EXP 30
8889: PPUSH
8890: LD_EXP 13
8894: PPUSH
8895: LD_INT 0
8897: PPUSH
8898: CALL_OW 290
// end else
8902: GO 8922
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8904: LD_EXP 30
8908: PPUSH
8909: LD_VAR 0 3
8913: PUSH
8914: LD_INT 1
8916: ARRAY
8917: PPUSH
8918: CALL_OW 112
// end ; if player_attacked_ar then
8922: LD_EXP 16
8926: IFFALSE 8930
// exit ;
8928: GO 9918
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
8930: LD_VAR 0 3
8934: PUSH
8935: LD_INT 1
8937: ARRAY
8938: PPUSH
8939: LD_EXP 13
8943: PPUSH
8944: CALL_OW 289
8948: PUSH
8949: LD_VAR 0 2
8953: PUSH
8954: LD_INT 10
8956: MUL
8957: GREATEREQUAL
8958: IFFALSE 8707
// no_oil_gain := false ;
8960: LD_ADDR_VAR 0 6
8964: PUSH
8965: LD_INT 0
8967: ST_TO_ADDR
// end else
8968: GO 9559
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8970: LD_ADDR_VAR 0 3
8974: PUSH
8975: LD_INT 22
8977: PUSH
8978: LD_INT 2
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: LD_INT 21
8987: PUSH
8988: LD_INT 2
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: PPUSH
8999: CALL_OW 69
9003: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9004: LD_EXP 30
9008: PPUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 250
9018: PUSH
9019: LD_INT 1
9021: PLUS
9022: PPUSH
9023: LD_VAR 0 4
9027: PPUSH
9028: CALL_OW 251
9032: PUSH
9033: LD_INT 1
9035: PLUS
9036: PPUSH
9037: CALL_OW 111
// time := 0 0$00 ;
9041: LD_ADDR_VAR 0 5
9045: PUSH
9046: LD_INT 0
9048: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9049: LD_INT 35
9051: PPUSH
9052: CALL_OW 67
// time := time + 0 0$1 ;
9056: LD_ADDR_VAR 0 5
9060: PUSH
9061: LD_VAR 0 5
9065: PUSH
9066: LD_INT 35
9068: PLUS
9069: ST_TO_ADDR
// if time > 1 1$45 then
9070: LD_VAR 0 5
9074: PUSH
9075: LD_INT 3675
9077: GREATER
9078: IFFALSE 9082
// break ;
9080: GO 9102
// until GetDistUnits ( Gali , dep ) < 4 ;
9082: LD_EXP 30
9086: PPUSH
9087: LD_VAR 0 4
9091: PPUSH
9092: CALL_OW 296
9096: PUSH
9097: LD_INT 4
9099: LESS
9100: IFFALSE 9049
// for i = 1 to 6 do
9102: LD_ADDR_VAR 0 1
9106: PUSH
9107: DOUBLE
9108: LD_INT 1
9110: DEC
9111: ST_TO_ADDR
9112: LD_INT 6
9114: PUSH
9115: FOR_TO
9116: IFFALSE 9320
// begin if player_attacked_ar then
9118: LD_EXP 16
9122: IFFALSE 9128
// exit ;
9124: POP
9125: POP
9126: GO 9918
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9128: LD_VAR 0 4
9132: PPUSH
9133: CALL_OW 274
9137: PPUSH
9138: LD_INT 2
9140: PPUSH
9141: CALL_OW 275
9145: PUSH
9146: LD_INT 10
9148: LESS
9149: PUSH
9150: LD_VAR 0 7
9154: NOT
9155: AND
9156: IFFALSE 9219
// begin first_warn := true ;
9158: LD_ADDR_VAR 0 7
9162: PUSH
9163: LD_INT 1
9165: ST_TO_ADDR
// DialogueOn ;
9166: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9170: LD_EXP 31
9174: PPUSH
9175: LD_STRING D9a-FAr1-1
9177: PPUSH
9178: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9182: LD_EXP 21
9186: PPUSH
9187: LD_STRING D9a-JMM-1
9189: PPUSH
9190: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9194: LD_EXP 29
9198: PPUSH
9199: LD_STRING D9a2-Ar1-1
9201: PPUSH
9202: CALL_OW 88
// DialogueOff ;
9206: CALL_OW 7
// wait ( time ) ;
9210: LD_VAR 0 5
9214: PPUSH
9215: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9219: LD_VAR 0 4
9223: PPUSH
9224: CALL_OW 274
9228: PPUSH
9229: LD_INT 2
9231: PPUSH
9232: CALL_OW 275
9236: PUSH
9237: LD_INT 10
9239: LESS
9240: IFFALSE 9266
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9242: LD_EXP 29
9246: PPUSH
9247: LD_STRING D9a3-Ar1-1
9249: PPUSH
9250: CALL_OW 88
// no_oil_gain := true ;
9254: LD_ADDR_VAR 0 6
9258: PUSH
9259: LD_INT 1
9261: ST_TO_ADDR
// break ;
9262: GO 9320
// end else
9264: GO 9318
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9266: LD_EXP 30
9270: PPUSH
9271: LD_VAR 0 4
9275: PPUSH
9276: LD_INT 2
9278: PPUSH
9279: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9283: LD_EXP 30
9287: PPUSH
9288: LD_VAR 0 3
9292: PUSH
9293: LD_VAR 0 1
9297: PUSH
9298: LD_INT 3
9300: MOD
9301: PUSH
9302: LD_INT 1
9304: PLUS
9305: ARRAY
9306: PPUSH
9307: CALL_OW 210
// wait ( 0 0$10 ) ;
9311: LD_INT 350
9313: PPUSH
9314: CALL_OW 67
// end ; end ;
9318: GO 9115
9320: POP
9321: POP
// time := 0 0$00 ;
9322: LD_ADDR_VAR 0 5
9326: PUSH
9327: LD_INT 0
9329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9330: LD_INT 35
9332: PPUSH
9333: CALL_OW 67
// if not HasTask ( Gali ) then
9337: LD_EXP 30
9341: PPUSH
9342: CALL_OW 314
9346: NOT
9347: IFFALSE 9363
// time := time + 0 0$1 ;
9349: LD_ADDR_VAR 0 5
9353: PUSH
9354: LD_VAR 0 5
9358: PUSH
9359: LD_INT 35
9361: PLUS
9362: ST_TO_ADDR
// if time > 1 1$25 then
9363: LD_VAR 0 5
9367: PUSH
9368: LD_INT 2975
9370: GREATER
9371: IFFALSE 9395
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9373: LD_EXP 29
9377: PPUSH
9378: LD_STRING D9a3-Ar1-1
9380: PPUSH
9381: CALL_OW 88
// no_oil_gain := true ;
9385: LD_ADDR_VAR 0 6
9389: PUSH
9390: LD_INT 1
9392: ST_TO_ADDR
// break ;
9393: GO 9559
// end ; if player_attacked_ar then
9395: LD_EXP 16
9399: IFFALSE 9403
// exit ;
9401: GO 9918
// for i in tmp do
9403: LD_ADDR_VAR 0 1
9407: PUSH
9408: LD_VAR 0 3
9412: PUSH
9413: FOR_IN
9414: IFFALSE 9445
// if GetFuel ( i ) < 100 then
9416: LD_VAR 0 1
9420: PPUSH
9421: CALL_OW 261
9425: PUSH
9426: LD_INT 100
9428: LESS
9429: IFFALSE 9443
// begin x := i ;
9431: LD_ADDR_VAR 0 2
9435: PUSH
9436: LD_VAR 0 1
9440: ST_TO_ADDR
// break ;
9441: GO 9445
// end ;
9443: GO 9413
9445: POP
9446: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9447: LD_EXP 30
9451: PPUSH
9452: CALL_OW 314
9456: NOT
9457: PUSH
9458: LD_EXP 30
9462: PPUSH
9463: CALL_OW 281
9467: NOT
9468: AND
9469: IFFALSE 9502
// begin ComTransport ( Gali , dep , mat_oil ) ;
9471: LD_EXP 30
9475: PPUSH
9476: LD_VAR 0 4
9480: PPUSH
9481: LD_INT 2
9483: PPUSH
9484: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9488: LD_EXP 30
9492: PPUSH
9493: LD_VAR 0 2
9497: PPUSH
9498: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9502: LD_VAR 0 3
9506: PUSH
9507: LD_INT 1
9509: ARRAY
9510: PPUSH
9511: CALL_OW 261
9515: PUSH
9516: LD_INT 80
9518: GREATER
9519: PUSH
9520: LD_VAR 0 3
9524: PUSH
9525: LD_INT 2
9527: ARRAY
9528: PPUSH
9529: CALL_OW 261
9533: PUSH
9534: LD_INT 80
9536: GREATER
9537: AND
9538: PUSH
9539: LD_VAR 0 3
9543: PUSH
9544: LD_INT 3
9546: ARRAY
9547: PPUSH
9548: CALL_OW 261
9552: PUSH
9553: LD_INT 80
9555: GREATER
9556: AND
9557: IFFALSE 9330
// end ; ComHold ( Gali ) ;
9559: LD_EXP 30
9563: PPUSH
9564: CALL_OW 140
// if not no_oil_gain then
9568: LD_VAR 0 6
9572: NOT
9573: IFFALSE 9738
// begin DialogueOn ;
9575: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9579: LD_EXP 29
9583: PPUSH
9584: CALL_OW 87
// if player_want_mortar then
9588: LD_EXP 12
9592: IFFALSE 9618
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9594: LD_EXP 29
9598: PPUSH
9599: LD_STRING D9e-Ar1-1
9601: PPUSH
9602: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9606: LD_EXP 21
9610: PPUSH
9611: LD_STRING D10a-JMM-1
9613: PPUSH
9614: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9618: LD_EXP 29
9622: PPUSH
9623: LD_STRING D10a-Ar1-1
9625: PPUSH
9626: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9630: LD_EXP 30
9634: PPUSH
9635: LD_STRING D10a-Ar2-1
9637: PPUSH
9638: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9642: LD_EXP 31
9646: PPUSH
9647: LD_STRING D10a-FAr1-1
9649: PPUSH
9650: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9654: LD_EXP 30
9658: PPUSH
9659: LD_STRING D10a-Ar2-2
9661: PPUSH
9662: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9666: LD_EXP 31
9670: PPUSH
9671: LD_STRING D10a-FAr1-2
9673: PPUSH
9674: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9678: LD_EXP 29
9682: PPUSH
9683: LD_STRING D10a-Ar1-2
9685: PPUSH
9686: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9690: LD_EXP 21
9694: PPUSH
9695: LD_STRING D10a-JMM-2
9697: PPUSH
9698: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9702: LD_EXP 29
9706: PPUSH
9707: LD_STRING D10a-Ar1-3
9709: PPUSH
9710: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9714: LD_EXP 21
9718: PPUSH
9719: LD_STRING D10a-JMM-3
9721: PPUSH
9722: CALL_OW 88
// player_get_info := true ;
9726: LD_ADDR_EXP 15
9730: PUSH
9731: LD_INT 1
9733: ST_TO_ADDR
// DialogueOff ;
9734: CALL_OW 7
// end ; end ; if player_attacked_ar then
9738: LD_EXP 16
9742: IFFALSE 9746
// exit ;
9744: GO 9918
// if player_want_mortar or player_want_info then
9746: LD_EXP 12
9750: PUSH
9751: LD_EXP 13
9755: OR
9756: IFFALSE 9770
// Say ( Vervecken , D9f-Ar1-1 ) ;
9758: LD_EXP 29
9762: PPUSH
9763: LD_STRING D9f-Ar1-1
9765: PPUSH
9766: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9770: LD_INT 22
9772: PUSH
9773: LD_INT 2
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PPUSH
9780: CALL_OW 69
9784: PPUSH
9785: LD_INT 51
9787: PPUSH
9788: LD_INT 99
9790: PPUSH
9791: CALL_OW 111
// wait ( 0 0$1 ) ;
9795: LD_INT 35
9797: PPUSH
9798: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9802: LD_INT 22
9804: PUSH
9805: LD_INT 2
9807: PUSH
9808: EMPTY
9809: LIST
9810: LIST
9811: PUSH
9812: LD_INT 92
9814: PUSH
9815: LD_INT 51
9817: PUSH
9818: LD_INT 99
9820: PUSH
9821: LD_INT 2
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: IFFALSE 9898
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9840: LD_ADDR_VAR 0 1
9844: PUSH
9845: LD_INT 22
9847: PUSH
9848: LD_INT 2
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PUSH
9855: LD_INT 92
9857: PUSH
9858: LD_INT 51
9860: PUSH
9861: LD_INT 99
9863: PUSH
9864: LD_INT 2
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: LIST
9871: LIST
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PPUSH
9877: CALL_OW 69
9881: PUSH
9882: FOR_IN
9883: IFFALSE 9896
// RemoveUnit ( i ) ;
9885: LD_VAR 0 1
9889: PPUSH
9890: CALL_OW 64
9894: GO 9882
9896: POP
9897: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9898: LD_INT 22
9900: PUSH
9901: LD_INT 2
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 69
9912: PUSH
9913: LD_INT 0
9915: EQUAL
9916: IFFALSE 9770
// end ;
9918: PPOPN 10
9920: END
// every 0 0$01 trigger blocked do var i ;
9921: LD_EXP 18
9925: IFFALSE 10093
9927: GO 9929
9929: DISABLE
9930: LD_INT 0
9932: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9933: LD_EXP 29
9937: PPUSH
9938: LD_STRING D9f-Ar1-1
9940: PPUSH
9941: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9945: LD_INT 22
9947: PUSH
9948: LD_INT 2
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: PPUSH
9955: CALL_OW 69
9959: PPUSH
9960: LD_INT 51
9962: PPUSH
9963: LD_INT 99
9965: PPUSH
9966: CALL_OW 111
// wait ( 0 0$1 ) ;
9970: LD_INT 35
9972: PPUSH
9973: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9977: LD_INT 22
9979: PUSH
9980: LD_INT 2
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PUSH
9987: LD_INT 92
9989: PUSH
9990: LD_INT 51
9992: PUSH
9993: LD_INT 99
9995: PUSH
9996: LD_INT 2
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: LIST
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PPUSH
10009: CALL_OW 69
10013: IFFALSE 10073
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10015: LD_ADDR_VAR 0 1
10019: PUSH
10020: LD_INT 22
10022: PUSH
10023: LD_INT 2
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PUSH
10030: LD_INT 92
10032: PUSH
10033: LD_INT 51
10035: PUSH
10036: LD_INT 99
10038: PUSH
10039: LD_INT 2
10041: PUSH
10042: EMPTY
10043: LIST
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PPUSH
10052: CALL_OW 69
10056: PUSH
10057: FOR_IN
10058: IFFALSE 10071
// RemoveUnit ( i ) ;
10060: LD_VAR 0 1
10064: PPUSH
10065: CALL_OW 64
10069: GO 10057
10071: POP
10072: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10073: LD_INT 22
10075: PUSH
10076: LD_INT 2
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PPUSH
10083: CALL_OW 69
10087: PUSH
10088: LD_INT 0
10090: EQUAL
10091: IFFALSE 9945
// end ;
10093: PPOPN 1
10095: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10096: LD_EXP 16
10100: IFFALSE 10453
10102: GO 10104
10104: DISABLE
10105: LD_INT 0
10107: PPUSH
10108: PPUSH
10109: PPUSH
10110: PPUSH
// begin ru_can_attack := true ;
10111: LD_ADDR_EXP 8
10115: PUSH
10116: LD_INT 1
10118: ST_TO_ADDR
// mine_launched := false ;
10119: LD_ADDR_VAR 0 3
10123: PUSH
10124: LD_INT 0
10126: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10127: LD_INT 22
10129: PUSH
10130: LD_INT 2
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PPUSH
10137: CALL_OW 69
10141: PPUSH
10142: LD_INT 51
10144: PPUSH
10145: LD_INT 99
10147: PPUSH
10148: CALL_OW 111
// if IsOk ( Vervecken ) then
10152: LD_EXP 29
10156: PPUSH
10157: CALL_OW 302
10161: IFFALSE 10175
// Say ( Vervecken , D11a-Ar1-1 ) ;
10163: LD_EXP 29
10167: PPUSH
10168: LD_STRING D11a-Ar1-1
10170: PPUSH
10171: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10175: LD_ADDR_VAR 0 2
10179: PUSH
10180: LD_EXP 36
10184: PPUSH
10185: LD_INT 25
10187: PUSH
10188: LD_INT 1
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PPUSH
10195: CALL_OW 72
10199: ST_TO_ADDR
// for i in tmp do
10200: LD_ADDR_VAR 0 1
10204: PUSH
10205: LD_VAR 0 2
10209: PUSH
10210: FOR_IN
10211: IFFALSE 10274
// if MineOfUnit ( i ) then
10213: LD_VAR 0 1
10217: PPUSH
10218: CALL_OW 459
10222: IFFALSE 10272
// begin x := MineOfUnit ( i ) ;
10224: LD_ADDR_VAR 0 4
10228: PUSH
10229: LD_VAR 0 1
10233: PPUSH
10234: CALL_OW 459
10238: ST_TO_ADDR
// mine_launched := true ;
10239: LD_ADDR_VAR 0 3
10243: PUSH
10244: LD_INT 1
10246: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10247: LD_VAR 0 4
10251: PUSH
10252: LD_INT 1
10254: ARRAY
10255: PPUSH
10256: LD_VAR 0 4
10260: PUSH
10261: LD_INT 2
10263: ARRAY
10264: PPUSH
10265: LD_INT 2
10267: PPUSH
10268: CALL_OW 456
// end ;
10272: GO 10210
10274: POP
10275: POP
// if mine_launched and IsOk ( Vervecken ) then
10276: LD_VAR 0 3
10280: PUSH
10281: LD_EXP 29
10285: PPUSH
10286: CALL_OW 302
10290: AND
10291: IFFALSE 10305
// Say ( Vervecken , D11b-Ar1-1 ) ;
10293: LD_EXP 29
10297: PPUSH
10298: LD_STRING D11b-Ar1-1
10300: PPUSH
10301: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10305: LD_INT 22
10307: PUSH
10308: LD_INT 2
10310: PUSH
10311: EMPTY
10312: LIST
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_INT 51
10322: PPUSH
10323: LD_INT 99
10325: PPUSH
10326: CALL_OW 111
// wait ( 0 0$1 ) ;
10330: LD_INT 35
10332: PPUSH
10333: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10337: LD_INT 22
10339: PUSH
10340: LD_INT 2
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 92
10349: PUSH
10350: LD_INT 51
10352: PUSH
10353: LD_INT 99
10355: PUSH
10356: LD_INT 2
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: PPUSH
10369: CALL_OW 69
10373: IFFALSE 10433
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10375: LD_ADDR_VAR 0 1
10379: PUSH
10380: LD_INT 22
10382: PUSH
10383: LD_INT 2
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 92
10392: PUSH
10393: LD_INT 51
10395: PUSH
10396: LD_INT 99
10398: PUSH
10399: LD_INT 2
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: PPUSH
10412: CALL_OW 69
10416: PUSH
10417: FOR_IN
10418: IFFALSE 10431
// RemoveUnit ( i ) ;
10420: LD_VAR 0 1
10424: PPUSH
10425: CALL_OW 64
10429: GO 10417
10431: POP
10432: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10433: LD_INT 22
10435: PUSH
10436: LD_INT 2
10438: PUSH
10439: EMPTY
10440: LIST
10441: LIST
10442: PPUSH
10443: CALL_OW 69
10447: PUSH
10448: LD_INT 0
10450: EQUAL
10451: IFFALSE 10305
// end ;
10453: PPOPN 4
10455: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10456: LD_EXP 10
10460: IFFALSE 10639
10462: GO 10464
10464: DISABLE
10465: LD_INT 0
10467: PPUSH
// begin Wait ( 10 10$00 ) ;
10468: LD_INT 21000
10470: PPUSH
10471: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10475: LD_INT 22
10477: PUSH
10478: LD_INT 2
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PPUSH
10485: CALL_OW 69
10489: IFFALSE 10639
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10491: LD_INT 22
10493: PUSH
10494: LD_INT 2
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 69
10505: PPUSH
10506: LD_INT 51
10508: PPUSH
10509: LD_INT 99
10511: PPUSH
10512: CALL_OW 114
// wait ( 0 0$1 ) ;
10516: LD_INT 35
10518: PPUSH
10519: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10523: LD_INT 22
10525: PUSH
10526: LD_INT 2
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: PUSH
10533: LD_INT 92
10535: PUSH
10536: LD_INT 51
10538: PUSH
10539: LD_INT 99
10541: PUSH
10542: LD_INT 2
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PPUSH
10555: CALL_OW 69
10559: IFFALSE 10619
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10561: LD_ADDR_VAR 0 1
10565: PUSH
10566: LD_INT 22
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: LD_INT 92
10578: PUSH
10579: LD_INT 51
10581: PUSH
10582: LD_INT 99
10584: PUSH
10585: LD_INT 2
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: PPUSH
10598: CALL_OW 69
10602: PUSH
10603: FOR_IN
10604: IFFALSE 10617
// RemoveUnit ( i ) ;
10606: LD_VAR 0 1
10610: PPUSH
10611: CALL_OW 64
10615: GO 10603
10617: POP
10618: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10619: LD_INT 22
10621: PUSH
10622: LD_INT 2
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: PPUSH
10629: CALL_OW 69
10633: PUSH
10634: LD_INT 0
10636: EQUAL
10637: IFFALSE 10491
// end ; end ;
10639: PPOPN 1
10641: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10642: LD_EXP 4
10646: IFFALSE 11672
10648: GO 10650
10650: DISABLE
10651: LD_INT 0
10653: PPUSH
10654: PPUSH
10655: PPUSH
10656: PPUSH
10657: PPUSH
10658: PPUSH
// begin Wait ( game_time ) ;
10659: LD_EXP 7
10663: PPUSH
10664: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// until ( not ru_can_attack ) ;
10675: LD_EXP 8
10679: NOT
10680: IFFALSE 10668
// Wait ( 0 0$35 ) ;
10682: LD_INT 1225
10684: PPUSH
10685: CALL_OW 67
// DialogueOn ;
10689: CALL_OW 6
// InGameOn ;
10693: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10697: LD_EXP 28
10701: PPUSH
10702: LD_STRING D12-Pow-1
10704: PPUSH
10705: CALL_OW 94
// InGameOff ;
10709: CALL_OW 9
// DialogueOff ;
10713: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10717: LD_STRING M4
10719: PPUSH
10720: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10724: LD_INT 5
10726: PPUSH
10727: LD_INT 1
10729: PPUSH
10730: CALL_OW 424
// can_end := true ;
10734: LD_ADDR_EXP 17
10738: PUSH
10739: LD_INT 1
10741: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10742: LD_INT 35
10744: PPUSH
10745: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10749: CALL 943 0 0
10753: PUSH
10754: LD_INT 20
10756: GREATEREQUAL
10757: PUSH
10758: LD_INT 22
10760: PUSH
10761: LD_INT 1
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: PUSH
10768: LD_INT 21
10770: PUSH
10771: LD_INT 1
10773: PUSH
10774: EMPTY
10775: LIST
10776: LIST
10777: PUSH
10778: EMPTY
10779: LIST
10780: LIST
10781: PPUSH
10782: CALL_OW 69
10786: PUSH
10787: LD_INT 5
10789: PPUSH
10790: LD_INT 22
10792: PUSH
10793: LD_INT 1
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 21
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 70
10818: PUSH
10819: LD_INT 22
10821: PUSH
10822: LD_INT 1
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: LD_INT 55
10831: PUSH
10832: EMPTY
10833: LIST
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: PPUSH
10839: CALL_OW 69
10843: PLUS
10844: LESSEQUAL
10845: AND
10846: IFFALSE 10742
// if not player_get_info then
10848: LD_EXP 15
10852: NOT
10853: IFFALSE 10864
// player_get_info := - 1 ;
10855: LD_ADDR_EXP 15
10859: PUSH
10860: LD_INT 1
10862: NEG
10863: ST_TO_ADDR
// m1 := player_get_info > 0 ;
10864: LD_ADDR_VAR 0 4
10868: PUSH
10869: LD_EXP 15
10873: PUSH
10874: LD_INT 0
10876: GREATER
10877: ST_TO_ADDR
// m2 := false ;
10878: LD_ADDR_VAR 0 5
10882: PUSH
10883: LD_INT 0
10885: ST_TO_ADDR
// m3 := earlySib ;
10886: LD_ADDR_VAR 0 6
10890: PUSH
10891: LD_EXP 19
10895: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10896: LD_STRING Information
10898: PPUSH
10899: LD_EXP 15
10903: PPUSH
10904: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10908: LD_ADDR_VAR 0 2
10912: PUSH
10913: LD_INT 22
10915: PUSH
10916: LD_INT 1
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: PUSH
10923: LD_INT 2
10925: PUSH
10926: LD_INT 25
10928: PUSH
10929: LD_INT 2
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: LD_INT 25
10938: PUSH
10939: LD_INT 16
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PUSH
10946: LD_INT 34
10948: PUSH
10949: LD_INT 12
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PUSH
10956: EMPTY
10957: LIST
10958: LIST
10959: LIST
10960: LIST
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PPUSH
10966: CALL_OW 69
10970: ST_TO_ADDR
// sib := GetTerminalCargo ;
10971: LD_ADDR_VAR 0 3
10975: PUSH
10976: CALL 943 0 0
10980: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10981: LD_ADDR_VAR 0 3
10985: PUSH
10986: LD_VAR 0 3
10990: PUSH
10991: LD_INT 6
10993: PPUSH
10994: LD_INT 3
10996: PPUSH
10997: CALL_OW 287
11001: PLUS
11002: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11003: LD_ADDR_VAR 0 3
11007: PUSH
11008: LD_VAR 0 3
11012: PUSH
11013: LD_VAR 0 2
11017: PPUSH
11018: LD_INT 3
11020: PPUSH
11021: CALL_OW 289
11025: PLUS
11026: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11027: LD_VAR 0 3
11031: PUSH
11032: LD_INT 2
11034: PUSH
11035: LD_OWVAR 67
11039: PLUS
11040: PUSH
11041: LD_INT 50
11043: MUL
11044: LESS
11045: IFFALSE 11070
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11047: LD_STRING MuchSiberite
11049: PPUSH
11050: LD_INT 2
11052: NEG
11053: PUSH
11054: LD_OWVAR 67
11058: MUL
11059: PUSH
11060: LD_INT 1
11062: PLUS
11063: PPUSH
11064: CALL_OW 101
11068: GO 11088
// begin AddMedal ( MuchSiberite , 1 ) ;
11070: LD_STRING MuchSiberite
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL_OW 101
// m2 := true ;
11080: LD_ADDR_VAR 0 5
11084: PUSH
11085: LD_INT 1
11087: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11088: LD_VAR 0 4
11092: PUSH
11093: LD_VAR 0 5
11097: AND
11098: PUSH
11099: LD_VAR 0 6
11103: AND
11104: PUSH
11105: LD_OWVAR 67
11109: PUSH
11110: LD_INT 3
11112: EQUAL
11113: AND
11114: IFFALSE 11126
// SetAchievementEX ( ACH_AMER , 9 ) ;
11116: LD_STRING ACH_AMER
11118: PPUSH
11119: LD_INT 9
11121: PPUSH
11122: CALL_OW 564
// if tick <= 55 55$00 then
11126: LD_OWVAR 1
11130: PUSH
11131: LD_INT 115500
11133: LESSEQUAL
11134: IFFALSE 11143
// SetAchievement ( ACH_ASPEED_9 ) ;
11136: LD_STRING ACH_ASPEED_9
11138: PPUSH
11139: CALL_OW 543
// GiveMedals ( MAIN ) ;
11143: LD_STRING MAIN
11145: PPUSH
11146: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11150: LD_INT 22
11152: PUSH
11153: LD_INT 1
11155: PUSH
11156: EMPTY
11157: LIST
11158: LIST
11159: PUSH
11160: LD_INT 2
11162: PUSH
11163: LD_INT 25
11165: PUSH
11166: LD_INT 1
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PUSH
11173: LD_INT 25
11175: PUSH
11176: LD_INT 2
11178: PUSH
11179: EMPTY
11180: LIST
11181: LIST
11182: PUSH
11183: LD_INT 25
11185: PUSH
11186: LD_INT 3
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PUSH
11193: LD_INT 25
11195: PUSH
11196: LD_INT 4
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 25
11205: PUSH
11206: LD_INT 8
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PPUSH
11225: CALL_OW 69
11229: PPUSH
11230: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11234: LD_ADDR_VAR 0 2
11238: PUSH
11239: LD_INT 22
11241: PUSH
11242: LD_INT 1
11244: PUSH
11245: EMPTY
11246: LIST
11247: LIST
11248: PUSH
11249: LD_INT 25
11251: PUSH
11252: LD_INT 8
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PPUSH
11263: CALL_OW 69
11267: ST_TO_ADDR
// if tmp then
11268: LD_VAR 0 2
11272: IFFALSE 11303
// for i in tmp do
11274: LD_ADDR_VAR 0 1
11278: PUSH
11279: LD_VAR 0 2
11283: PUSH
11284: FOR_IN
11285: IFFALSE 11301
// SetClass ( i , 1 ) ;
11287: LD_VAR 0 1
11291: PPUSH
11292: LD_INT 1
11294: PPUSH
11295: CALL_OW 336
11299: GO 11284
11301: POP
11302: POP
// SaveVariable ( sib , 09_sibRes ) ;
11303: LD_VAR 0 3
11307: PPUSH
11308: LD_STRING 09_sibRes
11310: PPUSH
11311: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11315: LD_EXP 15
11319: PPUSH
11320: LD_STRING 09_arInfo
11322: PPUSH
11323: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11327: LD_EXP 21
11331: PPUSH
11332: LD_EXP 1
11336: PUSH
11337: LD_STRING JMM
11339: STR
11340: PPUSH
11341: CALL_OW 38
// if IsLive ( Gary ) then
11345: LD_EXP 22
11349: PPUSH
11350: CALL_OW 300
11354: IFFALSE 11374
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11356: LD_EXP 22
11360: PPUSH
11361: LD_EXP 1
11365: PUSH
11366: LD_STRING Gary
11368: STR
11369: PPUSH
11370: CALL_OW 38
// if IsLive ( Bobby ) then
11374: LD_EXP 23
11378: PPUSH
11379: CALL_OW 300
11383: IFFALSE 11403
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11385: LD_EXP 23
11389: PPUSH
11390: LD_EXP 1
11394: PUSH
11395: LD_STRING Bobby
11397: STR
11398: PPUSH
11399: CALL_OW 38
// if IsLive ( Cyrus ) then
11403: LD_EXP 24
11407: PPUSH
11408: CALL_OW 300
11412: IFFALSE 11432
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11414: LD_EXP 24
11418: PPUSH
11419: LD_EXP 1
11423: PUSH
11424: LD_STRING Cyrus
11426: STR
11427: PPUSH
11428: CALL_OW 38
// if IsLive ( Houten ) then
11432: LD_EXP 25
11436: PPUSH
11437: CALL_OW 300
11441: IFFALSE 11461
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11443: LD_EXP 25
11447: PPUSH
11448: LD_EXP 1
11452: PUSH
11453: LD_STRING Houten
11455: STR
11456: PPUSH
11457: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11461: LD_ADDR_VAR 0 2
11465: PUSH
11466: LD_INT 22
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: LD_INT 25
11481: PUSH
11482: LD_INT 1
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: LD_INT 25
11491: PUSH
11492: LD_INT 2
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: PUSH
11499: LD_INT 25
11501: PUSH
11502: LD_INT 3
11504: PUSH
11505: EMPTY
11506: LIST
11507: LIST
11508: PUSH
11509: LD_INT 25
11511: PUSH
11512: LD_INT 4
11514: PUSH
11515: EMPTY
11516: LIST
11517: LIST
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: PPUSH
11530: CALL_OW 69
11534: PUSH
11535: LD_EXP 21
11539: PUSH
11540: LD_EXP 24
11544: PUSH
11545: LD_EXP 23
11549: PUSH
11550: LD_EXP 25
11554: PUSH
11555: LD_EXP 22
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: DIFF
11567: ST_TO_ADDR
// if tmp then
11568: LD_VAR 0 2
11572: IFFALSE 11592
// SaveCharacters ( tmp , mission_prefix & others ) ;
11574: LD_VAR 0 2
11578: PPUSH
11579: LD_EXP 1
11583: PUSH
11584: LD_STRING others
11586: STR
11587: PPUSH
11588: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11592: LD_ADDR_VAR 0 2
11596: PUSH
11597: LD_INT 22
11599: PUSH
11600: LD_INT 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 2
11609: PUSH
11610: LD_INT 25
11612: PUSH
11613: LD_INT 12
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: PUSH
11620: LD_INT 25
11622: PUSH
11623: LD_INT 16
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: LIST
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PPUSH
11639: CALL_OW 69
11643: ST_TO_ADDR
// if tmp then
11644: LD_VAR 0 2
11648: IFFALSE 11668
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11650: LD_VAR 0 2
11654: PPUSH
11655: LD_EXP 1
11659: PUSH
11660: LD_STRING apes
11662: STR
11663: PPUSH
11664: CALL_OW 38
// YouWin ;
11668: CALL_OW 103
// end ; end_of_file
11672: PPOPN 6
11674: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11675: LD_VAR 0 1
11679: PPUSH
11680: CALL_OW 266
11684: PUSH
11685: LD_INT 0
11687: EQUAL
11688: PUSH
11689: LD_EXP 3
11693: NOT
11694: AND
11695: IFFALSE 11719
// begin terminal := b ;
11697: LD_ADDR_EXP 3
11701: PUSH
11702: LD_VAR 0 1
11706: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11707: LD_EXP 3
11711: PPUSH
11712: LD_STRING terminal
11714: PPUSH
11715: CALL_OW 500
// end ; end ;
11719: PPOPN 2
11721: END
// on BuildingComplete ( b ) do var i ;
11722: LD_INT 0
11724: PPUSH
// begin if GetSide ( b ) = 3 then
11725: LD_VAR 0 1
11729: PPUSH
11730: CALL_OW 255
11734: PUSH
11735: LD_INT 3
11737: EQUAL
11738: IFFALSE 11778
// for i = 1 to 4 do
11740: LD_ADDR_VAR 0 2
11744: PUSH
11745: DOUBLE
11746: LD_INT 1
11748: DEC
11749: ST_TO_ADDR
11750: LD_INT 4
11752: PUSH
11753: FOR_TO
11754: IFFALSE 11776
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11756: LD_ADDR_EXP 39
11760: PUSH
11761: LD_EXP 39
11765: PPUSH
11766: LD_INT 1
11768: PPUSH
11769: CALL_OW 3
11773: ST_TO_ADDR
11774: GO 11753
11776: POP
11777: POP
// end ;
11778: PPOPN 2
11780: END
// on VehicleConstructed ( veh , fac ) do var i ;
11781: LD_INT 0
11783: PPUSH
// begin if GetSide ( veh ) = 3 then
11784: LD_VAR 0 1
11788: PPUSH
11789: CALL_OW 255
11793: PUSH
11794: LD_INT 3
11796: EQUAL
11797: IFFALSE 11922
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11799: LD_VAR 0 1
11803: PPUSH
11804: CALL_OW 264
11808: PUSH
11809: LD_INT 53
11811: PUSH
11812: LD_INT 52
11814: PUSH
11815: LD_INT 51
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: LIST
11822: IN
11823: NOT
11824: IFFALSE 11842
// ru_force := ru_force ^ veh ;
11826: LD_ADDR_EXP 38
11830: PUSH
11831: LD_EXP 38
11835: PUSH
11836: LD_VAR 0 1
11840: ADD
11841: ST_TO_ADDR
// for i = 1 to 4 do
11842: LD_ADDR_VAR 0 3
11846: PUSH
11847: DOUBLE
11848: LD_INT 1
11850: DEC
11851: ST_TO_ADDR
11852: LD_INT 4
11854: PUSH
11855: FOR_TO
11856: IFFALSE 11878
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11858: LD_ADDR_EXP 40
11862: PUSH
11863: LD_EXP 40
11867: PPUSH
11868: LD_INT 1
11870: PPUSH
11871: CALL_OW 3
11875: ST_TO_ADDR
11876: GO 11855
11878: POP
11879: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11880: LD_VAR 0 1
11884: PPUSH
11885: CALL_OW 264
11889: PUSH
11890: LD_INT 53
11892: EQUAL
11893: IFFALSE 11922
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11895: LD_VAR 0 1
11899: PPUSH
11900: LD_INT 7
11902: PPUSH
11903: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11907: LD_VAR 0 1
11911: PPUSH
11912: LD_INT 170
11914: PPUSH
11915: LD_INT 235
11917: PPUSH
11918: CALL_OW 171
// end ; end ; end ;
11922: PPOPN 3
11924: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11925: LD_VAR 0 1
11929: PUSH
11930: LD_INT 1
11932: EQUAL
11933: PUSH
11934: LD_VAR 0 2
11938: PUSH
11939: LD_INT 2
11941: EQUAL
11942: AND
11943: PUSH
11944: LD_VAR 0 1
11948: PUSH
11949: LD_INT 2
11951: EQUAL
11952: PUSH
11953: LD_VAR 0 2
11957: PUSH
11958: LD_INT 1
11960: EQUAL
11961: AND
11962: OR
11963: IFFALSE 11973
// player_attacked_ar := true ;
11965: LD_ADDR_EXP 16
11969: PUSH
11970: LD_INT 1
11972: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11973: LD_VAR 0 1
11977: PUSH
11978: LD_INT 1
11980: EQUAL
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: LD_INT 4
11989: EQUAL
11990: AND
11991: PUSH
11992: LD_VAR 0 1
11996: PUSH
11997: LD_INT 4
11999: EQUAL
12000: PUSH
12001: LD_VAR 0 2
12005: PUSH
12006: LD_INT 1
12008: EQUAL
12009: AND
12010: OR
12011: IFFALSE 12020
// YouLost ( Traitor ) ;
12013: LD_STRING Traitor
12015: PPUSH
12016: CALL_OW 104
// end ;
12020: PPOPN 2
12022: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12023: LD_VAR 0 1
12027: PUSH
12028: LD_EXP 21
12032: EQUAL
12033: IFFALSE 12042
// YouLost ( JMM ) ;
12035: LD_STRING JMM
12037: PPUSH
12038: CALL_OW 104
// if un = terminal then
12042: LD_VAR 0 1
12046: PUSH
12047: LD_EXP 3
12051: EQUAL
12052: IFFALSE 12061
// YouLost ( Terminal ) ;
12054: LD_STRING Terminal
12056: PPUSH
12057: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12061: LD_VAR 0 1
12065: PPUSH
12066: CALL_OW 264
12070: PUSH
12071: LD_INT 53
12073: EQUAL
12074: IFFALSE 12090
// bulldozerCounter := bulldozerCounter + 1 ;
12076: LD_ADDR_EXP 20
12080: PUSH
12081: LD_EXP 20
12085: PUSH
12086: LD_INT 1
12088: PLUS
12089: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12090: LD_VAR 0 1
12094: PUSH
12095: LD_INT 22
12097: PUSH
12098: LD_INT 3
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 21
12107: PUSH
12108: LD_INT 3
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 69
12123: IN
12124: IFFALSE 12270
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12126: LD_VAR 0 1
12130: PPUSH
12131: CALL_OW 266
12135: PUSH
12136: LD_INT 33
12138: PUSH
12139: LD_INT 26
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: IN
12146: IFFALSE 12205
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12148: LD_ADDR_EXP 39
12152: PUSH
12153: LD_EXP 39
12157: PUSH
12158: LD_VAR 0 1
12162: PPUSH
12163: CALL_OW 266
12167: PUSH
12168: LD_VAR 0 1
12172: PPUSH
12173: CALL_OW 250
12177: PUSH
12178: LD_VAR 0 1
12182: PPUSH
12183: CALL_OW 251
12187: PUSH
12188: LD_VAR 0 1
12192: PPUSH
12193: CALL_OW 254
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: LIST
12203: ADD
12204: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12205: LD_VAR 0 1
12209: PPUSH
12210: CALL_OW 266
12214: PUSH
12215: LD_INT 5
12217: EQUAL
12218: IFFALSE 12270
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12220: LD_ADDR_EXP 39
12224: PUSH
12225: LD_EXP 39
12229: PUSH
12230: LD_INT 4
12232: PUSH
12233: LD_VAR 0 1
12237: PPUSH
12238: CALL_OW 250
12242: PUSH
12243: LD_VAR 0 1
12247: PPUSH
12248: CALL_OW 251
12252: PUSH
12253: LD_VAR 0 1
12257: PPUSH
12258: CALL_OW 254
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: ADD
12269: ST_TO_ADDR
// end ; if un in ru_force then
12270: LD_VAR 0 1
12274: PUSH
12275: LD_EXP 38
12279: IN
12280: IFFALSE 12316
// begin ru_force := ru_force diff un ;
12282: LD_ADDR_EXP 38
12286: PUSH
12287: LD_EXP 38
12291: PUSH
12292: LD_VAR 0 1
12296: DIFF
12297: ST_TO_ADDR
// if ru_force = 0 then
12298: LD_EXP 38
12302: PUSH
12303: LD_INT 0
12305: EQUAL
12306: IFFALSE 12316
// ru_can_attack := false ;
12308: LD_ADDR_EXP 8
12312: PUSH
12313: LD_INT 0
12315: ST_TO_ADDR
// end ; end ;
12316: PPOPN 1
12318: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12319: LD_VAR 0 1
12323: PPUSH
12324: CALL 17646 0 1
// end ; end_of_file
12328: PPOPN 1
12330: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12331: LD_EXP 5
12335: PUSH
12336: LD_EXP 6
12340: AND
12341: IFFALSE 12426
12343: GO 12345
12345: DISABLE
12346: LD_INT 0
12348: PPUSH
// begin enable ;
12349: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12350: LD_ADDR_VAR 0 1
12354: PUSH
12355: LD_INT 60
12357: PUSH
12358: CALL 943 0 0
12362: MINUS
12363: ST_TO_ADDR
// if sib < 0 then
12364: LD_VAR 0 1
12368: PUSH
12369: LD_INT 0
12371: LESS
12372: IFFALSE 12382
// sib := 0 ;
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_INT 0
12381: ST_TO_ADDR
// if not debug then
12382: LD_EXP 2
12386: NOT
12387: IFFALSE 12412
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12389: LD_ADDR_OWVAR 47
12393: PUSH
12394: LD_STRING #Am09-1
12396: PUSH
12397: LD_VAR 0 1
12401: PUSH
12402: LD_EXP 6
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: LIST
12411: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12412: LD_ADDR_EXP 6
12416: PUSH
12417: LD_EXP 6
12421: PUSH
12422: LD_INT 35
12424: MINUS
12425: ST_TO_ADDR
// end ;
12426: PPOPN 1
12428: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12429: LD_EXP 6
12433: PUSH
12434: LD_INT 0
12436: EQUAL
12437: IFFALSE 12449
12439: GO 12441
12441: DISABLE
// display_strings := [ ] ;
12442: LD_ADDR_OWVAR 47
12446: PUSH
12447: EMPTY
12448: ST_TO_ADDR
12449: END
// every 1 1$35 do var i , tmp ;
12450: GO 12452
12452: DISABLE
12453: LD_INT 0
12455: PPUSH
12456: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12457: LD_ADDR_VAR 0 2
12461: PUSH
12462: LD_INT 1155
12464: PUSH
12465: LD_INT 1225
12467: PUSH
12468: LD_INT 1435
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: LIST
12475: PUSH
12476: LD_OWVAR 67
12480: ARRAY
12481: ST_TO_ADDR
// i := 0 ;
12482: LD_ADDR_VAR 0 1
12486: PUSH
12487: LD_INT 0
12489: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12490: LD_INT 1
12492: PPUSH
12493: LD_INT 5
12495: PPUSH
12496: CALL_OW 12
12500: PPUSH
12501: LD_INT 75
12503: PPUSH
12504: LD_INT 75
12506: PPUSH
12507: LD_INT 20
12509: PPUSH
12510: LD_INT 1
12512: PPUSH
12513: CALL_OW 56
// wait ( tmp ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12526: LD_ADDR_VAR 0 2
12530: PUSH
12531: LD_VAR 0 2
12535: PUSH
12536: LD_INT 105
12538: PPUSH
12539: LD_INT 315
12541: PPUSH
12542: CALL_OW 12
12546: PLUS
12547: ST_TO_ADDR
// i := i + 1 ;
12548: LD_ADDR_VAR 0 1
12552: PUSH
12553: LD_VAR 0 1
12557: PUSH
12558: LD_INT 1
12560: PLUS
12561: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12562: LD_VAR 0 1
12566: PUSH
12567: LD_INT 3
12569: MOD
12570: PUSH
12571: LD_INT 0
12573: EQUAL
12574: PUSH
12575: LD_EXP 4
12579: AND
12580: IFFALSE 12618
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12582: LD_INT 2
12584: PPUSH
12585: LD_INT 5
12587: PPUSH
12588: CALL_OW 12
12592: PPUSH
12593: LD_INT 8
12595: PPUSH
12596: LD_INT 1
12598: PPUSH
12599: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12603: LD_INT 665
12605: PPUSH
12606: LD_INT 735
12608: PPUSH
12609: CALL_OW 12
12613: PPUSH
12614: CALL_OW 67
// end ; until tick > game_time ;
12618: LD_OWVAR 1
12622: PUSH
12623: LD_EXP 7
12627: GREATER
12628: IFFALSE 12490
// end ; end_of_file
12630: PPOPN 2
12632: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12633: LD_INT 0
12635: PPUSH
12636: PPUSH
12637: PPUSH
12638: PPUSH
12639: PPUSH
12640: PPUSH
// x := 76 ;
12641: LD_ADDR_VAR 0 5
12645: PUSH
12646: LD_INT 76
12648: ST_TO_ADDR
// y := 147 ;
12649: LD_ADDR_VAR 0 6
12653: PUSH
12654: LD_INT 147
12656: ST_TO_ADDR
// uc_side := 2 ;
12657: LD_ADDR_OWVAR 20
12661: PUSH
12662: LD_INT 2
12664: ST_TO_ADDR
// uc_nation := 2 ;
12665: LD_ADDR_OWVAR 21
12669: PUSH
12670: LD_INT 2
12672: ST_TO_ADDR
// InitHc ;
12673: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12677: LD_INT 1
12679: PPUSH
12680: LD_INT 1
12682: PPUSH
12683: LD_INT 6
12685: PPUSH
12686: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12690: LD_ADDR_OWVAR 26
12694: PUSH
12695: LD_STRING Nicolas Vervecken
12697: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12698: LD_ADDR_OWVAR 33
12702: PUSH
12703: LD_STRING SecondCharsGal
12705: ST_TO_ADDR
// hc_face_number := 3 ;
12706: LD_ADDR_OWVAR 34
12710: PUSH
12711: LD_INT 3
12713: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12714: LD_ADDR_OWVAR 29
12718: PUSH
12719: LD_INT 11
12721: PUSH
12722: LD_INT 10
12724: PUSH
12725: EMPTY
12726: LIST
12727: LIST
12728: ST_TO_ADDR
// Vervecken := CreateHuman ;
12729: LD_ADDR_EXP 29
12733: PUSH
12734: CALL_OW 44
12738: ST_TO_ADDR
// ar_force := Vervecken ;
12739: LD_ADDR_EXP 36
12743: PUSH
12744: LD_EXP 29
12748: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12749: LD_INT 1
12751: PPUSH
12752: LD_INT 2
12754: PPUSH
12755: LD_INT 6
12757: PPUSH
12758: CALL_OW 380
// hc_name := Louis Gali ;
12762: LD_ADDR_OWVAR 26
12766: PUSH
12767: LD_STRING Louis Gali
12769: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12770: LD_ADDR_OWVAR 33
12774: PUSH
12775: LD_STRING SecondCharsGal
12777: ST_TO_ADDR
// hc_face_number := 2 ;
12778: LD_ADDR_OWVAR 34
12782: PUSH
12783: LD_INT 2
12785: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12786: LD_ADDR_OWVAR 29
12790: PUSH
12791: LD_INT 10
12793: PUSH
12794: LD_INT 11
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: ST_TO_ADDR
// Gali := CreateHuman ;
12801: LD_ADDR_EXP 30
12805: PUSH
12806: CALL_OW 44
12810: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12811: LD_ADDR_EXP 36
12815: PUSH
12816: LD_EXP 36
12820: PUSH
12821: LD_EXP 30
12825: ADD
12826: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12827: LD_INT 2
12829: PPUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_INT 6
12835: PPUSH
12836: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12840: LD_ADDR_OWVAR 26
12844: PUSH
12845: LD_STRING Maria Bogdanovic
12847: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12848: LD_ADDR_OWVAR 33
12852: PUSH
12853: LD_STRING SecondCharsGal
12855: ST_TO_ADDR
// hc_face_number := 14 ;
12856: LD_ADDR_OWVAR 34
12860: PUSH
12861: LD_INT 14
12863: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12864: LD_ADDR_OWVAR 29
12868: PUSH
12869: LD_INT 12
12871: PUSH
12872: LD_INT 9
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12879: LD_ADDR_EXP 31
12883: PUSH
12884: CALL_OW 44
12888: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12889: LD_ADDR_EXP 36
12893: PUSH
12894: LD_EXP 36
12898: PUSH
12899: LD_EXP 31
12903: ADD
12904: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12905: LD_INT 1
12907: PPUSH
12908: LD_INT 3
12910: PPUSH
12911: LD_INT 6
12913: PPUSH
12914: CALL_OW 380
// hc_name = Kntor Radomr ;
12918: LD_ADDR_OWVAR 26
12922: PUSH
12923: LD_STRING Kntor Radomr
12925: ST_TO_ADDR
// hc_gallery = sandar ;
12926: LD_ADDR_OWVAR 33
12930: PUSH
12931: LD_STRING sandar
12933: ST_TO_ADDR
// hc_face_number = 12 ;
12934: LD_ADDR_OWVAR 34
12938: PUSH
12939: LD_INT 12
12941: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12942: LD_ADDR_OWVAR 29
12946: PUSH
12947: LD_INT 9
12949: PUSH
12950: LD_INT 9
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: ST_TO_ADDR
// Kantor = CreateHuman ;
12957: LD_ADDR_EXP 32
12961: PUSH
12962: CALL_OW 44
12966: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12967: LD_ADDR_EXP 36
12971: PUSH
12972: LD_EXP 36
12976: PUSH
12977: LD_EXP 32
12981: ADD
12982: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12983: LD_INT 1
12985: PPUSH
12986: LD_INT 3
12988: PPUSH
12989: LD_INT 6
12991: PPUSH
12992: CALL_OW 380
// hc_name = Herczeg Farkas ;
12996: LD_ADDR_OWVAR 26
13000: PUSH
13001: LD_STRING Herczeg Farkas
13003: ST_TO_ADDR
// hc_gallery = sandar ;
13004: LD_ADDR_OWVAR 33
13008: PUSH
13009: LD_STRING sandar
13011: ST_TO_ADDR
// hc_face_number = 28 ;
13012: LD_ADDR_OWVAR 34
13016: PUSH
13017: LD_INT 28
13019: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13020: LD_ADDR_OWVAR 29
13024: PUSH
13025: LD_INT 10
13027: PUSH
13028: LD_INT 9
13030: PUSH
13031: EMPTY
13032: LIST
13033: LIST
13034: ST_TO_ADDR
// Herczeg = CreateHuman ;
13035: LD_ADDR_EXP 33
13039: PUSH
13040: CALL_OW 44
13044: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13045: LD_ADDR_EXP 36
13049: PUSH
13050: LD_EXP 36
13054: PUSH
13055: LD_EXP 33
13059: ADD
13060: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13061: LD_INT 1
13063: PPUSH
13064: LD_INT 1
13066: PPUSH
13067: LD_INT 6
13069: PPUSH
13070: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13074: LD_ADDR_OWVAR 26
13078: PUSH
13079: LD_STRING Ronn Horntvedt
13081: ST_TO_ADDR
// hc_gallery = sandar ;
13082: LD_ADDR_OWVAR 33
13086: PUSH
13087: LD_STRING sandar
13089: ST_TO_ADDR
// hc_face_number = 29 ;
13090: LD_ADDR_OWVAR 34
13094: PUSH
13095: LD_INT 29
13097: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13098: LD_ADDR_OWVAR 29
13102: PUSH
13103: LD_INT 11
13105: PUSH
13106: LD_INT 11
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: ST_TO_ADDR
// Ronn = CreateHuman ;
13113: LD_ADDR_EXP 34
13117: PUSH
13118: CALL_OW 44
13122: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13123: LD_ADDR_EXP 36
13127: PUSH
13128: LD_EXP 36
13132: PUSH
13133: LD_EXP 34
13137: ADD
13138: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13139: LD_INT 2
13141: PPUSH
13142: LD_INT 3
13144: PPUSH
13145: LD_INT 6
13147: PPUSH
13148: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13152: LD_ADDR_OWVAR 26
13156: PUSH
13157: LD_STRING Mia D. Mathiasen
13159: ST_TO_ADDR
// hc_gallery = sandar ;
13160: LD_ADDR_OWVAR 33
13164: PUSH
13165: LD_STRING sandar
13167: ST_TO_ADDR
// hc_face_number = 31 ;
13168: LD_ADDR_OWVAR 34
13172: PUSH
13173: LD_INT 31
13175: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13176: LD_ADDR_OWVAR 29
13180: PUSH
13181: LD_INT 10
13183: PUSH
13184: LD_INT 10
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: ST_TO_ADDR
// Mia = CreateHuman ;
13191: LD_ADDR_EXP 35
13195: PUSH
13196: CALL_OW 44
13200: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13201: LD_ADDR_EXP 36
13205: PUSH
13206: LD_EXP 36
13210: PUSH
13211: LD_EXP 35
13215: ADD
13216: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13217: LD_ADDR_VAR 0 3
13221: PUSH
13222: LD_VAR 0 3
13226: PUSH
13227: LD_INT 2
13229: PPUSH
13230: LD_INT 2
13232: PPUSH
13233: LD_INT 14
13235: PPUSH
13236: LD_INT 1
13238: PPUSH
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 32
13244: PPUSH
13245: LD_INT 30
13247: PPUSH
13248: CALL 423 0 7
13252: ADD
13253: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13254: LD_ADDR_VAR 0 3
13258: PUSH
13259: LD_VAR 0 3
13263: PUSH
13264: LD_INT 2
13266: PPUSH
13267: LD_INT 2
13269: PPUSH
13270: LD_INT 14
13272: PPUSH
13273: LD_INT 1
13275: PPUSH
13276: LD_INT 1
13278: PPUSH
13279: LD_INT 27
13281: PPUSH
13282: LD_INT 30
13284: PPUSH
13285: CALL 423 0 7
13289: ADD
13290: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13291: LD_ADDR_VAR 0 3
13295: PUSH
13296: LD_VAR 0 3
13300: PUSH
13301: LD_INT 2
13303: PPUSH
13304: LD_INT 2
13306: PPUSH
13307: LD_INT 14
13309: PPUSH
13310: LD_INT 1
13312: PPUSH
13313: LD_INT 1
13315: PPUSH
13316: LD_INT 25
13318: PPUSH
13319: LD_INT 33
13321: PPUSH
13322: CALL 423 0 7
13326: ADD
13327: ST_TO_ADDR
// tmp := tmp diff 0 ;
13328: LD_ADDR_VAR 0 3
13332: PUSH
13333: LD_VAR 0 3
13337: PUSH
13338: LD_INT 0
13340: DIFF
13341: ST_TO_ADDR
// for i in ar_force do
13342: LD_ADDR_VAR 0 4
13346: PUSH
13347: LD_EXP 36
13351: PUSH
13352: FOR_IN
13353: IFFALSE 13496
// begin if GetClass ( i ) = 3 then
13355: LD_VAR 0 4
13359: PPUSH
13360: CALL_OW 257
13364: PUSH
13365: LD_INT 3
13367: EQUAL
13368: IFFALSE 13450
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13370: LD_VAR 0 3
13374: PUSH
13375: LD_INT 1
13377: ARRAY
13378: PPUSH
13379: LD_INT 1
13381: PPUSH
13382: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13386: LD_VAR 0 3
13390: PUSH
13391: LD_INT 1
13393: ARRAY
13394: PPUSH
13395: LD_VAR 0 5
13399: PPUSH
13400: LD_VAR 0 6
13404: PPUSH
13405: LD_INT 0
13407: PPUSH
13408: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13412: LD_VAR 0 4
13416: PPUSH
13417: LD_VAR 0 3
13421: PUSH
13422: LD_INT 1
13424: ARRAY
13425: PPUSH
13426: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13430: LD_ADDR_VAR 0 3
13434: PUSH
13435: LD_VAR 0 3
13439: PPUSH
13440: LD_INT 1
13442: PPUSH
13443: CALL_OW 3
13447: ST_TO_ADDR
// end else
13448: GO 13472
// PlaceUnitXY ( i , x , y , false ) ;
13450: LD_VAR 0 4
13454: PPUSH
13455: LD_VAR 0 5
13459: PPUSH
13460: LD_VAR 0 6
13464: PPUSH
13465: LD_INT 0
13467: PPUSH
13468: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13472: LD_VAR 0 4
13476: PPUSH
13477: LD_INT 86
13479: PPUSH
13480: LD_INT 121
13482: PPUSH
13483: CALL_OW 111
// wait ( 0 0$2 ) ;
13487: LD_INT 70
13489: PPUSH
13490: CALL_OW 67
// end ;
13494: GO 13352
13496: POP
13497: POP
// ar_force := ar_force ^ tmp ;
13498: LD_ADDR_EXP 36
13502: PUSH
13503: LD_EXP 36
13507: PUSH
13508: LD_VAR 0 3
13512: ADD
13513: ST_TO_ADDR
// ar_spawned := true ;
13514: LD_ADDR_EXP 11
13518: PUSH
13519: LD_INT 1
13521: ST_TO_ADDR
// end ; end_of_file
13522: LD_VAR 0 1
13526: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13527: LD_INT 0
13529: PPUSH
13530: PPUSH
13531: PPUSH
13532: PPUSH
13533: PPUSH
13534: PPUSH
13535: PPUSH
// InitHc ;
13536: CALL_OW 19
// uc_side := 3 ;
13540: LD_ADDR_OWVAR 20
13544: PUSH
13545: LD_INT 3
13547: ST_TO_ADDR
// uc_nation := 3 ;
13548: LD_ADDR_OWVAR 21
13552: PUSH
13553: LD_INT 3
13555: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13556: LD_ADDR_VAR 0 5
13560: PUSH
13561: LD_INT 5
13563: PUSH
13564: LD_INT 6
13566: PUSH
13567: LD_INT 7
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: LIST
13574: PUSH
13575: LD_OWVAR 67
13579: ARRAY
13580: ST_TO_ADDR
// ru_force := [ ] ;
13581: LD_ADDR_EXP 38
13585: PUSH
13586: EMPTY
13587: ST_TO_ADDR
// ru_rebuild := [ ] ;
13588: LD_ADDR_EXP 39
13592: PUSH
13593: EMPTY
13594: ST_TO_ADDR
// ru_produce_list := [ ] ;
13595: LD_ADDR_EXP 40
13599: PUSH
13600: EMPTY
13601: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13602: LD_ADDR_VAR 0 6
13606: PUSH
13607: LD_INT 22
13609: PUSH
13610: LD_INT 3
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PUSH
13617: LD_INT 30
13619: PUSH
13620: LD_INT 8
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PPUSH
13631: CALL_OW 69
13635: PUSH
13636: LD_INT 1
13638: ARRAY
13639: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13640: LD_ADDR_VAR 0 4
13644: PUSH
13645: LD_INT 43
13647: PUSH
13648: LD_INT 46
13650: PUSH
13651: LD_INT 45
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: LIST
13658: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13659: LD_ADDR_VAR 0 7
13663: PUSH
13664: LD_INT 22
13666: PUSH
13667: LD_INT 3
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: PUSH
13674: LD_INT 30
13676: PUSH
13677: LD_INT 1
13679: PUSH
13680: EMPTY
13681: LIST
13682: LIST
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: PPUSH
13688: CALL_OW 69
13692: PUSH
13693: LD_INT 1
13695: ARRAY
13696: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13697: LD_VAR 0 7
13701: PPUSH
13702: CALL_OW 274
13706: PPUSH
13707: LD_INT 1
13709: PPUSH
13710: LD_INT 5000
13712: PPUSH
13713: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13717: LD_VAR 0 7
13721: PPUSH
13722: CALL_OW 274
13726: PPUSH
13727: LD_INT 2
13729: PPUSH
13730: LD_INT 1000
13732: PPUSH
13733: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13737: LD_VAR 0 7
13741: PPUSH
13742: CALL_OW 274
13746: PPUSH
13747: LD_INT 3
13749: PPUSH
13750: LD_INT 30
13752: PPUSH
13753: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13757: LD_ADDR_VAR 0 2
13761: PUSH
13762: LD_INT 22
13764: PUSH
13765: LD_INT 3
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PUSH
13772: LD_INT 30
13774: PUSH
13775: LD_INT 33
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PUSH
13782: EMPTY
13783: LIST
13784: LIST
13785: PPUSH
13786: CALL_OW 69
13790: PUSH
13791: FOR_IN
13792: IFFALSE 13824
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13794: LD_VAR 0 2
13798: PPUSH
13799: LD_VAR 0 4
13803: PUSH
13804: LD_VAR 0 2
13808: PUSH
13809: LD_INT 3
13811: MOD
13812: PUSH
13813: LD_INT 1
13815: PLUS
13816: ARRAY
13817: PPUSH
13818: CALL_OW 431
// end ;
13822: GO 13791
13824: POP
13825: POP
// for i = 1 to 4 do
13826: LD_ADDR_VAR 0 2
13830: PUSH
13831: DOUBLE
13832: LD_INT 1
13834: DEC
13835: ST_TO_ADDR
13836: LD_INT 4
13838: PUSH
13839: FOR_TO
13840: IFFALSE 13901
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13842: LD_INT 0
13844: PPUSH
13845: LD_INT 9
13847: PPUSH
13848: LD_VAR 0 5
13852: PPUSH
13853: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13857: CALL_OW 44
13861: PPUSH
13862: LD_INT 22
13864: PUSH
13865: LD_INT 3
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: PUSH
13872: LD_INT 30
13874: PUSH
13875: LD_INT 5
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PPUSH
13886: CALL_OW 69
13890: PUSH
13891: LD_INT 1
13893: ARRAY
13894: PPUSH
13895: CALL_OW 52
// end ;
13899: GO 13839
13901: POP
13902: POP
// for i = 1 to 5 do
13903: LD_ADDR_VAR 0 2
13907: PUSH
13908: DOUBLE
13909: LD_INT 1
13911: DEC
13912: ST_TO_ADDR
13913: LD_INT 5
13915: PUSH
13916: FOR_TO
13917: IFFALSE 13978
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13919: LD_INT 0
13921: PPUSH
13922: LD_INT 3
13924: PPUSH
13925: LD_VAR 0 5
13929: PPUSH
13930: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13934: CALL_OW 44
13938: PPUSH
13939: LD_INT 22
13941: PUSH
13942: LD_INT 3
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: LD_INT 30
13951: PUSH
13952: LD_INT 3
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PPUSH
13963: CALL_OW 69
13967: PUSH
13968: LD_INT 1
13970: ARRAY
13971: PPUSH
13972: CALL_OW 52
// end ;
13976: GO 13916
13978: POP
13979: POP
// for i = 1 to 4 do
13980: LD_ADDR_VAR 0 2
13984: PUSH
13985: DOUBLE
13986: LD_INT 1
13988: DEC
13989: ST_TO_ADDR
13990: LD_INT 4
13992: PUSH
13993: FOR_TO
13994: IFFALSE 14055
// begin PrepareHuman ( false , class_engineer , skill ) ;
13996: LD_INT 0
13998: PPUSH
13999: LD_INT 2
14001: PPUSH
14002: LD_VAR 0 5
14006: PPUSH
14007: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14011: CALL_OW 44
14015: PPUSH
14016: LD_INT 22
14018: PUSH
14019: LD_INT 3
14021: PUSH
14022: EMPTY
14023: LIST
14024: LIST
14025: PUSH
14026: LD_INT 30
14028: PUSH
14029: LD_INT 1
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: PUSH
14045: LD_INT 1
14047: ARRAY
14048: PPUSH
14049: CALL_OW 52
// end ;
14053: GO 13993
14055: POP
14056: POP
// for i = 1 to 3 do
14057: LD_ADDR_VAR 0 2
14061: PUSH
14062: DOUBLE
14063: LD_INT 1
14065: DEC
14066: ST_TO_ADDR
14067: LD_INT 3
14069: PUSH
14070: FOR_TO
14071: IFFALSE 14104
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14073: LD_INT 0
14075: PPUSH
14076: LD_INT 4
14078: PPUSH
14079: LD_VAR 0 5
14083: PPUSH
14084: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14088: CALL_OW 44
14092: PPUSH
14093: LD_VAR 0 6
14097: PPUSH
14098: CALL_OW 52
// end ;
14102: GO 14070
14104: POP
14105: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14106: LD_ADDR_EXP 37
14110: PUSH
14111: LD_STRING Yakotich
14113: PPUSH
14114: LD_EXP 2
14118: NOT
14119: PPUSH
14120: LD_STRING 
14122: PPUSH
14123: CALL 360 0 3
14127: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14128: LD_EXP 37
14132: PPUSH
14133: LD_INT 74
14135: PPUSH
14136: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14140: LD_VAR 0 6
14144: PPUSH
14145: LD_INT 49
14147: PPUSH
14148: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14152: LD_VAR 0 6
14156: PPUSH
14157: LD_INT 50
14159: PPUSH
14160: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14164: LD_VAR 0 6
14168: PPUSH
14169: LD_INT 51
14171: PPUSH
14172: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14176: LD_VAR 0 6
14180: PPUSH
14181: LD_INT 52
14183: PPUSH
14184: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14188: LD_VAR 0 6
14192: PPUSH
14193: LD_INT 69
14195: PPUSH
14196: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14200: LD_VAR 0 6
14204: PPUSH
14205: LD_INT 39
14207: PPUSH
14208: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14212: LD_VAR 0 6
14216: PPUSH
14217: LD_INT 34
14219: PPUSH
14220: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14224: LD_VAR 0 6
14228: PPUSH
14229: LD_INT 40
14231: PPUSH
14232: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14236: LD_VAR 0 6
14240: PPUSH
14241: LD_INT 57
14243: PPUSH
14244: CALL_OW 184
// if Difficulty > 1 then
14248: LD_OWVAR 67
14252: PUSH
14253: LD_INT 1
14255: GREATER
14256: IFFALSE 14270
// AddComResearch ( lab , tech_comp2 ) ;
14258: LD_VAR 0 6
14262: PPUSH
14263: LD_INT 58
14265: PPUSH
14266: CALL_OW 184
// end ;
14270: LD_VAR 0 1
14274: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14275: LD_INT 7
14277: PPUSH
14278: CALL_OW 353
14282: PUSH
14283: LD_INT 3
14285: GREATER
14286: PUSH
14287: LD_INT 22
14289: PUSH
14290: LD_INT 3
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: PUSH
14297: LD_INT 34
14299: PUSH
14300: LD_INT 53
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PPUSH
14311: CALL_OW 69
14315: NOT
14316: AND
14317: IFFALSE 14352
14319: GO 14321
14321: DISABLE
// begin enable ;
14322: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14323: LD_ADDR_EXP 40
14327: PUSH
14328: LD_EXP 40
14332: PUSH
14333: LD_INT 24
14335: PUSH
14336: LD_INT 1
14338: PUSH
14339: LD_INT 3
14341: PUSH
14342: LD_INT 53
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: ADD
14351: ST_TO_ADDR
// end ;
14352: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14353: LD_INT 22
14355: PUSH
14356: LD_INT 3
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 3
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PPUSH
14377: CALL_OW 69
14381: IFFALSE 15159
14383: GO 14385
14385: DISABLE
14386: LD_INT 0
14388: PPUSH
14389: PPUSH
14390: PPUSH
14391: PPUSH
14392: PPUSH
14393: PPUSH
14394: PPUSH
14395: PPUSH
// begin enable ;
14396: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14397: LD_ADDR_VAR 0 3
14401: PUSH
14402: LD_INT 22
14404: PUSH
14405: LD_INT 3
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: PUSH
14412: LD_INT 21
14414: PUSH
14415: LD_INT 3
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PUSH
14422: LD_INT 3
14424: PUSH
14425: LD_INT 24
14427: PUSH
14428: LD_INT 1000
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: LIST
14443: PPUSH
14444: CALL_OW 69
14448: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14449: LD_ADDR_VAR 0 4
14453: PUSH
14454: LD_INT 22
14456: PUSH
14457: LD_INT 3
14459: PUSH
14460: EMPTY
14461: LIST
14462: LIST
14463: PUSH
14464: LD_INT 25
14466: PUSH
14467: LD_INT 2
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: PPUSH
14478: CALL_OW 69
14482: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14483: LD_ADDR_VAR 0 5
14487: PUSH
14488: LD_INT 22
14490: PUSH
14491: LD_INT 3
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: LD_INT 30
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PPUSH
14512: CALL_OW 69
14516: PUSH
14517: LD_INT 1
14519: ARRAY
14520: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14521: LD_ADDR_VAR 0 8
14525: PUSH
14526: LD_INT 22
14528: PUSH
14529: LD_INT 3
14531: PUSH
14532: EMPTY
14533: LIST
14534: LIST
14535: PUSH
14536: LD_INT 2
14538: PUSH
14539: LD_INT 30
14541: PUSH
14542: LD_INT 6
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: PUSH
14549: LD_INT 30
14551: PUSH
14552: LD_INT 7
14554: PUSH
14555: EMPTY
14556: LIST
14557: LIST
14558: PUSH
14559: LD_INT 30
14561: PUSH
14562: LD_INT 8
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: PPUSH
14579: CALL_OW 69
14583: PUSH
14584: LD_INT 1
14586: ARRAY
14587: ST_TO_ADDR
// if not engs then
14588: LD_VAR 0 4
14592: NOT
14593: IFFALSE 14597
// exit ;
14595: GO 15159
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14597: LD_ADDR_VAR 0 6
14601: PUSH
14602: LD_VAR 0 4
14606: PPUSH
14607: LD_INT 3
14609: PUSH
14610: LD_INT 24
14612: PUSH
14613: LD_INT 600
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: PPUSH
14624: CALL_OW 72
14628: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14629: LD_ADDR_VAR 0 7
14633: PUSH
14634: LD_INT 22
14636: PUSH
14637: LD_INT 3
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PUSH
14644: LD_INT 25
14646: PUSH
14647: LD_INT 4
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PPUSH
14658: CALL_OW 69
14662: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14663: LD_VAR 0 3
14667: NOT
14668: PUSH
14669: LD_EXP 39
14673: NOT
14674: AND
14675: IFFALSE 14735
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14677: LD_VAR 0 4
14681: PPUSH
14682: LD_INT 3
14684: PUSH
14685: LD_INT 54
14687: PUSH
14688: EMPTY
14689: LIST
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: PPUSH
14695: CALL_OW 72
14699: IFFALSE 14733
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14701: LD_VAR 0 4
14705: PPUSH
14706: LD_INT 3
14708: PUSH
14709: LD_INT 54
14711: PUSH
14712: EMPTY
14713: LIST
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PPUSH
14719: CALL_OW 72
14723: PPUSH
14724: LD_VAR 0 5
14728: PPUSH
14729: CALL_OW 120
// exit ;
14733: GO 15159
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14735: LD_VAR 0 4
14739: PPUSH
14740: LD_INT 54
14742: PUSH
14743: EMPTY
14744: LIST
14745: PPUSH
14746: CALL_OW 72
14750: IFFALSE 14772
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14752: LD_VAR 0 4
14756: PPUSH
14757: LD_INT 54
14759: PUSH
14760: EMPTY
14761: LIST
14762: PPUSH
14763: CALL_OW 72
14767: PPUSH
14768: CALL_OW 122
// if not tmp then
14772: LD_VAR 0 3
14776: NOT
14777: IFFALSE 14909
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14779: LD_INT 81
14781: PUSH
14782: LD_INT 3
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: PUSH
14789: LD_INT 92
14791: PUSH
14792: LD_INT 147
14794: PUSH
14795: LD_INT 212
14797: PUSH
14798: LD_INT 30
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: PUSH
14807: EMPTY
14808: LIST
14809: LIST
14810: PPUSH
14811: CALL_OW 69
14815: NOT
14816: IFFALSE 14909
// begin if not HasTask ( engs [ 1 ] ) then
14818: LD_VAR 0 4
14822: PUSH
14823: LD_INT 1
14825: ARRAY
14826: PPUSH
14827: CALL_OW 314
14831: NOT
14832: IFFALSE 14909
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14834: LD_ADDR_VAR 0 2
14838: PUSH
14839: LD_VAR 0 4
14843: PPUSH
14844: LD_EXP 39
14848: PUSH
14849: LD_INT 1
14851: ARRAY
14852: PPUSH
14853: LD_EXP 39
14857: PUSH
14858: LD_INT 2
14860: ARRAY
14861: PPUSH
14862: LD_EXP 39
14866: PUSH
14867: LD_INT 3
14869: ARRAY
14870: PPUSH
14871: LD_EXP 39
14875: PUSH
14876: LD_INT 4
14878: ARRAY
14879: PPUSH
14880: CALL_OW 145
14884: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14885: LD_VAR 0 2
14889: PPUSH
14890: CALL_OW 266
14894: PUSH
14895: LD_INT 4
14897: EQUAL
14898: IFFALSE 14909
// AddComUpgrade ( i ) ;
14900: LD_VAR 0 2
14904: PPUSH
14905: CALL_OW 206
// end ; end ; end ; for i in engs do
14909: LD_ADDR_VAR 0 2
14913: PUSH
14914: LD_VAR 0 4
14918: PUSH
14919: FOR_IN
14920: IFFALSE 15038
// begin if i in to_heal and sci then
14922: LD_VAR 0 2
14926: PUSH
14927: LD_VAR 0 6
14931: IN
14932: PUSH
14933: LD_VAR 0 7
14937: AND
14938: IFFALSE 14989
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14940: LD_VAR 0 2
14944: PPUSH
14945: LD_INT 149
14947: PPUSH
14948: LD_INT 220
14950: PPUSH
14951: CALL_OW 297
14955: PUSH
14956: LD_INT 5
14958: LESS
14959: IFFALSE 14963
// continue ;
14961: GO 14919
// ComMoveXY ( i , 149 , 220 ) ;
14963: LD_VAR 0 2
14967: PPUSH
14968: LD_INT 149
14970: PPUSH
14971: LD_INT 220
14973: PPUSH
14974: CALL_OW 111
// AddComHold ( i ) ;
14978: LD_VAR 0 2
14982: PPUSH
14983: CALL_OW 200
// end else
14987: GO 15036
// if not HasTask ( i ) or WantsToAttack ( i ) then
14989: LD_VAR 0 2
14993: PPUSH
14994: CALL_OW 314
14998: NOT
14999: PUSH
15000: LD_VAR 0 2
15004: PPUSH
15005: CALL_OW 319
15009: OR
15010: IFFALSE 15036
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15012: LD_VAR 0 2
15016: PPUSH
15017: LD_VAR 0 3
15021: PPUSH
15022: LD_VAR 0 2
15026: PPUSH
15027: CALL_OW 74
15031: PPUSH
15032: CALL_OW 130
// end ;
15036: GO 14919
15038: POP
15039: POP
// if to_heal and sci then
15040: LD_VAR 0 6
15044: PUSH
15045: LD_VAR 0 7
15049: AND
15050: IFFALSE 15111
// begin if UnitFilter ( sci , [ f_inside ] ) then
15052: LD_VAR 0 7
15056: PPUSH
15057: LD_INT 54
15059: PUSH
15060: EMPTY
15061: LIST
15062: PPUSH
15063: CALL_OW 72
15067: IFFALSE 15091
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15069: LD_VAR 0 7
15073: PPUSH
15074: LD_INT 54
15076: PUSH
15077: EMPTY
15078: LIST
15079: PPUSH
15080: CALL_OW 72
15084: PPUSH
15085: CALL_OW 122
15089: GO 15109
// ComHeal ( sci , to_heal [ 1 ] ) ;
15091: LD_VAR 0 7
15095: PPUSH
15096: LD_VAR 0 6
15100: PUSH
15101: LD_INT 1
15103: ARRAY
15104: PPUSH
15105: CALL_OW 128
// end else
15109: GO 15159
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15111: LD_VAR 0 7
15115: PPUSH
15116: LD_INT 56
15118: PUSH
15119: EMPTY
15120: LIST
15121: PPUSH
15122: CALL_OW 72
15126: PUSH
15127: LD_VAR 0 8
15131: AND
15132: IFFALSE 15159
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15134: LD_VAR 0 7
15138: PPUSH
15139: LD_INT 56
15141: PUSH
15142: EMPTY
15143: LIST
15144: PPUSH
15145: CALL_OW 72
15149: PPUSH
15150: LD_VAR 0 8
15154: PPUSH
15155: CALL_OW 120
// end ;
15159: PPOPN 8
15161: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15162: LD_INT 22
15164: PUSH
15165: LD_INT 3
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 30
15174: PUSH
15175: LD_INT 3
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: PPUSH
15186: CALL_OW 69
15190: PUSH
15191: LD_EXP 40
15195: AND
15196: IFFALSE 15322
15198: GO 15200
15200: DISABLE
15201: LD_INT 0
15203: PPUSH
15204: PPUSH
15205: PPUSH
// begin enable ;
15206: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15207: LD_ADDR_VAR 0 3
15211: PUSH
15212: LD_INT 22
15214: PUSH
15215: LD_INT 3
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: PUSH
15222: LD_INT 30
15224: PUSH
15225: LD_INT 3
15227: PUSH
15228: EMPTY
15229: LIST
15230: LIST
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PPUSH
15236: CALL_OW 69
15240: PUSH
15241: LD_INT 1
15243: ARRAY
15244: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15245: LD_VAR 0 3
15249: PPUSH
15250: CALL_OW 313
15254: PUSH
15255: LD_INT 0
15257: EQUAL
15258: IFFALSE 15262
// exit ;
15260: GO 15322
// if BuildingStatus ( fac ) = bs_idle then
15262: LD_VAR 0 3
15266: PPUSH
15267: CALL_OW 461
15271: PUSH
15272: LD_INT 2
15274: EQUAL
15275: IFFALSE 15322
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15277: LD_VAR 0 3
15281: PPUSH
15282: LD_EXP 40
15286: PUSH
15287: LD_INT 1
15289: ARRAY
15290: PPUSH
15291: LD_EXP 40
15295: PUSH
15296: LD_INT 2
15298: ARRAY
15299: PPUSH
15300: LD_EXP 40
15304: PUSH
15305: LD_INT 3
15307: ARRAY
15308: PPUSH
15309: LD_EXP 40
15313: PUSH
15314: LD_INT 4
15316: ARRAY
15317: PPUSH
15318: CALL_OW 125
// end ;
15322: PPOPN 3
15324: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15325: LD_INT 0
15327: PPUSH
15328: PPUSH
15329: PPUSH
15330: PPUSH
15331: PPUSH
// uc_side := 3 ;
15332: LD_ADDR_OWVAR 20
15336: PUSH
15337: LD_INT 3
15339: ST_TO_ADDR
// uc_nation := 3 ;
15340: LD_ADDR_OWVAR 21
15344: PUSH
15345: LD_INT 3
15347: ST_TO_ADDR
// ru_can_attack := false ;
15348: LD_ADDR_EXP 8
15352: PUSH
15353: LD_INT 0
15355: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15356: LD_ADDR_VAR 0 6
15360: PUSH
15361: LD_INT 22
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 30
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if fac then
15390: LD_VAR 0 6
15394: IFFALSE 15546
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15396: LD_ADDR_EXP 40
15400: PUSH
15401: LD_INT 24
15403: PUSH
15404: LD_INT 1
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 43
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: ST_TO_ADDR
// if wave > 1 then
15419: LD_VAR 0 1
15423: PUSH
15424: LD_INT 1
15426: GREATER
15427: IFFALSE 15480
// for i = 1 to Difficulty do
15429: LD_ADDR_VAR 0 3
15433: PUSH
15434: DOUBLE
15435: LD_INT 1
15437: DEC
15438: ST_TO_ADDR
15439: LD_OWVAR 67
15443: PUSH
15444: FOR_TO
15445: IFFALSE 15478
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15447: LD_ADDR_EXP 40
15451: PUSH
15452: LD_EXP 40
15456: PUSH
15457: LD_INT 24
15459: PUSH
15460: LD_INT 1
15462: PUSH
15463: LD_INT 3
15465: PUSH
15466: LD_INT 45
15468: PUSH
15469: EMPTY
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: ADD
15475: ST_TO_ADDR
15476: GO 15444
15478: POP
15479: POP
// repeat wait ( 0 0$1 ) ;
15480: LD_INT 35
15482: PPUSH
15483: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15487: LD_EXP 40
15491: PUSH
15492: LD_INT 4
15494: LESS
15495: PUSH
15496: LD_VAR 0 6
15500: PUSH
15501: LD_INT 1
15503: ARRAY
15504: PPUSH
15505: CALL_OW 313
15509: PUSH
15510: LD_INT 0
15512: EQUAL
15513: OR
15514: PUSH
15515: LD_VAR 0 6
15519: PUSH
15520: LD_INT 1
15522: ARRAY
15523: PPUSH
15524: CALL_OW 461
15528: PUSH
15529: LD_INT 8
15531: PUSH
15532: LD_INT 6
15534: PUSH
15535: LD_INT 7
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: LIST
15542: IN
15543: OR
15544: IFFALSE 15480
// end ; case wave of 1 :
15546: LD_VAR 0 1
15550: PUSH
15551: LD_INT 1
15553: DOUBLE
15554: EQUAL
15555: IFTRUE 15559
15557: GO 15644
15559: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15560: LD_ADDR_VAR 0 3
15564: PUSH
15565: DOUBLE
15566: LD_INT 1
15568: DEC
15569: ST_TO_ADDR
15570: LD_INT 2
15572: PUSH
15573: LD_INT 3
15575: PUSH
15576: LD_INT 4
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: PUSH
15584: LD_OWVAR 67
15588: ARRAY
15589: PUSH
15590: FOR_TO
15591: IFFALSE 15599
// Sold ;
15593: CALL 15870 0 0
15597: GO 15590
15599: POP
15600: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15601: LD_ADDR_VAR 0 3
15605: PUSH
15606: DOUBLE
15607: LD_INT 1
15609: DEC
15610: ST_TO_ADDR
15611: LD_INT 2
15613: PUSH
15614: LD_INT 3
15616: PUSH
15617: LD_INT 3
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: LIST
15624: PUSH
15625: LD_OWVAR 67
15629: ARRAY
15630: PUSH
15631: FOR_TO
15632: IFFALSE 15640
// Tank ;
15634: CALL 16000 0 0
15638: GO 15631
15640: POP
15641: POP
// end ; 2 .. 9 :
15642: GO 15857
15644: LD_INT 2
15646: DOUBLE
15647: GREATEREQUAL
15648: IFFALSE 15656
15650: LD_INT 9
15652: DOUBLE
15653: LESSEQUAL
15654: IFTRUE 15658
15656: GO 15763
15658: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15659: LD_ADDR_VAR 0 3
15663: PUSH
15664: DOUBLE
15665: LD_INT 1
15667: DEC
15668: ST_TO_ADDR
15669: LD_INT 2
15671: PUSH
15672: LD_INT 4
15674: PUSH
15675: LD_INT 5
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: LIST
15682: PUSH
15683: LD_OWVAR 67
15687: ARRAY
15688: PUSH
15689: LD_VAR 0 1
15693: PUSH
15694: LD_INT 2
15696: DIV
15697: PLUS
15698: PUSH
15699: FOR_TO
15700: IFFALSE 15708
// Sold ;
15702: CALL 15870 0 0
15706: GO 15699
15708: POP
15709: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15710: LD_ADDR_VAR 0 3
15714: PUSH
15715: DOUBLE
15716: LD_INT 1
15718: DEC
15719: ST_TO_ADDR
15720: LD_INT 2
15722: PUSH
15723: LD_INT 3
15725: PUSH
15726: LD_INT 3
15728: PUSH
15729: EMPTY
15730: LIST
15731: LIST
15732: LIST
15733: PUSH
15734: LD_OWVAR 67
15738: ARRAY
15739: PUSH
15740: LD_VAR 0 1
15744: PUSH
15745: LD_INT 2
15747: DIV
15748: PLUS
15749: PUSH
15750: FOR_TO
15751: IFFALSE 15759
// Tank ;
15753: CALL 16000 0 0
15757: GO 15750
15759: POP
15760: POP
// end ; 10 :
15761: GO 15857
15763: LD_INT 10
15765: DOUBLE
15766: EQUAL
15767: IFTRUE 15771
15769: GO 15856
15771: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15772: LD_ADDR_VAR 0 3
15776: PUSH
15777: DOUBLE
15778: LD_INT 1
15780: DEC
15781: ST_TO_ADDR
15782: LD_INT 10
15784: PUSH
15785: LD_INT 12
15787: PUSH
15788: LD_INT 14
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: LIST
15795: PUSH
15796: LD_OWVAR 67
15800: ARRAY
15801: PUSH
15802: FOR_TO
15803: IFFALSE 15811
// Sold ;
15805: CALL 15870 0 0
15809: GO 15802
15811: POP
15812: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15813: LD_ADDR_VAR 0 3
15817: PUSH
15818: DOUBLE
15819: LD_INT 1
15821: DEC
15822: ST_TO_ADDR
15823: LD_INT 11
15825: PUSH
15826: LD_INT 13
15828: PUSH
15829: LD_INT 15
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: LIST
15836: PUSH
15837: LD_OWVAR 67
15841: ARRAY
15842: PUSH
15843: FOR_TO
15844: IFFALSE 15852
// Tank ;
15846: CALL 16000 0 0
15850: GO 15843
15852: POP
15853: POP
// end ; end ;
15854: GO 15857
15856: POP
// ru_can_attack := true ;
15857: LD_ADDR_EXP 8
15861: PUSH
15862: LD_INT 1
15864: ST_TO_ADDR
// end ;
15865: LD_VAR 0 2
15869: RET
// function Sold ( ) ; var un , skill ; begin
15870: LD_INT 0
15872: PPUSH
15873: PPUSH
15874: PPUSH
// uc_side := 3 ;
15875: LD_ADDR_OWVAR 20
15879: PUSH
15880: LD_INT 3
15882: ST_TO_ADDR
// uc_nation := 3 ;
15883: LD_ADDR_OWVAR 21
15887: PUSH
15888: LD_INT 3
15890: ST_TO_ADDR
// InitHc ;
15891: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15895: LD_ADDR_VAR 0 3
15899: PUSH
15900: LD_INT 5
15902: PUSH
15903: LD_INT 6
15905: PUSH
15906: LD_INT 7
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: LIST
15913: PUSH
15914: LD_OWVAR 67
15918: ARRAY
15919: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15920: LD_INT 0
15922: PPUSH
15923: LD_INT 1
15925: PUSH
15926: LD_INT 9
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: LD_INT 1
15935: PPUSH
15936: LD_INT 2
15938: PPUSH
15939: CALL_OW 12
15943: ARRAY
15944: PPUSH
15945: LD_VAR 0 3
15949: PPUSH
15950: CALL_OW 380
// un := CreateHuman ;
15954: LD_ADDR_VAR 0 2
15958: PUSH
15959: CALL_OW 44
15963: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15964: LD_VAR 0 2
15968: PPUSH
15969: LD_INT 4
15971: PPUSH
15972: LD_INT 0
15974: PPUSH
15975: CALL_OW 49
// ru_force := ru_force ^ un ;
15979: LD_ADDR_EXP 38
15983: PUSH
15984: LD_EXP 38
15988: PUSH
15989: LD_VAR 0 2
15993: ADD
15994: ST_TO_ADDR
// end ;
15995: LD_VAR 0 1
15999: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16000: LD_INT 0
16002: PPUSH
16003: PPUSH
16004: PPUSH
16005: PPUSH
16006: PPUSH
// uc_side := 3 ;
16007: LD_ADDR_OWVAR 20
16011: PUSH
16012: LD_INT 3
16014: ST_TO_ADDR
// uc_nation := 3 ;
16015: LD_ADDR_OWVAR 21
16019: PUSH
16020: LD_INT 3
16022: ST_TO_ADDR
// InitHc ;
16023: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16027: LD_ADDR_VAR 0 5
16031: PUSH
16032: LD_INT 5
16034: PUSH
16035: LD_INT 6
16037: PUSH
16038: LD_INT 7
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: LIST
16045: PUSH
16046: LD_OWVAR 67
16050: ARRAY
16051: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16052: LD_ADDR_VAR 0 3
16056: PUSH
16057: LD_INT 22
16059: PUSH
16060: LD_INT 24
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: LD_INT 1
16069: PPUSH
16070: LD_INT 2
16072: PPUSH
16073: CALL_OW 12
16077: ARRAY
16078: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16079: LD_VAR 0 3
16083: PUSH
16084: LD_INT 22
16086: EQUAL
16087: IFFALSE 16122
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16089: LD_ADDR_VAR 0 4
16093: PUSH
16094: LD_INT 45
16096: PUSH
16097: LD_INT 43
16099: PUSH
16100: LD_INT 44
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: LIST
16107: PUSH
16108: LD_INT 1
16110: PPUSH
16111: LD_INT 3
16113: PPUSH
16114: CALL_OW 12
16118: ARRAY
16119: ST_TO_ADDR
16120: GO 16153
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16122: LD_ADDR_VAR 0 4
16126: PUSH
16127: LD_INT 46
16129: PUSH
16130: LD_INT 44
16132: PUSH
16133: LD_INT 45
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: LIST
16140: PUSH
16141: LD_INT 1
16143: PPUSH
16144: LD_INT 3
16146: PPUSH
16147: CALL_OW 12
16151: ARRAY
16152: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16153: LD_ADDR_VAR 0 2
16157: PUSH
16158: LD_INT 3
16160: PPUSH
16161: LD_INT 3
16163: PPUSH
16164: LD_VAR 0 3
16168: PPUSH
16169: LD_INT 1
16171: PPUSH
16172: LD_INT 3
16174: PUSH
16175: LD_INT 3
16177: PUSH
16178: LD_INT 3
16180: PUSH
16181: LD_INT 1
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: LIST
16188: LIST
16189: PUSH
16190: LD_INT 1
16192: PPUSH
16193: LD_INT 4
16195: PPUSH
16196: CALL_OW 12
16200: ARRAY
16201: PPUSH
16202: LD_VAR 0 4
16206: PPUSH
16207: LD_INT 99
16209: PPUSH
16210: CALL 423 0 7
16214: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16215: LD_VAR 0 2
16219: PPUSH
16220: CALL_OW 263
16224: PUSH
16225: LD_INT 1
16227: EQUAL
16228: IFFALSE 16259
// begin PrepareHuman ( false , 3 , skill ) ;
16230: LD_INT 0
16232: PPUSH
16233: LD_INT 3
16235: PPUSH
16236: LD_VAR 0 5
16240: PPUSH
16241: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16245: CALL_OW 44
16249: PPUSH
16250: LD_VAR 0 2
16254: PPUSH
16255: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16259: LD_VAR 0 2
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: LD_INT 0
16269: PPUSH
16270: CALL_OW 49
// ru_force := ru_force ^ un ;
16274: LD_ADDR_EXP 38
16278: PUSH
16279: LD_EXP 38
16283: PUSH
16284: LD_VAR 0 2
16288: ADD
16289: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16290: LD_VAR 0 2
16294: PPUSH
16295: LD_INT 126
16297: PPUSH
16298: LD_INT 158
16300: PPUSH
16301: CALL_OW 111
// Wait ( 0 0$3 ) ;
16305: LD_INT 105
16307: PPUSH
16308: CALL_OW 67
// ComStop ( un ) ;
16312: LD_VAR 0 2
16316: PPUSH
16317: CALL_OW 141
// end ;
16321: LD_VAR 0 1
16325: RET
// every 0 0$1 do var i , time , wave ;
16326: GO 16328
16328: DISABLE
16329: LD_INT 0
16331: PPUSH
16332: PPUSH
16333: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16334: LD_ADDR_VAR 0 2
16338: PUSH
16339: LD_INT 25200
16341: PUSH
16342: LD_INT 24150
16344: PUSH
16345: LD_INT 23100
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: LIST
16352: PUSH
16353: LD_OWVAR 67
16357: ARRAY
16358: ST_TO_ADDR
// wait ( time ) ;
16359: LD_VAR 0 2
16363: PPUSH
16364: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16368: LD_ADDR_VAR 0 2
16372: PUSH
16373: LD_INT 15750
16375: PUSH
16376: LD_INT 15400
16378: PUSH
16379: LD_INT 15050
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: LIST
16386: PUSH
16387: LD_OWVAR 67
16391: ARRAY
16392: ST_TO_ADDR
// wave := 0 ;
16393: LD_ADDR_VAR 0 3
16397: PUSH
16398: LD_INT 0
16400: ST_TO_ADDR
// while true do
16401: LD_INT 1
16403: IFFALSE 16507
// begin wave := wave + 1 ;
16405: LD_ADDR_VAR 0 3
16409: PUSH
16410: LD_VAR 0 3
16414: PUSH
16415: LD_INT 1
16417: PLUS
16418: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16419: LD_INT 22
16421: PUSH
16422: LD_INT 2
16424: PUSH
16425: EMPTY
16426: LIST
16427: LIST
16428: PPUSH
16429: CALL_OW 69
16433: IFFALSE 16469
// begin repeat wait ( 0 0$1 ) ;
16435: LD_INT 35
16437: PPUSH
16438: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16442: LD_INT 22
16444: PUSH
16445: LD_INT 2
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: PPUSH
16452: CALL_OW 69
16456: PUSH
16457: LD_INT 0
16459: EQUAL
16460: IFFALSE 16435
// wait ( 1 1$30 ) ;
16462: LD_INT 3150
16464: PPUSH
16465: CALL_OW 67
// end ; if ru_force < 20 then
16469: LD_EXP 38
16473: PUSH
16474: LD_INT 20
16476: LESS
16477: IFFALSE 16488
// PrepareAttack ( wave ) ;
16479: LD_VAR 0 3
16483: PPUSH
16484: CALL 15325 0 1
// ru_can_attack := true ;
16488: LD_ADDR_EXP 8
16492: PUSH
16493: LD_INT 1
16495: ST_TO_ADDR
// wait ( time ) ;
16496: LD_VAR 0 2
16500: PPUSH
16501: CALL_OW 67
// end ;
16505: GO 16401
// end ;
16507: PPOPN 3
16509: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16510: LD_EXP 8
16514: PUSH
16515: LD_EXP 38
16519: AND
16520: IFFALSE 17354
16522: GO 16524
16524: DISABLE
16525: LD_INT 0
16527: PPUSH
16528: PPUSH
16529: PPUSH
16530: PPUSH
16531: PPUSH
16532: PPUSH
16533: PPUSH
16534: PPUSH
16535: PPUSH
// begin enable ;
16536: ENABLE
// points1 := [ 107 , 123 ] ;
16537: LD_ADDR_VAR 0 4
16541: PUSH
16542: LD_INT 107
16544: PUSH
16545: LD_INT 123
16547: PUSH
16548: EMPTY
16549: LIST
16550: LIST
16551: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16552: LD_ADDR_VAR 0 5
16556: PUSH
16557: LD_INT 55
16559: PUSH
16560: LD_INT 42
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16567: LD_ADDR_VAR 0 6
16571: PUSH
16572: LD_INT 102
16574: PUSH
16575: LD_INT 140
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: PUSH
16582: LD_INT 105
16584: PUSH
16585: LD_INT 142
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: PUSH
16592: LD_INT 129
16594: PUSH
16595: LD_INT 131
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: ST_TO_ADDR
// for i in ru_force do
16607: LD_ADDR_VAR 0 1
16611: PUSH
16612: LD_EXP 38
16616: PUSH
16617: FOR_IN
16618: IFFALSE 17352
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16620: LD_ADDR_VAR 0 3
16624: PUSH
16625: LD_INT 81
16627: PUSH
16628: LD_INT 3
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: PPUSH
16635: CALL_OW 69
16639: PPUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: CALL_OW 74
16649: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16650: LD_VAR 0 1
16654: PPUSH
16655: LD_VAR 0 3
16659: PPUSH
16660: CALL_OW 296
16664: PUSH
16665: LD_INT 12
16667: LESS
16668: IFFALSE 16813
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16670: LD_VAR 0 1
16674: PPUSH
16675: CALL_OW 247
16679: PUSH
16680: LD_INT 1
16682: EQUAL
16683: PUSH
16684: LD_VAR 0 1
16688: PPUSH
16689: CALL_OW 257
16693: PUSH
16694: LD_INT 1
16696: EQUAL
16697: AND
16698: PUSH
16699: LD_VAR 0 3
16703: PUSH
16704: LD_INT 21
16706: PUSH
16707: LD_INT 2
16709: PUSH
16710: EMPTY
16711: LIST
16712: LIST
16713: PUSH
16714: LD_INT 58
16716: PUSH
16717: EMPTY
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PPUSH
16724: CALL_OW 69
16728: IN
16729: AND
16730: IFFALSE 16748
// ComEnterUnit ( i , un ) else
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_VAR 0 3
16741: PPUSH
16742: CALL_OW 120
16746: GO 16811
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16748: LD_VAR 0 3
16752: PUSH
16753: LD_INT 21
16755: PUSH
16756: LD_INT 2
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: PUSH
16763: LD_INT 58
16765: PUSH
16766: EMPTY
16767: LIST
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PPUSH
16773: CALL_OW 69
16777: IN
16778: NOT
16779: IFFALSE 16797
// ComAttackUnit ( i , un ) else
16781: LD_VAR 0 1
16785: PPUSH
16786: LD_VAR 0 3
16790: PPUSH
16791: CALL_OW 115
16795: GO 16811
// ComAttackUnit ( i , JMM ) ;
16797: LD_VAR 0 1
16801: PPUSH
16802: LD_EXP 21
16806: PPUSH
16807: CALL_OW 115
// end else
16811: GO 17350
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16813: LD_VAR 0 1
16817: PPUSH
16818: LD_VAR 0 4
16822: PUSH
16823: LD_INT 1
16825: ARRAY
16826: PPUSH
16827: LD_VAR 0 4
16831: PUSH
16832: LD_INT 2
16834: ARRAY
16835: PPUSH
16836: CALL_OW 297
16840: PUSH
16841: LD_VAR 0 1
16845: PPUSH
16846: LD_VAR 0 5
16850: PUSH
16851: LD_INT 1
16853: ARRAY
16854: PPUSH
16855: LD_VAR 0 5
16859: PUSH
16860: LD_INT 2
16862: ARRAY
16863: PPUSH
16864: CALL_OW 297
16868: GREATER
16869: PUSH
16870: LD_EXP 9
16874: AND
16875: PUSH
16876: LD_INT 9
16878: PPUSH
16879: LD_INT 81
16881: PUSH
16882: LD_INT 3
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: PPUSH
16889: CALL_OW 70
16893: PUSH
16894: LD_INT 0
16896: EQUAL
16897: OR
16898: IFFALSE 16936
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16900: LD_VAR 0 1
16904: PPUSH
16905: LD_INT 81
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: PPUSH
16915: CALL_OW 69
16919: PPUSH
16920: LD_VAR 0 1
16924: PPUSH
16925: CALL_OW 74
16929: PPUSH
16930: CALL_OW 115
16934: GO 17350
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16936: LD_VAR 0 1
16940: PPUSH
16941: CALL_OW 264
16945: PUSH
16946: LD_INT 45
16948: EQUAL
16949: PUSH
16950: LD_EXP 38
16954: PPUSH
16955: LD_INT 3
16957: PUSH
16958: LD_INT 34
16960: PUSH
16961: LD_INT 45
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PPUSH
16972: CALL_OW 72
16976: PUSH
16977: LD_INT 6
16979: GREATER
16980: AND
16981: IFFALSE 17162
// begin dist := 9999 ;
16983: LD_ADDR_VAR 0 8
16987: PUSH
16988: LD_INT 9999
16990: ST_TO_ADDR
// xy := 0 ;
16991: LD_ADDR_VAR 0 9
16995: PUSH
16996: LD_INT 0
16998: ST_TO_ADDR
// for x in pointsr do
16999: LD_ADDR_VAR 0 7
17003: PUSH
17004: LD_VAR 0 6
17008: PUSH
17009: FOR_IN
17010: IFFALSE 17158
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17012: LD_VAR 0 1
17016: PPUSH
17017: LD_VAR 0 7
17021: PUSH
17022: LD_INT 1
17024: ARRAY
17025: PPUSH
17026: LD_VAR 0 7
17030: PUSH
17031: LD_INT 2
17033: ARRAY
17034: PPUSH
17035: CALL_OW 297
17039: PUSH
17040: LD_VAR 0 8
17044: LESS
17045: IFFALSE 17090
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17047: LD_ADDR_VAR 0 8
17051: PUSH
17052: LD_VAR 0 1
17056: PPUSH
17057: LD_VAR 0 7
17061: PUSH
17062: LD_INT 1
17064: ARRAY
17065: PPUSH
17066: LD_VAR 0 7
17070: PUSH
17071: LD_INT 2
17073: ARRAY
17074: PPUSH
17075: CALL_OW 297
17079: ST_TO_ADDR
// xy := x ;
17080: LD_ADDR_VAR 0 9
17084: PUSH
17085: LD_VAR 0 7
17089: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17090: LD_VAR 0 9
17094: PUSH
17095: LD_VAR 0 1
17099: PPUSH
17100: LD_VAR 0 9
17104: PUSH
17105: LD_INT 1
17107: ARRAY
17108: PPUSH
17109: LD_VAR 0 9
17113: PUSH
17114: LD_INT 2
17116: ARRAY
17117: PPUSH
17118: CALL_OW 297
17122: PUSH
17123: LD_INT 9
17125: GREATER
17126: AND
17127: IFFALSE 17156
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17129: LD_VAR 0 1
17133: PPUSH
17134: LD_VAR 0 9
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: LD_VAR 0 9
17147: PUSH
17148: LD_INT 2
17150: ARRAY
17151: PPUSH
17152: CALL_OW 114
// end ;
17156: GO 17009
17158: POP
17159: POP
// end else
17160: GO 17350
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17162: LD_ADDR_VAR 0 3
17166: PUSH
17167: LD_OWVAR 3
17171: PUSH
17172: LD_VAR 0 1
17176: DIFF
17177: PPUSH
17178: LD_VAR 0 1
17182: PPUSH
17183: CALL_OW 74
17187: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17188: LD_VAR 0 1
17192: PPUSH
17193: CALL_OW 320
17197: NOT
17198: PUSH
17199: LD_VAR 0 3
17203: PUSH
17204: LD_INT 21
17206: PUSH
17207: LD_INT 2
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: LD_INT 33
17216: PUSH
17217: LD_INT 1
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: PUSH
17224: LD_INT 58
17226: PUSH
17227: EMPTY
17228: LIST
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: LIST
17234: PPUSH
17235: CALL_OW 69
17239: IN
17240: PUSH
17241: LD_VAR 0 3
17245: PUSH
17246: LD_INT 22
17248: PUSH
17249: LD_INT 3
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: PUSH
17256: LD_INT 21
17258: PUSH
17259: LD_INT 2
17261: PUSH
17262: EMPTY
17263: LIST
17264: LIST
17265: PUSH
17266: LD_INT 3
17268: PUSH
17269: LD_INT 24
17271: PUSH
17272: LD_INT 249
17274: PUSH
17275: EMPTY
17276: LIST
17277: LIST
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: LIST
17287: PPUSH
17288: CALL_OW 69
17292: IN
17293: OR
17294: AND
17295: IFFALSE 17313
// ComAttackUnit ( i , un ) else
17297: LD_VAR 0 1
17301: PPUSH
17302: LD_VAR 0 3
17306: PPUSH
17307: CALL_OW 115
17311: GO 17350
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17313: LD_VAR 0 1
17317: PPUSH
17318: LD_INT 9
17320: PPUSH
17321: LD_INT 81
17323: PUSH
17324: LD_INT 3
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PPUSH
17331: CALL_OW 70
17335: PPUSH
17336: LD_VAR 0 1
17340: PPUSH
17341: CALL_OW 74
17345: PPUSH
17346: CALL_OW 115
// end ; end ; end ; end ;
17350: GO 16617
17352: POP
17353: POP
// end ;
17354: PPOPN 9
17356: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17357: LD_INT 22
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: PUSH
17367: LD_INT 32
17369: PUSH
17370: LD_INT 1
17372: PUSH
17373: EMPTY
17374: LIST
17375: LIST
17376: PUSH
17377: EMPTY
17378: LIST
17379: LIST
17380: PPUSH
17381: CALL_OW 69
17385: IFFALSE 17473
17387: GO 17389
17389: DISABLE
17390: LD_INT 0
17392: PPUSH
17393: PPUSH
// begin enable ;
17394: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17395: LD_ADDR_VAR 0 2
17399: PUSH
17400: LD_INT 22
17402: PUSH
17403: LD_INT 3
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PUSH
17410: LD_INT 32
17412: PUSH
17413: LD_INT 1
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: PPUSH
17424: CALL_OW 69
17428: ST_TO_ADDR
// for i in tmp do
17429: LD_ADDR_VAR 0 1
17433: PUSH
17434: LD_VAR 0 2
17438: PUSH
17439: FOR_IN
17440: IFFALSE 17471
// if GetFuel ( i ) < 12 then
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 261
17451: PUSH
17452: LD_INT 12
17454: LESS
17455: IFFALSE 17469
// SetFuel ( i , 12 ) ;
17457: LD_VAR 0 1
17461: PPUSH
17462: LD_INT 12
17464: PPUSH
17465: CALL_OW 240
17469: GO 17439
17471: POP
17472: POP
// end ;
17473: PPOPN 2
17475: END
// every 0 0$1 trigger can_end do
17476: LD_EXP 17
17480: IFFALSE 17503
17482: GO 17484
17484: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17485: LD_INT 3325
17487: PPUSH
17488: CALL_OW 67
// PrepareAttack ( 10 ) ;
17492: LD_INT 10
17494: PPUSH
17495: CALL 15325 0 1
// until false ;
17499: LD_INT 0
17501: IFFALSE 17485
// end ; end_of_file
17503: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17504: GO 17506
17506: DISABLE
// begin ru_radar := 98 ;
17507: LD_ADDR_EXP 41
17511: PUSH
17512: LD_INT 98
17514: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17515: LD_ADDR_EXP 42
17519: PUSH
17520: LD_INT 89
17522: ST_TO_ADDR
// us_hack := 99 ;
17523: LD_ADDR_EXP 43
17527: PUSH
17528: LD_INT 99
17530: ST_TO_ADDR
// us_artillery := 97 ;
17531: LD_ADDR_EXP 44
17535: PUSH
17536: LD_INT 97
17538: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17539: LD_ADDR_EXP 45
17543: PUSH
17544: LD_INT 91
17546: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
17547: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17548: LD_INT 0
17550: PPUSH
17551: PPUSH
17552: PPUSH
17553: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17554: LD_VAR 0 1
17558: PPUSH
17559: CALL_OW 264
17563: PUSH
17564: LD_EXP 45
17568: EQUAL
17569: IFFALSE 17641
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17571: LD_INT 68
17573: PPUSH
17574: LD_VAR 0 1
17578: PPUSH
17579: CALL_OW 255
17583: PPUSH
17584: CALL_OW 321
17588: PUSH
17589: LD_INT 2
17591: EQUAL
17592: IFFALSE 17604
// eff := 70 else
17594: LD_ADDR_VAR 0 6
17598: PUSH
17599: LD_INT 70
17601: ST_TO_ADDR
17602: GO 17612
// eff := 30 ;
17604: LD_ADDR_VAR 0 6
17608: PUSH
17609: LD_INT 30
17611: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17612: LD_VAR 0 1
17616: PPUSH
17617: CALL_OW 250
17621: PPUSH
17622: LD_VAR 0 1
17626: PPUSH
17627: CALL_OW 251
17631: PPUSH
17632: LD_VAR 0 6
17636: PPUSH
17637: CALL_OW 495
// end ; end ;
17641: LD_VAR 0 4
17645: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17646: LD_INT 0
17648: PPUSH
17649: PPUSH
17650: PPUSH
17651: PPUSH
17652: PPUSH
17653: PPUSH
// if cmd = 124 then
17654: LD_VAR 0 1
17658: PUSH
17659: LD_INT 124
17661: EQUAL
17662: IFFALSE 17868
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17664: LD_ADDR_VAR 0 5
17668: PUSH
17669: LD_INT 2
17671: PUSH
17672: LD_INT 34
17674: PUSH
17675: LD_INT 53
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: PUSH
17682: LD_INT 34
17684: PUSH
17685: LD_INT 14
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: PUSH
17692: EMPTY
17693: LIST
17694: LIST
17695: LIST
17696: PPUSH
17697: CALL_OW 69
17701: ST_TO_ADDR
// if not tmp then
17702: LD_VAR 0 5
17706: NOT
17707: IFFALSE 17711
// exit ;
17709: GO 17868
// for i in tmp do
17711: LD_ADDR_VAR 0 3
17715: PUSH
17716: LD_VAR 0 5
17720: PUSH
17721: FOR_IN
17722: IFFALSE 17866
// begin taskList := GetTaskList ( i ) ;
17724: LD_ADDR_VAR 0 6
17728: PUSH
17729: LD_VAR 0 3
17733: PPUSH
17734: CALL_OW 437
17738: ST_TO_ADDR
// if not taskList then
17739: LD_VAR 0 6
17743: NOT
17744: IFFALSE 17748
// continue ;
17746: GO 17721
// for j = 1 to taskList do
17748: LD_ADDR_VAR 0 4
17752: PUSH
17753: DOUBLE
17754: LD_INT 1
17756: DEC
17757: ST_TO_ADDR
17758: LD_VAR 0 6
17762: PUSH
17763: FOR_TO
17764: IFFALSE 17862
// if taskList [ j ] [ 1 ] = | then
17766: LD_VAR 0 6
17770: PUSH
17771: LD_VAR 0 4
17775: ARRAY
17776: PUSH
17777: LD_INT 1
17779: ARRAY
17780: PUSH
17781: LD_STRING |
17783: EQUAL
17784: IFFALSE 17860
// begin _taskList := Delete ( taskList , 1 ) ;
17786: LD_ADDR_VAR 0 7
17790: PUSH
17791: LD_VAR 0 6
17795: PPUSH
17796: LD_INT 1
17798: PPUSH
17799: CALL_OW 3
17803: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17804: LD_VAR 0 3
17808: PPUSH
17809: LD_VAR 0 7
17813: PPUSH
17814: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17818: LD_VAR 0 3
17822: PPUSH
17823: LD_VAR 0 6
17827: PUSH
17828: LD_VAR 0 4
17832: ARRAY
17833: PUSH
17834: LD_INT 2
17836: ARRAY
17837: PPUSH
17838: LD_VAR 0 6
17842: PUSH
17843: LD_VAR 0 4
17847: ARRAY
17848: PUSH
17849: LD_INT 3
17851: ARRAY
17852: PPUSH
17853: LD_INT 8
17855: PPUSH
17856: CALL 17873 0 4
// end ;
17860: GO 17763
17862: POP
17863: POP
// end ;
17864: GO 17721
17866: POP
17867: POP
// end ; end ;
17868: LD_VAR 0 2
17872: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17873: LD_INT 0
17875: PPUSH
17876: PPUSH
17877: PPUSH
17878: PPUSH
17879: PPUSH
17880: PPUSH
17881: PPUSH
17882: PPUSH
17883: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17884: LD_VAR 0 1
17888: NOT
17889: PUSH
17890: LD_VAR 0 2
17894: PPUSH
17895: LD_VAR 0 3
17899: PPUSH
17900: CALL_OW 488
17904: NOT
17905: OR
17906: PUSH
17907: LD_VAR 0 4
17911: NOT
17912: OR
17913: IFFALSE 17917
// exit ;
17915: GO 18257
// list := [ ] ;
17917: LD_ADDR_VAR 0 13
17921: PUSH
17922: EMPTY
17923: ST_TO_ADDR
// if x - r < 0 then
17924: LD_VAR 0 2
17928: PUSH
17929: LD_VAR 0 4
17933: MINUS
17934: PUSH
17935: LD_INT 0
17937: LESS
17938: IFFALSE 17950
// min_x := 0 else
17940: LD_ADDR_VAR 0 7
17944: PUSH
17945: LD_INT 0
17947: ST_TO_ADDR
17948: GO 17966
// min_x := x - r ;
17950: LD_ADDR_VAR 0 7
17954: PUSH
17955: LD_VAR 0 2
17959: PUSH
17960: LD_VAR 0 4
17964: MINUS
17965: ST_TO_ADDR
// if y - r < 0 then
17966: LD_VAR 0 3
17970: PUSH
17971: LD_VAR 0 4
17975: MINUS
17976: PUSH
17977: LD_INT 0
17979: LESS
17980: IFFALSE 17992
// min_y := 0 else
17982: LD_ADDR_VAR 0 8
17986: PUSH
17987: LD_INT 0
17989: ST_TO_ADDR
17990: GO 18008
// min_y := y - r ;
17992: LD_ADDR_VAR 0 8
17996: PUSH
17997: LD_VAR 0 3
18001: PUSH
18002: LD_VAR 0 4
18006: MINUS
18007: ST_TO_ADDR
// max_x := x + r ;
18008: LD_ADDR_VAR 0 9
18012: PUSH
18013: LD_VAR 0 2
18017: PUSH
18018: LD_VAR 0 4
18022: PLUS
18023: ST_TO_ADDR
// max_y := y + r ;
18024: LD_ADDR_VAR 0 10
18028: PUSH
18029: LD_VAR 0 3
18033: PUSH
18034: LD_VAR 0 4
18038: PLUS
18039: ST_TO_ADDR
// for _x = min_x to max_x do
18040: LD_ADDR_VAR 0 11
18044: PUSH
18045: DOUBLE
18046: LD_VAR 0 7
18050: DEC
18051: ST_TO_ADDR
18052: LD_VAR 0 9
18056: PUSH
18057: FOR_TO
18058: IFFALSE 18175
// for _y = min_y to max_y do
18060: LD_ADDR_VAR 0 12
18064: PUSH
18065: DOUBLE
18066: LD_VAR 0 8
18070: DEC
18071: ST_TO_ADDR
18072: LD_VAR 0 10
18076: PUSH
18077: FOR_TO
18078: IFFALSE 18171
// begin if not ValidHex ( _x , _y ) then
18080: LD_VAR 0 11
18084: PPUSH
18085: LD_VAR 0 12
18089: PPUSH
18090: CALL_OW 488
18094: NOT
18095: IFFALSE 18099
// continue ;
18097: GO 18077
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18099: LD_VAR 0 11
18103: PPUSH
18104: LD_VAR 0 12
18108: PPUSH
18109: CALL_OW 351
18113: PUSH
18114: LD_VAR 0 11
18118: PPUSH
18119: LD_VAR 0 12
18123: PPUSH
18124: CALL_OW 554
18128: AND
18129: IFFALSE 18169
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18131: LD_ADDR_VAR 0 13
18135: PUSH
18136: LD_VAR 0 13
18140: PPUSH
18141: LD_VAR 0 13
18145: PUSH
18146: LD_INT 1
18148: PLUS
18149: PPUSH
18150: LD_VAR 0 11
18154: PUSH
18155: LD_VAR 0 12
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PPUSH
18164: CALL_OW 2
18168: ST_TO_ADDR
// end ;
18169: GO 18077
18171: POP
18172: POP
18173: GO 18057
18175: POP
18176: POP
// if not list then
18177: LD_VAR 0 13
18181: NOT
18182: IFFALSE 18186
// exit ;
18184: GO 18257
// for i in list do
18186: LD_ADDR_VAR 0 6
18190: PUSH
18191: LD_VAR 0 13
18195: PUSH
18196: FOR_IN
18197: IFFALSE 18255
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18199: LD_VAR 0 1
18203: PPUSH
18204: LD_STRING M
18206: PUSH
18207: LD_VAR 0 6
18211: PUSH
18212: LD_INT 1
18214: ARRAY
18215: PUSH
18216: LD_VAR 0 6
18220: PUSH
18221: LD_INT 2
18223: ARRAY
18224: PUSH
18225: LD_INT 0
18227: PUSH
18228: LD_INT 0
18230: PUSH
18231: LD_INT 0
18233: PUSH
18234: LD_INT 0
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: PUSH
18246: EMPTY
18247: LIST
18248: PPUSH
18249: CALL_OW 447
18253: GO 18196
18255: POP
18256: POP
// end ;
18257: LD_VAR 0 5
18261: RET
