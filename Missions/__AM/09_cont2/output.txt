// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13721 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2966 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := 0 ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// hc_name := Peter McCreery ;
2391: LD_ADDR_OWVAR 26
2395: PUSH
2396: LD_STRING Peter McCreery
2398: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2399: LD_ADDR_OWVAR 33
2403: PUSH
2404: LD_STRING SecondCharsGal
2406: ST_TO_ADDR
// hc_face_number := 58 ;
2407: LD_ADDR_OWVAR 34
2411: PUSH
2412: LD_INT 58
2414: ST_TO_ADDR
// hc_sex := sex_male ;
2415: LD_ADDR_OWVAR 27
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// hc_class := 4 ;
2423: LD_ADDR_OWVAR 28
2427: PUSH
2428: LD_INT 4
2430: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 2 ] ;
2431: LD_ADDR_OWVAR 30
2435: PUSH
2436: LD_INT 0
2438: PUSH
2439: LD_INT 0
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 6 ] ;
2454: LD_ADDR_OWVAR 31
2458: PUSH
2459: LD_INT 1
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 3
2467: PUSH
2468: LD_INT 6
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// un := CreateHuman ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// SetTag ( un , 11 ) ;
2487: LD_VAR 0 5
2491: PPUSH
2492: LD_INT 11
2494: PPUSH
2495: CALL_OW 109
// tmp := tmp ^ un ;
2499: LD_ADDR_VAR 0 4
2503: PUSH
2504: LD_VAR 0 4
2508: PUSH
2509: LD_VAR 0 5
2513: ADD
2514: ST_TO_ADDR
// tmp := tmp diff 0 ;
2515: LD_ADDR_VAR 0 4
2519: PUSH
2520: LD_VAR 0 4
2524: PUSH
2525: LD_INT 0
2527: DIFF
2528: ST_TO_ADDR
// InitHc ;
2529: CALL_OW 19
// hc_name :=  ;
2533: LD_ADDR_OWVAR 26
2537: PUSH
2538: LD_STRING 
2540: ST_TO_ADDR
// hc_gallery :=  ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING 
2548: ST_TO_ADDR
// if debug then
2549: LD_EXP 2
2553: IFFALSE 2604
// begin for i = 1 to 6 do
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: DOUBLE
2561: LD_INT 1
2563: DEC
2564: ST_TO_ADDR
2565: LD_INT 6
2567: PUSH
2568: FOR_TO
2569: IFFALSE 2602
// begin PrepareHuman ( false , 1 , 6 ) ;
2571: LD_INT 0
2573: PPUSH
2574: LD_INT 1
2576: PPUSH
2577: LD_INT 6
2579: PPUSH
2580: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_VAR 0 4
2593: PUSH
2594: CALL_OW 44
2598: ADD
2599: ST_TO_ADDR
// end ;
2600: GO 2568
2602: POP
2603: POP
// end ; for i in tmp do
2604: LD_ADDR_VAR 0 2
2608: PUSH
2609: LD_VAR 0 4
2613: PUSH
2614: FOR_IN
2615: IFFALSE 2674
// begin if GetClass ( i ) in [ 2 , 3 ] then
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 257
2626: PUSH
2627: LD_INT 2
2629: PUSH
2630: LD_INT 3
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: IN
2637: IFFALSE 2651
// SetClass ( i , 1 ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 1
2646: PPUSH
2647: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 106
2658: PPUSH
2659: LD_INT 122
2661: PPUSH
2662: LD_INT 5
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 50
// end ;
2672: GO 2614
2674: POP
2675: POP
// tmp := tmp diff Gary ;
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_EXP 22
2690: DIFF
2691: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 30
2709: PUSH
2710: LD_INT 31
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PPUSH
2721: CALL_OW 69
2725: ST_TO_ADDR
// for i = 1 to b do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: DOUBLE
2732: LD_INT 1
2734: DEC
2735: ST_TO_ADDR
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_TO
2742: IFFALSE 2787
// ComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) [ i ] , b [ i ] ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_INT 25
2751: PUSH
2752: LD_INT 1
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 72
2763: PUSH
2764: LD_VAR 0 2
2768: ARRAY
2769: PPUSH
2770: LD_VAR 0 3
2774: PUSH
2775: LD_VAR 0 2
2779: ARRAY
2780: PPUSH
2781: CALL_OW 120
2785: GO 2741
2787: POP
2788: POP
// InitHc ;
2789: CALL_OW 19
// InitUc ;
2793: CALL_OW 18
// end ;
2797: LD_VAR 0 1
2801: RET
// export function PowellTransport ; var i , un ; begin
2802: LD_INT 0
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side := 4 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 4
2814: ST_TO_ADDR
// uc_nation := 1 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2823: LD_INT 1
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: LD_INT 6
2831: PPUSH
2832: CALL_OW 380
// hc_name :=  ;
2836: LD_ADDR_OWVAR 26
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING SecondCharsGal
2851: ST_TO_ADDR
// hc_face_number := 30 ;
2852: LD_ADDR_OWVAR 34
2856: PUSH
2857: LD_INT 30
2859: ST_TO_ADDR
// powell_trans := CreateHuman ;
2860: LD_ADDR_EXP 27
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// hc_face_number := 31 ;
2870: LD_ADDR_OWVAR 34
2874: PUSH
2875: LD_INT 31
2877: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2878: LD_ADDR_EXP 27
2882: PUSH
2883: LD_EXP 27
2887: PUSH
2888: CALL_OW 44
2892: ADD
2893: ST_TO_ADDR
// for i = 1 to 2 do
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: DOUBLE
2900: LD_INT 1
2902: DEC
2903: ST_TO_ADDR
2904: LD_INT 2
2906: PUSH
2907: FOR_TO
2908: IFFALSE 2959
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2910: LD_ADDR_VAR 0 3
2914: PUSH
2915: LD_INT 4
2917: PPUSH
2918: LD_INT 1
2920: PPUSH
2921: LD_INT 3
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: LD_INT 12
2932: PPUSH
2933: LD_INT 66
2935: PPUSH
2936: CALL 423 0 7
2940: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2941: LD_ADDR_EXP 27
2945: PUSH
2946: LD_EXP 27
2950: PUSH
2951: LD_VAR 0 3
2955: ADD
2956: ST_TO_ADDR
// end ;
2957: GO 2907
2959: POP
2960: POP
// end ; end_of_file
2961: LD_VAR 0 1
2965: RET
// export function Action ; var i , veh ; begin
2966: LD_INT 0
2968: PPUSH
2969: PPUSH
2970: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2971: LD_EXP 26
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: LD_INT 50
2981: PPUSH
2982: LD_INT 38
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: CALL_OW 145
// InGameOn ;
2992: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2996: LD_INT 43
2998: PPUSH
2999: LD_INT 9
3001: PPUSH
3002: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
3006: LD_EXP 21
3010: PPUSH
3011: LD_INT 54
3013: PPUSH
3014: LD_INT 34
3016: PPUSH
3017: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
3021: LD_EXP 21
3025: PPUSH
3026: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
3030: LD_EXP 21
3034: PPUSH
3035: LD_EXP 26
3039: PUSH
3040: LD_INT 1
3042: ARRAY
3043: PPUSH
3044: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// until See ( 4 , JMM ) ;
3055: LD_INT 4
3057: PPUSH
3058: LD_EXP 21
3062: PPUSH
3063: CALL_OW 292
3067: IFFALSE 3048
// CenterNowOnUnits ( JMM ) ;
3069: LD_EXP 21
3073: PPUSH
3074: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
3078: LD_EXP 21
3082: PPUSH
3083: LD_STRING D2-JMM-1
3085: PPUSH
3086: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
3090: LD_EXP 26
3094: PUSH
3095: LD_INT 3
3097: ARRAY
3098: PPUSH
3099: LD_EXP 21
3103: PPUSH
3104: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
3108: LD_EXP 26
3112: PUSH
3113: LD_INT 3
3115: ARRAY
3116: PPUSH
3117: LD_STRING D2-Eng1-1
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3124: LD_EXP 21
3128: PPUSH
3129: LD_STRING D2-JMM-2
3131: PPUSH
3132: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
3136: LD_EXP 26
3140: PUSH
3141: LD_INT 3
3143: ARRAY
3144: PPUSH
3145: LD_STRING D2-Eng1-2
3147: PPUSH
3148: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3152: LD_EXP 21
3156: PPUSH
3157: LD_STRING D2-JMM-3
3159: PPUSH
3160: CALL_OW 88
// if Houten then
3164: LD_EXP 25
3168: IFFALSE 3366
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3170: LD_ADDR_VAR 0 3
3174: PUSH
3175: LD_INT 4
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 4
3192: PPUSH
3193: LD_INT 55
3195: PPUSH
3196: CALL 423 0 7
3200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3201: LD_VAR 0 3
3205: PPUSH
3206: LD_INT 3
3208: PPUSH
3209: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3213: LD_VAR 0 3
3217: PPUSH
3218: LD_INT 46
3220: PPUSH
3221: LD_INT 19
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3231: LD_EXP 25
3235: PPUSH
3236: LD_VAR 0 3
3240: PPUSH
3241: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3245: LD_EXP 25
3249: PPUSH
3250: LD_INT 49
3252: PPUSH
3253: LD_INT 33
3255: PPUSH
3256: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3260: LD_EXP 25
3264: PPUSH
3265: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3269: LD_EXP 25
3273: PPUSH
3274: LD_EXP 21
3278: PPUSH
3279: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3283: LD_INT 35
3285: PPUSH
3286: CALL_OW 67
// until See ( 1 , Houten ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_EXP 25
3297: PPUSH
3298: CALL_OW 292
3302: IFFALSE 3283
// ComTurnUnit ( JMM , Houten ) ;
3304: LD_EXP 21
3308: PPUSH
3309: LD_EXP 25
3313: PPUSH
3314: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3318: LD_EXP 21
3322: PPUSH
3323: LD_STRING D1d-JMM-1
3325: PPUSH
3326: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3330: LD_EXP 25
3334: PPUSH
3335: LD_STRING D1-VanH-1
3337: PPUSH
3338: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3342: LD_EXP 21
3346: PPUSH
3347: LD_STRING D1-JMM-1v
3349: PPUSH
3350: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3354: LD_EXP 21
3358: PPUSH
3359: LD_STRING D1-JMM-2v
3361: PPUSH
3362: CALL_OW 88
// end ; InGameOff ;
3366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3370: LD_STRING M1
3372: PPUSH
3373: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3377: LD_INT 22
3379: PUSH
3380: LD_INT 4
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 92
3389: PUSH
3390: LD_EXP 21
3394: PPUSH
3395: CALL_OW 250
3399: PUSH
3400: LD_EXP 21
3404: PPUSH
3405: CALL_OW 251
3409: PUSH
3410: LD_INT 15
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3435: LD_EXP 26
3439: PUSH
3440: LD_EXP 21
3444: ADD
3445: PUSH
3446: LD_EXP 25
3450: ADD
3451: PPUSH
3452: CALL_OW 141
// end ;
3456: LD_VAR 0 1
3460: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3461: LD_INT 1
3463: PPUSH
3464: LD_EXP 22
3468: PPUSH
3469: CALL_OW 292
3473: PUSH
3474: LD_EXP 21
3478: PPUSH
3479: LD_EXP 22
3483: PPUSH
3484: CALL_OW 296
3488: PUSH
3489: LD_INT 6
3491: LESS
3492: AND
3493: IFFALSE 4366
3495: GO 3497
3497: DISABLE
3498: LD_INT 0
3500: PPUSH
3501: PPUSH
3502: PPUSH
3503: PPUSH
3504: PPUSH
// begin InGameOn ;
3505: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PPUSH
3519: CALL_OW 69
3523: PPUSH
3524: LD_INT 1
3526: PPUSH
3527: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3531: LD_ADDR_VAR 0 4
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 1
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 25
3561: PUSH
3562: LD_INT 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 25
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 25
3581: PUSH
3582: LD_INT 4
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// ComHold ( tmp ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3614: LD_EXP 21
3618: PPUSH
3619: LD_STRING D2-JMM-3a
3621: PPUSH
3622: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3626: LD_EXP 22
3630: PPUSH
3631: LD_EXP 21
3635: PPUSH
3636: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3640: LD_EXP 22
3644: PPUSH
3645: LD_STRING D2-Gary-3
3647: PPUSH
3648: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3652: LD_EXP 21
3656: PPUSH
3657: LD_EXP 22
3661: PPUSH
3662: CALL_OW 119
// for i in tmp do
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: LD_VAR 0 4
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3722
// begin if IsInUnit ( i ) then
3679: LD_VAR 0 5
3683: PPUSH
3684: CALL_OW 310
3688: IFFALSE 3699
// ComExitBuilding ( i ) ;
3690: LD_VAR 0 5
3694: PPUSH
3695: CALL_OW 122
// wait ( 1 ) ;
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_EXP 21
3715: PPUSH
3716: CALL_OW 119
// end ;
3720: GO 3676
3722: POP
3723: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3724: LD_ADDR_VAR 0 4
3728: PUSH
3729: LD_VAR 0 4
3733: PUSH
3734: LD_EXP 21
3738: PUSH
3739: LD_EXP 25
3743: PUSH
3744: LD_EXP 22
3748: PUSH
3749: LD_EXP 24
3753: PUSH
3754: LD_EXP 23
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: PUSH
3766: LD_EXP 26
3770: ADD
3771: DIFF
3772: ST_TO_ADDR
// if Bobby then
3773: LD_EXP 23
3777: IFFALSE 3791
// Say ( Bobby , D2-Bobby-3 ) ;
3779: LD_EXP 23
3783: PPUSH
3784: LD_STRING D2-Bobby-3
3786: PPUSH
3787: CALL_OW 88
// if Cyrus then
3791: LD_EXP 24
3795: IFFALSE 3809
// Say ( Cyrus , D2-Cyrus-3 ) ;
3797: LD_EXP 24
3801: PPUSH
3802: LD_STRING D2-Cyrus-3
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3809: LD_EXP 21
3813: PPUSH
3814: LD_STRING D2-JMM-4
3816: PPUSH
3817: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3821: LD_EXP 22
3825: PPUSH
3826: LD_STRING D2-Gary-4
3828: PPUSH
3829: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3833: LD_ADDR_VAR 0 1
3837: PUSH
3838: LD_VAR 0 4
3842: PPUSH
3843: LD_INT 26
3845: PUSH
3846: LD_INT 1
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 72
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// if Cyrus then
3862: LD_EXP 24
3866: IFFALSE 3882
// Say ( Cyrus , D2-Cyrus-4 ) else
3868: LD_EXP 24
3872: PPUSH
3873: LD_STRING D2-Cyrus-4
3875: PPUSH
3876: CALL_OW 88
3880: GO 3894
// Say ( un1 , D2-Sol1-4 ) ;
3882: LD_VAR 0 1
3886: PPUSH
3887: LD_STRING D2-Sol1-4
3889: PPUSH
3890: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3894: LD_EXP 21
3898: PPUSH
3899: LD_STRING D2-JMM-5
3901: PPUSH
3902: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3906: LD_ADDR_VAR 0 2
3910: PUSH
3911: LD_EXP 26
3915: PPUSH
3916: LD_INT 91
3918: PUSH
3919: LD_EXP 21
3923: PUSH
3924: LD_INT 10
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: LIST
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 72
3950: ST_TO_ADDR
// if un2 then
3951: LD_VAR 0 2
3955: IFFALSE 4009
// begin un2 := un2 [ un2 ] ;
3957: LD_ADDR_VAR 0 2
3961: PUSH
3962: LD_VAR 0 2
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3973: LD_VAR 0 2
3977: PPUSH
3978: LD_STRING D2-FEng1-5
3980: PPUSH
3981: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3985: LD_EXP 21
3989: PPUSH
3990: LD_STRING D2-JMM-6
3992: PPUSH
3993: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_STRING D2-FEng1-6
4004: PPUSH
4005: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_EXP 26
4018: PPUSH
4019: LD_INT 91
4021: PUSH
4022: LD_EXP 21
4026: PUSH
4027: LD_INT 10
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 72
4053: ST_TO_ADDR
// if un3 then
4054: LD_VAR 0 3
4058: IFFALSE 4113
// begin un3 := un3 [ 1 ] ;
4060: LD_ADDR_VAR 0 3
4064: PUSH
4065: LD_VAR 0 3
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
4074: LD_VAR 0 3
4078: PPUSH
4079: LD_INT 114
4081: PPUSH
4082: LD_INT 122
4084: PPUSH
4085: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
4089: LD_VAR 0 3
4093: PPUSH
4094: LD_STRING D2-Eng1-6
4096: PPUSH
4097: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4101: LD_EXP 21
4105: PPUSH
4106: LD_STRING D2-JMM-7
4108: PPUSH
4109: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
4113: LD_EXP 22
4117: PPUSH
4118: LD_STRING D2-Gary-7
4120: PPUSH
4121: CALL_OW 88
// if un2 then
4125: LD_VAR 0 2
4129: IFFALSE 4143
// Say ( un2 , D2-FEng1-7 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING D2-FEng1-7
4138: PPUSH
4139: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
4143: LD_VAR 0 1
4147: PPUSH
4148: LD_STRING D2-Sol1-7
4150: PPUSH
4151: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
4155: LD_EXP 21
4159: PPUSH
4160: LD_STRING D2-JMM-8
4162: PPUSH
4163: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PPUSH
4182: CALL_OW 141
// InGameOff ;
4186: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4190: LD_STRING M1a
4192: PPUSH
4193: CALL_OW 337
// jmm_in_ovsyenko := true ;
4197: LD_ADDR_EXP 4
4201: PUSH
4202: LD_INT 1
4204: ST_TO_ADDR
// if debug then
4205: LD_EXP 2
4209: IFFALSE 4315
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PPUSH
4244: CALL_OW 274
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_INT 1000
4254: PPUSH
4255: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4259: LD_INT 22
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 30
4271: PUSH
4272: LD_INT 0
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PPUSH
4283: CALL_OW 69
4287: PUSH
4288: LD_INT 1
4290: ARRAY
4291: PPUSH
4292: CALL_OW 274
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 1000
4302: PPUSH
4303: CALL_OW 277
// ar_can_arrive := true ;
4307: LD_ADDR_EXP 10
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4315: LD_INT 1050
4317: PPUSH
4318: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4322: LD_ADDR_VAR 0 4
4326: PUSH
4327: LD_INT 25
4329: PUSH
4330: LD_INT 14
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// if not tmp then
4342: LD_VAR 0 4
4346: NOT
4347: IFFALSE 4351
// exit ;
4349: GO 4366
// ComMoveXY ( tmp , 75 , 75 ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_INT 75
4358: PPUSH
4359: LD_INT 75
4361: PPUSH
4362: CALL_OW 111
// end ;
4366: PPOPN 5
4368: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 30
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: LD_INT 57
4394: PUSH
4395: EMPTY
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: IFFALSE 4453
4413: GO 4415
4415: DISABLE
4416: LD_INT 0
4418: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4419: LD_ADDR_VAR 0 1
4423: PUSH
4424: LD_STRING M2easy
4426: PUSH
4427: LD_STRING M2
4429: PUSH
4430: LD_STRING M2hard
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4438: LD_VAR 0 1
4442: PUSH
4443: LD_OWVAR 67
4447: ARRAY
4448: PPUSH
4449: CALL_OW 337
// end ;
4453: PPOPN 1
4455: END
// every 3 3$00 do
4456: GO 4458
4458: DISABLE
// begin DialogueOn ;
4459: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4463: LD_EXP 28
4467: PPUSH
4468: LD_STRING D3-Pow-1
4470: PPUSH
4471: CALL_OW 94
// if jmm_in_ovsyenko then
4475: LD_EXP 4
4479: IFFALSE 4507
// begin Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 21
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4493: LD_EXP 21
4497: PPUSH
4498: LD_STRING D3-JMM-1b
4500: PPUSH
4501: CALL_OW 88
// end else
4505: GO 4519
// Say ( JMM , D3-JMM-1a ) ;
4507: LD_EXP 21
4511: PPUSH
4512: LD_STRING D3-JMM-1a
4514: PPUSH
4515: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4519: LD_EXP 28
4523: PPUSH
4524: LD_STRING D3-Pow-2
4526: PPUSH
4527: CALL_OW 94
// DialogueOff ;
4531: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4535: LD_STRING M3
4537: PPUSH
4538: CALL_OW 337
// powell_want_sib := true ;
4542: LD_ADDR_EXP 5
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end ;
4550: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4551: LD_EXP 6
4555: PUSH
4556: LD_INT 0
4558: EQUAL
4559: IFFALSE 6020
4561: GO 4563
4563: DISABLE
4564: LD_INT 0
4566: PPUSH
4567: PPUSH
4568: PPUSH
4569: PPUSH
4570: PPUSH
4571: PPUSH
4572: PPUSH
4573: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4574: LD_INT 4
4576: PPUSH
4577: LD_INT 1
4579: PPUSH
4580: CALL_OW 343
// PowellTransport ;
4584: CALL 2802 0 0
// for i = 1 to 3 do
4588: LD_ADDR_VAR 0 4
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_INT 3
4600: PUSH
4601: FOR_TO
4602: IFFALSE 4669
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 6
4611: PPUSH
4612: LD_VAR 0 4
4616: PPUSH
4617: CALL_OW 287
4621: ST_TO_ADDR
// if not tmp then
4622: LD_VAR 0 1
4626: NOT
4627: IFFALSE 4631
// continue ;
4629: GO 4601
// EraseResourceArea ( terminalArea , i ) ;
4631: LD_INT 6
4633: PPUSH
4634: LD_VAR 0 4
4638: PPUSH
4639: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4643: LD_EXP 3
4647: PPUSH
4648: CALL_OW 274
4652: PPUSH
4653: LD_VAR 0 4
4657: PPUSH
4658: LD_VAR 0 1
4662: PPUSH
4663: CALL_OW 276
// end ;
4667: GO 4601
4669: POP
4670: POP
// x := 43 ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_INT 43
4678: ST_TO_ADDR
// y := 3 ;
4679: LD_ADDR_VAR 0 3
4683: PUSH
4684: LD_INT 3
4686: ST_TO_ADDR
// for i = 3 to 4 do
4687: LD_ADDR_VAR 0 4
4691: PUSH
4692: DOUBLE
4693: LD_INT 3
4695: DEC
4696: ST_TO_ADDR
4697: LD_INT 4
4699: PUSH
4700: FOR_TO
4701: IFFALSE 4892
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4703: LD_EXP 27
4707: PUSH
4708: LD_VAR 0 4
4712: ARRAY
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4721: LD_EXP 27
4725: PUSH
4726: LD_VAR 0 4
4730: ARRAY
4731: PPUSH
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_VAR 0 3
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4749: LD_EXP 27
4753: PUSH
4754: LD_VAR 0 4
4758: PUSH
4759: LD_INT 2
4761: MINUS
4762: ARRAY
4763: PPUSH
4764: LD_EXP 27
4768: PUSH
4769: LD_VAR 0 4
4773: ARRAY
4774: PPUSH
4775: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4779: LD_EXP 27
4783: PUSH
4784: LD_VAR 0 4
4788: ARRAY
4789: PPUSH
4790: LD_INT 1
4792: PPUSH
4793: LD_INT 100
4795: PPUSH
4796: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4800: LD_EXP 27
4804: PUSH
4805: LD_VAR 0 4
4809: PUSH
4810: LD_INT 2
4812: MINUS
4813: ARRAY
4814: PPUSH
4815: LD_INT 54
4817: PPUSH
4818: LD_INT 42
4820: PPUSH
4821: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4825: LD_EXP 27
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_INT 2
4837: MINUS
4838: ARRAY
4839: PPUSH
4840: LD_EXP 3
4844: PPUSH
4845: CALL_OW 250
4849: PPUSH
4850: LD_EXP 3
4854: PPUSH
4855: CALL_OW 251
4859: PPUSH
4860: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4864: LD_EXP 27
4868: PUSH
4869: LD_VAR 0 4
4873: PUSH
4874: LD_INT 2
4876: MINUS
4877: ARRAY
4878: PPUSH
4879: CALL_OW 200
// Wait ( 0 0$02 ) ;
4883: LD_INT 70
4885: PPUSH
4886: CALL_OW 67
// end ;
4890: GO 4700
4892: POP
4893: POP
// time := 0 0$20 ;
4894: LD_ADDR_VAR 0 8
4898: PUSH
4899: LD_INT 700
4901: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4902: LD_INT 35
4904: PPUSH
4905: CALL_OW 67
// time := time - 0 0$01 ;
4909: LD_ADDR_VAR 0 8
4913: PUSH
4914: LD_VAR 0 8
4918: PUSH
4919: LD_INT 35
4921: MINUS
4922: ST_TO_ADDR
// for i = 3 to 4 do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 3
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 5072
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4939: LD_EXP 27
4943: PUSH
4944: LD_VAR 0 4
4948: ARRAY
4949: PPUSH
4950: LD_INT 1
4952: PPUSH
4953: CALL_OW 289
4957: PUSH
4958: LD_INT 0
4960: GREATER
4961: PUSH
4962: LD_EXP 27
4966: PUSH
4967: LD_VAR 0 4
4971: ARRAY
4972: PPUSH
4973: CALL_OW 314
4977: NOT
4978: AND
4979: IFFALSE 5070
// begin x := rand ( 0 , 5 ) ;
4981: LD_ADDR_VAR 0 2
4985: PUSH
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 5
4991: PPUSH
4992: CALL_OW 12
4996: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4997: LD_EXP 27
5001: PUSH
5002: LD_VAR 0 4
5006: ARRAY
5007: PPUSH
5008: LD_EXP 27
5012: PUSH
5013: LD_VAR 0 4
5017: ARRAY
5018: PPUSH
5019: CALL_OW 250
5023: PPUSH
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 3
5031: PPUSH
5032: CALL_OW 272
5036: PPUSH
5037: LD_EXP 27
5041: PUSH
5042: LD_VAR 0 4
5046: ARRAY
5047: PPUSH
5048: CALL_OW 251
5052: PPUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: CALL_OW 273
5065: PPUSH
5066: CALL_OW 171
// end ;
5070: GO 4936
5072: POP
5073: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 1
5081: ARRAY
5082: PPUSH
5083: LD_INT 54
5085: PPUSH
5086: LD_INT 42
5088: PPUSH
5089: CALL_OW 297
5093: PUSH
5094: LD_INT 4
5096: LESS
5097: PUSH
5098: LD_VAR 0 8
5102: PUSH
5103: LD_INT 0
5105: EQUAL
5106: OR
5107: IFFALSE 4902
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
5109: LD_EXP 27
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
5128: LD_EXP 27
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: LD_INT 0
5142: PPUSH
5143: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
5147: LD_EXP 3
5151: PPUSH
5152: CALL_OW 274
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 200
5162: PPUSH
5163: CALL_OW 276
// DialogueOn ;
5167: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5171: LD_INT 53
5173: PPUSH
5174: LD_INT 35
5176: PPUSH
5177: CALL_OW 86
// un := powell_trans [ 1 ] ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_EXP 27
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D4-Mech1-1
5202: PPUSH
5203: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5207: LD_EXP 21
5211: PPUSH
5212: LD_STRING D4-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5219: LD_VAR 0 5
5223: PPUSH
5224: LD_STRING D4-Mech1-2
5226: PPUSH
5227: CALL_OW 88
// powell_happy := false ;
5231: LD_ADDR_VAR 0 6
5235: PUSH
5236: LD_INT 0
5238: ST_TO_ADDR
// take_cargo := false ;
5239: LD_ADDR_VAR 0 7
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5247: CALL 943 0 0
5251: PUSH
5252: LD_INT 60
5254: GREATEREQUAL
5255: IFFALSE 5303
// begin Say ( JMM , D5-JMM-1 ) ;
5257: LD_EXP 21
5261: PPUSH
5262: LD_STRING D5-JMM-1
5264: PPUSH
5265: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5269: LD_VAR 0 5
5273: PPUSH
5274: LD_STRING D6-Mech1-1
5276: PPUSH
5277: CALL_OW 88
// powell_happy := true ;
5281: LD_ADDR_VAR 0 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// take_cargo := true ;
5289: LD_ADDR_VAR 0 7
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// DialogueOff ;
5297: CALL_OW 7
// end else
5301: GO 5537
// if GetTerminalCargo > 0 then
5303: CALL 943 0 0
5307: PUSH
5308: LD_INT 0
5310: GREATER
5311: IFFALSE 5509
// begin case Query ( QWait ) of 1 :
5313: LD_STRING QWait
5315: PPUSH
5316: CALL_OW 97
5320: PUSH
5321: LD_INT 1
5323: DOUBLE
5324: EQUAL
5325: IFTRUE 5329
5327: GO 5420
5329: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5330: LD_EXP 21
5334: PPUSH
5335: LD_STRING D5a-JMM-1
5337: PPUSH
5338: CALL_OW 88
// DialogueOff ;
5342: CALL_OW 7
// wait ( 5 5$00 ) ;
5346: LD_INT 10500
5348: PPUSH
5349: CALL_OW 67
// if GetTerminalCargo < 60 then
5353: CALL 943 0 0
5357: PUSH
5358: LD_INT 60
5360: LESS
5361: IFFALSE 5402
// begin DialogueOn ;
5363: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5367: LD_EXP 3
5371: PPUSH
5372: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_STRING D6-Mech1-1a
5383: PPUSH
5384: CALL_OW 88
// DialogueOff ;
5388: CALL_OW 7
// powell_happy := false ;
5392: LD_ADDR_VAR 0 6
5396: PUSH
5397: LD_INT 0
5399: ST_TO_ADDR
// end else
5400: GO 5418
// begin powell_happy := true ;
5402: LD_ADDR_VAR 0 6
5406: PUSH
5407: LD_INT 1
5409: ST_TO_ADDR
// take_cargo := true ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// end ; end ; 2 :
5418: GO 5507
5420: LD_INT 2
5422: DOUBLE
5423: EQUAL
5424: IFTRUE 5428
5426: GO 5467
5428: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5429: LD_EXP 21
5433: PPUSH
5434: LD_STRING D5b-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_STRING D6-Mech1-1a
5448: PPUSH
5449: CALL_OW 88
// DialogueOff ;
5453: CALL_OW 7
// take_cargo := true ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// end ; 3 :
5465: GO 5507
5467: LD_INT 3
5469: DOUBLE
5470: EQUAL
5471: IFTRUE 5475
5473: GO 5506
5475: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5476: LD_EXP 21
5480: PPUSH
5481: LD_STRING D5c-JMM-1
5483: PPUSH
5484: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5488: LD_VAR 0 5
5492: PPUSH
5493: LD_STRING D6-Mech1-1b
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ; end ;
5504: GO 5507
5506: POP
// end else
5507: GO 5537
// begin Say ( JMM , D5c-JMM-1 ) ;
5509: LD_EXP 21
5513: PPUSH
5514: LD_STRING D5c-JMM-1
5516: PPUSH
5517: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_STRING D6-Mech1-1b
5528: PPUSH
5529: CALL_OW 88
// DialogueOff ;
5533: CALL_OW 7
// end ; if take_cargo then
5537: LD_VAR 0 7
5541: IFFALSE 5620
// begin x := GetTerminalCargo ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL 943 0 0
5552: ST_TO_ADDR
// if x > 60 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 60
5560: GREATER
5561: IFFALSE 5571
// x := 60 ;
5563: LD_ADDR_VAR 0 2
5567: PUSH
5568: LD_INT 60
5570: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5571: LD_EXP 3
5575: PPUSH
5576: CALL_OW 274
5580: PPUSH
5581: LD_INT 3
5583: PPUSH
5584: CALL 943 0 0
5588: PUSH
5589: LD_VAR 0 2
5593: MINUS
5594: PPUSH
5595: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5599: LD_EXP 27
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PPUSH
5608: LD_INT 3
5610: PPUSH
5611: LD_VAR 0 2
5615: PPUSH
5616: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5620: LD_EXP 27
5624: PPUSH
5625: LD_INT 43
5627: PPUSH
5628: LD_INT 3
5630: PPUSH
5631: CALL_OW 171
// x := 0 0$20 ;
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_INT 700
5642: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5643: LD_INT 35
5645: PPUSH
5646: CALL_OW 67
// x := x - 0 0$01 ;
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 35
5662: MINUS
5663: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5664: LD_VAR 0 2
5668: PUSH
5669: LD_INT 0
5671: EQUAL
5672: PUSH
5673: LD_EXP 27
5677: PUSH
5678: LD_INT 3
5680: ARRAY
5681: PPUSH
5682: LD_INT 43
5684: PPUSH
5685: LD_INT 3
5687: PPUSH
5688: CALL_OW 297
5692: PUSH
5693: LD_INT 4
5695: LESS
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ARRAY
5705: PPUSH
5706: LD_INT 43
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: CALL_OW 297
5716: PUSH
5717: LD_INT 4
5719: LESS
5720: AND
5721: OR
5722: IFFALSE 5643
// for i in powell_trans do
5724: LD_ADDR_VAR 0 4
5728: PUSH
5729: LD_EXP 27
5733: PUSH
5734: FOR_IN
5735: IFFALSE 5748
// RemoveUnit ( i ) ;
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 64
5746: GO 5734
5748: POP
5749: POP
// if not powell_happy then
5750: LD_VAR 0 6
5754: NOT
5755: IFFALSE 5766
// powell_happy := - 1 ;
5757: LD_ADDR_VAR 0 6
5761: PUSH
5762: LD_INT 1
5764: NEG
5765: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5766: LD_STRING EarlySiberite
5768: PPUSH
5769: LD_VAR 0 6
5773: PPUSH
5774: CALL_OW 101
// if powell_happy then
5778: LD_VAR 0 6
5782: IFFALSE 5792
// earlySib := true ;
5784: LD_ADDR_EXP 19
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// if powell_happy then
5792: LD_VAR 0 6
5796: IFFALSE 5807
// ChangeMissionObjectives ( M3a ) else
5798: LD_STRING M3a
5800: PPUSH
5801: CALL_OW 337
5805: GO 5814
// ChangeMissionObjectives ( M3b ) ;
5807: LD_STRING M3b
5809: PPUSH
5810: CALL_OW 337
// ru_can_attack_terminal := true ;
5814: LD_ADDR_EXP 9
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5822: LD_INT 25200
5824: PPUSH
5825: CALL_OW 67
// time := 2 2$00 ;
5829: LD_ADDR_VAR 0 8
5833: PUSH
5834: LD_INT 4200
5836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5837: LD_INT 35
5839: PPUSH
5840: CALL_OW 67
// time := time - 0 0$1 ;
5844: LD_ADDR_VAR 0 8
5848: PUSH
5849: LD_VAR 0 8
5853: PUSH
5854: LD_INT 35
5856: MINUS
5857: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5858: LD_EXP 8
5862: NOT
5863: PUSH
5864: LD_EXP 38
5868: PUSH
5869: LD_INT 0
5871: EQUAL
5872: OR
5873: PUSH
5874: LD_VAR 0 8
5878: PUSH
5879: LD_INT 0
5881: EQUAL
5882: OR
5883: IFFALSE 5837
// if ru_force then
5885: LD_EXP 38
5889: IFFALSE 5988
// for i in ru_force do
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_EXP 38
5900: PUSH
5901: FOR_IN
5902: IFFALSE 5986
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 4
5911: PPUSH
5912: CALL_OW 292
5916: NOT
5917: PUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: LD_INT 81
5925: PUSH
5926: LD_INT 3
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PPUSH
5938: LD_VAR 0 4
5942: PPUSH
5943: CALL_OW 74
5947: PPUSH
5948: CALL_OW 296
5952: PUSH
5953: LD_INT 10
5955: GREATER
5956: AND
5957: IFFALSE 5984
// begin RemoveUnit ( i ) ;
5959: LD_VAR 0 4
5963: PPUSH
5964: CALL_OW 64
// ru_force := ru_force diff i ;
5968: LD_ADDR_EXP 38
5972: PUSH
5973: LD_EXP 38
5977: PUSH
5978: LD_VAR 0 4
5982: DIFF
5983: ST_TO_ADDR
// end ;
5984: GO 5901
5986: POP
5987: POP
// repeat wait ( 0 0$03 ) ;
5988: LD_INT 105
5990: PPUSH
5991: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5995: LD_EXP 8
5999: NOT
6000: PUSH
6001: LD_EXP 38
6005: PUSH
6006: LD_INT 3
6008: LESS
6009: OR
6010: IFFALSE 5988
// ar_can_arrive := true ;
6012: LD_ADDR_EXP 10
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// end ;
6020: PPOPN 8
6022: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 20
6028: PPUSH
6029: CALL_OW 325
6033: IFFALSE 6180
6035: GO 6037
6037: DISABLE
6038: LD_INT 0
6040: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Gary , Cyrus , Bobby , Houten ] ;
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_INT 22
6048: PUSH
6049: LD_INT 1
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PUSH
6056: LD_INT 26
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 25
6068: PUSH
6069: LD_INT 4
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: LD_EXP 22
6095: PUSH
6096: LD_EXP 24
6100: PUSH
6101: LD_EXP 23
6105: PUSH
6106: LD_EXP 25
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: DIFF
6118: ST_TO_ADDR
// if not un then
6119: LD_VAR 0 1
6123: NOT
6124: IFFALSE 6128
// exit ;
6126: GO 6180
// DialogueOn ;
6128: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
6132: LD_VAR 0 1
6136: PUSH
6137: LD_INT 1
6139: ARRAY
6140: PPUSH
6141: LD_STRING D13-Sci1-1
6143: PPUSH
6144: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
6148: LD_EXP 21
6152: PPUSH
6153: LD_STRING D13-JMM-1
6155: PPUSH
6156: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
6160: LD_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: ARRAY
6168: PPUSH
6169: LD_STRING D13-Sci1-2
6171: PPUSH
6172: CALL_OW 88
// DialogueOff ;
6176: CALL_OW 7
// end ;
6180: PPOPN 1
6182: END
// every 0 0$1 trigger GetTerminalCargo > 77 and not InBattle ( 1 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6183: CALL 943 0 0
6187: PUSH
6188: LD_INT 77
6190: GREATER
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 463
6199: NOT
6200: AND
6201: PUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 25
6214: PUSH
6215: LD_INT 4
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 26
6224: PUSH
6225: LD_INT 1
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: PUSH
6242: LD_EXP 21
6246: PUSH
6247: LD_EXP 23
6251: PUSH
6252: LD_EXP 24
6256: PUSH
6257: LD_EXP 22
6261: PUSH
6262: LD_EXP 25
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: AND
6275: IFFALSE 6453
6277: GO 6279
6279: DISABLE
6280: LD_INT 0
6282: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: LD_INT 22
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 25
6300: PUSH
6301: LD_INT 4
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: PUSH
6308: LD_INT 26
6310: PUSH
6311: LD_INT 1
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: PUSH
6328: LD_EXP 21
6332: PUSH
6333: LD_EXP 23
6337: PUSH
6338: LD_EXP 24
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: LD_EXP 25
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: DIFF
6360: ST_TO_ADDR
// DialogueOn ;
6361: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: ARRAY
6373: PPUSH
6374: LD_STRING D7-Sci1-1
6376: PPUSH
6377: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6381: LD_EXP 21
6385: PPUSH
6386: LD_STRING D7-JMM-1
6388: PPUSH
6389: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6393: LD_VAR 0 1
6397: PUSH
6398: LD_INT 1
6400: ARRAY
6401: PPUSH
6402: LD_STRING D7-Sci1-2
6404: PPUSH
6405: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6409: LD_EXP 21
6413: PPUSH
6414: LD_STRING D7-JMM-2
6416: PPUSH
6417: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 1
6428: ARRAY
6429: PPUSH
6430: LD_STRING D7-Sci1-3
6432: PPUSH
6433: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6437: LD_EXP 21
6441: PPUSH
6442: LD_STRING D7-JMM-3
6444: PPUSH
6445: CALL_OW 88
// DialogueOff ;
6449: CALL_OW 7
// end ;
6453: PPOPN 1
6455: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6456: LD_EXP 10
6460: IFFALSE 10083
6462: GO 6464
6464: DISABLE
6465: LD_INT 0
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
// begin PrepareArabian ;
6477: CALL 12827 0 0
// blocked := false ;
6481: LD_ADDR_EXP 18
6485: PUSH
6486: LD_INT 0
6488: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6489: LD_INT 35
6491: PPUSH
6492: CALL_OW 67
// until ar_spawned ;
6496: LD_EXP 11
6500: IFFALSE 6489
// have_crates := true ;
6502: LD_ADDR_VAR 0 9
6506: PUSH
6507: LD_INT 1
6509: ST_TO_ADDR
// player_want_info := 2 ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 2
6517: ST_TO_ADDR
// DialogueOn ;
6518: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6522: LD_EXP 29
6526: PPUSH
6527: LD_STRING D8-Ar1-1
6529: PPUSH
6530: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6534: LD_EXP 21
6538: PPUSH
6539: LD_STRING D8-JMM-1
6541: PPUSH
6542: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6546: LD_EXP 29
6550: PPUSH
6551: LD_STRING D8-Ar1-2
6553: PPUSH
6554: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6558: LD_EXP 21
6562: PPUSH
6563: LD_STRING D8-JMM-2
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6570: LD_EXP 29
6574: PPUSH
6575: LD_STRING D8-Ar1-3
6577: PPUSH
6578: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6582: LD_EXP 21
6586: PPUSH
6587: LD_STRING D8-JMM-3
6589: PPUSH
6590: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6594: LD_EXP 29
6598: PPUSH
6599: LD_STRING D8-Ar1-4
6601: PPUSH
6602: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6606: LD_EXP 21
6610: PPUSH
6611: LD_STRING D8-JMM-4
6613: PPUSH
6614: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6618: LD_EXP 29
6622: PPUSH
6623: LD_STRING D8-Ar1-5
6625: PPUSH
6626: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6630: LD_EXP 21
6634: PPUSH
6635: LD_STRING D8-JMM-5
6637: PPUSH
6638: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6642: LD_EXP 29
6646: PPUSH
6647: LD_STRING D8-Ar1-6
6649: PPUSH
6650: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6654: LD_EXP 30
6658: PPUSH
6659: LD_STRING D8-Ar2-6
6661: PPUSH
6662: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6666: LD_EXP 21
6670: PPUSH
6671: LD_STRING D8-JMM-6
6673: PPUSH
6674: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6678: LD_EXP 30
6682: PPUSH
6683: LD_STRING D8-Ar2-7
6685: PPUSH
6686: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6690: LD_STRING QBarracks
6692: PPUSH
6693: CALL_OW 97
6697: PUSH
6698: LD_INT 1
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6741
6706: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6707: LD_EXP 21
6711: PPUSH
6712: LD_STRING D8a-JMM-1
6714: PPUSH
6715: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6719: LD_EXP 29
6723: PPUSH
6724: LD_STRING D8a-Ar1-1
6726: PPUSH
6727: CALL_OW 94
// player_want_mortar := true ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 1
6738: ST_TO_ADDR
// end ; 2 :
6739: GO 6915
6741: LD_INT 2
6743: DOUBLE
6744: EQUAL
6745: IFTRUE 6749
6747: GO 6871
6749: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6750: LD_EXP 21
6754: PPUSH
6755: LD_STRING D8b-JMM-1
6757: PPUSH
6758: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6762: LD_EXP 29
6766: PPUSH
6767: LD_STRING D8b-Ar1-1
6769: PPUSH
6770: CALL_OW 94
// case Query ( QInfo ) of 1 :
6774: LD_STRING QInfo
6776: PPUSH
6777: CALL_OW 97
6781: PUSH
6782: LD_INT 1
6784: DOUBLE
6785: EQUAL
6786: IFTRUE 6790
6788: GO 6825
6790: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6791: LD_EXP 21
6795: PPUSH
6796: LD_STRING D8b1-JMM-1
6798: PPUSH
6799: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6803: LD_EXP 29
6807: PPUSH
6808: LD_STRING D8b1-Ar1-1
6810: PPUSH
6811: CALL_OW 94
// player_want_info := 2 ;
6815: LD_ADDR_EXP 13
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
// end ; 2 :
6823: GO 6869
6825: LD_INT 2
6827: DOUBLE
6828: EQUAL
6829: IFTRUE 6833
6831: GO 6868
6833: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6834: LD_EXP 21
6838: PPUSH
6839: LD_STRING D8b2-JMM-1
6841: PPUSH
6842: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6846: LD_EXP 29
6850: PPUSH
6851: LD_STRING D8b2-Ar1-1
6853: PPUSH
6854: CALL_OW 94
// player_want_info := 0 ;
6858: LD_ADDR_EXP 13
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ; end ;
6866: GO 6869
6868: POP
// end ; 3 :
6869: GO 6915
6871: LD_INT 3
6873: DOUBLE
6874: EQUAL
6875: IFTRUE 6879
6877: GO 6914
6879: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6880: LD_EXP 21
6884: PPUSH
6885: LD_STRING D8c-JMM-1
6887: PPUSH
6888: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6892: LD_EXP 29
6896: PPUSH
6897: LD_STRING D8c-Ar1-1
6899: PPUSH
6900: CALL_OW 94
// player_want_info := 0 ;
6904: LD_ADDR_EXP 13
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// end ; end ;
6912: GO 6915
6914: POP
// DialogueOff ;
6915: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: LD_INT 9
6926: PPUSH
6927: LD_INT 2
6929: PUSH
6930: LD_INT 30
6932: PUSH
6933: LD_INT 0
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 30
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 70
6959: ST_TO_ADDR
// if dep then
6960: LD_VAR 0 4
6964: IFFALSE 6980
// dep := dep [ 1 ] ;
6966: LD_ADDR_VAR 0 4
6970: PUSH
6971: LD_VAR 0 4
6975: PUSH
6976: LD_INT 1
6978: ARRAY
6979: ST_TO_ADDR
// if not dep then
6980: LD_VAR 0 4
6984: NOT
6985: IFFALSE 7023
// begin case Query ( QInfoNothing ) of 1 :
6987: LD_STRING QInfoNothing
6989: PPUSH
6990: CALL_OW 97
6994: PUSH
6995: LD_INT 1
6997: DOUBLE
6998: EQUAL
6999: IFTRUE 7003
7001: GO 7006
7003: POP
// ; end ;
7004: GO 7007
7006: POP
// player_want_info := false ;
7007: LD_ADDR_EXP 13
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
// player_want_mortar := false ;
7015: LD_ADDR_EXP 12
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
7023: LD_ADDR_VAR 0 3
7027: PUSH
7028: LD_INT 22
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 21
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PPUSH
7052: CALL_OW 69
7056: ST_TO_ADDR
// time := 1 1$55 ;
7057: LD_ADDR_VAR 0 5
7061: PUSH
7062: LD_INT 4025
7064: ST_TO_ADDR
// no_oil_gain := false ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// first_warn := false ;
7073: LD_ADDR_VAR 0 7
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// if player_want_mortar or player_want_info then
7081: LD_EXP 12
7085: PUSH
7086: LD_EXP 13
7090: OR
7091: IFFALSE 7196
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
7093: LD_EXP 36
7097: PPUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: CALL_OW 250
7122: PPUSH
7123: LD_VAR 0 4
7127: PPUSH
7128: CALL_OW 251
7132: PPUSH
7133: LD_VAR 0 4
7137: PPUSH
7138: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
7142: LD_EXP 36
7146: PPUSH
7147: LD_INT 25
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PPUSH
7162: LD_INT 86
7164: PPUSH
7165: LD_INT 121
7167: PPUSH
7168: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7172: LD_EXP 36
7176: PPUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 72
7191: PPUSH
7192: CALL_OW 200
// end ; if player_attacked_ar then
7196: LD_EXP 16
7200: IFFALSE 7204
// exit ;
7202: GO 10083
// if player_want_mortar then
7204: LD_EXP 12
7208: IFFALSE 8745
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7210: LD_EXP 30
7214: PPUSH
7215: LD_VAR 0 4
7219: PPUSH
7220: CALL_OW 250
7224: PUSH
7225: LD_INT 1
7227: PLUS
7228: PPUSH
7229: LD_VAR 0 4
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 1
7241: PLUS
7242: PPUSH
7243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7247: LD_INT 35
7249: PPUSH
7250: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7254: LD_EXP 30
7258: PPUSH
7259: LD_VAR 0 4
7263: PPUSH
7264: CALL_OW 296
7268: PUSH
7269: LD_INT 4
7271: LESS
7272: IFFALSE 7247
// for i = 1 to 6 do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: DOUBLE
7280: LD_INT 1
7282: DEC
7283: ST_TO_ADDR
7284: LD_INT 6
7286: PUSH
7287: FOR_TO
7288: IFFALSE 7492
// begin if player_attacked_ar then
7290: LD_EXP 16
7294: IFFALSE 7300
// exit ;
7296: POP
7297: POP
7298: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7300: LD_VAR 0 4
7304: PPUSH
7305: CALL_OW 274
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 275
7317: PUSH
7318: LD_INT 10
7320: LESS
7321: PUSH
7322: LD_VAR 0 7
7326: NOT
7327: AND
7328: IFFALSE 7391
// begin first_warn := true ;
7330: LD_ADDR_VAR 0 7
7334: PUSH
7335: LD_INT 1
7337: ST_TO_ADDR
// DialogueOn ;
7338: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7342: LD_EXP 31
7346: PPUSH
7347: LD_STRING D9a-FAr1-1
7349: PPUSH
7350: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7354: LD_EXP 21
7358: PPUSH
7359: LD_STRING D9a-JMM-1
7361: PPUSH
7362: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7366: LD_EXP 29
7370: PPUSH
7371: LD_STRING D9a2-Ar1-1
7373: PPUSH
7374: CALL_OW 88
// DialogueOff ;
7378: CALL_OW 7
// wait ( time ) ;
7382: LD_VAR 0 5
7386: PPUSH
7387: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7391: LD_VAR 0 4
7395: PPUSH
7396: CALL_OW 274
7400: PPUSH
7401: LD_INT 2
7403: PPUSH
7404: CALL_OW 275
7408: PUSH
7409: LD_INT 10
7411: LESS
7412: IFFALSE 7438
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7414: LD_EXP 29
7418: PPUSH
7419: LD_STRING D9a3-Ar1-1
7421: PPUSH
7422: CALL_OW 88
// no_oil_gain := true ;
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// break ;
7434: GO 7492
// end else
7436: GO 7490
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7438: LD_EXP 30
7442: PPUSH
7443: LD_VAR 0 4
7447: PPUSH
7448: LD_INT 2
7450: PPUSH
7451: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7455: LD_EXP 30
7459: PPUSH
7460: LD_VAR 0 3
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: MOD
7473: PUSH
7474: LD_INT 1
7476: PLUS
7477: ARRAY
7478: PPUSH
7479: CALL_OW 210
// wait ( 0 0$10 ) ;
7483: LD_INT 350
7485: PPUSH
7486: CALL_OW 67
// end ; end ;
7490: GO 7287
7492: POP
7493: POP
// if not no_oil_gain then
7494: LD_VAR 0 6
7498: NOT
7499: IFFALSE 8745
// begin repeat wait ( 0 0$01 ) ;
7501: LD_INT 35
7503: PPUSH
7504: CALL_OW 67
// if player_attacked_ar then
7508: LD_EXP 16
7512: IFFALSE 7516
// exit ;
7514: GO 10083
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7516: LD_VAR 0 3
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: CALL_OW 261
7529: PUSH
7530: LD_INT 80
7532: GREATER
7533: PUSH
7534: LD_VAR 0 3
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: PPUSH
7543: CALL_OW 261
7547: PUSH
7548: LD_INT 80
7550: GREATER
7551: AND
7552: PUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 3
7560: ARRAY
7561: PPUSH
7562: CALL_OW 261
7566: PUSH
7567: LD_INT 80
7569: GREATER
7570: AND
7571: IFFALSE 7501
// ComMoveXY ( Gali , 105 , 127 ) ;
7573: LD_EXP 30
7577: PPUSH
7578: LD_INT 105
7580: PPUSH
7581: LD_INT 127
7583: PPUSH
7584: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7588: LD_EXP 30
7592: PPUSH
7593: LD_INT 2
7595: PPUSH
7596: CALL_OW 173
// AddComHold ( Gali ) ;
7600: LD_EXP 30
7604: PPUSH
7605: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 10083
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7624: LD_EXP 30
7628: PPUSH
7629: LD_INT 105
7631: PPUSH
7632: LD_INT 127
7634: PPUSH
7635: CALL_OW 297
7639: PUSH
7640: LD_INT 4
7642: LESS
7643: IFFALSE 7609
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7645: LD_VAR 0 4
7649: PPUSH
7650: CALL_OW 274
7654: PPUSH
7655: LD_INT 1
7657: PPUSH
7658: CALL_OW 275
7662: PUSH
7663: LD_INT 50
7665: LESS
7666: IFFALSE 7968
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7668: LD_VAR 0 4
7672: PPUSH
7673: CALL_OW 274
7677: PPUSH
7678: LD_INT 1
7680: PPUSH
7681: CALL_OW 275
7685: PUSH
7686: LD_INT 0
7688: DOUBLE
7689: GREATEREQUAL
7690: IFFALSE 7698
7692: LD_INT 24
7694: DOUBLE
7695: LESSEQUAL
7696: IFTRUE 7700
7698: GO 7715
7700: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7701: LD_EXP 30
7705: PPUSH
7706: LD_STRING D9b-Ar2-1
7708: PPUSH
7709: CALL_OW 88
7713: GO 7745
7715: LD_INT 25
7717: DOUBLE
7718: GREATEREQUAL
7719: IFFALSE 7727
7721: LD_INT 49
7723: DOUBLE
7724: LESSEQUAL
7725: IFTRUE 7729
7727: GO 7744
7729: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7730: LD_EXP 30
7734: PPUSH
7735: LD_STRING D9b-Ar2-1a
7737: PPUSH
7738: CALL_OW 88
7742: GO 7745
7744: POP
// Say ( JMM , D9b-JMM-1 ) ;
7745: LD_EXP 21
7749: PPUSH
7750: LD_STRING D9b-JMM-1
7752: PPUSH
7753: CALL_OW 88
// x := 0 0$0 ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: LD_INT 0
7764: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7765: LD_INT 35
7767: PPUSH
7768: CALL_OW 67
// x := x + 0 0$1 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 35
7784: PLUS
7785: ST_TO_ADDR
// if player_attacked_ar then
7786: LD_EXP 16
7790: IFFALSE 7794
// exit ;
7792: GO 10083
// until x >= time ;
7794: LD_VAR 0 2
7798: PUSH
7799: LD_VAR 0 5
7803: GREATEREQUAL
7804: IFFALSE 7765
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7806: LD_VAR 0 4
7810: PPUSH
7811: CALL_OW 274
7815: PPUSH
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 275
7823: PUSH
7824: LD_INT 50
7826: LESS
7827: IFFALSE 7968
// begin have_crates := false ;
7829: LD_ADDR_VAR 0 9
7833: PUSH
7834: LD_INT 0
7836: ST_TO_ADDR
// DialogueOn ;
7837: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7841: LD_EXP 29
7845: PPUSH
7846: LD_STRING D9c-Ar1-1
7848: PPUSH
7849: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7853: LD_EXP 21
7857: PPUSH
7858: LD_STRING D9c-JMM-1
7860: PPUSH
7861: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7865: LD_EXP 29
7869: PPUSH
7870: LD_STRING D9c-Ar1-2
7872: PPUSH
7873: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7877: LD_EXP 31
7881: PPUSH
7882: LD_STRING D9c-FAr1-2
7884: PPUSH
7885: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7889: LD_EXP 29
7893: PPUSH
7894: LD_STRING D9c-Ar1-3
7896: PPUSH
7897: CALL_OW 88
// case Query ( QInfo ) of 1 :
7901: LD_STRING QInfo
7903: PPUSH
7904: CALL_OW 97
7908: PUSH
7909: LD_INT 1
7911: DOUBLE
7912: EQUAL
7913: IFTRUE 7917
7915: GO 7940
7917: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7918: LD_EXP 21
7922: PPUSH
7923: LD_STRING D8b1-JMM-1
7925: PPUSH
7926: CALL_OW 88
// player_want_info := 2 ;
7930: LD_ADDR_EXP 13
7934: PUSH
7935: LD_INT 2
7937: ST_TO_ADDR
// end ; 2 :
7938: GO 7964
7940: LD_INT 2
7942: DOUBLE
7943: EQUAL
7944: IFTRUE 7948
7946: GO 7963
7948: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7949: LD_EXP 29
7953: PPUSH
7954: LD_STRING D8b2-Ar1-1
7956: PPUSH
7957: CALL_OW 88
// end ; end ;
7961: GO 7964
7963: POP
// DialogueOff ;
7964: CALL_OW 7
// end ; end ; if have_crates then
7968: LD_VAR 0 9
7972: IFFALSE 8745
// begin RemoveEnvironmentArea ( mortarArea ) ;
7974: LD_INT 2
7976: PPUSH
7977: CALL_OW 355
// wait ( 1 ) ;
7981: LD_INT 1
7983: PPUSH
7984: CALL_OW 67
// InGameOn ;
7988: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7992: LD_EXP 30
7996: PPUSH
7997: CALL_OW 87
// SetSide ( Gali , 1 ) ;
8001: LD_EXP 30
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
8013: LD_ADDR_VAR 0 10
8017: PUSH
8018: LD_INT 22
8020: PUSH
8021: LD_INT 1
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 23
8033: PUSH
8034: LD_INT 2
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 21
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 92
8057: PUSH
8058: LD_INT 107
8060: PUSH
8061: LD_INT 131
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: ST_TO_ADDR
// if filter then
8084: LD_VAR 0 10
8088: IFFALSE 8122
// for i in filter do
8090: LD_ADDR_VAR 0 1
8094: PUSH
8095: LD_VAR 0 10
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8120
// ComMoveXY ( i , 107 , 121 ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_INT 107
8110: PPUSH
8111: LD_INT 121
8113: PPUSH
8114: CALL_OW 111
8118: GO 8100
8120: POP
8121: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
8122: LD_EXP 30
8126: PPUSH
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 131
8135: PPUSH
8136: LD_INT 0
8138: PPUSH
8139: CALL_OW 145
// wait ( 0 0$1 ) ;
8143: LD_INT 35
8145: PPUSH
8146: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
8150: LD_INT 30
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 23
8162: PUSH
8163: LD_INT 2
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: IFFALSE 8013
// SetSide ( Gali , 2 ) ;
8180: LD_EXP 30
8184: PPUSH
8185: LD_INT 2
8187: PPUSH
8188: CALL_OW 235
// InGameOff ;
8192: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8196: LD_ADDR_VAR 0 8
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 4
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 23
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8234: LD_INT 35
8236: PPUSH
8237: CALL_OW 67
// if player_attacked_ar then
8241: LD_EXP 16
8245: IFFALSE 8249
// exit ;
8247: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8249: LD_VAR 0 8
8253: PPUSH
8254: CALL_OW 461
8258: PUSH
8259: LD_INT 1
8261: NONEQUAL
8262: IFFALSE 8234
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8264: LD_VAR 0 8
8268: PPUSH
8269: CALL_OW 302
8273: PUSH
8274: LD_VAR 0 4
8278: PPUSH
8279: CALL_OW 274
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 275
8291: PUSH
8292: LD_INT 25
8294: GREATEREQUAL
8295: AND
8296: IFFALSE 8395
// begin ComUpgrade ( b ) ;
8298: LD_VAR 0 8
8302: PPUSH
8303: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8307: LD_EXP 30
8311: PPUSH
8312: LD_STRING h
8314: PUSH
8315: LD_VAR 0 8
8319: PPUSH
8320: CALL_OW 250
8324: PUSH
8325: LD_VAR 0 8
8329: PPUSH
8330: CALL_OW 251
8334: PUSH
8335: LD_VAR 0 8
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: PPUSH
8361: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// if player_attacked_ar then
8372: LD_EXP 16
8376: IFFALSE 8380
// exit ;
8378: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8380: LD_VAR 0 8
8384: PPUSH
8385: CALL_OW 461
8389: PUSH
8390: LD_INT 1
8392: NONEQUAL
8393: IFFALSE 8365
// end ; if b then
8395: LD_VAR 0 8
8399: IFFALSE 8410
// CenterNowOnUnits ( b ) ;
8401: LD_VAR 0 8
8405: PPUSH
8406: CALL_OW 87
// DialogueOn ;
8410: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8414: LD_EXP 30
8418: PPUSH
8419: LD_STRING D9d-Ar2-1
8421: PPUSH
8422: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8426: LD_EXP 29
8430: PPUSH
8431: LD_STRING D9d-Ar1-1
8433: PPUSH
8434: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8438: LD_EXP 21
8442: PPUSH
8443: LD_STRING D9d-JMM-1
8445: PPUSH
8446: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8450: LD_EXP 29
8454: PPUSH
8455: LD_STRING D9d-Ar1-2
8457: PPUSH
8458: CALL_OW 88
// DialogueOff ;
8462: CALL_OW 7
// i := [ ] ;
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: EMPTY
8472: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8473: LD_VAR 0 4
8477: PPUSH
8478: CALL_OW 274
8482: PPUSH
8483: LD_INT 3
8485: PPUSH
8486: CALL_OW 275
8490: PUSH
8491: LD_INT 20
8493: GREATEREQUAL
8494: IFFALSE 8513
// i := i ^ [ 1 ] ;
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_VAR 0 1
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: EMPTY
8510: LIST
8511: ADD
8512: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8513: LD_VAR 0 4
8517: PPUSH
8518: CALL_OW 274
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_INT 50
8533: GREATEREQUAL
8534: IFFALSE 8553
// i := i ^ [ 2 ] ;
8536: LD_ADDR_VAR 0 1
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: EMPTY
8550: LIST
8551: ADD
8552: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL_OW 274
8562: PPUSH
8563: LD_INT 2
8565: PPUSH
8566: CALL_OW 275
8570: PUSH
8571: LD_INT 80
8573: GREATEREQUAL
8574: IFFALSE 8593
// i := i ^ [ 3 ] ;
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: LD_VAR 0 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: ADD
8592: ST_TO_ADDR
// i := i diff 0 ;
8593: LD_ADDR_VAR 0 1
8597: PUSH
8598: LD_VAR 0 1
8602: PUSH
8603: LD_INT 0
8605: DIFF
8606: ST_TO_ADDR
// if i then
8607: LD_VAR 0 1
8611: IFFALSE 8717
// begin i := i ^ [ 4 ] ;
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 4
8625: PUSH
8626: EMPTY
8627: LIST
8628: ADD
8629: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8630: LD_STRING QInfo2
8632: PPUSH
8633: CALL_OW 97
8637: PUSH
8638: LD_INT 1
8640: DOUBLE
8641: EQUAL
8642: IFTRUE 8646
8644: GO 8657
8646: POP
// player_want_info := 3 ; 2 :
8647: LD_ADDR_EXP 13
8651: PUSH
8652: LD_INT 3
8654: ST_TO_ADDR
8655: GO 8715
8657: LD_INT 2
8659: DOUBLE
8660: EQUAL
8661: IFTRUE 8665
8663: GO 8676
8665: POP
// player_want_info := 1 ; 3 :
8666: LD_ADDR_EXP 13
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
8674: GO 8715
8676: LD_INT 3
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8695
8684: POP
// player_want_info := 2 ; 4 :
8685: LD_ADDR_EXP 13
8689: PUSH
8690: LD_INT 2
8692: ST_TO_ADDR
8693: GO 8715
8695: LD_INT 4
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8714
8703: POP
// player_want_info := 0 ; end ;
8704: LD_ADDR_EXP 13
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
8712: GO 8715
8714: POP
// end else
8715: GO 8745
// case Query ( QInfoNothing ) of 1 :
8717: LD_STRING QInfoNothing
8719: PPUSH
8720: CALL_OW 97
8724: PUSH
8725: LD_INT 1
8727: DOUBLE
8728: EQUAL
8729: IFTRUE 8733
8731: GO 8744
8733: POP
// player_want_info := 0 ; end ;
8734: LD_ADDR_EXP 13
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
8742: GO 8745
8744: POP
// end ; end ; end ; if player_want_info then
8745: LD_EXP 13
8749: IFFALSE 9903
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8751: LD_ADDR_VAR 0 3
8755: PUSH
8756: LD_VAR 0 3
8760: PPUSH
8761: LD_INT 34
8763: PUSH
8764: LD_INT 32
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 72
8775: ST_TO_ADDR
// if player_want_mortar then
8776: LD_EXP 12
8780: IFFALSE 9135
// begin case player_want_info of 1 :
8782: LD_EXP 13
8786: PUSH
8787: LD_INT 1
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8806
8795: POP
// x := 5 ; 2 :
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: LD_INT 5
8803: ST_TO_ADDR
8804: GO 8845
8806: LD_INT 2
8808: DOUBLE
8809: EQUAL
8810: IFTRUE 8814
8812: GO 8825
8814: POP
// x := 8 ; 3 :
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 8
8822: ST_TO_ADDR
8823: GO 8845
8825: LD_INT 3
8827: DOUBLE
8828: EQUAL
8829: IFTRUE 8833
8831: GO 8844
8833: POP
// x := 2 ; end ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_INT 2
8841: ST_TO_ADDR
8842: GO 8845
8844: POP
// repeat wait ( 0 0$1 ) ;
8845: LD_INT 35
8847: PPUSH
8848: CALL_OW 67
// until not HasTask ( Gali ) ;
8852: LD_EXP 30
8856: PPUSH
8857: CALL_OW 314
8861: NOT
8862: IFFALSE 8845
// time := 0 0$00 ;
8864: LD_ADDR_VAR 0 5
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// time := time + 0 0$1 ;
8879: LD_ADDR_VAR 0 5
8883: PUSH
8884: LD_VAR 0 5
8888: PUSH
8889: LD_INT 35
8891: PLUS
8892: ST_TO_ADDR
// if debug then
8893: LD_EXP 2
8897: IFFALSE 8916
// debug_strings := [ time: & time ] ;
8899: LD_ADDR_OWVAR 48
8903: PUSH
8904: LD_STRING time:
8906: PUSH
8907: LD_VAR 0 5
8911: STR
8912: PUSH
8913: EMPTY
8914: LIST
8915: ST_TO_ADDR
// if time > 8 8$00 then
8916: LD_VAR 0 5
8920: PUSH
8921: LD_INT 16800
8923: GREATER
8924: IFFALSE 8936
// begin blocked := true ;
8926: LD_ADDR_EXP 18
8930: PUSH
8931: LD_INT 1
8933: ST_TO_ADDR
// exit ;
8934: GO 10083
// end ; if not Carry ( Gali ) then
8936: LD_EXP 30
8940: PPUSH
8941: CALL_OW 281
8945: NOT
8946: IFFALSE 8969
// ComTransport ( Gali , dep , player_want_info ) else
8948: LD_EXP 30
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: LD_EXP 13
8962: PPUSH
8963: CALL_OW 151
8967: GO 9087
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8969: LD_EXP 30
8973: PPUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: CALL_OW 296
8987: PUSH
8988: LD_INT 4
8990: LESS
8991: PUSH
8992: LD_EXP 30
8996: PPUSH
8997: LD_EXP 13
9001: PPUSH
9002: CALL_OW 289
9006: AND
9007: IFFALSE 9069
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_EXP 13
9022: PPUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ARRAY
9031: PPUSH
9032: LD_EXP 13
9036: PPUSH
9037: CALL_OW 289
9041: PUSH
9042: LD_INT 10
9044: PLUS
9045: PPUSH
9046: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
9050: LD_EXP 30
9054: PPUSH
9055: LD_EXP 13
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 290
// end else
9067: GO 9087
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
9069: LD_EXP 30
9073: PPUSH
9074: LD_VAR 0 3
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: CALL_OW 112
// end ; if player_attacked_ar then
9087: LD_EXP 16
9091: IFFALSE 9095
// exit ;
9093: GO 10083
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: PPUSH
9104: LD_EXP 13
9108: PPUSH
9109: CALL_OW 289
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 10
9121: MUL
9122: GREATEREQUAL
9123: IFFALSE 8872
// no_oil_gain := false ;
9125: LD_ADDR_VAR 0 6
9129: PUSH
9130: LD_INT 0
9132: ST_TO_ADDR
// end else
9133: GO 9724
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
9135: LD_ADDR_VAR 0 3
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 21
9152: PUSH
9153: LD_INT 2
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9169: LD_EXP 30
9173: PPUSH
9174: LD_VAR 0 4
9178: PPUSH
9179: CALL_OW 250
9183: PUSH
9184: LD_INT 1
9186: PLUS
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: CALL_OW 251
9197: PUSH
9198: LD_INT 1
9200: PLUS
9201: PPUSH
9202: CALL_OW 111
// time := 0 0$00 ;
9206: LD_ADDR_VAR 0 5
9210: PUSH
9211: LD_INT 0
9213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// time := time + 0 0$1 ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: LD_VAR 0 5
9230: PUSH
9231: LD_INT 35
9233: PLUS
9234: ST_TO_ADDR
// if time > 1 1$45 then
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 3675
9242: GREATER
9243: IFFALSE 9247
// break ;
9245: GO 9267
// until GetDistUnits ( Gali , dep ) < 4 ;
9247: LD_EXP 30
9251: PPUSH
9252: LD_VAR 0 4
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 4
9264: LESS
9265: IFFALSE 9214
// for i = 1 to 6 do
9267: LD_ADDR_VAR 0 1
9271: PUSH
9272: DOUBLE
9273: LD_INT 1
9275: DEC
9276: ST_TO_ADDR
9277: LD_INT 6
9279: PUSH
9280: FOR_TO
9281: IFFALSE 9485
// begin if player_attacked_ar then
9283: LD_EXP 16
9287: IFFALSE 9293
// exit ;
9289: POP
9290: POP
9291: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9293: LD_VAR 0 4
9297: PPUSH
9298: CALL_OW 274
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 275
9310: PUSH
9311: LD_INT 10
9313: LESS
9314: PUSH
9315: LD_VAR 0 7
9319: NOT
9320: AND
9321: IFFALSE 9384
// begin first_warn := true ;
9323: LD_ADDR_VAR 0 7
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// DialogueOn ;
9331: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9335: LD_EXP 31
9339: PPUSH
9340: LD_STRING D9a-FAr1-1
9342: PPUSH
9343: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9347: LD_EXP 21
9351: PPUSH
9352: LD_STRING D9a-JMM-1
9354: PPUSH
9355: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9359: LD_EXP 29
9363: PPUSH
9364: LD_STRING D9a2-Ar1-1
9366: PPUSH
9367: CALL_OW 88
// DialogueOff ;
9371: CALL_OW 7
// wait ( time ) ;
9375: LD_VAR 0 5
9379: PPUSH
9380: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9384: LD_VAR 0 4
9388: PPUSH
9389: CALL_OW 274
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 275
9401: PUSH
9402: LD_INT 10
9404: LESS
9405: IFFALSE 9431
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9407: LD_EXP 29
9411: PPUSH
9412: LD_STRING D9a3-Ar1-1
9414: PPUSH
9415: CALL_OW 88
// no_oil_gain := true ;
9419: LD_ADDR_VAR 0 6
9423: PUSH
9424: LD_INT 1
9426: ST_TO_ADDR
// break ;
9427: GO 9485
// end else
9429: GO 9483
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9431: LD_EXP 30
9435: PPUSH
9436: LD_VAR 0 4
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9448: LD_EXP 30
9452: PPUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 3
9465: MOD
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: ARRAY
9471: PPUSH
9472: CALL_OW 210
// wait ( 0 0$10 ) ;
9476: LD_INT 350
9478: PPUSH
9479: CALL_OW 67
// end ; end ;
9483: GO 9280
9485: POP
9486: POP
// time := 0 0$00 ;
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 0
9494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9495: LD_INT 35
9497: PPUSH
9498: CALL_OW 67
// if not HasTask ( Gali ) then
9502: LD_EXP 30
9506: PPUSH
9507: CALL_OW 314
9511: NOT
9512: IFFALSE 9528
// time := time + 0 0$1 ;
9514: LD_ADDR_VAR 0 5
9518: PUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_INT 35
9526: PLUS
9527: ST_TO_ADDR
// if time > 1 1$25 then
9528: LD_VAR 0 5
9532: PUSH
9533: LD_INT 2975
9535: GREATER
9536: IFFALSE 9560
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING D9a3-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// no_oil_gain := true ;
9550: LD_ADDR_VAR 0 6
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// break ;
9558: GO 9724
// end ; if player_attacked_ar then
9560: LD_EXP 16
9564: IFFALSE 9568
// exit ;
9566: GO 10083
// for i in tmp do
9568: LD_ADDR_VAR 0 1
9572: PUSH
9573: LD_VAR 0 3
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9610
// if GetFuel ( i ) < 100 then
9581: LD_VAR 0 1
9585: PPUSH
9586: CALL_OW 261
9590: PUSH
9591: LD_INT 100
9593: LESS
9594: IFFALSE 9608
// begin x := i ;
9596: LD_ADDR_VAR 0 2
9600: PUSH
9601: LD_VAR 0 1
9605: ST_TO_ADDR
// break ;
9606: GO 9610
// end ;
9608: GO 9578
9610: POP
9611: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9612: LD_EXP 30
9616: PPUSH
9617: CALL_OW 314
9621: NOT
9622: PUSH
9623: LD_EXP 30
9627: PPUSH
9628: CALL_OW 281
9632: NOT
9633: AND
9634: IFFALSE 9667
// begin ComTransport ( Gali , dep , mat_oil ) ;
9636: LD_EXP 30
9640: PPUSH
9641: LD_VAR 0 4
9645: PPUSH
9646: LD_INT 2
9648: PPUSH
9649: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9653: LD_EXP 30
9657: PPUSH
9658: LD_VAR 0 2
9662: PPUSH
9663: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9667: LD_VAR 0 3
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: CALL_OW 261
9680: PUSH
9681: LD_INT 80
9683: GREATER
9684: PUSH
9685: LD_VAR 0 3
9689: PUSH
9690: LD_INT 2
9692: ARRAY
9693: PPUSH
9694: CALL_OW 261
9698: PUSH
9699: LD_INT 80
9701: GREATER
9702: AND
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_INT 3
9711: ARRAY
9712: PPUSH
9713: CALL_OW 261
9717: PUSH
9718: LD_INT 80
9720: GREATER
9721: AND
9722: IFFALSE 9495
// end ; ComHold ( Gali ) ;
9724: LD_EXP 30
9728: PPUSH
9729: CALL_OW 140
// if not no_oil_gain then
9733: LD_VAR 0 6
9737: NOT
9738: IFFALSE 9903
// begin DialogueOn ;
9740: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9744: LD_EXP 29
9748: PPUSH
9749: CALL_OW 87
// if player_want_mortar then
9753: LD_EXP 12
9757: IFFALSE 9783
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9759: LD_EXP 29
9763: PPUSH
9764: LD_STRING D9e-Ar1-1
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9771: LD_EXP 21
9775: PPUSH
9776: LD_STRING D10a-JMM-1
9778: PPUSH
9779: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9783: LD_EXP 29
9787: PPUSH
9788: LD_STRING D10a-Ar1-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9795: LD_EXP 30
9799: PPUSH
9800: LD_STRING D10a-Ar2-1
9802: PPUSH
9803: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9807: LD_EXP 31
9811: PPUSH
9812: LD_STRING D10a-FAr1-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9819: LD_EXP 30
9823: PPUSH
9824: LD_STRING D10a-Ar2-2
9826: PPUSH
9827: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9831: LD_EXP 31
9835: PPUSH
9836: LD_STRING D10a-FAr1-2
9838: PPUSH
9839: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9843: LD_EXP 29
9847: PPUSH
9848: LD_STRING D10a-Ar1-2
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9855: LD_EXP 21
9859: PPUSH
9860: LD_STRING D10a-JMM-2
9862: PPUSH
9863: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9867: LD_EXP 29
9871: PPUSH
9872: LD_STRING D10a-Ar1-3
9874: PPUSH
9875: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9879: LD_EXP 21
9883: PPUSH
9884: LD_STRING D10a-JMM-3
9886: PPUSH
9887: CALL_OW 88
// player_get_info := true ;
9891: LD_ADDR_EXP 15
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// DialogueOff ;
9899: CALL_OW 7
// end ; end ; if player_attacked_ar then
9903: LD_EXP 16
9907: IFFALSE 9911
// exit ;
9909: GO 10083
// if player_want_mortar or player_want_info then
9911: LD_EXP 12
9915: PUSH
9916: LD_EXP 13
9920: OR
9921: IFFALSE 9935
// Say ( Vervecken , D9f-Ar1-1 ) ;
9923: LD_EXP 29
9927: PPUSH
9928: LD_STRING D9f-Ar1-1
9930: PPUSH
9931: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9935: LD_INT 22
9937: PUSH
9938: LD_INT 2
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: PPUSH
9950: LD_INT 51
9952: PPUSH
9953: LD_INT 99
9955: PPUSH
9956: CALL_OW 111
// wait ( 0 0$1 ) ;
9960: LD_INT 35
9962: PPUSH
9963: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9967: LD_INT 22
9969: PUSH
9970: LD_INT 2
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 92
9979: PUSH
9980: LD_INT 51
9982: PUSH
9983: LD_INT 99
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IFFALSE 10063
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 2
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 92
10022: PUSH
10023: LD_INT 51
10025: PUSH
10026: LD_INT 99
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 69
10046: PUSH
10047: FOR_IN
10048: IFFALSE 10061
// RemoveUnit ( i ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: CALL_OW 64
10059: GO 10047
10061: POP
10062: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: PUSH
10078: LD_INT 0
10080: EQUAL
10081: IFFALSE 9935
// end ;
10083: PPOPN 10
10085: END
// every 0 0$01 trigger blocked do var i ;
10086: LD_EXP 18
10090: IFFALSE 10258
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
10098: LD_EXP 29
10102: PPUSH
10103: LD_STRING D9f-Ar1-1
10105: PPUSH
10106: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10110: LD_INT 22
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_INT 51
10127: PPUSH
10128: LD_INT 99
10130: PPUSH
10131: CALL_OW 111
// wait ( 0 0$1 ) ;
10135: LD_INT 35
10137: PPUSH
10138: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10142: LD_INT 22
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 92
10154: PUSH
10155: LD_INT 51
10157: PUSH
10158: LD_INT 99
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: IFFALSE 10238
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10180: LD_ADDR_VAR 0 1
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 92
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 99
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PPUSH
10217: CALL_OW 69
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// RemoveUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 64
10234: GO 10222
10236: POP
10237: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10238: LD_INT 22
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: IFFALSE 10110
// end ;
10258: PPOPN 1
10260: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10261: LD_EXP 16
10265: IFFALSE 10618
10267: GO 10269
10269: DISABLE
10270: LD_INT 0
10272: PPUSH
10273: PPUSH
10274: PPUSH
10275: PPUSH
// begin ru_can_attack := true ;
10276: LD_ADDR_EXP 8
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// mine_launched := false ;
10284: LD_ADDR_VAR 0 3
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PPUSH
10307: LD_INT 51
10309: PPUSH
10310: LD_INT 99
10312: PPUSH
10313: CALL_OW 111
// if IsOk ( Vervecken ) then
10317: LD_EXP 29
10321: PPUSH
10322: CALL_OW 302
10326: IFFALSE 10340
// Say ( Vervecken , D11a-Ar1-1 ) ;
10328: LD_EXP 29
10332: PPUSH
10333: LD_STRING D11a-Ar1-1
10335: PPUSH
10336: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10340: LD_ADDR_VAR 0 2
10344: PUSH
10345: LD_EXP 36
10349: PPUSH
10350: LD_INT 25
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 72
10364: ST_TO_ADDR
// for i in tmp do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10439
// if MineOfUnit ( i ) then
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 459
10387: IFFALSE 10437
// begin x := MineOfUnit ( i ) ;
10389: LD_ADDR_VAR 0 4
10393: PUSH
10394: LD_VAR 0 1
10398: PPUSH
10399: CALL_OW 459
10403: ST_TO_ADDR
// mine_launched := true ;
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10412: LD_VAR 0 4
10416: PUSH
10417: LD_INT 1
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_INT 2
10428: ARRAY
10429: PPUSH
10430: LD_INT 2
10432: PPUSH
10433: CALL_OW 456
// end ;
10437: GO 10375
10439: POP
10440: POP
// if mine_launched and IsOk ( Vervecken ) then
10441: LD_VAR 0 3
10445: PUSH
10446: LD_EXP 29
10450: PPUSH
10451: CALL_OW 302
10455: AND
10456: IFFALSE 10470
// Say ( Vervecken , D11b-Ar1-1 ) ;
10458: LD_EXP 29
10462: PPUSH
10463: LD_STRING D11b-Ar1-1
10465: PPUSH
10466: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10470: LD_INT 22
10472: PUSH
10473: LD_INT 2
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: PPUSH
10485: LD_INT 51
10487: PPUSH
10488: LD_INT 99
10490: PPUSH
10491: CALL_OW 111
// wait ( 0 0$1 ) ;
10495: LD_INT 35
10497: PPUSH
10498: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10502: LD_INT 22
10504: PUSH
10505: LD_INT 2
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 92
10514: PUSH
10515: LD_INT 51
10517: PUSH
10518: LD_INT 99
10520: PUSH
10521: LD_INT 2
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IFFALSE 10598
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 22
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 92
10557: PUSH
10558: LD_INT 51
10560: PUSH
10561: LD_INT 99
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: PUSH
10582: FOR_IN
10583: IFFALSE 10596
// RemoveUnit ( i ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: CALL_OW 64
10594: GO 10582
10596: POP
10597: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PUSH
10613: LD_INT 0
10615: EQUAL
10616: IFFALSE 10470
// end ;
10618: PPOPN 4
10620: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10621: LD_EXP 10
10625: IFFALSE 10804
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
// begin Wait ( 10 10$00 ) ;
10633: LD_INT 21000
10635: PPUSH
10636: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10640: LD_INT 22
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: IFFALSE 10804
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: PPUSH
10671: LD_INT 51
10673: PPUSH
10674: LD_INT 99
10676: PPUSH
10677: CALL_OW 114
// wait ( 0 0$1 ) ;
10681: LD_INT 35
10683: PPUSH
10684: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10688: LD_INT 22
10690: PUSH
10691: LD_INT 2
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 92
10700: PUSH
10701: LD_INT 51
10703: PUSH
10704: LD_INT 99
10706: PUSH
10707: LD_INT 2
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: IFFALSE 10784
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 92
10743: PUSH
10744: LD_INT 51
10746: PUSH
10747: LD_INT 99
10749: PUSH
10750: LD_INT 2
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10782
// RemoveUnit ( i ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 64
10780: GO 10768
10782: POP
10783: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10784: LD_INT 22
10786: PUSH
10787: LD_INT 2
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: PUSH
10799: LD_INT 0
10801: EQUAL
10802: IFFALSE 10656
// end ; end ;
10804: PPOPN 1
10806: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10807: LD_EXP 4
10811: IFFALSE 11866
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
10819: PPUSH
10820: PPUSH
10821: PPUSH
10822: PPUSH
10823: PPUSH
// begin Wait ( game_time ) ;
10824: LD_EXP 7
10828: PPUSH
10829: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10833: LD_INT 35
10835: PPUSH
10836: CALL_OW 67
// until ( not ru_can_attack ) ;
10840: LD_EXP 8
10844: NOT
10845: IFFALSE 10833
// Wait ( 0 0$35 ) ;
10847: LD_INT 1225
10849: PPUSH
10850: CALL_OW 67
// DialogueOn ;
10854: CALL_OW 6
// InGameOn ;
10858: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10862: LD_EXP 28
10866: PPUSH
10867: LD_STRING D12-Pow-1
10869: PPUSH
10870: CALL_OW 94
// InGameOff ;
10874: CALL_OW 9
// DialogueOff ;
10878: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10882: LD_STRING M4
10884: PPUSH
10885: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10889: LD_INT 5
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 424
// can_end := true ;
10899: LD_ADDR_EXP 17
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10907: LD_INT 35
10909: PPUSH
10910: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10914: CALL 943 0 0
10918: PUSH
10919: LD_INT 20
10921: GREATEREQUAL
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_INT 1
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 21
10935: PUSH
10936: LD_INT 1
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PPUSH
10947: CALL_OW 69
10951: PUSH
10952: LD_INT 5
10954: PPUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 70
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 1
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 55
10996: PUSH
10997: EMPTY
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PLUS
11009: LESSEQUAL
11010: AND
11011: IFFALSE 10907
// if not player_get_info then
11013: LD_EXP 15
11017: NOT
11018: IFFALSE 11029
// player_get_info := - 1 ;
11020: LD_ADDR_EXP 15
11024: PUSH
11025: LD_INT 1
11027: NEG
11028: ST_TO_ADDR
// m1 := player_get_info > 0 ;
11029: LD_ADDR_VAR 0 4
11033: PUSH
11034: LD_EXP 15
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: ST_TO_ADDR
// m2 := false ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// m3 := earlySib ;
11051: LD_ADDR_VAR 0 6
11055: PUSH
11056: LD_EXP 19
11060: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
11061: LD_STRING Information
11063: PPUSH
11064: LD_EXP 15
11068: PPUSH
11069: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
11073: LD_ADDR_VAR 0 2
11077: PUSH
11078: LD_INT 22
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 2
11090: PUSH
11091: LD_INT 25
11093: PUSH
11094: LD_INT 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 25
11103: PUSH
11104: LD_INT 16
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 34
11113: PUSH
11114: LD_INT 12
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PPUSH
11131: CALL_OW 69
11135: ST_TO_ADDR
// sib := GetTerminalCargo ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: CALL 943 0 0
11145: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
11146: LD_ADDR_VAR 0 3
11150: PUSH
11151: LD_VAR 0 3
11155: PUSH
11156: LD_INT 6
11158: PPUSH
11159: LD_INT 3
11161: PPUSH
11162: CALL_OW 287
11166: PLUS
11167: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11168: LD_ADDR_VAR 0 3
11172: PUSH
11173: LD_VAR 0 3
11177: PUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: LD_INT 3
11185: PPUSH
11186: CALL_OW 289
11190: PLUS
11191: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11192: LD_VAR 0 3
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_OWVAR 67
11204: PLUS
11205: PUSH
11206: LD_INT 50
11208: MUL
11209: LESS
11210: IFFALSE 11235
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11212: LD_STRING MuchSiberite
11214: PPUSH
11215: LD_INT 2
11217: NEG
11218: PUSH
11219: LD_OWVAR 67
11223: MUL
11224: PUSH
11225: LD_INT 1
11227: PLUS
11228: PPUSH
11229: CALL_OW 101
11233: GO 11253
// begin AddMedal ( MuchSiberite , 1 ) ;
11235: LD_STRING MuchSiberite
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 101
// m2 := true ;
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 1
11252: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11253: LD_VAR 0 4
11257: PUSH
11258: LD_VAR 0 5
11262: AND
11263: PUSH
11264: LD_VAR 0 6
11268: AND
11269: PUSH
11270: LD_OWVAR 67
11274: PUSH
11275: LD_INT 3
11277: EQUAL
11278: AND
11279: IFFALSE 11291
// SetAchievementEX ( ACH_AMER , 9 ) ;
11281: LD_STRING ACH_AMER
11283: PPUSH
11284: LD_INT 9
11286: PPUSH
11287: CALL_OW 564
// if tick <= 55 55$00 then
11291: LD_OWVAR 1
11295: PUSH
11296: LD_INT 115500
11298: LESSEQUAL
11299: IFFALSE 11308
// SetAchievement ( ACH_ASPEED_9 ) ;
11301: LD_STRING ACH_ASPEED_9
11303: PPUSH
11304: CALL_OW 543
// GiveMedals ( MAIN ) ;
11308: LD_STRING MAIN
11310: PPUSH
11311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PUSH
11325: LD_INT 2
11327: PUSH
11328: LD_INT 25
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 25
11340: PUSH
11341: LD_INT 2
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 25
11350: PUSH
11351: LD_INT 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: LD_INT 25
11360: PUSH
11361: LD_INT 4
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 25
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PPUSH
11395: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11399: LD_ADDR_VAR 0 2
11403: PUSH
11404: LD_INT 22
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 25
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 69
11432: ST_TO_ADDR
// if tmp then
11433: LD_VAR 0 2
11437: IFFALSE 11468
// for i in tmp do
11439: LD_ADDR_VAR 0 1
11443: PUSH
11444: LD_VAR 0 2
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11466
// SetClass ( i , 1 ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 336
11464: GO 11449
11466: POP
11467: POP
// SaveVariable ( sib , 09_sibRes ) ;
11468: LD_VAR 0 3
11472: PPUSH
11473: LD_STRING 09_sibRes
11475: PPUSH
11476: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11480: LD_EXP 15
11484: PPUSH
11485: LD_STRING 09_arInfo
11487: PPUSH
11488: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11492: LD_EXP 21
11496: PPUSH
11497: LD_EXP 1
11501: PUSH
11502: LD_STRING JMM
11504: STR
11505: PPUSH
11506: CALL_OW 38
// if IsLive ( Gary ) then
11510: LD_EXP 22
11514: PPUSH
11515: CALL_OW 300
11519: IFFALSE 11539
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11521: LD_EXP 22
11525: PPUSH
11526: LD_EXP 1
11530: PUSH
11531: LD_STRING Gary
11533: STR
11534: PPUSH
11535: CALL_OW 38
// if IsLive ( Bobby ) then
11539: LD_EXP 23
11543: PPUSH
11544: CALL_OW 300
11548: IFFALSE 11568
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11550: LD_EXP 23
11554: PPUSH
11555: LD_EXP 1
11559: PUSH
11560: LD_STRING Bobby
11562: STR
11563: PPUSH
11564: CALL_OW 38
// if IsLive ( Cyrus ) then
11568: LD_EXP 24
11572: PPUSH
11573: CALL_OW 300
11577: IFFALSE 11597
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11579: LD_EXP 24
11583: PPUSH
11584: LD_EXP 1
11588: PUSH
11589: LD_STRING Cyrus
11591: STR
11592: PPUSH
11593: CALL_OW 38
// if IsLive ( Houten ) then
11597: LD_EXP 25
11601: PPUSH
11602: CALL_OW 300
11606: IFFALSE 11626
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11608: LD_EXP 25
11612: PPUSH
11613: LD_EXP 1
11617: PUSH
11618: LD_STRING Houten
11620: STR
11621: PPUSH
11622: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 25
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 4
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 21
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 23
11714: PUSH
11715: LD_EXP 25
11719: PUSH
11720: LD_EXP 22
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: DIFF
11732: ST_TO_ADDR
// if tmp then
11733: LD_VAR 0 2
11737: IFFALSE 11757
// SaveCharacters ( tmp , mission_prefix & others ) ;
11739: LD_VAR 0 2
11743: PPUSH
11744: LD_EXP 1
11748: PUSH
11749: LD_STRING others
11751: STR
11752: PPUSH
11753: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11757: LD_ADDR_VAR 0 2
11761: PUSH
11762: LD_INT 22
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 12
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: LD_INT 25
11787: PUSH
11788: LD_INT 16
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PPUSH
11804: CALL_OW 69
11808: ST_TO_ADDR
// if tmp then
11809: LD_VAR 0 2
11813: IFFALSE 11833
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11815: LD_VAR 0 2
11819: PPUSH
11820: LD_EXP 1
11824: PUSH
11825: LD_STRING apes
11827: STR
11828: PPUSH
11829: CALL_OW 38
// if IsLive ( Yakotich ) then
11833: LD_EXP 37
11837: PPUSH
11838: CALL_OW 300
11842: IFFALSE 11862
// SaveCharacters ( Yakotich , mission_prefix & Yakotich ) ;
11844: LD_EXP 37
11848: PPUSH
11849: LD_EXP 1
11853: PUSH
11854: LD_STRING Yakotich
11856: STR
11857: PPUSH
11858: CALL_OW 38
// YouWin ;
11862: CALL_OW 103
// end ; end_of_file
11866: PPOPN 6
11868: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11869: LD_VAR 0 1
11873: PPUSH
11874: CALL_OW 266
11878: PUSH
11879: LD_INT 0
11881: EQUAL
11882: PUSH
11883: LD_EXP 3
11887: NOT
11888: AND
11889: IFFALSE 11913
// begin terminal := b ;
11891: LD_ADDR_EXP 3
11895: PUSH
11896: LD_VAR 0 1
11900: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11901: LD_EXP 3
11905: PPUSH
11906: LD_STRING terminal
11908: PPUSH
11909: CALL_OW 500
// end ; end ;
11913: PPOPN 2
11915: END
// on BuildingComplete ( b ) do var i ;
11916: LD_INT 0
11918: PPUSH
// begin if GetSide ( b ) = 3 then
11919: LD_VAR 0 1
11923: PPUSH
11924: CALL_OW 255
11928: PUSH
11929: LD_INT 3
11931: EQUAL
11932: IFFALSE 11972
// for i = 1 to 4 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 4
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11970
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11950: LD_ADDR_EXP 39
11954: PUSH
11955: LD_EXP 39
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 3
11967: ST_TO_ADDR
11968: GO 11947
11970: POP
11971: POP
// end ;
11972: PPOPN 2
11974: END
// on VehicleConstructed ( veh , fac ) do var i ;
11975: LD_INT 0
11977: PPUSH
// begin if GetSide ( veh ) = 3 then
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 255
11987: PUSH
11988: LD_INT 3
11990: EQUAL
11991: IFFALSE 12116
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 264
12002: PUSH
12003: LD_INT 53
12005: PUSH
12006: LD_INT 52
12008: PUSH
12009: LD_INT 51
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: LIST
12016: IN
12017: NOT
12018: IFFALSE 12036
// ru_force := ru_force ^ veh ;
12020: LD_ADDR_EXP 38
12024: PUSH
12025: LD_EXP 38
12029: PUSH
12030: LD_VAR 0 1
12034: ADD
12035: ST_TO_ADDR
// for i = 1 to 4 do
12036: LD_ADDR_VAR 0 3
12040: PUSH
12041: DOUBLE
12042: LD_INT 1
12044: DEC
12045: ST_TO_ADDR
12046: LD_INT 4
12048: PUSH
12049: FOR_TO
12050: IFFALSE 12072
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
12052: LD_ADDR_EXP 40
12056: PUSH
12057: LD_EXP 40
12061: PPUSH
12062: LD_INT 1
12064: PPUSH
12065: CALL_OW 3
12069: ST_TO_ADDR
12070: GO 12049
12072: POP
12073: POP
// if GetWeapon ( veh ) = ru_bulldozer then
12074: LD_VAR 0 1
12078: PPUSH
12079: CALL_OW 264
12083: PUSH
12084: LD_INT 53
12086: EQUAL
12087: IFFALSE 12116
// begin CutTreeInArea ( veh , cutTreeArea ) ;
12089: LD_VAR 0 1
12093: PPUSH
12094: LD_INT 7
12096: PPUSH
12097: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
12101: LD_VAR 0 1
12105: PPUSH
12106: LD_INT 170
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 171
// end ; end ; end ;
12116: PPOPN 3
12118: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
12119: LD_VAR 0 1
12123: PUSH
12124: LD_INT 1
12126: EQUAL
12127: PUSH
12128: LD_VAR 0 2
12132: PUSH
12133: LD_INT 2
12135: EQUAL
12136: AND
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 2
12145: EQUAL
12146: PUSH
12147: LD_VAR 0 2
12151: PUSH
12152: LD_INT 1
12154: EQUAL
12155: AND
12156: OR
12157: IFFALSE 12167
// player_attacked_ar := true ;
12159: LD_ADDR_EXP 16
12163: PUSH
12164: LD_INT 1
12166: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
12167: LD_VAR 0 1
12171: PUSH
12172: LD_INT 1
12174: EQUAL
12175: PUSH
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 4
12183: EQUAL
12184: AND
12185: PUSH
12186: LD_VAR 0 1
12190: PUSH
12191: LD_INT 4
12193: EQUAL
12194: PUSH
12195: LD_VAR 0 2
12199: PUSH
12200: LD_INT 1
12202: EQUAL
12203: AND
12204: OR
12205: IFFALSE 12214
// YouLost ( Traitor ) ;
12207: LD_STRING Traitor
12209: PPUSH
12210: CALL_OW 104
// end ;
12214: PPOPN 2
12216: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12217: LD_VAR 0 1
12221: PUSH
12222: LD_EXP 21
12226: EQUAL
12227: IFFALSE 12236
// YouLost ( JMM ) ;
12229: LD_STRING JMM
12231: PPUSH
12232: CALL_OW 104
// if un = terminal then
12236: LD_VAR 0 1
12240: PUSH
12241: LD_EXP 3
12245: EQUAL
12246: IFFALSE 12255
// YouLost ( Terminal ) ;
12248: LD_STRING Terminal
12250: PPUSH
12251: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 264
12264: PUSH
12265: LD_INT 53
12267: EQUAL
12268: IFFALSE 12284
// bulldozerCounter := bulldozerCounter + 1 ;
12270: LD_ADDR_EXP 20
12274: PUSH
12275: LD_EXP 20
12279: PUSH
12280: LD_INT 1
12282: PLUS
12283: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12284: LD_VAR 0 1
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 3
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 21
12301: PUSH
12302: LD_INT 3
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PPUSH
12313: CALL_OW 69
12317: IN
12318: IFFALSE 12464
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 266
12329: PUSH
12330: LD_INT 33
12332: PUSH
12333: LD_INT 26
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: IN
12340: IFFALSE 12399
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12342: LD_ADDR_EXP 39
12346: PUSH
12347: LD_EXP 39
12351: PUSH
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 266
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 250
12371: PUSH
12372: LD_VAR 0 1
12376: PPUSH
12377: CALL_OW 251
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 254
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: ADD
12398: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12399: LD_VAR 0 1
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_INT 5
12411: EQUAL
12412: IFFALSE 12464
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12414: LD_ADDR_EXP 39
12418: PUSH
12419: LD_EXP 39
12423: PUSH
12424: LD_INT 4
12426: PUSH
12427: LD_VAR 0 1
12431: PPUSH
12432: CALL_OW 250
12436: PUSH
12437: LD_VAR 0 1
12441: PPUSH
12442: CALL_OW 251
12446: PUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: ADD
12463: ST_TO_ADDR
// end ; if un in ru_force then
12464: LD_VAR 0 1
12468: PUSH
12469: LD_EXP 38
12473: IN
12474: IFFALSE 12510
// begin ru_force := ru_force diff un ;
12476: LD_ADDR_EXP 38
12480: PUSH
12481: LD_EXP 38
12485: PUSH
12486: LD_VAR 0 1
12490: DIFF
12491: ST_TO_ADDR
// if ru_force = 0 then
12492: LD_EXP 38
12496: PUSH
12497: LD_INT 0
12499: EQUAL
12500: IFFALSE 12510
// ru_can_attack := false ;
12502: LD_ADDR_EXP 8
12506: PUSH
12507: LD_INT 0
12509: ST_TO_ADDR
// end ; end ;
12510: PPOPN 1
12512: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12513: LD_VAR 0 1
12517: PPUSH
12518: CALL 29194 0 1
// end ; end_of_file
12522: PPOPN 1
12524: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12525: LD_EXP 5
12529: PUSH
12530: LD_EXP 6
12534: AND
12535: IFFALSE 12620
12537: GO 12539
12539: DISABLE
12540: LD_INT 0
12542: PPUSH
// begin enable ;
12543: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12544: LD_ADDR_VAR 0 1
12548: PUSH
12549: LD_INT 60
12551: PUSH
12552: CALL 943 0 0
12556: MINUS
12557: ST_TO_ADDR
// if sib < 0 then
12558: LD_VAR 0 1
12562: PUSH
12563: LD_INT 0
12565: LESS
12566: IFFALSE 12576
// sib := 0 ;
12568: LD_ADDR_VAR 0 1
12572: PUSH
12573: LD_INT 0
12575: ST_TO_ADDR
// if not debug then
12576: LD_EXP 2
12580: NOT
12581: IFFALSE 12606
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12583: LD_ADDR_OWVAR 47
12587: PUSH
12588: LD_STRING #Am09-1
12590: PUSH
12591: LD_VAR 0 1
12595: PUSH
12596: LD_EXP 6
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: LIST
12605: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12606: LD_ADDR_EXP 6
12610: PUSH
12611: LD_EXP 6
12615: PUSH
12616: LD_INT 35
12618: MINUS
12619: ST_TO_ADDR
// end ;
12620: PPOPN 1
12622: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12623: LD_EXP 6
12627: PUSH
12628: LD_INT 0
12630: EQUAL
12631: IFFALSE 12643
12633: GO 12635
12635: DISABLE
// display_strings := [ ] ;
12636: LD_ADDR_OWVAR 47
12640: PUSH
12641: EMPTY
12642: ST_TO_ADDR
12643: END
// every 1 1$35 do var i , tmp ;
12644: GO 12646
12646: DISABLE
12647: LD_INT 0
12649: PPUSH
12650: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: LD_INT 1155
12658: PUSH
12659: LD_INT 1225
12661: PUSH
12662: LD_INT 1435
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: LD_OWVAR 67
12674: ARRAY
12675: ST_TO_ADDR
// i := 0 ;
12676: LD_ADDR_VAR 0 1
12680: PUSH
12681: LD_INT 0
12683: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12684: LD_INT 1
12686: PPUSH
12687: LD_INT 5
12689: PPUSH
12690: CALL_OW 12
12694: PPUSH
12695: LD_INT 75
12697: PPUSH
12698: LD_INT 75
12700: PPUSH
12701: LD_INT 20
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL_OW 56
// wait ( tmp ) ;
12711: LD_VAR 0 2
12715: PPUSH
12716: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12720: LD_ADDR_VAR 0 2
12724: PUSH
12725: LD_VAR 0 2
12729: PUSH
12730: LD_INT 105
12732: PPUSH
12733: LD_INT 315
12735: PPUSH
12736: CALL_OW 12
12740: PLUS
12741: ST_TO_ADDR
// i := i + 1 ;
12742: LD_ADDR_VAR 0 1
12746: PUSH
12747: LD_VAR 0 1
12751: PUSH
12752: LD_INT 1
12754: PLUS
12755: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12756: LD_VAR 0 1
12760: PUSH
12761: LD_INT 3
12763: MOD
12764: PUSH
12765: LD_INT 0
12767: EQUAL
12768: PUSH
12769: LD_EXP 4
12773: AND
12774: IFFALSE 12812
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12776: LD_INT 2
12778: PPUSH
12779: LD_INT 5
12781: PPUSH
12782: CALL_OW 12
12786: PPUSH
12787: LD_INT 8
12789: PPUSH
12790: LD_INT 1
12792: PPUSH
12793: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12797: LD_INT 665
12799: PPUSH
12800: LD_INT 735
12802: PPUSH
12803: CALL_OW 12
12807: PPUSH
12808: CALL_OW 67
// end ; until tick > game_time ;
12812: LD_OWVAR 1
12816: PUSH
12817: LD_EXP 7
12821: GREATER
12822: IFFALSE 12684
// end ; end_of_file
12824: PPOPN 2
12826: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12827: LD_INT 0
12829: PPUSH
12830: PPUSH
12831: PPUSH
12832: PPUSH
12833: PPUSH
12834: PPUSH
// x := 76 ;
12835: LD_ADDR_VAR 0 5
12839: PUSH
12840: LD_INT 76
12842: ST_TO_ADDR
// y := 147 ;
12843: LD_ADDR_VAR 0 6
12847: PUSH
12848: LD_INT 147
12850: ST_TO_ADDR
// uc_side := 2 ;
12851: LD_ADDR_OWVAR 20
12855: PUSH
12856: LD_INT 2
12858: ST_TO_ADDR
// uc_nation := 2 ;
12859: LD_ADDR_OWVAR 21
12863: PUSH
12864: LD_INT 2
12866: ST_TO_ADDR
// InitHc ;
12867: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 6
12879: PPUSH
12880: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12884: LD_ADDR_OWVAR 26
12888: PUSH
12889: LD_STRING Nicolas Vervecken
12891: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12892: LD_ADDR_OWVAR 33
12896: PUSH
12897: LD_STRING SecondCharsGal
12899: ST_TO_ADDR
// hc_face_number := 3 ;
12900: LD_ADDR_OWVAR 34
12904: PUSH
12905: LD_INT 3
12907: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12908: LD_ADDR_OWVAR 29
12912: PUSH
12913: LD_INT 11
12915: PUSH
12916: LD_INT 10
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: ST_TO_ADDR
// Vervecken := CreateHuman ;
12923: LD_ADDR_EXP 29
12927: PUSH
12928: CALL_OW 44
12932: ST_TO_ADDR
// ar_force := Vervecken ;
12933: LD_ADDR_EXP 36
12937: PUSH
12938: LD_EXP 29
12942: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 2
12948: PPUSH
12949: LD_INT 6
12951: PPUSH
12952: CALL_OW 380
// hc_name := Louis Gali ;
12956: LD_ADDR_OWVAR 26
12960: PUSH
12961: LD_STRING Louis Gali
12963: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12964: LD_ADDR_OWVAR 33
12968: PUSH
12969: LD_STRING SecondCharsGal
12971: ST_TO_ADDR
// hc_face_number := 2 ;
12972: LD_ADDR_OWVAR 34
12976: PUSH
12977: LD_INT 2
12979: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12980: LD_ADDR_OWVAR 29
12984: PUSH
12985: LD_INT 10
12987: PUSH
12988: LD_INT 11
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// Gali := CreateHuman ;
12995: LD_ADDR_EXP 30
12999: PUSH
13000: CALL_OW 44
13004: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
13005: LD_ADDR_EXP 36
13009: PUSH
13010: LD_EXP 36
13014: PUSH
13015: LD_EXP 30
13019: ADD
13020: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
13021: LD_INT 2
13023: PPUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_INT 6
13029: PPUSH
13030: CALL_OW 380
// hc_name := Maria Bogdanovic ;
13034: LD_ADDR_OWVAR 26
13038: PUSH
13039: LD_STRING Maria Bogdanovic
13041: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13042: LD_ADDR_OWVAR 33
13046: PUSH
13047: LD_STRING SecondCharsGal
13049: ST_TO_ADDR
// hc_face_number := 14 ;
13050: LD_ADDR_OWVAR 34
13054: PUSH
13055: LD_INT 14
13057: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
13058: LD_ADDR_OWVAR 29
13062: PUSH
13063: LD_INT 12
13065: PUSH
13066: LD_INT 9
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
13073: LD_ADDR_EXP 31
13077: PUSH
13078: CALL_OW 44
13082: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
13083: LD_ADDR_EXP 36
13087: PUSH
13088: LD_EXP 36
13092: PUSH
13093: LD_EXP 31
13097: ADD
13098: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13099: LD_INT 1
13101: PPUSH
13102: LD_INT 3
13104: PPUSH
13105: LD_INT 6
13107: PPUSH
13108: CALL_OW 380
// hc_name = Kntor Radomr ;
13112: LD_ADDR_OWVAR 26
13116: PUSH
13117: LD_STRING Kntor Radomr
13119: ST_TO_ADDR
// hc_gallery = sandar ;
13120: LD_ADDR_OWVAR 33
13124: PUSH
13125: LD_STRING sandar
13127: ST_TO_ADDR
// hc_face_number = 12 ;
13128: LD_ADDR_OWVAR 34
13132: PUSH
13133: LD_INT 12
13135: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
13136: LD_ADDR_OWVAR 29
13140: PUSH
13141: LD_INT 9
13143: PUSH
13144: LD_INT 9
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: ST_TO_ADDR
// Kantor = CreateHuman ;
13151: LD_ADDR_EXP 32
13155: PUSH
13156: CALL_OW 44
13160: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
13161: LD_ADDR_EXP 36
13165: PUSH
13166: LD_EXP 36
13170: PUSH
13171: LD_EXP 32
13175: ADD
13176: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 3
13182: PPUSH
13183: LD_INT 6
13185: PPUSH
13186: CALL_OW 380
// hc_name = Herczeg Farkas ;
13190: LD_ADDR_OWVAR 26
13194: PUSH
13195: LD_STRING Herczeg Farkas
13197: ST_TO_ADDR
// hc_gallery = sandar ;
13198: LD_ADDR_OWVAR 33
13202: PUSH
13203: LD_STRING sandar
13205: ST_TO_ADDR
// hc_face_number = 28 ;
13206: LD_ADDR_OWVAR 34
13210: PUSH
13211: LD_INT 28
13213: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13214: LD_ADDR_OWVAR 29
13218: PUSH
13219: LD_INT 10
13221: PUSH
13222: LD_INT 9
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: ST_TO_ADDR
// Herczeg = CreateHuman ;
13229: LD_ADDR_EXP 33
13233: PUSH
13234: CALL_OW 44
13238: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13239: LD_ADDR_EXP 36
13243: PUSH
13244: LD_EXP 36
13248: PUSH
13249: LD_EXP 33
13253: ADD
13254: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13255: LD_INT 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: LD_INT 6
13263: PPUSH
13264: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13268: LD_ADDR_OWVAR 26
13272: PUSH
13273: LD_STRING Ronn Horntvedt
13275: ST_TO_ADDR
// hc_gallery = sandar ;
13276: LD_ADDR_OWVAR 33
13280: PUSH
13281: LD_STRING sandar
13283: ST_TO_ADDR
// hc_face_number = 29 ;
13284: LD_ADDR_OWVAR 34
13288: PUSH
13289: LD_INT 29
13291: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13292: LD_ADDR_OWVAR 29
13296: PUSH
13297: LD_INT 11
13299: PUSH
13300: LD_INT 11
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: ST_TO_ADDR
// Ronn = CreateHuman ;
13307: LD_ADDR_EXP 34
13311: PUSH
13312: CALL_OW 44
13316: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13317: LD_ADDR_EXP 36
13321: PUSH
13322: LD_EXP 36
13326: PUSH
13327: LD_EXP 34
13331: ADD
13332: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13333: LD_INT 2
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 6
13341: PPUSH
13342: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13346: LD_ADDR_OWVAR 26
13350: PUSH
13351: LD_STRING Mia D. Mathiasen
13353: ST_TO_ADDR
// hc_gallery = sandar ;
13354: LD_ADDR_OWVAR 33
13358: PUSH
13359: LD_STRING sandar
13361: ST_TO_ADDR
// hc_face_number = 31 ;
13362: LD_ADDR_OWVAR 34
13366: PUSH
13367: LD_INT 31
13369: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13370: LD_ADDR_OWVAR 29
13374: PUSH
13375: LD_INT 10
13377: PUSH
13378: LD_INT 10
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: ST_TO_ADDR
// Mia = CreateHuman ;
13385: LD_ADDR_EXP 35
13389: PUSH
13390: CALL_OW 44
13394: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13395: LD_ADDR_EXP 36
13399: PUSH
13400: LD_EXP 36
13404: PUSH
13405: LD_EXP 35
13409: ADD
13410: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13411: LD_ADDR_VAR 0 3
13415: PUSH
13416: LD_VAR 0 3
13420: PUSH
13421: LD_INT 2
13423: PPUSH
13424: LD_INT 2
13426: PPUSH
13427: LD_INT 14
13429: PPUSH
13430: LD_INT 1
13432: PPUSH
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 32
13438: PPUSH
13439: LD_INT 30
13441: PPUSH
13442: CALL 423 0 7
13446: ADD
13447: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_INT 2
13460: PPUSH
13461: LD_INT 2
13463: PPUSH
13464: LD_INT 14
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: LD_INT 1
13472: PPUSH
13473: LD_INT 27
13475: PPUSH
13476: LD_INT 30
13478: PPUSH
13479: CALL 423 0 7
13483: ADD
13484: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_VAR 0 3
13494: PUSH
13495: LD_INT 2
13497: PPUSH
13498: LD_INT 2
13500: PPUSH
13501: LD_INT 14
13503: PPUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_INT 25
13512: PPUSH
13513: LD_INT 33
13515: PPUSH
13516: CALL 423 0 7
13520: ADD
13521: ST_TO_ADDR
// tmp := tmp diff 0 ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_INT 0
13534: DIFF
13535: ST_TO_ADDR
// for i in ar_force do
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_EXP 36
13545: PUSH
13546: FOR_IN
13547: IFFALSE 13690
// begin if GetClass ( i ) = 3 then
13549: LD_VAR 0 4
13553: PPUSH
13554: CALL_OW 257
13558: PUSH
13559: LD_INT 3
13561: EQUAL
13562: IFFALSE 13644
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13564: LD_VAR 0 3
13568: PUSH
13569: LD_INT 1
13571: ARRAY
13572: PPUSH
13573: LD_INT 1
13575: PPUSH
13576: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: PPUSH
13589: LD_VAR 0 5
13593: PPUSH
13594: LD_VAR 0 6
13598: PPUSH
13599: LD_INT 0
13601: PPUSH
13602: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13606: LD_VAR 0 4
13610: PPUSH
13611: LD_VAR 0 3
13615: PUSH
13616: LD_INT 1
13618: ARRAY
13619: PPUSH
13620: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13624: LD_ADDR_VAR 0 3
13628: PUSH
13629: LD_VAR 0 3
13633: PPUSH
13634: LD_INT 1
13636: PPUSH
13637: CALL_OW 3
13641: ST_TO_ADDR
// end else
13642: GO 13666
// PlaceUnitXY ( i , x , y , false ) ;
13644: LD_VAR 0 4
13648: PPUSH
13649: LD_VAR 0 5
13653: PPUSH
13654: LD_VAR 0 6
13658: PPUSH
13659: LD_INT 0
13661: PPUSH
13662: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13666: LD_VAR 0 4
13670: PPUSH
13671: LD_INT 86
13673: PPUSH
13674: LD_INT 121
13676: PPUSH
13677: CALL_OW 111
// wait ( 0 0$2 ) ;
13681: LD_INT 70
13683: PPUSH
13684: CALL_OW 67
// end ;
13688: GO 13546
13690: POP
13691: POP
// ar_force := ar_force ^ tmp ;
13692: LD_ADDR_EXP 36
13696: PUSH
13697: LD_EXP 36
13701: PUSH
13702: LD_VAR 0 3
13706: ADD
13707: ST_TO_ADDR
// ar_spawned := true ;
13708: LD_ADDR_EXP 11
13712: PUSH
13713: LD_INT 1
13715: ST_TO_ADDR
// end ; end_of_file
13716: LD_VAR 0 1
13720: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13721: LD_INT 0
13723: PPUSH
13724: PPUSH
13725: PPUSH
13726: PPUSH
13727: PPUSH
13728: PPUSH
13729: PPUSH
// InitHc ;
13730: CALL_OW 19
// uc_side := 3 ;
13734: LD_ADDR_OWVAR 20
13738: PUSH
13739: LD_INT 3
13741: ST_TO_ADDR
// uc_nation := 3 ;
13742: LD_ADDR_OWVAR 21
13746: PUSH
13747: LD_INT 3
13749: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13750: LD_ADDR_VAR 0 5
13754: PUSH
13755: LD_INT 5
13757: PUSH
13758: LD_INT 6
13760: PUSH
13761: LD_INT 7
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: ST_TO_ADDR
// ru_force := [ ] ;
13775: LD_ADDR_EXP 38
13779: PUSH
13780: EMPTY
13781: ST_TO_ADDR
// ru_rebuild := [ ] ;
13782: LD_ADDR_EXP 39
13786: PUSH
13787: EMPTY
13788: ST_TO_ADDR
// ru_produce_list := [ ] ;
13789: LD_ADDR_EXP 40
13793: PUSH
13794: EMPTY
13795: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13796: LD_ADDR_VAR 0 6
13800: PUSH
13801: LD_INT 22
13803: PUSH
13804: LD_INT 3
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: PUSH
13811: LD_INT 30
13813: PUSH
13814: LD_INT 8
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PPUSH
13825: CALL_OW 69
13829: PUSH
13830: LD_INT 1
13832: ARRAY
13833: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13834: LD_ADDR_VAR 0 4
13838: PUSH
13839: LD_INT 43
13841: PUSH
13842: LD_INT 46
13844: PUSH
13845: LD_INT 45
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13853: LD_ADDR_VAR 0 7
13857: PUSH
13858: LD_INT 22
13860: PUSH
13861: LD_INT 3
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: LD_INT 30
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 69
13886: PUSH
13887: LD_INT 1
13889: ARRAY
13890: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13891: LD_VAR 0 7
13895: PPUSH
13896: CALL_OW 274
13900: PPUSH
13901: LD_INT 1
13903: PPUSH
13904: LD_INT 5000
13906: PPUSH
13907: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13911: LD_VAR 0 7
13915: PPUSH
13916: CALL_OW 274
13920: PPUSH
13921: LD_INT 2
13923: PPUSH
13924: LD_INT 1000
13926: PPUSH
13927: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13931: LD_VAR 0 7
13935: PPUSH
13936: CALL_OW 274
13940: PPUSH
13941: LD_INT 3
13943: PPUSH
13944: LD_INT 30
13946: PPUSH
13947: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 3
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: PUSH
13985: FOR_IN
13986: IFFALSE 14019
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
13988: LD_VAR 0 2
13992: PPUSH
13993: LD_INT 5
13995: PUSH
13996: LD_INT 6
13998: PUSH
13999: LD_INT 7
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: LIST
14006: PUSH
14007: LD_OWVAR 67
14011: ARRAY
14012: PPUSH
14013: CALL_OW 241
14017: GO 13985
14019: POP
14020: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 22
14028: PUSH
14029: LD_INT 3
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 30
14038: PUSH
14039: LD_INT 33
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: CALL_OW 69
14054: PUSH
14055: FOR_IN
14056: IFFALSE 14088
// PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
14058: LD_VAR 0 2
14062: PPUSH
14063: LD_VAR 0 4
14067: PUSH
14068: LD_VAR 0 2
14072: PUSH
14073: LD_INT 3
14075: MOD
14076: PUSH
14077: LD_INT 1
14079: PLUS
14080: ARRAY
14081: PPUSH
14082: CALL_OW 431
14086: GO 14055
14088: POP
14089: POP
// for i = 1 to 4 do
14090: LD_ADDR_VAR 0 2
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 4
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14165
// begin PrepareHuman ( false , class_bazooker , skill ) ;
14106: LD_INT 0
14108: PPUSH
14109: LD_INT 9
14111: PPUSH
14112: LD_VAR 0 5
14116: PPUSH
14117: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
14121: CALL_OW 44
14125: PPUSH
14126: LD_INT 22
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 30
14138: PUSH
14139: LD_INT 5
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PPUSH
14150: CALL_OW 69
14154: PUSH
14155: LD_INT 1
14157: ARRAY
14158: PPUSH
14159: CALL_OW 52
// end ;
14163: GO 14103
14165: POP
14166: POP
// for i = 1 to 5 do
14167: LD_ADDR_VAR 0 2
14171: PUSH
14172: DOUBLE
14173: LD_INT 1
14175: DEC
14176: ST_TO_ADDR
14177: LD_INT 5
14179: PUSH
14180: FOR_TO
14181: IFFALSE 14242
// begin PrepareHuman ( false , class_mechanic , skill ) ;
14183: LD_INT 0
14185: PPUSH
14186: LD_INT 3
14188: PPUSH
14189: LD_VAR 0 5
14193: PPUSH
14194: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
14198: CALL_OW 44
14202: PPUSH
14203: LD_INT 22
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 3
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 69
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: PPUSH
14236: CALL_OW 52
// end ;
14240: GO 14180
14242: POP
14243: POP
// for i = 1 to 4 do
14244: LD_ADDR_VAR 0 2
14248: PUSH
14249: DOUBLE
14250: LD_INT 1
14252: DEC
14253: ST_TO_ADDR
14254: LD_INT 4
14256: PUSH
14257: FOR_TO
14258: IFFALSE 14319
// begin PrepareHuman ( false , class_engineer , skill ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 2
14265: PPUSH
14266: LD_VAR 0 5
14270: PPUSH
14271: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_INT 22
14282: PUSH
14283: LD_INT 3
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: PUSH
14290: LD_INT 30
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: PPUSH
14304: CALL_OW 69
14308: PUSH
14309: LD_INT 1
14311: ARRAY
14312: PPUSH
14313: CALL_OW 52
// end ;
14317: GO 14257
14319: POP
14320: POP
// for i = 1 to 3 do
14321: LD_ADDR_VAR 0 2
14325: PUSH
14326: DOUBLE
14327: LD_INT 1
14329: DEC
14330: ST_TO_ADDR
14331: LD_INT 3
14333: PUSH
14334: FOR_TO
14335: IFFALSE 14368
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 4
14342: PPUSH
14343: LD_VAR 0 5
14347: PPUSH
14348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14352: CALL_OW 44
14356: PPUSH
14357: LD_VAR 0 6
14361: PPUSH
14362: CALL_OW 52
// end ;
14366: GO 14334
14368: POP
14369: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14370: LD_ADDR_EXP 37
14374: PUSH
14375: LD_STRING Yakotich
14377: PPUSH
14378: LD_EXP 2
14382: NOT
14383: PPUSH
14384: LD_STRING 
14386: PPUSH
14387: CALL 360 0 3
14391: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14392: LD_EXP 37
14396: PPUSH
14397: LD_INT 74
14399: PPUSH
14400: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14404: LD_VAR 0 6
14408: PPUSH
14409: LD_INT 49
14411: PPUSH
14412: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14416: LD_VAR 0 6
14420: PPUSH
14421: LD_INT 50
14423: PPUSH
14424: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14428: LD_VAR 0 6
14432: PPUSH
14433: LD_INT 51
14435: PPUSH
14436: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14440: LD_VAR 0 6
14444: PPUSH
14445: LD_INT 52
14447: PPUSH
14448: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14452: LD_VAR 0 6
14456: PPUSH
14457: LD_INT 69
14459: PPUSH
14460: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14464: LD_VAR 0 6
14468: PPUSH
14469: LD_INT 39
14471: PPUSH
14472: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14476: LD_VAR 0 6
14480: PPUSH
14481: LD_INT 34
14483: PPUSH
14484: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14488: LD_VAR 0 6
14492: PPUSH
14493: LD_INT 40
14495: PPUSH
14496: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14500: LD_VAR 0 6
14504: PPUSH
14505: LD_INT 57
14507: PPUSH
14508: CALL_OW 184
// if Difficulty > 1 then
14512: LD_OWVAR 67
14516: PUSH
14517: LD_INT 1
14519: GREATER
14520: IFFALSE 14534
// AddComResearch ( lab , tech_comp2 ) ;
14522: LD_VAR 0 6
14526: PPUSH
14527: LD_INT 58
14529: PPUSH
14530: CALL_OW 184
// end ;
14534: LD_VAR 0 1
14538: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14539: LD_INT 7
14541: PPUSH
14542: CALL_OW 353
14546: PUSH
14547: LD_INT 3
14549: GREATER
14550: PUSH
14551: LD_INT 22
14553: PUSH
14554: LD_INT 3
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PUSH
14561: LD_INT 34
14563: PUSH
14564: LD_INT 53
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: PPUSH
14575: CALL_OW 69
14579: NOT
14580: AND
14581: IFFALSE 14616
14583: GO 14585
14585: DISABLE
// begin enable ;
14586: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14587: LD_ADDR_EXP 40
14591: PUSH
14592: LD_EXP 40
14596: PUSH
14597: LD_INT 24
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 3
14605: PUSH
14606: LD_INT 53
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ADD
14615: ST_TO_ADDR
// end ;
14616: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14617: LD_INT 22
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 3
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: IFFALSE 15423
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
14658: PPUSH
14659: PPUSH
// begin enable ;
14660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14661: LD_ADDR_VAR 0 3
14665: PUSH
14666: LD_INT 22
14668: PUSH
14669: LD_INT 3
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 21
14678: PUSH
14679: LD_INT 3
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 3
14688: PUSH
14689: LD_INT 24
14691: PUSH
14692: LD_INT 1000
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14713: LD_ADDR_VAR 0 4
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: LD_INT 25
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PPUSH
14742: CALL_OW 69
14746: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14747: LD_ADDR_VAR 0 5
14751: PUSH
14752: LD_INT 22
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 30
14764: PUSH
14765: LD_INT 1
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PPUSH
14776: CALL_OW 69
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14785: LD_ADDR_VAR 0 8
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 3
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 6
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 30
14815: PUSH
14816: LD_INT 7
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 30
14825: PUSH
14826: LD_INT 8
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 1
14850: ARRAY
14851: ST_TO_ADDR
// if not engs then
14852: LD_VAR 0 4
14856: NOT
14857: IFFALSE 14861
// exit ;
14859: GO 15423
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14861: LD_ADDR_VAR 0 6
14865: PUSH
14866: LD_VAR 0 4
14870: PPUSH
14871: LD_INT 3
14873: PUSH
14874: LD_INT 24
14876: PUSH
14877: LD_INT 600
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 72
14892: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14893: LD_ADDR_VAR 0 7
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 3
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 4
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14927: LD_VAR 0 3
14931: NOT
14932: PUSH
14933: LD_EXP 39
14937: NOT
14938: AND
14939: IFFALSE 14999
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14941: LD_VAR 0 4
14945: PPUSH
14946: LD_INT 3
14948: PUSH
14949: LD_INT 54
14951: PUSH
14952: EMPTY
14953: LIST
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PPUSH
14959: CALL_OW 72
14963: IFFALSE 14997
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14965: LD_VAR 0 4
14969: PPUSH
14970: LD_INT 3
14972: PUSH
14973: LD_INT 54
14975: PUSH
14976: EMPTY
14977: LIST
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: CALL_OW 72
14987: PPUSH
14988: LD_VAR 0 5
14992: PPUSH
14993: CALL_OW 120
// exit ;
14997: GO 15423
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14999: LD_VAR 0 4
15003: PPUSH
15004: LD_INT 54
15006: PUSH
15007: EMPTY
15008: LIST
15009: PPUSH
15010: CALL_OW 72
15014: IFFALSE 15036
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
15016: LD_VAR 0 4
15020: PPUSH
15021: LD_INT 54
15023: PUSH
15024: EMPTY
15025: LIST
15026: PPUSH
15027: CALL_OW 72
15031: PPUSH
15032: CALL_OW 122
// if not tmp then
15036: LD_VAR 0 3
15040: NOT
15041: IFFALSE 15173
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
15043: LD_INT 81
15045: PUSH
15046: LD_INT 3
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 92
15055: PUSH
15056: LD_INT 147
15058: PUSH
15059: LD_INT 212
15061: PUSH
15062: LD_INT 30
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PPUSH
15075: CALL_OW 69
15079: NOT
15080: IFFALSE 15173
// begin if not HasTask ( engs [ 1 ] ) then
15082: LD_VAR 0 4
15086: PUSH
15087: LD_INT 1
15089: ARRAY
15090: PPUSH
15091: CALL_OW 314
15095: NOT
15096: IFFALSE 15173
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
15098: LD_ADDR_VAR 0 2
15102: PUSH
15103: LD_VAR 0 4
15107: PPUSH
15108: LD_EXP 39
15112: PUSH
15113: LD_INT 1
15115: ARRAY
15116: PPUSH
15117: LD_EXP 39
15121: PUSH
15122: LD_INT 2
15124: ARRAY
15125: PPUSH
15126: LD_EXP 39
15130: PUSH
15131: LD_INT 3
15133: ARRAY
15134: PPUSH
15135: LD_EXP 39
15139: PUSH
15140: LD_INT 4
15142: ARRAY
15143: PPUSH
15144: CALL_OW 145
15148: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
15149: LD_VAR 0 2
15153: PPUSH
15154: CALL_OW 266
15158: PUSH
15159: LD_INT 4
15161: EQUAL
15162: IFFALSE 15173
// AddComUpgrade ( i ) ;
15164: LD_VAR 0 2
15168: PPUSH
15169: CALL_OW 206
// end ; end ; end ; for i in engs do
15173: LD_ADDR_VAR 0 2
15177: PUSH
15178: LD_VAR 0 4
15182: PUSH
15183: FOR_IN
15184: IFFALSE 15302
// begin if i in to_heal and sci then
15186: LD_VAR 0 2
15190: PUSH
15191: LD_VAR 0 6
15195: IN
15196: PUSH
15197: LD_VAR 0 7
15201: AND
15202: IFFALSE 15253
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
15204: LD_VAR 0 2
15208: PPUSH
15209: LD_INT 149
15211: PPUSH
15212: LD_INT 220
15214: PPUSH
15215: CALL_OW 297
15219: PUSH
15220: LD_INT 5
15222: LESS
15223: IFFALSE 15227
// continue ;
15225: GO 15183
// ComMoveXY ( i , 149 , 220 ) ;
15227: LD_VAR 0 2
15231: PPUSH
15232: LD_INT 149
15234: PPUSH
15235: LD_INT 220
15237: PPUSH
15238: CALL_OW 111
// AddComHold ( i ) ;
15242: LD_VAR 0 2
15246: PPUSH
15247: CALL_OW 200
// end else
15251: GO 15300
// if not HasTask ( i ) or WantsToAttack ( i ) then
15253: LD_VAR 0 2
15257: PPUSH
15258: CALL_OW 314
15262: NOT
15263: PUSH
15264: LD_VAR 0 2
15268: PPUSH
15269: CALL_OW 319
15273: OR
15274: IFFALSE 15300
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15276: LD_VAR 0 2
15280: PPUSH
15281: LD_VAR 0 3
15285: PPUSH
15286: LD_VAR 0 2
15290: PPUSH
15291: CALL_OW 74
15295: PPUSH
15296: CALL_OW 130
// end ;
15300: GO 15183
15302: POP
15303: POP
// if to_heal and sci then
15304: LD_VAR 0 6
15308: PUSH
15309: LD_VAR 0 7
15313: AND
15314: IFFALSE 15375
// begin if UnitFilter ( sci , [ f_inside ] ) then
15316: LD_VAR 0 7
15320: PPUSH
15321: LD_INT 54
15323: PUSH
15324: EMPTY
15325: LIST
15326: PPUSH
15327: CALL_OW 72
15331: IFFALSE 15355
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15333: LD_VAR 0 7
15337: PPUSH
15338: LD_INT 54
15340: PUSH
15341: EMPTY
15342: LIST
15343: PPUSH
15344: CALL_OW 72
15348: PPUSH
15349: CALL_OW 122
15353: GO 15373
// ComHeal ( sci , to_heal [ 1 ] ) ;
15355: LD_VAR 0 7
15359: PPUSH
15360: LD_VAR 0 6
15364: PUSH
15365: LD_INT 1
15367: ARRAY
15368: PPUSH
15369: CALL_OW 128
// end else
15373: GO 15423
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 56
15382: PUSH
15383: EMPTY
15384: LIST
15385: PPUSH
15386: CALL_OW 72
15390: PUSH
15391: LD_VAR 0 8
15395: AND
15396: IFFALSE 15423
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15398: LD_VAR 0 7
15402: PPUSH
15403: LD_INT 56
15405: PUSH
15406: EMPTY
15407: LIST
15408: PPUSH
15409: CALL_OW 72
15413: PPUSH
15414: LD_VAR 0 8
15418: PPUSH
15419: CALL_OW 120
// end ;
15423: PPOPN 8
15425: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15426: LD_INT 22
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PPUSH
15450: CALL_OW 69
15454: PUSH
15455: LD_EXP 40
15459: AND
15460: IFFALSE 15586
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
15468: PPUSH
15469: PPUSH
// begin enable ;
15470: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 22
15478: PUSH
15479: LD_INT 3
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: LD_INT 30
15488: PUSH
15489: LD_INT 3
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PPUSH
15500: CALL_OW 69
15504: PUSH
15505: LD_INT 1
15507: ARRAY
15508: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15509: LD_VAR 0 3
15513: PPUSH
15514: CALL_OW 313
15518: PUSH
15519: LD_INT 0
15521: EQUAL
15522: IFFALSE 15526
// exit ;
15524: GO 15586
// if BuildingStatus ( fac ) = bs_idle then
15526: LD_VAR 0 3
15530: PPUSH
15531: CALL_OW 461
15535: PUSH
15536: LD_INT 2
15538: EQUAL
15539: IFFALSE 15586
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_EXP 40
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_EXP 40
15559: PUSH
15560: LD_INT 2
15562: ARRAY
15563: PPUSH
15564: LD_EXP 40
15568: PUSH
15569: LD_INT 3
15571: ARRAY
15572: PPUSH
15573: LD_EXP 40
15577: PUSH
15578: LD_INT 4
15580: ARRAY
15581: PPUSH
15582: CALL_OW 125
// end ;
15586: PPOPN 3
15588: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15589: LD_INT 0
15591: PPUSH
15592: PPUSH
15593: PPUSH
15594: PPUSH
15595: PPUSH
// uc_side := 3 ;
15596: LD_ADDR_OWVAR 20
15600: PUSH
15601: LD_INT 3
15603: ST_TO_ADDR
// uc_nation := 3 ;
15604: LD_ADDR_OWVAR 21
15608: PUSH
15609: LD_INT 3
15611: ST_TO_ADDR
// ru_can_attack := false ;
15612: LD_ADDR_EXP 8
15616: PUSH
15617: LD_INT 0
15619: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15620: LD_ADDR_VAR 0 6
15624: PUSH
15625: LD_INT 22
15627: PUSH
15628: LD_INT 3
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: LD_INT 30
15637: PUSH
15638: LD_INT 3
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL_OW 69
15653: ST_TO_ADDR
// if fac then
15654: LD_VAR 0 6
15658: IFFALSE 15810
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15660: LD_ADDR_EXP 40
15664: PUSH
15665: LD_INT 24
15667: PUSH
15668: LD_INT 1
15670: PUSH
15671: LD_INT 3
15673: PUSH
15674: LD_INT 43
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: ST_TO_ADDR
// if wave > 1 then
15683: LD_VAR 0 1
15687: PUSH
15688: LD_INT 1
15690: GREATER
15691: IFFALSE 15744
// for i = 1 to Difficulty do
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: DOUBLE
15699: LD_INT 1
15701: DEC
15702: ST_TO_ADDR
15703: LD_OWVAR 67
15707: PUSH
15708: FOR_TO
15709: IFFALSE 15742
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15711: LD_ADDR_EXP 40
15715: PUSH
15716: LD_EXP 40
15720: PUSH
15721: LD_INT 24
15723: PUSH
15724: LD_INT 1
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: LD_INT 45
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: LIST
15737: LIST
15738: ADD
15739: ST_TO_ADDR
15740: GO 15708
15742: POP
15743: POP
// repeat wait ( 0 0$1 ) ;
15744: LD_INT 35
15746: PPUSH
15747: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15751: LD_EXP 40
15755: PUSH
15756: LD_INT 4
15758: LESS
15759: PUSH
15760: LD_VAR 0 6
15764: PUSH
15765: LD_INT 1
15767: ARRAY
15768: PPUSH
15769: CALL_OW 313
15773: PUSH
15774: LD_INT 0
15776: EQUAL
15777: OR
15778: PUSH
15779: LD_VAR 0 6
15783: PUSH
15784: LD_INT 1
15786: ARRAY
15787: PPUSH
15788: CALL_OW 461
15792: PUSH
15793: LD_INT 8
15795: PUSH
15796: LD_INT 6
15798: PUSH
15799: LD_INT 7
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: IN
15807: OR
15808: IFFALSE 15744
// end ; case wave of 1 :
15810: LD_VAR 0 1
15814: PUSH
15815: LD_INT 1
15817: DOUBLE
15818: EQUAL
15819: IFTRUE 15823
15821: GO 15908
15823: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15824: LD_ADDR_VAR 0 3
15828: PUSH
15829: DOUBLE
15830: LD_INT 1
15832: DEC
15833: ST_TO_ADDR
15834: LD_INT 2
15836: PUSH
15837: LD_INT 3
15839: PUSH
15840: LD_INT 4
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: LIST
15847: PUSH
15848: LD_OWVAR 67
15852: ARRAY
15853: PUSH
15854: FOR_TO
15855: IFFALSE 15863
// Sold ;
15857: CALL 16134 0 0
15861: GO 15854
15863: POP
15864: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15865: LD_ADDR_VAR 0 3
15869: PUSH
15870: DOUBLE
15871: LD_INT 1
15873: DEC
15874: ST_TO_ADDR
15875: LD_INT 2
15877: PUSH
15878: LD_INT 3
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: PUSH
15889: LD_OWVAR 67
15893: ARRAY
15894: PUSH
15895: FOR_TO
15896: IFFALSE 15904
// Tank ;
15898: CALL 16264 0 0
15902: GO 15895
15904: POP
15905: POP
// end ; 2 .. 9 :
15906: GO 16121
15908: LD_INT 2
15910: DOUBLE
15911: GREATEREQUAL
15912: IFFALSE 15920
15914: LD_INT 9
15916: DOUBLE
15917: LESSEQUAL
15918: IFTRUE 15922
15920: GO 16027
15922: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15923: LD_ADDR_VAR 0 3
15927: PUSH
15928: DOUBLE
15929: LD_INT 1
15931: DEC
15932: ST_TO_ADDR
15933: LD_INT 2
15935: PUSH
15936: LD_INT 4
15938: PUSH
15939: LD_INT 5
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: PUSH
15947: LD_OWVAR 67
15951: ARRAY
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: LD_INT 2
15960: DIV
15961: PLUS
15962: PUSH
15963: FOR_TO
15964: IFFALSE 15972
// Sold ;
15966: CALL 16134 0 0
15970: GO 15963
15972: POP
15973: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15974: LD_ADDR_VAR 0 3
15978: PUSH
15979: DOUBLE
15980: LD_INT 1
15982: DEC
15983: ST_TO_ADDR
15984: LD_INT 2
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: PUSH
15998: LD_OWVAR 67
16002: ARRAY
16003: PUSH
16004: LD_VAR 0 1
16008: PUSH
16009: LD_INT 2
16011: DIV
16012: PLUS
16013: PUSH
16014: FOR_TO
16015: IFFALSE 16023
// Tank ;
16017: CALL 16264 0 0
16021: GO 16014
16023: POP
16024: POP
// end ; 10 :
16025: GO 16121
16027: LD_INT 10
16029: DOUBLE
16030: EQUAL
16031: IFTRUE 16035
16033: GO 16120
16035: POP
// begin for i = 1 to [ 12 , 14 , 16 ] [ Difficulty ] do
16036: LD_ADDR_VAR 0 3
16040: PUSH
16041: DOUBLE
16042: LD_INT 1
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 12
16048: PUSH
16049: LD_INT 14
16051: PUSH
16052: LD_INT 16
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: PUSH
16060: LD_OWVAR 67
16064: ARRAY
16065: PUSH
16066: FOR_TO
16067: IFFALSE 16075
// Sold ;
16069: CALL 16134 0 0
16073: GO 16066
16075: POP
16076: POP
// for i = 1 to [ 13 , 15 , 17 ] [ Difficulty ] do
16077: LD_ADDR_VAR 0 3
16081: PUSH
16082: DOUBLE
16083: LD_INT 1
16085: DEC
16086: ST_TO_ADDR
16087: LD_INT 13
16089: PUSH
16090: LD_INT 15
16092: PUSH
16093: LD_INT 17
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: LIST
16100: PUSH
16101: LD_OWVAR 67
16105: ARRAY
16106: PUSH
16107: FOR_TO
16108: IFFALSE 16116
// Tank ;
16110: CALL 16264 0 0
16114: GO 16107
16116: POP
16117: POP
// end ; end ;
16118: GO 16121
16120: POP
// ru_can_attack := true ;
16121: LD_ADDR_EXP 8
16125: PUSH
16126: LD_INT 1
16128: ST_TO_ADDR
// end ;
16129: LD_VAR 0 2
16133: RET
// function Sold ( ) ; var un , skill ; begin
16134: LD_INT 0
16136: PPUSH
16137: PPUSH
16138: PPUSH
// uc_side := 3 ;
16139: LD_ADDR_OWVAR 20
16143: PUSH
16144: LD_INT 3
16146: ST_TO_ADDR
// uc_nation := 3 ;
16147: LD_ADDR_OWVAR 21
16151: PUSH
16152: LD_INT 3
16154: ST_TO_ADDR
// InitHc ;
16155: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16159: LD_ADDR_VAR 0 3
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 6
16169: PUSH
16170: LD_INT 7
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: PUSH
16178: LD_OWVAR 67
16182: ARRAY
16183: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
16184: LD_INT 0
16186: PPUSH
16187: LD_INT 1
16189: PUSH
16190: LD_INT 9
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: LD_INT 1
16199: PPUSH
16200: LD_INT 2
16202: PPUSH
16203: CALL_OW 12
16207: ARRAY
16208: PPUSH
16209: LD_VAR 0 3
16213: PPUSH
16214: CALL_OW 380
// un := CreateHuman ;
16218: LD_ADDR_VAR 0 2
16222: PUSH
16223: CALL_OW 44
16227: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: LD_INT 4
16235: PPUSH
16236: LD_INT 0
16238: PPUSH
16239: CALL_OW 49
// ru_force := ru_force ^ un ;
16243: LD_ADDR_EXP 38
16247: PUSH
16248: LD_EXP 38
16252: PUSH
16253: LD_VAR 0 2
16257: ADD
16258: ST_TO_ADDR
// end ;
16259: LD_VAR 0 1
16263: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16264: LD_INT 0
16266: PPUSH
16267: PPUSH
16268: PPUSH
16269: PPUSH
16270: PPUSH
// uc_side := 3 ;
16271: LD_ADDR_OWVAR 20
16275: PUSH
16276: LD_INT 3
16278: ST_TO_ADDR
// uc_nation := 3 ;
16279: LD_ADDR_OWVAR 21
16283: PUSH
16284: LD_INT 3
16286: ST_TO_ADDR
// InitHc ;
16287: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16291: LD_ADDR_VAR 0 5
16295: PUSH
16296: LD_INT 5
16298: PUSH
16299: LD_INT 6
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: LIST
16309: PUSH
16310: LD_OWVAR 67
16314: ARRAY
16315: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16316: LD_ADDR_VAR 0 3
16320: PUSH
16321: LD_INT 22
16323: PUSH
16324: LD_INT 24
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: LD_INT 1
16333: PPUSH
16334: LD_INT 2
16336: PPUSH
16337: CALL_OW 12
16341: ARRAY
16342: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16343: LD_VAR 0 3
16347: PUSH
16348: LD_INT 22
16350: EQUAL
16351: IFFALSE 16386
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16353: LD_ADDR_VAR 0 4
16357: PUSH
16358: LD_INT 45
16360: PUSH
16361: LD_INT 43
16363: PUSH
16364: LD_INT 44
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 1
16374: PPUSH
16375: LD_INT 3
16377: PPUSH
16378: CALL_OW 12
16382: ARRAY
16383: ST_TO_ADDR
16384: GO 16417
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16386: LD_ADDR_VAR 0 4
16390: PUSH
16391: LD_INT 46
16393: PUSH
16394: LD_INT 44
16396: PUSH
16397: LD_INT 45
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 3
16410: PPUSH
16411: CALL_OW 12
16415: ARRAY
16416: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 3
16427: PPUSH
16428: LD_VAR 0 3
16432: PPUSH
16433: LD_INT 1
16435: PPUSH
16436: LD_INT 3
16438: PUSH
16439: LD_INT 3
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: LD_INT 1
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_INT 4
16459: PPUSH
16460: CALL_OW 12
16464: ARRAY
16465: PPUSH
16466: LD_VAR 0 4
16470: PPUSH
16471: LD_INT 99
16473: PPUSH
16474: CALL 423 0 7
16478: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 263
16488: PUSH
16489: LD_INT 1
16491: EQUAL
16492: IFFALSE 16523
// begin PrepareHuman ( false , 3 , skill ) ;
16494: LD_INT 0
16496: PPUSH
16497: LD_INT 3
16499: PPUSH
16500: LD_VAR 0 5
16504: PPUSH
16505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16509: CALL_OW 44
16513: PPUSH
16514: LD_VAR 0 2
16518: PPUSH
16519: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16523: LD_VAR 0 2
16527: PPUSH
16528: LD_INT 3
16530: PPUSH
16531: LD_INT 0
16533: PPUSH
16534: CALL_OW 49
// ru_force := ru_force ^ un ;
16538: LD_ADDR_EXP 38
16542: PUSH
16543: LD_EXP 38
16547: PUSH
16548: LD_VAR 0 2
16552: ADD
16553: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16554: LD_VAR 0 2
16558: PPUSH
16559: LD_INT 126
16561: PPUSH
16562: LD_INT 158
16564: PPUSH
16565: CALL_OW 111
// Wait ( 0 0$3 ) ;
16569: LD_INT 105
16571: PPUSH
16572: CALL_OW 67
// ComStop ( un ) ;
16576: LD_VAR 0 2
16580: PPUSH
16581: CALL_OW 141
// end ;
16585: LD_VAR 0 1
16589: RET
// every 0 0$1 do var i , time , wave ;
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16598: LD_ADDR_VAR 0 2
16602: PUSH
16603: LD_INT 25200
16605: PUSH
16606: LD_INT 24150
16608: PUSH
16609: LD_INT 23100
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: LD_OWVAR 67
16621: ARRAY
16622: ST_TO_ADDR
// wait ( time ) ;
16623: LD_VAR 0 2
16627: PPUSH
16628: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16632: LD_ADDR_VAR 0 2
16636: PUSH
16637: LD_INT 15750
16639: PUSH
16640: LD_INT 15400
16642: PUSH
16643: LD_INT 15050
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: LIST
16650: PUSH
16651: LD_OWVAR 67
16655: ARRAY
16656: ST_TO_ADDR
// wave := 0 ;
16657: LD_ADDR_VAR 0 3
16661: PUSH
16662: LD_INT 0
16664: ST_TO_ADDR
// while true do
16665: LD_INT 1
16667: IFFALSE 16771
// begin wave := wave + 1 ;
16669: LD_ADDR_VAR 0 3
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_INT 1
16681: PLUS
16682: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16683: LD_INT 22
16685: PUSH
16686: LD_INT 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: IFFALSE 16733
// begin repeat wait ( 0 0$1 ) ;
16699: LD_INT 35
16701: PPUSH
16702: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16706: LD_INT 22
16708: PUSH
16709: LD_INT 2
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: PPUSH
16716: CALL_OW 69
16720: PUSH
16721: LD_INT 0
16723: EQUAL
16724: IFFALSE 16699
// wait ( 1 1$30 ) ;
16726: LD_INT 3150
16728: PPUSH
16729: CALL_OW 67
// end ; if ru_force < 20 then
16733: LD_EXP 38
16737: PUSH
16738: LD_INT 20
16740: LESS
16741: IFFALSE 16752
// PrepareAttack ( wave ) ;
16743: LD_VAR 0 3
16747: PPUSH
16748: CALL 15589 0 1
// ru_can_attack := true ;
16752: LD_ADDR_EXP 8
16756: PUSH
16757: LD_INT 1
16759: ST_TO_ADDR
// wait ( time ) ;
16760: LD_VAR 0 2
16764: PPUSH
16765: CALL_OW 67
// end ;
16769: GO 16665
// end ;
16771: PPOPN 3
16773: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16774: LD_EXP 8
16778: PUSH
16779: LD_EXP 38
16783: AND
16784: IFFALSE 17618
16786: GO 16788
16788: DISABLE
16789: LD_INT 0
16791: PPUSH
16792: PPUSH
16793: PPUSH
16794: PPUSH
16795: PPUSH
16796: PPUSH
16797: PPUSH
16798: PPUSH
16799: PPUSH
// begin enable ;
16800: ENABLE
// points1 := [ 107 , 123 ] ;
16801: LD_ADDR_VAR 0 4
16805: PUSH
16806: LD_INT 107
16808: PUSH
16809: LD_INT 123
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: LD_INT 55
16823: PUSH
16824: LD_INT 42
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16831: LD_ADDR_VAR 0 6
16835: PUSH
16836: LD_INT 102
16838: PUSH
16839: LD_INT 140
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PUSH
16846: LD_INT 105
16848: PUSH
16849: LD_INT 142
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 129
16858: PUSH
16859: LD_INT 131
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: ST_TO_ADDR
// for i in ru_force do
16871: LD_ADDR_VAR 0 1
16875: PUSH
16876: LD_EXP 38
16880: PUSH
16881: FOR_IN
16882: IFFALSE 17616
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16884: LD_ADDR_VAR 0 3
16888: PUSH
16889: LD_INT 81
16891: PUSH
16892: LD_INT 3
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: PPUSH
16899: CALL_OW 69
16903: PPUSH
16904: LD_VAR 0 1
16908: PPUSH
16909: CALL_OW 74
16913: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16914: LD_VAR 0 1
16918: PPUSH
16919: LD_VAR 0 3
16923: PPUSH
16924: CALL_OW 296
16928: PUSH
16929: LD_INT 12
16931: LESS
16932: IFFALSE 17077
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16934: LD_VAR 0 1
16938: PPUSH
16939: CALL_OW 247
16943: PUSH
16944: LD_INT 1
16946: EQUAL
16947: PUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 257
16957: PUSH
16958: LD_INT 1
16960: EQUAL
16961: AND
16962: PUSH
16963: LD_VAR 0 3
16967: PUSH
16968: LD_INT 21
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 58
16980: PUSH
16981: EMPTY
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PPUSH
16988: CALL_OW 69
16992: IN
16993: AND
16994: IFFALSE 17012
// ComEnterUnit ( i , un ) else
16996: LD_VAR 0 1
17000: PPUSH
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 120
17010: GO 17075
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
17012: LD_VAR 0 3
17016: PUSH
17017: LD_INT 21
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 58
17029: PUSH
17030: EMPTY
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: PPUSH
17037: CALL_OW 69
17041: IN
17042: NOT
17043: IFFALSE 17061
// ComAttackUnit ( i , un ) else
17045: LD_VAR 0 1
17049: PPUSH
17050: LD_VAR 0 3
17054: PPUSH
17055: CALL_OW 115
17059: GO 17075
// ComAttackUnit ( i , JMM ) ;
17061: LD_VAR 0 1
17065: PPUSH
17066: LD_EXP 21
17070: PPUSH
17071: CALL_OW 115
// end else
17075: GO 17614
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
17077: LD_VAR 0 1
17081: PPUSH
17082: LD_VAR 0 4
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_VAR 0 4
17095: PUSH
17096: LD_INT 2
17098: ARRAY
17099: PPUSH
17100: CALL_OW 297
17104: PUSH
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 5
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 2
17126: ARRAY
17127: PPUSH
17128: CALL_OW 297
17132: GREATER
17133: PUSH
17134: LD_EXP 9
17138: AND
17139: PUSH
17140: LD_INT 9
17142: PPUSH
17143: LD_INT 81
17145: PUSH
17146: LD_INT 3
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PPUSH
17153: CALL_OW 70
17157: PUSH
17158: LD_INT 0
17160: EQUAL
17161: OR
17162: IFFALSE 17200
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
17164: LD_VAR 0 1
17168: PPUSH
17169: LD_INT 81
17171: PUSH
17172: LD_INT 3
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PPUSH
17179: CALL_OW 69
17183: PPUSH
17184: LD_VAR 0 1
17188: PPUSH
17189: CALL_OW 74
17193: PPUSH
17194: CALL_OW 115
17198: GO 17614
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 264
17209: PUSH
17210: LD_INT 45
17212: EQUAL
17213: PUSH
17214: LD_EXP 38
17218: PPUSH
17219: LD_INT 3
17221: PUSH
17222: LD_INT 34
17224: PUSH
17225: LD_INT 45
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PPUSH
17236: CALL_OW 72
17240: PUSH
17241: LD_INT 6
17243: GREATER
17244: AND
17245: IFFALSE 17426
// begin dist := 9999 ;
17247: LD_ADDR_VAR 0 8
17251: PUSH
17252: LD_INT 9999
17254: ST_TO_ADDR
// xy := 0 ;
17255: LD_ADDR_VAR 0 9
17259: PUSH
17260: LD_INT 0
17262: ST_TO_ADDR
// for x in pointsr do
17263: LD_ADDR_VAR 0 7
17267: PUSH
17268: LD_VAR 0 6
17272: PUSH
17273: FOR_IN
17274: IFFALSE 17422
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17276: LD_VAR 0 1
17280: PPUSH
17281: LD_VAR 0 7
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: LD_VAR 0 7
17294: PUSH
17295: LD_INT 2
17297: ARRAY
17298: PPUSH
17299: CALL_OW 297
17303: PUSH
17304: LD_VAR 0 8
17308: LESS
17309: IFFALSE 17354
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17311: LD_ADDR_VAR 0 8
17315: PUSH
17316: LD_VAR 0 1
17320: PPUSH
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: LD_VAR 0 7
17334: PUSH
17335: LD_INT 2
17337: ARRAY
17338: PPUSH
17339: CALL_OW 297
17343: ST_TO_ADDR
// xy := x ;
17344: LD_ADDR_VAR 0 9
17348: PUSH
17349: LD_VAR 0 7
17353: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17354: LD_VAR 0 9
17358: PUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: LD_VAR 0 9
17368: PUSH
17369: LD_INT 1
17371: ARRAY
17372: PPUSH
17373: LD_VAR 0 9
17377: PUSH
17378: LD_INT 2
17380: ARRAY
17381: PPUSH
17382: CALL_OW 297
17386: PUSH
17387: LD_INT 9
17389: GREATER
17390: AND
17391: IFFALSE 17420
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17393: LD_VAR 0 1
17397: PPUSH
17398: LD_VAR 0 9
17402: PUSH
17403: LD_INT 1
17405: ARRAY
17406: PPUSH
17407: LD_VAR 0 9
17411: PUSH
17412: LD_INT 2
17414: ARRAY
17415: PPUSH
17416: CALL_OW 114
// end ;
17420: GO 17273
17422: POP
17423: POP
// end else
17424: GO 17614
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_OWVAR 3
17435: PUSH
17436: LD_VAR 0 1
17440: DIFF
17441: PPUSH
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 74
17451: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 320
17461: NOT
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_INT 21
17470: PUSH
17471: LD_INT 2
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PUSH
17478: LD_INT 33
17480: PUSH
17481: LD_INT 1
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: LD_INT 58
17490: PUSH
17491: EMPTY
17492: LIST
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: PPUSH
17499: CALL_OW 69
17503: IN
17504: PUSH
17505: LD_VAR 0 3
17509: PUSH
17510: LD_INT 22
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: EMPTY
17517: LIST
17518: LIST
17519: PUSH
17520: LD_INT 21
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: PUSH
17530: LD_INT 3
17532: PUSH
17533: LD_INT 24
17535: PUSH
17536: LD_INT 249
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 69
17556: IN
17557: OR
17558: AND
17559: IFFALSE 17577
// ComAttackUnit ( i , un ) else
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_VAR 0 3
17570: PPUSH
17571: CALL_OW 115
17575: GO 17614
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17577: LD_VAR 0 1
17581: PPUSH
17582: LD_INT 9
17584: PPUSH
17585: LD_INT 81
17587: PUSH
17588: LD_INT 3
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 70
17599: PPUSH
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL_OW 74
17609: PPUSH
17610: CALL_OW 115
// end ; end ; end ; end ;
17614: GO 16881
17616: POP
17617: POP
// end ;
17618: PPOPN 9
17620: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17621: LD_INT 22
17623: PUSH
17624: LD_INT 3
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 32
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: IFFALSE 17737
17651: GO 17653
17653: DISABLE
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// begin enable ;
17658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17659: LD_ADDR_VAR 0 2
17663: PUSH
17664: LD_INT 22
17666: PUSH
17667: LD_INT 3
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: LD_INT 32
17676: PUSH
17677: LD_INT 1
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PPUSH
17688: CALL_OW 69
17692: ST_TO_ADDR
// for i in tmp do
17693: LD_ADDR_VAR 0 1
17697: PUSH
17698: LD_VAR 0 2
17702: PUSH
17703: FOR_IN
17704: IFFALSE 17735
// if GetFuel ( i ) < 12 then
17706: LD_VAR 0 1
17710: PPUSH
17711: CALL_OW 261
17715: PUSH
17716: LD_INT 12
17718: LESS
17719: IFFALSE 17733
// SetFuel ( i , 12 ) ;
17721: LD_VAR 0 1
17725: PPUSH
17726: LD_INT 12
17728: PPUSH
17729: CALL_OW 240
17733: GO 17703
17735: POP
17736: POP
// end ;
17737: PPOPN 2
17739: END
// every 0 0$1 trigger can_end do var i , un , wave ;
17740: LD_EXP 17
17744: IFFALSE 17918
17746: GO 17748
17748: DISABLE
17749: LD_INT 0
17751: PPUSH
17752: PPUSH
17753: PPUSH
// begin wave := 0 ;
17754: LD_ADDR_VAR 0 3
17758: PUSH
17759: LD_INT 0
17761: ST_TO_ADDR
// repeat wait ( 1 1$35 ) ;
17762: LD_INT 3325
17764: PPUSH
17765: CALL_OW 67
// PrepareAttack ( 10 ) ;
17769: LD_INT 10
17771: PPUSH
17772: CALL 15589 0 1
// wave := wave + 1 ;
17776: LD_ADDR_VAR 0 3
17780: PUSH
17781: LD_VAR 0 3
17785: PUSH
17786: LD_INT 1
17788: PLUS
17789: ST_TO_ADDR
// if wave > 1 then
17790: LD_VAR 0 3
17794: PUSH
17795: LD_INT 1
17797: GREATER
17798: IFFALSE 17914
// begin for i := 1 to 6 do
17800: LD_ADDR_VAR 0 1
17804: PUSH
17805: DOUBLE
17806: LD_INT 1
17808: DEC
17809: ST_TO_ADDR
17810: LD_INT 6
17812: PUSH
17813: FOR_TO
17814: IFFALSE 17912
// begin uc_side := 3 ;
17816: LD_ADDR_OWVAR 20
17820: PUSH
17821: LD_INT 3
17823: ST_TO_ADDR
// uc_nation := 3 ;
17824: LD_ADDR_OWVAR 21
17828: PUSH
17829: LD_INT 3
17831: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , 9 ) ;
17832: LD_INT 0
17834: PPUSH
17835: LD_INT 1
17837: PUSH
17838: LD_INT 9
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: PUSH
17845: LD_INT 1
17847: PPUSH
17848: LD_INT 2
17850: PPUSH
17851: CALL_OW 12
17855: ARRAY
17856: PPUSH
17857: LD_INT 9
17859: PPUSH
17860: CALL_OW 380
// un := CreateHuman ;
17864: LD_ADDR_VAR 0 2
17868: PUSH
17869: CALL_OW 44
17873: ST_TO_ADDR
// PlaceUnitXYR ( un , 12 , 20 , 4 , false ) ;
17874: LD_VAR 0 2
17878: PPUSH
17879: LD_INT 12
17881: PPUSH
17882: LD_INT 20
17884: PPUSH
17885: LD_INT 4
17887: PPUSH
17888: LD_INT 0
17890: PPUSH
17891: CALL_OW 50
// ComAgressiveMove ( un , 49 , 32 ) ;
17895: LD_VAR 0 2
17899: PPUSH
17900: LD_INT 49
17902: PPUSH
17903: LD_INT 32
17905: PPUSH
17906: CALL_OW 114
// end ;
17910: GO 17813
17912: POP
17913: POP
// end ; until false ;
17914: LD_INT 0
17916: IFFALSE 17762
// end ; end_of_file
17918: PPOPN 3
17920: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
17921: GO 17923
17923: DISABLE
// begin ru_radar := 98 ;
17924: LD_ADDR_EXP 41
17928: PUSH
17929: LD_INT 98
17931: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17932: LD_ADDR_EXP 42
17936: PUSH
17937: LD_INT 89
17939: ST_TO_ADDR
// us_hack := 99 ;
17940: LD_ADDR_EXP 43
17944: PUSH
17945: LD_INT 99
17947: ST_TO_ADDR
// us_artillery := 97 ;
17948: LD_ADDR_EXP 44
17952: PUSH
17953: LD_INT 97
17955: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17956: LD_ADDR_EXP 45
17960: PUSH
17961: LD_INT 91
17963: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
17964: LD_ADDR_EXP 46
17968: PUSH
17969: LD_INT 92
17971: ST_TO_ADDR
// tech_Artillery := 80 ;
17972: LD_ADDR_EXP 47
17976: PUSH
17977: LD_INT 80
17979: ST_TO_ADDR
// tech_RadMat := 81 ;
17980: LD_ADDR_EXP 48
17984: PUSH
17985: LD_INT 81
17987: ST_TO_ADDR
// tech_BasicTools := 82 ;
17988: LD_ADDR_EXP 49
17992: PUSH
17993: LD_INT 82
17995: ST_TO_ADDR
// tech_Cargo := 83 ;
17996: LD_ADDR_EXP 50
18000: PUSH
18001: LD_INT 83
18003: ST_TO_ADDR
// tech_Track := 84 ;
18004: LD_ADDR_EXP 51
18008: PUSH
18009: LD_INT 84
18011: ST_TO_ADDR
// tech_Crane := 85 ;
18012: LD_ADDR_EXP 52
18016: PUSH
18017: LD_INT 85
18019: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18020: LD_ADDR_EXP 53
18024: PUSH
18025: LD_INT 86
18027: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18028: LD_ADDR_EXP 54
18032: PUSH
18033: LD_INT 87
18035: ST_TO_ADDR
// end ; end_of_file end_of_file
18036: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18037: GO 18039
18039: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18040: LD_STRING initStreamRollete();
18042: PPUSH
18043: CALL_OW 559
// InitStreamMode ;
18047: CALL 18056 0 0
// DefineStreamItems ( ) ;
18051: CALL 18496 0 0
// end ;
18055: END
// function InitStreamMode ; begin
18056: LD_INT 0
18058: PPUSH
// streamModeActive := false ;
18059: LD_ADDR_EXP 55
18063: PUSH
18064: LD_INT 0
18066: ST_TO_ADDR
// normalCounter := 36 ;
18067: LD_ADDR_EXP 56
18071: PUSH
18072: LD_INT 36
18074: ST_TO_ADDR
// hardcoreCounter := 16 ;
18075: LD_ADDR_EXP 57
18079: PUSH
18080: LD_INT 16
18082: ST_TO_ADDR
// sRocket := false ;
18083: LD_ADDR_EXP 60
18087: PUSH
18088: LD_INT 0
18090: ST_TO_ADDR
// sSpeed := false ;
18091: LD_ADDR_EXP 59
18095: PUSH
18096: LD_INT 0
18098: ST_TO_ADDR
// sEngine := false ;
18099: LD_ADDR_EXP 61
18103: PUSH
18104: LD_INT 0
18106: ST_TO_ADDR
// sSpec := false ;
18107: LD_ADDR_EXP 58
18111: PUSH
18112: LD_INT 0
18114: ST_TO_ADDR
// sLevel := false ;
18115: LD_ADDR_EXP 62
18119: PUSH
18120: LD_INT 0
18122: ST_TO_ADDR
// sArmoury := false ;
18123: LD_ADDR_EXP 63
18127: PUSH
18128: LD_INT 0
18130: ST_TO_ADDR
// sRadar := false ;
18131: LD_ADDR_EXP 64
18135: PUSH
18136: LD_INT 0
18138: ST_TO_ADDR
// sBunker := false ;
18139: LD_ADDR_EXP 65
18143: PUSH
18144: LD_INT 0
18146: ST_TO_ADDR
// sHack := false ;
18147: LD_ADDR_EXP 66
18151: PUSH
18152: LD_INT 0
18154: ST_TO_ADDR
// sFire := false ;
18155: LD_ADDR_EXP 67
18159: PUSH
18160: LD_INT 0
18162: ST_TO_ADDR
// sRefresh := false ;
18163: LD_ADDR_EXP 68
18167: PUSH
18168: LD_INT 0
18170: ST_TO_ADDR
// sExp := false ;
18171: LD_ADDR_EXP 69
18175: PUSH
18176: LD_INT 0
18178: ST_TO_ADDR
// sDepot := false ;
18179: LD_ADDR_EXP 70
18183: PUSH
18184: LD_INT 0
18186: ST_TO_ADDR
// sFlag := false ;
18187: LD_ADDR_EXP 71
18191: PUSH
18192: LD_INT 0
18194: ST_TO_ADDR
// sKamikadze := false ;
18195: LD_ADDR_EXP 79
18199: PUSH
18200: LD_INT 0
18202: ST_TO_ADDR
// sTroll := false ;
18203: LD_ADDR_EXP 80
18207: PUSH
18208: LD_INT 0
18210: ST_TO_ADDR
// sSlow := false ;
18211: LD_ADDR_EXP 81
18215: PUSH
18216: LD_INT 0
18218: ST_TO_ADDR
// sLack := false ;
18219: LD_ADDR_EXP 82
18223: PUSH
18224: LD_INT 0
18226: ST_TO_ADDR
// sTank := false ;
18227: LD_ADDR_EXP 84
18231: PUSH
18232: LD_INT 0
18234: ST_TO_ADDR
// sRemote := false ;
18235: LD_ADDR_EXP 85
18239: PUSH
18240: LD_INT 0
18242: ST_TO_ADDR
// sPowell := false ;
18243: LD_ADDR_EXP 86
18247: PUSH
18248: LD_INT 0
18250: ST_TO_ADDR
// sTeleport := false ;
18251: LD_ADDR_EXP 89
18255: PUSH
18256: LD_INT 0
18258: ST_TO_ADDR
// sOilTower := false ;
18259: LD_ADDR_EXP 91
18263: PUSH
18264: LD_INT 0
18266: ST_TO_ADDR
// sShovel := false ;
18267: LD_ADDR_EXP 92
18271: PUSH
18272: LD_INT 0
18274: ST_TO_ADDR
// sSheik := false ;
18275: LD_ADDR_EXP 93
18279: PUSH
18280: LD_INT 0
18282: ST_TO_ADDR
// sEarthquake := false ;
18283: LD_ADDR_EXP 95
18287: PUSH
18288: LD_INT 0
18290: ST_TO_ADDR
// sAI := false ;
18291: LD_ADDR_EXP 96
18295: PUSH
18296: LD_INT 0
18298: ST_TO_ADDR
// sCargo := false ;
18299: LD_ADDR_EXP 99
18303: PUSH
18304: LD_INT 0
18306: ST_TO_ADDR
// sDLaser := false ;
18307: LD_ADDR_EXP 100
18311: PUSH
18312: LD_INT 0
18314: ST_TO_ADDR
// sExchange := false ;
18315: LD_ADDR_EXP 101
18319: PUSH
18320: LD_INT 0
18322: ST_TO_ADDR
// sFac := false ;
18323: LD_ADDR_EXP 102
18327: PUSH
18328: LD_INT 0
18330: ST_TO_ADDR
// sPower := false ;
18331: LD_ADDR_EXP 103
18335: PUSH
18336: LD_INT 0
18338: ST_TO_ADDR
// sRandom := false ;
18339: LD_ADDR_EXP 104
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// sShield := false ;
18347: LD_ADDR_EXP 105
18351: PUSH
18352: LD_INT 0
18354: ST_TO_ADDR
// sTime := false ;
18355: LD_ADDR_EXP 106
18359: PUSH
18360: LD_INT 0
18362: ST_TO_ADDR
// sTools := false ;
18363: LD_ADDR_EXP 107
18367: PUSH
18368: LD_INT 0
18370: ST_TO_ADDR
// sSold := false ;
18371: LD_ADDR_EXP 72
18375: PUSH
18376: LD_INT 0
18378: ST_TO_ADDR
// sDiff := false ;
18379: LD_ADDR_EXP 73
18383: PUSH
18384: LD_INT 0
18386: ST_TO_ADDR
// sFog := false ;
18387: LD_ADDR_EXP 76
18391: PUSH
18392: LD_INT 0
18394: ST_TO_ADDR
// sReset := false ;
18395: LD_ADDR_EXP 77
18399: PUSH
18400: LD_INT 0
18402: ST_TO_ADDR
// sSun := false ;
18403: LD_ADDR_EXP 78
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// sTiger := false ;
18411: LD_ADDR_EXP 74
18415: PUSH
18416: LD_INT 0
18418: ST_TO_ADDR
// sBomb := false ;
18419: LD_ADDR_EXP 75
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// sWound := false ;
18427: LD_ADDR_EXP 83
18431: PUSH
18432: LD_INT 0
18434: ST_TO_ADDR
// sBetray := false ;
18435: LD_ADDR_EXP 87
18439: PUSH
18440: LD_INT 0
18442: ST_TO_ADDR
// sContamin := false ;
18443: LD_ADDR_EXP 88
18447: PUSH
18448: LD_INT 0
18450: ST_TO_ADDR
// sOil := false ;
18451: LD_ADDR_EXP 90
18455: PUSH
18456: LD_INT 0
18458: ST_TO_ADDR
// sStu := false ;
18459: LD_ADDR_EXP 94
18463: PUSH
18464: LD_INT 0
18466: ST_TO_ADDR
// sBazooka := false ;
18467: LD_ADDR_EXP 97
18471: PUSH
18472: LD_INT 0
18474: ST_TO_ADDR
// sMortar := false ;
18475: LD_ADDR_EXP 98
18479: PUSH
18480: LD_INT 0
18482: ST_TO_ADDR
// sRanger := false ;
18483: LD_ADDR_EXP 108
18487: PUSH
18488: LD_INT 0
18490: ST_TO_ADDR
// end ;
18491: LD_VAR 0 1
18495: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
18496: LD_INT 0
18498: PPUSH
18499: PPUSH
18500: PPUSH
18501: PPUSH
18502: PPUSH
// result := [ ] ;
18503: LD_ADDR_VAR 0 1
18507: PUSH
18508: EMPTY
18509: ST_TO_ADDR
// if campaign_id = 1 then
18510: LD_OWVAR 69
18514: PUSH
18515: LD_INT 1
18517: EQUAL
18518: IFFALSE 21456
// begin case mission_number of 1 :
18520: LD_OWVAR 70
18524: PUSH
18525: LD_INT 1
18527: DOUBLE
18528: EQUAL
18529: IFTRUE 18533
18531: GO 18597
18533: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
18534: LD_ADDR_VAR 0 1
18538: PUSH
18539: LD_INT 2
18541: PUSH
18542: LD_INT 4
18544: PUSH
18545: LD_INT 11
18547: PUSH
18548: LD_INT 12
18550: PUSH
18551: LD_INT 15
18553: PUSH
18554: LD_INT 16
18556: PUSH
18557: LD_INT 22
18559: PUSH
18560: LD_INT 23
18562: PUSH
18563: LD_INT 26
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: LIST
18574: LIST
18575: LIST
18576: PUSH
18577: LD_INT 101
18579: PUSH
18580: LD_INT 102
18582: PUSH
18583: LD_INT 106
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: LIST
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: ST_TO_ADDR
18595: GO 21454
18597: LD_INT 2
18599: DOUBLE
18600: EQUAL
18601: IFTRUE 18605
18603: GO 18677
18605: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
18606: LD_ADDR_VAR 0 1
18610: PUSH
18611: LD_INT 2
18613: PUSH
18614: LD_INT 4
18616: PUSH
18617: LD_INT 11
18619: PUSH
18620: LD_INT 12
18622: PUSH
18623: LD_INT 15
18625: PUSH
18626: LD_INT 16
18628: PUSH
18629: LD_INT 22
18631: PUSH
18632: LD_INT 23
18634: PUSH
18635: LD_INT 26
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: LIST
18642: LIST
18643: LIST
18644: LIST
18645: LIST
18646: LIST
18647: LIST
18648: PUSH
18649: LD_INT 101
18651: PUSH
18652: LD_INT 102
18654: PUSH
18655: LD_INT 105
18657: PUSH
18658: LD_INT 106
18660: PUSH
18661: LD_INT 108
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: LIST
18668: LIST
18669: LIST
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: ST_TO_ADDR
18675: GO 21454
18677: LD_INT 3
18679: DOUBLE
18680: EQUAL
18681: IFTRUE 18685
18683: GO 18761
18685: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
18686: LD_ADDR_VAR 0 1
18690: PUSH
18691: LD_INT 2
18693: PUSH
18694: LD_INT 4
18696: PUSH
18697: LD_INT 5
18699: PUSH
18700: LD_INT 11
18702: PUSH
18703: LD_INT 12
18705: PUSH
18706: LD_INT 15
18708: PUSH
18709: LD_INT 16
18711: PUSH
18712: LD_INT 22
18714: PUSH
18715: LD_INT 26
18717: PUSH
18718: LD_INT 36
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: LD_INT 101
18735: PUSH
18736: LD_INT 102
18738: PUSH
18739: LD_INT 105
18741: PUSH
18742: LD_INT 106
18744: PUSH
18745: LD_INT 108
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: LIST
18752: LIST
18753: LIST
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: ST_TO_ADDR
18759: GO 21454
18761: LD_INT 4
18763: DOUBLE
18764: EQUAL
18765: IFTRUE 18769
18767: GO 18853
18769: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
18770: LD_ADDR_VAR 0 1
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: LD_INT 4
18780: PUSH
18781: LD_INT 5
18783: PUSH
18784: LD_INT 8
18786: PUSH
18787: LD_INT 11
18789: PUSH
18790: LD_INT 12
18792: PUSH
18793: LD_INT 15
18795: PUSH
18796: LD_INT 16
18798: PUSH
18799: LD_INT 22
18801: PUSH
18802: LD_INT 23
18804: PUSH
18805: LD_INT 26
18807: PUSH
18808: LD_INT 36
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: PUSH
18825: LD_INT 101
18827: PUSH
18828: LD_INT 102
18830: PUSH
18831: LD_INT 105
18833: PUSH
18834: LD_INT 106
18836: PUSH
18837: LD_INT 108
18839: PUSH
18840: EMPTY
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: PUSH
18847: EMPTY
18848: LIST
18849: LIST
18850: ST_TO_ADDR
18851: GO 21454
18853: LD_INT 5
18855: DOUBLE
18856: EQUAL
18857: IFTRUE 18861
18859: GO 18961
18861: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
18862: LD_ADDR_VAR 0 1
18866: PUSH
18867: LD_INT 2
18869: PUSH
18870: LD_INT 4
18872: PUSH
18873: LD_INT 5
18875: PUSH
18876: LD_INT 6
18878: PUSH
18879: LD_INT 8
18881: PUSH
18882: LD_INT 11
18884: PUSH
18885: LD_INT 12
18887: PUSH
18888: LD_INT 15
18890: PUSH
18891: LD_INT 16
18893: PUSH
18894: LD_INT 22
18896: PUSH
18897: LD_INT 23
18899: PUSH
18900: LD_INT 25
18902: PUSH
18903: LD_INT 26
18905: PUSH
18906: LD_INT 36
18908: PUSH
18909: EMPTY
18910: LIST
18911: LIST
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: LIST
18917: LIST
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: PUSH
18925: LD_INT 101
18927: PUSH
18928: LD_INT 102
18930: PUSH
18931: LD_INT 105
18933: PUSH
18934: LD_INT 106
18936: PUSH
18937: LD_INT 108
18939: PUSH
18940: LD_INT 109
18942: PUSH
18943: LD_INT 112
18945: PUSH
18946: EMPTY
18947: LIST
18948: LIST
18949: LIST
18950: LIST
18951: LIST
18952: LIST
18953: LIST
18954: PUSH
18955: EMPTY
18956: LIST
18957: LIST
18958: ST_TO_ADDR
18959: GO 21454
18961: LD_INT 6
18963: DOUBLE
18964: EQUAL
18965: IFTRUE 18969
18967: GO 19089
18969: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
18970: LD_ADDR_VAR 0 1
18974: PUSH
18975: LD_INT 2
18977: PUSH
18978: LD_INT 4
18980: PUSH
18981: LD_INT 5
18983: PUSH
18984: LD_INT 6
18986: PUSH
18987: LD_INT 8
18989: PUSH
18990: LD_INT 11
18992: PUSH
18993: LD_INT 12
18995: PUSH
18996: LD_INT 15
18998: PUSH
18999: LD_INT 16
19001: PUSH
19002: LD_INT 20
19004: PUSH
19005: LD_INT 21
19007: PUSH
19008: LD_INT 22
19010: PUSH
19011: LD_INT 23
19013: PUSH
19014: LD_INT 25
19016: PUSH
19017: LD_INT 26
19019: PUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 31
19025: PUSH
19026: LD_INT 32
19028: PUSH
19029: LD_INT 36
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: LIST
19042: LIST
19043: LIST
19044: LIST
19045: LIST
19046: LIST
19047: LIST
19048: LIST
19049: LIST
19050: LIST
19051: LIST
19052: PUSH
19053: LD_INT 101
19055: PUSH
19056: LD_INT 102
19058: PUSH
19059: LD_INT 105
19061: PUSH
19062: LD_INT 106
19064: PUSH
19065: LD_INT 108
19067: PUSH
19068: LD_INT 109
19070: PUSH
19071: LD_INT 112
19073: PUSH
19074: EMPTY
19075: LIST
19076: LIST
19077: LIST
19078: LIST
19079: LIST
19080: LIST
19081: LIST
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: ST_TO_ADDR
19087: GO 21454
19089: LD_INT 7
19091: DOUBLE
19092: EQUAL
19093: IFTRUE 19097
19095: GO 19197
19097: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19098: LD_ADDR_VAR 0 1
19102: PUSH
19103: LD_INT 2
19105: PUSH
19106: LD_INT 4
19108: PUSH
19109: LD_INT 5
19111: PUSH
19112: LD_INT 7
19114: PUSH
19115: LD_INT 11
19117: PUSH
19118: LD_INT 12
19120: PUSH
19121: LD_INT 15
19123: PUSH
19124: LD_INT 16
19126: PUSH
19127: LD_INT 20
19129: PUSH
19130: LD_INT 21
19132: PUSH
19133: LD_INT 22
19135: PUSH
19136: LD_INT 23
19138: PUSH
19139: LD_INT 25
19141: PUSH
19142: LD_INT 26
19144: PUSH
19145: EMPTY
19146: LIST
19147: LIST
19148: LIST
19149: LIST
19150: LIST
19151: LIST
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: PUSH
19161: LD_INT 101
19163: PUSH
19164: LD_INT 102
19166: PUSH
19167: LD_INT 103
19169: PUSH
19170: LD_INT 105
19172: PUSH
19173: LD_INT 106
19175: PUSH
19176: LD_INT 108
19178: PUSH
19179: LD_INT 112
19181: PUSH
19182: EMPTY
19183: LIST
19184: LIST
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: ST_TO_ADDR
19195: GO 21454
19197: LD_INT 8
19199: DOUBLE
19200: EQUAL
19201: IFTRUE 19205
19203: GO 19333
19205: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19206: LD_ADDR_VAR 0 1
19210: PUSH
19211: LD_INT 2
19213: PUSH
19214: LD_INT 4
19216: PUSH
19217: LD_INT 5
19219: PUSH
19220: LD_INT 6
19222: PUSH
19223: LD_INT 7
19225: PUSH
19226: LD_INT 8
19228: PUSH
19229: LD_INT 11
19231: PUSH
19232: LD_INT 12
19234: PUSH
19235: LD_INT 15
19237: PUSH
19238: LD_INT 16
19240: PUSH
19241: LD_INT 20
19243: PUSH
19244: LD_INT 21
19246: PUSH
19247: LD_INT 22
19249: PUSH
19250: LD_INT 23
19252: PUSH
19253: LD_INT 25
19255: PUSH
19256: LD_INT 26
19258: PUSH
19259: LD_INT 30
19261: PUSH
19262: LD_INT 31
19264: PUSH
19265: LD_INT 32
19267: PUSH
19268: LD_INT 36
19270: PUSH
19271: EMPTY
19272: LIST
19273: LIST
19274: LIST
19275: LIST
19276: LIST
19277: LIST
19278: LIST
19279: LIST
19280: LIST
19281: LIST
19282: LIST
19283: LIST
19284: LIST
19285: LIST
19286: LIST
19287: LIST
19288: LIST
19289: LIST
19290: LIST
19291: LIST
19292: PUSH
19293: LD_INT 101
19295: PUSH
19296: LD_INT 102
19298: PUSH
19299: LD_INT 103
19301: PUSH
19302: LD_INT 105
19304: PUSH
19305: LD_INT 106
19307: PUSH
19308: LD_INT 108
19310: PUSH
19311: LD_INT 109
19313: PUSH
19314: LD_INT 112
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: LIST
19321: LIST
19322: LIST
19323: LIST
19324: LIST
19325: LIST
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: ST_TO_ADDR
19331: GO 21454
19333: LD_INT 9
19335: DOUBLE
19336: EQUAL
19337: IFTRUE 19341
19339: GO 19477
19341: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19342: LD_ADDR_VAR 0 1
19346: PUSH
19347: LD_INT 2
19349: PUSH
19350: LD_INT 4
19352: PUSH
19353: LD_INT 5
19355: PUSH
19356: LD_INT 6
19358: PUSH
19359: LD_INT 7
19361: PUSH
19362: LD_INT 8
19364: PUSH
19365: LD_INT 11
19367: PUSH
19368: LD_INT 12
19370: PUSH
19371: LD_INT 15
19373: PUSH
19374: LD_INT 16
19376: PUSH
19377: LD_INT 20
19379: PUSH
19380: LD_INT 21
19382: PUSH
19383: LD_INT 22
19385: PUSH
19386: LD_INT 23
19388: PUSH
19389: LD_INT 25
19391: PUSH
19392: LD_INT 26
19394: PUSH
19395: LD_INT 28
19397: PUSH
19398: LD_INT 30
19400: PUSH
19401: LD_INT 31
19403: PUSH
19404: LD_INT 32
19406: PUSH
19407: LD_INT 36
19409: PUSH
19410: EMPTY
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: PUSH
19433: LD_INT 101
19435: PUSH
19436: LD_INT 102
19438: PUSH
19439: LD_INT 103
19441: PUSH
19442: LD_INT 105
19444: PUSH
19445: LD_INT 106
19447: PUSH
19448: LD_INT 108
19450: PUSH
19451: LD_INT 109
19453: PUSH
19454: LD_INT 112
19456: PUSH
19457: LD_INT 114
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: LIST
19464: LIST
19465: LIST
19466: LIST
19467: LIST
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: ST_TO_ADDR
19475: GO 21454
19477: LD_INT 10
19479: DOUBLE
19480: EQUAL
19481: IFTRUE 19485
19483: GO 19669
19485: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
19486: LD_ADDR_VAR 0 1
19490: PUSH
19491: LD_INT 2
19493: PUSH
19494: LD_INT 4
19496: PUSH
19497: LD_INT 5
19499: PUSH
19500: LD_INT 6
19502: PUSH
19503: LD_INT 7
19505: PUSH
19506: LD_INT 8
19508: PUSH
19509: LD_INT 9
19511: PUSH
19512: LD_INT 10
19514: PUSH
19515: LD_INT 11
19517: PUSH
19518: LD_INT 12
19520: PUSH
19521: LD_INT 13
19523: PUSH
19524: LD_INT 14
19526: PUSH
19527: LD_INT 15
19529: PUSH
19530: LD_INT 16
19532: PUSH
19533: LD_INT 17
19535: PUSH
19536: LD_INT 18
19538: PUSH
19539: LD_INT 19
19541: PUSH
19542: LD_INT 20
19544: PUSH
19545: LD_INT 21
19547: PUSH
19548: LD_INT 22
19550: PUSH
19551: LD_INT 23
19553: PUSH
19554: LD_INT 24
19556: PUSH
19557: LD_INT 25
19559: PUSH
19560: LD_INT 26
19562: PUSH
19563: LD_INT 28
19565: PUSH
19566: LD_INT 30
19568: PUSH
19569: LD_INT 31
19571: PUSH
19572: LD_INT 32
19574: PUSH
19575: LD_INT 36
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: LIST
19587: LIST
19588: LIST
19589: LIST
19590: LIST
19591: LIST
19592: LIST
19593: LIST
19594: LIST
19595: LIST
19596: LIST
19597: LIST
19598: LIST
19599: LIST
19600: LIST
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: PUSH
19609: LD_INT 101
19611: PUSH
19612: LD_INT 102
19614: PUSH
19615: LD_INT 103
19617: PUSH
19618: LD_INT 104
19620: PUSH
19621: LD_INT 105
19623: PUSH
19624: LD_INT 106
19626: PUSH
19627: LD_INT 107
19629: PUSH
19630: LD_INT 108
19632: PUSH
19633: LD_INT 109
19635: PUSH
19636: LD_INT 110
19638: PUSH
19639: LD_INT 111
19641: PUSH
19642: LD_INT 112
19644: PUSH
19645: LD_INT 114
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: LIST
19660: LIST
19661: LIST
19662: PUSH
19663: EMPTY
19664: LIST
19665: LIST
19666: ST_TO_ADDR
19667: GO 21454
19669: LD_INT 11
19671: DOUBLE
19672: EQUAL
19673: IFTRUE 19677
19675: GO 19869
19677: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
19678: LD_ADDR_VAR 0 1
19682: PUSH
19683: LD_INT 2
19685: PUSH
19686: LD_INT 3
19688: PUSH
19689: LD_INT 4
19691: PUSH
19692: LD_INT 5
19694: PUSH
19695: LD_INT 6
19697: PUSH
19698: LD_INT 7
19700: PUSH
19701: LD_INT 8
19703: PUSH
19704: LD_INT 9
19706: PUSH
19707: LD_INT 10
19709: PUSH
19710: LD_INT 11
19712: PUSH
19713: LD_INT 12
19715: PUSH
19716: LD_INT 13
19718: PUSH
19719: LD_INT 14
19721: PUSH
19722: LD_INT 15
19724: PUSH
19725: LD_INT 16
19727: PUSH
19728: LD_INT 17
19730: PUSH
19731: LD_INT 18
19733: PUSH
19734: LD_INT 19
19736: PUSH
19737: LD_INT 20
19739: PUSH
19740: LD_INT 21
19742: PUSH
19743: LD_INT 22
19745: PUSH
19746: LD_INT 23
19748: PUSH
19749: LD_INT 24
19751: PUSH
19752: LD_INT 25
19754: PUSH
19755: LD_INT 26
19757: PUSH
19758: LD_INT 28
19760: PUSH
19761: LD_INT 30
19763: PUSH
19764: LD_INT 31
19766: PUSH
19767: LD_INT 32
19769: PUSH
19770: LD_INT 34
19772: PUSH
19773: LD_INT 36
19775: PUSH
19776: EMPTY
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 101
19811: PUSH
19812: LD_INT 102
19814: PUSH
19815: LD_INT 103
19817: PUSH
19818: LD_INT 104
19820: PUSH
19821: LD_INT 105
19823: PUSH
19824: LD_INT 106
19826: PUSH
19827: LD_INT 107
19829: PUSH
19830: LD_INT 108
19832: PUSH
19833: LD_INT 109
19835: PUSH
19836: LD_INT 110
19838: PUSH
19839: LD_INT 111
19841: PUSH
19842: LD_INT 112
19844: PUSH
19845: LD_INT 114
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: ST_TO_ADDR
19867: GO 21454
19869: LD_INT 12
19871: DOUBLE
19872: EQUAL
19873: IFTRUE 19877
19875: GO 20085
19877: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
19878: LD_ADDR_VAR 0 1
19882: PUSH
19883: LD_INT 1
19885: PUSH
19886: LD_INT 2
19888: PUSH
19889: LD_INT 3
19891: PUSH
19892: LD_INT 4
19894: PUSH
19895: LD_INT 5
19897: PUSH
19898: LD_INT 6
19900: PUSH
19901: LD_INT 7
19903: PUSH
19904: LD_INT 8
19906: PUSH
19907: LD_INT 9
19909: PUSH
19910: LD_INT 10
19912: PUSH
19913: LD_INT 11
19915: PUSH
19916: LD_INT 12
19918: PUSH
19919: LD_INT 13
19921: PUSH
19922: LD_INT 14
19924: PUSH
19925: LD_INT 15
19927: PUSH
19928: LD_INT 16
19930: PUSH
19931: LD_INT 17
19933: PUSH
19934: LD_INT 18
19936: PUSH
19937: LD_INT 19
19939: PUSH
19940: LD_INT 20
19942: PUSH
19943: LD_INT 21
19945: PUSH
19946: LD_INT 22
19948: PUSH
19949: LD_INT 23
19951: PUSH
19952: LD_INT 24
19954: PUSH
19955: LD_INT 25
19957: PUSH
19958: LD_INT 26
19960: PUSH
19961: LD_INT 27
19963: PUSH
19964: LD_INT 28
19966: PUSH
19967: LD_INT 30
19969: PUSH
19970: LD_INT 31
19972: PUSH
19973: LD_INT 32
19975: PUSH
19976: LD_INT 33
19978: PUSH
19979: LD_INT 34
19981: PUSH
19982: LD_INT 36
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: LIST
20017: LIST
20018: LIST
20019: LIST
20020: PUSH
20021: LD_INT 101
20023: PUSH
20024: LD_INT 102
20026: PUSH
20027: LD_INT 103
20029: PUSH
20030: LD_INT 104
20032: PUSH
20033: LD_INT 105
20035: PUSH
20036: LD_INT 106
20038: PUSH
20039: LD_INT 107
20041: PUSH
20042: LD_INT 108
20044: PUSH
20045: LD_INT 109
20047: PUSH
20048: LD_INT 110
20050: PUSH
20051: LD_INT 111
20053: PUSH
20054: LD_INT 112
20056: PUSH
20057: LD_INT 113
20059: PUSH
20060: LD_INT 114
20062: PUSH
20063: EMPTY
20064: LIST
20065: LIST
20066: LIST
20067: LIST
20068: LIST
20069: LIST
20070: LIST
20071: LIST
20072: LIST
20073: LIST
20074: LIST
20075: LIST
20076: LIST
20077: LIST
20078: PUSH
20079: EMPTY
20080: LIST
20081: LIST
20082: ST_TO_ADDR
20083: GO 21454
20085: LD_INT 13
20087: DOUBLE
20088: EQUAL
20089: IFTRUE 20093
20091: GO 20289
20093: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20094: LD_ADDR_VAR 0 1
20098: PUSH
20099: LD_INT 1
20101: PUSH
20102: LD_INT 2
20104: PUSH
20105: LD_INT 3
20107: PUSH
20108: LD_INT 4
20110: PUSH
20111: LD_INT 5
20113: PUSH
20114: LD_INT 8
20116: PUSH
20117: LD_INT 9
20119: PUSH
20120: LD_INT 10
20122: PUSH
20123: LD_INT 11
20125: PUSH
20126: LD_INT 12
20128: PUSH
20129: LD_INT 14
20131: PUSH
20132: LD_INT 15
20134: PUSH
20135: LD_INT 16
20137: PUSH
20138: LD_INT 17
20140: PUSH
20141: LD_INT 18
20143: PUSH
20144: LD_INT 19
20146: PUSH
20147: LD_INT 20
20149: PUSH
20150: LD_INT 21
20152: PUSH
20153: LD_INT 22
20155: PUSH
20156: LD_INT 23
20158: PUSH
20159: LD_INT 24
20161: PUSH
20162: LD_INT 25
20164: PUSH
20165: LD_INT 26
20167: PUSH
20168: LD_INT 27
20170: PUSH
20171: LD_INT 28
20173: PUSH
20174: LD_INT 30
20176: PUSH
20177: LD_INT 31
20179: PUSH
20180: LD_INT 32
20182: PUSH
20183: LD_INT 33
20185: PUSH
20186: LD_INT 34
20188: PUSH
20189: LD_INT 36
20191: PUSH
20192: EMPTY
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: LIST
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 101
20227: PUSH
20228: LD_INT 102
20230: PUSH
20231: LD_INT 103
20233: PUSH
20234: LD_INT 104
20236: PUSH
20237: LD_INT 105
20239: PUSH
20240: LD_INT 106
20242: PUSH
20243: LD_INT 107
20245: PUSH
20246: LD_INT 108
20248: PUSH
20249: LD_INT 109
20251: PUSH
20252: LD_INT 110
20254: PUSH
20255: LD_INT 111
20257: PUSH
20258: LD_INT 112
20260: PUSH
20261: LD_INT 113
20263: PUSH
20264: LD_INT 114
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: ST_TO_ADDR
20287: GO 21454
20289: LD_INT 14
20291: DOUBLE
20292: EQUAL
20293: IFTRUE 20297
20295: GO 20509
20297: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20298: LD_ADDR_VAR 0 1
20302: PUSH
20303: LD_INT 1
20305: PUSH
20306: LD_INT 2
20308: PUSH
20309: LD_INT 3
20311: PUSH
20312: LD_INT 4
20314: PUSH
20315: LD_INT 5
20317: PUSH
20318: LD_INT 6
20320: PUSH
20321: LD_INT 7
20323: PUSH
20324: LD_INT 8
20326: PUSH
20327: LD_INT 9
20329: PUSH
20330: LD_INT 10
20332: PUSH
20333: LD_INT 11
20335: PUSH
20336: LD_INT 12
20338: PUSH
20339: LD_INT 13
20341: PUSH
20342: LD_INT 14
20344: PUSH
20345: LD_INT 15
20347: PUSH
20348: LD_INT 16
20350: PUSH
20351: LD_INT 17
20353: PUSH
20354: LD_INT 18
20356: PUSH
20357: LD_INT 19
20359: PUSH
20360: LD_INT 20
20362: PUSH
20363: LD_INT 21
20365: PUSH
20366: LD_INT 22
20368: PUSH
20369: LD_INT 23
20371: PUSH
20372: LD_INT 24
20374: PUSH
20375: LD_INT 25
20377: PUSH
20378: LD_INT 26
20380: PUSH
20381: LD_INT 27
20383: PUSH
20384: LD_INT 28
20386: PUSH
20387: LD_INT 29
20389: PUSH
20390: LD_INT 30
20392: PUSH
20393: LD_INT 31
20395: PUSH
20396: LD_INT 32
20398: PUSH
20399: LD_INT 33
20401: PUSH
20402: LD_INT 34
20404: PUSH
20405: LD_INT 36
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: PUSH
20445: LD_INT 101
20447: PUSH
20448: LD_INT 102
20450: PUSH
20451: LD_INT 103
20453: PUSH
20454: LD_INT 104
20456: PUSH
20457: LD_INT 105
20459: PUSH
20460: LD_INT 106
20462: PUSH
20463: LD_INT 107
20465: PUSH
20466: LD_INT 108
20468: PUSH
20469: LD_INT 109
20471: PUSH
20472: LD_INT 110
20474: PUSH
20475: LD_INT 111
20477: PUSH
20478: LD_INT 112
20480: PUSH
20481: LD_INT 113
20483: PUSH
20484: LD_INT 114
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: LIST
20491: LIST
20492: LIST
20493: LIST
20494: LIST
20495: LIST
20496: LIST
20497: LIST
20498: LIST
20499: LIST
20500: LIST
20501: LIST
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: ST_TO_ADDR
20507: GO 21454
20509: LD_INT 15
20511: DOUBLE
20512: EQUAL
20513: IFTRUE 20517
20515: GO 20729
20517: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
20518: LD_ADDR_VAR 0 1
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: LD_INT 2
20528: PUSH
20529: LD_INT 3
20531: PUSH
20532: LD_INT 4
20534: PUSH
20535: LD_INT 5
20537: PUSH
20538: LD_INT 6
20540: PUSH
20541: LD_INT 7
20543: PUSH
20544: LD_INT 8
20546: PUSH
20547: LD_INT 9
20549: PUSH
20550: LD_INT 10
20552: PUSH
20553: LD_INT 11
20555: PUSH
20556: LD_INT 12
20558: PUSH
20559: LD_INT 13
20561: PUSH
20562: LD_INT 14
20564: PUSH
20565: LD_INT 15
20567: PUSH
20568: LD_INT 16
20570: PUSH
20571: LD_INT 17
20573: PUSH
20574: LD_INT 18
20576: PUSH
20577: LD_INT 19
20579: PUSH
20580: LD_INT 20
20582: PUSH
20583: LD_INT 21
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 23
20591: PUSH
20592: LD_INT 24
20594: PUSH
20595: LD_INT 25
20597: PUSH
20598: LD_INT 26
20600: PUSH
20601: LD_INT 27
20603: PUSH
20604: LD_INT 28
20606: PUSH
20607: LD_INT 29
20609: PUSH
20610: LD_INT 30
20612: PUSH
20613: LD_INT 31
20615: PUSH
20616: LD_INT 32
20618: PUSH
20619: LD_INT 33
20621: PUSH
20622: LD_INT 34
20624: PUSH
20625: LD_INT 36
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: PUSH
20665: LD_INT 101
20667: PUSH
20668: LD_INT 102
20670: PUSH
20671: LD_INT 103
20673: PUSH
20674: LD_INT 104
20676: PUSH
20677: LD_INT 105
20679: PUSH
20680: LD_INT 106
20682: PUSH
20683: LD_INT 107
20685: PUSH
20686: LD_INT 108
20688: PUSH
20689: LD_INT 109
20691: PUSH
20692: LD_INT 110
20694: PUSH
20695: LD_INT 111
20697: PUSH
20698: LD_INT 112
20700: PUSH
20701: LD_INT 113
20703: PUSH
20704: LD_INT 114
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: LIST
20711: LIST
20712: LIST
20713: LIST
20714: LIST
20715: LIST
20716: LIST
20717: LIST
20718: LIST
20719: LIST
20720: LIST
20721: LIST
20722: PUSH
20723: EMPTY
20724: LIST
20725: LIST
20726: ST_TO_ADDR
20727: GO 21454
20729: LD_INT 16
20731: DOUBLE
20732: EQUAL
20733: IFTRUE 20737
20735: GO 20861
20737: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
20738: LD_ADDR_VAR 0 1
20742: PUSH
20743: LD_INT 2
20745: PUSH
20746: LD_INT 4
20748: PUSH
20749: LD_INT 5
20751: PUSH
20752: LD_INT 7
20754: PUSH
20755: LD_INT 11
20757: PUSH
20758: LD_INT 12
20760: PUSH
20761: LD_INT 15
20763: PUSH
20764: LD_INT 16
20766: PUSH
20767: LD_INT 20
20769: PUSH
20770: LD_INT 21
20772: PUSH
20773: LD_INT 22
20775: PUSH
20776: LD_INT 23
20778: PUSH
20779: LD_INT 25
20781: PUSH
20782: LD_INT 26
20784: PUSH
20785: LD_INT 30
20787: PUSH
20788: LD_INT 31
20790: PUSH
20791: LD_INT 32
20793: PUSH
20794: LD_INT 33
20796: PUSH
20797: LD_INT 34
20799: PUSH
20800: EMPTY
20801: LIST
20802: LIST
20803: LIST
20804: LIST
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: PUSH
20821: LD_INT 101
20823: PUSH
20824: LD_INT 102
20826: PUSH
20827: LD_INT 103
20829: PUSH
20830: LD_INT 106
20832: PUSH
20833: LD_INT 108
20835: PUSH
20836: LD_INT 112
20838: PUSH
20839: LD_INT 113
20841: PUSH
20842: LD_INT 114
20844: PUSH
20845: EMPTY
20846: LIST
20847: LIST
20848: LIST
20849: LIST
20850: LIST
20851: LIST
20852: LIST
20853: LIST
20854: PUSH
20855: EMPTY
20856: LIST
20857: LIST
20858: ST_TO_ADDR
20859: GO 21454
20861: LD_INT 17
20863: DOUBLE
20864: EQUAL
20865: IFTRUE 20869
20867: GO 21081
20869: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
20870: LD_ADDR_VAR 0 1
20874: PUSH
20875: LD_INT 1
20877: PUSH
20878: LD_INT 2
20880: PUSH
20881: LD_INT 3
20883: PUSH
20884: LD_INT 4
20886: PUSH
20887: LD_INT 5
20889: PUSH
20890: LD_INT 6
20892: PUSH
20893: LD_INT 7
20895: PUSH
20896: LD_INT 8
20898: PUSH
20899: LD_INT 9
20901: PUSH
20902: LD_INT 10
20904: PUSH
20905: LD_INT 11
20907: PUSH
20908: LD_INT 12
20910: PUSH
20911: LD_INT 13
20913: PUSH
20914: LD_INT 14
20916: PUSH
20917: LD_INT 15
20919: PUSH
20920: LD_INT 16
20922: PUSH
20923: LD_INT 17
20925: PUSH
20926: LD_INT 18
20928: PUSH
20929: LD_INT 19
20931: PUSH
20932: LD_INT 20
20934: PUSH
20935: LD_INT 21
20937: PUSH
20938: LD_INT 22
20940: PUSH
20941: LD_INT 23
20943: PUSH
20944: LD_INT 24
20946: PUSH
20947: LD_INT 25
20949: PUSH
20950: LD_INT 26
20952: PUSH
20953: LD_INT 27
20955: PUSH
20956: LD_INT 28
20958: PUSH
20959: LD_INT 29
20961: PUSH
20962: LD_INT 30
20964: PUSH
20965: LD_INT 31
20967: PUSH
20968: LD_INT 32
20970: PUSH
20971: LD_INT 33
20973: PUSH
20974: LD_INT 34
20976: PUSH
20977: LD_INT 36
20979: PUSH
20980: EMPTY
20981: LIST
20982: LIST
20983: LIST
20984: LIST
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: LIST
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: LIST
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: LIST
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: LIST
21015: LIST
21016: PUSH
21017: LD_INT 101
21019: PUSH
21020: LD_INT 102
21022: PUSH
21023: LD_INT 103
21025: PUSH
21026: LD_INT 104
21028: PUSH
21029: LD_INT 105
21031: PUSH
21032: LD_INT 106
21034: PUSH
21035: LD_INT 107
21037: PUSH
21038: LD_INT 108
21040: PUSH
21041: LD_INT 109
21043: PUSH
21044: LD_INT 110
21046: PUSH
21047: LD_INT 111
21049: PUSH
21050: LD_INT 112
21052: PUSH
21053: LD_INT 113
21055: PUSH
21056: LD_INT 114
21058: PUSH
21059: EMPTY
21060: LIST
21061: LIST
21062: LIST
21063: LIST
21064: LIST
21065: LIST
21066: LIST
21067: LIST
21068: LIST
21069: LIST
21070: LIST
21071: LIST
21072: LIST
21073: LIST
21074: PUSH
21075: EMPTY
21076: LIST
21077: LIST
21078: ST_TO_ADDR
21079: GO 21454
21081: LD_INT 18
21083: DOUBLE
21084: EQUAL
21085: IFTRUE 21089
21087: GO 21225
21089: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21090: LD_ADDR_VAR 0 1
21094: PUSH
21095: LD_INT 2
21097: PUSH
21098: LD_INT 4
21100: PUSH
21101: LD_INT 5
21103: PUSH
21104: LD_INT 7
21106: PUSH
21107: LD_INT 11
21109: PUSH
21110: LD_INT 12
21112: PUSH
21113: LD_INT 15
21115: PUSH
21116: LD_INT 16
21118: PUSH
21119: LD_INT 20
21121: PUSH
21122: LD_INT 21
21124: PUSH
21125: LD_INT 22
21127: PUSH
21128: LD_INT 23
21130: PUSH
21131: LD_INT 25
21133: PUSH
21134: LD_INT 26
21136: PUSH
21137: LD_INT 30
21139: PUSH
21140: LD_INT 31
21142: PUSH
21143: LD_INT 32
21145: PUSH
21146: LD_INT 33
21148: PUSH
21149: LD_INT 34
21151: PUSH
21152: LD_INT 35
21154: PUSH
21155: LD_INT 36
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: LIST
21173: LIST
21174: LIST
21175: LIST
21176: LIST
21177: LIST
21178: LIST
21179: LIST
21180: PUSH
21181: LD_INT 101
21183: PUSH
21184: LD_INT 102
21186: PUSH
21187: LD_INT 103
21189: PUSH
21190: LD_INT 106
21192: PUSH
21193: LD_INT 108
21195: PUSH
21196: LD_INT 112
21198: PUSH
21199: LD_INT 113
21201: PUSH
21202: LD_INT 114
21204: PUSH
21205: LD_INT 115
21207: PUSH
21208: EMPTY
21209: LIST
21210: LIST
21211: LIST
21212: LIST
21213: LIST
21214: LIST
21215: LIST
21216: LIST
21217: LIST
21218: PUSH
21219: EMPTY
21220: LIST
21221: LIST
21222: ST_TO_ADDR
21223: GO 21454
21225: LD_INT 19
21227: DOUBLE
21228: EQUAL
21229: IFTRUE 21233
21231: GO 21453
21233: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21234: LD_ADDR_VAR 0 1
21238: PUSH
21239: LD_INT 1
21241: PUSH
21242: LD_INT 2
21244: PUSH
21245: LD_INT 3
21247: PUSH
21248: LD_INT 4
21250: PUSH
21251: LD_INT 5
21253: PUSH
21254: LD_INT 6
21256: PUSH
21257: LD_INT 7
21259: PUSH
21260: LD_INT 8
21262: PUSH
21263: LD_INT 9
21265: PUSH
21266: LD_INT 10
21268: PUSH
21269: LD_INT 11
21271: PUSH
21272: LD_INT 12
21274: PUSH
21275: LD_INT 13
21277: PUSH
21278: LD_INT 14
21280: PUSH
21281: LD_INT 15
21283: PUSH
21284: LD_INT 16
21286: PUSH
21287: LD_INT 17
21289: PUSH
21290: LD_INT 18
21292: PUSH
21293: LD_INT 19
21295: PUSH
21296: LD_INT 20
21298: PUSH
21299: LD_INT 21
21301: PUSH
21302: LD_INT 22
21304: PUSH
21305: LD_INT 23
21307: PUSH
21308: LD_INT 24
21310: PUSH
21311: LD_INT 25
21313: PUSH
21314: LD_INT 26
21316: PUSH
21317: LD_INT 27
21319: PUSH
21320: LD_INT 28
21322: PUSH
21323: LD_INT 29
21325: PUSH
21326: LD_INT 30
21328: PUSH
21329: LD_INT 31
21331: PUSH
21332: LD_INT 32
21334: PUSH
21335: LD_INT 33
21337: PUSH
21338: LD_INT 34
21340: PUSH
21341: LD_INT 35
21343: PUSH
21344: LD_INT 36
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: LIST
21351: LIST
21352: LIST
21353: LIST
21354: LIST
21355: LIST
21356: LIST
21357: LIST
21358: LIST
21359: LIST
21360: LIST
21361: LIST
21362: LIST
21363: LIST
21364: LIST
21365: LIST
21366: LIST
21367: LIST
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: LIST
21384: PUSH
21385: LD_INT 101
21387: PUSH
21388: LD_INT 102
21390: PUSH
21391: LD_INT 103
21393: PUSH
21394: LD_INT 104
21396: PUSH
21397: LD_INT 105
21399: PUSH
21400: LD_INT 106
21402: PUSH
21403: LD_INT 107
21405: PUSH
21406: LD_INT 108
21408: PUSH
21409: LD_INT 109
21411: PUSH
21412: LD_INT 110
21414: PUSH
21415: LD_INT 111
21417: PUSH
21418: LD_INT 112
21420: PUSH
21421: LD_INT 113
21423: PUSH
21424: LD_INT 114
21426: PUSH
21427: LD_INT 115
21429: PUSH
21430: EMPTY
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: ST_TO_ADDR
21451: GO 21454
21453: POP
// end else
21454: GO 21673
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
21456: LD_ADDR_VAR 0 1
21460: PUSH
21461: LD_INT 1
21463: PUSH
21464: LD_INT 2
21466: PUSH
21467: LD_INT 3
21469: PUSH
21470: LD_INT 4
21472: PUSH
21473: LD_INT 5
21475: PUSH
21476: LD_INT 6
21478: PUSH
21479: LD_INT 7
21481: PUSH
21482: LD_INT 8
21484: PUSH
21485: LD_INT 9
21487: PUSH
21488: LD_INT 10
21490: PUSH
21491: LD_INT 11
21493: PUSH
21494: LD_INT 12
21496: PUSH
21497: LD_INT 13
21499: PUSH
21500: LD_INT 14
21502: PUSH
21503: LD_INT 15
21505: PUSH
21506: LD_INT 16
21508: PUSH
21509: LD_INT 17
21511: PUSH
21512: LD_INT 18
21514: PUSH
21515: LD_INT 19
21517: PUSH
21518: LD_INT 20
21520: PUSH
21521: LD_INT 21
21523: PUSH
21524: LD_INT 22
21526: PUSH
21527: LD_INT 23
21529: PUSH
21530: LD_INT 24
21532: PUSH
21533: LD_INT 25
21535: PUSH
21536: LD_INT 26
21538: PUSH
21539: LD_INT 27
21541: PUSH
21542: LD_INT 28
21544: PUSH
21545: LD_INT 29
21547: PUSH
21548: LD_INT 30
21550: PUSH
21551: LD_INT 31
21553: PUSH
21554: LD_INT 32
21556: PUSH
21557: LD_INT 33
21559: PUSH
21560: LD_INT 34
21562: PUSH
21563: LD_INT 35
21565: PUSH
21566: LD_INT 36
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: LIST
21573: LIST
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: LIST
21599: LIST
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: PUSH
21607: LD_INT 101
21609: PUSH
21610: LD_INT 102
21612: PUSH
21613: LD_INT 103
21615: PUSH
21616: LD_INT 104
21618: PUSH
21619: LD_INT 105
21621: PUSH
21622: LD_INT 106
21624: PUSH
21625: LD_INT 107
21627: PUSH
21628: LD_INT 108
21630: PUSH
21631: LD_INT 109
21633: PUSH
21634: LD_INT 110
21636: PUSH
21637: LD_INT 111
21639: PUSH
21640: LD_INT 112
21642: PUSH
21643: LD_INT 113
21645: PUSH
21646: LD_INT 114
21648: PUSH
21649: LD_INT 115
21651: PUSH
21652: EMPTY
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: LIST
21668: PUSH
21669: EMPTY
21670: LIST
21671: LIST
21672: ST_TO_ADDR
// if result then
21673: LD_VAR 0 1
21677: IFFALSE 21966
// begin normal :=  ;
21679: LD_ADDR_VAR 0 3
21683: PUSH
21684: LD_STRING 
21686: ST_TO_ADDR
// hardcore :=  ;
21687: LD_ADDR_VAR 0 4
21691: PUSH
21692: LD_STRING 
21694: ST_TO_ADDR
// for i = 1 to normalCounter do
21695: LD_ADDR_VAR 0 5
21699: PUSH
21700: DOUBLE
21701: LD_INT 1
21703: DEC
21704: ST_TO_ADDR
21705: LD_EXP 56
21709: PUSH
21710: FOR_TO
21711: IFFALSE 21812
// begin tmp := 0 ;
21713: LD_ADDR_VAR 0 2
21717: PUSH
21718: LD_STRING 0
21720: ST_TO_ADDR
// if result [ 1 ] then
21721: LD_VAR 0 1
21725: PUSH
21726: LD_INT 1
21728: ARRAY
21729: IFFALSE 21794
// if result [ 1 ] [ 1 ] = i then
21731: LD_VAR 0 1
21735: PUSH
21736: LD_INT 1
21738: ARRAY
21739: PUSH
21740: LD_INT 1
21742: ARRAY
21743: PUSH
21744: LD_VAR 0 5
21748: EQUAL
21749: IFFALSE 21794
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
21751: LD_ADDR_VAR 0 1
21755: PUSH
21756: LD_VAR 0 1
21760: PPUSH
21761: LD_INT 1
21763: PPUSH
21764: LD_VAR 0 1
21768: PUSH
21769: LD_INT 1
21771: ARRAY
21772: PPUSH
21773: LD_INT 1
21775: PPUSH
21776: CALL_OW 3
21780: PPUSH
21781: CALL_OW 1
21785: ST_TO_ADDR
// tmp := 1 ;
21786: LD_ADDR_VAR 0 2
21790: PUSH
21791: LD_STRING 1
21793: ST_TO_ADDR
// end ; normal := normal & tmp ;
21794: LD_ADDR_VAR 0 3
21798: PUSH
21799: LD_VAR 0 3
21803: PUSH
21804: LD_VAR 0 2
21808: STR
21809: ST_TO_ADDR
// end ;
21810: GO 21710
21812: POP
21813: POP
// for i = 1 to hardcoreCounter do
21814: LD_ADDR_VAR 0 5
21818: PUSH
21819: DOUBLE
21820: LD_INT 1
21822: DEC
21823: ST_TO_ADDR
21824: LD_EXP 57
21828: PUSH
21829: FOR_TO
21830: IFFALSE 21935
// begin tmp := 0 ;
21832: LD_ADDR_VAR 0 2
21836: PUSH
21837: LD_STRING 0
21839: ST_TO_ADDR
// if result [ 2 ] then
21840: LD_VAR 0 1
21844: PUSH
21845: LD_INT 2
21847: ARRAY
21848: IFFALSE 21917
// if result [ 2 ] [ 1 ] = 100 + i then
21850: LD_VAR 0 1
21854: PUSH
21855: LD_INT 2
21857: ARRAY
21858: PUSH
21859: LD_INT 1
21861: ARRAY
21862: PUSH
21863: LD_INT 100
21865: PUSH
21866: LD_VAR 0 5
21870: PLUS
21871: EQUAL
21872: IFFALSE 21917
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
21874: LD_ADDR_VAR 0 1
21878: PUSH
21879: LD_VAR 0 1
21883: PPUSH
21884: LD_INT 2
21886: PPUSH
21887: LD_VAR 0 1
21891: PUSH
21892: LD_INT 2
21894: ARRAY
21895: PPUSH
21896: LD_INT 1
21898: PPUSH
21899: CALL_OW 3
21903: PPUSH
21904: CALL_OW 1
21908: ST_TO_ADDR
// tmp := 1 ;
21909: LD_ADDR_VAR 0 2
21913: PUSH
21914: LD_STRING 1
21916: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
21917: LD_ADDR_VAR 0 4
21921: PUSH
21922: LD_VAR 0 4
21926: PUSH
21927: LD_VAR 0 2
21931: STR
21932: ST_TO_ADDR
// end ;
21933: GO 21829
21935: POP
21936: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
21937: LD_STRING getStreamItemsFromMission("
21939: PUSH
21940: LD_VAR 0 3
21944: STR
21945: PUSH
21946: LD_STRING ","
21948: STR
21949: PUSH
21950: LD_VAR 0 4
21954: STR
21955: PUSH
21956: LD_STRING ")
21958: STR
21959: PPUSH
21960: CALL_OW 559
// end else
21964: GO 21973
// ToLua ( getStreamItemsFromMission("","") ) ;
21966: LD_STRING getStreamItemsFromMission("","")
21968: PPUSH
21969: CALL_OW 559
// end ;
21973: LD_VAR 0 1
21977: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
21978: LD_VAR 0 2
21982: PUSH
21983: LD_INT 100
21985: EQUAL
21986: IFFALSE 22935
// begin if not StreamModeActive then
21988: LD_EXP 55
21992: NOT
21993: IFFALSE 22003
// StreamModeActive := true ;
21995: LD_ADDR_EXP 55
21999: PUSH
22000: LD_INT 1
22002: ST_TO_ADDR
// if p3 = 0 then
22003: LD_VAR 0 3
22007: PUSH
22008: LD_INT 0
22010: EQUAL
22011: IFFALSE 22017
// InitStreamMode ;
22013: CALL 18056 0 0
// if p3 = 1 then
22017: LD_VAR 0 3
22021: PUSH
22022: LD_INT 1
22024: EQUAL
22025: IFFALSE 22035
// sRocket := true ;
22027: LD_ADDR_EXP 60
22031: PUSH
22032: LD_INT 1
22034: ST_TO_ADDR
// if p3 = 2 then
22035: LD_VAR 0 3
22039: PUSH
22040: LD_INT 2
22042: EQUAL
22043: IFFALSE 22053
// sSpeed := true ;
22045: LD_ADDR_EXP 59
22049: PUSH
22050: LD_INT 1
22052: ST_TO_ADDR
// if p3 = 3 then
22053: LD_VAR 0 3
22057: PUSH
22058: LD_INT 3
22060: EQUAL
22061: IFFALSE 22071
// sEngine := true ;
22063: LD_ADDR_EXP 61
22067: PUSH
22068: LD_INT 1
22070: ST_TO_ADDR
// if p3 = 4 then
22071: LD_VAR 0 3
22075: PUSH
22076: LD_INT 4
22078: EQUAL
22079: IFFALSE 22089
// sSpec := true ;
22081: LD_ADDR_EXP 58
22085: PUSH
22086: LD_INT 1
22088: ST_TO_ADDR
// if p3 = 5 then
22089: LD_VAR 0 3
22093: PUSH
22094: LD_INT 5
22096: EQUAL
22097: IFFALSE 22107
// sLevel := true ;
22099: LD_ADDR_EXP 62
22103: PUSH
22104: LD_INT 1
22106: ST_TO_ADDR
// if p3 = 6 then
22107: LD_VAR 0 3
22111: PUSH
22112: LD_INT 6
22114: EQUAL
22115: IFFALSE 22125
// sArmoury := true ;
22117: LD_ADDR_EXP 63
22121: PUSH
22122: LD_INT 1
22124: ST_TO_ADDR
// if p3 = 7 then
22125: LD_VAR 0 3
22129: PUSH
22130: LD_INT 7
22132: EQUAL
22133: IFFALSE 22143
// sRadar := true ;
22135: LD_ADDR_EXP 64
22139: PUSH
22140: LD_INT 1
22142: ST_TO_ADDR
// if p3 = 8 then
22143: LD_VAR 0 3
22147: PUSH
22148: LD_INT 8
22150: EQUAL
22151: IFFALSE 22161
// sBunker := true ;
22153: LD_ADDR_EXP 65
22157: PUSH
22158: LD_INT 1
22160: ST_TO_ADDR
// if p3 = 9 then
22161: LD_VAR 0 3
22165: PUSH
22166: LD_INT 9
22168: EQUAL
22169: IFFALSE 22179
// sHack := true ;
22171: LD_ADDR_EXP 66
22175: PUSH
22176: LD_INT 1
22178: ST_TO_ADDR
// if p3 = 10 then
22179: LD_VAR 0 3
22183: PUSH
22184: LD_INT 10
22186: EQUAL
22187: IFFALSE 22197
// sFire := true ;
22189: LD_ADDR_EXP 67
22193: PUSH
22194: LD_INT 1
22196: ST_TO_ADDR
// if p3 = 11 then
22197: LD_VAR 0 3
22201: PUSH
22202: LD_INT 11
22204: EQUAL
22205: IFFALSE 22215
// sRefresh := true ;
22207: LD_ADDR_EXP 68
22211: PUSH
22212: LD_INT 1
22214: ST_TO_ADDR
// if p3 = 12 then
22215: LD_VAR 0 3
22219: PUSH
22220: LD_INT 12
22222: EQUAL
22223: IFFALSE 22233
// sExp := true ;
22225: LD_ADDR_EXP 69
22229: PUSH
22230: LD_INT 1
22232: ST_TO_ADDR
// if p3 = 13 then
22233: LD_VAR 0 3
22237: PUSH
22238: LD_INT 13
22240: EQUAL
22241: IFFALSE 22251
// sDepot := true ;
22243: LD_ADDR_EXP 70
22247: PUSH
22248: LD_INT 1
22250: ST_TO_ADDR
// if p3 = 14 then
22251: LD_VAR 0 3
22255: PUSH
22256: LD_INT 14
22258: EQUAL
22259: IFFALSE 22269
// sFlag := true ;
22261: LD_ADDR_EXP 71
22265: PUSH
22266: LD_INT 1
22268: ST_TO_ADDR
// if p3 = 15 then
22269: LD_VAR 0 3
22273: PUSH
22274: LD_INT 15
22276: EQUAL
22277: IFFALSE 22287
// sKamikadze := true ;
22279: LD_ADDR_EXP 79
22283: PUSH
22284: LD_INT 1
22286: ST_TO_ADDR
// if p3 = 16 then
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 16
22294: EQUAL
22295: IFFALSE 22305
// sTroll := true ;
22297: LD_ADDR_EXP 80
22301: PUSH
22302: LD_INT 1
22304: ST_TO_ADDR
// if p3 = 17 then
22305: LD_VAR 0 3
22309: PUSH
22310: LD_INT 17
22312: EQUAL
22313: IFFALSE 22323
// sSlow := true ;
22315: LD_ADDR_EXP 81
22319: PUSH
22320: LD_INT 1
22322: ST_TO_ADDR
// if p3 = 18 then
22323: LD_VAR 0 3
22327: PUSH
22328: LD_INT 18
22330: EQUAL
22331: IFFALSE 22341
// sLack := true ;
22333: LD_ADDR_EXP 82
22337: PUSH
22338: LD_INT 1
22340: ST_TO_ADDR
// if p3 = 19 then
22341: LD_VAR 0 3
22345: PUSH
22346: LD_INT 19
22348: EQUAL
22349: IFFALSE 22359
// sTank := true ;
22351: LD_ADDR_EXP 84
22355: PUSH
22356: LD_INT 1
22358: ST_TO_ADDR
// if p3 = 20 then
22359: LD_VAR 0 3
22363: PUSH
22364: LD_INT 20
22366: EQUAL
22367: IFFALSE 22377
// sRemote := true ;
22369: LD_ADDR_EXP 85
22373: PUSH
22374: LD_INT 1
22376: ST_TO_ADDR
// if p3 = 21 then
22377: LD_VAR 0 3
22381: PUSH
22382: LD_INT 21
22384: EQUAL
22385: IFFALSE 22395
// sPowell := true ;
22387: LD_ADDR_EXP 86
22391: PUSH
22392: LD_INT 1
22394: ST_TO_ADDR
// if p3 = 22 then
22395: LD_VAR 0 3
22399: PUSH
22400: LD_INT 22
22402: EQUAL
22403: IFFALSE 22413
// sTeleport := true ;
22405: LD_ADDR_EXP 89
22409: PUSH
22410: LD_INT 1
22412: ST_TO_ADDR
// if p3 = 23 then
22413: LD_VAR 0 3
22417: PUSH
22418: LD_INT 23
22420: EQUAL
22421: IFFALSE 22431
// sOilTower := true ;
22423: LD_ADDR_EXP 91
22427: PUSH
22428: LD_INT 1
22430: ST_TO_ADDR
// if p3 = 24 then
22431: LD_VAR 0 3
22435: PUSH
22436: LD_INT 24
22438: EQUAL
22439: IFFALSE 22449
// sShovel := true ;
22441: LD_ADDR_EXP 92
22445: PUSH
22446: LD_INT 1
22448: ST_TO_ADDR
// if p3 = 25 then
22449: LD_VAR 0 3
22453: PUSH
22454: LD_INT 25
22456: EQUAL
22457: IFFALSE 22467
// sSheik := true ;
22459: LD_ADDR_EXP 93
22463: PUSH
22464: LD_INT 1
22466: ST_TO_ADDR
// if p3 = 26 then
22467: LD_VAR 0 3
22471: PUSH
22472: LD_INT 26
22474: EQUAL
22475: IFFALSE 22485
// sEarthquake := true ;
22477: LD_ADDR_EXP 95
22481: PUSH
22482: LD_INT 1
22484: ST_TO_ADDR
// if p3 = 27 then
22485: LD_VAR 0 3
22489: PUSH
22490: LD_INT 27
22492: EQUAL
22493: IFFALSE 22503
// sAI := true ;
22495: LD_ADDR_EXP 96
22499: PUSH
22500: LD_INT 1
22502: ST_TO_ADDR
// if p3 = 28 then
22503: LD_VAR 0 3
22507: PUSH
22508: LD_INT 28
22510: EQUAL
22511: IFFALSE 22521
// sCargo := true ;
22513: LD_ADDR_EXP 99
22517: PUSH
22518: LD_INT 1
22520: ST_TO_ADDR
// if p3 = 29 then
22521: LD_VAR 0 3
22525: PUSH
22526: LD_INT 29
22528: EQUAL
22529: IFFALSE 22539
// sDLaser := true ;
22531: LD_ADDR_EXP 100
22535: PUSH
22536: LD_INT 1
22538: ST_TO_ADDR
// if p3 = 30 then
22539: LD_VAR 0 3
22543: PUSH
22544: LD_INT 30
22546: EQUAL
22547: IFFALSE 22557
// sExchange := true ;
22549: LD_ADDR_EXP 101
22553: PUSH
22554: LD_INT 1
22556: ST_TO_ADDR
// if p3 = 31 then
22557: LD_VAR 0 3
22561: PUSH
22562: LD_INT 31
22564: EQUAL
22565: IFFALSE 22575
// sFac := true ;
22567: LD_ADDR_EXP 102
22571: PUSH
22572: LD_INT 1
22574: ST_TO_ADDR
// if p3 = 32 then
22575: LD_VAR 0 3
22579: PUSH
22580: LD_INT 32
22582: EQUAL
22583: IFFALSE 22593
// sPower := true ;
22585: LD_ADDR_EXP 103
22589: PUSH
22590: LD_INT 1
22592: ST_TO_ADDR
// if p3 = 33 then
22593: LD_VAR 0 3
22597: PUSH
22598: LD_INT 33
22600: EQUAL
22601: IFFALSE 22611
// sRandom := true ;
22603: LD_ADDR_EXP 104
22607: PUSH
22608: LD_INT 1
22610: ST_TO_ADDR
// if p3 = 34 then
22611: LD_VAR 0 3
22615: PUSH
22616: LD_INT 34
22618: EQUAL
22619: IFFALSE 22629
// sShield := true ;
22621: LD_ADDR_EXP 105
22625: PUSH
22626: LD_INT 1
22628: ST_TO_ADDR
// if p3 = 35 then
22629: LD_VAR 0 3
22633: PUSH
22634: LD_INT 35
22636: EQUAL
22637: IFFALSE 22647
// sTime := true ;
22639: LD_ADDR_EXP 106
22643: PUSH
22644: LD_INT 1
22646: ST_TO_ADDR
// if p3 = 36 then
22647: LD_VAR 0 3
22651: PUSH
22652: LD_INT 36
22654: EQUAL
22655: IFFALSE 22665
// sTools := true ;
22657: LD_ADDR_EXP 107
22661: PUSH
22662: LD_INT 1
22664: ST_TO_ADDR
// if p3 = 101 then
22665: LD_VAR 0 3
22669: PUSH
22670: LD_INT 101
22672: EQUAL
22673: IFFALSE 22683
// sSold := true ;
22675: LD_ADDR_EXP 72
22679: PUSH
22680: LD_INT 1
22682: ST_TO_ADDR
// if p3 = 102 then
22683: LD_VAR 0 3
22687: PUSH
22688: LD_INT 102
22690: EQUAL
22691: IFFALSE 22701
// sDiff := true ;
22693: LD_ADDR_EXP 73
22697: PUSH
22698: LD_INT 1
22700: ST_TO_ADDR
// if p3 = 103 then
22701: LD_VAR 0 3
22705: PUSH
22706: LD_INT 103
22708: EQUAL
22709: IFFALSE 22719
// sFog := true ;
22711: LD_ADDR_EXP 76
22715: PUSH
22716: LD_INT 1
22718: ST_TO_ADDR
// if p3 = 104 then
22719: LD_VAR 0 3
22723: PUSH
22724: LD_INT 104
22726: EQUAL
22727: IFFALSE 22737
// sReset := true ;
22729: LD_ADDR_EXP 77
22733: PUSH
22734: LD_INT 1
22736: ST_TO_ADDR
// if p3 = 105 then
22737: LD_VAR 0 3
22741: PUSH
22742: LD_INT 105
22744: EQUAL
22745: IFFALSE 22755
// sSun := true ;
22747: LD_ADDR_EXP 78
22751: PUSH
22752: LD_INT 1
22754: ST_TO_ADDR
// if p3 = 106 then
22755: LD_VAR 0 3
22759: PUSH
22760: LD_INT 106
22762: EQUAL
22763: IFFALSE 22773
// sTiger := true ;
22765: LD_ADDR_EXP 74
22769: PUSH
22770: LD_INT 1
22772: ST_TO_ADDR
// if p3 = 107 then
22773: LD_VAR 0 3
22777: PUSH
22778: LD_INT 107
22780: EQUAL
22781: IFFALSE 22791
// sBomb := true ;
22783: LD_ADDR_EXP 75
22787: PUSH
22788: LD_INT 1
22790: ST_TO_ADDR
// if p3 = 108 then
22791: LD_VAR 0 3
22795: PUSH
22796: LD_INT 108
22798: EQUAL
22799: IFFALSE 22809
// sWound := true ;
22801: LD_ADDR_EXP 83
22805: PUSH
22806: LD_INT 1
22808: ST_TO_ADDR
// if p3 = 109 then
22809: LD_VAR 0 3
22813: PUSH
22814: LD_INT 109
22816: EQUAL
22817: IFFALSE 22827
// sBetray := true ;
22819: LD_ADDR_EXP 87
22823: PUSH
22824: LD_INT 1
22826: ST_TO_ADDR
// if p3 = 110 then
22827: LD_VAR 0 3
22831: PUSH
22832: LD_INT 110
22834: EQUAL
22835: IFFALSE 22845
// sContamin := true ;
22837: LD_ADDR_EXP 88
22841: PUSH
22842: LD_INT 1
22844: ST_TO_ADDR
// if p3 = 111 then
22845: LD_VAR 0 3
22849: PUSH
22850: LD_INT 111
22852: EQUAL
22853: IFFALSE 22863
// sOil := true ;
22855: LD_ADDR_EXP 90
22859: PUSH
22860: LD_INT 1
22862: ST_TO_ADDR
// if p3 = 112 then
22863: LD_VAR 0 3
22867: PUSH
22868: LD_INT 112
22870: EQUAL
22871: IFFALSE 22881
// sStu := true ;
22873: LD_ADDR_EXP 94
22877: PUSH
22878: LD_INT 1
22880: ST_TO_ADDR
// if p3 = 113 then
22881: LD_VAR 0 3
22885: PUSH
22886: LD_INT 113
22888: EQUAL
22889: IFFALSE 22899
// sBazooka := true ;
22891: LD_ADDR_EXP 97
22895: PUSH
22896: LD_INT 1
22898: ST_TO_ADDR
// if p3 = 114 then
22899: LD_VAR 0 3
22903: PUSH
22904: LD_INT 114
22906: EQUAL
22907: IFFALSE 22917
// sMortar := true ;
22909: LD_ADDR_EXP 98
22913: PUSH
22914: LD_INT 1
22916: ST_TO_ADDR
// if p3 = 115 then
22917: LD_VAR 0 3
22921: PUSH
22922: LD_INT 115
22924: EQUAL
22925: IFFALSE 22935
// sRanger := true ;
22927: LD_ADDR_EXP 108
22931: PUSH
22932: LD_INT 1
22934: ST_TO_ADDR
// end ; end ;
22935: PPOPN 6
22937: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
22938: LD_EXP 55
22942: PUSH
22943: LD_EXP 60
22947: AND
22948: IFFALSE 23072
22950: GO 22952
22952: DISABLE
22953: LD_INT 0
22955: PPUSH
22956: PPUSH
// begin enable ;
22957: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
22958: LD_ADDR_VAR 0 2
22962: PUSH
22963: LD_INT 22
22965: PUSH
22966: LD_OWVAR 2
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PUSH
22975: LD_INT 2
22977: PUSH
22978: LD_INT 34
22980: PUSH
22981: LD_INT 7
22983: PUSH
22984: EMPTY
22985: LIST
22986: LIST
22987: PUSH
22988: LD_INT 34
22990: PUSH
22991: LD_INT 45
22993: PUSH
22994: EMPTY
22995: LIST
22996: LIST
22997: PUSH
22998: LD_INT 34
23000: PUSH
23001: LD_INT 28
23003: PUSH
23004: EMPTY
23005: LIST
23006: LIST
23007: PUSH
23008: LD_INT 34
23010: PUSH
23011: LD_INT 47
23013: PUSH
23014: EMPTY
23015: LIST
23016: LIST
23017: PUSH
23018: EMPTY
23019: LIST
23020: LIST
23021: LIST
23022: LIST
23023: LIST
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PPUSH
23029: CALL_OW 69
23033: ST_TO_ADDR
// if not tmp then
23034: LD_VAR 0 2
23038: NOT
23039: IFFALSE 23043
// exit ;
23041: GO 23072
// for i in tmp do
23043: LD_ADDR_VAR 0 1
23047: PUSH
23048: LD_VAR 0 2
23052: PUSH
23053: FOR_IN
23054: IFFALSE 23070
// begin SetLives ( i , 0 ) ;
23056: LD_VAR 0 1
23060: PPUSH
23061: LD_INT 0
23063: PPUSH
23064: CALL_OW 234
// end ;
23068: GO 23053
23070: POP
23071: POP
// end ;
23072: PPOPN 2
23074: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23075: LD_EXP 55
23079: PUSH
23080: LD_EXP 61
23084: AND
23085: IFFALSE 23169
23087: GO 23089
23089: DISABLE
23090: LD_INT 0
23092: PPUSH
23093: PPUSH
// begin enable ;
23094: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23095: LD_ADDR_VAR 0 2
23099: PUSH
23100: LD_INT 22
23102: PUSH
23103: LD_OWVAR 2
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: PUSH
23112: LD_INT 32
23114: PUSH
23115: LD_INT 3
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: PUSH
23122: EMPTY
23123: LIST
23124: LIST
23125: PPUSH
23126: CALL_OW 69
23130: ST_TO_ADDR
// if not tmp then
23131: LD_VAR 0 2
23135: NOT
23136: IFFALSE 23140
// exit ;
23138: GO 23169
// for i in tmp do
23140: LD_ADDR_VAR 0 1
23144: PUSH
23145: LD_VAR 0 2
23149: PUSH
23150: FOR_IN
23151: IFFALSE 23167
// begin SetLives ( i , 0 ) ;
23153: LD_VAR 0 1
23157: PPUSH
23158: LD_INT 0
23160: PPUSH
23161: CALL_OW 234
// end ;
23165: GO 23150
23167: POP
23168: POP
// end ;
23169: PPOPN 2
23171: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23172: LD_EXP 55
23176: PUSH
23177: LD_EXP 58
23181: AND
23182: IFFALSE 23275
23184: GO 23186
23186: DISABLE
23187: LD_INT 0
23189: PPUSH
// begin enable ;
23190: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23191: LD_ADDR_VAR 0 1
23195: PUSH
23196: LD_INT 22
23198: PUSH
23199: LD_OWVAR 2
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PUSH
23208: LD_INT 2
23210: PUSH
23211: LD_INT 25
23213: PUSH
23214: LD_INT 5
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: PUSH
23221: LD_INT 25
23223: PUSH
23224: LD_INT 9
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 25
23233: PUSH
23234: LD_INT 8
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: LIST
23245: LIST
23246: PUSH
23247: EMPTY
23248: LIST
23249: LIST
23250: PPUSH
23251: CALL_OW 69
23255: PUSH
23256: FOR_IN
23257: IFFALSE 23273
// begin SetClass ( i , 1 ) ;
23259: LD_VAR 0 1
23263: PPUSH
23264: LD_INT 1
23266: PPUSH
23267: CALL_OW 336
// end ;
23271: GO 23256
23273: POP
23274: POP
// end ;
23275: PPOPN 1
23277: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23278: LD_EXP 55
23282: PUSH
23283: LD_EXP 59
23287: AND
23288: PUSH
23289: LD_OWVAR 65
23293: PUSH
23294: LD_INT 7
23296: LESS
23297: AND
23298: IFFALSE 23312
23300: GO 23302
23302: DISABLE
// begin enable ;
23303: ENABLE
// game_speed := 7 ;
23304: LD_ADDR_OWVAR 65
23308: PUSH
23309: LD_INT 7
23311: ST_TO_ADDR
// end ;
23312: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23313: LD_EXP 55
23317: PUSH
23318: LD_EXP 62
23322: AND
23323: IFFALSE 23525
23325: GO 23327
23327: DISABLE
23328: LD_INT 0
23330: PPUSH
23331: PPUSH
23332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23333: LD_ADDR_VAR 0 3
23337: PUSH
23338: LD_INT 81
23340: PUSH
23341: LD_OWVAR 2
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 21
23352: PUSH
23353: LD_INT 1
23355: PUSH
23356: EMPTY
23357: LIST
23358: LIST
23359: PUSH
23360: EMPTY
23361: LIST
23362: LIST
23363: PPUSH
23364: CALL_OW 69
23368: ST_TO_ADDR
// if not tmp then
23369: LD_VAR 0 3
23373: NOT
23374: IFFALSE 23378
// exit ;
23376: GO 23525
// if tmp > 5 then
23378: LD_VAR 0 3
23382: PUSH
23383: LD_INT 5
23385: GREATER
23386: IFFALSE 23398
// k := 5 else
23388: LD_ADDR_VAR 0 2
23392: PUSH
23393: LD_INT 5
23395: ST_TO_ADDR
23396: GO 23408
// k := tmp ;
23398: LD_ADDR_VAR 0 2
23402: PUSH
23403: LD_VAR 0 3
23407: ST_TO_ADDR
// for i := 1 to k do
23408: LD_ADDR_VAR 0 1
23412: PUSH
23413: DOUBLE
23414: LD_INT 1
23416: DEC
23417: ST_TO_ADDR
23418: LD_VAR 0 2
23422: PUSH
23423: FOR_TO
23424: IFFALSE 23523
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23426: LD_VAR 0 3
23430: PUSH
23431: LD_VAR 0 1
23435: ARRAY
23436: PPUSH
23437: LD_VAR 0 1
23441: PUSH
23442: LD_INT 4
23444: MOD
23445: PUSH
23446: LD_INT 1
23448: PLUS
23449: PPUSH
23450: CALL_OW 259
23454: PUSH
23455: LD_INT 10
23457: LESS
23458: IFFALSE 23521
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23460: LD_VAR 0 3
23464: PUSH
23465: LD_VAR 0 1
23469: ARRAY
23470: PPUSH
23471: LD_VAR 0 1
23475: PUSH
23476: LD_INT 4
23478: MOD
23479: PUSH
23480: LD_INT 1
23482: PLUS
23483: PPUSH
23484: LD_VAR 0 3
23488: PUSH
23489: LD_VAR 0 1
23493: ARRAY
23494: PPUSH
23495: LD_VAR 0 1
23499: PUSH
23500: LD_INT 4
23502: MOD
23503: PUSH
23504: LD_INT 1
23506: PLUS
23507: PPUSH
23508: CALL_OW 259
23512: PUSH
23513: LD_INT 1
23515: PLUS
23516: PPUSH
23517: CALL_OW 237
23521: GO 23423
23523: POP
23524: POP
// end ;
23525: PPOPN 3
23527: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23528: LD_EXP 55
23532: PUSH
23533: LD_EXP 63
23537: AND
23538: IFFALSE 23558
23540: GO 23542
23542: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23543: LD_INT 4
23545: PPUSH
23546: LD_OWVAR 2
23550: PPUSH
23551: LD_INT 0
23553: PPUSH
23554: CALL_OW 324
23558: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23559: LD_EXP 55
23563: PUSH
23564: LD_EXP 92
23568: AND
23569: IFFALSE 23589
23571: GO 23573
23573: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23574: LD_INT 19
23576: PPUSH
23577: LD_OWVAR 2
23581: PPUSH
23582: LD_INT 0
23584: PPUSH
23585: CALL_OW 324
23589: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23590: LD_EXP 55
23594: PUSH
23595: LD_EXP 64
23599: AND
23600: IFFALSE 23702
23602: GO 23604
23604: DISABLE
23605: LD_INT 0
23607: PPUSH
23608: PPUSH
// begin enable ;
23609: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23610: LD_ADDR_VAR 0 2
23614: PUSH
23615: LD_INT 22
23617: PUSH
23618: LD_OWVAR 2
23622: PUSH
23623: EMPTY
23624: LIST
23625: LIST
23626: PUSH
23627: LD_INT 2
23629: PUSH
23630: LD_INT 34
23632: PUSH
23633: LD_INT 11
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: PUSH
23640: LD_INT 34
23642: PUSH
23643: LD_INT 30
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: LIST
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: PPUSH
23659: CALL_OW 69
23663: ST_TO_ADDR
// if not tmp then
23664: LD_VAR 0 2
23668: NOT
23669: IFFALSE 23673
// exit ;
23671: GO 23702
// for i in tmp do
23673: LD_ADDR_VAR 0 1
23677: PUSH
23678: LD_VAR 0 2
23682: PUSH
23683: FOR_IN
23684: IFFALSE 23700
// begin SetLives ( i , 0 ) ;
23686: LD_VAR 0 1
23690: PPUSH
23691: LD_INT 0
23693: PPUSH
23694: CALL_OW 234
// end ;
23698: GO 23683
23700: POP
23701: POP
// end ;
23702: PPOPN 2
23704: END
// every 0 0$1 trigger StreamModeActive and sBunker do
23705: LD_EXP 55
23709: PUSH
23710: LD_EXP 65
23714: AND
23715: IFFALSE 23735
23717: GO 23719
23719: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
23720: LD_INT 32
23722: PPUSH
23723: LD_OWVAR 2
23727: PPUSH
23728: LD_INT 0
23730: PPUSH
23731: CALL_OW 324
23735: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
23736: LD_EXP 55
23740: PUSH
23741: LD_EXP 66
23745: AND
23746: IFFALSE 23927
23748: GO 23750
23750: DISABLE
23751: LD_INT 0
23753: PPUSH
23754: PPUSH
23755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
23756: LD_ADDR_VAR 0 2
23760: PUSH
23761: LD_INT 22
23763: PUSH
23764: LD_OWVAR 2
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: LD_INT 33
23775: PUSH
23776: LD_INT 3
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PPUSH
23787: CALL_OW 69
23791: ST_TO_ADDR
// if not tmp then
23792: LD_VAR 0 2
23796: NOT
23797: IFFALSE 23801
// exit ;
23799: GO 23927
// side := 0 ;
23801: LD_ADDR_VAR 0 3
23805: PUSH
23806: LD_INT 0
23808: ST_TO_ADDR
// for i := 1 to 8 do
23809: LD_ADDR_VAR 0 1
23813: PUSH
23814: DOUBLE
23815: LD_INT 1
23817: DEC
23818: ST_TO_ADDR
23819: LD_INT 8
23821: PUSH
23822: FOR_TO
23823: IFFALSE 23871
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
23825: LD_OWVAR 2
23829: PUSH
23830: LD_VAR 0 1
23834: NONEQUAL
23835: PUSH
23836: LD_OWVAR 2
23840: PPUSH
23841: LD_VAR 0 1
23845: PPUSH
23846: CALL_OW 81
23850: PUSH
23851: LD_INT 2
23853: EQUAL
23854: AND
23855: IFFALSE 23869
// begin side := i ;
23857: LD_ADDR_VAR 0 3
23861: PUSH
23862: LD_VAR 0 1
23866: ST_TO_ADDR
// break ;
23867: GO 23871
// end ;
23869: GO 23822
23871: POP
23872: POP
// if not side then
23873: LD_VAR 0 3
23877: NOT
23878: IFFALSE 23882
// exit ;
23880: GO 23927
// for i := 1 to tmp do
23882: LD_ADDR_VAR 0 1
23886: PUSH
23887: DOUBLE
23888: LD_INT 1
23890: DEC
23891: ST_TO_ADDR
23892: LD_VAR 0 2
23896: PUSH
23897: FOR_TO
23898: IFFALSE 23925
// if Prob ( 60 ) then
23900: LD_INT 60
23902: PPUSH
23903: CALL_OW 13
23907: IFFALSE 23923
// SetSide ( i , side ) ;
23909: LD_VAR 0 1
23913: PPUSH
23914: LD_VAR 0 3
23918: PPUSH
23919: CALL_OW 235
23923: GO 23897
23925: POP
23926: POP
// end ;
23927: PPOPN 3
23929: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
23930: LD_EXP 55
23934: PUSH
23935: LD_EXP 68
23939: AND
23940: IFFALSE 24059
23942: GO 23944
23944: DISABLE
23945: LD_INT 0
23947: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
23948: LD_ADDR_VAR 0 1
23952: PUSH
23953: LD_INT 22
23955: PUSH
23956: LD_OWVAR 2
23960: PUSH
23961: EMPTY
23962: LIST
23963: LIST
23964: PUSH
23965: LD_INT 21
23967: PUSH
23968: LD_INT 1
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: PUSH
23975: LD_INT 3
23977: PUSH
23978: LD_INT 23
23980: PUSH
23981: LD_INT 0
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: PUSH
23992: EMPTY
23993: LIST
23994: LIST
23995: LIST
23996: PPUSH
23997: CALL_OW 69
24001: PUSH
24002: FOR_IN
24003: IFFALSE 24057
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24005: LD_VAR 0 1
24009: PPUSH
24010: CALL_OW 257
24014: PUSH
24015: LD_INT 1
24017: PUSH
24018: LD_INT 2
24020: PUSH
24021: LD_INT 3
24023: PUSH
24024: LD_INT 4
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: LIST
24032: IN
24033: IFFALSE 24055
// SetClass ( un , rand ( 1 , 4 ) ) ;
24035: LD_VAR 0 1
24039: PPUSH
24040: LD_INT 1
24042: PPUSH
24043: LD_INT 4
24045: PPUSH
24046: CALL_OW 12
24050: PPUSH
24051: CALL_OW 336
24055: GO 24002
24057: POP
24058: POP
// end ;
24059: PPOPN 1
24061: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24062: LD_EXP 55
24066: PUSH
24067: LD_EXP 67
24071: AND
24072: IFFALSE 24151
24074: GO 24076
24076: DISABLE
24077: LD_INT 0
24079: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24080: LD_ADDR_VAR 0 1
24084: PUSH
24085: LD_INT 22
24087: PUSH
24088: LD_OWVAR 2
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: PUSH
24097: LD_INT 21
24099: PUSH
24100: LD_INT 3
24102: PUSH
24103: EMPTY
24104: LIST
24105: LIST
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PPUSH
24111: CALL_OW 69
24115: ST_TO_ADDR
// if not tmp then
24116: LD_VAR 0 1
24120: NOT
24121: IFFALSE 24125
// exit ;
24123: GO 24151
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24125: LD_VAR 0 1
24129: PUSH
24130: LD_INT 1
24132: PPUSH
24133: LD_VAR 0 1
24137: PPUSH
24138: CALL_OW 12
24142: ARRAY
24143: PPUSH
24144: LD_INT 100
24146: PPUSH
24147: CALL_OW 234
// end ;
24151: PPOPN 1
24153: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24154: LD_EXP 55
24158: PUSH
24159: LD_EXP 69
24163: AND
24164: IFFALSE 24262
24166: GO 24168
24168: DISABLE
24169: LD_INT 0
24171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24172: LD_ADDR_VAR 0 1
24176: PUSH
24177: LD_INT 22
24179: PUSH
24180: LD_OWVAR 2
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: PUSH
24189: LD_INT 21
24191: PUSH
24192: LD_INT 1
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: PPUSH
24203: CALL_OW 69
24207: ST_TO_ADDR
// if not tmp then
24208: LD_VAR 0 1
24212: NOT
24213: IFFALSE 24217
// exit ;
24215: GO 24262
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24217: LD_VAR 0 1
24221: PUSH
24222: LD_INT 1
24224: PPUSH
24225: LD_VAR 0 1
24229: PPUSH
24230: CALL_OW 12
24234: ARRAY
24235: PPUSH
24236: LD_INT 1
24238: PPUSH
24239: LD_INT 4
24241: PPUSH
24242: CALL_OW 12
24246: PPUSH
24247: LD_INT 3000
24249: PPUSH
24250: LD_INT 9000
24252: PPUSH
24253: CALL_OW 12
24257: PPUSH
24258: CALL_OW 492
// end ;
24262: PPOPN 1
24264: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24265: LD_EXP 55
24269: PUSH
24270: LD_EXP 70
24274: AND
24275: IFFALSE 24295
24277: GO 24279
24279: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24280: LD_INT 1
24282: PPUSH
24283: LD_OWVAR 2
24287: PPUSH
24288: LD_INT 0
24290: PPUSH
24291: CALL_OW 324
24295: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24296: LD_EXP 55
24300: PUSH
24301: LD_EXP 71
24305: AND
24306: IFFALSE 24389
24308: GO 24310
24310: DISABLE
24311: LD_INT 0
24313: PPUSH
24314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24315: LD_ADDR_VAR 0 2
24319: PUSH
24320: LD_INT 22
24322: PUSH
24323: LD_OWVAR 2
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: PUSH
24332: LD_INT 21
24334: PUSH
24335: LD_INT 3
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: PUSH
24342: EMPTY
24343: LIST
24344: LIST
24345: PPUSH
24346: CALL_OW 69
24350: ST_TO_ADDR
// if not tmp then
24351: LD_VAR 0 2
24355: NOT
24356: IFFALSE 24360
// exit ;
24358: GO 24389
// for i in tmp do
24360: LD_ADDR_VAR 0 1
24364: PUSH
24365: LD_VAR 0 2
24369: PUSH
24370: FOR_IN
24371: IFFALSE 24387
// SetBLevel ( i , 10 ) ;
24373: LD_VAR 0 1
24377: PPUSH
24378: LD_INT 10
24380: PPUSH
24381: CALL_OW 241
24385: GO 24370
24387: POP
24388: POP
// end ;
24389: PPOPN 2
24391: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
24392: LD_EXP 55
24396: PUSH
24397: LD_EXP 72
24401: AND
24402: IFFALSE 24513
24404: GO 24406
24406: DISABLE
24407: LD_INT 0
24409: PPUSH
24410: PPUSH
24411: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24412: LD_ADDR_VAR 0 3
24416: PUSH
24417: LD_INT 22
24419: PUSH
24420: LD_OWVAR 2
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: PUSH
24429: LD_INT 25
24431: PUSH
24432: LD_INT 1
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: PUSH
24439: EMPTY
24440: LIST
24441: LIST
24442: PPUSH
24443: CALL_OW 69
24447: ST_TO_ADDR
// if not tmp then
24448: LD_VAR 0 3
24452: NOT
24453: IFFALSE 24457
// exit ;
24455: GO 24513
// un := tmp [ rand ( 1 , tmp ) ] ;
24457: LD_ADDR_VAR 0 2
24461: PUSH
24462: LD_VAR 0 3
24466: PUSH
24467: LD_INT 1
24469: PPUSH
24470: LD_VAR 0 3
24474: PPUSH
24475: CALL_OW 12
24479: ARRAY
24480: ST_TO_ADDR
// if Crawls ( un ) then
24481: LD_VAR 0 2
24485: PPUSH
24486: CALL_OW 318
24490: IFFALSE 24501
// ComWalk ( un ) ;
24492: LD_VAR 0 2
24496: PPUSH
24497: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24501: LD_VAR 0 2
24505: PPUSH
24506: LD_INT 5
24508: PPUSH
24509: CALL_OW 336
// end ;
24513: PPOPN 3
24515: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24516: LD_EXP 55
24520: PUSH
24521: LD_EXP 73
24525: AND
24526: PUSH
24527: LD_OWVAR 67
24531: PUSH
24532: LD_INT 3
24534: LESS
24535: AND
24536: IFFALSE 24555
24538: GO 24540
24540: DISABLE
// Difficulty := Difficulty + 1 ;
24541: LD_ADDR_OWVAR 67
24545: PUSH
24546: LD_OWVAR 67
24550: PUSH
24551: LD_INT 1
24553: PLUS
24554: ST_TO_ADDR
24555: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24556: LD_EXP 55
24560: PUSH
24561: LD_EXP 74
24565: AND
24566: IFFALSE 24669
24568: GO 24570
24570: DISABLE
24571: LD_INT 0
24573: PPUSH
// begin for i := 1 to 5 do
24574: LD_ADDR_VAR 0 1
24578: PUSH
24579: DOUBLE
24580: LD_INT 1
24582: DEC
24583: ST_TO_ADDR
24584: LD_INT 5
24586: PUSH
24587: FOR_TO
24588: IFFALSE 24667
// begin uc_nation := nation_nature ;
24590: LD_ADDR_OWVAR 21
24594: PUSH
24595: LD_INT 0
24597: ST_TO_ADDR
// uc_side := 0 ;
24598: LD_ADDR_OWVAR 20
24602: PUSH
24603: LD_INT 0
24605: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24606: LD_ADDR_OWVAR 29
24610: PUSH
24611: LD_INT 12
24613: PUSH
24614: LD_INT 12
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: ST_TO_ADDR
// hc_agressivity := 20 ;
24621: LD_ADDR_OWVAR 35
24625: PUSH
24626: LD_INT 20
24628: ST_TO_ADDR
// hc_class := class_tiger ;
24629: LD_ADDR_OWVAR 28
24633: PUSH
24634: LD_INT 14
24636: ST_TO_ADDR
// hc_gallery :=  ;
24637: LD_ADDR_OWVAR 33
24641: PUSH
24642: LD_STRING 
24644: ST_TO_ADDR
// hc_name :=  ;
24645: LD_ADDR_OWVAR 26
24649: PUSH
24650: LD_STRING 
24652: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
24653: CALL_OW 44
24657: PPUSH
24658: LD_INT 0
24660: PPUSH
24661: CALL_OW 51
// end ;
24665: GO 24587
24667: POP
24668: POP
// end ;
24669: PPOPN 1
24671: END
// every 0 0$1 trigger StreamModeActive and sBomb do
24672: LD_EXP 55
24676: PUSH
24677: LD_EXP 75
24681: AND
24682: IFFALSE 24691
24684: GO 24686
24686: DISABLE
// StreamSibBomb ;
24687: CALL 24692 0 0
24691: END
// export function StreamSibBomb ; var i , x , y ; begin
24692: LD_INT 0
24694: PPUSH
24695: PPUSH
24696: PPUSH
24697: PPUSH
// result := false ;
24698: LD_ADDR_VAR 0 1
24702: PUSH
24703: LD_INT 0
24705: ST_TO_ADDR
// for i := 1 to 16 do
24706: LD_ADDR_VAR 0 2
24710: PUSH
24711: DOUBLE
24712: LD_INT 1
24714: DEC
24715: ST_TO_ADDR
24716: LD_INT 16
24718: PUSH
24719: FOR_TO
24720: IFFALSE 24919
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24722: LD_ADDR_VAR 0 3
24726: PUSH
24727: LD_INT 10
24729: PUSH
24730: LD_INT 20
24732: PUSH
24733: LD_INT 30
24735: PUSH
24736: LD_INT 40
24738: PUSH
24739: LD_INT 50
24741: PUSH
24742: LD_INT 60
24744: PUSH
24745: LD_INT 70
24747: PUSH
24748: LD_INT 80
24750: PUSH
24751: LD_INT 90
24753: PUSH
24754: LD_INT 100
24756: PUSH
24757: LD_INT 110
24759: PUSH
24760: LD_INT 120
24762: PUSH
24763: LD_INT 130
24765: PUSH
24766: LD_INT 140
24768: PUSH
24769: LD_INT 150
24771: PUSH
24772: EMPTY
24773: LIST
24774: LIST
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: LIST
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_INT 1
24791: PPUSH
24792: LD_INT 15
24794: PPUSH
24795: CALL_OW 12
24799: ARRAY
24800: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24801: LD_ADDR_VAR 0 4
24805: PUSH
24806: LD_INT 10
24808: PUSH
24809: LD_INT 20
24811: PUSH
24812: LD_INT 30
24814: PUSH
24815: LD_INT 40
24817: PUSH
24818: LD_INT 50
24820: PUSH
24821: LD_INT 60
24823: PUSH
24824: LD_INT 70
24826: PUSH
24827: LD_INT 80
24829: PUSH
24830: LD_INT 90
24832: PUSH
24833: LD_INT 100
24835: PUSH
24836: LD_INT 110
24838: PUSH
24839: LD_INT 120
24841: PUSH
24842: LD_INT 130
24844: PUSH
24845: LD_INT 140
24847: PUSH
24848: LD_INT 150
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: LIST
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 1
24870: PPUSH
24871: LD_INT 15
24873: PPUSH
24874: CALL_OW 12
24878: ARRAY
24879: ST_TO_ADDR
// if ValidHex ( x , y ) then
24880: LD_VAR 0 3
24884: PPUSH
24885: LD_VAR 0 4
24889: PPUSH
24890: CALL_OW 488
24894: IFFALSE 24917
// begin result := [ x , y ] ;
24896: LD_ADDR_VAR 0 1
24900: PUSH
24901: LD_VAR 0 3
24905: PUSH
24906: LD_VAR 0 4
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: ST_TO_ADDR
// break ;
24915: GO 24919
// end ; end ;
24917: GO 24719
24919: POP
24920: POP
// if result then
24921: LD_VAR 0 1
24925: IFFALSE 24985
// begin ToLua ( playSibBomb() ) ;
24927: LD_STRING playSibBomb()
24929: PPUSH
24930: CALL_OW 559
// wait ( 0 0$14 ) ;
24934: LD_INT 490
24936: PPUSH
24937: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
24941: LD_VAR 0 1
24945: PUSH
24946: LD_INT 1
24948: ARRAY
24949: PPUSH
24950: LD_VAR 0 1
24954: PUSH
24955: LD_INT 2
24957: ARRAY
24958: PPUSH
24959: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
24963: LD_VAR 0 1
24967: PUSH
24968: LD_INT 1
24970: ARRAY
24971: PPUSH
24972: LD_VAR 0 1
24976: PUSH
24977: LD_INT 2
24979: ARRAY
24980: PPUSH
24981: CALL_OW 429
// end ; end ;
24985: LD_VAR 0 1
24989: RET
// every 0 0$1 trigger StreamModeActive and sReset do
24990: LD_EXP 55
24994: PUSH
24995: LD_EXP 77
24999: AND
25000: IFFALSE 25012
25002: GO 25004
25004: DISABLE
// YouLost (  ) ;
25005: LD_STRING 
25007: PPUSH
25008: CALL_OW 104
25012: END
// every 0 0$1 trigger StreamModeActive and sFog do
25013: LD_EXP 55
25017: PUSH
25018: LD_EXP 76
25022: AND
25023: IFFALSE 25037
25025: GO 25027
25027: DISABLE
// FogOff ( your_side ) ;
25028: LD_OWVAR 2
25032: PPUSH
25033: CALL_OW 344
25037: END
// every 0 0$1 trigger StreamModeActive and sSun do
25038: LD_EXP 55
25042: PUSH
25043: LD_EXP 78
25047: AND
25048: IFFALSE 25076
25050: GO 25052
25052: DISABLE
// begin solar_recharge_percent := 0 ;
25053: LD_ADDR_OWVAR 79
25057: PUSH
25058: LD_INT 0
25060: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25061: LD_INT 10500
25063: PPUSH
25064: CALL_OW 67
// solar_recharge_percent := 100 ;
25068: LD_ADDR_OWVAR 79
25072: PUSH
25073: LD_INT 100
25075: ST_TO_ADDR
// end ;
25076: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25077: LD_EXP 55
25081: PUSH
25082: LD_EXP 79
25086: AND
25087: IFFALSE 25326
25089: GO 25091
25091: DISABLE
25092: LD_INT 0
25094: PPUSH
25095: PPUSH
25096: PPUSH
// begin tmp := [ ] ;
25097: LD_ADDR_VAR 0 3
25101: PUSH
25102: EMPTY
25103: ST_TO_ADDR
// for i := 1 to 6 do
25104: LD_ADDR_VAR 0 1
25108: PUSH
25109: DOUBLE
25110: LD_INT 1
25112: DEC
25113: ST_TO_ADDR
25114: LD_INT 6
25116: PUSH
25117: FOR_TO
25118: IFFALSE 25223
// begin uc_nation := nation_nature ;
25120: LD_ADDR_OWVAR 21
25124: PUSH
25125: LD_INT 0
25127: ST_TO_ADDR
// uc_side := 0 ;
25128: LD_ADDR_OWVAR 20
25132: PUSH
25133: LD_INT 0
25135: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25136: LD_ADDR_OWVAR 29
25140: PUSH
25141: LD_INT 12
25143: PUSH
25144: LD_INT 12
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: ST_TO_ADDR
// hc_agressivity := 20 ;
25151: LD_ADDR_OWVAR 35
25155: PUSH
25156: LD_INT 20
25158: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25159: LD_ADDR_OWVAR 28
25163: PUSH
25164: LD_INT 17
25166: ST_TO_ADDR
// hc_gallery :=  ;
25167: LD_ADDR_OWVAR 33
25171: PUSH
25172: LD_STRING 
25174: ST_TO_ADDR
// hc_name :=  ;
25175: LD_ADDR_OWVAR 26
25179: PUSH
25180: LD_STRING 
25182: ST_TO_ADDR
// un := CreateHuman ;
25183: LD_ADDR_VAR 0 2
25187: PUSH
25188: CALL_OW 44
25192: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25193: LD_VAR 0 2
25197: PPUSH
25198: LD_INT 1
25200: PPUSH
25201: CALL_OW 51
// tmp := tmp ^ un ;
25205: LD_ADDR_VAR 0 3
25209: PUSH
25210: LD_VAR 0 3
25214: PUSH
25215: LD_VAR 0 2
25219: ADD
25220: ST_TO_ADDR
// end ;
25221: GO 25117
25223: POP
25224: POP
// repeat wait ( 0 0$1 ) ;
25225: LD_INT 35
25227: PPUSH
25228: CALL_OW 67
// for un in tmp do
25232: LD_ADDR_VAR 0 2
25236: PUSH
25237: LD_VAR 0 3
25241: PUSH
25242: FOR_IN
25243: IFFALSE 25317
// begin if IsDead ( un ) then
25245: LD_VAR 0 2
25249: PPUSH
25250: CALL_OW 301
25254: IFFALSE 25274
// begin tmp := tmp diff un ;
25256: LD_ADDR_VAR 0 3
25260: PUSH
25261: LD_VAR 0 3
25265: PUSH
25266: LD_VAR 0 2
25270: DIFF
25271: ST_TO_ADDR
// continue ;
25272: GO 25242
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25274: LD_VAR 0 2
25278: PPUSH
25279: LD_INT 3
25281: PUSH
25282: LD_INT 22
25284: PUSH
25285: LD_INT 0
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: PPUSH
25296: CALL_OW 69
25300: PPUSH
25301: LD_VAR 0 2
25305: PPUSH
25306: CALL_OW 74
25310: PPUSH
25311: CALL_OW 115
// end ;
25315: GO 25242
25317: POP
25318: POP
// until not tmp ;
25319: LD_VAR 0 3
25323: NOT
25324: IFFALSE 25225
// end ;
25326: PPOPN 3
25328: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25329: LD_EXP 55
25333: PUSH
25334: LD_EXP 80
25338: AND
25339: IFFALSE 25393
25341: GO 25343
25343: DISABLE
// begin ToLua ( displayTroll(); ) ;
25344: LD_STRING displayTroll();
25346: PPUSH
25347: CALL_OW 559
// wait ( 3 3$00 ) ;
25351: LD_INT 6300
25353: PPUSH
25354: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25358: LD_STRING hideTroll();
25360: PPUSH
25361: CALL_OW 559
// wait ( 1 1$00 ) ;
25365: LD_INT 2100
25367: PPUSH
25368: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25372: LD_STRING displayTroll();
25374: PPUSH
25375: CALL_OW 559
// wait ( 1 1$00 ) ;
25379: LD_INT 2100
25381: PPUSH
25382: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25386: LD_STRING hideTroll();
25388: PPUSH
25389: CALL_OW 559
// end ;
25393: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
25394: LD_EXP 55
25398: PUSH
25399: LD_EXP 81
25403: AND
25404: IFFALSE 25467
25406: GO 25408
25408: DISABLE
25409: LD_INT 0
25411: PPUSH
// begin p := 0 ;
25412: LD_ADDR_VAR 0 1
25416: PUSH
25417: LD_INT 0
25419: ST_TO_ADDR
// repeat game_speed := 1 ;
25420: LD_ADDR_OWVAR 65
25424: PUSH
25425: LD_INT 1
25427: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25428: LD_INT 35
25430: PPUSH
25431: CALL_OW 67
// p := p + 1 ;
25435: LD_ADDR_VAR 0 1
25439: PUSH
25440: LD_VAR 0 1
25444: PUSH
25445: LD_INT 1
25447: PLUS
25448: ST_TO_ADDR
// until p >= 60 ;
25449: LD_VAR 0 1
25453: PUSH
25454: LD_INT 60
25456: GREATEREQUAL
25457: IFFALSE 25420
// game_speed := 4 ;
25459: LD_ADDR_OWVAR 65
25463: PUSH
25464: LD_INT 4
25466: ST_TO_ADDR
// end ;
25467: PPOPN 1
25469: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25470: LD_EXP 55
25474: PUSH
25475: LD_EXP 82
25479: AND
25480: IFFALSE 25626
25482: GO 25484
25484: DISABLE
25485: LD_INT 0
25487: PPUSH
25488: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25489: LD_ADDR_VAR 0 1
25493: PUSH
25494: LD_INT 22
25496: PUSH
25497: LD_OWVAR 2
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: LD_INT 2
25508: PUSH
25509: LD_INT 30
25511: PUSH
25512: LD_INT 0
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: PUSH
25519: LD_INT 30
25521: PUSH
25522: LD_INT 1
25524: PUSH
25525: EMPTY
25526: LIST
25527: LIST
25528: PUSH
25529: EMPTY
25530: LIST
25531: LIST
25532: LIST
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PPUSH
25538: CALL_OW 69
25542: ST_TO_ADDR
// if not depot then
25543: LD_VAR 0 1
25547: NOT
25548: IFFALSE 25552
// exit ;
25550: GO 25626
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25552: LD_ADDR_VAR 0 2
25556: PUSH
25557: LD_VAR 0 1
25561: PUSH
25562: LD_INT 1
25564: PPUSH
25565: LD_VAR 0 1
25569: PPUSH
25570: CALL_OW 12
25574: ARRAY
25575: PPUSH
25576: CALL_OW 274
25580: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25581: LD_VAR 0 2
25585: PPUSH
25586: LD_INT 1
25588: PPUSH
25589: LD_INT 0
25591: PPUSH
25592: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25596: LD_VAR 0 2
25600: PPUSH
25601: LD_INT 2
25603: PPUSH
25604: LD_INT 0
25606: PPUSH
25607: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25611: LD_VAR 0 2
25615: PPUSH
25616: LD_INT 3
25618: PPUSH
25619: LD_INT 0
25621: PPUSH
25622: CALL_OW 277
// end ;
25626: PPOPN 2
25628: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
25629: LD_EXP 55
25633: PUSH
25634: LD_EXP 83
25638: AND
25639: IFFALSE 25736
25641: GO 25643
25643: DISABLE
25644: LD_INT 0
25646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25647: LD_ADDR_VAR 0 1
25651: PUSH
25652: LD_INT 22
25654: PUSH
25655: LD_OWVAR 2
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 21
25666: PUSH
25667: LD_INT 1
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 3
25676: PUSH
25677: LD_INT 23
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: EMPTY
25688: LIST
25689: LIST
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: LIST
25695: PPUSH
25696: CALL_OW 69
25700: ST_TO_ADDR
// if not tmp then
25701: LD_VAR 0 1
25705: NOT
25706: IFFALSE 25710
// exit ;
25708: GO 25736
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
25710: LD_VAR 0 1
25714: PUSH
25715: LD_INT 1
25717: PPUSH
25718: LD_VAR 0 1
25722: PPUSH
25723: CALL_OW 12
25727: ARRAY
25728: PPUSH
25729: LD_INT 200
25731: PPUSH
25732: CALL_OW 234
// end ;
25736: PPOPN 1
25738: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
25739: LD_EXP 55
25743: PUSH
25744: LD_EXP 84
25748: AND
25749: IFFALSE 25828
25751: GO 25753
25753: DISABLE
25754: LD_INT 0
25756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
25757: LD_ADDR_VAR 0 1
25761: PUSH
25762: LD_INT 22
25764: PUSH
25765: LD_OWVAR 2
25769: PUSH
25770: EMPTY
25771: LIST
25772: LIST
25773: PUSH
25774: LD_INT 21
25776: PUSH
25777: LD_INT 2
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PPUSH
25788: CALL_OW 69
25792: ST_TO_ADDR
// if not tmp then
25793: LD_VAR 0 1
25797: NOT
25798: IFFALSE 25802
// exit ;
25800: GO 25828
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
25802: LD_VAR 0 1
25806: PUSH
25807: LD_INT 1
25809: PPUSH
25810: LD_VAR 0 1
25814: PPUSH
25815: CALL_OW 12
25819: ARRAY
25820: PPUSH
25821: LD_INT 60
25823: PPUSH
25824: CALL_OW 234
// end ;
25828: PPOPN 1
25830: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
25831: LD_EXP 55
25835: PUSH
25836: LD_EXP 85
25840: AND
25841: IFFALSE 25940
25843: GO 25845
25845: DISABLE
25846: LD_INT 0
25848: PPUSH
25849: PPUSH
// begin enable ;
25850: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
25851: LD_ADDR_VAR 0 1
25855: PUSH
25856: LD_INT 22
25858: PUSH
25859: LD_OWVAR 2
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PUSH
25868: LD_INT 61
25870: PUSH
25871: EMPTY
25872: LIST
25873: PUSH
25874: LD_INT 33
25876: PUSH
25877: LD_INT 2
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: LIST
25888: PPUSH
25889: CALL_OW 69
25893: ST_TO_ADDR
// if not tmp then
25894: LD_VAR 0 1
25898: NOT
25899: IFFALSE 25903
// exit ;
25901: GO 25940
// for i in tmp do
25903: LD_ADDR_VAR 0 2
25907: PUSH
25908: LD_VAR 0 1
25912: PUSH
25913: FOR_IN
25914: IFFALSE 25938
// if IsControledBy ( i ) then
25916: LD_VAR 0 2
25920: PPUSH
25921: CALL_OW 312
25925: IFFALSE 25936
// ComUnlink ( i ) ;
25927: LD_VAR 0 2
25931: PPUSH
25932: CALL_OW 136
25936: GO 25913
25938: POP
25939: POP
// end ;
25940: PPOPN 2
25942: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
25943: LD_EXP 55
25947: PUSH
25948: LD_EXP 86
25952: AND
25953: IFFALSE 26093
25955: GO 25957
25957: DISABLE
25958: LD_INT 0
25960: PPUSH
25961: PPUSH
// begin ToLua ( displayPowell(); ) ;
25962: LD_STRING displayPowell();
25964: PPUSH
25965: CALL_OW 559
// uc_side := 0 ;
25969: LD_ADDR_OWVAR 20
25973: PUSH
25974: LD_INT 0
25976: ST_TO_ADDR
// uc_nation := 2 ;
25977: LD_ADDR_OWVAR 21
25981: PUSH
25982: LD_INT 2
25984: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
25985: LD_ADDR_OWVAR 37
25989: PUSH
25990: LD_INT 14
25992: ST_TO_ADDR
// vc_engine := engine_siberite ;
25993: LD_ADDR_OWVAR 39
25997: PUSH
25998: LD_INT 3
26000: ST_TO_ADDR
// vc_control := control_apeman ;
26001: LD_ADDR_OWVAR 38
26005: PUSH
26006: LD_INT 5
26008: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26009: LD_ADDR_OWVAR 40
26013: PUSH
26014: LD_INT 29
26016: ST_TO_ADDR
// un := CreateVehicle ;
26017: LD_ADDR_VAR 0 2
26021: PUSH
26022: CALL_OW 45
26026: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26027: LD_VAR 0 2
26031: PPUSH
26032: LD_INT 1
26034: PPUSH
26035: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26039: LD_INT 35
26041: PPUSH
26042: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26046: LD_VAR 0 2
26050: PPUSH
26051: LD_INT 22
26053: PUSH
26054: LD_OWVAR 2
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PPUSH
26063: CALL_OW 69
26067: PPUSH
26068: LD_VAR 0 2
26072: PPUSH
26073: CALL_OW 74
26077: PPUSH
26078: CALL_OW 115
// until IsDead ( un ) ;
26082: LD_VAR 0 2
26086: PPUSH
26087: CALL_OW 301
26091: IFFALSE 26039
// end ;
26093: PPOPN 2
26095: END
// every 0 0$1 trigger StreamModeActive and sStu do
26096: LD_EXP 55
26100: PUSH
26101: LD_EXP 94
26105: AND
26106: IFFALSE 26122
26108: GO 26110
26110: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26111: LD_STRING displayStucuk();
26113: PPUSH
26114: CALL_OW 559
// ResetFog ;
26118: CALL_OW 335
// end ;
26122: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26123: LD_EXP 55
26127: PUSH
26128: LD_EXP 87
26132: AND
26133: IFFALSE 26274
26135: GO 26137
26137: DISABLE
26138: LD_INT 0
26140: PPUSH
26141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26142: LD_ADDR_VAR 0 2
26146: PUSH
26147: LD_INT 22
26149: PUSH
26150: LD_OWVAR 2
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: PUSH
26159: LD_INT 21
26161: PUSH
26162: LD_INT 1
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PPUSH
26173: CALL_OW 69
26177: ST_TO_ADDR
// if not tmp then
26178: LD_VAR 0 2
26182: NOT
26183: IFFALSE 26187
// exit ;
26185: GO 26274
// un := tmp [ rand ( 1 , tmp ) ] ;
26187: LD_ADDR_VAR 0 1
26191: PUSH
26192: LD_VAR 0 2
26196: PUSH
26197: LD_INT 1
26199: PPUSH
26200: LD_VAR 0 2
26204: PPUSH
26205: CALL_OW 12
26209: ARRAY
26210: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26211: LD_VAR 0 1
26215: PPUSH
26216: LD_INT 0
26218: PPUSH
26219: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26223: LD_VAR 0 1
26227: PPUSH
26228: LD_OWVAR 3
26232: PUSH
26233: LD_VAR 0 1
26237: DIFF
26238: PPUSH
26239: LD_VAR 0 1
26243: PPUSH
26244: CALL_OW 74
26248: PPUSH
26249: CALL_OW 115
// wait ( 0 0$20 ) ;
26253: LD_INT 700
26255: PPUSH
26256: CALL_OW 67
// SetSide ( un , your_side ) ;
26260: LD_VAR 0 1
26264: PPUSH
26265: LD_OWVAR 2
26269: PPUSH
26270: CALL_OW 235
// end ;
26274: PPOPN 2
26276: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26277: LD_EXP 55
26281: PUSH
26282: LD_EXP 88
26286: AND
26287: IFFALSE 26393
26289: GO 26291
26291: DISABLE
26292: LD_INT 0
26294: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: LD_INT 22
26302: PUSH
26303: LD_OWVAR 2
26307: PUSH
26308: EMPTY
26309: LIST
26310: LIST
26311: PUSH
26312: LD_INT 2
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: LD_INT 0
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: LD_INT 30
26327: PUSH
26328: LD_INT 1
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: LIST
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PPUSH
26344: CALL_OW 69
26348: ST_TO_ADDR
// if not depot then
26349: LD_VAR 0 1
26353: NOT
26354: IFFALSE 26358
// exit ;
26356: GO 26393
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26358: LD_VAR 0 1
26362: PUSH
26363: LD_INT 1
26365: ARRAY
26366: PPUSH
26367: CALL_OW 250
26371: PPUSH
26372: LD_VAR 0 1
26376: PUSH
26377: LD_INT 1
26379: ARRAY
26380: PPUSH
26381: CALL_OW 251
26385: PPUSH
26386: LD_INT 70
26388: PPUSH
26389: CALL_OW 495
// end ;
26393: PPOPN 1
26395: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
26396: LD_EXP 55
26400: PUSH
26401: LD_EXP 89
26405: AND
26406: IFFALSE 26617
26408: GO 26410
26410: DISABLE
26411: LD_INT 0
26413: PPUSH
26414: PPUSH
26415: PPUSH
26416: PPUSH
26417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26418: LD_ADDR_VAR 0 5
26422: PUSH
26423: LD_INT 22
26425: PUSH
26426: LD_OWVAR 2
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: LD_INT 21
26437: PUSH
26438: LD_INT 1
26440: PUSH
26441: EMPTY
26442: LIST
26443: LIST
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PPUSH
26449: CALL_OW 69
26453: ST_TO_ADDR
// if not tmp then
26454: LD_VAR 0 5
26458: NOT
26459: IFFALSE 26463
// exit ;
26461: GO 26617
// for i in tmp do
26463: LD_ADDR_VAR 0 1
26467: PUSH
26468: LD_VAR 0 5
26472: PUSH
26473: FOR_IN
26474: IFFALSE 26615
// begin d := rand ( 0 , 5 ) ;
26476: LD_ADDR_VAR 0 4
26480: PUSH
26481: LD_INT 0
26483: PPUSH
26484: LD_INT 5
26486: PPUSH
26487: CALL_OW 12
26491: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26492: LD_ADDR_VAR 0 2
26496: PUSH
26497: LD_VAR 0 1
26501: PPUSH
26502: CALL_OW 250
26506: PPUSH
26507: LD_VAR 0 4
26511: PPUSH
26512: LD_INT 3
26514: PPUSH
26515: LD_INT 12
26517: PPUSH
26518: CALL_OW 12
26522: PPUSH
26523: CALL_OW 272
26527: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26528: LD_ADDR_VAR 0 3
26532: PUSH
26533: LD_VAR 0 1
26537: PPUSH
26538: CALL_OW 251
26542: PPUSH
26543: LD_VAR 0 4
26547: PPUSH
26548: LD_INT 3
26550: PPUSH
26551: LD_INT 12
26553: PPUSH
26554: CALL_OW 12
26558: PPUSH
26559: CALL_OW 273
26563: ST_TO_ADDR
// if ValidHex ( x , y ) then
26564: LD_VAR 0 2
26568: PPUSH
26569: LD_VAR 0 3
26573: PPUSH
26574: CALL_OW 488
26578: IFFALSE 26613
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26580: LD_VAR 0 1
26584: PPUSH
26585: LD_VAR 0 2
26589: PPUSH
26590: LD_VAR 0 3
26594: PPUSH
26595: LD_INT 3
26597: PPUSH
26598: LD_INT 6
26600: PPUSH
26601: CALL_OW 12
26605: PPUSH
26606: LD_INT 1
26608: PPUSH
26609: CALL_OW 483
// end ;
26613: GO 26473
26615: POP
26616: POP
// end ;
26617: PPOPN 5
26619: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26620: LD_EXP 55
26624: PUSH
26625: LD_EXP 90
26629: AND
26630: IFFALSE 26724
26632: GO 26634
26634: DISABLE
26635: LD_INT 0
26637: PPUSH
26638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
26639: LD_ADDR_VAR 0 2
26643: PUSH
26644: LD_INT 22
26646: PUSH
26647: LD_OWVAR 2
26651: PUSH
26652: EMPTY
26653: LIST
26654: LIST
26655: PUSH
26656: LD_INT 32
26658: PUSH
26659: LD_INT 1
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PUSH
26666: LD_INT 21
26668: PUSH
26669: LD_INT 2
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: LIST
26680: PPUSH
26681: CALL_OW 69
26685: ST_TO_ADDR
// if not tmp then
26686: LD_VAR 0 2
26690: NOT
26691: IFFALSE 26695
// exit ;
26693: GO 26724
// for i in tmp do
26695: LD_ADDR_VAR 0 1
26699: PUSH
26700: LD_VAR 0 2
26704: PUSH
26705: FOR_IN
26706: IFFALSE 26722
// SetFuel ( i , 0 ) ;
26708: LD_VAR 0 1
26712: PPUSH
26713: LD_INT 0
26715: PPUSH
26716: CALL_OW 240
26720: GO 26705
26722: POP
26723: POP
// end ;
26724: PPOPN 2
26726: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
26727: LD_EXP 55
26731: PUSH
26732: LD_EXP 91
26736: AND
26737: IFFALSE 26803
26739: GO 26741
26741: DISABLE
26742: LD_INT 0
26744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
26745: LD_ADDR_VAR 0 1
26749: PUSH
26750: LD_INT 22
26752: PUSH
26753: LD_OWVAR 2
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 30
26764: PUSH
26765: LD_INT 29
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PPUSH
26776: CALL_OW 69
26780: ST_TO_ADDR
// if not tmp then
26781: LD_VAR 0 1
26785: NOT
26786: IFFALSE 26790
// exit ;
26788: GO 26803
// DestroyUnit ( tmp [ 1 ] ) ;
26790: LD_VAR 0 1
26794: PUSH
26795: LD_INT 1
26797: ARRAY
26798: PPUSH
26799: CALL_OW 65
// end ;
26803: PPOPN 1
26805: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
26806: LD_EXP 55
26810: PUSH
26811: LD_EXP 93
26815: AND
26816: IFFALSE 26945
26818: GO 26820
26820: DISABLE
26821: LD_INT 0
26823: PPUSH
// begin uc_side := 0 ;
26824: LD_ADDR_OWVAR 20
26828: PUSH
26829: LD_INT 0
26831: ST_TO_ADDR
// uc_nation := nation_arabian ;
26832: LD_ADDR_OWVAR 21
26836: PUSH
26837: LD_INT 2
26839: ST_TO_ADDR
// hc_gallery :=  ;
26840: LD_ADDR_OWVAR 33
26844: PUSH
26845: LD_STRING 
26847: ST_TO_ADDR
// hc_name :=  ;
26848: LD_ADDR_OWVAR 26
26852: PUSH
26853: LD_STRING 
26855: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
26856: LD_INT 1
26858: PPUSH
26859: LD_INT 11
26861: PPUSH
26862: LD_INT 10
26864: PPUSH
26865: CALL_OW 380
// un := CreateHuman ;
26869: LD_ADDR_VAR 0 1
26873: PUSH
26874: CALL_OW 44
26878: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26879: LD_VAR 0 1
26883: PPUSH
26884: LD_INT 1
26886: PPUSH
26887: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26891: LD_INT 35
26893: PPUSH
26894: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26898: LD_VAR 0 1
26902: PPUSH
26903: LD_INT 22
26905: PUSH
26906: LD_OWVAR 2
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PPUSH
26915: CALL_OW 69
26919: PPUSH
26920: LD_VAR 0 1
26924: PPUSH
26925: CALL_OW 74
26929: PPUSH
26930: CALL_OW 115
// until IsDead ( un ) ;
26934: LD_VAR 0 1
26938: PPUSH
26939: CALL_OW 301
26943: IFFALSE 26891
// end ;
26945: PPOPN 1
26947: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
26948: LD_EXP 55
26952: PUSH
26953: LD_EXP 95
26957: AND
26958: IFFALSE 26970
26960: GO 26962
26962: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
26963: LD_STRING earthquake(getX(game), 0, 32)
26965: PPUSH
26966: CALL_OW 559
26970: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
26971: LD_EXP 55
26975: PUSH
26976: LD_EXP 96
26980: AND
26981: IFFALSE 27072
26983: GO 26985
26985: DISABLE
26986: LD_INT 0
26988: PPUSH
// begin enable ;
26989: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
26990: LD_ADDR_VAR 0 1
26994: PUSH
26995: LD_INT 22
26997: PUSH
26998: LD_OWVAR 2
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: PUSH
27007: LD_INT 21
27009: PUSH
27010: LD_INT 2
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: PUSH
27017: LD_INT 33
27019: PUSH
27020: LD_INT 3
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: LIST
27031: PPUSH
27032: CALL_OW 69
27036: ST_TO_ADDR
// if not tmp then
27037: LD_VAR 0 1
27041: NOT
27042: IFFALSE 27046
// exit ;
27044: GO 27072
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27046: LD_VAR 0 1
27050: PUSH
27051: LD_INT 1
27053: PPUSH
27054: LD_VAR 0 1
27058: PPUSH
27059: CALL_OW 12
27063: ARRAY
27064: PPUSH
27065: LD_INT 1
27067: PPUSH
27068: CALL_OW 234
// end ;
27072: PPOPN 1
27074: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27075: LD_EXP 55
27079: PUSH
27080: LD_EXP 97
27084: AND
27085: IFFALSE 27226
27087: GO 27089
27089: DISABLE
27090: LD_INT 0
27092: PPUSH
27093: PPUSH
27094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27095: LD_ADDR_VAR 0 3
27099: PUSH
27100: LD_INT 22
27102: PUSH
27103: LD_OWVAR 2
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 25
27114: PUSH
27115: LD_INT 1
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: PPUSH
27126: CALL_OW 69
27130: ST_TO_ADDR
// if not tmp then
27131: LD_VAR 0 3
27135: NOT
27136: IFFALSE 27140
// exit ;
27138: GO 27226
// un := tmp [ rand ( 1 , tmp ) ] ;
27140: LD_ADDR_VAR 0 2
27144: PUSH
27145: LD_VAR 0 3
27149: PUSH
27150: LD_INT 1
27152: PPUSH
27153: LD_VAR 0 3
27157: PPUSH
27158: CALL_OW 12
27162: ARRAY
27163: ST_TO_ADDR
// if Crawls ( un ) then
27164: LD_VAR 0 2
27168: PPUSH
27169: CALL_OW 318
27173: IFFALSE 27184
// ComWalk ( un ) ;
27175: LD_VAR 0 2
27179: PPUSH
27180: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27184: LD_VAR 0 2
27188: PPUSH
27189: LD_INT 9
27191: PPUSH
27192: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27196: LD_INT 28
27198: PPUSH
27199: LD_OWVAR 2
27203: PPUSH
27204: LD_INT 2
27206: PPUSH
27207: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27211: LD_INT 29
27213: PPUSH
27214: LD_OWVAR 2
27218: PPUSH
27219: LD_INT 2
27221: PPUSH
27222: CALL_OW 322
// end ;
27226: PPOPN 3
27228: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27229: LD_EXP 55
27233: PUSH
27234: LD_EXP 98
27238: AND
27239: IFFALSE 27350
27241: GO 27243
27243: DISABLE
27244: LD_INT 0
27246: PPUSH
27247: PPUSH
27248: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27249: LD_ADDR_VAR 0 3
27253: PUSH
27254: LD_INT 22
27256: PUSH
27257: LD_OWVAR 2
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 25
27268: PUSH
27269: LD_INT 1
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: PPUSH
27280: CALL_OW 69
27284: ST_TO_ADDR
// if not tmp then
27285: LD_VAR 0 3
27289: NOT
27290: IFFALSE 27294
// exit ;
27292: GO 27350
// un := tmp [ rand ( 1 , tmp ) ] ;
27294: LD_ADDR_VAR 0 2
27298: PUSH
27299: LD_VAR 0 3
27303: PUSH
27304: LD_INT 1
27306: PPUSH
27307: LD_VAR 0 3
27311: PPUSH
27312: CALL_OW 12
27316: ARRAY
27317: ST_TO_ADDR
// if Crawls ( un ) then
27318: LD_VAR 0 2
27322: PPUSH
27323: CALL_OW 318
27327: IFFALSE 27338
// ComWalk ( un ) ;
27329: LD_VAR 0 2
27333: PPUSH
27334: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27338: LD_VAR 0 2
27342: PPUSH
27343: LD_INT 8
27345: PPUSH
27346: CALL_OW 336
// end ;
27350: PPOPN 3
27352: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27353: LD_EXP 55
27357: PUSH
27358: LD_EXP 99
27362: AND
27363: IFFALSE 27507
27365: GO 27367
27367: DISABLE
27368: LD_INT 0
27370: PPUSH
27371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27372: LD_ADDR_VAR 0 2
27376: PUSH
27377: LD_INT 22
27379: PUSH
27380: LD_OWVAR 2
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 21
27391: PUSH
27392: LD_INT 2
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 2
27401: PUSH
27402: LD_INT 34
27404: PUSH
27405: LD_INT 12
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 34
27414: PUSH
27415: LD_INT 51
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 34
27424: PUSH
27425: LD_INT 32
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: LIST
27436: LIST
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: LIST
27442: PPUSH
27443: CALL_OW 69
27447: ST_TO_ADDR
// if not tmp then
27448: LD_VAR 0 2
27452: NOT
27453: IFFALSE 27457
// exit ;
27455: GO 27507
// for i in tmp do
27457: LD_ADDR_VAR 0 1
27461: PUSH
27462: LD_VAR 0 2
27466: PUSH
27467: FOR_IN
27468: IFFALSE 27505
// if GetCargo ( i , mat_artifact ) = 0 then
27470: LD_VAR 0 1
27474: PPUSH
27475: LD_INT 4
27477: PPUSH
27478: CALL_OW 289
27482: PUSH
27483: LD_INT 0
27485: EQUAL
27486: IFFALSE 27503
// SetCargo ( i , mat_siberit , 100 ) ;
27488: LD_VAR 0 1
27492: PPUSH
27493: LD_INT 3
27495: PPUSH
27496: LD_INT 100
27498: PPUSH
27499: CALL_OW 290
27503: GO 27467
27505: POP
27506: POP
// end ;
27507: PPOPN 2
27509: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27510: LD_EXP 55
27514: PUSH
27515: LD_EXP 100
27519: AND
27520: IFFALSE 27703
27522: GO 27524
27524: DISABLE
27525: LD_INT 0
27527: PPUSH
27528: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27529: LD_ADDR_VAR 0 2
27533: PUSH
27534: LD_INT 22
27536: PUSH
27537: LD_OWVAR 2
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PPUSH
27546: CALL_OW 69
27550: ST_TO_ADDR
// if not tmp then
27551: LD_VAR 0 2
27555: NOT
27556: IFFALSE 27560
// exit ;
27558: GO 27703
// for i := 1 to 2 do
27560: LD_ADDR_VAR 0 1
27564: PUSH
27565: DOUBLE
27566: LD_INT 1
27568: DEC
27569: ST_TO_ADDR
27570: LD_INT 2
27572: PUSH
27573: FOR_TO
27574: IFFALSE 27701
// begin uc_side := your_side ;
27576: LD_ADDR_OWVAR 20
27580: PUSH
27581: LD_OWVAR 2
27585: ST_TO_ADDR
// uc_nation := nation_american ;
27586: LD_ADDR_OWVAR 21
27590: PUSH
27591: LD_INT 1
27593: ST_TO_ADDR
// vc_chassis := us_morphling ;
27594: LD_ADDR_OWVAR 37
27598: PUSH
27599: LD_INT 5
27601: ST_TO_ADDR
// vc_engine := engine_siberite ;
27602: LD_ADDR_OWVAR 39
27606: PUSH
27607: LD_INT 3
27609: ST_TO_ADDR
// vc_control := control_computer ;
27610: LD_ADDR_OWVAR 38
27614: PUSH
27615: LD_INT 3
27617: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27618: LD_ADDR_OWVAR 40
27622: PUSH
27623: LD_INT 10
27625: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
27626: LD_VAR 0 2
27630: PUSH
27631: LD_INT 1
27633: ARRAY
27634: PPUSH
27635: CALL_OW 310
27639: NOT
27640: IFFALSE 27687
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
27642: CALL_OW 45
27646: PPUSH
27647: LD_VAR 0 2
27651: PUSH
27652: LD_INT 1
27654: ARRAY
27655: PPUSH
27656: CALL_OW 250
27660: PPUSH
27661: LD_VAR 0 2
27665: PUSH
27666: LD_INT 1
27668: ARRAY
27669: PPUSH
27670: CALL_OW 251
27674: PPUSH
27675: LD_INT 12
27677: PPUSH
27678: LD_INT 1
27680: PPUSH
27681: CALL_OW 50
27685: GO 27699
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
27687: CALL_OW 45
27691: PPUSH
27692: LD_INT 1
27694: PPUSH
27695: CALL_OW 51
// end ;
27699: GO 27573
27701: POP
27702: POP
// end ;
27703: PPOPN 2
27705: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
27706: LD_EXP 55
27710: PUSH
27711: LD_EXP 101
27715: AND
27716: IFFALSE 27938
27718: GO 27720
27720: DISABLE
27721: LD_INT 0
27723: PPUSH
27724: PPUSH
27725: PPUSH
27726: PPUSH
27727: PPUSH
27728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27729: LD_ADDR_VAR 0 6
27733: PUSH
27734: LD_INT 22
27736: PUSH
27737: LD_OWVAR 2
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 21
27748: PUSH
27749: LD_INT 1
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 3
27758: PUSH
27759: LD_INT 23
27761: PUSH
27762: LD_INT 0
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: LIST
27777: PPUSH
27778: CALL_OW 69
27782: ST_TO_ADDR
// if not tmp then
27783: LD_VAR 0 6
27787: NOT
27788: IFFALSE 27792
// exit ;
27790: GO 27938
// s1 := rand ( 1 , 4 ) ;
27792: LD_ADDR_VAR 0 2
27796: PUSH
27797: LD_INT 1
27799: PPUSH
27800: LD_INT 4
27802: PPUSH
27803: CALL_OW 12
27807: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
27808: LD_ADDR_VAR 0 4
27812: PUSH
27813: LD_VAR 0 6
27817: PUSH
27818: LD_INT 1
27820: ARRAY
27821: PPUSH
27822: LD_VAR 0 2
27826: PPUSH
27827: CALL_OW 259
27831: ST_TO_ADDR
// if s1 = 1 then
27832: LD_VAR 0 2
27836: PUSH
27837: LD_INT 1
27839: EQUAL
27840: IFFALSE 27860
// s2 := rand ( 2 , 4 ) else
27842: LD_ADDR_VAR 0 3
27846: PUSH
27847: LD_INT 2
27849: PPUSH
27850: LD_INT 4
27852: PPUSH
27853: CALL_OW 12
27857: ST_TO_ADDR
27858: GO 27868
// s2 := 1 ;
27860: LD_ADDR_VAR 0 3
27864: PUSH
27865: LD_INT 1
27867: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
27868: LD_ADDR_VAR 0 5
27872: PUSH
27873: LD_VAR 0 6
27877: PUSH
27878: LD_INT 1
27880: ARRAY
27881: PPUSH
27882: LD_VAR 0 3
27886: PPUSH
27887: CALL_OW 259
27891: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
27892: LD_VAR 0 6
27896: PUSH
27897: LD_INT 1
27899: ARRAY
27900: PPUSH
27901: LD_VAR 0 2
27905: PPUSH
27906: LD_VAR 0 5
27910: PPUSH
27911: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
27915: LD_VAR 0 6
27919: PUSH
27920: LD_INT 1
27922: ARRAY
27923: PPUSH
27924: LD_VAR 0 3
27928: PPUSH
27929: LD_VAR 0 4
27933: PPUSH
27934: CALL_OW 237
// end ;
27938: PPOPN 6
27940: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
27941: LD_EXP 55
27945: PUSH
27946: LD_EXP 102
27950: AND
27951: IFFALSE 28030
27953: GO 27955
27955: DISABLE
27956: LD_INT 0
27958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
27959: LD_ADDR_VAR 0 1
27963: PUSH
27964: LD_INT 22
27966: PUSH
27967: LD_OWVAR 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 30
27978: PUSH
27979: LD_INT 3
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: EMPTY
27987: LIST
27988: LIST
27989: PPUSH
27990: CALL_OW 69
27994: ST_TO_ADDR
// if not tmp then
27995: LD_VAR 0 1
27999: NOT
28000: IFFALSE 28004
// exit ;
28002: GO 28030
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28004: LD_VAR 0 1
28008: PUSH
28009: LD_INT 1
28011: PPUSH
28012: LD_VAR 0 1
28016: PPUSH
28017: CALL_OW 12
28021: ARRAY
28022: PPUSH
28023: LD_INT 1
28025: PPUSH
28026: CALL_OW 234
// end ;
28030: PPOPN 1
28032: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28033: LD_EXP 55
28037: PUSH
28038: LD_EXP 103
28042: AND
28043: IFFALSE 28155
28045: GO 28047
28047: DISABLE
28048: LD_INT 0
28050: PPUSH
28051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28052: LD_ADDR_VAR 0 2
28056: PUSH
28057: LD_INT 22
28059: PUSH
28060: LD_OWVAR 2
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 2
28071: PUSH
28072: LD_INT 30
28074: PUSH
28075: LD_INT 27
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 30
28084: PUSH
28085: LD_INT 26
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 30
28094: PUSH
28095: LD_INT 28
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PPUSH
28112: CALL_OW 69
28116: ST_TO_ADDR
// if not tmp then
28117: LD_VAR 0 2
28121: NOT
28122: IFFALSE 28126
// exit ;
28124: GO 28155
// for i in tmp do
28126: LD_ADDR_VAR 0 1
28130: PUSH
28131: LD_VAR 0 2
28135: PUSH
28136: FOR_IN
28137: IFFALSE 28153
// SetLives ( i , 1 ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: LD_INT 1
28146: PPUSH
28147: CALL_OW 234
28151: GO 28136
28153: POP
28154: POP
// end ;
28155: PPOPN 2
28157: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28158: LD_EXP 55
28162: PUSH
28163: LD_EXP 104
28167: AND
28168: IFFALSE 28442
28170: GO 28172
28172: DISABLE
28173: LD_INT 0
28175: PPUSH
28176: PPUSH
28177: PPUSH
// begin i := rand ( 1 , 7 ) ;
28178: LD_ADDR_VAR 0 1
28182: PUSH
28183: LD_INT 1
28185: PPUSH
28186: LD_INT 7
28188: PPUSH
28189: CALL_OW 12
28193: ST_TO_ADDR
// case i of 1 :
28194: LD_VAR 0 1
28198: PUSH
28199: LD_INT 1
28201: DOUBLE
28202: EQUAL
28203: IFTRUE 28207
28205: GO 28217
28207: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28208: LD_STRING earthquake(getX(game), 0, 32)
28210: PPUSH
28211: CALL_OW 559
28215: GO 28442
28217: LD_INT 2
28219: DOUBLE
28220: EQUAL
28221: IFTRUE 28225
28223: GO 28239
28225: POP
// begin ToLua ( displayStucuk(); ) ;
28226: LD_STRING displayStucuk();
28228: PPUSH
28229: CALL_OW 559
// ResetFog ;
28233: CALL_OW 335
// end ; 3 :
28237: GO 28442
28239: LD_INT 3
28241: DOUBLE
28242: EQUAL
28243: IFTRUE 28247
28245: GO 28351
28247: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28248: LD_ADDR_VAR 0 2
28252: PUSH
28253: LD_INT 22
28255: PUSH
28256: LD_OWVAR 2
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 25
28267: PUSH
28268: LD_INT 1
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PPUSH
28279: CALL_OW 69
28283: ST_TO_ADDR
// if not tmp then
28284: LD_VAR 0 2
28288: NOT
28289: IFFALSE 28293
// exit ;
28291: GO 28442
// un := tmp [ rand ( 1 , tmp ) ] ;
28293: LD_ADDR_VAR 0 3
28297: PUSH
28298: LD_VAR 0 2
28302: PUSH
28303: LD_INT 1
28305: PPUSH
28306: LD_VAR 0 2
28310: PPUSH
28311: CALL_OW 12
28315: ARRAY
28316: ST_TO_ADDR
// if Crawls ( un ) then
28317: LD_VAR 0 3
28321: PPUSH
28322: CALL_OW 318
28326: IFFALSE 28337
// ComWalk ( un ) ;
28328: LD_VAR 0 3
28332: PPUSH
28333: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28337: LD_VAR 0 3
28341: PPUSH
28342: LD_INT 8
28344: PPUSH
28345: CALL_OW 336
// end ; 4 :
28349: GO 28442
28351: LD_INT 4
28353: DOUBLE
28354: EQUAL
28355: IFTRUE 28359
28357: GO 28420
28359: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28360: LD_ADDR_VAR 0 2
28364: PUSH
28365: LD_INT 22
28367: PUSH
28368: LD_OWVAR 2
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: LD_INT 30
28379: PUSH
28380: LD_INT 29
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PPUSH
28391: CALL_OW 69
28395: ST_TO_ADDR
// if not tmp then
28396: LD_VAR 0 2
28400: NOT
28401: IFFALSE 28405
// exit ;
28403: GO 28442
// DestroyUnit ( tmp [ 1 ] ) ;
28405: LD_VAR 0 2
28409: PUSH
28410: LD_INT 1
28412: ARRAY
28413: PPUSH
28414: CALL_OW 65
// end ; 5 .. 7 :
28418: GO 28442
28420: LD_INT 5
28422: DOUBLE
28423: GREATEREQUAL
28424: IFFALSE 28432
28426: LD_INT 7
28428: DOUBLE
28429: LESSEQUAL
28430: IFTRUE 28434
28432: GO 28441
28434: POP
// StreamSibBomb ; end ;
28435: CALL 24692 0 0
28439: GO 28442
28441: POP
// end ;
28442: PPOPN 3
28444: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28445: LD_EXP 55
28449: PUSH
28450: LD_EXP 105
28454: AND
28455: IFFALSE 28611
28457: GO 28459
28459: DISABLE
28460: LD_INT 0
28462: PPUSH
28463: PPUSH
28464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28465: LD_ADDR_VAR 0 2
28469: PUSH
28470: LD_INT 81
28472: PUSH
28473: LD_OWVAR 2
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 2
28484: PUSH
28485: LD_INT 21
28487: PUSH
28488: LD_INT 1
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 21
28497: PUSH
28498: LD_INT 2
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PPUSH
28514: CALL_OW 69
28518: ST_TO_ADDR
// if not tmp then
28519: LD_VAR 0 2
28523: NOT
28524: IFFALSE 28528
// exit ;
28526: GO 28611
// p := 0 ;
28528: LD_ADDR_VAR 0 3
28532: PUSH
28533: LD_INT 0
28535: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28536: LD_INT 35
28538: PPUSH
28539: CALL_OW 67
// p := p + 1 ;
28543: LD_ADDR_VAR 0 3
28547: PUSH
28548: LD_VAR 0 3
28552: PUSH
28553: LD_INT 1
28555: PLUS
28556: ST_TO_ADDR
// for i in tmp do
28557: LD_ADDR_VAR 0 1
28561: PUSH
28562: LD_VAR 0 2
28566: PUSH
28567: FOR_IN
28568: IFFALSE 28599
// if GetLives ( i ) < 1000 then
28570: LD_VAR 0 1
28574: PPUSH
28575: CALL_OW 256
28579: PUSH
28580: LD_INT 1000
28582: LESS
28583: IFFALSE 28597
// SetLives ( i , 1000 ) ;
28585: LD_VAR 0 1
28589: PPUSH
28590: LD_INT 1000
28592: PPUSH
28593: CALL_OW 234
28597: GO 28567
28599: POP
28600: POP
// until p > 20 ;
28601: LD_VAR 0 3
28605: PUSH
28606: LD_INT 20
28608: GREATER
28609: IFFALSE 28536
// end ;
28611: PPOPN 3
28613: END
// every 0 0$1 trigger StreamModeActive and sTime do
28614: LD_EXP 55
28618: PUSH
28619: LD_EXP 106
28623: AND
28624: IFFALSE 28659
28626: GO 28628
28628: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28629: LD_INT 28
28631: PPUSH
28632: LD_OWVAR 2
28636: PPUSH
28637: LD_INT 2
28639: PPUSH
28640: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28644: LD_INT 30
28646: PPUSH
28647: LD_OWVAR 2
28651: PPUSH
28652: LD_INT 2
28654: PPUSH
28655: CALL_OW 322
// end ;
28659: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28660: LD_EXP 55
28664: PUSH
28665: LD_EXP 107
28669: AND
28670: IFFALSE 28791
28672: GO 28674
28674: DISABLE
28675: LD_INT 0
28677: PPUSH
28678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28679: LD_ADDR_VAR 0 2
28683: PUSH
28684: LD_INT 22
28686: PUSH
28687: LD_OWVAR 2
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: PUSH
28696: LD_INT 21
28698: PUSH
28699: LD_INT 1
28701: PUSH
28702: EMPTY
28703: LIST
28704: LIST
28705: PUSH
28706: LD_INT 3
28708: PUSH
28709: LD_INT 23
28711: PUSH
28712: LD_INT 0
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: LIST
28727: PPUSH
28728: CALL_OW 69
28732: ST_TO_ADDR
// if not tmp then
28733: LD_VAR 0 2
28737: NOT
28738: IFFALSE 28742
// exit ;
28740: GO 28791
// for i in tmp do
28742: LD_ADDR_VAR 0 1
28746: PUSH
28747: LD_VAR 0 2
28751: PUSH
28752: FOR_IN
28753: IFFALSE 28789
// begin if Crawls ( i ) then
28755: LD_VAR 0 1
28759: PPUSH
28760: CALL_OW 318
28764: IFFALSE 28775
// ComWalk ( i ) ;
28766: LD_VAR 0 1
28770: PPUSH
28771: CALL_OW 138
// SetClass ( i , 2 ) ;
28775: LD_VAR 0 1
28779: PPUSH
28780: LD_INT 2
28782: PPUSH
28783: CALL_OW 336
// end ;
28787: GO 28752
28789: POP
28790: POP
// end ;
28791: PPOPN 2
28793: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
28794: LD_EXP 55
28798: PUSH
28799: LD_EXP 108
28803: AND
28804: IFFALSE 29085
28806: GO 28808
28808: DISABLE
28809: LD_INT 0
28811: PPUSH
28812: PPUSH
28813: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
28814: LD_OWVAR 2
28818: PPUSH
28819: LD_INT 9
28821: PPUSH
28822: LD_INT 1
28824: PPUSH
28825: LD_INT 1
28827: PPUSH
28828: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
28832: LD_INT 9
28834: PPUSH
28835: LD_OWVAR 2
28839: PPUSH
28840: CALL_OW 343
// uc_side := 9 ;
28844: LD_ADDR_OWVAR 20
28848: PUSH
28849: LD_INT 9
28851: ST_TO_ADDR
// uc_nation := 2 ;
28852: LD_ADDR_OWVAR 21
28856: PUSH
28857: LD_INT 2
28859: ST_TO_ADDR
// hc_name := Dark Warrior ;
28860: LD_ADDR_OWVAR 26
28864: PUSH
28865: LD_STRING Dark Warrior
28867: ST_TO_ADDR
// hc_gallery :=  ;
28868: LD_ADDR_OWVAR 33
28872: PUSH
28873: LD_STRING 
28875: ST_TO_ADDR
// hc_noskilllimit := true ;
28876: LD_ADDR_OWVAR 76
28880: PUSH
28881: LD_INT 1
28883: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
28884: LD_ADDR_OWVAR 31
28888: PUSH
28889: LD_INT 30
28891: PUSH
28892: LD_INT 30
28894: PUSH
28895: LD_INT 30
28897: PUSH
28898: LD_INT 30
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: LIST
28905: LIST
28906: ST_TO_ADDR
// un := CreateHuman ;
28907: LD_ADDR_VAR 0 3
28911: PUSH
28912: CALL_OW 44
28916: ST_TO_ADDR
// hc_noskilllimit := false ;
28917: LD_ADDR_OWVAR 76
28921: PUSH
28922: LD_INT 0
28924: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28925: LD_VAR 0 3
28929: PPUSH
28930: LD_INT 1
28932: PPUSH
28933: CALL_OW 51
// p := 0 ;
28937: LD_ADDR_VAR 0 2
28941: PUSH
28942: LD_INT 0
28944: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28945: LD_INT 35
28947: PPUSH
28948: CALL_OW 67
// p := p + 1 ;
28952: LD_ADDR_VAR 0 2
28956: PUSH
28957: LD_VAR 0 2
28961: PUSH
28962: LD_INT 1
28964: PLUS
28965: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
28966: LD_VAR 0 3
28970: PPUSH
28971: CALL_OW 256
28975: PUSH
28976: LD_INT 1000
28978: LESS
28979: IFFALSE 28993
// SetLives ( un , 1000 ) ;
28981: LD_VAR 0 3
28985: PPUSH
28986: LD_INT 1000
28988: PPUSH
28989: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
28993: LD_VAR 0 3
28997: PPUSH
28998: LD_INT 81
29000: PUSH
29001: LD_OWVAR 2
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 91
29012: PUSH
29013: LD_VAR 0 3
29017: PUSH
29018: LD_INT 30
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: LIST
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PPUSH
29030: CALL_OW 69
29034: PPUSH
29035: LD_VAR 0 3
29039: PPUSH
29040: CALL_OW 74
29044: PPUSH
29045: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29049: LD_VAR 0 2
29053: PUSH
29054: LD_INT 60
29056: GREATER
29057: PUSH
29058: LD_VAR 0 3
29062: PPUSH
29063: CALL_OW 301
29067: OR
29068: IFFALSE 28945
// if un then
29070: LD_VAR 0 3
29074: IFFALSE 29085
// RemoveUnit ( un ) ;
29076: LD_VAR 0 3
29080: PPUSH
29081: CALL_OW 64
// end ; end_of_file
29085: PPOPN 3
29087: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29088: LD_INT 0
29090: PPUSH
29091: PPUSH
29092: PPUSH
29093: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29094: LD_VAR 0 1
29098: PPUSH
29099: CALL_OW 264
29103: PUSH
29104: LD_EXP 45
29108: EQUAL
29109: IFFALSE 29181
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29111: LD_INT 68
29113: PPUSH
29114: LD_VAR 0 1
29118: PPUSH
29119: CALL_OW 255
29123: PPUSH
29124: CALL_OW 321
29128: PUSH
29129: LD_INT 2
29131: EQUAL
29132: IFFALSE 29144
// eff := 70 else
29134: LD_ADDR_VAR 0 4
29138: PUSH
29139: LD_INT 70
29141: ST_TO_ADDR
29142: GO 29152
// eff := 30 ;
29144: LD_ADDR_VAR 0 4
29148: PUSH
29149: LD_INT 30
29151: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29152: LD_VAR 0 1
29156: PPUSH
29157: CALL_OW 250
29161: PPUSH
29162: LD_VAR 0 1
29166: PPUSH
29167: CALL_OW 251
29171: PPUSH
29172: LD_VAR 0 4
29176: PPUSH
29177: CALL_OW 495
// end ; end ;
29181: LD_VAR 0 2
29185: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29186: LD_INT 0
29188: PPUSH
// end ;
29189: LD_VAR 0 4
29193: RET
// export function SOS_Command ( cmd ) ; begin
29194: LD_INT 0
29196: PPUSH
// end ;
29197: LD_VAR 0 2
29201: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29202: LD_VAR 0 1
29206: PUSH
29207: LD_INT 255
29209: EQUAL
29210: PUSH
29211: LD_VAR 0 2
29215: PPUSH
29216: CALL_OW 264
29220: PUSH
29221: LD_INT 14
29223: PUSH
29224: LD_INT 53
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: IN
29231: AND
29232: PUSH
29233: LD_VAR 0 4
29237: PPUSH
29238: LD_VAR 0 5
29242: PPUSH
29243: CALL_OW 488
29247: AND
29248: IFFALSE 29272
// CutTreeXYR ( unit , x , y , 12 ) ;
29250: LD_VAR 0 2
29254: PPUSH
29255: LD_VAR 0 4
29259: PPUSH
29260: LD_VAR 0 5
29264: PPUSH
29265: LD_INT 12
29267: PPUSH
29268: CALL 29275 0 4
// end ;
29272: PPOPN 5
29274: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29275: LD_INT 0
29277: PPUSH
29278: PPUSH
29279: PPUSH
29280: PPUSH
29281: PPUSH
29282: PPUSH
29283: PPUSH
29284: PPUSH
29285: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29286: LD_VAR 0 1
29290: NOT
29291: PUSH
29292: LD_VAR 0 2
29296: PPUSH
29297: LD_VAR 0 3
29301: PPUSH
29302: CALL_OW 488
29306: NOT
29307: OR
29308: PUSH
29309: LD_VAR 0 4
29313: NOT
29314: OR
29315: IFFALSE 29319
// exit ;
29317: GO 29659
// list := [ ] ;
29319: LD_ADDR_VAR 0 13
29323: PUSH
29324: EMPTY
29325: ST_TO_ADDR
// if x - r < 0 then
29326: LD_VAR 0 2
29330: PUSH
29331: LD_VAR 0 4
29335: MINUS
29336: PUSH
29337: LD_INT 0
29339: LESS
29340: IFFALSE 29352
// min_x := 0 else
29342: LD_ADDR_VAR 0 7
29346: PUSH
29347: LD_INT 0
29349: ST_TO_ADDR
29350: GO 29368
// min_x := x - r ;
29352: LD_ADDR_VAR 0 7
29356: PUSH
29357: LD_VAR 0 2
29361: PUSH
29362: LD_VAR 0 4
29366: MINUS
29367: ST_TO_ADDR
// if y - r < 0 then
29368: LD_VAR 0 3
29372: PUSH
29373: LD_VAR 0 4
29377: MINUS
29378: PUSH
29379: LD_INT 0
29381: LESS
29382: IFFALSE 29394
// min_y := 0 else
29384: LD_ADDR_VAR 0 8
29388: PUSH
29389: LD_INT 0
29391: ST_TO_ADDR
29392: GO 29410
// min_y := y - r ;
29394: LD_ADDR_VAR 0 8
29398: PUSH
29399: LD_VAR 0 3
29403: PUSH
29404: LD_VAR 0 4
29408: MINUS
29409: ST_TO_ADDR
// max_x := x + r ;
29410: LD_ADDR_VAR 0 9
29414: PUSH
29415: LD_VAR 0 2
29419: PUSH
29420: LD_VAR 0 4
29424: PLUS
29425: ST_TO_ADDR
// max_y := y + r ;
29426: LD_ADDR_VAR 0 10
29430: PUSH
29431: LD_VAR 0 3
29435: PUSH
29436: LD_VAR 0 4
29440: PLUS
29441: ST_TO_ADDR
// for _x = min_x to max_x do
29442: LD_ADDR_VAR 0 11
29446: PUSH
29447: DOUBLE
29448: LD_VAR 0 7
29452: DEC
29453: ST_TO_ADDR
29454: LD_VAR 0 9
29458: PUSH
29459: FOR_TO
29460: IFFALSE 29577
// for _y = min_y to max_y do
29462: LD_ADDR_VAR 0 12
29466: PUSH
29467: DOUBLE
29468: LD_VAR 0 8
29472: DEC
29473: ST_TO_ADDR
29474: LD_VAR 0 10
29478: PUSH
29479: FOR_TO
29480: IFFALSE 29573
// begin if not ValidHex ( _x , _y ) then
29482: LD_VAR 0 11
29486: PPUSH
29487: LD_VAR 0 12
29491: PPUSH
29492: CALL_OW 488
29496: NOT
29497: IFFALSE 29501
// continue ;
29499: GO 29479
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29501: LD_VAR 0 11
29505: PPUSH
29506: LD_VAR 0 12
29510: PPUSH
29511: CALL_OW 351
29515: PUSH
29516: LD_VAR 0 11
29520: PPUSH
29521: LD_VAR 0 12
29525: PPUSH
29526: CALL_OW 554
29530: AND
29531: IFFALSE 29571
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29533: LD_ADDR_VAR 0 13
29537: PUSH
29538: LD_VAR 0 13
29542: PPUSH
29543: LD_VAR 0 13
29547: PUSH
29548: LD_INT 1
29550: PLUS
29551: PPUSH
29552: LD_VAR 0 11
29556: PUSH
29557: LD_VAR 0 12
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PPUSH
29566: CALL_OW 2
29570: ST_TO_ADDR
// end ;
29571: GO 29479
29573: POP
29574: POP
29575: GO 29459
29577: POP
29578: POP
// if not list then
29579: LD_VAR 0 13
29583: NOT
29584: IFFALSE 29588
// exit ;
29586: GO 29659
// for i in list do
29588: LD_ADDR_VAR 0 6
29592: PUSH
29593: LD_VAR 0 13
29597: PUSH
29598: FOR_IN
29599: IFFALSE 29657
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29601: LD_VAR 0 1
29605: PPUSH
29606: LD_STRING M
29608: PUSH
29609: LD_VAR 0 6
29613: PUSH
29614: LD_INT 1
29616: ARRAY
29617: PUSH
29618: LD_VAR 0 6
29622: PUSH
29623: LD_INT 2
29625: ARRAY
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: LD_INT 0
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: PUSH
29648: EMPTY
29649: LIST
29650: PPUSH
29651: CALL_OW 447
29655: GO 29598
29657: POP
29658: POP
// end ;
29659: LD_VAR 0 5
29663: RET
