// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 209 0 0
// PrepareNature ;
  23: CALL 384 0 0
// PrepareRussian ;
  27: CALL 13259 0 0
// PrepareAmerican ;
  31: CALL 1117 0 0
// PrepareOvsyenko ;
  35: CALL 1740 0 0
// Action ;
  39: CALL 2680 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := false ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// end ;
 204: LD_VAR 0 1
 208: RET
// function DebugMode ; begin
 209: LD_INT 0
 211: PPUSH
// if not debug then
 212: LD_EXP 2
 216: NOT
 217: IFFALSE 221
// exit ;
 219: GO 228
// FogOff ( 1 ) ;
 221: LD_INT 1
 223: PPUSH
 224: CALL_OW 344
// end ; end_of_file
 228: LD_VAR 0 1
 232: RET
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 233: LD_INT 0
 235: PPUSH
 236: PPUSH
// if exist_mode then
 237: LD_VAR 0 2
 241: IFFALSE 266
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 243: LD_ADDR_VAR 0 5
 247: PUSH
 248: LD_VAR 0 3
 252: PUSH
 253: LD_VAR 0 1
 257: STR
 258: PPUSH
 259: CALL_OW 34
 263: ST_TO_ADDR
 264: GO 281
// unit := NewCharacter ( ident ) ;
 266: LD_ADDR_VAR 0 5
 270: PUSH
 271: LD_VAR 0 1
 275: PPUSH
 276: CALL_OW 25
 280: ST_TO_ADDR
// result := unit ;
 281: LD_ADDR_VAR 0 4
 285: PUSH
 286: LD_VAR 0 5
 290: ST_TO_ADDR
// end ;
 291: LD_VAR 0 4
 295: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 296: LD_INT 0
 298: PPUSH
// uc_side := side ;
 299: LD_ADDR_OWVAR 20
 303: PUSH
 304: LD_VAR 0 1
 308: ST_TO_ADDR
// uc_nation := nation ;
 309: LD_ADDR_OWVAR 21
 313: PUSH
 314: LD_VAR 0 2
 318: ST_TO_ADDR
// vc_chassis := chassis ;
 319: LD_ADDR_OWVAR 37
 323: PUSH
 324: LD_VAR 0 3
 328: ST_TO_ADDR
// vc_engine := engine ;
 329: LD_ADDR_OWVAR 39
 333: PUSH
 334: LD_VAR 0 4
 338: ST_TO_ADDR
// vc_control := control ;
 339: LD_ADDR_OWVAR 38
 343: PUSH
 344: LD_VAR 0 5
 348: ST_TO_ADDR
// vc_weapon := weapon ;
 349: LD_ADDR_OWVAR 40
 353: PUSH
 354: LD_VAR 0 6
 358: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 359: LD_ADDR_OWVAR 41
 363: PUSH
 364: LD_VAR 0 7
 368: ST_TO_ADDR
// result := CreateVehicle ;
 369: LD_ADDR_VAR 0 8
 373: PUSH
 374: CALL_OW 45
 378: ST_TO_ADDR
// end ;
 379: LD_VAR 0 8
 383: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 384: LD_INT 0
 386: PPUSH
 387: PPUSH
 388: PPUSH
 389: PPUSH
// uc_side = 0 ;
 390: LD_ADDR_OWVAR 20
 394: PUSH
 395: LD_INT 0
 397: ST_TO_ADDR
// uc_nation = 0 ;
 398: LD_ADDR_OWVAR 21
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// nat_area := natureArea ;
 406: LD_ADDR_VAR 0 4
 410: PUSH
 411: LD_INT 1
 413: ST_TO_ADDR
// InitHc ;
 414: CALL_OW 19
// for i = 1 to 4 do
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: DOUBLE
 424: LD_INT 1
 426: DEC
 427: ST_TO_ADDR
 428: LD_INT 4
 430: PUSH
 431: FOR_TO
 432: IFFALSE 487
// begin hc_class = 18 ;
 434: LD_ADDR_OWVAR 28
 438: PUSH
 439: LD_INT 18
 441: ST_TO_ADDR
// hc_gallery =  ;
 442: LD_ADDR_OWVAR 33
 446: PUSH
 447: LD_STRING 
 449: ST_TO_ADDR
// hc_face_number = 1 ;
 450: LD_ADDR_OWVAR 34
 454: PUSH
 455: LD_INT 1
 457: ST_TO_ADDR
// animal := CreateHuman ;
 458: LD_ADDR_VAR 0 3
 462: PUSH
 463: CALL_OW 44
 467: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 468: LD_VAR 0 3
 472: PPUSH
 473: LD_VAR 0 4
 477: PPUSH
 478: LD_INT 0
 480: PPUSH
 481: CALL_OW 49
// end ;
 485: GO 431
 487: POP
 488: POP
// for i = 1 to 4 do
 489: LD_ADDR_VAR 0 2
 493: PUSH
 494: DOUBLE
 495: LD_INT 1
 497: DEC
 498: ST_TO_ADDR
 499: LD_INT 4
 501: PUSH
 502: FOR_TO
 503: IFFALSE 575
// begin hc_class = class_tiger ;
 505: LD_ADDR_OWVAR 28
 509: PUSH
 510: LD_INT 14
 512: ST_TO_ADDR
// hc_gallery =  ;
 513: LD_ADDR_OWVAR 33
 517: PUSH
 518: LD_STRING 
 520: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 521: LD_ADDR_OWVAR 35
 525: PUSH
 526: LD_INT 5
 528: NEG
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL_OW 12
 537: ST_TO_ADDR
// hc_face_number = 3 ;
 538: LD_ADDR_OWVAR 34
 542: PUSH
 543: LD_INT 3
 545: ST_TO_ADDR
// animal := CreateHuman ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: CALL_OW 44
 555: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 556: LD_VAR 0 3
 560: PPUSH
 561: LD_VAR 0 4
 565: PPUSH
 566: LD_INT 0
 568: PPUSH
 569: CALL_OW 49
// end ;
 573: GO 502
 575: POP
 576: POP
// for i = 1 to 8 do
 577: LD_ADDR_VAR 0 2
 581: PUSH
 582: DOUBLE
 583: LD_INT 1
 585: DEC
 586: ST_TO_ADDR
 587: LD_INT 8
 589: PUSH
 590: FOR_TO
 591: IFFALSE 694
// begin hc_class = class_apeman ;
 593: LD_ADDR_OWVAR 28
 597: PUSH
 598: LD_INT 12
 600: ST_TO_ADDR
// hc_gallery =  ;
 601: LD_ADDR_OWVAR 33
 605: PUSH
 606: LD_STRING 
 608: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 609: LD_ADDR_OWVAR 35
 613: PUSH
 614: LD_INT 2
 616: NEG
 617: PPUSH
 618: LD_INT 2
 620: PPUSH
 621: CALL_OW 12
 625: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 626: LD_ADDR_OWVAR 31
 630: PUSH
 631: LD_INT 1
 633: PPUSH
 634: LD_INT 3
 636: PPUSH
 637: CALL_OW 12
 641: PUSH
 642: LD_INT 1
 644: PPUSH
 645: LD_INT 3
 647: PPUSH
 648: CALL_OW 12
 652: PUSH
 653: LD_INT 0
 655: PUSH
 656: LD_INT 0
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: ST_TO_ADDR
// animal := CreateHuman ;
 665: LD_ADDR_VAR 0 3
 669: PUSH
 670: CALL_OW 44
 674: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 675: LD_VAR 0 3
 679: PPUSH
 680: LD_VAR 0 4
 684: PPUSH
 685: LD_INT 0
 687: PPUSH
 688: CALL_OW 49
// end ;
 692: GO 590
 694: POP
 695: POP
// for i = 1 to 6 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 6
 708: PUSH
 709: FOR_TO
 710: IFFALSE 765
// begin hc_class = 13 ;
 712: LD_ADDR_OWVAR 28
 716: PUSH
 717: LD_INT 13
 719: ST_TO_ADDR
// hc_gallery =  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// hc_face_number = 4 ;
 728: LD_ADDR_OWVAR 34
 732: PUSH
 733: LD_INT 4
 735: ST_TO_ADDR
// animal := CreateHuman ;
 736: LD_ADDR_VAR 0 3
 740: PUSH
 741: CALL_OW 44
 745: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 746: LD_VAR 0 3
 750: PPUSH
 751: LD_VAR 0 4
 755: PPUSH
 756: LD_INT 0
 758: PPUSH
 759: CALL_OW 49
// end ;
 763: GO 709
 765: POP
 766: POP
// vc_chassis := 31 ;
 767: LD_ADDR_OWVAR 37
 771: PUSH
 772: LD_INT 31
 774: ST_TO_ADDR
// vc_control := control_rider ;
 775: LD_ADDR_OWVAR 38
 779: PUSH
 780: LD_INT 4
 782: ST_TO_ADDR
// animal := CreateVehicle ;
 783: LD_ADDR_VAR 0 3
 787: PUSH
 788: CALL_OW 45
 792: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 793: LD_VAR 0 3
 797: PPUSH
 798: LD_INT 21
 800: PPUSH
 801: LD_INT 22
 803: PPUSH
 804: LD_INT 0
 806: PPUSH
 807: CALL_OW 48
// end ;
 811: LD_VAR 0 1
 815: RET
// export function GetTerminalCargo ; begin
 816: LD_INT 0
 818: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 819: LD_ADDR_VAR 0 1
 823: PUSH
 824: LD_EXP 3
 828: PPUSH
 829: CALL_OW 274
 833: PPUSH
 834: LD_INT 3
 836: PPUSH
 837: CALL_OW 275
 841: ST_TO_ADDR
// end ;
 842: LD_VAR 0 1
 846: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 847: LD_INT 0
 849: PPUSH
 850: PPUSH
 851: PPUSH
// result := 0 ;
 852: LD_ADDR_VAR 0 2
 856: PUSH
 857: LD_INT 0
 859: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 860: LD_ADDR_VAR 0 4
 864: PUSH
 865: LD_INT 22
 867: PUSH
 868: LD_VAR 0 1
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 30
 882: PUSH
 883: LD_INT 0
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 30
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: LIST
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: PPUSH
 909: CALL_OW 69
 913: ST_TO_ADDR
// if not tmp then
 914: LD_VAR 0 4
 918: NOT
 919: IFFALSE 923
// exit ;
 921: GO 969
// for i in tmp do
 923: LD_ADDR_VAR 0 3
 927: PUSH
 928: LD_VAR 0 4
 932: PUSH
 933: FOR_IN
 934: IFFALSE 967
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
 936: LD_ADDR_VAR 0 2
 940: PUSH
 941: LD_VAR 0 2
 945: PUSH
 946: LD_VAR 0 3
 950: PPUSH
 951: CALL_OW 274
 955: PPUSH
 956: LD_INT 3
 958: PPUSH
 959: CALL_OW 275
 963: PLUS
 964: ST_TO_ADDR
 965: GO 933
 967: POP
 968: POP
// end ;
 969: LD_VAR 0 2
 973: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
// area = ListEnvironmentArea ( area ) ;
 978: LD_ADDR_VAR 0 2
 982: PUSH
 983: LD_VAR 0 2
 987: PPUSH
 988: CALL_OW 353
 992: ST_TO_ADDR
// if bulldozer > 0 then
 993: LD_VAR 0 1
 997: PUSH
 998: LD_INT 0
1000: GREATER
1001: IFFALSE 1112
// for i = area downto 1 do
1003: LD_ADDR_VAR 0 4
1007: PUSH
1008: DOUBLE
1009: LD_VAR 0 2
1013: INC
1014: ST_TO_ADDR
1015: LD_INT 1
1017: PUSH
1018: FOR_DOWNTO
1019: IFFALSE 1110
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1021: LD_VAR 0 2
1025: PUSH
1026: LD_VAR 0 4
1030: ARRAY
1031: PUSH
1032: LD_INT 1
1034: ARRAY
1035: PPUSH
1036: LD_VAR 0 2
1040: PUSH
1041: LD_VAR 0 4
1045: ARRAY
1046: PUSH
1047: LD_INT 2
1049: ARRAY
1050: PPUSH
1051: CALL_OW 351
1055: IFFALSE 1108
// if not HasTask ( bulldozer ) then
1057: LD_VAR 0 1
1061: PPUSH
1062: CALL_OW 314
1066: NOT
1067: IFFALSE 1108
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1069: LD_VAR 0 1
1073: PPUSH
1074: LD_VAR 0 2
1078: PUSH
1079: LD_VAR 0 4
1083: ARRAY
1084: PUSH
1085: LD_INT 1
1087: ARRAY
1088: PPUSH
1089: LD_VAR 0 2
1093: PUSH
1094: LD_VAR 0 4
1098: ARRAY
1099: PUSH
1100: LD_INT 2
1102: ARRAY
1103: PPUSH
1104: CALL_OW 171
1108: GO 1018
1110: POP
1111: POP
// end ; end_of_file
1112: LD_VAR 0 3
1116: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1117: LD_INT 0
1119: PPUSH
1120: PPUSH
1121: PPUSH
1122: PPUSH
1123: PPUSH
// uc_side := 1 ;
1124: LD_ADDR_OWVAR 20
1128: PUSH
1129: LD_INT 1
1131: ST_TO_ADDR
// uc_nation := 1 ;
1132: LD_ADDR_OWVAR 21
1136: PUSH
1137: LD_INT 1
1139: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1140: LD_ADDR_EXP 19
1144: PUSH
1145: LD_STRING JMM
1147: PPUSH
1148: LD_EXP 2
1152: NOT
1153: PPUSH
1154: LD_STRING 08_
1156: PPUSH
1157: CALL 233 0 3
1161: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1162: LD_ADDR_VAR 0 4
1166: PUSH
1167: LD_INT 1
1169: PPUSH
1170: LD_INT 1
1172: PPUSH
1173: LD_INT 3
1175: PPUSH
1176: LD_INT 2
1178: PPUSH
1179: LD_INT 1
1181: PPUSH
1182: LD_INT 5
1184: PPUSH
1185: LD_INT 55
1187: PPUSH
1188: CALL 296 0 7
1192: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1193: LD_VAR 0 4
1197: PPUSH
1198: LD_INT 3
1200: PPUSH
1201: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1205: LD_VAR 0 4
1209: PPUSH
1210: LD_INT 43
1212: PPUSH
1213: LD_INT 3
1215: PPUSH
1216: LD_INT 0
1218: PPUSH
1219: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1223: LD_EXP 19
1227: PPUSH
1228: LD_VAR 0 4
1232: PPUSH
1233: CALL_OW 52
// tmp := [ ] ;
1237: LD_ADDR_VAR 0 2
1241: PUSH
1242: EMPTY
1243: ST_TO_ADDR
// uc_side := 4 ;
1244: LD_ADDR_OWVAR 20
1248: PUSH
1249: LD_INT 4
1251: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1252: LD_ADDR_OWVAR 33
1256: PUSH
1257: LD_STRING SecondCharsGal
1259: ST_TO_ADDR
// hc_class := 2 ;
1260: LD_ADDR_OWVAR 28
1264: PUSH
1265: LD_INT 2
1267: ST_TO_ADDR
// hc_sex := sex_female ;
1268: LD_ADDR_OWVAR 27
1272: PUSH
1273: LD_INT 2
1275: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1276: LD_ADDR_OWVAR 30
1280: PUSH
1281: LD_INT 0
1283: PUSH
1284: LD_INT 1
1286: PUSH
1287: LD_INT 1
1289: PUSH
1290: LD_INT 0
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1299: LD_ADDR_OWVAR 31
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: LD_INT 4
1309: PUSH
1310: LD_INT 2
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: EMPTY
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1322: LD_ADDR_OWVAR 29
1326: PUSH
1327: LD_INT 10
1329: PUSH
1330: LD_INT 11
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1337: LD_ADDR_OWVAR 26
1341: PUSH
1342: LD_STRING Naoma Goichman
1344: ST_TO_ADDR
// hc_face_number := 43 ;
1345: LD_ADDR_OWVAR 34
1349: PUSH
1350: LD_INT 43
1352: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1353: LD_ADDR_VAR 0 2
1357: PUSH
1358: LD_VAR 0 2
1362: PUSH
1363: CALL_OW 44
1367: ADD
1368: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1369: LD_ADDR_OWVAR 30
1373: PUSH
1374: LD_INT 0
1376: PUSH
1377: LD_INT 2
1379: PUSH
1380: LD_INT 0
1382: PUSH
1383: LD_INT 1
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1392: LD_ADDR_OWVAR 31
1396: PUSH
1397: LD_INT 0
1399: PUSH
1400: LD_INT 5
1402: PUSH
1403: LD_INT 3
1405: PUSH
1406: LD_INT 1
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1415: LD_ADDR_OWVAR 29
1419: PUSH
1420: LD_INT 10
1422: PUSH
1423: LD_INT 10
1425: PUSH
1426: EMPTY
1427: LIST
1428: LIST
1429: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1430: LD_ADDR_OWVAR 26
1434: PUSH
1435: LD_STRING Magdalene Glance
1437: ST_TO_ADDR
// hc_face_number := 44 ;
1438: LD_ADDR_OWVAR 34
1442: PUSH
1443: LD_INT 44
1445: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1446: LD_ADDR_VAR 0 2
1450: PUSH
1451: LD_VAR 0 2
1455: PUSH
1456: CALL_OW 44
1460: ADD
1461: ST_TO_ADDR
// hc_sex := sex_male ;
1462: LD_ADDR_OWVAR 27
1466: PUSH
1467: LD_INT 1
1469: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1470: LD_ADDR_OWVAR 30
1474: PUSH
1475: LD_INT 2
1477: PUSH
1478: LD_INT 2
1480: PUSH
1481: LD_INT 0
1483: PUSH
1484: LD_INT 0
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1493: LD_ADDR_OWVAR 31
1497: PUSH
1498: LD_INT 3
1500: PUSH
1501: LD_INT 4
1503: PUSH
1504: LD_INT 1
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: EMPTY
1511: LIST
1512: LIST
1513: LIST
1514: LIST
1515: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1516: LD_ADDR_OWVAR 29
1520: PUSH
1521: LD_INT 12
1523: PUSH
1524: LD_INT 10
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: ST_TO_ADDR
// hc_name := Steve Holland ;
1531: LD_ADDR_OWVAR 26
1535: PUSH
1536: LD_STRING Steve Holland
1538: ST_TO_ADDR
// hc_face_number := 60 ;
1539: LD_ADDR_OWVAR 34
1543: PUSH
1544: LD_INT 60
1546: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1547: LD_ADDR_VAR 0 2
1551: PUSH
1552: LD_VAR 0 2
1556: PUSH
1557: CALL_OW 44
1561: ADD
1562: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1563: LD_ADDR_EXP 24
1567: PUSH
1568: LD_VAR 0 2
1572: PUSH
1573: LD_INT 0
1575: DIFF
1576: ST_TO_ADDR
// for un in alpha_engs do
1577: LD_ADDR_VAR 0 3
1581: PUSH
1582: LD_EXP 24
1586: PUSH
1587: FOR_IN
1588: IFFALSE 1613
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1590: LD_VAR 0 3
1594: PPUSH
1595: LD_INT 52
1597: PPUSH
1598: LD_INT 35
1600: PPUSH
1601: LD_INT 3
1603: PPUSH
1604: LD_INT 0
1606: PPUSH
1607: CALL_OW 50
1611: GO 1587
1613: POP
1614: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: DOUBLE
1621: LD_INT 1
1623: DEC
1624: ST_TO_ADDR
1625: LD_INT 1
1627: PUSH
1628: LD_STRING 06_crates_1
1630: PPUSH
1631: LD_INT 0
1633: PPUSH
1634: CALL_OW 30
1638: PLUS
1639: PUSH
1640: LD_INT 2
1642: MUL
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1671
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1647: LD_INT 1
1649: PPUSH
1650: LD_INT 5
1652: PPUSH
1653: LD_INT 56
1655: PPUSH
1656: LD_INT 40
1658: PPUSH
1659: LD_INT 2
1661: PPUSH
1662: LD_INT 0
1664: PPUSH
1665: CALL_OW 60
1669: GO 1644
1671: POP
1672: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1673: LD_STRING GammaCommander
1675: PPUSH
1676: LD_INT 0
1678: PPUSH
1679: CALL_OW 30
1683: PUSH
1684: LD_INT 3
1686: LESS
1687: IFFALSE 1708
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1689: LD_ADDR_EXP 23
1693: PUSH
1694: LD_STRING VanHouten
1696: PPUSH
1697: LD_INT 0
1699: PPUSH
1700: LD_STRING 
1702: PPUSH
1703: CALL 233 0 3
1707: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1708: LD_ADDR_EXP 26
1712: PUSH
1713: LD_STRING Powell
1715: PPUSH
1716: LD_INT 0
1718: PPUSH
1719: LD_STRING 
1721: PPUSH
1722: CALL 233 0 3
1726: ST_TO_ADDR
// InitHc ;
1727: CALL_OW 19
// InitUc ;
1731: CALL_OW 18
// end ;
1735: LD_VAR 0 1
1739: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1740: LD_INT 0
1742: PPUSH
1743: PPUSH
1744: PPUSH
1745: PPUSH
1746: PPUSH
// uc_side := 4 ;
1747: LD_ADDR_OWVAR 20
1751: PUSH
1752: LD_INT 4
1754: ST_TO_ADDR
// uc_nation := 3 ;
1755: LD_ADDR_OWVAR 21
1759: PUSH
1760: LD_INT 3
1762: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1763: LD_ADDR_VAR 0 4
1767: PUSH
1768: LD_STRING 09_ovsyenko_base
1770: PPUSH
1771: LD_INT 0
1773: PUSH
1774: LD_INT 101
1776: PUSH
1777: LD_INT 118
1779: PUSH
1780: LD_INT 2
1782: PUSH
1783: LD_INT 500
1785: PUSH
1786: EMPTY
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: PUSH
1793: LD_INT 31
1795: PUSH
1796: LD_INT 109
1798: PUSH
1799: LD_INT 114
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 500
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: PUSH
1815: LD_INT 31
1817: PUSH
1818: LD_INT 115
1820: PUSH
1821: LD_INT 132
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 500
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 31
1839: PUSH
1840: LD_INT 98
1842: PUSH
1843: LD_INT 120
1845: PUSH
1846: LD_INT 1
1848: PUSH
1849: LD_INT 500
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL_OW 30
1869: ST_TO_ADDR
// for i in tmp do
1870: LD_ADDR_VAR 0 2
1874: PUSH
1875: LD_VAR 0 4
1879: PUSH
1880: FOR_IN
1881: IFFALSE 2037
// begin bc_type := i [ 1 ] ;
1883: LD_ADDR_OWVAR 42
1887: PUSH
1888: LD_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: ARRAY
1896: ST_TO_ADDR
// bc_level := 3 ;
1897: LD_ADDR_OWVAR 43
1901: PUSH
1902: LD_INT 3
1904: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1905: LD_ADDR_VAR 0 3
1909: PUSH
1910: LD_VAR 0 2
1914: PUSH
1915: LD_INT 2
1917: ARRAY
1918: PPUSH
1919: LD_VAR 0 2
1923: PUSH
1924: LD_INT 3
1926: ARRAY
1927: PPUSH
1928: LD_VAR 0 2
1932: PUSH
1933: LD_INT 4
1935: ARRAY
1936: PPUSH
1937: CALL_OW 47
1941: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
1942: LD_VAR 0 3
1946: PPUSH
1947: CALL_OW 266
1951: PUSH
1952: LD_INT 0
1954: EQUAL
1955: IFFALSE 1989
// begin SetBName ( b , ovsyenko ) ;
1957: LD_VAR 0 3
1961: PPUSH
1962: LD_STRING ovsyenko
1964: PPUSH
1965: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
1969: LD_VAR 0 3
1973: PPUSH
1974: CALL_OW 274
1978: PPUSH
1979: LD_INT 1
1981: PPUSH
1982: LD_INT 50
1984: PPUSH
1985: CALL_OW 277
// end ; if i [ 5 ] < 250 then
1989: LD_VAR 0 2
1993: PUSH
1994: LD_INT 5
1996: ARRAY
1997: PUSH
1998: LD_INT 250
2000: LESS
2001: IFFALSE 2017
// SetLives ( b , 333 ) else
2003: LD_VAR 0 3
2007: PPUSH
2008: LD_INT 333
2010: PPUSH
2011: CALL_OW 234
2015: GO 2035
// SetLives ( b , i [ 5 ] ) ;
2017: LD_VAR 0 3
2021: PPUSH
2022: LD_VAR 0 2
2026: PUSH
2027: LD_INT 5
2029: ARRAY
2030: PPUSH
2031: CALL_OW 234
// end ;
2035: GO 1880
2037: POP
2038: POP
// uc_nation := 1 ;
2039: LD_ADDR_OWVAR 21
2043: PUSH
2044: LD_INT 1
2046: ST_TO_ADDR
// tmp := [ ] ;
2047: LD_ADDR_VAR 0 4
2051: PUSH
2052: EMPTY
2053: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2054: LD_ADDR_EXP 20
2058: PUSH
2059: LD_STRING Gary
2061: PPUSH
2062: LD_EXP 2
2066: NOT
2067: PPUSH
2068: LD_STRING 
2070: PPUSH
2071: CALL 233 0 3
2075: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2076: LD_ADDR_VAR 0 4
2080: PUSH
2081: LD_VAR 0 4
2085: PUSH
2086: LD_EXP 20
2090: ADD
2091: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2092: LD_ADDR_EXP 21
2096: PUSH
2097: LD_STRING Bobby
2099: PPUSH
2100: LD_EXP 2
2104: NOT
2105: PPUSH
2106: LD_STRING 08_
2108: PPUSH
2109: CALL 233 0 3
2113: ST_TO_ADDR
// if not Bobby then
2114: LD_EXP 21
2118: NOT
2119: IFFALSE 2143
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2121: LD_ADDR_EXP 21
2125: PUSH
2126: LD_STRING Bobby
2128: PPUSH
2129: LD_EXP 2
2133: NOT
2134: PPUSH
2135: LD_STRING 03_
2137: PPUSH
2138: CALL 233 0 3
2142: ST_TO_ADDR
// if Bobby then
2143: LD_EXP 21
2147: IFFALSE 2165
// tmp := tmp ^ Bobby ;
2149: LD_ADDR_VAR 0 4
2153: PUSH
2154: LD_VAR 0 4
2158: PUSH
2159: LD_EXP 21
2163: ADD
2164: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2165: LD_ADDR_EXP 22
2169: PUSH
2170: LD_STRING Cyrus
2172: PPUSH
2173: LD_EXP 2
2177: NOT
2178: PPUSH
2179: LD_STRING 08_
2181: PPUSH
2182: CALL 233 0 3
2186: ST_TO_ADDR
// if not Cyrus then
2187: LD_EXP 22
2191: NOT
2192: IFFALSE 2216
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2194: LD_ADDR_EXP 22
2198: PUSH
2199: LD_STRING Cyrus
2201: PPUSH
2202: LD_EXP 2
2206: NOT
2207: PPUSH
2208: LD_STRING 03_
2210: PPUSH
2211: CALL 233 0 3
2215: ST_TO_ADDR
// if Cyrus then
2216: LD_EXP 22
2220: IFFALSE 2238
// tmp := tmp ^ Cyrus ;
2222: LD_ADDR_VAR 0 4
2226: PUSH
2227: LD_VAR 0 4
2231: PUSH
2232: LD_EXP 22
2236: ADD
2237: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2238: LD_ADDR_VAR 0 4
2242: PUSH
2243: LD_VAR 0 4
2247: PUSH
2248: LD_STRING 09_prev_squad
2250: PPUSH
2251: CALL_OW 31
2255: ADD
2256: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2257: LD_STRING 09_prev_squad
2259: PPUSH
2260: CALL_OW 40
// tmp := tmp diff 0 ;
2264: LD_ADDR_VAR 0 4
2268: PUSH
2269: LD_VAR 0 4
2273: PUSH
2274: LD_INT 0
2276: DIFF
2277: ST_TO_ADDR
// if debug then
2278: LD_EXP 2
2282: IFFALSE 2333
// begin for i = 1 to 6 do
2284: LD_ADDR_VAR 0 2
2288: PUSH
2289: DOUBLE
2290: LD_INT 1
2292: DEC
2293: ST_TO_ADDR
2294: LD_INT 6
2296: PUSH
2297: FOR_TO
2298: IFFALSE 2331
// begin PrepareHuman ( false , 1 , 6 ) ;
2300: LD_INT 0
2302: PPUSH
2303: LD_INT 1
2305: PPUSH
2306: LD_INT 6
2308: PPUSH
2309: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2313: LD_ADDR_VAR 0 4
2317: PUSH
2318: LD_VAR 0 4
2322: PUSH
2323: CALL_OW 44
2327: ADD
2328: ST_TO_ADDR
// end ;
2329: GO 2297
2331: POP
2332: POP
// end ; for i in tmp do
2333: LD_ADDR_VAR 0 2
2337: PUSH
2338: LD_VAR 0 4
2342: PUSH
2343: FOR_IN
2344: IFFALSE 2403
// begin if GetClass ( i ) in [ 2 , 3 ] then
2346: LD_VAR 0 2
2350: PPUSH
2351: CALL_OW 257
2355: PUSH
2356: LD_INT 2
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: IN
2366: IFFALSE 2380
// SetClass ( i , 1 ) ;
2368: LD_VAR 0 2
2372: PPUSH
2373: LD_INT 1
2375: PPUSH
2376: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2380: LD_VAR 0 2
2384: PPUSH
2385: LD_INT 106
2387: PPUSH
2388: LD_INT 122
2390: PPUSH
2391: LD_INT 5
2393: PPUSH
2394: LD_INT 0
2396: PPUSH
2397: CALL_OW 50
// end ;
2401: GO 2343
2403: POP
2404: POP
// tmp := tmp diff Gary ;
2405: LD_ADDR_VAR 0 4
2409: PUSH
2410: LD_VAR 0 4
2414: PUSH
2415: LD_EXP 20
2419: DIFF
2420: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2421: LD_ADDR_VAR 0 3
2425: PUSH
2426: LD_INT 22
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 30
2438: PUSH
2439: LD_INT 31
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PPUSH
2450: CALL_OW 69
2454: ST_TO_ADDR
// for i = 1 to b do
2455: LD_ADDR_VAR 0 2
2459: PUSH
2460: DOUBLE
2461: LD_INT 1
2463: DEC
2464: ST_TO_ADDR
2465: LD_VAR 0 3
2469: PUSH
2470: FOR_TO
2471: IFFALSE 2501
// begin ComEnterUnit ( tmp [ i ] , b [ i ] ) ;
2473: LD_VAR 0 4
2477: PUSH
2478: LD_VAR 0 2
2482: ARRAY
2483: PPUSH
2484: LD_VAR 0 3
2488: PUSH
2489: LD_VAR 0 2
2493: ARRAY
2494: PPUSH
2495: CALL_OW 120
// end ;
2499: GO 2470
2501: POP
2502: POP
// InitHc ;
2503: CALL_OW 19
// InitUc ;
2507: CALL_OW 18
// end ;
2511: LD_VAR 0 1
2515: RET
// export function PowellTransport ; var i , un ; begin
2516: LD_INT 0
2518: PPUSH
2519: PPUSH
2520: PPUSH
// uc_side := 4 ;
2521: LD_ADDR_OWVAR 20
2525: PUSH
2526: LD_INT 4
2528: ST_TO_ADDR
// uc_nation := 1 ;
2529: LD_ADDR_OWVAR 21
2533: PUSH
2534: LD_INT 1
2536: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2537: LD_INT 1
2539: PPUSH
2540: LD_INT 3
2542: PPUSH
2543: LD_INT 6
2545: PPUSH
2546: CALL_OW 380
// hc_name :=  ;
2550: LD_ADDR_OWVAR 26
2554: PUSH
2555: LD_STRING 
2557: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2558: LD_ADDR_OWVAR 33
2562: PUSH
2563: LD_STRING SecondCharsGal
2565: ST_TO_ADDR
// hc_face_number := 30 ;
2566: LD_ADDR_OWVAR 34
2570: PUSH
2571: LD_INT 30
2573: ST_TO_ADDR
// powell_trans := CreateHuman ;
2574: LD_ADDR_EXP 25
2578: PUSH
2579: CALL_OW 44
2583: ST_TO_ADDR
// hc_face_number := 31 ;
2584: LD_ADDR_OWVAR 34
2588: PUSH
2589: LD_INT 31
2591: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2592: LD_ADDR_EXP 25
2596: PUSH
2597: LD_EXP 25
2601: PUSH
2602: CALL_OW 44
2606: ADD
2607: ST_TO_ADDR
// for i = 1 to 2 do
2608: LD_ADDR_VAR 0 2
2612: PUSH
2613: DOUBLE
2614: LD_INT 1
2616: DEC
2617: ST_TO_ADDR
2618: LD_INT 2
2620: PUSH
2621: FOR_TO
2622: IFFALSE 2673
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_INT 4
2631: PPUSH
2632: LD_INT 1
2634: PPUSH
2635: LD_INT 3
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 1
2643: PPUSH
2644: LD_INT 12
2646: PPUSH
2647: LD_INT 66
2649: PPUSH
2650: CALL 296 0 7
2654: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2655: LD_ADDR_EXP 25
2659: PUSH
2660: LD_EXP 25
2664: PUSH
2665: LD_VAR 0 3
2669: ADD
2670: ST_TO_ADDR
// end ;
2671: GO 2621
2673: POP
2674: POP
// end ; end_of_file
2675: LD_VAR 0 1
2679: RET
// export function Action ; var i , veh ; begin
2680: LD_INT 0
2682: PPUSH
2683: PPUSH
2684: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2685: LD_EXP 24
2689: PPUSH
2690: LD_INT 0
2692: PPUSH
2693: LD_INT 50
2695: PPUSH
2696: LD_INT 38
2698: PPUSH
2699: LD_INT 2
2701: PPUSH
2702: CALL_OW 145
// InGameOn ;
2706: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2710: LD_INT 43
2712: PPUSH
2713: LD_INT 9
2715: PPUSH
2716: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
2720: LD_EXP 19
2724: PPUSH
2725: LD_INT 54
2727: PPUSH
2728: LD_INT 34
2730: PPUSH
2731: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
2735: LD_EXP 19
2739: PPUSH
2740: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
2744: LD_EXP 19
2748: PPUSH
2749: LD_EXP 24
2753: PUSH
2754: LD_INT 1
2756: ARRAY
2757: PPUSH
2758: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2762: LD_INT 35
2764: PPUSH
2765: CALL_OW 67
// until See ( 4 , JMM ) ;
2769: LD_INT 4
2771: PPUSH
2772: LD_EXP 19
2776: PPUSH
2777: CALL_OW 292
2781: IFFALSE 2762
// CenterNowOnUnits ( JMM ) ;
2783: LD_EXP 19
2787: PPUSH
2788: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
2792: LD_EXP 19
2796: PPUSH
2797: LD_STRING D2-JMM-1
2799: PPUSH
2800: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
2804: LD_EXP 24
2808: PUSH
2809: LD_INT 3
2811: ARRAY
2812: PPUSH
2813: LD_EXP 19
2817: PPUSH
2818: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
2822: LD_EXP 24
2826: PUSH
2827: LD_INT 3
2829: ARRAY
2830: PPUSH
2831: LD_STRING D2-Eng1-1
2833: PPUSH
2834: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2838: LD_EXP 19
2842: PPUSH
2843: LD_STRING D2-JMM-2
2845: PPUSH
2846: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
2850: LD_EXP 24
2854: PUSH
2855: LD_INT 3
2857: ARRAY
2858: PPUSH
2859: LD_STRING D2-Eng1-2
2861: PPUSH
2862: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2866: LD_EXP 19
2870: PPUSH
2871: LD_STRING D2-JMM-3
2873: PPUSH
2874: CALL_OW 88
// if Houten then
2878: LD_EXP 23
2882: IFFALSE 3080
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
2884: LD_ADDR_VAR 0 3
2888: PUSH
2889: LD_INT 4
2891: PPUSH
2892: LD_INT 1
2894: PPUSH
2895: LD_INT 3
2897: PPUSH
2898: LD_INT 2
2900: PPUSH
2901: LD_INT 1
2903: PPUSH
2904: LD_INT 4
2906: PPUSH
2907: LD_INT 55
2909: PPUSH
2910: CALL 296 0 7
2914: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2915: LD_VAR 0 3
2919: PPUSH
2920: LD_INT 3
2922: PPUSH
2923: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
2927: LD_VAR 0 3
2931: PPUSH
2932: LD_INT 46
2934: PPUSH
2935: LD_INT 19
2937: PPUSH
2938: LD_INT 0
2940: PPUSH
2941: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
2945: LD_EXP 23
2949: PPUSH
2950: LD_VAR 0 3
2954: PPUSH
2955: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
2959: LD_EXP 23
2963: PPUSH
2964: LD_INT 49
2966: PPUSH
2967: LD_INT 33
2969: PPUSH
2970: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
2974: LD_EXP 23
2978: PPUSH
2979: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
2983: LD_EXP 23
2987: PPUSH
2988: LD_EXP 19
2992: PPUSH
2993: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
2997: LD_INT 35
2999: PPUSH
3000: CALL_OW 67
// until See ( 1 , Houten ) ;
3004: LD_INT 1
3006: PPUSH
3007: LD_EXP 23
3011: PPUSH
3012: CALL_OW 292
3016: IFFALSE 2997
// ComTurnUnit ( JMM , Houten ) ;
3018: LD_EXP 19
3022: PPUSH
3023: LD_EXP 23
3027: PPUSH
3028: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3032: LD_EXP 19
3036: PPUSH
3037: LD_STRING D1d-JMM-1
3039: PPUSH
3040: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3044: LD_EXP 23
3048: PPUSH
3049: LD_STRING D1-VanH-1
3051: PPUSH
3052: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3056: LD_EXP 19
3060: PPUSH
3061: LD_STRING D1-JMM-1v
3063: PPUSH
3064: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3068: LD_EXP 19
3072: PPUSH
3073: LD_STRING D1-JMM-2v
3075: PPUSH
3076: CALL_OW 88
// end ; InGameOff ;
3080: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3084: LD_STRING M1
3086: PPUSH
3087: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3091: LD_INT 22
3093: PUSH
3094: LD_INT 4
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 92
3103: PUSH
3104: LD_EXP 19
3108: PPUSH
3109: CALL_OW 250
3113: PUSH
3114: LD_EXP 19
3118: PPUSH
3119: CALL_OW 251
3123: PUSH
3124: LD_INT 15
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: LIST
3131: LIST
3132: PUSH
3133: EMPTY
3134: LIST
3135: LIST
3136: PPUSH
3137: CALL_OW 69
3141: PPUSH
3142: LD_INT 1
3144: PPUSH
3145: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3149: LD_EXP 24
3153: PUSH
3154: LD_EXP 19
3158: ADD
3159: PUSH
3160: LD_EXP 23
3164: ADD
3165: PPUSH
3166: CALL_OW 141
// end ;
3170: LD_VAR 0 1
3174: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3175: LD_INT 1
3177: PPUSH
3178: LD_EXP 20
3182: PPUSH
3183: CALL_OW 292
3187: PUSH
3188: LD_EXP 19
3192: PPUSH
3193: LD_EXP 20
3197: PPUSH
3198: CALL_OW 296
3202: PUSH
3203: LD_INT 6
3205: LESS
3206: AND
3207: IFFALSE 4080
3209: GO 3211
3211: DISABLE
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
// begin InGameOn ;
3219: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3223: LD_INT 22
3225: PUSH
3226: LD_INT 4
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: PPUSH
3233: CALL_OW 69
3237: PPUSH
3238: LD_INT 1
3240: PPUSH
3241: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3245: LD_ADDR_VAR 0 4
3249: PUSH
3250: LD_INT 22
3252: PUSH
3253: LD_INT 1
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: PUSH
3260: LD_INT 2
3262: PUSH
3263: LD_INT 25
3265: PUSH
3266: LD_INT 1
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: LD_INT 25
3275: PUSH
3276: LD_INT 2
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: PUSH
3283: LD_INT 25
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: PUSH
3293: LD_INT 25
3295: PUSH
3296: LD_INT 4
3298: PUSH
3299: EMPTY
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: EMPTY
3311: LIST
3312: LIST
3313: PPUSH
3314: CALL_OW 69
3318: ST_TO_ADDR
// ComHold ( tmp ) ;
3319: LD_VAR 0 4
3323: PPUSH
3324: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3328: LD_EXP 19
3332: PPUSH
3333: LD_STRING D2-JMM-3a
3335: PPUSH
3336: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3340: LD_EXP 20
3344: PPUSH
3345: LD_EXP 19
3349: PPUSH
3350: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3354: LD_EXP 20
3358: PPUSH
3359: LD_STRING D2-Gary-3
3361: PPUSH
3362: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3366: LD_EXP 19
3370: PPUSH
3371: LD_EXP 20
3375: PPUSH
3376: CALL_OW 119
// for i in tmp do
3380: LD_ADDR_VAR 0 5
3384: PUSH
3385: LD_VAR 0 4
3389: PUSH
3390: FOR_IN
3391: IFFALSE 3436
// begin if IsInUnit ( i ) then
3393: LD_VAR 0 5
3397: PPUSH
3398: CALL_OW 310
3402: IFFALSE 3413
// ComExitBuilding ( i ) ;
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 122
// wait ( 1 ) ;
3413: LD_INT 1
3415: PPUSH
3416: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3420: LD_VAR 0 5
3424: PPUSH
3425: LD_EXP 19
3429: PPUSH
3430: CALL_OW 119
// end ;
3434: GO 3390
3436: POP
3437: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3438: LD_ADDR_VAR 0 4
3442: PUSH
3443: LD_VAR 0 4
3447: PUSH
3448: LD_EXP 19
3452: PUSH
3453: LD_EXP 23
3457: PUSH
3458: LD_EXP 20
3462: PUSH
3463: LD_EXP 22
3467: PUSH
3468: LD_EXP 21
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: PUSH
3480: LD_EXP 24
3484: ADD
3485: DIFF
3486: ST_TO_ADDR
// if Bobby then
3487: LD_EXP 21
3491: IFFALSE 3505
// Say ( Bobby , D2-Bobby-3 ) ;
3493: LD_EXP 21
3497: PPUSH
3498: LD_STRING D2-Bobby-3
3500: PPUSH
3501: CALL_OW 88
// if Cyrus then
3505: LD_EXP 22
3509: IFFALSE 3523
// Say ( Cyrus , D2-Cyrus-3 ) ;
3511: LD_EXP 22
3515: PPUSH
3516: LD_STRING D2-Cyrus-3
3518: PPUSH
3519: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3523: LD_EXP 19
3527: PPUSH
3528: LD_STRING D2-JMM-4
3530: PPUSH
3531: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_STRING D2-Gary-4
3542: PPUSH
3543: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3547: LD_ADDR_VAR 0 1
3551: PUSH
3552: LD_VAR 0 4
3556: PPUSH
3557: LD_INT 26
3559: PUSH
3560: LD_INT 1
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PPUSH
3567: CALL_OW 72
3571: PUSH
3572: LD_INT 1
3574: ARRAY
3575: ST_TO_ADDR
// if Cyrus then
3576: LD_EXP 22
3580: IFFALSE 3596
// Say ( Cyrus , D2-Cyrus-4 ) else
3582: LD_EXP 22
3586: PPUSH
3587: LD_STRING D2-Cyrus-4
3589: PPUSH
3590: CALL_OW 88
3594: GO 3608
// Say ( un1 , D2-Sol1-4 ) ;
3596: LD_VAR 0 1
3600: PPUSH
3601: LD_STRING D2-Sol1-4
3603: PPUSH
3604: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3608: LD_EXP 19
3612: PPUSH
3613: LD_STRING D2-JMM-5
3615: PPUSH
3616: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3620: LD_ADDR_VAR 0 2
3624: PUSH
3625: LD_EXP 24
3629: PPUSH
3630: LD_INT 91
3632: PUSH
3633: LD_EXP 19
3637: PUSH
3638: LD_INT 10
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: LIST
3645: PUSH
3646: LD_INT 26
3648: PUSH
3649: LD_INT 2
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: PUSH
3656: EMPTY
3657: LIST
3658: LIST
3659: PPUSH
3660: CALL_OW 72
3664: ST_TO_ADDR
// if un2 then
3665: LD_VAR 0 2
3669: IFFALSE 3723
// begin un2 := un2 [ un2 ] ;
3671: LD_ADDR_VAR 0 2
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_VAR 0 2
3685: ARRAY
3686: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3687: LD_VAR 0 2
3691: PPUSH
3692: LD_STRING D2-FEng1-5
3694: PPUSH
3695: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3699: LD_EXP 19
3703: PPUSH
3704: LD_STRING D2-JMM-6
3706: PPUSH
3707: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3711: LD_VAR 0 2
3715: PPUSH
3716: LD_STRING D2-FEng1-6
3718: PPUSH
3719: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
3723: LD_ADDR_VAR 0 3
3727: PUSH
3728: LD_EXP 24
3732: PPUSH
3733: LD_INT 91
3735: PUSH
3736: LD_EXP 19
3740: PUSH
3741: LD_INT 10
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: LIST
3748: PUSH
3749: LD_INT 26
3751: PUSH
3752: LD_INT 1
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PPUSH
3763: CALL_OW 72
3767: ST_TO_ADDR
// if un3 then
3768: LD_VAR 0 3
3772: IFFALSE 3827
// begin un3 := un3 [ 1 ] ;
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: LD_VAR 0 3
3783: PUSH
3784: LD_INT 1
3786: ARRAY
3787: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
3788: LD_VAR 0 3
3792: PPUSH
3793: LD_INT 114
3795: PPUSH
3796: LD_INT 122
3798: PPUSH
3799: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
3803: LD_VAR 0 3
3807: PPUSH
3808: LD_STRING D2-Eng1-6
3810: PPUSH
3811: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
3815: LD_EXP 19
3819: PPUSH
3820: LD_STRING D2-JMM-7
3822: PPUSH
3823: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
3827: LD_EXP 20
3831: PPUSH
3832: LD_STRING D2-Gary-7
3834: PPUSH
3835: CALL_OW 88
// if un2 then
3839: LD_VAR 0 2
3843: IFFALSE 3857
// Say ( un2 , D2-FEng1-7 ) ;
3845: LD_VAR 0 2
3849: PPUSH
3850: LD_STRING D2-FEng1-7
3852: PPUSH
3853: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
3857: LD_VAR 0 1
3861: PPUSH
3862: LD_STRING D2-Sol1-7
3864: PPUSH
3865: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
3869: LD_EXP 19
3873: PPUSH
3874: LD_STRING D2-JMM-8
3876: PPUSH
3877: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
3881: LD_INT 22
3883: PUSH
3884: LD_INT 1
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PPUSH
3896: CALL_OW 141
// InGameOff ;
3900: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
3904: LD_STRING M1a
3906: PPUSH
3907: CALL_OW 337
// jmm_in_ovsyenko := true ;
3911: LD_ADDR_EXP 4
3915: PUSH
3916: LD_INT 1
3918: ST_TO_ADDR
// if debug then
3919: LD_EXP 2
3923: IFFALSE 4029
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
3925: LD_INT 22
3927: PUSH
3928: LD_INT 1
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: PUSH
3935: LD_INT 30
3937: PUSH
3938: LD_INT 0
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: PPUSH
3949: CALL_OW 69
3953: PUSH
3954: LD_INT 1
3956: ARRAY
3957: PPUSH
3958: CALL_OW 274
3962: PPUSH
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 1000
3968: PPUSH
3969: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
3973: LD_INT 22
3975: PUSH
3976: LD_INT 1
3978: PUSH
3979: EMPTY
3980: LIST
3981: LIST
3982: PUSH
3983: LD_INT 30
3985: PUSH
3986: LD_INT 0
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: PPUSH
3997: CALL_OW 69
4001: PUSH
4002: LD_INT 1
4004: ARRAY
4005: PPUSH
4006: CALL_OW 274
4010: PPUSH
4011: LD_INT 1
4013: PPUSH
4014: LD_INT 1000
4016: PPUSH
4017: CALL_OW 277
// ar_can_arrive := true ;
4021: LD_ADDR_EXP 10
4025: PUSH
4026: LD_INT 1
4028: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4029: LD_INT 1050
4031: PPUSH
4032: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4036: LD_ADDR_VAR 0 4
4040: PUSH
4041: LD_INT 25
4043: PUSH
4044: LD_INT 14
4046: PUSH
4047: EMPTY
4048: LIST
4049: LIST
4050: PPUSH
4051: CALL_OW 69
4055: ST_TO_ADDR
// if not tmp then
4056: LD_VAR 0 4
4060: NOT
4061: IFFALSE 4065
// exit ;
4063: GO 4080
// ComMoveXY ( tmp , 75 , 75 ) ;
4065: LD_VAR 0 4
4069: PPUSH
4070: LD_INT 75
4072: PPUSH
4073: LD_INT 75
4075: PPUSH
4076: CALL_OW 111
// end ;
4080: PPOPN 5
4082: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4083: LD_INT 22
4085: PUSH
4086: LD_INT 1
4088: PUSH
4089: EMPTY
4090: LIST
4091: LIST
4092: PUSH
4093: LD_INT 30
4095: PUSH
4096: LD_INT 30
4098: PUSH
4099: EMPTY
4100: LIST
4101: LIST
4102: PUSH
4103: LD_INT 3
4105: PUSH
4106: LD_INT 57
4108: PUSH
4109: EMPTY
4110: LIST
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PPUSH
4121: CALL_OW 69
4125: IFFALSE 4167
4127: GO 4129
4129: DISABLE
4130: LD_INT 0
4132: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4133: LD_ADDR_VAR 0 1
4137: PUSH
4138: LD_STRING M2easy
4140: PUSH
4141: LD_STRING M2
4143: PUSH
4144: LD_STRING M2hard
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4152: LD_VAR 0 1
4156: PUSH
4157: LD_OWVAR 67
4161: ARRAY
4162: PPUSH
4163: CALL_OW 337
// end ;
4167: PPOPN 1
4169: END
// every 3 3$00 do
4170: GO 4172
4172: DISABLE
// begin DialogueOn ;
4173: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4177: LD_EXP 26
4181: PPUSH
4182: LD_STRING D3-Pow-1
4184: PPUSH
4185: CALL_OW 94
// if jmm_in_ovsyenko then
4189: LD_EXP 4
4193: IFFALSE 4221
// begin Say ( JMM , D3-JMM-1 ) ;
4195: LD_EXP 19
4199: PPUSH
4200: LD_STRING D3-JMM-1
4202: PPUSH
4203: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4207: LD_EXP 19
4211: PPUSH
4212: LD_STRING D3-JMM-1b
4214: PPUSH
4215: CALL_OW 88
// end else
4219: GO 4233
// Say ( JMM , D3-JMM-1a ) ;
4221: LD_EXP 19
4225: PPUSH
4226: LD_STRING D3-JMM-1a
4228: PPUSH
4229: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4233: LD_EXP 26
4237: PPUSH
4238: LD_STRING D3-Pow-2
4240: PPUSH
4241: CALL_OW 94
// DialogueOff ;
4245: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4249: LD_STRING M3
4251: PPUSH
4252: CALL_OW 337
// powell_want_sib := true ;
4256: LD_ADDR_EXP 5
4260: PUSH
4261: LD_INT 1
4263: ST_TO_ADDR
// end ;
4264: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4265: LD_EXP 6
4269: PUSH
4270: LD_INT 0
4272: EQUAL
4273: IFFALSE 5720
4275: GO 4277
4277: DISABLE
4278: LD_INT 0
4280: PPUSH
4281: PPUSH
4282: PPUSH
4283: PPUSH
4284: PPUSH
4285: PPUSH
4286: PPUSH
4287: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4288: LD_INT 4
4290: PPUSH
4291: LD_INT 1
4293: PPUSH
4294: CALL_OW 343
// PowellTransport ;
4298: CALL 2516 0 0
// for i = 1 to 3 do
4302: LD_ADDR_VAR 0 4
4306: PUSH
4307: DOUBLE
4308: LD_INT 1
4310: DEC
4311: ST_TO_ADDR
4312: LD_INT 3
4314: PUSH
4315: FOR_TO
4316: IFFALSE 4383
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4318: LD_ADDR_VAR 0 1
4322: PUSH
4323: LD_INT 6
4325: PPUSH
4326: LD_VAR 0 4
4330: PPUSH
4331: CALL_OW 287
4335: ST_TO_ADDR
// if not tmp then
4336: LD_VAR 0 1
4340: NOT
4341: IFFALSE 4345
// continue ;
4343: GO 4315
// EraseResourceArea ( terminalArea , i ) ;
4345: LD_INT 6
4347: PPUSH
4348: LD_VAR 0 4
4352: PPUSH
4353: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4357: LD_EXP 3
4361: PPUSH
4362: CALL_OW 274
4366: PPUSH
4367: LD_VAR 0 4
4371: PPUSH
4372: LD_VAR 0 1
4376: PPUSH
4377: CALL_OW 276
// end ;
4381: GO 4315
4383: POP
4384: POP
// x := 43 ;
4385: LD_ADDR_VAR 0 2
4389: PUSH
4390: LD_INT 43
4392: ST_TO_ADDR
// y := 3 ;
4393: LD_ADDR_VAR 0 3
4397: PUSH
4398: LD_INT 3
4400: ST_TO_ADDR
// for i = 3 to 4 do
4401: LD_ADDR_VAR 0 4
4405: PUSH
4406: DOUBLE
4407: LD_INT 3
4409: DEC
4410: ST_TO_ADDR
4411: LD_INT 4
4413: PUSH
4414: FOR_TO
4415: IFFALSE 4606
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4417: LD_EXP 25
4421: PUSH
4422: LD_VAR 0 4
4426: ARRAY
4427: PPUSH
4428: LD_INT 4
4430: PPUSH
4431: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4435: LD_EXP 25
4439: PUSH
4440: LD_VAR 0 4
4444: ARRAY
4445: PPUSH
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_VAR 0 3
4455: PPUSH
4456: LD_INT 0
4458: PPUSH
4459: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4463: LD_EXP 25
4467: PUSH
4468: LD_VAR 0 4
4472: PUSH
4473: LD_INT 2
4475: MINUS
4476: ARRAY
4477: PPUSH
4478: LD_EXP 25
4482: PUSH
4483: LD_VAR 0 4
4487: ARRAY
4488: PPUSH
4489: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4493: LD_EXP 25
4497: PUSH
4498: LD_VAR 0 4
4502: ARRAY
4503: PPUSH
4504: LD_INT 1
4506: PPUSH
4507: LD_INT 100
4509: PPUSH
4510: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4514: LD_EXP 25
4518: PUSH
4519: LD_VAR 0 4
4523: PUSH
4524: LD_INT 2
4526: MINUS
4527: ARRAY
4528: PPUSH
4529: LD_INT 54
4531: PPUSH
4532: LD_INT 42
4534: PPUSH
4535: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4539: LD_EXP 25
4543: PUSH
4544: LD_VAR 0 4
4548: PUSH
4549: LD_INT 2
4551: MINUS
4552: ARRAY
4553: PPUSH
4554: LD_EXP 3
4558: PPUSH
4559: CALL_OW 250
4563: PPUSH
4564: LD_EXP 3
4568: PPUSH
4569: CALL_OW 251
4573: PPUSH
4574: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4578: LD_EXP 25
4582: PUSH
4583: LD_VAR 0 4
4587: PUSH
4588: LD_INT 2
4590: MINUS
4591: ARRAY
4592: PPUSH
4593: CALL_OW 200
// Wait ( 0 0$02 ) ;
4597: LD_INT 70
4599: PPUSH
4600: CALL_OW 67
// end ;
4604: GO 4414
4606: POP
4607: POP
// time := 0 0$20 ;
4608: LD_ADDR_VAR 0 8
4612: PUSH
4613: LD_INT 700
4615: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4616: LD_INT 35
4618: PPUSH
4619: CALL_OW 67
// time := time - 0 0$01 ;
4623: LD_ADDR_VAR 0 8
4627: PUSH
4628: LD_VAR 0 8
4632: PUSH
4633: LD_INT 35
4635: MINUS
4636: ST_TO_ADDR
// for i = 3 to 4 do
4637: LD_ADDR_VAR 0 4
4641: PUSH
4642: DOUBLE
4643: LD_INT 3
4645: DEC
4646: ST_TO_ADDR
4647: LD_INT 4
4649: PUSH
4650: FOR_TO
4651: IFFALSE 4786
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4653: LD_EXP 25
4657: PUSH
4658: LD_VAR 0 4
4662: ARRAY
4663: PPUSH
4664: LD_INT 1
4666: PPUSH
4667: CALL_OW 289
4671: PUSH
4672: LD_INT 0
4674: GREATER
4675: PUSH
4676: LD_EXP 25
4680: PUSH
4681: LD_VAR 0 4
4685: ARRAY
4686: PPUSH
4687: CALL_OW 314
4691: NOT
4692: AND
4693: IFFALSE 4784
// begin x := rand ( 0 , 5 ) ;
4695: LD_ADDR_VAR 0 2
4699: PUSH
4700: LD_INT 0
4702: PPUSH
4703: LD_INT 5
4705: PPUSH
4706: CALL_OW 12
4710: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4711: LD_EXP 25
4715: PUSH
4716: LD_VAR 0 4
4720: ARRAY
4721: PPUSH
4722: LD_EXP 25
4726: PUSH
4727: LD_VAR 0 4
4731: ARRAY
4732: PPUSH
4733: CALL_OW 250
4737: PPUSH
4738: LD_VAR 0 2
4742: PPUSH
4743: LD_INT 3
4745: PPUSH
4746: CALL_OW 272
4750: PPUSH
4751: LD_EXP 25
4755: PUSH
4756: LD_VAR 0 4
4760: ARRAY
4761: PPUSH
4762: CALL_OW 251
4766: PPUSH
4767: LD_VAR 0 2
4771: PPUSH
4772: LD_INT 3
4774: PPUSH
4775: CALL_OW 273
4779: PPUSH
4780: CALL_OW 171
// end ;
4784: GO 4650
4786: POP
4787: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
4788: LD_EXP 25
4792: PUSH
4793: LD_INT 1
4795: ARRAY
4796: PPUSH
4797: LD_INT 54
4799: PPUSH
4800: LD_INT 42
4802: PPUSH
4803: CALL_OW 297
4807: PUSH
4808: LD_INT 4
4810: LESS
4811: PUSH
4812: LD_VAR 0 8
4816: PUSH
4817: LD_INT 0
4819: EQUAL
4820: OR
4821: IFFALSE 4616
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
4823: LD_EXP 25
4827: PUSH
4828: LD_INT 3
4830: ARRAY
4831: PPUSH
4832: LD_INT 1
4834: PPUSH
4835: LD_INT 0
4837: PPUSH
4838: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
4842: LD_EXP 25
4846: PUSH
4847: LD_INT 4
4849: ARRAY
4850: PPUSH
4851: LD_INT 1
4853: PPUSH
4854: LD_INT 0
4856: PPUSH
4857: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
4861: LD_EXP 3
4865: PPUSH
4866: CALL_OW 274
4870: PPUSH
4871: LD_INT 1
4873: PPUSH
4874: LD_INT 200
4876: PPUSH
4877: CALL_OW 276
// DialogueOn ;
4881: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
4885: LD_INT 53
4887: PPUSH
4888: LD_INT 35
4890: PPUSH
4891: CALL_OW 86
// un := powell_trans [ 1 ] ;
4895: LD_ADDR_VAR 0 5
4899: PUSH
4900: LD_EXP 25
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
4909: LD_VAR 0 5
4913: PPUSH
4914: LD_STRING D4-Mech1-1
4916: PPUSH
4917: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
4921: LD_EXP 19
4925: PPUSH
4926: LD_STRING D4-JMM-1
4928: PPUSH
4929: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
4933: LD_VAR 0 5
4937: PPUSH
4938: LD_STRING D4-Mech1-2
4940: PPUSH
4941: CALL_OW 88
// powell_happy := false ;
4945: LD_ADDR_VAR 0 6
4949: PUSH
4950: LD_INT 0
4952: ST_TO_ADDR
// take_cargo := false ;
4953: LD_ADDR_VAR 0 7
4957: PUSH
4958: LD_INT 0
4960: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
4961: CALL 816 0 0
4965: PUSH
4966: LD_INT 60
4968: GREATEREQUAL
4969: IFFALSE 5017
// begin Say ( JMM , D5-JMM-1 ) ;
4971: LD_EXP 19
4975: PPUSH
4976: LD_STRING D5-JMM-1
4978: PPUSH
4979: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
4983: LD_VAR 0 5
4987: PPUSH
4988: LD_STRING D6-Mech1-1
4990: PPUSH
4991: CALL_OW 88
// powell_happy := true ;
4995: LD_ADDR_VAR 0 6
4999: PUSH
5000: LD_INT 1
5002: ST_TO_ADDR
// take_cargo := true ;
5003: LD_ADDR_VAR 0 7
5007: PUSH
5008: LD_INT 1
5010: ST_TO_ADDR
// DialogueOff ;
5011: CALL_OW 7
// end else
5015: GO 5251
// if GetTerminalCargo > 0 then
5017: CALL 816 0 0
5021: PUSH
5022: LD_INT 0
5024: GREATER
5025: IFFALSE 5223
// begin case Query ( QWait ) of 1 :
5027: LD_STRING QWait
5029: PPUSH
5030: CALL_OW 97
5034: PUSH
5035: LD_INT 1
5037: DOUBLE
5038: EQUAL
5039: IFTRUE 5043
5041: GO 5134
5043: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5044: LD_EXP 19
5048: PPUSH
5049: LD_STRING D5a-JMM-1
5051: PPUSH
5052: CALL_OW 88
// DialogueOff ;
5056: CALL_OW 7
// wait ( 5 5$00 ) ;
5060: LD_INT 10500
5062: PPUSH
5063: CALL_OW 67
// if GetTerminalCargo < 60 then
5067: CALL 816 0 0
5071: PUSH
5072: LD_INT 60
5074: LESS
5075: IFFALSE 5116
// begin DialogueOn ;
5077: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5081: LD_EXP 3
5085: PPUSH
5086: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5090: LD_VAR 0 5
5094: PPUSH
5095: LD_STRING D6-Mech1-1a
5097: PPUSH
5098: CALL_OW 88
// DialogueOff ;
5102: CALL_OW 7
// powell_happy := false ;
5106: LD_ADDR_VAR 0 6
5110: PUSH
5111: LD_INT 0
5113: ST_TO_ADDR
// end else
5114: GO 5132
// begin powell_happy := true ;
5116: LD_ADDR_VAR 0 6
5120: PUSH
5121: LD_INT 1
5123: ST_TO_ADDR
// take_cargo := true ;
5124: LD_ADDR_VAR 0 7
5128: PUSH
5129: LD_INT 1
5131: ST_TO_ADDR
// end ; end ; 2 :
5132: GO 5221
5134: LD_INT 2
5136: DOUBLE
5137: EQUAL
5138: IFTRUE 5142
5140: GO 5181
5142: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5143: LD_EXP 19
5147: PPUSH
5148: LD_STRING D5b-JMM-1
5150: PPUSH
5151: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5155: LD_VAR 0 5
5159: PPUSH
5160: LD_STRING D6-Mech1-1a
5162: PPUSH
5163: CALL_OW 88
// DialogueOff ;
5167: CALL_OW 7
// take_cargo := true ;
5171: LD_ADDR_VAR 0 7
5175: PUSH
5176: LD_INT 1
5178: ST_TO_ADDR
// end ; 3 :
5179: GO 5221
5181: LD_INT 3
5183: DOUBLE
5184: EQUAL
5185: IFTRUE 5189
5187: GO 5220
5189: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5190: LD_EXP 19
5194: PPUSH
5195: LD_STRING D5c-JMM-1
5197: PPUSH
5198: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5202: LD_VAR 0 5
5206: PPUSH
5207: LD_STRING D6-Mech1-1b
5209: PPUSH
5210: CALL_OW 88
// DialogueOff ;
5214: CALL_OW 7
// end ; end ;
5218: GO 5221
5220: POP
// end else
5221: GO 5251
// begin Say ( JMM , D5c-JMM-1 ) ;
5223: LD_EXP 19
5227: PPUSH
5228: LD_STRING D5c-JMM-1
5230: PPUSH
5231: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5235: LD_VAR 0 5
5239: PPUSH
5240: LD_STRING D6-Mech1-1b
5242: PPUSH
5243: CALL_OW 88
// DialogueOff ;
5247: CALL_OW 7
// end ; if take_cargo then
5251: LD_VAR 0 7
5255: IFFALSE 5334
// begin x := GetTerminalCargo ;
5257: LD_ADDR_VAR 0 2
5261: PUSH
5262: CALL 816 0 0
5266: ST_TO_ADDR
// if x > 60 then
5267: LD_VAR 0 2
5271: PUSH
5272: LD_INT 60
5274: GREATER
5275: IFFALSE 5285
// x := 60 ;
5277: LD_ADDR_VAR 0 2
5281: PUSH
5282: LD_INT 60
5284: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5285: LD_EXP 3
5289: PPUSH
5290: CALL_OW 274
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: CALL 816 0 0
5302: PUSH
5303: LD_VAR 0 2
5307: MINUS
5308: PPUSH
5309: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5313: LD_EXP 25
5317: PUSH
5318: LD_INT 3
5320: ARRAY
5321: PPUSH
5322: LD_INT 3
5324: PPUSH
5325: LD_VAR 0 2
5329: PPUSH
5330: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5334: LD_EXP 25
5338: PPUSH
5339: LD_INT 43
5341: PPUSH
5342: LD_INT 3
5344: PPUSH
5345: CALL_OW 171
// x := 0 0$20 ;
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: LD_INT 700
5356: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5357: LD_INT 35
5359: PPUSH
5360: CALL_OW 67
// x := x - 0 0$01 ;
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: LD_VAR 0 2
5373: PUSH
5374: LD_INT 35
5376: MINUS
5377: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5378: LD_VAR 0 2
5382: PUSH
5383: LD_INT 0
5385: EQUAL
5386: PUSH
5387: LD_EXP 25
5391: PUSH
5392: LD_INT 3
5394: ARRAY
5395: PPUSH
5396: LD_INT 43
5398: PPUSH
5399: LD_INT 3
5401: PPUSH
5402: CALL_OW 297
5406: PUSH
5407: LD_INT 4
5409: LESS
5410: PUSH
5411: LD_EXP 25
5415: PUSH
5416: LD_INT 3
5418: ARRAY
5419: PPUSH
5420: LD_INT 43
5422: PPUSH
5423: LD_INT 3
5425: PPUSH
5426: CALL_OW 297
5430: PUSH
5431: LD_INT 4
5433: LESS
5434: AND
5435: OR
5436: IFFALSE 5357
// for i in powell_trans do
5438: LD_ADDR_VAR 0 4
5442: PUSH
5443: LD_EXP 25
5447: PUSH
5448: FOR_IN
5449: IFFALSE 5462
// RemoveUnit ( i ) ;
5451: LD_VAR 0 4
5455: PPUSH
5456: CALL_OW 64
5460: GO 5448
5462: POP
5463: POP
// if not powell_happy then
5464: LD_VAR 0 6
5468: NOT
5469: IFFALSE 5480
// powell_happy := - 1 ;
5471: LD_ADDR_VAR 0 6
5475: PUSH
5476: LD_INT 1
5478: NEG
5479: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5480: LD_STRING EarlySiberite
5482: PPUSH
5483: LD_VAR 0 6
5487: PPUSH
5488: CALL_OW 101
// if powell_happy then
5492: LD_VAR 0 6
5496: IFFALSE 5507
// ChangeMissionObjectives ( M3a ) else
5498: LD_STRING M3a
5500: PPUSH
5501: CALL_OW 337
5505: GO 5514
// ChangeMissionObjectives ( M3b ) ;
5507: LD_STRING M3b
5509: PPUSH
5510: CALL_OW 337
// ru_can_attack_terminal := true ;
5514: LD_ADDR_EXP 9
5518: PUSH
5519: LD_INT 1
5521: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5522: LD_INT 25200
5524: PPUSH
5525: CALL_OW 67
// time := 2 2$00 ;
5529: LD_ADDR_VAR 0 8
5533: PUSH
5534: LD_INT 4200
5536: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5537: LD_INT 35
5539: PPUSH
5540: CALL_OW 67
// time := time - 0 0$1 ;
5544: LD_ADDR_VAR 0 8
5548: PUSH
5549: LD_VAR 0 8
5553: PUSH
5554: LD_INT 35
5556: MINUS
5557: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5558: LD_EXP 8
5562: NOT
5563: PUSH
5564: LD_EXP 36
5568: PUSH
5569: LD_INT 0
5571: EQUAL
5572: OR
5573: PUSH
5574: LD_VAR 0 8
5578: PUSH
5579: LD_INT 0
5581: EQUAL
5582: OR
5583: IFFALSE 5537
// if ru_force then
5585: LD_EXP 36
5589: IFFALSE 5688
// for i in ru_force do
5591: LD_ADDR_VAR 0 4
5595: PUSH
5596: LD_EXP 36
5600: PUSH
5601: FOR_IN
5602: IFFALSE 5686
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5604: LD_INT 1
5606: PPUSH
5607: LD_VAR 0 4
5611: PPUSH
5612: CALL_OW 292
5616: NOT
5617: PUSH
5618: LD_VAR 0 4
5622: PPUSH
5623: LD_INT 81
5625: PUSH
5626: LD_INT 3
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: PPUSH
5633: CALL_OW 69
5637: PPUSH
5638: LD_VAR 0 4
5642: PPUSH
5643: CALL_OW 74
5647: PPUSH
5648: CALL_OW 296
5652: PUSH
5653: LD_INT 10
5655: GREATER
5656: AND
5657: IFFALSE 5684
// begin RemoveUnit ( i ) ;
5659: LD_VAR 0 4
5663: PPUSH
5664: CALL_OW 64
// ru_force := ru_force diff i ;
5668: LD_ADDR_EXP 36
5672: PUSH
5673: LD_EXP 36
5677: PUSH
5678: LD_VAR 0 4
5682: DIFF
5683: ST_TO_ADDR
// end ;
5684: GO 5601
5686: POP
5687: POP
// repeat wait ( 0 0$03 ) ;
5688: LD_INT 105
5690: PPUSH
5691: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5695: LD_EXP 8
5699: NOT
5700: PUSH
5701: LD_EXP 36
5705: PUSH
5706: LD_INT 3
5708: LESS
5709: OR
5710: IFFALSE 5688
// ar_can_arrive := true ;
5712: LD_ADDR_EXP 10
5716: PUSH
5717: LD_INT 1
5719: ST_TO_ADDR
// end ;
5720: PPOPN 8
5722: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
5723: LD_INT 1
5725: PPUSH
5726: LD_INT 20
5728: PPUSH
5729: CALL_OW 325
5733: IFFALSE 5874
5735: GO 5737
5737: DISABLE
5738: LD_INT 0
5740: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Cyrus , Bobby , Houten ] ;
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: LD_INT 22
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 26
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: PUSH
5766: LD_INT 25
5768: PUSH
5769: LD_INT 4
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: LIST
5780: PPUSH
5781: CALL_OW 69
5785: PUSH
5786: LD_EXP 19
5790: PUSH
5791: LD_EXP 22
5795: PUSH
5796: LD_EXP 21
5800: PUSH
5801: LD_EXP 23
5805: PUSH
5806: EMPTY
5807: LIST
5808: LIST
5809: LIST
5810: LIST
5811: DIFF
5812: ST_TO_ADDR
// if not un then
5813: LD_VAR 0 1
5817: NOT
5818: IFFALSE 5822
// exit ;
5820: GO 5874
// DialogueOn ;
5822: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
5826: LD_VAR 0 1
5830: PUSH
5831: LD_INT 1
5833: ARRAY
5834: PPUSH
5835: LD_STRING D13-Sci1-1
5837: PPUSH
5838: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
5842: LD_EXP 19
5846: PPUSH
5847: LD_STRING D13-JMM-1
5849: PPUSH
5850: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
5854: LD_VAR 0 1
5858: PUSH
5859: LD_INT 1
5861: ARRAY
5862: PPUSH
5863: LD_STRING D13-Sci1-2
5865: PPUSH
5866: CALL_OW 88
// DialogueOff ;
5870: CALL_OW 7
// end ;
5874: PPOPN 1
5876: END
// every 0 0$1 trigger GetPlayerSib ( 1 ) > 77 and ( not ru_can_attack ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
5877: LD_INT 1
5879: PPUSH
5880: CALL 847 0 1
5884: PUSH
5885: LD_INT 77
5887: GREATER
5888: PUSH
5889: LD_EXP 8
5893: NOT
5894: AND
5895: PUSH
5896: LD_INT 22
5898: PUSH
5899: LD_INT 1
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 25
5908: PUSH
5909: LD_INT 4
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 26
5918: PUSH
5919: LD_INT 1
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: LIST
5930: PPUSH
5931: CALL_OW 69
5935: PUSH
5936: LD_EXP 19
5940: PUSH
5941: LD_EXP 21
5945: PUSH
5946: LD_EXP 22
5950: PUSH
5951: LD_EXP 20
5955: PUSH
5956: LD_EXP 23
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: DIFF
5968: AND
5969: IFFALSE 6147
5971: GO 5973
5973: DISABLE
5974: LD_INT 0
5976: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
5977: LD_ADDR_VAR 0 1
5981: PUSH
5982: LD_INT 22
5984: PUSH
5985: LD_INT 1
5987: PUSH
5988: EMPTY
5989: LIST
5990: LIST
5991: PUSH
5992: LD_INT 25
5994: PUSH
5995: LD_INT 4
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 26
6004: PUSH
6005: LD_INT 1
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: LIST
6016: PPUSH
6017: CALL_OW 69
6021: PUSH
6022: LD_EXP 19
6026: PUSH
6027: LD_EXP 21
6031: PUSH
6032: LD_EXP 22
6036: PUSH
6037: LD_EXP 20
6041: PUSH
6042: LD_EXP 23
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: LIST
6053: DIFF
6054: ST_TO_ADDR
// DialogueOn ;
6055: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6059: LD_VAR 0 1
6063: PUSH
6064: LD_INT 1
6066: ARRAY
6067: PPUSH
6068: LD_STRING D7-Sci1-1
6070: PPUSH
6071: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6075: LD_EXP 19
6079: PPUSH
6080: LD_STRING D7-JMM-1
6082: PPUSH
6083: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6087: LD_VAR 0 1
6091: PUSH
6092: LD_INT 1
6094: ARRAY
6095: PPUSH
6096: LD_STRING D7-Sci1-2
6098: PPUSH
6099: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6103: LD_EXP 19
6107: PPUSH
6108: LD_STRING D7-JMM-2
6110: PPUSH
6111: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6115: LD_VAR 0 1
6119: PUSH
6120: LD_INT 1
6122: ARRAY
6123: PPUSH
6124: LD_STRING D7-Sci1-3
6126: PPUSH
6127: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6131: LD_EXP 19
6135: PPUSH
6136: LD_STRING D7-JMM-3
6138: PPUSH
6139: CALL_OW 88
// DialogueOff ;
6143: CALL_OW 7
// end ;
6147: PPOPN 1
6149: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6150: LD_EXP 10
6154: IFFALSE 9777
6156: GO 6158
6158: DISABLE
6159: LD_INT 0
6161: PPUSH
6162: PPUSH
6163: PPUSH
6164: PPUSH
6165: PPUSH
6166: PPUSH
6167: PPUSH
6168: PPUSH
6169: PPUSH
6170: PPUSH
// begin PrepareArabian ;
6171: CALL 12365 0 0
// blocked := false ;
6175: LD_ADDR_EXP 18
6179: PUSH
6180: LD_INT 0
6182: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6183: LD_INT 35
6185: PPUSH
6186: CALL_OW 67
// until ar_spawned ;
6190: LD_EXP 11
6194: IFFALSE 6183
// have_crates := true ;
6196: LD_ADDR_VAR 0 9
6200: PUSH
6201: LD_INT 1
6203: ST_TO_ADDR
// player_want_info := 2 ;
6204: LD_ADDR_EXP 13
6208: PUSH
6209: LD_INT 2
6211: ST_TO_ADDR
// DialogueOn ;
6212: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6216: LD_EXP 27
6220: PPUSH
6221: LD_STRING D8-Ar1-1
6223: PPUSH
6224: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6228: LD_EXP 19
6232: PPUSH
6233: LD_STRING D8-JMM-1
6235: PPUSH
6236: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6240: LD_EXP 27
6244: PPUSH
6245: LD_STRING D8-Ar1-2
6247: PPUSH
6248: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6252: LD_EXP 19
6256: PPUSH
6257: LD_STRING D8-JMM-2
6259: PPUSH
6260: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6264: LD_EXP 27
6268: PPUSH
6269: LD_STRING D8-Ar1-3
6271: PPUSH
6272: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6276: LD_EXP 19
6280: PPUSH
6281: LD_STRING D8-JMM-3
6283: PPUSH
6284: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6288: LD_EXP 27
6292: PPUSH
6293: LD_STRING D8-Ar1-4
6295: PPUSH
6296: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6300: LD_EXP 19
6304: PPUSH
6305: LD_STRING D8-JMM-4
6307: PPUSH
6308: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6312: LD_EXP 27
6316: PPUSH
6317: LD_STRING D8-Ar1-5
6319: PPUSH
6320: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6324: LD_EXP 19
6328: PPUSH
6329: LD_STRING D8-JMM-5
6331: PPUSH
6332: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6336: LD_EXP 27
6340: PPUSH
6341: LD_STRING D8-Ar1-6
6343: PPUSH
6344: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6348: LD_EXP 28
6352: PPUSH
6353: LD_STRING D8-Ar2-6
6355: PPUSH
6356: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6360: LD_EXP 19
6364: PPUSH
6365: LD_STRING D8-JMM-6
6367: PPUSH
6368: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6372: LD_EXP 28
6376: PPUSH
6377: LD_STRING D8-Ar2-7
6379: PPUSH
6380: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6384: LD_STRING QBarracks
6386: PPUSH
6387: CALL_OW 97
6391: PUSH
6392: LD_INT 1
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6435
6400: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6401: LD_EXP 19
6405: PPUSH
6406: LD_STRING D8a-JMM-1
6408: PPUSH
6409: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6413: LD_EXP 27
6417: PPUSH
6418: LD_STRING D8a-Ar1-1
6420: PPUSH
6421: CALL_OW 94
// player_want_mortar := true ;
6425: LD_ADDR_EXP 12
6429: PUSH
6430: LD_INT 1
6432: ST_TO_ADDR
// end ; 2 :
6433: GO 6609
6435: LD_INT 2
6437: DOUBLE
6438: EQUAL
6439: IFTRUE 6443
6441: GO 6565
6443: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6444: LD_EXP 19
6448: PPUSH
6449: LD_STRING D8b-JMM-1
6451: PPUSH
6452: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6456: LD_EXP 27
6460: PPUSH
6461: LD_STRING D8b-Ar1-1
6463: PPUSH
6464: CALL_OW 94
// case Query ( QInfo ) of 1 :
6468: LD_STRING QInfo
6470: PPUSH
6471: CALL_OW 97
6475: PUSH
6476: LD_INT 1
6478: DOUBLE
6479: EQUAL
6480: IFTRUE 6484
6482: GO 6519
6484: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6485: LD_EXP 19
6489: PPUSH
6490: LD_STRING D8b1-JMM-1
6492: PPUSH
6493: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6497: LD_EXP 27
6501: PPUSH
6502: LD_STRING D8b1-Ar1-1
6504: PPUSH
6505: CALL_OW 94
// player_want_info := 2 ;
6509: LD_ADDR_EXP 13
6513: PUSH
6514: LD_INT 2
6516: ST_TO_ADDR
// end ; 2 :
6517: GO 6563
6519: LD_INT 2
6521: DOUBLE
6522: EQUAL
6523: IFTRUE 6527
6525: GO 6562
6527: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6528: LD_EXP 19
6532: PPUSH
6533: LD_STRING D8b2-JMM-1
6535: PPUSH
6536: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6540: LD_EXP 27
6544: PPUSH
6545: LD_STRING D8b2-Ar1-1
6547: PPUSH
6548: CALL_OW 94
// player_want_info := 0 ;
6552: LD_ADDR_EXP 13
6556: PUSH
6557: LD_INT 0
6559: ST_TO_ADDR
// end ; end ;
6560: GO 6563
6562: POP
// end ; 3 :
6563: GO 6609
6565: LD_INT 3
6567: DOUBLE
6568: EQUAL
6569: IFTRUE 6573
6571: GO 6608
6573: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6574: LD_EXP 19
6578: PPUSH
6579: LD_STRING D8c-JMM-1
6581: PPUSH
6582: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6586: LD_EXP 27
6590: PPUSH
6591: LD_STRING D8c-Ar1-1
6593: PPUSH
6594: CALL_OW 94
// player_want_info := 0 ;
6598: LD_ADDR_EXP 13
6602: PUSH
6603: LD_INT 0
6605: ST_TO_ADDR
// end ; end ;
6606: GO 6609
6608: POP
// DialogueOff ;
6609: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: LD_INT 9
6620: PPUSH
6621: LD_INT 2
6623: PUSH
6624: LD_INT 30
6626: PUSH
6627: LD_INT 0
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 30
6636: PUSH
6637: LD_INT 1
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: LIST
6648: PPUSH
6649: CALL_OW 70
6653: ST_TO_ADDR
// if dep then
6654: LD_VAR 0 4
6658: IFFALSE 6674
// dep := dep [ 1 ] ;
6660: LD_ADDR_VAR 0 4
6664: PUSH
6665: LD_VAR 0 4
6669: PUSH
6670: LD_INT 1
6672: ARRAY
6673: ST_TO_ADDR
// if not dep then
6674: LD_VAR 0 4
6678: NOT
6679: IFFALSE 6717
// begin case Query ( QInfoNothing ) of 1 :
6681: LD_STRING QInfoNothing
6683: PPUSH
6684: CALL_OW 97
6688: PUSH
6689: LD_INT 1
6691: DOUBLE
6692: EQUAL
6693: IFTRUE 6697
6695: GO 6700
6697: POP
// ; end ;
6698: GO 6701
6700: POP
// player_want_info := false ;
6701: LD_ADDR_EXP 13
6705: PUSH
6706: LD_INT 0
6708: ST_TO_ADDR
// player_want_mortar := false ;
6709: LD_ADDR_EXP 12
6713: PUSH
6714: LD_INT 0
6716: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
6717: LD_ADDR_VAR 0 3
6721: PUSH
6722: LD_INT 22
6724: PUSH
6725: LD_INT 2
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: LD_INT 21
6734: PUSH
6735: LD_INT 2
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: PPUSH
6746: CALL_OW 69
6750: ST_TO_ADDR
// time := 1 1$55 ;
6751: LD_ADDR_VAR 0 5
6755: PUSH
6756: LD_INT 4025
6758: ST_TO_ADDR
// no_oil_gain := false ;
6759: LD_ADDR_VAR 0 6
6763: PUSH
6764: LD_INT 0
6766: ST_TO_ADDR
// first_warn := false ;
6767: LD_ADDR_VAR 0 7
6771: PUSH
6772: LD_INT 0
6774: ST_TO_ADDR
// if player_want_mortar or player_want_info then
6775: LD_EXP 12
6779: PUSH
6780: LD_EXP 13
6784: OR
6785: IFFALSE 6890
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
6787: LD_EXP 34
6791: PPUSH
6792: LD_INT 25
6794: PUSH
6795: LD_INT 1
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PPUSH
6802: CALL_OW 72
6806: PPUSH
6807: LD_VAR 0 4
6811: PPUSH
6812: CALL_OW 250
6816: PPUSH
6817: LD_VAR 0 4
6821: PPUSH
6822: CALL_OW 251
6826: PPUSH
6827: LD_VAR 0 4
6831: PPUSH
6832: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
6836: LD_EXP 34
6840: PPUSH
6841: LD_INT 25
6843: PUSH
6844: LD_INT 1
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: PPUSH
6851: CALL_OW 72
6855: PPUSH
6856: LD_INT 86
6858: PPUSH
6859: LD_INT 121
6861: PPUSH
6862: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
6866: LD_EXP 34
6870: PPUSH
6871: LD_INT 25
6873: PUSH
6874: LD_INT 1
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: PPUSH
6881: CALL_OW 72
6885: PPUSH
6886: CALL_OW 200
// end ; if player_attacked_ar then
6890: LD_EXP 16
6894: IFFALSE 6898
// exit ;
6896: GO 9777
// if player_want_mortar then
6898: LD_EXP 12
6902: IFFALSE 8439
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
6904: LD_EXP 28
6908: PPUSH
6909: LD_VAR 0 4
6913: PPUSH
6914: CALL_OW 250
6918: PUSH
6919: LD_INT 1
6921: PLUS
6922: PPUSH
6923: LD_VAR 0 4
6927: PPUSH
6928: CALL_OW 251
6932: PUSH
6933: LD_INT 1
6935: PLUS
6936: PPUSH
6937: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6941: LD_INT 35
6943: PPUSH
6944: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
6948: LD_EXP 28
6952: PPUSH
6953: LD_VAR 0 4
6957: PPUSH
6958: CALL_OW 296
6962: PUSH
6963: LD_INT 4
6965: LESS
6966: IFFALSE 6941
// for i = 1 to 6 do
6968: LD_ADDR_VAR 0 1
6972: PUSH
6973: DOUBLE
6974: LD_INT 1
6976: DEC
6977: ST_TO_ADDR
6978: LD_INT 6
6980: PUSH
6981: FOR_TO
6982: IFFALSE 7186
// begin if player_attacked_ar then
6984: LD_EXP 16
6988: IFFALSE 6994
// exit ;
6990: POP
6991: POP
6992: GO 9777
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
6994: LD_VAR 0 4
6998: PPUSH
6999: CALL_OW 274
7003: PPUSH
7004: LD_INT 2
7006: PPUSH
7007: CALL_OW 275
7011: PUSH
7012: LD_INT 10
7014: LESS
7015: PUSH
7016: LD_VAR 0 7
7020: NOT
7021: AND
7022: IFFALSE 7085
// begin first_warn := true ;
7024: LD_ADDR_VAR 0 7
7028: PUSH
7029: LD_INT 1
7031: ST_TO_ADDR
// DialogueOn ;
7032: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7036: LD_EXP 29
7040: PPUSH
7041: LD_STRING D9a-FAr1-1
7043: PPUSH
7044: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7048: LD_EXP 19
7052: PPUSH
7053: LD_STRING D9a-JMM-1
7055: PPUSH
7056: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7060: LD_EXP 27
7064: PPUSH
7065: LD_STRING D9a2-Ar1-1
7067: PPUSH
7068: CALL_OW 88
// DialogueOff ;
7072: CALL_OW 7
// wait ( time ) ;
7076: LD_VAR 0 5
7080: PPUSH
7081: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7085: LD_VAR 0 4
7089: PPUSH
7090: CALL_OW 274
7094: PPUSH
7095: LD_INT 2
7097: PPUSH
7098: CALL_OW 275
7102: PUSH
7103: LD_INT 10
7105: LESS
7106: IFFALSE 7132
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7108: LD_EXP 27
7112: PPUSH
7113: LD_STRING D9a3-Ar1-1
7115: PPUSH
7116: CALL_OW 88
// no_oil_gain := true ;
7120: LD_ADDR_VAR 0 6
7124: PUSH
7125: LD_INT 1
7127: ST_TO_ADDR
// break ;
7128: GO 7186
// end else
7130: GO 7184
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7132: LD_EXP 28
7136: PPUSH
7137: LD_VAR 0 4
7141: PPUSH
7142: LD_INT 2
7144: PPUSH
7145: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7149: LD_EXP 28
7153: PPUSH
7154: LD_VAR 0 3
7158: PUSH
7159: LD_VAR 0 1
7163: PUSH
7164: LD_INT 3
7166: MOD
7167: PUSH
7168: LD_INT 1
7170: PLUS
7171: ARRAY
7172: PPUSH
7173: CALL_OW 210
// wait ( 0 0$10 ) ;
7177: LD_INT 350
7179: PPUSH
7180: CALL_OW 67
// end ; end ;
7184: GO 6981
7186: POP
7187: POP
// if not no_oil_gain then
7188: LD_VAR 0 6
7192: NOT
7193: IFFALSE 8439
// begin repeat wait ( 0 0$01 ) ;
7195: LD_INT 35
7197: PPUSH
7198: CALL_OW 67
// if player_attacked_ar then
7202: LD_EXP 16
7206: IFFALSE 7210
// exit ;
7208: GO 9777
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7210: LD_VAR 0 3
7214: PUSH
7215: LD_INT 1
7217: ARRAY
7218: PPUSH
7219: CALL_OW 261
7223: PUSH
7224: LD_INT 80
7226: GREATER
7227: PUSH
7228: LD_VAR 0 3
7232: PUSH
7233: LD_INT 2
7235: ARRAY
7236: PPUSH
7237: CALL_OW 261
7241: PUSH
7242: LD_INT 80
7244: GREATER
7245: AND
7246: PUSH
7247: LD_VAR 0 3
7251: PUSH
7252: LD_INT 3
7254: ARRAY
7255: PPUSH
7256: CALL_OW 261
7260: PUSH
7261: LD_INT 80
7263: GREATER
7264: AND
7265: IFFALSE 7195
// ComMoveXY ( Gali , 105 , 127 ) ;
7267: LD_EXP 28
7271: PPUSH
7272: LD_INT 105
7274: PPUSH
7275: LD_INT 127
7277: PPUSH
7278: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7282: LD_EXP 28
7286: PPUSH
7287: LD_INT 2
7289: PPUSH
7290: CALL_OW 173
// AddComHold ( Gali ) ;
7294: LD_EXP 28
7298: PPUSH
7299: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7303: LD_INT 35
7305: PPUSH
7306: CALL_OW 67
// if player_attacked_ar then
7310: LD_EXP 16
7314: IFFALSE 7318
// exit ;
7316: GO 9777
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7318: LD_EXP 28
7322: PPUSH
7323: LD_INT 105
7325: PPUSH
7326: LD_INT 127
7328: PPUSH
7329: CALL_OW 297
7333: PUSH
7334: LD_INT 4
7336: LESS
7337: IFFALSE 7303
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7339: LD_VAR 0 4
7343: PPUSH
7344: CALL_OW 274
7348: PPUSH
7349: LD_INT 1
7351: PPUSH
7352: CALL_OW 275
7356: PUSH
7357: LD_INT 50
7359: LESS
7360: IFFALSE 7662
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7362: LD_VAR 0 4
7366: PPUSH
7367: CALL_OW 274
7371: PPUSH
7372: LD_INT 1
7374: PPUSH
7375: CALL_OW 275
7379: PUSH
7380: LD_INT 0
7382: DOUBLE
7383: GREATEREQUAL
7384: IFFALSE 7392
7386: LD_INT 24
7388: DOUBLE
7389: LESSEQUAL
7390: IFTRUE 7394
7392: GO 7409
7394: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7395: LD_EXP 28
7399: PPUSH
7400: LD_STRING D9b-Ar2-1
7402: PPUSH
7403: CALL_OW 88
7407: GO 7439
7409: LD_INT 25
7411: DOUBLE
7412: GREATEREQUAL
7413: IFFALSE 7421
7415: LD_INT 49
7417: DOUBLE
7418: LESSEQUAL
7419: IFTRUE 7423
7421: GO 7438
7423: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7424: LD_EXP 28
7428: PPUSH
7429: LD_STRING D9b-Ar2-1a
7431: PPUSH
7432: CALL_OW 88
7436: GO 7439
7438: POP
// Say ( JMM , D9b-JMM-1 ) ;
7439: LD_EXP 19
7443: PPUSH
7444: LD_STRING D9b-JMM-1
7446: PPUSH
7447: CALL_OW 88
// x := 0 0$0 ;
7451: LD_ADDR_VAR 0 2
7455: PUSH
7456: LD_INT 0
7458: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7459: LD_INT 35
7461: PPUSH
7462: CALL_OW 67
// x := x + 0 0$1 ;
7466: LD_ADDR_VAR 0 2
7470: PUSH
7471: LD_VAR 0 2
7475: PUSH
7476: LD_INT 35
7478: PLUS
7479: ST_TO_ADDR
// if player_attacked_ar then
7480: LD_EXP 16
7484: IFFALSE 7488
// exit ;
7486: GO 9777
// until x >= time ;
7488: LD_VAR 0 2
7492: PUSH
7493: LD_VAR 0 5
7497: GREATEREQUAL
7498: IFFALSE 7459
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7500: LD_VAR 0 4
7504: PPUSH
7505: CALL_OW 274
7509: PPUSH
7510: LD_INT 1
7512: PPUSH
7513: CALL_OW 275
7517: PUSH
7518: LD_INT 50
7520: LESS
7521: IFFALSE 7662
// begin have_crates := false ;
7523: LD_ADDR_VAR 0 9
7527: PUSH
7528: LD_INT 0
7530: ST_TO_ADDR
// DialogueOn ;
7531: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7535: LD_EXP 27
7539: PPUSH
7540: LD_STRING D9c-Ar1-1
7542: PPUSH
7543: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7547: LD_EXP 19
7551: PPUSH
7552: LD_STRING D9c-JMM-1
7554: PPUSH
7555: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7559: LD_EXP 27
7563: PPUSH
7564: LD_STRING D9c-Ar1-2
7566: PPUSH
7567: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7571: LD_EXP 29
7575: PPUSH
7576: LD_STRING D9c-FAr1-2
7578: PPUSH
7579: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7583: LD_EXP 27
7587: PPUSH
7588: LD_STRING D9c-Ar1-3
7590: PPUSH
7591: CALL_OW 88
// case Query ( QInfo ) of 1 :
7595: LD_STRING QInfo
7597: PPUSH
7598: CALL_OW 97
7602: PUSH
7603: LD_INT 1
7605: DOUBLE
7606: EQUAL
7607: IFTRUE 7611
7609: GO 7634
7611: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7612: LD_EXP 19
7616: PPUSH
7617: LD_STRING D8b1-JMM-1
7619: PPUSH
7620: CALL_OW 88
// player_want_info := 2 ;
7624: LD_ADDR_EXP 13
7628: PUSH
7629: LD_INT 2
7631: ST_TO_ADDR
// end ; 2 :
7632: GO 7658
7634: LD_INT 2
7636: DOUBLE
7637: EQUAL
7638: IFTRUE 7642
7640: GO 7657
7642: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7643: LD_EXP 27
7647: PPUSH
7648: LD_STRING D8b2-Ar1-1
7650: PPUSH
7651: CALL_OW 88
// end ; end ;
7655: GO 7658
7657: POP
// DialogueOff ;
7658: CALL_OW 7
// end ; end ; if have_crates then
7662: LD_VAR 0 9
7666: IFFALSE 8439
// begin RemoveEnvironmentArea ( mortarArea ) ;
7668: LD_INT 2
7670: PPUSH
7671: CALL_OW 355
// wait ( 1 ) ;
7675: LD_INT 1
7677: PPUSH
7678: CALL_OW 67
// InGameOn ;
7682: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7686: LD_EXP 28
7690: PPUSH
7691: CALL_OW 87
// SetSide ( Gali , 1 ) ;
7695: LD_EXP 28
7699: PPUSH
7700: LD_INT 1
7702: PPUSH
7703: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
7707: LD_ADDR_VAR 0 10
7711: PUSH
7712: LD_INT 22
7714: PUSH
7715: LD_INT 1
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PUSH
7722: LD_INT 3
7724: PUSH
7725: LD_INT 23
7727: PUSH
7728: LD_INT 2
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: LD_INT 21
7741: PUSH
7742: LD_INT 1
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 92
7751: PUSH
7752: LD_INT 107
7754: PUSH
7755: LD_INT 131
7757: PUSH
7758: LD_INT 6
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: LIST
7771: LIST
7772: PPUSH
7773: CALL_OW 69
7777: ST_TO_ADDR
// if filter then
7778: LD_VAR 0 10
7782: IFFALSE 7816
// for i in filter do
7784: LD_ADDR_VAR 0 1
7788: PUSH
7789: LD_VAR 0 10
7793: PUSH
7794: FOR_IN
7795: IFFALSE 7814
// ComMoveXY ( i , 107 , 121 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 107
7804: PPUSH
7805: LD_INT 121
7807: PPUSH
7808: CALL_OW 111
7812: GO 7794
7814: POP
7815: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
7816: LD_EXP 28
7820: PPUSH
7821: LD_INT 4
7823: PPUSH
7824: LD_INT 107
7826: PPUSH
7827: LD_INT 131
7829: PPUSH
7830: LD_INT 0
7832: PPUSH
7833: CALL_OW 145
// wait ( 0 0$1 ) ;
7837: LD_INT 35
7839: PPUSH
7840: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
7844: LD_INT 30
7846: PUSH
7847: LD_INT 4
7849: PUSH
7850: EMPTY
7851: LIST
7852: LIST
7853: PUSH
7854: LD_INT 23
7856: PUSH
7857: LD_INT 2
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PUSH
7864: EMPTY
7865: LIST
7866: LIST
7867: PPUSH
7868: CALL_OW 69
7872: IFFALSE 7707
// SetSide ( Gali , 2 ) ;
7874: LD_EXP 28
7878: PPUSH
7879: LD_INT 2
7881: PPUSH
7882: CALL_OW 235
// InGameOff ;
7886: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
7890: LD_ADDR_VAR 0 8
7894: PUSH
7895: LD_INT 30
7897: PUSH
7898: LD_INT 4
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: PUSH
7905: LD_INT 23
7907: PUSH
7908: LD_INT 2
7910: PUSH
7911: EMPTY
7912: LIST
7913: LIST
7914: PUSH
7915: EMPTY
7916: LIST
7917: LIST
7918: PPUSH
7919: CALL_OW 69
7923: PUSH
7924: LD_INT 1
7926: ARRAY
7927: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7928: LD_INT 35
7930: PPUSH
7931: CALL_OW 67
// if player_attacked_ar then
7935: LD_EXP 16
7939: IFFALSE 7943
// exit ;
7941: GO 9777
// until BuildingStatus ( b ) <> bs_build ;
7943: LD_VAR 0 8
7947: PPUSH
7948: CALL_OW 461
7952: PUSH
7953: LD_INT 1
7955: NONEQUAL
7956: IFFALSE 7928
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
7958: LD_VAR 0 8
7962: PPUSH
7963: CALL_OW 302
7967: PUSH
7968: LD_VAR 0 4
7972: PPUSH
7973: CALL_OW 274
7977: PPUSH
7978: LD_INT 1
7980: PPUSH
7981: CALL_OW 275
7985: PUSH
7986: LD_INT 25
7988: GREATEREQUAL
7989: AND
7990: IFFALSE 8089
// begin ComUpgrade ( b ) ;
7992: LD_VAR 0 8
7996: PPUSH
7997: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8001: LD_EXP 28
8005: PPUSH
8006: LD_STRING h
8008: PUSH
8009: LD_VAR 0 8
8013: PPUSH
8014: CALL_OW 250
8018: PUSH
8019: LD_VAR 0 8
8023: PPUSH
8024: CALL_OW 251
8028: PUSH
8029: LD_VAR 0 8
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: LD_INT 0
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8059: LD_INT 35
8061: PPUSH
8062: CALL_OW 67
// if player_attacked_ar then
8066: LD_EXP 16
8070: IFFALSE 8074
// exit ;
8072: GO 9777
// until BuildingStatus ( b ) <> bs_build ;
8074: LD_VAR 0 8
8078: PPUSH
8079: CALL_OW 461
8083: PUSH
8084: LD_INT 1
8086: NONEQUAL
8087: IFFALSE 8059
// end ; if b then
8089: LD_VAR 0 8
8093: IFFALSE 8104
// CenterNowOnUnits ( b ) ;
8095: LD_VAR 0 8
8099: PPUSH
8100: CALL_OW 87
// DialogueOn ;
8104: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8108: LD_EXP 28
8112: PPUSH
8113: LD_STRING D9d-Ar2-1
8115: PPUSH
8116: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8120: LD_EXP 27
8124: PPUSH
8125: LD_STRING D9d-Ar1-1
8127: PPUSH
8128: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8132: LD_EXP 19
8136: PPUSH
8137: LD_STRING D9d-JMM-1
8139: PPUSH
8140: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8144: LD_EXP 27
8148: PPUSH
8149: LD_STRING D9d-Ar1-2
8151: PPUSH
8152: CALL_OW 88
// DialogueOff ;
8156: CALL_OW 7
// i := [ ] ;
8160: LD_ADDR_VAR 0 1
8164: PUSH
8165: EMPTY
8166: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8167: LD_VAR 0 4
8171: PPUSH
8172: CALL_OW 274
8176: PPUSH
8177: LD_INT 3
8179: PPUSH
8180: CALL_OW 275
8184: PUSH
8185: LD_INT 20
8187: GREATEREQUAL
8188: IFFALSE 8207
// i := i ^ [ 1 ] ;
8190: LD_ADDR_VAR 0 1
8194: PUSH
8195: LD_VAR 0 1
8199: PUSH
8200: LD_INT 1
8202: PUSH
8203: EMPTY
8204: LIST
8205: ADD
8206: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8207: LD_VAR 0 4
8211: PPUSH
8212: CALL_OW 274
8216: PPUSH
8217: LD_INT 1
8219: PPUSH
8220: CALL_OW 275
8224: PUSH
8225: LD_INT 50
8227: GREATEREQUAL
8228: IFFALSE 8247
// i := i ^ [ 2 ] ;
8230: LD_ADDR_VAR 0 1
8234: PUSH
8235: LD_VAR 0 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: EMPTY
8244: LIST
8245: ADD
8246: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8247: LD_VAR 0 4
8251: PPUSH
8252: CALL_OW 274
8256: PPUSH
8257: LD_INT 2
8259: PPUSH
8260: CALL_OW 275
8264: PUSH
8265: LD_INT 80
8267: GREATEREQUAL
8268: IFFALSE 8287
// i := i ^ [ 3 ] ;
8270: LD_ADDR_VAR 0 1
8274: PUSH
8275: LD_VAR 0 1
8279: PUSH
8280: LD_INT 3
8282: PUSH
8283: EMPTY
8284: LIST
8285: ADD
8286: ST_TO_ADDR
// i := i diff 0 ;
8287: LD_ADDR_VAR 0 1
8291: PUSH
8292: LD_VAR 0 1
8296: PUSH
8297: LD_INT 0
8299: DIFF
8300: ST_TO_ADDR
// if i then
8301: LD_VAR 0 1
8305: IFFALSE 8411
// begin i := i ^ [ 4 ] ;
8307: LD_ADDR_VAR 0 1
8311: PUSH
8312: LD_VAR 0 1
8316: PUSH
8317: LD_INT 4
8319: PUSH
8320: EMPTY
8321: LIST
8322: ADD
8323: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8324: LD_STRING QInfo2
8326: PPUSH
8327: CALL_OW 97
8331: PUSH
8332: LD_INT 1
8334: DOUBLE
8335: EQUAL
8336: IFTRUE 8340
8338: GO 8351
8340: POP
// player_want_info := 3 ; 2 :
8341: LD_ADDR_EXP 13
8345: PUSH
8346: LD_INT 3
8348: ST_TO_ADDR
8349: GO 8409
8351: LD_INT 2
8353: DOUBLE
8354: EQUAL
8355: IFTRUE 8359
8357: GO 8370
8359: POP
// player_want_info := 1 ; 3 :
8360: LD_ADDR_EXP 13
8364: PUSH
8365: LD_INT 1
8367: ST_TO_ADDR
8368: GO 8409
8370: LD_INT 3
8372: DOUBLE
8373: EQUAL
8374: IFTRUE 8378
8376: GO 8389
8378: POP
// player_want_info := 2 ; 4 :
8379: LD_ADDR_EXP 13
8383: PUSH
8384: LD_INT 2
8386: ST_TO_ADDR
8387: GO 8409
8389: LD_INT 4
8391: DOUBLE
8392: EQUAL
8393: IFTRUE 8397
8395: GO 8408
8397: POP
// player_want_info := 0 ; end ;
8398: LD_ADDR_EXP 13
8402: PUSH
8403: LD_INT 0
8405: ST_TO_ADDR
8406: GO 8409
8408: POP
// end else
8409: GO 8439
// case Query ( QInfoNothing ) of 1 :
8411: LD_STRING QInfoNothing
8413: PPUSH
8414: CALL_OW 97
8418: PUSH
8419: LD_INT 1
8421: DOUBLE
8422: EQUAL
8423: IFTRUE 8427
8425: GO 8438
8427: POP
// player_want_info := 0 ; end ;
8428: LD_ADDR_EXP 13
8432: PUSH
8433: LD_INT 0
8435: ST_TO_ADDR
8436: GO 8439
8438: POP
// end ; end ; end ; if player_want_info then
8439: LD_EXP 13
8443: IFFALSE 9597
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8445: LD_ADDR_VAR 0 3
8449: PUSH
8450: LD_VAR 0 3
8454: PPUSH
8455: LD_INT 34
8457: PUSH
8458: LD_INT 32
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: ST_TO_ADDR
// if player_want_mortar then
8470: LD_EXP 12
8474: IFFALSE 8829
// begin case player_want_info of 1 :
8476: LD_EXP 13
8480: PUSH
8481: LD_INT 1
8483: DOUBLE
8484: EQUAL
8485: IFTRUE 8489
8487: GO 8500
8489: POP
// x := 5 ; 2 :
8490: LD_ADDR_VAR 0 2
8494: PUSH
8495: LD_INT 5
8497: ST_TO_ADDR
8498: GO 8539
8500: LD_INT 2
8502: DOUBLE
8503: EQUAL
8504: IFTRUE 8508
8506: GO 8519
8508: POP
// x := 8 ; 3 :
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_INT 8
8516: ST_TO_ADDR
8517: GO 8539
8519: LD_INT 3
8521: DOUBLE
8522: EQUAL
8523: IFTRUE 8527
8525: GO 8538
8527: POP
// x := 2 ; end ;
8528: LD_ADDR_VAR 0 2
8532: PUSH
8533: LD_INT 2
8535: ST_TO_ADDR
8536: GO 8539
8538: POP
// repeat wait ( 0 0$1 ) ;
8539: LD_INT 35
8541: PPUSH
8542: CALL_OW 67
// until not HasTask ( Gali ) ;
8546: LD_EXP 28
8550: PPUSH
8551: CALL_OW 314
8555: NOT
8556: IFFALSE 8539
// time := 0 0$00 ;
8558: LD_ADDR_VAR 0 5
8562: PUSH
8563: LD_INT 0
8565: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8566: LD_INT 35
8568: PPUSH
8569: CALL_OW 67
// time := time + 0 0$1 ;
8573: LD_ADDR_VAR 0 5
8577: PUSH
8578: LD_VAR 0 5
8582: PUSH
8583: LD_INT 35
8585: PLUS
8586: ST_TO_ADDR
// if debug then
8587: LD_EXP 2
8591: IFFALSE 8610
// debug_strings := [ time: & time ] ;
8593: LD_ADDR_OWVAR 48
8597: PUSH
8598: LD_STRING time:
8600: PUSH
8601: LD_VAR 0 5
8605: STR
8606: PUSH
8607: EMPTY
8608: LIST
8609: ST_TO_ADDR
// if time > 8 8$00 then
8610: LD_VAR 0 5
8614: PUSH
8615: LD_INT 16800
8617: GREATER
8618: IFFALSE 8630
// begin blocked := true ;
8620: LD_ADDR_EXP 18
8624: PUSH
8625: LD_INT 1
8627: ST_TO_ADDR
// exit ;
8628: GO 9777
// end ; if not Carry ( Gali ) then
8630: LD_EXP 28
8634: PPUSH
8635: CALL_OW 281
8639: NOT
8640: IFFALSE 8663
// ComTransport ( Gali , dep , player_want_info ) else
8642: LD_EXP 28
8646: PPUSH
8647: LD_VAR 0 4
8651: PPUSH
8652: LD_EXP 13
8656: PPUSH
8657: CALL_OW 151
8661: GO 8781
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8663: LD_EXP 28
8667: PPUSH
8668: LD_VAR 0 3
8672: PUSH
8673: LD_INT 1
8675: ARRAY
8676: PPUSH
8677: CALL_OW 296
8681: PUSH
8682: LD_INT 4
8684: LESS
8685: PUSH
8686: LD_EXP 28
8690: PPUSH
8691: LD_EXP 13
8695: PPUSH
8696: CALL_OW 289
8700: AND
8701: IFFALSE 8763
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
8703: LD_VAR 0 3
8707: PUSH
8708: LD_INT 1
8710: ARRAY
8711: PPUSH
8712: LD_EXP 13
8716: PPUSH
8717: LD_VAR 0 3
8721: PUSH
8722: LD_INT 1
8724: ARRAY
8725: PPUSH
8726: LD_EXP 13
8730: PPUSH
8731: CALL_OW 289
8735: PUSH
8736: LD_INT 10
8738: PLUS
8739: PPUSH
8740: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
8744: LD_EXP 28
8748: PPUSH
8749: LD_EXP 13
8753: PPUSH
8754: LD_INT 0
8756: PPUSH
8757: CALL_OW 290
// end else
8761: GO 8781
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
8763: LD_EXP 28
8767: PPUSH
8768: LD_VAR 0 3
8772: PUSH
8773: LD_INT 1
8775: ARRAY
8776: PPUSH
8777: CALL_OW 112
// end ; if player_attacked_ar then
8781: LD_EXP 16
8785: IFFALSE 8789
// exit ;
8787: GO 9777
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
8789: LD_VAR 0 3
8793: PUSH
8794: LD_INT 1
8796: ARRAY
8797: PPUSH
8798: LD_EXP 13
8802: PPUSH
8803: CALL_OW 289
8807: PUSH
8808: LD_VAR 0 2
8812: PUSH
8813: LD_INT 10
8815: MUL
8816: GREATEREQUAL
8817: IFFALSE 8566
// no_oil_gain := false ;
8819: LD_ADDR_VAR 0 6
8823: PUSH
8824: LD_INT 0
8826: ST_TO_ADDR
// end else
8827: GO 9418
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_INT 22
8836: PUSH
8837: LD_INT 2
8839: PUSH
8840: EMPTY
8841: LIST
8842: LIST
8843: PUSH
8844: LD_INT 21
8846: PUSH
8847: LD_INT 2
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PPUSH
8858: CALL_OW 69
8862: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
8863: LD_EXP 28
8867: PPUSH
8868: LD_VAR 0 4
8872: PPUSH
8873: CALL_OW 250
8877: PUSH
8878: LD_INT 1
8880: PLUS
8881: PPUSH
8882: LD_VAR 0 4
8886: PPUSH
8887: CALL_OW 251
8891: PUSH
8892: LD_INT 1
8894: PLUS
8895: PPUSH
8896: CALL_OW 111
// time := 0 0$00 ;
8900: LD_ADDR_VAR 0 5
8904: PUSH
8905: LD_INT 0
8907: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8908: LD_INT 35
8910: PPUSH
8911: CALL_OW 67
// time := time + 0 0$1 ;
8915: LD_ADDR_VAR 0 5
8919: PUSH
8920: LD_VAR 0 5
8924: PUSH
8925: LD_INT 35
8927: PLUS
8928: ST_TO_ADDR
// if time > 1 1$45 then
8929: LD_VAR 0 5
8933: PUSH
8934: LD_INT 3675
8936: GREATER
8937: IFFALSE 8941
// break ;
8939: GO 8961
// until GetDistUnits ( Gali , dep ) < 4 ;
8941: LD_EXP 28
8945: PPUSH
8946: LD_VAR 0 4
8950: PPUSH
8951: CALL_OW 296
8955: PUSH
8956: LD_INT 4
8958: LESS
8959: IFFALSE 8908
// for i = 1 to 6 do
8961: LD_ADDR_VAR 0 1
8965: PUSH
8966: DOUBLE
8967: LD_INT 1
8969: DEC
8970: ST_TO_ADDR
8971: LD_INT 6
8973: PUSH
8974: FOR_TO
8975: IFFALSE 9179
// begin if player_attacked_ar then
8977: LD_EXP 16
8981: IFFALSE 8987
// exit ;
8983: POP
8984: POP
8985: GO 9777
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
8987: LD_VAR 0 4
8991: PPUSH
8992: CALL_OW 274
8996: PPUSH
8997: LD_INT 2
8999: PPUSH
9000: CALL_OW 275
9004: PUSH
9005: LD_INT 10
9007: LESS
9008: PUSH
9009: LD_VAR 0 7
9013: NOT
9014: AND
9015: IFFALSE 9078
// begin first_warn := true ;
9017: LD_ADDR_VAR 0 7
9021: PUSH
9022: LD_INT 1
9024: ST_TO_ADDR
// DialogueOn ;
9025: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9029: LD_EXP 29
9033: PPUSH
9034: LD_STRING D9a-FAr1-1
9036: PPUSH
9037: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9041: LD_EXP 19
9045: PPUSH
9046: LD_STRING D9a-JMM-1
9048: PPUSH
9049: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9053: LD_EXP 27
9057: PPUSH
9058: LD_STRING D9a2-Ar1-1
9060: PPUSH
9061: CALL_OW 88
// DialogueOff ;
9065: CALL_OW 7
// wait ( time ) ;
9069: LD_VAR 0 5
9073: PPUSH
9074: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9078: LD_VAR 0 4
9082: PPUSH
9083: CALL_OW 274
9087: PPUSH
9088: LD_INT 2
9090: PPUSH
9091: CALL_OW 275
9095: PUSH
9096: LD_INT 10
9098: LESS
9099: IFFALSE 9125
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9101: LD_EXP 27
9105: PPUSH
9106: LD_STRING D9a3-Ar1-1
9108: PPUSH
9109: CALL_OW 88
// no_oil_gain := true ;
9113: LD_ADDR_VAR 0 6
9117: PUSH
9118: LD_INT 1
9120: ST_TO_ADDR
// break ;
9121: GO 9179
// end else
9123: GO 9177
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9125: LD_EXP 28
9129: PPUSH
9130: LD_VAR 0 4
9134: PPUSH
9135: LD_INT 2
9137: PPUSH
9138: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9142: LD_EXP 28
9146: PPUSH
9147: LD_VAR 0 3
9151: PUSH
9152: LD_VAR 0 1
9156: PUSH
9157: LD_INT 3
9159: MOD
9160: PUSH
9161: LD_INT 1
9163: PLUS
9164: ARRAY
9165: PPUSH
9166: CALL_OW 210
// wait ( 0 0$10 ) ;
9170: LD_INT 350
9172: PPUSH
9173: CALL_OW 67
// end ; end ;
9177: GO 8974
9179: POP
9180: POP
// time := 0 0$00 ;
9181: LD_ADDR_VAR 0 5
9185: PUSH
9186: LD_INT 0
9188: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9189: LD_INT 35
9191: PPUSH
9192: CALL_OW 67
// if not HasTask ( Gali ) then
9196: LD_EXP 28
9200: PPUSH
9201: CALL_OW 314
9205: NOT
9206: IFFALSE 9222
// time := time + 0 0$1 ;
9208: LD_ADDR_VAR 0 5
9212: PUSH
9213: LD_VAR 0 5
9217: PUSH
9218: LD_INT 35
9220: PLUS
9221: ST_TO_ADDR
// if time > 1 1$25 then
9222: LD_VAR 0 5
9226: PUSH
9227: LD_INT 2975
9229: GREATER
9230: IFFALSE 9254
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9232: LD_EXP 27
9236: PPUSH
9237: LD_STRING D9a3-Ar1-1
9239: PPUSH
9240: CALL_OW 88
// no_oil_gain := true ;
9244: LD_ADDR_VAR 0 6
9248: PUSH
9249: LD_INT 1
9251: ST_TO_ADDR
// break ;
9252: GO 9418
// end ; if player_attacked_ar then
9254: LD_EXP 16
9258: IFFALSE 9262
// exit ;
9260: GO 9777
// for i in tmp do
9262: LD_ADDR_VAR 0 1
9266: PUSH
9267: LD_VAR 0 3
9271: PUSH
9272: FOR_IN
9273: IFFALSE 9304
// if GetFuel ( i ) < 100 then
9275: LD_VAR 0 1
9279: PPUSH
9280: CALL_OW 261
9284: PUSH
9285: LD_INT 100
9287: LESS
9288: IFFALSE 9302
// begin x := i ;
9290: LD_ADDR_VAR 0 2
9294: PUSH
9295: LD_VAR 0 1
9299: ST_TO_ADDR
// break ;
9300: GO 9304
// end ;
9302: GO 9272
9304: POP
9305: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9306: LD_EXP 28
9310: PPUSH
9311: CALL_OW 314
9315: NOT
9316: PUSH
9317: LD_EXP 28
9321: PPUSH
9322: CALL_OW 281
9326: NOT
9327: AND
9328: IFFALSE 9361
// begin ComTransport ( Gali , dep , mat_oil ) ;
9330: LD_EXP 28
9334: PPUSH
9335: LD_VAR 0 4
9339: PPUSH
9340: LD_INT 2
9342: PPUSH
9343: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9347: LD_EXP 28
9351: PPUSH
9352: LD_VAR 0 2
9356: PPUSH
9357: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 1
9368: ARRAY
9369: PPUSH
9370: CALL_OW 261
9374: PUSH
9375: LD_INT 80
9377: GREATER
9378: PUSH
9379: LD_VAR 0 3
9383: PUSH
9384: LD_INT 2
9386: ARRAY
9387: PPUSH
9388: CALL_OW 261
9392: PUSH
9393: LD_INT 80
9395: GREATER
9396: AND
9397: PUSH
9398: LD_VAR 0 3
9402: PUSH
9403: LD_INT 3
9405: ARRAY
9406: PPUSH
9407: CALL_OW 261
9411: PUSH
9412: LD_INT 80
9414: GREATER
9415: AND
9416: IFFALSE 9189
// end ; ComHold ( Gali ) ;
9418: LD_EXP 28
9422: PPUSH
9423: CALL_OW 140
// if not no_oil_gain then
9427: LD_VAR 0 6
9431: NOT
9432: IFFALSE 9597
// begin DialogueOn ;
9434: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9438: LD_EXP 27
9442: PPUSH
9443: CALL_OW 87
// if player_want_mortar then
9447: LD_EXP 12
9451: IFFALSE 9477
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9453: LD_EXP 27
9457: PPUSH
9458: LD_STRING D9e-Ar1-1
9460: PPUSH
9461: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9465: LD_EXP 19
9469: PPUSH
9470: LD_STRING D10a-JMM-1
9472: PPUSH
9473: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9477: LD_EXP 27
9481: PPUSH
9482: LD_STRING D10a-Ar1-1
9484: PPUSH
9485: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9489: LD_EXP 28
9493: PPUSH
9494: LD_STRING D10a-Ar2-1
9496: PPUSH
9497: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9501: LD_EXP 29
9505: PPUSH
9506: LD_STRING D10a-FAr1-1
9508: PPUSH
9509: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9513: LD_EXP 28
9517: PPUSH
9518: LD_STRING D10a-Ar2-2
9520: PPUSH
9521: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9525: LD_EXP 29
9529: PPUSH
9530: LD_STRING D10a-FAr1-2
9532: PPUSH
9533: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9537: LD_EXP 27
9541: PPUSH
9542: LD_STRING D10a-Ar1-2
9544: PPUSH
9545: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9549: LD_EXP 19
9553: PPUSH
9554: LD_STRING D10a-JMM-2
9556: PPUSH
9557: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9561: LD_EXP 27
9565: PPUSH
9566: LD_STRING D10a-Ar1-3
9568: PPUSH
9569: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9573: LD_EXP 19
9577: PPUSH
9578: LD_STRING D10a-JMM-3
9580: PPUSH
9581: CALL_OW 88
// player_get_info := true ;
9585: LD_ADDR_EXP 15
9589: PUSH
9590: LD_INT 1
9592: ST_TO_ADDR
// DialogueOff ;
9593: CALL_OW 7
// end ; end ; if player_attacked_ar then
9597: LD_EXP 16
9601: IFFALSE 9605
// exit ;
9603: GO 9777
// if player_want_mortar or player_want_info then
9605: LD_EXP 12
9609: PUSH
9610: LD_EXP 13
9614: OR
9615: IFFALSE 9629
// Say ( Vervecken , D9f-Ar1-1 ) ;
9617: LD_EXP 27
9621: PPUSH
9622: LD_STRING D9f-Ar1-1
9624: PPUSH
9625: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9629: LD_INT 22
9631: PUSH
9632: LD_INT 2
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PPUSH
9639: CALL_OW 69
9643: PPUSH
9644: LD_INT 51
9646: PPUSH
9647: LD_INT 99
9649: PPUSH
9650: CALL_OW 111
// wait ( 0 0$1 ) ;
9654: LD_INT 35
9656: PPUSH
9657: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9661: LD_INT 22
9663: PUSH
9664: LD_INT 2
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: PUSH
9671: LD_INT 92
9673: PUSH
9674: LD_INT 51
9676: PUSH
9677: LD_INT 99
9679: PUSH
9680: LD_INT 2
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: PUSH
9689: EMPTY
9690: LIST
9691: LIST
9692: PPUSH
9693: CALL_OW 69
9697: IFFALSE 9757
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9699: LD_ADDR_VAR 0 1
9703: PUSH
9704: LD_INT 22
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 92
9716: PUSH
9717: LD_INT 51
9719: PUSH
9720: LD_INT 99
9722: PUSH
9723: LD_INT 2
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: PUSH
9732: EMPTY
9733: LIST
9734: LIST
9735: PPUSH
9736: CALL_OW 69
9740: PUSH
9741: FOR_IN
9742: IFFALSE 9755
// RemoveUnit ( i ) ;
9744: LD_VAR 0 1
9748: PPUSH
9749: CALL_OW 64
9753: GO 9741
9755: POP
9756: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9757: LD_INT 22
9759: PUSH
9760: LD_INT 2
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: LD_INT 0
9774: EQUAL
9775: IFFALSE 9629
// end ;
9777: PPOPN 10
9779: END
// every 0 0$01 trigger blocked do var i ;
9780: LD_EXP 18
9784: IFFALSE 9952
9786: GO 9788
9788: DISABLE
9789: LD_INT 0
9791: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
9792: LD_EXP 27
9796: PPUSH
9797: LD_STRING D9f-Ar1-1
9799: PPUSH
9800: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9804: LD_INT 22
9806: PUSH
9807: LD_INT 2
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PPUSH
9814: CALL_OW 69
9818: PPUSH
9819: LD_INT 51
9821: PPUSH
9822: LD_INT 99
9824: PPUSH
9825: CALL_OW 111
// wait ( 0 0$1 ) ;
9829: LD_INT 35
9831: PPUSH
9832: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9836: LD_INT 22
9838: PUSH
9839: LD_INT 2
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: PUSH
9846: LD_INT 92
9848: PUSH
9849: LD_INT 51
9851: PUSH
9852: LD_INT 99
9854: PUSH
9855: LD_INT 2
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: LIST
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 69
9872: IFFALSE 9932
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
9874: LD_ADDR_VAR 0 1
9878: PUSH
9879: LD_INT 22
9881: PUSH
9882: LD_INT 2
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 92
9891: PUSH
9892: LD_INT 51
9894: PUSH
9895: LD_INT 99
9897: PUSH
9898: LD_INT 2
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: PPUSH
9911: CALL_OW 69
9915: PUSH
9916: FOR_IN
9917: IFFALSE 9930
// RemoveUnit ( i ) ;
9919: LD_VAR 0 1
9923: PPUSH
9924: CALL_OW 64
9928: GO 9916
9930: POP
9931: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
9932: LD_INT 22
9934: PUSH
9935: LD_INT 2
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PPUSH
9942: CALL_OW 69
9946: PUSH
9947: LD_INT 0
9949: EQUAL
9950: IFFALSE 9804
// end ;
9952: PPOPN 1
9954: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
9955: LD_EXP 16
9959: IFFALSE 10312
9961: GO 9963
9963: DISABLE
9964: LD_INT 0
9966: PPUSH
9967: PPUSH
9968: PPUSH
9969: PPUSH
// begin ru_can_attack := true ;
9970: LD_ADDR_EXP 8
9974: PUSH
9975: LD_INT 1
9977: ST_TO_ADDR
// mine_launched := false ;
9978: LD_ADDR_VAR 0 3
9982: PUSH
9983: LD_INT 0
9985: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9986: LD_INT 22
9988: PUSH
9989: LD_INT 2
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: PPUSH
10001: LD_INT 51
10003: PPUSH
10004: LD_INT 99
10006: PPUSH
10007: CALL_OW 111
// if IsOk ( Vervecken ) then
10011: LD_EXP 27
10015: PPUSH
10016: CALL_OW 302
10020: IFFALSE 10034
// Say ( Vervecken , D11a-Ar1-1 ) ;
10022: LD_EXP 27
10026: PPUSH
10027: LD_STRING D11a-Ar1-1
10029: PPUSH
10030: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10034: LD_ADDR_VAR 0 2
10038: PUSH
10039: LD_EXP 34
10043: PPUSH
10044: LD_INT 25
10046: PUSH
10047: LD_INT 1
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 72
10058: ST_TO_ADDR
// for i in tmp do
10059: LD_ADDR_VAR 0 1
10063: PUSH
10064: LD_VAR 0 2
10068: PUSH
10069: FOR_IN
10070: IFFALSE 10133
// if MineOfUnit ( i ) then
10072: LD_VAR 0 1
10076: PPUSH
10077: CALL_OW 459
10081: IFFALSE 10131
// begin x := MineOfUnit ( i ) ;
10083: LD_ADDR_VAR 0 4
10087: PUSH
10088: LD_VAR 0 1
10092: PPUSH
10093: CALL_OW 459
10097: ST_TO_ADDR
// mine_launched := true ;
10098: LD_ADDR_VAR 0 3
10102: PUSH
10103: LD_INT 1
10105: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10106: LD_VAR 0 4
10110: PUSH
10111: LD_INT 1
10113: ARRAY
10114: PPUSH
10115: LD_VAR 0 4
10119: PUSH
10120: LD_INT 2
10122: ARRAY
10123: PPUSH
10124: LD_INT 2
10126: PPUSH
10127: CALL_OW 456
// end ;
10131: GO 10069
10133: POP
10134: POP
// if mine_launched and IsOk ( Vervecken ) then
10135: LD_VAR 0 3
10139: PUSH
10140: LD_EXP 27
10144: PPUSH
10145: CALL_OW 302
10149: AND
10150: IFFALSE 10164
// Say ( Vervecken , D11b-Ar1-1 ) ;
10152: LD_EXP 27
10156: PPUSH
10157: LD_STRING D11b-Ar1-1
10159: PPUSH
10160: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10164: LD_INT 22
10166: PUSH
10167: LD_INT 2
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: PPUSH
10179: LD_INT 51
10181: PPUSH
10182: LD_INT 99
10184: PPUSH
10185: CALL_OW 111
// wait ( 0 0$1 ) ;
10189: LD_INT 35
10191: PPUSH
10192: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10196: LD_INT 22
10198: PUSH
10199: LD_INT 2
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: PUSH
10206: LD_INT 92
10208: PUSH
10209: LD_INT 51
10211: PUSH
10212: LD_INT 99
10214: PUSH
10215: LD_INT 2
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: LIST
10222: LIST
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PPUSH
10228: CALL_OW 69
10232: IFFALSE 10292
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10234: LD_ADDR_VAR 0 1
10238: PUSH
10239: LD_INT 22
10241: PUSH
10242: LD_INT 2
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: PUSH
10249: LD_INT 92
10251: PUSH
10252: LD_INT 51
10254: PUSH
10255: LD_INT 99
10257: PUSH
10258: LD_INT 2
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10290
// RemoveUnit ( i ) ;
10279: LD_VAR 0 1
10283: PPUSH
10284: CALL_OW 64
10288: GO 10276
10290: POP
10291: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PUSH
10307: LD_INT 0
10309: EQUAL
10310: IFFALSE 10164
// end ;
10312: PPOPN 4
10314: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10315: LD_EXP 10
10319: IFFALSE 10498
10321: GO 10323
10323: DISABLE
10324: LD_INT 0
10326: PPUSH
// begin Wait ( 10 10$00 ) ;
10327: LD_INT 21000
10329: PPUSH
10330: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10334: LD_INT 22
10336: PUSH
10337: LD_INT 2
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PPUSH
10344: CALL_OW 69
10348: IFFALSE 10498
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10350: LD_INT 22
10352: PUSH
10353: LD_INT 2
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 69
10364: PPUSH
10365: LD_INT 51
10367: PPUSH
10368: LD_INT 99
10370: PPUSH
10371: CALL_OW 114
// wait ( 0 0$1 ) ;
10375: LD_INT 35
10377: PPUSH
10378: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10382: LD_INT 22
10384: PUSH
10385: LD_INT 2
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: PUSH
10392: LD_INT 92
10394: PUSH
10395: LD_INT 51
10397: PUSH
10398: LD_INT 99
10400: PUSH
10401: LD_INT 2
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: PPUSH
10414: CALL_OW 69
10418: IFFALSE 10478
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10420: LD_ADDR_VAR 0 1
10424: PUSH
10425: LD_INT 22
10427: PUSH
10428: LD_INT 2
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: LD_INT 92
10437: PUSH
10438: LD_INT 51
10440: PUSH
10441: LD_INT 99
10443: PUSH
10444: LD_INT 2
10446: PUSH
10447: EMPTY
10448: LIST
10449: LIST
10450: LIST
10451: LIST
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL_OW 69
10461: PUSH
10462: FOR_IN
10463: IFFALSE 10476
// RemoveUnit ( i ) ;
10465: LD_VAR 0 1
10469: PPUSH
10470: CALL_OW 64
10474: GO 10462
10476: POP
10477: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10478: LD_INT 22
10480: PUSH
10481: LD_INT 2
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PPUSH
10488: CALL_OW 69
10492: PUSH
10493: LD_INT 0
10495: EQUAL
10496: IFFALSE 10350
// end ; end ;
10498: PPOPN 1
10500: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib ;
10501: LD_EXP 4
10505: IFFALSE 11433
10507: GO 10509
10509: DISABLE
10510: LD_INT 0
10512: PPUSH
10513: PPUSH
10514: PPUSH
// begin Wait ( game_time ) ;
10515: LD_EXP 7
10519: PPUSH
10520: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10524: LD_INT 35
10526: PPUSH
10527: CALL_OW 67
// until ( not ru_can_attack ) ;
10531: LD_EXP 8
10535: NOT
10536: IFFALSE 10524
// Wait ( 0 0$35 ) ;
10538: LD_INT 1225
10540: PPUSH
10541: CALL_OW 67
// DialogueOn ;
10545: CALL_OW 6
// InGameOn ;
10549: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10553: LD_EXP 26
10557: PPUSH
10558: LD_STRING D12-Pow-1
10560: PPUSH
10561: CALL_OW 94
// InGameOff ;
10565: CALL_OW 9
// DialogueOff ;
10569: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10573: LD_STRING M4
10575: PPUSH
10576: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10580: LD_INT 5
10582: PPUSH
10583: LD_INT 1
10585: PPUSH
10586: CALL_OW 424
// can_end := true ;
10590: LD_ADDR_EXP 17
10594: PUSH
10595: LD_INT 1
10597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10598: LD_INT 35
10600: PPUSH
10601: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10605: CALL 816 0 0
10609: PUSH
10610: LD_INT 20
10612: GREATEREQUAL
10613: PUSH
10614: LD_INT 22
10616: PUSH
10617: LD_INT 1
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PUSH
10624: LD_INT 21
10626: PUSH
10627: LD_INT 1
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PPUSH
10638: CALL_OW 69
10642: PUSH
10643: LD_INT 5
10645: PPUSH
10646: LD_INT 22
10648: PUSH
10649: LD_INT 1
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: PUSH
10656: LD_INT 21
10658: PUSH
10659: LD_INT 1
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PUSH
10666: EMPTY
10667: LIST
10668: LIST
10669: PPUSH
10670: CALL_OW 70
10674: PUSH
10675: LD_INT 22
10677: PUSH
10678: LD_INT 1
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PUSH
10685: LD_INT 55
10687: PUSH
10688: EMPTY
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PPUSH
10695: CALL_OW 69
10699: PLUS
10700: LESSEQUAL
10701: AND
10702: IFFALSE 10598
// if not player_get_info then
10704: LD_EXP 15
10708: NOT
10709: IFFALSE 10720
// player_get_info := - 1 ;
10711: LD_ADDR_EXP 15
10715: PUSH
10716: LD_INT 1
10718: NEG
10719: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
10720: LD_STRING Information
10722: PPUSH
10723: LD_EXP 15
10727: PPUSH
10728: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
10732: LD_ADDR_VAR 0 2
10736: PUSH
10737: LD_INT 22
10739: PUSH
10740: LD_INT 1
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: PUSH
10747: LD_INT 2
10749: PUSH
10750: LD_INT 25
10752: PUSH
10753: LD_INT 2
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: LD_INT 25
10762: PUSH
10763: LD_INT 16
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: PUSH
10770: LD_INT 34
10772: PUSH
10773: LD_INT 12
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: PUSH
10780: EMPTY
10781: LIST
10782: LIST
10783: LIST
10784: LIST
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PPUSH
10790: CALL_OW 69
10794: ST_TO_ADDR
// sib := GetTerminalCargo ;
10795: LD_ADDR_VAR 0 3
10799: PUSH
10800: CALL 816 0 0
10804: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
10805: LD_ADDR_VAR 0 3
10809: PUSH
10810: LD_VAR 0 3
10814: PUSH
10815: LD_INT 6
10817: PPUSH
10818: LD_INT 3
10820: PPUSH
10821: CALL_OW 287
10825: PLUS
10826: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
10827: LD_ADDR_VAR 0 3
10831: PUSH
10832: LD_VAR 0 3
10836: PUSH
10837: LD_VAR 0 2
10841: PPUSH
10842: LD_INT 3
10844: PPUSH
10845: CALL_OW 289
10849: PLUS
10850: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
10851: LD_VAR 0 3
10855: PUSH
10856: LD_INT 2
10858: PUSH
10859: LD_OWVAR 67
10863: PLUS
10864: PUSH
10865: LD_INT 50
10867: MUL
10868: LESS
10869: IFFALSE 10894
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
10871: LD_STRING MuchSiberite
10873: PPUSH
10874: LD_INT 2
10876: NEG
10877: PUSH
10878: LD_OWVAR 67
10882: MUL
10883: PUSH
10884: LD_INT 1
10886: PLUS
10887: PPUSH
10888: CALL_OW 101
10892: GO 10904
// AddMedal ( MuchSiberite , 1 ) ;
10894: LD_STRING MuchSiberite
10896: PPUSH
10897: LD_INT 1
10899: PPUSH
10900: CALL_OW 101
// GiveMedals ( MAIN ) ;
10904: LD_STRING MAIN
10906: PPUSH
10907: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
10911: LD_INT 22
10913: PUSH
10914: LD_INT 1
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: LD_INT 2
10923: PUSH
10924: LD_INT 25
10926: PUSH
10927: LD_INT 1
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: LD_INT 25
10936: PUSH
10937: LD_INT 2
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: PUSH
10944: LD_INT 25
10946: PUSH
10947: LD_INT 3
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: PUSH
10954: LD_INT 25
10956: PUSH
10957: LD_INT 4
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PUSH
10964: LD_INT 25
10966: PUSH
10967: LD_INT 8
10969: PUSH
10970: EMPTY
10971: LIST
10972: LIST
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: LIST
10980: LIST
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: PPUSH
10986: CALL_OW 69
10990: PPUSH
10991: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
10995: LD_ADDR_VAR 0 2
10999: PUSH
11000: LD_INT 22
11002: PUSH
11003: LD_INT 1
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: LD_INT 25
11012: PUSH
11013: LD_INT 8
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PPUSH
11024: CALL_OW 69
11028: ST_TO_ADDR
// if tmp then
11029: LD_VAR 0 2
11033: IFFALSE 11064
// for i in tmp do
11035: LD_ADDR_VAR 0 1
11039: PUSH
11040: LD_VAR 0 2
11044: PUSH
11045: FOR_IN
11046: IFFALSE 11062
// SetClass ( i , 1 ) ;
11048: LD_VAR 0 1
11052: PPUSH
11053: LD_INT 1
11055: PPUSH
11056: CALL_OW 336
11060: GO 11045
11062: POP
11063: POP
// SaveVariable ( sib , 09_sibRes ) ;
11064: LD_VAR 0 3
11068: PPUSH
11069: LD_STRING 09_sibRes
11071: PPUSH
11072: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11076: LD_EXP 15
11080: PPUSH
11081: LD_STRING 09_arInfo
11083: PPUSH
11084: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11088: LD_EXP 19
11092: PPUSH
11093: LD_EXP 1
11097: PUSH
11098: LD_STRING JMM
11100: STR
11101: PPUSH
11102: CALL_OW 38
// if IsLive ( Gary ) then
11106: LD_EXP 20
11110: PPUSH
11111: CALL_OW 300
11115: IFFALSE 11135
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11117: LD_EXP 20
11121: PPUSH
11122: LD_EXP 1
11126: PUSH
11127: LD_STRING Gary
11129: STR
11130: PPUSH
11131: CALL_OW 38
// if IsLive ( Bobby ) then
11135: LD_EXP 21
11139: PPUSH
11140: CALL_OW 300
11144: IFFALSE 11164
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11146: LD_EXP 21
11150: PPUSH
11151: LD_EXP 1
11155: PUSH
11156: LD_STRING Bobby
11158: STR
11159: PPUSH
11160: CALL_OW 38
// if IsLive ( Cyrus ) then
11164: LD_EXP 22
11168: PPUSH
11169: CALL_OW 300
11173: IFFALSE 11193
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11175: LD_EXP 22
11179: PPUSH
11180: LD_EXP 1
11184: PUSH
11185: LD_STRING Cyrus
11187: STR
11188: PPUSH
11189: CALL_OW 38
// if IsLive ( Houten ) then
11193: LD_EXP 23
11197: PPUSH
11198: CALL_OW 300
11202: IFFALSE 11222
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11204: LD_EXP 23
11208: PPUSH
11209: LD_EXP 1
11213: PUSH
11214: LD_STRING Houten
11216: STR
11217: PPUSH
11218: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11222: LD_ADDR_VAR 0 2
11226: PUSH
11227: LD_INT 22
11229: PUSH
11230: LD_INT 1
11232: PUSH
11233: EMPTY
11234: LIST
11235: LIST
11236: PUSH
11237: LD_INT 2
11239: PUSH
11240: LD_INT 25
11242: PUSH
11243: LD_INT 1
11245: PUSH
11246: EMPTY
11247: LIST
11248: LIST
11249: PUSH
11250: LD_INT 25
11252: PUSH
11253: LD_INT 2
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: PUSH
11260: LD_INT 25
11262: PUSH
11263: LD_INT 3
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: LD_INT 25
11272: PUSH
11273: LD_INT 4
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PPUSH
11291: CALL_OW 69
11295: PUSH
11296: LD_EXP 19
11300: PUSH
11301: LD_EXP 22
11305: PUSH
11306: LD_EXP 21
11310: PUSH
11311: LD_EXP 23
11315: PUSH
11316: LD_EXP 20
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: DIFF
11328: ST_TO_ADDR
// if tmp then
11329: LD_VAR 0 2
11333: IFFALSE 11353
// SaveCharacters ( tmp , mission_prefix & others ) ;
11335: LD_VAR 0 2
11339: PPUSH
11340: LD_EXP 1
11344: PUSH
11345: LD_STRING others
11347: STR
11348: PPUSH
11349: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11353: LD_ADDR_VAR 0 2
11357: PUSH
11358: LD_INT 22
11360: PUSH
11361: LD_INT 1
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 2
11370: PUSH
11371: LD_INT 25
11373: PUSH
11374: LD_INT 12
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PUSH
11381: LD_INT 25
11383: PUSH
11384: LD_INT 16
11386: PUSH
11387: EMPTY
11388: LIST
11389: LIST
11390: PUSH
11391: EMPTY
11392: LIST
11393: LIST
11394: LIST
11395: PUSH
11396: EMPTY
11397: LIST
11398: LIST
11399: PPUSH
11400: CALL_OW 69
11404: ST_TO_ADDR
// if tmp then
11405: LD_VAR 0 2
11409: IFFALSE 11429
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11411: LD_VAR 0 2
11415: PPUSH
11416: LD_EXP 1
11420: PUSH
11421: LD_STRING apes
11423: STR
11424: PPUSH
11425: CALL_OW 38
// YouWin ;
11429: CALL_OW 103
// end ; end_of_file
11433: PPOPN 3
11435: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11436: LD_VAR 0 1
11440: PPUSH
11441: CALL_OW 266
11445: PUSH
11446: LD_INT 0
11448: EQUAL
11449: PUSH
11450: LD_EXP 3
11454: NOT
11455: AND
11456: IFFALSE 11480
// begin terminal := b ;
11458: LD_ADDR_EXP 3
11462: PUSH
11463: LD_VAR 0 1
11467: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11468: LD_EXP 3
11472: PPUSH
11473: LD_STRING terminal
11475: PPUSH
11476: CALL_OW 500
// end ; end ;
11480: PPOPN 2
11482: END
// on BuildingComplete ( b ) do var i ;
11483: LD_INT 0
11485: PPUSH
// begin if GetSide ( b ) = 3 then
11486: LD_VAR 0 1
11490: PPUSH
11491: CALL_OW 255
11495: PUSH
11496: LD_INT 3
11498: EQUAL
11499: IFFALSE 11539
// for i = 1 to 4 do
11501: LD_ADDR_VAR 0 2
11505: PUSH
11506: DOUBLE
11507: LD_INT 1
11509: DEC
11510: ST_TO_ADDR
11511: LD_INT 4
11513: PUSH
11514: FOR_TO
11515: IFFALSE 11537
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11517: LD_ADDR_EXP 37
11521: PUSH
11522: LD_EXP 37
11526: PPUSH
11527: LD_INT 1
11529: PPUSH
11530: CALL_OW 3
11534: ST_TO_ADDR
11535: GO 11514
11537: POP
11538: POP
// end ;
11539: PPOPN 2
11541: END
// on VehicleConstructed ( veh , fac ) do var i ;
11542: LD_INT 0
11544: PPUSH
// begin if GetSide ( veh ) = 3 then
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 255
11554: PUSH
11555: LD_INT 3
11557: EQUAL
11558: IFFALSE 11683
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11560: LD_VAR 0 1
11564: PPUSH
11565: CALL_OW 264
11569: PUSH
11570: LD_INT 53
11572: PUSH
11573: LD_INT 52
11575: PUSH
11576: LD_INT 51
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: LIST
11583: IN
11584: NOT
11585: IFFALSE 11603
// ru_force := ru_force ^ veh ;
11587: LD_ADDR_EXP 36
11591: PUSH
11592: LD_EXP 36
11596: PUSH
11597: LD_VAR 0 1
11601: ADD
11602: ST_TO_ADDR
// for i = 1 to 4 do
11603: LD_ADDR_VAR 0 3
11607: PUSH
11608: DOUBLE
11609: LD_INT 1
11611: DEC
11612: ST_TO_ADDR
11613: LD_INT 4
11615: PUSH
11616: FOR_TO
11617: IFFALSE 11639
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
11619: LD_ADDR_EXP 38
11623: PUSH
11624: LD_EXP 38
11628: PPUSH
11629: LD_INT 1
11631: PPUSH
11632: CALL_OW 3
11636: ST_TO_ADDR
11637: GO 11616
11639: POP
11640: POP
// if GetWeapon ( veh ) = ru_bulldozer then
11641: LD_VAR 0 1
11645: PPUSH
11646: CALL_OW 264
11650: PUSH
11651: LD_INT 53
11653: EQUAL
11654: IFFALSE 11683
// begin CutTreeInArea ( veh , cutTreeArea ) ;
11656: LD_VAR 0 1
11660: PPUSH
11661: LD_INT 7
11663: PPUSH
11664: CALL 974 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
11668: LD_VAR 0 1
11672: PPUSH
11673: LD_INT 170
11675: PPUSH
11676: LD_INT 235
11678: PPUSH
11679: CALL_OW 171
// end ; end ; end ;
11683: PPOPN 3
11685: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
11686: LD_VAR 0 1
11690: PUSH
11691: LD_INT 1
11693: EQUAL
11694: PUSH
11695: LD_VAR 0 2
11699: PUSH
11700: LD_INT 2
11702: EQUAL
11703: AND
11704: PUSH
11705: LD_VAR 0 1
11709: PUSH
11710: LD_INT 2
11712: EQUAL
11713: PUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_INT 1
11721: EQUAL
11722: AND
11723: OR
11724: IFFALSE 11734
// player_attacked_ar := true ;
11726: LD_ADDR_EXP 16
11730: PUSH
11731: LD_INT 1
11733: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
11734: LD_VAR 0 1
11738: PUSH
11739: LD_INT 1
11741: EQUAL
11742: PUSH
11743: LD_VAR 0 2
11747: PUSH
11748: LD_INT 4
11750: EQUAL
11751: AND
11752: PUSH
11753: LD_VAR 0 1
11757: PUSH
11758: LD_INT 4
11760: EQUAL
11761: PUSH
11762: LD_VAR 0 2
11766: PUSH
11767: LD_INT 1
11769: EQUAL
11770: AND
11771: OR
11772: IFFALSE 11781
// YouLost ( Traitor ) ;
11774: LD_STRING Traitor
11776: PPUSH
11777: CALL_OW 104
// end ;
11781: PPOPN 2
11783: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11784: LD_VAR 0 1
11788: PUSH
11789: LD_EXP 19
11793: EQUAL
11794: IFFALSE 11803
// YouLost ( JMM ) ;
11796: LD_STRING JMM
11798: PPUSH
11799: CALL_OW 104
// if un = terminal then
11803: LD_VAR 0 1
11807: PUSH
11808: LD_EXP 3
11812: EQUAL
11813: IFFALSE 11822
// YouLost ( Terminal ) ;
11815: LD_STRING Terminal
11817: PPUSH
11818: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
11822: LD_VAR 0 1
11826: PUSH
11827: LD_INT 22
11829: PUSH
11830: LD_INT 3
11832: PUSH
11833: EMPTY
11834: LIST
11835: LIST
11836: PUSH
11837: LD_INT 21
11839: PUSH
11840: LD_INT 3
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: PUSH
11847: EMPTY
11848: LIST
11849: LIST
11850: PPUSH
11851: CALL_OW 69
11855: IN
11856: IFFALSE 12002
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
11858: LD_VAR 0 1
11862: PPUSH
11863: CALL_OW 266
11867: PUSH
11868: LD_INT 33
11870: PUSH
11871: LD_INT 26
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: IN
11878: IFFALSE 11937
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11880: LD_ADDR_EXP 37
11884: PUSH
11885: LD_EXP 37
11889: PUSH
11890: LD_VAR 0 1
11894: PPUSH
11895: CALL_OW 266
11899: PUSH
11900: LD_VAR 0 1
11904: PPUSH
11905: CALL_OW 250
11909: PUSH
11910: LD_VAR 0 1
11914: PPUSH
11915: CALL_OW 251
11919: PUSH
11920: LD_VAR 0 1
11924: PPUSH
11925: CALL_OW 254
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: LIST
11934: LIST
11935: ADD
11936: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
11937: LD_VAR 0 1
11941: PPUSH
11942: CALL_OW 266
11946: PUSH
11947: LD_INT 5
11949: EQUAL
11950: IFFALSE 12002
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11952: LD_ADDR_EXP 37
11956: PUSH
11957: LD_EXP 37
11961: PUSH
11962: LD_INT 4
11964: PUSH
11965: LD_VAR 0 1
11969: PPUSH
11970: CALL_OW 250
11974: PUSH
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 251
11984: PUSH
11985: LD_VAR 0 1
11989: PPUSH
11990: CALL_OW 254
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: ADD
12001: ST_TO_ADDR
// end ; if un in ru_force then
12002: LD_VAR 0 1
12006: PUSH
12007: LD_EXP 36
12011: IN
12012: IFFALSE 12048
// begin ru_force := ru_force diff un ;
12014: LD_ADDR_EXP 36
12018: PUSH
12019: LD_EXP 36
12023: PUSH
12024: LD_VAR 0 1
12028: DIFF
12029: ST_TO_ADDR
// if ru_force = 0 then
12030: LD_EXP 36
12034: PUSH
12035: LD_INT 0
12037: EQUAL
12038: IFFALSE 12048
// ru_can_attack := false ;
12040: LD_ADDR_EXP 8
12044: PUSH
12045: LD_INT 0
12047: ST_TO_ADDR
// end ; end ;
12048: PPOPN 1
12050: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12051: LD_VAR 0 1
12055: PPUSH
12056: CALL 17378 0 1
// end ; end_of_file
12060: PPOPN 1
12062: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12063: LD_EXP 5
12067: PUSH
12068: LD_EXP 6
12072: AND
12073: IFFALSE 12158
12075: GO 12077
12077: DISABLE
12078: LD_INT 0
12080: PPUSH
// begin enable ;
12081: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12082: LD_ADDR_VAR 0 1
12086: PUSH
12087: LD_INT 60
12089: PUSH
12090: CALL 816 0 0
12094: MINUS
12095: ST_TO_ADDR
// if sib < 0 then
12096: LD_VAR 0 1
12100: PUSH
12101: LD_INT 0
12103: LESS
12104: IFFALSE 12114
// sib := 0 ;
12106: LD_ADDR_VAR 0 1
12110: PUSH
12111: LD_INT 0
12113: ST_TO_ADDR
// if not debug then
12114: LD_EXP 2
12118: NOT
12119: IFFALSE 12144
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12121: LD_ADDR_OWVAR 47
12125: PUSH
12126: LD_STRING #Am09-1
12128: PUSH
12129: LD_VAR 0 1
12133: PUSH
12134: LD_EXP 6
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: LIST
12143: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12144: LD_ADDR_EXP 6
12148: PUSH
12149: LD_EXP 6
12153: PUSH
12154: LD_INT 35
12156: MINUS
12157: ST_TO_ADDR
// end ;
12158: PPOPN 1
12160: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12161: LD_EXP 6
12165: PUSH
12166: LD_INT 0
12168: EQUAL
12169: IFFALSE 12181
12171: GO 12173
12173: DISABLE
// display_strings := [ ] ;
12174: LD_ADDR_OWVAR 47
12178: PUSH
12179: EMPTY
12180: ST_TO_ADDR
12181: END
// every 1 1$35 do var i , tmp ;
12182: GO 12184
12184: DISABLE
12185: LD_INT 0
12187: PPUSH
12188: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12189: LD_ADDR_VAR 0 2
12193: PUSH
12194: LD_INT 1155
12196: PUSH
12197: LD_INT 1225
12199: PUSH
12200: LD_INT 1435
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: LIST
12207: PUSH
12208: LD_OWVAR 67
12212: ARRAY
12213: ST_TO_ADDR
// i := 0 ;
12214: LD_ADDR_VAR 0 1
12218: PUSH
12219: LD_INT 0
12221: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12222: LD_INT 1
12224: PPUSH
12225: LD_INT 5
12227: PPUSH
12228: CALL_OW 12
12232: PPUSH
12233: LD_INT 75
12235: PPUSH
12236: LD_INT 75
12238: PPUSH
12239: LD_INT 20
12241: PPUSH
12242: LD_INT 1
12244: PPUSH
12245: CALL_OW 56
// wait ( tmp ) ;
12249: LD_VAR 0 2
12253: PPUSH
12254: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12258: LD_ADDR_VAR 0 2
12262: PUSH
12263: LD_VAR 0 2
12267: PUSH
12268: LD_INT 105
12270: PPUSH
12271: LD_INT 315
12273: PPUSH
12274: CALL_OW 12
12278: PLUS
12279: ST_TO_ADDR
// i := i + 1 ;
12280: LD_ADDR_VAR 0 1
12284: PUSH
12285: LD_VAR 0 1
12289: PUSH
12290: LD_INT 1
12292: PLUS
12293: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12294: LD_VAR 0 1
12298: PUSH
12299: LD_INT 3
12301: MOD
12302: PUSH
12303: LD_INT 0
12305: EQUAL
12306: PUSH
12307: LD_EXP 4
12311: AND
12312: IFFALSE 12350
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12314: LD_INT 2
12316: PPUSH
12317: LD_INT 5
12319: PPUSH
12320: CALL_OW 12
12324: PPUSH
12325: LD_INT 8
12327: PPUSH
12328: LD_INT 1
12330: PPUSH
12331: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12335: LD_INT 665
12337: PPUSH
12338: LD_INT 735
12340: PPUSH
12341: CALL_OW 12
12345: PPUSH
12346: CALL_OW 67
// end ; until tick > game_time ;
12350: LD_OWVAR 1
12354: PUSH
12355: LD_EXP 7
12359: GREATER
12360: IFFALSE 12222
// end ; end_of_file
12362: PPOPN 2
12364: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12365: LD_INT 0
12367: PPUSH
12368: PPUSH
12369: PPUSH
12370: PPUSH
12371: PPUSH
12372: PPUSH
// x := 76 ;
12373: LD_ADDR_VAR 0 5
12377: PUSH
12378: LD_INT 76
12380: ST_TO_ADDR
// y := 147 ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_INT 147
12388: ST_TO_ADDR
// uc_side := 2 ;
12389: LD_ADDR_OWVAR 20
12393: PUSH
12394: LD_INT 2
12396: ST_TO_ADDR
// uc_nation := 2 ;
12397: LD_ADDR_OWVAR 21
12401: PUSH
12402: LD_INT 2
12404: ST_TO_ADDR
// InitHc ;
12405: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12409: LD_INT 1
12411: PPUSH
12412: LD_INT 1
12414: PPUSH
12415: LD_INT 6
12417: PPUSH
12418: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12422: LD_ADDR_OWVAR 26
12426: PUSH
12427: LD_STRING Nicolas Vervecken
12429: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12430: LD_ADDR_OWVAR 33
12434: PUSH
12435: LD_STRING SecondCharsGal
12437: ST_TO_ADDR
// hc_face_number := 3 ;
12438: LD_ADDR_OWVAR 34
12442: PUSH
12443: LD_INT 3
12445: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12446: LD_ADDR_OWVAR 29
12450: PUSH
12451: LD_INT 11
12453: PUSH
12454: LD_INT 10
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: ST_TO_ADDR
// Vervecken := CreateHuman ;
12461: LD_ADDR_EXP 27
12465: PUSH
12466: CALL_OW 44
12470: ST_TO_ADDR
// ar_force := Vervecken ;
12471: LD_ADDR_EXP 34
12475: PUSH
12476: LD_EXP 27
12480: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12481: LD_INT 1
12483: PPUSH
12484: LD_INT 2
12486: PPUSH
12487: LD_INT 6
12489: PPUSH
12490: CALL_OW 380
// hc_name := Louis Gali ;
12494: LD_ADDR_OWVAR 26
12498: PUSH
12499: LD_STRING Louis Gali
12501: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12502: LD_ADDR_OWVAR 33
12506: PUSH
12507: LD_STRING SecondCharsGal
12509: ST_TO_ADDR
// hc_face_number := 2 ;
12510: LD_ADDR_OWVAR 34
12514: PUSH
12515: LD_INT 2
12517: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12518: LD_ADDR_OWVAR 29
12522: PUSH
12523: LD_INT 10
12525: PUSH
12526: LD_INT 11
12528: PUSH
12529: EMPTY
12530: LIST
12531: LIST
12532: ST_TO_ADDR
// Gali := CreateHuman ;
12533: LD_ADDR_EXP 28
12537: PUSH
12538: CALL_OW 44
12542: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
12543: LD_ADDR_EXP 34
12547: PUSH
12548: LD_EXP 34
12552: PUSH
12553: LD_EXP 28
12557: ADD
12558: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
12559: LD_INT 2
12561: PPUSH
12562: LD_INT 1
12564: PPUSH
12565: LD_INT 6
12567: PPUSH
12568: CALL_OW 380
// hc_name := Maria Bogdanovic ;
12572: LD_ADDR_OWVAR 26
12576: PUSH
12577: LD_STRING Maria Bogdanovic
12579: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12580: LD_ADDR_OWVAR 33
12584: PUSH
12585: LD_STRING SecondCharsGal
12587: ST_TO_ADDR
// hc_face_number := 14 ;
12588: LD_ADDR_OWVAR 34
12592: PUSH
12593: LD_INT 14
12595: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
12596: LD_ADDR_OWVAR 29
12600: PUSH
12601: LD_INT 12
12603: PUSH
12604: LD_INT 9
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
12611: LD_ADDR_EXP 29
12615: PUSH
12616: CALL_OW 44
12620: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
12621: LD_ADDR_EXP 34
12625: PUSH
12626: LD_EXP 34
12630: PUSH
12631: LD_EXP 29
12635: ADD
12636: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12637: LD_INT 1
12639: PPUSH
12640: LD_INT 3
12642: PPUSH
12643: LD_INT 6
12645: PPUSH
12646: CALL_OW 380
// hc_name = Kntor Radomr ;
12650: LD_ADDR_OWVAR 26
12654: PUSH
12655: LD_STRING Kntor Radomr
12657: ST_TO_ADDR
// hc_gallery = sandar ;
12658: LD_ADDR_OWVAR 33
12662: PUSH
12663: LD_STRING sandar
12665: ST_TO_ADDR
// hc_face_number = 12 ;
12666: LD_ADDR_OWVAR 34
12670: PUSH
12671: LD_INT 12
12673: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
12674: LD_ADDR_OWVAR 29
12678: PUSH
12679: LD_INT 9
12681: PUSH
12682: LD_INT 9
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: ST_TO_ADDR
// Kantor = CreateHuman ;
12689: LD_ADDR_EXP 30
12693: PUSH
12694: CALL_OW 44
12698: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
12699: LD_ADDR_EXP 34
12703: PUSH
12704: LD_EXP 34
12708: PUSH
12709: LD_EXP 30
12713: ADD
12714: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
12715: LD_INT 1
12717: PPUSH
12718: LD_INT 3
12720: PPUSH
12721: LD_INT 6
12723: PPUSH
12724: CALL_OW 380
// hc_name = Herczeg Farkas ;
12728: LD_ADDR_OWVAR 26
12732: PUSH
12733: LD_STRING Herczeg Farkas
12735: ST_TO_ADDR
// hc_gallery = sandar ;
12736: LD_ADDR_OWVAR 33
12740: PUSH
12741: LD_STRING sandar
12743: ST_TO_ADDR
// hc_face_number = 28 ;
12744: LD_ADDR_OWVAR 34
12748: PUSH
12749: LD_INT 28
12751: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
12752: LD_ADDR_OWVAR 29
12756: PUSH
12757: LD_INT 10
12759: PUSH
12760: LD_INT 9
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: ST_TO_ADDR
// Herczeg = CreateHuman ;
12767: LD_ADDR_EXP 31
12771: PUSH
12772: CALL_OW 44
12776: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
12777: LD_ADDR_EXP 34
12781: PUSH
12782: LD_EXP 34
12786: PUSH
12787: LD_EXP 31
12791: ADD
12792: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
12793: LD_INT 1
12795: PPUSH
12796: LD_INT 1
12798: PPUSH
12799: LD_INT 6
12801: PPUSH
12802: CALL_OW 380
// hc_name = Ronn Horntvedt ;
12806: LD_ADDR_OWVAR 26
12810: PUSH
12811: LD_STRING Ronn Horntvedt
12813: ST_TO_ADDR
// hc_gallery = sandar ;
12814: LD_ADDR_OWVAR 33
12818: PUSH
12819: LD_STRING sandar
12821: ST_TO_ADDR
// hc_face_number = 29 ;
12822: LD_ADDR_OWVAR 34
12826: PUSH
12827: LD_INT 29
12829: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
12830: LD_ADDR_OWVAR 29
12834: PUSH
12835: LD_INT 11
12837: PUSH
12838: LD_INT 11
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: ST_TO_ADDR
// Ronn = CreateHuman ;
12845: LD_ADDR_EXP 32
12849: PUSH
12850: CALL_OW 44
12854: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
12855: LD_ADDR_EXP 34
12859: PUSH
12860: LD_EXP 34
12864: PUSH
12865: LD_EXP 32
12869: ADD
12870: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
12871: LD_INT 2
12873: PPUSH
12874: LD_INT 3
12876: PPUSH
12877: LD_INT 6
12879: PPUSH
12880: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
12884: LD_ADDR_OWVAR 26
12888: PUSH
12889: LD_STRING Mia D. Mathiasen
12891: ST_TO_ADDR
// hc_gallery = sandar ;
12892: LD_ADDR_OWVAR 33
12896: PUSH
12897: LD_STRING sandar
12899: ST_TO_ADDR
// hc_face_number = 31 ;
12900: LD_ADDR_OWVAR 34
12904: PUSH
12905: LD_INT 31
12907: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
12908: LD_ADDR_OWVAR 29
12912: PUSH
12913: LD_INT 10
12915: PUSH
12916: LD_INT 10
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: ST_TO_ADDR
// Mia = CreateHuman ;
12923: LD_ADDR_EXP 33
12927: PUSH
12928: CALL_OW 44
12932: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
12933: LD_ADDR_EXP 34
12937: PUSH
12938: LD_EXP 34
12942: PUSH
12943: LD_EXP 33
12947: ADD
12948: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
12949: LD_ADDR_VAR 0 3
12953: PUSH
12954: LD_VAR 0 3
12958: PUSH
12959: LD_INT 2
12961: PPUSH
12962: LD_INT 2
12964: PPUSH
12965: LD_INT 14
12967: PPUSH
12968: LD_INT 1
12970: PPUSH
12971: LD_INT 1
12973: PPUSH
12974: LD_INT 32
12976: PPUSH
12977: LD_INT 30
12979: PPUSH
12980: CALL 296 0 7
12984: ADD
12985: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
12986: LD_ADDR_VAR 0 3
12990: PUSH
12991: LD_VAR 0 3
12995: PUSH
12996: LD_INT 2
12998: PPUSH
12999: LD_INT 2
13001: PPUSH
13002: LD_INT 14
13004: PPUSH
13005: LD_INT 1
13007: PPUSH
13008: LD_INT 1
13010: PPUSH
13011: LD_INT 27
13013: PPUSH
13014: LD_INT 30
13016: PPUSH
13017: CALL 296 0 7
13021: ADD
13022: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13023: LD_ADDR_VAR 0 3
13027: PUSH
13028: LD_VAR 0 3
13032: PUSH
13033: LD_INT 2
13035: PPUSH
13036: LD_INT 2
13038: PPUSH
13039: LD_INT 14
13041: PPUSH
13042: LD_INT 1
13044: PPUSH
13045: LD_INT 1
13047: PPUSH
13048: LD_INT 25
13050: PPUSH
13051: LD_INT 33
13053: PPUSH
13054: CALL 296 0 7
13058: ADD
13059: ST_TO_ADDR
// tmp := tmp diff 0 ;
13060: LD_ADDR_VAR 0 3
13064: PUSH
13065: LD_VAR 0 3
13069: PUSH
13070: LD_INT 0
13072: DIFF
13073: ST_TO_ADDR
// for i in ar_force do
13074: LD_ADDR_VAR 0 4
13078: PUSH
13079: LD_EXP 34
13083: PUSH
13084: FOR_IN
13085: IFFALSE 13228
// begin if GetClass ( i ) = 3 then
13087: LD_VAR 0 4
13091: PPUSH
13092: CALL_OW 257
13096: PUSH
13097: LD_INT 3
13099: EQUAL
13100: IFFALSE 13182
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13102: LD_VAR 0 3
13106: PUSH
13107: LD_INT 1
13109: ARRAY
13110: PPUSH
13111: LD_INT 1
13113: PPUSH
13114: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13118: LD_VAR 0 3
13122: PUSH
13123: LD_INT 1
13125: ARRAY
13126: PPUSH
13127: LD_VAR 0 5
13131: PPUSH
13132: LD_VAR 0 6
13136: PPUSH
13137: LD_INT 0
13139: PPUSH
13140: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13144: LD_VAR 0 4
13148: PPUSH
13149: LD_VAR 0 3
13153: PUSH
13154: LD_INT 1
13156: ARRAY
13157: PPUSH
13158: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13162: LD_ADDR_VAR 0 3
13166: PUSH
13167: LD_VAR 0 3
13171: PPUSH
13172: LD_INT 1
13174: PPUSH
13175: CALL_OW 3
13179: ST_TO_ADDR
// end else
13180: GO 13204
// PlaceUnitXY ( i , x , y , false ) ;
13182: LD_VAR 0 4
13186: PPUSH
13187: LD_VAR 0 5
13191: PPUSH
13192: LD_VAR 0 6
13196: PPUSH
13197: LD_INT 0
13199: PPUSH
13200: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13204: LD_VAR 0 4
13208: PPUSH
13209: LD_INT 86
13211: PPUSH
13212: LD_INT 121
13214: PPUSH
13215: CALL_OW 111
// wait ( 0 0$2 ) ;
13219: LD_INT 70
13221: PPUSH
13222: CALL_OW 67
// end ;
13226: GO 13084
13228: POP
13229: POP
// ar_force := ar_force ^ tmp ;
13230: LD_ADDR_EXP 34
13234: PUSH
13235: LD_EXP 34
13239: PUSH
13240: LD_VAR 0 3
13244: ADD
13245: ST_TO_ADDR
// ar_spawned := true ;
13246: LD_ADDR_EXP 11
13250: PUSH
13251: LD_INT 1
13253: ST_TO_ADDR
// end ; end_of_file
13254: LD_VAR 0 1
13258: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13259: LD_INT 0
13261: PPUSH
13262: PPUSH
13263: PPUSH
13264: PPUSH
13265: PPUSH
13266: PPUSH
13267: PPUSH
// InitHc ;
13268: CALL_OW 19
// uc_side := 3 ;
13272: LD_ADDR_OWVAR 20
13276: PUSH
13277: LD_INT 3
13279: ST_TO_ADDR
// uc_nation := 3 ;
13280: LD_ADDR_OWVAR 21
13284: PUSH
13285: LD_INT 3
13287: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13288: LD_ADDR_VAR 0 5
13292: PUSH
13293: LD_INT 5
13295: PUSH
13296: LD_INT 6
13298: PUSH
13299: LD_INT 7
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: LIST
13306: PUSH
13307: LD_OWVAR 67
13311: ARRAY
13312: ST_TO_ADDR
// ru_force := [ ] ;
13313: LD_ADDR_EXP 36
13317: PUSH
13318: EMPTY
13319: ST_TO_ADDR
// ru_rebuild := [ ] ;
13320: LD_ADDR_EXP 37
13324: PUSH
13325: EMPTY
13326: ST_TO_ADDR
// ru_produce_list := [ ] ;
13327: LD_ADDR_EXP 38
13331: PUSH
13332: EMPTY
13333: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13334: LD_ADDR_VAR 0 6
13338: PUSH
13339: LD_INT 22
13341: PUSH
13342: LD_INT 3
13344: PUSH
13345: EMPTY
13346: LIST
13347: LIST
13348: PUSH
13349: LD_INT 30
13351: PUSH
13352: LD_INT 8
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: PPUSH
13363: CALL_OW 69
13367: PUSH
13368: LD_INT 1
13370: ARRAY
13371: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13372: LD_ADDR_VAR 0 4
13376: PUSH
13377: LD_INT 43
13379: PUSH
13380: LD_INT 46
13382: PUSH
13383: LD_INT 45
13385: PUSH
13386: EMPTY
13387: LIST
13388: LIST
13389: LIST
13390: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13391: LD_ADDR_VAR 0 7
13395: PUSH
13396: LD_INT 22
13398: PUSH
13399: LD_INT 3
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 30
13408: PUSH
13409: LD_INT 1
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PPUSH
13420: CALL_OW 69
13424: PUSH
13425: LD_INT 1
13427: ARRAY
13428: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13429: LD_VAR 0 7
13433: PPUSH
13434: CALL_OW 274
13438: PPUSH
13439: LD_INT 1
13441: PPUSH
13442: LD_INT 5000
13444: PPUSH
13445: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13449: LD_VAR 0 7
13453: PPUSH
13454: CALL_OW 274
13458: PPUSH
13459: LD_INT 2
13461: PPUSH
13462: LD_INT 1000
13464: PPUSH
13465: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13469: LD_VAR 0 7
13473: PPUSH
13474: CALL_OW 274
13478: PPUSH
13479: LD_INT 3
13481: PPUSH
13482: LD_INT 30
13484: PPUSH
13485: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
13489: LD_ADDR_VAR 0 2
13493: PUSH
13494: LD_INT 22
13496: PUSH
13497: LD_INT 3
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: LD_INT 30
13506: PUSH
13507: LD_INT 33
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: PPUSH
13518: CALL_OW 69
13522: PUSH
13523: FOR_IN
13524: IFFALSE 13556
// begin PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
13526: LD_VAR 0 2
13530: PPUSH
13531: LD_VAR 0 4
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: LD_INT 3
13543: MOD
13544: PUSH
13545: LD_INT 1
13547: PLUS
13548: ARRAY
13549: PPUSH
13550: CALL_OW 431
// end ;
13554: GO 13523
13556: POP
13557: POP
// for i = 1 to 4 do
13558: LD_ADDR_VAR 0 2
13562: PUSH
13563: DOUBLE
13564: LD_INT 1
13566: DEC
13567: ST_TO_ADDR
13568: LD_INT 4
13570: PUSH
13571: FOR_TO
13572: IFFALSE 13633
// begin PrepareHuman ( false , class_bazooker , skill ) ;
13574: LD_INT 0
13576: PPUSH
13577: LD_INT 9
13579: PPUSH
13580: LD_VAR 0 5
13584: PPUSH
13585: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
13589: CALL_OW 44
13593: PPUSH
13594: LD_INT 22
13596: PUSH
13597: LD_INT 3
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 30
13606: PUSH
13607: LD_INT 5
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 1
13625: ARRAY
13626: PPUSH
13627: CALL_OW 52
// end ;
13631: GO 13571
13633: POP
13634: POP
// for i = 1 to 5 do
13635: LD_ADDR_VAR 0 2
13639: PUSH
13640: DOUBLE
13641: LD_INT 1
13643: DEC
13644: ST_TO_ADDR
13645: LD_INT 5
13647: PUSH
13648: FOR_TO
13649: IFFALSE 13710
// begin PrepareHuman ( false , class_mechanic , skill ) ;
13651: LD_INT 0
13653: PPUSH
13654: LD_INT 3
13656: PPUSH
13657: LD_VAR 0 5
13661: PPUSH
13662: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
13666: CALL_OW 44
13670: PPUSH
13671: LD_INT 22
13673: PUSH
13674: LD_INT 3
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 30
13683: PUSH
13684: LD_INT 3
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 69
13699: PUSH
13700: LD_INT 1
13702: ARRAY
13703: PPUSH
13704: CALL_OW 52
// end ;
13708: GO 13648
13710: POP
13711: POP
// for i = 1 to 4 do
13712: LD_ADDR_VAR 0 2
13716: PUSH
13717: DOUBLE
13718: LD_INT 1
13720: DEC
13721: ST_TO_ADDR
13722: LD_INT 4
13724: PUSH
13725: FOR_TO
13726: IFFALSE 13787
// begin PrepareHuman ( false , class_engineer , skill ) ;
13728: LD_INT 0
13730: PPUSH
13731: LD_INT 2
13733: PPUSH
13734: LD_VAR 0 5
13738: PPUSH
13739: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
13743: CALL_OW 44
13747: PPUSH
13748: LD_INT 22
13750: PUSH
13751: LD_INT 3
13753: PUSH
13754: EMPTY
13755: LIST
13756: LIST
13757: PUSH
13758: LD_INT 30
13760: PUSH
13761: LD_INT 1
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PPUSH
13772: CALL_OW 69
13776: PUSH
13777: LD_INT 1
13779: ARRAY
13780: PPUSH
13781: CALL_OW 52
// end ;
13785: GO 13725
13787: POP
13788: POP
// for i = 1 to 3 do
13789: LD_ADDR_VAR 0 2
13793: PUSH
13794: DOUBLE
13795: LD_INT 1
13797: DEC
13798: ST_TO_ADDR
13799: LD_INT 3
13801: PUSH
13802: FOR_TO
13803: IFFALSE 13836
// begin PrepareHuman ( false , class_scientistic , skill ) ;
13805: LD_INT 0
13807: PPUSH
13808: LD_INT 4
13810: PPUSH
13811: LD_VAR 0 5
13815: PPUSH
13816: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
13820: CALL_OW 44
13824: PPUSH
13825: LD_VAR 0 6
13829: PPUSH
13830: CALL_OW 52
// end ;
13834: GO 13802
13836: POP
13837: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
13838: LD_ADDR_EXP 35
13842: PUSH
13843: LD_STRING Yakotich
13845: PPUSH
13846: LD_EXP 2
13850: NOT
13851: PPUSH
13852: LD_STRING 
13854: PPUSH
13855: CALL 233 0 3
13859: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
13860: LD_EXP 35
13864: PPUSH
13865: LD_INT 74
13867: PPUSH
13868: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
13872: LD_VAR 0 6
13876: PPUSH
13877: LD_INT 49
13879: PPUSH
13880: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
13884: LD_VAR 0 6
13888: PPUSH
13889: LD_INT 50
13891: PPUSH
13892: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
13896: LD_VAR 0 6
13900: PPUSH
13901: LD_INT 51
13903: PPUSH
13904: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
13908: LD_VAR 0 6
13912: PPUSH
13913: LD_INT 52
13915: PPUSH
13916: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
13920: LD_VAR 0 6
13924: PPUSH
13925: LD_INT 69
13927: PPUSH
13928: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
13932: LD_VAR 0 6
13936: PPUSH
13937: LD_INT 39
13939: PPUSH
13940: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
13944: LD_VAR 0 6
13948: PPUSH
13949: LD_INT 34
13951: PPUSH
13952: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
13956: LD_VAR 0 6
13960: PPUSH
13961: LD_INT 40
13963: PPUSH
13964: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
13968: LD_VAR 0 6
13972: PPUSH
13973: LD_INT 57
13975: PPUSH
13976: CALL_OW 184
// if Difficulty > 1 then
13980: LD_OWVAR 67
13984: PUSH
13985: LD_INT 1
13987: GREATER
13988: IFFALSE 14002
// AddComResearch ( lab , tech_comp2 ) ;
13990: LD_VAR 0 6
13994: PPUSH
13995: LD_INT 58
13997: PPUSH
13998: CALL_OW 184
// end ;
14002: LD_VAR 0 1
14006: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14007: LD_INT 7
14009: PPUSH
14010: CALL_OW 353
14014: PUSH
14015: LD_INT 3
14017: GREATER
14018: PUSH
14019: LD_INT 22
14021: PUSH
14022: LD_INT 3
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 34
14031: PUSH
14032: LD_INT 53
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PPUSH
14043: CALL_OW 69
14047: NOT
14048: AND
14049: IFFALSE 14084
14051: GO 14053
14053: DISABLE
// begin enable ;
14054: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14055: LD_ADDR_EXP 38
14059: PUSH
14060: LD_EXP 38
14064: PUSH
14065: LD_INT 24
14067: PUSH
14068: LD_INT 1
14070: PUSH
14071: LD_INT 3
14073: PUSH
14074: LD_INT 53
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: ADD
14083: ST_TO_ADDR
// end ;
14084: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14085: LD_INT 22
14087: PUSH
14088: LD_INT 3
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: LD_INT 21
14097: PUSH
14098: LD_INT 3
14100: PUSH
14101: EMPTY
14102: LIST
14103: LIST
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: PPUSH
14109: CALL_OW 69
14113: IFFALSE 14891
14115: GO 14117
14117: DISABLE
14118: LD_INT 0
14120: PPUSH
14121: PPUSH
14122: PPUSH
14123: PPUSH
14124: PPUSH
14125: PPUSH
14126: PPUSH
14127: PPUSH
// begin enable ;
14128: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14129: LD_ADDR_VAR 0 3
14133: PUSH
14134: LD_INT 22
14136: PUSH
14137: LD_INT 3
14139: PUSH
14140: EMPTY
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 21
14146: PUSH
14147: LD_INT 3
14149: PUSH
14150: EMPTY
14151: LIST
14152: LIST
14153: PUSH
14154: LD_INT 3
14156: PUSH
14157: LD_INT 24
14159: PUSH
14160: LD_INT 1000
14162: PUSH
14163: EMPTY
14164: LIST
14165: LIST
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: LIST
14175: PPUSH
14176: CALL_OW 69
14180: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14181: LD_ADDR_VAR 0 4
14185: PUSH
14186: LD_INT 22
14188: PUSH
14189: LD_INT 3
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: LD_INT 25
14198: PUSH
14199: LD_INT 2
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: PPUSH
14210: CALL_OW 69
14214: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14215: LD_ADDR_VAR 0 5
14219: PUSH
14220: LD_INT 22
14222: PUSH
14223: LD_INT 3
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: PUSH
14230: LD_INT 30
14232: PUSH
14233: LD_INT 1
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: PPUSH
14244: CALL_OW 69
14248: PUSH
14249: LD_INT 1
14251: ARRAY
14252: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14253: LD_ADDR_VAR 0 8
14257: PUSH
14258: LD_INT 22
14260: PUSH
14261: LD_INT 3
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_INT 2
14270: PUSH
14271: LD_INT 30
14273: PUSH
14274: LD_INT 6
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_INT 30
14283: PUSH
14284: LD_INT 7
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: PUSH
14291: LD_INT 30
14293: PUSH
14294: LD_INT 8
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: PUSH
14301: EMPTY
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PPUSH
14311: CALL_OW 69
14315: PUSH
14316: LD_INT 1
14318: ARRAY
14319: ST_TO_ADDR
// if not engs then
14320: LD_VAR 0 4
14324: NOT
14325: IFFALSE 14329
// exit ;
14327: GO 14891
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14329: LD_ADDR_VAR 0 6
14333: PUSH
14334: LD_VAR 0 4
14338: PPUSH
14339: LD_INT 3
14341: PUSH
14342: LD_INT 24
14344: PUSH
14345: LD_INT 600
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: PPUSH
14356: CALL_OW 72
14360: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14361: LD_ADDR_VAR 0 7
14365: PUSH
14366: LD_INT 22
14368: PUSH
14369: LD_INT 3
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PUSH
14376: LD_INT 25
14378: PUSH
14379: LD_INT 4
14381: PUSH
14382: EMPTY
14383: LIST
14384: LIST
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: PPUSH
14390: CALL_OW 69
14394: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14395: LD_VAR 0 3
14399: NOT
14400: PUSH
14401: LD_EXP 37
14405: NOT
14406: AND
14407: IFFALSE 14467
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14409: LD_VAR 0 4
14413: PPUSH
14414: LD_INT 3
14416: PUSH
14417: LD_INT 54
14419: PUSH
14420: EMPTY
14421: LIST
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: PPUSH
14427: CALL_OW 72
14431: IFFALSE 14465
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14433: LD_VAR 0 4
14437: PPUSH
14438: LD_INT 3
14440: PUSH
14441: LD_INT 54
14443: PUSH
14444: EMPTY
14445: LIST
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PPUSH
14451: CALL_OW 72
14455: PPUSH
14456: LD_VAR 0 5
14460: PPUSH
14461: CALL_OW 120
// exit ;
14465: GO 14891
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14467: LD_VAR 0 4
14471: PPUSH
14472: LD_INT 54
14474: PUSH
14475: EMPTY
14476: LIST
14477: PPUSH
14478: CALL_OW 72
14482: IFFALSE 14504
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
14484: LD_VAR 0 4
14488: PPUSH
14489: LD_INT 54
14491: PUSH
14492: EMPTY
14493: LIST
14494: PPUSH
14495: CALL_OW 72
14499: PPUSH
14500: CALL_OW 122
// if not tmp then
14504: LD_VAR 0 3
14508: NOT
14509: IFFALSE 14641
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
14511: LD_INT 81
14513: PUSH
14514: LD_INT 3
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 92
14523: PUSH
14524: LD_INT 147
14526: PUSH
14527: LD_INT 212
14529: PUSH
14530: LD_INT 30
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PPUSH
14543: CALL_OW 69
14547: NOT
14548: IFFALSE 14641
// begin if not HasTask ( engs [ 1 ] ) then
14550: LD_VAR 0 4
14554: PUSH
14555: LD_INT 1
14557: ARRAY
14558: PPUSH
14559: CALL_OW 314
14563: NOT
14564: IFFALSE 14641
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
14566: LD_ADDR_VAR 0 2
14570: PUSH
14571: LD_VAR 0 4
14575: PPUSH
14576: LD_EXP 37
14580: PUSH
14581: LD_INT 1
14583: ARRAY
14584: PPUSH
14585: LD_EXP 37
14589: PUSH
14590: LD_INT 2
14592: ARRAY
14593: PPUSH
14594: LD_EXP 37
14598: PUSH
14599: LD_INT 3
14601: ARRAY
14602: PPUSH
14603: LD_EXP 37
14607: PUSH
14608: LD_INT 4
14610: ARRAY
14611: PPUSH
14612: CALL_OW 145
14616: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
14617: LD_VAR 0 2
14621: PPUSH
14622: CALL_OW 266
14626: PUSH
14627: LD_INT 4
14629: EQUAL
14630: IFFALSE 14641
// AddComUpgrade ( i ) ;
14632: LD_VAR 0 2
14636: PPUSH
14637: CALL_OW 206
// end ; end ; end ; for i in engs do
14641: LD_ADDR_VAR 0 2
14645: PUSH
14646: LD_VAR 0 4
14650: PUSH
14651: FOR_IN
14652: IFFALSE 14770
// begin if i in to_heal and sci then
14654: LD_VAR 0 2
14658: PUSH
14659: LD_VAR 0 6
14663: IN
14664: PUSH
14665: LD_VAR 0 7
14669: AND
14670: IFFALSE 14721
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
14672: LD_VAR 0 2
14676: PPUSH
14677: LD_INT 149
14679: PPUSH
14680: LD_INT 220
14682: PPUSH
14683: CALL_OW 297
14687: PUSH
14688: LD_INT 5
14690: LESS
14691: IFFALSE 14695
// continue ;
14693: GO 14651
// ComMoveXY ( i , 149 , 220 ) ;
14695: LD_VAR 0 2
14699: PPUSH
14700: LD_INT 149
14702: PPUSH
14703: LD_INT 220
14705: PPUSH
14706: CALL_OW 111
// AddComHold ( i ) ;
14710: LD_VAR 0 2
14714: PPUSH
14715: CALL_OW 200
// end else
14719: GO 14768
// if not HasTask ( i ) or WantsToAttack ( i ) then
14721: LD_VAR 0 2
14725: PPUSH
14726: CALL_OW 314
14730: NOT
14731: PUSH
14732: LD_VAR 0 2
14736: PPUSH
14737: CALL_OW 319
14741: OR
14742: IFFALSE 14768
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
14744: LD_VAR 0 2
14748: PPUSH
14749: LD_VAR 0 3
14753: PPUSH
14754: LD_VAR 0 2
14758: PPUSH
14759: CALL_OW 74
14763: PPUSH
14764: CALL_OW 130
// end ;
14768: GO 14651
14770: POP
14771: POP
// if to_heal and sci then
14772: LD_VAR 0 6
14776: PUSH
14777: LD_VAR 0 7
14781: AND
14782: IFFALSE 14843
// begin if UnitFilter ( sci , [ f_inside ] ) then
14784: LD_VAR 0 7
14788: PPUSH
14789: LD_INT 54
14791: PUSH
14792: EMPTY
14793: LIST
14794: PPUSH
14795: CALL_OW 72
14799: IFFALSE 14823
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
14801: LD_VAR 0 7
14805: PPUSH
14806: LD_INT 54
14808: PUSH
14809: EMPTY
14810: LIST
14811: PPUSH
14812: CALL_OW 72
14816: PPUSH
14817: CALL_OW 122
14821: GO 14841
// ComHeal ( sci , to_heal [ 1 ] ) ;
14823: LD_VAR 0 7
14827: PPUSH
14828: LD_VAR 0 6
14832: PUSH
14833: LD_INT 1
14835: ARRAY
14836: PPUSH
14837: CALL_OW 128
// end else
14841: GO 14891
// if UnitFilter ( sci , [ f_outside ] ) and lab then
14843: LD_VAR 0 7
14847: PPUSH
14848: LD_INT 56
14850: PUSH
14851: EMPTY
14852: LIST
14853: PPUSH
14854: CALL_OW 72
14858: PUSH
14859: LD_VAR 0 8
14863: AND
14864: IFFALSE 14891
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
14866: LD_VAR 0 7
14870: PPUSH
14871: LD_INT 56
14873: PUSH
14874: EMPTY
14875: LIST
14876: PPUSH
14877: CALL_OW 72
14881: PPUSH
14882: LD_VAR 0 8
14886: PPUSH
14887: CALL_OW 120
// end ;
14891: PPOPN 8
14893: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
14894: LD_INT 22
14896: PUSH
14897: LD_INT 3
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: PUSH
14904: LD_INT 30
14906: PUSH
14907: LD_INT 3
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: PUSH
14923: LD_EXP 38
14927: AND
14928: IFFALSE 15054
14930: GO 14932
14932: DISABLE
14933: LD_INT 0
14935: PPUSH
14936: PPUSH
14937: PPUSH
// begin enable ;
14938: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: LD_INT 22
14946: PUSH
14947: LD_INT 3
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: PUSH
14954: LD_INT 30
14956: PUSH
14957: LD_INT 3
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PPUSH
14968: CALL_OW 69
14972: PUSH
14973: LD_INT 1
14975: ARRAY
14976: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
14977: LD_VAR 0 3
14981: PPUSH
14982: CALL_OW 313
14986: PUSH
14987: LD_INT 0
14989: EQUAL
14990: IFFALSE 14994
// exit ;
14992: GO 15054
// if BuildingStatus ( fac ) = bs_idle then
14994: LD_VAR 0 3
14998: PPUSH
14999: CALL_OW 461
15003: PUSH
15004: LD_INT 2
15006: EQUAL
15007: IFFALSE 15054
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15009: LD_VAR 0 3
15013: PPUSH
15014: LD_EXP 38
15018: PUSH
15019: LD_INT 1
15021: ARRAY
15022: PPUSH
15023: LD_EXP 38
15027: PUSH
15028: LD_INT 2
15030: ARRAY
15031: PPUSH
15032: LD_EXP 38
15036: PUSH
15037: LD_INT 3
15039: ARRAY
15040: PPUSH
15041: LD_EXP 38
15045: PUSH
15046: LD_INT 4
15048: ARRAY
15049: PPUSH
15050: CALL_OW 125
// end ;
15054: PPOPN 3
15056: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15057: LD_INT 0
15059: PPUSH
15060: PPUSH
15061: PPUSH
15062: PPUSH
15063: PPUSH
// uc_side := 3 ;
15064: LD_ADDR_OWVAR 20
15068: PUSH
15069: LD_INT 3
15071: ST_TO_ADDR
// uc_nation := 3 ;
15072: LD_ADDR_OWVAR 21
15076: PUSH
15077: LD_INT 3
15079: ST_TO_ADDR
// ru_can_attack := false ;
15080: LD_ADDR_EXP 8
15084: PUSH
15085: LD_INT 0
15087: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15088: LD_ADDR_VAR 0 6
15092: PUSH
15093: LD_INT 22
15095: PUSH
15096: LD_INT 3
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: PUSH
15103: LD_INT 30
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PUSH
15113: EMPTY
15114: LIST
15115: LIST
15116: PPUSH
15117: CALL_OW 69
15121: ST_TO_ADDR
// if fac then
15122: LD_VAR 0 6
15126: IFFALSE 15278
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15128: LD_ADDR_EXP 38
15132: PUSH
15133: LD_INT 24
15135: PUSH
15136: LD_INT 1
15138: PUSH
15139: LD_INT 3
15141: PUSH
15142: LD_INT 43
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: ST_TO_ADDR
// if wave > 1 then
15151: LD_VAR 0 1
15155: PUSH
15156: LD_INT 1
15158: GREATER
15159: IFFALSE 15212
// for i = 1 to Difficulty do
15161: LD_ADDR_VAR 0 3
15165: PUSH
15166: DOUBLE
15167: LD_INT 1
15169: DEC
15170: ST_TO_ADDR
15171: LD_OWVAR 67
15175: PUSH
15176: FOR_TO
15177: IFFALSE 15210
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15179: LD_ADDR_EXP 38
15183: PUSH
15184: LD_EXP 38
15188: PUSH
15189: LD_INT 24
15191: PUSH
15192: LD_INT 1
15194: PUSH
15195: LD_INT 3
15197: PUSH
15198: LD_INT 45
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: LIST
15205: LIST
15206: ADD
15207: ST_TO_ADDR
15208: GO 15176
15210: POP
15211: POP
// repeat wait ( 0 0$1 ) ;
15212: LD_INT 35
15214: PPUSH
15215: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15219: LD_EXP 38
15223: PUSH
15224: LD_INT 4
15226: LESS
15227: PUSH
15228: LD_VAR 0 6
15232: PUSH
15233: LD_INT 1
15235: ARRAY
15236: PPUSH
15237: CALL_OW 313
15241: PUSH
15242: LD_INT 0
15244: EQUAL
15245: OR
15246: PUSH
15247: LD_VAR 0 6
15251: PUSH
15252: LD_INT 1
15254: ARRAY
15255: PPUSH
15256: CALL_OW 461
15260: PUSH
15261: LD_INT 8
15263: PUSH
15264: LD_INT 6
15266: PUSH
15267: LD_INT 7
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: LIST
15274: IN
15275: OR
15276: IFFALSE 15212
// end ; case wave of 1 :
15278: LD_VAR 0 1
15282: PUSH
15283: LD_INT 1
15285: DOUBLE
15286: EQUAL
15287: IFTRUE 15291
15289: GO 15376
15291: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
15292: LD_ADDR_VAR 0 3
15296: PUSH
15297: DOUBLE
15298: LD_INT 1
15300: DEC
15301: ST_TO_ADDR
15302: LD_INT 3
15304: PUSH
15305: LD_INT 4
15307: PUSH
15308: LD_INT 5
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: LIST
15315: PUSH
15316: LD_OWVAR 67
15320: ARRAY
15321: PUSH
15322: FOR_TO
15323: IFFALSE 15331
// Sold ;
15325: CALL 15602 0 0
15329: GO 15322
15331: POP
15332: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15333: LD_ADDR_VAR 0 3
15337: PUSH
15338: DOUBLE
15339: LD_INT 1
15341: DEC
15342: ST_TO_ADDR
15343: LD_INT 2
15345: PUSH
15346: LD_INT 3
15348: PUSH
15349: LD_INT 3
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: LIST
15356: PUSH
15357: LD_OWVAR 67
15361: ARRAY
15362: PUSH
15363: FOR_TO
15364: IFFALSE 15372
// Tank ;
15366: CALL 15732 0 0
15370: GO 15363
15372: POP
15373: POP
// end ; 2 .. 9 :
15374: GO 15589
15376: LD_INT 2
15378: DOUBLE
15379: GREATEREQUAL
15380: IFFALSE 15388
15382: LD_INT 9
15384: DOUBLE
15385: LESSEQUAL
15386: IFTRUE 15390
15388: GO 15495
15390: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15391: LD_ADDR_VAR 0 3
15395: PUSH
15396: DOUBLE
15397: LD_INT 1
15399: DEC
15400: ST_TO_ADDR
15401: LD_INT 3
15403: PUSH
15404: LD_INT 4
15406: PUSH
15407: LD_INT 5
15409: PUSH
15410: EMPTY
15411: LIST
15412: LIST
15413: LIST
15414: PUSH
15415: LD_OWVAR 67
15419: ARRAY
15420: PUSH
15421: LD_VAR 0 1
15425: PUSH
15426: LD_INT 2
15428: DIV
15429: PLUS
15430: PUSH
15431: FOR_TO
15432: IFFALSE 15440
// Sold ;
15434: CALL 15602 0 0
15438: GO 15431
15440: POP
15441: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15442: LD_ADDR_VAR 0 3
15446: PUSH
15447: DOUBLE
15448: LD_INT 1
15450: DEC
15451: ST_TO_ADDR
15452: LD_INT 2
15454: PUSH
15455: LD_INT 3
15457: PUSH
15458: LD_INT 3
15460: PUSH
15461: EMPTY
15462: LIST
15463: LIST
15464: LIST
15465: PUSH
15466: LD_OWVAR 67
15470: ARRAY
15471: PUSH
15472: LD_VAR 0 1
15476: PUSH
15477: LD_INT 2
15479: DIV
15480: PLUS
15481: PUSH
15482: FOR_TO
15483: IFFALSE 15491
// Tank ;
15485: CALL 15732 0 0
15489: GO 15482
15491: POP
15492: POP
// end ; 10 :
15493: GO 15589
15495: LD_INT 10
15497: DOUBLE
15498: EQUAL
15499: IFTRUE 15503
15501: GO 15588
15503: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
15504: LD_ADDR_VAR 0 3
15508: PUSH
15509: DOUBLE
15510: LD_INT 1
15512: DEC
15513: ST_TO_ADDR
15514: LD_INT 10
15516: PUSH
15517: LD_INT 12
15519: PUSH
15520: LD_INT 14
15522: PUSH
15523: EMPTY
15524: LIST
15525: LIST
15526: LIST
15527: PUSH
15528: LD_OWVAR 67
15532: ARRAY
15533: PUSH
15534: FOR_TO
15535: IFFALSE 15543
// Sold ;
15537: CALL 15602 0 0
15541: GO 15534
15543: POP
15544: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
15545: LD_ADDR_VAR 0 3
15549: PUSH
15550: DOUBLE
15551: LD_INT 1
15553: DEC
15554: ST_TO_ADDR
15555: LD_INT 11
15557: PUSH
15558: LD_INT 13
15560: PUSH
15561: LD_INT 15
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: LIST
15568: PUSH
15569: LD_OWVAR 67
15573: ARRAY
15574: PUSH
15575: FOR_TO
15576: IFFALSE 15584
// Tank ;
15578: CALL 15732 0 0
15582: GO 15575
15584: POP
15585: POP
// end ; end ;
15586: GO 15589
15588: POP
// ru_can_attack := true ;
15589: LD_ADDR_EXP 8
15593: PUSH
15594: LD_INT 1
15596: ST_TO_ADDR
// end ;
15597: LD_VAR 0 2
15601: RET
// function Sold ( ) ; var un , skill ; begin
15602: LD_INT 0
15604: PPUSH
15605: PPUSH
15606: PPUSH
// uc_side := 3 ;
15607: LD_ADDR_OWVAR 20
15611: PUSH
15612: LD_INT 3
15614: ST_TO_ADDR
// uc_nation := 3 ;
15615: LD_ADDR_OWVAR 21
15619: PUSH
15620: LD_INT 3
15622: ST_TO_ADDR
// InitHc ;
15623: CALL_OW 19
// skill := [ 6 , 7 , 7 ] [ Difficulty ] ;
15627: LD_ADDR_VAR 0 3
15631: PUSH
15632: LD_INT 6
15634: PUSH
15635: LD_INT 7
15637: PUSH
15638: LD_INT 7
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: LIST
15645: PUSH
15646: LD_OWVAR 67
15650: ARRAY
15651: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
15652: LD_INT 0
15654: PPUSH
15655: LD_INT 1
15657: PUSH
15658: LD_INT 9
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: PUSH
15665: LD_INT 1
15667: PPUSH
15668: LD_INT 2
15670: PPUSH
15671: CALL_OW 12
15675: ARRAY
15676: PPUSH
15677: LD_VAR 0 3
15681: PPUSH
15682: CALL_OW 380
// un := CreateHuman ;
15686: LD_ADDR_VAR 0 2
15690: PUSH
15691: CALL_OW 44
15695: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
15696: LD_VAR 0 2
15700: PPUSH
15701: LD_INT 4
15703: PPUSH
15704: LD_INT 0
15706: PPUSH
15707: CALL_OW 49
// ru_force := ru_force ^ un ;
15711: LD_ADDR_EXP 36
15715: PUSH
15716: LD_EXP 36
15720: PUSH
15721: LD_VAR 0 2
15725: ADD
15726: ST_TO_ADDR
// end ;
15727: LD_VAR 0 1
15731: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
15732: LD_INT 0
15734: PPUSH
15735: PPUSH
15736: PPUSH
15737: PPUSH
15738: PPUSH
// uc_side := 3 ;
15739: LD_ADDR_OWVAR 20
15743: PUSH
15744: LD_INT 3
15746: ST_TO_ADDR
// uc_nation := 3 ;
15747: LD_ADDR_OWVAR 21
15751: PUSH
15752: LD_INT 3
15754: ST_TO_ADDR
// InitHc ;
15755: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
15759: LD_ADDR_VAR 0 5
15763: PUSH
15764: LD_INT 5
15766: PUSH
15767: LD_INT 6
15769: PUSH
15770: LD_INT 7
15772: PUSH
15773: EMPTY
15774: LIST
15775: LIST
15776: LIST
15777: PUSH
15778: LD_OWVAR 67
15782: ARRAY
15783: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
15784: LD_ADDR_VAR 0 3
15788: PUSH
15789: LD_INT 22
15791: PUSH
15792: LD_INT 24
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: PUSH
15799: LD_INT 1
15801: PPUSH
15802: LD_INT 2
15804: PPUSH
15805: CALL_OW 12
15809: ARRAY
15810: ST_TO_ADDR
// if chassis = ru_medium_tracked then
15811: LD_VAR 0 3
15815: PUSH
15816: LD_INT 22
15818: EQUAL
15819: IFFALSE 15854
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
15821: LD_ADDR_VAR 0 4
15825: PUSH
15826: LD_INT 45
15828: PUSH
15829: LD_INT 43
15831: PUSH
15832: LD_INT 44
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: LIST
15839: PUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 3
15845: PPUSH
15846: CALL_OW 12
15850: ARRAY
15851: ST_TO_ADDR
15852: GO 15885
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
15854: LD_ADDR_VAR 0 4
15858: PUSH
15859: LD_INT 46
15861: PUSH
15862: LD_INT 44
15864: PUSH
15865: LD_INT 45
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: LIST
15872: PUSH
15873: LD_INT 1
15875: PPUSH
15876: LD_INT 3
15878: PPUSH
15879: CALL_OW 12
15883: ARRAY
15884: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
15885: LD_ADDR_VAR 0 2
15889: PUSH
15890: LD_INT 3
15892: PPUSH
15893: LD_INT 3
15895: PPUSH
15896: LD_VAR 0 3
15900: PPUSH
15901: LD_INT 1
15903: PPUSH
15904: LD_INT 3
15906: PUSH
15907: LD_INT 3
15909: PUSH
15910: LD_INT 3
15912: PUSH
15913: LD_INT 1
15915: PUSH
15916: EMPTY
15917: LIST
15918: LIST
15919: LIST
15920: LIST
15921: PUSH
15922: LD_INT 1
15924: PPUSH
15925: LD_INT 4
15927: PPUSH
15928: CALL_OW 12
15932: ARRAY
15933: PPUSH
15934: LD_VAR 0 4
15938: PPUSH
15939: LD_INT 99
15941: PPUSH
15942: CALL 296 0 7
15946: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
15947: LD_VAR 0 2
15951: PPUSH
15952: CALL_OW 263
15956: PUSH
15957: LD_INT 1
15959: EQUAL
15960: IFFALSE 15991
// begin PrepareHuman ( false , 3 , skill ) ;
15962: LD_INT 0
15964: PPUSH
15965: LD_INT 3
15967: PPUSH
15968: LD_VAR 0 5
15972: PPUSH
15973: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
15977: CALL_OW 44
15981: PPUSH
15982: LD_VAR 0 2
15986: PPUSH
15987: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
15991: LD_VAR 0 2
15995: PPUSH
15996: LD_INT 3
15998: PPUSH
15999: LD_INT 0
16001: PPUSH
16002: CALL_OW 49
// ru_force := ru_force ^ un ;
16006: LD_ADDR_EXP 36
16010: PUSH
16011: LD_EXP 36
16015: PUSH
16016: LD_VAR 0 2
16020: ADD
16021: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16022: LD_VAR 0 2
16026: PPUSH
16027: LD_INT 126
16029: PPUSH
16030: LD_INT 158
16032: PPUSH
16033: CALL_OW 111
// Wait ( 0 0$3 ) ;
16037: LD_INT 105
16039: PPUSH
16040: CALL_OW 67
// ComStop ( un ) ;
16044: LD_VAR 0 2
16048: PPUSH
16049: CALL_OW 141
// end ;
16053: LD_VAR 0 1
16057: RET
// every 0 0$1 do var i , time , wave ;
16058: GO 16060
16060: DISABLE
16061: LD_INT 0
16063: PPUSH
16064: PPUSH
16065: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16066: LD_ADDR_VAR 0 2
16070: PUSH
16071: LD_INT 25200
16073: PUSH
16074: LD_INT 24150
16076: PUSH
16077: LD_INT 23100
16079: PUSH
16080: EMPTY
16081: LIST
16082: LIST
16083: LIST
16084: PUSH
16085: LD_OWVAR 67
16089: ARRAY
16090: ST_TO_ADDR
// wait ( time ) ;
16091: LD_VAR 0 2
16095: PPUSH
16096: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16100: LD_ADDR_VAR 0 2
16104: PUSH
16105: LD_INT 15750
16107: PUSH
16108: LD_INT 15400
16110: PUSH
16111: LD_INT 15050
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: LIST
16118: PUSH
16119: LD_OWVAR 67
16123: ARRAY
16124: ST_TO_ADDR
// wave := 0 ;
16125: LD_ADDR_VAR 0 3
16129: PUSH
16130: LD_INT 0
16132: ST_TO_ADDR
// while true do
16133: LD_INT 1
16135: IFFALSE 16239
// begin wave := wave + 1 ;
16137: LD_ADDR_VAR 0 3
16141: PUSH
16142: LD_VAR 0 3
16146: PUSH
16147: LD_INT 1
16149: PLUS
16150: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16151: LD_INT 22
16153: PUSH
16154: LD_INT 2
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: PPUSH
16161: CALL_OW 69
16165: IFFALSE 16201
// begin repeat wait ( 0 0$1 ) ;
16167: LD_INT 35
16169: PPUSH
16170: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16174: LD_INT 22
16176: PUSH
16177: LD_INT 2
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: PPUSH
16184: CALL_OW 69
16188: PUSH
16189: LD_INT 0
16191: EQUAL
16192: IFFALSE 16167
// wait ( 1 1$30 ) ;
16194: LD_INT 3150
16196: PPUSH
16197: CALL_OW 67
// end ; if ru_force < 20 then
16201: LD_EXP 36
16205: PUSH
16206: LD_INT 20
16208: LESS
16209: IFFALSE 16220
// PrepareAttack ( wave ) ;
16211: LD_VAR 0 3
16215: PPUSH
16216: CALL 15057 0 1
// ru_can_attack := true ;
16220: LD_ADDR_EXP 8
16224: PUSH
16225: LD_INT 1
16227: ST_TO_ADDR
// wait ( time ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: CALL_OW 67
// end ;
16237: GO 16133
// end ;
16239: PPOPN 3
16241: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16242: LD_EXP 8
16246: PUSH
16247: LD_EXP 36
16251: AND
16252: IFFALSE 17086
16254: GO 16256
16256: DISABLE
16257: LD_INT 0
16259: PPUSH
16260: PPUSH
16261: PPUSH
16262: PPUSH
16263: PPUSH
16264: PPUSH
16265: PPUSH
16266: PPUSH
16267: PPUSH
// begin enable ;
16268: ENABLE
// points1 := [ 107 , 123 ] ;
16269: LD_ADDR_VAR 0 4
16273: PUSH
16274: LD_INT 107
16276: PUSH
16277: LD_INT 123
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16284: LD_ADDR_VAR 0 5
16288: PUSH
16289: LD_INT 55
16291: PUSH
16292: LD_INT 42
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_INT 102
16306: PUSH
16307: LD_INT 140
16309: PUSH
16310: EMPTY
16311: LIST
16312: LIST
16313: PUSH
16314: LD_INT 105
16316: PUSH
16317: LD_INT 142
16319: PUSH
16320: EMPTY
16321: LIST
16322: LIST
16323: PUSH
16324: LD_INT 129
16326: PUSH
16327: LD_INT 131
16329: PUSH
16330: EMPTY
16331: LIST
16332: LIST
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: LIST
16338: ST_TO_ADDR
// for i in ru_force do
16339: LD_ADDR_VAR 0 1
16343: PUSH
16344: LD_EXP 36
16348: PUSH
16349: FOR_IN
16350: IFFALSE 17084
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16352: LD_ADDR_VAR 0 3
16356: PUSH
16357: LD_INT 81
16359: PUSH
16360: LD_INT 3
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: PPUSH
16367: CALL_OW 69
16371: PPUSH
16372: LD_VAR 0 1
16376: PPUSH
16377: CALL_OW 74
16381: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16382: LD_VAR 0 1
16386: PPUSH
16387: LD_VAR 0 3
16391: PPUSH
16392: CALL_OW 296
16396: PUSH
16397: LD_INT 12
16399: LESS
16400: IFFALSE 16545
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16402: LD_VAR 0 1
16406: PPUSH
16407: CALL_OW 247
16411: PUSH
16412: LD_INT 1
16414: EQUAL
16415: PUSH
16416: LD_VAR 0 1
16420: PPUSH
16421: CALL_OW 257
16425: PUSH
16426: LD_INT 1
16428: EQUAL
16429: AND
16430: PUSH
16431: LD_VAR 0 3
16435: PUSH
16436: LD_INT 21
16438: PUSH
16439: LD_INT 2
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PUSH
16446: LD_INT 58
16448: PUSH
16449: EMPTY
16450: LIST
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: PPUSH
16456: CALL_OW 69
16460: IN
16461: AND
16462: IFFALSE 16480
// ComEnterUnit ( i , un ) else
16464: LD_VAR 0 1
16468: PPUSH
16469: LD_VAR 0 3
16473: PPUSH
16474: CALL_OW 120
16478: GO 16543
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16480: LD_VAR 0 3
16484: PUSH
16485: LD_INT 21
16487: PUSH
16488: LD_INT 2
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: PUSH
16495: LD_INT 58
16497: PUSH
16498: EMPTY
16499: LIST
16500: PUSH
16501: EMPTY
16502: LIST
16503: LIST
16504: PPUSH
16505: CALL_OW 69
16509: IN
16510: NOT
16511: IFFALSE 16529
// ComAttackUnit ( i , un ) else
16513: LD_VAR 0 1
16517: PPUSH
16518: LD_VAR 0 3
16522: PPUSH
16523: CALL_OW 115
16527: GO 16543
// ComAttackUnit ( i , JMM ) ;
16529: LD_VAR 0 1
16533: PPUSH
16534: LD_EXP 19
16538: PPUSH
16539: CALL_OW 115
// end else
16543: GO 17082
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
16545: LD_VAR 0 1
16549: PPUSH
16550: LD_VAR 0 4
16554: PUSH
16555: LD_INT 1
16557: ARRAY
16558: PPUSH
16559: LD_VAR 0 4
16563: PUSH
16564: LD_INT 2
16566: ARRAY
16567: PPUSH
16568: CALL_OW 297
16572: PUSH
16573: LD_VAR 0 1
16577: PPUSH
16578: LD_VAR 0 5
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: LD_VAR 0 5
16591: PUSH
16592: LD_INT 2
16594: ARRAY
16595: PPUSH
16596: CALL_OW 297
16600: GREATER
16601: PUSH
16602: LD_EXP 9
16606: AND
16607: PUSH
16608: LD_INT 9
16610: PPUSH
16611: LD_INT 81
16613: PUSH
16614: LD_INT 3
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: PPUSH
16621: CALL_OW 70
16625: PUSH
16626: LD_INT 0
16628: EQUAL
16629: OR
16630: IFFALSE 16668
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
16632: LD_VAR 0 1
16636: PPUSH
16637: LD_INT 81
16639: PUSH
16640: LD_INT 3
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PPUSH
16647: CALL_OW 69
16651: PPUSH
16652: LD_VAR 0 1
16656: PPUSH
16657: CALL_OW 74
16661: PPUSH
16662: CALL_OW 115
16666: GO 17082
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
16668: LD_VAR 0 1
16672: PPUSH
16673: CALL_OW 264
16677: PUSH
16678: LD_INT 45
16680: EQUAL
16681: PUSH
16682: LD_EXP 36
16686: PPUSH
16687: LD_INT 3
16689: PUSH
16690: LD_INT 34
16692: PUSH
16693: LD_INT 45
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: PPUSH
16704: CALL_OW 72
16708: PUSH
16709: LD_INT 6
16711: GREATER
16712: AND
16713: IFFALSE 16894
// begin dist := 9999 ;
16715: LD_ADDR_VAR 0 8
16719: PUSH
16720: LD_INT 9999
16722: ST_TO_ADDR
// xy := 0 ;
16723: LD_ADDR_VAR 0 9
16727: PUSH
16728: LD_INT 0
16730: ST_TO_ADDR
// for x in pointsr do
16731: LD_ADDR_VAR 0 7
16735: PUSH
16736: LD_VAR 0 6
16740: PUSH
16741: FOR_IN
16742: IFFALSE 16890
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
16744: LD_VAR 0 1
16748: PPUSH
16749: LD_VAR 0 7
16753: PUSH
16754: LD_INT 1
16756: ARRAY
16757: PPUSH
16758: LD_VAR 0 7
16762: PUSH
16763: LD_INT 2
16765: ARRAY
16766: PPUSH
16767: CALL_OW 297
16771: PUSH
16772: LD_VAR 0 8
16776: LESS
16777: IFFALSE 16822
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
16779: LD_ADDR_VAR 0 8
16783: PUSH
16784: LD_VAR 0 1
16788: PPUSH
16789: LD_VAR 0 7
16793: PUSH
16794: LD_INT 1
16796: ARRAY
16797: PPUSH
16798: LD_VAR 0 7
16802: PUSH
16803: LD_INT 2
16805: ARRAY
16806: PPUSH
16807: CALL_OW 297
16811: ST_TO_ADDR
// xy := x ;
16812: LD_ADDR_VAR 0 9
16816: PUSH
16817: LD_VAR 0 7
16821: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
16822: LD_VAR 0 9
16826: PUSH
16827: LD_VAR 0 1
16831: PPUSH
16832: LD_VAR 0 9
16836: PUSH
16837: LD_INT 1
16839: ARRAY
16840: PPUSH
16841: LD_VAR 0 9
16845: PUSH
16846: LD_INT 2
16848: ARRAY
16849: PPUSH
16850: CALL_OW 297
16854: PUSH
16855: LD_INT 9
16857: GREATER
16858: AND
16859: IFFALSE 16888
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
16861: LD_VAR 0 1
16865: PPUSH
16866: LD_VAR 0 9
16870: PUSH
16871: LD_INT 1
16873: ARRAY
16874: PPUSH
16875: LD_VAR 0 9
16879: PUSH
16880: LD_INT 2
16882: ARRAY
16883: PPUSH
16884: CALL_OW 114
// end ;
16888: GO 16741
16890: POP
16891: POP
// end else
16892: GO 17082
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
16894: LD_ADDR_VAR 0 3
16898: PUSH
16899: LD_OWVAR 3
16903: PUSH
16904: LD_VAR 0 1
16908: DIFF
16909: PPUSH
16910: LD_VAR 0 1
16914: PPUSH
16915: CALL_OW 74
16919: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
16920: LD_VAR 0 1
16924: PPUSH
16925: CALL_OW 320
16929: NOT
16930: PUSH
16931: LD_VAR 0 3
16935: PUSH
16936: LD_INT 21
16938: PUSH
16939: LD_INT 2
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PUSH
16946: LD_INT 33
16948: PUSH
16949: LD_INT 1
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: LD_INT 58
16958: PUSH
16959: EMPTY
16960: LIST
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: LIST
16966: PPUSH
16967: CALL_OW 69
16971: IN
16972: PUSH
16973: LD_VAR 0 3
16977: PUSH
16978: LD_INT 22
16980: PUSH
16981: LD_INT 3
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 21
16990: PUSH
16991: LD_INT 2
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 3
17000: PUSH
17001: LD_INT 24
17003: PUSH
17004: LD_INT 249
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PUSH
17015: EMPTY
17016: LIST
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: IN
17025: OR
17026: AND
17027: IFFALSE 17045
// ComAttackUnit ( i , un ) else
17029: LD_VAR 0 1
17033: PPUSH
17034: LD_VAR 0 3
17038: PPUSH
17039: CALL_OW 115
17043: GO 17082
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17045: LD_VAR 0 1
17049: PPUSH
17050: LD_INT 9
17052: PPUSH
17053: LD_INT 81
17055: PUSH
17056: LD_INT 3
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PPUSH
17063: CALL_OW 70
17067: PPUSH
17068: LD_VAR 0 1
17072: PPUSH
17073: CALL_OW 74
17077: PPUSH
17078: CALL_OW 115
// end ; end ; end ; end ;
17082: GO 16349
17084: POP
17085: POP
// end ;
17086: PPOPN 9
17088: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17089: LD_INT 22
17091: PUSH
17092: LD_INT 3
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: LD_INT 32
17101: PUSH
17102: LD_INT 1
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: PPUSH
17113: CALL_OW 69
17117: IFFALSE 17205
17119: GO 17121
17121: DISABLE
17122: LD_INT 0
17124: PPUSH
17125: PPUSH
// begin enable ;
17126: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17127: LD_ADDR_VAR 0 2
17131: PUSH
17132: LD_INT 22
17134: PUSH
17135: LD_INT 3
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PUSH
17142: LD_INT 32
17144: PUSH
17145: LD_INT 1
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PPUSH
17156: CALL_OW 69
17160: ST_TO_ADDR
// for i in tmp do
17161: LD_ADDR_VAR 0 1
17165: PUSH
17166: LD_VAR 0 2
17170: PUSH
17171: FOR_IN
17172: IFFALSE 17203
// if GetFuel ( i ) < 12 then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL_OW 261
17183: PUSH
17184: LD_INT 12
17186: LESS
17187: IFFALSE 17201
// SetFuel ( i , 12 ) ;
17189: LD_VAR 0 1
17193: PPUSH
17194: LD_INT 12
17196: PPUSH
17197: CALL_OW 240
17201: GO 17171
17203: POP
17204: POP
// end ;
17205: PPOPN 2
17207: END
// every 0 0$1 trigger can_end do
17208: LD_EXP 17
17212: IFFALSE 17235
17214: GO 17216
17216: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17217: LD_INT 3325
17219: PPUSH
17220: CALL_OW 67
// PrepareAttack ( 10 ) ;
17224: LD_INT 10
17226: PPUSH
17227: CALL 15057 0 1
// until false ;
17231: LD_INT 0
17233: IFFALSE 17217
// end ; end_of_file
17235: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17236: GO 17238
17238: DISABLE
// begin ru_radar := 98 ;
17239: LD_ADDR_EXP 39
17243: PUSH
17244: LD_INT 98
17246: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17247: LD_ADDR_EXP 40
17251: PUSH
17252: LD_INT 89
17254: ST_TO_ADDR
// us_hack := 99 ;
17255: LD_ADDR_EXP 41
17259: PUSH
17260: LD_INT 99
17262: ST_TO_ADDR
// us_artillery := 97 ;
17263: LD_ADDR_EXP 42
17267: PUSH
17268: LD_INT 97
17270: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17271: LD_ADDR_EXP 43
17275: PUSH
17276: LD_INT 91
17278: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
17279: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17280: LD_INT 0
17282: PPUSH
17283: PPUSH
17284: PPUSH
17285: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17286: LD_VAR 0 1
17290: PPUSH
17291: CALL_OW 264
17295: PUSH
17296: LD_EXP 43
17300: EQUAL
17301: IFFALSE 17373
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17303: LD_INT 68
17305: PPUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 255
17315: PPUSH
17316: CALL_OW 321
17320: PUSH
17321: LD_INT 2
17323: EQUAL
17324: IFFALSE 17336
// eff := 70 else
17326: LD_ADDR_VAR 0 6
17330: PUSH
17331: LD_INT 70
17333: ST_TO_ADDR
17334: GO 17344
// eff := 30 ;
17336: LD_ADDR_VAR 0 6
17340: PUSH
17341: LD_INT 30
17343: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17344: LD_VAR 0 1
17348: PPUSH
17349: CALL_OW 250
17353: PPUSH
17354: LD_VAR 0 1
17358: PPUSH
17359: CALL_OW 251
17363: PPUSH
17364: LD_VAR 0 6
17368: PPUSH
17369: CALL_OW 495
// end ; end ;
17373: LD_VAR 0 4
17377: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17378: LD_INT 0
17380: PPUSH
17381: PPUSH
17382: PPUSH
17383: PPUSH
17384: PPUSH
17385: PPUSH
// if cmd = 124 then
17386: LD_VAR 0 1
17390: PUSH
17391: LD_INT 124
17393: EQUAL
17394: IFFALSE 17600
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17396: LD_ADDR_VAR 0 5
17400: PUSH
17401: LD_INT 2
17403: PUSH
17404: LD_INT 34
17406: PUSH
17407: LD_INT 53
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: PUSH
17414: LD_INT 34
17416: PUSH
17417: LD_INT 14
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: LIST
17428: PPUSH
17429: CALL_OW 69
17433: ST_TO_ADDR
// if not tmp then
17434: LD_VAR 0 5
17438: NOT
17439: IFFALSE 17443
// exit ;
17441: GO 17600
// for i in tmp do
17443: LD_ADDR_VAR 0 3
17447: PUSH
17448: LD_VAR 0 5
17452: PUSH
17453: FOR_IN
17454: IFFALSE 17598
// begin taskList := GetTaskList ( i ) ;
17456: LD_ADDR_VAR 0 6
17460: PUSH
17461: LD_VAR 0 3
17465: PPUSH
17466: CALL_OW 437
17470: ST_TO_ADDR
// if not taskList then
17471: LD_VAR 0 6
17475: NOT
17476: IFFALSE 17480
// continue ;
17478: GO 17453
// for j = 1 to taskList do
17480: LD_ADDR_VAR 0 4
17484: PUSH
17485: DOUBLE
17486: LD_INT 1
17488: DEC
17489: ST_TO_ADDR
17490: LD_VAR 0 6
17494: PUSH
17495: FOR_TO
17496: IFFALSE 17594
// if taskList [ j ] [ 1 ] = | then
17498: LD_VAR 0 6
17502: PUSH
17503: LD_VAR 0 4
17507: ARRAY
17508: PUSH
17509: LD_INT 1
17511: ARRAY
17512: PUSH
17513: LD_STRING |
17515: EQUAL
17516: IFFALSE 17592
// begin _taskList := Delete ( taskList , 1 ) ;
17518: LD_ADDR_VAR 0 7
17522: PUSH
17523: LD_VAR 0 6
17527: PPUSH
17528: LD_INT 1
17530: PPUSH
17531: CALL_OW 3
17535: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17536: LD_VAR 0 3
17540: PPUSH
17541: LD_VAR 0 7
17545: PPUSH
17546: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17550: LD_VAR 0 3
17554: PPUSH
17555: LD_VAR 0 6
17559: PUSH
17560: LD_VAR 0 4
17564: ARRAY
17565: PUSH
17566: LD_INT 2
17568: ARRAY
17569: PPUSH
17570: LD_VAR 0 6
17574: PUSH
17575: LD_VAR 0 4
17579: ARRAY
17580: PUSH
17581: LD_INT 3
17583: ARRAY
17584: PPUSH
17585: LD_INT 8
17587: PPUSH
17588: CALL 17605 0 4
// end ;
17592: GO 17495
17594: POP
17595: POP
// end ;
17596: GO 17453
17598: POP
17599: POP
// end ; end ;
17600: LD_VAR 0 2
17604: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17605: LD_INT 0
17607: PPUSH
17608: PPUSH
17609: PPUSH
17610: PPUSH
17611: PPUSH
17612: PPUSH
17613: PPUSH
17614: PPUSH
17615: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17616: LD_VAR 0 1
17620: NOT
17621: PUSH
17622: LD_VAR 0 2
17626: PPUSH
17627: LD_VAR 0 3
17631: PPUSH
17632: CALL_OW 488
17636: NOT
17637: OR
17638: PUSH
17639: LD_VAR 0 4
17643: NOT
17644: OR
17645: IFFALSE 17649
// exit ;
17647: GO 17989
// list := [ ] ;
17649: LD_ADDR_VAR 0 13
17653: PUSH
17654: EMPTY
17655: ST_TO_ADDR
// if x - r < 0 then
17656: LD_VAR 0 2
17660: PUSH
17661: LD_VAR 0 4
17665: MINUS
17666: PUSH
17667: LD_INT 0
17669: LESS
17670: IFFALSE 17682
// min_x := 0 else
17672: LD_ADDR_VAR 0 7
17676: PUSH
17677: LD_INT 0
17679: ST_TO_ADDR
17680: GO 17698
// min_x := x - r ;
17682: LD_ADDR_VAR 0 7
17686: PUSH
17687: LD_VAR 0 2
17691: PUSH
17692: LD_VAR 0 4
17696: MINUS
17697: ST_TO_ADDR
// if y - r < 0 then
17698: LD_VAR 0 3
17702: PUSH
17703: LD_VAR 0 4
17707: MINUS
17708: PUSH
17709: LD_INT 0
17711: LESS
17712: IFFALSE 17724
// min_y := 0 else
17714: LD_ADDR_VAR 0 8
17718: PUSH
17719: LD_INT 0
17721: ST_TO_ADDR
17722: GO 17740
// min_y := y - r ;
17724: LD_ADDR_VAR 0 8
17728: PUSH
17729: LD_VAR 0 3
17733: PUSH
17734: LD_VAR 0 4
17738: MINUS
17739: ST_TO_ADDR
// max_x := x + r ;
17740: LD_ADDR_VAR 0 9
17744: PUSH
17745: LD_VAR 0 2
17749: PUSH
17750: LD_VAR 0 4
17754: PLUS
17755: ST_TO_ADDR
// max_y := y + r ;
17756: LD_ADDR_VAR 0 10
17760: PUSH
17761: LD_VAR 0 3
17765: PUSH
17766: LD_VAR 0 4
17770: PLUS
17771: ST_TO_ADDR
// for _x = min_x to max_x do
17772: LD_ADDR_VAR 0 11
17776: PUSH
17777: DOUBLE
17778: LD_VAR 0 7
17782: DEC
17783: ST_TO_ADDR
17784: LD_VAR 0 9
17788: PUSH
17789: FOR_TO
17790: IFFALSE 17907
// for _y = min_y to max_y do
17792: LD_ADDR_VAR 0 12
17796: PUSH
17797: DOUBLE
17798: LD_VAR 0 8
17802: DEC
17803: ST_TO_ADDR
17804: LD_VAR 0 10
17808: PUSH
17809: FOR_TO
17810: IFFALSE 17903
// begin if not ValidHex ( _x , _y ) then
17812: LD_VAR 0 11
17816: PPUSH
17817: LD_VAR 0 12
17821: PPUSH
17822: CALL_OW 488
17826: NOT
17827: IFFALSE 17831
// continue ;
17829: GO 17809
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
17831: LD_VAR 0 11
17835: PPUSH
17836: LD_VAR 0 12
17840: PPUSH
17841: CALL_OW 351
17845: PUSH
17846: LD_VAR 0 11
17850: PPUSH
17851: LD_VAR 0 12
17855: PPUSH
17856: CALL_OW 554
17860: AND
17861: IFFALSE 17901
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
17863: LD_ADDR_VAR 0 13
17867: PUSH
17868: LD_VAR 0 13
17872: PPUSH
17873: LD_VAR 0 13
17877: PUSH
17878: LD_INT 1
17880: PLUS
17881: PPUSH
17882: LD_VAR 0 11
17886: PUSH
17887: LD_VAR 0 12
17891: PUSH
17892: EMPTY
17893: LIST
17894: LIST
17895: PPUSH
17896: CALL_OW 2
17900: ST_TO_ADDR
// end ;
17901: GO 17809
17903: POP
17904: POP
17905: GO 17789
17907: POP
17908: POP
// if not list then
17909: LD_VAR 0 13
17913: NOT
17914: IFFALSE 17918
// exit ;
17916: GO 17989
// for i in list do
17918: LD_ADDR_VAR 0 6
17922: PUSH
17923: LD_VAR 0 13
17927: PUSH
17928: FOR_IN
17929: IFFALSE 17987
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
17931: LD_VAR 0 1
17935: PPUSH
17936: LD_STRING M
17938: PUSH
17939: LD_VAR 0 6
17943: PUSH
17944: LD_INT 1
17946: ARRAY
17947: PUSH
17948: LD_VAR 0 6
17952: PUSH
17953: LD_INT 2
17955: ARRAY
17956: PUSH
17957: LD_INT 0
17959: PUSH
17960: LD_INT 0
17962: PUSH
17963: LD_INT 0
17965: PUSH
17966: LD_INT 0
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: LIST
17975: LIST
17976: LIST
17977: PUSH
17978: EMPTY
17979: LIST
17980: PPUSH
17981: CALL_OW 447
17985: GO 17928
17987: POP
17988: POP
// end ;
17989: LD_VAR 0 5
17993: RET
