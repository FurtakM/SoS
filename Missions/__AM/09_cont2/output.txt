// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13721 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2966 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := 0 ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// hc_name := Peter McCreery ;
2391: LD_ADDR_OWVAR 26
2395: PUSH
2396: LD_STRING Peter McCreery
2398: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2399: LD_ADDR_OWVAR 33
2403: PUSH
2404: LD_STRING SecondCharsGal
2406: ST_TO_ADDR
// hc_face_number := 58 ;
2407: LD_ADDR_OWVAR 34
2411: PUSH
2412: LD_INT 58
2414: ST_TO_ADDR
// hc_sex := sex_male ;
2415: LD_ADDR_OWVAR 27
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// hc_class := 4 ;
2423: LD_ADDR_OWVAR 28
2427: PUSH
2428: LD_INT 4
2430: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 2 ] ;
2431: LD_ADDR_OWVAR 30
2435: PUSH
2436: LD_INT 0
2438: PUSH
2439: LD_INT 0
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 6 ] ;
2454: LD_ADDR_OWVAR 31
2458: PUSH
2459: LD_INT 1
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 3
2467: PUSH
2468: LD_INT 6
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// un := CreateHuman ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// SetTag ( un , 11 ) ;
2487: LD_VAR 0 5
2491: PPUSH
2492: LD_INT 11
2494: PPUSH
2495: CALL_OW 109
// tmp := tmp ^ un ;
2499: LD_ADDR_VAR 0 4
2503: PUSH
2504: LD_VAR 0 4
2508: PUSH
2509: LD_VAR 0 5
2513: ADD
2514: ST_TO_ADDR
// tmp := tmp diff 0 ;
2515: LD_ADDR_VAR 0 4
2519: PUSH
2520: LD_VAR 0 4
2524: PUSH
2525: LD_INT 0
2527: DIFF
2528: ST_TO_ADDR
// InitHc ;
2529: CALL_OW 19
// hc_name :=  ;
2533: LD_ADDR_OWVAR 26
2537: PUSH
2538: LD_STRING 
2540: ST_TO_ADDR
// hc_gallery :=  ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING 
2548: ST_TO_ADDR
// if debug then
2549: LD_EXP 2
2553: IFFALSE 2604
// begin for i = 1 to 6 do
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: DOUBLE
2561: LD_INT 1
2563: DEC
2564: ST_TO_ADDR
2565: LD_INT 6
2567: PUSH
2568: FOR_TO
2569: IFFALSE 2602
// begin PrepareHuman ( false , 1 , 6 ) ;
2571: LD_INT 0
2573: PPUSH
2574: LD_INT 1
2576: PPUSH
2577: LD_INT 6
2579: PPUSH
2580: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_VAR 0 4
2593: PUSH
2594: CALL_OW 44
2598: ADD
2599: ST_TO_ADDR
// end ;
2600: GO 2568
2602: POP
2603: POP
// end ; for i in tmp do
2604: LD_ADDR_VAR 0 2
2608: PUSH
2609: LD_VAR 0 4
2613: PUSH
2614: FOR_IN
2615: IFFALSE 2674
// begin if GetClass ( i ) in [ 2 , 3 ] then
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 257
2626: PUSH
2627: LD_INT 2
2629: PUSH
2630: LD_INT 3
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: IN
2637: IFFALSE 2651
// SetClass ( i , 1 ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 1
2646: PPUSH
2647: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 106
2658: PPUSH
2659: LD_INT 122
2661: PPUSH
2662: LD_INT 5
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 50
// end ;
2672: GO 2614
2674: POP
2675: POP
// tmp := tmp diff Gary ;
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_EXP 22
2690: DIFF
2691: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 30
2709: PUSH
2710: LD_INT 31
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PPUSH
2721: CALL_OW 69
2725: ST_TO_ADDR
// for i = 1 to b do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: DOUBLE
2732: LD_INT 1
2734: DEC
2735: ST_TO_ADDR
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_TO
2742: IFFALSE 2787
// ComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) [ i ] , b [ i ] ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_INT 25
2751: PUSH
2752: LD_INT 1
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 72
2763: PUSH
2764: LD_VAR 0 2
2768: ARRAY
2769: PPUSH
2770: LD_VAR 0 3
2774: PUSH
2775: LD_VAR 0 2
2779: ARRAY
2780: PPUSH
2781: CALL_OW 120
2785: GO 2741
2787: POP
2788: POP
// InitHc ;
2789: CALL_OW 19
// InitUc ;
2793: CALL_OW 18
// end ;
2797: LD_VAR 0 1
2801: RET
// export function PowellTransport ; var i , un ; begin
2802: LD_INT 0
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side := 4 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 4
2814: ST_TO_ADDR
// uc_nation := 1 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2823: LD_INT 1
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: LD_INT 6
2831: PPUSH
2832: CALL_OW 380
// hc_name :=  ;
2836: LD_ADDR_OWVAR 26
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING SecondCharsGal
2851: ST_TO_ADDR
// hc_face_number := 30 ;
2852: LD_ADDR_OWVAR 34
2856: PUSH
2857: LD_INT 30
2859: ST_TO_ADDR
// powell_trans := CreateHuman ;
2860: LD_ADDR_EXP 27
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// hc_face_number := 31 ;
2870: LD_ADDR_OWVAR 34
2874: PUSH
2875: LD_INT 31
2877: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2878: LD_ADDR_EXP 27
2882: PUSH
2883: LD_EXP 27
2887: PUSH
2888: CALL_OW 44
2892: ADD
2893: ST_TO_ADDR
// for i = 1 to 2 do
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: DOUBLE
2900: LD_INT 1
2902: DEC
2903: ST_TO_ADDR
2904: LD_INT 2
2906: PUSH
2907: FOR_TO
2908: IFFALSE 2959
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2910: LD_ADDR_VAR 0 3
2914: PUSH
2915: LD_INT 4
2917: PPUSH
2918: LD_INT 1
2920: PPUSH
2921: LD_INT 3
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: LD_INT 12
2932: PPUSH
2933: LD_INT 66
2935: PPUSH
2936: CALL 423 0 7
2940: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2941: LD_ADDR_EXP 27
2945: PUSH
2946: LD_EXP 27
2950: PUSH
2951: LD_VAR 0 3
2955: ADD
2956: ST_TO_ADDR
// end ;
2957: GO 2907
2959: POP
2960: POP
// end ; end_of_file
2961: LD_VAR 0 1
2965: RET
// export function Action ; var i , veh ; begin
2966: LD_INT 0
2968: PPUSH
2969: PPUSH
2970: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2971: LD_EXP 26
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: LD_INT 50
2981: PPUSH
2982: LD_INT 38
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: CALL_OW 145
// InGameOn ;
2992: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2996: LD_INT 43
2998: PPUSH
2999: LD_INT 9
3001: PPUSH
3002: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
3006: LD_EXP 21
3010: PPUSH
3011: LD_INT 54
3013: PPUSH
3014: LD_INT 34
3016: PPUSH
3017: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
3021: LD_EXP 21
3025: PPUSH
3026: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
3030: LD_EXP 21
3034: PPUSH
3035: LD_EXP 26
3039: PUSH
3040: LD_INT 1
3042: ARRAY
3043: PPUSH
3044: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// until See ( 4 , JMM ) ;
3055: LD_INT 4
3057: PPUSH
3058: LD_EXP 21
3062: PPUSH
3063: CALL_OW 292
3067: IFFALSE 3048
// CenterNowOnUnits ( JMM ) ;
3069: LD_EXP 21
3073: PPUSH
3074: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
3078: LD_EXP 21
3082: PPUSH
3083: LD_STRING D2-JMM-1
3085: PPUSH
3086: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
3090: LD_EXP 26
3094: PUSH
3095: LD_INT 3
3097: ARRAY
3098: PPUSH
3099: LD_EXP 21
3103: PPUSH
3104: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
3108: LD_EXP 26
3112: PUSH
3113: LD_INT 3
3115: ARRAY
3116: PPUSH
3117: LD_STRING D2-Eng1-1
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3124: LD_EXP 21
3128: PPUSH
3129: LD_STRING D2-JMM-2
3131: PPUSH
3132: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
3136: LD_EXP 26
3140: PUSH
3141: LD_INT 3
3143: ARRAY
3144: PPUSH
3145: LD_STRING D2-Eng1-2
3147: PPUSH
3148: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3152: LD_EXP 21
3156: PPUSH
3157: LD_STRING D2-JMM-3
3159: PPUSH
3160: CALL_OW 88
// if Houten then
3164: LD_EXP 25
3168: IFFALSE 3366
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3170: LD_ADDR_VAR 0 3
3174: PUSH
3175: LD_INT 4
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 4
3192: PPUSH
3193: LD_INT 55
3195: PPUSH
3196: CALL 423 0 7
3200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3201: LD_VAR 0 3
3205: PPUSH
3206: LD_INT 3
3208: PPUSH
3209: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3213: LD_VAR 0 3
3217: PPUSH
3218: LD_INT 46
3220: PPUSH
3221: LD_INT 19
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3231: LD_EXP 25
3235: PPUSH
3236: LD_VAR 0 3
3240: PPUSH
3241: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3245: LD_EXP 25
3249: PPUSH
3250: LD_INT 49
3252: PPUSH
3253: LD_INT 33
3255: PPUSH
3256: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3260: LD_EXP 25
3264: PPUSH
3265: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3269: LD_EXP 25
3273: PPUSH
3274: LD_EXP 21
3278: PPUSH
3279: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3283: LD_INT 35
3285: PPUSH
3286: CALL_OW 67
// until See ( 1 , Houten ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_EXP 25
3297: PPUSH
3298: CALL_OW 292
3302: IFFALSE 3283
// ComTurnUnit ( JMM , Houten ) ;
3304: LD_EXP 21
3308: PPUSH
3309: LD_EXP 25
3313: PPUSH
3314: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3318: LD_EXP 21
3322: PPUSH
3323: LD_STRING D1d-JMM-1
3325: PPUSH
3326: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3330: LD_EXP 25
3334: PPUSH
3335: LD_STRING D1-VanH-1
3337: PPUSH
3338: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3342: LD_EXP 21
3346: PPUSH
3347: LD_STRING D1-JMM-1v
3349: PPUSH
3350: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3354: LD_EXP 21
3358: PPUSH
3359: LD_STRING D1-JMM-2v
3361: PPUSH
3362: CALL_OW 88
// end ; InGameOff ;
3366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3370: LD_STRING M1
3372: PPUSH
3373: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3377: LD_INT 22
3379: PUSH
3380: LD_INT 4
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 92
3389: PUSH
3390: LD_EXP 21
3394: PPUSH
3395: CALL_OW 250
3399: PUSH
3400: LD_EXP 21
3404: PPUSH
3405: CALL_OW 251
3409: PUSH
3410: LD_INT 15
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3435: LD_EXP 26
3439: PUSH
3440: LD_EXP 21
3444: ADD
3445: PUSH
3446: LD_EXP 25
3450: ADD
3451: PPUSH
3452: CALL_OW 141
// end ;
3456: LD_VAR 0 1
3460: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3461: LD_INT 1
3463: PPUSH
3464: LD_EXP 22
3468: PPUSH
3469: CALL_OW 292
3473: PUSH
3474: LD_EXP 21
3478: PPUSH
3479: LD_EXP 22
3483: PPUSH
3484: CALL_OW 296
3488: PUSH
3489: LD_INT 6
3491: LESS
3492: AND
3493: IFFALSE 4366
3495: GO 3497
3497: DISABLE
3498: LD_INT 0
3500: PPUSH
3501: PPUSH
3502: PPUSH
3503: PPUSH
3504: PPUSH
// begin InGameOn ;
3505: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PPUSH
3519: CALL_OW 69
3523: PPUSH
3524: LD_INT 1
3526: PPUSH
3527: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3531: LD_ADDR_VAR 0 4
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 1
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 25
3561: PUSH
3562: LD_INT 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 25
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 25
3581: PUSH
3582: LD_INT 4
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// ComHold ( tmp ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3614: LD_EXP 21
3618: PPUSH
3619: LD_STRING D2-JMM-3a
3621: PPUSH
3622: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3626: LD_EXP 22
3630: PPUSH
3631: LD_EXP 21
3635: PPUSH
3636: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3640: LD_EXP 22
3644: PPUSH
3645: LD_STRING D2-Gary-3
3647: PPUSH
3648: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3652: LD_EXP 21
3656: PPUSH
3657: LD_EXP 22
3661: PPUSH
3662: CALL_OW 119
// for i in tmp do
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: LD_VAR 0 4
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3722
// begin if IsInUnit ( i ) then
3679: LD_VAR 0 5
3683: PPUSH
3684: CALL_OW 310
3688: IFFALSE 3699
// ComExitBuilding ( i ) ;
3690: LD_VAR 0 5
3694: PPUSH
3695: CALL_OW 122
// wait ( 1 ) ;
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_EXP 21
3715: PPUSH
3716: CALL_OW 119
// end ;
3720: GO 3676
3722: POP
3723: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3724: LD_ADDR_VAR 0 4
3728: PUSH
3729: LD_VAR 0 4
3733: PUSH
3734: LD_EXP 21
3738: PUSH
3739: LD_EXP 25
3743: PUSH
3744: LD_EXP 22
3748: PUSH
3749: LD_EXP 24
3753: PUSH
3754: LD_EXP 23
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: PUSH
3766: LD_EXP 26
3770: ADD
3771: DIFF
3772: ST_TO_ADDR
// if Bobby then
3773: LD_EXP 23
3777: IFFALSE 3791
// Say ( Bobby , D2-Bobby-3 ) ;
3779: LD_EXP 23
3783: PPUSH
3784: LD_STRING D2-Bobby-3
3786: PPUSH
3787: CALL_OW 88
// if Cyrus then
3791: LD_EXP 24
3795: IFFALSE 3809
// Say ( Cyrus , D2-Cyrus-3 ) ;
3797: LD_EXP 24
3801: PPUSH
3802: LD_STRING D2-Cyrus-3
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3809: LD_EXP 21
3813: PPUSH
3814: LD_STRING D2-JMM-4
3816: PPUSH
3817: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3821: LD_EXP 22
3825: PPUSH
3826: LD_STRING D2-Gary-4
3828: PPUSH
3829: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3833: LD_ADDR_VAR 0 1
3837: PUSH
3838: LD_VAR 0 4
3842: PPUSH
3843: LD_INT 26
3845: PUSH
3846: LD_INT 1
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 72
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// if Cyrus then
3862: LD_EXP 24
3866: IFFALSE 3882
// Say ( Cyrus , D2-Cyrus-4 ) else
3868: LD_EXP 24
3872: PPUSH
3873: LD_STRING D2-Cyrus-4
3875: PPUSH
3876: CALL_OW 88
3880: GO 3894
// Say ( un1 , D2-Sol1-4 ) ;
3882: LD_VAR 0 1
3886: PPUSH
3887: LD_STRING D2-Sol1-4
3889: PPUSH
3890: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3894: LD_EXP 21
3898: PPUSH
3899: LD_STRING D2-JMM-5
3901: PPUSH
3902: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3906: LD_ADDR_VAR 0 2
3910: PUSH
3911: LD_EXP 26
3915: PPUSH
3916: LD_INT 91
3918: PUSH
3919: LD_EXP 21
3923: PUSH
3924: LD_INT 10
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: LIST
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 72
3950: ST_TO_ADDR
// if un2 then
3951: LD_VAR 0 2
3955: IFFALSE 4009
// begin un2 := un2 [ un2 ] ;
3957: LD_ADDR_VAR 0 2
3961: PUSH
3962: LD_VAR 0 2
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3973: LD_VAR 0 2
3977: PPUSH
3978: LD_STRING D2-FEng1-5
3980: PPUSH
3981: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3985: LD_EXP 21
3989: PPUSH
3990: LD_STRING D2-JMM-6
3992: PPUSH
3993: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_STRING D2-FEng1-6
4004: PPUSH
4005: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_EXP 26
4018: PPUSH
4019: LD_INT 91
4021: PUSH
4022: LD_EXP 21
4026: PUSH
4027: LD_INT 10
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 72
4053: ST_TO_ADDR
// if un3 then
4054: LD_VAR 0 3
4058: IFFALSE 4113
// begin un3 := un3 [ 1 ] ;
4060: LD_ADDR_VAR 0 3
4064: PUSH
4065: LD_VAR 0 3
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
4074: LD_VAR 0 3
4078: PPUSH
4079: LD_INT 114
4081: PPUSH
4082: LD_INT 122
4084: PPUSH
4085: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
4089: LD_VAR 0 3
4093: PPUSH
4094: LD_STRING D2-Eng1-6
4096: PPUSH
4097: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4101: LD_EXP 21
4105: PPUSH
4106: LD_STRING D2-JMM-7
4108: PPUSH
4109: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
4113: LD_EXP 22
4117: PPUSH
4118: LD_STRING D2-Gary-7
4120: PPUSH
4121: CALL_OW 88
// if un2 then
4125: LD_VAR 0 2
4129: IFFALSE 4143
// Say ( un2 , D2-FEng1-7 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING D2-FEng1-7
4138: PPUSH
4139: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
4143: LD_VAR 0 1
4147: PPUSH
4148: LD_STRING D2-Sol1-7
4150: PPUSH
4151: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
4155: LD_EXP 21
4159: PPUSH
4160: LD_STRING D2-JMM-8
4162: PPUSH
4163: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PPUSH
4182: CALL_OW 141
// InGameOff ;
4186: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4190: LD_STRING M1a
4192: PPUSH
4193: CALL_OW 337
// jmm_in_ovsyenko := true ;
4197: LD_ADDR_EXP 4
4201: PUSH
4202: LD_INT 1
4204: ST_TO_ADDR
// if debug then
4205: LD_EXP 2
4209: IFFALSE 4315
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PPUSH
4244: CALL_OW 274
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_INT 1000
4254: PPUSH
4255: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4259: LD_INT 22
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 30
4271: PUSH
4272: LD_INT 0
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PPUSH
4283: CALL_OW 69
4287: PUSH
4288: LD_INT 1
4290: ARRAY
4291: PPUSH
4292: CALL_OW 274
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 1000
4302: PPUSH
4303: CALL_OW 277
// ar_can_arrive := true ;
4307: LD_ADDR_EXP 10
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4315: LD_INT 1050
4317: PPUSH
4318: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4322: LD_ADDR_VAR 0 4
4326: PUSH
4327: LD_INT 25
4329: PUSH
4330: LD_INT 14
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// if not tmp then
4342: LD_VAR 0 4
4346: NOT
4347: IFFALSE 4351
// exit ;
4349: GO 4366
// ComMoveXY ( tmp , 75 , 75 ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_INT 75
4358: PPUSH
4359: LD_INT 75
4361: PPUSH
4362: CALL_OW 111
// end ;
4366: PPOPN 5
4368: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 30
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: LD_INT 57
4394: PUSH
4395: EMPTY
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: IFFALSE 4453
4413: GO 4415
4415: DISABLE
4416: LD_INT 0
4418: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4419: LD_ADDR_VAR 0 1
4423: PUSH
4424: LD_STRING M2easy
4426: PUSH
4427: LD_STRING M2
4429: PUSH
4430: LD_STRING M2hard
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4438: LD_VAR 0 1
4442: PUSH
4443: LD_OWVAR 67
4447: ARRAY
4448: PPUSH
4449: CALL_OW 337
// end ;
4453: PPOPN 1
4455: END
// every 3 3$00 do
4456: GO 4458
4458: DISABLE
// begin DialogueOn ;
4459: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4463: LD_EXP 28
4467: PPUSH
4468: LD_STRING D3-Pow-1
4470: PPUSH
4471: CALL_OW 94
// if jmm_in_ovsyenko then
4475: LD_EXP 4
4479: IFFALSE 4507
// begin Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 21
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4493: LD_EXP 21
4497: PPUSH
4498: LD_STRING D3-JMM-1b
4500: PPUSH
4501: CALL_OW 88
// end else
4505: GO 4519
// Say ( JMM , D3-JMM-1a ) ;
4507: LD_EXP 21
4511: PPUSH
4512: LD_STRING D3-JMM-1a
4514: PPUSH
4515: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4519: LD_EXP 28
4523: PPUSH
4524: LD_STRING D3-Pow-2
4526: PPUSH
4527: CALL_OW 94
// DialogueOff ;
4531: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4535: LD_STRING M3
4537: PPUSH
4538: CALL_OW 337
// powell_want_sib := true ;
4542: LD_ADDR_EXP 5
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end ;
4550: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4551: LD_EXP 6
4555: PUSH
4556: LD_INT 0
4558: EQUAL
4559: IFFALSE 6020
4561: GO 4563
4563: DISABLE
4564: LD_INT 0
4566: PPUSH
4567: PPUSH
4568: PPUSH
4569: PPUSH
4570: PPUSH
4571: PPUSH
4572: PPUSH
4573: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4574: LD_INT 4
4576: PPUSH
4577: LD_INT 1
4579: PPUSH
4580: CALL_OW 343
// PowellTransport ;
4584: CALL 2802 0 0
// for i = 1 to 3 do
4588: LD_ADDR_VAR 0 4
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_INT 3
4600: PUSH
4601: FOR_TO
4602: IFFALSE 4669
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 6
4611: PPUSH
4612: LD_VAR 0 4
4616: PPUSH
4617: CALL_OW 287
4621: ST_TO_ADDR
// if not tmp then
4622: LD_VAR 0 1
4626: NOT
4627: IFFALSE 4631
// continue ;
4629: GO 4601
// EraseResourceArea ( terminalArea , i ) ;
4631: LD_INT 6
4633: PPUSH
4634: LD_VAR 0 4
4638: PPUSH
4639: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4643: LD_EXP 3
4647: PPUSH
4648: CALL_OW 274
4652: PPUSH
4653: LD_VAR 0 4
4657: PPUSH
4658: LD_VAR 0 1
4662: PPUSH
4663: CALL_OW 276
// end ;
4667: GO 4601
4669: POP
4670: POP
// x := 43 ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_INT 43
4678: ST_TO_ADDR
// y := 3 ;
4679: LD_ADDR_VAR 0 3
4683: PUSH
4684: LD_INT 3
4686: ST_TO_ADDR
// for i = 3 to 4 do
4687: LD_ADDR_VAR 0 4
4691: PUSH
4692: DOUBLE
4693: LD_INT 3
4695: DEC
4696: ST_TO_ADDR
4697: LD_INT 4
4699: PUSH
4700: FOR_TO
4701: IFFALSE 4892
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4703: LD_EXP 27
4707: PUSH
4708: LD_VAR 0 4
4712: ARRAY
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4721: LD_EXP 27
4725: PUSH
4726: LD_VAR 0 4
4730: ARRAY
4731: PPUSH
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_VAR 0 3
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4749: LD_EXP 27
4753: PUSH
4754: LD_VAR 0 4
4758: PUSH
4759: LD_INT 2
4761: MINUS
4762: ARRAY
4763: PPUSH
4764: LD_EXP 27
4768: PUSH
4769: LD_VAR 0 4
4773: ARRAY
4774: PPUSH
4775: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4779: LD_EXP 27
4783: PUSH
4784: LD_VAR 0 4
4788: ARRAY
4789: PPUSH
4790: LD_INT 1
4792: PPUSH
4793: LD_INT 100
4795: PPUSH
4796: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4800: LD_EXP 27
4804: PUSH
4805: LD_VAR 0 4
4809: PUSH
4810: LD_INT 2
4812: MINUS
4813: ARRAY
4814: PPUSH
4815: LD_INT 54
4817: PPUSH
4818: LD_INT 42
4820: PPUSH
4821: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4825: LD_EXP 27
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_INT 2
4837: MINUS
4838: ARRAY
4839: PPUSH
4840: LD_EXP 3
4844: PPUSH
4845: CALL_OW 250
4849: PPUSH
4850: LD_EXP 3
4854: PPUSH
4855: CALL_OW 251
4859: PPUSH
4860: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4864: LD_EXP 27
4868: PUSH
4869: LD_VAR 0 4
4873: PUSH
4874: LD_INT 2
4876: MINUS
4877: ARRAY
4878: PPUSH
4879: CALL_OW 200
// Wait ( 0 0$02 ) ;
4883: LD_INT 70
4885: PPUSH
4886: CALL_OW 67
// end ;
4890: GO 4700
4892: POP
4893: POP
// time := 0 0$20 ;
4894: LD_ADDR_VAR 0 8
4898: PUSH
4899: LD_INT 700
4901: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4902: LD_INT 35
4904: PPUSH
4905: CALL_OW 67
// time := time - 0 0$01 ;
4909: LD_ADDR_VAR 0 8
4913: PUSH
4914: LD_VAR 0 8
4918: PUSH
4919: LD_INT 35
4921: MINUS
4922: ST_TO_ADDR
// for i = 3 to 4 do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 3
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 5072
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4939: LD_EXP 27
4943: PUSH
4944: LD_VAR 0 4
4948: ARRAY
4949: PPUSH
4950: LD_INT 1
4952: PPUSH
4953: CALL_OW 289
4957: PUSH
4958: LD_INT 0
4960: GREATER
4961: PUSH
4962: LD_EXP 27
4966: PUSH
4967: LD_VAR 0 4
4971: ARRAY
4972: PPUSH
4973: CALL_OW 314
4977: NOT
4978: AND
4979: IFFALSE 5070
// begin x := rand ( 0 , 5 ) ;
4981: LD_ADDR_VAR 0 2
4985: PUSH
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 5
4991: PPUSH
4992: CALL_OW 12
4996: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4997: LD_EXP 27
5001: PUSH
5002: LD_VAR 0 4
5006: ARRAY
5007: PPUSH
5008: LD_EXP 27
5012: PUSH
5013: LD_VAR 0 4
5017: ARRAY
5018: PPUSH
5019: CALL_OW 250
5023: PPUSH
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 3
5031: PPUSH
5032: CALL_OW 272
5036: PPUSH
5037: LD_EXP 27
5041: PUSH
5042: LD_VAR 0 4
5046: ARRAY
5047: PPUSH
5048: CALL_OW 251
5052: PPUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: CALL_OW 273
5065: PPUSH
5066: CALL_OW 171
// end ;
5070: GO 4936
5072: POP
5073: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 1
5081: ARRAY
5082: PPUSH
5083: LD_INT 54
5085: PPUSH
5086: LD_INT 42
5088: PPUSH
5089: CALL_OW 297
5093: PUSH
5094: LD_INT 4
5096: LESS
5097: PUSH
5098: LD_VAR 0 8
5102: PUSH
5103: LD_INT 0
5105: EQUAL
5106: OR
5107: IFFALSE 4902
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
5109: LD_EXP 27
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
5128: LD_EXP 27
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: LD_INT 0
5142: PPUSH
5143: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
5147: LD_EXP 3
5151: PPUSH
5152: CALL_OW 274
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 200
5162: PPUSH
5163: CALL_OW 276
// DialogueOn ;
5167: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5171: LD_INT 53
5173: PPUSH
5174: LD_INT 35
5176: PPUSH
5177: CALL_OW 86
// un := powell_trans [ 1 ] ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_EXP 27
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D4-Mech1-1
5202: PPUSH
5203: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5207: LD_EXP 21
5211: PPUSH
5212: LD_STRING D4-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5219: LD_VAR 0 5
5223: PPUSH
5224: LD_STRING D4-Mech1-2
5226: PPUSH
5227: CALL_OW 88
// powell_happy := false ;
5231: LD_ADDR_VAR 0 6
5235: PUSH
5236: LD_INT 0
5238: ST_TO_ADDR
// take_cargo := false ;
5239: LD_ADDR_VAR 0 7
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5247: CALL 943 0 0
5251: PUSH
5252: LD_INT 60
5254: GREATEREQUAL
5255: IFFALSE 5303
// begin Say ( JMM , D5-JMM-1 ) ;
5257: LD_EXP 21
5261: PPUSH
5262: LD_STRING D5-JMM-1
5264: PPUSH
5265: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5269: LD_VAR 0 5
5273: PPUSH
5274: LD_STRING D6-Mech1-1
5276: PPUSH
5277: CALL_OW 88
// powell_happy := true ;
5281: LD_ADDR_VAR 0 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// take_cargo := true ;
5289: LD_ADDR_VAR 0 7
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// DialogueOff ;
5297: CALL_OW 7
// end else
5301: GO 5537
// if GetTerminalCargo > 0 then
5303: CALL 943 0 0
5307: PUSH
5308: LD_INT 0
5310: GREATER
5311: IFFALSE 5509
// begin case Query ( QWait ) of 1 :
5313: LD_STRING QWait
5315: PPUSH
5316: CALL_OW 97
5320: PUSH
5321: LD_INT 1
5323: DOUBLE
5324: EQUAL
5325: IFTRUE 5329
5327: GO 5420
5329: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5330: LD_EXP 21
5334: PPUSH
5335: LD_STRING D5a-JMM-1
5337: PPUSH
5338: CALL_OW 88
// DialogueOff ;
5342: CALL_OW 7
// wait ( 5 5$00 ) ;
5346: LD_INT 10500
5348: PPUSH
5349: CALL_OW 67
// if GetTerminalCargo < 60 then
5353: CALL 943 0 0
5357: PUSH
5358: LD_INT 60
5360: LESS
5361: IFFALSE 5402
// begin DialogueOn ;
5363: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5367: LD_EXP 3
5371: PPUSH
5372: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_STRING D6-Mech1-1a
5383: PPUSH
5384: CALL_OW 88
// DialogueOff ;
5388: CALL_OW 7
// powell_happy := false ;
5392: LD_ADDR_VAR 0 6
5396: PUSH
5397: LD_INT 0
5399: ST_TO_ADDR
// end else
5400: GO 5418
// begin powell_happy := true ;
5402: LD_ADDR_VAR 0 6
5406: PUSH
5407: LD_INT 1
5409: ST_TO_ADDR
// take_cargo := true ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// end ; end ; 2 :
5418: GO 5507
5420: LD_INT 2
5422: DOUBLE
5423: EQUAL
5424: IFTRUE 5428
5426: GO 5467
5428: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5429: LD_EXP 21
5433: PPUSH
5434: LD_STRING D5b-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_STRING D6-Mech1-1a
5448: PPUSH
5449: CALL_OW 88
// DialogueOff ;
5453: CALL_OW 7
// take_cargo := true ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// end ; 3 :
5465: GO 5507
5467: LD_INT 3
5469: DOUBLE
5470: EQUAL
5471: IFTRUE 5475
5473: GO 5506
5475: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5476: LD_EXP 21
5480: PPUSH
5481: LD_STRING D5c-JMM-1
5483: PPUSH
5484: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5488: LD_VAR 0 5
5492: PPUSH
5493: LD_STRING D6-Mech1-1b
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ; end ;
5504: GO 5507
5506: POP
// end else
5507: GO 5537
// begin Say ( JMM , D5c-JMM-1 ) ;
5509: LD_EXP 21
5513: PPUSH
5514: LD_STRING D5c-JMM-1
5516: PPUSH
5517: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_STRING D6-Mech1-1b
5528: PPUSH
5529: CALL_OW 88
// DialogueOff ;
5533: CALL_OW 7
// end ; if take_cargo then
5537: LD_VAR 0 7
5541: IFFALSE 5620
// begin x := GetTerminalCargo ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL 943 0 0
5552: ST_TO_ADDR
// if x > 60 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 60
5560: GREATER
5561: IFFALSE 5571
// x := 60 ;
5563: LD_ADDR_VAR 0 2
5567: PUSH
5568: LD_INT 60
5570: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5571: LD_EXP 3
5575: PPUSH
5576: CALL_OW 274
5580: PPUSH
5581: LD_INT 3
5583: PPUSH
5584: CALL 943 0 0
5588: PUSH
5589: LD_VAR 0 2
5593: MINUS
5594: PPUSH
5595: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5599: LD_EXP 27
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PPUSH
5608: LD_INT 3
5610: PPUSH
5611: LD_VAR 0 2
5615: PPUSH
5616: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5620: LD_EXP 27
5624: PPUSH
5625: LD_INT 43
5627: PPUSH
5628: LD_INT 3
5630: PPUSH
5631: CALL_OW 171
// x := 0 0$20 ;
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_INT 700
5642: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5643: LD_INT 35
5645: PPUSH
5646: CALL_OW 67
// x := x - 0 0$01 ;
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 35
5662: MINUS
5663: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5664: LD_VAR 0 2
5668: PUSH
5669: LD_INT 0
5671: EQUAL
5672: PUSH
5673: LD_EXP 27
5677: PUSH
5678: LD_INT 3
5680: ARRAY
5681: PPUSH
5682: LD_INT 43
5684: PPUSH
5685: LD_INT 3
5687: PPUSH
5688: CALL_OW 297
5692: PUSH
5693: LD_INT 4
5695: LESS
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ARRAY
5705: PPUSH
5706: LD_INT 43
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: CALL_OW 297
5716: PUSH
5717: LD_INT 4
5719: LESS
5720: AND
5721: OR
5722: IFFALSE 5643
// for i in powell_trans do
5724: LD_ADDR_VAR 0 4
5728: PUSH
5729: LD_EXP 27
5733: PUSH
5734: FOR_IN
5735: IFFALSE 5748
// RemoveUnit ( i ) ;
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 64
5746: GO 5734
5748: POP
5749: POP
// if not powell_happy then
5750: LD_VAR 0 6
5754: NOT
5755: IFFALSE 5766
// powell_happy := - 1 ;
5757: LD_ADDR_VAR 0 6
5761: PUSH
5762: LD_INT 1
5764: NEG
5765: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5766: LD_STRING EarlySiberite
5768: PPUSH
5769: LD_VAR 0 6
5773: PPUSH
5774: CALL_OW 101
// if powell_happy then
5778: LD_VAR 0 6
5782: IFFALSE 5792
// earlySib := true ;
5784: LD_ADDR_EXP 19
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// if powell_happy then
5792: LD_VAR 0 6
5796: IFFALSE 5807
// ChangeMissionObjectives ( M3a ) else
5798: LD_STRING M3a
5800: PPUSH
5801: CALL_OW 337
5805: GO 5814
// ChangeMissionObjectives ( M3b ) ;
5807: LD_STRING M3b
5809: PPUSH
5810: CALL_OW 337
// ru_can_attack_terminal := true ;
5814: LD_ADDR_EXP 9
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5822: LD_INT 25200
5824: PPUSH
5825: CALL_OW 67
// time := 2 2$00 ;
5829: LD_ADDR_VAR 0 8
5833: PUSH
5834: LD_INT 4200
5836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5837: LD_INT 35
5839: PPUSH
5840: CALL_OW 67
// time := time - 0 0$1 ;
5844: LD_ADDR_VAR 0 8
5848: PUSH
5849: LD_VAR 0 8
5853: PUSH
5854: LD_INT 35
5856: MINUS
5857: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5858: LD_EXP 8
5862: NOT
5863: PUSH
5864: LD_EXP 38
5868: PUSH
5869: LD_INT 0
5871: EQUAL
5872: OR
5873: PUSH
5874: LD_VAR 0 8
5878: PUSH
5879: LD_INT 0
5881: EQUAL
5882: OR
5883: IFFALSE 5837
// if ru_force then
5885: LD_EXP 38
5889: IFFALSE 5988
// for i in ru_force do
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_EXP 38
5900: PUSH
5901: FOR_IN
5902: IFFALSE 5986
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 4
5911: PPUSH
5912: CALL_OW 292
5916: NOT
5917: PUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: LD_INT 81
5925: PUSH
5926: LD_INT 3
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PPUSH
5938: LD_VAR 0 4
5942: PPUSH
5943: CALL_OW 74
5947: PPUSH
5948: CALL_OW 296
5952: PUSH
5953: LD_INT 10
5955: GREATER
5956: AND
5957: IFFALSE 5984
// begin RemoveUnit ( i ) ;
5959: LD_VAR 0 4
5963: PPUSH
5964: CALL_OW 64
// ru_force := ru_force diff i ;
5968: LD_ADDR_EXP 38
5972: PUSH
5973: LD_EXP 38
5977: PUSH
5978: LD_VAR 0 4
5982: DIFF
5983: ST_TO_ADDR
// end ;
5984: GO 5901
5986: POP
5987: POP
// repeat wait ( 0 0$03 ) ;
5988: LD_INT 105
5990: PPUSH
5991: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5995: LD_EXP 8
5999: NOT
6000: PUSH
6001: LD_EXP 38
6005: PUSH
6006: LD_INT 3
6008: LESS
6009: OR
6010: IFFALSE 5988
// ar_can_arrive := true ;
6012: LD_ADDR_EXP 10
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// end ;
6020: PPOPN 8
6022: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 20
6028: PPUSH
6029: CALL_OW 325
6033: IFFALSE 6180
6035: GO 6037
6037: DISABLE
6038: LD_INT 0
6040: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Gary , Cyrus , Bobby , Houten ] ;
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_INT 22
6048: PUSH
6049: LD_INT 1
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PUSH
6056: LD_INT 26
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 25
6068: PUSH
6069: LD_INT 4
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: LD_EXP 22
6095: PUSH
6096: LD_EXP 24
6100: PUSH
6101: LD_EXP 23
6105: PUSH
6106: LD_EXP 25
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: DIFF
6118: ST_TO_ADDR
// if not un then
6119: LD_VAR 0 1
6123: NOT
6124: IFFALSE 6128
// exit ;
6126: GO 6180
// DialogueOn ;
6128: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
6132: LD_VAR 0 1
6136: PUSH
6137: LD_INT 1
6139: ARRAY
6140: PPUSH
6141: LD_STRING D13-Sci1-1
6143: PPUSH
6144: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
6148: LD_EXP 21
6152: PPUSH
6153: LD_STRING D13-JMM-1
6155: PPUSH
6156: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
6160: LD_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: ARRAY
6168: PPUSH
6169: LD_STRING D13-Sci1-2
6171: PPUSH
6172: CALL_OW 88
// DialogueOff ;
6176: CALL_OW 7
// end ;
6180: PPOPN 1
6182: END
// every 0 0$1 trigger GetTerminalCargo > 77 and not InBattle ( 1 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6183: CALL 943 0 0
6187: PUSH
6188: LD_INT 77
6190: GREATER
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 463
6199: NOT
6200: AND
6201: PUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 25
6214: PUSH
6215: LD_INT 4
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 26
6224: PUSH
6225: LD_INT 1
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: PUSH
6242: LD_EXP 21
6246: PUSH
6247: LD_EXP 23
6251: PUSH
6252: LD_EXP 24
6256: PUSH
6257: LD_EXP 22
6261: PUSH
6262: LD_EXP 25
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: AND
6275: IFFALSE 6453
6277: GO 6279
6279: DISABLE
6280: LD_INT 0
6282: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: LD_INT 22
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 25
6300: PUSH
6301: LD_INT 4
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: PUSH
6308: LD_INT 26
6310: PUSH
6311: LD_INT 1
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: PUSH
6328: LD_EXP 21
6332: PUSH
6333: LD_EXP 23
6337: PUSH
6338: LD_EXP 24
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: LD_EXP 25
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: DIFF
6360: ST_TO_ADDR
// DialogueOn ;
6361: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: ARRAY
6373: PPUSH
6374: LD_STRING D7-Sci1-1
6376: PPUSH
6377: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6381: LD_EXP 21
6385: PPUSH
6386: LD_STRING D7-JMM-1
6388: PPUSH
6389: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6393: LD_VAR 0 1
6397: PUSH
6398: LD_INT 1
6400: ARRAY
6401: PPUSH
6402: LD_STRING D7-Sci1-2
6404: PPUSH
6405: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6409: LD_EXP 21
6413: PPUSH
6414: LD_STRING D7-JMM-2
6416: PPUSH
6417: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 1
6428: ARRAY
6429: PPUSH
6430: LD_STRING D7-Sci1-3
6432: PPUSH
6433: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6437: LD_EXP 21
6441: PPUSH
6442: LD_STRING D7-JMM-3
6444: PPUSH
6445: CALL_OW 88
// DialogueOff ;
6449: CALL_OW 7
// end ;
6453: PPOPN 1
6455: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6456: LD_EXP 10
6460: IFFALSE 10083
6462: GO 6464
6464: DISABLE
6465: LD_INT 0
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
// begin PrepareArabian ;
6477: CALL 12827 0 0
// blocked := false ;
6481: LD_ADDR_EXP 18
6485: PUSH
6486: LD_INT 0
6488: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6489: LD_INT 35
6491: PPUSH
6492: CALL_OW 67
// until ar_spawned ;
6496: LD_EXP 11
6500: IFFALSE 6489
// have_crates := true ;
6502: LD_ADDR_VAR 0 9
6506: PUSH
6507: LD_INT 1
6509: ST_TO_ADDR
// player_want_info := 2 ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 2
6517: ST_TO_ADDR
// DialogueOn ;
6518: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6522: LD_EXP 29
6526: PPUSH
6527: LD_STRING D8-Ar1-1
6529: PPUSH
6530: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6534: LD_EXP 21
6538: PPUSH
6539: LD_STRING D8-JMM-1
6541: PPUSH
6542: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6546: LD_EXP 29
6550: PPUSH
6551: LD_STRING D8-Ar1-2
6553: PPUSH
6554: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6558: LD_EXP 21
6562: PPUSH
6563: LD_STRING D8-JMM-2
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6570: LD_EXP 29
6574: PPUSH
6575: LD_STRING D8-Ar1-3
6577: PPUSH
6578: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6582: LD_EXP 21
6586: PPUSH
6587: LD_STRING D8-JMM-3
6589: PPUSH
6590: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6594: LD_EXP 29
6598: PPUSH
6599: LD_STRING D8-Ar1-4
6601: PPUSH
6602: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6606: LD_EXP 21
6610: PPUSH
6611: LD_STRING D8-JMM-4
6613: PPUSH
6614: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6618: LD_EXP 29
6622: PPUSH
6623: LD_STRING D8-Ar1-5
6625: PPUSH
6626: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6630: LD_EXP 21
6634: PPUSH
6635: LD_STRING D8-JMM-5
6637: PPUSH
6638: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6642: LD_EXP 29
6646: PPUSH
6647: LD_STRING D8-Ar1-6
6649: PPUSH
6650: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6654: LD_EXP 30
6658: PPUSH
6659: LD_STRING D8-Ar2-6
6661: PPUSH
6662: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6666: LD_EXP 21
6670: PPUSH
6671: LD_STRING D8-JMM-6
6673: PPUSH
6674: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6678: LD_EXP 30
6682: PPUSH
6683: LD_STRING D8-Ar2-7
6685: PPUSH
6686: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6690: LD_STRING QBarracks
6692: PPUSH
6693: CALL_OW 97
6697: PUSH
6698: LD_INT 1
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6741
6706: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6707: LD_EXP 21
6711: PPUSH
6712: LD_STRING D8a-JMM-1
6714: PPUSH
6715: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6719: LD_EXP 29
6723: PPUSH
6724: LD_STRING D8a-Ar1-1
6726: PPUSH
6727: CALL_OW 94
// player_want_mortar := true ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 1
6738: ST_TO_ADDR
// end ; 2 :
6739: GO 6915
6741: LD_INT 2
6743: DOUBLE
6744: EQUAL
6745: IFTRUE 6749
6747: GO 6871
6749: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6750: LD_EXP 21
6754: PPUSH
6755: LD_STRING D8b-JMM-1
6757: PPUSH
6758: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6762: LD_EXP 29
6766: PPUSH
6767: LD_STRING D8b-Ar1-1
6769: PPUSH
6770: CALL_OW 94
// case Query ( QInfo ) of 1 :
6774: LD_STRING QInfo
6776: PPUSH
6777: CALL_OW 97
6781: PUSH
6782: LD_INT 1
6784: DOUBLE
6785: EQUAL
6786: IFTRUE 6790
6788: GO 6825
6790: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6791: LD_EXP 21
6795: PPUSH
6796: LD_STRING D8b1-JMM-1
6798: PPUSH
6799: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6803: LD_EXP 29
6807: PPUSH
6808: LD_STRING D8b1-Ar1-1
6810: PPUSH
6811: CALL_OW 94
// player_want_info := 2 ;
6815: LD_ADDR_EXP 13
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
// end ; 2 :
6823: GO 6869
6825: LD_INT 2
6827: DOUBLE
6828: EQUAL
6829: IFTRUE 6833
6831: GO 6868
6833: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6834: LD_EXP 21
6838: PPUSH
6839: LD_STRING D8b2-JMM-1
6841: PPUSH
6842: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6846: LD_EXP 29
6850: PPUSH
6851: LD_STRING D8b2-Ar1-1
6853: PPUSH
6854: CALL_OW 94
// player_want_info := 0 ;
6858: LD_ADDR_EXP 13
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ; end ;
6866: GO 6869
6868: POP
// end ; 3 :
6869: GO 6915
6871: LD_INT 3
6873: DOUBLE
6874: EQUAL
6875: IFTRUE 6879
6877: GO 6914
6879: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6880: LD_EXP 21
6884: PPUSH
6885: LD_STRING D8c-JMM-1
6887: PPUSH
6888: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6892: LD_EXP 29
6896: PPUSH
6897: LD_STRING D8c-Ar1-1
6899: PPUSH
6900: CALL_OW 94
// player_want_info := 0 ;
6904: LD_ADDR_EXP 13
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// end ; end ;
6912: GO 6915
6914: POP
// DialogueOff ;
6915: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: LD_INT 9
6926: PPUSH
6927: LD_INT 2
6929: PUSH
6930: LD_INT 30
6932: PUSH
6933: LD_INT 0
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 30
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 70
6959: ST_TO_ADDR
// if dep then
6960: LD_VAR 0 4
6964: IFFALSE 6980
// dep := dep [ 1 ] ;
6966: LD_ADDR_VAR 0 4
6970: PUSH
6971: LD_VAR 0 4
6975: PUSH
6976: LD_INT 1
6978: ARRAY
6979: ST_TO_ADDR
// if not dep then
6980: LD_VAR 0 4
6984: NOT
6985: IFFALSE 7023
// begin case Query ( QInfoNothing ) of 1 :
6987: LD_STRING QInfoNothing
6989: PPUSH
6990: CALL_OW 97
6994: PUSH
6995: LD_INT 1
6997: DOUBLE
6998: EQUAL
6999: IFTRUE 7003
7001: GO 7006
7003: POP
// ; end ;
7004: GO 7007
7006: POP
// player_want_info := false ;
7007: LD_ADDR_EXP 13
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
// player_want_mortar := false ;
7015: LD_ADDR_EXP 12
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
7023: LD_ADDR_VAR 0 3
7027: PUSH
7028: LD_INT 22
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 21
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PPUSH
7052: CALL_OW 69
7056: ST_TO_ADDR
// time := 1 1$55 ;
7057: LD_ADDR_VAR 0 5
7061: PUSH
7062: LD_INT 4025
7064: ST_TO_ADDR
// no_oil_gain := false ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// first_warn := false ;
7073: LD_ADDR_VAR 0 7
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// if player_want_mortar or player_want_info then
7081: LD_EXP 12
7085: PUSH
7086: LD_EXP 13
7090: OR
7091: IFFALSE 7196
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
7093: LD_EXP 36
7097: PPUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: CALL_OW 250
7122: PPUSH
7123: LD_VAR 0 4
7127: PPUSH
7128: CALL_OW 251
7132: PPUSH
7133: LD_VAR 0 4
7137: PPUSH
7138: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
7142: LD_EXP 36
7146: PPUSH
7147: LD_INT 25
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PPUSH
7162: LD_INT 86
7164: PPUSH
7165: LD_INT 121
7167: PPUSH
7168: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7172: LD_EXP 36
7176: PPUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 72
7191: PPUSH
7192: CALL_OW 200
// end ; if player_attacked_ar then
7196: LD_EXP 16
7200: IFFALSE 7204
// exit ;
7202: GO 10083
// if player_want_mortar then
7204: LD_EXP 12
7208: IFFALSE 8745
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7210: LD_EXP 30
7214: PPUSH
7215: LD_VAR 0 4
7219: PPUSH
7220: CALL_OW 250
7224: PUSH
7225: LD_INT 1
7227: PLUS
7228: PPUSH
7229: LD_VAR 0 4
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 1
7241: PLUS
7242: PPUSH
7243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7247: LD_INT 35
7249: PPUSH
7250: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7254: LD_EXP 30
7258: PPUSH
7259: LD_VAR 0 4
7263: PPUSH
7264: CALL_OW 296
7268: PUSH
7269: LD_INT 4
7271: LESS
7272: IFFALSE 7247
// for i = 1 to 6 do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: DOUBLE
7280: LD_INT 1
7282: DEC
7283: ST_TO_ADDR
7284: LD_INT 6
7286: PUSH
7287: FOR_TO
7288: IFFALSE 7492
// begin if player_attacked_ar then
7290: LD_EXP 16
7294: IFFALSE 7300
// exit ;
7296: POP
7297: POP
7298: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7300: LD_VAR 0 4
7304: PPUSH
7305: CALL_OW 274
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 275
7317: PUSH
7318: LD_INT 10
7320: LESS
7321: PUSH
7322: LD_VAR 0 7
7326: NOT
7327: AND
7328: IFFALSE 7391
// begin first_warn := true ;
7330: LD_ADDR_VAR 0 7
7334: PUSH
7335: LD_INT 1
7337: ST_TO_ADDR
// DialogueOn ;
7338: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7342: LD_EXP 31
7346: PPUSH
7347: LD_STRING D9a-FAr1-1
7349: PPUSH
7350: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7354: LD_EXP 21
7358: PPUSH
7359: LD_STRING D9a-JMM-1
7361: PPUSH
7362: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7366: LD_EXP 29
7370: PPUSH
7371: LD_STRING D9a2-Ar1-1
7373: PPUSH
7374: CALL_OW 88
// DialogueOff ;
7378: CALL_OW 7
// wait ( time ) ;
7382: LD_VAR 0 5
7386: PPUSH
7387: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7391: LD_VAR 0 4
7395: PPUSH
7396: CALL_OW 274
7400: PPUSH
7401: LD_INT 2
7403: PPUSH
7404: CALL_OW 275
7408: PUSH
7409: LD_INT 10
7411: LESS
7412: IFFALSE 7438
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7414: LD_EXP 29
7418: PPUSH
7419: LD_STRING D9a3-Ar1-1
7421: PPUSH
7422: CALL_OW 88
// no_oil_gain := true ;
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// break ;
7434: GO 7492
// end else
7436: GO 7490
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7438: LD_EXP 30
7442: PPUSH
7443: LD_VAR 0 4
7447: PPUSH
7448: LD_INT 2
7450: PPUSH
7451: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7455: LD_EXP 30
7459: PPUSH
7460: LD_VAR 0 3
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: MOD
7473: PUSH
7474: LD_INT 1
7476: PLUS
7477: ARRAY
7478: PPUSH
7479: CALL_OW 210
// wait ( 0 0$10 ) ;
7483: LD_INT 350
7485: PPUSH
7486: CALL_OW 67
// end ; end ;
7490: GO 7287
7492: POP
7493: POP
// if not no_oil_gain then
7494: LD_VAR 0 6
7498: NOT
7499: IFFALSE 8745
// begin repeat wait ( 0 0$01 ) ;
7501: LD_INT 35
7503: PPUSH
7504: CALL_OW 67
// if player_attacked_ar then
7508: LD_EXP 16
7512: IFFALSE 7516
// exit ;
7514: GO 10083
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7516: LD_VAR 0 3
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: CALL_OW 261
7529: PUSH
7530: LD_INT 80
7532: GREATER
7533: PUSH
7534: LD_VAR 0 3
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: PPUSH
7543: CALL_OW 261
7547: PUSH
7548: LD_INT 80
7550: GREATER
7551: AND
7552: PUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 3
7560: ARRAY
7561: PPUSH
7562: CALL_OW 261
7566: PUSH
7567: LD_INT 80
7569: GREATER
7570: AND
7571: IFFALSE 7501
// ComMoveXY ( Gali , 105 , 127 ) ;
7573: LD_EXP 30
7577: PPUSH
7578: LD_INT 105
7580: PPUSH
7581: LD_INT 127
7583: PPUSH
7584: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7588: LD_EXP 30
7592: PPUSH
7593: LD_INT 2
7595: PPUSH
7596: CALL_OW 173
// AddComHold ( Gali ) ;
7600: LD_EXP 30
7604: PPUSH
7605: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 10083
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7624: LD_EXP 30
7628: PPUSH
7629: LD_INT 105
7631: PPUSH
7632: LD_INT 127
7634: PPUSH
7635: CALL_OW 297
7639: PUSH
7640: LD_INT 4
7642: LESS
7643: IFFALSE 7609
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7645: LD_VAR 0 4
7649: PPUSH
7650: CALL_OW 274
7654: PPUSH
7655: LD_INT 1
7657: PPUSH
7658: CALL_OW 275
7662: PUSH
7663: LD_INT 50
7665: LESS
7666: IFFALSE 7968
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7668: LD_VAR 0 4
7672: PPUSH
7673: CALL_OW 274
7677: PPUSH
7678: LD_INT 1
7680: PPUSH
7681: CALL_OW 275
7685: PUSH
7686: LD_INT 0
7688: DOUBLE
7689: GREATEREQUAL
7690: IFFALSE 7698
7692: LD_INT 24
7694: DOUBLE
7695: LESSEQUAL
7696: IFTRUE 7700
7698: GO 7715
7700: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7701: LD_EXP 30
7705: PPUSH
7706: LD_STRING D9b-Ar2-1
7708: PPUSH
7709: CALL_OW 88
7713: GO 7745
7715: LD_INT 25
7717: DOUBLE
7718: GREATEREQUAL
7719: IFFALSE 7727
7721: LD_INT 49
7723: DOUBLE
7724: LESSEQUAL
7725: IFTRUE 7729
7727: GO 7744
7729: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7730: LD_EXP 30
7734: PPUSH
7735: LD_STRING D9b-Ar2-1a
7737: PPUSH
7738: CALL_OW 88
7742: GO 7745
7744: POP
// Say ( JMM , D9b-JMM-1 ) ;
7745: LD_EXP 21
7749: PPUSH
7750: LD_STRING D9b-JMM-1
7752: PPUSH
7753: CALL_OW 88
// x := 0 0$0 ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: LD_INT 0
7764: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7765: LD_INT 35
7767: PPUSH
7768: CALL_OW 67
// x := x + 0 0$1 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 35
7784: PLUS
7785: ST_TO_ADDR
// if player_attacked_ar then
7786: LD_EXP 16
7790: IFFALSE 7794
// exit ;
7792: GO 10083
// until x >= time ;
7794: LD_VAR 0 2
7798: PUSH
7799: LD_VAR 0 5
7803: GREATEREQUAL
7804: IFFALSE 7765
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7806: LD_VAR 0 4
7810: PPUSH
7811: CALL_OW 274
7815: PPUSH
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 275
7823: PUSH
7824: LD_INT 50
7826: LESS
7827: IFFALSE 7968
// begin have_crates := false ;
7829: LD_ADDR_VAR 0 9
7833: PUSH
7834: LD_INT 0
7836: ST_TO_ADDR
// DialogueOn ;
7837: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7841: LD_EXP 29
7845: PPUSH
7846: LD_STRING D9c-Ar1-1
7848: PPUSH
7849: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7853: LD_EXP 21
7857: PPUSH
7858: LD_STRING D9c-JMM-1
7860: PPUSH
7861: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7865: LD_EXP 29
7869: PPUSH
7870: LD_STRING D9c-Ar1-2
7872: PPUSH
7873: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7877: LD_EXP 31
7881: PPUSH
7882: LD_STRING D9c-FAr1-2
7884: PPUSH
7885: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7889: LD_EXP 29
7893: PPUSH
7894: LD_STRING D9c-Ar1-3
7896: PPUSH
7897: CALL_OW 88
// case Query ( QInfo ) of 1 :
7901: LD_STRING QInfo
7903: PPUSH
7904: CALL_OW 97
7908: PUSH
7909: LD_INT 1
7911: DOUBLE
7912: EQUAL
7913: IFTRUE 7917
7915: GO 7940
7917: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7918: LD_EXP 21
7922: PPUSH
7923: LD_STRING D8b1-JMM-1
7925: PPUSH
7926: CALL_OW 88
// player_want_info := 2 ;
7930: LD_ADDR_EXP 13
7934: PUSH
7935: LD_INT 2
7937: ST_TO_ADDR
// end ; 2 :
7938: GO 7964
7940: LD_INT 2
7942: DOUBLE
7943: EQUAL
7944: IFTRUE 7948
7946: GO 7963
7948: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7949: LD_EXP 29
7953: PPUSH
7954: LD_STRING D8b2-Ar1-1
7956: PPUSH
7957: CALL_OW 88
// end ; end ;
7961: GO 7964
7963: POP
// DialogueOff ;
7964: CALL_OW 7
// end ; end ; if have_crates then
7968: LD_VAR 0 9
7972: IFFALSE 8745
// begin RemoveEnvironmentArea ( mortarArea ) ;
7974: LD_INT 2
7976: PPUSH
7977: CALL_OW 355
// wait ( 1 ) ;
7981: LD_INT 1
7983: PPUSH
7984: CALL_OW 67
// InGameOn ;
7988: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7992: LD_EXP 30
7996: PPUSH
7997: CALL_OW 87
// SetSide ( Gali , 1 ) ;
8001: LD_EXP 30
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
8013: LD_ADDR_VAR 0 10
8017: PUSH
8018: LD_INT 22
8020: PUSH
8021: LD_INT 1
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 23
8033: PUSH
8034: LD_INT 2
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 21
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 92
8057: PUSH
8058: LD_INT 107
8060: PUSH
8061: LD_INT 131
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: ST_TO_ADDR
// if filter then
8084: LD_VAR 0 10
8088: IFFALSE 8122
// for i in filter do
8090: LD_ADDR_VAR 0 1
8094: PUSH
8095: LD_VAR 0 10
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8120
// ComMoveXY ( i , 107 , 121 ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_INT 107
8110: PPUSH
8111: LD_INT 121
8113: PPUSH
8114: CALL_OW 111
8118: GO 8100
8120: POP
8121: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
8122: LD_EXP 30
8126: PPUSH
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 131
8135: PPUSH
8136: LD_INT 0
8138: PPUSH
8139: CALL_OW 145
// wait ( 0 0$1 ) ;
8143: LD_INT 35
8145: PPUSH
8146: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
8150: LD_INT 30
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 23
8162: PUSH
8163: LD_INT 2
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: IFFALSE 8013
// SetSide ( Gali , 2 ) ;
8180: LD_EXP 30
8184: PPUSH
8185: LD_INT 2
8187: PPUSH
8188: CALL_OW 235
// InGameOff ;
8192: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8196: LD_ADDR_VAR 0 8
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 4
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 23
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8234: LD_INT 35
8236: PPUSH
8237: CALL_OW 67
// if player_attacked_ar then
8241: LD_EXP 16
8245: IFFALSE 8249
// exit ;
8247: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8249: LD_VAR 0 8
8253: PPUSH
8254: CALL_OW 461
8258: PUSH
8259: LD_INT 1
8261: NONEQUAL
8262: IFFALSE 8234
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8264: LD_VAR 0 8
8268: PPUSH
8269: CALL_OW 302
8273: PUSH
8274: LD_VAR 0 4
8278: PPUSH
8279: CALL_OW 274
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 275
8291: PUSH
8292: LD_INT 25
8294: GREATEREQUAL
8295: AND
8296: IFFALSE 8395
// begin ComUpgrade ( b ) ;
8298: LD_VAR 0 8
8302: PPUSH
8303: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8307: LD_EXP 30
8311: PPUSH
8312: LD_STRING h
8314: PUSH
8315: LD_VAR 0 8
8319: PPUSH
8320: CALL_OW 250
8324: PUSH
8325: LD_VAR 0 8
8329: PPUSH
8330: CALL_OW 251
8334: PUSH
8335: LD_VAR 0 8
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: PPUSH
8361: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// if player_attacked_ar then
8372: LD_EXP 16
8376: IFFALSE 8380
// exit ;
8378: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8380: LD_VAR 0 8
8384: PPUSH
8385: CALL_OW 461
8389: PUSH
8390: LD_INT 1
8392: NONEQUAL
8393: IFFALSE 8365
// end ; if b then
8395: LD_VAR 0 8
8399: IFFALSE 8410
// CenterNowOnUnits ( b ) ;
8401: LD_VAR 0 8
8405: PPUSH
8406: CALL_OW 87
// DialogueOn ;
8410: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8414: LD_EXP 30
8418: PPUSH
8419: LD_STRING D9d-Ar2-1
8421: PPUSH
8422: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8426: LD_EXP 29
8430: PPUSH
8431: LD_STRING D9d-Ar1-1
8433: PPUSH
8434: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8438: LD_EXP 21
8442: PPUSH
8443: LD_STRING D9d-JMM-1
8445: PPUSH
8446: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8450: LD_EXP 29
8454: PPUSH
8455: LD_STRING D9d-Ar1-2
8457: PPUSH
8458: CALL_OW 88
// DialogueOff ;
8462: CALL_OW 7
// i := [ ] ;
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: EMPTY
8472: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8473: LD_VAR 0 4
8477: PPUSH
8478: CALL_OW 274
8482: PPUSH
8483: LD_INT 3
8485: PPUSH
8486: CALL_OW 275
8490: PUSH
8491: LD_INT 20
8493: GREATEREQUAL
8494: IFFALSE 8513
// i := i ^ [ 1 ] ;
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_VAR 0 1
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: EMPTY
8510: LIST
8511: ADD
8512: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8513: LD_VAR 0 4
8517: PPUSH
8518: CALL_OW 274
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_INT 50
8533: GREATEREQUAL
8534: IFFALSE 8553
// i := i ^ [ 2 ] ;
8536: LD_ADDR_VAR 0 1
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: EMPTY
8550: LIST
8551: ADD
8552: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL_OW 274
8562: PPUSH
8563: LD_INT 2
8565: PPUSH
8566: CALL_OW 275
8570: PUSH
8571: LD_INT 80
8573: GREATEREQUAL
8574: IFFALSE 8593
// i := i ^ [ 3 ] ;
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: LD_VAR 0 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: ADD
8592: ST_TO_ADDR
// i := i diff 0 ;
8593: LD_ADDR_VAR 0 1
8597: PUSH
8598: LD_VAR 0 1
8602: PUSH
8603: LD_INT 0
8605: DIFF
8606: ST_TO_ADDR
// if i then
8607: LD_VAR 0 1
8611: IFFALSE 8717
// begin i := i ^ [ 4 ] ;
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 4
8625: PUSH
8626: EMPTY
8627: LIST
8628: ADD
8629: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8630: LD_STRING QInfo2
8632: PPUSH
8633: CALL_OW 97
8637: PUSH
8638: LD_INT 1
8640: DOUBLE
8641: EQUAL
8642: IFTRUE 8646
8644: GO 8657
8646: POP
// player_want_info := 3 ; 2 :
8647: LD_ADDR_EXP 13
8651: PUSH
8652: LD_INT 3
8654: ST_TO_ADDR
8655: GO 8715
8657: LD_INT 2
8659: DOUBLE
8660: EQUAL
8661: IFTRUE 8665
8663: GO 8676
8665: POP
// player_want_info := 1 ; 3 :
8666: LD_ADDR_EXP 13
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
8674: GO 8715
8676: LD_INT 3
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8695
8684: POP
// player_want_info := 2 ; 4 :
8685: LD_ADDR_EXP 13
8689: PUSH
8690: LD_INT 2
8692: ST_TO_ADDR
8693: GO 8715
8695: LD_INT 4
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8714
8703: POP
// player_want_info := 0 ; end ;
8704: LD_ADDR_EXP 13
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
8712: GO 8715
8714: POP
// end else
8715: GO 8745
// case Query ( QInfoNothing ) of 1 :
8717: LD_STRING QInfoNothing
8719: PPUSH
8720: CALL_OW 97
8724: PUSH
8725: LD_INT 1
8727: DOUBLE
8728: EQUAL
8729: IFTRUE 8733
8731: GO 8744
8733: POP
// player_want_info := 0 ; end ;
8734: LD_ADDR_EXP 13
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
8742: GO 8745
8744: POP
// end ; end ; end ; if player_want_info then
8745: LD_EXP 13
8749: IFFALSE 9903
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8751: LD_ADDR_VAR 0 3
8755: PUSH
8756: LD_VAR 0 3
8760: PPUSH
8761: LD_INT 34
8763: PUSH
8764: LD_INT 32
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 72
8775: ST_TO_ADDR
// if player_want_mortar then
8776: LD_EXP 12
8780: IFFALSE 9135
// begin case player_want_info of 1 :
8782: LD_EXP 13
8786: PUSH
8787: LD_INT 1
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8806
8795: POP
// x := 5 ; 2 :
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: LD_INT 5
8803: ST_TO_ADDR
8804: GO 8845
8806: LD_INT 2
8808: DOUBLE
8809: EQUAL
8810: IFTRUE 8814
8812: GO 8825
8814: POP
// x := 8 ; 3 :
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 8
8822: ST_TO_ADDR
8823: GO 8845
8825: LD_INT 3
8827: DOUBLE
8828: EQUAL
8829: IFTRUE 8833
8831: GO 8844
8833: POP
// x := 2 ; end ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_INT 2
8841: ST_TO_ADDR
8842: GO 8845
8844: POP
// repeat wait ( 0 0$1 ) ;
8845: LD_INT 35
8847: PPUSH
8848: CALL_OW 67
// until not HasTask ( Gali ) ;
8852: LD_EXP 30
8856: PPUSH
8857: CALL_OW 314
8861: NOT
8862: IFFALSE 8845
// time := 0 0$00 ;
8864: LD_ADDR_VAR 0 5
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// time := time + 0 0$1 ;
8879: LD_ADDR_VAR 0 5
8883: PUSH
8884: LD_VAR 0 5
8888: PUSH
8889: LD_INT 35
8891: PLUS
8892: ST_TO_ADDR
// if debug then
8893: LD_EXP 2
8897: IFFALSE 8916
// debug_strings := [ time: & time ] ;
8899: LD_ADDR_OWVAR 48
8903: PUSH
8904: LD_STRING time:
8906: PUSH
8907: LD_VAR 0 5
8911: STR
8912: PUSH
8913: EMPTY
8914: LIST
8915: ST_TO_ADDR
// if time > 8 8$00 then
8916: LD_VAR 0 5
8920: PUSH
8921: LD_INT 16800
8923: GREATER
8924: IFFALSE 8936
// begin blocked := true ;
8926: LD_ADDR_EXP 18
8930: PUSH
8931: LD_INT 1
8933: ST_TO_ADDR
// exit ;
8934: GO 10083
// end ; if not Carry ( Gali ) then
8936: LD_EXP 30
8940: PPUSH
8941: CALL_OW 281
8945: NOT
8946: IFFALSE 8969
// ComTransport ( Gali , dep , player_want_info ) else
8948: LD_EXP 30
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: LD_EXP 13
8962: PPUSH
8963: CALL_OW 151
8967: GO 9087
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8969: LD_EXP 30
8973: PPUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: CALL_OW 296
8987: PUSH
8988: LD_INT 4
8990: LESS
8991: PUSH
8992: LD_EXP 30
8996: PPUSH
8997: LD_EXP 13
9001: PPUSH
9002: CALL_OW 289
9006: AND
9007: IFFALSE 9069
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_EXP 13
9022: PPUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ARRAY
9031: PPUSH
9032: LD_EXP 13
9036: PPUSH
9037: CALL_OW 289
9041: PUSH
9042: LD_INT 10
9044: PLUS
9045: PPUSH
9046: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
9050: LD_EXP 30
9054: PPUSH
9055: LD_EXP 13
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 290
// end else
9067: GO 9087
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
9069: LD_EXP 30
9073: PPUSH
9074: LD_VAR 0 3
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: CALL_OW 112
// end ; if player_attacked_ar then
9087: LD_EXP 16
9091: IFFALSE 9095
// exit ;
9093: GO 10083
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: PPUSH
9104: LD_EXP 13
9108: PPUSH
9109: CALL_OW 289
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 10
9121: MUL
9122: GREATEREQUAL
9123: IFFALSE 8872
// no_oil_gain := false ;
9125: LD_ADDR_VAR 0 6
9129: PUSH
9130: LD_INT 0
9132: ST_TO_ADDR
// end else
9133: GO 9724
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
9135: LD_ADDR_VAR 0 3
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 21
9152: PUSH
9153: LD_INT 2
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9169: LD_EXP 30
9173: PPUSH
9174: LD_VAR 0 4
9178: PPUSH
9179: CALL_OW 250
9183: PUSH
9184: LD_INT 1
9186: PLUS
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: CALL_OW 251
9197: PUSH
9198: LD_INT 1
9200: PLUS
9201: PPUSH
9202: CALL_OW 111
// time := 0 0$00 ;
9206: LD_ADDR_VAR 0 5
9210: PUSH
9211: LD_INT 0
9213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// time := time + 0 0$1 ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: LD_VAR 0 5
9230: PUSH
9231: LD_INT 35
9233: PLUS
9234: ST_TO_ADDR
// if time > 1 1$45 then
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 3675
9242: GREATER
9243: IFFALSE 9247
// break ;
9245: GO 9267
// until GetDistUnits ( Gali , dep ) < 4 ;
9247: LD_EXP 30
9251: PPUSH
9252: LD_VAR 0 4
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 4
9264: LESS
9265: IFFALSE 9214
// for i = 1 to 6 do
9267: LD_ADDR_VAR 0 1
9271: PUSH
9272: DOUBLE
9273: LD_INT 1
9275: DEC
9276: ST_TO_ADDR
9277: LD_INT 6
9279: PUSH
9280: FOR_TO
9281: IFFALSE 9485
// begin if player_attacked_ar then
9283: LD_EXP 16
9287: IFFALSE 9293
// exit ;
9289: POP
9290: POP
9291: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9293: LD_VAR 0 4
9297: PPUSH
9298: CALL_OW 274
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 275
9310: PUSH
9311: LD_INT 10
9313: LESS
9314: PUSH
9315: LD_VAR 0 7
9319: NOT
9320: AND
9321: IFFALSE 9384
// begin first_warn := true ;
9323: LD_ADDR_VAR 0 7
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// DialogueOn ;
9331: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9335: LD_EXP 31
9339: PPUSH
9340: LD_STRING D9a-FAr1-1
9342: PPUSH
9343: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9347: LD_EXP 21
9351: PPUSH
9352: LD_STRING D9a-JMM-1
9354: PPUSH
9355: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9359: LD_EXP 29
9363: PPUSH
9364: LD_STRING D9a2-Ar1-1
9366: PPUSH
9367: CALL_OW 88
// DialogueOff ;
9371: CALL_OW 7
// wait ( time ) ;
9375: LD_VAR 0 5
9379: PPUSH
9380: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9384: LD_VAR 0 4
9388: PPUSH
9389: CALL_OW 274
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 275
9401: PUSH
9402: LD_INT 10
9404: LESS
9405: IFFALSE 9431
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9407: LD_EXP 29
9411: PPUSH
9412: LD_STRING D9a3-Ar1-1
9414: PPUSH
9415: CALL_OW 88
// no_oil_gain := true ;
9419: LD_ADDR_VAR 0 6
9423: PUSH
9424: LD_INT 1
9426: ST_TO_ADDR
// break ;
9427: GO 9485
// end else
9429: GO 9483
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9431: LD_EXP 30
9435: PPUSH
9436: LD_VAR 0 4
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9448: LD_EXP 30
9452: PPUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 3
9465: MOD
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: ARRAY
9471: PPUSH
9472: CALL_OW 210
// wait ( 0 0$10 ) ;
9476: LD_INT 350
9478: PPUSH
9479: CALL_OW 67
// end ; end ;
9483: GO 9280
9485: POP
9486: POP
// time := 0 0$00 ;
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 0
9494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9495: LD_INT 35
9497: PPUSH
9498: CALL_OW 67
// if not HasTask ( Gali ) then
9502: LD_EXP 30
9506: PPUSH
9507: CALL_OW 314
9511: NOT
9512: IFFALSE 9528
// time := time + 0 0$1 ;
9514: LD_ADDR_VAR 0 5
9518: PUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_INT 35
9526: PLUS
9527: ST_TO_ADDR
// if time > 1 1$25 then
9528: LD_VAR 0 5
9532: PUSH
9533: LD_INT 2975
9535: GREATER
9536: IFFALSE 9560
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING D9a3-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// no_oil_gain := true ;
9550: LD_ADDR_VAR 0 6
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// break ;
9558: GO 9724
// end ; if player_attacked_ar then
9560: LD_EXP 16
9564: IFFALSE 9568
// exit ;
9566: GO 10083
// for i in tmp do
9568: LD_ADDR_VAR 0 1
9572: PUSH
9573: LD_VAR 0 3
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9610
// if GetFuel ( i ) < 100 then
9581: LD_VAR 0 1
9585: PPUSH
9586: CALL_OW 261
9590: PUSH
9591: LD_INT 100
9593: LESS
9594: IFFALSE 9608
// begin x := i ;
9596: LD_ADDR_VAR 0 2
9600: PUSH
9601: LD_VAR 0 1
9605: ST_TO_ADDR
// break ;
9606: GO 9610
// end ;
9608: GO 9578
9610: POP
9611: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9612: LD_EXP 30
9616: PPUSH
9617: CALL_OW 314
9621: NOT
9622: PUSH
9623: LD_EXP 30
9627: PPUSH
9628: CALL_OW 281
9632: NOT
9633: AND
9634: IFFALSE 9667
// begin ComTransport ( Gali , dep , mat_oil ) ;
9636: LD_EXP 30
9640: PPUSH
9641: LD_VAR 0 4
9645: PPUSH
9646: LD_INT 2
9648: PPUSH
9649: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9653: LD_EXP 30
9657: PPUSH
9658: LD_VAR 0 2
9662: PPUSH
9663: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9667: LD_VAR 0 3
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: CALL_OW 261
9680: PUSH
9681: LD_INT 80
9683: GREATER
9684: PUSH
9685: LD_VAR 0 3
9689: PUSH
9690: LD_INT 2
9692: ARRAY
9693: PPUSH
9694: CALL_OW 261
9698: PUSH
9699: LD_INT 80
9701: GREATER
9702: AND
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_INT 3
9711: ARRAY
9712: PPUSH
9713: CALL_OW 261
9717: PUSH
9718: LD_INT 80
9720: GREATER
9721: AND
9722: IFFALSE 9495
// end ; ComHold ( Gali ) ;
9724: LD_EXP 30
9728: PPUSH
9729: CALL_OW 140
// if not no_oil_gain then
9733: LD_VAR 0 6
9737: NOT
9738: IFFALSE 9903
// begin DialogueOn ;
9740: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9744: LD_EXP 29
9748: PPUSH
9749: CALL_OW 87
// if player_want_mortar then
9753: LD_EXP 12
9757: IFFALSE 9783
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9759: LD_EXP 29
9763: PPUSH
9764: LD_STRING D9e-Ar1-1
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9771: LD_EXP 21
9775: PPUSH
9776: LD_STRING D10a-JMM-1
9778: PPUSH
9779: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9783: LD_EXP 29
9787: PPUSH
9788: LD_STRING D10a-Ar1-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9795: LD_EXP 30
9799: PPUSH
9800: LD_STRING D10a-Ar2-1
9802: PPUSH
9803: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9807: LD_EXP 31
9811: PPUSH
9812: LD_STRING D10a-FAr1-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9819: LD_EXP 30
9823: PPUSH
9824: LD_STRING D10a-Ar2-2
9826: PPUSH
9827: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9831: LD_EXP 31
9835: PPUSH
9836: LD_STRING D10a-FAr1-2
9838: PPUSH
9839: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9843: LD_EXP 29
9847: PPUSH
9848: LD_STRING D10a-Ar1-2
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9855: LD_EXP 21
9859: PPUSH
9860: LD_STRING D10a-JMM-2
9862: PPUSH
9863: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9867: LD_EXP 29
9871: PPUSH
9872: LD_STRING D10a-Ar1-3
9874: PPUSH
9875: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9879: LD_EXP 21
9883: PPUSH
9884: LD_STRING D10a-JMM-3
9886: PPUSH
9887: CALL_OW 88
// player_get_info := true ;
9891: LD_ADDR_EXP 15
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// DialogueOff ;
9899: CALL_OW 7
// end ; end ; if player_attacked_ar then
9903: LD_EXP 16
9907: IFFALSE 9911
// exit ;
9909: GO 10083
// if player_want_mortar or player_want_info then
9911: LD_EXP 12
9915: PUSH
9916: LD_EXP 13
9920: OR
9921: IFFALSE 9935
// Say ( Vervecken , D9f-Ar1-1 ) ;
9923: LD_EXP 29
9927: PPUSH
9928: LD_STRING D9f-Ar1-1
9930: PPUSH
9931: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9935: LD_INT 22
9937: PUSH
9938: LD_INT 2
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: PPUSH
9950: LD_INT 51
9952: PPUSH
9953: LD_INT 99
9955: PPUSH
9956: CALL_OW 111
// wait ( 0 0$1 ) ;
9960: LD_INT 35
9962: PPUSH
9963: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9967: LD_INT 22
9969: PUSH
9970: LD_INT 2
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 92
9979: PUSH
9980: LD_INT 51
9982: PUSH
9983: LD_INT 99
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IFFALSE 10063
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 2
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 92
10022: PUSH
10023: LD_INT 51
10025: PUSH
10026: LD_INT 99
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 69
10046: PUSH
10047: FOR_IN
10048: IFFALSE 10061
// RemoveUnit ( i ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: CALL_OW 64
10059: GO 10047
10061: POP
10062: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: PUSH
10078: LD_INT 0
10080: EQUAL
10081: IFFALSE 9935
// end ;
10083: PPOPN 10
10085: END
// every 0 0$01 trigger blocked do var i ;
10086: LD_EXP 18
10090: IFFALSE 10258
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
10098: LD_EXP 29
10102: PPUSH
10103: LD_STRING D9f-Ar1-1
10105: PPUSH
10106: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10110: LD_INT 22
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_INT 51
10127: PPUSH
10128: LD_INT 99
10130: PPUSH
10131: CALL_OW 111
// wait ( 0 0$1 ) ;
10135: LD_INT 35
10137: PPUSH
10138: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10142: LD_INT 22
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 92
10154: PUSH
10155: LD_INT 51
10157: PUSH
10158: LD_INT 99
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: IFFALSE 10238
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10180: LD_ADDR_VAR 0 1
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 92
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 99
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PPUSH
10217: CALL_OW 69
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// RemoveUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 64
10234: GO 10222
10236: POP
10237: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10238: LD_INT 22
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: IFFALSE 10110
// end ;
10258: PPOPN 1
10260: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10261: LD_EXP 16
10265: IFFALSE 10618
10267: GO 10269
10269: DISABLE
10270: LD_INT 0
10272: PPUSH
10273: PPUSH
10274: PPUSH
10275: PPUSH
// begin ru_can_attack := true ;
10276: LD_ADDR_EXP 8
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// mine_launched := false ;
10284: LD_ADDR_VAR 0 3
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PPUSH
10307: LD_INT 51
10309: PPUSH
10310: LD_INT 99
10312: PPUSH
10313: CALL_OW 111
// if IsOk ( Vervecken ) then
10317: LD_EXP 29
10321: PPUSH
10322: CALL_OW 302
10326: IFFALSE 10340
// Say ( Vervecken , D11a-Ar1-1 ) ;
10328: LD_EXP 29
10332: PPUSH
10333: LD_STRING D11a-Ar1-1
10335: PPUSH
10336: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10340: LD_ADDR_VAR 0 2
10344: PUSH
10345: LD_EXP 36
10349: PPUSH
10350: LD_INT 25
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 72
10364: ST_TO_ADDR
// for i in tmp do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10439
// if MineOfUnit ( i ) then
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 459
10387: IFFALSE 10437
// begin x := MineOfUnit ( i ) ;
10389: LD_ADDR_VAR 0 4
10393: PUSH
10394: LD_VAR 0 1
10398: PPUSH
10399: CALL_OW 459
10403: ST_TO_ADDR
// mine_launched := true ;
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10412: LD_VAR 0 4
10416: PUSH
10417: LD_INT 1
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_INT 2
10428: ARRAY
10429: PPUSH
10430: LD_INT 2
10432: PPUSH
10433: CALL_OW 456
// end ;
10437: GO 10375
10439: POP
10440: POP
// if mine_launched and IsOk ( Vervecken ) then
10441: LD_VAR 0 3
10445: PUSH
10446: LD_EXP 29
10450: PPUSH
10451: CALL_OW 302
10455: AND
10456: IFFALSE 10470
// Say ( Vervecken , D11b-Ar1-1 ) ;
10458: LD_EXP 29
10462: PPUSH
10463: LD_STRING D11b-Ar1-1
10465: PPUSH
10466: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10470: LD_INT 22
10472: PUSH
10473: LD_INT 2
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: PPUSH
10485: LD_INT 51
10487: PPUSH
10488: LD_INT 99
10490: PPUSH
10491: CALL_OW 111
// wait ( 0 0$1 ) ;
10495: LD_INT 35
10497: PPUSH
10498: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10502: LD_INT 22
10504: PUSH
10505: LD_INT 2
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 92
10514: PUSH
10515: LD_INT 51
10517: PUSH
10518: LD_INT 99
10520: PUSH
10521: LD_INT 2
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IFFALSE 10598
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 22
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 92
10557: PUSH
10558: LD_INT 51
10560: PUSH
10561: LD_INT 99
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: PUSH
10582: FOR_IN
10583: IFFALSE 10596
// RemoveUnit ( i ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: CALL_OW 64
10594: GO 10582
10596: POP
10597: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PUSH
10613: LD_INT 0
10615: EQUAL
10616: IFFALSE 10470
// end ;
10618: PPOPN 4
10620: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10621: LD_EXP 10
10625: IFFALSE 10804
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
// begin Wait ( 10 10$00 ) ;
10633: LD_INT 21000
10635: PPUSH
10636: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10640: LD_INT 22
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: IFFALSE 10804
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: PPUSH
10671: LD_INT 51
10673: PPUSH
10674: LD_INT 99
10676: PPUSH
10677: CALL_OW 114
// wait ( 0 0$1 ) ;
10681: LD_INT 35
10683: PPUSH
10684: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10688: LD_INT 22
10690: PUSH
10691: LD_INT 2
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 92
10700: PUSH
10701: LD_INT 51
10703: PUSH
10704: LD_INT 99
10706: PUSH
10707: LD_INT 2
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: IFFALSE 10784
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 92
10743: PUSH
10744: LD_INT 51
10746: PUSH
10747: LD_INT 99
10749: PUSH
10750: LD_INT 2
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10782
// RemoveUnit ( i ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 64
10780: GO 10768
10782: POP
10783: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10784: LD_INT 22
10786: PUSH
10787: LD_INT 2
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: PUSH
10799: LD_INT 0
10801: EQUAL
10802: IFFALSE 10656
// end ; end ;
10804: PPOPN 1
10806: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10807: LD_EXP 4
10811: IFFALSE 11866
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
10819: PPUSH
10820: PPUSH
10821: PPUSH
10822: PPUSH
10823: PPUSH
// begin Wait ( game_time ) ;
10824: LD_EXP 7
10828: PPUSH
10829: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10833: LD_INT 35
10835: PPUSH
10836: CALL_OW 67
// until ( not ru_can_attack ) ;
10840: LD_EXP 8
10844: NOT
10845: IFFALSE 10833
// Wait ( 0 0$35 ) ;
10847: LD_INT 1225
10849: PPUSH
10850: CALL_OW 67
// DialogueOn ;
10854: CALL_OW 6
// InGameOn ;
10858: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10862: LD_EXP 28
10866: PPUSH
10867: LD_STRING D12-Pow-1
10869: PPUSH
10870: CALL_OW 94
// InGameOff ;
10874: CALL_OW 9
// DialogueOff ;
10878: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10882: LD_STRING M4
10884: PPUSH
10885: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10889: LD_INT 5
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 424
// can_end := true ;
10899: LD_ADDR_EXP 17
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10907: LD_INT 35
10909: PPUSH
10910: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10914: CALL 943 0 0
10918: PUSH
10919: LD_INT 20
10921: GREATEREQUAL
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_INT 1
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 21
10935: PUSH
10936: LD_INT 1
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PPUSH
10947: CALL_OW 69
10951: PUSH
10952: LD_INT 5
10954: PPUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 70
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 1
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 55
10996: PUSH
10997: EMPTY
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PLUS
11009: LESSEQUAL
11010: AND
11011: IFFALSE 10907
// if not player_get_info then
11013: LD_EXP 15
11017: NOT
11018: IFFALSE 11029
// player_get_info := - 1 ;
11020: LD_ADDR_EXP 15
11024: PUSH
11025: LD_INT 1
11027: NEG
11028: ST_TO_ADDR
// m1 := player_get_info > 0 ;
11029: LD_ADDR_VAR 0 4
11033: PUSH
11034: LD_EXP 15
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: ST_TO_ADDR
// m2 := false ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// m3 := earlySib ;
11051: LD_ADDR_VAR 0 6
11055: PUSH
11056: LD_EXP 19
11060: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
11061: LD_STRING Information
11063: PPUSH
11064: LD_EXP 15
11068: PPUSH
11069: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
11073: LD_ADDR_VAR 0 2
11077: PUSH
11078: LD_INT 22
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 2
11090: PUSH
11091: LD_INT 25
11093: PUSH
11094: LD_INT 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 25
11103: PUSH
11104: LD_INT 16
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 34
11113: PUSH
11114: LD_INT 12
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PPUSH
11131: CALL_OW 69
11135: ST_TO_ADDR
// sib := GetTerminalCargo ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: CALL 943 0 0
11145: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
11146: LD_ADDR_VAR 0 3
11150: PUSH
11151: LD_VAR 0 3
11155: PUSH
11156: LD_INT 6
11158: PPUSH
11159: LD_INT 3
11161: PPUSH
11162: CALL_OW 287
11166: PLUS
11167: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11168: LD_ADDR_VAR 0 3
11172: PUSH
11173: LD_VAR 0 3
11177: PUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: LD_INT 3
11185: PPUSH
11186: CALL_OW 289
11190: PLUS
11191: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11192: LD_VAR 0 3
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_OWVAR 67
11204: PLUS
11205: PUSH
11206: LD_INT 50
11208: MUL
11209: LESS
11210: IFFALSE 11235
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11212: LD_STRING MuchSiberite
11214: PPUSH
11215: LD_INT 2
11217: NEG
11218: PUSH
11219: LD_OWVAR 67
11223: MUL
11224: PUSH
11225: LD_INT 1
11227: PLUS
11228: PPUSH
11229: CALL_OW 101
11233: GO 11253
// begin AddMedal ( MuchSiberite , 1 ) ;
11235: LD_STRING MuchSiberite
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 101
// m2 := true ;
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 1
11252: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11253: LD_VAR 0 4
11257: PUSH
11258: LD_VAR 0 5
11262: AND
11263: PUSH
11264: LD_VAR 0 6
11268: AND
11269: PUSH
11270: LD_OWVAR 67
11274: PUSH
11275: LD_INT 3
11277: EQUAL
11278: AND
11279: IFFALSE 11291
// SetAchievementEX ( ACH_AMER , 9 ) ;
11281: LD_STRING ACH_AMER
11283: PPUSH
11284: LD_INT 9
11286: PPUSH
11287: CALL_OW 564
// if tick <= 55 55$00 then
11291: LD_OWVAR 1
11295: PUSH
11296: LD_INT 115500
11298: LESSEQUAL
11299: IFFALSE 11308
// SetAchievement ( ACH_ASPEED_9 ) ;
11301: LD_STRING ACH_ASPEED_9
11303: PPUSH
11304: CALL_OW 543
// GiveMedals ( MAIN ) ;
11308: LD_STRING MAIN
11310: PPUSH
11311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PUSH
11325: LD_INT 2
11327: PUSH
11328: LD_INT 25
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 25
11340: PUSH
11341: LD_INT 2
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 25
11350: PUSH
11351: LD_INT 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: LD_INT 25
11360: PUSH
11361: LD_INT 4
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 25
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PPUSH
11395: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11399: LD_ADDR_VAR 0 2
11403: PUSH
11404: LD_INT 22
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 25
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 69
11432: ST_TO_ADDR
// if tmp then
11433: LD_VAR 0 2
11437: IFFALSE 11468
// for i in tmp do
11439: LD_ADDR_VAR 0 1
11443: PUSH
11444: LD_VAR 0 2
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11466
// SetClass ( i , 1 ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 336
11464: GO 11449
11466: POP
11467: POP
// SaveVariable ( sib , 09_sibRes ) ;
11468: LD_VAR 0 3
11472: PPUSH
11473: LD_STRING 09_sibRes
11475: PPUSH
11476: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11480: LD_EXP 15
11484: PPUSH
11485: LD_STRING 09_arInfo
11487: PPUSH
11488: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11492: LD_EXP 21
11496: PPUSH
11497: LD_EXP 1
11501: PUSH
11502: LD_STRING JMM
11504: STR
11505: PPUSH
11506: CALL_OW 38
// if IsLive ( Gary ) then
11510: LD_EXP 22
11514: PPUSH
11515: CALL_OW 300
11519: IFFALSE 11539
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11521: LD_EXP 22
11525: PPUSH
11526: LD_EXP 1
11530: PUSH
11531: LD_STRING Gary
11533: STR
11534: PPUSH
11535: CALL_OW 38
// if IsLive ( Bobby ) then
11539: LD_EXP 23
11543: PPUSH
11544: CALL_OW 300
11548: IFFALSE 11568
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11550: LD_EXP 23
11554: PPUSH
11555: LD_EXP 1
11559: PUSH
11560: LD_STRING Bobby
11562: STR
11563: PPUSH
11564: CALL_OW 38
// if IsLive ( Cyrus ) then
11568: LD_EXP 24
11572: PPUSH
11573: CALL_OW 300
11577: IFFALSE 11597
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11579: LD_EXP 24
11583: PPUSH
11584: LD_EXP 1
11588: PUSH
11589: LD_STRING Cyrus
11591: STR
11592: PPUSH
11593: CALL_OW 38
// if IsLive ( Houten ) then
11597: LD_EXP 25
11601: PPUSH
11602: CALL_OW 300
11606: IFFALSE 11626
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11608: LD_EXP 25
11612: PPUSH
11613: LD_EXP 1
11617: PUSH
11618: LD_STRING Houten
11620: STR
11621: PPUSH
11622: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 25
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 4
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 21
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 23
11714: PUSH
11715: LD_EXP 25
11719: PUSH
11720: LD_EXP 22
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: DIFF
11732: ST_TO_ADDR
// if tmp then
11733: LD_VAR 0 2
11737: IFFALSE 11757
// SaveCharacters ( tmp , mission_prefix & others ) ;
11739: LD_VAR 0 2
11743: PPUSH
11744: LD_EXP 1
11748: PUSH
11749: LD_STRING others
11751: STR
11752: PPUSH
11753: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11757: LD_ADDR_VAR 0 2
11761: PUSH
11762: LD_INT 22
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 12
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: LD_INT 25
11787: PUSH
11788: LD_INT 16
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PPUSH
11804: CALL_OW 69
11808: ST_TO_ADDR
// if tmp then
11809: LD_VAR 0 2
11813: IFFALSE 11833
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11815: LD_VAR 0 2
11819: PPUSH
11820: LD_EXP 1
11824: PUSH
11825: LD_STRING apes
11827: STR
11828: PPUSH
11829: CALL_OW 38
// if IsLive ( Yakotich ) then
11833: LD_EXP 37
11837: PPUSH
11838: CALL_OW 300
11842: IFFALSE 11862
// SaveCharacters ( Yakotich , mission_prefix & Yakotich ) ;
11844: LD_EXP 37
11848: PPUSH
11849: LD_EXP 1
11853: PUSH
11854: LD_STRING Yakotich
11856: STR
11857: PPUSH
11858: CALL_OW 38
// YouWin ;
11862: CALL_OW 103
// end ; end_of_file
11866: PPOPN 6
11868: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11869: LD_VAR 0 1
11873: PPUSH
11874: CALL_OW 266
11878: PUSH
11879: LD_INT 0
11881: EQUAL
11882: PUSH
11883: LD_EXP 3
11887: NOT
11888: AND
11889: IFFALSE 11913
// begin terminal := b ;
11891: LD_ADDR_EXP 3
11895: PUSH
11896: LD_VAR 0 1
11900: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11901: LD_EXP 3
11905: PPUSH
11906: LD_STRING terminal
11908: PPUSH
11909: CALL_OW 500
// end ; end ;
11913: PPOPN 2
11915: END
// on BuildingComplete ( b ) do var i ;
11916: LD_INT 0
11918: PPUSH
// begin if GetSide ( b ) = 3 then
11919: LD_VAR 0 1
11923: PPUSH
11924: CALL_OW 255
11928: PUSH
11929: LD_INT 3
11931: EQUAL
11932: IFFALSE 11972
// for i = 1 to 4 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 4
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11970
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11950: LD_ADDR_EXP 39
11954: PUSH
11955: LD_EXP 39
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 3
11967: ST_TO_ADDR
11968: GO 11947
11970: POP
11971: POP
// end ;
11972: PPOPN 2
11974: END
// on VehicleConstructed ( veh , fac ) do var i ;
11975: LD_INT 0
11977: PPUSH
// begin if GetSide ( veh ) = 3 then
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 255
11987: PUSH
11988: LD_INT 3
11990: EQUAL
11991: IFFALSE 12116
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 264
12002: PUSH
12003: LD_INT 53
12005: PUSH
12006: LD_INT 52
12008: PUSH
12009: LD_INT 51
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: LIST
12016: IN
12017: NOT
12018: IFFALSE 12036
// ru_force := ru_force ^ veh ;
12020: LD_ADDR_EXP 38
12024: PUSH
12025: LD_EXP 38
12029: PUSH
12030: LD_VAR 0 1
12034: ADD
12035: ST_TO_ADDR
// for i = 1 to 4 do
12036: LD_ADDR_VAR 0 3
12040: PUSH
12041: DOUBLE
12042: LD_INT 1
12044: DEC
12045: ST_TO_ADDR
12046: LD_INT 4
12048: PUSH
12049: FOR_TO
12050: IFFALSE 12072
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
12052: LD_ADDR_EXP 40
12056: PUSH
12057: LD_EXP 40
12061: PPUSH
12062: LD_INT 1
12064: PPUSH
12065: CALL_OW 3
12069: ST_TO_ADDR
12070: GO 12049
12072: POP
12073: POP
// if GetWeapon ( veh ) = ru_bulldozer then
12074: LD_VAR 0 1
12078: PPUSH
12079: CALL_OW 264
12083: PUSH
12084: LD_INT 53
12086: EQUAL
12087: IFFALSE 12116
// begin CutTreeInArea ( veh , cutTreeArea ) ;
12089: LD_VAR 0 1
12093: PPUSH
12094: LD_INT 7
12096: PPUSH
12097: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
12101: LD_VAR 0 1
12105: PPUSH
12106: LD_INT 170
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 171
// end ; end ; end ;
12116: PPOPN 3
12118: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
12119: LD_VAR 0 1
12123: PUSH
12124: LD_INT 1
12126: EQUAL
12127: PUSH
12128: LD_VAR 0 2
12132: PUSH
12133: LD_INT 2
12135: EQUAL
12136: AND
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 2
12145: EQUAL
12146: PUSH
12147: LD_VAR 0 2
12151: PUSH
12152: LD_INT 1
12154: EQUAL
12155: AND
12156: OR
12157: IFFALSE 12167
// player_attacked_ar := true ;
12159: LD_ADDR_EXP 16
12163: PUSH
12164: LD_INT 1
12166: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
12167: LD_VAR 0 1
12171: PUSH
12172: LD_INT 1
12174: EQUAL
12175: PUSH
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 4
12183: EQUAL
12184: AND
12185: PUSH
12186: LD_VAR 0 1
12190: PUSH
12191: LD_INT 4
12193: EQUAL
12194: PUSH
12195: LD_VAR 0 2
12199: PUSH
12200: LD_INT 1
12202: EQUAL
12203: AND
12204: OR
12205: IFFALSE 12214
// YouLost ( Traitor ) ;
12207: LD_STRING Traitor
12209: PPUSH
12210: CALL_OW 104
// end ;
12214: PPOPN 2
12216: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12217: LD_VAR 0 1
12221: PUSH
12222: LD_EXP 21
12226: EQUAL
12227: IFFALSE 12236
// YouLost ( JMM ) ;
12229: LD_STRING JMM
12231: PPUSH
12232: CALL_OW 104
// if un = terminal then
12236: LD_VAR 0 1
12240: PUSH
12241: LD_EXP 3
12245: EQUAL
12246: IFFALSE 12255
// YouLost ( Terminal ) ;
12248: LD_STRING Terminal
12250: PPUSH
12251: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 264
12264: PUSH
12265: LD_INT 53
12267: EQUAL
12268: IFFALSE 12284
// bulldozerCounter := bulldozerCounter + 1 ;
12270: LD_ADDR_EXP 20
12274: PUSH
12275: LD_EXP 20
12279: PUSH
12280: LD_INT 1
12282: PLUS
12283: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12284: LD_VAR 0 1
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 3
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 21
12301: PUSH
12302: LD_INT 3
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PPUSH
12313: CALL_OW 69
12317: IN
12318: IFFALSE 12464
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 266
12329: PUSH
12330: LD_INT 33
12332: PUSH
12333: LD_INT 26
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: IN
12340: IFFALSE 12399
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12342: LD_ADDR_EXP 39
12346: PUSH
12347: LD_EXP 39
12351: PUSH
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 266
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 250
12371: PUSH
12372: LD_VAR 0 1
12376: PPUSH
12377: CALL_OW 251
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 254
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: ADD
12398: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12399: LD_VAR 0 1
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_INT 5
12411: EQUAL
12412: IFFALSE 12464
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12414: LD_ADDR_EXP 39
12418: PUSH
12419: LD_EXP 39
12423: PUSH
12424: LD_INT 4
12426: PUSH
12427: LD_VAR 0 1
12431: PPUSH
12432: CALL_OW 250
12436: PUSH
12437: LD_VAR 0 1
12441: PPUSH
12442: CALL_OW 251
12446: PUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: ADD
12463: ST_TO_ADDR
// end ; if un in ru_force then
12464: LD_VAR 0 1
12468: PUSH
12469: LD_EXP 38
12473: IN
12474: IFFALSE 12510
// begin ru_force := ru_force diff un ;
12476: LD_ADDR_EXP 38
12480: PUSH
12481: LD_EXP 38
12485: PUSH
12486: LD_VAR 0 1
12490: DIFF
12491: ST_TO_ADDR
// if ru_force = 0 then
12492: LD_EXP 38
12496: PUSH
12497: LD_INT 0
12499: EQUAL
12500: IFFALSE 12510
// ru_can_attack := false ;
12502: LD_ADDR_EXP 8
12506: PUSH
12507: LD_INT 0
12509: ST_TO_ADDR
// end ; end ;
12510: PPOPN 1
12512: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12513: LD_VAR 0 1
12517: PPUSH
12518: CALL 28634 0 1
// end ; end_of_file
12522: PPOPN 1
12524: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12525: LD_EXP 5
12529: PUSH
12530: LD_EXP 6
12534: AND
12535: IFFALSE 12620
12537: GO 12539
12539: DISABLE
12540: LD_INT 0
12542: PPUSH
// begin enable ;
12543: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12544: LD_ADDR_VAR 0 1
12548: PUSH
12549: LD_INT 60
12551: PUSH
12552: CALL 943 0 0
12556: MINUS
12557: ST_TO_ADDR
// if sib < 0 then
12558: LD_VAR 0 1
12562: PUSH
12563: LD_INT 0
12565: LESS
12566: IFFALSE 12576
// sib := 0 ;
12568: LD_ADDR_VAR 0 1
12572: PUSH
12573: LD_INT 0
12575: ST_TO_ADDR
// if not debug then
12576: LD_EXP 2
12580: NOT
12581: IFFALSE 12606
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12583: LD_ADDR_OWVAR 47
12587: PUSH
12588: LD_STRING #Am09-1
12590: PUSH
12591: LD_VAR 0 1
12595: PUSH
12596: LD_EXP 6
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: LIST
12605: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12606: LD_ADDR_EXP 6
12610: PUSH
12611: LD_EXP 6
12615: PUSH
12616: LD_INT 35
12618: MINUS
12619: ST_TO_ADDR
// end ;
12620: PPOPN 1
12622: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12623: LD_EXP 6
12627: PUSH
12628: LD_INT 0
12630: EQUAL
12631: IFFALSE 12643
12633: GO 12635
12635: DISABLE
// display_strings := [ ] ;
12636: LD_ADDR_OWVAR 47
12640: PUSH
12641: EMPTY
12642: ST_TO_ADDR
12643: END
// every 1 1$35 do var i , tmp ;
12644: GO 12646
12646: DISABLE
12647: LD_INT 0
12649: PPUSH
12650: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: LD_INT 1155
12658: PUSH
12659: LD_INT 1225
12661: PUSH
12662: LD_INT 1435
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: LD_OWVAR 67
12674: ARRAY
12675: ST_TO_ADDR
// i := 0 ;
12676: LD_ADDR_VAR 0 1
12680: PUSH
12681: LD_INT 0
12683: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12684: LD_INT 1
12686: PPUSH
12687: LD_INT 5
12689: PPUSH
12690: CALL_OW 12
12694: PPUSH
12695: LD_INT 75
12697: PPUSH
12698: LD_INT 75
12700: PPUSH
12701: LD_INT 20
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL_OW 56
// wait ( tmp ) ;
12711: LD_VAR 0 2
12715: PPUSH
12716: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12720: LD_ADDR_VAR 0 2
12724: PUSH
12725: LD_VAR 0 2
12729: PUSH
12730: LD_INT 105
12732: PPUSH
12733: LD_INT 315
12735: PPUSH
12736: CALL_OW 12
12740: PLUS
12741: ST_TO_ADDR
// i := i + 1 ;
12742: LD_ADDR_VAR 0 1
12746: PUSH
12747: LD_VAR 0 1
12751: PUSH
12752: LD_INT 1
12754: PLUS
12755: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12756: LD_VAR 0 1
12760: PUSH
12761: LD_INT 3
12763: MOD
12764: PUSH
12765: LD_INT 0
12767: EQUAL
12768: PUSH
12769: LD_EXP 4
12773: AND
12774: IFFALSE 12812
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12776: LD_INT 2
12778: PPUSH
12779: LD_INT 5
12781: PPUSH
12782: CALL_OW 12
12786: PPUSH
12787: LD_INT 8
12789: PPUSH
12790: LD_INT 1
12792: PPUSH
12793: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12797: LD_INT 665
12799: PPUSH
12800: LD_INT 735
12802: PPUSH
12803: CALL_OW 12
12807: PPUSH
12808: CALL_OW 67
// end ; until tick > game_time ;
12812: LD_OWVAR 1
12816: PUSH
12817: LD_EXP 7
12821: GREATER
12822: IFFALSE 12684
// end ; end_of_file
12824: PPOPN 2
12826: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12827: LD_INT 0
12829: PPUSH
12830: PPUSH
12831: PPUSH
12832: PPUSH
12833: PPUSH
12834: PPUSH
// x := 76 ;
12835: LD_ADDR_VAR 0 5
12839: PUSH
12840: LD_INT 76
12842: ST_TO_ADDR
// y := 147 ;
12843: LD_ADDR_VAR 0 6
12847: PUSH
12848: LD_INT 147
12850: ST_TO_ADDR
// uc_side := 2 ;
12851: LD_ADDR_OWVAR 20
12855: PUSH
12856: LD_INT 2
12858: ST_TO_ADDR
// uc_nation := 2 ;
12859: LD_ADDR_OWVAR 21
12863: PUSH
12864: LD_INT 2
12866: ST_TO_ADDR
// InitHc ;
12867: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 6
12879: PPUSH
12880: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12884: LD_ADDR_OWVAR 26
12888: PUSH
12889: LD_STRING Nicolas Vervecken
12891: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12892: LD_ADDR_OWVAR 33
12896: PUSH
12897: LD_STRING SecondCharsGal
12899: ST_TO_ADDR
// hc_face_number := 3 ;
12900: LD_ADDR_OWVAR 34
12904: PUSH
12905: LD_INT 3
12907: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12908: LD_ADDR_OWVAR 29
12912: PUSH
12913: LD_INT 11
12915: PUSH
12916: LD_INT 10
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: ST_TO_ADDR
// Vervecken := CreateHuman ;
12923: LD_ADDR_EXP 29
12927: PUSH
12928: CALL_OW 44
12932: ST_TO_ADDR
// ar_force := Vervecken ;
12933: LD_ADDR_EXP 36
12937: PUSH
12938: LD_EXP 29
12942: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 2
12948: PPUSH
12949: LD_INT 6
12951: PPUSH
12952: CALL_OW 380
// hc_name := Louis Gali ;
12956: LD_ADDR_OWVAR 26
12960: PUSH
12961: LD_STRING Louis Gali
12963: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12964: LD_ADDR_OWVAR 33
12968: PUSH
12969: LD_STRING SecondCharsGal
12971: ST_TO_ADDR
// hc_face_number := 2 ;
12972: LD_ADDR_OWVAR 34
12976: PUSH
12977: LD_INT 2
12979: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12980: LD_ADDR_OWVAR 29
12984: PUSH
12985: LD_INT 10
12987: PUSH
12988: LD_INT 11
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// Gali := CreateHuman ;
12995: LD_ADDR_EXP 30
12999: PUSH
13000: CALL_OW 44
13004: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
13005: LD_ADDR_EXP 36
13009: PUSH
13010: LD_EXP 36
13014: PUSH
13015: LD_EXP 30
13019: ADD
13020: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
13021: LD_INT 2
13023: PPUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_INT 6
13029: PPUSH
13030: CALL_OW 380
// hc_name := Maria Bogdanovic ;
13034: LD_ADDR_OWVAR 26
13038: PUSH
13039: LD_STRING Maria Bogdanovic
13041: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13042: LD_ADDR_OWVAR 33
13046: PUSH
13047: LD_STRING SecondCharsGal
13049: ST_TO_ADDR
// hc_face_number := 14 ;
13050: LD_ADDR_OWVAR 34
13054: PUSH
13055: LD_INT 14
13057: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
13058: LD_ADDR_OWVAR 29
13062: PUSH
13063: LD_INT 12
13065: PUSH
13066: LD_INT 9
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
13073: LD_ADDR_EXP 31
13077: PUSH
13078: CALL_OW 44
13082: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
13083: LD_ADDR_EXP 36
13087: PUSH
13088: LD_EXP 36
13092: PUSH
13093: LD_EXP 31
13097: ADD
13098: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13099: LD_INT 1
13101: PPUSH
13102: LD_INT 3
13104: PPUSH
13105: LD_INT 6
13107: PPUSH
13108: CALL_OW 380
// hc_name = Kntor Radomr ;
13112: LD_ADDR_OWVAR 26
13116: PUSH
13117: LD_STRING Kntor Radomr
13119: ST_TO_ADDR
// hc_gallery = sandar ;
13120: LD_ADDR_OWVAR 33
13124: PUSH
13125: LD_STRING sandar
13127: ST_TO_ADDR
// hc_face_number = 12 ;
13128: LD_ADDR_OWVAR 34
13132: PUSH
13133: LD_INT 12
13135: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
13136: LD_ADDR_OWVAR 29
13140: PUSH
13141: LD_INT 9
13143: PUSH
13144: LD_INT 9
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: ST_TO_ADDR
// Kantor = CreateHuman ;
13151: LD_ADDR_EXP 32
13155: PUSH
13156: CALL_OW 44
13160: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
13161: LD_ADDR_EXP 36
13165: PUSH
13166: LD_EXP 36
13170: PUSH
13171: LD_EXP 32
13175: ADD
13176: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 3
13182: PPUSH
13183: LD_INT 6
13185: PPUSH
13186: CALL_OW 380
// hc_name = Herczeg Farkas ;
13190: LD_ADDR_OWVAR 26
13194: PUSH
13195: LD_STRING Herczeg Farkas
13197: ST_TO_ADDR
// hc_gallery = sandar ;
13198: LD_ADDR_OWVAR 33
13202: PUSH
13203: LD_STRING sandar
13205: ST_TO_ADDR
// hc_face_number = 28 ;
13206: LD_ADDR_OWVAR 34
13210: PUSH
13211: LD_INT 28
13213: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13214: LD_ADDR_OWVAR 29
13218: PUSH
13219: LD_INT 10
13221: PUSH
13222: LD_INT 9
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: ST_TO_ADDR
// Herczeg = CreateHuman ;
13229: LD_ADDR_EXP 33
13233: PUSH
13234: CALL_OW 44
13238: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13239: LD_ADDR_EXP 36
13243: PUSH
13244: LD_EXP 36
13248: PUSH
13249: LD_EXP 33
13253: ADD
13254: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13255: LD_INT 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: LD_INT 6
13263: PPUSH
13264: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13268: LD_ADDR_OWVAR 26
13272: PUSH
13273: LD_STRING Ronn Horntvedt
13275: ST_TO_ADDR
// hc_gallery = sandar ;
13276: LD_ADDR_OWVAR 33
13280: PUSH
13281: LD_STRING sandar
13283: ST_TO_ADDR
// hc_face_number = 29 ;
13284: LD_ADDR_OWVAR 34
13288: PUSH
13289: LD_INT 29
13291: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13292: LD_ADDR_OWVAR 29
13296: PUSH
13297: LD_INT 11
13299: PUSH
13300: LD_INT 11
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: ST_TO_ADDR
// Ronn = CreateHuman ;
13307: LD_ADDR_EXP 34
13311: PUSH
13312: CALL_OW 44
13316: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13317: LD_ADDR_EXP 36
13321: PUSH
13322: LD_EXP 36
13326: PUSH
13327: LD_EXP 34
13331: ADD
13332: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13333: LD_INT 2
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 6
13341: PPUSH
13342: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13346: LD_ADDR_OWVAR 26
13350: PUSH
13351: LD_STRING Mia D. Mathiasen
13353: ST_TO_ADDR
// hc_gallery = sandar ;
13354: LD_ADDR_OWVAR 33
13358: PUSH
13359: LD_STRING sandar
13361: ST_TO_ADDR
// hc_face_number = 31 ;
13362: LD_ADDR_OWVAR 34
13366: PUSH
13367: LD_INT 31
13369: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13370: LD_ADDR_OWVAR 29
13374: PUSH
13375: LD_INT 10
13377: PUSH
13378: LD_INT 10
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: ST_TO_ADDR
// Mia = CreateHuman ;
13385: LD_ADDR_EXP 35
13389: PUSH
13390: CALL_OW 44
13394: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13395: LD_ADDR_EXP 36
13399: PUSH
13400: LD_EXP 36
13404: PUSH
13405: LD_EXP 35
13409: ADD
13410: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13411: LD_ADDR_VAR 0 3
13415: PUSH
13416: LD_VAR 0 3
13420: PUSH
13421: LD_INT 2
13423: PPUSH
13424: LD_INT 2
13426: PPUSH
13427: LD_INT 14
13429: PPUSH
13430: LD_INT 1
13432: PPUSH
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 32
13438: PPUSH
13439: LD_INT 30
13441: PPUSH
13442: CALL 423 0 7
13446: ADD
13447: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_INT 2
13460: PPUSH
13461: LD_INT 2
13463: PPUSH
13464: LD_INT 14
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: LD_INT 1
13472: PPUSH
13473: LD_INT 27
13475: PPUSH
13476: LD_INT 30
13478: PPUSH
13479: CALL 423 0 7
13483: ADD
13484: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_VAR 0 3
13494: PUSH
13495: LD_INT 2
13497: PPUSH
13498: LD_INT 2
13500: PPUSH
13501: LD_INT 14
13503: PPUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_INT 25
13512: PPUSH
13513: LD_INT 33
13515: PPUSH
13516: CALL 423 0 7
13520: ADD
13521: ST_TO_ADDR
// tmp := tmp diff 0 ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_INT 0
13534: DIFF
13535: ST_TO_ADDR
// for i in ar_force do
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_EXP 36
13545: PUSH
13546: FOR_IN
13547: IFFALSE 13690
// begin if GetClass ( i ) = 3 then
13549: LD_VAR 0 4
13553: PPUSH
13554: CALL_OW 257
13558: PUSH
13559: LD_INT 3
13561: EQUAL
13562: IFFALSE 13644
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13564: LD_VAR 0 3
13568: PUSH
13569: LD_INT 1
13571: ARRAY
13572: PPUSH
13573: LD_INT 1
13575: PPUSH
13576: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: PPUSH
13589: LD_VAR 0 5
13593: PPUSH
13594: LD_VAR 0 6
13598: PPUSH
13599: LD_INT 0
13601: PPUSH
13602: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13606: LD_VAR 0 4
13610: PPUSH
13611: LD_VAR 0 3
13615: PUSH
13616: LD_INT 1
13618: ARRAY
13619: PPUSH
13620: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13624: LD_ADDR_VAR 0 3
13628: PUSH
13629: LD_VAR 0 3
13633: PPUSH
13634: LD_INT 1
13636: PPUSH
13637: CALL_OW 3
13641: ST_TO_ADDR
// end else
13642: GO 13666
// PlaceUnitXY ( i , x , y , false ) ;
13644: LD_VAR 0 4
13648: PPUSH
13649: LD_VAR 0 5
13653: PPUSH
13654: LD_VAR 0 6
13658: PPUSH
13659: LD_INT 0
13661: PPUSH
13662: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13666: LD_VAR 0 4
13670: PPUSH
13671: LD_INT 86
13673: PPUSH
13674: LD_INT 121
13676: PPUSH
13677: CALL_OW 111
// wait ( 0 0$2 ) ;
13681: LD_INT 70
13683: PPUSH
13684: CALL_OW 67
// end ;
13688: GO 13546
13690: POP
13691: POP
// ar_force := ar_force ^ tmp ;
13692: LD_ADDR_EXP 36
13696: PUSH
13697: LD_EXP 36
13701: PUSH
13702: LD_VAR 0 3
13706: ADD
13707: ST_TO_ADDR
// ar_spawned := true ;
13708: LD_ADDR_EXP 11
13712: PUSH
13713: LD_INT 1
13715: ST_TO_ADDR
// end ; end_of_file
13716: LD_VAR 0 1
13720: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13721: LD_INT 0
13723: PPUSH
13724: PPUSH
13725: PPUSH
13726: PPUSH
13727: PPUSH
13728: PPUSH
13729: PPUSH
// InitHc ;
13730: CALL_OW 19
// uc_side := 3 ;
13734: LD_ADDR_OWVAR 20
13738: PUSH
13739: LD_INT 3
13741: ST_TO_ADDR
// uc_nation := 3 ;
13742: LD_ADDR_OWVAR 21
13746: PUSH
13747: LD_INT 3
13749: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13750: LD_ADDR_VAR 0 5
13754: PUSH
13755: LD_INT 5
13757: PUSH
13758: LD_INT 6
13760: PUSH
13761: LD_INT 7
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: ST_TO_ADDR
// ru_force := [ ] ;
13775: LD_ADDR_EXP 38
13779: PUSH
13780: EMPTY
13781: ST_TO_ADDR
// ru_rebuild := [ ] ;
13782: LD_ADDR_EXP 39
13786: PUSH
13787: EMPTY
13788: ST_TO_ADDR
// ru_produce_list := [ ] ;
13789: LD_ADDR_EXP 40
13793: PUSH
13794: EMPTY
13795: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13796: LD_ADDR_VAR 0 6
13800: PUSH
13801: LD_INT 22
13803: PUSH
13804: LD_INT 3
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: PUSH
13811: LD_INT 30
13813: PUSH
13814: LD_INT 8
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PPUSH
13825: CALL_OW 69
13829: PUSH
13830: LD_INT 1
13832: ARRAY
13833: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13834: LD_ADDR_VAR 0 4
13838: PUSH
13839: LD_INT 43
13841: PUSH
13842: LD_INT 46
13844: PUSH
13845: LD_INT 45
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13853: LD_ADDR_VAR 0 7
13857: PUSH
13858: LD_INT 22
13860: PUSH
13861: LD_INT 3
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: LD_INT 30
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 69
13886: PUSH
13887: LD_INT 1
13889: ARRAY
13890: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13891: LD_VAR 0 7
13895: PPUSH
13896: CALL_OW 274
13900: PPUSH
13901: LD_INT 1
13903: PPUSH
13904: LD_INT 5000
13906: PPUSH
13907: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13911: LD_VAR 0 7
13915: PPUSH
13916: CALL_OW 274
13920: PPUSH
13921: LD_INT 2
13923: PPUSH
13924: LD_INT 1000
13926: PPUSH
13927: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13931: LD_VAR 0 7
13935: PPUSH
13936: CALL_OW 274
13940: PPUSH
13941: LD_INT 3
13943: PPUSH
13944: LD_INT 30
13946: PPUSH
13947: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 3
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: PUSH
13985: FOR_IN
13986: IFFALSE 14019
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
13988: LD_VAR 0 2
13992: PPUSH
13993: LD_INT 5
13995: PUSH
13996: LD_INT 6
13998: PUSH
13999: LD_INT 7
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: LIST
14006: PUSH
14007: LD_OWVAR 67
14011: ARRAY
14012: PPUSH
14013: CALL_OW 241
14017: GO 13985
14019: POP
14020: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 22
14028: PUSH
14029: LD_INT 3
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 30
14038: PUSH
14039: LD_INT 33
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: CALL_OW 69
14054: PUSH
14055: FOR_IN
14056: IFFALSE 14088
// PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
14058: LD_VAR 0 2
14062: PPUSH
14063: LD_VAR 0 4
14067: PUSH
14068: LD_VAR 0 2
14072: PUSH
14073: LD_INT 3
14075: MOD
14076: PUSH
14077: LD_INT 1
14079: PLUS
14080: ARRAY
14081: PPUSH
14082: CALL_OW 431
14086: GO 14055
14088: POP
14089: POP
// for i = 1 to 4 do
14090: LD_ADDR_VAR 0 2
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 4
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14165
// begin PrepareHuman ( false , class_bazooker , skill ) ;
14106: LD_INT 0
14108: PPUSH
14109: LD_INT 9
14111: PPUSH
14112: LD_VAR 0 5
14116: PPUSH
14117: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
14121: CALL_OW 44
14125: PPUSH
14126: LD_INT 22
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 30
14138: PUSH
14139: LD_INT 5
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PPUSH
14150: CALL_OW 69
14154: PUSH
14155: LD_INT 1
14157: ARRAY
14158: PPUSH
14159: CALL_OW 52
// end ;
14163: GO 14103
14165: POP
14166: POP
// for i = 1 to 5 do
14167: LD_ADDR_VAR 0 2
14171: PUSH
14172: DOUBLE
14173: LD_INT 1
14175: DEC
14176: ST_TO_ADDR
14177: LD_INT 5
14179: PUSH
14180: FOR_TO
14181: IFFALSE 14242
// begin PrepareHuman ( false , class_mechanic , skill ) ;
14183: LD_INT 0
14185: PPUSH
14186: LD_INT 3
14188: PPUSH
14189: LD_VAR 0 5
14193: PPUSH
14194: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
14198: CALL_OW 44
14202: PPUSH
14203: LD_INT 22
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 3
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 69
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: PPUSH
14236: CALL_OW 52
// end ;
14240: GO 14180
14242: POP
14243: POP
// for i = 1 to 4 do
14244: LD_ADDR_VAR 0 2
14248: PUSH
14249: DOUBLE
14250: LD_INT 1
14252: DEC
14253: ST_TO_ADDR
14254: LD_INT 4
14256: PUSH
14257: FOR_TO
14258: IFFALSE 14319
// begin PrepareHuman ( false , class_engineer , skill ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 2
14265: PPUSH
14266: LD_VAR 0 5
14270: PPUSH
14271: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_INT 22
14282: PUSH
14283: LD_INT 3
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: PUSH
14290: LD_INT 30
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: PPUSH
14304: CALL_OW 69
14308: PUSH
14309: LD_INT 1
14311: ARRAY
14312: PPUSH
14313: CALL_OW 52
// end ;
14317: GO 14257
14319: POP
14320: POP
// for i = 1 to 3 do
14321: LD_ADDR_VAR 0 2
14325: PUSH
14326: DOUBLE
14327: LD_INT 1
14329: DEC
14330: ST_TO_ADDR
14331: LD_INT 3
14333: PUSH
14334: FOR_TO
14335: IFFALSE 14368
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 4
14342: PPUSH
14343: LD_VAR 0 5
14347: PPUSH
14348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14352: CALL_OW 44
14356: PPUSH
14357: LD_VAR 0 6
14361: PPUSH
14362: CALL_OW 52
// end ;
14366: GO 14334
14368: POP
14369: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14370: LD_ADDR_EXP 37
14374: PUSH
14375: LD_STRING Yakotich
14377: PPUSH
14378: LD_EXP 2
14382: NOT
14383: PPUSH
14384: LD_STRING 
14386: PPUSH
14387: CALL 360 0 3
14391: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14392: LD_EXP 37
14396: PPUSH
14397: LD_INT 74
14399: PPUSH
14400: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14404: LD_VAR 0 6
14408: PPUSH
14409: LD_INT 49
14411: PPUSH
14412: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14416: LD_VAR 0 6
14420: PPUSH
14421: LD_INT 50
14423: PPUSH
14424: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14428: LD_VAR 0 6
14432: PPUSH
14433: LD_INT 51
14435: PPUSH
14436: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14440: LD_VAR 0 6
14444: PPUSH
14445: LD_INT 52
14447: PPUSH
14448: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14452: LD_VAR 0 6
14456: PPUSH
14457: LD_INT 69
14459: PPUSH
14460: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14464: LD_VAR 0 6
14468: PPUSH
14469: LD_INT 39
14471: PPUSH
14472: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14476: LD_VAR 0 6
14480: PPUSH
14481: LD_INT 34
14483: PPUSH
14484: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14488: LD_VAR 0 6
14492: PPUSH
14493: LD_INT 40
14495: PPUSH
14496: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14500: LD_VAR 0 6
14504: PPUSH
14505: LD_INT 57
14507: PPUSH
14508: CALL_OW 184
// if Difficulty > 1 then
14512: LD_OWVAR 67
14516: PUSH
14517: LD_INT 1
14519: GREATER
14520: IFFALSE 14534
// AddComResearch ( lab , tech_comp2 ) ;
14522: LD_VAR 0 6
14526: PPUSH
14527: LD_INT 58
14529: PPUSH
14530: CALL_OW 184
// end ;
14534: LD_VAR 0 1
14538: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14539: LD_INT 7
14541: PPUSH
14542: CALL_OW 353
14546: PUSH
14547: LD_INT 3
14549: GREATER
14550: PUSH
14551: LD_INT 22
14553: PUSH
14554: LD_INT 3
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PUSH
14561: LD_INT 34
14563: PUSH
14564: LD_INT 53
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: PPUSH
14575: CALL_OW 69
14579: NOT
14580: AND
14581: IFFALSE 14616
14583: GO 14585
14585: DISABLE
// begin enable ;
14586: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14587: LD_ADDR_EXP 40
14591: PUSH
14592: LD_EXP 40
14596: PUSH
14597: LD_INT 24
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 3
14605: PUSH
14606: LD_INT 53
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ADD
14615: ST_TO_ADDR
// end ;
14616: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14617: LD_INT 22
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 3
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: IFFALSE 15423
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
14658: PPUSH
14659: PPUSH
// begin enable ;
14660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14661: LD_ADDR_VAR 0 3
14665: PUSH
14666: LD_INT 22
14668: PUSH
14669: LD_INT 3
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 21
14678: PUSH
14679: LD_INT 3
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 3
14688: PUSH
14689: LD_INT 24
14691: PUSH
14692: LD_INT 1000
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14713: LD_ADDR_VAR 0 4
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: LD_INT 25
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PPUSH
14742: CALL_OW 69
14746: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14747: LD_ADDR_VAR 0 5
14751: PUSH
14752: LD_INT 22
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 30
14764: PUSH
14765: LD_INT 1
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PPUSH
14776: CALL_OW 69
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14785: LD_ADDR_VAR 0 8
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 3
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 6
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 30
14815: PUSH
14816: LD_INT 7
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 30
14825: PUSH
14826: LD_INT 8
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 1
14850: ARRAY
14851: ST_TO_ADDR
// if not engs then
14852: LD_VAR 0 4
14856: NOT
14857: IFFALSE 14861
// exit ;
14859: GO 15423
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14861: LD_ADDR_VAR 0 6
14865: PUSH
14866: LD_VAR 0 4
14870: PPUSH
14871: LD_INT 3
14873: PUSH
14874: LD_INT 24
14876: PUSH
14877: LD_INT 600
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 72
14892: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14893: LD_ADDR_VAR 0 7
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 3
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 4
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14927: LD_VAR 0 3
14931: NOT
14932: PUSH
14933: LD_EXP 39
14937: NOT
14938: AND
14939: IFFALSE 14999
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14941: LD_VAR 0 4
14945: PPUSH
14946: LD_INT 3
14948: PUSH
14949: LD_INT 54
14951: PUSH
14952: EMPTY
14953: LIST
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PPUSH
14959: CALL_OW 72
14963: IFFALSE 14997
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14965: LD_VAR 0 4
14969: PPUSH
14970: LD_INT 3
14972: PUSH
14973: LD_INT 54
14975: PUSH
14976: EMPTY
14977: LIST
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: CALL_OW 72
14987: PPUSH
14988: LD_VAR 0 5
14992: PPUSH
14993: CALL_OW 120
// exit ;
14997: GO 15423
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14999: LD_VAR 0 4
15003: PPUSH
15004: LD_INT 54
15006: PUSH
15007: EMPTY
15008: LIST
15009: PPUSH
15010: CALL_OW 72
15014: IFFALSE 15036
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
15016: LD_VAR 0 4
15020: PPUSH
15021: LD_INT 54
15023: PUSH
15024: EMPTY
15025: LIST
15026: PPUSH
15027: CALL_OW 72
15031: PPUSH
15032: CALL_OW 122
// if not tmp then
15036: LD_VAR 0 3
15040: NOT
15041: IFFALSE 15173
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
15043: LD_INT 81
15045: PUSH
15046: LD_INT 3
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 92
15055: PUSH
15056: LD_INT 147
15058: PUSH
15059: LD_INT 212
15061: PUSH
15062: LD_INT 30
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PPUSH
15075: CALL_OW 69
15079: NOT
15080: IFFALSE 15173
// begin if not HasTask ( engs [ 1 ] ) then
15082: LD_VAR 0 4
15086: PUSH
15087: LD_INT 1
15089: ARRAY
15090: PPUSH
15091: CALL_OW 314
15095: NOT
15096: IFFALSE 15173
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
15098: LD_ADDR_VAR 0 2
15102: PUSH
15103: LD_VAR 0 4
15107: PPUSH
15108: LD_EXP 39
15112: PUSH
15113: LD_INT 1
15115: ARRAY
15116: PPUSH
15117: LD_EXP 39
15121: PUSH
15122: LD_INT 2
15124: ARRAY
15125: PPUSH
15126: LD_EXP 39
15130: PUSH
15131: LD_INT 3
15133: ARRAY
15134: PPUSH
15135: LD_EXP 39
15139: PUSH
15140: LD_INT 4
15142: ARRAY
15143: PPUSH
15144: CALL_OW 145
15148: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
15149: LD_VAR 0 2
15153: PPUSH
15154: CALL_OW 266
15158: PUSH
15159: LD_INT 4
15161: EQUAL
15162: IFFALSE 15173
// AddComUpgrade ( i ) ;
15164: LD_VAR 0 2
15168: PPUSH
15169: CALL_OW 206
// end ; end ; end ; for i in engs do
15173: LD_ADDR_VAR 0 2
15177: PUSH
15178: LD_VAR 0 4
15182: PUSH
15183: FOR_IN
15184: IFFALSE 15302
// begin if i in to_heal and sci then
15186: LD_VAR 0 2
15190: PUSH
15191: LD_VAR 0 6
15195: IN
15196: PUSH
15197: LD_VAR 0 7
15201: AND
15202: IFFALSE 15253
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
15204: LD_VAR 0 2
15208: PPUSH
15209: LD_INT 149
15211: PPUSH
15212: LD_INT 220
15214: PPUSH
15215: CALL_OW 297
15219: PUSH
15220: LD_INT 5
15222: LESS
15223: IFFALSE 15227
// continue ;
15225: GO 15183
// ComMoveXY ( i , 149 , 220 ) ;
15227: LD_VAR 0 2
15231: PPUSH
15232: LD_INT 149
15234: PPUSH
15235: LD_INT 220
15237: PPUSH
15238: CALL_OW 111
// AddComHold ( i ) ;
15242: LD_VAR 0 2
15246: PPUSH
15247: CALL_OW 200
// end else
15251: GO 15300
// if not HasTask ( i ) or WantsToAttack ( i ) then
15253: LD_VAR 0 2
15257: PPUSH
15258: CALL_OW 314
15262: NOT
15263: PUSH
15264: LD_VAR 0 2
15268: PPUSH
15269: CALL_OW 319
15273: OR
15274: IFFALSE 15300
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15276: LD_VAR 0 2
15280: PPUSH
15281: LD_VAR 0 3
15285: PPUSH
15286: LD_VAR 0 2
15290: PPUSH
15291: CALL_OW 74
15295: PPUSH
15296: CALL_OW 130
// end ;
15300: GO 15183
15302: POP
15303: POP
// if to_heal and sci then
15304: LD_VAR 0 6
15308: PUSH
15309: LD_VAR 0 7
15313: AND
15314: IFFALSE 15375
// begin if UnitFilter ( sci , [ f_inside ] ) then
15316: LD_VAR 0 7
15320: PPUSH
15321: LD_INT 54
15323: PUSH
15324: EMPTY
15325: LIST
15326: PPUSH
15327: CALL_OW 72
15331: IFFALSE 15355
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15333: LD_VAR 0 7
15337: PPUSH
15338: LD_INT 54
15340: PUSH
15341: EMPTY
15342: LIST
15343: PPUSH
15344: CALL_OW 72
15348: PPUSH
15349: CALL_OW 122
15353: GO 15373
// ComHeal ( sci , to_heal [ 1 ] ) ;
15355: LD_VAR 0 7
15359: PPUSH
15360: LD_VAR 0 6
15364: PUSH
15365: LD_INT 1
15367: ARRAY
15368: PPUSH
15369: CALL_OW 128
// end else
15373: GO 15423
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 56
15382: PUSH
15383: EMPTY
15384: LIST
15385: PPUSH
15386: CALL_OW 72
15390: PUSH
15391: LD_VAR 0 8
15395: AND
15396: IFFALSE 15423
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15398: LD_VAR 0 7
15402: PPUSH
15403: LD_INT 56
15405: PUSH
15406: EMPTY
15407: LIST
15408: PPUSH
15409: CALL_OW 72
15413: PPUSH
15414: LD_VAR 0 8
15418: PPUSH
15419: CALL_OW 120
// end ;
15423: PPOPN 8
15425: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15426: LD_INT 22
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PPUSH
15450: CALL_OW 69
15454: PUSH
15455: LD_EXP 40
15459: AND
15460: IFFALSE 15586
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
15468: PPUSH
15469: PPUSH
// begin enable ;
15470: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 22
15478: PUSH
15479: LD_INT 3
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: LD_INT 30
15488: PUSH
15489: LD_INT 3
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PPUSH
15500: CALL_OW 69
15504: PUSH
15505: LD_INT 1
15507: ARRAY
15508: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15509: LD_VAR 0 3
15513: PPUSH
15514: CALL_OW 313
15518: PUSH
15519: LD_INT 0
15521: EQUAL
15522: IFFALSE 15526
// exit ;
15524: GO 15586
// if BuildingStatus ( fac ) = bs_idle then
15526: LD_VAR 0 3
15530: PPUSH
15531: CALL_OW 461
15535: PUSH
15536: LD_INT 2
15538: EQUAL
15539: IFFALSE 15586
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_EXP 40
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_EXP 40
15559: PUSH
15560: LD_INT 2
15562: ARRAY
15563: PPUSH
15564: LD_EXP 40
15568: PUSH
15569: LD_INT 3
15571: ARRAY
15572: PPUSH
15573: LD_EXP 40
15577: PUSH
15578: LD_INT 4
15580: ARRAY
15581: PPUSH
15582: CALL_OW 125
// end ;
15586: PPOPN 3
15588: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15589: LD_INT 0
15591: PPUSH
15592: PPUSH
15593: PPUSH
15594: PPUSH
15595: PPUSH
// uc_side := 3 ;
15596: LD_ADDR_OWVAR 20
15600: PUSH
15601: LD_INT 3
15603: ST_TO_ADDR
// uc_nation := 3 ;
15604: LD_ADDR_OWVAR 21
15608: PUSH
15609: LD_INT 3
15611: ST_TO_ADDR
// ru_can_attack := false ;
15612: LD_ADDR_EXP 8
15616: PUSH
15617: LD_INT 0
15619: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15620: LD_ADDR_VAR 0 6
15624: PUSH
15625: LD_INT 22
15627: PUSH
15628: LD_INT 3
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: LD_INT 30
15637: PUSH
15638: LD_INT 3
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL_OW 69
15653: ST_TO_ADDR
// if fac then
15654: LD_VAR 0 6
15658: IFFALSE 15810
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15660: LD_ADDR_EXP 40
15664: PUSH
15665: LD_INT 24
15667: PUSH
15668: LD_INT 1
15670: PUSH
15671: LD_INT 3
15673: PUSH
15674: LD_INT 43
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: ST_TO_ADDR
// if wave > 1 then
15683: LD_VAR 0 1
15687: PUSH
15688: LD_INT 1
15690: GREATER
15691: IFFALSE 15744
// for i = 1 to Difficulty do
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: DOUBLE
15699: LD_INT 1
15701: DEC
15702: ST_TO_ADDR
15703: LD_OWVAR 67
15707: PUSH
15708: FOR_TO
15709: IFFALSE 15742
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15711: LD_ADDR_EXP 40
15715: PUSH
15716: LD_EXP 40
15720: PUSH
15721: LD_INT 24
15723: PUSH
15724: LD_INT 1
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: LD_INT 45
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: LIST
15737: LIST
15738: ADD
15739: ST_TO_ADDR
15740: GO 15708
15742: POP
15743: POP
// repeat wait ( 0 0$1 ) ;
15744: LD_INT 35
15746: PPUSH
15747: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15751: LD_EXP 40
15755: PUSH
15756: LD_INT 4
15758: LESS
15759: PUSH
15760: LD_VAR 0 6
15764: PUSH
15765: LD_INT 1
15767: ARRAY
15768: PPUSH
15769: CALL_OW 313
15773: PUSH
15774: LD_INT 0
15776: EQUAL
15777: OR
15778: PUSH
15779: LD_VAR 0 6
15783: PUSH
15784: LD_INT 1
15786: ARRAY
15787: PPUSH
15788: CALL_OW 461
15792: PUSH
15793: LD_INT 8
15795: PUSH
15796: LD_INT 6
15798: PUSH
15799: LD_INT 7
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: IN
15807: OR
15808: IFFALSE 15744
// end ; case wave of 1 :
15810: LD_VAR 0 1
15814: PUSH
15815: LD_INT 1
15817: DOUBLE
15818: EQUAL
15819: IFTRUE 15823
15821: GO 15908
15823: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15824: LD_ADDR_VAR 0 3
15828: PUSH
15829: DOUBLE
15830: LD_INT 1
15832: DEC
15833: ST_TO_ADDR
15834: LD_INT 2
15836: PUSH
15837: LD_INT 3
15839: PUSH
15840: LD_INT 4
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: LIST
15847: PUSH
15848: LD_OWVAR 67
15852: ARRAY
15853: PUSH
15854: FOR_TO
15855: IFFALSE 15863
// Sold ;
15857: CALL 16134 0 0
15861: GO 15854
15863: POP
15864: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15865: LD_ADDR_VAR 0 3
15869: PUSH
15870: DOUBLE
15871: LD_INT 1
15873: DEC
15874: ST_TO_ADDR
15875: LD_INT 2
15877: PUSH
15878: LD_INT 3
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: PUSH
15889: LD_OWVAR 67
15893: ARRAY
15894: PUSH
15895: FOR_TO
15896: IFFALSE 15904
// Tank ;
15898: CALL 16264 0 0
15902: GO 15895
15904: POP
15905: POP
// end ; 2 .. 9 :
15906: GO 16121
15908: LD_INT 2
15910: DOUBLE
15911: GREATEREQUAL
15912: IFFALSE 15920
15914: LD_INT 9
15916: DOUBLE
15917: LESSEQUAL
15918: IFTRUE 15922
15920: GO 16027
15922: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15923: LD_ADDR_VAR 0 3
15927: PUSH
15928: DOUBLE
15929: LD_INT 1
15931: DEC
15932: ST_TO_ADDR
15933: LD_INT 2
15935: PUSH
15936: LD_INT 4
15938: PUSH
15939: LD_INT 5
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: PUSH
15947: LD_OWVAR 67
15951: ARRAY
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: LD_INT 2
15960: DIV
15961: PLUS
15962: PUSH
15963: FOR_TO
15964: IFFALSE 15972
// Sold ;
15966: CALL 16134 0 0
15970: GO 15963
15972: POP
15973: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15974: LD_ADDR_VAR 0 3
15978: PUSH
15979: DOUBLE
15980: LD_INT 1
15982: DEC
15983: ST_TO_ADDR
15984: LD_INT 2
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: PUSH
15998: LD_OWVAR 67
16002: ARRAY
16003: PUSH
16004: LD_VAR 0 1
16008: PUSH
16009: LD_INT 2
16011: DIV
16012: PLUS
16013: PUSH
16014: FOR_TO
16015: IFFALSE 16023
// Tank ;
16017: CALL 16264 0 0
16021: GO 16014
16023: POP
16024: POP
// end ; 10 :
16025: GO 16121
16027: LD_INT 10
16029: DOUBLE
16030: EQUAL
16031: IFTRUE 16035
16033: GO 16120
16035: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
16036: LD_ADDR_VAR 0 3
16040: PUSH
16041: DOUBLE
16042: LD_INT 1
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 10
16048: PUSH
16049: LD_INT 12
16051: PUSH
16052: LD_INT 14
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: PUSH
16060: LD_OWVAR 67
16064: ARRAY
16065: PUSH
16066: FOR_TO
16067: IFFALSE 16075
// Sold ;
16069: CALL 16134 0 0
16073: GO 16066
16075: POP
16076: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
16077: LD_ADDR_VAR 0 3
16081: PUSH
16082: DOUBLE
16083: LD_INT 1
16085: DEC
16086: ST_TO_ADDR
16087: LD_INT 11
16089: PUSH
16090: LD_INT 13
16092: PUSH
16093: LD_INT 15
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: LIST
16100: PUSH
16101: LD_OWVAR 67
16105: ARRAY
16106: PUSH
16107: FOR_TO
16108: IFFALSE 16116
// Tank ;
16110: CALL 16264 0 0
16114: GO 16107
16116: POP
16117: POP
// end ; end ;
16118: GO 16121
16120: POP
// ru_can_attack := true ;
16121: LD_ADDR_EXP 8
16125: PUSH
16126: LD_INT 1
16128: ST_TO_ADDR
// end ;
16129: LD_VAR 0 2
16133: RET
// function Sold ( ) ; var un , skill ; begin
16134: LD_INT 0
16136: PPUSH
16137: PPUSH
16138: PPUSH
// uc_side := 3 ;
16139: LD_ADDR_OWVAR 20
16143: PUSH
16144: LD_INT 3
16146: ST_TO_ADDR
// uc_nation := 3 ;
16147: LD_ADDR_OWVAR 21
16151: PUSH
16152: LD_INT 3
16154: ST_TO_ADDR
// InitHc ;
16155: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16159: LD_ADDR_VAR 0 3
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 6
16169: PUSH
16170: LD_INT 7
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: PUSH
16178: LD_OWVAR 67
16182: ARRAY
16183: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
16184: LD_INT 0
16186: PPUSH
16187: LD_INT 1
16189: PUSH
16190: LD_INT 9
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: LD_INT 1
16199: PPUSH
16200: LD_INT 2
16202: PPUSH
16203: CALL_OW 12
16207: ARRAY
16208: PPUSH
16209: LD_VAR 0 3
16213: PPUSH
16214: CALL_OW 380
// un := CreateHuman ;
16218: LD_ADDR_VAR 0 2
16222: PUSH
16223: CALL_OW 44
16227: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: LD_INT 4
16235: PPUSH
16236: LD_INT 0
16238: PPUSH
16239: CALL_OW 49
// ru_force := ru_force ^ un ;
16243: LD_ADDR_EXP 38
16247: PUSH
16248: LD_EXP 38
16252: PUSH
16253: LD_VAR 0 2
16257: ADD
16258: ST_TO_ADDR
// end ;
16259: LD_VAR 0 1
16263: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16264: LD_INT 0
16266: PPUSH
16267: PPUSH
16268: PPUSH
16269: PPUSH
16270: PPUSH
// uc_side := 3 ;
16271: LD_ADDR_OWVAR 20
16275: PUSH
16276: LD_INT 3
16278: ST_TO_ADDR
// uc_nation := 3 ;
16279: LD_ADDR_OWVAR 21
16283: PUSH
16284: LD_INT 3
16286: ST_TO_ADDR
// InitHc ;
16287: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16291: LD_ADDR_VAR 0 5
16295: PUSH
16296: LD_INT 5
16298: PUSH
16299: LD_INT 6
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: LIST
16309: PUSH
16310: LD_OWVAR 67
16314: ARRAY
16315: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16316: LD_ADDR_VAR 0 3
16320: PUSH
16321: LD_INT 22
16323: PUSH
16324: LD_INT 24
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: LD_INT 1
16333: PPUSH
16334: LD_INT 2
16336: PPUSH
16337: CALL_OW 12
16341: ARRAY
16342: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16343: LD_VAR 0 3
16347: PUSH
16348: LD_INT 22
16350: EQUAL
16351: IFFALSE 16386
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16353: LD_ADDR_VAR 0 4
16357: PUSH
16358: LD_INT 45
16360: PUSH
16361: LD_INT 43
16363: PUSH
16364: LD_INT 44
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 1
16374: PPUSH
16375: LD_INT 3
16377: PPUSH
16378: CALL_OW 12
16382: ARRAY
16383: ST_TO_ADDR
16384: GO 16417
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16386: LD_ADDR_VAR 0 4
16390: PUSH
16391: LD_INT 46
16393: PUSH
16394: LD_INT 44
16396: PUSH
16397: LD_INT 45
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 3
16410: PPUSH
16411: CALL_OW 12
16415: ARRAY
16416: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 3
16427: PPUSH
16428: LD_VAR 0 3
16432: PPUSH
16433: LD_INT 1
16435: PPUSH
16436: LD_INT 3
16438: PUSH
16439: LD_INT 3
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: LD_INT 1
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_INT 4
16459: PPUSH
16460: CALL_OW 12
16464: ARRAY
16465: PPUSH
16466: LD_VAR 0 4
16470: PPUSH
16471: LD_INT 99
16473: PPUSH
16474: CALL 423 0 7
16478: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 263
16488: PUSH
16489: LD_INT 1
16491: EQUAL
16492: IFFALSE 16523
// begin PrepareHuman ( false , 3 , skill ) ;
16494: LD_INT 0
16496: PPUSH
16497: LD_INT 3
16499: PPUSH
16500: LD_VAR 0 5
16504: PPUSH
16505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16509: CALL_OW 44
16513: PPUSH
16514: LD_VAR 0 2
16518: PPUSH
16519: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16523: LD_VAR 0 2
16527: PPUSH
16528: LD_INT 3
16530: PPUSH
16531: LD_INT 0
16533: PPUSH
16534: CALL_OW 49
// ru_force := ru_force ^ un ;
16538: LD_ADDR_EXP 38
16542: PUSH
16543: LD_EXP 38
16547: PUSH
16548: LD_VAR 0 2
16552: ADD
16553: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16554: LD_VAR 0 2
16558: PPUSH
16559: LD_INT 126
16561: PPUSH
16562: LD_INT 158
16564: PPUSH
16565: CALL_OW 111
// Wait ( 0 0$3 ) ;
16569: LD_INT 105
16571: PPUSH
16572: CALL_OW 67
// ComStop ( un ) ;
16576: LD_VAR 0 2
16580: PPUSH
16581: CALL_OW 141
// end ;
16585: LD_VAR 0 1
16589: RET
// every 0 0$1 do var i , time , wave ;
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16598: LD_ADDR_VAR 0 2
16602: PUSH
16603: LD_INT 25200
16605: PUSH
16606: LD_INT 24150
16608: PUSH
16609: LD_INT 23100
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: LD_OWVAR 67
16621: ARRAY
16622: ST_TO_ADDR
// wait ( time ) ;
16623: LD_VAR 0 2
16627: PPUSH
16628: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16632: LD_ADDR_VAR 0 2
16636: PUSH
16637: LD_INT 15750
16639: PUSH
16640: LD_INT 15400
16642: PUSH
16643: LD_INT 15050
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: LIST
16650: PUSH
16651: LD_OWVAR 67
16655: ARRAY
16656: ST_TO_ADDR
// wave := 0 ;
16657: LD_ADDR_VAR 0 3
16661: PUSH
16662: LD_INT 0
16664: ST_TO_ADDR
// while true do
16665: LD_INT 1
16667: IFFALSE 16771
// begin wave := wave + 1 ;
16669: LD_ADDR_VAR 0 3
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_INT 1
16681: PLUS
16682: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16683: LD_INT 22
16685: PUSH
16686: LD_INT 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: IFFALSE 16733
// begin repeat wait ( 0 0$1 ) ;
16699: LD_INT 35
16701: PPUSH
16702: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16706: LD_INT 22
16708: PUSH
16709: LD_INT 2
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: PPUSH
16716: CALL_OW 69
16720: PUSH
16721: LD_INT 0
16723: EQUAL
16724: IFFALSE 16699
// wait ( 1 1$30 ) ;
16726: LD_INT 3150
16728: PPUSH
16729: CALL_OW 67
// end ; if ru_force < 20 then
16733: LD_EXP 38
16737: PUSH
16738: LD_INT 20
16740: LESS
16741: IFFALSE 16752
// PrepareAttack ( wave ) ;
16743: LD_VAR 0 3
16747: PPUSH
16748: CALL 15589 0 1
// ru_can_attack := true ;
16752: LD_ADDR_EXP 8
16756: PUSH
16757: LD_INT 1
16759: ST_TO_ADDR
// wait ( time ) ;
16760: LD_VAR 0 2
16764: PPUSH
16765: CALL_OW 67
// end ;
16769: GO 16665
// end ;
16771: PPOPN 3
16773: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16774: LD_EXP 8
16778: PUSH
16779: LD_EXP 38
16783: AND
16784: IFFALSE 17618
16786: GO 16788
16788: DISABLE
16789: LD_INT 0
16791: PPUSH
16792: PPUSH
16793: PPUSH
16794: PPUSH
16795: PPUSH
16796: PPUSH
16797: PPUSH
16798: PPUSH
16799: PPUSH
// begin enable ;
16800: ENABLE
// points1 := [ 107 , 123 ] ;
16801: LD_ADDR_VAR 0 4
16805: PUSH
16806: LD_INT 107
16808: PUSH
16809: LD_INT 123
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: LD_INT 55
16823: PUSH
16824: LD_INT 42
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16831: LD_ADDR_VAR 0 6
16835: PUSH
16836: LD_INT 102
16838: PUSH
16839: LD_INT 140
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PUSH
16846: LD_INT 105
16848: PUSH
16849: LD_INT 142
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 129
16858: PUSH
16859: LD_INT 131
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: ST_TO_ADDR
// for i in ru_force do
16871: LD_ADDR_VAR 0 1
16875: PUSH
16876: LD_EXP 38
16880: PUSH
16881: FOR_IN
16882: IFFALSE 17616
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16884: LD_ADDR_VAR 0 3
16888: PUSH
16889: LD_INT 81
16891: PUSH
16892: LD_INT 3
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: PPUSH
16899: CALL_OW 69
16903: PPUSH
16904: LD_VAR 0 1
16908: PPUSH
16909: CALL_OW 74
16913: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16914: LD_VAR 0 1
16918: PPUSH
16919: LD_VAR 0 3
16923: PPUSH
16924: CALL_OW 296
16928: PUSH
16929: LD_INT 12
16931: LESS
16932: IFFALSE 17077
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16934: LD_VAR 0 1
16938: PPUSH
16939: CALL_OW 247
16943: PUSH
16944: LD_INT 1
16946: EQUAL
16947: PUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 257
16957: PUSH
16958: LD_INT 1
16960: EQUAL
16961: AND
16962: PUSH
16963: LD_VAR 0 3
16967: PUSH
16968: LD_INT 21
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 58
16980: PUSH
16981: EMPTY
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PPUSH
16988: CALL_OW 69
16992: IN
16993: AND
16994: IFFALSE 17012
// ComEnterUnit ( i , un ) else
16996: LD_VAR 0 1
17000: PPUSH
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 120
17010: GO 17075
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
17012: LD_VAR 0 3
17016: PUSH
17017: LD_INT 21
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 58
17029: PUSH
17030: EMPTY
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: PPUSH
17037: CALL_OW 69
17041: IN
17042: NOT
17043: IFFALSE 17061
// ComAttackUnit ( i , un ) else
17045: LD_VAR 0 1
17049: PPUSH
17050: LD_VAR 0 3
17054: PPUSH
17055: CALL_OW 115
17059: GO 17075
// ComAttackUnit ( i , JMM ) ;
17061: LD_VAR 0 1
17065: PPUSH
17066: LD_EXP 21
17070: PPUSH
17071: CALL_OW 115
// end else
17075: GO 17614
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
17077: LD_VAR 0 1
17081: PPUSH
17082: LD_VAR 0 4
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_VAR 0 4
17095: PUSH
17096: LD_INT 2
17098: ARRAY
17099: PPUSH
17100: CALL_OW 297
17104: PUSH
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 5
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 2
17126: ARRAY
17127: PPUSH
17128: CALL_OW 297
17132: GREATER
17133: PUSH
17134: LD_EXP 9
17138: AND
17139: PUSH
17140: LD_INT 9
17142: PPUSH
17143: LD_INT 81
17145: PUSH
17146: LD_INT 3
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PPUSH
17153: CALL_OW 70
17157: PUSH
17158: LD_INT 0
17160: EQUAL
17161: OR
17162: IFFALSE 17200
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
17164: LD_VAR 0 1
17168: PPUSH
17169: LD_INT 81
17171: PUSH
17172: LD_INT 3
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PPUSH
17179: CALL_OW 69
17183: PPUSH
17184: LD_VAR 0 1
17188: PPUSH
17189: CALL_OW 74
17193: PPUSH
17194: CALL_OW 115
17198: GO 17614
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 264
17209: PUSH
17210: LD_INT 45
17212: EQUAL
17213: PUSH
17214: LD_EXP 38
17218: PPUSH
17219: LD_INT 3
17221: PUSH
17222: LD_INT 34
17224: PUSH
17225: LD_INT 45
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PPUSH
17236: CALL_OW 72
17240: PUSH
17241: LD_INT 6
17243: GREATER
17244: AND
17245: IFFALSE 17426
// begin dist := 9999 ;
17247: LD_ADDR_VAR 0 8
17251: PUSH
17252: LD_INT 9999
17254: ST_TO_ADDR
// xy := 0 ;
17255: LD_ADDR_VAR 0 9
17259: PUSH
17260: LD_INT 0
17262: ST_TO_ADDR
// for x in pointsr do
17263: LD_ADDR_VAR 0 7
17267: PUSH
17268: LD_VAR 0 6
17272: PUSH
17273: FOR_IN
17274: IFFALSE 17422
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17276: LD_VAR 0 1
17280: PPUSH
17281: LD_VAR 0 7
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: LD_VAR 0 7
17294: PUSH
17295: LD_INT 2
17297: ARRAY
17298: PPUSH
17299: CALL_OW 297
17303: PUSH
17304: LD_VAR 0 8
17308: LESS
17309: IFFALSE 17354
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17311: LD_ADDR_VAR 0 8
17315: PUSH
17316: LD_VAR 0 1
17320: PPUSH
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: LD_VAR 0 7
17334: PUSH
17335: LD_INT 2
17337: ARRAY
17338: PPUSH
17339: CALL_OW 297
17343: ST_TO_ADDR
// xy := x ;
17344: LD_ADDR_VAR 0 9
17348: PUSH
17349: LD_VAR 0 7
17353: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17354: LD_VAR 0 9
17358: PUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: LD_VAR 0 9
17368: PUSH
17369: LD_INT 1
17371: ARRAY
17372: PPUSH
17373: LD_VAR 0 9
17377: PUSH
17378: LD_INT 2
17380: ARRAY
17381: PPUSH
17382: CALL_OW 297
17386: PUSH
17387: LD_INT 9
17389: GREATER
17390: AND
17391: IFFALSE 17420
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17393: LD_VAR 0 1
17397: PPUSH
17398: LD_VAR 0 9
17402: PUSH
17403: LD_INT 1
17405: ARRAY
17406: PPUSH
17407: LD_VAR 0 9
17411: PUSH
17412: LD_INT 2
17414: ARRAY
17415: PPUSH
17416: CALL_OW 114
// end ;
17420: GO 17273
17422: POP
17423: POP
// end else
17424: GO 17614
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_OWVAR 3
17435: PUSH
17436: LD_VAR 0 1
17440: DIFF
17441: PPUSH
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 74
17451: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 320
17461: NOT
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_INT 21
17470: PUSH
17471: LD_INT 2
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PUSH
17478: LD_INT 33
17480: PUSH
17481: LD_INT 1
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: LD_INT 58
17490: PUSH
17491: EMPTY
17492: LIST
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: PPUSH
17499: CALL_OW 69
17503: IN
17504: PUSH
17505: LD_VAR 0 3
17509: PUSH
17510: LD_INT 22
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: EMPTY
17517: LIST
17518: LIST
17519: PUSH
17520: LD_INT 21
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: PUSH
17530: LD_INT 3
17532: PUSH
17533: LD_INT 24
17535: PUSH
17536: LD_INT 249
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 69
17556: IN
17557: OR
17558: AND
17559: IFFALSE 17577
// ComAttackUnit ( i , un ) else
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_VAR 0 3
17570: PPUSH
17571: CALL_OW 115
17575: GO 17614
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17577: LD_VAR 0 1
17581: PPUSH
17582: LD_INT 9
17584: PPUSH
17585: LD_INT 81
17587: PUSH
17588: LD_INT 3
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 70
17599: PPUSH
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL_OW 74
17609: PPUSH
17610: CALL_OW 115
// end ; end ; end ; end ;
17614: GO 16881
17616: POP
17617: POP
// end ;
17618: PPOPN 9
17620: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17621: LD_INT 22
17623: PUSH
17624: LD_INT 3
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 32
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: IFFALSE 17737
17651: GO 17653
17653: DISABLE
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// begin enable ;
17658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17659: LD_ADDR_VAR 0 2
17663: PUSH
17664: LD_INT 22
17666: PUSH
17667: LD_INT 3
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: LD_INT 32
17676: PUSH
17677: LD_INT 1
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PPUSH
17688: CALL_OW 69
17692: ST_TO_ADDR
// for i in tmp do
17693: LD_ADDR_VAR 0 1
17697: PUSH
17698: LD_VAR 0 2
17702: PUSH
17703: FOR_IN
17704: IFFALSE 17735
// if GetFuel ( i ) < 12 then
17706: LD_VAR 0 1
17710: PPUSH
17711: CALL_OW 261
17715: PUSH
17716: LD_INT 12
17718: LESS
17719: IFFALSE 17733
// SetFuel ( i , 12 ) ;
17721: LD_VAR 0 1
17725: PPUSH
17726: LD_INT 12
17728: PPUSH
17729: CALL_OW 240
17733: GO 17703
17735: POP
17736: POP
// end ;
17737: PPOPN 2
17739: END
// every 0 0$1 trigger can_end do
17740: LD_EXP 17
17744: IFFALSE 17767
17746: GO 17748
17748: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17749: LD_INT 3325
17751: PPUSH
17752: CALL_OW 67
// PrepareAttack ( 10 ) ;
17756: LD_INT 10
17758: PPUSH
17759: CALL 15589 0 1
// until false ;
17763: LD_INT 0
17765: IFFALSE 17749
// end ; end_of_file
17767: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17768: GO 17770
17770: DISABLE
// begin ru_radar := 98 ;
17771: LD_ADDR_EXP 41
17775: PUSH
17776: LD_INT 98
17778: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17779: LD_ADDR_EXP 42
17783: PUSH
17784: LD_INT 89
17786: ST_TO_ADDR
// us_hack := 99 ;
17787: LD_ADDR_EXP 43
17791: PUSH
17792: LD_INT 99
17794: ST_TO_ADDR
// us_artillery := 97 ;
17795: LD_ADDR_EXP 44
17799: PUSH
17800: LD_INT 97
17802: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17803: LD_ADDR_EXP 45
17807: PUSH
17808: LD_INT 91
17810: ST_TO_ADDR
// end ; end_of_file end_of_file
17811: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
17812: GO 17814
17814: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
17815: LD_STRING initStreamRollete();
17817: PPUSH
17818: CALL_OW 559
// InitStreamMode ;
17822: CALL 17831 0 0
// DefineStreamItems ( ) ;
17826: CALL 18271 0 0
// end ;
17830: END
// function InitStreamMode ; begin
17831: LD_INT 0
17833: PPUSH
// streamModeActive := false ;
17834: LD_ADDR_EXP 46
17838: PUSH
17839: LD_INT 0
17841: ST_TO_ADDR
// normalCounter := 26 ;
17842: LD_ADDR_EXP 47
17846: PUSH
17847: LD_INT 26
17849: ST_TO_ADDR
// hardcoreCounter := 12 ;
17850: LD_ADDR_EXP 48
17854: PUSH
17855: LD_INT 12
17857: ST_TO_ADDR
// sRocket := false ;
17858: LD_ADDR_EXP 51
17862: PUSH
17863: LD_INT 0
17865: ST_TO_ADDR
// sSpeed := false ;
17866: LD_ADDR_EXP 50
17870: PUSH
17871: LD_INT 0
17873: ST_TO_ADDR
// sEngine := false ;
17874: LD_ADDR_EXP 52
17878: PUSH
17879: LD_INT 0
17881: ST_TO_ADDR
// sSpec := false ;
17882: LD_ADDR_EXP 49
17886: PUSH
17887: LD_INT 0
17889: ST_TO_ADDR
// sLevel := false ;
17890: LD_ADDR_EXP 53
17894: PUSH
17895: LD_INT 0
17897: ST_TO_ADDR
// sArmoury := false ;
17898: LD_ADDR_EXP 54
17902: PUSH
17903: LD_INT 0
17905: ST_TO_ADDR
// sRadar := false ;
17906: LD_ADDR_EXP 55
17910: PUSH
17911: LD_INT 0
17913: ST_TO_ADDR
// sBunker := false ;
17914: LD_ADDR_EXP 56
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// sHack := false ;
17922: LD_ADDR_EXP 57
17926: PUSH
17927: LD_INT 0
17929: ST_TO_ADDR
// sFire := false ;
17930: LD_ADDR_EXP 58
17934: PUSH
17935: LD_INT 0
17937: ST_TO_ADDR
// sRefresh := false ;
17938: LD_ADDR_EXP 59
17942: PUSH
17943: LD_INT 0
17945: ST_TO_ADDR
// sExp := false ;
17946: LD_ADDR_EXP 60
17950: PUSH
17951: LD_INT 0
17953: ST_TO_ADDR
// sDepot := false ;
17954: LD_ADDR_EXP 61
17958: PUSH
17959: LD_INT 0
17961: ST_TO_ADDR
// sFlag := false ;
17962: LD_ADDR_EXP 62
17966: PUSH
17967: LD_INT 0
17969: ST_TO_ADDR
// sKamikadze := false ;
17970: LD_ADDR_EXP 70
17974: PUSH
17975: LD_INT 0
17977: ST_TO_ADDR
// sTroll := false ;
17978: LD_ADDR_EXP 71
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// sSlow := false ;
17986: LD_ADDR_EXP 72
17990: PUSH
17991: LD_INT 0
17993: ST_TO_ADDR
// sLack := false ;
17994: LD_ADDR_EXP 73
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// sTank := false ;
18002: LD_ADDR_EXP 75
18006: PUSH
18007: LD_INT 0
18009: ST_TO_ADDR
// sRemote := false ;
18010: LD_ADDR_EXP 76
18014: PUSH
18015: LD_INT 0
18017: ST_TO_ADDR
// sPowell := false ;
18018: LD_ADDR_EXP 77
18022: PUSH
18023: LD_INT 0
18025: ST_TO_ADDR
// sTeleport := false ;
18026: LD_ADDR_EXP 80
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// sOilTower := false ;
18034: LD_ADDR_EXP 82
18038: PUSH
18039: LD_INT 0
18041: ST_TO_ADDR
// sShovel := false ;
18042: LD_ADDR_EXP 83
18046: PUSH
18047: LD_INT 0
18049: ST_TO_ADDR
// sSheik := false ;
18050: LD_ADDR_EXP 84
18054: PUSH
18055: LD_INT 0
18057: ST_TO_ADDR
// sEarthquake := false ;
18058: LD_ADDR_EXP 86
18062: PUSH
18063: LD_INT 0
18065: ST_TO_ADDR
// sAI := false ;
18066: LD_ADDR_EXP 87
18070: PUSH
18071: LD_INT 0
18073: ST_TO_ADDR
// sCargo := false ;
18074: LD_ADDR_EXP 90
18078: PUSH
18079: LD_INT 0
18081: ST_TO_ADDR
// sDLaser := false ;
18082: LD_ADDR_EXP 91
18086: PUSH
18087: LD_INT 0
18089: ST_TO_ADDR
// sExchange := false ;
18090: LD_ADDR_EXP 92
18094: PUSH
18095: LD_INT 0
18097: ST_TO_ADDR
// sFac := false ;
18098: LD_ADDR_EXP 93
18102: PUSH
18103: LD_INT 0
18105: ST_TO_ADDR
// sPower := false ;
18106: LD_ADDR_EXP 94
18110: PUSH
18111: LD_INT 0
18113: ST_TO_ADDR
// sRandom := false ;
18114: LD_ADDR_EXP 95
18118: PUSH
18119: LD_INT 0
18121: ST_TO_ADDR
// sShield := false ;
18122: LD_ADDR_EXP 96
18126: PUSH
18127: LD_INT 0
18129: ST_TO_ADDR
// sTime := false ;
18130: LD_ADDR_EXP 97
18134: PUSH
18135: LD_INT 0
18137: ST_TO_ADDR
// sTools := false ;
18138: LD_ADDR_EXP 98
18142: PUSH
18143: LD_INT 0
18145: ST_TO_ADDR
// sSold := false ;
18146: LD_ADDR_EXP 63
18150: PUSH
18151: LD_INT 0
18153: ST_TO_ADDR
// sDiff := false ;
18154: LD_ADDR_EXP 64
18158: PUSH
18159: LD_INT 0
18161: ST_TO_ADDR
// sFog := false ;
18162: LD_ADDR_EXP 67
18166: PUSH
18167: LD_INT 0
18169: ST_TO_ADDR
// sReset := false ;
18170: LD_ADDR_EXP 68
18174: PUSH
18175: LD_INT 0
18177: ST_TO_ADDR
// sSun := false ;
18178: LD_ADDR_EXP 69
18182: PUSH
18183: LD_INT 0
18185: ST_TO_ADDR
// sTiger := false ;
18186: LD_ADDR_EXP 65
18190: PUSH
18191: LD_INT 0
18193: ST_TO_ADDR
// sBomb := false ;
18194: LD_ADDR_EXP 66
18198: PUSH
18199: LD_INT 0
18201: ST_TO_ADDR
// sWound := false ;
18202: LD_ADDR_EXP 74
18206: PUSH
18207: LD_INT 0
18209: ST_TO_ADDR
// sBetray := false ;
18210: LD_ADDR_EXP 78
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// sContamin := false ;
18218: LD_ADDR_EXP 79
18222: PUSH
18223: LD_INT 0
18225: ST_TO_ADDR
// sOil := false ;
18226: LD_ADDR_EXP 81
18230: PUSH
18231: LD_INT 0
18233: ST_TO_ADDR
// sStu := false ;
18234: LD_ADDR_EXP 85
18238: PUSH
18239: LD_INT 0
18241: ST_TO_ADDR
// sBazooka := false ;
18242: LD_ADDR_EXP 88
18246: PUSH
18247: LD_INT 0
18249: ST_TO_ADDR
// sMortar := false ;
18250: LD_ADDR_EXP 89
18254: PUSH
18255: LD_INT 0
18257: ST_TO_ADDR
// sRanger := false ;
18258: LD_ADDR_EXP 99
18262: PUSH
18263: LD_INT 0
18265: ST_TO_ADDR
// end ;
18266: LD_VAR 0 1
18270: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
18271: LD_INT 0
18273: PPUSH
18274: PPUSH
18275: PPUSH
18276: PPUSH
18277: PPUSH
// result := [ ] ;
18278: LD_ADDR_VAR 0 1
18282: PUSH
18283: EMPTY
18284: ST_TO_ADDR
// if campaign_id = 1 then
18285: LD_OWVAR 69
18289: PUSH
18290: LD_INT 1
18292: EQUAL
18293: IFFALSE 21241
// begin case mission_number of 1 :
18295: LD_OWVAR 70
18299: PUSH
18300: LD_INT 1
18302: DOUBLE
18303: EQUAL
18304: IFTRUE 18308
18306: GO 18372
18308: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
18309: LD_ADDR_VAR 0 1
18313: PUSH
18314: LD_INT 2
18316: PUSH
18317: LD_INT 4
18319: PUSH
18320: LD_INT 11
18322: PUSH
18323: LD_INT 12
18325: PUSH
18326: LD_INT 15
18328: PUSH
18329: LD_INT 16
18331: PUSH
18332: LD_INT 22
18334: PUSH
18335: LD_INT 23
18337: PUSH
18338: LD_INT 26
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: LIST
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 101
18354: PUSH
18355: LD_INT 102
18357: PUSH
18358: LD_INT 106
18360: PUSH
18361: EMPTY
18362: LIST
18363: LIST
18364: LIST
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: ST_TO_ADDR
18370: GO 21241
18372: LD_INT 2
18374: DOUBLE
18375: EQUAL
18376: IFTRUE 18380
18378: GO 18452
18380: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
18381: LD_ADDR_VAR 0 1
18385: PUSH
18386: LD_INT 2
18388: PUSH
18389: LD_INT 4
18391: PUSH
18392: LD_INT 11
18394: PUSH
18395: LD_INT 12
18397: PUSH
18398: LD_INT 15
18400: PUSH
18401: LD_INT 16
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 23
18409: PUSH
18410: LD_INT 26
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: LD_INT 101
18426: PUSH
18427: LD_INT 102
18429: PUSH
18430: LD_INT 105
18432: PUSH
18433: LD_INT 106
18435: PUSH
18436: LD_INT 108
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: ST_TO_ADDR
18450: GO 21241
18452: LD_INT 3
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18536
18460: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
18461: LD_ADDR_VAR 0 1
18465: PUSH
18466: LD_INT 2
18468: PUSH
18469: LD_INT 4
18471: PUSH
18472: LD_INT 5
18474: PUSH
18475: LD_INT 11
18477: PUSH
18478: LD_INT 12
18480: PUSH
18481: LD_INT 15
18483: PUSH
18484: LD_INT 16
18486: PUSH
18487: LD_INT 22
18489: PUSH
18490: LD_INT 26
18492: PUSH
18493: LD_INT 36
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: PUSH
18508: LD_INT 101
18510: PUSH
18511: LD_INT 102
18513: PUSH
18514: LD_INT 105
18516: PUSH
18517: LD_INT 106
18519: PUSH
18520: LD_INT 108
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: ST_TO_ADDR
18534: GO 21241
18536: LD_INT 4
18538: DOUBLE
18539: EQUAL
18540: IFTRUE 18544
18542: GO 18628
18544: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
18545: LD_ADDR_VAR 0 1
18549: PUSH
18550: LD_INT 2
18552: PUSH
18553: LD_INT 4
18555: PUSH
18556: LD_INT 5
18558: PUSH
18559: LD_INT 8
18561: PUSH
18562: LD_INT 11
18564: PUSH
18565: LD_INT 12
18567: PUSH
18568: LD_INT 15
18570: PUSH
18571: LD_INT 16
18573: PUSH
18574: LD_INT 22
18576: PUSH
18577: LD_INT 23
18579: PUSH
18580: LD_INT 26
18582: PUSH
18583: LD_INT 36
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: PUSH
18600: LD_INT 101
18602: PUSH
18603: LD_INT 102
18605: PUSH
18606: LD_INT 105
18608: PUSH
18609: LD_INT 106
18611: PUSH
18612: LD_INT 108
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: ST_TO_ADDR
18626: GO 21241
18628: LD_INT 5
18630: DOUBLE
18631: EQUAL
18632: IFTRUE 18636
18634: GO 18736
18636: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
18637: LD_ADDR_VAR 0 1
18641: PUSH
18642: LD_INT 2
18644: PUSH
18645: LD_INT 4
18647: PUSH
18648: LD_INT 5
18650: PUSH
18651: LD_INT 6
18653: PUSH
18654: LD_INT 8
18656: PUSH
18657: LD_INT 11
18659: PUSH
18660: LD_INT 12
18662: PUSH
18663: LD_INT 15
18665: PUSH
18666: LD_INT 16
18668: PUSH
18669: LD_INT 22
18671: PUSH
18672: LD_INT 23
18674: PUSH
18675: LD_INT 25
18677: PUSH
18678: LD_INT 26
18680: PUSH
18681: LD_INT 36
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: PUSH
18700: LD_INT 101
18702: PUSH
18703: LD_INT 102
18705: PUSH
18706: LD_INT 105
18708: PUSH
18709: LD_INT 106
18711: PUSH
18712: LD_INT 108
18714: PUSH
18715: LD_INT 109
18717: PUSH
18718: LD_INT 112
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: PUSH
18730: EMPTY
18731: LIST
18732: LIST
18733: ST_TO_ADDR
18734: GO 21241
18736: LD_INT 6
18738: DOUBLE
18739: EQUAL
18740: IFTRUE 18744
18742: GO 18864
18744: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
18745: LD_ADDR_VAR 0 1
18749: PUSH
18750: LD_INT 2
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: LD_INT 5
18758: PUSH
18759: LD_INT 6
18761: PUSH
18762: LD_INT 8
18764: PUSH
18765: LD_INT 11
18767: PUSH
18768: LD_INT 12
18770: PUSH
18771: LD_INT 15
18773: PUSH
18774: LD_INT 16
18776: PUSH
18777: LD_INT 20
18779: PUSH
18780: LD_INT 21
18782: PUSH
18783: LD_INT 22
18785: PUSH
18786: LD_INT 23
18788: PUSH
18789: LD_INT 25
18791: PUSH
18792: LD_INT 26
18794: PUSH
18795: LD_INT 30
18797: PUSH
18798: LD_INT 31
18800: PUSH
18801: LD_INT 32
18803: PUSH
18804: LD_INT 36
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: PUSH
18828: LD_INT 101
18830: PUSH
18831: LD_INT 102
18833: PUSH
18834: LD_INT 105
18836: PUSH
18837: LD_INT 106
18839: PUSH
18840: LD_INT 108
18842: PUSH
18843: LD_INT 109
18845: PUSH
18846: LD_INT 112
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: PUSH
18858: EMPTY
18859: LIST
18860: LIST
18861: ST_TO_ADDR
18862: GO 21241
18864: LD_INT 7
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18972
18872: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
18873: LD_ADDR_VAR 0 1
18877: PUSH
18878: LD_INT 2
18880: PUSH
18881: LD_INT 4
18883: PUSH
18884: LD_INT 5
18886: PUSH
18887: LD_INT 7
18889: PUSH
18890: LD_INT 11
18892: PUSH
18893: LD_INT 12
18895: PUSH
18896: LD_INT 15
18898: PUSH
18899: LD_INT 16
18901: PUSH
18902: LD_INT 20
18904: PUSH
18905: LD_INT 21
18907: PUSH
18908: LD_INT 22
18910: PUSH
18911: LD_INT 23
18913: PUSH
18914: LD_INT 25
18916: PUSH
18917: LD_INT 26
18919: PUSH
18920: EMPTY
18921: LIST
18922: LIST
18923: LIST
18924: LIST
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: PUSH
18936: LD_INT 101
18938: PUSH
18939: LD_INT 102
18941: PUSH
18942: LD_INT 103
18944: PUSH
18945: LD_INT 105
18947: PUSH
18948: LD_INT 106
18950: PUSH
18951: LD_INT 108
18953: PUSH
18954: LD_INT 112
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: PUSH
18966: EMPTY
18967: LIST
18968: LIST
18969: ST_TO_ADDR
18970: GO 21241
18972: LD_INT 8
18974: DOUBLE
18975: EQUAL
18976: IFTRUE 18980
18978: GO 19108
18980: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
18981: LD_ADDR_VAR 0 1
18985: PUSH
18986: LD_INT 2
18988: PUSH
18989: LD_INT 4
18991: PUSH
18992: LD_INT 5
18994: PUSH
18995: LD_INT 6
18997: PUSH
18998: LD_INT 7
19000: PUSH
19001: LD_INT 8
19003: PUSH
19004: LD_INT 11
19006: PUSH
19007: LD_INT 12
19009: PUSH
19010: LD_INT 15
19012: PUSH
19013: LD_INT 16
19015: PUSH
19016: LD_INT 20
19018: PUSH
19019: LD_INT 21
19021: PUSH
19022: LD_INT 22
19024: PUSH
19025: LD_INT 23
19027: PUSH
19028: LD_INT 25
19030: PUSH
19031: LD_INT 26
19033: PUSH
19034: LD_INT 30
19036: PUSH
19037: LD_INT 31
19039: PUSH
19040: LD_INT 32
19042: PUSH
19043: LD_INT 36
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: LIST
19050: LIST
19051: LIST
19052: LIST
19053: LIST
19054: LIST
19055: LIST
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: LIST
19066: LIST
19067: PUSH
19068: LD_INT 101
19070: PUSH
19071: LD_INT 102
19073: PUSH
19074: LD_INT 103
19076: PUSH
19077: LD_INT 105
19079: PUSH
19080: LD_INT 106
19082: PUSH
19083: LD_INT 108
19085: PUSH
19086: LD_INT 109
19088: PUSH
19089: LD_INT 112
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: ST_TO_ADDR
19106: GO 21241
19108: LD_INT 9
19110: DOUBLE
19111: EQUAL
19112: IFTRUE 19116
19114: GO 19252
19116: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19117: LD_ADDR_VAR 0 1
19121: PUSH
19122: LD_INT 2
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: LD_INT 6
19133: PUSH
19134: LD_INT 7
19136: PUSH
19137: LD_INT 8
19139: PUSH
19140: LD_INT 11
19142: PUSH
19143: LD_INT 12
19145: PUSH
19146: LD_INT 15
19148: PUSH
19149: LD_INT 16
19151: PUSH
19152: LD_INT 20
19154: PUSH
19155: LD_INT 21
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_INT 23
19163: PUSH
19164: LD_INT 25
19166: PUSH
19167: LD_INT 26
19169: PUSH
19170: LD_INT 28
19172: PUSH
19173: LD_INT 30
19175: PUSH
19176: LD_INT 31
19178: PUSH
19179: LD_INT 32
19181: PUSH
19182: LD_INT 36
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: LIST
19195: LIST
19196: LIST
19197: LIST
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: LIST
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 101
19210: PUSH
19211: LD_INT 102
19213: PUSH
19214: LD_INT 103
19216: PUSH
19217: LD_INT 105
19219: PUSH
19220: LD_INT 106
19222: PUSH
19223: LD_INT 108
19225: PUSH
19226: LD_INT 109
19228: PUSH
19229: LD_INT 112
19231: PUSH
19232: LD_INT 114
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: LIST
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: LIST
19244: LIST
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: ST_TO_ADDR
19250: GO 21241
19252: LD_INT 10
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19444
19260: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
19261: LD_ADDR_VAR 0 1
19265: PUSH
19266: LD_INT 2
19268: PUSH
19269: LD_INT 4
19271: PUSH
19272: LD_INT 5
19274: PUSH
19275: LD_INT 6
19277: PUSH
19278: LD_INT 7
19280: PUSH
19281: LD_INT 8
19283: PUSH
19284: LD_INT 9
19286: PUSH
19287: LD_INT 10
19289: PUSH
19290: LD_INT 11
19292: PUSH
19293: LD_INT 12
19295: PUSH
19296: LD_INT 13
19298: PUSH
19299: LD_INT 14
19301: PUSH
19302: LD_INT 15
19304: PUSH
19305: LD_INT 16
19307: PUSH
19308: LD_INT 17
19310: PUSH
19311: LD_INT 18
19313: PUSH
19314: LD_INT 19
19316: PUSH
19317: LD_INT 20
19319: PUSH
19320: LD_INT 21
19322: PUSH
19323: LD_INT 22
19325: PUSH
19326: LD_INT 23
19328: PUSH
19329: LD_INT 24
19331: PUSH
19332: LD_INT 25
19334: PUSH
19335: LD_INT 26
19337: PUSH
19338: LD_INT 28
19340: PUSH
19341: LD_INT 30
19343: PUSH
19344: LD_INT 31
19346: PUSH
19347: LD_INT 32
19349: PUSH
19350: LD_INT 36
19352: PUSH
19353: EMPTY
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: LIST
19364: LIST
19365: LIST
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: LIST
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: PUSH
19384: LD_INT 101
19386: PUSH
19387: LD_INT 102
19389: PUSH
19390: LD_INT 103
19392: PUSH
19393: LD_INT 104
19395: PUSH
19396: LD_INT 105
19398: PUSH
19399: LD_INT 106
19401: PUSH
19402: LD_INT 107
19404: PUSH
19405: LD_INT 108
19407: PUSH
19408: LD_INT 109
19410: PUSH
19411: LD_INT 110
19413: PUSH
19414: LD_INT 111
19416: PUSH
19417: LD_INT 112
19419: PUSH
19420: LD_INT 114
19422: PUSH
19423: EMPTY
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: LIST
19437: PUSH
19438: EMPTY
19439: LIST
19440: LIST
19441: ST_TO_ADDR
19442: GO 21241
19444: LD_INT 11
19446: DOUBLE
19447: EQUAL
19448: IFTRUE 19452
19450: GO 19644
19452: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
19453: LD_ADDR_VAR 0 1
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: LD_INT 3
19463: PUSH
19464: LD_INT 4
19466: PUSH
19467: LD_INT 5
19469: PUSH
19470: LD_INT 6
19472: PUSH
19473: LD_INT 7
19475: PUSH
19476: LD_INT 8
19478: PUSH
19479: LD_INT 9
19481: PUSH
19482: LD_INT 10
19484: PUSH
19485: LD_INT 11
19487: PUSH
19488: LD_INT 12
19490: PUSH
19491: LD_INT 13
19493: PUSH
19494: LD_INT 14
19496: PUSH
19497: LD_INT 15
19499: PUSH
19500: LD_INT 16
19502: PUSH
19503: LD_INT 17
19505: PUSH
19506: LD_INT 18
19508: PUSH
19509: LD_INT 19
19511: PUSH
19512: LD_INT 20
19514: PUSH
19515: LD_INT 21
19517: PUSH
19518: LD_INT 22
19520: PUSH
19521: LD_INT 23
19523: PUSH
19524: LD_INT 24
19526: PUSH
19527: LD_INT 25
19529: PUSH
19530: LD_INT 26
19532: PUSH
19533: LD_INT 28
19535: PUSH
19536: LD_INT 30
19538: PUSH
19539: LD_INT 31
19541: PUSH
19542: LD_INT 32
19544: PUSH
19545: LD_INT 34
19547: PUSH
19548: LD_INT 36
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: LIST
19555: LIST
19556: LIST
19557: LIST
19558: LIST
19559: LIST
19560: LIST
19561: LIST
19562: LIST
19563: LIST
19564: LIST
19565: LIST
19566: LIST
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_INT 101
19586: PUSH
19587: LD_INT 102
19589: PUSH
19590: LD_INT 103
19592: PUSH
19593: LD_INT 104
19595: PUSH
19596: LD_INT 105
19598: PUSH
19599: LD_INT 106
19601: PUSH
19602: LD_INT 107
19604: PUSH
19605: LD_INT 108
19607: PUSH
19608: LD_INT 109
19610: PUSH
19611: LD_INT 110
19613: PUSH
19614: LD_INT 111
19616: PUSH
19617: LD_INT 112
19619: PUSH
19620: LD_INT 114
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: ST_TO_ADDR
19642: GO 21241
19644: LD_INT 12
19646: DOUBLE
19647: EQUAL
19648: IFTRUE 19652
19650: GO 19860
19652: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
19653: LD_ADDR_VAR 0 1
19657: PUSH
19658: LD_INT 1
19660: PUSH
19661: LD_INT 2
19663: PUSH
19664: LD_INT 3
19666: PUSH
19667: LD_INT 4
19669: PUSH
19670: LD_INT 5
19672: PUSH
19673: LD_INT 6
19675: PUSH
19676: LD_INT 7
19678: PUSH
19679: LD_INT 8
19681: PUSH
19682: LD_INT 9
19684: PUSH
19685: LD_INT 10
19687: PUSH
19688: LD_INT 11
19690: PUSH
19691: LD_INT 12
19693: PUSH
19694: LD_INT 13
19696: PUSH
19697: LD_INT 14
19699: PUSH
19700: LD_INT 15
19702: PUSH
19703: LD_INT 16
19705: PUSH
19706: LD_INT 17
19708: PUSH
19709: LD_INT 18
19711: PUSH
19712: LD_INT 19
19714: PUSH
19715: LD_INT 20
19717: PUSH
19718: LD_INT 21
19720: PUSH
19721: LD_INT 22
19723: PUSH
19724: LD_INT 23
19726: PUSH
19727: LD_INT 24
19729: PUSH
19730: LD_INT 25
19732: PUSH
19733: LD_INT 26
19735: PUSH
19736: LD_INT 27
19738: PUSH
19739: LD_INT 28
19741: PUSH
19742: LD_INT 30
19744: PUSH
19745: LD_INT 31
19747: PUSH
19748: LD_INT 32
19750: PUSH
19751: LD_INT 33
19753: PUSH
19754: LD_INT 34
19756: PUSH
19757: LD_INT 36
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: LIST
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: PUSH
19796: LD_INT 101
19798: PUSH
19799: LD_INT 102
19801: PUSH
19802: LD_INT 103
19804: PUSH
19805: LD_INT 104
19807: PUSH
19808: LD_INT 105
19810: PUSH
19811: LD_INT 106
19813: PUSH
19814: LD_INT 107
19816: PUSH
19817: LD_INT 108
19819: PUSH
19820: LD_INT 109
19822: PUSH
19823: LD_INT 110
19825: PUSH
19826: LD_INT 111
19828: PUSH
19829: LD_INT 112
19831: PUSH
19832: LD_INT 113
19834: PUSH
19835: LD_INT 114
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: ST_TO_ADDR
19858: GO 21241
19860: LD_INT 13
19862: DOUBLE
19863: EQUAL
19864: IFTRUE 19868
19866: GO 20076
19868: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
19869: LD_ADDR_VAR 0 1
19873: PUSH
19874: LD_INT 1
19876: PUSH
19877: LD_INT 2
19879: PUSH
19880: LD_INT 3
19882: PUSH
19883: LD_INT 4
19885: PUSH
19886: LD_INT 5
19888: PUSH
19889: LD_INT 6
19891: PUSH
19892: LD_INT 7
19894: PUSH
19895: LD_INT 8
19897: PUSH
19898: LD_INT 9
19900: PUSH
19901: LD_INT 10
19903: PUSH
19904: LD_INT 11
19906: PUSH
19907: LD_INT 12
19909: PUSH
19910: LD_INT 13
19912: PUSH
19913: LD_INT 14
19915: PUSH
19916: LD_INT 15
19918: PUSH
19919: LD_INT 16
19921: PUSH
19922: LD_INT 17
19924: PUSH
19925: LD_INT 18
19927: PUSH
19928: LD_INT 19
19930: PUSH
19931: LD_INT 20
19933: PUSH
19934: LD_INT 21
19936: PUSH
19937: LD_INT 22
19939: PUSH
19940: LD_INT 23
19942: PUSH
19943: LD_INT 24
19945: PUSH
19946: LD_INT 25
19948: PUSH
19949: LD_INT 26
19951: PUSH
19952: LD_INT 27
19954: PUSH
19955: LD_INT 28
19957: PUSH
19958: LD_INT 30
19960: PUSH
19961: LD_INT 31
19963: PUSH
19964: LD_INT 32
19966: PUSH
19967: LD_INT 33
19969: PUSH
19970: LD_INT 34
19972: PUSH
19973: LD_INT 36
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: PUSH
20012: LD_INT 101
20014: PUSH
20015: LD_INT 102
20017: PUSH
20018: LD_INT 103
20020: PUSH
20021: LD_INT 104
20023: PUSH
20024: LD_INT 105
20026: PUSH
20027: LD_INT 106
20029: PUSH
20030: LD_INT 107
20032: PUSH
20033: LD_INT 108
20035: PUSH
20036: LD_INT 109
20038: PUSH
20039: LD_INT 110
20041: PUSH
20042: LD_INT 111
20044: PUSH
20045: LD_INT 112
20047: PUSH
20048: LD_INT 113
20050: PUSH
20051: LD_INT 114
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: LIST
20060: LIST
20061: LIST
20062: LIST
20063: LIST
20064: LIST
20065: LIST
20066: LIST
20067: LIST
20068: LIST
20069: PUSH
20070: EMPTY
20071: LIST
20072: LIST
20073: ST_TO_ADDR
20074: GO 21241
20076: LD_INT 14
20078: DOUBLE
20079: EQUAL
20080: IFTRUE 20084
20082: GO 20296
20084: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20085: LD_ADDR_VAR 0 1
20089: PUSH
20090: LD_INT 1
20092: PUSH
20093: LD_INT 2
20095: PUSH
20096: LD_INT 3
20098: PUSH
20099: LD_INT 4
20101: PUSH
20102: LD_INT 5
20104: PUSH
20105: LD_INT 6
20107: PUSH
20108: LD_INT 7
20110: PUSH
20111: LD_INT 8
20113: PUSH
20114: LD_INT 9
20116: PUSH
20117: LD_INT 10
20119: PUSH
20120: LD_INT 11
20122: PUSH
20123: LD_INT 12
20125: PUSH
20126: LD_INT 13
20128: PUSH
20129: LD_INT 14
20131: PUSH
20132: LD_INT 15
20134: PUSH
20135: LD_INT 16
20137: PUSH
20138: LD_INT 17
20140: PUSH
20141: LD_INT 18
20143: PUSH
20144: LD_INT 19
20146: PUSH
20147: LD_INT 20
20149: PUSH
20150: LD_INT 21
20152: PUSH
20153: LD_INT 22
20155: PUSH
20156: LD_INT 23
20158: PUSH
20159: LD_INT 24
20161: PUSH
20162: LD_INT 25
20164: PUSH
20165: LD_INT 26
20167: PUSH
20168: LD_INT 27
20170: PUSH
20171: LD_INT 28
20173: PUSH
20174: LD_INT 29
20176: PUSH
20177: LD_INT 30
20179: PUSH
20180: LD_INT 31
20182: PUSH
20183: LD_INT 32
20185: PUSH
20186: LD_INT 33
20188: PUSH
20189: LD_INT 34
20191: PUSH
20192: LD_INT 36
20194: PUSH
20195: EMPTY
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: LIST
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: LIST
20229: LIST
20230: LIST
20231: PUSH
20232: LD_INT 101
20234: PUSH
20235: LD_INT 102
20237: PUSH
20238: LD_INT 103
20240: PUSH
20241: LD_INT 104
20243: PUSH
20244: LD_INT 105
20246: PUSH
20247: LD_INT 106
20249: PUSH
20250: LD_INT 107
20252: PUSH
20253: LD_INT 108
20255: PUSH
20256: LD_INT 109
20258: PUSH
20259: LD_INT 110
20261: PUSH
20262: LD_INT 111
20264: PUSH
20265: LD_INT 112
20267: PUSH
20268: LD_INT 113
20270: PUSH
20271: LD_INT 114
20273: PUSH
20274: EMPTY
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: LIST
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: ST_TO_ADDR
20294: GO 21241
20296: LD_INT 15
20298: DOUBLE
20299: EQUAL
20300: IFTRUE 20304
20302: GO 20516
20304: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
20305: LD_ADDR_VAR 0 1
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 2
20315: PUSH
20316: LD_INT 3
20318: PUSH
20319: LD_INT 4
20321: PUSH
20322: LD_INT 5
20324: PUSH
20325: LD_INT 6
20327: PUSH
20328: LD_INT 7
20330: PUSH
20331: LD_INT 8
20333: PUSH
20334: LD_INT 9
20336: PUSH
20337: LD_INT 10
20339: PUSH
20340: LD_INT 11
20342: PUSH
20343: LD_INT 12
20345: PUSH
20346: LD_INT 13
20348: PUSH
20349: LD_INT 14
20351: PUSH
20352: LD_INT 15
20354: PUSH
20355: LD_INT 16
20357: PUSH
20358: LD_INT 17
20360: PUSH
20361: LD_INT 18
20363: PUSH
20364: LD_INT 19
20366: PUSH
20367: LD_INT 20
20369: PUSH
20370: LD_INT 21
20372: PUSH
20373: LD_INT 22
20375: PUSH
20376: LD_INT 23
20378: PUSH
20379: LD_INT 24
20381: PUSH
20382: LD_INT 25
20384: PUSH
20385: LD_INT 26
20387: PUSH
20388: LD_INT 27
20390: PUSH
20391: LD_INT 28
20393: PUSH
20394: LD_INT 29
20396: PUSH
20397: LD_INT 30
20399: PUSH
20400: LD_INT 31
20402: PUSH
20403: LD_INT 32
20405: PUSH
20406: LD_INT 33
20408: PUSH
20409: LD_INT 34
20411: PUSH
20412: LD_INT 36
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: LIST
20448: LIST
20449: LIST
20450: LIST
20451: PUSH
20452: LD_INT 101
20454: PUSH
20455: LD_INT 102
20457: PUSH
20458: LD_INT 103
20460: PUSH
20461: LD_INT 104
20463: PUSH
20464: LD_INT 105
20466: PUSH
20467: LD_INT 106
20469: PUSH
20470: LD_INT 107
20472: PUSH
20473: LD_INT 108
20475: PUSH
20476: LD_INT 109
20478: PUSH
20479: LD_INT 110
20481: PUSH
20482: LD_INT 111
20484: PUSH
20485: LD_INT 112
20487: PUSH
20488: LD_INT 113
20490: PUSH
20491: LD_INT 114
20493: PUSH
20494: EMPTY
20495: LIST
20496: LIST
20497: LIST
20498: LIST
20499: LIST
20500: LIST
20501: LIST
20502: LIST
20503: LIST
20504: LIST
20505: LIST
20506: LIST
20507: LIST
20508: LIST
20509: PUSH
20510: EMPTY
20511: LIST
20512: LIST
20513: ST_TO_ADDR
20514: GO 21241
20516: LD_INT 16
20518: DOUBLE
20519: EQUAL
20520: IFTRUE 20524
20522: GO 20648
20524: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
20525: LD_ADDR_VAR 0 1
20529: PUSH
20530: LD_INT 2
20532: PUSH
20533: LD_INT 4
20535: PUSH
20536: LD_INT 5
20538: PUSH
20539: LD_INT 7
20541: PUSH
20542: LD_INT 11
20544: PUSH
20545: LD_INT 12
20547: PUSH
20548: LD_INT 15
20550: PUSH
20551: LD_INT 16
20553: PUSH
20554: LD_INT 20
20556: PUSH
20557: LD_INT 21
20559: PUSH
20560: LD_INT 22
20562: PUSH
20563: LD_INT 23
20565: PUSH
20566: LD_INT 25
20568: PUSH
20569: LD_INT 26
20571: PUSH
20572: LD_INT 30
20574: PUSH
20575: LD_INT 31
20577: PUSH
20578: LD_INT 32
20580: PUSH
20581: LD_INT 33
20583: PUSH
20584: LD_INT 34
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: PUSH
20608: LD_INT 101
20610: PUSH
20611: LD_INT 102
20613: PUSH
20614: LD_INT 103
20616: PUSH
20617: LD_INT 106
20619: PUSH
20620: LD_INT 108
20622: PUSH
20623: LD_INT 112
20625: PUSH
20626: LD_INT 113
20628: PUSH
20629: LD_INT 114
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: ST_TO_ADDR
20646: GO 21241
20648: LD_INT 17
20650: DOUBLE
20651: EQUAL
20652: IFTRUE 20656
20654: GO 20868
20656: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
20657: LD_ADDR_VAR 0 1
20661: PUSH
20662: LD_INT 1
20664: PUSH
20665: LD_INT 2
20667: PUSH
20668: LD_INT 3
20670: PUSH
20671: LD_INT 4
20673: PUSH
20674: LD_INT 5
20676: PUSH
20677: LD_INT 6
20679: PUSH
20680: LD_INT 7
20682: PUSH
20683: LD_INT 8
20685: PUSH
20686: LD_INT 9
20688: PUSH
20689: LD_INT 10
20691: PUSH
20692: LD_INT 11
20694: PUSH
20695: LD_INT 12
20697: PUSH
20698: LD_INT 13
20700: PUSH
20701: LD_INT 14
20703: PUSH
20704: LD_INT 15
20706: PUSH
20707: LD_INT 16
20709: PUSH
20710: LD_INT 17
20712: PUSH
20713: LD_INT 18
20715: PUSH
20716: LD_INT 19
20718: PUSH
20719: LD_INT 20
20721: PUSH
20722: LD_INT 21
20724: PUSH
20725: LD_INT 22
20727: PUSH
20728: LD_INT 23
20730: PUSH
20731: LD_INT 24
20733: PUSH
20734: LD_INT 25
20736: PUSH
20737: LD_INT 26
20739: PUSH
20740: LD_INT 27
20742: PUSH
20743: LD_INT 28
20745: PUSH
20746: LD_INT 29
20748: PUSH
20749: LD_INT 30
20751: PUSH
20752: LD_INT 31
20754: PUSH
20755: LD_INT 32
20757: PUSH
20758: LD_INT 33
20760: PUSH
20761: LD_INT 34
20763: PUSH
20764: LD_INT 36
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: LIST
20771: LIST
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: LIST
20777: LIST
20778: LIST
20779: LIST
20780: LIST
20781: LIST
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: PUSH
20804: LD_INT 101
20806: PUSH
20807: LD_INT 102
20809: PUSH
20810: LD_INT 103
20812: PUSH
20813: LD_INT 104
20815: PUSH
20816: LD_INT 105
20818: PUSH
20819: LD_INT 106
20821: PUSH
20822: LD_INT 107
20824: PUSH
20825: LD_INT 108
20827: PUSH
20828: LD_INT 109
20830: PUSH
20831: LD_INT 110
20833: PUSH
20834: LD_INT 111
20836: PUSH
20837: LD_INT 112
20839: PUSH
20840: LD_INT 113
20842: PUSH
20843: LD_INT 114
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: LIST
20850: LIST
20851: LIST
20852: LIST
20853: LIST
20854: LIST
20855: LIST
20856: LIST
20857: LIST
20858: LIST
20859: LIST
20860: LIST
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: ST_TO_ADDR
20866: GO 21241
20868: LD_INT 18
20870: DOUBLE
20871: EQUAL
20872: IFTRUE 20876
20874: GO 21012
20876: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
20877: LD_ADDR_VAR 0 1
20881: PUSH
20882: LD_INT 2
20884: PUSH
20885: LD_INT 4
20887: PUSH
20888: LD_INT 5
20890: PUSH
20891: LD_INT 7
20893: PUSH
20894: LD_INT 11
20896: PUSH
20897: LD_INT 12
20899: PUSH
20900: LD_INT 15
20902: PUSH
20903: LD_INT 16
20905: PUSH
20906: LD_INT 20
20908: PUSH
20909: LD_INT 21
20911: PUSH
20912: LD_INT 22
20914: PUSH
20915: LD_INT 23
20917: PUSH
20918: LD_INT 25
20920: PUSH
20921: LD_INT 26
20923: PUSH
20924: LD_INT 30
20926: PUSH
20927: LD_INT 31
20929: PUSH
20930: LD_INT 32
20932: PUSH
20933: LD_INT 33
20935: PUSH
20936: LD_INT 34
20938: PUSH
20939: LD_INT 35
20941: PUSH
20942: LD_INT 36
20944: PUSH
20945: EMPTY
20946: LIST
20947: LIST
20948: LIST
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: LIST
20954: LIST
20955: LIST
20956: LIST
20957: LIST
20958: LIST
20959: LIST
20960: LIST
20961: LIST
20962: LIST
20963: LIST
20964: LIST
20965: LIST
20966: LIST
20967: PUSH
20968: LD_INT 101
20970: PUSH
20971: LD_INT 102
20973: PUSH
20974: LD_INT 103
20976: PUSH
20977: LD_INT 106
20979: PUSH
20980: LD_INT 108
20982: PUSH
20983: LD_INT 112
20985: PUSH
20986: LD_INT 113
20988: PUSH
20989: LD_INT 114
20991: PUSH
20992: LD_INT 115
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: LIST
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: ST_TO_ADDR
21010: GO 21241
21012: LD_INT 19
21014: DOUBLE
21015: EQUAL
21016: IFTRUE 21020
21018: GO 21240
21020: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21021: LD_ADDR_VAR 0 1
21025: PUSH
21026: LD_INT 1
21028: PUSH
21029: LD_INT 2
21031: PUSH
21032: LD_INT 3
21034: PUSH
21035: LD_INT 4
21037: PUSH
21038: LD_INT 5
21040: PUSH
21041: LD_INT 6
21043: PUSH
21044: LD_INT 7
21046: PUSH
21047: LD_INT 8
21049: PUSH
21050: LD_INT 9
21052: PUSH
21053: LD_INT 10
21055: PUSH
21056: LD_INT 11
21058: PUSH
21059: LD_INT 12
21061: PUSH
21062: LD_INT 13
21064: PUSH
21065: LD_INT 14
21067: PUSH
21068: LD_INT 15
21070: PUSH
21071: LD_INT 16
21073: PUSH
21074: LD_INT 17
21076: PUSH
21077: LD_INT 18
21079: PUSH
21080: LD_INT 19
21082: PUSH
21083: LD_INT 20
21085: PUSH
21086: LD_INT 21
21088: PUSH
21089: LD_INT 22
21091: PUSH
21092: LD_INT 23
21094: PUSH
21095: LD_INT 24
21097: PUSH
21098: LD_INT 25
21100: PUSH
21101: LD_INT 26
21103: PUSH
21104: LD_INT 27
21106: PUSH
21107: LD_INT 28
21109: PUSH
21110: LD_INT 29
21112: PUSH
21113: LD_INT 30
21115: PUSH
21116: LD_INT 31
21118: PUSH
21119: LD_INT 32
21121: PUSH
21122: LD_INT 33
21124: PUSH
21125: LD_INT 34
21127: PUSH
21128: LD_INT 35
21130: PUSH
21131: LD_INT 36
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: LIST
21138: LIST
21139: LIST
21140: LIST
21141: LIST
21142: LIST
21143: LIST
21144: LIST
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: PUSH
21172: LD_INT 101
21174: PUSH
21175: LD_INT 102
21177: PUSH
21178: LD_INT 103
21180: PUSH
21181: LD_INT 104
21183: PUSH
21184: LD_INT 105
21186: PUSH
21187: LD_INT 106
21189: PUSH
21190: LD_INT 107
21192: PUSH
21193: LD_INT 108
21195: PUSH
21196: LD_INT 109
21198: PUSH
21199: LD_INT 110
21201: PUSH
21202: LD_INT 111
21204: PUSH
21205: LD_INT 112
21207: PUSH
21208: LD_INT 113
21210: PUSH
21211: LD_INT 114
21213: PUSH
21214: LD_INT 115
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: LIST
21221: LIST
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: ST_TO_ADDR
21238: GO 21241
21240: POP
// end ; if result then
21241: LD_VAR 0 1
21245: IFFALSE 21534
// begin normal :=  ;
21247: LD_ADDR_VAR 0 3
21251: PUSH
21252: LD_STRING 
21254: ST_TO_ADDR
// hardcore :=  ;
21255: LD_ADDR_VAR 0 4
21259: PUSH
21260: LD_STRING 
21262: ST_TO_ADDR
// for i = 1 to normalCounter do
21263: LD_ADDR_VAR 0 5
21267: PUSH
21268: DOUBLE
21269: LD_INT 1
21271: DEC
21272: ST_TO_ADDR
21273: LD_EXP 47
21277: PUSH
21278: FOR_TO
21279: IFFALSE 21380
// begin tmp := 0 ;
21281: LD_ADDR_VAR 0 2
21285: PUSH
21286: LD_STRING 0
21288: ST_TO_ADDR
// if result [ 1 ] then
21289: LD_VAR 0 1
21293: PUSH
21294: LD_INT 1
21296: ARRAY
21297: IFFALSE 21362
// if result [ 1 ] [ 1 ] = i then
21299: LD_VAR 0 1
21303: PUSH
21304: LD_INT 1
21306: ARRAY
21307: PUSH
21308: LD_INT 1
21310: ARRAY
21311: PUSH
21312: LD_VAR 0 5
21316: EQUAL
21317: IFFALSE 21362
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
21319: LD_ADDR_VAR 0 1
21323: PUSH
21324: LD_VAR 0 1
21328: PPUSH
21329: LD_INT 1
21331: PPUSH
21332: LD_VAR 0 1
21336: PUSH
21337: LD_INT 1
21339: ARRAY
21340: PPUSH
21341: LD_INT 1
21343: PPUSH
21344: CALL_OW 3
21348: PPUSH
21349: CALL_OW 1
21353: ST_TO_ADDR
// tmp := 1 ;
21354: LD_ADDR_VAR 0 2
21358: PUSH
21359: LD_STRING 1
21361: ST_TO_ADDR
// end ; normal := normal & tmp ;
21362: LD_ADDR_VAR 0 3
21366: PUSH
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 2
21376: STR
21377: ST_TO_ADDR
// end ;
21378: GO 21278
21380: POP
21381: POP
// for i = 1 to hardcoreCounter do
21382: LD_ADDR_VAR 0 5
21386: PUSH
21387: DOUBLE
21388: LD_INT 1
21390: DEC
21391: ST_TO_ADDR
21392: LD_EXP 48
21396: PUSH
21397: FOR_TO
21398: IFFALSE 21503
// begin tmp := 0 ;
21400: LD_ADDR_VAR 0 2
21404: PUSH
21405: LD_STRING 0
21407: ST_TO_ADDR
// if result [ 2 ] then
21408: LD_VAR 0 1
21412: PUSH
21413: LD_INT 2
21415: ARRAY
21416: IFFALSE 21485
// if result [ 2 ] [ 1 ] = 100 + i then
21418: LD_VAR 0 1
21422: PUSH
21423: LD_INT 2
21425: ARRAY
21426: PUSH
21427: LD_INT 1
21429: ARRAY
21430: PUSH
21431: LD_INT 100
21433: PUSH
21434: LD_VAR 0 5
21438: PLUS
21439: EQUAL
21440: IFFALSE 21485
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
21442: LD_ADDR_VAR 0 1
21446: PUSH
21447: LD_VAR 0 1
21451: PPUSH
21452: LD_INT 2
21454: PPUSH
21455: LD_VAR 0 1
21459: PUSH
21460: LD_INT 2
21462: ARRAY
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: CALL_OW 3
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// tmp := 1 ;
21477: LD_ADDR_VAR 0 2
21481: PUSH
21482: LD_STRING 1
21484: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
21485: LD_ADDR_VAR 0 4
21489: PUSH
21490: LD_VAR 0 4
21494: PUSH
21495: LD_VAR 0 2
21499: STR
21500: ST_TO_ADDR
// end ;
21501: GO 21397
21503: POP
21504: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
21505: LD_STRING getStreamItemsFromMission("
21507: PUSH
21508: LD_VAR 0 3
21512: STR
21513: PUSH
21514: LD_STRING ","
21516: STR
21517: PUSH
21518: LD_VAR 0 4
21522: STR
21523: PUSH
21524: LD_STRING ")
21526: STR
21527: PPUSH
21528: CALL_OW 559
// end else
21532: GO 21541
// ToLua ( getStreamItemsFromMission("","") ) ;
21534: LD_STRING getStreamItemsFromMission("","")
21536: PPUSH
21537: CALL_OW 559
// end ;
21541: LD_VAR 0 1
21545: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
21546: LD_VAR 0 2
21550: PUSH
21551: LD_INT 100
21553: EQUAL
21554: IFFALSE 22503
// begin if not StreamModeActive then
21556: LD_EXP 46
21560: NOT
21561: IFFALSE 21571
// StreamModeActive := true ;
21563: LD_ADDR_EXP 46
21567: PUSH
21568: LD_INT 1
21570: ST_TO_ADDR
// if p3 = 0 then
21571: LD_VAR 0 3
21575: PUSH
21576: LD_INT 0
21578: EQUAL
21579: IFFALSE 21585
// InitStreamMode ;
21581: CALL 17831 0 0
// if p3 = 1 then
21585: LD_VAR 0 3
21589: PUSH
21590: LD_INT 1
21592: EQUAL
21593: IFFALSE 21603
// sRocket := true ;
21595: LD_ADDR_EXP 51
21599: PUSH
21600: LD_INT 1
21602: ST_TO_ADDR
// if p3 = 2 then
21603: LD_VAR 0 3
21607: PUSH
21608: LD_INT 2
21610: EQUAL
21611: IFFALSE 21621
// sSpeed := true ;
21613: LD_ADDR_EXP 50
21617: PUSH
21618: LD_INT 1
21620: ST_TO_ADDR
// if p3 = 3 then
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 3
21628: EQUAL
21629: IFFALSE 21639
// sEngine := true ;
21631: LD_ADDR_EXP 52
21635: PUSH
21636: LD_INT 1
21638: ST_TO_ADDR
// if p3 = 4 then
21639: LD_VAR 0 3
21643: PUSH
21644: LD_INT 4
21646: EQUAL
21647: IFFALSE 21657
// sSpec := true ;
21649: LD_ADDR_EXP 49
21653: PUSH
21654: LD_INT 1
21656: ST_TO_ADDR
// if p3 = 5 then
21657: LD_VAR 0 3
21661: PUSH
21662: LD_INT 5
21664: EQUAL
21665: IFFALSE 21675
// sLevel := true ;
21667: LD_ADDR_EXP 53
21671: PUSH
21672: LD_INT 1
21674: ST_TO_ADDR
// if p3 = 6 then
21675: LD_VAR 0 3
21679: PUSH
21680: LD_INT 6
21682: EQUAL
21683: IFFALSE 21693
// sArmoury := true ;
21685: LD_ADDR_EXP 54
21689: PUSH
21690: LD_INT 1
21692: ST_TO_ADDR
// if p3 = 7 then
21693: LD_VAR 0 3
21697: PUSH
21698: LD_INT 7
21700: EQUAL
21701: IFFALSE 21711
// sRadar := true ;
21703: LD_ADDR_EXP 55
21707: PUSH
21708: LD_INT 1
21710: ST_TO_ADDR
// if p3 = 8 then
21711: LD_VAR 0 3
21715: PUSH
21716: LD_INT 8
21718: EQUAL
21719: IFFALSE 21729
// sBunker := true ;
21721: LD_ADDR_EXP 56
21725: PUSH
21726: LD_INT 1
21728: ST_TO_ADDR
// if p3 = 9 then
21729: LD_VAR 0 3
21733: PUSH
21734: LD_INT 9
21736: EQUAL
21737: IFFALSE 21747
// sHack := true ;
21739: LD_ADDR_EXP 57
21743: PUSH
21744: LD_INT 1
21746: ST_TO_ADDR
// if p3 = 10 then
21747: LD_VAR 0 3
21751: PUSH
21752: LD_INT 10
21754: EQUAL
21755: IFFALSE 21765
// sFire := true ;
21757: LD_ADDR_EXP 58
21761: PUSH
21762: LD_INT 1
21764: ST_TO_ADDR
// if p3 = 11 then
21765: LD_VAR 0 3
21769: PUSH
21770: LD_INT 11
21772: EQUAL
21773: IFFALSE 21783
// sRefresh := true ;
21775: LD_ADDR_EXP 59
21779: PUSH
21780: LD_INT 1
21782: ST_TO_ADDR
// if p3 = 12 then
21783: LD_VAR 0 3
21787: PUSH
21788: LD_INT 12
21790: EQUAL
21791: IFFALSE 21801
// sExp := true ;
21793: LD_ADDR_EXP 60
21797: PUSH
21798: LD_INT 1
21800: ST_TO_ADDR
// if p3 = 13 then
21801: LD_VAR 0 3
21805: PUSH
21806: LD_INT 13
21808: EQUAL
21809: IFFALSE 21819
// sDepot := true ;
21811: LD_ADDR_EXP 61
21815: PUSH
21816: LD_INT 1
21818: ST_TO_ADDR
// if p3 = 14 then
21819: LD_VAR 0 3
21823: PUSH
21824: LD_INT 14
21826: EQUAL
21827: IFFALSE 21837
// sFlag := true ;
21829: LD_ADDR_EXP 62
21833: PUSH
21834: LD_INT 1
21836: ST_TO_ADDR
// if p3 = 15 then
21837: LD_VAR 0 3
21841: PUSH
21842: LD_INT 15
21844: EQUAL
21845: IFFALSE 21855
// sKamikadze := true ;
21847: LD_ADDR_EXP 70
21851: PUSH
21852: LD_INT 1
21854: ST_TO_ADDR
// if p3 = 16 then
21855: LD_VAR 0 3
21859: PUSH
21860: LD_INT 16
21862: EQUAL
21863: IFFALSE 21873
// sTroll := true ;
21865: LD_ADDR_EXP 71
21869: PUSH
21870: LD_INT 1
21872: ST_TO_ADDR
// if p3 = 17 then
21873: LD_VAR 0 3
21877: PUSH
21878: LD_INT 17
21880: EQUAL
21881: IFFALSE 21891
// sSlow := true ;
21883: LD_ADDR_EXP 72
21887: PUSH
21888: LD_INT 1
21890: ST_TO_ADDR
// if p3 = 18 then
21891: LD_VAR 0 3
21895: PUSH
21896: LD_INT 18
21898: EQUAL
21899: IFFALSE 21909
// sLack := true ;
21901: LD_ADDR_EXP 73
21905: PUSH
21906: LD_INT 1
21908: ST_TO_ADDR
// if p3 = 19 then
21909: LD_VAR 0 3
21913: PUSH
21914: LD_INT 19
21916: EQUAL
21917: IFFALSE 21927
// sTank := true ;
21919: LD_ADDR_EXP 75
21923: PUSH
21924: LD_INT 1
21926: ST_TO_ADDR
// if p3 = 20 then
21927: LD_VAR 0 3
21931: PUSH
21932: LD_INT 20
21934: EQUAL
21935: IFFALSE 21945
// sRemote := true ;
21937: LD_ADDR_EXP 76
21941: PUSH
21942: LD_INT 1
21944: ST_TO_ADDR
// if p3 = 21 then
21945: LD_VAR 0 3
21949: PUSH
21950: LD_INT 21
21952: EQUAL
21953: IFFALSE 21963
// sPowell := true ;
21955: LD_ADDR_EXP 77
21959: PUSH
21960: LD_INT 1
21962: ST_TO_ADDR
// if p3 = 22 then
21963: LD_VAR 0 3
21967: PUSH
21968: LD_INT 22
21970: EQUAL
21971: IFFALSE 21981
// sTeleport := true ;
21973: LD_ADDR_EXP 80
21977: PUSH
21978: LD_INT 1
21980: ST_TO_ADDR
// if p3 = 23 then
21981: LD_VAR 0 3
21985: PUSH
21986: LD_INT 23
21988: EQUAL
21989: IFFALSE 21999
// sOilTower := true ;
21991: LD_ADDR_EXP 82
21995: PUSH
21996: LD_INT 1
21998: ST_TO_ADDR
// if p3 = 24 then
21999: LD_VAR 0 3
22003: PUSH
22004: LD_INT 24
22006: EQUAL
22007: IFFALSE 22017
// sShovel := true ;
22009: LD_ADDR_EXP 83
22013: PUSH
22014: LD_INT 1
22016: ST_TO_ADDR
// if p3 = 25 then
22017: LD_VAR 0 3
22021: PUSH
22022: LD_INT 25
22024: EQUAL
22025: IFFALSE 22035
// sSheik := true ;
22027: LD_ADDR_EXP 84
22031: PUSH
22032: LD_INT 1
22034: ST_TO_ADDR
// if p3 = 26 then
22035: LD_VAR 0 3
22039: PUSH
22040: LD_INT 26
22042: EQUAL
22043: IFFALSE 22053
// sEarthquake := true ;
22045: LD_ADDR_EXP 86
22049: PUSH
22050: LD_INT 1
22052: ST_TO_ADDR
// if p3 = 27 then
22053: LD_VAR 0 3
22057: PUSH
22058: LD_INT 27
22060: EQUAL
22061: IFFALSE 22071
// sAI := true ;
22063: LD_ADDR_EXP 87
22067: PUSH
22068: LD_INT 1
22070: ST_TO_ADDR
// if p3 = 28 then
22071: LD_VAR 0 3
22075: PUSH
22076: LD_INT 28
22078: EQUAL
22079: IFFALSE 22089
// sCargo := true ;
22081: LD_ADDR_EXP 90
22085: PUSH
22086: LD_INT 1
22088: ST_TO_ADDR
// if p3 = 29 then
22089: LD_VAR 0 3
22093: PUSH
22094: LD_INT 29
22096: EQUAL
22097: IFFALSE 22107
// sDLaser := true ;
22099: LD_ADDR_EXP 91
22103: PUSH
22104: LD_INT 1
22106: ST_TO_ADDR
// if p3 = 30 then
22107: LD_VAR 0 3
22111: PUSH
22112: LD_INT 30
22114: EQUAL
22115: IFFALSE 22125
// sExchange := true ;
22117: LD_ADDR_EXP 92
22121: PUSH
22122: LD_INT 1
22124: ST_TO_ADDR
// if p3 = 31 then
22125: LD_VAR 0 3
22129: PUSH
22130: LD_INT 31
22132: EQUAL
22133: IFFALSE 22143
// sFac := true ;
22135: LD_ADDR_EXP 93
22139: PUSH
22140: LD_INT 1
22142: ST_TO_ADDR
// if p3 = 32 then
22143: LD_VAR 0 3
22147: PUSH
22148: LD_INT 32
22150: EQUAL
22151: IFFALSE 22161
// sPower := true ;
22153: LD_ADDR_EXP 94
22157: PUSH
22158: LD_INT 1
22160: ST_TO_ADDR
// if p3 = 33 then
22161: LD_VAR 0 3
22165: PUSH
22166: LD_INT 33
22168: EQUAL
22169: IFFALSE 22179
// sRandom := true ;
22171: LD_ADDR_EXP 95
22175: PUSH
22176: LD_INT 1
22178: ST_TO_ADDR
// if p3 = 34 then
22179: LD_VAR 0 3
22183: PUSH
22184: LD_INT 34
22186: EQUAL
22187: IFFALSE 22197
// sShield := true ;
22189: LD_ADDR_EXP 96
22193: PUSH
22194: LD_INT 1
22196: ST_TO_ADDR
// if p3 = 35 then
22197: LD_VAR 0 3
22201: PUSH
22202: LD_INT 35
22204: EQUAL
22205: IFFALSE 22215
// sTime := true ;
22207: LD_ADDR_EXP 97
22211: PUSH
22212: LD_INT 1
22214: ST_TO_ADDR
// if p3 = 36 then
22215: LD_VAR 0 3
22219: PUSH
22220: LD_INT 36
22222: EQUAL
22223: IFFALSE 22233
// sTools := true ;
22225: LD_ADDR_EXP 98
22229: PUSH
22230: LD_INT 1
22232: ST_TO_ADDR
// if p3 = 101 then
22233: LD_VAR 0 3
22237: PUSH
22238: LD_INT 101
22240: EQUAL
22241: IFFALSE 22251
// sSold := true ;
22243: LD_ADDR_EXP 63
22247: PUSH
22248: LD_INT 1
22250: ST_TO_ADDR
// if p3 = 102 then
22251: LD_VAR 0 3
22255: PUSH
22256: LD_INT 102
22258: EQUAL
22259: IFFALSE 22269
// sDiff := true ;
22261: LD_ADDR_EXP 64
22265: PUSH
22266: LD_INT 1
22268: ST_TO_ADDR
// if p3 = 103 then
22269: LD_VAR 0 3
22273: PUSH
22274: LD_INT 103
22276: EQUAL
22277: IFFALSE 22287
// sFog := true ;
22279: LD_ADDR_EXP 67
22283: PUSH
22284: LD_INT 1
22286: ST_TO_ADDR
// if p3 = 104 then
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 104
22294: EQUAL
22295: IFFALSE 22305
// sReset := true ;
22297: LD_ADDR_EXP 68
22301: PUSH
22302: LD_INT 1
22304: ST_TO_ADDR
// if p3 = 105 then
22305: LD_VAR 0 3
22309: PUSH
22310: LD_INT 105
22312: EQUAL
22313: IFFALSE 22323
// sSun := true ;
22315: LD_ADDR_EXP 69
22319: PUSH
22320: LD_INT 1
22322: ST_TO_ADDR
// if p3 = 106 then
22323: LD_VAR 0 3
22327: PUSH
22328: LD_INT 106
22330: EQUAL
22331: IFFALSE 22341
// sTiger := true ;
22333: LD_ADDR_EXP 65
22337: PUSH
22338: LD_INT 1
22340: ST_TO_ADDR
// if p3 = 107 then
22341: LD_VAR 0 3
22345: PUSH
22346: LD_INT 107
22348: EQUAL
22349: IFFALSE 22359
// sBomb := true ;
22351: LD_ADDR_EXP 66
22355: PUSH
22356: LD_INT 1
22358: ST_TO_ADDR
// if p3 = 108 then
22359: LD_VAR 0 3
22363: PUSH
22364: LD_INT 108
22366: EQUAL
22367: IFFALSE 22377
// sWound := true ;
22369: LD_ADDR_EXP 74
22373: PUSH
22374: LD_INT 1
22376: ST_TO_ADDR
// if p3 = 109 then
22377: LD_VAR 0 3
22381: PUSH
22382: LD_INT 109
22384: EQUAL
22385: IFFALSE 22395
// sBetray := true ;
22387: LD_ADDR_EXP 78
22391: PUSH
22392: LD_INT 1
22394: ST_TO_ADDR
// if p3 = 110 then
22395: LD_VAR 0 3
22399: PUSH
22400: LD_INT 110
22402: EQUAL
22403: IFFALSE 22413
// sContamin := true ;
22405: LD_ADDR_EXP 79
22409: PUSH
22410: LD_INT 1
22412: ST_TO_ADDR
// if p3 = 111 then
22413: LD_VAR 0 3
22417: PUSH
22418: LD_INT 111
22420: EQUAL
22421: IFFALSE 22431
// sOil := true ;
22423: LD_ADDR_EXP 81
22427: PUSH
22428: LD_INT 1
22430: ST_TO_ADDR
// if p3 = 112 then
22431: LD_VAR 0 3
22435: PUSH
22436: LD_INT 112
22438: EQUAL
22439: IFFALSE 22449
// sStu := true ;
22441: LD_ADDR_EXP 85
22445: PUSH
22446: LD_INT 1
22448: ST_TO_ADDR
// if p3 = 113 then
22449: LD_VAR 0 3
22453: PUSH
22454: LD_INT 113
22456: EQUAL
22457: IFFALSE 22467
// sBazooka := true ;
22459: LD_ADDR_EXP 88
22463: PUSH
22464: LD_INT 1
22466: ST_TO_ADDR
// if p3 = 114 then
22467: LD_VAR 0 3
22471: PUSH
22472: LD_INT 114
22474: EQUAL
22475: IFFALSE 22485
// sMortar := true ;
22477: LD_ADDR_EXP 89
22481: PUSH
22482: LD_INT 1
22484: ST_TO_ADDR
// if p3 = 115 then
22485: LD_VAR 0 3
22489: PUSH
22490: LD_INT 115
22492: EQUAL
22493: IFFALSE 22503
// sRanger := true ;
22495: LD_ADDR_EXP 99
22499: PUSH
22500: LD_INT 1
22502: ST_TO_ADDR
// end ; end ;
22503: PPOPN 6
22505: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
22506: LD_EXP 46
22510: PUSH
22511: LD_EXP 51
22515: AND
22516: IFFALSE 22640
22518: GO 22520
22520: DISABLE
22521: LD_INT 0
22523: PPUSH
22524: PPUSH
// begin enable ;
22525: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
22526: LD_ADDR_VAR 0 2
22530: PUSH
22531: LD_INT 22
22533: PUSH
22534: LD_OWVAR 2
22538: PUSH
22539: EMPTY
22540: LIST
22541: LIST
22542: PUSH
22543: LD_INT 2
22545: PUSH
22546: LD_INT 34
22548: PUSH
22549: LD_INT 7
22551: PUSH
22552: EMPTY
22553: LIST
22554: LIST
22555: PUSH
22556: LD_INT 34
22558: PUSH
22559: LD_INT 45
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 28
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 34
22578: PUSH
22579: LD_INT 47
22581: PUSH
22582: EMPTY
22583: LIST
22584: LIST
22585: PUSH
22586: EMPTY
22587: LIST
22588: LIST
22589: LIST
22590: LIST
22591: LIST
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: PPUSH
22597: CALL_OW 69
22601: ST_TO_ADDR
// if not tmp then
22602: LD_VAR 0 2
22606: NOT
22607: IFFALSE 22611
// exit ;
22609: GO 22640
// for i in tmp do
22611: LD_ADDR_VAR 0 1
22615: PUSH
22616: LD_VAR 0 2
22620: PUSH
22621: FOR_IN
22622: IFFALSE 22638
// begin SetLives ( i , 0 ) ;
22624: LD_VAR 0 1
22628: PPUSH
22629: LD_INT 0
22631: PPUSH
22632: CALL_OW 234
// end ;
22636: GO 22621
22638: POP
22639: POP
// end ;
22640: PPOPN 2
22642: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
22643: LD_EXP 46
22647: PUSH
22648: LD_EXP 52
22652: AND
22653: IFFALSE 22737
22655: GO 22657
22657: DISABLE
22658: LD_INT 0
22660: PPUSH
22661: PPUSH
// begin enable ;
22662: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
22663: LD_ADDR_VAR 0 2
22667: PUSH
22668: LD_INT 22
22670: PUSH
22671: LD_OWVAR 2
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: PUSH
22680: LD_INT 32
22682: PUSH
22683: LD_INT 3
22685: PUSH
22686: EMPTY
22687: LIST
22688: LIST
22689: PUSH
22690: EMPTY
22691: LIST
22692: LIST
22693: PPUSH
22694: CALL_OW 69
22698: ST_TO_ADDR
// if not tmp then
22699: LD_VAR 0 2
22703: NOT
22704: IFFALSE 22708
// exit ;
22706: GO 22737
// for i in tmp do
22708: LD_ADDR_VAR 0 1
22712: PUSH
22713: LD_VAR 0 2
22717: PUSH
22718: FOR_IN
22719: IFFALSE 22735
// begin SetLives ( i , 0 ) ;
22721: LD_VAR 0 1
22725: PPUSH
22726: LD_INT 0
22728: PPUSH
22729: CALL_OW 234
// end ;
22733: GO 22718
22735: POP
22736: POP
// end ;
22737: PPOPN 2
22739: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
22740: LD_EXP 46
22744: PUSH
22745: LD_EXP 49
22749: AND
22750: IFFALSE 22843
22752: GO 22754
22754: DISABLE
22755: LD_INT 0
22757: PPUSH
// begin enable ;
22758: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
22759: LD_ADDR_VAR 0 1
22763: PUSH
22764: LD_INT 22
22766: PUSH
22767: LD_OWVAR 2
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: LD_INT 2
22778: PUSH
22779: LD_INT 25
22781: PUSH
22782: LD_INT 5
22784: PUSH
22785: EMPTY
22786: LIST
22787: LIST
22788: PUSH
22789: LD_INT 25
22791: PUSH
22792: LD_INT 9
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: PUSH
22799: LD_INT 25
22801: PUSH
22802: LD_INT 8
22804: PUSH
22805: EMPTY
22806: LIST
22807: LIST
22808: PUSH
22809: EMPTY
22810: LIST
22811: LIST
22812: LIST
22813: LIST
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PPUSH
22819: CALL_OW 69
22823: PUSH
22824: FOR_IN
22825: IFFALSE 22841
// begin SetClass ( i , 1 ) ;
22827: LD_VAR 0 1
22831: PPUSH
22832: LD_INT 1
22834: PPUSH
22835: CALL_OW 336
// end ;
22839: GO 22824
22841: POP
22842: POP
// end ;
22843: PPOPN 1
22845: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
22846: LD_EXP 46
22850: PUSH
22851: LD_EXP 50
22855: AND
22856: PUSH
22857: LD_OWVAR 65
22861: PUSH
22862: LD_INT 7
22864: LESS
22865: AND
22866: IFFALSE 22880
22868: GO 22870
22870: DISABLE
// begin enable ;
22871: ENABLE
// game_speed := 7 ;
22872: LD_ADDR_OWVAR 65
22876: PUSH
22877: LD_INT 7
22879: ST_TO_ADDR
// end ;
22880: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
22881: LD_EXP 46
22885: PUSH
22886: LD_EXP 53
22890: AND
22891: IFFALSE 23093
22893: GO 22895
22895: DISABLE
22896: LD_INT 0
22898: PPUSH
22899: PPUSH
22900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
22901: LD_ADDR_VAR 0 3
22905: PUSH
22906: LD_INT 81
22908: PUSH
22909: LD_OWVAR 2
22913: PUSH
22914: EMPTY
22915: LIST
22916: LIST
22917: PUSH
22918: LD_INT 21
22920: PUSH
22921: LD_INT 1
22923: PUSH
22924: EMPTY
22925: LIST
22926: LIST
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 69
22936: ST_TO_ADDR
// if not tmp then
22937: LD_VAR 0 3
22941: NOT
22942: IFFALSE 22946
// exit ;
22944: GO 23093
// if tmp > 5 then
22946: LD_VAR 0 3
22950: PUSH
22951: LD_INT 5
22953: GREATER
22954: IFFALSE 22966
// k := 5 else
22956: LD_ADDR_VAR 0 2
22960: PUSH
22961: LD_INT 5
22963: ST_TO_ADDR
22964: GO 22976
// k := tmp ;
22966: LD_ADDR_VAR 0 2
22970: PUSH
22971: LD_VAR 0 3
22975: ST_TO_ADDR
// for i := 1 to k do
22976: LD_ADDR_VAR 0 1
22980: PUSH
22981: DOUBLE
22982: LD_INT 1
22984: DEC
22985: ST_TO_ADDR
22986: LD_VAR 0 2
22990: PUSH
22991: FOR_TO
22992: IFFALSE 23091
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
22994: LD_VAR 0 3
22998: PUSH
22999: LD_VAR 0 1
23003: ARRAY
23004: PPUSH
23005: LD_VAR 0 1
23009: PUSH
23010: LD_INT 4
23012: MOD
23013: PUSH
23014: LD_INT 1
23016: PLUS
23017: PPUSH
23018: CALL_OW 259
23022: PUSH
23023: LD_INT 10
23025: LESS
23026: IFFALSE 23089
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23028: LD_VAR 0 3
23032: PUSH
23033: LD_VAR 0 1
23037: ARRAY
23038: PPUSH
23039: LD_VAR 0 1
23043: PUSH
23044: LD_INT 4
23046: MOD
23047: PUSH
23048: LD_INT 1
23050: PLUS
23051: PPUSH
23052: LD_VAR 0 3
23056: PUSH
23057: LD_VAR 0 1
23061: ARRAY
23062: PPUSH
23063: LD_VAR 0 1
23067: PUSH
23068: LD_INT 4
23070: MOD
23071: PUSH
23072: LD_INT 1
23074: PLUS
23075: PPUSH
23076: CALL_OW 259
23080: PUSH
23081: LD_INT 1
23083: PLUS
23084: PPUSH
23085: CALL_OW 237
23089: GO 22991
23091: POP
23092: POP
// end ;
23093: PPOPN 3
23095: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23096: LD_EXP 46
23100: PUSH
23101: LD_EXP 54
23105: AND
23106: IFFALSE 23126
23108: GO 23110
23110: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23111: LD_INT 4
23113: PPUSH
23114: LD_OWVAR 2
23118: PPUSH
23119: LD_INT 0
23121: PPUSH
23122: CALL_OW 324
23126: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23127: LD_EXP 46
23131: PUSH
23132: LD_EXP 83
23136: AND
23137: IFFALSE 23157
23139: GO 23141
23141: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23142: LD_INT 19
23144: PPUSH
23145: LD_OWVAR 2
23149: PPUSH
23150: LD_INT 0
23152: PPUSH
23153: CALL_OW 324
23157: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23158: LD_EXP 46
23162: PUSH
23163: LD_EXP 55
23167: AND
23168: IFFALSE 23270
23170: GO 23172
23172: DISABLE
23173: LD_INT 0
23175: PPUSH
23176: PPUSH
// begin enable ;
23177: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23178: LD_ADDR_VAR 0 2
23182: PUSH
23183: LD_INT 22
23185: PUSH
23186: LD_OWVAR 2
23190: PUSH
23191: EMPTY
23192: LIST
23193: LIST
23194: PUSH
23195: LD_INT 2
23197: PUSH
23198: LD_INT 34
23200: PUSH
23201: LD_INT 11
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PUSH
23208: LD_INT 34
23210: PUSH
23211: LD_INT 30
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PUSH
23218: EMPTY
23219: LIST
23220: LIST
23221: LIST
23222: PUSH
23223: EMPTY
23224: LIST
23225: LIST
23226: PPUSH
23227: CALL_OW 69
23231: ST_TO_ADDR
// if not tmp then
23232: LD_VAR 0 2
23236: NOT
23237: IFFALSE 23241
// exit ;
23239: GO 23270
// for i in tmp do
23241: LD_ADDR_VAR 0 1
23245: PUSH
23246: LD_VAR 0 2
23250: PUSH
23251: FOR_IN
23252: IFFALSE 23268
// begin SetLives ( i , 0 ) ;
23254: LD_VAR 0 1
23258: PPUSH
23259: LD_INT 0
23261: PPUSH
23262: CALL_OW 234
// end ;
23266: GO 23251
23268: POP
23269: POP
// end ;
23270: PPOPN 2
23272: END
// every 0 0$1 trigger StreamModeActive and sBunker do
23273: LD_EXP 46
23277: PUSH
23278: LD_EXP 56
23282: AND
23283: IFFALSE 23303
23285: GO 23287
23287: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
23288: LD_INT 32
23290: PPUSH
23291: LD_OWVAR 2
23295: PPUSH
23296: LD_INT 0
23298: PPUSH
23299: CALL_OW 324
23303: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
23304: LD_EXP 46
23308: PUSH
23309: LD_EXP 57
23313: AND
23314: IFFALSE 23495
23316: GO 23318
23318: DISABLE
23319: LD_INT 0
23321: PPUSH
23322: PPUSH
23323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
23324: LD_ADDR_VAR 0 2
23328: PUSH
23329: LD_INT 22
23331: PUSH
23332: LD_OWVAR 2
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: PUSH
23341: LD_INT 33
23343: PUSH
23344: LD_INT 3
23346: PUSH
23347: EMPTY
23348: LIST
23349: LIST
23350: PUSH
23351: EMPTY
23352: LIST
23353: LIST
23354: PPUSH
23355: CALL_OW 69
23359: ST_TO_ADDR
// if not tmp then
23360: LD_VAR 0 2
23364: NOT
23365: IFFALSE 23369
// exit ;
23367: GO 23495
// side := 0 ;
23369: LD_ADDR_VAR 0 3
23373: PUSH
23374: LD_INT 0
23376: ST_TO_ADDR
// for i := 1 to 8 do
23377: LD_ADDR_VAR 0 1
23381: PUSH
23382: DOUBLE
23383: LD_INT 1
23385: DEC
23386: ST_TO_ADDR
23387: LD_INT 8
23389: PUSH
23390: FOR_TO
23391: IFFALSE 23439
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
23393: LD_OWVAR 2
23397: PUSH
23398: LD_VAR 0 1
23402: NONEQUAL
23403: PUSH
23404: LD_OWVAR 2
23408: PPUSH
23409: LD_VAR 0 1
23413: PPUSH
23414: CALL_OW 81
23418: PUSH
23419: LD_INT 2
23421: EQUAL
23422: AND
23423: IFFALSE 23437
// begin side := i ;
23425: LD_ADDR_VAR 0 3
23429: PUSH
23430: LD_VAR 0 1
23434: ST_TO_ADDR
// break ;
23435: GO 23439
// end ;
23437: GO 23390
23439: POP
23440: POP
// if not side then
23441: LD_VAR 0 3
23445: NOT
23446: IFFALSE 23450
// exit ;
23448: GO 23495
// for i := 1 to tmp do
23450: LD_ADDR_VAR 0 1
23454: PUSH
23455: DOUBLE
23456: LD_INT 1
23458: DEC
23459: ST_TO_ADDR
23460: LD_VAR 0 2
23464: PUSH
23465: FOR_TO
23466: IFFALSE 23493
// if Prob ( 30 ) then
23468: LD_INT 30
23470: PPUSH
23471: CALL_OW 13
23475: IFFALSE 23491
// SetSide ( i , side ) ;
23477: LD_VAR 0 1
23481: PPUSH
23482: LD_VAR 0 3
23486: PPUSH
23487: CALL_OW 235
23491: GO 23465
23493: POP
23494: POP
// end ;
23495: PPOPN 3
23497: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
23498: LD_EXP 46
23502: PUSH
23503: LD_EXP 59
23507: AND
23508: IFFALSE 23627
23510: GO 23512
23512: DISABLE
23513: LD_INT 0
23515: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
23516: LD_ADDR_VAR 0 1
23520: PUSH
23521: LD_INT 22
23523: PUSH
23524: LD_OWVAR 2
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PUSH
23533: LD_INT 21
23535: PUSH
23536: LD_INT 1
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 3
23545: PUSH
23546: LD_INT 23
23548: PUSH
23549: LD_INT 0
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: LIST
23564: PPUSH
23565: CALL_OW 69
23569: PUSH
23570: FOR_IN
23571: IFFALSE 23625
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
23573: LD_VAR 0 1
23577: PPUSH
23578: CALL_OW 257
23582: PUSH
23583: LD_INT 1
23585: PUSH
23586: LD_INT 2
23588: PUSH
23589: LD_INT 3
23591: PUSH
23592: LD_INT 4
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: LIST
23599: LIST
23600: IN
23601: IFFALSE 23623
// SetClass ( un , rand ( 1 , 4 ) ) ;
23603: LD_VAR 0 1
23607: PPUSH
23608: LD_INT 1
23610: PPUSH
23611: LD_INT 4
23613: PPUSH
23614: CALL_OW 12
23618: PPUSH
23619: CALL_OW 336
23623: GO 23570
23625: POP
23626: POP
// end ;
23627: PPOPN 1
23629: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
23630: LD_EXP 46
23634: PUSH
23635: LD_EXP 58
23639: AND
23640: IFFALSE 23719
23642: GO 23644
23644: DISABLE
23645: LD_INT 0
23647: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
23648: LD_ADDR_VAR 0 1
23652: PUSH
23653: LD_INT 22
23655: PUSH
23656: LD_OWVAR 2
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: LD_INT 21
23667: PUSH
23668: LD_INT 3
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: PPUSH
23679: CALL_OW 69
23683: ST_TO_ADDR
// if not tmp then
23684: LD_VAR 0 1
23688: NOT
23689: IFFALSE 23693
// exit ;
23691: GO 23719
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
23693: LD_VAR 0 1
23697: PUSH
23698: LD_INT 1
23700: PPUSH
23701: LD_VAR 0 1
23705: PPUSH
23706: CALL_OW 12
23710: ARRAY
23711: PPUSH
23712: LD_INT 100
23714: PPUSH
23715: CALL_OW 234
// end ;
23719: PPOPN 1
23721: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
23722: LD_EXP 46
23726: PUSH
23727: LD_EXP 60
23731: AND
23732: IFFALSE 23830
23734: GO 23736
23736: DISABLE
23737: LD_INT 0
23739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23740: LD_ADDR_VAR 0 1
23744: PUSH
23745: LD_INT 22
23747: PUSH
23748: LD_OWVAR 2
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: PUSH
23757: LD_INT 21
23759: PUSH
23760: LD_INT 1
23762: PUSH
23763: EMPTY
23764: LIST
23765: LIST
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PPUSH
23771: CALL_OW 69
23775: ST_TO_ADDR
// if not tmp then
23776: LD_VAR 0 1
23780: NOT
23781: IFFALSE 23785
// exit ;
23783: GO 23830
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
23785: LD_VAR 0 1
23789: PUSH
23790: LD_INT 1
23792: PPUSH
23793: LD_VAR 0 1
23797: PPUSH
23798: CALL_OW 12
23802: ARRAY
23803: PPUSH
23804: LD_INT 1
23806: PPUSH
23807: LD_INT 4
23809: PPUSH
23810: CALL_OW 12
23814: PPUSH
23815: LD_INT 3000
23817: PPUSH
23818: LD_INT 9000
23820: PPUSH
23821: CALL_OW 12
23825: PPUSH
23826: CALL_OW 492
// end ;
23830: PPOPN 1
23832: END
// every 0 0$1 trigger StreamModeActive and sDepot do
23833: LD_EXP 46
23837: PUSH
23838: LD_EXP 61
23842: AND
23843: IFFALSE 23863
23845: GO 23847
23847: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
23848: LD_INT 1
23850: PPUSH
23851: LD_OWVAR 2
23855: PPUSH
23856: LD_INT 0
23858: PPUSH
23859: CALL_OW 324
23863: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
23864: LD_EXP 46
23868: PUSH
23869: LD_EXP 62
23873: AND
23874: IFFALSE 23957
23876: GO 23878
23878: DISABLE
23879: LD_INT 0
23881: PPUSH
23882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
23883: LD_ADDR_VAR 0 2
23887: PUSH
23888: LD_INT 22
23890: PUSH
23891: LD_OWVAR 2
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 21
23902: PUSH
23903: LD_INT 3
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: PPUSH
23914: CALL_OW 69
23918: ST_TO_ADDR
// if not tmp then
23919: LD_VAR 0 2
23923: NOT
23924: IFFALSE 23928
// exit ;
23926: GO 23957
// for i in tmp do
23928: LD_ADDR_VAR 0 1
23932: PUSH
23933: LD_VAR 0 2
23937: PUSH
23938: FOR_IN
23939: IFFALSE 23955
// SetBLevel ( i , 10 ) ;
23941: LD_VAR 0 1
23945: PPUSH
23946: LD_INT 10
23948: PPUSH
23949: CALL_OW 241
23953: GO 23938
23955: POP
23956: POP
// end ;
23957: PPOPN 2
23959: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
23960: LD_EXP 46
23964: PUSH
23965: LD_EXP 63
23969: AND
23970: IFFALSE 24081
23972: GO 23974
23974: DISABLE
23975: LD_INT 0
23977: PPUSH
23978: PPUSH
23979: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
23980: LD_ADDR_VAR 0 3
23984: PUSH
23985: LD_INT 22
23987: PUSH
23988: LD_OWVAR 2
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: PUSH
23997: LD_INT 25
23999: PUSH
24000: LD_INT 1
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PPUSH
24011: CALL_OW 69
24015: ST_TO_ADDR
// if not tmp then
24016: LD_VAR 0 3
24020: NOT
24021: IFFALSE 24025
// exit ;
24023: GO 24081
// un := tmp [ rand ( 1 , tmp ) ] ;
24025: LD_ADDR_VAR 0 2
24029: PUSH
24030: LD_VAR 0 3
24034: PUSH
24035: LD_INT 1
24037: PPUSH
24038: LD_VAR 0 3
24042: PPUSH
24043: CALL_OW 12
24047: ARRAY
24048: ST_TO_ADDR
// if Crawls ( un ) then
24049: LD_VAR 0 2
24053: PPUSH
24054: CALL_OW 318
24058: IFFALSE 24069
// ComWalk ( un ) ;
24060: LD_VAR 0 2
24064: PPUSH
24065: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24069: LD_VAR 0 2
24073: PPUSH
24074: LD_INT 5
24076: PPUSH
24077: CALL_OW 336
// end ;
24081: PPOPN 3
24083: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24084: LD_EXP 46
24088: PUSH
24089: LD_EXP 64
24093: AND
24094: PUSH
24095: LD_OWVAR 67
24099: PUSH
24100: LD_INT 3
24102: LESS
24103: AND
24104: IFFALSE 24123
24106: GO 24108
24108: DISABLE
// Difficulty := Difficulty + 1 ;
24109: LD_ADDR_OWVAR 67
24113: PUSH
24114: LD_OWVAR 67
24118: PUSH
24119: LD_INT 1
24121: PLUS
24122: ST_TO_ADDR
24123: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24124: LD_EXP 46
24128: PUSH
24129: LD_EXP 65
24133: AND
24134: IFFALSE 24237
24136: GO 24138
24138: DISABLE
24139: LD_INT 0
24141: PPUSH
// begin for i := 1 to 5 do
24142: LD_ADDR_VAR 0 1
24146: PUSH
24147: DOUBLE
24148: LD_INT 1
24150: DEC
24151: ST_TO_ADDR
24152: LD_INT 5
24154: PUSH
24155: FOR_TO
24156: IFFALSE 24235
// begin uc_nation := nation_nature ;
24158: LD_ADDR_OWVAR 21
24162: PUSH
24163: LD_INT 0
24165: ST_TO_ADDR
// uc_side := 0 ;
24166: LD_ADDR_OWVAR 20
24170: PUSH
24171: LD_INT 0
24173: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24174: LD_ADDR_OWVAR 29
24178: PUSH
24179: LD_INT 12
24181: PUSH
24182: LD_INT 12
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: ST_TO_ADDR
// hc_agressivity := 20 ;
24189: LD_ADDR_OWVAR 35
24193: PUSH
24194: LD_INT 20
24196: ST_TO_ADDR
// hc_class := class_tiger ;
24197: LD_ADDR_OWVAR 28
24201: PUSH
24202: LD_INT 14
24204: ST_TO_ADDR
// hc_gallery :=  ;
24205: LD_ADDR_OWVAR 33
24209: PUSH
24210: LD_STRING 
24212: ST_TO_ADDR
// hc_name :=  ;
24213: LD_ADDR_OWVAR 26
24217: PUSH
24218: LD_STRING 
24220: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
24221: CALL_OW 44
24225: PPUSH
24226: LD_INT 0
24228: PPUSH
24229: CALL_OW 51
// end ;
24233: GO 24155
24235: POP
24236: POP
// end ;
24237: PPOPN 1
24239: END
// every 0 0$1 trigger StreamModeActive and sBomb do
24240: LD_EXP 46
24244: PUSH
24245: LD_EXP 66
24249: AND
24250: IFFALSE 24259
24252: GO 24254
24254: DISABLE
// StreamSibBomb ;
24255: CALL 24260 0 0
24259: END
// export function StreamSibBomb ; var i , x , y ; begin
24260: LD_INT 0
24262: PPUSH
24263: PPUSH
24264: PPUSH
24265: PPUSH
// result := false ;
24266: LD_ADDR_VAR 0 1
24270: PUSH
24271: LD_INT 0
24273: ST_TO_ADDR
// for i := 1 to 16 do
24274: LD_ADDR_VAR 0 2
24278: PUSH
24279: DOUBLE
24280: LD_INT 1
24282: DEC
24283: ST_TO_ADDR
24284: LD_INT 16
24286: PUSH
24287: FOR_TO
24288: IFFALSE 24487
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24290: LD_ADDR_VAR 0 3
24294: PUSH
24295: LD_INT 10
24297: PUSH
24298: LD_INT 20
24300: PUSH
24301: LD_INT 30
24303: PUSH
24304: LD_INT 40
24306: PUSH
24307: LD_INT 50
24309: PUSH
24310: LD_INT 60
24312: PUSH
24313: LD_INT 70
24315: PUSH
24316: LD_INT 80
24318: PUSH
24319: LD_INT 90
24321: PUSH
24322: LD_INT 100
24324: PUSH
24325: LD_INT 110
24327: PUSH
24328: LD_INT 120
24330: PUSH
24331: LD_INT 130
24333: PUSH
24334: LD_INT 140
24336: PUSH
24337: LD_INT 150
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: PUSH
24357: LD_INT 1
24359: PPUSH
24360: LD_INT 15
24362: PPUSH
24363: CALL_OW 12
24367: ARRAY
24368: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24369: LD_ADDR_VAR 0 4
24373: PUSH
24374: LD_INT 10
24376: PUSH
24377: LD_INT 20
24379: PUSH
24380: LD_INT 30
24382: PUSH
24383: LD_INT 40
24385: PUSH
24386: LD_INT 50
24388: PUSH
24389: LD_INT 60
24391: PUSH
24392: LD_INT 70
24394: PUSH
24395: LD_INT 80
24397: PUSH
24398: LD_INT 90
24400: PUSH
24401: LD_INT 100
24403: PUSH
24404: LD_INT 110
24406: PUSH
24407: LD_INT 120
24409: PUSH
24410: LD_INT 130
24412: PUSH
24413: LD_INT 140
24415: PUSH
24416: LD_INT 150
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: LIST
24423: LIST
24424: LIST
24425: LIST
24426: LIST
24427: LIST
24428: LIST
24429: LIST
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: LIST
24435: PUSH
24436: LD_INT 1
24438: PPUSH
24439: LD_INT 15
24441: PPUSH
24442: CALL_OW 12
24446: ARRAY
24447: ST_TO_ADDR
// if ValidHex ( x , y ) then
24448: LD_VAR 0 3
24452: PPUSH
24453: LD_VAR 0 4
24457: PPUSH
24458: CALL_OW 488
24462: IFFALSE 24485
// begin result := [ x , y ] ;
24464: LD_ADDR_VAR 0 1
24468: PUSH
24469: LD_VAR 0 3
24473: PUSH
24474: LD_VAR 0 4
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: ST_TO_ADDR
// break ;
24483: GO 24487
// end ; end ;
24485: GO 24287
24487: POP
24488: POP
// if result then
24489: LD_VAR 0 1
24493: IFFALSE 24553
// begin ToLua ( playSibBomb() ) ;
24495: LD_STRING playSibBomb()
24497: PPUSH
24498: CALL_OW 559
// wait ( 0 0$14 ) ;
24502: LD_INT 490
24504: PPUSH
24505: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
24509: LD_VAR 0 1
24513: PUSH
24514: LD_INT 1
24516: ARRAY
24517: PPUSH
24518: LD_VAR 0 1
24522: PUSH
24523: LD_INT 2
24525: ARRAY
24526: PPUSH
24527: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
24531: LD_VAR 0 1
24535: PUSH
24536: LD_INT 1
24538: ARRAY
24539: PPUSH
24540: LD_VAR 0 1
24544: PUSH
24545: LD_INT 2
24547: ARRAY
24548: PPUSH
24549: CALL_OW 429
// end ; end ;
24553: LD_VAR 0 1
24557: RET
// every 0 0$1 trigger StreamModeActive and sReset do
24558: LD_EXP 46
24562: PUSH
24563: LD_EXP 68
24567: AND
24568: IFFALSE 24580
24570: GO 24572
24572: DISABLE
// YouLost (  ) ;
24573: LD_STRING 
24575: PPUSH
24576: CALL_OW 104
24580: END
// every 0 0$1 trigger StreamModeActive and sFog do
24581: LD_EXP 46
24585: PUSH
24586: LD_EXP 67
24590: AND
24591: IFFALSE 24605
24593: GO 24595
24595: DISABLE
// FogOff ( your_side ) ;
24596: LD_OWVAR 2
24600: PPUSH
24601: CALL_OW 344
24605: END
// every 0 0$1 trigger StreamModeActive and sSun do
24606: LD_EXP 46
24610: PUSH
24611: LD_EXP 69
24615: AND
24616: IFFALSE 24644
24618: GO 24620
24620: DISABLE
// begin solar_recharge_percent := 0 ;
24621: LD_ADDR_OWVAR 79
24625: PUSH
24626: LD_INT 0
24628: ST_TO_ADDR
// wait ( 5 5$00 ) ;
24629: LD_INT 10500
24631: PPUSH
24632: CALL_OW 67
// solar_recharge_percent := 100 ;
24636: LD_ADDR_OWVAR 79
24640: PUSH
24641: LD_INT 100
24643: ST_TO_ADDR
// end ;
24644: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
24645: LD_EXP 46
24649: PUSH
24650: LD_EXP 70
24654: AND
24655: IFFALSE 24894
24657: GO 24659
24659: DISABLE
24660: LD_INT 0
24662: PPUSH
24663: PPUSH
24664: PPUSH
// begin tmp := [ ] ;
24665: LD_ADDR_VAR 0 3
24669: PUSH
24670: EMPTY
24671: ST_TO_ADDR
// for i := 1 to 6 do
24672: LD_ADDR_VAR 0 1
24676: PUSH
24677: DOUBLE
24678: LD_INT 1
24680: DEC
24681: ST_TO_ADDR
24682: LD_INT 6
24684: PUSH
24685: FOR_TO
24686: IFFALSE 24791
// begin uc_nation := nation_nature ;
24688: LD_ADDR_OWVAR 21
24692: PUSH
24693: LD_INT 0
24695: ST_TO_ADDR
// uc_side := 0 ;
24696: LD_ADDR_OWVAR 20
24700: PUSH
24701: LD_INT 0
24703: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24704: LD_ADDR_OWVAR 29
24708: PUSH
24709: LD_INT 12
24711: PUSH
24712: LD_INT 12
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: ST_TO_ADDR
// hc_agressivity := 20 ;
24719: LD_ADDR_OWVAR 35
24723: PUSH
24724: LD_INT 20
24726: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
24727: LD_ADDR_OWVAR 28
24731: PUSH
24732: LD_INT 17
24734: ST_TO_ADDR
// hc_gallery :=  ;
24735: LD_ADDR_OWVAR 33
24739: PUSH
24740: LD_STRING 
24742: ST_TO_ADDR
// hc_name :=  ;
24743: LD_ADDR_OWVAR 26
24747: PUSH
24748: LD_STRING 
24750: ST_TO_ADDR
// un := CreateHuman ;
24751: LD_ADDR_VAR 0 2
24755: PUSH
24756: CALL_OW 44
24760: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
24761: LD_VAR 0 2
24765: PPUSH
24766: LD_INT 1
24768: PPUSH
24769: CALL_OW 51
// tmp := tmp ^ un ;
24773: LD_ADDR_VAR 0 3
24777: PUSH
24778: LD_VAR 0 3
24782: PUSH
24783: LD_VAR 0 2
24787: ADD
24788: ST_TO_ADDR
// end ;
24789: GO 24685
24791: POP
24792: POP
// repeat wait ( 0 0$1 ) ;
24793: LD_INT 35
24795: PPUSH
24796: CALL_OW 67
// for un in tmp do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: LD_VAR 0 3
24809: PUSH
24810: FOR_IN
24811: IFFALSE 24885
// begin if IsDead ( un ) then
24813: LD_VAR 0 2
24817: PPUSH
24818: CALL_OW 301
24822: IFFALSE 24842
// begin tmp := tmp diff un ;
24824: LD_ADDR_VAR 0 3
24828: PUSH
24829: LD_VAR 0 3
24833: PUSH
24834: LD_VAR 0 2
24838: DIFF
24839: ST_TO_ADDR
// continue ;
24840: GO 24810
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
24842: LD_VAR 0 2
24846: PPUSH
24847: LD_INT 3
24849: PUSH
24850: LD_INT 22
24852: PUSH
24853: LD_INT 0
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: PUSH
24860: EMPTY
24861: LIST
24862: LIST
24863: PPUSH
24864: CALL_OW 69
24868: PPUSH
24869: LD_VAR 0 2
24873: PPUSH
24874: CALL_OW 74
24878: PPUSH
24879: CALL_OW 115
// end ;
24883: GO 24810
24885: POP
24886: POP
// until not tmp ;
24887: LD_VAR 0 3
24891: NOT
24892: IFFALSE 24793
// end ;
24894: PPOPN 3
24896: END
// every 0 0$1 trigger StreamModeActive and sTroll do
24897: LD_EXP 46
24901: PUSH
24902: LD_EXP 71
24906: AND
24907: IFFALSE 24961
24909: GO 24911
24911: DISABLE
// begin ToLua ( displayTroll(); ) ;
24912: LD_STRING displayTroll();
24914: PPUSH
24915: CALL_OW 559
// wait ( 3 3$00 ) ;
24919: LD_INT 6300
24921: PPUSH
24922: CALL_OW 67
// ToLua ( hideTroll(); ) ;
24926: LD_STRING hideTroll();
24928: PPUSH
24929: CALL_OW 559
// wait ( 1 1$00 ) ;
24933: LD_INT 2100
24935: PPUSH
24936: CALL_OW 67
// ToLua ( displayTroll(); ) ;
24940: LD_STRING displayTroll();
24942: PPUSH
24943: CALL_OW 559
// wait ( 1 1$00 ) ;
24947: LD_INT 2100
24949: PPUSH
24950: CALL_OW 67
// ToLua ( hideTroll(); ) ;
24954: LD_STRING hideTroll();
24956: PPUSH
24957: CALL_OW 559
// end ;
24961: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
24962: LD_EXP 46
24966: PUSH
24967: LD_EXP 72
24971: AND
24972: IFFALSE 25035
24974: GO 24976
24976: DISABLE
24977: LD_INT 0
24979: PPUSH
// begin p := 0 ;
24980: LD_ADDR_VAR 0 1
24984: PUSH
24985: LD_INT 0
24987: ST_TO_ADDR
// repeat game_speed := 1 ;
24988: LD_ADDR_OWVAR 65
24992: PUSH
24993: LD_INT 1
24995: ST_TO_ADDR
// wait ( 0 0$1 ) ;
24996: LD_INT 35
24998: PPUSH
24999: CALL_OW 67
// p := p + 1 ;
25003: LD_ADDR_VAR 0 1
25007: PUSH
25008: LD_VAR 0 1
25012: PUSH
25013: LD_INT 1
25015: PLUS
25016: ST_TO_ADDR
// until p >= 60 ;
25017: LD_VAR 0 1
25021: PUSH
25022: LD_INT 60
25024: GREATEREQUAL
25025: IFFALSE 24988
// game_speed := 4 ;
25027: LD_ADDR_OWVAR 65
25031: PUSH
25032: LD_INT 4
25034: ST_TO_ADDR
// end ;
25035: PPOPN 1
25037: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25038: LD_EXP 46
25042: PUSH
25043: LD_EXP 73
25047: AND
25048: IFFALSE 25194
25050: GO 25052
25052: DISABLE
25053: LD_INT 0
25055: PPUSH
25056: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25057: LD_ADDR_VAR 0 1
25061: PUSH
25062: LD_INT 22
25064: PUSH
25065: LD_OWVAR 2
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 2
25076: PUSH
25077: LD_INT 30
25079: PUSH
25080: LD_INT 0
25082: PUSH
25083: EMPTY
25084: LIST
25085: LIST
25086: PUSH
25087: LD_INT 30
25089: PUSH
25090: LD_INT 1
25092: PUSH
25093: EMPTY
25094: LIST
25095: LIST
25096: PUSH
25097: EMPTY
25098: LIST
25099: LIST
25100: LIST
25101: PUSH
25102: EMPTY
25103: LIST
25104: LIST
25105: PPUSH
25106: CALL_OW 69
25110: ST_TO_ADDR
// if not depot then
25111: LD_VAR 0 1
25115: NOT
25116: IFFALSE 25120
// exit ;
25118: GO 25194
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25120: LD_ADDR_VAR 0 2
25124: PUSH
25125: LD_VAR 0 1
25129: PUSH
25130: LD_INT 1
25132: PPUSH
25133: LD_VAR 0 1
25137: PPUSH
25138: CALL_OW 12
25142: ARRAY
25143: PPUSH
25144: CALL_OW 274
25148: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25149: LD_VAR 0 2
25153: PPUSH
25154: LD_INT 1
25156: PPUSH
25157: LD_INT 0
25159: PPUSH
25160: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25164: LD_VAR 0 2
25168: PPUSH
25169: LD_INT 2
25171: PPUSH
25172: LD_INT 0
25174: PPUSH
25175: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25179: LD_VAR 0 2
25183: PPUSH
25184: LD_INT 3
25186: PPUSH
25187: LD_INT 0
25189: PPUSH
25190: CALL_OW 277
// end ;
25194: PPOPN 2
25196: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
25197: LD_EXP 46
25201: PUSH
25202: LD_EXP 74
25206: AND
25207: IFFALSE 25304
25209: GO 25211
25211: DISABLE
25212: LD_INT 0
25214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25215: LD_ADDR_VAR 0 1
25219: PUSH
25220: LD_INT 22
25222: PUSH
25223: LD_OWVAR 2
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: PUSH
25232: LD_INT 21
25234: PUSH
25235: LD_INT 1
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: LD_INT 3
25244: PUSH
25245: LD_INT 23
25247: PUSH
25248: LD_INT 0
25250: PUSH
25251: EMPTY
25252: LIST
25253: LIST
25254: PUSH
25255: EMPTY
25256: LIST
25257: LIST
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: LIST
25263: PPUSH
25264: CALL_OW 69
25268: ST_TO_ADDR
// if not tmp then
25269: LD_VAR 0 1
25273: NOT
25274: IFFALSE 25278
// exit ;
25276: GO 25304
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
25278: LD_VAR 0 1
25282: PUSH
25283: LD_INT 1
25285: PPUSH
25286: LD_VAR 0 1
25290: PPUSH
25291: CALL_OW 12
25295: ARRAY
25296: PPUSH
25297: LD_INT 200
25299: PPUSH
25300: CALL_OW 234
// end ;
25304: PPOPN 1
25306: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
25307: LD_EXP 46
25311: PUSH
25312: LD_EXP 75
25316: AND
25317: IFFALSE 25396
25319: GO 25321
25321: DISABLE
25322: LD_INT 0
25324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
25325: LD_ADDR_VAR 0 1
25329: PUSH
25330: LD_INT 22
25332: PUSH
25333: LD_OWVAR 2
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: PUSH
25342: LD_INT 21
25344: PUSH
25345: LD_INT 2
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PPUSH
25356: CALL_OW 69
25360: ST_TO_ADDR
// if not tmp then
25361: LD_VAR 0 1
25365: NOT
25366: IFFALSE 25370
// exit ;
25368: GO 25396
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
25370: LD_VAR 0 1
25374: PUSH
25375: LD_INT 1
25377: PPUSH
25378: LD_VAR 0 1
25382: PPUSH
25383: CALL_OW 12
25387: ARRAY
25388: PPUSH
25389: LD_INT 60
25391: PPUSH
25392: CALL_OW 234
// end ;
25396: PPOPN 1
25398: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
25399: LD_EXP 46
25403: PUSH
25404: LD_EXP 76
25408: AND
25409: IFFALSE 25508
25411: GO 25413
25413: DISABLE
25414: LD_INT 0
25416: PPUSH
25417: PPUSH
// begin enable ;
25418: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
25419: LD_ADDR_VAR 0 1
25423: PUSH
25424: LD_INT 22
25426: PUSH
25427: LD_OWVAR 2
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 61
25438: PUSH
25439: EMPTY
25440: LIST
25441: PUSH
25442: LD_INT 33
25444: PUSH
25445: LD_INT 2
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: LIST
25456: PPUSH
25457: CALL_OW 69
25461: ST_TO_ADDR
// if not tmp then
25462: LD_VAR 0 1
25466: NOT
25467: IFFALSE 25471
// exit ;
25469: GO 25508
// for i in tmp do
25471: LD_ADDR_VAR 0 2
25475: PUSH
25476: LD_VAR 0 1
25480: PUSH
25481: FOR_IN
25482: IFFALSE 25506
// if IsControledBy ( i ) then
25484: LD_VAR 0 2
25488: PPUSH
25489: CALL_OW 312
25493: IFFALSE 25504
// ComUnlink ( i ) ;
25495: LD_VAR 0 2
25499: PPUSH
25500: CALL_OW 136
25504: GO 25481
25506: POP
25507: POP
// end ;
25508: PPOPN 2
25510: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
25511: LD_EXP 46
25515: PUSH
25516: LD_EXP 77
25520: AND
25521: IFFALSE 25655
25523: GO 25525
25525: DISABLE
25526: LD_INT 0
25528: PPUSH
25529: PPUSH
// begin ToLua ( displayPowell(); ) ;
25530: LD_STRING displayPowell();
25532: PPUSH
25533: CALL_OW 559
// uc_side := 0 ;
25537: LD_ADDR_OWVAR 20
25541: PUSH
25542: LD_INT 0
25544: ST_TO_ADDR
// uc_nation := 2 ;
25545: LD_ADDR_OWVAR 21
25549: PUSH
25550: LD_INT 2
25552: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
25553: LD_ADDR_OWVAR 37
25557: PUSH
25558: LD_INT 14
25560: ST_TO_ADDR
// vc_engine := engine_siberite ;
25561: LD_ADDR_OWVAR 39
25565: PUSH
25566: LD_INT 3
25568: ST_TO_ADDR
// vc_control := control_apeman ;
25569: LD_ADDR_OWVAR 38
25573: PUSH
25574: LD_INT 5
25576: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
25577: LD_ADDR_OWVAR 40
25581: PUSH
25582: LD_INT 29
25584: ST_TO_ADDR
// un := CreateVehicle ;
25585: LD_ADDR_VAR 0 2
25589: PUSH
25590: CALL_OW 45
25594: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
25595: LD_VAR 0 2
25599: PPUSH
25600: LD_INT 1
25602: PPUSH
25603: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
25607: LD_INT 35
25609: PPUSH
25610: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
25614: LD_VAR 0 2
25618: PPUSH
25619: LD_OWVAR 3
25623: PUSH
25624: LD_VAR 0 2
25628: DIFF
25629: PPUSH
25630: LD_VAR 0 2
25634: PPUSH
25635: CALL_OW 74
25639: PPUSH
25640: CALL_OW 115
// until IsOk ( un ) ;
25644: LD_VAR 0 2
25648: PPUSH
25649: CALL_OW 302
25653: IFFALSE 25607
// end ;
25655: PPOPN 2
25657: END
// every 0 0$1 trigger StreamModeActive and sStu do
25658: LD_EXP 46
25662: PUSH
25663: LD_EXP 85
25667: AND
25668: IFFALSE 25680
25670: GO 25672
25672: DISABLE
// begin ToLua ( displayStucuk(); ) ;
25673: LD_STRING displayStucuk();
25675: PPUSH
25676: CALL_OW 559
// end ;
25680: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
25681: LD_EXP 46
25685: PUSH
25686: LD_EXP 78
25690: AND
25691: IFFALSE 25832
25693: GO 25695
25695: DISABLE
25696: LD_INT 0
25698: PPUSH
25699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25700: LD_ADDR_VAR 0 2
25704: PUSH
25705: LD_INT 22
25707: PUSH
25708: LD_OWVAR 2
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: PUSH
25717: LD_INT 21
25719: PUSH
25720: LD_INT 1
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 69
25735: ST_TO_ADDR
// if not tmp then
25736: LD_VAR 0 2
25740: NOT
25741: IFFALSE 25745
// exit ;
25743: GO 25832
// un := tmp [ rand ( 1 , tmp ) ] ;
25745: LD_ADDR_VAR 0 1
25749: PUSH
25750: LD_VAR 0 2
25754: PUSH
25755: LD_INT 1
25757: PPUSH
25758: LD_VAR 0 2
25762: PPUSH
25763: CALL_OW 12
25767: ARRAY
25768: ST_TO_ADDR
// SetSide ( un , 0 ) ;
25769: LD_VAR 0 1
25773: PPUSH
25774: LD_INT 0
25776: PPUSH
25777: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
25781: LD_VAR 0 1
25785: PPUSH
25786: LD_OWVAR 3
25790: PUSH
25791: LD_VAR 0 1
25795: DIFF
25796: PPUSH
25797: LD_VAR 0 1
25801: PPUSH
25802: CALL_OW 74
25806: PPUSH
25807: CALL_OW 115
// wait ( 0 0$20 ) ;
25811: LD_INT 700
25813: PPUSH
25814: CALL_OW 67
// SetSide ( un , your_side ) ;
25818: LD_VAR 0 1
25822: PPUSH
25823: LD_OWVAR 2
25827: PPUSH
25828: CALL_OW 235
// end ;
25832: PPOPN 2
25834: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
25835: LD_EXP 46
25839: PUSH
25840: LD_EXP 79
25844: AND
25845: IFFALSE 25951
25847: GO 25849
25849: DISABLE
25850: LD_INT 0
25852: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25853: LD_ADDR_VAR 0 1
25857: PUSH
25858: LD_INT 22
25860: PUSH
25861: LD_OWVAR 2
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 2
25872: PUSH
25873: LD_INT 30
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 30
25885: PUSH
25886: LD_INT 1
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: LIST
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: PPUSH
25902: CALL_OW 69
25906: ST_TO_ADDR
// if not depot then
25907: LD_VAR 0 1
25911: NOT
25912: IFFALSE 25916
// exit ;
25914: GO 25951
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
25916: LD_VAR 0 1
25920: PUSH
25921: LD_INT 1
25923: ARRAY
25924: PPUSH
25925: CALL_OW 250
25929: PPUSH
25930: LD_VAR 0 1
25934: PUSH
25935: LD_INT 1
25937: ARRAY
25938: PPUSH
25939: CALL_OW 251
25943: PPUSH
25944: LD_INT 70
25946: PPUSH
25947: CALL_OW 495
// end ;
25951: PPOPN 1
25953: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
25954: LD_EXP 46
25958: PUSH
25959: LD_EXP 80
25963: AND
25964: IFFALSE 26175
25966: GO 25968
25968: DISABLE
25969: LD_INT 0
25971: PPUSH
25972: PPUSH
25973: PPUSH
25974: PPUSH
25975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25976: LD_ADDR_VAR 0 5
25980: PUSH
25981: LD_INT 22
25983: PUSH
25984: LD_OWVAR 2
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PUSH
25993: LD_INT 21
25995: PUSH
25996: LD_INT 1
25998: PUSH
25999: EMPTY
26000: LIST
26001: LIST
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PPUSH
26007: CALL_OW 69
26011: ST_TO_ADDR
// if not tmp then
26012: LD_VAR 0 5
26016: NOT
26017: IFFALSE 26021
// exit ;
26019: GO 26175
// for i in tmp do
26021: LD_ADDR_VAR 0 1
26025: PUSH
26026: LD_VAR 0 5
26030: PUSH
26031: FOR_IN
26032: IFFALSE 26173
// begin d := rand ( 0 , 5 ) ;
26034: LD_ADDR_VAR 0 4
26038: PUSH
26039: LD_INT 0
26041: PPUSH
26042: LD_INT 5
26044: PPUSH
26045: CALL_OW 12
26049: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26050: LD_ADDR_VAR 0 2
26054: PUSH
26055: LD_VAR 0 1
26059: PPUSH
26060: CALL_OW 250
26064: PPUSH
26065: LD_VAR 0 4
26069: PPUSH
26070: LD_INT 3
26072: PPUSH
26073: LD_INT 12
26075: PPUSH
26076: CALL_OW 12
26080: PPUSH
26081: CALL_OW 272
26085: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26086: LD_ADDR_VAR 0 3
26090: PUSH
26091: LD_VAR 0 1
26095: PPUSH
26096: CALL_OW 251
26100: PPUSH
26101: LD_VAR 0 4
26105: PPUSH
26106: LD_INT 3
26108: PPUSH
26109: LD_INT 12
26111: PPUSH
26112: CALL_OW 12
26116: PPUSH
26117: CALL_OW 273
26121: ST_TO_ADDR
// if ValidHex ( x , y ) then
26122: LD_VAR 0 2
26126: PPUSH
26127: LD_VAR 0 3
26131: PPUSH
26132: CALL_OW 488
26136: IFFALSE 26171
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26138: LD_VAR 0 1
26142: PPUSH
26143: LD_VAR 0 2
26147: PPUSH
26148: LD_VAR 0 3
26152: PPUSH
26153: LD_INT 3
26155: PPUSH
26156: LD_INT 6
26158: PPUSH
26159: CALL_OW 12
26163: PPUSH
26164: LD_INT 1
26166: PPUSH
26167: CALL_OW 483
// end ;
26171: GO 26031
26173: POP
26174: POP
// end ;
26175: PPOPN 5
26177: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26178: LD_EXP 46
26182: PUSH
26183: LD_EXP 81
26187: AND
26188: IFFALSE 26282
26190: GO 26192
26192: DISABLE
26193: LD_INT 0
26195: PPUSH
26196: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
26197: LD_ADDR_VAR 0 2
26201: PUSH
26202: LD_INT 22
26204: PUSH
26205: LD_OWVAR 2
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: PUSH
26214: LD_INT 32
26216: PUSH
26217: LD_INT 1
26219: PUSH
26220: EMPTY
26221: LIST
26222: LIST
26223: PUSH
26224: LD_INT 21
26226: PUSH
26227: LD_INT 2
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: LIST
26238: PPUSH
26239: CALL_OW 69
26243: ST_TO_ADDR
// if not tmp then
26244: LD_VAR 0 2
26248: NOT
26249: IFFALSE 26253
// exit ;
26251: GO 26282
// for i in tmp do
26253: LD_ADDR_VAR 0 1
26257: PUSH
26258: LD_VAR 0 2
26262: PUSH
26263: FOR_IN
26264: IFFALSE 26280
// SetFuel ( i , 0 ) ;
26266: LD_VAR 0 1
26270: PPUSH
26271: LD_INT 0
26273: PPUSH
26274: CALL_OW 240
26278: GO 26263
26280: POP
26281: POP
// end ;
26282: PPOPN 2
26284: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
26285: LD_EXP 46
26289: PUSH
26290: LD_EXP 82
26294: AND
26295: IFFALSE 26361
26297: GO 26299
26299: DISABLE
26300: LD_INT 0
26302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
26303: LD_ADDR_VAR 0 1
26307: PUSH
26308: LD_INT 22
26310: PUSH
26311: LD_OWVAR 2
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 30
26322: PUSH
26323: LD_INT 29
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PPUSH
26334: CALL_OW 69
26338: ST_TO_ADDR
// if not tmp then
26339: LD_VAR 0 1
26343: NOT
26344: IFFALSE 26348
// exit ;
26346: GO 26361
// DestroyUnit ( tmp [ 1 ] ) ;
26348: LD_VAR 0 1
26352: PUSH
26353: LD_INT 1
26355: ARRAY
26356: PPUSH
26357: CALL_OW 65
// end ;
26361: PPOPN 1
26363: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
26364: LD_EXP 46
26368: PUSH
26369: LD_EXP 84
26373: AND
26374: IFFALSE 26503
26376: GO 26378
26378: DISABLE
26379: LD_INT 0
26381: PPUSH
// begin uc_side := 0 ;
26382: LD_ADDR_OWVAR 20
26386: PUSH
26387: LD_INT 0
26389: ST_TO_ADDR
// uc_nation := nation_arabian ;
26390: LD_ADDR_OWVAR 21
26394: PUSH
26395: LD_INT 2
26397: ST_TO_ADDR
// hc_gallery :=  ;
26398: LD_ADDR_OWVAR 33
26402: PUSH
26403: LD_STRING 
26405: ST_TO_ADDR
// hc_name :=  ;
26406: LD_ADDR_OWVAR 26
26410: PUSH
26411: LD_STRING 
26413: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
26414: LD_INT 1
26416: PPUSH
26417: LD_INT 11
26419: PPUSH
26420: LD_INT 10
26422: PPUSH
26423: CALL_OW 380
// un := CreateHuman ;
26427: LD_ADDR_VAR 0 1
26431: PUSH
26432: CALL_OW 44
26436: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26437: LD_VAR 0 1
26441: PPUSH
26442: LD_INT 1
26444: PPUSH
26445: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26449: LD_INT 35
26451: PPUSH
26452: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26456: LD_VAR 0 1
26460: PPUSH
26461: LD_INT 22
26463: PUSH
26464: LD_OWVAR 2
26468: PUSH
26469: EMPTY
26470: LIST
26471: LIST
26472: PPUSH
26473: CALL_OW 69
26477: PPUSH
26478: LD_VAR 0 1
26482: PPUSH
26483: CALL_OW 74
26487: PPUSH
26488: CALL_OW 115
// until IsDead ( un ) ;
26492: LD_VAR 0 1
26496: PPUSH
26497: CALL_OW 301
26501: IFFALSE 26449
// end ;
26503: PPOPN 1
26505: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
26506: LD_EXP 46
26510: PUSH
26511: LD_EXP 86
26515: AND
26516: IFFALSE 26528
26518: GO 26520
26520: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
26521: LD_STRING earthquake(getX(game), 0, 32)
26523: PPUSH
26524: CALL_OW 559
26528: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
26529: LD_EXP 46
26533: PUSH
26534: LD_EXP 87
26538: AND
26539: IFFALSE 26630
26541: GO 26543
26543: DISABLE
26544: LD_INT 0
26546: PPUSH
// begin enable ;
26547: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
26548: LD_ADDR_VAR 0 1
26552: PUSH
26553: LD_INT 22
26555: PUSH
26556: LD_OWVAR 2
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 21
26567: PUSH
26568: LD_INT 2
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: LD_INT 33
26577: PUSH
26578: LD_INT 3
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: LIST
26589: PPUSH
26590: CALL_OW 69
26594: ST_TO_ADDR
// if not tmp then
26595: LD_VAR 0 1
26599: NOT
26600: IFFALSE 26604
// exit ;
26602: GO 26630
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
26604: LD_VAR 0 1
26608: PUSH
26609: LD_INT 1
26611: PPUSH
26612: LD_VAR 0 1
26616: PPUSH
26617: CALL_OW 12
26621: ARRAY
26622: PPUSH
26623: LD_INT 1
26625: PPUSH
26626: CALL_OW 234
// end ;
26630: PPOPN 1
26632: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
26633: LD_EXP 46
26637: PUSH
26638: LD_EXP 88
26642: AND
26643: IFFALSE 26784
26645: GO 26647
26647: DISABLE
26648: LD_INT 0
26650: PPUSH
26651: PPUSH
26652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26653: LD_ADDR_VAR 0 3
26657: PUSH
26658: LD_INT 22
26660: PUSH
26661: LD_OWVAR 2
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 25
26672: PUSH
26673: LD_INT 1
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PUSH
26680: EMPTY
26681: LIST
26682: LIST
26683: PPUSH
26684: CALL_OW 69
26688: ST_TO_ADDR
// if not tmp then
26689: LD_VAR 0 3
26693: NOT
26694: IFFALSE 26698
// exit ;
26696: GO 26784
// un := tmp [ rand ( 1 , tmp ) ] ;
26698: LD_ADDR_VAR 0 2
26702: PUSH
26703: LD_VAR 0 3
26707: PUSH
26708: LD_INT 1
26710: PPUSH
26711: LD_VAR 0 3
26715: PPUSH
26716: CALL_OW 12
26720: ARRAY
26721: ST_TO_ADDR
// if Crawls ( un ) then
26722: LD_VAR 0 2
26726: PPUSH
26727: CALL_OW 318
26731: IFFALSE 26742
// ComWalk ( un ) ;
26733: LD_VAR 0 2
26737: PPUSH
26738: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
26742: LD_VAR 0 2
26746: PPUSH
26747: LD_INT 9
26749: PPUSH
26750: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
26754: LD_INT 28
26756: PPUSH
26757: LD_OWVAR 2
26761: PPUSH
26762: LD_INT 2
26764: PPUSH
26765: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
26769: LD_INT 29
26771: PPUSH
26772: LD_OWVAR 2
26776: PPUSH
26777: LD_INT 2
26779: PPUSH
26780: CALL_OW 322
// end ;
26784: PPOPN 3
26786: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
26787: LD_EXP 46
26791: PUSH
26792: LD_EXP 89
26796: AND
26797: IFFALSE 26908
26799: GO 26801
26801: DISABLE
26802: LD_INT 0
26804: PPUSH
26805: PPUSH
26806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26807: LD_ADDR_VAR 0 3
26811: PUSH
26812: LD_INT 22
26814: PUSH
26815: LD_OWVAR 2
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: LD_INT 25
26826: PUSH
26827: LD_INT 1
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PPUSH
26838: CALL_OW 69
26842: ST_TO_ADDR
// if not tmp then
26843: LD_VAR 0 3
26847: NOT
26848: IFFALSE 26852
// exit ;
26850: GO 26908
// un := tmp [ rand ( 1 , tmp ) ] ;
26852: LD_ADDR_VAR 0 2
26856: PUSH
26857: LD_VAR 0 3
26861: PUSH
26862: LD_INT 1
26864: PPUSH
26865: LD_VAR 0 3
26869: PPUSH
26870: CALL_OW 12
26874: ARRAY
26875: ST_TO_ADDR
// if Crawls ( un ) then
26876: LD_VAR 0 2
26880: PPUSH
26881: CALL_OW 318
26885: IFFALSE 26896
// ComWalk ( un ) ;
26887: LD_VAR 0 2
26891: PPUSH
26892: CALL_OW 138
// SetClass ( un , class_mortar ) ;
26896: LD_VAR 0 2
26900: PPUSH
26901: LD_INT 8
26903: PPUSH
26904: CALL_OW 336
// end ;
26908: PPOPN 3
26910: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
26911: LD_EXP 46
26915: PUSH
26916: LD_EXP 90
26920: AND
26921: IFFALSE 27065
26923: GO 26925
26925: DISABLE
26926: LD_INT 0
26928: PPUSH
26929: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
26930: LD_ADDR_VAR 0 2
26934: PUSH
26935: LD_INT 22
26937: PUSH
26938: LD_OWVAR 2
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: PUSH
26947: LD_INT 21
26949: PUSH
26950: LD_INT 2
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PUSH
26957: LD_INT 2
26959: PUSH
26960: LD_INT 34
26962: PUSH
26963: LD_INT 12
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PUSH
26970: LD_INT 34
26972: PUSH
26973: LD_INT 51
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 34
26982: PUSH
26983: LD_INT 32
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: EMPTY
26991: LIST
26992: LIST
26993: LIST
26994: LIST
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: LIST
27000: PPUSH
27001: CALL_OW 69
27005: ST_TO_ADDR
// if not tmp then
27006: LD_VAR 0 2
27010: NOT
27011: IFFALSE 27015
// exit ;
27013: GO 27065
// for i in tmp do
27015: LD_ADDR_VAR 0 1
27019: PUSH
27020: LD_VAR 0 2
27024: PUSH
27025: FOR_IN
27026: IFFALSE 27063
// if GetCargo ( i , mat_artifact ) = 0 then
27028: LD_VAR 0 1
27032: PPUSH
27033: LD_INT 4
27035: PPUSH
27036: CALL_OW 289
27040: PUSH
27041: LD_INT 0
27043: EQUAL
27044: IFFALSE 27061
// SetCargo ( i , mat_siberit , 100 ) ;
27046: LD_VAR 0 1
27050: PPUSH
27051: LD_INT 3
27053: PPUSH
27054: LD_INT 100
27056: PPUSH
27057: CALL_OW 290
27061: GO 27025
27063: POP
27064: POP
// end ;
27065: PPOPN 2
27067: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27068: LD_EXP 46
27072: PUSH
27073: LD_EXP 91
27077: AND
27078: IFFALSE 27231
27080: GO 27082
27082: DISABLE
27083: LD_INT 0
27085: PPUSH
27086: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27087: LD_ADDR_VAR 0 2
27091: PUSH
27092: LD_INT 22
27094: PUSH
27095: LD_OWVAR 2
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PPUSH
27104: CALL_OW 69
27108: ST_TO_ADDR
// if not tmp then
27109: LD_VAR 0 2
27113: NOT
27114: IFFALSE 27118
// exit ;
27116: GO 27231
// for i := 1 to 2 do
27118: LD_ADDR_VAR 0 1
27122: PUSH
27123: DOUBLE
27124: LD_INT 1
27126: DEC
27127: ST_TO_ADDR
27128: LD_INT 2
27130: PUSH
27131: FOR_TO
27132: IFFALSE 27229
// begin uc_side := your_side ;
27134: LD_ADDR_OWVAR 20
27138: PUSH
27139: LD_OWVAR 2
27143: ST_TO_ADDR
// uc_nation := nation_american ;
27144: LD_ADDR_OWVAR 21
27148: PUSH
27149: LD_INT 1
27151: ST_TO_ADDR
// vc_chassis := us_morphling ;
27152: LD_ADDR_OWVAR 37
27156: PUSH
27157: LD_INT 5
27159: ST_TO_ADDR
// vc_engine := engine_siberite ;
27160: LD_ADDR_OWVAR 39
27164: PUSH
27165: LD_INT 3
27167: ST_TO_ADDR
// vc_control := control_computer ;
27168: LD_ADDR_OWVAR 38
27172: PUSH
27173: LD_INT 3
27175: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27176: LD_ADDR_OWVAR 40
27180: PUSH
27181: LD_INT 10
27183: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
27184: CALL_OW 45
27188: PPUSH
27189: LD_VAR 0 2
27193: PUSH
27194: LD_INT 1
27196: ARRAY
27197: PPUSH
27198: CALL_OW 250
27202: PPUSH
27203: LD_VAR 0 2
27207: PUSH
27208: LD_INT 1
27210: ARRAY
27211: PPUSH
27212: CALL_OW 251
27216: PPUSH
27217: LD_INT 12
27219: PPUSH
27220: LD_INT 1
27222: PPUSH
27223: CALL_OW 50
// end ;
27227: GO 27131
27229: POP
27230: POP
// end ;
27231: PPOPN 2
27233: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
27234: LD_EXP 46
27238: PUSH
27239: LD_EXP 92
27243: AND
27244: IFFALSE 27466
27246: GO 27248
27248: DISABLE
27249: LD_INT 0
27251: PPUSH
27252: PPUSH
27253: PPUSH
27254: PPUSH
27255: PPUSH
27256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27257: LD_ADDR_VAR 0 6
27261: PUSH
27262: LD_INT 22
27264: PUSH
27265: LD_OWVAR 2
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: LD_INT 21
27276: PUSH
27277: LD_INT 1
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 3
27286: PUSH
27287: LD_INT 23
27289: PUSH
27290: LD_INT 0
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: EMPTY
27298: LIST
27299: LIST
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: LIST
27305: PPUSH
27306: CALL_OW 69
27310: ST_TO_ADDR
// if not tmp then
27311: LD_VAR 0 6
27315: NOT
27316: IFFALSE 27320
// exit ;
27318: GO 27466
// s1 := rand ( 1 , 4 ) ;
27320: LD_ADDR_VAR 0 2
27324: PUSH
27325: LD_INT 1
27327: PPUSH
27328: LD_INT 4
27330: PPUSH
27331: CALL_OW 12
27335: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
27336: LD_ADDR_VAR 0 4
27340: PUSH
27341: LD_VAR 0 6
27345: PUSH
27346: LD_INT 1
27348: ARRAY
27349: PPUSH
27350: LD_VAR 0 2
27354: PPUSH
27355: CALL_OW 259
27359: ST_TO_ADDR
// if s1 = 1 then
27360: LD_VAR 0 2
27364: PUSH
27365: LD_INT 1
27367: EQUAL
27368: IFFALSE 27388
// s2 := rand ( 2 , 4 ) else
27370: LD_ADDR_VAR 0 3
27374: PUSH
27375: LD_INT 2
27377: PPUSH
27378: LD_INT 4
27380: PPUSH
27381: CALL_OW 12
27385: ST_TO_ADDR
27386: GO 27396
// s2 := 1 ;
27388: LD_ADDR_VAR 0 3
27392: PUSH
27393: LD_INT 1
27395: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
27396: LD_ADDR_VAR 0 5
27400: PUSH
27401: LD_VAR 0 6
27405: PUSH
27406: LD_INT 1
27408: ARRAY
27409: PPUSH
27410: LD_VAR 0 3
27414: PPUSH
27415: CALL_OW 259
27419: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
27420: LD_VAR 0 6
27424: PUSH
27425: LD_INT 1
27427: ARRAY
27428: PPUSH
27429: LD_VAR 0 2
27433: PPUSH
27434: LD_VAR 0 5
27438: PPUSH
27439: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
27443: LD_VAR 0 6
27447: PUSH
27448: LD_INT 1
27450: ARRAY
27451: PPUSH
27452: LD_VAR 0 3
27456: PPUSH
27457: LD_VAR 0 4
27461: PPUSH
27462: CALL_OW 237
// end ;
27466: PPOPN 6
27468: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
27469: LD_EXP 46
27473: PUSH
27474: LD_EXP 93
27478: AND
27479: IFFALSE 27558
27481: GO 27483
27483: DISABLE
27484: LD_INT 0
27486: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
27487: LD_ADDR_VAR 0 1
27491: PUSH
27492: LD_INT 22
27494: PUSH
27495: LD_OWVAR 2
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 30
27506: PUSH
27507: LD_INT 3
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: EMPTY
27515: LIST
27516: LIST
27517: PPUSH
27518: CALL_OW 69
27522: ST_TO_ADDR
// if not tmp then
27523: LD_VAR 0 1
27527: NOT
27528: IFFALSE 27532
// exit ;
27530: GO 27558
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 1
27539: PPUSH
27540: LD_VAR 0 1
27544: PPUSH
27545: CALL_OW 12
27549: ARRAY
27550: PPUSH
27551: LD_INT 1
27553: PPUSH
27554: CALL_OW 234
// end ;
27558: PPOPN 1
27560: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
27561: LD_EXP 46
27565: PUSH
27566: LD_EXP 94
27570: AND
27571: IFFALSE 27683
27573: GO 27575
27575: DISABLE
27576: LD_INT 0
27578: PPUSH
27579: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
27580: LD_ADDR_VAR 0 2
27584: PUSH
27585: LD_INT 22
27587: PUSH
27588: LD_OWVAR 2
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PUSH
27597: LD_INT 2
27599: PUSH
27600: LD_INT 30
27602: PUSH
27603: LD_INT 27
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 30
27612: PUSH
27613: LD_INT 26
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 30
27622: PUSH
27623: LD_INT 28
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: EMPTY
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PPUSH
27640: CALL_OW 69
27644: ST_TO_ADDR
// if not tmp then
27645: LD_VAR 0 2
27649: NOT
27650: IFFALSE 27654
// exit ;
27652: GO 27683
// for i in tmp do
27654: LD_ADDR_VAR 0 1
27658: PUSH
27659: LD_VAR 0 2
27663: PUSH
27664: FOR_IN
27665: IFFALSE 27681
// SetLives ( i , 1 ) ;
27667: LD_VAR 0 1
27671: PPUSH
27672: LD_INT 1
27674: PPUSH
27675: CALL_OW 234
27679: GO 27664
27681: POP
27682: POP
// end ;
27683: PPOPN 2
27685: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
27686: LD_EXP 46
27690: PUSH
27691: LD_EXP 95
27695: AND
27696: IFFALSE 27966
27698: GO 27700
27700: DISABLE
27701: LD_INT 0
27703: PPUSH
27704: PPUSH
27705: PPUSH
// begin i := rand ( 1 , 7 ) ;
27706: LD_ADDR_VAR 0 1
27710: PUSH
27711: LD_INT 1
27713: PPUSH
27714: LD_INT 7
27716: PPUSH
27717: CALL_OW 12
27721: ST_TO_ADDR
// case i of 1 :
27722: LD_VAR 0 1
27726: PUSH
27727: LD_INT 1
27729: DOUBLE
27730: EQUAL
27731: IFTRUE 27735
27733: GO 27745
27735: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
27736: LD_STRING earthquake(getX(game), 0, 32)
27738: PPUSH
27739: CALL_OW 559
27743: GO 27966
27745: LD_INT 2
27747: DOUBLE
27748: EQUAL
27749: IFTRUE 27753
27751: GO 27763
27753: POP
// ToLua ( displayStucuk(); ) ; 3 :
27754: LD_STRING displayStucuk();
27756: PPUSH
27757: CALL_OW 559
27761: GO 27966
27763: LD_INT 3
27765: DOUBLE
27766: EQUAL
27767: IFTRUE 27771
27769: GO 27875
27771: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27772: LD_ADDR_VAR 0 2
27776: PUSH
27777: LD_INT 22
27779: PUSH
27780: LD_OWVAR 2
27784: PUSH
27785: EMPTY
27786: LIST
27787: LIST
27788: PUSH
27789: LD_INT 25
27791: PUSH
27792: LD_INT 1
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PPUSH
27803: CALL_OW 69
27807: ST_TO_ADDR
// if not tmp then
27808: LD_VAR 0 2
27812: NOT
27813: IFFALSE 27817
// exit ;
27815: GO 27966
// un := tmp [ rand ( 1 , tmp ) ] ;
27817: LD_ADDR_VAR 0 3
27821: PUSH
27822: LD_VAR 0 2
27826: PUSH
27827: LD_INT 1
27829: PPUSH
27830: LD_VAR 0 2
27834: PPUSH
27835: CALL_OW 12
27839: ARRAY
27840: ST_TO_ADDR
// if Crawls ( un ) then
27841: LD_VAR 0 3
27845: PPUSH
27846: CALL_OW 318
27850: IFFALSE 27861
// ComWalk ( un ) ;
27852: LD_VAR 0 3
27856: PPUSH
27857: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27861: LD_VAR 0 3
27865: PPUSH
27866: LD_INT 8
27868: PPUSH
27869: CALL_OW 336
// end ; 4 :
27873: GO 27966
27875: LD_INT 4
27877: DOUBLE
27878: EQUAL
27879: IFTRUE 27883
27881: GO 27944
27883: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27884: LD_ADDR_VAR 0 2
27888: PUSH
27889: LD_INT 22
27891: PUSH
27892: LD_OWVAR 2
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 30
27903: PUSH
27904: LD_INT 29
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PPUSH
27915: CALL_OW 69
27919: ST_TO_ADDR
// if not tmp then
27920: LD_VAR 0 2
27924: NOT
27925: IFFALSE 27929
// exit ;
27927: GO 27966
// DestroyUnit ( tmp [ 1 ] ) ;
27929: LD_VAR 0 2
27933: PUSH
27934: LD_INT 1
27936: ARRAY
27937: PPUSH
27938: CALL_OW 65
// end ; 5 .. 7 :
27942: GO 27966
27944: LD_INT 5
27946: DOUBLE
27947: GREATEREQUAL
27948: IFFALSE 27956
27950: LD_INT 7
27952: DOUBLE
27953: LESSEQUAL
27954: IFTRUE 27958
27956: GO 27965
27958: POP
// StreamSibBomb ; end ;
27959: CALL 24260 0 0
27963: GO 27966
27965: POP
// end ;
27966: PPOPN 3
27968: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
27969: LD_EXP 46
27973: PUSH
27974: LD_EXP 96
27978: AND
27979: IFFALSE 28135
27981: GO 27983
27983: DISABLE
27984: LD_INT 0
27986: PPUSH
27987: PPUSH
27988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
27989: LD_ADDR_VAR 0 2
27993: PUSH
27994: LD_INT 81
27996: PUSH
27997: LD_OWVAR 2
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 2
28008: PUSH
28009: LD_INT 21
28011: PUSH
28012: LD_INT 1
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: LD_INT 21
28021: PUSH
28022: LD_INT 2
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: LIST
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PPUSH
28038: CALL_OW 69
28042: ST_TO_ADDR
// if not tmp then
28043: LD_VAR 0 2
28047: NOT
28048: IFFALSE 28052
// exit ;
28050: GO 28135
// p := 0 ;
28052: LD_ADDR_VAR 0 3
28056: PUSH
28057: LD_INT 0
28059: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28060: LD_INT 35
28062: PPUSH
28063: CALL_OW 67
// p := p + 1 ;
28067: LD_ADDR_VAR 0 3
28071: PUSH
28072: LD_VAR 0 3
28076: PUSH
28077: LD_INT 1
28079: PLUS
28080: ST_TO_ADDR
// for i in tmp do
28081: LD_ADDR_VAR 0 1
28085: PUSH
28086: LD_VAR 0 2
28090: PUSH
28091: FOR_IN
28092: IFFALSE 28123
// if GetLives ( i ) < 1000 then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 256
28103: PUSH
28104: LD_INT 1000
28106: LESS
28107: IFFALSE 28121
// SetLives ( i , 1000 ) ;
28109: LD_VAR 0 1
28113: PPUSH
28114: LD_INT 1000
28116: PPUSH
28117: CALL_OW 234
28121: GO 28091
28123: POP
28124: POP
// until p > 20 ;
28125: LD_VAR 0 3
28129: PUSH
28130: LD_INT 20
28132: GREATER
28133: IFFALSE 28060
// end ;
28135: PPOPN 3
28137: END
// every 0 0$1 trigger StreamModeActive and sTime do
28138: LD_EXP 46
28142: PUSH
28143: LD_EXP 97
28147: AND
28148: IFFALSE 28183
28150: GO 28152
28152: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28153: LD_INT 28
28155: PPUSH
28156: LD_OWVAR 2
28160: PPUSH
28161: LD_INT 2
28163: PPUSH
28164: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28168: LD_INT 30
28170: PPUSH
28171: LD_OWVAR 2
28175: PPUSH
28176: LD_INT 2
28178: PPUSH
28179: CALL_OW 322
// end ;
28183: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28184: LD_EXP 46
28188: PUSH
28189: LD_EXP 98
28193: AND
28194: IFFALSE 28315
28196: GO 28198
28198: DISABLE
28199: LD_INT 0
28201: PPUSH
28202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28203: LD_ADDR_VAR 0 2
28207: PUSH
28208: LD_INT 22
28210: PUSH
28211: LD_OWVAR 2
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: LD_INT 21
28222: PUSH
28223: LD_INT 1
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: LD_INT 3
28232: PUSH
28233: LD_INT 23
28235: PUSH
28236: LD_INT 0
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: LIST
28251: PPUSH
28252: CALL_OW 69
28256: ST_TO_ADDR
// if not tmp then
28257: LD_VAR 0 2
28261: NOT
28262: IFFALSE 28266
// exit ;
28264: GO 28315
// for i in tmp do
28266: LD_ADDR_VAR 0 1
28270: PUSH
28271: LD_VAR 0 2
28275: PUSH
28276: FOR_IN
28277: IFFALSE 28313
// begin if Crawls ( i ) then
28279: LD_VAR 0 1
28283: PPUSH
28284: CALL_OW 318
28288: IFFALSE 28299
// ComWalk ( i ) ;
28290: LD_VAR 0 1
28294: PPUSH
28295: CALL_OW 138
// SetClass ( i , 2 ) ;
28299: LD_VAR 0 1
28303: PPUSH
28304: LD_INT 2
28306: PPUSH
28307: CALL_OW 336
// end ;
28311: GO 28276
28313: POP
28314: POP
// end ;
28315: PPOPN 2
28317: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
28318: LD_EXP 46
28322: PUSH
28323: LD_EXP 99
28327: AND
28328: IFFALSE 28533
28330: GO 28332
28332: DISABLE
28333: LD_INT 0
28335: PPUSH
28336: PPUSH
28337: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
28338: LD_OWVAR 2
28342: PPUSH
28343: LD_INT 9
28345: PPUSH
28346: LD_INT 1
28348: PPUSH
28349: LD_INT 1
28351: PPUSH
28352: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
28356: LD_INT 9
28358: PPUSH
28359: LD_OWVAR 2
28363: PPUSH
28364: CALL_OW 343
// hc_name := Dark Warrior ;
28368: LD_ADDR_OWVAR 26
28372: PUSH
28373: LD_STRING Dark Warrior
28375: ST_TO_ADDR
// hc_gallery :=  ;
28376: LD_ADDR_OWVAR 33
28380: PUSH
28381: LD_STRING 
28383: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
28384: LD_INT 1
28386: PPUSH
28387: LD_INT 1
28389: PPUSH
28390: LD_INT 10
28392: PPUSH
28393: CALL_OW 380
// un := CreateHuman ;
28397: LD_ADDR_VAR 0 3
28401: PUSH
28402: CALL_OW 44
28406: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28407: LD_VAR 0 3
28411: PPUSH
28412: LD_INT 1
28414: PPUSH
28415: CALL_OW 51
// p := 0 ;
28419: LD_ADDR_VAR 0 2
28423: PUSH
28424: LD_INT 0
28426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28427: LD_INT 35
28429: PPUSH
28430: CALL_OW 67
// if GetLives ( un ) < 1000 then
28434: LD_VAR 0 3
28438: PPUSH
28439: CALL_OW 256
28443: PUSH
28444: LD_INT 1000
28446: LESS
28447: IFFALSE 28461
// SetLives ( un , 1000 ) ;
28449: LD_VAR 0 3
28453: PPUSH
28454: LD_INT 1000
28456: PPUSH
28457: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_INT 81
28468: PUSH
28469: LD_OWVAR 2
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PPUSH
28478: CALL_OW 69
28482: PPUSH
28483: LD_VAR 0 3
28487: PPUSH
28488: CALL_OW 74
28492: PPUSH
28493: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
28497: LD_VAR 0 2
28501: PUSH
28502: LD_INT 60
28504: GREATER
28505: PUSH
28506: LD_VAR 0 3
28510: PPUSH
28511: CALL_OW 301
28515: OR
28516: IFFALSE 28427
// if un then
28518: LD_VAR 0 3
28522: IFFALSE 28533
// RemoveUnit ( un ) ;
28524: LD_VAR 0 3
28528: PPUSH
28529: CALL_OW 64
// end ; end_of_file
28533: PPOPN 3
28535: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
28536: LD_INT 0
28538: PPUSH
28539: PPUSH
28540: PPUSH
28541: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
28542: LD_VAR 0 1
28546: PPUSH
28547: CALL_OW 264
28551: PUSH
28552: LD_EXP 45
28556: EQUAL
28557: IFFALSE 28629
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
28559: LD_INT 68
28561: PPUSH
28562: LD_VAR 0 1
28566: PPUSH
28567: CALL_OW 255
28571: PPUSH
28572: CALL_OW 321
28576: PUSH
28577: LD_INT 2
28579: EQUAL
28580: IFFALSE 28592
// eff := 70 else
28582: LD_ADDR_VAR 0 6
28586: PUSH
28587: LD_INT 70
28589: ST_TO_ADDR
28590: GO 28600
// eff := 30 ;
28592: LD_ADDR_VAR 0 6
28596: PUSH
28597: LD_INT 30
28599: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
28600: LD_VAR 0 1
28604: PPUSH
28605: CALL_OW 250
28609: PPUSH
28610: LD_VAR 0 1
28614: PPUSH
28615: CALL_OW 251
28619: PPUSH
28620: LD_VAR 0 6
28624: PPUSH
28625: CALL_OW 495
// end ; end ;
28629: LD_VAR 0 4
28633: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
28634: LD_INT 0
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
28640: PPUSH
28641: PPUSH
// if cmd = 124 then
28642: LD_VAR 0 1
28646: PUSH
28647: LD_INT 124
28649: EQUAL
28650: IFFALSE 28856
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
28652: LD_ADDR_VAR 0 5
28656: PUSH
28657: LD_INT 2
28659: PUSH
28660: LD_INT 34
28662: PUSH
28663: LD_INT 53
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 34
28672: PUSH
28673: LD_INT 14
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: PPUSH
28685: CALL_OW 69
28689: ST_TO_ADDR
// if not tmp then
28690: LD_VAR 0 5
28694: NOT
28695: IFFALSE 28699
// exit ;
28697: GO 28856
// for i in tmp do
28699: LD_ADDR_VAR 0 3
28703: PUSH
28704: LD_VAR 0 5
28708: PUSH
28709: FOR_IN
28710: IFFALSE 28854
// begin taskList := GetTaskList ( i ) ;
28712: LD_ADDR_VAR 0 6
28716: PUSH
28717: LD_VAR 0 3
28721: PPUSH
28722: CALL_OW 437
28726: ST_TO_ADDR
// if not taskList then
28727: LD_VAR 0 6
28731: NOT
28732: IFFALSE 28736
// continue ;
28734: GO 28709
// for j = 1 to taskList do
28736: LD_ADDR_VAR 0 4
28740: PUSH
28741: DOUBLE
28742: LD_INT 1
28744: DEC
28745: ST_TO_ADDR
28746: LD_VAR 0 6
28750: PUSH
28751: FOR_TO
28752: IFFALSE 28850
// if taskList [ j ] [ 1 ] = | then
28754: LD_VAR 0 6
28758: PUSH
28759: LD_VAR 0 4
28763: ARRAY
28764: PUSH
28765: LD_INT 1
28767: ARRAY
28768: PUSH
28769: LD_STRING |
28771: EQUAL
28772: IFFALSE 28848
// begin _taskList := Delete ( taskList , 1 ) ;
28774: LD_ADDR_VAR 0 7
28778: PUSH
28779: LD_VAR 0 6
28783: PPUSH
28784: LD_INT 1
28786: PPUSH
28787: CALL_OW 3
28791: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
28792: LD_VAR 0 3
28796: PPUSH
28797: LD_VAR 0 7
28801: PPUSH
28802: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
28806: LD_VAR 0 3
28810: PPUSH
28811: LD_VAR 0 6
28815: PUSH
28816: LD_VAR 0 4
28820: ARRAY
28821: PUSH
28822: LD_INT 2
28824: ARRAY
28825: PPUSH
28826: LD_VAR 0 6
28830: PUSH
28831: LD_VAR 0 4
28835: ARRAY
28836: PUSH
28837: LD_INT 3
28839: ARRAY
28840: PPUSH
28841: LD_INT 8
28843: PPUSH
28844: CALL 28861 0 4
// end ;
28848: GO 28751
28850: POP
28851: POP
// end ;
28852: GO 28709
28854: POP
28855: POP
// end ; end ;
28856: LD_VAR 0 2
28860: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
28861: LD_INT 0
28863: PPUSH
28864: PPUSH
28865: PPUSH
28866: PPUSH
28867: PPUSH
28868: PPUSH
28869: PPUSH
28870: PPUSH
28871: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
28872: LD_VAR 0 1
28876: NOT
28877: PUSH
28878: LD_VAR 0 2
28882: PPUSH
28883: LD_VAR 0 3
28887: PPUSH
28888: CALL_OW 488
28892: NOT
28893: OR
28894: PUSH
28895: LD_VAR 0 4
28899: NOT
28900: OR
28901: IFFALSE 28905
// exit ;
28903: GO 29245
// list := [ ] ;
28905: LD_ADDR_VAR 0 13
28909: PUSH
28910: EMPTY
28911: ST_TO_ADDR
// if x - r < 0 then
28912: LD_VAR 0 2
28916: PUSH
28917: LD_VAR 0 4
28921: MINUS
28922: PUSH
28923: LD_INT 0
28925: LESS
28926: IFFALSE 28938
// min_x := 0 else
28928: LD_ADDR_VAR 0 7
28932: PUSH
28933: LD_INT 0
28935: ST_TO_ADDR
28936: GO 28954
// min_x := x - r ;
28938: LD_ADDR_VAR 0 7
28942: PUSH
28943: LD_VAR 0 2
28947: PUSH
28948: LD_VAR 0 4
28952: MINUS
28953: ST_TO_ADDR
// if y - r < 0 then
28954: LD_VAR 0 3
28958: PUSH
28959: LD_VAR 0 4
28963: MINUS
28964: PUSH
28965: LD_INT 0
28967: LESS
28968: IFFALSE 28980
// min_y := 0 else
28970: LD_ADDR_VAR 0 8
28974: PUSH
28975: LD_INT 0
28977: ST_TO_ADDR
28978: GO 28996
// min_y := y - r ;
28980: LD_ADDR_VAR 0 8
28984: PUSH
28985: LD_VAR 0 3
28989: PUSH
28990: LD_VAR 0 4
28994: MINUS
28995: ST_TO_ADDR
// max_x := x + r ;
28996: LD_ADDR_VAR 0 9
29000: PUSH
29001: LD_VAR 0 2
29005: PUSH
29006: LD_VAR 0 4
29010: PLUS
29011: ST_TO_ADDR
// max_y := y + r ;
29012: LD_ADDR_VAR 0 10
29016: PUSH
29017: LD_VAR 0 3
29021: PUSH
29022: LD_VAR 0 4
29026: PLUS
29027: ST_TO_ADDR
// for _x = min_x to max_x do
29028: LD_ADDR_VAR 0 11
29032: PUSH
29033: DOUBLE
29034: LD_VAR 0 7
29038: DEC
29039: ST_TO_ADDR
29040: LD_VAR 0 9
29044: PUSH
29045: FOR_TO
29046: IFFALSE 29163
// for _y = min_y to max_y do
29048: LD_ADDR_VAR 0 12
29052: PUSH
29053: DOUBLE
29054: LD_VAR 0 8
29058: DEC
29059: ST_TO_ADDR
29060: LD_VAR 0 10
29064: PUSH
29065: FOR_TO
29066: IFFALSE 29159
// begin if not ValidHex ( _x , _y ) then
29068: LD_VAR 0 11
29072: PPUSH
29073: LD_VAR 0 12
29077: PPUSH
29078: CALL_OW 488
29082: NOT
29083: IFFALSE 29087
// continue ;
29085: GO 29065
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29087: LD_VAR 0 11
29091: PPUSH
29092: LD_VAR 0 12
29096: PPUSH
29097: CALL_OW 351
29101: PUSH
29102: LD_VAR 0 11
29106: PPUSH
29107: LD_VAR 0 12
29111: PPUSH
29112: CALL_OW 554
29116: AND
29117: IFFALSE 29157
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29119: LD_ADDR_VAR 0 13
29123: PUSH
29124: LD_VAR 0 13
29128: PPUSH
29129: LD_VAR 0 13
29133: PUSH
29134: LD_INT 1
29136: PLUS
29137: PPUSH
29138: LD_VAR 0 11
29142: PUSH
29143: LD_VAR 0 12
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PPUSH
29152: CALL_OW 2
29156: ST_TO_ADDR
// end ;
29157: GO 29065
29159: POP
29160: POP
29161: GO 29045
29163: POP
29164: POP
// if not list then
29165: LD_VAR 0 13
29169: NOT
29170: IFFALSE 29174
// exit ;
29172: GO 29245
// for i in list do
29174: LD_ADDR_VAR 0 6
29178: PUSH
29179: LD_VAR 0 13
29183: PUSH
29184: FOR_IN
29185: IFFALSE 29243
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29187: LD_VAR 0 1
29191: PPUSH
29192: LD_STRING M
29194: PUSH
29195: LD_VAR 0 6
29199: PUSH
29200: LD_INT 1
29202: ARRAY
29203: PUSH
29204: LD_VAR 0 6
29208: PUSH
29209: LD_INT 2
29211: ARRAY
29212: PUSH
29213: LD_INT 0
29215: PUSH
29216: LD_INT 0
29218: PUSH
29219: LD_INT 0
29221: PUSH
29222: LD_INT 0
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: PUSH
29234: EMPTY
29235: LIST
29236: PPUSH
29237: CALL_OW 447
29241: GO 29184
29243: POP
29244: POP
// end ;
29245: LD_VAR 0 5
29249: RET
