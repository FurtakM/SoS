// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13721 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2966 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := 0 ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// hc_name := Peter McCreery ;
2391: LD_ADDR_OWVAR 26
2395: PUSH
2396: LD_STRING Peter McCreery
2398: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2399: LD_ADDR_OWVAR 33
2403: PUSH
2404: LD_STRING SecondCharsGal
2406: ST_TO_ADDR
// hc_face_number := 58 ;
2407: LD_ADDR_OWVAR 34
2411: PUSH
2412: LD_INT 58
2414: ST_TO_ADDR
// hc_sex := sex_male ;
2415: LD_ADDR_OWVAR 27
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// hc_class := 4 ;
2423: LD_ADDR_OWVAR 28
2427: PUSH
2428: LD_INT 4
2430: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 2 ] ;
2431: LD_ADDR_OWVAR 30
2435: PUSH
2436: LD_INT 0
2438: PUSH
2439: LD_INT 0
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 6 ] ;
2454: LD_ADDR_OWVAR 31
2458: PUSH
2459: LD_INT 1
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 3
2467: PUSH
2468: LD_INT 6
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// un := CreateHuman ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// SetTag ( un , 11 ) ;
2487: LD_VAR 0 5
2491: PPUSH
2492: LD_INT 11
2494: PPUSH
2495: CALL_OW 109
// tmp := tmp ^ un ;
2499: LD_ADDR_VAR 0 4
2503: PUSH
2504: LD_VAR 0 4
2508: PUSH
2509: LD_VAR 0 5
2513: ADD
2514: ST_TO_ADDR
// tmp := tmp diff 0 ;
2515: LD_ADDR_VAR 0 4
2519: PUSH
2520: LD_VAR 0 4
2524: PUSH
2525: LD_INT 0
2527: DIFF
2528: ST_TO_ADDR
// InitHc ;
2529: CALL_OW 19
// hc_name :=  ;
2533: LD_ADDR_OWVAR 26
2537: PUSH
2538: LD_STRING 
2540: ST_TO_ADDR
// hc_gallery :=  ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING 
2548: ST_TO_ADDR
// if debug then
2549: LD_EXP 2
2553: IFFALSE 2604
// begin for i = 1 to 6 do
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: DOUBLE
2561: LD_INT 1
2563: DEC
2564: ST_TO_ADDR
2565: LD_INT 6
2567: PUSH
2568: FOR_TO
2569: IFFALSE 2602
// begin PrepareHuman ( false , 1 , 6 ) ;
2571: LD_INT 0
2573: PPUSH
2574: LD_INT 1
2576: PPUSH
2577: LD_INT 6
2579: PPUSH
2580: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_VAR 0 4
2593: PUSH
2594: CALL_OW 44
2598: ADD
2599: ST_TO_ADDR
// end ;
2600: GO 2568
2602: POP
2603: POP
// end ; for i in tmp do
2604: LD_ADDR_VAR 0 2
2608: PUSH
2609: LD_VAR 0 4
2613: PUSH
2614: FOR_IN
2615: IFFALSE 2674
// begin if GetClass ( i ) in [ 2 , 3 ] then
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 257
2626: PUSH
2627: LD_INT 2
2629: PUSH
2630: LD_INT 3
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: IN
2637: IFFALSE 2651
// SetClass ( i , 1 ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 1
2646: PPUSH
2647: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 106
2658: PPUSH
2659: LD_INT 122
2661: PPUSH
2662: LD_INT 5
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 50
// end ;
2672: GO 2614
2674: POP
2675: POP
// tmp := tmp diff Gary ;
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_EXP 22
2690: DIFF
2691: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 30
2709: PUSH
2710: LD_INT 31
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PPUSH
2721: CALL_OW 69
2725: ST_TO_ADDR
// for i = 1 to b do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: DOUBLE
2732: LD_INT 1
2734: DEC
2735: ST_TO_ADDR
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_TO
2742: IFFALSE 2787
// ComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) [ i ] , b [ i ] ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_INT 25
2751: PUSH
2752: LD_INT 1
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 72
2763: PUSH
2764: LD_VAR 0 2
2768: ARRAY
2769: PPUSH
2770: LD_VAR 0 3
2774: PUSH
2775: LD_VAR 0 2
2779: ARRAY
2780: PPUSH
2781: CALL_OW 120
2785: GO 2741
2787: POP
2788: POP
// InitHc ;
2789: CALL_OW 19
// InitUc ;
2793: CALL_OW 18
// end ;
2797: LD_VAR 0 1
2801: RET
// export function PowellTransport ; var i , un ; begin
2802: LD_INT 0
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side := 4 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 4
2814: ST_TO_ADDR
// uc_nation := 1 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2823: LD_INT 1
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: LD_INT 6
2831: PPUSH
2832: CALL_OW 380
// hc_name :=  ;
2836: LD_ADDR_OWVAR 26
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING SecondCharsGal
2851: ST_TO_ADDR
// hc_face_number := 30 ;
2852: LD_ADDR_OWVAR 34
2856: PUSH
2857: LD_INT 30
2859: ST_TO_ADDR
// powell_trans := CreateHuman ;
2860: LD_ADDR_EXP 27
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// hc_face_number := 31 ;
2870: LD_ADDR_OWVAR 34
2874: PUSH
2875: LD_INT 31
2877: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2878: LD_ADDR_EXP 27
2882: PUSH
2883: LD_EXP 27
2887: PUSH
2888: CALL_OW 44
2892: ADD
2893: ST_TO_ADDR
// for i = 1 to 2 do
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: DOUBLE
2900: LD_INT 1
2902: DEC
2903: ST_TO_ADDR
2904: LD_INT 2
2906: PUSH
2907: FOR_TO
2908: IFFALSE 2959
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2910: LD_ADDR_VAR 0 3
2914: PUSH
2915: LD_INT 4
2917: PPUSH
2918: LD_INT 1
2920: PPUSH
2921: LD_INT 3
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: LD_INT 12
2932: PPUSH
2933: LD_INT 66
2935: PPUSH
2936: CALL 423 0 7
2940: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2941: LD_ADDR_EXP 27
2945: PUSH
2946: LD_EXP 27
2950: PUSH
2951: LD_VAR 0 3
2955: ADD
2956: ST_TO_ADDR
// end ;
2957: GO 2907
2959: POP
2960: POP
// end ; end_of_file
2961: LD_VAR 0 1
2965: RET
// export function Action ; var i , veh ; begin
2966: LD_INT 0
2968: PPUSH
2969: PPUSH
2970: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2971: LD_EXP 26
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: LD_INT 50
2981: PPUSH
2982: LD_INT 38
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: CALL_OW 145
// InGameOn ;
2992: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2996: LD_INT 43
2998: PPUSH
2999: LD_INT 9
3001: PPUSH
3002: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
3006: LD_EXP 21
3010: PPUSH
3011: LD_INT 54
3013: PPUSH
3014: LD_INT 34
3016: PPUSH
3017: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
3021: LD_EXP 21
3025: PPUSH
3026: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
3030: LD_EXP 21
3034: PPUSH
3035: LD_EXP 26
3039: PUSH
3040: LD_INT 1
3042: ARRAY
3043: PPUSH
3044: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// until See ( 4 , JMM ) ;
3055: LD_INT 4
3057: PPUSH
3058: LD_EXP 21
3062: PPUSH
3063: CALL_OW 292
3067: IFFALSE 3048
// CenterNowOnUnits ( JMM ) ;
3069: LD_EXP 21
3073: PPUSH
3074: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
3078: LD_EXP 21
3082: PPUSH
3083: LD_STRING D2-JMM-1
3085: PPUSH
3086: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
3090: LD_EXP 26
3094: PUSH
3095: LD_INT 3
3097: ARRAY
3098: PPUSH
3099: LD_EXP 21
3103: PPUSH
3104: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
3108: LD_EXP 26
3112: PUSH
3113: LD_INT 3
3115: ARRAY
3116: PPUSH
3117: LD_STRING D2-Eng1-1
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3124: LD_EXP 21
3128: PPUSH
3129: LD_STRING D2-JMM-2
3131: PPUSH
3132: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
3136: LD_EXP 26
3140: PUSH
3141: LD_INT 3
3143: ARRAY
3144: PPUSH
3145: LD_STRING D2-Eng1-2
3147: PPUSH
3148: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3152: LD_EXP 21
3156: PPUSH
3157: LD_STRING D2-JMM-3
3159: PPUSH
3160: CALL_OW 88
// if Houten then
3164: LD_EXP 25
3168: IFFALSE 3366
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3170: LD_ADDR_VAR 0 3
3174: PUSH
3175: LD_INT 4
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 4
3192: PPUSH
3193: LD_INT 55
3195: PPUSH
3196: CALL 423 0 7
3200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3201: LD_VAR 0 3
3205: PPUSH
3206: LD_INT 3
3208: PPUSH
3209: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3213: LD_VAR 0 3
3217: PPUSH
3218: LD_INT 46
3220: PPUSH
3221: LD_INT 19
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3231: LD_EXP 25
3235: PPUSH
3236: LD_VAR 0 3
3240: PPUSH
3241: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3245: LD_EXP 25
3249: PPUSH
3250: LD_INT 49
3252: PPUSH
3253: LD_INT 33
3255: PPUSH
3256: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3260: LD_EXP 25
3264: PPUSH
3265: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3269: LD_EXP 25
3273: PPUSH
3274: LD_EXP 21
3278: PPUSH
3279: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3283: LD_INT 35
3285: PPUSH
3286: CALL_OW 67
// until See ( 1 , Houten ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_EXP 25
3297: PPUSH
3298: CALL_OW 292
3302: IFFALSE 3283
// ComTurnUnit ( JMM , Houten ) ;
3304: LD_EXP 21
3308: PPUSH
3309: LD_EXP 25
3313: PPUSH
3314: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3318: LD_EXP 21
3322: PPUSH
3323: LD_STRING D1d-JMM-1
3325: PPUSH
3326: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3330: LD_EXP 25
3334: PPUSH
3335: LD_STRING D1-VanH-1
3337: PPUSH
3338: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3342: LD_EXP 21
3346: PPUSH
3347: LD_STRING D1-JMM-1v
3349: PPUSH
3350: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3354: LD_EXP 21
3358: PPUSH
3359: LD_STRING D1-JMM-2v
3361: PPUSH
3362: CALL_OW 88
// end ; InGameOff ;
3366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3370: LD_STRING M1
3372: PPUSH
3373: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3377: LD_INT 22
3379: PUSH
3380: LD_INT 4
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 92
3389: PUSH
3390: LD_EXP 21
3394: PPUSH
3395: CALL_OW 250
3399: PUSH
3400: LD_EXP 21
3404: PPUSH
3405: CALL_OW 251
3409: PUSH
3410: LD_INT 15
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3435: LD_EXP 26
3439: PUSH
3440: LD_EXP 21
3444: ADD
3445: PUSH
3446: LD_EXP 25
3450: ADD
3451: PPUSH
3452: CALL_OW 141
// end ;
3456: LD_VAR 0 1
3460: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3461: LD_INT 1
3463: PPUSH
3464: LD_EXP 22
3468: PPUSH
3469: CALL_OW 292
3473: PUSH
3474: LD_EXP 21
3478: PPUSH
3479: LD_EXP 22
3483: PPUSH
3484: CALL_OW 296
3488: PUSH
3489: LD_INT 6
3491: LESS
3492: AND
3493: IFFALSE 4366
3495: GO 3497
3497: DISABLE
3498: LD_INT 0
3500: PPUSH
3501: PPUSH
3502: PPUSH
3503: PPUSH
3504: PPUSH
// begin InGameOn ;
3505: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PPUSH
3519: CALL_OW 69
3523: PPUSH
3524: LD_INT 1
3526: PPUSH
3527: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3531: LD_ADDR_VAR 0 4
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 1
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 25
3561: PUSH
3562: LD_INT 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 25
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 25
3581: PUSH
3582: LD_INT 4
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// ComHold ( tmp ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3614: LD_EXP 21
3618: PPUSH
3619: LD_STRING D2-JMM-3a
3621: PPUSH
3622: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3626: LD_EXP 22
3630: PPUSH
3631: LD_EXP 21
3635: PPUSH
3636: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3640: LD_EXP 22
3644: PPUSH
3645: LD_STRING D2-Gary-3
3647: PPUSH
3648: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3652: LD_EXP 21
3656: PPUSH
3657: LD_EXP 22
3661: PPUSH
3662: CALL_OW 119
// for i in tmp do
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: LD_VAR 0 4
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3722
// begin if IsInUnit ( i ) then
3679: LD_VAR 0 5
3683: PPUSH
3684: CALL_OW 310
3688: IFFALSE 3699
// ComExitBuilding ( i ) ;
3690: LD_VAR 0 5
3694: PPUSH
3695: CALL_OW 122
// wait ( 1 ) ;
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_EXP 21
3715: PPUSH
3716: CALL_OW 119
// end ;
3720: GO 3676
3722: POP
3723: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3724: LD_ADDR_VAR 0 4
3728: PUSH
3729: LD_VAR 0 4
3733: PUSH
3734: LD_EXP 21
3738: PUSH
3739: LD_EXP 25
3743: PUSH
3744: LD_EXP 22
3748: PUSH
3749: LD_EXP 24
3753: PUSH
3754: LD_EXP 23
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: PUSH
3766: LD_EXP 26
3770: ADD
3771: DIFF
3772: ST_TO_ADDR
// if Bobby then
3773: LD_EXP 23
3777: IFFALSE 3791
// Say ( Bobby , D2-Bobby-3 ) ;
3779: LD_EXP 23
3783: PPUSH
3784: LD_STRING D2-Bobby-3
3786: PPUSH
3787: CALL_OW 88
// if Cyrus then
3791: LD_EXP 24
3795: IFFALSE 3809
// Say ( Cyrus , D2-Cyrus-3 ) ;
3797: LD_EXP 24
3801: PPUSH
3802: LD_STRING D2-Cyrus-3
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3809: LD_EXP 21
3813: PPUSH
3814: LD_STRING D2-JMM-4
3816: PPUSH
3817: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3821: LD_EXP 22
3825: PPUSH
3826: LD_STRING D2-Gary-4
3828: PPUSH
3829: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3833: LD_ADDR_VAR 0 1
3837: PUSH
3838: LD_VAR 0 4
3842: PPUSH
3843: LD_INT 26
3845: PUSH
3846: LD_INT 1
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 72
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// if Cyrus then
3862: LD_EXP 24
3866: IFFALSE 3882
// Say ( Cyrus , D2-Cyrus-4 ) else
3868: LD_EXP 24
3872: PPUSH
3873: LD_STRING D2-Cyrus-4
3875: PPUSH
3876: CALL_OW 88
3880: GO 3894
// Say ( un1 , D2-Sol1-4 ) ;
3882: LD_VAR 0 1
3886: PPUSH
3887: LD_STRING D2-Sol1-4
3889: PPUSH
3890: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3894: LD_EXP 21
3898: PPUSH
3899: LD_STRING D2-JMM-5
3901: PPUSH
3902: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3906: LD_ADDR_VAR 0 2
3910: PUSH
3911: LD_EXP 26
3915: PPUSH
3916: LD_INT 91
3918: PUSH
3919: LD_EXP 21
3923: PUSH
3924: LD_INT 10
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: LIST
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 72
3950: ST_TO_ADDR
// if un2 then
3951: LD_VAR 0 2
3955: IFFALSE 4009
// begin un2 := un2 [ un2 ] ;
3957: LD_ADDR_VAR 0 2
3961: PUSH
3962: LD_VAR 0 2
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3973: LD_VAR 0 2
3977: PPUSH
3978: LD_STRING D2-FEng1-5
3980: PPUSH
3981: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3985: LD_EXP 21
3989: PPUSH
3990: LD_STRING D2-JMM-6
3992: PPUSH
3993: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_STRING D2-FEng1-6
4004: PPUSH
4005: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_EXP 26
4018: PPUSH
4019: LD_INT 91
4021: PUSH
4022: LD_EXP 21
4026: PUSH
4027: LD_INT 10
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 72
4053: ST_TO_ADDR
// if un3 then
4054: LD_VAR 0 3
4058: IFFALSE 4113
// begin un3 := un3 [ 1 ] ;
4060: LD_ADDR_VAR 0 3
4064: PUSH
4065: LD_VAR 0 3
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
4074: LD_VAR 0 3
4078: PPUSH
4079: LD_INT 114
4081: PPUSH
4082: LD_INT 122
4084: PPUSH
4085: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
4089: LD_VAR 0 3
4093: PPUSH
4094: LD_STRING D2-Eng1-6
4096: PPUSH
4097: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4101: LD_EXP 21
4105: PPUSH
4106: LD_STRING D2-JMM-7
4108: PPUSH
4109: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
4113: LD_EXP 22
4117: PPUSH
4118: LD_STRING D2-Gary-7
4120: PPUSH
4121: CALL_OW 88
// if un2 then
4125: LD_VAR 0 2
4129: IFFALSE 4143
// Say ( un2 , D2-FEng1-7 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING D2-FEng1-7
4138: PPUSH
4139: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
4143: LD_VAR 0 1
4147: PPUSH
4148: LD_STRING D2-Sol1-7
4150: PPUSH
4151: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
4155: LD_EXP 21
4159: PPUSH
4160: LD_STRING D2-JMM-8
4162: PPUSH
4163: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PPUSH
4182: CALL_OW 141
// InGameOff ;
4186: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4190: LD_STRING M1a
4192: PPUSH
4193: CALL_OW 337
// jmm_in_ovsyenko := true ;
4197: LD_ADDR_EXP 4
4201: PUSH
4202: LD_INT 1
4204: ST_TO_ADDR
// if debug then
4205: LD_EXP 2
4209: IFFALSE 4315
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PPUSH
4244: CALL_OW 274
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_INT 1000
4254: PPUSH
4255: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4259: LD_INT 22
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 30
4271: PUSH
4272: LD_INT 0
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PPUSH
4283: CALL_OW 69
4287: PUSH
4288: LD_INT 1
4290: ARRAY
4291: PPUSH
4292: CALL_OW 274
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 1000
4302: PPUSH
4303: CALL_OW 277
// ar_can_arrive := true ;
4307: LD_ADDR_EXP 10
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4315: LD_INT 1050
4317: PPUSH
4318: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4322: LD_ADDR_VAR 0 4
4326: PUSH
4327: LD_INT 25
4329: PUSH
4330: LD_INT 14
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// if not tmp then
4342: LD_VAR 0 4
4346: NOT
4347: IFFALSE 4351
// exit ;
4349: GO 4366
// ComMoveXY ( tmp , 75 , 75 ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_INT 75
4358: PPUSH
4359: LD_INT 75
4361: PPUSH
4362: CALL_OW 111
// end ;
4366: PPOPN 5
4368: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 30
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: LD_INT 57
4394: PUSH
4395: EMPTY
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: IFFALSE 4453
4413: GO 4415
4415: DISABLE
4416: LD_INT 0
4418: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4419: LD_ADDR_VAR 0 1
4423: PUSH
4424: LD_STRING M2easy
4426: PUSH
4427: LD_STRING M2
4429: PUSH
4430: LD_STRING M2hard
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4438: LD_VAR 0 1
4442: PUSH
4443: LD_OWVAR 67
4447: ARRAY
4448: PPUSH
4449: CALL_OW 337
// end ;
4453: PPOPN 1
4455: END
// every 3 3$00 do
4456: GO 4458
4458: DISABLE
// begin DialogueOn ;
4459: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4463: LD_EXP 28
4467: PPUSH
4468: LD_STRING D3-Pow-1
4470: PPUSH
4471: CALL_OW 94
// if jmm_in_ovsyenko then
4475: LD_EXP 4
4479: IFFALSE 4507
// begin Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 21
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4493: LD_EXP 21
4497: PPUSH
4498: LD_STRING D3-JMM-1b
4500: PPUSH
4501: CALL_OW 88
// end else
4505: GO 4519
// Say ( JMM , D3-JMM-1a ) ;
4507: LD_EXP 21
4511: PPUSH
4512: LD_STRING D3-JMM-1a
4514: PPUSH
4515: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4519: LD_EXP 28
4523: PPUSH
4524: LD_STRING D3-Pow-2
4526: PPUSH
4527: CALL_OW 94
// DialogueOff ;
4531: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4535: LD_STRING M3
4537: PPUSH
4538: CALL_OW 337
// powell_want_sib := true ;
4542: LD_ADDR_EXP 5
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end ;
4550: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4551: LD_EXP 6
4555: PUSH
4556: LD_INT 0
4558: EQUAL
4559: IFFALSE 6020
4561: GO 4563
4563: DISABLE
4564: LD_INT 0
4566: PPUSH
4567: PPUSH
4568: PPUSH
4569: PPUSH
4570: PPUSH
4571: PPUSH
4572: PPUSH
4573: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4574: LD_INT 4
4576: PPUSH
4577: LD_INT 1
4579: PPUSH
4580: CALL_OW 343
// PowellTransport ;
4584: CALL 2802 0 0
// for i = 1 to 3 do
4588: LD_ADDR_VAR 0 4
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_INT 3
4600: PUSH
4601: FOR_TO
4602: IFFALSE 4669
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 6
4611: PPUSH
4612: LD_VAR 0 4
4616: PPUSH
4617: CALL_OW 287
4621: ST_TO_ADDR
// if not tmp then
4622: LD_VAR 0 1
4626: NOT
4627: IFFALSE 4631
// continue ;
4629: GO 4601
// EraseResourceArea ( terminalArea , i ) ;
4631: LD_INT 6
4633: PPUSH
4634: LD_VAR 0 4
4638: PPUSH
4639: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4643: LD_EXP 3
4647: PPUSH
4648: CALL_OW 274
4652: PPUSH
4653: LD_VAR 0 4
4657: PPUSH
4658: LD_VAR 0 1
4662: PPUSH
4663: CALL_OW 276
// end ;
4667: GO 4601
4669: POP
4670: POP
// x := 43 ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_INT 43
4678: ST_TO_ADDR
// y := 3 ;
4679: LD_ADDR_VAR 0 3
4683: PUSH
4684: LD_INT 3
4686: ST_TO_ADDR
// for i = 3 to 4 do
4687: LD_ADDR_VAR 0 4
4691: PUSH
4692: DOUBLE
4693: LD_INT 3
4695: DEC
4696: ST_TO_ADDR
4697: LD_INT 4
4699: PUSH
4700: FOR_TO
4701: IFFALSE 4892
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4703: LD_EXP 27
4707: PUSH
4708: LD_VAR 0 4
4712: ARRAY
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4721: LD_EXP 27
4725: PUSH
4726: LD_VAR 0 4
4730: ARRAY
4731: PPUSH
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_VAR 0 3
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4749: LD_EXP 27
4753: PUSH
4754: LD_VAR 0 4
4758: PUSH
4759: LD_INT 2
4761: MINUS
4762: ARRAY
4763: PPUSH
4764: LD_EXP 27
4768: PUSH
4769: LD_VAR 0 4
4773: ARRAY
4774: PPUSH
4775: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4779: LD_EXP 27
4783: PUSH
4784: LD_VAR 0 4
4788: ARRAY
4789: PPUSH
4790: LD_INT 1
4792: PPUSH
4793: LD_INT 100
4795: PPUSH
4796: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4800: LD_EXP 27
4804: PUSH
4805: LD_VAR 0 4
4809: PUSH
4810: LD_INT 2
4812: MINUS
4813: ARRAY
4814: PPUSH
4815: LD_INT 54
4817: PPUSH
4818: LD_INT 42
4820: PPUSH
4821: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4825: LD_EXP 27
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_INT 2
4837: MINUS
4838: ARRAY
4839: PPUSH
4840: LD_EXP 3
4844: PPUSH
4845: CALL_OW 250
4849: PPUSH
4850: LD_EXP 3
4854: PPUSH
4855: CALL_OW 251
4859: PPUSH
4860: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4864: LD_EXP 27
4868: PUSH
4869: LD_VAR 0 4
4873: PUSH
4874: LD_INT 2
4876: MINUS
4877: ARRAY
4878: PPUSH
4879: CALL_OW 200
// Wait ( 0 0$02 ) ;
4883: LD_INT 70
4885: PPUSH
4886: CALL_OW 67
// end ;
4890: GO 4700
4892: POP
4893: POP
// time := 0 0$20 ;
4894: LD_ADDR_VAR 0 8
4898: PUSH
4899: LD_INT 700
4901: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4902: LD_INT 35
4904: PPUSH
4905: CALL_OW 67
// time := time - 0 0$01 ;
4909: LD_ADDR_VAR 0 8
4913: PUSH
4914: LD_VAR 0 8
4918: PUSH
4919: LD_INT 35
4921: MINUS
4922: ST_TO_ADDR
// for i = 3 to 4 do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 3
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 5072
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4939: LD_EXP 27
4943: PUSH
4944: LD_VAR 0 4
4948: ARRAY
4949: PPUSH
4950: LD_INT 1
4952: PPUSH
4953: CALL_OW 289
4957: PUSH
4958: LD_INT 0
4960: GREATER
4961: PUSH
4962: LD_EXP 27
4966: PUSH
4967: LD_VAR 0 4
4971: ARRAY
4972: PPUSH
4973: CALL_OW 314
4977: NOT
4978: AND
4979: IFFALSE 5070
// begin x := rand ( 0 , 5 ) ;
4981: LD_ADDR_VAR 0 2
4985: PUSH
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 5
4991: PPUSH
4992: CALL_OW 12
4996: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4997: LD_EXP 27
5001: PUSH
5002: LD_VAR 0 4
5006: ARRAY
5007: PPUSH
5008: LD_EXP 27
5012: PUSH
5013: LD_VAR 0 4
5017: ARRAY
5018: PPUSH
5019: CALL_OW 250
5023: PPUSH
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 3
5031: PPUSH
5032: CALL_OW 272
5036: PPUSH
5037: LD_EXP 27
5041: PUSH
5042: LD_VAR 0 4
5046: ARRAY
5047: PPUSH
5048: CALL_OW 251
5052: PPUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: CALL_OW 273
5065: PPUSH
5066: CALL_OW 171
// end ;
5070: GO 4936
5072: POP
5073: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 1
5081: ARRAY
5082: PPUSH
5083: LD_INT 54
5085: PPUSH
5086: LD_INT 42
5088: PPUSH
5089: CALL_OW 297
5093: PUSH
5094: LD_INT 4
5096: LESS
5097: PUSH
5098: LD_VAR 0 8
5102: PUSH
5103: LD_INT 0
5105: EQUAL
5106: OR
5107: IFFALSE 4902
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
5109: LD_EXP 27
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
5128: LD_EXP 27
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: LD_INT 0
5142: PPUSH
5143: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
5147: LD_EXP 3
5151: PPUSH
5152: CALL_OW 274
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 200
5162: PPUSH
5163: CALL_OW 276
// DialogueOn ;
5167: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5171: LD_INT 53
5173: PPUSH
5174: LD_INT 35
5176: PPUSH
5177: CALL_OW 86
// un := powell_trans [ 1 ] ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_EXP 27
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D4-Mech1-1
5202: PPUSH
5203: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5207: LD_EXP 21
5211: PPUSH
5212: LD_STRING D4-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5219: LD_VAR 0 5
5223: PPUSH
5224: LD_STRING D4-Mech1-2
5226: PPUSH
5227: CALL_OW 88
// powell_happy := false ;
5231: LD_ADDR_VAR 0 6
5235: PUSH
5236: LD_INT 0
5238: ST_TO_ADDR
// take_cargo := false ;
5239: LD_ADDR_VAR 0 7
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5247: CALL 943 0 0
5251: PUSH
5252: LD_INT 60
5254: GREATEREQUAL
5255: IFFALSE 5303
// begin Say ( JMM , D5-JMM-1 ) ;
5257: LD_EXP 21
5261: PPUSH
5262: LD_STRING D5-JMM-1
5264: PPUSH
5265: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5269: LD_VAR 0 5
5273: PPUSH
5274: LD_STRING D6-Mech1-1
5276: PPUSH
5277: CALL_OW 88
// powell_happy := true ;
5281: LD_ADDR_VAR 0 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// take_cargo := true ;
5289: LD_ADDR_VAR 0 7
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// DialogueOff ;
5297: CALL_OW 7
// end else
5301: GO 5537
// if GetTerminalCargo > 0 then
5303: CALL 943 0 0
5307: PUSH
5308: LD_INT 0
5310: GREATER
5311: IFFALSE 5509
// begin case Query ( QWait ) of 1 :
5313: LD_STRING QWait
5315: PPUSH
5316: CALL_OW 97
5320: PUSH
5321: LD_INT 1
5323: DOUBLE
5324: EQUAL
5325: IFTRUE 5329
5327: GO 5420
5329: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5330: LD_EXP 21
5334: PPUSH
5335: LD_STRING D5a-JMM-1
5337: PPUSH
5338: CALL_OW 88
// DialogueOff ;
5342: CALL_OW 7
// wait ( 5 5$00 ) ;
5346: LD_INT 10500
5348: PPUSH
5349: CALL_OW 67
// if GetTerminalCargo < 60 then
5353: CALL 943 0 0
5357: PUSH
5358: LD_INT 60
5360: LESS
5361: IFFALSE 5402
// begin DialogueOn ;
5363: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5367: LD_EXP 3
5371: PPUSH
5372: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_STRING D6-Mech1-1a
5383: PPUSH
5384: CALL_OW 88
// DialogueOff ;
5388: CALL_OW 7
// powell_happy := false ;
5392: LD_ADDR_VAR 0 6
5396: PUSH
5397: LD_INT 0
5399: ST_TO_ADDR
// end else
5400: GO 5418
// begin powell_happy := true ;
5402: LD_ADDR_VAR 0 6
5406: PUSH
5407: LD_INT 1
5409: ST_TO_ADDR
// take_cargo := true ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// end ; end ; 2 :
5418: GO 5507
5420: LD_INT 2
5422: DOUBLE
5423: EQUAL
5424: IFTRUE 5428
5426: GO 5467
5428: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5429: LD_EXP 21
5433: PPUSH
5434: LD_STRING D5b-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_STRING D6-Mech1-1a
5448: PPUSH
5449: CALL_OW 88
// DialogueOff ;
5453: CALL_OW 7
// take_cargo := true ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// end ; 3 :
5465: GO 5507
5467: LD_INT 3
5469: DOUBLE
5470: EQUAL
5471: IFTRUE 5475
5473: GO 5506
5475: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5476: LD_EXP 21
5480: PPUSH
5481: LD_STRING D5c-JMM-1
5483: PPUSH
5484: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5488: LD_VAR 0 5
5492: PPUSH
5493: LD_STRING D6-Mech1-1b
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ; end ;
5504: GO 5507
5506: POP
// end else
5507: GO 5537
// begin Say ( JMM , D5c-JMM-1 ) ;
5509: LD_EXP 21
5513: PPUSH
5514: LD_STRING D5c-JMM-1
5516: PPUSH
5517: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_STRING D6-Mech1-1b
5528: PPUSH
5529: CALL_OW 88
// DialogueOff ;
5533: CALL_OW 7
// end ; if take_cargo then
5537: LD_VAR 0 7
5541: IFFALSE 5620
// begin x := GetTerminalCargo ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL 943 0 0
5552: ST_TO_ADDR
// if x > 60 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 60
5560: GREATER
5561: IFFALSE 5571
// x := 60 ;
5563: LD_ADDR_VAR 0 2
5567: PUSH
5568: LD_INT 60
5570: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5571: LD_EXP 3
5575: PPUSH
5576: CALL_OW 274
5580: PPUSH
5581: LD_INT 3
5583: PPUSH
5584: CALL 943 0 0
5588: PUSH
5589: LD_VAR 0 2
5593: MINUS
5594: PPUSH
5595: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5599: LD_EXP 27
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PPUSH
5608: LD_INT 3
5610: PPUSH
5611: LD_VAR 0 2
5615: PPUSH
5616: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5620: LD_EXP 27
5624: PPUSH
5625: LD_INT 43
5627: PPUSH
5628: LD_INT 3
5630: PPUSH
5631: CALL_OW 171
// x := 0 0$20 ;
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_INT 700
5642: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5643: LD_INT 35
5645: PPUSH
5646: CALL_OW 67
// x := x - 0 0$01 ;
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 35
5662: MINUS
5663: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5664: LD_VAR 0 2
5668: PUSH
5669: LD_INT 0
5671: EQUAL
5672: PUSH
5673: LD_EXP 27
5677: PUSH
5678: LD_INT 3
5680: ARRAY
5681: PPUSH
5682: LD_INT 43
5684: PPUSH
5685: LD_INT 3
5687: PPUSH
5688: CALL_OW 297
5692: PUSH
5693: LD_INT 4
5695: LESS
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ARRAY
5705: PPUSH
5706: LD_INT 43
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: CALL_OW 297
5716: PUSH
5717: LD_INT 4
5719: LESS
5720: AND
5721: OR
5722: IFFALSE 5643
// for i in powell_trans do
5724: LD_ADDR_VAR 0 4
5728: PUSH
5729: LD_EXP 27
5733: PUSH
5734: FOR_IN
5735: IFFALSE 5748
// RemoveUnit ( i ) ;
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 64
5746: GO 5734
5748: POP
5749: POP
// if not powell_happy then
5750: LD_VAR 0 6
5754: NOT
5755: IFFALSE 5766
// powell_happy := - 1 ;
5757: LD_ADDR_VAR 0 6
5761: PUSH
5762: LD_INT 1
5764: NEG
5765: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5766: LD_STRING EarlySiberite
5768: PPUSH
5769: LD_VAR 0 6
5773: PPUSH
5774: CALL_OW 101
// if powell_happy then
5778: LD_VAR 0 6
5782: IFFALSE 5792
// earlySib := true ;
5784: LD_ADDR_EXP 19
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// if powell_happy then
5792: LD_VAR 0 6
5796: IFFALSE 5807
// ChangeMissionObjectives ( M3a ) else
5798: LD_STRING M3a
5800: PPUSH
5801: CALL_OW 337
5805: GO 5814
// ChangeMissionObjectives ( M3b ) ;
5807: LD_STRING M3b
5809: PPUSH
5810: CALL_OW 337
// ru_can_attack_terminal := true ;
5814: LD_ADDR_EXP 9
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5822: LD_INT 25200
5824: PPUSH
5825: CALL_OW 67
// time := 2 2$00 ;
5829: LD_ADDR_VAR 0 8
5833: PUSH
5834: LD_INT 4200
5836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5837: LD_INT 35
5839: PPUSH
5840: CALL_OW 67
// time := time - 0 0$1 ;
5844: LD_ADDR_VAR 0 8
5848: PUSH
5849: LD_VAR 0 8
5853: PUSH
5854: LD_INT 35
5856: MINUS
5857: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5858: LD_EXP 8
5862: NOT
5863: PUSH
5864: LD_EXP 38
5868: PUSH
5869: LD_INT 0
5871: EQUAL
5872: OR
5873: PUSH
5874: LD_VAR 0 8
5878: PUSH
5879: LD_INT 0
5881: EQUAL
5882: OR
5883: IFFALSE 5837
// if ru_force then
5885: LD_EXP 38
5889: IFFALSE 5988
// for i in ru_force do
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_EXP 38
5900: PUSH
5901: FOR_IN
5902: IFFALSE 5986
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 4
5911: PPUSH
5912: CALL_OW 292
5916: NOT
5917: PUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: LD_INT 81
5925: PUSH
5926: LD_INT 3
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PPUSH
5938: LD_VAR 0 4
5942: PPUSH
5943: CALL_OW 74
5947: PPUSH
5948: CALL_OW 296
5952: PUSH
5953: LD_INT 10
5955: GREATER
5956: AND
5957: IFFALSE 5984
// begin RemoveUnit ( i ) ;
5959: LD_VAR 0 4
5963: PPUSH
5964: CALL_OW 64
// ru_force := ru_force diff i ;
5968: LD_ADDR_EXP 38
5972: PUSH
5973: LD_EXP 38
5977: PUSH
5978: LD_VAR 0 4
5982: DIFF
5983: ST_TO_ADDR
// end ;
5984: GO 5901
5986: POP
5987: POP
// repeat wait ( 0 0$03 ) ;
5988: LD_INT 105
5990: PPUSH
5991: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5995: LD_EXP 8
5999: NOT
6000: PUSH
6001: LD_EXP 38
6005: PUSH
6006: LD_INT 3
6008: LESS
6009: OR
6010: IFFALSE 5988
// ar_can_arrive := true ;
6012: LD_ADDR_EXP 10
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// end ;
6020: PPOPN 8
6022: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 20
6028: PPUSH
6029: CALL_OW 325
6033: IFFALSE 6180
6035: GO 6037
6037: DISABLE
6038: LD_INT 0
6040: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Gary , Cyrus , Bobby , Houten ] ;
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_INT 22
6048: PUSH
6049: LD_INT 1
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PUSH
6056: LD_INT 26
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 25
6068: PUSH
6069: LD_INT 4
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: LD_EXP 22
6095: PUSH
6096: LD_EXP 24
6100: PUSH
6101: LD_EXP 23
6105: PUSH
6106: LD_EXP 25
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: DIFF
6118: ST_TO_ADDR
// if not un then
6119: LD_VAR 0 1
6123: NOT
6124: IFFALSE 6128
// exit ;
6126: GO 6180
// DialogueOn ;
6128: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
6132: LD_VAR 0 1
6136: PUSH
6137: LD_INT 1
6139: ARRAY
6140: PPUSH
6141: LD_STRING D13-Sci1-1
6143: PPUSH
6144: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
6148: LD_EXP 21
6152: PPUSH
6153: LD_STRING D13-JMM-1
6155: PPUSH
6156: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
6160: LD_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: ARRAY
6168: PPUSH
6169: LD_STRING D13-Sci1-2
6171: PPUSH
6172: CALL_OW 88
// DialogueOff ;
6176: CALL_OW 7
// end ;
6180: PPOPN 1
6182: END
// every 0 0$1 trigger GetTerminalCargo > 77 and not InBattle ( 1 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6183: CALL 943 0 0
6187: PUSH
6188: LD_INT 77
6190: GREATER
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 463
6199: NOT
6200: AND
6201: PUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 25
6214: PUSH
6215: LD_INT 4
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 26
6224: PUSH
6225: LD_INT 1
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: PUSH
6242: LD_EXP 21
6246: PUSH
6247: LD_EXP 23
6251: PUSH
6252: LD_EXP 24
6256: PUSH
6257: LD_EXP 22
6261: PUSH
6262: LD_EXP 25
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: AND
6275: IFFALSE 6453
6277: GO 6279
6279: DISABLE
6280: LD_INT 0
6282: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: LD_INT 22
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 25
6300: PUSH
6301: LD_INT 4
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: PUSH
6308: LD_INT 26
6310: PUSH
6311: LD_INT 1
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: PUSH
6328: LD_EXP 21
6332: PUSH
6333: LD_EXP 23
6337: PUSH
6338: LD_EXP 24
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: LD_EXP 25
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: DIFF
6360: ST_TO_ADDR
// DialogueOn ;
6361: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: ARRAY
6373: PPUSH
6374: LD_STRING D7-Sci1-1
6376: PPUSH
6377: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6381: LD_EXP 21
6385: PPUSH
6386: LD_STRING D7-JMM-1
6388: PPUSH
6389: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6393: LD_VAR 0 1
6397: PUSH
6398: LD_INT 1
6400: ARRAY
6401: PPUSH
6402: LD_STRING D7-Sci1-2
6404: PPUSH
6405: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6409: LD_EXP 21
6413: PPUSH
6414: LD_STRING D7-JMM-2
6416: PPUSH
6417: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 1
6428: ARRAY
6429: PPUSH
6430: LD_STRING D7-Sci1-3
6432: PPUSH
6433: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6437: LD_EXP 21
6441: PPUSH
6442: LD_STRING D7-JMM-3
6444: PPUSH
6445: CALL_OW 88
// DialogueOff ;
6449: CALL_OW 7
// end ;
6453: PPOPN 1
6455: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6456: LD_EXP 10
6460: IFFALSE 10083
6462: GO 6464
6464: DISABLE
6465: LD_INT 0
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
// begin PrepareArabian ;
6477: CALL 12827 0 0
// blocked := false ;
6481: LD_ADDR_EXP 18
6485: PUSH
6486: LD_INT 0
6488: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6489: LD_INT 35
6491: PPUSH
6492: CALL_OW 67
// until ar_spawned ;
6496: LD_EXP 11
6500: IFFALSE 6489
// have_crates := true ;
6502: LD_ADDR_VAR 0 9
6506: PUSH
6507: LD_INT 1
6509: ST_TO_ADDR
// player_want_info := 2 ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 2
6517: ST_TO_ADDR
// DialogueOn ;
6518: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6522: LD_EXP 29
6526: PPUSH
6527: LD_STRING D8-Ar1-1
6529: PPUSH
6530: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6534: LD_EXP 21
6538: PPUSH
6539: LD_STRING D8-JMM-1
6541: PPUSH
6542: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6546: LD_EXP 29
6550: PPUSH
6551: LD_STRING D8-Ar1-2
6553: PPUSH
6554: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6558: LD_EXP 21
6562: PPUSH
6563: LD_STRING D8-JMM-2
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6570: LD_EXP 29
6574: PPUSH
6575: LD_STRING D8-Ar1-3
6577: PPUSH
6578: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6582: LD_EXP 21
6586: PPUSH
6587: LD_STRING D8-JMM-3
6589: PPUSH
6590: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6594: LD_EXP 29
6598: PPUSH
6599: LD_STRING D8-Ar1-4
6601: PPUSH
6602: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6606: LD_EXP 21
6610: PPUSH
6611: LD_STRING D8-JMM-4
6613: PPUSH
6614: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6618: LD_EXP 29
6622: PPUSH
6623: LD_STRING D8-Ar1-5
6625: PPUSH
6626: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6630: LD_EXP 21
6634: PPUSH
6635: LD_STRING D8-JMM-5
6637: PPUSH
6638: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6642: LD_EXP 29
6646: PPUSH
6647: LD_STRING D8-Ar1-6
6649: PPUSH
6650: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6654: LD_EXP 30
6658: PPUSH
6659: LD_STRING D8-Ar2-6
6661: PPUSH
6662: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6666: LD_EXP 21
6670: PPUSH
6671: LD_STRING D8-JMM-6
6673: PPUSH
6674: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6678: LD_EXP 30
6682: PPUSH
6683: LD_STRING D8-Ar2-7
6685: PPUSH
6686: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6690: LD_STRING QBarracks
6692: PPUSH
6693: CALL_OW 97
6697: PUSH
6698: LD_INT 1
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6741
6706: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6707: LD_EXP 21
6711: PPUSH
6712: LD_STRING D8a-JMM-1
6714: PPUSH
6715: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6719: LD_EXP 29
6723: PPUSH
6724: LD_STRING D8a-Ar1-1
6726: PPUSH
6727: CALL_OW 94
// player_want_mortar := true ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 1
6738: ST_TO_ADDR
// end ; 2 :
6739: GO 6915
6741: LD_INT 2
6743: DOUBLE
6744: EQUAL
6745: IFTRUE 6749
6747: GO 6871
6749: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6750: LD_EXP 21
6754: PPUSH
6755: LD_STRING D8b-JMM-1
6757: PPUSH
6758: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6762: LD_EXP 29
6766: PPUSH
6767: LD_STRING D8b-Ar1-1
6769: PPUSH
6770: CALL_OW 94
// case Query ( QInfo ) of 1 :
6774: LD_STRING QInfo
6776: PPUSH
6777: CALL_OW 97
6781: PUSH
6782: LD_INT 1
6784: DOUBLE
6785: EQUAL
6786: IFTRUE 6790
6788: GO 6825
6790: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6791: LD_EXP 21
6795: PPUSH
6796: LD_STRING D8b1-JMM-1
6798: PPUSH
6799: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6803: LD_EXP 29
6807: PPUSH
6808: LD_STRING D8b1-Ar1-1
6810: PPUSH
6811: CALL_OW 94
// player_want_info := 2 ;
6815: LD_ADDR_EXP 13
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
// end ; 2 :
6823: GO 6869
6825: LD_INT 2
6827: DOUBLE
6828: EQUAL
6829: IFTRUE 6833
6831: GO 6868
6833: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6834: LD_EXP 21
6838: PPUSH
6839: LD_STRING D8b2-JMM-1
6841: PPUSH
6842: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6846: LD_EXP 29
6850: PPUSH
6851: LD_STRING D8b2-Ar1-1
6853: PPUSH
6854: CALL_OW 94
// player_want_info := 0 ;
6858: LD_ADDR_EXP 13
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ; end ;
6866: GO 6869
6868: POP
// end ; 3 :
6869: GO 6915
6871: LD_INT 3
6873: DOUBLE
6874: EQUAL
6875: IFTRUE 6879
6877: GO 6914
6879: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6880: LD_EXP 21
6884: PPUSH
6885: LD_STRING D8c-JMM-1
6887: PPUSH
6888: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6892: LD_EXP 29
6896: PPUSH
6897: LD_STRING D8c-Ar1-1
6899: PPUSH
6900: CALL_OW 94
// player_want_info := 0 ;
6904: LD_ADDR_EXP 13
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// end ; end ;
6912: GO 6915
6914: POP
// DialogueOff ;
6915: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: LD_INT 9
6926: PPUSH
6927: LD_INT 2
6929: PUSH
6930: LD_INT 30
6932: PUSH
6933: LD_INT 0
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 30
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 70
6959: ST_TO_ADDR
// if dep then
6960: LD_VAR 0 4
6964: IFFALSE 6980
// dep := dep [ 1 ] ;
6966: LD_ADDR_VAR 0 4
6970: PUSH
6971: LD_VAR 0 4
6975: PUSH
6976: LD_INT 1
6978: ARRAY
6979: ST_TO_ADDR
// if not dep then
6980: LD_VAR 0 4
6984: NOT
6985: IFFALSE 7023
// begin case Query ( QInfoNothing ) of 1 :
6987: LD_STRING QInfoNothing
6989: PPUSH
6990: CALL_OW 97
6994: PUSH
6995: LD_INT 1
6997: DOUBLE
6998: EQUAL
6999: IFTRUE 7003
7001: GO 7006
7003: POP
// ; end ;
7004: GO 7007
7006: POP
// player_want_info := false ;
7007: LD_ADDR_EXP 13
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
// player_want_mortar := false ;
7015: LD_ADDR_EXP 12
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
7023: LD_ADDR_VAR 0 3
7027: PUSH
7028: LD_INT 22
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 21
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PPUSH
7052: CALL_OW 69
7056: ST_TO_ADDR
// time := 1 1$55 ;
7057: LD_ADDR_VAR 0 5
7061: PUSH
7062: LD_INT 4025
7064: ST_TO_ADDR
// no_oil_gain := false ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// first_warn := false ;
7073: LD_ADDR_VAR 0 7
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// if player_want_mortar or player_want_info then
7081: LD_EXP 12
7085: PUSH
7086: LD_EXP 13
7090: OR
7091: IFFALSE 7196
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
7093: LD_EXP 36
7097: PPUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: CALL_OW 250
7122: PPUSH
7123: LD_VAR 0 4
7127: PPUSH
7128: CALL_OW 251
7132: PPUSH
7133: LD_VAR 0 4
7137: PPUSH
7138: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
7142: LD_EXP 36
7146: PPUSH
7147: LD_INT 25
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PPUSH
7162: LD_INT 86
7164: PPUSH
7165: LD_INT 121
7167: PPUSH
7168: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7172: LD_EXP 36
7176: PPUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 72
7191: PPUSH
7192: CALL_OW 200
// end ; if player_attacked_ar then
7196: LD_EXP 16
7200: IFFALSE 7204
// exit ;
7202: GO 10083
// if player_want_mortar then
7204: LD_EXP 12
7208: IFFALSE 8745
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7210: LD_EXP 30
7214: PPUSH
7215: LD_VAR 0 4
7219: PPUSH
7220: CALL_OW 250
7224: PUSH
7225: LD_INT 1
7227: PLUS
7228: PPUSH
7229: LD_VAR 0 4
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 1
7241: PLUS
7242: PPUSH
7243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7247: LD_INT 35
7249: PPUSH
7250: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7254: LD_EXP 30
7258: PPUSH
7259: LD_VAR 0 4
7263: PPUSH
7264: CALL_OW 296
7268: PUSH
7269: LD_INT 4
7271: LESS
7272: IFFALSE 7247
// for i = 1 to 6 do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: DOUBLE
7280: LD_INT 1
7282: DEC
7283: ST_TO_ADDR
7284: LD_INT 6
7286: PUSH
7287: FOR_TO
7288: IFFALSE 7492
// begin if player_attacked_ar then
7290: LD_EXP 16
7294: IFFALSE 7300
// exit ;
7296: POP
7297: POP
7298: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7300: LD_VAR 0 4
7304: PPUSH
7305: CALL_OW 274
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 275
7317: PUSH
7318: LD_INT 10
7320: LESS
7321: PUSH
7322: LD_VAR 0 7
7326: NOT
7327: AND
7328: IFFALSE 7391
// begin first_warn := true ;
7330: LD_ADDR_VAR 0 7
7334: PUSH
7335: LD_INT 1
7337: ST_TO_ADDR
// DialogueOn ;
7338: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7342: LD_EXP 31
7346: PPUSH
7347: LD_STRING D9a-FAr1-1
7349: PPUSH
7350: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7354: LD_EXP 21
7358: PPUSH
7359: LD_STRING D9a-JMM-1
7361: PPUSH
7362: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7366: LD_EXP 29
7370: PPUSH
7371: LD_STRING D9a2-Ar1-1
7373: PPUSH
7374: CALL_OW 88
// DialogueOff ;
7378: CALL_OW 7
// wait ( time ) ;
7382: LD_VAR 0 5
7386: PPUSH
7387: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7391: LD_VAR 0 4
7395: PPUSH
7396: CALL_OW 274
7400: PPUSH
7401: LD_INT 2
7403: PPUSH
7404: CALL_OW 275
7408: PUSH
7409: LD_INT 10
7411: LESS
7412: IFFALSE 7438
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7414: LD_EXP 29
7418: PPUSH
7419: LD_STRING D9a3-Ar1-1
7421: PPUSH
7422: CALL_OW 88
// no_oil_gain := true ;
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// break ;
7434: GO 7492
// end else
7436: GO 7490
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7438: LD_EXP 30
7442: PPUSH
7443: LD_VAR 0 4
7447: PPUSH
7448: LD_INT 2
7450: PPUSH
7451: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7455: LD_EXP 30
7459: PPUSH
7460: LD_VAR 0 3
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: MOD
7473: PUSH
7474: LD_INT 1
7476: PLUS
7477: ARRAY
7478: PPUSH
7479: CALL_OW 210
// wait ( 0 0$10 ) ;
7483: LD_INT 350
7485: PPUSH
7486: CALL_OW 67
// end ; end ;
7490: GO 7287
7492: POP
7493: POP
// if not no_oil_gain then
7494: LD_VAR 0 6
7498: NOT
7499: IFFALSE 8745
// begin repeat wait ( 0 0$01 ) ;
7501: LD_INT 35
7503: PPUSH
7504: CALL_OW 67
// if player_attacked_ar then
7508: LD_EXP 16
7512: IFFALSE 7516
// exit ;
7514: GO 10083
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7516: LD_VAR 0 3
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: CALL_OW 261
7529: PUSH
7530: LD_INT 80
7532: GREATER
7533: PUSH
7534: LD_VAR 0 3
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: PPUSH
7543: CALL_OW 261
7547: PUSH
7548: LD_INT 80
7550: GREATER
7551: AND
7552: PUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 3
7560: ARRAY
7561: PPUSH
7562: CALL_OW 261
7566: PUSH
7567: LD_INT 80
7569: GREATER
7570: AND
7571: IFFALSE 7501
// ComMoveXY ( Gali , 105 , 127 ) ;
7573: LD_EXP 30
7577: PPUSH
7578: LD_INT 105
7580: PPUSH
7581: LD_INT 127
7583: PPUSH
7584: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7588: LD_EXP 30
7592: PPUSH
7593: LD_INT 2
7595: PPUSH
7596: CALL_OW 173
// AddComHold ( Gali ) ;
7600: LD_EXP 30
7604: PPUSH
7605: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 10083
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7624: LD_EXP 30
7628: PPUSH
7629: LD_INT 105
7631: PPUSH
7632: LD_INT 127
7634: PPUSH
7635: CALL_OW 297
7639: PUSH
7640: LD_INT 4
7642: LESS
7643: IFFALSE 7609
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7645: LD_VAR 0 4
7649: PPUSH
7650: CALL_OW 274
7654: PPUSH
7655: LD_INT 1
7657: PPUSH
7658: CALL_OW 275
7662: PUSH
7663: LD_INT 50
7665: LESS
7666: IFFALSE 7968
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7668: LD_VAR 0 4
7672: PPUSH
7673: CALL_OW 274
7677: PPUSH
7678: LD_INT 1
7680: PPUSH
7681: CALL_OW 275
7685: PUSH
7686: LD_INT 0
7688: DOUBLE
7689: GREATEREQUAL
7690: IFFALSE 7698
7692: LD_INT 24
7694: DOUBLE
7695: LESSEQUAL
7696: IFTRUE 7700
7698: GO 7715
7700: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7701: LD_EXP 30
7705: PPUSH
7706: LD_STRING D9b-Ar2-1
7708: PPUSH
7709: CALL_OW 88
7713: GO 7745
7715: LD_INT 25
7717: DOUBLE
7718: GREATEREQUAL
7719: IFFALSE 7727
7721: LD_INT 49
7723: DOUBLE
7724: LESSEQUAL
7725: IFTRUE 7729
7727: GO 7744
7729: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7730: LD_EXP 30
7734: PPUSH
7735: LD_STRING D9b-Ar2-1a
7737: PPUSH
7738: CALL_OW 88
7742: GO 7745
7744: POP
// Say ( JMM , D9b-JMM-1 ) ;
7745: LD_EXP 21
7749: PPUSH
7750: LD_STRING D9b-JMM-1
7752: PPUSH
7753: CALL_OW 88
// x := 0 0$0 ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: LD_INT 0
7764: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7765: LD_INT 35
7767: PPUSH
7768: CALL_OW 67
// x := x + 0 0$1 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 35
7784: PLUS
7785: ST_TO_ADDR
// if player_attacked_ar then
7786: LD_EXP 16
7790: IFFALSE 7794
// exit ;
7792: GO 10083
// until x >= time ;
7794: LD_VAR 0 2
7798: PUSH
7799: LD_VAR 0 5
7803: GREATEREQUAL
7804: IFFALSE 7765
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7806: LD_VAR 0 4
7810: PPUSH
7811: CALL_OW 274
7815: PPUSH
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 275
7823: PUSH
7824: LD_INT 50
7826: LESS
7827: IFFALSE 7968
// begin have_crates := false ;
7829: LD_ADDR_VAR 0 9
7833: PUSH
7834: LD_INT 0
7836: ST_TO_ADDR
// DialogueOn ;
7837: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7841: LD_EXP 29
7845: PPUSH
7846: LD_STRING D9c-Ar1-1
7848: PPUSH
7849: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7853: LD_EXP 21
7857: PPUSH
7858: LD_STRING D9c-JMM-1
7860: PPUSH
7861: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7865: LD_EXP 29
7869: PPUSH
7870: LD_STRING D9c-Ar1-2
7872: PPUSH
7873: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7877: LD_EXP 31
7881: PPUSH
7882: LD_STRING D9c-FAr1-2
7884: PPUSH
7885: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7889: LD_EXP 29
7893: PPUSH
7894: LD_STRING D9c-Ar1-3
7896: PPUSH
7897: CALL_OW 88
// case Query ( QInfo ) of 1 :
7901: LD_STRING QInfo
7903: PPUSH
7904: CALL_OW 97
7908: PUSH
7909: LD_INT 1
7911: DOUBLE
7912: EQUAL
7913: IFTRUE 7917
7915: GO 7940
7917: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7918: LD_EXP 21
7922: PPUSH
7923: LD_STRING D8b1-JMM-1
7925: PPUSH
7926: CALL_OW 88
// player_want_info := 2 ;
7930: LD_ADDR_EXP 13
7934: PUSH
7935: LD_INT 2
7937: ST_TO_ADDR
// end ; 2 :
7938: GO 7964
7940: LD_INT 2
7942: DOUBLE
7943: EQUAL
7944: IFTRUE 7948
7946: GO 7963
7948: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7949: LD_EXP 29
7953: PPUSH
7954: LD_STRING D8b2-Ar1-1
7956: PPUSH
7957: CALL_OW 88
// end ; end ;
7961: GO 7964
7963: POP
// DialogueOff ;
7964: CALL_OW 7
// end ; end ; if have_crates then
7968: LD_VAR 0 9
7972: IFFALSE 8745
// begin RemoveEnvironmentArea ( mortarArea ) ;
7974: LD_INT 2
7976: PPUSH
7977: CALL_OW 355
// wait ( 1 ) ;
7981: LD_INT 1
7983: PPUSH
7984: CALL_OW 67
// InGameOn ;
7988: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7992: LD_EXP 30
7996: PPUSH
7997: CALL_OW 87
// SetSide ( Gali , 1 ) ;
8001: LD_EXP 30
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
8013: LD_ADDR_VAR 0 10
8017: PUSH
8018: LD_INT 22
8020: PUSH
8021: LD_INT 1
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 23
8033: PUSH
8034: LD_INT 2
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 21
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 92
8057: PUSH
8058: LD_INT 107
8060: PUSH
8061: LD_INT 131
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: ST_TO_ADDR
// if filter then
8084: LD_VAR 0 10
8088: IFFALSE 8122
// for i in filter do
8090: LD_ADDR_VAR 0 1
8094: PUSH
8095: LD_VAR 0 10
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8120
// ComMoveXY ( i , 107 , 121 ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_INT 107
8110: PPUSH
8111: LD_INT 121
8113: PPUSH
8114: CALL_OW 111
8118: GO 8100
8120: POP
8121: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
8122: LD_EXP 30
8126: PPUSH
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 131
8135: PPUSH
8136: LD_INT 0
8138: PPUSH
8139: CALL_OW 145
// wait ( 0 0$1 ) ;
8143: LD_INT 35
8145: PPUSH
8146: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
8150: LD_INT 30
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 23
8162: PUSH
8163: LD_INT 2
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: IFFALSE 8013
// SetSide ( Gali , 2 ) ;
8180: LD_EXP 30
8184: PPUSH
8185: LD_INT 2
8187: PPUSH
8188: CALL_OW 235
// InGameOff ;
8192: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8196: LD_ADDR_VAR 0 8
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 4
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 23
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8234: LD_INT 35
8236: PPUSH
8237: CALL_OW 67
// if player_attacked_ar then
8241: LD_EXP 16
8245: IFFALSE 8249
// exit ;
8247: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8249: LD_VAR 0 8
8253: PPUSH
8254: CALL_OW 461
8258: PUSH
8259: LD_INT 1
8261: NONEQUAL
8262: IFFALSE 8234
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8264: LD_VAR 0 8
8268: PPUSH
8269: CALL_OW 302
8273: PUSH
8274: LD_VAR 0 4
8278: PPUSH
8279: CALL_OW 274
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 275
8291: PUSH
8292: LD_INT 25
8294: GREATEREQUAL
8295: AND
8296: IFFALSE 8395
// begin ComUpgrade ( b ) ;
8298: LD_VAR 0 8
8302: PPUSH
8303: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8307: LD_EXP 30
8311: PPUSH
8312: LD_STRING h
8314: PUSH
8315: LD_VAR 0 8
8319: PPUSH
8320: CALL_OW 250
8324: PUSH
8325: LD_VAR 0 8
8329: PPUSH
8330: CALL_OW 251
8334: PUSH
8335: LD_VAR 0 8
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: PPUSH
8361: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// if player_attacked_ar then
8372: LD_EXP 16
8376: IFFALSE 8380
// exit ;
8378: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8380: LD_VAR 0 8
8384: PPUSH
8385: CALL_OW 461
8389: PUSH
8390: LD_INT 1
8392: NONEQUAL
8393: IFFALSE 8365
// end ; if b then
8395: LD_VAR 0 8
8399: IFFALSE 8410
// CenterNowOnUnits ( b ) ;
8401: LD_VAR 0 8
8405: PPUSH
8406: CALL_OW 87
// DialogueOn ;
8410: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8414: LD_EXP 30
8418: PPUSH
8419: LD_STRING D9d-Ar2-1
8421: PPUSH
8422: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8426: LD_EXP 29
8430: PPUSH
8431: LD_STRING D9d-Ar1-1
8433: PPUSH
8434: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8438: LD_EXP 21
8442: PPUSH
8443: LD_STRING D9d-JMM-1
8445: PPUSH
8446: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8450: LD_EXP 29
8454: PPUSH
8455: LD_STRING D9d-Ar1-2
8457: PPUSH
8458: CALL_OW 88
// DialogueOff ;
8462: CALL_OW 7
// i := [ ] ;
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: EMPTY
8472: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8473: LD_VAR 0 4
8477: PPUSH
8478: CALL_OW 274
8482: PPUSH
8483: LD_INT 3
8485: PPUSH
8486: CALL_OW 275
8490: PUSH
8491: LD_INT 20
8493: GREATEREQUAL
8494: IFFALSE 8513
// i := i ^ [ 1 ] ;
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_VAR 0 1
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: EMPTY
8510: LIST
8511: ADD
8512: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8513: LD_VAR 0 4
8517: PPUSH
8518: CALL_OW 274
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_INT 50
8533: GREATEREQUAL
8534: IFFALSE 8553
// i := i ^ [ 2 ] ;
8536: LD_ADDR_VAR 0 1
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: EMPTY
8550: LIST
8551: ADD
8552: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL_OW 274
8562: PPUSH
8563: LD_INT 2
8565: PPUSH
8566: CALL_OW 275
8570: PUSH
8571: LD_INT 80
8573: GREATEREQUAL
8574: IFFALSE 8593
// i := i ^ [ 3 ] ;
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: LD_VAR 0 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: ADD
8592: ST_TO_ADDR
// i := i diff 0 ;
8593: LD_ADDR_VAR 0 1
8597: PUSH
8598: LD_VAR 0 1
8602: PUSH
8603: LD_INT 0
8605: DIFF
8606: ST_TO_ADDR
// if i then
8607: LD_VAR 0 1
8611: IFFALSE 8717
// begin i := i ^ [ 4 ] ;
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 4
8625: PUSH
8626: EMPTY
8627: LIST
8628: ADD
8629: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8630: LD_STRING QInfo2
8632: PPUSH
8633: CALL_OW 97
8637: PUSH
8638: LD_INT 1
8640: DOUBLE
8641: EQUAL
8642: IFTRUE 8646
8644: GO 8657
8646: POP
// player_want_info := 3 ; 2 :
8647: LD_ADDR_EXP 13
8651: PUSH
8652: LD_INT 3
8654: ST_TO_ADDR
8655: GO 8715
8657: LD_INT 2
8659: DOUBLE
8660: EQUAL
8661: IFTRUE 8665
8663: GO 8676
8665: POP
// player_want_info := 1 ; 3 :
8666: LD_ADDR_EXP 13
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
8674: GO 8715
8676: LD_INT 3
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8695
8684: POP
// player_want_info := 2 ; 4 :
8685: LD_ADDR_EXP 13
8689: PUSH
8690: LD_INT 2
8692: ST_TO_ADDR
8693: GO 8715
8695: LD_INT 4
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8714
8703: POP
// player_want_info := 0 ; end ;
8704: LD_ADDR_EXP 13
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
8712: GO 8715
8714: POP
// end else
8715: GO 8745
// case Query ( QInfoNothing ) of 1 :
8717: LD_STRING QInfoNothing
8719: PPUSH
8720: CALL_OW 97
8724: PUSH
8725: LD_INT 1
8727: DOUBLE
8728: EQUAL
8729: IFTRUE 8733
8731: GO 8744
8733: POP
// player_want_info := 0 ; end ;
8734: LD_ADDR_EXP 13
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
8742: GO 8745
8744: POP
// end ; end ; end ; if player_want_info then
8745: LD_EXP 13
8749: IFFALSE 9903
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8751: LD_ADDR_VAR 0 3
8755: PUSH
8756: LD_VAR 0 3
8760: PPUSH
8761: LD_INT 34
8763: PUSH
8764: LD_INT 32
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 72
8775: ST_TO_ADDR
// if player_want_mortar then
8776: LD_EXP 12
8780: IFFALSE 9135
// begin case player_want_info of 1 :
8782: LD_EXP 13
8786: PUSH
8787: LD_INT 1
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8806
8795: POP
// x := 5 ; 2 :
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: LD_INT 5
8803: ST_TO_ADDR
8804: GO 8845
8806: LD_INT 2
8808: DOUBLE
8809: EQUAL
8810: IFTRUE 8814
8812: GO 8825
8814: POP
// x := 8 ; 3 :
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 8
8822: ST_TO_ADDR
8823: GO 8845
8825: LD_INT 3
8827: DOUBLE
8828: EQUAL
8829: IFTRUE 8833
8831: GO 8844
8833: POP
// x := 2 ; end ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_INT 2
8841: ST_TO_ADDR
8842: GO 8845
8844: POP
// repeat wait ( 0 0$1 ) ;
8845: LD_INT 35
8847: PPUSH
8848: CALL_OW 67
// until not HasTask ( Gali ) ;
8852: LD_EXP 30
8856: PPUSH
8857: CALL_OW 314
8861: NOT
8862: IFFALSE 8845
// time := 0 0$00 ;
8864: LD_ADDR_VAR 0 5
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// time := time + 0 0$1 ;
8879: LD_ADDR_VAR 0 5
8883: PUSH
8884: LD_VAR 0 5
8888: PUSH
8889: LD_INT 35
8891: PLUS
8892: ST_TO_ADDR
// if debug then
8893: LD_EXP 2
8897: IFFALSE 8916
// debug_strings := [ time: & time ] ;
8899: LD_ADDR_OWVAR 48
8903: PUSH
8904: LD_STRING time:
8906: PUSH
8907: LD_VAR 0 5
8911: STR
8912: PUSH
8913: EMPTY
8914: LIST
8915: ST_TO_ADDR
// if time > 8 8$00 then
8916: LD_VAR 0 5
8920: PUSH
8921: LD_INT 16800
8923: GREATER
8924: IFFALSE 8936
// begin blocked := true ;
8926: LD_ADDR_EXP 18
8930: PUSH
8931: LD_INT 1
8933: ST_TO_ADDR
// exit ;
8934: GO 10083
// end ; if not Carry ( Gali ) then
8936: LD_EXP 30
8940: PPUSH
8941: CALL_OW 281
8945: NOT
8946: IFFALSE 8969
// ComTransport ( Gali , dep , player_want_info ) else
8948: LD_EXP 30
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: LD_EXP 13
8962: PPUSH
8963: CALL_OW 151
8967: GO 9087
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8969: LD_EXP 30
8973: PPUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: CALL_OW 296
8987: PUSH
8988: LD_INT 4
8990: LESS
8991: PUSH
8992: LD_EXP 30
8996: PPUSH
8997: LD_EXP 13
9001: PPUSH
9002: CALL_OW 289
9006: AND
9007: IFFALSE 9069
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_EXP 13
9022: PPUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ARRAY
9031: PPUSH
9032: LD_EXP 13
9036: PPUSH
9037: CALL_OW 289
9041: PUSH
9042: LD_INT 10
9044: PLUS
9045: PPUSH
9046: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
9050: LD_EXP 30
9054: PPUSH
9055: LD_EXP 13
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 290
// end else
9067: GO 9087
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
9069: LD_EXP 30
9073: PPUSH
9074: LD_VAR 0 3
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: CALL_OW 112
// end ; if player_attacked_ar then
9087: LD_EXP 16
9091: IFFALSE 9095
// exit ;
9093: GO 10083
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: PPUSH
9104: LD_EXP 13
9108: PPUSH
9109: CALL_OW 289
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 10
9121: MUL
9122: GREATEREQUAL
9123: IFFALSE 8872
// no_oil_gain := false ;
9125: LD_ADDR_VAR 0 6
9129: PUSH
9130: LD_INT 0
9132: ST_TO_ADDR
// end else
9133: GO 9724
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
9135: LD_ADDR_VAR 0 3
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 21
9152: PUSH
9153: LD_INT 2
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9169: LD_EXP 30
9173: PPUSH
9174: LD_VAR 0 4
9178: PPUSH
9179: CALL_OW 250
9183: PUSH
9184: LD_INT 1
9186: PLUS
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: CALL_OW 251
9197: PUSH
9198: LD_INT 1
9200: PLUS
9201: PPUSH
9202: CALL_OW 111
// time := 0 0$00 ;
9206: LD_ADDR_VAR 0 5
9210: PUSH
9211: LD_INT 0
9213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// time := time + 0 0$1 ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: LD_VAR 0 5
9230: PUSH
9231: LD_INT 35
9233: PLUS
9234: ST_TO_ADDR
// if time > 1 1$45 then
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 3675
9242: GREATER
9243: IFFALSE 9247
// break ;
9245: GO 9267
// until GetDistUnits ( Gali , dep ) < 4 ;
9247: LD_EXP 30
9251: PPUSH
9252: LD_VAR 0 4
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 4
9264: LESS
9265: IFFALSE 9214
// for i = 1 to 6 do
9267: LD_ADDR_VAR 0 1
9271: PUSH
9272: DOUBLE
9273: LD_INT 1
9275: DEC
9276: ST_TO_ADDR
9277: LD_INT 6
9279: PUSH
9280: FOR_TO
9281: IFFALSE 9485
// begin if player_attacked_ar then
9283: LD_EXP 16
9287: IFFALSE 9293
// exit ;
9289: POP
9290: POP
9291: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9293: LD_VAR 0 4
9297: PPUSH
9298: CALL_OW 274
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 275
9310: PUSH
9311: LD_INT 10
9313: LESS
9314: PUSH
9315: LD_VAR 0 7
9319: NOT
9320: AND
9321: IFFALSE 9384
// begin first_warn := true ;
9323: LD_ADDR_VAR 0 7
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// DialogueOn ;
9331: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9335: LD_EXP 31
9339: PPUSH
9340: LD_STRING D9a-FAr1-1
9342: PPUSH
9343: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9347: LD_EXP 21
9351: PPUSH
9352: LD_STRING D9a-JMM-1
9354: PPUSH
9355: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9359: LD_EXP 29
9363: PPUSH
9364: LD_STRING D9a2-Ar1-1
9366: PPUSH
9367: CALL_OW 88
// DialogueOff ;
9371: CALL_OW 7
// wait ( time ) ;
9375: LD_VAR 0 5
9379: PPUSH
9380: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9384: LD_VAR 0 4
9388: PPUSH
9389: CALL_OW 274
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 275
9401: PUSH
9402: LD_INT 10
9404: LESS
9405: IFFALSE 9431
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9407: LD_EXP 29
9411: PPUSH
9412: LD_STRING D9a3-Ar1-1
9414: PPUSH
9415: CALL_OW 88
// no_oil_gain := true ;
9419: LD_ADDR_VAR 0 6
9423: PUSH
9424: LD_INT 1
9426: ST_TO_ADDR
// break ;
9427: GO 9485
// end else
9429: GO 9483
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9431: LD_EXP 30
9435: PPUSH
9436: LD_VAR 0 4
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9448: LD_EXP 30
9452: PPUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 3
9465: MOD
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: ARRAY
9471: PPUSH
9472: CALL_OW 210
// wait ( 0 0$10 ) ;
9476: LD_INT 350
9478: PPUSH
9479: CALL_OW 67
// end ; end ;
9483: GO 9280
9485: POP
9486: POP
// time := 0 0$00 ;
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 0
9494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9495: LD_INT 35
9497: PPUSH
9498: CALL_OW 67
// if not HasTask ( Gali ) then
9502: LD_EXP 30
9506: PPUSH
9507: CALL_OW 314
9511: NOT
9512: IFFALSE 9528
// time := time + 0 0$1 ;
9514: LD_ADDR_VAR 0 5
9518: PUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_INT 35
9526: PLUS
9527: ST_TO_ADDR
// if time > 1 1$25 then
9528: LD_VAR 0 5
9532: PUSH
9533: LD_INT 2975
9535: GREATER
9536: IFFALSE 9560
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING D9a3-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// no_oil_gain := true ;
9550: LD_ADDR_VAR 0 6
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// break ;
9558: GO 9724
// end ; if player_attacked_ar then
9560: LD_EXP 16
9564: IFFALSE 9568
// exit ;
9566: GO 10083
// for i in tmp do
9568: LD_ADDR_VAR 0 1
9572: PUSH
9573: LD_VAR 0 3
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9610
// if GetFuel ( i ) < 100 then
9581: LD_VAR 0 1
9585: PPUSH
9586: CALL_OW 261
9590: PUSH
9591: LD_INT 100
9593: LESS
9594: IFFALSE 9608
// begin x := i ;
9596: LD_ADDR_VAR 0 2
9600: PUSH
9601: LD_VAR 0 1
9605: ST_TO_ADDR
// break ;
9606: GO 9610
// end ;
9608: GO 9578
9610: POP
9611: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9612: LD_EXP 30
9616: PPUSH
9617: CALL_OW 314
9621: NOT
9622: PUSH
9623: LD_EXP 30
9627: PPUSH
9628: CALL_OW 281
9632: NOT
9633: AND
9634: IFFALSE 9667
// begin ComTransport ( Gali , dep , mat_oil ) ;
9636: LD_EXP 30
9640: PPUSH
9641: LD_VAR 0 4
9645: PPUSH
9646: LD_INT 2
9648: PPUSH
9649: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9653: LD_EXP 30
9657: PPUSH
9658: LD_VAR 0 2
9662: PPUSH
9663: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9667: LD_VAR 0 3
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: CALL_OW 261
9680: PUSH
9681: LD_INT 80
9683: GREATER
9684: PUSH
9685: LD_VAR 0 3
9689: PUSH
9690: LD_INT 2
9692: ARRAY
9693: PPUSH
9694: CALL_OW 261
9698: PUSH
9699: LD_INT 80
9701: GREATER
9702: AND
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_INT 3
9711: ARRAY
9712: PPUSH
9713: CALL_OW 261
9717: PUSH
9718: LD_INT 80
9720: GREATER
9721: AND
9722: IFFALSE 9495
// end ; ComHold ( Gali ) ;
9724: LD_EXP 30
9728: PPUSH
9729: CALL_OW 140
// if not no_oil_gain then
9733: LD_VAR 0 6
9737: NOT
9738: IFFALSE 9903
// begin DialogueOn ;
9740: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9744: LD_EXP 29
9748: PPUSH
9749: CALL_OW 87
// if player_want_mortar then
9753: LD_EXP 12
9757: IFFALSE 9783
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9759: LD_EXP 29
9763: PPUSH
9764: LD_STRING D9e-Ar1-1
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9771: LD_EXP 21
9775: PPUSH
9776: LD_STRING D10a-JMM-1
9778: PPUSH
9779: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9783: LD_EXP 29
9787: PPUSH
9788: LD_STRING D10a-Ar1-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9795: LD_EXP 30
9799: PPUSH
9800: LD_STRING D10a-Ar2-1
9802: PPUSH
9803: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9807: LD_EXP 31
9811: PPUSH
9812: LD_STRING D10a-FAr1-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9819: LD_EXP 30
9823: PPUSH
9824: LD_STRING D10a-Ar2-2
9826: PPUSH
9827: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9831: LD_EXP 31
9835: PPUSH
9836: LD_STRING D10a-FAr1-2
9838: PPUSH
9839: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9843: LD_EXP 29
9847: PPUSH
9848: LD_STRING D10a-Ar1-2
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9855: LD_EXP 21
9859: PPUSH
9860: LD_STRING D10a-JMM-2
9862: PPUSH
9863: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9867: LD_EXP 29
9871: PPUSH
9872: LD_STRING D10a-Ar1-3
9874: PPUSH
9875: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9879: LD_EXP 21
9883: PPUSH
9884: LD_STRING D10a-JMM-3
9886: PPUSH
9887: CALL_OW 88
// player_get_info := true ;
9891: LD_ADDR_EXP 15
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// DialogueOff ;
9899: CALL_OW 7
// end ; end ; if player_attacked_ar then
9903: LD_EXP 16
9907: IFFALSE 9911
// exit ;
9909: GO 10083
// if player_want_mortar or player_want_info then
9911: LD_EXP 12
9915: PUSH
9916: LD_EXP 13
9920: OR
9921: IFFALSE 9935
// Say ( Vervecken , D9f-Ar1-1 ) ;
9923: LD_EXP 29
9927: PPUSH
9928: LD_STRING D9f-Ar1-1
9930: PPUSH
9931: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9935: LD_INT 22
9937: PUSH
9938: LD_INT 2
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: PPUSH
9950: LD_INT 51
9952: PPUSH
9953: LD_INT 99
9955: PPUSH
9956: CALL_OW 111
// wait ( 0 0$1 ) ;
9960: LD_INT 35
9962: PPUSH
9963: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9967: LD_INT 22
9969: PUSH
9970: LD_INT 2
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 92
9979: PUSH
9980: LD_INT 51
9982: PUSH
9983: LD_INT 99
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IFFALSE 10063
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 2
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 92
10022: PUSH
10023: LD_INT 51
10025: PUSH
10026: LD_INT 99
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 69
10046: PUSH
10047: FOR_IN
10048: IFFALSE 10061
// RemoveUnit ( i ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: CALL_OW 64
10059: GO 10047
10061: POP
10062: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: PUSH
10078: LD_INT 0
10080: EQUAL
10081: IFFALSE 9935
// end ;
10083: PPOPN 10
10085: END
// every 0 0$01 trigger blocked do var i ;
10086: LD_EXP 18
10090: IFFALSE 10258
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
10098: LD_EXP 29
10102: PPUSH
10103: LD_STRING D9f-Ar1-1
10105: PPUSH
10106: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10110: LD_INT 22
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_INT 51
10127: PPUSH
10128: LD_INT 99
10130: PPUSH
10131: CALL_OW 111
// wait ( 0 0$1 ) ;
10135: LD_INT 35
10137: PPUSH
10138: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10142: LD_INT 22
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 92
10154: PUSH
10155: LD_INT 51
10157: PUSH
10158: LD_INT 99
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: IFFALSE 10238
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10180: LD_ADDR_VAR 0 1
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 92
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 99
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PPUSH
10217: CALL_OW 69
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// RemoveUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 64
10234: GO 10222
10236: POP
10237: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10238: LD_INT 22
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: IFFALSE 10110
// end ;
10258: PPOPN 1
10260: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10261: LD_EXP 16
10265: IFFALSE 10618
10267: GO 10269
10269: DISABLE
10270: LD_INT 0
10272: PPUSH
10273: PPUSH
10274: PPUSH
10275: PPUSH
// begin ru_can_attack := true ;
10276: LD_ADDR_EXP 8
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// mine_launched := false ;
10284: LD_ADDR_VAR 0 3
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PPUSH
10307: LD_INT 51
10309: PPUSH
10310: LD_INT 99
10312: PPUSH
10313: CALL_OW 111
// if IsOk ( Vervecken ) then
10317: LD_EXP 29
10321: PPUSH
10322: CALL_OW 302
10326: IFFALSE 10340
// Say ( Vervecken , D11a-Ar1-1 ) ;
10328: LD_EXP 29
10332: PPUSH
10333: LD_STRING D11a-Ar1-1
10335: PPUSH
10336: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10340: LD_ADDR_VAR 0 2
10344: PUSH
10345: LD_EXP 36
10349: PPUSH
10350: LD_INT 25
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 72
10364: ST_TO_ADDR
// for i in tmp do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10439
// if MineOfUnit ( i ) then
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 459
10387: IFFALSE 10437
// begin x := MineOfUnit ( i ) ;
10389: LD_ADDR_VAR 0 4
10393: PUSH
10394: LD_VAR 0 1
10398: PPUSH
10399: CALL_OW 459
10403: ST_TO_ADDR
// mine_launched := true ;
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10412: LD_VAR 0 4
10416: PUSH
10417: LD_INT 1
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_INT 2
10428: ARRAY
10429: PPUSH
10430: LD_INT 2
10432: PPUSH
10433: CALL_OW 456
// end ;
10437: GO 10375
10439: POP
10440: POP
// if mine_launched and IsOk ( Vervecken ) then
10441: LD_VAR 0 3
10445: PUSH
10446: LD_EXP 29
10450: PPUSH
10451: CALL_OW 302
10455: AND
10456: IFFALSE 10470
// Say ( Vervecken , D11b-Ar1-1 ) ;
10458: LD_EXP 29
10462: PPUSH
10463: LD_STRING D11b-Ar1-1
10465: PPUSH
10466: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10470: LD_INT 22
10472: PUSH
10473: LD_INT 2
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: PPUSH
10485: LD_INT 51
10487: PPUSH
10488: LD_INT 99
10490: PPUSH
10491: CALL_OW 111
// wait ( 0 0$1 ) ;
10495: LD_INT 35
10497: PPUSH
10498: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10502: LD_INT 22
10504: PUSH
10505: LD_INT 2
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 92
10514: PUSH
10515: LD_INT 51
10517: PUSH
10518: LD_INT 99
10520: PUSH
10521: LD_INT 2
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IFFALSE 10598
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 22
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 92
10557: PUSH
10558: LD_INT 51
10560: PUSH
10561: LD_INT 99
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: PUSH
10582: FOR_IN
10583: IFFALSE 10596
// RemoveUnit ( i ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: CALL_OW 64
10594: GO 10582
10596: POP
10597: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PUSH
10613: LD_INT 0
10615: EQUAL
10616: IFFALSE 10470
// end ;
10618: PPOPN 4
10620: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10621: LD_EXP 10
10625: IFFALSE 10804
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
// begin Wait ( 10 10$00 ) ;
10633: LD_INT 21000
10635: PPUSH
10636: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10640: LD_INT 22
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: IFFALSE 10804
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: PPUSH
10671: LD_INT 51
10673: PPUSH
10674: LD_INT 99
10676: PPUSH
10677: CALL_OW 114
// wait ( 0 0$1 ) ;
10681: LD_INT 35
10683: PPUSH
10684: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10688: LD_INT 22
10690: PUSH
10691: LD_INT 2
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 92
10700: PUSH
10701: LD_INT 51
10703: PUSH
10704: LD_INT 99
10706: PUSH
10707: LD_INT 2
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: IFFALSE 10784
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 92
10743: PUSH
10744: LD_INT 51
10746: PUSH
10747: LD_INT 99
10749: PUSH
10750: LD_INT 2
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10782
// RemoveUnit ( i ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 64
10780: GO 10768
10782: POP
10783: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10784: LD_INT 22
10786: PUSH
10787: LD_INT 2
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: PUSH
10799: LD_INT 0
10801: EQUAL
10802: IFFALSE 10656
// end ; end ;
10804: PPOPN 1
10806: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10807: LD_EXP 4
10811: IFFALSE 11866
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
10819: PPUSH
10820: PPUSH
10821: PPUSH
10822: PPUSH
10823: PPUSH
// begin Wait ( game_time ) ;
10824: LD_EXP 7
10828: PPUSH
10829: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10833: LD_INT 35
10835: PPUSH
10836: CALL_OW 67
// until ( not ru_can_attack ) ;
10840: LD_EXP 8
10844: NOT
10845: IFFALSE 10833
// Wait ( 0 0$35 ) ;
10847: LD_INT 1225
10849: PPUSH
10850: CALL_OW 67
// DialogueOn ;
10854: CALL_OW 6
// InGameOn ;
10858: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10862: LD_EXP 28
10866: PPUSH
10867: LD_STRING D12-Pow-1
10869: PPUSH
10870: CALL_OW 94
// InGameOff ;
10874: CALL_OW 9
// DialogueOff ;
10878: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10882: LD_STRING M4
10884: PPUSH
10885: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10889: LD_INT 5
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 424
// can_end := true ;
10899: LD_ADDR_EXP 17
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10907: LD_INT 35
10909: PPUSH
10910: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10914: CALL 943 0 0
10918: PUSH
10919: LD_INT 20
10921: GREATEREQUAL
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_INT 1
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 21
10935: PUSH
10936: LD_INT 1
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PPUSH
10947: CALL_OW 69
10951: PUSH
10952: LD_INT 5
10954: PPUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 70
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 1
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 55
10996: PUSH
10997: EMPTY
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PLUS
11009: LESSEQUAL
11010: AND
11011: IFFALSE 10907
// if not player_get_info then
11013: LD_EXP 15
11017: NOT
11018: IFFALSE 11029
// player_get_info := - 1 ;
11020: LD_ADDR_EXP 15
11024: PUSH
11025: LD_INT 1
11027: NEG
11028: ST_TO_ADDR
// m1 := player_get_info > 0 ;
11029: LD_ADDR_VAR 0 4
11033: PUSH
11034: LD_EXP 15
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: ST_TO_ADDR
// m2 := false ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// m3 := earlySib ;
11051: LD_ADDR_VAR 0 6
11055: PUSH
11056: LD_EXP 19
11060: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
11061: LD_STRING Information
11063: PPUSH
11064: LD_EXP 15
11068: PPUSH
11069: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
11073: LD_ADDR_VAR 0 2
11077: PUSH
11078: LD_INT 22
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 2
11090: PUSH
11091: LD_INT 25
11093: PUSH
11094: LD_INT 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 25
11103: PUSH
11104: LD_INT 16
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 34
11113: PUSH
11114: LD_INT 12
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PPUSH
11131: CALL_OW 69
11135: ST_TO_ADDR
// sib := GetTerminalCargo ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: CALL 943 0 0
11145: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
11146: LD_ADDR_VAR 0 3
11150: PUSH
11151: LD_VAR 0 3
11155: PUSH
11156: LD_INT 6
11158: PPUSH
11159: LD_INT 3
11161: PPUSH
11162: CALL_OW 287
11166: PLUS
11167: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11168: LD_ADDR_VAR 0 3
11172: PUSH
11173: LD_VAR 0 3
11177: PUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: LD_INT 3
11185: PPUSH
11186: CALL_OW 289
11190: PLUS
11191: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11192: LD_VAR 0 3
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_OWVAR 67
11204: PLUS
11205: PUSH
11206: LD_INT 50
11208: MUL
11209: LESS
11210: IFFALSE 11235
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11212: LD_STRING MuchSiberite
11214: PPUSH
11215: LD_INT 2
11217: NEG
11218: PUSH
11219: LD_OWVAR 67
11223: MUL
11224: PUSH
11225: LD_INT 1
11227: PLUS
11228: PPUSH
11229: CALL_OW 101
11233: GO 11253
// begin AddMedal ( MuchSiberite , 1 ) ;
11235: LD_STRING MuchSiberite
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 101
// m2 := true ;
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 1
11252: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11253: LD_VAR 0 4
11257: PUSH
11258: LD_VAR 0 5
11262: AND
11263: PUSH
11264: LD_VAR 0 6
11268: AND
11269: PUSH
11270: LD_OWVAR 67
11274: PUSH
11275: LD_INT 3
11277: EQUAL
11278: AND
11279: IFFALSE 11291
// SetAchievementEX ( ACH_AMER , 9 ) ;
11281: LD_STRING ACH_AMER
11283: PPUSH
11284: LD_INT 9
11286: PPUSH
11287: CALL_OW 564
// if tick <= 55 55$00 then
11291: LD_OWVAR 1
11295: PUSH
11296: LD_INT 115500
11298: LESSEQUAL
11299: IFFALSE 11308
// SetAchievement ( ACH_ASPEED_9 ) ;
11301: LD_STRING ACH_ASPEED_9
11303: PPUSH
11304: CALL_OW 543
// GiveMedals ( MAIN ) ;
11308: LD_STRING MAIN
11310: PPUSH
11311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PUSH
11325: LD_INT 2
11327: PUSH
11328: LD_INT 25
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 25
11340: PUSH
11341: LD_INT 2
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 25
11350: PUSH
11351: LD_INT 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: LD_INT 25
11360: PUSH
11361: LD_INT 4
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 25
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PPUSH
11395: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11399: LD_ADDR_VAR 0 2
11403: PUSH
11404: LD_INT 22
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 25
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 69
11432: ST_TO_ADDR
// if tmp then
11433: LD_VAR 0 2
11437: IFFALSE 11468
// for i in tmp do
11439: LD_ADDR_VAR 0 1
11443: PUSH
11444: LD_VAR 0 2
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11466
// SetClass ( i , 1 ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 336
11464: GO 11449
11466: POP
11467: POP
// SaveVariable ( sib , 09_sibRes ) ;
11468: LD_VAR 0 3
11472: PPUSH
11473: LD_STRING 09_sibRes
11475: PPUSH
11476: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11480: LD_EXP 15
11484: PPUSH
11485: LD_STRING 09_arInfo
11487: PPUSH
11488: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11492: LD_EXP 21
11496: PPUSH
11497: LD_EXP 1
11501: PUSH
11502: LD_STRING JMM
11504: STR
11505: PPUSH
11506: CALL_OW 38
// if IsLive ( Gary ) then
11510: LD_EXP 22
11514: PPUSH
11515: CALL_OW 300
11519: IFFALSE 11539
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11521: LD_EXP 22
11525: PPUSH
11526: LD_EXP 1
11530: PUSH
11531: LD_STRING Gary
11533: STR
11534: PPUSH
11535: CALL_OW 38
// if IsLive ( Bobby ) then
11539: LD_EXP 23
11543: PPUSH
11544: CALL_OW 300
11548: IFFALSE 11568
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11550: LD_EXP 23
11554: PPUSH
11555: LD_EXP 1
11559: PUSH
11560: LD_STRING Bobby
11562: STR
11563: PPUSH
11564: CALL_OW 38
// if IsLive ( Cyrus ) then
11568: LD_EXP 24
11572: PPUSH
11573: CALL_OW 300
11577: IFFALSE 11597
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11579: LD_EXP 24
11583: PPUSH
11584: LD_EXP 1
11588: PUSH
11589: LD_STRING Cyrus
11591: STR
11592: PPUSH
11593: CALL_OW 38
// if IsLive ( Houten ) then
11597: LD_EXP 25
11601: PPUSH
11602: CALL_OW 300
11606: IFFALSE 11626
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11608: LD_EXP 25
11612: PPUSH
11613: LD_EXP 1
11617: PUSH
11618: LD_STRING Houten
11620: STR
11621: PPUSH
11622: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 25
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 4
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 21
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 23
11714: PUSH
11715: LD_EXP 25
11719: PUSH
11720: LD_EXP 22
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: DIFF
11732: ST_TO_ADDR
// if tmp then
11733: LD_VAR 0 2
11737: IFFALSE 11757
// SaveCharacters ( tmp , mission_prefix & others ) ;
11739: LD_VAR 0 2
11743: PPUSH
11744: LD_EXP 1
11748: PUSH
11749: LD_STRING others
11751: STR
11752: PPUSH
11753: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11757: LD_ADDR_VAR 0 2
11761: PUSH
11762: LD_INT 22
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 12
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: LD_INT 25
11787: PUSH
11788: LD_INT 16
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PPUSH
11804: CALL_OW 69
11808: ST_TO_ADDR
// if tmp then
11809: LD_VAR 0 2
11813: IFFALSE 11833
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11815: LD_VAR 0 2
11819: PPUSH
11820: LD_EXP 1
11824: PUSH
11825: LD_STRING apes
11827: STR
11828: PPUSH
11829: CALL_OW 38
// if IsLive ( Yakotich ) then
11833: LD_EXP 37
11837: PPUSH
11838: CALL_OW 300
11842: IFFALSE 11862
// SaveCharacters ( Yakotich , mission_prefix & Yakotich ) ;
11844: LD_EXP 37
11848: PPUSH
11849: LD_EXP 1
11853: PUSH
11854: LD_STRING Yakotich
11856: STR
11857: PPUSH
11858: CALL_OW 38
// YouWin ;
11862: CALL_OW 103
// end ; end_of_file
11866: PPOPN 6
11868: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11869: LD_VAR 0 1
11873: PPUSH
11874: CALL_OW 266
11878: PUSH
11879: LD_INT 0
11881: EQUAL
11882: PUSH
11883: LD_EXP 3
11887: NOT
11888: AND
11889: IFFALSE 11913
// begin terminal := b ;
11891: LD_ADDR_EXP 3
11895: PUSH
11896: LD_VAR 0 1
11900: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11901: LD_EXP 3
11905: PPUSH
11906: LD_STRING terminal
11908: PPUSH
11909: CALL_OW 500
// end ; end ;
11913: PPOPN 2
11915: END
// on BuildingComplete ( b ) do var i ;
11916: LD_INT 0
11918: PPUSH
// begin if GetSide ( b ) = 3 then
11919: LD_VAR 0 1
11923: PPUSH
11924: CALL_OW 255
11928: PUSH
11929: LD_INT 3
11931: EQUAL
11932: IFFALSE 11972
// for i = 1 to 4 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 4
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11970
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11950: LD_ADDR_EXP 39
11954: PUSH
11955: LD_EXP 39
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 3
11967: ST_TO_ADDR
11968: GO 11947
11970: POP
11971: POP
// end ;
11972: PPOPN 2
11974: END
// on VehicleConstructed ( veh , fac ) do var i ;
11975: LD_INT 0
11977: PPUSH
// begin if GetSide ( veh ) = 3 then
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 255
11987: PUSH
11988: LD_INT 3
11990: EQUAL
11991: IFFALSE 12116
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 264
12002: PUSH
12003: LD_INT 53
12005: PUSH
12006: LD_INT 52
12008: PUSH
12009: LD_INT 51
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: LIST
12016: IN
12017: NOT
12018: IFFALSE 12036
// ru_force := ru_force ^ veh ;
12020: LD_ADDR_EXP 38
12024: PUSH
12025: LD_EXP 38
12029: PUSH
12030: LD_VAR 0 1
12034: ADD
12035: ST_TO_ADDR
// for i = 1 to 4 do
12036: LD_ADDR_VAR 0 3
12040: PUSH
12041: DOUBLE
12042: LD_INT 1
12044: DEC
12045: ST_TO_ADDR
12046: LD_INT 4
12048: PUSH
12049: FOR_TO
12050: IFFALSE 12072
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
12052: LD_ADDR_EXP 40
12056: PUSH
12057: LD_EXP 40
12061: PPUSH
12062: LD_INT 1
12064: PPUSH
12065: CALL_OW 3
12069: ST_TO_ADDR
12070: GO 12049
12072: POP
12073: POP
// if GetWeapon ( veh ) = ru_bulldozer then
12074: LD_VAR 0 1
12078: PPUSH
12079: CALL_OW 264
12083: PUSH
12084: LD_INT 53
12086: EQUAL
12087: IFFALSE 12116
// begin CutTreeInArea ( veh , cutTreeArea ) ;
12089: LD_VAR 0 1
12093: PPUSH
12094: LD_INT 7
12096: PPUSH
12097: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
12101: LD_VAR 0 1
12105: PPUSH
12106: LD_INT 170
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 171
// end ; end ; end ;
12116: PPOPN 3
12118: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
12119: LD_VAR 0 1
12123: PUSH
12124: LD_INT 1
12126: EQUAL
12127: PUSH
12128: LD_VAR 0 2
12132: PUSH
12133: LD_INT 2
12135: EQUAL
12136: AND
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 2
12145: EQUAL
12146: PUSH
12147: LD_VAR 0 2
12151: PUSH
12152: LD_INT 1
12154: EQUAL
12155: AND
12156: OR
12157: IFFALSE 12167
// player_attacked_ar := true ;
12159: LD_ADDR_EXP 16
12163: PUSH
12164: LD_INT 1
12166: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
12167: LD_VAR 0 1
12171: PUSH
12172: LD_INT 1
12174: EQUAL
12175: PUSH
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 4
12183: EQUAL
12184: AND
12185: PUSH
12186: LD_VAR 0 1
12190: PUSH
12191: LD_INT 4
12193: EQUAL
12194: PUSH
12195: LD_VAR 0 2
12199: PUSH
12200: LD_INT 1
12202: EQUAL
12203: AND
12204: OR
12205: IFFALSE 12214
// YouLost ( Traitor ) ;
12207: LD_STRING Traitor
12209: PPUSH
12210: CALL_OW 104
// end ;
12214: PPOPN 2
12216: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12217: LD_VAR 0 1
12221: PUSH
12222: LD_EXP 21
12226: EQUAL
12227: IFFALSE 12236
// YouLost ( JMM ) ;
12229: LD_STRING JMM
12231: PPUSH
12232: CALL_OW 104
// if un = terminal then
12236: LD_VAR 0 1
12240: PUSH
12241: LD_EXP 3
12245: EQUAL
12246: IFFALSE 12255
// YouLost ( Terminal ) ;
12248: LD_STRING Terminal
12250: PPUSH
12251: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 264
12264: PUSH
12265: LD_INT 53
12267: EQUAL
12268: IFFALSE 12284
// bulldozerCounter := bulldozerCounter + 1 ;
12270: LD_ADDR_EXP 20
12274: PUSH
12275: LD_EXP 20
12279: PUSH
12280: LD_INT 1
12282: PLUS
12283: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12284: LD_VAR 0 1
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 3
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 21
12301: PUSH
12302: LD_INT 3
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PPUSH
12313: CALL_OW 69
12317: IN
12318: IFFALSE 12464
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 266
12329: PUSH
12330: LD_INT 33
12332: PUSH
12333: LD_INT 26
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: IN
12340: IFFALSE 12399
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12342: LD_ADDR_EXP 39
12346: PUSH
12347: LD_EXP 39
12351: PUSH
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 266
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 250
12371: PUSH
12372: LD_VAR 0 1
12376: PPUSH
12377: CALL_OW 251
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 254
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: ADD
12398: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12399: LD_VAR 0 1
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_INT 5
12411: EQUAL
12412: IFFALSE 12464
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12414: LD_ADDR_EXP 39
12418: PUSH
12419: LD_EXP 39
12423: PUSH
12424: LD_INT 4
12426: PUSH
12427: LD_VAR 0 1
12431: PPUSH
12432: CALL_OW 250
12436: PUSH
12437: LD_VAR 0 1
12441: PPUSH
12442: CALL_OW 251
12446: PUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: ADD
12463: ST_TO_ADDR
// end ; if un in ru_force then
12464: LD_VAR 0 1
12468: PUSH
12469: LD_EXP 38
12473: IN
12474: IFFALSE 12510
// begin ru_force := ru_force diff un ;
12476: LD_ADDR_EXP 38
12480: PUSH
12481: LD_EXP 38
12485: PUSH
12486: LD_VAR 0 1
12490: DIFF
12491: ST_TO_ADDR
// if ru_force = 0 then
12492: LD_EXP 38
12496: PUSH
12497: LD_INT 0
12499: EQUAL
12500: IFFALSE 12510
// ru_can_attack := false ;
12502: LD_ADDR_EXP 8
12506: PUSH
12507: LD_INT 0
12509: ST_TO_ADDR
// end ; end ;
12510: PPOPN 1
12512: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12513: LD_VAR 0 1
12517: PPUSH
12518: CALL 28652 0 1
// end ; end_of_file
12522: PPOPN 1
12524: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12525: LD_EXP 5
12529: PUSH
12530: LD_EXP 6
12534: AND
12535: IFFALSE 12620
12537: GO 12539
12539: DISABLE
12540: LD_INT 0
12542: PPUSH
// begin enable ;
12543: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12544: LD_ADDR_VAR 0 1
12548: PUSH
12549: LD_INT 60
12551: PUSH
12552: CALL 943 0 0
12556: MINUS
12557: ST_TO_ADDR
// if sib < 0 then
12558: LD_VAR 0 1
12562: PUSH
12563: LD_INT 0
12565: LESS
12566: IFFALSE 12576
// sib := 0 ;
12568: LD_ADDR_VAR 0 1
12572: PUSH
12573: LD_INT 0
12575: ST_TO_ADDR
// if not debug then
12576: LD_EXP 2
12580: NOT
12581: IFFALSE 12606
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12583: LD_ADDR_OWVAR 47
12587: PUSH
12588: LD_STRING #Am09-1
12590: PUSH
12591: LD_VAR 0 1
12595: PUSH
12596: LD_EXP 6
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: LIST
12605: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12606: LD_ADDR_EXP 6
12610: PUSH
12611: LD_EXP 6
12615: PUSH
12616: LD_INT 35
12618: MINUS
12619: ST_TO_ADDR
// end ;
12620: PPOPN 1
12622: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12623: LD_EXP 6
12627: PUSH
12628: LD_INT 0
12630: EQUAL
12631: IFFALSE 12643
12633: GO 12635
12635: DISABLE
// display_strings := [ ] ;
12636: LD_ADDR_OWVAR 47
12640: PUSH
12641: EMPTY
12642: ST_TO_ADDR
12643: END
// every 1 1$35 do var i , tmp ;
12644: GO 12646
12646: DISABLE
12647: LD_INT 0
12649: PPUSH
12650: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: LD_INT 1155
12658: PUSH
12659: LD_INT 1225
12661: PUSH
12662: LD_INT 1435
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: LD_OWVAR 67
12674: ARRAY
12675: ST_TO_ADDR
// i := 0 ;
12676: LD_ADDR_VAR 0 1
12680: PUSH
12681: LD_INT 0
12683: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12684: LD_INT 1
12686: PPUSH
12687: LD_INT 5
12689: PPUSH
12690: CALL_OW 12
12694: PPUSH
12695: LD_INT 75
12697: PPUSH
12698: LD_INT 75
12700: PPUSH
12701: LD_INT 20
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL_OW 56
// wait ( tmp ) ;
12711: LD_VAR 0 2
12715: PPUSH
12716: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12720: LD_ADDR_VAR 0 2
12724: PUSH
12725: LD_VAR 0 2
12729: PUSH
12730: LD_INT 105
12732: PPUSH
12733: LD_INT 315
12735: PPUSH
12736: CALL_OW 12
12740: PLUS
12741: ST_TO_ADDR
// i := i + 1 ;
12742: LD_ADDR_VAR 0 1
12746: PUSH
12747: LD_VAR 0 1
12751: PUSH
12752: LD_INT 1
12754: PLUS
12755: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12756: LD_VAR 0 1
12760: PUSH
12761: LD_INT 3
12763: MOD
12764: PUSH
12765: LD_INT 0
12767: EQUAL
12768: PUSH
12769: LD_EXP 4
12773: AND
12774: IFFALSE 12812
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12776: LD_INT 2
12778: PPUSH
12779: LD_INT 5
12781: PPUSH
12782: CALL_OW 12
12786: PPUSH
12787: LD_INT 8
12789: PPUSH
12790: LD_INT 1
12792: PPUSH
12793: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12797: LD_INT 665
12799: PPUSH
12800: LD_INT 735
12802: PPUSH
12803: CALL_OW 12
12807: PPUSH
12808: CALL_OW 67
// end ; until tick > game_time ;
12812: LD_OWVAR 1
12816: PUSH
12817: LD_EXP 7
12821: GREATER
12822: IFFALSE 12684
// end ; end_of_file
12824: PPOPN 2
12826: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12827: LD_INT 0
12829: PPUSH
12830: PPUSH
12831: PPUSH
12832: PPUSH
12833: PPUSH
12834: PPUSH
// x := 76 ;
12835: LD_ADDR_VAR 0 5
12839: PUSH
12840: LD_INT 76
12842: ST_TO_ADDR
// y := 147 ;
12843: LD_ADDR_VAR 0 6
12847: PUSH
12848: LD_INT 147
12850: ST_TO_ADDR
// uc_side := 2 ;
12851: LD_ADDR_OWVAR 20
12855: PUSH
12856: LD_INT 2
12858: ST_TO_ADDR
// uc_nation := 2 ;
12859: LD_ADDR_OWVAR 21
12863: PUSH
12864: LD_INT 2
12866: ST_TO_ADDR
// InitHc ;
12867: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 6
12879: PPUSH
12880: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12884: LD_ADDR_OWVAR 26
12888: PUSH
12889: LD_STRING Nicolas Vervecken
12891: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12892: LD_ADDR_OWVAR 33
12896: PUSH
12897: LD_STRING SecondCharsGal
12899: ST_TO_ADDR
// hc_face_number := 3 ;
12900: LD_ADDR_OWVAR 34
12904: PUSH
12905: LD_INT 3
12907: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12908: LD_ADDR_OWVAR 29
12912: PUSH
12913: LD_INT 11
12915: PUSH
12916: LD_INT 10
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: ST_TO_ADDR
// Vervecken := CreateHuman ;
12923: LD_ADDR_EXP 29
12927: PUSH
12928: CALL_OW 44
12932: ST_TO_ADDR
// ar_force := Vervecken ;
12933: LD_ADDR_EXP 36
12937: PUSH
12938: LD_EXP 29
12942: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 2
12948: PPUSH
12949: LD_INT 6
12951: PPUSH
12952: CALL_OW 380
// hc_name := Louis Gali ;
12956: LD_ADDR_OWVAR 26
12960: PUSH
12961: LD_STRING Louis Gali
12963: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12964: LD_ADDR_OWVAR 33
12968: PUSH
12969: LD_STRING SecondCharsGal
12971: ST_TO_ADDR
// hc_face_number := 2 ;
12972: LD_ADDR_OWVAR 34
12976: PUSH
12977: LD_INT 2
12979: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12980: LD_ADDR_OWVAR 29
12984: PUSH
12985: LD_INT 10
12987: PUSH
12988: LD_INT 11
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// Gali := CreateHuman ;
12995: LD_ADDR_EXP 30
12999: PUSH
13000: CALL_OW 44
13004: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
13005: LD_ADDR_EXP 36
13009: PUSH
13010: LD_EXP 36
13014: PUSH
13015: LD_EXP 30
13019: ADD
13020: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
13021: LD_INT 2
13023: PPUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_INT 6
13029: PPUSH
13030: CALL_OW 380
// hc_name := Maria Bogdanovic ;
13034: LD_ADDR_OWVAR 26
13038: PUSH
13039: LD_STRING Maria Bogdanovic
13041: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13042: LD_ADDR_OWVAR 33
13046: PUSH
13047: LD_STRING SecondCharsGal
13049: ST_TO_ADDR
// hc_face_number := 14 ;
13050: LD_ADDR_OWVAR 34
13054: PUSH
13055: LD_INT 14
13057: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
13058: LD_ADDR_OWVAR 29
13062: PUSH
13063: LD_INT 12
13065: PUSH
13066: LD_INT 9
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
13073: LD_ADDR_EXP 31
13077: PUSH
13078: CALL_OW 44
13082: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
13083: LD_ADDR_EXP 36
13087: PUSH
13088: LD_EXP 36
13092: PUSH
13093: LD_EXP 31
13097: ADD
13098: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13099: LD_INT 1
13101: PPUSH
13102: LD_INT 3
13104: PPUSH
13105: LD_INT 6
13107: PPUSH
13108: CALL_OW 380
// hc_name = Kntor Radomr ;
13112: LD_ADDR_OWVAR 26
13116: PUSH
13117: LD_STRING Kntor Radomr
13119: ST_TO_ADDR
// hc_gallery = sandar ;
13120: LD_ADDR_OWVAR 33
13124: PUSH
13125: LD_STRING sandar
13127: ST_TO_ADDR
// hc_face_number = 12 ;
13128: LD_ADDR_OWVAR 34
13132: PUSH
13133: LD_INT 12
13135: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
13136: LD_ADDR_OWVAR 29
13140: PUSH
13141: LD_INT 9
13143: PUSH
13144: LD_INT 9
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: ST_TO_ADDR
// Kantor = CreateHuman ;
13151: LD_ADDR_EXP 32
13155: PUSH
13156: CALL_OW 44
13160: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
13161: LD_ADDR_EXP 36
13165: PUSH
13166: LD_EXP 36
13170: PUSH
13171: LD_EXP 32
13175: ADD
13176: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 3
13182: PPUSH
13183: LD_INT 6
13185: PPUSH
13186: CALL_OW 380
// hc_name = Herczeg Farkas ;
13190: LD_ADDR_OWVAR 26
13194: PUSH
13195: LD_STRING Herczeg Farkas
13197: ST_TO_ADDR
// hc_gallery = sandar ;
13198: LD_ADDR_OWVAR 33
13202: PUSH
13203: LD_STRING sandar
13205: ST_TO_ADDR
// hc_face_number = 28 ;
13206: LD_ADDR_OWVAR 34
13210: PUSH
13211: LD_INT 28
13213: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13214: LD_ADDR_OWVAR 29
13218: PUSH
13219: LD_INT 10
13221: PUSH
13222: LD_INT 9
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: ST_TO_ADDR
// Herczeg = CreateHuman ;
13229: LD_ADDR_EXP 33
13233: PUSH
13234: CALL_OW 44
13238: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13239: LD_ADDR_EXP 36
13243: PUSH
13244: LD_EXP 36
13248: PUSH
13249: LD_EXP 33
13253: ADD
13254: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13255: LD_INT 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: LD_INT 6
13263: PPUSH
13264: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13268: LD_ADDR_OWVAR 26
13272: PUSH
13273: LD_STRING Ronn Horntvedt
13275: ST_TO_ADDR
// hc_gallery = sandar ;
13276: LD_ADDR_OWVAR 33
13280: PUSH
13281: LD_STRING sandar
13283: ST_TO_ADDR
// hc_face_number = 29 ;
13284: LD_ADDR_OWVAR 34
13288: PUSH
13289: LD_INT 29
13291: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13292: LD_ADDR_OWVAR 29
13296: PUSH
13297: LD_INT 11
13299: PUSH
13300: LD_INT 11
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: ST_TO_ADDR
// Ronn = CreateHuman ;
13307: LD_ADDR_EXP 34
13311: PUSH
13312: CALL_OW 44
13316: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13317: LD_ADDR_EXP 36
13321: PUSH
13322: LD_EXP 36
13326: PUSH
13327: LD_EXP 34
13331: ADD
13332: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13333: LD_INT 2
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 6
13341: PPUSH
13342: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13346: LD_ADDR_OWVAR 26
13350: PUSH
13351: LD_STRING Mia D. Mathiasen
13353: ST_TO_ADDR
// hc_gallery = sandar ;
13354: LD_ADDR_OWVAR 33
13358: PUSH
13359: LD_STRING sandar
13361: ST_TO_ADDR
// hc_face_number = 31 ;
13362: LD_ADDR_OWVAR 34
13366: PUSH
13367: LD_INT 31
13369: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13370: LD_ADDR_OWVAR 29
13374: PUSH
13375: LD_INT 10
13377: PUSH
13378: LD_INT 10
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: ST_TO_ADDR
// Mia = CreateHuman ;
13385: LD_ADDR_EXP 35
13389: PUSH
13390: CALL_OW 44
13394: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13395: LD_ADDR_EXP 36
13399: PUSH
13400: LD_EXP 36
13404: PUSH
13405: LD_EXP 35
13409: ADD
13410: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13411: LD_ADDR_VAR 0 3
13415: PUSH
13416: LD_VAR 0 3
13420: PUSH
13421: LD_INT 2
13423: PPUSH
13424: LD_INT 2
13426: PPUSH
13427: LD_INT 14
13429: PPUSH
13430: LD_INT 1
13432: PPUSH
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 32
13438: PPUSH
13439: LD_INT 30
13441: PPUSH
13442: CALL 423 0 7
13446: ADD
13447: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_INT 2
13460: PPUSH
13461: LD_INT 2
13463: PPUSH
13464: LD_INT 14
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: LD_INT 1
13472: PPUSH
13473: LD_INT 27
13475: PPUSH
13476: LD_INT 30
13478: PPUSH
13479: CALL 423 0 7
13483: ADD
13484: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_VAR 0 3
13494: PUSH
13495: LD_INT 2
13497: PPUSH
13498: LD_INT 2
13500: PPUSH
13501: LD_INT 14
13503: PPUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_INT 25
13512: PPUSH
13513: LD_INT 33
13515: PPUSH
13516: CALL 423 0 7
13520: ADD
13521: ST_TO_ADDR
// tmp := tmp diff 0 ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_INT 0
13534: DIFF
13535: ST_TO_ADDR
// for i in ar_force do
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_EXP 36
13545: PUSH
13546: FOR_IN
13547: IFFALSE 13690
// begin if GetClass ( i ) = 3 then
13549: LD_VAR 0 4
13553: PPUSH
13554: CALL_OW 257
13558: PUSH
13559: LD_INT 3
13561: EQUAL
13562: IFFALSE 13644
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13564: LD_VAR 0 3
13568: PUSH
13569: LD_INT 1
13571: ARRAY
13572: PPUSH
13573: LD_INT 1
13575: PPUSH
13576: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: PPUSH
13589: LD_VAR 0 5
13593: PPUSH
13594: LD_VAR 0 6
13598: PPUSH
13599: LD_INT 0
13601: PPUSH
13602: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13606: LD_VAR 0 4
13610: PPUSH
13611: LD_VAR 0 3
13615: PUSH
13616: LD_INT 1
13618: ARRAY
13619: PPUSH
13620: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13624: LD_ADDR_VAR 0 3
13628: PUSH
13629: LD_VAR 0 3
13633: PPUSH
13634: LD_INT 1
13636: PPUSH
13637: CALL_OW 3
13641: ST_TO_ADDR
// end else
13642: GO 13666
// PlaceUnitXY ( i , x , y , false ) ;
13644: LD_VAR 0 4
13648: PPUSH
13649: LD_VAR 0 5
13653: PPUSH
13654: LD_VAR 0 6
13658: PPUSH
13659: LD_INT 0
13661: PPUSH
13662: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13666: LD_VAR 0 4
13670: PPUSH
13671: LD_INT 86
13673: PPUSH
13674: LD_INT 121
13676: PPUSH
13677: CALL_OW 111
// wait ( 0 0$2 ) ;
13681: LD_INT 70
13683: PPUSH
13684: CALL_OW 67
// end ;
13688: GO 13546
13690: POP
13691: POP
// ar_force := ar_force ^ tmp ;
13692: LD_ADDR_EXP 36
13696: PUSH
13697: LD_EXP 36
13701: PUSH
13702: LD_VAR 0 3
13706: ADD
13707: ST_TO_ADDR
// ar_spawned := true ;
13708: LD_ADDR_EXP 11
13712: PUSH
13713: LD_INT 1
13715: ST_TO_ADDR
// end ; end_of_file
13716: LD_VAR 0 1
13720: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13721: LD_INT 0
13723: PPUSH
13724: PPUSH
13725: PPUSH
13726: PPUSH
13727: PPUSH
13728: PPUSH
13729: PPUSH
// InitHc ;
13730: CALL_OW 19
// uc_side := 3 ;
13734: LD_ADDR_OWVAR 20
13738: PUSH
13739: LD_INT 3
13741: ST_TO_ADDR
// uc_nation := 3 ;
13742: LD_ADDR_OWVAR 21
13746: PUSH
13747: LD_INT 3
13749: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13750: LD_ADDR_VAR 0 5
13754: PUSH
13755: LD_INT 5
13757: PUSH
13758: LD_INT 6
13760: PUSH
13761: LD_INT 7
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: ST_TO_ADDR
// ru_force := [ ] ;
13775: LD_ADDR_EXP 38
13779: PUSH
13780: EMPTY
13781: ST_TO_ADDR
// ru_rebuild := [ ] ;
13782: LD_ADDR_EXP 39
13786: PUSH
13787: EMPTY
13788: ST_TO_ADDR
// ru_produce_list := [ ] ;
13789: LD_ADDR_EXP 40
13793: PUSH
13794: EMPTY
13795: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13796: LD_ADDR_VAR 0 6
13800: PUSH
13801: LD_INT 22
13803: PUSH
13804: LD_INT 3
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: PUSH
13811: LD_INT 30
13813: PUSH
13814: LD_INT 8
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PPUSH
13825: CALL_OW 69
13829: PUSH
13830: LD_INT 1
13832: ARRAY
13833: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13834: LD_ADDR_VAR 0 4
13838: PUSH
13839: LD_INT 43
13841: PUSH
13842: LD_INT 46
13844: PUSH
13845: LD_INT 45
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13853: LD_ADDR_VAR 0 7
13857: PUSH
13858: LD_INT 22
13860: PUSH
13861: LD_INT 3
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: LD_INT 30
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 69
13886: PUSH
13887: LD_INT 1
13889: ARRAY
13890: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13891: LD_VAR 0 7
13895: PPUSH
13896: CALL_OW 274
13900: PPUSH
13901: LD_INT 1
13903: PPUSH
13904: LD_INT 5000
13906: PPUSH
13907: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13911: LD_VAR 0 7
13915: PPUSH
13916: CALL_OW 274
13920: PPUSH
13921: LD_INT 2
13923: PPUSH
13924: LD_INT 1000
13926: PPUSH
13927: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13931: LD_VAR 0 7
13935: PPUSH
13936: CALL_OW 274
13940: PPUSH
13941: LD_INT 3
13943: PPUSH
13944: LD_INT 30
13946: PPUSH
13947: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 3
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: PUSH
13985: FOR_IN
13986: IFFALSE 14019
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
13988: LD_VAR 0 2
13992: PPUSH
13993: LD_INT 5
13995: PUSH
13996: LD_INT 6
13998: PUSH
13999: LD_INT 7
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: LIST
14006: PUSH
14007: LD_OWVAR 67
14011: ARRAY
14012: PPUSH
14013: CALL_OW 241
14017: GO 13985
14019: POP
14020: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 22
14028: PUSH
14029: LD_INT 3
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 30
14038: PUSH
14039: LD_INT 33
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: CALL_OW 69
14054: PUSH
14055: FOR_IN
14056: IFFALSE 14088
// PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
14058: LD_VAR 0 2
14062: PPUSH
14063: LD_VAR 0 4
14067: PUSH
14068: LD_VAR 0 2
14072: PUSH
14073: LD_INT 3
14075: MOD
14076: PUSH
14077: LD_INT 1
14079: PLUS
14080: ARRAY
14081: PPUSH
14082: CALL_OW 431
14086: GO 14055
14088: POP
14089: POP
// for i = 1 to 4 do
14090: LD_ADDR_VAR 0 2
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 4
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14165
// begin PrepareHuman ( false , class_bazooker , skill ) ;
14106: LD_INT 0
14108: PPUSH
14109: LD_INT 9
14111: PPUSH
14112: LD_VAR 0 5
14116: PPUSH
14117: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
14121: CALL_OW 44
14125: PPUSH
14126: LD_INT 22
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 30
14138: PUSH
14139: LD_INT 5
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PPUSH
14150: CALL_OW 69
14154: PUSH
14155: LD_INT 1
14157: ARRAY
14158: PPUSH
14159: CALL_OW 52
// end ;
14163: GO 14103
14165: POP
14166: POP
// for i = 1 to 5 do
14167: LD_ADDR_VAR 0 2
14171: PUSH
14172: DOUBLE
14173: LD_INT 1
14175: DEC
14176: ST_TO_ADDR
14177: LD_INT 5
14179: PUSH
14180: FOR_TO
14181: IFFALSE 14242
// begin PrepareHuman ( false , class_mechanic , skill ) ;
14183: LD_INT 0
14185: PPUSH
14186: LD_INT 3
14188: PPUSH
14189: LD_VAR 0 5
14193: PPUSH
14194: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
14198: CALL_OW 44
14202: PPUSH
14203: LD_INT 22
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 3
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 69
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: PPUSH
14236: CALL_OW 52
// end ;
14240: GO 14180
14242: POP
14243: POP
// for i = 1 to 4 do
14244: LD_ADDR_VAR 0 2
14248: PUSH
14249: DOUBLE
14250: LD_INT 1
14252: DEC
14253: ST_TO_ADDR
14254: LD_INT 4
14256: PUSH
14257: FOR_TO
14258: IFFALSE 14319
// begin PrepareHuman ( false , class_engineer , skill ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 2
14265: PPUSH
14266: LD_VAR 0 5
14270: PPUSH
14271: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_INT 22
14282: PUSH
14283: LD_INT 3
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: PUSH
14290: LD_INT 30
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: PPUSH
14304: CALL_OW 69
14308: PUSH
14309: LD_INT 1
14311: ARRAY
14312: PPUSH
14313: CALL_OW 52
// end ;
14317: GO 14257
14319: POP
14320: POP
// for i = 1 to 3 do
14321: LD_ADDR_VAR 0 2
14325: PUSH
14326: DOUBLE
14327: LD_INT 1
14329: DEC
14330: ST_TO_ADDR
14331: LD_INT 3
14333: PUSH
14334: FOR_TO
14335: IFFALSE 14368
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 4
14342: PPUSH
14343: LD_VAR 0 5
14347: PPUSH
14348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14352: CALL_OW 44
14356: PPUSH
14357: LD_VAR 0 6
14361: PPUSH
14362: CALL_OW 52
// end ;
14366: GO 14334
14368: POP
14369: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14370: LD_ADDR_EXP 37
14374: PUSH
14375: LD_STRING Yakotich
14377: PPUSH
14378: LD_EXP 2
14382: NOT
14383: PPUSH
14384: LD_STRING 
14386: PPUSH
14387: CALL 360 0 3
14391: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14392: LD_EXP 37
14396: PPUSH
14397: LD_INT 74
14399: PPUSH
14400: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14404: LD_VAR 0 6
14408: PPUSH
14409: LD_INT 49
14411: PPUSH
14412: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14416: LD_VAR 0 6
14420: PPUSH
14421: LD_INT 50
14423: PPUSH
14424: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14428: LD_VAR 0 6
14432: PPUSH
14433: LD_INT 51
14435: PPUSH
14436: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14440: LD_VAR 0 6
14444: PPUSH
14445: LD_INT 52
14447: PPUSH
14448: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14452: LD_VAR 0 6
14456: PPUSH
14457: LD_INT 69
14459: PPUSH
14460: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14464: LD_VAR 0 6
14468: PPUSH
14469: LD_INT 39
14471: PPUSH
14472: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14476: LD_VAR 0 6
14480: PPUSH
14481: LD_INT 34
14483: PPUSH
14484: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14488: LD_VAR 0 6
14492: PPUSH
14493: LD_INT 40
14495: PPUSH
14496: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14500: LD_VAR 0 6
14504: PPUSH
14505: LD_INT 57
14507: PPUSH
14508: CALL_OW 184
// if Difficulty > 1 then
14512: LD_OWVAR 67
14516: PUSH
14517: LD_INT 1
14519: GREATER
14520: IFFALSE 14534
// AddComResearch ( lab , tech_comp2 ) ;
14522: LD_VAR 0 6
14526: PPUSH
14527: LD_INT 58
14529: PPUSH
14530: CALL_OW 184
// end ;
14534: LD_VAR 0 1
14538: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14539: LD_INT 7
14541: PPUSH
14542: CALL_OW 353
14546: PUSH
14547: LD_INT 3
14549: GREATER
14550: PUSH
14551: LD_INT 22
14553: PUSH
14554: LD_INT 3
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PUSH
14561: LD_INT 34
14563: PUSH
14564: LD_INT 53
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: PPUSH
14575: CALL_OW 69
14579: NOT
14580: AND
14581: IFFALSE 14616
14583: GO 14585
14585: DISABLE
// begin enable ;
14586: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14587: LD_ADDR_EXP 40
14591: PUSH
14592: LD_EXP 40
14596: PUSH
14597: LD_INT 24
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 3
14605: PUSH
14606: LD_INT 53
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ADD
14615: ST_TO_ADDR
// end ;
14616: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14617: LD_INT 22
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 3
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: IFFALSE 15423
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
14658: PPUSH
14659: PPUSH
// begin enable ;
14660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14661: LD_ADDR_VAR 0 3
14665: PUSH
14666: LD_INT 22
14668: PUSH
14669: LD_INT 3
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 21
14678: PUSH
14679: LD_INT 3
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 3
14688: PUSH
14689: LD_INT 24
14691: PUSH
14692: LD_INT 1000
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14713: LD_ADDR_VAR 0 4
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: LD_INT 25
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PPUSH
14742: CALL_OW 69
14746: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14747: LD_ADDR_VAR 0 5
14751: PUSH
14752: LD_INT 22
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 30
14764: PUSH
14765: LD_INT 1
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PPUSH
14776: CALL_OW 69
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14785: LD_ADDR_VAR 0 8
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 3
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 6
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 30
14815: PUSH
14816: LD_INT 7
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 30
14825: PUSH
14826: LD_INT 8
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 1
14850: ARRAY
14851: ST_TO_ADDR
// if not engs then
14852: LD_VAR 0 4
14856: NOT
14857: IFFALSE 14861
// exit ;
14859: GO 15423
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14861: LD_ADDR_VAR 0 6
14865: PUSH
14866: LD_VAR 0 4
14870: PPUSH
14871: LD_INT 3
14873: PUSH
14874: LD_INT 24
14876: PUSH
14877: LD_INT 600
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 72
14892: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14893: LD_ADDR_VAR 0 7
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 3
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 4
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14927: LD_VAR 0 3
14931: NOT
14932: PUSH
14933: LD_EXP 39
14937: NOT
14938: AND
14939: IFFALSE 14999
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14941: LD_VAR 0 4
14945: PPUSH
14946: LD_INT 3
14948: PUSH
14949: LD_INT 54
14951: PUSH
14952: EMPTY
14953: LIST
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PPUSH
14959: CALL_OW 72
14963: IFFALSE 14997
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14965: LD_VAR 0 4
14969: PPUSH
14970: LD_INT 3
14972: PUSH
14973: LD_INT 54
14975: PUSH
14976: EMPTY
14977: LIST
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: CALL_OW 72
14987: PPUSH
14988: LD_VAR 0 5
14992: PPUSH
14993: CALL_OW 120
// exit ;
14997: GO 15423
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14999: LD_VAR 0 4
15003: PPUSH
15004: LD_INT 54
15006: PUSH
15007: EMPTY
15008: LIST
15009: PPUSH
15010: CALL_OW 72
15014: IFFALSE 15036
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
15016: LD_VAR 0 4
15020: PPUSH
15021: LD_INT 54
15023: PUSH
15024: EMPTY
15025: LIST
15026: PPUSH
15027: CALL_OW 72
15031: PPUSH
15032: CALL_OW 122
// if not tmp then
15036: LD_VAR 0 3
15040: NOT
15041: IFFALSE 15173
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
15043: LD_INT 81
15045: PUSH
15046: LD_INT 3
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 92
15055: PUSH
15056: LD_INT 147
15058: PUSH
15059: LD_INT 212
15061: PUSH
15062: LD_INT 30
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PPUSH
15075: CALL_OW 69
15079: NOT
15080: IFFALSE 15173
// begin if not HasTask ( engs [ 1 ] ) then
15082: LD_VAR 0 4
15086: PUSH
15087: LD_INT 1
15089: ARRAY
15090: PPUSH
15091: CALL_OW 314
15095: NOT
15096: IFFALSE 15173
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
15098: LD_ADDR_VAR 0 2
15102: PUSH
15103: LD_VAR 0 4
15107: PPUSH
15108: LD_EXP 39
15112: PUSH
15113: LD_INT 1
15115: ARRAY
15116: PPUSH
15117: LD_EXP 39
15121: PUSH
15122: LD_INT 2
15124: ARRAY
15125: PPUSH
15126: LD_EXP 39
15130: PUSH
15131: LD_INT 3
15133: ARRAY
15134: PPUSH
15135: LD_EXP 39
15139: PUSH
15140: LD_INT 4
15142: ARRAY
15143: PPUSH
15144: CALL_OW 145
15148: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
15149: LD_VAR 0 2
15153: PPUSH
15154: CALL_OW 266
15158: PUSH
15159: LD_INT 4
15161: EQUAL
15162: IFFALSE 15173
// AddComUpgrade ( i ) ;
15164: LD_VAR 0 2
15168: PPUSH
15169: CALL_OW 206
// end ; end ; end ; for i in engs do
15173: LD_ADDR_VAR 0 2
15177: PUSH
15178: LD_VAR 0 4
15182: PUSH
15183: FOR_IN
15184: IFFALSE 15302
// begin if i in to_heal and sci then
15186: LD_VAR 0 2
15190: PUSH
15191: LD_VAR 0 6
15195: IN
15196: PUSH
15197: LD_VAR 0 7
15201: AND
15202: IFFALSE 15253
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
15204: LD_VAR 0 2
15208: PPUSH
15209: LD_INT 149
15211: PPUSH
15212: LD_INT 220
15214: PPUSH
15215: CALL_OW 297
15219: PUSH
15220: LD_INT 5
15222: LESS
15223: IFFALSE 15227
// continue ;
15225: GO 15183
// ComMoveXY ( i , 149 , 220 ) ;
15227: LD_VAR 0 2
15231: PPUSH
15232: LD_INT 149
15234: PPUSH
15235: LD_INT 220
15237: PPUSH
15238: CALL_OW 111
// AddComHold ( i ) ;
15242: LD_VAR 0 2
15246: PPUSH
15247: CALL_OW 200
// end else
15251: GO 15300
// if not HasTask ( i ) or WantsToAttack ( i ) then
15253: LD_VAR 0 2
15257: PPUSH
15258: CALL_OW 314
15262: NOT
15263: PUSH
15264: LD_VAR 0 2
15268: PPUSH
15269: CALL_OW 319
15273: OR
15274: IFFALSE 15300
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15276: LD_VAR 0 2
15280: PPUSH
15281: LD_VAR 0 3
15285: PPUSH
15286: LD_VAR 0 2
15290: PPUSH
15291: CALL_OW 74
15295: PPUSH
15296: CALL_OW 130
// end ;
15300: GO 15183
15302: POP
15303: POP
// if to_heal and sci then
15304: LD_VAR 0 6
15308: PUSH
15309: LD_VAR 0 7
15313: AND
15314: IFFALSE 15375
// begin if UnitFilter ( sci , [ f_inside ] ) then
15316: LD_VAR 0 7
15320: PPUSH
15321: LD_INT 54
15323: PUSH
15324: EMPTY
15325: LIST
15326: PPUSH
15327: CALL_OW 72
15331: IFFALSE 15355
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15333: LD_VAR 0 7
15337: PPUSH
15338: LD_INT 54
15340: PUSH
15341: EMPTY
15342: LIST
15343: PPUSH
15344: CALL_OW 72
15348: PPUSH
15349: CALL_OW 122
15353: GO 15373
// ComHeal ( sci , to_heal [ 1 ] ) ;
15355: LD_VAR 0 7
15359: PPUSH
15360: LD_VAR 0 6
15364: PUSH
15365: LD_INT 1
15367: ARRAY
15368: PPUSH
15369: CALL_OW 128
// end else
15373: GO 15423
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 56
15382: PUSH
15383: EMPTY
15384: LIST
15385: PPUSH
15386: CALL_OW 72
15390: PUSH
15391: LD_VAR 0 8
15395: AND
15396: IFFALSE 15423
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15398: LD_VAR 0 7
15402: PPUSH
15403: LD_INT 56
15405: PUSH
15406: EMPTY
15407: LIST
15408: PPUSH
15409: CALL_OW 72
15413: PPUSH
15414: LD_VAR 0 8
15418: PPUSH
15419: CALL_OW 120
// end ;
15423: PPOPN 8
15425: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15426: LD_INT 22
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PPUSH
15450: CALL_OW 69
15454: PUSH
15455: LD_EXP 40
15459: AND
15460: IFFALSE 15586
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
15468: PPUSH
15469: PPUSH
// begin enable ;
15470: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 22
15478: PUSH
15479: LD_INT 3
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: LD_INT 30
15488: PUSH
15489: LD_INT 3
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PPUSH
15500: CALL_OW 69
15504: PUSH
15505: LD_INT 1
15507: ARRAY
15508: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15509: LD_VAR 0 3
15513: PPUSH
15514: CALL_OW 313
15518: PUSH
15519: LD_INT 0
15521: EQUAL
15522: IFFALSE 15526
// exit ;
15524: GO 15586
// if BuildingStatus ( fac ) = bs_idle then
15526: LD_VAR 0 3
15530: PPUSH
15531: CALL_OW 461
15535: PUSH
15536: LD_INT 2
15538: EQUAL
15539: IFFALSE 15586
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_EXP 40
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_EXP 40
15559: PUSH
15560: LD_INT 2
15562: ARRAY
15563: PPUSH
15564: LD_EXP 40
15568: PUSH
15569: LD_INT 3
15571: ARRAY
15572: PPUSH
15573: LD_EXP 40
15577: PUSH
15578: LD_INT 4
15580: ARRAY
15581: PPUSH
15582: CALL_OW 125
// end ;
15586: PPOPN 3
15588: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15589: LD_INT 0
15591: PPUSH
15592: PPUSH
15593: PPUSH
15594: PPUSH
15595: PPUSH
// uc_side := 3 ;
15596: LD_ADDR_OWVAR 20
15600: PUSH
15601: LD_INT 3
15603: ST_TO_ADDR
// uc_nation := 3 ;
15604: LD_ADDR_OWVAR 21
15608: PUSH
15609: LD_INT 3
15611: ST_TO_ADDR
// ru_can_attack := false ;
15612: LD_ADDR_EXP 8
15616: PUSH
15617: LD_INT 0
15619: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15620: LD_ADDR_VAR 0 6
15624: PUSH
15625: LD_INT 22
15627: PUSH
15628: LD_INT 3
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: LD_INT 30
15637: PUSH
15638: LD_INT 3
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL_OW 69
15653: ST_TO_ADDR
// if fac then
15654: LD_VAR 0 6
15658: IFFALSE 15810
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15660: LD_ADDR_EXP 40
15664: PUSH
15665: LD_INT 24
15667: PUSH
15668: LD_INT 1
15670: PUSH
15671: LD_INT 3
15673: PUSH
15674: LD_INT 43
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: ST_TO_ADDR
// if wave > 1 then
15683: LD_VAR 0 1
15687: PUSH
15688: LD_INT 1
15690: GREATER
15691: IFFALSE 15744
// for i = 1 to Difficulty do
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: DOUBLE
15699: LD_INT 1
15701: DEC
15702: ST_TO_ADDR
15703: LD_OWVAR 67
15707: PUSH
15708: FOR_TO
15709: IFFALSE 15742
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15711: LD_ADDR_EXP 40
15715: PUSH
15716: LD_EXP 40
15720: PUSH
15721: LD_INT 24
15723: PUSH
15724: LD_INT 1
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: LD_INT 45
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: LIST
15737: LIST
15738: ADD
15739: ST_TO_ADDR
15740: GO 15708
15742: POP
15743: POP
// repeat wait ( 0 0$1 ) ;
15744: LD_INT 35
15746: PPUSH
15747: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15751: LD_EXP 40
15755: PUSH
15756: LD_INT 4
15758: LESS
15759: PUSH
15760: LD_VAR 0 6
15764: PUSH
15765: LD_INT 1
15767: ARRAY
15768: PPUSH
15769: CALL_OW 313
15773: PUSH
15774: LD_INT 0
15776: EQUAL
15777: OR
15778: PUSH
15779: LD_VAR 0 6
15783: PUSH
15784: LD_INT 1
15786: ARRAY
15787: PPUSH
15788: CALL_OW 461
15792: PUSH
15793: LD_INT 8
15795: PUSH
15796: LD_INT 6
15798: PUSH
15799: LD_INT 7
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: IN
15807: OR
15808: IFFALSE 15744
// end ; case wave of 1 :
15810: LD_VAR 0 1
15814: PUSH
15815: LD_INT 1
15817: DOUBLE
15818: EQUAL
15819: IFTRUE 15823
15821: GO 15908
15823: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15824: LD_ADDR_VAR 0 3
15828: PUSH
15829: DOUBLE
15830: LD_INT 1
15832: DEC
15833: ST_TO_ADDR
15834: LD_INT 2
15836: PUSH
15837: LD_INT 3
15839: PUSH
15840: LD_INT 4
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: LIST
15847: PUSH
15848: LD_OWVAR 67
15852: ARRAY
15853: PUSH
15854: FOR_TO
15855: IFFALSE 15863
// Sold ;
15857: CALL 16134 0 0
15861: GO 15854
15863: POP
15864: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15865: LD_ADDR_VAR 0 3
15869: PUSH
15870: DOUBLE
15871: LD_INT 1
15873: DEC
15874: ST_TO_ADDR
15875: LD_INT 2
15877: PUSH
15878: LD_INT 3
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: PUSH
15889: LD_OWVAR 67
15893: ARRAY
15894: PUSH
15895: FOR_TO
15896: IFFALSE 15904
// Tank ;
15898: CALL 16264 0 0
15902: GO 15895
15904: POP
15905: POP
// end ; 2 .. 9 :
15906: GO 16121
15908: LD_INT 2
15910: DOUBLE
15911: GREATEREQUAL
15912: IFFALSE 15920
15914: LD_INT 9
15916: DOUBLE
15917: LESSEQUAL
15918: IFTRUE 15922
15920: GO 16027
15922: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15923: LD_ADDR_VAR 0 3
15927: PUSH
15928: DOUBLE
15929: LD_INT 1
15931: DEC
15932: ST_TO_ADDR
15933: LD_INT 2
15935: PUSH
15936: LD_INT 4
15938: PUSH
15939: LD_INT 5
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: PUSH
15947: LD_OWVAR 67
15951: ARRAY
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: LD_INT 2
15960: DIV
15961: PLUS
15962: PUSH
15963: FOR_TO
15964: IFFALSE 15972
// Sold ;
15966: CALL 16134 0 0
15970: GO 15963
15972: POP
15973: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15974: LD_ADDR_VAR 0 3
15978: PUSH
15979: DOUBLE
15980: LD_INT 1
15982: DEC
15983: ST_TO_ADDR
15984: LD_INT 2
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: PUSH
15998: LD_OWVAR 67
16002: ARRAY
16003: PUSH
16004: LD_VAR 0 1
16008: PUSH
16009: LD_INT 2
16011: DIV
16012: PLUS
16013: PUSH
16014: FOR_TO
16015: IFFALSE 16023
// Tank ;
16017: CALL 16264 0 0
16021: GO 16014
16023: POP
16024: POP
// end ; 10 :
16025: GO 16121
16027: LD_INT 10
16029: DOUBLE
16030: EQUAL
16031: IFTRUE 16035
16033: GO 16120
16035: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
16036: LD_ADDR_VAR 0 3
16040: PUSH
16041: DOUBLE
16042: LD_INT 1
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 10
16048: PUSH
16049: LD_INT 12
16051: PUSH
16052: LD_INT 14
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: PUSH
16060: LD_OWVAR 67
16064: ARRAY
16065: PUSH
16066: FOR_TO
16067: IFFALSE 16075
// Sold ;
16069: CALL 16134 0 0
16073: GO 16066
16075: POP
16076: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
16077: LD_ADDR_VAR 0 3
16081: PUSH
16082: DOUBLE
16083: LD_INT 1
16085: DEC
16086: ST_TO_ADDR
16087: LD_INT 11
16089: PUSH
16090: LD_INT 13
16092: PUSH
16093: LD_INT 15
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: LIST
16100: PUSH
16101: LD_OWVAR 67
16105: ARRAY
16106: PUSH
16107: FOR_TO
16108: IFFALSE 16116
// Tank ;
16110: CALL 16264 0 0
16114: GO 16107
16116: POP
16117: POP
// end ; end ;
16118: GO 16121
16120: POP
// ru_can_attack := true ;
16121: LD_ADDR_EXP 8
16125: PUSH
16126: LD_INT 1
16128: ST_TO_ADDR
// end ;
16129: LD_VAR 0 2
16133: RET
// function Sold ( ) ; var un , skill ; begin
16134: LD_INT 0
16136: PPUSH
16137: PPUSH
16138: PPUSH
// uc_side := 3 ;
16139: LD_ADDR_OWVAR 20
16143: PUSH
16144: LD_INT 3
16146: ST_TO_ADDR
// uc_nation := 3 ;
16147: LD_ADDR_OWVAR 21
16151: PUSH
16152: LD_INT 3
16154: ST_TO_ADDR
// InitHc ;
16155: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16159: LD_ADDR_VAR 0 3
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 6
16169: PUSH
16170: LD_INT 7
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: PUSH
16178: LD_OWVAR 67
16182: ARRAY
16183: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
16184: LD_INT 0
16186: PPUSH
16187: LD_INT 1
16189: PUSH
16190: LD_INT 9
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: LD_INT 1
16199: PPUSH
16200: LD_INT 2
16202: PPUSH
16203: CALL_OW 12
16207: ARRAY
16208: PPUSH
16209: LD_VAR 0 3
16213: PPUSH
16214: CALL_OW 380
// un := CreateHuman ;
16218: LD_ADDR_VAR 0 2
16222: PUSH
16223: CALL_OW 44
16227: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: LD_INT 4
16235: PPUSH
16236: LD_INT 0
16238: PPUSH
16239: CALL_OW 49
// ru_force := ru_force ^ un ;
16243: LD_ADDR_EXP 38
16247: PUSH
16248: LD_EXP 38
16252: PUSH
16253: LD_VAR 0 2
16257: ADD
16258: ST_TO_ADDR
// end ;
16259: LD_VAR 0 1
16263: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16264: LD_INT 0
16266: PPUSH
16267: PPUSH
16268: PPUSH
16269: PPUSH
16270: PPUSH
// uc_side := 3 ;
16271: LD_ADDR_OWVAR 20
16275: PUSH
16276: LD_INT 3
16278: ST_TO_ADDR
// uc_nation := 3 ;
16279: LD_ADDR_OWVAR 21
16283: PUSH
16284: LD_INT 3
16286: ST_TO_ADDR
// InitHc ;
16287: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16291: LD_ADDR_VAR 0 5
16295: PUSH
16296: LD_INT 5
16298: PUSH
16299: LD_INT 6
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: LIST
16309: PUSH
16310: LD_OWVAR 67
16314: ARRAY
16315: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16316: LD_ADDR_VAR 0 3
16320: PUSH
16321: LD_INT 22
16323: PUSH
16324: LD_INT 24
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: LD_INT 1
16333: PPUSH
16334: LD_INT 2
16336: PPUSH
16337: CALL_OW 12
16341: ARRAY
16342: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16343: LD_VAR 0 3
16347: PUSH
16348: LD_INT 22
16350: EQUAL
16351: IFFALSE 16386
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16353: LD_ADDR_VAR 0 4
16357: PUSH
16358: LD_INT 45
16360: PUSH
16361: LD_INT 43
16363: PUSH
16364: LD_INT 44
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 1
16374: PPUSH
16375: LD_INT 3
16377: PPUSH
16378: CALL_OW 12
16382: ARRAY
16383: ST_TO_ADDR
16384: GO 16417
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16386: LD_ADDR_VAR 0 4
16390: PUSH
16391: LD_INT 46
16393: PUSH
16394: LD_INT 44
16396: PUSH
16397: LD_INT 45
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 3
16410: PPUSH
16411: CALL_OW 12
16415: ARRAY
16416: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 3
16427: PPUSH
16428: LD_VAR 0 3
16432: PPUSH
16433: LD_INT 1
16435: PPUSH
16436: LD_INT 3
16438: PUSH
16439: LD_INT 3
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: LD_INT 1
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_INT 4
16459: PPUSH
16460: CALL_OW 12
16464: ARRAY
16465: PPUSH
16466: LD_VAR 0 4
16470: PPUSH
16471: LD_INT 99
16473: PPUSH
16474: CALL 423 0 7
16478: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 263
16488: PUSH
16489: LD_INT 1
16491: EQUAL
16492: IFFALSE 16523
// begin PrepareHuman ( false , 3 , skill ) ;
16494: LD_INT 0
16496: PPUSH
16497: LD_INT 3
16499: PPUSH
16500: LD_VAR 0 5
16504: PPUSH
16505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16509: CALL_OW 44
16513: PPUSH
16514: LD_VAR 0 2
16518: PPUSH
16519: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16523: LD_VAR 0 2
16527: PPUSH
16528: LD_INT 3
16530: PPUSH
16531: LD_INT 0
16533: PPUSH
16534: CALL_OW 49
// ru_force := ru_force ^ un ;
16538: LD_ADDR_EXP 38
16542: PUSH
16543: LD_EXP 38
16547: PUSH
16548: LD_VAR 0 2
16552: ADD
16553: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16554: LD_VAR 0 2
16558: PPUSH
16559: LD_INT 126
16561: PPUSH
16562: LD_INT 158
16564: PPUSH
16565: CALL_OW 111
// Wait ( 0 0$3 ) ;
16569: LD_INT 105
16571: PPUSH
16572: CALL_OW 67
// ComStop ( un ) ;
16576: LD_VAR 0 2
16580: PPUSH
16581: CALL_OW 141
// end ;
16585: LD_VAR 0 1
16589: RET
// every 0 0$1 do var i , time , wave ;
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16598: LD_ADDR_VAR 0 2
16602: PUSH
16603: LD_INT 25200
16605: PUSH
16606: LD_INT 24150
16608: PUSH
16609: LD_INT 23100
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: LD_OWVAR 67
16621: ARRAY
16622: ST_TO_ADDR
// wait ( time ) ;
16623: LD_VAR 0 2
16627: PPUSH
16628: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16632: LD_ADDR_VAR 0 2
16636: PUSH
16637: LD_INT 15750
16639: PUSH
16640: LD_INT 15400
16642: PUSH
16643: LD_INT 15050
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: LIST
16650: PUSH
16651: LD_OWVAR 67
16655: ARRAY
16656: ST_TO_ADDR
// wave := 0 ;
16657: LD_ADDR_VAR 0 3
16661: PUSH
16662: LD_INT 0
16664: ST_TO_ADDR
// while true do
16665: LD_INT 1
16667: IFFALSE 16771
// begin wave := wave + 1 ;
16669: LD_ADDR_VAR 0 3
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_INT 1
16681: PLUS
16682: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16683: LD_INT 22
16685: PUSH
16686: LD_INT 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: IFFALSE 16733
// begin repeat wait ( 0 0$1 ) ;
16699: LD_INT 35
16701: PPUSH
16702: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16706: LD_INT 22
16708: PUSH
16709: LD_INT 2
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: PPUSH
16716: CALL_OW 69
16720: PUSH
16721: LD_INT 0
16723: EQUAL
16724: IFFALSE 16699
// wait ( 1 1$30 ) ;
16726: LD_INT 3150
16728: PPUSH
16729: CALL_OW 67
// end ; if ru_force < 20 then
16733: LD_EXP 38
16737: PUSH
16738: LD_INT 20
16740: LESS
16741: IFFALSE 16752
// PrepareAttack ( wave ) ;
16743: LD_VAR 0 3
16747: PPUSH
16748: CALL 15589 0 1
// ru_can_attack := true ;
16752: LD_ADDR_EXP 8
16756: PUSH
16757: LD_INT 1
16759: ST_TO_ADDR
// wait ( time ) ;
16760: LD_VAR 0 2
16764: PPUSH
16765: CALL_OW 67
// end ;
16769: GO 16665
// end ;
16771: PPOPN 3
16773: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16774: LD_EXP 8
16778: PUSH
16779: LD_EXP 38
16783: AND
16784: IFFALSE 17618
16786: GO 16788
16788: DISABLE
16789: LD_INT 0
16791: PPUSH
16792: PPUSH
16793: PPUSH
16794: PPUSH
16795: PPUSH
16796: PPUSH
16797: PPUSH
16798: PPUSH
16799: PPUSH
// begin enable ;
16800: ENABLE
// points1 := [ 107 , 123 ] ;
16801: LD_ADDR_VAR 0 4
16805: PUSH
16806: LD_INT 107
16808: PUSH
16809: LD_INT 123
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: LD_INT 55
16823: PUSH
16824: LD_INT 42
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16831: LD_ADDR_VAR 0 6
16835: PUSH
16836: LD_INT 102
16838: PUSH
16839: LD_INT 140
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PUSH
16846: LD_INT 105
16848: PUSH
16849: LD_INT 142
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 129
16858: PUSH
16859: LD_INT 131
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: ST_TO_ADDR
// for i in ru_force do
16871: LD_ADDR_VAR 0 1
16875: PUSH
16876: LD_EXP 38
16880: PUSH
16881: FOR_IN
16882: IFFALSE 17616
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16884: LD_ADDR_VAR 0 3
16888: PUSH
16889: LD_INT 81
16891: PUSH
16892: LD_INT 3
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: PPUSH
16899: CALL_OW 69
16903: PPUSH
16904: LD_VAR 0 1
16908: PPUSH
16909: CALL_OW 74
16913: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16914: LD_VAR 0 1
16918: PPUSH
16919: LD_VAR 0 3
16923: PPUSH
16924: CALL_OW 296
16928: PUSH
16929: LD_INT 12
16931: LESS
16932: IFFALSE 17077
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16934: LD_VAR 0 1
16938: PPUSH
16939: CALL_OW 247
16943: PUSH
16944: LD_INT 1
16946: EQUAL
16947: PUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 257
16957: PUSH
16958: LD_INT 1
16960: EQUAL
16961: AND
16962: PUSH
16963: LD_VAR 0 3
16967: PUSH
16968: LD_INT 21
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 58
16980: PUSH
16981: EMPTY
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PPUSH
16988: CALL_OW 69
16992: IN
16993: AND
16994: IFFALSE 17012
// ComEnterUnit ( i , un ) else
16996: LD_VAR 0 1
17000: PPUSH
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 120
17010: GO 17075
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
17012: LD_VAR 0 3
17016: PUSH
17017: LD_INT 21
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 58
17029: PUSH
17030: EMPTY
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: PPUSH
17037: CALL_OW 69
17041: IN
17042: NOT
17043: IFFALSE 17061
// ComAttackUnit ( i , un ) else
17045: LD_VAR 0 1
17049: PPUSH
17050: LD_VAR 0 3
17054: PPUSH
17055: CALL_OW 115
17059: GO 17075
// ComAttackUnit ( i , JMM ) ;
17061: LD_VAR 0 1
17065: PPUSH
17066: LD_EXP 21
17070: PPUSH
17071: CALL_OW 115
// end else
17075: GO 17614
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
17077: LD_VAR 0 1
17081: PPUSH
17082: LD_VAR 0 4
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_VAR 0 4
17095: PUSH
17096: LD_INT 2
17098: ARRAY
17099: PPUSH
17100: CALL_OW 297
17104: PUSH
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 5
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 2
17126: ARRAY
17127: PPUSH
17128: CALL_OW 297
17132: GREATER
17133: PUSH
17134: LD_EXP 9
17138: AND
17139: PUSH
17140: LD_INT 9
17142: PPUSH
17143: LD_INT 81
17145: PUSH
17146: LD_INT 3
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PPUSH
17153: CALL_OW 70
17157: PUSH
17158: LD_INT 0
17160: EQUAL
17161: OR
17162: IFFALSE 17200
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
17164: LD_VAR 0 1
17168: PPUSH
17169: LD_INT 81
17171: PUSH
17172: LD_INT 3
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PPUSH
17179: CALL_OW 69
17183: PPUSH
17184: LD_VAR 0 1
17188: PPUSH
17189: CALL_OW 74
17193: PPUSH
17194: CALL_OW 115
17198: GO 17614
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 264
17209: PUSH
17210: LD_INT 45
17212: EQUAL
17213: PUSH
17214: LD_EXP 38
17218: PPUSH
17219: LD_INT 3
17221: PUSH
17222: LD_INT 34
17224: PUSH
17225: LD_INT 45
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PPUSH
17236: CALL_OW 72
17240: PUSH
17241: LD_INT 6
17243: GREATER
17244: AND
17245: IFFALSE 17426
// begin dist := 9999 ;
17247: LD_ADDR_VAR 0 8
17251: PUSH
17252: LD_INT 9999
17254: ST_TO_ADDR
// xy := 0 ;
17255: LD_ADDR_VAR 0 9
17259: PUSH
17260: LD_INT 0
17262: ST_TO_ADDR
// for x in pointsr do
17263: LD_ADDR_VAR 0 7
17267: PUSH
17268: LD_VAR 0 6
17272: PUSH
17273: FOR_IN
17274: IFFALSE 17422
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17276: LD_VAR 0 1
17280: PPUSH
17281: LD_VAR 0 7
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: LD_VAR 0 7
17294: PUSH
17295: LD_INT 2
17297: ARRAY
17298: PPUSH
17299: CALL_OW 297
17303: PUSH
17304: LD_VAR 0 8
17308: LESS
17309: IFFALSE 17354
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17311: LD_ADDR_VAR 0 8
17315: PUSH
17316: LD_VAR 0 1
17320: PPUSH
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: LD_VAR 0 7
17334: PUSH
17335: LD_INT 2
17337: ARRAY
17338: PPUSH
17339: CALL_OW 297
17343: ST_TO_ADDR
// xy := x ;
17344: LD_ADDR_VAR 0 9
17348: PUSH
17349: LD_VAR 0 7
17353: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17354: LD_VAR 0 9
17358: PUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: LD_VAR 0 9
17368: PUSH
17369: LD_INT 1
17371: ARRAY
17372: PPUSH
17373: LD_VAR 0 9
17377: PUSH
17378: LD_INT 2
17380: ARRAY
17381: PPUSH
17382: CALL_OW 297
17386: PUSH
17387: LD_INT 9
17389: GREATER
17390: AND
17391: IFFALSE 17420
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17393: LD_VAR 0 1
17397: PPUSH
17398: LD_VAR 0 9
17402: PUSH
17403: LD_INT 1
17405: ARRAY
17406: PPUSH
17407: LD_VAR 0 9
17411: PUSH
17412: LD_INT 2
17414: ARRAY
17415: PPUSH
17416: CALL_OW 114
// end ;
17420: GO 17273
17422: POP
17423: POP
// end else
17424: GO 17614
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_OWVAR 3
17435: PUSH
17436: LD_VAR 0 1
17440: DIFF
17441: PPUSH
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 74
17451: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 320
17461: NOT
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_INT 21
17470: PUSH
17471: LD_INT 2
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PUSH
17478: LD_INT 33
17480: PUSH
17481: LD_INT 1
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: LD_INT 58
17490: PUSH
17491: EMPTY
17492: LIST
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: PPUSH
17499: CALL_OW 69
17503: IN
17504: PUSH
17505: LD_VAR 0 3
17509: PUSH
17510: LD_INT 22
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: EMPTY
17517: LIST
17518: LIST
17519: PUSH
17520: LD_INT 21
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: PUSH
17530: LD_INT 3
17532: PUSH
17533: LD_INT 24
17535: PUSH
17536: LD_INT 249
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 69
17556: IN
17557: OR
17558: AND
17559: IFFALSE 17577
// ComAttackUnit ( i , un ) else
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_VAR 0 3
17570: PPUSH
17571: CALL_OW 115
17575: GO 17614
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17577: LD_VAR 0 1
17581: PPUSH
17582: LD_INT 9
17584: PPUSH
17585: LD_INT 81
17587: PUSH
17588: LD_INT 3
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 70
17599: PPUSH
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL_OW 74
17609: PPUSH
17610: CALL_OW 115
// end ; end ; end ; end ;
17614: GO 16881
17616: POP
17617: POP
// end ;
17618: PPOPN 9
17620: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17621: LD_INT 22
17623: PUSH
17624: LD_INT 3
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 32
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: IFFALSE 17737
17651: GO 17653
17653: DISABLE
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// begin enable ;
17658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17659: LD_ADDR_VAR 0 2
17663: PUSH
17664: LD_INT 22
17666: PUSH
17667: LD_INT 3
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: LD_INT 32
17676: PUSH
17677: LD_INT 1
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PPUSH
17688: CALL_OW 69
17692: ST_TO_ADDR
// for i in tmp do
17693: LD_ADDR_VAR 0 1
17697: PUSH
17698: LD_VAR 0 2
17702: PUSH
17703: FOR_IN
17704: IFFALSE 17735
// if GetFuel ( i ) < 12 then
17706: LD_VAR 0 1
17710: PPUSH
17711: CALL_OW 261
17715: PUSH
17716: LD_INT 12
17718: LESS
17719: IFFALSE 17733
// SetFuel ( i , 12 ) ;
17721: LD_VAR 0 1
17725: PPUSH
17726: LD_INT 12
17728: PPUSH
17729: CALL_OW 240
17733: GO 17703
17735: POP
17736: POP
// end ;
17737: PPOPN 2
17739: END
// every 0 0$1 trigger can_end do
17740: LD_EXP 17
17744: IFFALSE 17767
17746: GO 17748
17748: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17749: LD_INT 3325
17751: PPUSH
17752: CALL_OW 67
// PrepareAttack ( 10 ) ;
17756: LD_INT 10
17758: PPUSH
17759: CALL 15589 0 1
// until false ;
17763: LD_INT 0
17765: IFFALSE 17749
// end ; end_of_file
17767: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17768: GO 17770
17770: DISABLE
// begin ru_radar := 98 ;
17771: LD_ADDR_EXP 41
17775: PUSH
17776: LD_INT 98
17778: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17779: LD_ADDR_EXP 42
17783: PUSH
17784: LD_INT 89
17786: ST_TO_ADDR
// us_hack := 99 ;
17787: LD_ADDR_EXP 43
17791: PUSH
17792: LD_INT 99
17794: ST_TO_ADDR
// us_artillery := 97 ;
17795: LD_ADDR_EXP 44
17799: PUSH
17800: LD_INT 97
17802: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17803: LD_ADDR_EXP 45
17807: PUSH
17808: LD_INT 91
17810: ST_TO_ADDR
// end ; end_of_file end_of_file
17811: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
17812: GO 17814
17814: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
17815: LD_STRING initStreamRollete();
17817: PPUSH
17818: CALL_OW 559
// InitStreamMode ;
17822: CALL 17831 0 0
// DefineStreamItems ( ) ;
17826: CALL 18271 0 0
// end ;
17830: END
// function InitStreamMode ; begin
17831: LD_INT 0
17833: PPUSH
// streamModeActive := false ;
17834: LD_ADDR_EXP 46
17838: PUSH
17839: LD_INT 0
17841: ST_TO_ADDR
// normalCounter := 26 ;
17842: LD_ADDR_EXP 47
17846: PUSH
17847: LD_INT 26
17849: ST_TO_ADDR
// hardcoreCounter := 12 ;
17850: LD_ADDR_EXP 48
17854: PUSH
17855: LD_INT 12
17857: ST_TO_ADDR
// sRocket := false ;
17858: LD_ADDR_EXP 51
17862: PUSH
17863: LD_INT 0
17865: ST_TO_ADDR
// sSpeed := false ;
17866: LD_ADDR_EXP 50
17870: PUSH
17871: LD_INT 0
17873: ST_TO_ADDR
// sEngine := false ;
17874: LD_ADDR_EXP 52
17878: PUSH
17879: LD_INT 0
17881: ST_TO_ADDR
// sSpec := false ;
17882: LD_ADDR_EXP 49
17886: PUSH
17887: LD_INT 0
17889: ST_TO_ADDR
// sLevel := false ;
17890: LD_ADDR_EXP 53
17894: PUSH
17895: LD_INT 0
17897: ST_TO_ADDR
// sArmoury := false ;
17898: LD_ADDR_EXP 54
17902: PUSH
17903: LD_INT 0
17905: ST_TO_ADDR
// sRadar := false ;
17906: LD_ADDR_EXP 55
17910: PUSH
17911: LD_INT 0
17913: ST_TO_ADDR
// sBunker := false ;
17914: LD_ADDR_EXP 56
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// sHack := false ;
17922: LD_ADDR_EXP 57
17926: PUSH
17927: LD_INT 0
17929: ST_TO_ADDR
// sFire := false ;
17930: LD_ADDR_EXP 58
17934: PUSH
17935: LD_INT 0
17937: ST_TO_ADDR
// sRefresh := false ;
17938: LD_ADDR_EXP 59
17942: PUSH
17943: LD_INT 0
17945: ST_TO_ADDR
// sExp := false ;
17946: LD_ADDR_EXP 60
17950: PUSH
17951: LD_INT 0
17953: ST_TO_ADDR
// sDepot := false ;
17954: LD_ADDR_EXP 61
17958: PUSH
17959: LD_INT 0
17961: ST_TO_ADDR
// sFlag := false ;
17962: LD_ADDR_EXP 62
17966: PUSH
17967: LD_INT 0
17969: ST_TO_ADDR
// sKamikadze := false ;
17970: LD_ADDR_EXP 70
17974: PUSH
17975: LD_INT 0
17977: ST_TO_ADDR
// sTroll := false ;
17978: LD_ADDR_EXP 71
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// sSlow := false ;
17986: LD_ADDR_EXP 72
17990: PUSH
17991: LD_INT 0
17993: ST_TO_ADDR
// sLack := false ;
17994: LD_ADDR_EXP 73
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// sTank := false ;
18002: LD_ADDR_EXP 75
18006: PUSH
18007: LD_INT 0
18009: ST_TO_ADDR
// sRemote := false ;
18010: LD_ADDR_EXP 76
18014: PUSH
18015: LD_INT 0
18017: ST_TO_ADDR
// sPowell := false ;
18018: LD_ADDR_EXP 77
18022: PUSH
18023: LD_INT 0
18025: ST_TO_ADDR
// sTeleport := false ;
18026: LD_ADDR_EXP 80
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// sOilTower := false ;
18034: LD_ADDR_EXP 82
18038: PUSH
18039: LD_INT 0
18041: ST_TO_ADDR
// sShovel := false ;
18042: LD_ADDR_EXP 83
18046: PUSH
18047: LD_INT 0
18049: ST_TO_ADDR
// sSheik := false ;
18050: LD_ADDR_EXP 84
18054: PUSH
18055: LD_INT 0
18057: ST_TO_ADDR
// sEarthquake := false ;
18058: LD_ADDR_EXP 86
18062: PUSH
18063: LD_INT 0
18065: ST_TO_ADDR
// sAI := false ;
18066: LD_ADDR_EXP 87
18070: PUSH
18071: LD_INT 0
18073: ST_TO_ADDR
// sCargo := false ;
18074: LD_ADDR_EXP 90
18078: PUSH
18079: LD_INT 0
18081: ST_TO_ADDR
// sDLaser := false ;
18082: LD_ADDR_EXP 91
18086: PUSH
18087: LD_INT 0
18089: ST_TO_ADDR
// sExchange := false ;
18090: LD_ADDR_EXP 92
18094: PUSH
18095: LD_INT 0
18097: ST_TO_ADDR
// sFac := false ;
18098: LD_ADDR_EXP 93
18102: PUSH
18103: LD_INT 0
18105: ST_TO_ADDR
// sPower := false ;
18106: LD_ADDR_EXP 94
18110: PUSH
18111: LD_INT 0
18113: ST_TO_ADDR
// sRandom := false ;
18114: LD_ADDR_EXP 95
18118: PUSH
18119: LD_INT 0
18121: ST_TO_ADDR
// sShield := false ;
18122: LD_ADDR_EXP 96
18126: PUSH
18127: LD_INT 0
18129: ST_TO_ADDR
// sTime := false ;
18130: LD_ADDR_EXP 97
18134: PUSH
18135: LD_INT 0
18137: ST_TO_ADDR
// sTools := false ;
18138: LD_ADDR_EXP 98
18142: PUSH
18143: LD_INT 0
18145: ST_TO_ADDR
// sSold := false ;
18146: LD_ADDR_EXP 63
18150: PUSH
18151: LD_INT 0
18153: ST_TO_ADDR
// sDiff := false ;
18154: LD_ADDR_EXP 64
18158: PUSH
18159: LD_INT 0
18161: ST_TO_ADDR
// sFog := false ;
18162: LD_ADDR_EXP 67
18166: PUSH
18167: LD_INT 0
18169: ST_TO_ADDR
// sReset := false ;
18170: LD_ADDR_EXP 68
18174: PUSH
18175: LD_INT 0
18177: ST_TO_ADDR
// sSun := false ;
18178: LD_ADDR_EXP 69
18182: PUSH
18183: LD_INT 0
18185: ST_TO_ADDR
// sTiger := false ;
18186: LD_ADDR_EXP 65
18190: PUSH
18191: LD_INT 0
18193: ST_TO_ADDR
// sBomb := false ;
18194: LD_ADDR_EXP 66
18198: PUSH
18199: LD_INT 0
18201: ST_TO_ADDR
// sWound := false ;
18202: LD_ADDR_EXP 74
18206: PUSH
18207: LD_INT 0
18209: ST_TO_ADDR
// sBetray := false ;
18210: LD_ADDR_EXP 78
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// sContamin := false ;
18218: LD_ADDR_EXP 79
18222: PUSH
18223: LD_INT 0
18225: ST_TO_ADDR
// sOil := false ;
18226: LD_ADDR_EXP 81
18230: PUSH
18231: LD_INT 0
18233: ST_TO_ADDR
// sStu := false ;
18234: LD_ADDR_EXP 85
18238: PUSH
18239: LD_INT 0
18241: ST_TO_ADDR
// sBazooka := false ;
18242: LD_ADDR_EXP 88
18246: PUSH
18247: LD_INT 0
18249: ST_TO_ADDR
// sMortar := false ;
18250: LD_ADDR_EXP 89
18254: PUSH
18255: LD_INT 0
18257: ST_TO_ADDR
// sRanger := false ;
18258: LD_ADDR_EXP 99
18262: PUSH
18263: LD_INT 0
18265: ST_TO_ADDR
// end ;
18266: LD_VAR 0 1
18270: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
18271: LD_INT 0
18273: PPUSH
18274: PPUSH
18275: PPUSH
18276: PPUSH
18277: PPUSH
// result := [ ] ;
18278: LD_ADDR_VAR 0 1
18282: PUSH
18283: EMPTY
18284: ST_TO_ADDR
// if campaign_id = 1 then
18285: LD_OWVAR 69
18289: PUSH
18290: LD_INT 1
18292: EQUAL
18293: IFFALSE 21229
// begin case mission_number of 1 :
18295: LD_OWVAR 70
18299: PUSH
18300: LD_INT 1
18302: DOUBLE
18303: EQUAL
18304: IFTRUE 18308
18306: GO 18372
18308: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
18309: LD_ADDR_VAR 0 1
18313: PUSH
18314: LD_INT 2
18316: PUSH
18317: LD_INT 4
18319: PUSH
18320: LD_INT 11
18322: PUSH
18323: LD_INT 12
18325: PUSH
18326: LD_INT 15
18328: PUSH
18329: LD_INT 16
18331: PUSH
18332: LD_INT 22
18334: PUSH
18335: LD_INT 23
18337: PUSH
18338: LD_INT 26
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: LIST
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 101
18354: PUSH
18355: LD_INT 102
18357: PUSH
18358: LD_INT 106
18360: PUSH
18361: EMPTY
18362: LIST
18363: LIST
18364: LIST
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: ST_TO_ADDR
18370: GO 21229
18372: LD_INT 2
18374: DOUBLE
18375: EQUAL
18376: IFTRUE 18380
18378: GO 18452
18380: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
18381: LD_ADDR_VAR 0 1
18385: PUSH
18386: LD_INT 2
18388: PUSH
18389: LD_INT 4
18391: PUSH
18392: LD_INT 11
18394: PUSH
18395: LD_INT 12
18397: PUSH
18398: LD_INT 15
18400: PUSH
18401: LD_INT 16
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 23
18409: PUSH
18410: LD_INT 26
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: LD_INT 101
18426: PUSH
18427: LD_INT 102
18429: PUSH
18430: LD_INT 105
18432: PUSH
18433: LD_INT 106
18435: PUSH
18436: LD_INT 108
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: ST_TO_ADDR
18450: GO 21229
18452: LD_INT 3
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18536
18460: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
18461: LD_ADDR_VAR 0 1
18465: PUSH
18466: LD_INT 2
18468: PUSH
18469: LD_INT 4
18471: PUSH
18472: LD_INT 5
18474: PUSH
18475: LD_INT 11
18477: PUSH
18478: LD_INT 12
18480: PUSH
18481: LD_INT 15
18483: PUSH
18484: LD_INT 16
18486: PUSH
18487: LD_INT 22
18489: PUSH
18490: LD_INT 26
18492: PUSH
18493: LD_INT 36
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: PUSH
18508: LD_INT 101
18510: PUSH
18511: LD_INT 102
18513: PUSH
18514: LD_INT 105
18516: PUSH
18517: LD_INT 106
18519: PUSH
18520: LD_INT 108
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: ST_TO_ADDR
18534: GO 21229
18536: LD_INT 4
18538: DOUBLE
18539: EQUAL
18540: IFTRUE 18544
18542: GO 18628
18544: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
18545: LD_ADDR_VAR 0 1
18549: PUSH
18550: LD_INT 2
18552: PUSH
18553: LD_INT 4
18555: PUSH
18556: LD_INT 5
18558: PUSH
18559: LD_INT 8
18561: PUSH
18562: LD_INT 11
18564: PUSH
18565: LD_INT 12
18567: PUSH
18568: LD_INT 15
18570: PUSH
18571: LD_INT 16
18573: PUSH
18574: LD_INT 22
18576: PUSH
18577: LD_INT 23
18579: PUSH
18580: LD_INT 26
18582: PUSH
18583: LD_INT 36
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: PUSH
18600: LD_INT 101
18602: PUSH
18603: LD_INT 102
18605: PUSH
18606: LD_INT 105
18608: PUSH
18609: LD_INT 106
18611: PUSH
18612: LD_INT 108
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: ST_TO_ADDR
18626: GO 21229
18628: LD_INT 5
18630: DOUBLE
18631: EQUAL
18632: IFTRUE 18636
18634: GO 18736
18636: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
18637: LD_ADDR_VAR 0 1
18641: PUSH
18642: LD_INT 2
18644: PUSH
18645: LD_INT 4
18647: PUSH
18648: LD_INT 5
18650: PUSH
18651: LD_INT 6
18653: PUSH
18654: LD_INT 8
18656: PUSH
18657: LD_INT 11
18659: PUSH
18660: LD_INT 12
18662: PUSH
18663: LD_INT 15
18665: PUSH
18666: LD_INT 16
18668: PUSH
18669: LD_INT 22
18671: PUSH
18672: LD_INT 23
18674: PUSH
18675: LD_INT 25
18677: PUSH
18678: LD_INT 26
18680: PUSH
18681: LD_INT 36
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: PUSH
18700: LD_INT 101
18702: PUSH
18703: LD_INT 102
18705: PUSH
18706: LD_INT 105
18708: PUSH
18709: LD_INT 106
18711: PUSH
18712: LD_INT 108
18714: PUSH
18715: LD_INT 109
18717: PUSH
18718: LD_INT 112
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: PUSH
18730: EMPTY
18731: LIST
18732: LIST
18733: ST_TO_ADDR
18734: GO 21229
18736: LD_INT 6
18738: DOUBLE
18739: EQUAL
18740: IFTRUE 18744
18742: GO 18864
18744: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
18745: LD_ADDR_VAR 0 1
18749: PUSH
18750: LD_INT 2
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: LD_INT 5
18758: PUSH
18759: LD_INT 6
18761: PUSH
18762: LD_INT 8
18764: PUSH
18765: LD_INT 11
18767: PUSH
18768: LD_INT 12
18770: PUSH
18771: LD_INT 15
18773: PUSH
18774: LD_INT 16
18776: PUSH
18777: LD_INT 20
18779: PUSH
18780: LD_INT 21
18782: PUSH
18783: LD_INT 22
18785: PUSH
18786: LD_INT 23
18788: PUSH
18789: LD_INT 25
18791: PUSH
18792: LD_INT 26
18794: PUSH
18795: LD_INT 30
18797: PUSH
18798: LD_INT 31
18800: PUSH
18801: LD_INT 32
18803: PUSH
18804: LD_INT 36
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: PUSH
18828: LD_INT 101
18830: PUSH
18831: LD_INT 102
18833: PUSH
18834: LD_INT 105
18836: PUSH
18837: LD_INT 106
18839: PUSH
18840: LD_INT 108
18842: PUSH
18843: LD_INT 109
18845: PUSH
18846: LD_INT 112
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: PUSH
18858: EMPTY
18859: LIST
18860: LIST
18861: ST_TO_ADDR
18862: GO 21229
18864: LD_INT 7
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18972
18872: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
18873: LD_ADDR_VAR 0 1
18877: PUSH
18878: LD_INT 2
18880: PUSH
18881: LD_INT 4
18883: PUSH
18884: LD_INT 5
18886: PUSH
18887: LD_INT 7
18889: PUSH
18890: LD_INT 11
18892: PUSH
18893: LD_INT 12
18895: PUSH
18896: LD_INT 15
18898: PUSH
18899: LD_INT 16
18901: PUSH
18902: LD_INT 20
18904: PUSH
18905: LD_INT 21
18907: PUSH
18908: LD_INT 22
18910: PUSH
18911: LD_INT 23
18913: PUSH
18914: LD_INT 25
18916: PUSH
18917: LD_INT 26
18919: PUSH
18920: EMPTY
18921: LIST
18922: LIST
18923: LIST
18924: LIST
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: PUSH
18936: LD_INT 101
18938: PUSH
18939: LD_INT 102
18941: PUSH
18942: LD_INT 103
18944: PUSH
18945: LD_INT 105
18947: PUSH
18948: LD_INT 106
18950: PUSH
18951: LD_INT 108
18953: PUSH
18954: LD_INT 112
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: PUSH
18966: EMPTY
18967: LIST
18968: LIST
18969: ST_TO_ADDR
18970: GO 21229
18972: LD_INT 8
18974: DOUBLE
18975: EQUAL
18976: IFTRUE 18980
18978: GO 19108
18980: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
18981: LD_ADDR_VAR 0 1
18985: PUSH
18986: LD_INT 2
18988: PUSH
18989: LD_INT 4
18991: PUSH
18992: LD_INT 5
18994: PUSH
18995: LD_INT 6
18997: PUSH
18998: LD_INT 7
19000: PUSH
19001: LD_INT 8
19003: PUSH
19004: LD_INT 11
19006: PUSH
19007: LD_INT 12
19009: PUSH
19010: LD_INT 15
19012: PUSH
19013: LD_INT 16
19015: PUSH
19016: LD_INT 20
19018: PUSH
19019: LD_INT 21
19021: PUSH
19022: LD_INT 22
19024: PUSH
19025: LD_INT 23
19027: PUSH
19028: LD_INT 25
19030: PUSH
19031: LD_INT 26
19033: PUSH
19034: LD_INT 30
19036: PUSH
19037: LD_INT 31
19039: PUSH
19040: LD_INT 32
19042: PUSH
19043: LD_INT 36
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: LIST
19050: LIST
19051: LIST
19052: LIST
19053: LIST
19054: LIST
19055: LIST
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: LIST
19066: LIST
19067: PUSH
19068: LD_INT 101
19070: PUSH
19071: LD_INT 102
19073: PUSH
19074: LD_INT 103
19076: PUSH
19077: LD_INT 105
19079: PUSH
19080: LD_INT 106
19082: PUSH
19083: LD_INT 108
19085: PUSH
19086: LD_INT 109
19088: PUSH
19089: LD_INT 112
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: ST_TO_ADDR
19106: GO 21229
19108: LD_INT 9
19110: DOUBLE
19111: EQUAL
19112: IFTRUE 19116
19114: GO 19252
19116: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19117: LD_ADDR_VAR 0 1
19121: PUSH
19122: LD_INT 2
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: LD_INT 6
19133: PUSH
19134: LD_INT 7
19136: PUSH
19137: LD_INT 8
19139: PUSH
19140: LD_INT 11
19142: PUSH
19143: LD_INT 12
19145: PUSH
19146: LD_INT 15
19148: PUSH
19149: LD_INT 16
19151: PUSH
19152: LD_INT 20
19154: PUSH
19155: LD_INT 21
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_INT 23
19163: PUSH
19164: LD_INT 25
19166: PUSH
19167: LD_INT 26
19169: PUSH
19170: LD_INT 28
19172: PUSH
19173: LD_INT 30
19175: PUSH
19176: LD_INT 31
19178: PUSH
19179: LD_INT 32
19181: PUSH
19182: LD_INT 36
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: LIST
19195: LIST
19196: LIST
19197: LIST
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: LIST
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 101
19210: PUSH
19211: LD_INT 102
19213: PUSH
19214: LD_INT 103
19216: PUSH
19217: LD_INT 105
19219: PUSH
19220: LD_INT 106
19222: PUSH
19223: LD_INT 108
19225: PUSH
19226: LD_INT 109
19228: PUSH
19229: LD_INT 112
19231: PUSH
19232: LD_INT 114
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: LIST
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: LIST
19244: LIST
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: ST_TO_ADDR
19250: GO 21229
19252: LD_INT 10
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19444
19260: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
19261: LD_ADDR_VAR 0 1
19265: PUSH
19266: LD_INT 2
19268: PUSH
19269: LD_INT 4
19271: PUSH
19272: LD_INT 5
19274: PUSH
19275: LD_INT 6
19277: PUSH
19278: LD_INT 7
19280: PUSH
19281: LD_INT 8
19283: PUSH
19284: LD_INT 9
19286: PUSH
19287: LD_INT 10
19289: PUSH
19290: LD_INT 11
19292: PUSH
19293: LD_INT 12
19295: PUSH
19296: LD_INT 13
19298: PUSH
19299: LD_INT 14
19301: PUSH
19302: LD_INT 15
19304: PUSH
19305: LD_INT 16
19307: PUSH
19308: LD_INT 17
19310: PUSH
19311: LD_INT 18
19313: PUSH
19314: LD_INT 19
19316: PUSH
19317: LD_INT 20
19319: PUSH
19320: LD_INT 21
19322: PUSH
19323: LD_INT 22
19325: PUSH
19326: LD_INT 23
19328: PUSH
19329: LD_INT 24
19331: PUSH
19332: LD_INT 25
19334: PUSH
19335: LD_INT 26
19337: PUSH
19338: LD_INT 28
19340: PUSH
19341: LD_INT 30
19343: PUSH
19344: LD_INT 31
19346: PUSH
19347: LD_INT 32
19349: PUSH
19350: LD_INT 36
19352: PUSH
19353: EMPTY
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: LIST
19364: LIST
19365: LIST
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: LIST
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: PUSH
19384: LD_INT 101
19386: PUSH
19387: LD_INT 102
19389: PUSH
19390: LD_INT 103
19392: PUSH
19393: LD_INT 104
19395: PUSH
19396: LD_INT 105
19398: PUSH
19399: LD_INT 106
19401: PUSH
19402: LD_INT 107
19404: PUSH
19405: LD_INT 108
19407: PUSH
19408: LD_INT 109
19410: PUSH
19411: LD_INT 110
19413: PUSH
19414: LD_INT 111
19416: PUSH
19417: LD_INT 112
19419: PUSH
19420: LD_INT 114
19422: PUSH
19423: EMPTY
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: LIST
19437: PUSH
19438: EMPTY
19439: LIST
19440: LIST
19441: ST_TO_ADDR
19442: GO 21229
19444: LD_INT 11
19446: DOUBLE
19447: EQUAL
19448: IFTRUE 19452
19450: GO 19644
19452: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
19453: LD_ADDR_VAR 0 1
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: LD_INT 3
19463: PUSH
19464: LD_INT 4
19466: PUSH
19467: LD_INT 5
19469: PUSH
19470: LD_INT 6
19472: PUSH
19473: LD_INT 7
19475: PUSH
19476: LD_INT 8
19478: PUSH
19479: LD_INT 9
19481: PUSH
19482: LD_INT 10
19484: PUSH
19485: LD_INT 11
19487: PUSH
19488: LD_INT 12
19490: PUSH
19491: LD_INT 13
19493: PUSH
19494: LD_INT 14
19496: PUSH
19497: LD_INT 15
19499: PUSH
19500: LD_INT 16
19502: PUSH
19503: LD_INT 17
19505: PUSH
19506: LD_INT 18
19508: PUSH
19509: LD_INT 19
19511: PUSH
19512: LD_INT 20
19514: PUSH
19515: LD_INT 21
19517: PUSH
19518: LD_INT 22
19520: PUSH
19521: LD_INT 23
19523: PUSH
19524: LD_INT 24
19526: PUSH
19527: LD_INT 25
19529: PUSH
19530: LD_INT 26
19532: PUSH
19533: LD_INT 28
19535: PUSH
19536: LD_INT 30
19538: PUSH
19539: LD_INT 31
19541: PUSH
19542: LD_INT 32
19544: PUSH
19545: LD_INT 34
19547: PUSH
19548: LD_INT 36
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: LIST
19555: LIST
19556: LIST
19557: LIST
19558: LIST
19559: LIST
19560: LIST
19561: LIST
19562: LIST
19563: LIST
19564: LIST
19565: LIST
19566: LIST
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_INT 101
19586: PUSH
19587: LD_INT 102
19589: PUSH
19590: LD_INT 103
19592: PUSH
19593: LD_INT 104
19595: PUSH
19596: LD_INT 105
19598: PUSH
19599: LD_INT 106
19601: PUSH
19602: LD_INT 107
19604: PUSH
19605: LD_INT 108
19607: PUSH
19608: LD_INT 109
19610: PUSH
19611: LD_INT 110
19613: PUSH
19614: LD_INT 111
19616: PUSH
19617: LD_INT 112
19619: PUSH
19620: LD_INT 114
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: ST_TO_ADDR
19642: GO 21229
19644: LD_INT 12
19646: DOUBLE
19647: EQUAL
19648: IFTRUE 19652
19650: GO 19860
19652: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
19653: LD_ADDR_VAR 0 1
19657: PUSH
19658: LD_INT 1
19660: PUSH
19661: LD_INT 2
19663: PUSH
19664: LD_INT 3
19666: PUSH
19667: LD_INT 4
19669: PUSH
19670: LD_INT 5
19672: PUSH
19673: LD_INT 6
19675: PUSH
19676: LD_INT 7
19678: PUSH
19679: LD_INT 8
19681: PUSH
19682: LD_INT 9
19684: PUSH
19685: LD_INT 10
19687: PUSH
19688: LD_INT 11
19690: PUSH
19691: LD_INT 12
19693: PUSH
19694: LD_INT 13
19696: PUSH
19697: LD_INT 14
19699: PUSH
19700: LD_INT 15
19702: PUSH
19703: LD_INT 16
19705: PUSH
19706: LD_INT 17
19708: PUSH
19709: LD_INT 18
19711: PUSH
19712: LD_INT 19
19714: PUSH
19715: LD_INT 20
19717: PUSH
19718: LD_INT 21
19720: PUSH
19721: LD_INT 22
19723: PUSH
19724: LD_INT 23
19726: PUSH
19727: LD_INT 24
19729: PUSH
19730: LD_INT 25
19732: PUSH
19733: LD_INT 26
19735: PUSH
19736: LD_INT 27
19738: PUSH
19739: LD_INT 28
19741: PUSH
19742: LD_INT 30
19744: PUSH
19745: LD_INT 31
19747: PUSH
19748: LD_INT 32
19750: PUSH
19751: LD_INT 33
19753: PUSH
19754: LD_INT 34
19756: PUSH
19757: LD_INT 36
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: LIST
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: PUSH
19796: LD_INT 101
19798: PUSH
19799: LD_INT 102
19801: PUSH
19802: LD_INT 103
19804: PUSH
19805: LD_INT 104
19807: PUSH
19808: LD_INT 105
19810: PUSH
19811: LD_INT 106
19813: PUSH
19814: LD_INT 107
19816: PUSH
19817: LD_INT 108
19819: PUSH
19820: LD_INT 109
19822: PUSH
19823: LD_INT 110
19825: PUSH
19826: LD_INT 111
19828: PUSH
19829: LD_INT 112
19831: PUSH
19832: LD_INT 113
19834: PUSH
19835: LD_INT 114
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: ST_TO_ADDR
19858: GO 21229
19860: LD_INT 13
19862: DOUBLE
19863: EQUAL
19864: IFTRUE 19868
19866: GO 20064
19868: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
19869: LD_ADDR_VAR 0 1
19873: PUSH
19874: LD_INT 1
19876: PUSH
19877: LD_INT 2
19879: PUSH
19880: LD_INT 3
19882: PUSH
19883: LD_INT 4
19885: PUSH
19886: LD_INT 5
19888: PUSH
19889: LD_INT 8
19891: PUSH
19892: LD_INT 9
19894: PUSH
19895: LD_INT 10
19897: PUSH
19898: LD_INT 11
19900: PUSH
19901: LD_INT 12
19903: PUSH
19904: LD_INT 14
19906: PUSH
19907: LD_INT 15
19909: PUSH
19910: LD_INT 16
19912: PUSH
19913: LD_INT 17
19915: PUSH
19916: LD_INT 18
19918: PUSH
19919: LD_INT 19
19921: PUSH
19922: LD_INT 20
19924: PUSH
19925: LD_INT 21
19927: PUSH
19928: LD_INT 22
19930: PUSH
19931: LD_INT 23
19933: PUSH
19934: LD_INT 24
19936: PUSH
19937: LD_INT 25
19939: PUSH
19940: LD_INT 26
19942: PUSH
19943: LD_INT 27
19945: PUSH
19946: LD_INT 28
19948: PUSH
19949: LD_INT 30
19951: PUSH
19952: LD_INT 31
19954: PUSH
19955: LD_INT 32
19957: PUSH
19958: LD_INT 33
19960: PUSH
19961: LD_INT 34
19963: PUSH
19964: LD_INT 36
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: PUSH
20000: LD_INT 101
20002: PUSH
20003: LD_INT 102
20005: PUSH
20006: LD_INT 103
20008: PUSH
20009: LD_INT 104
20011: PUSH
20012: LD_INT 105
20014: PUSH
20015: LD_INT 106
20017: PUSH
20018: LD_INT 107
20020: PUSH
20021: LD_INT 108
20023: PUSH
20024: LD_INT 109
20026: PUSH
20027: LD_INT 110
20029: PUSH
20030: LD_INT 111
20032: PUSH
20033: LD_INT 112
20035: PUSH
20036: LD_INT 113
20038: PUSH
20039: LD_INT 114
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: LIST
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: LIST
20054: LIST
20055: LIST
20056: LIST
20057: PUSH
20058: EMPTY
20059: LIST
20060: LIST
20061: ST_TO_ADDR
20062: GO 21229
20064: LD_INT 14
20066: DOUBLE
20067: EQUAL
20068: IFTRUE 20072
20070: GO 20284
20072: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20073: LD_ADDR_VAR 0 1
20077: PUSH
20078: LD_INT 1
20080: PUSH
20081: LD_INT 2
20083: PUSH
20084: LD_INT 3
20086: PUSH
20087: LD_INT 4
20089: PUSH
20090: LD_INT 5
20092: PUSH
20093: LD_INT 6
20095: PUSH
20096: LD_INT 7
20098: PUSH
20099: LD_INT 8
20101: PUSH
20102: LD_INT 9
20104: PUSH
20105: LD_INT 10
20107: PUSH
20108: LD_INT 11
20110: PUSH
20111: LD_INT 12
20113: PUSH
20114: LD_INT 13
20116: PUSH
20117: LD_INT 14
20119: PUSH
20120: LD_INT 15
20122: PUSH
20123: LD_INT 16
20125: PUSH
20126: LD_INT 17
20128: PUSH
20129: LD_INT 18
20131: PUSH
20132: LD_INT 19
20134: PUSH
20135: LD_INT 20
20137: PUSH
20138: LD_INT 21
20140: PUSH
20141: LD_INT 22
20143: PUSH
20144: LD_INT 23
20146: PUSH
20147: LD_INT 24
20149: PUSH
20150: LD_INT 25
20152: PUSH
20153: LD_INT 26
20155: PUSH
20156: LD_INT 27
20158: PUSH
20159: LD_INT 28
20161: PUSH
20162: LD_INT 29
20164: PUSH
20165: LD_INT 30
20167: PUSH
20168: LD_INT 31
20170: PUSH
20171: LD_INT 32
20173: PUSH
20174: LD_INT 33
20176: PUSH
20177: LD_INT 34
20179: PUSH
20180: LD_INT 36
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: PUSH
20220: LD_INT 101
20222: PUSH
20223: LD_INT 102
20225: PUSH
20226: LD_INT 103
20228: PUSH
20229: LD_INT 104
20231: PUSH
20232: LD_INT 105
20234: PUSH
20235: LD_INT 106
20237: PUSH
20238: LD_INT 107
20240: PUSH
20241: LD_INT 108
20243: PUSH
20244: LD_INT 109
20246: PUSH
20247: LD_INT 110
20249: PUSH
20250: LD_INT 111
20252: PUSH
20253: LD_INT 112
20255: PUSH
20256: LD_INT 113
20258: PUSH
20259: LD_INT 114
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: LIST
20266: LIST
20267: LIST
20268: LIST
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: ST_TO_ADDR
20282: GO 21229
20284: LD_INT 15
20286: DOUBLE
20287: EQUAL
20288: IFTRUE 20292
20290: GO 20504
20292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
20293: LD_ADDR_VAR 0 1
20297: PUSH
20298: LD_INT 1
20300: PUSH
20301: LD_INT 2
20303: PUSH
20304: LD_INT 3
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 5
20312: PUSH
20313: LD_INT 6
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: LD_INT 8
20321: PUSH
20322: LD_INT 9
20324: PUSH
20325: LD_INT 10
20327: PUSH
20328: LD_INT 11
20330: PUSH
20331: LD_INT 12
20333: PUSH
20334: LD_INT 13
20336: PUSH
20337: LD_INT 14
20339: PUSH
20340: LD_INT 15
20342: PUSH
20343: LD_INT 16
20345: PUSH
20346: LD_INT 17
20348: PUSH
20349: LD_INT 18
20351: PUSH
20352: LD_INT 19
20354: PUSH
20355: LD_INT 20
20357: PUSH
20358: LD_INT 21
20360: PUSH
20361: LD_INT 22
20363: PUSH
20364: LD_INT 23
20366: PUSH
20367: LD_INT 24
20369: PUSH
20370: LD_INT 25
20372: PUSH
20373: LD_INT 26
20375: PUSH
20376: LD_INT 27
20378: PUSH
20379: LD_INT 28
20381: PUSH
20382: LD_INT 29
20384: PUSH
20385: LD_INT 30
20387: PUSH
20388: LD_INT 31
20390: PUSH
20391: LD_INT 32
20393: PUSH
20394: LD_INT 33
20396: PUSH
20397: LD_INT 34
20399: PUSH
20400: LD_INT 36
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 101
20442: PUSH
20443: LD_INT 102
20445: PUSH
20446: LD_INT 103
20448: PUSH
20449: LD_INT 104
20451: PUSH
20452: LD_INT 105
20454: PUSH
20455: LD_INT 106
20457: PUSH
20458: LD_INT 107
20460: PUSH
20461: LD_INT 108
20463: PUSH
20464: LD_INT 109
20466: PUSH
20467: LD_INT 110
20469: PUSH
20470: LD_INT 111
20472: PUSH
20473: LD_INT 112
20475: PUSH
20476: LD_INT 113
20478: PUSH
20479: LD_INT 114
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: LIST
20488: LIST
20489: LIST
20490: LIST
20491: LIST
20492: LIST
20493: LIST
20494: LIST
20495: LIST
20496: LIST
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: ST_TO_ADDR
20502: GO 21229
20504: LD_INT 16
20506: DOUBLE
20507: EQUAL
20508: IFTRUE 20512
20510: GO 20636
20512: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
20513: LD_ADDR_VAR 0 1
20517: PUSH
20518: LD_INT 2
20520: PUSH
20521: LD_INT 4
20523: PUSH
20524: LD_INT 5
20526: PUSH
20527: LD_INT 7
20529: PUSH
20530: LD_INT 11
20532: PUSH
20533: LD_INT 12
20535: PUSH
20536: LD_INT 15
20538: PUSH
20539: LD_INT 16
20541: PUSH
20542: LD_INT 20
20544: PUSH
20545: LD_INT 21
20547: PUSH
20548: LD_INT 22
20550: PUSH
20551: LD_INT 23
20553: PUSH
20554: LD_INT 25
20556: PUSH
20557: LD_INT 26
20559: PUSH
20560: LD_INT 30
20562: PUSH
20563: LD_INT 31
20565: PUSH
20566: LD_INT 32
20568: PUSH
20569: LD_INT 33
20571: PUSH
20572: LD_INT 34
20574: PUSH
20575: EMPTY
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 101
20598: PUSH
20599: LD_INT 102
20601: PUSH
20602: LD_INT 103
20604: PUSH
20605: LD_INT 106
20607: PUSH
20608: LD_INT 108
20610: PUSH
20611: LD_INT 112
20613: PUSH
20614: LD_INT 113
20616: PUSH
20617: LD_INT 114
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: PUSH
20630: EMPTY
20631: LIST
20632: LIST
20633: ST_TO_ADDR
20634: GO 21229
20636: LD_INT 17
20638: DOUBLE
20639: EQUAL
20640: IFTRUE 20644
20642: GO 20856
20644: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
20645: LD_ADDR_VAR 0 1
20649: PUSH
20650: LD_INT 1
20652: PUSH
20653: LD_INT 2
20655: PUSH
20656: LD_INT 3
20658: PUSH
20659: LD_INT 4
20661: PUSH
20662: LD_INT 5
20664: PUSH
20665: LD_INT 6
20667: PUSH
20668: LD_INT 7
20670: PUSH
20671: LD_INT 8
20673: PUSH
20674: LD_INT 9
20676: PUSH
20677: LD_INT 10
20679: PUSH
20680: LD_INT 11
20682: PUSH
20683: LD_INT 12
20685: PUSH
20686: LD_INT 13
20688: PUSH
20689: LD_INT 14
20691: PUSH
20692: LD_INT 15
20694: PUSH
20695: LD_INT 16
20697: PUSH
20698: LD_INT 17
20700: PUSH
20701: LD_INT 18
20703: PUSH
20704: LD_INT 19
20706: PUSH
20707: LD_INT 20
20709: PUSH
20710: LD_INT 21
20712: PUSH
20713: LD_INT 22
20715: PUSH
20716: LD_INT 23
20718: PUSH
20719: LD_INT 24
20721: PUSH
20722: LD_INT 25
20724: PUSH
20725: LD_INT 26
20727: PUSH
20728: LD_INT 27
20730: PUSH
20731: LD_INT 28
20733: PUSH
20734: LD_INT 29
20736: PUSH
20737: LD_INT 30
20739: PUSH
20740: LD_INT 31
20742: PUSH
20743: LD_INT 32
20745: PUSH
20746: LD_INT 33
20748: PUSH
20749: LD_INT 34
20751: PUSH
20752: LD_INT 36
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: LIST
20759: LIST
20760: LIST
20761: LIST
20762: LIST
20763: LIST
20764: LIST
20765: LIST
20766: LIST
20767: LIST
20768: LIST
20769: LIST
20770: LIST
20771: LIST
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: LIST
20777: LIST
20778: LIST
20779: LIST
20780: LIST
20781: LIST
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: PUSH
20792: LD_INT 101
20794: PUSH
20795: LD_INT 102
20797: PUSH
20798: LD_INT 103
20800: PUSH
20801: LD_INT 104
20803: PUSH
20804: LD_INT 105
20806: PUSH
20807: LD_INT 106
20809: PUSH
20810: LD_INT 107
20812: PUSH
20813: LD_INT 108
20815: PUSH
20816: LD_INT 109
20818: PUSH
20819: LD_INT 110
20821: PUSH
20822: LD_INT 111
20824: PUSH
20825: LD_INT 112
20827: PUSH
20828: LD_INT 113
20830: PUSH
20831: LD_INT 114
20833: PUSH
20834: EMPTY
20835: LIST
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: LIST
20845: LIST
20846: LIST
20847: LIST
20848: LIST
20849: PUSH
20850: EMPTY
20851: LIST
20852: LIST
20853: ST_TO_ADDR
20854: GO 21229
20856: LD_INT 18
20858: DOUBLE
20859: EQUAL
20860: IFTRUE 20864
20862: GO 21000
20864: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
20865: LD_ADDR_VAR 0 1
20869: PUSH
20870: LD_INT 2
20872: PUSH
20873: LD_INT 4
20875: PUSH
20876: LD_INT 5
20878: PUSH
20879: LD_INT 7
20881: PUSH
20882: LD_INT 11
20884: PUSH
20885: LD_INT 12
20887: PUSH
20888: LD_INT 15
20890: PUSH
20891: LD_INT 16
20893: PUSH
20894: LD_INT 20
20896: PUSH
20897: LD_INT 21
20899: PUSH
20900: LD_INT 22
20902: PUSH
20903: LD_INT 23
20905: PUSH
20906: LD_INT 25
20908: PUSH
20909: LD_INT 26
20911: PUSH
20912: LD_INT 30
20914: PUSH
20915: LD_INT 31
20917: PUSH
20918: LD_INT 32
20920: PUSH
20921: LD_INT 33
20923: PUSH
20924: LD_INT 34
20926: PUSH
20927: LD_INT 35
20929: PUSH
20930: LD_INT 36
20932: PUSH
20933: EMPTY
20934: LIST
20935: LIST
20936: LIST
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: LIST
20954: LIST
20955: PUSH
20956: LD_INT 101
20958: PUSH
20959: LD_INT 102
20961: PUSH
20962: LD_INT 103
20964: PUSH
20965: LD_INT 106
20967: PUSH
20968: LD_INT 108
20970: PUSH
20971: LD_INT 112
20973: PUSH
20974: LD_INT 113
20976: PUSH
20977: LD_INT 114
20979: PUSH
20980: LD_INT 115
20982: PUSH
20983: EMPTY
20984: LIST
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: ST_TO_ADDR
20998: GO 21229
21000: LD_INT 19
21002: DOUBLE
21003: EQUAL
21004: IFTRUE 21008
21006: GO 21228
21008: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21009: LD_ADDR_VAR 0 1
21013: PUSH
21014: LD_INT 1
21016: PUSH
21017: LD_INT 2
21019: PUSH
21020: LD_INT 3
21022: PUSH
21023: LD_INT 4
21025: PUSH
21026: LD_INT 5
21028: PUSH
21029: LD_INT 6
21031: PUSH
21032: LD_INT 7
21034: PUSH
21035: LD_INT 8
21037: PUSH
21038: LD_INT 9
21040: PUSH
21041: LD_INT 10
21043: PUSH
21044: LD_INT 11
21046: PUSH
21047: LD_INT 12
21049: PUSH
21050: LD_INT 13
21052: PUSH
21053: LD_INT 14
21055: PUSH
21056: LD_INT 15
21058: PUSH
21059: LD_INT 16
21061: PUSH
21062: LD_INT 17
21064: PUSH
21065: LD_INT 18
21067: PUSH
21068: LD_INT 19
21070: PUSH
21071: LD_INT 20
21073: PUSH
21074: LD_INT 21
21076: PUSH
21077: LD_INT 22
21079: PUSH
21080: LD_INT 23
21082: PUSH
21083: LD_INT 24
21085: PUSH
21086: LD_INT 25
21088: PUSH
21089: LD_INT 26
21091: PUSH
21092: LD_INT 27
21094: PUSH
21095: LD_INT 28
21097: PUSH
21098: LD_INT 29
21100: PUSH
21101: LD_INT 30
21103: PUSH
21104: LD_INT 31
21106: PUSH
21107: LD_INT 32
21109: PUSH
21110: LD_INT 33
21112: PUSH
21113: LD_INT 34
21115: PUSH
21116: LD_INT 35
21118: PUSH
21119: LD_INT 36
21121: PUSH
21122: EMPTY
21123: LIST
21124: LIST
21125: LIST
21126: LIST
21127: LIST
21128: LIST
21129: LIST
21130: LIST
21131: LIST
21132: LIST
21133: LIST
21134: LIST
21135: LIST
21136: LIST
21137: LIST
21138: LIST
21139: LIST
21140: LIST
21141: LIST
21142: LIST
21143: LIST
21144: LIST
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: PUSH
21160: LD_INT 101
21162: PUSH
21163: LD_INT 102
21165: PUSH
21166: LD_INT 103
21168: PUSH
21169: LD_INT 104
21171: PUSH
21172: LD_INT 105
21174: PUSH
21175: LD_INT 106
21177: PUSH
21178: LD_INT 107
21180: PUSH
21181: LD_INT 108
21183: PUSH
21184: LD_INT 109
21186: PUSH
21187: LD_INT 110
21189: PUSH
21190: LD_INT 111
21192: PUSH
21193: LD_INT 112
21195: PUSH
21196: LD_INT 113
21198: PUSH
21199: LD_INT 114
21201: PUSH
21202: LD_INT 115
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: LIST
21209: LIST
21210: LIST
21211: LIST
21212: LIST
21213: LIST
21214: LIST
21215: LIST
21216: LIST
21217: LIST
21218: LIST
21219: LIST
21220: LIST
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: ST_TO_ADDR
21226: GO 21229
21228: POP
// end ; if result then
21229: LD_VAR 0 1
21233: IFFALSE 21522
// begin normal :=  ;
21235: LD_ADDR_VAR 0 3
21239: PUSH
21240: LD_STRING 
21242: ST_TO_ADDR
// hardcore :=  ;
21243: LD_ADDR_VAR 0 4
21247: PUSH
21248: LD_STRING 
21250: ST_TO_ADDR
// for i = 1 to normalCounter do
21251: LD_ADDR_VAR 0 5
21255: PUSH
21256: DOUBLE
21257: LD_INT 1
21259: DEC
21260: ST_TO_ADDR
21261: LD_EXP 47
21265: PUSH
21266: FOR_TO
21267: IFFALSE 21368
// begin tmp := 0 ;
21269: LD_ADDR_VAR 0 2
21273: PUSH
21274: LD_STRING 0
21276: ST_TO_ADDR
// if result [ 1 ] then
21277: LD_VAR 0 1
21281: PUSH
21282: LD_INT 1
21284: ARRAY
21285: IFFALSE 21350
// if result [ 1 ] [ 1 ] = i then
21287: LD_VAR 0 1
21291: PUSH
21292: LD_INT 1
21294: ARRAY
21295: PUSH
21296: LD_INT 1
21298: ARRAY
21299: PUSH
21300: LD_VAR 0 5
21304: EQUAL
21305: IFFALSE 21350
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
21307: LD_ADDR_VAR 0 1
21311: PUSH
21312: LD_VAR 0 1
21316: PPUSH
21317: LD_INT 1
21319: PPUSH
21320: LD_VAR 0 1
21324: PUSH
21325: LD_INT 1
21327: ARRAY
21328: PPUSH
21329: LD_INT 1
21331: PPUSH
21332: CALL_OW 3
21336: PPUSH
21337: CALL_OW 1
21341: ST_TO_ADDR
// tmp := 1 ;
21342: LD_ADDR_VAR 0 2
21346: PUSH
21347: LD_STRING 1
21349: ST_TO_ADDR
// end ; normal := normal & tmp ;
21350: LD_ADDR_VAR 0 3
21354: PUSH
21355: LD_VAR 0 3
21359: PUSH
21360: LD_VAR 0 2
21364: STR
21365: ST_TO_ADDR
// end ;
21366: GO 21266
21368: POP
21369: POP
// for i = 1 to hardcoreCounter do
21370: LD_ADDR_VAR 0 5
21374: PUSH
21375: DOUBLE
21376: LD_INT 1
21378: DEC
21379: ST_TO_ADDR
21380: LD_EXP 48
21384: PUSH
21385: FOR_TO
21386: IFFALSE 21491
// begin tmp := 0 ;
21388: LD_ADDR_VAR 0 2
21392: PUSH
21393: LD_STRING 0
21395: ST_TO_ADDR
// if result [ 2 ] then
21396: LD_VAR 0 1
21400: PUSH
21401: LD_INT 2
21403: ARRAY
21404: IFFALSE 21473
// if result [ 2 ] [ 1 ] = 100 + i then
21406: LD_VAR 0 1
21410: PUSH
21411: LD_INT 2
21413: ARRAY
21414: PUSH
21415: LD_INT 1
21417: ARRAY
21418: PUSH
21419: LD_INT 100
21421: PUSH
21422: LD_VAR 0 5
21426: PLUS
21427: EQUAL
21428: IFFALSE 21473
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
21430: LD_ADDR_VAR 0 1
21434: PUSH
21435: LD_VAR 0 1
21439: PPUSH
21440: LD_INT 2
21442: PPUSH
21443: LD_VAR 0 1
21447: PUSH
21448: LD_INT 2
21450: ARRAY
21451: PPUSH
21452: LD_INT 1
21454: PPUSH
21455: CALL_OW 3
21459: PPUSH
21460: CALL_OW 1
21464: ST_TO_ADDR
// tmp := 1 ;
21465: LD_ADDR_VAR 0 2
21469: PUSH
21470: LD_STRING 1
21472: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
21473: LD_ADDR_VAR 0 4
21477: PUSH
21478: LD_VAR 0 4
21482: PUSH
21483: LD_VAR 0 2
21487: STR
21488: ST_TO_ADDR
// end ;
21489: GO 21385
21491: POP
21492: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
21493: LD_STRING getStreamItemsFromMission("
21495: PUSH
21496: LD_VAR 0 3
21500: STR
21501: PUSH
21502: LD_STRING ","
21504: STR
21505: PUSH
21506: LD_VAR 0 4
21510: STR
21511: PUSH
21512: LD_STRING ")
21514: STR
21515: PPUSH
21516: CALL_OW 559
// end else
21520: GO 21529
// ToLua ( getStreamItemsFromMission("","") ) ;
21522: LD_STRING getStreamItemsFromMission("","")
21524: PPUSH
21525: CALL_OW 559
// end ;
21529: LD_VAR 0 1
21533: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
21534: LD_VAR 0 2
21538: PUSH
21539: LD_INT 100
21541: EQUAL
21542: IFFALSE 22491
// begin if not StreamModeActive then
21544: LD_EXP 46
21548: NOT
21549: IFFALSE 21559
// StreamModeActive := true ;
21551: LD_ADDR_EXP 46
21555: PUSH
21556: LD_INT 1
21558: ST_TO_ADDR
// if p3 = 0 then
21559: LD_VAR 0 3
21563: PUSH
21564: LD_INT 0
21566: EQUAL
21567: IFFALSE 21573
// InitStreamMode ;
21569: CALL 17831 0 0
// if p3 = 1 then
21573: LD_VAR 0 3
21577: PUSH
21578: LD_INT 1
21580: EQUAL
21581: IFFALSE 21591
// sRocket := true ;
21583: LD_ADDR_EXP 51
21587: PUSH
21588: LD_INT 1
21590: ST_TO_ADDR
// if p3 = 2 then
21591: LD_VAR 0 3
21595: PUSH
21596: LD_INT 2
21598: EQUAL
21599: IFFALSE 21609
// sSpeed := true ;
21601: LD_ADDR_EXP 50
21605: PUSH
21606: LD_INT 1
21608: ST_TO_ADDR
// if p3 = 3 then
21609: LD_VAR 0 3
21613: PUSH
21614: LD_INT 3
21616: EQUAL
21617: IFFALSE 21627
// sEngine := true ;
21619: LD_ADDR_EXP 52
21623: PUSH
21624: LD_INT 1
21626: ST_TO_ADDR
// if p3 = 4 then
21627: LD_VAR 0 3
21631: PUSH
21632: LD_INT 4
21634: EQUAL
21635: IFFALSE 21645
// sSpec := true ;
21637: LD_ADDR_EXP 49
21641: PUSH
21642: LD_INT 1
21644: ST_TO_ADDR
// if p3 = 5 then
21645: LD_VAR 0 3
21649: PUSH
21650: LD_INT 5
21652: EQUAL
21653: IFFALSE 21663
// sLevel := true ;
21655: LD_ADDR_EXP 53
21659: PUSH
21660: LD_INT 1
21662: ST_TO_ADDR
// if p3 = 6 then
21663: LD_VAR 0 3
21667: PUSH
21668: LD_INT 6
21670: EQUAL
21671: IFFALSE 21681
// sArmoury := true ;
21673: LD_ADDR_EXP 54
21677: PUSH
21678: LD_INT 1
21680: ST_TO_ADDR
// if p3 = 7 then
21681: LD_VAR 0 3
21685: PUSH
21686: LD_INT 7
21688: EQUAL
21689: IFFALSE 21699
// sRadar := true ;
21691: LD_ADDR_EXP 55
21695: PUSH
21696: LD_INT 1
21698: ST_TO_ADDR
// if p3 = 8 then
21699: LD_VAR 0 3
21703: PUSH
21704: LD_INT 8
21706: EQUAL
21707: IFFALSE 21717
// sBunker := true ;
21709: LD_ADDR_EXP 56
21713: PUSH
21714: LD_INT 1
21716: ST_TO_ADDR
// if p3 = 9 then
21717: LD_VAR 0 3
21721: PUSH
21722: LD_INT 9
21724: EQUAL
21725: IFFALSE 21735
// sHack := true ;
21727: LD_ADDR_EXP 57
21731: PUSH
21732: LD_INT 1
21734: ST_TO_ADDR
// if p3 = 10 then
21735: LD_VAR 0 3
21739: PUSH
21740: LD_INT 10
21742: EQUAL
21743: IFFALSE 21753
// sFire := true ;
21745: LD_ADDR_EXP 58
21749: PUSH
21750: LD_INT 1
21752: ST_TO_ADDR
// if p3 = 11 then
21753: LD_VAR 0 3
21757: PUSH
21758: LD_INT 11
21760: EQUAL
21761: IFFALSE 21771
// sRefresh := true ;
21763: LD_ADDR_EXP 59
21767: PUSH
21768: LD_INT 1
21770: ST_TO_ADDR
// if p3 = 12 then
21771: LD_VAR 0 3
21775: PUSH
21776: LD_INT 12
21778: EQUAL
21779: IFFALSE 21789
// sExp := true ;
21781: LD_ADDR_EXP 60
21785: PUSH
21786: LD_INT 1
21788: ST_TO_ADDR
// if p3 = 13 then
21789: LD_VAR 0 3
21793: PUSH
21794: LD_INT 13
21796: EQUAL
21797: IFFALSE 21807
// sDepot := true ;
21799: LD_ADDR_EXP 61
21803: PUSH
21804: LD_INT 1
21806: ST_TO_ADDR
// if p3 = 14 then
21807: LD_VAR 0 3
21811: PUSH
21812: LD_INT 14
21814: EQUAL
21815: IFFALSE 21825
// sFlag := true ;
21817: LD_ADDR_EXP 62
21821: PUSH
21822: LD_INT 1
21824: ST_TO_ADDR
// if p3 = 15 then
21825: LD_VAR 0 3
21829: PUSH
21830: LD_INT 15
21832: EQUAL
21833: IFFALSE 21843
// sKamikadze := true ;
21835: LD_ADDR_EXP 70
21839: PUSH
21840: LD_INT 1
21842: ST_TO_ADDR
// if p3 = 16 then
21843: LD_VAR 0 3
21847: PUSH
21848: LD_INT 16
21850: EQUAL
21851: IFFALSE 21861
// sTroll := true ;
21853: LD_ADDR_EXP 71
21857: PUSH
21858: LD_INT 1
21860: ST_TO_ADDR
// if p3 = 17 then
21861: LD_VAR 0 3
21865: PUSH
21866: LD_INT 17
21868: EQUAL
21869: IFFALSE 21879
// sSlow := true ;
21871: LD_ADDR_EXP 72
21875: PUSH
21876: LD_INT 1
21878: ST_TO_ADDR
// if p3 = 18 then
21879: LD_VAR 0 3
21883: PUSH
21884: LD_INT 18
21886: EQUAL
21887: IFFALSE 21897
// sLack := true ;
21889: LD_ADDR_EXP 73
21893: PUSH
21894: LD_INT 1
21896: ST_TO_ADDR
// if p3 = 19 then
21897: LD_VAR 0 3
21901: PUSH
21902: LD_INT 19
21904: EQUAL
21905: IFFALSE 21915
// sTank := true ;
21907: LD_ADDR_EXP 75
21911: PUSH
21912: LD_INT 1
21914: ST_TO_ADDR
// if p3 = 20 then
21915: LD_VAR 0 3
21919: PUSH
21920: LD_INT 20
21922: EQUAL
21923: IFFALSE 21933
// sRemote := true ;
21925: LD_ADDR_EXP 76
21929: PUSH
21930: LD_INT 1
21932: ST_TO_ADDR
// if p3 = 21 then
21933: LD_VAR 0 3
21937: PUSH
21938: LD_INT 21
21940: EQUAL
21941: IFFALSE 21951
// sPowell := true ;
21943: LD_ADDR_EXP 77
21947: PUSH
21948: LD_INT 1
21950: ST_TO_ADDR
// if p3 = 22 then
21951: LD_VAR 0 3
21955: PUSH
21956: LD_INT 22
21958: EQUAL
21959: IFFALSE 21969
// sTeleport := true ;
21961: LD_ADDR_EXP 80
21965: PUSH
21966: LD_INT 1
21968: ST_TO_ADDR
// if p3 = 23 then
21969: LD_VAR 0 3
21973: PUSH
21974: LD_INT 23
21976: EQUAL
21977: IFFALSE 21987
// sOilTower := true ;
21979: LD_ADDR_EXP 82
21983: PUSH
21984: LD_INT 1
21986: ST_TO_ADDR
// if p3 = 24 then
21987: LD_VAR 0 3
21991: PUSH
21992: LD_INT 24
21994: EQUAL
21995: IFFALSE 22005
// sShovel := true ;
21997: LD_ADDR_EXP 83
22001: PUSH
22002: LD_INT 1
22004: ST_TO_ADDR
// if p3 = 25 then
22005: LD_VAR 0 3
22009: PUSH
22010: LD_INT 25
22012: EQUAL
22013: IFFALSE 22023
// sSheik := true ;
22015: LD_ADDR_EXP 84
22019: PUSH
22020: LD_INT 1
22022: ST_TO_ADDR
// if p3 = 26 then
22023: LD_VAR 0 3
22027: PUSH
22028: LD_INT 26
22030: EQUAL
22031: IFFALSE 22041
// sEarthquake := true ;
22033: LD_ADDR_EXP 86
22037: PUSH
22038: LD_INT 1
22040: ST_TO_ADDR
// if p3 = 27 then
22041: LD_VAR 0 3
22045: PUSH
22046: LD_INT 27
22048: EQUAL
22049: IFFALSE 22059
// sAI := true ;
22051: LD_ADDR_EXP 87
22055: PUSH
22056: LD_INT 1
22058: ST_TO_ADDR
// if p3 = 28 then
22059: LD_VAR 0 3
22063: PUSH
22064: LD_INT 28
22066: EQUAL
22067: IFFALSE 22077
// sCargo := true ;
22069: LD_ADDR_EXP 90
22073: PUSH
22074: LD_INT 1
22076: ST_TO_ADDR
// if p3 = 29 then
22077: LD_VAR 0 3
22081: PUSH
22082: LD_INT 29
22084: EQUAL
22085: IFFALSE 22095
// sDLaser := true ;
22087: LD_ADDR_EXP 91
22091: PUSH
22092: LD_INT 1
22094: ST_TO_ADDR
// if p3 = 30 then
22095: LD_VAR 0 3
22099: PUSH
22100: LD_INT 30
22102: EQUAL
22103: IFFALSE 22113
// sExchange := true ;
22105: LD_ADDR_EXP 92
22109: PUSH
22110: LD_INT 1
22112: ST_TO_ADDR
// if p3 = 31 then
22113: LD_VAR 0 3
22117: PUSH
22118: LD_INT 31
22120: EQUAL
22121: IFFALSE 22131
// sFac := true ;
22123: LD_ADDR_EXP 93
22127: PUSH
22128: LD_INT 1
22130: ST_TO_ADDR
// if p3 = 32 then
22131: LD_VAR 0 3
22135: PUSH
22136: LD_INT 32
22138: EQUAL
22139: IFFALSE 22149
// sPower := true ;
22141: LD_ADDR_EXP 94
22145: PUSH
22146: LD_INT 1
22148: ST_TO_ADDR
// if p3 = 33 then
22149: LD_VAR 0 3
22153: PUSH
22154: LD_INT 33
22156: EQUAL
22157: IFFALSE 22167
// sRandom := true ;
22159: LD_ADDR_EXP 95
22163: PUSH
22164: LD_INT 1
22166: ST_TO_ADDR
// if p3 = 34 then
22167: LD_VAR 0 3
22171: PUSH
22172: LD_INT 34
22174: EQUAL
22175: IFFALSE 22185
// sShield := true ;
22177: LD_ADDR_EXP 96
22181: PUSH
22182: LD_INT 1
22184: ST_TO_ADDR
// if p3 = 35 then
22185: LD_VAR 0 3
22189: PUSH
22190: LD_INT 35
22192: EQUAL
22193: IFFALSE 22203
// sTime := true ;
22195: LD_ADDR_EXP 97
22199: PUSH
22200: LD_INT 1
22202: ST_TO_ADDR
// if p3 = 36 then
22203: LD_VAR 0 3
22207: PUSH
22208: LD_INT 36
22210: EQUAL
22211: IFFALSE 22221
// sTools := true ;
22213: LD_ADDR_EXP 98
22217: PUSH
22218: LD_INT 1
22220: ST_TO_ADDR
// if p3 = 101 then
22221: LD_VAR 0 3
22225: PUSH
22226: LD_INT 101
22228: EQUAL
22229: IFFALSE 22239
// sSold := true ;
22231: LD_ADDR_EXP 63
22235: PUSH
22236: LD_INT 1
22238: ST_TO_ADDR
// if p3 = 102 then
22239: LD_VAR 0 3
22243: PUSH
22244: LD_INT 102
22246: EQUAL
22247: IFFALSE 22257
// sDiff := true ;
22249: LD_ADDR_EXP 64
22253: PUSH
22254: LD_INT 1
22256: ST_TO_ADDR
// if p3 = 103 then
22257: LD_VAR 0 3
22261: PUSH
22262: LD_INT 103
22264: EQUAL
22265: IFFALSE 22275
// sFog := true ;
22267: LD_ADDR_EXP 67
22271: PUSH
22272: LD_INT 1
22274: ST_TO_ADDR
// if p3 = 104 then
22275: LD_VAR 0 3
22279: PUSH
22280: LD_INT 104
22282: EQUAL
22283: IFFALSE 22293
// sReset := true ;
22285: LD_ADDR_EXP 68
22289: PUSH
22290: LD_INT 1
22292: ST_TO_ADDR
// if p3 = 105 then
22293: LD_VAR 0 3
22297: PUSH
22298: LD_INT 105
22300: EQUAL
22301: IFFALSE 22311
// sSun := true ;
22303: LD_ADDR_EXP 69
22307: PUSH
22308: LD_INT 1
22310: ST_TO_ADDR
// if p3 = 106 then
22311: LD_VAR 0 3
22315: PUSH
22316: LD_INT 106
22318: EQUAL
22319: IFFALSE 22329
// sTiger := true ;
22321: LD_ADDR_EXP 65
22325: PUSH
22326: LD_INT 1
22328: ST_TO_ADDR
// if p3 = 107 then
22329: LD_VAR 0 3
22333: PUSH
22334: LD_INT 107
22336: EQUAL
22337: IFFALSE 22347
// sBomb := true ;
22339: LD_ADDR_EXP 66
22343: PUSH
22344: LD_INT 1
22346: ST_TO_ADDR
// if p3 = 108 then
22347: LD_VAR 0 3
22351: PUSH
22352: LD_INT 108
22354: EQUAL
22355: IFFALSE 22365
// sWound := true ;
22357: LD_ADDR_EXP 74
22361: PUSH
22362: LD_INT 1
22364: ST_TO_ADDR
// if p3 = 109 then
22365: LD_VAR 0 3
22369: PUSH
22370: LD_INT 109
22372: EQUAL
22373: IFFALSE 22383
// sBetray := true ;
22375: LD_ADDR_EXP 78
22379: PUSH
22380: LD_INT 1
22382: ST_TO_ADDR
// if p3 = 110 then
22383: LD_VAR 0 3
22387: PUSH
22388: LD_INT 110
22390: EQUAL
22391: IFFALSE 22401
// sContamin := true ;
22393: LD_ADDR_EXP 79
22397: PUSH
22398: LD_INT 1
22400: ST_TO_ADDR
// if p3 = 111 then
22401: LD_VAR 0 3
22405: PUSH
22406: LD_INT 111
22408: EQUAL
22409: IFFALSE 22419
// sOil := true ;
22411: LD_ADDR_EXP 81
22415: PUSH
22416: LD_INT 1
22418: ST_TO_ADDR
// if p3 = 112 then
22419: LD_VAR 0 3
22423: PUSH
22424: LD_INT 112
22426: EQUAL
22427: IFFALSE 22437
// sStu := true ;
22429: LD_ADDR_EXP 85
22433: PUSH
22434: LD_INT 1
22436: ST_TO_ADDR
// if p3 = 113 then
22437: LD_VAR 0 3
22441: PUSH
22442: LD_INT 113
22444: EQUAL
22445: IFFALSE 22455
// sBazooka := true ;
22447: LD_ADDR_EXP 88
22451: PUSH
22452: LD_INT 1
22454: ST_TO_ADDR
// if p3 = 114 then
22455: LD_VAR 0 3
22459: PUSH
22460: LD_INT 114
22462: EQUAL
22463: IFFALSE 22473
// sMortar := true ;
22465: LD_ADDR_EXP 89
22469: PUSH
22470: LD_INT 1
22472: ST_TO_ADDR
// if p3 = 115 then
22473: LD_VAR 0 3
22477: PUSH
22478: LD_INT 115
22480: EQUAL
22481: IFFALSE 22491
// sRanger := true ;
22483: LD_ADDR_EXP 99
22487: PUSH
22488: LD_INT 1
22490: ST_TO_ADDR
// end ; end ;
22491: PPOPN 6
22493: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
22494: LD_EXP 46
22498: PUSH
22499: LD_EXP 51
22503: AND
22504: IFFALSE 22628
22506: GO 22508
22508: DISABLE
22509: LD_INT 0
22511: PPUSH
22512: PPUSH
// begin enable ;
22513: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
22514: LD_ADDR_VAR 0 2
22518: PUSH
22519: LD_INT 22
22521: PUSH
22522: LD_OWVAR 2
22526: PUSH
22527: EMPTY
22528: LIST
22529: LIST
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: LD_INT 34
22536: PUSH
22537: LD_INT 7
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: PUSH
22544: LD_INT 34
22546: PUSH
22547: LD_INT 45
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: PUSH
22554: LD_INT 34
22556: PUSH
22557: LD_INT 28
22559: PUSH
22560: EMPTY
22561: LIST
22562: LIST
22563: PUSH
22564: LD_INT 34
22566: PUSH
22567: LD_INT 47
22569: PUSH
22570: EMPTY
22571: LIST
22572: LIST
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: LIST
22578: LIST
22579: LIST
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// if not tmp then
22590: LD_VAR 0 2
22594: NOT
22595: IFFALSE 22599
// exit ;
22597: GO 22628
// for i in tmp do
22599: LD_ADDR_VAR 0 1
22603: PUSH
22604: LD_VAR 0 2
22608: PUSH
22609: FOR_IN
22610: IFFALSE 22626
// begin SetLives ( i , 0 ) ;
22612: LD_VAR 0 1
22616: PPUSH
22617: LD_INT 0
22619: PPUSH
22620: CALL_OW 234
// end ;
22624: GO 22609
22626: POP
22627: POP
// end ;
22628: PPOPN 2
22630: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
22631: LD_EXP 46
22635: PUSH
22636: LD_EXP 52
22640: AND
22641: IFFALSE 22725
22643: GO 22645
22645: DISABLE
22646: LD_INT 0
22648: PPUSH
22649: PPUSH
// begin enable ;
22650: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
22651: LD_ADDR_VAR 0 2
22655: PUSH
22656: LD_INT 22
22658: PUSH
22659: LD_OWVAR 2
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: LD_INT 32
22670: PUSH
22671: LD_INT 3
22673: PUSH
22674: EMPTY
22675: LIST
22676: LIST
22677: PUSH
22678: EMPTY
22679: LIST
22680: LIST
22681: PPUSH
22682: CALL_OW 69
22686: ST_TO_ADDR
// if not tmp then
22687: LD_VAR 0 2
22691: NOT
22692: IFFALSE 22696
// exit ;
22694: GO 22725
// for i in tmp do
22696: LD_ADDR_VAR 0 1
22700: PUSH
22701: LD_VAR 0 2
22705: PUSH
22706: FOR_IN
22707: IFFALSE 22723
// begin SetLives ( i , 0 ) ;
22709: LD_VAR 0 1
22713: PPUSH
22714: LD_INT 0
22716: PPUSH
22717: CALL_OW 234
// end ;
22721: GO 22706
22723: POP
22724: POP
// end ;
22725: PPOPN 2
22727: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
22728: LD_EXP 46
22732: PUSH
22733: LD_EXP 49
22737: AND
22738: IFFALSE 22831
22740: GO 22742
22742: DISABLE
22743: LD_INT 0
22745: PPUSH
// begin enable ;
22746: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
22747: LD_ADDR_VAR 0 1
22751: PUSH
22752: LD_INT 22
22754: PUSH
22755: LD_OWVAR 2
22759: PUSH
22760: EMPTY
22761: LIST
22762: LIST
22763: PUSH
22764: LD_INT 2
22766: PUSH
22767: LD_INT 25
22769: PUSH
22770: LD_INT 5
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 25
22779: PUSH
22780: LD_INT 9
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: PUSH
22787: LD_INT 25
22789: PUSH
22790: LD_INT 8
22792: PUSH
22793: EMPTY
22794: LIST
22795: LIST
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: LIST
22801: LIST
22802: PUSH
22803: EMPTY
22804: LIST
22805: LIST
22806: PPUSH
22807: CALL_OW 69
22811: PUSH
22812: FOR_IN
22813: IFFALSE 22829
// begin SetClass ( i , 1 ) ;
22815: LD_VAR 0 1
22819: PPUSH
22820: LD_INT 1
22822: PPUSH
22823: CALL_OW 336
// end ;
22827: GO 22812
22829: POP
22830: POP
// end ;
22831: PPOPN 1
22833: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
22834: LD_EXP 46
22838: PUSH
22839: LD_EXP 50
22843: AND
22844: PUSH
22845: LD_OWVAR 65
22849: PUSH
22850: LD_INT 7
22852: LESS
22853: AND
22854: IFFALSE 22868
22856: GO 22858
22858: DISABLE
// begin enable ;
22859: ENABLE
// game_speed := 7 ;
22860: LD_ADDR_OWVAR 65
22864: PUSH
22865: LD_INT 7
22867: ST_TO_ADDR
// end ;
22868: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
22869: LD_EXP 46
22873: PUSH
22874: LD_EXP 53
22878: AND
22879: IFFALSE 23081
22881: GO 22883
22883: DISABLE
22884: LD_INT 0
22886: PPUSH
22887: PPUSH
22888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
22889: LD_ADDR_VAR 0 3
22893: PUSH
22894: LD_INT 81
22896: PUSH
22897: LD_OWVAR 2
22901: PUSH
22902: EMPTY
22903: LIST
22904: LIST
22905: PUSH
22906: LD_INT 21
22908: PUSH
22909: LD_INT 1
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: PUSH
22916: EMPTY
22917: LIST
22918: LIST
22919: PPUSH
22920: CALL_OW 69
22924: ST_TO_ADDR
// if not tmp then
22925: LD_VAR 0 3
22929: NOT
22930: IFFALSE 22934
// exit ;
22932: GO 23081
// if tmp > 5 then
22934: LD_VAR 0 3
22938: PUSH
22939: LD_INT 5
22941: GREATER
22942: IFFALSE 22954
// k := 5 else
22944: LD_ADDR_VAR 0 2
22948: PUSH
22949: LD_INT 5
22951: ST_TO_ADDR
22952: GO 22964
// k := tmp ;
22954: LD_ADDR_VAR 0 2
22958: PUSH
22959: LD_VAR 0 3
22963: ST_TO_ADDR
// for i := 1 to k do
22964: LD_ADDR_VAR 0 1
22968: PUSH
22969: DOUBLE
22970: LD_INT 1
22972: DEC
22973: ST_TO_ADDR
22974: LD_VAR 0 2
22978: PUSH
22979: FOR_TO
22980: IFFALSE 23079
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
22982: LD_VAR 0 3
22986: PUSH
22987: LD_VAR 0 1
22991: ARRAY
22992: PPUSH
22993: LD_VAR 0 1
22997: PUSH
22998: LD_INT 4
23000: MOD
23001: PUSH
23002: LD_INT 1
23004: PLUS
23005: PPUSH
23006: CALL_OW 259
23010: PUSH
23011: LD_INT 10
23013: LESS
23014: IFFALSE 23077
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23016: LD_VAR 0 3
23020: PUSH
23021: LD_VAR 0 1
23025: ARRAY
23026: PPUSH
23027: LD_VAR 0 1
23031: PUSH
23032: LD_INT 4
23034: MOD
23035: PUSH
23036: LD_INT 1
23038: PLUS
23039: PPUSH
23040: LD_VAR 0 3
23044: PUSH
23045: LD_VAR 0 1
23049: ARRAY
23050: PPUSH
23051: LD_VAR 0 1
23055: PUSH
23056: LD_INT 4
23058: MOD
23059: PUSH
23060: LD_INT 1
23062: PLUS
23063: PPUSH
23064: CALL_OW 259
23068: PUSH
23069: LD_INT 1
23071: PLUS
23072: PPUSH
23073: CALL_OW 237
23077: GO 22979
23079: POP
23080: POP
// end ;
23081: PPOPN 3
23083: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23084: LD_EXP 46
23088: PUSH
23089: LD_EXP 54
23093: AND
23094: IFFALSE 23114
23096: GO 23098
23098: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23099: LD_INT 4
23101: PPUSH
23102: LD_OWVAR 2
23106: PPUSH
23107: LD_INT 0
23109: PPUSH
23110: CALL_OW 324
23114: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23115: LD_EXP 46
23119: PUSH
23120: LD_EXP 83
23124: AND
23125: IFFALSE 23145
23127: GO 23129
23129: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23130: LD_INT 19
23132: PPUSH
23133: LD_OWVAR 2
23137: PPUSH
23138: LD_INT 0
23140: PPUSH
23141: CALL_OW 324
23145: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23146: LD_EXP 46
23150: PUSH
23151: LD_EXP 55
23155: AND
23156: IFFALSE 23258
23158: GO 23160
23160: DISABLE
23161: LD_INT 0
23163: PPUSH
23164: PPUSH
// begin enable ;
23165: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23166: LD_ADDR_VAR 0 2
23170: PUSH
23171: LD_INT 22
23173: PUSH
23174: LD_OWVAR 2
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: PUSH
23183: LD_INT 2
23185: PUSH
23186: LD_INT 34
23188: PUSH
23189: LD_INT 11
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: LD_INT 34
23198: PUSH
23199: LD_INT 30
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: LIST
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: PPUSH
23215: CALL_OW 69
23219: ST_TO_ADDR
// if not tmp then
23220: LD_VAR 0 2
23224: NOT
23225: IFFALSE 23229
// exit ;
23227: GO 23258
// for i in tmp do
23229: LD_ADDR_VAR 0 1
23233: PUSH
23234: LD_VAR 0 2
23238: PUSH
23239: FOR_IN
23240: IFFALSE 23256
// begin SetLives ( i , 0 ) ;
23242: LD_VAR 0 1
23246: PPUSH
23247: LD_INT 0
23249: PPUSH
23250: CALL_OW 234
// end ;
23254: GO 23239
23256: POP
23257: POP
// end ;
23258: PPOPN 2
23260: END
// every 0 0$1 trigger StreamModeActive and sBunker do
23261: LD_EXP 46
23265: PUSH
23266: LD_EXP 56
23270: AND
23271: IFFALSE 23291
23273: GO 23275
23275: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
23276: LD_INT 32
23278: PPUSH
23279: LD_OWVAR 2
23283: PPUSH
23284: LD_INT 0
23286: PPUSH
23287: CALL_OW 324
23291: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
23292: LD_EXP 46
23296: PUSH
23297: LD_EXP 57
23301: AND
23302: IFFALSE 23483
23304: GO 23306
23306: DISABLE
23307: LD_INT 0
23309: PPUSH
23310: PPUSH
23311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
23312: LD_ADDR_VAR 0 2
23316: PUSH
23317: LD_INT 22
23319: PUSH
23320: LD_OWVAR 2
23324: PUSH
23325: EMPTY
23326: LIST
23327: LIST
23328: PUSH
23329: LD_INT 33
23331: PUSH
23332: LD_INT 3
23334: PUSH
23335: EMPTY
23336: LIST
23337: LIST
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: PPUSH
23343: CALL_OW 69
23347: ST_TO_ADDR
// if not tmp then
23348: LD_VAR 0 2
23352: NOT
23353: IFFALSE 23357
// exit ;
23355: GO 23483
// side := 0 ;
23357: LD_ADDR_VAR 0 3
23361: PUSH
23362: LD_INT 0
23364: ST_TO_ADDR
// for i := 1 to 8 do
23365: LD_ADDR_VAR 0 1
23369: PUSH
23370: DOUBLE
23371: LD_INT 1
23373: DEC
23374: ST_TO_ADDR
23375: LD_INT 8
23377: PUSH
23378: FOR_TO
23379: IFFALSE 23427
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
23381: LD_OWVAR 2
23385: PUSH
23386: LD_VAR 0 1
23390: NONEQUAL
23391: PUSH
23392: LD_OWVAR 2
23396: PPUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: CALL_OW 81
23406: PUSH
23407: LD_INT 2
23409: EQUAL
23410: AND
23411: IFFALSE 23425
// begin side := i ;
23413: LD_ADDR_VAR 0 3
23417: PUSH
23418: LD_VAR 0 1
23422: ST_TO_ADDR
// break ;
23423: GO 23427
// end ;
23425: GO 23378
23427: POP
23428: POP
// if not side then
23429: LD_VAR 0 3
23433: NOT
23434: IFFALSE 23438
// exit ;
23436: GO 23483
// for i := 1 to tmp do
23438: LD_ADDR_VAR 0 1
23442: PUSH
23443: DOUBLE
23444: LD_INT 1
23446: DEC
23447: ST_TO_ADDR
23448: LD_VAR 0 2
23452: PUSH
23453: FOR_TO
23454: IFFALSE 23481
// if Prob ( 60 ) then
23456: LD_INT 60
23458: PPUSH
23459: CALL_OW 13
23463: IFFALSE 23479
// SetSide ( i , side ) ;
23465: LD_VAR 0 1
23469: PPUSH
23470: LD_VAR 0 3
23474: PPUSH
23475: CALL_OW 235
23479: GO 23453
23481: POP
23482: POP
// end ;
23483: PPOPN 3
23485: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
23486: LD_EXP 46
23490: PUSH
23491: LD_EXP 59
23495: AND
23496: IFFALSE 23615
23498: GO 23500
23500: DISABLE
23501: LD_INT 0
23503: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
23504: LD_ADDR_VAR 0 1
23508: PUSH
23509: LD_INT 22
23511: PUSH
23512: LD_OWVAR 2
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: LD_INT 21
23523: PUSH
23524: LD_INT 1
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 3
23533: PUSH
23534: LD_INT 23
23536: PUSH
23537: LD_INT 0
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: LIST
23552: PPUSH
23553: CALL_OW 69
23557: PUSH
23558: FOR_IN
23559: IFFALSE 23613
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
23561: LD_VAR 0 1
23565: PPUSH
23566: CALL_OW 257
23570: PUSH
23571: LD_INT 1
23573: PUSH
23574: LD_INT 2
23576: PUSH
23577: LD_INT 3
23579: PUSH
23580: LD_INT 4
23582: PUSH
23583: EMPTY
23584: LIST
23585: LIST
23586: LIST
23587: LIST
23588: IN
23589: IFFALSE 23611
// SetClass ( un , rand ( 1 , 4 ) ) ;
23591: LD_VAR 0 1
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: LD_INT 4
23601: PPUSH
23602: CALL_OW 12
23606: PPUSH
23607: CALL_OW 336
23611: GO 23558
23613: POP
23614: POP
// end ;
23615: PPOPN 1
23617: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
23618: LD_EXP 46
23622: PUSH
23623: LD_EXP 58
23627: AND
23628: IFFALSE 23707
23630: GO 23632
23632: DISABLE
23633: LD_INT 0
23635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
23636: LD_ADDR_VAR 0 1
23640: PUSH
23641: LD_INT 22
23643: PUSH
23644: LD_OWVAR 2
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: PUSH
23653: LD_INT 21
23655: PUSH
23656: LD_INT 3
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PPUSH
23667: CALL_OW 69
23671: ST_TO_ADDR
// if not tmp then
23672: LD_VAR 0 1
23676: NOT
23677: IFFALSE 23681
// exit ;
23679: GO 23707
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
23681: LD_VAR 0 1
23685: PUSH
23686: LD_INT 1
23688: PPUSH
23689: LD_VAR 0 1
23693: PPUSH
23694: CALL_OW 12
23698: ARRAY
23699: PPUSH
23700: LD_INT 100
23702: PPUSH
23703: CALL_OW 234
// end ;
23707: PPOPN 1
23709: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
23710: LD_EXP 46
23714: PUSH
23715: LD_EXP 60
23719: AND
23720: IFFALSE 23818
23722: GO 23724
23724: DISABLE
23725: LD_INT 0
23727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23728: LD_ADDR_VAR 0 1
23732: PUSH
23733: LD_INT 22
23735: PUSH
23736: LD_OWVAR 2
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: PUSH
23745: LD_INT 21
23747: PUSH
23748: LD_INT 1
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: EMPTY
23756: LIST
23757: LIST
23758: PPUSH
23759: CALL_OW 69
23763: ST_TO_ADDR
// if not tmp then
23764: LD_VAR 0 1
23768: NOT
23769: IFFALSE 23773
// exit ;
23771: GO 23818
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
23773: LD_VAR 0 1
23777: PUSH
23778: LD_INT 1
23780: PPUSH
23781: LD_VAR 0 1
23785: PPUSH
23786: CALL_OW 12
23790: ARRAY
23791: PPUSH
23792: LD_INT 1
23794: PPUSH
23795: LD_INT 4
23797: PPUSH
23798: CALL_OW 12
23802: PPUSH
23803: LD_INT 3000
23805: PPUSH
23806: LD_INT 9000
23808: PPUSH
23809: CALL_OW 12
23813: PPUSH
23814: CALL_OW 492
// end ;
23818: PPOPN 1
23820: END
// every 0 0$1 trigger StreamModeActive and sDepot do
23821: LD_EXP 46
23825: PUSH
23826: LD_EXP 61
23830: AND
23831: IFFALSE 23851
23833: GO 23835
23835: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
23836: LD_INT 1
23838: PPUSH
23839: LD_OWVAR 2
23843: PPUSH
23844: LD_INT 0
23846: PPUSH
23847: CALL_OW 324
23851: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
23852: LD_EXP 46
23856: PUSH
23857: LD_EXP 62
23861: AND
23862: IFFALSE 23945
23864: GO 23866
23866: DISABLE
23867: LD_INT 0
23869: PPUSH
23870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
23871: LD_ADDR_VAR 0 2
23875: PUSH
23876: LD_INT 22
23878: PUSH
23879: LD_OWVAR 2
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 21
23890: PUSH
23891: LD_INT 3
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 69
23906: ST_TO_ADDR
// if not tmp then
23907: LD_VAR 0 2
23911: NOT
23912: IFFALSE 23916
// exit ;
23914: GO 23945
// for i in tmp do
23916: LD_ADDR_VAR 0 1
23920: PUSH
23921: LD_VAR 0 2
23925: PUSH
23926: FOR_IN
23927: IFFALSE 23943
// SetBLevel ( i , 10 ) ;
23929: LD_VAR 0 1
23933: PPUSH
23934: LD_INT 10
23936: PPUSH
23937: CALL_OW 241
23941: GO 23926
23943: POP
23944: POP
// end ;
23945: PPOPN 2
23947: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
23948: LD_EXP 46
23952: PUSH
23953: LD_EXP 63
23957: AND
23958: IFFALSE 24069
23960: GO 23962
23962: DISABLE
23963: LD_INT 0
23965: PPUSH
23966: PPUSH
23967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
23968: LD_ADDR_VAR 0 3
23972: PUSH
23973: LD_INT 22
23975: PUSH
23976: LD_OWVAR 2
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: PUSH
23985: LD_INT 25
23987: PUSH
23988: LD_INT 1
23990: PUSH
23991: EMPTY
23992: LIST
23993: LIST
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PPUSH
23999: CALL_OW 69
24003: ST_TO_ADDR
// if not tmp then
24004: LD_VAR 0 3
24008: NOT
24009: IFFALSE 24013
// exit ;
24011: GO 24069
// un := tmp [ rand ( 1 , tmp ) ] ;
24013: LD_ADDR_VAR 0 2
24017: PUSH
24018: LD_VAR 0 3
24022: PUSH
24023: LD_INT 1
24025: PPUSH
24026: LD_VAR 0 3
24030: PPUSH
24031: CALL_OW 12
24035: ARRAY
24036: ST_TO_ADDR
// if Crawls ( un ) then
24037: LD_VAR 0 2
24041: PPUSH
24042: CALL_OW 318
24046: IFFALSE 24057
// ComWalk ( un ) ;
24048: LD_VAR 0 2
24052: PPUSH
24053: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24057: LD_VAR 0 2
24061: PPUSH
24062: LD_INT 5
24064: PPUSH
24065: CALL_OW 336
// end ;
24069: PPOPN 3
24071: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24072: LD_EXP 46
24076: PUSH
24077: LD_EXP 64
24081: AND
24082: PUSH
24083: LD_OWVAR 67
24087: PUSH
24088: LD_INT 3
24090: LESS
24091: AND
24092: IFFALSE 24111
24094: GO 24096
24096: DISABLE
// Difficulty := Difficulty + 1 ;
24097: LD_ADDR_OWVAR 67
24101: PUSH
24102: LD_OWVAR 67
24106: PUSH
24107: LD_INT 1
24109: PLUS
24110: ST_TO_ADDR
24111: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24112: LD_EXP 46
24116: PUSH
24117: LD_EXP 65
24121: AND
24122: IFFALSE 24225
24124: GO 24126
24126: DISABLE
24127: LD_INT 0
24129: PPUSH
// begin for i := 1 to 5 do
24130: LD_ADDR_VAR 0 1
24134: PUSH
24135: DOUBLE
24136: LD_INT 1
24138: DEC
24139: ST_TO_ADDR
24140: LD_INT 5
24142: PUSH
24143: FOR_TO
24144: IFFALSE 24223
// begin uc_nation := nation_nature ;
24146: LD_ADDR_OWVAR 21
24150: PUSH
24151: LD_INT 0
24153: ST_TO_ADDR
// uc_side := 0 ;
24154: LD_ADDR_OWVAR 20
24158: PUSH
24159: LD_INT 0
24161: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24162: LD_ADDR_OWVAR 29
24166: PUSH
24167: LD_INT 12
24169: PUSH
24170: LD_INT 12
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: ST_TO_ADDR
// hc_agressivity := 20 ;
24177: LD_ADDR_OWVAR 35
24181: PUSH
24182: LD_INT 20
24184: ST_TO_ADDR
// hc_class := class_tiger ;
24185: LD_ADDR_OWVAR 28
24189: PUSH
24190: LD_INT 14
24192: ST_TO_ADDR
// hc_gallery :=  ;
24193: LD_ADDR_OWVAR 33
24197: PUSH
24198: LD_STRING 
24200: ST_TO_ADDR
// hc_name :=  ;
24201: LD_ADDR_OWVAR 26
24205: PUSH
24206: LD_STRING 
24208: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
24209: CALL_OW 44
24213: PPUSH
24214: LD_INT 0
24216: PPUSH
24217: CALL_OW 51
// end ;
24221: GO 24143
24223: POP
24224: POP
// end ;
24225: PPOPN 1
24227: END
// every 0 0$1 trigger StreamModeActive and sBomb do
24228: LD_EXP 46
24232: PUSH
24233: LD_EXP 66
24237: AND
24238: IFFALSE 24247
24240: GO 24242
24242: DISABLE
// StreamSibBomb ;
24243: CALL 24248 0 0
24247: END
// export function StreamSibBomb ; var i , x , y ; begin
24248: LD_INT 0
24250: PPUSH
24251: PPUSH
24252: PPUSH
24253: PPUSH
// result := false ;
24254: LD_ADDR_VAR 0 1
24258: PUSH
24259: LD_INT 0
24261: ST_TO_ADDR
// for i := 1 to 16 do
24262: LD_ADDR_VAR 0 2
24266: PUSH
24267: DOUBLE
24268: LD_INT 1
24270: DEC
24271: ST_TO_ADDR
24272: LD_INT 16
24274: PUSH
24275: FOR_TO
24276: IFFALSE 24475
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24278: LD_ADDR_VAR 0 3
24282: PUSH
24283: LD_INT 10
24285: PUSH
24286: LD_INT 20
24288: PUSH
24289: LD_INT 30
24291: PUSH
24292: LD_INT 40
24294: PUSH
24295: LD_INT 50
24297: PUSH
24298: LD_INT 60
24300: PUSH
24301: LD_INT 70
24303: PUSH
24304: LD_INT 80
24306: PUSH
24307: LD_INT 90
24309: PUSH
24310: LD_INT 100
24312: PUSH
24313: LD_INT 110
24315: PUSH
24316: LD_INT 120
24318: PUSH
24319: LD_INT 130
24321: PUSH
24322: LD_INT 140
24324: PUSH
24325: LD_INT 150
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: LIST
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: LIST
24337: LIST
24338: LIST
24339: LIST
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: PUSH
24345: LD_INT 1
24347: PPUSH
24348: LD_INT 15
24350: PPUSH
24351: CALL_OW 12
24355: ARRAY
24356: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24357: LD_ADDR_VAR 0 4
24361: PUSH
24362: LD_INT 10
24364: PUSH
24365: LD_INT 20
24367: PUSH
24368: LD_INT 30
24370: PUSH
24371: LD_INT 40
24373: PUSH
24374: LD_INT 50
24376: PUSH
24377: LD_INT 60
24379: PUSH
24380: LD_INT 70
24382: PUSH
24383: LD_INT 80
24385: PUSH
24386: LD_INT 90
24388: PUSH
24389: LD_INT 100
24391: PUSH
24392: LD_INT 110
24394: PUSH
24395: LD_INT 120
24397: PUSH
24398: LD_INT 130
24400: PUSH
24401: LD_INT 140
24403: PUSH
24404: LD_INT 150
24406: PUSH
24407: EMPTY
24408: LIST
24409: LIST
24410: LIST
24411: LIST
24412: LIST
24413: LIST
24414: LIST
24415: LIST
24416: LIST
24417: LIST
24418: LIST
24419: LIST
24420: LIST
24421: LIST
24422: LIST
24423: PUSH
24424: LD_INT 1
24426: PPUSH
24427: LD_INT 15
24429: PPUSH
24430: CALL_OW 12
24434: ARRAY
24435: ST_TO_ADDR
// if ValidHex ( x , y ) then
24436: LD_VAR 0 3
24440: PPUSH
24441: LD_VAR 0 4
24445: PPUSH
24446: CALL_OW 488
24450: IFFALSE 24473
// begin result := [ x , y ] ;
24452: LD_ADDR_VAR 0 1
24456: PUSH
24457: LD_VAR 0 3
24461: PUSH
24462: LD_VAR 0 4
24466: PUSH
24467: EMPTY
24468: LIST
24469: LIST
24470: ST_TO_ADDR
// break ;
24471: GO 24475
// end ; end ;
24473: GO 24275
24475: POP
24476: POP
// if result then
24477: LD_VAR 0 1
24481: IFFALSE 24541
// begin ToLua ( playSibBomb() ) ;
24483: LD_STRING playSibBomb()
24485: PPUSH
24486: CALL_OW 559
// wait ( 0 0$14 ) ;
24490: LD_INT 490
24492: PPUSH
24493: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
24497: LD_VAR 0 1
24501: PUSH
24502: LD_INT 1
24504: ARRAY
24505: PPUSH
24506: LD_VAR 0 1
24510: PUSH
24511: LD_INT 2
24513: ARRAY
24514: PPUSH
24515: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
24519: LD_VAR 0 1
24523: PUSH
24524: LD_INT 1
24526: ARRAY
24527: PPUSH
24528: LD_VAR 0 1
24532: PUSH
24533: LD_INT 2
24535: ARRAY
24536: PPUSH
24537: CALL_OW 429
// end ; end ;
24541: LD_VAR 0 1
24545: RET
// every 0 0$1 trigger StreamModeActive and sReset do
24546: LD_EXP 46
24550: PUSH
24551: LD_EXP 68
24555: AND
24556: IFFALSE 24568
24558: GO 24560
24560: DISABLE
// YouLost (  ) ;
24561: LD_STRING 
24563: PPUSH
24564: CALL_OW 104
24568: END
// every 0 0$1 trigger StreamModeActive and sFog do
24569: LD_EXP 46
24573: PUSH
24574: LD_EXP 67
24578: AND
24579: IFFALSE 24593
24581: GO 24583
24583: DISABLE
// FogOff ( your_side ) ;
24584: LD_OWVAR 2
24588: PPUSH
24589: CALL_OW 344
24593: END
// every 0 0$1 trigger StreamModeActive and sSun do
24594: LD_EXP 46
24598: PUSH
24599: LD_EXP 69
24603: AND
24604: IFFALSE 24632
24606: GO 24608
24608: DISABLE
// begin solar_recharge_percent := 0 ;
24609: LD_ADDR_OWVAR 79
24613: PUSH
24614: LD_INT 0
24616: ST_TO_ADDR
// wait ( 5 5$00 ) ;
24617: LD_INT 10500
24619: PPUSH
24620: CALL_OW 67
// solar_recharge_percent := 100 ;
24624: LD_ADDR_OWVAR 79
24628: PUSH
24629: LD_INT 100
24631: ST_TO_ADDR
// end ;
24632: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
24633: LD_EXP 46
24637: PUSH
24638: LD_EXP 70
24642: AND
24643: IFFALSE 24882
24645: GO 24647
24647: DISABLE
24648: LD_INT 0
24650: PPUSH
24651: PPUSH
24652: PPUSH
// begin tmp := [ ] ;
24653: LD_ADDR_VAR 0 3
24657: PUSH
24658: EMPTY
24659: ST_TO_ADDR
// for i := 1 to 6 do
24660: LD_ADDR_VAR 0 1
24664: PUSH
24665: DOUBLE
24666: LD_INT 1
24668: DEC
24669: ST_TO_ADDR
24670: LD_INT 6
24672: PUSH
24673: FOR_TO
24674: IFFALSE 24779
// begin uc_nation := nation_nature ;
24676: LD_ADDR_OWVAR 21
24680: PUSH
24681: LD_INT 0
24683: ST_TO_ADDR
// uc_side := 0 ;
24684: LD_ADDR_OWVAR 20
24688: PUSH
24689: LD_INT 0
24691: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24692: LD_ADDR_OWVAR 29
24696: PUSH
24697: LD_INT 12
24699: PUSH
24700: LD_INT 12
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: ST_TO_ADDR
// hc_agressivity := 20 ;
24707: LD_ADDR_OWVAR 35
24711: PUSH
24712: LD_INT 20
24714: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
24715: LD_ADDR_OWVAR 28
24719: PUSH
24720: LD_INT 17
24722: ST_TO_ADDR
// hc_gallery :=  ;
24723: LD_ADDR_OWVAR 33
24727: PUSH
24728: LD_STRING 
24730: ST_TO_ADDR
// hc_name :=  ;
24731: LD_ADDR_OWVAR 26
24735: PUSH
24736: LD_STRING 
24738: ST_TO_ADDR
// un := CreateHuman ;
24739: LD_ADDR_VAR 0 2
24743: PUSH
24744: CALL_OW 44
24748: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
24749: LD_VAR 0 2
24753: PPUSH
24754: LD_INT 1
24756: PPUSH
24757: CALL_OW 51
// tmp := tmp ^ un ;
24761: LD_ADDR_VAR 0 3
24765: PUSH
24766: LD_VAR 0 3
24770: PUSH
24771: LD_VAR 0 2
24775: ADD
24776: ST_TO_ADDR
// end ;
24777: GO 24673
24779: POP
24780: POP
// repeat wait ( 0 0$1 ) ;
24781: LD_INT 35
24783: PPUSH
24784: CALL_OW 67
// for un in tmp do
24788: LD_ADDR_VAR 0 2
24792: PUSH
24793: LD_VAR 0 3
24797: PUSH
24798: FOR_IN
24799: IFFALSE 24873
// begin if IsDead ( un ) then
24801: LD_VAR 0 2
24805: PPUSH
24806: CALL_OW 301
24810: IFFALSE 24830
// begin tmp := tmp diff un ;
24812: LD_ADDR_VAR 0 3
24816: PUSH
24817: LD_VAR 0 3
24821: PUSH
24822: LD_VAR 0 2
24826: DIFF
24827: ST_TO_ADDR
// continue ;
24828: GO 24798
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
24830: LD_VAR 0 2
24834: PPUSH
24835: LD_INT 3
24837: PUSH
24838: LD_INT 22
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PUSH
24848: EMPTY
24849: LIST
24850: LIST
24851: PPUSH
24852: CALL_OW 69
24856: PPUSH
24857: LD_VAR 0 2
24861: PPUSH
24862: CALL_OW 74
24866: PPUSH
24867: CALL_OW 115
// end ;
24871: GO 24798
24873: POP
24874: POP
// until not tmp ;
24875: LD_VAR 0 3
24879: NOT
24880: IFFALSE 24781
// end ;
24882: PPOPN 3
24884: END
// every 0 0$1 trigger StreamModeActive and sTroll do
24885: LD_EXP 46
24889: PUSH
24890: LD_EXP 71
24894: AND
24895: IFFALSE 24949
24897: GO 24899
24899: DISABLE
// begin ToLua ( displayTroll(); ) ;
24900: LD_STRING displayTroll();
24902: PPUSH
24903: CALL_OW 559
// wait ( 3 3$00 ) ;
24907: LD_INT 6300
24909: PPUSH
24910: CALL_OW 67
// ToLua ( hideTroll(); ) ;
24914: LD_STRING hideTroll();
24916: PPUSH
24917: CALL_OW 559
// wait ( 1 1$00 ) ;
24921: LD_INT 2100
24923: PPUSH
24924: CALL_OW 67
// ToLua ( displayTroll(); ) ;
24928: LD_STRING displayTroll();
24930: PPUSH
24931: CALL_OW 559
// wait ( 1 1$00 ) ;
24935: LD_INT 2100
24937: PPUSH
24938: CALL_OW 67
// ToLua ( hideTroll(); ) ;
24942: LD_STRING hideTroll();
24944: PPUSH
24945: CALL_OW 559
// end ;
24949: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
24950: LD_EXP 46
24954: PUSH
24955: LD_EXP 72
24959: AND
24960: IFFALSE 25023
24962: GO 24964
24964: DISABLE
24965: LD_INT 0
24967: PPUSH
// begin p := 0 ;
24968: LD_ADDR_VAR 0 1
24972: PUSH
24973: LD_INT 0
24975: ST_TO_ADDR
// repeat game_speed := 1 ;
24976: LD_ADDR_OWVAR 65
24980: PUSH
24981: LD_INT 1
24983: ST_TO_ADDR
// wait ( 0 0$1 ) ;
24984: LD_INT 35
24986: PPUSH
24987: CALL_OW 67
// p := p + 1 ;
24991: LD_ADDR_VAR 0 1
24995: PUSH
24996: LD_VAR 0 1
25000: PUSH
25001: LD_INT 1
25003: PLUS
25004: ST_TO_ADDR
// until p >= 60 ;
25005: LD_VAR 0 1
25009: PUSH
25010: LD_INT 60
25012: GREATEREQUAL
25013: IFFALSE 24976
// game_speed := 4 ;
25015: LD_ADDR_OWVAR 65
25019: PUSH
25020: LD_INT 4
25022: ST_TO_ADDR
// end ;
25023: PPOPN 1
25025: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25026: LD_EXP 46
25030: PUSH
25031: LD_EXP 73
25035: AND
25036: IFFALSE 25182
25038: GO 25040
25040: DISABLE
25041: LD_INT 0
25043: PPUSH
25044: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25045: LD_ADDR_VAR 0 1
25049: PUSH
25050: LD_INT 22
25052: PUSH
25053: LD_OWVAR 2
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: PUSH
25062: LD_INT 2
25064: PUSH
25065: LD_INT 30
25067: PUSH
25068: LD_INT 0
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PUSH
25075: LD_INT 30
25077: PUSH
25078: LD_INT 1
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: LIST
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PPUSH
25094: CALL_OW 69
25098: ST_TO_ADDR
// if not depot then
25099: LD_VAR 0 1
25103: NOT
25104: IFFALSE 25108
// exit ;
25106: GO 25182
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25108: LD_ADDR_VAR 0 2
25112: PUSH
25113: LD_VAR 0 1
25117: PUSH
25118: LD_INT 1
25120: PPUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL_OW 12
25130: ARRAY
25131: PPUSH
25132: CALL_OW 274
25136: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25137: LD_VAR 0 2
25141: PPUSH
25142: LD_INT 1
25144: PPUSH
25145: LD_INT 0
25147: PPUSH
25148: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25152: LD_VAR 0 2
25156: PPUSH
25157: LD_INT 2
25159: PPUSH
25160: LD_INT 0
25162: PPUSH
25163: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25167: LD_VAR 0 2
25171: PPUSH
25172: LD_INT 3
25174: PPUSH
25175: LD_INT 0
25177: PPUSH
25178: CALL_OW 277
// end ;
25182: PPOPN 2
25184: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
25185: LD_EXP 46
25189: PUSH
25190: LD_EXP 74
25194: AND
25195: IFFALSE 25292
25197: GO 25199
25199: DISABLE
25200: LD_INT 0
25202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25203: LD_ADDR_VAR 0 1
25207: PUSH
25208: LD_INT 22
25210: PUSH
25211: LD_OWVAR 2
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: PUSH
25220: LD_INT 21
25222: PUSH
25223: LD_INT 1
25225: PUSH
25226: EMPTY
25227: LIST
25228: LIST
25229: PUSH
25230: LD_INT 3
25232: PUSH
25233: LD_INT 23
25235: PUSH
25236: LD_INT 0
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: LIST
25251: PPUSH
25252: CALL_OW 69
25256: ST_TO_ADDR
// if not tmp then
25257: LD_VAR 0 1
25261: NOT
25262: IFFALSE 25266
// exit ;
25264: GO 25292
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
25266: LD_VAR 0 1
25270: PUSH
25271: LD_INT 1
25273: PPUSH
25274: LD_VAR 0 1
25278: PPUSH
25279: CALL_OW 12
25283: ARRAY
25284: PPUSH
25285: LD_INT 200
25287: PPUSH
25288: CALL_OW 234
// end ;
25292: PPOPN 1
25294: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
25295: LD_EXP 46
25299: PUSH
25300: LD_EXP 75
25304: AND
25305: IFFALSE 25384
25307: GO 25309
25309: DISABLE
25310: LD_INT 0
25312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
25313: LD_ADDR_VAR 0 1
25317: PUSH
25318: LD_INT 22
25320: PUSH
25321: LD_OWVAR 2
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 21
25332: PUSH
25333: LD_INT 2
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: PPUSH
25344: CALL_OW 69
25348: ST_TO_ADDR
// if not tmp then
25349: LD_VAR 0 1
25353: NOT
25354: IFFALSE 25358
// exit ;
25356: GO 25384
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
25358: LD_VAR 0 1
25362: PUSH
25363: LD_INT 1
25365: PPUSH
25366: LD_VAR 0 1
25370: PPUSH
25371: CALL_OW 12
25375: ARRAY
25376: PPUSH
25377: LD_INT 60
25379: PPUSH
25380: CALL_OW 234
// end ;
25384: PPOPN 1
25386: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
25387: LD_EXP 46
25391: PUSH
25392: LD_EXP 76
25396: AND
25397: IFFALSE 25496
25399: GO 25401
25401: DISABLE
25402: LD_INT 0
25404: PPUSH
25405: PPUSH
// begin enable ;
25406: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
25407: LD_ADDR_VAR 0 1
25411: PUSH
25412: LD_INT 22
25414: PUSH
25415: LD_OWVAR 2
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 61
25426: PUSH
25427: EMPTY
25428: LIST
25429: PUSH
25430: LD_INT 33
25432: PUSH
25433: LD_INT 2
25435: PUSH
25436: EMPTY
25437: LIST
25438: LIST
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: LIST
25444: PPUSH
25445: CALL_OW 69
25449: ST_TO_ADDR
// if not tmp then
25450: LD_VAR 0 1
25454: NOT
25455: IFFALSE 25459
// exit ;
25457: GO 25496
// for i in tmp do
25459: LD_ADDR_VAR 0 2
25463: PUSH
25464: LD_VAR 0 1
25468: PUSH
25469: FOR_IN
25470: IFFALSE 25494
// if IsControledBy ( i ) then
25472: LD_VAR 0 2
25476: PPUSH
25477: CALL_OW 312
25481: IFFALSE 25492
// ComUnlink ( i ) ;
25483: LD_VAR 0 2
25487: PPUSH
25488: CALL_OW 136
25492: GO 25469
25494: POP
25495: POP
// end ;
25496: PPOPN 2
25498: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
25499: LD_EXP 46
25503: PUSH
25504: LD_EXP 77
25508: AND
25509: IFFALSE 25649
25511: GO 25513
25513: DISABLE
25514: LD_INT 0
25516: PPUSH
25517: PPUSH
// begin ToLua ( displayPowell(); ) ;
25518: LD_STRING displayPowell();
25520: PPUSH
25521: CALL_OW 559
// uc_side := 0 ;
25525: LD_ADDR_OWVAR 20
25529: PUSH
25530: LD_INT 0
25532: ST_TO_ADDR
// uc_nation := 2 ;
25533: LD_ADDR_OWVAR 21
25537: PUSH
25538: LD_INT 2
25540: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
25541: LD_ADDR_OWVAR 37
25545: PUSH
25546: LD_INT 14
25548: ST_TO_ADDR
// vc_engine := engine_siberite ;
25549: LD_ADDR_OWVAR 39
25553: PUSH
25554: LD_INT 3
25556: ST_TO_ADDR
// vc_control := control_apeman ;
25557: LD_ADDR_OWVAR 38
25561: PUSH
25562: LD_INT 5
25564: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
25565: LD_ADDR_OWVAR 40
25569: PUSH
25570: LD_INT 29
25572: ST_TO_ADDR
// un := CreateVehicle ;
25573: LD_ADDR_VAR 0 2
25577: PUSH
25578: CALL_OW 45
25582: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
25583: LD_VAR 0 2
25587: PPUSH
25588: LD_INT 1
25590: PPUSH
25591: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
25595: LD_INT 35
25597: PPUSH
25598: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
25602: LD_VAR 0 2
25606: PPUSH
25607: LD_INT 22
25609: PUSH
25610: LD_OWVAR 2
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PPUSH
25619: CALL_OW 69
25623: PPUSH
25624: LD_VAR 0 2
25628: PPUSH
25629: CALL_OW 74
25633: PPUSH
25634: CALL_OW 115
// until IsDead ( un ) ;
25638: LD_VAR 0 2
25642: PPUSH
25643: CALL_OW 301
25647: IFFALSE 25595
// end ;
25649: PPOPN 2
25651: END
// every 0 0$1 trigger StreamModeActive and sStu do
25652: LD_EXP 46
25656: PUSH
25657: LD_EXP 85
25661: AND
25662: IFFALSE 25678
25664: GO 25666
25666: DISABLE
// begin ToLua ( displayStucuk(); ) ;
25667: LD_STRING displayStucuk();
25669: PPUSH
25670: CALL_OW 559
// ResetFog ;
25674: CALL_OW 335
// end ;
25678: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
25679: LD_EXP 46
25683: PUSH
25684: LD_EXP 78
25688: AND
25689: IFFALSE 25830
25691: GO 25693
25693: DISABLE
25694: LD_INT 0
25696: PPUSH
25697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25698: LD_ADDR_VAR 0 2
25702: PUSH
25703: LD_INT 22
25705: PUSH
25706: LD_OWVAR 2
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: LD_INT 21
25717: PUSH
25718: LD_INT 1
25720: PUSH
25721: EMPTY
25722: LIST
25723: LIST
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PPUSH
25729: CALL_OW 69
25733: ST_TO_ADDR
// if not tmp then
25734: LD_VAR 0 2
25738: NOT
25739: IFFALSE 25743
// exit ;
25741: GO 25830
// un := tmp [ rand ( 1 , tmp ) ] ;
25743: LD_ADDR_VAR 0 1
25747: PUSH
25748: LD_VAR 0 2
25752: PUSH
25753: LD_INT 1
25755: PPUSH
25756: LD_VAR 0 2
25760: PPUSH
25761: CALL_OW 12
25765: ARRAY
25766: ST_TO_ADDR
// SetSide ( un , 0 ) ;
25767: LD_VAR 0 1
25771: PPUSH
25772: LD_INT 0
25774: PPUSH
25775: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
25779: LD_VAR 0 1
25783: PPUSH
25784: LD_OWVAR 3
25788: PUSH
25789: LD_VAR 0 1
25793: DIFF
25794: PPUSH
25795: LD_VAR 0 1
25799: PPUSH
25800: CALL_OW 74
25804: PPUSH
25805: CALL_OW 115
// wait ( 0 0$20 ) ;
25809: LD_INT 700
25811: PPUSH
25812: CALL_OW 67
// SetSide ( un , your_side ) ;
25816: LD_VAR 0 1
25820: PPUSH
25821: LD_OWVAR 2
25825: PPUSH
25826: CALL_OW 235
// end ;
25830: PPOPN 2
25832: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
25833: LD_EXP 46
25837: PUSH
25838: LD_EXP 79
25842: AND
25843: IFFALSE 25949
25845: GO 25847
25847: DISABLE
25848: LD_INT 0
25850: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25851: LD_ADDR_VAR 0 1
25855: PUSH
25856: LD_INT 22
25858: PUSH
25859: LD_OWVAR 2
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PUSH
25868: LD_INT 2
25870: PUSH
25871: LD_INT 30
25873: PUSH
25874: LD_INT 0
25876: PUSH
25877: EMPTY
25878: LIST
25879: LIST
25880: PUSH
25881: LD_INT 30
25883: PUSH
25884: LD_INT 1
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: LIST
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PPUSH
25900: CALL_OW 69
25904: ST_TO_ADDR
// if not depot then
25905: LD_VAR 0 1
25909: NOT
25910: IFFALSE 25914
// exit ;
25912: GO 25949
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
25914: LD_VAR 0 1
25918: PUSH
25919: LD_INT 1
25921: ARRAY
25922: PPUSH
25923: CALL_OW 250
25927: PPUSH
25928: LD_VAR 0 1
25932: PUSH
25933: LD_INT 1
25935: ARRAY
25936: PPUSH
25937: CALL_OW 251
25941: PPUSH
25942: LD_INT 70
25944: PPUSH
25945: CALL_OW 495
// end ;
25949: PPOPN 1
25951: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
25952: LD_EXP 46
25956: PUSH
25957: LD_EXP 80
25961: AND
25962: IFFALSE 26173
25964: GO 25966
25966: DISABLE
25967: LD_INT 0
25969: PPUSH
25970: PPUSH
25971: PPUSH
25972: PPUSH
25973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25974: LD_ADDR_VAR 0 5
25978: PUSH
25979: LD_INT 22
25981: PUSH
25982: LD_OWVAR 2
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PUSH
25991: LD_INT 21
25993: PUSH
25994: LD_INT 1
25996: PUSH
25997: EMPTY
25998: LIST
25999: LIST
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PPUSH
26005: CALL_OW 69
26009: ST_TO_ADDR
// if not tmp then
26010: LD_VAR 0 5
26014: NOT
26015: IFFALSE 26019
// exit ;
26017: GO 26173
// for i in tmp do
26019: LD_ADDR_VAR 0 1
26023: PUSH
26024: LD_VAR 0 5
26028: PUSH
26029: FOR_IN
26030: IFFALSE 26171
// begin d := rand ( 0 , 5 ) ;
26032: LD_ADDR_VAR 0 4
26036: PUSH
26037: LD_INT 0
26039: PPUSH
26040: LD_INT 5
26042: PPUSH
26043: CALL_OW 12
26047: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26048: LD_ADDR_VAR 0 2
26052: PUSH
26053: LD_VAR 0 1
26057: PPUSH
26058: CALL_OW 250
26062: PPUSH
26063: LD_VAR 0 4
26067: PPUSH
26068: LD_INT 3
26070: PPUSH
26071: LD_INT 12
26073: PPUSH
26074: CALL_OW 12
26078: PPUSH
26079: CALL_OW 272
26083: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26084: LD_ADDR_VAR 0 3
26088: PUSH
26089: LD_VAR 0 1
26093: PPUSH
26094: CALL_OW 251
26098: PPUSH
26099: LD_VAR 0 4
26103: PPUSH
26104: LD_INT 3
26106: PPUSH
26107: LD_INT 12
26109: PPUSH
26110: CALL_OW 12
26114: PPUSH
26115: CALL_OW 273
26119: ST_TO_ADDR
// if ValidHex ( x , y ) then
26120: LD_VAR 0 2
26124: PPUSH
26125: LD_VAR 0 3
26129: PPUSH
26130: CALL_OW 488
26134: IFFALSE 26169
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26136: LD_VAR 0 1
26140: PPUSH
26141: LD_VAR 0 2
26145: PPUSH
26146: LD_VAR 0 3
26150: PPUSH
26151: LD_INT 3
26153: PPUSH
26154: LD_INT 6
26156: PPUSH
26157: CALL_OW 12
26161: PPUSH
26162: LD_INT 1
26164: PPUSH
26165: CALL_OW 483
// end ;
26169: GO 26029
26171: POP
26172: POP
// end ;
26173: PPOPN 5
26175: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26176: LD_EXP 46
26180: PUSH
26181: LD_EXP 81
26185: AND
26186: IFFALSE 26280
26188: GO 26190
26190: DISABLE
26191: LD_INT 0
26193: PPUSH
26194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
26195: LD_ADDR_VAR 0 2
26199: PUSH
26200: LD_INT 22
26202: PUSH
26203: LD_OWVAR 2
26207: PUSH
26208: EMPTY
26209: LIST
26210: LIST
26211: PUSH
26212: LD_INT 32
26214: PUSH
26215: LD_INT 1
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 21
26224: PUSH
26225: LD_INT 2
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: LIST
26236: PPUSH
26237: CALL_OW 69
26241: ST_TO_ADDR
// if not tmp then
26242: LD_VAR 0 2
26246: NOT
26247: IFFALSE 26251
// exit ;
26249: GO 26280
// for i in tmp do
26251: LD_ADDR_VAR 0 1
26255: PUSH
26256: LD_VAR 0 2
26260: PUSH
26261: FOR_IN
26262: IFFALSE 26278
// SetFuel ( i , 0 ) ;
26264: LD_VAR 0 1
26268: PPUSH
26269: LD_INT 0
26271: PPUSH
26272: CALL_OW 240
26276: GO 26261
26278: POP
26279: POP
// end ;
26280: PPOPN 2
26282: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
26283: LD_EXP 46
26287: PUSH
26288: LD_EXP 82
26292: AND
26293: IFFALSE 26359
26295: GO 26297
26297: DISABLE
26298: LD_INT 0
26300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
26301: LD_ADDR_VAR 0 1
26305: PUSH
26306: LD_INT 22
26308: PUSH
26309: LD_OWVAR 2
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PUSH
26318: LD_INT 30
26320: PUSH
26321: LD_INT 29
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PPUSH
26332: CALL_OW 69
26336: ST_TO_ADDR
// if not tmp then
26337: LD_VAR 0 1
26341: NOT
26342: IFFALSE 26346
// exit ;
26344: GO 26359
// DestroyUnit ( tmp [ 1 ] ) ;
26346: LD_VAR 0 1
26350: PUSH
26351: LD_INT 1
26353: ARRAY
26354: PPUSH
26355: CALL_OW 65
// end ;
26359: PPOPN 1
26361: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
26362: LD_EXP 46
26366: PUSH
26367: LD_EXP 84
26371: AND
26372: IFFALSE 26501
26374: GO 26376
26376: DISABLE
26377: LD_INT 0
26379: PPUSH
// begin uc_side := 0 ;
26380: LD_ADDR_OWVAR 20
26384: PUSH
26385: LD_INT 0
26387: ST_TO_ADDR
// uc_nation := nation_arabian ;
26388: LD_ADDR_OWVAR 21
26392: PUSH
26393: LD_INT 2
26395: ST_TO_ADDR
// hc_gallery :=  ;
26396: LD_ADDR_OWVAR 33
26400: PUSH
26401: LD_STRING 
26403: ST_TO_ADDR
// hc_name :=  ;
26404: LD_ADDR_OWVAR 26
26408: PUSH
26409: LD_STRING 
26411: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
26412: LD_INT 1
26414: PPUSH
26415: LD_INT 11
26417: PPUSH
26418: LD_INT 10
26420: PPUSH
26421: CALL_OW 380
// un := CreateHuman ;
26425: LD_ADDR_VAR 0 1
26429: PUSH
26430: CALL_OW 44
26434: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26435: LD_VAR 0 1
26439: PPUSH
26440: LD_INT 1
26442: PPUSH
26443: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26447: LD_INT 35
26449: PPUSH
26450: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26454: LD_VAR 0 1
26458: PPUSH
26459: LD_INT 22
26461: PUSH
26462: LD_OWVAR 2
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PPUSH
26471: CALL_OW 69
26475: PPUSH
26476: LD_VAR 0 1
26480: PPUSH
26481: CALL_OW 74
26485: PPUSH
26486: CALL_OW 115
// until IsDead ( un ) ;
26490: LD_VAR 0 1
26494: PPUSH
26495: CALL_OW 301
26499: IFFALSE 26447
// end ;
26501: PPOPN 1
26503: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
26504: LD_EXP 46
26508: PUSH
26509: LD_EXP 86
26513: AND
26514: IFFALSE 26526
26516: GO 26518
26518: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
26519: LD_STRING earthquake(getX(game), 0, 32)
26521: PPUSH
26522: CALL_OW 559
26526: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
26527: LD_EXP 46
26531: PUSH
26532: LD_EXP 87
26536: AND
26537: IFFALSE 26628
26539: GO 26541
26541: DISABLE
26542: LD_INT 0
26544: PPUSH
// begin enable ;
26545: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
26546: LD_ADDR_VAR 0 1
26550: PUSH
26551: LD_INT 22
26553: PUSH
26554: LD_OWVAR 2
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 21
26565: PUSH
26566: LD_INT 2
26568: PUSH
26569: EMPTY
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 33
26575: PUSH
26576: LD_INT 3
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: LIST
26587: PPUSH
26588: CALL_OW 69
26592: ST_TO_ADDR
// if not tmp then
26593: LD_VAR 0 1
26597: NOT
26598: IFFALSE 26602
// exit ;
26600: GO 26628
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
26602: LD_VAR 0 1
26606: PUSH
26607: LD_INT 1
26609: PPUSH
26610: LD_VAR 0 1
26614: PPUSH
26615: CALL_OW 12
26619: ARRAY
26620: PPUSH
26621: LD_INT 1
26623: PPUSH
26624: CALL_OW 234
// end ;
26628: PPOPN 1
26630: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
26631: LD_EXP 46
26635: PUSH
26636: LD_EXP 88
26640: AND
26641: IFFALSE 26782
26643: GO 26645
26645: DISABLE
26646: LD_INT 0
26648: PPUSH
26649: PPUSH
26650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26651: LD_ADDR_VAR 0 3
26655: PUSH
26656: LD_INT 22
26658: PUSH
26659: LD_OWVAR 2
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: LD_INT 25
26670: PUSH
26671: LD_INT 1
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: PPUSH
26682: CALL_OW 69
26686: ST_TO_ADDR
// if not tmp then
26687: LD_VAR 0 3
26691: NOT
26692: IFFALSE 26696
// exit ;
26694: GO 26782
// un := tmp [ rand ( 1 , tmp ) ] ;
26696: LD_ADDR_VAR 0 2
26700: PUSH
26701: LD_VAR 0 3
26705: PUSH
26706: LD_INT 1
26708: PPUSH
26709: LD_VAR 0 3
26713: PPUSH
26714: CALL_OW 12
26718: ARRAY
26719: ST_TO_ADDR
// if Crawls ( un ) then
26720: LD_VAR 0 2
26724: PPUSH
26725: CALL_OW 318
26729: IFFALSE 26740
// ComWalk ( un ) ;
26731: LD_VAR 0 2
26735: PPUSH
26736: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
26740: LD_VAR 0 2
26744: PPUSH
26745: LD_INT 9
26747: PPUSH
26748: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
26752: LD_INT 28
26754: PPUSH
26755: LD_OWVAR 2
26759: PPUSH
26760: LD_INT 2
26762: PPUSH
26763: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
26767: LD_INT 29
26769: PPUSH
26770: LD_OWVAR 2
26774: PPUSH
26775: LD_INT 2
26777: PPUSH
26778: CALL_OW 322
// end ;
26782: PPOPN 3
26784: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
26785: LD_EXP 46
26789: PUSH
26790: LD_EXP 89
26794: AND
26795: IFFALSE 26906
26797: GO 26799
26799: DISABLE
26800: LD_INT 0
26802: PPUSH
26803: PPUSH
26804: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26805: LD_ADDR_VAR 0 3
26809: PUSH
26810: LD_INT 22
26812: PUSH
26813: LD_OWVAR 2
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PUSH
26822: LD_INT 25
26824: PUSH
26825: LD_INT 1
26827: PUSH
26828: EMPTY
26829: LIST
26830: LIST
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PPUSH
26836: CALL_OW 69
26840: ST_TO_ADDR
// if not tmp then
26841: LD_VAR 0 3
26845: NOT
26846: IFFALSE 26850
// exit ;
26848: GO 26906
// un := tmp [ rand ( 1 , tmp ) ] ;
26850: LD_ADDR_VAR 0 2
26854: PUSH
26855: LD_VAR 0 3
26859: PUSH
26860: LD_INT 1
26862: PPUSH
26863: LD_VAR 0 3
26867: PPUSH
26868: CALL_OW 12
26872: ARRAY
26873: ST_TO_ADDR
// if Crawls ( un ) then
26874: LD_VAR 0 2
26878: PPUSH
26879: CALL_OW 318
26883: IFFALSE 26894
// ComWalk ( un ) ;
26885: LD_VAR 0 2
26889: PPUSH
26890: CALL_OW 138
// SetClass ( un , class_mortar ) ;
26894: LD_VAR 0 2
26898: PPUSH
26899: LD_INT 8
26901: PPUSH
26902: CALL_OW 336
// end ;
26906: PPOPN 3
26908: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
26909: LD_EXP 46
26913: PUSH
26914: LD_EXP 90
26918: AND
26919: IFFALSE 27063
26921: GO 26923
26923: DISABLE
26924: LD_INT 0
26926: PPUSH
26927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
26928: LD_ADDR_VAR 0 2
26932: PUSH
26933: LD_INT 22
26935: PUSH
26936: LD_OWVAR 2
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PUSH
26945: LD_INT 21
26947: PUSH
26948: LD_INT 2
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: PUSH
26955: LD_INT 2
26957: PUSH
26958: LD_INT 34
26960: PUSH
26961: LD_INT 12
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 34
26970: PUSH
26971: LD_INT 51
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: LD_INT 34
26980: PUSH
26981: LD_INT 32
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: LIST
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: LIST
26998: PPUSH
26999: CALL_OW 69
27003: ST_TO_ADDR
// if not tmp then
27004: LD_VAR 0 2
27008: NOT
27009: IFFALSE 27013
// exit ;
27011: GO 27063
// for i in tmp do
27013: LD_ADDR_VAR 0 1
27017: PUSH
27018: LD_VAR 0 2
27022: PUSH
27023: FOR_IN
27024: IFFALSE 27061
// if GetCargo ( i , mat_artifact ) = 0 then
27026: LD_VAR 0 1
27030: PPUSH
27031: LD_INT 4
27033: PPUSH
27034: CALL_OW 289
27038: PUSH
27039: LD_INT 0
27041: EQUAL
27042: IFFALSE 27059
// SetCargo ( i , mat_siberit , 100 ) ;
27044: LD_VAR 0 1
27048: PPUSH
27049: LD_INT 3
27051: PPUSH
27052: LD_INT 100
27054: PPUSH
27055: CALL_OW 290
27059: GO 27023
27061: POP
27062: POP
// end ;
27063: PPOPN 2
27065: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27066: LD_EXP 46
27070: PUSH
27071: LD_EXP 91
27075: AND
27076: IFFALSE 27229
27078: GO 27080
27080: DISABLE
27081: LD_INT 0
27083: PPUSH
27084: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27085: LD_ADDR_VAR 0 2
27089: PUSH
27090: LD_INT 22
27092: PUSH
27093: LD_OWVAR 2
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PPUSH
27102: CALL_OW 69
27106: ST_TO_ADDR
// if not tmp then
27107: LD_VAR 0 2
27111: NOT
27112: IFFALSE 27116
// exit ;
27114: GO 27229
// for i := 1 to 2 do
27116: LD_ADDR_VAR 0 1
27120: PUSH
27121: DOUBLE
27122: LD_INT 1
27124: DEC
27125: ST_TO_ADDR
27126: LD_INT 2
27128: PUSH
27129: FOR_TO
27130: IFFALSE 27227
// begin uc_side := your_side ;
27132: LD_ADDR_OWVAR 20
27136: PUSH
27137: LD_OWVAR 2
27141: ST_TO_ADDR
// uc_nation := nation_american ;
27142: LD_ADDR_OWVAR 21
27146: PUSH
27147: LD_INT 1
27149: ST_TO_ADDR
// vc_chassis := us_morphling ;
27150: LD_ADDR_OWVAR 37
27154: PUSH
27155: LD_INT 5
27157: ST_TO_ADDR
// vc_engine := engine_siberite ;
27158: LD_ADDR_OWVAR 39
27162: PUSH
27163: LD_INT 3
27165: ST_TO_ADDR
// vc_control := control_computer ;
27166: LD_ADDR_OWVAR 38
27170: PUSH
27171: LD_INT 3
27173: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27174: LD_ADDR_OWVAR 40
27178: PUSH
27179: LD_INT 10
27181: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
27182: CALL_OW 45
27186: PPUSH
27187: LD_VAR 0 2
27191: PUSH
27192: LD_INT 1
27194: ARRAY
27195: PPUSH
27196: CALL_OW 250
27200: PPUSH
27201: LD_VAR 0 2
27205: PUSH
27206: LD_INT 1
27208: ARRAY
27209: PPUSH
27210: CALL_OW 251
27214: PPUSH
27215: LD_INT 12
27217: PPUSH
27218: LD_INT 1
27220: PPUSH
27221: CALL_OW 50
// end ;
27225: GO 27129
27227: POP
27228: POP
// end ;
27229: PPOPN 2
27231: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
27232: LD_EXP 46
27236: PUSH
27237: LD_EXP 92
27241: AND
27242: IFFALSE 27464
27244: GO 27246
27246: DISABLE
27247: LD_INT 0
27249: PPUSH
27250: PPUSH
27251: PPUSH
27252: PPUSH
27253: PPUSH
27254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27255: LD_ADDR_VAR 0 6
27259: PUSH
27260: LD_INT 22
27262: PUSH
27263: LD_OWVAR 2
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 21
27274: PUSH
27275: LD_INT 1
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 3
27284: PUSH
27285: LD_INT 23
27287: PUSH
27288: LD_INT 0
27290: PUSH
27291: EMPTY
27292: LIST
27293: LIST
27294: PUSH
27295: EMPTY
27296: LIST
27297: LIST
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: LIST
27303: PPUSH
27304: CALL_OW 69
27308: ST_TO_ADDR
// if not tmp then
27309: LD_VAR 0 6
27313: NOT
27314: IFFALSE 27318
// exit ;
27316: GO 27464
// s1 := rand ( 1 , 4 ) ;
27318: LD_ADDR_VAR 0 2
27322: PUSH
27323: LD_INT 1
27325: PPUSH
27326: LD_INT 4
27328: PPUSH
27329: CALL_OW 12
27333: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
27334: LD_ADDR_VAR 0 4
27338: PUSH
27339: LD_VAR 0 6
27343: PUSH
27344: LD_INT 1
27346: ARRAY
27347: PPUSH
27348: LD_VAR 0 2
27352: PPUSH
27353: CALL_OW 259
27357: ST_TO_ADDR
// if s1 = 1 then
27358: LD_VAR 0 2
27362: PUSH
27363: LD_INT 1
27365: EQUAL
27366: IFFALSE 27386
// s2 := rand ( 2 , 4 ) else
27368: LD_ADDR_VAR 0 3
27372: PUSH
27373: LD_INT 2
27375: PPUSH
27376: LD_INT 4
27378: PPUSH
27379: CALL_OW 12
27383: ST_TO_ADDR
27384: GO 27394
// s2 := 1 ;
27386: LD_ADDR_VAR 0 3
27390: PUSH
27391: LD_INT 1
27393: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
27394: LD_ADDR_VAR 0 5
27398: PUSH
27399: LD_VAR 0 6
27403: PUSH
27404: LD_INT 1
27406: ARRAY
27407: PPUSH
27408: LD_VAR 0 3
27412: PPUSH
27413: CALL_OW 259
27417: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
27418: LD_VAR 0 6
27422: PUSH
27423: LD_INT 1
27425: ARRAY
27426: PPUSH
27427: LD_VAR 0 2
27431: PPUSH
27432: LD_VAR 0 5
27436: PPUSH
27437: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
27441: LD_VAR 0 6
27445: PUSH
27446: LD_INT 1
27448: ARRAY
27449: PPUSH
27450: LD_VAR 0 3
27454: PPUSH
27455: LD_VAR 0 4
27459: PPUSH
27460: CALL_OW 237
// end ;
27464: PPOPN 6
27466: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
27467: LD_EXP 46
27471: PUSH
27472: LD_EXP 93
27476: AND
27477: IFFALSE 27556
27479: GO 27481
27481: DISABLE
27482: LD_INT 0
27484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
27485: LD_ADDR_VAR 0 1
27489: PUSH
27490: LD_INT 22
27492: PUSH
27493: LD_OWVAR 2
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 30
27504: PUSH
27505: LD_INT 3
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PPUSH
27516: CALL_OW 69
27520: ST_TO_ADDR
// if not tmp then
27521: LD_VAR 0 1
27525: NOT
27526: IFFALSE 27530
// exit ;
27528: GO 27556
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27530: LD_VAR 0 1
27534: PUSH
27535: LD_INT 1
27537: PPUSH
27538: LD_VAR 0 1
27542: PPUSH
27543: CALL_OW 12
27547: ARRAY
27548: PPUSH
27549: LD_INT 1
27551: PPUSH
27552: CALL_OW 234
// end ;
27556: PPOPN 1
27558: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
27559: LD_EXP 46
27563: PUSH
27564: LD_EXP 94
27568: AND
27569: IFFALSE 27681
27571: GO 27573
27573: DISABLE
27574: LD_INT 0
27576: PPUSH
27577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
27578: LD_ADDR_VAR 0 2
27582: PUSH
27583: LD_INT 22
27585: PUSH
27586: LD_OWVAR 2
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 2
27597: PUSH
27598: LD_INT 30
27600: PUSH
27601: LD_INT 27
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 30
27610: PUSH
27611: LD_INT 26
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 30
27620: PUSH
27621: LD_INT 28
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: LIST
27632: LIST
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PPUSH
27638: CALL_OW 69
27642: ST_TO_ADDR
// if not tmp then
27643: LD_VAR 0 2
27647: NOT
27648: IFFALSE 27652
// exit ;
27650: GO 27681
// for i in tmp do
27652: LD_ADDR_VAR 0 1
27656: PUSH
27657: LD_VAR 0 2
27661: PUSH
27662: FOR_IN
27663: IFFALSE 27679
// SetLives ( i , 1 ) ;
27665: LD_VAR 0 1
27669: PPUSH
27670: LD_INT 1
27672: PPUSH
27673: CALL_OW 234
27677: GO 27662
27679: POP
27680: POP
// end ;
27681: PPOPN 2
27683: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
27684: LD_EXP 46
27688: PUSH
27689: LD_EXP 95
27693: AND
27694: IFFALSE 27968
27696: GO 27698
27698: DISABLE
27699: LD_INT 0
27701: PPUSH
27702: PPUSH
27703: PPUSH
// begin i := rand ( 1 , 7 ) ;
27704: LD_ADDR_VAR 0 1
27708: PUSH
27709: LD_INT 1
27711: PPUSH
27712: LD_INT 7
27714: PPUSH
27715: CALL_OW 12
27719: ST_TO_ADDR
// case i of 1 :
27720: LD_VAR 0 1
27724: PUSH
27725: LD_INT 1
27727: DOUBLE
27728: EQUAL
27729: IFTRUE 27733
27731: GO 27743
27733: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
27734: LD_STRING earthquake(getX(game), 0, 32)
27736: PPUSH
27737: CALL_OW 559
27741: GO 27968
27743: LD_INT 2
27745: DOUBLE
27746: EQUAL
27747: IFTRUE 27751
27749: GO 27765
27751: POP
// begin ToLua ( displayStucuk(); ) ;
27752: LD_STRING displayStucuk();
27754: PPUSH
27755: CALL_OW 559
// ResetFog ;
27759: CALL_OW 335
// end ; 3 :
27763: GO 27968
27765: LD_INT 3
27767: DOUBLE
27768: EQUAL
27769: IFTRUE 27773
27771: GO 27877
27773: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27774: LD_ADDR_VAR 0 2
27778: PUSH
27779: LD_INT 22
27781: PUSH
27782: LD_OWVAR 2
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PUSH
27791: LD_INT 25
27793: PUSH
27794: LD_INT 1
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PPUSH
27805: CALL_OW 69
27809: ST_TO_ADDR
// if not tmp then
27810: LD_VAR 0 2
27814: NOT
27815: IFFALSE 27819
// exit ;
27817: GO 27968
// un := tmp [ rand ( 1 , tmp ) ] ;
27819: LD_ADDR_VAR 0 3
27823: PUSH
27824: LD_VAR 0 2
27828: PUSH
27829: LD_INT 1
27831: PPUSH
27832: LD_VAR 0 2
27836: PPUSH
27837: CALL_OW 12
27841: ARRAY
27842: ST_TO_ADDR
// if Crawls ( un ) then
27843: LD_VAR 0 3
27847: PPUSH
27848: CALL_OW 318
27852: IFFALSE 27863
// ComWalk ( un ) ;
27854: LD_VAR 0 3
27858: PPUSH
27859: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27863: LD_VAR 0 3
27867: PPUSH
27868: LD_INT 8
27870: PPUSH
27871: CALL_OW 336
// end ; 4 :
27875: GO 27968
27877: LD_INT 4
27879: DOUBLE
27880: EQUAL
27881: IFTRUE 27885
27883: GO 27946
27885: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27886: LD_ADDR_VAR 0 2
27890: PUSH
27891: LD_INT 22
27893: PUSH
27894: LD_OWVAR 2
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: PUSH
27903: LD_INT 30
27905: PUSH
27906: LD_INT 29
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PPUSH
27917: CALL_OW 69
27921: ST_TO_ADDR
// if not tmp then
27922: LD_VAR 0 2
27926: NOT
27927: IFFALSE 27931
// exit ;
27929: GO 27968
// DestroyUnit ( tmp [ 1 ] ) ;
27931: LD_VAR 0 2
27935: PUSH
27936: LD_INT 1
27938: ARRAY
27939: PPUSH
27940: CALL_OW 65
// end ; 5 .. 7 :
27944: GO 27968
27946: LD_INT 5
27948: DOUBLE
27949: GREATEREQUAL
27950: IFFALSE 27958
27952: LD_INT 7
27954: DOUBLE
27955: LESSEQUAL
27956: IFTRUE 27960
27958: GO 27967
27960: POP
// StreamSibBomb ; end ;
27961: CALL 24248 0 0
27965: GO 27968
27967: POP
// end ;
27968: PPOPN 3
27970: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
27971: LD_EXP 46
27975: PUSH
27976: LD_EXP 96
27980: AND
27981: IFFALSE 28137
27983: GO 27985
27985: DISABLE
27986: LD_INT 0
27988: PPUSH
27989: PPUSH
27990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
27991: LD_ADDR_VAR 0 2
27995: PUSH
27996: LD_INT 81
27998: PUSH
27999: LD_OWVAR 2
28003: PUSH
28004: EMPTY
28005: LIST
28006: LIST
28007: PUSH
28008: LD_INT 2
28010: PUSH
28011: LD_INT 21
28013: PUSH
28014: LD_INT 1
28016: PUSH
28017: EMPTY
28018: LIST
28019: LIST
28020: PUSH
28021: LD_INT 21
28023: PUSH
28024: LD_INT 2
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: LIST
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PPUSH
28040: CALL_OW 69
28044: ST_TO_ADDR
// if not tmp then
28045: LD_VAR 0 2
28049: NOT
28050: IFFALSE 28054
// exit ;
28052: GO 28137
// p := 0 ;
28054: LD_ADDR_VAR 0 3
28058: PUSH
28059: LD_INT 0
28061: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28062: LD_INT 35
28064: PPUSH
28065: CALL_OW 67
// p := p + 1 ;
28069: LD_ADDR_VAR 0 3
28073: PUSH
28074: LD_VAR 0 3
28078: PUSH
28079: LD_INT 1
28081: PLUS
28082: ST_TO_ADDR
// for i in tmp do
28083: LD_ADDR_VAR 0 1
28087: PUSH
28088: LD_VAR 0 2
28092: PUSH
28093: FOR_IN
28094: IFFALSE 28125
// if GetLives ( i ) < 1000 then
28096: LD_VAR 0 1
28100: PPUSH
28101: CALL_OW 256
28105: PUSH
28106: LD_INT 1000
28108: LESS
28109: IFFALSE 28123
// SetLives ( i , 1000 ) ;
28111: LD_VAR 0 1
28115: PPUSH
28116: LD_INT 1000
28118: PPUSH
28119: CALL_OW 234
28123: GO 28093
28125: POP
28126: POP
// until p > 20 ;
28127: LD_VAR 0 3
28131: PUSH
28132: LD_INT 20
28134: GREATER
28135: IFFALSE 28062
// end ;
28137: PPOPN 3
28139: END
// every 0 0$1 trigger StreamModeActive and sTime do
28140: LD_EXP 46
28144: PUSH
28145: LD_EXP 97
28149: AND
28150: IFFALSE 28185
28152: GO 28154
28154: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28155: LD_INT 28
28157: PPUSH
28158: LD_OWVAR 2
28162: PPUSH
28163: LD_INT 2
28165: PPUSH
28166: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28170: LD_INT 30
28172: PPUSH
28173: LD_OWVAR 2
28177: PPUSH
28178: LD_INT 2
28180: PPUSH
28181: CALL_OW 322
// end ;
28185: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28186: LD_EXP 46
28190: PUSH
28191: LD_EXP 98
28195: AND
28196: IFFALSE 28317
28198: GO 28200
28200: DISABLE
28201: LD_INT 0
28203: PPUSH
28204: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28205: LD_ADDR_VAR 0 2
28209: PUSH
28210: LD_INT 22
28212: PUSH
28213: LD_OWVAR 2
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 21
28224: PUSH
28225: LD_INT 1
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: LD_INT 3
28234: PUSH
28235: LD_INT 23
28237: PUSH
28238: LD_INT 0
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PUSH
28245: EMPTY
28246: LIST
28247: LIST
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: LIST
28253: PPUSH
28254: CALL_OW 69
28258: ST_TO_ADDR
// if not tmp then
28259: LD_VAR 0 2
28263: NOT
28264: IFFALSE 28268
// exit ;
28266: GO 28317
// for i in tmp do
28268: LD_ADDR_VAR 0 1
28272: PUSH
28273: LD_VAR 0 2
28277: PUSH
28278: FOR_IN
28279: IFFALSE 28315
// begin if Crawls ( i ) then
28281: LD_VAR 0 1
28285: PPUSH
28286: CALL_OW 318
28290: IFFALSE 28301
// ComWalk ( i ) ;
28292: LD_VAR 0 1
28296: PPUSH
28297: CALL_OW 138
// SetClass ( i , 2 ) ;
28301: LD_VAR 0 1
28305: PPUSH
28306: LD_INT 2
28308: PPUSH
28309: CALL_OW 336
// end ;
28313: GO 28278
28315: POP
28316: POP
// end ;
28317: PPOPN 2
28319: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
28320: LD_EXP 46
28324: PUSH
28325: LD_EXP 99
28329: AND
28330: IFFALSE 28551
28332: GO 28334
28334: DISABLE
28335: LD_INT 0
28337: PPUSH
28338: PPUSH
28339: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
28340: LD_OWVAR 2
28344: PPUSH
28345: LD_INT 9
28347: PPUSH
28348: LD_INT 1
28350: PPUSH
28351: LD_INT 1
28353: PPUSH
28354: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
28358: LD_INT 9
28360: PPUSH
28361: LD_OWVAR 2
28365: PPUSH
28366: CALL_OW 343
// uc_side := 9 ;
28370: LD_ADDR_OWVAR 20
28374: PUSH
28375: LD_INT 9
28377: ST_TO_ADDR
// uc_nation := 2 ;
28378: LD_ADDR_OWVAR 21
28382: PUSH
28383: LD_INT 2
28385: ST_TO_ADDR
// hc_name := Dark Warrior ;
28386: LD_ADDR_OWVAR 26
28390: PUSH
28391: LD_STRING Dark Warrior
28393: ST_TO_ADDR
// hc_gallery :=  ;
28394: LD_ADDR_OWVAR 33
28398: PUSH
28399: LD_STRING 
28401: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
28402: LD_INT 1
28404: PPUSH
28405: LD_INT 1
28407: PPUSH
28408: LD_INT 10
28410: PPUSH
28411: CALL_OW 380
// un := CreateHuman ;
28415: LD_ADDR_VAR 0 3
28419: PUSH
28420: CALL_OW 44
28424: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28425: LD_VAR 0 3
28429: PPUSH
28430: LD_INT 1
28432: PPUSH
28433: CALL_OW 51
// p := 0 ;
28437: LD_ADDR_VAR 0 2
28441: PUSH
28442: LD_INT 0
28444: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28445: LD_INT 35
28447: PPUSH
28448: CALL_OW 67
// if GetLives ( un ) < 1000 then
28452: LD_VAR 0 3
28456: PPUSH
28457: CALL_OW 256
28461: PUSH
28462: LD_INT 1000
28464: LESS
28465: IFFALSE 28479
// SetLives ( un , 1000 ) ;
28467: LD_VAR 0 3
28471: PPUSH
28472: LD_INT 1000
28474: PPUSH
28475: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
28479: LD_VAR 0 3
28483: PPUSH
28484: LD_INT 81
28486: PUSH
28487: LD_OWVAR 2
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PPUSH
28496: CALL_OW 69
28500: PPUSH
28501: LD_VAR 0 3
28505: PPUSH
28506: CALL_OW 74
28510: PPUSH
28511: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
28515: LD_VAR 0 2
28519: PUSH
28520: LD_INT 60
28522: GREATER
28523: PUSH
28524: LD_VAR 0 3
28528: PPUSH
28529: CALL_OW 301
28533: OR
28534: IFFALSE 28445
// if un then
28536: LD_VAR 0 3
28540: IFFALSE 28551
// RemoveUnit ( un ) ;
28542: LD_VAR 0 3
28546: PPUSH
28547: CALL_OW 64
// end ; end_of_file
28551: PPOPN 3
28553: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
28554: LD_INT 0
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
28560: LD_VAR 0 1
28564: PPUSH
28565: CALL_OW 264
28569: PUSH
28570: LD_EXP 45
28574: EQUAL
28575: IFFALSE 28647
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
28577: LD_INT 68
28579: PPUSH
28580: LD_VAR 0 1
28584: PPUSH
28585: CALL_OW 255
28589: PPUSH
28590: CALL_OW 321
28594: PUSH
28595: LD_INT 2
28597: EQUAL
28598: IFFALSE 28610
// eff := 70 else
28600: LD_ADDR_VAR 0 6
28604: PUSH
28605: LD_INT 70
28607: ST_TO_ADDR
28608: GO 28618
// eff := 30 ;
28610: LD_ADDR_VAR 0 6
28614: PUSH
28615: LD_INT 30
28617: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
28618: LD_VAR 0 1
28622: PPUSH
28623: CALL_OW 250
28627: PPUSH
28628: LD_VAR 0 1
28632: PPUSH
28633: CALL_OW 251
28637: PPUSH
28638: LD_VAR 0 6
28642: PPUSH
28643: CALL_OW 495
// end ; end ;
28647: LD_VAR 0 4
28651: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
28652: LD_INT 0
28654: PPUSH
28655: PPUSH
28656: PPUSH
28657: PPUSH
28658: PPUSH
28659: PPUSH
// if cmd = 124 then
28660: LD_VAR 0 1
28664: PUSH
28665: LD_INT 124
28667: EQUAL
28668: IFFALSE 28874
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
28670: LD_ADDR_VAR 0 5
28674: PUSH
28675: LD_INT 2
28677: PUSH
28678: LD_INT 34
28680: PUSH
28681: LD_INT 53
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 34
28690: PUSH
28691: LD_INT 14
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: LIST
28702: PPUSH
28703: CALL_OW 69
28707: ST_TO_ADDR
// if not tmp then
28708: LD_VAR 0 5
28712: NOT
28713: IFFALSE 28717
// exit ;
28715: GO 28874
// for i in tmp do
28717: LD_ADDR_VAR 0 3
28721: PUSH
28722: LD_VAR 0 5
28726: PUSH
28727: FOR_IN
28728: IFFALSE 28872
// begin taskList := GetTaskList ( i ) ;
28730: LD_ADDR_VAR 0 6
28734: PUSH
28735: LD_VAR 0 3
28739: PPUSH
28740: CALL_OW 437
28744: ST_TO_ADDR
// if not taskList then
28745: LD_VAR 0 6
28749: NOT
28750: IFFALSE 28754
// continue ;
28752: GO 28727
// for j = 1 to taskList do
28754: LD_ADDR_VAR 0 4
28758: PUSH
28759: DOUBLE
28760: LD_INT 1
28762: DEC
28763: ST_TO_ADDR
28764: LD_VAR 0 6
28768: PUSH
28769: FOR_TO
28770: IFFALSE 28868
// if taskList [ j ] [ 1 ] = | then
28772: LD_VAR 0 6
28776: PUSH
28777: LD_VAR 0 4
28781: ARRAY
28782: PUSH
28783: LD_INT 1
28785: ARRAY
28786: PUSH
28787: LD_STRING |
28789: EQUAL
28790: IFFALSE 28866
// begin _taskList := Delete ( taskList , 1 ) ;
28792: LD_ADDR_VAR 0 7
28796: PUSH
28797: LD_VAR 0 6
28801: PPUSH
28802: LD_INT 1
28804: PPUSH
28805: CALL_OW 3
28809: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
28810: LD_VAR 0 3
28814: PPUSH
28815: LD_VAR 0 7
28819: PPUSH
28820: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
28824: LD_VAR 0 3
28828: PPUSH
28829: LD_VAR 0 6
28833: PUSH
28834: LD_VAR 0 4
28838: ARRAY
28839: PUSH
28840: LD_INT 2
28842: ARRAY
28843: PPUSH
28844: LD_VAR 0 6
28848: PUSH
28849: LD_VAR 0 4
28853: ARRAY
28854: PUSH
28855: LD_INT 3
28857: ARRAY
28858: PPUSH
28859: LD_INT 8
28861: PPUSH
28862: CALL 28879 0 4
// end ;
28866: GO 28769
28868: POP
28869: POP
// end ;
28870: GO 28727
28872: POP
28873: POP
// end ; end ;
28874: LD_VAR 0 2
28878: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
28879: LD_INT 0
28881: PPUSH
28882: PPUSH
28883: PPUSH
28884: PPUSH
28885: PPUSH
28886: PPUSH
28887: PPUSH
28888: PPUSH
28889: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
28890: LD_VAR 0 1
28894: NOT
28895: PUSH
28896: LD_VAR 0 2
28900: PPUSH
28901: LD_VAR 0 3
28905: PPUSH
28906: CALL_OW 488
28910: NOT
28911: OR
28912: PUSH
28913: LD_VAR 0 4
28917: NOT
28918: OR
28919: IFFALSE 28923
// exit ;
28921: GO 29263
// list := [ ] ;
28923: LD_ADDR_VAR 0 13
28927: PUSH
28928: EMPTY
28929: ST_TO_ADDR
// if x - r < 0 then
28930: LD_VAR 0 2
28934: PUSH
28935: LD_VAR 0 4
28939: MINUS
28940: PUSH
28941: LD_INT 0
28943: LESS
28944: IFFALSE 28956
// min_x := 0 else
28946: LD_ADDR_VAR 0 7
28950: PUSH
28951: LD_INT 0
28953: ST_TO_ADDR
28954: GO 28972
// min_x := x - r ;
28956: LD_ADDR_VAR 0 7
28960: PUSH
28961: LD_VAR 0 2
28965: PUSH
28966: LD_VAR 0 4
28970: MINUS
28971: ST_TO_ADDR
// if y - r < 0 then
28972: LD_VAR 0 3
28976: PUSH
28977: LD_VAR 0 4
28981: MINUS
28982: PUSH
28983: LD_INT 0
28985: LESS
28986: IFFALSE 28998
// min_y := 0 else
28988: LD_ADDR_VAR 0 8
28992: PUSH
28993: LD_INT 0
28995: ST_TO_ADDR
28996: GO 29014
// min_y := y - r ;
28998: LD_ADDR_VAR 0 8
29002: PUSH
29003: LD_VAR 0 3
29007: PUSH
29008: LD_VAR 0 4
29012: MINUS
29013: ST_TO_ADDR
// max_x := x + r ;
29014: LD_ADDR_VAR 0 9
29018: PUSH
29019: LD_VAR 0 2
29023: PUSH
29024: LD_VAR 0 4
29028: PLUS
29029: ST_TO_ADDR
// max_y := y + r ;
29030: LD_ADDR_VAR 0 10
29034: PUSH
29035: LD_VAR 0 3
29039: PUSH
29040: LD_VAR 0 4
29044: PLUS
29045: ST_TO_ADDR
// for _x = min_x to max_x do
29046: LD_ADDR_VAR 0 11
29050: PUSH
29051: DOUBLE
29052: LD_VAR 0 7
29056: DEC
29057: ST_TO_ADDR
29058: LD_VAR 0 9
29062: PUSH
29063: FOR_TO
29064: IFFALSE 29181
// for _y = min_y to max_y do
29066: LD_ADDR_VAR 0 12
29070: PUSH
29071: DOUBLE
29072: LD_VAR 0 8
29076: DEC
29077: ST_TO_ADDR
29078: LD_VAR 0 10
29082: PUSH
29083: FOR_TO
29084: IFFALSE 29177
// begin if not ValidHex ( _x , _y ) then
29086: LD_VAR 0 11
29090: PPUSH
29091: LD_VAR 0 12
29095: PPUSH
29096: CALL_OW 488
29100: NOT
29101: IFFALSE 29105
// continue ;
29103: GO 29083
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29105: LD_VAR 0 11
29109: PPUSH
29110: LD_VAR 0 12
29114: PPUSH
29115: CALL_OW 351
29119: PUSH
29120: LD_VAR 0 11
29124: PPUSH
29125: LD_VAR 0 12
29129: PPUSH
29130: CALL_OW 554
29134: AND
29135: IFFALSE 29175
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29137: LD_ADDR_VAR 0 13
29141: PUSH
29142: LD_VAR 0 13
29146: PPUSH
29147: LD_VAR 0 13
29151: PUSH
29152: LD_INT 1
29154: PLUS
29155: PPUSH
29156: LD_VAR 0 11
29160: PUSH
29161: LD_VAR 0 12
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PPUSH
29170: CALL_OW 2
29174: ST_TO_ADDR
// end ;
29175: GO 29083
29177: POP
29178: POP
29179: GO 29063
29181: POP
29182: POP
// if not list then
29183: LD_VAR 0 13
29187: NOT
29188: IFFALSE 29192
// exit ;
29190: GO 29263
// for i in list do
29192: LD_ADDR_VAR 0 6
29196: PUSH
29197: LD_VAR 0 13
29201: PUSH
29202: FOR_IN
29203: IFFALSE 29261
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29205: LD_VAR 0 1
29209: PPUSH
29210: LD_STRING M
29212: PUSH
29213: LD_VAR 0 6
29217: PUSH
29218: LD_INT 1
29220: ARRAY
29221: PUSH
29222: LD_VAR 0 6
29226: PUSH
29227: LD_INT 2
29229: ARRAY
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: LD_INT 0
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: PUSH
29252: EMPTY
29253: LIST
29254: PPUSH
29255: CALL_OW 447
29259: GO 29202
29261: POP
29262: POP
// end ;
29263: LD_VAR 0 5
29267: RET
