// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ( ) ;
   4: CALL_OW 11
// AnimateTrees ( true ) ;
   8: LD_INT 1
  10: PPUSH
  11: CALL_OW 573
// Init ;
  15: CALL 48 0 0
// DebugMode ;
  19: CALL 225 0 0
// PrepareNature ;
  23: CALL 511 0 0
// PrepareRussian ;
  27: CALL 13721 0 0
// PrepareAmerican ;
  31: CALL 1244 0 0
// PrepareOvsyenko ;
  35: CALL 1867 0 0
// Action ;
  39: CALL 2966 0 0
// SaveForQuickRestart ;
  43: CALL_OW 22
// end ;
  47: END
// export mission_prefix , debug , terminal ; export jmm_in_ovsyenko , powell_want_sib , powell_want_sib_counter , game_time , ru_can_attack , ru_can_attack_terminal , ar_can_arrive , ar_spawned , player_want_mortar , player_want_info , player_get_mortar , player_get_info , player_attacked_ar , can_end , blocked , earlySib , bulldozerCounter ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := 0 ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// jmm_in_ovsyenko := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// mission_prefix := 09_ ;
  67: LD_ADDR_EXP 1
  71: PUSH
  72: LD_STRING 09_
  74: ST_TO_ADDR
// powell_want_sib := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// powell_want_sib_counter := 15 15$00 ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 31500
  90: ST_TO_ADDR
// game_time := [ 47 47$00 , 50 50$00 , 53 53$00 ] [ Difficulty ] ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 98700
  98: PUSH
  99: LD_INT 105000
 101: PUSH
 102: LD_INT 111300
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: ST_TO_ADDR
// ru_can_attack := false ;
 116: LD_ADDR_EXP 8
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// ru_can_attack_terminal := false ;
 124: LD_ADDR_EXP 9
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// ar_can_arrive := false ;
 132: LD_ADDR_EXP 10
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// ar_spawned := false ;
 140: LD_ADDR_EXP 11
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// player_want_mortar := false ;
 148: LD_ADDR_EXP 12
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// player_want_info := false ;
 156: LD_ADDR_EXP 13
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// player_get_mortar := false ;
 164: LD_ADDR_EXP 14
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// player_get_info := false ;
 172: LD_ADDR_EXP 15
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// player_attacked_ar := false ;
 180: LD_ADDR_EXP 16
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// can_end := false ;
 188: LD_ADDR_EXP 17
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// blocked := false ;
 196: LD_ADDR_EXP 18
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// earlySib := false ;
 204: LD_ADDR_EXP 19
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// bulldozerCounter := 0 ;
 212: LD_ADDR_EXP 20
 216: PUSH
 217: LD_INT 0
 219: ST_TO_ADDR
// end ;
 220: LD_VAR 0 1
 224: RET
// function DebugMode ; begin
 225: LD_INT 0
 227: PPUSH
// if not debug then
 228: LD_EXP 2
 232: NOT
 233: IFFALSE 237
// exit ;
 235: GO 244
// FogOff ( 1 ) ;
 237: LD_INT 1
 239: PPUSH
 240: CALL_OW 344
// end ;
 244: LD_VAR 0 1
 248: RET
// every 0 0$1 trigger bulldozerCounter >= 2 do
 249: LD_EXP 20
 253: PUSH
 254: LD_INT 2
 256: GREATEREQUAL
 257: IFFALSE 269
 259: GO 261
 261: DISABLE
// SetAchievement ( ACH_BULLDOZER ) ;
 262: LD_STRING ACH_BULLDOZER
 264: PPUSH
 265: CALL_OW 543
 269: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) = 0 do
 270: LD_INT 22
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: EMPTY
 277: LIST
 278: LIST
 279: PUSH
 280: LD_INT 21
 282: PUSH
 283: LD_INT 3
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: LD_INT 0
 301: EQUAL
 302: IFFALSE 314
 304: GO 306
 306: DISABLE
// SetAchievement ( ACH_COUNTERSTRIKE ) ;
 307: LD_STRING ACH_COUNTERSTRIKE
 309: PPUSH
 310: CALL_OW 543
 314: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] ] ) = 2 do
 315: LD_INT 22
 317: PUSH
 318: LD_INT 1
 320: PUSH
 321: EMPTY
 322: LIST
 323: LIST
 324: PUSH
 325: LD_INT 30
 327: PUSH
 328: LD_INT 30
 330: PUSH
 331: EMPTY
 332: LIST
 333: LIST
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PPUSH
 339: CALL_OW 69
 343: PUSH
 344: LD_INT 2
 346: EQUAL
 347: IFFALSE 359
 349: GO 351
 351: DISABLE
// SetAchievement ( ACH_SIBMINE ) ; end_of_file
 352: LD_STRING ACH_SIBMINE
 354: PPUSH
 355: CALL_OW 543
 359: END
// export function PrepareUnit ( ident , exist_mode , mission_prefix_prev ) ; var unit ; begin
 360: LD_INT 0
 362: PPUSH
 363: PPUSH
// if exist_mode then
 364: LD_VAR 0 2
 368: IFFALSE 393
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 370: LD_ADDR_VAR 0 5
 374: PUSH
 375: LD_VAR 0 3
 379: PUSH
 380: LD_VAR 0 1
 384: STR
 385: PPUSH
 386: CALL_OW 34
 390: ST_TO_ADDR
 391: GO 408
// unit := NewCharacter ( ident ) ;
 393: LD_ADDR_VAR 0 5
 397: PUSH
 398: LD_VAR 0 1
 402: PPUSH
 403: CALL_OW 25
 407: ST_TO_ADDR
// result := unit ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 5
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 4
 422: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 423: LD_INT 0
 425: PPUSH
// uc_side := side ;
 426: LD_ADDR_OWVAR 20
 430: PUSH
 431: LD_VAR 0 1
 435: ST_TO_ADDR
// uc_nation := nation ;
 436: LD_ADDR_OWVAR 21
 440: PUSH
 441: LD_VAR 0 2
 445: ST_TO_ADDR
// vc_chassis := chassis ;
 446: LD_ADDR_OWVAR 37
 450: PUSH
 451: LD_VAR 0 3
 455: ST_TO_ADDR
// vc_engine := engine ;
 456: LD_ADDR_OWVAR 39
 460: PUSH
 461: LD_VAR 0 4
 465: ST_TO_ADDR
// vc_control := control ;
 466: LD_ADDR_OWVAR 38
 470: PUSH
 471: LD_VAR 0 5
 475: ST_TO_ADDR
// vc_weapon := weapon ;
 476: LD_ADDR_OWVAR 40
 480: PUSH
 481: LD_VAR 0 6
 485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 486: LD_ADDR_OWVAR 41
 490: PUSH
 491: LD_VAR 0 7
 495: ST_TO_ADDR
// result := CreateVehicle ;
 496: LD_ADDR_VAR 0 8
 500: PUSH
 501: CALL_OW 45
 505: ST_TO_ADDR
// end ;
 506: LD_VAR 0 8
 510: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
 511: LD_INT 0
 513: PPUSH
 514: PPUSH
 515: PPUSH
 516: PPUSH
// uc_side = 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation = 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// nat_area := natureArea ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// InitHc ;
 541: CALL_OW 19
// for i = 1 to 4 do
 545: LD_ADDR_VAR 0 2
 549: PUSH
 550: DOUBLE
 551: LD_INT 1
 553: DEC
 554: ST_TO_ADDR
 555: LD_INT 4
 557: PUSH
 558: FOR_TO
 559: IFFALSE 614
// begin hc_class = 18 ;
 561: LD_ADDR_OWVAR 28
 565: PUSH
 566: LD_INT 18
 568: ST_TO_ADDR
// hc_gallery =  ;
 569: LD_ADDR_OWVAR 33
 573: PUSH
 574: LD_STRING 
 576: ST_TO_ADDR
// hc_face_number = 1 ;
 577: LD_ADDR_OWVAR 34
 581: PUSH
 582: LD_INT 1
 584: ST_TO_ADDR
// animal := CreateHuman ;
 585: LD_ADDR_VAR 0 3
 589: PUSH
 590: CALL_OW 44
 594: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 595: LD_VAR 0 3
 599: PPUSH
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_INT 0
 607: PPUSH
 608: CALL_OW 49
// end ;
 612: GO 558
 614: POP
 615: POP
// for i = 1 to 4 do
 616: LD_ADDR_VAR 0 2
 620: PUSH
 621: DOUBLE
 622: LD_INT 1
 624: DEC
 625: ST_TO_ADDR
 626: LD_INT 4
 628: PUSH
 629: FOR_TO
 630: IFFALSE 702
// begin hc_class = class_tiger ;
 632: LD_ADDR_OWVAR 28
 636: PUSH
 637: LD_INT 14
 639: ST_TO_ADDR
// hc_gallery =  ;
 640: LD_ADDR_OWVAR 33
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
 648: LD_ADDR_OWVAR 35
 652: PUSH
 653: LD_INT 5
 655: NEG
 656: PPUSH
 657: LD_INT 5
 659: PPUSH
 660: CALL_OW 12
 664: ST_TO_ADDR
// hc_face_number = 3 ;
 665: LD_ADDR_OWVAR 34
 669: PUSH
 670: LD_INT 3
 672: ST_TO_ADDR
// animal := CreateHuman ;
 673: LD_ADDR_VAR 0 3
 677: PUSH
 678: CALL_OW 44
 682: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 683: LD_VAR 0 3
 687: PPUSH
 688: LD_VAR 0 4
 692: PPUSH
 693: LD_INT 0
 695: PPUSH
 696: CALL_OW 49
// end ;
 700: GO 629
 702: POP
 703: POP
// for i = 1 to 8 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 8
 716: PUSH
 717: FOR_TO
 718: IFFALSE 821
// begin hc_class = class_apeman ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 12
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
 736: LD_ADDR_OWVAR 35
 740: PUSH
 741: LD_INT 2
 743: NEG
 744: PPUSH
 745: LD_INT 2
 747: PPUSH
 748: CALL_OW 12
 752: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
 753: LD_ADDR_OWVAR 31
 757: PUSH
 758: LD_INT 1
 760: PPUSH
 761: LD_INT 3
 763: PPUSH
 764: CALL_OW 12
 768: PUSH
 769: LD_INT 1
 771: PPUSH
 772: LD_INT 3
 774: PPUSH
 775: CALL_OW 12
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: ST_TO_ADDR
// animal := CreateHuman ;
 792: LD_ADDR_VAR 0 3
 796: PUSH
 797: CALL_OW 44
 801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: LD_INT 0
 814: PPUSH
 815: CALL_OW 49
// end ;
 819: GO 717
 821: POP
 822: POP
// for i = 1 to 6 do
 823: LD_ADDR_VAR 0 2
 827: PUSH
 828: DOUBLE
 829: LD_INT 1
 831: DEC
 832: ST_TO_ADDR
 833: LD_INT 6
 835: PUSH
 836: FOR_TO
 837: IFFALSE 892
// begin hc_class = 13 ;
 839: LD_ADDR_OWVAR 28
 843: PUSH
 844: LD_INT 13
 846: ST_TO_ADDR
// hc_gallery =  ;
 847: LD_ADDR_OWVAR 33
 851: PUSH
 852: LD_STRING 
 854: ST_TO_ADDR
// hc_face_number = 4 ;
 855: LD_ADDR_OWVAR 34
 859: PUSH
 860: LD_INT 4
 862: ST_TO_ADDR
// animal := CreateHuman ;
 863: LD_ADDR_VAR 0 3
 867: PUSH
 868: CALL_OW 44
 872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
 873: LD_VAR 0 3
 877: PPUSH
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_INT 0
 885: PPUSH
 886: CALL_OW 49
// end ;
 890: GO 836
 892: POP
 893: POP
// vc_chassis := 31 ;
 894: LD_ADDR_OWVAR 37
 898: PUSH
 899: LD_INT 31
 901: ST_TO_ADDR
// vc_control := control_rider ;
 902: LD_ADDR_OWVAR 38
 906: PUSH
 907: LD_INT 4
 909: ST_TO_ADDR
// animal := CreateVehicle ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: CALL_OW 45
 919: ST_TO_ADDR
// PlaceUnitXY ( animal , 21 , 22 , false ) ;
 920: LD_VAR 0 3
 924: PPUSH
 925: LD_INT 21
 927: PPUSH
 928: LD_INT 22
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: CALL_OW 48
// end ;
 938: LD_VAR 0 1
 942: RET
// export function GetTerminalCargo ; begin
 943: LD_INT 0
 945: PPUSH
// result := GetResourceType ( GetBase ( terminal ) , mat_siberit ) ;
 946: LD_ADDR_VAR 0 1
 950: PUSH
 951: LD_EXP 3
 955: PPUSH
 956: CALL_OW 274
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: CALL_OW 275
 968: ST_TO_ADDR
// end ;
 969: LD_VAR 0 1
 973: RET
// export function GetPlayerSib ( side ) ; var i , tmp ; begin
 974: LD_INT 0
 976: PPUSH
 977: PPUSH
 978: PPUSH
// result := 0 ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
 987: LD_ADDR_VAR 0 4
 991: PUSH
 992: LD_INT 22
 994: PUSH
 995: LD_VAR 0 1
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 30
1009: PUSH
1010: LD_INT 0
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: PUSH
1017: LD_INT 30
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL_OW 69
1040: ST_TO_ADDR
// if not tmp then
1041: LD_VAR 0 4
1045: NOT
1046: IFFALSE 1050
// exit ;
1048: GO 1096
// for i in tmp do
1050: LD_ADDR_VAR 0 3
1054: PUSH
1055: LD_VAR 0 4
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1094
// result := result + GetResourceType ( GetBase ( i ) , mat_siberit ) ;
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: LD_VAR 0 2
1072: PUSH
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 274
1082: PPUSH
1083: LD_INT 3
1085: PPUSH
1086: CALL_OW 275
1090: PLUS
1091: ST_TO_ADDR
1092: GO 1060
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
1101: LD_INT 0
1103: PPUSH
1104: PPUSH
// area = ListEnvironmentArea ( area ) ;
1105: LD_ADDR_VAR 0 2
1109: PUSH
1110: LD_VAR 0 2
1114: PPUSH
1115: CALL_OW 353
1119: ST_TO_ADDR
// if bulldozer > 0 then
1120: LD_VAR 0 1
1124: PUSH
1125: LD_INT 0
1127: GREATER
1128: IFFALSE 1239
// for i = area downto 1 do
1130: LD_ADDR_VAR 0 4
1134: PUSH
1135: DOUBLE
1136: LD_VAR 0 2
1140: INC
1141: ST_TO_ADDR
1142: LD_INT 1
1144: PUSH
1145: FOR_DOWNTO
1146: IFFALSE 1237
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
1148: LD_VAR 0 2
1152: PUSH
1153: LD_VAR 0 4
1157: ARRAY
1158: PUSH
1159: LD_INT 1
1161: ARRAY
1162: PPUSH
1163: LD_VAR 0 2
1167: PUSH
1168: LD_VAR 0 4
1172: ARRAY
1173: PUSH
1174: LD_INT 2
1176: ARRAY
1177: PPUSH
1178: CALL_OW 351
1182: IFFALSE 1235
// if not HasTask ( bulldozer ) then
1184: LD_VAR 0 1
1188: PPUSH
1189: CALL_OW 314
1193: NOT
1194: IFFALSE 1235
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
1196: LD_VAR 0 1
1200: PPUSH
1201: LD_VAR 0 2
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PUSH
1212: LD_INT 1
1214: ARRAY
1215: PPUSH
1216: LD_VAR 0 2
1220: PUSH
1221: LD_VAR 0 4
1225: ARRAY
1226: PUSH
1227: LD_INT 2
1229: ARRAY
1230: PPUSH
1231: CALL_OW 171
1235: GO 1145
1237: POP
1238: POP
// end ; end_of_file
1239: LD_VAR 0 3
1243: RET
// export JMM , Gary , Bobby , Cyrus , Houten , alpha_engs , powell_trans , Powell ; export function PrepareAmerican ; var tmp , un , veh , i ; begin
1244: LD_INT 0
1246: PPUSH
1247: PPUSH
1248: PPUSH
1249: PPUSH
1250: PPUSH
// uc_side := 1 ;
1251: LD_ADDR_OWVAR 20
1255: PUSH
1256: LD_INT 1
1258: ST_TO_ADDR
// uc_nation := 1 ;
1259: LD_ADDR_OWVAR 21
1263: PUSH
1264: LD_INT 1
1266: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 08_ ) ;
1267: LD_ADDR_EXP 21
1271: PUSH
1272: LD_STRING JMM
1274: PPUSH
1275: LD_EXP 2
1279: NOT
1280: PPUSH
1281: LD_STRING 08_
1283: PPUSH
1284: CALL 360 0 3
1288: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_tracked , engine_solar , control_manual , us_double_gun , 55 ) ;
1289: LD_ADDR_VAR 0 4
1293: PUSH
1294: LD_INT 1
1296: PPUSH
1297: LD_INT 1
1299: PPUSH
1300: LD_INT 3
1302: PPUSH
1303: LD_INT 2
1305: PPUSH
1306: LD_INT 1
1308: PPUSH
1309: LD_INT 5
1311: PPUSH
1312: LD_INT 55
1314: PPUSH
1315: CALL 423 0 7
1319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1320: LD_VAR 0 4
1324: PPUSH
1325: LD_INT 3
1327: PPUSH
1328: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 3 , false ) ;
1332: LD_VAR 0 4
1336: PPUSH
1337: LD_INT 43
1339: PPUSH
1340: LD_INT 3
1342: PPUSH
1343: LD_INT 0
1345: PPUSH
1346: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1350: LD_EXP 21
1354: PPUSH
1355: LD_VAR 0 4
1359: PPUSH
1360: CALL_OW 52
// tmp := [ ] ;
1364: LD_ADDR_VAR 0 2
1368: PUSH
1369: EMPTY
1370: ST_TO_ADDR
// uc_side := 4 ;
1371: LD_ADDR_OWVAR 20
1375: PUSH
1376: LD_INT 4
1378: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
1379: LD_ADDR_OWVAR 33
1383: PUSH
1384: LD_STRING SecondCharsGal
1386: ST_TO_ADDR
// hc_class := 2 ;
1387: LD_ADDR_OWVAR 28
1391: PUSH
1392: LD_INT 2
1394: ST_TO_ADDR
// hc_sex := sex_female ;
1395: LD_ADDR_OWVAR 27
1399: PUSH
1400: LD_INT 2
1402: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 1 , 0 ] ;
1403: LD_ADDR_OWVAR 30
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 1
1416: PUSH
1417: LD_INT 0
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 2 , 1 ] ;
1426: LD_ADDR_OWVAR 31
1430: PUSH
1431: LD_INT 3
1433: PUSH
1434: LD_INT 4
1436: PUSH
1437: LD_INT 2
1439: PUSH
1440: LD_INT 1
1442: PUSH
1443: EMPTY
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
1449: LD_ADDR_OWVAR 29
1453: PUSH
1454: LD_INT 10
1456: PUSH
1457: LD_INT 11
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: ST_TO_ADDR
// hc_name := Naoma Goichman ;
1464: LD_ADDR_OWVAR 26
1468: PUSH
1469: LD_STRING Naoma Goichman
1471: ST_TO_ADDR
// hc_face_number := 43 ;
1472: LD_ADDR_OWVAR 34
1476: PUSH
1477: LD_INT 43
1479: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1480: LD_ADDR_VAR 0 2
1484: PUSH
1485: LD_VAR 0 2
1489: PUSH
1490: CALL_OW 44
1494: ADD
1495: ST_TO_ADDR
// hc_basic_skills := [ 0 , 2 , 0 , 1 ] ;
1496: LD_ADDR_OWVAR 30
1500: PUSH
1501: LD_INT 0
1503: PUSH
1504: LD_INT 2
1506: PUSH
1507: LD_INT 0
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: LIST
1517: LIST
1518: ST_TO_ADDR
// hc_skills := [ 0 , 5 , 3 , 1 ] ;
1519: LD_ADDR_OWVAR 31
1523: PUSH
1524: LD_INT 0
1526: PUSH
1527: LD_INT 5
1529: PUSH
1530: LD_INT 3
1532: PUSH
1533: LD_INT 1
1535: PUSH
1536: EMPTY
1537: LIST
1538: LIST
1539: LIST
1540: LIST
1541: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1542: LD_ADDR_OWVAR 29
1546: PUSH
1547: LD_INT 10
1549: PUSH
1550: LD_INT 10
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: ST_TO_ADDR
// hc_name := Magdalene Glance ;
1557: LD_ADDR_OWVAR 26
1561: PUSH
1562: LD_STRING Magdalene Glance
1564: ST_TO_ADDR
// hc_face_number := 44 ;
1565: LD_ADDR_OWVAR 34
1569: PUSH
1570: LD_INT 44
1572: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 2
1582: PUSH
1583: CALL_OW 44
1587: ADD
1588: ST_TO_ADDR
// hc_sex := sex_male ;
1589: LD_ADDR_OWVAR 27
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 0 , 0 ] ;
1597: LD_ADDR_OWVAR 30
1601: PUSH
1602: LD_INT 2
1604: PUSH
1605: LD_INT 2
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 0
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 1 , 0 ] ;
1620: LD_ADDR_OWVAR 31
1624: PUSH
1625: LD_INT 3
1627: PUSH
1628: LD_INT 4
1630: PUSH
1631: LD_INT 1
1633: PUSH
1634: LD_INT 0
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: ST_TO_ADDR
// hc_attr := [ 12 , 10 ] ;
1643: LD_ADDR_OWVAR 29
1647: PUSH
1648: LD_INT 12
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// hc_name := Steve Holland ;
1658: LD_ADDR_OWVAR 26
1662: PUSH
1663: LD_STRING Steve Holland
1665: ST_TO_ADDR
// hc_face_number := 60 ;
1666: LD_ADDR_OWVAR 34
1670: PUSH
1671: LD_INT 60
1673: ST_TO_ADDR
// tmp := tmp ^ CreateHuman ;
1674: LD_ADDR_VAR 0 2
1678: PUSH
1679: LD_VAR 0 2
1683: PUSH
1684: CALL_OW 44
1688: ADD
1689: ST_TO_ADDR
// alpha_engs := tmp diff 0 ;
1690: LD_ADDR_EXP 26
1694: PUSH
1695: LD_VAR 0 2
1699: PUSH
1700: LD_INT 0
1702: DIFF
1703: ST_TO_ADDR
// for un in alpha_engs do
1704: LD_ADDR_VAR 0 3
1708: PUSH
1709: LD_EXP 26
1713: PUSH
1714: FOR_IN
1715: IFFALSE 1740
// PlaceUnitXYR ( un , 52 , 35 , 3 , false ) ;
1717: LD_VAR 0 3
1721: PPUSH
1722: LD_INT 52
1724: PPUSH
1725: LD_INT 35
1727: PPUSH
1728: LD_INT 3
1730: PPUSH
1731: LD_INT 0
1733: PPUSH
1734: CALL_OW 50
1738: GO 1714
1740: POP
1741: POP
// for tmp = 1 to ( 1 + LoadVariable ( 06_crates_1 , 0 ) ) * 2 do
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: DOUBLE
1748: LD_INT 1
1750: DEC
1751: ST_TO_ADDR
1752: LD_INT 1
1754: PUSH
1755: LD_STRING 06_crates_1
1757: PPUSH
1758: LD_INT 0
1760: PPUSH
1761: CALL_OW 30
1765: PLUS
1766: PUSH
1767: LD_INT 2
1769: MUL
1770: PUSH
1771: FOR_TO
1772: IFFALSE 1798
// CreateResourcesXYR ( mat_cans , 5 , 56 , 40 , 2 , false ) ;
1774: LD_INT 1
1776: PPUSH
1777: LD_INT 5
1779: PPUSH
1780: LD_INT 56
1782: PPUSH
1783: LD_INT 40
1785: PPUSH
1786: LD_INT 2
1788: PPUSH
1789: LD_INT 0
1791: PPUSH
1792: CALL_OW 60
1796: GO 1771
1798: POP
1799: POP
// if LoadVariable ( GammaCommander , 0 ) < 3 then
1800: LD_STRING GammaCommander
1802: PPUSH
1803: LD_INT 0
1805: PPUSH
1806: CALL_OW 30
1810: PUSH
1811: LD_INT 3
1813: LESS
1814: IFFALSE 1835
// Houten := PrepareUnit ( VanHouten , false ,  ) ;
1816: LD_ADDR_EXP 25
1820: PUSH
1821: LD_STRING VanHouten
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: LD_STRING 
1829: PPUSH
1830: CALL 360 0 3
1834: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
1835: LD_ADDR_EXP 28
1839: PUSH
1840: LD_STRING Powell
1842: PPUSH
1843: LD_INT 0
1845: PPUSH
1846: LD_STRING 
1848: PPUSH
1849: CALL 360 0 3
1853: ST_TO_ADDR
// InitHc ;
1854: CALL_OW 19
// InitUc ;
1858: CALL_OW 18
// end ;
1862: LD_VAR 0 1
1866: RET
// export function PrepareOvsyenko ; var i , b , tmp , un ; begin
1867: LD_INT 0
1869: PPUSH
1870: PPUSH
1871: PPUSH
1872: PPUSH
1873: PPUSH
// uc_side := 4 ;
1874: LD_ADDR_OWVAR 20
1878: PUSH
1879: LD_INT 4
1881: ST_TO_ADDR
// uc_nation := 3 ;
1882: LD_ADDR_OWVAR 21
1886: PUSH
1887: LD_INT 3
1889: ST_TO_ADDR
// tmp := LoadVariable ( 09_ovsyenko_base , [ [ b_depot , 101 , 118 , 2 , 500 ] , [ b_breastwork , 109 , 114 , 4 , 500 ] , [ b_breastwork , 115 , 132 , 5 , 500 ] , [ b_breastwork , 98 , 120 , 1 , 500 ] ] ) ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_STRING 09_ovsyenko_base
1897: PPUSH
1898: LD_INT 0
1900: PUSH
1901: LD_INT 101
1903: PUSH
1904: LD_INT 118
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 500
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: LD_INT 31
1922: PUSH
1923: LD_INT 109
1925: PUSH
1926: LD_INT 114
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 500
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: PUSH
1942: LD_INT 31
1944: PUSH
1945: LD_INT 115
1947: PUSH
1948: LD_INT 132
1950: PUSH
1951: LD_INT 5
1953: PUSH
1954: LD_INT 500
1956: PUSH
1957: EMPTY
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 31
1966: PUSH
1967: LD_INT 98
1969: PUSH
1970: LD_INT 120
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 500
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PPUSH
1992: CALL_OW 30
1996: ST_TO_ADDR
// for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2164
// begin bc_type := i [ 1 ] ;
2010: LD_ADDR_OWVAR 42
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_INT 1
2022: ARRAY
2023: ST_TO_ADDR
// bc_level := 3 ;
2024: LD_ADDR_OWVAR 43
2028: PUSH
2029: LD_INT 3
2031: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
2032: LD_ADDR_VAR 0 3
2036: PUSH
2037: LD_VAR 0 2
2041: PUSH
2042: LD_INT 2
2044: ARRAY
2045: PPUSH
2046: LD_VAR 0 2
2050: PUSH
2051: LD_INT 3
2053: ARRAY
2054: PPUSH
2055: LD_VAR 0 2
2059: PUSH
2060: LD_INT 4
2062: ARRAY
2063: PPUSH
2064: CALL_OW 47
2068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
2069: LD_VAR 0 3
2073: PPUSH
2074: CALL_OW 266
2078: PUSH
2079: LD_INT 0
2081: EQUAL
2082: IFFALSE 2116
// begin SetBName ( b , ovsyenko ) ;
2084: LD_VAR 0 3
2088: PPUSH
2089: LD_STRING ovsyenko
2091: PPUSH
2092: CALL_OW 500
// SetResourceType ( GetBase ( b ) , mat_cans , 50 ) ;
2096: LD_VAR 0 3
2100: PPUSH
2101: CALL_OW 274
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_INT 50
2111: PPUSH
2112: CALL_OW 277
// end ; if i [ 5 ] < 250 then
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 5
2123: ARRAY
2124: PUSH
2125: LD_INT 250
2127: LESS
2128: IFFALSE 2144
// SetLives ( b , 333 ) else
2130: LD_VAR 0 3
2134: PPUSH
2135: LD_INT 333
2137: PPUSH
2138: CALL_OW 234
2142: GO 2162
// SetLives ( b , i [ 5 ] ) ;
2144: LD_VAR 0 3
2148: PPUSH
2149: LD_VAR 0 2
2153: PUSH
2154: LD_INT 5
2156: ARRAY
2157: PPUSH
2158: CALL_OW 234
// end ;
2162: GO 2007
2164: POP
2165: POP
// uc_nation := 1 ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 1
2173: ST_TO_ADDR
// tmp := [ ] ;
2174: LD_ADDR_VAR 0 4
2178: PUSH
2179: EMPTY
2180: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) ,  ) ;
2181: LD_ADDR_EXP 22
2185: PUSH
2186: LD_STRING Gary
2188: PPUSH
2189: LD_EXP 2
2193: NOT
2194: PPUSH
2195: LD_STRING 
2197: PPUSH
2198: CALL 360 0 3
2202: ST_TO_ADDR
// tmp := tmp ^ Gary ;
2203: LD_ADDR_VAR 0 4
2207: PUSH
2208: LD_VAR 0 4
2212: PUSH
2213: LD_EXP 22
2217: ADD
2218: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 08_ ) ;
2219: LD_ADDR_EXP 23
2223: PUSH
2224: LD_STRING Bobby
2226: PPUSH
2227: LD_EXP 2
2231: NOT
2232: PPUSH
2233: LD_STRING 08_
2235: PPUSH
2236: CALL 360 0 3
2240: ST_TO_ADDR
// if not Bobby then
2241: LD_EXP 23
2245: NOT
2246: IFFALSE 2270
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 03_ ) ;
2248: LD_ADDR_EXP 23
2252: PUSH
2253: LD_STRING Bobby
2255: PPUSH
2256: LD_EXP 2
2260: NOT
2261: PPUSH
2262: LD_STRING 03_
2264: PPUSH
2265: CALL 360 0 3
2269: ST_TO_ADDR
// if Bobby then
2270: LD_EXP 23
2274: IFFALSE 2292
// tmp := tmp ^ Bobby ;
2276: LD_ADDR_VAR 0 4
2280: PUSH
2281: LD_VAR 0 4
2285: PUSH
2286: LD_EXP 23
2290: ADD
2291: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 08_ ) ;
2292: LD_ADDR_EXP 24
2296: PUSH
2297: LD_STRING Cyrus
2299: PPUSH
2300: LD_EXP 2
2304: NOT
2305: PPUSH
2306: LD_STRING 08_
2308: PPUSH
2309: CALL 360 0 3
2313: ST_TO_ADDR
// if not Cyrus then
2314: LD_EXP 24
2318: NOT
2319: IFFALSE 2343
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 03_ ) ;
2321: LD_ADDR_EXP 24
2325: PUSH
2326: LD_STRING Cyrus
2328: PPUSH
2329: LD_EXP 2
2333: NOT
2334: PPUSH
2335: LD_STRING 03_
2337: PPUSH
2338: CALL 360 0 3
2342: ST_TO_ADDR
// if Cyrus then
2343: LD_EXP 24
2347: IFFALSE 2365
// tmp := tmp ^ Cyrus ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_VAR 0 4
2358: PUSH
2359: LD_EXP 24
2363: ADD
2364: ST_TO_ADDR
// tmp := tmp ^ CreateCharacterSet ( 09_prev_squad ) ;
2365: LD_ADDR_VAR 0 4
2369: PUSH
2370: LD_VAR 0 4
2374: PUSH
2375: LD_STRING 09_prev_squad
2377: PPUSH
2378: CALL_OW 31
2382: ADD
2383: ST_TO_ADDR
// DeleteCharacters ( 09_prev_squad ) ;
2384: LD_STRING 09_prev_squad
2386: PPUSH
2387: CALL_OW 40
// hc_name := Peter McCreery ;
2391: LD_ADDR_OWVAR 26
2395: PUSH
2396: LD_STRING Peter McCreery
2398: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2399: LD_ADDR_OWVAR 33
2403: PUSH
2404: LD_STRING SecondCharsGal
2406: ST_TO_ADDR
// hc_face_number := 58 ;
2407: LD_ADDR_OWVAR 34
2411: PUSH
2412: LD_INT 58
2414: ST_TO_ADDR
// hc_sex := sex_male ;
2415: LD_ADDR_OWVAR 27
2419: PUSH
2420: LD_INT 1
2422: ST_TO_ADDR
// hc_class := 4 ;
2423: LD_ADDR_OWVAR 28
2427: PUSH
2428: LD_INT 4
2430: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 1 , 2 ] ;
2431: LD_ADDR_OWVAR 30
2435: PUSH
2436: LD_INT 0
2438: PUSH
2439: LD_INT 0
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 3 , 6 ] ;
2454: LD_ADDR_OWVAR 31
2458: PUSH
2459: LD_INT 1
2461: PUSH
2462: LD_INT 0
2464: PUSH
2465: LD_INT 3
2467: PUSH
2468: LD_INT 6
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: ST_TO_ADDR
// un := CreateHuman ;
2477: LD_ADDR_VAR 0 5
2481: PUSH
2482: CALL_OW 44
2486: ST_TO_ADDR
// SetTag ( un , 11 ) ;
2487: LD_VAR 0 5
2491: PPUSH
2492: LD_INT 11
2494: PPUSH
2495: CALL_OW 109
// tmp := tmp ^ un ;
2499: LD_ADDR_VAR 0 4
2503: PUSH
2504: LD_VAR 0 4
2508: PUSH
2509: LD_VAR 0 5
2513: ADD
2514: ST_TO_ADDR
// tmp := tmp diff 0 ;
2515: LD_ADDR_VAR 0 4
2519: PUSH
2520: LD_VAR 0 4
2524: PUSH
2525: LD_INT 0
2527: DIFF
2528: ST_TO_ADDR
// InitHc ;
2529: CALL_OW 19
// hc_name :=  ;
2533: LD_ADDR_OWVAR 26
2537: PUSH
2538: LD_STRING 
2540: ST_TO_ADDR
// hc_gallery :=  ;
2541: LD_ADDR_OWVAR 33
2545: PUSH
2546: LD_STRING 
2548: ST_TO_ADDR
// if debug then
2549: LD_EXP 2
2553: IFFALSE 2604
// begin for i = 1 to 6 do
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: DOUBLE
2561: LD_INT 1
2563: DEC
2564: ST_TO_ADDR
2565: LD_INT 6
2567: PUSH
2568: FOR_TO
2569: IFFALSE 2602
// begin PrepareHuman ( false , 1 , 6 ) ;
2571: LD_INT 0
2573: PPUSH
2574: LD_INT 1
2576: PPUSH
2577: LD_INT 6
2579: PPUSH
2580: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2584: LD_ADDR_VAR 0 4
2588: PUSH
2589: LD_VAR 0 4
2593: PUSH
2594: CALL_OW 44
2598: ADD
2599: ST_TO_ADDR
// end ;
2600: GO 2568
2602: POP
2603: POP
// end ; for i in tmp do
2604: LD_ADDR_VAR 0 2
2608: PUSH
2609: LD_VAR 0 4
2613: PUSH
2614: FOR_IN
2615: IFFALSE 2674
// begin if GetClass ( i ) in [ 2 , 3 ] then
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 257
2626: PUSH
2627: LD_INT 2
2629: PUSH
2630: LD_INT 3
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: IN
2637: IFFALSE 2651
// SetClass ( i , 1 ) ;
2639: LD_VAR 0 2
2643: PPUSH
2644: LD_INT 1
2646: PPUSH
2647: CALL_OW 336
// PlaceUnitXYR ( i , 106 , 122 , 5 , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 106
2658: PPUSH
2659: LD_INT 122
2661: PPUSH
2662: LD_INT 5
2664: PPUSH
2665: LD_INT 0
2667: PPUSH
2668: CALL_OW 50
// end ;
2672: GO 2614
2674: POP
2675: POP
// tmp := tmp diff Gary ;
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_EXP 22
2690: DIFF
2691: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) ;
2692: LD_ADDR_VAR 0 3
2696: PUSH
2697: LD_INT 22
2699: PUSH
2700: LD_INT 4
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 30
2709: PUSH
2710: LD_INT 31
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PPUSH
2721: CALL_OW 69
2725: ST_TO_ADDR
// for i = 1 to b do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: DOUBLE
2732: LD_INT 1
2734: DEC
2735: ST_TO_ADDR
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_TO
2742: IFFALSE 2787
// ComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) [ i ] , b [ i ] ) ;
2744: LD_VAR 0 4
2748: PPUSH
2749: LD_INT 25
2751: PUSH
2752: LD_INT 1
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 72
2763: PUSH
2764: LD_VAR 0 2
2768: ARRAY
2769: PPUSH
2770: LD_VAR 0 3
2774: PUSH
2775: LD_VAR 0 2
2779: ARRAY
2780: PPUSH
2781: CALL_OW 120
2785: GO 2741
2787: POP
2788: POP
// InitHc ;
2789: CALL_OW 19
// InitUc ;
2793: CALL_OW 18
// end ;
2797: LD_VAR 0 1
2801: RET
// export function PowellTransport ; var i , un ; begin
2802: LD_INT 0
2804: PPUSH
2805: PPUSH
2806: PPUSH
// uc_side := 4 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 4
2814: ST_TO_ADDR
// uc_nation := 1 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
2823: LD_INT 1
2825: PPUSH
2826: LD_INT 3
2828: PPUSH
2829: LD_INT 6
2831: PPUSH
2832: CALL_OW 380
// hc_name :=  ;
2836: LD_ADDR_OWVAR 26
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING SecondCharsGal
2851: ST_TO_ADDR
// hc_face_number := 30 ;
2852: LD_ADDR_OWVAR 34
2856: PUSH
2857: LD_INT 30
2859: ST_TO_ADDR
// powell_trans := CreateHuman ;
2860: LD_ADDR_EXP 27
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// hc_face_number := 31 ;
2870: LD_ADDR_OWVAR 34
2874: PUSH
2875: LD_INT 31
2877: ST_TO_ADDR
// powell_trans := powell_trans ^ CreateHuman ;
2878: LD_ADDR_EXP 27
2882: PUSH
2883: LD_EXP 27
2887: PUSH
2888: CALL_OW 44
2892: ADD
2893: ST_TO_ADDR
// for i = 1 to 2 do
2894: LD_ADDR_VAR 0 2
2898: PUSH
2899: DOUBLE
2900: LD_INT 1
2902: DEC
2903: ST_TO_ADDR
2904: LD_INT 2
2906: PUSH
2907: FOR_TO
2908: IFFALSE 2959
// begin un := PrepareTank ( 4 , 1 , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay , 66 ) ;
2910: LD_ADDR_VAR 0 3
2914: PUSH
2915: LD_INT 4
2917: PPUSH
2918: LD_INT 1
2920: PPUSH
2921: LD_INT 3
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_INT 1
2929: PPUSH
2930: LD_INT 12
2932: PPUSH
2933: LD_INT 66
2935: PPUSH
2936: CALL 423 0 7
2940: ST_TO_ADDR
// powell_trans := powell_trans ^ un ;
2941: LD_ADDR_EXP 27
2945: PUSH
2946: LD_EXP 27
2950: PUSH
2951: LD_VAR 0 3
2955: ADD
2956: ST_TO_ADDR
// end ;
2957: GO 2907
2959: POP
2960: POP
// end ; end_of_file
2961: LD_VAR 0 1
2965: RET
// export function Action ; var i , veh ; begin
2966: LD_INT 0
2968: PPUSH
2969: PPUSH
2970: PPUSH
// ComBuild ( alpha_engs , b_depot , 50 , 38 , 2 ) ;
2971: LD_EXP 26
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: LD_INT 50
2981: PPUSH
2982: LD_INT 38
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: CALL_OW 145
// InGameOn ;
2992: CALL_OW 8
// CenterNowOnXY ( 43 , 9 ) ;
2996: LD_INT 43
2998: PPUSH
2999: LD_INT 9
3001: PPUSH
3002: CALL_OW 86
// ComMoveXY ( JMM , 54 , 34 ) ;
3006: LD_EXP 21
3010: PPUSH
3011: LD_INT 54
3013: PPUSH
3014: LD_INT 34
3016: PPUSH
3017: CALL_OW 111
// AddComExitVehicle ( JMM ) ;
3021: LD_EXP 21
3025: PPUSH
3026: CALL_OW 181
// AddComTurnUnit ( JMM , alpha_engs [ 1 ] ) ;
3030: LD_EXP 21
3034: PPUSH
3035: LD_EXP 26
3039: PUSH
3040: LD_INT 1
3042: ARRAY
3043: PPUSH
3044: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3048: LD_INT 35
3050: PPUSH
3051: CALL_OW 67
// until See ( 4 , JMM ) ;
3055: LD_INT 4
3057: PPUSH
3058: LD_EXP 21
3062: PPUSH
3063: CALL_OW 292
3067: IFFALSE 3048
// CenterNowOnUnits ( JMM ) ;
3069: LD_EXP 21
3073: PPUSH
3074: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
3078: LD_EXP 21
3082: PPUSH
3083: LD_STRING D2-JMM-1
3085: PPUSH
3086: CALL_OW 88
// ComTurnUnit ( alpha_engs [ 3 ] , JMM ) ;
3090: LD_EXP 26
3094: PUSH
3095: LD_INT 3
3097: ARRAY
3098: PPUSH
3099: LD_EXP 21
3103: PPUSH
3104: CALL_OW 119
// Say ( alpha_engs [ 3 ] , D2-Eng1-1 ) ;
3108: LD_EXP 26
3112: PUSH
3113: LD_INT 3
3115: ARRAY
3116: PPUSH
3117: LD_STRING D2-Eng1-1
3119: PPUSH
3120: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
3124: LD_EXP 21
3128: PPUSH
3129: LD_STRING D2-JMM-2
3131: PPUSH
3132: CALL_OW 88
// Say ( alpha_engs [ 3 ] , D2-Eng1-2 ) ;
3136: LD_EXP 26
3140: PUSH
3141: LD_INT 3
3143: ARRAY
3144: PPUSH
3145: LD_STRING D2-Eng1-2
3147: PPUSH
3148: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
3152: LD_EXP 21
3156: PPUSH
3157: LD_STRING D2-JMM-3
3159: PPUSH
3160: CALL_OW 88
// if Houten then
3164: LD_EXP 25
3168: IFFALSE 3366
// begin veh := PrepareTank ( 4 , 1 , us_medium_tracked , engine_solar , control_manual , us_gatling_gun , 55 ) ;
3170: LD_ADDR_VAR 0 3
3174: PUSH
3175: LD_INT 4
3177: PPUSH
3178: LD_INT 1
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 4
3192: PPUSH
3193: LD_INT 55
3195: PPUSH
3196: CALL 423 0 7
3200: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3201: LD_VAR 0 3
3205: PPUSH
3206: LD_INT 3
3208: PPUSH
3209: CALL_OW 233
// PlaceUnitXY ( veh , 46 , 19 , false ) ;
3213: LD_VAR 0 3
3217: PPUSH
3218: LD_INT 46
3220: PPUSH
3221: LD_INT 19
3223: PPUSH
3224: LD_INT 0
3226: PPUSH
3227: CALL_OW 48
// PlaceHumanInUnit ( Houten , veh ) ;
3231: LD_EXP 25
3235: PPUSH
3236: LD_VAR 0 3
3240: PPUSH
3241: CALL_OW 52
// ComMoveXY ( Houten , 49 , 33 ) ;
3245: LD_EXP 25
3249: PPUSH
3250: LD_INT 49
3252: PPUSH
3253: LD_INT 33
3255: PPUSH
3256: CALL_OW 111
// AddComExitVehicle ( Houten ) ;
3260: LD_EXP 25
3264: PPUSH
3265: CALL_OW 181
// AddComTurnUnit ( Houten , JMM ) ;
3269: LD_EXP 25
3273: PPUSH
3274: LD_EXP 21
3278: PPUSH
3279: CALL_OW 179
// repeat wait ( 0 0$01 ) ;
3283: LD_INT 35
3285: PPUSH
3286: CALL_OW 67
// until See ( 1 , Houten ) ;
3290: LD_INT 1
3292: PPUSH
3293: LD_EXP 25
3297: PPUSH
3298: CALL_OW 292
3302: IFFALSE 3283
// ComTurnUnit ( JMM , Houten ) ;
3304: LD_EXP 21
3308: PPUSH
3309: LD_EXP 25
3313: PPUSH
3314: CALL_OW 119
// Say ( JMM , D1d-JMM-1 ) ;
3318: LD_EXP 21
3322: PPUSH
3323: LD_STRING D1d-JMM-1
3325: PPUSH
3326: CALL_OW 88
// Say ( Houten , D1-VanH-1 ) ;
3330: LD_EXP 25
3334: PPUSH
3335: LD_STRING D1-VanH-1
3337: PPUSH
3338: CALL_OW 88
// Say ( JMM , D1-JMM-1v ) ;
3342: LD_EXP 21
3346: PPUSH
3347: LD_STRING D1-JMM-1v
3349: PPUSH
3350: CALL_OW 88
// Say ( JMM , D1-JMM-2v ) ;
3354: LD_EXP 21
3358: PPUSH
3359: LD_STRING D1-JMM-2v
3361: PPUSH
3362: CALL_OW 88
// end ; InGameOff ;
3366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3370: LD_STRING M1
3372: PPUSH
3373: CALL_OW 337
// SetSide ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 15 ] ] ) , 1 ) ;
3377: LD_INT 22
3379: PUSH
3380: LD_INT 4
3382: PUSH
3383: EMPTY
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 92
3389: PUSH
3390: LD_EXP 21
3394: PPUSH
3395: CALL_OW 250
3399: PUSH
3400: LD_EXP 21
3404: PPUSH
3405: CALL_OW 251
3409: PUSH
3410: LD_INT 15
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: CALL_OW 235
// ComStop ( alpha_engs ^ JMM ^ Houten ) ;
3435: LD_EXP 26
3439: PUSH
3440: LD_EXP 21
3444: ADD
3445: PUSH
3446: LD_EXP 25
3450: ADD
3451: PPUSH
3452: CALL_OW 141
// end ;
3456: LD_VAR 0 1
3460: RET
// every 0 0$1 trigger See ( 1 , Gary ) and GetDistUnits ( JMM , Gary ) < 6 do var un1 , un2 , un3 , tmp , i ;
3461: LD_INT 1
3463: PPUSH
3464: LD_EXP 22
3468: PPUSH
3469: CALL_OW 292
3473: PUSH
3474: LD_EXP 21
3478: PPUSH
3479: LD_EXP 22
3483: PPUSH
3484: CALL_OW 296
3488: PUSH
3489: LD_INT 6
3491: LESS
3492: AND
3493: IFFALSE 4366
3495: GO 3497
3497: DISABLE
3498: LD_INT 0
3500: PPUSH
3501: PPUSH
3502: PPUSH
3503: PPUSH
3504: PPUSH
// begin InGameOn ;
3505: CALL_OW 8
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
3509: LD_INT 22
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PPUSH
3519: CALL_OW 69
3523: PPUSH
3524: LD_INT 1
3526: PPUSH
3527: CALL_OW 235
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
3531: LD_ADDR_VAR 0 4
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 1
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 25
3561: PUSH
3562: LD_INT 2
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: LD_INT 25
3571: PUSH
3572: LD_INT 3
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PUSH
3579: LD_INT 25
3581: PUSH
3582: LD_INT 4
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: ST_TO_ADDR
// ComHold ( tmp ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: CALL_OW 140
// Say ( JMM , D2-JMM-3a ) ;
3614: LD_EXP 21
3618: PPUSH
3619: LD_STRING D2-JMM-3a
3621: PPUSH
3622: CALL_OW 88
// ComTurnUnit ( Gary , JMM ) ;
3626: LD_EXP 22
3630: PPUSH
3631: LD_EXP 21
3635: PPUSH
3636: CALL_OW 119
// Say ( Gary , D2-Gary-3 ) ;
3640: LD_EXP 22
3644: PPUSH
3645: LD_STRING D2-Gary-3
3647: PPUSH
3648: CALL_OW 88
// ComTurnUnit ( JMM , Gary ) ;
3652: LD_EXP 21
3656: PPUSH
3657: LD_EXP 22
3661: PPUSH
3662: CALL_OW 119
// for i in tmp do
3666: LD_ADDR_VAR 0 5
3670: PUSH
3671: LD_VAR 0 4
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3722
// begin if IsInUnit ( i ) then
3679: LD_VAR 0 5
3683: PPUSH
3684: CALL_OW 310
3688: IFFALSE 3699
// ComExitBuilding ( i ) ;
3690: LD_VAR 0 5
3694: PPUSH
3695: CALL_OW 122
// wait ( 1 ) ;
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 67
// ComTurnUnit ( i , JMM ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_EXP 21
3715: PPUSH
3716: CALL_OW 119
// end ;
3720: GO 3676
3722: POP
3723: POP
// tmp := tmp diff [ JMM , Houten , Gary , Cyrus , Bobby ] ^ alpha_engs ;
3724: LD_ADDR_VAR 0 4
3728: PUSH
3729: LD_VAR 0 4
3733: PUSH
3734: LD_EXP 21
3738: PUSH
3739: LD_EXP 25
3743: PUSH
3744: LD_EXP 22
3748: PUSH
3749: LD_EXP 24
3753: PUSH
3754: LD_EXP 23
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: PUSH
3766: LD_EXP 26
3770: ADD
3771: DIFF
3772: ST_TO_ADDR
// if Bobby then
3773: LD_EXP 23
3777: IFFALSE 3791
// Say ( Bobby , D2-Bobby-3 ) ;
3779: LD_EXP 23
3783: PPUSH
3784: LD_STRING D2-Bobby-3
3786: PPUSH
3787: CALL_OW 88
// if Cyrus then
3791: LD_EXP 24
3795: IFFALSE 3809
// Say ( Cyrus , D2-Cyrus-3 ) ;
3797: LD_EXP 24
3801: PPUSH
3802: LD_STRING D2-Cyrus-3
3804: PPUSH
3805: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
3809: LD_EXP 21
3813: PPUSH
3814: LD_STRING D2-JMM-4
3816: PPUSH
3817: CALL_OW 88
// Say ( Gary , D2-Gary-4 ) ;
3821: LD_EXP 22
3825: PPUSH
3826: LD_STRING D2-Gary-4
3828: PPUSH
3829: CALL_OW 88
// un1 := UnitFilter ( tmp , [ f_sex , sex_male ] ) [ 1 ] ;
3833: LD_ADDR_VAR 0 1
3837: PUSH
3838: LD_VAR 0 4
3842: PPUSH
3843: LD_INT 26
3845: PUSH
3846: LD_INT 1
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 72
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// if Cyrus then
3862: LD_EXP 24
3866: IFFALSE 3882
// Say ( Cyrus , D2-Cyrus-4 ) else
3868: LD_EXP 24
3872: PPUSH
3873: LD_STRING D2-Cyrus-4
3875: PPUSH
3876: CALL_OW 88
3880: GO 3894
// Say ( un1 , D2-Sol1-4 ) ;
3882: LD_VAR 0 1
3886: PPUSH
3887: LD_STRING D2-Sol1-4
3889: PPUSH
3890: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
3894: LD_EXP 21
3898: PPUSH
3899: LD_STRING D2-JMM-5
3901: PPUSH
3902: CALL_OW 88
// un2 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_female ] ] ) ;
3906: LD_ADDR_VAR 0 2
3910: PUSH
3911: LD_EXP 26
3915: PPUSH
3916: LD_INT 91
3918: PUSH
3919: LD_EXP 21
3923: PUSH
3924: LD_INT 10
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: LIST
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PPUSH
3946: CALL_OW 72
3950: ST_TO_ADDR
// if un2 then
3951: LD_VAR 0 2
3955: IFFALSE 4009
// begin un2 := un2 [ un2 ] ;
3957: LD_ADDR_VAR 0 2
3961: PUSH
3962: LD_VAR 0 2
3966: PUSH
3967: LD_VAR 0 2
3971: ARRAY
3972: ST_TO_ADDR
// Say ( un2 , D2-FEng1-5 ) ;
3973: LD_VAR 0 2
3977: PPUSH
3978: LD_STRING D2-FEng1-5
3980: PPUSH
3981: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
3985: LD_EXP 21
3989: PPUSH
3990: LD_STRING D2-JMM-6
3992: PPUSH
3993: CALL_OW 88
// Say ( un2 , D2-FEng1-6 ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_STRING D2-FEng1-6
4004: PPUSH
4005: CALL_OW 88
// end ; un3 := UnitFilter ( alpha_engs , [ [ f_dist , JMM , 10 ] , [ f_sex , sex_male ] ] ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_EXP 26
4018: PPUSH
4019: LD_INT 91
4021: PUSH
4022: LD_EXP 21
4026: PUSH
4027: LD_INT 10
4029: PUSH
4030: EMPTY
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 72
4053: ST_TO_ADDR
// if un3 then
4054: LD_VAR 0 3
4058: IFFALSE 4113
// begin un3 := un3 [ 1 ] ;
4060: LD_ADDR_VAR 0 3
4064: PUSH
4065: LD_VAR 0 3
4069: PUSH
4070: LD_INT 1
4072: ARRAY
4073: ST_TO_ADDR
// ComMoveXY ( un3 , 114 , 122 ) ;
4074: LD_VAR 0 3
4078: PPUSH
4079: LD_INT 114
4081: PPUSH
4082: LD_INT 122
4084: PPUSH
4085: CALL_OW 111
// Say ( un3 , D2-Eng1-6 ) ;
4089: LD_VAR 0 3
4093: PPUSH
4094: LD_STRING D2-Eng1-6
4096: PPUSH
4097: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4101: LD_EXP 21
4105: PPUSH
4106: LD_STRING D2-JMM-7
4108: PPUSH
4109: CALL_OW 88
// end ; Say ( Gary , D2-Gary-7 ) ;
4113: LD_EXP 22
4117: PPUSH
4118: LD_STRING D2-Gary-7
4120: PPUSH
4121: CALL_OW 88
// if un2 then
4125: LD_VAR 0 2
4129: IFFALSE 4143
// Say ( un2 , D2-FEng1-7 ) ;
4131: LD_VAR 0 2
4135: PPUSH
4136: LD_STRING D2-FEng1-7
4138: PPUSH
4139: CALL_OW 88
// Say ( un1 , D2-Sol1-7 ) ;
4143: LD_VAR 0 1
4147: PPUSH
4148: LD_STRING D2-Sol1-7
4150: PPUSH
4151: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
4155: LD_EXP 21
4159: PPUSH
4160: LD_STRING D2-JMM-8
4162: PPUSH
4163: CALL_OW 88
// ComStop ( FilterAllUnits ( [ f_side , 1 ] ) ) ;
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PPUSH
4182: CALL_OW 141
// InGameOff ;
4186: CALL_OW 9
// ChangeMissionObjectives ( M1a ) ;
4190: LD_STRING M1a
4192: PPUSH
4193: CALL_OW 337
// jmm_in_ovsyenko := true ;
4197: LD_ADDR_EXP 4
4201: PUSH
4202: LD_INT 1
4204: ST_TO_ADDR
// if debug then
4205: LD_EXP 2
4209: IFFALSE 4315
// begin SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_oil , 1000 ) ;
4211: LD_INT 22
4213: PUSH
4214: LD_INT 1
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PUSH
4221: LD_INT 30
4223: PUSH
4224: LD_INT 0
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PPUSH
4235: CALL_OW 69
4239: PUSH
4240: LD_INT 1
4242: ARRAY
4243: PPUSH
4244: CALL_OW 274
4248: PPUSH
4249: LD_INT 2
4251: PPUSH
4252: LD_INT 1000
4254: PPUSH
4255: CALL_OW 277
// SetResourceType ( GetBase ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) , mat_cans , 1000 ) ;
4259: LD_INT 22
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 30
4271: PUSH
4272: LD_INT 0
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PPUSH
4283: CALL_OW 69
4287: PUSH
4288: LD_INT 1
4290: ARRAY
4291: PPUSH
4292: CALL_OW 274
4296: PPUSH
4297: LD_INT 1
4299: PPUSH
4300: LD_INT 1000
4302: PPUSH
4303: CALL_OW 277
// ar_can_arrive := true ;
4307: LD_ADDR_EXP 10
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// end ; wait ( 0 0$30 ) ;
4315: LD_INT 1050
4317: PPUSH
4318: CALL_OW 67
// tmp := FilterAllUnits ( [ f_class , class_tiger ] ) ;
4322: LD_ADDR_VAR 0 4
4326: PUSH
4327: LD_INT 25
4329: PUSH
4330: LD_INT 14
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PPUSH
4337: CALL_OW 69
4341: ST_TO_ADDR
// if not tmp then
4342: LD_VAR 0 4
4346: NOT
4347: IFFALSE 4351
// exit ;
4349: GO 4366
// ComMoveXY ( tmp , 75 , 75 ) ;
4351: LD_VAR 0 4
4355: PPUSH
4356: LD_INT 75
4358: PPUSH
4359: LD_INT 75
4361: PPUSH
4362: CALL_OW 111
// end ;
4366: PPOPN 5
4368: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_siberite_mine ] , [ f_not , [ f_constructed ] ] ] ) do var tmp ;
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 30
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: LD_INT 57
4394: PUSH
4395: EMPTY
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: IFFALSE 4453
4413: GO 4415
4415: DISABLE
4416: LD_INT 0
4418: PPUSH
// begin tmp := [ M2easy , M2 , M2hard ] ;
4419: LD_ADDR_VAR 0 1
4423: PUSH
4424: LD_STRING M2easy
4426: PUSH
4427: LD_STRING M2
4429: PUSH
4430: LD_STRING M2hard
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: ST_TO_ADDR
// ChangeMissionObjectives ( tmp [ Difficulty ] ) ;
4438: LD_VAR 0 1
4442: PUSH
4443: LD_OWVAR 67
4447: ARRAY
4448: PPUSH
4449: CALL_OW 337
// end ;
4453: PPOPN 1
4455: END
// every 3 3$00 do
4456: GO 4458
4458: DISABLE
// begin DialogueOn ;
4459: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4463: LD_EXP 28
4467: PPUSH
4468: LD_STRING D3-Pow-1
4470: PPUSH
4471: CALL_OW 94
// if jmm_in_ovsyenko then
4475: LD_EXP 4
4479: IFFALSE 4507
// begin Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 21
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( JMM , D3-JMM-1b ) ;
4493: LD_EXP 21
4497: PPUSH
4498: LD_STRING D3-JMM-1b
4500: PPUSH
4501: CALL_OW 88
// end else
4505: GO 4519
// Say ( JMM , D3-JMM-1a ) ;
4507: LD_EXP 21
4511: PPUSH
4512: LD_STRING D3-JMM-1a
4514: PPUSH
4515: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4519: LD_EXP 28
4523: PPUSH
4524: LD_STRING D3-Pow-2
4526: PPUSH
4527: CALL_OW 94
// DialogueOff ;
4531: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
4535: LD_STRING M3
4537: PPUSH
4538: CALL_OW 337
// powell_want_sib := true ;
4542: LD_ADDR_EXP 5
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// end ;
4550: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do var tmp , x , y , i , un , powell_happy , take_cargo , time ;
4551: LD_EXP 6
4555: PUSH
4556: LD_INT 0
4558: EQUAL
4559: IFFALSE 6020
4561: GO 4563
4563: DISABLE
4564: LD_INT 0
4566: PPUSH
4567: PPUSH
4568: PPUSH
4569: PPUSH
4570: PPUSH
4571: PPUSH
4572: PPUSH
4573: PPUSH
// begin ChangeSideFog ( 4 , 1 ) ;
4574: LD_INT 4
4576: PPUSH
4577: LD_INT 1
4579: PPUSH
4580: CALL_OW 343
// PowellTransport ;
4584: CALL 2802 0 0
// for i = 1 to 3 do
4588: LD_ADDR_VAR 0 4
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_INT 3
4600: PUSH
4601: FOR_TO
4602: IFFALSE 4669
// begin tmp := GetResourceArea ( terminalArea , i ) ;
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_INT 6
4611: PPUSH
4612: LD_VAR 0 4
4616: PPUSH
4617: CALL_OW 287
4621: ST_TO_ADDR
// if not tmp then
4622: LD_VAR 0 1
4626: NOT
4627: IFFALSE 4631
// continue ;
4629: GO 4601
// EraseResourceArea ( terminalArea , i ) ;
4631: LD_INT 6
4633: PPUSH
4634: LD_VAR 0 4
4638: PPUSH
4639: CALL_OW 286
// AddResourceType ( GetBase ( terminal ) , i , tmp ) ;
4643: LD_EXP 3
4647: PPUSH
4648: CALL_OW 274
4652: PPUSH
4653: LD_VAR 0 4
4657: PPUSH
4658: LD_VAR 0 1
4662: PPUSH
4663: CALL_OW 276
// end ;
4667: GO 4601
4669: POP
4670: POP
// x := 43 ;
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: LD_INT 43
4678: ST_TO_ADDR
// y := 3 ;
4679: LD_ADDR_VAR 0 3
4683: PUSH
4684: LD_INT 3
4686: ST_TO_ADDR
// for i = 3 to 4 do
4687: LD_ADDR_VAR 0 4
4691: PUSH
4692: DOUBLE
4693: LD_INT 3
4695: DEC
4696: ST_TO_ADDR
4697: LD_INT 4
4699: PUSH
4700: FOR_TO
4701: IFFALSE 4892
// begin SetDir ( powell_trans [ i ] , 4 ) ;
4703: LD_EXP 27
4707: PUSH
4708: LD_VAR 0 4
4712: ARRAY
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 233
// PlaceUnitXY ( powell_trans [ i ] , x , y , false ) ;
4721: LD_EXP 27
4725: PUSH
4726: LD_VAR 0 4
4730: ARRAY
4731: PPUSH
4732: LD_VAR 0 2
4736: PPUSH
4737: LD_VAR 0 3
4741: PPUSH
4742: LD_INT 0
4744: PPUSH
4745: CALL_OW 48
// PlaceHumanInUnit ( powell_trans [ i - 2 ] , powell_trans [ i ] ) ;
4749: LD_EXP 27
4753: PUSH
4754: LD_VAR 0 4
4758: PUSH
4759: LD_INT 2
4761: MINUS
4762: ARRAY
4763: PPUSH
4764: LD_EXP 27
4768: PUSH
4769: LD_VAR 0 4
4773: ARRAY
4774: PPUSH
4775: CALL_OW 52
// SetCargo ( powell_trans [ i ] , mat_cans , 100 ) ;
4779: LD_EXP 27
4783: PUSH
4784: LD_VAR 0 4
4788: ARRAY
4789: PPUSH
4790: LD_INT 1
4792: PPUSH
4793: LD_INT 100
4795: PPUSH
4796: CALL_OW 290
// ComMoveXY ( powell_trans [ i - 2 ] , 54 , 42 ) ;
4800: LD_EXP 27
4804: PUSH
4805: LD_VAR 0 4
4809: PUSH
4810: LD_INT 2
4812: MINUS
4813: ARRAY
4814: PPUSH
4815: LD_INT 54
4817: PPUSH
4818: LD_INT 42
4820: PPUSH
4821: CALL_OW 111
// AddComMoveXY ( powell_trans [ i - 2 ] , GetX ( terminal ) , GetY ( terminal ) ) ;
4825: LD_EXP 27
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_INT 2
4837: MINUS
4838: ARRAY
4839: PPUSH
4840: LD_EXP 3
4844: PPUSH
4845: CALL_OW 250
4849: PPUSH
4850: LD_EXP 3
4854: PPUSH
4855: CALL_OW 251
4859: PPUSH
4860: CALL_OW 171
// AddComHold ( powell_trans [ i - 2 ] ) ;
4864: LD_EXP 27
4868: PUSH
4869: LD_VAR 0 4
4873: PUSH
4874: LD_INT 2
4876: MINUS
4877: ARRAY
4878: PPUSH
4879: CALL_OW 200
// Wait ( 0 0$02 ) ;
4883: LD_INT 70
4885: PPUSH
4886: CALL_OW 67
// end ;
4890: GO 4700
4892: POP
4893: POP
// time := 0 0$20 ;
4894: LD_ADDR_VAR 0 8
4898: PUSH
4899: LD_INT 700
4901: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
4902: LD_INT 35
4904: PPUSH
4905: CALL_OW 67
// time := time - 0 0$01 ;
4909: LD_ADDR_VAR 0 8
4913: PUSH
4914: LD_VAR 0 8
4918: PUSH
4919: LD_INT 35
4921: MINUS
4922: ST_TO_ADDR
// for i = 3 to 4 do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 3
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 4
4935: PUSH
4936: FOR_TO
4937: IFFALSE 5072
// if GetCargo ( powell_trans [ i ] , mat_cans ) > 0 and not HasTask ( powell_trans [ i ] ) then
4939: LD_EXP 27
4943: PUSH
4944: LD_VAR 0 4
4948: ARRAY
4949: PPUSH
4950: LD_INT 1
4952: PPUSH
4953: CALL_OW 289
4957: PUSH
4958: LD_INT 0
4960: GREATER
4961: PUSH
4962: LD_EXP 27
4966: PUSH
4967: LD_VAR 0 4
4971: ARRAY
4972: PPUSH
4973: CALL_OW 314
4977: NOT
4978: AND
4979: IFFALSE 5070
// begin x := rand ( 0 , 5 ) ;
4981: LD_ADDR_VAR 0 2
4985: PUSH
4986: LD_INT 0
4988: PPUSH
4989: LD_INT 5
4991: PPUSH
4992: CALL_OW 12
4996: ST_TO_ADDR
// AddComMoveXY ( powell_trans [ i ] , ShiftX ( GetX ( powell_trans [ i ] ) , x , 3 ) , ShiftY ( GetY ( powell_trans [ i ] ) , x , 3 ) ) ;
4997: LD_EXP 27
5001: PUSH
5002: LD_VAR 0 4
5006: ARRAY
5007: PPUSH
5008: LD_EXP 27
5012: PUSH
5013: LD_VAR 0 4
5017: ARRAY
5018: PPUSH
5019: CALL_OW 250
5023: PPUSH
5024: LD_VAR 0 2
5028: PPUSH
5029: LD_INT 3
5031: PPUSH
5032: CALL_OW 272
5036: PPUSH
5037: LD_EXP 27
5041: PUSH
5042: LD_VAR 0 4
5046: ARRAY
5047: PPUSH
5048: CALL_OW 251
5052: PPUSH
5053: LD_VAR 0 2
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: CALL_OW 273
5065: PPUSH
5066: CALL_OW 171
// end ;
5070: GO 4936
5072: POP
5073: POP
// until GetDistUnitXY ( powell_trans [ 1 ] , 54 , 42 ) < 4 or time = 0 ;
5074: LD_EXP 27
5078: PUSH
5079: LD_INT 1
5081: ARRAY
5082: PPUSH
5083: LD_INT 54
5085: PPUSH
5086: LD_INT 42
5088: PPUSH
5089: CALL_OW 297
5093: PUSH
5094: LD_INT 4
5096: LESS
5097: PUSH
5098: LD_VAR 0 8
5102: PUSH
5103: LD_INT 0
5105: EQUAL
5106: OR
5107: IFFALSE 4902
// SetCargo ( powell_trans [ 3 ] , mat_cans , 0 ) ;
5109: LD_EXP 27
5113: PUSH
5114: LD_INT 3
5116: ARRAY
5117: PPUSH
5118: LD_INT 1
5120: PPUSH
5121: LD_INT 0
5123: PPUSH
5124: CALL_OW 290
// SetCargo ( powell_trans [ 4 ] , mat_cans , 0 ) ;
5128: LD_EXP 27
5132: PUSH
5133: LD_INT 4
5135: ARRAY
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: LD_INT 0
5142: PPUSH
5143: CALL_OW 290
// AddResourceType ( GetBase ( terminal ) , mat_cans , 200 ) ;
5147: LD_EXP 3
5151: PPUSH
5152: CALL_OW 274
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 200
5162: PPUSH
5163: CALL_OW 276
// DialogueOn ;
5167: CALL_OW 6
// CenterNowOnXY ( 53 , 35 ) ;
5171: LD_INT 53
5173: PPUSH
5174: LD_INT 35
5176: PPUSH
5177: CALL_OW 86
// un := powell_trans [ 1 ] ;
5181: LD_ADDR_VAR 0 5
5185: PUSH
5186: LD_EXP 27
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: ST_TO_ADDR
// Say ( un , D4-Mech1-1 ) ;
5195: LD_VAR 0 5
5199: PPUSH
5200: LD_STRING D4-Mech1-1
5202: PPUSH
5203: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
5207: LD_EXP 21
5211: PPUSH
5212: LD_STRING D4-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( un , D4-Mech1-2 ) ;
5219: LD_VAR 0 5
5223: PPUSH
5224: LD_STRING D4-Mech1-2
5226: PPUSH
5227: CALL_OW 88
// powell_happy := false ;
5231: LD_ADDR_VAR 0 6
5235: PUSH
5236: LD_INT 0
5238: ST_TO_ADDR
// take_cargo := false ;
5239: LD_ADDR_VAR 0 7
5243: PUSH
5244: LD_INT 0
5246: ST_TO_ADDR
// if GetTerminalCargo >= 60 then
5247: CALL 943 0 0
5251: PUSH
5252: LD_INT 60
5254: GREATEREQUAL
5255: IFFALSE 5303
// begin Say ( JMM , D5-JMM-1 ) ;
5257: LD_EXP 21
5261: PPUSH
5262: LD_STRING D5-JMM-1
5264: PPUSH
5265: CALL_OW 88
// Say ( un , D6-Mech1-1 ) ;
5269: LD_VAR 0 5
5273: PPUSH
5274: LD_STRING D6-Mech1-1
5276: PPUSH
5277: CALL_OW 88
// powell_happy := true ;
5281: LD_ADDR_VAR 0 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// take_cargo := true ;
5289: LD_ADDR_VAR 0 7
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// DialogueOff ;
5297: CALL_OW 7
// end else
5301: GO 5537
// if GetTerminalCargo > 0 then
5303: CALL 943 0 0
5307: PUSH
5308: LD_INT 0
5310: GREATER
5311: IFFALSE 5509
// begin case Query ( QWait ) of 1 :
5313: LD_STRING QWait
5315: PPUSH
5316: CALL_OW 97
5320: PUSH
5321: LD_INT 1
5323: DOUBLE
5324: EQUAL
5325: IFTRUE 5329
5327: GO 5420
5329: POP
// begin Say ( JMM , D5a-JMM-1 ) ;
5330: LD_EXP 21
5334: PPUSH
5335: LD_STRING D5a-JMM-1
5337: PPUSH
5338: CALL_OW 88
// DialogueOff ;
5342: CALL_OW 7
// wait ( 5 5$00 ) ;
5346: LD_INT 10500
5348: PPUSH
5349: CALL_OW 67
// if GetTerminalCargo < 60 then
5353: CALL 943 0 0
5357: PUSH
5358: LD_INT 60
5360: LESS
5361: IFFALSE 5402
// begin DialogueOn ;
5363: CALL_OW 6
// CenterNowOnUnits ( terminal ) ;
5367: LD_EXP 3
5371: PPUSH
5372: CALL_OW 87
// Say ( un , D6-Mech1-1a ) ;
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_STRING D6-Mech1-1a
5383: PPUSH
5384: CALL_OW 88
// DialogueOff ;
5388: CALL_OW 7
// powell_happy := false ;
5392: LD_ADDR_VAR 0 6
5396: PUSH
5397: LD_INT 0
5399: ST_TO_ADDR
// end else
5400: GO 5418
// begin powell_happy := true ;
5402: LD_ADDR_VAR 0 6
5406: PUSH
5407: LD_INT 1
5409: ST_TO_ADDR
// take_cargo := true ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// end ; end ; 2 :
5418: GO 5507
5420: LD_INT 2
5422: DOUBLE
5423: EQUAL
5424: IFTRUE 5428
5426: GO 5467
5428: POP
// begin Say ( JMM , D5b-JMM-1 ) ;
5429: LD_EXP 21
5433: PPUSH
5434: LD_STRING D5b-JMM-1
5436: PPUSH
5437: CALL_OW 88
// Say ( un , D6-Mech1-1a ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_STRING D6-Mech1-1a
5448: PPUSH
5449: CALL_OW 88
// DialogueOff ;
5453: CALL_OW 7
// take_cargo := true ;
5457: LD_ADDR_VAR 0 7
5461: PUSH
5462: LD_INT 1
5464: ST_TO_ADDR
// end ; 3 :
5465: GO 5507
5467: LD_INT 3
5469: DOUBLE
5470: EQUAL
5471: IFTRUE 5475
5473: GO 5506
5475: POP
// begin Say ( JMM , D5c-JMM-1 ) ;
5476: LD_EXP 21
5480: PPUSH
5481: LD_STRING D5c-JMM-1
5483: PPUSH
5484: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5488: LD_VAR 0 5
5492: PPUSH
5493: LD_STRING D6-Mech1-1b
5495: PPUSH
5496: CALL_OW 88
// DialogueOff ;
5500: CALL_OW 7
// end ; end ;
5504: GO 5507
5506: POP
// end else
5507: GO 5537
// begin Say ( JMM , D5c-JMM-1 ) ;
5509: LD_EXP 21
5513: PPUSH
5514: LD_STRING D5c-JMM-1
5516: PPUSH
5517: CALL_OW 88
// Say ( un , D6-Mech1-1b ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_STRING D6-Mech1-1b
5528: PPUSH
5529: CALL_OW 88
// DialogueOff ;
5533: CALL_OW 7
// end ; if take_cargo then
5537: LD_VAR 0 7
5541: IFFALSE 5620
// begin x := GetTerminalCargo ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL 943 0 0
5552: ST_TO_ADDR
// if x > 60 then
5553: LD_VAR 0 2
5557: PUSH
5558: LD_INT 60
5560: GREATER
5561: IFFALSE 5571
// x := 60 ;
5563: LD_ADDR_VAR 0 2
5567: PUSH
5568: LD_INT 60
5570: ST_TO_ADDR
// SetResourceType ( GetBase ( terminal ) , mat_siberit , GetTerminalCargo ( ) - x ) ;
5571: LD_EXP 3
5575: PPUSH
5576: CALL_OW 274
5580: PPUSH
5581: LD_INT 3
5583: PPUSH
5584: CALL 943 0 0
5588: PUSH
5589: LD_VAR 0 2
5593: MINUS
5594: PPUSH
5595: CALL_OW 277
// AddCargo ( powell_trans [ 3 ] , mat_siberit , x ) ;
5599: LD_EXP 27
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PPUSH
5608: LD_INT 3
5610: PPUSH
5611: LD_VAR 0 2
5615: PPUSH
5616: CALL_OW 291
// end ; AddComMoveXY ( powell_trans , 43 , 3 ) ;
5620: LD_EXP 27
5624: PPUSH
5625: LD_INT 43
5627: PPUSH
5628: LD_INT 3
5630: PPUSH
5631: CALL_OW 171
// x := 0 0$20 ;
5635: LD_ADDR_VAR 0 2
5639: PUSH
5640: LD_INT 700
5642: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5643: LD_INT 35
5645: PPUSH
5646: CALL_OW 67
// x := x - 0 0$01 ;
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 35
5662: MINUS
5663: ST_TO_ADDR
// until x = 0 0$00 or ( GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 and GetDistUnitXY ( powell_trans [ 3 ] , 43 , 3 ) < 4 ) ;
5664: LD_VAR 0 2
5668: PUSH
5669: LD_INT 0
5671: EQUAL
5672: PUSH
5673: LD_EXP 27
5677: PUSH
5678: LD_INT 3
5680: ARRAY
5681: PPUSH
5682: LD_INT 43
5684: PPUSH
5685: LD_INT 3
5687: PPUSH
5688: CALL_OW 297
5692: PUSH
5693: LD_INT 4
5695: LESS
5696: PUSH
5697: LD_EXP 27
5701: PUSH
5702: LD_INT 3
5704: ARRAY
5705: PPUSH
5706: LD_INT 43
5708: PPUSH
5709: LD_INT 3
5711: PPUSH
5712: CALL_OW 297
5716: PUSH
5717: LD_INT 4
5719: LESS
5720: AND
5721: OR
5722: IFFALSE 5643
// for i in powell_trans do
5724: LD_ADDR_VAR 0 4
5728: PUSH
5729: LD_EXP 27
5733: PUSH
5734: FOR_IN
5735: IFFALSE 5748
// RemoveUnit ( i ) ;
5737: LD_VAR 0 4
5741: PPUSH
5742: CALL_OW 64
5746: GO 5734
5748: POP
5749: POP
// if not powell_happy then
5750: LD_VAR 0 6
5754: NOT
5755: IFFALSE 5766
// powell_happy := - 1 ;
5757: LD_ADDR_VAR 0 6
5761: PUSH
5762: LD_INT 1
5764: NEG
5765: ST_TO_ADDR
// AddMedal ( EarlySiberite , powell_happy ) ;
5766: LD_STRING EarlySiberite
5768: PPUSH
5769: LD_VAR 0 6
5773: PPUSH
5774: CALL_OW 101
// if powell_happy then
5778: LD_VAR 0 6
5782: IFFALSE 5792
// earlySib := true ;
5784: LD_ADDR_EXP 19
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// if powell_happy then
5792: LD_VAR 0 6
5796: IFFALSE 5807
// ChangeMissionObjectives ( M3a ) else
5798: LD_STRING M3a
5800: PPUSH
5801: CALL_OW 337
5805: GO 5814
// ChangeMissionObjectives ( M3b ) ;
5807: LD_STRING M3b
5809: PPUSH
5810: CALL_OW 337
// ru_can_attack_terminal := true ;
5814: LD_ADDR_EXP 9
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// Wait ( 12 12$00 ) ;
5822: LD_INT 25200
5824: PPUSH
5825: CALL_OW 67
// time := 2 2$00 ;
5829: LD_ADDR_VAR 0 8
5833: PUSH
5834: LD_INT 4200
5836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5837: LD_INT 35
5839: PPUSH
5840: CALL_OW 67
// time := time - 0 0$1 ;
5844: LD_ADDR_VAR 0 8
5848: PUSH
5849: LD_VAR 0 8
5853: PUSH
5854: LD_INT 35
5856: MINUS
5857: ST_TO_ADDR
// until not ru_can_attack or ru_force = 0 or time = 0 0$0 ;
5858: LD_EXP 8
5862: NOT
5863: PUSH
5864: LD_EXP 38
5868: PUSH
5869: LD_INT 0
5871: EQUAL
5872: OR
5873: PUSH
5874: LD_VAR 0 8
5878: PUSH
5879: LD_INT 0
5881: EQUAL
5882: OR
5883: IFFALSE 5837
// if ru_force then
5885: LD_EXP 38
5889: IFFALSE 5988
// for i in ru_force do
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_EXP 38
5900: PUSH
5901: FOR_IN
5902: IFFALSE 5986
// if not See ( 1 , i ) and GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) > 10 then
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 4
5911: PPUSH
5912: CALL_OW 292
5916: NOT
5917: PUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: LD_INT 81
5925: PUSH
5926: LD_INT 3
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PPUSH
5938: LD_VAR 0 4
5942: PPUSH
5943: CALL_OW 74
5947: PPUSH
5948: CALL_OW 296
5952: PUSH
5953: LD_INT 10
5955: GREATER
5956: AND
5957: IFFALSE 5984
// begin RemoveUnit ( i ) ;
5959: LD_VAR 0 4
5963: PPUSH
5964: CALL_OW 64
// ru_force := ru_force diff i ;
5968: LD_ADDR_EXP 38
5972: PUSH
5973: LD_EXP 38
5977: PUSH
5978: LD_VAR 0 4
5982: DIFF
5983: ST_TO_ADDR
// end ;
5984: GO 5901
5986: POP
5987: POP
// repeat wait ( 0 0$03 ) ;
5988: LD_INT 105
5990: PPUSH
5991: CALL_OW 67
// until not ru_can_attack or ru_force < 3 ;
5995: LD_EXP 8
5999: NOT
6000: PUSH
6001: LD_EXP 38
6005: PUSH
6006: LD_INT 3
6008: LESS
6009: OR
6010: IFFALSE 5988
// ar_can_arrive := true ;
6012: LD_ADDR_EXP 10
6016: PUSH
6017: LD_INT 1
6019: ST_TO_ADDR
// end ;
6020: PPOPN 8
6022: END
// every 0 0$1 trigger Researched ( 1 , 20 ) do var un ;
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 20
6028: PPUSH
6029: CALL_OW 325
6033: IFFALSE 6180
6035: GO 6037
6037: DISABLE
6038: LD_INT 0
6040: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_class , 4 ] ] ) diff [ JMM , Gary , Cyrus , Bobby , Houten ] ;
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_INT 22
6048: PUSH
6049: LD_INT 1
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PUSH
6056: LD_INT 26
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 25
6068: PUSH
6069: LD_INT 4
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 69
6085: PUSH
6086: LD_EXP 21
6090: PUSH
6091: LD_EXP 22
6095: PUSH
6096: LD_EXP 24
6100: PUSH
6101: LD_EXP 23
6105: PUSH
6106: LD_EXP 25
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: DIFF
6118: ST_TO_ADDR
// if not un then
6119: LD_VAR 0 1
6123: NOT
6124: IFFALSE 6128
// exit ;
6126: GO 6180
// DialogueOn ;
6128: CALL_OW 6
// Say ( un [ 1 ] , D13-Sci1-1 ) ;
6132: LD_VAR 0 1
6136: PUSH
6137: LD_INT 1
6139: ARRAY
6140: PPUSH
6141: LD_STRING D13-Sci1-1
6143: PPUSH
6144: CALL_OW 88
// Say ( JMM , D13-JMM-1 ) ;
6148: LD_EXP 21
6152: PPUSH
6153: LD_STRING D13-JMM-1
6155: PPUSH
6156: CALL_OW 88
// Say ( un [ 1 ] , D13-Sci1-2 ) ;
6160: LD_VAR 0 1
6164: PUSH
6165: LD_INT 1
6167: ARRAY
6168: PPUSH
6169: LD_STRING D13-Sci1-2
6171: PPUSH
6172: CALL_OW 88
// DialogueOff ;
6176: CALL_OW 7
// end ;
6180: PPOPN 1
6182: END
// every 0 0$1 trigger GetTerminalCargo > 77 and not InBattle ( 1 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] do var sci ;
6183: CALL 943 0 0
6187: PUSH
6188: LD_INT 77
6190: GREATER
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 463
6199: NOT
6200: AND
6201: PUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 25
6214: PUSH
6215: LD_INT 4
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 26
6224: PUSH
6225: LD_INT 1
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PPUSH
6237: CALL_OW 69
6241: PUSH
6242: LD_EXP 21
6246: PUSH
6247: LD_EXP 23
6251: PUSH
6252: LD_EXP 24
6256: PUSH
6257: LD_EXP 22
6261: PUSH
6262: LD_EXP 25
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: DIFF
6274: AND
6275: IFFALSE 6453
6277: GO 6279
6279: DISABLE
6280: LD_INT 0
6282: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Gary , Houten ] ;
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: LD_INT 22
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 25
6300: PUSH
6301: LD_INT 4
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: PUSH
6308: LD_INT 26
6310: PUSH
6311: LD_INT 1
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: PUSH
6328: LD_EXP 21
6332: PUSH
6333: LD_EXP 23
6337: PUSH
6338: LD_EXP 24
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: LD_EXP 25
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: DIFF
6360: ST_TO_ADDR
// DialogueOn ;
6361: CALL_OW 6
// Say ( sci [ 1 ] , D7-Sci1-1 ) ;
6365: LD_VAR 0 1
6369: PUSH
6370: LD_INT 1
6372: ARRAY
6373: PPUSH
6374: LD_STRING D7-Sci1-1
6376: PPUSH
6377: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
6381: LD_EXP 21
6385: PPUSH
6386: LD_STRING D7-JMM-1
6388: PPUSH
6389: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-2 ) ;
6393: LD_VAR 0 1
6397: PUSH
6398: LD_INT 1
6400: ARRAY
6401: PPUSH
6402: LD_STRING D7-Sci1-2
6404: PPUSH
6405: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
6409: LD_EXP 21
6413: PPUSH
6414: LD_STRING D7-JMM-2
6416: PPUSH
6417: CALL_OW 88
// Say ( sci [ 1 ] , D7-Sci1-3 ) ;
6421: LD_VAR 0 1
6425: PUSH
6426: LD_INT 1
6428: ARRAY
6429: PPUSH
6430: LD_STRING D7-Sci1-3
6432: PPUSH
6433: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
6437: LD_EXP 21
6441: PPUSH
6442: LD_STRING D7-JMM-3
6444: PPUSH
6445: CALL_OW 88
// DialogueOff ;
6449: CALL_OW 7
// end ;
6453: PPOPN 1
6455: END
// every 0 0$1 trigger ar_can_arrive do var i , x , tmp , dep , time , no_oil_gain , first_warn , b , have_crates , filter ;
6456: LD_EXP 10
6460: IFFALSE 10083
6462: GO 6464
6464: DISABLE
6465: LD_INT 0
6467: PPUSH
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
6472: PPUSH
6473: PPUSH
6474: PPUSH
6475: PPUSH
6476: PPUSH
// begin PrepareArabian ;
6477: CALL 12827 0 0
// blocked := false ;
6481: LD_ADDR_EXP 18
6485: PUSH
6486: LD_INT 0
6488: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6489: LD_INT 35
6491: PPUSH
6492: CALL_OW 67
// until ar_spawned ;
6496: LD_EXP 11
6500: IFFALSE 6489
// have_crates := true ;
6502: LD_ADDR_VAR 0 9
6506: PUSH
6507: LD_INT 1
6509: ST_TO_ADDR
// player_want_info := 2 ;
6510: LD_ADDR_EXP 13
6514: PUSH
6515: LD_INT 2
6517: ST_TO_ADDR
// DialogueOn ;
6518: CALL_OW 6
// SayRadio ( Vervecken , D8-Ar1-1 ) ;
6522: LD_EXP 29
6526: PPUSH
6527: LD_STRING D8-Ar1-1
6529: PPUSH
6530: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
6534: LD_EXP 21
6538: PPUSH
6539: LD_STRING D8-JMM-1
6541: PPUSH
6542: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-2 ) ;
6546: LD_EXP 29
6550: PPUSH
6551: LD_STRING D8-Ar1-2
6553: PPUSH
6554: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
6558: LD_EXP 21
6562: PPUSH
6563: LD_STRING D8-JMM-2
6565: PPUSH
6566: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-3 ) ;
6570: LD_EXP 29
6574: PPUSH
6575: LD_STRING D8-Ar1-3
6577: PPUSH
6578: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
6582: LD_EXP 21
6586: PPUSH
6587: LD_STRING D8-JMM-3
6589: PPUSH
6590: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-4 ) ;
6594: LD_EXP 29
6598: PPUSH
6599: LD_STRING D8-Ar1-4
6601: PPUSH
6602: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
6606: LD_EXP 21
6610: PPUSH
6611: LD_STRING D8-JMM-4
6613: PPUSH
6614: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-5 ) ;
6618: LD_EXP 29
6622: PPUSH
6623: LD_STRING D8-Ar1-5
6625: PPUSH
6626: CALL_OW 94
// Say ( JMM , D8-JMM-5 ) ;
6630: LD_EXP 21
6634: PPUSH
6635: LD_STRING D8-JMM-5
6637: PPUSH
6638: CALL_OW 88
// SayRadio ( Vervecken , D8-Ar1-6 ) ;
6642: LD_EXP 29
6646: PPUSH
6647: LD_STRING D8-Ar1-6
6649: PPUSH
6650: CALL_OW 94
// SayRadio ( Gali , D8-Ar2-6 ) ;
6654: LD_EXP 30
6658: PPUSH
6659: LD_STRING D8-Ar2-6
6661: PPUSH
6662: CALL_OW 94
// Say ( JMM , D8-JMM-6 ) ;
6666: LD_EXP 21
6670: PPUSH
6671: LD_STRING D8-JMM-6
6673: PPUSH
6674: CALL_OW 88
// SayRadio ( Gali , D8-Ar2-7 ) ;
6678: LD_EXP 30
6682: PPUSH
6683: LD_STRING D8-Ar2-7
6685: PPUSH
6686: CALL_OW 94
// case Query ( QBarracks ) of 1 :
6690: LD_STRING QBarracks
6692: PPUSH
6693: CALL_OW 97
6697: PUSH
6698: LD_INT 1
6700: DOUBLE
6701: EQUAL
6702: IFTRUE 6706
6704: GO 6741
6706: POP
// begin Say ( JMM , D8a-JMM-1 ) ;
6707: LD_EXP 21
6711: PPUSH
6712: LD_STRING D8a-JMM-1
6714: PPUSH
6715: CALL_OW 88
// SayRadio ( Vervecken , D8a-Ar1-1 ) ;
6719: LD_EXP 29
6723: PPUSH
6724: LD_STRING D8a-Ar1-1
6726: PPUSH
6727: CALL_OW 94
// player_want_mortar := true ;
6731: LD_ADDR_EXP 12
6735: PUSH
6736: LD_INT 1
6738: ST_TO_ADDR
// end ; 2 :
6739: GO 6915
6741: LD_INT 2
6743: DOUBLE
6744: EQUAL
6745: IFTRUE 6749
6747: GO 6871
6749: POP
// begin Say ( JMM , D8b-JMM-1 ) ;
6750: LD_EXP 21
6754: PPUSH
6755: LD_STRING D8b-JMM-1
6757: PPUSH
6758: CALL_OW 88
// SayRadio ( Vervecken , D8b-Ar1-1 ) ;
6762: LD_EXP 29
6766: PPUSH
6767: LD_STRING D8b-Ar1-1
6769: PPUSH
6770: CALL_OW 94
// case Query ( QInfo ) of 1 :
6774: LD_STRING QInfo
6776: PPUSH
6777: CALL_OW 97
6781: PUSH
6782: LD_INT 1
6784: DOUBLE
6785: EQUAL
6786: IFTRUE 6790
6788: GO 6825
6790: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
6791: LD_EXP 21
6795: PPUSH
6796: LD_STRING D8b1-JMM-1
6798: PPUSH
6799: CALL_OW 88
// SayRadio ( Vervecken , D8b1-Ar1-1 ) ;
6803: LD_EXP 29
6807: PPUSH
6808: LD_STRING D8b1-Ar1-1
6810: PPUSH
6811: CALL_OW 94
// player_want_info := 2 ;
6815: LD_ADDR_EXP 13
6819: PUSH
6820: LD_INT 2
6822: ST_TO_ADDR
// end ; 2 :
6823: GO 6869
6825: LD_INT 2
6827: DOUBLE
6828: EQUAL
6829: IFTRUE 6833
6831: GO 6868
6833: POP
// begin Say ( JMM , D8b2-JMM-1 ) ;
6834: LD_EXP 21
6838: PPUSH
6839: LD_STRING D8b2-JMM-1
6841: PPUSH
6842: CALL_OW 88
// SayRadio ( Vervecken , D8b2-Ar1-1 ) ;
6846: LD_EXP 29
6850: PPUSH
6851: LD_STRING D8b2-Ar1-1
6853: PPUSH
6854: CALL_OW 94
// player_want_info := 0 ;
6858: LD_ADDR_EXP 13
6862: PUSH
6863: LD_INT 0
6865: ST_TO_ADDR
// end ; end ;
6866: GO 6869
6868: POP
// end ; 3 :
6869: GO 6915
6871: LD_INT 3
6873: DOUBLE
6874: EQUAL
6875: IFTRUE 6879
6877: GO 6914
6879: POP
// begin Say ( JMM , D8c-JMM-1 ) ;
6880: LD_EXP 21
6884: PPUSH
6885: LD_STRING D8c-JMM-1
6887: PPUSH
6888: CALL_OW 88
// SayRadio ( Vervecken , D8c-Ar1-1 ) ;
6892: LD_EXP 29
6896: PPUSH
6897: LD_STRING D8c-Ar1-1
6899: PPUSH
6900: CALL_OW 94
// player_want_info := 0 ;
6904: LD_ADDR_EXP 13
6908: PUSH
6909: LD_INT 0
6911: ST_TO_ADDR
// end ; end ;
6912: GO 6915
6914: POP
// DialogueOff ;
6915: CALL_OW 7
// dep := FilterUnitsInArea ( ovsyenkoArea , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: LD_INT 9
6926: PPUSH
6927: LD_INT 2
6929: PUSH
6930: LD_INT 30
6932: PUSH
6933: LD_INT 0
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 30
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: EMPTY
6951: LIST
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 70
6959: ST_TO_ADDR
// if dep then
6960: LD_VAR 0 4
6964: IFFALSE 6980
// dep := dep [ 1 ] ;
6966: LD_ADDR_VAR 0 4
6970: PUSH
6971: LD_VAR 0 4
6975: PUSH
6976: LD_INT 1
6978: ARRAY
6979: ST_TO_ADDR
// if not dep then
6980: LD_VAR 0 4
6984: NOT
6985: IFFALSE 7023
// begin case Query ( QInfoNothing ) of 1 :
6987: LD_STRING QInfoNothing
6989: PPUSH
6990: CALL_OW 97
6994: PUSH
6995: LD_INT 1
6997: DOUBLE
6998: EQUAL
6999: IFTRUE 7003
7001: GO 7006
7003: POP
// ; end ;
7004: GO 7007
7006: POP
// player_want_info := false ;
7007: LD_ADDR_EXP 13
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
// player_want_mortar := false ;
7015: LD_ADDR_EXP 12
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// end ; tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
7023: LD_ADDR_VAR 0 3
7027: PUSH
7028: LD_INT 22
7030: PUSH
7031: LD_INT 2
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 21
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PPUSH
7052: CALL_OW 69
7056: ST_TO_ADDR
// time := 1 1$55 ;
7057: LD_ADDR_VAR 0 5
7061: PUSH
7062: LD_INT 4025
7064: ST_TO_ADDR
// no_oil_gain := false ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_INT 0
7072: ST_TO_ADDR
// first_warn := false ;
7073: LD_ADDR_VAR 0 7
7077: PUSH
7078: LD_INT 0
7080: ST_TO_ADDR
// if player_want_mortar or player_want_info then
7081: LD_EXP 12
7085: PUSH
7086: LD_EXP 13
7090: OR
7091: IFFALSE 7196
// begin ComPlaceRemoteCharge ( UnitFilter ( ar_force , [ f_class , 1 ] ) , GetX ( dep ) , GetY ( dep ) , dep ) ;
7093: LD_EXP 36
7097: PPUSH
7098: LD_INT 25
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: PPUSH
7113: LD_VAR 0 4
7117: PPUSH
7118: CALL_OW 250
7122: PPUSH
7123: LD_VAR 0 4
7127: PPUSH
7128: CALL_OW 251
7132: PPUSH
7133: LD_VAR 0 4
7137: PPUSH
7138: CALL_OW 133
// AddComMoveXY ( UnitFilter ( ar_force , [ f_class , 1 ] ) , 86 , 121 ) ;
7142: LD_EXP 36
7146: PPUSH
7147: LD_INT 25
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PPUSH
7162: LD_INT 86
7164: PPUSH
7165: LD_INT 121
7167: PPUSH
7168: CALL_OW 171
// AddComHold ( UnitFilter ( ar_force , [ f_class , 1 ] ) ) ;
7172: LD_EXP 36
7176: PPUSH
7177: LD_INT 25
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PPUSH
7187: CALL_OW 72
7191: PPUSH
7192: CALL_OW 200
// end ; if player_attacked_ar then
7196: LD_EXP 16
7200: IFFALSE 7204
// exit ;
7202: GO 10083
// if player_want_mortar then
7204: LD_EXP 12
7208: IFFALSE 8745
// begin ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
7210: LD_EXP 30
7214: PPUSH
7215: LD_VAR 0 4
7219: PPUSH
7220: CALL_OW 250
7224: PUSH
7225: LD_INT 1
7227: PLUS
7228: PPUSH
7229: LD_VAR 0 4
7233: PPUSH
7234: CALL_OW 251
7238: PUSH
7239: LD_INT 1
7241: PLUS
7242: PPUSH
7243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7247: LD_INT 35
7249: PPUSH
7250: CALL_OW 67
// until GetDistUnits ( Gali , dep ) < 4 ;
7254: LD_EXP 30
7258: PPUSH
7259: LD_VAR 0 4
7263: PPUSH
7264: CALL_OW 296
7268: PUSH
7269: LD_INT 4
7271: LESS
7272: IFFALSE 7247
// for i = 1 to 6 do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: DOUBLE
7280: LD_INT 1
7282: DEC
7283: ST_TO_ADDR
7284: LD_INT 6
7286: PUSH
7287: FOR_TO
7288: IFFALSE 7492
// begin if player_attacked_ar then
7290: LD_EXP 16
7294: IFFALSE 7300
// exit ;
7296: POP
7297: POP
7298: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
7300: LD_VAR 0 4
7304: PPUSH
7305: CALL_OW 274
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 275
7317: PUSH
7318: LD_INT 10
7320: LESS
7321: PUSH
7322: LD_VAR 0 7
7326: NOT
7327: AND
7328: IFFALSE 7391
// begin first_warn := true ;
7330: LD_ADDR_VAR 0 7
7334: PUSH
7335: LD_INT 1
7337: ST_TO_ADDR
// DialogueOn ;
7338: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
7342: LD_EXP 31
7346: PPUSH
7347: LD_STRING D9a-FAr1-1
7349: PPUSH
7350: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
7354: LD_EXP 21
7358: PPUSH
7359: LD_STRING D9a-JMM-1
7361: PPUSH
7362: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
7366: LD_EXP 29
7370: PPUSH
7371: LD_STRING D9a2-Ar1-1
7373: PPUSH
7374: CALL_OW 88
// DialogueOff ;
7378: CALL_OW 7
// wait ( time ) ;
7382: LD_VAR 0 5
7386: PPUSH
7387: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
7391: LD_VAR 0 4
7395: PPUSH
7396: CALL_OW 274
7400: PPUSH
7401: LD_INT 2
7403: PPUSH
7404: CALL_OW 275
7408: PUSH
7409: LD_INT 10
7411: LESS
7412: IFFALSE 7438
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
7414: LD_EXP 29
7418: PPUSH
7419: LD_STRING D9a3-Ar1-1
7421: PPUSH
7422: CALL_OW 88
// no_oil_gain := true ;
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// break ;
7434: GO 7492
// end else
7436: GO 7490
// begin AddComTransport ( Gali , dep , mat_oil ) ;
7438: LD_EXP 30
7442: PPUSH
7443: LD_VAR 0 4
7447: PPUSH
7448: LD_INT 2
7450: PPUSH
7451: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
7455: LD_EXP 30
7459: PPUSH
7460: LD_VAR 0 3
7464: PUSH
7465: LD_VAR 0 1
7469: PUSH
7470: LD_INT 3
7472: MOD
7473: PUSH
7474: LD_INT 1
7476: PLUS
7477: ARRAY
7478: PPUSH
7479: CALL_OW 210
// wait ( 0 0$10 ) ;
7483: LD_INT 350
7485: PPUSH
7486: CALL_OW 67
// end ; end ;
7490: GO 7287
7492: POP
7493: POP
// if not no_oil_gain then
7494: LD_VAR 0 6
7498: NOT
7499: IFFALSE 8745
// begin repeat wait ( 0 0$01 ) ;
7501: LD_INT 35
7503: PPUSH
7504: CALL_OW 67
// if player_attacked_ar then
7508: LD_EXP 16
7512: IFFALSE 7516
// exit ;
7514: GO 10083
// until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
7516: LD_VAR 0 3
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: CALL_OW 261
7529: PUSH
7530: LD_INT 80
7532: GREATER
7533: PUSH
7534: LD_VAR 0 3
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: PPUSH
7543: CALL_OW 261
7547: PUSH
7548: LD_INT 80
7550: GREATER
7551: AND
7552: PUSH
7553: LD_VAR 0 3
7557: PUSH
7558: LD_INT 3
7560: ARRAY
7561: PPUSH
7562: CALL_OW 261
7566: PUSH
7567: LD_INT 80
7569: GREATER
7570: AND
7571: IFFALSE 7501
// ComMoveXY ( Gali , 105 , 127 ) ;
7573: LD_EXP 30
7577: PPUSH
7578: LD_INT 105
7580: PPUSH
7581: LD_INT 127
7583: PPUSH
7584: CALL_OW 111
// AddComMoveToArea ( Gali , mortarArea ) ;
7588: LD_EXP 30
7592: PPUSH
7593: LD_INT 2
7595: PPUSH
7596: CALL_OW 173
// AddComHold ( Gali ) ;
7600: LD_EXP 30
7604: PPUSH
7605: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7609: LD_INT 35
7611: PPUSH
7612: CALL_OW 67
// if player_attacked_ar then
7616: LD_EXP 16
7620: IFFALSE 7624
// exit ;
7622: GO 10083
// until GetDistUnitXY ( Gali , 105 , 127 ) < 4 ;
7624: LD_EXP 30
7628: PPUSH
7629: LD_INT 105
7631: PPUSH
7632: LD_INT 127
7634: PPUSH
7635: CALL_OW 297
7639: PUSH
7640: LD_INT 4
7642: LESS
7643: IFFALSE 7609
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7645: LD_VAR 0 4
7649: PPUSH
7650: CALL_OW 274
7654: PPUSH
7655: LD_INT 1
7657: PPUSH
7658: CALL_OW 275
7662: PUSH
7663: LD_INT 50
7665: LESS
7666: IFFALSE 7968
// begin case GetResourceType ( GetBase ( dep ) , mat_cans ) of 0 .. 24 :
7668: LD_VAR 0 4
7672: PPUSH
7673: CALL_OW 274
7677: PPUSH
7678: LD_INT 1
7680: PPUSH
7681: CALL_OW 275
7685: PUSH
7686: LD_INT 0
7688: DOUBLE
7689: GREATEREQUAL
7690: IFFALSE 7698
7692: LD_INT 24
7694: DOUBLE
7695: LESSEQUAL
7696: IFTRUE 7700
7698: GO 7715
7700: POP
// Say ( Gali , D9b-Ar2-1 ) ; 25 .. 49 :
7701: LD_EXP 30
7705: PPUSH
7706: LD_STRING D9b-Ar2-1
7708: PPUSH
7709: CALL_OW 88
7713: GO 7745
7715: LD_INT 25
7717: DOUBLE
7718: GREATEREQUAL
7719: IFFALSE 7727
7721: LD_INT 49
7723: DOUBLE
7724: LESSEQUAL
7725: IFTRUE 7729
7727: GO 7744
7729: POP
// Say ( Gali , D9b-Ar2-1a ) ; end ;
7730: LD_EXP 30
7734: PPUSH
7735: LD_STRING D9b-Ar2-1a
7737: PPUSH
7738: CALL_OW 88
7742: GO 7745
7744: POP
// Say ( JMM , D9b-JMM-1 ) ;
7745: LD_EXP 21
7749: PPUSH
7750: LD_STRING D9b-JMM-1
7752: PPUSH
7753: CALL_OW 88
// x := 0 0$0 ;
7757: LD_ADDR_VAR 0 2
7761: PUSH
7762: LD_INT 0
7764: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7765: LD_INT 35
7767: PPUSH
7768: CALL_OW 67
// x := x + 0 0$1 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 35
7784: PLUS
7785: ST_TO_ADDR
// if player_attacked_ar then
7786: LD_EXP 16
7790: IFFALSE 7794
// exit ;
7792: GO 10083
// until x >= time ;
7794: LD_VAR 0 2
7798: PUSH
7799: LD_VAR 0 5
7803: GREATEREQUAL
7804: IFFALSE 7765
// if GetResourceType ( GetBase ( dep ) , mat_cans ) < 50 then
7806: LD_VAR 0 4
7810: PPUSH
7811: CALL_OW 274
7815: PPUSH
7816: LD_INT 1
7818: PPUSH
7819: CALL_OW 275
7823: PUSH
7824: LD_INT 50
7826: LESS
7827: IFFALSE 7968
// begin have_crates := false ;
7829: LD_ADDR_VAR 0 9
7833: PUSH
7834: LD_INT 0
7836: ST_TO_ADDR
// DialogueOn ;
7837: CALL_OW 6
// Say ( Vervecken , D9c-Ar1-1 ) ;
7841: LD_EXP 29
7845: PPUSH
7846: LD_STRING D9c-Ar1-1
7848: PPUSH
7849: CALL_OW 88
// Say ( JMM , D9c-JMM-1 ) ;
7853: LD_EXP 21
7857: PPUSH
7858: LD_STRING D9c-JMM-1
7860: PPUSH
7861: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-2 ) ;
7865: LD_EXP 29
7869: PPUSH
7870: LD_STRING D9c-Ar1-2
7872: PPUSH
7873: CALL_OW 88
// Say ( Bogdanovic , D9c-FAr1-2 ) ;
7877: LD_EXP 31
7881: PPUSH
7882: LD_STRING D9c-FAr1-2
7884: PPUSH
7885: CALL_OW 88
// Say ( Vervecken , D9c-Ar1-3 ) ;
7889: LD_EXP 29
7893: PPUSH
7894: LD_STRING D9c-Ar1-3
7896: PPUSH
7897: CALL_OW 88
// case Query ( QInfo ) of 1 :
7901: LD_STRING QInfo
7903: PPUSH
7904: CALL_OW 97
7908: PUSH
7909: LD_INT 1
7911: DOUBLE
7912: EQUAL
7913: IFTRUE 7917
7915: GO 7940
7917: POP
// begin Say ( JMM , D8b1-JMM-1 ) ;
7918: LD_EXP 21
7922: PPUSH
7923: LD_STRING D8b1-JMM-1
7925: PPUSH
7926: CALL_OW 88
// player_want_info := 2 ;
7930: LD_ADDR_EXP 13
7934: PUSH
7935: LD_INT 2
7937: ST_TO_ADDR
// end ; 2 :
7938: GO 7964
7940: LD_INT 2
7942: DOUBLE
7943: EQUAL
7944: IFTRUE 7948
7946: GO 7963
7948: POP
// begin Say ( Vervecken , D8b2-Ar1-1 ) ;
7949: LD_EXP 29
7953: PPUSH
7954: LD_STRING D8b2-Ar1-1
7956: PPUSH
7957: CALL_OW 88
// end ; end ;
7961: GO 7964
7963: POP
// DialogueOff ;
7964: CALL_OW 7
// end ; end ; if have_crates then
7968: LD_VAR 0 9
7972: IFFALSE 8745
// begin RemoveEnvironmentArea ( mortarArea ) ;
7974: LD_INT 2
7976: PPUSH
7977: CALL_OW 355
// wait ( 1 ) ;
7981: LD_INT 1
7983: PPUSH
7984: CALL_OW 67
// InGameOn ;
7988: CALL_OW 8
// CenterNowOnUnits ( Gali ) ;
7992: LD_EXP 30
7996: PPUSH
7997: CALL_OW 87
// SetSide ( Gali , 1 ) ;
8001: LD_EXP 30
8005: PPUSH
8006: LD_INT 1
8008: PPUSH
8009: CALL_OW 235
// repeat filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_nation , 2 ] ] , [ f_type , unit_human ] , [ f_distxy , 107 , 131 , 6 ] ] ) ;
8013: LD_ADDR_VAR 0 10
8017: PUSH
8018: LD_INT 22
8020: PUSH
8021: LD_INT 1
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: LD_INT 23
8033: PUSH
8034: LD_INT 2
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 21
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 92
8057: PUSH
8058: LD_INT 107
8060: PUSH
8061: LD_INT 131
8063: PUSH
8064: LD_INT 6
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: PPUSH
8079: CALL_OW 69
8083: ST_TO_ADDR
// if filter then
8084: LD_VAR 0 10
8088: IFFALSE 8122
// for i in filter do
8090: LD_ADDR_VAR 0 1
8094: PUSH
8095: LD_VAR 0 10
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8120
// ComMoveXY ( i , 107 , 121 ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_INT 107
8110: PPUSH
8111: LD_INT 121
8113: PPUSH
8114: CALL_OW 111
8118: GO 8100
8120: POP
8121: POP
// ComBuild ( Gali , b_armoury , 107 , 131 , 0 ) ;
8122: LD_EXP 30
8126: PPUSH
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 131
8135: PPUSH
8136: LD_INT 0
8138: PPUSH
8139: CALL_OW 145
// wait ( 0 0$1 ) ;
8143: LD_INT 35
8145: PPUSH
8146: CALL_OW 67
// until FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) ;
8150: LD_INT 30
8152: PUSH
8153: LD_INT 4
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 23
8162: PUSH
8163: LD_INT 2
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: IFFALSE 8013
// SetSide ( Gali , 2 ) ;
8180: LD_EXP 30
8184: PPUSH
8185: LD_INT 2
8187: PPUSH
8188: CALL_OW 235
// InGameOff ;
8192: CALL_OW 9
// b := FilterAllUnits ( [ [ f_btype , b_armoury ] , [ f_nation , nation_arabian ] ] ) [ 1 ] ;
8196: LD_ADDR_VAR 0 8
8200: PUSH
8201: LD_INT 30
8203: PUSH
8204: LD_INT 4
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 23
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 1
8232: ARRAY
8233: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
8234: LD_INT 35
8236: PPUSH
8237: CALL_OW 67
// if player_attacked_ar then
8241: LD_EXP 16
8245: IFFALSE 8249
// exit ;
8247: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8249: LD_VAR 0 8
8253: PPUSH
8254: CALL_OW 461
8258: PUSH
8259: LD_INT 1
8261: NONEQUAL
8262: IFFALSE 8234
// if IsOk ( b ) and GetResourceType ( GetBase ( dep ) , mat_cans ) >= 25 then
8264: LD_VAR 0 8
8268: PPUSH
8269: CALL_OW 302
8273: PUSH
8274: LD_VAR 0 4
8278: PPUSH
8279: CALL_OW 274
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL_OW 275
8291: PUSH
8292: LD_INT 25
8294: GREATEREQUAL
8295: AND
8296: IFFALSE 8395
// begin ComUpgrade ( b ) ;
8298: LD_VAR 0 8
8302: PPUSH
8303: CALL_OW 146
// SetTaskList ( Gali , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
8307: LD_EXP 30
8311: PPUSH
8312: LD_STRING h
8314: PUSH
8315: LD_VAR 0 8
8319: PPUSH
8320: CALL_OW 250
8324: PUSH
8325: LD_VAR 0 8
8329: PPUSH
8330: CALL_OW 251
8334: PUSH
8335: LD_VAR 0 8
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: PPUSH
8361: CALL_OW 446
// repeat wait ( 0 0$01 ) ;
8365: LD_INT 35
8367: PPUSH
8368: CALL_OW 67
// if player_attacked_ar then
8372: LD_EXP 16
8376: IFFALSE 8380
// exit ;
8378: GO 10083
// until BuildingStatus ( b ) <> bs_build ;
8380: LD_VAR 0 8
8384: PPUSH
8385: CALL_OW 461
8389: PUSH
8390: LD_INT 1
8392: NONEQUAL
8393: IFFALSE 8365
// end ; if b then
8395: LD_VAR 0 8
8399: IFFALSE 8410
// CenterNowOnUnits ( b ) ;
8401: LD_VAR 0 8
8405: PPUSH
8406: CALL_OW 87
// DialogueOn ;
8410: CALL_OW 6
// Say ( Gali , D9d-Ar2-1 ) ;
8414: LD_EXP 30
8418: PPUSH
8419: LD_STRING D9d-Ar2-1
8421: PPUSH
8422: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-1 ) ;
8426: LD_EXP 29
8430: PPUSH
8431: LD_STRING D9d-Ar1-1
8433: PPUSH
8434: CALL_OW 88
// Say ( JMM , D9d-JMM-1 ) ;
8438: LD_EXP 21
8442: PPUSH
8443: LD_STRING D9d-JMM-1
8445: PPUSH
8446: CALL_OW 88
// Say ( Vervecken , D9d-Ar1-2 ) ;
8450: LD_EXP 29
8454: PPUSH
8455: LD_STRING D9d-Ar1-2
8457: PPUSH
8458: CALL_OW 88
// DialogueOff ;
8462: CALL_OW 7
// i := [ ] ;
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: EMPTY
8472: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_siberit ) >= 20 then
8473: LD_VAR 0 4
8477: PPUSH
8478: CALL_OW 274
8482: PPUSH
8483: LD_INT 3
8485: PPUSH
8486: CALL_OW 275
8490: PUSH
8491: LD_INT 20
8493: GREATEREQUAL
8494: IFFALSE 8513
// i := i ^ [ 1 ] ;
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_VAR 0 1
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: EMPTY
8510: LIST
8511: ADD
8512: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_cans ) >= 50 then
8513: LD_VAR 0 4
8517: PPUSH
8518: CALL_OW 274
8522: PPUSH
8523: LD_INT 1
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_INT 50
8533: GREATEREQUAL
8534: IFFALSE 8553
// i := i ^ [ 2 ] ;
8536: LD_ADDR_VAR 0 1
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_INT 2
8548: PUSH
8549: EMPTY
8550: LIST
8551: ADD
8552: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep ) , mat_oil ) >= 80 then
8553: LD_VAR 0 4
8557: PPUSH
8558: CALL_OW 274
8562: PPUSH
8563: LD_INT 2
8565: PPUSH
8566: CALL_OW 275
8570: PUSH
8571: LD_INT 80
8573: GREATEREQUAL
8574: IFFALSE 8593
// i := i ^ [ 3 ] ;
8576: LD_ADDR_VAR 0 1
8580: PUSH
8581: LD_VAR 0 1
8585: PUSH
8586: LD_INT 3
8588: PUSH
8589: EMPTY
8590: LIST
8591: ADD
8592: ST_TO_ADDR
// i := i diff 0 ;
8593: LD_ADDR_VAR 0 1
8597: PUSH
8598: LD_VAR 0 1
8602: PUSH
8603: LD_INT 0
8605: DIFF
8606: ST_TO_ADDR
// if i then
8607: LD_VAR 0 1
8611: IFFALSE 8717
// begin i := i ^ [ 4 ] ;
8613: LD_ADDR_VAR 0 1
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 4
8625: PUSH
8626: EMPTY
8627: LIST
8628: ADD
8629: ST_TO_ADDR
// case Query ( QInfo2 ) of 1 :
8630: LD_STRING QInfo2
8632: PPUSH
8633: CALL_OW 97
8637: PUSH
8638: LD_INT 1
8640: DOUBLE
8641: EQUAL
8642: IFTRUE 8646
8644: GO 8657
8646: POP
// player_want_info := 3 ; 2 :
8647: LD_ADDR_EXP 13
8651: PUSH
8652: LD_INT 3
8654: ST_TO_ADDR
8655: GO 8715
8657: LD_INT 2
8659: DOUBLE
8660: EQUAL
8661: IFTRUE 8665
8663: GO 8676
8665: POP
// player_want_info := 1 ; 3 :
8666: LD_ADDR_EXP 13
8670: PUSH
8671: LD_INT 1
8673: ST_TO_ADDR
8674: GO 8715
8676: LD_INT 3
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8695
8684: POP
// player_want_info := 2 ; 4 :
8685: LD_ADDR_EXP 13
8689: PUSH
8690: LD_INT 2
8692: ST_TO_ADDR
8693: GO 8715
8695: LD_INT 4
8697: DOUBLE
8698: EQUAL
8699: IFTRUE 8703
8701: GO 8714
8703: POP
// player_want_info := 0 ; end ;
8704: LD_ADDR_EXP 13
8708: PUSH
8709: LD_INT 0
8711: ST_TO_ADDR
8712: GO 8715
8714: POP
// end else
8715: GO 8745
// case Query ( QInfoNothing ) of 1 :
8717: LD_STRING QInfoNothing
8719: PPUSH
8720: CALL_OW 97
8724: PUSH
8725: LD_INT 1
8727: DOUBLE
8728: EQUAL
8729: IFTRUE 8733
8731: GO 8744
8733: POP
// player_want_info := 0 ; end ;
8734: LD_ADDR_EXP 13
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
8742: GO 8745
8744: POP
// end ; end ; end ; if player_want_info then
8745: LD_EXP 13
8749: IFFALSE 9903
// begin tmp := UnitFilter ( tmp , [ f_weapon , ar_cargo_bay ] ) ;
8751: LD_ADDR_VAR 0 3
8755: PUSH
8756: LD_VAR 0 3
8760: PPUSH
8761: LD_INT 34
8763: PUSH
8764: LD_INT 32
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 72
8775: ST_TO_ADDR
// if player_want_mortar then
8776: LD_EXP 12
8780: IFFALSE 9135
// begin case player_want_info of 1 :
8782: LD_EXP 13
8786: PUSH
8787: LD_INT 1
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8806
8795: POP
// x := 5 ; 2 :
8796: LD_ADDR_VAR 0 2
8800: PUSH
8801: LD_INT 5
8803: ST_TO_ADDR
8804: GO 8845
8806: LD_INT 2
8808: DOUBLE
8809: EQUAL
8810: IFTRUE 8814
8812: GO 8825
8814: POP
// x := 8 ; 3 :
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_INT 8
8822: ST_TO_ADDR
8823: GO 8845
8825: LD_INT 3
8827: DOUBLE
8828: EQUAL
8829: IFTRUE 8833
8831: GO 8844
8833: POP
// x := 2 ; end ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_INT 2
8841: ST_TO_ADDR
8842: GO 8845
8844: POP
// repeat wait ( 0 0$1 ) ;
8845: LD_INT 35
8847: PPUSH
8848: CALL_OW 67
// until not HasTask ( Gali ) ;
8852: LD_EXP 30
8856: PPUSH
8857: CALL_OW 314
8861: NOT
8862: IFFALSE 8845
// time := 0 0$00 ;
8864: LD_ADDR_VAR 0 5
8868: PUSH
8869: LD_INT 0
8871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8872: LD_INT 35
8874: PPUSH
8875: CALL_OW 67
// time := time + 0 0$1 ;
8879: LD_ADDR_VAR 0 5
8883: PUSH
8884: LD_VAR 0 5
8888: PUSH
8889: LD_INT 35
8891: PLUS
8892: ST_TO_ADDR
// if debug then
8893: LD_EXP 2
8897: IFFALSE 8916
// debug_strings := [ time: & time ] ;
8899: LD_ADDR_OWVAR 48
8903: PUSH
8904: LD_STRING time:
8906: PUSH
8907: LD_VAR 0 5
8911: STR
8912: PUSH
8913: EMPTY
8914: LIST
8915: ST_TO_ADDR
// if time > 8 8$00 then
8916: LD_VAR 0 5
8920: PUSH
8921: LD_INT 16800
8923: GREATER
8924: IFFALSE 8936
// begin blocked := true ;
8926: LD_ADDR_EXP 18
8930: PUSH
8931: LD_INT 1
8933: ST_TO_ADDR
// exit ;
8934: GO 10083
// end ; if not Carry ( Gali ) then
8936: LD_EXP 30
8940: PPUSH
8941: CALL_OW 281
8945: NOT
8946: IFFALSE 8969
// ComTransport ( Gali , dep , player_want_info ) else
8948: LD_EXP 30
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: LD_EXP 13
8962: PPUSH
8963: CALL_OW 151
8967: GO 9087
// begin if GetDistUnits ( Gali , tmp [ 1 ] ) < 4 and GetCargo ( Gali , player_want_info ) then
8969: LD_EXP 30
8973: PPUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: CALL_OW 296
8987: PUSH
8988: LD_INT 4
8990: LESS
8991: PUSH
8992: LD_EXP 30
8996: PPUSH
8997: LD_EXP 13
9001: PPUSH
9002: CALL_OW 289
9006: AND
9007: IFFALSE 9069
// begin SetCargo ( tmp [ 1 ] , player_want_info , GetCargo ( tmp [ 1 ] , player_want_info ) + 10 ) ;
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_EXP 13
9022: PPUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ARRAY
9031: PPUSH
9032: LD_EXP 13
9036: PPUSH
9037: CALL_OW 289
9041: PUSH
9042: LD_INT 10
9044: PLUS
9045: PPUSH
9046: CALL_OW 290
// SetCargo ( Gali , player_want_info , 0 ) ;
9050: LD_EXP 30
9054: PPUSH
9055: LD_EXP 13
9059: PPUSH
9060: LD_INT 0
9062: PPUSH
9063: CALL_OW 290
// end else
9067: GO 9087
// ComMoveUnit ( Gali , tmp [ 1 ] ) ;
9069: LD_EXP 30
9073: PPUSH
9074: LD_VAR 0 3
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: CALL_OW 112
// end ; if player_attacked_ar then
9087: LD_EXP 16
9091: IFFALSE 9095
// exit ;
9093: GO 10083
// until GetCargo ( tmp [ 1 ] , player_want_info ) >= x * 10 ;
9095: LD_VAR 0 3
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: PPUSH
9104: LD_EXP 13
9108: PPUSH
9109: CALL_OW 289
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 10
9121: MUL
9122: GREATEREQUAL
9123: IFFALSE 8872
// no_oil_gain := false ;
9125: LD_ADDR_VAR 0 6
9129: PUSH
9130: LD_INT 0
9132: ST_TO_ADDR
// end else
9133: GO 9724
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) ;
9135: LD_ADDR_VAR 0 3
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 2
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 21
9152: PUSH
9153: LD_INT 2
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: ST_TO_ADDR
// ComMoveXY ( Gali , GetX ( dep ) + 1 , GetY ( dep ) + 1 ) ;
9169: LD_EXP 30
9173: PPUSH
9174: LD_VAR 0 4
9178: PPUSH
9179: CALL_OW 250
9183: PUSH
9184: LD_INT 1
9186: PLUS
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: CALL_OW 251
9197: PUSH
9198: LD_INT 1
9200: PLUS
9201: PPUSH
9202: CALL_OW 111
// time := 0 0$00 ;
9206: LD_ADDR_VAR 0 5
9210: PUSH
9211: LD_INT 0
9213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// time := time + 0 0$1 ;
9221: LD_ADDR_VAR 0 5
9225: PUSH
9226: LD_VAR 0 5
9230: PUSH
9231: LD_INT 35
9233: PLUS
9234: ST_TO_ADDR
// if time > 1 1$45 then
9235: LD_VAR 0 5
9239: PUSH
9240: LD_INT 3675
9242: GREATER
9243: IFFALSE 9247
// break ;
9245: GO 9267
// until GetDistUnits ( Gali , dep ) < 4 ;
9247: LD_EXP 30
9251: PPUSH
9252: LD_VAR 0 4
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 4
9264: LESS
9265: IFFALSE 9214
// for i = 1 to 6 do
9267: LD_ADDR_VAR 0 1
9271: PUSH
9272: DOUBLE
9273: LD_INT 1
9275: DEC
9276: ST_TO_ADDR
9277: LD_INT 6
9279: PUSH
9280: FOR_TO
9281: IFFALSE 9485
// begin if player_attacked_ar then
9283: LD_EXP 16
9287: IFFALSE 9293
// exit ;
9289: POP
9290: POP
9291: GO 10083
// if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 and not first_warn then
9293: LD_VAR 0 4
9297: PPUSH
9298: CALL_OW 274
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 275
9310: PUSH
9311: LD_INT 10
9313: LESS
9314: PUSH
9315: LD_VAR 0 7
9319: NOT
9320: AND
9321: IFFALSE 9384
// begin first_warn := true ;
9323: LD_ADDR_VAR 0 7
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
// DialogueOn ;
9331: CALL_OW 6
// Say ( Bogdanovic , D9a-FAr1-1 ) ;
9335: LD_EXP 31
9339: PPUSH
9340: LD_STRING D9a-FAr1-1
9342: PPUSH
9343: CALL_OW 88
// Say ( JMM , D9a-JMM-1 ) ;
9347: LD_EXP 21
9351: PPUSH
9352: LD_STRING D9a-JMM-1
9354: PPUSH
9355: CALL_OW 88
// Say ( Vervecken , D9a2-Ar1-1 ) ;
9359: LD_EXP 29
9363: PPUSH
9364: LD_STRING D9a2-Ar1-1
9366: PPUSH
9367: CALL_OW 88
// DialogueOff ;
9371: CALL_OW 7
// wait ( time ) ;
9375: LD_VAR 0 5
9379: PPUSH
9380: CALL_OW 67
// end ; if GetResourceType ( GetBase ( dep ) , mat_oil ) < 10 then
9384: LD_VAR 0 4
9388: PPUSH
9389: CALL_OW 274
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 275
9401: PUSH
9402: LD_INT 10
9404: LESS
9405: IFFALSE 9431
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9407: LD_EXP 29
9411: PPUSH
9412: LD_STRING D9a3-Ar1-1
9414: PPUSH
9415: CALL_OW 88
// no_oil_gain := true ;
9419: LD_ADDR_VAR 0 6
9423: PUSH
9424: LD_INT 1
9426: ST_TO_ADDR
// break ;
9427: GO 9485
// end else
9429: GO 9483
// begin AddComTransport ( Gali , dep , mat_oil ) ;
9431: LD_EXP 30
9435: PPUSH
9436: LD_VAR 0 4
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 211
// AddComRefuel ( Gali , tmp [ i mod 3 + 1 ] ) ;
9448: LD_EXP 30
9452: PPUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_VAR 0 1
9462: PUSH
9463: LD_INT 3
9465: MOD
9466: PUSH
9467: LD_INT 1
9469: PLUS
9470: ARRAY
9471: PPUSH
9472: CALL_OW 210
// wait ( 0 0$10 ) ;
9476: LD_INT 350
9478: PPUSH
9479: CALL_OW 67
// end ; end ;
9483: GO 9280
9485: POP
9486: POP
// time := 0 0$00 ;
9487: LD_ADDR_VAR 0 5
9491: PUSH
9492: LD_INT 0
9494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9495: LD_INT 35
9497: PPUSH
9498: CALL_OW 67
// if not HasTask ( Gali ) then
9502: LD_EXP 30
9506: PPUSH
9507: CALL_OW 314
9511: NOT
9512: IFFALSE 9528
// time := time + 0 0$1 ;
9514: LD_ADDR_VAR 0 5
9518: PUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_INT 35
9526: PLUS
9527: ST_TO_ADDR
// if time > 1 1$25 then
9528: LD_VAR 0 5
9532: PUSH
9533: LD_INT 2975
9535: GREATER
9536: IFFALSE 9560
// begin Say ( Vervecken , D9a3-Ar1-1 ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING D9a3-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// no_oil_gain := true ;
9550: LD_ADDR_VAR 0 6
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// break ;
9558: GO 9724
// end ; if player_attacked_ar then
9560: LD_EXP 16
9564: IFFALSE 9568
// exit ;
9566: GO 10083
// for i in tmp do
9568: LD_ADDR_VAR 0 1
9572: PUSH
9573: LD_VAR 0 3
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9610
// if GetFuel ( i ) < 100 then
9581: LD_VAR 0 1
9585: PPUSH
9586: CALL_OW 261
9590: PUSH
9591: LD_INT 100
9593: LESS
9594: IFFALSE 9608
// begin x := i ;
9596: LD_ADDR_VAR 0 2
9600: PUSH
9601: LD_VAR 0 1
9605: ST_TO_ADDR
// break ;
9606: GO 9610
// end ;
9608: GO 9578
9610: POP
9611: POP
// if not HasTask ( Gali ) and not Carry ( Gali ) then
9612: LD_EXP 30
9616: PPUSH
9617: CALL_OW 314
9621: NOT
9622: PUSH
9623: LD_EXP 30
9627: PPUSH
9628: CALL_OW 281
9632: NOT
9633: AND
9634: IFFALSE 9667
// begin ComTransport ( Gali , dep , mat_oil ) ;
9636: LD_EXP 30
9640: PPUSH
9641: LD_VAR 0 4
9645: PPUSH
9646: LD_INT 2
9648: PPUSH
9649: CALL_OW 151
// AddComRefuel ( Gali , x ) ;
9653: LD_EXP 30
9657: PPUSH
9658: LD_VAR 0 2
9662: PPUSH
9663: CALL_OW 210
// end ; until ( GetFuel ( tmp [ 1 ] ) > 80 and GetFuel ( tmp [ 2 ] ) > 80 and GetFuel ( tmp [ 3 ] ) > 80 ) ;
9667: LD_VAR 0 3
9671: PUSH
9672: LD_INT 1
9674: ARRAY
9675: PPUSH
9676: CALL_OW 261
9680: PUSH
9681: LD_INT 80
9683: GREATER
9684: PUSH
9685: LD_VAR 0 3
9689: PUSH
9690: LD_INT 2
9692: ARRAY
9693: PPUSH
9694: CALL_OW 261
9698: PUSH
9699: LD_INT 80
9701: GREATER
9702: AND
9703: PUSH
9704: LD_VAR 0 3
9708: PUSH
9709: LD_INT 3
9711: ARRAY
9712: PPUSH
9713: CALL_OW 261
9717: PUSH
9718: LD_INT 80
9720: GREATER
9721: AND
9722: IFFALSE 9495
// end ; ComHold ( Gali ) ;
9724: LD_EXP 30
9728: PPUSH
9729: CALL_OW 140
// if not no_oil_gain then
9733: LD_VAR 0 6
9737: NOT
9738: IFFALSE 9903
// begin DialogueOn ;
9740: CALL_OW 6
// CenterNowOnUnits ( Vervecken ) ;
9744: LD_EXP 29
9748: PPUSH
9749: CALL_OW 87
// if player_want_mortar then
9753: LD_EXP 12
9757: IFFALSE 9783
// begin Say ( Vervecken , D9e-Ar1-1 ) ;
9759: LD_EXP 29
9763: PPUSH
9764: LD_STRING D9e-Ar1-1
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D10a-JMM-1 ) ;
9771: LD_EXP 21
9775: PPUSH
9776: LD_STRING D10a-JMM-1
9778: PPUSH
9779: CALL_OW 88
// end ; Say ( Vervecken , D10a-Ar1-1 ) ;
9783: LD_EXP 29
9787: PPUSH
9788: LD_STRING D10a-Ar1-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Gali , D10a-Ar2-1 ) ;
9795: LD_EXP 30
9799: PPUSH
9800: LD_STRING D10a-Ar2-1
9802: PPUSH
9803: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-1 ) ;
9807: LD_EXP 31
9811: PPUSH
9812: LD_STRING D10a-FAr1-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Gali , D10a-Ar2-2 ) ;
9819: LD_EXP 30
9823: PPUSH
9824: LD_STRING D10a-Ar2-2
9826: PPUSH
9827: CALL_OW 88
// Say ( Bogdanovic , D10a-FAr1-2 ) ;
9831: LD_EXP 31
9835: PPUSH
9836: LD_STRING D10a-FAr1-2
9838: PPUSH
9839: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-2 ) ;
9843: LD_EXP 29
9847: PPUSH
9848: LD_STRING D10a-Ar1-2
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
9855: LD_EXP 21
9859: PPUSH
9860: LD_STRING D10a-JMM-2
9862: PPUSH
9863: CALL_OW 88
// Say ( Vervecken , D10a-Ar1-3 ) ;
9867: LD_EXP 29
9871: PPUSH
9872: LD_STRING D10a-Ar1-3
9874: PPUSH
9875: CALL_OW 88
// Say ( JMM , D10a-JMM-3 ) ;
9879: LD_EXP 21
9883: PPUSH
9884: LD_STRING D10a-JMM-3
9886: PPUSH
9887: CALL_OW 88
// player_get_info := true ;
9891: LD_ADDR_EXP 15
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// DialogueOff ;
9899: CALL_OW 7
// end ; end ; if player_attacked_ar then
9903: LD_EXP 16
9907: IFFALSE 9911
// exit ;
9909: GO 10083
// if player_want_mortar or player_want_info then
9911: LD_EXP 12
9915: PUSH
9916: LD_EXP 13
9920: OR
9921: IFFALSE 9935
// Say ( Vervecken , D9f-Ar1-1 ) ;
9923: LD_EXP 29
9927: PPUSH
9928: LD_STRING D9f-Ar1-1
9930: PPUSH
9931: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
9935: LD_INT 22
9937: PUSH
9938: LD_INT 2
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: PPUSH
9945: CALL_OW 69
9949: PPUSH
9950: LD_INT 51
9952: PPUSH
9953: LD_INT 99
9955: PPUSH
9956: CALL_OW 111
// wait ( 0 0$1 ) ;
9960: LD_INT 35
9962: PPUSH
9963: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
9967: LD_INT 22
9969: PUSH
9970: LD_INT 2
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 92
9979: PUSH
9980: LD_INT 51
9982: PUSH
9983: LD_INT 99
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: PPUSH
9999: CALL_OW 69
10003: IFFALSE 10063
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_INT 2
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 92
10022: PUSH
10023: LD_INT 51
10025: PUSH
10026: LD_INT 99
10028: PUSH
10029: LD_INT 2
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PPUSH
10042: CALL_OW 69
10046: PUSH
10047: FOR_IN
10048: IFFALSE 10061
// RemoveUnit ( i ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: CALL_OW 64
10059: GO 10047
10061: POP
10062: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10063: LD_INT 22
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: PUSH
10078: LD_INT 0
10080: EQUAL
10081: IFFALSE 9935
// end ;
10083: PPOPN 10
10085: END
// every 0 0$01 trigger blocked do var i ;
10086: LD_EXP 18
10090: IFFALSE 10258
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
// begin Say ( Vervecken , D9f-Ar1-1 ) ;
10098: LD_EXP 29
10102: PPUSH
10103: LD_STRING D9f-Ar1-1
10105: PPUSH
10106: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10110: LD_INT 22
10112: PUSH
10113: LD_INT 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_INT 51
10127: PPUSH
10128: LD_INT 99
10130: PPUSH
10131: CALL_OW 111
// wait ( 0 0$1 ) ;
10135: LD_INT 35
10137: PPUSH
10138: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10142: LD_INT 22
10144: PUSH
10145: LD_INT 2
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: PUSH
10152: LD_INT 92
10154: PUSH
10155: LD_INT 51
10157: PUSH
10158: LD_INT 99
10160: PUSH
10161: LD_INT 2
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: IFFALSE 10238
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10180: LD_ADDR_VAR 0 1
10184: PUSH
10185: LD_INT 22
10187: PUSH
10188: LD_INT 2
10190: PUSH
10191: EMPTY
10192: LIST
10193: LIST
10194: PUSH
10195: LD_INT 92
10197: PUSH
10198: LD_INT 51
10200: PUSH
10201: LD_INT 99
10203: PUSH
10204: LD_INT 2
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PPUSH
10217: CALL_OW 69
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// RemoveUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 64
10234: GO 10222
10236: POP
10237: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10238: LD_INT 22
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PUSH
10253: LD_INT 0
10255: EQUAL
10256: IFFALSE 10110
// end ;
10258: PPOPN 1
10260: END
// every 0 0$1 trigger player_attacked_ar do var i , tmp , mine_launched , x ;
10261: LD_EXP 16
10265: IFFALSE 10618
10267: GO 10269
10269: DISABLE
10270: LD_INT 0
10272: PPUSH
10273: PPUSH
10274: PPUSH
10275: PPUSH
// begin ru_can_attack := true ;
10276: LD_ADDR_EXP 8
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// mine_launched := false ;
10284: LD_ADDR_VAR 0 3
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10292: LD_INT 22
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PPUSH
10302: CALL_OW 69
10306: PPUSH
10307: LD_INT 51
10309: PPUSH
10310: LD_INT 99
10312: PPUSH
10313: CALL_OW 111
// if IsOk ( Vervecken ) then
10317: LD_EXP 29
10321: PPUSH
10322: CALL_OW 302
10326: IFFALSE 10340
// Say ( Vervecken , D11a-Ar1-1 ) ;
10328: LD_EXP 29
10332: PPUSH
10333: LD_STRING D11a-Ar1-1
10335: PPUSH
10336: CALL_OW 88
// tmp := UnitFilter ( ar_force , [ f_class , 1 ] ) ;
10340: LD_ADDR_VAR 0 2
10344: PUSH
10345: LD_EXP 36
10349: PPUSH
10350: LD_INT 25
10352: PUSH
10353: LD_INT 1
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 72
10364: ST_TO_ADDR
// for i in tmp do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_VAR 0 2
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10439
// if MineOfUnit ( i ) then
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 459
10387: IFFALSE 10437
// begin x := MineOfUnit ( i ) ;
10389: LD_ADDR_VAR 0 4
10393: PUSH
10394: LD_VAR 0 1
10398: PPUSH
10399: CALL_OW 459
10403: ST_TO_ADDR
// mine_launched := true ;
10404: LD_ADDR_VAR 0 3
10408: PUSH
10409: LD_INT 1
10411: ST_TO_ADDR
// LaunchMineAtPos ( x [ 1 ] , x [ 2 ] , 2 ) ;
10412: LD_VAR 0 4
10416: PUSH
10417: LD_INT 1
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_INT 2
10428: ARRAY
10429: PPUSH
10430: LD_INT 2
10432: PPUSH
10433: CALL_OW 456
// end ;
10437: GO 10375
10439: POP
10440: POP
// if mine_launched and IsOk ( Vervecken ) then
10441: LD_VAR 0 3
10445: PUSH
10446: LD_EXP 29
10450: PPUSH
10451: CALL_OW 302
10455: AND
10456: IFFALSE 10470
// Say ( Vervecken , D11b-Ar1-1 ) ;
10458: LD_EXP 29
10462: PPUSH
10463: LD_STRING D11b-Ar1-1
10465: PPUSH
10466: CALL_OW 88
// repeat ComMoveXY ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10470: LD_INT 22
10472: PUSH
10473: LD_INT 2
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PPUSH
10480: CALL_OW 69
10484: PPUSH
10485: LD_INT 51
10487: PPUSH
10488: LD_INT 99
10490: PPUSH
10491: CALL_OW 111
// wait ( 0 0$1 ) ;
10495: LD_INT 35
10497: PPUSH
10498: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10502: LD_INT 22
10504: PUSH
10505: LD_INT 2
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 92
10514: PUSH
10515: LD_INT 51
10517: PUSH
10518: LD_INT 99
10520: PUSH
10521: LD_INT 2
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IFFALSE 10598
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 22
10547: PUSH
10548: LD_INT 2
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 92
10557: PUSH
10558: LD_INT 51
10560: PUSH
10561: LD_INT 99
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: PUSH
10582: FOR_IN
10583: IFFALSE 10596
// RemoveUnit ( i ) ;
10585: LD_VAR 0 1
10589: PPUSH
10590: CALL_OW 64
10594: GO 10582
10596: POP
10597: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PUSH
10613: LD_INT 0
10615: EQUAL
10616: IFFALSE 10470
// end ;
10618: PPOPN 4
10620: END
// every 0 0$1 trigger ar_can_arrive do var i ;
10621: LD_EXP 10
10625: IFFALSE 10804
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
// begin Wait ( 10 10$00 ) ;
10633: LD_INT 21000
10635: PPUSH
10636: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) then
10640: LD_INT 22
10642: PUSH
10643: LD_INT 2
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: IFFALSE 10804
// begin repeat ComAgressiveMove ( FilterAllUnits ( [ f_side , 2 ] ) , 51 , 99 ) ;
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 69
10670: PPUSH
10671: LD_INT 51
10673: PPUSH
10674: LD_INT 99
10676: PPUSH
10677: CALL_OW 114
// wait ( 0 0$1 ) ;
10681: LD_INT 35
10683: PPUSH
10684: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) then
10688: LD_INT 22
10690: PUSH
10691: LD_INT 2
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 92
10700: PUSH
10701: LD_INT 51
10703: PUSH
10704: LD_INT 99
10706: PUSH
10707: LD_INT 2
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: EMPTY
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 69
10724: IFFALSE 10784
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 51 , 99 , 2 ] ] ) do
10726: LD_ADDR_VAR 0 1
10730: PUSH
10731: LD_INT 22
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 92
10743: PUSH
10744: LD_INT 51
10746: PUSH
10747: LD_INT 99
10749: PUSH
10750: LD_INT 2
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10782
// RemoveUnit ( i ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 64
10780: GO 10768
10782: POP
10783: POP
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
10784: LD_INT 22
10786: PUSH
10787: LD_INT 2
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: PUSH
10799: LD_INT 0
10801: EQUAL
10802: IFFALSE 10656
// end ; end ;
10804: PPOPN 1
10806: END
// every 0 0$1 trigger jmm_in_ovsyenko do var i , tmp , sib , m1 , m2 , m3 ;
10807: LD_EXP 4
10811: IFFALSE 11866
10813: GO 10815
10815: DISABLE
10816: LD_INT 0
10818: PPUSH
10819: PPUSH
10820: PPUSH
10821: PPUSH
10822: PPUSH
10823: PPUSH
// begin Wait ( game_time ) ;
10824: LD_EXP 7
10828: PPUSH
10829: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10833: LD_INT 35
10835: PPUSH
10836: CALL_OW 67
// until ( not ru_can_attack ) ;
10840: LD_EXP 8
10844: NOT
10845: IFFALSE 10833
// Wait ( 0 0$35 ) ;
10847: LD_INT 1225
10849: PPUSH
10850: CALL_OW 67
// DialogueOn ;
10854: CALL_OW 6
// InGameOn ;
10858: CALL_OW 8
// SayRadio ( Powell , D12-Pow-1 ) ;
10862: LD_EXP 28
10866: PPUSH
10867: LD_STRING D12-Pow-1
10869: PPUSH
10870: CALL_OW 94
// InGameOff ;
10874: CALL_OW 9
// DialogueOff ;
10878: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
10882: LD_STRING M4
10884: PPUSH
10885: CALL_OW 337
// SetAreaMapShow ( endMissionArea , 1 ) ;
10889: LD_INT 5
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 424
// can_end := true ;
10899: LD_ADDR_EXP 17
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10907: LD_INT 35
10909: PPUSH
10910: CALL_OW 67
// until GetTerminalCargo >= 20 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) <= FilterUnitsInArea ( endMissionArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 1 ] , [ f_driving ] ] ) ;
10914: CALL 943 0 0
10918: PUSH
10919: LD_INT 20
10921: GREATEREQUAL
10922: PUSH
10923: LD_INT 22
10925: PUSH
10926: LD_INT 1
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 21
10935: PUSH
10936: LD_INT 1
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: PPUSH
10947: CALL_OW 69
10951: PUSH
10952: LD_INT 5
10954: PPUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 70
10983: PUSH
10984: LD_INT 22
10986: PUSH
10987: LD_INT 1
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 55
10996: PUSH
10997: EMPTY
10998: LIST
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PPUSH
11004: CALL_OW 69
11008: PLUS
11009: LESSEQUAL
11010: AND
11011: IFFALSE 10907
// if not player_get_info then
11013: LD_EXP 15
11017: NOT
11018: IFFALSE 11029
// player_get_info := - 1 ;
11020: LD_ADDR_EXP 15
11024: PUSH
11025: LD_INT 1
11027: NEG
11028: ST_TO_ADDR
// m1 := player_get_info > 0 ;
11029: LD_ADDR_VAR 0 4
11033: PUSH
11034: LD_EXP 15
11038: PUSH
11039: LD_INT 0
11041: GREATER
11042: ST_TO_ADDR
// m2 := false ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// m3 := earlySib ;
11051: LD_ADDR_VAR 0 6
11055: PUSH
11056: LD_EXP 19
11060: ST_TO_ADDR
// AddMedal ( Information , player_get_info ) ;
11061: LD_STRING Information
11063: PPUSH
11064: LD_EXP 15
11068: PPUSH
11069: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
11073: LD_ADDR_VAR 0 2
11077: PUSH
11078: LD_INT 22
11080: PUSH
11081: LD_INT 1
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 2
11090: PUSH
11091: LD_INT 25
11093: PUSH
11094: LD_INT 2
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 25
11103: PUSH
11104: LD_INT 16
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 34
11113: PUSH
11114: LD_INT 12
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PPUSH
11131: CALL_OW 69
11135: ST_TO_ADDR
// sib := GetTerminalCargo ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: CALL 943 0 0
11145: ST_TO_ADDR
// sib := sib + GetResourceArea ( terminalArea , mat_siberit ) ;
11146: LD_ADDR_VAR 0 3
11150: PUSH
11151: LD_VAR 0 3
11155: PUSH
11156: LD_INT 6
11158: PPUSH
11159: LD_INT 3
11161: PPUSH
11162: CALL_OW 287
11166: PLUS
11167: ST_TO_ADDR
// sib := sib + GetCargo ( tmp , mat_siberit ) ;
11168: LD_ADDR_VAR 0 3
11172: PUSH
11173: LD_VAR 0 3
11177: PUSH
11178: LD_VAR 0 2
11182: PPUSH
11183: LD_INT 3
11185: PPUSH
11186: CALL_OW 289
11190: PLUS
11191: ST_TO_ADDR
// if sib < ( 2 + Difficulty ) * 50 then
11192: LD_VAR 0 3
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_OWVAR 67
11204: PLUS
11205: PUSH
11206: LD_INT 50
11208: MUL
11209: LESS
11210: IFFALSE 11235
// AddMedal ( MuchSiberite , - 2 * Difficulty + 1 ) else
11212: LD_STRING MuchSiberite
11214: PPUSH
11215: LD_INT 2
11217: NEG
11218: PUSH
11219: LD_OWVAR 67
11223: MUL
11224: PUSH
11225: LD_INT 1
11227: PLUS
11228: PPUSH
11229: CALL_OW 101
11233: GO 11253
// begin AddMedal ( MuchSiberite , 1 ) ;
11235: LD_STRING MuchSiberite
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 101
// m2 := true ;
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 1
11252: ST_TO_ADDR
// end ; if m1 and m2 and m3 and Difficulty = 3 then
11253: LD_VAR 0 4
11257: PUSH
11258: LD_VAR 0 5
11262: AND
11263: PUSH
11264: LD_VAR 0 6
11268: AND
11269: PUSH
11270: LD_OWVAR 67
11274: PUSH
11275: LD_INT 3
11277: EQUAL
11278: AND
11279: IFFALSE 11291
// SetAchievementEX ( ACH_AMER , 9 ) ;
11281: LD_STRING ACH_AMER
11283: PPUSH
11284: LD_INT 9
11286: PPUSH
11287: CALL_OW 564
// if tick <= 55 55$00 then
11291: LD_OWVAR 1
11295: PUSH
11296: LD_INT 115500
11298: LESSEQUAL
11299: IFFALSE 11308
// SetAchievement ( ACH_ASPEED_9 ) ;
11301: LD_STRING ACH_ASPEED_9
11303: PPUSH
11304: CALL_OW 543
// GiveMedals ( MAIN ) ;
11308: LD_STRING MAIN
11310: PPUSH
11311: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ) ;
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PUSH
11325: LD_INT 2
11327: PUSH
11328: LD_INT 25
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 25
11340: PUSH
11341: LD_INT 2
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 25
11350: PUSH
11351: LD_INT 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: LD_INT 25
11360: PUSH
11361: LD_INT 4
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 25
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PPUSH
11395: CALL_OW 43
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 8 ] ] ) ;
11399: LD_ADDR_VAR 0 2
11403: PUSH
11404: LD_INT 22
11406: PUSH
11407: LD_INT 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 25
11416: PUSH
11417: LD_INT 8
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 69
11432: ST_TO_ADDR
// if tmp then
11433: LD_VAR 0 2
11437: IFFALSE 11468
// for i in tmp do
11439: LD_ADDR_VAR 0 1
11443: PUSH
11444: LD_VAR 0 2
11448: PUSH
11449: FOR_IN
11450: IFFALSE 11466
// SetClass ( i , 1 ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 336
11464: GO 11449
11466: POP
11467: POP
// SaveVariable ( sib , 09_sibRes ) ;
11468: LD_VAR 0 3
11472: PPUSH
11473: LD_STRING 09_sibRes
11475: PPUSH
11476: CALL_OW 39
// SaveVariable ( player_get_info , 09_arInfo ) ;
11480: LD_EXP 15
11484: PPUSH
11485: LD_STRING 09_arInfo
11487: PPUSH
11488: CALL_OW 39
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11492: LD_EXP 21
11496: PPUSH
11497: LD_EXP 1
11501: PUSH
11502: LD_STRING JMM
11504: STR
11505: PPUSH
11506: CALL_OW 38
// if IsLive ( Gary ) then
11510: LD_EXP 22
11514: PPUSH
11515: CALL_OW 300
11519: IFFALSE 11539
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
11521: LD_EXP 22
11525: PPUSH
11526: LD_EXP 1
11530: PUSH
11531: LD_STRING Gary
11533: STR
11534: PPUSH
11535: CALL_OW 38
// if IsLive ( Bobby ) then
11539: LD_EXP 23
11543: PPUSH
11544: CALL_OW 300
11548: IFFALSE 11568
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11550: LD_EXP 23
11554: PPUSH
11555: LD_EXP 1
11559: PUSH
11560: LD_STRING Bobby
11562: STR
11563: PPUSH
11564: CALL_OW 38
// if IsLive ( Cyrus ) then
11568: LD_EXP 24
11572: PPUSH
11573: CALL_OW 300
11577: IFFALSE 11597
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11579: LD_EXP 24
11583: PPUSH
11584: LD_EXP 1
11588: PUSH
11589: LD_STRING Cyrus
11591: STR
11592: PPUSH
11593: CALL_OW 38
// if IsLive ( Houten ) then
11597: LD_EXP 25
11601: PPUSH
11602: CALL_OW 300
11606: IFFALSE 11626
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
11608: LD_EXP 25
11612: PPUSH
11613: LD_EXP 1
11617: PUSH
11618: LD_STRING Houten
11620: STR
11621: PPUSH
11622: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Cyrus , Bobby , Houten , Gary ] ;
11626: LD_ADDR_VAR 0 2
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 2
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 25
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 25
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 25
11676: PUSH
11677: LD_INT 4
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 21
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 23
11714: PUSH
11715: LD_EXP 25
11719: PUSH
11720: LD_EXP 22
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: DIFF
11732: ST_TO_ADDR
// if tmp then
11733: LD_VAR 0 2
11737: IFFALSE 11757
// SaveCharacters ( tmp , mission_prefix & others ) ;
11739: LD_VAR 0 2
11743: PPUSH
11744: LD_EXP 1
11748: PUSH
11749: LD_STRING others
11751: STR
11752: PPUSH
11753: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) ;
11757: LD_ADDR_VAR 0 2
11761: PUSH
11762: LD_INT 22
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 2
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 12
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: LD_INT 25
11787: PUSH
11788: LD_INT 16
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PPUSH
11804: CALL_OW 69
11808: ST_TO_ADDR
// if tmp then
11809: LD_VAR 0 2
11813: IFFALSE 11833
// SaveCharacters ( tmp , mission_prefix & apes ) ;
11815: LD_VAR 0 2
11819: PPUSH
11820: LD_EXP 1
11824: PUSH
11825: LD_STRING apes
11827: STR
11828: PPUSH
11829: CALL_OW 38
// if IsLive ( Yakotich ) then
11833: LD_EXP 37
11837: PPUSH
11838: CALL_OW 300
11842: IFFALSE 11862
// SaveCharacters ( Yakotich , mission_prefix & Yakotich ) ;
11844: LD_EXP 37
11848: PPUSH
11849: LD_EXP 1
11853: PUSH
11854: LD_STRING Yakotich
11856: STR
11857: PPUSH
11858: CALL_OW 38
// YouWin ;
11862: CALL_OW 103
// end ; end_of_file
11866: PPOPN 6
11868: END
// on BuildingStarted ( b , eng ) do begin if GetBType ( b ) = b_depot and not terminal then
11869: LD_VAR 0 1
11873: PPUSH
11874: CALL_OW 266
11878: PUSH
11879: LD_INT 0
11881: EQUAL
11882: PUSH
11883: LD_EXP 3
11887: NOT
11888: AND
11889: IFFALSE 11913
// begin terminal := b ;
11891: LD_ADDR_EXP 3
11895: PUSH
11896: LD_VAR 0 1
11900: ST_TO_ADDR
// SetBName ( terminal , terminal ) ;
11901: LD_EXP 3
11905: PPUSH
11906: LD_STRING terminal
11908: PPUSH
11909: CALL_OW 500
// end ; end ;
11913: PPOPN 2
11915: END
// on BuildingComplete ( b ) do var i ;
11916: LD_INT 0
11918: PPUSH
// begin if GetSide ( b ) = 3 then
11919: LD_VAR 0 1
11923: PPUSH
11924: CALL_OW 255
11928: PUSH
11929: LD_INT 3
11931: EQUAL
11932: IFFALSE 11972
// for i = 1 to 4 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 4
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11970
// ru_rebuild := Delete ( ru_rebuild , 1 ) ;
11950: LD_ADDR_EXP 39
11954: PUSH
11955: LD_EXP 39
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 3
11967: ST_TO_ADDR
11968: GO 11947
11970: POP
11971: POP
// end ;
11972: PPOPN 2
11974: END
// on VehicleConstructed ( veh , fac ) do var i ;
11975: LD_INT 0
11977: PPUSH
// begin if GetSide ( veh ) = 3 then
11978: LD_VAR 0 1
11982: PPUSH
11983: CALL_OW 255
11987: PUSH
11988: LD_INT 3
11990: EQUAL
11991: IFFALSE 12116
// begin if not GetWeapon ( veh ) in [ ru_bulldozer , ru_crane , ru_cargo_bay ] then
11993: LD_VAR 0 1
11997: PPUSH
11998: CALL_OW 264
12002: PUSH
12003: LD_INT 53
12005: PUSH
12006: LD_INT 52
12008: PUSH
12009: LD_INT 51
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: LIST
12016: IN
12017: NOT
12018: IFFALSE 12036
// ru_force := ru_force ^ veh ;
12020: LD_ADDR_EXP 38
12024: PUSH
12025: LD_EXP 38
12029: PUSH
12030: LD_VAR 0 1
12034: ADD
12035: ST_TO_ADDR
// for i = 1 to 4 do
12036: LD_ADDR_VAR 0 3
12040: PUSH
12041: DOUBLE
12042: LD_INT 1
12044: DEC
12045: ST_TO_ADDR
12046: LD_INT 4
12048: PUSH
12049: FOR_TO
12050: IFFALSE 12072
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
12052: LD_ADDR_EXP 40
12056: PUSH
12057: LD_EXP 40
12061: PPUSH
12062: LD_INT 1
12064: PPUSH
12065: CALL_OW 3
12069: ST_TO_ADDR
12070: GO 12049
12072: POP
12073: POP
// if GetWeapon ( veh ) = ru_bulldozer then
12074: LD_VAR 0 1
12078: PPUSH
12079: CALL_OW 264
12083: PUSH
12084: LD_INT 53
12086: EQUAL
12087: IFFALSE 12116
// begin CutTreeInArea ( veh , cutTreeArea ) ;
12089: LD_VAR 0 1
12093: PPUSH
12094: LD_INT 7
12096: PPUSH
12097: CALL 1101 0 2
// AddComMoveXY ( veh , 170 , 235 ) ;
12101: LD_VAR 0 1
12105: PPUSH
12106: LD_INT 170
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 171
// end ; end ; end ;
12116: PPOPN 3
12118: END
// on Contact ( s1 , s2 ) do begin if ( s1 = 1 and s2 = 2 ) or ( s1 = 2 and s2 = 1 ) then
12119: LD_VAR 0 1
12123: PUSH
12124: LD_INT 1
12126: EQUAL
12127: PUSH
12128: LD_VAR 0 2
12132: PUSH
12133: LD_INT 2
12135: EQUAL
12136: AND
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 2
12145: EQUAL
12146: PUSH
12147: LD_VAR 0 2
12151: PUSH
12152: LD_INT 1
12154: EQUAL
12155: AND
12156: OR
12157: IFFALSE 12167
// player_attacked_ar := true ;
12159: LD_ADDR_EXP 16
12163: PUSH
12164: LD_INT 1
12166: ST_TO_ADDR
// if ( s1 = 1 and s2 = 4 ) or ( s1 = 4 and s2 = 1 ) then
12167: LD_VAR 0 1
12171: PUSH
12172: LD_INT 1
12174: EQUAL
12175: PUSH
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 4
12183: EQUAL
12184: AND
12185: PUSH
12186: LD_VAR 0 1
12190: PUSH
12191: LD_INT 4
12193: EQUAL
12194: PUSH
12195: LD_VAR 0 2
12199: PUSH
12200: LD_INT 1
12202: EQUAL
12203: AND
12204: OR
12205: IFFALSE 12214
// YouLost ( Traitor ) ;
12207: LD_STRING Traitor
12209: PPUSH
12210: CALL_OW 104
// end ;
12214: PPOPN 2
12216: END
// on UnitDestroyed ( un ) do begin if un = JMM then
12217: LD_VAR 0 1
12221: PUSH
12222: LD_EXP 21
12226: EQUAL
12227: IFFALSE 12236
// YouLost ( JMM ) ;
12229: LD_STRING JMM
12231: PPUSH
12232: CALL_OW 104
// if un = terminal then
12236: LD_VAR 0 1
12240: PUSH
12241: LD_EXP 3
12245: EQUAL
12246: IFFALSE 12255
// YouLost ( Terminal ) ;
12248: LD_STRING Terminal
12250: PPUSH
12251: CALL_OW 104
// if GetWeapon ( un ) = ru_bulldozer then
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 264
12264: PUSH
12265: LD_INT 53
12267: EQUAL
12268: IFFALSE 12284
// bulldozerCounter := bulldozerCounter + 1 ;
12270: LD_ADDR_EXP 20
12274: PUSH
12275: LD_EXP 20
12279: PUSH
12280: LD_INT 1
12282: PLUS
12283: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) then
12284: LD_VAR 0 1
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 3
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 21
12301: PUSH
12302: LD_INT 3
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PPUSH
12313: CALL_OW 69
12317: IN
12318: IFFALSE 12464
// begin if GetBType ( un ) in [ b_turret , b_oil_power ] then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 266
12329: PUSH
12330: LD_INT 33
12332: PUSH
12333: LD_INT 26
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: IN
12340: IFFALSE 12399
// ru_rebuild := ru_rebuild ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12342: LD_ADDR_EXP 39
12346: PUSH
12347: LD_EXP 39
12351: PUSH
12352: LD_VAR 0 1
12356: PPUSH
12357: CALL_OW 266
12361: PUSH
12362: LD_VAR 0 1
12366: PPUSH
12367: CALL_OW 250
12371: PUSH
12372: LD_VAR 0 1
12376: PPUSH
12377: CALL_OW 251
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 254
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: ADD
12398: ST_TO_ADDR
// if GetBType ( un ) = b_barracks then
12399: LD_VAR 0 1
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_INT 5
12411: EQUAL
12412: IFFALSE 12464
// ru_rebuild := ru_rebuild ^ [ b_armoury , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
12414: LD_ADDR_EXP 39
12418: PUSH
12419: LD_EXP 39
12423: PUSH
12424: LD_INT 4
12426: PUSH
12427: LD_VAR 0 1
12431: PPUSH
12432: CALL_OW 250
12436: PUSH
12437: LD_VAR 0 1
12441: PPUSH
12442: CALL_OW 251
12446: PUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: ADD
12463: ST_TO_ADDR
// end ; if un in ru_force then
12464: LD_VAR 0 1
12468: PUSH
12469: LD_EXP 38
12473: IN
12474: IFFALSE 12510
// begin ru_force := ru_force diff un ;
12476: LD_ADDR_EXP 38
12480: PUSH
12481: LD_EXP 38
12485: PUSH
12486: LD_VAR 0 1
12490: DIFF
12491: ST_TO_ADDR
// if ru_force = 0 then
12492: LD_EXP 38
12496: PUSH
12497: LD_INT 0
12499: EQUAL
12500: IFFALSE 12510
// ru_can_attack := false ;
12502: LD_ADDR_EXP 8
12506: PUSH
12507: LD_INT 0
12509: ST_TO_ADDR
// end ; end ;
12510: PPOPN 1
12512: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12513: LD_VAR 0 1
12517: PPUSH
12518: CALL 28757 0 1
// end ; end_of_file
12522: PPOPN 1
12524: END
// every 0 0$01 trigger powell_want_sib and powell_want_sib_counter do var sib ;
12525: LD_EXP 5
12529: PUSH
12530: LD_EXP 6
12534: AND
12535: IFFALSE 12620
12537: GO 12539
12539: DISABLE
12540: LD_INT 0
12542: PPUSH
// begin enable ;
12543: ENABLE
// sib := 60 - GetTerminalCargo ( ) ;
12544: LD_ADDR_VAR 0 1
12548: PUSH
12549: LD_INT 60
12551: PUSH
12552: CALL 943 0 0
12556: MINUS
12557: ST_TO_ADDR
// if sib < 0 then
12558: LD_VAR 0 1
12562: PUSH
12563: LD_INT 0
12565: LESS
12566: IFFALSE 12576
// sib := 0 ;
12568: LD_ADDR_VAR 0 1
12572: PUSH
12573: LD_INT 0
12575: ST_TO_ADDR
// if not debug then
12576: LD_EXP 2
12580: NOT
12581: IFFALSE 12606
// display_strings := [ #Am09-1 , sib , powell_want_sib_counter ] ;
12583: LD_ADDR_OWVAR 47
12587: PUSH
12588: LD_STRING #Am09-1
12590: PUSH
12591: LD_VAR 0 1
12595: PUSH
12596: LD_EXP 6
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: LIST
12605: ST_TO_ADDR
// powell_want_sib_counter := powell_want_sib_counter - 0 0$01 ;
12606: LD_ADDR_EXP 6
12610: PUSH
12611: LD_EXP 6
12615: PUSH
12616: LD_INT 35
12618: MINUS
12619: ST_TO_ADDR
// end ;
12620: PPOPN 1
12622: END
// every 0 0$1 trigger powell_want_sib_counter = 0 0$00 do
12623: LD_EXP 6
12627: PUSH
12628: LD_INT 0
12630: EQUAL
12631: IFFALSE 12643
12633: GO 12635
12635: DISABLE
// display_strings := [ ] ;
12636: LD_ADDR_OWVAR 47
12640: PUSH
12641: EMPTY
12642: ST_TO_ADDR
12643: END
// every 1 1$35 do var i , tmp ;
12644: GO 12646
12646: DISABLE
12647: LD_INT 0
12649: PPUSH
12650: PPUSH
// begin tmp := [ 0 0$33 , 0 0$35 , 0 0$41 ] [ Difficulty ] ;
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: LD_INT 1155
12658: PUSH
12659: LD_INT 1225
12661: PUSH
12662: LD_INT 1435
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: LD_OWVAR 67
12674: ARRAY
12675: ST_TO_ADDR
// i := 0 ;
12676: LD_ADDR_VAR 0 1
12680: PUSH
12681: LD_INT 0
12683: ST_TO_ADDR
// repeat CreateCratesXYR ( rand ( 1 , 5 ) , 75 , 75 , 20 , true ) ;
12684: LD_INT 1
12686: PPUSH
12687: LD_INT 5
12689: PPUSH
12690: CALL_OW 12
12694: PPUSH
12695: LD_INT 75
12697: PPUSH
12698: LD_INT 75
12700: PPUSH
12701: LD_INT 20
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL_OW 56
// wait ( tmp ) ;
12711: LD_VAR 0 2
12715: PPUSH
12716: CALL_OW 67
// tmp := tmp + rand ( 0 0$3 , 0 0$9 ) ;
12720: LD_ADDR_VAR 0 2
12724: PUSH
12725: LD_VAR 0 2
12729: PUSH
12730: LD_INT 105
12732: PPUSH
12733: LD_INT 315
12735: PPUSH
12736: CALL_OW 12
12740: PLUS
12741: ST_TO_ADDR
// i := i + 1 ;
12742: LD_ADDR_VAR 0 1
12746: PUSH
12747: LD_VAR 0 1
12751: PUSH
12752: LD_INT 1
12754: PLUS
12755: ST_TO_ADDR
// if i mod 3 = 0 and jmm_in_ovsyenko then
12756: LD_VAR 0 1
12760: PUSH
12761: LD_INT 3
12763: MOD
12764: PUSH
12765: LD_INT 0
12767: EQUAL
12768: PUSH
12769: LD_EXP 4
12773: AND
12774: IFFALSE 12812
// begin CreateCratesArea ( rand ( 2 , 5 ) , cratesArea , true ) ;
12776: LD_INT 2
12778: PPUSH
12779: LD_INT 5
12781: PPUSH
12782: CALL_OW 12
12786: PPUSH
12787: LD_INT 8
12789: PPUSH
12790: LD_INT 1
12792: PPUSH
12793: CALL_OW 55
// wait ( rand ( 0 0$19 , 0 0$21 ) ) ;
12797: LD_INT 665
12799: PPUSH
12800: LD_INT 735
12802: PPUSH
12803: CALL_OW 12
12807: PPUSH
12808: CALL_OW 67
// end ; until tick > game_time ;
12812: LD_OWVAR 1
12816: PUSH
12817: LD_EXP 7
12821: GREATER
12822: IFFALSE 12684
// end ; end_of_file
12824: PPOPN 2
12826: END
// export Vervecken , Gali , Bogdanovic , Kantor , Herczeg , Ronn , Mia ; export ar_force ; export function PrepareArabian ; var veh , tmp , i , x , y ; begin
12827: LD_INT 0
12829: PPUSH
12830: PPUSH
12831: PPUSH
12832: PPUSH
12833: PPUSH
12834: PPUSH
// x := 76 ;
12835: LD_ADDR_VAR 0 5
12839: PUSH
12840: LD_INT 76
12842: ST_TO_ADDR
// y := 147 ;
12843: LD_ADDR_VAR 0 6
12847: PUSH
12848: LD_INT 147
12850: ST_TO_ADDR
// uc_side := 2 ;
12851: LD_ADDR_OWVAR 20
12855: PUSH
12856: LD_INT 2
12858: ST_TO_ADDR
// uc_nation := 2 ;
12859: LD_ADDR_OWVAR 21
12863: PUSH
12864: LD_INT 2
12866: ST_TO_ADDR
// InitHc ;
12867: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 6
12879: PPUSH
12880: CALL_OW 380
// hc_name := Nicolas Vervecken ;
12884: LD_ADDR_OWVAR 26
12888: PUSH
12889: LD_STRING Nicolas Vervecken
12891: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12892: LD_ADDR_OWVAR 33
12896: PUSH
12897: LD_STRING SecondCharsGal
12899: ST_TO_ADDR
// hc_face_number := 3 ;
12900: LD_ADDR_OWVAR 34
12904: PUSH
12905: LD_INT 3
12907: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
12908: LD_ADDR_OWVAR 29
12912: PUSH
12913: LD_INT 11
12915: PUSH
12916: LD_INT 10
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: ST_TO_ADDR
// Vervecken := CreateHuman ;
12923: LD_ADDR_EXP 29
12927: PUSH
12928: CALL_OW 44
12932: ST_TO_ADDR
// ar_force := Vervecken ;
12933: LD_ADDR_EXP 36
12937: PUSH
12938: LD_EXP 29
12942: ST_TO_ADDR
// PrepareHuman ( sex_male , 2 , 6 ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 2
12948: PPUSH
12949: LD_INT 6
12951: PPUSH
12952: CALL_OW 380
// hc_name := Louis Gali ;
12956: LD_ADDR_OWVAR 26
12960: PUSH
12961: LD_STRING Louis Gali
12963: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
12964: LD_ADDR_OWVAR 33
12968: PUSH
12969: LD_STRING SecondCharsGal
12971: ST_TO_ADDR
// hc_face_number := 2 ;
12972: LD_ADDR_OWVAR 34
12976: PUSH
12977: LD_INT 2
12979: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
12980: LD_ADDR_OWVAR 29
12984: PUSH
12985: LD_INT 10
12987: PUSH
12988: LD_INT 11
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// Gali := CreateHuman ;
12995: LD_ADDR_EXP 30
12999: PUSH
13000: CALL_OW 44
13004: ST_TO_ADDR
// ar_force := ar_force ^ Gali ;
13005: LD_ADDR_EXP 36
13009: PUSH
13010: LD_EXP 36
13014: PUSH
13015: LD_EXP 30
13019: ADD
13020: ST_TO_ADDR
// PrepareHuman ( sex_female , 1 , 6 ) ;
13021: LD_INT 2
13023: PPUSH
13024: LD_INT 1
13026: PPUSH
13027: LD_INT 6
13029: PPUSH
13030: CALL_OW 380
// hc_name := Maria Bogdanovic ;
13034: LD_ADDR_OWVAR 26
13038: PUSH
13039: LD_STRING Maria Bogdanovic
13041: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13042: LD_ADDR_OWVAR 33
13046: PUSH
13047: LD_STRING SecondCharsGal
13049: ST_TO_ADDR
// hc_face_number := 14 ;
13050: LD_ADDR_OWVAR 34
13054: PUSH
13055: LD_INT 14
13057: ST_TO_ADDR
// hc_attr := [ 12 , 9 ] ;
13058: LD_ADDR_OWVAR 29
13062: PUSH
13063: LD_INT 12
13065: PUSH
13066: LD_INT 9
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: ST_TO_ADDR
// Bogdanovic := CreateHuman ;
13073: LD_ADDR_EXP 31
13077: PUSH
13078: CALL_OW 44
13082: ST_TO_ADDR
// ar_force := ar_force ^ Bogdanovic ;
13083: LD_ADDR_EXP 36
13087: PUSH
13088: LD_EXP 36
13092: PUSH
13093: LD_EXP 31
13097: ADD
13098: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13099: LD_INT 1
13101: PPUSH
13102: LD_INT 3
13104: PPUSH
13105: LD_INT 6
13107: PPUSH
13108: CALL_OW 380
// hc_name = Kntor Radomr ;
13112: LD_ADDR_OWVAR 26
13116: PUSH
13117: LD_STRING Kntor Radomr
13119: ST_TO_ADDR
// hc_gallery = sandar ;
13120: LD_ADDR_OWVAR 33
13124: PUSH
13125: LD_STRING sandar
13127: ST_TO_ADDR
// hc_face_number = 12 ;
13128: LD_ADDR_OWVAR 34
13132: PUSH
13133: LD_INT 12
13135: ST_TO_ADDR
// hc_attr = [ 9 , 9 ] ;
13136: LD_ADDR_OWVAR 29
13140: PUSH
13141: LD_INT 9
13143: PUSH
13144: LD_INT 9
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: ST_TO_ADDR
// Kantor = CreateHuman ;
13151: LD_ADDR_EXP 32
13155: PUSH
13156: CALL_OW 44
13160: ST_TO_ADDR
// ar_force := ar_force ^ Kantor ;
13161: LD_ADDR_EXP 36
13165: PUSH
13166: LD_EXP 36
13170: PUSH
13171: LD_EXP 32
13175: ADD
13176: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 6 ) ;
13177: LD_INT 1
13179: PPUSH
13180: LD_INT 3
13182: PPUSH
13183: LD_INT 6
13185: PPUSH
13186: CALL_OW 380
// hc_name = Herczeg Farkas ;
13190: LD_ADDR_OWVAR 26
13194: PUSH
13195: LD_STRING Herczeg Farkas
13197: ST_TO_ADDR
// hc_gallery = sandar ;
13198: LD_ADDR_OWVAR 33
13202: PUSH
13203: LD_STRING sandar
13205: ST_TO_ADDR
// hc_face_number = 28 ;
13206: LD_ADDR_OWVAR 34
13210: PUSH
13211: LD_INT 28
13213: ST_TO_ADDR
// hc_attr = [ 10 , 9 ] ;
13214: LD_ADDR_OWVAR 29
13218: PUSH
13219: LD_INT 10
13221: PUSH
13222: LD_INT 9
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: ST_TO_ADDR
// Herczeg = CreateHuman ;
13229: LD_ADDR_EXP 33
13233: PUSH
13234: CALL_OW 44
13238: ST_TO_ADDR
// ar_force := ar_force ^ Herczeg ;
13239: LD_ADDR_EXP 36
13243: PUSH
13244: LD_EXP 36
13248: PUSH
13249: LD_EXP 33
13253: ADD
13254: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 6 ) ;
13255: LD_INT 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: LD_INT 6
13263: PPUSH
13264: CALL_OW 380
// hc_name = Ronn Horntvedt ;
13268: LD_ADDR_OWVAR 26
13272: PUSH
13273: LD_STRING Ronn Horntvedt
13275: ST_TO_ADDR
// hc_gallery = sandar ;
13276: LD_ADDR_OWVAR 33
13280: PUSH
13281: LD_STRING sandar
13283: ST_TO_ADDR
// hc_face_number = 29 ;
13284: LD_ADDR_OWVAR 34
13288: PUSH
13289: LD_INT 29
13291: ST_TO_ADDR
// hc_attr = [ 11 , 11 ] ;
13292: LD_ADDR_OWVAR 29
13296: PUSH
13297: LD_INT 11
13299: PUSH
13300: LD_INT 11
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: ST_TO_ADDR
// Ronn = CreateHuman ;
13307: LD_ADDR_EXP 34
13311: PUSH
13312: CALL_OW 44
13316: ST_TO_ADDR
// ar_force := ar_force ^ Ronn ;
13317: LD_ADDR_EXP 36
13321: PUSH
13322: LD_EXP 36
13326: PUSH
13327: LD_EXP 34
13331: ADD
13332: ST_TO_ADDR
// PrepareHuman ( sex_female , 3 , 6 ) ;
13333: LD_INT 2
13335: PPUSH
13336: LD_INT 3
13338: PPUSH
13339: LD_INT 6
13341: PPUSH
13342: CALL_OW 380
// hc_name = Mia D. Mathiasen ;
13346: LD_ADDR_OWVAR 26
13350: PUSH
13351: LD_STRING Mia D. Mathiasen
13353: ST_TO_ADDR
// hc_gallery = sandar ;
13354: LD_ADDR_OWVAR 33
13358: PUSH
13359: LD_STRING sandar
13361: ST_TO_ADDR
// hc_face_number = 31 ;
13362: LD_ADDR_OWVAR 34
13366: PUSH
13367: LD_INT 31
13369: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
13370: LD_ADDR_OWVAR 29
13374: PUSH
13375: LD_INT 10
13377: PUSH
13378: LD_INT 10
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: ST_TO_ADDR
// Mia = CreateHuman ;
13385: LD_ADDR_EXP 35
13389: PUSH
13390: CALL_OW 44
13394: ST_TO_ADDR
// ar_force := ar_force ^ Mia ;
13395: LD_ADDR_EXP 36
13399: PUSH
13400: LD_EXP 36
13404: PUSH
13405: LD_EXP 35
13409: ADD
13410: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_cargo_bay , 30 ) ;
13411: LD_ADDR_VAR 0 3
13415: PUSH
13416: LD_VAR 0 3
13420: PUSH
13421: LD_INT 2
13423: PPUSH
13424: LD_INT 2
13426: PPUSH
13427: LD_INT 14
13429: PPUSH
13430: LD_INT 1
13432: PPUSH
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 32
13438: PPUSH
13439: LD_INT 30
13441: PPUSH
13442: CALL 423 0 7
13446: ADD
13447: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gun , 30 ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_VAR 0 3
13457: PUSH
13458: LD_INT 2
13460: PPUSH
13461: LD_INT 2
13463: PPUSH
13464: LD_INT 14
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: LD_INT 1
13472: PPUSH
13473: LD_INT 27
13475: PPUSH
13476: LD_INT 30
13478: PPUSH
13479: CALL 423 0 7
13483: ADD
13484: ST_TO_ADDR
// tmp := tmp ^ PrepareTank ( 2 , 2 , ar_half_tracked , engine_combustion , control_manual , ar_gatling_gun , 33 ) ;
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_VAR 0 3
13494: PUSH
13495: LD_INT 2
13497: PPUSH
13498: LD_INT 2
13500: PPUSH
13501: LD_INT 14
13503: PPUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: LD_INT 25
13512: PPUSH
13513: LD_INT 33
13515: PPUSH
13516: CALL 423 0 7
13520: ADD
13521: ST_TO_ADDR
// tmp := tmp diff 0 ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_INT 0
13534: DIFF
13535: ST_TO_ADDR
// for i in ar_force do
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_EXP 36
13545: PUSH
13546: FOR_IN
13547: IFFALSE 13690
// begin if GetClass ( i ) = 3 then
13549: LD_VAR 0 4
13553: PPUSH
13554: CALL_OW 257
13558: PUSH
13559: LD_INT 3
13561: EQUAL
13562: IFFALSE 13644
// begin SetDir ( tmp [ 1 ] , 1 ) ;
13564: LD_VAR 0 3
13568: PUSH
13569: LD_INT 1
13571: ARRAY
13572: PPUSH
13573: LD_INT 1
13575: PPUSH
13576: CALL_OW 233
// PlaceUnitXY ( tmp [ 1 ] , x , y , false ) ;
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: PPUSH
13589: LD_VAR 0 5
13593: PPUSH
13594: LD_VAR 0 6
13598: PPUSH
13599: LD_INT 0
13601: PPUSH
13602: CALL_OW 48
// PlaceHumanInUnit ( i , tmp [ 1 ] ) ;
13606: LD_VAR 0 4
13610: PPUSH
13611: LD_VAR 0 3
13615: PUSH
13616: LD_INT 1
13618: ARRAY
13619: PPUSH
13620: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
13624: LD_ADDR_VAR 0 3
13628: PUSH
13629: LD_VAR 0 3
13633: PPUSH
13634: LD_INT 1
13636: PPUSH
13637: CALL_OW 3
13641: ST_TO_ADDR
// end else
13642: GO 13666
// PlaceUnitXY ( i , x , y , false ) ;
13644: LD_VAR 0 4
13648: PPUSH
13649: LD_VAR 0 5
13653: PPUSH
13654: LD_VAR 0 6
13658: PPUSH
13659: LD_INT 0
13661: PPUSH
13662: CALL_OW 48
// ComMoveXY ( i , 86 , 121 ) ;
13666: LD_VAR 0 4
13670: PPUSH
13671: LD_INT 86
13673: PPUSH
13674: LD_INT 121
13676: PPUSH
13677: CALL_OW 111
// wait ( 0 0$2 ) ;
13681: LD_INT 70
13683: PPUSH
13684: CALL_OW 67
// end ;
13688: GO 13546
13690: POP
13691: POP
// ar_force := ar_force ^ tmp ;
13692: LD_ADDR_EXP 36
13696: PUSH
13697: LD_EXP 36
13701: PUSH
13702: LD_VAR 0 3
13706: ADD
13707: ST_TO_ADDR
// ar_spawned := true ;
13708: LD_ADDR_EXP 11
13712: PUSH
13713: LD_INT 1
13715: ST_TO_ADDR
// end ; end_of_file
13716: LD_VAR 0 1
13720: RET
// export Yakotich ; export ru_force , ru_rebuild , ru_produce_list ; export function PrepareRussian ; var i , un , tmp , skill , lab , dep ; begin
13721: LD_INT 0
13723: PPUSH
13724: PPUSH
13725: PPUSH
13726: PPUSH
13727: PPUSH
13728: PPUSH
13729: PPUSH
// InitHc ;
13730: CALL_OW 19
// uc_side := 3 ;
13734: LD_ADDR_OWVAR 20
13738: PUSH
13739: LD_INT 3
13741: ST_TO_ADDR
// uc_nation := 3 ;
13742: LD_ADDR_OWVAR 21
13746: PUSH
13747: LD_INT 3
13749: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
13750: LD_ADDR_VAR 0 5
13754: PUSH
13755: LD_INT 5
13757: PUSH
13758: LD_INT 6
13760: PUSH
13761: LD_INT 7
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: ST_TO_ADDR
// ru_force := [ ] ;
13775: LD_ADDR_EXP 38
13779: PUSH
13780: EMPTY
13781: ST_TO_ADDR
// ru_rebuild := [ ] ;
13782: LD_ADDR_EXP 39
13786: PUSH
13787: EMPTY
13788: ST_TO_ADDR
// ru_produce_list := [ ] ;
13789: LD_ADDR_EXP 40
13793: PUSH
13794: EMPTY
13795: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13796: LD_ADDR_VAR 0 6
13800: PUSH
13801: LD_INT 22
13803: PUSH
13804: LD_INT 3
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: PUSH
13811: LD_INT 30
13813: PUSH
13814: LD_INT 8
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PPUSH
13825: CALL_OW 69
13829: PUSH
13830: LD_INT 1
13832: ARRAY
13833: ST_TO_ADDR
// tmp := [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ;
13834: LD_ADDR_VAR 0 4
13838: PUSH
13839: LD_INT 43
13841: PUSH
13842: LD_INT 46
13844: PUSH
13845: LD_INT 45
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13853: LD_ADDR_VAR 0 7
13857: PUSH
13858: LD_INT 22
13860: PUSH
13861: LD_INT 3
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: LD_INT 30
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 69
13886: PUSH
13887: LD_INT 1
13889: ARRAY
13890: ST_TO_ADDR
// SetResourceType ( GetBase ( dep ) , mat_cans , 5000 ) ;
13891: LD_VAR 0 7
13895: PPUSH
13896: CALL_OW 274
13900: PPUSH
13901: LD_INT 1
13903: PPUSH
13904: LD_INT 5000
13906: PPUSH
13907: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_oil , 1000 ) ;
13911: LD_VAR 0 7
13915: PPUSH
13916: CALL_OW 274
13920: PPUSH
13921: LD_INT 2
13923: PPUSH
13924: LD_INT 1000
13926: PPUSH
13927: CALL_OW 277
// SetResourceType ( GetBase ( dep ) , mat_siberit , 30 ) ;
13931: LD_VAR 0 7
13935: PPUSH
13936: CALL_OW 274
13940: PPUSH
13941: LD_INT 3
13943: PPUSH
13944: LD_INT 30
13946: PPUSH
13947: CALL_OW 277
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 3
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: PUSH
13985: FOR_IN
13986: IFFALSE 14019
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
13988: LD_VAR 0 2
13992: PPUSH
13993: LD_INT 5
13995: PUSH
13996: LD_INT 6
13998: PUSH
13999: LD_INT 7
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: LIST
14006: PUSH
14007: LD_OWVAR 67
14011: ARRAY
14012: PPUSH
14013: CALL_OW 241
14017: GO 13985
14019: POP
14020: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) do
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 22
14028: PUSH
14029: LD_INT 3
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PUSH
14036: LD_INT 30
14038: PUSH
14039: LD_INT 33
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PPUSH
14050: CALL_OW 69
14054: PUSH
14055: FOR_IN
14056: IFFALSE 14088
// PlaceWeaponTurret ( i , tmp [ i mod 3 + 1 ] ) ;
14058: LD_VAR 0 2
14062: PPUSH
14063: LD_VAR 0 4
14067: PUSH
14068: LD_VAR 0 2
14072: PUSH
14073: LD_INT 3
14075: MOD
14076: PUSH
14077: LD_INT 1
14079: PLUS
14080: ARRAY
14081: PPUSH
14082: CALL_OW 431
14086: GO 14055
14088: POP
14089: POP
// for i = 1 to 4 do
14090: LD_ADDR_VAR 0 2
14094: PUSH
14095: DOUBLE
14096: LD_INT 1
14098: DEC
14099: ST_TO_ADDR
14100: LD_INT 4
14102: PUSH
14103: FOR_TO
14104: IFFALSE 14165
// begin PrepareHuman ( false , class_bazooker , skill ) ;
14106: LD_INT 0
14108: PPUSH
14109: LD_INT 9
14111: PPUSH
14112: LD_VAR 0 5
14116: PPUSH
14117: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_barracks ] ] ) [ 1 ] ) ;
14121: CALL_OW 44
14125: PPUSH
14126: LD_INT 22
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 30
14138: PUSH
14139: LD_INT 5
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PPUSH
14150: CALL_OW 69
14154: PUSH
14155: LD_INT 1
14157: ARRAY
14158: PPUSH
14159: CALL_OW 52
// end ;
14163: GO 14103
14165: POP
14166: POP
// for i = 1 to 5 do
14167: LD_ADDR_VAR 0 2
14171: PUSH
14172: DOUBLE
14173: LD_INT 1
14175: DEC
14176: ST_TO_ADDR
14177: LD_INT 5
14179: PUSH
14180: FOR_TO
14181: IFFALSE 14242
// begin PrepareHuman ( false , class_mechanic , skill ) ;
14183: LD_INT 0
14185: PPUSH
14186: LD_INT 3
14188: PPUSH
14189: LD_VAR 0 5
14193: PPUSH
14194: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
14198: CALL_OW 44
14202: PPUSH
14203: LD_INT 22
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 3
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 69
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: PPUSH
14236: CALL_OW 52
// end ;
14240: GO 14180
14242: POP
14243: POP
// for i = 1 to 4 do
14244: LD_ADDR_VAR 0 2
14248: PUSH
14249: DOUBLE
14250: LD_INT 1
14252: DEC
14253: ST_TO_ADDR
14254: LD_INT 4
14256: PUSH
14257: FOR_TO
14258: IFFALSE 14319
// begin PrepareHuman ( false , class_engineer , skill ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 2
14265: PPUSH
14266: LD_VAR 0 5
14270: PPUSH
14271: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_INT 22
14282: PUSH
14283: LD_INT 3
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: PUSH
14290: LD_INT 30
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: PPUSH
14304: CALL_OW 69
14308: PUSH
14309: LD_INT 1
14311: ARRAY
14312: PPUSH
14313: CALL_OW 52
// end ;
14317: GO 14257
14319: POP
14320: POP
// for i = 1 to 3 do
14321: LD_ADDR_VAR 0 2
14325: PUSH
14326: DOUBLE
14327: LD_INT 1
14329: DEC
14330: ST_TO_ADDR
14331: LD_INT 3
14333: PUSH
14334: FOR_TO
14335: IFFALSE 14368
// begin PrepareHuman ( false , class_scientistic , skill ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 4
14342: PPUSH
14343: LD_VAR 0 5
14347: PPUSH
14348: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab ) ;
14352: CALL_OW 44
14356: PPUSH
14357: LD_VAR 0 6
14361: PPUSH
14362: CALL_OW 52
// end ;
14366: GO 14334
14368: POP
14369: POP
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) ,  ) ;
14370: LD_ADDR_EXP 37
14374: PUSH
14375: LD_STRING Yakotich
14377: PPUSH
14378: LD_EXP 2
14382: NOT
14383: PPUSH
14384: LD_STRING 
14386: PPUSH
14387: CALL 360 0 3
14391: ST_TO_ADDR
// PlaceHumanInUnit ( Yakotich , ru_dep ) ;
14392: LD_EXP 37
14396: PPUSH
14397: LD_INT 74
14399: PPUSH
14400: CALL_OW 52
// AddComResearch ( lab , tech_tech2 ) ;
14404: LD_VAR 0 6
14408: PPUSH
14409: LD_INT 49
14411: PPUSH
14412: CALL_OW 184
// AddComResearch ( lab , tech_tech3 ) ;
14416: LD_VAR 0 6
14420: PPUSH
14421: LD_INT 50
14423: PPUSH
14424: CALL_OW 184
// AddComResearch ( lab , tech_weap1 ) ;
14428: LD_VAR 0 6
14432: PPUSH
14433: LD_INT 51
14435: PPUSH
14436: CALL_OW 184
// AddComResearch ( lab , tech_weap2 ) ;
14440: LD_VAR 0 6
14444: PPUSH
14445: LD_INT 52
14447: PPUSH
14448: CALL_OW 184
// AddComResearch ( lab , tech_gatling ) ;
14452: LD_VAR 0 6
14456: PPUSH
14457: LD_INT 69
14459: PPUSH
14460: CALL_OW 184
// AddComResearch ( lab , tech_gun ) ;
14464: LD_VAR 0 6
14468: PPUSH
14469: LD_INT 39
14471: PPUSH
14472: CALL_OW 184
// AddComResearch ( lab , tech_advmet ) ;
14476: LD_VAR 0 6
14480: PPUSH
14481: LD_INT 34
14483: PPUSH
14484: CALL_OW 184
// AddComResearch ( lab , tech_rocket ) ;
14488: LD_VAR 0 6
14492: PPUSH
14493: LD_INT 40
14495: PPUSH
14496: CALL_OW 184
// AddComResearch ( lab , tech_comp1 ) ;
14500: LD_VAR 0 6
14504: PPUSH
14505: LD_INT 57
14507: PPUSH
14508: CALL_OW 184
// if Difficulty > 1 then
14512: LD_OWVAR 67
14516: PUSH
14517: LD_INT 1
14519: GREATER
14520: IFFALSE 14534
// AddComResearch ( lab , tech_comp2 ) ;
14522: LD_VAR 0 6
14526: PPUSH
14527: LD_INT 58
14529: PPUSH
14530: CALL_OW 184
// end ;
14534: LD_VAR 0 1
14538: RET
// every 3 3$30 trigger ListEnvironmentArea ( cutTreeArea ) > 3 and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_bulldozer ] ] ) do
14539: LD_INT 7
14541: PPUSH
14542: CALL_OW 353
14546: PUSH
14547: LD_INT 3
14549: GREATER
14550: PUSH
14551: LD_INT 22
14553: PUSH
14554: LD_INT 3
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PUSH
14561: LD_INT 34
14563: PUSH
14564: LD_INT 53
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: PPUSH
14575: CALL_OW 69
14579: NOT
14580: AND
14581: IFFALSE 14616
14583: GO 14585
14585: DISABLE
// begin enable ;
14586: ENABLE
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_bulldozer ] ;
14587: LD_ADDR_EXP 40
14591: PUSH
14592: LD_EXP 40
14596: PUSH
14597: LD_INT 24
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 3
14605: PUSH
14606: LD_INT 53
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ADD
14615: ST_TO_ADDR
// end ;
14616: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) do var un , i , tmp , engs , dep , to_heal , sci , lab ;
14617: LD_INT 22
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 3
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: IFFALSE 15423
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
14656: PPUSH
14657: PPUSH
14658: PPUSH
14659: PPUSH
// begin enable ;
14660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14661: LD_ADDR_VAR 0 3
14665: PUSH
14666: LD_INT 22
14668: PUSH
14669: LD_INT 3
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 21
14678: PUSH
14679: LD_INT 3
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 3
14688: PUSH
14689: LD_INT 24
14691: PUSH
14692: LD_INT 1000
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: PPUSH
14708: CALL_OW 69
14712: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
14713: LD_ADDR_VAR 0 4
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: LD_INT 25
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: EMPTY
14735: LIST
14736: LIST
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PPUSH
14742: CALL_OW 69
14746: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
14747: LD_ADDR_VAR 0 5
14751: PUSH
14752: LD_INT 22
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 30
14764: PUSH
14765: LD_INT 1
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PPUSH
14776: CALL_OW 69
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ;
14785: LD_ADDR_VAR 0 8
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 3
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 2
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 6
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 30
14815: PUSH
14816: LD_INT 7
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 30
14825: PUSH
14826: LD_INT 8
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 1
14850: ARRAY
14851: ST_TO_ADDR
// if not engs then
14852: LD_VAR 0 4
14856: NOT
14857: IFFALSE 14861
// exit ;
14859: GO 15423
// to_heal := UnitFilter ( engs , [ f_not , [ f_lives , 600 ] ] ) ;
14861: LD_ADDR_VAR 0 6
14865: PUSH
14866: LD_VAR 0 4
14870: PPUSH
14871: LD_INT 3
14873: PUSH
14874: LD_INT 24
14876: PUSH
14877: LD_INT 600
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 72
14892: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
14893: LD_ADDR_VAR 0 7
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 3
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 4
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: ST_TO_ADDR
// if not tmp and not ru_rebuild then
14927: LD_VAR 0 3
14931: NOT
14932: PUSH
14933: LD_EXP 39
14937: NOT
14938: AND
14939: IFFALSE 14999
// begin if UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
14941: LD_VAR 0 4
14945: PPUSH
14946: LD_INT 3
14948: PUSH
14949: LD_INT 54
14951: PUSH
14952: EMPTY
14953: LIST
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PPUSH
14959: CALL_OW 72
14963: IFFALSE 14997
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , dep ) ;
14965: LD_VAR 0 4
14969: PPUSH
14970: LD_INT 3
14972: PUSH
14973: LD_INT 54
14975: PUSH
14976: EMPTY
14977: LIST
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PPUSH
14983: CALL_OW 72
14987: PPUSH
14988: LD_VAR 0 5
14992: PPUSH
14993: CALL_OW 120
// exit ;
14997: GO 15423
// end ; if UnitFilter ( engs , [ f_inside ] ) then
14999: LD_VAR 0 4
15003: PPUSH
15004: LD_INT 54
15006: PUSH
15007: EMPTY
15008: LIST
15009: PPUSH
15010: CALL_OW 72
15014: IFFALSE 15036
// ComExitBuilding ( UnitFilter ( engs , [ f_inside ] ) ) ;
15016: LD_VAR 0 4
15020: PPUSH
15021: LD_INT 54
15023: PUSH
15024: EMPTY
15025: LIST
15026: PPUSH
15027: CALL_OW 72
15031: PPUSH
15032: CALL_OW 122
// if not tmp then
15036: LD_VAR 0 3
15040: NOT
15041: IFFALSE 15173
// begin if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_distxy , 147 , 212 , 30 ] ] ) then
15043: LD_INT 81
15045: PUSH
15046: LD_INT 3
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 92
15055: PUSH
15056: LD_INT 147
15058: PUSH
15059: LD_INT 212
15061: PUSH
15062: LD_INT 30
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PPUSH
15075: CALL_OW 69
15079: NOT
15080: IFFALSE 15173
// begin if not HasTask ( engs [ 1 ] ) then
15082: LD_VAR 0 4
15086: PUSH
15087: LD_INT 1
15089: ARRAY
15090: PPUSH
15091: CALL_OW 314
15095: NOT
15096: IFFALSE 15173
// begin i := ComBuild ( engs , ru_rebuild [ 1 ] , ru_rebuild [ 2 ] , ru_rebuild [ 3 ] , ru_rebuild [ 4 ] ) ;
15098: LD_ADDR_VAR 0 2
15102: PUSH
15103: LD_VAR 0 4
15107: PPUSH
15108: LD_EXP 39
15112: PUSH
15113: LD_INT 1
15115: ARRAY
15116: PPUSH
15117: LD_EXP 39
15121: PUSH
15122: LD_INT 2
15124: ARRAY
15125: PPUSH
15126: LD_EXP 39
15130: PUSH
15131: LD_INT 3
15133: ARRAY
15134: PPUSH
15135: LD_EXP 39
15139: PUSH
15140: LD_INT 4
15142: ARRAY
15143: PPUSH
15144: CALL_OW 145
15148: ST_TO_ADDR
// if GetBType ( i ) = b_armoury then
15149: LD_VAR 0 2
15153: PPUSH
15154: CALL_OW 266
15158: PUSH
15159: LD_INT 4
15161: EQUAL
15162: IFFALSE 15173
// AddComUpgrade ( i ) ;
15164: LD_VAR 0 2
15168: PPUSH
15169: CALL_OW 206
// end ; end ; end ; for i in engs do
15173: LD_ADDR_VAR 0 2
15177: PUSH
15178: LD_VAR 0 4
15182: PUSH
15183: FOR_IN
15184: IFFALSE 15302
// begin if i in to_heal and sci then
15186: LD_VAR 0 2
15190: PUSH
15191: LD_VAR 0 6
15195: IN
15196: PUSH
15197: LD_VAR 0 7
15201: AND
15202: IFFALSE 15253
// begin if GetDistUnitXY ( i , 149 , 220 ) < 5 then
15204: LD_VAR 0 2
15208: PPUSH
15209: LD_INT 149
15211: PPUSH
15212: LD_INT 220
15214: PPUSH
15215: CALL_OW 297
15219: PUSH
15220: LD_INT 5
15222: LESS
15223: IFFALSE 15227
// continue ;
15225: GO 15183
// ComMoveXY ( i , 149 , 220 ) ;
15227: LD_VAR 0 2
15231: PPUSH
15232: LD_INT 149
15234: PPUSH
15235: LD_INT 220
15237: PPUSH
15238: CALL_OW 111
// AddComHold ( i ) ;
15242: LD_VAR 0 2
15246: PPUSH
15247: CALL_OW 200
// end else
15251: GO 15300
// if not HasTask ( i ) or WantsToAttack ( i ) then
15253: LD_VAR 0 2
15257: PPUSH
15258: CALL_OW 314
15262: NOT
15263: PUSH
15264: LD_VAR 0 2
15268: PPUSH
15269: CALL_OW 319
15273: OR
15274: IFFALSE 15300
// ComRepairBuilding ( i , NearestUnitToUnit ( tmp , i ) ) ;
15276: LD_VAR 0 2
15280: PPUSH
15281: LD_VAR 0 3
15285: PPUSH
15286: LD_VAR 0 2
15290: PPUSH
15291: CALL_OW 74
15295: PPUSH
15296: CALL_OW 130
// end ;
15300: GO 15183
15302: POP
15303: POP
// if to_heal and sci then
15304: LD_VAR 0 6
15308: PUSH
15309: LD_VAR 0 7
15313: AND
15314: IFFALSE 15375
// begin if UnitFilter ( sci , [ f_inside ] ) then
15316: LD_VAR 0 7
15320: PPUSH
15321: LD_INT 54
15323: PUSH
15324: EMPTY
15325: LIST
15326: PPUSH
15327: CALL_OW 72
15331: IFFALSE 15355
// ComExitBuilding ( UnitFilter ( sci , [ f_inside ] ) ) else
15333: LD_VAR 0 7
15337: PPUSH
15338: LD_INT 54
15340: PUSH
15341: EMPTY
15342: LIST
15343: PPUSH
15344: CALL_OW 72
15348: PPUSH
15349: CALL_OW 122
15353: GO 15373
// ComHeal ( sci , to_heal [ 1 ] ) ;
15355: LD_VAR 0 7
15359: PPUSH
15360: LD_VAR 0 6
15364: PUSH
15365: LD_INT 1
15367: ARRAY
15368: PPUSH
15369: CALL_OW 128
// end else
15373: GO 15423
// if UnitFilter ( sci , [ f_outside ] ) and lab then
15375: LD_VAR 0 7
15379: PPUSH
15380: LD_INT 56
15382: PUSH
15383: EMPTY
15384: LIST
15385: PPUSH
15386: CALL_OW 72
15390: PUSH
15391: LD_VAR 0 8
15395: AND
15396: IFFALSE 15423
// ComEnterUnit ( UnitFilter ( sci , [ f_outside ] ) , lab ) ;
15398: LD_VAR 0 7
15402: PPUSH
15403: LD_INT 56
15405: PUSH
15406: EMPTY
15407: LIST
15408: PPUSH
15409: CALL_OW 72
15413: PPUSH
15414: LD_VAR 0 8
15418: PPUSH
15419: CALL_OW 120
// end ;
15423: PPOPN 8
15425: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) and ru_produce_list do var i , tmp , fac ;
15426: LD_INT 22
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 30
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PPUSH
15450: CALL_OW 69
15454: PUSH
15455: LD_EXP 40
15459: AND
15460: IFFALSE 15586
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
15468: PPUSH
15469: PPUSH
// begin enable ;
15470: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 22
15478: PUSH
15479: LD_INT 3
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: LD_INT 30
15488: PUSH
15489: LD_INT 3
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PPUSH
15500: CALL_OW 69
15504: PUSH
15505: LD_INT 1
15507: ARRAY
15508: ST_TO_ADDR
// if UnitsInside ( fac ) = 0 then
15509: LD_VAR 0 3
15513: PPUSH
15514: CALL_OW 313
15518: PUSH
15519: LD_INT 0
15521: EQUAL
15522: IFFALSE 15526
// exit ;
15524: GO 15586
// if BuildingStatus ( fac ) = bs_idle then
15526: LD_VAR 0 3
15530: PPUSH
15531: CALL_OW 461
15535: PUSH
15536: LD_INT 2
15538: EQUAL
15539: IFFALSE 15586
// ComConstruct ( fac , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_EXP 40
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_EXP 40
15559: PUSH
15560: LD_INT 2
15562: ARRAY
15563: PPUSH
15564: LD_EXP 40
15568: PUSH
15569: LD_INT 3
15571: ARRAY
15572: PPUSH
15573: LD_EXP 40
15577: PUSH
15578: LD_INT 4
15580: ARRAY
15581: PPUSH
15582: CALL_OW 125
// end ;
15586: PPOPN 3
15588: END
// export function PrepareAttack ( wave ) ; var i , un , tmp , fac ; begin
15589: LD_INT 0
15591: PPUSH
15592: PPUSH
15593: PPUSH
15594: PPUSH
15595: PPUSH
// uc_side := 3 ;
15596: LD_ADDR_OWVAR 20
15600: PUSH
15601: LD_INT 3
15603: ST_TO_ADDR
// uc_nation := 3 ;
15604: LD_ADDR_OWVAR 21
15608: PUSH
15609: LD_INT 3
15611: ST_TO_ADDR
// ru_can_attack := false ;
15612: LD_ADDR_EXP 8
15616: PUSH
15617: LD_INT 0
15619: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
15620: LD_ADDR_VAR 0 6
15624: PUSH
15625: LD_INT 22
15627: PUSH
15628: LD_INT 3
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: LD_INT 30
15637: PUSH
15638: LD_INT 3
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL_OW 69
15653: ST_TO_ADDR
// if fac then
15654: LD_VAR 0 6
15658: IFFALSE 15810
// begin ru_produce_list := [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] ;
15660: LD_ADDR_EXP 40
15664: PUSH
15665: LD_INT 24
15667: PUSH
15668: LD_INT 1
15670: PUSH
15671: LD_INT 3
15673: PUSH
15674: LD_INT 43
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: ST_TO_ADDR
// if wave > 1 then
15683: LD_VAR 0 1
15687: PUSH
15688: LD_INT 1
15690: GREATER
15691: IFFALSE 15744
// for i = 1 to Difficulty do
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: DOUBLE
15699: LD_INT 1
15701: DEC
15702: ST_TO_ADDR
15703: LD_OWVAR 67
15707: PUSH
15708: FOR_TO
15709: IFFALSE 15742
// ru_produce_list := ru_produce_list ^ [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ;
15711: LD_ADDR_EXP 40
15715: PUSH
15716: LD_EXP 40
15720: PUSH
15721: LD_INT 24
15723: PUSH
15724: LD_INT 1
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: LD_INT 45
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: LIST
15737: LIST
15738: ADD
15739: ST_TO_ADDR
15740: GO 15708
15742: POP
15743: POP
// repeat wait ( 0 0$1 ) ;
15744: LD_INT 35
15746: PPUSH
15747: CALL_OW 67
// until ru_produce_list < 4 or UnitsInside ( fac [ 1 ] ) = 0 or BuildingStatus ( fac [ 1 ] ) in [ bs_need_extension , bs_need_people , bs_need_power ] ;
15751: LD_EXP 40
15755: PUSH
15756: LD_INT 4
15758: LESS
15759: PUSH
15760: LD_VAR 0 6
15764: PUSH
15765: LD_INT 1
15767: ARRAY
15768: PPUSH
15769: CALL_OW 313
15773: PUSH
15774: LD_INT 0
15776: EQUAL
15777: OR
15778: PUSH
15779: LD_VAR 0 6
15783: PUSH
15784: LD_INT 1
15786: ARRAY
15787: PPUSH
15788: CALL_OW 461
15792: PUSH
15793: LD_INT 8
15795: PUSH
15796: LD_INT 6
15798: PUSH
15799: LD_INT 7
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: IN
15807: OR
15808: IFFALSE 15744
// end ; case wave of 1 :
15810: LD_VAR 0 1
15814: PUSH
15815: LD_INT 1
15817: DOUBLE
15818: EQUAL
15819: IFTRUE 15823
15821: GO 15908
15823: POP
// begin for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15824: LD_ADDR_VAR 0 3
15828: PUSH
15829: DOUBLE
15830: LD_INT 1
15832: DEC
15833: ST_TO_ADDR
15834: LD_INT 2
15836: PUSH
15837: LD_INT 3
15839: PUSH
15840: LD_INT 4
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: LIST
15847: PUSH
15848: LD_OWVAR 67
15852: ARRAY
15853: PUSH
15854: FOR_TO
15855: IFFALSE 15863
// Sold ;
15857: CALL 16134 0 0
15861: GO 15854
15863: POP
15864: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
15865: LD_ADDR_VAR 0 3
15869: PUSH
15870: DOUBLE
15871: LD_INT 1
15873: DEC
15874: ST_TO_ADDR
15875: LD_INT 2
15877: PUSH
15878: LD_INT 3
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: PUSH
15889: LD_OWVAR 67
15893: ARRAY
15894: PUSH
15895: FOR_TO
15896: IFFALSE 15904
// Tank ;
15898: CALL 16264 0 0
15902: GO 15895
15904: POP
15905: POP
// end ; 2 .. 9 :
15906: GO 16121
15908: LD_INT 2
15910: DOUBLE
15911: GREATEREQUAL
15912: IFFALSE 15920
15914: LD_INT 9
15916: DOUBLE
15917: LESSEQUAL
15918: IFTRUE 15922
15920: GO 16027
15922: POP
// begin for i = 1 to [ 2 , 4 , 5 ] [ Difficulty ] + ( wave div 2 ) do
15923: LD_ADDR_VAR 0 3
15927: PUSH
15928: DOUBLE
15929: LD_INT 1
15931: DEC
15932: ST_TO_ADDR
15933: LD_INT 2
15935: PUSH
15936: LD_INT 4
15938: PUSH
15939: LD_INT 5
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: LIST
15946: PUSH
15947: LD_OWVAR 67
15951: ARRAY
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: LD_INT 2
15960: DIV
15961: PLUS
15962: PUSH
15963: FOR_TO
15964: IFFALSE 15972
// Sold ;
15966: CALL 16134 0 0
15970: GO 15963
15972: POP
15973: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] + ( wave div 2 ) do
15974: LD_ADDR_VAR 0 3
15978: PUSH
15979: DOUBLE
15980: LD_INT 1
15982: DEC
15983: ST_TO_ADDR
15984: LD_INT 2
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: LD_INT 3
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: PUSH
15998: LD_OWVAR 67
16002: ARRAY
16003: PUSH
16004: LD_VAR 0 1
16008: PUSH
16009: LD_INT 2
16011: DIV
16012: PLUS
16013: PUSH
16014: FOR_TO
16015: IFFALSE 16023
// Tank ;
16017: CALL 16264 0 0
16021: GO 16014
16023: POP
16024: POP
// end ; 10 :
16025: GO 16121
16027: LD_INT 10
16029: DOUBLE
16030: EQUAL
16031: IFTRUE 16035
16033: GO 16120
16035: POP
// begin for i = 1 to [ 10 , 12 , 14 ] [ Difficulty ] do
16036: LD_ADDR_VAR 0 3
16040: PUSH
16041: DOUBLE
16042: LD_INT 1
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 10
16048: PUSH
16049: LD_INT 12
16051: PUSH
16052: LD_INT 14
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: PUSH
16060: LD_OWVAR 67
16064: ARRAY
16065: PUSH
16066: FOR_TO
16067: IFFALSE 16075
// Sold ;
16069: CALL 16134 0 0
16073: GO 16066
16075: POP
16076: POP
// for i = 1 to [ 11 , 13 , 15 ] [ Difficulty ] do
16077: LD_ADDR_VAR 0 3
16081: PUSH
16082: DOUBLE
16083: LD_INT 1
16085: DEC
16086: ST_TO_ADDR
16087: LD_INT 11
16089: PUSH
16090: LD_INT 13
16092: PUSH
16093: LD_INT 15
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: LIST
16100: PUSH
16101: LD_OWVAR 67
16105: ARRAY
16106: PUSH
16107: FOR_TO
16108: IFFALSE 16116
// Tank ;
16110: CALL 16264 0 0
16114: GO 16107
16116: POP
16117: POP
// end ; end ;
16118: GO 16121
16120: POP
// ru_can_attack := true ;
16121: LD_ADDR_EXP 8
16125: PUSH
16126: LD_INT 1
16128: ST_TO_ADDR
// end ;
16129: LD_VAR 0 2
16133: RET
// function Sold ( ) ; var un , skill ; begin
16134: LD_INT 0
16136: PPUSH
16137: PPUSH
16138: PPUSH
// uc_side := 3 ;
16139: LD_ADDR_OWVAR 20
16143: PUSH
16144: LD_INT 3
16146: ST_TO_ADDR
// uc_nation := 3 ;
16147: LD_ADDR_OWVAR 21
16151: PUSH
16152: LD_INT 3
16154: ST_TO_ADDR
// InitHc ;
16155: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16159: LD_ADDR_VAR 0 3
16163: PUSH
16164: LD_INT 5
16166: PUSH
16167: LD_INT 6
16169: PUSH
16170: LD_INT 7
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: PUSH
16178: LD_OWVAR 67
16182: ARRAY
16183: ST_TO_ADDR
// PrepareHuman ( false , [ class_soldier , class_bazooker ] [ rand ( 1 , 2 ) ] , skill ) ;
16184: LD_INT 0
16186: PPUSH
16187: LD_INT 1
16189: PUSH
16190: LD_INT 9
16192: PUSH
16193: EMPTY
16194: LIST
16195: LIST
16196: PUSH
16197: LD_INT 1
16199: PPUSH
16200: LD_INT 2
16202: PPUSH
16203: CALL_OW 12
16207: ARRAY
16208: PPUSH
16209: LD_VAR 0 3
16213: PPUSH
16214: CALL_OW 380
// un := CreateHuman ;
16218: LD_ADDR_VAR 0 2
16222: PUSH
16223: CALL_OW 44
16227: ST_TO_ADDR
// PlaceUnitArea ( un , ruForestSpawn , false ) ;
16228: LD_VAR 0 2
16232: PPUSH
16233: LD_INT 4
16235: PPUSH
16236: LD_INT 0
16238: PPUSH
16239: CALL_OW 49
// ru_force := ru_force ^ un ;
16243: LD_ADDR_EXP 38
16247: PUSH
16248: LD_EXP 38
16252: PUSH
16253: LD_VAR 0 2
16257: ADD
16258: ST_TO_ADDR
// end ;
16259: LD_VAR 0 1
16263: RET
// function Tank ( ) ; var un , chassis , weapon , skill ; begin
16264: LD_INT 0
16266: PPUSH
16267: PPUSH
16268: PPUSH
16269: PPUSH
16270: PPUSH
// uc_side := 3 ;
16271: LD_ADDR_OWVAR 20
16275: PUSH
16276: LD_INT 3
16278: ST_TO_ADDR
// uc_nation := 3 ;
16279: LD_ADDR_OWVAR 21
16283: PUSH
16284: LD_INT 3
16286: ST_TO_ADDR
// InitHc ;
16287: CALL_OW 19
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
16291: LD_ADDR_VAR 0 5
16295: PUSH
16296: LD_INT 5
16298: PUSH
16299: LD_INT 6
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: LIST
16309: PUSH
16310: LD_OWVAR 67
16314: ARRAY
16315: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] ;
16316: LD_ADDR_VAR 0 3
16320: PUSH
16321: LD_INT 22
16323: PUSH
16324: LD_INT 24
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: LD_INT 1
16333: PPUSH
16334: LD_INT 2
16336: PPUSH
16337: CALL_OW 12
16341: ARRAY
16342: ST_TO_ADDR
// if chassis = ru_medium_tracked then
16343: LD_VAR 0 3
16347: PUSH
16348: LD_INT 22
16350: EQUAL
16351: IFFALSE 16386
// weapon := [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] else
16353: LD_ADDR_VAR 0 4
16357: PUSH
16358: LD_INT 45
16360: PUSH
16361: LD_INT 43
16363: PUSH
16364: LD_INT 44
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 1
16374: PPUSH
16375: LD_INT 3
16377: PPUSH
16378: CALL_OW 12
16382: ARRAY
16383: ST_TO_ADDR
16384: GO 16417
// weapon := [ ru_heavy_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ;
16386: LD_ADDR_VAR 0 4
16390: PUSH
16391: LD_INT 46
16393: PUSH
16394: LD_INT 44
16396: PUSH
16397: LD_INT 45
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_INT 3
16410: PPUSH
16411: CALL_OW 12
16415: ARRAY
16416: ST_TO_ADDR
// un := PrepareTank ( 3 , 3 , chassis , engine_combustion , [ control_computer , control_computer , control_computer , control_manual ] [ rand ( 1 , 4 ) ] , weapon , 99 ) ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 3
16427: PPUSH
16428: LD_VAR 0 3
16432: PPUSH
16433: LD_INT 1
16435: PPUSH
16436: LD_INT 3
16438: PUSH
16439: LD_INT 3
16441: PUSH
16442: LD_INT 3
16444: PUSH
16445: LD_INT 1
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_INT 4
16459: PPUSH
16460: CALL_OW 12
16464: ARRAY
16465: PPUSH
16466: LD_VAR 0 4
16470: PPUSH
16471: LD_INT 99
16473: PPUSH
16474: CALL 423 0 7
16478: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 263
16488: PUSH
16489: LD_INT 1
16491: EQUAL
16492: IFFALSE 16523
// begin PrepareHuman ( false , 3 , skill ) ;
16494: LD_INT 0
16496: PPUSH
16497: LD_INT 3
16499: PPUSH
16500: LD_VAR 0 5
16504: PPUSH
16505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
16509: CALL_OW 44
16513: PPUSH
16514: LD_VAR 0 2
16518: PPUSH
16519: CALL_OW 52
// end ; PlaceUnitArea ( un , ruRoadSpawn , false ) ;
16523: LD_VAR 0 2
16527: PPUSH
16528: LD_INT 3
16530: PPUSH
16531: LD_INT 0
16533: PPUSH
16534: CALL_OW 49
// ru_force := ru_force ^ un ;
16538: LD_ADDR_EXP 38
16542: PUSH
16543: LD_EXP 38
16547: PUSH
16548: LD_VAR 0 2
16552: ADD
16553: ST_TO_ADDR
// ComMoveXY ( un , 126 , 158 ) ;
16554: LD_VAR 0 2
16558: PPUSH
16559: LD_INT 126
16561: PPUSH
16562: LD_INT 158
16564: PPUSH
16565: CALL_OW 111
// Wait ( 0 0$3 ) ;
16569: LD_INT 105
16571: PPUSH
16572: CALL_OW 67
// ComStop ( un ) ;
16576: LD_VAR 0 2
16580: PPUSH
16581: CALL_OW 141
// end ;
16585: LD_VAR 0 1
16589: RET
// every 0 0$1 do var i , time , wave ;
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin time := [ 12 12$00 , 11 11$30 , 11 11$00 ] [ Difficulty ] ;
16598: LD_ADDR_VAR 0 2
16602: PUSH
16603: LD_INT 25200
16605: PUSH
16606: LD_INT 24150
16608: PUSH
16609: LD_INT 23100
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: LD_OWVAR 67
16621: ARRAY
16622: ST_TO_ADDR
// wait ( time ) ;
16623: LD_VAR 0 2
16627: PPUSH
16628: CALL_OW 67
// time := [ 7 7$30 , 7 7$20 , 7 7$10 ] [ Difficulty ] ;
16632: LD_ADDR_VAR 0 2
16636: PUSH
16637: LD_INT 15750
16639: PUSH
16640: LD_INT 15400
16642: PUSH
16643: LD_INT 15050
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: LIST
16650: PUSH
16651: LD_OWVAR 67
16655: ARRAY
16656: ST_TO_ADDR
// wave := 0 ;
16657: LD_ADDR_VAR 0 3
16661: PUSH
16662: LD_INT 0
16664: ST_TO_ADDR
// while true do
16665: LD_INT 1
16667: IFFALSE 16771
// begin wave := wave + 1 ;
16669: LD_ADDR_VAR 0 3
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_INT 1
16681: PLUS
16682: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 2 ] ) then
16683: LD_INT 22
16685: PUSH
16686: LD_INT 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: IFFALSE 16733
// begin repeat wait ( 0 0$1 ) ;
16699: LD_INT 35
16701: PPUSH
16702: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
16706: LD_INT 22
16708: PUSH
16709: LD_INT 2
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: PPUSH
16716: CALL_OW 69
16720: PUSH
16721: LD_INT 0
16723: EQUAL
16724: IFFALSE 16699
// wait ( 1 1$30 ) ;
16726: LD_INT 3150
16728: PPUSH
16729: CALL_OW 67
// end ; if ru_force < 20 then
16733: LD_EXP 38
16737: PUSH
16738: LD_INT 20
16740: LESS
16741: IFFALSE 16752
// PrepareAttack ( wave ) ;
16743: LD_VAR 0 3
16747: PPUSH
16748: CALL 15589 0 1
// ru_can_attack := true ;
16752: LD_ADDR_EXP 8
16756: PUSH
16757: LD_INT 1
16759: ST_TO_ADDR
// wait ( time ) ;
16760: LD_VAR 0 2
16764: PPUSH
16765: CALL_OW 67
// end ;
16769: GO 16665
// end ;
16771: PPOPN 3
16773: END
// every 0 0$1 trigger ru_can_attack and ru_force do var i , tmp , un , points1 , points2 , pointsr , x , dist , xy ;
16774: LD_EXP 8
16778: PUSH
16779: LD_EXP 38
16783: AND
16784: IFFALSE 17618
16786: GO 16788
16788: DISABLE
16789: LD_INT 0
16791: PPUSH
16792: PPUSH
16793: PPUSH
16794: PPUSH
16795: PPUSH
16796: PPUSH
16797: PPUSH
16798: PPUSH
16799: PPUSH
// begin enable ;
16800: ENABLE
// points1 := [ 107 , 123 ] ;
16801: LD_ADDR_VAR 0 4
16805: PUSH
16806: LD_INT 107
16808: PUSH
16809: LD_INT 123
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: ST_TO_ADDR
// points2 := [ 55 , 42 ] ;
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: LD_INT 55
16823: PUSH
16824: LD_INT 42
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: ST_TO_ADDR
// pointsr := [ [ 102 , 140 ] , [ 105 , 142 ] , [ 129 , 131 ] ] ;
16831: LD_ADDR_VAR 0 6
16835: PUSH
16836: LD_INT 102
16838: PUSH
16839: LD_INT 140
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PUSH
16846: LD_INT 105
16848: PUSH
16849: LD_INT 142
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 129
16858: PUSH
16859: LD_INT 131
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: ST_TO_ADDR
// for i in ru_force do
16871: LD_ADDR_VAR 0 1
16875: PUSH
16876: LD_EXP 38
16880: PUSH
16881: FOR_IN
16882: IFFALSE 17616
// begin un := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ;
16884: LD_ADDR_VAR 0 3
16888: PUSH
16889: LD_INT 81
16891: PUSH
16892: LD_INT 3
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: PPUSH
16899: CALL_OW 69
16903: PPUSH
16904: LD_VAR 0 1
16908: PPUSH
16909: CALL_OW 74
16913: ST_TO_ADDR
// if GetDistUnits ( i , un ) < 12 then
16914: LD_VAR 0 1
16918: PPUSH
16919: LD_VAR 0 3
16923: PPUSH
16924: CALL_OW 296
16928: PUSH
16929: LD_INT 12
16931: LESS
16932: IFFALSE 17077
// begin if GetType ( i ) = unit_human and GetClass ( i ) = 1 and un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
16934: LD_VAR 0 1
16938: PPUSH
16939: CALL_OW 247
16943: PUSH
16944: LD_INT 1
16946: EQUAL
16947: PUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 257
16957: PUSH
16958: LD_INT 1
16960: EQUAL
16961: AND
16962: PUSH
16963: LD_VAR 0 3
16967: PUSH
16968: LD_INT 21
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 58
16980: PUSH
16981: EMPTY
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PPUSH
16988: CALL_OW 69
16992: IN
16993: AND
16994: IFFALSE 17012
// ComEnterUnit ( i , un ) else
16996: LD_VAR 0 1
17000: PPUSH
17001: LD_VAR 0 3
17005: PPUSH
17006: CALL_OW 120
17010: GO 17075
// if not un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
17012: LD_VAR 0 3
17016: PUSH
17017: LD_INT 21
17019: PUSH
17020: LD_INT 2
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 58
17029: PUSH
17030: EMPTY
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: PPUSH
17037: CALL_OW 69
17041: IN
17042: NOT
17043: IFFALSE 17061
// ComAttackUnit ( i , un ) else
17045: LD_VAR 0 1
17049: PPUSH
17050: LD_VAR 0 3
17054: PPUSH
17055: CALL_OW 115
17059: GO 17075
// ComAttackUnit ( i , JMM ) ;
17061: LD_VAR 0 1
17065: PPUSH
17066: LD_EXP 21
17070: PPUSH
17071: CALL_OW 115
// end else
17075: GO 17614
// begin if ( GetDistUnitXY ( i , points1 [ 1 ] , points1 [ 2 ] ) > GetDistUnitXY ( i , points2 [ 1 ] , points2 [ 2 ] ) and ru_can_attack_terminal ) or FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) = 0 then
17077: LD_VAR 0 1
17081: PPUSH
17082: LD_VAR 0 4
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: LD_VAR 0 4
17095: PUSH
17096: LD_INT 2
17098: ARRAY
17099: PPUSH
17100: CALL_OW 297
17104: PUSH
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 5
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: PPUSH
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 2
17126: ARRAY
17127: PPUSH
17128: CALL_OW 297
17132: GREATER
17133: PUSH
17134: LD_EXP 9
17138: AND
17139: PUSH
17140: LD_INT 9
17142: PPUSH
17143: LD_INT 81
17145: PUSH
17146: LD_INT 3
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PPUSH
17153: CALL_OW 70
17157: PUSH
17158: LD_INT 0
17160: EQUAL
17161: OR
17162: IFFALSE 17200
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
17164: LD_VAR 0 1
17168: PPUSH
17169: LD_INT 81
17171: PUSH
17172: LD_INT 3
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PPUSH
17179: CALL_OW 69
17183: PPUSH
17184: LD_VAR 0 1
17188: PPUSH
17189: CALL_OW 74
17193: PPUSH
17194: CALL_OW 115
17198: GO 17614
// begin if GetWeapon ( i ) = ru_rocket_launcher and UnitFilter ( ru_force , [ f_not , [ f_weapon , ru_rocket_launcher ] ] ) > 6 then
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 264
17209: PUSH
17210: LD_INT 45
17212: EQUAL
17213: PUSH
17214: LD_EXP 38
17218: PPUSH
17219: LD_INT 3
17221: PUSH
17222: LD_INT 34
17224: PUSH
17225: LD_INT 45
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PPUSH
17236: CALL_OW 72
17240: PUSH
17241: LD_INT 6
17243: GREATER
17244: AND
17245: IFFALSE 17426
// begin dist := 9999 ;
17247: LD_ADDR_VAR 0 8
17251: PUSH
17252: LD_INT 9999
17254: ST_TO_ADDR
// xy := 0 ;
17255: LD_ADDR_VAR 0 9
17259: PUSH
17260: LD_INT 0
17262: ST_TO_ADDR
// for x in pointsr do
17263: LD_ADDR_VAR 0 7
17267: PUSH
17268: LD_VAR 0 6
17272: PUSH
17273: FOR_IN
17274: IFFALSE 17422
// begin if GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) < dist then
17276: LD_VAR 0 1
17280: PPUSH
17281: LD_VAR 0 7
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: LD_VAR 0 7
17294: PUSH
17295: LD_INT 2
17297: ARRAY
17298: PPUSH
17299: CALL_OW 297
17303: PUSH
17304: LD_VAR 0 8
17308: LESS
17309: IFFALSE 17354
// begin dist := GetDistUnitXY ( i , x [ 1 ] , x [ 2 ] ) ;
17311: LD_ADDR_VAR 0 8
17315: PUSH
17316: LD_VAR 0 1
17320: PPUSH
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: LD_VAR 0 7
17334: PUSH
17335: LD_INT 2
17337: ARRAY
17338: PPUSH
17339: CALL_OW 297
17343: ST_TO_ADDR
// xy := x ;
17344: LD_ADDR_VAR 0 9
17348: PUSH
17349: LD_VAR 0 7
17353: ST_TO_ADDR
// end ; if xy and GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 9 then
17354: LD_VAR 0 9
17358: PUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: LD_VAR 0 9
17368: PUSH
17369: LD_INT 1
17371: ARRAY
17372: PPUSH
17373: LD_VAR 0 9
17377: PUSH
17378: LD_INT 2
17380: ARRAY
17381: PPUSH
17382: CALL_OW 297
17386: PUSH
17387: LD_INT 9
17389: GREATER
17390: AND
17391: IFFALSE 17420
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) ;
17393: LD_VAR 0 1
17397: PPUSH
17398: LD_VAR 0 9
17402: PUSH
17403: LD_INT 1
17405: ARRAY
17406: PPUSH
17407: LD_VAR 0 9
17411: PUSH
17412: LD_INT 2
17414: ARRAY
17415: PPUSH
17416: CALL_OW 114
// end ;
17420: GO 17273
17422: POP
17423: POP
// end else
17424: GO 17614
// begin un := NearestUnitToUnit ( all_units diff i , i ) ;
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_OWVAR 3
17435: PUSH
17436: LD_VAR 0 1
17440: DIFF
17441: PPUSH
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 74
17451: ST_TO_ADDR
// if not Attacks ( i ) and ( un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] , [ f_empty ] ] ) or un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 249 ] ] ] ) ) then
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 320
17461: NOT
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_INT 21
17470: PUSH
17471: LD_INT 2
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PUSH
17478: LD_INT 33
17480: PUSH
17481: LD_INT 1
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: LD_INT 58
17490: PUSH
17491: EMPTY
17492: LIST
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: PPUSH
17499: CALL_OW 69
17503: IN
17504: PUSH
17505: LD_VAR 0 3
17509: PUSH
17510: LD_INT 22
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: EMPTY
17517: LIST
17518: LIST
17519: PUSH
17520: LD_INT 21
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: PUSH
17530: LD_INT 3
17532: PUSH
17533: LD_INT 24
17535: PUSH
17536: LD_INT 249
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 69
17556: IN
17557: OR
17558: AND
17559: IFFALSE 17577
// ComAttackUnit ( i , un ) else
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_VAR 0 3
17570: PPUSH
17571: CALL_OW 115
17575: GO 17614
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( ovsyenkoArea , [ f_enemy , 3 ] ) , i ) ) ;
17577: LD_VAR 0 1
17581: PPUSH
17582: LD_INT 9
17584: PPUSH
17585: LD_INT 81
17587: PUSH
17588: LD_INT 3
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 70
17599: PPUSH
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL_OW 74
17609: PPUSH
17610: CALL_OW 115
// end ; end ; end ; end ;
17614: GO 16881
17616: POP
17617: POP
// end ;
17618: PPOPN 9
17620: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
17621: LD_INT 22
17623: PUSH
17624: LD_INT 3
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 32
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: IFFALSE 17737
17651: GO 17653
17653: DISABLE
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// begin enable ;
17658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_engine , engine_combustion ] ] ) ;
17659: LD_ADDR_VAR 0 2
17663: PUSH
17664: LD_INT 22
17666: PUSH
17667: LD_INT 3
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PUSH
17674: LD_INT 32
17676: PUSH
17677: LD_INT 1
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: PPUSH
17688: CALL_OW 69
17692: ST_TO_ADDR
// for i in tmp do
17693: LD_ADDR_VAR 0 1
17697: PUSH
17698: LD_VAR 0 2
17702: PUSH
17703: FOR_IN
17704: IFFALSE 17735
// if GetFuel ( i ) < 12 then
17706: LD_VAR 0 1
17710: PPUSH
17711: CALL_OW 261
17715: PUSH
17716: LD_INT 12
17718: LESS
17719: IFFALSE 17733
// SetFuel ( i , 12 ) ;
17721: LD_VAR 0 1
17725: PPUSH
17726: LD_INT 12
17728: PPUSH
17729: CALL_OW 240
17733: GO 17703
17735: POP
17736: POP
// end ;
17737: PPOPN 2
17739: END
// every 0 0$1 trigger can_end do
17740: LD_EXP 17
17744: IFFALSE 17767
17746: GO 17748
17748: DISABLE
// begin repeat wait ( 1 1$35 ) ;
17749: LD_INT 3325
17751: PPUSH
17752: CALL_OW 67
// PrepareAttack ( 10 ) ;
17756: LD_INT 10
17758: PPUSH
17759: CALL 15589 0 1
// until false ;
17763: LD_INT 0
17765: IFFALSE 17749
// end ; end_of_file
17767: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17768: GO 17770
17770: DISABLE
// begin ru_radar := 98 ;
17771: LD_ADDR_EXP 41
17775: PUSH
17776: LD_INT 98
17778: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17779: LD_ADDR_EXP 42
17783: PUSH
17784: LD_INT 89
17786: ST_TO_ADDR
// us_hack := 99 ;
17787: LD_ADDR_EXP 43
17791: PUSH
17792: LD_INT 99
17794: ST_TO_ADDR
// us_artillery := 97 ;
17795: LD_ADDR_EXP 44
17799: PUSH
17800: LD_INT 97
17802: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17803: LD_ADDR_EXP 45
17807: PUSH
17808: LD_INT 91
17810: ST_TO_ADDR
// end ; end_of_file end_of_file
17811: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
17812: GO 17814
17814: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
17815: LD_STRING initStreamRollete();
17817: PPUSH
17818: CALL_OW 559
// InitStreamMode ;
17822: CALL 17831 0 0
// DefineStreamItems ( ) ;
17826: CALL 18271 0 0
// end ;
17830: END
// function InitStreamMode ; begin
17831: LD_INT 0
17833: PPUSH
// streamModeActive := false ;
17834: LD_ADDR_EXP 46
17838: PUSH
17839: LD_INT 0
17841: ST_TO_ADDR
// normalCounter := 36 ;
17842: LD_ADDR_EXP 47
17846: PUSH
17847: LD_INT 36
17849: ST_TO_ADDR
// hardcoreCounter := 16 ;
17850: LD_ADDR_EXP 48
17854: PUSH
17855: LD_INT 16
17857: ST_TO_ADDR
// sRocket := false ;
17858: LD_ADDR_EXP 51
17862: PUSH
17863: LD_INT 0
17865: ST_TO_ADDR
// sSpeed := false ;
17866: LD_ADDR_EXP 50
17870: PUSH
17871: LD_INT 0
17873: ST_TO_ADDR
// sEngine := false ;
17874: LD_ADDR_EXP 52
17878: PUSH
17879: LD_INT 0
17881: ST_TO_ADDR
// sSpec := false ;
17882: LD_ADDR_EXP 49
17886: PUSH
17887: LD_INT 0
17889: ST_TO_ADDR
// sLevel := false ;
17890: LD_ADDR_EXP 53
17894: PUSH
17895: LD_INT 0
17897: ST_TO_ADDR
// sArmoury := false ;
17898: LD_ADDR_EXP 54
17902: PUSH
17903: LD_INT 0
17905: ST_TO_ADDR
// sRadar := false ;
17906: LD_ADDR_EXP 55
17910: PUSH
17911: LD_INT 0
17913: ST_TO_ADDR
// sBunker := false ;
17914: LD_ADDR_EXP 56
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// sHack := false ;
17922: LD_ADDR_EXP 57
17926: PUSH
17927: LD_INT 0
17929: ST_TO_ADDR
// sFire := false ;
17930: LD_ADDR_EXP 58
17934: PUSH
17935: LD_INT 0
17937: ST_TO_ADDR
// sRefresh := false ;
17938: LD_ADDR_EXP 59
17942: PUSH
17943: LD_INT 0
17945: ST_TO_ADDR
// sExp := false ;
17946: LD_ADDR_EXP 60
17950: PUSH
17951: LD_INT 0
17953: ST_TO_ADDR
// sDepot := false ;
17954: LD_ADDR_EXP 61
17958: PUSH
17959: LD_INT 0
17961: ST_TO_ADDR
// sFlag := false ;
17962: LD_ADDR_EXP 62
17966: PUSH
17967: LD_INT 0
17969: ST_TO_ADDR
// sKamikadze := false ;
17970: LD_ADDR_EXP 70
17974: PUSH
17975: LD_INT 0
17977: ST_TO_ADDR
// sTroll := false ;
17978: LD_ADDR_EXP 71
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// sSlow := false ;
17986: LD_ADDR_EXP 72
17990: PUSH
17991: LD_INT 0
17993: ST_TO_ADDR
// sLack := false ;
17994: LD_ADDR_EXP 73
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// sTank := false ;
18002: LD_ADDR_EXP 75
18006: PUSH
18007: LD_INT 0
18009: ST_TO_ADDR
// sRemote := false ;
18010: LD_ADDR_EXP 76
18014: PUSH
18015: LD_INT 0
18017: ST_TO_ADDR
// sPowell := false ;
18018: LD_ADDR_EXP 77
18022: PUSH
18023: LD_INT 0
18025: ST_TO_ADDR
// sTeleport := false ;
18026: LD_ADDR_EXP 80
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// sOilTower := false ;
18034: LD_ADDR_EXP 82
18038: PUSH
18039: LD_INT 0
18041: ST_TO_ADDR
// sShovel := false ;
18042: LD_ADDR_EXP 83
18046: PUSH
18047: LD_INT 0
18049: ST_TO_ADDR
// sSheik := false ;
18050: LD_ADDR_EXP 84
18054: PUSH
18055: LD_INT 0
18057: ST_TO_ADDR
// sEarthquake := false ;
18058: LD_ADDR_EXP 86
18062: PUSH
18063: LD_INT 0
18065: ST_TO_ADDR
// sAI := false ;
18066: LD_ADDR_EXP 87
18070: PUSH
18071: LD_INT 0
18073: ST_TO_ADDR
// sCargo := false ;
18074: LD_ADDR_EXP 90
18078: PUSH
18079: LD_INT 0
18081: ST_TO_ADDR
// sDLaser := false ;
18082: LD_ADDR_EXP 91
18086: PUSH
18087: LD_INT 0
18089: ST_TO_ADDR
// sExchange := false ;
18090: LD_ADDR_EXP 92
18094: PUSH
18095: LD_INT 0
18097: ST_TO_ADDR
// sFac := false ;
18098: LD_ADDR_EXP 93
18102: PUSH
18103: LD_INT 0
18105: ST_TO_ADDR
// sPower := false ;
18106: LD_ADDR_EXP 94
18110: PUSH
18111: LD_INT 0
18113: ST_TO_ADDR
// sRandom := false ;
18114: LD_ADDR_EXP 95
18118: PUSH
18119: LD_INT 0
18121: ST_TO_ADDR
// sShield := false ;
18122: LD_ADDR_EXP 96
18126: PUSH
18127: LD_INT 0
18129: ST_TO_ADDR
// sTime := false ;
18130: LD_ADDR_EXP 97
18134: PUSH
18135: LD_INT 0
18137: ST_TO_ADDR
// sTools := false ;
18138: LD_ADDR_EXP 98
18142: PUSH
18143: LD_INT 0
18145: ST_TO_ADDR
// sSold := false ;
18146: LD_ADDR_EXP 63
18150: PUSH
18151: LD_INT 0
18153: ST_TO_ADDR
// sDiff := false ;
18154: LD_ADDR_EXP 64
18158: PUSH
18159: LD_INT 0
18161: ST_TO_ADDR
// sFog := false ;
18162: LD_ADDR_EXP 67
18166: PUSH
18167: LD_INT 0
18169: ST_TO_ADDR
// sReset := false ;
18170: LD_ADDR_EXP 68
18174: PUSH
18175: LD_INT 0
18177: ST_TO_ADDR
// sSun := false ;
18178: LD_ADDR_EXP 69
18182: PUSH
18183: LD_INT 0
18185: ST_TO_ADDR
// sTiger := false ;
18186: LD_ADDR_EXP 65
18190: PUSH
18191: LD_INT 0
18193: ST_TO_ADDR
// sBomb := false ;
18194: LD_ADDR_EXP 66
18198: PUSH
18199: LD_INT 0
18201: ST_TO_ADDR
// sWound := false ;
18202: LD_ADDR_EXP 74
18206: PUSH
18207: LD_INT 0
18209: ST_TO_ADDR
// sBetray := false ;
18210: LD_ADDR_EXP 78
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// sContamin := false ;
18218: LD_ADDR_EXP 79
18222: PUSH
18223: LD_INT 0
18225: ST_TO_ADDR
// sOil := false ;
18226: LD_ADDR_EXP 81
18230: PUSH
18231: LD_INT 0
18233: ST_TO_ADDR
// sStu := false ;
18234: LD_ADDR_EXP 85
18238: PUSH
18239: LD_INT 0
18241: ST_TO_ADDR
// sBazooka := false ;
18242: LD_ADDR_EXP 88
18246: PUSH
18247: LD_INT 0
18249: ST_TO_ADDR
// sMortar := false ;
18250: LD_ADDR_EXP 89
18254: PUSH
18255: LD_INT 0
18257: ST_TO_ADDR
// sRanger := false ;
18258: LD_ADDR_EXP 99
18262: PUSH
18263: LD_INT 0
18265: ST_TO_ADDR
// end ;
18266: LD_VAR 0 1
18270: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
18271: LD_INT 0
18273: PPUSH
18274: PPUSH
18275: PPUSH
18276: PPUSH
18277: PPUSH
// result := [ ] ;
18278: LD_ADDR_VAR 0 1
18282: PUSH
18283: EMPTY
18284: ST_TO_ADDR
// if campaign_id = 1 then
18285: LD_OWVAR 69
18289: PUSH
18290: LD_INT 1
18292: EQUAL
18293: IFFALSE 21231
// begin case mission_number of 1 :
18295: LD_OWVAR 70
18299: PUSH
18300: LD_INT 1
18302: DOUBLE
18303: EQUAL
18304: IFTRUE 18308
18306: GO 18372
18308: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
18309: LD_ADDR_VAR 0 1
18313: PUSH
18314: LD_INT 2
18316: PUSH
18317: LD_INT 4
18319: PUSH
18320: LD_INT 11
18322: PUSH
18323: LD_INT 12
18325: PUSH
18326: LD_INT 15
18328: PUSH
18329: LD_INT 16
18331: PUSH
18332: LD_INT 22
18334: PUSH
18335: LD_INT 23
18337: PUSH
18338: LD_INT 26
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: LIST
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 101
18354: PUSH
18355: LD_INT 102
18357: PUSH
18358: LD_INT 106
18360: PUSH
18361: EMPTY
18362: LIST
18363: LIST
18364: LIST
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: ST_TO_ADDR
18370: GO 21229
18372: LD_INT 2
18374: DOUBLE
18375: EQUAL
18376: IFTRUE 18380
18378: GO 18452
18380: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
18381: LD_ADDR_VAR 0 1
18385: PUSH
18386: LD_INT 2
18388: PUSH
18389: LD_INT 4
18391: PUSH
18392: LD_INT 11
18394: PUSH
18395: LD_INT 12
18397: PUSH
18398: LD_INT 15
18400: PUSH
18401: LD_INT 16
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 23
18409: PUSH
18410: LD_INT 26
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: LD_INT 101
18426: PUSH
18427: LD_INT 102
18429: PUSH
18430: LD_INT 105
18432: PUSH
18433: LD_INT 106
18435: PUSH
18436: LD_INT 108
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: ST_TO_ADDR
18450: GO 21229
18452: LD_INT 3
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18536
18460: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
18461: LD_ADDR_VAR 0 1
18465: PUSH
18466: LD_INT 2
18468: PUSH
18469: LD_INT 4
18471: PUSH
18472: LD_INT 5
18474: PUSH
18475: LD_INT 11
18477: PUSH
18478: LD_INT 12
18480: PUSH
18481: LD_INT 15
18483: PUSH
18484: LD_INT 16
18486: PUSH
18487: LD_INT 22
18489: PUSH
18490: LD_INT 26
18492: PUSH
18493: LD_INT 36
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: PUSH
18508: LD_INT 101
18510: PUSH
18511: LD_INT 102
18513: PUSH
18514: LD_INT 105
18516: PUSH
18517: LD_INT 106
18519: PUSH
18520: LD_INT 108
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: ST_TO_ADDR
18534: GO 21229
18536: LD_INT 4
18538: DOUBLE
18539: EQUAL
18540: IFTRUE 18544
18542: GO 18628
18544: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
18545: LD_ADDR_VAR 0 1
18549: PUSH
18550: LD_INT 2
18552: PUSH
18553: LD_INT 4
18555: PUSH
18556: LD_INT 5
18558: PUSH
18559: LD_INT 8
18561: PUSH
18562: LD_INT 11
18564: PUSH
18565: LD_INT 12
18567: PUSH
18568: LD_INT 15
18570: PUSH
18571: LD_INT 16
18573: PUSH
18574: LD_INT 22
18576: PUSH
18577: LD_INT 23
18579: PUSH
18580: LD_INT 26
18582: PUSH
18583: LD_INT 36
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: PUSH
18600: LD_INT 101
18602: PUSH
18603: LD_INT 102
18605: PUSH
18606: LD_INT 105
18608: PUSH
18609: LD_INT 106
18611: PUSH
18612: LD_INT 108
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: ST_TO_ADDR
18626: GO 21229
18628: LD_INT 5
18630: DOUBLE
18631: EQUAL
18632: IFTRUE 18636
18634: GO 18736
18636: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
18637: LD_ADDR_VAR 0 1
18641: PUSH
18642: LD_INT 2
18644: PUSH
18645: LD_INT 4
18647: PUSH
18648: LD_INT 5
18650: PUSH
18651: LD_INT 6
18653: PUSH
18654: LD_INT 8
18656: PUSH
18657: LD_INT 11
18659: PUSH
18660: LD_INT 12
18662: PUSH
18663: LD_INT 15
18665: PUSH
18666: LD_INT 16
18668: PUSH
18669: LD_INT 22
18671: PUSH
18672: LD_INT 23
18674: PUSH
18675: LD_INT 25
18677: PUSH
18678: LD_INT 26
18680: PUSH
18681: LD_INT 36
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: PUSH
18700: LD_INT 101
18702: PUSH
18703: LD_INT 102
18705: PUSH
18706: LD_INT 105
18708: PUSH
18709: LD_INT 106
18711: PUSH
18712: LD_INT 108
18714: PUSH
18715: LD_INT 109
18717: PUSH
18718: LD_INT 112
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: PUSH
18730: EMPTY
18731: LIST
18732: LIST
18733: ST_TO_ADDR
18734: GO 21229
18736: LD_INT 6
18738: DOUBLE
18739: EQUAL
18740: IFTRUE 18744
18742: GO 18864
18744: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
18745: LD_ADDR_VAR 0 1
18749: PUSH
18750: LD_INT 2
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: LD_INT 5
18758: PUSH
18759: LD_INT 6
18761: PUSH
18762: LD_INT 8
18764: PUSH
18765: LD_INT 11
18767: PUSH
18768: LD_INT 12
18770: PUSH
18771: LD_INT 15
18773: PUSH
18774: LD_INT 16
18776: PUSH
18777: LD_INT 20
18779: PUSH
18780: LD_INT 21
18782: PUSH
18783: LD_INT 22
18785: PUSH
18786: LD_INT 23
18788: PUSH
18789: LD_INT 25
18791: PUSH
18792: LD_INT 26
18794: PUSH
18795: LD_INT 30
18797: PUSH
18798: LD_INT 31
18800: PUSH
18801: LD_INT 32
18803: PUSH
18804: LD_INT 36
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: PUSH
18828: LD_INT 101
18830: PUSH
18831: LD_INT 102
18833: PUSH
18834: LD_INT 105
18836: PUSH
18837: LD_INT 106
18839: PUSH
18840: LD_INT 108
18842: PUSH
18843: LD_INT 109
18845: PUSH
18846: LD_INT 112
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: PUSH
18858: EMPTY
18859: LIST
18860: LIST
18861: ST_TO_ADDR
18862: GO 21229
18864: LD_INT 7
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18972
18872: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
18873: LD_ADDR_VAR 0 1
18877: PUSH
18878: LD_INT 2
18880: PUSH
18881: LD_INT 4
18883: PUSH
18884: LD_INT 5
18886: PUSH
18887: LD_INT 7
18889: PUSH
18890: LD_INT 11
18892: PUSH
18893: LD_INT 12
18895: PUSH
18896: LD_INT 15
18898: PUSH
18899: LD_INT 16
18901: PUSH
18902: LD_INT 20
18904: PUSH
18905: LD_INT 21
18907: PUSH
18908: LD_INT 22
18910: PUSH
18911: LD_INT 23
18913: PUSH
18914: LD_INT 25
18916: PUSH
18917: LD_INT 26
18919: PUSH
18920: EMPTY
18921: LIST
18922: LIST
18923: LIST
18924: LIST
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: PUSH
18936: LD_INT 101
18938: PUSH
18939: LD_INT 102
18941: PUSH
18942: LD_INT 103
18944: PUSH
18945: LD_INT 105
18947: PUSH
18948: LD_INT 106
18950: PUSH
18951: LD_INT 108
18953: PUSH
18954: LD_INT 112
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: PUSH
18966: EMPTY
18967: LIST
18968: LIST
18969: ST_TO_ADDR
18970: GO 21229
18972: LD_INT 8
18974: DOUBLE
18975: EQUAL
18976: IFTRUE 18980
18978: GO 19108
18980: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
18981: LD_ADDR_VAR 0 1
18985: PUSH
18986: LD_INT 2
18988: PUSH
18989: LD_INT 4
18991: PUSH
18992: LD_INT 5
18994: PUSH
18995: LD_INT 6
18997: PUSH
18998: LD_INT 7
19000: PUSH
19001: LD_INT 8
19003: PUSH
19004: LD_INT 11
19006: PUSH
19007: LD_INT 12
19009: PUSH
19010: LD_INT 15
19012: PUSH
19013: LD_INT 16
19015: PUSH
19016: LD_INT 20
19018: PUSH
19019: LD_INT 21
19021: PUSH
19022: LD_INT 22
19024: PUSH
19025: LD_INT 23
19027: PUSH
19028: LD_INT 25
19030: PUSH
19031: LD_INT 26
19033: PUSH
19034: LD_INT 30
19036: PUSH
19037: LD_INT 31
19039: PUSH
19040: LD_INT 32
19042: PUSH
19043: LD_INT 36
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: LIST
19050: LIST
19051: LIST
19052: LIST
19053: LIST
19054: LIST
19055: LIST
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: LIST
19066: LIST
19067: PUSH
19068: LD_INT 101
19070: PUSH
19071: LD_INT 102
19073: PUSH
19074: LD_INT 103
19076: PUSH
19077: LD_INT 105
19079: PUSH
19080: LD_INT 106
19082: PUSH
19083: LD_INT 108
19085: PUSH
19086: LD_INT 109
19088: PUSH
19089: LD_INT 112
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: ST_TO_ADDR
19106: GO 21229
19108: LD_INT 9
19110: DOUBLE
19111: EQUAL
19112: IFTRUE 19116
19114: GO 19252
19116: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19117: LD_ADDR_VAR 0 1
19121: PUSH
19122: LD_INT 2
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: LD_INT 6
19133: PUSH
19134: LD_INT 7
19136: PUSH
19137: LD_INT 8
19139: PUSH
19140: LD_INT 11
19142: PUSH
19143: LD_INT 12
19145: PUSH
19146: LD_INT 15
19148: PUSH
19149: LD_INT 16
19151: PUSH
19152: LD_INT 20
19154: PUSH
19155: LD_INT 21
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_INT 23
19163: PUSH
19164: LD_INT 25
19166: PUSH
19167: LD_INT 26
19169: PUSH
19170: LD_INT 28
19172: PUSH
19173: LD_INT 30
19175: PUSH
19176: LD_INT 31
19178: PUSH
19179: LD_INT 32
19181: PUSH
19182: LD_INT 36
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: LIST
19195: LIST
19196: LIST
19197: LIST
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: LIST
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 101
19210: PUSH
19211: LD_INT 102
19213: PUSH
19214: LD_INT 103
19216: PUSH
19217: LD_INT 105
19219: PUSH
19220: LD_INT 106
19222: PUSH
19223: LD_INT 108
19225: PUSH
19226: LD_INT 109
19228: PUSH
19229: LD_INT 112
19231: PUSH
19232: LD_INT 114
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: LIST
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: LIST
19244: LIST
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: ST_TO_ADDR
19250: GO 21229
19252: LD_INT 10
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19444
19260: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
19261: LD_ADDR_VAR 0 1
19265: PUSH
19266: LD_INT 2
19268: PUSH
19269: LD_INT 4
19271: PUSH
19272: LD_INT 5
19274: PUSH
19275: LD_INT 6
19277: PUSH
19278: LD_INT 7
19280: PUSH
19281: LD_INT 8
19283: PUSH
19284: LD_INT 9
19286: PUSH
19287: LD_INT 10
19289: PUSH
19290: LD_INT 11
19292: PUSH
19293: LD_INT 12
19295: PUSH
19296: LD_INT 13
19298: PUSH
19299: LD_INT 14
19301: PUSH
19302: LD_INT 15
19304: PUSH
19305: LD_INT 16
19307: PUSH
19308: LD_INT 17
19310: PUSH
19311: LD_INT 18
19313: PUSH
19314: LD_INT 19
19316: PUSH
19317: LD_INT 20
19319: PUSH
19320: LD_INT 21
19322: PUSH
19323: LD_INT 22
19325: PUSH
19326: LD_INT 23
19328: PUSH
19329: LD_INT 24
19331: PUSH
19332: LD_INT 25
19334: PUSH
19335: LD_INT 26
19337: PUSH
19338: LD_INT 28
19340: PUSH
19341: LD_INT 30
19343: PUSH
19344: LD_INT 31
19346: PUSH
19347: LD_INT 32
19349: PUSH
19350: LD_INT 36
19352: PUSH
19353: EMPTY
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: LIST
19362: LIST
19363: LIST
19364: LIST
19365: LIST
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: LIST
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: PUSH
19384: LD_INT 101
19386: PUSH
19387: LD_INT 102
19389: PUSH
19390: LD_INT 103
19392: PUSH
19393: LD_INT 104
19395: PUSH
19396: LD_INT 105
19398: PUSH
19399: LD_INT 106
19401: PUSH
19402: LD_INT 107
19404: PUSH
19405: LD_INT 108
19407: PUSH
19408: LD_INT 109
19410: PUSH
19411: LD_INT 110
19413: PUSH
19414: LD_INT 111
19416: PUSH
19417: LD_INT 112
19419: PUSH
19420: LD_INT 114
19422: PUSH
19423: EMPTY
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: LIST
19437: PUSH
19438: EMPTY
19439: LIST
19440: LIST
19441: ST_TO_ADDR
19442: GO 21229
19444: LD_INT 11
19446: DOUBLE
19447: EQUAL
19448: IFTRUE 19452
19450: GO 19644
19452: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
19453: LD_ADDR_VAR 0 1
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: LD_INT 3
19463: PUSH
19464: LD_INT 4
19466: PUSH
19467: LD_INT 5
19469: PUSH
19470: LD_INT 6
19472: PUSH
19473: LD_INT 7
19475: PUSH
19476: LD_INT 8
19478: PUSH
19479: LD_INT 9
19481: PUSH
19482: LD_INT 10
19484: PUSH
19485: LD_INT 11
19487: PUSH
19488: LD_INT 12
19490: PUSH
19491: LD_INT 13
19493: PUSH
19494: LD_INT 14
19496: PUSH
19497: LD_INT 15
19499: PUSH
19500: LD_INT 16
19502: PUSH
19503: LD_INT 17
19505: PUSH
19506: LD_INT 18
19508: PUSH
19509: LD_INT 19
19511: PUSH
19512: LD_INT 20
19514: PUSH
19515: LD_INT 21
19517: PUSH
19518: LD_INT 22
19520: PUSH
19521: LD_INT 23
19523: PUSH
19524: LD_INT 24
19526: PUSH
19527: LD_INT 25
19529: PUSH
19530: LD_INT 26
19532: PUSH
19533: LD_INT 28
19535: PUSH
19536: LD_INT 30
19538: PUSH
19539: LD_INT 31
19541: PUSH
19542: LD_INT 32
19544: PUSH
19545: LD_INT 34
19547: PUSH
19548: LD_INT 36
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: LIST
19555: LIST
19556: LIST
19557: LIST
19558: LIST
19559: LIST
19560: LIST
19561: LIST
19562: LIST
19563: LIST
19564: LIST
19565: LIST
19566: LIST
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_INT 101
19586: PUSH
19587: LD_INT 102
19589: PUSH
19590: LD_INT 103
19592: PUSH
19593: LD_INT 104
19595: PUSH
19596: LD_INT 105
19598: PUSH
19599: LD_INT 106
19601: PUSH
19602: LD_INT 107
19604: PUSH
19605: LD_INT 108
19607: PUSH
19608: LD_INT 109
19610: PUSH
19611: LD_INT 110
19613: PUSH
19614: LD_INT 111
19616: PUSH
19617: LD_INT 112
19619: PUSH
19620: LD_INT 114
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: ST_TO_ADDR
19642: GO 21229
19644: LD_INT 12
19646: DOUBLE
19647: EQUAL
19648: IFTRUE 19652
19650: GO 19860
19652: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
19653: LD_ADDR_VAR 0 1
19657: PUSH
19658: LD_INT 1
19660: PUSH
19661: LD_INT 2
19663: PUSH
19664: LD_INT 3
19666: PUSH
19667: LD_INT 4
19669: PUSH
19670: LD_INT 5
19672: PUSH
19673: LD_INT 6
19675: PUSH
19676: LD_INT 7
19678: PUSH
19679: LD_INT 8
19681: PUSH
19682: LD_INT 9
19684: PUSH
19685: LD_INT 10
19687: PUSH
19688: LD_INT 11
19690: PUSH
19691: LD_INT 12
19693: PUSH
19694: LD_INT 13
19696: PUSH
19697: LD_INT 14
19699: PUSH
19700: LD_INT 15
19702: PUSH
19703: LD_INT 16
19705: PUSH
19706: LD_INT 17
19708: PUSH
19709: LD_INT 18
19711: PUSH
19712: LD_INT 19
19714: PUSH
19715: LD_INT 20
19717: PUSH
19718: LD_INT 21
19720: PUSH
19721: LD_INT 22
19723: PUSH
19724: LD_INT 23
19726: PUSH
19727: LD_INT 24
19729: PUSH
19730: LD_INT 25
19732: PUSH
19733: LD_INT 26
19735: PUSH
19736: LD_INT 27
19738: PUSH
19739: LD_INT 28
19741: PUSH
19742: LD_INT 30
19744: PUSH
19745: LD_INT 31
19747: PUSH
19748: LD_INT 32
19750: PUSH
19751: LD_INT 33
19753: PUSH
19754: LD_INT 34
19756: PUSH
19757: LD_INT 36
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: LIST
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: PUSH
19796: LD_INT 101
19798: PUSH
19799: LD_INT 102
19801: PUSH
19802: LD_INT 103
19804: PUSH
19805: LD_INT 104
19807: PUSH
19808: LD_INT 105
19810: PUSH
19811: LD_INT 106
19813: PUSH
19814: LD_INT 107
19816: PUSH
19817: LD_INT 108
19819: PUSH
19820: LD_INT 109
19822: PUSH
19823: LD_INT 110
19825: PUSH
19826: LD_INT 111
19828: PUSH
19829: LD_INT 112
19831: PUSH
19832: LD_INT 113
19834: PUSH
19835: LD_INT 114
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: LIST
19852: LIST
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: ST_TO_ADDR
19858: GO 21229
19860: LD_INT 13
19862: DOUBLE
19863: EQUAL
19864: IFTRUE 19868
19866: GO 20064
19868: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
19869: LD_ADDR_VAR 0 1
19873: PUSH
19874: LD_INT 1
19876: PUSH
19877: LD_INT 2
19879: PUSH
19880: LD_INT 3
19882: PUSH
19883: LD_INT 4
19885: PUSH
19886: LD_INT 5
19888: PUSH
19889: LD_INT 8
19891: PUSH
19892: LD_INT 9
19894: PUSH
19895: LD_INT 10
19897: PUSH
19898: LD_INT 11
19900: PUSH
19901: LD_INT 12
19903: PUSH
19904: LD_INT 14
19906: PUSH
19907: LD_INT 15
19909: PUSH
19910: LD_INT 16
19912: PUSH
19913: LD_INT 17
19915: PUSH
19916: LD_INT 18
19918: PUSH
19919: LD_INT 19
19921: PUSH
19922: LD_INT 20
19924: PUSH
19925: LD_INT 21
19927: PUSH
19928: LD_INT 22
19930: PUSH
19931: LD_INT 23
19933: PUSH
19934: LD_INT 24
19936: PUSH
19937: LD_INT 25
19939: PUSH
19940: LD_INT 26
19942: PUSH
19943: LD_INT 27
19945: PUSH
19946: LD_INT 28
19948: PUSH
19949: LD_INT 30
19951: PUSH
19952: LD_INT 31
19954: PUSH
19955: LD_INT 32
19957: PUSH
19958: LD_INT 33
19960: PUSH
19961: LD_INT 34
19963: PUSH
19964: LD_INT 36
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: PUSH
20000: LD_INT 101
20002: PUSH
20003: LD_INT 102
20005: PUSH
20006: LD_INT 103
20008: PUSH
20009: LD_INT 104
20011: PUSH
20012: LD_INT 105
20014: PUSH
20015: LD_INT 106
20017: PUSH
20018: LD_INT 107
20020: PUSH
20021: LD_INT 108
20023: PUSH
20024: LD_INT 109
20026: PUSH
20027: LD_INT 110
20029: PUSH
20030: LD_INT 111
20032: PUSH
20033: LD_INT 112
20035: PUSH
20036: LD_INT 113
20038: PUSH
20039: LD_INT 114
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: LIST
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: LIST
20054: LIST
20055: LIST
20056: LIST
20057: PUSH
20058: EMPTY
20059: LIST
20060: LIST
20061: ST_TO_ADDR
20062: GO 21229
20064: LD_INT 14
20066: DOUBLE
20067: EQUAL
20068: IFTRUE 20072
20070: GO 20284
20072: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20073: LD_ADDR_VAR 0 1
20077: PUSH
20078: LD_INT 1
20080: PUSH
20081: LD_INT 2
20083: PUSH
20084: LD_INT 3
20086: PUSH
20087: LD_INT 4
20089: PUSH
20090: LD_INT 5
20092: PUSH
20093: LD_INT 6
20095: PUSH
20096: LD_INT 7
20098: PUSH
20099: LD_INT 8
20101: PUSH
20102: LD_INT 9
20104: PUSH
20105: LD_INT 10
20107: PUSH
20108: LD_INT 11
20110: PUSH
20111: LD_INT 12
20113: PUSH
20114: LD_INT 13
20116: PUSH
20117: LD_INT 14
20119: PUSH
20120: LD_INT 15
20122: PUSH
20123: LD_INT 16
20125: PUSH
20126: LD_INT 17
20128: PUSH
20129: LD_INT 18
20131: PUSH
20132: LD_INT 19
20134: PUSH
20135: LD_INT 20
20137: PUSH
20138: LD_INT 21
20140: PUSH
20141: LD_INT 22
20143: PUSH
20144: LD_INT 23
20146: PUSH
20147: LD_INT 24
20149: PUSH
20150: LD_INT 25
20152: PUSH
20153: LD_INT 26
20155: PUSH
20156: LD_INT 27
20158: PUSH
20159: LD_INT 28
20161: PUSH
20162: LD_INT 29
20164: PUSH
20165: LD_INT 30
20167: PUSH
20168: LD_INT 31
20170: PUSH
20171: LD_INT 32
20173: PUSH
20174: LD_INT 33
20176: PUSH
20177: LD_INT 34
20179: PUSH
20180: LD_INT 36
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: PUSH
20220: LD_INT 101
20222: PUSH
20223: LD_INT 102
20225: PUSH
20226: LD_INT 103
20228: PUSH
20229: LD_INT 104
20231: PUSH
20232: LD_INT 105
20234: PUSH
20235: LD_INT 106
20237: PUSH
20238: LD_INT 107
20240: PUSH
20241: LD_INT 108
20243: PUSH
20244: LD_INT 109
20246: PUSH
20247: LD_INT 110
20249: PUSH
20250: LD_INT 111
20252: PUSH
20253: LD_INT 112
20255: PUSH
20256: LD_INT 113
20258: PUSH
20259: LD_INT 114
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: LIST
20266: LIST
20267: LIST
20268: LIST
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: ST_TO_ADDR
20282: GO 21229
20284: LD_INT 15
20286: DOUBLE
20287: EQUAL
20288: IFTRUE 20292
20290: GO 20504
20292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
20293: LD_ADDR_VAR 0 1
20297: PUSH
20298: LD_INT 1
20300: PUSH
20301: LD_INT 2
20303: PUSH
20304: LD_INT 3
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 5
20312: PUSH
20313: LD_INT 6
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: LD_INT 8
20321: PUSH
20322: LD_INT 9
20324: PUSH
20325: LD_INT 10
20327: PUSH
20328: LD_INT 11
20330: PUSH
20331: LD_INT 12
20333: PUSH
20334: LD_INT 13
20336: PUSH
20337: LD_INT 14
20339: PUSH
20340: LD_INT 15
20342: PUSH
20343: LD_INT 16
20345: PUSH
20346: LD_INT 17
20348: PUSH
20349: LD_INT 18
20351: PUSH
20352: LD_INT 19
20354: PUSH
20355: LD_INT 20
20357: PUSH
20358: LD_INT 21
20360: PUSH
20361: LD_INT 22
20363: PUSH
20364: LD_INT 23
20366: PUSH
20367: LD_INT 24
20369: PUSH
20370: LD_INT 25
20372: PUSH
20373: LD_INT 26
20375: PUSH
20376: LD_INT 27
20378: PUSH
20379: LD_INT 28
20381: PUSH
20382: LD_INT 29
20384: PUSH
20385: LD_INT 30
20387: PUSH
20388: LD_INT 31
20390: PUSH
20391: LD_INT 32
20393: PUSH
20394: LD_INT 33
20396: PUSH
20397: LD_INT 34
20399: PUSH
20400: LD_INT 36
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 101
20442: PUSH
20443: LD_INT 102
20445: PUSH
20446: LD_INT 103
20448: PUSH
20449: LD_INT 104
20451: PUSH
20452: LD_INT 105
20454: PUSH
20455: LD_INT 106
20457: PUSH
20458: LD_INT 107
20460: PUSH
20461: LD_INT 108
20463: PUSH
20464: LD_INT 109
20466: PUSH
20467: LD_INT 110
20469: PUSH
20470: LD_INT 111
20472: PUSH
20473: LD_INT 112
20475: PUSH
20476: LD_INT 113
20478: PUSH
20479: LD_INT 114
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: LIST
20488: LIST
20489: LIST
20490: LIST
20491: LIST
20492: LIST
20493: LIST
20494: LIST
20495: LIST
20496: LIST
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: ST_TO_ADDR
20502: GO 21229
20504: LD_INT 16
20506: DOUBLE
20507: EQUAL
20508: IFTRUE 20512
20510: GO 20636
20512: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
20513: LD_ADDR_VAR 0 1
20517: PUSH
20518: LD_INT 2
20520: PUSH
20521: LD_INT 4
20523: PUSH
20524: LD_INT 5
20526: PUSH
20527: LD_INT 7
20529: PUSH
20530: LD_INT 11
20532: PUSH
20533: LD_INT 12
20535: PUSH
20536: LD_INT 15
20538: PUSH
20539: LD_INT 16
20541: PUSH
20542: LD_INT 20
20544: PUSH
20545: LD_INT 21
20547: PUSH
20548: LD_INT 22
20550: PUSH
20551: LD_INT 23
20553: PUSH
20554: LD_INT 25
20556: PUSH
20557: LD_INT 26
20559: PUSH
20560: LD_INT 30
20562: PUSH
20563: LD_INT 31
20565: PUSH
20566: LD_INT 32
20568: PUSH
20569: LD_INT 33
20571: PUSH
20572: LD_INT 34
20574: PUSH
20575: EMPTY
20576: LIST
20577: LIST
20578: LIST
20579: LIST
20580: LIST
20581: LIST
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 101
20598: PUSH
20599: LD_INT 102
20601: PUSH
20602: LD_INT 103
20604: PUSH
20605: LD_INT 106
20607: PUSH
20608: LD_INT 108
20610: PUSH
20611: LD_INT 112
20613: PUSH
20614: LD_INT 113
20616: PUSH
20617: LD_INT 114
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: PUSH
20630: EMPTY
20631: LIST
20632: LIST
20633: ST_TO_ADDR
20634: GO 21229
20636: LD_INT 17
20638: DOUBLE
20639: EQUAL
20640: IFTRUE 20644
20642: GO 20856
20644: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
20645: LD_ADDR_VAR 0 1
20649: PUSH
20650: LD_INT 1
20652: PUSH
20653: LD_INT 2
20655: PUSH
20656: LD_INT 3
20658: PUSH
20659: LD_INT 4
20661: PUSH
20662: LD_INT 5
20664: PUSH
20665: LD_INT 6
20667: PUSH
20668: LD_INT 7
20670: PUSH
20671: LD_INT 8
20673: PUSH
20674: LD_INT 9
20676: PUSH
20677: LD_INT 10
20679: PUSH
20680: LD_INT 11
20682: PUSH
20683: LD_INT 12
20685: PUSH
20686: LD_INT 13
20688: PUSH
20689: LD_INT 14
20691: PUSH
20692: LD_INT 15
20694: PUSH
20695: LD_INT 16
20697: PUSH
20698: LD_INT 17
20700: PUSH
20701: LD_INT 18
20703: PUSH
20704: LD_INT 19
20706: PUSH
20707: LD_INT 20
20709: PUSH
20710: LD_INT 21
20712: PUSH
20713: LD_INT 22
20715: PUSH
20716: LD_INT 23
20718: PUSH
20719: LD_INT 24
20721: PUSH
20722: LD_INT 25
20724: PUSH
20725: LD_INT 26
20727: PUSH
20728: LD_INT 27
20730: PUSH
20731: LD_INT 28
20733: PUSH
20734: LD_INT 29
20736: PUSH
20737: LD_INT 30
20739: PUSH
20740: LD_INT 31
20742: PUSH
20743: LD_INT 32
20745: PUSH
20746: LD_INT 33
20748: PUSH
20749: LD_INT 34
20751: PUSH
20752: LD_INT 36
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: LIST
20759: LIST
20760: LIST
20761: LIST
20762: LIST
20763: LIST
20764: LIST
20765: LIST
20766: LIST
20767: LIST
20768: LIST
20769: LIST
20770: LIST
20771: LIST
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: LIST
20777: LIST
20778: LIST
20779: LIST
20780: LIST
20781: LIST
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: PUSH
20792: LD_INT 101
20794: PUSH
20795: LD_INT 102
20797: PUSH
20798: LD_INT 103
20800: PUSH
20801: LD_INT 104
20803: PUSH
20804: LD_INT 105
20806: PUSH
20807: LD_INT 106
20809: PUSH
20810: LD_INT 107
20812: PUSH
20813: LD_INT 108
20815: PUSH
20816: LD_INT 109
20818: PUSH
20819: LD_INT 110
20821: PUSH
20822: LD_INT 111
20824: PUSH
20825: LD_INT 112
20827: PUSH
20828: LD_INT 113
20830: PUSH
20831: LD_INT 114
20833: PUSH
20834: EMPTY
20835: LIST
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: LIST
20845: LIST
20846: LIST
20847: LIST
20848: LIST
20849: PUSH
20850: EMPTY
20851: LIST
20852: LIST
20853: ST_TO_ADDR
20854: GO 21229
20856: LD_INT 18
20858: DOUBLE
20859: EQUAL
20860: IFTRUE 20864
20862: GO 21000
20864: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
20865: LD_ADDR_VAR 0 1
20869: PUSH
20870: LD_INT 2
20872: PUSH
20873: LD_INT 4
20875: PUSH
20876: LD_INT 5
20878: PUSH
20879: LD_INT 7
20881: PUSH
20882: LD_INT 11
20884: PUSH
20885: LD_INT 12
20887: PUSH
20888: LD_INT 15
20890: PUSH
20891: LD_INT 16
20893: PUSH
20894: LD_INT 20
20896: PUSH
20897: LD_INT 21
20899: PUSH
20900: LD_INT 22
20902: PUSH
20903: LD_INT 23
20905: PUSH
20906: LD_INT 25
20908: PUSH
20909: LD_INT 26
20911: PUSH
20912: LD_INT 30
20914: PUSH
20915: LD_INT 31
20917: PUSH
20918: LD_INT 32
20920: PUSH
20921: LD_INT 33
20923: PUSH
20924: LD_INT 34
20926: PUSH
20927: LD_INT 35
20929: PUSH
20930: LD_INT 36
20932: PUSH
20933: EMPTY
20934: LIST
20935: LIST
20936: LIST
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: LIST
20954: LIST
20955: PUSH
20956: LD_INT 101
20958: PUSH
20959: LD_INT 102
20961: PUSH
20962: LD_INT 103
20964: PUSH
20965: LD_INT 106
20967: PUSH
20968: LD_INT 108
20970: PUSH
20971: LD_INT 112
20973: PUSH
20974: LD_INT 113
20976: PUSH
20977: LD_INT 114
20979: PUSH
20980: LD_INT 115
20982: PUSH
20983: EMPTY
20984: LIST
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: ST_TO_ADDR
20998: GO 21229
21000: LD_INT 19
21002: DOUBLE
21003: EQUAL
21004: IFTRUE 21008
21006: GO 21228
21008: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21009: LD_ADDR_VAR 0 1
21013: PUSH
21014: LD_INT 1
21016: PUSH
21017: LD_INT 2
21019: PUSH
21020: LD_INT 3
21022: PUSH
21023: LD_INT 4
21025: PUSH
21026: LD_INT 5
21028: PUSH
21029: LD_INT 6
21031: PUSH
21032: LD_INT 7
21034: PUSH
21035: LD_INT 8
21037: PUSH
21038: LD_INT 9
21040: PUSH
21041: LD_INT 10
21043: PUSH
21044: LD_INT 11
21046: PUSH
21047: LD_INT 12
21049: PUSH
21050: LD_INT 13
21052: PUSH
21053: LD_INT 14
21055: PUSH
21056: LD_INT 15
21058: PUSH
21059: LD_INT 16
21061: PUSH
21062: LD_INT 17
21064: PUSH
21065: LD_INT 18
21067: PUSH
21068: LD_INT 19
21070: PUSH
21071: LD_INT 20
21073: PUSH
21074: LD_INT 21
21076: PUSH
21077: LD_INT 22
21079: PUSH
21080: LD_INT 23
21082: PUSH
21083: LD_INT 24
21085: PUSH
21086: LD_INT 25
21088: PUSH
21089: LD_INT 26
21091: PUSH
21092: LD_INT 27
21094: PUSH
21095: LD_INT 28
21097: PUSH
21098: LD_INT 29
21100: PUSH
21101: LD_INT 30
21103: PUSH
21104: LD_INT 31
21106: PUSH
21107: LD_INT 32
21109: PUSH
21110: LD_INT 33
21112: PUSH
21113: LD_INT 34
21115: PUSH
21116: LD_INT 35
21118: PUSH
21119: LD_INT 36
21121: PUSH
21122: EMPTY
21123: LIST
21124: LIST
21125: LIST
21126: LIST
21127: LIST
21128: LIST
21129: LIST
21130: LIST
21131: LIST
21132: LIST
21133: LIST
21134: LIST
21135: LIST
21136: LIST
21137: LIST
21138: LIST
21139: LIST
21140: LIST
21141: LIST
21142: LIST
21143: LIST
21144: LIST
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: PUSH
21160: LD_INT 101
21162: PUSH
21163: LD_INT 102
21165: PUSH
21166: LD_INT 103
21168: PUSH
21169: LD_INT 104
21171: PUSH
21172: LD_INT 105
21174: PUSH
21175: LD_INT 106
21177: PUSH
21178: LD_INT 107
21180: PUSH
21181: LD_INT 108
21183: PUSH
21184: LD_INT 109
21186: PUSH
21187: LD_INT 110
21189: PUSH
21190: LD_INT 111
21192: PUSH
21193: LD_INT 112
21195: PUSH
21196: LD_INT 113
21198: PUSH
21199: LD_INT 114
21201: PUSH
21202: LD_INT 115
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: LIST
21209: LIST
21210: LIST
21211: LIST
21212: LIST
21213: LIST
21214: LIST
21215: LIST
21216: LIST
21217: LIST
21218: LIST
21219: LIST
21220: LIST
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: ST_TO_ADDR
21226: GO 21229
21228: POP
// end else
21229: GO 21266
// if campaign_id = 5 then
21231: LD_OWVAR 69
21235: PUSH
21236: LD_INT 5
21238: EQUAL
21239: IFFALSE 21266
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
21241: LD_ADDR_VAR 0 1
21245: PUSH
21246: LD_INT 1
21248: PUSH
21249: LD_INT 2
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: PUSH
21256: LD_INT 100
21258: PUSH
21259: EMPTY
21260: LIST
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: ST_TO_ADDR
// end ; if result then
21266: LD_VAR 0 1
21270: IFFALSE 21559
// begin normal :=  ;
21272: LD_ADDR_VAR 0 3
21276: PUSH
21277: LD_STRING 
21279: ST_TO_ADDR
// hardcore :=  ;
21280: LD_ADDR_VAR 0 4
21284: PUSH
21285: LD_STRING 
21287: ST_TO_ADDR
// for i = 1 to normalCounter do
21288: LD_ADDR_VAR 0 5
21292: PUSH
21293: DOUBLE
21294: LD_INT 1
21296: DEC
21297: ST_TO_ADDR
21298: LD_EXP 47
21302: PUSH
21303: FOR_TO
21304: IFFALSE 21405
// begin tmp := 0 ;
21306: LD_ADDR_VAR 0 2
21310: PUSH
21311: LD_STRING 0
21313: ST_TO_ADDR
// if result [ 1 ] then
21314: LD_VAR 0 1
21318: PUSH
21319: LD_INT 1
21321: ARRAY
21322: IFFALSE 21387
// if result [ 1 ] [ 1 ] = i then
21324: LD_VAR 0 1
21328: PUSH
21329: LD_INT 1
21331: ARRAY
21332: PUSH
21333: LD_INT 1
21335: ARRAY
21336: PUSH
21337: LD_VAR 0 5
21341: EQUAL
21342: IFFALSE 21387
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
21344: LD_ADDR_VAR 0 1
21348: PUSH
21349: LD_VAR 0 1
21353: PPUSH
21354: LD_INT 1
21356: PPUSH
21357: LD_VAR 0 1
21361: PUSH
21362: LD_INT 1
21364: ARRAY
21365: PPUSH
21366: LD_INT 1
21368: PPUSH
21369: CALL_OW 3
21373: PPUSH
21374: CALL_OW 1
21378: ST_TO_ADDR
// tmp := 1 ;
21379: LD_ADDR_VAR 0 2
21383: PUSH
21384: LD_STRING 1
21386: ST_TO_ADDR
// end ; normal := normal & tmp ;
21387: LD_ADDR_VAR 0 3
21391: PUSH
21392: LD_VAR 0 3
21396: PUSH
21397: LD_VAR 0 2
21401: STR
21402: ST_TO_ADDR
// end ;
21403: GO 21303
21405: POP
21406: POP
// for i = 1 to hardcoreCounter do
21407: LD_ADDR_VAR 0 5
21411: PUSH
21412: DOUBLE
21413: LD_INT 1
21415: DEC
21416: ST_TO_ADDR
21417: LD_EXP 48
21421: PUSH
21422: FOR_TO
21423: IFFALSE 21528
// begin tmp := 0 ;
21425: LD_ADDR_VAR 0 2
21429: PUSH
21430: LD_STRING 0
21432: ST_TO_ADDR
// if result [ 2 ] then
21433: LD_VAR 0 1
21437: PUSH
21438: LD_INT 2
21440: ARRAY
21441: IFFALSE 21510
// if result [ 2 ] [ 1 ] = 100 + i then
21443: LD_VAR 0 1
21447: PUSH
21448: LD_INT 2
21450: ARRAY
21451: PUSH
21452: LD_INT 1
21454: ARRAY
21455: PUSH
21456: LD_INT 100
21458: PUSH
21459: LD_VAR 0 5
21463: PLUS
21464: EQUAL
21465: IFFALSE 21510
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
21467: LD_ADDR_VAR 0 1
21471: PUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: LD_VAR 0 1
21484: PUSH
21485: LD_INT 2
21487: ARRAY
21488: PPUSH
21489: LD_INT 1
21491: PPUSH
21492: CALL_OW 3
21496: PPUSH
21497: CALL_OW 1
21501: ST_TO_ADDR
// tmp := 1 ;
21502: LD_ADDR_VAR 0 2
21506: PUSH
21507: LD_STRING 1
21509: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
21510: LD_ADDR_VAR 0 4
21514: PUSH
21515: LD_VAR 0 4
21519: PUSH
21520: LD_VAR 0 2
21524: STR
21525: ST_TO_ADDR
// end ;
21526: GO 21422
21528: POP
21529: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
21530: LD_STRING getStreamItemsFromMission("
21532: PUSH
21533: LD_VAR 0 3
21537: STR
21538: PUSH
21539: LD_STRING ","
21541: STR
21542: PUSH
21543: LD_VAR 0 4
21547: STR
21548: PUSH
21549: LD_STRING ")
21551: STR
21552: PPUSH
21553: CALL_OW 559
// end else
21557: GO 21566
// ToLua ( getStreamItemsFromMission("","") ) ;
21559: LD_STRING getStreamItemsFromMission("","")
21561: PPUSH
21562: CALL_OW 559
// end ;
21566: LD_VAR 0 1
21570: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
21571: LD_VAR 0 2
21575: PUSH
21576: LD_INT 100
21578: EQUAL
21579: IFFALSE 22528
// begin if not StreamModeActive then
21581: LD_EXP 46
21585: NOT
21586: IFFALSE 21596
// StreamModeActive := true ;
21588: LD_ADDR_EXP 46
21592: PUSH
21593: LD_INT 1
21595: ST_TO_ADDR
// if p3 = 0 then
21596: LD_VAR 0 3
21600: PUSH
21601: LD_INT 0
21603: EQUAL
21604: IFFALSE 21610
// InitStreamMode ;
21606: CALL 17831 0 0
// if p3 = 1 then
21610: LD_VAR 0 3
21614: PUSH
21615: LD_INT 1
21617: EQUAL
21618: IFFALSE 21628
// sRocket := true ;
21620: LD_ADDR_EXP 51
21624: PUSH
21625: LD_INT 1
21627: ST_TO_ADDR
// if p3 = 2 then
21628: LD_VAR 0 3
21632: PUSH
21633: LD_INT 2
21635: EQUAL
21636: IFFALSE 21646
// sSpeed := true ;
21638: LD_ADDR_EXP 50
21642: PUSH
21643: LD_INT 1
21645: ST_TO_ADDR
// if p3 = 3 then
21646: LD_VAR 0 3
21650: PUSH
21651: LD_INT 3
21653: EQUAL
21654: IFFALSE 21664
// sEngine := true ;
21656: LD_ADDR_EXP 52
21660: PUSH
21661: LD_INT 1
21663: ST_TO_ADDR
// if p3 = 4 then
21664: LD_VAR 0 3
21668: PUSH
21669: LD_INT 4
21671: EQUAL
21672: IFFALSE 21682
// sSpec := true ;
21674: LD_ADDR_EXP 49
21678: PUSH
21679: LD_INT 1
21681: ST_TO_ADDR
// if p3 = 5 then
21682: LD_VAR 0 3
21686: PUSH
21687: LD_INT 5
21689: EQUAL
21690: IFFALSE 21700
// sLevel := true ;
21692: LD_ADDR_EXP 53
21696: PUSH
21697: LD_INT 1
21699: ST_TO_ADDR
// if p3 = 6 then
21700: LD_VAR 0 3
21704: PUSH
21705: LD_INT 6
21707: EQUAL
21708: IFFALSE 21718
// sArmoury := true ;
21710: LD_ADDR_EXP 54
21714: PUSH
21715: LD_INT 1
21717: ST_TO_ADDR
// if p3 = 7 then
21718: LD_VAR 0 3
21722: PUSH
21723: LD_INT 7
21725: EQUAL
21726: IFFALSE 21736
// sRadar := true ;
21728: LD_ADDR_EXP 55
21732: PUSH
21733: LD_INT 1
21735: ST_TO_ADDR
// if p3 = 8 then
21736: LD_VAR 0 3
21740: PUSH
21741: LD_INT 8
21743: EQUAL
21744: IFFALSE 21754
// sBunker := true ;
21746: LD_ADDR_EXP 56
21750: PUSH
21751: LD_INT 1
21753: ST_TO_ADDR
// if p3 = 9 then
21754: LD_VAR 0 3
21758: PUSH
21759: LD_INT 9
21761: EQUAL
21762: IFFALSE 21772
// sHack := true ;
21764: LD_ADDR_EXP 57
21768: PUSH
21769: LD_INT 1
21771: ST_TO_ADDR
// if p3 = 10 then
21772: LD_VAR 0 3
21776: PUSH
21777: LD_INT 10
21779: EQUAL
21780: IFFALSE 21790
// sFire := true ;
21782: LD_ADDR_EXP 58
21786: PUSH
21787: LD_INT 1
21789: ST_TO_ADDR
// if p3 = 11 then
21790: LD_VAR 0 3
21794: PUSH
21795: LD_INT 11
21797: EQUAL
21798: IFFALSE 21808
// sRefresh := true ;
21800: LD_ADDR_EXP 59
21804: PUSH
21805: LD_INT 1
21807: ST_TO_ADDR
// if p3 = 12 then
21808: LD_VAR 0 3
21812: PUSH
21813: LD_INT 12
21815: EQUAL
21816: IFFALSE 21826
// sExp := true ;
21818: LD_ADDR_EXP 60
21822: PUSH
21823: LD_INT 1
21825: ST_TO_ADDR
// if p3 = 13 then
21826: LD_VAR 0 3
21830: PUSH
21831: LD_INT 13
21833: EQUAL
21834: IFFALSE 21844
// sDepot := true ;
21836: LD_ADDR_EXP 61
21840: PUSH
21841: LD_INT 1
21843: ST_TO_ADDR
// if p3 = 14 then
21844: LD_VAR 0 3
21848: PUSH
21849: LD_INT 14
21851: EQUAL
21852: IFFALSE 21862
// sFlag := true ;
21854: LD_ADDR_EXP 62
21858: PUSH
21859: LD_INT 1
21861: ST_TO_ADDR
// if p3 = 15 then
21862: LD_VAR 0 3
21866: PUSH
21867: LD_INT 15
21869: EQUAL
21870: IFFALSE 21880
// sKamikadze := true ;
21872: LD_ADDR_EXP 70
21876: PUSH
21877: LD_INT 1
21879: ST_TO_ADDR
// if p3 = 16 then
21880: LD_VAR 0 3
21884: PUSH
21885: LD_INT 16
21887: EQUAL
21888: IFFALSE 21898
// sTroll := true ;
21890: LD_ADDR_EXP 71
21894: PUSH
21895: LD_INT 1
21897: ST_TO_ADDR
// if p3 = 17 then
21898: LD_VAR 0 3
21902: PUSH
21903: LD_INT 17
21905: EQUAL
21906: IFFALSE 21916
// sSlow := true ;
21908: LD_ADDR_EXP 72
21912: PUSH
21913: LD_INT 1
21915: ST_TO_ADDR
// if p3 = 18 then
21916: LD_VAR 0 3
21920: PUSH
21921: LD_INT 18
21923: EQUAL
21924: IFFALSE 21934
// sLack := true ;
21926: LD_ADDR_EXP 73
21930: PUSH
21931: LD_INT 1
21933: ST_TO_ADDR
// if p3 = 19 then
21934: LD_VAR 0 3
21938: PUSH
21939: LD_INT 19
21941: EQUAL
21942: IFFALSE 21952
// sTank := true ;
21944: LD_ADDR_EXP 75
21948: PUSH
21949: LD_INT 1
21951: ST_TO_ADDR
// if p3 = 20 then
21952: LD_VAR 0 3
21956: PUSH
21957: LD_INT 20
21959: EQUAL
21960: IFFALSE 21970
// sRemote := true ;
21962: LD_ADDR_EXP 76
21966: PUSH
21967: LD_INT 1
21969: ST_TO_ADDR
// if p3 = 21 then
21970: LD_VAR 0 3
21974: PUSH
21975: LD_INT 21
21977: EQUAL
21978: IFFALSE 21988
// sPowell := true ;
21980: LD_ADDR_EXP 77
21984: PUSH
21985: LD_INT 1
21987: ST_TO_ADDR
// if p3 = 22 then
21988: LD_VAR 0 3
21992: PUSH
21993: LD_INT 22
21995: EQUAL
21996: IFFALSE 22006
// sTeleport := true ;
21998: LD_ADDR_EXP 80
22002: PUSH
22003: LD_INT 1
22005: ST_TO_ADDR
// if p3 = 23 then
22006: LD_VAR 0 3
22010: PUSH
22011: LD_INT 23
22013: EQUAL
22014: IFFALSE 22024
// sOilTower := true ;
22016: LD_ADDR_EXP 82
22020: PUSH
22021: LD_INT 1
22023: ST_TO_ADDR
// if p3 = 24 then
22024: LD_VAR 0 3
22028: PUSH
22029: LD_INT 24
22031: EQUAL
22032: IFFALSE 22042
// sShovel := true ;
22034: LD_ADDR_EXP 83
22038: PUSH
22039: LD_INT 1
22041: ST_TO_ADDR
// if p3 = 25 then
22042: LD_VAR 0 3
22046: PUSH
22047: LD_INT 25
22049: EQUAL
22050: IFFALSE 22060
// sSheik := true ;
22052: LD_ADDR_EXP 84
22056: PUSH
22057: LD_INT 1
22059: ST_TO_ADDR
// if p3 = 26 then
22060: LD_VAR 0 3
22064: PUSH
22065: LD_INT 26
22067: EQUAL
22068: IFFALSE 22078
// sEarthquake := true ;
22070: LD_ADDR_EXP 86
22074: PUSH
22075: LD_INT 1
22077: ST_TO_ADDR
// if p3 = 27 then
22078: LD_VAR 0 3
22082: PUSH
22083: LD_INT 27
22085: EQUAL
22086: IFFALSE 22096
// sAI := true ;
22088: LD_ADDR_EXP 87
22092: PUSH
22093: LD_INT 1
22095: ST_TO_ADDR
// if p3 = 28 then
22096: LD_VAR 0 3
22100: PUSH
22101: LD_INT 28
22103: EQUAL
22104: IFFALSE 22114
// sCargo := true ;
22106: LD_ADDR_EXP 90
22110: PUSH
22111: LD_INT 1
22113: ST_TO_ADDR
// if p3 = 29 then
22114: LD_VAR 0 3
22118: PUSH
22119: LD_INT 29
22121: EQUAL
22122: IFFALSE 22132
// sDLaser := true ;
22124: LD_ADDR_EXP 91
22128: PUSH
22129: LD_INT 1
22131: ST_TO_ADDR
// if p3 = 30 then
22132: LD_VAR 0 3
22136: PUSH
22137: LD_INT 30
22139: EQUAL
22140: IFFALSE 22150
// sExchange := true ;
22142: LD_ADDR_EXP 92
22146: PUSH
22147: LD_INT 1
22149: ST_TO_ADDR
// if p3 = 31 then
22150: LD_VAR 0 3
22154: PUSH
22155: LD_INT 31
22157: EQUAL
22158: IFFALSE 22168
// sFac := true ;
22160: LD_ADDR_EXP 93
22164: PUSH
22165: LD_INT 1
22167: ST_TO_ADDR
// if p3 = 32 then
22168: LD_VAR 0 3
22172: PUSH
22173: LD_INT 32
22175: EQUAL
22176: IFFALSE 22186
// sPower := true ;
22178: LD_ADDR_EXP 94
22182: PUSH
22183: LD_INT 1
22185: ST_TO_ADDR
// if p3 = 33 then
22186: LD_VAR 0 3
22190: PUSH
22191: LD_INT 33
22193: EQUAL
22194: IFFALSE 22204
// sRandom := true ;
22196: LD_ADDR_EXP 95
22200: PUSH
22201: LD_INT 1
22203: ST_TO_ADDR
// if p3 = 34 then
22204: LD_VAR 0 3
22208: PUSH
22209: LD_INT 34
22211: EQUAL
22212: IFFALSE 22222
// sShield := true ;
22214: LD_ADDR_EXP 96
22218: PUSH
22219: LD_INT 1
22221: ST_TO_ADDR
// if p3 = 35 then
22222: LD_VAR 0 3
22226: PUSH
22227: LD_INT 35
22229: EQUAL
22230: IFFALSE 22240
// sTime := true ;
22232: LD_ADDR_EXP 97
22236: PUSH
22237: LD_INT 1
22239: ST_TO_ADDR
// if p3 = 36 then
22240: LD_VAR 0 3
22244: PUSH
22245: LD_INT 36
22247: EQUAL
22248: IFFALSE 22258
// sTools := true ;
22250: LD_ADDR_EXP 98
22254: PUSH
22255: LD_INT 1
22257: ST_TO_ADDR
// if p3 = 101 then
22258: LD_VAR 0 3
22262: PUSH
22263: LD_INT 101
22265: EQUAL
22266: IFFALSE 22276
// sSold := true ;
22268: LD_ADDR_EXP 63
22272: PUSH
22273: LD_INT 1
22275: ST_TO_ADDR
// if p3 = 102 then
22276: LD_VAR 0 3
22280: PUSH
22281: LD_INT 102
22283: EQUAL
22284: IFFALSE 22294
// sDiff := true ;
22286: LD_ADDR_EXP 64
22290: PUSH
22291: LD_INT 1
22293: ST_TO_ADDR
// if p3 = 103 then
22294: LD_VAR 0 3
22298: PUSH
22299: LD_INT 103
22301: EQUAL
22302: IFFALSE 22312
// sFog := true ;
22304: LD_ADDR_EXP 67
22308: PUSH
22309: LD_INT 1
22311: ST_TO_ADDR
// if p3 = 104 then
22312: LD_VAR 0 3
22316: PUSH
22317: LD_INT 104
22319: EQUAL
22320: IFFALSE 22330
// sReset := true ;
22322: LD_ADDR_EXP 68
22326: PUSH
22327: LD_INT 1
22329: ST_TO_ADDR
// if p3 = 105 then
22330: LD_VAR 0 3
22334: PUSH
22335: LD_INT 105
22337: EQUAL
22338: IFFALSE 22348
// sSun := true ;
22340: LD_ADDR_EXP 69
22344: PUSH
22345: LD_INT 1
22347: ST_TO_ADDR
// if p3 = 106 then
22348: LD_VAR 0 3
22352: PUSH
22353: LD_INT 106
22355: EQUAL
22356: IFFALSE 22366
// sTiger := true ;
22358: LD_ADDR_EXP 65
22362: PUSH
22363: LD_INT 1
22365: ST_TO_ADDR
// if p3 = 107 then
22366: LD_VAR 0 3
22370: PUSH
22371: LD_INT 107
22373: EQUAL
22374: IFFALSE 22384
// sBomb := true ;
22376: LD_ADDR_EXP 66
22380: PUSH
22381: LD_INT 1
22383: ST_TO_ADDR
// if p3 = 108 then
22384: LD_VAR 0 3
22388: PUSH
22389: LD_INT 108
22391: EQUAL
22392: IFFALSE 22402
// sWound := true ;
22394: LD_ADDR_EXP 74
22398: PUSH
22399: LD_INT 1
22401: ST_TO_ADDR
// if p3 = 109 then
22402: LD_VAR 0 3
22406: PUSH
22407: LD_INT 109
22409: EQUAL
22410: IFFALSE 22420
// sBetray := true ;
22412: LD_ADDR_EXP 78
22416: PUSH
22417: LD_INT 1
22419: ST_TO_ADDR
// if p3 = 110 then
22420: LD_VAR 0 3
22424: PUSH
22425: LD_INT 110
22427: EQUAL
22428: IFFALSE 22438
// sContamin := true ;
22430: LD_ADDR_EXP 79
22434: PUSH
22435: LD_INT 1
22437: ST_TO_ADDR
// if p3 = 111 then
22438: LD_VAR 0 3
22442: PUSH
22443: LD_INT 111
22445: EQUAL
22446: IFFALSE 22456
// sOil := true ;
22448: LD_ADDR_EXP 81
22452: PUSH
22453: LD_INT 1
22455: ST_TO_ADDR
// if p3 = 112 then
22456: LD_VAR 0 3
22460: PUSH
22461: LD_INT 112
22463: EQUAL
22464: IFFALSE 22474
// sStu := true ;
22466: LD_ADDR_EXP 85
22470: PUSH
22471: LD_INT 1
22473: ST_TO_ADDR
// if p3 = 113 then
22474: LD_VAR 0 3
22478: PUSH
22479: LD_INT 113
22481: EQUAL
22482: IFFALSE 22492
// sBazooka := true ;
22484: LD_ADDR_EXP 88
22488: PUSH
22489: LD_INT 1
22491: ST_TO_ADDR
// if p3 = 114 then
22492: LD_VAR 0 3
22496: PUSH
22497: LD_INT 114
22499: EQUAL
22500: IFFALSE 22510
// sMortar := true ;
22502: LD_ADDR_EXP 89
22506: PUSH
22507: LD_INT 1
22509: ST_TO_ADDR
// if p3 = 115 then
22510: LD_VAR 0 3
22514: PUSH
22515: LD_INT 115
22517: EQUAL
22518: IFFALSE 22528
// sRanger := true ;
22520: LD_ADDR_EXP 99
22524: PUSH
22525: LD_INT 1
22527: ST_TO_ADDR
// end ; end ;
22528: PPOPN 6
22530: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
22531: LD_EXP 46
22535: PUSH
22536: LD_EXP 51
22540: AND
22541: IFFALSE 22665
22543: GO 22545
22545: DISABLE
22546: LD_INT 0
22548: PPUSH
22549: PPUSH
// begin enable ;
22550: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
22551: LD_ADDR_VAR 0 2
22555: PUSH
22556: LD_INT 22
22558: PUSH
22559: LD_OWVAR 2
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: PUSH
22568: LD_INT 2
22570: PUSH
22571: LD_INT 34
22573: PUSH
22574: LD_INT 7
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PUSH
22581: LD_INT 34
22583: PUSH
22584: LD_INT 45
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: PUSH
22591: LD_INT 34
22593: PUSH
22594: LD_INT 28
22596: PUSH
22597: EMPTY
22598: LIST
22599: LIST
22600: PUSH
22601: LD_INT 34
22603: PUSH
22604: LD_INT 47
22606: PUSH
22607: EMPTY
22608: LIST
22609: LIST
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: LIST
22617: PUSH
22618: EMPTY
22619: LIST
22620: LIST
22621: PPUSH
22622: CALL_OW 69
22626: ST_TO_ADDR
// if not tmp then
22627: LD_VAR 0 2
22631: NOT
22632: IFFALSE 22636
// exit ;
22634: GO 22665
// for i in tmp do
22636: LD_ADDR_VAR 0 1
22640: PUSH
22641: LD_VAR 0 2
22645: PUSH
22646: FOR_IN
22647: IFFALSE 22663
// begin SetLives ( i , 0 ) ;
22649: LD_VAR 0 1
22653: PPUSH
22654: LD_INT 0
22656: PPUSH
22657: CALL_OW 234
// end ;
22661: GO 22646
22663: POP
22664: POP
// end ;
22665: PPOPN 2
22667: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
22668: LD_EXP 46
22672: PUSH
22673: LD_EXP 52
22677: AND
22678: IFFALSE 22762
22680: GO 22682
22682: DISABLE
22683: LD_INT 0
22685: PPUSH
22686: PPUSH
// begin enable ;
22687: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
22688: LD_ADDR_VAR 0 2
22692: PUSH
22693: LD_INT 22
22695: PUSH
22696: LD_OWVAR 2
22700: PUSH
22701: EMPTY
22702: LIST
22703: LIST
22704: PUSH
22705: LD_INT 32
22707: PUSH
22708: LD_INT 3
22710: PUSH
22711: EMPTY
22712: LIST
22713: LIST
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: PPUSH
22719: CALL_OW 69
22723: ST_TO_ADDR
// if not tmp then
22724: LD_VAR 0 2
22728: NOT
22729: IFFALSE 22733
// exit ;
22731: GO 22762
// for i in tmp do
22733: LD_ADDR_VAR 0 1
22737: PUSH
22738: LD_VAR 0 2
22742: PUSH
22743: FOR_IN
22744: IFFALSE 22760
// begin SetLives ( i , 0 ) ;
22746: LD_VAR 0 1
22750: PPUSH
22751: LD_INT 0
22753: PPUSH
22754: CALL_OW 234
// end ;
22758: GO 22743
22760: POP
22761: POP
// end ;
22762: PPOPN 2
22764: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
22765: LD_EXP 46
22769: PUSH
22770: LD_EXP 49
22774: AND
22775: IFFALSE 22868
22777: GO 22779
22779: DISABLE
22780: LD_INT 0
22782: PPUSH
// begin enable ;
22783: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
22784: LD_ADDR_VAR 0 1
22788: PUSH
22789: LD_INT 22
22791: PUSH
22792: LD_OWVAR 2
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: LD_INT 2
22803: PUSH
22804: LD_INT 25
22806: PUSH
22807: LD_INT 5
22809: PUSH
22810: EMPTY
22811: LIST
22812: LIST
22813: PUSH
22814: LD_INT 25
22816: PUSH
22817: LD_INT 9
22819: PUSH
22820: EMPTY
22821: LIST
22822: LIST
22823: PUSH
22824: LD_INT 25
22826: PUSH
22827: LD_INT 8
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PPUSH
22844: CALL_OW 69
22848: PUSH
22849: FOR_IN
22850: IFFALSE 22866
// begin SetClass ( i , 1 ) ;
22852: LD_VAR 0 1
22856: PPUSH
22857: LD_INT 1
22859: PPUSH
22860: CALL_OW 336
// end ;
22864: GO 22849
22866: POP
22867: POP
// end ;
22868: PPOPN 1
22870: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
22871: LD_EXP 46
22875: PUSH
22876: LD_EXP 50
22880: AND
22881: PUSH
22882: LD_OWVAR 65
22886: PUSH
22887: LD_INT 7
22889: LESS
22890: AND
22891: IFFALSE 22905
22893: GO 22895
22895: DISABLE
// begin enable ;
22896: ENABLE
// game_speed := 7 ;
22897: LD_ADDR_OWVAR 65
22901: PUSH
22902: LD_INT 7
22904: ST_TO_ADDR
// end ;
22905: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
22906: LD_EXP 46
22910: PUSH
22911: LD_EXP 53
22915: AND
22916: IFFALSE 23118
22918: GO 22920
22920: DISABLE
22921: LD_INT 0
22923: PPUSH
22924: PPUSH
22925: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
22926: LD_ADDR_VAR 0 3
22930: PUSH
22931: LD_INT 81
22933: PUSH
22934: LD_OWVAR 2
22938: PUSH
22939: EMPTY
22940: LIST
22941: LIST
22942: PUSH
22943: LD_INT 21
22945: PUSH
22946: LD_INT 1
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: PUSH
22953: EMPTY
22954: LIST
22955: LIST
22956: PPUSH
22957: CALL_OW 69
22961: ST_TO_ADDR
// if not tmp then
22962: LD_VAR 0 3
22966: NOT
22967: IFFALSE 22971
// exit ;
22969: GO 23118
// if tmp > 5 then
22971: LD_VAR 0 3
22975: PUSH
22976: LD_INT 5
22978: GREATER
22979: IFFALSE 22991
// k := 5 else
22981: LD_ADDR_VAR 0 2
22985: PUSH
22986: LD_INT 5
22988: ST_TO_ADDR
22989: GO 23001
// k := tmp ;
22991: LD_ADDR_VAR 0 2
22995: PUSH
22996: LD_VAR 0 3
23000: ST_TO_ADDR
// for i := 1 to k do
23001: LD_ADDR_VAR 0 1
23005: PUSH
23006: DOUBLE
23007: LD_INT 1
23009: DEC
23010: ST_TO_ADDR
23011: LD_VAR 0 2
23015: PUSH
23016: FOR_TO
23017: IFFALSE 23116
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
23019: LD_VAR 0 3
23023: PUSH
23024: LD_VAR 0 1
23028: ARRAY
23029: PPUSH
23030: LD_VAR 0 1
23034: PUSH
23035: LD_INT 4
23037: MOD
23038: PUSH
23039: LD_INT 1
23041: PLUS
23042: PPUSH
23043: CALL_OW 259
23047: PUSH
23048: LD_INT 10
23050: LESS
23051: IFFALSE 23114
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
23053: LD_VAR 0 3
23057: PUSH
23058: LD_VAR 0 1
23062: ARRAY
23063: PPUSH
23064: LD_VAR 0 1
23068: PUSH
23069: LD_INT 4
23071: MOD
23072: PUSH
23073: LD_INT 1
23075: PLUS
23076: PPUSH
23077: LD_VAR 0 3
23081: PUSH
23082: LD_VAR 0 1
23086: ARRAY
23087: PPUSH
23088: LD_VAR 0 1
23092: PUSH
23093: LD_INT 4
23095: MOD
23096: PUSH
23097: LD_INT 1
23099: PLUS
23100: PPUSH
23101: CALL_OW 259
23105: PUSH
23106: LD_INT 1
23108: PLUS
23109: PPUSH
23110: CALL_OW 237
23114: GO 23016
23116: POP
23117: POP
// end ;
23118: PPOPN 3
23120: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
23121: LD_EXP 46
23125: PUSH
23126: LD_EXP 54
23130: AND
23131: IFFALSE 23151
23133: GO 23135
23135: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
23136: LD_INT 4
23138: PPUSH
23139: LD_OWVAR 2
23143: PPUSH
23144: LD_INT 0
23146: PPUSH
23147: CALL_OW 324
23151: END
// every 0 0$1 trigger StreamModeActive and sShovel do
23152: LD_EXP 46
23156: PUSH
23157: LD_EXP 83
23161: AND
23162: IFFALSE 23182
23164: GO 23166
23166: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
23167: LD_INT 19
23169: PPUSH
23170: LD_OWVAR 2
23174: PPUSH
23175: LD_INT 0
23177: PPUSH
23178: CALL_OW 324
23182: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
23183: LD_EXP 46
23187: PUSH
23188: LD_EXP 55
23192: AND
23193: IFFALSE 23295
23195: GO 23197
23197: DISABLE
23198: LD_INT 0
23200: PPUSH
23201: PPUSH
// begin enable ;
23202: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
23203: LD_ADDR_VAR 0 2
23207: PUSH
23208: LD_INT 22
23210: PUSH
23211: LD_OWVAR 2
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: PUSH
23220: LD_INT 2
23222: PUSH
23223: LD_INT 34
23225: PUSH
23226: LD_INT 11
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: PUSH
23233: LD_INT 34
23235: PUSH
23236: LD_INT 30
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PPUSH
23252: CALL_OW 69
23256: ST_TO_ADDR
// if not tmp then
23257: LD_VAR 0 2
23261: NOT
23262: IFFALSE 23266
// exit ;
23264: GO 23295
// for i in tmp do
23266: LD_ADDR_VAR 0 1
23270: PUSH
23271: LD_VAR 0 2
23275: PUSH
23276: FOR_IN
23277: IFFALSE 23293
// begin SetLives ( i , 0 ) ;
23279: LD_VAR 0 1
23283: PPUSH
23284: LD_INT 0
23286: PPUSH
23287: CALL_OW 234
// end ;
23291: GO 23276
23293: POP
23294: POP
// end ;
23295: PPOPN 2
23297: END
// every 0 0$1 trigger StreamModeActive and sBunker do
23298: LD_EXP 46
23302: PUSH
23303: LD_EXP 56
23307: AND
23308: IFFALSE 23328
23310: GO 23312
23312: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
23313: LD_INT 32
23315: PPUSH
23316: LD_OWVAR 2
23320: PPUSH
23321: LD_INT 0
23323: PPUSH
23324: CALL_OW 324
23328: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
23329: LD_EXP 46
23333: PUSH
23334: LD_EXP 57
23338: AND
23339: IFFALSE 23520
23341: GO 23343
23343: DISABLE
23344: LD_INT 0
23346: PPUSH
23347: PPUSH
23348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
23349: LD_ADDR_VAR 0 2
23353: PUSH
23354: LD_INT 22
23356: PUSH
23357: LD_OWVAR 2
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: PUSH
23366: LD_INT 33
23368: PUSH
23369: LD_INT 3
23371: PUSH
23372: EMPTY
23373: LIST
23374: LIST
23375: PUSH
23376: EMPTY
23377: LIST
23378: LIST
23379: PPUSH
23380: CALL_OW 69
23384: ST_TO_ADDR
// if not tmp then
23385: LD_VAR 0 2
23389: NOT
23390: IFFALSE 23394
// exit ;
23392: GO 23520
// side := 0 ;
23394: LD_ADDR_VAR 0 3
23398: PUSH
23399: LD_INT 0
23401: ST_TO_ADDR
// for i := 1 to 8 do
23402: LD_ADDR_VAR 0 1
23406: PUSH
23407: DOUBLE
23408: LD_INT 1
23410: DEC
23411: ST_TO_ADDR
23412: LD_INT 8
23414: PUSH
23415: FOR_TO
23416: IFFALSE 23464
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
23418: LD_OWVAR 2
23422: PUSH
23423: LD_VAR 0 1
23427: NONEQUAL
23428: PUSH
23429: LD_OWVAR 2
23433: PPUSH
23434: LD_VAR 0 1
23438: PPUSH
23439: CALL_OW 81
23443: PUSH
23444: LD_INT 2
23446: EQUAL
23447: AND
23448: IFFALSE 23462
// begin side := i ;
23450: LD_ADDR_VAR 0 3
23454: PUSH
23455: LD_VAR 0 1
23459: ST_TO_ADDR
// break ;
23460: GO 23464
// end ;
23462: GO 23415
23464: POP
23465: POP
// if not side then
23466: LD_VAR 0 3
23470: NOT
23471: IFFALSE 23475
// exit ;
23473: GO 23520
// for i := 1 to tmp do
23475: LD_ADDR_VAR 0 1
23479: PUSH
23480: DOUBLE
23481: LD_INT 1
23483: DEC
23484: ST_TO_ADDR
23485: LD_VAR 0 2
23489: PUSH
23490: FOR_TO
23491: IFFALSE 23518
// if Prob ( 60 ) then
23493: LD_INT 60
23495: PPUSH
23496: CALL_OW 13
23500: IFFALSE 23516
// SetSide ( i , side ) ;
23502: LD_VAR 0 1
23506: PPUSH
23507: LD_VAR 0 3
23511: PPUSH
23512: CALL_OW 235
23516: GO 23490
23518: POP
23519: POP
// end ;
23520: PPOPN 3
23522: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
23523: LD_EXP 46
23527: PUSH
23528: LD_EXP 59
23532: AND
23533: IFFALSE 23652
23535: GO 23537
23537: DISABLE
23538: LD_INT 0
23540: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
23541: LD_ADDR_VAR 0 1
23545: PUSH
23546: LD_INT 22
23548: PUSH
23549: LD_OWVAR 2
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: PUSH
23558: LD_INT 21
23560: PUSH
23561: LD_INT 1
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: PUSH
23568: LD_INT 3
23570: PUSH
23571: LD_INT 23
23573: PUSH
23574: LD_INT 0
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: EMPTY
23586: LIST
23587: LIST
23588: LIST
23589: PPUSH
23590: CALL_OW 69
23594: PUSH
23595: FOR_IN
23596: IFFALSE 23650
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
23598: LD_VAR 0 1
23602: PPUSH
23603: CALL_OW 257
23607: PUSH
23608: LD_INT 1
23610: PUSH
23611: LD_INT 2
23613: PUSH
23614: LD_INT 3
23616: PUSH
23617: LD_INT 4
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: LIST
23624: LIST
23625: IN
23626: IFFALSE 23648
// SetClass ( un , rand ( 1 , 4 ) ) ;
23628: LD_VAR 0 1
23632: PPUSH
23633: LD_INT 1
23635: PPUSH
23636: LD_INT 4
23638: PPUSH
23639: CALL_OW 12
23643: PPUSH
23644: CALL_OW 336
23648: GO 23595
23650: POP
23651: POP
// end ;
23652: PPOPN 1
23654: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
23655: LD_EXP 46
23659: PUSH
23660: LD_EXP 58
23664: AND
23665: IFFALSE 23744
23667: GO 23669
23669: DISABLE
23670: LD_INT 0
23672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
23673: LD_ADDR_VAR 0 1
23677: PUSH
23678: LD_INT 22
23680: PUSH
23681: LD_OWVAR 2
23685: PUSH
23686: EMPTY
23687: LIST
23688: LIST
23689: PUSH
23690: LD_INT 21
23692: PUSH
23693: LD_INT 3
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PPUSH
23704: CALL_OW 69
23708: ST_TO_ADDR
// if not tmp then
23709: LD_VAR 0 1
23713: NOT
23714: IFFALSE 23718
// exit ;
23716: GO 23744
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
23718: LD_VAR 0 1
23722: PUSH
23723: LD_INT 1
23725: PPUSH
23726: LD_VAR 0 1
23730: PPUSH
23731: CALL_OW 12
23735: ARRAY
23736: PPUSH
23737: LD_INT 100
23739: PPUSH
23740: CALL_OW 234
// end ;
23744: PPOPN 1
23746: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
23747: LD_EXP 46
23751: PUSH
23752: LD_EXP 60
23756: AND
23757: IFFALSE 23855
23759: GO 23761
23761: DISABLE
23762: LD_INT 0
23764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23765: LD_ADDR_VAR 0 1
23769: PUSH
23770: LD_INT 22
23772: PUSH
23773: LD_OWVAR 2
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: PUSH
23782: LD_INT 21
23784: PUSH
23785: LD_INT 1
23787: PUSH
23788: EMPTY
23789: LIST
23790: LIST
23791: PUSH
23792: EMPTY
23793: LIST
23794: LIST
23795: PPUSH
23796: CALL_OW 69
23800: ST_TO_ADDR
// if not tmp then
23801: LD_VAR 0 1
23805: NOT
23806: IFFALSE 23810
// exit ;
23808: GO 23855
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
23810: LD_VAR 0 1
23814: PUSH
23815: LD_INT 1
23817: PPUSH
23818: LD_VAR 0 1
23822: PPUSH
23823: CALL_OW 12
23827: ARRAY
23828: PPUSH
23829: LD_INT 1
23831: PPUSH
23832: LD_INT 4
23834: PPUSH
23835: CALL_OW 12
23839: PPUSH
23840: LD_INT 3000
23842: PPUSH
23843: LD_INT 9000
23845: PPUSH
23846: CALL_OW 12
23850: PPUSH
23851: CALL_OW 492
// end ;
23855: PPOPN 1
23857: END
// every 0 0$1 trigger StreamModeActive and sDepot do
23858: LD_EXP 46
23862: PUSH
23863: LD_EXP 61
23867: AND
23868: IFFALSE 23888
23870: GO 23872
23872: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
23873: LD_INT 1
23875: PPUSH
23876: LD_OWVAR 2
23880: PPUSH
23881: LD_INT 0
23883: PPUSH
23884: CALL_OW 324
23888: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
23889: LD_EXP 46
23893: PUSH
23894: LD_EXP 62
23898: AND
23899: IFFALSE 23982
23901: GO 23903
23903: DISABLE
23904: LD_INT 0
23906: PPUSH
23907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
23908: LD_ADDR_VAR 0 2
23912: PUSH
23913: LD_INT 22
23915: PUSH
23916: LD_OWVAR 2
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: PUSH
23925: LD_INT 21
23927: PUSH
23928: LD_INT 3
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: PPUSH
23939: CALL_OW 69
23943: ST_TO_ADDR
// if not tmp then
23944: LD_VAR 0 2
23948: NOT
23949: IFFALSE 23953
// exit ;
23951: GO 23982
// for i in tmp do
23953: LD_ADDR_VAR 0 1
23957: PUSH
23958: LD_VAR 0 2
23962: PUSH
23963: FOR_IN
23964: IFFALSE 23980
// SetBLevel ( i , 10 ) ;
23966: LD_VAR 0 1
23970: PPUSH
23971: LD_INT 10
23973: PPUSH
23974: CALL_OW 241
23978: GO 23963
23980: POP
23981: POP
// end ;
23982: PPOPN 2
23984: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
23985: LD_EXP 46
23989: PUSH
23990: LD_EXP 63
23994: AND
23995: IFFALSE 24106
23997: GO 23999
23999: DISABLE
24000: LD_INT 0
24002: PPUSH
24003: PPUSH
24004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24005: LD_ADDR_VAR 0 3
24009: PUSH
24010: LD_INT 22
24012: PUSH
24013: LD_OWVAR 2
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 25
24024: PUSH
24025: LD_INT 1
24027: PUSH
24028: EMPTY
24029: LIST
24030: LIST
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: PPUSH
24036: CALL_OW 69
24040: ST_TO_ADDR
// if not tmp then
24041: LD_VAR 0 3
24045: NOT
24046: IFFALSE 24050
// exit ;
24048: GO 24106
// un := tmp [ rand ( 1 , tmp ) ] ;
24050: LD_ADDR_VAR 0 2
24054: PUSH
24055: LD_VAR 0 3
24059: PUSH
24060: LD_INT 1
24062: PPUSH
24063: LD_VAR 0 3
24067: PPUSH
24068: CALL_OW 12
24072: ARRAY
24073: ST_TO_ADDR
// if Crawls ( un ) then
24074: LD_VAR 0 2
24078: PPUSH
24079: CALL_OW 318
24083: IFFALSE 24094
// ComWalk ( un ) ;
24085: LD_VAR 0 2
24089: PPUSH
24090: CALL_OW 138
// SetClass ( un , class_sniper ) ;
24094: LD_VAR 0 2
24098: PPUSH
24099: LD_INT 5
24101: PPUSH
24102: CALL_OW 336
// end ;
24106: PPOPN 3
24108: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
24109: LD_EXP 46
24113: PUSH
24114: LD_EXP 64
24118: AND
24119: PUSH
24120: LD_OWVAR 67
24124: PUSH
24125: LD_INT 3
24127: LESS
24128: AND
24129: IFFALSE 24148
24131: GO 24133
24133: DISABLE
// Difficulty := Difficulty + 1 ;
24134: LD_ADDR_OWVAR 67
24138: PUSH
24139: LD_OWVAR 67
24143: PUSH
24144: LD_INT 1
24146: PLUS
24147: ST_TO_ADDR
24148: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
24149: LD_EXP 46
24153: PUSH
24154: LD_EXP 65
24158: AND
24159: IFFALSE 24262
24161: GO 24163
24163: DISABLE
24164: LD_INT 0
24166: PPUSH
// begin for i := 1 to 5 do
24167: LD_ADDR_VAR 0 1
24171: PUSH
24172: DOUBLE
24173: LD_INT 1
24175: DEC
24176: ST_TO_ADDR
24177: LD_INT 5
24179: PUSH
24180: FOR_TO
24181: IFFALSE 24260
// begin uc_nation := nation_nature ;
24183: LD_ADDR_OWVAR 21
24187: PUSH
24188: LD_INT 0
24190: ST_TO_ADDR
// uc_side := 0 ;
24191: LD_ADDR_OWVAR 20
24195: PUSH
24196: LD_INT 0
24198: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24199: LD_ADDR_OWVAR 29
24203: PUSH
24204: LD_INT 12
24206: PUSH
24207: LD_INT 12
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: ST_TO_ADDR
// hc_agressivity := 20 ;
24214: LD_ADDR_OWVAR 35
24218: PUSH
24219: LD_INT 20
24221: ST_TO_ADDR
// hc_class := class_tiger ;
24222: LD_ADDR_OWVAR 28
24226: PUSH
24227: LD_INT 14
24229: ST_TO_ADDR
// hc_gallery :=  ;
24230: LD_ADDR_OWVAR 33
24234: PUSH
24235: LD_STRING 
24237: ST_TO_ADDR
// hc_name :=  ;
24238: LD_ADDR_OWVAR 26
24242: PUSH
24243: LD_STRING 
24245: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
24246: CALL_OW 44
24250: PPUSH
24251: LD_INT 0
24253: PPUSH
24254: CALL_OW 51
// end ;
24258: GO 24180
24260: POP
24261: POP
// end ;
24262: PPOPN 1
24264: END
// every 0 0$1 trigger StreamModeActive and sBomb do
24265: LD_EXP 46
24269: PUSH
24270: LD_EXP 66
24274: AND
24275: IFFALSE 24284
24277: GO 24279
24279: DISABLE
// StreamSibBomb ;
24280: CALL 24285 0 0
24284: END
// export function StreamSibBomb ; var i , x , y ; begin
24285: LD_INT 0
24287: PPUSH
24288: PPUSH
24289: PPUSH
24290: PPUSH
// result := false ;
24291: LD_ADDR_VAR 0 1
24295: PUSH
24296: LD_INT 0
24298: ST_TO_ADDR
// for i := 1 to 16 do
24299: LD_ADDR_VAR 0 2
24303: PUSH
24304: DOUBLE
24305: LD_INT 1
24307: DEC
24308: ST_TO_ADDR
24309: LD_INT 16
24311: PUSH
24312: FOR_TO
24313: IFFALSE 24512
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24315: LD_ADDR_VAR 0 3
24319: PUSH
24320: LD_INT 10
24322: PUSH
24323: LD_INT 20
24325: PUSH
24326: LD_INT 30
24328: PUSH
24329: LD_INT 40
24331: PUSH
24332: LD_INT 50
24334: PUSH
24335: LD_INT 60
24337: PUSH
24338: LD_INT 70
24340: PUSH
24341: LD_INT 80
24343: PUSH
24344: LD_INT 90
24346: PUSH
24347: LD_INT 100
24349: PUSH
24350: LD_INT 110
24352: PUSH
24353: LD_INT 120
24355: PUSH
24356: LD_INT 130
24358: PUSH
24359: LD_INT 140
24361: PUSH
24362: LD_INT 150
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: LIST
24369: LIST
24370: LIST
24371: LIST
24372: LIST
24373: LIST
24374: LIST
24375: LIST
24376: LIST
24377: LIST
24378: LIST
24379: LIST
24380: LIST
24381: PUSH
24382: LD_INT 1
24384: PPUSH
24385: LD_INT 15
24387: PPUSH
24388: CALL_OW 12
24392: ARRAY
24393: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
24394: LD_ADDR_VAR 0 4
24398: PUSH
24399: LD_INT 10
24401: PUSH
24402: LD_INT 20
24404: PUSH
24405: LD_INT 30
24407: PUSH
24408: LD_INT 40
24410: PUSH
24411: LD_INT 50
24413: PUSH
24414: LD_INT 60
24416: PUSH
24417: LD_INT 70
24419: PUSH
24420: LD_INT 80
24422: PUSH
24423: LD_INT 90
24425: PUSH
24426: LD_INT 100
24428: PUSH
24429: LD_INT 110
24431: PUSH
24432: LD_INT 120
24434: PUSH
24435: LD_INT 130
24437: PUSH
24438: LD_INT 140
24440: PUSH
24441: LD_INT 150
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: LIST
24448: LIST
24449: LIST
24450: LIST
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: PUSH
24461: LD_INT 1
24463: PPUSH
24464: LD_INT 15
24466: PPUSH
24467: CALL_OW 12
24471: ARRAY
24472: ST_TO_ADDR
// if ValidHex ( x , y ) then
24473: LD_VAR 0 3
24477: PPUSH
24478: LD_VAR 0 4
24482: PPUSH
24483: CALL_OW 488
24487: IFFALSE 24510
// begin result := [ x , y ] ;
24489: LD_ADDR_VAR 0 1
24493: PUSH
24494: LD_VAR 0 3
24498: PUSH
24499: LD_VAR 0 4
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: ST_TO_ADDR
// break ;
24508: GO 24512
// end ; end ;
24510: GO 24312
24512: POP
24513: POP
// if result then
24514: LD_VAR 0 1
24518: IFFALSE 24578
// begin ToLua ( playSibBomb() ) ;
24520: LD_STRING playSibBomb()
24522: PPUSH
24523: CALL_OW 559
// wait ( 0 0$14 ) ;
24527: LD_INT 490
24529: PPUSH
24530: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
24534: LD_VAR 0 1
24538: PUSH
24539: LD_INT 1
24541: ARRAY
24542: PPUSH
24543: LD_VAR 0 1
24547: PUSH
24548: LD_INT 2
24550: ARRAY
24551: PPUSH
24552: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
24556: LD_VAR 0 1
24560: PUSH
24561: LD_INT 1
24563: ARRAY
24564: PPUSH
24565: LD_VAR 0 1
24569: PUSH
24570: LD_INT 2
24572: ARRAY
24573: PPUSH
24574: CALL_OW 429
// end ; end ;
24578: LD_VAR 0 1
24582: RET
// every 0 0$1 trigger StreamModeActive and sReset do
24583: LD_EXP 46
24587: PUSH
24588: LD_EXP 68
24592: AND
24593: IFFALSE 24605
24595: GO 24597
24597: DISABLE
// YouLost (  ) ;
24598: LD_STRING 
24600: PPUSH
24601: CALL_OW 104
24605: END
// every 0 0$1 trigger StreamModeActive and sFog do
24606: LD_EXP 46
24610: PUSH
24611: LD_EXP 67
24615: AND
24616: IFFALSE 24630
24618: GO 24620
24620: DISABLE
// FogOff ( your_side ) ;
24621: LD_OWVAR 2
24625: PPUSH
24626: CALL_OW 344
24630: END
// every 0 0$1 trigger StreamModeActive and sSun do
24631: LD_EXP 46
24635: PUSH
24636: LD_EXP 69
24640: AND
24641: IFFALSE 24669
24643: GO 24645
24645: DISABLE
// begin solar_recharge_percent := 0 ;
24646: LD_ADDR_OWVAR 79
24650: PUSH
24651: LD_INT 0
24653: ST_TO_ADDR
// wait ( 5 5$00 ) ;
24654: LD_INT 10500
24656: PPUSH
24657: CALL_OW 67
// solar_recharge_percent := 100 ;
24661: LD_ADDR_OWVAR 79
24665: PUSH
24666: LD_INT 100
24668: ST_TO_ADDR
// end ;
24669: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
24670: LD_EXP 46
24674: PUSH
24675: LD_EXP 70
24679: AND
24680: IFFALSE 24919
24682: GO 24684
24684: DISABLE
24685: LD_INT 0
24687: PPUSH
24688: PPUSH
24689: PPUSH
// begin tmp := [ ] ;
24690: LD_ADDR_VAR 0 3
24694: PUSH
24695: EMPTY
24696: ST_TO_ADDR
// for i := 1 to 6 do
24697: LD_ADDR_VAR 0 1
24701: PUSH
24702: DOUBLE
24703: LD_INT 1
24705: DEC
24706: ST_TO_ADDR
24707: LD_INT 6
24709: PUSH
24710: FOR_TO
24711: IFFALSE 24816
// begin uc_nation := nation_nature ;
24713: LD_ADDR_OWVAR 21
24717: PUSH
24718: LD_INT 0
24720: ST_TO_ADDR
// uc_side := 0 ;
24721: LD_ADDR_OWVAR 20
24725: PUSH
24726: LD_INT 0
24728: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
24729: LD_ADDR_OWVAR 29
24733: PUSH
24734: LD_INT 12
24736: PUSH
24737: LD_INT 12
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: ST_TO_ADDR
// hc_agressivity := 20 ;
24744: LD_ADDR_OWVAR 35
24748: PUSH
24749: LD_INT 20
24751: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
24752: LD_ADDR_OWVAR 28
24756: PUSH
24757: LD_INT 17
24759: ST_TO_ADDR
// hc_gallery :=  ;
24760: LD_ADDR_OWVAR 33
24764: PUSH
24765: LD_STRING 
24767: ST_TO_ADDR
// hc_name :=  ;
24768: LD_ADDR_OWVAR 26
24772: PUSH
24773: LD_STRING 
24775: ST_TO_ADDR
// un := CreateHuman ;
24776: LD_ADDR_VAR 0 2
24780: PUSH
24781: CALL_OW 44
24785: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
24786: LD_VAR 0 2
24790: PPUSH
24791: LD_INT 1
24793: PPUSH
24794: CALL_OW 51
// tmp := tmp ^ un ;
24798: LD_ADDR_VAR 0 3
24802: PUSH
24803: LD_VAR 0 3
24807: PUSH
24808: LD_VAR 0 2
24812: ADD
24813: ST_TO_ADDR
// end ;
24814: GO 24710
24816: POP
24817: POP
// repeat wait ( 0 0$1 ) ;
24818: LD_INT 35
24820: PPUSH
24821: CALL_OW 67
// for un in tmp do
24825: LD_ADDR_VAR 0 2
24829: PUSH
24830: LD_VAR 0 3
24834: PUSH
24835: FOR_IN
24836: IFFALSE 24910
// begin if IsDead ( un ) then
24838: LD_VAR 0 2
24842: PPUSH
24843: CALL_OW 301
24847: IFFALSE 24867
// begin tmp := tmp diff un ;
24849: LD_ADDR_VAR 0 3
24853: PUSH
24854: LD_VAR 0 3
24858: PUSH
24859: LD_VAR 0 2
24863: DIFF
24864: ST_TO_ADDR
// continue ;
24865: GO 24835
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
24867: LD_VAR 0 2
24871: PPUSH
24872: LD_INT 3
24874: PUSH
24875: LD_INT 22
24877: PUSH
24878: LD_INT 0
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: EMPTY
24886: LIST
24887: LIST
24888: PPUSH
24889: CALL_OW 69
24893: PPUSH
24894: LD_VAR 0 2
24898: PPUSH
24899: CALL_OW 74
24903: PPUSH
24904: CALL_OW 115
// end ;
24908: GO 24835
24910: POP
24911: POP
// until not tmp ;
24912: LD_VAR 0 3
24916: NOT
24917: IFFALSE 24818
// end ;
24919: PPOPN 3
24921: END
// every 0 0$1 trigger StreamModeActive and sTroll do
24922: LD_EXP 46
24926: PUSH
24927: LD_EXP 71
24931: AND
24932: IFFALSE 24986
24934: GO 24936
24936: DISABLE
// begin ToLua ( displayTroll(); ) ;
24937: LD_STRING displayTroll();
24939: PPUSH
24940: CALL_OW 559
// wait ( 3 3$00 ) ;
24944: LD_INT 6300
24946: PPUSH
24947: CALL_OW 67
// ToLua ( hideTroll(); ) ;
24951: LD_STRING hideTroll();
24953: PPUSH
24954: CALL_OW 559
// wait ( 1 1$00 ) ;
24958: LD_INT 2100
24960: PPUSH
24961: CALL_OW 67
// ToLua ( displayTroll(); ) ;
24965: LD_STRING displayTroll();
24967: PPUSH
24968: CALL_OW 559
// wait ( 1 1$00 ) ;
24972: LD_INT 2100
24974: PPUSH
24975: CALL_OW 67
// ToLua ( hideTroll(); ) ;
24979: LD_STRING hideTroll();
24981: PPUSH
24982: CALL_OW 559
// end ;
24986: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
24987: LD_EXP 46
24991: PUSH
24992: LD_EXP 72
24996: AND
24997: IFFALSE 25060
24999: GO 25001
25001: DISABLE
25002: LD_INT 0
25004: PPUSH
// begin p := 0 ;
25005: LD_ADDR_VAR 0 1
25009: PUSH
25010: LD_INT 0
25012: ST_TO_ADDR
// repeat game_speed := 1 ;
25013: LD_ADDR_OWVAR 65
25017: PUSH
25018: LD_INT 1
25020: ST_TO_ADDR
// wait ( 0 0$1 ) ;
25021: LD_INT 35
25023: PPUSH
25024: CALL_OW 67
// p := p + 1 ;
25028: LD_ADDR_VAR 0 1
25032: PUSH
25033: LD_VAR 0 1
25037: PUSH
25038: LD_INT 1
25040: PLUS
25041: ST_TO_ADDR
// until p >= 60 ;
25042: LD_VAR 0 1
25046: PUSH
25047: LD_INT 60
25049: GREATEREQUAL
25050: IFFALSE 25013
// game_speed := 4 ;
25052: LD_ADDR_OWVAR 65
25056: PUSH
25057: LD_INT 4
25059: ST_TO_ADDR
// end ;
25060: PPOPN 1
25062: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
25063: LD_EXP 46
25067: PUSH
25068: LD_EXP 73
25072: AND
25073: IFFALSE 25219
25075: GO 25077
25077: DISABLE
25078: LD_INT 0
25080: PPUSH
25081: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25082: LD_ADDR_VAR 0 1
25086: PUSH
25087: LD_INT 22
25089: PUSH
25090: LD_OWVAR 2
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: PUSH
25099: LD_INT 2
25101: PUSH
25102: LD_INT 30
25104: PUSH
25105: LD_INT 0
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 30
25114: PUSH
25115: LD_INT 1
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: LIST
25126: PUSH
25127: EMPTY
25128: LIST
25129: LIST
25130: PPUSH
25131: CALL_OW 69
25135: ST_TO_ADDR
// if not depot then
25136: LD_VAR 0 1
25140: NOT
25141: IFFALSE 25145
// exit ;
25143: GO 25219
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
25145: LD_ADDR_VAR 0 2
25149: PUSH
25150: LD_VAR 0 1
25154: PUSH
25155: LD_INT 1
25157: PPUSH
25158: LD_VAR 0 1
25162: PPUSH
25163: CALL_OW 12
25167: ARRAY
25168: PPUSH
25169: CALL_OW 274
25173: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
25174: LD_VAR 0 2
25178: PPUSH
25179: LD_INT 1
25181: PPUSH
25182: LD_INT 0
25184: PPUSH
25185: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
25189: LD_VAR 0 2
25193: PPUSH
25194: LD_INT 2
25196: PPUSH
25197: LD_INT 0
25199: PPUSH
25200: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
25204: LD_VAR 0 2
25208: PPUSH
25209: LD_INT 3
25211: PPUSH
25212: LD_INT 0
25214: PPUSH
25215: CALL_OW 277
// end ;
25219: PPOPN 2
25221: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
25222: LD_EXP 46
25226: PUSH
25227: LD_EXP 74
25231: AND
25232: IFFALSE 25329
25234: GO 25236
25236: DISABLE
25237: LD_INT 0
25239: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25240: LD_ADDR_VAR 0 1
25244: PUSH
25245: LD_INT 22
25247: PUSH
25248: LD_OWVAR 2
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 21
25259: PUSH
25260: LD_INT 1
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: LD_INT 3
25269: PUSH
25270: LD_INT 23
25272: PUSH
25273: LD_INT 0
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: LIST
25288: PPUSH
25289: CALL_OW 69
25293: ST_TO_ADDR
// if not tmp then
25294: LD_VAR 0 1
25298: NOT
25299: IFFALSE 25303
// exit ;
25301: GO 25329
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
25303: LD_VAR 0 1
25307: PUSH
25308: LD_INT 1
25310: PPUSH
25311: LD_VAR 0 1
25315: PPUSH
25316: CALL_OW 12
25320: ARRAY
25321: PPUSH
25322: LD_INT 200
25324: PPUSH
25325: CALL_OW 234
// end ;
25329: PPOPN 1
25331: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
25332: LD_EXP 46
25336: PUSH
25337: LD_EXP 75
25341: AND
25342: IFFALSE 25421
25344: GO 25346
25346: DISABLE
25347: LD_INT 0
25349: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
25350: LD_ADDR_VAR 0 1
25354: PUSH
25355: LD_INT 22
25357: PUSH
25358: LD_OWVAR 2
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 21
25369: PUSH
25370: LD_INT 2
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: PPUSH
25381: CALL_OW 69
25385: ST_TO_ADDR
// if not tmp then
25386: LD_VAR 0 1
25390: NOT
25391: IFFALSE 25395
// exit ;
25393: GO 25421
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
25395: LD_VAR 0 1
25399: PUSH
25400: LD_INT 1
25402: PPUSH
25403: LD_VAR 0 1
25407: PPUSH
25408: CALL_OW 12
25412: ARRAY
25413: PPUSH
25414: LD_INT 60
25416: PPUSH
25417: CALL_OW 234
// end ;
25421: PPOPN 1
25423: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
25424: LD_EXP 46
25428: PUSH
25429: LD_EXP 76
25433: AND
25434: IFFALSE 25533
25436: GO 25438
25438: DISABLE
25439: LD_INT 0
25441: PPUSH
25442: PPUSH
// begin enable ;
25443: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
25444: LD_ADDR_VAR 0 1
25448: PUSH
25449: LD_INT 22
25451: PUSH
25452: LD_OWVAR 2
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 61
25463: PUSH
25464: EMPTY
25465: LIST
25466: PUSH
25467: LD_INT 33
25469: PUSH
25470: LD_INT 2
25472: PUSH
25473: EMPTY
25474: LIST
25475: LIST
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: LIST
25481: PPUSH
25482: CALL_OW 69
25486: ST_TO_ADDR
// if not tmp then
25487: LD_VAR 0 1
25491: NOT
25492: IFFALSE 25496
// exit ;
25494: GO 25533
// for i in tmp do
25496: LD_ADDR_VAR 0 2
25500: PUSH
25501: LD_VAR 0 1
25505: PUSH
25506: FOR_IN
25507: IFFALSE 25531
// if IsControledBy ( i ) then
25509: LD_VAR 0 2
25513: PPUSH
25514: CALL_OW 312
25518: IFFALSE 25529
// ComUnlink ( i ) ;
25520: LD_VAR 0 2
25524: PPUSH
25525: CALL_OW 136
25529: GO 25506
25531: POP
25532: POP
// end ;
25533: PPOPN 2
25535: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
25536: LD_EXP 46
25540: PUSH
25541: LD_EXP 77
25545: AND
25546: IFFALSE 25686
25548: GO 25550
25550: DISABLE
25551: LD_INT 0
25553: PPUSH
25554: PPUSH
// begin ToLua ( displayPowell(); ) ;
25555: LD_STRING displayPowell();
25557: PPUSH
25558: CALL_OW 559
// uc_side := 0 ;
25562: LD_ADDR_OWVAR 20
25566: PUSH
25567: LD_INT 0
25569: ST_TO_ADDR
// uc_nation := 2 ;
25570: LD_ADDR_OWVAR 21
25574: PUSH
25575: LD_INT 2
25577: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
25578: LD_ADDR_OWVAR 37
25582: PUSH
25583: LD_INT 14
25585: ST_TO_ADDR
// vc_engine := engine_siberite ;
25586: LD_ADDR_OWVAR 39
25590: PUSH
25591: LD_INT 3
25593: ST_TO_ADDR
// vc_control := control_apeman ;
25594: LD_ADDR_OWVAR 38
25598: PUSH
25599: LD_INT 5
25601: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
25602: LD_ADDR_OWVAR 40
25606: PUSH
25607: LD_INT 29
25609: ST_TO_ADDR
// un := CreateVehicle ;
25610: LD_ADDR_VAR 0 2
25614: PUSH
25615: CALL_OW 45
25619: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
25620: LD_VAR 0 2
25624: PPUSH
25625: LD_INT 1
25627: PPUSH
25628: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
25632: LD_INT 35
25634: PPUSH
25635: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
25639: LD_VAR 0 2
25643: PPUSH
25644: LD_INT 22
25646: PUSH
25647: LD_OWVAR 2
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PPUSH
25656: CALL_OW 69
25660: PPUSH
25661: LD_VAR 0 2
25665: PPUSH
25666: CALL_OW 74
25670: PPUSH
25671: CALL_OW 115
// until IsDead ( un ) ;
25675: LD_VAR 0 2
25679: PPUSH
25680: CALL_OW 301
25684: IFFALSE 25632
// end ;
25686: PPOPN 2
25688: END
// every 0 0$1 trigger StreamModeActive and sStu do
25689: LD_EXP 46
25693: PUSH
25694: LD_EXP 85
25698: AND
25699: IFFALSE 25715
25701: GO 25703
25703: DISABLE
// begin ToLua ( displayStucuk(); ) ;
25704: LD_STRING displayStucuk();
25706: PPUSH
25707: CALL_OW 559
// ResetFog ;
25711: CALL_OW 335
// end ;
25715: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
25716: LD_EXP 46
25720: PUSH
25721: LD_EXP 78
25725: AND
25726: IFFALSE 25867
25728: GO 25730
25730: DISABLE
25731: LD_INT 0
25733: PPUSH
25734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25735: LD_ADDR_VAR 0 2
25739: PUSH
25740: LD_INT 22
25742: PUSH
25743: LD_OWVAR 2
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 21
25754: PUSH
25755: LD_INT 1
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PPUSH
25766: CALL_OW 69
25770: ST_TO_ADDR
// if not tmp then
25771: LD_VAR 0 2
25775: NOT
25776: IFFALSE 25780
// exit ;
25778: GO 25867
// un := tmp [ rand ( 1 , tmp ) ] ;
25780: LD_ADDR_VAR 0 1
25784: PUSH
25785: LD_VAR 0 2
25789: PUSH
25790: LD_INT 1
25792: PPUSH
25793: LD_VAR 0 2
25797: PPUSH
25798: CALL_OW 12
25802: ARRAY
25803: ST_TO_ADDR
// SetSide ( un , 0 ) ;
25804: LD_VAR 0 1
25808: PPUSH
25809: LD_INT 0
25811: PPUSH
25812: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
25816: LD_VAR 0 1
25820: PPUSH
25821: LD_OWVAR 3
25825: PUSH
25826: LD_VAR 0 1
25830: DIFF
25831: PPUSH
25832: LD_VAR 0 1
25836: PPUSH
25837: CALL_OW 74
25841: PPUSH
25842: CALL_OW 115
// wait ( 0 0$20 ) ;
25846: LD_INT 700
25848: PPUSH
25849: CALL_OW 67
// SetSide ( un , your_side ) ;
25853: LD_VAR 0 1
25857: PPUSH
25858: LD_OWVAR 2
25862: PPUSH
25863: CALL_OW 235
// end ;
25867: PPOPN 2
25869: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
25870: LD_EXP 46
25874: PUSH
25875: LD_EXP 79
25879: AND
25880: IFFALSE 25986
25882: GO 25884
25884: DISABLE
25885: LD_INT 0
25887: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25888: LD_ADDR_VAR 0 1
25892: PUSH
25893: LD_INT 22
25895: PUSH
25896: LD_OWVAR 2
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 2
25907: PUSH
25908: LD_INT 30
25910: PUSH
25911: LD_INT 0
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 30
25920: PUSH
25921: LD_INT 1
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: LIST
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: PPUSH
25937: CALL_OW 69
25941: ST_TO_ADDR
// if not depot then
25942: LD_VAR 0 1
25946: NOT
25947: IFFALSE 25951
// exit ;
25949: GO 25986
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
25951: LD_VAR 0 1
25955: PUSH
25956: LD_INT 1
25958: ARRAY
25959: PPUSH
25960: CALL_OW 250
25964: PPUSH
25965: LD_VAR 0 1
25969: PUSH
25970: LD_INT 1
25972: ARRAY
25973: PPUSH
25974: CALL_OW 251
25978: PPUSH
25979: LD_INT 70
25981: PPUSH
25982: CALL_OW 495
// end ;
25986: PPOPN 1
25988: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
25989: LD_EXP 46
25993: PUSH
25994: LD_EXP 80
25998: AND
25999: IFFALSE 26210
26001: GO 26003
26003: DISABLE
26004: LD_INT 0
26006: PPUSH
26007: PPUSH
26008: PPUSH
26009: PPUSH
26010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26011: LD_ADDR_VAR 0 5
26015: PUSH
26016: LD_INT 22
26018: PUSH
26019: LD_OWVAR 2
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: PUSH
26028: LD_INT 21
26030: PUSH
26031: LD_INT 1
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PPUSH
26042: CALL_OW 69
26046: ST_TO_ADDR
// if not tmp then
26047: LD_VAR 0 5
26051: NOT
26052: IFFALSE 26056
// exit ;
26054: GO 26210
// for i in tmp do
26056: LD_ADDR_VAR 0 1
26060: PUSH
26061: LD_VAR 0 5
26065: PUSH
26066: FOR_IN
26067: IFFALSE 26208
// begin d := rand ( 0 , 5 ) ;
26069: LD_ADDR_VAR 0 4
26073: PUSH
26074: LD_INT 0
26076: PPUSH
26077: LD_INT 5
26079: PPUSH
26080: CALL_OW 12
26084: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
26085: LD_ADDR_VAR 0 2
26089: PUSH
26090: LD_VAR 0 1
26094: PPUSH
26095: CALL_OW 250
26099: PPUSH
26100: LD_VAR 0 4
26104: PPUSH
26105: LD_INT 3
26107: PPUSH
26108: LD_INT 12
26110: PPUSH
26111: CALL_OW 12
26115: PPUSH
26116: CALL_OW 272
26120: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
26121: LD_ADDR_VAR 0 3
26125: PUSH
26126: LD_VAR 0 1
26130: PPUSH
26131: CALL_OW 251
26135: PPUSH
26136: LD_VAR 0 4
26140: PPUSH
26141: LD_INT 3
26143: PPUSH
26144: LD_INT 12
26146: PPUSH
26147: CALL_OW 12
26151: PPUSH
26152: CALL_OW 273
26156: ST_TO_ADDR
// if ValidHex ( x , y ) then
26157: LD_VAR 0 2
26161: PPUSH
26162: LD_VAR 0 3
26166: PPUSH
26167: CALL_OW 488
26171: IFFALSE 26206
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
26173: LD_VAR 0 1
26177: PPUSH
26178: LD_VAR 0 2
26182: PPUSH
26183: LD_VAR 0 3
26187: PPUSH
26188: LD_INT 3
26190: PPUSH
26191: LD_INT 6
26193: PPUSH
26194: CALL_OW 12
26198: PPUSH
26199: LD_INT 1
26201: PPUSH
26202: CALL_OW 483
// end ;
26206: GO 26066
26208: POP
26209: POP
// end ;
26210: PPOPN 5
26212: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
26213: LD_EXP 46
26217: PUSH
26218: LD_EXP 81
26222: AND
26223: IFFALSE 26317
26225: GO 26227
26227: DISABLE
26228: LD_INT 0
26230: PPUSH
26231: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
26232: LD_ADDR_VAR 0 2
26236: PUSH
26237: LD_INT 22
26239: PUSH
26240: LD_OWVAR 2
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 32
26251: PUSH
26252: LD_INT 1
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 21
26261: PUSH
26262: LD_INT 2
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: LIST
26273: PPUSH
26274: CALL_OW 69
26278: ST_TO_ADDR
// if not tmp then
26279: LD_VAR 0 2
26283: NOT
26284: IFFALSE 26288
// exit ;
26286: GO 26317
// for i in tmp do
26288: LD_ADDR_VAR 0 1
26292: PUSH
26293: LD_VAR 0 2
26297: PUSH
26298: FOR_IN
26299: IFFALSE 26315
// SetFuel ( i , 0 ) ;
26301: LD_VAR 0 1
26305: PPUSH
26306: LD_INT 0
26308: PPUSH
26309: CALL_OW 240
26313: GO 26298
26315: POP
26316: POP
// end ;
26317: PPOPN 2
26319: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
26320: LD_EXP 46
26324: PUSH
26325: LD_EXP 82
26329: AND
26330: IFFALSE 26396
26332: GO 26334
26334: DISABLE
26335: LD_INT 0
26337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
26338: LD_ADDR_VAR 0 1
26342: PUSH
26343: LD_INT 22
26345: PUSH
26346: LD_OWVAR 2
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 30
26357: PUSH
26358: LD_INT 29
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PPUSH
26369: CALL_OW 69
26373: ST_TO_ADDR
// if not tmp then
26374: LD_VAR 0 1
26378: NOT
26379: IFFALSE 26383
// exit ;
26381: GO 26396
// DestroyUnit ( tmp [ 1 ] ) ;
26383: LD_VAR 0 1
26387: PUSH
26388: LD_INT 1
26390: ARRAY
26391: PPUSH
26392: CALL_OW 65
// end ;
26396: PPOPN 1
26398: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
26399: LD_EXP 46
26403: PUSH
26404: LD_EXP 84
26408: AND
26409: IFFALSE 26538
26411: GO 26413
26413: DISABLE
26414: LD_INT 0
26416: PPUSH
// begin uc_side := 0 ;
26417: LD_ADDR_OWVAR 20
26421: PUSH
26422: LD_INT 0
26424: ST_TO_ADDR
// uc_nation := nation_arabian ;
26425: LD_ADDR_OWVAR 21
26429: PUSH
26430: LD_INT 2
26432: ST_TO_ADDR
// hc_gallery :=  ;
26433: LD_ADDR_OWVAR 33
26437: PUSH
26438: LD_STRING 
26440: ST_TO_ADDR
// hc_name :=  ;
26441: LD_ADDR_OWVAR 26
26445: PUSH
26446: LD_STRING 
26448: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
26449: LD_INT 1
26451: PPUSH
26452: LD_INT 11
26454: PPUSH
26455: LD_INT 10
26457: PPUSH
26458: CALL_OW 380
// un := CreateHuman ;
26462: LD_ADDR_VAR 0 1
26466: PUSH
26467: CALL_OW 44
26471: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26472: LD_VAR 0 1
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26484: LD_INT 35
26486: PPUSH
26487: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26491: LD_VAR 0 1
26495: PPUSH
26496: LD_INT 22
26498: PUSH
26499: LD_OWVAR 2
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PPUSH
26508: CALL_OW 69
26512: PPUSH
26513: LD_VAR 0 1
26517: PPUSH
26518: CALL_OW 74
26522: PPUSH
26523: CALL_OW 115
// until IsDead ( un ) ;
26527: LD_VAR 0 1
26531: PPUSH
26532: CALL_OW 301
26536: IFFALSE 26484
// end ;
26538: PPOPN 1
26540: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
26541: LD_EXP 46
26545: PUSH
26546: LD_EXP 86
26550: AND
26551: IFFALSE 26563
26553: GO 26555
26555: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
26556: LD_STRING earthquake(getX(game), 0, 32)
26558: PPUSH
26559: CALL_OW 559
26563: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
26564: LD_EXP 46
26568: PUSH
26569: LD_EXP 87
26573: AND
26574: IFFALSE 26665
26576: GO 26578
26578: DISABLE
26579: LD_INT 0
26581: PPUSH
// begin enable ;
26582: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
26583: LD_ADDR_VAR 0 1
26587: PUSH
26588: LD_INT 22
26590: PUSH
26591: LD_OWVAR 2
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PUSH
26600: LD_INT 21
26602: PUSH
26603: LD_INT 2
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: PUSH
26610: LD_INT 33
26612: PUSH
26613: LD_INT 3
26615: PUSH
26616: EMPTY
26617: LIST
26618: LIST
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: LIST
26624: PPUSH
26625: CALL_OW 69
26629: ST_TO_ADDR
// if not tmp then
26630: LD_VAR 0 1
26634: NOT
26635: IFFALSE 26639
// exit ;
26637: GO 26665
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
26639: LD_VAR 0 1
26643: PUSH
26644: LD_INT 1
26646: PPUSH
26647: LD_VAR 0 1
26651: PPUSH
26652: CALL_OW 12
26656: ARRAY
26657: PPUSH
26658: LD_INT 1
26660: PPUSH
26661: CALL_OW 234
// end ;
26665: PPOPN 1
26667: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
26668: LD_EXP 46
26672: PUSH
26673: LD_EXP 88
26677: AND
26678: IFFALSE 26819
26680: GO 26682
26682: DISABLE
26683: LD_INT 0
26685: PPUSH
26686: PPUSH
26687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26688: LD_ADDR_VAR 0 3
26692: PUSH
26693: LD_INT 22
26695: PUSH
26696: LD_OWVAR 2
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PUSH
26705: LD_INT 25
26707: PUSH
26708: LD_INT 1
26710: PUSH
26711: EMPTY
26712: LIST
26713: LIST
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PPUSH
26719: CALL_OW 69
26723: ST_TO_ADDR
// if not tmp then
26724: LD_VAR 0 3
26728: NOT
26729: IFFALSE 26733
// exit ;
26731: GO 26819
// un := tmp [ rand ( 1 , tmp ) ] ;
26733: LD_ADDR_VAR 0 2
26737: PUSH
26738: LD_VAR 0 3
26742: PUSH
26743: LD_INT 1
26745: PPUSH
26746: LD_VAR 0 3
26750: PPUSH
26751: CALL_OW 12
26755: ARRAY
26756: ST_TO_ADDR
// if Crawls ( un ) then
26757: LD_VAR 0 2
26761: PPUSH
26762: CALL_OW 318
26766: IFFALSE 26777
// ComWalk ( un ) ;
26768: LD_VAR 0 2
26772: PPUSH
26773: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
26777: LD_VAR 0 2
26781: PPUSH
26782: LD_INT 9
26784: PPUSH
26785: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
26789: LD_INT 28
26791: PPUSH
26792: LD_OWVAR 2
26796: PPUSH
26797: LD_INT 2
26799: PPUSH
26800: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
26804: LD_INT 29
26806: PPUSH
26807: LD_OWVAR 2
26811: PPUSH
26812: LD_INT 2
26814: PPUSH
26815: CALL_OW 322
// end ;
26819: PPOPN 3
26821: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
26822: LD_EXP 46
26826: PUSH
26827: LD_EXP 89
26831: AND
26832: IFFALSE 26943
26834: GO 26836
26836: DISABLE
26837: LD_INT 0
26839: PPUSH
26840: PPUSH
26841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26842: LD_ADDR_VAR 0 3
26846: PUSH
26847: LD_INT 22
26849: PUSH
26850: LD_OWVAR 2
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PUSH
26859: LD_INT 25
26861: PUSH
26862: LD_INT 1
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: EMPTY
26870: LIST
26871: LIST
26872: PPUSH
26873: CALL_OW 69
26877: ST_TO_ADDR
// if not tmp then
26878: LD_VAR 0 3
26882: NOT
26883: IFFALSE 26887
// exit ;
26885: GO 26943
// un := tmp [ rand ( 1 , tmp ) ] ;
26887: LD_ADDR_VAR 0 2
26891: PUSH
26892: LD_VAR 0 3
26896: PUSH
26897: LD_INT 1
26899: PPUSH
26900: LD_VAR 0 3
26904: PPUSH
26905: CALL_OW 12
26909: ARRAY
26910: ST_TO_ADDR
// if Crawls ( un ) then
26911: LD_VAR 0 2
26915: PPUSH
26916: CALL_OW 318
26920: IFFALSE 26931
// ComWalk ( un ) ;
26922: LD_VAR 0 2
26926: PPUSH
26927: CALL_OW 138
// SetClass ( un , class_mortar ) ;
26931: LD_VAR 0 2
26935: PPUSH
26936: LD_INT 8
26938: PPUSH
26939: CALL_OW 336
// end ;
26943: PPOPN 3
26945: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
26946: LD_EXP 46
26950: PUSH
26951: LD_EXP 90
26955: AND
26956: IFFALSE 27100
26958: GO 26960
26960: DISABLE
26961: LD_INT 0
26963: PPUSH
26964: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
26965: LD_ADDR_VAR 0 2
26969: PUSH
26970: LD_INT 22
26972: PUSH
26973: LD_OWVAR 2
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 21
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 2
26994: PUSH
26995: LD_INT 34
26997: PUSH
26998: LD_INT 12
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: PUSH
27005: LD_INT 34
27007: PUSH
27008: LD_INT 51
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 34
27017: PUSH
27018: LD_INT 32
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: LIST
27035: PPUSH
27036: CALL_OW 69
27040: ST_TO_ADDR
// if not tmp then
27041: LD_VAR 0 2
27045: NOT
27046: IFFALSE 27050
// exit ;
27048: GO 27100
// for i in tmp do
27050: LD_ADDR_VAR 0 1
27054: PUSH
27055: LD_VAR 0 2
27059: PUSH
27060: FOR_IN
27061: IFFALSE 27098
// if GetCargo ( i , mat_artifact ) = 0 then
27063: LD_VAR 0 1
27067: PPUSH
27068: LD_INT 4
27070: PPUSH
27071: CALL_OW 289
27075: PUSH
27076: LD_INT 0
27078: EQUAL
27079: IFFALSE 27096
// SetCargo ( i , mat_siberit , 100 ) ;
27081: LD_VAR 0 1
27085: PPUSH
27086: LD_INT 3
27088: PPUSH
27089: LD_INT 100
27091: PPUSH
27092: CALL_OW 290
27096: GO 27060
27098: POP
27099: POP
// end ;
27100: PPOPN 2
27102: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
27103: LD_EXP 46
27107: PUSH
27108: LD_EXP 91
27112: AND
27113: IFFALSE 27266
27115: GO 27117
27117: DISABLE
27118: LD_INT 0
27120: PPUSH
27121: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
27122: LD_ADDR_VAR 0 2
27126: PUSH
27127: LD_INT 22
27129: PUSH
27130: LD_OWVAR 2
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PPUSH
27139: CALL_OW 69
27143: ST_TO_ADDR
// if not tmp then
27144: LD_VAR 0 2
27148: NOT
27149: IFFALSE 27153
// exit ;
27151: GO 27266
// for i := 1 to 2 do
27153: LD_ADDR_VAR 0 1
27157: PUSH
27158: DOUBLE
27159: LD_INT 1
27161: DEC
27162: ST_TO_ADDR
27163: LD_INT 2
27165: PUSH
27166: FOR_TO
27167: IFFALSE 27264
// begin uc_side := your_side ;
27169: LD_ADDR_OWVAR 20
27173: PUSH
27174: LD_OWVAR 2
27178: ST_TO_ADDR
// uc_nation := nation_american ;
27179: LD_ADDR_OWVAR 21
27183: PUSH
27184: LD_INT 1
27186: ST_TO_ADDR
// vc_chassis := us_morphling ;
27187: LD_ADDR_OWVAR 37
27191: PUSH
27192: LD_INT 5
27194: ST_TO_ADDR
// vc_engine := engine_siberite ;
27195: LD_ADDR_OWVAR 39
27199: PUSH
27200: LD_INT 3
27202: ST_TO_ADDR
// vc_control := control_computer ;
27203: LD_ADDR_OWVAR 38
27207: PUSH
27208: LD_INT 3
27210: ST_TO_ADDR
// vc_weapon := us_double_laser ;
27211: LD_ADDR_OWVAR 40
27215: PUSH
27216: LD_INT 10
27218: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
27219: CALL_OW 45
27223: PPUSH
27224: LD_VAR 0 2
27228: PUSH
27229: LD_INT 1
27231: ARRAY
27232: PPUSH
27233: CALL_OW 250
27237: PPUSH
27238: LD_VAR 0 2
27242: PUSH
27243: LD_INT 1
27245: ARRAY
27246: PPUSH
27247: CALL_OW 251
27251: PPUSH
27252: LD_INT 12
27254: PPUSH
27255: LD_INT 1
27257: PPUSH
27258: CALL_OW 50
// end ;
27262: GO 27166
27264: POP
27265: POP
// end ;
27266: PPOPN 2
27268: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
27269: LD_EXP 46
27273: PUSH
27274: LD_EXP 92
27278: AND
27279: IFFALSE 27501
27281: GO 27283
27283: DISABLE
27284: LD_INT 0
27286: PPUSH
27287: PPUSH
27288: PPUSH
27289: PPUSH
27290: PPUSH
27291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27292: LD_ADDR_VAR 0 6
27296: PUSH
27297: LD_INT 22
27299: PUSH
27300: LD_OWVAR 2
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: PUSH
27309: LD_INT 21
27311: PUSH
27312: LD_INT 1
27314: PUSH
27315: EMPTY
27316: LIST
27317: LIST
27318: PUSH
27319: LD_INT 3
27321: PUSH
27322: LD_INT 23
27324: PUSH
27325: LD_INT 0
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: LIST
27340: PPUSH
27341: CALL_OW 69
27345: ST_TO_ADDR
// if not tmp then
27346: LD_VAR 0 6
27350: NOT
27351: IFFALSE 27355
// exit ;
27353: GO 27501
// s1 := rand ( 1 , 4 ) ;
27355: LD_ADDR_VAR 0 2
27359: PUSH
27360: LD_INT 1
27362: PPUSH
27363: LD_INT 4
27365: PPUSH
27366: CALL_OW 12
27370: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
27371: LD_ADDR_VAR 0 4
27375: PUSH
27376: LD_VAR 0 6
27380: PUSH
27381: LD_INT 1
27383: ARRAY
27384: PPUSH
27385: LD_VAR 0 2
27389: PPUSH
27390: CALL_OW 259
27394: ST_TO_ADDR
// if s1 = 1 then
27395: LD_VAR 0 2
27399: PUSH
27400: LD_INT 1
27402: EQUAL
27403: IFFALSE 27423
// s2 := rand ( 2 , 4 ) else
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: LD_INT 2
27412: PPUSH
27413: LD_INT 4
27415: PPUSH
27416: CALL_OW 12
27420: ST_TO_ADDR
27421: GO 27431
// s2 := 1 ;
27423: LD_ADDR_VAR 0 3
27427: PUSH
27428: LD_INT 1
27430: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
27431: LD_ADDR_VAR 0 5
27435: PUSH
27436: LD_VAR 0 6
27440: PUSH
27441: LD_INT 1
27443: ARRAY
27444: PPUSH
27445: LD_VAR 0 3
27449: PPUSH
27450: CALL_OW 259
27454: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
27455: LD_VAR 0 6
27459: PUSH
27460: LD_INT 1
27462: ARRAY
27463: PPUSH
27464: LD_VAR 0 2
27468: PPUSH
27469: LD_VAR 0 5
27473: PPUSH
27474: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
27478: LD_VAR 0 6
27482: PUSH
27483: LD_INT 1
27485: ARRAY
27486: PPUSH
27487: LD_VAR 0 3
27491: PPUSH
27492: LD_VAR 0 4
27496: PPUSH
27497: CALL_OW 237
// end ;
27501: PPOPN 6
27503: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
27504: LD_EXP 46
27508: PUSH
27509: LD_EXP 93
27513: AND
27514: IFFALSE 27593
27516: GO 27518
27518: DISABLE
27519: LD_INT 0
27521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
27522: LD_ADDR_VAR 0 1
27526: PUSH
27527: LD_INT 22
27529: PUSH
27530: LD_OWVAR 2
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 30
27541: PUSH
27542: LD_INT 3
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PPUSH
27553: CALL_OW 69
27557: ST_TO_ADDR
// if not tmp then
27558: LD_VAR 0 1
27562: NOT
27563: IFFALSE 27567
// exit ;
27565: GO 27593
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27567: LD_VAR 0 1
27571: PUSH
27572: LD_INT 1
27574: PPUSH
27575: LD_VAR 0 1
27579: PPUSH
27580: CALL_OW 12
27584: ARRAY
27585: PPUSH
27586: LD_INT 1
27588: PPUSH
27589: CALL_OW 234
// end ;
27593: PPOPN 1
27595: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
27596: LD_EXP 46
27600: PUSH
27601: LD_EXP 94
27605: AND
27606: IFFALSE 27718
27608: GO 27610
27610: DISABLE
27611: LD_INT 0
27613: PPUSH
27614: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
27615: LD_ADDR_VAR 0 2
27619: PUSH
27620: LD_INT 22
27622: PUSH
27623: LD_OWVAR 2
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: PUSH
27632: LD_INT 2
27634: PUSH
27635: LD_INT 30
27637: PUSH
27638: LD_INT 27
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: LD_INT 30
27647: PUSH
27648: LD_INT 26
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 30
27657: PUSH
27658: LD_INT 28
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: PUSH
27665: EMPTY
27666: LIST
27667: LIST
27668: LIST
27669: LIST
27670: PUSH
27671: EMPTY
27672: LIST
27673: LIST
27674: PPUSH
27675: CALL_OW 69
27679: ST_TO_ADDR
// if not tmp then
27680: LD_VAR 0 2
27684: NOT
27685: IFFALSE 27689
// exit ;
27687: GO 27718
// for i in tmp do
27689: LD_ADDR_VAR 0 1
27693: PUSH
27694: LD_VAR 0 2
27698: PUSH
27699: FOR_IN
27700: IFFALSE 27716
// SetLives ( i , 1 ) ;
27702: LD_VAR 0 1
27706: PPUSH
27707: LD_INT 1
27709: PPUSH
27710: CALL_OW 234
27714: GO 27699
27716: POP
27717: POP
// end ;
27718: PPOPN 2
27720: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
27721: LD_EXP 46
27725: PUSH
27726: LD_EXP 95
27730: AND
27731: IFFALSE 28005
27733: GO 27735
27735: DISABLE
27736: LD_INT 0
27738: PPUSH
27739: PPUSH
27740: PPUSH
// begin i := rand ( 1 , 7 ) ;
27741: LD_ADDR_VAR 0 1
27745: PUSH
27746: LD_INT 1
27748: PPUSH
27749: LD_INT 7
27751: PPUSH
27752: CALL_OW 12
27756: ST_TO_ADDR
// case i of 1 :
27757: LD_VAR 0 1
27761: PUSH
27762: LD_INT 1
27764: DOUBLE
27765: EQUAL
27766: IFTRUE 27770
27768: GO 27780
27770: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
27771: LD_STRING earthquake(getX(game), 0, 32)
27773: PPUSH
27774: CALL_OW 559
27778: GO 28005
27780: LD_INT 2
27782: DOUBLE
27783: EQUAL
27784: IFTRUE 27788
27786: GO 27802
27788: POP
// begin ToLua ( displayStucuk(); ) ;
27789: LD_STRING displayStucuk();
27791: PPUSH
27792: CALL_OW 559
// ResetFog ;
27796: CALL_OW 335
// end ; 3 :
27800: GO 28005
27802: LD_INT 3
27804: DOUBLE
27805: EQUAL
27806: IFTRUE 27810
27808: GO 27914
27810: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27811: LD_ADDR_VAR 0 2
27815: PUSH
27816: LD_INT 22
27818: PUSH
27819: LD_OWVAR 2
27823: PUSH
27824: EMPTY
27825: LIST
27826: LIST
27827: PUSH
27828: LD_INT 25
27830: PUSH
27831: LD_INT 1
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PPUSH
27842: CALL_OW 69
27846: ST_TO_ADDR
// if not tmp then
27847: LD_VAR 0 2
27851: NOT
27852: IFFALSE 27856
// exit ;
27854: GO 28005
// un := tmp [ rand ( 1 , tmp ) ] ;
27856: LD_ADDR_VAR 0 3
27860: PUSH
27861: LD_VAR 0 2
27865: PUSH
27866: LD_INT 1
27868: PPUSH
27869: LD_VAR 0 2
27873: PPUSH
27874: CALL_OW 12
27878: ARRAY
27879: ST_TO_ADDR
// if Crawls ( un ) then
27880: LD_VAR 0 3
27884: PPUSH
27885: CALL_OW 318
27889: IFFALSE 27900
// ComWalk ( un ) ;
27891: LD_VAR 0 3
27895: PPUSH
27896: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27900: LD_VAR 0 3
27904: PPUSH
27905: LD_INT 8
27907: PPUSH
27908: CALL_OW 336
// end ; 4 :
27912: GO 28005
27914: LD_INT 4
27916: DOUBLE
27917: EQUAL
27918: IFTRUE 27922
27920: GO 27983
27922: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27923: LD_ADDR_VAR 0 2
27927: PUSH
27928: LD_INT 22
27930: PUSH
27931: LD_OWVAR 2
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: LD_INT 30
27942: PUSH
27943: LD_INT 29
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: PPUSH
27954: CALL_OW 69
27958: ST_TO_ADDR
// if not tmp then
27959: LD_VAR 0 2
27963: NOT
27964: IFFALSE 27968
// exit ;
27966: GO 28005
// DestroyUnit ( tmp [ 1 ] ) ;
27968: LD_VAR 0 2
27972: PUSH
27973: LD_INT 1
27975: ARRAY
27976: PPUSH
27977: CALL_OW 65
// end ; 5 .. 7 :
27981: GO 28005
27983: LD_INT 5
27985: DOUBLE
27986: GREATEREQUAL
27987: IFFALSE 27995
27989: LD_INT 7
27991: DOUBLE
27992: LESSEQUAL
27993: IFTRUE 27997
27995: GO 28004
27997: POP
// StreamSibBomb ; end ;
27998: CALL 24285 0 0
28002: GO 28005
28004: POP
// end ;
28005: PPOPN 3
28007: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
28008: LD_EXP 46
28012: PUSH
28013: LD_EXP 96
28017: AND
28018: IFFALSE 28174
28020: GO 28022
28022: DISABLE
28023: LD_INT 0
28025: PPUSH
28026: PPUSH
28027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
28028: LD_ADDR_VAR 0 2
28032: PUSH
28033: LD_INT 81
28035: PUSH
28036: LD_OWVAR 2
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 2
28047: PUSH
28048: LD_INT 21
28050: PUSH
28051: LD_INT 1
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 21
28060: PUSH
28061: LD_INT 2
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: LIST
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PPUSH
28077: CALL_OW 69
28081: ST_TO_ADDR
// if not tmp then
28082: LD_VAR 0 2
28086: NOT
28087: IFFALSE 28091
// exit ;
28089: GO 28174
// p := 0 ;
28091: LD_ADDR_VAR 0 3
28095: PUSH
28096: LD_INT 0
28098: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28099: LD_INT 35
28101: PPUSH
28102: CALL_OW 67
// p := p + 1 ;
28106: LD_ADDR_VAR 0 3
28110: PUSH
28111: LD_VAR 0 3
28115: PUSH
28116: LD_INT 1
28118: PLUS
28119: ST_TO_ADDR
// for i in tmp do
28120: LD_ADDR_VAR 0 1
28124: PUSH
28125: LD_VAR 0 2
28129: PUSH
28130: FOR_IN
28131: IFFALSE 28162
// if GetLives ( i ) < 1000 then
28133: LD_VAR 0 1
28137: PPUSH
28138: CALL_OW 256
28142: PUSH
28143: LD_INT 1000
28145: LESS
28146: IFFALSE 28160
// SetLives ( i , 1000 ) ;
28148: LD_VAR 0 1
28152: PPUSH
28153: LD_INT 1000
28155: PPUSH
28156: CALL_OW 234
28160: GO 28130
28162: POP
28163: POP
// until p > 20 ;
28164: LD_VAR 0 3
28168: PUSH
28169: LD_INT 20
28171: GREATER
28172: IFFALSE 28099
// end ;
28174: PPOPN 3
28176: END
// every 0 0$1 trigger StreamModeActive and sTime do
28177: LD_EXP 46
28181: PUSH
28182: LD_EXP 97
28186: AND
28187: IFFALSE 28222
28189: GO 28191
28191: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
28192: LD_INT 28
28194: PPUSH
28195: LD_OWVAR 2
28199: PPUSH
28200: LD_INT 2
28202: PPUSH
28203: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
28207: LD_INT 30
28209: PPUSH
28210: LD_OWVAR 2
28214: PPUSH
28215: LD_INT 2
28217: PPUSH
28218: CALL_OW 322
// end ;
28222: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
28223: LD_EXP 46
28227: PUSH
28228: LD_EXP 98
28232: AND
28233: IFFALSE 28354
28235: GO 28237
28237: DISABLE
28238: LD_INT 0
28240: PPUSH
28241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28242: LD_ADDR_VAR 0 2
28246: PUSH
28247: LD_INT 22
28249: PUSH
28250: LD_OWVAR 2
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 21
28261: PUSH
28262: LD_INT 1
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: PUSH
28269: LD_INT 3
28271: PUSH
28272: LD_INT 23
28274: PUSH
28275: LD_INT 0
28277: PUSH
28278: EMPTY
28279: LIST
28280: LIST
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: LIST
28290: PPUSH
28291: CALL_OW 69
28295: ST_TO_ADDR
// if not tmp then
28296: LD_VAR 0 2
28300: NOT
28301: IFFALSE 28305
// exit ;
28303: GO 28354
// for i in tmp do
28305: LD_ADDR_VAR 0 1
28309: PUSH
28310: LD_VAR 0 2
28314: PUSH
28315: FOR_IN
28316: IFFALSE 28352
// begin if Crawls ( i ) then
28318: LD_VAR 0 1
28322: PPUSH
28323: CALL_OW 318
28327: IFFALSE 28338
// ComWalk ( i ) ;
28329: LD_VAR 0 1
28333: PPUSH
28334: CALL_OW 138
// SetClass ( i , 2 ) ;
28338: LD_VAR 0 1
28342: PPUSH
28343: LD_INT 2
28345: PPUSH
28346: CALL_OW 336
// end ;
28350: GO 28315
28352: POP
28353: POP
// end ;
28354: PPOPN 2
28356: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
28357: LD_EXP 46
28361: PUSH
28362: LD_EXP 99
28366: AND
28367: IFFALSE 28648
28369: GO 28371
28371: DISABLE
28372: LD_INT 0
28374: PPUSH
28375: PPUSH
28376: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
28377: LD_OWVAR 2
28381: PPUSH
28382: LD_INT 9
28384: PPUSH
28385: LD_INT 1
28387: PPUSH
28388: LD_INT 1
28390: PPUSH
28391: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
28395: LD_INT 9
28397: PPUSH
28398: LD_OWVAR 2
28402: PPUSH
28403: CALL_OW 343
// uc_side := 9 ;
28407: LD_ADDR_OWVAR 20
28411: PUSH
28412: LD_INT 9
28414: ST_TO_ADDR
// uc_nation := 2 ;
28415: LD_ADDR_OWVAR 21
28419: PUSH
28420: LD_INT 2
28422: ST_TO_ADDR
// hc_name := Dark Warrior ;
28423: LD_ADDR_OWVAR 26
28427: PUSH
28428: LD_STRING Dark Warrior
28430: ST_TO_ADDR
// hc_gallery :=  ;
28431: LD_ADDR_OWVAR 33
28435: PUSH
28436: LD_STRING 
28438: ST_TO_ADDR
// hc_noskilllimit := true ;
28439: LD_ADDR_OWVAR 76
28443: PUSH
28444: LD_INT 1
28446: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
28447: LD_ADDR_OWVAR 31
28451: PUSH
28452: LD_INT 30
28454: PUSH
28455: LD_INT 30
28457: PUSH
28458: LD_INT 30
28460: PUSH
28461: LD_INT 30
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: ST_TO_ADDR
// un := CreateHuman ;
28470: LD_ADDR_VAR 0 3
28474: PUSH
28475: CALL_OW 44
28479: ST_TO_ADDR
// hc_noskilllimit := false ;
28480: LD_ADDR_OWVAR 76
28484: PUSH
28485: LD_INT 0
28487: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28488: LD_VAR 0 3
28492: PPUSH
28493: LD_INT 1
28495: PPUSH
28496: CALL_OW 51
// p := 0 ;
28500: LD_ADDR_VAR 0 2
28504: PUSH
28505: LD_INT 0
28507: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
28508: LD_INT 35
28510: PPUSH
28511: CALL_OW 67
// p := p + 1 ;
28515: LD_ADDR_VAR 0 2
28519: PUSH
28520: LD_VAR 0 2
28524: PUSH
28525: LD_INT 1
28527: PLUS
28528: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
28529: LD_VAR 0 3
28533: PPUSH
28534: CALL_OW 256
28538: PUSH
28539: LD_INT 1000
28541: LESS
28542: IFFALSE 28556
// SetLives ( un , 1000 ) ;
28544: LD_VAR 0 3
28548: PPUSH
28549: LD_INT 1000
28551: PPUSH
28552: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
28556: LD_VAR 0 3
28560: PPUSH
28561: LD_INT 81
28563: PUSH
28564: LD_OWVAR 2
28568: PUSH
28569: EMPTY
28570: LIST
28571: LIST
28572: PUSH
28573: LD_INT 91
28575: PUSH
28576: LD_VAR 0 3
28580: PUSH
28581: LD_INT 30
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PPUSH
28593: CALL_OW 69
28597: PPUSH
28598: LD_VAR 0 3
28602: PPUSH
28603: CALL_OW 74
28607: PPUSH
28608: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
28612: LD_VAR 0 2
28616: PUSH
28617: LD_INT 60
28619: GREATER
28620: PUSH
28621: LD_VAR 0 3
28625: PPUSH
28626: CALL_OW 301
28630: OR
28631: IFFALSE 28508
// if un then
28633: LD_VAR 0 3
28637: IFFALSE 28648
// RemoveUnit ( un ) ;
28639: LD_VAR 0 3
28643: PPUSH
28644: CALL_OW 64
// end ; end_of_file
28648: PPOPN 3
28650: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
28651: LD_INT 0
28653: PPUSH
28654: PPUSH
28655: PPUSH
28656: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
28657: LD_VAR 0 1
28661: PPUSH
28662: CALL_OW 264
28666: PUSH
28667: LD_EXP 45
28671: EQUAL
28672: IFFALSE 28744
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
28674: LD_INT 68
28676: PPUSH
28677: LD_VAR 0 1
28681: PPUSH
28682: CALL_OW 255
28686: PPUSH
28687: CALL_OW 321
28691: PUSH
28692: LD_INT 2
28694: EQUAL
28695: IFFALSE 28707
// eff := 70 else
28697: LD_ADDR_VAR 0 4
28701: PUSH
28702: LD_INT 70
28704: ST_TO_ADDR
28705: GO 28715
// eff := 30 ;
28707: LD_ADDR_VAR 0 4
28711: PUSH
28712: LD_INT 30
28714: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
28715: LD_VAR 0 1
28719: PPUSH
28720: CALL_OW 250
28724: PPUSH
28725: LD_VAR 0 1
28729: PPUSH
28730: CALL_OW 251
28734: PPUSH
28735: LD_VAR 0 4
28739: PPUSH
28740: CALL_OW 495
// end ; end ;
28744: LD_VAR 0 2
28748: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
28749: LD_INT 0
28751: PPUSH
// end ;
28752: LD_VAR 0 4
28756: RET
// export function SOS_Command ( cmd ) ; begin
28757: LD_INT 0
28759: PPUSH
// end ;
28760: LD_VAR 0 2
28764: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
28765: LD_VAR 0 1
28769: PUSH
28770: LD_INT 255
28772: EQUAL
28773: PUSH
28774: LD_VAR 0 2
28778: PPUSH
28779: CALL_OW 264
28783: PUSH
28784: LD_INT 14
28786: PUSH
28787: LD_INT 53
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: IN
28794: AND
28795: PUSH
28796: LD_VAR 0 4
28800: PPUSH
28801: LD_VAR 0 5
28805: PPUSH
28806: CALL_OW 488
28810: AND
28811: IFFALSE 28835
// CutTreeXYR ( unit , x , y , 12 ) ;
28813: LD_VAR 0 2
28817: PPUSH
28818: LD_VAR 0 4
28822: PPUSH
28823: LD_VAR 0 5
28827: PPUSH
28828: LD_INT 12
28830: PPUSH
28831: CALL 28838 0 4
// end ;
28835: PPOPN 5
28837: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
28838: LD_INT 0
28840: PPUSH
28841: PPUSH
28842: PPUSH
28843: PPUSH
28844: PPUSH
28845: PPUSH
28846: PPUSH
28847: PPUSH
28848: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
28849: LD_VAR 0 1
28853: NOT
28854: PUSH
28855: LD_VAR 0 2
28859: PPUSH
28860: LD_VAR 0 3
28864: PPUSH
28865: CALL_OW 488
28869: NOT
28870: OR
28871: PUSH
28872: LD_VAR 0 4
28876: NOT
28877: OR
28878: IFFALSE 28882
// exit ;
28880: GO 29222
// list := [ ] ;
28882: LD_ADDR_VAR 0 13
28886: PUSH
28887: EMPTY
28888: ST_TO_ADDR
// if x - r < 0 then
28889: LD_VAR 0 2
28893: PUSH
28894: LD_VAR 0 4
28898: MINUS
28899: PUSH
28900: LD_INT 0
28902: LESS
28903: IFFALSE 28915
// min_x := 0 else
28905: LD_ADDR_VAR 0 7
28909: PUSH
28910: LD_INT 0
28912: ST_TO_ADDR
28913: GO 28931
// min_x := x - r ;
28915: LD_ADDR_VAR 0 7
28919: PUSH
28920: LD_VAR 0 2
28924: PUSH
28925: LD_VAR 0 4
28929: MINUS
28930: ST_TO_ADDR
// if y - r < 0 then
28931: LD_VAR 0 3
28935: PUSH
28936: LD_VAR 0 4
28940: MINUS
28941: PUSH
28942: LD_INT 0
28944: LESS
28945: IFFALSE 28957
// min_y := 0 else
28947: LD_ADDR_VAR 0 8
28951: PUSH
28952: LD_INT 0
28954: ST_TO_ADDR
28955: GO 28973
// min_y := y - r ;
28957: LD_ADDR_VAR 0 8
28961: PUSH
28962: LD_VAR 0 3
28966: PUSH
28967: LD_VAR 0 4
28971: MINUS
28972: ST_TO_ADDR
// max_x := x + r ;
28973: LD_ADDR_VAR 0 9
28977: PUSH
28978: LD_VAR 0 2
28982: PUSH
28983: LD_VAR 0 4
28987: PLUS
28988: ST_TO_ADDR
// max_y := y + r ;
28989: LD_ADDR_VAR 0 10
28993: PUSH
28994: LD_VAR 0 3
28998: PUSH
28999: LD_VAR 0 4
29003: PLUS
29004: ST_TO_ADDR
// for _x = min_x to max_x do
29005: LD_ADDR_VAR 0 11
29009: PUSH
29010: DOUBLE
29011: LD_VAR 0 7
29015: DEC
29016: ST_TO_ADDR
29017: LD_VAR 0 9
29021: PUSH
29022: FOR_TO
29023: IFFALSE 29140
// for _y = min_y to max_y do
29025: LD_ADDR_VAR 0 12
29029: PUSH
29030: DOUBLE
29031: LD_VAR 0 8
29035: DEC
29036: ST_TO_ADDR
29037: LD_VAR 0 10
29041: PUSH
29042: FOR_TO
29043: IFFALSE 29136
// begin if not ValidHex ( _x , _y ) then
29045: LD_VAR 0 11
29049: PPUSH
29050: LD_VAR 0 12
29054: PPUSH
29055: CALL_OW 488
29059: NOT
29060: IFFALSE 29064
// continue ;
29062: GO 29042
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
29064: LD_VAR 0 11
29068: PPUSH
29069: LD_VAR 0 12
29073: PPUSH
29074: CALL_OW 351
29078: PUSH
29079: LD_VAR 0 11
29083: PPUSH
29084: LD_VAR 0 12
29088: PPUSH
29089: CALL_OW 554
29093: AND
29094: IFFALSE 29134
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
29096: LD_ADDR_VAR 0 13
29100: PUSH
29101: LD_VAR 0 13
29105: PPUSH
29106: LD_VAR 0 13
29110: PUSH
29111: LD_INT 1
29113: PLUS
29114: PPUSH
29115: LD_VAR 0 11
29119: PUSH
29120: LD_VAR 0 12
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PPUSH
29129: CALL_OW 2
29133: ST_TO_ADDR
// end ;
29134: GO 29042
29136: POP
29137: POP
29138: GO 29022
29140: POP
29141: POP
// if not list then
29142: LD_VAR 0 13
29146: NOT
29147: IFFALSE 29151
// exit ;
29149: GO 29222
// for i in list do
29151: LD_ADDR_VAR 0 6
29155: PUSH
29156: LD_VAR 0 13
29160: PUSH
29161: FOR_IN
29162: IFFALSE 29220
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
29164: LD_VAR 0 1
29168: PPUSH
29169: LD_STRING M
29171: PUSH
29172: LD_VAR 0 6
29176: PUSH
29177: LD_INT 1
29179: ARRAY
29180: PUSH
29181: LD_VAR 0 6
29185: PUSH
29186: LD_INT 2
29188: ARRAY
29189: PUSH
29190: LD_INT 0
29192: PUSH
29193: LD_INT 0
29195: PUSH
29196: LD_INT 0
29198: PUSH
29199: LD_INT 0
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: PUSH
29211: EMPTY
29212: LIST
29213: PPUSH
29214: CALL_OW 447
29218: GO 29161
29220: POP
29221: POP
// end ;
29222: LD_VAR 0 5
29226: RET
