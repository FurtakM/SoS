// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 44 0 0
// DebugMode ;
  12: CALL 253 0 0
// AnimateTrees ( true ) ;
  16: LD_INT 1
  18: PPUSH
  19: CALL_OW 573
// PrepareNature ;
  23: CALL 3069 0 0
// PrepareRussians ;
  27: CALL 4810 0 0
// PrepareAmericans ;
  31: CALL 3726 0 0
// Action ;
  35: CALL 8690 0 0
// SaveForQuickRestart ;
  39: CALL_OW 22
// end ;
  43: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end , kill_counter ; function Init ; begin
  44: LD_INT 0
  46: PPUSH
// debug := false ;
  47: LD_ADDR_EXP 1
  51: PUSH
  52: LD_INT 0
  54: ST_TO_ADDR
// mission_prefix := 07c_ ;
  55: LD_ADDR_EXP 3
  59: PUSH
  60: LD_STRING 07c_
  62: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  63: LD_ADDR_EXP 2
  67: PUSH
  68: LD_STRING 07_
  70: ST_TO_ADDR
// buildings_counter := 0 ;
  71: LD_ADDR_EXP 4
  75: PUSH
  76: LD_INT 0
  78: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  79: LD_ADDR_EXP 5
  83: PUSH
  84: LD_INT 67200
  86: PUSH
  87: LD_INT 60900
  89: PUSH
  90: LD_INT 54600
  92: PUSH
  93: EMPTY
  94: LIST
  95: LIST
  96: LIST
  97: PUSH
  98: LD_OWVAR 67
 102: ARRAY
 103: PUSH
 104: LD_INT 79800
 106: PUSH
 107: LD_INT 73500
 109: PUSH
 110: LD_INT 67200
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PUSH
 124: LD_INT 92400
 126: PUSH
 127: LD_INT 86100
 129: PUSH
 130: LD_INT 79800
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: PUSH
 138: LD_OWVAR 67
 142: ARRAY
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// can_end := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// must_end := false ;
 157: LD_ADDR_EXP 7
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// kill_counter := 0 ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// end ;
 173: LD_VAR 0 1
 177: RET
// every 0 0$01 trigger not debug do
 178: LD_EXP 1
 182: NOT
 183: IFFALSE 252
 185: GO 187
 187: DISABLE
// begin enable ;
 188: ENABLE
// if not must_end then
 189: LD_EXP 7
 193: NOT
 194: IFFALSE 215
// display_strings := [ #Am07-1 , tick ] else
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: ST_TO_ADDR
 213: GO 252
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 215: LD_ADDR_OWVAR 47
 219: PUSH
 220: LD_STRING #Am07-1
 222: PUSH
 223: LD_OWVAR 1
 227: PUSH
 228: LD_STRING #Am07-2
 230: PUSH
 231: LD_EXP 5
 235: PUSH
 236: LD_INT 3
 238: ARRAY
 239: PUSH
 240: LD_OWVAR 1
 244: MINUS
 245: PUSH
 246: EMPTY
 247: LIST
 248: LIST
 249: LIST
 250: LIST
 251: ST_TO_ADDR
// end ;
 252: END
// function DebugMode ; var i ; begin
 253: LD_INT 0
 255: PPUSH
 256: PPUSH
// if not debug then
 257: LD_EXP 1
 261: NOT
 262: IFFALSE 266
// exit ;
 264: GO 273
// FogOff ( 1 ) ;
 266: LD_INT 1
 268: PPUSH
 269: CALL_OW 344
// end ;
 273: LD_VAR 0 1
 277: RET
// every 3 trigger debug do var i , filter ;
 278: LD_EXP 1
 282: IFFALSE 371
 284: GO 286
 286: DISABLE
 287: LD_INT 0
 289: PPUSH
 290: PPUSH
// begin enable ;
 291: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: LD_INT 22
 299: PUSH
 300: LD_INT 1
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: PUSH
 307: LD_INT 3
 309: PUSH
 310: LD_INT 24
 312: PUSH
 313: LD_INT 500
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: PPUSH
 328: CALL_OW 69
 332: ST_TO_ADDR
// if not filter then
 333: LD_VAR 0 2
 337: NOT
 338: IFFALSE 342
// exit ;
 340: GO 371
// for i in filter do
 342: LD_ADDR_VAR 0 1
 346: PUSH
 347: LD_VAR 0 2
 351: PUSH
 352: FOR_IN
 353: IFFALSE 369
// SetLives ( i , 1000 ) ;
 355: LD_VAR 0 1
 359: PPUSH
 360: LD_INT 1000
 362: PPUSH
 363: CALL_OW 234
 367: GO 352
 369: POP
 370: POP
// end ;
 371: PPOPN 2
 373: END
// every 0 0$1 trigger kill_counter >= 20 do
 374: LD_EXP 8
 378: PUSH
 379: LD_INT 20
 381: GREATEREQUAL
 382: IFFALSE 394
 384: GO 386
 386: DISABLE
// SetAchievement ( ACH_HITMAN ) ;
 387: LD_STRING ACH_HITMAN
 389: PPUSH
 390: CALL_OW 543
 394: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] ] ) >= 3 do
 395: LD_INT 22
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: LD_INT 23
 407: PUSH
 408: LD_INT 3
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: PUSH
 415: LD_INT 21
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: PPUSH
 430: CALL_OW 69
 434: PUSH
 435: LD_INT 3
 437: GREATEREQUAL
 438: IFFALSE 450
 440: GO 442
 442: DISABLE
// SetAchievement ( ACH_TANKACE ) ;
 443: LD_STRING ACH_TANKACE
 445: PPUSH
 446: CALL_OW 543
 450: END
// every 0 0$1 trigger FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) = 0 do
 451: LD_INT 2
 453: PUSH
 454: LD_INT 30
 456: PUSH
 457: LD_INT 0
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: PUSH
 464: LD_INT 30
 466: PUSH
 467: LD_INT 1
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PPUSH
 479: CALL_OW 69
 483: PUSH
 484: LD_INT 0
 486: EQUAL
 487: IFFALSE 499
 489: GO 491
 491: DISABLE
// SetAchievement ( ACH_COMMANDO ) ; end_of_file
 492: LD_STRING ACH_COMMANDO
 494: PPUSH
 495: CALL_OW 543
 499: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// if exist_mode then
 504: LD_VAR 0 2
 508: IFFALSE 533
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_EXP 2
 519: PUSH
 520: LD_VAR 0 1
 524: STR
 525: PPUSH
 526: CALL_OW 34
 530: ST_TO_ADDR
 531: GO 548
// unit := NewCharacter ( ident ) ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_VAR 0 1
 542: PPUSH
 543: CALL_OW 25
 547: ST_TO_ADDR
// result := unit ;
 548: LD_ADDR_VAR 0 3
 552: PUSH
 553: LD_VAR 0 4
 557: ST_TO_ADDR
// end ;
 558: LD_VAR 0 3
 562: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 563: LD_INT 0
 565: PPUSH
// uc_side := side ;
 566: LD_ADDR_OWVAR 20
 570: PUSH
 571: LD_VAR 0 1
 575: ST_TO_ADDR
// uc_nation := nation ;
 576: LD_ADDR_OWVAR 21
 580: PUSH
 581: LD_VAR 0 2
 585: ST_TO_ADDR
// vc_chassis := chassis ;
 586: LD_ADDR_OWVAR 37
 590: PUSH
 591: LD_VAR 0 3
 595: ST_TO_ADDR
// vc_engine := engine ;
 596: LD_ADDR_OWVAR 39
 600: PUSH
 601: LD_VAR 0 4
 605: ST_TO_ADDR
// vc_control := control ;
 606: LD_ADDR_OWVAR 38
 610: PUSH
 611: LD_VAR 0 5
 615: ST_TO_ADDR
// vc_weapon := weapon ;
 616: LD_ADDR_OWVAR 40
 620: PUSH
 621: LD_VAR 0 6
 625: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 626: LD_ADDR_OWVAR 41
 630: PUSH
 631: LD_VAR 0 7
 635: ST_TO_ADDR
// result := CreateVehicle ;
 636: LD_ADDR_VAR 0 8
 640: PUSH
 641: CALL_OW 45
 645: ST_TO_ADDR
// end ;
 646: LD_VAR 0 8
 650: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 651: LD_INT 0
 653: PPUSH
 654: PPUSH
 655: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 656: LD_ADDR_VAR 0 4
 660: PUSH
 661: LD_INT 22
 663: PUSH
 664: LD_INT 1
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: PUSH
 671: LD_INT 21
 673: PUSH
 674: LD_INT 1
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PUSH
 681: LD_INT 50
 683: PUSH
 684: EMPTY
 685: LIST
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL_OW 69
 696: PUSH
 697: LD_EXP 9
 701: PUSH
 702: LD_EXP 10
 706: PUSH
 707: LD_EXP 11
 711: PUSH
 712: LD_EXP 12
 716: PUSH
 717: LD_EXP 13
 721: PUSH
 722: LD_EXP 14
 726: PUSH
 727: LD_EXP 15
 731: PUSH
 732: LD_EXP 16
 736: PUSH
 737: LD_EXP 18
 741: PUSH
 742: LD_EXP 17
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: DIFF
 759: ST_TO_ADDR
// if not filter then
 760: LD_VAR 0 4
 764: NOT
 765: IFFALSE 769
// exit ;
 767: GO 796
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 769: LD_ADDR_VAR 0 2
 773: PUSH
 774: LD_VAR 0 4
 778: PPUSH
 779: LD_INT 26
 781: PUSH
 782: LD_VAR 0 1
 786: PUSH
 787: EMPTY
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL_OW 72
 795: ST_TO_ADDR
// end ;
 796: LD_VAR 0 2
 800: RET
// export function SayX ( units , ident ) ; var i ; begin
 801: LD_INT 0
 803: PPUSH
 804: PPUSH
// result := false ;
 805: LD_ADDR_VAR 0 3
 809: PUSH
 810: LD_INT 0
 812: ST_TO_ADDR
// if not units then
 813: LD_VAR 0 1
 817: NOT
 818: IFFALSE 822
// exit ;
 820: GO 876
// for i in units do
 822: LD_ADDR_VAR 0 4
 826: PUSH
 827: LD_VAR 0 1
 831: PUSH
 832: FOR_IN
 833: IFFALSE 874
// if IsOk ( i ) then
 835: LD_VAR 0 4
 839: PPUSH
 840: CALL_OW 302
 844: IFFALSE 872
// begin Say ( i , ident ) ;
 846: LD_VAR 0 4
 850: PPUSH
 851: LD_VAR 0 2
 855: PPUSH
 856: CALL_OW 88
// result := i ;
 860: LD_ADDR_VAR 0 3
 864: PUSH
 865: LD_VAR 0 4
 869: ST_TO_ADDR
// break ;
 870: GO 874
// end ;
 872: GO 832
 874: POP
 875: POP
// end ;
 876: LD_VAR 0 3
 880: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 881: LD_INT 0
 883: PPUSH
 884: PPUSH
 885: PPUSH
// result := [ ] ;
 886: LD_ADDR_VAR 0 2
 890: PUSH
 891: EMPTY
 892: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 893: LD_ADDR_VAR 0 3
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PPUSH
 908: CALL_OW 69
 912: ST_TO_ADDR
// if not tmp then
 913: LD_VAR 0 3
 917: NOT
 918: IFFALSE 922
// exit ;
 920: GO 972
// for i in tmp do
 922: LD_ADDR_VAR 0 4
 926: PUSH
 927: LD_VAR 0 3
 931: PUSH
 932: FOR_IN
 933: IFFALSE 970
// if GetBase ( i ) = base then
 935: LD_VAR 0 4
 939: PPUSH
 940: CALL_OW 274
 944: PUSH
 945: LD_VAR 0 1
 949: EQUAL
 950: IFFALSE 968
// result := result ^ i ;
 952: LD_ADDR_VAR 0 2
 956: PUSH
 957: LD_VAR 0 2
 961: PUSH
 962: LD_VAR 0 4
 966: ADD
 967: ST_TO_ADDR
 968: GO 932
 970: POP
 971: POP
// end ;
 972: LD_VAR 0 2
 976: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 977: LD_INT 0
 979: PPUSH
 980: PPUSH
 981: PPUSH
 982: PPUSH
 983: PPUSH
 984: PPUSH
 985: PPUSH
 986: PPUSH
 987: PPUSH
 988: PPUSH
 989: PPUSH
 990: PPUSH
 991: PPUSH
 992: PPUSH
 993: PPUSH
 994: PPUSH
// result := false ;
 995: LD_ADDR_VAR 0 2
 999: PUSH
1000: LD_INT 0
1002: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
1003: LD_VAR 0 1
1007: NOT
1008: PUSH
1009: LD_VAR 0 1
1013: PPUSH
1014: CALL_OW 266
1018: PUSH
1019: LD_INT 32
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: IN
1029: NOT
1030: OR
1031: IFFALSE 1035
// exit ;
1033: GO 2195
// nat := GetNation ( tower ) ;
1035: LD_ADDR_VAR 0 11
1039: PUSH
1040: LD_VAR 0 1
1044: PPUSH
1045: CALL_OW 248
1049: ST_TO_ADDR
// side := GetSide ( tower ) ;
1050: LD_ADDR_VAR 0 15
1054: PUSH
1055: LD_VAR 0 1
1059: PPUSH
1060: CALL_OW 255
1064: ST_TO_ADDR
// x := GetX ( tower ) ;
1065: LD_ADDR_VAR 0 9
1069: PUSH
1070: LD_VAR 0 1
1074: PPUSH
1075: CALL_OW 250
1079: ST_TO_ADDR
// y := GetY ( tower ) ;
1080: LD_ADDR_VAR 0 10
1084: PUSH
1085: LD_VAR 0 1
1089: PPUSH
1090: CALL_OW 251
1094: ST_TO_ADDR
// if not x or not y then
1095: LD_VAR 0 9
1099: NOT
1100: PUSH
1101: LD_VAR 0 10
1105: NOT
1106: OR
1107: IFFALSE 1111
// exit ;
1109: GO 2195
// weapon := 0 ;
1111: LD_ADDR_VAR 0 17
1115: PUSH
1116: LD_INT 0
1118: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
1119: LD_ADDR_VAR 0 16
1123: PUSH
1124: LD_INT 42
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 44
1132: PUSH
1133: LD_INT 46
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: ST_TO_ADDR
// if not fac_list then
1142: LD_VAR 0 16
1146: NOT
1147: IFFALSE 1151
// exit ;
1149: GO 2195
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1151: LD_ADDR_VAR 0 4
1155: PUSH
1156: LD_INT 4
1158: PUSH
1159: LD_INT 5
1161: PUSH
1162: LD_INT 9
1164: PUSH
1165: LD_INT 10
1167: PUSH
1168: LD_INT 6
1170: PUSH
1171: LD_INT 7
1173: PUSH
1174: LD_INT 11
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 28
1191: PUSH
1192: LD_INT 26
1194: PUSH
1195: LD_INT 30
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 43
1206: PUSH
1207: LD_INT 44
1209: PUSH
1210: LD_INT 46
1212: PUSH
1213: LD_INT 45
1215: PUSH
1216: LD_INT 47
1218: PUSH
1219: LD_INT 49
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: PUSH
1235: LD_VAR 0 11
1239: ARRAY
1240: ST_TO_ADDR
// for i in list do
1241: LD_ADDR_VAR 0 7
1245: PUSH
1246: LD_VAR 0 4
1250: PUSH
1251: FOR_IN
1252: IFFALSE 1285
// if not i in fac_list then
1254: LD_VAR 0 7
1258: PUSH
1259: LD_VAR 0 16
1263: IN
1264: NOT
1265: IFFALSE 1283
// list := list diff i ;
1267: LD_ADDR_VAR 0 4
1271: PUSH
1272: LD_VAR 0 4
1276: PUSH
1277: LD_VAR 0 7
1281: DIFF
1282: ST_TO_ADDR
1283: GO 1251
1285: POP
1286: POP
// if not list then
1287: LD_VAR 0 4
1291: NOT
1292: IFFALSE 1296
// exit ;
1294: GO 2195
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1296: LD_VAR 0 11
1300: PUSH
1301: LD_INT 3
1303: EQUAL
1304: PUSH
1305: LD_INT 49
1307: PUSH
1308: LD_VAR 0 4
1312: IN
1313: AND
1314: PUSH
1315: LD_INT 31
1317: PPUSH
1318: LD_VAR 0 15
1322: PPUSH
1323: CALL_OW 321
1327: PUSH
1328: LD_INT 2
1330: EQUAL
1331: AND
1332: IFFALSE 1392
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1334: LD_INT 22
1336: PUSH
1337: LD_VAR 0 15
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 35
1348: PUSH
1349: LD_INT 49
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: PUSH
1356: LD_INT 91
1358: PUSH
1359: LD_VAR 0 1
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL_OW 69
1381: NOT
1382: IFFALSE 1392
// weapon := ru_time_lapser ;
1384: LD_ADDR_VAR 0 17
1388: PUSH
1389: LD_INT 49
1391: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1392: LD_VAR 0 11
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 2
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: IN
1407: PUSH
1408: LD_INT 11
1410: PUSH
1411: LD_VAR 0 4
1415: IN
1416: PUSH
1417: LD_INT 30
1419: PUSH
1420: LD_VAR 0 4
1424: IN
1425: OR
1426: AND
1427: PUSH
1428: LD_INT 6
1430: PPUSH
1431: LD_VAR 0 15
1435: PPUSH
1436: CALL_OW 321
1440: PUSH
1441: LD_INT 2
1443: EQUAL
1444: AND
1445: IFFALSE 1610
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1447: LD_INT 22
1449: PUSH
1450: LD_VAR 0 15
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: LD_INT 2
1461: PUSH
1462: LD_INT 35
1464: PUSH
1465: LD_INT 11
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 35
1474: PUSH
1475: LD_INT 30
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: PUSH
1487: LD_INT 91
1489: PUSH
1490: LD_VAR 0 1
1494: PUSH
1495: LD_INT 18
1497: PUSH
1498: EMPTY
1499: LIST
1500: LIST
1501: LIST
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: PPUSH
1508: CALL_OW 69
1512: NOT
1513: PUSH
1514: LD_INT 22
1516: PUSH
1517: LD_VAR 0 15
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: LD_INT 2
1528: PUSH
1529: LD_INT 30
1531: PUSH
1532: LD_INT 32
1534: PUSH
1535: EMPTY
1536: LIST
1537: LIST
1538: PUSH
1539: LD_INT 30
1541: PUSH
1542: LD_INT 33
1544: PUSH
1545: EMPTY
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: PUSH
1554: LD_INT 91
1556: PUSH
1557: LD_VAR 0 1
1561: PUSH
1562: LD_INT 12
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: LIST
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: EMPTY
1576: LIST
1577: PPUSH
1578: CALL_OW 69
1582: PUSH
1583: LD_INT 2
1585: GREATER
1586: AND
1587: IFFALSE 1610
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1589: LD_ADDR_VAR 0 17
1593: PUSH
1594: LD_INT 11
1596: PUSH
1597: LD_INT 30
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: LD_VAR 0 11
1608: ARRAY
1609: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1610: LD_VAR 0 17
1614: NOT
1615: PUSH
1616: LD_INT 40
1618: PPUSH
1619: LD_VAR 0 15
1623: PPUSH
1624: CALL_OW 321
1628: PUSH
1629: LD_INT 2
1631: EQUAL
1632: AND
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_VAR 0 4
1641: IN
1642: PUSH
1643: LD_INT 28
1645: PUSH
1646: LD_VAR 0 4
1650: IN
1651: OR
1652: PUSH
1653: LD_INT 45
1655: PUSH
1656: LD_VAR 0 4
1660: IN
1661: OR
1662: AND
1663: IFFALSE 1917
// begin hex := GetHexInfo ( x , y ) ;
1665: LD_ADDR_VAR 0 3
1669: PUSH
1670: LD_VAR 0 9
1674: PPUSH
1675: LD_VAR 0 10
1679: PPUSH
1680: CALL_OW 546
1684: ST_TO_ADDR
// if hex [ 1 ] then
1685: LD_VAR 0 3
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: IFFALSE 1697
// exit ;
1695: GO 2195
// height := hex [ 2 ] ;
1697: LD_ADDR_VAR 0 14
1701: PUSH
1702: LD_VAR 0 3
1706: PUSH
1707: LD_INT 2
1709: ARRAY
1710: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1711: LD_ADDR_VAR 0 13
1715: PUSH
1716: LD_INT 0
1718: PUSH
1719: LD_INT 2
1721: PUSH
1722: LD_INT 3
1724: PUSH
1725: LD_INT 5
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: ST_TO_ADDR
// for i in tmp do
1734: LD_ADDR_VAR 0 7
1738: PUSH
1739: LD_VAR 0 13
1743: PUSH
1744: FOR_IN
1745: IFFALSE 1915
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1747: LD_ADDR_VAR 0 8
1751: PUSH
1752: LD_VAR 0 9
1756: PPUSH
1757: LD_VAR 0 7
1761: PPUSH
1762: LD_INT 5
1764: PPUSH
1765: CALL_OW 272
1769: PUSH
1770: LD_VAR 0 10
1774: PPUSH
1775: LD_VAR 0 7
1779: PPUSH
1780: LD_INT 5
1782: PPUSH
1783: CALL_OW 273
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1792: LD_VAR 0 8
1796: PUSH
1797: LD_INT 1
1799: ARRAY
1800: PPUSH
1801: LD_VAR 0 8
1805: PUSH
1806: LD_INT 2
1808: ARRAY
1809: PPUSH
1810: CALL_OW 488
1814: IFFALSE 1913
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1816: LD_ADDR_VAR 0 3
1820: PUSH
1821: LD_VAR 0 8
1825: PUSH
1826: LD_INT 1
1828: ARRAY
1829: PPUSH
1830: LD_VAR 0 8
1834: PUSH
1835: LD_INT 2
1837: ARRAY
1838: PPUSH
1839: CALL_OW 546
1843: ST_TO_ADDR
// if hex [ 1 ] then
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: IFFALSE 1856
// continue ;
1854: GO 1744
// h := hex [ 2 ] ;
1856: LD_ADDR_VAR 0 12
1860: PUSH
1861: LD_VAR 0 3
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: ST_TO_ADDR
// if h + 7 < height then
1870: LD_VAR 0 12
1874: PUSH
1875: LD_INT 7
1877: PLUS
1878: PUSH
1879: LD_VAR 0 14
1883: LESS
1884: IFFALSE 1913
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1886: LD_ADDR_VAR 0 17
1890: PUSH
1891: LD_INT 7
1893: PUSH
1894: LD_INT 28
1896: PUSH
1897: LD_INT 45
1899: PUSH
1900: EMPTY
1901: LIST
1902: LIST
1903: LIST
1904: PUSH
1905: LD_VAR 0 11
1909: ARRAY
1910: ST_TO_ADDR
// break ;
1911: GO 1915
// end ; end ; end ;
1913: GO 1744
1915: POP
1916: POP
// end ; if not weapon then
1917: LD_VAR 0 17
1921: NOT
1922: IFFALSE 2077
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1924: LD_ADDR_VAR 0 4
1928: PUSH
1929: LD_VAR 0 4
1933: PUSH
1934: LD_INT 11
1936: PUSH
1937: LD_INT 30
1939: PUSH
1940: LD_INT 49
1942: PUSH
1943: EMPTY
1944: LIST
1945: LIST
1946: LIST
1947: DIFF
1948: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1949: LD_ADDR_VAR 0 13
1953: PUSH
1954: LD_INT 22
1956: PUSH
1957: LD_VAR 0 15
1961: PUSH
1962: EMPTY
1963: LIST
1964: LIST
1965: PUSH
1966: LD_INT 91
1968: PUSH
1969: LD_VAR 0 1
1973: PUSH
1974: LD_INT 6
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 3
1984: PUSH
1985: LD_INT 35
1987: PUSH
1988: LD_INT 0
1990: PUSH
1991: EMPTY
1992: LIST
1993: LIST
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: LIST
2003: PPUSH
2004: CALL_OW 69
2008: ST_TO_ADDR
// for i in tmp do
2009: LD_ADDR_VAR 0 7
2013: PUSH
2014: LD_VAR 0 13
2018: PUSH
2019: FOR_IN
2020: IFFALSE 2045
// list := list diff GetBWeapon ( i ) ;
2022: LD_ADDR_VAR 0 4
2026: PUSH
2027: LD_VAR 0 4
2031: PUSH
2032: LD_VAR 0 7
2036: PPUSH
2037: CALL_OW 269
2041: DIFF
2042: ST_TO_ADDR
2043: GO 2019
2045: POP
2046: POP
// if list then
2047: LD_VAR 0 4
2051: IFFALSE 2077
// weapon := list [ rand ( 1 , list ) ] ;
2053: LD_ADDR_VAR 0 17
2057: PUSH
2058: LD_VAR 0 4
2062: PUSH
2063: LD_INT 1
2065: PPUSH
2066: LD_VAR 0 4
2070: PPUSH
2071: CALL_OW 12
2075: ARRAY
2076: ST_TO_ADDR
// end ; if weapon then
2077: LD_VAR 0 17
2081: IFFALSE 2195
// begin tmp := CostOfWeapon ( weapon ) ;
2083: LD_ADDR_VAR 0 13
2087: PUSH
2088: LD_VAR 0 17
2092: PPUSH
2093: CALL_OW 451
2097: ST_TO_ADDR
// j := GetBase ( tower ) ;
2098: LD_ADDR_VAR 0 8
2102: PUSH
2103: LD_VAR 0 1
2107: PPUSH
2108: CALL_OW 274
2112: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
2113: LD_VAR 0 8
2117: PPUSH
2118: LD_INT 1
2120: PPUSH
2121: CALL_OW 275
2125: PUSH
2126: LD_VAR 0 13
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: GREATEREQUAL
2135: PUSH
2136: LD_VAR 0 8
2140: PPUSH
2141: LD_INT 2
2143: PPUSH
2144: CALL_OW 275
2148: PUSH
2149: LD_VAR 0 13
2153: PUSH
2154: LD_INT 2
2156: ARRAY
2157: GREATEREQUAL
2158: AND
2159: PUSH
2160: LD_VAR 0 8
2164: PPUSH
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 275
2172: PUSH
2173: LD_VAR 0 13
2177: PUSH
2178: LD_INT 3
2180: ARRAY
2181: GREATEREQUAL
2182: AND
2183: IFFALSE 2195
// result := weapon ;
2185: LD_ADDR_VAR 0 2
2189: PUSH
2190: LD_VAR 0 17
2194: ST_TO_ADDR
// end ; end ;
2195: LD_VAR 0 2
2199: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2200: LD_INT 0
2202: PPUSH
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
// if not un or not IsOk ( un ) then
2207: LD_VAR 0 1
2211: NOT
2212: PUSH
2213: LD_VAR 0 1
2217: PPUSH
2218: CALL_OW 302
2222: NOT
2223: OR
2224: IFFALSE 2228
// exit ;
2226: GO 2674
// side := GetSide ( un ) ;
2228: LD_ADDR_VAR 0 9
2232: PUSH
2233: LD_VAR 0 1
2237: PPUSH
2238: CALL_OW 255
2242: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2243: LD_ADDR_VAR 0 7
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: LD_VAR 0 9
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: PUSH
2260: LD_INT 30
2262: PUSH
2263: LD_INT 32
2265: PUSH
2266: EMPTY
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 50
2272: PUSH
2273: EMPTY
2274: LIST
2275: PUSH
2276: LD_INT 58
2278: PUSH
2279: EMPTY
2280: LIST
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: PPUSH
2288: CALL_OW 69
2292: PUSH
2293: LD_VAR 0 2
2297: DIFF
2298: ST_TO_ADDR
// if not filter then
2299: LD_VAR 0 7
2303: NOT
2304: IFFALSE 2539
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2306: LD_ADDR_VAR 0 7
2310: PUSH
2311: LD_INT 22
2313: PUSH
2314: LD_VAR 0 9
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: LD_INT 30
2325: PUSH
2326: LD_INT 5
2328: PUSH
2329: EMPTY
2330: LIST
2331: LIST
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: PPUSH
2337: CALL_OW 69
2341: ST_TO_ADDR
// if debug then
2342: LD_EXP 1
2346: IFFALSE 2365
// display_strings := [ filter , 1 ] ;
2348: LD_ADDR_OWVAR 47
2352: PUSH
2353: LD_VAR 0 7
2357: PUSH
2358: LD_STRING 1
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: ST_TO_ADDR
// if not filter then
2365: LD_VAR 0 7
2369: NOT
2370: IFFALSE 2393
// begin ComMoveXY ( un , x , y ) ;
2372: LD_VAR 0 1
2376: PPUSH
2377: LD_VAR 0 3
2381: PPUSH
2382: LD_VAR 0 4
2386: PPUSH
2387: CALL_OW 111
// exit ;
2391: GO 2674
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2393: LD_ADDR_VAR 0 8
2397: PUSH
2398: LD_VAR 0 7
2402: PPUSH
2403: LD_VAR 0 1
2407: PPUSH
2408: CALL_OW 74
2412: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2413: LD_VAR 0 8
2417: PPUSH
2418: CALL_OW 313
2422: PUSH
2423: LD_INT 6
2425: EQUAL
2426: IFFALSE 2446
// filter := filter diff t else
2428: LD_ADDR_VAR 0 7
2432: PUSH
2433: LD_VAR 0 7
2437: PUSH
2438: LD_VAR 0 8
2442: DIFF
2443: ST_TO_ADDR
2444: GO 2448
// break ;
2446: GO 2470
// until UnitsInside ( t ) < 6 or not filter ;
2448: LD_VAR 0 8
2452: PPUSH
2453: CALL_OW 313
2457: PUSH
2458: LD_INT 6
2460: LESS
2461: PUSH
2462: LD_VAR 0 7
2466: NOT
2467: OR
2468: IFFALSE 2393
// if debug then
2470: LD_EXP 1
2474: IFFALSE 2495
// display_strings := [ filter , t ] ;
2476: LD_ADDR_OWVAR 47
2480: PUSH
2481: LD_VAR 0 7
2485: PUSH
2486: LD_VAR 0 8
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: ST_TO_ADDR
// if not filter then
2495: LD_VAR 0 7
2499: NOT
2500: IFFALSE 2523
// ComMoveXY ( un , x , y ) else
2502: LD_VAR 0 1
2506: PPUSH
2507: LD_VAR 0 3
2511: PPUSH
2512: LD_VAR 0 4
2516: PPUSH
2517: CALL_OW 111
2521: GO 2537
// ComEnterUnit ( un , t ) ;
2523: LD_VAR 0 1
2527: PPUSH
2528: LD_VAR 0 8
2532: PPUSH
2533: CALL_OW 120
// end else
2537: GO 2674
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2539: LD_ADDR_VAR 0 8
2543: PUSH
2544: LD_VAR 0 7
2548: PPUSH
2549: LD_VAR 0 1
2553: PPUSH
2554: CALL_OW 74
2558: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2559: LD_VAR 0 8
2563: PPUSH
2564: CALL_OW 110
2568: PUSH
2569: LD_INT 7
2571: EQUAL
2572: IFFALSE 2590
// filter := filter diff t ;
2574: LD_ADDR_VAR 0 7
2578: PUSH
2579: LD_VAR 0 7
2583: PUSH
2584: LD_VAR 0 8
2588: DIFF
2589: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2590: LD_VAR 0 8
2594: PPUSH
2595: CALL_OW 110
2599: PUSH
2600: LD_INT 7
2602: NONEQUAL
2603: PUSH
2604: LD_VAR 0 7
2608: NOT
2609: OR
2610: IFFALSE 2539
// if GetTag ( t ) <> 7 then
2612: LD_VAR 0 8
2616: PPUSH
2617: CALL_OW 110
2621: PUSH
2622: LD_INT 7
2624: NONEQUAL
2625: IFFALSE 2655
// begin SetTag ( t , 7 ) ;
2627: LD_VAR 0 8
2631: PPUSH
2632: LD_INT 7
2634: PPUSH
2635: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2639: LD_VAR 0 1
2643: PPUSH
2644: LD_VAR 0 8
2648: PPUSH
2649: CALL_OW 120
// end else
2653: GO 2674
// ComMoveXY ( un , x , y ) ;
2655: LD_VAR 0 1
2659: PPUSH
2660: LD_VAR 0 3
2664: PPUSH
2665: LD_VAR 0 4
2669: PPUSH
2670: CALL_OW 111
// end ; end ;
2674: LD_VAR 0 5
2678: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2679: LD_INT 0
2681: PPUSH
2682: PPUSH
2683: PPUSH
// if not base then
2684: LD_VAR 0 1
2688: NOT
2689: IFFALSE 2693
// exit ;
2691: GO 2751
// tmp := GetEnergy ( GetBase ( base ) ) ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_VAR 0 1
2702: PPUSH
2703: CALL_OW 274
2707: PPUSH
2708: CALL_OW 278
2712: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2713: LD_VAR 0 4
2717: PUSH
2718: LD_INT 1
2720: ARRAY
2721: PUSH
2722: LD_VAR 0 4
2726: PUSH
2727: LD_INT 4
2729: ARRAY
2730: GREATER
2731: IFFALSE 2743
// result := true else
2733: LD_ADDR_VAR 0 2
2737: PUSH
2738: LD_INT 1
2740: ST_TO_ADDR
2741: GO 2751
// result := false ;
2743: LD_ADDR_VAR 0 2
2747: PUSH
2748: LD_INT 0
2750: ST_TO_ADDR
// end ;
2751: LD_VAR 0 2
2755: RET
// export function FilterPeople ( side ) ; begin
2756: LD_INT 0
2758: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2759: LD_ADDR_VAR 0 2
2763: PUSH
2764: LD_INT 22
2766: PUSH
2767: LD_VAR 0 1
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: PUSH
2776: LD_INT 21
2778: PUSH
2779: LD_INT 1
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PPUSH
2790: CALL_OW 69
2794: ST_TO_ADDR
// end ;
2795: LD_VAR 0 2
2799: RET
// export function FilterDrivers ( side ) ; begin
2800: LD_INT 0
2802: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2803: LD_ADDR_VAR 0 2
2807: PUSH
2808: LD_INT 22
2810: PUSH
2811: LD_VAR 0 1
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 3
2822: PUSH
2823: LD_INT 56
2825: PUSH
2826: EMPTY
2827: LIST
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PPUSH
2837: CALL_OW 69
2841: ST_TO_ADDR
// end ;
2842: LD_VAR 0 2
2846: RET
// export function FilterPeopleArea ( side , area ) ; begin
2847: LD_INT 0
2849: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2850: LD_ADDR_VAR 0 3
2854: PUSH
2855: LD_VAR 0 2
2859: PPUSH
2860: LD_INT 22
2862: PUSH
2863: LD_INT 1
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: PUSH
2870: LD_INT 21
2872: PUSH
2873: LD_INT 1
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PPUSH
2884: CALL_OW 70
2888: ST_TO_ADDR
// end ;
2889: LD_VAR 0 3
2893: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2894: LD_INT 0
2896: PPUSH
2897: PPUSH
2898: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2899: LD_ADDR_VAR 0 5
2903: PUSH
2904: LD_VAR 0 2
2908: PPUSH
2909: LD_INT 22
2911: PUSH
2912: LD_INT 1
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: LD_INT 21
2921: PUSH
2922: LD_INT 2
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 3
2931: PUSH
2932: LD_INT 58
2934: PUSH
2935: EMPTY
2936: LIST
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PPUSH
2947: CALL_OW 70
2951: ST_TO_ADDR
// result := [ ] ;
2952: LD_ADDR_VAR 0 3
2956: PUSH
2957: EMPTY
2958: ST_TO_ADDR
// if not tmp then
2959: LD_VAR 0 5
2963: NOT
2964: IFFALSE 2968
// exit ;
2966: GO 3020
// for i in tmp do
2968: LD_ADDR_VAR 0 4
2972: PUSH
2973: LD_VAR 0 5
2977: PUSH
2978: FOR_IN
2979: IFFALSE 3004
// result := result union IsDrivenBy ( i ) ;
2981: LD_ADDR_VAR 0 3
2985: PUSH
2986: LD_VAR 0 3
2990: PUSH
2991: LD_VAR 0 4
2995: PPUSH
2996: CALL_OW 311
3000: UNION
3001: ST_TO_ADDR
3002: GO 2978
3004: POP
3005: POP
// result := result diff 0 ;
3006: LD_ADDR_VAR 0 3
3010: PUSH
3011: LD_VAR 0 3
3015: PUSH
3016: LD_INT 0
3018: DIFF
3019: ST_TO_ADDR
// end ;
3020: LD_VAR 0 3
3024: RET
// export function FilterBuildings ( side ) ; begin
3025: LD_INT 0
3027: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 22
3035: PUSH
3036: LD_VAR 0 1
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 21
3047: PUSH
3048: LD_INT 3
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PPUSH
3059: CALL_OW 69
3063: ST_TO_ADDR
// end ;
3064: LD_VAR 0 2
3068: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
3069: LD_INT 0
3071: PPUSH
3072: PPUSH
3073: PPUSH
3074: PPUSH
// uc_side = 0 ;
3075: LD_ADDR_OWVAR 20
3079: PUSH
3080: LD_INT 0
3082: ST_TO_ADDR
// uc_nation = 0 ;
3083: LD_ADDR_OWVAR 21
3087: PUSH
3088: LD_INT 0
3090: ST_TO_ADDR
// nat_area := wildArea ;
3091: LD_ADDR_VAR 0 4
3095: PUSH
3096: LD_INT 3
3098: ST_TO_ADDR
// InitHc ;
3099: CALL_OW 19
// for i = 1 to 4 do
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: DOUBLE
3109: LD_INT 1
3111: DEC
3112: ST_TO_ADDR
3113: LD_INT 4
3115: PUSH
3116: FOR_TO
3117: IFFALSE 3172
// begin hc_class = 18 ;
3119: LD_ADDR_OWVAR 28
3123: PUSH
3124: LD_INT 18
3126: ST_TO_ADDR
// hc_gallery =  ;
3127: LD_ADDR_OWVAR 33
3131: PUSH
3132: LD_STRING 
3134: ST_TO_ADDR
// hc_face_number = 1 ;
3135: LD_ADDR_OWVAR 34
3139: PUSH
3140: LD_INT 1
3142: ST_TO_ADDR
// animal := CreateHuman ;
3143: LD_ADDR_VAR 0 3
3147: PUSH
3148: CALL_OW 44
3152: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_VAR 0 4
3162: PPUSH
3163: LD_INT 0
3165: PPUSH
3166: CALL_OW 49
// end ;
3170: GO 3116
3172: POP
3173: POP
// for i = 1 to 6 do
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: DOUBLE
3180: LD_INT 1
3182: DEC
3183: ST_TO_ADDR
3184: LD_INT 6
3186: PUSH
3187: FOR_TO
3188: IFFALSE 3259
// begin hc_class = class_tiger ;
3190: LD_ADDR_OWVAR 28
3194: PUSH
3195: LD_INT 14
3197: ST_TO_ADDR
// hc_gallery =  ;
3198: LD_ADDR_OWVAR 33
3202: PUSH
3203: LD_STRING 
3205: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3206: LD_ADDR_OWVAR 35
3210: PUSH
3211: LD_INT 0
3213: PPUSH
3214: LD_INT 10
3216: PPUSH
3217: CALL_OW 12
3221: ST_TO_ADDR
// hc_face_number = 3 ;
3222: LD_ADDR_OWVAR 34
3226: PUSH
3227: LD_INT 3
3229: ST_TO_ADDR
// animal := CreateHuman ;
3230: LD_ADDR_VAR 0 3
3234: PUSH
3235: CALL_OW 44
3239: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3240: LD_VAR 0 3
3244: PPUSH
3245: LD_VAR 0 4
3249: PPUSH
3250: LD_INT 0
3252: PPUSH
3253: CALL_OW 49
// end ;
3257: GO 3187
3259: POP
3260: POP
// for i = 1 to 2 do
3261: LD_ADDR_VAR 0 2
3265: PUSH
3266: DOUBLE
3267: LD_INT 1
3269: DEC
3270: ST_TO_ADDR
3271: LD_INT 2
3273: PUSH
3274: FOR_TO
3275: IFFALSE 3338
// begin hc_class = 21 ;
3277: LD_ADDR_OWVAR 28
3281: PUSH
3282: LD_INT 21
3284: ST_TO_ADDR
// hc_gallery =  ;
3285: LD_ADDR_OWVAR 33
3289: PUSH
3290: LD_STRING 
3292: ST_TO_ADDR
// hc_agressivity = 0 ;
3293: LD_ADDR_OWVAR 35
3297: PUSH
3298: LD_INT 0
3300: ST_TO_ADDR
// hc_face_number = 5 ;
3301: LD_ADDR_OWVAR 34
3305: PUSH
3306: LD_INT 5
3308: ST_TO_ADDR
// animal := CreateHuman ;
3309: LD_ADDR_VAR 0 3
3313: PUSH
3314: CALL_OW 44
3318: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3319: LD_VAR 0 3
3323: PPUSH
3324: LD_VAR 0 4
3328: PPUSH
3329: LD_INT 0
3331: PPUSH
3332: CALL_OW 49
// end ;
3336: GO 3274
3338: POP
3339: POP
// for i = 1 to 6 do
3340: LD_ADDR_VAR 0 2
3344: PUSH
3345: DOUBLE
3346: LD_INT 1
3348: DEC
3349: ST_TO_ADDR
3350: LD_INT 6
3352: PUSH
3353: FOR_TO
3354: IFFALSE 3409
// begin hc_class = 13 ;
3356: LD_ADDR_OWVAR 28
3360: PUSH
3361: LD_INT 13
3363: ST_TO_ADDR
// hc_gallery =  ;
3364: LD_ADDR_OWVAR 33
3368: PUSH
3369: LD_STRING 
3371: ST_TO_ADDR
// hc_face_number = 4 ;
3372: LD_ADDR_OWVAR 34
3376: PUSH
3377: LD_INT 4
3379: ST_TO_ADDR
// animal := CreateHuman ;
3380: LD_ADDR_VAR 0 3
3384: PUSH
3385: CALL_OW 44
3389: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_VAR 0 4
3399: PPUSH
3400: LD_INT 0
3402: PPUSH
3403: CALL_OW 49
// end ;
3407: GO 3353
3409: POP
3410: POP
// for i = 1 to 2 do
3411: LD_ADDR_VAR 0 2
3415: PUSH
3416: DOUBLE
3417: LD_INT 1
3419: DEC
3420: ST_TO_ADDR
3421: LD_INT 2
3423: PUSH
3424: FOR_TO
3425: IFFALSE 3484
// begin hc_class = 20 ;
3427: LD_ADDR_OWVAR 28
3431: PUSH
3432: LD_INT 20
3434: ST_TO_ADDR
// hc_gallery =  ;
3435: LD_ADDR_OWVAR 33
3439: PUSH
3440: LD_STRING 
3442: ST_TO_ADDR
// hc_face_number = 2 ;
3443: LD_ADDR_OWVAR 34
3447: PUSH
3448: LD_INT 2
3450: ST_TO_ADDR
// animal := CreateHuman ;
3451: LD_ADDR_VAR 0 3
3455: PUSH
3456: CALL_OW 44
3460: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_INT 101
3468: PPUSH
3469: LD_INT 37
3471: PPUSH
3472: LD_INT 3
3474: PPUSH
3475: LD_INT 0
3477: PPUSH
3478: CALL_OW 50
// end ;
3482: GO 3424
3484: POP
3485: POP
// for i = 1 to 1 do
3486: LD_ADDR_VAR 0 2
3490: PUSH
3491: DOUBLE
3492: LD_INT 1
3494: DEC
3495: ST_TO_ADDR
3496: LD_INT 1
3498: PUSH
3499: FOR_TO
3500: IFFALSE 3547
// begin vc_chassis := 31 ;
3502: LD_ADDR_OWVAR 37
3506: PUSH
3507: LD_INT 31
3509: ST_TO_ADDR
// vc_control := control_rider ;
3510: LD_ADDR_OWVAR 38
3514: PUSH
3515: LD_INT 4
3517: ST_TO_ADDR
// animal := CreateVehicle ;
3518: LD_ADDR_VAR 0 3
3522: PUSH
3523: CALL_OW 45
3527: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3528: LD_VAR 0 3
3532: PPUSH
3533: LD_VAR 0 4
3537: PPUSH
3538: LD_INT 0
3540: PPUSH
3541: CALL_OW 49
// end ;
3545: GO 3499
3547: POP
3548: POP
// end ;
3549: LD_VAR 0 1
3553: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3554: LD_INT 0
3556: PPUSH
3557: PPUSH
3558: PPUSH
3559: PPUSH
// result := [ ] ;
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: EMPTY
3566: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3567: LD_ADDR_VAR 0 4
3571: PUSH
3572: LD_INT 81
3574: PUSH
3575: LD_VAR 0 1
3579: PPUSH
3580: CALL_OW 255
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: LD_INT 91
3591: PUSH
3592: LD_VAR 0 1
3596: PUSH
3597: LD_INT 15
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 2
3607: PUSH
3608: LD_INT 30
3610: PUSH
3611: LD_INT 32
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: PUSH
3618: LD_INT 30
3620: PUSH
3621: LD_INT 33
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PUSH
3628: EMPTY
3629: LIST
3630: LIST
3631: LIST
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: LIST
3637: PPUSH
3638: CALL_OW 69
3642: ST_TO_ADDR
// if not tmp then
3643: LD_VAR 0 4
3647: NOT
3648: IFFALSE 3652
// exit ;
3650: GO 3721
// for i in tmp do
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: LD_VAR 0 4
3661: PUSH
3662: FOR_IN
3663: IFFALSE 3719
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3665: LD_ADDR_VAR 0 5
3669: PUSH
3670: LD_VAR 0 3
3674: PPUSH
3675: CALL_OW 274
3679: PPUSH
3680: CALL_OW 278
3684: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3685: LD_VAR 0 5
3689: PUSH
3690: LD_INT 4
3692: ARRAY
3693: PUSH
3694: LD_VAR 0 5
3698: PUSH
3699: LD_INT 1
3701: ARRAY
3702: GREATER
3703: IFFALSE 3717
// begin result := i ;
3705: LD_ADDR_VAR 0 2
3709: PUSH
3710: LD_VAR 0 3
3714: ST_TO_ADDR
// break ;
3715: GO 3719
// end ; end ;
3717: GO 3662
3719: POP
3720: POP
// end ; end_of_file
3721: LD_VAR 0 2
3725: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3726: LD_INT 0
3728: PPUSH
3729: PPUSH
3730: PPUSH
3731: PPUSH
3732: PPUSH
3733: PPUSH
// uc_side := 1 ;
3734: LD_ADDR_OWVAR 20
3738: PUSH
3739: LD_INT 1
3741: ST_TO_ADDR
// uc_nation := 1 ;
3742: LD_ADDR_OWVAR 21
3746: PUSH
3747: LD_INT 1
3749: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3750: LD_ADDR_EXP 9
3754: PUSH
3755: LD_STRING JMM
3757: PPUSH
3758: LD_EXP 1
3762: NOT
3763: PPUSH
3764: CALL 500 0 2
3768: ST_TO_ADDR
// team := [ JMM ] ;
3769: LD_ADDR_VAR 0 3
3773: PUSH
3774: LD_EXP 9
3778: PUSH
3779: EMPTY
3780: LIST
3781: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3782: LD_STRING BrownIn07
3784: PPUSH
3785: LD_EXP 1
3789: PPUSH
3790: CALL_OW 30
3794: IFFALSE 3815
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3796: LD_ADDR_EXP 10
3800: PUSH
3801: LD_STRING Brown
3803: PPUSH
3804: LD_EXP 1
3808: NOT
3809: PPUSH
3810: CALL 500 0 2
3814: ST_TO_ADDR
// if Brown then
3815: LD_EXP 10
3819: IFFALSE 3837
// team := team ^ Brown ;
3821: LD_ADDR_VAR 0 3
3825: PUSH
3826: LD_VAR 0 3
3830: PUSH
3831: LD_EXP 10
3835: ADD
3836: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3837: LD_STRING DonaldsonIn07
3839: PPUSH
3840: LD_EXP 1
3844: PPUSH
3845: CALL_OW 30
3849: IFFALSE 3870
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3851: LD_ADDR_EXP 11
3855: PUSH
3856: LD_STRING Donaldson
3858: PPUSH
3859: LD_EXP 1
3863: NOT
3864: PPUSH
3865: CALL 500 0 2
3869: ST_TO_ADDR
// if Donaldson then
3870: LD_EXP 11
3874: IFFALSE 3892
// team := team ^ Donaldson ;
3876: LD_ADDR_VAR 0 3
3880: PUSH
3881: LD_VAR 0 3
3885: PUSH
3886: LD_EXP 11
3890: ADD
3891: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3892: LD_STRING BobbyIn07
3894: PPUSH
3895: LD_EXP 1
3899: PPUSH
3900: CALL_OW 30
3904: IFFALSE 3925
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3906: LD_ADDR_EXP 12
3910: PUSH
3911: LD_STRING Bobby
3913: PPUSH
3914: LD_EXP 1
3918: NOT
3919: PPUSH
3920: CALL 500 0 2
3924: ST_TO_ADDR
// if Bobby then
3925: LD_EXP 12
3929: IFFALSE 3947
// team := team ^ Bobby ;
3931: LD_ADDR_VAR 0 3
3935: PUSH
3936: LD_VAR 0 3
3940: PUSH
3941: LD_EXP 12
3945: ADD
3946: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3947: LD_STRING CyrusIn07
3949: PPUSH
3950: LD_EXP 1
3954: PPUSH
3955: CALL_OW 30
3959: IFFALSE 3980
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3961: LD_ADDR_EXP 13
3965: PUSH
3966: LD_STRING Cyrus
3968: PPUSH
3969: LD_EXP 1
3973: NOT
3974: PPUSH
3975: CALL 500 0 2
3979: ST_TO_ADDR
// if Cyrus then
3980: LD_EXP 13
3984: IFFALSE 4002
// team := team ^ Cyrus ;
3986: LD_ADDR_VAR 0 3
3990: PUSH
3991: LD_VAR 0 3
3995: PUSH
3996: LD_EXP 13
4000: ADD
4001: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
4002: LD_STRING LisaIn07
4004: PPUSH
4005: LD_EXP 1
4009: PPUSH
4010: CALL_OW 30
4014: IFFALSE 4035
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
4016: LD_ADDR_EXP 14
4020: PUSH
4021: LD_STRING Lisa
4023: PPUSH
4024: LD_EXP 1
4028: NOT
4029: PPUSH
4030: CALL 500 0 2
4034: ST_TO_ADDR
// if Lisa then
4035: LD_EXP 14
4039: IFFALSE 4057
// team := team ^ Lisa ;
4041: LD_ADDR_VAR 0 3
4045: PUSH
4046: LD_VAR 0 3
4050: PUSH
4051: LD_EXP 14
4055: ADD
4056: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
4057: LD_STRING GladstoneIn07
4059: PPUSH
4060: LD_EXP 1
4064: PPUSH
4065: CALL_OW 30
4069: IFFALSE 4090
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
4071: LD_ADDR_EXP 16
4075: PUSH
4076: LD_STRING Gladstone
4078: PPUSH
4079: LD_EXP 1
4083: NOT
4084: PPUSH
4085: CALL 500 0 2
4089: ST_TO_ADDR
// if Gladstone then
4090: LD_EXP 16
4094: IFFALSE 4112
// team := team ^ Gladstone ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: LD_VAR 0 3
4105: PUSH
4106: LD_EXP 16
4110: ADD
4111: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
4112: LD_STRING KhatamIn07
4114: PPUSH
4115: LD_EXP 1
4119: PPUSH
4120: CALL_OW 30
4124: IFFALSE 4145
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
4126: LD_ADDR_EXP 17
4130: PUSH
4131: LD_STRING Khatam
4133: PPUSH
4134: LD_EXP 1
4138: NOT
4139: PPUSH
4140: CALL 500 0 2
4144: ST_TO_ADDR
// if Khatam then
4145: LD_EXP 17
4149: IFFALSE 4167
// team := team ^ Khatam ;
4151: LD_ADDR_VAR 0 3
4155: PUSH
4156: LD_VAR 0 3
4160: PUSH
4161: LD_EXP 17
4165: ADD
4166: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4167: LD_ADDR_VAR 0 4
4171: PUSH
4172: LD_STRING 07_others
4174: PPUSH
4175: CALL_OW 31
4179: ST_TO_ADDR
// if others then
4180: LD_VAR 0 4
4184: IFFALSE 4202
// team := team ^ others ;
4186: LD_ADDR_VAR 0 3
4190: PUSH
4191: LD_VAR 0 3
4195: PUSH
4196: LD_VAR 0 4
4200: ADD
4201: ST_TO_ADDR
// if debug then
4202: LD_EXP 1
4206: IFFALSE 4280
// begin InitHc ;
4208: CALL_OW 19
// for i = 1 to 4 do
4212: LD_ADDR_VAR 0 2
4216: PUSH
4217: DOUBLE
4218: LD_INT 1
4220: DEC
4221: ST_TO_ADDR
4222: LD_INT 4
4224: PUSH
4225: FOR_TO
4226: IFFALSE 4278
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4228: LD_INT 0
4230: PPUSH
4231: LD_INT 1
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 1
4243: PPUSH
4244: LD_INT 2
4246: PPUSH
4247: CALL_OW 12
4251: ARRAY
4252: PPUSH
4253: LD_INT 4
4255: PPUSH
4256: CALL_OW 380
// team := team ^ CreateHuman ;
4260: LD_ADDR_VAR 0 3
4264: PUSH
4265: LD_VAR 0 3
4269: PUSH
4270: CALL_OW 44
4274: ADD
4275: ST_TO_ADDR
// end ;
4276: GO 4225
4278: POP
4279: POP
// end ; m := 0 ;
4280: LD_ADDR_VAR 0 6
4284: PUSH
4285: LD_INT 0
4287: ST_TO_ADDR
// for i in team do
4288: LD_ADDR_VAR 0 2
4292: PUSH
4293: LD_VAR 0 3
4297: PUSH
4298: FOR_IN
4299: IFFALSE 4506
// if GetClass ( i ) = 3 then
4301: LD_VAR 0 2
4305: PPUSH
4306: CALL_OW 257
4310: PUSH
4311: LD_INT 3
4313: EQUAL
4314: IFFALSE 4462
// begin m := m + 1 ;
4316: LD_ADDR_VAR 0 6
4320: PUSH
4321: LD_VAR 0 6
4325: PUSH
4326: LD_INT 1
4328: PLUS
4329: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4330: LD_ADDR_VAR 0 5
4334: PUSH
4335: LD_INT 1
4337: PPUSH
4338: LD_INT 1
4340: PPUSH
4341: LD_INT 2
4343: PUSH
4344: LD_INT 3
4346: PUSH
4347: LD_INT 2
4349: PUSH
4350: LD_INT 1
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: LIST
4357: LIST
4358: PUSH
4359: LD_VAR 0 6
4363: PUSH
4364: LD_INT 4
4366: MOD
4367: PUSH
4368: LD_INT 1
4370: PLUS
4371: ARRAY
4372: PPUSH
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 1
4378: PPUSH
4379: LD_INT 4
4381: PUSH
4382: LD_INT 5
4384: PUSH
4385: LD_INT 3
4387: PUSH
4388: LD_INT 11
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_VAR 0 6
4401: PUSH
4402: LD_INT 4
4404: MOD
4405: PUSH
4406: LD_INT 1
4408: PLUS
4409: ARRAY
4410: PPUSH
4411: LD_INT 60
4413: PPUSH
4414: CALL 563 0 7
4418: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4419: LD_VAR 0 5
4423: PPUSH
4424: LD_INT 2
4426: PPUSH
4427: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4431: LD_VAR 0 5
4435: PPUSH
4436: LD_INT 1
4438: PPUSH
4439: LD_INT 0
4441: PPUSH
4442: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_VAR 0 5
4455: PPUSH
4456: CALL_OW 52
// end else
4460: GO 4504
// begin if GetClass ( i ) = 2 then
4462: LD_VAR 0 2
4466: PPUSH
4467: CALL_OW 257
4471: PUSH
4472: LD_INT 2
4474: EQUAL
4475: IFFALSE 4489
// SetClass ( i , 1 ) ;
4477: LD_VAR 0 2
4481: PPUSH
4482: LD_INT 1
4484: PPUSH
4485: CALL_OW 336
// PlaceUnitArea ( i , startArea , false ) ;
4489: LD_VAR 0 2
4493: PPUSH
4494: LD_INT 1
4496: PPUSH
4497: LD_INT 0
4499: PPUSH
4500: CALL_OW 49
// end ;
4504: GO 4298
4506: POP
4507: POP
// uc_side := 4 ;
4508: LD_ADDR_OWVAR 20
4512: PUSH
4513: LD_INT 4
4515: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4516: LD_ADDR_EXP 19
4520: PUSH
4521: LD_STRING Harisson
4523: PPUSH
4524: LD_INT 0
4526: PPUSH
4527: CALL 500 0 2
4531: ST_TO_ADDR
// PrepareScout ;
4532: CALL 4541 0 0
// end ;
4536: LD_VAR 0 1
4540: RET
// function PrepareScout ; var ape ; begin
4541: LD_INT 0
4543: PPUSH
4544: PPUSH
// uc_side := 4 ;
4545: LD_ADDR_OWVAR 20
4549: PUSH
4550: LD_INT 4
4552: ST_TO_ADDR
// uc_nation := 1 ;
4553: LD_ADDR_OWVAR 21
4557: PUSH
4558: LD_INT 1
4560: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4561: LD_STRING FrankIn06
4563: PPUSH
4564: LD_INT 0
4566: PPUSH
4567: CALL_OW 30
4571: IFFALSE 4588
// Frank := CreateCharacter ( 06c_Frank ) else
4573: LD_ADDR_EXP 15
4577: PUSH
4578: LD_STRING 06c_Frank
4580: PPUSH
4581: CALL_OW 34
4585: ST_TO_ADDR
4586: GO 4628
// if LoadVariable ( FrankInDelta , 0 ) then
4588: LD_STRING FrankInDelta
4590: PPUSH
4591: LD_INT 0
4593: PPUSH
4594: CALL_OW 30
4598: IFFALSE 4615
// Frank := CreateCharacter ( 05_Frank ) else
4600: LD_ADDR_EXP 15
4604: PUSH
4605: LD_STRING 05_Frank
4607: PPUSH
4608: CALL_OW 34
4612: ST_TO_ADDR
4613: GO 4628
// Frank := CreateCharacter ( 04_Frank ) ;
4615: LD_ADDR_EXP 15
4619: PUSH
4620: LD_STRING 04_Frank
4622: PPUSH
4623: CALL_OW 34
4627: ST_TO_ADDR
// if Frank then
4628: LD_EXP 15
4632: IFFALSE 4765
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4634: LD_EXP 15
4638: PPUSH
4639: LD_INT 2
4641: PPUSH
4642: LD_INT 0
4644: PPUSH
4645: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4649: LD_EXP 15
4653: PPUSH
4654: LD_INT 1
4656: PPUSH
4657: CALL_OW 336
// uc_side := 0 ;
4661: LD_ADDR_OWVAR 20
4665: PUSH
4666: LD_INT 0
4668: ST_TO_ADDR
// uc_nation := 0 ;
4669: LD_ADDR_OWVAR 21
4673: PUSH
4674: LD_INT 0
4676: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4677: LD_INT 0
4679: PPUSH
4680: LD_INT 12
4682: PPUSH
4683: LD_INT 0
4685: PPUSH
4686: CALL_OW 380
// ape := CreateHuman ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: CALL_OW 44
4699: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4700: LD_VAR 0 2
4704: PPUSH
4705: LD_EXP 15
4709: PPUSH
4710: CALL_OW 250
4714: PPUSH
4715: LD_EXP 15
4719: PPUSH
4720: CALL_OW 251
4724: PPUSH
4725: LD_INT 5
4727: PPUSH
4728: LD_INT 0
4730: PPUSH
4731: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4735: LD_VAR 0 2
4739: PPUSH
4740: LD_EXP 15
4744: PPUSH
4745: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4749: LD_EXP 15
4753: PPUSH
4754: LD_VAR 0 2
4758: PPUSH
4759: CALL_OW 119
// exit ;
4763: GO 4805
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4765: LD_ADDR_EXP 18
4769: PUSH
4770: LD_STRING Yamoko
4772: PPUSH
4773: LD_INT 0
4775: PPUSH
4776: CALL 500 0 2
4780: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4781: LD_EXP 18
4785: PPUSH
4786: LD_INT 2
4788: PPUSH
4789: LD_INT 0
4791: PPUSH
4792: CALL_OW 49
// ComHold ( Kikuchi ) ;
4796: LD_EXP 18
4800: PPUSH
4801: CALL_OW 140
// end ; end_of_file
4805: LD_VAR 0 1
4809: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4810: LD_INT 0
4812: PPUSH
4813: PPUSH
4814: PPUSH
4815: PPUSH
4816: PPUSH
4817: PPUSH
4818: PPUSH
4819: PPUSH
4820: PPUSH
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
4826: PPUSH
4827: PPUSH
// ru_rebuild_list := [ ] ;
4828: LD_ADDR_EXP 20
4832: PUSH
4833: EMPTY
4834: ST_TO_ADDR
// uc_side := 3 ;
4835: LD_ADDR_OWVAR 20
4839: PUSH
4840: LD_INT 3
4842: ST_TO_ADDR
// uc_nation := 3 ;
4843: LD_ADDR_OWVAR 21
4847: PUSH
4848: LD_INT 3
4850: ST_TO_ADDR
// if Difficulty > 1 then
4851: LD_OWVAR 67
4855: PUSH
4856: LD_INT 1
4858: GREATER
4859: IFFALSE 4995
// begin bc_type := b_breastwork ;
4861: LD_ADDR_OWVAR 42
4865: PUSH
4866: LD_INT 31
4868: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4869: LD_INT 78
4871: PPUSH
4872: LD_INT 74
4874: PPUSH
4875: LD_INT 2
4877: PPUSH
4878: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4882: LD_INT 171
4884: PPUSH
4885: LD_INT 193
4887: PPUSH
4888: LD_INT 4
4890: PPUSH
4891: CALL_OW 47
// bc_type := b_turret ;
4895: LD_ADDR_OWVAR 42
4899: PUSH
4900: LD_INT 33
4902: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4903: LD_INT 129
4905: PPUSH
4906: LD_INT 96
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 47
// if Difficulty > 2 then
4916: LD_OWVAR 67
4920: PUSH
4921: LD_INT 2
4923: GREATER
4924: IFFALSE 4995
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4926: LD_INT 83
4928: PPUSH
4929: LD_INT 141
4931: PPUSH
4932: CALL_OW 428
4936: PPUSH
4937: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4941: LD_INT 78
4943: PPUSH
4944: LD_INT 133
4946: PPUSH
4947: CALL_OW 428
4951: PPUSH
4952: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4956: LD_INT 83
4958: PPUSH
4959: LD_INT 141
4961: PPUSH
4962: LD_INT 2
4964: PPUSH
4965: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4969: LD_INT 78
4971: PPUSH
4972: LD_INT 133
4974: PPUSH
4975: LD_INT 2
4977: PPUSH
4978: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4982: LD_INT 145
4984: PPUSH
4985: LD_INT 112
4987: PPUSH
4988: LD_INT 3
4990: PPUSH
4991: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4995: LD_ADDR_VAR 0 9
4999: PUSH
5000: LD_INT 22
5002: PUSH
5003: LD_INT 3
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: LD_INT 2
5012: PUSH
5013: LD_INT 30
5015: PUSH
5016: LD_INT 0
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 30
5025: PUSH
5026: LD_INT 1
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: LIST
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PPUSH
5042: CALL_OW 69
5046: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
5047: LD_ADDR_VAR 0 10
5051: PUSH
5052: LD_INT 22
5054: PUSH
5055: LD_INT 3
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 6
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 30
5077: PUSH
5078: LD_INT 7
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: LD_INT 30
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PPUSH
5105: CALL_OW 69
5109: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
5110: LD_ADDR_VAR 0 11
5114: PUSH
5115: LD_INT 22
5117: PUSH
5118: LD_INT 3
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 30
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
5144: LD_ADDR_VAR 0 12
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 30
5161: PUSH
5162: LD_INT 31
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PPUSH
5173: CALL_OW 69
5177: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5178: LD_ADDR_VAR 0 13
5182: PUSH
5183: LD_INT 22
5185: PUSH
5186: LD_INT 3
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 30
5195: PUSH
5196: LD_INT 32
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL_OW 69
5211: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5212: LD_ADDR_VAR 0 14
5216: PUSH
5217: LD_INT 22
5219: PUSH
5220: LD_INT 3
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: PUSH
5227: LD_INT 30
5229: PUSH
5230: LD_INT 33
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PUSH
5237: EMPTY
5238: LIST
5239: LIST
5240: PPUSH
5241: CALL_OW 69
5245: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5246: LD_ADDR_VAR 0 15
5250: PUSH
5251: LD_INT 42
5253: PUSH
5254: LD_INT 5
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 43
5263: PUSH
5264: LD_INT 50
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 44
5273: PUSH
5274: LD_INT 30
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 46
5283: PUSH
5284: LD_INT 15
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5297: LD_ADDR_VAR 0 16
5301: PUSH
5302: LD_INT 0
5304: PUSH
5305: LD_INT 4
5307: PUSH
5308: LD_INT 6
5310: PUSH
5311: LD_INT 3
5313: PUSH
5314: EMPTY
5315: LIST
5316: LIST
5317: LIST
5318: LIST
5319: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_INT 4
5327: PUSH
5328: LD_INT 5
5330: PUSH
5331: LD_INT 6
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: LIST
5338: PUSH
5339: LD_OWVAR 67
5343: ARRAY
5344: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5345: LD_INT 16
5347: PPUSH
5348: LD_STRING am_tukh
5350: PPUSH
5351: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 21
5362: PUSH
5363: LD_INT 3
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PPUSH
5370: CALL_OW 69
5374: PUSH
5375: FOR_IN
5376: IFFALSE 5409
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_INT 4
5385: PUSH
5386: LD_INT 5
5388: PUSH
5389: LD_INT 6
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_OWVAR 67
5401: ARRAY
5402: PPUSH
5403: CALL_OW 241
5407: GO 5375
5409: POP
5410: POP
// for i in dep_list do
5411: LD_ADDR_VAR 0 2
5415: PUSH
5416: LD_VAR 0 9
5420: PUSH
5421: FOR_IN
5422: IFFALSE 5466
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5424: LD_VAR 0 2
5428: PPUSH
5429: CALL_OW 274
5433: PPUSH
5434: LD_INT 1
5436: PPUSH
5437: LD_INT 1000
5439: PPUSH
5440: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 274
5453: PPUSH
5454: LD_INT 2
5456: PPUSH
5457: LD_INT 1000
5459: PPUSH
5460: CALL_OW 277
// end ;
5464: GO 5421
5466: POP
5467: POP
// InitHc ;
5468: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5472: LD_ADDR_VAR 0 8
5476: PUSH
5477: LD_VAR 0 13
5481: PUSH
5482: LD_INT 45
5484: PUSH
5485: LD_INT 60
5487: PUSH
5488: LD_INT 75
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: MUL
5502: PUSH
5503: LD_INT 100
5505: DIV
5506: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5507: LD_ADDR_VAR 0 16
5511: PUSH
5512: LD_VAR 0 16
5516: PPUSH
5517: LD_INT 1
5519: PPUSH
5520: LD_VAR 0 8
5524: PPUSH
5525: CALL_OW 1
5529: ST_TO_ADDR
// tmp := [ ] ;
5530: LD_ADDR_VAR 0 8
5534: PUSH
5535: EMPTY
5536: ST_TO_ADDR
// for i in bunker_list do
5537: LD_ADDR_VAR 0 2
5541: PUSH
5542: LD_VAR 0 13
5546: PUSH
5547: FOR_IN
5548: IFFALSE 5644
// if i mod 10 + 1 < tmp then
5550: LD_VAR 0 2
5554: PUSH
5555: LD_INT 10
5557: MOD
5558: PUSH
5559: LD_INT 1
5561: PLUS
5562: PUSH
5563: LD_VAR 0 8
5567: LESS
5568: IFFALSE 5613
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5570: LD_ADDR_VAR 0 8
5574: PUSH
5575: LD_VAR 0 8
5579: PPUSH
5580: LD_VAR 0 2
5584: PUSH
5585: LD_INT 3
5587: PPUSH
5588: LD_INT 5
5590: PPUSH
5591: CALL_OW 12
5595: MOD
5596: PUSH
5597: LD_INT 1
5599: PLUS
5600: PPUSH
5601: LD_VAR 0 2
5605: PPUSH
5606: CALL_OW 2
5610: ST_TO_ADDR
5611: GO 5642
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5613: LD_ADDR_VAR 0 8
5617: PUSH
5618: LD_VAR 0 8
5622: PPUSH
5623: LD_VAR 0 8
5627: PUSH
5628: LD_INT 1
5630: PLUS
5631: PPUSH
5632: LD_VAR 0 2
5636: PPUSH
5637: CALL_OW 2
5641: ST_TO_ADDR
5642: GO 5547
5644: POP
5645: POP
// bunker_list := tmp ;
5646: LD_ADDR_VAR 0 13
5650: PUSH
5651: LD_VAR 0 8
5655: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5656: LD_ADDR_VAR 0 2
5660: PUSH
5661: LD_VAR 0 13
5665: PUSH
5666: LD_VAR 0 14
5670: ADD
5671: PUSH
5672: FOR_IN
5673: IFFALSE 5696
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5675: LD_VAR 0 2
5679: PPUSH
5680: LD_VAR 0 2
5684: PPUSH
5685: CALL 977 0 1
5689: PPUSH
5690: CALL_OW 431
5694: GO 5672
5696: POP
5697: POP
// while ( personel_counter [ 1 ] ) do
5698: LD_VAR 0 16
5702: PUSH
5703: LD_INT 1
5705: ARRAY
5706: IFFALSE 5814
// begin i := rand ( 1 , bunker_list ) ;
5708: LD_ADDR_VAR 0 2
5712: PUSH
5713: LD_INT 1
5715: PPUSH
5716: LD_VAR 0 13
5720: PPUSH
5721: CALL_OW 12
5725: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5726: LD_INT 0
5728: PPUSH
5729: LD_INT 1
5731: PPUSH
5732: LD_VAR 0 6
5736: PPUSH
5737: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5741: CALL_OW 44
5745: PPUSH
5746: LD_VAR 0 13
5750: PUSH
5751: LD_VAR 0 2
5755: ARRAY
5756: PPUSH
5757: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5761: LD_ADDR_VAR 0 13
5765: PUSH
5766: LD_VAR 0 13
5770: PPUSH
5771: LD_VAR 0 2
5775: PPUSH
5776: CALL_OW 3
5780: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5781: LD_ADDR_VAR 0 16
5785: PUSH
5786: LD_VAR 0 16
5790: PPUSH
5791: LD_INT 1
5793: PPUSH
5794: LD_VAR 0 16
5798: PUSH
5799: LD_INT 1
5801: ARRAY
5802: PUSH
5803: LD_INT 1
5805: MINUS
5806: PPUSH
5807: CALL_OW 1
5811: ST_TO_ADDR
// end ;
5812: GO 5698
// for i = 1 to personel_counter [ 2 ] do
5814: LD_ADDR_VAR 0 2
5818: PUSH
5819: DOUBLE
5820: LD_INT 1
5822: DEC
5823: ST_TO_ADDR
5824: LD_VAR 0 16
5828: PUSH
5829: LD_INT 2
5831: ARRAY
5832: PUSH
5833: FOR_TO
5834: IFFALSE 5865
// begin PrepareHuman ( false , 2 , skill ) ;
5836: LD_INT 0
5838: PPUSH
5839: LD_INT 2
5841: PPUSH
5842: LD_VAR 0 6
5846: PPUSH
5847: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5851: CALL_OW 44
5855: PPUSH
5856: LD_INT 16
5858: PPUSH
5859: CALL_OW 52
// end ;
5863: GO 5833
5865: POP
5866: POP
// for i = 1 to personel_counter [ 3 ] do
5867: LD_ADDR_VAR 0 2
5871: PUSH
5872: DOUBLE
5873: LD_INT 1
5875: DEC
5876: ST_TO_ADDR
5877: LD_VAR 0 16
5881: PUSH
5882: LD_INT 3
5884: ARRAY
5885: PUSH
5886: FOR_TO
5887: IFFALSE 5934
// begin PrepareHuman ( false , 3 , skill ) ;
5889: LD_INT 0
5891: PPUSH
5892: LD_INT 3
5894: PPUSH
5895: LD_VAR 0 6
5899: PPUSH
5900: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_VAR 0 11
5913: PUSH
5914: LD_VAR 0 2
5918: PUSH
5919: LD_INT 2
5921: MOD
5922: PUSH
5923: LD_INT 1
5925: PLUS
5926: ARRAY
5927: PPUSH
5928: CALL_OW 52
// end ;
5932: GO 5886
5934: POP
5935: POP
// for i = 1 to personel_counter [ 4 ] do
5936: LD_ADDR_VAR 0 2
5940: PUSH
5941: DOUBLE
5942: LD_INT 1
5944: DEC
5945: ST_TO_ADDR
5946: LD_VAR 0 16
5950: PUSH
5951: LD_INT 4
5953: ARRAY
5954: PUSH
5955: FOR_TO
5956: IFFALSE 5993
// begin PrepareHuman ( false , 4 , skill ) ;
5958: LD_INT 0
5960: PPUSH
5961: LD_INT 4
5963: PPUSH
5964: LD_VAR 0 6
5968: PPUSH
5969: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5973: CALL_OW 44
5977: PPUSH
5978: LD_VAR 0 10
5982: PUSH
5983: LD_INT 1
5985: ARRAY
5986: PPUSH
5987: CALL_OW 52
// end ;
5991: GO 5955
5993: POP
5994: POP
// for i in breastworks_list do
5995: LD_ADDR_VAR 0 2
5999: PUSH
6000: LD_VAR 0 12
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6118
// begin r := GetDir ( i ) ;
6008: LD_ADDR_VAR 0 4
6012: PUSH
6013: LD_VAR 0 2
6017: PPUSH
6018: CALL_OW 254
6022: ST_TO_ADDR
// if r > 3 then
6023: LD_VAR 0 4
6027: PUSH
6028: LD_INT 3
6030: GREATER
6031: IFFALSE 6049
// r := r - 3 else
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 4
6042: PUSH
6043: LD_INT 3
6045: MINUS
6046: ST_TO_ADDR
6047: GO 6063
// r := r + 3 ;
6049: LD_ADDR_VAR 0 4
6053: PUSH
6054: LD_VAR 0 4
6058: PUSH
6059: LD_INT 3
6061: PLUS
6062: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6063: LD_INT 0
6065: PPUSH
6066: LD_INT 1
6068: PPUSH
6069: LD_VAR 0 6
6073: PPUSH
6074: CALL_OW 380
// un := CreateHuman ;
6078: LD_ADDR_VAR 0 5
6082: PUSH
6083: CALL_OW 44
6087: ST_TO_ADDR
// SetDir ( un , r ) ;
6088: LD_VAR 0 5
6092: PPUSH
6093: LD_VAR 0 4
6097: PPUSH
6098: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6102: LD_VAR 0 5
6106: PPUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: CALL_OW 52
// end ;
6116: GO 6005
6118: POP
6119: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
6120: LD_ADDR_VAR 0 8
6124: PUSH
6125: LD_INT 22
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: LD_INT 25
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PPUSH
6149: CALL_OW 69
6153: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
6154: LD_ADDR_VAR 0 4
6158: PUSH
6159: LD_INT 4
6161: PUSH
6162: LD_INT 5
6164: PUSH
6165: LD_INT 6
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: LD_OWVAR 67
6177: ARRAY
6178: ST_TO_ADDR
// for i = 1 to r do
6179: LD_ADDR_VAR 0 2
6183: PUSH
6184: DOUBLE
6185: LD_INT 1
6187: DEC
6188: ST_TO_ADDR
6189: LD_VAR 0 4
6193: PUSH
6194: FOR_TO
6195: IFFALSE 6368
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6197: LD_ADDR_VAR 0 5
6201: PUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 3
6207: PPUSH
6208: LD_INT 22
6210: PUSH
6211: LD_INT 22
6213: PUSH
6214: LD_INT 24
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: LD_INT 3
6229: MOD
6230: PUSH
6231: LD_INT 1
6233: PLUS
6234: ARRAY
6235: PPUSH
6236: LD_INT 1
6238: PPUSH
6239: LD_INT 1
6241: PPUSH
6242: LD_INT 43
6244: PUSH
6245: LD_INT 44
6247: PUSH
6248: LD_INT 42
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: LIST
6255: PUSH
6256: LD_VAR 0 2
6260: PUSH
6261: LD_INT 3
6263: MOD
6264: PUSH
6265: LD_INT 1
6267: PLUS
6268: ARRAY
6269: PPUSH
6270: LD_INT 100
6272: PPUSH
6273: CALL 563 0 7
6277: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6278: LD_VAR 0 5
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: LD_INT 5
6288: PPUSH
6289: CALL_OW 12
6293: PPUSH
6294: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_INT 5
6305: PPUSH
6306: LD_INT 0
6308: PPUSH
6309: CALL_OW 49
// if i > tmp - 2 then
6313: LD_VAR 0 2
6317: PUSH
6318: LD_VAR 0 8
6322: PUSH
6323: LD_INT 2
6325: MINUS
6326: GREATER
6327: IFFALSE 6331
// continue ;
6329: GO 6194
// ComExitBuilding ( tmp [ i ] ) ;
6331: LD_VAR 0 8
6335: PUSH
6336: LD_VAR 0 2
6340: ARRAY
6341: PPUSH
6342: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6346: LD_VAR 0 8
6350: PUSH
6351: LD_VAR 0 2
6355: ARRAY
6356: PPUSH
6357: LD_VAR 0 5
6361: PPUSH
6362: CALL_OW 180
// end ;
6366: GO 6194
6368: POP
6369: POP
// end ;
6370: LD_VAR 0 1
6374: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6375: LD_INT 22
6377: PUSH
6378: LD_INT 3
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 25
6387: PUSH
6388: LD_INT 2
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL_OW 69
6403: IFFALSE 7135
6405: GO 6407
6407: DISABLE
6408: LD_INT 0
6410: PPUSH
6411: PPUSH
6412: PPUSH
6413: PPUSH
6414: PPUSH
// begin enable ;
6415: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6416: LD_ADDR_VAR 0 2
6420: PUSH
6421: LD_INT 6
6423: PPUSH
6424: LD_INT 3
6426: PUSH
6427: LD_INT 24
6429: PUSH
6430: LD_INT 1000
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: PUSH
6441: LD_INT 21
6443: PUSH
6444: LD_INT 3
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL_OW 70
6459: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6460: LD_ADDR_VAR 0 4
6464: PUSH
6465: LD_INT 22
6467: PUSH
6468: LD_INT 3
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: LD_INT 25
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PPUSH
6489: CALL_OW 69
6493: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6494: LD_VAR 0 2
6498: NOT
6499: PUSH
6500: LD_EXP 20
6504: NOT
6505: AND
6506: IFFALSE 6576
// begin for i in engs do
6508: LD_ADDR_VAR 0 1
6512: PUSH
6513: LD_VAR 0 4
6517: PUSH
6518: FOR_IN
6519: IFFALSE 6574
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6521: LD_VAR 0 1
6525: PPUSH
6526: CALL_OW 256
6530: PUSH
6531: LD_INT 1000
6533: EQUAL
6534: PUSH
6535: LD_VAR 0 1
6539: PPUSH
6540: CALL_OW 314
6544: NOT
6545: AND
6546: PUSH
6547: LD_VAR 0 1
6551: PPUSH
6552: CALL_OW 310
6556: NOT
6557: AND
6558: IFFALSE 6572
// ComEnterUnit ( i , ru_dep_main ) ;
6560: LD_VAR 0 1
6564: PPUSH
6565: LD_INT 16
6567: PPUSH
6568: CALL_OW 120
6572: GO 6518
6574: POP
6575: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6576: LD_VAR 0 4
6580: PPUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 24
6586: PUSH
6587: LD_INT 650
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PPUSH
6598: CALL_OW 72
6602: IFFALSE 6695
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6604: LD_ADDR_VAR 0 3
6608: PUSH
6609: LD_VAR 0 4
6613: PPUSH
6614: LD_INT 3
6616: PUSH
6617: LD_INT 24
6619: PUSH
6620: LD_INT 650
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: PPUSH
6631: CALL_OW 72
6635: ST_TO_ADDR
// for i in tmp do
6636: LD_ADDR_VAR 0 1
6640: PUSH
6641: LD_VAR 0 3
6645: PUSH
6646: FOR_IN
6647: IFFALSE 6693
// if not IsInArea ( i , mainBaseArea ) then
6649: LD_VAR 0 1
6653: PPUSH
6654: LD_INT 14
6656: PPUSH
6657: CALL_OW 308
6661: NOT
6662: IFFALSE 6691
// begin ComMoveXY ( i , 129 , 125 ) ;
6664: LD_VAR 0 1
6668: PPUSH
6669: LD_INT 129
6671: PPUSH
6672: LD_INT 125
6674: PPUSH
6675: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6679: LD_VAR 0 1
6683: PPUSH
6684: LD_INT 1050
6686: PPUSH
6687: CALL_OW 202
// end ;
6691: GO 6646
6693: POP
6694: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_VAR 0 4
6704: PPUSH
6705: LD_INT 24
6707: PUSH
6708: LD_INT 650
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PPUSH
6715: CALL_OW 72
6719: ST_TO_ADDR
// if not engs then
6720: LD_VAR 0 4
6724: NOT
6725: IFFALSE 6729
// exit ;
6727: GO 7135
// if filter then
6729: LD_VAR 0 2
6733: IFFALSE 6992
// begin for i in engs do
6735: LD_ADDR_VAR 0 1
6739: PUSH
6740: LD_VAR 0 4
6744: PUSH
6745: FOR_IN
6746: IFFALSE 6770
// if IsInUnit ( i ) then
6748: LD_VAR 0 1
6752: PPUSH
6753: CALL_OW 310
6757: IFFALSE 6768
// ComExitBuilding ( i ) ;
6759: LD_VAR 0 1
6763: PPUSH
6764: CALL_OW 122
6768: GO 6745
6770: POP
6771: POP
// wait ( 3 ) ;
6772: LD_INT 3
6774: PPUSH
6775: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6779: LD_VAR 0 2
6783: PUSH
6784: LD_INT 2
6786: GREATEREQUAL
6787: PUSH
6788: LD_VAR 0 4
6792: PUSH
6793: LD_INT 2
6795: GREATEREQUAL
6796: AND
6797: IFFALSE 6945
// begin for i = 1 to engs / 2 do
6799: LD_ADDR_VAR 0 1
6803: PUSH
6804: DOUBLE
6805: LD_INT 1
6807: DEC
6808: ST_TO_ADDR
6809: LD_VAR 0 4
6813: PUSH
6814: LD_INT 2
6816: DIVREAL
6817: PUSH
6818: FOR_TO
6819: IFFALSE 6865
// if not HasTask ( engs [ i ] ) then
6821: LD_VAR 0 4
6825: PUSH
6826: LD_VAR 0 1
6830: ARRAY
6831: PPUSH
6832: CALL_OW 314
6836: NOT
6837: IFFALSE 6863
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6839: LD_VAR 0 4
6843: PUSH
6844: LD_VAR 0 1
6848: ARRAY
6849: PPUSH
6850: LD_VAR 0 2
6854: PUSH
6855: LD_INT 1
6857: ARRAY
6858: PPUSH
6859: CALL_OW 130
6863: GO 6818
6865: POP
6866: POP
// for i = engs / 2 + 1 to engs do
6867: LD_ADDR_VAR 0 1
6871: PUSH
6872: DOUBLE
6873: LD_VAR 0 4
6877: PUSH
6878: LD_INT 2
6880: DIVREAL
6881: PUSH
6882: LD_INT 1
6884: PLUS
6885: DEC
6886: ST_TO_ADDR
6887: LD_VAR 0 4
6891: PUSH
6892: FOR_TO
6893: IFFALSE 6941
// if not HasTask ( engs [ i ] ) then
6895: LD_VAR 0 4
6899: PUSH
6900: LD_VAR 0 1
6904: ARRAY
6905: PPUSH
6906: CALL_OW 314
6910: NOT
6911: IFFALSE 6939
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6913: LD_VAR 0 4
6917: PUSH
6918: LD_VAR 0 1
6922: ARRAY
6923: PPUSH
6924: LD_VAR 0 2
6928: PUSH
6929: LD_VAR 0 2
6933: ARRAY
6934: PPUSH
6935: CALL_OW 130
6939: GO 6892
6941: POP
6942: POP
// end else
6943: GO 6992
// for i in engs do
6945: LD_ADDR_VAR 0 1
6949: PUSH
6950: LD_VAR 0 4
6954: PUSH
6955: FOR_IN
6956: IFFALSE 6990
// if not HasTask ( i ) then
6958: LD_VAR 0 1
6962: PPUSH
6963: CALL_OW 314
6967: NOT
6968: IFFALSE 6988
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_VAR 0 2
6979: PUSH
6980: LD_INT 1
6982: ARRAY
6983: PPUSH
6984: CALL_OW 130
6988: GO 6955
6990: POP
6991: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6992: LD_ADDR_VAR 0 5
6996: PUSH
6997: LD_INT 81
6999: PUSH
7000: LD_INT 3
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: ST_TO_ADDR
// if ru_rebuild_list and not filter then
7012: LD_EXP 20
7016: PUSH
7017: LD_VAR 0 2
7021: NOT
7022: AND
7023: IFFALSE 7135
// begin ComExitBuilding ( engs ) ;
7025: LD_VAR 0 4
7029: PPUSH
7030: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
7034: LD_VAR 0 5
7038: PPUSH
7039: LD_EXP 20
7043: PUSH
7044: LD_INT 2
7046: ARRAY
7047: PPUSH
7048: LD_EXP 20
7052: PUSH
7053: LD_INT 3
7055: ARRAY
7056: PPUSH
7057: CALL_OW 73
7061: PPUSH
7062: LD_EXP 20
7066: PUSH
7067: LD_INT 2
7069: ARRAY
7070: PPUSH
7071: LD_EXP 20
7075: PUSH
7076: LD_INT 3
7078: ARRAY
7079: PPUSH
7080: CALL_OW 297
7084: PUSH
7085: LD_INT 10
7087: GREATER
7088: IFFALSE 7135
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
7090: LD_VAR 0 4
7094: PPUSH
7095: LD_EXP 20
7099: PUSH
7100: LD_INT 1
7102: ARRAY
7103: PPUSH
7104: LD_EXP 20
7108: PUSH
7109: LD_INT 2
7111: ARRAY
7112: PPUSH
7113: LD_EXP 20
7117: PUSH
7118: LD_INT 3
7120: ARRAY
7121: PPUSH
7122: LD_EXP 20
7126: PUSH
7127: LD_INT 4
7129: ARRAY
7130: PPUSH
7131: CALL_OW 145
// end ; end ;
7135: PPOPN 5
7137: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 250 do var i , tmp ;
7138: LD_INT 16
7140: PPUSH
7141: CALL_OW 256
7145: PUSH
7146: LD_INT 250
7148: LESS
7149: IFFALSE 7339
7151: GO 7153
7153: DISABLE
7154: LD_INT 0
7156: PPUSH
7157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
7158: LD_ADDR_VAR 0 2
7162: PUSH
7163: LD_INT 22
7165: PUSH
7166: LD_INT 3
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 2
7175: PUSH
7176: LD_INT 25
7178: PUSH
7179: LD_INT 1
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: LD_INT 25
7188: PUSH
7189: LD_INT 3
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 25
7198: PUSH
7199: LD_INT 4
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PPUSH
7216: CALL_OW 69
7220: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7221: LD_VAR 0 2
7225: PPUSH
7226: CALL_OW 122
// wait ( 3 ) ;
7230: LD_INT 3
7232: PPUSH
7233: CALL_OW 67
// ComMoveXY ( tmp , 156 , 211 ) ;
7237: LD_VAR 0 2
7241: PPUSH
7242: LD_INT 156
7244: PPUSH
7245: LD_INT 211
7247: PPUSH
7248: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7252: LD_INT 35
7254: PPUSH
7255: CALL_OW 67
// for i in tmp do
7259: LD_ADDR_VAR 0 1
7263: PUSH
7264: LD_VAR 0 2
7268: PUSH
7269: FOR_IN
7270: IFFALSE 7330
// if IsInArea ( i , escapeArea ) then
7272: LD_VAR 0 1
7276: PPUSH
7277: LD_INT 15
7279: PPUSH
7280: CALL_OW 308
7284: IFFALSE 7313
// begin RemoveUnit ( i ) ;
7286: LD_VAR 0 1
7290: PPUSH
7291: CALL_OW 64
// tmp := tmp diff i ;
7295: LD_ADDR_VAR 0 2
7299: PUSH
7300: LD_VAR 0 2
7304: PUSH
7305: LD_VAR 0 1
7309: DIFF
7310: ST_TO_ADDR
// end else
7311: GO 7328
// ComMoveXY ( i , 156 , 211 ) ;
7313: LD_VAR 0 1
7317: PPUSH
7318: LD_INT 156
7320: PPUSH
7321: LD_INT 211
7323: PPUSH
7324: CALL_OW 111
7328: GO 7269
7330: POP
7331: POP
// until not tmp ;
7332: LD_VAR 0 2
7336: NOT
7337: IFFALSE 7252
// end ;
7339: PPOPN 2
7341: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 250 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7342: LD_INT 16
7344: PPUSH
7345: CALL_OW 256
7349: PUSH
7350: LD_INT 250
7352: GREATER
7353: PUSH
7354: LD_INT 22
7356: PUSH
7357: LD_INT 3
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: PUSH
7364: LD_INT 25
7366: PUSH
7367: LD_INT 1
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PUSH
7374: LD_INT 56
7376: PUSH
7377: EMPTY
7378: LIST
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: PUSH
7385: EMPTY
7386: LIST
7387: PPUSH
7388: CALL_OW 69
7392: AND
7393: IFFALSE 7505
7395: GO 7397
7397: DISABLE
7398: LD_INT 0
7400: PPUSH
7401: PPUSH
// begin enable ;
7402: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7403: LD_ADDR_VAR 0 2
7407: PUSH
7408: LD_INT 22
7410: PUSH
7411: LD_INT 3
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: PUSH
7418: LD_INT 25
7420: PUSH
7421: LD_INT 1
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: PUSH
7428: LD_INT 56
7430: PUSH
7431: EMPTY
7432: LIST
7433: PUSH
7434: LD_INT 3
7436: PUSH
7437: LD_INT 60
7439: PUSH
7440: EMPTY
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: LIST
7451: LIST
7452: PUSH
7453: EMPTY
7454: LIST
7455: PPUSH
7456: CALL_OW 69
7460: ST_TO_ADDR
// if not tmp then
7461: LD_VAR 0 2
7465: NOT
7466: IFFALSE 7470
// exit ;
7468: GO 7505
// for i in tmp do
7470: LD_ADDR_VAR 0 1
7474: PUSH
7475: LD_VAR 0 2
7479: PUSH
7480: FOR_IN
7481: IFFALSE 7503
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: LD_INT 143
7493: PPUSH
7494: LD_INT 143
7496: PPUSH
7497: CALL 2200 0 4
7501: GO 7480
7503: POP
7504: POP
// end ;
7505: PPOPN 2
7507: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7508: LD_INT 22
7510: PUSH
7511: LD_INT 3
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: LD_INT 25
7520: PUSH
7521: LD_INT 4
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: IFFALSE 7790
7538: GO 7540
7540: DISABLE
7541: LD_INT 0
7543: PPUSH
7544: PPUSH
7545: PPUSH
// begin enable ;
7546: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7547: LD_ADDR_VAR 0 2
7551: PUSH
7552: LD_INT 14
7554: PPUSH
7555: LD_INT 22
7557: PUSH
7558: LD_INT 3
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PUSH
7565: LD_INT 21
7567: PUSH
7568: LD_INT 1
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 3
7577: PUSH
7578: LD_INT 24
7580: PUSH
7581: LD_INT 1000
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PPUSH
7597: CALL_OW 70
7601: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7602: LD_ADDR_VAR 0 3
7606: PUSH
7607: LD_INT 22
7609: PUSH
7610: LD_INT 3
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PUSH
7617: LD_INT 25
7619: PUSH
7620: LD_INT 4
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PPUSH
7631: CALL_OW 69
7635: ST_TO_ADDR
// if not doc then
7636: LD_VAR 0 3
7640: NOT
7641: IFFALSE 7645
// exit ;
7643: GO 7790
// if not tmp then
7645: LD_VAR 0 2
7649: NOT
7650: IFFALSE 7741
// begin if not IsInUnit ( doc [ 1 ] ) then
7652: LD_VAR 0 3
7656: PUSH
7657: LD_INT 1
7659: ARRAY
7660: PPUSH
7661: CALL_OW 310
7665: NOT
7666: IFFALSE 7739
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7668: LD_VAR 0 3
7672: PPUSH
7673: LD_INT 22
7675: PUSH
7676: LD_INT 3
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 2
7685: PUSH
7686: LD_INT 30
7688: PUSH
7689: LD_INT 6
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: LD_INT 30
7698: PUSH
7699: LD_INT 7
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 30
7708: PUSH
7709: LD_INT 8
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: PPUSH
7726: CALL_OW 69
7730: PUSH
7731: LD_INT 1
7733: ARRAY
7734: PPUSH
7735: CALL_OW 120
// exit ;
7739: GO 7790
// end ; if IsInUnit ( doc [ 1 ] ) then
7741: LD_VAR 0 3
7745: PUSH
7746: LD_INT 1
7748: ARRAY
7749: PPUSH
7750: CALL_OW 310
7754: IFFALSE 7765
// ComExitBuilding ( doc ) ;
7756: LD_VAR 0 3
7760: PPUSH
7761: CALL_OW 122
// wait ( 3 ) ;
7765: LD_INT 3
7767: PPUSH
7768: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7772: LD_VAR 0 3
7776: PPUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 1
7784: ARRAY
7785: PPUSH
7786: CALL_OW 128
// end ;
7790: PPOPN 3
7792: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7793: LD_INT 22
7795: PUSH
7796: LD_INT 3
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PUSH
7803: LD_INT 25
7805: PUSH
7806: LD_INT 3
7808: PUSH
7809: EMPTY
7810: LIST
7811: LIST
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: PPUSH
7817: CALL_OW 69
7821: PUSH
7822: LD_INT 22
7824: PUSH
7825: LD_INT 3
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: LD_INT 21
7834: PUSH
7835: LD_INT 2
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PPUSH
7846: CALL_OW 69
7850: AND
7851: IFFALSE 8265
7853: GO 7855
7855: DISABLE
7856: LD_INT 0
7858: PPUSH
7859: PPUSH
7860: PPUSH
7861: PPUSH
7862: PPUSH
// begin enable ;
7863: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7864: LD_ADDR_VAR 0 2
7868: PUSH
7869: LD_INT 22
7871: PUSH
7872: LD_INT 3
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PUSH
7879: LD_INT 21
7881: PUSH
7882: LD_INT 2
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 3
7891: PUSH
7892: LD_INT 58
7894: PUSH
7895: EMPTY
7896: LIST
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7912: LD_ADDR_VAR 0 4
7916: PUSH
7917: LD_INT 10
7919: PUSH
7920: LD_INT 11
7922: PUSH
7923: LD_INT 12
7925: PUSH
7926: LD_INT 14
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: LIST
7933: LIST
7934: ST_TO_ADDR
// area := 0 ;
7935: LD_ADDR_VAR 0 5
7939: PUSH
7940: LD_INT 0
7942: ST_TO_ADDR
// attacking := false ;
7943: LD_ADDR_VAR 0 3
7947: PUSH
7948: LD_INT 0
7950: ST_TO_ADDR
// for i in tmp do
7951: LD_ADDR_VAR 0 1
7955: PUSH
7956: LD_VAR 0 2
7960: PUSH
7961: FOR_IN
7962: IFFALSE 8048
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 22
7971: PUSH
7972: LD_INT 1
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 69
7983: PPUSH
7984: LD_VAR 0 1
7988: PPUSH
7989: CALL_OW 74
7993: PPUSH
7994: CALL_OW 296
7998: PUSH
7999: LD_INT 10
8001: LESS
8002: IFFALSE 8046
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 22
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PPUSH
8019: CALL_OW 69
8023: PPUSH
8024: LD_VAR 0 1
8028: PPUSH
8029: CALL_OW 74
8033: PPUSH
8034: CALL_OW 115
// attacking := true ;
8038: LD_ADDR_VAR 0 3
8042: PUSH
8043: LD_INT 1
8045: ST_TO_ADDR
// end ;
8046: GO 7961
8048: POP
8049: POP
// if attacking then
8050: LD_VAR 0 3
8054: IFFALSE 8058
// exit ;
8056: GO 8265
// for i in areas do
8058: LD_ADDR_VAR 0 1
8062: PUSH
8063: LD_VAR 0 4
8067: PUSH
8068: FOR_IN
8069: IFFALSE 8106
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
8071: LD_VAR 0 1
8075: PPUSH
8076: LD_INT 22
8078: PUSH
8079: LD_INT 1
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PPUSH
8086: CALL_OW 70
8090: IFFALSE 8104
// begin area := i ;
8092: LD_ADDR_VAR 0 5
8096: PUSH
8097: LD_VAR 0 1
8101: ST_TO_ADDR
// break ;
8102: GO 8106
// end ;
8104: GO 8068
8106: POP
8107: POP
// if area then
8108: LD_VAR 0 5
8112: IFFALSE 8265
// begin for i in tmp do
8114: LD_ADDR_VAR 0 1
8118: PUSH
8119: LD_VAR 0 2
8123: PUSH
8124: FOR_IN
8125: IFFALSE 8263
// begin if GetFuel ( i ) < 33 then
8127: LD_VAR 0 1
8131: PPUSH
8132: CALL_OW 261
8136: PUSH
8137: LD_INT 33
8139: LESS
8140: IFFALSE 8154
// SetFuel ( i , 33 ) ;
8142: LD_VAR 0 1
8146: PPUSH
8147: LD_INT 33
8149: PPUSH
8150: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
8154: LD_VAR 0 1
8158: PPUSH
8159: LD_INT 22
8161: PUSH
8162: LD_INT 1
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: PPUSH
8174: LD_VAR 0 1
8178: PPUSH
8179: CALL_OW 74
8183: PPUSH
8184: CALL_OW 296
8188: PUSH
8189: LD_INT 10
8191: LESS
8192: IFFALSE 8230
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8194: LD_VAR 0 1
8198: PPUSH
8199: LD_INT 22
8201: PUSH
8202: LD_INT 1
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: PPUSH
8209: CALL_OW 69
8213: PPUSH
8214: LD_VAR 0 1
8218: PPUSH
8219: CALL_OW 74
8223: PPUSH
8224: CALL_OW 115
8228: GO 8261
// if not IsInArea ( i , area ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: LD_VAR 0 5
8239: PPUSH
8240: CALL_OW 308
8244: NOT
8245: IFFALSE 8261
// ComMoveToArea ( i , area ) ;
8247: LD_VAR 0 1
8251: PPUSH
8252: LD_VAR 0 5
8256: PPUSH
8257: CALL_OW 113
// end ;
8261: GO 8124
8263: POP
8264: POP
// end ; end ;
8265: PPOPN 5
8267: END
// every 15 15$00 trigger Difficulty > 1 do var i , j , un , veh , time , count ;
8268: LD_OWVAR 67
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8553
8278: GO 8280
8280: DISABLE
8281: LD_INT 0
8283: PPUSH
8284: PPUSH
8285: PPUSH
8286: PPUSH
8287: PPUSH
8288: PPUSH
// begin uc_side := 3 ;
8289: LD_ADDR_OWVAR 20
8293: PUSH
8294: LD_INT 3
8296: ST_TO_ADDR
// uc_nation := 3 ;
8297: LD_ADDR_OWVAR 21
8301: PUSH
8302: LD_INT 3
8304: ST_TO_ADDR
// time := [ 9 9$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8305: LD_ADDR_VAR 0 5
8309: PUSH
8310: LD_INT 18900
8312: PUSH
8313: LD_INT 14700
8315: PUSH
8316: LD_INT 12600
8318: PUSH
8319: EMPTY
8320: LIST
8321: LIST
8322: LIST
8323: PUSH
8324: LD_OWVAR 67
8328: ARRAY
8329: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8330: LD_ADDR_VAR 0 6
8334: PUSH
8335: LD_INT 2
8337: PUSH
8338: LD_INT 2
8340: PUSH
8341: LD_INT 3
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: LIST
8348: PUSH
8349: LD_OWVAR 67
8353: ARRAY
8354: ST_TO_ADDR
// for i = 1 to count do
8355: LD_ADDR_VAR 0 1
8359: PUSH
8360: DOUBLE
8361: LD_INT 1
8363: DEC
8364: ST_TO_ADDR
8365: LD_VAR 0 6
8369: PUSH
8370: FOR_TO
8371: IFFALSE 8551
// begin wait ( time ) ;
8373: LD_VAR 0 5
8377: PPUSH
8378: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8382: LD_ADDR_VAR 0 2
8386: PUSH
8387: DOUBLE
8388: LD_INT 1
8390: DEC
8391: ST_TO_ADDR
8392: LD_INT 1
8394: PPUSH
8395: LD_OWVAR 67
8399: PPUSH
8400: CALL_OW 12
8404: PUSH
8405: FOR_TO
8406: IFFALSE 8547
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8408: LD_ADDR_VAR 0 4
8412: PUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 22
8421: PPUSH
8422: LD_INT 1
8424: PPUSH
8425: LD_INT 1
8427: PPUSH
8428: LD_INT 43
8430: PUSH
8431: LD_INT 44
8433: PUSH
8434: LD_INT 42
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: LD_VAR 0 1
8446: PUSH
8447: LD_INT 3
8449: MOD
8450: PUSH
8451: LD_INT 1
8453: PLUS
8454: ARRAY
8455: PPUSH
8456: LD_INT 80
8458: PPUSH
8459: CALL 563 0 7
8463: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8464: LD_VAR 0 4
8468: PPUSH
8469: LD_INT 13
8471: PPUSH
8472: LD_INT 0
8474: PPUSH
8475: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8479: LD_INT 0
8481: PPUSH
8482: LD_INT 3
8484: PPUSH
8485: LD_INT 4
8487: PUSH
8488: LD_INT 5
8490: PUSH
8491: LD_INT 5
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: LIST
8498: PUSH
8499: LD_OWVAR 67
8503: ARRAY
8504: PPUSH
8505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8509: CALL_OW 44
8513: PPUSH
8514: LD_VAR 0 4
8518: PPUSH
8519: CALL_OW 52
// wait ( 0 0$01 ) ;
8523: LD_INT 35
8525: PPUSH
8526: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8530: LD_VAR 0 4
8534: PPUSH
8535: LD_INT 143
8537: PPUSH
8538: LD_INT 143
8540: PPUSH
8541: CALL_OW 111
// end ;
8545: GO 8405
8547: POP
8548: POP
// end ;
8549: GO 8370
8551: POP
8552: POP
// end ;
8553: PPOPN 6
8555: END
// every 8 8$00 do var i , un , time ;
8556: GO 8558
8558: DISABLE
8559: LD_INT 0
8561: PPUSH
8562: PPUSH
8563: PPUSH
// begin time := [ 3 3$00 , 1 1$00 , 0 0$30 ] ;
8564: LD_ADDR_VAR 0 3
8568: PUSH
8569: LD_INT 6300
8571: PUSH
8572: LD_INT 2100
8574: PUSH
8575: LD_INT 1050
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: ST_TO_ADDR
// wait ( time ) ;
8583: LD_VAR 0 3
8587: PPUSH
8588: CALL_OW 67
// uc_side := 3 ;
8592: LD_ADDR_OWVAR 20
8596: PUSH
8597: LD_INT 3
8599: ST_TO_ADDR
// uc_nation := 3 ;
8600: LD_ADDR_OWVAR 21
8604: PUSH
8605: LD_INT 3
8607: ST_TO_ADDR
// for i = 1 to 2 do
8608: LD_ADDR_VAR 0 1
8612: PUSH
8613: DOUBLE
8614: LD_INT 1
8616: DEC
8617: ST_TO_ADDR
8618: LD_INT 2
8620: PUSH
8621: FOR_TO
8622: IFFALSE 8685
// begin PrepareHuman ( false , 1 , 4 ) ;
8624: LD_INT 0
8626: PPUSH
8627: LD_INT 1
8629: PPUSH
8630: LD_INT 4
8632: PPUSH
8633: CALL_OW 380
// un := CreateHuman ;
8637: LD_ADDR_VAR 0 2
8641: PUSH
8642: CALL_OW 44
8646: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8647: LD_VAR 0 2
8651: PPUSH
8652: LD_INT 16
8654: PPUSH
8655: CALL_OW 52
// ComExitBuilding ( un ) ;
8659: LD_VAR 0 2
8663: PPUSH
8664: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8668: LD_VAR 0 2
8672: PPUSH
8673: LD_INT 41
8675: PPUSH
8676: LD_INT 76
8678: PPUSH
8679: CALL_OW 174
// end ;
8683: GO 8621
8685: POP
8686: POP
// end ; end_of_file
8687: PPOPN 3
8689: END
// export function Action ; begin
8690: LD_INT 0
8692: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8693: LD_INT 28
8695: PPUSH
8696: LD_INT 3
8698: PPUSH
8699: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8703: LD_INT 41
8705: PPUSH
8706: LD_INT 76
8708: PPUSH
8709: LD_INT 1
8711: PPUSH
8712: LD_INT 10
8714: PPUSH
8715: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8719: LD_INT 41
8721: PPUSH
8722: LD_INT 76
8724: PPUSH
8725: LD_INT 1
8727: PPUSH
8728: CALL_OW 331
// InGameOn ;
8732: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8736: LD_EXP 19
8740: PPUSH
8741: LD_STRING D2-Har-1
8743: PPUSH
8744: CALL_OW 94
// InGameOff ;
8748: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8752: LD_STRING M1
8754: PPUSH
8755: CALL_OW 337
// end ;
8759: LD_VAR 0 1
8763: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8764: LD_EXP 4
8768: PUSH
8769: LD_INT 1
8771: GREATER
8772: IFFALSE 8863
8774: GO 8776
8776: DISABLE
8777: LD_INT 0
8779: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8780: LD_ADDR_VAR 0 1
8784: PUSH
8785: LD_INT 1
8787: PPUSH
8788: CALL 651 0 1
8792: PUSH
8793: LD_INT 1
8795: ARRAY
8796: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8797: LD_VAR 0 1
8801: PPUSH
8802: LD_STRING D2a-Sol1-1
8804: PPUSH
8805: CALL_OW 88
// if not un then
8809: LD_VAR 0 1
8813: NOT
8814: IFFALSE 8845
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8816: LD_ADDR_VAR 0 1
8820: PUSH
8821: LD_INT 2
8823: PPUSH
8824: CALL 651 0 1
8828: PUSH
8829: LD_INT 1
8831: ARRAY
8832: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8833: LD_VAR 0 1
8837: PPUSH
8838: LD_STRING D2a-FSol1-1
8840: PPUSH
8841: CALL_OW 88
// end ; if Khatam then
8845: LD_EXP 17
8849: IFFALSE 8863
// Say ( Khatam , D3b-Khat-3 ) ;
8851: LD_EXP 17
8855: PPUSH
8856: LD_STRING D3b-Khat-3
8858: PPUSH
8859: CALL_OW 88
// end ;
8863: PPOPN 1
8865: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) and not InBattle ( 4 ) do var i , ape ;
8866: LD_EXP 15
8870: PUSH
8871: LD_EXP 18
8875: NOT
8876: AND
8877: PUSH
8878: LD_INT 22
8880: PUSH
8881: LD_INT 1
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PUSH
8888: LD_INT 92
8890: PUSH
8891: LD_EXP 15
8895: PPUSH
8896: CALL_OW 250
8900: PUSH
8901: LD_EXP 15
8905: PPUSH
8906: CALL_OW 251
8910: PUSH
8911: LD_INT 7
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: LIST
8918: LIST
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: AND
8929: PUSH
8930: LD_INT 1
8932: PPUSH
8933: CALL_OW 463
8937: NOT
8938: AND
8939: PUSH
8940: LD_INT 4
8942: PPUSH
8943: CALL_OW 463
8947: NOT
8948: AND
8949: IFFALSE 9536
8951: GO 8953
8953: DISABLE
8954: LD_INT 0
8956: PPUSH
8957: PPUSH
// begin InGameOn ;
8958: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8962: LD_ADDR_VAR 0 2
8966: PUSH
8967: LD_INT 22
8969: PUSH
8970: LD_INT 0
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PUSH
8977: LD_INT 25
8979: PUSH
8980: LD_INT 12
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: PUSH
8987: EMPTY
8988: LIST
8989: LIST
8990: PPUSH
8991: CALL_OW 69
8995: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8996: LD_ADDR_VAR 0 2
9000: PUSH
9001: LD_VAR 0 2
9005: PPUSH
9006: LD_EXP 15
9010: PPUSH
9011: CALL_OW 74
9015: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
9016: LD_ADDR_VAR 0 1
9020: PUSH
9021: LD_INT 22
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: PUSH
9031: LD_INT 21
9033: PUSH
9034: LD_INT 1
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: PUSH
9041: LD_INT 91
9043: PUSH
9044: LD_EXP 15
9048: PUSH
9049: LD_INT 20
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PPUSH
9062: CALL_OW 69
9066: PUSH
9067: FOR_IN
9068: IFFALSE 9086
// ComTurnUnit ( i , Frank ) ;
9070: LD_VAR 0 1
9074: PPUSH
9075: LD_EXP 15
9079: PPUSH
9080: CALL_OW 119
9084: GO 9067
9086: POP
9087: POP
// SetSide ( Frank , 1 ) ;
9088: LD_EXP 15
9092: PPUSH
9093: LD_INT 1
9095: PPUSH
9096: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
9100: LD_EXP 9
9104: PPUSH
9105: LD_EXP 15
9109: PPUSH
9110: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
9114: LD_EXP 9
9118: PPUSH
9119: LD_EXP 15
9123: PPUSH
9124: CALL_OW 179
// CenterOnUnits ( Frank ) ;
9128: LD_EXP 15
9132: PPUSH
9133: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
9137: LD_EXP 15
9141: PPUSH
9142: LD_STRING D3a-Frank-1
9144: PPUSH
9145: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
9149: LD_VAR 0 2
9153: PPUSH
9154: LD_INT 42
9156: PPUSH
9157: LD_INT 78
9159: PPUSH
9160: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
9164: LD_VAR 0 2
9168: PPUSH
9169: LD_EXP 15
9173: PPUSH
9174: CALL_OW 179
// if Lisa then
9178: LD_EXP 14
9182: IFFALSE 9196
// Say ( Lisa , D3a-Lisa-1 ) ;
9184: LD_EXP 14
9188: PPUSH
9189: LD_STRING D3a-Lisa-1
9191: PPUSH
9192: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
9196: LD_EXP 9
9200: PPUSH
9201: LD_STRING D3a-JMM-1
9203: PPUSH
9204: CALL_OW 88
// if Cyrus then
9208: LD_EXP 13
9212: IFFALSE 9226
// Say ( Cyrus , D3a-Cyrus-1 ) ;
9214: LD_EXP 13
9218: PPUSH
9219: LD_STRING D3a-Cyrus-1
9221: PPUSH
9222: CALL_OW 88
// if GetRandom ( sex_male ) then
9226: LD_INT 1
9228: PPUSH
9229: CALL 651 0 1
9233: IFFALSE 9254
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
9235: LD_INT 1
9237: PPUSH
9238: CALL 651 0 1
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_STRING D3a-Sol1-1
9249: PPUSH
9250: CALL_OW 88
// if GetRandom ( sex_female ) then
9254: LD_INT 2
9256: PPUSH
9257: CALL 651 0 1
9261: IFFALSE 9282
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
9263: LD_INT 2
9265: PPUSH
9266: CALL 651 0 1
9270: PUSH
9271: LD_INT 1
9273: ARRAY
9274: PPUSH
9275: LD_STRING D3a-FSol1-1
9277: PPUSH
9278: CALL_OW 88
// if Gladstone then
9282: LD_EXP 16
9286: IFFALSE 9300
// Say ( Gladstone , D3a-Glad-1 ) ;
9288: LD_EXP 16
9292: PPUSH
9293: LD_STRING D3a-Glad-1
9295: PPUSH
9296: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
9300: LD_VAR 0 2
9304: PPUSH
9305: LD_INT 60
9307: PPUSH
9308: LD_INT 113
9310: PPUSH
9311: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9315: LD_EXP 15
9319: PPUSH
9320: LD_STRING D3a-Frank-2
9322: PPUSH
9323: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9327: LD_EXP 15
9331: PPUSH
9332: LD_EXP 9
9336: PPUSH
9337: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9341: LD_EXP 9
9345: PPUSH
9346: LD_STRING D3a-JMM-2
9348: PPUSH
9349: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9353: LD_INT 1
9355: PPUSH
9356: LD_INT 4
9358: PPUSH
9359: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9363: LD_INT 85
9365: PPUSH
9366: LD_INT 134
9368: PPUSH
9369: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9373: LD_EXP 15
9377: PPUSH
9378: LD_STRING D3a-Frank-3
9380: PPUSH
9381: CALL_OW 88
// Wait ( 0 0$01 ) ;
9385: LD_INT 35
9387: PPUSH
9388: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9392: LD_INT 166
9394: PPUSH
9395: LD_INT 136
9397: PPUSH
9398: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9402: LD_EXP 9
9406: PPUSH
9407: LD_STRING D3a-JMM-3
9409: PPUSH
9410: CALL_OW 88
// Wait ( 0 0$01 ) ;
9414: LD_INT 35
9416: PPUSH
9417: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9421: LD_EXP 15
9425: PPUSH
9426: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9430: LD_EXP 15
9434: PPUSH
9435: LD_STRING D3a-Frank-4
9437: PPUSH
9438: CALL_OW 88
// if Lisa then
9442: LD_EXP 14
9446: IFFALSE 9460
// Say ( Lisa , D3a-Lisa-4 ) ;
9448: LD_EXP 14
9452: PPUSH
9453: LD_STRING D3a-Lisa-4
9455: PPUSH
9456: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9460: LD_EXP 9
9464: PPUSH
9465: LD_STRING D3a-JMM-4
9467: PPUSH
9468: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9472: LD_EXP 15
9476: PPUSH
9477: LD_STRING D3a-Frank-5
9479: PPUSH
9480: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9484: LD_EXP 9
9488: PPUSH
9489: LD_STRING D3a-JMM-5
9491: PPUSH
9492: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9496: LD_EXP 15
9500: PPUSH
9501: LD_STRING D3a-Frank-6
9503: PPUSH
9504: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9508: LD_EXP 9
9512: PPUSH
9513: LD_STRING D3a-JMM-6
9515: PPUSH
9516: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9520: LD_EXP 15
9524: PPUSH
9525: LD_STRING D3a-Frank-7
9527: PPUSH
9528: CALL_OW 88
// InGameOff ;
9532: CALL_OW 9
// end ;
9536: PPOPN 2
9538: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) and not InBattle ( 4 ) do
9539: LD_EXP 18
9543: PUSH
9544: LD_EXP 15
9548: NOT
9549: AND
9550: PUSH
9551: LD_INT 22
9553: PUSH
9554: LD_INT 1
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 92
9563: PUSH
9564: LD_EXP 18
9568: PPUSH
9569: CALL_OW 250
9573: PUSH
9574: LD_EXP 18
9578: PPUSH
9579: CALL_OW 251
9583: PUSH
9584: LD_INT 7
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PPUSH
9597: CALL_OW 69
9601: AND
9602: PUSH
9603: LD_INT 1
9605: PPUSH
9606: CALL_OW 463
9610: NOT
9611: AND
9612: PUSH
9613: LD_INT 4
9615: PPUSH
9616: CALL_OW 463
9620: NOT
9621: AND
9622: IFFALSE 9802
9624: GO 9626
9626: DISABLE
// begin InGameOn ;
9627: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9631: LD_EXP 9
9635: PPUSH
9636: LD_EXP 18
9640: PPUSH
9641: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9645: LD_EXP 18
9649: PPUSH
9650: LD_EXP 9
9654: PPUSH
9655: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9659: LD_EXP 18
9663: PPUSH
9664: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9668: LD_EXP 18
9672: PPUSH
9673: LD_STRING D3b-Yam-1
9675: PPUSH
9676: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9680: LD_EXP 9
9684: PPUSH
9685: LD_STRING D3b-JMM-1
9687: PPUSH
9688: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9692: LD_INT 1
9694: PPUSH
9695: LD_INT 4
9697: PPUSH
9698: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9702: LD_INT 85
9704: PPUSH
9705: LD_INT 134
9707: PPUSH
9708: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9712: LD_EXP 18
9716: PPUSH
9717: LD_STRING D3b-Yam-2
9719: PPUSH
9720: CALL_OW 88
// Wait ( 0 0$01 ) ;
9724: LD_INT 35
9726: PPUSH
9727: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9731: LD_EXP 9
9735: PPUSH
9736: LD_STRING D3b-JMM-2
9738: PPUSH
9739: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9743: LD_INT 166
9745: PPUSH
9746: LD_INT 136
9748: PPUSH
9749: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9753: LD_EXP 18
9757: PPUSH
9758: LD_STRING D3b-Yam-3
9760: PPUSH
9761: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9765: LD_EXP 9
9769: PPUSH
9770: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9774: LD_EXP 9
9778: PPUSH
9779: LD_STRING D3b-JMM-3a
9781: PPUSH
9782: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9786: LD_EXP 18
9790: PPUSH
9791: LD_INT 1
9793: PPUSH
9794: CALL_OW 235
// InGameOff ;
9798: CALL_OW 9
// end ;
9802: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9803: LD_INT 7
9805: PPUSH
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 3
9818: PUSH
9819: LD_INT 24
9821: PUSH
9822: LD_INT 1000
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PUSH
9833: EMPTY
9834: LIST
9835: LIST
9836: PPUSH
9837: CALL_OW 70
9841: IFFALSE 10297
9843: GO 9845
9845: DISABLE
9846: LD_INT 0
9848: PPUSH
9849: PPUSH
9850: PPUSH
9851: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9852: LD_INT 35
9854: PPUSH
9855: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9859: LD_ADDR_VAR 0 1
9863: PUSH
9864: LD_INT 7
9866: PPUSH
9867: LD_INT 22
9869: PUSH
9870: LD_INT 1
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: LD_INT 3
9879: PUSH
9880: LD_INT 24
9882: PUSH
9883: LD_INT 1000
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 70
9902: ST_TO_ADDR
// if not un then
9903: LD_VAR 0 1
9907: NOT
9908: IFFALSE 9912
// continue ;
9910: GO 9852
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9912: LD_ADDR_VAR 0 3
9916: PUSH
9917: LD_VAR 0 1
9921: PUSH
9922: LD_INT 1
9924: ARRAY
9925: PPUSH
9926: CALL 3554 0 1
9930: ST_TO_ADDR
// until tw ;
9931: LD_VAR 0 3
9935: IFFALSE 9852
// DialogueOn ;
9937: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9941: LD_VAR 0 3
9945: PPUSH
9946: CALL_OW 87
// if Lisa then
9950: LD_EXP 14
9954: IFFALSE 9982
// begin Say ( Lisa , D5-Lisa-1 ) ;
9956: LD_EXP 14
9960: PPUSH
9961: LD_STRING D5-Lisa-1
9963: PPUSH
9964: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9968: LD_EXP 9
9972: PPUSH
9973: LD_STRING D5-JMM-1a
9975: PPUSH
9976: CALL_OW 88
// end else
9980: GO 9994
// Say ( JMM , D5-JMM-1 ) ;
9982: LD_EXP 9
9986: PPUSH
9987: LD_STRING D5-JMM-1
9989: PPUSH
9990: CALL_OW 88
// DialogueOff ;
9994: CALL_OW 7
// while ( true ) do
9998: LD_INT 1
10000: IFFALSE 10056
// begin wait ( 0 0$01 ) ;
10002: LD_INT 35
10004: PPUSH
10005: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
10009: LD_ADDR_VAR 0 2
10013: PUSH
10014: LD_INT 8
10016: PPUSH
10017: LD_INT 30
10019: PUSH
10020: LD_INT 26
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 101
10029: PUSH
10030: LD_INT 1
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PPUSH
10041: CALL_OW 71
10045: ST_TO_ADDR
// if x then
10046: LD_VAR 0 2
10050: IFFALSE 10054
// break ;
10052: GO 10056
// end ;
10054: GO 9998
// CenterOnUnits ( x [ 1 ] ) ;
10056: LD_VAR 0 2
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PPUSH
10065: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
10069: LD_EXP 15
10073: PUSH
10074: LD_EXP 15
10078: PPUSH
10079: CALL_OW 255
10083: PUSH
10084: LD_INT 1
10086: EQUAL
10087: AND
10088: IFFALSE 10104
// Say ( Frank , D5a-Frank-1 ) else
10090: LD_EXP 15
10094: PPUSH
10095: LD_STRING D5a-Frank-1
10097: PPUSH
10098: CALL_OW 88
10102: GO 10158
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10104: LD_EXP 18
10108: PUSH
10109: LD_EXP 18
10113: PPUSH
10114: CALL_OW 255
10118: PUSH
10119: LD_INT 1
10121: EQUAL
10122: AND
10123: IFFALSE 10139
// Say ( Kikuchi , D5a-Yam-1 ) else
10125: LD_EXP 18
10129: PPUSH
10130: LD_STRING D5a-Yam-1
10132: PPUSH
10133: CALL_OW 88
10137: GO 10158
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
10139: LD_INT 1
10141: PPUSH
10142: CALL 651 0 1
10146: PUSH
10147: LD_INT 1
10149: ARRAY
10150: PPUSH
10151: LD_STRING D5a-Sol1-1
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
10158: LD_EXP 9
10162: PPUSH
10163: LD_STRING D5a-JMM-1
10165: PPUSH
10166: CALL_OW 88
// if Cyrus then
10170: LD_EXP 13
10174: IFFALSE 10188
// Say ( Cyrus , D5a-Cyrus-1 ) ;
10176: LD_EXP 13
10180: PPUSH
10181: LD_STRING D5a-Cyrus-1
10183: PPUSH
10184: CALL_OW 88
// x := false ;
10188: LD_ADDR_VAR 0 2
10192: PUSH
10193: LD_INT 0
10195: ST_TO_ADDR
// while ( true ) do
10196: LD_INT 1
10198: IFFALSE 10285
// begin wait ( 0 0$01 ) ;
10200: LD_INT 35
10202: PPUSH
10203: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
10207: LD_ADDR_VAR 0 4
10211: PUSH
10212: LD_INT 2
10214: PUSH
10215: LD_INT 30
10217: PUSH
10218: LD_INT 0
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 30
10227: PUSH
10228: LD_INT 1
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: EMPTY
10236: LIST
10237: LIST
10238: LIST
10239: PPUSH
10240: CALL_OW 69
10244: PUSH
10245: LD_INT 1
10247: DIFF
10248: PUSH
10249: FOR_IN
10250: IFFALSE 10273
// if BaseNeedEnergy ( i ) then
10252: LD_VAR 0 4
10256: PPUSH
10257: CALL 2679 0 1
10261: IFFALSE 10271
// x := true ;
10263: LD_ADDR_VAR 0 2
10267: PUSH
10268: LD_INT 1
10270: ST_TO_ADDR
10271: GO 10249
10273: POP
10274: POP
// if x then
10275: LD_VAR 0 2
10279: IFFALSE 10283
// break ;
10281: GO 10285
// end ;
10283: GO 10196
// Say ( JMM , D5b-JMM-1 ) ;
10285: LD_EXP 9
10289: PPUSH
10290: LD_STRING D5b-JMM-1
10292: PPUSH
10293: CALL_OW 88
// end ;
10297: PPOPN 4
10299: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
10300: LD_EXP 5
10304: PUSH
10305: LD_INT 1
10307: ARRAY
10308: PUSH
10309: LD_OWVAR 1
10313: LESS
10314: IFFALSE 10514
10316: GO 10318
10318: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10319: LD_INT 16
10321: PPUSH
10322: CALL_OW 301
10326: NOT
10327: IFFALSE 10350
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10329: LD_EXP 19
10333: PPUSH
10334: LD_STRING D3b-Har-3
10336: PPUSH
10337: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10341: LD_STRING M2a
10343: PPUSH
10344: CALL_OW 337
// end else
10348: GO 10369
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10350: LD_EXP 19
10354: PPUSH
10355: LD_STRING D3b-Har-3a
10357: PPUSH
10358: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10362: LD_STRING M2
10364: PPUSH
10365: CALL_OW 337
// end ; can_end := true ;
10369: LD_ADDR_EXP 6
10373: PUSH
10374: LD_INT 1
10376: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10377: LD_INT 9
10379: PPUSH
10380: LD_INT 1
10382: PPUSH
10383: CALL_OW 424
// Wait ( 0 0$02 ) ;
10387: LD_INT 70
10389: PPUSH
10390: CALL_OW 67
// if Lisa then
10394: LD_EXP 14
10398: IFFALSE 10412
// Say ( Lisa , D3b-Lisa ) ;
10400: LD_EXP 14
10404: PPUSH
10405: LD_STRING D3b-Lisa
10407: PPUSH
10408: CALL_OW 88
// if Bobby then
10412: LD_EXP 12
10416: IFFALSE 10430
// Say ( Bobby , D3b-Bobby-3 ) ;
10418: LD_EXP 12
10422: PPUSH
10423: LD_STRING D3b-Bobby-3
10425: PPUSH
10426: CALL_OW 88
// if Cyrus then
10430: LD_EXP 13
10434: IFFALSE 10448
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10436: LD_EXP 13
10440: PPUSH
10441: LD_STRING D3b-Cyrus-3
10443: PPUSH
10444: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10448: LD_EXP 15
10452: PUSH
10453: LD_EXP 15
10457: PPUSH
10458: CALL_OW 255
10462: PUSH
10463: LD_INT 1
10465: EQUAL
10466: AND
10467: IFFALSE 10481
// Say ( Frank , D3b-Frank-3 ) ;
10469: LD_EXP 15
10473: PPUSH
10474: LD_STRING D3b-Frank-3
10476: PPUSH
10477: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10481: LD_EXP 18
10485: PUSH
10486: LD_EXP 18
10490: PPUSH
10491: CALL_OW 255
10495: PUSH
10496: LD_INT 1
10498: EQUAL
10499: AND
10500: IFFALSE 10514
// Say ( Kikuchi , D3b-Yam-4 ) ;
10502: LD_EXP 18
10506: PPUSH
10507: LD_STRING D3b-Yam-4
10509: PPUSH
10510: CALL_OW 88
// end ;
10514: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10515: LD_EXP 5
10519: PUSH
10520: LD_INT 2
10522: ARRAY
10523: PUSH
10524: LD_OWVAR 1
10528: LESS
10529: IFFALSE 10561
10531: GO 10533
10533: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10534: LD_EXP 19
10538: PPUSH
10539: LD_STRING D4-Har-1
10541: PPUSH
10542: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10546: LD_STRING M3
10548: PPUSH
10549: CALL_OW 337
// must_end := true ;
10553: LD_ADDR_EXP 7
10557: PUSH
10558: LD_INT 1
10560: ST_TO_ADDR
// end ;
10561: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10562: LD_EXP 5
10566: PUSH
10567: LD_INT 3
10569: ARRAY
10570: PUSH
10571: LD_OWVAR 1
10575: LESS
10576: IFFALSE 10607
10578: GO 10580
10580: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10581: LD_INT 16
10583: PPUSH
10584: CALL_OW 301
10588: NOT
10589: IFFALSE 10600
// YouLost ( TimeOut1 ) else
10591: LD_STRING TimeOut1
10593: PPUSH
10594: CALL_OW 104
10598: GO 10607
// YouLost ( TimeOut2 ) ;
10600: LD_STRING TimeOut2
10602: PPUSH
10603: CALL_OW 104
// end ;
10607: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp , m1 , m2 , m3 ;
10608: LD_EXP 9
10612: PPUSH
10613: LD_INT 9
10615: PPUSH
10616: CALL_OW 308
10620: PUSH
10621: LD_EXP 6
10625: AND
10626: IFFALSE 11726
10628: GO 10630
10630: DISABLE
10631: LD_INT 0
10633: PPUSH
10634: PPUSH
10635: PPUSH
10636: PPUSH
10637: PPUSH
10638: PPUSH
// begin wait_on := false ;
10639: LD_ADDR_VAR 0 1
10643: PUSH
10644: LD_INT 0
10646: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10647: LD_INT 1
10649: PPUSH
10650: CALL 2756 0 1
10654: PUSH
10655: LD_INT 0
10657: PLUS
10658: PUSH
10659: LD_INT 1
10661: PPUSH
10662: LD_INT 9
10664: PPUSH
10665: CALL 2847 0 2
10669: PUSH
10670: LD_INT 1
10672: PPUSH
10673: LD_INT 9
10675: PPUSH
10676: CALL 2894 0 2
10680: ADD
10681: PUSH
10682: LD_INT 0
10684: PLUS
10685: GREATER
10686: IFFALSE 10735
// case Query ( Q1 ) of 1 :
10688: LD_STRING Q1
10690: PPUSH
10691: CALL_OW 97
10695: PUSH
10696: LD_INT 1
10698: DOUBLE
10699: EQUAL
10700: IFTRUE 10704
10702: GO 10715
10704: POP
// wait_on := true ; 2 :
10705: LD_ADDR_VAR 0 1
10709: PUSH
10710: LD_INT 1
10712: ST_TO_ADDR
10713: GO 10735
10715: LD_INT 2
10717: DOUBLE
10718: EQUAL
10719: IFTRUE 10723
10721: GO 10734
10723: POP
// wait_on := false ; end ;
10724: LD_ADDR_VAR 0 1
10728: PUSH
10729: LD_INT 0
10731: ST_TO_ADDR
10732: GO 10735
10734: POP
// repeat wait ( 0 0$01 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10742: LD_VAR 0 1
10746: NOT
10747: PUSH
10748: LD_INT 1
10750: PPUSH
10751: CALL 2756 0 1
10755: PUSH
10756: LD_INT 0
10758: PLUS
10759: PUSH
10760: LD_INT 1
10762: PPUSH
10763: LD_INT 9
10765: PPUSH
10766: CALL 2847 0 2
10770: PUSH
10771: LD_INT 1
10773: PPUSH
10774: LD_INT 9
10776: PPUSH
10777: CALL 2894 0 2
10781: ADD
10782: PUSH
10783: LD_INT 0
10785: PLUS
10786: EQUAL
10787: OR
10788: IFFALSE 10735
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10794: LD_EXP 9
10798: PPUSH
10799: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10803: LD_EXP 9
10807: PPUSH
10808: LD_STRING D6-JMM-1
10810: PPUSH
10811: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10815: LD_EXP 19
10819: PPUSH
10820: LD_STRING D6-Har-1
10822: PPUSH
10823: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10827: LD_EXP 9
10831: PPUSH
10832: LD_STRING D6-JMM-2
10834: PPUSH
10835: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10839: LD_EXP 19
10843: PPUSH
10844: LD_STRING D6-Har-2
10846: PPUSH
10847: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10851: LD_EXP 9
10855: PPUSH
10856: LD_STRING D6-JMM-3
10858: PPUSH
10859: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10863: LD_EXP 19
10867: PPUSH
10868: LD_STRING D6-Har-3
10870: PPUSH
10871: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10875: LD_EXP 9
10879: PPUSH
10880: LD_STRING D6-JMM-4
10882: PPUSH
10883: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10887: LD_EXP 19
10891: PPUSH
10892: LD_STRING D6-Har-4
10894: PPUSH
10895: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10899: LD_EXP 9
10903: PPUSH
10904: LD_STRING D6-JMM-5
10906: PPUSH
10907: CALL_OW 88
// DialogueOff ;
10911: CALL_OW 7
// m1 := false ;
10915: LD_ADDR_VAR 0 4
10919: PUSH
10920: LD_INT 0
10922: ST_TO_ADDR
// m2 := false ;
10923: LD_ADDR_VAR 0 5
10927: PUSH
10928: LD_INT 0
10930: ST_TO_ADDR
// m3 := false ;
10931: LD_ADDR_VAR 0 6
10935: PUSH
10936: LD_INT 0
10938: ST_TO_ADDR
// tmp := FilterBuildings ( 3 ) ;
10939: LD_ADDR_VAR 0 3
10943: PUSH
10944: LD_INT 3
10946: PPUSH
10947: CALL 3025 0 1
10951: ST_TO_ADDR
// if tmp >= 35 then
10952: LD_VAR 0 3
10956: PUSH
10957: LD_INT 35
10959: GREATEREQUAL
10960: IFFALSE 10997
// begin AddMedal ( Destroy1 , - 1 ) ;
10962: LD_STRING Destroy1
10964: PPUSH
10965: LD_INT 1
10967: NEG
10968: PPUSH
10969: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10973: LD_STRING Destroy2
10975: PPUSH
10976: LD_INT 1
10978: NEG
10979: PPUSH
10980: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10984: LD_STRING Destroy3
10986: PPUSH
10987: LD_INT 1
10989: NEG
10990: PPUSH
10991: CALL_OW 101
// end else
10995: GO 11108
// begin AddMedal ( Destroy1 , 1 ) ;
10997: LD_STRING Destroy1
10999: PPUSH
11000: LD_INT 1
11002: PPUSH
11003: CALL_OW 101
// m1 := true ;
11007: LD_ADDR_VAR 0 4
11011: PUSH
11012: LD_INT 1
11014: ST_TO_ADDR
// if tmp >= 25 then
11015: LD_VAR 0 3
11019: PUSH
11020: LD_INT 25
11022: GREATEREQUAL
11023: IFFALSE 11049
// begin AddMedal ( Destroy2 , - 1 ) ;
11025: LD_STRING Destroy2
11027: PPUSH
11028: LD_INT 1
11030: NEG
11031: PPUSH
11032: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
11036: LD_STRING Destroy3
11038: PPUSH
11039: LD_INT 1
11041: NEG
11042: PPUSH
11043: CALL_OW 101
// end else
11047: GO 11108
// begin AddMedal ( Destroy2 , 1 ) ;
11049: LD_STRING Destroy2
11051: PPUSH
11052: LD_INT 1
11054: PPUSH
11055: CALL_OW 101
// m2 := true ;
11059: LD_ADDR_VAR 0 5
11063: PUSH
11064: LD_INT 1
11066: ST_TO_ADDR
// if tmp >= 15 then
11067: LD_VAR 0 3
11071: PUSH
11072: LD_INT 15
11074: GREATEREQUAL
11075: IFFALSE 11090
// AddMedal ( Destroy3 , - 1 ) else
11077: LD_STRING Destroy3
11079: PPUSH
11080: LD_INT 1
11082: NEG
11083: PPUSH
11084: CALL_OW 101
11088: GO 11108
// begin AddMedal ( Destroy3 , 1 ) ;
11090: LD_STRING Destroy3
11092: PPUSH
11093: LD_INT 1
11095: PPUSH
11096: CALL_OW 101
// m3 := true ;
11100: LD_ADDR_VAR 0 6
11104: PUSH
11105: LD_INT 1
11107: ST_TO_ADDR
// end ; end ; end ; if tick <= 32 32$00 then
11108: LD_OWVAR 1
11112: PUSH
11113: LD_INT 67200
11115: LESSEQUAL
11116: IFFALSE 11125
// SetAchievement ( ACH_ASPEED_7 ) ;
11118: LD_STRING ACH_ASPEED_7
11120: PPUSH
11121: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
11125: LD_VAR 0 4
11129: PUSH
11130: LD_VAR 0 5
11134: AND
11135: PUSH
11136: LD_VAR 0 6
11140: AND
11141: PUSH
11142: LD_OWVAR 67
11146: PUSH
11147: LD_INT 3
11149: EQUAL
11150: AND
11151: IFFALSE 11163
// SetAchievementEX ( ACH_AMER , 7 ) ;
11153: LD_STRING ACH_AMER
11155: PPUSH
11156: LD_INT 7
11158: PPUSH
11159: CALL_OW 564
// GiveMedals ( MAIN ) ;
11163: LD_STRING MAIN
11165: PPUSH
11166: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
11170: LD_ADDR_VAR 0 3
11174: PUSH
11175: LD_INT 1
11177: PPUSH
11178: LD_INT 9
11180: PPUSH
11181: CALL 2847 0 2
11185: PUSH
11186: LD_INT 1
11188: PPUSH
11189: LD_INT 9
11191: PPUSH
11192: CALL 2894 0 2
11196: UNION
11197: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11198: LD_VAR 0 3
11202: PPUSH
11203: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11207: LD_EXP 9
11211: PPUSH
11212: LD_EXP 3
11216: PUSH
11217: LD_STRING JMM
11219: STR
11220: PPUSH
11221: CALL_OW 38
// if Brown in tmp then
11225: LD_EXP 10
11229: PUSH
11230: LD_VAR 0 3
11234: IN
11235: IFFALSE 11255
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
11237: LD_EXP 10
11241: PPUSH
11242: LD_EXP 3
11246: PUSH
11247: LD_STRING Brown
11249: STR
11250: PPUSH
11251: CALL_OW 38
// if Donaldson in tmp then
11255: LD_EXP 11
11259: PUSH
11260: LD_VAR 0 3
11264: IN
11265: IFFALSE 11285
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
11267: LD_EXP 11
11271: PPUSH
11272: LD_EXP 3
11276: PUSH
11277: LD_STRING Donaldson
11279: STR
11280: PPUSH
11281: CALL_OW 38
// if Bobby in tmp then
11285: LD_EXP 12
11289: PUSH
11290: LD_VAR 0 3
11294: IN
11295: IFFALSE 11315
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11297: LD_EXP 12
11301: PPUSH
11302: LD_EXP 3
11306: PUSH
11307: LD_STRING Bobby
11309: STR
11310: PPUSH
11311: CALL_OW 38
// if Cyrus in tmp then
11315: LD_EXP 13
11319: PUSH
11320: LD_VAR 0 3
11324: IN
11325: IFFALSE 11345
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11327: LD_EXP 13
11331: PPUSH
11332: LD_EXP 3
11336: PUSH
11337: LD_STRING Cyrus
11339: STR
11340: PPUSH
11341: CALL_OW 38
// if Lisa in tmp then
11345: LD_EXP 14
11349: PUSH
11350: LD_VAR 0 3
11354: IN
11355: IFFALSE 11375
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11357: LD_EXP 14
11361: PPUSH
11362: LD_EXP 3
11366: PUSH
11367: LD_STRING Lisa
11369: STR
11370: PPUSH
11371: CALL_OW 38
// if Frank in tmp then
11375: LD_EXP 15
11379: PUSH
11380: LD_VAR 0 3
11384: IN
11385: IFFALSE 11405
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11387: LD_EXP 15
11391: PPUSH
11392: LD_EXP 3
11396: PUSH
11397: LD_STRING Frank
11399: STR
11400: PPUSH
11401: CALL_OW 38
// if Gladstone in tmp then
11405: LD_EXP 16
11409: PUSH
11410: LD_VAR 0 3
11414: IN
11415: IFFALSE 11435
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
11417: LD_EXP 16
11421: PPUSH
11422: LD_EXP 3
11426: PUSH
11427: LD_STRING Gladstone
11429: STR
11430: PPUSH
11431: CALL_OW 38
// if Khatam in tmp then
11435: LD_EXP 17
11439: PUSH
11440: LD_VAR 0 3
11444: IN
11445: IFFALSE 11465
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11447: LD_EXP 17
11451: PPUSH
11452: LD_EXP 3
11456: PUSH
11457: LD_STRING Khatam
11459: STR
11460: PPUSH
11461: CALL_OW 38
// if Kikuchi in tmp then
11465: LD_EXP 18
11469: PUSH
11470: LD_VAR 0 3
11474: IN
11475: IFFALSE 11495
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11477: LD_EXP 18
11481: PPUSH
11482: LD_EXP 3
11486: PUSH
11487: LD_STRING Kikuchi
11489: STR
11490: PPUSH
11491: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11495: LD_VAR 0 3
11499: PUSH
11500: LD_EXP 9
11504: PUSH
11505: LD_EXP 10
11509: PUSH
11510: LD_EXP 11
11514: PUSH
11515: LD_EXP 12
11519: PUSH
11520: LD_EXP 13
11524: PUSH
11525: LD_EXP 14
11529: PUSH
11530: LD_EXP 15
11534: PUSH
11535: LD_EXP 16
11539: PUSH
11540: LD_EXP 18
11544: PUSH
11545: LD_EXP 17
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: DIFF
11562: PPUSH
11563: LD_EXP 3
11567: PUSH
11568: LD_STRING others
11570: STR
11571: PPUSH
11572: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11576: LD_OWVAR 1
11580: PPUSH
11581: LD_STRING 07_time
11583: PPUSH
11584: CALL_OW 39
// tmp := [ ] ;
11588: LD_ADDR_VAR 0 3
11592: PUSH
11593: EMPTY
11594: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11595: LD_ADDR_VAR 0 2
11599: PUSH
11600: LD_INT 9
11602: PPUSH
11603: LD_INT 22
11605: PUSH
11606: LD_INT 1
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: PUSH
11613: LD_INT 23
11615: PUSH
11616: LD_INT 1
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PUSH
11623: LD_INT 21
11625: PUSH
11626: LD_INT 2
11628: PUSH
11629: EMPTY
11630: LIST
11631: LIST
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: LIST
11637: PUSH
11638: EMPTY
11639: LIST
11640: PPUSH
11641: CALL_OW 70
11645: PUSH
11646: FOR_IN
11647: IFFALSE 11708
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11649: LD_ADDR_VAR 0 3
11653: PUSH
11654: LD_VAR 0 3
11658: PUSH
11659: LD_VAR 0 2
11663: PPUSH
11664: CALL_OW 265
11668: PUSH
11669: LD_VAR 0 2
11673: PPUSH
11674: CALL_OW 262
11678: PUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL_OW 263
11688: PUSH
11689: LD_VAR 0 2
11693: PPUSH
11694: CALL_OW 264
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: ADD
11705: ST_TO_ADDR
11706: GO 11646
11708: POP
11709: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11710: LD_VAR 0 3
11714: PPUSH
11715: LD_STRING 07_vehicles
11717: PPUSH
11718: CALL_OW 39
// YouWin ;
11722: CALL_OW 103
// end ; end_of_file
11726: PPOPN 6
11728: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11729: LD_VAR 0 1
11733: PUSH
11734: LD_EXP 9
11738: EQUAL
11739: IFFALSE 11748
// YouLost ( JMM ) ;
11741: LD_STRING JMM
11743: PPUSH
11744: CALL_OW 104
// if GetType ( un ) = unit_building then
11748: LD_VAR 0 1
11752: PPUSH
11753: CALL_OW 247
11757: PUSH
11758: LD_INT 3
11760: EQUAL
11761: IFFALSE 11777
// buildings_counter := buildings_counter + 1 ;
11763: LD_ADDR_EXP 4
11767: PUSH
11768: LD_EXP 4
11772: PUSH
11773: LD_INT 1
11775: PLUS
11776: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11777: LD_VAR 0 1
11781: PUSH
11782: LD_INT 6
11784: PPUSH
11785: LD_INT 2
11787: PUSH
11788: LD_INT 30
11790: PUSH
11791: LD_INT 33
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 30
11800: PUSH
11801: LD_INT 32
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: LIST
11812: PPUSH
11813: CALL_OW 70
11817: IN
11818: IFFALSE 11877
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11820: LD_ADDR_EXP 20
11824: PUSH
11825: LD_EXP 20
11829: PUSH
11830: LD_VAR 0 1
11834: PPUSH
11835: CALL_OW 266
11839: PUSH
11840: LD_VAR 0 1
11844: PPUSH
11845: CALL_OW 250
11849: PUSH
11850: LD_VAR 0 1
11854: PPUSH
11855: CALL_OW 251
11859: PUSH
11860: LD_VAR 0 1
11864: PPUSH
11865: CALL_OW 254
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: ADD
11876: ST_TO_ADDR
// if un = ru_dep_main then
11877: LD_VAR 0 1
11881: PUSH
11882: LD_INT 16
11884: EQUAL
11885: IFFALSE 11894
// ChangeMissionObjectives ( M1a ) ;
11887: LD_STRING M1a
11889: PPUSH
11890: CALL_OW 337
// if GetType ( un ) = unit_human and GetSide ( un ) = 3 then
11894: LD_VAR 0 1
11898: PPUSH
11899: CALL_OW 247
11903: PUSH
11904: LD_INT 1
11906: EQUAL
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL_OW 255
11917: PUSH
11918: LD_INT 3
11920: EQUAL
11921: AND
11922: IFFALSE 11938
// kill_counter := kill_counter + 1 ;
11924: LD_ADDR_EXP 8
11928: PUSH
11929: LD_EXP 8
11933: PUSH
11934: LD_INT 1
11936: PLUS
11937: ST_TO_ADDR
// end ;
11938: PPOPN 1
11940: END
// on BuildingStarted ( b , builder ) do var i ;
11941: LD_INT 0
11943: PPUSH
// begin if GetSide ( b ) = 3 then
11944: LD_VAR 0 1
11948: PPUSH
11949: CALL_OW 255
11953: PUSH
11954: LD_INT 3
11956: EQUAL
11957: IFFALSE 11997
// for i = 1 to 4 do
11959: LD_ADDR_VAR 0 3
11963: PUSH
11964: DOUBLE
11965: LD_INT 1
11967: DEC
11968: ST_TO_ADDR
11969: LD_INT 4
11971: PUSH
11972: FOR_TO
11973: IFFALSE 11995
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11975: LD_ADDR_EXP 20
11979: PUSH
11980: LD_EXP 20
11984: PPUSH
11985: LD_INT 1
11987: PPUSH
11988: CALL_OW 3
11992: ST_TO_ADDR
11993: GO 11972
11995: POP
11996: POP
// end ;
11997: PPOPN 3
11999: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
12000: LD_VAR 0 1
12004: PPUSH
12005: CALL_OW 266
12009: PUSH
12010: LD_INT 32
12012: PUSH
12013: LD_INT 33
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: IN
12020: IFFALSE 12034
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
12022: LD_VAR 0 1
12026: PPUSH
12027: LD_INT 43
12029: PPUSH
12030: CALL_OW 148
12034: PPOPN 1
12036: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
12037: LD_VAR 0 1
12041: PUSH
12042: LD_INT 22
12044: PUSH
12045: LD_INT 3
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 2
12054: PUSH
12055: LD_INT 30
12057: PUSH
12058: LD_INT 31
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 30
12067: PUSH
12068: LD_INT 32
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PPUSH
12084: CALL_OW 69
12088: IN
12089: IFFALSE 12111
// GoToAnotherTower ( un , b , 143 , 143 ) ;
12091: LD_VAR 0 2
12095: PPUSH
12096: LD_VAR 0 1
12100: PPUSH
12101: LD_INT 143
12103: PPUSH
12104: LD_INT 143
12106: PPUSH
12107: CALL 2200 0 4
// end ;
12111: PPOPN 2
12113: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
12114: LD_VAR 0 1
12118: PUSH
12119: LD_INT 22
12121: PUSH
12122: LD_INT 3
12124: PUSH
12125: EMPTY
12126: LIST
12127: LIST
12128: PUSH
12129: LD_INT 30
12131: PUSH
12132: LD_INT 32
12134: PUSH
12135: EMPTY
12136: LIST
12137: LIST
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PPUSH
12143: CALL_OW 69
12147: IN
12148: IFFALSE 12162
// SetTag ( b , 0 ) ;
12150: LD_VAR 0 1
12154: PPUSH
12155: LD_INT 0
12157: PPUSH
12158: CALL_OW 109
// end ; end_of_file
12162: PPOPN 2
12164: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
12165: GO 12167
12167: DISABLE
// begin ru_radar := 98 ;
12168: LD_ADDR_EXP 21
12172: PUSH
12173: LD_INT 98
12175: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
12176: LD_ADDR_EXP 22
12180: PUSH
12181: LD_INT 89
12183: ST_TO_ADDR
// us_hack := 99 ;
12184: LD_ADDR_EXP 23
12188: PUSH
12189: LD_INT 99
12191: ST_TO_ADDR
// us_artillery := 97 ;
12192: LD_ADDR_EXP 24
12196: PUSH
12197: LD_INT 97
12199: ST_TO_ADDR
// ar_bio_bomb := 91 ;
12200: LD_ADDR_EXP 25
12204: PUSH
12205: LD_INT 91
12207: ST_TO_ADDR
// tech_Artillery := 80 ;
12208: LD_ADDR_EXP 26
12212: PUSH
12213: LD_INT 80
12215: ST_TO_ADDR
// tech_RadMat := 81 ;
12216: LD_ADDR_EXP 27
12220: PUSH
12221: LD_INT 81
12223: ST_TO_ADDR
// tech_BasicTools := 82 ;
12224: LD_ADDR_EXP 28
12228: PUSH
12229: LD_INT 82
12231: ST_TO_ADDR
// tech_Cargo := 83 ;
12232: LD_ADDR_EXP 29
12236: PUSH
12237: LD_INT 83
12239: ST_TO_ADDR
// tech_Track := 84 ;
12240: LD_ADDR_EXP 30
12244: PUSH
12245: LD_INT 84
12247: ST_TO_ADDR
// tech_Crane := 85 ;
12248: LD_ADDR_EXP 31
12252: PUSH
12253: LD_INT 85
12255: ST_TO_ADDR
// tech_Bulldozer := 86 ;
12256: LD_ADDR_EXP 32
12260: PUSH
12261: LD_INT 86
12263: ST_TO_ADDR
// tech_Hovercraft := 87 ;
12264: LD_ADDR_EXP 33
12268: PUSH
12269: LD_INT 87
12271: ST_TO_ADDR
// end ; end_of_file end_of_file
12272: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
12273: GO 12275
12275: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
12276: LD_STRING initStreamRollete();
12278: PPUSH
12279: CALL_OW 559
// InitStreamMode ;
12283: CALL 12292 0 0
// DefineStreamItems ( ) ;
12287: CALL 12732 0 0
// end ;
12291: END
// function InitStreamMode ; begin
12292: LD_INT 0
12294: PPUSH
// streamModeActive := false ;
12295: LD_ADDR_EXP 34
12299: PUSH
12300: LD_INT 0
12302: ST_TO_ADDR
// normalCounter := 36 ;
12303: LD_ADDR_EXP 35
12307: PUSH
12308: LD_INT 36
12310: ST_TO_ADDR
// hardcoreCounter := 16 ;
12311: LD_ADDR_EXP 36
12315: PUSH
12316: LD_INT 16
12318: ST_TO_ADDR
// sRocket := false ;
12319: LD_ADDR_EXP 39
12323: PUSH
12324: LD_INT 0
12326: ST_TO_ADDR
// sSpeed := false ;
12327: LD_ADDR_EXP 38
12331: PUSH
12332: LD_INT 0
12334: ST_TO_ADDR
// sEngine := false ;
12335: LD_ADDR_EXP 40
12339: PUSH
12340: LD_INT 0
12342: ST_TO_ADDR
// sSpec := false ;
12343: LD_ADDR_EXP 37
12347: PUSH
12348: LD_INT 0
12350: ST_TO_ADDR
// sLevel := false ;
12351: LD_ADDR_EXP 41
12355: PUSH
12356: LD_INT 0
12358: ST_TO_ADDR
// sArmoury := false ;
12359: LD_ADDR_EXP 42
12363: PUSH
12364: LD_INT 0
12366: ST_TO_ADDR
// sRadar := false ;
12367: LD_ADDR_EXP 43
12371: PUSH
12372: LD_INT 0
12374: ST_TO_ADDR
// sBunker := false ;
12375: LD_ADDR_EXP 44
12379: PUSH
12380: LD_INT 0
12382: ST_TO_ADDR
// sHack := false ;
12383: LD_ADDR_EXP 45
12387: PUSH
12388: LD_INT 0
12390: ST_TO_ADDR
// sFire := false ;
12391: LD_ADDR_EXP 46
12395: PUSH
12396: LD_INT 0
12398: ST_TO_ADDR
// sRefresh := false ;
12399: LD_ADDR_EXP 47
12403: PUSH
12404: LD_INT 0
12406: ST_TO_ADDR
// sExp := false ;
12407: LD_ADDR_EXP 48
12411: PUSH
12412: LD_INT 0
12414: ST_TO_ADDR
// sDepot := false ;
12415: LD_ADDR_EXP 49
12419: PUSH
12420: LD_INT 0
12422: ST_TO_ADDR
// sFlag := false ;
12423: LD_ADDR_EXP 50
12427: PUSH
12428: LD_INT 0
12430: ST_TO_ADDR
// sKamikadze := false ;
12431: LD_ADDR_EXP 58
12435: PUSH
12436: LD_INT 0
12438: ST_TO_ADDR
// sTroll := false ;
12439: LD_ADDR_EXP 59
12443: PUSH
12444: LD_INT 0
12446: ST_TO_ADDR
// sSlow := false ;
12447: LD_ADDR_EXP 60
12451: PUSH
12452: LD_INT 0
12454: ST_TO_ADDR
// sLack := false ;
12455: LD_ADDR_EXP 61
12459: PUSH
12460: LD_INT 0
12462: ST_TO_ADDR
// sTank := false ;
12463: LD_ADDR_EXP 63
12467: PUSH
12468: LD_INT 0
12470: ST_TO_ADDR
// sRemote := false ;
12471: LD_ADDR_EXP 64
12475: PUSH
12476: LD_INT 0
12478: ST_TO_ADDR
// sPowell := false ;
12479: LD_ADDR_EXP 65
12483: PUSH
12484: LD_INT 0
12486: ST_TO_ADDR
// sTeleport := false ;
12487: LD_ADDR_EXP 68
12491: PUSH
12492: LD_INT 0
12494: ST_TO_ADDR
// sOilTower := false ;
12495: LD_ADDR_EXP 70
12499: PUSH
12500: LD_INT 0
12502: ST_TO_ADDR
// sShovel := false ;
12503: LD_ADDR_EXP 71
12507: PUSH
12508: LD_INT 0
12510: ST_TO_ADDR
// sSheik := false ;
12511: LD_ADDR_EXP 72
12515: PUSH
12516: LD_INT 0
12518: ST_TO_ADDR
// sEarthquake := false ;
12519: LD_ADDR_EXP 74
12523: PUSH
12524: LD_INT 0
12526: ST_TO_ADDR
// sAI := false ;
12527: LD_ADDR_EXP 75
12531: PUSH
12532: LD_INT 0
12534: ST_TO_ADDR
// sCargo := false ;
12535: LD_ADDR_EXP 78
12539: PUSH
12540: LD_INT 0
12542: ST_TO_ADDR
// sDLaser := false ;
12543: LD_ADDR_EXP 79
12547: PUSH
12548: LD_INT 0
12550: ST_TO_ADDR
// sExchange := false ;
12551: LD_ADDR_EXP 80
12555: PUSH
12556: LD_INT 0
12558: ST_TO_ADDR
// sFac := false ;
12559: LD_ADDR_EXP 81
12563: PUSH
12564: LD_INT 0
12566: ST_TO_ADDR
// sPower := false ;
12567: LD_ADDR_EXP 82
12571: PUSH
12572: LD_INT 0
12574: ST_TO_ADDR
// sRandom := false ;
12575: LD_ADDR_EXP 83
12579: PUSH
12580: LD_INT 0
12582: ST_TO_ADDR
// sShield := false ;
12583: LD_ADDR_EXP 84
12587: PUSH
12588: LD_INT 0
12590: ST_TO_ADDR
// sTime := false ;
12591: LD_ADDR_EXP 85
12595: PUSH
12596: LD_INT 0
12598: ST_TO_ADDR
// sTools := false ;
12599: LD_ADDR_EXP 86
12603: PUSH
12604: LD_INT 0
12606: ST_TO_ADDR
// sSold := false ;
12607: LD_ADDR_EXP 51
12611: PUSH
12612: LD_INT 0
12614: ST_TO_ADDR
// sDiff := false ;
12615: LD_ADDR_EXP 52
12619: PUSH
12620: LD_INT 0
12622: ST_TO_ADDR
// sFog := false ;
12623: LD_ADDR_EXP 55
12627: PUSH
12628: LD_INT 0
12630: ST_TO_ADDR
// sReset := false ;
12631: LD_ADDR_EXP 56
12635: PUSH
12636: LD_INT 0
12638: ST_TO_ADDR
// sSun := false ;
12639: LD_ADDR_EXP 57
12643: PUSH
12644: LD_INT 0
12646: ST_TO_ADDR
// sTiger := false ;
12647: LD_ADDR_EXP 53
12651: PUSH
12652: LD_INT 0
12654: ST_TO_ADDR
// sBomb := false ;
12655: LD_ADDR_EXP 54
12659: PUSH
12660: LD_INT 0
12662: ST_TO_ADDR
// sWound := false ;
12663: LD_ADDR_EXP 62
12667: PUSH
12668: LD_INT 0
12670: ST_TO_ADDR
// sBetray := false ;
12671: LD_ADDR_EXP 66
12675: PUSH
12676: LD_INT 0
12678: ST_TO_ADDR
// sContamin := false ;
12679: LD_ADDR_EXP 67
12683: PUSH
12684: LD_INT 0
12686: ST_TO_ADDR
// sOil := false ;
12687: LD_ADDR_EXP 69
12691: PUSH
12692: LD_INT 0
12694: ST_TO_ADDR
// sStu := false ;
12695: LD_ADDR_EXP 73
12699: PUSH
12700: LD_INT 0
12702: ST_TO_ADDR
// sBazooka := false ;
12703: LD_ADDR_EXP 76
12707: PUSH
12708: LD_INT 0
12710: ST_TO_ADDR
// sMortar := false ;
12711: LD_ADDR_EXP 77
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// sRanger := false ;
12719: LD_ADDR_EXP 87
12723: PUSH
12724: LD_INT 0
12726: ST_TO_ADDR
// end ;
12727: LD_VAR 0 1
12731: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12732: LD_INT 0
12734: PPUSH
12735: PPUSH
12736: PPUSH
12737: PPUSH
12738: PPUSH
// result := [ ] ;
12739: LD_ADDR_VAR 0 1
12743: PUSH
12744: EMPTY
12745: ST_TO_ADDR
// if campaign_id = 1 then
12746: LD_OWVAR 69
12750: PUSH
12751: LD_INT 1
12753: EQUAL
12754: IFFALSE 15692
// begin case mission_number of 1 :
12756: LD_OWVAR 70
12760: PUSH
12761: LD_INT 1
12763: DOUBLE
12764: EQUAL
12765: IFTRUE 12769
12767: GO 12833
12769: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12770: LD_ADDR_VAR 0 1
12774: PUSH
12775: LD_INT 2
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: LD_INT 11
12783: PUSH
12784: LD_INT 12
12786: PUSH
12787: LD_INT 15
12789: PUSH
12790: LD_INT 16
12792: PUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 23
12798: PUSH
12799: LD_INT 26
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 101
12815: PUSH
12816: LD_INT 102
12818: PUSH
12819: LD_INT 106
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: LIST
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: ST_TO_ADDR
12831: GO 15690
12833: LD_INT 2
12835: DOUBLE
12836: EQUAL
12837: IFTRUE 12841
12839: GO 12913
12841: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12842: LD_ADDR_VAR 0 1
12846: PUSH
12847: LD_INT 2
12849: PUSH
12850: LD_INT 4
12852: PUSH
12853: LD_INT 11
12855: PUSH
12856: LD_INT 12
12858: PUSH
12859: LD_INT 15
12861: PUSH
12862: LD_INT 16
12864: PUSH
12865: LD_INT 22
12867: PUSH
12868: LD_INT 23
12870: PUSH
12871: LD_INT 26
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 101
12887: PUSH
12888: LD_INT 102
12890: PUSH
12891: LD_INT 105
12893: PUSH
12894: LD_INT 106
12896: PUSH
12897: LD_INT 108
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: LIST
12904: LIST
12905: LIST
12906: PUSH
12907: EMPTY
12908: LIST
12909: LIST
12910: ST_TO_ADDR
12911: GO 15690
12913: LD_INT 3
12915: DOUBLE
12916: EQUAL
12917: IFTRUE 12921
12919: GO 12997
12921: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12922: LD_ADDR_VAR 0 1
12926: PUSH
12927: LD_INT 2
12929: PUSH
12930: LD_INT 4
12932: PUSH
12933: LD_INT 5
12935: PUSH
12936: LD_INT 11
12938: PUSH
12939: LD_INT 12
12941: PUSH
12942: LD_INT 15
12944: PUSH
12945: LD_INT 16
12947: PUSH
12948: LD_INT 22
12950: PUSH
12951: LD_INT 26
12953: PUSH
12954: LD_INT 36
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PUSH
12969: LD_INT 101
12971: PUSH
12972: LD_INT 102
12974: PUSH
12975: LD_INT 105
12977: PUSH
12978: LD_INT 106
12980: PUSH
12981: LD_INT 108
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: ST_TO_ADDR
12995: GO 15690
12997: LD_INT 4
12999: DOUBLE
13000: EQUAL
13001: IFTRUE 13005
13003: GO 13089
13005: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
13006: LD_ADDR_VAR 0 1
13010: PUSH
13011: LD_INT 2
13013: PUSH
13014: LD_INT 4
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 8
13022: PUSH
13023: LD_INT 11
13025: PUSH
13026: LD_INT 12
13028: PUSH
13029: LD_INT 15
13031: PUSH
13032: LD_INT 16
13034: PUSH
13035: LD_INT 22
13037: PUSH
13038: LD_INT 23
13040: PUSH
13041: LD_INT 26
13043: PUSH
13044: LD_INT 36
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: PUSH
13061: LD_INT 101
13063: PUSH
13064: LD_INT 102
13066: PUSH
13067: LD_INT 105
13069: PUSH
13070: LD_INT 106
13072: PUSH
13073: LD_INT 108
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: ST_TO_ADDR
13087: GO 15690
13089: LD_INT 5
13091: DOUBLE
13092: EQUAL
13093: IFTRUE 13097
13095: GO 13197
13097: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
13098: LD_ADDR_VAR 0 1
13102: PUSH
13103: LD_INT 2
13105: PUSH
13106: LD_INT 4
13108: PUSH
13109: LD_INT 5
13111: PUSH
13112: LD_INT 6
13114: PUSH
13115: LD_INT 8
13117: PUSH
13118: LD_INT 11
13120: PUSH
13121: LD_INT 12
13123: PUSH
13124: LD_INT 15
13126: PUSH
13127: LD_INT 16
13129: PUSH
13130: LD_INT 22
13132: PUSH
13133: LD_INT 23
13135: PUSH
13136: LD_INT 25
13138: PUSH
13139: LD_INT 26
13141: PUSH
13142: LD_INT 36
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: LIST
13152: LIST
13153: LIST
13154: LIST
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 101
13163: PUSH
13164: LD_INT 102
13166: PUSH
13167: LD_INT 105
13169: PUSH
13170: LD_INT 106
13172: PUSH
13173: LD_INT 108
13175: PUSH
13176: LD_INT 109
13178: PUSH
13179: LD_INT 112
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: PUSH
13191: EMPTY
13192: LIST
13193: LIST
13194: ST_TO_ADDR
13195: GO 15690
13197: LD_INT 6
13199: DOUBLE
13200: EQUAL
13201: IFTRUE 13205
13203: GO 13325
13205: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
13206: LD_ADDR_VAR 0 1
13210: PUSH
13211: LD_INT 2
13213: PUSH
13214: LD_INT 4
13216: PUSH
13217: LD_INT 5
13219: PUSH
13220: LD_INT 6
13222: PUSH
13223: LD_INT 8
13225: PUSH
13226: LD_INT 11
13228: PUSH
13229: LD_INT 12
13231: PUSH
13232: LD_INT 15
13234: PUSH
13235: LD_INT 16
13237: PUSH
13238: LD_INT 20
13240: PUSH
13241: LD_INT 21
13243: PUSH
13244: LD_INT 22
13246: PUSH
13247: LD_INT 23
13249: PUSH
13250: LD_INT 25
13252: PUSH
13253: LD_INT 26
13255: PUSH
13256: LD_INT 30
13258: PUSH
13259: LD_INT 31
13261: PUSH
13262: LD_INT 32
13264: PUSH
13265: LD_INT 36
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: LIST
13283: LIST
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_INT 101
13291: PUSH
13292: LD_INT 102
13294: PUSH
13295: LD_INT 105
13297: PUSH
13298: LD_INT 106
13300: PUSH
13301: LD_INT 108
13303: PUSH
13304: LD_INT 109
13306: PUSH
13307: LD_INT 112
13309: PUSH
13310: EMPTY
13311: LIST
13312: LIST
13313: LIST
13314: LIST
13315: LIST
13316: LIST
13317: LIST
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: ST_TO_ADDR
13323: GO 15690
13325: LD_INT 7
13327: DOUBLE
13328: EQUAL
13329: IFTRUE 13333
13331: GO 13433
13333: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
13334: LD_ADDR_VAR 0 1
13338: PUSH
13339: LD_INT 2
13341: PUSH
13342: LD_INT 4
13344: PUSH
13345: LD_INT 5
13347: PUSH
13348: LD_INT 7
13350: PUSH
13351: LD_INT 11
13353: PUSH
13354: LD_INT 12
13356: PUSH
13357: LD_INT 15
13359: PUSH
13360: LD_INT 16
13362: PUSH
13363: LD_INT 20
13365: PUSH
13366: LD_INT 21
13368: PUSH
13369: LD_INT 22
13371: PUSH
13372: LD_INT 23
13374: PUSH
13375: LD_INT 25
13377: PUSH
13378: LD_INT 26
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: PUSH
13397: LD_INT 101
13399: PUSH
13400: LD_INT 102
13402: PUSH
13403: LD_INT 103
13405: PUSH
13406: LD_INT 105
13408: PUSH
13409: LD_INT 106
13411: PUSH
13412: LD_INT 108
13414: PUSH
13415: LD_INT 112
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: PUSH
13427: EMPTY
13428: LIST
13429: LIST
13430: ST_TO_ADDR
13431: GO 15690
13433: LD_INT 8
13435: DOUBLE
13436: EQUAL
13437: IFTRUE 13441
13439: GO 13569
13441: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13442: LD_ADDR_VAR 0 1
13446: PUSH
13447: LD_INT 2
13449: PUSH
13450: LD_INT 4
13452: PUSH
13453: LD_INT 5
13455: PUSH
13456: LD_INT 6
13458: PUSH
13459: LD_INT 7
13461: PUSH
13462: LD_INT 8
13464: PUSH
13465: LD_INT 11
13467: PUSH
13468: LD_INT 12
13470: PUSH
13471: LD_INT 15
13473: PUSH
13474: LD_INT 16
13476: PUSH
13477: LD_INT 20
13479: PUSH
13480: LD_INT 21
13482: PUSH
13483: LD_INT 22
13485: PUSH
13486: LD_INT 23
13488: PUSH
13489: LD_INT 25
13491: PUSH
13492: LD_INT 26
13494: PUSH
13495: LD_INT 30
13497: PUSH
13498: LD_INT 31
13500: PUSH
13501: LD_INT 32
13503: PUSH
13504: LD_INT 36
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: LIST
13511: LIST
13512: LIST
13513: LIST
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: LIST
13524: LIST
13525: LIST
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 101
13531: PUSH
13532: LD_INT 102
13534: PUSH
13535: LD_INT 103
13537: PUSH
13538: LD_INT 105
13540: PUSH
13541: LD_INT 106
13543: PUSH
13544: LD_INT 108
13546: PUSH
13547: LD_INT 109
13549: PUSH
13550: LD_INT 112
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: ST_TO_ADDR
13567: GO 15690
13569: LD_INT 9
13571: DOUBLE
13572: EQUAL
13573: IFTRUE 13577
13575: GO 13713
13577: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13578: LD_ADDR_VAR 0 1
13582: PUSH
13583: LD_INT 2
13585: PUSH
13586: LD_INT 4
13588: PUSH
13589: LD_INT 5
13591: PUSH
13592: LD_INT 6
13594: PUSH
13595: LD_INT 7
13597: PUSH
13598: LD_INT 8
13600: PUSH
13601: LD_INT 11
13603: PUSH
13604: LD_INT 12
13606: PUSH
13607: LD_INT 15
13609: PUSH
13610: LD_INT 16
13612: PUSH
13613: LD_INT 20
13615: PUSH
13616: LD_INT 21
13618: PUSH
13619: LD_INT 22
13621: PUSH
13622: LD_INT 23
13624: PUSH
13625: LD_INT 25
13627: PUSH
13628: LD_INT 26
13630: PUSH
13631: LD_INT 28
13633: PUSH
13634: LD_INT 30
13636: PUSH
13637: LD_INT 31
13639: PUSH
13640: LD_INT 32
13642: PUSH
13643: LD_INT 36
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: LIST
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: LIST
13664: LIST
13665: LIST
13666: LIST
13667: LIST
13668: PUSH
13669: LD_INT 101
13671: PUSH
13672: LD_INT 102
13674: PUSH
13675: LD_INT 103
13677: PUSH
13678: LD_INT 105
13680: PUSH
13681: LD_INT 106
13683: PUSH
13684: LD_INT 108
13686: PUSH
13687: LD_INT 109
13689: PUSH
13690: LD_INT 112
13692: PUSH
13693: LD_INT 114
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: PUSH
13707: EMPTY
13708: LIST
13709: LIST
13710: ST_TO_ADDR
13711: GO 15690
13713: LD_INT 10
13715: DOUBLE
13716: EQUAL
13717: IFTRUE 13721
13719: GO 13905
13721: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13722: LD_ADDR_VAR 0 1
13726: PUSH
13727: LD_INT 2
13729: PUSH
13730: LD_INT 4
13732: PUSH
13733: LD_INT 5
13735: PUSH
13736: LD_INT 6
13738: PUSH
13739: LD_INT 7
13741: PUSH
13742: LD_INT 8
13744: PUSH
13745: LD_INT 9
13747: PUSH
13748: LD_INT 10
13750: PUSH
13751: LD_INT 11
13753: PUSH
13754: LD_INT 12
13756: PUSH
13757: LD_INT 13
13759: PUSH
13760: LD_INT 14
13762: PUSH
13763: LD_INT 15
13765: PUSH
13766: LD_INT 16
13768: PUSH
13769: LD_INT 17
13771: PUSH
13772: LD_INT 18
13774: PUSH
13775: LD_INT 19
13777: PUSH
13778: LD_INT 20
13780: PUSH
13781: LD_INT 21
13783: PUSH
13784: LD_INT 22
13786: PUSH
13787: LD_INT 23
13789: PUSH
13790: LD_INT 24
13792: PUSH
13793: LD_INT 25
13795: PUSH
13796: LD_INT 26
13798: PUSH
13799: LD_INT 28
13801: PUSH
13802: LD_INT 30
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: LD_INT 32
13810: PUSH
13811: LD_INT 36
13813: PUSH
13814: EMPTY
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: LIST
13830: LIST
13831: LIST
13832: LIST
13833: LIST
13834: LIST
13835: LIST
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: LIST
13842: LIST
13843: LIST
13844: PUSH
13845: LD_INT 101
13847: PUSH
13848: LD_INT 102
13850: PUSH
13851: LD_INT 103
13853: PUSH
13854: LD_INT 104
13856: PUSH
13857: LD_INT 105
13859: PUSH
13860: LD_INT 106
13862: PUSH
13863: LD_INT 107
13865: PUSH
13866: LD_INT 108
13868: PUSH
13869: LD_INT 109
13871: PUSH
13872: LD_INT 110
13874: PUSH
13875: LD_INT 111
13877: PUSH
13878: LD_INT 112
13880: PUSH
13881: LD_INT 114
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: ST_TO_ADDR
13903: GO 15690
13905: LD_INT 11
13907: DOUBLE
13908: EQUAL
13909: IFTRUE 13913
13911: GO 14105
13913: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13914: LD_ADDR_VAR 0 1
13918: PUSH
13919: LD_INT 2
13921: PUSH
13922: LD_INT 3
13924: PUSH
13925: LD_INT 4
13927: PUSH
13928: LD_INT 5
13930: PUSH
13931: LD_INT 6
13933: PUSH
13934: LD_INT 7
13936: PUSH
13937: LD_INT 8
13939: PUSH
13940: LD_INT 9
13942: PUSH
13943: LD_INT 10
13945: PUSH
13946: LD_INT 11
13948: PUSH
13949: LD_INT 12
13951: PUSH
13952: LD_INT 13
13954: PUSH
13955: LD_INT 14
13957: PUSH
13958: LD_INT 15
13960: PUSH
13961: LD_INT 16
13963: PUSH
13964: LD_INT 17
13966: PUSH
13967: LD_INT 18
13969: PUSH
13970: LD_INT 19
13972: PUSH
13973: LD_INT 20
13975: PUSH
13976: LD_INT 21
13978: PUSH
13979: LD_INT 22
13981: PUSH
13982: LD_INT 23
13984: PUSH
13985: LD_INT 24
13987: PUSH
13988: LD_INT 25
13990: PUSH
13991: LD_INT 26
13993: PUSH
13994: LD_INT 28
13996: PUSH
13997: LD_INT 30
13999: PUSH
14000: LD_INT 31
14002: PUSH
14003: LD_INT 32
14005: PUSH
14006: LD_INT 34
14008: PUSH
14009: LD_INT 36
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: PUSH
14045: LD_INT 101
14047: PUSH
14048: LD_INT 102
14050: PUSH
14051: LD_INT 103
14053: PUSH
14054: LD_INT 104
14056: PUSH
14057: LD_INT 105
14059: PUSH
14060: LD_INT 106
14062: PUSH
14063: LD_INT 107
14065: PUSH
14066: LD_INT 108
14068: PUSH
14069: LD_INT 109
14071: PUSH
14072: LD_INT 110
14074: PUSH
14075: LD_INT 111
14077: PUSH
14078: LD_INT 112
14080: PUSH
14081: LD_INT 114
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: ST_TO_ADDR
14103: GO 15690
14105: LD_INT 12
14107: DOUBLE
14108: EQUAL
14109: IFTRUE 14113
14111: GO 14321
14113: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
14114: LD_ADDR_VAR 0 1
14118: PUSH
14119: LD_INT 1
14121: PUSH
14122: LD_INT 2
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 4
14130: PUSH
14131: LD_INT 5
14133: PUSH
14134: LD_INT 6
14136: PUSH
14137: LD_INT 7
14139: PUSH
14140: LD_INT 8
14142: PUSH
14143: LD_INT 9
14145: PUSH
14146: LD_INT 10
14148: PUSH
14149: LD_INT 11
14151: PUSH
14152: LD_INT 12
14154: PUSH
14155: LD_INT 13
14157: PUSH
14158: LD_INT 14
14160: PUSH
14161: LD_INT 15
14163: PUSH
14164: LD_INT 16
14166: PUSH
14167: LD_INT 17
14169: PUSH
14170: LD_INT 18
14172: PUSH
14173: LD_INT 19
14175: PUSH
14176: LD_INT 20
14178: PUSH
14179: LD_INT 21
14181: PUSH
14182: LD_INT 22
14184: PUSH
14185: LD_INT 23
14187: PUSH
14188: LD_INT 24
14190: PUSH
14191: LD_INT 25
14193: PUSH
14194: LD_INT 26
14196: PUSH
14197: LD_INT 27
14199: PUSH
14200: LD_INT 28
14202: PUSH
14203: LD_INT 30
14205: PUSH
14206: LD_INT 31
14208: PUSH
14209: LD_INT 32
14211: PUSH
14212: LD_INT 33
14214: PUSH
14215: LD_INT 34
14217: PUSH
14218: LD_INT 36
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: LIST
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 101
14259: PUSH
14260: LD_INT 102
14262: PUSH
14263: LD_INT 103
14265: PUSH
14266: LD_INT 104
14268: PUSH
14269: LD_INT 105
14271: PUSH
14272: LD_INT 106
14274: PUSH
14275: LD_INT 107
14277: PUSH
14278: LD_INT 108
14280: PUSH
14281: LD_INT 109
14283: PUSH
14284: LD_INT 110
14286: PUSH
14287: LD_INT 111
14289: PUSH
14290: LD_INT 112
14292: PUSH
14293: LD_INT 113
14295: PUSH
14296: LD_INT 114
14298: PUSH
14299: EMPTY
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: LIST
14312: LIST
14313: LIST
14314: PUSH
14315: EMPTY
14316: LIST
14317: LIST
14318: ST_TO_ADDR
14319: GO 15690
14321: LD_INT 13
14323: DOUBLE
14324: EQUAL
14325: IFTRUE 14329
14327: GO 14525
14329: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
14330: LD_ADDR_VAR 0 1
14334: PUSH
14335: LD_INT 1
14337: PUSH
14338: LD_INT 2
14340: PUSH
14341: LD_INT 3
14343: PUSH
14344: LD_INT 4
14346: PUSH
14347: LD_INT 5
14349: PUSH
14350: LD_INT 8
14352: PUSH
14353: LD_INT 9
14355: PUSH
14356: LD_INT 10
14358: PUSH
14359: LD_INT 11
14361: PUSH
14362: LD_INT 12
14364: PUSH
14365: LD_INT 14
14367: PUSH
14368: LD_INT 15
14370: PUSH
14371: LD_INT 16
14373: PUSH
14374: LD_INT 17
14376: PUSH
14377: LD_INT 18
14379: PUSH
14380: LD_INT 19
14382: PUSH
14383: LD_INT 20
14385: PUSH
14386: LD_INT 21
14388: PUSH
14389: LD_INT 22
14391: PUSH
14392: LD_INT 23
14394: PUSH
14395: LD_INT 24
14397: PUSH
14398: LD_INT 25
14400: PUSH
14401: LD_INT 26
14403: PUSH
14404: LD_INT 27
14406: PUSH
14407: LD_INT 28
14409: PUSH
14410: LD_INT 30
14412: PUSH
14413: LD_INT 31
14415: PUSH
14416: LD_INT 32
14418: PUSH
14419: LD_INT 33
14421: PUSH
14422: LD_INT 34
14424: PUSH
14425: LD_INT 36
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: LIST
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: LIST
14440: LIST
14441: LIST
14442: LIST
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: PUSH
14461: LD_INT 101
14463: PUSH
14464: LD_INT 102
14466: PUSH
14467: LD_INT 103
14469: PUSH
14470: LD_INT 104
14472: PUSH
14473: LD_INT 105
14475: PUSH
14476: LD_INT 106
14478: PUSH
14479: LD_INT 107
14481: PUSH
14482: LD_INT 108
14484: PUSH
14485: LD_INT 109
14487: PUSH
14488: LD_INT 110
14490: PUSH
14491: LD_INT 111
14493: PUSH
14494: LD_INT 112
14496: PUSH
14497: LD_INT 113
14499: PUSH
14500: LD_INT 114
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: EMPTY
14520: LIST
14521: LIST
14522: ST_TO_ADDR
14523: GO 15690
14525: LD_INT 14
14527: DOUBLE
14528: EQUAL
14529: IFTRUE 14533
14531: GO 14745
14533: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14534: LD_ADDR_VAR 0 1
14538: PUSH
14539: LD_INT 1
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: LD_INT 4
14550: PUSH
14551: LD_INT 5
14553: PUSH
14554: LD_INT 6
14556: PUSH
14557: LD_INT 7
14559: PUSH
14560: LD_INT 8
14562: PUSH
14563: LD_INT 9
14565: PUSH
14566: LD_INT 10
14568: PUSH
14569: LD_INT 11
14571: PUSH
14572: LD_INT 12
14574: PUSH
14575: LD_INT 13
14577: PUSH
14578: LD_INT 14
14580: PUSH
14581: LD_INT 15
14583: PUSH
14584: LD_INT 16
14586: PUSH
14587: LD_INT 17
14589: PUSH
14590: LD_INT 18
14592: PUSH
14593: LD_INT 19
14595: PUSH
14596: LD_INT 20
14598: PUSH
14599: LD_INT 21
14601: PUSH
14602: LD_INT 22
14604: PUSH
14605: LD_INT 23
14607: PUSH
14608: LD_INT 24
14610: PUSH
14611: LD_INT 25
14613: PUSH
14614: LD_INT 26
14616: PUSH
14617: LD_INT 27
14619: PUSH
14620: LD_INT 28
14622: PUSH
14623: LD_INT 29
14625: PUSH
14626: LD_INT 30
14628: PUSH
14629: LD_INT 31
14631: PUSH
14632: LD_INT 32
14634: PUSH
14635: LD_INT 33
14637: PUSH
14638: LD_INT 34
14640: PUSH
14641: LD_INT 36
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: LIST
14680: PUSH
14681: LD_INT 101
14683: PUSH
14684: LD_INT 102
14686: PUSH
14687: LD_INT 103
14689: PUSH
14690: LD_INT 104
14692: PUSH
14693: LD_INT 105
14695: PUSH
14696: LD_INT 106
14698: PUSH
14699: LD_INT 107
14701: PUSH
14702: LD_INT 108
14704: PUSH
14705: LD_INT 109
14707: PUSH
14708: LD_INT 110
14710: PUSH
14711: LD_INT 111
14713: PUSH
14714: LD_INT 112
14716: PUSH
14717: LD_INT 113
14719: PUSH
14720: LD_INT 114
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: ST_TO_ADDR
14743: GO 15690
14745: LD_INT 15
14747: DOUBLE
14748: EQUAL
14749: IFTRUE 14753
14751: GO 14965
14753: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14754: LD_ADDR_VAR 0 1
14758: PUSH
14759: LD_INT 1
14761: PUSH
14762: LD_INT 2
14764: PUSH
14765: LD_INT 3
14767: PUSH
14768: LD_INT 4
14770: PUSH
14771: LD_INT 5
14773: PUSH
14774: LD_INT 6
14776: PUSH
14777: LD_INT 7
14779: PUSH
14780: LD_INT 8
14782: PUSH
14783: LD_INT 9
14785: PUSH
14786: LD_INT 10
14788: PUSH
14789: LD_INT 11
14791: PUSH
14792: LD_INT 12
14794: PUSH
14795: LD_INT 13
14797: PUSH
14798: LD_INT 14
14800: PUSH
14801: LD_INT 15
14803: PUSH
14804: LD_INT 16
14806: PUSH
14807: LD_INT 17
14809: PUSH
14810: LD_INT 18
14812: PUSH
14813: LD_INT 19
14815: PUSH
14816: LD_INT 20
14818: PUSH
14819: LD_INT 21
14821: PUSH
14822: LD_INT 22
14824: PUSH
14825: LD_INT 23
14827: PUSH
14828: LD_INT 24
14830: PUSH
14831: LD_INT 25
14833: PUSH
14834: LD_INT 26
14836: PUSH
14837: LD_INT 27
14839: PUSH
14840: LD_INT 28
14842: PUSH
14843: LD_INT 29
14845: PUSH
14846: LD_INT 30
14848: PUSH
14849: LD_INT 31
14851: PUSH
14852: LD_INT 32
14854: PUSH
14855: LD_INT 33
14857: PUSH
14858: LD_INT 34
14860: PUSH
14861: LD_INT 36
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: LIST
14868: LIST
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: LIST
14876: LIST
14877: LIST
14878: LIST
14879: LIST
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: LIST
14885: LIST
14886: LIST
14887: LIST
14888: LIST
14889: LIST
14890: LIST
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: PUSH
14901: LD_INT 101
14903: PUSH
14904: LD_INT 102
14906: PUSH
14907: LD_INT 103
14909: PUSH
14910: LD_INT 104
14912: PUSH
14913: LD_INT 105
14915: PUSH
14916: LD_INT 106
14918: PUSH
14919: LD_INT 107
14921: PUSH
14922: LD_INT 108
14924: PUSH
14925: LD_INT 109
14927: PUSH
14928: LD_INT 110
14930: PUSH
14931: LD_INT 111
14933: PUSH
14934: LD_INT 112
14936: PUSH
14937: LD_INT 113
14939: PUSH
14940: LD_INT 114
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: LIST
14947: LIST
14948: LIST
14949: LIST
14950: LIST
14951: LIST
14952: LIST
14953: LIST
14954: LIST
14955: LIST
14956: LIST
14957: LIST
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: ST_TO_ADDR
14963: GO 15690
14965: LD_INT 16
14967: DOUBLE
14968: EQUAL
14969: IFTRUE 14973
14971: GO 15097
14973: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14974: LD_ADDR_VAR 0 1
14978: PUSH
14979: LD_INT 2
14981: PUSH
14982: LD_INT 4
14984: PUSH
14985: LD_INT 5
14987: PUSH
14988: LD_INT 7
14990: PUSH
14991: LD_INT 11
14993: PUSH
14994: LD_INT 12
14996: PUSH
14997: LD_INT 15
14999: PUSH
15000: LD_INT 16
15002: PUSH
15003: LD_INT 20
15005: PUSH
15006: LD_INT 21
15008: PUSH
15009: LD_INT 22
15011: PUSH
15012: LD_INT 23
15014: PUSH
15015: LD_INT 25
15017: PUSH
15018: LD_INT 26
15020: PUSH
15021: LD_INT 30
15023: PUSH
15024: LD_INT 31
15026: PUSH
15027: LD_INT 32
15029: PUSH
15030: LD_INT 33
15032: PUSH
15033: LD_INT 34
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: PUSH
15057: LD_INT 101
15059: PUSH
15060: LD_INT 102
15062: PUSH
15063: LD_INT 103
15065: PUSH
15066: LD_INT 106
15068: PUSH
15069: LD_INT 108
15071: PUSH
15072: LD_INT 112
15074: PUSH
15075: LD_INT 113
15077: PUSH
15078: LD_INT 114
15080: PUSH
15081: EMPTY
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: ST_TO_ADDR
15095: GO 15690
15097: LD_INT 17
15099: DOUBLE
15100: EQUAL
15101: IFTRUE 15105
15103: GO 15317
15105: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
15106: LD_ADDR_VAR 0 1
15110: PUSH
15111: LD_INT 1
15113: PUSH
15114: LD_INT 2
15116: PUSH
15117: LD_INT 3
15119: PUSH
15120: LD_INT 4
15122: PUSH
15123: LD_INT 5
15125: PUSH
15126: LD_INT 6
15128: PUSH
15129: LD_INT 7
15131: PUSH
15132: LD_INT 8
15134: PUSH
15135: LD_INT 9
15137: PUSH
15138: LD_INT 10
15140: PUSH
15141: LD_INT 11
15143: PUSH
15144: LD_INT 12
15146: PUSH
15147: LD_INT 13
15149: PUSH
15150: LD_INT 14
15152: PUSH
15153: LD_INT 15
15155: PUSH
15156: LD_INT 16
15158: PUSH
15159: LD_INT 17
15161: PUSH
15162: LD_INT 18
15164: PUSH
15165: LD_INT 19
15167: PUSH
15168: LD_INT 20
15170: PUSH
15171: LD_INT 21
15173: PUSH
15174: LD_INT 22
15176: PUSH
15177: LD_INT 23
15179: PUSH
15180: LD_INT 24
15182: PUSH
15183: LD_INT 25
15185: PUSH
15186: LD_INT 26
15188: PUSH
15189: LD_INT 27
15191: PUSH
15192: LD_INT 28
15194: PUSH
15195: LD_INT 29
15197: PUSH
15198: LD_INT 30
15200: PUSH
15201: LD_INT 31
15203: PUSH
15204: LD_INT 32
15206: PUSH
15207: LD_INT 33
15209: PUSH
15210: LD_INT 34
15212: PUSH
15213: LD_INT 36
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: PUSH
15253: LD_INT 101
15255: PUSH
15256: LD_INT 102
15258: PUSH
15259: LD_INT 103
15261: PUSH
15262: LD_INT 104
15264: PUSH
15265: LD_INT 105
15267: PUSH
15268: LD_INT 106
15270: PUSH
15271: LD_INT 107
15273: PUSH
15274: LD_INT 108
15276: PUSH
15277: LD_INT 109
15279: PUSH
15280: LD_INT 110
15282: PUSH
15283: LD_INT 111
15285: PUSH
15286: LD_INT 112
15288: PUSH
15289: LD_INT 113
15291: PUSH
15292: LD_INT 114
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: LIST
15299: LIST
15300: LIST
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: ST_TO_ADDR
15315: GO 15690
15317: LD_INT 18
15319: DOUBLE
15320: EQUAL
15321: IFTRUE 15325
15323: GO 15461
15325: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_INT 2
15333: PUSH
15334: LD_INT 4
15336: PUSH
15337: LD_INT 5
15339: PUSH
15340: LD_INT 7
15342: PUSH
15343: LD_INT 11
15345: PUSH
15346: LD_INT 12
15348: PUSH
15349: LD_INT 15
15351: PUSH
15352: LD_INT 16
15354: PUSH
15355: LD_INT 20
15357: PUSH
15358: LD_INT 21
15360: PUSH
15361: LD_INT 22
15363: PUSH
15364: LD_INT 23
15366: PUSH
15367: LD_INT 25
15369: PUSH
15370: LD_INT 26
15372: PUSH
15373: LD_INT 30
15375: PUSH
15376: LD_INT 31
15378: PUSH
15379: LD_INT 32
15381: PUSH
15382: LD_INT 33
15384: PUSH
15385: LD_INT 34
15387: PUSH
15388: LD_INT 35
15390: PUSH
15391: LD_INT 36
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: LIST
15407: LIST
15408: LIST
15409: LIST
15410: LIST
15411: LIST
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: PUSH
15417: LD_INT 101
15419: PUSH
15420: LD_INT 102
15422: PUSH
15423: LD_INT 103
15425: PUSH
15426: LD_INT 106
15428: PUSH
15429: LD_INT 108
15431: PUSH
15432: LD_INT 112
15434: PUSH
15435: LD_INT 113
15437: PUSH
15438: LD_INT 114
15440: PUSH
15441: LD_INT 115
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: PUSH
15455: EMPTY
15456: LIST
15457: LIST
15458: ST_TO_ADDR
15459: GO 15690
15461: LD_INT 19
15463: DOUBLE
15464: EQUAL
15465: IFTRUE 15469
15467: GO 15689
15469: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15470: LD_ADDR_VAR 0 1
15474: PUSH
15475: LD_INT 1
15477: PUSH
15478: LD_INT 2
15480: PUSH
15481: LD_INT 3
15483: PUSH
15484: LD_INT 4
15486: PUSH
15487: LD_INT 5
15489: PUSH
15490: LD_INT 6
15492: PUSH
15493: LD_INT 7
15495: PUSH
15496: LD_INT 8
15498: PUSH
15499: LD_INT 9
15501: PUSH
15502: LD_INT 10
15504: PUSH
15505: LD_INT 11
15507: PUSH
15508: LD_INT 12
15510: PUSH
15511: LD_INT 13
15513: PUSH
15514: LD_INT 14
15516: PUSH
15517: LD_INT 15
15519: PUSH
15520: LD_INT 16
15522: PUSH
15523: LD_INT 17
15525: PUSH
15526: LD_INT 18
15528: PUSH
15529: LD_INT 19
15531: PUSH
15532: LD_INT 20
15534: PUSH
15535: LD_INT 21
15537: PUSH
15538: LD_INT 22
15540: PUSH
15541: LD_INT 23
15543: PUSH
15544: LD_INT 24
15546: PUSH
15547: LD_INT 25
15549: PUSH
15550: LD_INT 26
15552: PUSH
15553: LD_INT 27
15555: PUSH
15556: LD_INT 28
15558: PUSH
15559: LD_INT 29
15561: PUSH
15562: LD_INT 30
15564: PUSH
15565: LD_INT 31
15567: PUSH
15568: LD_INT 32
15570: PUSH
15571: LD_INT 33
15573: PUSH
15574: LD_INT 34
15576: PUSH
15577: LD_INT 35
15579: PUSH
15580: LD_INT 36
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: LIST
15597: LIST
15598: LIST
15599: LIST
15600: LIST
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: LIST
15611: LIST
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: LIST
15620: PUSH
15621: LD_INT 101
15623: PUSH
15624: LD_INT 102
15626: PUSH
15627: LD_INT 103
15629: PUSH
15630: LD_INT 104
15632: PUSH
15633: LD_INT 105
15635: PUSH
15636: LD_INT 106
15638: PUSH
15639: LD_INT 107
15641: PUSH
15642: LD_INT 108
15644: PUSH
15645: LD_INT 109
15647: PUSH
15648: LD_INT 110
15650: PUSH
15651: LD_INT 111
15653: PUSH
15654: LD_INT 112
15656: PUSH
15657: LD_INT 113
15659: PUSH
15660: LD_INT 114
15662: PUSH
15663: LD_INT 115
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: LIST
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: ST_TO_ADDR
15687: GO 15690
15689: POP
// end else
15690: GO 15909
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
15692: LD_ADDR_VAR 0 1
15696: PUSH
15697: LD_INT 1
15699: PUSH
15700: LD_INT 2
15702: PUSH
15703: LD_INT 3
15705: PUSH
15706: LD_INT 4
15708: PUSH
15709: LD_INT 5
15711: PUSH
15712: LD_INT 6
15714: PUSH
15715: LD_INT 7
15717: PUSH
15718: LD_INT 8
15720: PUSH
15721: LD_INT 9
15723: PUSH
15724: LD_INT 10
15726: PUSH
15727: LD_INT 11
15729: PUSH
15730: LD_INT 12
15732: PUSH
15733: LD_INT 13
15735: PUSH
15736: LD_INT 14
15738: PUSH
15739: LD_INT 15
15741: PUSH
15742: LD_INT 16
15744: PUSH
15745: LD_INT 17
15747: PUSH
15748: LD_INT 18
15750: PUSH
15751: LD_INT 19
15753: PUSH
15754: LD_INT 20
15756: PUSH
15757: LD_INT 21
15759: PUSH
15760: LD_INT 22
15762: PUSH
15763: LD_INT 23
15765: PUSH
15766: LD_INT 24
15768: PUSH
15769: LD_INT 25
15771: PUSH
15772: LD_INT 26
15774: PUSH
15775: LD_INT 27
15777: PUSH
15778: LD_INT 28
15780: PUSH
15781: LD_INT 29
15783: PUSH
15784: LD_INT 30
15786: PUSH
15787: LD_INT 31
15789: PUSH
15790: LD_INT 32
15792: PUSH
15793: LD_INT 33
15795: PUSH
15796: LD_INT 34
15798: PUSH
15799: LD_INT 35
15801: PUSH
15802: LD_INT 36
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: LIST
15809: LIST
15810: LIST
15811: LIST
15812: LIST
15813: LIST
15814: LIST
15815: LIST
15816: LIST
15817: LIST
15818: LIST
15819: LIST
15820: LIST
15821: LIST
15822: LIST
15823: LIST
15824: LIST
15825: LIST
15826: LIST
15827: LIST
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: LIST
15837: LIST
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PUSH
15843: LD_INT 101
15845: PUSH
15846: LD_INT 102
15848: PUSH
15849: LD_INT 103
15851: PUSH
15852: LD_INT 104
15854: PUSH
15855: LD_INT 105
15857: PUSH
15858: LD_INT 106
15860: PUSH
15861: LD_INT 107
15863: PUSH
15864: LD_INT 108
15866: PUSH
15867: LD_INT 109
15869: PUSH
15870: LD_INT 110
15872: PUSH
15873: LD_INT 111
15875: PUSH
15876: LD_INT 112
15878: PUSH
15879: LD_INT 113
15881: PUSH
15882: LD_INT 114
15884: PUSH
15885: LD_INT 115
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: LIST
15892: LIST
15893: LIST
15894: LIST
15895: LIST
15896: LIST
15897: LIST
15898: LIST
15899: LIST
15900: LIST
15901: LIST
15902: LIST
15903: LIST
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: ST_TO_ADDR
// if result then
15909: LD_VAR 0 1
15913: IFFALSE 16202
// begin normal :=  ;
15915: LD_ADDR_VAR 0 3
15919: PUSH
15920: LD_STRING 
15922: ST_TO_ADDR
// hardcore :=  ;
15923: LD_ADDR_VAR 0 4
15927: PUSH
15928: LD_STRING 
15930: ST_TO_ADDR
// for i = 1 to normalCounter do
15931: LD_ADDR_VAR 0 5
15935: PUSH
15936: DOUBLE
15937: LD_INT 1
15939: DEC
15940: ST_TO_ADDR
15941: LD_EXP 35
15945: PUSH
15946: FOR_TO
15947: IFFALSE 16048
// begin tmp := 0 ;
15949: LD_ADDR_VAR 0 2
15953: PUSH
15954: LD_STRING 0
15956: ST_TO_ADDR
// if result [ 1 ] then
15957: LD_VAR 0 1
15961: PUSH
15962: LD_INT 1
15964: ARRAY
15965: IFFALSE 16030
// if result [ 1 ] [ 1 ] = i then
15967: LD_VAR 0 1
15971: PUSH
15972: LD_INT 1
15974: ARRAY
15975: PUSH
15976: LD_INT 1
15978: ARRAY
15979: PUSH
15980: LD_VAR 0 5
15984: EQUAL
15985: IFFALSE 16030
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15987: LD_ADDR_VAR 0 1
15991: PUSH
15992: LD_VAR 0 1
15996: PPUSH
15997: LD_INT 1
15999: PPUSH
16000: LD_VAR 0 1
16004: PUSH
16005: LD_INT 1
16007: ARRAY
16008: PPUSH
16009: LD_INT 1
16011: PPUSH
16012: CALL_OW 3
16016: PPUSH
16017: CALL_OW 1
16021: ST_TO_ADDR
// tmp := 1 ;
16022: LD_ADDR_VAR 0 2
16026: PUSH
16027: LD_STRING 1
16029: ST_TO_ADDR
// end ; normal := normal & tmp ;
16030: LD_ADDR_VAR 0 3
16034: PUSH
16035: LD_VAR 0 3
16039: PUSH
16040: LD_VAR 0 2
16044: STR
16045: ST_TO_ADDR
// end ;
16046: GO 15946
16048: POP
16049: POP
// for i = 1 to hardcoreCounter do
16050: LD_ADDR_VAR 0 5
16054: PUSH
16055: DOUBLE
16056: LD_INT 1
16058: DEC
16059: ST_TO_ADDR
16060: LD_EXP 36
16064: PUSH
16065: FOR_TO
16066: IFFALSE 16171
// begin tmp := 0 ;
16068: LD_ADDR_VAR 0 2
16072: PUSH
16073: LD_STRING 0
16075: ST_TO_ADDR
// if result [ 2 ] then
16076: LD_VAR 0 1
16080: PUSH
16081: LD_INT 2
16083: ARRAY
16084: IFFALSE 16153
// if result [ 2 ] [ 1 ] = 100 + i then
16086: LD_VAR 0 1
16090: PUSH
16091: LD_INT 2
16093: ARRAY
16094: PUSH
16095: LD_INT 1
16097: ARRAY
16098: PUSH
16099: LD_INT 100
16101: PUSH
16102: LD_VAR 0 5
16106: PLUS
16107: EQUAL
16108: IFFALSE 16153
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
16110: LD_ADDR_VAR 0 1
16114: PUSH
16115: LD_VAR 0 1
16119: PPUSH
16120: LD_INT 2
16122: PPUSH
16123: LD_VAR 0 1
16127: PUSH
16128: LD_INT 2
16130: ARRAY
16131: PPUSH
16132: LD_INT 1
16134: PPUSH
16135: CALL_OW 3
16139: PPUSH
16140: CALL_OW 1
16144: ST_TO_ADDR
// tmp := 1 ;
16145: LD_ADDR_VAR 0 2
16149: PUSH
16150: LD_STRING 1
16152: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
16153: LD_ADDR_VAR 0 4
16157: PUSH
16158: LD_VAR 0 4
16162: PUSH
16163: LD_VAR 0 2
16167: STR
16168: ST_TO_ADDR
// end ;
16169: GO 16065
16171: POP
16172: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
16173: LD_STRING getStreamItemsFromMission("
16175: PUSH
16176: LD_VAR 0 3
16180: STR
16181: PUSH
16182: LD_STRING ","
16184: STR
16185: PUSH
16186: LD_VAR 0 4
16190: STR
16191: PUSH
16192: LD_STRING ")
16194: STR
16195: PPUSH
16196: CALL_OW 559
// end else
16200: GO 16209
// ToLua ( getStreamItemsFromMission("","") ) ;
16202: LD_STRING getStreamItemsFromMission("","")
16204: PPUSH
16205: CALL_OW 559
// end ;
16209: LD_VAR 0 1
16213: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
16214: LD_VAR 0 2
16218: PUSH
16219: LD_INT 100
16221: EQUAL
16222: IFFALSE 17171
// begin if not StreamModeActive then
16224: LD_EXP 34
16228: NOT
16229: IFFALSE 16239
// StreamModeActive := true ;
16231: LD_ADDR_EXP 34
16235: PUSH
16236: LD_INT 1
16238: ST_TO_ADDR
// if p3 = 0 then
16239: LD_VAR 0 3
16243: PUSH
16244: LD_INT 0
16246: EQUAL
16247: IFFALSE 16253
// InitStreamMode ;
16249: CALL 12292 0 0
// if p3 = 1 then
16253: LD_VAR 0 3
16257: PUSH
16258: LD_INT 1
16260: EQUAL
16261: IFFALSE 16271
// sRocket := true ;
16263: LD_ADDR_EXP 39
16267: PUSH
16268: LD_INT 1
16270: ST_TO_ADDR
// if p3 = 2 then
16271: LD_VAR 0 3
16275: PUSH
16276: LD_INT 2
16278: EQUAL
16279: IFFALSE 16289
// sSpeed := true ;
16281: LD_ADDR_EXP 38
16285: PUSH
16286: LD_INT 1
16288: ST_TO_ADDR
// if p3 = 3 then
16289: LD_VAR 0 3
16293: PUSH
16294: LD_INT 3
16296: EQUAL
16297: IFFALSE 16307
// sEngine := true ;
16299: LD_ADDR_EXP 40
16303: PUSH
16304: LD_INT 1
16306: ST_TO_ADDR
// if p3 = 4 then
16307: LD_VAR 0 3
16311: PUSH
16312: LD_INT 4
16314: EQUAL
16315: IFFALSE 16325
// sSpec := true ;
16317: LD_ADDR_EXP 37
16321: PUSH
16322: LD_INT 1
16324: ST_TO_ADDR
// if p3 = 5 then
16325: LD_VAR 0 3
16329: PUSH
16330: LD_INT 5
16332: EQUAL
16333: IFFALSE 16343
// sLevel := true ;
16335: LD_ADDR_EXP 41
16339: PUSH
16340: LD_INT 1
16342: ST_TO_ADDR
// if p3 = 6 then
16343: LD_VAR 0 3
16347: PUSH
16348: LD_INT 6
16350: EQUAL
16351: IFFALSE 16361
// sArmoury := true ;
16353: LD_ADDR_EXP 42
16357: PUSH
16358: LD_INT 1
16360: ST_TO_ADDR
// if p3 = 7 then
16361: LD_VAR 0 3
16365: PUSH
16366: LD_INT 7
16368: EQUAL
16369: IFFALSE 16379
// sRadar := true ;
16371: LD_ADDR_EXP 43
16375: PUSH
16376: LD_INT 1
16378: ST_TO_ADDR
// if p3 = 8 then
16379: LD_VAR 0 3
16383: PUSH
16384: LD_INT 8
16386: EQUAL
16387: IFFALSE 16397
// sBunker := true ;
16389: LD_ADDR_EXP 44
16393: PUSH
16394: LD_INT 1
16396: ST_TO_ADDR
// if p3 = 9 then
16397: LD_VAR 0 3
16401: PUSH
16402: LD_INT 9
16404: EQUAL
16405: IFFALSE 16415
// sHack := true ;
16407: LD_ADDR_EXP 45
16411: PUSH
16412: LD_INT 1
16414: ST_TO_ADDR
// if p3 = 10 then
16415: LD_VAR 0 3
16419: PUSH
16420: LD_INT 10
16422: EQUAL
16423: IFFALSE 16433
// sFire := true ;
16425: LD_ADDR_EXP 46
16429: PUSH
16430: LD_INT 1
16432: ST_TO_ADDR
// if p3 = 11 then
16433: LD_VAR 0 3
16437: PUSH
16438: LD_INT 11
16440: EQUAL
16441: IFFALSE 16451
// sRefresh := true ;
16443: LD_ADDR_EXP 47
16447: PUSH
16448: LD_INT 1
16450: ST_TO_ADDR
// if p3 = 12 then
16451: LD_VAR 0 3
16455: PUSH
16456: LD_INT 12
16458: EQUAL
16459: IFFALSE 16469
// sExp := true ;
16461: LD_ADDR_EXP 48
16465: PUSH
16466: LD_INT 1
16468: ST_TO_ADDR
// if p3 = 13 then
16469: LD_VAR 0 3
16473: PUSH
16474: LD_INT 13
16476: EQUAL
16477: IFFALSE 16487
// sDepot := true ;
16479: LD_ADDR_EXP 49
16483: PUSH
16484: LD_INT 1
16486: ST_TO_ADDR
// if p3 = 14 then
16487: LD_VAR 0 3
16491: PUSH
16492: LD_INT 14
16494: EQUAL
16495: IFFALSE 16505
// sFlag := true ;
16497: LD_ADDR_EXP 50
16501: PUSH
16502: LD_INT 1
16504: ST_TO_ADDR
// if p3 = 15 then
16505: LD_VAR 0 3
16509: PUSH
16510: LD_INT 15
16512: EQUAL
16513: IFFALSE 16523
// sKamikadze := true ;
16515: LD_ADDR_EXP 58
16519: PUSH
16520: LD_INT 1
16522: ST_TO_ADDR
// if p3 = 16 then
16523: LD_VAR 0 3
16527: PUSH
16528: LD_INT 16
16530: EQUAL
16531: IFFALSE 16541
// sTroll := true ;
16533: LD_ADDR_EXP 59
16537: PUSH
16538: LD_INT 1
16540: ST_TO_ADDR
// if p3 = 17 then
16541: LD_VAR 0 3
16545: PUSH
16546: LD_INT 17
16548: EQUAL
16549: IFFALSE 16559
// sSlow := true ;
16551: LD_ADDR_EXP 60
16555: PUSH
16556: LD_INT 1
16558: ST_TO_ADDR
// if p3 = 18 then
16559: LD_VAR 0 3
16563: PUSH
16564: LD_INT 18
16566: EQUAL
16567: IFFALSE 16577
// sLack := true ;
16569: LD_ADDR_EXP 61
16573: PUSH
16574: LD_INT 1
16576: ST_TO_ADDR
// if p3 = 19 then
16577: LD_VAR 0 3
16581: PUSH
16582: LD_INT 19
16584: EQUAL
16585: IFFALSE 16595
// sTank := true ;
16587: LD_ADDR_EXP 63
16591: PUSH
16592: LD_INT 1
16594: ST_TO_ADDR
// if p3 = 20 then
16595: LD_VAR 0 3
16599: PUSH
16600: LD_INT 20
16602: EQUAL
16603: IFFALSE 16613
// sRemote := true ;
16605: LD_ADDR_EXP 64
16609: PUSH
16610: LD_INT 1
16612: ST_TO_ADDR
// if p3 = 21 then
16613: LD_VAR 0 3
16617: PUSH
16618: LD_INT 21
16620: EQUAL
16621: IFFALSE 16631
// sPowell := true ;
16623: LD_ADDR_EXP 65
16627: PUSH
16628: LD_INT 1
16630: ST_TO_ADDR
// if p3 = 22 then
16631: LD_VAR 0 3
16635: PUSH
16636: LD_INT 22
16638: EQUAL
16639: IFFALSE 16649
// sTeleport := true ;
16641: LD_ADDR_EXP 68
16645: PUSH
16646: LD_INT 1
16648: ST_TO_ADDR
// if p3 = 23 then
16649: LD_VAR 0 3
16653: PUSH
16654: LD_INT 23
16656: EQUAL
16657: IFFALSE 16667
// sOilTower := true ;
16659: LD_ADDR_EXP 70
16663: PUSH
16664: LD_INT 1
16666: ST_TO_ADDR
// if p3 = 24 then
16667: LD_VAR 0 3
16671: PUSH
16672: LD_INT 24
16674: EQUAL
16675: IFFALSE 16685
// sShovel := true ;
16677: LD_ADDR_EXP 71
16681: PUSH
16682: LD_INT 1
16684: ST_TO_ADDR
// if p3 = 25 then
16685: LD_VAR 0 3
16689: PUSH
16690: LD_INT 25
16692: EQUAL
16693: IFFALSE 16703
// sSheik := true ;
16695: LD_ADDR_EXP 72
16699: PUSH
16700: LD_INT 1
16702: ST_TO_ADDR
// if p3 = 26 then
16703: LD_VAR 0 3
16707: PUSH
16708: LD_INT 26
16710: EQUAL
16711: IFFALSE 16721
// sEarthquake := true ;
16713: LD_ADDR_EXP 74
16717: PUSH
16718: LD_INT 1
16720: ST_TO_ADDR
// if p3 = 27 then
16721: LD_VAR 0 3
16725: PUSH
16726: LD_INT 27
16728: EQUAL
16729: IFFALSE 16739
// sAI := true ;
16731: LD_ADDR_EXP 75
16735: PUSH
16736: LD_INT 1
16738: ST_TO_ADDR
// if p3 = 28 then
16739: LD_VAR 0 3
16743: PUSH
16744: LD_INT 28
16746: EQUAL
16747: IFFALSE 16757
// sCargo := true ;
16749: LD_ADDR_EXP 78
16753: PUSH
16754: LD_INT 1
16756: ST_TO_ADDR
// if p3 = 29 then
16757: LD_VAR 0 3
16761: PUSH
16762: LD_INT 29
16764: EQUAL
16765: IFFALSE 16775
// sDLaser := true ;
16767: LD_ADDR_EXP 79
16771: PUSH
16772: LD_INT 1
16774: ST_TO_ADDR
// if p3 = 30 then
16775: LD_VAR 0 3
16779: PUSH
16780: LD_INT 30
16782: EQUAL
16783: IFFALSE 16793
// sExchange := true ;
16785: LD_ADDR_EXP 80
16789: PUSH
16790: LD_INT 1
16792: ST_TO_ADDR
// if p3 = 31 then
16793: LD_VAR 0 3
16797: PUSH
16798: LD_INT 31
16800: EQUAL
16801: IFFALSE 16811
// sFac := true ;
16803: LD_ADDR_EXP 81
16807: PUSH
16808: LD_INT 1
16810: ST_TO_ADDR
// if p3 = 32 then
16811: LD_VAR 0 3
16815: PUSH
16816: LD_INT 32
16818: EQUAL
16819: IFFALSE 16829
// sPower := true ;
16821: LD_ADDR_EXP 82
16825: PUSH
16826: LD_INT 1
16828: ST_TO_ADDR
// if p3 = 33 then
16829: LD_VAR 0 3
16833: PUSH
16834: LD_INT 33
16836: EQUAL
16837: IFFALSE 16847
// sRandom := true ;
16839: LD_ADDR_EXP 83
16843: PUSH
16844: LD_INT 1
16846: ST_TO_ADDR
// if p3 = 34 then
16847: LD_VAR 0 3
16851: PUSH
16852: LD_INT 34
16854: EQUAL
16855: IFFALSE 16865
// sShield := true ;
16857: LD_ADDR_EXP 84
16861: PUSH
16862: LD_INT 1
16864: ST_TO_ADDR
// if p3 = 35 then
16865: LD_VAR 0 3
16869: PUSH
16870: LD_INT 35
16872: EQUAL
16873: IFFALSE 16883
// sTime := true ;
16875: LD_ADDR_EXP 85
16879: PUSH
16880: LD_INT 1
16882: ST_TO_ADDR
// if p3 = 36 then
16883: LD_VAR 0 3
16887: PUSH
16888: LD_INT 36
16890: EQUAL
16891: IFFALSE 16901
// sTools := true ;
16893: LD_ADDR_EXP 86
16897: PUSH
16898: LD_INT 1
16900: ST_TO_ADDR
// if p3 = 101 then
16901: LD_VAR 0 3
16905: PUSH
16906: LD_INT 101
16908: EQUAL
16909: IFFALSE 16919
// sSold := true ;
16911: LD_ADDR_EXP 51
16915: PUSH
16916: LD_INT 1
16918: ST_TO_ADDR
// if p3 = 102 then
16919: LD_VAR 0 3
16923: PUSH
16924: LD_INT 102
16926: EQUAL
16927: IFFALSE 16937
// sDiff := true ;
16929: LD_ADDR_EXP 52
16933: PUSH
16934: LD_INT 1
16936: ST_TO_ADDR
// if p3 = 103 then
16937: LD_VAR 0 3
16941: PUSH
16942: LD_INT 103
16944: EQUAL
16945: IFFALSE 16955
// sFog := true ;
16947: LD_ADDR_EXP 55
16951: PUSH
16952: LD_INT 1
16954: ST_TO_ADDR
// if p3 = 104 then
16955: LD_VAR 0 3
16959: PUSH
16960: LD_INT 104
16962: EQUAL
16963: IFFALSE 16973
// sReset := true ;
16965: LD_ADDR_EXP 56
16969: PUSH
16970: LD_INT 1
16972: ST_TO_ADDR
// if p3 = 105 then
16973: LD_VAR 0 3
16977: PUSH
16978: LD_INT 105
16980: EQUAL
16981: IFFALSE 16991
// sSun := true ;
16983: LD_ADDR_EXP 57
16987: PUSH
16988: LD_INT 1
16990: ST_TO_ADDR
// if p3 = 106 then
16991: LD_VAR 0 3
16995: PUSH
16996: LD_INT 106
16998: EQUAL
16999: IFFALSE 17009
// sTiger := true ;
17001: LD_ADDR_EXP 53
17005: PUSH
17006: LD_INT 1
17008: ST_TO_ADDR
// if p3 = 107 then
17009: LD_VAR 0 3
17013: PUSH
17014: LD_INT 107
17016: EQUAL
17017: IFFALSE 17027
// sBomb := true ;
17019: LD_ADDR_EXP 54
17023: PUSH
17024: LD_INT 1
17026: ST_TO_ADDR
// if p3 = 108 then
17027: LD_VAR 0 3
17031: PUSH
17032: LD_INT 108
17034: EQUAL
17035: IFFALSE 17045
// sWound := true ;
17037: LD_ADDR_EXP 62
17041: PUSH
17042: LD_INT 1
17044: ST_TO_ADDR
// if p3 = 109 then
17045: LD_VAR 0 3
17049: PUSH
17050: LD_INT 109
17052: EQUAL
17053: IFFALSE 17063
// sBetray := true ;
17055: LD_ADDR_EXP 66
17059: PUSH
17060: LD_INT 1
17062: ST_TO_ADDR
// if p3 = 110 then
17063: LD_VAR 0 3
17067: PUSH
17068: LD_INT 110
17070: EQUAL
17071: IFFALSE 17081
// sContamin := true ;
17073: LD_ADDR_EXP 67
17077: PUSH
17078: LD_INT 1
17080: ST_TO_ADDR
// if p3 = 111 then
17081: LD_VAR 0 3
17085: PUSH
17086: LD_INT 111
17088: EQUAL
17089: IFFALSE 17099
// sOil := true ;
17091: LD_ADDR_EXP 69
17095: PUSH
17096: LD_INT 1
17098: ST_TO_ADDR
// if p3 = 112 then
17099: LD_VAR 0 3
17103: PUSH
17104: LD_INT 112
17106: EQUAL
17107: IFFALSE 17117
// sStu := true ;
17109: LD_ADDR_EXP 73
17113: PUSH
17114: LD_INT 1
17116: ST_TO_ADDR
// if p3 = 113 then
17117: LD_VAR 0 3
17121: PUSH
17122: LD_INT 113
17124: EQUAL
17125: IFFALSE 17135
// sBazooka := true ;
17127: LD_ADDR_EXP 76
17131: PUSH
17132: LD_INT 1
17134: ST_TO_ADDR
// if p3 = 114 then
17135: LD_VAR 0 3
17139: PUSH
17140: LD_INT 114
17142: EQUAL
17143: IFFALSE 17153
// sMortar := true ;
17145: LD_ADDR_EXP 77
17149: PUSH
17150: LD_INT 1
17152: ST_TO_ADDR
// if p3 = 115 then
17153: LD_VAR 0 3
17157: PUSH
17158: LD_INT 115
17160: EQUAL
17161: IFFALSE 17171
// sRanger := true ;
17163: LD_ADDR_EXP 87
17167: PUSH
17168: LD_INT 1
17170: ST_TO_ADDR
// end ; end ;
17171: PPOPN 6
17173: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
17174: LD_EXP 34
17178: PUSH
17179: LD_EXP 39
17183: AND
17184: IFFALSE 17308
17186: GO 17188
17188: DISABLE
17189: LD_INT 0
17191: PPUSH
17192: PPUSH
// begin enable ;
17193: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
17194: LD_ADDR_VAR 0 2
17198: PUSH
17199: LD_INT 22
17201: PUSH
17202: LD_OWVAR 2
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: LD_INT 2
17213: PUSH
17214: LD_INT 34
17216: PUSH
17217: LD_INT 7
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: PUSH
17224: LD_INT 34
17226: PUSH
17227: LD_INT 45
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 34
17236: PUSH
17237: LD_INT 28
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: LD_INT 34
17246: PUSH
17247: LD_INT 47
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: PUSH
17261: EMPTY
17262: LIST
17263: LIST
17264: PPUSH
17265: CALL_OW 69
17269: ST_TO_ADDR
// if not tmp then
17270: LD_VAR 0 2
17274: NOT
17275: IFFALSE 17279
// exit ;
17277: GO 17308
// for i in tmp do
17279: LD_ADDR_VAR 0 1
17283: PUSH
17284: LD_VAR 0 2
17288: PUSH
17289: FOR_IN
17290: IFFALSE 17306
// begin SetLives ( i , 0 ) ;
17292: LD_VAR 0 1
17296: PPUSH
17297: LD_INT 0
17299: PPUSH
17300: CALL_OW 234
// end ;
17304: GO 17289
17306: POP
17307: POP
// end ;
17308: PPOPN 2
17310: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
17311: LD_EXP 34
17315: PUSH
17316: LD_EXP 40
17320: AND
17321: IFFALSE 17405
17323: GO 17325
17325: DISABLE
17326: LD_INT 0
17328: PPUSH
17329: PPUSH
// begin enable ;
17330: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
17331: LD_ADDR_VAR 0 2
17335: PUSH
17336: LD_INT 22
17338: PUSH
17339: LD_OWVAR 2
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: PUSH
17348: LD_INT 32
17350: PUSH
17351: LD_INT 3
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PPUSH
17362: CALL_OW 69
17366: ST_TO_ADDR
// if not tmp then
17367: LD_VAR 0 2
17371: NOT
17372: IFFALSE 17376
// exit ;
17374: GO 17405
// for i in tmp do
17376: LD_ADDR_VAR 0 1
17380: PUSH
17381: LD_VAR 0 2
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17403
// begin SetLives ( i , 0 ) ;
17389: LD_VAR 0 1
17393: PPUSH
17394: LD_INT 0
17396: PPUSH
17397: CALL_OW 234
// end ;
17401: GO 17386
17403: POP
17404: POP
// end ;
17405: PPOPN 2
17407: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
17408: LD_EXP 34
17412: PUSH
17413: LD_EXP 37
17417: AND
17418: IFFALSE 17511
17420: GO 17422
17422: DISABLE
17423: LD_INT 0
17425: PPUSH
// begin enable ;
17426: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
17427: LD_ADDR_VAR 0 1
17431: PUSH
17432: LD_INT 22
17434: PUSH
17435: LD_OWVAR 2
17439: PUSH
17440: EMPTY
17441: LIST
17442: LIST
17443: PUSH
17444: LD_INT 2
17446: PUSH
17447: LD_INT 25
17449: PUSH
17450: LD_INT 5
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: PUSH
17457: LD_INT 25
17459: PUSH
17460: LD_INT 9
17462: PUSH
17463: EMPTY
17464: LIST
17465: LIST
17466: PUSH
17467: LD_INT 25
17469: PUSH
17470: LD_INT 8
17472: PUSH
17473: EMPTY
17474: LIST
17475: LIST
17476: PUSH
17477: EMPTY
17478: LIST
17479: LIST
17480: LIST
17481: LIST
17482: PUSH
17483: EMPTY
17484: LIST
17485: LIST
17486: PPUSH
17487: CALL_OW 69
17491: PUSH
17492: FOR_IN
17493: IFFALSE 17509
// begin SetClass ( i , 1 ) ;
17495: LD_VAR 0 1
17499: PPUSH
17500: LD_INT 1
17502: PPUSH
17503: CALL_OW 336
// end ;
17507: GO 17492
17509: POP
17510: POP
// end ;
17511: PPOPN 1
17513: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17514: LD_EXP 34
17518: PUSH
17519: LD_EXP 38
17523: AND
17524: PUSH
17525: LD_OWVAR 65
17529: PUSH
17530: LD_INT 7
17532: LESS
17533: AND
17534: IFFALSE 17548
17536: GO 17538
17538: DISABLE
// begin enable ;
17539: ENABLE
// game_speed := 7 ;
17540: LD_ADDR_OWVAR 65
17544: PUSH
17545: LD_INT 7
17547: ST_TO_ADDR
// end ;
17548: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17549: LD_EXP 34
17553: PUSH
17554: LD_EXP 41
17558: AND
17559: IFFALSE 17761
17561: GO 17563
17563: DISABLE
17564: LD_INT 0
17566: PPUSH
17567: PPUSH
17568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17569: LD_ADDR_VAR 0 3
17573: PUSH
17574: LD_INT 81
17576: PUSH
17577: LD_OWVAR 2
17581: PUSH
17582: EMPTY
17583: LIST
17584: LIST
17585: PUSH
17586: LD_INT 21
17588: PUSH
17589: LD_INT 1
17591: PUSH
17592: EMPTY
17593: LIST
17594: LIST
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: PPUSH
17600: CALL_OW 69
17604: ST_TO_ADDR
// if not tmp then
17605: LD_VAR 0 3
17609: NOT
17610: IFFALSE 17614
// exit ;
17612: GO 17761
// if tmp > 5 then
17614: LD_VAR 0 3
17618: PUSH
17619: LD_INT 5
17621: GREATER
17622: IFFALSE 17634
// k := 5 else
17624: LD_ADDR_VAR 0 2
17628: PUSH
17629: LD_INT 5
17631: ST_TO_ADDR
17632: GO 17644
// k := tmp ;
17634: LD_ADDR_VAR 0 2
17638: PUSH
17639: LD_VAR 0 3
17643: ST_TO_ADDR
// for i := 1 to k do
17644: LD_ADDR_VAR 0 1
17648: PUSH
17649: DOUBLE
17650: LD_INT 1
17652: DEC
17653: ST_TO_ADDR
17654: LD_VAR 0 2
17658: PUSH
17659: FOR_TO
17660: IFFALSE 17759
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17662: LD_VAR 0 3
17666: PUSH
17667: LD_VAR 0 1
17671: ARRAY
17672: PPUSH
17673: LD_VAR 0 1
17677: PUSH
17678: LD_INT 4
17680: MOD
17681: PUSH
17682: LD_INT 1
17684: PLUS
17685: PPUSH
17686: CALL_OW 259
17690: PUSH
17691: LD_INT 10
17693: LESS
17694: IFFALSE 17757
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17696: LD_VAR 0 3
17700: PUSH
17701: LD_VAR 0 1
17705: ARRAY
17706: PPUSH
17707: LD_VAR 0 1
17711: PUSH
17712: LD_INT 4
17714: MOD
17715: PUSH
17716: LD_INT 1
17718: PLUS
17719: PPUSH
17720: LD_VAR 0 3
17724: PUSH
17725: LD_VAR 0 1
17729: ARRAY
17730: PPUSH
17731: LD_VAR 0 1
17735: PUSH
17736: LD_INT 4
17738: MOD
17739: PUSH
17740: LD_INT 1
17742: PLUS
17743: PPUSH
17744: CALL_OW 259
17748: PUSH
17749: LD_INT 1
17751: PLUS
17752: PPUSH
17753: CALL_OW 237
17757: GO 17659
17759: POP
17760: POP
// end ;
17761: PPOPN 3
17763: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17764: LD_EXP 34
17768: PUSH
17769: LD_EXP 42
17773: AND
17774: IFFALSE 17794
17776: GO 17778
17778: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17779: LD_INT 4
17781: PPUSH
17782: LD_OWVAR 2
17786: PPUSH
17787: LD_INT 0
17789: PPUSH
17790: CALL_OW 324
17794: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17795: LD_EXP 34
17799: PUSH
17800: LD_EXP 71
17804: AND
17805: IFFALSE 17825
17807: GO 17809
17809: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17810: LD_INT 19
17812: PPUSH
17813: LD_OWVAR 2
17817: PPUSH
17818: LD_INT 0
17820: PPUSH
17821: CALL_OW 324
17825: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17826: LD_EXP 34
17830: PUSH
17831: LD_EXP 43
17835: AND
17836: IFFALSE 17938
17838: GO 17840
17840: DISABLE
17841: LD_INT 0
17843: PPUSH
17844: PPUSH
// begin enable ;
17845: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17846: LD_ADDR_VAR 0 2
17850: PUSH
17851: LD_INT 22
17853: PUSH
17854: LD_OWVAR 2
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: PUSH
17863: LD_INT 2
17865: PUSH
17866: LD_INT 34
17868: PUSH
17869: LD_INT 11
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: PUSH
17876: LD_INT 34
17878: PUSH
17879: LD_INT 30
17881: PUSH
17882: EMPTY
17883: LIST
17884: LIST
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: LIST
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: PPUSH
17895: CALL_OW 69
17899: ST_TO_ADDR
// if not tmp then
17900: LD_VAR 0 2
17904: NOT
17905: IFFALSE 17909
// exit ;
17907: GO 17938
// for i in tmp do
17909: LD_ADDR_VAR 0 1
17913: PUSH
17914: LD_VAR 0 2
17918: PUSH
17919: FOR_IN
17920: IFFALSE 17936
// begin SetLives ( i , 0 ) ;
17922: LD_VAR 0 1
17926: PPUSH
17927: LD_INT 0
17929: PPUSH
17930: CALL_OW 234
// end ;
17934: GO 17919
17936: POP
17937: POP
// end ;
17938: PPOPN 2
17940: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17941: LD_EXP 34
17945: PUSH
17946: LD_EXP 44
17950: AND
17951: IFFALSE 17971
17953: GO 17955
17955: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17956: LD_INT 32
17958: PPUSH
17959: LD_OWVAR 2
17963: PPUSH
17964: LD_INT 0
17966: PPUSH
17967: CALL_OW 324
17971: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17972: LD_EXP 34
17976: PUSH
17977: LD_EXP 45
17981: AND
17982: IFFALSE 18163
17984: GO 17986
17986: DISABLE
17987: LD_INT 0
17989: PPUSH
17990: PPUSH
17991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17992: LD_ADDR_VAR 0 2
17996: PUSH
17997: LD_INT 22
17999: PUSH
18000: LD_OWVAR 2
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 33
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL_OW 69
18027: ST_TO_ADDR
// if not tmp then
18028: LD_VAR 0 2
18032: NOT
18033: IFFALSE 18037
// exit ;
18035: GO 18163
// side := 0 ;
18037: LD_ADDR_VAR 0 3
18041: PUSH
18042: LD_INT 0
18044: ST_TO_ADDR
// for i := 1 to 8 do
18045: LD_ADDR_VAR 0 1
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_INT 8
18057: PUSH
18058: FOR_TO
18059: IFFALSE 18107
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
18061: LD_OWVAR 2
18065: PUSH
18066: LD_VAR 0 1
18070: NONEQUAL
18071: PUSH
18072: LD_OWVAR 2
18076: PPUSH
18077: LD_VAR 0 1
18081: PPUSH
18082: CALL_OW 81
18086: PUSH
18087: LD_INT 2
18089: EQUAL
18090: AND
18091: IFFALSE 18105
// begin side := i ;
18093: LD_ADDR_VAR 0 3
18097: PUSH
18098: LD_VAR 0 1
18102: ST_TO_ADDR
// break ;
18103: GO 18107
// end ;
18105: GO 18058
18107: POP
18108: POP
// if not side then
18109: LD_VAR 0 3
18113: NOT
18114: IFFALSE 18118
// exit ;
18116: GO 18163
// for i := 1 to tmp do
18118: LD_ADDR_VAR 0 1
18122: PUSH
18123: DOUBLE
18124: LD_INT 1
18126: DEC
18127: ST_TO_ADDR
18128: LD_VAR 0 2
18132: PUSH
18133: FOR_TO
18134: IFFALSE 18161
// if Prob ( 60 ) then
18136: LD_INT 60
18138: PPUSH
18139: CALL_OW 13
18143: IFFALSE 18159
// SetSide ( i , side ) ;
18145: LD_VAR 0 1
18149: PPUSH
18150: LD_VAR 0 3
18154: PPUSH
18155: CALL_OW 235
18159: GO 18133
18161: POP
18162: POP
// end ;
18163: PPOPN 3
18165: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
18166: LD_EXP 34
18170: PUSH
18171: LD_EXP 47
18175: AND
18176: IFFALSE 18295
18178: GO 18180
18180: DISABLE
18181: LD_INT 0
18183: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
18184: LD_ADDR_VAR 0 1
18188: PUSH
18189: LD_INT 22
18191: PUSH
18192: LD_OWVAR 2
18196: PUSH
18197: EMPTY
18198: LIST
18199: LIST
18200: PUSH
18201: LD_INT 21
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PUSH
18211: LD_INT 3
18213: PUSH
18214: LD_INT 23
18216: PUSH
18217: LD_INT 0
18219: PUSH
18220: EMPTY
18221: LIST
18222: LIST
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: PUSH
18228: EMPTY
18229: LIST
18230: LIST
18231: LIST
18232: PPUSH
18233: CALL_OW 69
18237: PUSH
18238: FOR_IN
18239: IFFALSE 18293
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
18241: LD_VAR 0 1
18245: PPUSH
18246: CALL_OW 257
18250: PUSH
18251: LD_INT 1
18253: PUSH
18254: LD_INT 2
18256: PUSH
18257: LD_INT 3
18259: PUSH
18260: LD_INT 4
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: IN
18269: IFFALSE 18291
// SetClass ( un , rand ( 1 , 4 ) ) ;
18271: LD_VAR 0 1
18275: PPUSH
18276: LD_INT 1
18278: PPUSH
18279: LD_INT 4
18281: PPUSH
18282: CALL_OW 12
18286: PPUSH
18287: CALL_OW 336
18291: GO 18238
18293: POP
18294: POP
// end ;
18295: PPOPN 1
18297: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
18298: LD_EXP 34
18302: PUSH
18303: LD_EXP 46
18307: AND
18308: IFFALSE 18387
18310: GO 18312
18312: DISABLE
18313: LD_INT 0
18315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18316: LD_ADDR_VAR 0 1
18320: PUSH
18321: LD_INT 22
18323: PUSH
18324: LD_OWVAR 2
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: LD_INT 21
18335: PUSH
18336: LD_INT 3
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: PUSH
18343: EMPTY
18344: LIST
18345: LIST
18346: PPUSH
18347: CALL_OW 69
18351: ST_TO_ADDR
// if not tmp then
18352: LD_VAR 0 1
18356: NOT
18357: IFFALSE 18361
// exit ;
18359: GO 18387
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
18361: LD_VAR 0 1
18365: PUSH
18366: LD_INT 1
18368: PPUSH
18369: LD_VAR 0 1
18373: PPUSH
18374: CALL_OW 12
18378: ARRAY
18379: PPUSH
18380: LD_INT 100
18382: PPUSH
18383: CALL_OW 234
// end ;
18387: PPOPN 1
18389: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
18390: LD_EXP 34
18394: PUSH
18395: LD_EXP 48
18399: AND
18400: IFFALSE 18498
18402: GO 18404
18404: DISABLE
18405: LD_INT 0
18407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18408: LD_ADDR_VAR 0 1
18412: PUSH
18413: LD_INT 22
18415: PUSH
18416: LD_OWVAR 2
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PUSH
18425: LD_INT 21
18427: PUSH
18428: LD_INT 1
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: PUSH
18435: EMPTY
18436: LIST
18437: LIST
18438: PPUSH
18439: CALL_OW 69
18443: ST_TO_ADDR
// if not tmp then
18444: LD_VAR 0 1
18448: NOT
18449: IFFALSE 18453
// exit ;
18451: GO 18498
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18453: LD_VAR 0 1
18457: PUSH
18458: LD_INT 1
18460: PPUSH
18461: LD_VAR 0 1
18465: PPUSH
18466: CALL_OW 12
18470: ARRAY
18471: PPUSH
18472: LD_INT 1
18474: PPUSH
18475: LD_INT 4
18477: PPUSH
18478: CALL_OW 12
18482: PPUSH
18483: LD_INT 3000
18485: PPUSH
18486: LD_INT 9000
18488: PPUSH
18489: CALL_OW 12
18493: PPUSH
18494: CALL_OW 492
// end ;
18498: PPOPN 1
18500: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18501: LD_EXP 34
18505: PUSH
18506: LD_EXP 49
18510: AND
18511: IFFALSE 18531
18513: GO 18515
18515: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18516: LD_INT 1
18518: PPUSH
18519: LD_OWVAR 2
18523: PPUSH
18524: LD_INT 0
18526: PPUSH
18527: CALL_OW 324
18531: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18532: LD_EXP 34
18536: PUSH
18537: LD_EXP 50
18541: AND
18542: IFFALSE 18625
18544: GO 18546
18546: DISABLE
18547: LD_INT 0
18549: PPUSH
18550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18551: LD_ADDR_VAR 0 2
18555: PUSH
18556: LD_INT 22
18558: PUSH
18559: LD_OWVAR 2
18563: PUSH
18564: EMPTY
18565: LIST
18566: LIST
18567: PUSH
18568: LD_INT 21
18570: PUSH
18571: LD_INT 3
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: EMPTY
18579: LIST
18580: LIST
18581: PPUSH
18582: CALL_OW 69
18586: ST_TO_ADDR
// if not tmp then
18587: LD_VAR 0 2
18591: NOT
18592: IFFALSE 18596
// exit ;
18594: GO 18625
// for i in tmp do
18596: LD_ADDR_VAR 0 1
18600: PUSH
18601: LD_VAR 0 2
18605: PUSH
18606: FOR_IN
18607: IFFALSE 18623
// SetBLevel ( i , 10 ) ;
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 10
18616: PPUSH
18617: CALL_OW 241
18621: GO 18606
18623: POP
18624: POP
// end ;
18625: PPOPN 2
18627: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18628: LD_EXP 34
18632: PUSH
18633: LD_EXP 51
18637: AND
18638: IFFALSE 18749
18640: GO 18642
18642: DISABLE
18643: LD_INT 0
18645: PPUSH
18646: PPUSH
18647: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18648: LD_ADDR_VAR 0 3
18652: PUSH
18653: LD_INT 22
18655: PUSH
18656: LD_OWVAR 2
18660: PUSH
18661: EMPTY
18662: LIST
18663: LIST
18664: PUSH
18665: LD_INT 25
18667: PUSH
18668: LD_INT 1
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL_OW 69
18683: ST_TO_ADDR
// if not tmp then
18684: LD_VAR 0 3
18688: NOT
18689: IFFALSE 18693
// exit ;
18691: GO 18749
// un := tmp [ rand ( 1 , tmp ) ] ;
18693: LD_ADDR_VAR 0 2
18697: PUSH
18698: LD_VAR 0 3
18702: PUSH
18703: LD_INT 1
18705: PPUSH
18706: LD_VAR 0 3
18710: PPUSH
18711: CALL_OW 12
18715: ARRAY
18716: ST_TO_ADDR
// if Crawls ( un ) then
18717: LD_VAR 0 2
18721: PPUSH
18722: CALL_OW 318
18726: IFFALSE 18737
// ComWalk ( un ) ;
18728: LD_VAR 0 2
18732: PPUSH
18733: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18737: LD_VAR 0 2
18741: PPUSH
18742: LD_INT 5
18744: PPUSH
18745: CALL_OW 336
// end ;
18749: PPOPN 3
18751: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18752: LD_EXP 34
18756: PUSH
18757: LD_EXP 52
18761: AND
18762: PUSH
18763: LD_OWVAR 67
18767: PUSH
18768: LD_INT 3
18770: LESS
18771: AND
18772: IFFALSE 18791
18774: GO 18776
18776: DISABLE
// Difficulty := Difficulty + 1 ;
18777: LD_ADDR_OWVAR 67
18781: PUSH
18782: LD_OWVAR 67
18786: PUSH
18787: LD_INT 1
18789: PLUS
18790: ST_TO_ADDR
18791: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18792: LD_EXP 34
18796: PUSH
18797: LD_EXP 53
18801: AND
18802: IFFALSE 18905
18804: GO 18806
18806: DISABLE
18807: LD_INT 0
18809: PPUSH
// begin for i := 1 to 5 do
18810: LD_ADDR_VAR 0 1
18814: PUSH
18815: DOUBLE
18816: LD_INT 1
18818: DEC
18819: ST_TO_ADDR
18820: LD_INT 5
18822: PUSH
18823: FOR_TO
18824: IFFALSE 18903
// begin uc_nation := nation_nature ;
18826: LD_ADDR_OWVAR 21
18830: PUSH
18831: LD_INT 0
18833: ST_TO_ADDR
// uc_side := 0 ;
18834: LD_ADDR_OWVAR 20
18838: PUSH
18839: LD_INT 0
18841: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18842: LD_ADDR_OWVAR 29
18846: PUSH
18847: LD_INT 12
18849: PUSH
18850: LD_INT 12
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: ST_TO_ADDR
// hc_agressivity := 20 ;
18857: LD_ADDR_OWVAR 35
18861: PUSH
18862: LD_INT 20
18864: ST_TO_ADDR
// hc_class := class_tiger ;
18865: LD_ADDR_OWVAR 28
18869: PUSH
18870: LD_INT 14
18872: ST_TO_ADDR
// hc_gallery :=  ;
18873: LD_ADDR_OWVAR 33
18877: PUSH
18878: LD_STRING 
18880: ST_TO_ADDR
// hc_name :=  ;
18881: LD_ADDR_OWVAR 26
18885: PUSH
18886: LD_STRING 
18888: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18889: CALL_OW 44
18893: PPUSH
18894: LD_INT 0
18896: PPUSH
18897: CALL_OW 51
// end ;
18901: GO 18823
18903: POP
18904: POP
// end ;
18905: PPOPN 1
18907: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18908: LD_EXP 34
18912: PUSH
18913: LD_EXP 54
18917: AND
18918: IFFALSE 18927
18920: GO 18922
18922: DISABLE
// StreamSibBomb ;
18923: CALL 18928 0 0
18927: END
// export function StreamSibBomb ; var i , x , y ; begin
18928: LD_INT 0
18930: PPUSH
18931: PPUSH
18932: PPUSH
18933: PPUSH
// result := false ;
18934: LD_ADDR_VAR 0 1
18938: PUSH
18939: LD_INT 0
18941: ST_TO_ADDR
// for i := 1 to 16 do
18942: LD_ADDR_VAR 0 2
18946: PUSH
18947: DOUBLE
18948: LD_INT 1
18950: DEC
18951: ST_TO_ADDR
18952: LD_INT 16
18954: PUSH
18955: FOR_TO
18956: IFFALSE 19155
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18958: LD_ADDR_VAR 0 3
18962: PUSH
18963: LD_INT 10
18965: PUSH
18966: LD_INT 20
18968: PUSH
18969: LD_INT 30
18971: PUSH
18972: LD_INT 40
18974: PUSH
18975: LD_INT 50
18977: PUSH
18978: LD_INT 60
18980: PUSH
18981: LD_INT 70
18983: PUSH
18984: LD_INT 80
18986: PUSH
18987: LD_INT 90
18989: PUSH
18990: LD_INT 100
18992: PUSH
18993: LD_INT 110
18995: PUSH
18996: LD_INT 120
18998: PUSH
18999: LD_INT 130
19001: PUSH
19002: LD_INT 140
19004: PUSH
19005: LD_INT 150
19007: PUSH
19008: EMPTY
19009: LIST
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: LIST
19015: LIST
19016: LIST
19017: LIST
19018: LIST
19019: LIST
19020: LIST
19021: LIST
19022: LIST
19023: LIST
19024: PUSH
19025: LD_INT 1
19027: PPUSH
19028: LD_INT 15
19030: PPUSH
19031: CALL_OW 12
19035: ARRAY
19036: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
19037: LD_ADDR_VAR 0 4
19041: PUSH
19042: LD_INT 10
19044: PUSH
19045: LD_INT 20
19047: PUSH
19048: LD_INT 30
19050: PUSH
19051: LD_INT 40
19053: PUSH
19054: LD_INT 50
19056: PUSH
19057: LD_INT 60
19059: PUSH
19060: LD_INT 70
19062: PUSH
19063: LD_INT 80
19065: PUSH
19066: LD_INT 90
19068: PUSH
19069: LD_INT 100
19071: PUSH
19072: LD_INT 110
19074: PUSH
19075: LD_INT 120
19077: PUSH
19078: LD_INT 130
19080: PUSH
19081: LD_INT 140
19083: PUSH
19084: LD_INT 150
19086: PUSH
19087: EMPTY
19088: LIST
19089: LIST
19090: LIST
19091: LIST
19092: LIST
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: LIST
19103: PUSH
19104: LD_INT 1
19106: PPUSH
19107: LD_INT 15
19109: PPUSH
19110: CALL_OW 12
19114: ARRAY
19115: ST_TO_ADDR
// if ValidHex ( x , y ) then
19116: LD_VAR 0 3
19120: PPUSH
19121: LD_VAR 0 4
19125: PPUSH
19126: CALL_OW 488
19130: IFFALSE 19153
// begin result := [ x , y ] ;
19132: LD_ADDR_VAR 0 1
19136: PUSH
19137: LD_VAR 0 3
19141: PUSH
19142: LD_VAR 0 4
19146: PUSH
19147: EMPTY
19148: LIST
19149: LIST
19150: ST_TO_ADDR
// break ;
19151: GO 19155
// end ; end ;
19153: GO 18955
19155: POP
19156: POP
// if result then
19157: LD_VAR 0 1
19161: IFFALSE 19221
// begin ToLua ( playSibBomb() ) ;
19163: LD_STRING playSibBomb()
19165: PPUSH
19166: CALL_OW 559
// wait ( 0 0$14 ) ;
19170: LD_INT 490
19172: PPUSH
19173: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
19177: LD_VAR 0 1
19181: PUSH
19182: LD_INT 1
19184: ARRAY
19185: PPUSH
19186: LD_VAR 0 1
19190: PUSH
19191: LD_INT 2
19193: ARRAY
19194: PPUSH
19195: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
19199: LD_VAR 0 1
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: LD_VAR 0 1
19212: PUSH
19213: LD_INT 2
19215: ARRAY
19216: PPUSH
19217: CALL_OW 429
// end ; end ;
19221: LD_VAR 0 1
19225: RET
// every 0 0$1 trigger StreamModeActive and sReset do
19226: LD_EXP 34
19230: PUSH
19231: LD_EXP 56
19235: AND
19236: IFFALSE 19248
19238: GO 19240
19240: DISABLE
// YouLost (  ) ;
19241: LD_STRING 
19243: PPUSH
19244: CALL_OW 104
19248: END
// every 0 0$1 trigger StreamModeActive and sFog do
19249: LD_EXP 34
19253: PUSH
19254: LD_EXP 55
19258: AND
19259: IFFALSE 19273
19261: GO 19263
19263: DISABLE
// FogOff ( your_side ) ;
19264: LD_OWVAR 2
19268: PPUSH
19269: CALL_OW 344
19273: END
// every 0 0$1 trigger StreamModeActive and sSun do
19274: LD_EXP 34
19278: PUSH
19279: LD_EXP 57
19283: AND
19284: IFFALSE 19312
19286: GO 19288
19288: DISABLE
// begin solar_recharge_percent := 0 ;
19289: LD_ADDR_OWVAR 79
19293: PUSH
19294: LD_INT 0
19296: ST_TO_ADDR
// wait ( 5 5$00 ) ;
19297: LD_INT 10500
19299: PPUSH
19300: CALL_OW 67
// solar_recharge_percent := 100 ;
19304: LD_ADDR_OWVAR 79
19308: PUSH
19309: LD_INT 100
19311: ST_TO_ADDR
// end ;
19312: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
19313: LD_EXP 34
19317: PUSH
19318: LD_EXP 58
19322: AND
19323: IFFALSE 19562
19325: GO 19327
19327: DISABLE
19328: LD_INT 0
19330: PPUSH
19331: PPUSH
19332: PPUSH
// begin tmp := [ ] ;
19333: LD_ADDR_VAR 0 3
19337: PUSH
19338: EMPTY
19339: ST_TO_ADDR
// for i := 1 to 6 do
19340: LD_ADDR_VAR 0 1
19344: PUSH
19345: DOUBLE
19346: LD_INT 1
19348: DEC
19349: ST_TO_ADDR
19350: LD_INT 6
19352: PUSH
19353: FOR_TO
19354: IFFALSE 19459
// begin uc_nation := nation_nature ;
19356: LD_ADDR_OWVAR 21
19360: PUSH
19361: LD_INT 0
19363: ST_TO_ADDR
// uc_side := 0 ;
19364: LD_ADDR_OWVAR 20
19368: PUSH
19369: LD_INT 0
19371: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
19372: LD_ADDR_OWVAR 29
19376: PUSH
19377: LD_INT 12
19379: PUSH
19380: LD_INT 12
19382: PUSH
19383: EMPTY
19384: LIST
19385: LIST
19386: ST_TO_ADDR
// hc_agressivity := 20 ;
19387: LD_ADDR_OWVAR 35
19391: PUSH
19392: LD_INT 20
19394: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
19395: LD_ADDR_OWVAR 28
19399: PUSH
19400: LD_INT 17
19402: ST_TO_ADDR
// hc_gallery :=  ;
19403: LD_ADDR_OWVAR 33
19407: PUSH
19408: LD_STRING 
19410: ST_TO_ADDR
// hc_name :=  ;
19411: LD_ADDR_OWVAR 26
19415: PUSH
19416: LD_STRING 
19418: ST_TO_ADDR
// un := CreateHuman ;
19419: LD_ADDR_VAR 0 2
19423: PUSH
19424: CALL_OW 44
19428: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
19429: LD_VAR 0 2
19433: PPUSH
19434: LD_INT 1
19436: PPUSH
19437: CALL_OW 51
// tmp := tmp ^ un ;
19441: LD_ADDR_VAR 0 3
19445: PUSH
19446: LD_VAR 0 3
19450: PUSH
19451: LD_VAR 0 2
19455: ADD
19456: ST_TO_ADDR
// end ;
19457: GO 19353
19459: POP
19460: POP
// repeat wait ( 0 0$1 ) ;
19461: LD_INT 35
19463: PPUSH
19464: CALL_OW 67
// for un in tmp do
19468: LD_ADDR_VAR 0 2
19472: PUSH
19473: LD_VAR 0 3
19477: PUSH
19478: FOR_IN
19479: IFFALSE 19553
// begin if IsDead ( un ) then
19481: LD_VAR 0 2
19485: PPUSH
19486: CALL_OW 301
19490: IFFALSE 19510
// begin tmp := tmp diff un ;
19492: LD_ADDR_VAR 0 3
19496: PUSH
19497: LD_VAR 0 3
19501: PUSH
19502: LD_VAR 0 2
19506: DIFF
19507: ST_TO_ADDR
// continue ;
19508: GO 19478
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19510: LD_VAR 0 2
19514: PPUSH
19515: LD_INT 3
19517: PUSH
19518: LD_INT 22
19520: PUSH
19521: LD_INT 0
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: PPUSH
19532: CALL_OW 69
19536: PPUSH
19537: LD_VAR 0 2
19541: PPUSH
19542: CALL_OW 74
19546: PPUSH
19547: CALL_OW 115
// end ;
19551: GO 19478
19553: POP
19554: POP
// until not tmp ;
19555: LD_VAR 0 3
19559: NOT
19560: IFFALSE 19461
// end ;
19562: PPOPN 3
19564: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19565: LD_EXP 34
19569: PUSH
19570: LD_EXP 59
19574: AND
19575: IFFALSE 19629
19577: GO 19579
19579: DISABLE
// begin ToLua ( displayTroll(); ) ;
19580: LD_STRING displayTroll();
19582: PPUSH
19583: CALL_OW 559
// wait ( 3 3$00 ) ;
19587: LD_INT 6300
19589: PPUSH
19590: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19594: LD_STRING hideTroll();
19596: PPUSH
19597: CALL_OW 559
// wait ( 1 1$00 ) ;
19601: LD_INT 2100
19603: PPUSH
19604: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19608: LD_STRING displayTroll();
19610: PPUSH
19611: CALL_OW 559
// wait ( 1 1$00 ) ;
19615: LD_INT 2100
19617: PPUSH
19618: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19622: LD_STRING hideTroll();
19624: PPUSH
19625: CALL_OW 559
// end ;
19629: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19630: LD_EXP 34
19634: PUSH
19635: LD_EXP 60
19639: AND
19640: IFFALSE 19703
19642: GO 19644
19644: DISABLE
19645: LD_INT 0
19647: PPUSH
// begin p := 0 ;
19648: LD_ADDR_VAR 0 1
19652: PUSH
19653: LD_INT 0
19655: ST_TO_ADDR
// repeat game_speed := 1 ;
19656: LD_ADDR_OWVAR 65
19660: PUSH
19661: LD_INT 1
19663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19664: LD_INT 35
19666: PPUSH
19667: CALL_OW 67
// p := p + 1 ;
19671: LD_ADDR_VAR 0 1
19675: PUSH
19676: LD_VAR 0 1
19680: PUSH
19681: LD_INT 1
19683: PLUS
19684: ST_TO_ADDR
// until p >= 60 ;
19685: LD_VAR 0 1
19689: PUSH
19690: LD_INT 60
19692: GREATEREQUAL
19693: IFFALSE 19656
// game_speed := 4 ;
19695: LD_ADDR_OWVAR 65
19699: PUSH
19700: LD_INT 4
19702: ST_TO_ADDR
// end ;
19703: PPOPN 1
19705: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19706: LD_EXP 34
19710: PUSH
19711: LD_EXP 61
19715: AND
19716: IFFALSE 19862
19718: GO 19720
19720: DISABLE
19721: LD_INT 0
19723: PPUSH
19724: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19725: LD_ADDR_VAR 0 1
19729: PUSH
19730: LD_INT 22
19732: PUSH
19733: LD_OWVAR 2
19737: PUSH
19738: EMPTY
19739: LIST
19740: LIST
19741: PUSH
19742: LD_INT 2
19744: PUSH
19745: LD_INT 30
19747: PUSH
19748: LD_INT 0
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: PUSH
19755: LD_INT 30
19757: PUSH
19758: LD_INT 1
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: LIST
19769: PUSH
19770: EMPTY
19771: LIST
19772: LIST
19773: PPUSH
19774: CALL_OW 69
19778: ST_TO_ADDR
// if not depot then
19779: LD_VAR 0 1
19783: NOT
19784: IFFALSE 19788
// exit ;
19786: GO 19862
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19788: LD_ADDR_VAR 0 2
19792: PUSH
19793: LD_VAR 0 1
19797: PUSH
19798: LD_INT 1
19800: PPUSH
19801: LD_VAR 0 1
19805: PPUSH
19806: CALL_OW 12
19810: ARRAY
19811: PPUSH
19812: CALL_OW 274
19816: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19817: LD_VAR 0 2
19821: PPUSH
19822: LD_INT 1
19824: PPUSH
19825: LD_INT 0
19827: PPUSH
19828: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19832: LD_VAR 0 2
19836: PPUSH
19837: LD_INT 2
19839: PPUSH
19840: LD_INT 0
19842: PPUSH
19843: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19847: LD_VAR 0 2
19851: PPUSH
19852: LD_INT 3
19854: PPUSH
19855: LD_INT 0
19857: PPUSH
19858: CALL_OW 277
// end ;
19862: PPOPN 2
19864: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19865: LD_EXP 34
19869: PUSH
19870: LD_EXP 62
19874: AND
19875: IFFALSE 19972
19877: GO 19879
19879: DISABLE
19880: LD_INT 0
19882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19883: LD_ADDR_VAR 0 1
19887: PUSH
19888: LD_INT 22
19890: PUSH
19891: LD_OWVAR 2
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 21
19902: PUSH
19903: LD_INT 1
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: PUSH
19910: LD_INT 3
19912: PUSH
19913: LD_INT 23
19915: PUSH
19916: LD_INT 0
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: PUSH
19923: EMPTY
19924: LIST
19925: LIST
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: LIST
19931: PPUSH
19932: CALL_OW 69
19936: ST_TO_ADDR
// if not tmp then
19937: LD_VAR 0 1
19941: NOT
19942: IFFALSE 19946
// exit ;
19944: GO 19972
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19946: LD_VAR 0 1
19950: PUSH
19951: LD_INT 1
19953: PPUSH
19954: LD_VAR 0 1
19958: PPUSH
19959: CALL_OW 12
19963: ARRAY
19964: PPUSH
19965: LD_INT 200
19967: PPUSH
19968: CALL_OW 234
// end ;
19972: PPOPN 1
19974: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19975: LD_EXP 34
19979: PUSH
19980: LD_EXP 63
19984: AND
19985: IFFALSE 20064
19987: GO 19989
19989: DISABLE
19990: LD_INT 0
19992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19993: LD_ADDR_VAR 0 1
19997: PUSH
19998: LD_INT 22
20000: PUSH
20001: LD_OWVAR 2
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PUSH
20010: LD_INT 21
20012: PUSH
20013: LD_INT 2
20015: PUSH
20016: EMPTY
20017: LIST
20018: LIST
20019: PUSH
20020: EMPTY
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL_OW 69
20028: ST_TO_ADDR
// if not tmp then
20029: LD_VAR 0 1
20033: NOT
20034: IFFALSE 20038
// exit ;
20036: GO 20064
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
20038: LD_VAR 0 1
20042: PUSH
20043: LD_INT 1
20045: PPUSH
20046: LD_VAR 0 1
20050: PPUSH
20051: CALL_OW 12
20055: ARRAY
20056: PPUSH
20057: LD_INT 60
20059: PPUSH
20060: CALL_OW 234
// end ;
20064: PPOPN 1
20066: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
20067: LD_EXP 34
20071: PUSH
20072: LD_EXP 64
20076: AND
20077: IFFALSE 20176
20079: GO 20081
20081: DISABLE
20082: LD_INT 0
20084: PPUSH
20085: PPUSH
// begin enable ;
20086: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
20087: LD_ADDR_VAR 0 1
20091: PUSH
20092: LD_INT 22
20094: PUSH
20095: LD_OWVAR 2
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: PUSH
20104: LD_INT 61
20106: PUSH
20107: EMPTY
20108: LIST
20109: PUSH
20110: LD_INT 33
20112: PUSH
20113: LD_INT 2
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: PUSH
20120: EMPTY
20121: LIST
20122: LIST
20123: LIST
20124: PPUSH
20125: CALL_OW 69
20129: ST_TO_ADDR
// if not tmp then
20130: LD_VAR 0 1
20134: NOT
20135: IFFALSE 20139
// exit ;
20137: GO 20176
// for i in tmp do
20139: LD_ADDR_VAR 0 2
20143: PUSH
20144: LD_VAR 0 1
20148: PUSH
20149: FOR_IN
20150: IFFALSE 20174
// if IsControledBy ( i ) then
20152: LD_VAR 0 2
20156: PPUSH
20157: CALL_OW 312
20161: IFFALSE 20172
// ComUnlink ( i ) ;
20163: LD_VAR 0 2
20167: PPUSH
20168: CALL_OW 136
20172: GO 20149
20174: POP
20175: POP
// end ;
20176: PPOPN 2
20178: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
20179: LD_EXP 34
20183: PUSH
20184: LD_EXP 65
20188: AND
20189: IFFALSE 20329
20191: GO 20193
20193: DISABLE
20194: LD_INT 0
20196: PPUSH
20197: PPUSH
// begin ToLua ( displayPowell(); ) ;
20198: LD_STRING displayPowell();
20200: PPUSH
20201: CALL_OW 559
// uc_side := 0 ;
20205: LD_ADDR_OWVAR 20
20209: PUSH
20210: LD_INT 0
20212: ST_TO_ADDR
// uc_nation := 2 ;
20213: LD_ADDR_OWVAR 21
20217: PUSH
20218: LD_INT 2
20220: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
20221: LD_ADDR_OWVAR 37
20225: PUSH
20226: LD_INT 14
20228: ST_TO_ADDR
// vc_engine := engine_siberite ;
20229: LD_ADDR_OWVAR 39
20233: PUSH
20234: LD_INT 3
20236: ST_TO_ADDR
// vc_control := control_apeman ;
20237: LD_ADDR_OWVAR 38
20241: PUSH
20242: LD_INT 5
20244: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
20245: LD_ADDR_OWVAR 40
20249: PUSH
20250: LD_INT 29
20252: ST_TO_ADDR
// un := CreateVehicle ;
20253: LD_ADDR_VAR 0 2
20257: PUSH
20258: CALL_OW 45
20262: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20263: LD_VAR 0 2
20267: PPUSH
20268: LD_INT 1
20270: PPUSH
20271: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20275: LD_INT 35
20277: PPUSH
20278: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20282: LD_VAR 0 2
20286: PPUSH
20287: LD_INT 22
20289: PUSH
20290: LD_OWVAR 2
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: PPUSH
20299: CALL_OW 69
20303: PPUSH
20304: LD_VAR 0 2
20308: PPUSH
20309: CALL_OW 74
20313: PPUSH
20314: CALL_OW 115
// until IsDead ( un ) ;
20318: LD_VAR 0 2
20322: PPUSH
20323: CALL_OW 301
20327: IFFALSE 20275
// end ;
20329: PPOPN 2
20331: END
// every 0 0$1 trigger StreamModeActive and sStu do
20332: LD_EXP 34
20336: PUSH
20337: LD_EXP 73
20341: AND
20342: IFFALSE 20358
20344: GO 20346
20346: DISABLE
// begin ToLua ( displayStucuk(); ) ;
20347: LD_STRING displayStucuk();
20349: PPUSH
20350: CALL_OW 559
// ResetFog ;
20354: CALL_OW 335
// end ;
20358: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
20359: LD_EXP 34
20363: PUSH
20364: LD_EXP 66
20368: AND
20369: IFFALSE 20510
20371: GO 20373
20373: DISABLE
20374: LD_INT 0
20376: PPUSH
20377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20378: LD_ADDR_VAR 0 2
20382: PUSH
20383: LD_INT 22
20385: PUSH
20386: LD_OWVAR 2
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: PUSH
20395: LD_INT 21
20397: PUSH
20398: LD_INT 1
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PPUSH
20409: CALL_OW 69
20413: ST_TO_ADDR
// if not tmp then
20414: LD_VAR 0 2
20418: NOT
20419: IFFALSE 20423
// exit ;
20421: GO 20510
// un := tmp [ rand ( 1 , tmp ) ] ;
20423: LD_ADDR_VAR 0 1
20427: PUSH
20428: LD_VAR 0 2
20432: PUSH
20433: LD_INT 1
20435: PPUSH
20436: LD_VAR 0 2
20440: PPUSH
20441: CALL_OW 12
20445: ARRAY
20446: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20447: LD_VAR 0 1
20451: PPUSH
20452: LD_INT 0
20454: PPUSH
20455: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20459: LD_VAR 0 1
20463: PPUSH
20464: LD_OWVAR 3
20468: PUSH
20469: LD_VAR 0 1
20473: DIFF
20474: PPUSH
20475: LD_VAR 0 1
20479: PPUSH
20480: CALL_OW 74
20484: PPUSH
20485: CALL_OW 115
// wait ( 0 0$20 ) ;
20489: LD_INT 700
20491: PPUSH
20492: CALL_OW 67
// SetSide ( un , your_side ) ;
20496: LD_VAR 0 1
20500: PPUSH
20501: LD_OWVAR 2
20505: PPUSH
20506: CALL_OW 235
// end ;
20510: PPOPN 2
20512: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20513: LD_EXP 34
20517: PUSH
20518: LD_EXP 67
20522: AND
20523: IFFALSE 20629
20525: GO 20527
20527: DISABLE
20528: LD_INT 0
20530: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20531: LD_ADDR_VAR 0 1
20535: PUSH
20536: LD_INT 22
20538: PUSH
20539: LD_OWVAR 2
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 2
20550: PUSH
20551: LD_INT 30
20553: PUSH
20554: LD_INT 0
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: PUSH
20561: LD_INT 30
20563: PUSH
20564: LD_INT 1
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: PPUSH
20580: CALL_OW 69
20584: ST_TO_ADDR
// if not depot then
20585: LD_VAR 0 1
20589: NOT
20590: IFFALSE 20594
// exit ;
20592: GO 20629
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20594: LD_VAR 0 1
20598: PUSH
20599: LD_INT 1
20601: ARRAY
20602: PPUSH
20603: CALL_OW 250
20607: PPUSH
20608: LD_VAR 0 1
20612: PUSH
20613: LD_INT 1
20615: ARRAY
20616: PPUSH
20617: CALL_OW 251
20621: PPUSH
20622: LD_INT 70
20624: PPUSH
20625: CALL_OW 495
// end ;
20629: PPOPN 1
20631: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20632: LD_EXP 34
20636: PUSH
20637: LD_EXP 68
20641: AND
20642: IFFALSE 20853
20644: GO 20646
20646: DISABLE
20647: LD_INT 0
20649: PPUSH
20650: PPUSH
20651: PPUSH
20652: PPUSH
20653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20654: LD_ADDR_VAR 0 5
20658: PUSH
20659: LD_INT 22
20661: PUSH
20662: LD_OWVAR 2
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: PUSH
20671: LD_INT 21
20673: PUSH
20674: LD_INT 1
20676: PUSH
20677: EMPTY
20678: LIST
20679: LIST
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: PPUSH
20685: CALL_OW 69
20689: ST_TO_ADDR
// if not tmp then
20690: LD_VAR 0 5
20694: NOT
20695: IFFALSE 20699
// exit ;
20697: GO 20853
// for i in tmp do
20699: LD_ADDR_VAR 0 1
20703: PUSH
20704: LD_VAR 0 5
20708: PUSH
20709: FOR_IN
20710: IFFALSE 20851
// begin d := rand ( 0 , 5 ) ;
20712: LD_ADDR_VAR 0 4
20716: PUSH
20717: LD_INT 0
20719: PPUSH
20720: LD_INT 5
20722: PPUSH
20723: CALL_OW 12
20727: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20728: LD_ADDR_VAR 0 2
20732: PUSH
20733: LD_VAR 0 1
20737: PPUSH
20738: CALL_OW 250
20742: PPUSH
20743: LD_VAR 0 4
20747: PPUSH
20748: LD_INT 3
20750: PPUSH
20751: LD_INT 12
20753: PPUSH
20754: CALL_OW 12
20758: PPUSH
20759: CALL_OW 272
20763: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20764: LD_ADDR_VAR 0 3
20768: PUSH
20769: LD_VAR 0 1
20773: PPUSH
20774: CALL_OW 251
20778: PPUSH
20779: LD_VAR 0 4
20783: PPUSH
20784: LD_INT 3
20786: PPUSH
20787: LD_INT 12
20789: PPUSH
20790: CALL_OW 12
20794: PPUSH
20795: CALL_OW 273
20799: ST_TO_ADDR
// if ValidHex ( x , y ) then
20800: LD_VAR 0 2
20804: PPUSH
20805: LD_VAR 0 3
20809: PPUSH
20810: CALL_OW 488
20814: IFFALSE 20849
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20816: LD_VAR 0 1
20820: PPUSH
20821: LD_VAR 0 2
20825: PPUSH
20826: LD_VAR 0 3
20830: PPUSH
20831: LD_INT 3
20833: PPUSH
20834: LD_INT 6
20836: PPUSH
20837: CALL_OW 12
20841: PPUSH
20842: LD_INT 1
20844: PPUSH
20845: CALL_OW 483
// end ;
20849: GO 20709
20851: POP
20852: POP
// end ;
20853: PPOPN 5
20855: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20856: LD_EXP 34
20860: PUSH
20861: LD_EXP 69
20865: AND
20866: IFFALSE 20960
20868: GO 20870
20870: DISABLE
20871: LD_INT 0
20873: PPUSH
20874: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20875: LD_ADDR_VAR 0 2
20879: PUSH
20880: LD_INT 22
20882: PUSH
20883: LD_OWVAR 2
20887: PUSH
20888: EMPTY
20889: LIST
20890: LIST
20891: PUSH
20892: LD_INT 32
20894: PUSH
20895: LD_INT 1
20897: PUSH
20898: EMPTY
20899: LIST
20900: LIST
20901: PUSH
20902: LD_INT 21
20904: PUSH
20905: LD_INT 2
20907: PUSH
20908: EMPTY
20909: LIST
20910: LIST
20911: PUSH
20912: EMPTY
20913: LIST
20914: LIST
20915: LIST
20916: PPUSH
20917: CALL_OW 69
20921: ST_TO_ADDR
// if not tmp then
20922: LD_VAR 0 2
20926: NOT
20927: IFFALSE 20931
// exit ;
20929: GO 20960
// for i in tmp do
20931: LD_ADDR_VAR 0 1
20935: PUSH
20936: LD_VAR 0 2
20940: PUSH
20941: FOR_IN
20942: IFFALSE 20958
// SetFuel ( i , 0 ) ;
20944: LD_VAR 0 1
20948: PPUSH
20949: LD_INT 0
20951: PPUSH
20952: CALL_OW 240
20956: GO 20941
20958: POP
20959: POP
// end ;
20960: PPOPN 2
20962: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20963: LD_EXP 34
20967: PUSH
20968: LD_EXP 70
20972: AND
20973: IFFALSE 21039
20975: GO 20977
20977: DISABLE
20978: LD_INT 0
20980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20981: LD_ADDR_VAR 0 1
20985: PUSH
20986: LD_INT 22
20988: PUSH
20989: LD_OWVAR 2
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: PUSH
20998: LD_INT 30
21000: PUSH
21001: LD_INT 29
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: PPUSH
21012: CALL_OW 69
21016: ST_TO_ADDR
// if not tmp then
21017: LD_VAR 0 1
21021: NOT
21022: IFFALSE 21026
// exit ;
21024: GO 21039
// DestroyUnit ( tmp [ 1 ] ) ;
21026: LD_VAR 0 1
21030: PUSH
21031: LD_INT 1
21033: ARRAY
21034: PPUSH
21035: CALL_OW 65
// end ;
21039: PPOPN 1
21041: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
21042: LD_EXP 34
21046: PUSH
21047: LD_EXP 72
21051: AND
21052: IFFALSE 21181
21054: GO 21056
21056: DISABLE
21057: LD_INT 0
21059: PPUSH
// begin uc_side := 0 ;
21060: LD_ADDR_OWVAR 20
21064: PUSH
21065: LD_INT 0
21067: ST_TO_ADDR
// uc_nation := nation_arabian ;
21068: LD_ADDR_OWVAR 21
21072: PUSH
21073: LD_INT 2
21075: ST_TO_ADDR
// hc_gallery :=  ;
21076: LD_ADDR_OWVAR 33
21080: PUSH
21081: LD_STRING 
21083: ST_TO_ADDR
// hc_name :=  ;
21084: LD_ADDR_OWVAR 26
21088: PUSH
21089: LD_STRING 
21091: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
21092: LD_INT 1
21094: PPUSH
21095: LD_INT 11
21097: PPUSH
21098: LD_INT 10
21100: PPUSH
21101: CALL_OW 380
// un := CreateHuman ;
21105: LD_ADDR_VAR 0 1
21109: PUSH
21110: CALL_OW 44
21114: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21115: LD_VAR 0 1
21119: PPUSH
21120: LD_INT 1
21122: PPUSH
21123: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
21127: LD_INT 35
21129: PPUSH
21130: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 22
21141: PUSH
21142: LD_OWVAR 2
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: PPUSH
21151: CALL_OW 69
21155: PPUSH
21156: LD_VAR 0 1
21160: PPUSH
21161: CALL_OW 74
21165: PPUSH
21166: CALL_OW 115
// until IsDead ( un ) ;
21170: LD_VAR 0 1
21174: PPUSH
21175: CALL_OW 301
21179: IFFALSE 21127
// end ;
21181: PPOPN 1
21183: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
21184: LD_EXP 34
21188: PUSH
21189: LD_EXP 74
21193: AND
21194: IFFALSE 21206
21196: GO 21198
21198: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
21199: LD_STRING earthquake(getX(game), 0, 32)
21201: PPUSH
21202: CALL_OW 559
21206: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
21207: LD_EXP 34
21211: PUSH
21212: LD_EXP 75
21216: AND
21217: IFFALSE 21308
21219: GO 21221
21221: DISABLE
21222: LD_INT 0
21224: PPUSH
// begin enable ;
21225: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
21226: LD_ADDR_VAR 0 1
21230: PUSH
21231: LD_INT 22
21233: PUSH
21234: LD_OWVAR 2
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: PUSH
21243: LD_INT 21
21245: PUSH
21246: LD_INT 2
21248: PUSH
21249: EMPTY
21250: LIST
21251: LIST
21252: PUSH
21253: LD_INT 33
21255: PUSH
21256: LD_INT 3
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PUSH
21263: EMPTY
21264: LIST
21265: LIST
21266: LIST
21267: PPUSH
21268: CALL_OW 69
21272: ST_TO_ADDR
// if not tmp then
21273: LD_VAR 0 1
21277: NOT
21278: IFFALSE 21282
// exit ;
21280: GO 21308
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21282: LD_VAR 0 1
21286: PUSH
21287: LD_INT 1
21289: PPUSH
21290: LD_VAR 0 1
21294: PPUSH
21295: CALL_OW 12
21299: ARRAY
21300: PPUSH
21301: LD_INT 1
21303: PPUSH
21304: CALL_OW 234
// end ;
21308: PPOPN 1
21310: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
21311: LD_EXP 34
21315: PUSH
21316: LD_EXP 76
21320: AND
21321: IFFALSE 21462
21323: GO 21325
21325: DISABLE
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
21330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21331: LD_ADDR_VAR 0 3
21335: PUSH
21336: LD_INT 22
21338: PUSH
21339: LD_OWVAR 2
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: PUSH
21348: LD_INT 25
21350: PUSH
21351: LD_INT 1
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PPUSH
21362: CALL_OW 69
21366: ST_TO_ADDR
// if not tmp then
21367: LD_VAR 0 3
21371: NOT
21372: IFFALSE 21376
// exit ;
21374: GO 21462
// un := tmp [ rand ( 1 , tmp ) ] ;
21376: LD_ADDR_VAR 0 2
21380: PUSH
21381: LD_VAR 0 3
21385: PUSH
21386: LD_INT 1
21388: PPUSH
21389: LD_VAR 0 3
21393: PPUSH
21394: CALL_OW 12
21398: ARRAY
21399: ST_TO_ADDR
// if Crawls ( un ) then
21400: LD_VAR 0 2
21404: PPUSH
21405: CALL_OW 318
21409: IFFALSE 21420
// ComWalk ( un ) ;
21411: LD_VAR 0 2
21415: PPUSH
21416: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
21420: LD_VAR 0 2
21424: PPUSH
21425: LD_INT 9
21427: PPUSH
21428: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
21432: LD_INT 28
21434: PPUSH
21435: LD_OWVAR 2
21439: PPUSH
21440: LD_INT 2
21442: PPUSH
21443: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21447: LD_INT 29
21449: PPUSH
21450: LD_OWVAR 2
21454: PPUSH
21455: LD_INT 2
21457: PPUSH
21458: CALL_OW 322
// end ;
21462: PPOPN 3
21464: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21465: LD_EXP 34
21469: PUSH
21470: LD_EXP 77
21474: AND
21475: IFFALSE 21586
21477: GO 21479
21479: DISABLE
21480: LD_INT 0
21482: PPUSH
21483: PPUSH
21484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21485: LD_ADDR_VAR 0 3
21489: PUSH
21490: LD_INT 22
21492: PUSH
21493: LD_OWVAR 2
21497: PUSH
21498: EMPTY
21499: LIST
21500: LIST
21501: PUSH
21502: LD_INT 25
21504: PUSH
21505: LD_INT 1
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: PPUSH
21516: CALL_OW 69
21520: ST_TO_ADDR
// if not tmp then
21521: LD_VAR 0 3
21525: NOT
21526: IFFALSE 21530
// exit ;
21528: GO 21586
// un := tmp [ rand ( 1 , tmp ) ] ;
21530: LD_ADDR_VAR 0 2
21534: PUSH
21535: LD_VAR 0 3
21539: PUSH
21540: LD_INT 1
21542: PPUSH
21543: LD_VAR 0 3
21547: PPUSH
21548: CALL_OW 12
21552: ARRAY
21553: ST_TO_ADDR
// if Crawls ( un ) then
21554: LD_VAR 0 2
21558: PPUSH
21559: CALL_OW 318
21563: IFFALSE 21574
// ComWalk ( un ) ;
21565: LD_VAR 0 2
21569: PPUSH
21570: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21574: LD_VAR 0 2
21578: PPUSH
21579: LD_INT 8
21581: PPUSH
21582: CALL_OW 336
// end ;
21586: PPOPN 3
21588: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21589: LD_EXP 34
21593: PUSH
21594: LD_EXP 78
21598: AND
21599: IFFALSE 21743
21601: GO 21603
21603: DISABLE
21604: LD_INT 0
21606: PPUSH
21607: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21608: LD_ADDR_VAR 0 2
21612: PUSH
21613: LD_INT 22
21615: PUSH
21616: LD_OWVAR 2
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 21
21627: PUSH
21628: LD_INT 2
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 2
21637: PUSH
21638: LD_INT 34
21640: PUSH
21641: LD_INT 12
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: LD_INT 34
21650: PUSH
21651: LD_INT 51
21653: PUSH
21654: EMPTY
21655: LIST
21656: LIST
21657: PUSH
21658: LD_INT 34
21660: PUSH
21661: LD_INT 32
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: LIST
21672: LIST
21673: PUSH
21674: EMPTY
21675: LIST
21676: LIST
21677: LIST
21678: PPUSH
21679: CALL_OW 69
21683: ST_TO_ADDR
// if not tmp then
21684: LD_VAR 0 2
21688: NOT
21689: IFFALSE 21693
// exit ;
21691: GO 21743
// for i in tmp do
21693: LD_ADDR_VAR 0 1
21697: PUSH
21698: LD_VAR 0 2
21702: PUSH
21703: FOR_IN
21704: IFFALSE 21741
// if GetCargo ( i , mat_artifact ) = 0 then
21706: LD_VAR 0 1
21710: PPUSH
21711: LD_INT 4
21713: PPUSH
21714: CALL_OW 289
21718: PUSH
21719: LD_INT 0
21721: EQUAL
21722: IFFALSE 21739
// SetCargo ( i , mat_siberit , 100 ) ;
21724: LD_VAR 0 1
21728: PPUSH
21729: LD_INT 3
21731: PPUSH
21732: LD_INT 100
21734: PPUSH
21735: CALL_OW 290
21739: GO 21703
21741: POP
21742: POP
// end ;
21743: PPOPN 2
21745: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21746: LD_EXP 34
21750: PUSH
21751: LD_EXP 79
21755: AND
21756: IFFALSE 21909
21758: GO 21760
21760: DISABLE
21761: LD_INT 0
21763: PPUSH
21764: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21765: LD_ADDR_VAR 0 2
21769: PUSH
21770: LD_INT 22
21772: PUSH
21773: LD_OWVAR 2
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: PPUSH
21782: CALL_OW 69
21786: ST_TO_ADDR
// if not tmp then
21787: LD_VAR 0 2
21791: NOT
21792: IFFALSE 21796
// exit ;
21794: GO 21909
// for i := 1 to 2 do
21796: LD_ADDR_VAR 0 1
21800: PUSH
21801: DOUBLE
21802: LD_INT 1
21804: DEC
21805: ST_TO_ADDR
21806: LD_INT 2
21808: PUSH
21809: FOR_TO
21810: IFFALSE 21907
// begin uc_side := your_side ;
21812: LD_ADDR_OWVAR 20
21816: PUSH
21817: LD_OWVAR 2
21821: ST_TO_ADDR
// uc_nation := nation_american ;
21822: LD_ADDR_OWVAR 21
21826: PUSH
21827: LD_INT 1
21829: ST_TO_ADDR
// vc_chassis := us_morphling ;
21830: LD_ADDR_OWVAR 37
21834: PUSH
21835: LD_INT 5
21837: ST_TO_ADDR
// vc_engine := engine_siberite ;
21838: LD_ADDR_OWVAR 39
21842: PUSH
21843: LD_INT 3
21845: ST_TO_ADDR
// vc_control := control_computer ;
21846: LD_ADDR_OWVAR 38
21850: PUSH
21851: LD_INT 3
21853: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21854: LD_ADDR_OWVAR 40
21858: PUSH
21859: LD_INT 10
21861: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
21862: CALL_OW 45
21866: PPUSH
21867: LD_VAR 0 2
21871: PUSH
21872: LD_INT 1
21874: ARRAY
21875: PPUSH
21876: CALL_OW 250
21880: PPUSH
21881: LD_VAR 0 2
21885: PUSH
21886: LD_INT 1
21888: ARRAY
21889: PPUSH
21890: CALL_OW 251
21894: PPUSH
21895: LD_INT 12
21897: PPUSH
21898: LD_INT 1
21900: PPUSH
21901: CALL_OW 50
// end ;
21905: GO 21809
21907: POP
21908: POP
// end ;
21909: PPOPN 2
21911: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21912: LD_EXP 34
21916: PUSH
21917: LD_EXP 80
21921: AND
21922: IFFALSE 22144
21924: GO 21926
21926: DISABLE
21927: LD_INT 0
21929: PPUSH
21930: PPUSH
21931: PPUSH
21932: PPUSH
21933: PPUSH
21934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21935: LD_ADDR_VAR 0 6
21939: PUSH
21940: LD_INT 22
21942: PUSH
21943: LD_OWVAR 2
21947: PUSH
21948: EMPTY
21949: LIST
21950: LIST
21951: PUSH
21952: LD_INT 21
21954: PUSH
21955: LD_INT 1
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 3
21964: PUSH
21965: LD_INT 23
21967: PUSH
21968: LD_INT 0
21970: PUSH
21971: EMPTY
21972: LIST
21973: LIST
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: LIST
21983: PPUSH
21984: CALL_OW 69
21988: ST_TO_ADDR
// if not tmp then
21989: LD_VAR 0 6
21993: NOT
21994: IFFALSE 21998
// exit ;
21996: GO 22144
// s1 := rand ( 1 , 4 ) ;
21998: LD_ADDR_VAR 0 2
22002: PUSH
22003: LD_INT 1
22005: PPUSH
22006: LD_INT 4
22008: PPUSH
22009: CALL_OW 12
22013: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
22014: LD_ADDR_VAR 0 4
22018: PUSH
22019: LD_VAR 0 6
22023: PUSH
22024: LD_INT 1
22026: ARRAY
22027: PPUSH
22028: LD_VAR 0 2
22032: PPUSH
22033: CALL_OW 259
22037: ST_TO_ADDR
// if s1 = 1 then
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: EQUAL
22046: IFFALSE 22066
// s2 := rand ( 2 , 4 ) else
22048: LD_ADDR_VAR 0 3
22052: PUSH
22053: LD_INT 2
22055: PPUSH
22056: LD_INT 4
22058: PPUSH
22059: CALL_OW 12
22063: ST_TO_ADDR
22064: GO 22074
// s2 := 1 ;
22066: LD_ADDR_VAR 0 3
22070: PUSH
22071: LD_INT 1
22073: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
22074: LD_ADDR_VAR 0 5
22078: PUSH
22079: LD_VAR 0 6
22083: PUSH
22084: LD_INT 1
22086: ARRAY
22087: PPUSH
22088: LD_VAR 0 3
22092: PPUSH
22093: CALL_OW 259
22097: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
22098: LD_VAR 0 6
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: PPUSH
22107: LD_VAR 0 2
22111: PPUSH
22112: LD_VAR 0 5
22116: PPUSH
22117: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
22121: LD_VAR 0 6
22125: PUSH
22126: LD_INT 1
22128: ARRAY
22129: PPUSH
22130: LD_VAR 0 3
22134: PPUSH
22135: LD_VAR 0 4
22139: PPUSH
22140: CALL_OW 237
// end ;
22144: PPOPN 6
22146: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
22147: LD_EXP 34
22151: PUSH
22152: LD_EXP 81
22156: AND
22157: IFFALSE 22236
22159: GO 22161
22161: DISABLE
22162: LD_INT 0
22164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
22165: LD_ADDR_VAR 0 1
22169: PUSH
22170: LD_INT 22
22172: PUSH
22173: LD_OWVAR 2
22177: PUSH
22178: EMPTY
22179: LIST
22180: LIST
22181: PUSH
22182: LD_INT 30
22184: PUSH
22185: LD_INT 3
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PPUSH
22196: CALL_OW 69
22200: ST_TO_ADDR
// if not tmp then
22201: LD_VAR 0 1
22205: NOT
22206: IFFALSE 22210
// exit ;
22208: GO 22236
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
22210: LD_VAR 0 1
22214: PUSH
22215: LD_INT 1
22217: PPUSH
22218: LD_VAR 0 1
22222: PPUSH
22223: CALL_OW 12
22227: ARRAY
22228: PPUSH
22229: LD_INT 1
22231: PPUSH
22232: CALL_OW 234
// end ;
22236: PPOPN 1
22238: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
22239: LD_EXP 34
22243: PUSH
22244: LD_EXP 82
22248: AND
22249: IFFALSE 22361
22251: GO 22253
22253: DISABLE
22254: LD_INT 0
22256: PPUSH
22257: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
22258: LD_ADDR_VAR 0 2
22262: PUSH
22263: LD_INT 22
22265: PUSH
22266: LD_OWVAR 2
22270: PUSH
22271: EMPTY
22272: LIST
22273: LIST
22274: PUSH
22275: LD_INT 2
22277: PUSH
22278: LD_INT 30
22280: PUSH
22281: LD_INT 27
22283: PUSH
22284: EMPTY
22285: LIST
22286: LIST
22287: PUSH
22288: LD_INT 30
22290: PUSH
22291: LD_INT 26
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PUSH
22298: LD_INT 30
22300: PUSH
22301: LD_INT 28
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: EMPTY
22309: LIST
22310: LIST
22311: LIST
22312: LIST
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: PPUSH
22318: CALL_OW 69
22322: ST_TO_ADDR
// if not tmp then
22323: LD_VAR 0 2
22327: NOT
22328: IFFALSE 22332
// exit ;
22330: GO 22361
// for i in tmp do
22332: LD_ADDR_VAR 0 1
22336: PUSH
22337: LD_VAR 0 2
22341: PUSH
22342: FOR_IN
22343: IFFALSE 22359
// SetLives ( i , 1 ) ;
22345: LD_VAR 0 1
22349: PPUSH
22350: LD_INT 1
22352: PPUSH
22353: CALL_OW 234
22357: GO 22342
22359: POP
22360: POP
// end ;
22361: PPOPN 2
22363: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
22364: LD_EXP 34
22368: PUSH
22369: LD_EXP 83
22373: AND
22374: IFFALSE 22648
22376: GO 22378
22378: DISABLE
22379: LD_INT 0
22381: PPUSH
22382: PPUSH
22383: PPUSH
// begin i := rand ( 1 , 7 ) ;
22384: LD_ADDR_VAR 0 1
22388: PUSH
22389: LD_INT 1
22391: PPUSH
22392: LD_INT 7
22394: PPUSH
22395: CALL_OW 12
22399: ST_TO_ADDR
// case i of 1 :
22400: LD_VAR 0 1
22404: PUSH
22405: LD_INT 1
22407: DOUBLE
22408: EQUAL
22409: IFTRUE 22413
22411: GO 22423
22413: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
22414: LD_STRING earthquake(getX(game), 0, 32)
22416: PPUSH
22417: CALL_OW 559
22421: GO 22648
22423: LD_INT 2
22425: DOUBLE
22426: EQUAL
22427: IFTRUE 22431
22429: GO 22445
22431: POP
// begin ToLua ( displayStucuk(); ) ;
22432: LD_STRING displayStucuk();
22434: PPUSH
22435: CALL_OW 559
// ResetFog ;
22439: CALL_OW 335
// end ; 3 :
22443: GO 22648
22445: LD_INT 3
22447: DOUBLE
22448: EQUAL
22449: IFTRUE 22453
22451: GO 22557
22453: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22454: LD_ADDR_VAR 0 2
22458: PUSH
22459: LD_INT 22
22461: PUSH
22462: LD_OWVAR 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: LD_INT 25
22473: PUSH
22474: LD_INT 1
22476: PUSH
22477: EMPTY
22478: LIST
22479: LIST
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: PPUSH
22485: CALL_OW 69
22489: ST_TO_ADDR
// if not tmp then
22490: LD_VAR 0 2
22494: NOT
22495: IFFALSE 22499
// exit ;
22497: GO 22648
// un := tmp [ rand ( 1 , tmp ) ] ;
22499: LD_ADDR_VAR 0 3
22503: PUSH
22504: LD_VAR 0 2
22508: PUSH
22509: LD_INT 1
22511: PPUSH
22512: LD_VAR 0 2
22516: PPUSH
22517: CALL_OW 12
22521: ARRAY
22522: ST_TO_ADDR
// if Crawls ( un ) then
22523: LD_VAR 0 3
22527: PPUSH
22528: CALL_OW 318
22532: IFFALSE 22543
// ComWalk ( un ) ;
22534: LD_VAR 0 3
22538: PPUSH
22539: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22543: LD_VAR 0 3
22547: PPUSH
22548: LD_INT 8
22550: PPUSH
22551: CALL_OW 336
// end ; 4 :
22555: GO 22648
22557: LD_INT 4
22559: DOUBLE
22560: EQUAL
22561: IFTRUE 22565
22563: GO 22626
22565: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22566: LD_ADDR_VAR 0 2
22570: PUSH
22571: LD_INT 22
22573: PUSH
22574: LD_OWVAR 2
22578: PUSH
22579: EMPTY
22580: LIST
22581: LIST
22582: PUSH
22583: LD_INT 30
22585: PUSH
22586: LD_INT 29
22588: PUSH
22589: EMPTY
22590: LIST
22591: LIST
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: PPUSH
22597: CALL_OW 69
22601: ST_TO_ADDR
// if not tmp then
22602: LD_VAR 0 2
22606: NOT
22607: IFFALSE 22611
// exit ;
22609: GO 22648
// DestroyUnit ( tmp [ 1 ] ) ;
22611: LD_VAR 0 2
22615: PUSH
22616: LD_INT 1
22618: ARRAY
22619: PPUSH
22620: CALL_OW 65
// end ; 5 .. 7 :
22624: GO 22648
22626: LD_INT 5
22628: DOUBLE
22629: GREATEREQUAL
22630: IFFALSE 22638
22632: LD_INT 7
22634: DOUBLE
22635: LESSEQUAL
22636: IFTRUE 22640
22638: GO 22647
22640: POP
// StreamSibBomb ; end ;
22641: CALL 18928 0 0
22645: GO 22648
22647: POP
// end ;
22648: PPOPN 3
22650: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22651: LD_EXP 34
22655: PUSH
22656: LD_EXP 84
22660: AND
22661: IFFALSE 22817
22663: GO 22665
22665: DISABLE
22666: LD_INT 0
22668: PPUSH
22669: PPUSH
22670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22671: LD_ADDR_VAR 0 2
22675: PUSH
22676: LD_INT 81
22678: PUSH
22679: LD_OWVAR 2
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 2
22690: PUSH
22691: LD_INT 21
22693: PUSH
22694: LD_INT 1
22696: PUSH
22697: EMPTY
22698: LIST
22699: LIST
22700: PUSH
22701: LD_INT 21
22703: PUSH
22704: LD_INT 2
22706: PUSH
22707: EMPTY
22708: LIST
22709: LIST
22710: PUSH
22711: EMPTY
22712: LIST
22713: LIST
22714: LIST
22715: PUSH
22716: EMPTY
22717: LIST
22718: LIST
22719: PPUSH
22720: CALL_OW 69
22724: ST_TO_ADDR
// if not tmp then
22725: LD_VAR 0 2
22729: NOT
22730: IFFALSE 22734
// exit ;
22732: GO 22817
// p := 0 ;
22734: LD_ADDR_VAR 0 3
22738: PUSH
22739: LD_INT 0
22741: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22742: LD_INT 35
22744: PPUSH
22745: CALL_OW 67
// p := p + 1 ;
22749: LD_ADDR_VAR 0 3
22753: PUSH
22754: LD_VAR 0 3
22758: PUSH
22759: LD_INT 1
22761: PLUS
22762: ST_TO_ADDR
// for i in tmp do
22763: LD_ADDR_VAR 0 1
22767: PUSH
22768: LD_VAR 0 2
22772: PUSH
22773: FOR_IN
22774: IFFALSE 22805
// if GetLives ( i ) < 1000 then
22776: LD_VAR 0 1
22780: PPUSH
22781: CALL_OW 256
22785: PUSH
22786: LD_INT 1000
22788: LESS
22789: IFFALSE 22803
// SetLives ( i , 1000 ) ;
22791: LD_VAR 0 1
22795: PPUSH
22796: LD_INT 1000
22798: PPUSH
22799: CALL_OW 234
22803: GO 22773
22805: POP
22806: POP
// until p > 20 ;
22807: LD_VAR 0 3
22811: PUSH
22812: LD_INT 20
22814: GREATER
22815: IFFALSE 22742
// end ;
22817: PPOPN 3
22819: END
// every 0 0$1 trigger StreamModeActive and sTime do
22820: LD_EXP 34
22824: PUSH
22825: LD_EXP 85
22829: AND
22830: IFFALSE 22865
22832: GO 22834
22834: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22835: LD_INT 28
22837: PPUSH
22838: LD_OWVAR 2
22842: PPUSH
22843: LD_INT 2
22845: PPUSH
22846: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22850: LD_INT 30
22852: PPUSH
22853: LD_OWVAR 2
22857: PPUSH
22858: LD_INT 2
22860: PPUSH
22861: CALL_OW 322
// end ;
22865: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22866: LD_EXP 34
22870: PUSH
22871: LD_EXP 86
22875: AND
22876: IFFALSE 22997
22878: GO 22880
22880: DISABLE
22881: LD_INT 0
22883: PPUSH
22884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22885: LD_ADDR_VAR 0 2
22889: PUSH
22890: LD_INT 22
22892: PUSH
22893: LD_OWVAR 2
22897: PUSH
22898: EMPTY
22899: LIST
22900: LIST
22901: PUSH
22902: LD_INT 21
22904: PUSH
22905: LD_INT 1
22907: PUSH
22908: EMPTY
22909: LIST
22910: LIST
22911: PUSH
22912: LD_INT 3
22914: PUSH
22915: LD_INT 23
22917: PUSH
22918: LD_INT 0
22920: PUSH
22921: EMPTY
22922: LIST
22923: LIST
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: LIST
22933: PPUSH
22934: CALL_OW 69
22938: ST_TO_ADDR
// if not tmp then
22939: LD_VAR 0 2
22943: NOT
22944: IFFALSE 22948
// exit ;
22946: GO 22997
// for i in tmp do
22948: LD_ADDR_VAR 0 1
22952: PUSH
22953: LD_VAR 0 2
22957: PUSH
22958: FOR_IN
22959: IFFALSE 22995
// begin if Crawls ( i ) then
22961: LD_VAR 0 1
22965: PPUSH
22966: CALL_OW 318
22970: IFFALSE 22981
// ComWalk ( i ) ;
22972: LD_VAR 0 1
22976: PPUSH
22977: CALL_OW 138
// SetClass ( i , 2 ) ;
22981: LD_VAR 0 1
22985: PPUSH
22986: LD_INT 2
22988: PPUSH
22989: CALL_OW 336
// end ;
22993: GO 22958
22995: POP
22996: POP
// end ;
22997: PPOPN 2
22999: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
23000: LD_EXP 34
23004: PUSH
23005: LD_EXP 87
23009: AND
23010: IFFALSE 23291
23012: GO 23014
23014: DISABLE
23015: LD_INT 0
23017: PPUSH
23018: PPUSH
23019: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
23020: LD_OWVAR 2
23024: PPUSH
23025: LD_INT 9
23027: PPUSH
23028: LD_INT 1
23030: PPUSH
23031: LD_INT 1
23033: PPUSH
23034: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
23038: LD_INT 9
23040: PPUSH
23041: LD_OWVAR 2
23045: PPUSH
23046: CALL_OW 343
// uc_side := 9 ;
23050: LD_ADDR_OWVAR 20
23054: PUSH
23055: LD_INT 9
23057: ST_TO_ADDR
// uc_nation := 2 ;
23058: LD_ADDR_OWVAR 21
23062: PUSH
23063: LD_INT 2
23065: ST_TO_ADDR
// hc_name := Dark Warrior ;
23066: LD_ADDR_OWVAR 26
23070: PUSH
23071: LD_STRING Dark Warrior
23073: ST_TO_ADDR
// hc_gallery :=  ;
23074: LD_ADDR_OWVAR 33
23078: PUSH
23079: LD_STRING 
23081: ST_TO_ADDR
// hc_noskilllimit := true ;
23082: LD_ADDR_OWVAR 76
23086: PUSH
23087: LD_INT 1
23089: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
23090: LD_ADDR_OWVAR 31
23094: PUSH
23095: LD_INT 30
23097: PUSH
23098: LD_INT 30
23100: PUSH
23101: LD_INT 30
23103: PUSH
23104: LD_INT 30
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: LIST
23111: LIST
23112: ST_TO_ADDR
// un := CreateHuman ;
23113: LD_ADDR_VAR 0 3
23117: PUSH
23118: CALL_OW 44
23122: ST_TO_ADDR
// hc_noskilllimit := false ;
23123: LD_ADDR_OWVAR 76
23127: PUSH
23128: LD_INT 0
23130: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23131: LD_VAR 0 3
23135: PPUSH
23136: LD_INT 1
23138: PPUSH
23139: CALL_OW 51
// p := 0 ;
23143: LD_ADDR_VAR 0 2
23147: PUSH
23148: LD_INT 0
23150: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23151: LD_INT 35
23153: PPUSH
23154: CALL_OW 67
// p := p + 1 ;
23158: LD_ADDR_VAR 0 2
23162: PUSH
23163: LD_VAR 0 2
23167: PUSH
23168: LD_INT 1
23170: PLUS
23171: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
23172: LD_VAR 0 3
23176: PPUSH
23177: CALL_OW 256
23181: PUSH
23182: LD_INT 1000
23184: LESS
23185: IFFALSE 23199
// SetLives ( un , 1000 ) ;
23187: LD_VAR 0 3
23191: PPUSH
23192: LD_INT 1000
23194: PPUSH
23195: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
23199: LD_VAR 0 3
23203: PPUSH
23204: LD_INT 81
23206: PUSH
23207: LD_OWVAR 2
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 91
23218: PUSH
23219: LD_VAR 0 3
23223: PUSH
23224: LD_INT 30
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: PPUSH
23236: CALL_OW 69
23240: PPUSH
23241: LD_VAR 0 3
23245: PPUSH
23246: CALL_OW 74
23250: PPUSH
23251: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
23255: LD_VAR 0 2
23259: PUSH
23260: LD_INT 60
23262: GREATER
23263: PUSH
23264: LD_VAR 0 3
23268: PPUSH
23269: CALL_OW 301
23273: OR
23274: IFFALSE 23151
// if un then
23276: LD_VAR 0 3
23280: IFFALSE 23291
// RemoveUnit ( un ) ;
23282: LD_VAR 0 3
23286: PPUSH
23287: CALL_OW 64
// end ; end_of_file
23291: PPOPN 3
23293: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
23294: LD_INT 0
23296: PPUSH
23297: PPUSH
23298: PPUSH
23299: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 264
23309: PUSH
23310: LD_EXP 25
23314: EQUAL
23315: IFFALSE 23387
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
23317: LD_INT 68
23319: PPUSH
23320: LD_VAR 0 1
23324: PPUSH
23325: CALL_OW 255
23329: PPUSH
23330: CALL_OW 321
23334: PUSH
23335: LD_INT 2
23337: EQUAL
23338: IFFALSE 23350
// eff := 70 else
23340: LD_ADDR_VAR 0 4
23344: PUSH
23345: LD_INT 70
23347: ST_TO_ADDR
23348: GO 23358
// eff := 30 ;
23350: LD_ADDR_VAR 0 4
23354: PUSH
23355: LD_INT 30
23357: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
23358: LD_VAR 0 1
23362: PPUSH
23363: CALL_OW 250
23367: PPUSH
23368: LD_VAR 0 1
23372: PPUSH
23373: CALL_OW 251
23377: PPUSH
23378: LD_VAR 0 4
23382: PPUSH
23383: CALL_OW 495
// end ; end ;
23387: LD_VAR 0 2
23391: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
23392: LD_INT 0
23394: PPUSH
// end ;
23395: LD_VAR 0 4
23399: RET
// export function SOS_Command ( cmd ) ; begin
23400: LD_INT 0
23402: PPUSH
// end ;
23403: LD_VAR 0 2
23407: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
23408: LD_VAR 0 1
23412: PUSH
23413: LD_INT 255
23415: EQUAL
23416: PUSH
23417: LD_VAR 0 2
23421: PPUSH
23422: CALL_OW 264
23426: PUSH
23427: LD_INT 14
23429: PUSH
23430: LD_INT 53
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: IN
23437: AND
23438: PUSH
23439: LD_VAR 0 4
23443: PPUSH
23444: LD_VAR 0 5
23448: PPUSH
23449: CALL_OW 488
23453: AND
23454: IFFALSE 23478
// CutTreeXYR ( unit , x , y , 12 ) ;
23456: LD_VAR 0 2
23460: PPUSH
23461: LD_VAR 0 4
23465: PPUSH
23466: LD_VAR 0 5
23470: PPUSH
23471: LD_INT 12
23473: PPUSH
23474: CALL 23481 0 4
// end ;
23478: PPOPN 5
23480: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
23481: LD_INT 0
23483: PPUSH
23484: PPUSH
23485: PPUSH
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
23492: LD_VAR 0 1
23496: NOT
23497: PUSH
23498: LD_VAR 0 2
23502: PPUSH
23503: LD_VAR 0 3
23507: PPUSH
23508: CALL_OW 488
23512: NOT
23513: OR
23514: PUSH
23515: LD_VAR 0 4
23519: NOT
23520: OR
23521: IFFALSE 23525
// exit ;
23523: GO 23865
// list := [ ] ;
23525: LD_ADDR_VAR 0 13
23529: PUSH
23530: EMPTY
23531: ST_TO_ADDR
// if x - r < 0 then
23532: LD_VAR 0 2
23536: PUSH
23537: LD_VAR 0 4
23541: MINUS
23542: PUSH
23543: LD_INT 0
23545: LESS
23546: IFFALSE 23558
// min_x := 0 else
23548: LD_ADDR_VAR 0 7
23552: PUSH
23553: LD_INT 0
23555: ST_TO_ADDR
23556: GO 23574
// min_x := x - r ;
23558: LD_ADDR_VAR 0 7
23562: PUSH
23563: LD_VAR 0 2
23567: PUSH
23568: LD_VAR 0 4
23572: MINUS
23573: ST_TO_ADDR
// if y - r < 0 then
23574: LD_VAR 0 3
23578: PUSH
23579: LD_VAR 0 4
23583: MINUS
23584: PUSH
23585: LD_INT 0
23587: LESS
23588: IFFALSE 23600
// min_y := 0 else
23590: LD_ADDR_VAR 0 8
23594: PUSH
23595: LD_INT 0
23597: ST_TO_ADDR
23598: GO 23616
// min_y := y - r ;
23600: LD_ADDR_VAR 0 8
23604: PUSH
23605: LD_VAR 0 3
23609: PUSH
23610: LD_VAR 0 4
23614: MINUS
23615: ST_TO_ADDR
// max_x := x + r ;
23616: LD_ADDR_VAR 0 9
23620: PUSH
23621: LD_VAR 0 2
23625: PUSH
23626: LD_VAR 0 4
23630: PLUS
23631: ST_TO_ADDR
// max_y := y + r ;
23632: LD_ADDR_VAR 0 10
23636: PUSH
23637: LD_VAR 0 3
23641: PUSH
23642: LD_VAR 0 4
23646: PLUS
23647: ST_TO_ADDR
// for _x = min_x to max_x do
23648: LD_ADDR_VAR 0 11
23652: PUSH
23653: DOUBLE
23654: LD_VAR 0 7
23658: DEC
23659: ST_TO_ADDR
23660: LD_VAR 0 9
23664: PUSH
23665: FOR_TO
23666: IFFALSE 23783
// for _y = min_y to max_y do
23668: LD_ADDR_VAR 0 12
23672: PUSH
23673: DOUBLE
23674: LD_VAR 0 8
23678: DEC
23679: ST_TO_ADDR
23680: LD_VAR 0 10
23684: PUSH
23685: FOR_TO
23686: IFFALSE 23779
// begin if not ValidHex ( _x , _y ) then
23688: LD_VAR 0 11
23692: PPUSH
23693: LD_VAR 0 12
23697: PPUSH
23698: CALL_OW 488
23702: NOT
23703: IFFALSE 23707
// continue ;
23705: GO 23685
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
23707: LD_VAR 0 11
23711: PPUSH
23712: LD_VAR 0 12
23716: PPUSH
23717: CALL_OW 351
23721: PUSH
23722: LD_VAR 0 11
23726: PPUSH
23727: LD_VAR 0 12
23731: PPUSH
23732: CALL_OW 554
23736: AND
23737: IFFALSE 23777
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
23739: LD_ADDR_VAR 0 13
23743: PUSH
23744: LD_VAR 0 13
23748: PPUSH
23749: LD_VAR 0 13
23753: PUSH
23754: LD_INT 1
23756: PLUS
23757: PPUSH
23758: LD_VAR 0 11
23762: PUSH
23763: LD_VAR 0 12
23767: PUSH
23768: EMPTY
23769: LIST
23770: LIST
23771: PPUSH
23772: CALL_OW 2
23776: ST_TO_ADDR
// end ;
23777: GO 23685
23779: POP
23780: POP
23781: GO 23665
23783: POP
23784: POP
// if not list then
23785: LD_VAR 0 13
23789: NOT
23790: IFFALSE 23794
// exit ;
23792: GO 23865
// for i in list do
23794: LD_ADDR_VAR 0 6
23798: PUSH
23799: LD_VAR 0 13
23803: PUSH
23804: FOR_IN
23805: IFFALSE 23863
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
23807: LD_VAR 0 1
23811: PPUSH
23812: LD_STRING M
23814: PUSH
23815: LD_VAR 0 6
23819: PUSH
23820: LD_INT 1
23822: ARRAY
23823: PUSH
23824: LD_VAR 0 6
23828: PUSH
23829: LD_INT 2
23831: ARRAY
23832: PUSH
23833: LD_INT 0
23835: PUSH
23836: LD_INT 0
23838: PUSH
23839: LD_INT 0
23841: PUSH
23842: LD_INT 0
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: LIST
23853: PUSH
23854: EMPTY
23855: LIST
23856: PPUSH
23857: CALL_OW 447
23861: GO 23804
23863: POP
23864: POP
// end ;
23865: LD_VAR 0 5
23869: RET
