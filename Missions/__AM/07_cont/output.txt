// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 37 0 0
// DebugMode ;
  12: CALL 238 0 0
// PrepareNature ;
  16: CALL 2922 0 0
// PrepareRussians ;
  20: CALL 4636 0 0
// PrepareAmericans ;
  24: CALL 3579 0 0
// Action ;
  28: CALL 8399 0 0
// SaveForQuickRestart ;
  32: CALL_OW 22
// end ;
  36: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  37: LD_INT 0
  39: PPUSH
// debug := false ;
  40: LD_ADDR_EXP 1
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// mission_prefix := 07c_ ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_STRING 07c_
  55: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 07_
  63: ST_TO_ADDR
// buildings_counter := 0 ;
  64: LD_ADDR_EXP 4
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  72: LD_ADDR_EXP 5
  76: PUSH
  77: LD_INT 67200
  79: PUSH
  80: LD_INT 60900
  82: PUSH
  83: LD_INT 54600
  85: PUSH
  86: EMPTY
  87: LIST
  88: LIST
  89: LIST
  90: PUSH
  91: LD_OWVAR 67
  95: ARRAY
  96: PUSH
  97: LD_INT 79800
  99: PUSH
 100: LD_INT 73500
 102: PUSH
 103: LD_INT 67200
 105: PUSH
 106: EMPTY
 107: LIST
 108: LIST
 109: LIST
 110: PUSH
 111: LD_OWVAR 67
 115: ARRAY
 116: PUSH
 117: LD_INT 92400
 119: PUSH
 120: LD_INT 86100
 122: PUSH
 123: LD_INT 79800
 125: PUSH
 126: EMPTY
 127: LIST
 128: LIST
 129: LIST
 130: PUSH
 131: LD_OWVAR 67
 135: ARRAY
 136: PUSH
 137: EMPTY
 138: LIST
 139: LIST
 140: LIST
 141: ST_TO_ADDR
// can_end := false ;
 142: LD_ADDR_EXP 6
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// must_end := false ;
 150: LD_ADDR_EXP 7
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// end ;
 158: LD_VAR 0 1
 162: RET
// every 0 0$01 trigger not debug do
 163: LD_EXP 1
 167: NOT
 168: IFFALSE 237
 170: GO 172
 172: DISABLE
// begin enable ;
 173: ENABLE
// if not must_end then
 174: LD_EXP 7
 178: NOT
 179: IFFALSE 200
// display_strings := [ #Am07-1 , tick ] else
 181: LD_ADDR_OWVAR 47
 185: PUSH
 186: LD_STRING #Am07-1
 188: PUSH
 189: LD_OWVAR 1
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: ST_TO_ADDR
 198: GO 237
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 200: LD_ADDR_OWVAR 47
 204: PUSH
 205: LD_STRING #Am07-1
 207: PUSH
 208: LD_OWVAR 1
 212: PUSH
 213: LD_STRING #Am07-2
 215: PUSH
 216: LD_EXP 5
 220: PUSH
 221: LD_INT 3
 223: ARRAY
 224: PUSH
 225: LD_OWVAR 1
 229: MINUS
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: ST_TO_ADDR
// end ;
 237: END
// function DebugMode ; var i ; begin
 238: LD_INT 0
 240: PPUSH
 241: PPUSH
// if not debug then
 242: LD_EXP 1
 246: NOT
 247: IFFALSE 251
// exit ;
 249: GO 258
// FogOff ( 1 ) ;
 251: LD_INT 1
 253: PPUSH
 254: CALL_OW 344
// end ;
 258: LD_VAR 0 1
 262: RET
// every 3 trigger debug do var i , filter ;
 263: LD_EXP 1
 267: IFFALSE 356
 269: GO 271
 271: DISABLE
 272: LD_INT 0
 274: PPUSH
 275: PPUSH
// begin enable ;
 276: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 277: LD_ADDR_VAR 0 2
 281: PUSH
 282: LD_INT 22
 284: PUSH
 285: LD_INT 1
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: PUSH
 292: LD_INT 3
 294: PUSH
 295: LD_INT 24
 297: PUSH
 298: LD_INT 500
 300: PUSH
 301: EMPTY
 302: LIST
 303: LIST
 304: PUSH
 305: EMPTY
 306: LIST
 307: LIST
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL_OW 69
 317: ST_TO_ADDR
// if not filter then
 318: LD_VAR 0 2
 322: NOT
 323: IFFALSE 327
// exit ;
 325: GO 356
// for i in filter do
 327: LD_ADDR_VAR 0 1
 331: PUSH
 332: LD_VAR 0 2
 336: PUSH
 337: FOR_IN
 338: IFFALSE 354
// SetLives ( i , 1000 ) ;
 340: LD_VAR 0 1
 344: PPUSH
 345: LD_INT 1000
 347: PPUSH
 348: CALL_OW 234
 352: GO 337
 354: POP
 355: POP
// end ; end_of_file
 356: PPOPN 2
 358: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 359: LD_INT 0
 361: PPUSH
 362: PPUSH
// if exist_mode then
 363: LD_VAR 0 2
 367: IFFALSE 392
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 369: LD_ADDR_VAR 0 4
 373: PUSH
 374: LD_EXP 2
 378: PUSH
 379: LD_VAR 0 1
 383: STR
 384: PPUSH
 385: CALL_OW 34
 389: ST_TO_ADDR
 390: GO 407
// unit := NewCharacter ( ident ) ;
 392: LD_ADDR_VAR 0 4
 396: PUSH
 397: LD_VAR 0 1
 401: PPUSH
 402: CALL_OW 25
 406: ST_TO_ADDR
// result := unit ;
 407: LD_ADDR_VAR 0 3
 411: PUSH
 412: LD_VAR 0 4
 416: ST_TO_ADDR
// end ;
 417: LD_VAR 0 3
 421: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 422: LD_INT 0
 424: PPUSH
// uc_side := side ;
 425: LD_ADDR_OWVAR 20
 429: PUSH
 430: LD_VAR 0 1
 434: ST_TO_ADDR
// uc_nation := nation ;
 435: LD_ADDR_OWVAR 21
 439: PUSH
 440: LD_VAR 0 2
 444: ST_TO_ADDR
// vc_chassis := chassis ;
 445: LD_ADDR_OWVAR 37
 449: PUSH
 450: LD_VAR 0 3
 454: ST_TO_ADDR
// vc_engine := engine ;
 455: LD_ADDR_OWVAR 39
 459: PUSH
 460: LD_VAR 0 4
 464: ST_TO_ADDR
// vc_control := control ;
 465: LD_ADDR_OWVAR 38
 469: PUSH
 470: LD_VAR 0 5
 474: ST_TO_ADDR
// vc_weapon := weapon ;
 475: LD_ADDR_OWVAR 40
 479: PUSH
 480: LD_VAR 0 6
 484: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 485: LD_ADDR_OWVAR 41
 489: PUSH
 490: LD_VAR 0 7
 494: ST_TO_ADDR
// result := CreateVehicle ;
 495: LD_ADDR_VAR 0 8
 499: PUSH
 500: CALL_OW 45
 504: ST_TO_ADDR
// end ;
 505: LD_VAR 0 8
 509: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 510: LD_INT 0
 512: PPUSH
 513: PPUSH
 514: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 515: LD_ADDR_VAR 0 4
 519: PUSH
 520: LD_INT 22
 522: PUSH
 523: LD_INT 1
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: PUSH
 530: LD_INT 21
 532: PUSH
 533: LD_INT 1
 535: PUSH
 536: EMPTY
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 50
 542: PUSH
 543: EMPTY
 544: LIST
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL_OW 69
 555: PUSH
 556: LD_EXP 8
 560: PUSH
 561: LD_EXP 9
 565: PUSH
 566: LD_EXP 10
 570: PUSH
 571: LD_EXP 11
 575: PUSH
 576: LD_EXP 12
 580: PUSH
 581: LD_EXP 13
 585: PUSH
 586: LD_EXP 14
 590: PUSH
 591: LD_EXP 15
 595: PUSH
 596: LD_EXP 17
 600: PUSH
 601: LD_EXP 16
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: DIFF
 618: ST_TO_ADDR
// if not filter then
 619: LD_VAR 0 4
 623: NOT
 624: IFFALSE 628
// exit ;
 626: GO 655
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 628: LD_ADDR_VAR 0 2
 632: PUSH
 633: LD_VAR 0 4
 637: PPUSH
 638: LD_INT 26
 640: PUSH
 641: LD_VAR 0 1
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: PPUSH
 650: CALL_OW 72
 654: ST_TO_ADDR
// end ;
 655: LD_VAR 0 2
 659: RET
// export function SayX ( units , ident ) ; var i ; begin
 660: LD_INT 0
 662: PPUSH
 663: PPUSH
// result := false ;
 664: LD_ADDR_VAR 0 3
 668: PUSH
 669: LD_INT 0
 671: ST_TO_ADDR
// if not units then
 672: LD_VAR 0 1
 676: NOT
 677: IFFALSE 681
// exit ;
 679: GO 735
// for i in units do
 681: LD_ADDR_VAR 0 4
 685: PUSH
 686: LD_VAR 0 1
 690: PUSH
 691: FOR_IN
 692: IFFALSE 733
// if IsOk ( i ) then
 694: LD_VAR 0 4
 698: PPUSH
 699: CALL_OW 302
 703: IFFALSE 731
// begin Say ( i , ident ) ;
 705: LD_VAR 0 4
 709: PPUSH
 710: LD_VAR 0 2
 714: PPUSH
 715: CALL_OW 88
// result := i ;
 719: LD_ADDR_VAR 0 3
 723: PUSH
 724: LD_VAR 0 4
 728: ST_TO_ADDR
// break ;
 729: GO 733
// end ;
 731: GO 691
 733: POP
 734: POP
// end ;
 735: LD_VAR 0 3
 739: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 740: LD_INT 0
 742: PPUSH
 743: PPUSH
 744: PPUSH
// result := [ ] ;
 745: LD_ADDR_VAR 0 2
 749: PUSH
 750: EMPTY
 751: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 752: LD_ADDR_VAR 0 3
 756: PUSH
 757: LD_INT 21
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: EMPTY
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL_OW 69
 771: ST_TO_ADDR
// if not tmp then
 772: LD_VAR 0 3
 776: NOT
 777: IFFALSE 781
// exit ;
 779: GO 831
// for i in tmp do
 781: LD_ADDR_VAR 0 4
 785: PUSH
 786: LD_VAR 0 3
 790: PUSH
 791: FOR_IN
 792: IFFALSE 829
// if GetBase ( i ) = base then
 794: LD_VAR 0 4
 798: PPUSH
 799: CALL_OW 274
 803: PUSH
 804: LD_VAR 0 1
 808: EQUAL
 809: IFFALSE 827
// result := result ^ i ;
 811: LD_ADDR_VAR 0 2
 815: PUSH
 816: LD_VAR 0 2
 820: PUSH
 821: LD_VAR 0 4
 825: ADD
 826: ST_TO_ADDR
 827: GO 791
 829: POP
 830: POP
// end ;
 831: LD_VAR 0 2
 835: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 836: LD_INT 0
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
 843: PPUSH
 844: PPUSH
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
 852: PPUSH
 853: PPUSH
// result := false ;
 854: LD_ADDR_VAR 0 2
 858: PUSH
 859: LD_INT 0
 861: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 862: LD_VAR 0 1
 866: NOT
 867: PUSH
 868: LD_VAR 0 1
 872: PPUSH
 873: CALL_OW 266
 877: PUSH
 878: LD_INT 32
 880: PUSH
 881: LD_INT 33
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: IN
 888: NOT
 889: OR
 890: IFFALSE 894
// exit ;
 892: GO 2054
// nat := GetNation ( tower ) ;
 894: LD_ADDR_VAR 0 11
 898: PUSH
 899: LD_VAR 0 1
 903: PPUSH
 904: CALL_OW 248
 908: ST_TO_ADDR
// side := GetSide ( tower ) ;
 909: LD_ADDR_VAR 0 15
 913: PUSH
 914: LD_VAR 0 1
 918: PPUSH
 919: CALL_OW 255
 923: ST_TO_ADDR
// x := GetX ( tower ) ;
 924: LD_ADDR_VAR 0 9
 928: PUSH
 929: LD_VAR 0 1
 933: PPUSH
 934: CALL_OW 250
 938: ST_TO_ADDR
// y := GetY ( tower ) ;
 939: LD_ADDR_VAR 0 10
 943: PUSH
 944: LD_VAR 0 1
 948: PPUSH
 949: CALL_OW 251
 953: ST_TO_ADDR
// if not x or not y then
 954: LD_VAR 0 9
 958: NOT
 959: PUSH
 960: LD_VAR 0 10
 964: NOT
 965: OR
 966: IFFALSE 970
// exit ;
 968: GO 2054
// weapon := 0 ;
 970: LD_ADDR_VAR 0 17
 974: PUSH
 975: LD_INT 0
 977: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 978: LD_ADDR_VAR 0 16
 982: PUSH
 983: LD_INT 42
 985: PUSH
 986: LD_INT 43
 988: PUSH
 989: LD_INT 44
 991: PUSH
 992: LD_INT 46
 994: PUSH
 995: EMPTY
 996: LIST
 997: LIST
 998: LIST
 999: LIST
1000: ST_TO_ADDR
// if not fac_list then
1001: LD_VAR 0 16
1005: NOT
1006: IFFALSE 1010
// exit ;
1008: GO 2054
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1010: LD_ADDR_VAR 0 4
1014: PUSH
1015: LD_INT 4
1017: PUSH
1018: LD_INT 5
1020: PUSH
1021: LD_INT 9
1023: PUSH
1024: LD_INT 10
1026: PUSH
1027: LD_INT 6
1029: PUSH
1030: LD_INT 7
1032: PUSH
1033: LD_INT 11
1035: PUSH
1036: EMPTY
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 27
1047: PUSH
1048: LD_INT 28
1050: PUSH
1051: LD_INT 26
1053: PUSH
1054: LD_INT 30
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 43
1065: PUSH
1066: LD_INT 44
1068: PUSH
1069: LD_INT 46
1071: PUSH
1072: LD_INT 45
1074: PUSH
1075: LD_INT 47
1077: PUSH
1078: LD_INT 49
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: PUSH
1094: LD_VAR 0 11
1098: ARRAY
1099: ST_TO_ADDR
// for i in list do
1100: LD_ADDR_VAR 0 7
1104: PUSH
1105: LD_VAR 0 4
1109: PUSH
1110: FOR_IN
1111: IFFALSE 1144
// if not i in fac_list then
1113: LD_VAR 0 7
1117: PUSH
1118: LD_VAR 0 16
1122: IN
1123: NOT
1124: IFFALSE 1142
// list := list diff i ;
1126: LD_ADDR_VAR 0 4
1130: PUSH
1131: LD_VAR 0 4
1135: PUSH
1136: LD_VAR 0 7
1140: DIFF
1141: ST_TO_ADDR
1142: GO 1110
1144: POP
1145: POP
// if not list then
1146: LD_VAR 0 4
1150: NOT
1151: IFFALSE 1155
// exit ;
1153: GO 2054
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1155: LD_VAR 0 11
1159: PUSH
1160: LD_INT 3
1162: EQUAL
1163: PUSH
1164: LD_INT 49
1166: PUSH
1167: LD_VAR 0 4
1171: IN
1172: AND
1173: PUSH
1174: LD_INT 31
1176: PPUSH
1177: LD_VAR 0 15
1181: PPUSH
1182: CALL_OW 321
1186: PUSH
1187: LD_INT 2
1189: EQUAL
1190: AND
1191: IFFALSE 1251
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1193: LD_INT 22
1195: PUSH
1196: LD_VAR 0 15
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 35
1207: PUSH
1208: LD_INT 49
1210: PUSH
1211: EMPTY
1212: LIST
1213: LIST
1214: PUSH
1215: LD_INT 91
1217: PUSH
1218: LD_VAR 0 1
1222: PUSH
1223: LD_INT 10
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: PPUSH
1236: CALL_OW 69
1240: NOT
1241: IFFALSE 1251
// weapon := ru_time_lapser ;
1243: LD_ADDR_VAR 0 17
1247: PUSH
1248: LD_INT 49
1250: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1251: LD_VAR 0 11
1255: PUSH
1256: LD_INT 1
1258: PUSH
1259: LD_INT 2
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: IN
1266: PUSH
1267: LD_INT 11
1269: PUSH
1270: LD_VAR 0 4
1274: IN
1275: PUSH
1276: LD_INT 30
1278: PUSH
1279: LD_VAR 0 4
1283: IN
1284: OR
1285: AND
1286: PUSH
1287: LD_INT 6
1289: PPUSH
1290: LD_VAR 0 15
1294: PPUSH
1295: CALL_OW 321
1299: PUSH
1300: LD_INT 2
1302: EQUAL
1303: AND
1304: IFFALSE 1469
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1306: LD_INT 22
1308: PUSH
1309: LD_VAR 0 15
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: LD_INT 2
1320: PUSH
1321: LD_INT 35
1323: PUSH
1324: LD_INT 11
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 35
1333: PUSH
1334: LD_INT 30
1336: PUSH
1337: EMPTY
1338: LIST
1339: LIST
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 91
1348: PUSH
1349: LD_VAR 0 1
1353: PUSH
1354: LD_INT 18
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: PUSH
1362: EMPTY
1363: LIST
1364: LIST
1365: LIST
1366: PPUSH
1367: CALL_OW 69
1371: NOT
1372: PUSH
1373: LD_INT 22
1375: PUSH
1376: LD_VAR 0 15
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: LD_INT 2
1387: PUSH
1388: LD_INT 30
1390: PUSH
1391: LD_INT 32
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 30
1400: PUSH
1401: LD_INT 33
1403: PUSH
1404: EMPTY
1405: LIST
1406: LIST
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: LIST
1412: PUSH
1413: LD_INT 91
1415: PUSH
1416: LD_VAR 0 1
1420: PUSH
1421: LD_INT 12
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: PUSH
1429: EMPTY
1430: LIST
1431: LIST
1432: LIST
1433: PUSH
1434: EMPTY
1435: LIST
1436: PPUSH
1437: CALL_OW 69
1441: PUSH
1442: LD_INT 2
1444: GREATER
1445: AND
1446: IFFALSE 1469
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1448: LD_ADDR_VAR 0 17
1452: PUSH
1453: LD_INT 11
1455: PUSH
1456: LD_INT 30
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: PUSH
1463: LD_VAR 0 11
1467: ARRAY
1468: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1469: LD_VAR 0 17
1473: NOT
1474: PUSH
1475: LD_INT 40
1477: PPUSH
1478: LD_VAR 0 15
1482: PPUSH
1483: CALL_OW 321
1487: PUSH
1488: LD_INT 2
1490: EQUAL
1491: AND
1492: PUSH
1493: LD_INT 7
1495: PUSH
1496: LD_VAR 0 4
1500: IN
1501: PUSH
1502: LD_INT 28
1504: PUSH
1505: LD_VAR 0 4
1509: IN
1510: OR
1511: PUSH
1512: LD_INT 45
1514: PUSH
1515: LD_VAR 0 4
1519: IN
1520: OR
1521: AND
1522: IFFALSE 1776
// begin hex := GetHexInfo ( x , y ) ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_VAR 0 9
1533: PPUSH
1534: LD_VAR 0 10
1538: PPUSH
1539: CALL_OW 546
1543: ST_TO_ADDR
// if hex [ 1 ] then
1544: LD_VAR 0 3
1548: PUSH
1549: LD_INT 1
1551: ARRAY
1552: IFFALSE 1556
// exit ;
1554: GO 2054
// height := hex [ 2 ] ;
1556: LD_ADDR_VAR 0 14
1560: PUSH
1561: LD_VAR 0 3
1565: PUSH
1566: LD_INT 2
1568: ARRAY
1569: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1570: LD_ADDR_VAR 0 13
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: LD_INT 2
1580: PUSH
1581: LD_INT 3
1583: PUSH
1584: LD_INT 5
1586: PUSH
1587: EMPTY
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: ST_TO_ADDR
// for i in tmp do
1593: LD_ADDR_VAR 0 7
1597: PUSH
1598: LD_VAR 0 13
1602: PUSH
1603: FOR_IN
1604: IFFALSE 1774
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1606: LD_ADDR_VAR 0 8
1610: PUSH
1611: LD_VAR 0 9
1615: PPUSH
1616: LD_VAR 0 7
1620: PPUSH
1621: LD_INT 5
1623: PPUSH
1624: CALL_OW 272
1628: PUSH
1629: LD_VAR 0 10
1633: PPUSH
1634: LD_VAR 0 7
1638: PPUSH
1639: LD_INT 5
1641: PPUSH
1642: CALL_OW 273
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1651: LD_VAR 0 8
1655: PUSH
1656: LD_INT 1
1658: ARRAY
1659: PPUSH
1660: LD_VAR 0 8
1664: PUSH
1665: LD_INT 2
1667: ARRAY
1668: PPUSH
1669: CALL_OW 488
1673: IFFALSE 1772
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1675: LD_ADDR_VAR 0 3
1679: PUSH
1680: LD_VAR 0 8
1684: PUSH
1685: LD_INT 1
1687: ARRAY
1688: PPUSH
1689: LD_VAR 0 8
1693: PUSH
1694: LD_INT 2
1696: ARRAY
1697: PPUSH
1698: CALL_OW 546
1702: ST_TO_ADDR
// if hex [ 1 ] then
1703: LD_VAR 0 3
1707: PUSH
1708: LD_INT 1
1710: ARRAY
1711: IFFALSE 1715
// continue ;
1713: GO 1603
// h := hex [ 2 ] ;
1715: LD_ADDR_VAR 0 12
1719: PUSH
1720: LD_VAR 0 3
1724: PUSH
1725: LD_INT 2
1727: ARRAY
1728: ST_TO_ADDR
// if h + 7 < height then
1729: LD_VAR 0 12
1733: PUSH
1734: LD_INT 7
1736: PLUS
1737: PUSH
1738: LD_VAR 0 14
1742: LESS
1743: IFFALSE 1772
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1745: LD_ADDR_VAR 0 17
1749: PUSH
1750: LD_INT 7
1752: PUSH
1753: LD_INT 28
1755: PUSH
1756: LD_INT 45
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 11
1768: ARRAY
1769: ST_TO_ADDR
// break ;
1770: GO 1774
// end ; end ; end ;
1772: GO 1603
1774: POP
1775: POP
// end ; if not weapon then
1776: LD_VAR 0 17
1780: NOT
1781: IFFALSE 1936
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1783: LD_ADDR_VAR 0 4
1787: PUSH
1788: LD_VAR 0 4
1792: PUSH
1793: LD_INT 11
1795: PUSH
1796: LD_INT 30
1798: PUSH
1799: LD_INT 49
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: LIST
1806: DIFF
1807: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1808: LD_ADDR_VAR 0 13
1812: PUSH
1813: LD_INT 22
1815: PUSH
1816: LD_VAR 0 15
1820: PUSH
1821: EMPTY
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 91
1827: PUSH
1828: LD_VAR 0 1
1832: PUSH
1833: LD_INT 6
1835: PUSH
1836: EMPTY
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 3
1843: PUSH
1844: LD_INT 35
1846: PUSH
1847: LD_INT 0
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: PPUSH
1863: CALL_OW 69
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 7
1872: PUSH
1873: LD_VAR 0 13
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1904
// list := list diff GetBWeapon ( i ) ;
1881: LD_ADDR_VAR 0 4
1885: PUSH
1886: LD_VAR 0 4
1890: PUSH
1891: LD_VAR 0 7
1895: PPUSH
1896: CALL_OW 269
1900: DIFF
1901: ST_TO_ADDR
1902: GO 1878
1904: POP
1905: POP
// if list then
1906: LD_VAR 0 4
1910: IFFALSE 1936
// weapon := list [ rand ( 1 , list ) ] ;
1912: LD_ADDR_VAR 0 17
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_INT 1
1924: PPUSH
1925: LD_VAR 0 4
1929: PPUSH
1930: CALL_OW 12
1934: ARRAY
1935: ST_TO_ADDR
// end ; if weapon then
1936: LD_VAR 0 17
1940: IFFALSE 2054
// begin tmp := CostOfWeapon ( weapon ) ;
1942: LD_ADDR_VAR 0 13
1946: PUSH
1947: LD_VAR 0 17
1951: PPUSH
1952: CALL_OW 451
1956: ST_TO_ADDR
// j := GetBase ( tower ) ;
1957: LD_ADDR_VAR 0 8
1961: PUSH
1962: LD_VAR 0 1
1966: PPUSH
1967: CALL_OW 274
1971: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1972: LD_VAR 0 8
1976: PPUSH
1977: LD_INT 1
1979: PPUSH
1980: CALL_OW 275
1984: PUSH
1985: LD_VAR 0 13
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: GREATEREQUAL
1994: PUSH
1995: LD_VAR 0 8
1999: PPUSH
2000: LD_INT 2
2002: PPUSH
2003: CALL_OW 275
2007: PUSH
2008: LD_VAR 0 13
2012: PUSH
2013: LD_INT 2
2015: ARRAY
2016: GREATEREQUAL
2017: AND
2018: PUSH
2019: LD_VAR 0 8
2023: PPUSH
2024: LD_INT 3
2026: PPUSH
2027: CALL_OW 275
2031: PUSH
2032: LD_VAR 0 13
2036: PUSH
2037: LD_INT 3
2039: ARRAY
2040: GREATEREQUAL
2041: AND
2042: IFFALSE 2054
// result := weapon ;
2044: LD_ADDR_VAR 0 2
2048: PUSH
2049: LD_VAR 0 17
2053: ST_TO_ADDR
// end ; end ;
2054: LD_VAR 0 2
2058: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2059: LD_INT 0
2061: PPUSH
2062: PPUSH
2063: PPUSH
2064: PPUSH
2065: PPUSH
// if not un or not IsOk ( un ) then
2066: LD_VAR 0 1
2070: NOT
2071: PUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: CALL_OW 302
2081: NOT
2082: OR
2083: IFFALSE 2087
// exit ;
2085: GO 2527
// side := GetSide ( un ) ;
2087: LD_ADDR_VAR 0 9
2091: PUSH
2092: LD_VAR 0 1
2096: PPUSH
2097: CALL_OW 255
2101: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2102: LD_ADDR_VAR 0 7
2106: PUSH
2107: LD_INT 22
2109: PUSH
2110: LD_VAR 0 9
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PUSH
2119: LD_INT 30
2121: PUSH
2122: LD_INT 32
2124: PUSH
2125: EMPTY
2126: LIST
2127: LIST
2128: PUSH
2129: LD_INT 50
2131: PUSH
2132: EMPTY
2133: LIST
2134: PUSH
2135: LD_INT 58
2137: PUSH
2138: EMPTY
2139: LIST
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: PPUSH
2147: CALL_OW 69
2151: PUSH
2152: LD_VAR 0 2
2156: DIFF
2157: ST_TO_ADDR
// if not filter then
2158: LD_VAR 0 7
2162: NOT
2163: IFFALSE 2392
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2165: LD_ADDR_VAR 0 7
2169: PUSH
2170: LD_INT 22
2172: PUSH
2173: LD_VAR 0 9
2177: PUSH
2178: EMPTY
2179: LIST
2180: LIST
2181: PUSH
2182: LD_INT 30
2184: PUSH
2185: LD_INT 5
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: PPUSH
2196: CALL_OW 69
2200: ST_TO_ADDR
// if debug then
2201: LD_EXP 1
2205: IFFALSE 2224
// display_strings := [ filter , 1 ] ;
2207: LD_ADDR_OWVAR 47
2211: PUSH
2212: LD_VAR 0 7
2216: PUSH
2217: LD_STRING 1
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: ST_TO_ADDR
// if not filter then
2224: LD_VAR 0 7
2228: NOT
2229: IFFALSE 2252
// begin ComMoveXY ( un , x , y ) ;
2231: LD_VAR 0 1
2235: PPUSH
2236: LD_VAR 0 3
2240: PPUSH
2241: LD_VAR 0 4
2245: PPUSH
2246: CALL_OW 111
// exit ;
2250: GO 2527
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2252: LD_ADDR_VAR 0 8
2256: PUSH
2257: LD_VAR 0 7
2261: PPUSH
2262: LD_VAR 0 1
2266: PPUSH
2267: CALL_OW 74
2271: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2272: LD_VAR 0 8
2276: PPUSH
2277: CALL_OW 313
2281: PUSH
2282: LD_INT 6
2284: EQUAL
2285: IFFALSE 2305
// filter := filter diff t else
2287: LD_ADDR_VAR 0 7
2291: PUSH
2292: LD_VAR 0 7
2296: PUSH
2297: LD_VAR 0 8
2301: DIFF
2302: ST_TO_ADDR
2303: GO 2307
// break ;
2305: GO 2329
// until UnitsInside ( t ) < 6 or not filter ;
2307: LD_VAR 0 8
2311: PPUSH
2312: CALL_OW 313
2316: PUSH
2317: LD_INT 6
2319: LESS
2320: PUSH
2321: LD_VAR 0 7
2325: NOT
2326: OR
2327: IFFALSE 2252
// display_strings := [ filter , t ] ;
2329: LD_ADDR_OWVAR 47
2333: PUSH
2334: LD_VAR 0 7
2338: PUSH
2339: LD_VAR 0 8
2343: PUSH
2344: EMPTY
2345: LIST
2346: LIST
2347: ST_TO_ADDR
// if not filter then
2348: LD_VAR 0 7
2352: NOT
2353: IFFALSE 2376
// ComMoveXY ( un , x , y ) else
2355: LD_VAR 0 1
2359: PPUSH
2360: LD_VAR 0 3
2364: PPUSH
2365: LD_VAR 0 4
2369: PPUSH
2370: CALL_OW 111
2374: GO 2390
// ComEnterUnit ( un , t ) ;
2376: LD_VAR 0 1
2380: PPUSH
2381: LD_VAR 0 8
2385: PPUSH
2386: CALL_OW 120
// end else
2390: GO 2527
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2392: LD_ADDR_VAR 0 8
2396: PUSH
2397: LD_VAR 0 7
2401: PPUSH
2402: LD_VAR 0 1
2406: PPUSH
2407: CALL_OW 74
2411: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2412: LD_VAR 0 8
2416: PPUSH
2417: CALL_OW 110
2421: PUSH
2422: LD_INT 7
2424: EQUAL
2425: IFFALSE 2443
// filter := filter diff t ;
2427: LD_ADDR_VAR 0 7
2431: PUSH
2432: LD_VAR 0 7
2436: PUSH
2437: LD_VAR 0 8
2441: DIFF
2442: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2443: LD_VAR 0 8
2447: PPUSH
2448: CALL_OW 110
2452: PUSH
2453: LD_INT 7
2455: NONEQUAL
2456: PUSH
2457: LD_VAR 0 7
2461: NOT
2462: OR
2463: IFFALSE 2392
// if GetTag ( t ) <> 7 then
2465: LD_VAR 0 8
2469: PPUSH
2470: CALL_OW 110
2474: PUSH
2475: LD_INT 7
2477: NONEQUAL
2478: IFFALSE 2508
// begin SetTag ( t , 7 ) ;
2480: LD_VAR 0 8
2484: PPUSH
2485: LD_INT 7
2487: PPUSH
2488: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2492: LD_VAR 0 1
2496: PPUSH
2497: LD_VAR 0 8
2501: PPUSH
2502: CALL_OW 120
// end else
2506: GO 2527
// ComMoveXY ( un , x , y ) ;
2508: LD_VAR 0 1
2512: PPUSH
2513: LD_VAR 0 3
2517: PPUSH
2518: LD_VAR 0 4
2522: PPUSH
2523: CALL_OW 111
// end ; end ;
2527: LD_VAR 0 5
2531: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2532: LD_INT 0
2534: PPUSH
2535: PPUSH
2536: PPUSH
// if not base then
2537: LD_VAR 0 1
2541: NOT
2542: IFFALSE 2546
// exit ;
2544: GO 2604
// tmp := GetEnergy ( GetBase ( base ) ) ;
2546: LD_ADDR_VAR 0 4
2550: PUSH
2551: LD_VAR 0 1
2555: PPUSH
2556: CALL_OW 274
2560: PPUSH
2561: CALL_OW 278
2565: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2566: LD_VAR 0 4
2570: PUSH
2571: LD_INT 1
2573: ARRAY
2574: PUSH
2575: LD_VAR 0 4
2579: PUSH
2580: LD_INT 4
2582: ARRAY
2583: GREATER
2584: IFFALSE 2596
// result := true else
2586: LD_ADDR_VAR 0 2
2590: PUSH
2591: LD_INT 1
2593: ST_TO_ADDR
2594: GO 2604
// result := false ;
2596: LD_ADDR_VAR 0 2
2600: PUSH
2601: LD_INT 0
2603: ST_TO_ADDR
// end ;
2604: LD_VAR 0 2
2608: RET
// export function FilterPeople ( side ) ; begin
2609: LD_INT 0
2611: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2612: LD_ADDR_VAR 0 2
2616: PUSH
2617: LD_INT 22
2619: PUSH
2620: LD_VAR 0 1
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 21
2631: PUSH
2632: LD_INT 1
2634: PUSH
2635: EMPTY
2636: LIST
2637: LIST
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: PPUSH
2643: CALL_OW 69
2647: ST_TO_ADDR
// end ;
2648: LD_VAR 0 2
2652: RET
// export function FilterDrivers ( side ) ; begin
2653: LD_INT 0
2655: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2656: LD_ADDR_VAR 0 2
2660: PUSH
2661: LD_INT 22
2663: PUSH
2664: LD_VAR 0 1
2668: PUSH
2669: EMPTY
2670: LIST
2671: LIST
2672: PUSH
2673: LD_INT 3
2675: PUSH
2676: LD_INT 56
2678: PUSH
2679: EMPTY
2680: LIST
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PPUSH
2690: CALL_OW 69
2694: ST_TO_ADDR
// end ;
2695: LD_VAR 0 2
2699: RET
// export function FilterPeopleArea ( side , area ) ; begin
2700: LD_INT 0
2702: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2703: LD_ADDR_VAR 0 3
2707: PUSH
2708: LD_VAR 0 2
2712: PPUSH
2713: LD_INT 22
2715: PUSH
2716: LD_INT 1
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 1
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: PPUSH
2737: CALL_OW 70
2741: ST_TO_ADDR
// end ;
2742: LD_VAR 0 3
2746: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2747: LD_INT 0
2749: PPUSH
2750: PPUSH
2751: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2752: LD_ADDR_VAR 0 5
2756: PUSH
2757: LD_VAR 0 2
2761: PPUSH
2762: LD_INT 22
2764: PUSH
2765: LD_INT 1
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PUSH
2772: LD_INT 21
2774: PUSH
2775: LD_INT 2
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PUSH
2782: LD_INT 3
2784: PUSH
2785: LD_INT 58
2787: PUSH
2788: EMPTY
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: PPUSH
2800: CALL_OW 70
2804: ST_TO_ADDR
// result := [ ] ;
2805: LD_ADDR_VAR 0 3
2809: PUSH
2810: EMPTY
2811: ST_TO_ADDR
// if not tmp then
2812: LD_VAR 0 5
2816: NOT
2817: IFFALSE 2821
// exit ;
2819: GO 2873
// for i in tmp do
2821: LD_ADDR_VAR 0 4
2825: PUSH
2826: LD_VAR 0 5
2830: PUSH
2831: FOR_IN
2832: IFFALSE 2857
// result := result union IsDrivenBy ( i ) ;
2834: LD_ADDR_VAR 0 3
2838: PUSH
2839: LD_VAR 0 3
2843: PUSH
2844: LD_VAR 0 4
2848: PPUSH
2849: CALL_OW 311
2853: UNION
2854: ST_TO_ADDR
2855: GO 2831
2857: POP
2858: POP
// result := result diff 0 ;
2859: LD_ADDR_VAR 0 3
2863: PUSH
2864: LD_VAR 0 3
2868: PUSH
2869: LD_INT 0
2871: DIFF
2872: ST_TO_ADDR
// end ;
2873: LD_VAR 0 3
2877: RET
// export function FilterBuildings ( side ) ; begin
2878: LD_INT 0
2880: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2881: LD_ADDR_VAR 0 2
2885: PUSH
2886: LD_INT 22
2888: PUSH
2889: LD_VAR 0 1
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PUSH
2898: LD_INT 21
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: PPUSH
2912: CALL_OW 69
2916: ST_TO_ADDR
// end ;
2917: LD_VAR 0 2
2921: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2922: LD_INT 0
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
// uc_side = 0 ;
2928: LD_ADDR_OWVAR 20
2932: PUSH
2933: LD_INT 0
2935: ST_TO_ADDR
// uc_nation = 0 ;
2936: LD_ADDR_OWVAR 21
2940: PUSH
2941: LD_INT 0
2943: ST_TO_ADDR
// nat_area := wildArea ;
2944: LD_ADDR_VAR 0 4
2948: PUSH
2949: LD_INT 3
2951: ST_TO_ADDR
// InitHc ;
2952: CALL_OW 19
// for i = 1 to 4 do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 4
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3025
// begin hc_class = 18 ;
2972: LD_ADDR_OWVAR 28
2976: PUSH
2977: LD_INT 18
2979: ST_TO_ADDR
// hc_gallery =  ;
2980: LD_ADDR_OWVAR 33
2984: PUSH
2985: LD_STRING 
2987: ST_TO_ADDR
// hc_face_number = 1 ;
2988: LD_ADDR_OWVAR 34
2992: PUSH
2993: LD_INT 1
2995: ST_TO_ADDR
// animal := CreateHuman ;
2996: LD_ADDR_VAR 0 3
3000: PUSH
3001: CALL_OW 44
3005: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3006: LD_VAR 0 3
3010: PPUSH
3011: LD_VAR 0 4
3015: PPUSH
3016: LD_INT 0
3018: PPUSH
3019: CALL_OW 49
// end ;
3023: GO 2969
3025: POP
3026: POP
// for i = 1 to 6 do
3027: LD_ADDR_VAR 0 2
3031: PUSH
3032: DOUBLE
3033: LD_INT 1
3035: DEC
3036: ST_TO_ADDR
3037: LD_INT 6
3039: PUSH
3040: FOR_TO
3041: IFFALSE 3112
// begin hc_class = class_tiger ;
3043: LD_ADDR_OWVAR 28
3047: PUSH
3048: LD_INT 14
3050: ST_TO_ADDR
// hc_gallery =  ;
3051: LD_ADDR_OWVAR 33
3055: PUSH
3056: LD_STRING 
3058: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3059: LD_ADDR_OWVAR 35
3063: PUSH
3064: LD_INT 0
3066: PPUSH
3067: LD_INT 10
3069: PPUSH
3070: CALL_OW 12
3074: ST_TO_ADDR
// hc_face_number = 3 ;
3075: LD_ADDR_OWVAR 34
3079: PUSH
3080: LD_INT 3
3082: ST_TO_ADDR
// animal := CreateHuman ;
3083: LD_ADDR_VAR 0 3
3087: PUSH
3088: CALL_OW 44
3092: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3093: LD_VAR 0 3
3097: PPUSH
3098: LD_VAR 0 4
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 49
// end ;
3110: GO 3040
3112: POP
3113: POP
// for i = 1 to 2 do
3114: LD_ADDR_VAR 0 2
3118: PUSH
3119: DOUBLE
3120: LD_INT 1
3122: DEC
3123: ST_TO_ADDR
3124: LD_INT 2
3126: PUSH
3127: FOR_TO
3128: IFFALSE 3191
// begin hc_class = 21 ;
3130: LD_ADDR_OWVAR 28
3134: PUSH
3135: LD_INT 21
3137: ST_TO_ADDR
// hc_gallery =  ;
3138: LD_ADDR_OWVAR 33
3142: PUSH
3143: LD_STRING 
3145: ST_TO_ADDR
// hc_agressivity = 0 ;
3146: LD_ADDR_OWVAR 35
3150: PUSH
3151: LD_INT 0
3153: ST_TO_ADDR
// hc_face_number = 5 ;
3154: LD_ADDR_OWVAR 34
3158: PUSH
3159: LD_INT 5
3161: ST_TO_ADDR
// animal := CreateHuman ;
3162: LD_ADDR_VAR 0 3
3166: PUSH
3167: CALL_OW 44
3171: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3172: LD_VAR 0 3
3176: PPUSH
3177: LD_VAR 0 4
3181: PPUSH
3182: LD_INT 0
3184: PPUSH
3185: CALL_OW 49
// end ;
3189: GO 3127
3191: POP
3192: POP
// for i = 1 to 6 do
3193: LD_ADDR_VAR 0 2
3197: PUSH
3198: DOUBLE
3199: LD_INT 1
3201: DEC
3202: ST_TO_ADDR
3203: LD_INT 6
3205: PUSH
3206: FOR_TO
3207: IFFALSE 3262
// begin hc_class = 13 ;
3209: LD_ADDR_OWVAR 28
3213: PUSH
3214: LD_INT 13
3216: ST_TO_ADDR
// hc_gallery =  ;
3217: LD_ADDR_OWVAR 33
3221: PUSH
3222: LD_STRING 
3224: ST_TO_ADDR
// hc_face_number = 4 ;
3225: LD_ADDR_OWVAR 34
3229: PUSH
3230: LD_INT 4
3232: ST_TO_ADDR
// animal := CreateHuman ;
3233: LD_ADDR_VAR 0 3
3237: PUSH
3238: CALL_OW 44
3242: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3243: LD_VAR 0 3
3247: PPUSH
3248: LD_VAR 0 4
3252: PPUSH
3253: LD_INT 0
3255: PPUSH
3256: CALL_OW 49
// end ;
3260: GO 3206
3262: POP
3263: POP
// for i = 1 to 2 do
3264: LD_ADDR_VAR 0 2
3268: PUSH
3269: DOUBLE
3270: LD_INT 1
3272: DEC
3273: ST_TO_ADDR
3274: LD_INT 2
3276: PUSH
3277: FOR_TO
3278: IFFALSE 3337
// begin hc_class = 20 ;
3280: LD_ADDR_OWVAR 28
3284: PUSH
3285: LD_INT 20
3287: ST_TO_ADDR
// hc_gallery =  ;
3288: LD_ADDR_OWVAR 33
3292: PUSH
3293: LD_STRING 
3295: ST_TO_ADDR
// hc_face_number = 2 ;
3296: LD_ADDR_OWVAR 34
3300: PUSH
3301: LD_INT 2
3303: ST_TO_ADDR
// animal := CreateHuman ;
3304: LD_ADDR_VAR 0 3
3308: PUSH
3309: CALL_OW 44
3313: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3314: LD_VAR 0 3
3318: PPUSH
3319: LD_INT 101
3321: PPUSH
3322: LD_INT 37
3324: PPUSH
3325: LD_INT 3
3327: PPUSH
3328: LD_INT 0
3330: PPUSH
3331: CALL_OW 50
// end ;
3335: GO 3277
3337: POP
3338: POP
// for i = 1 to 1 do
3339: LD_ADDR_VAR 0 2
3343: PUSH
3344: DOUBLE
3345: LD_INT 1
3347: DEC
3348: ST_TO_ADDR
3349: LD_INT 1
3351: PUSH
3352: FOR_TO
3353: IFFALSE 3400
// begin vc_chassis := 31 ;
3355: LD_ADDR_OWVAR 37
3359: PUSH
3360: LD_INT 31
3362: ST_TO_ADDR
// vc_control := control_rider ;
3363: LD_ADDR_OWVAR 38
3367: PUSH
3368: LD_INT 4
3370: ST_TO_ADDR
// animal := CreateVehicle ;
3371: LD_ADDR_VAR 0 3
3375: PUSH
3376: CALL_OW 45
3380: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3381: LD_VAR 0 3
3385: PPUSH
3386: LD_VAR 0 4
3390: PPUSH
3391: LD_INT 0
3393: PPUSH
3394: CALL_OW 49
// end ;
3398: GO 3352
3400: POP
3401: POP
// end ;
3402: LD_VAR 0 1
3406: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3407: LD_INT 0
3409: PPUSH
3410: PPUSH
3411: PPUSH
3412: PPUSH
// result := [ ] ;
3413: LD_ADDR_VAR 0 2
3417: PUSH
3418: EMPTY
3419: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: LD_INT 81
3427: PUSH
3428: LD_VAR 0 1
3432: PPUSH
3433: CALL_OW 255
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: LD_INT 91
3444: PUSH
3445: LD_VAR 0 1
3449: PUSH
3450: LD_INT 15
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: PUSH
3458: LD_INT 2
3460: PUSH
3461: LD_INT 30
3463: PUSH
3464: LD_INT 32
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PUSH
3471: LD_INT 30
3473: PUSH
3474: LD_INT 33
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: PPUSH
3491: CALL_OW 69
3495: ST_TO_ADDR
// if not tmp then
3496: LD_VAR 0 4
3500: NOT
3501: IFFALSE 3505
// exit ;
3503: GO 3574
// for i in tmp do
3505: LD_ADDR_VAR 0 3
3509: PUSH
3510: LD_VAR 0 4
3514: PUSH
3515: FOR_IN
3516: IFFALSE 3572
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3518: LD_ADDR_VAR 0 5
3522: PUSH
3523: LD_VAR 0 3
3527: PPUSH
3528: CALL_OW 274
3532: PPUSH
3533: CALL_OW 278
3537: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3538: LD_VAR 0 5
3542: PUSH
3543: LD_INT 4
3545: ARRAY
3546: PUSH
3547: LD_VAR 0 5
3551: PUSH
3552: LD_INT 1
3554: ARRAY
3555: GREATER
3556: IFFALSE 3570
// begin result := i ;
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: LD_VAR 0 3
3567: ST_TO_ADDR
// break ;
3568: GO 3572
// end ; end ;
3570: GO 3515
3572: POP
3573: POP
// end ; end_of_file
3574: LD_VAR 0 2
3578: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3579: LD_INT 0
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
3586: PPUSH
// uc_side := 1 ;
3587: LD_ADDR_OWVAR 20
3591: PUSH
3592: LD_INT 1
3594: ST_TO_ADDR
// uc_nation := 1 ;
3595: LD_ADDR_OWVAR 21
3599: PUSH
3600: LD_INT 1
3602: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3603: LD_ADDR_EXP 8
3607: PUSH
3608: LD_STRING JMM
3610: PPUSH
3611: LD_EXP 1
3615: NOT
3616: PPUSH
3617: CALL 359 0 2
3621: ST_TO_ADDR
// team := [ JMM ] ;
3622: LD_ADDR_VAR 0 3
3626: PUSH
3627: LD_EXP 8
3631: PUSH
3632: EMPTY
3633: LIST
3634: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3635: LD_STRING BrownIn07
3637: PPUSH
3638: LD_EXP 1
3642: PPUSH
3643: CALL_OW 30
3647: IFFALSE 3668
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3649: LD_ADDR_EXP 9
3653: PUSH
3654: LD_STRING Brown
3656: PPUSH
3657: LD_EXP 1
3661: NOT
3662: PPUSH
3663: CALL 359 0 2
3667: ST_TO_ADDR
// if Brown then
3668: LD_EXP 9
3672: IFFALSE 3690
// team := team ^ Brown ;
3674: LD_ADDR_VAR 0 3
3678: PUSH
3679: LD_VAR 0 3
3683: PUSH
3684: LD_EXP 9
3688: ADD
3689: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3690: LD_STRING DonaldsonIn07
3692: PPUSH
3693: LD_EXP 1
3697: PPUSH
3698: CALL_OW 30
3702: IFFALSE 3723
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3704: LD_ADDR_EXP 10
3708: PUSH
3709: LD_STRING Donaldson
3711: PPUSH
3712: LD_EXP 1
3716: NOT
3717: PPUSH
3718: CALL 359 0 2
3722: ST_TO_ADDR
// if Donaldson then
3723: LD_EXP 10
3727: IFFALSE 3745
// team := team ^ Donaldson ;
3729: LD_ADDR_VAR 0 3
3733: PUSH
3734: LD_VAR 0 3
3738: PUSH
3739: LD_EXP 10
3743: ADD
3744: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3745: LD_STRING BobbyIn07
3747: PPUSH
3748: LD_EXP 1
3752: PPUSH
3753: CALL_OW 30
3757: IFFALSE 3778
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3759: LD_ADDR_EXP 11
3763: PUSH
3764: LD_STRING Bobby
3766: PPUSH
3767: LD_EXP 1
3771: NOT
3772: PPUSH
3773: CALL 359 0 2
3777: ST_TO_ADDR
// if Bobby then
3778: LD_EXP 11
3782: IFFALSE 3800
// team := team ^ Bobby ;
3784: LD_ADDR_VAR 0 3
3788: PUSH
3789: LD_VAR 0 3
3793: PUSH
3794: LD_EXP 11
3798: ADD
3799: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3800: LD_STRING CyrusIn07
3802: PPUSH
3803: LD_EXP 1
3807: PPUSH
3808: CALL_OW 30
3812: IFFALSE 3833
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3814: LD_ADDR_EXP 12
3818: PUSH
3819: LD_STRING Cyrus
3821: PPUSH
3822: LD_EXP 1
3826: NOT
3827: PPUSH
3828: CALL 359 0 2
3832: ST_TO_ADDR
// if Cyrus then
3833: LD_EXP 12
3837: IFFALSE 3855
// team := team ^ Cyrus ;
3839: LD_ADDR_VAR 0 3
3843: PUSH
3844: LD_VAR 0 3
3848: PUSH
3849: LD_EXP 12
3853: ADD
3854: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3855: LD_STRING LisaIn07
3857: PPUSH
3858: LD_EXP 1
3862: PPUSH
3863: CALL_OW 30
3867: IFFALSE 3888
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3869: LD_ADDR_EXP 13
3873: PUSH
3874: LD_STRING Lisa
3876: PPUSH
3877: LD_EXP 1
3881: NOT
3882: PPUSH
3883: CALL 359 0 2
3887: ST_TO_ADDR
// if Lisa then
3888: LD_EXP 13
3892: IFFALSE 3910
// team := team ^ Lisa ;
3894: LD_ADDR_VAR 0 3
3898: PUSH
3899: LD_VAR 0 3
3903: PUSH
3904: LD_EXP 13
3908: ADD
3909: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3910: LD_STRING GladstoneIn07
3912: PPUSH
3913: LD_EXP 1
3917: PPUSH
3918: CALL_OW 30
3922: IFFALSE 3943
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3924: LD_ADDR_EXP 15
3928: PUSH
3929: LD_STRING Gladstone
3931: PPUSH
3932: LD_EXP 1
3936: NOT
3937: PPUSH
3938: CALL 359 0 2
3942: ST_TO_ADDR
// if Gladstone then
3943: LD_EXP 15
3947: IFFALSE 3965
// team := team ^ Gladstone ;
3949: LD_ADDR_VAR 0 3
3953: PUSH
3954: LD_VAR 0 3
3958: PUSH
3959: LD_EXP 15
3963: ADD
3964: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3965: LD_STRING KhatamIn07
3967: PPUSH
3968: LD_EXP 1
3972: PPUSH
3973: CALL_OW 30
3977: IFFALSE 3998
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3979: LD_ADDR_EXP 16
3983: PUSH
3984: LD_STRING Khatam
3986: PPUSH
3987: LD_EXP 1
3991: NOT
3992: PPUSH
3993: CALL 359 0 2
3997: ST_TO_ADDR
// if Khatam then
3998: LD_EXP 16
4002: IFFALSE 4020
// team := team ^ Khatam ;
4004: LD_ADDR_VAR 0 3
4008: PUSH
4009: LD_VAR 0 3
4013: PUSH
4014: LD_EXP 16
4018: ADD
4019: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4020: LD_ADDR_VAR 0 4
4024: PUSH
4025: LD_STRING 07_others
4027: PPUSH
4028: CALL_OW 31
4032: ST_TO_ADDR
// if others then
4033: LD_VAR 0 4
4037: IFFALSE 4055
// team := team ^ others ;
4039: LD_ADDR_VAR 0 3
4043: PUSH
4044: LD_VAR 0 3
4048: PUSH
4049: LD_VAR 0 4
4053: ADD
4054: ST_TO_ADDR
// if debug then
4055: LD_EXP 1
4059: IFFALSE 4133
// begin InitHc ;
4061: CALL_OW 19
// for i = 1 to 4 do
4065: LD_ADDR_VAR 0 2
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 4
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4131
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 1
4086: PUSH
4087: LD_INT 3
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: PUSH
4094: LD_INT 1
4096: PPUSH
4097: LD_INT 2
4099: PPUSH
4100: CALL_OW 12
4104: ARRAY
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 380
// team := team ^ CreateHuman ;
4113: LD_ADDR_VAR 0 3
4117: PUSH
4118: LD_VAR 0 3
4122: PUSH
4123: CALL_OW 44
4127: ADD
4128: ST_TO_ADDR
// end ;
4129: GO 4078
4131: POP
4132: POP
// end ; m := 0 ;
4133: LD_ADDR_VAR 0 6
4137: PUSH
4138: LD_INT 0
4140: ST_TO_ADDR
// for i in team do
4141: LD_ADDR_VAR 0 2
4145: PUSH
4146: LD_VAR 0 3
4150: PUSH
4151: FOR_IN
4152: IFFALSE 4332
// if GetClass ( i ) = 3 then
4154: LD_VAR 0 2
4158: PPUSH
4159: CALL_OW 257
4163: PUSH
4164: LD_INT 3
4166: EQUAL
4167: IFFALSE 4315
// begin m := m + 1 ;
4169: LD_ADDR_VAR 0 6
4173: PUSH
4174: LD_VAR 0 6
4178: PUSH
4179: LD_INT 1
4181: PLUS
4182: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4183: LD_ADDR_VAR 0 5
4187: PUSH
4188: LD_INT 1
4190: PPUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PUSH
4197: LD_INT 3
4199: PUSH
4200: LD_INT 2
4202: PUSH
4203: LD_INT 1
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: PUSH
4212: LD_VAR 0 6
4216: PUSH
4217: LD_INT 4
4219: MOD
4220: PUSH
4221: LD_INT 1
4223: PLUS
4224: ARRAY
4225: PPUSH
4226: LD_INT 2
4228: PPUSH
4229: LD_INT 1
4231: PPUSH
4232: LD_INT 4
4234: PUSH
4235: LD_INT 5
4237: PUSH
4238: LD_INT 3
4240: PUSH
4241: LD_INT 11
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: LIST
4249: PUSH
4250: LD_VAR 0 6
4254: PUSH
4255: LD_INT 4
4257: MOD
4258: PUSH
4259: LD_INT 1
4261: PLUS
4262: ARRAY
4263: PPUSH
4264: LD_INT 60
4266: PPUSH
4267: CALL 422 0 7
4271: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4272: LD_VAR 0 5
4276: PPUSH
4277: LD_INT 2
4279: PPUSH
4280: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4284: LD_VAR 0 5
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 0
4294: PPUSH
4295: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4299: LD_VAR 0 2
4303: PPUSH
4304: LD_VAR 0 5
4308: PPUSH
4309: CALL_OW 52
// end else
4313: GO 4330
// PlaceUnitArea ( i , startArea , false ) ;
4315: LD_VAR 0 2
4319: PPUSH
4320: LD_INT 1
4322: PPUSH
4323: LD_INT 0
4325: PPUSH
4326: CALL_OW 49
4330: GO 4151
4332: POP
4333: POP
// uc_side := 4 ;
4334: LD_ADDR_OWVAR 20
4338: PUSH
4339: LD_INT 4
4341: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4342: LD_ADDR_EXP 18
4346: PUSH
4347: LD_STRING Harisson
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL 359 0 2
4357: ST_TO_ADDR
// PrepareScout ;
4358: CALL 4367 0 0
// end ;
4362: LD_VAR 0 1
4366: RET
// function PrepareScout ; var ape ; begin
4367: LD_INT 0
4369: PPUSH
4370: PPUSH
// uc_side := 4 ;
4371: LD_ADDR_OWVAR 20
4375: PUSH
4376: LD_INT 4
4378: ST_TO_ADDR
// uc_nation := 1 ;
4379: LD_ADDR_OWVAR 21
4383: PUSH
4384: LD_INT 1
4386: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4387: LD_STRING FrankIn06
4389: PPUSH
4390: LD_INT 0
4392: PPUSH
4393: CALL_OW 30
4397: IFFALSE 4414
// Frank := CreateCharacter ( 06c_Frank ) else
4399: LD_ADDR_EXP 14
4403: PUSH
4404: LD_STRING 06c_Frank
4406: PPUSH
4407: CALL_OW 34
4411: ST_TO_ADDR
4412: GO 4454
// if LoadVariable ( FrankInDelta , 0 ) then
4414: LD_STRING FrankInDelta
4416: PPUSH
4417: LD_INT 0
4419: PPUSH
4420: CALL_OW 30
4424: IFFALSE 4441
// Frank := CreateCharacter ( 05_Frank ) else
4426: LD_ADDR_EXP 14
4430: PUSH
4431: LD_STRING 05_Frank
4433: PPUSH
4434: CALL_OW 34
4438: ST_TO_ADDR
4439: GO 4454
// Frank := CreateCharacter ( 04_Frank ) ;
4441: LD_ADDR_EXP 14
4445: PUSH
4446: LD_STRING 04_Frank
4448: PPUSH
4449: CALL_OW 34
4453: ST_TO_ADDR
// if Frank then
4454: LD_EXP 14
4458: IFFALSE 4591
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4460: LD_EXP 14
4464: PPUSH
4465: LD_INT 2
4467: PPUSH
4468: LD_INT 0
4470: PPUSH
4471: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4475: LD_EXP 14
4479: PPUSH
4480: LD_INT 1
4482: PPUSH
4483: CALL_OW 336
// uc_side := 0 ;
4487: LD_ADDR_OWVAR 20
4491: PUSH
4492: LD_INT 0
4494: ST_TO_ADDR
// uc_nation := 0 ;
4495: LD_ADDR_OWVAR 21
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4503: LD_INT 0
4505: PPUSH
4506: LD_INT 12
4508: PPUSH
4509: LD_INT 0
4511: PPUSH
4512: CALL_OW 380
// ape := CreateHuman ;
4516: LD_ADDR_VAR 0 2
4520: PUSH
4521: CALL_OW 44
4525: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4526: LD_VAR 0 2
4530: PPUSH
4531: LD_EXP 14
4535: PPUSH
4536: CALL_OW 250
4540: PPUSH
4541: LD_EXP 14
4545: PPUSH
4546: CALL_OW 251
4550: PPUSH
4551: LD_INT 5
4553: PPUSH
4554: LD_INT 0
4556: PPUSH
4557: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4561: LD_VAR 0 2
4565: PPUSH
4566: LD_EXP 14
4570: PPUSH
4571: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4575: LD_EXP 14
4579: PPUSH
4580: LD_VAR 0 2
4584: PPUSH
4585: CALL_OW 119
// exit ;
4589: GO 4631
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4591: LD_ADDR_EXP 17
4595: PUSH
4596: LD_STRING Yamoko
4598: PPUSH
4599: LD_INT 0
4601: PPUSH
4602: CALL 359 0 2
4606: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4607: LD_EXP 17
4611: PPUSH
4612: LD_INT 2
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 49
// ComHold ( Kikuchi ) ;
4622: LD_EXP 17
4626: PPUSH
4627: CALL_OW 140
// end ; end_of_file
4631: LD_VAR 0 1
4635: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4636: LD_INT 0
4638: PPUSH
4639: PPUSH
4640: PPUSH
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
4647: PPUSH
4648: PPUSH
4649: PPUSH
4650: PPUSH
4651: PPUSH
4652: PPUSH
4653: PPUSH
// ru_rebuild_list := [ ] ;
4654: LD_ADDR_EXP 19
4658: PUSH
4659: EMPTY
4660: ST_TO_ADDR
// uc_side := 3 ;
4661: LD_ADDR_OWVAR 20
4665: PUSH
4666: LD_INT 3
4668: ST_TO_ADDR
// uc_nation := 3 ;
4669: LD_ADDR_OWVAR 21
4673: PUSH
4674: LD_INT 3
4676: ST_TO_ADDR
// if Difficulty > 1 then
4677: LD_OWVAR 67
4681: PUSH
4682: LD_INT 1
4684: GREATER
4685: IFFALSE 4821
// begin bc_type := b_breastwork ;
4687: LD_ADDR_OWVAR 42
4691: PUSH
4692: LD_INT 31
4694: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4695: LD_INT 78
4697: PPUSH
4698: LD_INT 74
4700: PPUSH
4701: LD_INT 2
4703: PPUSH
4704: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4708: LD_INT 171
4710: PPUSH
4711: LD_INT 193
4713: PPUSH
4714: LD_INT 4
4716: PPUSH
4717: CALL_OW 47
// bc_type := b_turret ;
4721: LD_ADDR_OWVAR 42
4725: PUSH
4726: LD_INT 33
4728: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4729: LD_INT 129
4731: PPUSH
4732: LD_INT 96
4734: PPUSH
4735: LD_INT 3
4737: PPUSH
4738: CALL_OW 47
// if Difficulty > 2 then
4742: LD_OWVAR 67
4746: PUSH
4747: LD_INT 2
4749: GREATER
4750: IFFALSE 4821
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4752: LD_INT 83
4754: PPUSH
4755: LD_INT 141
4757: PPUSH
4758: CALL_OW 428
4762: PPUSH
4763: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4767: LD_INT 78
4769: PPUSH
4770: LD_INT 133
4772: PPUSH
4773: CALL_OW 428
4777: PPUSH
4778: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4782: LD_INT 83
4784: PPUSH
4785: LD_INT 141
4787: PPUSH
4788: LD_INT 2
4790: PPUSH
4791: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4795: LD_INT 78
4797: PPUSH
4798: LD_INT 133
4800: PPUSH
4801: LD_INT 2
4803: PPUSH
4804: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4808: LD_INT 145
4810: PPUSH
4811: LD_INT 112
4813: PPUSH
4814: LD_INT 3
4816: PPUSH
4817: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4821: LD_ADDR_VAR 0 9
4825: PUSH
4826: LD_INT 22
4828: PUSH
4829: LD_INT 3
4831: PUSH
4832: EMPTY
4833: LIST
4834: LIST
4835: PUSH
4836: LD_INT 2
4838: PUSH
4839: LD_INT 30
4841: PUSH
4842: LD_INT 0
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PUSH
4849: LD_INT 30
4851: PUSH
4852: LD_INT 1
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: PUSH
4859: EMPTY
4860: LIST
4861: LIST
4862: LIST
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PPUSH
4868: CALL_OW 69
4872: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4873: LD_ADDR_VAR 0 10
4877: PUSH
4878: LD_INT 22
4880: PUSH
4881: LD_INT 3
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: PUSH
4888: LD_INT 2
4890: PUSH
4891: LD_INT 30
4893: PUSH
4894: LD_INT 6
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 30
4903: PUSH
4904: LD_INT 7
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 30
4913: PUSH
4914: LD_INT 8
4916: PUSH
4917: EMPTY
4918: LIST
4919: LIST
4920: PUSH
4921: EMPTY
4922: LIST
4923: LIST
4924: LIST
4925: LIST
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: PPUSH
4931: CALL_OW 69
4935: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4936: LD_ADDR_VAR 0 11
4940: PUSH
4941: LD_INT 22
4943: PUSH
4944: LD_INT 3
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: CALL_OW 69
4969: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4970: LD_ADDR_VAR 0 12
4974: PUSH
4975: LD_INT 22
4977: PUSH
4978: LD_INT 3
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PUSH
4985: LD_INT 30
4987: PUSH
4988: LD_INT 31
4990: PUSH
4991: EMPTY
4992: LIST
4993: LIST
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PPUSH
4999: CALL_OW 69
5003: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5004: LD_ADDR_VAR 0 13
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 3
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 32
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 69
5037: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5038: LD_ADDR_VAR 0 14
5042: PUSH
5043: LD_INT 22
5045: PUSH
5046: LD_INT 3
5048: PUSH
5049: EMPTY
5050: LIST
5051: LIST
5052: PUSH
5053: LD_INT 30
5055: PUSH
5056: LD_INT 33
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PPUSH
5067: CALL_OW 69
5071: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5072: LD_ADDR_VAR 0 15
5076: PUSH
5077: LD_INT 42
5079: PUSH
5080: LD_INT 5
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 43
5089: PUSH
5090: LD_INT 50
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 44
5099: PUSH
5100: LD_INT 30
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 46
5109: PUSH
5110: LD_INT 15
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5123: LD_ADDR_VAR 0 16
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 4
5133: PUSH
5134: LD_INT 6
5136: PUSH
5137: LD_INT 3
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: LIST
5145: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5146: LD_ADDR_VAR 0 6
5150: PUSH
5151: LD_INT 4
5153: PUSH
5154: LD_INT 5
5156: PUSH
5157: LD_INT 6
5159: PUSH
5160: EMPTY
5161: LIST
5162: LIST
5163: LIST
5164: PUSH
5165: LD_OWVAR 67
5169: ARRAY
5170: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5171: LD_INT 16
5173: PPUSH
5174: LD_STRING am_tukh
5176: PPUSH
5177: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5181: LD_ADDR_VAR 0 2
5185: PUSH
5186: LD_INT 21
5188: PUSH
5189: LD_INT 3
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PPUSH
5196: CALL_OW 69
5200: PUSH
5201: FOR_IN
5202: IFFALSE 5235
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5204: LD_VAR 0 2
5208: PPUSH
5209: LD_INT 4
5211: PUSH
5212: LD_INT 5
5214: PUSH
5215: LD_INT 6
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 241
5233: GO 5201
5235: POP
5236: POP
// for i in dep_list do
5237: LD_ADDR_VAR 0 2
5241: PUSH
5242: LD_VAR 0 9
5246: PUSH
5247: FOR_IN
5248: IFFALSE 5292
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5250: LD_VAR 0 2
5254: PPUSH
5255: CALL_OW 274
5259: PPUSH
5260: LD_INT 1
5262: PPUSH
5263: LD_INT 1000
5265: PPUSH
5266: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5270: LD_VAR 0 2
5274: PPUSH
5275: CALL_OW 274
5279: PPUSH
5280: LD_INT 2
5282: PPUSH
5283: LD_INT 1000
5285: PPUSH
5286: CALL_OW 277
// end ;
5290: GO 5247
5292: POP
5293: POP
// InitHc ;
5294: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5298: LD_ADDR_VAR 0 8
5302: PUSH
5303: LD_VAR 0 13
5307: PUSH
5308: LD_INT 45
5310: PUSH
5311: LD_INT 60
5313: PUSH
5314: LD_INT 75
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: LIST
5321: PUSH
5322: LD_OWVAR 67
5326: ARRAY
5327: MUL
5328: PUSH
5329: LD_INT 100
5331: DIV
5332: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5333: LD_ADDR_VAR 0 16
5337: PUSH
5338: LD_VAR 0 16
5342: PPUSH
5343: LD_INT 1
5345: PPUSH
5346: LD_VAR 0 8
5350: PPUSH
5351: CALL_OW 1
5355: ST_TO_ADDR
// tmp := [ ] ;
5356: LD_ADDR_VAR 0 8
5360: PUSH
5361: EMPTY
5362: ST_TO_ADDR
// for i in bunker_list do
5363: LD_ADDR_VAR 0 2
5367: PUSH
5368: LD_VAR 0 13
5372: PUSH
5373: FOR_IN
5374: IFFALSE 5470
// if i mod 10 + 1 < tmp then
5376: LD_VAR 0 2
5380: PUSH
5381: LD_INT 10
5383: MOD
5384: PUSH
5385: LD_INT 1
5387: PLUS
5388: PUSH
5389: LD_VAR 0 8
5393: LESS
5394: IFFALSE 5439
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5396: LD_ADDR_VAR 0 8
5400: PUSH
5401: LD_VAR 0 8
5405: PPUSH
5406: LD_VAR 0 2
5410: PUSH
5411: LD_INT 3
5413: PPUSH
5414: LD_INT 5
5416: PPUSH
5417: CALL_OW 12
5421: MOD
5422: PUSH
5423: LD_INT 1
5425: PLUS
5426: PPUSH
5427: LD_VAR 0 2
5431: PPUSH
5432: CALL_OW 2
5436: ST_TO_ADDR
5437: GO 5468
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5439: LD_ADDR_VAR 0 8
5443: PUSH
5444: LD_VAR 0 8
5448: PPUSH
5449: LD_VAR 0 8
5453: PUSH
5454: LD_INT 1
5456: PLUS
5457: PPUSH
5458: LD_VAR 0 2
5462: PPUSH
5463: CALL_OW 2
5467: ST_TO_ADDR
5468: GO 5373
5470: POP
5471: POP
// bunker_list := tmp ;
5472: LD_ADDR_VAR 0 13
5476: PUSH
5477: LD_VAR 0 8
5481: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5482: LD_ADDR_VAR 0 2
5486: PUSH
5487: LD_VAR 0 13
5491: PUSH
5492: LD_VAR 0 14
5496: ADD
5497: PUSH
5498: FOR_IN
5499: IFFALSE 5522
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5501: LD_VAR 0 2
5505: PPUSH
5506: LD_VAR 0 2
5510: PPUSH
5511: CALL 836 0 1
5515: PPUSH
5516: CALL_OW 431
5520: GO 5498
5522: POP
5523: POP
// while ( personel_counter [ 1 ] ) do
5524: LD_VAR 0 16
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: IFFALSE 5640
// begin i := rand ( 1 , bunker_list ) ;
5534: LD_ADDR_VAR 0 2
5538: PUSH
5539: LD_INT 1
5541: PPUSH
5542: LD_VAR 0 13
5546: PPUSH
5547: CALL_OW 12
5551: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5552: LD_INT 0
5554: PPUSH
5555: LD_INT 1
5557: PPUSH
5558: LD_VAR 0 6
5562: PPUSH
5563: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5567: CALL_OW 44
5571: PPUSH
5572: LD_VAR 0 13
5576: PUSH
5577: LD_VAR 0 2
5581: ARRAY
5582: PPUSH
5583: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5587: LD_ADDR_VAR 0 13
5591: PUSH
5592: LD_VAR 0 13
5596: PPUSH
5597: LD_VAR 0 2
5601: PPUSH
5602: CALL_OW 3
5606: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5607: LD_ADDR_VAR 0 16
5611: PUSH
5612: LD_VAR 0 16
5616: PPUSH
5617: LD_INT 1
5619: PPUSH
5620: LD_VAR 0 16
5624: PUSH
5625: LD_INT 1
5627: ARRAY
5628: PUSH
5629: LD_INT 1
5631: MINUS
5632: PPUSH
5633: CALL_OW 1
5637: ST_TO_ADDR
// end ;
5638: GO 5524
// for i = 1 to personel_counter [ 2 ] do
5640: LD_ADDR_VAR 0 2
5644: PUSH
5645: DOUBLE
5646: LD_INT 1
5648: DEC
5649: ST_TO_ADDR
5650: LD_VAR 0 16
5654: PUSH
5655: LD_INT 2
5657: ARRAY
5658: PUSH
5659: FOR_TO
5660: IFFALSE 5691
// begin PrepareHuman ( false , 2 , skill ) ;
5662: LD_INT 0
5664: PPUSH
5665: LD_INT 2
5667: PPUSH
5668: LD_VAR 0 6
5672: PPUSH
5673: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5677: CALL_OW 44
5681: PPUSH
5682: LD_INT 16
5684: PPUSH
5685: CALL_OW 52
// end ;
5689: GO 5659
5691: POP
5692: POP
// for i = 1 to personel_counter [ 3 ] do
5693: LD_ADDR_VAR 0 2
5697: PUSH
5698: DOUBLE
5699: LD_INT 1
5701: DEC
5702: ST_TO_ADDR
5703: LD_VAR 0 16
5707: PUSH
5708: LD_INT 3
5710: ARRAY
5711: PUSH
5712: FOR_TO
5713: IFFALSE 5760
// begin PrepareHuman ( false , 3 , skill ) ;
5715: LD_INT 0
5717: PPUSH
5718: LD_INT 3
5720: PPUSH
5721: LD_VAR 0 6
5725: PPUSH
5726: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5730: CALL_OW 44
5734: PPUSH
5735: LD_VAR 0 11
5739: PUSH
5740: LD_VAR 0 2
5744: PUSH
5745: LD_INT 2
5747: MOD
5748: PUSH
5749: LD_INT 1
5751: PLUS
5752: ARRAY
5753: PPUSH
5754: CALL_OW 52
// end ;
5758: GO 5712
5760: POP
5761: POP
// for i = 1 to personel_counter [ 4 ] do
5762: LD_ADDR_VAR 0 2
5766: PUSH
5767: DOUBLE
5768: LD_INT 1
5770: DEC
5771: ST_TO_ADDR
5772: LD_VAR 0 16
5776: PUSH
5777: LD_INT 4
5779: ARRAY
5780: PUSH
5781: FOR_TO
5782: IFFALSE 5819
// begin PrepareHuman ( false , 4 , skill ) ;
5784: LD_INT 0
5786: PPUSH
5787: LD_INT 4
5789: PPUSH
5790: LD_VAR 0 6
5794: PPUSH
5795: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5799: CALL_OW 44
5803: PPUSH
5804: LD_VAR 0 10
5808: PUSH
5809: LD_INT 1
5811: ARRAY
5812: PPUSH
5813: CALL_OW 52
// end ;
5817: GO 5781
5819: POP
5820: POP
// for i in breastworks_list do
5821: LD_ADDR_VAR 0 2
5825: PUSH
5826: LD_VAR 0 12
5830: PUSH
5831: FOR_IN
5832: IFFALSE 5944
// begin r := GetDir ( i ) ;
5834: LD_ADDR_VAR 0 4
5838: PUSH
5839: LD_VAR 0 2
5843: PPUSH
5844: CALL_OW 254
5848: ST_TO_ADDR
// if r > 3 then
5849: LD_VAR 0 4
5853: PUSH
5854: LD_INT 3
5856: GREATER
5857: IFFALSE 5875
// r := r - 3 else
5859: LD_ADDR_VAR 0 4
5863: PUSH
5864: LD_VAR 0 4
5868: PUSH
5869: LD_INT 3
5871: MINUS
5872: ST_TO_ADDR
5873: GO 5889
// r := r + 3 ;
5875: LD_ADDR_VAR 0 4
5879: PUSH
5880: LD_VAR 0 4
5884: PUSH
5885: LD_INT 3
5887: PLUS
5888: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5889: LD_INT 0
5891: PPUSH
5892: LD_INT 1
5894: PPUSH
5895: LD_VAR 0 6
5899: PPUSH
5900: CALL_OW 380
// un := CreateHuman ;
5904: LD_ADDR_VAR 0 5
5908: PUSH
5909: CALL_OW 44
5913: ST_TO_ADDR
// SetDir ( un , r ) ;
5914: LD_VAR 0 5
5918: PPUSH
5919: LD_VAR 0 4
5923: PPUSH
5924: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5928: LD_VAR 0 5
5932: PPUSH
5933: LD_VAR 0 2
5937: PPUSH
5938: CALL_OW 52
// end ;
5942: GO 5831
5944: POP
5945: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5946: LD_ADDR_VAR 0 8
5950: PUSH
5951: LD_INT 22
5953: PUSH
5954: LD_INT 3
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: PUSH
5961: LD_INT 25
5963: PUSH
5964: LD_INT 3
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PPUSH
5975: CALL_OW 69
5979: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
5980: LD_ADDR_VAR 0 4
5984: PUSH
5985: LD_INT 4
5987: PUSH
5988: LD_INT 5
5990: PUSH
5991: LD_INT 6
5993: PUSH
5994: EMPTY
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_OWVAR 67
6003: ARRAY
6004: ST_TO_ADDR
// for i = 1 to r do
6005: LD_ADDR_VAR 0 2
6009: PUSH
6010: DOUBLE
6011: LD_INT 1
6013: DEC
6014: ST_TO_ADDR
6015: LD_VAR 0 4
6019: PUSH
6020: FOR_TO
6021: IFFALSE 6194
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6023: LD_ADDR_VAR 0 5
6027: PUSH
6028: LD_INT 3
6030: PPUSH
6031: LD_INT 3
6033: PPUSH
6034: LD_INT 22
6036: PUSH
6037: LD_INT 22
6039: PUSH
6040: LD_INT 24
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_VAR 0 2
6052: PUSH
6053: LD_INT 3
6055: MOD
6056: PUSH
6057: LD_INT 1
6059: PLUS
6060: ARRAY
6061: PPUSH
6062: LD_INT 1
6064: PPUSH
6065: LD_INT 1
6067: PPUSH
6068: LD_INT 43
6070: PUSH
6071: LD_INT 44
6073: PUSH
6074: LD_INT 42
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_VAR 0 2
6086: PUSH
6087: LD_INT 3
6089: MOD
6090: PUSH
6091: LD_INT 1
6093: PLUS
6094: ARRAY
6095: PPUSH
6096: LD_INT 100
6098: PPUSH
6099: CALL 422 0 7
6103: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6104: LD_VAR 0 5
6108: PPUSH
6109: LD_INT 0
6111: PPUSH
6112: LD_INT 5
6114: PPUSH
6115: CALL_OW 12
6119: PPUSH
6120: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6124: LD_VAR 0 5
6128: PPUSH
6129: LD_INT 5
6131: PPUSH
6132: LD_INT 0
6134: PPUSH
6135: CALL_OW 49
// if i > tmp - 2 then
6139: LD_VAR 0 2
6143: PUSH
6144: LD_VAR 0 8
6148: PUSH
6149: LD_INT 2
6151: MINUS
6152: GREATER
6153: IFFALSE 6157
// continue ;
6155: GO 6020
// ComExitBuilding ( tmp [ i ] ) ;
6157: LD_VAR 0 8
6161: PUSH
6162: LD_VAR 0 2
6166: ARRAY
6167: PPUSH
6168: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6172: LD_VAR 0 8
6176: PUSH
6177: LD_VAR 0 2
6181: ARRAY
6182: PPUSH
6183: LD_VAR 0 5
6187: PPUSH
6188: CALL_OW 180
// end ;
6192: GO 6020
6194: POP
6195: POP
// end ;
6196: LD_VAR 0 1
6200: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6201: LD_INT 22
6203: PUSH
6204: LD_INT 3
6206: PUSH
6207: EMPTY
6208: LIST
6209: LIST
6210: PUSH
6211: LD_INT 25
6213: PUSH
6214: LD_INT 2
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: IFFALSE 6961
6231: GO 6233
6233: DISABLE
6234: LD_INT 0
6236: PPUSH
6237: PPUSH
6238: PPUSH
6239: PPUSH
6240: PPUSH
// begin enable ;
6241: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6242: LD_ADDR_VAR 0 2
6246: PUSH
6247: LD_INT 6
6249: PPUSH
6250: LD_INT 3
6252: PUSH
6253: LD_INT 24
6255: PUSH
6256: LD_INT 1000
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: LD_INT 21
6269: PUSH
6270: LD_INT 3
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: CALL_OW 70
6285: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6286: LD_ADDR_VAR 0 4
6290: PUSH
6291: LD_INT 22
6293: PUSH
6294: LD_INT 3
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: PUSH
6301: LD_INT 25
6303: PUSH
6304: LD_INT 2
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PPUSH
6315: CALL_OW 69
6319: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6320: LD_VAR 0 2
6324: NOT
6325: PUSH
6326: LD_EXP 19
6330: NOT
6331: AND
6332: IFFALSE 6402
// begin for i in engs do
6334: LD_ADDR_VAR 0 1
6338: PUSH
6339: LD_VAR 0 4
6343: PUSH
6344: FOR_IN
6345: IFFALSE 6400
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6347: LD_VAR 0 1
6351: PPUSH
6352: CALL_OW 256
6356: PUSH
6357: LD_INT 1000
6359: EQUAL
6360: PUSH
6361: LD_VAR 0 1
6365: PPUSH
6366: CALL_OW 314
6370: NOT
6371: AND
6372: PUSH
6373: LD_VAR 0 1
6377: PPUSH
6378: CALL_OW 310
6382: NOT
6383: AND
6384: IFFALSE 6398
// ComEnterUnit ( i , ru_dep_main ) ;
6386: LD_VAR 0 1
6390: PPUSH
6391: LD_INT 16
6393: PPUSH
6394: CALL_OW 120
6398: GO 6344
6400: POP
6401: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6402: LD_VAR 0 4
6406: PPUSH
6407: LD_INT 3
6409: PUSH
6410: LD_INT 24
6412: PUSH
6413: LD_INT 650
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PUSH
6420: EMPTY
6421: LIST
6422: LIST
6423: PPUSH
6424: CALL_OW 72
6428: IFFALSE 6521
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6430: LD_ADDR_VAR 0 3
6434: PUSH
6435: LD_VAR 0 4
6439: PPUSH
6440: LD_INT 3
6442: PUSH
6443: LD_INT 24
6445: PUSH
6446: LD_INT 650
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PPUSH
6457: CALL_OW 72
6461: ST_TO_ADDR
// for i in tmp do
6462: LD_ADDR_VAR 0 1
6466: PUSH
6467: LD_VAR 0 3
6471: PUSH
6472: FOR_IN
6473: IFFALSE 6519
// if not IsInArea ( i , mainBaseArea ) then
6475: LD_VAR 0 1
6479: PPUSH
6480: LD_INT 14
6482: PPUSH
6483: CALL_OW 308
6487: NOT
6488: IFFALSE 6517
// begin ComMoveXY ( i , 129 , 125 ) ;
6490: LD_VAR 0 1
6494: PPUSH
6495: LD_INT 129
6497: PPUSH
6498: LD_INT 125
6500: PPUSH
6501: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6505: LD_VAR 0 1
6509: PPUSH
6510: LD_INT 1050
6512: PPUSH
6513: CALL_OW 202
// end ;
6517: GO 6472
6519: POP
6520: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6521: LD_ADDR_VAR 0 4
6525: PUSH
6526: LD_VAR 0 4
6530: PPUSH
6531: LD_INT 24
6533: PUSH
6534: LD_INT 650
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PPUSH
6541: CALL_OW 72
6545: ST_TO_ADDR
// if not engs then
6546: LD_VAR 0 4
6550: NOT
6551: IFFALSE 6555
// exit ;
6553: GO 6961
// if filter then
6555: LD_VAR 0 2
6559: IFFALSE 6818
// begin for i in engs do
6561: LD_ADDR_VAR 0 1
6565: PUSH
6566: LD_VAR 0 4
6570: PUSH
6571: FOR_IN
6572: IFFALSE 6596
// if IsInUnit ( i ) then
6574: LD_VAR 0 1
6578: PPUSH
6579: CALL_OW 310
6583: IFFALSE 6594
// ComExitBuilding ( i ) ;
6585: LD_VAR 0 1
6589: PPUSH
6590: CALL_OW 122
6594: GO 6571
6596: POP
6597: POP
// wait ( 3 ) ;
6598: LD_INT 3
6600: PPUSH
6601: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6605: LD_VAR 0 2
6609: PUSH
6610: LD_INT 2
6612: GREATEREQUAL
6613: PUSH
6614: LD_VAR 0 4
6618: PUSH
6619: LD_INT 2
6621: GREATEREQUAL
6622: AND
6623: IFFALSE 6771
// begin for i = 1 to engs / 2 do
6625: LD_ADDR_VAR 0 1
6629: PUSH
6630: DOUBLE
6631: LD_INT 1
6633: DEC
6634: ST_TO_ADDR
6635: LD_VAR 0 4
6639: PUSH
6640: LD_INT 2
6642: DIVREAL
6643: PUSH
6644: FOR_TO
6645: IFFALSE 6691
// if not HasTask ( engs [ i ] ) then
6647: LD_VAR 0 4
6651: PUSH
6652: LD_VAR 0 1
6656: ARRAY
6657: PPUSH
6658: CALL_OW 314
6662: NOT
6663: IFFALSE 6689
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6665: LD_VAR 0 4
6669: PUSH
6670: LD_VAR 0 1
6674: ARRAY
6675: PPUSH
6676: LD_VAR 0 2
6680: PUSH
6681: LD_INT 1
6683: ARRAY
6684: PPUSH
6685: CALL_OW 130
6689: GO 6644
6691: POP
6692: POP
// for i = engs / 2 + 1 to engs do
6693: LD_ADDR_VAR 0 1
6697: PUSH
6698: DOUBLE
6699: LD_VAR 0 4
6703: PUSH
6704: LD_INT 2
6706: DIVREAL
6707: PUSH
6708: LD_INT 1
6710: PLUS
6711: DEC
6712: ST_TO_ADDR
6713: LD_VAR 0 4
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6767
// if not HasTask ( engs [ i ] ) then
6721: LD_VAR 0 4
6725: PUSH
6726: LD_VAR 0 1
6730: ARRAY
6731: PPUSH
6732: CALL_OW 314
6736: NOT
6737: IFFALSE 6765
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6739: LD_VAR 0 4
6743: PUSH
6744: LD_VAR 0 1
6748: ARRAY
6749: PPUSH
6750: LD_VAR 0 2
6754: PUSH
6755: LD_VAR 0 2
6759: ARRAY
6760: PPUSH
6761: CALL_OW 130
6765: GO 6718
6767: POP
6768: POP
// end else
6769: GO 6818
// for i in engs do
6771: LD_ADDR_VAR 0 1
6775: PUSH
6776: LD_VAR 0 4
6780: PUSH
6781: FOR_IN
6782: IFFALSE 6816
// if not HasTask ( i ) then
6784: LD_VAR 0 1
6788: PPUSH
6789: CALL_OW 314
6793: NOT
6794: IFFALSE 6814
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6796: LD_VAR 0 1
6800: PPUSH
6801: LD_VAR 0 2
6805: PUSH
6806: LD_INT 1
6808: ARRAY
6809: PPUSH
6810: CALL_OW 130
6814: GO 6781
6816: POP
6817: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6818: LD_ADDR_VAR 0 5
6822: PUSH
6823: LD_INT 81
6825: PUSH
6826: LD_INT 3
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: PPUSH
6833: CALL_OW 69
6837: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6838: LD_EXP 19
6842: PUSH
6843: LD_VAR 0 2
6847: NOT
6848: AND
6849: IFFALSE 6961
// begin ComExitBuilding ( engs ) ;
6851: LD_VAR 0 4
6855: PPUSH
6856: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6860: LD_VAR 0 5
6864: PPUSH
6865: LD_EXP 19
6869: PUSH
6870: LD_INT 2
6872: ARRAY
6873: PPUSH
6874: LD_EXP 19
6878: PUSH
6879: LD_INT 3
6881: ARRAY
6882: PPUSH
6883: CALL_OW 73
6887: PPUSH
6888: LD_EXP 19
6892: PUSH
6893: LD_INT 2
6895: ARRAY
6896: PPUSH
6897: LD_EXP 19
6901: PUSH
6902: LD_INT 3
6904: ARRAY
6905: PPUSH
6906: CALL_OW 297
6910: PUSH
6911: LD_INT 10
6913: GREATER
6914: IFFALSE 6961
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_EXP 19
6925: PUSH
6926: LD_INT 1
6928: ARRAY
6929: PPUSH
6930: LD_EXP 19
6934: PUSH
6935: LD_INT 2
6937: ARRAY
6938: PPUSH
6939: LD_EXP 19
6943: PUSH
6944: LD_INT 3
6946: ARRAY
6947: PPUSH
6948: LD_EXP 19
6952: PUSH
6953: LD_INT 4
6955: ARRAY
6956: PPUSH
6957: CALL_OW 145
// end ; end ;
6961: PPOPN 5
6963: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
6964: LD_INT 16
6966: PPUSH
6967: CALL_OW 256
6971: PUSH
6972: LD_INT 650
6974: LESS
6975: IFFALSE 7058
6977: GO 6979
6979: DISABLE
6980: LD_INT 0
6982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
6983: LD_ADDR_VAR 0 1
6987: PUSH
6988: LD_INT 22
6990: PUSH
6991: LD_INT 3
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: PUSH
6998: LD_INT 25
7000: PUSH
7001: LD_INT 1
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PPUSH
7012: CALL_OW 69
7016: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7017: LD_VAR 0 1
7021: PPUSH
7022: CALL_OW 122
// wait ( 3 ) ;
7026: LD_INT 3
7028: PPUSH
7029: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
7033: LD_VAR 0 1
7037: PPUSH
7038: LD_INT 16
7040: PPUSH
7041: CALL_OW 250
7045: PPUSH
7046: LD_INT 16
7048: PPUSH
7049: CALL_OW 251
7053: PPUSH
7054: CALL_OW 114
// end ;
7058: PPOPN 1
7060: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7061: LD_INT 16
7063: PPUSH
7064: CALL_OW 256
7068: PUSH
7069: LD_INT 650
7071: GREATER
7072: PUSH
7073: LD_INT 22
7075: PUSH
7076: LD_INT 3
7078: PUSH
7079: EMPTY
7080: LIST
7081: LIST
7082: PUSH
7083: LD_INT 25
7085: PUSH
7086: LD_INT 1
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PUSH
7093: LD_INT 56
7095: PUSH
7096: EMPTY
7097: LIST
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: LIST
7103: PUSH
7104: EMPTY
7105: LIST
7106: PPUSH
7107: CALL_OW 69
7111: AND
7112: IFFALSE 7224
7114: GO 7116
7116: DISABLE
7117: LD_INT 0
7119: PPUSH
7120: PPUSH
// begin enable ;
7121: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7122: LD_ADDR_VAR 0 2
7126: PUSH
7127: LD_INT 22
7129: PUSH
7130: LD_INT 3
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: PUSH
7137: LD_INT 25
7139: PUSH
7140: LD_INT 1
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 56
7149: PUSH
7150: EMPTY
7151: LIST
7152: PUSH
7153: LD_INT 3
7155: PUSH
7156: LD_INT 60
7158: PUSH
7159: EMPTY
7160: LIST
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: PUSH
7172: EMPTY
7173: LIST
7174: PPUSH
7175: CALL_OW 69
7179: ST_TO_ADDR
// if not tmp then
7180: LD_VAR 0 2
7184: NOT
7185: IFFALSE 7189
// exit ;
7187: GO 7224
// for i in tmp do
7189: LD_ADDR_VAR 0 1
7193: PUSH
7194: LD_VAR 0 2
7198: PUSH
7199: FOR_IN
7200: IFFALSE 7222
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7202: LD_VAR 0 1
7206: PPUSH
7207: LD_INT 0
7209: PPUSH
7210: LD_INT 143
7212: PPUSH
7213: LD_INT 143
7215: PPUSH
7216: CALL 2059 0 4
7220: GO 7199
7222: POP
7223: POP
// end ;
7224: PPOPN 2
7226: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7227: LD_INT 22
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: EMPTY
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 25
7239: PUSH
7240: LD_INT 4
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PPUSH
7251: CALL_OW 69
7255: IFFALSE 7509
7257: GO 7259
7259: DISABLE
7260: LD_INT 0
7262: PPUSH
7263: PPUSH
7264: PPUSH
// begin enable ;
7265: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7266: LD_ADDR_VAR 0 2
7270: PUSH
7271: LD_INT 14
7273: PPUSH
7274: LD_INT 22
7276: PUSH
7277: LD_INT 3
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PUSH
7284: LD_INT 21
7286: PUSH
7287: LD_INT 1
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: PUSH
7294: LD_INT 3
7296: PUSH
7297: LD_INT 24
7299: PUSH
7300: LD_INT 1000
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: LIST
7315: PPUSH
7316: CALL_OW 70
7320: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7321: LD_ADDR_VAR 0 3
7325: PUSH
7326: LD_INT 22
7328: PUSH
7329: LD_INT 3
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: LD_INT 25
7338: PUSH
7339: LD_INT 4
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: PPUSH
7350: CALL_OW 69
7354: ST_TO_ADDR
// if not doc then
7355: LD_VAR 0 3
7359: NOT
7360: IFFALSE 7364
// exit ;
7362: GO 7509
// if not tmp then
7364: LD_VAR 0 2
7368: NOT
7369: IFFALSE 7460
// begin if not IsInUnit ( doc [ 1 ] ) then
7371: LD_VAR 0 3
7375: PUSH
7376: LD_INT 1
7378: ARRAY
7379: PPUSH
7380: CALL_OW 310
7384: NOT
7385: IFFALSE 7458
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7387: LD_VAR 0 3
7391: PPUSH
7392: LD_INT 22
7394: PUSH
7395: LD_INT 3
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: LD_INT 30
7407: PUSH
7408: LD_INT 6
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: PUSH
7415: LD_INT 30
7417: PUSH
7418: LD_INT 7
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: LD_INT 30
7427: PUSH
7428: LD_INT 8
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: PUSH
7435: EMPTY
7436: LIST
7437: LIST
7438: LIST
7439: LIST
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: PPUSH
7445: CALL_OW 69
7449: PUSH
7450: LD_INT 1
7452: ARRAY
7453: PPUSH
7454: CALL_OW 120
// exit ;
7458: GO 7509
// end ; if IsInUnit ( doc [ 1 ] ) then
7460: LD_VAR 0 3
7464: PUSH
7465: LD_INT 1
7467: ARRAY
7468: PPUSH
7469: CALL_OW 310
7473: IFFALSE 7484
// ComExitBuilding ( doc ) ;
7475: LD_VAR 0 3
7479: PPUSH
7480: CALL_OW 122
// wait ( 3 ) ;
7484: LD_INT 3
7486: PPUSH
7487: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7491: LD_VAR 0 3
7495: PPUSH
7496: LD_VAR 0 2
7500: PUSH
7501: LD_INT 1
7503: ARRAY
7504: PPUSH
7505: CALL_OW 128
// end ;
7509: PPOPN 3
7511: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7512: LD_INT 22
7514: PUSH
7515: LD_INT 3
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: LD_INT 25
7524: PUSH
7525: LD_INT 3
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PPUSH
7536: CALL_OW 69
7540: PUSH
7541: LD_INT 22
7543: PUSH
7544: LD_INT 3
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_INT 21
7553: PUSH
7554: LD_INT 2
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PPUSH
7565: CALL_OW 69
7569: AND
7570: IFFALSE 7984
7572: GO 7574
7574: DISABLE
7575: LD_INT 0
7577: PPUSH
7578: PPUSH
7579: PPUSH
7580: PPUSH
7581: PPUSH
// begin enable ;
7582: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7583: LD_ADDR_VAR 0 2
7587: PUSH
7588: LD_INT 22
7590: PUSH
7591: LD_INT 3
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 21
7600: PUSH
7601: LD_INT 2
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: LD_INT 3
7610: PUSH
7611: LD_INT 58
7613: PUSH
7614: EMPTY
7615: LIST
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 69
7630: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7631: LD_ADDR_VAR 0 4
7635: PUSH
7636: LD_INT 10
7638: PUSH
7639: LD_INT 11
7641: PUSH
7642: LD_INT 12
7644: PUSH
7645: LD_INT 14
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: ST_TO_ADDR
// area := 0 ;
7654: LD_ADDR_VAR 0 5
7658: PUSH
7659: LD_INT 0
7661: ST_TO_ADDR
// attacking := false ;
7662: LD_ADDR_VAR 0 3
7666: PUSH
7667: LD_INT 0
7669: ST_TO_ADDR
// for i in tmp do
7670: LD_ADDR_VAR 0 1
7674: PUSH
7675: LD_VAR 0 2
7679: PUSH
7680: FOR_IN
7681: IFFALSE 7767
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7683: LD_VAR 0 1
7687: PPUSH
7688: LD_INT 22
7690: PUSH
7691: LD_INT 1
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PPUSH
7698: CALL_OW 69
7702: PPUSH
7703: LD_VAR 0 1
7707: PPUSH
7708: CALL_OW 74
7712: PPUSH
7713: CALL_OW 296
7717: PUSH
7718: LD_INT 10
7720: LESS
7721: IFFALSE 7765
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7723: LD_VAR 0 1
7727: PPUSH
7728: LD_INT 22
7730: PUSH
7731: LD_INT 1
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 69
7742: PPUSH
7743: LD_VAR 0 1
7747: PPUSH
7748: CALL_OW 74
7752: PPUSH
7753: CALL_OW 115
// attacking := true ;
7757: LD_ADDR_VAR 0 3
7761: PUSH
7762: LD_INT 1
7764: ST_TO_ADDR
// end ;
7765: GO 7680
7767: POP
7768: POP
// if attacking then
7769: LD_VAR 0 3
7773: IFFALSE 7777
// exit ;
7775: GO 7984
// for i in areas do
7777: LD_ADDR_VAR 0 1
7781: PUSH
7782: LD_VAR 0 4
7786: PUSH
7787: FOR_IN
7788: IFFALSE 7825
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7790: LD_VAR 0 1
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 70
7809: IFFALSE 7823
// begin area := i ;
7811: LD_ADDR_VAR 0 5
7815: PUSH
7816: LD_VAR 0 1
7820: ST_TO_ADDR
// break ;
7821: GO 7825
// end ;
7823: GO 7787
7825: POP
7826: POP
// if area then
7827: LD_VAR 0 5
7831: IFFALSE 7984
// begin for i in tmp do
7833: LD_ADDR_VAR 0 1
7837: PUSH
7838: LD_VAR 0 2
7842: PUSH
7843: FOR_IN
7844: IFFALSE 7982
// begin if GetFuel ( i ) < 33 then
7846: LD_VAR 0 1
7850: PPUSH
7851: CALL_OW 261
7855: PUSH
7856: LD_INT 33
7858: LESS
7859: IFFALSE 7873
// SetFuel ( i , 33 ) ;
7861: LD_VAR 0 1
7865: PPUSH
7866: LD_INT 33
7868: PPUSH
7869: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7873: LD_VAR 0 1
7877: PPUSH
7878: LD_INT 22
7880: PUSH
7881: LD_INT 1
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PPUSH
7888: CALL_OW 69
7892: PPUSH
7893: LD_VAR 0 1
7897: PPUSH
7898: CALL_OW 74
7902: PPUSH
7903: CALL_OW 296
7907: PUSH
7908: LD_INT 10
7910: LESS
7911: IFFALSE 7949
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7913: LD_VAR 0 1
7917: PPUSH
7918: LD_INT 22
7920: PUSH
7921: LD_INT 1
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PPUSH
7928: CALL_OW 69
7932: PPUSH
7933: LD_VAR 0 1
7937: PPUSH
7938: CALL_OW 74
7942: PPUSH
7943: CALL_OW 115
7947: GO 7980
// if not IsInArea ( i , area ) then
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_VAR 0 5
7958: PPUSH
7959: CALL_OW 308
7963: NOT
7964: IFFALSE 7980
// ComMoveToArea ( i , area ) ;
7966: LD_VAR 0 1
7970: PPUSH
7971: LD_VAR 0 5
7975: PPUSH
7976: CALL_OW 113
// end ;
7980: GO 7843
7982: POP
7983: POP
// end ; end ;
7984: PPOPN 5
7986: END
// every 10 10$00 do var i , j , un , veh , time , count ;
7987: GO 7989
7989: DISABLE
7990: LD_INT 0
7992: PPUSH
7993: PPUSH
7994: PPUSH
7995: PPUSH
7996: PPUSH
7997: PPUSH
// begin uc_side := 3 ;
7998: LD_ADDR_OWVAR 20
8002: PUSH
8003: LD_INT 3
8005: ST_TO_ADDR
// uc_nation := 3 ;
8006: LD_ADDR_OWVAR 21
8010: PUSH
8011: LD_INT 3
8013: ST_TO_ADDR
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8014: LD_ADDR_VAR 0 5
8018: PUSH
8019: LD_INT 16800
8021: PUSH
8022: LD_INT 14700
8024: PUSH
8025: LD_INT 12600
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: LIST
8032: PUSH
8033: LD_OWVAR 67
8037: ARRAY
8038: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8039: LD_ADDR_VAR 0 6
8043: PUSH
8044: LD_INT 2
8046: PUSH
8047: LD_INT 2
8049: PUSH
8050: LD_INT 3
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: LIST
8057: PUSH
8058: LD_OWVAR 67
8062: ARRAY
8063: ST_TO_ADDR
// for i = 1 to count do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: DOUBLE
8070: LD_INT 1
8072: DEC
8073: ST_TO_ADDR
8074: LD_VAR 0 6
8078: PUSH
8079: FOR_TO
8080: IFFALSE 8260
// begin wait ( time ) ;
8082: LD_VAR 0 5
8086: PPUSH
8087: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8091: LD_ADDR_VAR 0 2
8095: PUSH
8096: DOUBLE
8097: LD_INT 1
8099: DEC
8100: ST_TO_ADDR
8101: LD_INT 1
8103: PPUSH
8104: LD_OWVAR 67
8108: PPUSH
8109: CALL_OW 12
8113: PUSH
8114: FOR_TO
8115: IFFALSE 8256
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8117: LD_ADDR_VAR 0 4
8121: PUSH
8122: LD_INT 3
8124: PPUSH
8125: LD_INT 3
8127: PPUSH
8128: LD_INT 22
8130: PPUSH
8131: LD_INT 1
8133: PPUSH
8134: LD_INT 1
8136: PPUSH
8137: LD_INT 43
8139: PUSH
8140: LD_INT 44
8142: PUSH
8143: LD_INT 42
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: LIST
8150: PUSH
8151: LD_VAR 0 1
8155: PUSH
8156: LD_INT 3
8158: MOD
8159: PUSH
8160: LD_INT 1
8162: PLUS
8163: ARRAY
8164: PPUSH
8165: LD_INT 80
8167: PPUSH
8168: CALL 422 0 7
8172: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8173: LD_VAR 0 4
8177: PPUSH
8178: LD_INT 13
8180: PPUSH
8181: LD_INT 0
8183: PPUSH
8184: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8188: LD_INT 0
8190: PPUSH
8191: LD_INT 3
8193: PPUSH
8194: LD_INT 4
8196: PUSH
8197: LD_INT 5
8199: PUSH
8200: LD_INT 5
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: PUSH
8208: LD_OWVAR 67
8212: ARRAY
8213: PPUSH
8214: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8218: CALL_OW 44
8222: PPUSH
8223: LD_VAR 0 4
8227: PPUSH
8228: CALL_OW 52
// wait ( 0 0$01 ) ;
8232: LD_INT 35
8234: PPUSH
8235: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8239: LD_VAR 0 4
8243: PPUSH
8244: LD_INT 143
8246: PPUSH
8247: LD_INT 143
8249: PPUSH
8250: CALL_OW 111
// end ;
8254: GO 8114
8256: POP
8257: POP
// end ;
8258: GO 8079
8260: POP
8261: POP
// end ;
8262: PPOPN 6
8264: END
// every 8 8$00 do var i , un , time ;
8265: GO 8267
8267: DISABLE
8268: LD_INT 0
8270: PPUSH
8271: PPUSH
8272: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
8273: LD_ADDR_VAR 0 3
8277: PUSH
8278: LD_INT 4200
8280: PUSH
8281: LD_INT 2100
8283: PUSH
8284: LD_INT 1050
8286: PUSH
8287: EMPTY
8288: LIST
8289: LIST
8290: LIST
8291: ST_TO_ADDR
// wait ( time ) ;
8292: LD_VAR 0 3
8296: PPUSH
8297: CALL_OW 67
// uc_side := 3 ;
8301: LD_ADDR_OWVAR 20
8305: PUSH
8306: LD_INT 3
8308: ST_TO_ADDR
// uc_nation := 3 ;
8309: LD_ADDR_OWVAR 21
8313: PUSH
8314: LD_INT 3
8316: ST_TO_ADDR
// for i = 1 to 2 do
8317: LD_ADDR_VAR 0 1
8321: PUSH
8322: DOUBLE
8323: LD_INT 1
8325: DEC
8326: ST_TO_ADDR
8327: LD_INT 2
8329: PUSH
8330: FOR_TO
8331: IFFALSE 8394
// begin PrepareHuman ( false , 1 , 4 ) ;
8333: LD_INT 0
8335: PPUSH
8336: LD_INT 1
8338: PPUSH
8339: LD_INT 4
8341: PPUSH
8342: CALL_OW 380
// un := CreateHuman ;
8346: LD_ADDR_VAR 0 2
8350: PUSH
8351: CALL_OW 44
8355: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8356: LD_VAR 0 2
8360: PPUSH
8361: LD_INT 16
8363: PPUSH
8364: CALL_OW 52
// ComExitBuilding ( un ) ;
8368: LD_VAR 0 2
8372: PPUSH
8373: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8377: LD_VAR 0 2
8381: PPUSH
8382: LD_INT 41
8384: PPUSH
8385: LD_INT 76
8387: PPUSH
8388: CALL_OW 174
// end ;
8392: GO 8330
8394: POP
8395: POP
// end ; end_of_file
8396: PPOPN 3
8398: END
// export function Action ; begin
8399: LD_INT 0
8401: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8402: LD_INT 28
8404: PPUSH
8405: LD_INT 3
8407: PPUSH
8408: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8412: LD_INT 41
8414: PPUSH
8415: LD_INT 76
8417: PPUSH
8418: LD_INT 1
8420: PPUSH
8421: LD_INT 10
8423: PPUSH
8424: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8428: LD_INT 41
8430: PPUSH
8431: LD_INT 76
8433: PPUSH
8434: LD_INT 1
8436: PPUSH
8437: CALL_OW 331
// InGameOn ;
8441: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8445: LD_EXP 18
8449: PPUSH
8450: LD_STRING D2-Har-1
8452: PPUSH
8453: CALL_OW 94
// InGameOff ;
8457: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8461: LD_STRING M1
8463: PPUSH
8464: CALL_OW 337
// end ;
8468: LD_VAR 0 1
8472: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8473: LD_EXP 4
8477: PUSH
8478: LD_INT 1
8480: GREATER
8481: IFFALSE 8572
8483: GO 8485
8485: DISABLE
8486: LD_INT 0
8488: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8489: LD_ADDR_VAR 0 1
8493: PUSH
8494: LD_INT 1
8496: PPUSH
8497: CALL 510 0 1
8501: PUSH
8502: LD_INT 1
8504: ARRAY
8505: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8506: LD_VAR 0 1
8510: PPUSH
8511: LD_STRING D2a-Sol1-1
8513: PPUSH
8514: CALL_OW 88
// if not un then
8518: LD_VAR 0 1
8522: NOT
8523: IFFALSE 8554
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8525: LD_ADDR_VAR 0 1
8529: PUSH
8530: LD_INT 2
8532: PPUSH
8533: CALL 510 0 1
8537: PUSH
8538: LD_INT 1
8540: ARRAY
8541: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8542: LD_VAR 0 1
8546: PPUSH
8547: LD_STRING D2a-FSol1-1
8549: PPUSH
8550: CALL_OW 88
// end ; if Khatam then
8554: LD_EXP 16
8558: IFFALSE 8572
// Say ( Khatam , D3b-Khat-3 ) ;
8560: LD_EXP 16
8564: PPUSH
8565: LD_STRING D3b-Khat-3
8567: PPUSH
8568: CALL_OW 88
// end ;
8572: PPOPN 1
8574: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8575: LD_EXP 14
8579: PUSH
8580: LD_EXP 17
8584: NOT
8585: AND
8586: PUSH
8587: LD_INT 22
8589: PUSH
8590: LD_INT 1
8592: PUSH
8593: EMPTY
8594: LIST
8595: LIST
8596: PUSH
8597: LD_INT 92
8599: PUSH
8600: LD_EXP 14
8604: PPUSH
8605: CALL_OW 250
8609: PUSH
8610: LD_EXP 14
8614: PPUSH
8615: CALL_OW 251
8619: PUSH
8620: LD_INT 7
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: PUSH
8629: EMPTY
8630: LIST
8631: LIST
8632: PPUSH
8633: CALL_OW 69
8637: AND
8638: PUSH
8639: LD_INT 1
8641: PPUSH
8642: CALL_OW 463
8646: NOT
8647: AND
8648: IFFALSE 9235
8650: GO 8652
8652: DISABLE
8653: LD_INT 0
8655: PPUSH
8656: PPUSH
// begin InGameOn ;
8657: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8661: LD_ADDR_VAR 0 2
8665: PUSH
8666: LD_INT 22
8668: PUSH
8669: LD_INT 0
8671: PUSH
8672: EMPTY
8673: LIST
8674: LIST
8675: PUSH
8676: LD_INT 25
8678: PUSH
8679: LD_INT 12
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PPUSH
8690: CALL_OW 69
8694: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8695: LD_ADDR_VAR 0 2
8699: PUSH
8700: LD_VAR 0 2
8704: PPUSH
8705: LD_EXP 14
8709: PPUSH
8710: CALL_OW 74
8714: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8715: LD_ADDR_VAR 0 1
8719: PUSH
8720: LD_INT 22
8722: PUSH
8723: LD_INT 1
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: PUSH
8730: LD_INT 21
8732: PUSH
8733: LD_INT 1
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: LD_INT 91
8742: PUSH
8743: LD_EXP 14
8747: PUSH
8748: LD_INT 20
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: LIST
8760: PPUSH
8761: CALL_OW 69
8765: PUSH
8766: FOR_IN
8767: IFFALSE 8785
// ComTurnUnit ( i , Frank ) ;
8769: LD_VAR 0 1
8773: PPUSH
8774: LD_EXP 14
8778: PPUSH
8779: CALL_OW 119
8783: GO 8766
8785: POP
8786: POP
// SetSide ( Frank , 1 ) ;
8787: LD_EXP 14
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8799: LD_EXP 8
8803: PPUSH
8804: LD_EXP 14
8808: PPUSH
8809: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8813: LD_EXP 8
8817: PPUSH
8818: LD_EXP 14
8822: PPUSH
8823: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8827: LD_EXP 14
8831: PPUSH
8832: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8836: LD_EXP 14
8840: PPUSH
8841: LD_STRING D3a-Frank-1
8843: PPUSH
8844: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8848: LD_VAR 0 2
8852: PPUSH
8853: LD_INT 42
8855: PPUSH
8856: LD_INT 78
8858: PPUSH
8859: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
8863: LD_VAR 0 2
8867: PPUSH
8868: LD_EXP 14
8872: PPUSH
8873: CALL_OW 179
// if Lisa then
8877: LD_EXP 13
8881: IFFALSE 8895
// Say ( Lisa , D3a-Lisa-1 ) ;
8883: LD_EXP 13
8887: PPUSH
8888: LD_STRING D3a-Lisa-1
8890: PPUSH
8891: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
8895: LD_EXP 8
8899: PPUSH
8900: LD_STRING D3a-JMM-1
8902: PPUSH
8903: CALL_OW 88
// if Cyrus then
8907: LD_EXP 12
8911: IFFALSE 8925
// Say ( Cyrus , D3a-Cyrus-1 ) ;
8913: LD_EXP 12
8917: PPUSH
8918: LD_STRING D3a-Cyrus-1
8920: PPUSH
8921: CALL_OW 88
// if GetRandom ( sex_male ) then
8925: LD_INT 1
8927: PPUSH
8928: CALL 510 0 1
8932: IFFALSE 8953
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
8934: LD_INT 1
8936: PPUSH
8937: CALL 510 0 1
8941: PUSH
8942: LD_INT 1
8944: ARRAY
8945: PPUSH
8946: LD_STRING D3a-Sol1-1
8948: PPUSH
8949: CALL_OW 88
// if GetRandom ( sex_female ) then
8953: LD_INT 2
8955: PPUSH
8956: CALL 510 0 1
8960: IFFALSE 8981
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
8962: LD_INT 2
8964: PPUSH
8965: CALL 510 0 1
8969: PUSH
8970: LD_INT 1
8972: ARRAY
8973: PPUSH
8974: LD_STRING D3a-FSol1-1
8976: PPUSH
8977: CALL_OW 88
// if Gladstone then
8981: LD_EXP 15
8985: IFFALSE 8999
// Say ( Gladstone , D3a-Glad-1 ) ;
8987: LD_EXP 15
8991: PPUSH
8992: LD_STRING D3a-Glad-1
8994: PPUSH
8995: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
8999: LD_VAR 0 2
9003: PPUSH
9004: LD_INT 60
9006: PPUSH
9007: LD_INT 113
9009: PPUSH
9010: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9014: LD_EXP 14
9018: PPUSH
9019: LD_STRING D3a-Frank-2
9021: PPUSH
9022: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9026: LD_EXP 14
9030: PPUSH
9031: LD_EXP 8
9035: PPUSH
9036: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9040: LD_EXP 8
9044: PPUSH
9045: LD_STRING D3a-JMM-2
9047: PPUSH
9048: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9052: LD_INT 1
9054: PPUSH
9055: LD_INT 4
9057: PPUSH
9058: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9062: LD_INT 85
9064: PPUSH
9065: LD_INT 134
9067: PPUSH
9068: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9072: LD_EXP 14
9076: PPUSH
9077: LD_STRING D3a-Frank-3
9079: PPUSH
9080: CALL_OW 88
// Wait ( 0 0$01 ) ;
9084: LD_INT 35
9086: PPUSH
9087: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9091: LD_INT 166
9093: PPUSH
9094: LD_INT 136
9096: PPUSH
9097: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9101: LD_EXP 8
9105: PPUSH
9106: LD_STRING D3a-JMM-3
9108: PPUSH
9109: CALL_OW 88
// Wait ( 0 0$01 ) ;
9113: LD_INT 35
9115: PPUSH
9116: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9120: LD_EXP 14
9124: PPUSH
9125: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9129: LD_EXP 14
9133: PPUSH
9134: LD_STRING D3a-Frank-4
9136: PPUSH
9137: CALL_OW 88
// if Lisa then
9141: LD_EXP 13
9145: IFFALSE 9159
// Say ( Lisa , D3a-Lisa-4 ) ;
9147: LD_EXP 13
9151: PPUSH
9152: LD_STRING D3a-Lisa-4
9154: PPUSH
9155: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9159: LD_EXP 8
9163: PPUSH
9164: LD_STRING D3a-JMM-4
9166: PPUSH
9167: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9171: LD_EXP 14
9175: PPUSH
9176: LD_STRING D3a-Frank-5
9178: PPUSH
9179: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9183: LD_EXP 8
9187: PPUSH
9188: LD_STRING D3a-JMM-5
9190: PPUSH
9191: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9195: LD_EXP 14
9199: PPUSH
9200: LD_STRING D3a-Frank-6
9202: PPUSH
9203: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9207: LD_EXP 8
9211: PPUSH
9212: LD_STRING D3a-JMM-6
9214: PPUSH
9215: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9219: LD_EXP 14
9223: PPUSH
9224: LD_STRING D3a-Frank-7
9226: PPUSH
9227: CALL_OW 88
// InGameOff ;
9231: CALL_OW 9
// end ;
9235: PPOPN 2
9237: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9238: LD_EXP 17
9242: PUSH
9243: LD_EXP 14
9247: NOT
9248: AND
9249: PUSH
9250: LD_INT 22
9252: PUSH
9253: LD_INT 1
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: PUSH
9260: LD_INT 92
9262: PUSH
9263: LD_EXP 17
9267: PPUSH
9268: CALL_OW 250
9272: PUSH
9273: LD_EXP 17
9277: PPUSH
9278: CALL_OW 251
9282: PUSH
9283: LD_INT 7
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: LIST
9290: LIST
9291: PUSH
9292: EMPTY
9293: LIST
9294: LIST
9295: PPUSH
9296: CALL_OW 69
9300: AND
9301: PUSH
9302: LD_INT 1
9304: PPUSH
9305: CALL_OW 463
9309: NOT
9310: AND
9311: IFFALSE 9491
9313: GO 9315
9315: DISABLE
// begin InGameOn ;
9316: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9320: LD_EXP 8
9324: PPUSH
9325: LD_EXP 17
9329: PPUSH
9330: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9334: LD_EXP 17
9338: PPUSH
9339: LD_EXP 8
9343: PPUSH
9344: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9348: LD_EXP 17
9352: PPUSH
9353: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9357: LD_EXP 17
9361: PPUSH
9362: LD_STRING D3b-Yam-1
9364: PPUSH
9365: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9369: LD_EXP 8
9373: PPUSH
9374: LD_STRING D3b-JMM-1
9376: PPUSH
9377: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9381: LD_INT 1
9383: PPUSH
9384: LD_INT 4
9386: PPUSH
9387: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9391: LD_INT 85
9393: PPUSH
9394: LD_INT 134
9396: PPUSH
9397: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9401: LD_EXP 17
9405: PPUSH
9406: LD_STRING D3b-Yam-2
9408: PPUSH
9409: CALL_OW 88
// Wait ( 0 0$01 ) ;
9413: LD_INT 35
9415: PPUSH
9416: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9420: LD_EXP 8
9424: PPUSH
9425: LD_STRING D3b-JMM-2
9427: PPUSH
9428: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9432: LD_INT 166
9434: PPUSH
9435: LD_INT 136
9437: PPUSH
9438: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9442: LD_EXP 17
9446: PPUSH
9447: LD_STRING D3b-Yam-3
9449: PPUSH
9450: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9454: LD_EXP 8
9458: PPUSH
9459: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9463: LD_EXP 8
9467: PPUSH
9468: LD_STRING D3b-JMM-3a
9470: PPUSH
9471: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9475: LD_EXP 17
9479: PPUSH
9480: LD_INT 1
9482: PPUSH
9483: CALL_OW 235
// InGameOff ;
9487: CALL_OW 9
// end ;
9491: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9492: LD_INT 7
9494: PPUSH
9495: LD_INT 22
9497: PUSH
9498: LD_INT 1
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: PUSH
9505: LD_INT 3
9507: PUSH
9508: LD_INT 24
9510: PUSH
9511: LD_INT 1000
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PPUSH
9526: CALL_OW 70
9530: IFFALSE 9986
9532: GO 9534
9534: DISABLE
9535: LD_INT 0
9537: PPUSH
9538: PPUSH
9539: PPUSH
9540: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9541: LD_INT 35
9543: PPUSH
9544: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9548: LD_ADDR_VAR 0 1
9552: PUSH
9553: LD_INT 7
9555: PPUSH
9556: LD_INT 22
9558: PUSH
9559: LD_INT 1
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: PUSH
9566: LD_INT 3
9568: PUSH
9569: LD_INT 24
9571: PUSH
9572: LD_INT 1000
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: PPUSH
9587: CALL_OW 70
9591: ST_TO_ADDR
// if not un then
9592: LD_VAR 0 1
9596: NOT
9597: IFFALSE 9601
// continue ;
9599: GO 9541
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9601: LD_ADDR_VAR 0 3
9605: PUSH
9606: LD_VAR 0 1
9610: PUSH
9611: LD_INT 1
9613: ARRAY
9614: PPUSH
9615: CALL 3407 0 1
9619: ST_TO_ADDR
// until tw ;
9620: LD_VAR 0 3
9624: IFFALSE 9541
// DialogueOn ;
9626: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9630: LD_VAR 0 3
9634: PPUSH
9635: CALL_OW 87
// if Lisa then
9639: LD_EXP 13
9643: IFFALSE 9671
// begin Say ( Lisa , D5-Lisa-1 ) ;
9645: LD_EXP 13
9649: PPUSH
9650: LD_STRING D5-Lisa-1
9652: PPUSH
9653: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9657: LD_EXP 8
9661: PPUSH
9662: LD_STRING D5-JMM-1a
9664: PPUSH
9665: CALL_OW 88
// end else
9669: GO 9683
// Say ( JMM , D5-JMM-1 ) ;
9671: LD_EXP 8
9675: PPUSH
9676: LD_STRING D5-JMM-1
9678: PPUSH
9679: CALL_OW 88
// DialogueOff ;
9683: CALL_OW 7
// while ( true ) do
9687: LD_INT 1
9689: IFFALSE 9745
// begin wait ( 0 0$01 ) ;
9691: LD_INT 35
9693: PPUSH
9694: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9698: LD_ADDR_VAR 0 2
9702: PUSH
9703: LD_INT 8
9705: PPUSH
9706: LD_INT 30
9708: PUSH
9709: LD_INT 26
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: PUSH
9716: LD_INT 101
9718: PUSH
9719: LD_INT 1
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PPUSH
9730: CALL_OW 71
9734: ST_TO_ADDR
// if x then
9735: LD_VAR 0 2
9739: IFFALSE 9743
// break ;
9741: GO 9745
// end ;
9743: GO 9687
// CenterOnUnits ( x [ 1 ] ) ;
9745: LD_VAR 0 2
9749: PUSH
9750: LD_INT 1
9752: ARRAY
9753: PPUSH
9754: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9758: LD_EXP 14
9762: PUSH
9763: LD_EXP 14
9767: PPUSH
9768: CALL_OW 255
9772: PUSH
9773: LD_INT 1
9775: EQUAL
9776: AND
9777: IFFALSE 9793
// Say ( Frank , D5a-Frank-1 ) else
9779: LD_EXP 14
9783: PPUSH
9784: LD_STRING D5a-Frank-1
9786: PPUSH
9787: CALL_OW 88
9791: GO 9847
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9793: LD_EXP 17
9797: PUSH
9798: LD_EXP 17
9802: PPUSH
9803: CALL_OW 255
9807: PUSH
9808: LD_INT 1
9810: EQUAL
9811: AND
9812: IFFALSE 9828
// Say ( Kikuchi , D5a-Yam-1 ) else
9814: LD_EXP 17
9818: PPUSH
9819: LD_STRING D5a-Yam-1
9821: PPUSH
9822: CALL_OW 88
9826: GO 9847
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9828: LD_INT 1
9830: PPUSH
9831: CALL 510 0 1
9835: PUSH
9836: LD_INT 1
9838: ARRAY
9839: PPUSH
9840: LD_STRING D5a-Sol1-1
9842: PPUSH
9843: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9847: LD_EXP 8
9851: PPUSH
9852: LD_STRING D5a-JMM-1
9854: PPUSH
9855: CALL_OW 88
// if Cyrus then
9859: LD_EXP 12
9863: IFFALSE 9877
// Say ( Cyrus , D5a-Cyrus-1 ) ;
9865: LD_EXP 12
9869: PPUSH
9870: LD_STRING D5a-Cyrus-1
9872: PPUSH
9873: CALL_OW 88
// x := false ;
9877: LD_ADDR_VAR 0 2
9881: PUSH
9882: LD_INT 0
9884: ST_TO_ADDR
// while ( true ) do
9885: LD_INT 1
9887: IFFALSE 9974
// begin wait ( 0 0$01 ) ;
9889: LD_INT 35
9891: PPUSH
9892: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
9896: LD_ADDR_VAR 0 4
9900: PUSH
9901: LD_INT 2
9903: PUSH
9904: LD_INT 30
9906: PUSH
9907: LD_INT 0
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 30
9916: PUSH
9917: LD_INT 1
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: EMPTY
9925: LIST
9926: LIST
9927: LIST
9928: PPUSH
9929: CALL_OW 69
9933: PUSH
9934: LD_INT 1
9936: DIFF
9937: PUSH
9938: FOR_IN
9939: IFFALSE 9962
// if BaseNeedEnergy ( i ) then
9941: LD_VAR 0 4
9945: PPUSH
9946: CALL 2532 0 1
9950: IFFALSE 9960
// x := true ;
9952: LD_ADDR_VAR 0 2
9956: PUSH
9957: LD_INT 1
9959: ST_TO_ADDR
9960: GO 9938
9962: POP
9963: POP
// if x then
9964: LD_VAR 0 2
9968: IFFALSE 9972
// break ;
9970: GO 9974
// end ;
9972: GO 9885
// Say ( JMM , D5b-JMM-1 ) ;
9974: LD_EXP 8
9978: PPUSH
9979: LD_STRING D5b-JMM-1
9981: PPUSH
9982: CALL_OW 88
// end ;
9986: PPOPN 4
9988: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
9989: LD_EXP 5
9993: PUSH
9994: LD_INT 1
9996: ARRAY
9997: PUSH
9998: LD_OWVAR 1
10002: LESS
10003: IFFALSE 10203
10005: GO 10007
10007: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10008: LD_INT 16
10010: PPUSH
10011: CALL_OW 301
10015: NOT
10016: IFFALSE 10039
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10018: LD_EXP 18
10022: PPUSH
10023: LD_STRING D3b-Har-3
10025: PPUSH
10026: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10030: LD_STRING M2a
10032: PPUSH
10033: CALL_OW 337
// end else
10037: GO 10058
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10039: LD_EXP 18
10043: PPUSH
10044: LD_STRING D3b-Har-3a
10046: PPUSH
10047: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10051: LD_STRING M2
10053: PPUSH
10054: CALL_OW 337
// end ; can_end := true ;
10058: LD_ADDR_EXP 6
10062: PUSH
10063: LD_INT 1
10065: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10066: LD_INT 9
10068: PPUSH
10069: LD_INT 1
10071: PPUSH
10072: CALL_OW 424
// Wait ( 0 0$02 ) ;
10076: LD_INT 70
10078: PPUSH
10079: CALL_OW 67
// if Lisa then
10083: LD_EXP 13
10087: IFFALSE 10101
// Say ( Lisa , D3b-Lisa ) ;
10089: LD_EXP 13
10093: PPUSH
10094: LD_STRING D3b-Lisa
10096: PPUSH
10097: CALL_OW 88
// if Bobby then
10101: LD_EXP 11
10105: IFFALSE 10119
// Say ( Bobby , D3b-Bobby-3 ) ;
10107: LD_EXP 11
10111: PPUSH
10112: LD_STRING D3b-Bobby-3
10114: PPUSH
10115: CALL_OW 88
// if Cyrus then
10119: LD_EXP 12
10123: IFFALSE 10137
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10125: LD_EXP 12
10129: PPUSH
10130: LD_STRING D3b-Cyrus-3
10132: PPUSH
10133: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10137: LD_EXP 14
10141: PUSH
10142: LD_EXP 14
10146: PPUSH
10147: CALL_OW 255
10151: PUSH
10152: LD_INT 1
10154: EQUAL
10155: AND
10156: IFFALSE 10170
// Say ( Frank , D3b-Frank-3 ) ;
10158: LD_EXP 14
10162: PPUSH
10163: LD_STRING D3b-Frank-3
10165: PPUSH
10166: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10170: LD_EXP 17
10174: PUSH
10175: LD_EXP 17
10179: PPUSH
10180: CALL_OW 255
10184: PUSH
10185: LD_INT 1
10187: EQUAL
10188: AND
10189: IFFALSE 10203
// Say ( Kikuchi , D3b-Yam-4 ) ;
10191: LD_EXP 17
10195: PPUSH
10196: LD_STRING D3b-Yam-4
10198: PPUSH
10199: CALL_OW 88
// end ;
10203: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10204: LD_EXP 5
10208: PUSH
10209: LD_INT 2
10211: ARRAY
10212: PUSH
10213: LD_OWVAR 1
10217: LESS
10218: IFFALSE 10250
10220: GO 10222
10222: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10223: LD_EXP 18
10227: PPUSH
10228: LD_STRING D4-Har-1
10230: PPUSH
10231: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10235: LD_STRING M3
10237: PPUSH
10238: CALL_OW 337
// must_end := true ;
10242: LD_ADDR_EXP 7
10246: PUSH
10247: LD_INT 1
10249: ST_TO_ADDR
// end ;
10250: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10251: LD_EXP 5
10255: PUSH
10256: LD_INT 3
10258: ARRAY
10259: PUSH
10260: LD_OWVAR 1
10264: LESS
10265: IFFALSE 10296
10267: GO 10269
10269: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10270: LD_INT 16
10272: PPUSH
10273: CALL_OW 301
10277: NOT
10278: IFFALSE 10289
// YouLost ( TimeOut1 ) else
10280: LD_STRING TimeOut1
10282: PPUSH
10283: CALL_OW 104
10287: GO 10296
// YouLost ( TimeOut2 ) ;
10289: LD_STRING TimeOut2
10291: PPUSH
10292: CALL_OW 104
// end ;
10296: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
10297: LD_EXP 8
10301: PPUSH
10302: LD_INT 9
10304: PPUSH
10305: CALL_OW 308
10309: PUSH
10310: LD_EXP 6
10314: AND
10315: IFFALSE 11309
10317: GO 10319
10319: DISABLE
10320: LD_INT 0
10322: PPUSH
10323: PPUSH
10324: PPUSH
// begin wait_on := false ;
10325: LD_ADDR_VAR 0 1
10329: PUSH
10330: LD_INT 0
10332: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10333: LD_INT 1
10335: PPUSH
10336: CALL 2609 0 1
10340: PUSH
10341: LD_INT 0
10343: PLUS
10344: PUSH
10345: LD_INT 1
10347: PPUSH
10348: LD_INT 9
10350: PPUSH
10351: CALL 2700 0 2
10355: PUSH
10356: LD_INT 1
10358: PPUSH
10359: LD_INT 9
10361: PPUSH
10362: CALL 2747 0 2
10366: ADD
10367: PUSH
10368: LD_INT 0
10370: PLUS
10371: GREATER
10372: IFFALSE 10421
// case Query ( Q1 ) of 1 :
10374: LD_STRING Q1
10376: PPUSH
10377: CALL_OW 97
10381: PUSH
10382: LD_INT 1
10384: DOUBLE
10385: EQUAL
10386: IFTRUE 10390
10388: GO 10401
10390: POP
// wait_on := true ; 2 :
10391: LD_ADDR_VAR 0 1
10395: PUSH
10396: LD_INT 1
10398: ST_TO_ADDR
10399: GO 10421
10401: LD_INT 2
10403: DOUBLE
10404: EQUAL
10405: IFTRUE 10409
10407: GO 10420
10409: POP
// wait_on := false ; end ;
10410: LD_ADDR_VAR 0 1
10414: PUSH
10415: LD_INT 0
10417: ST_TO_ADDR
10418: GO 10421
10420: POP
// repeat wait ( 0 0$01 ) ;
10421: LD_INT 35
10423: PPUSH
10424: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10428: LD_VAR 0 1
10432: NOT
10433: PUSH
10434: LD_INT 1
10436: PPUSH
10437: CALL 2609 0 1
10441: PUSH
10442: LD_INT 0
10444: PLUS
10445: PUSH
10446: LD_INT 1
10448: PPUSH
10449: LD_INT 9
10451: PPUSH
10452: CALL 2700 0 2
10456: PUSH
10457: LD_INT 1
10459: PPUSH
10460: LD_INT 9
10462: PPUSH
10463: CALL 2747 0 2
10467: ADD
10468: PUSH
10469: LD_INT 0
10471: PLUS
10472: EQUAL
10473: OR
10474: IFFALSE 10421
// DialogueOn ;
10476: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10480: LD_EXP 8
10484: PPUSH
10485: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10489: LD_EXP 8
10493: PPUSH
10494: LD_STRING D6-JMM-1
10496: PPUSH
10497: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10501: LD_EXP 18
10505: PPUSH
10506: LD_STRING D6-Har-1
10508: PPUSH
10509: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10513: LD_EXP 8
10517: PPUSH
10518: LD_STRING D6-JMM-2
10520: PPUSH
10521: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10525: LD_EXP 18
10529: PPUSH
10530: LD_STRING D6-Har-2
10532: PPUSH
10533: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10537: LD_EXP 8
10541: PPUSH
10542: LD_STRING D6-JMM-3
10544: PPUSH
10545: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10549: LD_EXP 18
10553: PPUSH
10554: LD_STRING D6-Har-3
10556: PPUSH
10557: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10561: LD_EXP 8
10565: PPUSH
10566: LD_STRING D6-JMM-4
10568: PPUSH
10569: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10573: LD_EXP 18
10577: PPUSH
10578: LD_STRING D6-Har-4
10580: PPUSH
10581: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10585: LD_EXP 8
10589: PPUSH
10590: LD_STRING D6-JMM-5
10592: PPUSH
10593: CALL_OW 88
// DialogueOff ;
10597: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
10601: LD_ADDR_VAR 0 3
10605: PUSH
10606: LD_INT 3
10608: PPUSH
10609: CALL 2878 0 1
10613: ST_TO_ADDR
// if tmp >= 35 then
10614: LD_VAR 0 3
10618: PUSH
10619: LD_INT 35
10621: GREATEREQUAL
10622: IFFALSE 10659
// begin AddMedal ( Destroy1 , - 1 ) ;
10624: LD_STRING Destroy1
10626: PPUSH
10627: LD_INT 1
10629: NEG
10630: PPUSH
10631: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10635: LD_STRING Destroy2
10637: PPUSH
10638: LD_INT 1
10640: NEG
10641: PPUSH
10642: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10646: LD_STRING Destroy3
10648: PPUSH
10649: LD_INT 1
10651: NEG
10652: PPUSH
10653: CALL_OW 101
// end else
10657: GO 10746
// begin AddMedal ( Destroy1 , 1 ) ;
10659: LD_STRING Destroy1
10661: PPUSH
10662: LD_INT 1
10664: PPUSH
10665: CALL_OW 101
// if tmp >= 25 then
10669: LD_VAR 0 3
10673: PUSH
10674: LD_INT 25
10676: GREATEREQUAL
10677: IFFALSE 10703
// begin AddMedal ( Destroy2 , - 1 ) ;
10679: LD_STRING Destroy2
10681: PPUSH
10682: LD_INT 1
10684: NEG
10685: PPUSH
10686: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10690: LD_STRING Destroy3
10692: PPUSH
10693: LD_INT 1
10695: NEG
10696: PPUSH
10697: CALL_OW 101
// end else
10701: GO 10746
// begin AddMedal ( Destroy2 , 1 ) ;
10703: LD_STRING Destroy2
10705: PPUSH
10706: LD_INT 1
10708: PPUSH
10709: CALL_OW 101
// if tmp >= 15 then
10713: LD_VAR 0 3
10717: PUSH
10718: LD_INT 15
10720: GREATEREQUAL
10721: IFFALSE 10736
// AddMedal ( Destroy3 , - 1 ) else
10723: LD_STRING Destroy3
10725: PPUSH
10726: LD_INT 1
10728: NEG
10729: PPUSH
10730: CALL_OW 101
10734: GO 10746
// AddMedal ( Destroy3 , 1 ) ;
10736: LD_STRING Destroy3
10738: PPUSH
10739: LD_INT 1
10741: PPUSH
10742: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
10746: LD_STRING MAIN
10748: PPUSH
10749: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
10753: LD_ADDR_VAR 0 3
10757: PUSH
10758: LD_INT 1
10760: PPUSH
10761: LD_INT 9
10763: PPUSH
10764: CALL 2700 0 2
10768: PUSH
10769: LD_INT 1
10771: PPUSH
10772: LD_INT 9
10774: PPUSH
10775: CALL 2747 0 2
10779: UNION
10780: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10781: LD_VAR 0 3
10785: PPUSH
10786: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10790: LD_EXP 8
10794: PPUSH
10795: LD_EXP 3
10799: PUSH
10800: LD_STRING JMM
10802: STR
10803: PPUSH
10804: CALL_OW 38
// if Brown in tmp then
10808: LD_EXP 9
10812: PUSH
10813: LD_VAR 0 3
10817: IN
10818: IFFALSE 10838
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
10820: LD_EXP 9
10824: PPUSH
10825: LD_EXP 3
10829: PUSH
10830: LD_STRING Brown
10832: STR
10833: PPUSH
10834: CALL_OW 38
// if Donaldson in tmp then
10838: LD_EXP 10
10842: PUSH
10843: LD_VAR 0 3
10847: IN
10848: IFFALSE 10868
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
10850: LD_EXP 10
10854: PPUSH
10855: LD_EXP 3
10859: PUSH
10860: LD_STRING Donaldson
10862: STR
10863: PPUSH
10864: CALL_OW 38
// if Bobby in tmp then
10868: LD_EXP 11
10872: PUSH
10873: LD_VAR 0 3
10877: IN
10878: IFFALSE 10898
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10880: LD_EXP 11
10884: PPUSH
10885: LD_EXP 3
10889: PUSH
10890: LD_STRING Bobby
10892: STR
10893: PPUSH
10894: CALL_OW 38
// if Cyrus in tmp then
10898: LD_EXP 12
10902: PUSH
10903: LD_VAR 0 3
10907: IN
10908: IFFALSE 10928
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10910: LD_EXP 12
10914: PPUSH
10915: LD_EXP 3
10919: PUSH
10920: LD_STRING Cyrus
10922: STR
10923: PPUSH
10924: CALL_OW 38
// if Lisa in tmp then
10928: LD_EXP 13
10932: PUSH
10933: LD_VAR 0 3
10937: IN
10938: IFFALSE 10958
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
10940: LD_EXP 13
10944: PPUSH
10945: LD_EXP 3
10949: PUSH
10950: LD_STRING Lisa
10952: STR
10953: PPUSH
10954: CALL_OW 38
// if Frank in tmp then
10958: LD_EXP 14
10962: PUSH
10963: LD_VAR 0 3
10967: IN
10968: IFFALSE 10988
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
10970: LD_EXP 14
10974: PPUSH
10975: LD_EXP 3
10979: PUSH
10980: LD_STRING Frank
10982: STR
10983: PPUSH
10984: CALL_OW 38
// if Gladstone in tmp then
10988: LD_EXP 15
10992: PUSH
10993: LD_VAR 0 3
10997: IN
10998: IFFALSE 11018
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
11000: LD_EXP 15
11004: PPUSH
11005: LD_EXP 3
11009: PUSH
11010: LD_STRING Gladstone
11012: STR
11013: PPUSH
11014: CALL_OW 38
// if Khatam in tmp then
11018: LD_EXP 16
11022: PUSH
11023: LD_VAR 0 3
11027: IN
11028: IFFALSE 11048
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11030: LD_EXP 16
11034: PPUSH
11035: LD_EXP 3
11039: PUSH
11040: LD_STRING Khatam
11042: STR
11043: PPUSH
11044: CALL_OW 38
// if Kikuchi in tmp then
11048: LD_EXP 17
11052: PUSH
11053: LD_VAR 0 3
11057: IN
11058: IFFALSE 11078
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11060: LD_EXP 17
11064: PPUSH
11065: LD_EXP 3
11069: PUSH
11070: LD_STRING Kikuchi
11072: STR
11073: PPUSH
11074: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11078: LD_VAR 0 3
11082: PUSH
11083: LD_EXP 8
11087: PUSH
11088: LD_EXP 9
11092: PUSH
11093: LD_EXP 10
11097: PUSH
11098: LD_EXP 11
11102: PUSH
11103: LD_EXP 12
11107: PUSH
11108: LD_EXP 13
11112: PUSH
11113: LD_EXP 14
11117: PUSH
11118: LD_EXP 15
11122: PUSH
11123: LD_EXP 17
11127: PUSH
11128: LD_EXP 16
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: LIST
11143: LIST
11144: DIFF
11145: PPUSH
11146: LD_EXP 3
11150: PUSH
11151: LD_STRING others
11153: STR
11154: PPUSH
11155: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11159: LD_OWVAR 1
11163: PPUSH
11164: LD_STRING 07_time
11166: PPUSH
11167: CALL_OW 39
// tmp := [ ] ;
11171: LD_ADDR_VAR 0 3
11175: PUSH
11176: EMPTY
11177: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11178: LD_ADDR_VAR 0 2
11182: PUSH
11183: LD_INT 9
11185: PPUSH
11186: LD_INT 22
11188: PUSH
11189: LD_INT 1
11191: PUSH
11192: EMPTY
11193: LIST
11194: LIST
11195: PUSH
11196: LD_INT 23
11198: PUSH
11199: LD_INT 1
11201: PUSH
11202: EMPTY
11203: LIST
11204: LIST
11205: PUSH
11206: LD_INT 21
11208: PUSH
11209: LD_INT 2
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: PPUSH
11224: CALL_OW 70
11228: PUSH
11229: FOR_IN
11230: IFFALSE 11291
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11232: LD_ADDR_VAR 0 3
11236: PUSH
11237: LD_VAR 0 3
11241: PUSH
11242: LD_VAR 0 2
11246: PPUSH
11247: CALL_OW 265
11251: PUSH
11252: LD_VAR 0 2
11256: PPUSH
11257: CALL_OW 262
11261: PUSH
11262: LD_VAR 0 2
11266: PPUSH
11267: CALL_OW 263
11271: PUSH
11272: LD_VAR 0 2
11276: PPUSH
11277: CALL_OW 264
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: ADD
11288: ST_TO_ADDR
11289: GO 11229
11291: POP
11292: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11293: LD_VAR 0 3
11297: PPUSH
11298: LD_STRING 07_vehicles
11300: PPUSH
11301: CALL_OW 39
// YouWin ;
11305: CALL_OW 103
// end ; end_of_file
11309: PPOPN 3
11311: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11312: LD_VAR 0 1
11316: PUSH
11317: LD_EXP 8
11321: EQUAL
11322: IFFALSE 11331
// YouLost ( JMM ) ;
11324: LD_STRING JMM
11326: PPUSH
11327: CALL_OW 104
// if GetType ( un ) = unit_building then
11331: LD_VAR 0 1
11335: PPUSH
11336: CALL_OW 247
11340: PUSH
11341: LD_INT 3
11343: EQUAL
11344: IFFALSE 11360
// buildings_counter := buildings_counter + 1 ;
11346: LD_ADDR_EXP 4
11350: PUSH
11351: LD_EXP 4
11355: PUSH
11356: LD_INT 1
11358: PLUS
11359: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11360: LD_VAR 0 1
11364: PUSH
11365: LD_INT 6
11367: PPUSH
11368: LD_INT 2
11370: PUSH
11371: LD_INT 30
11373: PUSH
11374: LD_INT 33
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PUSH
11381: LD_INT 30
11383: PUSH
11384: LD_INT 32
11386: PUSH
11387: EMPTY
11388: LIST
11389: LIST
11390: PUSH
11391: EMPTY
11392: LIST
11393: LIST
11394: LIST
11395: PPUSH
11396: CALL_OW 70
11400: IN
11401: IFFALSE 11460
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11403: LD_ADDR_EXP 19
11407: PUSH
11408: LD_EXP 19
11412: PUSH
11413: LD_VAR 0 1
11417: PPUSH
11418: CALL_OW 266
11422: PUSH
11423: LD_VAR 0 1
11427: PPUSH
11428: CALL_OW 250
11432: PUSH
11433: LD_VAR 0 1
11437: PPUSH
11438: CALL_OW 251
11442: PUSH
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 254
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: LIST
11457: LIST
11458: ADD
11459: ST_TO_ADDR
// if un = ru_dep_main then
11460: LD_VAR 0 1
11464: PUSH
11465: LD_INT 16
11467: EQUAL
11468: IFFALSE 11477
// ChangeMissionObjectives ( M1a ) ;
11470: LD_STRING M1a
11472: PPUSH
11473: CALL_OW 337
// end ;
11477: PPOPN 1
11479: END
// on BuildingStarted ( b , builder ) do var i ;
11480: LD_INT 0
11482: PPUSH
// begin if GetSide ( b ) = 3 then
11483: LD_VAR 0 1
11487: PPUSH
11488: CALL_OW 255
11492: PUSH
11493: LD_INT 3
11495: EQUAL
11496: IFFALSE 11536
// for i = 1 to 4 do
11498: LD_ADDR_VAR 0 3
11502: PUSH
11503: DOUBLE
11504: LD_INT 1
11506: DEC
11507: ST_TO_ADDR
11508: LD_INT 4
11510: PUSH
11511: FOR_TO
11512: IFFALSE 11534
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11514: LD_ADDR_EXP 19
11518: PUSH
11519: LD_EXP 19
11523: PPUSH
11524: LD_INT 1
11526: PPUSH
11527: CALL_OW 3
11531: ST_TO_ADDR
11532: GO 11511
11534: POP
11535: POP
// end ;
11536: PPOPN 3
11538: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11539: LD_VAR 0 1
11543: PPUSH
11544: CALL_OW 266
11548: PUSH
11549: LD_INT 32
11551: PUSH
11552: LD_INT 33
11554: PUSH
11555: EMPTY
11556: LIST
11557: LIST
11558: IN
11559: IFFALSE 11573
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11561: LD_VAR 0 1
11565: PPUSH
11566: LD_INT 43
11568: PPUSH
11569: CALL_OW 148
11573: PPOPN 1
11575: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11576: LD_VAR 0 1
11580: PUSH
11581: LD_INT 22
11583: PUSH
11584: LD_INT 3
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: LD_INT 2
11593: PUSH
11594: LD_INT 30
11596: PUSH
11597: LD_INT 31
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PUSH
11604: LD_INT 30
11606: PUSH
11607: LD_INT 32
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 69
11627: IN
11628: IFFALSE 11650
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11630: LD_VAR 0 2
11634: PPUSH
11635: LD_VAR 0 1
11639: PPUSH
11640: LD_INT 143
11642: PPUSH
11643: LD_INT 143
11645: PPUSH
11646: CALL 2059 0 4
// end ;
11650: PPOPN 2
11652: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11653: LD_VAR 0 1
11657: PUSH
11658: LD_INT 22
11660: PUSH
11661: LD_INT 3
11663: PUSH
11664: EMPTY
11665: LIST
11666: LIST
11667: PUSH
11668: LD_INT 30
11670: PUSH
11671: LD_INT 32
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: PPUSH
11682: CALL_OW 69
11686: IN
11687: IFFALSE 11701
// SetTag ( b , 0 ) ;
11689: LD_VAR 0 1
11693: PPUSH
11694: LD_INT 0
11696: PPUSH
11697: CALL_OW 109
// end ;
11701: PPOPN 2
11703: END
