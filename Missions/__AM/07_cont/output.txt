// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 44 0 0
// DebugMode ;
  12: CALL 253 0 0
// AnimateTrees ( true ) ;
  16: LD_INT 1
  18: PPUSH
  19: CALL_OW 573
// PrepareNature ;
  23: CALL 3063 0 0
// PrepareRussians ;
  27: CALL 4804 0 0
// PrepareAmericans ;
  31: CALL 3720 0 0
// Action ;
  35: CALL 8684 0 0
// SaveForQuickRestart ;
  39: CALL_OW 22
// end ;
  43: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end , kill_counter ; function Init ; begin
  44: LD_INT 0
  46: PPUSH
// debug := false ;
  47: LD_ADDR_EXP 1
  51: PUSH
  52: LD_INT 0
  54: ST_TO_ADDR
// mission_prefix := 07c_ ;
  55: LD_ADDR_EXP 3
  59: PUSH
  60: LD_STRING 07c_
  62: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  63: LD_ADDR_EXP 2
  67: PUSH
  68: LD_STRING 07_
  70: ST_TO_ADDR
// buildings_counter := 0 ;
  71: LD_ADDR_EXP 4
  75: PUSH
  76: LD_INT 0
  78: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  79: LD_ADDR_EXP 5
  83: PUSH
  84: LD_INT 67200
  86: PUSH
  87: LD_INT 60900
  89: PUSH
  90: LD_INT 54600
  92: PUSH
  93: EMPTY
  94: LIST
  95: LIST
  96: LIST
  97: PUSH
  98: LD_OWVAR 67
 102: ARRAY
 103: PUSH
 104: LD_INT 79800
 106: PUSH
 107: LD_INT 73500
 109: PUSH
 110: LD_INT 67200
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PUSH
 124: LD_INT 92400
 126: PUSH
 127: LD_INT 86100
 129: PUSH
 130: LD_INT 79800
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: PUSH
 138: LD_OWVAR 67
 142: ARRAY
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// can_end := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// must_end := false ;
 157: LD_ADDR_EXP 7
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// kill_counter := 0 ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// end ;
 173: LD_VAR 0 1
 177: RET
// every 0 0$01 trigger not debug do
 178: LD_EXP 1
 182: NOT
 183: IFFALSE 252
 185: GO 187
 187: DISABLE
// begin enable ;
 188: ENABLE
// if not must_end then
 189: LD_EXP 7
 193: NOT
 194: IFFALSE 215
// display_strings := [ #Am07-1 , tick ] else
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: ST_TO_ADDR
 213: GO 252
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 215: LD_ADDR_OWVAR 47
 219: PUSH
 220: LD_STRING #Am07-1
 222: PUSH
 223: LD_OWVAR 1
 227: PUSH
 228: LD_STRING #Am07-2
 230: PUSH
 231: LD_EXP 5
 235: PUSH
 236: LD_INT 3
 238: ARRAY
 239: PUSH
 240: LD_OWVAR 1
 244: MINUS
 245: PUSH
 246: EMPTY
 247: LIST
 248: LIST
 249: LIST
 250: LIST
 251: ST_TO_ADDR
// end ;
 252: END
// function DebugMode ; var i ; begin
 253: LD_INT 0
 255: PPUSH
 256: PPUSH
// if not debug then
 257: LD_EXP 1
 261: NOT
 262: IFFALSE 266
// exit ;
 264: GO 273
// FogOff ( 1 ) ;
 266: LD_INT 1
 268: PPUSH
 269: CALL_OW 344
// end ;
 273: LD_VAR 0 1
 277: RET
// every 3 trigger debug do var i , filter ;
 278: LD_EXP 1
 282: IFFALSE 371
 284: GO 286
 286: DISABLE
 287: LD_INT 0
 289: PPUSH
 290: PPUSH
// begin enable ;
 291: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: LD_INT 22
 299: PUSH
 300: LD_INT 1
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: PUSH
 307: LD_INT 3
 309: PUSH
 310: LD_INT 24
 312: PUSH
 313: LD_INT 500
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: PPUSH
 328: CALL_OW 69
 332: ST_TO_ADDR
// if not filter then
 333: LD_VAR 0 2
 337: NOT
 338: IFFALSE 342
// exit ;
 340: GO 371
// for i in filter do
 342: LD_ADDR_VAR 0 1
 346: PUSH
 347: LD_VAR 0 2
 351: PUSH
 352: FOR_IN
 353: IFFALSE 369
// SetLives ( i , 1000 ) ;
 355: LD_VAR 0 1
 359: PPUSH
 360: LD_INT 1000
 362: PPUSH
 363: CALL_OW 234
 367: GO 352
 369: POP
 370: POP
// end ;
 371: PPOPN 2
 373: END
// every 0 0$1 trigger kill_counter >= 20 do
 374: LD_EXP 8
 378: PUSH
 379: LD_INT 20
 381: GREATEREQUAL
 382: IFFALSE 394
 384: GO 386
 386: DISABLE
// SetAchievement ( ACH_HITMAN ) ;
 387: LD_STRING ACH_HITMAN
 389: PPUSH
 390: CALL_OW 543
 394: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] ] ) >= 3 do
 395: LD_INT 22
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: LD_INT 23
 407: PUSH
 408: LD_INT 3
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: PUSH
 415: LD_INT 21
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: PPUSH
 430: CALL_OW 69
 434: PUSH
 435: LD_INT 3
 437: GREATEREQUAL
 438: IFFALSE 450
 440: GO 442
 442: DISABLE
// SetAchievement ( ACH_TANKACE ) ;
 443: LD_STRING ACH_TANKACE
 445: PPUSH
 446: CALL_OW 543
 450: END
// every 0 0$1 trigger FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) = 0 do
 451: LD_INT 2
 453: PUSH
 454: LD_INT 30
 456: PUSH
 457: LD_INT 0
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: PUSH
 464: LD_INT 30
 466: PUSH
 467: LD_INT 1
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PPUSH
 479: CALL_OW 69
 483: PUSH
 484: LD_INT 0
 486: EQUAL
 487: IFFALSE 499
 489: GO 491
 491: DISABLE
// SetAchievement ( ACH_COMMANDO ) ; end_of_file
 492: LD_STRING ACH_COMMANDO
 494: PPUSH
 495: CALL_OW 543
 499: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// if exist_mode then
 504: LD_VAR 0 2
 508: IFFALSE 533
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_EXP 2
 519: PUSH
 520: LD_VAR 0 1
 524: STR
 525: PPUSH
 526: CALL_OW 34
 530: ST_TO_ADDR
 531: GO 548
// unit := NewCharacter ( ident ) ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_VAR 0 1
 542: PPUSH
 543: CALL_OW 25
 547: ST_TO_ADDR
// result := unit ;
 548: LD_ADDR_VAR 0 3
 552: PUSH
 553: LD_VAR 0 4
 557: ST_TO_ADDR
// end ;
 558: LD_VAR 0 3
 562: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 563: LD_INT 0
 565: PPUSH
// uc_side := side ;
 566: LD_ADDR_OWVAR 20
 570: PUSH
 571: LD_VAR 0 1
 575: ST_TO_ADDR
// uc_nation := nation ;
 576: LD_ADDR_OWVAR 21
 580: PUSH
 581: LD_VAR 0 2
 585: ST_TO_ADDR
// vc_chassis := chassis ;
 586: LD_ADDR_OWVAR 37
 590: PUSH
 591: LD_VAR 0 3
 595: ST_TO_ADDR
// vc_engine := engine ;
 596: LD_ADDR_OWVAR 39
 600: PUSH
 601: LD_VAR 0 4
 605: ST_TO_ADDR
// vc_control := control ;
 606: LD_ADDR_OWVAR 38
 610: PUSH
 611: LD_VAR 0 5
 615: ST_TO_ADDR
// vc_weapon := weapon ;
 616: LD_ADDR_OWVAR 40
 620: PUSH
 621: LD_VAR 0 6
 625: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 626: LD_ADDR_OWVAR 41
 630: PUSH
 631: LD_VAR 0 7
 635: ST_TO_ADDR
// result := CreateVehicle ;
 636: LD_ADDR_VAR 0 8
 640: PUSH
 641: CALL_OW 45
 645: ST_TO_ADDR
// end ;
 646: LD_VAR 0 8
 650: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 651: LD_INT 0
 653: PPUSH
 654: PPUSH
 655: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 656: LD_ADDR_VAR 0 4
 660: PUSH
 661: LD_INT 22
 663: PUSH
 664: LD_INT 1
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: PUSH
 671: LD_INT 21
 673: PUSH
 674: LD_INT 1
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PUSH
 681: LD_INT 50
 683: PUSH
 684: EMPTY
 685: LIST
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL_OW 69
 696: PUSH
 697: LD_EXP 9
 701: PUSH
 702: LD_EXP 10
 706: PUSH
 707: LD_EXP 11
 711: PUSH
 712: LD_EXP 12
 716: PUSH
 717: LD_EXP 13
 721: PUSH
 722: LD_EXP 14
 726: PUSH
 727: LD_EXP 15
 731: PUSH
 732: LD_EXP 16
 736: PUSH
 737: LD_EXP 18
 741: PUSH
 742: LD_EXP 17
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: DIFF
 759: ST_TO_ADDR
// if not filter then
 760: LD_VAR 0 4
 764: NOT
 765: IFFALSE 769
// exit ;
 767: GO 796
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 769: LD_ADDR_VAR 0 2
 773: PUSH
 774: LD_VAR 0 4
 778: PPUSH
 779: LD_INT 26
 781: PUSH
 782: LD_VAR 0 1
 786: PUSH
 787: EMPTY
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL_OW 72
 795: ST_TO_ADDR
// end ;
 796: LD_VAR 0 2
 800: RET
// export function SayX ( units , ident ) ; var i ; begin
 801: LD_INT 0
 803: PPUSH
 804: PPUSH
// result := false ;
 805: LD_ADDR_VAR 0 3
 809: PUSH
 810: LD_INT 0
 812: ST_TO_ADDR
// if not units then
 813: LD_VAR 0 1
 817: NOT
 818: IFFALSE 822
// exit ;
 820: GO 876
// for i in units do
 822: LD_ADDR_VAR 0 4
 826: PUSH
 827: LD_VAR 0 1
 831: PUSH
 832: FOR_IN
 833: IFFALSE 874
// if IsOk ( i ) then
 835: LD_VAR 0 4
 839: PPUSH
 840: CALL_OW 302
 844: IFFALSE 872
// begin Say ( i , ident ) ;
 846: LD_VAR 0 4
 850: PPUSH
 851: LD_VAR 0 2
 855: PPUSH
 856: CALL_OW 88
// result := i ;
 860: LD_ADDR_VAR 0 3
 864: PUSH
 865: LD_VAR 0 4
 869: ST_TO_ADDR
// break ;
 870: GO 874
// end ;
 872: GO 832
 874: POP
 875: POP
// end ;
 876: LD_VAR 0 3
 880: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 881: LD_INT 0
 883: PPUSH
 884: PPUSH
 885: PPUSH
// result := [ ] ;
 886: LD_ADDR_VAR 0 2
 890: PUSH
 891: EMPTY
 892: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 893: LD_ADDR_VAR 0 3
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PPUSH
 908: CALL_OW 69
 912: ST_TO_ADDR
// if not tmp then
 913: LD_VAR 0 3
 917: NOT
 918: IFFALSE 922
// exit ;
 920: GO 972
// for i in tmp do
 922: LD_ADDR_VAR 0 4
 926: PUSH
 927: LD_VAR 0 3
 931: PUSH
 932: FOR_IN
 933: IFFALSE 970
// if GetBase ( i ) = base then
 935: LD_VAR 0 4
 939: PPUSH
 940: CALL_OW 274
 944: PUSH
 945: LD_VAR 0 1
 949: EQUAL
 950: IFFALSE 968
// result := result ^ i ;
 952: LD_ADDR_VAR 0 2
 956: PUSH
 957: LD_VAR 0 2
 961: PUSH
 962: LD_VAR 0 4
 966: ADD
 967: ST_TO_ADDR
 968: GO 932
 970: POP
 971: POP
// end ;
 972: LD_VAR 0 2
 976: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 977: LD_INT 0
 979: PPUSH
 980: PPUSH
 981: PPUSH
 982: PPUSH
 983: PPUSH
 984: PPUSH
 985: PPUSH
 986: PPUSH
 987: PPUSH
 988: PPUSH
 989: PPUSH
 990: PPUSH
 991: PPUSH
 992: PPUSH
 993: PPUSH
 994: PPUSH
// result := false ;
 995: LD_ADDR_VAR 0 2
 999: PUSH
1000: LD_INT 0
1002: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
1003: LD_VAR 0 1
1007: NOT
1008: PUSH
1009: LD_VAR 0 1
1013: PPUSH
1014: CALL_OW 266
1018: PUSH
1019: LD_INT 32
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: IN
1029: NOT
1030: OR
1031: IFFALSE 1035
// exit ;
1033: GO 2195
// nat := GetNation ( tower ) ;
1035: LD_ADDR_VAR 0 11
1039: PUSH
1040: LD_VAR 0 1
1044: PPUSH
1045: CALL_OW 248
1049: ST_TO_ADDR
// side := GetSide ( tower ) ;
1050: LD_ADDR_VAR 0 15
1054: PUSH
1055: LD_VAR 0 1
1059: PPUSH
1060: CALL_OW 255
1064: ST_TO_ADDR
// x := GetX ( tower ) ;
1065: LD_ADDR_VAR 0 9
1069: PUSH
1070: LD_VAR 0 1
1074: PPUSH
1075: CALL_OW 250
1079: ST_TO_ADDR
// y := GetY ( tower ) ;
1080: LD_ADDR_VAR 0 10
1084: PUSH
1085: LD_VAR 0 1
1089: PPUSH
1090: CALL_OW 251
1094: ST_TO_ADDR
// if not x or not y then
1095: LD_VAR 0 9
1099: NOT
1100: PUSH
1101: LD_VAR 0 10
1105: NOT
1106: OR
1107: IFFALSE 1111
// exit ;
1109: GO 2195
// weapon := 0 ;
1111: LD_ADDR_VAR 0 17
1115: PUSH
1116: LD_INT 0
1118: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
1119: LD_ADDR_VAR 0 16
1123: PUSH
1124: LD_INT 42
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 44
1132: PUSH
1133: LD_INT 46
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: ST_TO_ADDR
// if not fac_list then
1142: LD_VAR 0 16
1146: NOT
1147: IFFALSE 1151
// exit ;
1149: GO 2195
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1151: LD_ADDR_VAR 0 4
1155: PUSH
1156: LD_INT 4
1158: PUSH
1159: LD_INT 5
1161: PUSH
1162: LD_INT 9
1164: PUSH
1165: LD_INT 10
1167: PUSH
1168: LD_INT 6
1170: PUSH
1171: LD_INT 7
1173: PUSH
1174: LD_INT 11
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 28
1191: PUSH
1192: LD_INT 26
1194: PUSH
1195: LD_INT 30
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 43
1206: PUSH
1207: LD_INT 44
1209: PUSH
1210: LD_INT 46
1212: PUSH
1213: LD_INT 45
1215: PUSH
1216: LD_INT 47
1218: PUSH
1219: LD_INT 49
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: PUSH
1235: LD_VAR 0 11
1239: ARRAY
1240: ST_TO_ADDR
// for i in list do
1241: LD_ADDR_VAR 0 7
1245: PUSH
1246: LD_VAR 0 4
1250: PUSH
1251: FOR_IN
1252: IFFALSE 1285
// if not i in fac_list then
1254: LD_VAR 0 7
1258: PUSH
1259: LD_VAR 0 16
1263: IN
1264: NOT
1265: IFFALSE 1283
// list := list diff i ;
1267: LD_ADDR_VAR 0 4
1271: PUSH
1272: LD_VAR 0 4
1276: PUSH
1277: LD_VAR 0 7
1281: DIFF
1282: ST_TO_ADDR
1283: GO 1251
1285: POP
1286: POP
// if not list then
1287: LD_VAR 0 4
1291: NOT
1292: IFFALSE 1296
// exit ;
1294: GO 2195
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1296: LD_VAR 0 11
1300: PUSH
1301: LD_INT 3
1303: EQUAL
1304: PUSH
1305: LD_INT 49
1307: PUSH
1308: LD_VAR 0 4
1312: IN
1313: AND
1314: PUSH
1315: LD_INT 31
1317: PPUSH
1318: LD_VAR 0 15
1322: PPUSH
1323: CALL_OW 321
1327: PUSH
1328: LD_INT 2
1330: EQUAL
1331: AND
1332: IFFALSE 1392
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1334: LD_INT 22
1336: PUSH
1337: LD_VAR 0 15
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 35
1348: PUSH
1349: LD_INT 49
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: PUSH
1356: LD_INT 91
1358: PUSH
1359: LD_VAR 0 1
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL_OW 69
1381: NOT
1382: IFFALSE 1392
// weapon := ru_time_lapser ;
1384: LD_ADDR_VAR 0 17
1388: PUSH
1389: LD_INT 49
1391: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1392: LD_VAR 0 11
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 2
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: IN
1407: PUSH
1408: LD_INT 11
1410: PUSH
1411: LD_VAR 0 4
1415: IN
1416: PUSH
1417: LD_INT 30
1419: PUSH
1420: LD_VAR 0 4
1424: IN
1425: OR
1426: AND
1427: PUSH
1428: LD_INT 6
1430: PPUSH
1431: LD_VAR 0 15
1435: PPUSH
1436: CALL_OW 321
1440: PUSH
1441: LD_INT 2
1443: EQUAL
1444: AND
1445: IFFALSE 1610
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1447: LD_INT 22
1449: PUSH
1450: LD_VAR 0 15
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: LD_INT 2
1461: PUSH
1462: LD_INT 35
1464: PUSH
1465: LD_INT 11
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 35
1474: PUSH
1475: LD_INT 30
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: PUSH
1487: LD_INT 91
1489: PUSH
1490: LD_VAR 0 1
1494: PUSH
1495: LD_INT 18
1497: PUSH
1498: EMPTY
1499: LIST
1500: LIST
1501: LIST
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: PPUSH
1508: CALL_OW 69
1512: NOT
1513: PUSH
1514: LD_INT 22
1516: PUSH
1517: LD_VAR 0 15
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: LD_INT 2
1528: PUSH
1529: LD_INT 30
1531: PUSH
1532: LD_INT 32
1534: PUSH
1535: EMPTY
1536: LIST
1537: LIST
1538: PUSH
1539: LD_INT 30
1541: PUSH
1542: LD_INT 33
1544: PUSH
1545: EMPTY
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: PUSH
1554: LD_INT 91
1556: PUSH
1557: LD_VAR 0 1
1561: PUSH
1562: LD_INT 12
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: LIST
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: EMPTY
1576: LIST
1577: PPUSH
1578: CALL_OW 69
1582: PUSH
1583: LD_INT 2
1585: GREATER
1586: AND
1587: IFFALSE 1610
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1589: LD_ADDR_VAR 0 17
1593: PUSH
1594: LD_INT 11
1596: PUSH
1597: LD_INT 30
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: LD_VAR 0 11
1608: ARRAY
1609: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1610: LD_VAR 0 17
1614: NOT
1615: PUSH
1616: LD_INT 40
1618: PPUSH
1619: LD_VAR 0 15
1623: PPUSH
1624: CALL_OW 321
1628: PUSH
1629: LD_INT 2
1631: EQUAL
1632: AND
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_VAR 0 4
1641: IN
1642: PUSH
1643: LD_INT 28
1645: PUSH
1646: LD_VAR 0 4
1650: IN
1651: OR
1652: PUSH
1653: LD_INT 45
1655: PUSH
1656: LD_VAR 0 4
1660: IN
1661: OR
1662: AND
1663: IFFALSE 1917
// begin hex := GetHexInfo ( x , y ) ;
1665: LD_ADDR_VAR 0 3
1669: PUSH
1670: LD_VAR 0 9
1674: PPUSH
1675: LD_VAR 0 10
1679: PPUSH
1680: CALL_OW 546
1684: ST_TO_ADDR
// if hex [ 1 ] then
1685: LD_VAR 0 3
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: IFFALSE 1697
// exit ;
1695: GO 2195
// height := hex [ 2 ] ;
1697: LD_ADDR_VAR 0 14
1701: PUSH
1702: LD_VAR 0 3
1706: PUSH
1707: LD_INT 2
1709: ARRAY
1710: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1711: LD_ADDR_VAR 0 13
1715: PUSH
1716: LD_INT 0
1718: PUSH
1719: LD_INT 2
1721: PUSH
1722: LD_INT 3
1724: PUSH
1725: LD_INT 5
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: ST_TO_ADDR
// for i in tmp do
1734: LD_ADDR_VAR 0 7
1738: PUSH
1739: LD_VAR 0 13
1743: PUSH
1744: FOR_IN
1745: IFFALSE 1915
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1747: LD_ADDR_VAR 0 8
1751: PUSH
1752: LD_VAR 0 9
1756: PPUSH
1757: LD_VAR 0 7
1761: PPUSH
1762: LD_INT 5
1764: PPUSH
1765: CALL_OW 272
1769: PUSH
1770: LD_VAR 0 10
1774: PPUSH
1775: LD_VAR 0 7
1779: PPUSH
1780: LD_INT 5
1782: PPUSH
1783: CALL_OW 273
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1792: LD_VAR 0 8
1796: PUSH
1797: LD_INT 1
1799: ARRAY
1800: PPUSH
1801: LD_VAR 0 8
1805: PUSH
1806: LD_INT 2
1808: ARRAY
1809: PPUSH
1810: CALL_OW 488
1814: IFFALSE 1913
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1816: LD_ADDR_VAR 0 3
1820: PUSH
1821: LD_VAR 0 8
1825: PUSH
1826: LD_INT 1
1828: ARRAY
1829: PPUSH
1830: LD_VAR 0 8
1834: PUSH
1835: LD_INT 2
1837: ARRAY
1838: PPUSH
1839: CALL_OW 546
1843: ST_TO_ADDR
// if hex [ 1 ] then
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: IFFALSE 1856
// continue ;
1854: GO 1744
// h := hex [ 2 ] ;
1856: LD_ADDR_VAR 0 12
1860: PUSH
1861: LD_VAR 0 3
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: ST_TO_ADDR
// if h + 7 < height then
1870: LD_VAR 0 12
1874: PUSH
1875: LD_INT 7
1877: PLUS
1878: PUSH
1879: LD_VAR 0 14
1883: LESS
1884: IFFALSE 1913
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1886: LD_ADDR_VAR 0 17
1890: PUSH
1891: LD_INT 7
1893: PUSH
1894: LD_INT 28
1896: PUSH
1897: LD_INT 45
1899: PUSH
1900: EMPTY
1901: LIST
1902: LIST
1903: LIST
1904: PUSH
1905: LD_VAR 0 11
1909: ARRAY
1910: ST_TO_ADDR
// break ;
1911: GO 1915
// end ; end ; end ;
1913: GO 1744
1915: POP
1916: POP
// end ; if not weapon then
1917: LD_VAR 0 17
1921: NOT
1922: IFFALSE 2077
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1924: LD_ADDR_VAR 0 4
1928: PUSH
1929: LD_VAR 0 4
1933: PUSH
1934: LD_INT 11
1936: PUSH
1937: LD_INT 30
1939: PUSH
1940: LD_INT 49
1942: PUSH
1943: EMPTY
1944: LIST
1945: LIST
1946: LIST
1947: DIFF
1948: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1949: LD_ADDR_VAR 0 13
1953: PUSH
1954: LD_INT 22
1956: PUSH
1957: LD_VAR 0 15
1961: PUSH
1962: EMPTY
1963: LIST
1964: LIST
1965: PUSH
1966: LD_INT 91
1968: PUSH
1969: LD_VAR 0 1
1973: PUSH
1974: LD_INT 6
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 3
1984: PUSH
1985: LD_INT 35
1987: PUSH
1988: LD_INT 0
1990: PUSH
1991: EMPTY
1992: LIST
1993: LIST
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: LIST
2003: PPUSH
2004: CALL_OW 69
2008: ST_TO_ADDR
// for i in tmp do
2009: LD_ADDR_VAR 0 7
2013: PUSH
2014: LD_VAR 0 13
2018: PUSH
2019: FOR_IN
2020: IFFALSE 2045
// list := list diff GetBWeapon ( i ) ;
2022: LD_ADDR_VAR 0 4
2026: PUSH
2027: LD_VAR 0 4
2031: PUSH
2032: LD_VAR 0 7
2036: PPUSH
2037: CALL_OW 269
2041: DIFF
2042: ST_TO_ADDR
2043: GO 2019
2045: POP
2046: POP
// if list then
2047: LD_VAR 0 4
2051: IFFALSE 2077
// weapon := list [ rand ( 1 , list ) ] ;
2053: LD_ADDR_VAR 0 17
2057: PUSH
2058: LD_VAR 0 4
2062: PUSH
2063: LD_INT 1
2065: PPUSH
2066: LD_VAR 0 4
2070: PPUSH
2071: CALL_OW 12
2075: ARRAY
2076: ST_TO_ADDR
// end ; if weapon then
2077: LD_VAR 0 17
2081: IFFALSE 2195
// begin tmp := CostOfWeapon ( weapon ) ;
2083: LD_ADDR_VAR 0 13
2087: PUSH
2088: LD_VAR 0 17
2092: PPUSH
2093: CALL_OW 451
2097: ST_TO_ADDR
// j := GetBase ( tower ) ;
2098: LD_ADDR_VAR 0 8
2102: PUSH
2103: LD_VAR 0 1
2107: PPUSH
2108: CALL_OW 274
2112: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
2113: LD_VAR 0 8
2117: PPUSH
2118: LD_INT 1
2120: PPUSH
2121: CALL_OW 275
2125: PUSH
2126: LD_VAR 0 13
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: GREATEREQUAL
2135: PUSH
2136: LD_VAR 0 8
2140: PPUSH
2141: LD_INT 2
2143: PPUSH
2144: CALL_OW 275
2148: PUSH
2149: LD_VAR 0 13
2153: PUSH
2154: LD_INT 2
2156: ARRAY
2157: GREATEREQUAL
2158: AND
2159: PUSH
2160: LD_VAR 0 8
2164: PPUSH
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 275
2172: PUSH
2173: LD_VAR 0 13
2177: PUSH
2178: LD_INT 3
2180: ARRAY
2181: GREATEREQUAL
2182: AND
2183: IFFALSE 2195
// result := weapon ;
2185: LD_ADDR_VAR 0 2
2189: PUSH
2190: LD_VAR 0 17
2194: ST_TO_ADDR
// end ; end ;
2195: LD_VAR 0 2
2199: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2200: LD_INT 0
2202: PPUSH
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
// if not un or not IsOk ( un ) then
2207: LD_VAR 0 1
2211: NOT
2212: PUSH
2213: LD_VAR 0 1
2217: PPUSH
2218: CALL_OW 302
2222: NOT
2223: OR
2224: IFFALSE 2228
// exit ;
2226: GO 2668
// side := GetSide ( un ) ;
2228: LD_ADDR_VAR 0 9
2232: PUSH
2233: LD_VAR 0 1
2237: PPUSH
2238: CALL_OW 255
2242: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2243: LD_ADDR_VAR 0 7
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: LD_VAR 0 9
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: PUSH
2260: LD_INT 30
2262: PUSH
2263: LD_INT 32
2265: PUSH
2266: EMPTY
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 50
2272: PUSH
2273: EMPTY
2274: LIST
2275: PUSH
2276: LD_INT 58
2278: PUSH
2279: EMPTY
2280: LIST
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: PPUSH
2288: CALL_OW 69
2292: PUSH
2293: LD_VAR 0 2
2297: DIFF
2298: ST_TO_ADDR
// if not filter then
2299: LD_VAR 0 7
2303: NOT
2304: IFFALSE 2533
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2306: LD_ADDR_VAR 0 7
2310: PUSH
2311: LD_INT 22
2313: PUSH
2314: LD_VAR 0 9
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: LD_INT 30
2325: PUSH
2326: LD_INT 5
2328: PUSH
2329: EMPTY
2330: LIST
2331: LIST
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: PPUSH
2337: CALL_OW 69
2341: ST_TO_ADDR
// if debug then
2342: LD_EXP 1
2346: IFFALSE 2365
// display_strings := [ filter , 1 ] ;
2348: LD_ADDR_OWVAR 47
2352: PUSH
2353: LD_VAR 0 7
2357: PUSH
2358: LD_STRING 1
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: ST_TO_ADDR
// if not filter then
2365: LD_VAR 0 7
2369: NOT
2370: IFFALSE 2393
// begin ComMoveXY ( un , x , y ) ;
2372: LD_VAR 0 1
2376: PPUSH
2377: LD_VAR 0 3
2381: PPUSH
2382: LD_VAR 0 4
2386: PPUSH
2387: CALL_OW 111
// exit ;
2391: GO 2668
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2393: LD_ADDR_VAR 0 8
2397: PUSH
2398: LD_VAR 0 7
2402: PPUSH
2403: LD_VAR 0 1
2407: PPUSH
2408: CALL_OW 74
2412: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2413: LD_VAR 0 8
2417: PPUSH
2418: CALL_OW 313
2422: PUSH
2423: LD_INT 6
2425: EQUAL
2426: IFFALSE 2446
// filter := filter diff t else
2428: LD_ADDR_VAR 0 7
2432: PUSH
2433: LD_VAR 0 7
2437: PUSH
2438: LD_VAR 0 8
2442: DIFF
2443: ST_TO_ADDR
2444: GO 2448
// break ;
2446: GO 2470
// until UnitsInside ( t ) < 6 or not filter ;
2448: LD_VAR 0 8
2452: PPUSH
2453: CALL_OW 313
2457: PUSH
2458: LD_INT 6
2460: LESS
2461: PUSH
2462: LD_VAR 0 7
2466: NOT
2467: OR
2468: IFFALSE 2393
// display_strings := [ filter , t ] ;
2470: LD_ADDR_OWVAR 47
2474: PUSH
2475: LD_VAR 0 7
2479: PUSH
2480: LD_VAR 0 8
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: ST_TO_ADDR
// if not filter then
2489: LD_VAR 0 7
2493: NOT
2494: IFFALSE 2517
// ComMoveXY ( un , x , y ) else
2496: LD_VAR 0 1
2500: PPUSH
2501: LD_VAR 0 3
2505: PPUSH
2506: LD_VAR 0 4
2510: PPUSH
2511: CALL_OW 111
2515: GO 2531
// ComEnterUnit ( un , t ) ;
2517: LD_VAR 0 1
2521: PPUSH
2522: LD_VAR 0 8
2526: PPUSH
2527: CALL_OW 120
// end else
2531: GO 2668
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2533: LD_ADDR_VAR 0 8
2537: PUSH
2538: LD_VAR 0 7
2542: PPUSH
2543: LD_VAR 0 1
2547: PPUSH
2548: CALL_OW 74
2552: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2553: LD_VAR 0 8
2557: PPUSH
2558: CALL_OW 110
2562: PUSH
2563: LD_INT 7
2565: EQUAL
2566: IFFALSE 2584
// filter := filter diff t ;
2568: LD_ADDR_VAR 0 7
2572: PUSH
2573: LD_VAR 0 7
2577: PUSH
2578: LD_VAR 0 8
2582: DIFF
2583: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2584: LD_VAR 0 8
2588: PPUSH
2589: CALL_OW 110
2593: PUSH
2594: LD_INT 7
2596: NONEQUAL
2597: PUSH
2598: LD_VAR 0 7
2602: NOT
2603: OR
2604: IFFALSE 2533
// if GetTag ( t ) <> 7 then
2606: LD_VAR 0 8
2610: PPUSH
2611: CALL_OW 110
2615: PUSH
2616: LD_INT 7
2618: NONEQUAL
2619: IFFALSE 2649
// begin SetTag ( t , 7 ) ;
2621: LD_VAR 0 8
2625: PPUSH
2626: LD_INT 7
2628: PPUSH
2629: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2633: LD_VAR 0 1
2637: PPUSH
2638: LD_VAR 0 8
2642: PPUSH
2643: CALL_OW 120
// end else
2647: GO 2668
// ComMoveXY ( un , x , y ) ;
2649: LD_VAR 0 1
2653: PPUSH
2654: LD_VAR 0 3
2658: PPUSH
2659: LD_VAR 0 4
2663: PPUSH
2664: CALL_OW 111
// end ; end ;
2668: LD_VAR 0 5
2672: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2673: LD_INT 0
2675: PPUSH
2676: PPUSH
2677: PPUSH
// if not base then
2678: LD_VAR 0 1
2682: NOT
2683: IFFALSE 2687
// exit ;
2685: GO 2745
// tmp := GetEnergy ( GetBase ( base ) ) ;
2687: LD_ADDR_VAR 0 4
2691: PUSH
2692: LD_VAR 0 1
2696: PPUSH
2697: CALL_OW 274
2701: PPUSH
2702: CALL_OW 278
2706: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2707: LD_VAR 0 4
2711: PUSH
2712: LD_INT 1
2714: ARRAY
2715: PUSH
2716: LD_VAR 0 4
2720: PUSH
2721: LD_INT 4
2723: ARRAY
2724: GREATER
2725: IFFALSE 2737
// result := true else
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
2735: GO 2745
// result := false ;
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 0
2744: ST_TO_ADDR
// end ;
2745: LD_VAR 0 2
2749: RET
// export function FilterPeople ( side ) ; begin
2750: LD_INT 0
2752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2753: LD_ADDR_VAR 0 2
2757: PUSH
2758: LD_INT 22
2760: PUSH
2761: LD_VAR 0 1
2765: PUSH
2766: EMPTY
2767: LIST
2768: LIST
2769: PUSH
2770: LD_INT 21
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: PPUSH
2784: CALL_OW 69
2788: ST_TO_ADDR
// end ;
2789: LD_VAR 0 2
2793: RET
// export function FilterDrivers ( side ) ; begin
2794: LD_INT 0
2796: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2797: LD_ADDR_VAR 0 2
2801: PUSH
2802: LD_INT 22
2804: PUSH
2805: LD_VAR 0 1
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: LD_INT 3
2816: PUSH
2817: LD_INT 56
2819: PUSH
2820: EMPTY
2821: LIST
2822: PUSH
2823: EMPTY
2824: LIST
2825: LIST
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// end ;
2836: LD_VAR 0 2
2840: RET
// export function FilterPeopleArea ( side , area ) ; begin
2841: LD_INT 0
2843: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2844: LD_ADDR_VAR 0 3
2848: PUSH
2849: LD_VAR 0 2
2853: PPUSH
2854: LD_INT 22
2856: PUSH
2857: LD_INT 1
2859: PUSH
2860: EMPTY
2861: LIST
2862: LIST
2863: PUSH
2864: LD_INT 21
2866: PUSH
2867: LD_INT 1
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: PUSH
2874: EMPTY
2875: LIST
2876: LIST
2877: PPUSH
2878: CALL_OW 70
2882: ST_TO_ADDR
// end ;
2883: LD_VAR 0 3
2887: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2888: LD_INT 0
2890: PPUSH
2891: PPUSH
2892: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2893: LD_ADDR_VAR 0 5
2897: PUSH
2898: LD_VAR 0 2
2902: PPUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 1
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_INT 21
2915: PUSH
2916: LD_INT 2
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PUSH
2923: LD_INT 3
2925: PUSH
2926: LD_INT 58
2928: PUSH
2929: EMPTY
2930: LIST
2931: PUSH
2932: EMPTY
2933: LIST
2934: LIST
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 70
2945: ST_TO_ADDR
// result := [ ] ;
2946: LD_ADDR_VAR 0 3
2950: PUSH
2951: EMPTY
2952: ST_TO_ADDR
// if not tmp then
2953: LD_VAR 0 5
2957: NOT
2958: IFFALSE 2962
// exit ;
2960: GO 3014
// for i in tmp do
2962: LD_ADDR_VAR 0 4
2966: PUSH
2967: LD_VAR 0 5
2971: PUSH
2972: FOR_IN
2973: IFFALSE 2998
// result := result union IsDrivenBy ( i ) ;
2975: LD_ADDR_VAR 0 3
2979: PUSH
2980: LD_VAR 0 3
2984: PUSH
2985: LD_VAR 0 4
2989: PPUSH
2990: CALL_OW 311
2994: UNION
2995: ST_TO_ADDR
2996: GO 2972
2998: POP
2999: POP
// result := result diff 0 ;
3000: LD_ADDR_VAR 0 3
3004: PUSH
3005: LD_VAR 0 3
3009: PUSH
3010: LD_INT 0
3012: DIFF
3013: ST_TO_ADDR
// end ;
3014: LD_VAR 0 3
3018: RET
// export function FilterBuildings ( side ) ; begin
3019: LD_INT 0
3021: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_INT 22
3029: PUSH
3030: LD_VAR 0 1
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: PUSH
3039: LD_INT 21
3041: PUSH
3042: LD_INT 3
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: PUSH
3049: EMPTY
3050: LIST
3051: LIST
3052: PPUSH
3053: CALL_OW 69
3057: ST_TO_ADDR
// end ;
3058: LD_VAR 0 2
3062: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
3063: LD_INT 0
3065: PPUSH
3066: PPUSH
3067: PPUSH
3068: PPUSH
// uc_side = 0 ;
3069: LD_ADDR_OWVAR 20
3073: PUSH
3074: LD_INT 0
3076: ST_TO_ADDR
// uc_nation = 0 ;
3077: LD_ADDR_OWVAR 21
3081: PUSH
3082: LD_INT 0
3084: ST_TO_ADDR
// nat_area := wildArea ;
3085: LD_ADDR_VAR 0 4
3089: PUSH
3090: LD_INT 3
3092: ST_TO_ADDR
// InitHc ;
3093: CALL_OW 19
// for i = 1 to 4 do
3097: LD_ADDR_VAR 0 2
3101: PUSH
3102: DOUBLE
3103: LD_INT 1
3105: DEC
3106: ST_TO_ADDR
3107: LD_INT 4
3109: PUSH
3110: FOR_TO
3111: IFFALSE 3166
// begin hc_class = 18 ;
3113: LD_ADDR_OWVAR 28
3117: PUSH
3118: LD_INT 18
3120: ST_TO_ADDR
// hc_gallery =  ;
3121: LD_ADDR_OWVAR 33
3125: PUSH
3126: LD_STRING 
3128: ST_TO_ADDR
// hc_face_number = 1 ;
3129: LD_ADDR_OWVAR 34
3133: PUSH
3134: LD_INT 1
3136: ST_TO_ADDR
// animal := CreateHuman ;
3137: LD_ADDR_VAR 0 3
3141: PUSH
3142: CALL_OW 44
3146: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3147: LD_VAR 0 3
3151: PPUSH
3152: LD_VAR 0 4
3156: PPUSH
3157: LD_INT 0
3159: PPUSH
3160: CALL_OW 49
// end ;
3164: GO 3110
3166: POP
3167: POP
// for i = 1 to 6 do
3168: LD_ADDR_VAR 0 2
3172: PUSH
3173: DOUBLE
3174: LD_INT 1
3176: DEC
3177: ST_TO_ADDR
3178: LD_INT 6
3180: PUSH
3181: FOR_TO
3182: IFFALSE 3253
// begin hc_class = class_tiger ;
3184: LD_ADDR_OWVAR 28
3188: PUSH
3189: LD_INT 14
3191: ST_TO_ADDR
// hc_gallery =  ;
3192: LD_ADDR_OWVAR 33
3196: PUSH
3197: LD_STRING 
3199: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3200: LD_ADDR_OWVAR 35
3204: PUSH
3205: LD_INT 0
3207: PPUSH
3208: LD_INT 10
3210: PPUSH
3211: CALL_OW 12
3215: ST_TO_ADDR
// hc_face_number = 3 ;
3216: LD_ADDR_OWVAR 34
3220: PUSH
3221: LD_INT 3
3223: ST_TO_ADDR
// animal := CreateHuman ;
3224: LD_ADDR_VAR 0 3
3228: PUSH
3229: CALL_OW 44
3233: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3234: LD_VAR 0 3
3238: PPUSH
3239: LD_VAR 0 4
3243: PPUSH
3244: LD_INT 0
3246: PPUSH
3247: CALL_OW 49
// end ;
3251: GO 3181
3253: POP
3254: POP
// for i = 1 to 2 do
3255: LD_ADDR_VAR 0 2
3259: PUSH
3260: DOUBLE
3261: LD_INT 1
3263: DEC
3264: ST_TO_ADDR
3265: LD_INT 2
3267: PUSH
3268: FOR_TO
3269: IFFALSE 3332
// begin hc_class = 21 ;
3271: LD_ADDR_OWVAR 28
3275: PUSH
3276: LD_INT 21
3278: ST_TO_ADDR
// hc_gallery =  ;
3279: LD_ADDR_OWVAR 33
3283: PUSH
3284: LD_STRING 
3286: ST_TO_ADDR
// hc_agressivity = 0 ;
3287: LD_ADDR_OWVAR 35
3291: PUSH
3292: LD_INT 0
3294: ST_TO_ADDR
// hc_face_number = 5 ;
3295: LD_ADDR_OWVAR 34
3299: PUSH
3300: LD_INT 5
3302: ST_TO_ADDR
// animal := CreateHuman ;
3303: LD_ADDR_VAR 0 3
3307: PUSH
3308: CALL_OW 44
3312: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3313: LD_VAR 0 3
3317: PPUSH
3318: LD_VAR 0 4
3322: PPUSH
3323: LD_INT 0
3325: PPUSH
3326: CALL_OW 49
// end ;
3330: GO 3268
3332: POP
3333: POP
// for i = 1 to 6 do
3334: LD_ADDR_VAR 0 2
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 6
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3403
// begin hc_class = 13 ;
3350: LD_ADDR_OWVAR 28
3354: PUSH
3355: LD_INT 13
3357: ST_TO_ADDR
// hc_gallery =  ;
3358: LD_ADDR_OWVAR 33
3362: PUSH
3363: LD_STRING 
3365: ST_TO_ADDR
// hc_face_number = 4 ;
3366: LD_ADDR_OWVAR 34
3370: PUSH
3371: LD_INT 4
3373: ST_TO_ADDR
// animal := CreateHuman ;
3374: LD_ADDR_VAR 0 3
3378: PUSH
3379: CALL_OW 44
3383: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3384: LD_VAR 0 3
3388: PPUSH
3389: LD_VAR 0 4
3393: PPUSH
3394: LD_INT 0
3396: PPUSH
3397: CALL_OW 49
// end ;
3401: GO 3347
3403: POP
3404: POP
// for i = 1 to 2 do
3405: LD_ADDR_VAR 0 2
3409: PUSH
3410: DOUBLE
3411: LD_INT 1
3413: DEC
3414: ST_TO_ADDR
3415: LD_INT 2
3417: PUSH
3418: FOR_TO
3419: IFFALSE 3478
// begin hc_class = 20 ;
3421: LD_ADDR_OWVAR 28
3425: PUSH
3426: LD_INT 20
3428: ST_TO_ADDR
// hc_gallery =  ;
3429: LD_ADDR_OWVAR 33
3433: PUSH
3434: LD_STRING 
3436: ST_TO_ADDR
// hc_face_number = 2 ;
3437: LD_ADDR_OWVAR 34
3441: PUSH
3442: LD_INT 2
3444: ST_TO_ADDR
// animal := CreateHuman ;
3445: LD_ADDR_VAR 0 3
3449: PUSH
3450: CALL_OW 44
3454: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3455: LD_VAR 0 3
3459: PPUSH
3460: LD_INT 101
3462: PPUSH
3463: LD_INT 37
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 0
3471: PPUSH
3472: CALL_OW 50
// end ;
3476: GO 3418
3478: POP
3479: POP
// for i = 1 to 1 do
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_INT 1
3492: PUSH
3493: FOR_TO
3494: IFFALSE 3541
// begin vc_chassis := 31 ;
3496: LD_ADDR_OWVAR 37
3500: PUSH
3501: LD_INT 31
3503: ST_TO_ADDR
// vc_control := control_rider ;
3504: LD_ADDR_OWVAR 38
3508: PUSH
3509: LD_INT 4
3511: ST_TO_ADDR
// animal := CreateVehicle ;
3512: LD_ADDR_VAR 0 3
3516: PUSH
3517: CALL_OW 45
3521: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3522: LD_VAR 0 3
3526: PPUSH
3527: LD_VAR 0 4
3531: PPUSH
3532: LD_INT 0
3534: PPUSH
3535: CALL_OW 49
// end ;
3539: GO 3493
3541: POP
3542: POP
// end ;
3543: LD_VAR 0 1
3547: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3548: LD_INT 0
3550: PPUSH
3551: PPUSH
3552: PPUSH
3553: PPUSH
// result := [ ] ;
3554: LD_ADDR_VAR 0 2
3558: PUSH
3559: EMPTY
3560: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3561: LD_ADDR_VAR 0 4
3565: PUSH
3566: LD_INT 81
3568: PUSH
3569: LD_VAR 0 1
3573: PPUSH
3574: CALL_OW 255
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PUSH
3583: LD_INT 91
3585: PUSH
3586: LD_VAR 0 1
3590: PUSH
3591: LD_INT 15
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: LIST
3598: PUSH
3599: LD_INT 2
3601: PUSH
3602: LD_INT 30
3604: PUSH
3605: LD_INT 32
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: LD_INT 30
3614: PUSH
3615: LD_INT 33
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: LIST
3626: PUSH
3627: EMPTY
3628: LIST
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 69
3636: ST_TO_ADDR
// if not tmp then
3637: LD_VAR 0 4
3641: NOT
3642: IFFALSE 3646
// exit ;
3644: GO 3715
// for i in tmp do
3646: LD_ADDR_VAR 0 3
3650: PUSH
3651: LD_VAR 0 4
3655: PUSH
3656: FOR_IN
3657: IFFALSE 3713
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3659: LD_ADDR_VAR 0 5
3663: PUSH
3664: LD_VAR 0 3
3668: PPUSH
3669: CALL_OW 274
3673: PPUSH
3674: CALL_OW 278
3678: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3679: LD_VAR 0 5
3683: PUSH
3684: LD_INT 4
3686: ARRAY
3687: PUSH
3688: LD_VAR 0 5
3692: PUSH
3693: LD_INT 1
3695: ARRAY
3696: GREATER
3697: IFFALSE 3711
// begin result := i ;
3699: LD_ADDR_VAR 0 2
3703: PUSH
3704: LD_VAR 0 3
3708: ST_TO_ADDR
// break ;
3709: GO 3713
// end ; end ;
3711: GO 3656
3713: POP
3714: POP
// end ; end_of_file
3715: LD_VAR 0 2
3719: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
3724: PPUSH
3725: PPUSH
3726: PPUSH
3727: PPUSH
// uc_side := 1 ;
3728: LD_ADDR_OWVAR 20
3732: PUSH
3733: LD_INT 1
3735: ST_TO_ADDR
// uc_nation := 1 ;
3736: LD_ADDR_OWVAR 21
3740: PUSH
3741: LD_INT 1
3743: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3744: LD_ADDR_EXP 9
3748: PUSH
3749: LD_STRING JMM
3751: PPUSH
3752: LD_EXP 1
3756: NOT
3757: PPUSH
3758: CALL 500 0 2
3762: ST_TO_ADDR
// team := [ JMM ] ;
3763: LD_ADDR_VAR 0 3
3767: PUSH
3768: LD_EXP 9
3772: PUSH
3773: EMPTY
3774: LIST
3775: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3776: LD_STRING BrownIn07
3778: PPUSH
3779: LD_EXP 1
3783: PPUSH
3784: CALL_OW 30
3788: IFFALSE 3809
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3790: LD_ADDR_EXP 10
3794: PUSH
3795: LD_STRING Brown
3797: PPUSH
3798: LD_EXP 1
3802: NOT
3803: PPUSH
3804: CALL 500 0 2
3808: ST_TO_ADDR
// if Brown then
3809: LD_EXP 10
3813: IFFALSE 3831
// team := team ^ Brown ;
3815: LD_ADDR_VAR 0 3
3819: PUSH
3820: LD_VAR 0 3
3824: PUSH
3825: LD_EXP 10
3829: ADD
3830: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3831: LD_STRING DonaldsonIn07
3833: PPUSH
3834: LD_EXP 1
3838: PPUSH
3839: CALL_OW 30
3843: IFFALSE 3864
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3845: LD_ADDR_EXP 11
3849: PUSH
3850: LD_STRING Donaldson
3852: PPUSH
3853: LD_EXP 1
3857: NOT
3858: PPUSH
3859: CALL 500 0 2
3863: ST_TO_ADDR
// if Donaldson then
3864: LD_EXP 11
3868: IFFALSE 3886
// team := team ^ Donaldson ;
3870: LD_ADDR_VAR 0 3
3874: PUSH
3875: LD_VAR 0 3
3879: PUSH
3880: LD_EXP 11
3884: ADD
3885: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3886: LD_STRING BobbyIn07
3888: PPUSH
3889: LD_EXP 1
3893: PPUSH
3894: CALL_OW 30
3898: IFFALSE 3919
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3900: LD_ADDR_EXP 12
3904: PUSH
3905: LD_STRING Bobby
3907: PPUSH
3908: LD_EXP 1
3912: NOT
3913: PPUSH
3914: CALL 500 0 2
3918: ST_TO_ADDR
// if Bobby then
3919: LD_EXP 12
3923: IFFALSE 3941
// team := team ^ Bobby ;
3925: LD_ADDR_VAR 0 3
3929: PUSH
3930: LD_VAR 0 3
3934: PUSH
3935: LD_EXP 12
3939: ADD
3940: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3941: LD_STRING CyrusIn07
3943: PPUSH
3944: LD_EXP 1
3948: PPUSH
3949: CALL_OW 30
3953: IFFALSE 3974
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3955: LD_ADDR_EXP 13
3959: PUSH
3960: LD_STRING Cyrus
3962: PPUSH
3963: LD_EXP 1
3967: NOT
3968: PPUSH
3969: CALL 500 0 2
3973: ST_TO_ADDR
// if Cyrus then
3974: LD_EXP 13
3978: IFFALSE 3996
// team := team ^ Cyrus ;
3980: LD_ADDR_VAR 0 3
3984: PUSH
3985: LD_VAR 0 3
3989: PUSH
3990: LD_EXP 13
3994: ADD
3995: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3996: LD_STRING LisaIn07
3998: PPUSH
3999: LD_EXP 1
4003: PPUSH
4004: CALL_OW 30
4008: IFFALSE 4029
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
4010: LD_ADDR_EXP 14
4014: PUSH
4015: LD_STRING Lisa
4017: PPUSH
4018: LD_EXP 1
4022: NOT
4023: PPUSH
4024: CALL 500 0 2
4028: ST_TO_ADDR
// if Lisa then
4029: LD_EXP 14
4033: IFFALSE 4051
// team := team ^ Lisa ;
4035: LD_ADDR_VAR 0 3
4039: PUSH
4040: LD_VAR 0 3
4044: PUSH
4045: LD_EXP 14
4049: ADD
4050: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
4051: LD_STRING GladstoneIn07
4053: PPUSH
4054: LD_EXP 1
4058: PPUSH
4059: CALL_OW 30
4063: IFFALSE 4084
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
4065: LD_ADDR_EXP 16
4069: PUSH
4070: LD_STRING Gladstone
4072: PPUSH
4073: LD_EXP 1
4077: NOT
4078: PPUSH
4079: CALL 500 0 2
4083: ST_TO_ADDR
// if Gladstone then
4084: LD_EXP 16
4088: IFFALSE 4106
// team := team ^ Gladstone ;
4090: LD_ADDR_VAR 0 3
4094: PUSH
4095: LD_VAR 0 3
4099: PUSH
4100: LD_EXP 16
4104: ADD
4105: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
4106: LD_STRING KhatamIn07
4108: PPUSH
4109: LD_EXP 1
4113: PPUSH
4114: CALL_OW 30
4118: IFFALSE 4139
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
4120: LD_ADDR_EXP 17
4124: PUSH
4125: LD_STRING Khatam
4127: PPUSH
4128: LD_EXP 1
4132: NOT
4133: PPUSH
4134: CALL 500 0 2
4138: ST_TO_ADDR
// if Khatam then
4139: LD_EXP 17
4143: IFFALSE 4161
// team := team ^ Khatam ;
4145: LD_ADDR_VAR 0 3
4149: PUSH
4150: LD_VAR 0 3
4154: PUSH
4155: LD_EXP 17
4159: ADD
4160: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4161: LD_ADDR_VAR 0 4
4165: PUSH
4166: LD_STRING 07_others
4168: PPUSH
4169: CALL_OW 31
4173: ST_TO_ADDR
// if others then
4174: LD_VAR 0 4
4178: IFFALSE 4196
// team := team ^ others ;
4180: LD_ADDR_VAR 0 3
4184: PUSH
4185: LD_VAR 0 3
4189: PUSH
4190: LD_VAR 0 4
4194: ADD
4195: ST_TO_ADDR
// if debug then
4196: LD_EXP 1
4200: IFFALSE 4274
// begin InitHc ;
4202: CALL_OW 19
// for i = 1 to 4 do
4206: LD_ADDR_VAR 0 2
4210: PUSH
4211: DOUBLE
4212: LD_INT 1
4214: DEC
4215: ST_TO_ADDR
4216: LD_INT 4
4218: PUSH
4219: FOR_TO
4220: IFFALSE 4272
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4222: LD_INT 0
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 1
4237: PPUSH
4238: LD_INT 2
4240: PPUSH
4241: CALL_OW 12
4245: ARRAY
4246: PPUSH
4247: LD_INT 4
4249: PPUSH
4250: CALL_OW 380
// team := team ^ CreateHuman ;
4254: LD_ADDR_VAR 0 3
4258: PUSH
4259: LD_VAR 0 3
4263: PUSH
4264: CALL_OW 44
4268: ADD
4269: ST_TO_ADDR
// end ;
4270: GO 4219
4272: POP
4273: POP
// end ; m := 0 ;
4274: LD_ADDR_VAR 0 6
4278: PUSH
4279: LD_INT 0
4281: ST_TO_ADDR
// for i in team do
4282: LD_ADDR_VAR 0 2
4286: PUSH
4287: LD_VAR 0 3
4291: PUSH
4292: FOR_IN
4293: IFFALSE 4500
// if GetClass ( i ) = 3 then
4295: LD_VAR 0 2
4299: PPUSH
4300: CALL_OW 257
4304: PUSH
4305: LD_INT 3
4307: EQUAL
4308: IFFALSE 4456
// begin m := m + 1 ;
4310: LD_ADDR_VAR 0 6
4314: PUSH
4315: LD_VAR 0 6
4319: PUSH
4320: LD_INT 1
4322: PLUS
4323: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4324: LD_ADDR_VAR 0 5
4328: PUSH
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 1
4334: PPUSH
4335: LD_INT 2
4337: PUSH
4338: LD_INT 3
4340: PUSH
4341: LD_INT 2
4343: PUSH
4344: LD_INT 1
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: PUSH
4353: LD_VAR 0 6
4357: PUSH
4358: LD_INT 4
4360: MOD
4361: PUSH
4362: LD_INT 1
4364: PLUS
4365: ARRAY
4366: PPUSH
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 1
4372: PPUSH
4373: LD_INT 4
4375: PUSH
4376: LD_INT 5
4378: PUSH
4379: LD_INT 3
4381: PUSH
4382: LD_INT 11
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: LIST
4389: LIST
4390: PUSH
4391: LD_VAR 0 6
4395: PUSH
4396: LD_INT 4
4398: MOD
4399: PUSH
4400: LD_INT 1
4402: PLUS
4403: ARRAY
4404: PPUSH
4405: LD_INT 60
4407: PPUSH
4408: CALL 563 0 7
4412: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4413: LD_VAR 0 5
4417: PPUSH
4418: LD_INT 2
4420: PPUSH
4421: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4425: LD_VAR 0 5
4429: PPUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 0
4435: PPUSH
4436: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4440: LD_VAR 0 2
4444: PPUSH
4445: LD_VAR 0 5
4449: PPUSH
4450: CALL_OW 52
// end else
4454: GO 4498
// begin if GetClass ( i ) = 2 then
4456: LD_VAR 0 2
4460: PPUSH
4461: CALL_OW 257
4465: PUSH
4466: LD_INT 2
4468: EQUAL
4469: IFFALSE 4483
// SetClass ( i , 1 ) ;
4471: LD_VAR 0 2
4475: PPUSH
4476: LD_INT 1
4478: PPUSH
4479: CALL_OW 336
// PlaceUnitArea ( i , startArea , false ) ;
4483: LD_VAR 0 2
4487: PPUSH
4488: LD_INT 1
4490: PPUSH
4491: LD_INT 0
4493: PPUSH
4494: CALL_OW 49
// end ;
4498: GO 4292
4500: POP
4501: POP
// uc_side := 4 ;
4502: LD_ADDR_OWVAR 20
4506: PUSH
4507: LD_INT 4
4509: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4510: LD_ADDR_EXP 19
4514: PUSH
4515: LD_STRING Harisson
4517: PPUSH
4518: LD_INT 0
4520: PPUSH
4521: CALL 500 0 2
4525: ST_TO_ADDR
// PrepareScout ;
4526: CALL 4535 0 0
// end ;
4530: LD_VAR 0 1
4534: RET
// function PrepareScout ; var ape ; begin
4535: LD_INT 0
4537: PPUSH
4538: PPUSH
// uc_side := 4 ;
4539: LD_ADDR_OWVAR 20
4543: PUSH
4544: LD_INT 4
4546: ST_TO_ADDR
// uc_nation := 1 ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 1
4554: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4555: LD_STRING FrankIn06
4557: PPUSH
4558: LD_INT 0
4560: PPUSH
4561: CALL_OW 30
4565: IFFALSE 4582
// Frank := CreateCharacter ( 06c_Frank ) else
4567: LD_ADDR_EXP 15
4571: PUSH
4572: LD_STRING 06c_Frank
4574: PPUSH
4575: CALL_OW 34
4579: ST_TO_ADDR
4580: GO 4622
// if LoadVariable ( FrankInDelta , 0 ) then
4582: LD_STRING FrankInDelta
4584: PPUSH
4585: LD_INT 0
4587: PPUSH
4588: CALL_OW 30
4592: IFFALSE 4609
// Frank := CreateCharacter ( 05_Frank ) else
4594: LD_ADDR_EXP 15
4598: PUSH
4599: LD_STRING 05_Frank
4601: PPUSH
4602: CALL_OW 34
4606: ST_TO_ADDR
4607: GO 4622
// Frank := CreateCharacter ( 04_Frank ) ;
4609: LD_ADDR_EXP 15
4613: PUSH
4614: LD_STRING 04_Frank
4616: PPUSH
4617: CALL_OW 34
4621: ST_TO_ADDR
// if Frank then
4622: LD_EXP 15
4626: IFFALSE 4759
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4628: LD_EXP 15
4632: PPUSH
4633: LD_INT 2
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4643: LD_EXP 15
4647: PPUSH
4648: LD_INT 1
4650: PPUSH
4651: CALL_OW 336
// uc_side := 0 ;
4655: LD_ADDR_OWVAR 20
4659: PUSH
4660: LD_INT 0
4662: ST_TO_ADDR
// uc_nation := 0 ;
4663: LD_ADDR_OWVAR 21
4667: PUSH
4668: LD_INT 0
4670: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4671: LD_INT 0
4673: PPUSH
4674: LD_INT 12
4676: PPUSH
4677: LD_INT 0
4679: PPUSH
4680: CALL_OW 380
// ape := CreateHuman ;
4684: LD_ADDR_VAR 0 2
4688: PUSH
4689: CALL_OW 44
4693: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_EXP 15
4703: PPUSH
4704: CALL_OW 250
4708: PPUSH
4709: LD_EXP 15
4713: PPUSH
4714: CALL_OW 251
4718: PPUSH
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 0
4724: PPUSH
4725: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4729: LD_VAR 0 2
4733: PPUSH
4734: LD_EXP 15
4738: PPUSH
4739: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4743: LD_EXP 15
4747: PPUSH
4748: LD_VAR 0 2
4752: PPUSH
4753: CALL_OW 119
// exit ;
4757: GO 4799
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4759: LD_ADDR_EXP 18
4763: PUSH
4764: LD_STRING Yamoko
4766: PPUSH
4767: LD_INT 0
4769: PPUSH
4770: CALL 500 0 2
4774: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4775: LD_EXP 18
4779: PPUSH
4780: LD_INT 2
4782: PPUSH
4783: LD_INT 0
4785: PPUSH
4786: CALL_OW 49
// ComHold ( Kikuchi ) ;
4790: LD_EXP 18
4794: PPUSH
4795: CALL_OW 140
// end ; end_of_file
4799: LD_VAR 0 1
4803: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4804: LD_INT 0
4806: PPUSH
4807: PPUSH
4808: PPUSH
4809: PPUSH
4810: PPUSH
4811: PPUSH
4812: PPUSH
4813: PPUSH
4814: PPUSH
4815: PPUSH
4816: PPUSH
4817: PPUSH
4818: PPUSH
4819: PPUSH
4820: PPUSH
4821: PPUSH
// ru_rebuild_list := [ ] ;
4822: LD_ADDR_EXP 20
4826: PUSH
4827: EMPTY
4828: ST_TO_ADDR
// uc_side := 3 ;
4829: LD_ADDR_OWVAR 20
4833: PUSH
4834: LD_INT 3
4836: ST_TO_ADDR
// uc_nation := 3 ;
4837: LD_ADDR_OWVAR 21
4841: PUSH
4842: LD_INT 3
4844: ST_TO_ADDR
// if Difficulty > 1 then
4845: LD_OWVAR 67
4849: PUSH
4850: LD_INT 1
4852: GREATER
4853: IFFALSE 4989
// begin bc_type := b_breastwork ;
4855: LD_ADDR_OWVAR 42
4859: PUSH
4860: LD_INT 31
4862: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4863: LD_INT 78
4865: PPUSH
4866: LD_INT 74
4868: PPUSH
4869: LD_INT 2
4871: PPUSH
4872: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4876: LD_INT 171
4878: PPUSH
4879: LD_INT 193
4881: PPUSH
4882: LD_INT 4
4884: PPUSH
4885: CALL_OW 47
// bc_type := b_turret ;
4889: LD_ADDR_OWVAR 42
4893: PUSH
4894: LD_INT 33
4896: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4897: LD_INT 129
4899: PPUSH
4900: LD_INT 96
4902: PPUSH
4903: LD_INT 3
4905: PPUSH
4906: CALL_OW 47
// if Difficulty > 2 then
4910: LD_OWVAR 67
4914: PUSH
4915: LD_INT 2
4917: GREATER
4918: IFFALSE 4989
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4920: LD_INT 83
4922: PPUSH
4923: LD_INT 141
4925: PPUSH
4926: CALL_OW 428
4930: PPUSH
4931: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4935: LD_INT 78
4937: PPUSH
4938: LD_INT 133
4940: PPUSH
4941: CALL_OW 428
4945: PPUSH
4946: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4950: LD_INT 83
4952: PPUSH
4953: LD_INT 141
4955: PPUSH
4956: LD_INT 2
4958: PPUSH
4959: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4963: LD_INT 78
4965: PPUSH
4966: LD_INT 133
4968: PPUSH
4969: LD_INT 2
4971: PPUSH
4972: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4976: LD_INT 145
4978: PPUSH
4979: LD_INT 112
4981: PPUSH
4982: LD_INT 3
4984: PPUSH
4985: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4989: LD_ADDR_VAR 0 9
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 3
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 2
5006: PUSH
5007: LD_INT 30
5009: PUSH
5010: LD_INT 0
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 30
5019: PUSH
5020: LD_INT 1
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: LIST
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
5041: LD_ADDR_VAR 0 10
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 3
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 2
5058: PUSH
5059: LD_INT 30
5061: PUSH
5062: LD_INT 6
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 30
5071: PUSH
5072: LD_INT 7
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: LD_INT 30
5081: PUSH
5082: LD_INT 8
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: PPUSH
5099: CALL_OW 69
5103: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
5104: LD_ADDR_VAR 0 11
5108: PUSH
5109: LD_INT 22
5111: PUSH
5112: LD_INT 3
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 30
5121: PUSH
5122: LD_INT 3
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PPUSH
5133: CALL_OW 69
5137: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
5138: LD_ADDR_VAR 0 12
5142: PUSH
5143: LD_INT 22
5145: PUSH
5146: LD_INT 3
5148: PUSH
5149: EMPTY
5150: LIST
5151: LIST
5152: PUSH
5153: LD_INT 30
5155: PUSH
5156: LD_INT 31
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PPUSH
5167: CALL_OW 69
5171: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5172: LD_ADDR_VAR 0 13
5176: PUSH
5177: LD_INT 22
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 32
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: PPUSH
5201: CALL_OW 69
5205: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5206: LD_ADDR_VAR 0 14
5210: PUSH
5211: LD_INT 22
5213: PUSH
5214: LD_INT 3
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: PUSH
5221: LD_INT 30
5223: PUSH
5224: LD_INT 33
5226: PUSH
5227: EMPTY
5228: LIST
5229: LIST
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PPUSH
5235: CALL_OW 69
5239: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5240: LD_ADDR_VAR 0 15
5244: PUSH
5245: LD_INT 42
5247: PUSH
5248: LD_INT 5
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: LD_INT 43
5257: PUSH
5258: LD_INT 50
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: LD_INT 44
5267: PUSH
5268: LD_INT 30
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: PUSH
5275: LD_INT 46
5277: PUSH
5278: LD_INT 15
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: PUSH
5285: EMPTY
5286: LIST
5287: LIST
5288: LIST
5289: LIST
5290: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5291: LD_ADDR_VAR 0 16
5295: PUSH
5296: LD_INT 0
5298: PUSH
5299: LD_INT 4
5301: PUSH
5302: LD_INT 6
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: LIST
5312: LIST
5313: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5314: LD_ADDR_VAR 0 6
5318: PUSH
5319: LD_INT 4
5321: PUSH
5322: LD_INT 5
5324: PUSH
5325: LD_INT 6
5327: PUSH
5328: EMPTY
5329: LIST
5330: LIST
5331: LIST
5332: PUSH
5333: LD_OWVAR 67
5337: ARRAY
5338: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5339: LD_INT 16
5341: PPUSH
5342: LD_STRING am_tukh
5344: PPUSH
5345: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: LD_INT 21
5356: PUSH
5357: LD_INT 3
5359: PUSH
5360: EMPTY
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: PUSH
5369: FOR_IN
5370: IFFALSE 5403
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5372: LD_VAR 0 2
5376: PPUSH
5377: LD_INT 4
5379: PUSH
5380: LD_INT 5
5382: PUSH
5383: LD_INT 6
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: LIST
5390: PUSH
5391: LD_OWVAR 67
5395: ARRAY
5396: PPUSH
5397: CALL_OW 241
5401: GO 5369
5403: POP
5404: POP
// for i in dep_list do
5405: LD_ADDR_VAR 0 2
5409: PUSH
5410: LD_VAR 0 9
5414: PUSH
5415: FOR_IN
5416: IFFALSE 5460
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5418: LD_VAR 0 2
5422: PPUSH
5423: CALL_OW 274
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: LD_INT 1000
5433: PPUSH
5434: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5438: LD_VAR 0 2
5442: PPUSH
5443: CALL_OW 274
5447: PPUSH
5448: LD_INT 2
5450: PPUSH
5451: LD_INT 1000
5453: PPUSH
5454: CALL_OW 277
// end ;
5458: GO 5415
5460: POP
5461: POP
// InitHc ;
5462: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5466: LD_ADDR_VAR 0 8
5470: PUSH
5471: LD_VAR 0 13
5475: PUSH
5476: LD_INT 45
5478: PUSH
5479: LD_INT 60
5481: PUSH
5482: LD_INT 75
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: MUL
5496: PUSH
5497: LD_INT 100
5499: DIV
5500: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5501: LD_ADDR_VAR 0 16
5505: PUSH
5506: LD_VAR 0 16
5510: PPUSH
5511: LD_INT 1
5513: PPUSH
5514: LD_VAR 0 8
5518: PPUSH
5519: CALL_OW 1
5523: ST_TO_ADDR
// tmp := [ ] ;
5524: LD_ADDR_VAR 0 8
5528: PUSH
5529: EMPTY
5530: ST_TO_ADDR
// for i in bunker_list do
5531: LD_ADDR_VAR 0 2
5535: PUSH
5536: LD_VAR 0 13
5540: PUSH
5541: FOR_IN
5542: IFFALSE 5638
// if i mod 10 + 1 < tmp then
5544: LD_VAR 0 2
5548: PUSH
5549: LD_INT 10
5551: MOD
5552: PUSH
5553: LD_INT 1
5555: PLUS
5556: PUSH
5557: LD_VAR 0 8
5561: LESS
5562: IFFALSE 5607
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5564: LD_ADDR_VAR 0 8
5568: PUSH
5569: LD_VAR 0 8
5573: PPUSH
5574: LD_VAR 0 2
5578: PUSH
5579: LD_INT 3
5581: PPUSH
5582: LD_INT 5
5584: PPUSH
5585: CALL_OW 12
5589: MOD
5590: PUSH
5591: LD_INT 1
5593: PLUS
5594: PPUSH
5595: LD_VAR 0 2
5599: PPUSH
5600: CALL_OW 2
5604: ST_TO_ADDR
5605: GO 5636
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5607: LD_ADDR_VAR 0 8
5611: PUSH
5612: LD_VAR 0 8
5616: PPUSH
5617: LD_VAR 0 8
5621: PUSH
5622: LD_INT 1
5624: PLUS
5625: PPUSH
5626: LD_VAR 0 2
5630: PPUSH
5631: CALL_OW 2
5635: ST_TO_ADDR
5636: GO 5541
5638: POP
5639: POP
// bunker_list := tmp ;
5640: LD_ADDR_VAR 0 13
5644: PUSH
5645: LD_VAR 0 8
5649: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5650: LD_ADDR_VAR 0 2
5654: PUSH
5655: LD_VAR 0 13
5659: PUSH
5660: LD_VAR 0 14
5664: ADD
5665: PUSH
5666: FOR_IN
5667: IFFALSE 5690
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5669: LD_VAR 0 2
5673: PPUSH
5674: LD_VAR 0 2
5678: PPUSH
5679: CALL 977 0 1
5683: PPUSH
5684: CALL_OW 431
5688: GO 5666
5690: POP
5691: POP
// while ( personel_counter [ 1 ] ) do
5692: LD_VAR 0 16
5696: PUSH
5697: LD_INT 1
5699: ARRAY
5700: IFFALSE 5808
// begin i := rand ( 1 , bunker_list ) ;
5702: LD_ADDR_VAR 0 2
5706: PUSH
5707: LD_INT 1
5709: PPUSH
5710: LD_VAR 0 13
5714: PPUSH
5715: CALL_OW 12
5719: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5720: LD_INT 0
5722: PPUSH
5723: LD_INT 1
5725: PPUSH
5726: LD_VAR 0 6
5730: PPUSH
5731: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5735: CALL_OW 44
5739: PPUSH
5740: LD_VAR 0 13
5744: PUSH
5745: LD_VAR 0 2
5749: ARRAY
5750: PPUSH
5751: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5755: LD_ADDR_VAR 0 13
5759: PUSH
5760: LD_VAR 0 13
5764: PPUSH
5765: LD_VAR 0 2
5769: PPUSH
5770: CALL_OW 3
5774: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5775: LD_ADDR_VAR 0 16
5779: PUSH
5780: LD_VAR 0 16
5784: PPUSH
5785: LD_INT 1
5787: PPUSH
5788: LD_VAR 0 16
5792: PUSH
5793: LD_INT 1
5795: ARRAY
5796: PUSH
5797: LD_INT 1
5799: MINUS
5800: PPUSH
5801: CALL_OW 1
5805: ST_TO_ADDR
// end ;
5806: GO 5692
// for i = 1 to personel_counter [ 2 ] do
5808: LD_ADDR_VAR 0 2
5812: PUSH
5813: DOUBLE
5814: LD_INT 1
5816: DEC
5817: ST_TO_ADDR
5818: LD_VAR 0 16
5822: PUSH
5823: LD_INT 2
5825: ARRAY
5826: PUSH
5827: FOR_TO
5828: IFFALSE 5859
// begin PrepareHuman ( false , 2 , skill ) ;
5830: LD_INT 0
5832: PPUSH
5833: LD_INT 2
5835: PPUSH
5836: LD_VAR 0 6
5840: PPUSH
5841: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5845: CALL_OW 44
5849: PPUSH
5850: LD_INT 16
5852: PPUSH
5853: CALL_OW 52
// end ;
5857: GO 5827
5859: POP
5860: POP
// for i = 1 to personel_counter [ 3 ] do
5861: LD_ADDR_VAR 0 2
5865: PUSH
5866: DOUBLE
5867: LD_INT 1
5869: DEC
5870: ST_TO_ADDR
5871: LD_VAR 0 16
5875: PUSH
5876: LD_INT 3
5878: ARRAY
5879: PUSH
5880: FOR_TO
5881: IFFALSE 5928
// begin PrepareHuman ( false , 3 , skill ) ;
5883: LD_INT 0
5885: PPUSH
5886: LD_INT 3
5888: PPUSH
5889: LD_VAR 0 6
5893: PPUSH
5894: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5898: CALL_OW 44
5902: PPUSH
5903: LD_VAR 0 11
5907: PUSH
5908: LD_VAR 0 2
5912: PUSH
5913: LD_INT 2
5915: MOD
5916: PUSH
5917: LD_INT 1
5919: PLUS
5920: ARRAY
5921: PPUSH
5922: CALL_OW 52
// end ;
5926: GO 5880
5928: POP
5929: POP
// for i = 1 to personel_counter [ 4 ] do
5930: LD_ADDR_VAR 0 2
5934: PUSH
5935: DOUBLE
5936: LD_INT 1
5938: DEC
5939: ST_TO_ADDR
5940: LD_VAR 0 16
5944: PUSH
5945: LD_INT 4
5947: ARRAY
5948: PUSH
5949: FOR_TO
5950: IFFALSE 5987
// begin PrepareHuman ( false , 4 , skill ) ;
5952: LD_INT 0
5954: PPUSH
5955: LD_INT 4
5957: PPUSH
5958: LD_VAR 0 6
5962: PPUSH
5963: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5967: CALL_OW 44
5971: PPUSH
5972: LD_VAR 0 10
5976: PUSH
5977: LD_INT 1
5979: ARRAY
5980: PPUSH
5981: CALL_OW 52
// end ;
5985: GO 5949
5987: POP
5988: POP
// for i in breastworks_list do
5989: LD_ADDR_VAR 0 2
5993: PUSH
5994: LD_VAR 0 12
5998: PUSH
5999: FOR_IN
6000: IFFALSE 6112
// begin r := GetDir ( i ) ;
6002: LD_ADDR_VAR 0 4
6006: PUSH
6007: LD_VAR 0 2
6011: PPUSH
6012: CALL_OW 254
6016: ST_TO_ADDR
// if r > 3 then
6017: LD_VAR 0 4
6021: PUSH
6022: LD_INT 3
6024: GREATER
6025: IFFALSE 6043
// r := r - 3 else
6027: LD_ADDR_VAR 0 4
6031: PUSH
6032: LD_VAR 0 4
6036: PUSH
6037: LD_INT 3
6039: MINUS
6040: ST_TO_ADDR
6041: GO 6057
// r := r + 3 ;
6043: LD_ADDR_VAR 0 4
6047: PUSH
6048: LD_VAR 0 4
6052: PUSH
6053: LD_INT 3
6055: PLUS
6056: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 1
6062: PPUSH
6063: LD_VAR 0 6
6067: PPUSH
6068: CALL_OW 380
// un := CreateHuman ;
6072: LD_ADDR_VAR 0 5
6076: PUSH
6077: CALL_OW 44
6081: ST_TO_ADDR
// SetDir ( un , r ) ;
6082: LD_VAR 0 5
6086: PPUSH
6087: LD_VAR 0 4
6091: PPUSH
6092: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6096: LD_VAR 0 5
6100: PPUSH
6101: LD_VAR 0 2
6105: PPUSH
6106: CALL_OW 52
// end ;
6110: GO 5999
6112: POP
6113: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
6114: LD_ADDR_VAR 0 8
6118: PUSH
6119: LD_INT 22
6121: PUSH
6122: LD_INT 3
6124: PUSH
6125: EMPTY
6126: LIST
6127: LIST
6128: PUSH
6129: LD_INT 25
6131: PUSH
6132: LD_INT 3
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PUSH
6139: EMPTY
6140: LIST
6141: LIST
6142: PPUSH
6143: CALL_OW 69
6147: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
6148: LD_ADDR_VAR 0 4
6152: PUSH
6153: LD_INT 4
6155: PUSH
6156: LD_INT 5
6158: PUSH
6159: LD_INT 6
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: LD_OWVAR 67
6171: ARRAY
6172: ST_TO_ADDR
// for i = 1 to r do
6173: LD_ADDR_VAR 0 2
6177: PUSH
6178: DOUBLE
6179: LD_INT 1
6181: DEC
6182: ST_TO_ADDR
6183: LD_VAR 0 4
6187: PUSH
6188: FOR_TO
6189: IFFALSE 6362
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6191: LD_ADDR_VAR 0 5
6195: PUSH
6196: LD_INT 3
6198: PPUSH
6199: LD_INT 3
6201: PPUSH
6202: LD_INT 22
6204: PUSH
6205: LD_INT 22
6207: PUSH
6208: LD_INT 24
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: PUSH
6216: LD_VAR 0 2
6220: PUSH
6221: LD_INT 3
6223: MOD
6224: PUSH
6225: LD_INT 1
6227: PLUS
6228: ARRAY
6229: PPUSH
6230: LD_INT 1
6232: PPUSH
6233: LD_INT 1
6235: PPUSH
6236: LD_INT 43
6238: PUSH
6239: LD_INT 44
6241: PUSH
6242: LD_INT 42
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: PUSH
6250: LD_VAR 0 2
6254: PUSH
6255: LD_INT 3
6257: MOD
6258: PUSH
6259: LD_INT 1
6261: PLUS
6262: ARRAY
6263: PPUSH
6264: LD_INT 100
6266: PPUSH
6267: CALL 563 0 7
6271: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6272: LD_VAR 0 5
6276: PPUSH
6277: LD_INT 0
6279: PPUSH
6280: LD_INT 5
6282: PPUSH
6283: CALL_OW 12
6287: PPUSH
6288: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6292: LD_VAR 0 5
6296: PPUSH
6297: LD_INT 5
6299: PPUSH
6300: LD_INT 0
6302: PPUSH
6303: CALL_OW 49
// if i > tmp - 2 then
6307: LD_VAR 0 2
6311: PUSH
6312: LD_VAR 0 8
6316: PUSH
6317: LD_INT 2
6319: MINUS
6320: GREATER
6321: IFFALSE 6325
// continue ;
6323: GO 6188
// ComExitBuilding ( tmp [ i ] ) ;
6325: LD_VAR 0 8
6329: PUSH
6330: LD_VAR 0 2
6334: ARRAY
6335: PPUSH
6336: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6340: LD_VAR 0 8
6344: PUSH
6345: LD_VAR 0 2
6349: ARRAY
6350: PPUSH
6351: LD_VAR 0 5
6355: PPUSH
6356: CALL_OW 180
// end ;
6360: GO 6188
6362: POP
6363: POP
// end ;
6364: LD_VAR 0 1
6368: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6369: LD_INT 22
6371: PUSH
6372: LD_INT 3
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: PUSH
6379: LD_INT 25
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PPUSH
6393: CALL_OW 69
6397: IFFALSE 7129
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
6407: PPUSH
6408: PPUSH
// begin enable ;
6409: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6410: LD_ADDR_VAR 0 2
6414: PUSH
6415: LD_INT 6
6417: PPUSH
6418: LD_INT 3
6420: PUSH
6421: LD_INT 24
6423: PUSH
6424: LD_INT 1000
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: PUSH
6435: LD_INT 21
6437: PUSH
6438: LD_INT 3
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PPUSH
6449: CALL_OW 70
6453: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6454: LD_ADDR_VAR 0 4
6458: PUSH
6459: LD_INT 22
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 25
6471: PUSH
6472: LD_INT 2
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PPUSH
6483: CALL_OW 69
6487: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6488: LD_VAR 0 2
6492: NOT
6493: PUSH
6494: LD_EXP 20
6498: NOT
6499: AND
6500: IFFALSE 6570
// begin for i in engs do
6502: LD_ADDR_VAR 0 1
6506: PUSH
6507: LD_VAR 0 4
6511: PUSH
6512: FOR_IN
6513: IFFALSE 6568
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6515: LD_VAR 0 1
6519: PPUSH
6520: CALL_OW 256
6524: PUSH
6525: LD_INT 1000
6527: EQUAL
6528: PUSH
6529: LD_VAR 0 1
6533: PPUSH
6534: CALL_OW 314
6538: NOT
6539: AND
6540: PUSH
6541: LD_VAR 0 1
6545: PPUSH
6546: CALL_OW 310
6550: NOT
6551: AND
6552: IFFALSE 6566
// ComEnterUnit ( i , ru_dep_main ) ;
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 16
6561: PPUSH
6562: CALL_OW 120
6566: GO 6512
6568: POP
6569: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6570: LD_VAR 0 4
6574: PPUSH
6575: LD_INT 3
6577: PUSH
6578: LD_INT 24
6580: PUSH
6581: LD_INT 650
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PPUSH
6592: CALL_OW 72
6596: IFFALSE 6689
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6598: LD_ADDR_VAR 0 3
6602: PUSH
6603: LD_VAR 0 4
6607: PPUSH
6608: LD_INT 3
6610: PUSH
6611: LD_INT 24
6613: PUSH
6614: LD_INT 650
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: PUSH
6621: EMPTY
6622: LIST
6623: LIST
6624: PPUSH
6625: CALL_OW 72
6629: ST_TO_ADDR
// for i in tmp do
6630: LD_ADDR_VAR 0 1
6634: PUSH
6635: LD_VAR 0 3
6639: PUSH
6640: FOR_IN
6641: IFFALSE 6687
// if not IsInArea ( i , mainBaseArea ) then
6643: LD_VAR 0 1
6647: PPUSH
6648: LD_INT 14
6650: PPUSH
6651: CALL_OW 308
6655: NOT
6656: IFFALSE 6685
// begin ComMoveXY ( i , 129 , 125 ) ;
6658: LD_VAR 0 1
6662: PPUSH
6663: LD_INT 129
6665: PPUSH
6666: LD_INT 125
6668: PPUSH
6669: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6673: LD_VAR 0 1
6677: PPUSH
6678: LD_INT 1050
6680: PPUSH
6681: CALL_OW 202
// end ;
6685: GO 6640
6687: POP
6688: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6689: LD_ADDR_VAR 0 4
6693: PUSH
6694: LD_VAR 0 4
6698: PPUSH
6699: LD_INT 24
6701: PUSH
6702: LD_INT 650
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: PPUSH
6709: CALL_OW 72
6713: ST_TO_ADDR
// if not engs then
6714: LD_VAR 0 4
6718: NOT
6719: IFFALSE 6723
// exit ;
6721: GO 7129
// if filter then
6723: LD_VAR 0 2
6727: IFFALSE 6986
// begin for i in engs do
6729: LD_ADDR_VAR 0 1
6733: PUSH
6734: LD_VAR 0 4
6738: PUSH
6739: FOR_IN
6740: IFFALSE 6764
// if IsInUnit ( i ) then
6742: LD_VAR 0 1
6746: PPUSH
6747: CALL_OW 310
6751: IFFALSE 6762
// ComExitBuilding ( i ) ;
6753: LD_VAR 0 1
6757: PPUSH
6758: CALL_OW 122
6762: GO 6739
6764: POP
6765: POP
// wait ( 3 ) ;
6766: LD_INT 3
6768: PPUSH
6769: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6773: LD_VAR 0 2
6777: PUSH
6778: LD_INT 2
6780: GREATEREQUAL
6781: PUSH
6782: LD_VAR 0 4
6786: PUSH
6787: LD_INT 2
6789: GREATEREQUAL
6790: AND
6791: IFFALSE 6939
// begin for i = 1 to engs / 2 do
6793: LD_ADDR_VAR 0 1
6797: PUSH
6798: DOUBLE
6799: LD_INT 1
6801: DEC
6802: ST_TO_ADDR
6803: LD_VAR 0 4
6807: PUSH
6808: LD_INT 2
6810: DIVREAL
6811: PUSH
6812: FOR_TO
6813: IFFALSE 6859
// if not HasTask ( engs [ i ] ) then
6815: LD_VAR 0 4
6819: PUSH
6820: LD_VAR 0 1
6824: ARRAY
6825: PPUSH
6826: CALL_OW 314
6830: NOT
6831: IFFALSE 6857
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6833: LD_VAR 0 4
6837: PUSH
6838: LD_VAR 0 1
6842: ARRAY
6843: PPUSH
6844: LD_VAR 0 2
6848: PUSH
6849: LD_INT 1
6851: ARRAY
6852: PPUSH
6853: CALL_OW 130
6857: GO 6812
6859: POP
6860: POP
// for i = engs / 2 + 1 to engs do
6861: LD_ADDR_VAR 0 1
6865: PUSH
6866: DOUBLE
6867: LD_VAR 0 4
6871: PUSH
6872: LD_INT 2
6874: DIVREAL
6875: PUSH
6876: LD_INT 1
6878: PLUS
6879: DEC
6880: ST_TO_ADDR
6881: LD_VAR 0 4
6885: PUSH
6886: FOR_TO
6887: IFFALSE 6935
// if not HasTask ( engs [ i ] ) then
6889: LD_VAR 0 4
6893: PUSH
6894: LD_VAR 0 1
6898: ARRAY
6899: PPUSH
6900: CALL_OW 314
6904: NOT
6905: IFFALSE 6933
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6907: LD_VAR 0 4
6911: PUSH
6912: LD_VAR 0 1
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_VAR 0 2
6927: ARRAY
6928: PPUSH
6929: CALL_OW 130
6933: GO 6886
6935: POP
6936: POP
// end else
6937: GO 6986
// for i in engs do
6939: LD_ADDR_VAR 0 1
6943: PUSH
6944: LD_VAR 0 4
6948: PUSH
6949: FOR_IN
6950: IFFALSE 6984
// if not HasTask ( i ) then
6952: LD_VAR 0 1
6956: PPUSH
6957: CALL_OW 314
6961: NOT
6962: IFFALSE 6982
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6964: LD_VAR 0 1
6968: PPUSH
6969: LD_VAR 0 2
6973: PUSH
6974: LD_INT 1
6976: ARRAY
6977: PPUSH
6978: CALL_OW 130
6982: GO 6949
6984: POP
6985: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6986: LD_ADDR_VAR 0 5
6990: PUSH
6991: LD_INT 81
6993: PUSH
6994: LD_INT 3
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: PPUSH
7001: CALL_OW 69
7005: ST_TO_ADDR
// if ru_rebuild_list and not filter then
7006: LD_EXP 20
7010: PUSH
7011: LD_VAR 0 2
7015: NOT
7016: AND
7017: IFFALSE 7129
// begin ComExitBuilding ( engs ) ;
7019: LD_VAR 0 4
7023: PPUSH
7024: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
7028: LD_VAR 0 5
7032: PPUSH
7033: LD_EXP 20
7037: PUSH
7038: LD_INT 2
7040: ARRAY
7041: PPUSH
7042: LD_EXP 20
7046: PUSH
7047: LD_INT 3
7049: ARRAY
7050: PPUSH
7051: CALL_OW 73
7055: PPUSH
7056: LD_EXP 20
7060: PUSH
7061: LD_INT 2
7063: ARRAY
7064: PPUSH
7065: LD_EXP 20
7069: PUSH
7070: LD_INT 3
7072: ARRAY
7073: PPUSH
7074: CALL_OW 297
7078: PUSH
7079: LD_INT 10
7081: GREATER
7082: IFFALSE 7129
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
7084: LD_VAR 0 4
7088: PPUSH
7089: LD_EXP 20
7093: PUSH
7094: LD_INT 1
7096: ARRAY
7097: PPUSH
7098: LD_EXP 20
7102: PUSH
7103: LD_INT 2
7105: ARRAY
7106: PPUSH
7107: LD_EXP 20
7111: PUSH
7112: LD_INT 3
7114: ARRAY
7115: PPUSH
7116: LD_EXP 20
7120: PUSH
7121: LD_INT 4
7123: ARRAY
7124: PPUSH
7125: CALL_OW 145
// end ; end ;
7129: PPOPN 5
7131: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 250 do var i , tmp ;
7132: LD_INT 16
7134: PPUSH
7135: CALL_OW 256
7139: PUSH
7140: LD_INT 250
7142: LESS
7143: IFFALSE 7333
7145: GO 7147
7147: DISABLE
7148: LD_INT 0
7150: PPUSH
7151: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: LD_INT 22
7159: PUSH
7160: LD_INT 3
7162: PUSH
7163: EMPTY
7164: LIST
7165: LIST
7166: PUSH
7167: LD_INT 2
7169: PUSH
7170: LD_INT 25
7172: PUSH
7173: LD_INT 1
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 25
7182: PUSH
7183: LD_INT 3
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: LD_INT 25
7192: PUSH
7193: LD_INT 4
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: EMPTY
7201: LIST
7202: LIST
7203: LIST
7204: LIST
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: PPUSH
7210: CALL_OW 69
7214: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7215: LD_VAR 0 2
7219: PPUSH
7220: CALL_OW 122
// wait ( 3 ) ;
7224: LD_INT 3
7226: PPUSH
7227: CALL_OW 67
// ComMoveXY ( tmp , 156 , 211 ) ;
7231: LD_VAR 0 2
7235: PPUSH
7236: LD_INT 156
7238: PPUSH
7239: LD_INT 211
7241: PPUSH
7242: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7246: LD_INT 35
7248: PPUSH
7249: CALL_OW 67
// for i in tmp do
7253: LD_ADDR_VAR 0 1
7257: PUSH
7258: LD_VAR 0 2
7262: PUSH
7263: FOR_IN
7264: IFFALSE 7324
// if IsInArea ( i , escapeArea ) then
7266: LD_VAR 0 1
7270: PPUSH
7271: LD_INT 15
7273: PPUSH
7274: CALL_OW 308
7278: IFFALSE 7307
// begin RemoveUnit ( i ) ;
7280: LD_VAR 0 1
7284: PPUSH
7285: CALL_OW 64
// tmp := tmp diff i ;
7289: LD_ADDR_VAR 0 2
7293: PUSH
7294: LD_VAR 0 2
7298: PUSH
7299: LD_VAR 0 1
7303: DIFF
7304: ST_TO_ADDR
// end else
7305: GO 7322
// ComMoveXY ( i , 156 , 211 ) ;
7307: LD_VAR 0 1
7311: PPUSH
7312: LD_INT 156
7314: PPUSH
7315: LD_INT 211
7317: PPUSH
7318: CALL_OW 111
7322: GO 7263
7324: POP
7325: POP
// until not tmp ;
7326: LD_VAR 0 2
7330: NOT
7331: IFFALSE 7246
// end ;
7333: PPOPN 2
7335: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 250 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7336: LD_INT 16
7338: PPUSH
7339: CALL_OW 256
7343: PUSH
7344: LD_INT 250
7346: GREATER
7347: PUSH
7348: LD_INT 22
7350: PUSH
7351: LD_INT 3
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 25
7360: PUSH
7361: LD_INT 1
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: PUSH
7368: LD_INT 56
7370: PUSH
7371: EMPTY
7372: LIST
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: LIST
7378: PUSH
7379: EMPTY
7380: LIST
7381: PPUSH
7382: CALL_OW 69
7386: AND
7387: IFFALSE 7499
7389: GO 7391
7391: DISABLE
7392: LD_INT 0
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7397: LD_ADDR_VAR 0 2
7401: PUSH
7402: LD_INT 22
7404: PUSH
7405: LD_INT 3
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PUSH
7412: LD_INT 25
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: LD_INT 56
7424: PUSH
7425: EMPTY
7426: LIST
7427: PUSH
7428: LD_INT 3
7430: PUSH
7431: LD_INT 60
7433: PUSH
7434: EMPTY
7435: LIST
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: LIST
7446: PUSH
7447: EMPTY
7448: LIST
7449: PPUSH
7450: CALL_OW 69
7454: ST_TO_ADDR
// if not tmp then
7455: LD_VAR 0 2
7459: NOT
7460: IFFALSE 7464
// exit ;
7462: GO 7499
// for i in tmp do
7464: LD_ADDR_VAR 0 1
7468: PUSH
7469: LD_VAR 0 2
7473: PUSH
7474: FOR_IN
7475: IFFALSE 7497
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7477: LD_VAR 0 1
7481: PPUSH
7482: LD_INT 0
7484: PPUSH
7485: LD_INT 143
7487: PPUSH
7488: LD_INT 143
7490: PPUSH
7491: CALL 2200 0 4
7495: GO 7474
7497: POP
7498: POP
// end ;
7499: PPOPN 2
7501: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7502: LD_INT 22
7504: PUSH
7505: LD_INT 3
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: PUSH
7512: LD_INT 25
7514: PUSH
7515: LD_INT 4
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PPUSH
7526: CALL_OW 69
7530: IFFALSE 7784
7532: GO 7534
7534: DISABLE
7535: LD_INT 0
7537: PPUSH
7538: PPUSH
7539: PPUSH
// begin enable ;
7540: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7541: LD_ADDR_VAR 0 2
7545: PUSH
7546: LD_INT 14
7548: PPUSH
7549: LD_INT 22
7551: PUSH
7552: LD_INT 3
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 21
7561: PUSH
7562: LD_INT 1
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 3
7571: PUSH
7572: LD_INT 24
7574: PUSH
7575: LD_INT 1000
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: LIST
7590: PPUSH
7591: CALL_OW 70
7595: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7596: LD_ADDR_VAR 0 3
7600: PUSH
7601: LD_INT 22
7603: PUSH
7604: LD_INT 3
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 25
7613: PUSH
7614: LD_INT 4
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: PPUSH
7625: CALL_OW 69
7629: ST_TO_ADDR
// if not doc then
7630: LD_VAR 0 3
7634: NOT
7635: IFFALSE 7639
// exit ;
7637: GO 7784
// if not tmp then
7639: LD_VAR 0 2
7643: NOT
7644: IFFALSE 7735
// begin if not IsInUnit ( doc [ 1 ] ) then
7646: LD_VAR 0 3
7650: PUSH
7651: LD_INT 1
7653: ARRAY
7654: PPUSH
7655: CALL_OW 310
7659: NOT
7660: IFFALSE 7733
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7662: LD_VAR 0 3
7666: PPUSH
7667: LD_INT 22
7669: PUSH
7670: LD_INT 3
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 30
7682: PUSH
7683: LD_INT 6
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 30
7692: PUSH
7693: LD_INT 7
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 30
7702: PUSH
7703: LD_INT 8
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_INT 1
7727: ARRAY
7728: PPUSH
7729: CALL_OW 120
// exit ;
7733: GO 7784
// end ; if IsInUnit ( doc [ 1 ] ) then
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: ARRAY
7743: PPUSH
7744: CALL_OW 310
7748: IFFALSE 7759
// ComExitBuilding ( doc ) ;
7750: LD_VAR 0 3
7754: PPUSH
7755: CALL_OW 122
// wait ( 3 ) ;
7759: LD_INT 3
7761: PPUSH
7762: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7766: LD_VAR 0 3
7770: PPUSH
7771: LD_VAR 0 2
7775: PUSH
7776: LD_INT 1
7778: ARRAY
7779: PPUSH
7780: CALL_OW 128
// end ;
7784: PPOPN 3
7786: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7787: LD_INT 22
7789: PUSH
7790: LD_INT 3
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PUSH
7797: LD_INT 25
7799: PUSH
7800: LD_INT 3
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PPUSH
7811: CALL_OW 69
7815: PUSH
7816: LD_INT 22
7818: PUSH
7819: LD_INT 3
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 21
7828: PUSH
7829: LD_INT 2
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: PPUSH
7840: CALL_OW 69
7844: AND
7845: IFFALSE 8259
7847: GO 7849
7849: DISABLE
7850: LD_INT 0
7852: PPUSH
7853: PPUSH
7854: PPUSH
7855: PPUSH
7856: PPUSH
// begin enable ;
7857: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7858: LD_ADDR_VAR 0 2
7862: PUSH
7863: LD_INT 22
7865: PUSH
7866: LD_INT 3
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: LD_INT 21
7875: PUSH
7876: LD_INT 2
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: LD_INT 3
7885: PUSH
7886: LD_INT 58
7888: PUSH
7889: EMPTY
7890: LIST
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PUSH
7896: EMPTY
7897: LIST
7898: LIST
7899: LIST
7900: PPUSH
7901: CALL_OW 69
7905: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7906: LD_ADDR_VAR 0 4
7910: PUSH
7911: LD_INT 10
7913: PUSH
7914: LD_INT 11
7916: PUSH
7917: LD_INT 12
7919: PUSH
7920: LD_INT 14
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: LIST
7927: LIST
7928: ST_TO_ADDR
// area := 0 ;
7929: LD_ADDR_VAR 0 5
7933: PUSH
7934: LD_INT 0
7936: ST_TO_ADDR
// attacking := false ;
7937: LD_ADDR_VAR 0 3
7941: PUSH
7942: LD_INT 0
7944: ST_TO_ADDR
// for i in tmp do
7945: LD_ADDR_VAR 0 1
7949: PUSH
7950: LD_VAR 0 2
7954: PUSH
7955: FOR_IN
7956: IFFALSE 8042
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7958: LD_VAR 0 1
7962: PPUSH
7963: LD_INT 22
7965: PUSH
7966: LD_INT 1
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PPUSH
7973: CALL_OW 69
7977: PPUSH
7978: LD_VAR 0 1
7982: PPUSH
7983: CALL_OW 74
7987: PPUSH
7988: CALL_OW 296
7992: PUSH
7993: LD_INT 10
7995: LESS
7996: IFFALSE 8040
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7998: LD_VAR 0 1
8002: PPUSH
8003: LD_INT 22
8005: PUSH
8006: LD_INT 1
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 69
8017: PPUSH
8018: LD_VAR 0 1
8022: PPUSH
8023: CALL_OW 74
8027: PPUSH
8028: CALL_OW 115
// attacking := true ;
8032: LD_ADDR_VAR 0 3
8036: PUSH
8037: LD_INT 1
8039: ST_TO_ADDR
// end ;
8040: GO 7955
8042: POP
8043: POP
// if attacking then
8044: LD_VAR 0 3
8048: IFFALSE 8052
// exit ;
8050: GO 8259
// for i in areas do
8052: LD_ADDR_VAR 0 1
8056: PUSH
8057: LD_VAR 0 4
8061: PUSH
8062: FOR_IN
8063: IFFALSE 8100
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
8065: LD_VAR 0 1
8069: PPUSH
8070: LD_INT 22
8072: PUSH
8073: LD_INT 1
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: PPUSH
8080: CALL_OW 70
8084: IFFALSE 8098
// begin area := i ;
8086: LD_ADDR_VAR 0 5
8090: PUSH
8091: LD_VAR 0 1
8095: ST_TO_ADDR
// break ;
8096: GO 8100
// end ;
8098: GO 8062
8100: POP
8101: POP
// if area then
8102: LD_VAR 0 5
8106: IFFALSE 8259
// begin for i in tmp do
8108: LD_ADDR_VAR 0 1
8112: PUSH
8113: LD_VAR 0 2
8117: PUSH
8118: FOR_IN
8119: IFFALSE 8257
// begin if GetFuel ( i ) < 33 then
8121: LD_VAR 0 1
8125: PPUSH
8126: CALL_OW 261
8130: PUSH
8131: LD_INT 33
8133: LESS
8134: IFFALSE 8148
// SetFuel ( i , 33 ) ;
8136: LD_VAR 0 1
8140: PPUSH
8141: LD_INT 33
8143: PPUSH
8144: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
8148: LD_VAR 0 1
8152: PPUSH
8153: LD_INT 22
8155: PUSH
8156: LD_INT 1
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PPUSH
8163: CALL_OW 69
8167: PPUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 74
8177: PPUSH
8178: CALL_OW 296
8182: PUSH
8183: LD_INT 10
8185: LESS
8186: IFFALSE 8224
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8188: LD_VAR 0 1
8192: PPUSH
8193: LD_INT 22
8195: PUSH
8196: LD_INT 1
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: PPUSH
8203: CALL_OW 69
8207: PPUSH
8208: LD_VAR 0 1
8212: PPUSH
8213: CALL_OW 74
8217: PPUSH
8218: CALL_OW 115
8222: GO 8255
// if not IsInArea ( i , area ) then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 5
8233: PPUSH
8234: CALL_OW 308
8238: NOT
8239: IFFALSE 8255
// ComMoveToArea ( i , area ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_VAR 0 5
8250: PPUSH
8251: CALL_OW 113
// end ;
8255: GO 8118
8257: POP
8258: POP
// end ; end ;
8259: PPOPN 5
8261: END
// every 15 15$00 trigger Difficulty > 1 do var i , j , un , veh , time , count ;
8262: LD_OWVAR 67
8266: PUSH
8267: LD_INT 1
8269: GREATER
8270: IFFALSE 8547
8272: GO 8274
8274: DISABLE
8275: LD_INT 0
8277: PPUSH
8278: PPUSH
8279: PPUSH
8280: PPUSH
8281: PPUSH
8282: PPUSH
// begin uc_side := 3 ;
8283: LD_ADDR_OWVAR 20
8287: PUSH
8288: LD_INT 3
8290: ST_TO_ADDR
// uc_nation := 3 ;
8291: LD_ADDR_OWVAR 21
8295: PUSH
8296: LD_INT 3
8298: ST_TO_ADDR
// time := [ 9 9$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8299: LD_ADDR_VAR 0 5
8303: PUSH
8304: LD_INT 18900
8306: PUSH
8307: LD_INT 14700
8309: PUSH
8310: LD_INT 12600
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: LIST
8317: PUSH
8318: LD_OWVAR 67
8322: ARRAY
8323: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8324: LD_ADDR_VAR 0 6
8328: PUSH
8329: LD_INT 2
8331: PUSH
8332: LD_INT 2
8334: PUSH
8335: LD_INT 3
8337: PUSH
8338: EMPTY
8339: LIST
8340: LIST
8341: LIST
8342: PUSH
8343: LD_OWVAR 67
8347: ARRAY
8348: ST_TO_ADDR
// for i = 1 to count do
8349: LD_ADDR_VAR 0 1
8353: PUSH
8354: DOUBLE
8355: LD_INT 1
8357: DEC
8358: ST_TO_ADDR
8359: LD_VAR 0 6
8363: PUSH
8364: FOR_TO
8365: IFFALSE 8545
// begin wait ( time ) ;
8367: LD_VAR 0 5
8371: PPUSH
8372: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8376: LD_ADDR_VAR 0 2
8380: PUSH
8381: DOUBLE
8382: LD_INT 1
8384: DEC
8385: ST_TO_ADDR
8386: LD_INT 1
8388: PPUSH
8389: LD_OWVAR 67
8393: PPUSH
8394: CALL_OW 12
8398: PUSH
8399: FOR_TO
8400: IFFALSE 8541
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8402: LD_ADDR_VAR 0 4
8406: PUSH
8407: LD_INT 3
8409: PPUSH
8410: LD_INT 3
8412: PPUSH
8413: LD_INT 22
8415: PPUSH
8416: LD_INT 1
8418: PPUSH
8419: LD_INT 1
8421: PPUSH
8422: LD_INT 43
8424: PUSH
8425: LD_INT 44
8427: PUSH
8428: LD_INT 42
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: LIST
8435: PUSH
8436: LD_VAR 0 1
8440: PUSH
8441: LD_INT 3
8443: MOD
8444: PUSH
8445: LD_INT 1
8447: PLUS
8448: ARRAY
8449: PPUSH
8450: LD_INT 80
8452: PPUSH
8453: CALL 563 0 7
8457: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8458: LD_VAR 0 4
8462: PPUSH
8463: LD_INT 13
8465: PPUSH
8466: LD_INT 0
8468: PPUSH
8469: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8473: LD_INT 0
8475: PPUSH
8476: LD_INT 3
8478: PPUSH
8479: LD_INT 4
8481: PUSH
8482: LD_INT 5
8484: PUSH
8485: LD_INT 5
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: LIST
8492: PUSH
8493: LD_OWVAR 67
8497: ARRAY
8498: PPUSH
8499: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8503: CALL_OW 44
8507: PPUSH
8508: LD_VAR 0 4
8512: PPUSH
8513: CALL_OW 52
// wait ( 0 0$01 ) ;
8517: LD_INT 35
8519: PPUSH
8520: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8524: LD_VAR 0 4
8528: PPUSH
8529: LD_INT 143
8531: PPUSH
8532: LD_INT 143
8534: PPUSH
8535: CALL_OW 111
// end ;
8539: GO 8399
8541: POP
8542: POP
// end ;
8543: GO 8364
8545: POP
8546: POP
// end ;
8547: PPOPN 6
8549: END
// every 8 8$00 do var i , un , time ;
8550: GO 8552
8552: DISABLE
8553: LD_INT 0
8555: PPUSH
8556: PPUSH
8557: PPUSH
// begin time := [ 3 3$00 , 1 1$00 , 0 0$30 ] ;
8558: LD_ADDR_VAR 0 3
8562: PUSH
8563: LD_INT 6300
8565: PUSH
8566: LD_INT 2100
8568: PUSH
8569: LD_INT 1050
8571: PUSH
8572: EMPTY
8573: LIST
8574: LIST
8575: LIST
8576: ST_TO_ADDR
// wait ( time ) ;
8577: LD_VAR 0 3
8581: PPUSH
8582: CALL_OW 67
// uc_side := 3 ;
8586: LD_ADDR_OWVAR 20
8590: PUSH
8591: LD_INT 3
8593: ST_TO_ADDR
// uc_nation := 3 ;
8594: LD_ADDR_OWVAR 21
8598: PUSH
8599: LD_INT 3
8601: ST_TO_ADDR
// for i = 1 to 2 do
8602: LD_ADDR_VAR 0 1
8606: PUSH
8607: DOUBLE
8608: LD_INT 1
8610: DEC
8611: ST_TO_ADDR
8612: LD_INT 2
8614: PUSH
8615: FOR_TO
8616: IFFALSE 8679
// begin PrepareHuman ( false , 1 , 4 ) ;
8618: LD_INT 0
8620: PPUSH
8621: LD_INT 1
8623: PPUSH
8624: LD_INT 4
8626: PPUSH
8627: CALL_OW 380
// un := CreateHuman ;
8631: LD_ADDR_VAR 0 2
8635: PUSH
8636: CALL_OW 44
8640: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8641: LD_VAR 0 2
8645: PPUSH
8646: LD_INT 16
8648: PPUSH
8649: CALL_OW 52
// ComExitBuilding ( un ) ;
8653: LD_VAR 0 2
8657: PPUSH
8658: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8662: LD_VAR 0 2
8666: PPUSH
8667: LD_INT 41
8669: PPUSH
8670: LD_INT 76
8672: PPUSH
8673: CALL_OW 174
// end ;
8677: GO 8615
8679: POP
8680: POP
// end ; end_of_file
8681: PPOPN 3
8683: END
// export function Action ; begin
8684: LD_INT 0
8686: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8687: LD_INT 28
8689: PPUSH
8690: LD_INT 3
8692: PPUSH
8693: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8697: LD_INT 41
8699: PPUSH
8700: LD_INT 76
8702: PPUSH
8703: LD_INT 1
8705: PPUSH
8706: LD_INT 10
8708: PPUSH
8709: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8713: LD_INT 41
8715: PPUSH
8716: LD_INT 76
8718: PPUSH
8719: LD_INT 1
8721: PPUSH
8722: CALL_OW 331
// InGameOn ;
8726: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8730: LD_EXP 19
8734: PPUSH
8735: LD_STRING D2-Har-1
8737: PPUSH
8738: CALL_OW 94
// InGameOff ;
8742: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8746: LD_STRING M1
8748: PPUSH
8749: CALL_OW 337
// end ;
8753: LD_VAR 0 1
8757: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8758: LD_EXP 4
8762: PUSH
8763: LD_INT 1
8765: GREATER
8766: IFFALSE 8857
8768: GO 8770
8770: DISABLE
8771: LD_INT 0
8773: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8774: LD_ADDR_VAR 0 1
8778: PUSH
8779: LD_INT 1
8781: PPUSH
8782: CALL 651 0 1
8786: PUSH
8787: LD_INT 1
8789: ARRAY
8790: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8791: LD_VAR 0 1
8795: PPUSH
8796: LD_STRING D2a-Sol1-1
8798: PPUSH
8799: CALL_OW 88
// if not un then
8803: LD_VAR 0 1
8807: NOT
8808: IFFALSE 8839
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8810: LD_ADDR_VAR 0 1
8814: PUSH
8815: LD_INT 2
8817: PPUSH
8818: CALL 651 0 1
8822: PUSH
8823: LD_INT 1
8825: ARRAY
8826: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8827: LD_VAR 0 1
8831: PPUSH
8832: LD_STRING D2a-FSol1-1
8834: PPUSH
8835: CALL_OW 88
// end ; if Khatam then
8839: LD_EXP 17
8843: IFFALSE 8857
// Say ( Khatam , D3b-Khat-3 ) ;
8845: LD_EXP 17
8849: PPUSH
8850: LD_STRING D3b-Khat-3
8852: PPUSH
8853: CALL_OW 88
// end ;
8857: PPOPN 1
8859: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8860: LD_EXP 15
8864: PUSH
8865: LD_EXP 18
8869: NOT
8870: AND
8871: PUSH
8872: LD_INT 22
8874: PUSH
8875: LD_INT 1
8877: PUSH
8878: EMPTY
8879: LIST
8880: LIST
8881: PUSH
8882: LD_INT 92
8884: PUSH
8885: LD_EXP 15
8889: PPUSH
8890: CALL_OW 250
8894: PUSH
8895: LD_EXP 15
8899: PPUSH
8900: CALL_OW 251
8904: PUSH
8905: LD_INT 7
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: LIST
8912: LIST
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PPUSH
8918: CALL_OW 69
8922: AND
8923: PUSH
8924: LD_INT 1
8926: PPUSH
8927: CALL_OW 463
8931: NOT
8932: AND
8933: IFFALSE 9520
8935: GO 8937
8937: DISABLE
8938: LD_INT 0
8940: PPUSH
8941: PPUSH
// begin InGameOn ;
8942: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8946: LD_ADDR_VAR 0 2
8950: PUSH
8951: LD_INT 22
8953: PUSH
8954: LD_INT 0
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 25
8963: PUSH
8964: LD_INT 12
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8980: LD_ADDR_VAR 0 2
8984: PUSH
8985: LD_VAR 0 2
8989: PPUSH
8990: LD_EXP 15
8994: PPUSH
8995: CALL_OW 74
8999: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
9000: LD_ADDR_VAR 0 1
9004: PUSH
9005: LD_INT 22
9007: PUSH
9008: LD_INT 1
9010: PUSH
9011: EMPTY
9012: LIST
9013: LIST
9014: PUSH
9015: LD_INT 21
9017: PUSH
9018: LD_INT 1
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: PUSH
9025: LD_INT 91
9027: PUSH
9028: LD_EXP 15
9032: PUSH
9033: LD_INT 20
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: LIST
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: LIST
9045: PPUSH
9046: CALL_OW 69
9050: PUSH
9051: FOR_IN
9052: IFFALSE 9070
// ComTurnUnit ( i , Frank ) ;
9054: LD_VAR 0 1
9058: PPUSH
9059: LD_EXP 15
9063: PPUSH
9064: CALL_OW 119
9068: GO 9051
9070: POP
9071: POP
// SetSide ( Frank , 1 ) ;
9072: LD_EXP 15
9076: PPUSH
9077: LD_INT 1
9079: PPUSH
9080: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
9084: LD_EXP 9
9088: PPUSH
9089: LD_EXP 15
9093: PPUSH
9094: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
9098: LD_EXP 9
9102: PPUSH
9103: LD_EXP 15
9107: PPUSH
9108: CALL_OW 179
// CenterOnUnits ( Frank ) ;
9112: LD_EXP 15
9116: PPUSH
9117: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
9121: LD_EXP 15
9125: PPUSH
9126: LD_STRING D3a-Frank-1
9128: PPUSH
9129: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
9133: LD_VAR 0 2
9137: PPUSH
9138: LD_INT 42
9140: PPUSH
9141: LD_INT 78
9143: PPUSH
9144: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
9148: LD_VAR 0 2
9152: PPUSH
9153: LD_EXP 15
9157: PPUSH
9158: CALL_OW 179
// if Lisa then
9162: LD_EXP 14
9166: IFFALSE 9180
// Say ( Lisa , D3a-Lisa-1 ) ;
9168: LD_EXP 14
9172: PPUSH
9173: LD_STRING D3a-Lisa-1
9175: PPUSH
9176: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
9180: LD_EXP 9
9184: PPUSH
9185: LD_STRING D3a-JMM-1
9187: PPUSH
9188: CALL_OW 88
// if Cyrus then
9192: LD_EXP 13
9196: IFFALSE 9210
// Say ( Cyrus , D3a-Cyrus-1 ) ;
9198: LD_EXP 13
9202: PPUSH
9203: LD_STRING D3a-Cyrus-1
9205: PPUSH
9206: CALL_OW 88
// if GetRandom ( sex_male ) then
9210: LD_INT 1
9212: PPUSH
9213: CALL 651 0 1
9217: IFFALSE 9238
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
9219: LD_INT 1
9221: PPUSH
9222: CALL 651 0 1
9226: PUSH
9227: LD_INT 1
9229: ARRAY
9230: PPUSH
9231: LD_STRING D3a-Sol1-1
9233: PPUSH
9234: CALL_OW 88
// if GetRandom ( sex_female ) then
9238: LD_INT 2
9240: PPUSH
9241: CALL 651 0 1
9245: IFFALSE 9266
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
9247: LD_INT 2
9249: PPUSH
9250: CALL 651 0 1
9254: PUSH
9255: LD_INT 1
9257: ARRAY
9258: PPUSH
9259: LD_STRING D3a-FSol1-1
9261: PPUSH
9262: CALL_OW 88
// if Gladstone then
9266: LD_EXP 16
9270: IFFALSE 9284
// Say ( Gladstone , D3a-Glad-1 ) ;
9272: LD_EXP 16
9276: PPUSH
9277: LD_STRING D3a-Glad-1
9279: PPUSH
9280: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
9284: LD_VAR 0 2
9288: PPUSH
9289: LD_INT 60
9291: PPUSH
9292: LD_INT 113
9294: PPUSH
9295: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9299: LD_EXP 15
9303: PPUSH
9304: LD_STRING D3a-Frank-2
9306: PPUSH
9307: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9311: LD_EXP 15
9315: PPUSH
9316: LD_EXP 9
9320: PPUSH
9321: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9325: LD_EXP 9
9329: PPUSH
9330: LD_STRING D3a-JMM-2
9332: PPUSH
9333: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9337: LD_INT 1
9339: PPUSH
9340: LD_INT 4
9342: PPUSH
9343: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9347: LD_INT 85
9349: PPUSH
9350: LD_INT 134
9352: PPUSH
9353: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9357: LD_EXP 15
9361: PPUSH
9362: LD_STRING D3a-Frank-3
9364: PPUSH
9365: CALL_OW 88
// Wait ( 0 0$01 ) ;
9369: LD_INT 35
9371: PPUSH
9372: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9376: LD_INT 166
9378: PPUSH
9379: LD_INT 136
9381: PPUSH
9382: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9386: LD_EXP 9
9390: PPUSH
9391: LD_STRING D3a-JMM-3
9393: PPUSH
9394: CALL_OW 88
// Wait ( 0 0$01 ) ;
9398: LD_INT 35
9400: PPUSH
9401: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9405: LD_EXP 15
9409: PPUSH
9410: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9414: LD_EXP 15
9418: PPUSH
9419: LD_STRING D3a-Frank-4
9421: PPUSH
9422: CALL_OW 88
// if Lisa then
9426: LD_EXP 14
9430: IFFALSE 9444
// Say ( Lisa , D3a-Lisa-4 ) ;
9432: LD_EXP 14
9436: PPUSH
9437: LD_STRING D3a-Lisa-4
9439: PPUSH
9440: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9444: LD_EXP 9
9448: PPUSH
9449: LD_STRING D3a-JMM-4
9451: PPUSH
9452: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9456: LD_EXP 15
9460: PPUSH
9461: LD_STRING D3a-Frank-5
9463: PPUSH
9464: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9468: LD_EXP 9
9472: PPUSH
9473: LD_STRING D3a-JMM-5
9475: PPUSH
9476: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9480: LD_EXP 15
9484: PPUSH
9485: LD_STRING D3a-Frank-6
9487: PPUSH
9488: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9492: LD_EXP 9
9496: PPUSH
9497: LD_STRING D3a-JMM-6
9499: PPUSH
9500: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9504: LD_EXP 15
9508: PPUSH
9509: LD_STRING D3a-Frank-7
9511: PPUSH
9512: CALL_OW 88
// InGameOff ;
9516: CALL_OW 9
// end ;
9520: PPOPN 2
9522: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9523: LD_EXP 18
9527: PUSH
9528: LD_EXP 15
9532: NOT
9533: AND
9534: PUSH
9535: LD_INT 22
9537: PUSH
9538: LD_INT 1
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PUSH
9545: LD_INT 92
9547: PUSH
9548: LD_EXP 18
9552: PPUSH
9553: CALL_OW 250
9557: PUSH
9558: LD_EXP 18
9562: PPUSH
9563: CALL_OW 251
9567: PUSH
9568: LD_INT 7
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PPUSH
9581: CALL_OW 69
9585: AND
9586: PUSH
9587: LD_INT 1
9589: PPUSH
9590: CALL_OW 463
9594: NOT
9595: AND
9596: IFFALSE 9776
9598: GO 9600
9600: DISABLE
// begin InGameOn ;
9601: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9605: LD_EXP 9
9609: PPUSH
9610: LD_EXP 18
9614: PPUSH
9615: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9619: LD_EXP 18
9623: PPUSH
9624: LD_EXP 9
9628: PPUSH
9629: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9633: LD_EXP 18
9637: PPUSH
9638: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9642: LD_EXP 18
9646: PPUSH
9647: LD_STRING D3b-Yam-1
9649: PPUSH
9650: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9654: LD_EXP 9
9658: PPUSH
9659: LD_STRING D3b-JMM-1
9661: PPUSH
9662: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9666: LD_INT 1
9668: PPUSH
9669: LD_INT 4
9671: PPUSH
9672: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9676: LD_INT 85
9678: PPUSH
9679: LD_INT 134
9681: PPUSH
9682: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9686: LD_EXP 18
9690: PPUSH
9691: LD_STRING D3b-Yam-2
9693: PPUSH
9694: CALL_OW 88
// Wait ( 0 0$01 ) ;
9698: LD_INT 35
9700: PPUSH
9701: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9705: LD_EXP 9
9709: PPUSH
9710: LD_STRING D3b-JMM-2
9712: PPUSH
9713: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9717: LD_INT 166
9719: PPUSH
9720: LD_INT 136
9722: PPUSH
9723: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9727: LD_EXP 18
9731: PPUSH
9732: LD_STRING D3b-Yam-3
9734: PPUSH
9735: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9739: LD_EXP 9
9743: PPUSH
9744: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9748: LD_EXP 9
9752: PPUSH
9753: LD_STRING D3b-JMM-3a
9755: PPUSH
9756: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9760: LD_EXP 18
9764: PPUSH
9765: LD_INT 1
9767: PPUSH
9768: CALL_OW 235
// InGameOff ;
9772: CALL_OW 9
// end ;
9776: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9777: LD_INT 7
9779: PPUSH
9780: LD_INT 22
9782: PUSH
9783: LD_INT 1
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: PUSH
9790: LD_INT 3
9792: PUSH
9793: LD_INT 24
9795: PUSH
9796: LD_INT 1000
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PUSH
9807: EMPTY
9808: LIST
9809: LIST
9810: PPUSH
9811: CALL_OW 70
9815: IFFALSE 10271
9817: GO 9819
9819: DISABLE
9820: LD_INT 0
9822: PPUSH
9823: PPUSH
9824: PPUSH
9825: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9826: LD_INT 35
9828: PPUSH
9829: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9833: LD_ADDR_VAR 0 1
9837: PUSH
9838: LD_INT 7
9840: PPUSH
9841: LD_INT 22
9843: PUSH
9844: LD_INT 1
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: PUSH
9851: LD_INT 3
9853: PUSH
9854: LD_INT 24
9856: PUSH
9857: LD_INT 1000
9859: PUSH
9860: EMPTY
9861: LIST
9862: LIST
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: PPUSH
9872: CALL_OW 70
9876: ST_TO_ADDR
// if not un then
9877: LD_VAR 0 1
9881: NOT
9882: IFFALSE 9886
// continue ;
9884: GO 9826
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9886: LD_ADDR_VAR 0 3
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 1
9898: ARRAY
9899: PPUSH
9900: CALL 3548 0 1
9904: ST_TO_ADDR
// until tw ;
9905: LD_VAR 0 3
9909: IFFALSE 9826
// DialogueOn ;
9911: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9915: LD_VAR 0 3
9919: PPUSH
9920: CALL_OW 87
// if Lisa then
9924: LD_EXP 14
9928: IFFALSE 9956
// begin Say ( Lisa , D5-Lisa-1 ) ;
9930: LD_EXP 14
9934: PPUSH
9935: LD_STRING D5-Lisa-1
9937: PPUSH
9938: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9942: LD_EXP 9
9946: PPUSH
9947: LD_STRING D5-JMM-1a
9949: PPUSH
9950: CALL_OW 88
// end else
9954: GO 9968
// Say ( JMM , D5-JMM-1 ) ;
9956: LD_EXP 9
9960: PPUSH
9961: LD_STRING D5-JMM-1
9963: PPUSH
9964: CALL_OW 88
// DialogueOff ;
9968: CALL_OW 7
// while ( true ) do
9972: LD_INT 1
9974: IFFALSE 10030
// begin wait ( 0 0$01 ) ;
9976: LD_INT 35
9978: PPUSH
9979: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9983: LD_ADDR_VAR 0 2
9987: PUSH
9988: LD_INT 8
9990: PPUSH
9991: LD_INT 30
9993: PUSH
9994: LD_INT 26
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: LD_INT 101
10003: PUSH
10004: LD_INT 1
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PPUSH
10015: CALL_OW 71
10019: ST_TO_ADDR
// if x then
10020: LD_VAR 0 2
10024: IFFALSE 10028
// break ;
10026: GO 10030
// end ;
10028: GO 9972
// CenterOnUnits ( x [ 1 ] ) ;
10030: LD_VAR 0 2
10034: PUSH
10035: LD_INT 1
10037: ARRAY
10038: PPUSH
10039: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
10043: LD_EXP 15
10047: PUSH
10048: LD_EXP 15
10052: PPUSH
10053: CALL_OW 255
10057: PUSH
10058: LD_INT 1
10060: EQUAL
10061: AND
10062: IFFALSE 10078
// Say ( Frank , D5a-Frank-1 ) else
10064: LD_EXP 15
10068: PPUSH
10069: LD_STRING D5a-Frank-1
10071: PPUSH
10072: CALL_OW 88
10076: GO 10132
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10078: LD_EXP 18
10082: PUSH
10083: LD_EXP 18
10087: PPUSH
10088: CALL_OW 255
10092: PUSH
10093: LD_INT 1
10095: EQUAL
10096: AND
10097: IFFALSE 10113
// Say ( Kikuchi , D5a-Yam-1 ) else
10099: LD_EXP 18
10103: PPUSH
10104: LD_STRING D5a-Yam-1
10106: PPUSH
10107: CALL_OW 88
10111: GO 10132
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
10113: LD_INT 1
10115: PPUSH
10116: CALL 651 0 1
10120: PUSH
10121: LD_INT 1
10123: ARRAY
10124: PPUSH
10125: LD_STRING D5a-Sol1-1
10127: PPUSH
10128: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
10132: LD_EXP 9
10136: PPUSH
10137: LD_STRING D5a-JMM-1
10139: PPUSH
10140: CALL_OW 88
// if Cyrus then
10144: LD_EXP 13
10148: IFFALSE 10162
// Say ( Cyrus , D5a-Cyrus-1 ) ;
10150: LD_EXP 13
10154: PPUSH
10155: LD_STRING D5a-Cyrus-1
10157: PPUSH
10158: CALL_OW 88
// x := false ;
10162: LD_ADDR_VAR 0 2
10166: PUSH
10167: LD_INT 0
10169: ST_TO_ADDR
// while ( true ) do
10170: LD_INT 1
10172: IFFALSE 10259
// begin wait ( 0 0$01 ) ;
10174: LD_INT 35
10176: PPUSH
10177: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
10181: LD_ADDR_VAR 0 4
10185: PUSH
10186: LD_INT 2
10188: PUSH
10189: LD_INT 30
10191: PUSH
10192: LD_INT 0
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PUSH
10199: LD_INT 30
10201: PUSH
10202: LD_INT 1
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: LIST
10213: PPUSH
10214: CALL_OW 69
10218: PUSH
10219: LD_INT 1
10221: DIFF
10222: PUSH
10223: FOR_IN
10224: IFFALSE 10247
// if BaseNeedEnergy ( i ) then
10226: LD_VAR 0 4
10230: PPUSH
10231: CALL 2673 0 1
10235: IFFALSE 10245
// x := true ;
10237: LD_ADDR_VAR 0 2
10241: PUSH
10242: LD_INT 1
10244: ST_TO_ADDR
10245: GO 10223
10247: POP
10248: POP
// if x then
10249: LD_VAR 0 2
10253: IFFALSE 10257
// break ;
10255: GO 10259
// end ;
10257: GO 10170
// Say ( JMM , D5b-JMM-1 ) ;
10259: LD_EXP 9
10263: PPUSH
10264: LD_STRING D5b-JMM-1
10266: PPUSH
10267: CALL_OW 88
// end ;
10271: PPOPN 4
10273: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
10274: LD_EXP 5
10278: PUSH
10279: LD_INT 1
10281: ARRAY
10282: PUSH
10283: LD_OWVAR 1
10287: LESS
10288: IFFALSE 10488
10290: GO 10292
10292: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10293: LD_INT 16
10295: PPUSH
10296: CALL_OW 301
10300: NOT
10301: IFFALSE 10324
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10303: LD_EXP 19
10307: PPUSH
10308: LD_STRING D3b-Har-3
10310: PPUSH
10311: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10315: LD_STRING M2a
10317: PPUSH
10318: CALL_OW 337
// end else
10322: GO 10343
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10324: LD_EXP 19
10328: PPUSH
10329: LD_STRING D3b-Har-3a
10331: PPUSH
10332: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10336: LD_STRING M2
10338: PPUSH
10339: CALL_OW 337
// end ; can_end := true ;
10343: LD_ADDR_EXP 6
10347: PUSH
10348: LD_INT 1
10350: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10351: LD_INT 9
10353: PPUSH
10354: LD_INT 1
10356: PPUSH
10357: CALL_OW 424
// Wait ( 0 0$02 ) ;
10361: LD_INT 70
10363: PPUSH
10364: CALL_OW 67
// if Lisa then
10368: LD_EXP 14
10372: IFFALSE 10386
// Say ( Lisa , D3b-Lisa ) ;
10374: LD_EXP 14
10378: PPUSH
10379: LD_STRING D3b-Lisa
10381: PPUSH
10382: CALL_OW 88
// if Bobby then
10386: LD_EXP 12
10390: IFFALSE 10404
// Say ( Bobby , D3b-Bobby-3 ) ;
10392: LD_EXP 12
10396: PPUSH
10397: LD_STRING D3b-Bobby-3
10399: PPUSH
10400: CALL_OW 88
// if Cyrus then
10404: LD_EXP 13
10408: IFFALSE 10422
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10410: LD_EXP 13
10414: PPUSH
10415: LD_STRING D3b-Cyrus-3
10417: PPUSH
10418: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10422: LD_EXP 15
10426: PUSH
10427: LD_EXP 15
10431: PPUSH
10432: CALL_OW 255
10436: PUSH
10437: LD_INT 1
10439: EQUAL
10440: AND
10441: IFFALSE 10455
// Say ( Frank , D3b-Frank-3 ) ;
10443: LD_EXP 15
10447: PPUSH
10448: LD_STRING D3b-Frank-3
10450: PPUSH
10451: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10455: LD_EXP 18
10459: PUSH
10460: LD_EXP 18
10464: PPUSH
10465: CALL_OW 255
10469: PUSH
10470: LD_INT 1
10472: EQUAL
10473: AND
10474: IFFALSE 10488
// Say ( Kikuchi , D3b-Yam-4 ) ;
10476: LD_EXP 18
10480: PPUSH
10481: LD_STRING D3b-Yam-4
10483: PPUSH
10484: CALL_OW 88
// end ;
10488: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10489: LD_EXP 5
10493: PUSH
10494: LD_INT 2
10496: ARRAY
10497: PUSH
10498: LD_OWVAR 1
10502: LESS
10503: IFFALSE 10535
10505: GO 10507
10507: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10508: LD_EXP 19
10512: PPUSH
10513: LD_STRING D4-Har-1
10515: PPUSH
10516: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10520: LD_STRING M3
10522: PPUSH
10523: CALL_OW 337
// must_end := true ;
10527: LD_ADDR_EXP 7
10531: PUSH
10532: LD_INT 1
10534: ST_TO_ADDR
// end ;
10535: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10536: LD_EXP 5
10540: PUSH
10541: LD_INT 3
10543: ARRAY
10544: PUSH
10545: LD_OWVAR 1
10549: LESS
10550: IFFALSE 10581
10552: GO 10554
10554: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10555: LD_INT 16
10557: PPUSH
10558: CALL_OW 301
10562: NOT
10563: IFFALSE 10574
// YouLost ( TimeOut1 ) else
10565: LD_STRING TimeOut1
10567: PPUSH
10568: CALL_OW 104
10572: GO 10581
// YouLost ( TimeOut2 ) ;
10574: LD_STRING TimeOut2
10576: PPUSH
10577: CALL_OW 104
// end ;
10581: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp , m1 , m2 , m3 ;
10582: LD_EXP 9
10586: PPUSH
10587: LD_INT 9
10589: PPUSH
10590: CALL_OW 308
10594: PUSH
10595: LD_EXP 6
10599: AND
10600: IFFALSE 11700
10602: GO 10604
10604: DISABLE
10605: LD_INT 0
10607: PPUSH
10608: PPUSH
10609: PPUSH
10610: PPUSH
10611: PPUSH
10612: PPUSH
// begin wait_on := false ;
10613: LD_ADDR_VAR 0 1
10617: PUSH
10618: LD_INT 0
10620: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10621: LD_INT 1
10623: PPUSH
10624: CALL 2750 0 1
10628: PUSH
10629: LD_INT 0
10631: PLUS
10632: PUSH
10633: LD_INT 1
10635: PPUSH
10636: LD_INT 9
10638: PPUSH
10639: CALL 2841 0 2
10643: PUSH
10644: LD_INT 1
10646: PPUSH
10647: LD_INT 9
10649: PPUSH
10650: CALL 2888 0 2
10654: ADD
10655: PUSH
10656: LD_INT 0
10658: PLUS
10659: GREATER
10660: IFFALSE 10709
// case Query ( Q1 ) of 1 :
10662: LD_STRING Q1
10664: PPUSH
10665: CALL_OW 97
10669: PUSH
10670: LD_INT 1
10672: DOUBLE
10673: EQUAL
10674: IFTRUE 10678
10676: GO 10689
10678: POP
// wait_on := true ; 2 :
10679: LD_ADDR_VAR 0 1
10683: PUSH
10684: LD_INT 1
10686: ST_TO_ADDR
10687: GO 10709
10689: LD_INT 2
10691: DOUBLE
10692: EQUAL
10693: IFTRUE 10697
10695: GO 10708
10697: POP
// wait_on := false ; end ;
10698: LD_ADDR_VAR 0 1
10702: PUSH
10703: LD_INT 0
10705: ST_TO_ADDR
10706: GO 10709
10708: POP
// repeat wait ( 0 0$01 ) ;
10709: LD_INT 35
10711: PPUSH
10712: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10716: LD_VAR 0 1
10720: NOT
10721: PUSH
10722: LD_INT 1
10724: PPUSH
10725: CALL 2750 0 1
10729: PUSH
10730: LD_INT 0
10732: PLUS
10733: PUSH
10734: LD_INT 1
10736: PPUSH
10737: LD_INT 9
10739: PPUSH
10740: CALL 2841 0 2
10744: PUSH
10745: LD_INT 1
10747: PPUSH
10748: LD_INT 9
10750: PPUSH
10751: CALL 2888 0 2
10755: ADD
10756: PUSH
10757: LD_INT 0
10759: PLUS
10760: EQUAL
10761: OR
10762: IFFALSE 10709
// DialogueOn ;
10764: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10768: LD_EXP 9
10772: PPUSH
10773: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10777: LD_EXP 9
10781: PPUSH
10782: LD_STRING D6-JMM-1
10784: PPUSH
10785: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10789: LD_EXP 19
10793: PPUSH
10794: LD_STRING D6-Har-1
10796: PPUSH
10797: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10801: LD_EXP 9
10805: PPUSH
10806: LD_STRING D6-JMM-2
10808: PPUSH
10809: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10813: LD_EXP 19
10817: PPUSH
10818: LD_STRING D6-Har-2
10820: PPUSH
10821: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10825: LD_EXP 9
10829: PPUSH
10830: LD_STRING D6-JMM-3
10832: PPUSH
10833: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10837: LD_EXP 19
10841: PPUSH
10842: LD_STRING D6-Har-3
10844: PPUSH
10845: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10849: LD_EXP 9
10853: PPUSH
10854: LD_STRING D6-JMM-4
10856: PPUSH
10857: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10861: LD_EXP 19
10865: PPUSH
10866: LD_STRING D6-Har-4
10868: PPUSH
10869: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10873: LD_EXP 9
10877: PPUSH
10878: LD_STRING D6-JMM-5
10880: PPUSH
10881: CALL_OW 88
// DialogueOff ;
10885: CALL_OW 7
// m1 := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// m2 := false ;
10897: LD_ADDR_VAR 0 5
10901: PUSH
10902: LD_INT 0
10904: ST_TO_ADDR
// m3 := false ;
10905: LD_ADDR_VAR 0 6
10909: PUSH
10910: LD_INT 0
10912: ST_TO_ADDR
// tmp := FilterBuildings ( 3 ) ;
10913: LD_ADDR_VAR 0 3
10917: PUSH
10918: LD_INT 3
10920: PPUSH
10921: CALL 3019 0 1
10925: ST_TO_ADDR
// if tmp >= 35 then
10926: LD_VAR 0 3
10930: PUSH
10931: LD_INT 35
10933: GREATEREQUAL
10934: IFFALSE 10971
// begin AddMedal ( Destroy1 , - 1 ) ;
10936: LD_STRING Destroy1
10938: PPUSH
10939: LD_INT 1
10941: NEG
10942: PPUSH
10943: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10947: LD_STRING Destroy2
10949: PPUSH
10950: LD_INT 1
10952: NEG
10953: PPUSH
10954: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10958: LD_STRING Destroy3
10960: PPUSH
10961: LD_INT 1
10963: NEG
10964: PPUSH
10965: CALL_OW 101
// end else
10969: GO 11082
// begin AddMedal ( Destroy1 , 1 ) ;
10971: LD_STRING Destroy1
10973: PPUSH
10974: LD_INT 1
10976: PPUSH
10977: CALL_OW 101
// m1 := true ;
10981: LD_ADDR_VAR 0 4
10985: PUSH
10986: LD_INT 1
10988: ST_TO_ADDR
// if tmp >= 25 then
10989: LD_VAR 0 3
10993: PUSH
10994: LD_INT 25
10996: GREATEREQUAL
10997: IFFALSE 11023
// begin AddMedal ( Destroy2 , - 1 ) ;
10999: LD_STRING Destroy2
11001: PPUSH
11002: LD_INT 1
11004: NEG
11005: PPUSH
11006: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
11010: LD_STRING Destroy3
11012: PPUSH
11013: LD_INT 1
11015: NEG
11016: PPUSH
11017: CALL_OW 101
// end else
11021: GO 11082
// begin AddMedal ( Destroy2 , 1 ) ;
11023: LD_STRING Destroy2
11025: PPUSH
11026: LD_INT 1
11028: PPUSH
11029: CALL_OW 101
// m2 := true ;
11033: LD_ADDR_VAR 0 5
11037: PUSH
11038: LD_INT 1
11040: ST_TO_ADDR
// if tmp >= 15 then
11041: LD_VAR 0 3
11045: PUSH
11046: LD_INT 15
11048: GREATEREQUAL
11049: IFFALSE 11064
// AddMedal ( Destroy3 , - 1 ) else
11051: LD_STRING Destroy3
11053: PPUSH
11054: LD_INT 1
11056: NEG
11057: PPUSH
11058: CALL_OW 101
11062: GO 11082
// begin AddMedal ( Destroy3 , 1 ) ;
11064: LD_STRING Destroy3
11066: PPUSH
11067: LD_INT 1
11069: PPUSH
11070: CALL_OW 101
// m3 := true ;
11074: LD_ADDR_VAR 0 6
11078: PUSH
11079: LD_INT 1
11081: ST_TO_ADDR
// end ; end ; end ; if tick <= 32 32$00 then
11082: LD_OWVAR 1
11086: PUSH
11087: LD_INT 67200
11089: LESSEQUAL
11090: IFFALSE 11099
// SetAchievement ( ACH_ASPEED_7 ) ;
11092: LD_STRING ACH_ASPEED_7
11094: PPUSH
11095: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
11099: LD_VAR 0 4
11103: PUSH
11104: LD_VAR 0 5
11108: AND
11109: PUSH
11110: LD_VAR 0 6
11114: AND
11115: PUSH
11116: LD_OWVAR 67
11120: PUSH
11121: LD_INT 3
11123: EQUAL
11124: AND
11125: IFFALSE 11137
// SetAchievementEX ( ACH_AMER , 7 ) ;
11127: LD_STRING ACH_AMER
11129: PPUSH
11130: LD_INT 7
11132: PPUSH
11133: CALL_OW 564
// GiveMedals ( MAIN ) ;
11137: LD_STRING MAIN
11139: PPUSH
11140: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
11144: LD_ADDR_VAR 0 3
11148: PUSH
11149: LD_INT 1
11151: PPUSH
11152: LD_INT 9
11154: PPUSH
11155: CALL 2841 0 2
11159: PUSH
11160: LD_INT 1
11162: PPUSH
11163: LD_INT 9
11165: PPUSH
11166: CALL 2888 0 2
11170: UNION
11171: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11172: LD_VAR 0 3
11176: PPUSH
11177: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11181: LD_EXP 9
11185: PPUSH
11186: LD_EXP 3
11190: PUSH
11191: LD_STRING JMM
11193: STR
11194: PPUSH
11195: CALL_OW 38
// if Brown in tmp then
11199: LD_EXP 10
11203: PUSH
11204: LD_VAR 0 3
11208: IN
11209: IFFALSE 11229
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
11211: LD_EXP 10
11215: PPUSH
11216: LD_EXP 3
11220: PUSH
11221: LD_STRING Brown
11223: STR
11224: PPUSH
11225: CALL_OW 38
// if Donaldson in tmp then
11229: LD_EXP 11
11233: PUSH
11234: LD_VAR 0 3
11238: IN
11239: IFFALSE 11259
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
11241: LD_EXP 11
11245: PPUSH
11246: LD_EXP 3
11250: PUSH
11251: LD_STRING Donaldson
11253: STR
11254: PPUSH
11255: CALL_OW 38
// if Bobby in tmp then
11259: LD_EXP 12
11263: PUSH
11264: LD_VAR 0 3
11268: IN
11269: IFFALSE 11289
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11271: LD_EXP 12
11275: PPUSH
11276: LD_EXP 3
11280: PUSH
11281: LD_STRING Bobby
11283: STR
11284: PPUSH
11285: CALL_OW 38
// if Cyrus in tmp then
11289: LD_EXP 13
11293: PUSH
11294: LD_VAR 0 3
11298: IN
11299: IFFALSE 11319
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11301: LD_EXP 13
11305: PPUSH
11306: LD_EXP 3
11310: PUSH
11311: LD_STRING Cyrus
11313: STR
11314: PPUSH
11315: CALL_OW 38
// if Lisa in tmp then
11319: LD_EXP 14
11323: PUSH
11324: LD_VAR 0 3
11328: IN
11329: IFFALSE 11349
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11331: LD_EXP 14
11335: PPUSH
11336: LD_EXP 3
11340: PUSH
11341: LD_STRING Lisa
11343: STR
11344: PPUSH
11345: CALL_OW 38
// if Frank in tmp then
11349: LD_EXP 15
11353: PUSH
11354: LD_VAR 0 3
11358: IN
11359: IFFALSE 11379
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11361: LD_EXP 15
11365: PPUSH
11366: LD_EXP 3
11370: PUSH
11371: LD_STRING Frank
11373: STR
11374: PPUSH
11375: CALL_OW 38
// if Gladstone in tmp then
11379: LD_EXP 16
11383: PUSH
11384: LD_VAR 0 3
11388: IN
11389: IFFALSE 11409
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
11391: LD_EXP 16
11395: PPUSH
11396: LD_EXP 3
11400: PUSH
11401: LD_STRING Gladstone
11403: STR
11404: PPUSH
11405: CALL_OW 38
// if Khatam in tmp then
11409: LD_EXP 17
11413: PUSH
11414: LD_VAR 0 3
11418: IN
11419: IFFALSE 11439
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11421: LD_EXP 17
11425: PPUSH
11426: LD_EXP 3
11430: PUSH
11431: LD_STRING Khatam
11433: STR
11434: PPUSH
11435: CALL_OW 38
// if Kikuchi in tmp then
11439: LD_EXP 18
11443: PUSH
11444: LD_VAR 0 3
11448: IN
11449: IFFALSE 11469
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11451: LD_EXP 18
11455: PPUSH
11456: LD_EXP 3
11460: PUSH
11461: LD_STRING Kikuchi
11463: STR
11464: PPUSH
11465: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11469: LD_VAR 0 3
11473: PUSH
11474: LD_EXP 9
11478: PUSH
11479: LD_EXP 10
11483: PUSH
11484: LD_EXP 11
11488: PUSH
11489: LD_EXP 12
11493: PUSH
11494: LD_EXP 13
11498: PUSH
11499: LD_EXP 14
11503: PUSH
11504: LD_EXP 15
11508: PUSH
11509: LD_EXP 16
11513: PUSH
11514: LD_EXP 18
11518: PUSH
11519: LD_EXP 17
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: DIFF
11536: PPUSH
11537: LD_EXP 3
11541: PUSH
11542: LD_STRING others
11544: STR
11545: PPUSH
11546: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11550: LD_OWVAR 1
11554: PPUSH
11555: LD_STRING 07_time
11557: PPUSH
11558: CALL_OW 39
// tmp := [ ] ;
11562: LD_ADDR_VAR 0 3
11566: PUSH
11567: EMPTY
11568: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11569: LD_ADDR_VAR 0 2
11573: PUSH
11574: LD_INT 9
11576: PPUSH
11577: LD_INT 22
11579: PUSH
11580: LD_INT 1
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 23
11589: PUSH
11590: LD_INT 1
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 21
11599: PUSH
11600: LD_INT 2
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: PPUSH
11615: CALL_OW 70
11619: PUSH
11620: FOR_IN
11621: IFFALSE 11682
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11623: LD_ADDR_VAR 0 3
11627: PUSH
11628: LD_VAR 0 3
11632: PUSH
11633: LD_VAR 0 2
11637: PPUSH
11638: CALL_OW 265
11642: PUSH
11643: LD_VAR 0 2
11647: PPUSH
11648: CALL_OW 262
11652: PUSH
11653: LD_VAR 0 2
11657: PPUSH
11658: CALL_OW 263
11662: PUSH
11663: LD_VAR 0 2
11667: PPUSH
11668: CALL_OW 264
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: LIST
11677: LIST
11678: ADD
11679: ST_TO_ADDR
11680: GO 11620
11682: POP
11683: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11684: LD_VAR 0 3
11688: PPUSH
11689: LD_STRING 07_vehicles
11691: PPUSH
11692: CALL_OW 39
// YouWin ;
11696: CALL_OW 103
// end ; end_of_file
11700: PPOPN 6
11702: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11703: LD_VAR 0 1
11707: PUSH
11708: LD_EXP 9
11712: EQUAL
11713: IFFALSE 11722
// YouLost ( JMM ) ;
11715: LD_STRING JMM
11717: PPUSH
11718: CALL_OW 104
// if GetType ( un ) = unit_building then
11722: LD_VAR 0 1
11726: PPUSH
11727: CALL_OW 247
11731: PUSH
11732: LD_INT 3
11734: EQUAL
11735: IFFALSE 11751
// buildings_counter := buildings_counter + 1 ;
11737: LD_ADDR_EXP 4
11741: PUSH
11742: LD_EXP 4
11746: PUSH
11747: LD_INT 1
11749: PLUS
11750: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11751: LD_VAR 0 1
11755: PUSH
11756: LD_INT 6
11758: PPUSH
11759: LD_INT 2
11761: PUSH
11762: LD_INT 30
11764: PUSH
11765: LD_INT 33
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 30
11774: PUSH
11775: LD_INT 32
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: PPUSH
11787: CALL_OW 70
11791: IN
11792: IFFALSE 11851
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11794: LD_ADDR_EXP 20
11798: PUSH
11799: LD_EXP 20
11803: PUSH
11804: LD_VAR 0 1
11808: PPUSH
11809: CALL_OW 266
11813: PUSH
11814: LD_VAR 0 1
11818: PPUSH
11819: CALL_OW 250
11823: PUSH
11824: LD_VAR 0 1
11828: PPUSH
11829: CALL_OW 251
11833: PUSH
11834: LD_VAR 0 1
11838: PPUSH
11839: CALL_OW 254
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: ADD
11850: ST_TO_ADDR
// if un = ru_dep_main then
11851: LD_VAR 0 1
11855: PUSH
11856: LD_INT 16
11858: EQUAL
11859: IFFALSE 11868
// ChangeMissionObjectives ( M1a ) ;
11861: LD_STRING M1a
11863: PPUSH
11864: CALL_OW 337
// if GetType ( un ) = unit_human and GetSide ( un ) = 3 then
11868: LD_VAR 0 1
11872: PPUSH
11873: CALL_OW 247
11877: PUSH
11878: LD_INT 1
11880: EQUAL
11881: PUSH
11882: LD_VAR 0 1
11886: PPUSH
11887: CALL_OW 255
11891: PUSH
11892: LD_INT 3
11894: EQUAL
11895: AND
11896: IFFALSE 11912
// kill_counter := kill_counter + 1 ;
11898: LD_ADDR_EXP 8
11902: PUSH
11903: LD_EXP 8
11907: PUSH
11908: LD_INT 1
11910: PLUS
11911: ST_TO_ADDR
// end ;
11912: PPOPN 1
11914: END
// on BuildingStarted ( b , builder ) do var i ;
11915: LD_INT 0
11917: PPUSH
// begin if GetSide ( b ) = 3 then
11918: LD_VAR 0 1
11922: PPUSH
11923: CALL_OW 255
11927: PUSH
11928: LD_INT 3
11930: EQUAL
11931: IFFALSE 11971
// for i = 1 to 4 do
11933: LD_ADDR_VAR 0 3
11937: PUSH
11938: DOUBLE
11939: LD_INT 1
11941: DEC
11942: ST_TO_ADDR
11943: LD_INT 4
11945: PUSH
11946: FOR_TO
11947: IFFALSE 11969
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11949: LD_ADDR_EXP 20
11953: PUSH
11954: LD_EXP 20
11958: PPUSH
11959: LD_INT 1
11961: PPUSH
11962: CALL_OW 3
11966: ST_TO_ADDR
11967: GO 11946
11969: POP
11970: POP
// end ;
11971: PPOPN 3
11973: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11974: LD_VAR 0 1
11978: PPUSH
11979: CALL_OW 266
11983: PUSH
11984: LD_INT 32
11986: PUSH
11987: LD_INT 33
11989: PUSH
11990: EMPTY
11991: LIST
11992: LIST
11993: IN
11994: IFFALSE 12008
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11996: LD_VAR 0 1
12000: PPUSH
12001: LD_INT 43
12003: PPUSH
12004: CALL_OW 148
12008: PPOPN 1
12010: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
12011: LD_VAR 0 1
12015: PUSH
12016: LD_INT 22
12018: PUSH
12019: LD_INT 3
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: PUSH
12026: LD_INT 2
12028: PUSH
12029: LD_INT 30
12031: PUSH
12032: LD_INT 31
12034: PUSH
12035: EMPTY
12036: LIST
12037: LIST
12038: PUSH
12039: LD_INT 30
12041: PUSH
12042: LD_INT 32
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: LIST
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PPUSH
12058: CALL_OW 69
12062: IN
12063: IFFALSE 12085
// GoToAnotherTower ( un , b , 143 , 143 ) ;
12065: LD_VAR 0 2
12069: PPUSH
12070: LD_VAR 0 1
12074: PPUSH
12075: LD_INT 143
12077: PPUSH
12078: LD_INT 143
12080: PPUSH
12081: CALL 2200 0 4
// end ;
12085: PPOPN 2
12087: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
12088: LD_VAR 0 1
12092: PUSH
12093: LD_INT 22
12095: PUSH
12096: LD_INT 3
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 30
12105: PUSH
12106: LD_INT 32
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PPUSH
12117: CALL_OW 69
12121: IN
12122: IFFALSE 12136
// SetTag ( b , 0 ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_INT 0
12131: PPUSH
12132: CALL_OW 109
// end ; end_of_file
12136: PPOPN 2
12138: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
12139: GO 12141
12141: DISABLE
// begin ru_radar := 98 ;
12142: LD_ADDR_EXP 21
12146: PUSH
12147: LD_INT 98
12149: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
12150: LD_ADDR_EXP 22
12154: PUSH
12155: LD_INT 89
12157: ST_TO_ADDR
// us_hack := 99 ;
12158: LD_ADDR_EXP 23
12162: PUSH
12163: LD_INT 99
12165: ST_TO_ADDR
// us_artillery := 97 ;
12166: LD_ADDR_EXP 24
12170: PUSH
12171: LD_INT 97
12173: ST_TO_ADDR
// ar_bio_bomb := 91 ;
12174: LD_ADDR_EXP 25
12178: PUSH
12179: LD_INT 91
12181: ST_TO_ADDR
// end ; end_of_file end_of_file
12182: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
12183: GO 12185
12185: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
12186: LD_STRING initStreamRollete();
12188: PPUSH
12189: CALL_OW 559
// InitStreamMode ;
12193: CALL 12202 0 0
// DefineStreamItems ( ) ;
12197: CALL 12642 0 0
// end ;
12201: END
// function InitStreamMode ; begin
12202: LD_INT 0
12204: PPUSH
// streamModeActive := false ;
12205: LD_ADDR_EXP 26
12209: PUSH
12210: LD_INT 0
12212: ST_TO_ADDR
// normalCounter := 36 ;
12213: LD_ADDR_EXP 27
12217: PUSH
12218: LD_INT 36
12220: ST_TO_ADDR
// hardcoreCounter := 16 ;
12221: LD_ADDR_EXP 28
12225: PUSH
12226: LD_INT 16
12228: ST_TO_ADDR
// sRocket := false ;
12229: LD_ADDR_EXP 31
12233: PUSH
12234: LD_INT 0
12236: ST_TO_ADDR
// sSpeed := false ;
12237: LD_ADDR_EXP 30
12241: PUSH
12242: LD_INT 0
12244: ST_TO_ADDR
// sEngine := false ;
12245: LD_ADDR_EXP 32
12249: PUSH
12250: LD_INT 0
12252: ST_TO_ADDR
// sSpec := false ;
12253: LD_ADDR_EXP 29
12257: PUSH
12258: LD_INT 0
12260: ST_TO_ADDR
// sLevel := false ;
12261: LD_ADDR_EXP 33
12265: PUSH
12266: LD_INT 0
12268: ST_TO_ADDR
// sArmoury := false ;
12269: LD_ADDR_EXP 34
12273: PUSH
12274: LD_INT 0
12276: ST_TO_ADDR
// sRadar := false ;
12277: LD_ADDR_EXP 35
12281: PUSH
12282: LD_INT 0
12284: ST_TO_ADDR
// sBunker := false ;
12285: LD_ADDR_EXP 36
12289: PUSH
12290: LD_INT 0
12292: ST_TO_ADDR
// sHack := false ;
12293: LD_ADDR_EXP 37
12297: PUSH
12298: LD_INT 0
12300: ST_TO_ADDR
// sFire := false ;
12301: LD_ADDR_EXP 38
12305: PUSH
12306: LD_INT 0
12308: ST_TO_ADDR
// sRefresh := false ;
12309: LD_ADDR_EXP 39
12313: PUSH
12314: LD_INT 0
12316: ST_TO_ADDR
// sExp := false ;
12317: LD_ADDR_EXP 40
12321: PUSH
12322: LD_INT 0
12324: ST_TO_ADDR
// sDepot := false ;
12325: LD_ADDR_EXP 41
12329: PUSH
12330: LD_INT 0
12332: ST_TO_ADDR
// sFlag := false ;
12333: LD_ADDR_EXP 42
12337: PUSH
12338: LD_INT 0
12340: ST_TO_ADDR
// sKamikadze := false ;
12341: LD_ADDR_EXP 50
12345: PUSH
12346: LD_INT 0
12348: ST_TO_ADDR
// sTroll := false ;
12349: LD_ADDR_EXP 51
12353: PUSH
12354: LD_INT 0
12356: ST_TO_ADDR
// sSlow := false ;
12357: LD_ADDR_EXP 52
12361: PUSH
12362: LD_INT 0
12364: ST_TO_ADDR
// sLack := false ;
12365: LD_ADDR_EXP 53
12369: PUSH
12370: LD_INT 0
12372: ST_TO_ADDR
// sTank := false ;
12373: LD_ADDR_EXP 55
12377: PUSH
12378: LD_INT 0
12380: ST_TO_ADDR
// sRemote := false ;
12381: LD_ADDR_EXP 56
12385: PUSH
12386: LD_INT 0
12388: ST_TO_ADDR
// sPowell := false ;
12389: LD_ADDR_EXP 57
12393: PUSH
12394: LD_INT 0
12396: ST_TO_ADDR
// sTeleport := false ;
12397: LD_ADDR_EXP 60
12401: PUSH
12402: LD_INT 0
12404: ST_TO_ADDR
// sOilTower := false ;
12405: LD_ADDR_EXP 62
12409: PUSH
12410: LD_INT 0
12412: ST_TO_ADDR
// sShovel := false ;
12413: LD_ADDR_EXP 63
12417: PUSH
12418: LD_INT 0
12420: ST_TO_ADDR
// sSheik := false ;
12421: LD_ADDR_EXP 64
12425: PUSH
12426: LD_INT 0
12428: ST_TO_ADDR
// sEarthquake := false ;
12429: LD_ADDR_EXP 66
12433: PUSH
12434: LD_INT 0
12436: ST_TO_ADDR
// sAI := false ;
12437: LD_ADDR_EXP 67
12441: PUSH
12442: LD_INT 0
12444: ST_TO_ADDR
// sCargo := false ;
12445: LD_ADDR_EXP 70
12449: PUSH
12450: LD_INT 0
12452: ST_TO_ADDR
// sDLaser := false ;
12453: LD_ADDR_EXP 71
12457: PUSH
12458: LD_INT 0
12460: ST_TO_ADDR
// sExchange := false ;
12461: LD_ADDR_EXP 72
12465: PUSH
12466: LD_INT 0
12468: ST_TO_ADDR
// sFac := false ;
12469: LD_ADDR_EXP 73
12473: PUSH
12474: LD_INT 0
12476: ST_TO_ADDR
// sPower := false ;
12477: LD_ADDR_EXP 74
12481: PUSH
12482: LD_INT 0
12484: ST_TO_ADDR
// sRandom := false ;
12485: LD_ADDR_EXP 75
12489: PUSH
12490: LD_INT 0
12492: ST_TO_ADDR
// sShield := false ;
12493: LD_ADDR_EXP 76
12497: PUSH
12498: LD_INT 0
12500: ST_TO_ADDR
// sTime := false ;
12501: LD_ADDR_EXP 77
12505: PUSH
12506: LD_INT 0
12508: ST_TO_ADDR
// sTools := false ;
12509: LD_ADDR_EXP 78
12513: PUSH
12514: LD_INT 0
12516: ST_TO_ADDR
// sSold := false ;
12517: LD_ADDR_EXP 43
12521: PUSH
12522: LD_INT 0
12524: ST_TO_ADDR
// sDiff := false ;
12525: LD_ADDR_EXP 44
12529: PUSH
12530: LD_INT 0
12532: ST_TO_ADDR
// sFog := false ;
12533: LD_ADDR_EXP 47
12537: PUSH
12538: LD_INT 0
12540: ST_TO_ADDR
// sReset := false ;
12541: LD_ADDR_EXP 48
12545: PUSH
12546: LD_INT 0
12548: ST_TO_ADDR
// sSun := false ;
12549: LD_ADDR_EXP 49
12553: PUSH
12554: LD_INT 0
12556: ST_TO_ADDR
// sTiger := false ;
12557: LD_ADDR_EXP 45
12561: PUSH
12562: LD_INT 0
12564: ST_TO_ADDR
// sBomb := false ;
12565: LD_ADDR_EXP 46
12569: PUSH
12570: LD_INT 0
12572: ST_TO_ADDR
// sWound := false ;
12573: LD_ADDR_EXP 54
12577: PUSH
12578: LD_INT 0
12580: ST_TO_ADDR
// sBetray := false ;
12581: LD_ADDR_EXP 58
12585: PUSH
12586: LD_INT 0
12588: ST_TO_ADDR
// sContamin := false ;
12589: LD_ADDR_EXP 59
12593: PUSH
12594: LD_INT 0
12596: ST_TO_ADDR
// sOil := false ;
12597: LD_ADDR_EXP 61
12601: PUSH
12602: LD_INT 0
12604: ST_TO_ADDR
// sStu := false ;
12605: LD_ADDR_EXP 65
12609: PUSH
12610: LD_INT 0
12612: ST_TO_ADDR
// sBazooka := false ;
12613: LD_ADDR_EXP 68
12617: PUSH
12618: LD_INT 0
12620: ST_TO_ADDR
// sMortar := false ;
12621: LD_ADDR_EXP 69
12625: PUSH
12626: LD_INT 0
12628: ST_TO_ADDR
// sRanger := false ;
12629: LD_ADDR_EXP 79
12633: PUSH
12634: LD_INT 0
12636: ST_TO_ADDR
// end ;
12637: LD_VAR 0 1
12641: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12642: LD_INT 0
12644: PPUSH
12645: PPUSH
12646: PPUSH
12647: PPUSH
12648: PPUSH
// result := [ ] ;
12649: LD_ADDR_VAR 0 1
12653: PUSH
12654: EMPTY
12655: ST_TO_ADDR
// if campaign_id = 1 then
12656: LD_OWVAR 69
12660: PUSH
12661: LD_INT 1
12663: EQUAL
12664: IFFALSE 15602
// begin case mission_number of 1 :
12666: LD_OWVAR 70
12670: PUSH
12671: LD_INT 1
12673: DOUBLE
12674: EQUAL
12675: IFTRUE 12679
12677: GO 12743
12679: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12680: LD_ADDR_VAR 0 1
12684: PUSH
12685: LD_INT 2
12687: PUSH
12688: LD_INT 4
12690: PUSH
12691: LD_INT 11
12693: PUSH
12694: LD_INT 12
12696: PUSH
12697: LD_INT 15
12699: PUSH
12700: LD_INT 16
12702: PUSH
12703: LD_INT 22
12705: PUSH
12706: LD_INT 23
12708: PUSH
12709: LD_INT 26
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: LIST
12716: LIST
12717: LIST
12718: LIST
12719: LIST
12720: LIST
12721: LIST
12722: PUSH
12723: LD_INT 101
12725: PUSH
12726: LD_INT 102
12728: PUSH
12729: LD_INT 106
12731: PUSH
12732: EMPTY
12733: LIST
12734: LIST
12735: LIST
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: ST_TO_ADDR
12741: GO 15600
12743: LD_INT 2
12745: DOUBLE
12746: EQUAL
12747: IFTRUE 12751
12749: GO 12823
12751: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12752: LD_ADDR_VAR 0 1
12756: PUSH
12757: LD_INT 2
12759: PUSH
12760: LD_INT 4
12762: PUSH
12763: LD_INT 11
12765: PUSH
12766: LD_INT 12
12768: PUSH
12769: LD_INT 15
12771: PUSH
12772: LD_INT 16
12774: PUSH
12775: LD_INT 22
12777: PUSH
12778: LD_INT 23
12780: PUSH
12781: LD_INT 26
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 101
12797: PUSH
12798: LD_INT 102
12800: PUSH
12801: LD_INT 105
12803: PUSH
12804: LD_INT 106
12806: PUSH
12807: LD_INT 108
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: ST_TO_ADDR
12821: GO 15600
12823: LD_INT 3
12825: DOUBLE
12826: EQUAL
12827: IFTRUE 12831
12829: GO 12907
12831: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12832: LD_ADDR_VAR 0 1
12836: PUSH
12837: LD_INT 2
12839: PUSH
12840: LD_INT 4
12842: PUSH
12843: LD_INT 5
12845: PUSH
12846: LD_INT 11
12848: PUSH
12849: LD_INT 12
12851: PUSH
12852: LD_INT 15
12854: PUSH
12855: LD_INT 16
12857: PUSH
12858: LD_INT 22
12860: PUSH
12861: LD_INT 26
12863: PUSH
12864: LD_INT 36
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: PUSH
12879: LD_INT 101
12881: PUSH
12882: LD_INT 102
12884: PUSH
12885: LD_INT 105
12887: PUSH
12888: LD_INT 106
12890: PUSH
12891: LD_INT 108
12893: PUSH
12894: EMPTY
12895: LIST
12896: LIST
12897: LIST
12898: LIST
12899: LIST
12900: PUSH
12901: EMPTY
12902: LIST
12903: LIST
12904: ST_TO_ADDR
12905: GO 15600
12907: LD_INT 4
12909: DOUBLE
12910: EQUAL
12911: IFTRUE 12915
12913: GO 12999
12915: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12916: LD_ADDR_VAR 0 1
12920: PUSH
12921: LD_INT 2
12923: PUSH
12924: LD_INT 4
12926: PUSH
12927: LD_INT 5
12929: PUSH
12930: LD_INT 8
12932: PUSH
12933: LD_INT 11
12935: PUSH
12936: LD_INT 12
12938: PUSH
12939: LD_INT 15
12941: PUSH
12942: LD_INT 16
12944: PUSH
12945: LD_INT 22
12947: PUSH
12948: LD_INT 23
12950: PUSH
12951: LD_INT 26
12953: PUSH
12954: LD_INT 36
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: PUSH
12971: LD_INT 101
12973: PUSH
12974: LD_INT 102
12976: PUSH
12977: LD_INT 105
12979: PUSH
12980: LD_INT 106
12982: PUSH
12983: LD_INT 108
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: PUSH
12993: EMPTY
12994: LIST
12995: LIST
12996: ST_TO_ADDR
12997: GO 15600
12999: LD_INT 5
13001: DOUBLE
13002: EQUAL
13003: IFTRUE 13007
13005: GO 13107
13007: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
13008: LD_ADDR_VAR 0 1
13012: PUSH
13013: LD_INT 2
13015: PUSH
13016: LD_INT 4
13018: PUSH
13019: LD_INT 5
13021: PUSH
13022: LD_INT 6
13024: PUSH
13025: LD_INT 8
13027: PUSH
13028: LD_INT 11
13030: PUSH
13031: LD_INT 12
13033: PUSH
13034: LD_INT 15
13036: PUSH
13037: LD_INT 16
13039: PUSH
13040: LD_INT 22
13042: PUSH
13043: LD_INT 23
13045: PUSH
13046: LD_INT 25
13048: PUSH
13049: LD_INT 26
13051: PUSH
13052: LD_INT 36
13054: PUSH
13055: EMPTY
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: LIST
13062: LIST
13063: LIST
13064: LIST
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 101
13073: PUSH
13074: LD_INT 102
13076: PUSH
13077: LD_INT 105
13079: PUSH
13080: LD_INT 106
13082: PUSH
13083: LD_INT 108
13085: PUSH
13086: LD_INT 109
13088: PUSH
13089: LD_INT 112
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: ST_TO_ADDR
13105: GO 15600
13107: LD_INT 6
13109: DOUBLE
13110: EQUAL
13111: IFTRUE 13115
13113: GO 13235
13115: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
13116: LD_ADDR_VAR 0 1
13120: PUSH
13121: LD_INT 2
13123: PUSH
13124: LD_INT 4
13126: PUSH
13127: LD_INT 5
13129: PUSH
13130: LD_INT 6
13132: PUSH
13133: LD_INT 8
13135: PUSH
13136: LD_INT 11
13138: PUSH
13139: LD_INT 12
13141: PUSH
13142: LD_INT 15
13144: PUSH
13145: LD_INT 16
13147: PUSH
13148: LD_INT 20
13150: PUSH
13151: LD_INT 21
13153: PUSH
13154: LD_INT 22
13156: PUSH
13157: LD_INT 23
13159: PUSH
13160: LD_INT 25
13162: PUSH
13163: LD_INT 26
13165: PUSH
13166: LD_INT 30
13168: PUSH
13169: LD_INT 31
13171: PUSH
13172: LD_INT 32
13174: PUSH
13175: LD_INT 36
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 101
13201: PUSH
13202: LD_INT 102
13204: PUSH
13205: LD_INT 105
13207: PUSH
13208: LD_INT 106
13210: PUSH
13211: LD_INT 108
13213: PUSH
13214: LD_INT 109
13216: PUSH
13217: LD_INT 112
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: ST_TO_ADDR
13233: GO 15600
13235: LD_INT 7
13237: DOUBLE
13238: EQUAL
13239: IFTRUE 13243
13241: GO 13343
13243: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
13244: LD_ADDR_VAR 0 1
13248: PUSH
13249: LD_INT 2
13251: PUSH
13252: LD_INT 4
13254: PUSH
13255: LD_INT 5
13257: PUSH
13258: LD_INT 7
13260: PUSH
13261: LD_INT 11
13263: PUSH
13264: LD_INT 12
13266: PUSH
13267: LD_INT 15
13269: PUSH
13270: LD_INT 16
13272: PUSH
13273: LD_INT 20
13275: PUSH
13276: LD_INT 21
13278: PUSH
13279: LD_INT 22
13281: PUSH
13282: LD_INT 23
13284: PUSH
13285: LD_INT 25
13287: PUSH
13288: LD_INT 26
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 101
13309: PUSH
13310: LD_INT 102
13312: PUSH
13313: LD_INT 103
13315: PUSH
13316: LD_INT 105
13318: PUSH
13319: LD_INT 106
13321: PUSH
13322: LD_INT 108
13324: PUSH
13325: LD_INT 112
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: LIST
13335: LIST
13336: PUSH
13337: EMPTY
13338: LIST
13339: LIST
13340: ST_TO_ADDR
13341: GO 15600
13343: LD_INT 8
13345: DOUBLE
13346: EQUAL
13347: IFTRUE 13351
13349: GO 13479
13351: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13352: LD_ADDR_VAR 0 1
13356: PUSH
13357: LD_INT 2
13359: PUSH
13360: LD_INT 4
13362: PUSH
13363: LD_INT 5
13365: PUSH
13366: LD_INT 6
13368: PUSH
13369: LD_INT 7
13371: PUSH
13372: LD_INT 8
13374: PUSH
13375: LD_INT 11
13377: PUSH
13378: LD_INT 12
13380: PUSH
13381: LD_INT 15
13383: PUSH
13384: LD_INT 16
13386: PUSH
13387: LD_INT 20
13389: PUSH
13390: LD_INT 21
13392: PUSH
13393: LD_INT 22
13395: PUSH
13396: LD_INT 23
13398: PUSH
13399: LD_INT 25
13401: PUSH
13402: LD_INT 26
13404: PUSH
13405: LD_INT 30
13407: PUSH
13408: LD_INT 31
13410: PUSH
13411: LD_INT 32
13413: PUSH
13414: LD_INT 36
13416: PUSH
13417: EMPTY
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: LIST
13429: LIST
13430: LIST
13431: LIST
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: PUSH
13439: LD_INT 101
13441: PUSH
13442: LD_INT 102
13444: PUSH
13445: LD_INT 103
13447: PUSH
13448: LD_INT 105
13450: PUSH
13451: LD_INT 106
13453: PUSH
13454: LD_INT 108
13456: PUSH
13457: LD_INT 109
13459: PUSH
13460: LD_INT 112
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: LIST
13472: PUSH
13473: EMPTY
13474: LIST
13475: LIST
13476: ST_TO_ADDR
13477: GO 15600
13479: LD_INT 9
13481: DOUBLE
13482: EQUAL
13483: IFTRUE 13487
13485: GO 13623
13487: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_INT 2
13495: PUSH
13496: LD_INT 4
13498: PUSH
13499: LD_INT 5
13501: PUSH
13502: LD_INT 6
13504: PUSH
13505: LD_INT 7
13507: PUSH
13508: LD_INT 8
13510: PUSH
13511: LD_INT 11
13513: PUSH
13514: LD_INT 12
13516: PUSH
13517: LD_INT 15
13519: PUSH
13520: LD_INT 16
13522: PUSH
13523: LD_INT 20
13525: PUSH
13526: LD_INT 21
13528: PUSH
13529: LD_INT 22
13531: PUSH
13532: LD_INT 23
13534: PUSH
13535: LD_INT 25
13537: PUSH
13538: LD_INT 26
13540: PUSH
13541: LD_INT 28
13543: PUSH
13544: LD_INT 30
13546: PUSH
13547: LD_INT 31
13549: PUSH
13550: LD_INT 32
13552: PUSH
13553: LD_INT 36
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: LIST
13572: LIST
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 101
13581: PUSH
13582: LD_INT 102
13584: PUSH
13585: LD_INT 103
13587: PUSH
13588: LD_INT 105
13590: PUSH
13591: LD_INT 106
13593: PUSH
13594: LD_INT 108
13596: PUSH
13597: LD_INT 109
13599: PUSH
13600: LD_INT 112
13602: PUSH
13603: LD_INT 114
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: ST_TO_ADDR
13621: GO 15600
13623: LD_INT 10
13625: DOUBLE
13626: EQUAL
13627: IFTRUE 13631
13629: GO 13815
13631: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13632: LD_ADDR_VAR 0 1
13636: PUSH
13637: LD_INT 2
13639: PUSH
13640: LD_INT 4
13642: PUSH
13643: LD_INT 5
13645: PUSH
13646: LD_INT 6
13648: PUSH
13649: LD_INT 7
13651: PUSH
13652: LD_INT 8
13654: PUSH
13655: LD_INT 9
13657: PUSH
13658: LD_INT 10
13660: PUSH
13661: LD_INT 11
13663: PUSH
13664: LD_INT 12
13666: PUSH
13667: LD_INT 13
13669: PUSH
13670: LD_INT 14
13672: PUSH
13673: LD_INT 15
13675: PUSH
13676: LD_INT 16
13678: PUSH
13679: LD_INT 17
13681: PUSH
13682: LD_INT 18
13684: PUSH
13685: LD_INT 19
13687: PUSH
13688: LD_INT 20
13690: PUSH
13691: LD_INT 21
13693: PUSH
13694: LD_INT 22
13696: PUSH
13697: LD_INT 23
13699: PUSH
13700: LD_INT 24
13702: PUSH
13703: LD_INT 25
13705: PUSH
13706: LD_INT 26
13708: PUSH
13709: LD_INT 28
13711: PUSH
13712: LD_INT 30
13714: PUSH
13715: LD_INT 31
13717: PUSH
13718: LD_INT 32
13720: PUSH
13721: LD_INT 36
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: LIST
13728: LIST
13729: LIST
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: PUSH
13755: LD_INT 101
13757: PUSH
13758: LD_INT 102
13760: PUSH
13761: LD_INT 103
13763: PUSH
13764: LD_INT 104
13766: PUSH
13767: LD_INT 105
13769: PUSH
13770: LD_INT 106
13772: PUSH
13773: LD_INT 107
13775: PUSH
13776: LD_INT 108
13778: PUSH
13779: LD_INT 109
13781: PUSH
13782: LD_INT 110
13784: PUSH
13785: LD_INT 111
13787: PUSH
13788: LD_INT 112
13790: PUSH
13791: LD_INT 114
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: LIST
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: ST_TO_ADDR
13813: GO 15600
13815: LD_INT 11
13817: DOUBLE
13818: EQUAL
13819: IFTRUE 13823
13821: GO 14015
13823: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13824: LD_ADDR_VAR 0 1
13828: PUSH
13829: LD_INT 2
13831: PUSH
13832: LD_INT 3
13834: PUSH
13835: LD_INT 4
13837: PUSH
13838: LD_INT 5
13840: PUSH
13841: LD_INT 6
13843: PUSH
13844: LD_INT 7
13846: PUSH
13847: LD_INT 8
13849: PUSH
13850: LD_INT 9
13852: PUSH
13853: LD_INT 10
13855: PUSH
13856: LD_INT 11
13858: PUSH
13859: LD_INT 12
13861: PUSH
13862: LD_INT 13
13864: PUSH
13865: LD_INT 14
13867: PUSH
13868: LD_INT 15
13870: PUSH
13871: LD_INT 16
13873: PUSH
13874: LD_INT 17
13876: PUSH
13877: LD_INT 18
13879: PUSH
13880: LD_INT 19
13882: PUSH
13883: LD_INT 20
13885: PUSH
13886: LD_INT 21
13888: PUSH
13889: LD_INT 22
13891: PUSH
13892: LD_INT 23
13894: PUSH
13895: LD_INT 24
13897: PUSH
13898: LD_INT 25
13900: PUSH
13901: LD_INT 26
13903: PUSH
13904: LD_INT 28
13906: PUSH
13907: LD_INT 30
13909: PUSH
13910: LD_INT 31
13912: PUSH
13913: LD_INT 32
13915: PUSH
13916: LD_INT 34
13918: PUSH
13919: LD_INT 36
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: PUSH
13955: LD_INT 101
13957: PUSH
13958: LD_INT 102
13960: PUSH
13961: LD_INT 103
13963: PUSH
13964: LD_INT 104
13966: PUSH
13967: LD_INT 105
13969: PUSH
13970: LD_INT 106
13972: PUSH
13973: LD_INT 107
13975: PUSH
13976: LD_INT 108
13978: PUSH
13979: LD_INT 109
13981: PUSH
13982: LD_INT 110
13984: PUSH
13985: LD_INT 111
13987: PUSH
13988: LD_INT 112
13990: PUSH
13991: LD_INT 114
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: LIST
14007: LIST
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: ST_TO_ADDR
14013: GO 15600
14015: LD_INT 12
14017: DOUBLE
14018: EQUAL
14019: IFTRUE 14023
14021: GO 14231
14023: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
14024: LD_ADDR_VAR 0 1
14028: PUSH
14029: LD_INT 1
14031: PUSH
14032: LD_INT 2
14034: PUSH
14035: LD_INT 3
14037: PUSH
14038: LD_INT 4
14040: PUSH
14041: LD_INT 5
14043: PUSH
14044: LD_INT 6
14046: PUSH
14047: LD_INT 7
14049: PUSH
14050: LD_INT 8
14052: PUSH
14053: LD_INT 9
14055: PUSH
14056: LD_INT 10
14058: PUSH
14059: LD_INT 11
14061: PUSH
14062: LD_INT 12
14064: PUSH
14065: LD_INT 13
14067: PUSH
14068: LD_INT 14
14070: PUSH
14071: LD_INT 15
14073: PUSH
14074: LD_INT 16
14076: PUSH
14077: LD_INT 17
14079: PUSH
14080: LD_INT 18
14082: PUSH
14083: LD_INT 19
14085: PUSH
14086: LD_INT 20
14088: PUSH
14089: LD_INT 21
14091: PUSH
14092: LD_INT 22
14094: PUSH
14095: LD_INT 23
14097: PUSH
14098: LD_INT 24
14100: PUSH
14101: LD_INT 25
14103: PUSH
14104: LD_INT 26
14106: PUSH
14107: LD_INT 27
14109: PUSH
14110: LD_INT 28
14112: PUSH
14113: LD_INT 30
14115: PUSH
14116: LD_INT 31
14118: PUSH
14119: LD_INT 32
14121: PUSH
14122: LD_INT 33
14124: PUSH
14125: LD_INT 34
14127: PUSH
14128: LD_INT 36
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: PUSH
14167: LD_INT 101
14169: PUSH
14170: LD_INT 102
14172: PUSH
14173: LD_INT 103
14175: PUSH
14176: LD_INT 104
14178: PUSH
14179: LD_INT 105
14181: PUSH
14182: LD_INT 106
14184: PUSH
14185: LD_INT 107
14187: PUSH
14188: LD_INT 108
14190: PUSH
14191: LD_INT 109
14193: PUSH
14194: LD_INT 110
14196: PUSH
14197: LD_INT 111
14199: PUSH
14200: LD_INT 112
14202: PUSH
14203: LD_INT 113
14205: PUSH
14206: LD_INT 114
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: ST_TO_ADDR
14229: GO 15600
14231: LD_INT 13
14233: DOUBLE
14234: EQUAL
14235: IFTRUE 14239
14237: GO 14435
14239: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
14240: LD_ADDR_VAR 0 1
14244: PUSH
14245: LD_INT 1
14247: PUSH
14248: LD_INT 2
14250: PUSH
14251: LD_INT 3
14253: PUSH
14254: LD_INT 4
14256: PUSH
14257: LD_INT 5
14259: PUSH
14260: LD_INT 8
14262: PUSH
14263: LD_INT 9
14265: PUSH
14266: LD_INT 10
14268: PUSH
14269: LD_INT 11
14271: PUSH
14272: LD_INT 12
14274: PUSH
14275: LD_INT 14
14277: PUSH
14278: LD_INT 15
14280: PUSH
14281: LD_INT 16
14283: PUSH
14284: LD_INT 17
14286: PUSH
14287: LD_INT 18
14289: PUSH
14290: LD_INT 19
14292: PUSH
14293: LD_INT 20
14295: PUSH
14296: LD_INT 21
14298: PUSH
14299: LD_INT 22
14301: PUSH
14302: LD_INT 23
14304: PUSH
14305: LD_INT 24
14307: PUSH
14308: LD_INT 25
14310: PUSH
14311: LD_INT 26
14313: PUSH
14314: LD_INT 27
14316: PUSH
14317: LD_INT 28
14319: PUSH
14320: LD_INT 30
14322: PUSH
14323: LD_INT 31
14325: PUSH
14326: LD_INT 32
14328: PUSH
14329: LD_INT 33
14331: PUSH
14332: LD_INT 34
14334: PUSH
14335: LD_INT 36
14337: PUSH
14338: EMPTY
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: PUSH
14371: LD_INT 101
14373: PUSH
14374: LD_INT 102
14376: PUSH
14377: LD_INT 103
14379: PUSH
14380: LD_INT 104
14382: PUSH
14383: LD_INT 105
14385: PUSH
14386: LD_INT 106
14388: PUSH
14389: LD_INT 107
14391: PUSH
14392: LD_INT 108
14394: PUSH
14395: LD_INT 109
14397: PUSH
14398: LD_INT 110
14400: PUSH
14401: LD_INT 111
14403: PUSH
14404: LD_INT 112
14406: PUSH
14407: LD_INT 113
14409: PUSH
14410: LD_INT 114
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: LIST
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: ST_TO_ADDR
14433: GO 15600
14435: LD_INT 14
14437: DOUBLE
14438: EQUAL
14439: IFTRUE 14443
14441: GO 14655
14443: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14444: LD_ADDR_VAR 0 1
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: LD_INT 2
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: LD_INT 4
14460: PUSH
14461: LD_INT 5
14463: PUSH
14464: LD_INT 6
14466: PUSH
14467: LD_INT 7
14469: PUSH
14470: LD_INT 8
14472: PUSH
14473: LD_INT 9
14475: PUSH
14476: LD_INT 10
14478: PUSH
14479: LD_INT 11
14481: PUSH
14482: LD_INT 12
14484: PUSH
14485: LD_INT 13
14487: PUSH
14488: LD_INT 14
14490: PUSH
14491: LD_INT 15
14493: PUSH
14494: LD_INT 16
14496: PUSH
14497: LD_INT 17
14499: PUSH
14500: LD_INT 18
14502: PUSH
14503: LD_INT 19
14505: PUSH
14506: LD_INT 20
14508: PUSH
14509: LD_INT 21
14511: PUSH
14512: LD_INT 22
14514: PUSH
14515: LD_INT 23
14517: PUSH
14518: LD_INT 24
14520: PUSH
14521: LD_INT 25
14523: PUSH
14524: LD_INT 26
14526: PUSH
14527: LD_INT 27
14529: PUSH
14530: LD_INT 28
14532: PUSH
14533: LD_INT 29
14535: PUSH
14536: LD_INT 30
14538: PUSH
14539: LD_INT 31
14541: PUSH
14542: LD_INT 32
14544: PUSH
14545: LD_INT 33
14547: PUSH
14548: LD_INT 34
14550: PUSH
14551: LD_INT 36
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: PUSH
14591: LD_INT 101
14593: PUSH
14594: LD_INT 102
14596: PUSH
14597: LD_INT 103
14599: PUSH
14600: LD_INT 104
14602: PUSH
14603: LD_INT 105
14605: PUSH
14606: LD_INT 106
14608: PUSH
14609: LD_INT 107
14611: PUSH
14612: LD_INT 108
14614: PUSH
14615: LD_INT 109
14617: PUSH
14618: LD_INT 110
14620: PUSH
14621: LD_INT 111
14623: PUSH
14624: LD_INT 112
14626: PUSH
14627: LD_INT 113
14629: PUSH
14630: LD_INT 114
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: LIST
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: ST_TO_ADDR
14653: GO 15600
14655: LD_INT 15
14657: DOUBLE
14658: EQUAL
14659: IFTRUE 14663
14661: GO 14875
14663: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14664: LD_ADDR_VAR 0 1
14668: PUSH
14669: LD_INT 1
14671: PUSH
14672: LD_INT 2
14674: PUSH
14675: LD_INT 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: LD_INT 6
14686: PUSH
14687: LD_INT 7
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: LD_INT 9
14695: PUSH
14696: LD_INT 10
14698: PUSH
14699: LD_INT 11
14701: PUSH
14702: LD_INT 12
14704: PUSH
14705: LD_INT 13
14707: PUSH
14708: LD_INT 14
14710: PUSH
14711: LD_INT 15
14713: PUSH
14714: LD_INT 16
14716: PUSH
14717: LD_INT 17
14719: PUSH
14720: LD_INT 18
14722: PUSH
14723: LD_INT 19
14725: PUSH
14726: LD_INT 20
14728: PUSH
14729: LD_INT 21
14731: PUSH
14732: LD_INT 22
14734: PUSH
14735: LD_INT 23
14737: PUSH
14738: LD_INT 24
14740: PUSH
14741: LD_INT 25
14743: PUSH
14744: LD_INT 26
14746: PUSH
14747: LD_INT 27
14749: PUSH
14750: LD_INT 28
14752: PUSH
14753: LD_INT 29
14755: PUSH
14756: LD_INT 30
14758: PUSH
14759: LD_INT 31
14761: PUSH
14762: LD_INT 32
14764: PUSH
14765: LD_INT 33
14767: PUSH
14768: LD_INT 34
14770: PUSH
14771: LD_INT 36
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: PUSH
14811: LD_INT 101
14813: PUSH
14814: LD_INT 102
14816: PUSH
14817: LD_INT 103
14819: PUSH
14820: LD_INT 104
14822: PUSH
14823: LD_INT 105
14825: PUSH
14826: LD_INT 106
14828: PUSH
14829: LD_INT 107
14831: PUSH
14832: LD_INT 108
14834: PUSH
14835: LD_INT 109
14837: PUSH
14838: LD_INT 110
14840: PUSH
14841: LD_INT 111
14843: PUSH
14844: LD_INT 112
14846: PUSH
14847: LD_INT 113
14849: PUSH
14850: LD_INT 114
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: LIST
14857: LIST
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: ST_TO_ADDR
14873: GO 15600
14875: LD_INT 16
14877: DOUBLE
14878: EQUAL
14879: IFTRUE 14883
14881: GO 15007
14883: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14884: LD_ADDR_VAR 0 1
14888: PUSH
14889: LD_INT 2
14891: PUSH
14892: LD_INT 4
14894: PUSH
14895: LD_INT 5
14897: PUSH
14898: LD_INT 7
14900: PUSH
14901: LD_INT 11
14903: PUSH
14904: LD_INT 12
14906: PUSH
14907: LD_INT 15
14909: PUSH
14910: LD_INT 16
14912: PUSH
14913: LD_INT 20
14915: PUSH
14916: LD_INT 21
14918: PUSH
14919: LD_INT 22
14921: PUSH
14922: LD_INT 23
14924: PUSH
14925: LD_INT 25
14927: PUSH
14928: LD_INT 26
14930: PUSH
14931: LD_INT 30
14933: PUSH
14934: LD_INT 31
14936: PUSH
14937: LD_INT 32
14939: PUSH
14940: LD_INT 33
14942: PUSH
14943: LD_INT 34
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: LIST
14950: LIST
14951: LIST
14952: LIST
14953: LIST
14954: LIST
14955: LIST
14956: LIST
14957: LIST
14958: LIST
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 101
14969: PUSH
14970: LD_INT 102
14972: PUSH
14973: LD_INT 103
14975: PUSH
14976: LD_INT 106
14978: PUSH
14979: LD_INT 108
14981: PUSH
14982: LD_INT 112
14984: PUSH
14985: LD_INT 113
14987: PUSH
14988: LD_INT 114
14990: PUSH
14991: EMPTY
14992: LIST
14993: LIST
14994: LIST
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: ST_TO_ADDR
15005: GO 15600
15007: LD_INT 17
15009: DOUBLE
15010: EQUAL
15011: IFTRUE 15015
15013: GO 15227
15015: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
15016: LD_ADDR_VAR 0 1
15020: PUSH
15021: LD_INT 1
15023: PUSH
15024: LD_INT 2
15026: PUSH
15027: LD_INT 3
15029: PUSH
15030: LD_INT 4
15032: PUSH
15033: LD_INT 5
15035: PUSH
15036: LD_INT 6
15038: PUSH
15039: LD_INT 7
15041: PUSH
15042: LD_INT 8
15044: PUSH
15045: LD_INT 9
15047: PUSH
15048: LD_INT 10
15050: PUSH
15051: LD_INT 11
15053: PUSH
15054: LD_INT 12
15056: PUSH
15057: LD_INT 13
15059: PUSH
15060: LD_INT 14
15062: PUSH
15063: LD_INT 15
15065: PUSH
15066: LD_INT 16
15068: PUSH
15069: LD_INT 17
15071: PUSH
15072: LD_INT 18
15074: PUSH
15075: LD_INT 19
15077: PUSH
15078: LD_INT 20
15080: PUSH
15081: LD_INT 21
15083: PUSH
15084: LD_INT 22
15086: PUSH
15087: LD_INT 23
15089: PUSH
15090: LD_INT 24
15092: PUSH
15093: LD_INT 25
15095: PUSH
15096: LD_INT 26
15098: PUSH
15099: LD_INT 27
15101: PUSH
15102: LD_INT 28
15104: PUSH
15105: LD_INT 29
15107: PUSH
15108: LD_INT 30
15110: PUSH
15111: LD_INT 31
15113: PUSH
15114: LD_INT 32
15116: PUSH
15117: LD_INT 33
15119: PUSH
15120: LD_INT 34
15122: PUSH
15123: LD_INT 36
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: LIST
15140: LIST
15141: LIST
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: PUSH
15163: LD_INT 101
15165: PUSH
15166: LD_INT 102
15168: PUSH
15169: LD_INT 103
15171: PUSH
15172: LD_INT 104
15174: PUSH
15175: LD_INT 105
15177: PUSH
15178: LD_INT 106
15180: PUSH
15181: LD_INT 107
15183: PUSH
15184: LD_INT 108
15186: PUSH
15187: LD_INT 109
15189: PUSH
15190: LD_INT 110
15192: PUSH
15193: LD_INT 111
15195: PUSH
15196: LD_INT 112
15198: PUSH
15199: LD_INT 113
15201: PUSH
15202: LD_INT 114
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: ST_TO_ADDR
15225: GO 15600
15227: LD_INT 18
15229: DOUBLE
15230: EQUAL
15231: IFTRUE 15235
15233: GO 15371
15235: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
15236: LD_ADDR_VAR 0 1
15240: PUSH
15241: LD_INT 2
15243: PUSH
15244: LD_INT 4
15246: PUSH
15247: LD_INT 5
15249: PUSH
15250: LD_INT 7
15252: PUSH
15253: LD_INT 11
15255: PUSH
15256: LD_INT 12
15258: PUSH
15259: LD_INT 15
15261: PUSH
15262: LD_INT 16
15264: PUSH
15265: LD_INT 20
15267: PUSH
15268: LD_INT 21
15270: PUSH
15271: LD_INT 22
15273: PUSH
15274: LD_INT 23
15276: PUSH
15277: LD_INT 25
15279: PUSH
15280: LD_INT 26
15282: PUSH
15283: LD_INT 30
15285: PUSH
15286: LD_INT 31
15288: PUSH
15289: LD_INT 32
15291: PUSH
15292: LD_INT 33
15294: PUSH
15295: LD_INT 34
15297: PUSH
15298: LD_INT 35
15300: PUSH
15301: LD_INT 36
15303: PUSH
15304: EMPTY
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: LIST
15314: LIST
15315: LIST
15316: LIST
15317: LIST
15318: LIST
15319: LIST
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PUSH
15327: LD_INT 101
15329: PUSH
15330: LD_INT 102
15332: PUSH
15333: LD_INT 103
15335: PUSH
15336: LD_INT 106
15338: PUSH
15339: LD_INT 108
15341: PUSH
15342: LD_INT 112
15344: PUSH
15345: LD_INT 113
15347: PUSH
15348: LD_INT 114
15350: PUSH
15351: LD_INT 115
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: ST_TO_ADDR
15369: GO 15600
15371: LD_INT 19
15373: DOUBLE
15374: EQUAL
15375: IFTRUE 15379
15377: GO 15599
15379: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15380: LD_ADDR_VAR 0 1
15384: PUSH
15385: LD_INT 1
15387: PUSH
15388: LD_INT 2
15390: PUSH
15391: LD_INT 3
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: LD_INT 5
15399: PUSH
15400: LD_INT 6
15402: PUSH
15403: LD_INT 7
15405: PUSH
15406: LD_INT 8
15408: PUSH
15409: LD_INT 9
15411: PUSH
15412: LD_INT 10
15414: PUSH
15415: LD_INT 11
15417: PUSH
15418: LD_INT 12
15420: PUSH
15421: LD_INT 13
15423: PUSH
15424: LD_INT 14
15426: PUSH
15427: LD_INT 15
15429: PUSH
15430: LD_INT 16
15432: PUSH
15433: LD_INT 17
15435: PUSH
15436: LD_INT 18
15438: PUSH
15439: LD_INT 19
15441: PUSH
15442: LD_INT 20
15444: PUSH
15445: LD_INT 21
15447: PUSH
15448: LD_INT 22
15450: PUSH
15451: LD_INT 23
15453: PUSH
15454: LD_INT 24
15456: PUSH
15457: LD_INT 25
15459: PUSH
15460: LD_INT 26
15462: PUSH
15463: LD_INT 27
15465: PUSH
15466: LD_INT 28
15468: PUSH
15469: LD_INT 29
15471: PUSH
15472: LD_INT 30
15474: PUSH
15475: LD_INT 31
15477: PUSH
15478: LD_INT 32
15480: PUSH
15481: LD_INT 33
15483: PUSH
15484: LD_INT 34
15486: PUSH
15487: LD_INT 35
15489: PUSH
15490: LD_INT 36
15492: PUSH
15493: EMPTY
15494: LIST
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: LIST
15500: LIST
15501: LIST
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: LIST
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: LIST
15514: LIST
15515: LIST
15516: LIST
15517: LIST
15518: LIST
15519: LIST
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: LIST
15527: LIST
15528: LIST
15529: LIST
15530: PUSH
15531: LD_INT 101
15533: PUSH
15534: LD_INT 102
15536: PUSH
15537: LD_INT 103
15539: PUSH
15540: LD_INT 104
15542: PUSH
15543: LD_INT 105
15545: PUSH
15546: LD_INT 106
15548: PUSH
15549: LD_INT 107
15551: PUSH
15552: LD_INT 108
15554: PUSH
15555: LD_INT 109
15557: PUSH
15558: LD_INT 110
15560: PUSH
15561: LD_INT 111
15563: PUSH
15564: LD_INT 112
15566: PUSH
15567: LD_INT 113
15569: PUSH
15570: LD_INT 114
15572: PUSH
15573: LD_INT 115
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: LIST
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: PUSH
15593: EMPTY
15594: LIST
15595: LIST
15596: ST_TO_ADDR
15597: GO 15600
15599: POP
// end else
15600: GO 15637
// if campaign_id = 5 then
15602: LD_OWVAR 69
15606: PUSH
15607: LD_INT 5
15609: EQUAL
15610: IFFALSE 15637
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
15612: LD_ADDR_VAR 0 1
15616: PUSH
15617: LD_INT 1
15619: PUSH
15620: LD_INT 2
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: LD_INT 100
15629: PUSH
15630: EMPTY
15631: LIST
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: ST_TO_ADDR
// end ; if result then
15637: LD_VAR 0 1
15641: IFFALSE 15930
// begin normal :=  ;
15643: LD_ADDR_VAR 0 3
15647: PUSH
15648: LD_STRING 
15650: ST_TO_ADDR
// hardcore :=  ;
15651: LD_ADDR_VAR 0 4
15655: PUSH
15656: LD_STRING 
15658: ST_TO_ADDR
// for i = 1 to normalCounter do
15659: LD_ADDR_VAR 0 5
15663: PUSH
15664: DOUBLE
15665: LD_INT 1
15667: DEC
15668: ST_TO_ADDR
15669: LD_EXP 27
15673: PUSH
15674: FOR_TO
15675: IFFALSE 15776
// begin tmp := 0 ;
15677: LD_ADDR_VAR 0 2
15681: PUSH
15682: LD_STRING 0
15684: ST_TO_ADDR
// if result [ 1 ] then
15685: LD_VAR 0 1
15689: PUSH
15690: LD_INT 1
15692: ARRAY
15693: IFFALSE 15758
// if result [ 1 ] [ 1 ] = i then
15695: LD_VAR 0 1
15699: PUSH
15700: LD_INT 1
15702: ARRAY
15703: PUSH
15704: LD_INT 1
15706: ARRAY
15707: PUSH
15708: LD_VAR 0 5
15712: EQUAL
15713: IFFALSE 15758
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15715: LD_ADDR_VAR 0 1
15719: PUSH
15720: LD_VAR 0 1
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_VAR 0 1
15732: PUSH
15733: LD_INT 1
15735: ARRAY
15736: PPUSH
15737: LD_INT 1
15739: PPUSH
15740: CALL_OW 3
15744: PPUSH
15745: CALL_OW 1
15749: ST_TO_ADDR
// tmp := 1 ;
15750: LD_ADDR_VAR 0 2
15754: PUSH
15755: LD_STRING 1
15757: ST_TO_ADDR
// end ; normal := normal & tmp ;
15758: LD_ADDR_VAR 0 3
15762: PUSH
15763: LD_VAR 0 3
15767: PUSH
15768: LD_VAR 0 2
15772: STR
15773: ST_TO_ADDR
// end ;
15774: GO 15674
15776: POP
15777: POP
// for i = 1 to hardcoreCounter do
15778: LD_ADDR_VAR 0 5
15782: PUSH
15783: DOUBLE
15784: LD_INT 1
15786: DEC
15787: ST_TO_ADDR
15788: LD_EXP 28
15792: PUSH
15793: FOR_TO
15794: IFFALSE 15899
// begin tmp := 0 ;
15796: LD_ADDR_VAR 0 2
15800: PUSH
15801: LD_STRING 0
15803: ST_TO_ADDR
// if result [ 2 ] then
15804: LD_VAR 0 1
15808: PUSH
15809: LD_INT 2
15811: ARRAY
15812: IFFALSE 15881
// if result [ 2 ] [ 1 ] = 100 + i then
15814: LD_VAR 0 1
15818: PUSH
15819: LD_INT 2
15821: ARRAY
15822: PUSH
15823: LD_INT 1
15825: ARRAY
15826: PUSH
15827: LD_INT 100
15829: PUSH
15830: LD_VAR 0 5
15834: PLUS
15835: EQUAL
15836: IFFALSE 15881
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15838: LD_ADDR_VAR 0 1
15842: PUSH
15843: LD_VAR 0 1
15847: PPUSH
15848: LD_INT 2
15850: PPUSH
15851: LD_VAR 0 1
15855: PUSH
15856: LD_INT 2
15858: ARRAY
15859: PPUSH
15860: LD_INT 1
15862: PPUSH
15863: CALL_OW 3
15867: PPUSH
15868: CALL_OW 1
15872: ST_TO_ADDR
// tmp := 1 ;
15873: LD_ADDR_VAR 0 2
15877: PUSH
15878: LD_STRING 1
15880: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15881: LD_ADDR_VAR 0 4
15885: PUSH
15886: LD_VAR 0 4
15890: PUSH
15891: LD_VAR 0 2
15895: STR
15896: ST_TO_ADDR
// end ;
15897: GO 15793
15899: POP
15900: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15901: LD_STRING getStreamItemsFromMission("
15903: PUSH
15904: LD_VAR 0 3
15908: STR
15909: PUSH
15910: LD_STRING ","
15912: STR
15913: PUSH
15914: LD_VAR 0 4
15918: STR
15919: PUSH
15920: LD_STRING ")
15922: STR
15923: PPUSH
15924: CALL_OW 559
// end else
15928: GO 15937
// ToLua ( getStreamItemsFromMission("","") ) ;
15930: LD_STRING getStreamItemsFromMission("","")
15932: PPUSH
15933: CALL_OW 559
// end ;
15937: LD_VAR 0 1
15941: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15942: LD_VAR 0 2
15946: PUSH
15947: LD_INT 100
15949: EQUAL
15950: IFFALSE 16899
// begin if not StreamModeActive then
15952: LD_EXP 26
15956: NOT
15957: IFFALSE 15967
// StreamModeActive := true ;
15959: LD_ADDR_EXP 26
15963: PUSH
15964: LD_INT 1
15966: ST_TO_ADDR
// if p3 = 0 then
15967: LD_VAR 0 3
15971: PUSH
15972: LD_INT 0
15974: EQUAL
15975: IFFALSE 15981
// InitStreamMode ;
15977: CALL 12202 0 0
// if p3 = 1 then
15981: LD_VAR 0 3
15985: PUSH
15986: LD_INT 1
15988: EQUAL
15989: IFFALSE 15999
// sRocket := true ;
15991: LD_ADDR_EXP 31
15995: PUSH
15996: LD_INT 1
15998: ST_TO_ADDR
// if p3 = 2 then
15999: LD_VAR 0 3
16003: PUSH
16004: LD_INT 2
16006: EQUAL
16007: IFFALSE 16017
// sSpeed := true ;
16009: LD_ADDR_EXP 30
16013: PUSH
16014: LD_INT 1
16016: ST_TO_ADDR
// if p3 = 3 then
16017: LD_VAR 0 3
16021: PUSH
16022: LD_INT 3
16024: EQUAL
16025: IFFALSE 16035
// sEngine := true ;
16027: LD_ADDR_EXP 32
16031: PUSH
16032: LD_INT 1
16034: ST_TO_ADDR
// if p3 = 4 then
16035: LD_VAR 0 3
16039: PUSH
16040: LD_INT 4
16042: EQUAL
16043: IFFALSE 16053
// sSpec := true ;
16045: LD_ADDR_EXP 29
16049: PUSH
16050: LD_INT 1
16052: ST_TO_ADDR
// if p3 = 5 then
16053: LD_VAR 0 3
16057: PUSH
16058: LD_INT 5
16060: EQUAL
16061: IFFALSE 16071
// sLevel := true ;
16063: LD_ADDR_EXP 33
16067: PUSH
16068: LD_INT 1
16070: ST_TO_ADDR
// if p3 = 6 then
16071: LD_VAR 0 3
16075: PUSH
16076: LD_INT 6
16078: EQUAL
16079: IFFALSE 16089
// sArmoury := true ;
16081: LD_ADDR_EXP 34
16085: PUSH
16086: LD_INT 1
16088: ST_TO_ADDR
// if p3 = 7 then
16089: LD_VAR 0 3
16093: PUSH
16094: LD_INT 7
16096: EQUAL
16097: IFFALSE 16107
// sRadar := true ;
16099: LD_ADDR_EXP 35
16103: PUSH
16104: LD_INT 1
16106: ST_TO_ADDR
// if p3 = 8 then
16107: LD_VAR 0 3
16111: PUSH
16112: LD_INT 8
16114: EQUAL
16115: IFFALSE 16125
// sBunker := true ;
16117: LD_ADDR_EXP 36
16121: PUSH
16122: LD_INT 1
16124: ST_TO_ADDR
// if p3 = 9 then
16125: LD_VAR 0 3
16129: PUSH
16130: LD_INT 9
16132: EQUAL
16133: IFFALSE 16143
// sHack := true ;
16135: LD_ADDR_EXP 37
16139: PUSH
16140: LD_INT 1
16142: ST_TO_ADDR
// if p3 = 10 then
16143: LD_VAR 0 3
16147: PUSH
16148: LD_INT 10
16150: EQUAL
16151: IFFALSE 16161
// sFire := true ;
16153: LD_ADDR_EXP 38
16157: PUSH
16158: LD_INT 1
16160: ST_TO_ADDR
// if p3 = 11 then
16161: LD_VAR 0 3
16165: PUSH
16166: LD_INT 11
16168: EQUAL
16169: IFFALSE 16179
// sRefresh := true ;
16171: LD_ADDR_EXP 39
16175: PUSH
16176: LD_INT 1
16178: ST_TO_ADDR
// if p3 = 12 then
16179: LD_VAR 0 3
16183: PUSH
16184: LD_INT 12
16186: EQUAL
16187: IFFALSE 16197
// sExp := true ;
16189: LD_ADDR_EXP 40
16193: PUSH
16194: LD_INT 1
16196: ST_TO_ADDR
// if p3 = 13 then
16197: LD_VAR 0 3
16201: PUSH
16202: LD_INT 13
16204: EQUAL
16205: IFFALSE 16215
// sDepot := true ;
16207: LD_ADDR_EXP 41
16211: PUSH
16212: LD_INT 1
16214: ST_TO_ADDR
// if p3 = 14 then
16215: LD_VAR 0 3
16219: PUSH
16220: LD_INT 14
16222: EQUAL
16223: IFFALSE 16233
// sFlag := true ;
16225: LD_ADDR_EXP 42
16229: PUSH
16230: LD_INT 1
16232: ST_TO_ADDR
// if p3 = 15 then
16233: LD_VAR 0 3
16237: PUSH
16238: LD_INT 15
16240: EQUAL
16241: IFFALSE 16251
// sKamikadze := true ;
16243: LD_ADDR_EXP 50
16247: PUSH
16248: LD_INT 1
16250: ST_TO_ADDR
// if p3 = 16 then
16251: LD_VAR 0 3
16255: PUSH
16256: LD_INT 16
16258: EQUAL
16259: IFFALSE 16269
// sTroll := true ;
16261: LD_ADDR_EXP 51
16265: PUSH
16266: LD_INT 1
16268: ST_TO_ADDR
// if p3 = 17 then
16269: LD_VAR 0 3
16273: PUSH
16274: LD_INT 17
16276: EQUAL
16277: IFFALSE 16287
// sSlow := true ;
16279: LD_ADDR_EXP 52
16283: PUSH
16284: LD_INT 1
16286: ST_TO_ADDR
// if p3 = 18 then
16287: LD_VAR 0 3
16291: PUSH
16292: LD_INT 18
16294: EQUAL
16295: IFFALSE 16305
// sLack := true ;
16297: LD_ADDR_EXP 53
16301: PUSH
16302: LD_INT 1
16304: ST_TO_ADDR
// if p3 = 19 then
16305: LD_VAR 0 3
16309: PUSH
16310: LD_INT 19
16312: EQUAL
16313: IFFALSE 16323
// sTank := true ;
16315: LD_ADDR_EXP 55
16319: PUSH
16320: LD_INT 1
16322: ST_TO_ADDR
// if p3 = 20 then
16323: LD_VAR 0 3
16327: PUSH
16328: LD_INT 20
16330: EQUAL
16331: IFFALSE 16341
// sRemote := true ;
16333: LD_ADDR_EXP 56
16337: PUSH
16338: LD_INT 1
16340: ST_TO_ADDR
// if p3 = 21 then
16341: LD_VAR 0 3
16345: PUSH
16346: LD_INT 21
16348: EQUAL
16349: IFFALSE 16359
// sPowell := true ;
16351: LD_ADDR_EXP 57
16355: PUSH
16356: LD_INT 1
16358: ST_TO_ADDR
// if p3 = 22 then
16359: LD_VAR 0 3
16363: PUSH
16364: LD_INT 22
16366: EQUAL
16367: IFFALSE 16377
// sTeleport := true ;
16369: LD_ADDR_EXP 60
16373: PUSH
16374: LD_INT 1
16376: ST_TO_ADDR
// if p3 = 23 then
16377: LD_VAR 0 3
16381: PUSH
16382: LD_INT 23
16384: EQUAL
16385: IFFALSE 16395
// sOilTower := true ;
16387: LD_ADDR_EXP 62
16391: PUSH
16392: LD_INT 1
16394: ST_TO_ADDR
// if p3 = 24 then
16395: LD_VAR 0 3
16399: PUSH
16400: LD_INT 24
16402: EQUAL
16403: IFFALSE 16413
// sShovel := true ;
16405: LD_ADDR_EXP 63
16409: PUSH
16410: LD_INT 1
16412: ST_TO_ADDR
// if p3 = 25 then
16413: LD_VAR 0 3
16417: PUSH
16418: LD_INT 25
16420: EQUAL
16421: IFFALSE 16431
// sSheik := true ;
16423: LD_ADDR_EXP 64
16427: PUSH
16428: LD_INT 1
16430: ST_TO_ADDR
// if p3 = 26 then
16431: LD_VAR 0 3
16435: PUSH
16436: LD_INT 26
16438: EQUAL
16439: IFFALSE 16449
// sEarthquake := true ;
16441: LD_ADDR_EXP 66
16445: PUSH
16446: LD_INT 1
16448: ST_TO_ADDR
// if p3 = 27 then
16449: LD_VAR 0 3
16453: PUSH
16454: LD_INT 27
16456: EQUAL
16457: IFFALSE 16467
// sAI := true ;
16459: LD_ADDR_EXP 67
16463: PUSH
16464: LD_INT 1
16466: ST_TO_ADDR
// if p3 = 28 then
16467: LD_VAR 0 3
16471: PUSH
16472: LD_INT 28
16474: EQUAL
16475: IFFALSE 16485
// sCargo := true ;
16477: LD_ADDR_EXP 70
16481: PUSH
16482: LD_INT 1
16484: ST_TO_ADDR
// if p3 = 29 then
16485: LD_VAR 0 3
16489: PUSH
16490: LD_INT 29
16492: EQUAL
16493: IFFALSE 16503
// sDLaser := true ;
16495: LD_ADDR_EXP 71
16499: PUSH
16500: LD_INT 1
16502: ST_TO_ADDR
// if p3 = 30 then
16503: LD_VAR 0 3
16507: PUSH
16508: LD_INT 30
16510: EQUAL
16511: IFFALSE 16521
// sExchange := true ;
16513: LD_ADDR_EXP 72
16517: PUSH
16518: LD_INT 1
16520: ST_TO_ADDR
// if p3 = 31 then
16521: LD_VAR 0 3
16525: PUSH
16526: LD_INT 31
16528: EQUAL
16529: IFFALSE 16539
// sFac := true ;
16531: LD_ADDR_EXP 73
16535: PUSH
16536: LD_INT 1
16538: ST_TO_ADDR
// if p3 = 32 then
16539: LD_VAR 0 3
16543: PUSH
16544: LD_INT 32
16546: EQUAL
16547: IFFALSE 16557
// sPower := true ;
16549: LD_ADDR_EXP 74
16553: PUSH
16554: LD_INT 1
16556: ST_TO_ADDR
// if p3 = 33 then
16557: LD_VAR 0 3
16561: PUSH
16562: LD_INT 33
16564: EQUAL
16565: IFFALSE 16575
// sRandom := true ;
16567: LD_ADDR_EXP 75
16571: PUSH
16572: LD_INT 1
16574: ST_TO_ADDR
// if p3 = 34 then
16575: LD_VAR 0 3
16579: PUSH
16580: LD_INT 34
16582: EQUAL
16583: IFFALSE 16593
// sShield := true ;
16585: LD_ADDR_EXP 76
16589: PUSH
16590: LD_INT 1
16592: ST_TO_ADDR
// if p3 = 35 then
16593: LD_VAR 0 3
16597: PUSH
16598: LD_INT 35
16600: EQUAL
16601: IFFALSE 16611
// sTime := true ;
16603: LD_ADDR_EXP 77
16607: PUSH
16608: LD_INT 1
16610: ST_TO_ADDR
// if p3 = 36 then
16611: LD_VAR 0 3
16615: PUSH
16616: LD_INT 36
16618: EQUAL
16619: IFFALSE 16629
// sTools := true ;
16621: LD_ADDR_EXP 78
16625: PUSH
16626: LD_INT 1
16628: ST_TO_ADDR
// if p3 = 101 then
16629: LD_VAR 0 3
16633: PUSH
16634: LD_INT 101
16636: EQUAL
16637: IFFALSE 16647
// sSold := true ;
16639: LD_ADDR_EXP 43
16643: PUSH
16644: LD_INT 1
16646: ST_TO_ADDR
// if p3 = 102 then
16647: LD_VAR 0 3
16651: PUSH
16652: LD_INT 102
16654: EQUAL
16655: IFFALSE 16665
// sDiff := true ;
16657: LD_ADDR_EXP 44
16661: PUSH
16662: LD_INT 1
16664: ST_TO_ADDR
// if p3 = 103 then
16665: LD_VAR 0 3
16669: PUSH
16670: LD_INT 103
16672: EQUAL
16673: IFFALSE 16683
// sFog := true ;
16675: LD_ADDR_EXP 47
16679: PUSH
16680: LD_INT 1
16682: ST_TO_ADDR
// if p3 = 104 then
16683: LD_VAR 0 3
16687: PUSH
16688: LD_INT 104
16690: EQUAL
16691: IFFALSE 16701
// sReset := true ;
16693: LD_ADDR_EXP 48
16697: PUSH
16698: LD_INT 1
16700: ST_TO_ADDR
// if p3 = 105 then
16701: LD_VAR 0 3
16705: PUSH
16706: LD_INT 105
16708: EQUAL
16709: IFFALSE 16719
// sSun := true ;
16711: LD_ADDR_EXP 49
16715: PUSH
16716: LD_INT 1
16718: ST_TO_ADDR
// if p3 = 106 then
16719: LD_VAR 0 3
16723: PUSH
16724: LD_INT 106
16726: EQUAL
16727: IFFALSE 16737
// sTiger := true ;
16729: LD_ADDR_EXP 45
16733: PUSH
16734: LD_INT 1
16736: ST_TO_ADDR
// if p3 = 107 then
16737: LD_VAR 0 3
16741: PUSH
16742: LD_INT 107
16744: EQUAL
16745: IFFALSE 16755
// sBomb := true ;
16747: LD_ADDR_EXP 46
16751: PUSH
16752: LD_INT 1
16754: ST_TO_ADDR
// if p3 = 108 then
16755: LD_VAR 0 3
16759: PUSH
16760: LD_INT 108
16762: EQUAL
16763: IFFALSE 16773
// sWound := true ;
16765: LD_ADDR_EXP 54
16769: PUSH
16770: LD_INT 1
16772: ST_TO_ADDR
// if p3 = 109 then
16773: LD_VAR 0 3
16777: PUSH
16778: LD_INT 109
16780: EQUAL
16781: IFFALSE 16791
// sBetray := true ;
16783: LD_ADDR_EXP 58
16787: PUSH
16788: LD_INT 1
16790: ST_TO_ADDR
// if p3 = 110 then
16791: LD_VAR 0 3
16795: PUSH
16796: LD_INT 110
16798: EQUAL
16799: IFFALSE 16809
// sContamin := true ;
16801: LD_ADDR_EXP 59
16805: PUSH
16806: LD_INT 1
16808: ST_TO_ADDR
// if p3 = 111 then
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 111
16816: EQUAL
16817: IFFALSE 16827
// sOil := true ;
16819: LD_ADDR_EXP 61
16823: PUSH
16824: LD_INT 1
16826: ST_TO_ADDR
// if p3 = 112 then
16827: LD_VAR 0 3
16831: PUSH
16832: LD_INT 112
16834: EQUAL
16835: IFFALSE 16845
// sStu := true ;
16837: LD_ADDR_EXP 65
16841: PUSH
16842: LD_INT 1
16844: ST_TO_ADDR
// if p3 = 113 then
16845: LD_VAR 0 3
16849: PUSH
16850: LD_INT 113
16852: EQUAL
16853: IFFALSE 16863
// sBazooka := true ;
16855: LD_ADDR_EXP 68
16859: PUSH
16860: LD_INT 1
16862: ST_TO_ADDR
// if p3 = 114 then
16863: LD_VAR 0 3
16867: PUSH
16868: LD_INT 114
16870: EQUAL
16871: IFFALSE 16881
// sMortar := true ;
16873: LD_ADDR_EXP 69
16877: PUSH
16878: LD_INT 1
16880: ST_TO_ADDR
// if p3 = 115 then
16881: LD_VAR 0 3
16885: PUSH
16886: LD_INT 115
16888: EQUAL
16889: IFFALSE 16899
// sRanger := true ;
16891: LD_ADDR_EXP 79
16895: PUSH
16896: LD_INT 1
16898: ST_TO_ADDR
// end ; end ;
16899: PPOPN 6
16901: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16902: LD_EXP 26
16906: PUSH
16907: LD_EXP 31
16911: AND
16912: IFFALSE 17036
16914: GO 16916
16916: DISABLE
16917: LD_INT 0
16919: PPUSH
16920: PPUSH
// begin enable ;
16921: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16922: LD_ADDR_VAR 0 2
16926: PUSH
16927: LD_INT 22
16929: PUSH
16930: LD_OWVAR 2
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 2
16941: PUSH
16942: LD_INT 34
16944: PUSH
16945: LD_INT 7
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: PUSH
16952: LD_INT 34
16954: PUSH
16955: LD_INT 45
16957: PUSH
16958: EMPTY
16959: LIST
16960: LIST
16961: PUSH
16962: LD_INT 34
16964: PUSH
16965: LD_INT 28
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PUSH
16972: LD_INT 34
16974: PUSH
16975: LD_INT 47
16977: PUSH
16978: EMPTY
16979: LIST
16980: LIST
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: PPUSH
16993: CALL_OW 69
16997: ST_TO_ADDR
// if not tmp then
16998: LD_VAR 0 2
17002: NOT
17003: IFFALSE 17007
// exit ;
17005: GO 17036
// for i in tmp do
17007: LD_ADDR_VAR 0 1
17011: PUSH
17012: LD_VAR 0 2
17016: PUSH
17017: FOR_IN
17018: IFFALSE 17034
// begin SetLives ( i , 0 ) ;
17020: LD_VAR 0 1
17024: PPUSH
17025: LD_INT 0
17027: PPUSH
17028: CALL_OW 234
// end ;
17032: GO 17017
17034: POP
17035: POP
// end ;
17036: PPOPN 2
17038: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
17039: LD_EXP 26
17043: PUSH
17044: LD_EXP 32
17048: AND
17049: IFFALSE 17133
17051: GO 17053
17053: DISABLE
17054: LD_INT 0
17056: PPUSH
17057: PPUSH
// begin enable ;
17058: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
17059: LD_ADDR_VAR 0 2
17063: PUSH
17064: LD_INT 22
17066: PUSH
17067: LD_OWVAR 2
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 32
17078: PUSH
17079: LD_INT 3
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: ST_TO_ADDR
// if not tmp then
17095: LD_VAR 0 2
17099: NOT
17100: IFFALSE 17104
// exit ;
17102: GO 17133
// for i in tmp do
17104: LD_ADDR_VAR 0 1
17108: PUSH
17109: LD_VAR 0 2
17113: PUSH
17114: FOR_IN
17115: IFFALSE 17131
// begin SetLives ( i , 0 ) ;
17117: LD_VAR 0 1
17121: PPUSH
17122: LD_INT 0
17124: PPUSH
17125: CALL_OW 234
// end ;
17129: GO 17114
17131: POP
17132: POP
// end ;
17133: PPOPN 2
17135: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
17136: LD_EXP 26
17140: PUSH
17141: LD_EXP 29
17145: AND
17146: IFFALSE 17239
17148: GO 17150
17150: DISABLE
17151: LD_INT 0
17153: PPUSH
// begin enable ;
17154: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
17155: LD_ADDR_VAR 0 1
17159: PUSH
17160: LD_INT 22
17162: PUSH
17163: LD_OWVAR 2
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: LD_INT 2
17174: PUSH
17175: LD_INT 25
17177: PUSH
17178: LD_INT 5
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 25
17187: PUSH
17188: LD_INT 9
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: LD_INT 25
17197: PUSH
17198: LD_INT 8
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: EMPTY
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PPUSH
17215: CALL_OW 69
17219: PUSH
17220: FOR_IN
17221: IFFALSE 17237
// begin SetClass ( i , 1 ) ;
17223: LD_VAR 0 1
17227: PPUSH
17228: LD_INT 1
17230: PPUSH
17231: CALL_OW 336
// end ;
17235: GO 17220
17237: POP
17238: POP
// end ;
17239: PPOPN 1
17241: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17242: LD_EXP 26
17246: PUSH
17247: LD_EXP 30
17251: AND
17252: PUSH
17253: LD_OWVAR 65
17257: PUSH
17258: LD_INT 7
17260: LESS
17261: AND
17262: IFFALSE 17276
17264: GO 17266
17266: DISABLE
// begin enable ;
17267: ENABLE
// game_speed := 7 ;
17268: LD_ADDR_OWVAR 65
17272: PUSH
17273: LD_INT 7
17275: ST_TO_ADDR
// end ;
17276: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17277: LD_EXP 26
17281: PUSH
17282: LD_EXP 33
17286: AND
17287: IFFALSE 17489
17289: GO 17291
17291: DISABLE
17292: LD_INT 0
17294: PPUSH
17295: PPUSH
17296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 81
17304: PUSH
17305: LD_OWVAR 2
17309: PUSH
17310: EMPTY
17311: LIST
17312: LIST
17313: PUSH
17314: LD_INT 21
17316: PUSH
17317: LD_INT 1
17319: PUSH
17320: EMPTY
17321: LIST
17322: LIST
17323: PUSH
17324: EMPTY
17325: LIST
17326: LIST
17327: PPUSH
17328: CALL_OW 69
17332: ST_TO_ADDR
// if not tmp then
17333: LD_VAR 0 3
17337: NOT
17338: IFFALSE 17342
// exit ;
17340: GO 17489
// if tmp > 5 then
17342: LD_VAR 0 3
17346: PUSH
17347: LD_INT 5
17349: GREATER
17350: IFFALSE 17362
// k := 5 else
17352: LD_ADDR_VAR 0 2
17356: PUSH
17357: LD_INT 5
17359: ST_TO_ADDR
17360: GO 17372
// k := tmp ;
17362: LD_ADDR_VAR 0 2
17366: PUSH
17367: LD_VAR 0 3
17371: ST_TO_ADDR
// for i := 1 to k do
17372: LD_ADDR_VAR 0 1
17376: PUSH
17377: DOUBLE
17378: LD_INT 1
17380: DEC
17381: ST_TO_ADDR
17382: LD_VAR 0 2
17386: PUSH
17387: FOR_TO
17388: IFFALSE 17487
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17390: LD_VAR 0 3
17394: PUSH
17395: LD_VAR 0 1
17399: ARRAY
17400: PPUSH
17401: LD_VAR 0 1
17405: PUSH
17406: LD_INT 4
17408: MOD
17409: PUSH
17410: LD_INT 1
17412: PLUS
17413: PPUSH
17414: CALL_OW 259
17418: PUSH
17419: LD_INT 10
17421: LESS
17422: IFFALSE 17485
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17424: LD_VAR 0 3
17428: PUSH
17429: LD_VAR 0 1
17433: ARRAY
17434: PPUSH
17435: LD_VAR 0 1
17439: PUSH
17440: LD_INT 4
17442: MOD
17443: PUSH
17444: LD_INT 1
17446: PLUS
17447: PPUSH
17448: LD_VAR 0 3
17452: PUSH
17453: LD_VAR 0 1
17457: ARRAY
17458: PPUSH
17459: LD_VAR 0 1
17463: PUSH
17464: LD_INT 4
17466: MOD
17467: PUSH
17468: LD_INT 1
17470: PLUS
17471: PPUSH
17472: CALL_OW 259
17476: PUSH
17477: LD_INT 1
17479: PLUS
17480: PPUSH
17481: CALL_OW 237
17485: GO 17387
17487: POP
17488: POP
// end ;
17489: PPOPN 3
17491: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17492: LD_EXP 26
17496: PUSH
17497: LD_EXP 34
17501: AND
17502: IFFALSE 17522
17504: GO 17506
17506: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17507: LD_INT 4
17509: PPUSH
17510: LD_OWVAR 2
17514: PPUSH
17515: LD_INT 0
17517: PPUSH
17518: CALL_OW 324
17522: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17523: LD_EXP 26
17527: PUSH
17528: LD_EXP 63
17532: AND
17533: IFFALSE 17553
17535: GO 17537
17537: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17538: LD_INT 19
17540: PPUSH
17541: LD_OWVAR 2
17545: PPUSH
17546: LD_INT 0
17548: PPUSH
17549: CALL_OW 324
17553: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17554: LD_EXP 26
17558: PUSH
17559: LD_EXP 35
17563: AND
17564: IFFALSE 17666
17566: GO 17568
17568: DISABLE
17569: LD_INT 0
17571: PPUSH
17572: PPUSH
// begin enable ;
17573: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17574: LD_ADDR_VAR 0 2
17578: PUSH
17579: LD_INT 22
17581: PUSH
17582: LD_OWVAR 2
17586: PUSH
17587: EMPTY
17588: LIST
17589: LIST
17590: PUSH
17591: LD_INT 2
17593: PUSH
17594: LD_INT 34
17596: PUSH
17597: LD_INT 11
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: PUSH
17604: LD_INT 34
17606: PUSH
17607: LD_INT 30
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: PPUSH
17623: CALL_OW 69
17627: ST_TO_ADDR
// if not tmp then
17628: LD_VAR 0 2
17632: NOT
17633: IFFALSE 17637
// exit ;
17635: GO 17666
// for i in tmp do
17637: LD_ADDR_VAR 0 1
17641: PUSH
17642: LD_VAR 0 2
17646: PUSH
17647: FOR_IN
17648: IFFALSE 17664
// begin SetLives ( i , 0 ) ;
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 0
17657: PPUSH
17658: CALL_OW 234
// end ;
17662: GO 17647
17664: POP
17665: POP
// end ;
17666: PPOPN 2
17668: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17669: LD_EXP 26
17673: PUSH
17674: LD_EXP 36
17678: AND
17679: IFFALSE 17699
17681: GO 17683
17683: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17684: LD_INT 32
17686: PPUSH
17687: LD_OWVAR 2
17691: PPUSH
17692: LD_INT 0
17694: PPUSH
17695: CALL_OW 324
17699: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17700: LD_EXP 26
17704: PUSH
17705: LD_EXP 37
17709: AND
17710: IFFALSE 17891
17712: GO 17714
17714: DISABLE
17715: LD_INT 0
17717: PPUSH
17718: PPUSH
17719: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17720: LD_ADDR_VAR 0 2
17724: PUSH
17725: LD_INT 22
17727: PUSH
17728: LD_OWVAR 2
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: PUSH
17737: LD_INT 33
17739: PUSH
17740: LD_INT 3
17742: PUSH
17743: EMPTY
17744: LIST
17745: LIST
17746: PUSH
17747: EMPTY
17748: LIST
17749: LIST
17750: PPUSH
17751: CALL_OW 69
17755: ST_TO_ADDR
// if not tmp then
17756: LD_VAR 0 2
17760: NOT
17761: IFFALSE 17765
// exit ;
17763: GO 17891
// side := 0 ;
17765: LD_ADDR_VAR 0 3
17769: PUSH
17770: LD_INT 0
17772: ST_TO_ADDR
// for i := 1 to 8 do
17773: LD_ADDR_VAR 0 1
17777: PUSH
17778: DOUBLE
17779: LD_INT 1
17781: DEC
17782: ST_TO_ADDR
17783: LD_INT 8
17785: PUSH
17786: FOR_TO
17787: IFFALSE 17835
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17789: LD_OWVAR 2
17793: PUSH
17794: LD_VAR 0 1
17798: NONEQUAL
17799: PUSH
17800: LD_OWVAR 2
17804: PPUSH
17805: LD_VAR 0 1
17809: PPUSH
17810: CALL_OW 81
17814: PUSH
17815: LD_INT 2
17817: EQUAL
17818: AND
17819: IFFALSE 17833
// begin side := i ;
17821: LD_ADDR_VAR 0 3
17825: PUSH
17826: LD_VAR 0 1
17830: ST_TO_ADDR
// break ;
17831: GO 17835
// end ;
17833: GO 17786
17835: POP
17836: POP
// if not side then
17837: LD_VAR 0 3
17841: NOT
17842: IFFALSE 17846
// exit ;
17844: GO 17891
// for i := 1 to tmp do
17846: LD_ADDR_VAR 0 1
17850: PUSH
17851: DOUBLE
17852: LD_INT 1
17854: DEC
17855: ST_TO_ADDR
17856: LD_VAR 0 2
17860: PUSH
17861: FOR_TO
17862: IFFALSE 17889
// if Prob ( 60 ) then
17864: LD_INT 60
17866: PPUSH
17867: CALL_OW 13
17871: IFFALSE 17887
// SetSide ( i , side ) ;
17873: LD_VAR 0 1
17877: PPUSH
17878: LD_VAR 0 3
17882: PPUSH
17883: CALL_OW 235
17887: GO 17861
17889: POP
17890: POP
// end ;
17891: PPOPN 3
17893: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17894: LD_EXP 26
17898: PUSH
17899: LD_EXP 39
17903: AND
17904: IFFALSE 18023
17906: GO 17908
17908: DISABLE
17909: LD_INT 0
17911: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17912: LD_ADDR_VAR 0 1
17916: PUSH
17917: LD_INT 22
17919: PUSH
17920: LD_OWVAR 2
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PUSH
17929: LD_INT 21
17931: PUSH
17932: LD_INT 1
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 23
17944: PUSH
17945: LD_INT 0
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: LIST
17960: PPUSH
17961: CALL_OW 69
17965: PUSH
17966: FOR_IN
17967: IFFALSE 18021
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17969: LD_VAR 0 1
17973: PPUSH
17974: CALL_OW 257
17978: PUSH
17979: LD_INT 1
17981: PUSH
17982: LD_INT 2
17984: PUSH
17985: LD_INT 3
17987: PUSH
17988: LD_INT 4
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: IN
17997: IFFALSE 18019
// SetClass ( un , rand ( 1 , 4 ) ) ;
17999: LD_VAR 0 1
18003: PPUSH
18004: LD_INT 1
18006: PPUSH
18007: LD_INT 4
18009: PPUSH
18010: CALL_OW 12
18014: PPUSH
18015: CALL_OW 336
18019: GO 17966
18021: POP
18022: POP
// end ;
18023: PPOPN 1
18025: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
18026: LD_EXP 26
18030: PUSH
18031: LD_EXP 38
18035: AND
18036: IFFALSE 18115
18038: GO 18040
18040: DISABLE
18041: LD_INT 0
18043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18044: LD_ADDR_VAR 0 1
18048: PUSH
18049: LD_INT 22
18051: PUSH
18052: LD_OWVAR 2
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: PUSH
18061: LD_INT 21
18063: PUSH
18064: LD_INT 3
18066: PUSH
18067: EMPTY
18068: LIST
18069: LIST
18070: PUSH
18071: EMPTY
18072: LIST
18073: LIST
18074: PPUSH
18075: CALL_OW 69
18079: ST_TO_ADDR
// if not tmp then
18080: LD_VAR 0 1
18084: NOT
18085: IFFALSE 18089
// exit ;
18087: GO 18115
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
18089: LD_VAR 0 1
18093: PUSH
18094: LD_INT 1
18096: PPUSH
18097: LD_VAR 0 1
18101: PPUSH
18102: CALL_OW 12
18106: ARRAY
18107: PPUSH
18108: LD_INT 100
18110: PPUSH
18111: CALL_OW 234
// end ;
18115: PPOPN 1
18117: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
18118: LD_EXP 26
18122: PUSH
18123: LD_EXP 40
18127: AND
18128: IFFALSE 18226
18130: GO 18132
18132: DISABLE
18133: LD_INT 0
18135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18136: LD_ADDR_VAR 0 1
18140: PUSH
18141: LD_INT 22
18143: PUSH
18144: LD_OWVAR 2
18148: PUSH
18149: EMPTY
18150: LIST
18151: LIST
18152: PUSH
18153: LD_INT 21
18155: PUSH
18156: LD_INT 1
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PPUSH
18167: CALL_OW 69
18171: ST_TO_ADDR
// if not tmp then
18172: LD_VAR 0 1
18176: NOT
18177: IFFALSE 18181
// exit ;
18179: GO 18226
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18181: LD_VAR 0 1
18185: PUSH
18186: LD_INT 1
18188: PPUSH
18189: LD_VAR 0 1
18193: PPUSH
18194: CALL_OW 12
18198: ARRAY
18199: PPUSH
18200: LD_INT 1
18202: PPUSH
18203: LD_INT 4
18205: PPUSH
18206: CALL_OW 12
18210: PPUSH
18211: LD_INT 3000
18213: PPUSH
18214: LD_INT 9000
18216: PPUSH
18217: CALL_OW 12
18221: PPUSH
18222: CALL_OW 492
// end ;
18226: PPOPN 1
18228: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18229: LD_EXP 26
18233: PUSH
18234: LD_EXP 41
18238: AND
18239: IFFALSE 18259
18241: GO 18243
18243: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18244: LD_INT 1
18246: PPUSH
18247: LD_OWVAR 2
18251: PPUSH
18252: LD_INT 0
18254: PPUSH
18255: CALL_OW 324
18259: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18260: LD_EXP 26
18264: PUSH
18265: LD_EXP 42
18269: AND
18270: IFFALSE 18353
18272: GO 18274
18274: DISABLE
18275: LD_INT 0
18277: PPUSH
18278: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18279: LD_ADDR_VAR 0 2
18283: PUSH
18284: LD_INT 22
18286: PUSH
18287: LD_OWVAR 2
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: PUSH
18296: LD_INT 21
18298: PUSH
18299: LD_INT 3
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PPUSH
18310: CALL_OW 69
18314: ST_TO_ADDR
// if not tmp then
18315: LD_VAR 0 2
18319: NOT
18320: IFFALSE 18324
// exit ;
18322: GO 18353
// for i in tmp do
18324: LD_ADDR_VAR 0 1
18328: PUSH
18329: LD_VAR 0 2
18333: PUSH
18334: FOR_IN
18335: IFFALSE 18351
// SetBLevel ( i , 10 ) ;
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_INT 10
18344: PPUSH
18345: CALL_OW 241
18349: GO 18334
18351: POP
18352: POP
// end ;
18353: PPOPN 2
18355: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18356: LD_EXP 26
18360: PUSH
18361: LD_EXP 43
18365: AND
18366: IFFALSE 18477
18368: GO 18370
18370: DISABLE
18371: LD_INT 0
18373: PPUSH
18374: PPUSH
18375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18376: LD_ADDR_VAR 0 3
18380: PUSH
18381: LD_INT 22
18383: PUSH
18384: LD_OWVAR 2
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: LD_INT 25
18395: PUSH
18396: LD_INT 1
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: PPUSH
18407: CALL_OW 69
18411: ST_TO_ADDR
// if not tmp then
18412: LD_VAR 0 3
18416: NOT
18417: IFFALSE 18421
// exit ;
18419: GO 18477
// un := tmp [ rand ( 1 , tmp ) ] ;
18421: LD_ADDR_VAR 0 2
18425: PUSH
18426: LD_VAR 0 3
18430: PUSH
18431: LD_INT 1
18433: PPUSH
18434: LD_VAR 0 3
18438: PPUSH
18439: CALL_OW 12
18443: ARRAY
18444: ST_TO_ADDR
// if Crawls ( un ) then
18445: LD_VAR 0 2
18449: PPUSH
18450: CALL_OW 318
18454: IFFALSE 18465
// ComWalk ( un ) ;
18456: LD_VAR 0 2
18460: PPUSH
18461: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18465: LD_VAR 0 2
18469: PPUSH
18470: LD_INT 5
18472: PPUSH
18473: CALL_OW 336
// end ;
18477: PPOPN 3
18479: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18480: LD_EXP 26
18484: PUSH
18485: LD_EXP 44
18489: AND
18490: PUSH
18491: LD_OWVAR 67
18495: PUSH
18496: LD_INT 3
18498: LESS
18499: AND
18500: IFFALSE 18519
18502: GO 18504
18504: DISABLE
// Difficulty := Difficulty + 1 ;
18505: LD_ADDR_OWVAR 67
18509: PUSH
18510: LD_OWVAR 67
18514: PUSH
18515: LD_INT 1
18517: PLUS
18518: ST_TO_ADDR
18519: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18520: LD_EXP 26
18524: PUSH
18525: LD_EXP 45
18529: AND
18530: IFFALSE 18633
18532: GO 18534
18534: DISABLE
18535: LD_INT 0
18537: PPUSH
// begin for i := 1 to 5 do
18538: LD_ADDR_VAR 0 1
18542: PUSH
18543: DOUBLE
18544: LD_INT 1
18546: DEC
18547: ST_TO_ADDR
18548: LD_INT 5
18550: PUSH
18551: FOR_TO
18552: IFFALSE 18631
// begin uc_nation := nation_nature ;
18554: LD_ADDR_OWVAR 21
18558: PUSH
18559: LD_INT 0
18561: ST_TO_ADDR
// uc_side := 0 ;
18562: LD_ADDR_OWVAR 20
18566: PUSH
18567: LD_INT 0
18569: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18570: LD_ADDR_OWVAR 29
18574: PUSH
18575: LD_INT 12
18577: PUSH
18578: LD_INT 12
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: ST_TO_ADDR
// hc_agressivity := 20 ;
18585: LD_ADDR_OWVAR 35
18589: PUSH
18590: LD_INT 20
18592: ST_TO_ADDR
// hc_class := class_tiger ;
18593: LD_ADDR_OWVAR 28
18597: PUSH
18598: LD_INT 14
18600: ST_TO_ADDR
// hc_gallery :=  ;
18601: LD_ADDR_OWVAR 33
18605: PUSH
18606: LD_STRING 
18608: ST_TO_ADDR
// hc_name :=  ;
18609: LD_ADDR_OWVAR 26
18613: PUSH
18614: LD_STRING 
18616: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18617: CALL_OW 44
18621: PPUSH
18622: LD_INT 0
18624: PPUSH
18625: CALL_OW 51
// end ;
18629: GO 18551
18631: POP
18632: POP
// end ;
18633: PPOPN 1
18635: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18636: LD_EXP 26
18640: PUSH
18641: LD_EXP 46
18645: AND
18646: IFFALSE 18655
18648: GO 18650
18650: DISABLE
// StreamSibBomb ;
18651: CALL 18656 0 0
18655: END
// export function StreamSibBomb ; var i , x , y ; begin
18656: LD_INT 0
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
// result := false ;
18662: LD_ADDR_VAR 0 1
18666: PUSH
18667: LD_INT 0
18669: ST_TO_ADDR
// for i := 1 to 16 do
18670: LD_ADDR_VAR 0 2
18674: PUSH
18675: DOUBLE
18676: LD_INT 1
18678: DEC
18679: ST_TO_ADDR
18680: LD_INT 16
18682: PUSH
18683: FOR_TO
18684: IFFALSE 18883
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18686: LD_ADDR_VAR 0 3
18690: PUSH
18691: LD_INT 10
18693: PUSH
18694: LD_INT 20
18696: PUSH
18697: LD_INT 30
18699: PUSH
18700: LD_INT 40
18702: PUSH
18703: LD_INT 50
18705: PUSH
18706: LD_INT 60
18708: PUSH
18709: LD_INT 70
18711: PUSH
18712: LD_INT 80
18714: PUSH
18715: LD_INT 90
18717: PUSH
18718: LD_INT 100
18720: PUSH
18721: LD_INT 110
18723: PUSH
18724: LD_INT 120
18726: PUSH
18727: LD_INT 130
18729: PUSH
18730: LD_INT 140
18732: PUSH
18733: LD_INT 150
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: LIST
18740: LIST
18741: LIST
18742: LIST
18743: LIST
18744: LIST
18745: LIST
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: LIST
18751: LIST
18752: PUSH
18753: LD_INT 1
18755: PPUSH
18756: LD_INT 15
18758: PPUSH
18759: CALL_OW 12
18763: ARRAY
18764: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18765: LD_ADDR_VAR 0 4
18769: PUSH
18770: LD_INT 10
18772: PUSH
18773: LD_INT 20
18775: PUSH
18776: LD_INT 30
18778: PUSH
18779: LD_INT 40
18781: PUSH
18782: LD_INT 50
18784: PUSH
18785: LD_INT 60
18787: PUSH
18788: LD_INT 70
18790: PUSH
18791: LD_INT 80
18793: PUSH
18794: LD_INT 90
18796: PUSH
18797: LD_INT 100
18799: PUSH
18800: LD_INT 110
18802: PUSH
18803: LD_INT 120
18805: PUSH
18806: LD_INT 130
18808: PUSH
18809: LD_INT 140
18811: PUSH
18812: LD_INT 150
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: LIST
18831: PUSH
18832: LD_INT 1
18834: PPUSH
18835: LD_INT 15
18837: PPUSH
18838: CALL_OW 12
18842: ARRAY
18843: ST_TO_ADDR
// if ValidHex ( x , y ) then
18844: LD_VAR 0 3
18848: PPUSH
18849: LD_VAR 0 4
18853: PPUSH
18854: CALL_OW 488
18858: IFFALSE 18881
// begin result := [ x , y ] ;
18860: LD_ADDR_VAR 0 1
18864: PUSH
18865: LD_VAR 0 3
18869: PUSH
18870: LD_VAR 0 4
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: ST_TO_ADDR
// break ;
18879: GO 18883
// end ; end ;
18881: GO 18683
18883: POP
18884: POP
// if result then
18885: LD_VAR 0 1
18889: IFFALSE 18949
// begin ToLua ( playSibBomb() ) ;
18891: LD_STRING playSibBomb()
18893: PPUSH
18894: CALL_OW 559
// wait ( 0 0$14 ) ;
18898: LD_INT 490
18900: PPUSH
18901: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18905: LD_VAR 0 1
18909: PUSH
18910: LD_INT 1
18912: ARRAY
18913: PPUSH
18914: LD_VAR 0 1
18918: PUSH
18919: LD_INT 2
18921: ARRAY
18922: PPUSH
18923: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18927: LD_VAR 0 1
18931: PUSH
18932: LD_INT 1
18934: ARRAY
18935: PPUSH
18936: LD_VAR 0 1
18940: PUSH
18941: LD_INT 2
18943: ARRAY
18944: PPUSH
18945: CALL_OW 429
// end ; end ;
18949: LD_VAR 0 1
18953: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18954: LD_EXP 26
18958: PUSH
18959: LD_EXP 48
18963: AND
18964: IFFALSE 18976
18966: GO 18968
18968: DISABLE
// YouLost (  ) ;
18969: LD_STRING 
18971: PPUSH
18972: CALL_OW 104
18976: END
// every 0 0$1 trigger StreamModeActive and sFog do
18977: LD_EXP 26
18981: PUSH
18982: LD_EXP 47
18986: AND
18987: IFFALSE 19001
18989: GO 18991
18991: DISABLE
// FogOff ( your_side ) ;
18992: LD_OWVAR 2
18996: PPUSH
18997: CALL_OW 344
19001: END
// every 0 0$1 trigger StreamModeActive and sSun do
19002: LD_EXP 26
19006: PUSH
19007: LD_EXP 49
19011: AND
19012: IFFALSE 19040
19014: GO 19016
19016: DISABLE
// begin solar_recharge_percent := 0 ;
19017: LD_ADDR_OWVAR 79
19021: PUSH
19022: LD_INT 0
19024: ST_TO_ADDR
// wait ( 5 5$00 ) ;
19025: LD_INT 10500
19027: PPUSH
19028: CALL_OW 67
// solar_recharge_percent := 100 ;
19032: LD_ADDR_OWVAR 79
19036: PUSH
19037: LD_INT 100
19039: ST_TO_ADDR
// end ;
19040: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
19041: LD_EXP 26
19045: PUSH
19046: LD_EXP 50
19050: AND
19051: IFFALSE 19290
19053: GO 19055
19055: DISABLE
19056: LD_INT 0
19058: PPUSH
19059: PPUSH
19060: PPUSH
// begin tmp := [ ] ;
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: EMPTY
19067: ST_TO_ADDR
// for i := 1 to 6 do
19068: LD_ADDR_VAR 0 1
19072: PUSH
19073: DOUBLE
19074: LD_INT 1
19076: DEC
19077: ST_TO_ADDR
19078: LD_INT 6
19080: PUSH
19081: FOR_TO
19082: IFFALSE 19187
// begin uc_nation := nation_nature ;
19084: LD_ADDR_OWVAR 21
19088: PUSH
19089: LD_INT 0
19091: ST_TO_ADDR
// uc_side := 0 ;
19092: LD_ADDR_OWVAR 20
19096: PUSH
19097: LD_INT 0
19099: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
19100: LD_ADDR_OWVAR 29
19104: PUSH
19105: LD_INT 12
19107: PUSH
19108: LD_INT 12
19110: PUSH
19111: EMPTY
19112: LIST
19113: LIST
19114: ST_TO_ADDR
// hc_agressivity := 20 ;
19115: LD_ADDR_OWVAR 35
19119: PUSH
19120: LD_INT 20
19122: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
19123: LD_ADDR_OWVAR 28
19127: PUSH
19128: LD_INT 17
19130: ST_TO_ADDR
// hc_gallery :=  ;
19131: LD_ADDR_OWVAR 33
19135: PUSH
19136: LD_STRING 
19138: ST_TO_ADDR
// hc_name :=  ;
19139: LD_ADDR_OWVAR 26
19143: PUSH
19144: LD_STRING 
19146: ST_TO_ADDR
// un := CreateHuman ;
19147: LD_ADDR_VAR 0 2
19151: PUSH
19152: CALL_OW 44
19156: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
19157: LD_VAR 0 2
19161: PPUSH
19162: LD_INT 1
19164: PPUSH
19165: CALL_OW 51
// tmp := tmp ^ un ;
19169: LD_ADDR_VAR 0 3
19173: PUSH
19174: LD_VAR 0 3
19178: PUSH
19179: LD_VAR 0 2
19183: ADD
19184: ST_TO_ADDR
// end ;
19185: GO 19081
19187: POP
19188: POP
// repeat wait ( 0 0$1 ) ;
19189: LD_INT 35
19191: PPUSH
19192: CALL_OW 67
// for un in tmp do
19196: LD_ADDR_VAR 0 2
19200: PUSH
19201: LD_VAR 0 3
19205: PUSH
19206: FOR_IN
19207: IFFALSE 19281
// begin if IsDead ( un ) then
19209: LD_VAR 0 2
19213: PPUSH
19214: CALL_OW 301
19218: IFFALSE 19238
// begin tmp := tmp diff un ;
19220: LD_ADDR_VAR 0 3
19224: PUSH
19225: LD_VAR 0 3
19229: PUSH
19230: LD_VAR 0 2
19234: DIFF
19235: ST_TO_ADDR
// continue ;
19236: GO 19206
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19238: LD_VAR 0 2
19242: PPUSH
19243: LD_INT 3
19245: PUSH
19246: LD_INT 22
19248: PUSH
19249: LD_INT 0
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: PUSH
19256: EMPTY
19257: LIST
19258: LIST
19259: PPUSH
19260: CALL_OW 69
19264: PPUSH
19265: LD_VAR 0 2
19269: PPUSH
19270: CALL_OW 74
19274: PPUSH
19275: CALL_OW 115
// end ;
19279: GO 19206
19281: POP
19282: POP
// until not tmp ;
19283: LD_VAR 0 3
19287: NOT
19288: IFFALSE 19189
// end ;
19290: PPOPN 3
19292: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19293: LD_EXP 26
19297: PUSH
19298: LD_EXP 51
19302: AND
19303: IFFALSE 19357
19305: GO 19307
19307: DISABLE
// begin ToLua ( displayTroll(); ) ;
19308: LD_STRING displayTroll();
19310: PPUSH
19311: CALL_OW 559
// wait ( 3 3$00 ) ;
19315: LD_INT 6300
19317: PPUSH
19318: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19322: LD_STRING hideTroll();
19324: PPUSH
19325: CALL_OW 559
// wait ( 1 1$00 ) ;
19329: LD_INT 2100
19331: PPUSH
19332: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19336: LD_STRING displayTroll();
19338: PPUSH
19339: CALL_OW 559
// wait ( 1 1$00 ) ;
19343: LD_INT 2100
19345: PPUSH
19346: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19350: LD_STRING hideTroll();
19352: PPUSH
19353: CALL_OW 559
// end ;
19357: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19358: LD_EXP 26
19362: PUSH
19363: LD_EXP 52
19367: AND
19368: IFFALSE 19431
19370: GO 19372
19372: DISABLE
19373: LD_INT 0
19375: PPUSH
// begin p := 0 ;
19376: LD_ADDR_VAR 0 1
19380: PUSH
19381: LD_INT 0
19383: ST_TO_ADDR
// repeat game_speed := 1 ;
19384: LD_ADDR_OWVAR 65
19388: PUSH
19389: LD_INT 1
19391: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19392: LD_INT 35
19394: PPUSH
19395: CALL_OW 67
// p := p + 1 ;
19399: LD_ADDR_VAR 0 1
19403: PUSH
19404: LD_VAR 0 1
19408: PUSH
19409: LD_INT 1
19411: PLUS
19412: ST_TO_ADDR
// until p >= 60 ;
19413: LD_VAR 0 1
19417: PUSH
19418: LD_INT 60
19420: GREATEREQUAL
19421: IFFALSE 19384
// game_speed := 4 ;
19423: LD_ADDR_OWVAR 65
19427: PUSH
19428: LD_INT 4
19430: ST_TO_ADDR
// end ;
19431: PPOPN 1
19433: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19434: LD_EXP 26
19438: PUSH
19439: LD_EXP 53
19443: AND
19444: IFFALSE 19590
19446: GO 19448
19448: DISABLE
19449: LD_INT 0
19451: PPUSH
19452: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19453: LD_ADDR_VAR 0 1
19457: PUSH
19458: LD_INT 22
19460: PUSH
19461: LD_OWVAR 2
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: PUSH
19470: LD_INT 2
19472: PUSH
19473: LD_INT 30
19475: PUSH
19476: LD_INT 0
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: PUSH
19483: LD_INT 30
19485: PUSH
19486: LD_INT 1
19488: PUSH
19489: EMPTY
19490: LIST
19491: LIST
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: PUSH
19498: EMPTY
19499: LIST
19500: LIST
19501: PPUSH
19502: CALL_OW 69
19506: ST_TO_ADDR
// if not depot then
19507: LD_VAR 0 1
19511: NOT
19512: IFFALSE 19516
// exit ;
19514: GO 19590
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19516: LD_ADDR_VAR 0 2
19520: PUSH
19521: LD_VAR 0 1
19525: PUSH
19526: LD_INT 1
19528: PPUSH
19529: LD_VAR 0 1
19533: PPUSH
19534: CALL_OW 12
19538: ARRAY
19539: PPUSH
19540: CALL_OW 274
19544: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19545: LD_VAR 0 2
19549: PPUSH
19550: LD_INT 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19560: LD_VAR 0 2
19564: PPUSH
19565: LD_INT 2
19567: PPUSH
19568: LD_INT 0
19570: PPUSH
19571: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19575: LD_VAR 0 2
19579: PPUSH
19580: LD_INT 3
19582: PPUSH
19583: LD_INT 0
19585: PPUSH
19586: CALL_OW 277
// end ;
19590: PPOPN 2
19592: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19593: LD_EXP 26
19597: PUSH
19598: LD_EXP 54
19602: AND
19603: IFFALSE 19700
19605: GO 19607
19607: DISABLE
19608: LD_INT 0
19610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19611: LD_ADDR_VAR 0 1
19615: PUSH
19616: LD_INT 22
19618: PUSH
19619: LD_OWVAR 2
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 21
19630: PUSH
19631: LD_INT 1
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 3
19640: PUSH
19641: LD_INT 23
19643: PUSH
19644: LD_INT 0
19646: PUSH
19647: EMPTY
19648: LIST
19649: LIST
19650: PUSH
19651: EMPTY
19652: LIST
19653: LIST
19654: PUSH
19655: EMPTY
19656: LIST
19657: LIST
19658: LIST
19659: PPUSH
19660: CALL_OW 69
19664: ST_TO_ADDR
// if not tmp then
19665: LD_VAR 0 1
19669: NOT
19670: IFFALSE 19674
// exit ;
19672: GO 19700
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19674: LD_VAR 0 1
19678: PUSH
19679: LD_INT 1
19681: PPUSH
19682: LD_VAR 0 1
19686: PPUSH
19687: CALL_OW 12
19691: ARRAY
19692: PPUSH
19693: LD_INT 200
19695: PPUSH
19696: CALL_OW 234
// end ;
19700: PPOPN 1
19702: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19703: LD_EXP 26
19707: PUSH
19708: LD_EXP 55
19712: AND
19713: IFFALSE 19792
19715: GO 19717
19717: DISABLE
19718: LD_INT 0
19720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19721: LD_ADDR_VAR 0 1
19725: PUSH
19726: LD_INT 22
19728: PUSH
19729: LD_OWVAR 2
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: PUSH
19738: LD_INT 21
19740: PUSH
19741: LD_INT 2
19743: PUSH
19744: EMPTY
19745: LIST
19746: LIST
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: PPUSH
19752: CALL_OW 69
19756: ST_TO_ADDR
// if not tmp then
19757: LD_VAR 0 1
19761: NOT
19762: IFFALSE 19766
// exit ;
19764: GO 19792
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19766: LD_VAR 0 1
19770: PUSH
19771: LD_INT 1
19773: PPUSH
19774: LD_VAR 0 1
19778: PPUSH
19779: CALL_OW 12
19783: ARRAY
19784: PPUSH
19785: LD_INT 60
19787: PPUSH
19788: CALL_OW 234
// end ;
19792: PPOPN 1
19794: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19795: LD_EXP 26
19799: PUSH
19800: LD_EXP 56
19804: AND
19805: IFFALSE 19904
19807: GO 19809
19809: DISABLE
19810: LD_INT 0
19812: PPUSH
19813: PPUSH
// begin enable ;
19814: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19815: LD_ADDR_VAR 0 1
19819: PUSH
19820: LD_INT 22
19822: PUSH
19823: LD_OWVAR 2
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: PUSH
19832: LD_INT 61
19834: PUSH
19835: EMPTY
19836: LIST
19837: PUSH
19838: LD_INT 33
19840: PUSH
19841: LD_INT 2
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: LIST
19852: PPUSH
19853: CALL_OW 69
19857: ST_TO_ADDR
// if not tmp then
19858: LD_VAR 0 1
19862: NOT
19863: IFFALSE 19867
// exit ;
19865: GO 19904
// for i in tmp do
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 1
19876: PUSH
19877: FOR_IN
19878: IFFALSE 19902
// if IsControledBy ( i ) then
19880: LD_VAR 0 2
19884: PPUSH
19885: CALL_OW 312
19889: IFFALSE 19900
// ComUnlink ( i ) ;
19891: LD_VAR 0 2
19895: PPUSH
19896: CALL_OW 136
19900: GO 19877
19902: POP
19903: POP
// end ;
19904: PPOPN 2
19906: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19907: LD_EXP 26
19911: PUSH
19912: LD_EXP 57
19916: AND
19917: IFFALSE 20057
19919: GO 19921
19921: DISABLE
19922: LD_INT 0
19924: PPUSH
19925: PPUSH
// begin ToLua ( displayPowell(); ) ;
19926: LD_STRING displayPowell();
19928: PPUSH
19929: CALL_OW 559
// uc_side := 0 ;
19933: LD_ADDR_OWVAR 20
19937: PUSH
19938: LD_INT 0
19940: ST_TO_ADDR
// uc_nation := 2 ;
19941: LD_ADDR_OWVAR 21
19945: PUSH
19946: LD_INT 2
19948: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19949: LD_ADDR_OWVAR 37
19953: PUSH
19954: LD_INT 14
19956: ST_TO_ADDR
// vc_engine := engine_siberite ;
19957: LD_ADDR_OWVAR 39
19961: PUSH
19962: LD_INT 3
19964: ST_TO_ADDR
// vc_control := control_apeman ;
19965: LD_ADDR_OWVAR 38
19969: PUSH
19970: LD_INT 5
19972: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19973: LD_ADDR_OWVAR 40
19977: PUSH
19978: LD_INT 29
19980: ST_TO_ADDR
// un := CreateVehicle ;
19981: LD_ADDR_VAR 0 2
19985: PUSH
19986: CALL_OW 45
19990: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19991: LD_VAR 0 2
19995: PPUSH
19996: LD_INT 1
19998: PPUSH
19999: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20003: LD_INT 35
20005: PPUSH
20006: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20010: LD_VAR 0 2
20014: PPUSH
20015: LD_INT 22
20017: PUSH
20018: LD_OWVAR 2
20022: PUSH
20023: EMPTY
20024: LIST
20025: LIST
20026: PPUSH
20027: CALL_OW 69
20031: PPUSH
20032: LD_VAR 0 2
20036: PPUSH
20037: CALL_OW 74
20041: PPUSH
20042: CALL_OW 115
// until IsDead ( un ) ;
20046: LD_VAR 0 2
20050: PPUSH
20051: CALL_OW 301
20055: IFFALSE 20003
// end ;
20057: PPOPN 2
20059: END
// every 0 0$1 trigger StreamModeActive and sStu do
20060: LD_EXP 26
20064: PUSH
20065: LD_EXP 65
20069: AND
20070: IFFALSE 20086
20072: GO 20074
20074: DISABLE
// begin ToLua ( displayStucuk(); ) ;
20075: LD_STRING displayStucuk();
20077: PPUSH
20078: CALL_OW 559
// ResetFog ;
20082: CALL_OW 335
// end ;
20086: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
20087: LD_EXP 26
20091: PUSH
20092: LD_EXP 58
20096: AND
20097: IFFALSE 20238
20099: GO 20101
20101: DISABLE
20102: LD_INT 0
20104: PPUSH
20105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20106: LD_ADDR_VAR 0 2
20110: PUSH
20111: LD_INT 22
20113: PUSH
20114: LD_OWVAR 2
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: PUSH
20123: LD_INT 21
20125: PUSH
20126: LD_INT 1
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PUSH
20133: EMPTY
20134: LIST
20135: LIST
20136: PPUSH
20137: CALL_OW 69
20141: ST_TO_ADDR
// if not tmp then
20142: LD_VAR 0 2
20146: NOT
20147: IFFALSE 20151
// exit ;
20149: GO 20238
// un := tmp [ rand ( 1 , tmp ) ] ;
20151: LD_ADDR_VAR 0 1
20155: PUSH
20156: LD_VAR 0 2
20160: PUSH
20161: LD_INT 1
20163: PPUSH
20164: LD_VAR 0 2
20168: PPUSH
20169: CALL_OW 12
20173: ARRAY
20174: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20175: LD_VAR 0 1
20179: PPUSH
20180: LD_INT 0
20182: PPUSH
20183: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20187: LD_VAR 0 1
20191: PPUSH
20192: LD_OWVAR 3
20196: PUSH
20197: LD_VAR 0 1
20201: DIFF
20202: PPUSH
20203: LD_VAR 0 1
20207: PPUSH
20208: CALL_OW 74
20212: PPUSH
20213: CALL_OW 115
// wait ( 0 0$20 ) ;
20217: LD_INT 700
20219: PPUSH
20220: CALL_OW 67
// SetSide ( un , your_side ) ;
20224: LD_VAR 0 1
20228: PPUSH
20229: LD_OWVAR 2
20233: PPUSH
20234: CALL_OW 235
// end ;
20238: PPOPN 2
20240: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20241: LD_EXP 26
20245: PUSH
20246: LD_EXP 59
20250: AND
20251: IFFALSE 20357
20253: GO 20255
20255: DISABLE
20256: LD_INT 0
20258: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20259: LD_ADDR_VAR 0 1
20263: PUSH
20264: LD_INT 22
20266: PUSH
20267: LD_OWVAR 2
20271: PUSH
20272: EMPTY
20273: LIST
20274: LIST
20275: PUSH
20276: LD_INT 2
20278: PUSH
20279: LD_INT 30
20281: PUSH
20282: LD_INT 0
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 30
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: LIST
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: PPUSH
20308: CALL_OW 69
20312: ST_TO_ADDR
// if not depot then
20313: LD_VAR 0 1
20317: NOT
20318: IFFALSE 20322
// exit ;
20320: GO 20357
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20322: LD_VAR 0 1
20326: PUSH
20327: LD_INT 1
20329: ARRAY
20330: PPUSH
20331: CALL_OW 250
20335: PPUSH
20336: LD_VAR 0 1
20340: PUSH
20341: LD_INT 1
20343: ARRAY
20344: PPUSH
20345: CALL_OW 251
20349: PPUSH
20350: LD_INT 70
20352: PPUSH
20353: CALL_OW 495
// end ;
20357: PPOPN 1
20359: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20360: LD_EXP 26
20364: PUSH
20365: LD_EXP 60
20369: AND
20370: IFFALSE 20581
20372: GO 20374
20374: DISABLE
20375: LD_INT 0
20377: PPUSH
20378: PPUSH
20379: PPUSH
20380: PPUSH
20381: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20382: LD_ADDR_VAR 0 5
20386: PUSH
20387: LD_INT 22
20389: PUSH
20390: LD_OWVAR 2
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 21
20401: PUSH
20402: LD_INT 1
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: PPUSH
20413: CALL_OW 69
20417: ST_TO_ADDR
// if not tmp then
20418: LD_VAR 0 5
20422: NOT
20423: IFFALSE 20427
// exit ;
20425: GO 20581
// for i in tmp do
20427: LD_ADDR_VAR 0 1
20431: PUSH
20432: LD_VAR 0 5
20436: PUSH
20437: FOR_IN
20438: IFFALSE 20579
// begin d := rand ( 0 , 5 ) ;
20440: LD_ADDR_VAR 0 4
20444: PUSH
20445: LD_INT 0
20447: PPUSH
20448: LD_INT 5
20450: PPUSH
20451: CALL_OW 12
20455: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20456: LD_ADDR_VAR 0 2
20460: PUSH
20461: LD_VAR 0 1
20465: PPUSH
20466: CALL_OW 250
20470: PPUSH
20471: LD_VAR 0 4
20475: PPUSH
20476: LD_INT 3
20478: PPUSH
20479: LD_INT 12
20481: PPUSH
20482: CALL_OW 12
20486: PPUSH
20487: CALL_OW 272
20491: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20492: LD_ADDR_VAR 0 3
20496: PUSH
20497: LD_VAR 0 1
20501: PPUSH
20502: CALL_OW 251
20506: PPUSH
20507: LD_VAR 0 4
20511: PPUSH
20512: LD_INT 3
20514: PPUSH
20515: LD_INT 12
20517: PPUSH
20518: CALL_OW 12
20522: PPUSH
20523: CALL_OW 273
20527: ST_TO_ADDR
// if ValidHex ( x , y ) then
20528: LD_VAR 0 2
20532: PPUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: CALL_OW 488
20542: IFFALSE 20577
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20544: LD_VAR 0 1
20548: PPUSH
20549: LD_VAR 0 2
20553: PPUSH
20554: LD_VAR 0 3
20558: PPUSH
20559: LD_INT 3
20561: PPUSH
20562: LD_INT 6
20564: PPUSH
20565: CALL_OW 12
20569: PPUSH
20570: LD_INT 1
20572: PPUSH
20573: CALL_OW 483
// end ;
20577: GO 20437
20579: POP
20580: POP
// end ;
20581: PPOPN 5
20583: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20584: LD_EXP 26
20588: PUSH
20589: LD_EXP 61
20593: AND
20594: IFFALSE 20688
20596: GO 20598
20598: DISABLE
20599: LD_INT 0
20601: PPUSH
20602: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20603: LD_ADDR_VAR 0 2
20607: PUSH
20608: LD_INT 22
20610: PUSH
20611: LD_OWVAR 2
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 32
20622: PUSH
20623: LD_INT 1
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: PUSH
20630: LD_INT 21
20632: PUSH
20633: LD_INT 2
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: LIST
20644: PPUSH
20645: CALL_OW 69
20649: ST_TO_ADDR
// if not tmp then
20650: LD_VAR 0 2
20654: NOT
20655: IFFALSE 20659
// exit ;
20657: GO 20688
// for i in tmp do
20659: LD_ADDR_VAR 0 1
20663: PUSH
20664: LD_VAR 0 2
20668: PUSH
20669: FOR_IN
20670: IFFALSE 20686
// SetFuel ( i , 0 ) ;
20672: LD_VAR 0 1
20676: PPUSH
20677: LD_INT 0
20679: PPUSH
20680: CALL_OW 240
20684: GO 20669
20686: POP
20687: POP
// end ;
20688: PPOPN 2
20690: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20691: LD_EXP 26
20695: PUSH
20696: LD_EXP 62
20700: AND
20701: IFFALSE 20767
20703: GO 20705
20705: DISABLE
20706: LD_INT 0
20708: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20709: LD_ADDR_VAR 0 1
20713: PUSH
20714: LD_INT 22
20716: PUSH
20717: LD_OWVAR 2
20721: PUSH
20722: EMPTY
20723: LIST
20724: LIST
20725: PUSH
20726: LD_INT 30
20728: PUSH
20729: LD_INT 29
20731: PUSH
20732: EMPTY
20733: LIST
20734: LIST
20735: PUSH
20736: EMPTY
20737: LIST
20738: LIST
20739: PPUSH
20740: CALL_OW 69
20744: ST_TO_ADDR
// if not tmp then
20745: LD_VAR 0 1
20749: NOT
20750: IFFALSE 20754
// exit ;
20752: GO 20767
// DestroyUnit ( tmp [ 1 ] ) ;
20754: LD_VAR 0 1
20758: PUSH
20759: LD_INT 1
20761: ARRAY
20762: PPUSH
20763: CALL_OW 65
// end ;
20767: PPOPN 1
20769: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20770: LD_EXP 26
20774: PUSH
20775: LD_EXP 64
20779: AND
20780: IFFALSE 20909
20782: GO 20784
20784: DISABLE
20785: LD_INT 0
20787: PPUSH
// begin uc_side := 0 ;
20788: LD_ADDR_OWVAR 20
20792: PUSH
20793: LD_INT 0
20795: ST_TO_ADDR
// uc_nation := nation_arabian ;
20796: LD_ADDR_OWVAR 21
20800: PUSH
20801: LD_INT 2
20803: ST_TO_ADDR
// hc_gallery :=  ;
20804: LD_ADDR_OWVAR 33
20808: PUSH
20809: LD_STRING 
20811: ST_TO_ADDR
// hc_name :=  ;
20812: LD_ADDR_OWVAR 26
20816: PUSH
20817: LD_STRING 
20819: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20820: LD_INT 1
20822: PPUSH
20823: LD_INT 11
20825: PPUSH
20826: LD_INT 10
20828: PPUSH
20829: CALL_OW 380
// un := CreateHuman ;
20833: LD_ADDR_VAR 0 1
20837: PUSH
20838: CALL_OW 44
20842: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20843: LD_VAR 0 1
20847: PPUSH
20848: LD_INT 1
20850: PPUSH
20851: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20855: LD_INT 35
20857: PPUSH
20858: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20862: LD_VAR 0 1
20866: PPUSH
20867: LD_INT 22
20869: PUSH
20870: LD_OWVAR 2
20874: PUSH
20875: EMPTY
20876: LIST
20877: LIST
20878: PPUSH
20879: CALL_OW 69
20883: PPUSH
20884: LD_VAR 0 1
20888: PPUSH
20889: CALL_OW 74
20893: PPUSH
20894: CALL_OW 115
// until IsDead ( un ) ;
20898: LD_VAR 0 1
20902: PPUSH
20903: CALL_OW 301
20907: IFFALSE 20855
// end ;
20909: PPOPN 1
20911: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20912: LD_EXP 26
20916: PUSH
20917: LD_EXP 66
20921: AND
20922: IFFALSE 20934
20924: GO 20926
20926: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20927: LD_STRING earthquake(getX(game), 0, 32)
20929: PPUSH
20930: CALL_OW 559
20934: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20935: LD_EXP 26
20939: PUSH
20940: LD_EXP 67
20944: AND
20945: IFFALSE 21036
20947: GO 20949
20949: DISABLE
20950: LD_INT 0
20952: PPUSH
// begin enable ;
20953: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20954: LD_ADDR_VAR 0 1
20958: PUSH
20959: LD_INT 22
20961: PUSH
20962: LD_OWVAR 2
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PUSH
20971: LD_INT 21
20973: PUSH
20974: LD_INT 2
20976: PUSH
20977: EMPTY
20978: LIST
20979: LIST
20980: PUSH
20981: LD_INT 33
20983: PUSH
20984: LD_INT 3
20986: PUSH
20987: EMPTY
20988: LIST
20989: LIST
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: LIST
20995: PPUSH
20996: CALL_OW 69
21000: ST_TO_ADDR
// if not tmp then
21001: LD_VAR 0 1
21005: NOT
21006: IFFALSE 21010
// exit ;
21008: GO 21036
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21010: LD_VAR 0 1
21014: PUSH
21015: LD_INT 1
21017: PPUSH
21018: LD_VAR 0 1
21022: PPUSH
21023: CALL_OW 12
21027: ARRAY
21028: PPUSH
21029: LD_INT 1
21031: PPUSH
21032: CALL_OW 234
// end ;
21036: PPOPN 1
21038: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
21039: LD_EXP 26
21043: PUSH
21044: LD_EXP 68
21048: AND
21049: IFFALSE 21190
21051: GO 21053
21053: DISABLE
21054: LD_INT 0
21056: PPUSH
21057: PPUSH
21058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21059: LD_ADDR_VAR 0 3
21063: PUSH
21064: LD_INT 22
21066: PUSH
21067: LD_OWVAR 2
21071: PUSH
21072: EMPTY
21073: LIST
21074: LIST
21075: PUSH
21076: LD_INT 25
21078: PUSH
21079: LD_INT 1
21081: PUSH
21082: EMPTY
21083: LIST
21084: LIST
21085: PUSH
21086: EMPTY
21087: LIST
21088: LIST
21089: PPUSH
21090: CALL_OW 69
21094: ST_TO_ADDR
// if not tmp then
21095: LD_VAR 0 3
21099: NOT
21100: IFFALSE 21104
// exit ;
21102: GO 21190
// un := tmp [ rand ( 1 , tmp ) ] ;
21104: LD_ADDR_VAR 0 2
21108: PUSH
21109: LD_VAR 0 3
21113: PUSH
21114: LD_INT 1
21116: PPUSH
21117: LD_VAR 0 3
21121: PPUSH
21122: CALL_OW 12
21126: ARRAY
21127: ST_TO_ADDR
// if Crawls ( un ) then
21128: LD_VAR 0 2
21132: PPUSH
21133: CALL_OW 318
21137: IFFALSE 21148
// ComWalk ( un ) ;
21139: LD_VAR 0 2
21143: PPUSH
21144: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
21148: LD_VAR 0 2
21152: PPUSH
21153: LD_INT 9
21155: PPUSH
21156: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
21160: LD_INT 28
21162: PPUSH
21163: LD_OWVAR 2
21167: PPUSH
21168: LD_INT 2
21170: PPUSH
21171: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21175: LD_INT 29
21177: PPUSH
21178: LD_OWVAR 2
21182: PPUSH
21183: LD_INT 2
21185: PPUSH
21186: CALL_OW 322
// end ;
21190: PPOPN 3
21192: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21193: LD_EXP 26
21197: PUSH
21198: LD_EXP 69
21202: AND
21203: IFFALSE 21314
21205: GO 21207
21207: DISABLE
21208: LD_INT 0
21210: PPUSH
21211: PPUSH
21212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21213: LD_ADDR_VAR 0 3
21217: PUSH
21218: LD_INT 22
21220: PUSH
21221: LD_OWVAR 2
21225: PUSH
21226: EMPTY
21227: LIST
21228: LIST
21229: PUSH
21230: LD_INT 25
21232: PUSH
21233: LD_INT 1
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PPUSH
21244: CALL_OW 69
21248: ST_TO_ADDR
// if not tmp then
21249: LD_VAR 0 3
21253: NOT
21254: IFFALSE 21258
// exit ;
21256: GO 21314
// un := tmp [ rand ( 1 , tmp ) ] ;
21258: LD_ADDR_VAR 0 2
21262: PUSH
21263: LD_VAR 0 3
21267: PUSH
21268: LD_INT 1
21270: PPUSH
21271: LD_VAR 0 3
21275: PPUSH
21276: CALL_OW 12
21280: ARRAY
21281: ST_TO_ADDR
// if Crawls ( un ) then
21282: LD_VAR 0 2
21286: PPUSH
21287: CALL_OW 318
21291: IFFALSE 21302
// ComWalk ( un ) ;
21293: LD_VAR 0 2
21297: PPUSH
21298: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21302: LD_VAR 0 2
21306: PPUSH
21307: LD_INT 8
21309: PPUSH
21310: CALL_OW 336
// end ;
21314: PPOPN 3
21316: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21317: LD_EXP 26
21321: PUSH
21322: LD_EXP 70
21326: AND
21327: IFFALSE 21471
21329: GO 21331
21331: DISABLE
21332: LD_INT 0
21334: PPUSH
21335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21336: LD_ADDR_VAR 0 2
21340: PUSH
21341: LD_INT 22
21343: PUSH
21344: LD_OWVAR 2
21348: PUSH
21349: EMPTY
21350: LIST
21351: LIST
21352: PUSH
21353: LD_INT 21
21355: PUSH
21356: LD_INT 2
21358: PUSH
21359: EMPTY
21360: LIST
21361: LIST
21362: PUSH
21363: LD_INT 2
21365: PUSH
21366: LD_INT 34
21368: PUSH
21369: LD_INT 12
21371: PUSH
21372: EMPTY
21373: LIST
21374: LIST
21375: PUSH
21376: LD_INT 34
21378: PUSH
21379: LD_INT 51
21381: PUSH
21382: EMPTY
21383: LIST
21384: LIST
21385: PUSH
21386: LD_INT 34
21388: PUSH
21389: LD_INT 32
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: PUSH
21396: EMPTY
21397: LIST
21398: LIST
21399: LIST
21400: LIST
21401: PUSH
21402: EMPTY
21403: LIST
21404: LIST
21405: LIST
21406: PPUSH
21407: CALL_OW 69
21411: ST_TO_ADDR
// if not tmp then
21412: LD_VAR 0 2
21416: NOT
21417: IFFALSE 21421
// exit ;
21419: GO 21471
// for i in tmp do
21421: LD_ADDR_VAR 0 1
21425: PUSH
21426: LD_VAR 0 2
21430: PUSH
21431: FOR_IN
21432: IFFALSE 21469
// if GetCargo ( i , mat_artifact ) = 0 then
21434: LD_VAR 0 1
21438: PPUSH
21439: LD_INT 4
21441: PPUSH
21442: CALL_OW 289
21446: PUSH
21447: LD_INT 0
21449: EQUAL
21450: IFFALSE 21467
// SetCargo ( i , mat_siberit , 100 ) ;
21452: LD_VAR 0 1
21456: PPUSH
21457: LD_INT 3
21459: PPUSH
21460: LD_INT 100
21462: PPUSH
21463: CALL_OW 290
21467: GO 21431
21469: POP
21470: POP
// end ;
21471: PPOPN 2
21473: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21474: LD_EXP 26
21478: PUSH
21479: LD_EXP 71
21483: AND
21484: IFFALSE 21637
21486: GO 21488
21488: DISABLE
21489: LD_INT 0
21491: PPUSH
21492: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21493: LD_ADDR_VAR 0 2
21497: PUSH
21498: LD_INT 22
21500: PUSH
21501: LD_OWVAR 2
21505: PUSH
21506: EMPTY
21507: LIST
21508: LIST
21509: PPUSH
21510: CALL_OW 69
21514: ST_TO_ADDR
// if not tmp then
21515: LD_VAR 0 2
21519: NOT
21520: IFFALSE 21524
// exit ;
21522: GO 21637
// for i := 1 to 2 do
21524: LD_ADDR_VAR 0 1
21528: PUSH
21529: DOUBLE
21530: LD_INT 1
21532: DEC
21533: ST_TO_ADDR
21534: LD_INT 2
21536: PUSH
21537: FOR_TO
21538: IFFALSE 21635
// begin uc_side := your_side ;
21540: LD_ADDR_OWVAR 20
21544: PUSH
21545: LD_OWVAR 2
21549: ST_TO_ADDR
// uc_nation := nation_american ;
21550: LD_ADDR_OWVAR 21
21554: PUSH
21555: LD_INT 1
21557: ST_TO_ADDR
// vc_chassis := us_morphling ;
21558: LD_ADDR_OWVAR 37
21562: PUSH
21563: LD_INT 5
21565: ST_TO_ADDR
// vc_engine := engine_siberite ;
21566: LD_ADDR_OWVAR 39
21570: PUSH
21571: LD_INT 3
21573: ST_TO_ADDR
// vc_control := control_computer ;
21574: LD_ADDR_OWVAR 38
21578: PUSH
21579: LD_INT 3
21581: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21582: LD_ADDR_OWVAR 40
21586: PUSH
21587: LD_INT 10
21589: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
21590: CALL_OW 45
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_INT 1
21602: ARRAY
21603: PPUSH
21604: CALL_OW 250
21608: PPUSH
21609: LD_VAR 0 2
21613: PUSH
21614: LD_INT 1
21616: ARRAY
21617: PPUSH
21618: CALL_OW 251
21622: PPUSH
21623: LD_INT 12
21625: PPUSH
21626: LD_INT 1
21628: PPUSH
21629: CALL_OW 50
// end ;
21633: GO 21537
21635: POP
21636: POP
// end ;
21637: PPOPN 2
21639: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21640: LD_EXP 26
21644: PUSH
21645: LD_EXP 72
21649: AND
21650: IFFALSE 21872
21652: GO 21654
21654: DISABLE
21655: LD_INT 0
21657: PPUSH
21658: PPUSH
21659: PPUSH
21660: PPUSH
21661: PPUSH
21662: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21663: LD_ADDR_VAR 0 6
21667: PUSH
21668: LD_INT 22
21670: PUSH
21671: LD_OWVAR 2
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: LD_INT 21
21682: PUSH
21683: LD_INT 1
21685: PUSH
21686: EMPTY
21687: LIST
21688: LIST
21689: PUSH
21690: LD_INT 3
21692: PUSH
21693: LD_INT 23
21695: PUSH
21696: LD_INT 0
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: LIST
21711: PPUSH
21712: CALL_OW 69
21716: ST_TO_ADDR
// if not tmp then
21717: LD_VAR 0 6
21721: NOT
21722: IFFALSE 21726
// exit ;
21724: GO 21872
// s1 := rand ( 1 , 4 ) ;
21726: LD_ADDR_VAR 0 2
21730: PUSH
21731: LD_INT 1
21733: PPUSH
21734: LD_INT 4
21736: PPUSH
21737: CALL_OW 12
21741: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21742: LD_ADDR_VAR 0 4
21746: PUSH
21747: LD_VAR 0 6
21751: PUSH
21752: LD_INT 1
21754: ARRAY
21755: PPUSH
21756: LD_VAR 0 2
21760: PPUSH
21761: CALL_OW 259
21765: ST_TO_ADDR
// if s1 = 1 then
21766: LD_VAR 0 2
21770: PUSH
21771: LD_INT 1
21773: EQUAL
21774: IFFALSE 21794
// s2 := rand ( 2 , 4 ) else
21776: LD_ADDR_VAR 0 3
21780: PUSH
21781: LD_INT 2
21783: PPUSH
21784: LD_INT 4
21786: PPUSH
21787: CALL_OW 12
21791: ST_TO_ADDR
21792: GO 21802
// s2 := 1 ;
21794: LD_ADDR_VAR 0 3
21798: PUSH
21799: LD_INT 1
21801: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21802: LD_ADDR_VAR 0 5
21806: PUSH
21807: LD_VAR 0 6
21811: PUSH
21812: LD_INT 1
21814: ARRAY
21815: PPUSH
21816: LD_VAR 0 3
21820: PPUSH
21821: CALL_OW 259
21825: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21826: LD_VAR 0 6
21830: PUSH
21831: LD_INT 1
21833: ARRAY
21834: PPUSH
21835: LD_VAR 0 2
21839: PPUSH
21840: LD_VAR 0 5
21844: PPUSH
21845: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21849: LD_VAR 0 6
21853: PUSH
21854: LD_INT 1
21856: ARRAY
21857: PPUSH
21858: LD_VAR 0 3
21862: PPUSH
21863: LD_VAR 0 4
21867: PPUSH
21868: CALL_OW 237
// end ;
21872: PPOPN 6
21874: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21875: LD_EXP 26
21879: PUSH
21880: LD_EXP 73
21884: AND
21885: IFFALSE 21964
21887: GO 21889
21889: DISABLE
21890: LD_INT 0
21892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21893: LD_ADDR_VAR 0 1
21897: PUSH
21898: LD_INT 22
21900: PUSH
21901: LD_OWVAR 2
21905: PUSH
21906: EMPTY
21907: LIST
21908: LIST
21909: PUSH
21910: LD_INT 30
21912: PUSH
21913: LD_INT 3
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: PUSH
21920: EMPTY
21921: LIST
21922: LIST
21923: PPUSH
21924: CALL_OW 69
21928: ST_TO_ADDR
// if not tmp then
21929: LD_VAR 0 1
21933: NOT
21934: IFFALSE 21938
// exit ;
21936: GO 21964
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21938: LD_VAR 0 1
21942: PUSH
21943: LD_INT 1
21945: PPUSH
21946: LD_VAR 0 1
21950: PPUSH
21951: CALL_OW 12
21955: ARRAY
21956: PPUSH
21957: LD_INT 1
21959: PPUSH
21960: CALL_OW 234
// end ;
21964: PPOPN 1
21966: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21967: LD_EXP 26
21971: PUSH
21972: LD_EXP 74
21976: AND
21977: IFFALSE 22089
21979: GO 21981
21981: DISABLE
21982: LD_INT 0
21984: PPUSH
21985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21986: LD_ADDR_VAR 0 2
21990: PUSH
21991: LD_INT 22
21993: PUSH
21994: LD_OWVAR 2
21998: PUSH
21999: EMPTY
22000: LIST
22001: LIST
22002: PUSH
22003: LD_INT 2
22005: PUSH
22006: LD_INT 30
22008: PUSH
22009: LD_INT 27
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 30
22018: PUSH
22019: LD_INT 26
22021: PUSH
22022: EMPTY
22023: LIST
22024: LIST
22025: PUSH
22026: LD_INT 30
22028: PUSH
22029: LD_INT 28
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: PUSH
22036: EMPTY
22037: LIST
22038: LIST
22039: LIST
22040: LIST
22041: PUSH
22042: EMPTY
22043: LIST
22044: LIST
22045: PPUSH
22046: CALL_OW 69
22050: ST_TO_ADDR
// if not tmp then
22051: LD_VAR 0 2
22055: NOT
22056: IFFALSE 22060
// exit ;
22058: GO 22089
// for i in tmp do
22060: LD_ADDR_VAR 0 1
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: FOR_IN
22071: IFFALSE 22087
// SetLives ( i , 1 ) ;
22073: LD_VAR 0 1
22077: PPUSH
22078: LD_INT 1
22080: PPUSH
22081: CALL_OW 234
22085: GO 22070
22087: POP
22088: POP
// end ;
22089: PPOPN 2
22091: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
22092: LD_EXP 26
22096: PUSH
22097: LD_EXP 75
22101: AND
22102: IFFALSE 22376
22104: GO 22106
22106: DISABLE
22107: LD_INT 0
22109: PPUSH
22110: PPUSH
22111: PPUSH
// begin i := rand ( 1 , 7 ) ;
22112: LD_ADDR_VAR 0 1
22116: PUSH
22117: LD_INT 1
22119: PPUSH
22120: LD_INT 7
22122: PPUSH
22123: CALL_OW 12
22127: ST_TO_ADDR
// case i of 1 :
22128: LD_VAR 0 1
22132: PUSH
22133: LD_INT 1
22135: DOUBLE
22136: EQUAL
22137: IFTRUE 22141
22139: GO 22151
22141: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
22142: LD_STRING earthquake(getX(game), 0, 32)
22144: PPUSH
22145: CALL_OW 559
22149: GO 22376
22151: LD_INT 2
22153: DOUBLE
22154: EQUAL
22155: IFTRUE 22159
22157: GO 22173
22159: POP
// begin ToLua ( displayStucuk(); ) ;
22160: LD_STRING displayStucuk();
22162: PPUSH
22163: CALL_OW 559
// ResetFog ;
22167: CALL_OW 335
// end ; 3 :
22171: GO 22376
22173: LD_INT 3
22175: DOUBLE
22176: EQUAL
22177: IFTRUE 22181
22179: GO 22285
22181: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22182: LD_ADDR_VAR 0 2
22186: PUSH
22187: LD_INT 22
22189: PUSH
22190: LD_OWVAR 2
22194: PUSH
22195: EMPTY
22196: LIST
22197: LIST
22198: PUSH
22199: LD_INT 25
22201: PUSH
22202: LD_INT 1
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PPUSH
22213: CALL_OW 69
22217: ST_TO_ADDR
// if not tmp then
22218: LD_VAR 0 2
22222: NOT
22223: IFFALSE 22227
// exit ;
22225: GO 22376
// un := tmp [ rand ( 1 , tmp ) ] ;
22227: LD_ADDR_VAR 0 3
22231: PUSH
22232: LD_VAR 0 2
22236: PUSH
22237: LD_INT 1
22239: PPUSH
22240: LD_VAR 0 2
22244: PPUSH
22245: CALL_OW 12
22249: ARRAY
22250: ST_TO_ADDR
// if Crawls ( un ) then
22251: LD_VAR 0 3
22255: PPUSH
22256: CALL_OW 318
22260: IFFALSE 22271
// ComWalk ( un ) ;
22262: LD_VAR 0 3
22266: PPUSH
22267: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22271: LD_VAR 0 3
22275: PPUSH
22276: LD_INT 8
22278: PPUSH
22279: CALL_OW 336
// end ; 4 :
22283: GO 22376
22285: LD_INT 4
22287: DOUBLE
22288: EQUAL
22289: IFTRUE 22293
22291: GO 22354
22293: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22294: LD_ADDR_VAR 0 2
22298: PUSH
22299: LD_INT 22
22301: PUSH
22302: LD_OWVAR 2
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PUSH
22311: LD_INT 30
22313: PUSH
22314: LD_INT 29
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: LIST
22324: PPUSH
22325: CALL_OW 69
22329: ST_TO_ADDR
// if not tmp then
22330: LD_VAR 0 2
22334: NOT
22335: IFFALSE 22339
// exit ;
22337: GO 22376
// DestroyUnit ( tmp [ 1 ] ) ;
22339: LD_VAR 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 65
// end ; 5 .. 7 :
22352: GO 22376
22354: LD_INT 5
22356: DOUBLE
22357: GREATEREQUAL
22358: IFFALSE 22366
22360: LD_INT 7
22362: DOUBLE
22363: LESSEQUAL
22364: IFTRUE 22368
22366: GO 22375
22368: POP
// StreamSibBomb ; end ;
22369: CALL 18656 0 0
22373: GO 22376
22375: POP
// end ;
22376: PPOPN 3
22378: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22379: LD_EXP 26
22383: PUSH
22384: LD_EXP 76
22388: AND
22389: IFFALSE 22545
22391: GO 22393
22393: DISABLE
22394: LD_INT 0
22396: PPUSH
22397: PPUSH
22398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22399: LD_ADDR_VAR 0 2
22403: PUSH
22404: LD_INT 81
22406: PUSH
22407: LD_OWVAR 2
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: PUSH
22416: LD_INT 2
22418: PUSH
22419: LD_INT 21
22421: PUSH
22422: LD_INT 1
22424: PUSH
22425: EMPTY
22426: LIST
22427: LIST
22428: PUSH
22429: LD_INT 21
22431: PUSH
22432: LD_INT 2
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: LIST
22443: PUSH
22444: EMPTY
22445: LIST
22446: LIST
22447: PPUSH
22448: CALL_OW 69
22452: ST_TO_ADDR
// if not tmp then
22453: LD_VAR 0 2
22457: NOT
22458: IFFALSE 22462
// exit ;
22460: GO 22545
// p := 0 ;
22462: LD_ADDR_VAR 0 3
22466: PUSH
22467: LD_INT 0
22469: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22470: LD_INT 35
22472: PPUSH
22473: CALL_OW 67
// p := p + 1 ;
22477: LD_ADDR_VAR 0 3
22481: PUSH
22482: LD_VAR 0 3
22486: PUSH
22487: LD_INT 1
22489: PLUS
22490: ST_TO_ADDR
// for i in tmp do
22491: LD_ADDR_VAR 0 1
22495: PUSH
22496: LD_VAR 0 2
22500: PUSH
22501: FOR_IN
22502: IFFALSE 22533
// if GetLives ( i ) < 1000 then
22504: LD_VAR 0 1
22508: PPUSH
22509: CALL_OW 256
22513: PUSH
22514: LD_INT 1000
22516: LESS
22517: IFFALSE 22531
// SetLives ( i , 1000 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 1000
22526: PPUSH
22527: CALL_OW 234
22531: GO 22501
22533: POP
22534: POP
// until p > 20 ;
22535: LD_VAR 0 3
22539: PUSH
22540: LD_INT 20
22542: GREATER
22543: IFFALSE 22470
// end ;
22545: PPOPN 3
22547: END
// every 0 0$1 trigger StreamModeActive and sTime do
22548: LD_EXP 26
22552: PUSH
22553: LD_EXP 77
22557: AND
22558: IFFALSE 22593
22560: GO 22562
22562: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22563: LD_INT 28
22565: PPUSH
22566: LD_OWVAR 2
22570: PPUSH
22571: LD_INT 2
22573: PPUSH
22574: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22578: LD_INT 30
22580: PPUSH
22581: LD_OWVAR 2
22585: PPUSH
22586: LD_INT 2
22588: PPUSH
22589: CALL_OW 322
// end ;
22593: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22594: LD_EXP 26
22598: PUSH
22599: LD_EXP 78
22603: AND
22604: IFFALSE 22725
22606: GO 22608
22608: DISABLE
22609: LD_INT 0
22611: PPUSH
22612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22613: LD_ADDR_VAR 0 2
22617: PUSH
22618: LD_INT 22
22620: PUSH
22621: LD_OWVAR 2
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: PUSH
22630: LD_INT 21
22632: PUSH
22633: LD_INT 1
22635: PUSH
22636: EMPTY
22637: LIST
22638: LIST
22639: PUSH
22640: LD_INT 3
22642: PUSH
22643: LD_INT 23
22645: PUSH
22646: LD_INT 0
22648: PUSH
22649: EMPTY
22650: LIST
22651: LIST
22652: PUSH
22653: EMPTY
22654: LIST
22655: LIST
22656: PUSH
22657: EMPTY
22658: LIST
22659: LIST
22660: LIST
22661: PPUSH
22662: CALL_OW 69
22666: ST_TO_ADDR
// if not tmp then
22667: LD_VAR 0 2
22671: NOT
22672: IFFALSE 22676
// exit ;
22674: GO 22725
// for i in tmp do
22676: LD_ADDR_VAR 0 1
22680: PUSH
22681: LD_VAR 0 2
22685: PUSH
22686: FOR_IN
22687: IFFALSE 22723
// begin if Crawls ( i ) then
22689: LD_VAR 0 1
22693: PPUSH
22694: CALL_OW 318
22698: IFFALSE 22709
// ComWalk ( i ) ;
22700: LD_VAR 0 1
22704: PPUSH
22705: CALL_OW 138
// SetClass ( i , 2 ) ;
22709: LD_VAR 0 1
22713: PPUSH
22714: LD_INT 2
22716: PPUSH
22717: CALL_OW 336
// end ;
22721: GO 22686
22723: POP
22724: POP
// end ;
22725: PPOPN 2
22727: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22728: LD_EXP 26
22732: PUSH
22733: LD_EXP 79
22737: AND
22738: IFFALSE 23019
22740: GO 22742
22742: DISABLE
22743: LD_INT 0
22745: PPUSH
22746: PPUSH
22747: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22748: LD_OWVAR 2
22752: PPUSH
22753: LD_INT 9
22755: PPUSH
22756: LD_INT 1
22758: PPUSH
22759: LD_INT 1
22761: PPUSH
22762: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22766: LD_INT 9
22768: PPUSH
22769: LD_OWVAR 2
22773: PPUSH
22774: CALL_OW 343
// uc_side := 9 ;
22778: LD_ADDR_OWVAR 20
22782: PUSH
22783: LD_INT 9
22785: ST_TO_ADDR
// uc_nation := 2 ;
22786: LD_ADDR_OWVAR 21
22790: PUSH
22791: LD_INT 2
22793: ST_TO_ADDR
// hc_name := Dark Warrior ;
22794: LD_ADDR_OWVAR 26
22798: PUSH
22799: LD_STRING Dark Warrior
22801: ST_TO_ADDR
// hc_gallery :=  ;
22802: LD_ADDR_OWVAR 33
22806: PUSH
22807: LD_STRING 
22809: ST_TO_ADDR
// hc_noskilllimit := true ;
22810: LD_ADDR_OWVAR 76
22814: PUSH
22815: LD_INT 1
22817: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22818: LD_ADDR_OWVAR 31
22822: PUSH
22823: LD_INT 30
22825: PUSH
22826: LD_INT 30
22828: PUSH
22829: LD_INT 30
22831: PUSH
22832: LD_INT 30
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: ST_TO_ADDR
// un := CreateHuman ;
22841: LD_ADDR_VAR 0 3
22845: PUSH
22846: CALL_OW 44
22850: ST_TO_ADDR
// hc_noskilllimit := false ;
22851: LD_ADDR_OWVAR 76
22855: PUSH
22856: LD_INT 0
22858: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22859: LD_VAR 0 3
22863: PPUSH
22864: LD_INT 1
22866: PPUSH
22867: CALL_OW 51
// p := 0 ;
22871: LD_ADDR_VAR 0 2
22875: PUSH
22876: LD_INT 0
22878: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22879: LD_INT 35
22881: PPUSH
22882: CALL_OW 67
// p := p + 1 ;
22886: LD_ADDR_VAR 0 2
22890: PUSH
22891: LD_VAR 0 2
22895: PUSH
22896: LD_INT 1
22898: PLUS
22899: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22900: LD_VAR 0 3
22904: PPUSH
22905: CALL_OW 256
22909: PUSH
22910: LD_INT 1000
22912: LESS
22913: IFFALSE 22927
// SetLives ( un , 1000 ) ;
22915: LD_VAR 0 3
22919: PPUSH
22920: LD_INT 1000
22922: PPUSH
22923: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22927: LD_VAR 0 3
22931: PPUSH
22932: LD_INT 81
22934: PUSH
22935: LD_OWVAR 2
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: PUSH
22944: LD_INT 91
22946: PUSH
22947: LD_VAR 0 3
22951: PUSH
22952: LD_INT 30
22954: PUSH
22955: EMPTY
22956: LIST
22957: LIST
22958: LIST
22959: PUSH
22960: EMPTY
22961: LIST
22962: LIST
22963: PPUSH
22964: CALL_OW 69
22968: PPUSH
22969: LD_VAR 0 3
22973: PPUSH
22974: CALL_OW 74
22978: PPUSH
22979: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22983: LD_VAR 0 2
22987: PUSH
22988: LD_INT 60
22990: GREATER
22991: PUSH
22992: LD_VAR 0 3
22996: PPUSH
22997: CALL_OW 301
23001: OR
23002: IFFALSE 22879
// if un then
23004: LD_VAR 0 3
23008: IFFALSE 23019
// RemoveUnit ( un ) ;
23010: LD_VAR 0 3
23014: PPUSH
23015: CALL_OW 64
// end ; end_of_file
23019: PPOPN 3
23021: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
23022: LD_INT 0
23024: PPUSH
23025: PPUSH
23026: PPUSH
23027: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
23028: LD_VAR 0 1
23032: PPUSH
23033: CALL_OW 264
23037: PUSH
23038: LD_EXP 25
23042: EQUAL
23043: IFFALSE 23115
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
23045: LD_INT 68
23047: PPUSH
23048: LD_VAR 0 1
23052: PPUSH
23053: CALL_OW 255
23057: PPUSH
23058: CALL_OW 321
23062: PUSH
23063: LD_INT 2
23065: EQUAL
23066: IFFALSE 23078
// eff := 70 else
23068: LD_ADDR_VAR 0 6
23072: PUSH
23073: LD_INT 70
23075: ST_TO_ADDR
23076: GO 23086
// eff := 30 ;
23078: LD_ADDR_VAR 0 6
23082: PUSH
23083: LD_INT 30
23085: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
23086: LD_VAR 0 1
23090: PPUSH
23091: CALL_OW 250
23095: PPUSH
23096: LD_VAR 0 1
23100: PPUSH
23101: CALL_OW 251
23105: PPUSH
23106: LD_VAR 0 6
23110: PPUSH
23111: CALL_OW 495
// end ; end ;
23115: LD_VAR 0 4
23119: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
23120: LD_INT 0
23122: PPUSH
23123: PPUSH
23124: PPUSH
23125: PPUSH
23126: PPUSH
23127: PPUSH
// if cmd = 124 then
23128: LD_VAR 0 1
23132: PUSH
23133: LD_INT 124
23135: EQUAL
23136: IFFALSE 23342
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
23138: LD_ADDR_VAR 0 5
23142: PUSH
23143: LD_INT 2
23145: PUSH
23146: LD_INT 34
23148: PUSH
23149: LD_INT 53
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: PUSH
23156: LD_INT 34
23158: PUSH
23159: LD_INT 14
23161: PUSH
23162: EMPTY
23163: LIST
23164: LIST
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: LIST
23170: PPUSH
23171: CALL_OW 69
23175: ST_TO_ADDR
// if not tmp then
23176: LD_VAR 0 5
23180: NOT
23181: IFFALSE 23185
// exit ;
23183: GO 23342
// for i in tmp do
23185: LD_ADDR_VAR 0 3
23189: PUSH
23190: LD_VAR 0 5
23194: PUSH
23195: FOR_IN
23196: IFFALSE 23340
// begin taskList := GetTaskList ( i ) ;
23198: LD_ADDR_VAR 0 6
23202: PUSH
23203: LD_VAR 0 3
23207: PPUSH
23208: CALL_OW 437
23212: ST_TO_ADDR
// if not taskList then
23213: LD_VAR 0 6
23217: NOT
23218: IFFALSE 23222
// continue ;
23220: GO 23195
// for j = 1 to taskList do
23222: LD_ADDR_VAR 0 4
23226: PUSH
23227: DOUBLE
23228: LD_INT 1
23230: DEC
23231: ST_TO_ADDR
23232: LD_VAR 0 6
23236: PUSH
23237: FOR_TO
23238: IFFALSE 23336
// if taskList [ j ] [ 1 ] = | then
23240: LD_VAR 0 6
23244: PUSH
23245: LD_VAR 0 4
23249: ARRAY
23250: PUSH
23251: LD_INT 1
23253: ARRAY
23254: PUSH
23255: LD_STRING |
23257: EQUAL
23258: IFFALSE 23334
// begin _taskList := Delete ( taskList , 1 ) ;
23260: LD_ADDR_VAR 0 7
23264: PUSH
23265: LD_VAR 0 6
23269: PPUSH
23270: LD_INT 1
23272: PPUSH
23273: CALL_OW 3
23277: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
23278: LD_VAR 0 3
23282: PPUSH
23283: LD_VAR 0 7
23287: PPUSH
23288: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
23292: LD_VAR 0 3
23296: PPUSH
23297: LD_VAR 0 6
23301: PUSH
23302: LD_VAR 0 4
23306: ARRAY
23307: PUSH
23308: LD_INT 2
23310: ARRAY
23311: PPUSH
23312: LD_VAR 0 6
23316: PUSH
23317: LD_VAR 0 4
23321: ARRAY
23322: PUSH
23323: LD_INT 3
23325: ARRAY
23326: PPUSH
23327: LD_INT 8
23329: PPUSH
23330: CALL 23347 0 4
// end ;
23334: GO 23237
23336: POP
23337: POP
// end ;
23338: GO 23195
23340: POP
23341: POP
// end ; end ;
23342: LD_VAR 0 2
23346: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
23347: LD_INT 0
23349: PPUSH
23350: PPUSH
23351: PPUSH
23352: PPUSH
23353: PPUSH
23354: PPUSH
23355: PPUSH
23356: PPUSH
23357: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
23358: LD_VAR 0 1
23362: NOT
23363: PUSH
23364: LD_VAR 0 2
23368: PPUSH
23369: LD_VAR 0 3
23373: PPUSH
23374: CALL_OW 488
23378: NOT
23379: OR
23380: PUSH
23381: LD_VAR 0 4
23385: NOT
23386: OR
23387: IFFALSE 23391
// exit ;
23389: GO 23731
// list := [ ] ;
23391: LD_ADDR_VAR 0 13
23395: PUSH
23396: EMPTY
23397: ST_TO_ADDR
// if x - r < 0 then
23398: LD_VAR 0 2
23402: PUSH
23403: LD_VAR 0 4
23407: MINUS
23408: PUSH
23409: LD_INT 0
23411: LESS
23412: IFFALSE 23424
// min_x := 0 else
23414: LD_ADDR_VAR 0 7
23418: PUSH
23419: LD_INT 0
23421: ST_TO_ADDR
23422: GO 23440
// min_x := x - r ;
23424: LD_ADDR_VAR 0 7
23428: PUSH
23429: LD_VAR 0 2
23433: PUSH
23434: LD_VAR 0 4
23438: MINUS
23439: ST_TO_ADDR
// if y - r < 0 then
23440: LD_VAR 0 3
23444: PUSH
23445: LD_VAR 0 4
23449: MINUS
23450: PUSH
23451: LD_INT 0
23453: LESS
23454: IFFALSE 23466
// min_y := 0 else
23456: LD_ADDR_VAR 0 8
23460: PUSH
23461: LD_INT 0
23463: ST_TO_ADDR
23464: GO 23482
// min_y := y - r ;
23466: LD_ADDR_VAR 0 8
23470: PUSH
23471: LD_VAR 0 3
23475: PUSH
23476: LD_VAR 0 4
23480: MINUS
23481: ST_TO_ADDR
// max_x := x + r ;
23482: LD_ADDR_VAR 0 9
23486: PUSH
23487: LD_VAR 0 2
23491: PUSH
23492: LD_VAR 0 4
23496: PLUS
23497: ST_TO_ADDR
// max_y := y + r ;
23498: LD_ADDR_VAR 0 10
23502: PUSH
23503: LD_VAR 0 3
23507: PUSH
23508: LD_VAR 0 4
23512: PLUS
23513: ST_TO_ADDR
// for _x = min_x to max_x do
23514: LD_ADDR_VAR 0 11
23518: PUSH
23519: DOUBLE
23520: LD_VAR 0 7
23524: DEC
23525: ST_TO_ADDR
23526: LD_VAR 0 9
23530: PUSH
23531: FOR_TO
23532: IFFALSE 23649
// for _y = min_y to max_y do
23534: LD_ADDR_VAR 0 12
23538: PUSH
23539: DOUBLE
23540: LD_VAR 0 8
23544: DEC
23545: ST_TO_ADDR
23546: LD_VAR 0 10
23550: PUSH
23551: FOR_TO
23552: IFFALSE 23645
// begin if not ValidHex ( _x , _y ) then
23554: LD_VAR 0 11
23558: PPUSH
23559: LD_VAR 0 12
23563: PPUSH
23564: CALL_OW 488
23568: NOT
23569: IFFALSE 23573
// continue ;
23571: GO 23551
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
23573: LD_VAR 0 11
23577: PPUSH
23578: LD_VAR 0 12
23582: PPUSH
23583: CALL_OW 351
23587: PUSH
23588: LD_VAR 0 11
23592: PPUSH
23593: LD_VAR 0 12
23597: PPUSH
23598: CALL_OW 554
23602: AND
23603: IFFALSE 23643
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
23605: LD_ADDR_VAR 0 13
23609: PUSH
23610: LD_VAR 0 13
23614: PPUSH
23615: LD_VAR 0 13
23619: PUSH
23620: LD_INT 1
23622: PLUS
23623: PPUSH
23624: LD_VAR 0 11
23628: PUSH
23629: LD_VAR 0 12
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PPUSH
23638: CALL_OW 2
23642: ST_TO_ADDR
// end ;
23643: GO 23551
23645: POP
23646: POP
23647: GO 23531
23649: POP
23650: POP
// if not list then
23651: LD_VAR 0 13
23655: NOT
23656: IFFALSE 23660
// exit ;
23658: GO 23731
// for i in list do
23660: LD_ADDR_VAR 0 6
23664: PUSH
23665: LD_VAR 0 13
23669: PUSH
23670: FOR_IN
23671: IFFALSE 23729
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
23673: LD_VAR 0 1
23677: PPUSH
23678: LD_STRING M
23680: PUSH
23681: LD_VAR 0 6
23685: PUSH
23686: LD_INT 1
23688: ARRAY
23689: PUSH
23690: LD_VAR 0 6
23694: PUSH
23695: LD_INT 2
23697: ARRAY
23698: PUSH
23699: LD_INT 0
23701: PUSH
23702: LD_INT 0
23704: PUSH
23705: LD_INT 0
23707: PUSH
23708: LD_INT 0
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: LIST
23715: LIST
23716: LIST
23717: LIST
23718: LIST
23719: PUSH
23720: EMPTY
23721: LIST
23722: PPUSH
23723: CALL_OW 447
23727: GO 23670
23729: POP
23730: POP
// end ;
23731: LD_VAR 0 5
23735: RET
