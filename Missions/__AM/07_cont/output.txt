// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 44 0 0
// DebugMode ;
  12: CALL 253 0 0
// AnimateTrees ( true ) ;
  16: LD_INT 1
  18: PPUSH
  19: CALL_OW 573
// PrepareNature ;
  23: CALL 3069 0 0
// PrepareRussians ;
  27: CALL 4810 0 0
// PrepareAmericans ;
  31: CALL 3726 0 0
// Action ;
  35: CALL 8690 0 0
// SaveForQuickRestart ;
  39: CALL_OW 22
// end ;
  43: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end , kill_counter ; function Init ; begin
  44: LD_INT 0
  46: PPUSH
// debug := false ;
  47: LD_ADDR_EXP 1
  51: PUSH
  52: LD_INT 0
  54: ST_TO_ADDR
// mission_prefix := 07c_ ;
  55: LD_ADDR_EXP 3
  59: PUSH
  60: LD_STRING 07c_
  62: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  63: LD_ADDR_EXP 2
  67: PUSH
  68: LD_STRING 07_
  70: ST_TO_ADDR
// buildings_counter := 0 ;
  71: LD_ADDR_EXP 4
  75: PUSH
  76: LD_INT 0
  78: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  79: LD_ADDR_EXP 5
  83: PUSH
  84: LD_INT 67200
  86: PUSH
  87: LD_INT 60900
  89: PUSH
  90: LD_INT 54600
  92: PUSH
  93: EMPTY
  94: LIST
  95: LIST
  96: LIST
  97: PUSH
  98: LD_OWVAR 67
 102: ARRAY
 103: PUSH
 104: LD_INT 79800
 106: PUSH
 107: LD_INT 73500
 109: PUSH
 110: LD_INT 67200
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PUSH
 124: LD_INT 92400
 126: PUSH
 127: LD_INT 86100
 129: PUSH
 130: LD_INT 79800
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: PUSH
 138: LD_OWVAR 67
 142: ARRAY
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// can_end := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// must_end := false ;
 157: LD_ADDR_EXP 7
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// kill_counter := 0 ;
 165: LD_ADDR_EXP 8
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// end ;
 173: LD_VAR 0 1
 177: RET
// every 0 0$01 trigger not debug do
 178: LD_EXP 1
 182: NOT
 183: IFFALSE 252
 185: GO 187
 187: DISABLE
// begin enable ;
 188: ENABLE
// if not must_end then
 189: LD_EXP 7
 193: NOT
 194: IFFALSE 215
// display_strings := [ #Am07-1 , tick ] else
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: ST_TO_ADDR
 213: GO 252
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 215: LD_ADDR_OWVAR 47
 219: PUSH
 220: LD_STRING #Am07-1
 222: PUSH
 223: LD_OWVAR 1
 227: PUSH
 228: LD_STRING #Am07-2
 230: PUSH
 231: LD_EXP 5
 235: PUSH
 236: LD_INT 3
 238: ARRAY
 239: PUSH
 240: LD_OWVAR 1
 244: MINUS
 245: PUSH
 246: EMPTY
 247: LIST
 248: LIST
 249: LIST
 250: LIST
 251: ST_TO_ADDR
// end ;
 252: END
// function DebugMode ; var i ; begin
 253: LD_INT 0
 255: PPUSH
 256: PPUSH
// if not debug then
 257: LD_EXP 1
 261: NOT
 262: IFFALSE 266
// exit ;
 264: GO 273
// FogOff ( 1 ) ;
 266: LD_INT 1
 268: PPUSH
 269: CALL_OW 344
// end ;
 273: LD_VAR 0 1
 277: RET
// every 3 trigger debug do var i , filter ;
 278: LD_EXP 1
 282: IFFALSE 371
 284: GO 286
 286: DISABLE
 287: LD_INT 0
 289: PPUSH
 290: PPUSH
// begin enable ;
 291: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 292: LD_ADDR_VAR 0 2
 296: PUSH
 297: LD_INT 22
 299: PUSH
 300: LD_INT 1
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: PUSH
 307: LD_INT 3
 309: PUSH
 310: LD_INT 24
 312: PUSH
 313: LD_INT 500
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: PPUSH
 328: CALL_OW 69
 332: ST_TO_ADDR
// if not filter then
 333: LD_VAR 0 2
 337: NOT
 338: IFFALSE 342
// exit ;
 340: GO 371
// for i in filter do
 342: LD_ADDR_VAR 0 1
 346: PUSH
 347: LD_VAR 0 2
 351: PUSH
 352: FOR_IN
 353: IFFALSE 369
// SetLives ( i , 1000 ) ;
 355: LD_VAR 0 1
 359: PPUSH
 360: LD_INT 1000
 362: PPUSH
 363: CALL_OW 234
 367: GO 352
 369: POP
 370: POP
// end ;
 371: PPOPN 2
 373: END
// every 0 0$1 trigger kill_counter >= 20 do
 374: LD_EXP 8
 378: PUSH
 379: LD_INT 20
 381: GREATEREQUAL
 382: IFFALSE 394
 384: GO 386
 386: DISABLE
// SetAchievement ( ACH_HITMAN ) ;
 387: LD_STRING ACH_HITMAN
 389: PPUSH
 390: CALL_OW 543
 394: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] ] ) >= 3 do
 395: LD_INT 22
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PUSH
 405: LD_INT 23
 407: PUSH
 408: LD_INT 3
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: PUSH
 415: LD_INT 21
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: PPUSH
 430: CALL_OW 69
 434: PUSH
 435: LD_INT 3
 437: GREATEREQUAL
 438: IFFALSE 450
 440: GO 442
 442: DISABLE
// SetAchievement ( ACH_TANKACE ) ;
 443: LD_STRING ACH_TANKACE
 445: PPUSH
 446: CALL_OW 543
 450: END
// every 0 0$1 trigger FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) = 0 do
 451: LD_INT 2
 453: PUSH
 454: LD_INT 30
 456: PUSH
 457: LD_INT 0
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: PUSH
 464: LD_INT 30
 466: PUSH
 467: LD_INT 1
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PPUSH
 479: CALL_OW 69
 483: PUSH
 484: LD_INT 0
 486: EQUAL
 487: IFFALSE 499
 489: GO 491
 491: DISABLE
// SetAchievement ( ACH_COMMANDO ) ; end_of_file
 492: LD_STRING ACH_COMMANDO
 494: PPUSH
 495: CALL_OW 543
 499: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// if exist_mode then
 504: LD_VAR 0 2
 508: IFFALSE 533
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_EXP 2
 519: PUSH
 520: LD_VAR 0 1
 524: STR
 525: PPUSH
 526: CALL_OW 34
 530: ST_TO_ADDR
 531: GO 548
// unit := NewCharacter ( ident ) ;
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: LD_VAR 0 1
 542: PPUSH
 543: CALL_OW 25
 547: ST_TO_ADDR
// result := unit ;
 548: LD_ADDR_VAR 0 3
 552: PUSH
 553: LD_VAR 0 4
 557: ST_TO_ADDR
// end ;
 558: LD_VAR 0 3
 562: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 563: LD_INT 0
 565: PPUSH
// uc_side := side ;
 566: LD_ADDR_OWVAR 20
 570: PUSH
 571: LD_VAR 0 1
 575: ST_TO_ADDR
// uc_nation := nation ;
 576: LD_ADDR_OWVAR 21
 580: PUSH
 581: LD_VAR 0 2
 585: ST_TO_ADDR
// vc_chassis := chassis ;
 586: LD_ADDR_OWVAR 37
 590: PUSH
 591: LD_VAR 0 3
 595: ST_TO_ADDR
// vc_engine := engine ;
 596: LD_ADDR_OWVAR 39
 600: PUSH
 601: LD_VAR 0 4
 605: ST_TO_ADDR
// vc_control := control ;
 606: LD_ADDR_OWVAR 38
 610: PUSH
 611: LD_VAR 0 5
 615: ST_TO_ADDR
// vc_weapon := weapon ;
 616: LD_ADDR_OWVAR 40
 620: PUSH
 621: LD_VAR 0 6
 625: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 626: LD_ADDR_OWVAR 41
 630: PUSH
 631: LD_VAR 0 7
 635: ST_TO_ADDR
// result := CreateVehicle ;
 636: LD_ADDR_VAR 0 8
 640: PUSH
 641: CALL_OW 45
 645: ST_TO_ADDR
// end ;
 646: LD_VAR 0 8
 650: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 651: LD_INT 0
 653: PPUSH
 654: PPUSH
 655: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 656: LD_ADDR_VAR 0 4
 660: PUSH
 661: LD_INT 22
 663: PUSH
 664: LD_INT 1
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: PUSH
 671: LD_INT 21
 673: PUSH
 674: LD_INT 1
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PUSH
 681: LD_INT 50
 683: PUSH
 684: EMPTY
 685: LIST
 686: PUSH
 687: EMPTY
 688: LIST
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL_OW 69
 696: PUSH
 697: LD_EXP 9
 701: PUSH
 702: LD_EXP 10
 706: PUSH
 707: LD_EXP 11
 711: PUSH
 712: LD_EXP 12
 716: PUSH
 717: LD_EXP 13
 721: PUSH
 722: LD_EXP 14
 726: PUSH
 727: LD_EXP 15
 731: PUSH
 732: LD_EXP 16
 736: PUSH
 737: LD_EXP 18
 741: PUSH
 742: LD_EXP 17
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: DIFF
 759: ST_TO_ADDR
// if not filter then
 760: LD_VAR 0 4
 764: NOT
 765: IFFALSE 769
// exit ;
 767: GO 796
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 769: LD_ADDR_VAR 0 2
 773: PUSH
 774: LD_VAR 0 4
 778: PPUSH
 779: LD_INT 26
 781: PUSH
 782: LD_VAR 0 1
 786: PUSH
 787: EMPTY
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL_OW 72
 795: ST_TO_ADDR
// end ;
 796: LD_VAR 0 2
 800: RET
// export function SayX ( units , ident ) ; var i ; begin
 801: LD_INT 0
 803: PPUSH
 804: PPUSH
// result := false ;
 805: LD_ADDR_VAR 0 3
 809: PUSH
 810: LD_INT 0
 812: ST_TO_ADDR
// if not units then
 813: LD_VAR 0 1
 817: NOT
 818: IFFALSE 822
// exit ;
 820: GO 876
// for i in units do
 822: LD_ADDR_VAR 0 4
 826: PUSH
 827: LD_VAR 0 1
 831: PUSH
 832: FOR_IN
 833: IFFALSE 874
// if IsOk ( i ) then
 835: LD_VAR 0 4
 839: PPUSH
 840: CALL_OW 302
 844: IFFALSE 872
// begin Say ( i , ident ) ;
 846: LD_VAR 0 4
 850: PPUSH
 851: LD_VAR 0 2
 855: PPUSH
 856: CALL_OW 88
// result := i ;
 860: LD_ADDR_VAR 0 3
 864: PUSH
 865: LD_VAR 0 4
 869: ST_TO_ADDR
// break ;
 870: GO 874
// end ;
 872: GO 832
 874: POP
 875: POP
// end ;
 876: LD_VAR 0 3
 880: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 881: LD_INT 0
 883: PPUSH
 884: PPUSH
 885: PPUSH
// result := [ ] ;
 886: LD_ADDR_VAR 0 2
 890: PUSH
 891: EMPTY
 892: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 893: LD_ADDR_VAR 0 3
 897: PUSH
 898: LD_INT 21
 900: PUSH
 901: LD_INT 3
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: PPUSH
 908: CALL_OW 69
 912: ST_TO_ADDR
// if not tmp then
 913: LD_VAR 0 3
 917: NOT
 918: IFFALSE 922
// exit ;
 920: GO 972
// for i in tmp do
 922: LD_ADDR_VAR 0 4
 926: PUSH
 927: LD_VAR 0 3
 931: PUSH
 932: FOR_IN
 933: IFFALSE 970
// if GetBase ( i ) = base then
 935: LD_VAR 0 4
 939: PPUSH
 940: CALL_OW 274
 944: PUSH
 945: LD_VAR 0 1
 949: EQUAL
 950: IFFALSE 968
// result := result ^ i ;
 952: LD_ADDR_VAR 0 2
 956: PUSH
 957: LD_VAR 0 2
 961: PUSH
 962: LD_VAR 0 4
 966: ADD
 967: ST_TO_ADDR
 968: GO 932
 970: POP
 971: POP
// end ;
 972: LD_VAR 0 2
 976: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 977: LD_INT 0
 979: PPUSH
 980: PPUSH
 981: PPUSH
 982: PPUSH
 983: PPUSH
 984: PPUSH
 985: PPUSH
 986: PPUSH
 987: PPUSH
 988: PPUSH
 989: PPUSH
 990: PPUSH
 991: PPUSH
 992: PPUSH
 993: PPUSH
 994: PPUSH
// result := false ;
 995: LD_ADDR_VAR 0 2
 999: PUSH
1000: LD_INT 0
1002: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
1003: LD_VAR 0 1
1007: NOT
1008: PUSH
1009: LD_VAR 0 1
1013: PPUSH
1014: CALL_OW 266
1018: PUSH
1019: LD_INT 32
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: IN
1029: NOT
1030: OR
1031: IFFALSE 1035
// exit ;
1033: GO 2195
// nat := GetNation ( tower ) ;
1035: LD_ADDR_VAR 0 11
1039: PUSH
1040: LD_VAR 0 1
1044: PPUSH
1045: CALL_OW 248
1049: ST_TO_ADDR
// side := GetSide ( tower ) ;
1050: LD_ADDR_VAR 0 15
1054: PUSH
1055: LD_VAR 0 1
1059: PPUSH
1060: CALL_OW 255
1064: ST_TO_ADDR
// x := GetX ( tower ) ;
1065: LD_ADDR_VAR 0 9
1069: PUSH
1070: LD_VAR 0 1
1074: PPUSH
1075: CALL_OW 250
1079: ST_TO_ADDR
// y := GetY ( tower ) ;
1080: LD_ADDR_VAR 0 10
1084: PUSH
1085: LD_VAR 0 1
1089: PPUSH
1090: CALL_OW 251
1094: ST_TO_ADDR
// if not x or not y then
1095: LD_VAR 0 9
1099: NOT
1100: PUSH
1101: LD_VAR 0 10
1105: NOT
1106: OR
1107: IFFALSE 1111
// exit ;
1109: GO 2195
// weapon := 0 ;
1111: LD_ADDR_VAR 0 17
1115: PUSH
1116: LD_INT 0
1118: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
1119: LD_ADDR_VAR 0 16
1123: PUSH
1124: LD_INT 42
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 44
1132: PUSH
1133: LD_INT 46
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: ST_TO_ADDR
// if not fac_list then
1142: LD_VAR 0 16
1146: NOT
1147: IFFALSE 1151
// exit ;
1149: GO 2195
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1151: LD_ADDR_VAR 0 4
1155: PUSH
1156: LD_INT 4
1158: PUSH
1159: LD_INT 5
1161: PUSH
1162: LD_INT 9
1164: PUSH
1165: LD_INT 10
1167: PUSH
1168: LD_INT 6
1170: PUSH
1171: LD_INT 7
1173: PUSH
1174: LD_INT 11
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 28
1191: PUSH
1192: LD_INT 26
1194: PUSH
1195: LD_INT 30
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 43
1206: PUSH
1207: LD_INT 44
1209: PUSH
1210: LD_INT 46
1212: PUSH
1213: LD_INT 45
1215: PUSH
1216: LD_INT 47
1218: PUSH
1219: LD_INT 49
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: PUSH
1235: LD_VAR 0 11
1239: ARRAY
1240: ST_TO_ADDR
// for i in list do
1241: LD_ADDR_VAR 0 7
1245: PUSH
1246: LD_VAR 0 4
1250: PUSH
1251: FOR_IN
1252: IFFALSE 1285
// if not i in fac_list then
1254: LD_VAR 0 7
1258: PUSH
1259: LD_VAR 0 16
1263: IN
1264: NOT
1265: IFFALSE 1283
// list := list diff i ;
1267: LD_ADDR_VAR 0 4
1271: PUSH
1272: LD_VAR 0 4
1276: PUSH
1277: LD_VAR 0 7
1281: DIFF
1282: ST_TO_ADDR
1283: GO 1251
1285: POP
1286: POP
// if not list then
1287: LD_VAR 0 4
1291: NOT
1292: IFFALSE 1296
// exit ;
1294: GO 2195
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1296: LD_VAR 0 11
1300: PUSH
1301: LD_INT 3
1303: EQUAL
1304: PUSH
1305: LD_INT 49
1307: PUSH
1308: LD_VAR 0 4
1312: IN
1313: AND
1314: PUSH
1315: LD_INT 31
1317: PPUSH
1318: LD_VAR 0 15
1322: PPUSH
1323: CALL_OW 321
1327: PUSH
1328: LD_INT 2
1330: EQUAL
1331: AND
1332: IFFALSE 1392
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1334: LD_INT 22
1336: PUSH
1337: LD_VAR 0 15
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 35
1348: PUSH
1349: LD_INT 49
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: PUSH
1356: LD_INT 91
1358: PUSH
1359: LD_VAR 0 1
1363: PUSH
1364: LD_INT 10
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL_OW 69
1381: NOT
1382: IFFALSE 1392
// weapon := ru_time_lapser ;
1384: LD_ADDR_VAR 0 17
1388: PUSH
1389: LD_INT 49
1391: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1392: LD_VAR 0 11
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 2
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: IN
1407: PUSH
1408: LD_INT 11
1410: PUSH
1411: LD_VAR 0 4
1415: IN
1416: PUSH
1417: LD_INT 30
1419: PUSH
1420: LD_VAR 0 4
1424: IN
1425: OR
1426: AND
1427: PUSH
1428: LD_INT 6
1430: PPUSH
1431: LD_VAR 0 15
1435: PPUSH
1436: CALL_OW 321
1440: PUSH
1441: LD_INT 2
1443: EQUAL
1444: AND
1445: IFFALSE 1610
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1447: LD_INT 22
1449: PUSH
1450: LD_VAR 0 15
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: LD_INT 2
1461: PUSH
1462: LD_INT 35
1464: PUSH
1465: LD_INT 11
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 35
1474: PUSH
1475: LD_INT 30
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: PUSH
1487: LD_INT 91
1489: PUSH
1490: LD_VAR 0 1
1494: PUSH
1495: LD_INT 18
1497: PUSH
1498: EMPTY
1499: LIST
1500: LIST
1501: LIST
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: LIST
1507: PPUSH
1508: CALL_OW 69
1512: NOT
1513: PUSH
1514: LD_INT 22
1516: PUSH
1517: LD_VAR 0 15
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: LD_INT 2
1528: PUSH
1529: LD_INT 30
1531: PUSH
1532: LD_INT 32
1534: PUSH
1535: EMPTY
1536: LIST
1537: LIST
1538: PUSH
1539: LD_INT 30
1541: PUSH
1542: LD_INT 33
1544: PUSH
1545: EMPTY
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: PUSH
1554: LD_INT 91
1556: PUSH
1557: LD_VAR 0 1
1561: PUSH
1562: LD_INT 12
1564: PUSH
1565: EMPTY
1566: LIST
1567: LIST
1568: LIST
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: EMPTY
1576: LIST
1577: PPUSH
1578: CALL_OW 69
1582: PUSH
1583: LD_INT 2
1585: GREATER
1586: AND
1587: IFFALSE 1610
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1589: LD_ADDR_VAR 0 17
1593: PUSH
1594: LD_INT 11
1596: PUSH
1597: LD_INT 30
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: LD_VAR 0 11
1608: ARRAY
1609: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1610: LD_VAR 0 17
1614: NOT
1615: PUSH
1616: LD_INT 40
1618: PPUSH
1619: LD_VAR 0 15
1623: PPUSH
1624: CALL_OW 321
1628: PUSH
1629: LD_INT 2
1631: EQUAL
1632: AND
1633: PUSH
1634: LD_INT 7
1636: PUSH
1637: LD_VAR 0 4
1641: IN
1642: PUSH
1643: LD_INT 28
1645: PUSH
1646: LD_VAR 0 4
1650: IN
1651: OR
1652: PUSH
1653: LD_INT 45
1655: PUSH
1656: LD_VAR 0 4
1660: IN
1661: OR
1662: AND
1663: IFFALSE 1917
// begin hex := GetHexInfo ( x , y ) ;
1665: LD_ADDR_VAR 0 3
1669: PUSH
1670: LD_VAR 0 9
1674: PPUSH
1675: LD_VAR 0 10
1679: PPUSH
1680: CALL_OW 546
1684: ST_TO_ADDR
// if hex [ 1 ] then
1685: LD_VAR 0 3
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: IFFALSE 1697
// exit ;
1695: GO 2195
// height := hex [ 2 ] ;
1697: LD_ADDR_VAR 0 14
1701: PUSH
1702: LD_VAR 0 3
1706: PUSH
1707: LD_INT 2
1709: ARRAY
1710: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1711: LD_ADDR_VAR 0 13
1715: PUSH
1716: LD_INT 0
1718: PUSH
1719: LD_INT 2
1721: PUSH
1722: LD_INT 3
1724: PUSH
1725: LD_INT 5
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: ST_TO_ADDR
// for i in tmp do
1734: LD_ADDR_VAR 0 7
1738: PUSH
1739: LD_VAR 0 13
1743: PUSH
1744: FOR_IN
1745: IFFALSE 1915
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1747: LD_ADDR_VAR 0 8
1751: PUSH
1752: LD_VAR 0 9
1756: PPUSH
1757: LD_VAR 0 7
1761: PPUSH
1762: LD_INT 5
1764: PPUSH
1765: CALL_OW 272
1769: PUSH
1770: LD_VAR 0 10
1774: PPUSH
1775: LD_VAR 0 7
1779: PPUSH
1780: LD_INT 5
1782: PPUSH
1783: CALL_OW 273
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1792: LD_VAR 0 8
1796: PUSH
1797: LD_INT 1
1799: ARRAY
1800: PPUSH
1801: LD_VAR 0 8
1805: PUSH
1806: LD_INT 2
1808: ARRAY
1809: PPUSH
1810: CALL_OW 488
1814: IFFALSE 1913
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1816: LD_ADDR_VAR 0 3
1820: PUSH
1821: LD_VAR 0 8
1825: PUSH
1826: LD_INT 1
1828: ARRAY
1829: PPUSH
1830: LD_VAR 0 8
1834: PUSH
1835: LD_INT 2
1837: ARRAY
1838: PPUSH
1839: CALL_OW 546
1843: ST_TO_ADDR
// if hex [ 1 ] then
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 1
1851: ARRAY
1852: IFFALSE 1856
// continue ;
1854: GO 1744
// h := hex [ 2 ] ;
1856: LD_ADDR_VAR 0 12
1860: PUSH
1861: LD_VAR 0 3
1865: PUSH
1866: LD_INT 2
1868: ARRAY
1869: ST_TO_ADDR
// if h + 7 < height then
1870: LD_VAR 0 12
1874: PUSH
1875: LD_INT 7
1877: PLUS
1878: PUSH
1879: LD_VAR 0 14
1883: LESS
1884: IFFALSE 1913
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1886: LD_ADDR_VAR 0 17
1890: PUSH
1891: LD_INT 7
1893: PUSH
1894: LD_INT 28
1896: PUSH
1897: LD_INT 45
1899: PUSH
1900: EMPTY
1901: LIST
1902: LIST
1903: LIST
1904: PUSH
1905: LD_VAR 0 11
1909: ARRAY
1910: ST_TO_ADDR
// break ;
1911: GO 1915
// end ; end ; end ;
1913: GO 1744
1915: POP
1916: POP
// end ; if not weapon then
1917: LD_VAR 0 17
1921: NOT
1922: IFFALSE 2077
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1924: LD_ADDR_VAR 0 4
1928: PUSH
1929: LD_VAR 0 4
1933: PUSH
1934: LD_INT 11
1936: PUSH
1937: LD_INT 30
1939: PUSH
1940: LD_INT 49
1942: PUSH
1943: EMPTY
1944: LIST
1945: LIST
1946: LIST
1947: DIFF
1948: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1949: LD_ADDR_VAR 0 13
1953: PUSH
1954: LD_INT 22
1956: PUSH
1957: LD_VAR 0 15
1961: PUSH
1962: EMPTY
1963: LIST
1964: LIST
1965: PUSH
1966: LD_INT 91
1968: PUSH
1969: LD_VAR 0 1
1973: PUSH
1974: LD_INT 6
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 3
1984: PUSH
1985: LD_INT 35
1987: PUSH
1988: LD_INT 0
1990: PUSH
1991: EMPTY
1992: LIST
1993: LIST
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: LIST
2003: PPUSH
2004: CALL_OW 69
2008: ST_TO_ADDR
// for i in tmp do
2009: LD_ADDR_VAR 0 7
2013: PUSH
2014: LD_VAR 0 13
2018: PUSH
2019: FOR_IN
2020: IFFALSE 2045
// list := list diff GetBWeapon ( i ) ;
2022: LD_ADDR_VAR 0 4
2026: PUSH
2027: LD_VAR 0 4
2031: PUSH
2032: LD_VAR 0 7
2036: PPUSH
2037: CALL_OW 269
2041: DIFF
2042: ST_TO_ADDR
2043: GO 2019
2045: POP
2046: POP
// if list then
2047: LD_VAR 0 4
2051: IFFALSE 2077
// weapon := list [ rand ( 1 , list ) ] ;
2053: LD_ADDR_VAR 0 17
2057: PUSH
2058: LD_VAR 0 4
2062: PUSH
2063: LD_INT 1
2065: PPUSH
2066: LD_VAR 0 4
2070: PPUSH
2071: CALL_OW 12
2075: ARRAY
2076: ST_TO_ADDR
// end ; if weapon then
2077: LD_VAR 0 17
2081: IFFALSE 2195
// begin tmp := CostOfWeapon ( weapon ) ;
2083: LD_ADDR_VAR 0 13
2087: PUSH
2088: LD_VAR 0 17
2092: PPUSH
2093: CALL_OW 451
2097: ST_TO_ADDR
// j := GetBase ( tower ) ;
2098: LD_ADDR_VAR 0 8
2102: PUSH
2103: LD_VAR 0 1
2107: PPUSH
2108: CALL_OW 274
2112: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
2113: LD_VAR 0 8
2117: PPUSH
2118: LD_INT 1
2120: PPUSH
2121: CALL_OW 275
2125: PUSH
2126: LD_VAR 0 13
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: GREATEREQUAL
2135: PUSH
2136: LD_VAR 0 8
2140: PPUSH
2141: LD_INT 2
2143: PPUSH
2144: CALL_OW 275
2148: PUSH
2149: LD_VAR 0 13
2153: PUSH
2154: LD_INT 2
2156: ARRAY
2157: GREATEREQUAL
2158: AND
2159: PUSH
2160: LD_VAR 0 8
2164: PPUSH
2165: LD_INT 3
2167: PPUSH
2168: CALL_OW 275
2172: PUSH
2173: LD_VAR 0 13
2177: PUSH
2178: LD_INT 3
2180: ARRAY
2181: GREATEREQUAL
2182: AND
2183: IFFALSE 2195
// result := weapon ;
2185: LD_ADDR_VAR 0 2
2189: PUSH
2190: LD_VAR 0 17
2194: ST_TO_ADDR
// end ; end ;
2195: LD_VAR 0 2
2199: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2200: LD_INT 0
2202: PPUSH
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
// if not un or not IsOk ( un ) then
2207: LD_VAR 0 1
2211: NOT
2212: PUSH
2213: LD_VAR 0 1
2217: PPUSH
2218: CALL_OW 302
2222: NOT
2223: OR
2224: IFFALSE 2228
// exit ;
2226: GO 2674
// side := GetSide ( un ) ;
2228: LD_ADDR_VAR 0 9
2232: PUSH
2233: LD_VAR 0 1
2237: PPUSH
2238: CALL_OW 255
2242: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2243: LD_ADDR_VAR 0 7
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: LD_VAR 0 9
2255: PUSH
2256: EMPTY
2257: LIST
2258: LIST
2259: PUSH
2260: LD_INT 30
2262: PUSH
2263: LD_INT 32
2265: PUSH
2266: EMPTY
2267: LIST
2268: LIST
2269: PUSH
2270: LD_INT 50
2272: PUSH
2273: EMPTY
2274: LIST
2275: PUSH
2276: LD_INT 58
2278: PUSH
2279: EMPTY
2280: LIST
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: LIST
2287: PPUSH
2288: CALL_OW 69
2292: PUSH
2293: LD_VAR 0 2
2297: DIFF
2298: ST_TO_ADDR
// if not filter then
2299: LD_VAR 0 7
2303: NOT
2304: IFFALSE 2539
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2306: LD_ADDR_VAR 0 7
2310: PUSH
2311: LD_INT 22
2313: PUSH
2314: LD_VAR 0 9
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: PUSH
2323: LD_INT 30
2325: PUSH
2326: LD_INT 5
2328: PUSH
2329: EMPTY
2330: LIST
2331: LIST
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: PPUSH
2337: CALL_OW 69
2341: ST_TO_ADDR
// if debug then
2342: LD_EXP 1
2346: IFFALSE 2365
// display_strings := [ filter , 1 ] ;
2348: LD_ADDR_OWVAR 47
2352: PUSH
2353: LD_VAR 0 7
2357: PUSH
2358: LD_STRING 1
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: ST_TO_ADDR
// if not filter then
2365: LD_VAR 0 7
2369: NOT
2370: IFFALSE 2393
// begin ComMoveXY ( un , x , y ) ;
2372: LD_VAR 0 1
2376: PPUSH
2377: LD_VAR 0 3
2381: PPUSH
2382: LD_VAR 0 4
2386: PPUSH
2387: CALL_OW 111
// exit ;
2391: GO 2674
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2393: LD_ADDR_VAR 0 8
2397: PUSH
2398: LD_VAR 0 7
2402: PPUSH
2403: LD_VAR 0 1
2407: PPUSH
2408: CALL_OW 74
2412: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2413: LD_VAR 0 8
2417: PPUSH
2418: CALL_OW 313
2422: PUSH
2423: LD_INT 6
2425: EQUAL
2426: IFFALSE 2446
// filter := filter diff t else
2428: LD_ADDR_VAR 0 7
2432: PUSH
2433: LD_VAR 0 7
2437: PUSH
2438: LD_VAR 0 8
2442: DIFF
2443: ST_TO_ADDR
2444: GO 2448
// break ;
2446: GO 2470
// until UnitsInside ( t ) < 6 or not filter ;
2448: LD_VAR 0 8
2452: PPUSH
2453: CALL_OW 313
2457: PUSH
2458: LD_INT 6
2460: LESS
2461: PUSH
2462: LD_VAR 0 7
2466: NOT
2467: OR
2468: IFFALSE 2393
// if debug then
2470: LD_EXP 1
2474: IFFALSE 2495
// display_strings := [ filter , t ] ;
2476: LD_ADDR_OWVAR 47
2480: PUSH
2481: LD_VAR 0 7
2485: PUSH
2486: LD_VAR 0 8
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: ST_TO_ADDR
// if not filter then
2495: LD_VAR 0 7
2499: NOT
2500: IFFALSE 2523
// ComMoveXY ( un , x , y ) else
2502: LD_VAR 0 1
2506: PPUSH
2507: LD_VAR 0 3
2511: PPUSH
2512: LD_VAR 0 4
2516: PPUSH
2517: CALL_OW 111
2521: GO 2537
// ComEnterUnit ( un , t ) ;
2523: LD_VAR 0 1
2527: PPUSH
2528: LD_VAR 0 8
2532: PPUSH
2533: CALL_OW 120
// end else
2537: GO 2674
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2539: LD_ADDR_VAR 0 8
2543: PUSH
2544: LD_VAR 0 7
2548: PPUSH
2549: LD_VAR 0 1
2553: PPUSH
2554: CALL_OW 74
2558: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2559: LD_VAR 0 8
2563: PPUSH
2564: CALL_OW 110
2568: PUSH
2569: LD_INT 7
2571: EQUAL
2572: IFFALSE 2590
// filter := filter diff t ;
2574: LD_ADDR_VAR 0 7
2578: PUSH
2579: LD_VAR 0 7
2583: PUSH
2584: LD_VAR 0 8
2588: DIFF
2589: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2590: LD_VAR 0 8
2594: PPUSH
2595: CALL_OW 110
2599: PUSH
2600: LD_INT 7
2602: NONEQUAL
2603: PUSH
2604: LD_VAR 0 7
2608: NOT
2609: OR
2610: IFFALSE 2539
// if GetTag ( t ) <> 7 then
2612: LD_VAR 0 8
2616: PPUSH
2617: CALL_OW 110
2621: PUSH
2622: LD_INT 7
2624: NONEQUAL
2625: IFFALSE 2655
// begin SetTag ( t , 7 ) ;
2627: LD_VAR 0 8
2631: PPUSH
2632: LD_INT 7
2634: PPUSH
2635: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2639: LD_VAR 0 1
2643: PPUSH
2644: LD_VAR 0 8
2648: PPUSH
2649: CALL_OW 120
// end else
2653: GO 2674
// ComMoveXY ( un , x , y ) ;
2655: LD_VAR 0 1
2659: PPUSH
2660: LD_VAR 0 3
2664: PPUSH
2665: LD_VAR 0 4
2669: PPUSH
2670: CALL_OW 111
// end ; end ;
2674: LD_VAR 0 5
2678: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2679: LD_INT 0
2681: PPUSH
2682: PPUSH
2683: PPUSH
// if not base then
2684: LD_VAR 0 1
2688: NOT
2689: IFFALSE 2693
// exit ;
2691: GO 2751
// tmp := GetEnergy ( GetBase ( base ) ) ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_VAR 0 1
2702: PPUSH
2703: CALL_OW 274
2707: PPUSH
2708: CALL_OW 278
2712: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2713: LD_VAR 0 4
2717: PUSH
2718: LD_INT 1
2720: ARRAY
2721: PUSH
2722: LD_VAR 0 4
2726: PUSH
2727: LD_INT 4
2729: ARRAY
2730: GREATER
2731: IFFALSE 2743
// result := true else
2733: LD_ADDR_VAR 0 2
2737: PUSH
2738: LD_INT 1
2740: ST_TO_ADDR
2741: GO 2751
// result := false ;
2743: LD_ADDR_VAR 0 2
2747: PUSH
2748: LD_INT 0
2750: ST_TO_ADDR
// end ;
2751: LD_VAR 0 2
2755: RET
// export function FilterPeople ( side ) ; begin
2756: LD_INT 0
2758: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2759: LD_ADDR_VAR 0 2
2763: PUSH
2764: LD_INT 22
2766: PUSH
2767: LD_VAR 0 1
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: PUSH
2776: LD_INT 21
2778: PUSH
2779: LD_INT 1
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PPUSH
2790: CALL_OW 69
2794: ST_TO_ADDR
// end ;
2795: LD_VAR 0 2
2799: RET
// export function FilterDrivers ( side ) ; begin
2800: LD_INT 0
2802: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2803: LD_ADDR_VAR 0 2
2807: PUSH
2808: LD_INT 22
2810: PUSH
2811: LD_VAR 0 1
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 3
2822: PUSH
2823: LD_INT 56
2825: PUSH
2826: EMPTY
2827: LIST
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PPUSH
2837: CALL_OW 69
2841: ST_TO_ADDR
// end ;
2842: LD_VAR 0 2
2846: RET
// export function FilterPeopleArea ( side , area ) ; begin
2847: LD_INT 0
2849: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2850: LD_ADDR_VAR 0 3
2854: PUSH
2855: LD_VAR 0 2
2859: PPUSH
2860: LD_INT 22
2862: PUSH
2863: LD_INT 1
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: PUSH
2870: LD_INT 21
2872: PUSH
2873: LD_INT 1
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PPUSH
2884: CALL_OW 70
2888: ST_TO_ADDR
// end ;
2889: LD_VAR 0 3
2893: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2894: LD_INT 0
2896: PPUSH
2897: PPUSH
2898: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2899: LD_ADDR_VAR 0 5
2903: PUSH
2904: LD_VAR 0 2
2908: PPUSH
2909: LD_INT 22
2911: PUSH
2912: LD_INT 1
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PUSH
2919: LD_INT 21
2921: PUSH
2922: LD_INT 2
2924: PUSH
2925: EMPTY
2926: LIST
2927: LIST
2928: PUSH
2929: LD_INT 3
2931: PUSH
2932: LD_INT 58
2934: PUSH
2935: EMPTY
2936: LIST
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PPUSH
2947: CALL_OW 70
2951: ST_TO_ADDR
// result := [ ] ;
2952: LD_ADDR_VAR 0 3
2956: PUSH
2957: EMPTY
2958: ST_TO_ADDR
// if not tmp then
2959: LD_VAR 0 5
2963: NOT
2964: IFFALSE 2968
// exit ;
2966: GO 3020
// for i in tmp do
2968: LD_ADDR_VAR 0 4
2972: PUSH
2973: LD_VAR 0 5
2977: PUSH
2978: FOR_IN
2979: IFFALSE 3004
// result := result union IsDrivenBy ( i ) ;
2981: LD_ADDR_VAR 0 3
2985: PUSH
2986: LD_VAR 0 3
2990: PUSH
2991: LD_VAR 0 4
2995: PPUSH
2996: CALL_OW 311
3000: UNION
3001: ST_TO_ADDR
3002: GO 2978
3004: POP
3005: POP
// result := result diff 0 ;
3006: LD_ADDR_VAR 0 3
3010: PUSH
3011: LD_VAR 0 3
3015: PUSH
3016: LD_INT 0
3018: DIFF
3019: ST_TO_ADDR
// end ;
3020: LD_VAR 0 3
3024: RET
// export function FilterBuildings ( side ) ; begin
3025: LD_INT 0
3027: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 22
3035: PUSH
3036: LD_VAR 0 1
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 21
3047: PUSH
3048: LD_INT 3
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PPUSH
3059: CALL_OW 69
3063: ST_TO_ADDR
// end ;
3064: LD_VAR 0 2
3068: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
3069: LD_INT 0
3071: PPUSH
3072: PPUSH
3073: PPUSH
3074: PPUSH
// uc_side = 0 ;
3075: LD_ADDR_OWVAR 20
3079: PUSH
3080: LD_INT 0
3082: ST_TO_ADDR
// uc_nation = 0 ;
3083: LD_ADDR_OWVAR 21
3087: PUSH
3088: LD_INT 0
3090: ST_TO_ADDR
// nat_area := wildArea ;
3091: LD_ADDR_VAR 0 4
3095: PUSH
3096: LD_INT 3
3098: ST_TO_ADDR
// InitHc ;
3099: CALL_OW 19
// for i = 1 to 4 do
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: DOUBLE
3109: LD_INT 1
3111: DEC
3112: ST_TO_ADDR
3113: LD_INT 4
3115: PUSH
3116: FOR_TO
3117: IFFALSE 3172
// begin hc_class = 18 ;
3119: LD_ADDR_OWVAR 28
3123: PUSH
3124: LD_INT 18
3126: ST_TO_ADDR
// hc_gallery =  ;
3127: LD_ADDR_OWVAR 33
3131: PUSH
3132: LD_STRING 
3134: ST_TO_ADDR
// hc_face_number = 1 ;
3135: LD_ADDR_OWVAR 34
3139: PUSH
3140: LD_INT 1
3142: ST_TO_ADDR
// animal := CreateHuman ;
3143: LD_ADDR_VAR 0 3
3147: PUSH
3148: CALL_OW 44
3152: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_VAR 0 4
3162: PPUSH
3163: LD_INT 0
3165: PPUSH
3166: CALL_OW 49
// end ;
3170: GO 3116
3172: POP
3173: POP
// for i = 1 to 6 do
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: DOUBLE
3180: LD_INT 1
3182: DEC
3183: ST_TO_ADDR
3184: LD_INT 6
3186: PUSH
3187: FOR_TO
3188: IFFALSE 3259
// begin hc_class = class_tiger ;
3190: LD_ADDR_OWVAR 28
3194: PUSH
3195: LD_INT 14
3197: ST_TO_ADDR
// hc_gallery =  ;
3198: LD_ADDR_OWVAR 33
3202: PUSH
3203: LD_STRING 
3205: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3206: LD_ADDR_OWVAR 35
3210: PUSH
3211: LD_INT 0
3213: PPUSH
3214: LD_INT 10
3216: PPUSH
3217: CALL_OW 12
3221: ST_TO_ADDR
// hc_face_number = 3 ;
3222: LD_ADDR_OWVAR 34
3226: PUSH
3227: LD_INT 3
3229: ST_TO_ADDR
// animal := CreateHuman ;
3230: LD_ADDR_VAR 0 3
3234: PUSH
3235: CALL_OW 44
3239: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3240: LD_VAR 0 3
3244: PPUSH
3245: LD_VAR 0 4
3249: PPUSH
3250: LD_INT 0
3252: PPUSH
3253: CALL_OW 49
// end ;
3257: GO 3187
3259: POP
3260: POP
// for i = 1 to 2 do
3261: LD_ADDR_VAR 0 2
3265: PUSH
3266: DOUBLE
3267: LD_INT 1
3269: DEC
3270: ST_TO_ADDR
3271: LD_INT 2
3273: PUSH
3274: FOR_TO
3275: IFFALSE 3338
// begin hc_class = 21 ;
3277: LD_ADDR_OWVAR 28
3281: PUSH
3282: LD_INT 21
3284: ST_TO_ADDR
// hc_gallery =  ;
3285: LD_ADDR_OWVAR 33
3289: PUSH
3290: LD_STRING 
3292: ST_TO_ADDR
// hc_agressivity = 0 ;
3293: LD_ADDR_OWVAR 35
3297: PUSH
3298: LD_INT 0
3300: ST_TO_ADDR
// hc_face_number = 5 ;
3301: LD_ADDR_OWVAR 34
3305: PUSH
3306: LD_INT 5
3308: ST_TO_ADDR
// animal := CreateHuman ;
3309: LD_ADDR_VAR 0 3
3313: PUSH
3314: CALL_OW 44
3318: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3319: LD_VAR 0 3
3323: PPUSH
3324: LD_VAR 0 4
3328: PPUSH
3329: LD_INT 0
3331: PPUSH
3332: CALL_OW 49
// end ;
3336: GO 3274
3338: POP
3339: POP
// for i = 1 to 6 do
3340: LD_ADDR_VAR 0 2
3344: PUSH
3345: DOUBLE
3346: LD_INT 1
3348: DEC
3349: ST_TO_ADDR
3350: LD_INT 6
3352: PUSH
3353: FOR_TO
3354: IFFALSE 3409
// begin hc_class = 13 ;
3356: LD_ADDR_OWVAR 28
3360: PUSH
3361: LD_INT 13
3363: ST_TO_ADDR
// hc_gallery =  ;
3364: LD_ADDR_OWVAR 33
3368: PUSH
3369: LD_STRING 
3371: ST_TO_ADDR
// hc_face_number = 4 ;
3372: LD_ADDR_OWVAR 34
3376: PUSH
3377: LD_INT 4
3379: ST_TO_ADDR
// animal := CreateHuman ;
3380: LD_ADDR_VAR 0 3
3384: PUSH
3385: CALL_OW 44
3389: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_VAR 0 4
3399: PPUSH
3400: LD_INT 0
3402: PPUSH
3403: CALL_OW 49
// end ;
3407: GO 3353
3409: POP
3410: POP
// for i = 1 to 2 do
3411: LD_ADDR_VAR 0 2
3415: PUSH
3416: DOUBLE
3417: LD_INT 1
3419: DEC
3420: ST_TO_ADDR
3421: LD_INT 2
3423: PUSH
3424: FOR_TO
3425: IFFALSE 3484
// begin hc_class = 20 ;
3427: LD_ADDR_OWVAR 28
3431: PUSH
3432: LD_INT 20
3434: ST_TO_ADDR
// hc_gallery =  ;
3435: LD_ADDR_OWVAR 33
3439: PUSH
3440: LD_STRING 
3442: ST_TO_ADDR
// hc_face_number = 2 ;
3443: LD_ADDR_OWVAR 34
3447: PUSH
3448: LD_INT 2
3450: ST_TO_ADDR
// animal := CreateHuman ;
3451: LD_ADDR_VAR 0 3
3455: PUSH
3456: CALL_OW 44
3460: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_INT 101
3468: PPUSH
3469: LD_INT 37
3471: PPUSH
3472: LD_INT 3
3474: PPUSH
3475: LD_INT 0
3477: PPUSH
3478: CALL_OW 50
// end ;
3482: GO 3424
3484: POP
3485: POP
// for i = 1 to 1 do
3486: LD_ADDR_VAR 0 2
3490: PUSH
3491: DOUBLE
3492: LD_INT 1
3494: DEC
3495: ST_TO_ADDR
3496: LD_INT 1
3498: PUSH
3499: FOR_TO
3500: IFFALSE 3547
// begin vc_chassis := 31 ;
3502: LD_ADDR_OWVAR 37
3506: PUSH
3507: LD_INT 31
3509: ST_TO_ADDR
// vc_control := control_rider ;
3510: LD_ADDR_OWVAR 38
3514: PUSH
3515: LD_INT 4
3517: ST_TO_ADDR
// animal := CreateVehicle ;
3518: LD_ADDR_VAR 0 3
3522: PUSH
3523: CALL_OW 45
3527: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3528: LD_VAR 0 3
3532: PPUSH
3533: LD_VAR 0 4
3537: PPUSH
3538: LD_INT 0
3540: PPUSH
3541: CALL_OW 49
// end ;
3545: GO 3499
3547: POP
3548: POP
// end ;
3549: LD_VAR 0 1
3553: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3554: LD_INT 0
3556: PPUSH
3557: PPUSH
3558: PPUSH
3559: PPUSH
// result := [ ] ;
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: EMPTY
3566: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3567: LD_ADDR_VAR 0 4
3571: PUSH
3572: LD_INT 81
3574: PUSH
3575: LD_VAR 0 1
3579: PPUSH
3580: CALL_OW 255
3584: PUSH
3585: EMPTY
3586: LIST
3587: LIST
3588: PUSH
3589: LD_INT 91
3591: PUSH
3592: LD_VAR 0 1
3596: PUSH
3597: LD_INT 15
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 2
3607: PUSH
3608: LD_INT 30
3610: PUSH
3611: LD_INT 32
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: PUSH
3618: LD_INT 30
3620: PUSH
3621: LD_INT 33
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: PUSH
3628: EMPTY
3629: LIST
3630: LIST
3631: LIST
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: LIST
3637: PPUSH
3638: CALL_OW 69
3642: ST_TO_ADDR
// if not tmp then
3643: LD_VAR 0 4
3647: NOT
3648: IFFALSE 3652
// exit ;
3650: GO 3721
// for i in tmp do
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: LD_VAR 0 4
3661: PUSH
3662: FOR_IN
3663: IFFALSE 3719
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3665: LD_ADDR_VAR 0 5
3669: PUSH
3670: LD_VAR 0 3
3674: PPUSH
3675: CALL_OW 274
3679: PPUSH
3680: CALL_OW 278
3684: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3685: LD_VAR 0 5
3689: PUSH
3690: LD_INT 4
3692: ARRAY
3693: PUSH
3694: LD_VAR 0 5
3698: PUSH
3699: LD_INT 1
3701: ARRAY
3702: GREATER
3703: IFFALSE 3717
// begin result := i ;
3705: LD_ADDR_VAR 0 2
3709: PUSH
3710: LD_VAR 0 3
3714: ST_TO_ADDR
// break ;
3715: GO 3719
// end ; end ;
3717: GO 3662
3719: POP
3720: POP
// end ; end_of_file
3721: LD_VAR 0 2
3725: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3726: LD_INT 0
3728: PPUSH
3729: PPUSH
3730: PPUSH
3731: PPUSH
3732: PPUSH
3733: PPUSH
// uc_side := 1 ;
3734: LD_ADDR_OWVAR 20
3738: PUSH
3739: LD_INT 1
3741: ST_TO_ADDR
// uc_nation := 1 ;
3742: LD_ADDR_OWVAR 21
3746: PUSH
3747: LD_INT 1
3749: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3750: LD_ADDR_EXP 9
3754: PUSH
3755: LD_STRING JMM
3757: PPUSH
3758: LD_EXP 1
3762: NOT
3763: PPUSH
3764: CALL 500 0 2
3768: ST_TO_ADDR
// team := [ JMM ] ;
3769: LD_ADDR_VAR 0 3
3773: PUSH
3774: LD_EXP 9
3778: PUSH
3779: EMPTY
3780: LIST
3781: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3782: LD_STRING BrownIn07
3784: PPUSH
3785: LD_EXP 1
3789: PPUSH
3790: CALL_OW 30
3794: IFFALSE 3815
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3796: LD_ADDR_EXP 10
3800: PUSH
3801: LD_STRING Brown
3803: PPUSH
3804: LD_EXP 1
3808: NOT
3809: PPUSH
3810: CALL 500 0 2
3814: ST_TO_ADDR
// if Brown then
3815: LD_EXP 10
3819: IFFALSE 3837
// team := team ^ Brown ;
3821: LD_ADDR_VAR 0 3
3825: PUSH
3826: LD_VAR 0 3
3830: PUSH
3831: LD_EXP 10
3835: ADD
3836: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3837: LD_STRING DonaldsonIn07
3839: PPUSH
3840: LD_EXP 1
3844: PPUSH
3845: CALL_OW 30
3849: IFFALSE 3870
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3851: LD_ADDR_EXP 11
3855: PUSH
3856: LD_STRING Donaldson
3858: PPUSH
3859: LD_EXP 1
3863: NOT
3864: PPUSH
3865: CALL 500 0 2
3869: ST_TO_ADDR
// if Donaldson then
3870: LD_EXP 11
3874: IFFALSE 3892
// team := team ^ Donaldson ;
3876: LD_ADDR_VAR 0 3
3880: PUSH
3881: LD_VAR 0 3
3885: PUSH
3886: LD_EXP 11
3890: ADD
3891: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3892: LD_STRING BobbyIn07
3894: PPUSH
3895: LD_EXP 1
3899: PPUSH
3900: CALL_OW 30
3904: IFFALSE 3925
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3906: LD_ADDR_EXP 12
3910: PUSH
3911: LD_STRING Bobby
3913: PPUSH
3914: LD_EXP 1
3918: NOT
3919: PPUSH
3920: CALL 500 0 2
3924: ST_TO_ADDR
// if Bobby then
3925: LD_EXP 12
3929: IFFALSE 3947
// team := team ^ Bobby ;
3931: LD_ADDR_VAR 0 3
3935: PUSH
3936: LD_VAR 0 3
3940: PUSH
3941: LD_EXP 12
3945: ADD
3946: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3947: LD_STRING CyrusIn07
3949: PPUSH
3950: LD_EXP 1
3954: PPUSH
3955: CALL_OW 30
3959: IFFALSE 3980
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3961: LD_ADDR_EXP 13
3965: PUSH
3966: LD_STRING Cyrus
3968: PPUSH
3969: LD_EXP 1
3973: NOT
3974: PPUSH
3975: CALL 500 0 2
3979: ST_TO_ADDR
// if Cyrus then
3980: LD_EXP 13
3984: IFFALSE 4002
// team := team ^ Cyrus ;
3986: LD_ADDR_VAR 0 3
3990: PUSH
3991: LD_VAR 0 3
3995: PUSH
3996: LD_EXP 13
4000: ADD
4001: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
4002: LD_STRING LisaIn07
4004: PPUSH
4005: LD_EXP 1
4009: PPUSH
4010: CALL_OW 30
4014: IFFALSE 4035
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
4016: LD_ADDR_EXP 14
4020: PUSH
4021: LD_STRING Lisa
4023: PPUSH
4024: LD_EXP 1
4028: NOT
4029: PPUSH
4030: CALL 500 0 2
4034: ST_TO_ADDR
// if Lisa then
4035: LD_EXP 14
4039: IFFALSE 4057
// team := team ^ Lisa ;
4041: LD_ADDR_VAR 0 3
4045: PUSH
4046: LD_VAR 0 3
4050: PUSH
4051: LD_EXP 14
4055: ADD
4056: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
4057: LD_STRING GladstoneIn07
4059: PPUSH
4060: LD_EXP 1
4064: PPUSH
4065: CALL_OW 30
4069: IFFALSE 4090
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
4071: LD_ADDR_EXP 16
4075: PUSH
4076: LD_STRING Gladstone
4078: PPUSH
4079: LD_EXP 1
4083: NOT
4084: PPUSH
4085: CALL 500 0 2
4089: ST_TO_ADDR
// if Gladstone then
4090: LD_EXP 16
4094: IFFALSE 4112
// team := team ^ Gladstone ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: LD_VAR 0 3
4105: PUSH
4106: LD_EXP 16
4110: ADD
4111: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
4112: LD_STRING KhatamIn07
4114: PPUSH
4115: LD_EXP 1
4119: PPUSH
4120: CALL_OW 30
4124: IFFALSE 4145
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
4126: LD_ADDR_EXP 17
4130: PUSH
4131: LD_STRING Khatam
4133: PPUSH
4134: LD_EXP 1
4138: NOT
4139: PPUSH
4140: CALL 500 0 2
4144: ST_TO_ADDR
// if Khatam then
4145: LD_EXP 17
4149: IFFALSE 4167
// team := team ^ Khatam ;
4151: LD_ADDR_VAR 0 3
4155: PUSH
4156: LD_VAR 0 3
4160: PUSH
4161: LD_EXP 17
4165: ADD
4166: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4167: LD_ADDR_VAR 0 4
4171: PUSH
4172: LD_STRING 07_others
4174: PPUSH
4175: CALL_OW 31
4179: ST_TO_ADDR
// if others then
4180: LD_VAR 0 4
4184: IFFALSE 4202
// team := team ^ others ;
4186: LD_ADDR_VAR 0 3
4190: PUSH
4191: LD_VAR 0 3
4195: PUSH
4196: LD_VAR 0 4
4200: ADD
4201: ST_TO_ADDR
// if debug then
4202: LD_EXP 1
4206: IFFALSE 4280
// begin InitHc ;
4208: CALL_OW 19
// for i = 1 to 4 do
4212: LD_ADDR_VAR 0 2
4216: PUSH
4217: DOUBLE
4218: LD_INT 1
4220: DEC
4221: ST_TO_ADDR
4222: LD_INT 4
4224: PUSH
4225: FOR_TO
4226: IFFALSE 4278
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4228: LD_INT 0
4230: PPUSH
4231: LD_INT 1
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 1
4243: PPUSH
4244: LD_INT 2
4246: PPUSH
4247: CALL_OW 12
4251: ARRAY
4252: PPUSH
4253: LD_INT 4
4255: PPUSH
4256: CALL_OW 380
// team := team ^ CreateHuman ;
4260: LD_ADDR_VAR 0 3
4264: PUSH
4265: LD_VAR 0 3
4269: PUSH
4270: CALL_OW 44
4274: ADD
4275: ST_TO_ADDR
// end ;
4276: GO 4225
4278: POP
4279: POP
// end ; m := 0 ;
4280: LD_ADDR_VAR 0 6
4284: PUSH
4285: LD_INT 0
4287: ST_TO_ADDR
// for i in team do
4288: LD_ADDR_VAR 0 2
4292: PUSH
4293: LD_VAR 0 3
4297: PUSH
4298: FOR_IN
4299: IFFALSE 4506
// if GetClass ( i ) = 3 then
4301: LD_VAR 0 2
4305: PPUSH
4306: CALL_OW 257
4310: PUSH
4311: LD_INT 3
4313: EQUAL
4314: IFFALSE 4462
// begin m := m + 1 ;
4316: LD_ADDR_VAR 0 6
4320: PUSH
4321: LD_VAR 0 6
4325: PUSH
4326: LD_INT 1
4328: PLUS
4329: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4330: LD_ADDR_VAR 0 5
4334: PUSH
4335: LD_INT 1
4337: PPUSH
4338: LD_INT 1
4340: PPUSH
4341: LD_INT 2
4343: PUSH
4344: LD_INT 3
4346: PUSH
4347: LD_INT 2
4349: PUSH
4350: LD_INT 1
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: LIST
4357: LIST
4358: PUSH
4359: LD_VAR 0 6
4363: PUSH
4364: LD_INT 4
4366: MOD
4367: PUSH
4368: LD_INT 1
4370: PLUS
4371: ARRAY
4372: PPUSH
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 1
4378: PPUSH
4379: LD_INT 4
4381: PUSH
4382: LD_INT 5
4384: PUSH
4385: LD_INT 3
4387: PUSH
4388: LD_INT 11
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_VAR 0 6
4401: PUSH
4402: LD_INT 4
4404: MOD
4405: PUSH
4406: LD_INT 1
4408: PLUS
4409: ARRAY
4410: PPUSH
4411: LD_INT 60
4413: PPUSH
4414: CALL 563 0 7
4418: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4419: LD_VAR 0 5
4423: PPUSH
4424: LD_INT 2
4426: PPUSH
4427: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4431: LD_VAR 0 5
4435: PPUSH
4436: LD_INT 1
4438: PPUSH
4439: LD_INT 0
4441: PPUSH
4442: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_VAR 0 5
4455: PPUSH
4456: CALL_OW 52
// end else
4460: GO 4504
// begin if GetClass ( i ) = 2 then
4462: LD_VAR 0 2
4466: PPUSH
4467: CALL_OW 257
4471: PUSH
4472: LD_INT 2
4474: EQUAL
4475: IFFALSE 4489
// SetClass ( i , 1 ) ;
4477: LD_VAR 0 2
4481: PPUSH
4482: LD_INT 1
4484: PPUSH
4485: CALL_OW 336
// PlaceUnitArea ( i , startArea , false ) ;
4489: LD_VAR 0 2
4493: PPUSH
4494: LD_INT 1
4496: PPUSH
4497: LD_INT 0
4499: PPUSH
4500: CALL_OW 49
// end ;
4504: GO 4298
4506: POP
4507: POP
// uc_side := 4 ;
4508: LD_ADDR_OWVAR 20
4512: PUSH
4513: LD_INT 4
4515: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4516: LD_ADDR_EXP 19
4520: PUSH
4521: LD_STRING Harisson
4523: PPUSH
4524: LD_INT 0
4526: PPUSH
4527: CALL 500 0 2
4531: ST_TO_ADDR
// PrepareScout ;
4532: CALL 4541 0 0
// end ;
4536: LD_VAR 0 1
4540: RET
// function PrepareScout ; var ape ; begin
4541: LD_INT 0
4543: PPUSH
4544: PPUSH
// uc_side := 4 ;
4545: LD_ADDR_OWVAR 20
4549: PUSH
4550: LD_INT 4
4552: ST_TO_ADDR
// uc_nation := 1 ;
4553: LD_ADDR_OWVAR 21
4557: PUSH
4558: LD_INT 1
4560: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4561: LD_STRING FrankIn06
4563: PPUSH
4564: LD_INT 0
4566: PPUSH
4567: CALL_OW 30
4571: IFFALSE 4588
// Frank := CreateCharacter ( 06c_Frank ) else
4573: LD_ADDR_EXP 15
4577: PUSH
4578: LD_STRING 06c_Frank
4580: PPUSH
4581: CALL_OW 34
4585: ST_TO_ADDR
4586: GO 4628
// if LoadVariable ( FrankInDelta , 0 ) then
4588: LD_STRING FrankInDelta
4590: PPUSH
4591: LD_INT 0
4593: PPUSH
4594: CALL_OW 30
4598: IFFALSE 4615
// Frank := CreateCharacter ( 05_Frank ) else
4600: LD_ADDR_EXP 15
4604: PUSH
4605: LD_STRING 05_Frank
4607: PPUSH
4608: CALL_OW 34
4612: ST_TO_ADDR
4613: GO 4628
// Frank := CreateCharacter ( 04_Frank ) ;
4615: LD_ADDR_EXP 15
4619: PUSH
4620: LD_STRING 04_Frank
4622: PPUSH
4623: CALL_OW 34
4627: ST_TO_ADDR
// if Frank then
4628: LD_EXP 15
4632: IFFALSE 4765
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4634: LD_EXP 15
4638: PPUSH
4639: LD_INT 2
4641: PPUSH
4642: LD_INT 0
4644: PPUSH
4645: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4649: LD_EXP 15
4653: PPUSH
4654: LD_INT 1
4656: PPUSH
4657: CALL_OW 336
// uc_side := 0 ;
4661: LD_ADDR_OWVAR 20
4665: PUSH
4666: LD_INT 0
4668: ST_TO_ADDR
// uc_nation := 0 ;
4669: LD_ADDR_OWVAR 21
4673: PUSH
4674: LD_INT 0
4676: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4677: LD_INT 0
4679: PPUSH
4680: LD_INT 12
4682: PPUSH
4683: LD_INT 0
4685: PPUSH
4686: CALL_OW 380
// ape := CreateHuman ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: CALL_OW 44
4699: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4700: LD_VAR 0 2
4704: PPUSH
4705: LD_EXP 15
4709: PPUSH
4710: CALL_OW 250
4714: PPUSH
4715: LD_EXP 15
4719: PPUSH
4720: CALL_OW 251
4724: PPUSH
4725: LD_INT 5
4727: PPUSH
4728: LD_INT 0
4730: PPUSH
4731: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4735: LD_VAR 0 2
4739: PPUSH
4740: LD_EXP 15
4744: PPUSH
4745: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4749: LD_EXP 15
4753: PPUSH
4754: LD_VAR 0 2
4758: PPUSH
4759: CALL_OW 119
// exit ;
4763: GO 4805
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4765: LD_ADDR_EXP 18
4769: PUSH
4770: LD_STRING Yamoko
4772: PPUSH
4773: LD_INT 0
4775: PPUSH
4776: CALL 500 0 2
4780: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4781: LD_EXP 18
4785: PPUSH
4786: LD_INT 2
4788: PPUSH
4789: LD_INT 0
4791: PPUSH
4792: CALL_OW 49
// ComHold ( Kikuchi ) ;
4796: LD_EXP 18
4800: PPUSH
4801: CALL_OW 140
// end ; end_of_file
4805: LD_VAR 0 1
4809: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4810: LD_INT 0
4812: PPUSH
4813: PPUSH
4814: PPUSH
4815: PPUSH
4816: PPUSH
4817: PPUSH
4818: PPUSH
4819: PPUSH
4820: PPUSH
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
4826: PPUSH
4827: PPUSH
// ru_rebuild_list := [ ] ;
4828: LD_ADDR_EXP 20
4832: PUSH
4833: EMPTY
4834: ST_TO_ADDR
// uc_side := 3 ;
4835: LD_ADDR_OWVAR 20
4839: PUSH
4840: LD_INT 3
4842: ST_TO_ADDR
// uc_nation := 3 ;
4843: LD_ADDR_OWVAR 21
4847: PUSH
4848: LD_INT 3
4850: ST_TO_ADDR
// if Difficulty > 1 then
4851: LD_OWVAR 67
4855: PUSH
4856: LD_INT 1
4858: GREATER
4859: IFFALSE 4995
// begin bc_type := b_breastwork ;
4861: LD_ADDR_OWVAR 42
4865: PUSH
4866: LD_INT 31
4868: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4869: LD_INT 78
4871: PPUSH
4872: LD_INT 74
4874: PPUSH
4875: LD_INT 2
4877: PPUSH
4878: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4882: LD_INT 171
4884: PPUSH
4885: LD_INT 193
4887: PPUSH
4888: LD_INT 4
4890: PPUSH
4891: CALL_OW 47
// bc_type := b_turret ;
4895: LD_ADDR_OWVAR 42
4899: PUSH
4900: LD_INT 33
4902: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4903: LD_INT 129
4905: PPUSH
4906: LD_INT 96
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 47
// if Difficulty > 2 then
4916: LD_OWVAR 67
4920: PUSH
4921: LD_INT 2
4923: GREATER
4924: IFFALSE 4995
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4926: LD_INT 83
4928: PPUSH
4929: LD_INT 141
4931: PPUSH
4932: CALL_OW 428
4936: PPUSH
4937: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4941: LD_INT 78
4943: PPUSH
4944: LD_INT 133
4946: PPUSH
4947: CALL_OW 428
4951: PPUSH
4952: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4956: LD_INT 83
4958: PPUSH
4959: LD_INT 141
4961: PPUSH
4962: LD_INT 2
4964: PPUSH
4965: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4969: LD_INT 78
4971: PPUSH
4972: LD_INT 133
4974: PPUSH
4975: LD_INT 2
4977: PPUSH
4978: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4982: LD_INT 145
4984: PPUSH
4985: LD_INT 112
4987: PPUSH
4988: LD_INT 3
4990: PPUSH
4991: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4995: LD_ADDR_VAR 0 9
4999: PUSH
5000: LD_INT 22
5002: PUSH
5003: LD_INT 3
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: LD_INT 2
5012: PUSH
5013: LD_INT 30
5015: PUSH
5016: LD_INT 0
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 30
5025: PUSH
5026: LD_INT 1
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: LIST
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PPUSH
5042: CALL_OW 69
5046: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
5047: LD_ADDR_VAR 0 10
5051: PUSH
5052: LD_INT 22
5054: PUSH
5055: LD_INT 3
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 6
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 30
5077: PUSH
5078: LD_INT 7
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: LD_INT 30
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PPUSH
5105: CALL_OW 69
5109: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
5110: LD_ADDR_VAR 0 11
5114: PUSH
5115: LD_INT 22
5117: PUSH
5118: LD_INT 3
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 30
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
5144: LD_ADDR_VAR 0 12
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 30
5161: PUSH
5162: LD_INT 31
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PPUSH
5173: CALL_OW 69
5177: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5178: LD_ADDR_VAR 0 13
5182: PUSH
5183: LD_INT 22
5185: PUSH
5186: LD_INT 3
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 30
5195: PUSH
5196: LD_INT 32
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL_OW 69
5211: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5212: LD_ADDR_VAR 0 14
5216: PUSH
5217: LD_INT 22
5219: PUSH
5220: LD_INT 3
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: PUSH
5227: LD_INT 30
5229: PUSH
5230: LD_INT 33
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PUSH
5237: EMPTY
5238: LIST
5239: LIST
5240: PPUSH
5241: CALL_OW 69
5245: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5246: LD_ADDR_VAR 0 15
5250: PUSH
5251: LD_INT 42
5253: PUSH
5254: LD_INT 5
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 43
5263: PUSH
5264: LD_INT 50
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 44
5273: PUSH
5274: LD_INT 30
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 46
5283: PUSH
5284: LD_INT 15
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5297: LD_ADDR_VAR 0 16
5301: PUSH
5302: LD_INT 0
5304: PUSH
5305: LD_INT 4
5307: PUSH
5308: LD_INT 6
5310: PUSH
5311: LD_INT 3
5313: PUSH
5314: EMPTY
5315: LIST
5316: LIST
5317: LIST
5318: LIST
5319: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_INT 4
5327: PUSH
5328: LD_INT 5
5330: PUSH
5331: LD_INT 6
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: LIST
5338: PUSH
5339: LD_OWVAR 67
5343: ARRAY
5344: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5345: LD_INT 16
5347: PPUSH
5348: LD_STRING am_tukh
5350: PPUSH
5351: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 21
5362: PUSH
5363: LD_INT 3
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PPUSH
5370: CALL_OW 69
5374: PUSH
5375: FOR_IN
5376: IFFALSE 5409
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_INT 4
5385: PUSH
5386: LD_INT 5
5388: PUSH
5389: LD_INT 6
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_OWVAR 67
5401: ARRAY
5402: PPUSH
5403: CALL_OW 241
5407: GO 5375
5409: POP
5410: POP
// for i in dep_list do
5411: LD_ADDR_VAR 0 2
5415: PUSH
5416: LD_VAR 0 9
5420: PUSH
5421: FOR_IN
5422: IFFALSE 5466
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5424: LD_VAR 0 2
5428: PPUSH
5429: CALL_OW 274
5433: PPUSH
5434: LD_INT 1
5436: PPUSH
5437: LD_INT 1000
5439: PPUSH
5440: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 274
5453: PPUSH
5454: LD_INT 2
5456: PPUSH
5457: LD_INT 1000
5459: PPUSH
5460: CALL_OW 277
// end ;
5464: GO 5421
5466: POP
5467: POP
// InitHc ;
5468: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5472: LD_ADDR_VAR 0 8
5476: PUSH
5477: LD_VAR 0 13
5481: PUSH
5482: LD_INT 45
5484: PUSH
5485: LD_INT 60
5487: PUSH
5488: LD_INT 75
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: MUL
5502: PUSH
5503: LD_INT 100
5505: DIV
5506: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5507: LD_ADDR_VAR 0 16
5511: PUSH
5512: LD_VAR 0 16
5516: PPUSH
5517: LD_INT 1
5519: PPUSH
5520: LD_VAR 0 8
5524: PPUSH
5525: CALL_OW 1
5529: ST_TO_ADDR
// tmp := [ ] ;
5530: LD_ADDR_VAR 0 8
5534: PUSH
5535: EMPTY
5536: ST_TO_ADDR
// for i in bunker_list do
5537: LD_ADDR_VAR 0 2
5541: PUSH
5542: LD_VAR 0 13
5546: PUSH
5547: FOR_IN
5548: IFFALSE 5644
// if i mod 10 + 1 < tmp then
5550: LD_VAR 0 2
5554: PUSH
5555: LD_INT 10
5557: MOD
5558: PUSH
5559: LD_INT 1
5561: PLUS
5562: PUSH
5563: LD_VAR 0 8
5567: LESS
5568: IFFALSE 5613
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5570: LD_ADDR_VAR 0 8
5574: PUSH
5575: LD_VAR 0 8
5579: PPUSH
5580: LD_VAR 0 2
5584: PUSH
5585: LD_INT 3
5587: PPUSH
5588: LD_INT 5
5590: PPUSH
5591: CALL_OW 12
5595: MOD
5596: PUSH
5597: LD_INT 1
5599: PLUS
5600: PPUSH
5601: LD_VAR 0 2
5605: PPUSH
5606: CALL_OW 2
5610: ST_TO_ADDR
5611: GO 5642
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5613: LD_ADDR_VAR 0 8
5617: PUSH
5618: LD_VAR 0 8
5622: PPUSH
5623: LD_VAR 0 8
5627: PUSH
5628: LD_INT 1
5630: PLUS
5631: PPUSH
5632: LD_VAR 0 2
5636: PPUSH
5637: CALL_OW 2
5641: ST_TO_ADDR
5642: GO 5547
5644: POP
5645: POP
// bunker_list := tmp ;
5646: LD_ADDR_VAR 0 13
5650: PUSH
5651: LD_VAR 0 8
5655: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5656: LD_ADDR_VAR 0 2
5660: PUSH
5661: LD_VAR 0 13
5665: PUSH
5666: LD_VAR 0 14
5670: ADD
5671: PUSH
5672: FOR_IN
5673: IFFALSE 5696
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5675: LD_VAR 0 2
5679: PPUSH
5680: LD_VAR 0 2
5684: PPUSH
5685: CALL 977 0 1
5689: PPUSH
5690: CALL_OW 431
5694: GO 5672
5696: POP
5697: POP
// while ( personel_counter [ 1 ] ) do
5698: LD_VAR 0 16
5702: PUSH
5703: LD_INT 1
5705: ARRAY
5706: IFFALSE 5814
// begin i := rand ( 1 , bunker_list ) ;
5708: LD_ADDR_VAR 0 2
5712: PUSH
5713: LD_INT 1
5715: PPUSH
5716: LD_VAR 0 13
5720: PPUSH
5721: CALL_OW 12
5725: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5726: LD_INT 0
5728: PPUSH
5729: LD_INT 1
5731: PPUSH
5732: LD_VAR 0 6
5736: PPUSH
5737: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5741: CALL_OW 44
5745: PPUSH
5746: LD_VAR 0 13
5750: PUSH
5751: LD_VAR 0 2
5755: ARRAY
5756: PPUSH
5757: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5761: LD_ADDR_VAR 0 13
5765: PUSH
5766: LD_VAR 0 13
5770: PPUSH
5771: LD_VAR 0 2
5775: PPUSH
5776: CALL_OW 3
5780: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5781: LD_ADDR_VAR 0 16
5785: PUSH
5786: LD_VAR 0 16
5790: PPUSH
5791: LD_INT 1
5793: PPUSH
5794: LD_VAR 0 16
5798: PUSH
5799: LD_INT 1
5801: ARRAY
5802: PUSH
5803: LD_INT 1
5805: MINUS
5806: PPUSH
5807: CALL_OW 1
5811: ST_TO_ADDR
// end ;
5812: GO 5698
// for i = 1 to personel_counter [ 2 ] do
5814: LD_ADDR_VAR 0 2
5818: PUSH
5819: DOUBLE
5820: LD_INT 1
5822: DEC
5823: ST_TO_ADDR
5824: LD_VAR 0 16
5828: PUSH
5829: LD_INT 2
5831: ARRAY
5832: PUSH
5833: FOR_TO
5834: IFFALSE 5865
// begin PrepareHuman ( false , 2 , skill ) ;
5836: LD_INT 0
5838: PPUSH
5839: LD_INT 2
5841: PPUSH
5842: LD_VAR 0 6
5846: PPUSH
5847: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5851: CALL_OW 44
5855: PPUSH
5856: LD_INT 16
5858: PPUSH
5859: CALL_OW 52
// end ;
5863: GO 5833
5865: POP
5866: POP
// for i = 1 to personel_counter [ 3 ] do
5867: LD_ADDR_VAR 0 2
5871: PUSH
5872: DOUBLE
5873: LD_INT 1
5875: DEC
5876: ST_TO_ADDR
5877: LD_VAR 0 16
5881: PUSH
5882: LD_INT 3
5884: ARRAY
5885: PUSH
5886: FOR_TO
5887: IFFALSE 5934
// begin PrepareHuman ( false , 3 , skill ) ;
5889: LD_INT 0
5891: PPUSH
5892: LD_INT 3
5894: PPUSH
5895: LD_VAR 0 6
5899: PPUSH
5900: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_VAR 0 11
5913: PUSH
5914: LD_VAR 0 2
5918: PUSH
5919: LD_INT 2
5921: MOD
5922: PUSH
5923: LD_INT 1
5925: PLUS
5926: ARRAY
5927: PPUSH
5928: CALL_OW 52
// end ;
5932: GO 5886
5934: POP
5935: POP
// for i = 1 to personel_counter [ 4 ] do
5936: LD_ADDR_VAR 0 2
5940: PUSH
5941: DOUBLE
5942: LD_INT 1
5944: DEC
5945: ST_TO_ADDR
5946: LD_VAR 0 16
5950: PUSH
5951: LD_INT 4
5953: ARRAY
5954: PUSH
5955: FOR_TO
5956: IFFALSE 5993
// begin PrepareHuman ( false , 4 , skill ) ;
5958: LD_INT 0
5960: PPUSH
5961: LD_INT 4
5963: PPUSH
5964: LD_VAR 0 6
5968: PPUSH
5969: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5973: CALL_OW 44
5977: PPUSH
5978: LD_VAR 0 10
5982: PUSH
5983: LD_INT 1
5985: ARRAY
5986: PPUSH
5987: CALL_OW 52
// end ;
5991: GO 5955
5993: POP
5994: POP
// for i in breastworks_list do
5995: LD_ADDR_VAR 0 2
5999: PUSH
6000: LD_VAR 0 12
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6118
// begin r := GetDir ( i ) ;
6008: LD_ADDR_VAR 0 4
6012: PUSH
6013: LD_VAR 0 2
6017: PPUSH
6018: CALL_OW 254
6022: ST_TO_ADDR
// if r > 3 then
6023: LD_VAR 0 4
6027: PUSH
6028: LD_INT 3
6030: GREATER
6031: IFFALSE 6049
// r := r - 3 else
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 4
6042: PUSH
6043: LD_INT 3
6045: MINUS
6046: ST_TO_ADDR
6047: GO 6063
// r := r + 3 ;
6049: LD_ADDR_VAR 0 4
6053: PUSH
6054: LD_VAR 0 4
6058: PUSH
6059: LD_INT 3
6061: PLUS
6062: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6063: LD_INT 0
6065: PPUSH
6066: LD_INT 1
6068: PPUSH
6069: LD_VAR 0 6
6073: PPUSH
6074: CALL_OW 380
// un := CreateHuman ;
6078: LD_ADDR_VAR 0 5
6082: PUSH
6083: CALL_OW 44
6087: ST_TO_ADDR
// SetDir ( un , r ) ;
6088: LD_VAR 0 5
6092: PPUSH
6093: LD_VAR 0 4
6097: PPUSH
6098: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6102: LD_VAR 0 5
6106: PPUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: CALL_OW 52
// end ;
6116: GO 6005
6118: POP
6119: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
6120: LD_ADDR_VAR 0 8
6124: PUSH
6125: LD_INT 22
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: LD_INT 25
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PPUSH
6149: CALL_OW 69
6153: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
6154: LD_ADDR_VAR 0 4
6158: PUSH
6159: LD_INT 4
6161: PUSH
6162: LD_INT 5
6164: PUSH
6165: LD_INT 6
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: LD_OWVAR 67
6177: ARRAY
6178: ST_TO_ADDR
// for i = 1 to r do
6179: LD_ADDR_VAR 0 2
6183: PUSH
6184: DOUBLE
6185: LD_INT 1
6187: DEC
6188: ST_TO_ADDR
6189: LD_VAR 0 4
6193: PUSH
6194: FOR_TO
6195: IFFALSE 6368
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6197: LD_ADDR_VAR 0 5
6201: PUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 3
6207: PPUSH
6208: LD_INT 22
6210: PUSH
6211: LD_INT 22
6213: PUSH
6214: LD_INT 24
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: LD_INT 3
6229: MOD
6230: PUSH
6231: LD_INT 1
6233: PLUS
6234: ARRAY
6235: PPUSH
6236: LD_INT 1
6238: PPUSH
6239: LD_INT 1
6241: PPUSH
6242: LD_INT 43
6244: PUSH
6245: LD_INT 44
6247: PUSH
6248: LD_INT 42
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: LIST
6255: PUSH
6256: LD_VAR 0 2
6260: PUSH
6261: LD_INT 3
6263: MOD
6264: PUSH
6265: LD_INT 1
6267: PLUS
6268: ARRAY
6269: PPUSH
6270: LD_INT 100
6272: PPUSH
6273: CALL 563 0 7
6277: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6278: LD_VAR 0 5
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: LD_INT 5
6288: PPUSH
6289: CALL_OW 12
6293: PPUSH
6294: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_INT 5
6305: PPUSH
6306: LD_INT 0
6308: PPUSH
6309: CALL_OW 49
// if i > tmp - 2 then
6313: LD_VAR 0 2
6317: PUSH
6318: LD_VAR 0 8
6322: PUSH
6323: LD_INT 2
6325: MINUS
6326: GREATER
6327: IFFALSE 6331
// continue ;
6329: GO 6194
// ComExitBuilding ( tmp [ i ] ) ;
6331: LD_VAR 0 8
6335: PUSH
6336: LD_VAR 0 2
6340: ARRAY
6341: PPUSH
6342: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6346: LD_VAR 0 8
6350: PUSH
6351: LD_VAR 0 2
6355: ARRAY
6356: PPUSH
6357: LD_VAR 0 5
6361: PPUSH
6362: CALL_OW 180
// end ;
6366: GO 6194
6368: POP
6369: POP
// end ;
6370: LD_VAR 0 1
6374: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6375: LD_INT 22
6377: PUSH
6378: LD_INT 3
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 25
6387: PUSH
6388: LD_INT 2
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL_OW 69
6403: IFFALSE 7135
6405: GO 6407
6407: DISABLE
6408: LD_INT 0
6410: PPUSH
6411: PPUSH
6412: PPUSH
6413: PPUSH
6414: PPUSH
// begin enable ;
6415: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6416: LD_ADDR_VAR 0 2
6420: PUSH
6421: LD_INT 6
6423: PPUSH
6424: LD_INT 3
6426: PUSH
6427: LD_INT 24
6429: PUSH
6430: LD_INT 1000
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: PUSH
6441: LD_INT 21
6443: PUSH
6444: LD_INT 3
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL_OW 70
6459: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6460: LD_ADDR_VAR 0 4
6464: PUSH
6465: LD_INT 22
6467: PUSH
6468: LD_INT 3
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: LD_INT 25
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PPUSH
6489: CALL_OW 69
6493: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6494: LD_VAR 0 2
6498: NOT
6499: PUSH
6500: LD_EXP 20
6504: NOT
6505: AND
6506: IFFALSE 6576
// begin for i in engs do
6508: LD_ADDR_VAR 0 1
6512: PUSH
6513: LD_VAR 0 4
6517: PUSH
6518: FOR_IN
6519: IFFALSE 6574
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6521: LD_VAR 0 1
6525: PPUSH
6526: CALL_OW 256
6530: PUSH
6531: LD_INT 1000
6533: EQUAL
6534: PUSH
6535: LD_VAR 0 1
6539: PPUSH
6540: CALL_OW 314
6544: NOT
6545: AND
6546: PUSH
6547: LD_VAR 0 1
6551: PPUSH
6552: CALL_OW 310
6556: NOT
6557: AND
6558: IFFALSE 6572
// ComEnterUnit ( i , ru_dep_main ) ;
6560: LD_VAR 0 1
6564: PPUSH
6565: LD_INT 16
6567: PPUSH
6568: CALL_OW 120
6572: GO 6518
6574: POP
6575: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6576: LD_VAR 0 4
6580: PPUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 24
6586: PUSH
6587: LD_INT 650
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PPUSH
6598: CALL_OW 72
6602: IFFALSE 6695
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6604: LD_ADDR_VAR 0 3
6608: PUSH
6609: LD_VAR 0 4
6613: PPUSH
6614: LD_INT 3
6616: PUSH
6617: LD_INT 24
6619: PUSH
6620: LD_INT 650
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: PPUSH
6631: CALL_OW 72
6635: ST_TO_ADDR
// for i in tmp do
6636: LD_ADDR_VAR 0 1
6640: PUSH
6641: LD_VAR 0 3
6645: PUSH
6646: FOR_IN
6647: IFFALSE 6693
// if not IsInArea ( i , mainBaseArea ) then
6649: LD_VAR 0 1
6653: PPUSH
6654: LD_INT 14
6656: PPUSH
6657: CALL_OW 308
6661: NOT
6662: IFFALSE 6691
// begin ComMoveXY ( i , 129 , 125 ) ;
6664: LD_VAR 0 1
6668: PPUSH
6669: LD_INT 129
6671: PPUSH
6672: LD_INT 125
6674: PPUSH
6675: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6679: LD_VAR 0 1
6683: PPUSH
6684: LD_INT 1050
6686: PPUSH
6687: CALL_OW 202
// end ;
6691: GO 6646
6693: POP
6694: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_VAR 0 4
6704: PPUSH
6705: LD_INT 24
6707: PUSH
6708: LD_INT 650
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PPUSH
6715: CALL_OW 72
6719: ST_TO_ADDR
// if not engs then
6720: LD_VAR 0 4
6724: NOT
6725: IFFALSE 6729
// exit ;
6727: GO 7135
// if filter then
6729: LD_VAR 0 2
6733: IFFALSE 6992
// begin for i in engs do
6735: LD_ADDR_VAR 0 1
6739: PUSH
6740: LD_VAR 0 4
6744: PUSH
6745: FOR_IN
6746: IFFALSE 6770
// if IsInUnit ( i ) then
6748: LD_VAR 0 1
6752: PPUSH
6753: CALL_OW 310
6757: IFFALSE 6768
// ComExitBuilding ( i ) ;
6759: LD_VAR 0 1
6763: PPUSH
6764: CALL_OW 122
6768: GO 6745
6770: POP
6771: POP
// wait ( 3 ) ;
6772: LD_INT 3
6774: PPUSH
6775: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6779: LD_VAR 0 2
6783: PUSH
6784: LD_INT 2
6786: GREATEREQUAL
6787: PUSH
6788: LD_VAR 0 4
6792: PUSH
6793: LD_INT 2
6795: GREATEREQUAL
6796: AND
6797: IFFALSE 6945
// begin for i = 1 to engs / 2 do
6799: LD_ADDR_VAR 0 1
6803: PUSH
6804: DOUBLE
6805: LD_INT 1
6807: DEC
6808: ST_TO_ADDR
6809: LD_VAR 0 4
6813: PUSH
6814: LD_INT 2
6816: DIVREAL
6817: PUSH
6818: FOR_TO
6819: IFFALSE 6865
// if not HasTask ( engs [ i ] ) then
6821: LD_VAR 0 4
6825: PUSH
6826: LD_VAR 0 1
6830: ARRAY
6831: PPUSH
6832: CALL_OW 314
6836: NOT
6837: IFFALSE 6863
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6839: LD_VAR 0 4
6843: PUSH
6844: LD_VAR 0 1
6848: ARRAY
6849: PPUSH
6850: LD_VAR 0 2
6854: PUSH
6855: LD_INT 1
6857: ARRAY
6858: PPUSH
6859: CALL_OW 130
6863: GO 6818
6865: POP
6866: POP
// for i = engs / 2 + 1 to engs do
6867: LD_ADDR_VAR 0 1
6871: PUSH
6872: DOUBLE
6873: LD_VAR 0 4
6877: PUSH
6878: LD_INT 2
6880: DIVREAL
6881: PUSH
6882: LD_INT 1
6884: PLUS
6885: DEC
6886: ST_TO_ADDR
6887: LD_VAR 0 4
6891: PUSH
6892: FOR_TO
6893: IFFALSE 6941
// if not HasTask ( engs [ i ] ) then
6895: LD_VAR 0 4
6899: PUSH
6900: LD_VAR 0 1
6904: ARRAY
6905: PPUSH
6906: CALL_OW 314
6910: NOT
6911: IFFALSE 6939
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6913: LD_VAR 0 4
6917: PUSH
6918: LD_VAR 0 1
6922: ARRAY
6923: PPUSH
6924: LD_VAR 0 2
6928: PUSH
6929: LD_VAR 0 2
6933: ARRAY
6934: PPUSH
6935: CALL_OW 130
6939: GO 6892
6941: POP
6942: POP
// end else
6943: GO 6992
// for i in engs do
6945: LD_ADDR_VAR 0 1
6949: PUSH
6950: LD_VAR 0 4
6954: PUSH
6955: FOR_IN
6956: IFFALSE 6990
// if not HasTask ( i ) then
6958: LD_VAR 0 1
6962: PPUSH
6963: CALL_OW 314
6967: NOT
6968: IFFALSE 6988
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_VAR 0 2
6979: PUSH
6980: LD_INT 1
6982: ARRAY
6983: PPUSH
6984: CALL_OW 130
6988: GO 6955
6990: POP
6991: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6992: LD_ADDR_VAR 0 5
6996: PUSH
6997: LD_INT 81
6999: PUSH
7000: LD_INT 3
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: ST_TO_ADDR
// if ru_rebuild_list and not filter then
7012: LD_EXP 20
7016: PUSH
7017: LD_VAR 0 2
7021: NOT
7022: AND
7023: IFFALSE 7135
// begin ComExitBuilding ( engs ) ;
7025: LD_VAR 0 4
7029: PPUSH
7030: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
7034: LD_VAR 0 5
7038: PPUSH
7039: LD_EXP 20
7043: PUSH
7044: LD_INT 2
7046: ARRAY
7047: PPUSH
7048: LD_EXP 20
7052: PUSH
7053: LD_INT 3
7055: ARRAY
7056: PPUSH
7057: CALL_OW 73
7061: PPUSH
7062: LD_EXP 20
7066: PUSH
7067: LD_INT 2
7069: ARRAY
7070: PPUSH
7071: LD_EXP 20
7075: PUSH
7076: LD_INT 3
7078: ARRAY
7079: PPUSH
7080: CALL_OW 297
7084: PUSH
7085: LD_INT 10
7087: GREATER
7088: IFFALSE 7135
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
7090: LD_VAR 0 4
7094: PPUSH
7095: LD_EXP 20
7099: PUSH
7100: LD_INT 1
7102: ARRAY
7103: PPUSH
7104: LD_EXP 20
7108: PUSH
7109: LD_INT 2
7111: ARRAY
7112: PPUSH
7113: LD_EXP 20
7117: PUSH
7118: LD_INT 3
7120: ARRAY
7121: PPUSH
7122: LD_EXP 20
7126: PUSH
7127: LD_INT 4
7129: ARRAY
7130: PPUSH
7131: CALL_OW 145
// end ; end ;
7135: PPOPN 5
7137: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 250 do var i , tmp ;
7138: LD_INT 16
7140: PPUSH
7141: CALL_OW 256
7145: PUSH
7146: LD_INT 250
7148: LESS
7149: IFFALSE 7339
7151: GO 7153
7153: DISABLE
7154: LD_INT 0
7156: PPUSH
7157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
7158: LD_ADDR_VAR 0 2
7162: PUSH
7163: LD_INT 22
7165: PUSH
7166: LD_INT 3
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 2
7175: PUSH
7176: LD_INT 25
7178: PUSH
7179: LD_INT 1
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: LD_INT 25
7188: PUSH
7189: LD_INT 3
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 25
7198: PUSH
7199: LD_INT 4
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PPUSH
7216: CALL_OW 69
7220: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7221: LD_VAR 0 2
7225: PPUSH
7226: CALL_OW 122
// wait ( 3 ) ;
7230: LD_INT 3
7232: PPUSH
7233: CALL_OW 67
// ComMoveXY ( tmp , 156 , 211 ) ;
7237: LD_VAR 0 2
7241: PPUSH
7242: LD_INT 156
7244: PPUSH
7245: LD_INT 211
7247: PPUSH
7248: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7252: LD_INT 35
7254: PPUSH
7255: CALL_OW 67
// for i in tmp do
7259: LD_ADDR_VAR 0 1
7263: PUSH
7264: LD_VAR 0 2
7268: PUSH
7269: FOR_IN
7270: IFFALSE 7330
// if IsInArea ( i , escapeArea ) then
7272: LD_VAR 0 1
7276: PPUSH
7277: LD_INT 15
7279: PPUSH
7280: CALL_OW 308
7284: IFFALSE 7313
// begin RemoveUnit ( i ) ;
7286: LD_VAR 0 1
7290: PPUSH
7291: CALL_OW 64
// tmp := tmp diff i ;
7295: LD_ADDR_VAR 0 2
7299: PUSH
7300: LD_VAR 0 2
7304: PUSH
7305: LD_VAR 0 1
7309: DIFF
7310: ST_TO_ADDR
// end else
7311: GO 7328
// ComMoveXY ( i , 156 , 211 ) ;
7313: LD_VAR 0 1
7317: PPUSH
7318: LD_INT 156
7320: PPUSH
7321: LD_INT 211
7323: PPUSH
7324: CALL_OW 111
7328: GO 7269
7330: POP
7331: POP
// until not tmp ;
7332: LD_VAR 0 2
7336: NOT
7337: IFFALSE 7252
// end ;
7339: PPOPN 2
7341: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 250 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7342: LD_INT 16
7344: PPUSH
7345: CALL_OW 256
7349: PUSH
7350: LD_INT 250
7352: GREATER
7353: PUSH
7354: LD_INT 22
7356: PUSH
7357: LD_INT 3
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: PUSH
7364: LD_INT 25
7366: PUSH
7367: LD_INT 1
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PUSH
7374: LD_INT 56
7376: PUSH
7377: EMPTY
7378: LIST
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: PUSH
7385: EMPTY
7386: LIST
7387: PPUSH
7388: CALL_OW 69
7392: AND
7393: IFFALSE 7505
7395: GO 7397
7397: DISABLE
7398: LD_INT 0
7400: PPUSH
7401: PPUSH
// begin enable ;
7402: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7403: LD_ADDR_VAR 0 2
7407: PUSH
7408: LD_INT 22
7410: PUSH
7411: LD_INT 3
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: PUSH
7418: LD_INT 25
7420: PUSH
7421: LD_INT 1
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: PUSH
7428: LD_INT 56
7430: PUSH
7431: EMPTY
7432: LIST
7433: PUSH
7434: LD_INT 3
7436: PUSH
7437: LD_INT 60
7439: PUSH
7440: EMPTY
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: LIST
7451: LIST
7452: PUSH
7453: EMPTY
7454: LIST
7455: PPUSH
7456: CALL_OW 69
7460: ST_TO_ADDR
// if not tmp then
7461: LD_VAR 0 2
7465: NOT
7466: IFFALSE 7470
// exit ;
7468: GO 7505
// for i in tmp do
7470: LD_ADDR_VAR 0 1
7474: PUSH
7475: LD_VAR 0 2
7479: PUSH
7480: FOR_IN
7481: IFFALSE 7503
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: LD_INT 143
7493: PPUSH
7494: LD_INT 143
7496: PPUSH
7497: CALL 2200 0 4
7501: GO 7480
7503: POP
7504: POP
// end ;
7505: PPOPN 2
7507: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7508: LD_INT 22
7510: PUSH
7511: LD_INT 3
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: LD_INT 25
7520: PUSH
7521: LD_INT 4
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: IFFALSE 7790
7538: GO 7540
7540: DISABLE
7541: LD_INT 0
7543: PPUSH
7544: PPUSH
7545: PPUSH
// begin enable ;
7546: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7547: LD_ADDR_VAR 0 2
7551: PUSH
7552: LD_INT 14
7554: PPUSH
7555: LD_INT 22
7557: PUSH
7558: LD_INT 3
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PUSH
7565: LD_INT 21
7567: PUSH
7568: LD_INT 1
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 3
7577: PUSH
7578: LD_INT 24
7580: PUSH
7581: LD_INT 1000
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PPUSH
7597: CALL_OW 70
7601: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7602: LD_ADDR_VAR 0 3
7606: PUSH
7607: LD_INT 22
7609: PUSH
7610: LD_INT 3
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PUSH
7617: LD_INT 25
7619: PUSH
7620: LD_INT 4
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PPUSH
7631: CALL_OW 69
7635: ST_TO_ADDR
// if not doc then
7636: LD_VAR 0 3
7640: NOT
7641: IFFALSE 7645
// exit ;
7643: GO 7790
// if not tmp then
7645: LD_VAR 0 2
7649: NOT
7650: IFFALSE 7741
// begin if not IsInUnit ( doc [ 1 ] ) then
7652: LD_VAR 0 3
7656: PUSH
7657: LD_INT 1
7659: ARRAY
7660: PPUSH
7661: CALL_OW 310
7665: NOT
7666: IFFALSE 7739
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7668: LD_VAR 0 3
7672: PPUSH
7673: LD_INT 22
7675: PUSH
7676: LD_INT 3
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 2
7685: PUSH
7686: LD_INT 30
7688: PUSH
7689: LD_INT 6
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: LD_INT 30
7698: PUSH
7699: LD_INT 7
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 30
7708: PUSH
7709: LD_INT 8
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: PPUSH
7726: CALL_OW 69
7730: PUSH
7731: LD_INT 1
7733: ARRAY
7734: PPUSH
7735: CALL_OW 120
// exit ;
7739: GO 7790
// end ; if IsInUnit ( doc [ 1 ] ) then
7741: LD_VAR 0 3
7745: PUSH
7746: LD_INT 1
7748: ARRAY
7749: PPUSH
7750: CALL_OW 310
7754: IFFALSE 7765
// ComExitBuilding ( doc ) ;
7756: LD_VAR 0 3
7760: PPUSH
7761: CALL_OW 122
// wait ( 3 ) ;
7765: LD_INT 3
7767: PPUSH
7768: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7772: LD_VAR 0 3
7776: PPUSH
7777: LD_VAR 0 2
7781: PUSH
7782: LD_INT 1
7784: ARRAY
7785: PPUSH
7786: CALL_OW 128
// end ;
7790: PPOPN 3
7792: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7793: LD_INT 22
7795: PUSH
7796: LD_INT 3
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PUSH
7803: LD_INT 25
7805: PUSH
7806: LD_INT 3
7808: PUSH
7809: EMPTY
7810: LIST
7811: LIST
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: PPUSH
7817: CALL_OW 69
7821: PUSH
7822: LD_INT 22
7824: PUSH
7825: LD_INT 3
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: LD_INT 21
7834: PUSH
7835: LD_INT 2
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PPUSH
7846: CALL_OW 69
7850: AND
7851: IFFALSE 8265
7853: GO 7855
7855: DISABLE
7856: LD_INT 0
7858: PPUSH
7859: PPUSH
7860: PPUSH
7861: PPUSH
7862: PPUSH
// begin enable ;
7863: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7864: LD_ADDR_VAR 0 2
7868: PUSH
7869: LD_INT 22
7871: PUSH
7872: LD_INT 3
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PUSH
7879: LD_INT 21
7881: PUSH
7882: LD_INT 2
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 3
7891: PUSH
7892: LD_INT 58
7894: PUSH
7895: EMPTY
7896: LIST
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7912: LD_ADDR_VAR 0 4
7916: PUSH
7917: LD_INT 10
7919: PUSH
7920: LD_INT 11
7922: PUSH
7923: LD_INT 12
7925: PUSH
7926: LD_INT 14
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: LIST
7933: LIST
7934: ST_TO_ADDR
// area := 0 ;
7935: LD_ADDR_VAR 0 5
7939: PUSH
7940: LD_INT 0
7942: ST_TO_ADDR
// attacking := false ;
7943: LD_ADDR_VAR 0 3
7947: PUSH
7948: LD_INT 0
7950: ST_TO_ADDR
// for i in tmp do
7951: LD_ADDR_VAR 0 1
7955: PUSH
7956: LD_VAR 0 2
7960: PUSH
7961: FOR_IN
7962: IFFALSE 8048
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 22
7971: PUSH
7972: LD_INT 1
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 69
7983: PPUSH
7984: LD_VAR 0 1
7988: PPUSH
7989: CALL_OW 74
7993: PPUSH
7994: CALL_OW 296
7998: PUSH
7999: LD_INT 10
8001: LESS
8002: IFFALSE 8046
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 22
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PPUSH
8019: CALL_OW 69
8023: PPUSH
8024: LD_VAR 0 1
8028: PPUSH
8029: CALL_OW 74
8033: PPUSH
8034: CALL_OW 115
// attacking := true ;
8038: LD_ADDR_VAR 0 3
8042: PUSH
8043: LD_INT 1
8045: ST_TO_ADDR
// end ;
8046: GO 7961
8048: POP
8049: POP
// if attacking then
8050: LD_VAR 0 3
8054: IFFALSE 8058
// exit ;
8056: GO 8265
// for i in areas do
8058: LD_ADDR_VAR 0 1
8062: PUSH
8063: LD_VAR 0 4
8067: PUSH
8068: FOR_IN
8069: IFFALSE 8106
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
8071: LD_VAR 0 1
8075: PPUSH
8076: LD_INT 22
8078: PUSH
8079: LD_INT 1
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PPUSH
8086: CALL_OW 70
8090: IFFALSE 8104
// begin area := i ;
8092: LD_ADDR_VAR 0 5
8096: PUSH
8097: LD_VAR 0 1
8101: ST_TO_ADDR
// break ;
8102: GO 8106
// end ;
8104: GO 8068
8106: POP
8107: POP
// if area then
8108: LD_VAR 0 5
8112: IFFALSE 8265
// begin for i in tmp do
8114: LD_ADDR_VAR 0 1
8118: PUSH
8119: LD_VAR 0 2
8123: PUSH
8124: FOR_IN
8125: IFFALSE 8263
// begin if GetFuel ( i ) < 33 then
8127: LD_VAR 0 1
8131: PPUSH
8132: CALL_OW 261
8136: PUSH
8137: LD_INT 33
8139: LESS
8140: IFFALSE 8154
// SetFuel ( i , 33 ) ;
8142: LD_VAR 0 1
8146: PPUSH
8147: LD_INT 33
8149: PPUSH
8150: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
8154: LD_VAR 0 1
8158: PPUSH
8159: LD_INT 22
8161: PUSH
8162: LD_INT 1
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: PPUSH
8174: LD_VAR 0 1
8178: PPUSH
8179: CALL_OW 74
8183: PPUSH
8184: CALL_OW 296
8188: PUSH
8189: LD_INT 10
8191: LESS
8192: IFFALSE 8230
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8194: LD_VAR 0 1
8198: PPUSH
8199: LD_INT 22
8201: PUSH
8202: LD_INT 1
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: PPUSH
8209: CALL_OW 69
8213: PPUSH
8214: LD_VAR 0 1
8218: PPUSH
8219: CALL_OW 74
8223: PPUSH
8224: CALL_OW 115
8228: GO 8261
// if not IsInArea ( i , area ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: LD_VAR 0 5
8239: PPUSH
8240: CALL_OW 308
8244: NOT
8245: IFFALSE 8261
// ComMoveToArea ( i , area ) ;
8247: LD_VAR 0 1
8251: PPUSH
8252: LD_VAR 0 5
8256: PPUSH
8257: CALL_OW 113
// end ;
8261: GO 8124
8263: POP
8264: POP
// end ; end ;
8265: PPOPN 5
8267: END
// every 15 15$00 trigger Difficulty > 1 do var i , j , un , veh , time , count ;
8268: LD_OWVAR 67
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8553
8278: GO 8280
8280: DISABLE
8281: LD_INT 0
8283: PPUSH
8284: PPUSH
8285: PPUSH
8286: PPUSH
8287: PPUSH
8288: PPUSH
// begin uc_side := 3 ;
8289: LD_ADDR_OWVAR 20
8293: PUSH
8294: LD_INT 3
8296: ST_TO_ADDR
// uc_nation := 3 ;
8297: LD_ADDR_OWVAR 21
8301: PUSH
8302: LD_INT 3
8304: ST_TO_ADDR
// time := [ 9 9$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8305: LD_ADDR_VAR 0 5
8309: PUSH
8310: LD_INT 18900
8312: PUSH
8313: LD_INT 14700
8315: PUSH
8316: LD_INT 12600
8318: PUSH
8319: EMPTY
8320: LIST
8321: LIST
8322: LIST
8323: PUSH
8324: LD_OWVAR 67
8328: ARRAY
8329: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8330: LD_ADDR_VAR 0 6
8334: PUSH
8335: LD_INT 2
8337: PUSH
8338: LD_INT 2
8340: PUSH
8341: LD_INT 3
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: LIST
8348: PUSH
8349: LD_OWVAR 67
8353: ARRAY
8354: ST_TO_ADDR
// for i = 1 to count do
8355: LD_ADDR_VAR 0 1
8359: PUSH
8360: DOUBLE
8361: LD_INT 1
8363: DEC
8364: ST_TO_ADDR
8365: LD_VAR 0 6
8369: PUSH
8370: FOR_TO
8371: IFFALSE 8551
// begin wait ( time ) ;
8373: LD_VAR 0 5
8377: PPUSH
8378: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8382: LD_ADDR_VAR 0 2
8386: PUSH
8387: DOUBLE
8388: LD_INT 1
8390: DEC
8391: ST_TO_ADDR
8392: LD_INT 1
8394: PPUSH
8395: LD_OWVAR 67
8399: PPUSH
8400: CALL_OW 12
8404: PUSH
8405: FOR_TO
8406: IFFALSE 8547
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8408: LD_ADDR_VAR 0 4
8412: PUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 22
8421: PPUSH
8422: LD_INT 1
8424: PPUSH
8425: LD_INT 1
8427: PPUSH
8428: LD_INT 43
8430: PUSH
8431: LD_INT 44
8433: PUSH
8434: LD_INT 42
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: LD_VAR 0 1
8446: PUSH
8447: LD_INT 3
8449: MOD
8450: PUSH
8451: LD_INT 1
8453: PLUS
8454: ARRAY
8455: PPUSH
8456: LD_INT 80
8458: PPUSH
8459: CALL 563 0 7
8463: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8464: LD_VAR 0 4
8468: PPUSH
8469: LD_INT 13
8471: PPUSH
8472: LD_INT 0
8474: PPUSH
8475: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8479: LD_INT 0
8481: PPUSH
8482: LD_INT 3
8484: PPUSH
8485: LD_INT 4
8487: PUSH
8488: LD_INT 5
8490: PUSH
8491: LD_INT 5
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: LIST
8498: PUSH
8499: LD_OWVAR 67
8503: ARRAY
8504: PPUSH
8505: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8509: CALL_OW 44
8513: PPUSH
8514: LD_VAR 0 4
8518: PPUSH
8519: CALL_OW 52
// wait ( 0 0$01 ) ;
8523: LD_INT 35
8525: PPUSH
8526: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8530: LD_VAR 0 4
8534: PPUSH
8535: LD_INT 143
8537: PPUSH
8538: LD_INT 143
8540: PPUSH
8541: CALL_OW 111
// end ;
8545: GO 8405
8547: POP
8548: POP
// end ;
8549: GO 8370
8551: POP
8552: POP
// end ;
8553: PPOPN 6
8555: END
// every 8 8$00 do var i , un , time ;
8556: GO 8558
8558: DISABLE
8559: LD_INT 0
8561: PPUSH
8562: PPUSH
8563: PPUSH
// begin time := [ 3 3$00 , 1 1$00 , 0 0$30 ] ;
8564: LD_ADDR_VAR 0 3
8568: PUSH
8569: LD_INT 6300
8571: PUSH
8572: LD_INT 2100
8574: PUSH
8575: LD_INT 1050
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: ST_TO_ADDR
// wait ( time ) ;
8583: LD_VAR 0 3
8587: PPUSH
8588: CALL_OW 67
// uc_side := 3 ;
8592: LD_ADDR_OWVAR 20
8596: PUSH
8597: LD_INT 3
8599: ST_TO_ADDR
// uc_nation := 3 ;
8600: LD_ADDR_OWVAR 21
8604: PUSH
8605: LD_INT 3
8607: ST_TO_ADDR
// for i = 1 to 2 do
8608: LD_ADDR_VAR 0 1
8612: PUSH
8613: DOUBLE
8614: LD_INT 1
8616: DEC
8617: ST_TO_ADDR
8618: LD_INT 2
8620: PUSH
8621: FOR_TO
8622: IFFALSE 8685
// begin PrepareHuman ( false , 1 , 4 ) ;
8624: LD_INT 0
8626: PPUSH
8627: LD_INT 1
8629: PPUSH
8630: LD_INT 4
8632: PPUSH
8633: CALL_OW 380
// un := CreateHuman ;
8637: LD_ADDR_VAR 0 2
8641: PUSH
8642: CALL_OW 44
8646: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8647: LD_VAR 0 2
8651: PPUSH
8652: LD_INT 16
8654: PPUSH
8655: CALL_OW 52
// ComExitBuilding ( un ) ;
8659: LD_VAR 0 2
8663: PPUSH
8664: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8668: LD_VAR 0 2
8672: PPUSH
8673: LD_INT 41
8675: PPUSH
8676: LD_INT 76
8678: PPUSH
8679: CALL_OW 174
// end ;
8683: GO 8621
8685: POP
8686: POP
// end ; end_of_file
8687: PPOPN 3
8689: END
// export function Action ; begin
8690: LD_INT 0
8692: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8693: LD_INT 28
8695: PPUSH
8696: LD_INT 3
8698: PPUSH
8699: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8703: LD_INT 41
8705: PPUSH
8706: LD_INT 76
8708: PPUSH
8709: LD_INT 1
8711: PPUSH
8712: LD_INT 10
8714: PPUSH
8715: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8719: LD_INT 41
8721: PPUSH
8722: LD_INT 76
8724: PPUSH
8725: LD_INT 1
8727: PPUSH
8728: CALL_OW 331
// InGameOn ;
8732: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8736: LD_EXP 19
8740: PPUSH
8741: LD_STRING D2-Har-1
8743: PPUSH
8744: CALL_OW 94
// InGameOff ;
8748: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8752: LD_STRING M1
8754: PPUSH
8755: CALL_OW 337
// end ;
8759: LD_VAR 0 1
8763: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8764: LD_EXP 4
8768: PUSH
8769: LD_INT 1
8771: GREATER
8772: IFFALSE 8863
8774: GO 8776
8776: DISABLE
8777: LD_INT 0
8779: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8780: LD_ADDR_VAR 0 1
8784: PUSH
8785: LD_INT 1
8787: PPUSH
8788: CALL 651 0 1
8792: PUSH
8793: LD_INT 1
8795: ARRAY
8796: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8797: LD_VAR 0 1
8801: PPUSH
8802: LD_STRING D2a-Sol1-1
8804: PPUSH
8805: CALL_OW 88
// if not un then
8809: LD_VAR 0 1
8813: NOT
8814: IFFALSE 8845
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8816: LD_ADDR_VAR 0 1
8820: PUSH
8821: LD_INT 2
8823: PPUSH
8824: CALL 651 0 1
8828: PUSH
8829: LD_INT 1
8831: ARRAY
8832: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8833: LD_VAR 0 1
8837: PPUSH
8838: LD_STRING D2a-FSol1-1
8840: PPUSH
8841: CALL_OW 88
// end ; if Khatam then
8845: LD_EXP 17
8849: IFFALSE 8863
// Say ( Khatam , D3b-Khat-3 ) ;
8851: LD_EXP 17
8855: PPUSH
8856: LD_STRING D3b-Khat-3
8858: PPUSH
8859: CALL_OW 88
// end ;
8863: PPOPN 1
8865: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) and not InBattle ( 4 ) do var i , ape ;
8866: LD_EXP 15
8870: PUSH
8871: LD_EXP 18
8875: NOT
8876: AND
8877: PUSH
8878: LD_INT 22
8880: PUSH
8881: LD_INT 1
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PUSH
8888: LD_INT 92
8890: PUSH
8891: LD_EXP 15
8895: PPUSH
8896: CALL_OW 250
8900: PUSH
8901: LD_EXP 15
8905: PPUSH
8906: CALL_OW 251
8910: PUSH
8911: LD_INT 7
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: LIST
8918: LIST
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: AND
8929: PUSH
8930: LD_INT 1
8932: PPUSH
8933: CALL_OW 463
8937: NOT
8938: AND
8939: PUSH
8940: LD_INT 4
8942: PPUSH
8943: CALL_OW 463
8947: NOT
8948: AND
8949: IFFALSE 9536
8951: GO 8953
8953: DISABLE
8954: LD_INT 0
8956: PPUSH
8957: PPUSH
// begin InGameOn ;
8958: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8962: LD_ADDR_VAR 0 2
8966: PUSH
8967: LD_INT 22
8969: PUSH
8970: LD_INT 0
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PUSH
8977: LD_INT 25
8979: PUSH
8980: LD_INT 12
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: PUSH
8987: EMPTY
8988: LIST
8989: LIST
8990: PPUSH
8991: CALL_OW 69
8995: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8996: LD_ADDR_VAR 0 2
9000: PUSH
9001: LD_VAR 0 2
9005: PPUSH
9006: LD_EXP 15
9010: PPUSH
9011: CALL_OW 74
9015: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
9016: LD_ADDR_VAR 0 1
9020: PUSH
9021: LD_INT 22
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: PUSH
9031: LD_INT 21
9033: PUSH
9034: LD_INT 1
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: PUSH
9041: LD_INT 91
9043: PUSH
9044: LD_EXP 15
9048: PUSH
9049: LD_INT 20
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PPUSH
9062: CALL_OW 69
9066: PUSH
9067: FOR_IN
9068: IFFALSE 9086
// ComTurnUnit ( i , Frank ) ;
9070: LD_VAR 0 1
9074: PPUSH
9075: LD_EXP 15
9079: PPUSH
9080: CALL_OW 119
9084: GO 9067
9086: POP
9087: POP
// SetSide ( Frank , 1 ) ;
9088: LD_EXP 15
9092: PPUSH
9093: LD_INT 1
9095: PPUSH
9096: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
9100: LD_EXP 9
9104: PPUSH
9105: LD_EXP 15
9109: PPUSH
9110: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
9114: LD_EXP 9
9118: PPUSH
9119: LD_EXP 15
9123: PPUSH
9124: CALL_OW 179
// CenterOnUnits ( Frank ) ;
9128: LD_EXP 15
9132: PPUSH
9133: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
9137: LD_EXP 15
9141: PPUSH
9142: LD_STRING D3a-Frank-1
9144: PPUSH
9145: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
9149: LD_VAR 0 2
9153: PPUSH
9154: LD_INT 42
9156: PPUSH
9157: LD_INT 78
9159: PPUSH
9160: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
9164: LD_VAR 0 2
9168: PPUSH
9169: LD_EXP 15
9173: PPUSH
9174: CALL_OW 179
// if Lisa then
9178: LD_EXP 14
9182: IFFALSE 9196
// Say ( Lisa , D3a-Lisa-1 ) ;
9184: LD_EXP 14
9188: PPUSH
9189: LD_STRING D3a-Lisa-1
9191: PPUSH
9192: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
9196: LD_EXP 9
9200: PPUSH
9201: LD_STRING D3a-JMM-1
9203: PPUSH
9204: CALL_OW 88
// if Cyrus then
9208: LD_EXP 13
9212: IFFALSE 9226
// Say ( Cyrus , D3a-Cyrus-1 ) ;
9214: LD_EXP 13
9218: PPUSH
9219: LD_STRING D3a-Cyrus-1
9221: PPUSH
9222: CALL_OW 88
// if GetRandom ( sex_male ) then
9226: LD_INT 1
9228: PPUSH
9229: CALL 651 0 1
9233: IFFALSE 9254
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
9235: LD_INT 1
9237: PPUSH
9238: CALL 651 0 1
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_STRING D3a-Sol1-1
9249: PPUSH
9250: CALL_OW 88
// if GetRandom ( sex_female ) then
9254: LD_INT 2
9256: PPUSH
9257: CALL 651 0 1
9261: IFFALSE 9282
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
9263: LD_INT 2
9265: PPUSH
9266: CALL 651 0 1
9270: PUSH
9271: LD_INT 1
9273: ARRAY
9274: PPUSH
9275: LD_STRING D3a-FSol1-1
9277: PPUSH
9278: CALL_OW 88
// if Gladstone then
9282: LD_EXP 16
9286: IFFALSE 9300
// Say ( Gladstone , D3a-Glad-1 ) ;
9288: LD_EXP 16
9292: PPUSH
9293: LD_STRING D3a-Glad-1
9295: PPUSH
9296: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
9300: LD_VAR 0 2
9304: PPUSH
9305: LD_INT 60
9307: PPUSH
9308: LD_INT 113
9310: PPUSH
9311: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9315: LD_EXP 15
9319: PPUSH
9320: LD_STRING D3a-Frank-2
9322: PPUSH
9323: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9327: LD_EXP 15
9331: PPUSH
9332: LD_EXP 9
9336: PPUSH
9337: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9341: LD_EXP 9
9345: PPUSH
9346: LD_STRING D3a-JMM-2
9348: PPUSH
9349: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9353: LD_INT 1
9355: PPUSH
9356: LD_INT 4
9358: PPUSH
9359: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9363: LD_INT 85
9365: PPUSH
9366: LD_INT 134
9368: PPUSH
9369: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9373: LD_EXP 15
9377: PPUSH
9378: LD_STRING D3a-Frank-3
9380: PPUSH
9381: CALL_OW 88
// Wait ( 0 0$01 ) ;
9385: LD_INT 35
9387: PPUSH
9388: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9392: LD_INT 166
9394: PPUSH
9395: LD_INT 136
9397: PPUSH
9398: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9402: LD_EXP 9
9406: PPUSH
9407: LD_STRING D3a-JMM-3
9409: PPUSH
9410: CALL_OW 88
// Wait ( 0 0$01 ) ;
9414: LD_INT 35
9416: PPUSH
9417: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9421: LD_EXP 15
9425: PPUSH
9426: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9430: LD_EXP 15
9434: PPUSH
9435: LD_STRING D3a-Frank-4
9437: PPUSH
9438: CALL_OW 88
// if Lisa then
9442: LD_EXP 14
9446: IFFALSE 9460
// Say ( Lisa , D3a-Lisa-4 ) ;
9448: LD_EXP 14
9452: PPUSH
9453: LD_STRING D3a-Lisa-4
9455: PPUSH
9456: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9460: LD_EXP 9
9464: PPUSH
9465: LD_STRING D3a-JMM-4
9467: PPUSH
9468: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9472: LD_EXP 15
9476: PPUSH
9477: LD_STRING D3a-Frank-5
9479: PPUSH
9480: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9484: LD_EXP 9
9488: PPUSH
9489: LD_STRING D3a-JMM-5
9491: PPUSH
9492: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9496: LD_EXP 15
9500: PPUSH
9501: LD_STRING D3a-Frank-6
9503: PPUSH
9504: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9508: LD_EXP 9
9512: PPUSH
9513: LD_STRING D3a-JMM-6
9515: PPUSH
9516: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9520: LD_EXP 15
9524: PPUSH
9525: LD_STRING D3a-Frank-7
9527: PPUSH
9528: CALL_OW 88
// InGameOff ;
9532: CALL_OW 9
// end ;
9536: PPOPN 2
9538: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) and not InBattle ( 4 ) do
9539: LD_EXP 18
9543: PUSH
9544: LD_EXP 15
9548: NOT
9549: AND
9550: PUSH
9551: LD_INT 22
9553: PUSH
9554: LD_INT 1
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 92
9563: PUSH
9564: LD_EXP 18
9568: PPUSH
9569: CALL_OW 250
9573: PUSH
9574: LD_EXP 18
9578: PPUSH
9579: CALL_OW 251
9583: PUSH
9584: LD_INT 7
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PPUSH
9597: CALL_OW 69
9601: AND
9602: PUSH
9603: LD_INT 1
9605: PPUSH
9606: CALL_OW 463
9610: NOT
9611: AND
9612: PUSH
9613: LD_INT 4
9615: PPUSH
9616: CALL_OW 463
9620: NOT
9621: AND
9622: IFFALSE 9802
9624: GO 9626
9626: DISABLE
// begin InGameOn ;
9627: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9631: LD_EXP 9
9635: PPUSH
9636: LD_EXP 18
9640: PPUSH
9641: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9645: LD_EXP 18
9649: PPUSH
9650: LD_EXP 9
9654: PPUSH
9655: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9659: LD_EXP 18
9663: PPUSH
9664: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9668: LD_EXP 18
9672: PPUSH
9673: LD_STRING D3b-Yam-1
9675: PPUSH
9676: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9680: LD_EXP 9
9684: PPUSH
9685: LD_STRING D3b-JMM-1
9687: PPUSH
9688: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9692: LD_INT 1
9694: PPUSH
9695: LD_INT 4
9697: PPUSH
9698: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9702: LD_INT 85
9704: PPUSH
9705: LD_INT 134
9707: PPUSH
9708: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9712: LD_EXP 18
9716: PPUSH
9717: LD_STRING D3b-Yam-2
9719: PPUSH
9720: CALL_OW 88
// Wait ( 0 0$01 ) ;
9724: LD_INT 35
9726: PPUSH
9727: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9731: LD_EXP 9
9735: PPUSH
9736: LD_STRING D3b-JMM-2
9738: PPUSH
9739: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9743: LD_INT 166
9745: PPUSH
9746: LD_INT 136
9748: PPUSH
9749: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9753: LD_EXP 18
9757: PPUSH
9758: LD_STRING D3b-Yam-3
9760: PPUSH
9761: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9765: LD_EXP 9
9769: PPUSH
9770: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9774: LD_EXP 9
9778: PPUSH
9779: LD_STRING D3b-JMM-3a
9781: PPUSH
9782: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9786: LD_EXP 18
9790: PPUSH
9791: LD_INT 1
9793: PPUSH
9794: CALL_OW 235
// InGameOff ;
9798: CALL_OW 9
// end ;
9802: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9803: LD_INT 7
9805: PPUSH
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 3
9818: PUSH
9819: LD_INT 24
9821: PUSH
9822: LD_INT 1000
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PUSH
9833: EMPTY
9834: LIST
9835: LIST
9836: PPUSH
9837: CALL_OW 70
9841: IFFALSE 10297
9843: GO 9845
9845: DISABLE
9846: LD_INT 0
9848: PPUSH
9849: PPUSH
9850: PPUSH
9851: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9852: LD_INT 35
9854: PPUSH
9855: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9859: LD_ADDR_VAR 0 1
9863: PUSH
9864: LD_INT 7
9866: PPUSH
9867: LD_INT 22
9869: PUSH
9870: LD_INT 1
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: LD_INT 3
9879: PUSH
9880: LD_INT 24
9882: PUSH
9883: LD_INT 1000
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 70
9902: ST_TO_ADDR
// if not un then
9903: LD_VAR 0 1
9907: NOT
9908: IFFALSE 9912
// continue ;
9910: GO 9852
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9912: LD_ADDR_VAR 0 3
9916: PUSH
9917: LD_VAR 0 1
9921: PUSH
9922: LD_INT 1
9924: ARRAY
9925: PPUSH
9926: CALL 3554 0 1
9930: ST_TO_ADDR
// until tw ;
9931: LD_VAR 0 3
9935: IFFALSE 9852
// DialogueOn ;
9937: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9941: LD_VAR 0 3
9945: PPUSH
9946: CALL_OW 87
// if Lisa then
9950: LD_EXP 14
9954: IFFALSE 9982
// begin Say ( Lisa , D5-Lisa-1 ) ;
9956: LD_EXP 14
9960: PPUSH
9961: LD_STRING D5-Lisa-1
9963: PPUSH
9964: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9968: LD_EXP 9
9972: PPUSH
9973: LD_STRING D5-JMM-1a
9975: PPUSH
9976: CALL_OW 88
// end else
9980: GO 9994
// Say ( JMM , D5-JMM-1 ) ;
9982: LD_EXP 9
9986: PPUSH
9987: LD_STRING D5-JMM-1
9989: PPUSH
9990: CALL_OW 88
// DialogueOff ;
9994: CALL_OW 7
// while ( true ) do
9998: LD_INT 1
10000: IFFALSE 10056
// begin wait ( 0 0$01 ) ;
10002: LD_INT 35
10004: PPUSH
10005: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
10009: LD_ADDR_VAR 0 2
10013: PUSH
10014: LD_INT 8
10016: PPUSH
10017: LD_INT 30
10019: PUSH
10020: LD_INT 26
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 101
10029: PUSH
10030: LD_INT 1
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PPUSH
10041: CALL_OW 71
10045: ST_TO_ADDR
// if x then
10046: LD_VAR 0 2
10050: IFFALSE 10054
// break ;
10052: GO 10056
// end ;
10054: GO 9998
// CenterOnUnits ( x [ 1 ] ) ;
10056: LD_VAR 0 2
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PPUSH
10065: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
10069: LD_EXP 15
10073: PUSH
10074: LD_EXP 15
10078: PPUSH
10079: CALL_OW 255
10083: PUSH
10084: LD_INT 1
10086: EQUAL
10087: AND
10088: IFFALSE 10104
// Say ( Frank , D5a-Frank-1 ) else
10090: LD_EXP 15
10094: PPUSH
10095: LD_STRING D5a-Frank-1
10097: PPUSH
10098: CALL_OW 88
10102: GO 10158
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10104: LD_EXP 18
10108: PUSH
10109: LD_EXP 18
10113: PPUSH
10114: CALL_OW 255
10118: PUSH
10119: LD_INT 1
10121: EQUAL
10122: AND
10123: IFFALSE 10139
// Say ( Kikuchi , D5a-Yam-1 ) else
10125: LD_EXP 18
10129: PPUSH
10130: LD_STRING D5a-Yam-1
10132: PPUSH
10133: CALL_OW 88
10137: GO 10158
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
10139: LD_INT 1
10141: PPUSH
10142: CALL 651 0 1
10146: PUSH
10147: LD_INT 1
10149: ARRAY
10150: PPUSH
10151: LD_STRING D5a-Sol1-1
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
10158: LD_EXP 9
10162: PPUSH
10163: LD_STRING D5a-JMM-1
10165: PPUSH
10166: CALL_OW 88
// if Cyrus then
10170: LD_EXP 13
10174: IFFALSE 10188
// Say ( Cyrus , D5a-Cyrus-1 ) ;
10176: LD_EXP 13
10180: PPUSH
10181: LD_STRING D5a-Cyrus-1
10183: PPUSH
10184: CALL_OW 88
// x := false ;
10188: LD_ADDR_VAR 0 2
10192: PUSH
10193: LD_INT 0
10195: ST_TO_ADDR
// while ( true ) do
10196: LD_INT 1
10198: IFFALSE 10285
// begin wait ( 0 0$01 ) ;
10200: LD_INT 35
10202: PPUSH
10203: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
10207: LD_ADDR_VAR 0 4
10211: PUSH
10212: LD_INT 2
10214: PUSH
10215: LD_INT 30
10217: PUSH
10218: LD_INT 0
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 30
10227: PUSH
10228: LD_INT 1
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: EMPTY
10236: LIST
10237: LIST
10238: LIST
10239: PPUSH
10240: CALL_OW 69
10244: PUSH
10245: LD_INT 1
10247: DIFF
10248: PUSH
10249: FOR_IN
10250: IFFALSE 10273
// if BaseNeedEnergy ( i ) then
10252: LD_VAR 0 4
10256: PPUSH
10257: CALL 2679 0 1
10261: IFFALSE 10271
// x := true ;
10263: LD_ADDR_VAR 0 2
10267: PUSH
10268: LD_INT 1
10270: ST_TO_ADDR
10271: GO 10249
10273: POP
10274: POP
// if x then
10275: LD_VAR 0 2
10279: IFFALSE 10283
// break ;
10281: GO 10285
// end ;
10283: GO 10196
// Say ( JMM , D5b-JMM-1 ) ;
10285: LD_EXP 9
10289: PPUSH
10290: LD_STRING D5b-JMM-1
10292: PPUSH
10293: CALL_OW 88
// end ;
10297: PPOPN 4
10299: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
10300: LD_EXP 5
10304: PUSH
10305: LD_INT 1
10307: ARRAY
10308: PUSH
10309: LD_OWVAR 1
10313: LESS
10314: IFFALSE 10514
10316: GO 10318
10318: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10319: LD_INT 16
10321: PPUSH
10322: CALL_OW 301
10326: NOT
10327: IFFALSE 10350
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10329: LD_EXP 19
10333: PPUSH
10334: LD_STRING D3b-Har-3
10336: PPUSH
10337: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10341: LD_STRING M2a
10343: PPUSH
10344: CALL_OW 337
// end else
10348: GO 10369
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10350: LD_EXP 19
10354: PPUSH
10355: LD_STRING D3b-Har-3a
10357: PPUSH
10358: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10362: LD_STRING M2
10364: PPUSH
10365: CALL_OW 337
// end ; can_end := true ;
10369: LD_ADDR_EXP 6
10373: PUSH
10374: LD_INT 1
10376: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10377: LD_INT 9
10379: PPUSH
10380: LD_INT 1
10382: PPUSH
10383: CALL_OW 424
// Wait ( 0 0$02 ) ;
10387: LD_INT 70
10389: PPUSH
10390: CALL_OW 67
// if Lisa then
10394: LD_EXP 14
10398: IFFALSE 10412
// Say ( Lisa , D3b-Lisa ) ;
10400: LD_EXP 14
10404: PPUSH
10405: LD_STRING D3b-Lisa
10407: PPUSH
10408: CALL_OW 88
// if Bobby then
10412: LD_EXP 12
10416: IFFALSE 10430
// Say ( Bobby , D3b-Bobby-3 ) ;
10418: LD_EXP 12
10422: PPUSH
10423: LD_STRING D3b-Bobby-3
10425: PPUSH
10426: CALL_OW 88
// if Cyrus then
10430: LD_EXP 13
10434: IFFALSE 10448
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10436: LD_EXP 13
10440: PPUSH
10441: LD_STRING D3b-Cyrus-3
10443: PPUSH
10444: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10448: LD_EXP 15
10452: PUSH
10453: LD_EXP 15
10457: PPUSH
10458: CALL_OW 255
10462: PUSH
10463: LD_INT 1
10465: EQUAL
10466: AND
10467: IFFALSE 10481
// Say ( Frank , D3b-Frank-3 ) ;
10469: LD_EXP 15
10473: PPUSH
10474: LD_STRING D3b-Frank-3
10476: PPUSH
10477: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10481: LD_EXP 18
10485: PUSH
10486: LD_EXP 18
10490: PPUSH
10491: CALL_OW 255
10495: PUSH
10496: LD_INT 1
10498: EQUAL
10499: AND
10500: IFFALSE 10514
// Say ( Kikuchi , D3b-Yam-4 ) ;
10502: LD_EXP 18
10506: PPUSH
10507: LD_STRING D3b-Yam-4
10509: PPUSH
10510: CALL_OW 88
// end ;
10514: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10515: LD_EXP 5
10519: PUSH
10520: LD_INT 2
10522: ARRAY
10523: PUSH
10524: LD_OWVAR 1
10528: LESS
10529: IFFALSE 10561
10531: GO 10533
10533: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10534: LD_EXP 19
10538: PPUSH
10539: LD_STRING D4-Har-1
10541: PPUSH
10542: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10546: LD_STRING M3
10548: PPUSH
10549: CALL_OW 337
// must_end := true ;
10553: LD_ADDR_EXP 7
10557: PUSH
10558: LD_INT 1
10560: ST_TO_ADDR
// end ;
10561: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10562: LD_EXP 5
10566: PUSH
10567: LD_INT 3
10569: ARRAY
10570: PUSH
10571: LD_OWVAR 1
10575: LESS
10576: IFFALSE 10607
10578: GO 10580
10580: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10581: LD_INT 16
10583: PPUSH
10584: CALL_OW 301
10588: NOT
10589: IFFALSE 10600
// YouLost ( TimeOut1 ) else
10591: LD_STRING TimeOut1
10593: PPUSH
10594: CALL_OW 104
10598: GO 10607
// YouLost ( TimeOut2 ) ;
10600: LD_STRING TimeOut2
10602: PPUSH
10603: CALL_OW 104
// end ;
10607: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp , m1 , m2 , m3 ;
10608: LD_EXP 9
10612: PPUSH
10613: LD_INT 9
10615: PPUSH
10616: CALL_OW 308
10620: PUSH
10621: LD_EXP 6
10625: AND
10626: IFFALSE 11726
10628: GO 10630
10630: DISABLE
10631: LD_INT 0
10633: PPUSH
10634: PPUSH
10635: PPUSH
10636: PPUSH
10637: PPUSH
10638: PPUSH
// begin wait_on := false ;
10639: LD_ADDR_VAR 0 1
10643: PUSH
10644: LD_INT 0
10646: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10647: LD_INT 1
10649: PPUSH
10650: CALL 2756 0 1
10654: PUSH
10655: LD_INT 0
10657: PLUS
10658: PUSH
10659: LD_INT 1
10661: PPUSH
10662: LD_INT 9
10664: PPUSH
10665: CALL 2847 0 2
10669: PUSH
10670: LD_INT 1
10672: PPUSH
10673: LD_INT 9
10675: PPUSH
10676: CALL 2894 0 2
10680: ADD
10681: PUSH
10682: LD_INT 0
10684: PLUS
10685: GREATER
10686: IFFALSE 10735
// case Query ( Q1 ) of 1 :
10688: LD_STRING Q1
10690: PPUSH
10691: CALL_OW 97
10695: PUSH
10696: LD_INT 1
10698: DOUBLE
10699: EQUAL
10700: IFTRUE 10704
10702: GO 10715
10704: POP
// wait_on := true ; 2 :
10705: LD_ADDR_VAR 0 1
10709: PUSH
10710: LD_INT 1
10712: ST_TO_ADDR
10713: GO 10735
10715: LD_INT 2
10717: DOUBLE
10718: EQUAL
10719: IFTRUE 10723
10721: GO 10734
10723: POP
// wait_on := false ; end ;
10724: LD_ADDR_VAR 0 1
10728: PUSH
10729: LD_INT 0
10731: ST_TO_ADDR
10732: GO 10735
10734: POP
// repeat wait ( 0 0$01 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10742: LD_VAR 0 1
10746: NOT
10747: PUSH
10748: LD_INT 1
10750: PPUSH
10751: CALL 2756 0 1
10755: PUSH
10756: LD_INT 0
10758: PLUS
10759: PUSH
10760: LD_INT 1
10762: PPUSH
10763: LD_INT 9
10765: PPUSH
10766: CALL 2847 0 2
10770: PUSH
10771: LD_INT 1
10773: PPUSH
10774: LD_INT 9
10776: PPUSH
10777: CALL 2894 0 2
10781: ADD
10782: PUSH
10783: LD_INT 0
10785: PLUS
10786: EQUAL
10787: OR
10788: IFFALSE 10735
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10794: LD_EXP 9
10798: PPUSH
10799: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10803: LD_EXP 9
10807: PPUSH
10808: LD_STRING D6-JMM-1
10810: PPUSH
10811: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10815: LD_EXP 19
10819: PPUSH
10820: LD_STRING D6-Har-1
10822: PPUSH
10823: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10827: LD_EXP 9
10831: PPUSH
10832: LD_STRING D6-JMM-2
10834: PPUSH
10835: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10839: LD_EXP 19
10843: PPUSH
10844: LD_STRING D6-Har-2
10846: PPUSH
10847: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10851: LD_EXP 9
10855: PPUSH
10856: LD_STRING D6-JMM-3
10858: PPUSH
10859: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10863: LD_EXP 19
10867: PPUSH
10868: LD_STRING D6-Har-3
10870: PPUSH
10871: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10875: LD_EXP 9
10879: PPUSH
10880: LD_STRING D6-JMM-4
10882: PPUSH
10883: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10887: LD_EXP 19
10891: PPUSH
10892: LD_STRING D6-Har-4
10894: PPUSH
10895: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10899: LD_EXP 9
10903: PPUSH
10904: LD_STRING D6-JMM-5
10906: PPUSH
10907: CALL_OW 88
// DialogueOff ;
10911: CALL_OW 7
// m1 := false ;
10915: LD_ADDR_VAR 0 4
10919: PUSH
10920: LD_INT 0
10922: ST_TO_ADDR
// m2 := false ;
10923: LD_ADDR_VAR 0 5
10927: PUSH
10928: LD_INT 0
10930: ST_TO_ADDR
// m3 := false ;
10931: LD_ADDR_VAR 0 6
10935: PUSH
10936: LD_INT 0
10938: ST_TO_ADDR
// tmp := FilterBuildings ( 3 ) ;
10939: LD_ADDR_VAR 0 3
10943: PUSH
10944: LD_INT 3
10946: PPUSH
10947: CALL 3025 0 1
10951: ST_TO_ADDR
// if tmp >= 35 then
10952: LD_VAR 0 3
10956: PUSH
10957: LD_INT 35
10959: GREATEREQUAL
10960: IFFALSE 10997
// begin AddMedal ( Destroy1 , - 1 ) ;
10962: LD_STRING Destroy1
10964: PPUSH
10965: LD_INT 1
10967: NEG
10968: PPUSH
10969: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10973: LD_STRING Destroy2
10975: PPUSH
10976: LD_INT 1
10978: NEG
10979: PPUSH
10980: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10984: LD_STRING Destroy3
10986: PPUSH
10987: LD_INT 1
10989: NEG
10990: PPUSH
10991: CALL_OW 101
// end else
10995: GO 11108
// begin AddMedal ( Destroy1 , 1 ) ;
10997: LD_STRING Destroy1
10999: PPUSH
11000: LD_INT 1
11002: PPUSH
11003: CALL_OW 101
// m1 := true ;
11007: LD_ADDR_VAR 0 4
11011: PUSH
11012: LD_INT 1
11014: ST_TO_ADDR
// if tmp >= 25 then
11015: LD_VAR 0 3
11019: PUSH
11020: LD_INT 25
11022: GREATEREQUAL
11023: IFFALSE 11049
// begin AddMedal ( Destroy2 , - 1 ) ;
11025: LD_STRING Destroy2
11027: PPUSH
11028: LD_INT 1
11030: NEG
11031: PPUSH
11032: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
11036: LD_STRING Destroy3
11038: PPUSH
11039: LD_INT 1
11041: NEG
11042: PPUSH
11043: CALL_OW 101
// end else
11047: GO 11108
// begin AddMedal ( Destroy2 , 1 ) ;
11049: LD_STRING Destroy2
11051: PPUSH
11052: LD_INT 1
11054: PPUSH
11055: CALL_OW 101
// m2 := true ;
11059: LD_ADDR_VAR 0 5
11063: PUSH
11064: LD_INT 1
11066: ST_TO_ADDR
// if tmp >= 15 then
11067: LD_VAR 0 3
11071: PUSH
11072: LD_INT 15
11074: GREATEREQUAL
11075: IFFALSE 11090
// AddMedal ( Destroy3 , - 1 ) else
11077: LD_STRING Destroy3
11079: PPUSH
11080: LD_INT 1
11082: NEG
11083: PPUSH
11084: CALL_OW 101
11088: GO 11108
// begin AddMedal ( Destroy3 , 1 ) ;
11090: LD_STRING Destroy3
11092: PPUSH
11093: LD_INT 1
11095: PPUSH
11096: CALL_OW 101
// m3 := true ;
11100: LD_ADDR_VAR 0 6
11104: PUSH
11105: LD_INT 1
11107: ST_TO_ADDR
// end ; end ; end ; if tick <= 32 32$00 then
11108: LD_OWVAR 1
11112: PUSH
11113: LD_INT 67200
11115: LESSEQUAL
11116: IFFALSE 11125
// SetAchievement ( ACH_ASPEED_7 ) ;
11118: LD_STRING ACH_ASPEED_7
11120: PPUSH
11121: CALL_OW 543
// if m1 and m2 and m3 and Difficulty = 3 then
11125: LD_VAR 0 4
11129: PUSH
11130: LD_VAR 0 5
11134: AND
11135: PUSH
11136: LD_VAR 0 6
11140: AND
11141: PUSH
11142: LD_OWVAR 67
11146: PUSH
11147: LD_INT 3
11149: EQUAL
11150: AND
11151: IFFALSE 11163
// SetAchievementEX ( ACH_AMER , 7 ) ;
11153: LD_STRING ACH_AMER
11155: PPUSH
11156: LD_INT 7
11158: PPUSH
11159: CALL_OW 564
// GiveMedals ( MAIN ) ;
11163: LD_STRING MAIN
11165: PPUSH
11166: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
11170: LD_ADDR_VAR 0 3
11174: PUSH
11175: LD_INT 1
11177: PPUSH
11178: LD_INT 9
11180: PPUSH
11181: CALL 2847 0 2
11185: PUSH
11186: LD_INT 1
11188: PPUSH
11189: LD_INT 9
11191: PPUSH
11192: CALL 2894 0 2
11196: UNION
11197: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11198: LD_VAR 0 3
11202: PPUSH
11203: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11207: LD_EXP 9
11211: PPUSH
11212: LD_EXP 3
11216: PUSH
11217: LD_STRING JMM
11219: STR
11220: PPUSH
11221: CALL_OW 38
// if Brown in tmp then
11225: LD_EXP 10
11229: PUSH
11230: LD_VAR 0 3
11234: IN
11235: IFFALSE 11255
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
11237: LD_EXP 10
11241: PPUSH
11242: LD_EXP 3
11246: PUSH
11247: LD_STRING Brown
11249: STR
11250: PPUSH
11251: CALL_OW 38
// if Donaldson in tmp then
11255: LD_EXP 11
11259: PUSH
11260: LD_VAR 0 3
11264: IN
11265: IFFALSE 11285
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
11267: LD_EXP 11
11271: PPUSH
11272: LD_EXP 3
11276: PUSH
11277: LD_STRING Donaldson
11279: STR
11280: PPUSH
11281: CALL_OW 38
// if Bobby in tmp then
11285: LD_EXP 12
11289: PUSH
11290: LD_VAR 0 3
11294: IN
11295: IFFALSE 11315
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11297: LD_EXP 12
11301: PPUSH
11302: LD_EXP 3
11306: PUSH
11307: LD_STRING Bobby
11309: STR
11310: PPUSH
11311: CALL_OW 38
// if Cyrus in tmp then
11315: LD_EXP 13
11319: PUSH
11320: LD_VAR 0 3
11324: IN
11325: IFFALSE 11345
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11327: LD_EXP 13
11331: PPUSH
11332: LD_EXP 3
11336: PUSH
11337: LD_STRING Cyrus
11339: STR
11340: PPUSH
11341: CALL_OW 38
// if Lisa in tmp then
11345: LD_EXP 14
11349: PUSH
11350: LD_VAR 0 3
11354: IN
11355: IFFALSE 11375
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11357: LD_EXP 14
11361: PPUSH
11362: LD_EXP 3
11366: PUSH
11367: LD_STRING Lisa
11369: STR
11370: PPUSH
11371: CALL_OW 38
// if Frank in tmp then
11375: LD_EXP 15
11379: PUSH
11380: LD_VAR 0 3
11384: IN
11385: IFFALSE 11405
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11387: LD_EXP 15
11391: PPUSH
11392: LD_EXP 3
11396: PUSH
11397: LD_STRING Frank
11399: STR
11400: PPUSH
11401: CALL_OW 38
// if Gladstone in tmp then
11405: LD_EXP 16
11409: PUSH
11410: LD_VAR 0 3
11414: IN
11415: IFFALSE 11435
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
11417: LD_EXP 16
11421: PPUSH
11422: LD_EXP 3
11426: PUSH
11427: LD_STRING Gladstone
11429: STR
11430: PPUSH
11431: CALL_OW 38
// if Khatam in tmp then
11435: LD_EXP 17
11439: PUSH
11440: LD_VAR 0 3
11444: IN
11445: IFFALSE 11465
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11447: LD_EXP 17
11451: PPUSH
11452: LD_EXP 3
11456: PUSH
11457: LD_STRING Khatam
11459: STR
11460: PPUSH
11461: CALL_OW 38
// if Kikuchi in tmp then
11465: LD_EXP 18
11469: PUSH
11470: LD_VAR 0 3
11474: IN
11475: IFFALSE 11495
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11477: LD_EXP 18
11481: PPUSH
11482: LD_EXP 3
11486: PUSH
11487: LD_STRING Kikuchi
11489: STR
11490: PPUSH
11491: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11495: LD_VAR 0 3
11499: PUSH
11500: LD_EXP 9
11504: PUSH
11505: LD_EXP 10
11509: PUSH
11510: LD_EXP 11
11514: PUSH
11515: LD_EXP 12
11519: PUSH
11520: LD_EXP 13
11524: PUSH
11525: LD_EXP 14
11529: PUSH
11530: LD_EXP 15
11534: PUSH
11535: LD_EXP 16
11539: PUSH
11540: LD_EXP 18
11544: PUSH
11545: LD_EXP 17
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: DIFF
11562: PPUSH
11563: LD_EXP 3
11567: PUSH
11568: LD_STRING others
11570: STR
11571: PPUSH
11572: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11576: LD_OWVAR 1
11580: PPUSH
11581: LD_STRING 07_time
11583: PPUSH
11584: CALL_OW 39
// tmp := [ ] ;
11588: LD_ADDR_VAR 0 3
11592: PUSH
11593: EMPTY
11594: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11595: LD_ADDR_VAR 0 2
11599: PUSH
11600: LD_INT 9
11602: PPUSH
11603: LD_INT 22
11605: PUSH
11606: LD_INT 1
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: PUSH
11613: LD_INT 23
11615: PUSH
11616: LD_INT 1
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PUSH
11623: LD_INT 21
11625: PUSH
11626: LD_INT 2
11628: PUSH
11629: EMPTY
11630: LIST
11631: LIST
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: LIST
11637: PUSH
11638: EMPTY
11639: LIST
11640: PPUSH
11641: CALL_OW 70
11645: PUSH
11646: FOR_IN
11647: IFFALSE 11708
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11649: LD_ADDR_VAR 0 3
11653: PUSH
11654: LD_VAR 0 3
11658: PUSH
11659: LD_VAR 0 2
11663: PPUSH
11664: CALL_OW 265
11668: PUSH
11669: LD_VAR 0 2
11673: PPUSH
11674: CALL_OW 262
11678: PUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL_OW 263
11688: PUSH
11689: LD_VAR 0 2
11693: PPUSH
11694: CALL_OW 264
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: ADD
11705: ST_TO_ADDR
11706: GO 11646
11708: POP
11709: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11710: LD_VAR 0 3
11714: PPUSH
11715: LD_STRING 07_vehicles
11717: PPUSH
11718: CALL_OW 39
// YouWin ;
11722: CALL_OW 103
// end ; end_of_file
11726: PPOPN 6
11728: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11729: LD_VAR 0 1
11733: PUSH
11734: LD_EXP 9
11738: EQUAL
11739: IFFALSE 11748
// YouLost ( JMM ) ;
11741: LD_STRING JMM
11743: PPUSH
11744: CALL_OW 104
// if GetType ( un ) = unit_building then
11748: LD_VAR 0 1
11752: PPUSH
11753: CALL_OW 247
11757: PUSH
11758: LD_INT 3
11760: EQUAL
11761: IFFALSE 11777
// buildings_counter := buildings_counter + 1 ;
11763: LD_ADDR_EXP 4
11767: PUSH
11768: LD_EXP 4
11772: PUSH
11773: LD_INT 1
11775: PLUS
11776: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11777: LD_VAR 0 1
11781: PUSH
11782: LD_INT 6
11784: PPUSH
11785: LD_INT 2
11787: PUSH
11788: LD_INT 30
11790: PUSH
11791: LD_INT 33
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 30
11800: PUSH
11801: LD_INT 32
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: LIST
11812: PPUSH
11813: CALL_OW 70
11817: IN
11818: IFFALSE 11877
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11820: LD_ADDR_EXP 20
11824: PUSH
11825: LD_EXP 20
11829: PUSH
11830: LD_VAR 0 1
11834: PPUSH
11835: CALL_OW 266
11839: PUSH
11840: LD_VAR 0 1
11844: PPUSH
11845: CALL_OW 250
11849: PUSH
11850: LD_VAR 0 1
11854: PPUSH
11855: CALL_OW 251
11859: PUSH
11860: LD_VAR 0 1
11864: PPUSH
11865: CALL_OW 254
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: ADD
11876: ST_TO_ADDR
// if un = ru_dep_main then
11877: LD_VAR 0 1
11881: PUSH
11882: LD_INT 16
11884: EQUAL
11885: IFFALSE 11894
// ChangeMissionObjectives ( M1a ) ;
11887: LD_STRING M1a
11889: PPUSH
11890: CALL_OW 337
// if GetType ( un ) = unit_human and GetSide ( un ) = 3 then
11894: LD_VAR 0 1
11898: PPUSH
11899: CALL_OW 247
11903: PUSH
11904: LD_INT 1
11906: EQUAL
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL_OW 255
11917: PUSH
11918: LD_INT 3
11920: EQUAL
11921: AND
11922: IFFALSE 11938
// kill_counter := kill_counter + 1 ;
11924: LD_ADDR_EXP 8
11928: PUSH
11929: LD_EXP 8
11933: PUSH
11934: LD_INT 1
11936: PLUS
11937: ST_TO_ADDR
// end ;
11938: PPOPN 1
11940: END
// on BuildingStarted ( b , builder ) do var i ;
11941: LD_INT 0
11943: PPUSH
// begin if GetSide ( b ) = 3 then
11944: LD_VAR 0 1
11948: PPUSH
11949: CALL_OW 255
11953: PUSH
11954: LD_INT 3
11956: EQUAL
11957: IFFALSE 11997
// for i = 1 to 4 do
11959: LD_ADDR_VAR 0 3
11963: PUSH
11964: DOUBLE
11965: LD_INT 1
11967: DEC
11968: ST_TO_ADDR
11969: LD_INT 4
11971: PUSH
11972: FOR_TO
11973: IFFALSE 11995
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11975: LD_ADDR_EXP 20
11979: PUSH
11980: LD_EXP 20
11984: PPUSH
11985: LD_INT 1
11987: PPUSH
11988: CALL_OW 3
11992: ST_TO_ADDR
11993: GO 11972
11995: POP
11996: POP
// end ;
11997: PPOPN 3
11999: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
12000: LD_VAR 0 1
12004: PPUSH
12005: CALL_OW 266
12009: PUSH
12010: LD_INT 32
12012: PUSH
12013: LD_INT 33
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: IN
12020: IFFALSE 12034
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
12022: LD_VAR 0 1
12026: PPUSH
12027: LD_INT 43
12029: PPUSH
12030: CALL_OW 148
12034: PPOPN 1
12036: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
12037: LD_VAR 0 1
12041: PUSH
12042: LD_INT 22
12044: PUSH
12045: LD_INT 3
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 2
12054: PUSH
12055: LD_INT 30
12057: PUSH
12058: LD_INT 31
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 30
12067: PUSH
12068: LD_INT 32
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PPUSH
12084: CALL_OW 69
12088: IN
12089: IFFALSE 12111
// GoToAnotherTower ( un , b , 143 , 143 ) ;
12091: LD_VAR 0 2
12095: PPUSH
12096: LD_VAR 0 1
12100: PPUSH
12101: LD_INT 143
12103: PPUSH
12104: LD_INT 143
12106: PPUSH
12107: CALL 2200 0 4
// end ;
12111: PPOPN 2
12113: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
12114: LD_VAR 0 1
12118: PUSH
12119: LD_INT 22
12121: PUSH
12122: LD_INT 3
12124: PUSH
12125: EMPTY
12126: LIST
12127: LIST
12128: PUSH
12129: LD_INT 30
12131: PUSH
12132: LD_INT 32
12134: PUSH
12135: EMPTY
12136: LIST
12137: LIST
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PPUSH
12143: CALL_OW 69
12147: IN
12148: IFFALSE 12162
// SetTag ( b , 0 ) ;
12150: LD_VAR 0 1
12154: PPUSH
12155: LD_INT 0
12157: PPUSH
12158: CALL_OW 109
// end ; end_of_file
12162: PPOPN 2
12164: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
12165: GO 12167
12167: DISABLE
// begin ru_radar := 98 ;
12168: LD_ADDR_EXP 21
12172: PUSH
12173: LD_INT 98
12175: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
12176: LD_ADDR_EXP 22
12180: PUSH
12181: LD_INT 89
12183: ST_TO_ADDR
// us_hack := 99 ;
12184: LD_ADDR_EXP 23
12188: PUSH
12189: LD_INT 99
12191: ST_TO_ADDR
// us_artillery := 97 ;
12192: LD_ADDR_EXP 24
12196: PUSH
12197: LD_INT 97
12199: ST_TO_ADDR
// ar_bio_bomb := 91 ;
12200: LD_ADDR_EXP 25
12204: PUSH
12205: LD_INT 91
12207: ST_TO_ADDR
// end ; end_of_file end_of_file
12208: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
12209: GO 12211
12211: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
12212: LD_STRING initStreamRollete();
12214: PPUSH
12215: CALL_OW 559
// InitStreamMode ;
12219: CALL 12228 0 0
// DefineStreamItems ( ) ;
12223: CALL 12668 0 0
// end ;
12227: END
// function InitStreamMode ; begin
12228: LD_INT 0
12230: PPUSH
// streamModeActive := false ;
12231: LD_ADDR_EXP 26
12235: PUSH
12236: LD_INT 0
12238: ST_TO_ADDR
// normalCounter := 36 ;
12239: LD_ADDR_EXP 27
12243: PUSH
12244: LD_INT 36
12246: ST_TO_ADDR
// hardcoreCounter := 16 ;
12247: LD_ADDR_EXP 28
12251: PUSH
12252: LD_INT 16
12254: ST_TO_ADDR
// sRocket := false ;
12255: LD_ADDR_EXP 31
12259: PUSH
12260: LD_INT 0
12262: ST_TO_ADDR
// sSpeed := false ;
12263: LD_ADDR_EXP 30
12267: PUSH
12268: LD_INT 0
12270: ST_TO_ADDR
// sEngine := false ;
12271: LD_ADDR_EXP 32
12275: PUSH
12276: LD_INT 0
12278: ST_TO_ADDR
// sSpec := false ;
12279: LD_ADDR_EXP 29
12283: PUSH
12284: LD_INT 0
12286: ST_TO_ADDR
// sLevel := false ;
12287: LD_ADDR_EXP 33
12291: PUSH
12292: LD_INT 0
12294: ST_TO_ADDR
// sArmoury := false ;
12295: LD_ADDR_EXP 34
12299: PUSH
12300: LD_INT 0
12302: ST_TO_ADDR
// sRadar := false ;
12303: LD_ADDR_EXP 35
12307: PUSH
12308: LD_INT 0
12310: ST_TO_ADDR
// sBunker := false ;
12311: LD_ADDR_EXP 36
12315: PUSH
12316: LD_INT 0
12318: ST_TO_ADDR
// sHack := false ;
12319: LD_ADDR_EXP 37
12323: PUSH
12324: LD_INT 0
12326: ST_TO_ADDR
// sFire := false ;
12327: LD_ADDR_EXP 38
12331: PUSH
12332: LD_INT 0
12334: ST_TO_ADDR
// sRefresh := false ;
12335: LD_ADDR_EXP 39
12339: PUSH
12340: LD_INT 0
12342: ST_TO_ADDR
// sExp := false ;
12343: LD_ADDR_EXP 40
12347: PUSH
12348: LD_INT 0
12350: ST_TO_ADDR
// sDepot := false ;
12351: LD_ADDR_EXP 41
12355: PUSH
12356: LD_INT 0
12358: ST_TO_ADDR
// sFlag := false ;
12359: LD_ADDR_EXP 42
12363: PUSH
12364: LD_INT 0
12366: ST_TO_ADDR
// sKamikadze := false ;
12367: LD_ADDR_EXP 50
12371: PUSH
12372: LD_INT 0
12374: ST_TO_ADDR
// sTroll := false ;
12375: LD_ADDR_EXP 51
12379: PUSH
12380: LD_INT 0
12382: ST_TO_ADDR
// sSlow := false ;
12383: LD_ADDR_EXP 52
12387: PUSH
12388: LD_INT 0
12390: ST_TO_ADDR
// sLack := false ;
12391: LD_ADDR_EXP 53
12395: PUSH
12396: LD_INT 0
12398: ST_TO_ADDR
// sTank := false ;
12399: LD_ADDR_EXP 55
12403: PUSH
12404: LD_INT 0
12406: ST_TO_ADDR
// sRemote := false ;
12407: LD_ADDR_EXP 56
12411: PUSH
12412: LD_INT 0
12414: ST_TO_ADDR
// sPowell := false ;
12415: LD_ADDR_EXP 57
12419: PUSH
12420: LD_INT 0
12422: ST_TO_ADDR
// sTeleport := false ;
12423: LD_ADDR_EXP 60
12427: PUSH
12428: LD_INT 0
12430: ST_TO_ADDR
// sOilTower := false ;
12431: LD_ADDR_EXP 62
12435: PUSH
12436: LD_INT 0
12438: ST_TO_ADDR
// sShovel := false ;
12439: LD_ADDR_EXP 63
12443: PUSH
12444: LD_INT 0
12446: ST_TO_ADDR
// sSheik := false ;
12447: LD_ADDR_EXP 64
12451: PUSH
12452: LD_INT 0
12454: ST_TO_ADDR
// sEarthquake := false ;
12455: LD_ADDR_EXP 66
12459: PUSH
12460: LD_INT 0
12462: ST_TO_ADDR
// sAI := false ;
12463: LD_ADDR_EXP 67
12467: PUSH
12468: LD_INT 0
12470: ST_TO_ADDR
// sCargo := false ;
12471: LD_ADDR_EXP 70
12475: PUSH
12476: LD_INT 0
12478: ST_TO_ADDR
// sDLaser := false ;
12479: LD_ADDR_EXP 71
12483: PUSH
12484: LD_INT 0
12486: ST_TO_ADDR
// sExchange := false ;
12487: LD_ADDR_EXP 72
12491: PUSH
12492: LD_INT 0
12494: ST_TO_ADDR
// sFac := false ;
12495: LD_ADDR_EXP 73
12499: PUSH
12500: LD_INT 0
12502: ST_TO_ADDR
// sPower := false ;
12503: LD_ADDR_EXP 74
12507: PUSH
12508: LD_INT 0
12510: ST_TO_ADDR
// sRandom := false ;
12511: LD_ADDR_EXP 75
12515: PUSH
12516: LD_INT 0
12518: ST_TO_ADDR
// sShield := false ;
12519: LD_ADDR_EXP 76
12523: PUSH
12524: LD_INT 0
12526: ST_TO_ADDR
// sTime := false ;
12527: LD_ADDR_EXP 77
12531: PUSH
12532: LD_INT 0
12534: ST_TO_ADDR
// sTools := false ;
12535: LD_ADDR_EXP 78
12539: PUSH
12540: LD_INT 0
12542: ST_TO_ADDR
// sSold := false ;
12543: LD_ADDR_EXP 43
12547: PUSH
12548: LD_INT 0
12550: ST_TO_ADDR
// sDiff := false ;
12551: LD_ADDR_EXP 44
12555: PUSH
12556: LD_INT 0
12558: ST_TO_ADDR
// sFog := false ;
12559: LD_ADDR_EXP 47
12563: PUSH
12564: LD_INT 0
12566: ST_TO_ADDR
// sReset := false ;
12567: LD_ADDR_EXP 48
12571: PUSH
12572: LD_INT 0
12574: ST_TO_ADDR
// sSun := false ;
12575: LD_ADDR_EXP 49
12579: PUSH
12580: LD_INT 0
12582: ST_TO_ADDR
// sTiger := false ;
12583: LD_ADDR_EXP 45
12587: PUSH
12588: LD_INT 0
12590: ST_TO_ADDR
// sBomb := false ;
12591: LD_ADDR_EXP 46
12595: PUSH
12596: LD_INT 0
12598: ST_TO_ADDR
// sWound := false ;
12599: LD_ADDR_EXP 54
12603: PUSH
12604: LD_INT 0
12606: ST_TO_ADDR
// sBetray := false ;
12607: LD_ADDR_EXP 58
12611: PUSH
12612: LD_INT 0
12614: ST_TO_ADDR
// sContamin := false ;
12615: LD_ADDR_EXP 59
12619: PUSH
12620: LD_INT 0
12622: ST_TO_ADDR
// sOil := false ;
12623: LD_ADDR_EXP 61
12627: PUSH
12628: LD_INT 0
12630: ST_TO_ADDR
// sStu := false ;
12631: LD_ADDR_EXP 65
12635: PUSH
12636: LD_INT 0
12638: ST_TO_ADDR
// sBazooka := false ;
12639: LD_ADDR_EXP 68
12643: PUSH
12644: LD_INT 0
12646: ST_TO_ADDR
// sMortar := false ;
12647: LD_ADDR_EXP 69
12651: PUSH
12652: LD_INT 0
12654: ST_TO_ADDR
// sRanger := false ;
12655: LD_ADDR_EXP 79
12659: PUSH
12660: LD_INT 0
12662: ST_TO_ADDR
// end ;
12663: LD_VAR 0 1
12667: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12668: LD_INT 0
12670: PPUSH
12671: PPUSH
12672: PPUSH
12673: PPUSH
12674: PPUSH
// result := [ ] ;
12675: LD_ADDR_VAR 0 1
12679: PUSH
12680: EMPTY
12681: ST_TO_ADDR
// if campaign_id = 1 then
12682: LD_OWVAR 69
12686: PUSH
12687: LD_INT 1
12689: EQUAL
12690: IFFALSE 15628
// begin case mission_number of 1 :
12692: LD_OWVAR 70
12696: PUSH
12697: LD_INT 1
12699: DOUBLE
12700: EQUAL
12701: IFTRUE 12705
12703: GO 12769
12705: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12706: LD_ADDR_VAR 0 1
12710: PUSH
12711: LD_INT 2
12713: PUSH
12714: LD_INT 4
12716: PUSH
12717: LD_INT 11
12719: PUSH
12720: LD_INT 12
12722: PUSH
12723: LD_INT 15
12725: PUSH
12726: LD_INT 16
12728: PUSH
12729: LD_INT 22
12731: PUSH
12732: LD_INT 23
12734: PUSH
12735: LD_INT 26
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: PUSH
12749: LD_INT 101
12751: PUSH
12752: LD_INT 102
12754: PUSH
12755: LD_INT 106
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: LIST
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: ST_TO_ADDR
12767: GO 15626
12769: LD_INT 2
12771: DOUBLE
12772: EQUAL
12773: IFTRUE 12777
12775: GO 12849
12777: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12778: LD_ADDR_VAR 0 1
12782: PUSH
12783: LD_INT 2
12785: PUSH
12786: LD_INT 4
12788: PUSH
12789: LD_INT 11
12791: PUSH
12792: LD_INT 12
12794: PUSH
12795: LD_INT 15
12797: PUSH
12798: LD_INT 16
12800: PUSH
12801: LD_INT 22
12803: PUSH
12804: LD_INT 23
12806: PUSH
12807: LD_INT 26
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PUSH
12821: LD_INT 101
12823: PUSH
12824: LD_INT 102
12826: PUSH
12827: LD_INT 105
12829: PUSH
12830: LD_INT 106
12832: PUSH
12833: LD_INT 108
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: ST_TO_ADDR
12847: GO 15626
12849: LD_INT 3
12851: DOUBLE
12852: EQUAL
12853: IFTRUE 12857
12855: GO 12933
12857: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12858: LD_ADDR_VAR 0 1
12862: PUSH
12863: LD_INT 2
12865: PUSH
12866: LD_INT 4
12868: PUSH
12869: LD_INT 5
12871: PUSH
12872: LD_INT 11
12874: PUSH
12875: LD_INT 12
12877: PUSH
12878: LD_INT 15
12880: PUSH
12881: LD_INT 16
12883: PUSH
12884: LD_INT 22
12886: PUSH
12887: LD_INT 26
12889: PUSH
12890: LD_INT 36
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: LIST
12897: LIST
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: LIST
12903: LIST
12904: PUSH
12905: LD_INT 101
12907: PUSH
12908: LD_INT 102
12910: PUSH
12911: LD_INT 105
12913: PUSH
12914: LD_INT 106
12916: PUSH
12917: LD_INT 108
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: ST_TO_ADDR
12931: GO 15626
12933: LD_INT 4
12935: DOUBLE
12936: EQUAL
12937: IFTRUE 12941
12939: GO 13025
12941: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12942: LD_ADDR_VAR 0 1
12946: PUSH
12947: LD_INT 2
12949: PUSH
12950: LD_INT 4
12952: PUSH
12953: LD_INT 5
12955: PUSH
12956: LD_INT 8
12958: PUSH
12959: LD_INT 11
12961: PUSH
12962: LD_INT 12
12964: PUSH
12965: LD_INT 15
12967: PUSH
12968: LD_INT 16
12970: PUSH
12971: LD_INT 22
12973: PUSH
12974: LD_INT 23
12976: PUSH
12977: LD_INT 26
12979: PUSH
12980: LD_INT 36
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: LIST
12993: LIST
12994: LIST
12995: LIST
12996: PUSH
12997: LD_INT 101
12999: PUSH
13000: LD_INT 102
13002: PUSH
13003: LD_INT 105
13005: PUSH
13006: LD_INT 106
13008: PUSH
13009: LD_INT 108
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: ST_TO_ADDR
13023: GO 15626
13025: LD_INT 5
13027: DOUBLE
13028: EQUAL
13029: IFTRUE 13033
13031: GO 13133
13033: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
13034: LD_ADDR_VAR 0 1
13038: PUSH
13039: LD_INT 2
13041: PUSH
13042: LD_INT 4
13044: PUSH
13045: LD_INT 5
13047: PUSH
13048: LD_INT 6
13050: PUSH
13051: LD_INT 8
13053: PUSH
13054: LD_INT 11
13056: PUSH
13057: LD_INT 12
13059: PUSH
13060: LD_INT 15
13062: PUSH
13063: LD_INT 16
13065: PUSH
13066: LD_INT 22
13068: PUSH
13069: LD_INT 23
13071: PUSH
13072: LD_INT 25
13074: PUSH
13075: LD_INT 26
13077: PUSH
13078: LD_INT 36
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: PUSH
13097: LD_INT 101
13099: PUSH
13100: LD_INT 102
13102: PUSH
13103: LD_INT 105
13105: PUSH
13106: LD_INT 106
13108: PUSH
13109: LD_INT 108
13111: PUSH
13112: LD_INT 109
13114: PUSH
13115: LD_INT 112
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: EMPTY
13128: LIST
13129: LIST
13130: ST_TO_ADDR
13131: GO 15626
13133: LD_INT 6
13135: DOUBLE
13136: EQUAL
13137: IFTRUE 13141
13139: GO 13261
13141: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
13142: LD_ADDR_VAR 0 1
13146: PUSH
13147: LD_INT 2
13149: PUSH
13150: LD_INT 4
13152: PUSH
13153: LD_INT 5
13155: PUSH
13156: LD_INT 6
13158: PUSH
13159: LD_INT 8
13161: PUSH
13162: LD_INT 11
13164: PUSH
13165: LD_INT 12
13167: PUSH
13168: LD_INT 15
13170: PUSH
13171: LD_INT 16
13173: PUSH
13174: LD_INT 20
13176: PUSH
13177: LD_INT 21
13179: PUSH
13180: LD_INT 22
13182: PUSH
13183: LD_INT 23
13185: PUSH
13186: LD_INT 25
13188: PUSH
13189: LD_INT 26
13191: PUSH
13192: LD_INT 30
13194: PUSH
13195: LD_INT 31
13197: PUSH
13198: LD_INT 32
13200: PUSH
13201: LD_INT 36
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PUSH
13225: LD_INT 101
13227: PUSH
13228: LD_INT 102
13230: PUSH
13231: LD_INT 105
13233: PUSH
13234: LD_INT 106
13236: PUSH
13237: LD_INT 108
13239: PUSH
13240: LD_INT 109
13242: PUSH
13243: LD_INT 112
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: ST_TO_ADDR
13259: GO 15626
13261: LD_INT 7
13263: DOUBLE
13264: EQUAL
13265: IFTRUE 13269
13267: GO 13369
13269: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
13270: LD_ADDR_VAR 0 1
13274: PUSH
13275: LD_INT 2
13277: PUSH
13278: LD_INT 4
13280: PUSH
13281: LD_INT 5
13283: PUSH
13284: LD_INT 7
13286: PUSH
13287: LD_INT 11
13289: PUSH
13290: LD_INT 12
13292: PUSH
13293: LD_INT 15
13295: PUSH
13296: LD_INT 16
13298: PUSH
13299: LD_INT 20
13301: PUSH
13302: LD_INT 21
13304: PUSH
13305: LD_INT 22
13307: PUSH
13308: LD_INT 23
13310: PUSH
13311: LD_INT 25
13313: PUSH
13314: LD_INT 26
13316: PUSH
13317: EMPTY
13318: LIST
13319: LIST
13320: LIST
13321: LIST
13322: LIST
13323: LIST
13324: LIST
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: LD_INT 101
13335: PUSH
13336: LD_INT 102
13338: PUSH
13339: LD_INT 103
13341: PUSH
13342: LD_INT 105
13344: PUSH
13345: LD_INT 106
13347: PUSH
13348: LD_INT 108
13350: PUSH
13351: LD_INT 112
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: LIST
13358: LIST
13359: LIST
13360: LIST
13361: LIST
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: ST_TO_ADDR
13367: GO 15626
13369: LD_INT 8
13371: DOUBLE
13372: EQUAL
13373: IFTRUE 13377
13375: GO 13505
13377: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13378: LD_ADDR_VAR 0 1
13382: PUSH
13383: LD_INT 2
13385: PUSH
13386: LD_INT 4
13388: PUSH
13389: LD_INT 5
13391: PUSH
13392: LD_INT 6
13394: PUSH
13395: LD_INT 7
13397: PUSH
13398: LD_INT 8
13400: PUSH
13401: LD_INT 11
13403: PUSH
13404: LD_INT 12
13406: PUSH
13407: LD_INT 15
13409: PUSH
13410: LD_INT 16
13412: PUSH
13413: LD_INT 20
13415: PUSH
13416: LD_INT 21
13418: PUSH
13419: LD_INT 22
13421: PUSH
13422: LD_INT 23
13424: PUSH
13425: LD_INT 25
13427: PUSH
13428: LD_INT 26
13430: PUSH
13431: LD_INT 30
13433: PUSH
13434: LD_INT 31
13436: PUSH
13437: LD_INT 32
13439: PUSH
13440: LD_INT 36
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: LIST
13463: LIST
13464: PUSH
13465: LD_INT 101
13467: PUSH
13468: LD_INT 102
13470: PUSH
13471: LD_INT 103
13473: PUSH
13474: LD_INT 105
13476: PUSH
13477: LD_INT 106
13479: PUSH
13480: LD_INT 108
13482: PUSH
13483: LD_INT 109
13485: PUSH
13486: LD_INT 112
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: LIST
13497: LIST
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: ST_TO_ADDR
13503: GO 15626
13505: LD_INT 9
13507: DOUBLE
13508: EQUAL
13509: IFTRUE 13513
13511: GO 13649
13513: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13514: LD_ADDR_VAR 0 1
13518: PUSH
13519: LD_INT 2
13521: PUSH
13522: LD_INT 4
13524: PUSH
13525: LD_INT 5
13527: PUSH
13528: LD_INT 6
13530: PUSH
13531: LD_INT 7
13533: PUSH
13534: LD_INT 8
13536: PUSH
13537: LD_INT 11
13539: PUSH
13540: LD_INT 12
13542: PUSH
13543: LD_INT 15
13545: PUSH
13546: LD_INT 16
13548: PUSH
13549: LD_INT 20
13551: PUSH
13552: LD_INT 21
13554: PUSH
13555: LD_INT 22
13557: PUSH
13558: LD_INT 23
13560: PUSH
13561: LD_INT 25
13563: PUSH
13564: LD_INT 26
13566: PUSH
13567: LD_INT 28
13569: PUSH
13570: LD_INT 30
13572: PUSH
13573: LD_INT 31
13575: PUSH
13576: LD_INT 32
13578: PUSH
13579: LD_INT 36
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 101
13607: PUSH
13608: LD_INT 102
13610: PUSH
13611: LD_INT 103
13613: PUSH
13614: LD_INT 105
13616: PUSH
13617: LD_INT 106
13619: PUSH
13620: LD_INT 108
13622: PUSH
13623: LD_INT 109
13625: PUSH
13626: LD_INT 112
13628: PUSH
13629: LD_INT 114
13631: PUSH
13632: EMPTY
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: ST_TO_ADDR
13647: GO 15626
13649: LD_INT 10
13651: DOUBLE
13652: EQUAL
13653: IFTRUE 13657
13655: GO 13841
13657: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13658: LD_ADDR_VAR 0 1
13662: PUSH
13663: LD_INT 2
13665: PUSH
13666: LD_INT 4
13668: PUSH
13669: LD_INT 5
13671: PUSH
13672: LD_INT 6
13674: PUSH
13675: LD_INT 7
13677: PUSH
13678: LD_INT 8
13680: PUSH
13681: LD_INT 9
13683: PUSH
13684: LD_INT 10
13686: PUSH
13687: LD_INT 11
13689: PUSH
13690: LD_INT 12
13692: PUSH
13693: LD_INT 13
13695: PUSH
13696: LD_INT 14
13698: PUSH
13699: LD_INT 15
13701: PUSH
13702: LD_INT 16
13704: PUSH
13705: LD_INT 17
13707: PUSH
13708: LD_INT 18
13710: PUSH
13711: LD_INT 19
13713: PUSH
13714: LD_INT 20
13716: PUSH
13717: LD_INT 21
13719: PUSH
13720: LD_INT 22
13722: PUSH
13723: LD_INT 23
13725: PUSH
13726: LD_INT 24
13728: PUSH
13729: LD_INT 25
13731: PUSH
13732: LD_INT 26
13734: PUSH
13735: LD_INT 28
13737: PUSH
13738: LD_INT 30
13740: PUSH
13741: LD_INT 31
13743: PUSH
13744: LD_INT 32
13746: PUSH
13747: LD_INT 36
13749: PUSH
13750: EMPTY
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: PUSH
13781: LD_INT 101
13783: PUSH
13784: LD_INT 102
13786: PUSH
13787: LD_INT 103
13789: PUSH
13790: LD_INT 104
13792: PUSH
13793: LD_INT 105
13795: PUSH
13796: LD_INT 106
13798: PUSH
13799: LD_INT 107
13801: PUSH
13802: LD_INT 108
13804: PUSH
13805: LD_INT 109
13807: PUSH
13808: LD_INT 110
13810: PUSH
13811: LD_INT 111
13813: PUSH
13814: LD_INT 112
13816: PUSH
13817: LD_INT 114
13819: PUSH
13820: EMPTY
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: LIST
13830: LIST
13831: LIST
13832: LIST
13833: LIST
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: ST_TO_ADDR
13839: GO 15626
13841: LD_INT 11
13843: DOUBLE
13844: EQUAL
13845: IFTRUE 13849
13847: GO 14041
13849: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13850: LD_ADDR_VAR 0 1
13854: PUSH
13855: LD_INT 2
13857: PUSH
13858: LD_INT 3
13860: PUSH
13861: LD_INT 4
13863: PUSH
13864: LD_INT 5
13866: PUSH
13867: LD_INT 6
13869: PUSH
13870: LD_INT 7
13872: PUSH
13873: LD_INT 8
13875: PUSH
13876: LD_INT 9
13878: PUSH
13879: LD_INT 10
13881: PUSH
13882: LD_INT 11
13884: PUSH
13885: LD_INT 12
13887: PUSH
13888: LD_INT 13
13890: PUSH
13891: LD_INT 14
13893: PUSH
13894: LD_INT 15
13896: PUSH
13897: LD_INT 16
13899: PUSH
13900: LD_INT 17
13902: PUSH
13903: LD_INT 18
13905: PUSH
13906: LD_INT 19
13908: PUSH
13909: LD_INT 20
13911: PUSH
13912: LD_INT 21
13914: PUSH
13915: LD_INT 22
13917: PUSH
13918: LD_INT 23
13920: PUSH
13921: LD_INT 24
13923: PUSH
13924: LD_INT 25
13926: PUSH
13927: LD_INT 26
13929: PUSH
13930: LD_INT 28
13932: PUSH
13933: LD_INT 30
13935: PUSH
13936: LD_INT 31
13938: PUSH
13939: LD_INT 32
13941: PUSH
13942: LD_INT 34
13944: PUSH
13945: LD_INT 36
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: PUSH
13981: LD_INT 101
13983: PUSH
13984: LD_INT 102
13986: PUSH
13987: LD_INT 103
13989: PUSH
13990: LD_INT 104
13992: PUSH
13993: LD_INT 105
13995: PUSH
13996: LD_INT 106
13998: PUSH
13999: LD_INT 107
14001: PUSH
14002: LD_INT 108
14004: PUSH
14005: LD_INT 109
14007: PUSH
14008: LD_INT 110
14010: PUSH
14011: LD_INT 111
14013: PUSH
14014: LD_INT 112
14016: PUSH
14017: LD_INT 114
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: ST_TO_ADDR
14039: GO 15626
14041: LD_INT 12
14043: DOUBLE
14044: EQUAL
14045: IFTRUE 14049
14047: GO 14257
14049: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
14050: LD_ADDR_VAR 0 1
14054: PUSH
14055: LD_INT 1
14057: PUSH
14058: LD_INT 2
14060: PUSH
14061: LD_INT 3
14063: PUSH
14064: LD_INT 4
14066: PUSH
14067: LD_INT 5
14069: PUSH
14070: LD_INT 6
14072: PUSH
14073: LD_INT 7
14075: PUSH
14076: LD_INT 8
14078: PUSH
14079: LD_INT 9
14081: PUSH
14082: LD_INT 10
14084: PUSH
14085: LD_INT 11
14087: PUSH
14088: LD_INT 12
14090: PUSH
14091: LD_INT 13
14093: PUSH
14094: LD_INT 14
14096: PUSH
14097: LD_INT 15
14099: PUSH
14100: LD_INT 16
14102: PUSH
14103: LD_INT 17
14105: PUSH
14106: LD_INT 18
14108: PUSH
14109: LD_INT 19
14111: PUSH
14112: LD_INT 20
14114: PUSH
14115: LD_INT 21
14117: PUSH
14118: LD_INT 22
14120: PUSH
14121: LD_INT 23
14123: PUSH
14124: LD_INT 24
14126: PUSH
14127: LD_INT 25
14129: PUSH
14130: LD_INT 26
14132: PUSH
14133: LD_INT 27
14135: PUSH
14136: LD_INT 28
14138: PUSH
14139: LD_INT 30
14141: PUSH
14142: LD_INT 31
14144: PUSH
14145: LD_INT 32
14147: PUSH
14148: LD_INT 33
14150: PUSH
14151: LD_INT 34
14153: PUSH
14154: LD_INT 36
14156: PUSH
14157: EMPTY
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: LIST
14192: PUSH
14193: LD_INT 101
14195: PUSH
14196: LD_INT 102
14198: PUSH
14199: LD_INT 103
14201: PUSH
14202: LD_INT 104
14204: PUSH
14205: LD_INT 105
14207: PUSH
14208: LD_INT 106
14210: PUSH
14211: LD_INT 107
14213: PUSH
14214: LD_INT 108
14216: PUSH
14217: LD_INT 109
14219: PUSH
14220: LD_INT 110
14222: PUSH
14223: LD_INT 111
14225: PUSH
14226: LD_INT 112
14228: PUSH
14229: LD_INT 113
14231: PUSH
14232: LD_INT 114
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: LIST
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: ST_TO_ADDR
14255: GO 15626
14257: LD_INT 13
14259: DOUBLE
14260: EQUAL
14261: IFTRUE 14265
14263: GO 14461
14265: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
14266: LD_ADDR_VAR 0 1
14270: PUSH
14271: LD_INT 1
14273: PUSH
14274: LD_INT 2
14276: PUSH
14277: LD_INT 3
14279: PUSH
14280: LD_INT 4
14282: PUSH
14283: LD_INT 5
14285: PUSH
14286: LD_INT 8
14288: PUSH
14289: LD_INT 9
14291: PUSH
14292: LD_INT 10
14294: PUSH
14295: LD_INT 11
14297: PUSH
14298: LD_INT 12
14300: PUSH
14301: LD_INT 14
14303: PUSH
14304: LD_INT 15
14306: PUSH
14307: LD_INT 16
14309: PUSH
14310: LD_INT 17
14312: PUSH
14313: LD_INT 18
14315: PUSH
14316: LD_INT 19
14318: PUSH
14319: LD_INT 20
14321: PUSH
14322: LD_INT 21
14324: PUSH
14325: LD_INT 22
14327: PUSH
14328: LD_INT 23
14330: PUSH
14331: LD_INT 24
14333: PUSH
14334: LD_INT 25
14336: PUSH
14337: LD_INT 26
14339: PUSH
14340: LD_INT 27
14342: PUSH
14343: LD_INT 28
14345: PUSH
14346: LD_INT 30
14348: PUSH
14349: LD_INT 31
14351: PUSH
14352: LD_INT 32
14354: PUSH
14355: LD_INT 33
14357: PUSH
14358: LD_INT 34
14360: PUSH
14361: LD_INT 36
14363: PUSH
14364: EMPTY
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: PUSH
14397: LD_INT 101
14399: PUSH
14400: LD_INT 102
14402: PUSH
14403: LD_INT 103
14405: PUSH
14406: LD_INT 104
14408: PUSH
14409: LD_INT 105
14411: PUSH
14412: LD_INT 106
14414: PUSH
14415: LD_INT 107
14417: PUSH
14418: LD_INT 108
14420: PUSH
14421: LD_INT 109
14423: PUSH
14424: LD_INT 110
14426: PUSH
14427: LD_INT 111
14429: PUSH
14430: LD_INT 112
14432: PUSH
14433: LD_INT 113
14435: PUSH
14436: LD_INT 114
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: LIST
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: ST_TO_ADDR
14459: GO 15626
14461: LD_INT 14
14463: DOUBLE
14464: EQUAL
14465: IFTRUE 14469
14467: GO 14681
14469: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14470: LD_ADDR_VAR 0 1
14474: PUSH
14475: LD_INT 1
14477: PUSH
14478: LD_INT 2
14480: PUSH
14481: LD_INT 3
14483: PUSH
14484: LD_INT 4
14486: PUSH
14487: LD_INT 5
14489: PUSH
14490: LD_INT 6
14492: PUSH
14493: LD_INT 7
14495: PUSH
14496: LD_INT 8
14498: PUSH
14499: LD_INT 9
14501: PUSH
14502: LD_INT 10
14504: PUSH
14505: LD_INT 11
14507: PUSH
14508: LD_INT 12
14510: PUSH
14511: LD_INT 13
14513: PUSH
14514: LD_INT 14
14516: PUSH
14517: LD_INT 15
14519: PUSH
14520: LD_INT 16
14522: PUSH
14523: LD_INT 17
14525: PUSH
14526: LD_INT 18
14528: PUSH
14529: LD_INT 19
14531: PUSH
14532: LD_INT 20
14534: PUSH
14535: LD_INT 21
14537: PUSH
14538: LD_INT 22
14540: PUSH
14541: LD_INT 23
14543: PUSH
14544: LD_INT 24
14546: PUSH
14547: LD_INT 25
14549: PUSH
14550: LD_INT 26
14552: PUSH
14553: LD_INT 27
14555: PUSH
14556: LD_INT 28
14558: PUSH
14559: LD_INT 29
14561: PUSH
14562: LD_INT 30
14564: PUSH
14565: LD_INT 31
14567: PUSH
14568: LD_INT 32
14570: PUSH
14571: LD_INT 33
14573: PUSH
14574: LD_INT 34
14576: PUSH
14577: LD_INT 36
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: PUSH
14617: LD_INT 101
14619: PUSH
14620: LD_INT 102
14622: PUSH
14623: LD_INT 103
14625: PUSH
14626: LD_INT 104
14628: PUSH
14629: LD_INT 105
14631: PUSH
14632: LD_INT 106
14634: PUSH
14635: LD_INT 107
14637: PUSH
14638: LD_INT 108
14640: PUSH
14641: LD_INT 109
14643: PUSH
14644: LD_INT 110
14646: PUSH
14647: LD_INT 111
14649: PUSH
14650: LD_INT 112
14652: PUSH
14653: LD_INT 113
14655: PUSH
14656: LD_INT 114
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: PUSH
14675: EMPTY
14676: LIST
14677: LIST
14678: ST_TO_ADDR
14679: GO 15626
14681: LD_INT 15
14683: DOUBLE
14684: EQUAL
14685: IFTRUE 14689
14687: GO 14901
14689: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14690: LD_ADDR_VAR 0 1
14694: PUSH
14695: LD_INT 1
14697: PUSH
14698: LD_INT 2
14700: PUSH
14701: LD_INT 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: LD_INT 6
14712: PUSH
14713: LD_INT 7
14715: PUSH
14716: LD_INT 8
14718: PUSH
14719: LD_INT 9
14721: PUSH
14722: LD_INT 10
14724: PUSH
14725: LD_INT 11
14727: PUSH
14728: LD_INT 12
14730: PUSH
14731: LD_INT 13
14733: PUSH
14734: LD_INT 14
14736: PUSH
14737: LD_INT 15
14739: PUSH
14740: LD_INT 16
14742: PUSH
14743: LD_INT 17
14745: PUSH
14746: LD_INT 18
14748: PUSH
14749: LD_INT 19
14751: PUSH
14752: LD_INT 20
14754: PUSH
14755: LD_INT 21
14757: PUSH
14758: LD_INT 22
14760: PUSH
14761: LD_INT 23
14763: PUSH
14764: LD_INT 24
14766: PUSH
14767: LD_INT 25
14769: PUSH
14770: LD_INT 26
14772: PUSH
14773: LD_INT 27
14775: PUSH
14776: LD_INT 28
14778: PUSH
14779: LD_INT 29
14781: PUSH
14782: LD_INT 30
14784: PUSH
14785: LD_INT 31
14787: PUSH
14788: LD_INT 32
14790: PUSH
14791: LD_INT 33
14793: PUSH
14794: LD_INT 34
14796: PUSH
14797: LD_INT 36
14799: PUSH
14800: EMPTY
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: PUSH
14837: LD_INT 101
14839: PUSH
14840: LD_INT 102
14842: PUSH
14843: LD_INT 103
14845: PUSH
14846: LD_INT 104
14848: PUSH
14849: LD_INT 105
14851: PUSH
14852: LD_INT 106
14854: PUSH
14855: LD_INT 107
14857: PUSH
14858: LD_INT 108
14860: PUSH
14861: LD_INT 109
14863: PUSH
14864: LD_INT 110
14866: PUSH
14867: LD_INT 111
14869: PUSH
14870: LD_INT 112
14872: PUSH
14873: LD_INT 113
14875: PUSH
14876: LD_INT 114
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: LIST
14885: LIST
14886: LIST
14887: LIST
14888: LIST
14889: LIST
14890: LIST
14891: LIST
14892: LIST
14893: LIST
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: ST_TO_ADDR
14899: GO 15626
14901: LD_INT 16
14903: DOUBLE
14904: EQUAL
14905: IFTRUE 14909
14907: GO 15033
14909: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14910: LD_ADDR_VAR 0 1
14914: PUSH
14915: LD_INT 2
14917: PUSH
14918: LD_INT 4
14920: PUSH
14921: LD_INT 5
14923: PUSH
14924: LD_INT 7
14926: PUSH
14927: LD_INT 11
14929: PUSH
14930: LD_INT 12
14932: PUSH
14933: LD_INT 15
14935: PUSH
14936: LD_INT 16
14938: PUSH
14939: LD_INT 20
14941: PUSH
14942: LD_INT 21
14944: PUSH
14945: LD_INT 22
14947: PUSH
14948: LD_INT 23
14950: PUSH
14951: LD_INT 25
14953: PUSH
14954: LD_INT 26
14956: PUSH
14957: LD_INT 30
14959: PUSH
14960: LD_INT 31
14962: PUSH
14963: LD_INT 32
14965: PUSH
14966: LD_INT 33
14968: PUSH
14969: LD_INT 34
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: LIST
14976: LIST
14977: LIST
14978: LIST
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: LIST
14984: LIST
14985: LIST
14986: LIST
14987: LIST
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: PUSH
14993: LD_INT 101
14995: PUSH
14996: LD_INT 102
14998: PUSH
14999: LD_INT 103
15001: PUSH
15002: LD_INT 106
15004: PUSH
15005: LD_INT 108
15007: PUSH
15008: LD_INT 112
15010: PUSH
15011: LD_INT 113
15013: PUSH
15014: LD_INT 114
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: ST_TO_ADDR
15031: GO 15626
15033: LD_INT 17
15035: DOUBLE
15036: EQUAL
15037: IFTRUE 15041
15039: GO 15253
15041: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
15042: LD_ADDR_VAR 0 1
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: LD_INT 2
15052: PUSH
15053: LD_INT 3
15055: PUSH
15056: LD_INT 4
15058: PUSH
15059: LD_INT 5
15061: PUSH
15062: LD_INT 6
15064: PUSH
15065: LD_INT 7
15067: PUSH
15068: LD_INT 8
15070: PUSH
15071: LD_INT 9
15073: PUSH
15074: LD_INT 10
15076: PUSH
15077: LD_INT 11
15079: PUSH
15080: LD_INT 12
15082: PUSH
15083: LD_INT 13
15085: PUSH
15086: LD_INT 14
15088: PUSH
15089: LD_INT 15
15091: PUSH
15092: LD_INT 16
15094: PUSH
15095: LD_INT 17
15097: PUSH
15098: LD_INT 18
15100: PUSH
15101: LD_INT 19
15103: PUSH
15104: LD_INT 20
15106: PUSH
15107: LD_INT 21
15109: PUSH
15110: LD_INT 22
15112: PUSH
15113: LD_INT 23
15115: PUSH
15116: LD_INT 24
15118: PUSH
15119: LD_INT 25
15121: PUSH
15122: LD_INT 26
15124: PUSH
15125: LD_INT 27
15127: PUSH
15128: LD_INT 28
15130: PUSH
15131: LD_INT 29
15133: PUSH
15134: LD_INT 30
15136: PUSH
15137: LD_INT 31
15139: PUSH
15140: LD_INT 32
15142: PUSH
15143: LD_INT 33
15145: PUSH
15146: LD_INT 34
15148: PUSH
15149: LD_INT 36
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: LIST
15173: LIST
15174: LIST
15175: LIST
15176: LIST
15177: LIST
15178: LIST
15179: LIST
15180: LIST
15181: LIST
15182: LIST
15183: LIST
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: PUSH
15189: LD_INT 101
15191: PUSH
15192: LD_INT 102
15194: PUSH
15195: LD_INT 103
15197: PUSH
15198: LD_INT 104
15200: PUSH
15201: LD_INT 105
15203: PUSH
15204: LD_INT 106
15206: PUSH
15207: LD_INT 107
15209: PUSH
15210: LD_INT 108
15212: PUSH
15213: LD_INT 109
15215: PUSH
15216: LD_INT 110
15218: PUSH
15219: LD_INT 111
15221: PUSH
15222: LD_INT 112
15224: PUSH
15225: LD_INT 113
15227: PUSH
15228: LD_INT 114
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: ST_TO_ADDR
15251: GO 15626
15253: LD_INT 18
15255: DOUBLE
15256: EQUAL
15257: IFTRUE 15261
15259: GO 15397
15261: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
15262: LD_ADDR_VAR 0 1
15266: PUSH
15267: LD_INT 2
15269: PUSH
15270: LD_INT 4
15272: PUSH
15273: LD_INT 5
15275: PUSH
15276: LD_INT 7
15278: PUSH
15279: LD_INT 11
15281: PUSH
15282: LD_INT 12
15284: PUSH
15285: LD_INT 15
15287: PUSH
15288: LD_INT 16
15290: PUSH
15291: LD_INT 20
15293: PUSH
15294: LD_INT 21
15296: PUSH
15297: LD_INT 22
15299: PUSH
15300: LD_INT 23
15302: PUSH
15303: LD_INT 25
15305: PUSH
15306: LD_INT 26
15308: PUSH
15309: LD_INT 30
15311: PUSH
15312: LD_INT 31
15314: PUSH
15315: LD_INT 32
15317: PUSH
15318: LD_INT 33
15320: PUSH
15321: LD_INT 34
15323: PUSH
15324: LD_INT 35
15326: PUSH
15327: LD_INT 36
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: LIST
15347: LIST
15348: LIST
15349: LIST
15350: LIST
15351: LIST
15352: PUSH
15353: LD_INT 101
15355: PUSH
15356: LD_INT 102
15358: PUSH
15359: LD_INT 103
15361: PUSH
15362: LD_INT 106
15364: PUSH
15365: LD_INT 108
15367: PUSH
15368: LD_INT 112
15370: PUSH
15371: LD_INT 113
15373: PUSH
15374: LD_INT 114
15376: PUSH
15377: LD_INT 115
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: ST_TO_ADDR
15395: GO 15626
15397: LD_INT 19
15399: DOUBLE
15400: EQUAL
15401: IFTRUE 15405
15403: GO 15625
15405: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15406: LD_ADDR_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: LD_INT 2
15416: PUSH
15417: LD_INT 3
15419: PUSH
15420: LD_INT 4
15422: PUSH
15423: LD_INT 5
15425: PUSH
15426: LD_INT 6
15428: PUSH
15429: LD_INT 7
15431: PUSH
15432: LD_INT 8
15434: PUSH
15435: LD_INT 9
15437: PUSH
15438: LD_INT 10
15440: PUSH
15441: LD_INT 11
15443: PUSH
15444: LD_INT 12
15446: PUSH
15447: LD_INT 13
15449: PUSH
15450: LD_INT 14
15452: PUSH
15453: LD_INT 15
15455: PUSH
15456: LD_INT 16
15458: PUSH
15459: LD_INT 17
15461: PUSH
15462: LD_INT 18
15464: PUSH
15465: LD_INT 19
15467: PUSH
15468: LD_INT 20
15470: PUSH
15471: LD_INT 21
15473: PUSH
15474: LD_INT 22
15476: PUSH
15477: LD_INT 23
15479: PUSH
15480: LD_INT 24
15482: PUSH
15483: LD_INT 25
15485: PUSH
15486: LD_INT 26
15488: PUSH
15489: LD_INT 27
15491: PUSH
15492: LD_INT 28
15494: PUSH
15495: LD_INT 29
15497: PUSH
15498: LD_INT 30
15500: PUSH
15501: LD_INT 31
15503: PUSH
15504: LD_INT 32
15506: PUSH
15507: LD_INT 33
15509: PUSH
15510: LD_INT 34
15512: PUSH
15513: LD_INT 35
15515: PUSH
15516: LD_INT 36
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: LIST
15527: LIST
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: LIST
15544: LIST
15545: LIST
15546: LIST
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: LIST
15553: LIST
15554: LIST
15555: LIST
15556: PUSH
15557: LD_INT 101
15559: PUSH
15560: LD_INT 102
15562: PUSH
15563: LD_INT 103
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 105
15571: PUSH
15572: LD_INT 106
15574: PUSH
15575: LD_INT 107
15577: PUSH
15578: LD_INT 108
15580: PUSH
15581: LD_INT 109
15583: PUSH
15584: LD_INT 110
15586: PUSH
15587: LD_INT 111
15589: PUSH
15590: LD_INT 112
15592: PUSH
15593: LD_INT 113
15595: PUSH
15596: LD_INT 114
15598: PUSH
15599: LD_INT 115
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: LIST
15611: LIST
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: ST_TO_ADDR
15623: GO 15626
15625: POP
// end else
15626: GO 15663
// if campaign_id = 5 then
15628: LD_OWVAR 69
15632: PUSH
15633: LD_INT 5
15635: EQUAL
15636: IFFALSE 15663
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
15638: LD_ADDR_VAR 0 1
15642: PUSH
15643: LD_INT 1
15645: PUSH
15646: LD_INT 2
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: PUSH
15653: LD_INT 100
15655: PUSH
15656: EMPTY
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: ST_TO_ADDR
// end ; if result then
15663: LD_VAR 0 1
15667: IFFALSE 15956
// begin normal :=  ;
15669: LD_ADDR_VAR 0 3
15673: PUSH
15674: LD_STRING 
15676: ST_TO_ADDR
// hardcore :=  ;
15677: LD_ADDR_VAR 0 4
15681: PUSH
15682: LD_STRING 
15684: ST_TO_ADDR
// for i = 1 to normalCounter do
15685: LD_ADDR_VAR 0 5
15689: PUSH
15690: DOUBLE
15691: LD_INT 1
15693: DEC
15694: ST_TO_ADDR
15695: LD_EXP 27
15699: PUSH
15700: FOR_TO
15701: IFFALSE 15802
// begin tmp := 0 ;
15703: LD_ADDR_VAR 0 2
15707: PUSH
15708: LD_STRING 0
15710: ST_TO_ADDR
// if result [ 1 ] then
15711: LD_VAR 0 1
15715: PUSH
15716: LD_INT 1
15718: ARRAY
15719: IFFALSE 15784
// if result [ 1 ] [ 1 ] = i then
15721: LD_VAR 0 1
15725: PUSH
15726: LD_INT 1
15728: ARRAY
15729: PUSH
15730: LD_INT 1
15732: ARRAY
15733: PUSH
15734: LD_VAR 0 5
15738: EQUAL
15739: IFFALSE 15784
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15741: LD_ADDR_VAR 0 1
15745: PUSH
15746: LD_VAR 0 1
15750: PPUSH
15751: LD_INT 1
15753: PPUSH
15754: LD_VAR 0 1
15758: PUSH
15759: LD_INT 1
15761: ARRAY
15762: PPUSH
15763: LD_INT 1
15765: PPUSH
15766: CALL_OW 3
15770: PPUSH
15771: CALL_OW 1
15775: ST_TO_ADDR
// tmp := 1 ;
15776: LD_ADDR_VAR 0 2
15780: PUSH
15781: LD_STRING 1
15783: ST_TO_ADDR
// end ; normal := normal & tmp ;
15784: LD_ADDR_VAR 0 3
15788: PUSH
15789: LD_VAR 0 3
15793: PUSH
15794: LD_VAR 0 2
15798: STR
15799: ST_TO_ADDR
// end ;
15800: GO 15700
15802: POP
15803: POP
// for i = 1 to hardcoreCounter do
15804: LD_ADDR_VAR 0 5
15808: PUSH
15809: DOUBLE
15810: LD_INT 1
15812: DEC
15813: ST_TO_ADDR
15814: LD_EXP 28
15818: PUSH
15819: FOR_TO
15820: IFFALSE 15925
// begin tmp := 0 ;
15822: LD_ADDR_VAR 0 2
15826: PUSH
15827: LD_STRING 0
15829: ST_TO_ADDR
// if result [ 2 ] then
15830: LD_VAR 0 1
15834: PUSH
15835: LD_INT 2
15837: ARRAY
15838: IFFALSE 15907
// if result [ 2 ] [ 1 ] = 100 + i then
15840: LD_VAR 0 1
15844: PUSH
15845: LD_INT 2
15847: ARRAY
15848: PUSH
15849: LD_INT 1
15851: ARRAY
15852: PUSH
15853: LD_INT 100
15855: PUSH
15856: LD_VAR 0 5
15860: PLUS
15861: EQUAL
15862: IFFALSE 15907
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15864: LD_ADDR_VAR 0 1
15868: PUSH
15869: LD_VAR 0 1
15873: PPUSH
15874: LD_INT 2
15876: PPUSH
15877: LD_VAR 0 1
15881: PUSH
15882: LD_INT 2
15884: ARRAY
15885: PPUSH
15886: LD_INT 1
15888: PPUSH
15889: CALL_OW 3
15893: PPUSH
15894: CALL_OW 1
15898: ST_TO_ADDR
// tmp := 1 ;
15899: LD_ADDR_VAR 0 2
15903: PUSH
15904: LD_STRING 1
15906: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15907: LD_ADDR_VAR 0 4
15911: PUSH
15912: LD_VAR 0 4
15916: PUSH
15917: LD_VAR 0 2
15921: STR
15922: ST_TO_ADDR
// end ;
15923: GO 15819
15925: POP
15926: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15927: LD_STRING getStreamItemsFromMission("
15929: PUSH
15930: LD_VAR 0 3
15934: STR
15935: PUSH
15936: LD_STRING ","
15938: STR
15939: PUSH
15940: LD_VAR 0 4
15944: STR
15945: PUSH
15946: LD_STRING ")
15948: STR
15949: PPUSH
15950: CALL_OW 559
// end else
15954: GO 15963
// ToLua ( getStreamItemsFromMission("","") ) ;
15956: LD_STRING getStreamItemsFromMission("","")
15958: PPUSH
15959: CALL_OW 559
// end ;
15963: LD_VAR 0 1
15967: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15968: LD_VAR 0 2
15972: PUSH
15973: LD_INT 100
15975: EQUAL
15976: IFFALSE 16925
// begin if not StreamModeActive then
15978: LD_EXP 26
15982: NOT
15983: IFFALSE 15993
// StreamModeActive := true ;
15985: LD_ADDR_EXP 26
15989: PUSH
15990: LD_INT 1
15992: ST_TO_ADDR
// if p3 = 0 then
15993: LD_VAR 0 3
15997: PUSH
15998: LD_INT 0
16000: EQUAL
16001: IFFALSE 16007
// InitStreamMode ;
16003: CALL 12228 0 0
// if p3 = 1 then
16007: LD_VAR 0 3
16011: PUSH
16012: LD_INT 1
16014: EQUAL
16015: IFFALSE 16025
// sRocket := true ;
16017: LD_ADDR_EXP 31
16021: PUSH
16022: LD_INT 1
16024: ST_TO_ADDR
// if p3 = 2 then
16025: LD_VAR 0 3
16029: PUSH
16030: LD_INT 2
16032: EQUAL
16033: IFFALSE 16043
// sSpeed := true ;
16035: LD_ADDR_EXP 30
16039: PUSH
16040: LD_INT 1
16042: ST_TO_ADDR
// if p3 = 3 then
16043: LD_VAR 0 3
16047: PUSH
16048: LD_INT 3
16050: EQUAL
16051: IFFALSE 16061
// sEngine := true ;
16053: LD_ADDR_EXP 32
16057: PUSH
16058: LD_INT 1
16060: ST_TO_ADDR
// if p3 = 4 then
16061: LD_VAR 0 3
16065: PUSH
16066: LD_INT 4
16068: EQUAL
16069: IFFALSE 16079
// sSpec := true ;
16071: LD_ADDR_EXP 29
16075: PUSH
16076: LD_INT 1
16078: ST_TO_ADDR
// if p3 = 5 then
16079: LD_VAR 0 3
16083: PUSH
16084: LD_INT 5
16086: EQUAL
16087: IFFALSE 16097
// sLevel := true ;
16089: LD_ADDR_EXP 33
16093: PUSH
16094: LD_INT 1
16096: ST_TO_ADDR
// if p3 = 6 then
16097: LD_VAR 0 3
16101: PUSH
16102: LD_INT 6
16104: EQUAL
16105: IFFALSE 16115
// sArmoury := true ;
16107: LD_ADDR_EXP 34
16111: PUSH
16112: LD_INT 1
16114: ST_TO_ADDR
// if p3 = 7 then
16115: LD_VAR 0 3
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: IFFALSE 16133
// sRadar := true ;
16125: LD_ADDR_EXP 35
16129: PUSH
16130: LD_INT 1
16132: ST_TO_ADDR
// if p3 = 8 then
16133: LD_VAR 0 3
16137: PUSH
16138: LD_INT 8
16140: EQUAL
16141: IFFALSE 16151
// sBunker := true ;
16143: LD_ADDR_EXP 36
16147: PUSH
16148: LD_INT 1
16150: ST_TO_ADDR
// if p3 = 9 then
16151: LD_VAR 0 3
16155: PUSH
16156: LD_INT 9
16158: EQUAL
16159: IFFALSE 16169
// sHack := true ;
16161: LD_ADDR_EXP 37
16165: PUSH
16166: LD_INT 1
16168: ST_TO_ADDR
// if p3 = 10 then
16169: LD_VAR 0 3
16173: PUSH
16174: LD_INT 10
16176: EQUAL
16177: IFFALSE 16187
// sFire := true ;
16179: LD_ADDR_EXP 38
16183: PUSH
16184: LD_INT 1
16186: ST_TO_ADDR
// if p3 = 11 then
16187: LD_VAR 0 3
16191: PUSH
16192: LD_INT 11
16194: EQUAL
16195: IFFALSE 16205
// sRefresh := true ;
16197: LD_ADDR_EXP 39
16201: PUSH
16202: LD_INT 1
16204: ST_TO_ADDR
// if p3 = 12 then
16205: LD_VAR 0 3
16209: PUSH
16210: LD_INT 12
16212: EQUAL
16213: IFFALSE 16223
// sExp := true ;
16215: LD_ADDR_EXP 40
16219: PUSH
16220: LD_INT 1
16222: ST_TO_ADDR
// if p3 = 13 then
16223: LD_VAR 0 3
16227: PUSH
16228: LD_INT 13
16230: EQUAL
16231: IFFALSE 16241
// sDepot := true ;
16233: LD_ADDR_EXP 41
16237: PUSH
16238: LD_INT 1
16240: ST_TO_ADDR
// if p3 = 14 then
16241: LD_VAR 0 3
16245: PUSH
16246: LD_INT 14
16248: EQUAL
16249: IFFALSE 16259
// sFlag := true ;
16251: LD_ADDR_EXP 42
16255: PUSH
16256: LD_INT 1
16258: ST_TO_ADDR
// if p3 = 15 then
16259: LD_VAR 0 3
16263: PUSH
16264: LD_INT 15
16266: EQUAL
16267: IFFALSE 16277
// sKamikadze := true ;
16269: LD_ADDR_EXP 50
16273: PUSH
16274: LD_INT 1
16276: ST_TO_ADDR
// if p3 = 16 then
16277: LD_VAR 0 3
16281: PUSH
16282: LD_INT 16
16284: EQUAL
16285: IFFALSE 16295
// sTroll := true ;
16287: LD_ADDR_EXP 51
16291: PUSH
16292: LD_INT 1
16294: ST_TO_ADDR
// if p3 = 17 then
16295: LD_VAR 0 3
16299: PUSH
16300: LD_INT 17
16302: EQUAL
16303: IFFALSE 16313
// sSlow := true ;
16305: LD_ADDR_EXP 52
16309: PUSH
16310: LD_INT 1
16312: ST_TO_ADDR
// if p3 = 18 then
16313: LD_VAR 0 3
16317: PUSH
16318: LD_INT 18
16320: EQUAL
16321: IFFALSE 16331
// sLack := true ;
16323: LD_ADDR_EXP 53
16327: PUSH
16328: LD_INT 1
16330: ST_TO_ADDR
// if p3 = 19 then
16331: LD_VAR 0 3
16335: PUSH
16336: LD_INT 19
16338: EQUAL
16339: IFFALSE 16349
// sTank := true ;
16341: LD_ADDR_EXP 55
16345: PUSH
16346: LD_INT 1
16348: ST_TO_ADDR
// if p3 = 20 then
16349: LD_VAR 0 3
16353: PUSH
16354: LD_INT 20
16356: EQUAL
16357: IFFALSE 16367
// sRemote := true ;
16359: LD_ADDR_EXP 56
16363: PUSH
16364: LD_INT 1
16366: ST_TO_ADDR
// if p3 = 21 then
16367: LD_VAR 0 3
16371: PUSH
16372: LD_INT 21
16374: EQUAL
16375: IFFALSE 16385
// sPowell := true ;
16377: LD_ADDR_EXP 57
16381: PUSH
16382: LD_INT 1
16384: ST_TO_ADDR
// if p3 = 22 then
16385: LD_VAR 0 3
16389: PUSH
16390: LD_INT 22
16392: EQUAL
16393: IFFALSE 16403
// sTeleport := true ;
16395: LD_ADDR_EXP 60
16399: PUSH
16400: LD_INT 1
16402: ST_TO_ADDR
// if p3 = 23 then
16403: LD_VAR 0 3
16407: PUSH
16408: LD_INT 23
16410: EQUAL
16411: IFFALSE 16421
// sOilTower := true ;
16413: LD_ADDR_EXP 62
16417: PUSH
16418: LD_INT 1
16420: ST_TO_ADDR
// if p3 = 24 then
16421: LD_VAR 0 3
16425: PUSH
16426: LD_INT 24
16428: EQUAL
16429: IFFALSE 16439
// sShovel := true ;
16431: LD_ADDR_EXP 63
16435: PUSH
16436: LD_INT 1
16438: ST_TO_ADDR
// if p3 = 25 then
16439: LD_VAR 0 3
16443: PUSH
16444: LD_INT 25
16446: EQUAL
16447: IFFALSE 16457
// sSheik := true ;
16449: LD_ADDR_EXP 64
16453: PUSH
16454: LD_INT 1
16456: ST_TO_ADDR
// if p3 = 26 then
16457: LD_VAR 0 3
16461: PUSH
16462: LD_INT 26
16464: EQUAL
16465: IFFALSE 16475
// sEarthquake := true ;
16467: LD_ADDR_EXP 66
16471: PUSH
16472: LD_INT 1
16474: ST_TO_ADDR
// if p3 = 27 then
16475: LD_VAR 0 3
16479: PUSH
16480: LD_INT 27
16482: EQUAL
16483: IFFALSE 16493
// sAI := true ;
16485: LD_ADDR_EXP 67
16489: PUSH
16490: LD_INT 1
16492: ST_TO_ADDR
// if p3 = 28 then
16493: LD_VAR 0 3
16497: PUSH
16498: LD_INT 28
16500: EQUAL
16501: IFFALSE 16511
// sCargo := true ;
16503: LD_ADDR_EXP 70
16507: PUSH
16508: LD_INT 1
16510: ST_TO_ADDR
// if p3 = 29 then
16511: LD_VAR 0 3
16515: PUSH
16516: LD_INT 29
16518: EQUAL
16519: IFFALSE 16529
// sDLaser := true ;
16521: LD_ADDR_EXP 71
16525: PUSH
16526: LD_INT 1
16528: ST_TO_ADDR
// if p3 = 30 then
16529: LD_VAR 0 3
16533: PUSH
16534: LD_INT 30
16536: EQUAL
16537: IFFALSE 16547
// sExchange := true ;
16539: LD_ADDR_EXP 72
16543: PUSH
16544: LD_INT 1
16546: ST_TO_ADDR
// if p3 = 31 then
16547: LD_VAR 0 3
16551: PUSH
16552: LD_INT 31
16554: EQUAL
16555: IFFALSE 16565
// sFac := true ;
16557: LD_ADDR_EXP 73
16561: PUSH
16562: LD_INT 1
16564: ST_TO_ADDR
// if p3 = 32 then
16565: LD_VAR 0 3
16569: PUSH
16570: LD_INT 32
16572: EQUAL
16573: IFFALSE 16583
// sPower := true ;
16575: LD_ADDR_EXP 74
16579: PUSH
16580: LD_INT 1
16582: ST_TO_ADDR
// if p3 = 33 then
16583: LD_VAR 0 3
16587: PUSH
16588: LD_INT 33
16590: EQUAL
16591: IFFALSE 16601
// sRandom := true ;
16593: LD_ADDR_EXP 75
16597: PUSH
16598: LD_INT 1
16600: ST_TO_ADDR
// if p3 = 34 then
16601: LD_VAR 0 3
16605: PUSH
16606: LD_INT 34
16608: EQUAL
16609: IFFALSE 16619
// sShield := true ;
16611: LD_ADDR_EXP 76
16615: PUSH
16616: LD_INT 1
16618: ST_TO_ADDR
// if p3 = 35 then
16619: LD_VAR 0 3
16623: PUSH
16624: LD_INT 35
16626: EQUAL
16627: IFFALSE 16637
// sTime := true ;
16629: LD_ADDR_EXP 77
16633: PUSH
16634: LD_INT 1
16636: ST_TO_ADDR
// if p3 = 36 then
16637: LD_VAR 0 3
16641: PUSH
16642: LD_INT 36
16644: EQUAL
16645: IFFALSE 16655
// sTools := true ;
16647: LD_ADDR_EXP 78
16651: PUSH
16652: LD_INT 1
16654: ST_TO_ADDR
// if p3 = 101 then
16655: LD_VAR 0 3
16659: PUSH
16660: LD_INT 101
16662: EQUAL
16663: IFFALSE 16673
// sSold := true ;
16665: LD_ADDR_EXP 43
16669: PUSH
16670: LD_INT 1
16672: ST_TO_ADDR
// if p3 = 102 then
16673: LD_VAR 0 3
16677: PUSH
16678: LD_INT 102
16680: EQUAL
16681: IFFALSE 16691
// sDiff := true ;
16683: LD_ADDR_EXP 44
16687: PUSH
16688: LD_INT 1
16690: ST_TO_ADDR
// if p3 = 103 then
16691: LD_VAR 0 3
16695: PUSH
16696: LD_INT 103
16698: EQUAL
16699: IFFALSE 16709
// sFog := true ;
16701: LD_ADDR_EXP 47
16705: PUSH
16706: LD_INT 1
16708: ST_TO_ADDR
// if p3 = 104 then
16709: LD_VAR 0 3
16713: PUSH
16714: LD_INT 104
16716: EQUAL
16717: IFFALSE 16727
// sReset := true ;
16719: LD_ADDR_EXP 48
16723: PUSH
16724: LD_INT 1
16726: ST_TO_ADDR
// if p3 = 105 then
16727: LD_VAR 0 3
16731: PUSH
16732: LD_INT 105
16734: EQUAL
16735: IFFALSE 16745
// sSun := true ;
16737: LD_ADDR_EXP 49
16741: PUSH
16742: LD_INT 1
16744: ST_TO_ADDR
// if p3 = 106 then
16745: LD_VAR 0 3
16749: PUSH
16750: LD_INT 106
16752: EQUAL
16753: IFFALSE 16763
// sTiger := true ;
16755: LD_ADDR_EXP 45
16759: PUSH
16760: LD_INT 1
16762: ST_TO_ADDR
// if p3 = 107 then
16763: LD_VAR 0 3
16767: PUSH
16768: LD_INT 107
16770: EQUAL
16771: IFFALSE 16781
// sBomb := true ;
16773: LD_ADDR_EXP 46
16777: PUSH
16778: LD_INT 1
16780: ST_TO_ADDR
// if p3 = 108 then
16781: LD_VAR 0 3
16785: PUSH
16786: LD_INT 108
16788: EQUAL
16789: IFFALSE 16799
// sWound := true ;
16791: LD_ADDR_EXP 54
16795: PUSH
16796: LD_INT 1
16798: ST_TO_ADDR
// if p3 = 109 then
16799: LD_VAR 0 3
16803: PUSH
16804: LD_INT 109
16806: EQUAL
16807: IFFALSE 16817
// sBetray := true ;
16809: LD_ADDR_EXP 58
16813: PUSH
16814: LD_INT 1
16816: ST_TO_ADDR
// if p3 = 110 then
16817: LD_VAR 0 3
16821: PUSH
16822: LD_INT 110
16824: EQUAL
16825: IFFALSE 16835
// sContamin := true ;
16827: LD_ADDR_EXP 59
16831: PUSH
16832: LD_INT 1
16834: ST_TO_ADDR
// if p3 = 111 then
16835: LD_VAR 0 3
16839: PUSH
16840: LD_INT 111
16842: EQUAL
16843: IFFALSE 16853
// sOil := true ;
16845: LD_ADDR_EXP 61
16849: PUSH
16850: LD_INT 1
16852: ST_TO_ADDR
// if p3 = 112 then
16853: LD_VAR 0 3
16857: PUSH
16858: LD_INT 112
16860: EQUAL
16861: IFFALSE 16871
// sStu := true ;
16863: LD_ADDR_EXP 65
16867: PUSH
16868: LD_INT 1
16870: ST_TO_ADDR
// if p3 = 113 then
16871: LD_VAR 0 3
16875: PUSH
16876: LD_INT 113
16878: EQUAL
16879: IFFALSE 16889
// sBazooka := true ;
16881: LD_ADDR_EXP 68
16885: PUSH
16886: LD_INT 1
16888: ST_TO_ADDR
// if p3 = 114 then
16889: LD_VAR 0 3
16893: PUSH
16894: LD_INT 114
16896: EQUAL
16897: IFFALSE 16907
// sMortar := true ;
16899: LD_ADDR_EXP 69
16903: PUSH
16904: LD_INT 1
16906: ST_TO_ADDR
// if p3 = 115 then
16907: LD_VAR 0 3
16911: PUSH
16912: LD_INT 115
16914: EQUAL
16915: IFFALSE 16925
// sRanger := true ;
16917: LD_ADDR_EXP 79
16921: PUSH
16922: LD_INT 1
16924: ST_TO_ADDR
// end ; end ;
16925: PPOPN 6
16927: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16928: LD_EXP 26
16932: PUSH
16933: LD_EXP 31
16937: AND
16938: IFFALSE 17062
16940: GO 16942
16942: DISABLE
16943: LD_INT 0
16945: PPUSH
16946: PPUSH
// begin enable ;
16947: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16948: LD_ADDR_VAR 0 2
16952: PUSH
16953: LD_INT 22
16955: PUSH
16956: LD_OWVAR 2
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 2
16967: PUSH
16968: LD_INT 34
16970: PUSH
16971: LD_INT 7
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 34
16980: PUSH
16981: LD_INT 45
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 34
16990: PUSH
16991: LD_INT 28
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 34
17000: PUSH
17001: LD_INT 47
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: LIST
17014: PUSH
17015: EMPTY
17016: LIST
17017: LIST
17018: PPUSH
17019: CALL_OW 69
17023: ST_TO_ADDR
// if not tmp then
17024: LD_VAR 0 2
17028: NOT
17029: IFFALSE 17033
// exit ;
17031: GO 17062
// for i in tmp do
17033: LD_ADDR_VAR 0 1
17037: PUSH
17038: LD_VAR 0 2
17042: PUSH
17043: FOR_IN
17044: IFFALSE 17060
// begin SetLives ( i , 0 ) ;
17046: LD_VAR 0 1
17050: PPUSH
17051: LD_INT 0
17053: PPUSH
17054: CALL_OW 234
// end ;
17058: GO 17043
17060: POP
17061: POP
// end ;
17062: PPOPN 2
17064: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
17065: LD_EXP 26
17069: PUSH
17070: LD_EXP 32
17074: AND
17075: IFFALSE 17159
17077: GO 17079
17079: DISABLE
17080: LD_INT 0
17082: PPUSH
17083: PPUSH
// begin enable ;
17084: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
17085: LD_ADDR_VAR 0 2
17089: PUSH
17090: LD_INT 22
17092: PUSH
17093: LD_OWVAR 2
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: PUSH
17102: LD_INT 32
17104: PUSH
17105: LD_INT 3
17107: PUSH
17108: EMPTY
17109: LIST
17110: LIST
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: PPUSH
17116: CALL_OW 69
17120: ST_TO_ADDR
// if not tmp then
17121: LD_VAR 0 2
17125: NOT
17126: IFFALSE 17130
// exit ;
17128: GO 17159
// for i in tmp do
17130: LD_ADDR_VAR 0 1
17134: PUSH
17135: LD_VAR 0 2
17139: PUSH
17140: FOR_IN
17141: IFFALSE 17157
// begin SetLives ( i , 0 ) ;
17143: LD_VAR 0 1
17147: PPUSH
17148: LD_INT 0
17150: PPUSH
17151: CALL_OW 234
// end ;
17155: GO 17140
17157: POP
17158: POP
// end ;
17159: PPOPN 2
17161: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
17162: LD_EXP 26
17166: PUSH
17167: LD_EXP 29
17171: AND
17172: IFFALSE 17265
17174: GO 17176
17176: DISABLE
17177: LD_INT 0
17179: PPUSH
// begin enable ;
17180: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
17181: LD_ADDR_VAR 0 1
17185: PUSH
17186: LD_INT 22
17188: PUSH
17189: LD_OWVAR 2
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: PUSH
17198: LD_INT 2
17200: PUSH
17201: LD_INT 25
17203: PUSH
17204: LD_INT 5
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: LD_INT 25
17213: PUSH
17214: LD_INT 9
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: LD_INT 25
17223: PUSH
17224: LD_INT 8
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: LIST
17235: LIST
17236: PUSH
17237: EMPTY
17238: LIST
17239: LIST
17240: PPUSH
17241: CALL_OW 69
17245: PUSH
17246: FOR_IN
17247: IFFALSE 17263
// begin SetClass ( i , 1 ) ;
17249: LD_VAR 0 1
17253: PPUSH
17254: LD_INT 1
17256: PPUSH
17257: CALL_OW 336
// end ;
17261: GO 17246
17263: POP
17264: POP
// end ;
17265: PPOPN 1
17267: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17268: LD_EXP 26
17272: PUSH
17273: LD_EXP 30
17277: AND
17278: PUSH
17279: LD_OWVAR 65
17283: PUSH
17284: LD_INT 7
17286: LESS
17287: AND
17288: IFFALSE 17302
17290: GO 17292
17292: DISABLE
// begin enable ;
17293: ENABLE
// game_speed := 7 ;
17294: LD_ADDR_OWVAR 65
17298: PUSH
17299: LD_INT 7
17301: ST_TO_ADDR
// end ;
17302: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17303: LD_EXP 26
17307: PUSH
17308: LD_EXP 33
17312: AND
17313: IFFALSE 17515
17315: GO 17317
17317: DISABLE
17318: LD_INT 0
17320: PPUSH
17321: PPUSH
17322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17323: LD_ADDR_VAR 0 3
17327: PUSH
17328: LD_INT 81
17330: PUSH
17331: LD_OWVAR 2
17335: PUSH
17336: EMPTY
17337: LIST
17338: LIST
17339: PUSH
17340: LD_INT 21
17342: PUSH
17343: LD_INT 1
17345: PUSH
17346: EMPTY
17347: LIST
17348: LIST
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: PPUSH
17354: CALL_OW 69
17358: ST_TO_ADDR
// if not tmp then
17359: LD_VAR 0 3
17363: NOT
17364: IFFALSE 17368
// exit ;
17366: GO 17515
// if tmp > 5 then
17368: LD_VAR 0 3
17372: PUSH
17373: LD_INT 5
17375: GREATER
17376: IFFALSE 17388
// k := 5 else
17378: LD_ADDR_VAR 0 2
17382: PUSH
17383: LD_INT 5
17385: ST_TO_ADDR
17386: GO 17398
// k := tmp ;
17388: LD_ADDR_VAR 0 2
17392: PUSH
17393: LD_VAR 0 3
17397: ST_TO_ADDR
// for i := 1 to k do
17398: LD_ADDR_VAR 0 1
17402: PUSH
17403: DOUBLE
17404: LD_INT 1
17406: DEC
17407: ST_TO_ADDR
17408: LD_VAR 0 2
17412: PUSH
17413: FOR_TO
17414: IFFALSE 17513
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17416: LD_VAR 0 3
17420: PUSH
17421: LD_VAR 0 1
17425: ARRAY
17426: PPUSH
17427: LD_VAR 0 1
17431: PUSH
17432: LD_INT 4
17434: MOD
17435: PUSH
17436: LD_INT 1
17438: PLUS
17439: PPUSH
17440: CALL_OW 259
17444: PUSH
17445: LD_INT 10
17447: LESS
17448: IFFALSE 17511
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17450: LD_VAR 0 3
17454: PUSH
17455: LD_VAR 0 1
17459: ARRAY
17460: PPUSH
17461: LD_VAR 0 1
17465: PUSH
17466: LD_INT 4
17468: MOD
17469: PUSH
17470: LD_INT 1
17472: PLUS
17473: PPUSH
17474: LD_VAR 0 3
17478: PUSH
17479: LD_VAR 0 1
17483: ARRAY
17484: PPUSH
17485: LD_VAR 0 1
17489: PUSH
17490: LD_INT 4
17492: MOD
17493: PUSH
17494: LD_INT 1
17496: PLUS
17497: PPUSH
17498: CALL_OW 259
17502: PUSH
17503: LD_INT 1
17505: PLUS
17506: PPUSH
17507: CALL_OW 237
17511: GO 17413
17513: POP
17514: POP
// end ;
17515: PPOPN 3
17517: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17518: LD_EXP 26
17522: PUSH
17523: LD_EXP 34
17527: AND
17528: IFFALSE 17548
17530: GO 17532
17532: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17533: LD_INT 4
17535: PPUSH
17536: LD_OWVAR 2
17540: PPUSH
17541: LD_INT 0
17543: PPUSH
17544: CALL_OW 324
17548: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17549: LD_EXP 26
17553: PUSH
17554: LD_EXP 63
17558: AND
17559: IFFALSE 17579
17561: GO 17563
17563: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17564: LD_INT 19
17566: PPUSH
17567: LD_OWVAR 2
17571: PPUSH
17572: LD_INT 0
17574: PPUSH
17575: CALL_OW 324
17579: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17580: LD_EXP 26
17584: PUSH
17585: LD_EXP 35
17589: AND
17590: IFFALSE 17692
17592: GO 17594
17594: DISABLE
17595: LD_INT 0
17597: PPUSH
17598: PPUSH
// begin enable ;
17599: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17600: LD_ADDR_VAR 0 2
17604: PUSH
17605: LD_INT 22
17607: PUSH
17608: LD_OWVAR 2
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PUSH
17617: LD_INT 2
17619: PUSH
17620: LD_INT 34
17622: PUSH
17623: LD_INT 11
17625: PUSH
17626: EMPTY
17627: LIST
17628: LIST
17629: PUSH
17630: LD_INT 34
17632: PUSH
17633: LD_INT 30
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: LIST
17644: PUSH
17645: EMPTY
17646: LIST
17647: LIST
17648: PPUSH
17649: CALL_OW 69
17653: ST_TO_ADDR
// if not tmp then
17654: LD_VAR 0 2
17658: NOT
17659: IFFALSE 17663
// exit ;
17661: GO 17692
// for i in tmp do
17663: LD_ADDR_VAR 0 1
17667: PUSH
17668: LD_VAR 0 2
17672: PUSH
17673: FOR_IN
17674: IFFALSE 17690
// begin SetLives ( i , 0 ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: LD_INT 0
17683: PPUSH
17684: CALL_OW 234
// end ;
17688: GO 17673
17690: POP
17691: POP
// end ;
17692: PPOPN 2
17694: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17695: LD_EXP 26
17699: PUSH
17700: LD_EXP 36
17704: AND
17705: IFFALSE 17725
17707: GO 17709
17709: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17710: LD_INT 32
17712: PPUSH
17713: LD_OWVAR 2
17717: PPUSH
17718: LD_INT 0
17720: PPUSH
17721: CALL_OW 324
17725: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17726: LD_EXP 26
17730: PUSH
17731: LD_EXP 37
17735: AND
17736: IFFALSE 17917
17738: GO 17740
17740: DISABLE
17741: LD_INT 0
17743: PPUSH
17744: PPUSH
17745: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17746: LD_ADDR_VAR 0 2
17750: PUSH
17751: LD_INT 22
17753: PUSH
17754: LD_OWVAR 2
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: PUSH
17763: LD_INT 33
17765: PUSH
17766: LD_INT 3
17768: PUSH
17769: EMPTY
17770: LIST
17771: LIST
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: PPUSH
17777: CALL_OW 69
17781: ST_TO_ADDR
// if not tmp then
17782: LD_VAR 0 2
17786: NOT
17787: IFFALSE 17791
// exit ;
17789: GO 17917
// side := 0 ;
17791: LD_ADDR_VAR 0 3
17795: PUSH
17796: LD_INT 0
17798: ST_TO_ADDR
// for i := 1 to 8 do
17799: LD_ADDR_VAR 0 1
17803: PUSH
17804: DOUBLE
17805: LD_INT 1
17807: DEC
17808: ST_TO_ADDR
17809: LD_INT 8
17811: PUSH
17812: FOR_TO
17813: IFFALSE 17861
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17815: LD_OWVAR 2
17819: PUSH
17820: LD_VAR 0 1
17824: NONEQUAL
17825: PUSH
17826: LD_OWVAR 2
17830: PPUSH
17831: LD_VAR 0 1
17835: PPUSH
17836: CALL_OW 81
17840: PUSH
17841: LD_INT 2
17843: EQUAL
17844: AND
17845: IFFALSE 17859
// begin side := i ;
17847: LD_ADDR_VAR 0 3
17851: PUSH
17852: LD_VAR 0 1
17856: ST_TO_ADDR
// break ;
17857: GO 17861
// end ;
17859: GO 17812
17861: POP
17862: POP
// if not side then
17863: LD_VAR 0 3
17867: NOT
17868: IFFALSE 17872
// exit ;
17870: GO 17917
// for i := 1 to tmp do
17872: LD_ADDR_VAR 0 1
17876: PUSH
17877: DOUBLE
17878: LD_INT 1
17880: DEC
17881: ST_TO_ADDR
17882: LD_VAR 0 2
17886: PUSH
17887: FOR_TO
17888: IFFALSE 17915
// if Prob ( 60 ) then
17890: LD_INT 60
17892: PPUSH
17893: CALL_OW 13
17897: IFFALSE 17913
// SetSide ( i , side ) ;
17899: LD_VAR 0 1
17903: PPUSH
17904: LD_VAR 0 3
17908: PPUSH
17909: CALL_OW 235
17913: GO 17887
17915: POP
17916: POP
// end ;
17917: PPOPN 3
17919: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17920: LD_EXP 26
17924: PUSH
17925: LD_EXP 39
17929: AND
17930: IFFALSE 18049
17932: GO 17934
17934: DISABLE
17935: LD_INT 0
17937: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17938: LD_ADDR_VAR 0 1
17942: PUSH
17943: LD_INT 22
17945: PUSH
17946: LD_OWVAR 2
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: PUSH
17955: LD_INT 21
17957: PUSH
17958: LD_INT 1
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: PUSH
17965: LD_INT 3
17967: PUSH
17968: LD_INT 23
17970: PUSH
17971: LD_INT 0
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: PUSH
17982: EMPTY
17983: LIST
17984: LIST
17985: LIST
17986: PPUSH
17987: CALL_OW 69
17991: PUSH
17992: FOR_IN
17993: IFFALSE 18047
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL_OW 257
18004: PUSH
18005: LD_INT 1
18007: PUSH
18008: LD_INT 2
18010: PUSH
18011: LD_INT 3
18013: PUSH
18014: LD_INT 4
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: IN
18023: IFFALSE 18045
// SetClass ( un , rand ( 1 , 4 ) ) ;
18025: LD_VAR 0 1
18029: PPUSH
18030: LD_INT 1
18032: PPUSH
18033: LD_INT 4
18035: PPUSH
18036: CALL_OW 12
18040: PPUSH
18041: CALL_OW 336
18045: GO 17992
18047: POP
18048: POP
// end ;
18049: PPOPN 1
18051: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
18052: LD_EXP 26
18056: PUSH
18057: LD_EXP 38
18061: AND
18062: IFFALSE 18141
18064: GO 18066
18066: DISABLE
18067: LD_INT 0
18069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18070: LD_ADDR_VAR 0 1
18074: PUSH
18075: LD_INT 22
18077: PUSH
18078: LD_OWVAR 2
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: PUSH
18087: LD_INT 21
18089: PUSH
18090: LD_INT 3
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PPUSH
18101: CALL_OW 69
18105: ST_TO_ADDR
// if not tmp then
18106: LD_VAR 0 1
18110: NOT
18111: IFFALSE 18115
// exit ;
18113: GO 18141
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
18115: LD_VAR 0 1
18119: PUSH
18120: LD_INT 1
18122: PPUSH
18123: LD_VAR 0 1
18127: PPUSH
18128: CALL_OW 12
18132: ARRAY
18133: PPUSH
18134: LD_INT 100
18136: PPUSH
18137: CALL_OW 234
// end ;
18141: PPOPN 1
18143: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
18144: LD_EXP 26
18148: PUSH
18149: LD_EXP 40
18153: AND
18154: IFFALSE 18252
18156: GO 18158
18158: DISABLE
18159: LD_INT 0
18161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18162: LD_ADDR_VAR 0 1
18166: PUSH
18167: LD_INT 22
18169: PUSH
18170: LD_OWVAR 2
18174: PUSH
18175: EMPTY
18176: LIST
18177: LIST
18178: PUSH
18179: LD_INT 21
18181: PUSH
18182: LD_INT 1
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: PUSH
18189: EMPTY
18190: LIST
18191: LIST
18192: PPUSH
18193: CALL_OW 69
18197: ST_TO_ADDR
// if not tmp then
18198: LD_VAR 0 1
18202: NOT
18203: IFFALSE 18207
// exit ;
18205: GO 18252
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18207: LD_VAR 0 1
18211: PUSH
18212: LD_INT 1
18214: PPUSH
18215: LD_VAR 0 1
18219: PPUSH
18220: CALL_OW 12
18224: ARRAY
18225: PPUSH
18226: LD_INT 1
18228: PPUSH
18229: LD_INT 4
18231: PPUSH
18232: CALL_OW 12
18236: PPUSH
18237: LD_INT 3000
18239: PPUSH
18240: LD_INT 9000
18242: PPUSH
18243: CALL_OW 12
18247: PPUSH
18248: CALL_OW 492
// end ;
18252: PPOPN 1
18254: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18255: LD_EXP 26
18259: PUSH
18260: LD_EXP 41
18264: AND
18265: IFFALSE 18285
18267: GO 18269
18269: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18270: LD_INT 1
18272: PPUSH
18273: LD_OWVAR 2
18277: PPUSH
18278: LD_INT 0
18280: PPUSH
18281: CALL_OW 324
18285: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18286: LD_EXP 26
18290: PUSH
18291: LD_EXP 42
18295: AND
18296: IFFALSE 18379
18298: GO 18300
18300: DISABLE
18301: LD_INT 0
18303: PPUSH
18304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18305: LD_ADDR_VAR 0 2
18309: PUSH
18310: LD_INT 22
18312: PUSH
18313: LD_OWVAR 2
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: PUSH
18322: LD_INT 21
18324: PUSH
18325: LD_INT 3
18327: PUSH
18328: EMPTY
18329: LIST
18330: LIST
18331: PUSH
18332: EMPTY
18333: LIST
18334: LIST
18335: PPUSH
18336: CALL_OW 69
18340: ST_TO_ADDR
// if not tmp then
18341: LD_VAR 0 2
18345: NOT
18346: IFFALSE 18350
// exit ;
18348: GO 18379
// for i in tmp do
18350: LD_ADDR_VAR 0 1
18354: PUSH
18355: LD_VAR 0 2
18359: PUSH
18360: FOR_IN
18361: IFFALSE 18377
// SetBLevel ( i , 10 ) ;
18363: LD_VAR 0 1
18367: PPUSH
18368: LD_INT 10
18370: PPUSH
18371: CALL_OW 241
18375: GO 18360
18377: POP
18378: POP
// end ;
18379: PPOPN 2
18381: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18382: LD_EXP 26
18386: PUSH
18387: LD_EXP 43
18391: AND
18392: IFFALSE 18503
18394: GO 18396
18396: DISABLE
18397: LD_INT 0
18399: PPUSH
18400: PPUSH
18401: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18402: LD_ADDR_VAR 0 3
18406: PUSH
18407: LD_INT 22
18409: PUSH
18410: LD_OWVAR 2
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: PUSH
18419: LD_INT 25
18421: PUSH
18422: LD_INT 1
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: PUSH
18429: EMPTY
18430: LIST
18431: LIST
18432: PPUSH
18433: CALL_OW 69
18437: ST_TO_ADDR
// if not tmp then
18438: LD_VAR 0 3
18442: NOT
18443: IFFALSE 18447
// exit ;
18445: GO 18503
// un := tmp [ rand ( 1 , tmp ) ] ;
18447: LD_ADDR_VAR 0 2
18451: PUSH
18452: LD_VAR 0 3
18456: PUSH
18457: LD_INT 1
18459: PPUSH
18460: LD_VAR 0 3
18464: PPUSH
18465: CALL_OW 12
18469: ARRAY
18470: ST_TO_ADDR
// if Crawls ( un ) then
18471: LD_VAR 0 2
18475: PPUSH
18476: CALL_OW 318
18480: IFFALSE 18491
// ComWalk ( un ) ;
18482: LD_VAR 0 2
18486: PPUSH
18487: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18491: LD_VAR 0 2
18495: PPUSH
18496: LD_INT 5
18498: PPUSH
18499: CALL_OW 336
// end ;
18503: PPOPN 3
18505: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18506: LD_EXP 26
18510: PUSH
18511: LD_EXP 44
18515: AND
18516: PUSH
18517: LD_OWVAR 67
18521: PUSH
18522: LD_INT 3
18524: LESS
18525: AND
18526: IFFALSE 18545
18528: GO 18530
18530: DISABLE
// Difficulty := Difficulty + 1 ;
18531: LD_ADDR_OWVAR 67
18535: PUSH
18536: LD_OWVAR 67
18540: PUSH
18541: LD_INT 1
18543: PLUS
18544: ST_TO_ADDR
18545: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18546: LD_EXP 26
18550: PUSH
18551: LD_EXP 45
18555: AND
18556: IFFALSE 18659
18558: GO 18560
18560: DISABLE
18561: LD_INT 0
18563: PPUSH
// begin for i := 1 to 5 do
18564: LD_ADDR_VAR 0 1
18568: PUSH
18569: DOUBLE
18570: LD_INT 1
18572: DEC
18573: ST_TO_ADDR
18574: LD_INT 5
18576: PUSH
18577: FOR_TO
18578: IFFALSE 18657
// begin uc_nation := nation_nature ;
18580: LD_ADDR_OWVAR 21
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// uc_side := 0 ;
18588: LD_ADDR_OWVAR 20
18592: PUSH
18593: LD_INT 0
18595: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18596: LD_ADDR_OWVAR 29
18600: PUSH
18601: LD_INT 12
18603: PUSH
18604: LD_INT 12
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: ST_TO_ADDR
// hc_agressivity := 20 ;
18611: LD_ADDR_OWVAR 35
18615: PUSH
18616: LD_INT 20
18618: ST_TO_ADDR
// hc_class := class_tiger ;
18619: LD_ADDR_OWVAR 28
18623: PUSH
18624: LD_INT 14
18626: ST_TO_ADDR
// hc_gallery :=  ;
18627: LD_ADDR_OWVAR 33
18631: PUSH
18632: LD_STRING 
18634: ST_TO_ADDR
// hc_name :=  ;
18635: LD_ADDR_OWVAR 26
18639: PUSH
18640: LD_STRING 
18642: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18643: CALL_OW 44
18647: PPUSH
18648: LD_INT 0
18650: PPUSH
18651: CALL_OW 51
// end ;
18655: GO 18577
18657: POP
18658: POP
// end ;
18659: PPOPN 1
18661: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18662: LD_EXP 26
18666: PUSH
18667: LD_EXP 46
18671: AND
18672: IFFALSE 18681
18674: GO 18676
18676: DISABLE
// StreamSibBomb ;
18677: CALL 18682 0 0
18681: END
// export function StreamSibBomb ; var i , x , y ; begin
18682: LD_INT 0
18684: PPUSH
18685: PPUSH
18686: PPUSH
18687: PPUSH
// result := false ;
18688: LD_ADDR_VAR 0 1
18692: PUSH
18693: LD_INT 0
18695: ST_TO_ADDR
// for i := 1 to 16 do
18696: LD_ADDR_VAR 0 2
18700: PUSH
18701: DOUBLE
18702: LD_INT 1
18704: DEC
18705: ST_TO_ADDR
18706: LD_INT 16
18708: PUSH
18709: FOR_TO
18710: IFFALSE 18909
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18712: LD_ADDR_VAR 0 3
18716: PUSH
18717: LD_INT 10
18719: PUSH
18720: LD_INT 20
18722: PUSH
18723: LD_INT 30
18725: PUSH
18726: LD_INT 40
18728: PUSH
18729: LD_INT 50
18731: PUSH
18732: LD_INT 60
18734: PUSH
18735: LD_INT 70
18737: PUSH
18738: LD_INT 80
18740: PUSH
18741: LD_INT 90
18743: PUSH
18744: LD_INT 100
18746: PUSH
18747: LD_INT 110
18749: PUSH
18750: LD_INT 120
18752: PUSH
18753: LD_INT 130
18755: PUSH
18756: LD_INT 140
18758: PUSH
18759: LD_INT 150
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: LIST
18775: LIST
18776: LIST
18777: LIST
18778: PUSH
18779: LD_INT 1
18781: PPUSH
18782: LD_INT 15
18784: PPUSH
18785: CALL_OW 12
18789: ARRAY
18790: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18791: LD_ADDR_VAR 0 4
18795: PUSH
18796: LD_INT 10
18798: PUSH
18799: LD_INT 20
18801: PUSH
18802: LD_INT 30
18804: PUSH
18805: LD_INT 40
18807: PUSH
18808: LD_INT 50
18810: PUSH
18811: LD_INT 60
18813: PUSH
18814: LD_INT 70
18816: PUSH
18817: LD_INT 80
18819: PUSH
18820: LD_INT 90
18822: PUSH
18823: LD_INT 100
18825: PUSH
18826: LD_INT 110
18828: PUSH
18829: LD_INT 120
18831: PUSH
18832: LD_INT 130
18834: PUSH
18835: LD_INT 140
18837: PUSH
18838: LD_INT 150
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: PUSH
18858: LD_INT 1
18860: PPUSH
18861: LD_INT 15
18863: PPUSH
18864: CALL_OW 12
18868: ARRAY
18869: ST_TO_ADDR
// if ValidHex ( x , y ) then
18870: LD_VAR 0 3
18874: PPUSH
18875: LD_VAR 0 4
18879: PPUSH
18880: CALL_OW 488
18884: IFFALSE 18907
// begin result := [ x , y ] ;
18886: LD_ADDR_VAR 0 1
18890: PUSH
18891: LD_VAR 0 3
18895: PUSH
18896: LD_VAR 0 4
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: ST_TO_ADDR
// break ;
18905: GO 18909
// end ; end ;
18907: GO 18709
18909: POP
18910: POP
// if result then
18911: LD_VAR 0 1
18915: IFFALSE 18975
// begin ToLua ( playSibBomb() ) ;
18917: LD_STRING playSibBomb()
18919: PPUSH
18920: CALL_OW 559
// wait ( 0 0$14 ) ;
18924: LD_INT 490
18926: PPUSH
18927: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18931: LD_VAR 0 1
18935: PUSH
18936: LD_INT 1
18938: ARRAY
18939: PPUSH
18940: LD_VAR 0 1
18944: PUSH
18945: LD_INT 2
18947: ARRAY
18948: PPUSH
18949: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18953: LD_VAR 0 1
18957: PUSH
18958: LD_INT 1
18960: ARRAY
18961: PPUSH
18962: LD_VAR 0 1
18966: PUSH
18967: LD_INT 2
18969: ARRAY
18970: PPUSH
18971: CALL_OW 429
// end ; end ;
18975: LD_VAR 0 1
18979: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18980: LD_EXP 26
18984: PUSH
18985: LD_EXP 48
18989: AND
18990: IFFALSE 19002
18992: GO 18994
18994: DISABLE
// YouLost (  ) ;
18995: LD_STRING 
18997: PPUSH
18998: CALL_OW 104
19002: END
// every 0 0$1 trigger StreamModeActive and sFog do
19003: LD_EXP 26
19007: PUSH
19008: LD_EXP 47
19012: AND
19013: IFFALSE 19027
19015: GO 19017
19017: DISABLE
// FogOff ( your_side ) ;
19018: LD_OWVAR 2
19022: PPUSH
19023: CALL_OW 344
19027: END
// every 0 0$1 trigger StreamModeActive and sSun do
19028: LD_EXP 26
19032: PUSH
19033: LD_EXP 49
19037: AND
19038: IFFALSE 19066
19040: GO 19042
19042: DISABLE
// begin solar_recharge_percent := 0 ;
19043: LD_ADDR_OWVAR 79
19047: PUSH
19048: LD_INT 0
19050: ST_TO_ADDR
// wait ( 5 5$00 ) ;
19051: LD_INT 10500
19053: PPUSH
19054: CALL_OW 67
// solar_recharge_percent := 100 ;
19058: LD_ADDR_OWVAR 79
19062: PUSH
19063: LD_INT 100
19065: ST_TO_ADDR
// end ;
19066: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
19067: LD_EXP 26
19071: PUSH
19072: LD_EXP 50
19076: AND
19077: IFFALSE 19316
19079: GO 19081
19081: DISABLE
19082: LD_INT 0
19084: PPUSH
19085: PPUSH
19086: PPUSH
// begin tmp := [ ] ;
19087: LD_ADDR_VAR 0 3
19091: PUSH
19092: EMPTY
19093: ST_TO_ADDR
// for i := 1 to 6 do
19094: LD_ADDR_VAR 0 1
19098: PUSH
19099: DOUBLE
19100: LD_INT 1
19102: DEC
19103: ST_TO_ADDR
19104: LD_INT 6
19106: PUSH
19107: FOR_TO
19108: IFFALSE 19213
// begin uc_nation := nation_nature ;
19110: LD_ADDR_OWVAR 21
19114: PUSH
19115: LD_INT 0
19117: ST_TO_ADDR
// uc_side := 0 ;
19118: LD_ADDR_OWVAR 20
19122: PUSH
19123: LD_INT 0
19125: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
19126: LD_ADDR_OWVAR 29
19130: PUSH
19131: LD_INT 12
19133: PUSH
19134: LD_INT 12
19136: PUSH
19137: EMPTY
19138: LIST
19139: LIST
19140: ST_TO_ADDR
// hc_agressivity := 20 ;
19141: LD_ADDR_OWVAR 35
19145: PUSH
19146: LD_INT 20
19148: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
19149: LD_ADDR_OWVAR 28
19153: PUSH
19154: LD_INT 17
19156: ST_TO_ADDR
// hc_gallery :=  ;
19157: LD_ADDR_OWVAR 33
19161: PUSH
19162: LD_STRING 
19164: ST_TO_ADDR
// hc_name :=  ;
19165: LD_ADDR_OWVAR 26
19169: PUSH
19170: LD_STRING 
19172: ST_TO_ADDR
// un := CreateHuman ;
19173: LD_ADDR_VAR 0 2
19177: PUSH
19178: CALL_OW 44
19182: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
19183: LD_VAR 0 2
19187: PPUSH
19188: LD_INT 1
19190: PPUSH
19191: CALL_OW 51
// tmp := tmp ^ un ;
19195: LD_ADDR_VAR 0 3
19199: PUSH
19200: LD_VAR 0 3
19204: PUSH
19205: LD_VAR 0 2
19209: ADD
19210: ST_TO_ADDR
// end ;
19211: GO 19107
19213: POP
19214: POP
// repeat wait ( 0 0$1 ) ;
19215: LD_INT 35
19217: PPUSH
19218: CALL_OW 67
// for un in tmp do
19222: LD_ADDR_VAR 0 2
19226: PUSH
19227: LD_VAR 0 3
19231: PUSH
19232: FOR_IN
19233: IFFALSE 19307
// begin if IsDead ( un ) then
19235: LD_VAR 0 2
19239: PPUSH
19240: CALL_OW 301
19244: IFFALSE 19264
// begin tmp := tmp diff un ;
19246: LD_ADDR_VAR 0 3
19250: PUSH
19251: LD_VAR 0 3
19255: PUSH
19256: LD_VAR 0 2
19260: DIFF
19261: ST_TO_ADDR
// continue ;
19262: GO 19232
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19264: LD_VAR 0 2
19268: PPUSH
19269: LD_INT 3
19271: PUSH
19272: LD_INT 22
19274: PUSH
19275: LD_INT 0
19277: PUSH
19278: EMPTY
19279: LIST
19280: LIST
19281: PUSH
19282: EMPTY
19283: LIST
19284: LIST
19285: PPUSH
19286: CALL_OW 69
19290: PPUSH
19291: LD_VAR 0 2
19295: PPUSH
19296: CALL_OW 74
19300: PPUSH
19301: CALL_OW 115
// end ;
19305: GO 19232
19307: POP
19308: POP
// until not tmp ;
19309: LD_VAR 0 3
19313: NOT
19314: IFFALSE 19215
// end ;
19316: PPOPN 3
19318: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19319: LD_EXP 26
19323: PUSH
19324: LD_EXP 51
19328: AND
19329: IFFALSE 19383
19331: GO 19333
19333: DISABLE
// begin ToLua ( displayTroll(); ) ;
19334: LD_STRING displayTroll();
19336: PPUSH
19337: CALL_OW 559
// wait ( 3 3$00 ) ;
19341: LD_INT 6300
19343: PPUSH
19344: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19348: LD_STRING hideTroll();
19350: PPUSH
19351: CALL_OW 559
// wait ( 1 1$00 ) ;
19355: LD_INT 2100
19357: PPUSH
19358: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19362: LD_STRING displayTroll();
19364: PPUSH
19365: CALL_OW 559
// wait ( 1 1$00 ) ;
19369: LD_INT 2100
19371: PPUSH
19372: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19376: LD_STRING hideTroll();
19378: PPUSH
19379: CALL_OW 559
// end ;
19383: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19384: LD_EXP 26
19388: PUSH
19389: LD_EXP 52
19393: AND
19394: IFFALSE 19457
19396: GO 19398
19398: DISABLE
19399: LD_INT 0
19401: PPUSH
// begin p := 0 ;
19402: LD_ADDR_VAR 0 1
19406: PUSH
19407: LD_INT 0
19409: ST_TO_ADDR
// repeat game_speed := 1 ;
19410: LD_ADDR_OWVAR 65
19414: PUSH
19415: LD_INT 1
19417: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19418: LD_INT 35
19420: PPUSH
19421: CALL_OW 67
// p := p + 1 ;
19425: LD_ADDR_VAR 0 1
19429: PUSH
19430: LD_VAR 0 1
19434: PUSH
19435: LD_INT 1
19437: PLUS
19438: ST_TO_ADDR
// until p >= 60 ;
19439: LD_VAR 0 1
19443: PUSH
19444: LD_INT 60
19446: GREATEREQUAL
19447: IFFALSE 19410
// game_speed := 4 ;
19449: LD_ADDR_OWVAR 65
19453: PUSH
19454: LD_INT 4
19456: ST_TO_ADDR
// end ;
19457: PPOPN 1
19459: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19460: LD_EXP 26
19464: PUSH
19465: LD_EXP 53
19469: AND
19470: IFFALSE 19616
19472: GO 19474
19474: DISABLE
19475: LD_INT 0
19477: PPUSH
19478: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19479: LD_ADDR_VAR 0 1
19483: PUSH
19484: LD_INT 22
19486: PUSH
19487: LD_OWVAR 2
19491: PUSH
19492: EMPTY
19493: LIST
19494: LIST
19495: PUSH
19496: LD_INT 2
19498: PUSH
19499: LD_INT 30
19501: PUSH
19502: LD_INT 0
19504: PUSH
19505: EMPTY
19506: LIST
19507: LIST
19508: PUSH
19509: LD_INT 30
19511: PUSH
19512: LD_INT 1
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: PUSH
19519: EMPTY
19520: LIST
19521: LIST
19522: LIST
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: PPUSH
19528: CALL_OW 69
19532: ST_TO_ADDR
// if not depot then
19533: LD_VAR 0 1
19537: NOT
19538: IFFALSE 19542
// exit ;
19540: GO 19616
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19542: LD_ADDR_VAR 0 2
19546: PUSH
19547: LD_VAR 0 1
19551: PUSH
19552: LD_INT 1
19554: PPUSH
19555: LD_VAR 0 1
19559: PPUSH
19560: CALL_OW 12
19564: ARRAY
19565: PPUSH
19566: CALL_OW 274
19570: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19571: LD_VAR 0 2
19575: PPUSH
19576: LD_INT 1
19578: PPUSH
19579: LD_INT 0
19581: PPUSH
19582: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19586: LD_VAR 0 2
19590: PPUSH
19591: LD_INT 2
19593: PPUSH
19594: LD_INT 0
19596: PPUSH
19597: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19601: LD_VAR 0 2
19605: PPUSH
19606: LD_INT 3
19608: PPUSH
19609: LD_INT 0
19611: PPUSH
19612: CALL_OW 277
// end ;
19616: PPOPN 2
19618: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19619: LD_EXP 26
19623: PUSH
19624: LD_EXP 54
19628: AND
19629: IFFALSE 19726
19631: GO 19633
19633: DISABLE
19634: LD_INT 0
19636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19637: LD_ADDR_VAR 0 1
19641: PUSH
19642: LD_INT 22
19644: PUSH
19645: LD_OWVAR 2
19649: PUSH
19650: EMPTY
19651: LIST
19652: LIST
19653: PUSH
19654: LD_INT 21
19656: PUSH
19657: LD_INT 1
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: PUSH
19664: LD_INT 3
19666: PUSH
19667: LD_INT 23
19669: PUSH
19670: LD_INT 0
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PUSH
19677: EMPTY
19678: LIST
19679: LIST
19680: PUSH
19681: EMPTY
19682: LIST
19683: LIST
19684: LIST
19685: PPUSH
19686: CALL_OW 69
19690: ST_TO_ADDR
// if not tmp then
19691: LD_VAR 0 1
19695: NOT
19696: IFFALSE 19700
// exit ;
19698: GO 19726
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19700: LD_VAR 0 1
19704: PUSH
19705: LD_INT 1
19707: PPUSH
19708: LD_VAR 0 1
19712: PPUSH
19713: CALL_OW 12
19717: ARRAY
19718: PPUSH
19719: LD_INT 200
19721: PPUSH
19722: CALL_OW 234
// end ;
19726: PPOPN 1
19728: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19729: LD_EXP 26
19733: PUSH
19734: LD_EXP 55
19738: AND
19739: IFFALSE 19818
19741: GO 19743
19743: DISABLE
19744: LD_INT 0
19746: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19747: LD_ADDR_VAR 0 1
19751: PUSH
19752: LD_INT 22
19754: PUSH
19755: LD_OWVAR 2
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: PUSH
19764: LD_INT 21
19766: PUSH
19767: LD_INT 2
19769: PUSH
19770: EMPTY
19771: LIST
19772: LIST
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL_OW 69
19782: ST_TO_ADDR
// if not tmp then
19783: LD_VAR 0 1
19787: NOT
19788: IFFALSE 19792
// exit ;
19790: GO 19818
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19792: LD_VAR 0 1
19796: PUSH
19797: LD_INT 1
19799: PPUSH
19800: LD_VAR 0 1
19804: PPUSH
19805: CALL_OW 12
19809: ARRAY
19810: PPUSH
19811: LD_INT 60
19813: PPUSH
19814: CALL_OW 234
// end ;
19818: PPOPN 1
19820: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19821: LD_EXP 26
19825: PUSH
19826: LD_EXP 56
19830: AND
19831: IFFALSE 19930
19833: GO 19835
19835: DISABLE
19836: LD_INT 0
19838: PPUSH
19839: PPUSH
// begin enable ;
19840: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19841: LD_ADDR_VAR 0 1
19845: PUSH
19846: LD_INT 22
19848: PUSH
19849: LD_OWVAR 2
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: PUSH
19858: LD_INT 61
19860: PUSH
19861: EMPTY
19862: LIST
19863: PUSH
19864: LD_INT 33
19866: PUSH
19867: LD_INT 2
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: PUSH
19874: EMPTY
19875: LIST
19876: LIST
19877: LIST
19878: PPUSH
19879: CALL_OW 69
19883: ST_TO_ADDR
// if not tmp then
19884: LD_VAR 0 1
19888: NOT
19889: IFFALSE 19893
// exit ;
19891: GO 19930
// for i in tmp do
19893: LD_ADDR_VAR 0 2
19897: PUSH
19898: LD_VAR 0 1
19902: PUSH
19903: FOR_IN
19904: IFFALSE 19928
// if IsControledBy ( i ) then
19906: LD_VAR 0 2
19910: PPUSH
19911: CALL_OW 312
19915: IFFALSE 19926
// ComUnlink ( i ) ;
19917: LD_VAR 0 2
19921: PPUSH
19922: CALL_OW 136
19926: GO 19903
19928: POP
19929: POP
// end ;
19930: PPOPN 2
19932: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19933: LD_EXP 26
19937: PUSH
19938: LD_EXP 57
19942: AND
19943: IFFALSE 20083
19945: GO 19947
19947: DISABLE
19948: LD_INT 0
19950: PPUSH
19951: PPUSH
// begin ToLua ( displayPowell(); ) ;
19952: LD_STRING displayPowell();
19954: PPUSH
19955: CALL_OW 559
// uc_side := 0 ;
19959: LD_ADDR_OWVAR 20
19963: PUSH
19964: LD_INT 0
19966: ST_TO_ADDR
// uc_nation := 2 ;
19967: LD_ADDR_OWVAR 21
19971: PUSH
19972: LD_INT 2
19974: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19975: LD_ADDR_OWVAR 37
19979: PUSH
19980: LD_INT 14
19982: ST_TO_ADDR
// vc_engine := engine_siberite ;
19983: LD_ADDR_OWVAR 39
19987: PUSH
19988: LD_INT 3
19990: ST_TO_ADDR
// vc_control := control_apeman ;
19991: LD_ADDR_OWVAR 38
19995: PUSH
19996: LD_INT 5
19998: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19999: LD_ADDR_OWVAR 40
20003: PUSH
20004: LD_INT 29
20006: ST_TO_ADDR
// un := CreateVehicle ;
20007: LD_ADDR_VAR 0 2
20011: PUSH
20012: CALL_OW 45
20016: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20017: LD_VAR 0 2
20021: PPUSH
20022: LD_INT 1
20024: PPUSH
20025: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20029: LD_INT 35
20031: PPUSH
20032: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20036: LD_VAR 0 2
20040: PPUSH
20041: LD_INT 22
20043: PUSH
20044: LD_OWVAR 2
20048: PUSH
20049: EMPTY
20050: LIST
20051: LIST
20052: PPUSH
20053: CALL_OW 69
20057: PPUSH
20058: LD_VAR 0 2
20062: PPUSH
20063: CALL_OW 74
20067: PPUSH
20068: CALL_OW 115
// until IsDead ( un ) ;
20072: LD_VAR 0 2
20076: PPUSH
20077: CALL_OW 301
20081: IFFALSE 20029
// end ;
20083: PPOPN 2
20085: END
// every 0 0$1 trigger StreamModeActive and sStu do
20086: LD_EXP 26
20090: PUSH
20091: LD_EXP 65
20095: AND
20096: IFFALSE 20112
20098: GO 20100
20100: DISABLE
// begin ToLua ( displayStucuk(); ) ;
20101: LD_STRING displayStucuk();
20103: PPUSH
20104: CALL_OW 559
// ResetFog ;
20108: CALL_OW 335
// end ;
20112: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
20113: LD_EXP 26
20117: PUSH
20118: LD_EXP 58
20122: AND
20123: IFFALSE 20264
20125: GO 20127
20127: DISABLE
20128: LD_INT 0
20130: PPUSH
20131: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20132: LD_ADDR_VAR 0 2
20136: PUSH
20137: LD_INT 22
20139: PUSH
20140: LD_OWVAR 2
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: PUSH
20149: LD_INT 21
20151: PUSH
20152: LD_INT 1
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PPUSH
20163: CALL_OW 69
20167: ST_TO_ADDR
// if not tmp then
20168: LD_VAR 0 2
20172: NOT
20173: IFFALSE 20177
// exit ;
20175: GO 20264
// un := tmp [ rand ( 1 , tmp ) ] ;
20177: LD_ADDR_VAR 0 1
20181: PUSH
20182: LD_VAR 0 2
20186: PUSH
20187: LD_INT 1
20189: PPUSH
20190: LD_VAR 0 2
20194: PPUSH
20195: CALL_OW 12
20199: ARRAY
20200: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20201: LD_VAR 0 1
20205: PPUSH
20206: LD_INT 0
20208: PPUSH
20209: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20213: LD_VAR 0 1
20217: PPUSH
20218: LD_OWVAR 3
20222: PUSH
20223: LD_VAR 0 1
20227: DIFF
20228: PPUSH
20229: LD_VAR 0 1
20233: PPUSH
20234: CALL_OW 74
20238: PPUSH
20239: CALL_OW 115
// wait ( 0 0$20 ) ;
20243: LD_INT 700
20245: PPUSH
20246: CALL_OW 67
// SetSide ( un , your_side ) ;
20250: LD_VAR 0 1
20254: PPUSH
20255: LD_OWVAR 2
20259: PPUSH
20260: CALL_OW 235
// end ;
20264: PPOPN 2
20266: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20267: LD_EXP 26
20271: PUSH
20272: LD_EXP 59
20276: AND
20277: IFFALSE 20383
20279: GO 20281
20281: DISABLE
20282: LD_INT 0
20284: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20285: LD_ADDR_VAR 0 1
20289: PUSH
20290: LD_INT 22
20292: PUSH
20293: LD_OWVAR 2
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: PUSH
20302: LD_INT 2
20304: PUSH
20305: LD_INT 30
20307: PUSH
20308: LD_INT 0
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: PUSH
20315: LD_INT 30
20317: PUSH
20318: LD_INT 1
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: LIST
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PPUSH
20334: CALL_OW 69
20338: ST_TO_ADDR
// if not depot then
20339: LD_VAR 0 1
20343: NOT
20344: IFFALSE 20348
// exit ;
20346: GO 20383
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20348: LD_VAR 0 1
20352: PUSH
20353: LD_INT 1
20355: ARRAY
20356: PPUSH
20357: CALL_OW 250
20361: PPUSH
20362: LD_VAR 0 1
20366: PUSH
20367: LD_INT 1
20369: ARRAY
20370: PPUSH
20371: CALL_OW 251
20375: PPUSH
20376: LD_INT 70
20378: PPUSH
20379: CALL_OW 495
// end ;
20383: PPOPN 1
20385: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20386: LD_EXP 26
20390: PUSH
20391: LD_EXP 60
20395: AND
20396: IFFALSE 20607
20398: GO 20400
20400: DISABLE
20401: LD_INT 0
20403: PPUSH
20404: PPUSH
20405: PPUSH
20406: PPUSH
20407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20408: LD_ADDR_VAR 0 5
20412: PUSH
20413: LD_INT 22
20415: PUSH
20416: LD_OWVAR 2
20420: PUSH
20421: EMPTY
20422: LIST
20423: LIST
20424: PUSH
20425: LD_INT 21
20427: PUSH
20428: LD_INT 1
20430: PUSH
20431: EMPTY
20432: LIST
20433: LIST
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: PPUSH
20439: CALL_OW 69
20443: ST_TO_ADDR
// if not tmp then
20444: LD_VAR 0 5
20448: NOT
20449: IFFALSE 20453
// exit ;
20451: GO 20607
// for i in tmp do
20453: LD_ADDR_VAR 0 1
20457: PUSH
20458: LD_VAR 0 5
20462: PUSH
20463: FOR_IN
20464: IFFALSE 20605
// begin d := rand ( 0 , 5 ) ;
20466: LD_ADDR_VAR 0 4
20470: PUSH
20471: LD_INT 0
20473: PPUSH
20474: LD_INT 5
20476: PPUSH
20477: CALL_OW 12
20481: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20482: LD_ADDR_VAR 0 2
20486: PUSH
20487: LD_VAR 0 1
20491: PPUSH
20492: CALL_OW 250
20496: PPUSH
20497: LD_VAR 0 4
20501: PPUSH
20502: LD_INT 3
20504: PPUSH
20505: LD_INT 12
20507: PPUSH
20508: CALL_OW 12
20512: PPUSH
20513: CALL_OW 272
20517: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20518: LD_ADDR_VAR 0 3
20522: PUSH
20523: LD_VAR 0 1
20527: PPUSH
20528: CALL_OW 251
20532: PPUSH
20533: LD_VAR 0 4
20537: PPUSH
20538: LD_INT 3
20540: PPUSH
20541: LD_INT 12
20543: PPUSH
20544: CALL_OW 12
20548: PPUSH
20549: CALL_OW 273
20553: ST_TO_ADDR
// if ValidHex ( x , y ) then
20554: LD_VAR 0 2
20558: PPUSH
20559: LD_VAR 0 3
20563: PPUSH
20564: CALL_OW 488
20568: IFFALSE 20603
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20570: LD_VAR 0 1
20574: PPUSH
20575: LD_VAR 0 2
20579: PPUSH
20580: LD_VAR 0 3
20584: PPUSH
20585: LD_INT 3
20587: PPUSH
20588: LD_INT 6
20590: PPUSH
20591: CALL_OW 12
20595: PPUSH
20596: LD_INT 1
20598: PPUSH
20599: CALL_OW 483
// end ;
20603: GO 20463
20605: POP
20606: POP
// end ;
20607: PPOPN 5
20609: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20610: LD_EXP 26
20614: PUSH
20615: LD_EXP 61
20619: AND
20620: IFFALSE 20714
20622: GO 20624
20624: DISABLE
20625: LD_INT 0
20627: PPUSH
20628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20629: LD_ADDR_VAR 0 2
20633: PUSH
20634: LD_INT 22
20636: PUSH
20637: LD_OWVAR 2
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: PUSH
20646: LD_INT 32
20648: PUSH
20649: LD_INT 1
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: PUSH
20656: LD_INT 21
20658: PUSH
20659: LD_INT 2
20661: PUSH
20662: EMPTY
20663: LIST
20664: LIST
20665: PUSH
20666: EMPTY
20667: LIST
20668: LIST
20669: LIST
20670: PPUSH
20671: CALL_OW 69
20675: ST_TO_ADDR
// if not tmp then
20676: LD_VAR 0 2
20680: NOT
20681: IFFALSE 20685
// exit ;
20683: GO 20714
// for i in tmp do
20685: LD_ADDR_VAR 0 1
20689: PUSH
20690: LD_VAR 0 2
20694: PUSH
20695: FOR_IN
20696: IFFALSE 20712
// SetFuel ( i , 0 ) ;
20698: LD_VAR 0 1
20702: PPUSH
20703: LD_INT 0
20705: PPUSH
20706: CALL_OW 240
20710: GO 20695
20712: POP
20713: POP
// end ;
20714: PPOPN 2
20716: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20717: LD_EXP 26
20721: PUSH
20722: LD_EXP 62
20726: AND
20727: IFFALSE 20793
20729: GO 20731
20731: DISABLE
20732: LD_INT 0
20734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20735: LD_ADDR_VAR 0 1
20739: PUSH
20740: LD_INT 22
20742: PUSH
20743: LD_OWVAR 2
20747: PUSH
20748: EMPTY
20749: LIST
20750: LIST
20751: PUSH
20752: LD_INT 30
20754: PUSH
20755: LD_INT 29
20757: PUSH
20758: EMPTY
20759: LIST
20760: LIST
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: PPUSH
20766: CALL_OW 69
20770: ST_TO_ADDR
// if not tmp then
20771: LD_VAR 0 1
20775: NOT
20776: IFFALSE 20780
// exit ;
20778: GO 20793
// DestroyUnit ( tmp [ 1 ] ) ;
20780: LD_VAR 0 1
20784: PUSH
20785: LD_INT 1
20787: ARRAY
20788: PPUSH
20789: CALL_OW 65
// end ;
20793: PPOPN 1
20795: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20796: LD_EXP 26
20800: PUSH
20801: LD_EXP 64
20805: AND
20806: IFFALSE 20935
20808: GO 20810
20810: DISABLE
20811: LD_INT 0
20813: PPUSH
// begin uc_side := 0 ;
20814: LD_ADDR_OWVAR 20
20818: PUSH
20819: LD_INT 0
20821: ST_TO_ADDR
// uc_nation := nation_arabian ;
20822: LD_ADDR_OWVAR 21
20826: PUSH
20827: LD_INT 2
20829: ST_TO_ADDR
// hc_gallery :=  ;
20830: LD_ADDR_OWVAR 33
20834: PUSH
20835: LD_STRING 
20837: ST_TO_ADDR
// hc_name :=  ;
20838: LD_ADDR_OWVAR 26
20842: PUSH
20843: LD_STRING 
20845: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20846: LD_INT 1
20848: PPUSH
20849: LD_INT 11
20851: PPUSH
20852: LD_INT 10
20854: PPUSH
20855: CALL_OW 380
// un := CreateHuman ;
20859: LD_ADDR_VAR 0 1
20863: PUSH
20864: CALL_OW 44
20868: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_INT 1
20876: PPUSH
20877: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20881: LD_INT 35
20883: PPUSH
20884: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20888: LD_VAR 0 1
20892: PPUSH
20893: LD_INT 22
20895: PUSH
20896: LD_OWVAR 2
20900: PUSH
20901: EMPTY
20902: LIST
20903: LIST
20904: PPUSH
20905: CALL_OW 69
20909: PPUSH
20910: LD_VAR 0 1
20914: PPUSH
20915: CALL_OW 74
20919: PPUSH
20920: CALL_OW 115
// until IsDead ( un ) ;
20924: LD_VAR 0 1
20928: PPUSH
20929: CALL_OW 301
20933: IFFALSE 20881
// end ;
20935: PPOPN 1
20937: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20938: LD_EXP 26
20942: PUSH
20943: LD_EXP 66
20947: AND
20948: IFFALSE 20960
20950: GO 20952
20952: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20953: LD_STRING earthquake(getX(game), 0, 32)
20955: PPUSH
20956: CALL_OW 559
20960: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20961: LD_EXP 26
20965: PUSH
20966: LD_EXP 67
20970: AND
20971: IFFALSE 21062
20973: GO 20975
20975: DISABLE
20976: LD_INT 0
20978: PPUSH
// begin enable ;
20979: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20980: LD_ADDR_VAR 0 1
20984: PUSH
20985: LD_INT 22
20987: PUSH
20988: LD_OWVAR 2
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: LD_INT 21
20999: PUSH
21000: LD_INT 2
21002: PUSH
21003: EMPTY
21004: LIST
21005: LIST
21006: PUSH
21007: LD_INT 33
21009: PUSH
21010: LD_INT 3
21012: PUSH
21013: EMPTY
21014: LIST
21015: LIST
21016: PUSH
21017: EMPTY
21018: LIST
21019: LIST
21020: LIST
21021: PPUSH
21022: CALL_OW 69
21026: ST_TO_ADDR
// if not tmp then
21027: LD_VAR 0 1
21031: NOT
21032: IFFALSE 21036
// exit ;
21034: GO 21062
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21036: LD_VAR 0 1
21040: PUSH
21041: LD_INT 1
21043: PPUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 12
21053: ARRAY
21054: PPUSH
21055: LD_INT 1
21057: PPUSH
21058: CALL_OW 234
// end ;
21062: PPOPN 1
21064: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
21065: LD_EXP 26
21069: PUSH
21070: LD_EXP 68
21074: AND
21075: IFFALSE 21216
21077: GO 21079
21079: DISABLE
21080: LD_INT 0
21082: PPUSH
21083: PPUSH
21084: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21085: LD_ADDR_VAR 0 3
21089: PUSH
21090: LD_INT 22
21092: PUSH
21093: LD_OWVAR 2
21097: PUSH
21098: EMPTY
21099: LIST
21100: LIST
21101: PUSH
21102: LD_INT 25
21104: PUSH
21105: LD_INT 1
21107: PUSH
21108: EMPTY
21109: LIST
21110: LIST
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: PPUSH
21116: CALL_OW 69
21120: ST_TO_ADDR
// if not tmp then
21121: LD_VAR 0 3
21125: NOT
21126: IFFALSE 21130
// exit ;
21128: GO 21216
// un := tmp [ rand ( 1 , tmp ) ] ;
21130: LD_ADDR_VAR 0 2
21134: PUSH
21135: LD_VAR 0 3
21139: PUSH
21140: LD_INT 1
21142: PPUSH
21143: LD_VAR 0 3
21147: PPUSH
21148: CALL_OW 12
21152: ARRAY
21153: ST_TO_ADDR
// if Crawls ( un ) then
21154: LD_VAR 0 2
21158: PPUSH
21159: CALL_OW 318
21163: IFFALSE 21174
// ComWalk ( un ) ;
21165: LD_VAR 0 2
21169: PPUSH
21170: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
21174: LD_VAR 0 2
21178: PPUSH
21179: LD_INT 9
21181: PPUSH
21182: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
21186: LD_INT 28
21188: PPUSH
21189: LD_OWVAR 2
21193: PPUSH
21194: LD_INT 2
21196: PPUSH
21197: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21201: LD_INT 29
21203: PPUSH
21204: LD_OWVAR 2
21208: PPUSH
21209: LD_INT 2
21211: PPUSH
21212: CALL_OW 322
// end ;
21216: PPOPN 3
21218: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21219: LD_EXP 26
21223: PUSH
21224: LD_EXP 69
21228: AND
21229: IFFALSE 21340
21231: GO 21233
21233: DISABLE
21234: LD_INT 0
21236: PPUSH
21237: PPUSH
21238: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21239: LD_ADDR_VAR 0 3
21243: PUSH
21244: LD_INT 22
21246: PUSH
21247: LD_OWVAR 2
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: PUSH
21256: LD_INT 25
21258: PUSH
21259: LD_INT 1
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PUSH
21266: EMPTY
21267: LIST
21268: LIST
21269: PPUSH
21270: CALL_OW 69
21274: ST_TO_ADDR
// if not tmp then
21275: LD_VAR 0 3
21279: NOT
21280: IFFALSE 21284
// exit ;
21282: GO 21340
// un := tmp [ rand ( 1 , tmp ) ] ;
21284: LD_ADDR_VAR 0 2
21288: PUSH
21289: LD_VAR 0 3
21293: PUSH
21294: LD_INT 1
21296: PPUSH
21297: LD_VAR 0 3
21301: PPUSH
21302: CALL_OW 12
21306: ARRAY
21307: ST_TO_ADDR
// if Crawls ( un ) then
21308: LD_VAR 0 2
21312: PPUSH
21313: CALL_OW 318
21317: IFFALSE 21328
// ComWalk ( un ) ;
21319: LD_VAR 0 2
21323: PPUSH
21324: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21328: LD_VAR 0 2
21332: PPUSH
21333: LD_INT 8
21335: PPUSH
21336: CALL_OW 336
// end ;
21340: PPOPN 3
21342: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21343: LD_EXP 26
21347: PUSH
21348: LD_EXP 70
21352: AND
21353: IFFALSE 21497
21355: GO 21357
21357: DISABLE
21358: LD_INT 0
21360: PPUSH
21361: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21362: LD_ADDR_VAR 0 2
21366: PUSH
21367: LD_INT 22
21369: PUSH
21370: LD_OWVAR 2
21374: PUSH
21375: EMPTY
21376: LIST
21377: LIST
21378: PUSH
21379: LD_INT 21
21381: PUSH
21382: LD_INT 2
21384: PUSH
21385: EMPTY
21386: LIST
21387: LIST
21388: PUSH
21389: LD_INT 2
21391: PUSH
21392: LD_INT 34
21394: PUSH
21395: LD_INT 12
21397: PUSH
21398: EMPTY
21399: LIST
21400: LIST
21401: PUSH
21402: LD_INT 34
21404: PUSH
21405: LD_INT 51
21407: PUSH
21408: EMPTY
21409: LIST
21410: LIST
21411: PUSH
21412: LD_INT 34
21414: PUSH
21415: LD_INT 32
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PUSH
21422: EMPTY
21423: LIST
21424: LIST
21425: LIST
21426: LIST
21427: PUSH
21428: EMPTY
21429: LIST
21430: LIST
21431: LIST
21432: PPUSH
21433: CALL_OW 69
21437: ST_TO_ADDR
// if not tmp then
21438: LD_VAR 0 2
21442: NOT
21443: IFFALSE 21447
// exit ;
21445: GO 21497
// for i in tmp do
21447: LD_ADDR_VAR 0 1
21451: PUSH
21452: LD_VAR 0 2
21456: PUSH
21457: FOR_IN
21458: IFFALSE 21495
// if GetCargo ( i , mat_artifact ) = 0 then
21460: LD_VAR 0 1
21464: PPUSH
21465: LD_INT 4
21467: PPUSH
21468: CALL_OW 289
21472: PUSH
21473: LD_INT 0
21475: EQUAL
21476: IFFALSE 21493
// SetCargo ( i , mat_siberit , 100 ) ;
21478: LD_VAR 0 1
21482: PPUSH
21483: LD_INT 3
21485: PPUSH
21486: LD_INT 100
21488: PPUSH
21489: CALL_OW 290
21493: GO 21457
21495: POP
21496: POP
// end ;
21497: PPOPN 2
21499: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21500: LD_EXP 26
21504: PUSH
21505: LD_EXP 71
21509: AND
21510: IFFALSE 21663
21512: GO 21514
21514: DISABLE
21515: LD_INT 0
21517: PPUSH
21518: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21519: LD_ADDR_VAR 0 2
21523: PUSH
21524: LD_INT 22
21526: PUSH
21527: LD_OWVAR 2
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PPUSH
21536: CALL_OW 69
21540: ST_TO_ADDR
// if not tmp then
21541: LD_VAR 0 2
21545: NOT
21546: IFFALSE 21550
// exit ;
21548: GO 21663
// for i := 1 to 2 do
21550: LD_ADDR_VAR 0 1
21554: PUSH
21555: DOUBLE
21556: LD_INT 1
21558: DEC
21559: ST_TO_ADDR
21560: LD_INT 2
21562: PUSH
21563: FOR_TO
21564: IFFALSE 21661
// begin uc_side := your_side ;
21566: LD_ADDR_OWVAR 20
21570: PUSH
21571: LD_OWVAR 2
21575: ST_TO_ADDR
// uc_nation := nation_american ;
21576: LD_ADDR_OWVAR 21
21580: PUSH
21581: LD_INT 1
21583: ST_TO_ADDR
// vc_chassis := us_morphling ;
21584: LD_ADDR_OWVAR 37
21588: PUSH
21589: LD_INT 5
21591: ST_TO_ADDR
// vc_engine := engine_siberite ;
21592: LD_ADDR_OWVAR 39
21596: PUSH
21597: LD_INT 3
21599: ST_TO_ADDR
// vc_control := control_computer ;
21600: LD_ADDR_OWVAR 38
21604: PUSH
21605: LD_INT 3
21607: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21608: LD_ADDR_OWVAR 40
21612: PUSH
21613: LD_INT 10
21615: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
21616: CALL_OW 45
21620: PPUSH
21621: LD_VAR 0 2
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PPUSH
21630: CALL_OW 250
21634: PPUSH
21635: LD_VAR 0 2
21639: PUSH
21640: LD_INT 1
21642: ARRAY
21643: PPUSH
21644: CALL_OW 251
21648: PPUSH
21649: LD_INT 12
21651: PPUSH
21652: LD_INT 1
21654: PPUSH
21655: CALL_OW 50
// end ;
21659: GO 21563
21661: POP
21662: POP
// end ;
21663: PPOPN 2
21665: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21666: LD_EXP 26
21670: PUSH
21671: LD_EXP 72
21675: AND
21676: IFFALSE 21898
21678: GO 21680
21680: DISABLE
21681: LD_INT 0
21683: PPUSH
21684: PPUSH
21685: PPUSH
21686: PPUSH
21687: PPUSH
21688: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21689: LD_ADDR_VAR 0 6
21693: PUSH
21694: LD_INT 22
21696: PUSH
21697: LD_OWVAR 2
21701: PUSH
21702: EMPTY
21703: LIST
21704: LIST
21705: PUSH
21706: LD_INT 21
21708: PUSH
21709: LD_INT 1
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PUSH
21716: LD_INT 3
21718: PUSH
21719: LD_INT 23
21721: PUSH
21722: LD_INT 0
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: PUSH
21729: EMPTY
21730: LIST
21731: LIST
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: LIST
21737: PPUSH
21738: CALL_OW 69
21742: ST_TO_ADDR
// if not tmp then
21743: LD_VAR 0 6
21747: NOT
21748: IFFALSE 21752
// exit ;
21750: GO 21898
// s1 := rand ( 1 , 4 ) ;
21752: LD_ADDR_VAR 0 2
21756: PUSH
21757: LD_INT 1
21759: PPUSH
21760: LD_INT 4
21762: PPUSH
21763: CALL_OW 12
21767: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21768: LD_ADDR_VAR 0 4
21772: PUSH
21773: LD_VAR 0 6
21777: PUSH
21778: LD_INT 1
21780: ARRAY
21781: PPUSH
21782: LD_VAR 0 2
21786: PPUSH
21787: CALL_OW 259
21791: ST_TO_ADDR
// if s1 = 1 then
21792: LD_VAR 0 2
21796: PUSH
21797: LD_INT 1
21799: EQUAL
21800: IFFALSE 21820
// s2 := rand ( 2 , 4 ) else
21802: LD_ADDR_VAR 0 3
21806: PUSH
21807: LD_INT 2
21809: PPUSH
21810: LD_INT 4
21812: PPUSH
21813: CALL_OW 12
21817: ST_TO_ADDR
21818: GO 21828
// s2 := 1 ;
21820: LD_ADDR_VAR 0 3
21824: PUSH
21825: LD_INT 1
21827: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21828: LD_ADDR_VAR 0 5
21832: PUSH
21833: LD_VAR 0 6
21837: PUSH
21838: LD_INT 1
21840: ARRAY
21841: PPUSH
21842: LD_VAR 0 3
21846: PPUSH
21847: CALL_OW 259
21851: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21852: LD_VAR 0 6
21856: PUSH
21857: LD_INT 1
21859: ARRAY
21860: PPUSH
21861: LD_VAR 0 2
21865: PPUSH
21866: LD_VAR 0 5
21870: PPUSH
21871: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21875: LD_VAR 0 6
21879: PUSH
21880: LD_INT 1
21882: ARRAY
21883: PPUSH
21884: LD_VAR 0 3
21888: PPUSH
21889: LD_VAR 0 4
21893: PPUSH
21894: CALL_OW 237
// end ;
21898: PPOPN 6
21900: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21901: LD_EXP 26
21905: PUSH
21906: LD_EXP 73
21910: AND
21911: IFFALSE 21990
21913: GO 21915
21915: DISABLE
21916: LD_INT 0
21918: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21919: LD_ADDR_VAR 0 1
21923: PUSH
21924: LD_INT 22
21926: PUSH
21927: LD_OWVAR 2
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: PUSH
21936: LD_INT 30
21938: PUSH
21939: LD_INT 3
21941: PUSH
21942: EMPTY
21943: LIST
21944: LIST
21945: PUSH
21946: EMPTY
21947: LIST
21948: LIST
21949: PPUSH
21950: CALL_OW 69
21954: ST_TO_ADDR
// if not tmp then
21955: LD_VAR 0 1
21959: NOT
21960: IFFALSE 21964
// exit ;
21962: GO 21990
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21964: LD_VAR 0 1
21968: PUSH
21969: LD_INT 1
21971: PPUSH
21972: LD_VAR 0 1
21976: PPUSH
21977: CALL_OW 12
21981: ARRAY
21982: PPUSH
21983: LD_INT 1
21985: PPUSH
21986: CALL_OW 234
// end ;
21990: PPOPN 1
21992: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21993: LD_EXP 26
21997: PUSH
21998: LD_EXP 74
22002: AND
22003: IFFALSE 22115
22005: GO 22007
22007: DISABLE
22008: LD_INT 0
22010: PPUSH
22011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
22012: LD_ADDR_VAR 0 2
22016: PUSH
22017: LD_INT 22
22019: PUSH
22020: LD_OWVAR 2
22024: PUSH
22025: EMPTY
22026: LIST
22027: LIST
22028: PUSH
22029: LD_INT 2
22031: PUSH
22032: LD_INT 30
22034: PUSH
22035: LD_INT 27
22037: PUSH
22038: EMPTY
22039: LIST
22040: LIST
22041: PUSH
22042: LD_INT 30
22044: PUSH
22045: LD_INT 26
22047: PUSH
22048: EMPTY
22049: LIST
22050: LIST
22051: PUSH
22052: LD_INT 30
22054: PUSH
22055: LD_INT 28
22057: PUSH
22058: EMPTY
22059: LIST
22060: LIST
22061: PUSH
22062: EMPTY
22063: LIST
22064: LIST
22065: LIST
22066: LIST
22067: PUSH
22068: EMPTY
22069: LIST
22070: LIST
22071: PPUSH
22072: CALL_OW 69
22076: ST_TO_ADDR
// if not tmp then
22077: LD_VAR 0 2
22081: NOT
22082: IFFALSE 22086
// exit ;
22084: GO 22115
// for i in tmp do
22086: LD_ADDR_VAR 0 1
22090: PUSH
22091: LD_VAR 0 2
22095: PUSH
22096: FOR_IN
22097: IFFALSE 22113
// SetLives ( i , 1 ) ;
22099: LD_VAR 0 1
22103: PPUSH
22104: LD_INT 1
22106: PPUSH
22107: CALL_OW 234
22111: GO 22096
22113: POP
22114: POP
// end ;
22115: PPOPN 2
22117: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
22118: LD_EXP 26
22122: PUSH
22123: LD_EXP 75
22127: AND
22128: IFFALSE 22402
22130: GO 22132
22132: DISABLE
22133: LD_INT 0
22135: PPUSH
22136: PPUSH
22137: PPUSH
// begin i := rand ( 1 , 7 ) ;
22138: LD_ADDR_VAR 0 1
22142: PUSH
22143: LD_INT 1
22145: PPUSH
22146: LD_INT 7
22148: PPUSH
22149: CALL_OW 12
22153: ST_TO_ADDR
// case i of 1 :
22154: LD_VAR 0 1
22158: PUSH
22159: LD_INT 1
22161: DOUBLE
22162: EQUAL
22163: IFTRUE 22167
22165: GO 22177
22167: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
22168: LD_STRING earthquake(getX(game), 0, 32)
22170: PPUSH
22171: CALL_OW 559
22175: GO 22402
22177: LD_INT 2
22179: DOUBLE
22180: EQUAL
22181: IFTRUE 22185
22183: GO 22199
22185: POP
// begin ToLua ( displayStucuk(); ) ;
22186: LD_STRING displayStucuk();
22188: PPUSH
22189: CALL_OW 559
// ResetFog ;
22193: CALL_OW 335
// end ; 3 :
22197: GO 22402
22199: LD_INT 3
22201: DOUBLE
22202: EQUAL
22203: IFTRUE 22207
22205: GO 22311
22207: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22208: LD_ADDR_VAR 0 2
22212: PUSH
22213: LD_INT 22
22215: PUSH
22216: LD_OWVAR 2
22220: PUSH
22221: EMPTY
22222: LIST
22223: LIST
22224: PUSH
22225: LD_INT 25
22227: PUSH
22228: LD_INT 1
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PPUSH
22239: CALL_OW 69
22243: ST_TO_ADDR
// if not tmp then
22244: LD_VAR 0 2
22248: NOT
22249: IFFALSE 22253
// exit ;
22251: GO 22402
// un := tmp [ rand ( 1 , tmp ) ] ;
22253: LD_ADDR_VAR 0 3
22257: PUSH
22258: LD_VAR 0 2
22262: PUSH
22263: LD_INT 1
22265: PPUSH
22266: LD_VAR 0 2
22270: PPUSH
22271: CALL_OW 12
22275: ARRAY
22276: ST_TO_ADDR
// if Crawls ( un ) then
22277: LD_VAR 0 3
22281: PPUSH
22282: CALL_OW 318
22286: IFFALSE 22297
// ComWalk ( un ) ;
22288: LD_VAR 0 3
22292: PPUSH
22293: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22297: LD_VAR 0 3
22301: PPUSH
22302: LD_INT 8
22304: PPUSH
22305: CALL_OW 336
// end ; 4 :
22309: GO 22402
22311: LD_INT 4
22313: DOUBLE
22314: EQUAL
22315: IFTRUE 22319
22317: GO 22380
22319: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22320: LD_ADDR_VAR 0 2
22324: PUSH
22325: LD_INT 22
22327: PUSH
22328: LD_OWVAR 2
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 30
22339: PUSH
22340: LD_INT 29
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: PPUSH
22351: CALL_OW 69
22355: ST_TO_ADDR
// if not tmp then
22356: LD_VAR 0 2
22360: NOT
22361: IFFALSE 22365
// exit ;
22363: GO 22402
// DestroyUnit ( tmp [ 1 ] ) ;
22365: LD_VAR 0 2
22369: PUSH
22370: LD_INT 1
22372: ARRAY
22373: PPUSH
22374: CALL_OW 65
// end ; 5 .. 7 :
22378: GO 22402
22380: LD_INT 5
22382: DOUBLE
22383: GREATEREQUAL
22384: IFFALSE 22392
22386: LD_INT 7
22388: DOUBLE
22389: LESSEQUAL
22390: IFTRUE 22394
22392: GO 22401
22394: POP
// StreamSibBomb ; end ;
22395: CALL 18682 0 0
22399: GO 22402
22401: POP
// end ;
22402: PPOPN 3
22404: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22405: LD_EXP 26
22409: PUSH
22410: LD_EXP 76
22414: AND
22415: IFFALSE 22571
22417: GO 22419
22419: DISABLE
22420: LD_INT 0
22422: PPUSH
22423: PPUSH
22424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22425: LD_ADDR_VAR 0 2
22429: PUSH
22430: LD_INT 81
22432: PUSH
22433: LD_OWVAR 2
22437: PUSH
22438: EMPTY
22439: LIST
22440: LIST
22441: PUSH
22442: LD_INT 2
22444: PUSH
22445: LD_INT 21
22447: PUSH
22448: LD_INT 1
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: PUSH
22455: LD_INT 21
22457: PUSH
22458: LD_INT 2
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: PUSH
22465: EMPTY
22466: LIST
22467: LIST
22468: LIST
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: PPUSH
22474: CALL_OW 69
22478: ST_TO_ADDR
// if not tmp then
22479: LD_VAR 0 2
22483: NOT
22484: IFFALSE 22488
// exit ;
22486: GO 22571
// p := 0 ;
22488: LD_ADDR_VAR 0 3
22492: PUSH
22493: LD_INT 0
22495: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22496: LD_INT 35
22498: PPUSH
22499: CALL_OW 67
// p := p + 1 ;
22503: LD_ADDR_VAR 0 3
22507: PUSH
22508: LD_VAR 0 3
22512: PUSH
22513: LD_INT 1
22515: PLUS
22516: ST_TO_ADDR
// for i in tmp do
22517: LD_ADDR_VAR 0 1
22521: PUSH
22522: LD_VAR 0 2
22526: PUSH
22527: FOR_IN
22528: IFFALSE 22559
// if GetLives ( i ) < 1000 then
22530: LD_VAR 0 1
22534: PPUSH
22535: CALL_OW 256
22539: PUSH
22540: LD_INT 1000
22542: LESS
22543: IFFALSE 22557
// SetLives ( i , 1000 ) ;
22545: LD_VAR 0 1
22549: PPUSH
22550: LD_INT 1000
22552: PPUSH
22553: CALL_OW 234
22557: GO 22527
22559: POP
22560: POP
// until p > 20 ;
22561: LD_VAR 0 3
22565: PUSH
22566: LD_INT 20
22568: GREATER
22569: IFFALSE 22496
// end ;
22571: PPOPN 3
22573: END
// every 0 0$1 trigger StreamModeActive and sTime do
22574: LD_EXP 26
22578: PUSH
22579: LD_EXP 77
22583: AND
22584: IFFALSE 22619
22586: GO 22588
22588: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22589: LD_INT 28
22591: PPUSH
22592: LD_OWVAR 2
22596: PPUSH
22597: LD_INT 2
22599: PPUSH
22600: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22604: LD_INT 30
22606: PPUSH
22607: LD_OWVAR 2
22611: PPUSH
22612: LD_INT 2
22614: PPUSH
22615: CALL_OW 322
// end ;
22619: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22620: LD_EXP 26
22624: PUSH
22625: LD_EXP 78
22629: AND
22630: IFFALSE 22751
22632: GO 22634
22634: DISABLE
22635: LD_INT 0
22637: PPUSH
22638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22639: LD_ADDR_VAR 0 2
22643: PUSH
22644: LD_INT 22
22646: PUSH
22647: LD_OWVAR 2
22651: PUSH
22652: EMPTY
22653: LIST
22654: LIST
22655: PUSH
22656: LD_INT 21
22658: PUSH
22659: LD_INT 1
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: PUSH
22666: LD_INT 3
22668: PUSH
22669: LD_INT 23
22671: PUSH
22672: LD_INT 0
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: PUSH
22683: EMPTY
22684: LIST
22685: LIST
22686: LIST
22687: PPUSH
22688: CALL_OW 69
22692: ST_TO_ADDR
// if not tmp then
22693: LD_VAR 0 2
22697: NOT
22698: IFFALSE 22702
// exit ;
22700: GO 22751
// for i in tmp do
22702: LD_ADDR_VAR 0 1
22706: PUSH
22707: LD_VAR 0 2
22711: PUSH
22712: FOR_IN
22713: IFFALSE 22749
// begin if Crawls ( i ) then
22715: LD_VAR 0 1
22719: PPUSH
22720: CALL_OW 318
22724: IFFALSE 22735
// ComWalk ( i ) ;
22726: LD_VAR 0 1
22730: PPUSH
22731: CALL_OW 138
// SetClass ( i , 2 ) ;
22735: LD_VAR 0 1
22739: PPUSH
22740: LD_INT 2
22742: PPUSH
22743: CALL_OW 336
// end ;
22747: GO 22712
22749: POP
22750: POP
// end ;
22751: PPOPN 2
22753: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22754: LD_EXP 26
22758: PUSH
22759: LD_EXP 79
22763: AND
22764: IFFALSE 23045
22766: GO 22768
22768: DISABLE
22769: LD_INT 0
22771: PPUSH
22772: PPUSH
22773: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22774: LD_OWVAR 2
22778: PPUSH
22779: LD_INT 9
22781: PPUSH
22782: LD_INT 1
22784: PPUSH
22785: LD_INT 1
22787: PPUSH
22788: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22792: LD_INT 9
22794: PPUSH
22795: LD_OWVAR 2
22799: PPUSH
22800: CALL_OW 343
// uc_side := 9 ;
22804: LD_ADDR_OWVAR 20
22808: PUSH
22809: LD_INT 9
22811: ST_TO_ADDR
// uc_nation := 2 ;
22812: LD_ADDR_OWVAR 21
22816: PUSH
22817: LD_INT 2
22819: ST_TO_ADDR
// hc_name := Dark Warrior ;
22820: LD_ADDR_OWVAR 26
22824: PUSH
22825: LD_STRING Dark Warrior
22827: ST_TO_ADDR
// hc_gallery :=  ;
22828: LD_ADDR_OWVAR 33
22832: PUSH
22833: LD_STRING 
22835: ST_TO_ADDR
// hc_noskilllimit := true ;
22836: LD_ADDR_OWVAR 76
22840: PUSH
22841: LD_INT 1
22843: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22844: LD_ADDR_OWVAR 31
22848: PUSH
22849: LD_INT 30
22851: PUSH
22852: LD_INT 30
22854: PUSH
22855: LD_INT 30
22857: PUSH
22858: LD_INT 30
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: LIST
22865: LIST
22866: ST_TO_ADDR
// un := CreateHuman ;
22867: LD_ADDR_VAR 0 3
22871: PUSH
22872: CALL_OW 44
22876: ST_TO_ADDR
// hc_noskilllimit := false ;
22877: LD_ADDR_OWVAR 76
22881: PUSH
22882: LD_INT 0
22884: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22885: LD_VAR 0 3
22889: PPUSH
22890: LD_INT 1
22892: PPUSH
22893: CALL_OW 51
// p := 0 ;
22897: LD_ADDR_VAR 0 2
22901: PUSH
22902: LD_INT 0
22904: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22905: LD_INT 35
22907: PPUSH
22908: CALL_OW 67
// p := p + 1 ;
22912: LD_ADDR_VAR 0 2
22916: PUSH
22917: LD_VAR 0 2
22921: PUSH
22922: LD_INT 1
22924: PLUS
22925: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22926: LD_VAR 0 3
22930: PPUSH
22931: CALL_OW 256
22935: PUSH
22936: LD_INT 1000
22938: LESS
22939: IFFALSE 22953
// SetLives ( un , 1000 ) ;
22941: LD_VAR 0 3
22945: PPUSH
22946: LD_INT 1000
22948: PPUSH
22949: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22953: LD_VAR 0 3
22957: PPUSH
22958: LD_INT 81
22960: PUSH
22961: LD_OWVAR 2
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: PUSH
22970: LD_INT 91
22972: PUSH
22973: LD_VAR 0 3
22977: PUSH
22978: LD_INT 30
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: LIST
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PPUSH
22990: CALL_OW 69
22994: PPUSH
22995: LD_VAR 0 3
22999: PPUSH
23000: CALL_OW 74
23004: PPUSH
23005: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
23009: LD_VAR 0 2
23013: PUSH
23014: LD_INT 60
23016: GREATER
23017: PUSH
23018: LD_VAR 0 3
23022: PPUSH
23023: CALL_OW 301
23027: OR
23028: IFFALSE 22905
// if un then
23030: LD_VAR 0 3
23034: IFFALSE 23045
// RemoveUnit ( un ) ;
23036: LD_VAR 0 3
23040: PPUSH
23041: CALL_OW 64
// end ; end_of_file
23045: PPOPN 3
23047: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
23048: LD_INT 0
23050: PPUSH
23051: PPUSH
23052: PPUSH
23053: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
23054: LD_VAR 0 1
23058: PPUSH
23059: CALL_OW 264
23063: PUSH
23064: LD_EXP 25
23068: EQUAL
23069: IFFALSE 23141
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
23071: LD_INT 68
23073: PPUSH
23074: LD_VAR 0 1
23078: PPUSH
23079: CALL_OW 255
23083: PPUSH
23084: CALL_OW 321
23088: PUSH
23089: LD_INT 2
23091: EQUAL
23092: IFFALSE 23104
// eff := 70 else
23094: LD_ADDR_VAR 0 4
23098: PUSH
23099: LD_INT 70
23101: ST_TO_ADDR
23102: GO 23112
// eff := 30 ;
23104: LD_ADDR_VAR 0 4
23108: PUSH
23109: LD_INT 30
23111: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
23112: LD_VAR 0 1
23116: PPUSH
23117: CALL_OW 250
23121: PPUSH
23122: LD_VAR 0 1
23126: PPUSH
23127: CALL_OW 251
23131: PPUSH
23132: LD_VAR 0 4
23136: PPUSH
23137: CALL_OW 495
// end ; end ;
23141: LD_VAR 0 2
23145: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
23146: LD_INT 0
23148: PPUSH
// end ;
23149: LD_VAR 0 4
23153: RET
// export function SOS_Command ( cmd ) ; begin
23154: LD_INT 0
23156: PPUSH
// end ;
23157: LD_VAR 0 2
23161: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
23162: LD_VAR 0 1
23166: PUSH
23167: LD_INT 255
23169: EQUAL
23170: PUSH
23171: LD_VAR 0 2
23175: PPUSH
23176: CALL_OW 264
23180: PUSH
23181: LD_INT 14
23183: PUSH
23184: LD_INT 53
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: IN
23191: AND
23192: PUSH
23193: LD_VAR 0 4
23197: PPUSH
23198: LD_VAR 0 5
23202: PPUSH
23203: CALL_OW 488
23207: AND
23208: IFFALSE 23232
// CutTreeXYR ( unit , x , y , 12 ) ;
23210: LD_VAR 0 2
23214: PPUSH
23215: LD_VAR 0 4
23219: PPUSH
23220: LD_VAR 0 5
23224: PPUSH
23225: LD_INT 12
23227: PPUSH
23228: CALL 23235 0 4
// end ;
23232: PPOPN 5
23234: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
23235: LD_INT 0
23237: PPUSH
23238: PPUSH
23239: PPUSH
23240: PPUSH
23241: PPUSH
23242: PPUSH
23243: PPUSH
23244: PPUSH
23245: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
23246: LD_VAR 0 1
23250: NOT
23251: PUSH
23252: LD_VAR 0 2
23256: PPUSH
23257: LD_VAR 0 3
23261: PPUSH
23262: CALL_OW 488
23266: NOT
23267: OR
23268: PUSH
23269: LD_VAR 0 4
23273: NOT
23274: OR
23275: IFFALSE 23279
// exit ;
23277: GO 23619
// list := [ ] ;
23279: LD_ADDR_VAR 0 13
23283: PUSH
23284: EMPTY
23285: ST_TO_ADDR
// if x - r < 0 then
23286: LD_VAR 0 2
23290: PUSH
23291: LD_VAR 0 4
23295: MINUS
23296: PUSH
23297: LD_INT 0
23299: LESS
23300: IFFALSE 23312
// min_x := 0 else
23302: LD_ADDR_VAR 0 7
23306: PUSH
23307: LD_INT 0
23309: ST_TO_ADDR
23310: GO 23328
// min_x := x - r ;
23312: LD_ADDR_VAR 0 7
23316: PUSH
23317: LD_VAR 0 2
23321: PUSH
23322: LD_VAR 0 4
23326: MINUS
23327: ST_TO_ADDR
// if y - r < 0 then
23328: LD_VAR 0 3
23332: PUSH
23333: LD_VAR 0 4
23337: MINUS
23338: PUSH
23339: LD_INT 0
23341: LESS
23342: IFFALSE 23354
// min_y := 0 else
23344: LD_ADDR_VAR 0 8
23348: PUSH
23349: LD_INT 0
23351: ST_TO_ADDR
23352: GO 23370
// min_y := y - r ;
23354: LD_ADDR_VAR 0 8
23358: PUSH
23359: LD_VAR 0 3
23363: PUSH
23364: LD_VAR 0 4
23368: MINUS
23369: ST_TO_ADDR
// max_x := x + r ;
23370: LD_ADDR_VAR 0 9
23374: PUSH
23375: LD_VAR 0 2
23379: PUSH
23380: LD_VAR 0 4
23384: PLUS
23385: ST_TO_ADDR
// max_y := y + r ;
23386: LD_ADDR_VAR 0 10
23390: PUSH
23391: LD_VAR 0 3
23395: PUSH
23396: LD_VAR 0 4
23400: PLUS
23401: ST_TO_ADDR
// for _x = min_x to max_x do
23402: LD_ADDR_VAR 0 11
23406: PUSH
23407: DOUBLE
23408: LD_VAR 0 7
23412: DEC
23413: ST_TO_ADDR
23414: LD_VAR 0 9
23418: PUSH
23419: FOR_TO
23420: IFFALSE 23537
// for _y = min_y to max_y do
23422: LD_ADDR_VAR 0 12
23426: PUSH
23427: DOUBLE
23428: LD_VAR 0 8
23432: DEC
23433: ST_TO_ADDR
23434: LD_VAR 0 10
23438: PUSH
23439: FOR_TO
23440: IFFALSE 23533
// begin if not ValidHex ( _x , _y ) then
23442: LD_VAR 0 11
23446: PPUSH
23447: LD_VAR 0 12
23451: PPUSH
23452: CALL_OW 488
23456: NOT
23457: IFFALSE 23461
// continue ;
23459: GO 23439
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
23461: LD_VAR 0 11
23465: PPUSH
23466: LD_VAR 0 12
23470: PPUSH
23471: CALL_OW 351
23475: PUSH
23476: LD_VAR 0 11
23480: PPUSH
23481: LD_VAR 0 12
23485: PPUSH
23486: CALL_OW 554
23490: AND
23491: IFFALSE 23531
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
23493: LD_ADDR_VAR 0 13
23497: PUSH
23498: LD_VAR 0 13
23502: PPUSH
23503: LD_VAR 0 13
23507: PUSH
23508: LD_INT 1
23510: PLUS
23511: PPUSH
23512: LD_VAR 0 11
23516: PUSH
23517: LD_VAR 0 12
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: PPUSH
23526: CALL_OW 2
23530: ST_TO_ADDR
// end ;
23531: GO 23439
23533: POP
23534: POP
23535: GO 23419
23537: POP
23538: POP
// if not list then
23539: LD_VAR 0 13
23543: NOT
23544: IFFALSE 23548
// exit ;
23546: GO 23619
// for i in list do
23548: LD_ADDR_VAR 0 6
23552: PUSH
23553: LD_VAR 0 13
23557: PUSH
23558: FOR_IN
23559: IFFALSE 23617
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
23561: LD_VAR 0 1
23565: PPUSH
23566: LD_STRING M
23568: PUSH
23569: LD_VAR 0 6
23573: PUSH
23574: LD_INT 1
23576: ARRAY
23577: PUSH
23578: LD_VAR 0 6
23582: PUSH
23583: LD_INT 2
23585: ARRAY
23586: PUSH
23587: LD_INT 0
23589: PUSH
23590: LD_INT 0
23592: PUSH
23593: LD_INT 0
23595: PUSH
23596: LD_INT 0
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: LIST
23607: PUSH
23608: EMPTY
23609: LIST
23610: PPUSH
23611: CALL_OW 447
23615: GO 23558
23617: POP
23618: POP
// end ;
23619: LD_VAR 0 5
23623: RET
