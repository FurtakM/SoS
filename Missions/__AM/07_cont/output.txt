// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 1598 0 0
// PrepareRussians ;
  20: CALL 3140 0 0
// PrepareAmericans ;
  24: CALL 2083 0 0
// Action ;
  28: CALL 6871 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 30 30$00 , 27 27$00 , 24 24$00 ] [ Difficulty ] , [ 36 36$00 , 33 33$00 , 30 30$00 ] [ Difficulty ] , [ 42 42$00 , 39 39$00 , 36 36$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 63000
  75: PUSH
  76: LD_INT 56700
  78: PUSH
  79: LD_INT 50400
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 75600
  95: PUSH
  96: LD_INT 69300
  98: PUSH
  99: LD_INT 63000
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 88200
 115: PUSH
 116: LD_INT 81900
 118: PUSH
 119: LD_INT 75600
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// if not un or not IsOk ( un ) then
 742: LD_VAR 0 1
 746: NOT
 747: PUSH
 748: LD_VAR 0 1
 752: PPUSH
 753: CALL_OW 302
 757: NOT
 758: OR
 759: IFFALSE 763
// exit ;
 761: GO 1203
// side := GetSide ( un ) ;
 763: LD_ADDR_VAR 0 9
 767: PUSH
 768: LD_VAR 0 1
 772: PPUSH
 773: CALL_OW 255
 777: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 778: LD_ADDR_VAR 0 7
 782: PUSH
 783: LD_INT 22
 785: PUSH
 786: LD_VAR 0 9
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 32
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 50
 807: PUSH
 808: EMPTY
 809: LIST
 810: PUSH
 811: LD_INT 58
 813: PUSH
 814: EMPTY
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: PUSH
 828: LD_VAR 0 2
 832: DIFF
 833: ST_TO_ADDR
// if not filter then
 834: LD_VAR 0 7
 838: NOT
 839: IFFALSE 1068
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 841: LD_ADDR_VAR 0 7
 845: PUSH
 846: LD_INT 22
 848: PUSH
 849: LD_VAR 0 9
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 5
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PPUSH
 872: CALL_OW 69
 876: ST_TO_ADDR
// if debug then
 877: LD_EXP 1
 881: IFFALSE 900
// display_strings := [ filter , 1 ] ;
 883: LD_ADDR_OWVAR 47
 887: PUSH
 888: LD_VAR 0 7
 892: PUSH
 893: LD_STRING 1
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: ST_TO_ADDR
// if not filter then
 900: LD_VAR 0 7
 904: NOT
 905: IFFALSE 928
// begin ComMoveXY ( un , x , y ) ;
 907: LD_VAR 0 1
 911: PPUSH
 912: LD_VAR 0 3
 916: PPUSH
 917: LD_VAR 0 4
 921: PPUSH
 922: CALL_OW 111
// exit ;
 926: GO 1203
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 928: LD_ADDR_VAR 0 8
 932: PUSH
 933: LD_VAR 0 7
 937: PPUSH
 938: LD_VAR 0 1
 942: PPUSH
 943: CALL_OW 74
 947: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 948: LD_VAR 0 8
 952: PPUSH
 953: CALL_OW 313
 957: PUSH
 958: LD_INT 6
 960: EQUAL
 961: IFFALSE 981
// filter := filter diff t else
 963: LD_ADDR_VAR 0 7
 967: PUSH
 968: LD_VAR 0 7
 972: PUSH
 973: LD_VAR 0 8
 977: DIFF
 978: ST_TO_ADDR
 979: GO 983
// break ;
 981: GO 1005
// until UnitsInside ( t ) < 6 or not filter ;
 983: LD_VAR 0 8
 987: PPUSH
 988: CALL_OW 313
 992: PUSH
 993: LD_INT 6
 995: LESS
 996: PUSH
 997: LD_VAR 0 7
1001: NOT
1002: OR
1003: IFFALSE 928
// display_strings := [ filter , t ] ;
1005: LD_ADDR_OWVAR 47
1009: PUSH
1010: LD_VAR 0 7
1014: PUSH
1015: LD_VAR 0 8
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: ST_TO_ADDR
// if not filter then
1024: LD_VAR 0 7
1028: NOT
1029: IFFALSE 1052
// ComMoveXY ( un , x , y ) else
1031: LD_VAR 0 1
1035: PPUSH
1036: LD_VAR 0 3
1040: PPUSH
1041: LD_VAR 0 4
1045: PPUSH
1046: CALL_OW 111
1050: GO 1066
// ComEnterUnit ( un , t ) ;
1052: LD_VAR 0 1
1056: PPUSH
1057: LD_VAR 0 8
1061: PPUSH
1062: CALL_OW 120
// end else
1066: GO 1203
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
1068: LD_ADDR_VAR 0 8
1072: PUSH
1073: LD_VAR 0 7
1077: PPUSH
1078: LD_VAR 0 1
1082: PPUSH
1083: CALL_OW 74
1087: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
1088: LD_VAR 0 8
1092: PPUSH
1093: CALL_OW 110
1097: PUSH
1098: LD_INT 7
1100: EQUAL
1101: IFFALSE 1119
// filter := filter diff t ;
1103: LD_ADDR_VAR 0 7
1107: PUSH
1108: LD_VAR 0 7
1112: PUSH
1113: LD_VAR 0 8
1117: DIFF
1118: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1119: LD_VAR 0 8
1123: PPUSH
1124: CALL_OW 110
1128: PUSH
1129: LD_INT 7
1131: NONEQUAL
1132: PUSH
1133: LD_VAR 0 7
1137: NOT
1138: OR
1139: IFFALSE 1068
// if GetTag ( t ) <> 7 then
1141: LD_VAR 0 8
1145: PPUSH
1146: CALL_OW 110
1150: PUSH
1151: LD_INT 7
1153: NONEQUAL
1154: IFFALSE 1184
// begin SetTag ( t , 7 ) ;
1156: LD_VAR 0 8
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_VAR 0 8
1177: PPUSH
1178: CALL_OW 120
// end else
1182: GO 1203
// ComMoveXY ( un , x , y ) ;
1184: LD_VAR 0 1
1188: PPUSH
1189: LD_VAR 0 3
1193: PPUSH
1194: LD_VAR 0 4
1198: PPUSH
1199: CALL_OW 111
// end ; end ;
1203: LD_VAR 0 5
1207: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1208: LD_INT 0
1210: PPUSH
1211: PPUSH
1212: PPUSH
// if not base then
1213: LD_VAR 0 1
1217: NOT
1218: IFFALSE 1222
// exit ;
1220: GO 1280
// tmp := GetEnergy ( GetBase ( base ) ) ;
1222: LD_ADDR_VAR 0 4
1226: PUSH
1227: LD_VAR 0 1
1231: PPUSH
1232: CALL_OW 274
1236: PPUSH
1237: CALL_OW 278
1241: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1242: LD_VAR 0 4
1246: PUSH
1247: LD_INT 1
1249: ARRAY
1250: PUSH
1251: LD_VAR 0 4
1255: PUSH
1256: LD_INT 4
1258: ARRAY
1259: GREATER
1260: IFFALSE 1272
// result := true else
1262: LD_ADDR_VAR 0 2
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
1270: GO 1280
// result := false ;
1272: LD_ADDR_VAR 0 2
1276: PUSH
1277: LD_INT 0
1279: ST_TO_ADDR
// end ;
1280: LD_VAR 0 2
1284: RET
// export function FilterPeople ( side ) ; begin
1285: LD_INT 0
1287: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1288: LD_ADDR_VAR 0 2
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_VAR 0 1
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
// end ;
1324: LD_VAR 0 2
1328: RET
// export function FilterDrivers ( side ) ; begin
1329: LD_INT 0
1331: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1332: LD_ADDR_VAR 0 2
1336: PUSH
1337: LD_INT 22
1339: PUSH
1340: LD_VAR 0 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: PUSH
1349: LD_INT 3
1351: PUSH
1352: LD_INT 56
1354: PUSH
1355: EMPTY
1356: LIST
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: EMPTY
1363: LIST
1364: LIST
1365: PPUSH
1366: CALL_OW 69
1370: ST_TO_ADDR
// end ;
1371: LD_VAR 0 2
1375: RET
// export function FilterPeopleArea ( side , area ) ; begin
1376: LD_INT 0
1378: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1379: LD_ADDR_VAR 0 3
1383: PUSH
1384: LD_VAR 0 2
1388: PPUSH
1389: LD_INT 22
1391: PUSH
1392: LD_INT 1
1394: PUSH
1395: EMPTY
1396: LIST
1397: LIST
1398: PUSH
1399: LD_INT 21
1401: PUSH
1402: LD_INT 1
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL_OW 70
1417: ST_TO_ADDR
// end ;
1418: LD_VAR 0 3
1422: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1423: LD_INT 0
1425: PPUSH
1426: PPUSH
1427: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1428: LD_ADDR_VAR 0 5
1432: PUSH
1433: LD_VAR 0 2
1437: PPUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 21
1450: PUSH
1451: LD_INT 2
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: LD_INT 3
1460: PUSH
1461: LD_INT 58
1463: PUSH
1464: EMPTY
1465: LIST
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: PUSH
1471: EMPTY
1472: LIST
1473: LIST
1474: LIST
1475: PPUSH
1476: CALL_OW 70
1480: ST_TO_ADDR
// result := [ ] ;
1481: LD_ADDR_VAR 0 3
1485: PUSH
1486: EMPTY
1487: ST_TO_ADDR
// if not tmp then
1488: LD_VAR 0 5
1492: NOT
1493: IFFALSE 1497
// exit ;
1495: GO 1549
// for i in tmp do
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_VAR 0 5
1506: PUSH
1507: FOR_IN
1508: IFFALSE 1533
// result := result ^ IsDrivenBy ( i ) ;
1510: LD_ADDR_VAR 0 3
1514: PUSH
1515: LD_VAR 0 3
1519: PUSH
1520: LD_VAR 0 4
1524: PPUSH
1525: CALL_OW 311
1529: ADD
1530: ST_TO_ADDR
1531: GO 1507
1533: POP
1534: POP
// result := result diff 0 ;
1535: LD_ADDR_VAR 0 3
1539: PUSH
1540: LD_VAR 0 3
1544: PUSH
1545: LD_INT 0
1547: DIFF
1548: ST_TO_ADDR
// end ;
1549: LD_VAR 0 3
1553: RET
// export function FilterBuildings ( side ) ; begin
1554: LD_INT 0
1556: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_INT 22
1564: PUSH
1565: LD_VAR 0 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PPUSH
1588: CALL_OW 69
1592: ST_TO_ADDR
// end ;
1593: LD_VAR 0 2
1597: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
1598: LD_INT 0
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
// uc_side = 0 ;
1604: LD_ADDR_OWVAR 20
1608: PUSH
1609: LD_INT 0
1611: ST_TO_ADDR
// uc_nation = 0 ;
1612: LD_ADDR_OWVAR 21
1616: PUSH
1617: LD_INT 0
1619: ST_TO_ADDR
// nat_area := wildArea ;
1620: LD_ADDR_VAR 0 4
1624: PUSH
1625: LD_INT 3
1627: ST_TO_ADDR
// InitHc ;
1628: CALL_OW 19
// for i = 1 to 4 do
1632: LD_ADDR_VAR 0 2
1636: PUSH
1637: DOUBLE
1638: LD_INT 1
1640: DEC
1641: ST_TO_ADDR
1642: LD_INT 4
1644: PUSH
1645: FOR_TO
1646: IFFALSE 1701
// begin hc_class = 18 ;
1648: LD_ADDR_OWVAR 28
1652: PUSH
1653: LD_INT 18
1655: ST_TO_ADDR
// hc_gallery =  ;
1656: LD_ADDR_OWVAR 33
1660: PUSH
1661: LD_STRING 
1663: ST_TO_ADDR
// hc_face_number = 1 ;
1664: LD_ADDR_OWVAR 34
1668: PUSH
1669: LD_INT 1
1671: ST_TO_ADDR
// animal := CreateHuman ;
1672: LD_ADDR_VAR 0 3
1676: PUSH
1677: CALL_OW 44
1681: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1682: LD_VAR 0 3
1686: PPUSH
1687: LD_VAR 0 4
1691: PPUSH
1692: LD_INT 0
1694: PPUSH
1695: CALL_OW 49
// end ;
1699: GO 1645
1701: POP
1702: POP
// for i = 1 to 6 do
1703: LD_ADDR_VAR 0 2
1707: PUSH
1708: DOUBLE
1709: LD_INT 1
1711: DEC
1712: ST_TO_ADDR
1713: LD_INT 6
1715: PUSH
1716: FOR_TO
1717: IFFALSE 1788
// begin hc_class = class_tiger ;
1719: LD_ADDR_OWVAR 28
1723: PUSH
1724: LD_INT 14
1726: ST_TO_ADDR
// hc_gallery =  ;
1727: LD_ADDR_OWVAR 33
1731: PUSH
1732: LD_STRING 
1734: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
1735: LD_ADDR_OWVAR 35
1739: PUSH
1740: LD_INT 0
1742: PPUSH
1743: LD_INT 10
1745: PPUSH
1746: CALL_OW 12
1750: ST_TO_ADDR
// hc_face_number = 3 ;
1751: LD_ADDR_OWVAR 34
1755: PUSH
1756: LD_INT 3
1758: ST_TO_ADDR
// animal := CreateHuman ;
1759: LD_ADDR_VAR 0 3
1763: PUSH
1764: CALL_OW 44
1768: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1769: LD_VAR 0 3
1773: PPUSH
1774: LD_VAR 0 4
1778: PPUSH
1779: LD_INT 0
1781: PPUSH
1782: CALL_OW 49
// end ;
1786: GO 1716
1788: POP
1789: POP
// for i = 1 to 2 do
1790: LD_ADDR_VAR 0 2
1794: PUSH
1795: DOUBLE
1796: LD_INT 1
1798: DEC
1799: ST_TO_ADDR
1800: LD_INT 2
1802: PUSH
1803: FOR_TO
1804: IFFALSE 1867
// begin hc_class = 21 ;
1806: LD_ADDR_OWVAR 28
1810: PUSH
1811: LD_INT 21
1813: ST_TO_ADDR
// hc_gallery =  ;
1814: LD_ADDR_OWVAR 33
1818: PUSH
1819: LD_STRING 
1821: ST_TO_ADDR
// hc_agressivity = 0 ;
1822: LD_ADDR_OWVAR 35
1826: PUSH
1827: LD_INT 0
1829: ST_TO_ADDR
// hc_face_number = 5 ;
1830: LD_ADDR_OWVAR 34
1834: PUSH
1835: LD_INT 5
1837: ST_TO_ADDR
// animal := CreateHuman ;
1838: LD_ADDR_VAR 0 3
1842: PUSH
1843: CALL_OW 44
1847: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1848: LD_VAR 0 3
1852: PPUSH
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 0
1860: PPUSH
1861: CALL_OW 49
// end ;
1865: GO 1803
1867: POP
1868: POP
// for i = 1 to 6 do
1869: LD_ADDR_VAR 0 2
1873: PUSH
1874: DOUBLE
1875: LD_INT 1
1877: DEC
1878: ST_TO_ADDR
1879: LD_INT 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 1938
// begin hc_class = 13 ;
1885: LD_ADDR_OWVAR 28
1889: PUSH
1890: LD_INT 13
1892: ST_TO_ADDR
// hc_gallery =  ;
1893: LD_ADDR_OWVAR 33
1897: PUSH
1898: LD_STRING 
1900: ST_TO_ADDR
// hc_face_number = 4 ;
1901: LD_ADDR_OWVAR 34
1905: PUSH
1906: LD_INT 4
1908: ST_TO_ADDR
// animal := CreateHuman ;
1909: LD_ADDR_VAR 0 3
1913: PUSH
1914: CALL_OW 44
1918: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1919: LD_VAR 0 3
1923: PPUSH
1924: LD_VAR 0 4
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
// end ;
1936: GO 1882
1938: POP
1939: POP
// for i = 1 to 2 do
1940: LD_ADDR_VAR 0 2
1944: PUSH
1945: DOUBLE
1946: LD_INT 1
1948: DEC
1949: ST_TO_ADDR
1950: LD_INT 2
1952: PUSH
1953: FOR_TO
1954: IFFALSE 2013
// begin hc_class = 20 ;
1956: LD_ADDR_OWVAR 28
1960: PUSH
1961: LD_INT 20
1963: ST_TO_ADDR
// hc_gallery =  ;
1964: LD_ADDR_OWVAR 33
1968: PUSH
1969: LD_STRING 
1971: ST_TO_ADDR
// hc_face_number = 2 ;
1972: LD_ADDR_OWVAR 34
1976: PUSH
1977: LD_INT 2
1979: ST_TO_ADDR
// animal := CreateHuman ;
1980: LD_ADDR_VAR 0 3
1984: PUSH
1985: CALL_OW 44
1989: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
1990: LD_VAR 0 3
1994: PPUSH
1995: LD_INT 101
1997: PPUSH
1998: LD_INT 37
2000: PPUSH
2001: LD_INT 3
2003: PPUSH
2004: LD_INT 0
2006: PPUSH
2007: CALL_OW 50
// end ;
2011: GO 1953
2013: POP
2014: POP
// for i = 1 to 1 do
2015: LD_ADDR_VAR 0 2
2019: PUSH
2020: DOUBLE
2021: LD_INT 1
2023: DEC
2024: ST_TO_ADDR
2025: LD_INT 1
2027: PUSH
2028: FOR_TO
2029: IFFALSE 2076
// begin vc_chassis := 31 ;
2031: LD_ADDR_OWVAR 37
2035: PUSH
2036: LD_INT 31
2038: ST_TO_ADDR
// vc_control := control_rider ;
2039: LD_ADDR_OWVAR 38
2043: PUSH
2044: LD_INT 4
2046: ST_TO_ADDR
// animal := CreateVehicle ;
2047: LD_ADDR_VAR 0 3
2051: PUSH
2052: CALL_OW 45
2056: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
2057: LD_VAR 0 3
2061: PPUSH
2062: LD_VAR 0 4
2066: PPUSH
2067: LD_INT 0
2069: PPUSH
2070: CALL_OW 49
// end ;
2074: GO 2028
2076: POP
2077: POP
// end ; end_of_file
2078: LD_VAR 0 1
2082: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
2083: LD_INT 0
2085: PPUSH
2086: PPUSH
2087: PPUSH
2088: PPUSH
2089: PPUSH
2090: PPUSH
// uc_side := 1 ;
2091: LD_ADDR_OWVAR 20
2095: PUSH
2096: LD_INT 1
2098: ST_TO_ADDR
// uc_nation := 1 ;
2099: LD_ADDR_OWVAR 21
2103: PUSH
2104: LD_INT 1
2106: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
2107: LD_ADDR_EXP 8
2111: PUSH
2112: LD_STRING JMM
2114: PPUSH
2115: LD_EXP 1
2119: NOT
2120: PPUSH
2121: CALL 354 0 2
2125: ST_TO_ADDR
// team := [ JMM ] ;
2126: LD_ADDR_VAR 0 3
2130: PUSH
2131: LD_EXP 8
2135: PUSH
2136: EMPTY
2137: LIST
2138: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
2139: LD_STRING BrownIn07
2141: PPUSH
2142: LD_EXP 1
2146: PPUSH
2147: CALL_OW 30
2151: IFFALSE 2172
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
2153: LD_ADDR_EXP 9
2157: PUSH
2158: LD_STRING Brown
2160: PPUSH
2161: LD_EXP 1
2165: NOT
2166: PPUSH
2167: CALL 354 0 2
2171: ST_TO_ADDR
// if Brown then
2172: LD_EXP 9
2176: IFFALSE 2194
// team := team ^ Brown ;
2178: LD_ADDR_VAR 0 3
2182: PUSH
2183: LD_VAR 0 3
2187: PUSH
2188: LD_EXP 9
2192: ADD
2193: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
2194: LD_STRING DonaldsonIn07
2196: PPUSH
2197: LD_EXP 1
2201: PPUSH
2202: CALL_OW 30
2206: IFFALSE 2227
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
2208: LD_ADDR_EXP 10
2212: PUSH
2213: LD_STRING Donaldson
2215: PPUSH
2216: LD_EXP 1
2220: NOT
2221: PPUSH
2222: CALL 354 0 2
2226: ST_TO_ADDR
// if Donaldson then
2227: LD_EXP 10
2231: IFFALSE 2249
// team := team ^ Donaldson ;
2233: LD_ADDR_VAR 0 3
2237: PUSH
2238: LD_VAR 0 3
2242: PUSH
2243: LD_EXP 10
2247: ADD
2248: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
2249: LD_STRING BobbyIn07
2251: PPUSH
2252: LD_EXP 1
2256: PPUSH
2257: CALL_OW 30
2261: IFFALSE 2282
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
2263: LD_ADDR_EXP 11
2267: PUSH
2268: LD_STRING Bobby
2270: PPUSH
2271: LD_EXP 1
2275: NOT
2276: PPUSH
2277: CALL 354 0 2
2281: ST_TO_ADDR
// if Bobby then
2282: LD_EXP 11
2286: IFFALSE 2304
// team := team ^ Bobby ;
2288: LD_ADDR_VAR 0 3
2292: PUSH
2293: LD_VAR 0 3
2297: PUSH
2298: LD_EXP 11
2302: ADD
2303: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
2304: LD_STRING CyrusIn07
2306: PPUSH
2307: LD_EXP 1
2311: PPUSH
2312: CALL_OW 30
2316: IFFALSE 2337
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
2318: LD_ADDR_EXP 12
2322: PUSH
2323: LD_STRING Cyrus
2325: PPUSH
2326: LD_EXP 1
2330: NOT
2331: PPUSH
2332: CALL 354 0 2
2336: ST_TO_ADDR
// if Cyrus then
2337: LD_EXP 12
2341: IFFALSE 2359
// team := team ^ Cyrus ;
2343: LD_ADDR_VAR 0 3
2347: PUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_EXP 12
2357: ADD
2358: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
2359: LD_STRING LisaIn07
2361: PPUSH
2362: LD_EXP 1
2366: PPUSH
2367: CALL_OW 30
2371: IFFALSE 2392
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
2373: LD_ADDR_EXP 13
2377: PUSH
2378: LD_STRING Lisa
2380: PPUSH
2381: LD_EXP 1
2385: NOT
2386: PPUSH
2387: CALL 354 0 2
2391: ST_TO_ADDR
// if Lisa then
2392: LD_EXP 13
2396: IFFALSE 2414
// team := team ^ Lisa ;
2398: LD_ADDR_VAR 0 3
2402: PUSH
2403: LD_VAR 0 3
2407: PUSH
2408: LD_EXP 13
2412: ADD
2413: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
2414: LD_STRING GladstoneIn07
2416: PPUSH
2417: LD_EXP 1
2421: PPUSH
2422: CALL_OW 30
2426: IFFALSE 2447
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
2428: LD_ADDR_EXP 15
2432: PUSH
2433: LD_STRING Gladstone
2435: PPUSH
2436: LD_EXP 1
2440: NOT
2441: PPUSH
2442: CALL 354 0 2
2446: ST_TO_ADDR
// if Gladstone then
2447: LD_EXP 15
2451: IFFALSE 2469
// team := team ^ Gladstone ;
2453: LD_ADDR_VAR 0 3
2457: PUSH
2458: LD_VAR 0 3
2462: PUSH
2463: LD_EXP 15
2467: ADD
2468: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
2469: LD_STRING KhatamIn07
2471: PPUSH
2472: LD_EXP 1
2476: PPUSH
2477: CALL_OW 30
2481: IFFALSE 2502
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
2483: LD_ADDR_EXP 16
2487: PUSH
2488: LD_STRING Khatam
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: CALL 354 0 2
2501: ST_TO_ADDR
// if Khatam then
2502: LD_EXP 16
2506: IFFALSE 2524
// team := team ^ Khatam ;
2508: LD_ADDR_VAR 0 3
2512: PUSH
2513: LD_VAR 0 3
2517: PUSH
2518: LD_EXP 16
2522: ADD
2523: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
2524: LD_ADDR_VAR 0 4
2528: PUSH
2529: LD_STRING 07_others
2531: PPUSH
2532: CALL_OW 31
2536: ST_TO_ADDR
// if others then
2537: LD_VAR 0 4
2541: IFFALSE 2559
// team := team ^ others ;
2543: LD_ADDR_VAR 0 3
2547: PUSH
2548: LD_VAR 0 3
2552: PUSH
2553: LD_VAR 0 4
2557: ADD
2558: ST_TO_ADDR
// if debug then
2559: LD_EXP 1
2563: IFFALSE 2637
// begin InitHc ;
2565: CALL_OW 19
// for i = 1 to 4 do
2569: LD_ADDR_VAR 0 2
2573: PUSH
2574: DOUBLE
2575: LD_INT 1
2577: DEC
2578: ST_TO_ADDR
2579: LD_INT 4
2581: PUSH
2582: FOR_TO
2583: IFFALSE 2635
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
2585: LD_INT 0
2587: PPUSH
2588: LD_INT 1
2590: PUSH
2591: LD_INT 3
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: PUSH
2598: LD_INT 1
2600: PPUSH
2601: LD_INT 2
2603: PPUSH
2604: CALL_OW 12
2608: ARRAY
2609: PPUSH
2610: LD_INT 4
2612: PPUSH
2613: CALL_OW 380
// team := team ^ CreateHuman ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_VAR 0 3
2626: PUSH
2627: CALL_OW 44
2631: ADD
2632: ST_TO_ADDR
// end ;
2633: GO 2582
2635: POP
2636: POP
// end ; m := 0 ;
2637: LD_ADDR_VAR 0 6
2641: PUSH
2642: LD_INT 0
2644: ST_TO_ADDR
// for i in team do
2645: LD_ADDR_VAR 0 2
2649: PUSH
2650: LD_VAR 0 3
2654: PUSH
2655: FOR_IN
2656: IFFALSE 2836
// if GetClass ( i ) = 3 then
2658: LD_VAR 0 2
2662: PPUSH
2663: CALL_OW 257
2667: PUSH
2668: LD_INT 3
2670: EQUAL
2671: IFFALSE 2819
// begin m := m + 1 ;
2673: LD_ADDR_VAR 0 6
2677: PUSH
2678: LD_VAR 0 6
2682: PUSH
2683: LD_INT 1
2685: PLUS
2686: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2687: LD_ADDR_VAR 0 5
2691: PUSH
2692: LD_INT 1
2694: PPUSH
2695: LD_INT 1
2697: PPUSH
2698: LD_INT 2
2700: PUSH
2701: LD_INT 3
2703: PUSH
2704: LD_INT 2
2706: PUSH
2707: LD_INT 1
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: LIST
2714: LIST
2715: PUSH
2716: LD_VAR 0 6
2720: PUSH
2721: LD_INT 4
2723: MOD
2724: PUSH
2725: LD_INT 1
2727: PLUS
2728: ARRAY
2729: PPUSH
2730: LD_INT 2
2732: PPUSH
2733: LD_INT 1
2735: PPUSH
2736: LD_INT 4
2738: PUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 11
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: PUSH
2754: LD_VAR 0 6
2758: PUSH
2759: LD_INT 4
2761: MOD
2762: PUSH
2763: LD_INT 1
2765: PLUS
2766: ARRAY
2767: PPUSH
2768: LD_INT 60
2770: PPUSH
2771: CALL 417 0 7
2775: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2776: LD_VAR 0 5
2780: PPUSH
2781: LD_INT 2
2783: PPUSH
2784: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2788: LD_VAR 0 5
2792: PPUSH
2793: LD_INT 1
2795: PPUSH
2796: LD_INT 0
2798: PPUSH
2799: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2803: LD_VAR 0 2
2807: PPUSH
2808: LD_VAR 0 5
2812: PPUSH
2813: CALL_OW 52
// end else
2817: GO 2834
// PlaceUnitArea ( i , startArea , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 1
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
2834: GO 2655
2836: POP
2837: POP
// uc_side := 4 ;
2838: LD_ADDR_OWVAR 20
2842: PUSH
2843: LD_INT 4
2845: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2846: LD_ADDR_EXP 18
2850: PUSH
2851: LD_STRING Harisson
2853: PPUSH
2854: LD_INT 0
2856: PPUSH
2857: CALL 354 0 2
2861: ST_TO_ADDR
// PrepareScout ;
2862: CALL 2871 0 0
// end ;
2866: LD_VAR 0 1
2870: RET
// function PrepareScout ; var ape ; begin
2871: LD_INT 0
2873: PPUSH
2874: PPUSH
// uc_side := 4 ;
2875: LD_ADDR_OWVAR 20
2879: PUSH
2880: LD_INT 4
2882: ST_TO_ADDR
// uc_nation := 1 ;
2883: LD_ADDR_OWVAR 21
2887: PUSH
2888: LD_INT 1
2890: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2891: LD_STRING FrankIn06
2893: PPUSH
2894: LD_INT 0
2896: PPUSH
2897: CALL_OW 30
2901: IFFALSE 2918
// Frank := CreateCharacter ( 06c_Frank ) else
2903: LD_ADDR_EXP 14
2907: PUSH
2908: LD_STRING 06c_Frank
2910: PPUSH
2911: CALL_OW 34
2915: ST_TO_ADDR
2916: GO 2958
// if LoadVariable ( FrankInDelta , 0 ) then
2918: LD_STRING FrankInDelta
2920: PPUSH
2921: LD_INT 0
2923: PPUSH
2924: CALL_OW 30
2928: IFFALSE 2945
// Frank := CreateCharacter ( 05_Frank ) else
2930: LD_ADDR_EXP 14
2934: PUSH
2935: LD_STRING 05_Frank
2937: PPUSH
2938: CALL_OW 34
2942: ST_TO_ADDR
2943: GO 2958
// Frank := CreateCharacter ( 04_Frank ) ;
2945: LD_ADDR_EXP 14
2949: PUSH
2950: LD_STRING 04_Frank
2952: PPUSH
2953: CALL_OW 34
2957: ST_TO_ADDR
// if Frank then
2958: LD_EXP 14
2962: IFFALSE 3095
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2964: LD_EXP 14
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: LD_INT 0
2974: PPUSH
2975: CALL_OW 49
// SetClass ( Frank , 1 ) ;
2979: LD_EXP 14
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: CALL_OW 336
// uc_side := 0 ;
2991: LD_ADDR_OWVAR 20
2995: PUSH
2996: LD_INT 0
2998: ST_TO_ADDR
// uc_nation := 0 ;
2999: LD_ADDR_OWVAR 21
3003: PUSH
3004: LD_INT 0
3006: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3007: LD_INT 0
3009: PPUSH
3010: LD_INT 12
3012: PPUSH
3013: LD_INT 0
3015: PPUSH
3016: CALL_OW 380
// ape := CreateHuman ;
3020: LD_ADDR_VAR 0 2
3024: PUSH
3025: CALL_OW 44
3029: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
3030: LD_VAR 0 2
3034: PPUSH
3035: LD_EXP 14
3039: PPUSH
3040: CALL_OW 250
3044: PPUSH
3045: LD_EXP 14
3049: PPUSH
3050: CALL_OW 251
3054: PPUSH
3055: LD_INT 5
3057: PPUSH
3058: LD_INT 0
3060: PPUSH
3061: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
3065: LD_VAR 0 2
3069: PPUSH
3070: LD_EXP 14
3074: PPUSH
3075: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
3079: LD_EXP 14
3083: PPUSH
3084: LD_VAR 0 2
3088: PPUSH
3089: CALL_OW 119
// exit ;
3093: GO 3135
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
3095: LD_ADDR_EXP 17
3099: PUSH
3100: LD_STRING Yamoko
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL 354 0 2
3110: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
3111: LD_EXP 17
3115: PPUSH
3116: LD_INT 2
3118: PPUSH
3119: LD_INT 0
3121: PPUSH
3122: CALL_OW 49
// ComHold ( Kikuchi ) ;
3126: LD_EXP 17
3130: PPUSH
3131: CALL_OW 140
// end ; end_of_file
3135: LD_VAR 0 1
3139: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
3140: LD_INT 0
3142: PPUSH
3143: PPUSH
3144: PPUSH
3145: PPUSH
3146: PPUSH
3147: PPUSH
3148: PPUSH
3149: PPUSH
3150: PPUSH
3151: PPUSH
3152: PPUSH
3153: PPUSH
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
// ru_rebuild_list := [ ] ;
3158: LD_ADDR_EXP 19
3162: PUSH
3163: EMPTY
3164: ST_TO_ADDR
// uc_side := 3 ;
3165: LD_ADDR_OWVAR 20
3169: PUSH
3170: LD_INT 3
3172: ST_TO_ADDR
// uc_nation := 3 ;
3173: LD_ADDR_OWVAR 21
3177: PUSH
3178: LD_INT 3
3180: ST_TO_ADDR
// if Difficulty > 1 then
3181: LD_OWVAR 67
3185: PUSH
3186: LD_INT 1
3188: GREATER
3189: IFFALSE 3325
// begin bc_type := b_breastwork ;
3191: LD_ADDR_OWVAR 42
3195: PUSH
3196: LD_INT 31
3198: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
3199: LD_INT 78
3201: PPUSH
3202: LD_INT 74
3204: PPUSH
3205: LD_INT 2
3207: PPUSH
3208: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
3212: LD_INT 171
3214: PPUSH
3215: LD_INT 193
3217: PPUSH
3218: LD_INT 4
3220: PPUSH
3221: CALL_OW 47
// bc_type := b_turret ;
3225: LD_ADDR_OWVAR 42
3229: PUSH
3230: LD_INT 33
3232: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
3233: LD_INT 129
3235: PPUSH
3236: LD_INT 96
3238: PPUSH
3239: LD_INT 3
3241: PPUSH
3242: CALL_OW 47
// if Difficulty > 2 then
3246: LD_OWVAR 67
3250: PUSH
3251: LD_INT 2
3253: GREATER
3254: IFFALSE 3325
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
3256: LD_INT 83
3258: PPUSH
3259: LD_INT 141
3261: PPUSH
3262: CALL_OW 428
3266: PPUSH
3267: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
3271: LD_INT 78
3273: PPUSH
3274: LD_INT 133
3276: PPUSH
3277: CALL_OW 428
3281: PPUSH
3282: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
3286: LD_INT 83
3288: PPUSH
3289: LD_INT 141
3291: PPUSH
3292: LD_INT 2
3294: PPUSH
3295: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
3299: LD_INT 78
3301: PPUSH
3302: LD_INT 133
3304: PPUSH
3305: LD_INT 2
3307: PPUSH
3308: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
3312: LD_INT 145
3314: PPUSH
3315: LD_INT 112
3317: PPUSH
3318: LD_INT 3
3320: PPUSH
3321: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3325: LD_ADDR_VAR 0 9
3329: PUSH
3330: LD_INT 22
3332: PUSH
3333: LD_INT 3
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PUSH
3340: LD_INT 2
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 30
3355: PUSH
3356: LD_INT 1
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: PPUSH
3372: CALL_OW 69
3376: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3377: LD_ADDR_VAR 0 10
3381: PUSH
3382: LD_INT 22
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 2
3394: PUSH
3395: LD_INT 30
3397: PUSH
3398: LD_INT 6
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PUSH
3405: LD_INT 30
3407: PUSH
3408: LD_INT 7
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: PUSH
3415: LD_INT 30
3417: PUSH
3418: LD_INT 8
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: PUSH
3425: EMPTY
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PPUSH
3435: CALL_OW 69
3439: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3440: LD_ADDR_VAR 0 11
3444: PUSH
3445: LD_INT 22
3447: PUSH
3448: LD_INT 3
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: PUSH
3455: LD_INT 30
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PPUSH
3469: CALL_OW 69
3473: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
3474: LD_ADDR_VAR 0 12
3478: PUSH
3479: LD_INT 22
3481: PUSH
3482: LD_INT 3
3484: PUSH
3485: EMPTY
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 30
3491: PUSH
3492: LD_INT 31
3494: PUSH
3495: EMPTY
3496: LIST
3497: LIST
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 69
3507: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
3508: LD_ADDR_VAR 0 13
3512: PUSH
3513: LD_INT 22
3515: PUSH
3516: LD_INT 3
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 32
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: PPUSH
3537: CALL_OW 69
3541: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3542: LD_ADDR_VAR 0 14
3546: PUSH
3547: LD_INT 22
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: PUSH
3557: LD_INT 30
3559: PUSH
3560: LD_INT 33
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: PPUSH
3571: CALL_OW 69
3575: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
3576: LD_ADDR_VAR 0 15
3580: PUSH
3581: LD_INT 42
3583: PUSH
3584: LD_INT 5
3586: PUSH
3587: EMPTY
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 43
3593: PUSH
3594: LD_INT 50
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: PUSH
3601: LD_INT 44
3603: PUSH
3604: LD_INT 30
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PUSH
3611: LD_INT 46
3613: PUSH
3614: LD_INT 15
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: LIST
3625: LIST
3626: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
3627: LD_ADDR_VAR 0 16
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: LD_INT 4
3637: PUSH
3638: LD_INT 6
3640: PUSH
3641: LD_INT 3
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3650: LD_ADDR_VAR 0 6
3654: PUSH
3655: LD_INT 4
3657: PUSH
3658: LD_INT 5
3660: PUSH
3661: LD_INT 6
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_OWVAR 67
3673: ARRAY
3674: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3675: LD_INT 16
3677: PPUSH
3678: LD_STRING am_tukh
3680: PPUSH
3681: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3685: LD_ADDR_VAR 0 2
3689: PUSH
3690: LD_INT 21
3692: PUSH
3693: LD_INT 3
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PPUSH
3700: CALL_OW 69
3704: PUSH
3705: FOR_IN
3706: IFFALSE 3739
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3708: LD_VAR 0 2
3712: PPUSH
3713: LD_INT 4
3715: PUSH
3716: LD_INT 5
3718: PUSH
3719: LD_INT 6
3721: PUSH
3722: EMPTY
3723: LIST
3724: LIST
3725: LIST
3726: PUSH
3727: LD_OWVAR 67
3731: ARRAY
3732: PPUSH
3733: CALL_OW 241
3737: GO 3705
3739: POP
3740: POP
// for i in dep_list do
3741: LD_ADDR_VAR 0 2
3745: PUSH
3746: LD_VAR 0 9
3750: PUSH
3751: FOR_IN
3752: IFFALSE 3796
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3754: LD_VAR 0 2
3758: PPUSH
3759: CALL_OW 274
3763: PPUSH
3764: LD_INT 1
3766: PPUSH
3767: LD_INT 1000
3769: PPUSH
3770: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3774: LD_VAR 0 2
3778: PPUSH
3779: CALL_OW 274
3783: PPUSH
3784: LD_INT 2
3786: PPUSH
3787: LD_INT 1000
3789: PPUSH
3790: CALL_OW 277
// end ;
3794: GO 3751
3796: POP
3797: POP
// InitHc ;
3798: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: LD_VAR 0 13
3811: PUSH
3812: LD_INT 50
3814: PUSH
3815: LD_INT 70
3817: PUSH
3818: LD_INT 85
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: LIST
3825: PUSH
3826: LD_OWVAR 67
3830: ARRAY
3831: MUL
3832: PUSH
3833: LD_INT 100
3835: DIV
3836: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3837: LD_ADDR_VAR 0 16
3841: PUSH
3842: LD_VAR 0 16
3846: PPUSH
3847: LD_INT 1
3849: PPUSH
3850: LD_VAR 0 8
3854: PPUSH
3855: CALL_OW 1
3859: ST_TO_ADDR
// tmp := [ ] ;
3860: LD_ADDR_VAR 0 8
3864: PUSH
3865: EMPTY
3866: ST_TO_ADDR
// for i in bunker_list do
3867: LD_ADDR_VAR 0 2
3871: PUSH
3872: LD_VAR 0 13
3876: PUSH
3877: FOR_IN
3878: IFFALSE 3974
// if i mod 10 + 1 < tmp then
3880: LD_VAR 0 2
3884: PUSH
3885: LD_INT 10
3887: MOD
3888: PUSH
3889: LD_INT 1
3891: PLUS
3892: PUSH
3893: LD_VAR 0 8
3897: LESS
3898: IFFALSE 3943
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3900: LD_ADDR_VAR 0 8
3904: PUSH
3905: LD_VAR 0 8
3909: PPUSH
3910: LD_VAR 0 2
3914: PUSH
3915: LD_INT 3
3917: PPUSH
3918: LD_INT 5
3920: PPUSH
3921: CALL_OW 12
3925: MOD
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: PPUSH
3931: LD_VAR 0 2
3935: PPUSH
3936: CALL_OW 2
3940: ST_TO_ADDR
3941: GO 3972
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3943: LD_ADDR_VAR 0 8
3947: PUSH
3948: LD_VAR 0 8
3952: PPUSH
3953: LD_VAR 0 8
3957: PUSH
3958: LD_INT 1
3960: PLUS
3961: PPUSH
3962: LD_VAR 0 2
3966: PPUSH
3967: CALL_OW 2
3971: ST_TO_ADDR
3972: GO 3877
3974: POP
3975: POP
// bunker_list := tmp ;
3976: LD_ADDR_VAR 0 13
3980: PUSH
3981: LD_VAR 0 8
3985: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3986: LD_ADDR_VAR 0 2
3990: PUSH
3991: LD_VAR 0 13
3995: PUSH
3996: LD_VAR 0 14
4000: ADD
4001: PUSH
4002: FOR_IN
4003: IFFALSE 4100
// begin tmp := rand ( 0 , 100 ) ;
4005: LD_ADDR_VAR 0 8
4009: PUSH
4010: LD_INT 0
4012: PPUSH
4013: LD_INT 100
4015: PPUSH
4016: CALL_OW 12
4020: ST_TO_ADDR
// r := 0 ;
4021: LD_ADDR_VAR 0 4
4025: PUSH
4026: LD_INT 0
4028: ST_TO_ADDR
// for j in weapons_list do
4029: LD_ADDR_VAR 0 3
4033: PUSH
4034: LD_VAR 0 15
4038: PUSH
4039: FOR_IN
4040: IFFALSE 4096
// begin r := r + j [ 2 ] ;
4042: LD_ADDR_VAR 0 4
4046: PUSH
4047: LD_VAR 0 4
4051: PUSH
4052: LD_VAR 0 3
4056: PUSH
4057: LD_INT 2
4059: ARRAY
4060: PLUS
4061: ST_TO_ADDR
// if r >= tmp then
4062: LD_VAR 0 4
4066: PUSH
4067: LD_VAR 0 8
4071: GREATEREQUAL
4072: IFFALSE 4094
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
4074: LD_VAR 0 2
4078: PPUSH
4079: LD_VAR 0 3
4083: PUSH
4084: LD_INT 1
4086: ARRAY
4087: PPUSH
4088: CALL_OW 431
// break ;
4092: GO 4096
// end ; end ;
4094: GO 4039
4096: POP
4097: POP
// end ;
4098: GO 4002
4100: POP
4101: POP
// while ( personel_counter [ 1 ] ) do
4102: LD_VAR 0 16
4106: PUSH
4107: LD_INT 1
4109: ARRAY
4110: IFFALSE 4218
// begin i := rand ( 1 , bunker_list ) ;
4112: LD_ADDR_VAR 0 2
4116: PUSH
4117: LD_INT 1
4119: PPUSH
4120: LD_VAR 0 13
4124: PPUSH
4125: CALL_OW 12
4129: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4130: LD_INT 0
4132: PPUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_VAR 0 6
4140: PPUSH
4141: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
4145: CALL_OW 44
4149: PPUSH
4150: LD_VAR 0 13
4154: PUSH
4155: LD_VAR 0 2
4159: ARRAY
4160: PPUSH
4161: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
4165: LD_ADDR_VAR 0 13
4169: PUSH
4170: LD_VAR 0 13
4174: PPUSH
4175: LD_VAR 0 2
4179: PPUSH
4180: CALL_OW 3
4184: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
4185: LD_ADDR_VAR 0 16
4189: PUSH
4190: LD_VAR 0 16
4194: PPUSH
4195: LD_INT 1
4197: PPUSH
4198: LD_VAR 0 16
4202: PUSH
4203: LD_INT 1
4205: ARRAY
4206: PUSH
4207: LD_INT 1
4209: MINUS
4210: PPUSH
4211: CALL_OW 1
4215: ST_TO_ADDR
// end ;
4216: GO 4102
// for i = 1 to personel_counter [ 2 ] do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_VAR 0 16
4232: PUSH
4233: LD_INT 2
4235: ARRAY
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4269
// begin PrepareHuman ( false , 2 , skill ) ;
4240: LD_INT 0
4242: PPUSH
4243: LD_INT 2
4245: PPUSH
4246: LD_VAR 0 6
4250: PPUSH
4251: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
4255: CALL_OW 44
4259: PPUSH
4260: LD_INT 16
4262: PPUSH
4263: CALL_OW 52
// end ;
4267: GO 4237
4269: POP
4270: POP
// for i = 1 to personel_counter [ 3 ] do
4271: LD_ADDR_VAR 0 2
4275: PUSH
4276: DOUBLE
4277: LD_INT 1
4279: DEC
4280: ST_TO_ADDR
4281: LD_VAR 0 16
4285: PUSH
4286: LD_INT 3
4288: ARRAY
4289: PUSH
4290: FOR_TO
4291: IFFALSE 4338
// begin PrepareHuman ( false , 3 , skill ) ;
4293: LD_INT 0
4295: PPUSH
4296: LD_INT 3
4298: PPUSH
4299: LD_VAR 0 6
4303: PPUSH
4304: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
4308: CALL_OW 44
4312: PPUSH
4313: LD_VAR 0 11
4317: PUSH
4318: LD_VAR 0 2
4322: PUSH
4323: LD_INT 2
4325: MOD
4326: PUSH
4327: LD_INT 1
4329: PLUS
4330: ARRAY
4331: PPUSH
4332: CALL_OW 52
// end ;
4336: GO 4290
4338: POP
4339: POP
// for i = 1 to personel_counter [ 4 ] do
4340: LD_ADDR_VAR 0 2
4344: PUSH
4345: DOUBLE
4346: LD_INT 1
4348: DEC
4349: ST_TO_ADDR
4350: LD_VAR 0 16
4354: PUSH
4355: LD_INT 4
4357: ARRAY
4358: PUSH
4359: FOR_TO
4360: IFFALSE 4397
// begin PrepareHuman ( false , 4 , skill ) ;
4362: LD_INT 0
4364: PPUSH
4365: LD_INT 4
4367: PPUSH
4368: LD_VAR 0 6
4372: PPUSH
4373: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
4377: CALL_OW 44
4381: PPUSH
4382: LD_VAR 0 10
4386: PUSH
4387: LD_INT 1
4389: ARRAY
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 4359
4397: POP
4398: POP
// for i in breastworks_list do
4399: LD_ADDR_VAR 0 2
4403: PUSH
4404: LD_VAR 0 12
4408: PUSH
4409: FOR_IN
4410: IFFALSE 4522
// begin r := GetDir ( i ) ;
4412: LD_ADDR_VAR 0 4
4416: PUSH
4417: LD_VAR 0 2
4421: PPUSH
4422: CALL_OW 254
4426: ST_TO_ADDR
// if r > 3 then
4427: LD_VAR 0 4
4431: PUSH
4432: LD_INT 3
4434: GREATER
4435: IFFALSE 4453
// r := r - 3 else
4437: LD_ADDR_VAR 0 4
4441: PUSH
4442: LD_VAR 0 4
4446: PUSH
4447: LD_INT 3
4449: MINUS
4450: ST_TO_ADDR
4451: GO 4467
// r := r + 3 ;
4453: LD_ADDR_VAR 0 4
4457: PUSH
4458: LD_VAR 0 4
4462: PUSH
4463: LD_INT 3
4465: PLUS
4466: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4467: LD_INT 0
4469: PPUSH
4470: LD_INT 1
4472: PPUSH
4473: LD_VAR 0 6
4477: PPUSH
4478: CALL_OW 380
// un := CreateHuman ;
4482: LD_ADDR_VAR 0 5
4486: PUSH
4487: CALL_OW 44
4491: ST_TO_ADDR
// SetDir ( un , r ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_VAR 0 4
4501: PPUSH
4502: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4506: LD_VAR 0 5
4510: PPUSH
4511: LD_VAR 0 2
4515: PPUSH
4516: CALL_OW 52
// end ;
4520: GO 4409
4522: POP
4523: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
4524: LD_ADDR_VAR 0 8
4528: PUSH
4529: LD_INT 22
4531: PUSH
4532: LD_INT 3
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: PUSH
4539: LD_INT 25
4541: PUSH
4542: LD_INT 3
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PPUSH
4553: CALL_OW 69
4557: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
4558: LD_ADDR_VAR 0 4
4562: PUSH
4563: LD_INT 4
4565: PUSH
4566: LD_INT 5
4568: PUSH
4569: LD_INT 6
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: LIST
4576: PUSH
4577: LD_OWVAR 67
4581: ARRAY
4582: ST_TO_ADDR
// for i = 1 to r do
4583: LD_ADDR_VAR 0 2
4587: PUSH
4588: DOUBLE
4589: LD_INT 1
4591: DEC
4592: ST_TO_ADDR
4593: LD_VAR 0 4
4597: PUSH
4598: FOR_TO
4599: IFFALSE 4772
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
4601: LD_ADDR_VAR 0 5
4605: PUSH
4606: LD_INT 3
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 22
4617: PUSH
4618: LD_INT 24
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: LIST
4625: PUSH
4626: LD_VAR 0 2
4630: PUSH
4631: LD_INT 3
4633: MOD
4634: PUSH
4635: LD_INT 1
4637: PLUS
4638: ARRAY
4639: PPUSH
4640: LD_INT 1
4642: PPUSH
4643: LD_INT 1
4645: PPUSH
4646: LD_INT 43
4648: PUSH
4649: LD_INT 44
4651: PUSH
4652: LD_INT 42
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: PUSH
4660: LD_VAR 0 2
4664: PUSH
4665: LD_INT 3
4667: MOD
4668: PUSH
4669: LD_INT 1
4671: PLUS
4672: ARRAY
4673: PPUSH
4674: LD_INT 100
4676: PPUSH
4677: CALL 417 0 7
4681: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4682: LD_VAR 0 5
4686: PPUSH
4687: LD_INT 0
4689: PPUSH
4690: LD_INT 5
4692: PPUSH
4693: CALL_OW 12
4697: PPUSH
4698: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4702: LD_VAR 0 5
4706: PPUSH
4707: LD_INT 5
4709: PPUSH
4710: LD_INT 0
4712: PPUSH
4713: CALL_OW 49
// if i > tmp - 2 then
4717: LD_VAR 0 2
4721: PUSH
4722: LD_VAR 0 8
4726: PUSH
4727: LD_INT 2
4729: MINUS
4730: GREATER
4731: IFFALSE 4735
// continue ;
4733: GO 4598
// ComExitBuilding ( tmp [ i ] ) ;
4735: LD_VAR 0 8
4739: PUSH
4740: LD_VAR 0 2
4744: ARRAY
4745: PPUSH
4746: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
4750: LD_VAR 0 8
4754: PUSH
4755: LD_VAR 0 2
4759: ARRAY
4760: PPUSH
4761: LD_VAR 0 5
4765: PPUSH
4766: CALL_OW 180
// end ;
4770: GO 4598
4772: POP
4773: POP
// end ;
4774: LD_VAR 0 1
4778: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4779: LD_INT 22
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 25
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: LD_INT 50
4801: PUSH
4802: EMPTY
4803: LIST
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: PPUSH
4810: CALL_OW 69
4814: IFFALSE 5510
4816: GO 4818
4818: DISABLE
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
// begin enable ;
4826: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4827: LD_ADDR_VAR 0 2
4831: PUSH
4832: LD_INT 6
4834: PPUSH
4835: LD_INT 3
4837: PUSH
4838: LD_INT 24
4840: PUSH
4841: LD_INT 1000
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 21
4854: PUSH
4855: LD_INT 3
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PPUSH
4866: CALL_OW 70
4870: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4871: LD_ADDR_VAR 0 4
4875: PUSH
4876: LD_INT 22
4878: PUSH
4879: LD_INT 3
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: LD_INT 25
4888: PUSH
4889: LD_INT 2
4891: PUSH
4892: EMPTY
4893: LIST
4894: LIST
4895: PUSH
4896: LD_INT 24
4898: PUSH
4899: LD_INT 650
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: LIST
4910: PPUSH
4911: CALL_OW 69
4915: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4916: LD_VAR 0 2
4920: NOT
4921: PUSH
4922: LD_EXP 19
4926: NOT
4927: AND
4928: IFFALSE 4960
// begin if not IsInUnit ( engs [ 1 ] ) then
4930: LD_VAR 0 4
4934: PUSH
4935: LD_INT 1
4937: ARRAY
4938: PPUSH
4939: CALL_OW 310
4943: NOT
4944: IFFALSE 4958
// ComEnterUnit ( engs , ru_dep_main ) ;
4946: LD_VAR 0 4
4950: PPUSH
4951: LD_INT 16
4953: PPUSH
4954: CALL_OW 120
// exit ;
4958: GO 5510
// end ; if debug then
4960: LD_EXP 1
4964: IFFALSE 4985
// display_strings := [ engs , filter ] ;
4966: LD_ADDR_OWVAR 47
4970: PUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_VAR 0 2
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4985: LD_VAR 0 4
4989: PPUSH
4990: LD_INT 3
4992: PUSH
4993: LD_INT 24
4995: PUSH
4996: LD_INT 650
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 72
5011: IFFALSE 5104
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_VAR 0 4
5022: PPUSH
5023: LD_INT 3
5025: PUSH
5026: LD_INT 24
5028: PUSH
5029: LD_INT 650
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 72
5044: ST_TO_ADDR
// for i in tmp do
5045: LD_ADDR_VAR 0 1
5049: PUSH
5050: LD_VAR 0 3
5054: PUSH
5055: FOR_IN
5056: IFFALSE 5102
// if not IsInArea ( i , mainBaseArea ) then
5058: LD_VAR 0 1
5062: PPUSH
5063: LD_INT 14
5065: PPUSH
5066: CALL_OW 308
5070: NOT
5071: IFFALSE 5100
// begin ComMoveXY ( i , 129 , 125 ) ;
5073: LD_VAR 0 1
5077: PPUSH
5078: LD_INT 129
5080: PPUSH
5081: LD_INT 125
5083: PPUSH
5084: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
5088: LD_VAR 0 1
5092: PPUSH
5093: LD_INT 1050
5095: PPUSH
5096: CALL_OW 202
// end ;
5100: GO 5055
5102: POP
5103: POP
// end ; if filter then
5104: LD_VAR 0 2
5108: IFFALSE 5367
// begin for i in engs do
5110: LD_ADDR_VAR 0 1
5114: PUSH
5115: LD_VAR 0 4
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5145
// if IsInUnit ( i ) then
5123: LD_VAR 0 1
5127: PPUSH
5128: CALL_OW 310
5132: IFFALSE 5143
// ComExitBuilding ( i ) ;
5134: LD_VAR 0 1
5138: PPUSH
5139: CALL_OW 122
5143: GO 5120
5145: POP
5146: POP
// wait ( 3 ) ;
5147: LD_INT 3
5149: PPUSH
5150: CALL_OW 67
// if filter >= 2 and engs >= 2 then
5154: LD_VAR 0 2
5158: PUSH
5159: LD_INT 2
5161: GREATEREQUAL
5162: PUSH
5163: LD_VAR 0 4
5167: PUSH
5168: LD_INT 2
5170: GREATEREQUAL
5171: AND
5172: IFFALSE 5320
// begin for i = 1 to engs / 2 do
5174: LD_ADDR_VAR 0 1
5178: PUSH
5179: DOUBLE
5180: LD_INT 1
5182: DEC
5183: ST_TO_ADDR
5184: LD_VAR 0 4
5188: PUSH
5189: LD_INT 2
5191: DIVREAL
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5240
// if not HasTask ( engs [ i ] ) then
5196: LD_VAR 0 4
5200: PUSH
5201: LD_VAR 0 1
5205: ARRAY
5206: PPUSH
5207: CALL_OW 314
5211: NOT
5212: IFFALSE 5238
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
5214: LD_VAR 0 4
5218: PUSH
5219: LD_VAR 0 1
5223: ARRAY
5224: PPUSH
5225: LD_VAR 0 2
5229: PUSH
5230: LD_INT 1
5232: ARRAY
5233: PPUSH
5234: CALL_OW 130
5238: GO 5193
5240: POP
5241: POP
// for i = engs / 2 + 1 to engs do
5242: LD_ADDR_VAR 0 1
5246: PUSH
5247: DOUBLE
5248: LD_VAR 0 4
5252: PUSH
5253: LD_INT 2
5255: DIVREAL
5256: PUSH
5257: LD_INT 1
5259: PLUS
5260: DEC
5261: ST_TO_ADDR
5262: LD_VAR 0 4
5266: PUSH
5267: FOR_TO
5268: IFFALSE 5316
// if not HasTask ( engs [ i ] ) then
5270: LD_VAR 0 4
5274: PUSH
5275: LD_VAR 0 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 314
5285: NOT
5286: IFFALSE 5314
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
5288: LD_VAR 0 4
5292: PUSH
5293: LD_VAR 0 1
5297: ARRAY
5298: PPUSH
5299: LD_VAR 0 2
5303: PUSH
5304: LD_VAR 0 2
5308: ARRAY
5309: PPUSH
5310: CALL_OW 130
5314: GO 5267
5316: POP
5317: POP
// end else
5318: GO 5367
// for i in engs do
5320: LD_ADDR_VAR 0 1
5324: PUSH
5325: LD_VAR 0 4
5329: PUSH
5330: FOR_IN
5331: IFFALSE 5365
// if not HasTask ( i ) then
5333: LD_VAR 0 1
5337: PPUSH
5338: CALL_OW 314
5342: NOT
5343: IFFALSE 5363
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5345: LD_VAR 0 1
5349: PPUSH
5350: LD_VAR 0 2
5354: PUSH
5355: LD_INT 1
5357: ARRAY
5358: PPUSH
5359: CALL_OW 130
5363: GO 5330
5365: POP
5366: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
5367: LD_ADDR_VAR 0 5
5371: PUSH
5372: LD_INT 81
5374: PUSH
5375: LD_INT 3
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: ST_TO_ADDR
// if ru_rebuild_list and not filter then
5387: LD_EXP 19
5391: PUSH
5392: LD_VAR 0 2
5396: NOT
5397: AND
5398: IFFALSE 5510
// begin ComExitBuilding ( engs ) ;
5400: LD_VAR 0 4
5404: PPUSH
5405: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
5409: LD_VAR 0 5
5413: PPUSH
5414: LD_EXP 19
5418: PUSH
5419: LD_INT 2
5421: ARRAY
5422: PPUSH
5423: LD_EXP 19
5427: PUSH
5428: LD_INT 3
5430: ARRAY
5431: PPUSH
5432: CALL_OW 73
5436: PPUSH
5437: LD_EXP 19
5441: PUSH
5442: LD_INT 2
5444: ARRAY
5445: PPUSH
5446: LD_EXP 19
5450: PUSH
5451: LD_INT 3
5453: ARRAY
5454: PPUSH
5455: CALL_OW 297
5459: PUSH
5460: LD_INT 10
5462: GREATER
5463: IFFALSE 5510
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
5465: LD_VAR 0 4
5469: PPUSH
5470: LD_EXP 19
5474: PUSH
5475: LD_INT 1
5477: ARRAY
5478: PPUSH
5479: LD_EXP 19
5483: PUSH
5484: LD_INT 2
5486: ARRAY
5487: PPUSH
5488: LD_EXP 19
5492: PUSH
5493: LD_INT 3
5495: ARRAY
5496: PPUSH
5497: LD_EXP 19
5501: PUSH
5502: LD_INT 4
5504: ARRAY
5505: PPUSH
5506: CALL_OW 145
// end ; end ;
5510: PPOPN 5
5512: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
5513: LD_INT 16
5515: PPUSH
5516: CALL_OW 256
5520: PUSH
5521: LD_INT 650
5523: LESS
5524: IFFALSE 5607
5526: GO 5528
5528: DISABLE
5529: LD_INT 0
5531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
5532: LD_ADDR_VAR 0 1
5536: PUSH
5537: LD_INT 22
5539: PUSH
5540: LD_INT 3
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: PUSH
5547: LD_INT 25
5549: PUSH
5550: LD_INT 1
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PPUSH
5561: CALL_OW 69
5565: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
5566: LD_VAR 0 1
5570: PPUSH
5571: CALL_OW 122
// wait ( 3 ) ;
5575: LD_INT 3
5577: PPUSH
5578: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
5582: LD_VAR 0 1
5586: PPUSH
5587: LD_INT 16
5589: PPUSH
5590: CALL_OW 250
5594: PPUSH
5595: LD_INT 16
5597: PPUSH
5598: CALL_OW 251
5602: PPUSH
5603: CALL_OW 114
// end ;
5607: PPOPN 1
5609: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
5610: LD_INT 16
5612: PPUSH
5613: CALL_OW 256
5617: PUSH
5618: LD_INT 650
5620: GREATER
5621: PUSH
5622: LD_INT 22
5624: PUSH
5625: LD_INT 3
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 25
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 56
5644: PUSH
5645: EMPTY
5646: LIST
5647: PUSH
5648: EMPTY
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: EMPTY
5654: LIST
5655: PPUSH
5656: CALL_OW 69
5660: AND
5661: IFFALSE 5773
5663: GO 5665
5665: DISABLE
5666: LD_INT 0
5668: PPUSH
5669: PPUSH
// begin enable ;
5670: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
5671: LD_ADDR_VAR 0 2
5675: PUSH
5676: LD_INT 22
5678: PUSH
5679: LD_INT 3
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 25
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 56
5698: PUSH
5699: EMPTY
5700: LIST
5701: PUSH
5702: LD_INT 3
5704: PUSH
5705: LD_INT 60
5707: PUSH
5708: EMPTY
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: PPUSH
5724: CALL_OW 69
5728: ST_TO_ADDR
// if not tmp then
5729: LD_VAR 0 2
5733: NOT
5734: IFFALSE 5738
// exit ;
5736: GO 5773
// for i in tmp do
5738: LD_ADDR_VAR 0 1
5742: PUSH
5743: LD_VAR 0 2
5747: PUSH
5748: FOR_IN
5749: IFFALSE 5771
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
5751: LD_VAR 0 1
5755: PPUSH
5756: LD_INT 0
5758: PPUSH
5759: LD_INT 143
5761: PPUSH
5762: LD_INT 143
5764: PPUSH
5765: CALL 735 0 4
5769: GO 5748
5771: POP
5772: POP
// end ;
5773: PPOPN 2
5775: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
5776: LD_INT 22
5778: PUSH
5779: LD_INT 3
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: PUSH
5786: LD_INT 25
5788: PUSH
5789: LD_INT 4
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PPUSH
5800: CALL_OW 69
5804: IFFALSE 6058
5806: GO 5808
5808: DISABLE
5809: LD_INT 0
5811: PPUSH
5812: PPUSH
5813: PPUSH
// begin enable ;
5814: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5815: LD_ADDR_VAR 0 2
5819: PUSH
5820: LD_INT 14
5822: PPUSH
5823: LD_INT 22
5825: PUSH
5826: LD_INT 3
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: LD_INT 3
5845: PUSH
5846: LD_INT 24
5848: PUSH
5849: LD_INT 1000
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: LIST
5864: PPUSH
5865: CALL_OW 70
5869: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
5870: LD_ADDR_VAR 0 3
5874: PUSH
5875: LD_INT 22
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 25
5887: PUSH
5888: LD_INT 4
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PPUSH
5899: CALL_OW 69
5903: ST_TO_ADDR
// if not doc then
5904: LD_VAR 0 3
5908: NOT
5909: IFFALSE 5913
// exit ;
5911: GO 6058
// if not tmp then
5913: LD_VAR 0 2
5917: NOT
5918: IFFALSE 6009
// begin if not IsInUnit ( doc [ 1 ] ) then
5920: LD_VAR 0 3
5924: PUSH
5925: LD_INT 1
5927: ARRAY
5928: PPUSH
5929: CALL_OW 310
5933: NOT
5934: IFFALSE 6007
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
5936: LD_VAR 0 3
5940: PPUSH
5941: LD_INT 22
5943: PUSH
5944: LD_INT 3
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: PUSH
5951: LD_INT 2
5953: PUSH
5954: LD_INT 30
5956: PUSH
5957: LD_INT 6
5959: PUSH
5960: EMPTY
5961: LIST
5962: LIST
5963: PUSH
5964: LD_INT 30
5966: PUSH
5967: LD_INT 7
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: PUSH
5974: LD_INT 30
5976: PUSH
5977: LD_INT 8
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: PPUSH
5994: CALL_OW 69
5998: PUSH
5999: LD_INT 1
6001: ARRAY
6002: PPUSH
6003: CALL_OW 120
// exit ;
6007: GO 6058
// end ; if IsInUnit ( doc [ 1 ] ) then
6009: LD_VAR 0 3
6013: PUSH
6014: LD_INT 1
6016: ARRAY
6017: PPUSH
6018: CALL_OW 310
6022: IFFALSE 6033
// ComExitBuilding ( doc ) ;
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 122
// wait ( 3 ) ;
6033: LD_INT 3
6035: PPUSH
6036: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
6040: LD_VAR 0 3
6044: PPUSH
6045: LD_VAR 0 2
6049: PUSH
6050: LD_INT 1
6052: ARRAY
6053: PPUSH
6054: CALL_OW 128
// end ;
6058: PPOPN 3
6060: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , areas , area ;
6061: LD_INT 22
6063: PUSH
6064: LD_INT 3
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: PUSH
6071: LD_INT 25
6073: PUSH
6074: LD_INT 3
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PPUSH
6085: CALL_OW 69
6089: PUSH
6090: LD_INT 22
6092: PUSH
6093: LD_INT 3
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 21
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 69
6118: AND
6119: IFFALSE 6341
6121: GO 6123
6123: DISABLE
6124: LD_INT 0
6126: PPUSH
6127: PPUSH
6128: PPUSH
6129: PPUSH
// begin enable ;
6130: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
6131: LD_ADDR_VAR 0 2
6135: PUSH
6136: LD_INT 22
6138: PUSH
6139: LD_INT 3
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 21
6148: PUSH
6149: LD_INT 2
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 3
6158: PUSH
6159: LD_INT 58
6161: PUSH
6162: EMPTY
6163: LIST
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: LIST
6173: PPUSH
6174: CALL_OW 69
6178: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
6179: LD_ADDR_VAR 0 3
6183: PUSH
6184: LD_INT 10
6186: PUSH
6187: LD_INT 11
6189: PUSH
6190: LD_INT 12
6192: PUSH
6193: LD_INT 14
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: ST_TO_ADDR
// area := 0 ;
6202: LD_ADDR_VAR 0 4
6206: PUSH
6207: LD_INT 0
6209: ST_TO_ADDR
// for i in areas do
6210: LD_ADDR_VAR 0 1
6214: PUSH
6215: LD_VAR 0 3
6219: PUSH
6220: FOR_IN
6221: IFFALSE 6258
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
6223: LD_VAR 0 1
6227: PPUSH
6228: LD_INT 22
6230: PUSH
6231: LD_INT 1
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 70
6242: IFFALSE 6256
// begin area := i ;
6244: LD_ADDR_VAR 0 4
6248: PUSH
6249: LD_VAR 0 1
6253: ST_TO_ADDR
// break ;
6254: GO 6258
// end ;
6256: GO 6220
6258: POP
6259: POP
// if area then
6260: LD_VAR 0 4
6264: IFFALSE 6341
// begin for i in tmp do
6266: LD_ADDR_VAR 0 1
6270: PUSH
6271: LD_VAR 0 2
6275: PUSH
6276: FOR_IN
6277: IFFALSE 6339
// begin if GetFuel ( i ) < 33 then
6279: LD_VAR 0 1
6283: PPUSH
6284: CALL_OW 261
6288: PUSH
6289: LD_INT 33
6291: LESS
6292: IFFALSE 6306
// SetFuel ( i , 33 ) ;
6294: LD_VAR 0 1
6298: PPUSH
6299: LD_INT 33
6301: PPUSH
6302: CALL_OW 240
// if not IsInArea ( i , area ) then
6306: LD_VAR 0 1
6310: PPUSH
6311: LD_VAR 0 4
6315: PPUSH
6316: CALL_OW 308
6320: NOT
6321: IFFALSE 6337
// ComMoveToArea ( i , area ) ;
6323: LD_VAR 0 1
6327: PPUSH
6328: LD_VAR 0 4
6332: PPUSH
6333: CALL_OW 113
// end ;
6337: GO 6276
6339: POP
6340: POP
// end ; end ;
6341: PPOPN 4
6343: END
// every 10 10$00 do var i , j , un , veh , time , count ;
6344: GO 6346
6346: DISABLE
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
6354: PPUSH
// begin uc_side := 3 ;
6355: LD_ADDR_OWVAR 20
6359: PUSH
6360: LD_INT 3
6362: ST_TO_ADDR
// uc_nation := 3 ;
6363: LD_ADDR_OWVAR 21
6367: PUSH
6368: LD_INT 3
6370: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
6371: LD_ADDR_VAR 0 5
6375: PUSH
6376: LD_INT 12600
6378: PUSH
6379: LD_INT 10500
6381: PUSH
6382: LD_INT 8400
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: PUSH
6390: LD_OWVAR 67
6394: ARRAY
6395: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
6396: LD_ADDR_VAR 0 6
6400: PUSH
6401: LD_INT 3
6403: PUSH
6404: LD_INT 4
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: LIST
6414: PUSH
6415: LD_OWVAR 67
6419: ARRAY
6420: ST_TO_ADDR
// for i = 1 to count do
6421: LD_ADDR_VAR 0 1
6425: PUSH
6426: DOUBLE
6427: LD_INT 1
6429: DEC
6430: ST_TO_ADDR
6431: LD_VAR 0 6
6435: PUSH
6436: FOR_TO
6437: IFFALSE 6732
// begin wait ( time ) ;
6439: LD_VAR 0 5
6443: PPUSH
6444: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
6448: LD_ADDR_VAR 0 2
6452: PUSH
6453: DOUBLE
6454: LD_INT 1
6456: DEC
6457: ST_TO_ADDR
6458: LD_INT 1
6460: PPUSH
6461: LD_OWVAR 67
6465: PPUSH
6466: CALL_OW 12
6470: PUSH
6471: FOR_TO
6472: IFFALSE 6613
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
6474: LD_ADDR_VAR 0 4
6478: PUSH
6479: LD_INT 3
6481: PPUSH
6482: LD_INT 3
6484: PPUSH
6485: LD_INT 22
6487: PPUSH
6488: LD_INT 1
6490: PPUSH
6491: LD_INT 1
6493: PPUSH
6494: LD_INT 43
6496: PUSH
6497: LD_INT 44
6499: PUSH
6500: LD_INT 42
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_VAR 0 1
6512: PUSH
6513: LD_INT 3
6515: MOD
6516: PUSH
6517: LD_INT 1
6519: PLUS
6520: ARRAY
6521: PPUSH
6522: LD_INT 80
6524: PPUSH
6525: CALL 417 0 7
6529: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
6530: LD_VAR 0 4
6534: PPUSH
6535: LD_INT 13
6537: PPUSH
6538: LD_INT 0
6540: PPUSH
6541: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
6545: LD_INT 0
6547: PPUSH
6548: LD_INT 3
6550: PPUSH
6551: LD_INT 4
6553: PUSH
6554: LD_INT 5
6556: PUSH
6557: LD_INT 5
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: LIST
6564: PUSH
6565: LD_OWVAR 67
6569: ARRAY
6570: PPUSH
6571: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6575: CALL_OW 44
6579: PPUSH
6580: LD_VAR 0 4
6584: PPUSH
6585: CALL_OW 52
// wait ( 0 0$01 ) ;
6589: LD_INT 35
6591: PPUSH
6592: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
6596: LD_VAR 0 4
6600: PPUSH
6601: LD_INT 143
6603: PPUSH
6604: LD_INT 143
6606: PPUSH
6607: CALL_OW 111
// end ;
6611: GO 6471
6613: POP
6614: POP
// if count < 3 then
6615: LD_VAR 0 6
6619: PUSH
6620: LD_INT 3
6622: LESS
6623: IFFALSE 6627
// continue ;
6625: GO 6436
// for j = 1 to 1 + Difficulty do
6627: LD_ADDR_VAR 0 2
6631: PUSH
6632: DOUBLE
6633: LD_INT 1
6635: DEC
6636: ST_TO_ADDR
6637: LD_INT 1
6639: PUSH
6640: LD_OWVAR 67
6644: PLUS
6645: PUSH
6646: FOR_TO
6647: IFFALSE 6728
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
6649: LD_INT 0
6651: PPUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 4
6657: PUSH
6658: LD_INT 5
6660: PUSH
6661: LD_INT 6
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_OWVAR 67
6673: ARRAY
6674: PPUSH
6675: CALL_OW 380
// un := CreateHuman ;
6679: LD_ADDR_VAR 0 3
6683: PUSH
6684: CALL_OW 44
6688: ST_TO_ADDR
// PlaceUnitArea ( un , southArea , false ) ;
6689: LD_VAR 0 3
6693: PPUSH
6694: LD_INT 13
6696: PPUSH
6697: LD_INT 0
6699: PPUSH
6700: CALL_OW 49
// ComMoveXY ( un , 143 , 143 ) ;
6704: LD_VAR 0 3
6708: PPUSH
6709: LD_INT 143
6711: PPUSH
6712: LD_INT 143
6714: PPUSH
6715: CALL_OW 111
// wait ( 0 0$01 ) ;
6719: LD_INT 35
6721: PPUSH
6722: CALL_OW 67
// end ;
6726: GO 6646
6728: POP
6729: POP
// end ;
6730: GO 6436
6732: POP
6733: POP
// end ;
6734: PPOPN 6
6736: END
// every 4 4$00 do var i , un , time ;
6737: GO 6739
6739: DISABLE
6740: LD_INT 0
6742: PPUSH
6743: PPUSH
6744: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
6745: LD_ADDR_VAR 0 3
6749: PUSH
6750: LD_INT 4200
6752: PUSH
6753: LD_INT 2100
6755: PUSH
6756: LD_INT 1050
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: ST_TO_ADDR
// wait ( time ) ;
6764: LD_VAR 0 3
6768: PPUSH
6769: CALL_OW 67
// uc_side := 3 ;
6773: LD_ADDR_OWVAR 20
6777: PUSH
6778: LD_INT 3
6780: ST_TO_ADDR
// uc_nation := 3 ;
6781: LD_ADDR_OWVAR 21
6785: PUSH
6786: LD_INT 3
6788: ST_TO_ADDR
// for i = 1 to 2 do
6789: LD_ADDR_VAR 0 1
6793: PUSH
6794: DOUBLE
6795: LD_INT 1
6797: DEC
6798: ST_TO_ADDR
6799: LD_INT 2
6801: PUSH
6802: FOR_TO
6803: IFFALSE 6866
// begin PrepareHuman ( false , 1 , 4 ) ;
6805: LD_INT 0
6807: PPUSH
6808: LD_INT 1
6810: PPUSH
6811: LD_INT 4
6813: PPUSH
6814: CALL_OW 380
// un := CreateHuman ;
6818: LD_ADDR_VAR 0 2
6822: PUSH
6823: CALL_OW 44
6827: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
6828: LD_VAR 0 2
6832: PPUSH
6833: LD_INT 16
6835: PPUSH
6836: CALL_OW 52
// ComExitBuilding ( un ) ;
6840: LD_VAR 0 2
6844: PPUSH
6845: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
6849: LD_VAR 0 2
6853: PPUSH
6854: LD_INT 41
6856: PPUSH
6857: LD_INT 76
6859: PPUSH
6860: CALL_OW 174
// end ;
6864: GO 6802
6866: POP
6867: POP
// end ; end_of_file
6868: PPOPN 3
6870: END
// export function Action ; begin
6871: LD_INT 0
6873: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
6874: LD_INT 28
6876: PPUSH
6877: LD_INT 3
6879: PPUSH
6880: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
6884: LD_INT 41
6886: PPUSH
6887: LD_INT 76
6889: PPUSH
6890: LD_INT 1
6892: PPUSH
6893: LD_INT 10
6895: PPUSH
6896: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
6900: LD_INT 41
6902: PPUSH
6903: LD_INT 76
6905: PPUSH
6906: LD_INT 1
6908: PPUSH
6909: CALL_OW 331
// InGameOn ;
6913: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
6917: LD_EXP 18
6921: PPUSH
6922: LD_STRING D2-Har-1
6924: PPUSH
6925: CALL_OW 94
// InGameOff ;
6929: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6933: LD_STRING M1
6935: PPUSH
6936: CALL_OW 337
// end ;
6940: LD_VAR 0 1
6944: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
6945: LD_EXP 4
6949: PUSH
6950: LD_INT 1
6952: GREATER
6953: IFFALSE 7044
6955: GO 6957
6957: DISABLE
6958: LD_INT 0
6960: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
6961: LD_ADDR_VAR 0 1
6965: PUSH
6966: LD_INT 1
6968: PPUSH
6969: CALL 505 0 1
6973: PUSH
6974: LD_INT 1
6976: ARRAY
6977: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
6978: LD_VAR 0 1
6982: PPUSH
6983: LD_STRING D2a-Sol1-1
6985: PPUSH
6986: CALL_OW 88
// if not un then
6990: LD_VAR 0 1
6994: NOT
6995: IFFALSE 7026
// begin un := GetRandom ( sex_female ) [ 1 ] ;
6997: LD_ADDR_VAR 0 1
7001: PUSH
7002: LD_INT 2
7004: PPUSH
7005: CALL 505 0 1
7009: PUSH
7010: LD_INT 1
7012: ARRAY
7013: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_STRING D2a-FSol1-1
7021: PPUSH
7022: CALL_OW 88
// end ; if Khatam then
7026: LD_EXP 16
7030: IFFALSE 7044
// Say ( Khatam , D3b-Khat-3 ) ;
7032: LD_EXP 16
7036: PPUSH
7037: LD_STRING D3b-Khat-3
7039: PPUSH
7040: CALL_OW 88
// end ;
7044: PPOPN 1
7046: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
7047: LD_EXP 14
7051: PUSH
7052: LD_EXP 8
7056: PPUSH
7057: LD_EXP 14
7061: PPUSH
7062: CALL_OW 296
7066: PUSH
7067: LD_INT 5
7069: LESS
7070: AND
7071: PUSH
7072: LD_INT 1
7074: PPUSH
7075: CALL_OW 463
7079: NOT
7080: AND
7081: IFFALSE 7668
7083: GO 7085
7085: DISABLE
7086: LD_INT 0
7088: PPUSH
7089: PPUSH
// begin InGameOn ;
7090: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
7094: LD_ADDR_VAR 0 2
7098: PUSH
7099: LD_INT 22
7101: PUSH
7102: LD_INT 0
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: PUSH
7109: LD_INT 25
7111: PUSH
7112: LD_INT 12
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PPUSH
7123: CALL_OW 69
7127: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
7128: LD_ADDR_VAR 0 2
7132: PUSH
7133: LD_VAR 0 2
7137: PPUSH
7138: LD_EXP 14
7142: PPUSH
7143: CALL_OW 74
7147: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
7148: LD_ADDR_VAR 0 1
7152: PUSH
7153: LD_INT 22
7155: PUSH
7156: LD_INT 1
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: PUSH
7163: LD_INT 21
7165: PUSH
7166: LD_INT 1
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 91
7175: PUSH
7176: LD_EXP 14
7180: PUSH
7181: LD_INT 20
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: PUSH
7199: FOR_IN
7200: IFFALSE 7218
// ComTurnUnit ( i , Frank ) ;
7202: LD_VAR 0 1
7206: PPUSH
7207: LD_EXP 14
7211: PPUSH
7212: CALL_OW 119
7216: GO 7199
7218: POP
7219: POP
// SetSide ( Frank , 1 ) ;
7220: LD_EXP 14
7224: PPUSH
7225: LD_INT 1
7227: PPUSH
7228: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
7232: LD_EXP 8
7236: PPUSH
7237: LD_EXP 14
7241: PPUSH
7242: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
7246: LD_EXP 8
7250: PPUSH
7251: LD_EXP 14
7255: PPUSH
7256: CALL_OW 179
// CenterOnUnits ( Frank ) ;
7260: LD_EXP 14
7264: PPUSH
7265: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
7269: LD_EXP 14
7273: PPUSH
7274: LD_STRING D3a-Frank-1
7276: PPUSH
7277: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
7281: LD_VAR 0 2
7285: PPUSH
7286: LD_INT 42
7288: PPUSH
7289: LD_INT 78
7291: PPUSH
7292: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
7296: LD_VAR 0 2
7300: PPUSH
7301: LD_EXP 14
7305: PPUSH
7306: CALL_OW 179
// if Lisa then
7310: LD_EXP 13
7314: IFFALSE 7328
// Say ( Lisa , D3a-Lisa-1 ) ;
7316: LD_EXP 13
7320: PPUSH
7321: LD_STRING D3a-Lisa-1
7323: PPUSH
7324: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
7328: LD_EXP 8
7332: PPUSH
7333: LD_STRING D3a-JMM-1
7335: PPUSH
7336: CALL_OW 88
// if Cyrus then
7340: LD_EXP 12
7344: IFFALSE 7358
// Say ( Cyrus , D3a-Cyrus-1 ) ;
7346: LD_EXP 12
7350: PPUSH
7351: LD_STRING D3a-Cyrus-1
7353: PPUSH
7354: CALL_OW 88
// if GetRandom ( sex_male ) then
7358: LD_INT 1
7360: PPUSH
7361: CALL 505 0 1
7365: IFFALSE 7386
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
7367: LD_INT 1
7369: PPUSH
7370: CALL 505 0 1
7374: PUSH
7375: LD_INT 1
7377: ARRAY
7378: PPUSH
7379: LD_STRING D3a-Sol1-1
7381: PPUSH
7382: CALL_OW 88
// if GetRandom ( sex_female ) then
7386: LD_INT 2
7388: PPUSH
7389: CALL 505 0 1
7393: IFFALSE 7414
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
7395: LD_INT 2
7397: PPUSH
7398: CALL 505 0 1
7402: PUSH
7403: LD_INT 1
7405: ARRAY
7406: PPUSH
7407: LD_STRING D3a-FSol1-1
7409: PPUSH
7410: CALL_OW 88
// if Gladstone then
7414: LD_EXP 15
7418: IFFALSE 7432
// Say ( Gladstone , D3a-Glad-1 ) ;
7420: LD_EXP 15
7424: PPUSH
7425: LD_STRING D3a-Glad-1
7427: PPUSH
7428: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
7432: LD_VAR 0 2
7436: PPUSH
7437: LD_INT 60
7439: PPUSH
7440: LD_INT 113
7442: PPUSH
7443: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
7447: LD_EXP 14
7451: PPUSH
7452: LD_STRING D3a-Frank-2
7454: PPUSH
7455: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
7459: LD_EXP 14
7463: PPUSH
7464: LD_EXP 8
7468: PPUSH
7469: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
7473: LD_EXP 8
7477: PPUSH
7478: LD_STRING D3a-JMM-2
7480: PPUSH
7481: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7485: LD_INT 1
7487: PPUSH
7488: LD_INT 4
7490: PPUSH
7491: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7495: LD_INT 85
7497: PPUSH
7498: LD_INT 134
7500: PPUSH
7501: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
7505: LD_EXP 14
7509: PPUSH
7510: LD_STRING D3a-Frank-3
7512: PPUSH
7513: CALL_OW 88
// Wait ( 0 0$01 ) ;
7517: LD_INT 35
7519: PPUSH
7520: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
7524: LD_INT 166
7526: PPUSH
7527: LD_INT 136
7529: PPUSH
7530: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
7534: LD_EXP 8
7538: PPUSH
7539: LD_STRING D3a-JMM-3
7541: PPUSH
7542: CALL_OW 88
// Wait ( 0 0$01 ) ;
7546: LD_INT 35
7548: PPUSH
7549: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
7553: LD_EXP 14
7557: PPUSH
7558: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
7562: LD_EXP 14
7566: PPUSH
7567: LD_STRING D3a-Frank-4
7569: PPUSH
7570: CALL_OW 88
// if Lisa then
7574: LD_EXP 13
7578: IFFALSE 7592
// Say ( Lisa , D3a-Lisa-4 ) ;
7580: LD_EXP 13
7584: PPUSH
7585: LD_STRING D3a-Lisa-4
7587: PPUSH
7588: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
7592: LD_EXP 8
7596: PPUSH
7597: LD_STRING D3a-JMM-4
7599: PPUSH
7600: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
7604: LD_EXP 14
7608: PPUSH
7609: LD_STRING D3a-Frank-5
7611: PPUSH
7612: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
7616: LD_EXP 8
7620: PPUSH
7621: LD_STRING D3a-JMM-5
7623: PPUSH
7624: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
7628: LD_EXP 14
7632: PPUSH
7633: LD_STRING D3a-Frank-6
7635: PPUSH
7636: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
7640: LD_EXP 8
7644: PPUSH
7645: LD_STRING D3a-JMM-6
7647: PPUSH
7648: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
7652: LD_EXP 14
7656: PPUSH
7657: LD_STRING D3a-Frank-7
7659: PPUSH
7660: CALL_OW 88
// InGameOff ;
7664: CALL_OW 9
// end ;
7668: PPOPN 2
7670: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
7671: LD_EXP 17
7675: PUSH
7676: LD_EXP 8
7680: PPUSH
7681: LD_EXP 17
7685: PPUSH
7686: CALL_OW 296
7690: PUSH
7691: LD_INT 5
7693: LESS
7694: AND
7695: PUSH
7696: LD_INT 1
7698: PPUSH
7699: CALL_OW 463
7703: NOT
7704: AND
7705: IFFALSE 7885
7707: GO 7709
7709: DISABLE
// begin InGameOn ;
7710: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
7714: LD_EXP 8
7718: PPUSH
7719: LD_EXP 17
7723: PPUSH
7724: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
7728: LD_EXP 17
7732: PPUSH
7733: LD_EXP 8
7737: PPUSH
7738: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
7742: LD_EXP 17
7746: PPUSH
7747: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
7751: LD_EXP 17
7755: PPUSH
7756: LD_STRING D3b-Yam-1
7758: PPUSH
7759: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
7763: LD_EXP 8
7767: PPUSH
7768: LD_STRING D3b-JMM-1
7770: PPUSH
7771: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7775: LD_INT 1
7777: PPUSH
7778: LD_INT 4
7780: PPUSH
7781: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7785: LD_INT 85
7787: PPUSH
7788: LD_INT 134
7790: PPUSH
7791: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
7795: LD_EXP 17
7799: PPUSH
7800: LD_STRING D3b-Yam-2
7802: PPUSH
7803: CALL_OW 88
// Wait ( 0 0$01 ) ;
7807: LD_INT 35
7809: PPUSH
7810: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
7814: LD_EXP 8
7818: PPUSH
7819: LD_STRING D3b-JMM-2
7821: PPUSH
7822: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
7826: LD_INT 166
7828: PPUSH
7829: LD_INT 136
7831: PPUSH
7832: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
7836: LD_EXP 17
7840: PPUSH
7841: LD_STRING D3b-Yam-3
7843: PPUSH
7844: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
7848: LD_EXP 8
7852: PPUSH
7853: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
7857: LD_EXP 8
7861: PPUSH
7862: LD_STRING D3b-JMM-3a
7864: PPUSH
7865: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
7869: LD_EXP 17
7873: PPUSH
7874: LD_INT 1
7876: PPUSH
7877: CALL_OW 235
// InGameOff ;
7881: CALL_OW 9
// end ;
7885: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
7886: LD_INT 7
7888: PPUSH
7889: LD_INT 22
7891: PUSH
7892: LD_INT 1
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: PUSH
7899: LD_INT 3
7901: PUSH
7902: LD_INT 24
7904: PUSH
7905: LD_INT 1000
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PPUSH
7920: CALL_OW 70
7924: IFFALSE 8342
7926: GO 7928
7928: DISABLE
7929: LD_INT 0
7931: PPUSH
7932: PPUSH
7933: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
7934: LD_ADDR_VAR 0 1
7938: PUSH
7939: LD_INT 7
7941: PPUSH
7942: LD_INT 22
7944: PUSH
7945: LD_INT 1
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 3
7954: PUSH
7955: LD_INT 24
7957: PUSH
7958: LD_INT 1000
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PPUSH
7973: CALL_OW 70
7977: PUSH
7978: LD_INT 1
7980: ARRAY
7981: ST_TO_ADDR
// DialogueOn ;
7982: CALL_OW 6
// CenterNowOnUnits ( un ) ;
7986: LD_VAR 0 1
7990: PPUSH
7991: CALL_OW 87
// if Lisa then
7995: LD_EXP 13
7999: IFFALSE 8027
// begin Say ( Lisa , D5-Lisa-1 ) ;
8001: LD_EXP 13
8005: PPUSH
8006: LD_STRING D5-Lisa-1
8008: PPUSH
8009: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
8013: LD_EXP 8
8017: PPUSH
8018: LD_STRING D5-JMM-1a
8020: PPUSH
8021: CALL_OW 88
// end else
8025: GO 8039
// Say ( JMM , D5-JMM-1 ) ;
8027: LD_EXP 8
8031: PPUSH
8032: LD_STRING D5-JMM-1
8034: PPUSH
8035: CALL_OW 88
// DialogueOff ;
8039: CALL_OW 7
// while ( true ) do
8043: LD_INT 1
8045: IFFALSE 8101
// begin wait ( 0 0$01 ) ;
8047: LD_INT 35
8049: PPUSH
8050: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
8054: LD_ADDR_VAR 0 2
8058: PUSH
8059: LD_INT 8
8061: PPUSH
8062: LD_INT 30
8064: PUSH
8065: LD_INT 26
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 101
8074: PUSH
8075: LD_INT 1
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PPUSH
8086: CALL_OW 71
8090: ST_TO_ADDR
// if x then
8091: LD_VAR 0 2
8095: IFFALSE 8099
// break ;
8097: GO 8101
// end ;
8099: GO 8043
// CenterOnUnits ( x [ 1 ] ) ;
8101: LD_VAR 0 2
8105: PUSH
8106: LD_INT 1
8108: ARRAY
8109: PPUSH
8110: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
8114: LD_EXP 14
8118: PUSH
8119: LD_EXP 14
8123: PPUSH
8124: CALL_OW 255
8128: PUSH
8129: LD_INT 1
8131: EQUAL
8132: AND
8133: IFFALSE 8149
// Say ( Frank , D5a-Frank-1 ) else
8135: LD_EXP 14
8139: PPUSH
8140: LD_STRING D5a-Frank-1
8142: PPUSH
8143: CALL_OW 88
8147: GO 8203
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8149: LD_EXP 17
8153: PUSH
8154: LD_EXP 17
8158: PPUSH
8159: CALL_OW 255
8163: PUSH
8164: LD_INT 1
8166: EQUAL
8167: AND
8168: IFFALSE 8184
// Say ( Kikuchi , D5a-Yam-1 ) else
8170: LD_EXP 17
8174: PPUSH
8175: LD_STRING D5a-Yam-1
8177: PPUSH
8178: CALL_OW 88
8182: GO 8203
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
8184: LD_INT 1
8186: PPUSH
8187: CALL 505 0 1
8191: PUSH
8192: LD_INT 1
8194: ARRAY
8195: PPUSH
8196: LD_STRING D5a-Sol1-1
8198: PPUSH
8199: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
8203: LD_EXP 8
8207: PPUSH
8208: LD_STRING D5a-JMM-1
8210: PPUSH
8211: CALL_OW 88
// if Cyrus then
8215: LD_EXP 12
8219: IFFALSE 8233
// Say ( Cyrus , D5a-Cyrus-1 ) ;
8221: LD_EXP 12
8225: PPUSH
8226: LD_STRING D5a-Cyrus-1
8228: PPUSH
8229: CALL_OW 88
// x := false ;
8233: LD_ADDR_VAR 0 2
8237: PUSH
8238: LD_INT 0
8240: ST_TO_ADDR
// while ( true ) do
8241: LD_INT 1
8243: IFFALSE 8330
// begin wait ( 0 0$01 ) ;
8245: LD_INT 35
8247: PPUSH
8248: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
8252: LD_ADDR_VAR 0 3
8256: PUSH
8257: LD_INT 2
8259: PUSH
8260: LD_INT 30
8262: PUSH
8263: LD_INT 0
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 30
8272: PUSH
8273: LD_INT 1
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: PPUSH
8285: CALL_OW 69
8289: PUSH
8290: LD_INT 1
8292: DIFF
8293: PUSH
8294: FOR_IN
8295: IFFALSE 8318
// if BaseNeedEnergy ( i ) then
8297: LD_VAR 0 3
8301: PPUSH
8302: CALL 1208 0 1
8306: IFFALSE 8316
// x := true ;
8308: LD_ADDR_VAR 0 2
8312: PUSH
8313: LD_INT 1
8315: ST_TO_ADDR
8316: GO 8294
8318: POP
8319: POP
// if x then
8320: LD_VAR 0 2
8324: IFFALSE 8328
// break ;
8326: GO 8330
// end ;
8328: GO 8241
// Say ( JMM , D5b-JMM-1 ) ;
8330: LD_EXP 8
8334: PPUSH
8335: LD_STRING D5b-JMM-1
8337: PPUSH
8338: CALL_OW 88
// end ;
8342: PPOPN 3
8344: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
8345: LD_EXP 5
8349: PUSH
8350: LD_INT 1
8352: ARRAY
8353: PUSH
8354: LD_OWVAR 1
8358: LESS
8359: IFFALSE 8559
8361: GO 8363
8363: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8364: LD_INT 16
8366: PPUSH
8367: CALL_OW 301
8371: NOT
8372: IFFALSE 8395
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
8374: LD_EXP 18
8378: PPUSH
8379: LD_STRING D3b-Har-3
8381: PPUSH
8382: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
8386: LD_STRING M2a
8388: PPUSH
8389: CALL_OW 337
// end else
8393: GO 8414
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
8395: LD_EXP 18
8399: PPUSH
8400: LD_STRING D3b-Har-3a
8402: PPUSH
8403: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
8407: LD_STRING M2
8409: PPUSH
8410: CALL_OW 337
// end ; can_end := true ;
8414: LD_ADDR_EXP 6
8418: PUSH
8419: LD_INT 1
8421: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
8422: LD_INT 9
8424: PPUSH
8425: LD_INT 1
8427: PPUSH
8428: CALL_OW 424
// Wait ( 0 0$02 ) ;
8432: LD_INT 70
8434: PPUSH
8435: CALL_OW 67
// if Lisa then
8439: LD_EXP 13
8443: IFFALSE 8457
// Say ( Lisa , D3b-Lisa ) ;
8445: LD_EXP 13
8449: PPUSH
8450: LD_STRING D3b-Lisa
8452: PPUSH
8453: CALL_OW 88
// if Bobby then
8457: LD_EXP 11
8461: IFFALSE 8475
// Say ( Bobby , D3b-Bobby-3 ) ;
8463: LD_EXP 11
8467: PPUSH
8468: LD_STRING D3b-Bobby-3
8470: PPUSH
8471: CALL_OW 88
// if Cyrus then
8475: LD_EXP 12
8479: IFFALSE 8493
// Say ( Cyrus , D3b-Cyrus-3 ) ;
8481: LD_EXP 12
8485: PPUSH
8486: LD_STRING D3b-Cyrus-3
8488: PPUSH
8489: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
8493: LD_EXP 14
8497: PUSH
8498: LD_EXP 14
8502: PPUSH
8503: CALL_OW 255
8507: PUSH
8508: LD_INT 1
8510: EQUAL
8511: AND
8512: IFFALSE 8526
// Say ( Frank , D3b-Frank-3 ) ;
8514: LD_EXP 14
8518: PPUSH
8519: LD_STRING D3b-Frank-3
8521: PPUSH
8522: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8526: LD_EXP 17
8530: PUSH
8531: LD_EXP 17
8535: PPUSH
8536: CALL_OW 255
8540: PUSH
8541: LD_INT 1
8543: EQUAL
8544: AND
8545: IFFALSE 8559
// Say ( Kikuchi , D3b-Yam-4 ) ;
8547: LD_EXP 17
8551: PPUSH
8552: LD_STRING D3b-Yam-4
8554: PPUSH
8555: CALL_OW 88
// end ;
8559: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
8560: LD_EXP 5
8564: PUSH
8565: LD_INT 2
8567: ARRAY
8568: PUSH
8569: LD_OWVAR 1
8573: LESS
8574: IFFALSE 8606
8576: GO 8578
8578: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
8579: LD_EXP 18
8583: PPUSH
8584: LD_STRING D4-Har-1
8586: PPUSH
8587: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
8591: LD_STRING M3
8593: PPUSH
8594: CALL_OW 337
// must_end := true ;
8598: LD_ADDR_EXP 7
8602: PUSH
8603: LD_INT 1
8605: ST_TO_ADDR
// end ;
8606: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
8607: LD_EXP 5
8611: PUSH
8612: LD_INT 3
8614: ARRAY
8615: PUSH
8616: LD_OWVAR 1
8620: LESS
8621: IFFALSE 8652
8623: GO 8625
8625: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8626: LD_INT 16
8628: PPUSH
8629: CALL_OW 301
8633: NOT
8634: IFFALSE 8645
// YouLost ( TimeOut1 ) else
8636: LD_STRING TimeOut1
8638: PPUSH
8639: CALL_OW 104
8643: GO 8652
// YouLost ( TimeOut2 ) ;
8645: LD_STRING TimeOut2
8647: PPUSH
8648: CALL_OW 104
// end ;
8652: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
8653: LD_EXP 8
8657: PPUSH
8658: LD_INT 9
8660: PPUSH
8661: CALL_OW 308
8665: PUSH
8666: LD_EXP 6
8670: AND
8671: IFFALSE 9662
8673: GO 8675
8675: DISABLE
8676: LD_INT 0
8678: PPUSH
8679: PPUSH
8680: PPUSH
// begin wait_on := false ;
8681: LD_ADDR_VAR 0 1
8685: PUSH
8686: LD_INT 0
8688: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
8689: LD_INT 1
8691: PPUSH
8692: CALL 1285 0 1
8696: PUSH
8697: LD_INT 0
8699: PLUS
8700: PUSH
8701: LD_INT 1
8703: PPUSH
8704: LD_INT 9
8706: PPUSH
8707: CALL 1376 0 2
8711: PUSH
8712: LD_INT 1
8714: PPUSH
8715: LD_INT 9
8717: PPUSH
8718: CALL 1423 0 2
8722: ADD
8723: PUSH
8724: LD_INT 0
8726: PLUS
8727: GREATER
8728: IFFALSE 8777
// case Query ( Q1 ) of 1 :
8730: LD_STRING Q1
8732: PPUSH
8733: CALL_OW 97
8737: PUSH
8738: LD_INT 1
8740: DOUBLE
8741: EQUAL
8742: IFTRUE 8746
8744: GO 8757
8746: POP
// wait_on := true ; 2 :
8747: LD_ADDR_VAR 0 1
8751: PUSH
8752: LD_INT 1
8754: ST_TO_ADDR
8755: GO 8777
8757: LD_INT 2
8759: DOUBLE
8760: EQUAL
8761: IFTRUE 8765
8763: GO 8776
8765: POP
// wait_on := false ; end ;
8766: LD_ADDR_VAR 0 1
8770: PUSH
8771: LD_INT 0
8773: ST_TO_ADDR
8774: GO 8777
8776: POP
// repeat wait ( 0 0$01 ) ;
8777: LD_INT 35
8779: PPUSH
8780: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
8784: LD_VAR 0 1
8788: NOT
8789: PUSH
8790: LD_INT 1
8792: PPUSH
8793: CALL 1285 0 1
8797: PUSH
8798: LD_INT 0
8800: PLUS
8801: PUSH
8802: LD_INT 1
8804: PPUSH
8805: LD_INT 9
8807: PPUSH
8808: CALL 1376 0 2
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 9
8818: PPUSH
8819: CALL 1423 0 2
8823: ADD
8824: PUSH
8825: LD_INT 0
8827: PLUS
8828: EQUAL
8829: OR
8830: IFFALSE 8777
// DialogueOn ;
8832: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
8836: LD_EXP 8
8840: PPUSH
8841: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
8845: LD_EXP 8
8849: PPUSH
8850: LD_STRING D6-JMM-1
8852: PPUSH
8853: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
8857: LD_EXP 18
8861: PPUSH
8862: LD_STRING D6-Har-1
8864: PPUSH
8865: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
8869: LD_EXP 8
8873: PPUSH
8874: LD_STRING D6-JMM-2
8876: PPUSH
8877: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
8881: LD_EXP 18
8885: PPUSH
8886: LD_STRING D6-Har-2
8888: PPUSH
8889: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
8893: LD_EXP 8
8897: PPUSH
8898: LD_STRING D6-JMM-3
8900: PPUSH
8901: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
8905: LD_EXP 18
8909: PPUSH
8910: LD_STRING D6-Har-3
8912: PPUSH
8913: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
8917: LD_EXP 8
8921: PPUSH
8922: LD_STRING D6-JMM-4
8924: PPUSH
8925: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
8929: LD_EXP 18
8933: PPUSH
8934: LD_STRING D6-Har-4
8936: PPUSH
8937: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
8941: LD_EXP 8
8945: PPUSH
8946: LD_STRING D6-JMM-5
8948: PPUSH
8949: CALL_OW 88
// DialogueOff ;
8953: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
8957: LD_ADDR_VAR 0 3
8961: PUSH
8962: LD_INT 3
8964: PPUSH
8965: CALL 1554 0 1
8969: ST_TO_ADDR
// if tmp >= 35 then
8970: LD_VAR 0 3
8974: PUSH
8975: LD_INT 35
8977: GREATEREQUAL
8978: IFFALSE 9015
// begin AddMedal ( Destroy1 , - 1 ) ;
8980: LD_STRING Destroy1
8982: PPUSH
8983: LD_INT 1
8985: NEG
8986: PPUSH
8987: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
8991: LD_STRING Destroy2
8993: PPUSH
8994: LD_INT 1
8996: NEG
8997: PPUSH
8998: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
9002: LD_STRING Destroy3
9004: PPUSH
9005: LD_INT 1
9007: NEG
9008: PPUSH
9009: CALL_OW 101
// end else
9013: GO 9102
// begin AddMedal ( Destroy1 , 1 ) ;
9015: LD_STRING Destroy1
9017: PPUSH
9018: LD_INT 1
9020: PPUSH
9021: CALL_OW 101
// if tmp >= 25 then
9025: LD_VAR 0 3
9029: PUSH
9030: LD_INT 25
9032: GREATEREQUAL
9033: IFFALSE 9059
// begin AddMedal ( Destroy2 , - 1 ) ;
9035: LD_STRING Destroy2
9037: PPUSH
9038: LD_INT 1
9040: NEG
9041: PPUSH
9042: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
9046: LD_STRING Destroy3
9048: PPUSH
9049: LD_INT 1
9051: NEG
9052: PPUSH
9053: CALL_OW 101
// end else
9057: GO 9102
// begin AddMedal ( Destroy2 , 1 ) ;
9059: LD_STRING Destroy2
9061: PPUSH
9062: LD_INT 1
9064: PPUSH
9065: CALL_OW 101
// if tmp >= 15 then
9069: LD_VAR 0 3
9073: PUSH
9074: LD_INT 15
9076: GREATEREQUAL
9077: IFFALSE 9092
// AddMedal ( Destroy3 , - 1 ) else
9079: LD_STRING Destroy3
9081: PPUSH
9082: LD_INT 1
9084: NEG
9085: PPUSH
9086: CALL_OW 101
9090: GO 9102
// AddMedal ( Destroy3 , 1 ) ;
9092: LD_STRING Destroy3
9094: PPUSH
9095: LD_INT 1
9097: PPUSH
9098: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
9102: LD_STRING MAIN
9104: PPUSH
9105: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 1
9116: PPUSH
9117: LD_INT 9
9119: PPUSH
9120: CALL 1376 0 2
9124: PUSH
9125: LD_INT 1
9127: PPUSH
9128: LD_INT 9
9130: PPUSH
9131: CALL 1423 0 2
9135: ADD
9136: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9137: LD_VAR 0 3
9141: PPUSH
9142: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
9146: LD_EXP 8
9150: PPUSH
9151: LD_EXP 3
9155: PUSH
9156: LD_STRING JMM
9158: STR
9159: PPUSH
9160: CALL_OW 38
// if Brown in tmp then
9164: LD_EXP 9
9168: PUSH
9169: LD_VAR 0 3
9173: IN
9174: IFFALSE 9194
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
9176: LD_EXP 9
9180: PPUSH
9181: LD_EXP 3
9185: PUSH
9186: LD_STRING Brown
9188: STR
9189: PPUSH
9190: CALL_OW 38
// if Donaldson in tmp then
9194: LD_EXP 10
9198: PUSH
9199: LD_VAR 0 3
9203: IN
9204: IFFALSE 9224
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
9206: LD_EXP 10
9210: PPUSH
9211: LD_EXP 3
9215: PUSH
9216: LD_STRING Donaldson
9218: STR
9219: PPUSH
9220: CALL_OW 38
// if Bobby in tmp then
9224: LD_EXP 11
9228: PUSH
9229: LD_VAR 0 3
9233: IN
9234: IFFALSE 9254
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
9236: LD_EXP 11
9240: PPUSH
9241: LD_EXP 3
9245: PUSH
9246: LD_STRING Bobby
9248: STR
9249: PPUSH
9250: CALL_OW 38
// if Cyrus in tmp then
9254: LD_EXP 12
9258: PUSH
9259: LD_VAR 0 3
9263: IN
9264: IFFALSE 9284
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
9266: LD_EXP 12
9270: PPUSH
9271: LD_EXP 3
9275: PUSH
9276: LD_STRING Cyrus
9278: STR
9279: PPUSH
9280: CALL_OW 38
// if Lisa in tmp then
9284: LD_EXP 13
9288: PUSH
9289: LD_VAR 0 3
9293: IN
9294: IFFALSE 9314
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
9296: LD_EXP 13
9300: PPUSH
9301: LD_EXP 3
9305: PUSH
9306: LD_STRING Lisa
9308: STR
9309: PPUSH
9310: CALL_OW 38
// if Frank in tmp then
9314: LD_EXP 14
9318: PUSH
9319: LD_VAR 0 3
9323: IN
9324: IFFALSE 9344
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
9326: LD_EXP 14
9330: PPUSH
9331: LD_EXP 3
9335: PUSH
9336: LD_STRING Frank
9338: STR
9339: PPUSH
9340: CALL_OW 38
// if Gladstone in tmp then
9344: LD_EXP 15
9348: PUSH
9349: LD_VAR 0 3
9353: IN
9354: IFFALSE 9374
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
9356: LD_EXP 15
9360: PPUSH
9361: LD_EXP 3
9365: PUSH
9366: LD_STRING Gladstone
9368: STR
9369: PPUSH
9370: CALL_OW 38
// if Khatam in tmp then
9374: LD_EXP 16
9378: PUSH
9379: LD_VAR 0 3
9383: IN
9384: IFFALSE 9404
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
9386: LD_EXP 16
9390: PPUSH
9391: LD_EXP 3
9395: PUSH
9396: LD_STRING Khatam
9398: STR
9399: PPUSH
9400: CALL_OW 38
// if Kikuchi in tmp then
9404: LD_EXP 17
9408: PUSH
9409: LD_VAR 0 3
9413: IN
9414: IFFALSE 9434
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
9416: LD_EXP 17
9420: PPUSH
9421: LD_EXP 3
9425: PUSH
9426: LD_STRING Kikuchi
9428: STR
9429: PPUSH
9430: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
9434: LD_VAR 0 3
9438: PUSH
9439: LD_EXP 8
9443: PUSH
9444: LD_EXP 9
9448: PUSH
9449: LD_EXP 10
9453: PUSH
9454: LD_EXP 11
9458: PUSH
9459: LD_EXP 12
9463: PUSH
9464: LD_EXP 13
9468: PUSH
9469: LD_EXP 14
9473: PUSH
9474: LD_EXP 15
9478: PUSH
9479: LD_EXP 17
9483: PUSH
9484: LD_EXP 16
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: LIST
9493: LIST
9494: LIST
9495: LIST
9496: LIST
9497: LIST
9498: LIST
9499: LIST
9500: DIFF
9501: PPUSH
9502: LD_EXP 3
9506: PUSH
9507: LD_STRING others
9509: STR
9510: PPUSH
9511: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
9515: LD_OWVAR 1
9519: PPUSH
9520: LD_STRING 07_time
9522: PPUSH
9523: CALL_OW 39
// tmp := [ ] ;
9527: LD_ADDR_VAR 0 3
9531: PUSH
9532: EMPTY
9533: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_INT 22
9541: PUSH
9542: LD_INT 1
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 23
9551: PUSH
9552: LD_INT 1
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: LD_INT 21
9561: PUSH
9562: LD_INT 2
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: PPUSH
9577: CALL_OW 69
9581: PUSH
9582: FOR_IN
9583: IFFALSE 9644
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
9585: LD_ADDR_VAR 0 3
9589: PUSH
9590: LD_VAR 0 3
9594: PUSH
9595: LD_VAR 0 2
9599: PPUSH
9600: CALL_OW 265
9604: PUSH
9605: LD_VAR 0 2
9609: PPUSH
9610: CALL_OW 262
9614: PUSH
9615: LD_VAR 0 2
9619: PPUSH
9620: CALL_OW 263
9624: PUSH
9625: LD_VAR 0 2
9629: PPUSH
9630: CALL_OW 264
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: ADD
9641: ST_TO_ADDR
9642: GO 9582
9644: POP
9645: POP
// SaveVariable ( tmp , 07_vehicles ) ;
9646: LD_VAR 0 3
9650: PPUSH
9651: LD_STRING 07_vehicles
9653: PPUSH
9654: CALL_OW 39
// YouWin ;
9658: CALL_OW 103
// end ; end_of_file
9662: PPOPN 3
9664: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9665: LD_VAR 0 1
9669: PUSH
9670: LD_EXP 8
9674: EQUAL
9675: IFFALSE 9684
// YouLost ( JMM ) ;
9677: LD_STRING JMM
9679: PPUSH
9680: CALL_OW 104
// if GetType ( un ) = unit_building then
9684: LD_VAR 0 1
9688: PPUSH
9689: CALL_OW 247
9693: PUSH
9694: LD_INT 3
9696: EQUAL
9697: IFFALSE 9713
// buildings_counter := buildings_counter + 1 ;
9699: LD_ADDR_EXP 4
9703: PUSH
9704: LD_EXP 4
9708: PUSH
9709: LD_INT 1
9711: PLUS
9712: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
9713: LD_VAR 0 1
9717: PUSH
9718: LD_INT 6
9720: PPUSH
9721: LD_INT 2
9723: PUSH
9724: LD_INT 30
9726: PUSH
9727: LD_INT 33
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: LD_INT 30
9736: PUSH
9737: LD_INT 32
9739: PUSH
9740: EMPTY
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: LIST
9748: PPUSH
9749: CALL_OW 70
9753: IN
9754: IFFALSE 9813
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
9756: LD_ADDR_EXP 19
9760: PUSH
9761: LD_EXP 19
9765: PUSH
9766: LD_VAR 0 1
9770: PPUSH
9771: CALL_OW 266
9775: PUSH
9776: LD_VAR 0 1
9780: PPUSH
9781: CALL_OW 250
9785: PUSH
9786: LD_VAR 0 1
9790: PPUSH
9791: CALL_OW 251
9795: PUSH
9796: LD_VAR 0 1
9800: PPUSH
9801: CALL_OW 254
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: ADD
9812: ST_TO_ADDR
// if un = ru_dep_main then
9813: LD_VAR 0 1
9817: PUSH
9818: LD_INT 16
9820: EQUAL
9821: IFFALSE 9830
// ChangeMissionObjectives ( M1a ) ;
9823: LD_STRING M1a
9825: PPUSH
9826: CALL_OW 337
// end ;
9830: PPOPN 1
9832: END
// on BuildingStarted ( b , builder ) do var i ;
9833: LD_INT 0
9835: PPUSH
// begin if GetSide ( b ) = 3 then
9836: LD_VAR 0 1
9840: PPUSH
9841: CALL_OW 255
9845: PUSH
9846: LD_INT 3
9848: EQUAL
9849: IFFALSE 9889
// for i = 1 to 4 do
9851: LD_ADDR_VAR 0 3
9855: PUSH
9856: DOUBLE
9857: LD_INT 1
9859: DEC
9860: ST_TO_ADDR
9861: LD_INT 4
9863: PUSH
9864: FOR_TO
9865: IFFALSE 9887
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
9867: LD_ADDR_EXP 19
9871: PUSH
9872: LD_EXP 19
9876: PPUSH
9877: LD_INT 1
9879: PPUSH
9880: CALL_OW 3
9884: ST_TO_ADDR
9885: GO 9864
9887: POP
9888: POP
// end ;
9889: PPOPN 3
9891: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
9892: LD_VAR 0 1
9896: PPUSH
9897: CALL_OW 266
9901: PUSH
9902: LD_INT 32
9904: PUSH
9905: LD_INT 33
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: IN
9912: IFFALSE 9926
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_INT 43
9921: PPUSH
9922: CALL_OW 148
9926: PPOPN 1
9928: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
9929: LD_VAR 0 1
9933: PUSH
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 2
9946: PUSH
9947: LD_INT 30
9949: PUSH
9950: LD_INT 31
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 30
9959: PUSH
9960: LD_INT 32
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: LIST
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: PPUSH
9976: CALL_OW 69
9980: IN
9981: IFFALSE 10003
// GoToAnotherTower ( un , b , 143 , 143 ) ;
9983: LD_VAR 0 2
9987: PPUSH
9988: LD_VAR 0 1
9992: PPUSH
9993: LD_INT 143
9995: PPUSH
9996: LD_INT 143
9998: PPUSH
9999: CALL 735 0 4
// end ;
10003: PPOPN 2
10005: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
10006: LD_VAR 0 1
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 30
10023: PUSH
10024: LD_INT 32
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PPUSH
10035: CALL_OW 69
10039: IN
10040: IFFALSE 10054
// SetTag ( b , 0 ) ;
10042: LD_VAR 0 1
10046: PPUSH
10047: LD_INT 0
10049: PPUSH
10050: CALL_OW 109
// end ;
10054: PPOPN 2
10056: END
