// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 2918 0 0
// PrepareRussians ;
  20: CALL 4632 0 0
// PrepareAmericans ;
  24: CALL 3575 0 0
// Action ;
  28: CALL 8395 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 67200
  75: PUSH
  76: LD_INT 60900
  78: PUSH
  79: LD_INT 54600
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 79800
  95: PUSH
  96: LD_INT 73500
  98: PUSH
  99: LD_INT 67200
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 92400
 115: PUSH
 116: LD_INT 86100
 118: PUSH
 119: LD_INT 79800
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; var i ; begin
 234: LD_INT 0
 236: PPUSH
 237: PPUSH
// if not debug then
 238: LD_EXP 1
 242: NOT
 243: IFFALSE 247
// exit ;
 245: GO 254
// FogOff ( 1 ) ;
 247: LD_INT 1
 249: PPUSH
 250: CALL_OW 344
// end ;
 254: LD_VAR 0 1
 258: RET
// every 3 trigger debug do var i , filter ;
 259: LD_EXP 1
 263: IFFALSE 352
 265: GO 267
 267: DISABLE
 268: LD_INT 0
 270: PPUSH
 271: PPUSH
// begin enable ;
 272: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 273: LD_ADDR_VAR 0 2
 277: PUSH
 278: LD_INT 22
 280: PUSH
 281: LD_INT 1
 283: PUSH
 284: EMPTY
 285: LIST
 286: LIST
 287: PUSH
 288: LD_INT 3
 290: PUSH
 291: LD_INT 24
 293: PUSH
 294: LD_INT 500
 296: PUSH
 297: EMPTY
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: LIST
 304: PUSH
 305: EMPTY
 306: LIST
 307: LIST
 308: PPUSH
 309: CALL_OW 69
 313: ST_TO_ADDR
// if not filter then
 314: LD_VAR 0 2
 318: NOT
 319: IFFALSE 323
// exit ;
 321: GO 352
// for i in filter do
 323: LD_ADDR_VAR 0 1
 327: PUSH
 328: LD_VAR 0 2
 332: PUSH
 333: FOR_IN
 334: IFFALSE 350
// SetLives ( i , 1000 ) ;
 336: LD_VAR 0 1
 340: PPUSH
 341: LD_INT 1000
 343: PPUSH
 344: CALL_OW 234
 348: GO 333
 350: POP
 351: POP
// end ; end_of_file
 352: PPOPN 2
 354: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 355: LD_INT 0
 357: PPUSH
 358: PPUSH
// if exist_mode then
 359: LD_VAR 0 2
 363: IFFALSE 388
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 365: LD_ADDR_VAR 0 4
 369: PUSH
 370: LD_EXP 2
 374: PUSH
 375: LD_VAR 0 1
 379: STR
 380: PPUSH
 381: CALL_OW 34
 385: ST_TO_ADDR
 386: GO 403
// unit := NewCharacter ( ident ) ;
 388: LD_ADDR_VAR 0 4
 392: PUSH
 393: LD_VAR 0 1
 397: PPUSH
 398: CALL_OW 25
 402: ST_TO_ADDR
// result := unit ;
 403: LD_ADDR_VAR 0 3
 407: PUSH
 408: LD_VAR 0 4
 412: ST_TO_ADDR
// end ;
 413: LD_VAR 0 3
 417: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 418: LD_INT 0
 420: PPUSH
// uc_side := side ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_VAR 0 1
 430: ST_TO_ADDR
// uc_nation := nation ;
 431: LD_ADDR_OWVAR 21
 435: PUSH
 436: LD_VAR 0 2
 440: ST_TO_ADDR
// vc_chassis := chassis ;
 441: LD_ADDR_OWVAR 37
 445: PUSH
 446: LD_VAR 0 3
 450: ST_TO_ADDR
// vc_engine := engine ;
 451: LD_ADDR_OWVAR 39
 455: PUSH
 456: LD_VAR 0 4
 460: ST_TO_ADDR
// vc_control := control ;
 461: LD_ADDR_OWVAR 38
 465: PUSH
 466: LD_VAR 0 5
 470: ST_TO_ADDR
// vc_weapon := weapon ;
 471: LD_ADDR_OWVAR 40
 475: PUSH
 476: LD_VAR 0 6
 480: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 481: LD_ADDR_OWVAR 41
 485: PUSH
 486: LD_VAR 0 7
 490: ST_TO_ADDR
// result := CreateVehicle ;
 491: LD_ADDR_VAR 0 8
 495: PUSH
 496: CALL_OW 45
 500: ST_TO_ADDR
// end ;
 501: LD_VAR 0 8
 505: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 506: LD_INT 0
 508: PPUSH
 509: PPUSH
 510: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 511: LD_ADDR_VAR 0 4
 515: PUSH
 516: LD_INT 22
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: EMPTY
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 21
 528: PUSH
 529: LD_INT 1
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: PUSH
 536: LD_INT 50
 538: PUSH
 539: EMPTY
 540: LIST
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: PPUSH
 547: CALL_OW 69
 551: PUSH
 552: LD_EXP 8
 556: PUSH
 557: LD_EXP 9
 561: PUSH
 562: LD_EXP 10
 566: PUSH
 567: LD_EXP 11
 571: PUSH
 572: LD_EXP 12
 576: PUSH
 577: LD_EXP 13
 581: PUSH
 582: LD_EXP 14
 586: PUSH
 587: LD_EXP 15
 591: PUSH
 592: LD_EXP 17
 596: PUSH
 597: LD_EXP 16
 601: PUSH
 602: EMPTY
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: LIST
 613: DIFF
 614: ST_TO_ADDR
// if not filter then
 615: LD_VAR 0 4
 619: NOT
 620: IFFALSE 624
// exit ;
 622: GO 651
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 624: LD_ADDR_VAR 0 2
 628: PUSH
 629: LD_VAR 0 4
 633: PPUSH
 634: LD_INT 26
 636: PUSH
 637: LD_VAR 0 1
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: PPUSH
 646: CALL_OW 72
 650: ST_TO_ADDR
// end ;
 651: LD_VAR 0 2
 655: RET
// export function SayX ( units , ident ) ; var i ; begin
 656: LD_INT 0
 658: PPUSH
 659: PPUSH
// result := false ;
 660: LD_ADDR_VAR 0 3
 664: PUSH
 665: LD_INT 0
 667: ST_TO_ADDR
// if not units then
 668: LD_VAR 0 1
 672: NOT
 673: IFFALSE 677
// exit ;
 675: GO 731
// for i in units do
 677: LD_ADDR_VAR 0 4
 681: PUSH
 682: LD_VAR 0 1
 686: PUSH
 687: FOR_IN
 688: IFFALSE 729
// if IsOk ( i ) then
 690: LD_VAR 0 4
 694: PPUSH
 695: CALL_OW 302
 699: IFFALSE 727
// begin Say ( i , ident ) ;
 701: LD_VAR 0 4
 705: PPUSH
 706: LD_VAR 0 2
 710: PPUSH
 711: CALL_OW 88
// result := i ;
 715: LD_ADDR_VAR 0 3
 719: PUSH
 720: LD_VAR 0 4
 724: ST_TO_ADDR
// break ;
 725: GO 729
// end ;
 727: GO 687
 729: POP
 730: POP
// end ;
 731: LD_VAR 0 3
 735: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 736: LD_INT 0
 738: PPUSH
 739: PPUSH
 740: PPUSH
// result := [ ] ;
 741: LD_ADDR_VAR 0 2
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_INT 21
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: ST_TO_ADDR
// if not tmp then
 768: LD_VAR 0 3
 772: NOT
 773: IFFALSE 777
// exit ;
 775: GO 827
// for i in tmp do
 777: LD_ADDR_VAR 0 4
 781: PUSH
 782: LD_VAR 0 3
 786: PUSH
 787: FOR_IN
 788: IFFALSE 825
// if GetBase ( i ) = base then
 790: LD_VAR 0 4
 794: PPUSH
 795: CALL_OW 274
 799: PUSH
 800: LD_VAR 0 1
 804: EQUAL
 805: IFFALSE 823
// result := result ^ i ;
 807: LD_ADDR_VAR 0 2
 811: PUSH
 812: LD_VAR 0 2
 816: PUSH
 817: LD_VAR 0 4
 821: ADD
 822: ST_TO_ADDR
 823: GO 787
 825: POP
 826: POP
// end ;
 827: LD_VAR 0 2
 831: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 832: LD_INT 0
 834: PPUSH
 835: PPUSH
 836: PPUSH
 837: PPUSH
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
 843: PPUSH
 844: PPUSH
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
 849: PPUSH
// result := false ;
 850: LD_ADDR_VAR 0 2
 854: PUSH
 855: LD_INT 0
 857: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 858: LD_VAR 0 1
 862: NOT
 863: PUSH
 864: LD_VAR 0 1
 868: PPUSH
 869: CALL_OW 266
 873: PUSH
 874: LD_INT 32
 876: PUSH
 877: LD_INT 33
 879: PUSH
 880: EMPTY
 881: LIST
 882: LIST
 883: IN
 884: NOT
 885: OR
 886: IFFALSE 890
// exit ;
 888: GO 2050
// nat := GetNation ( tower ) ;
 890: LD_ADDR_VAR 0 11
 894: PUSH
 895: LD_VAR 0 1
 899: PPUSH
 900: CALL_OW 248
 904: ST_TO_ADDR
// side := GetSide ( tower ) ;
 905: LD_ADDR_VAR 0 15
 909: PUSH
 910: LD_VAR 0 1
 914: PPUSH
 915: CALL_OW 255
 919: ST_TO_ADDR
// x := GetX ( tower ) ;
 920: LD_ADDR_VAR 0 9
 924: PUSH
 925: LD_VAR 0 1
 929: PPUSH
 930: CALL_OW 250
 934: ST_TO_ADDR
// y := GetY ( tower ) ;
 935: LD_ADDR_VAR 0 10
 939: PUSH
 940: LD_VAR 0 1
 944: PPUSH
 945: CALL_OW 251
 949: ST_TO_ADDR
// if not x or not y then
 950: LD_VAR 0 9
 954: NOT
 955: PUSH
 956: LD_VAR 0 10
 960: NOT
 961: OR
 962: IFFALSE 966
// exit ;
 964: GO 2050
// weapon := 0 ;
 966: LD_ADDR_VAR 0 17
 970: PUSH
 971: LD_INT 0
 973: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 974: LD_ADDR_VAR 0 16
 978: PUSH
 979: LD_INT 42
 981: PUSH
 982: LD_INT 43
 984: PUSH
 985: LD_INT 44
 987: PUSH
 988: LD_INT 46
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: ST_TO_ADDR
// if not fac_list then
 997: LD_VAR 0 16
1001: NOT
1002: IFFALSE 1006
// exit ;
1004: GO 2050
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1006: LD_ADDR_VAR 0 4
1010: PUSH
1011: LD_INT 4
1013: PUSH
1014: LD_INT 5
1016: PUSH
1017: LD_INT 9
1019: PUSH
1020: LD_INT 10
1022: PUSH
1023: LD_INT 6
1025: PUSH
1026: LD_INT 7
1028: PUSH
1029: LD_INT 11
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 27
1043: PUSH
1044: LD_INT 28
1046: PUSH
1047: LD_INT 26
1049: PUSH
1050: LD_INT 30
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 43
1061: PUSH
1062: LD_INT 44
1064: PUSH
1065: LD_INT 46
1067: PUSH
1068: LD_INT 45
1070: PUSH
1071: LD_INT 47
1073: PUSH
1074: LD_INT 49
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: EMPTY
1086: LIST
1087: LIST
1088: LIST
1089: PUSH
1090: LD_VAR 0 11
1094: ARRAY
1095: ST_TO_ADDR
// for i in list do
1096: LD_ADDR_VAR 0 7
1100: PUSH
1101: LD_VAR 0 4
1105: PUSH
1106: FOR_IN
1107: IFFALSE 1140
// if not i in fac_list then
1109: LD_VAR 0 7
1113: PUSH
1114: LD_VAR 0 16
1118: IN
1119: NOT
1120: IFFALSE 1138
// list := list diff i ;
1122: LD_ADDR_VAR 0 4
1126: PUSH
1127: LD_VAR 0 4
1131: PUSH
1132: LD_VAR 0 7
1136: DIFF
1137: ST_TO_ADDR
1138: GO 1106
1140: POP
1141: POP
// if not list then
1142: LD_VAR 0 4
1146: NOT
1147: IFFALSE 1151
// exit ;
1149: GO 2050
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1151: LD_VAR 0 11
1155: PUSH
1156: LD_INT 3
1158: EQUAL
1159: PUSH
1160: LD_INT 49
1162: PUSH
1163: LD_VAR 0 4
1167: IN
1168: AND
1169: PUSH
1170: LD_INT 31
1172: PPUSH
1173: LD_VAR 0 15
1177: PPUSH
1178: CALL_OW 321
1182: PUSH
1183: LD_INT 2
1185: EQUAL
1186: AND
1187: IFFALSE 1247
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1189: LD_INT 22
1191: PUSH
1192: LD_VAR 0 15
1196: PUSH
1197: EMPTY
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 35
1203: PUSH
1204: LD_INT 49
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: PUSH
1211: LD_INT 91
1213: PUSH
1214: LD_VAR 0 1
1218: PUSH
1219: LD_INT 10
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: LIST
1231: PPUSH
1232: CALL_OW 69
1236: NOT
1237: IFFALSE 1247
// weapon := ru_time_lapser ;
1239: LD_ADDR_VAR 0 17
1243: PUSH
1244: LD_INT 49
1246: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1247: LD_VAR 0 11
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 2
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: IN
1262: PUSH
1263: LD_INT 11
1265: PUSH
1266: LD_VAR 0 4
1270: IN
1271: PUSH
1272: LD_INT 30
1274: PUSH
1275: LD_VAR 0 4
1279: IN
1280: OR
1281: AND
1282: PUSH
1283: LD_INT 6
1285: PPUSH
1286: LD_VAR 0 15
1290: PPUSH
1291: CALL_OW 321
1295: PUSH
1296: LD_INT 2
1298: EQUAL
1299: AND
1300: IFFALSE 1465
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1302: LD_INT 22
1304: PUSH
1305: LD_VAR 0 15
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: PUSH
1314: LD_INT 2
1316: PUSH
1317: LD_INT 35
1319: PUSH
1320: LD_INT 11
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: PUSH
1327: LD_INT 35
1329: PUSH
1330: LD_INT 30
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: PUSH
1337: EMPTY
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: LD_INT 91
1344: PUSH
1345: LD_VAR 0 1
1349: PUSH
1350: LD_INT 18
1352: PUSH
1353: EMPTY
1354: LIST
1355: LIST
1356: LIST
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: LIST
1362: PPUSH
1363: CALL_OW 69
1367: NOT
1368: PUSH
1369: LD_INT 22
1371: PUSH
1372: LD_VAR 0 15
1376: PUSH
1377: EMPTY
1378: LIST
1379: LIST
1380: PUSH
1381: LD_INT 2
1383: PUSH
1384: LD_INT 30
1386: PUSH
1387: LD_INT 32
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: PUSH
1394: LD_INT 30
1396: PUSH
1397: LD_INT 33
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: PUSH
1404: EMPTY
1405: LIST
1406: LIST
1407: LIST
1408: PUSH
1409: LD_INT 91
1411: PUSH
1412: LD_VAR 0 1
1416: PUSH
1417: LD_INT 12
1419: PUSH
1420: EMPTY
1421: LIST
1422: LIST
1423: LIST
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: PUSH
1430: EMPTY
1431: LIST
1432: PPUSH
1433: CALL_OW 69
1437: PUSH
1438: LD_INT 2
1440: GREATER
1441: AND
1442: IFFALSE 1465
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1444: LD_ADDR_VAR 0 17
1448: PUSH
1449: LD_INT 11
1451: PUSH
1452: LD_INT 30
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: LD_VAR 0 11
1463: ARRAY
1464: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1465: LD_VAR 0 17
1469: NOT
1470: PUSH
1471: LD_INT 40
1473: PPUSH
1474: LD_VAR 0 15
1478: PPUSH
1479: CALL_OW 321
1483: PUSH
1484: LD_INT 2
1486: EQUAL
1487: AND
1488: PUSH
1489: LD_INT 7
1491: PUSH
1492: LD_VAR 0 4
1496: IN
1497: PUSH
1498: LD_INT 28
1500: PUSH
1501: LD_VAR 0 4
1505: IN
1506: OR
1507: PUSH
1508: LD_INT 45
1510: PUSH
1511: LD_VAR 0 4
1515: IN
1516: OR
1517: AND
1518: IFFALSE 1772
// begin hex := GetHexInfo ( x , y ) ;
1520: LD_ADDR_VAR 0 3
1524: PUSH
1525: LD_VAR 0 9
1529: PPUSH
1530: LD_VAR 0 10
1534: PPUSH
1535: CALL_OW 546
1539: ST_TO_ADDR
// if hex [ 1 ] then
1540: LD_VAR 0 3
1544: PUSH
1545: LD_INT 1
1547: ARRAY
1548: IFFALSE 1552
// exit ;
1550: GO 2050
// height := hex [ 2 ] ;
1552: LD_ADDR_VAR 0 14
1556: PUSH
1557: LD_VAR 0 3
1561: PUSH
1562: LD_INT 2
1564: ARRAY
1565: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1566: LD_ADDR_VAR 0 13
1570: PUSH
1571: LD_INT 0
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: LD_INT 5
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: ST_TO_ADDR
// for i in tmp do
1589: LD_ADDR_VAR 0 7
1593: PUSH
1594: LD_VAR 0 13
1598: PUSH
1599: FOR_IN
1600: IFFALSE 1770
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1602: LD_ADDR_VAR 0 8
1606: PUSH
1607: LD_VAR 0 9
1611: PPUSH
1612: LD_VAR 0 7
1616: PPUSH
1617: LD_INT 5
1619: PPUSH
1620: CALL_OW 272
1624: PUSH
1625: LD_VAR 0 10
1629: PPUSH
1630: LD_VAR 0 7
1634: PPUSH
1635: LD_INT 5
1637: PPUSH
1638: CALL_OW 273
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1647: LD_VAR 0 8
1651: PUSH
1652: LD_INT 1
1654: ARRAY
1655: PPUSH
1656: LD_VAR 0 8
1660: PUSH
1661: LD_INT 2
1663: ARRAY
1664: PPUSH
1665: CALL_OW 488
1669: IFFALSE 1768
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1671: LD_ADDR_VAR 0 3
1675: PUSH
1676: LD_VAR 0 8
1680: PUSH
1681: LD_INT 1
1683: ARRAY
1684: PPUSH
1685: LD_VAR 0 8
1689: PUSH
1690: LD_INT 2
1692: ARRAY
1693: PPUSH
1694: CALL_OW 546
1698: ST_TO_ADDR
// if hex [ 1 ] then
1699: LD_VAR 0 3
1703: PUSH
1704: LD_INT 1
1706: ARRAY
1707: IFFALSE 1711
// continue ;
1709: GO 1599
// h := hex [ 2 ] ;
1711: LD_ADDR_VAR 0 12
1715: PUSH
1716: LD_VAR 0 3
1720: PUSH
1721: LD_INT 2
1723: ARRAY
1724: ST_TO_ADDR
// if h + 7 < height then
1725: LD_VAR 0 12
1729: PUSH
1730: LD_INT 7
1732: PLUS
1733: PUSH
1734: LD_VAR 0 14
1738: LESS
1739: IFFALSE 1768
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1741: LD_ADDR_VAR 0 17
1745: PUSH
1746: LD_INT 7
1748: PUSH
1749: LD_INT 28
1751: PUSH
1752: LD_INT 45
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: PUSH
1760: LD_VAR 0 11
1764: ARRAY
1765: ST_TO_ADDR
// break ;
1766: GO 1770
// end ; end ; end ;
1768: GO 1599
1770: POP
1771: POP
// end ; if not weapon then
1772: LD_VAR 0 17
1776: NOT
1777: IFFALSE 1932
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1779: LD_ADDR_VAR 0 4
1783: PUSH
1784: LD_VAR 0 4
1788: PUSH
1789: LD_INT 11
1791: PUSH
1792: LD_INT 30
1794: PUSH
1795: LD_INT 49
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: DIFF
1803: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1804: LD_ADDR_VAR 0 13
1808: PUSH
1809: LD_INT 22
1811: PUSH
1812: LD_VAR 0 15
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: PUSH
1821: LD_INT 91
1823: PUSH
1824: LD_VAR 0 1
1828: PUSH
1829: LD_INT 6
1831: PUSH
1832: EMPTY
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 3
1839: PUSH
1840: LD_INT 35
1842: PUSH
1843: LD_INT 0
1845: PUSH
1846: EMPTY
1847: LIST
1848: LIST
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: LIST
1858: PPUSH
1859: CALL_OW 69
1863: ST_TO_ADDR
// for i in tmp do
1864: LD_ADDR_VAR 0 7
1868: PUSH
1869: LD_VAR 0 13
1873: PUSH
1874: FOR_IN
1875: IFFALSE 1900
// list := list diff GetBWeapon ( i ) ;
1877: LD_ADDR_VAR 0 4
1881: PUSH
1882: LD_VAR 0 4
1886: PUSH
1887: LD_VAR 0 7
1891: PPUSH
1892: CALL_OW 269
1896: DIFF
1897: ST_TO_ADDR
1898: GO 1874
1900: POP
1901: POP
// if list then
1902: LD_VAR 0 4
1906: IFFALSE 1932
// weapon := list [ rand ( 1 , list ) ] ;
1908: LD_ADDR_VAR 0 17
1912: PUSH
1913: LD_VAR 0 4
1917: PUSH
1918: LD_INT 1
1920: PPUSH
1921: LD_VAR 0 4
1925: PPUSH
1926: CALL_OW 12
1930: ARRAY
1931: ST_TO_ADDR
// end ; if weapon then
1932: LD_VAR 0 17
1936: IFFALSE 2050
// begin tmp := CostOfWeapon ( weapon ) ;
1938: LD_ADDR_VAR 0 13
1942: PUSH
1943: LD_VAR 0 17
1947: PPUSH
1948: CALL_OW 451
1952: ST_TO_ADDR
// j := GetBase ( tower ) ;
1953: LD_ADDR_VAR 0 8
1957: PUSH
1958: LD_VAR 0 1
1962: PPUSH
1963: CALL_OW 274
1967: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1968: LD_VAR 0 8
1972: PPUSH
1973: LD_INT 1
1975: PPUSH
1976: CALL_OW 275
1980: PUSH
1981: LD_VAR 0 13
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: GREATEREQUAL
1990: PUSH
1991: LD_VAR 0 8
1995: PPUSH
1996: LD_INT 2
1998: PPUSH
1999: CALL_OW 275
2003: PUSH
2004: LD_VAR 0 13
2008: PUSH
2009: LD_INT 2
2011: ARRAY
2012: GREATEREQUAL
2013: AND
2014: PUSH
2015: LD_VAR 0 8
2019: PPUSH
2020: LD_INT 3
2022: PPUSH
2023: CALL_OW 275
2027: PUSH
2028: LD_VAR 0 13
2032: PUSH
2033: LD_INT 3
2035: ARRAY
2036: GREATEREQUAL
2037: AND
2038: IFFALSE 2050
// result := weapon ;
2040: LD_ADDR_VAR 0 2
2044: PUSH
2045: LD_VAR 0 17
2049: ST_TO_ADDR
// end ; end ;
2050: LD_VAR 0 2
2054: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2055: LD_INT 0
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
2061: PPUSH
// if not un or not IsOk ( un ) then
2062: LD_VAR 0 1
2066: NOT
2067: PUSH
2068: LD_VAR 0 1
2072: PPUSH
2073: CALL_OW 302
2077: NOT
2078: OR
2079: IFFALSE 2083
// exit ;
2081: GO 2523
// side := GetSide ( un ) ;
2083: LD_ADDR_VAR 0 9
2087: PUSH
2088: LD_VAR 0 1
2092: PPUSH
2093: CALL_OW 255
2097: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2098: LD_ADDR_VAR 0 7
2102: PUSH
2103: LD_INT 22
2105: PUSH
2106: LD_VAR 0 9
2110: PUSH
2111: EMPTY
2112: LIST
2113: LIST
2114: PUSH
2115: LD_INT 30
2117: PUSH
2118: LD_INT 32
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 50
2127: PUSH
2128: EMPTY
2129: LIST
2130: PUSH
2131: LD_INT 58
2133: PUSH
2134: EMPTY
2135: LIST
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 69
2147: PUSH
2148: LD_VAR 0 2
2152: DIFF
2153: ST_TO_ADDR
// if not filter then
2154: LD_VAR 0 7
2158: NOT
2159: IFFALSE 2388
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2161: LD_ADDR_VAR 0 7
2165: PUSH
2166: LD_INT 22
2168: PUSH
2169: LD_VAR 0 9
2173: PUSH
2174: EMPTY
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 30
2180: PUSH
2181: LD_INT 5
2183: PUSH
2184: EMPTY
2185: LIST
2186: LIST
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PPUSH
2192: CALL_OW 69
2196: ST_TO_ADDR
// if debug then
2197: LD_EXP 1
2201: IFFALSE 2220
// display_strings := [ filter , 1 ] ;
2203: LD_ADDR_OWVAR 47
2207: PUSH
2208: LD_VAR 0 7
2212: PUSH
2213: LD_STRING 1
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: ST_TO_ADDR
// if not filter then
2220: LD_VAR 0 7
2224: NOT
2225: IFFALSE 2248
// begin ComMoveXY ( un , x , y ) ;
2227: LD_VAR 0 1
2231: PPUSH
2232: LD_VAR 0 3
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 111
// exit ;
2246: GO 2523
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2248: LD_ADDR_VAR 0 8
2252: PUSH
2253: LD_VAR 0 7
2257: PPUSH
2258: LD_VAR 0 1
2262: PPUSH
2263: CALL_OW 74
2267: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2268: LD_VAR 0 8
2272: PPUSH
2273: CALL_OW 313
2277: PUSH
2278: LD_INT 6
2280: EQUAL
2281: IFFALSE 2301
// filter := filter diff t else
2283: LD_ADDR_VAR 0 7
2287: PUSH
2288: LD_VAR 0 7
2292: PUSH
2293: LD_VAR 0 8
2297: DIFF
2298: ST_TO_ADDR
2299: GO 2303
// break ;
2301: GO 2325
// until UnitsInside ( t ) < 6 or not filter ;
2303: LD_VAR 0 8
2307: PPUSH
2308: CALL_OW 313
2312: PUSH
2313: LD_INT 6
2315: LESS
2316: PUSH
2317: LD_VAR 0 7
2321: NOT
2322: OR
2323: IFFALSE 2248
// display_strings := [ filter , t ] ;
2325: LD_ADDR_OWVAR 47
2329: PUSH
2330: LD_VAR 0 7
2334: PUSH
2335: LD_VAR 0 8
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: ST_TO_ADDR
// if not filter then
2344: LD_VAR 0 7
2348: NOT
2349: IFFALSE 2372
// ComMoveXY ( un , x , y ) else
2351: LD_VAR 0 1
2355: PPUSH
2356: LD_VAR 0 3
2360: PPUSH
2361: LD_VAR 0 4
2365: PPUSH
2366: CALL_OW 111
2370: GO 2386
// ComEnterUnit ( un , t ) ;
2372: LD_VAR 0 1
2376: PPUSH
2377: LD_VAR 0 8
2381: PPUSH
2382: CALL_OW 120
// end else
2386: GO 2523
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2388: LD_ADDR_VAR 0 8
2392: PUSH
2393: LD_VAR 0 7
2397: PPUSH
2398: LD_VAR 0 1
2402: PPUSH
2403: CALL_OW 74
2407: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2408: LD_VAR 0 8
2412: PPUSH
2413: CALL_OW 110
2417: PUSH
2418: LD_INT 7
2420: EQUAL
2421: IFFALSE 2439
// filter := filter diff t ;
2423: LD_ADDR_VAR 0 7
2427: PUSH
2428: LD_VAR 0 7
2432: PUSH
2433: LD_VAR 0 8
2437: DIFF
2438: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2439: LD_VAR 0 8
2443: PPUSH
2444: CALL_OW 110
2448: PUSH
2449: LD_INT 7
2451: NONEQUAL
2452: PUSH
2453: LD_VAR 0 7
2457: NOT
2458: OR
2459: IFFALSE 2388
// if GetTag ( t ) <> 7 then
2461: LD_VAR 0 8
2465: PPUSH
2466: CALL_OW 110
2470: PUSH
2471: LD_INT 7
2473: NONEQUAL
2474: IFFALSE 2504
// begin SetTag ( t , 7 ) ;
2476: LD_VAR 0 8
2480: PPUSH
2481: LD_INT 7
2483: PPUSH
2484: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2488: LD_VAR 0 1
2492: PPUSH
2493: LD_VAR 0 8
2497: PPUSH
2498: CALL_OW 120
// end else
2502: GO 2523
// ComMoveXY ( un , x , y ) ;
2504: LD_VAR 0 1
2508: PPUSH
2509: LD_VAR 0 3
2513: PPUSH
2514: LD_VAR 0 4
2518: PPUSH
2519: CALL_OW 111
// end ; end ;
2523: LD_VAR 0 5
2527: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2528: LD_INT 0
2530: PPUSH
2531: PPUSH
2532: PPUSH
// if not base then
2533: LD_VAR 0 1
2537: NOT
2538: IFFALSE 2542
// exit ;
2540: GO 2600
// tmp := GetEnergy ( GetBase ( base ) ) ;
2542: LD_ADDR_VAR 0 4
2546: PUSH
2547: LD_VAR 0 1
2551: PPUSH
2552: CALL_OW 274
2556: PPUSH
2557: CALL_OW 278
2561: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2562: LD_VAR 0 4
2566: PUSH
2567: LD_INT 1
2569: ARRAY
2570: PUSH
2571: LD_VAR 0 4
2575: PUSH
2576: LD_INT 4
2578: ARRAY
2579: GREATER
2580: IFFALSE 2592
// result := true else
2582: LD_ADDR_VAR 0 2
2586: PUSH
2587: LD_INT 1
2589: ST_TO_ADDR
2590: GO 2600
// result := false ;
2592: LD_ADDR_VAR 0 2
2596: PUSH
2597: LD_INT 0
2599: ST_TO_ADDR
// end ;
2600: LD_VAR 0 2
2604: RET
// export function FilterPeople ( side ) ; begin
2605: LD_INT 0
2607: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2608: LD_ADDR_VAR 0 2
2612: PUSH
2613: LD_INT 22
2615: PUSH
2616: LD_VAR 0 1
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: PUSH
2625: LD_INT 21
2627: PUSH
2628: LD_INT 1
2630: PUSH
2631: EMPTY
2632: LIST
2633: LIST
2634: PUSH
2635: EMPTY
2636: LIST
2637: LIST
2638: PPUSH
2639: CALL_OW 69
2643: ST_TO_ADDR
// end ;
2644: LD_VAR 0 2
2648: RET
// export function FilterDrivers ( side ) ; begin
2649: LD_INT 0
2651: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2652: LD_ADDR_VAR 0 2
2656: PUSH
2657: LD_INT 22
2659: PUSH
2660: LD_VAR 0 1
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: PUSH
2669: LD_INT 3
2671: PUSH
2672: LD_INT 56
2674: PUSH
2675: EMPTY
2676: LIST
2677: PUSH
2678: EMPTY
2679: LIST
2680: LIST
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: PPUSH
2686: CALL_OW 69
2690: ST_TO_ADDR
// end ;
2691: LD_VAR 0 2
2695: RET
// export function FilterPeopleArea ( side , area ) ; begin
2696: LD_INT 0
2698: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2699: LD_ADDR_VAR 0 3
2703: PUSH
2704: LD_VAR 0 2
2708: PPUSH
2709: LD_INT 22
2711: PUSH
2712: LD_INT 1
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: LD_INT 21
2721: PUSH
2722: LD_INT 1
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 70
2737: ST_TO_ADDR
// end ;
2738: LD_VAR 0 3
2742: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2743: LD_INT 0
2745: PPUSH
2746: PPUSH
2747: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2748: LD_ADDR_VAR 0 5
2752: PUSH
2753: LD_VAR 0 2
2757: PPUSH
2758: LD_INT 22
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 21
2770: PUSH
2771: LD_INT 2
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: LD_INT 3
2780: PUSH
2781: LD_INT 58
2783: PUSH
2784: EMPTY
2785: LIST
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: LIST
2795: PPUSH
2796: CALL_OW 70
2800: ST_TO_ADDR
// result := [ ] ;
2801: LD_ADDR_VAR 0 3
2805: PUSH
2806: EMPTY
2807: ST_TO_ADDR
// if not tmp then
2808: LD_VAR 0 5
2812: NOT
2813: IFFALSE 2817
// exit ;
2815: GO 2869
// for i in tmp do
2817: LD_ADDR_VAR 0 4
2821: PUSH
2822: LD_VAR 0 5
2826: PUSH
2827: FOR_IN
2828: IFFALSE 2853
// result := result union IsDrivenBy ( i ) ;
2830: LD_ADDR_VAR 0 3
2834: PUSH
2835: LD_VAR 0 3
2839: PUSH
2840: LD_VAR 0 4
2844: PPUSH
2845: CALL_OW 311
2849: UNION
2850: ST_TO_ADDR
2851: GO 2827
2853: POP
2854: POP
// result := result diff 0 ;
2855: LD_ADDR_VAR 0 3
2859: PUSH
2860: LD_VAR 0 3
2864: PUSH
2865: LD_INT 0
2867: DIFF
2868: ST_TO_ADDR
// end ;
2869: LD_VAR 0 3
2873: RET
// export function FilterBuildings ( side ) ; begin
2874: LD_INT 0
2876: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2877: LD_ADDR_VAR 0 2
2881: PUSH
2882: LD_INT 22
2884: PUSH
2885: LD_VAR 0 1
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: PUSH
2894: LD_INT 21
2896: PUSH
2897: LD_INT 3
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: PPUSH
2908: CALL_OW 69
2912: ST_TO_ADDR
// end ;
2913: LD_VAR 0 2
2917: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
// uc_side = 0 ;
2924: LD_ADDR_OWVAR 20
2928: PUSH
2929: LD_INT 0
2931: ST_TO_ADDR
// uc_nation = 0 ;
2932: LD_ADDR_OWVAR 21
2936: PUSH
2937: LD_INT 0
2939: ST_TO_ADDR
// nat_area := wildArea ;
2940: LD_ADDR_VAR 0 4
2944: PUSH
2945: LD_INT 3
2947: ST_TO_ADDR
// InitHc ;
2948: CALL_OW 19
// for i = 1 to 4 do
2952: LD_ADDR_VAR 0 2
2956: PUSH
2957: DOUBLE
2958: LD_INT 1
2960: DEC
2961: ST_TO_ADDR
2962: LD_INT 4
2964: PUSH
2965: FOR_TO
2966: IFFALSE 3021
// begin hc_class = 18 ;
2968: LD_ADDR_OWVAR 28
2972: PUSH
2973: LD_INT 18
2975: ST_TO_ADDR
// hc_gallery =  ;
2976: LD_ADDR_OWVAR 33
2980: PUSH
2981: LD_STRING 
2983: ST_TO_ADDR
// hc_face_number = 1 ;
2984: LD_ADDR_OWVAR 34
2988: PUSH
2989: LD_INT 1
2991: ST_TO_ADDR
// animal := CreateHuman ;
2992: LD_ADDR_VAR 0 3
2996: PUSH
2997: CALL_OW 44
3001: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3002: LD_VAR 0 3
3006: PPUSH
3007: LD_VAR 0 4
3011: PPUSH
3012: LD_INT 0
3014: PPUSH
3015: CALL_OW 49
// end ;
3019: GO 2965
3021: POP
3022: POP
// for i = 1 to 6 do
3023: LD_ADDR_VAR 0 2
3027: PUSH
3028: DOUBLE
3029: LD_INT 1
3031: DEC
3032: ST_TO_ADDR
3033: LD_INT 6
3035: PUSH
3036: FOR_TO
3037: IFFALSE 3108
// begin hc_class = class_tiger ;
3039: LD_ADDR_OWVAR 28
3043: PUSH
3044: LD_INT 14
3046: ST_TO_ADDR
// hc_gallery =  ;
3047: LD_ADDR_OWVAR 33
3051: PUSH
3052: LD_STRING 
3054: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3055: LD_ADDR_OWVAR 35
3059: PUSH
3060: LD_INT 0
3062: PPUSH
3063: LD_INT 10
3065: PPUSH
3066: CALL_OW 12
3070: ST_TO_ADDR
// hc_face_number = 3 ;
3071: LD_ADDR_OWVAR 34
3075: PUSH
3076: LD_INT 3
3078: ST_TO_ADDR
// animal := CreateHuman ;
3079: LD_ADDR_VAR 0 3
3083: PUSH
3084: CALL_OW 44
3088: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3089: LD_VAR 0 3
3093: PPUSH
3094: LD_VAR 0 4
3098: PPUSH
3099: LD_INT 0
3101: PPUSH
3102: CALL_OW 49
// end ;
3106: GO 3036
3108: POP
3109: POP
// for i = 1 to 2 do
3110: LD_ADDR_VAR 0 2
3114: PUSH
3115: DOUBLE
3116: LD_INT 1
3118: DEC
3119: ST_TO_ADDR
3120: LD_INT 2
3122: PUSH
3123: FOR_TO
3124: IFFALSE 3187
// begin hc_class = 21 ;
3126: LD_ADDR_OWVAR 28
3130: PUSH
3131: LD_INT 21
3133: ST_TO_ADDR
// hc_gallery =  ;
3134: LD_ADDR_OWVAR 33
3138: PUSH
3139: LD_STRING 
3141: ST_TO_ADDR
// hc_agressivity = 0 ;
3142: LD_ADDR_OWVAR 35
3146: PUSH
3147: LD_INT 0
3149: ST_TO_ADDR
// hc_face_number = 5 ;
3150: LD_ADDR_OWVAR 34
3154: PUSH
3155: LD_INT 5
3157: ST_TO_ADDR
// animal := CreateHuman ;
3158: LD_ADDR_VAR 0 3
3162: PUSH
3163: CALL_OW 44
3167: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3168: LD_VAR 0 3
3172: PPUSH
3173: LD_VAR 0 4
3177: PPUSH
3178: LD_INT 0
3180: PPUSH
3181: CALL_OW 49
// end ;
3185: GO 3123
3187: POP
3188: POP
// for i = 1 to 6 do
3189: LD_ADDR_VAR 0 2
3193: PUSH
3194: DOUBLE
3195: LD_INT 1
3197: DEC
3198: ST_TO_ADDR
3199: LD_INT 6
3201: PUSH
3202: FOR_TO
3203: IFFALSE 3258
// begin hc_class = 13 ;
3205: LD_ADDR_OWVAR 28
3209: PUSH
3210: LD_INT 13
3212: ST_TO_ADDR
// hc_gallery =  ;
3213: LD_ADDR_OWVAR 33
3217: PUSH
3218: LD_STRING 
3220: ST_TO_ADDR
// hc_face_number = 4 ;
3221: LD_ADDR_OWVAR 34
3225: PUSH
3226: LD_INT 4
3228: ST_TO_ADDR
// animal := CreateHuman ;
3229: LD_ADDR_VAR 0 3
3233: PUSH
3234: CALL_OW 44
3238: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3239: LD_VAR 0 3
3243: PPUSH
3244: LD_VAR 0 4
3248: PPUSH
3249: LD_INT 0
3251: PPUSH
3252: CALL_OW 49
// end ;
3256: GO 3202
3258: POP
3259: POP
// for i = 1 to 2 do
3260: LD_ADDR_VAR 0 2
3264: PUSH
3265: DOUBLE
3266: LD_INT 1
3268: DEC
3269: ST_TO_ADDR
3270: LD_INT 2
3272: PUSH
3273: FOR_TO
3274: IFFALSE 3333
// begin hc_class = 20 ;
3276: LD_ADDR_OWVAR 28
3280: PUSH
3281: LD_INT 20
3283: ST_TO_ADDR
// hc_gallery =  ;
3284: LD_ADDR_OWVAR 33
3288: PUSH
3289: LD_STRING 
3291: ST_TO_ADDR
// hc_face_number = 2 ;
3292: LD_ADDR_OWVAR 34
3296: PUSH
3297: LD_INT 2
3299: ST_TO_ADDR
// animal := CreateHuman ;
3300: LD_ADDR_VAR 0 3
3304: PUSH
3305: CALL_OW 44
3309: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3310: LD_VAR 0 3
3314: PPUSH
3315: LD_INT 101
3317: PPUSH
3318: LD_INT 37
3320: PPUSH
3321: LD_INT 3
3323: PPUSH
3324: LD_INT 0
3326: PPUSH
3327: CALL_OW 50
// end ;
3331: GO 3273
3333: POP
3334: POP
// for i = 1 to 1 do
3335: LD_ADDR_VAR 0 2
3339: PUSH
3340: DOUBLE
3341: LD_INT 1
3343: DEC
3344: ST_TO_ADDR
3345: LD_INT 1
3347: PUSH
3348: FOR_TO
3349: IFFALSE 3396
// begin vc_chassis := 31 ;
3351: LD_ADDR_OWVAR 37
3355: PUSH
3356: LD_INT 31
3358: ST_TO_ADDR
// vc_control := control_rider ;
3359: LD_ADDR_OWVAR 38
3363: PUSH
3364: LD_INT 4
3366: ST_TO_ADDR
// animal := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_VAR 0 4
3386: PPUSH
3387: LD_INT 0
3389: PPUSH
3390: CALL_OW 49
// end ;
3394: GO 3348
3396: POP
3397: POP
// end ;
3398: LD_VAR 0 1
3402: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3403: LD_INT 0
3405: PPUSH
3406: PPUSH
3407: PPUSH
3408: PPUSH
// result := [ ] ;
3409: LD_ADDR_VAR 0 2
3413: PUSH
3414: EMPTY
3415: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3416: LD_ADDR_VAR 0 4
3420: PUSH
3421: LD_INT 81
3423: PUSH
3424: LD_VAR 0 1
3428: PPUSH
3429: CALL_OW 255
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 91
3440: PUSH
3441: LD_VAR 0 1
3445: PUSH
3446: LD_INT 15
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: LIST
3453: PUSH
3454: LD_INT 2
3456: PUSH
3457: LD_INT 30
3459: PUSH
3460: LD_INT 32
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: PUSH
3467: LD_INT 30
3469: PUSH
3470: LD_INT 33
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: LIST
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: PPUSH
3487: CALL_OW 69
3491: ST_TO_ADDR
// if not tmp then
3492: LD_VAR 0 4
3496: NOT
3497: IFFALSE 3501
// exit ;
3499: GO 3570
// for i in tmp do
3501: LD_ADDR_VAR 0 3
3505: PUSH
3506: LD_VAR 0 4
3510: PUSH
3511: FOR_IN
3512: IFFALSE 3568
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3514: LD_ADDR_VAR 0 5
3518: PUSH
3519: LD_VAR 0 3
3523: PPUSH
3524: CALL_OW 274
3528: PPUSH
3529: CALL_OW 278
3533: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3534: LD_VAR 0 5
3538: PUSH
3539: LD_INT 4
3541: ARRAY
3542: PUSH
3543: LD_VAR 0 5
3547: PUSH
3548: LD_INT 1
3550: ARRAY
3551: GREATER
3552: IFFALSE 3566
// begin result := i ;
3554: LD_ADDR_VAR 0 2
3558: PUSH
3559: LD_VAR 0 3
3563: ST_TO_ADDR
// break ;
3564: GO 3568
// end ; end ;
3566: GO 3511
3568: POP
3569: POP
// end ; end_of_file
3570: LD_VAR 0 2
3574: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3575: LD_INT 0
3577: PPUSH
3578: PPUSH
3579: PPUSH
3580: PPUSH
3581: PPUSH
3582: PPUSH
// uc_side := 1 ;
3583: LD_ADDR_OWVAR 20
3587: PUSH
3588: LD_INT 1
3590: ST_TO_ADDR
// uc_nation := 1 ;
3591: LD_ADDR_OWVAR 21
3595: PUSH
3596: LD_INT 1
3598: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3599: LD_ADDR_EXP 8
3603: PUSH
3604: LD_STRING JMM
3606: PPUSH
3607: LD_EXP 1
3611: NOT
3612: PPUSH
3613: CALL 355 0 2
3617: ST_TO_ADDR
// team := [ JMM ] ;
3618: LD_ADDR_VAR 0 3
3622: PUSH
3623: LD_EXP 8
3627: PUSH
3628: EMPTY
3629: LIST
3630: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3631: LD_STRING BrownIn07
3633: PPUSH
3634: LD_EXP 1
3638: PPUSH
3639: CALL_OW 30
3643: IFFALSE 3664
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3645: LD_ADDR_EXP 9
3649: PUSH
3650: LD_STRING Brown
3652: PPUSH
3653: LD_EXP 1
3657: NOT
3658: PPUSH
3659: CALL 355 0 2
3663: ST_TO_ADDR
// if Brown then
3664: LD_EXP 9
3668: IFFALSE 3686
// team := team ^ Brown ;
3670: LD_ADDR_VAR 0 3
3674: PUSH
3675: LD_VAR 0 3
3679: PUSH
3680: LD_EXP 9
3684: ADD
3685: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3686: LD_STRING DonaldsonIn07
3688: PPUSH
3689: LD_EXP 1
3693: PPUSH
3694: CALL_OW 30
3698: IFFALSE 3719
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3700: LD_ADDR_EXP 10
3704: PUSH
3705: LD_STRING Donaldson
3707: PPUSH
3708: LD_EXP 1
3712: NOT
3713: PPUSH
3714: CALL 355 0 2
3718: ST_TO_ADDR
// if Donaldson then
3719: LD_EXP 10
3723: IFFALSE 3741
// team := team ^ Donaldson ;
3725: LD_ADDR_VAR 0 3
3729: PUSH
3730: LD_VAR 0 3
3734: PUSH
3735: LD_EXP 10
3739: ADD
3740: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3741: LD_STRING BobbyIn07
3743: PPUSH
3744: LD_EXP 1
3748: PPUSH
3749: CALL_OW 30
3753: IFFALSE 3774
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3755: LD_ADDR_EXP 11
3759: PUSH
3760: LD_STRING Bobby
3762: PPUSH
3763: LD_EXP 1
3767: NOT
3768: PPUSH
3769: CALL 355 0 2
3773: ST_TO_ADDR
// if Bobby then
3774: LD_EXP 11
3778: IFFALSE 3796
// team := team ^ Bobby ;
3780: LD_ADDR_VAR 0 3
3784: PUSH
3785: LD_VAR 0 3
3789: PUSH
3790: LD_EXP 11
3794: ADD
3795: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3796: LD_STRING CyrusIn07
3798: PPUSH
3799: LD_EXP 1
3803: PPUSH
3804: CALL_OW 30
3808: IFFALSE 3829
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3810: LD_ADDR_EXP 12
3814: PUSH
3815: LD_STRING Cyrus
3817: PPUSH
3818: LD_EXP 1
3822: NOT
3823: PPUSH
3824: CALL 355 0 2
3828: ST_TO_ADDR
// if Cyrus then
3829: LD_EXP 12
3833: IFFALSE 3851
// team := team ^ Cyrus ;
3835: LD_ADDR_VAR 0 3
3839: PUSH
3840: LD_VAR 0 3
3844: PUSH
3845: LD_EXP 12
3849: ADD
3850: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3851: LD_STRING LisaIn07
3853: PPUSH
3854: LD_EXP 1
3858: PPUSH
3859: CALL_OW 30
3863: IFFALSE 3884
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3865: LD_ADDR_EXP 13
3869: PUSH
3870: LD_STRING Lisa
3872: PPUSH
3873: LD_EXP 1
3877: NOT
3878: PPUSH
3879: CALL 355 0 2
3883: ST_TO_ADDR
// if Lisa then
3884: LD_EXP 13
3888: IFFALSE 3906
// team := team ^ Lisa ;
3890: LD_ADDR_VAR 0 3
3894: PUSH
3895: LD_VAR 0 3
3899: PUSH
3900: LD_EXP 13
3904: ADD
3905: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3906: LD_STRING GladstoneIn07
3908: PPUSH
3909: LD_EXP 1
3913: PPUSH
3914: CALL_OW 30
3918: IFFALSE 3939
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3920: LD_ADDR_EXP 15
3924: PUSH
3925: LD_STRING Gladstone
3927: PPUSH
3928: LD_EXP 1
3932: NOT
3933: PPUSH
3934: CALL 355 0 2
3938: ST_TO_ADDR
// if Gladstone then
3939: LD_EXP 15
3943: IFFALSE 3961
// team := team ^ Gladstone ;
3945: LD_ADDR_VAR 0 3
3949: PUSH
3950: LD_VAR 0 3
3954: PUSH
3955: LD_EXP 15
3959: ADD
3960: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3961: LD_STRING KhatamIn07
3963: PPUSH
3964: LD_EXP 1
3968: PPUSH
3969: CALL_OW 30
3973: IFFALSE 3994
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3975: LD_ADDR_EXP 16
3979: PUSH
3980: LD_STRING Khatam
3982: PPUSH
3983: LD_EXP 1
3987: NOT
3988: PPUSH
3989: CALL 355 0 2
3993: ST_TO_ADDR
// if Khatam then
3994: LD_EXP 16
3998: IFFALSE 4016
// team := team ^ Khatam ;
4000: LD_ADDR_VAR 0 3
4004: PUSH
4005: LD_VAR 0 3
4009: PUSH
4010: LD_EXP 16
4014: ADD
4015: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4016: LD_ADDR_VAR 0 4
4020: PUSH
4021: LD_STRING 07_others
4023: PPUSH
4024: CALL_OW 31
4028: ST_TO_ADDR
// if others then
4029: LD_VAR 0 4
4033: IFFALSE 4051
// team := team ^ others ;
4035: LD_ADDR_VAR 0 3
4039: PUSH
4040: LD_VAR 0 3
4044: PUSH
4045: LD_VAR 0 4
4049: ADD
4050: ST_TO_ADDR
// if debug then
4051: LD_EXP 1
4055: IFFALSE 4129
// begin InitHc ;
4057: CALL_OW 19
// for i = 1 to 4 do
4061: LD_ADDR_VAR 0 2
4065: PUSH
4066: DOUBLE
4067: LD_INT 1
4069: DEC
4070: ST_TO_ADDR
4071: LD_INT 4
4073: PUSH
4074: FOR_TO
4075: IFFALSE 4127
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4077: LD_INT 0
4079: PPUSH
4080: LD_INT 1
4082: PUSH
4083: LD_INT 3
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: LD_INT 1
4092: PPUSH
4093: LD_INT 2
4095: PPUSH
4096: CALL_OW 12
4100: ARRAY
4101: PPUSH
4102: LD_INT 4
4104: PPUSH
4105: CALL_OW 380
// team := team ^ CreateHuman ;
4109: LD_ADDR_VAR 0 3
4113: PUSH
4114: LD_VAR 0 3
4118: PUSH
4119: CALL_OW 44
4123: ADD
4124: ST_TO_ADDR
// end ;
4125: GO 4074
4127: POP
4128: POP
// end ; m := 0 ;
4129: LD_ADDR_VAR 0 6
4133: PUSH
4134: LD_INT 0
4136: ST_TO_ADDR
// for i in team do
4137: LD_ADDR_VAR 0 2
4141: PUSH
4142: LD_VAR 0 3
4146: PUSH
4147: FOR_IN
4148: IFFALSE 4328
// if GetClass ( i ) = 3 then
4150: LD_VAR 0 2
4154: PPUSH
4155: CALL_OW 257
4159: PUSH
4160: LD_INT 3
4162: EQUAL
4163: IFFALSE 4311
// begin m := m + 1 ;
4165: LD_ADDR_VAR 0 6
4169: PUSH
4170: LD_VAR 0 6
4174: PUSH
4175: LD_INT 1
4177: PLUS
4178: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4179: LD_ADDR_VAR 0 5
4183: PUSH
4184: LD_INT 1
4186: PPUSH
4187: LD_INT 1
4189: PPUSH
4190: LD_INT 2
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 2
4198: PUSH
4199: LD_INT 1
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: LIST
4206: LIST
4207: PUSH
4208: LD_VAR 0 6
4212: PUSH
4213: LD_INT 4
4215: MOD
4216: PUSH
4217: LD_INT 1
4219: PLUS
4220: ARRAY
4221: PPUSH
4222: LD_INT 2
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 4
4230: PUSH
4231: LD_INT 5
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: LD_INT 11
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: LD_VAR 0 6
4250: PUSH
4251: LD_INT 4
4253: MOD
4254: PUSH
4255: LD_INT 1
4257: PLUS
4258: ARRAY
4259: PPUSH
4260: LD_INT 60
4262: PPUSH
4263: CALL 418 0 7
4267: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4268: LD_VAR 0 5
4272: PPUSH
4273: LD_INT 2
4275: PPUSH
4276: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4280: LD_VAR 0 5
4284: PPUSH
4285: LD_INT 1
4287: PPUSH
4288: LD_INT 0
4290: PPUSH
4291: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4295: LD_VAR 0 2
4299: PPUSH
4300: LD_VAR 0 5
4304: PPUSH
4305: CALL_OW 52
// end else
4309: GO 4326
// PlaceUnitArea ( i , startArea , false ) ;
4311: LD_VAR 0 2
4315: PPUSH
4316: LD_INT 1
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 49
4326: GO 4147
4328: POP
4329: POP
// uc_side := 4 ;
4330: LD_ADDR_OWVAR 20
4334: PUSH
4335: LD_INT 4
4337: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4338: LD_ADDR_EXP 18
4342: PUSH
4343: LD_STRING Harisson
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 355 0 2
4353: ST_TO_ADDR
// PrepareScout ;
4354: CALL 4363 0 0
// end ;
4358: LD_VAR 0 1
4362: RET
// function PrepareScout ; var ape ; begin
4363: LD_INT 0
4365: PPUSH
4366: PPUSH
// uc_side := 4 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 4
4374: ST_TO_ADDR
// uc_nation := 1 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 1
4382: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4383: LD_STRING FrankIn06
4385: PPUSH
4386: LD_INT 0
4388: PPUSH
4389: CALL_OW 30
4393: IFFALSE 4410
// Frank := CreateCharacter ( 06c_Frank ) else
4395: LD_ADDR_EXP 14
4399: PUSH
4400: LD_STRING 06c_Frank
4402: PPUSH
4403: CALL_OW 34
4407: ST_TO_ADDR
4408: GO 4450
// if LoadVariable ( FrankInDelta , 0 ) then
4410: LD_STRING FrankInDelta
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 30
4420: IFFALSE 4437
// Frank := CreateCharacter ( 05_Frank ) else
4422: LD_ADDR_EXP 14
4426: PUSH
4427: LD_STRING 05_Frank
4429: PPUSH
4430: CALL_OW 34
4434: ST_TO_ADDR
4435: GO 4450
// Frank := CreateCharacter ( 04_Frank ) ;
4437: LD_ADDR_EXP 14
4441: PUSH
4442: LD_STRING 04_Frank
4444: PPUSH
4445: CALL_OW 34
4449: ST_TO_ADDR
// if Frank then
4450: LD_EXP 14
4454: IFFALSE 4587
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4456: LD_EXP 14
4460: PPUSH
4461: LD_INT 2
4463: PPUSH
4464: LD_INT 0
4466: PPUSH
4467: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4471: LD_EXP 14
4475: PPUSH
4476: LD_INT 1
4478: PPUSH
4479: CALL_OW 336
// uc_side := 0 ;
4483: LD_ADDR_OWVAR 20
4487: PUSH
4488: LD_INT 0
4490: ST_TO_ADDR
// uc_nation := 0 ;
4491: LD_ADDR_OWVAR 21
4495: PUSH
4496: LD_INT 0
4498: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4499: LD_INT 0
4501: PPUSH
4502: LD_INT 12
4504: PPUSH
4505: LD_INT 0
4507: PPUSH
4508: CALL_OW 380
// ape := CreateHuman ;
4512: LD_ADDR_VAR 0 2
4516: PUSH
4517: CALL_OW 44
4521: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4522: LD_VAR 0 2
4526: PPUSH
4527: LD_EXP 14
4531: PPUSH
4532: CALL_OW 250
4536: PPUSH
4537: LD_EXP 14
4541: PPUSH
4542: CALL_OW 251
4546: PPUSH
4547: LD_INT 5
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4557: LD_VAR 0 2
4561: PPUSH
4562: LD_EXP 14
4566: PPUSH
4567: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4571: LD_EXP 14
4575: PPUSH
4576: LD_VAR 0 2
4580: PPUSH
4581: CALL_OW 119
// exit ;
4585: GO 4627
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4587: LD_ADDR_EXP 17
4591: PUSH
4592: LD_STRING Yamoko
4594: PPUSH
4595: LD_INT 0
4597: PPUSH
4598: CALL 355 0 2
4602: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4603: LD_EXP 17
4607: PPUSH
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 0
4613: PPUSH
4614: CALL_OW 49
// ComHold ( Kikuchi ) ;
4618: LD_EXP 17
4622: PPUSH
4623: CALL_OW 140
// end ; end_of_file
4627: LD_VAR 0 1
4631: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4632: LD_INT 0
4634: PPUSH
4635: PPUSH
4636: PPUSH
4637: PPUSH
4638: PPUSH
4639: PPUSH
4640: PPUSH
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
4647: PPUSH
4648: PPUSH
4649: PPUSH
// ru_rebuild_list := [ ] ;
4650: LD_ADDR_EXP 19
4654: PUSH
4655: EMPTY
4656: ST_TO_ADDR
// uc_side := 3 ;
4657: LD_ADDR_OWVAR 20
4661: PUSH
4662: LD_INT 3
4664: ST_TO_ADDR
// uc_nation := 3 ;
4665: LD_ADDR_OWVAR 21
4669: PUSH
4670: LD_INT 3
4672: ST_TO_ADDR
// if Difficulty > 1 then
4673: LD_OWVAR 67
4677: PUSH
4678: LD_INT 1
4680: GREATER
4681: IFFALSE 4817
// begin bc_type := b_breastwork ;
4683: LD_ADDR_OWVAR 42
4687: PUSH
4688: LD_INT 31
4690: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4691: LD_INT 78
4693: PPUSH
4694: LD_INT 74
4696: PPUSH
4697: LD_INT 2
4699: PPUSH
4700: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4704: LD_INT 171
4706: PPUSH
4707: LD_INT 193
4709: PPUSH
4710: LD_INT 4
4712: PPUSH
4713: CALL_OW 47
// bc_type := b_turret ;
4717: LD_ADDR_OWVAR 42
4721: PUSH
4722: LD_INT 33
4724: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4725: LD_INT 129
4727: PPUSH
4728: LD_INT 96
4730: PPUSH
4731: LD_INT 3
4733: PPUSH
4734: CALL_OW 47
// if Difficulty > 2 then
4738: LD_OWVAR 67
4742: PUSH
4743: LD_INT 2
4745: GREATER
4746: IFFALSE 4817
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4748: LD_INT 83
4750: PPUSH
4751: LD_INT 141
4753: PPUSH
4754: CALL_OW 428
4758: PPUSH
4759: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4763: LD_INT 78
4765: PPUSH
4766: LD_INT 133
4768: PPUSH
4769: CALL_OW 428
4773: PPUSH
4774: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4778: LD_INT 83
4780: PPUSH
4781: LD_INT 141
4783: PPUSH
4784: LD_INT 2
4786: PPUSH
4787: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4791: LD_INT 78
4793: PPUSH
4794: LD_INT 133
4796: PPUSH
4797: LD_INT 2
4799: PPUSH
4800: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4804: LD_INT 145
4806: PPUSH
4807: LD_INT 112
4809: PPUSH
4810: LD_INT 3
4812: PPUSH
4813: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4817: LD_ADDR_VAR 0 9
4821: PUSH
4822: LD_INT 22
4824: PUSH
4825: LD_INT 3
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PUSH
4832: LD_INT 2
4834: PUSH
4835: LD_INT 30
4837: PUSH
4838: LD_INT 0
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: LD_INT 30
4847: PUSH
4848: LD_INT 1
4850: PUSH
4851: EMPTY
4852: LIST
4853: LIST
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: LIST
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PPUSH
4864: CALL_OW 69
4868: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4869: LD_ADDR_VAR 0 10
4873: PUSH
4874: LD_INT 22
4876: PUSH
4877: LD_INT 3
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 2
4886: PUSH
4887: LD_INT 30
4889: PUSH
4890: LD_INT 6
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: PUSH
4897: LD_INT 30
4899: PUSH
4900: LD_INT 7
4902: PUSH
4903: EMPTY
4904: LIST
4905: LIST
4906: PUSH
4907: LD_INT 30
4909: PUSH
4910: LD_INT 8
4912: PUSH
4913: EMPTY
4914: LIST
4915: LIST
4916: PUSH
4917: EMPTY
4918: LIST
4919: LIST
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PPUSH
4927: CALL_OW 69
4931: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4932: LD_ADDR_VAR 0 11
4936: PUSH
4937: LD_INT 22
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 30
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PPUSH
4961: CALL_OW 69
4965: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4966: LD_ADDR_VAR 0 12
4970: PUSH
4971: LD_INT 22
4973: PUSH
4974: LD_INT 3
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: PUSH
4981: LD_INT 30
4983: PUSH
4984: LD_INT 31
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: EMPTY
4992: LIST
4993: LIST
4994: PPUSH
4995: CALL_OW 69
4999: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5000: LD_ADDR_VAR 0 13
5004: PUSH
5005: LD_INT 22
5007: PUSH
5008: LD_INT 3
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: LD_INT 30
5017: PUSH
5018: LD_INT 32
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PPUSH
5029: CALL_OW 69
5033: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5034: LD_ADDR_VAR 0 14
5038: PUSH
5039: LD_INT 22
5041: PUSH
5042: LD_INT 3
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: PUSH
5049: LD_INT 30
5051: PUSH
5052: LD_INT 33
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5068: LD_ADDR_VAR 0 15
5072: PUSH
5073: LD_INT 42
5075: PUSH
5076: LD_INT 5
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PUSH
5083: LD_INT 43
5085: PUSH
5086: LD_INT 50
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: PUSH
5093: LD_INT 44
5095: PUSH
5096: LD_INT 30
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 46
5105: PUSH
5106: LD_INT 15
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5119: LD_ADDR_VAR 0 16
5123: PUSH
5124: LD_INT 0
5126: PUSH
5127: LD_INT 4
5129: PUSH
5130: LD_INT 6
5132: PUSH
5133: LD_INT 3
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: LIST
5140: LIST
5141: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_INT 4
5149: PUSH
5150: LD_INT 5
5152: PUSH
5153: LD_INT 6
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: LIST
5160: PUSH
5161: LD_OWVAR 67
5165: ARRAY
5166: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5167: LD_INT 16
5169: PPUSH
5170: LD_STRING am_tukh
5172: PPUSH
5173: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5177: LD_ADDR_VAR 0 2
5181: PUSH
5182: LD_INT 21
5184: PUSH
5185: LD_INT 3
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: PPUSH
5192: CALL_OW 69
5196: PUSH
5197: FOR_IN
5198: IFFALSE 5231
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5200: LD_VAR 0 2
5204: PPUSH
5205: LD_INT 4
5207: PUSH
5208: LD_INT 5
5210: PUSH
5211: LD_INT 6
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: LIST
5218: PUSH
5219: LD_OWVAR 67
5223: ARRAY
5224: PPUSH
5225: CALL_OW 241
5229: GO 5197
5231: POP
5232: POP
// for i in dep_list do
5233: LD_ADDR_VAR 0 2
5237: PUSH
5238: LD_VAR 0 9
5242: PUSH
5243: FOR_IN
5244: IFFALSE 5288
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5246: LD_VAR 0 2
5250: PPUSH
5251: CALL_OW 274
5255: PPUSH
5256: LD_INT 1
5258: PPUSH
5259: LD_INT 1000
5261: PPUSH
5262: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5266: LD_VAR 0 2
5270: PPUSH
5271: CALL_OW 274
5275: PPUSH
5276: LD_INT 2
5278: PPUSH
5279: LD_INT 1000
5281: PPUSH
5282: CALL_OW 277
// end ;
5286: GO 5243
5288: POP
5289: POP
// InitHc ;
5290: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5294: LD_ADDR_VAR 0 8
5298: PUSH
5299: LD_VAR 0 13
5303: PUSH
5304: LD_INT 45
5306: PUSH
5307: LD_INT 60
5309: PUSH
5310: LD_INT 75
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: LIST
5317: PUSH
5318: LD_OWVAR 67
5322: ARRAY
5323: MUL
5324: PUSH
5325: LD_INT 100
5327: DIV
5328: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5329: LD_ADDR_VAR 0 16
5333: PUSH
5334: LD_VAR 0 16
5338: PPUSH
5339: LD_INT 1
5341: PPUSH
5342: LD_VAR 0 8
5346: PPUSH
5347: CALL_OW 1
5351: ST_TO_ADDR
// tmp := [ ] ;
5352: LD_ADDR_VAR 0 8
5356: PUSH
5357: EMPTY
5358: ST_TO_ADDR
// for i in bunker_list do
5359: LD_ADDR_VAR 0 2
5363: PUSH
5364: LD_VAR 0 13
5368: PUSH
5369: FOR_IN
5370: IFFALSE 5466
// if i mod 10 + 1 < tmp then
5372: LD_VAR 0 2
5376: PUSH
5377: LD_INT 10
5379: MOD
5380: PUSH
5381: LD_INT 1
5383: PLUS
5384: PUSH
5385: LD_VAR 0 8
5389: LESS
5390: IFFALSE 5435
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5392: LD_ADDR_VAR 0 8
5396: PUSH
5397: LD_VAR 0 8
5401: PPUSH
5402: LD_VAR 0 2
5406: PUSH
5407: LD_INT 3
5409: PPUSH
5410: LD_INT 5
5412: PPUSH
5413: CALL_OW 12
5417: MOD
5418: PUSH
5419: LD_INT 1
5421: PLUS
5422: PPUSH
5423: LD_VAR 0 2
5427: PPUSH
5428: CALL_OW 2
5432: ST_TO_ADDR
5433: GO 5464
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5435: LD_ADDR_VAR 0 8
5439: PUSH
5440: LD_VAR 0 8
5444: PPUSH
5445: LD_VAR 0 8
5449: PUSH
5450: LD_INT 1
5452: PLUS
5453: PPUSH
5454: LD_VAR 0 2
5458: PPUSH
5459: CALL_OW 2
5463: ST_TO_ADDR
5464: GO 5369
5466: POP
5467: POP
// bunker_list := tmp ;
5468: LD_ADDR_VAR 0 13
5472: PUSH
5473: LD_VAR 0 8
5477: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5478: LD_ADDR_VAR 0 2
5482: PUSH
5483: LD_VAR 0 13
5487: PUSH
5488: LD_VAR 0 14
5492: ADD
5493: PUSH
5494: FOR_IN
5495: IFFALSE 5518
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5497: LD_VAR 0 2
5501: PPUSH
5502: LD_VAR 0 2
5506: PPUSH
5507: CALL 832 0 1
5511: PPUSH
5512: CALL_OW 431
5516: GO 5494
5518: POP
5519: POP
// while ( personel_counter [ 1 ] ) do
5520: LD_VAR 0 16
5524: PUSH
5525: LD_INT 1
5527: ARRAY
5528: IFFALSE 5636
// begin i := rand ( 1 , bunker_list ) ;
5530: LD_ADDR_VAR 0 2
5534: PUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_VAR 0 13
5542: PPUSH
5543: CALL_OW 12
5547: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5548: LD_INT 0
5550: PPUSH
5551: LD_INT 1
5553: PPUSH
5554: LD_VAR 0 6
5558: PPUSH
5559: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5563: CALL_OW 44
5567: PPUSH
5568: LD_VAR 0 13
5572: PUSH
5573: LD_VAR 0 2
5577: ARRAY
5578: PPUSH
5579: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5583: LD_ADDR_VAR 0 13
5587: PUSH
5588: LD_VAR 0 13
5592: PPUSH
5593: LD_VAR 0 2
5597: PPUSH
5598: CALL_OW 3
5602: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5603: LD_ADDR_VAR 0 16
5607: PUSH
5608: LD_VAR 0 16
5612: PPUSH
5613: LD_INT 1
5615: PPUSH
5616: LD_VAR 0 16
5620: PUSH
5621: LD_INT 1
5623: ARRAY
5624: PUSH
5625: LD_INT 1
5627: MINUS
5628: PPUSH
5629: CALL_OW 1
5633: ST_TO_ADDR
// end ;
5634: GO 5520
// for i = 1 to personel_counter [ 2 ] do
5636: LD_ADDR_VAR 0 2
5640: PUSH
5641: DOUBLE
5642: LD_INT 1
5644: DEC
5645: ST_TO_ADDR
5646: LD_VAR 0 16
5650: PUSH
5651: LD_INT 2
5653: ARRAY
5654: PUSH
5655: FOR_TO
5656: IFFALSE 5687
// begin PrepareHuman ( false , 2 , skill ) ;
5658: LD_INT 0
5660: PPUSH
5661: LD_INT 2
5663: PPUSH
5664: LD_VAR 0 6
5668: PPUSH
5669: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5673: CALL_OW 44
5677: PPUSH
5678: LD_INT 16
5680: PPUSH
5681: CALL_OW 52
// end ;
5685: GO 5655
5687: POP
5688: POP
// for i = 1 to personel_counter [ 3 ] do
5689: LD_ADDR_VAR 0 2
5693: PUSH
5694: DOUBLE
5695: LD_INT 1
5697: DEC
5698: ST_TO_ADDR
5699: LD_VAR 0 16
5703: PUSH
5704: LD_INT 3
5706: ARRAY
5707: PUSH
5708: FOR_TO
5709: IFFALSE 5756
// begin PrepareHuman ( false , 3 , skill ) ;
5711: LD_INT 0
5713: PPUSH
5714: LD_INT 3
5716: PPUSH
5717: LD_VAR 0 6
5721: PPUSH
5722: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5726: CALL_OW 44
5730: PPUSH
5731: LD_VAR 0 11
5735: PUSH
5736: LD_VAR 0 2
5740: PUSH
5741: LD_INT 2
5743: MOD
5744: PUSH
5745: LD_INT 1
5747: PLUS
5748: ARRAY
5749: PPUSH
5750: CALL_OW 52
// end ;
5754: GO 5708
5756: POP
5757: POP
// for i = 1 to personel_counter [ 4 ] do
5758: LD_ADDR_VAR 0 2
5762: PUSH
5763: DOUBLE
5764: LD_INT 1
5766: DEC
5767: ST_TO_ADDR
5768: LD_VAR 0 16
5772: PUSH
5773: LD_INT 4
5775: ARRAY
5776: PUSH
5777: FOR_TO
5778: IFFALSE 5815
// begin PrepareHuman ( false , 4 , skill ) ;
5780: LD_INT 0
5782: PPUSH
5783: LD_INT 4
5785: PPUSH
5786: LD_VAR 0 6
5790: PPUSH
5791: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5795: CALL_OW 44
5799: PPUSH
5800: LD_VAR 0 10
5804: PUSH
5805: LD_INT 1
5807: ARRAY
5808: PPUSH
5809: CALL_OW 52
// end ;
5813: GO 5777
5815: POP
5816: POP
// for i in breastworks_list do
5817: LD_ADDR_VAR 0 2
5821: PUSH
5822: LD_VAR 0 12
5826: PUSH
5827: FOR_IN
5828: IFFALSE 5940
// begin r := GetDir ( i ) ;
5830: LD_ADDR_VAR 0 4
5834: PUSH
5835: LD_VAR 0 2
5839: PPUSH
5840: CALL_OW 254
5844: ST_TO_ADDR
// if r > 3 then
5845: LD_VAR 0 4
5849: PUSH
5850: LD_INT 3
5852: GREATER
5853: IFFALSE 5871
// r := r - 3 else
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_VAR 0 4
5864: PUSH
5865: LD_INT 3
5867: MINUS
5868: ST_TO_ADDR
5869: GO 5885
// r := r + 3 ;
5871: LD_ADDR_VAR 0 4
5875: PUSH
5876: LD_VAR 0 4
5880: PUSH
5881: LD_INT 3
5883: PLUS
5884: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5885: LD_INT 0
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: LD_VAR 0 6
5895: PPUSH
5896: CALL_OW 380
// un := CreateHuman ;
5900: LD_ADDR_VAR 0 5
5904: PUSH
5905: CALL_OW 44
5909: ST_TO_ADDR
// SetDir ( un , r ) ;
5910: LD_VAR 0 5
5914: PPUSH
5915: LD_VAR 0 4
5919: PPUSH
5920: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5924: LD_VAR 0 5
5928: PPUSH
5929: LD_VAR 0 2
5933: PPUSH
5934: CALL_OW 52
// end ;
5938: GO 5827
5940: POP
5941: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5942: LD_ADDR_VAR 0 8
5946: PUSH
5947: LD_INT 22
5949: PUSH
5950: LD_INT 3
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 25
5959: PUSH
5960: LD_INT 3
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: PPUSH
5971: CALL_OW 69
5975: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
5976: LD_ADDR_VAR 0 4
5980: PUSH
5981: LD_INT 4
5983: PUSH
5984: LD_INT 5
5986: PUSH
5987: LD_INT 6
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_OWVAR 67
5999: ARRAY
6000: ST_TO_ADDR
// for i = 1 to r do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: DOUBLE
6007: LD_INT 1
6009: DEC
6010: ST_TO_ADDR
6011: LD_VAR 0 4
6015: PUSH
6016: FOR_TO
6017: IFFALSE 6190
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6019: LD_ADDR_VAR 0 5
6023: PUSH
6024: LD_INT 3
6026: PPUSH
6027: LD_INT 3
6029: PPUSH
6030: LD_INT 22
6032: PUSH
6033: LD_INT 22
6035: PUSH
6036: LD_INT 24
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: LIST
6043: PUSH
6044: LD_VAR 0 2
6048: PUSH
6049: LD_INT 3
6051: MOD
6052: PUSH
6053: LD_INT 1
6055: PLUS
6056: ARRAY
6057: PPUSH
6058: LD_INT 1
6060: PPUSH
6061: LD_INT 1
6063: PPUSH
6064: LD_INT 43
6066: PUSH
6067: LD_INT 44
6069: PUSH
6070: LD_INT 42
6072: PUSH
6073: EMPTY
6074: LIST
6075: LIST
6076: LIST
6077: PUSH
6078: LD_VAR 0 2
6082: PUSH
6083: LD_INT 3
6085: MOD
6086: PUSH
6087: LD_INT 1
6089: PLUS
6090: ARRAY
6091: PPUSH
6092: LD_INT 100
6094: PPUSH
6095: CALL 418 0 7
6099: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6100: LD_VAR 0 5
6104: PPUSH
6105: LD_INT 0
6107: PPUSH
6108: LD_INT 5
6110: PPUSH
6111: CALL_OW 12
6115: PPUSH
6116: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6120: LD_VAR 0 5
6124: PPUSH
6125: LD_INT 5
6127: PPUSH
6128: LD_INT 0
6130: PPUSH
6131: CALL_OW 49
// if i > tmp - 2 then
6135: LD_VAR 0 2
6139: PUSH
6140: LD_VAR 0 8
6144: PUSH
6145: LD_INT 2
6147: MINUS
6148: GREATER
6149: IFFALSE 6153
// continue ;
6151: GO 6016
// ComExitBuilding ( tmp [ i ] ) ;
6153: LD_VAR 0 8
6157: PUSH
6158: LD_VAR 0 2
6162: ARRAY
6163: PPUSH
6164: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6168: LD_VAR 0 8
6172: PUSH
6173: LD_VAR 0 2
6177: ARRAY
6178: PPUSH
6179: LD_VAR 0 5
6183: PPUSH
6184: CALL_OW 180
// end ;
6188: GO 6016
6190: POP
6191: POP
// end ;
6192: LD_VAR 0 1
6196: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6197: LD_INT 22
6199: PUSH
6200: LD_INT 3
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: PUSH
6207: LD_INT 25
6209: PUSH
6210: LD_INT 2
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PPUSH
6221: CALL_OW 69
6225: IFFALSE 6957
6227: GO 6229
6229: DISABLE
6230: LD_INT 0
6232: PPUSH
6233: PPUSH
6234: PPUSH
6235: PPUSH
6236: PPUSH
// begin enable ;
6237: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6238: LD_ADDR_VAR 0 2
6242: PUSH
6243: LD_INT 6
6245: PPUSH
6246: LD_INT 3
6248: PUSH
6249: LD_INT 24
6251: PUSH
6252: LD_INT 1000
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 21
6265: PUSH
6266: LD_INT 3
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL_OW 70
6281: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6282: LD_ADDR_VAR 0 4
6286: PUSH
6287: LD_INT 22
6289: PUSH
6290: LD_INT 3
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 25
6299: PUSH
6300: LD_INT 2
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PPUSH
6311: CALL_OW 69
6315: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6316: LD_VAR 0 2
6320: NOT
6321: PUSH
6322: LD_EXP 19
6326: NOT
6327: AND
6328: IFFALSE 6398
// begin for i in engs do
6330: LD_ADDR_VAR 0 1
6334: PUSH
6335: LD_VAR 0 4
6339: PUSH
6340: FOR_IN
6341: IFFALSE 6396
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6343: LD_VAR 0 1
6347: PPUSH
6348: CALL_OW 256
6352: PUSH
6353: LD_INT 1000
6355: EQUAL
6356: PUSH
6357: LD_VAR 0 1
6361: PPUSH
6362: CALL_OW 314
6366: NOT
6367: AND
6368: PUSH
6369: LD_VAR 0 1
6373: PPUSH
6374: CALL_OW 310
6378: NOT
6379: AND
6380: IFFALSE 6394
// ComEnterUnit ( i , ru_dep_main ) ;
6382: LD_VAR 0 1
6386: PPUSH
6387: LD_INT 16
6389: PPUSH
6390: CALL_OW 120
6394: GO 6340
6396: POP
6397: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6398: LD_VAR 0 4
6402: PPUSH
6403: LD_INT 3
6405: PUSH
6406: LD_INT 24
6408: PUSH
6409: LD_INT 650
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PPUSH
6420: CALL_OW 72
6424: IFFALSE 6517
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6426: LD_ADDR_VAR 0 3
6430: PUSH
6431: LD_VAR 0 4
6435: PPUSH
6436: LD_INT 3
6438: PUSH
6439: LD_INT 24
6441: PUSH
6442: LD_INT 650
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: PPUSH
6453: CALL_OW 72
6457: ST_TO_ADDR
// for i in tmp do
6458: LD_ADDR_VAR 0 1
6462: PUSH
6463: LD_VAR 0 3
6467: PUSH
6468: FOR_IN
6469: IFFALSE 6515
// if not IsInArea ( i , mainBaseArea ) then
6471: LD_VAR 0 1
6475: PPUSH
6476: LD_INT 14
6478: PPUSH
6479: CALL_OW 308
6483: NOT
6484: IFFALSE 6513
// begin ComMoveXY ( i , 129 , 125 ) ;
6486: LD_VAR 0 1
6490: PPUSH
6491: LD_INT 129
6493: PPUSH
6494: LD_INT 125
6496: PPUSH
6497: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6501: LD_VAR 0 1
6505: PPUSH
6506: LD_INT 1050
6508: PPUSH
6509: CALL_OW 202
// end ;
6513: GO 6468
6515: POP
6516: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6517: LD_ADDR_VAR 0 4
6521: PUSH
6522: LD_VAR 0 4
6526: PPUSH
6527: LD_INT 24
6529: PUSH
6530: LD_INT 650
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: PPUSH
6537: CALL_OW 72
6541: ST_TO_ADDR
// if not engs then
6542: LD_VAR 0 4
6546: NOT
6547: IFFALSE 6551
// exit ;
6549: GO 6957
// if filter then
6551: LD_VAR 0 2
6555: IFFALSE 6814
// begin for i in engs do
6557: LD_ADDR_VAR 0 1
6561: PUSH
6562: LD_VAR 0 4
6566: PUSH
6567: FOR_IN
6568: IFFALSE 6592
// if IsInUnit ( i ) then
6570: LD_VAR 0 1
6574: PPUSH
6575: CALL_OW 310
6579: IFFALSE 6590
// ComExitBuilding ( i ) ;
6581: LD_VAR 0 1
6585: PPUSH
6586: CALL_OW 122
6590: GO 6567
6592: POP
6593: POP
// wait ( 3 ) ;
6594: LD_INT 3
6596: PPUSH
6597: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6601: LD_VAR 0 2
6605: PUSH
6606: LD_INT 2
6608: GREATEREQUAL
6609: PUSH
6610: LD_VAR 0 4
6614: PUSH
6615: LD_INT 2
6617: GREATEREQUAL
6618: AND
6619: IFFALSE 6767
// begin for i = 1 to engs / 2 do
6621: LD_ADDR_VAR 0 1
6625: PUSH
6626: DOUBLE
6627: LD_INT 1
6629: DEC
6630: ST_TO_ADDR
6631: LD_VAR 0 4
6635: PUSH
6636: LD_INT 2
6638: DIVREAL
6639: PUSH
6640: FOR_TO
6641: IFFALSE 6687
// if not HasTask ( engs [ i ] ) then
6643: LD_VAR 0 4
6647: PUSH
6648: LD_VAR 0 1
6652: ARRAY
6653: PPUSH
6654: CALL_OW 314
6658: NOT
6659: IFFALSE 6685
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6661: LD_VAR 0 4
6665: PUSH
6666: LD_VAR 0 1
6670: ARRAY
6671: PPUSH
6672: LD_VAR 0 2
6676: PUSH
6677: LD_INT 1
6679: ARRAY
6680: PPUSH
6681: CALL_OW 130
6685: GO 6640
6687: POP
6688: POP
// for i = engs / 2 + 1 to engs do
6689: LD_ADDR_VAR 0 1
6693: PUSH
6694: DOUBLE
6695: LD_VAR 0 4
6699: PUSH
6700: LD_INT 2
6702: DIVREAL
6703: PUSH
6704: LD_INT 1
6706: PLUS
6707: DEC
6708: ST_TO_ADDR
6709: LD_VAR 0 4
6713: PUSH
6714: FOR_TO
6715: IFFALSE 6763
// if not HasTask ( engs [ i ] ) then
6717: LD_VAR 0 4
6721: PUSH
6722: LD_VAR 0 1
6726: ARRAY
6727: PPUSH
6728: CALL_OW 314
6732: NOT
6733: IFFALSE 6761
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6735: LD_VAR 0 4
6739: PUSH
6740: LD_VAR 0 1
6744: ARRAY
6745: PPUSH
6746: LD_VAR 0 2
6750: PUSH
6751: LD_VAR 0 2
6755: ARRAY
6756: PPUSH
6757: CALL_OW 130
6761: GO 6714
6763: POP
6764: POP
// end else
6765: GO 6814
// for i in engs do
6767: LD_ADDR_VAR 0 1
6771: PUSH
6772: LD_VAR 0 4
6776: PUSH
6777: FOR_IN
6778: IFFALSE 6812
// if not HasTask ( i ) then
6780: LD_VAR 0 1
6784: PPUSH
6785: CALL_OW 314
6789: NOT
6790: IFFALSE 6810
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6792: LD_VAR 0 1
6796: PPUSH
6797: LD_VAR 0 2
6801: PUSH
6802: LD_INT 1
6804: ARRAY
6805: PPUSH
6806: CALL_OW 130
6810: GO 6777
6812: POP
6813: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6814: LD_ADDR_VAR 0 5
6818: PUSH
6819: LD_INT 81
6821: PUSH
6822: LD_INT 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PPUSH
6829: CALL_OW 69
6833: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6834: LD_EXP 19
6838: PUSH
6839: LD_VAR 0 2
6843: NOT
6844: AND
6845: IFFALSE 6957
// begin ComExitBuilding ( engs ) ;
6847: LD_VAR 0 4
6851: PPUSH
6852: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_EXP 19
6865: PUSH
6866: LD_INT 2
6868: ARRAY
6869: PPUSH
6870: LD_EXP 19
6874: PUSH
6875: LD_INT 3
6877: ARRAY
6878: PPUSH
6879: CALL_OW 73
6883: PPUSH
6884: LD_EXP 19
6888: PUSH
6889: LD_INT 2
6891: ARRAY
6892: PPUSH
6893: LD_EXP 19
6897: PUSH
6898: LD_INT 3
6900: ARRAY
6901: PPUSH
6902: CALL_OW 297
6906: PUSH
6907: LD_INT 10
6909: GREATER
6910: IFFALSE 6957
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6912: LD_VAR 0 4
6916: PPUSH
6917: LD_EXP 19
6921: PUSH
6922: LD_INT 1
6924: ARRAY
6925: PPUSH
6926: LD_EXP 19
6930: PUSH
6931: LD_INT 2
6933: ARRAY
6934: PPUSH
6935: LD_EXP 19
6939: PUSH
6940: LD_INT 3
6942: ARRAY
6943: PPUSH
6944: LD_EXP 19
6948: PUSH
6949: LD_INT 4
6951: ARRAY
6952: PPUSH
6953: CALL_OW 145
// end ; end ;
6957: PPOPN 5
6959: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
6960: LD_INT 16
6962: PPUSH
6963: CALL_OW 256
6967: PUSH
6968: LD_INT 650
6970: LESS
6971: IFFALSE 7054
6973: GO 6975
6975: DISABLE
6976: LD_INT 0
6978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
6979: LD_ADDR_VAR 0 1
6983: PUSH
6984: LD_INT 22
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 25
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7013: LD_VAR 0 1
7017: PPUSH
7018: CALL_OW 122
// wait ( 3 ) ;
7022: LD_INT 3
7024: PPUSH
7025: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
7029: LD_VAR 0 1
7033: PPUSH
7034: LD_INT 16
7036: PPUSH
7037: CALL_OW 250
7041: PPUSH
7042: LD_INT 16
7044: PPUSH
7045: CALL_OW 251
7049: PPUSH
7050: CALL_OW 114
// end ;
7054: PPOPN 1
7056: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7057: LD_INT 16
7059: PPUSH
7060: CALL_OW 256
7064: PUSH
7065: LD_INT 650
7067: GREATER
7068: PUSH
7069: LD_INT 22
7071: PUSH
7072: LD_INT 3
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PUSH
7079: LD_INT 25
7081: PUSH
7082: LD_INT 1
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: LD_INT 56
7091: PUSH
7092: EMPTY
7093: LIST
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: PPUSH
7103: CALL_OW 69
7107: AND
7108: IFFALSE 7220
7110: GO 7112
7112: DISABLE
7113: LD_INT 0
7115: PPUSH
7116: PPUSH
// begin enable ;
7117: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7118: LD_ADDR_VAR 0 2
7122: PUSH
7123: LD_INT 22
7125: PUSH
7126: LD_INT 3
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PUSH
7133: LD_INT 25
7135: PUSH
7136: LD_INT 1
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: PUSH
7143: LD_INT 56
7145: PUSH
7146: EMPTY
7147: LIST
7148: PUSH
7149: LD_INT 3
7151: PUSH
7152: LD_INT 60
7154: PUSH
7155: EMPTY
7156: LIST
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: LIST
7167: PUSH
7168: EMPTY
7169: LIST
7170: PPUSH
7171: CALL_OW 69
7175: ST_TO_ADDR
// if not tmp then
7176: LD_VAR 0 2
7180: NOT
7181: IFFALSE 7185
// exit ;
7183: GO 7220
// for i in tmp do
7185: LD_ADDR_VAR 0 1
7189: PUSH
7190: LD_VAR 0 2
7194: PUSH
7195: FOR_IN
7196: IFFALSE 7218
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7198: LD_VAR 0 1
7202: PPUSH
7203: LD_INT 0
7205: PPUSH
7206: LD_INT 143
7208: PPUSH
7209: LD_INT 143
7211: PPUSH
7212: CALL 2055 0 4
7216: GO 7195
7218: POP
7219: POP
// end ;
7220: PPOPN 2
7222: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7223: LD_INT 22
7225: PUSH
7226: LD_INT 3
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PUSH
7233: LD_INT 25
7235: PUSH
7236: LD_INT 4
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PPUSH
7247: CALL_OW 69
7251: IFFALSE 7505
7253: GO 7255
7255: DISABLE
7256: LD_INT 0
7258: PPUSH
7259: PPUSH
7260: PPUSH
// begin enable ;
7261: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7262: LD_ADDR_VAR 0 2
7266: PUSH
7267: LD_INT 14
7269: PPUSH
7270: LD_INT 22
7272: PUSH
7273: LD_INT 3
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: PUSH
7280: LD_INT 21
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 3
7292: PUSH
7293: LD_INT 24
7295: PUSH
7296: LD_INT 1000
7298: PUSH
7299: EMPTY
7300: LIST
7301: LIST
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: LIST
7311: PPUSH
7312: CALL_OW 70
7316: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7317: LD_ADDR_VAR 0 3
7321: PUSH
7322: LD_INT 22
7324: PUSH
7325: LD_INT 3
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PUSH
7332: LD_INT 25
7334: PUSH
7335: LD_INT 4
7337: PUSH
7338: EMPTY
7339: LIST
7340: LIST
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PPUSH
7346: CALL_OW 69
7350: ST_TO_ADDR
// if not doc then
7351: LD_VAR 0 3
7355: NOT
7356: IFFALSE 7360
// exit ;
7358: GO 7505
// if not tmp then
7360: LD_VAR 0 2
7364: NOT
7365: IFFALSE 7456
// begin if not IsInUnit ( doc [ 1 ] ) then
7367: LD_VAR 0 3
7371: PUSH
7372: LD_INT 1
7374: ARRAY
7375: PPUSH
7376: CALL_OW 310
7380: NOT
7381: IFFALSE 7454
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7383: LD_VAR 0 3
7387: PPUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 2
7400: PUSH
7401: LD_INT 30
7403: PUSH
7404: LD_INT 6
7406: PUSH
7407: EMPTY
7408: LIST
7409: LIST
7410: PUSH
7411: LD_INT 30
7413: PUSH
7414: LD_INT 7
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: LD_INT 30
7423: PUSH
7424: LD_INT 8
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: PPUSH
7441: CALL_OW 69
7445: PUSH
7446: LD_INT 1
7448: ARRAY
7449: PPUSH
7450: CALL_OW 120
// exit ;
7454: GO 7505
// end ; if IsInUnit ( doc [ 1 ] ) then
7456: LD_VAR 0 3
7460: PUSH
7461: LD_INT 1
7463: ARRAY
7464: PPUSH
7465: CALL_OW 310
7469: IFFALSE 7480
// ComExitBuilding ( doc ) ;
7471: LD_VAR 0 3
7475: PPUSH
7476: CALL_OW 122
// wait ( 3 ) ;
7480: LD_INT 3
7482: PPUSH
7483: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7487: LD_VAR 0 3
7491: PPUSH
7492: LD_VAR 0 2
7496: PUSH
7497: LD_INT 1
7499: ARRAY
7500: PPUSH
7501: CALL_OW 128
// end ;
7505: PPOPN 3
7507: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7508: LD_INT 22
7510: PUSH
7511: LD_INT 3
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: LD_INT 25
7520: PUSH
7521: LD_INT 3
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: PUSH
7537: LD_INT 22
7539: PUSH
7540: LD_INT 3
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: LD_INT 21
7549: PUSH
7550: LD_INT 2
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PPUSH
7561: CALL_OW 69
7565: AND
7566: IFFALSE 7980
7568: GO 7570
7570: DISABLE
7571: LD_INT 0
7573: PPUSH
7574: PPUSH
7575: PPUSH
7576: PPUSH
7577: PPUSH
// begin enable ;
7578: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7579: LD_ADDR_VAR 0 2
7583: PUSH
7584: LD_INT 22
7586: PUSH
7587: LD_INT 3
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: PUSH
7594: LD_INT 21
7596: PUSH
7597: LD_INT 2
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PUSH
7604: LD_INT 3
7606: PUSH
7607: LD_INT 58
7609: PUSH
7610: EMPTY
7611: LIST
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: LIST
7621: PPUSH
7622: CALL_OW 69
7626: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7627: LD_ADDR_VAR 0 4
7631: PUSH
7632: LD_INT 10
7634: PUSH
7635: LD_INT 11
7637: PUSH
7638: LD_INT 12
7640: PUSH
7641: LD_INT 14
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// area := 0 ;
7650: LD_ADDR_VAR 0 5
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// attacking := false ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// for i in tmp do
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 2
7675: PUSH
7676: FOR_IN
7677: IFFALSE 7763
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7679: LD_VAR 0 1
7683: PPUSH
7684: LD_INT 22
7686: PUSH
7687: LD_INT 1
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 69
7698: PPUSH
7699: LD_VAR 0 1
7703: PPUSH
7704: CALL_OW 74
7708: PPUSH
7709: CALL_OW 296
7713: PUSH
7714: LD_INT 10
7716: LESS
7717: IFFALSE 7761
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7719: LD_VAR 0 1
7723: PPUSH
7724: LD_INT 22
7726: PUSH
7727: LD_INT 1
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: PPUSH
7739: LD_VAR 0 1
7743: PPUSH
7744: CALL_OW 74
7748: PPUSH
7749: CALL_OW 115
// attacking := true ;
7753: LD_ADDR_VAR 0 3
7757: PUSH
7758: LD_INT 1
7760: ST_TO_ADDR
// end ;
7761: GO 7676
7763: POP
7764: POP
// if attacking then
7765: LD_VAR 0 3
7769: IFFALSE 7773
// exit ;
7771: GO 7980
// for i in areas do
7773: LD_ADDR_VAR 0 1
7777: PUSH
7778: LD_VAR 0 4
7782: PUSH
7783: FOR_IN
7784: IFFALSE 7821
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: LD_INT 22
7793: PUSH
7794: LD_INT 1
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PPUSH
7801: CALL_OW 70
7805: IFFALSE 7819
// begin area := i ;
7807: LD_ADDR_VAR 0 5
7811: PUSH
7812: LD_VAR 0 1
7816: ST_TO_ADDR
// break ;
7817: GO 7821
// end ;
7819: GO 7783
7821: POP
7822: POP
// if area then
7823: LD_VAR 0 5
7827: IFFALSE 7980
// begin for i in tmp do
7829: LD_ADDR_VAR 0 1
7833: PUSH
7834: LD_VAR 0 2
7838: PUSH
7839: FOR_IN
7840: IFFALSE 7978
// begin if GetFuel ( i ) < 33 then
7842: LD_VAR 0 1
7846: PPUSH
7847: CALL_OW 261
7851: PUSH
7852: LD_INT 33
7854: LESS
7855: IFFALSE 7869
// SetFuel ( i , 33 ) ;
7857: LD_VAR 0 1
7861: PPUSH
7862: LD_INT 33
7864: PPUSH
7865: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7869: LD_VAR 0 1
7873: PPUSH
7874: LD_INT 22
7876: PUSH
7877: LD_INT 1
7879: PUSH
7880: EMPTY
7881: LIST
7882: LIST
7883: PPUSH
7884: CALL_OW 69
7888: PPUSH
7889: LD_VAR 0 1
7893: PPUSH
7894: CALL_OW 74
7898: PPUSH
7899: CALL_OW 296
7903: PUSH
7904: LD_INT 10
7906: LESS
7907: IFFALSE 7945
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7909: LD_VAR 0 1
7913: PPUSH
7914: LD_INT 22
7916: PUSH
7917: LD_INT 1
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PPUSH
7924: CALL_OW 69
7928: PPUSH
7929: LD_VAR 0 1
7933: PPUSH
7934: CALL_OW 74
7938: PPUSH
7939: CALL_OW 115
7943: GO 7976
// if not IsInArea ( i , area ) then
7945: LD_VAR 0 1
7949: PPUSH
7950: LD_VAR 0 5
7954: PPUSH
7955: CALL_OW 308
7959: NOT
7960: IFFALSE 7976
// ComMoveToArea ( i , area ) ;
7962: LD_VAR 0 1
7966: PPUSH
7967: LD_VAR 0 5
7971: PPUSH
7972: CALL_OW 113
// end ;
7976: GO 7839
7978: POP
7979: POP
// end ; end ;
7980: PPOPN 5
7982: END
// every 10 10$00 do var i , j , un , veh , time , count ;
7983: GO 7985
7985: DISABLE
7986: LD_INT 0
7988: PPUSH
7989: PPUSH
7990: PPUSH
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin uc_side := 3 ;
7994: LD_ADDR_OWVAR 20
7998: PUSH
7999: LD_INT 3
8001: ST_TO_ADDR
// uc_nation := 3 ;
8002: LD_ADDR_OWVAR 21
8006: PUSH
8007: LD_INT 3
8009: ST_TO_ADDR
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8010: LD_ADDR_VAR 0 5
8014: PUSH
8015: LD_INT 16800
8017: PUSH
8018: LD_INT 14700
8020: PUSH
8021: LD_INT 12600
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: LIST
8028: PUSH
8029: LD_OWVAR 67
8033: ARRAY
8034: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8035: LD_ADDR_VAR 0 6
8039: PUSH
8040: LD_INT 2
8042: PUSH
8043: LD_INT 2
8045: PUSH
8046: LD_INT 3
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: LIST
8053: PUSH
8054: LD_OWVAR 67
8058: ARRAY
8059: ST_TO_ADDR
// for i = 1 to count do
8060: LD_ADDR_VAR 0 1
8064: PUSH
8065: DOUBLE
8066: LD_INT 1
8068: DEC
8069: ST_TO_ADDR
8070: LD_VAR 0 6
8074: PUSH
8075: FOR_TO
8076: IFFALSE 8256
// begin wait ( time ) ;
8078: LD_VAR 0 5
8082: PPUSH
8083: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8087: LD_ADDR_VAR 0 2
8091: PUSH
8092: DOUBLE
8093: LD_INT 1
8095: DEC
8096: ST_TO_ADDR
8097: LD_INT 1
8099: PPUSH
8100: LD_OWVAR 67
8104: PPUSH
8105: CALL_OW 12
8109: PUSH
8110: FOR_TO
8111: IFFALSE 8252
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8113: LD_ADDR_VAR 0 4
8117: PUSH
8118: LD_INT 3
8120: PPUSH
8121: LD_INT 3
8123: PPUSH
8124: LD_INT 22
8126: PPUSH
8127: LD_INT 1
8129: PPUSH
8130: LD_INT 1
8132: PPUSH
8133: LD_INT 43
8135: PUSH
8136: LD_INT 44
8138: PUSH
8139: LD_INT 42
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: LIST
8146: PUSH
8147: LD_VAR 0 1
8151: PUSH
8152: LD_INT 3
8154: MOD
8155: PUSH
8156: LD_INT 1
8158: PLUS
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 418 0 7
8168: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8169: LD_VAR 0 4
8173: PPUSH
8174: LD_INT 13
8176: PPUSH
8177: LD_INT 0
8179: PPUSH
8180: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8184: LD_INT 0
8186: PPUSH
8187: LD_INT 3
8189: PPUSH
8190: LD_INT 4
8192: PUSH
8193: LD_INT 5
8195: PUSH
8196: LD_INT 5
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_OWVAR 67
8208: ARRAY
8209: PPUSH
8210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8214: CALL_OW 44
8218: PPUSH
8219: LD_VAR 0 4
8223: PPUSH
8224: CALL_OW 52
// wait ( 0 0$01 ) ;
8228: LD_INT 35
8230: PPUSH
8231: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8235: LD_VAR 0 4
8239: PPUSH
8240: LD_INT 143
8242: PPUSH
8243: LD_INT 143
8245: PPUSH
8246: CALL_OW 111
// end ;
8250: GO 8110
8252: POP
8253: POP
// end ;
8254: GO 8075
8256: POP
8257: POP
// end ;
8258: PPOPN 6
8260: END
// every 8 8$00 do var i , un , time ;
8261: GO 8263
8263: DISABLE
8264: LD_INT 0
8266: PPUSH
8267: PPUSH
8268: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
8269: LD_ADDR_VAR 0 3
8273: PUSH
8274: LD_INT 4200
8276: PUSH
8277: LD_INT 2100
8279: PUSH
8280: LD_INT 1050
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: LIST
8287: ST_TO_ADDR
// wait ( time ) ;
8288: LD_VAR 0 3
8292: PPUSH
8293: CALL_OW 67
// uc_side := 3 ;
8297: LD_ADDR_OWVAR 20
8301: PUSH
8302: LD_INT 3
8304: ST_TO_ADDR
// uc_nation := 3 ;
8305: LD_ADDR_OWVAR 21
8309: PUSH
8310: LD_INT 3
8312: ST_TO_ADDR
// for i = 1 to 2 do
8313: LD_ADDR_VAR 0 1
8317: PUSH
8318: DOUBLE
8319: LD_INT 1
8321: DEC
8322: ST_TO_ADDR
8323: LD_INT 2
8325: PUSH
8326: FOR_TO
8327: IFFALSE 8390
// begin PrepareHuman ( false , 1 , 4 ) ;
8329: LD_INT 0
8331: PPUSH
8332: LD_INT 1
8334: PPUSH
8335: LD_INT 4
8337: PPUSH
8338: CALL_OW 380
// un := CreateHuman ;
8342: LD_ADDR_VAR 0 2
8346: PUSH
8347: CALL_OW 44
8351: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8352: LD_VAR 0 2
8356: PPUSH
8357: LD_INT 16
8359: PPUSH
8360: CALL_OW 52
// ComExitBuilding ( un ) ;
8364: LD_VAR 0 2
8368: PPUSH
8369: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8373: LD_VAR 0 2
8377: PPUSH
8378: LD_INT 41
8380: PPUSH
8381: LD_INT 76
8383: PPUSH
8384: CALL_OW 174
// end ;
8388: GO 8326
8390: POP
8391: POP
// end ; end_of_file
8392: PPOPN 3
8394: END
// export function Action ; begin
8395: LD_INT 0
8397: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8398: LD_INT 28
8400: PPUSH
8401: LD_INT 3
8403: PPUSH
8404: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8408: LD_INT 41
8410: PPUSH
8411: LD_INT 76
8413: PPUSH
8414: LD_INT 1
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8424: LD_INT 41
8426: PPUSH
8427: LD_INT 76
8429: PPUSH
8430: LD_INT 1
8432: PPUSH
8433: CALL_OW 331
// InGameOn ;
8437: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8441: LD_EXP 18
8445: PPUSH
8446: LD_STRING D2-Har-1
8448: PPUSH
8449: CALL_OW 94
// InGameOff ;
8453: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8457: LD_STRING M1
8459: PPUSH
8460: CALL_OW 337
// end ;
8464: LD_VAR 0 1
8468: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8469: LD_EXP 4
8473: PUSH
8474: LD_INT 1
8476: GREATER
8477: IFFALSE 8568
8479: GO 8481
8481: DISABLE
8482: LD_INT 0
8484: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8485: LD_ADDR_VAR 0 1
8489: PUSH
8490: LD_INT 1
8492: PPUSH
8493: CALL 506 0 1
8497: PUSH
8498: LD_INT 1
8500: ARRAY
8501: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8502: LD_VAR 0 1
8506: PPUSH
8507: LD_STRING D2a-Sol1-1
8509: PPUSH
8510: CALL_OW 88
// if not un then
8514: LD_VAR 0 1
8518: NOT
8519: IFFALSE 8550
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8521: LD_ADDR_VAR 0 1
8525: PUSH
8526: LD_INT 2
8528: PPUSH
8529: CALL 506 0 1
8533: PUSH
8534: LD_INT 1
8536: ARRAY
8537: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8538: LD_VAR 0 1
8542: PPUSH
8543: LD_STRING D2a-FSol1-1
8545: PPUSH
8546: CALL_OW 88
// end ; if Khatam then
8550: LD_EXP 16
8554: IFFALSE 8568
// Say ( Khatam , D3b-Khat-3 ) ;
8556: LD_EXP 16
8560: PPUSH
8561: LD_STRING D3b-Khat-3
8563: PPUSH
8564: CALL_OW 88
// end ;
8568: PPOPN 1
8570: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8571: LD_EXP 14
8575: PUSH
8576: LD_EXP 17
8580: NOT
8581: AND
8582: PUSH
8583: LD_INT 22
8585: PUSH
8586: LD_INT 1
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PUSH
8593: LD_INT 92
8595: PUSH
8596: LD_EXP 14
8600: PPUSH
8601: CALL_OW 250
8605: PUSH
8606: LD_EXP 14
8610: PPUSH
8611: CALL_OW 251
8615: PUSH
8616: LD_INT 7
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: LIST
8624: PUSH
8625: EMPTY
8626: LIST
8627: LIST
8628: PPUSH
8629: CALL_OW 69
8633: AND
8634: PUSH
8635: LD_INT 1
8637: PPUSH
8638: CALL_OW 463
8642: NOT
8643: AND
8644: IFFALSE 9231
8646: GO 8648
8648: DISABLE
8649: LD_INT 0
8651: PPUSH
8652: PPUSH
// begin InGameOn ;
8653: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8657: LD_ADDR_VAR 0 2
8661: PUSH
8662: LD_INT 22
8664: PUSH
8665: LD_INT 0
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 25
8674: PUSH
8675: LD_INT 12
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: PPUSH
8686: CALL_OW 69
8690: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8691: LD_ADDR_VAR 0 2
8695: PUSH
8696: LD_VAR 0 2
8700: PPUSH
8701: LD_EXP 14
8705: PPUSH
8706: CALL_OW 74
8710: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8711: LD_ADDR_VAR 0 1
8715: PUSH
8716: LD_INT 22
8718: PUSH
8719: LD_INT 1
8721: PUSH
8722: EMPTY
8723: LIST
8724: LIST
8725: PUSH
8726: LD_INT 21
8728: PUSH
8729: LD_INT 1
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PUSH
8736: LD_INT 91
8738: PUSH
8739: LD_EXP 14
8743: PUSH
8744: LD_INT 20
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL_OW 69
8761: PUSH
8762: FOR_IN
8763: IFFALSE 8781
// ComTurnUnit ( i , Frank ) ;
8765: LD_VAR 0 1
8769: PPUSH
8770: LD_EXP 14
8774: PPUSH
8775: CALL_OW 119
8779: GO 8762
8781: POP
8782: POP
// SetSide ( Frank , 1 ) ;
8783: LD_EXP 14
8787: PPUSH
8788: LD_INT 1
8790: PPUSH
8791: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8795: LD_EXP 8
8799: PPUSH
8800: LD_EXP 14
8804: PPUSH
8805: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8809: LD_EXP 8
8813: PPUSH
8814: LD_EXP 14
8818: PPUSH
8819: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8823: LD_EXP 14
8827: PPUSH
8828: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8832: LD_EXP 14
8836: PPUSH
8837: LD_STRING D3a-Frank-1
8839: PPUSH
8840: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8844: LD_VAR 0 2
8848: PPUSH
8849: LD_INT 42
8851: PPUSH
8852: LD_INT 78
8854: PPUSH
8855: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
8859: LD_VAR 0 2
8863: PPUSH
8864: LD_EXP 14
8868: PPUSH
8869: CALL_OW 179
// if Lisa then
8873: LD_EXP 13
8877: IFFALSE 8891
// Say ( Lisa , D3a-Lisa-1 ) ;
8879: LD_EXP 13
8883: PPUSH
8884: LD_STRING D3a-Lisa-1
8886: PPUSH
8887: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
8891: LD_EXP 8
8895: PPUSH
8896: LD_STRING D3a-JMM-1
8898: PPUSH
8899: CALL_OW 88
// if Cyrus then
8903: LD_EXP 12
8907: IFFALSE 8921
// Say ( Cyrus , D3a-Cyrus-1 ) ;
8909: LD_EXP 12
8913: PPUSH
8914: LD_STRING D3a-Cyrus-1
8916: PPUSH
8917: CALL_OW 88
// if GetRandom ( sex_male ) then
8921: LD_INT 1
8923: PPUSH
8924: CALL 506 0 1
8928: IFFALSE 8949
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
8930: LD_INT 1
8932: PPUSH
8933: CALL 506 0 1
8937: PUSH
8938: LD_INT 1
8940: ARRAY
8941: PPUSH
8942: LD_STRING D3a-Sol1-1
8944: PPUSH
8945: CALL_OW 88
// if GetRandom ( sex_female ) then
8949: LD_INT 2
8951: PPUSH
8952: CALL 506 0 1
8956: IFFALSE 8977
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
8958: LD_INT 2
8960: PPUSH
8961: CALL 506 0 1
8965: PUSH
8966: LD_INT 1
8968: ARRAY
8969: PPUSH
8970: LD_STRING D3a-FSol1-1
8972: PPUSH
8973: CALL_OW 88
// if Gladstone then
8977: LD_EXP 15
8981: IFFALSE 8995
// Say ( Gladstone , D3a-Glad-1 ) ;
8983: LD_EXP 15
8987: PPUSH
8988: LD_STRING D3a-Glad-1
8990: PPUSH
8991: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
8995: LD_VAR 0 2
8999: PPUSH
9000: LD_INT 60
9002: PPUSH
9003: LD_INT 113
9005: PPUSH
9006: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9010: LD_EXP 14
9014: PPUSH
9015: LD_STRING D3a-Frank-2
9017: PPUSH
9018: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9022: LD_EXP 14
9026: PPUSH
9027: LD_EXP 8
9031: PPUSH
9032: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9036: LD_EXP 8
9040: PPUSH
9041: LD_STRING D3a-JMM-2
9043: PPUSH
9044: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9048: LD_INT 1
9050: PPUSH
9051: LD_INT 4
9053: PPUSH
9054: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9058: LD_INT 85
9060: PPUSH
9061: LD_INT 134
9063: PPUSH
9064: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9068: LD_EXP 14
9072: PPUSH
9073: LD_STRING D3a-Frank-3
9075: PPUSH
9076: CALL_OW 88
// Wait ( 0 0$01 ) ;
9080: LD_INT 35
9082: PPUSH
9083: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9087: LD_INT 166
9089: PPUSH
9090: LD_INT 136
9092: PPUSH
9093: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9097: LD_EXP 8
9101: PPUSH
9102: LD_STRING D3a-JMM-3
9104: PPUSH
9105: CALL_OW 88
// Wait ( 0 0$01 ) ;
9109: LD_INT 35
9111: PPUSH
9112: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9116: LD_EXP 14
9120: PPUSH
9121: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9125: LD_EXP 14
9129: PPUSH
9130: LD_STRING D3a-Frank-4
9132: PPUSH
9133: CALL_OW 88
// if Lisa then
9137: LD_EXP 13
9141: IFFALSE 9155
// Say ( Lisa , D3a-Lisa-4 ) ;
9143: LD_EXP 13
9147: PPUSH
9148: LD_STRING D3a-Lisa-4
9150: PPUSH
9151: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9155: LD_EXP 8
9159: PPUSH
9160: LD_STRING D3a-JMM-4
9162: PPUSH
9163: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9167: LD_EXP 14
9171: PPUSH
9172: LD_STRING D3a-Frank-5
9174: PPUSH
9175: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9179: LD_EXP 8
9183: PPUSH
9184: LD_STRING D3a-JMM-5
9186: PPUSH
9187: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9191: LD_EXP 14
9195: PPUSH
9196: LD_STRING D3a-Frank-6
9198: PPUSH
9199: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9203: LD_EXP 8
9207: PPUSH
9208: LD_STRING D3a-JMM-6
9210: PPUSH
9211: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9215: LD_EXP 14
9219: PPUSH
9220: LD_STRING D3a-Frank-7
9222: PPUSH
9223: CALL_OW 88
// InGameOff ;
9227: CALL_OW 9
// end ;
9231: PPOPN 2
9233: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9234: LD_EXP 17
9238: PUSH
9239: LD_EXP 14
9243: NOT
9244: AND
9245: PUSH
9246: LD_INT 22
9248: PUSH
9249: LD_INT 1
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: PUSH
9256: LD_INT 92
9258: PUSH
9259: LD_EXP 17
9263: PPUSH
9264: CALL_OW 250
9268: PUSH
9269: LD_EXP 17
9273: PPUSH
9274: CALL_OW 251
9278: PUSH
9279: LD_INT 7
9281: PUSH
9282: EMPTY
9283: LIST
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PPUSH
9292: CALL_OW 69
9296: AND
9297: PUSH
9298: LD_INT 1
9300: PPUSH
9301: CALL_OW 463
9305: NOT
9306: AND
9307: IFFALSE 9487
9309: GO 9311
9311: DISABLE
// begin InGameOn ;
9312: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9316: LD_EXP 8
9320: PPUSH
9321: LD_EXP 17
9325: PPUSH
9326: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9330: LD_EXP 17
9334: PPUSH
9335: LD_EXP 8
9339: PPUSH
9340: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9344: LD_EXP 17
9348: PPUSH
9349: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9353: LD_EXP 17
9357: PPUSH
9358: LD_STRING D3b-Yam-1
9360: PPUSH
9361: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9365: LD_EXP 8
9369: PPUSH
9370: LD_STRING D3b-JMM-1
9372: PPUSH
9373: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9377: LD_INT 1
9379: PPUSH
9380: LD_INT 4
9382: PPUSH
9383: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9387: LD_INT 85
9389: PPUSH
9390: LD_INT 134
9392: PPUSH
9393: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9397: LD_EXP 17
9401: PPUSH
9402: LD_STRING D3b-Yam-2
9404: PPUSH
9405: CALL_OW 88
// Wait ( 0 0$01 ) ;
9409: LD_INT 35
9411: PPUSH
9412: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9416: LD_EXP 8
9420: PPUSH
9421: LD_STRING D3b-JMM-2
9423: PPUSH
9424: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9428: LD_INT 166
9430: PPUSH
9431: LD_INT 136
9433: PPUSH
9434: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9438: LD_EXP 17
9442: PPUSH
9443: LD_STRING D3b-Yam-3
9445: PPUSH
9446: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9450: LD_EXP 8
9454: PPUSH
9455: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9459: LD_EXP 8
9463: PPUSH
9464: LD_STRING D3b-JMM-3a
9466: PPUSH
9467: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9471: LD_EXP 17
9475: PPUSH
9476: LD_INT 1
9478: PPUSH
9479: CALL_OW 235
// InGameOff ;
9483: CALL_OW 9
// end ;
9487: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9488: LD_INT 7
9490: PPUSH
9491: LD_INT 22
9493: PUSH
9494: LD_INT 1
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PUSH
9501: LD_INT 3
9503: PUSH
9504: LD_INT 24
9506: PUSH
9507: LD_INT 1000
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PPUSH
9522: CALL_OW 70
9526: IFFALSE 9982
9528: GO 9530
9530: DISABLE
9531: LD_INT 0
9533: PPUSH
9534: PPUSH
9535: PPUSH
9536: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9537: LD_INT 35
9539: PPUSH
9540: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9544: LD_ADDR_VAR 0 1
9548: PUSH
9549: LD_INT 7
9551: PPUSH
9552: LD_INT 22
9554: PUSH
9555: LD_INT 1
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: PUSH
9562: LD_INT 3
9564: PUSH
9565: LD_INT 24
9567: PUSH
9568: LD_INT 1000
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PPUSH
9583: CALL_OW 70
9587: ST_TO_ADDR
// if not un then
9588: LD_VAR 0 1
9592: NOT
9593: IFFALSE 9597
// continue ;
9595: GO 9537
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9597: LD_ADDR_VAR 0 3
9601: PUSH
9602: LD_VAR 0 1
9606: PUSH
9607: LD_INT 1
9609: ARRAY
9610: PPUSH
9611: CALL 3403 0 1
9615: ST_TO_ADDR
// until tw ;
9616: LD_VAR 0 3
9620: IFFALSE 9537
// DialogueOn ;
9622: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9626: LD_VAR 0 3
9630: PPUSH
9631: CALL_OW 87
// if Lisa then
9635: LD_EXP 13
9639: IFFALSE 9667
// begin Say ( Lisa , D5-Lisa-1 ) ;
9641: LD_EXP 13
9645: PPUSH
9646: LD_STRING D5-Lisa-1
9648: PPUSH
9649: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9653: LD_EXP 8
9657: PPUSH
9658: LD_STRING D5-JMM-1a
9660: PPUSH
9661: CALL_OW 88
// end else
9665: GO 9679
// Say ( JMM , D5-JMM-1 ) ;
9667: LD_EXP 8
9671: PPUSH
9672: LD_STRING D5-JMM-1
9674: PPUSH
9675: CALL_OW 88
// DialogueOff ;
9679: CALL_OW 7
// while ( true ) do
9683: LD_INT 1
9685: IFFALSE 9741
// begin wait ( 0 0$01 ) ;
9687: LD_INT 35
9689: PPUSH
9690: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9694: LD_ADDR_VAR 0 2
9698: PUSH
9699: LD_INT 8
9701: PPUSH
9702: LD_INT 30
9704: PUSH
9705: LD_INT 26
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PUSH
9712: LD_INT 101
9714: PUSH
9715: LD_INT 1
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PPUSH
9726: CALL_OW 71
9730: ST_TO_ADDR
// if x then
9731: LD_VAR 0 2
9735: IFFALSE 9739
// break ;
9737: GO 9741
// end ;
9739: GO 9683
// CenterOnUnits ( x [ 1 ] ) ;
9741: LD_VAR 0 2
9745: PUSH
9746: LD_INT 1
9748: ARRAY
9749: PPUSH
9750: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9754: LD_EXP 14
9758: PUSH
9759: LD_EXP 14
9763: PPUSH
9764: CALL_OW 255
9768: PUSH
9769: LD_INT 1
9771: EQUAL
9772: AND
9773: IFFALSE 9789
// Say ( Frank , D5a-Frank-1 ) else
9775: LD_EXP 14
9779: PPUSH
9780: LD_STRING D5a-Frank-1
9782: PPUSH
9783: CALL_OW 88
9787: GO 9843
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9789: LD_EXP 17
9793: PUSH
9794: LD_EXP 17
9798: PPUSH
9799: CALL_OW 255
9803: PUSH
9804: LD_INT 1
9806: EQUAL
9807: AND
9808: IFFALSE 9824
// Say ( Kikuchi , D5a-Yam-1 ) else
9810: LD_EXP 17
9814: PPUSH
9815: LD_STRING D5a-Yam-1
9817: PPUSH
9818: CALL_OW 88
9822: GO 9843
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9824: LD_INT 1
9826: PPUSH
9827: CALL 506 0 1
9831: PUSH
9832: LD_INT 1
9834: ARRAY
9835: PPUSH
9836: LD_STRING D5a-Sol1-1
9838: PPUSH
9839: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9843: LD_EXP 8
9847: PPUSH
9848: LD_STRING D5a-JMM-1
9850: PPUSH
9851: CALL_OW 88
// if Cyrus then
9855: LD_EXP 12
9859: IFFALSE 9873
// Say ( Cyrus , D5a-Cyrus-1 ) ;
9861: LD_EXP 12
9865: PPUSH
9866: LD_STRING D5a-Cyrus-1
9868: PPUSH
9869: CALL_OW 88
// x := false ;
9873: LD_ADDR_VAR 0 2
9877: PUSH
9878: LD_INT 0
9880: ST_TO_ADDR
// while ( true ) do
9881: LD_INT 1
9883: IFFALSE 9970
// begin wait ( 0 0$01 ) ;
9885: LD_INT 35
9887: PPUSH
9888: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
9892: LD_ADDR_VAR 0 4
9896: PUSH
9897: LD_INT 2
9899: PUSH
9900: LD_INT 30
9902: PUSH
9903: LD_INT 0
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: PUSH
9910: LD_INT 30
9912: PUSH
9913: LD_INT 1
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: LIST
9924: PPUSH
9925: CALL_OW 69
9929: PUSH
9930: LD_INT 1
9932: DIFF
9933: PUSH
9934: FOR_IN
9935: IFFALSE 9958
// if BaseNeedEnergy ( i ) then
9937: LD_VAR 0 4
9941: PPUSH
9942: CALL 2528 0 1
9946: IFFALSE 9956
// x := true ;
9948: LD_ADDR_VAR 0 2
9952: PUSH
9953: LD_INT 1
9955: ST_TO_ADDR
9956: GO 9934
9958: POP
9959: POP
// if x then
9960: LD_VAR 0 2
9964: IFFALSE 9968
// break ;
9966: GO 9970
// end ;
9968: GO 9881
// Say ( JMM , D5b-JMM-1 ) ;
9970: LD_EXP 8
9974: PPUSH
9975: LD_STRING D5b-JMM-1
9977: PPUSH
9978: CALL_OW 88
// end ;
9982: PPOPN 4
9984: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
9985: LD_EXP 5
9989: PUSH
9990: LD_INT 1
9992: ARRAY
9993: PUSH
9994: LD_OWVAR 1
9998: LESS
9999: IFFALSE 10199
10001: GO 10003
10003: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10004: LD_INT 16
10006: PPUSH
10007: CALL_OW 301
10011: NOT
10012: IFFALSE 10035
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10014: LD_EXP 18
10018: PPUSH
10019: LD_STRING D3b-Har-3
10021: PPUSH
10022: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10026: LD_STRING M2a
10028: PPUSH
10029: CALL_OW 337
// end else
10033: GO 10054
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10035: LD_EXP 18
10039: PPUSH
10040: LD_STRING D3b-Har-3a
10042: PPUSH
10043: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10047: LD_STRING M2
10049: PPUSH
10050: CALL_OW 337
// end ; can_end := true ;
10054: LD_ADDR_EXP 6
10058: PUSH
10059: LD_INT 1
10061: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10062: LD_INT 9
10064: PPUSH
10065: LD_INT 1
10067: PPUSH
10068: CALL_OW 424
// Wait ( 0 0$02 ) ;
10072: LD_INT 70
10074: PPUSH
10075: CALL_OW 67
// if Lisa then
10079: LD_EXP 13
10083: IFFALSE 10097
// Say ( Lisa , D3b-Lisa ) ;
10085: LD_EXP 13
10089: PPUSH
10090: LD_STRING D3b-Lisa
10092: PPUSH
10093: CALL_OW 88
// if Bobby then
10097: LD_EXP 11
10101: IFFALSE 10115
// Say ( Bobby , D3b-Bobby-3 ) ;
10103: LD_EXP 11
10107: PPUSH
10108: LD_STRING D3b-Bobby-3
10110: PPUSH
10111: CALL_OW 88
// if Cyrus then
10115: LD_EXP 12
10119: IFFALSE 10133
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10121: LD_EXP 12
10125: PPUSH
10126: LD_STRING D3b-Cyrus-3
10128: PPUSH
10129: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10133: LD_EXP 14
10137: PUSH
10138: LD_EXP 14
10142: PPUSH
10143: CALL_OW 255
10147: PUSH
10148: LD_INT 1
10150: EQUAL
10151: AND
10152: IFFALSE 10166
// Say ( Frank , D3b-Frank-3 ) ;
10154: LD_EXP 14
10158: PPUSH
10159: LD_STRING D3b-Frank-3
10161: PPUSH
10162: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10166: LD_EXP 17
10170: PUSH
10171: LD_EXP 17
10175: PPUSH
10176: CALL_OW 255
10180: PUSH
10181: LD_INT 1
10183: EQUAL
10184: AND
10185: IFFALSE 10199
// Say ( Kikuchi , D3b-Yam-4 ) ;
10187: LD_EXP 17
10191: PPUSH
10192: LD_STRING D3b-Yam-4
10194: PPUSH
10195: CALL_OW 88
// end ;
10199: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10200: LD_EXP 5
10204: PUSH
10205: LD_INT 2
10207: ARRAY
10208: PUSH
10209: LD_OWVAR 1
10213: LESS
10214: IFFALSE 10246
10216: GO 10218
10218: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10219: LD_EXP 18
10223: PPUSH
10224: LD_STRING D4-Har-1
10226: PPUSH
10227: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10231: LD_STRING M3
10233: PPUSH
10234: CALL_OW 337
// must_end := true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// end ;
10246: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10247: LD_EXP 5
10251: PUSH
10252: LD_INT 3
10254: ARRAY
10255: PUSH
10256: LD_OWVAR 1
10260: LESS
10261: IFFALSE 10292
10263: GO 10265
10265: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10266: LD_INT 16
10268: PPUSH
10269: CALL_OW 301
10273: NOT
10274: IFFALSE 10285
// YouLost ( TimeOut1 ) else
10276: LD_STRING TimeOut1
10278: PPUSH
10279: CALL_OW 104
10283: GO 10292
// YouLost ( TimeOut2 ) ;
10285: LD_STRING TimeOut2
10287: PPUSH
10288: CALL_OW 104
// end ;
10292: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
10293: LD_EXP 8
10297: PPUSH
10298: LD_INT 9
10300: PPUSH
10301: CALL_OW 308
10305: PUSH
10306: LD_EXP 6
10310: AND
10311: IFFALSE 11305
10313: GO 10315
10315: DISABLE
10316: LD_INT 0
10318: PPUSH
10319: PPUSH
10320: PPUSH
// begin wait_on := false ;
10321: LD_ADDR_VAR 0 1
10325: PUSH
10326: LD_INT 0
10328: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10329: LD_INT 1
10331: PPUSH
10332: CALL 2605 0 1
10336: PUSH
10337: LD_INT 0
10339: PLUS
10340: PUSH
10341: LD_INT 1
10343: PPUSH
10344: LD_INT 9
10346: PPUSH
10347: CALL 2696 0 2
10351: PUSH
10352: LD_INT 1
10354: PPUSH
10355: LD_INT 9
10357: PPUSH
10358: CALL 2743 0 2
10362: ADD
10363: PUSH
10364: LD_INT 0
10366: PLUS
10367: GREATER
10368: IFFALSE 10417
// case Query ( Q1 ) of 1 :
10370: LD_STRING Q1
10372: PPUSH
10373: CALL_OW 97
10377: PUSH
10378: LD_INT 1
10380: DOUBLE
10381: EQUAL
10382: IFTRUE 10386
10384: GO 10397
10386: POP
// wait_on := true ; 2 :
10387: LD_ADDR_VAR 0 1
10391: PUSH
10392: LD_INT 1
10394: ST_TO_ADDR
10395: GO 10417
10397: LD_INT 2
10399: DOUBLE
10400: EQUAL
10401: IFTRUE 10405
10403: GO 10416
10405: POP
// wait_on := false ; end ;
10406: LD_ADDR_VAR 0 1
10410: PUSH
10411: LD_INT 0
10413: ST_TO_ADDR
10414: GO 10417
10416: POP
// repeat wait ( 0 0$01 ) ;
10417: LD_INT 35
10419: PPUSH
10420: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10424: LD_VAR 0 1
10428: NOT
10429: PUSH
10430: LD_INT 1
10432: PPUSH
10433: CALL 2605 0 1
10437: PUSH
10438: LD_INT 0
10440: PLUS
10441: PUSH
10442: LD_INT 1
10444: PPUSH
10445: LD_INT 9
10447: PPUSH
10448: CALL 2696 0 2
10452: PUSH
10453: LD_INT 1
10455: PPUSH
10456: LD_INT 9
10458: PPUSH
10459: CALL 2743 0 2
10463: ADD
10464: PUSH
10465: LD_INT 0
10467: PLUS
10468: EQUAL
10469: OR
10470: IFFALSE 10417
// DialogueOn ;
10472: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10476: LD_EXP 8
10480: PPUSH
10481: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10485: LD_EXP 8
10489: PPUSH
10490: LD_STRING D6-JMM-1
10492: PPUSH
10493: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10497: LD_EXP 18
10501: PPUSH
10502: LD_STRING D6-Har-1
10504: PPUSH
10505: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10509: LD_EXP 8
10513: PPUSH
10514: LD_STRING D6-JMM-2
10516: PPUSH
10517: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10521: LD_EXP 18
10525: PPUSH
10526: LD_STRING D6-Har-2
10528: PPUSH
10529: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10533: LD_EXP 8
10537: PPUSH
10538: LD_STRING D6-JMM-3
10540: PPUSH
10541: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10545: LD_EXP 18
10549: PPUSH
10550: LD_STRING D6-Har-3
10552: PPUSH
10553: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10557: LD_EXP 8
10561: PPUSH
10562: LD_STRING D6-JMM-4
10564: PPUSH
10565: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10569: LD_EXP 18
10573: PPUSH
10574: LD_STRING D6-Har-4
10576: PPUSH
10577: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10581: LD_EXP 8
10585: PPUSH
10586: LD_STRING D6-JMM-5
10588: PPUSH
10589: CALL_OW 88
// DialogueOff ;
10593: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
10597: LD_ADDR_VAR 0 3
10601: PUSH
10602: LD_INT 3
10604: PPUSH
10605: CALL 2874 0 1
10609: ST_TO_ADDR
// if tmp >= 35 then
10610: LD_VAR 0 3
10614: PUSH
10615: LD_INT 35
10617: GREATEREQUAL
10618: IFFALSE 10655
// begin AddMedal ( Destroy1 , - 1 ) ;
10620: LD_STRING Destroy1
10622: PPUSH
10623: LD_INT 1
10625: NEG
10626: PPUSH
10627: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10631: LD_STRING Destroy2
10633: PPUSH
10634: LD_INT 1
10636: NEG
10637: PPUSH
10638: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10642: LD_STRING Destroy3
10644: PPUSH
10645: LD_INT 1
10647: NEG
10648: PPUSH
10649: CALL_OW 101
// end else
10653: GO 10742
// begin AddMedal ( Destroy1 , 1 ) ;
10655: LD_STRING Destroy1
10657: PPUSH
10658: LD_INT 1
10660: PPUSH
10661: CALL_OW 101
// if tmp >= 25 then
10665: LD_VAR 0 3
10669: PUSH
10670: LD_INT 25
10672: GREATEREQUAL
10673: IFFALSE 10699
// begin AddMedal ( Destroy2 , - 1 ) ;
10675: LD_STRING Destroy2
10677: PPUSH
10678: LD_INT 1
10680: NEG
10681: PPUSH
10682: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10686: LD_STRING Destroy3
10688: PPUSH
10689: LD_INT 1
10691: NEG
10692: PPUSH
10693: CALL_OW 101
// end else
10697: GO 10742
// begin AddMedal ( Destroy2 , 1 ) ;
10699: LD_STRING Destroy2
10701: PPUSH
10702: LD_INT 1
10704: PPUSH
10705: CALL_OW 101
// if tmp >= 15 then
10709: LD_VAR 0 3
10713: PUSH
10714: LD_INT 15
10716: GREATEREQUAL
10717: IFFALSE 10732
// AddMedal ( Destroy3 , - 1 ) else
10719: LD_STRING Destroy3
10721: PPUSH
10722: LD_INT 1
10724: NEG
10725: PPUSH
10726: CALL_OW 101
10730: GO 10742
// AddMedal ( Destroy3 , 1 ) ;
10732: LD_STRING Destroy3
10734: PPUSH
10735: LD_INT 1
10737: PPUSH
10738: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
10742: LD_STRING MAIN
10744: PPUSH
10745: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
10749: LD_ADDR_VAR 0 3
10753: PUSH
10754: LD_INT 1
10756: PPUSH
10757: LD_INT 9
10759: PPUSH
10760: CALL 2696 0 2
10764: PUSH
10765: LD_INT 1
10767: PPUSH
10768: LD_INT 9
10770: PPUSH
10771: CALL 2743 0 2
10775: UNION
10776: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10777: LD_VAR 0 3
10781: PPUSH
10782: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10786: LD_EXP 8
10790: PPUSH
10791: LD_EXP 3
10795: PUSH
10796: LD_STRING JMM
10798: STR
10799: PPUSH
10800: CALL_OW 38
// if Brown in tmp then
10804: LD_EXP 9
10808: PUSH
10809: LD_VAR 0 3
10813: IN
10814: IFFALSE 10834
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
10816: LD_EXP 9
10820: PPUSH
10821: LD_EXP 3
10825: PUSH
10826: LD_STRING Brown
10828: STR
10829: PPUSH
10830: CALL_OW 38
// if Donaldson in tmp then
10834: LD_EXP 10
10838: PUSH
10839: LD_VAR 0 3
10843: IN
10844: IFFALSE 10864
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
10846: LD_EXP 10
10850: PPUSH
10851: LD_EXP 3
10855: PUSH
10856: LD_STRING Donaldson
10858: STR
10859: PPUSH
10860: CALL_OW 38
// if Bobby in tmp then
10864: LD_EXP 11
10868: PUSH
10869: LD_VAR 0 3
10873: IN
10874: IFFALSE 10894
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10876: LD_EXP 11
10880: PPUSH
10881: LD_EXP 3
10885: PUSH
10886: LD_STRING Bobby
10888: STR
10889: PPUSH
10890: CALL_OW 38
// if Cyrus in tmp then
10894: LD_EXP 12
10898: PUSH
10899: LD_VAR 0 3
10903: IN
10904: IFFALSE 10924
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10906: LD_EXP 12
10910: PPUSH
10911: LD_EXP 3
10915: PUSH
10916: LD_STRING Cyrus
10918: STR
10919: PPUSH
10920: CALL_OW 38
// if Lisa in tmp then
10924: LD_EXP 13
10928: PUSH
10929: LD_VAR 0 3
10933: IN
10934: IFFALSE 10954
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
10936: LD_EXP 13
10940: PPUSH
10941: LD_EXP 3
10945: PUSH
10946: LD_STRING Lisa
10948: STR
10949: PPUSH
10950: CALL_OW 38
// if Frank in tmp then
10954: LD_EXP 14
10958: PUSH
10959: LD_VAR 0 3
10963: IN
10964: IFFALSE 10984
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
10966: LD_EXP 14
10970: PPUSH
10971: LD_EXP 3
10975: PUSH
10976: LD_STRING Frank
10978: STR
10979: PPUSH
10980: CALL_OW 38
// if Gladstone in tmp then
10984: LD_EXP 15
10988: PUSH
10989: LD_VAR 0 3
10993: IN
10994: IFFALSE 11014
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
10996: LD_EXP 15
11000: PPUSH
11001: LD_EXP 3
11005: PUSH
11006: LD_STRING Gladstone
11008: STR
11009: PPUSH
11010: CALL_OW 38
// if Khatam in tmp then
11014: LD_EXP 16
11018: PUSH
11019: LD_VAR 0 3
11023: IN
11024: IFFALSE 11044
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11026: LD_EXP 16
11030: PPUSH
11031: LD_EXP 3
11035: PUSH
11036: LD_STRING Khatam
11038: STR
11039: PPUSH
11040: CALL_OW 38
// if Kikuchi in tmp then
11044: LD_EXP 17
11048: PUSH
11049: LD_VAR 0 3
11053: IN
11054: IFFALSE 11074
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11056: LD_EXP 17
11060: PPUSH
11061: LD_EXP 3
11065: PUSH
11066: LD_STRING Kikuchi
11068: STR
11069: PPUSH
11070: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11074: LD_VAR 0 3
11078: PUSH
11079: LD_EXP 8
11083: PUSH
11084: LD_EXP 9
11088: PUSH
11089: LD_EXP 10
11093: PUSH
11094: LD_EXP 11
11098: PUSH
11099: LD_EXP 12
11103: PUSH
11104: LD_EXP 13
11108: PUSH
11109: LD_EXP 14
11113: PUSH
11114: LD_EXP 15
11118: PUSH
11119: LD_EXP 17
11123: PUSH
11124: LD_EXP 16
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: LIST
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: DIFF
11141: PPUSH
11142: LD_EXP 3
11146: PUSH
11147: LD_STRING others
11149: STR
11150: PPUSH
11151: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11155: LD_OWVAR 1
11159: PPUSH
11160: LD_STRING 07_time
11162: PPUSH
11163: CALL_OW 39
// tmp := [ ] ;
11167: LD_ADDR_VAR 0 3
11171: PUSH
11172: EMPTY
11173: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11174: LD_ADDR_VAR 0 2
11178: PUSH
11179: LD_INT 9
11181: PPUSH
11182: LD_INT 22
11184: PUSH
11185: LD_INT 1
11187: PUSH
11188: EMPTY
11189: LIST
11190: LIST
11191: PUSH
11192: LD_INT 23
11194: PUSH
11195: LD_INT 1
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: PUSH
11202: LD_INT 21
11204: PUSH
11205: LD_INT 2
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: PUSH
11217: EMPTY
11218: LIST
11219: PPUSH
11220: CALL_OW 70
11224: PUSH
11225: FOR_IN
11226: IFFALSE 11287
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11228: LD_ADDR_VAR 0 3
11232: PUSH
11233: LD_VAR 0 3
11237: PUSH
11238: LD_VAR 0 2
11242: PPUSH
11243: CALL_OW 265
11247: PUSH
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 262
11257: PUSH
11258: LD_VAR 0 2
11262: PPUSH
11263: CALL_OW 263
11267: PUSH
11268: LD_VAR 0 2
11272: PPUSH
11273: CALL_OW 264
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: ADD
11284: ST_TO_ADDR
11285: GO 11225
11287: POP
11288: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11289: LD_VAR 0 3
11293: PPUSH
11294: LD_STRING 07_vehicles
11296: PPUSH
11297: CALL_OW 39
// YouWin ;
11301: CALL_OW 103
// end ; end_of_file
11305: PPOPN 3
11307: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11308: LD_VAR 0 1
11312: PUSH
11313: LD_EXP 8
11317: EQUAL
11318: IFFALSE 11327
// YouLost ( JMM ) ;
11320: LD_STRING JMM
11322: PPUSH
11323: CALL_OW 104
// if GetType ( un ) = unit_building then
11327: LD_VAR 0 1
11331: PPUSH
11332: CALL_OW 247
11336: PUSH
11337: LD_INT 3
11339: EQUAL
11340: IFFALSE 11356
// buildings_counter := buildings_counter + 1 ;
11342: LD_ADDR_EXP 4
11346: PUSH
11347: LD_EXP 4
11351: PUSH
11352: LD_INT 1
11354: PLUS
11355: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11356: LD_VAR 0 1
11360: PUSH
11361: LD_INT 6
11363: PPUSH
11364: LD_INT 2
11366: PUSH
11367: LD_INT 30
11369: PUSH
11370: LD_INT 33
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: PUSH
11377: LD_INT 30
11379: PUSH
11380: LD_INT 32
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: PUSH
11387: EMPTY
11388: LIST
11389: LIST
11390: LIST
11391: PPUSH
11392: CALL_OW 70
11396: IN
11397: IFFALSE 11456
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11399: LD_ADDR_EXP 19
11403: PUSH
11404: LD_EXP 19
11408: PUSH
11409: LD_VAR 0 1
11413: PPUSH
11414: CALL_OW 266
11418: PUSH
11419: LD_VAR 0 1
11423: PPUSH
11424: CALL_OW 250
11428: PUSH
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 251
11438: PUSH
11439: LD_VAR 0 1
11443: PPUSH
11444: CALL_OW 254
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: ADD
11455: ST_TO_ADDR
// if un = ru_dep_main then
11456: LD_VAR 0 1
11460: PUSH
11461: LD_INT 16
11463: EQUAL
11464: IFFALSE 11473
// ChangeMissionObjectives ( M1a ) ;
11466: LD_STRING M1a
11468: PPUSH
11469: CALL_OW 337
// end ;
11473: PPOPN 1
11475: END
// on BuildingStarted ( b , builder ) do var i ;
11476: LD_INT 0
11478: PPUSH
// begin if GetSide ( b ) = 3 then
11479: LD_VAR 0 1
11483: PPUSH
11484: CALL_OW 255
11488: PUSH
11489: LD_INT 3
11491: EQUAL
11492: IFFALSE 11532
// for i = 1 to 4 do
11494: LD_ADDR_VAR 0 3
11498: PUSH
11499: DOUBLE
11500: LD_INT 1
11502: DEC
11503: ST_TO_ADDR
11504: LD_INT 4
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11530
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11510: LD_ADDR_EXP 19
11514: PUSH
11515: LD_EXP 19
11519: PPUSH
11520: LD_INT 1
11522: PPUSH
11523: CALL_OW 3
11527: ST_TO_ADDR
11528: GO 11507
11530: POP
11531: POP
// end ;
11532: PPOPN 3
11534: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11535: LD_VAR 0 1
11539: PPUSH
11540: CALL_OW 266
11544: PUSH
11545: LD_INT 32
11547: PUSH
11548: LD_INT 33
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: IN
11555: IFFALSE 11569
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11557: LD_VAR 0 1
11561: PPUSH
11562: LD_INT 43
11564: PPUSH
11565: CALL_OW 148
11569: PPOPN 1
11571: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11572: LD_VAR 0 1
11576: PUSH
11577: LD_INT 22
11579: PUSH
11580: LD_INT 3
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 2
11589: PUSH
11590: LD_INT 30
11592: PUSH
11593: LD_INT 31
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PUSH
11600: LD_INT 30
11602: PUSH
11603: LD_INT 32
11605: PUSH
11606: EMPTY
11607: LIST
11608: LIST
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: LIST
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PPUSH
11619: CALL_OW 69
11623: IN
11624: IFFALSE 11646
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11626: LD_VAR 0 2
11630: PPUSH
11631: LD_VAR 0 1
11635: PPUSH
11636: LD_INT 143
11638: PPUSH
11639: LD_INT 143
11641: PPUSH
11642: CALL 2055 0 4
// end ;
11646: PPOPN 2
11648: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11649: LD_VAR 0 1
11653: PUSH
11654: LD_INT 22
11656: PUSH
11657: LD_INT 3
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: PUSH
11664: LD_INT 30
11666: PUSH
11667: LD_INT 32
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PPUSH
11678: CALL_OW 69
11682: IN
11683: IFFALSE 11697
// SetTag ( b , 0 ) ;
11685: LD_VAR 0 1
11689: PPUSH
11690: LD_INT 0
11692: PPUSH
11693: CALL_OW 109
// end ;
11697: PPOPN 2
11699: END
