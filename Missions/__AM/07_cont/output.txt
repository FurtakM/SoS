// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 44 0 0
// DebugMode ;
  12: CALL 245 0 0
// AnimateTrees ( true ) ;
  16: LD_INT 1
  18: PPUSH
  19: CALL_OW 573
// PrepareNature ;
  23: CALL 2929 0 0
// PrepareRussians ;
  27: CALL 4670 0 0
// PrepareAmericans ;
  31: CALL 3586 0 0
// Action ;
  35: CALL 8433 0 0
// SaveForQuickRestart ;
  39: CALL_OW 22
// end ;
  43: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  44: LD_INT 0
  46: PPUSH
// debug := false ;
  47: LD_ADDR_EXP 1
  51: PUSH
  52: LD_INT 0
  54: ST_TO_ADDR
// mission_prefix := 07c_ ;
  55: LD_ADDR_EXP 3
  59: PUSH
  60: LD_STRING 07c_
  62: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  63: LD_ADDR_EXP 2
  67: PUSH
  68: LD_STRING 07_
  70: ST_TO_ADDR
// buildings_counter := 0 ;
  71: LD_ADDR_EXP 4
  75: PUSH
  76: LD_INT 0
  78: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  79: LD_ADDR_EXP 5
  83: PUSH
  84: LD_INT 67200
  86: PUSH
  87: LD_INT 60900
  89: PUSH
  90: LD_INT 54600
  92: PUSH
  93: EMPTY
  94: LIST
  95: LIST
  96: LIST
  97: PUSH
  98: LD_OWVAR 67
 102: ARRAY
 103: PUSH
 104: LD_INT 79800
 106: PUSH
 107: LD_INT 73500
 109: PUSH
 110: LD_INT 67200
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PUSH
 124: LD_INT 92400
 126: PUSH
 127: LD_INT 86100
 129: PUSH
 130: LD_INT 79800
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: PUSH
 138: LD_OWVAR 67
 142: ARRAY
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// can_end := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// must_end := false ;
 157: LD_ADDR_EXP 7
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// end ;
 165: LD_VAR 0 1
 169: RET
// every 0 0$01 trigger not debug do
 170: LD_EXP 1
 174: NOT
 175: IFFALSE 244
 177: GO 179
 179: DISABLE
// begin enable ;
 180: ENABLE
// if not must_end then
 181: LD_EXP 7
 185: NOT
 186: IFFALSE 207
// display_strings := [ #Am07-1 , tick ] else
 188: LD_ADDR_OWVAR 47
 192: PUSH
 193: LD_STRING #Am07-1
 195: PUSH
 196: LD_OWVAR 1
 200: PUSH
 201: EMPTY
 202: LIST
 203: LIST
 204: ST_TO_ADDR
 205: GO 244
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 207: LD_ADDR_OWVAR 47
 211: PUSH
 212: LD_STRING #Am07-1
 214: PUSH
 215: LD_OWVAR 1
 219: PUSH
 220: LD_STRING #Am07-2
 222: PUSH
 223: LD_EXP 5
 227: PUSH
 228: LD_INT 3
 230: ARRAY
 231: PUSH
 232: LD_OWVAR 1
 236: MINUS
 237: PUSH
 238: EMPTY
 239: LIST
 240: LIST
 241: LIST
 242: LIST
 243: ST_TO_ADDR
// end ;
 244: END
// function DebugMode ; var i ; begin
 245: LD_INT 0
 247: PPUSH
 248: PPUSH
// if not debug then
 249: LD_EXP 1
 253: NOT
 254: IFFALSE 258
// exit ;
 256: GO 265
// FogOff ( 1 ) ;
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 344
// end ;
 265: LD_VAR 0 1
 269: RET
// every 3 trigger debug do var i , filter ;
 270: LD_EXP 1
 274: IFFALSE 363
 276: GO 278
 278: DISABLE
 279: LD_INT 0
 281: PPUSH
 282: PPUSH
// begin enable ;
 283: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 284: LD_ADDR_VAR 0 2
 288: PUSH
 289: LD_INT 22
 291: PUSH
 292: LD_INT 1
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: PUSH
 299: LD_INT 3
 301: PUSH
 302: LD_INT 24
 304: PUSH
 305: LD_INT 500
 307: PUSH
 308: EMPTY
 309: LIST
 310: LIST
 311: PUSH
 312: EMPTY
 313: LIST
 314: LIST
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: PPUSH
 320: CALL_OW 69
 324: ST_TO_ADDR
// if not filter then
 325: LD_VAR 0 2
 329: NOT
 330: IFFALSE 334
// exit ;
 332: GO 363
// for i in filter do
 334: LD_ADDR_VAR 0 1
 338: PUSH
 339: LD_VAR 0 2
 343: PUSH
 344: FOR_IN
 345: IFFALSE 361
// SetLives ( i , 1000 ) ;
 347: LD_VAR 0 1
 351: PPUSH
 352: LD_INT 1000
 354: PPUSH
 355: CALL_OW 234
 359: GO 344
 361: POP
 362: POP
// end ; end_of_file
 363: PPOPN 2
 365: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 366: LD_INT 0
 368: PPUSH
 369: PPUSH
// if exist_mode then
 370: LD_VAR 0 2
 374: IFFALSE 399
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 376: LD_ADDR_VAR 0 4
 380: PUSH
 381: LD_EXP 2
 385: PUSH
 386: LD_VAR 0 1
 390: STR
 391: PPUSH
 392: CALL_OW 34
 396: ST_TO_ADDR
 397: GO 414
// unit := NewCharacter ( ident ) ;
 399: LD_ADDR_VAR 0 4
 403: PUSH
 404: LD_VAR 0 1
 408: PPUSH
 409: CALL_OW 25
 413: ST_TO_ADDR
// result := unit ;
 414: LD_ADDR_VAR 0 3
 418: PUSH
 419: LD_VAR 0 4
 423: ST_TO_ADDR
// end ;
 424: LD_VAR 0 3
 428: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 429: LD_INT 0
 431: PPUSH
// uc_side := side ;
 432: LD_ADDR_OWVAR 20
 436: PUSH
 437: LD_VAR 0 1
 441: ST_TO_ADDR
// uc_nation := nation ;
 442: LD_ADDR_OWVAR 21
 446: PUSH
 447: LD_VAR 0 2
 451: ST_TO_ADDR
// vc_chassis := chassis ;
 452: LD_ADDR_OWVAR 37
 456: PUSH
 457: LD_VAR 0 3
 461: ST_TO_ADDR
// vc_engine := engine ;
 462: LD_ADDR_OWVAR 39
 466: PUSH
 467: LD_VAR 0 4
 471: ST_TO_ADDR
// vc_control := control ;
 472: LD_ADDR_OWVAR 38
 476: PUSH
 477: LD_VAR 0 5
 481: ST_TO_ADDR
// vc_weapon := weapon ;
 482: LD_ADDR_OWVAR 40
 486: PUSH
 487: LD_VAR 0 6
 491: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 492: LD_ADDR_OWVAR 41
 496: PUSH
 497: LD_VAR 0 7
 501: ST_TO_ADDR
// result := CreateVehicle ;
 502: LD_ADDR_VAR 0 8
 506: PUSH
 507: CALL_OW 45
 511: ST_TO_ADDR
// end ;
 512: LD_VAR 0 8
 516: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 517: LD_INT 0
 519: PPUSH
 520: PPUSH
 521: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_INT 22
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: LD_INT 21
 539: PUSH
 540: LD_INT 1
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 50
 549: PUSH
 550: EMPTY
 551: LIST
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL_OW 69
 562: PUSH
 563: LD_EXP 8
 567: PUSH
 568: LD_EXP 9
 572: PUSH
 573: LD_EXP 10
 577: PUSH
 578: LD_EXP 11
 582: PUSH
 583: LD_EXP 12
 587: PUSH
 588: LD_EXP 13
 592: PUSH
 593: LD_EXP 14
 597: PUSH
 598: LD_EXP 15
 602: PUSH
 603: LD_EXP 17
 607: PUSH
 608: LD_EXP 16
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: DIFF
 625: ST_TO_ADDR
// if not filter then
 626: LD_VAR 0 4
 630: NOT
 631: IFFALSE 635
// exit ;
 633: GO 662
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 635: LD_ADDR_VAR 0 2
 639: PUSH
 640: LD_VAR 0 4
 644: PPUSH
 645: LD_INT 26
 647: PUSH
 648: LD_VAR 0 1
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PPUSH
 657: CALL_OW 72
 661: ST_TO_ADDR
// end ;
 662: LD_VAR 0 2
 666: RET
// export function SayX ( units , ident ) ; var i ; begin
 667: LD_INT 0
 669: PPUSH
 670: PPUSH
// result := false ;
 671: LD_ADDR_VAR 0 3
 675: PUSH
 676: LD_INT 0
 678: ST_TO_ADDR
// if not units then
 679: LD_VAR 0 1
 683: NOT
 684: IFFALSE 688
// exit ;
 686: GO 742
// for i in units do
 688: LD_ADDR_VAR 0 4
 692: PUSH
 693: LD_VAR 0 1
 697: PUSH
 698: FOR_IN
 699: IFFALSE 740
// if IsOk ( i ) then
 701: LD_VAR 0 4
 705: PPUSH
 706: CALL_OW 302
 710: IFFALSE 738
// begin Say ( i , ident ) ;
 712: LD_VAR 0 4
 716: PPUSH
 717: LD_VAR 0 2
 721: PPUSH
 722: CALL_OW 88
// result := i ;
 726: LD_ADDR_VAR 0 3
 730: PUSH
 731: LD_VAR 0 4
 735: ST_TO_ADDR
// break ;
 736: GO 740
// end ;
 738: GO 698
 740: POP
 741: POP
// end ;
 742: LD_VAR 0 3
 746: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 747: LD_INT 0
 749: PPUSH
 750: PPUSH
 751: PPUSH
// result := [ ] ;
 752: LD_ADDR_VAR 0 2
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 759: LD_ADDR_VAR 0 3
 763: PUSH
 764: LD_INT 21
 766: PUSH
 767: LD_INT 3
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: PPUSH
 774: CALL_OW 69
 778: ST_TO_ADDR
// if not tmp then
 779: LD_VAR 0 3
 783: NOT
 784: IFFALSE 788
// exit ;
 786: GO 838
// for i in tmp do
 788: LD_ADDR_VAR 0 4
 792: PUSH
 793: LD_VAR 0 3
 797: PUSH
 798: FOR_IN
 799: IFFALSE 836
// if GetBase ( i ) = base then
 801: LD_VAR 0 4
 805: PPUSH
 806: CALL_OW 274
 810: PUSH
 811: LD_VAR 0 1
 815: EQUAL
 816: IFFALSE 834
// result := result ^ i ;
 818: LD_ADDR_VAR 0 2
 822: PUSH
 823: LD_VAR 0 2
 827: PUSH
 828: LD_VAR 0 4
 832: ADD
 833: ST_TO_ADDR
 834: GO 798
 836: POP
 837: POP
// end ;
 838: LD_VAR 0 2
 842: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 843: LD_INT 0
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
 852: PPUSH
 853: PPUSH
 854: PPUSH
 855: PPUSH
 856: PPUSH
 857: PPUSH
 858: PPUSH
 859: PPUSH
 860: PPUSH
// result := false ;
 861: LD_ADDR_VAR 0 2
 865: PUSH
 866: LD_INT 0
 868: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 869: LD_VAR 0 1
 873: NOT
 874: PUSH
 875: LD_VAR 0 1
 879: PPUSH
 880: CALL_OW 266
 884: PUSH
 885: LD_INT 32
 887: PUSH
 888: LD_INT 33
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: IN
 895: NOT
 896: OR
 897: IFFALSE 901
// exit ;
 899: GO 2061
// nat := GetNation ( tower ) ;
 901: LD_ADDR_VAR 0 11
 905: PUSH
 906: LD_VAR 0 1
 910: PPUSH
 911: CALL_OW 248
 915: ST_TO_ADDR
// side := GetSide ( tower ) ;
 916: LD_ADDR_VAR 0 15
 920: PUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 255
 930: ST_TO_ADDR
// x := GetX ( tower ) ;
 931: LD_ADDR_VAR 0 9
 935: PUSH
 936: LD_VAR 0 1
 940: PPUSH
 941: CALL_OW 250
 945: ST_TO_ADDR
// y := GetY ( tower ) ;
 946: LD_ADDR_VAR 0 10
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: CALL_OW 251
 960: ST_TO_ADDR
// if not x or not y then
 961: LD_VAR 0 9
 965: NOT
 966: PUSH
 967: LD_VAR 0 10
 971: NOT
 972: OR
 973: IFFALSE 977
// exit ;
 975: GO 2061
// weapon := 0 ;
 977: LD_ADDR_VAR 0 17
 981: PUSH
 982: LD_INT 0
 984: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 985: LD_ADDR_VAR 0 16
 989: PUSH
 990: LD_INT 42
 992: PUSH
 993: LD_INT 43
 995: PUSH
 996: LD_INT 44
 998: PUSH
 999: LD_INT 46
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: ST_TO_ADDR
// if not fac_list then
1008: LD_VAR 0 16
1012: NOT
1013: IFFALSE 1017
// exit ;
1015: GO 2061
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1017: LD_ADDR_VAR 0 4
1021: PUSH
1022: LD_INT 4
1024: PUSH
1025: LD_INT 5
1027: PUSH
1028: LD_INT 9
1030: PUSH
1031: LD_INT 10
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: LD_INT 7
1039: PUSH
1040: LD_INT 11
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: PUSH
1052: LD_INT 27
1054: PUSH
1055: LD_INT 28
1057: PUSH
1058: LD_INT 26
1060: PUSH
1061: LD_INT 30
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_INT 43
1072: PUSH
1073: LD_INT 44
1075: PUSH
1076: LD_INT 46
1078: PUSH
1079: LD_INT 45
1081: PUSH
1082: LD_INT 47
1084: PUSH
1085: LD_INT 49
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_VAR 0 11
1105: ARRAY
1106: ST_TO_ADDR
// for i in list do
1107: LD_ADDR_VAR 0 7
1111: PUSH
1112: LD_VAR 0 4
1116: PUSH
1117: FOR_IN
1118: IFFALSE 1151
// if not i in fac_list then
1120: LD_VAR 0 7
1124: PUSH
1125: LD_VAR 0 16
1129: IN
1130: NOT
1131: IFFALSE 1149
// list := list diff i ;
1133: LD_ADDR_VAR 0 4
1137: PUSH
1138: LD_VAR 0 4
1142: PUSH
1143: LD_VAR 0 7
1147: DIFF
1148: ST_TO_ADDR
1149: GO 1117
1151: POP
1152: POP
// if not list then
1153: LD_VAR 0 4
1157: NOT
1158: IFFALSE 1162
// exit ;
1160: GO 2061
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1162: LD_VAR 0 11
1166: PUSH
1167: LD_INT 3
1169: EQUAL
1170: PUSH
1171: LD_INT 49
1173: PUSH
1174: LD_VAR 0 4
1178: IN
1179: AND
1180: PUSH
1181: LD_INT 31
1183: PPUSH
1184: LD_VAR 0 15
1188: PPUSH
1189: CALL_OW 321
1193: PUSH
1194: LD_INT 2
1196: EQUAL
1197: AND
1198: IFFALSE 1258
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1200: LD_INT 22
1202: PUSH
1203: LD_VAR 0 15
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 35
1214: PUSH
1215: LD_INT 49
1217: PUSH
1218: EMPTY
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 91
1224: PUSH
1225: LD_VAR 0 1
1229: PUSH
1230: LD_INT 10
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: LIST
1237: PUSH
1238: EMPTY
1239: LIST
1240: LIST
1241: LIST
1242: PPUSH
1243: CALL_OW 69
1247: NOT
1248: IFFALSE 1258
// weapon := ru_time_lapser ;
1250: LD_ADDR_VAR 0 17
1254: PUSH
1255: LD_INT 49
1257: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1258: LD_VAR 0 11
1262: PUSH
1263: LD_INT 1
1265: PUSH
1266: LD_INT 2
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: IN
1273: PUSH
1274: LD_INT 11
1276: PUSH
1277: LD_VAR 0 4
1281: IN
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_VAR 0 4
1290: IN
1291: OR
1292: AND
1293: PUSH
1294: LD_INT 6
1296: PPUSH
1297: LD_VAR 0 15
1301: PPUSH
1302: CALL_OW 321
1306: PUSH
1307: LD_INT 2
1309: EQUAL
1310: AND
1311: IFFALSE 1476
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1313: LD_INT 22
1315: PUSH
1316: LD_VAR 0 15
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 2
1327: PUSH
1328: LD_INT 35
1330: PUSH
1331: LD_INT 11
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 35
1340: PUSH
1341: LD_INT 30
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 91
1355: PUSH
1356: LD_VAR 0 1
1360: PUSH
1361: LD_INT 18
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL_OW 69
1378: NOT
1379: PUSH
1380: LD_INT 22
1382: PUSH
1383: LD_VAR 0 15
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: PUSH
1392: LD_INT 2
1394: PUSH
1395: LD_INT 30
1397: PUSH
1398: LD_INT 32
1400: PUSH
1401: EMPTY
1402: LIST
1403: LIST
1404: PUSH
1405: LD_INT 30
1407: PUSH
1408: LD_INT 33
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: LIST
1419: PUSH
1420: LD_INT 91
1422: PUSH
1423: LD_VAR 0 1
1427: PUSH
1428: LD_INT 12
1430: PUSH
1431: EMPTY
1432: LIST
1433: LIST
1434: LIST
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: PUSH
1441: EMPTY
1442: LIST
1443: PPUSH
1444: CALL_OW 69
1448: PUSH
1449: LD_INT 2
1451: GREATER
1452: AND
1453: IFFALSE 1476
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1455: LD_ADDR_VAR 0 17
1459: PUSH
1460: LD_INT 11
1462: PUSH
1463: LD_INT 30
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PUSH
1470: LD_VAR 0 11
1474: ARRAY
1475: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1476: LD_VAR 0 17
1480: NOT
1481: PUSH
1482: LD_INT 40
1484: PPUSH
1485: LD_VAR 0 15
1489: PPUSH
1490: CALL_OW 321
1494: PUSH
1495: LD_INT 2
1497: EQUAL
1498: AND
1499: PUSH
1500: LD_INT 7
1502: PUSH
1503: LD_VAR 0 4
1507: IN
1508: PUSH
1509: LD_INT 28
1511: PUSH
1512: LD_VAR 0 4
1516: IN
1517: OR
1518: PUSH
1519: LD_INT 45
1521: PUSH
1522: LD_VAR 0 4
1526: IN
1527: OR
1528: AND
1529: IFFALSE 1783
// begin hex := GetHexInfo ( x , y ) ;
1531: LD_ADDR_VAR 0 3
1535: PUSH
1536: LD_VAR 0 9
1540: PPUSH
1541: LD_VAR 0 10
1545: PPUSH
1546: CALL_OW 546
1550: ST_TO_ADDR
// if hex [ 1 ] then
1551: LD_VAR 0 3
1555: PUSH
1556: LD_INT 1
1558: ARRAY
1559: IFFALSE 1563
// exit ;
1561: GO 2061
// height := hex [ 2 ] ;
1563: LD_ADDR_VAR 0 14
1567: PUSH
1568: LD_VAR 0 3
1572: PUSH
1573: LD_INT 2
1575: ARRAY
1576: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1577: LD_ADDR_VAR 0 13
1581: PUSH
1582: LD_INT 0
1584: PUSH
1585: LD_INT 2
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 5
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: ST_TO_ADDR
// for i in tmp do
1600: LD_ADDR_VAR 0 7
1604: PUSH
1605: LD_VAR 0 13
1609: PUSH
1610: FOR_IN
1611: IFFALSE 1781
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1613: LD_ADDR_VAR 0 8
1617: PUSH
1618: LD_VAR 0 9
1622: PPUSH
1623: LD_VAR 0 7
1627: PPUSH
1628: LD_INT 5
1630: PPUSH
1631: CALL_OW 272
1635: PUSH
1636: LD_VAR 0 10
1640: PPUSH
1641: LD_VAR 0 7
1645: PPUSH
1646: LD_INT 5
1648: PPUSH
1649: CALL_OW 273
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1658: LD_VAR 0 8
1662: PUSH
1663: LD_INT 1
1665: ARRAY
1666: PPUSH
1667: LD_VAR 0 8
1671: PUSH
1672: LD_INT 2
1674: ARRAY
1675: PPUSH
1676: CALL_OW 488
1680: IFFALSE 1779
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1682: LD_ADDR_VAR 0 3
1686: PUSH
1687: LD_VAR 0 8
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PPUSH
1696: LD_VAR 0 8
1700: PUSH
1701: LD_INT 2
1703: ARRAY
1704: PPUSH
1705: CALL_OW 546
1709: ST_TO_ADDR
// if hex [ 1 ] then
1710: LD_VAR 0 3
1714: PUSH
1715: LD_INT 1
1717: ARRAY
1718: IFFALSE 1722
// continue ;
1720: GO 1610
// h := hex [ 2 ] ;
1722: LD_ADDR_VAR 0 12
1726: PUSH
1727: LD_VAR 0 3
1731: PUSH
1732: LD_INT 2
1734: ARRAY
1735: ST_TO_ADDR
// if h + 7 < height then
1736: LD_VAR 0 12
1740: PUSH
1741: LD_INT 7
1743: PLUS
1744: PUSH
1745: LD_VAR 0 14
1749: LESS
1750: IFFALSE 1779
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1752: LD_ADDR_VAR 0 17
1756: PUSH
1757: LD_INT 7
1759: PUSH
1760: LD_INT 28
1762: PUSH
1763: LD_INT 45
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: PUSH
1771: LD_VAR 0 11
1775: ARRAY
1776: ST_TO_ADDR
// break ;
1777: GO 1781
// end ; end ; end ;
1779: GO 1610
1781: POP
1782: POP
// end ; if not weapon then
1783: LD_VAR 0 17
1787: NOT
1788: IFFALSE 1943
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1790: LD_ADDR_VAR 0 4
1794: PUSH
1795: LD_VAR 0 4
1799: PUSH
1800: LD_INT 11
1802: PUSH
1803: LD_INT 30
1805: PUSH
1806: LD_INT 49
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: DIFF
1814: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1815: LD_ADDR_VAR 0 13
1819: PUSH
1820: LD_INT 22
1822: PUSH
1823: LD_VAR 0 15
1827: PUSH
1828: EMPTY
1829: LIST
1830: LIST
1831: PUSH
1832: LD_INT 91
1834: PUSH
1835: LD_VAR 0 1
1839: PUSH
1840: LD_INT 6
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 3
1850: PUSH
1851: LD_INT 35
1853: PUSH
1854: LD_INT 0
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PPUSH
1870: CALL_OW 69
1874: ST_TO_ADDR
// for i in tmp do
1875: LD_ADDR_VAR 0 7
1879: PUSH
1880: LD_VAR 0 13
1884: PUSH
1885: FOR_IN
1886: IFFALSE 1911
// list := list diff GetBWeapon ( i ) ;
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: LD_VAR 0 4
1897: PUSH
1898: LD_VAR 0 7
1902: PPUSH
1903: CALL_OW 269
1907: DIFF
1908: ST_TO_ADDR
1909: GO 1885
1911: POP
1912: POP
// if list then
1913: LD_VAR 0 4
1917: IFFALSE 1943
// weapon := list [ rand ( 1 , list ) ] ;
1919: LD_ADDR_VAR 0 17
1923: PUSH
1924: LD_VAR 0 4
1928: PUSH
1929: LD_INT 1
1931: PPUSH
1932: LD_VAR 0 4
1936: PPUSH
1937: CALL_OW 12
1941: ARRAY
1942: ST_TO_ADDR
// end ; if weapon then
1943: LD_VAR 0 17
1947: IFFALSE 2061
// begin tmp := CostOfWeapon ( weapon ) ;
1949: LD_ADDR_VAR 0 13
1953: PUSH
1954: LD_VAR 0 17
1958: PPUSH
1959: CALL_OW 451
1963: ST_TO_ADDR
// j := GetBase ( tower ) ;
1964: LD_ADDR_VAR 0 8
1968: PUSH
1969: LD_VAR 0 1
1973: PPUSH
1974: CALL_OW 274
1978: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1979: LD_VAR 0 8
1983: PPUSH
1984: LD_INT 1
1986: PPUSH
1987: CALL_OW 275
1991: PUSH
1992: LD_VAR 0 13
1996: PUSH
1997: LD_INT 1
1999: ARRAY
2000: GREATEREQUAL
2001: PUSH
2002: LD_VAR 0 8
2006: PPUSH
2007: LD_INT 2
2009: PPUSH
2010: CALL_OW 275
2014: PUSH
2015: LD_VAR 0 13
2019: PUSH
2020: LD_INT 2
2022: ARRAY
2023: GREATEREQUAL
2024: AND
2025: PUSH
2026: LD_VAR 0 8
2030: PPUSH
2031: LD_INT 3
2033: PPUSH
2034: CALL_OW 275
2038: PUSH
2039: LD_VAR 0 13
2043: PUSH
2044: LD_INT 3
2046: ARRAY
2047: GREATEREQUAL
2048: AND
2049: IFFALSE 2061
// result := weapon ;
2051: LD_ADDR_VAR 0 2
2055: PUSH
2056: LD_VAR 0 17
2060: ST_TO_ADDR
// end ; end ;
2061: LD_VAR 0 2
2065: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2066: LD_INT 0
2068: PPUSH
2069: PPUSH
2070: PPUSH
2071: PPUSH
2072: PPUSH
// if not un or not IsOk ( un ) then
2073: LD_VAR 0 1
2077: NOT
2078: PUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 302
2088: NOT
2089: OR
2090: IFFALSE 2094
// exit ;
2092: GO 2534
// side := GetSide ( un ) ;
2094: LD_ADDR_VAR 0 9
2098: PUSH
2099: LD_VAR 0 1
2103: PPUSH
2104: CALL_OW 255
2108: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2109: LD_ADDR_VAR 0 7
2113: PUSH
2114: LD_INT 22
2116: PUSH
2117: LD_VAR 0 9
2121: PUSH
2122: EMPTY
2123: LIST
2124: LIST
2125: PUSH
2126: LD_INT 30
2128: PUSH
2129: LD_INT 32
2131: PUSH
2132: EMPTY
2133: LIST
2134: LIST
2135: PUSH
2136: LD_INT 50
2138: PUSH
2139: EMPTY
2140: LIST
2141: PUSH
2142: LD_INT 58
2144: PUSH
2145: EMPTY
2146: LIST
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: PPUSH
2154: CALL_OW 69
2158: PUSH
2159: LD_VAR 0 2
2163: DIFF
2164: ST_TO_ADDR
// if not filter then
2165: LD_VAR 0 7
2169: NOT
2170: IFFALSE 2399
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2172: LD_ADDR_VAR 0 7
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_VAR 0 9
2184: PUSH
2185: EMPTY
2186: LIST
2187: LIST
2188: PUSH
2189: LD_INT 30
2191: PUSH
2192: LD_INT 5
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 69
2207: ST_TO_ADDR
// if debug then
2208: LD_EXP 1
2212: IFFALSE 2231
// display_strings := [ filter , 1 ] ;
2214: LD_ADDR_OWVAR 47
2218: PUSH
2219: LD_VAR 0 7
2223: PUSH
2224: LD_STRING 1
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: ST_TO_ADDR
// if not filter then
2231: LD_VAR 0 7
2235: NOT
2236: IFFALSE 2259
// begin ComMoveXY ( un , x , y ) ;
2238: LD_VAR 0 1
2242: PPUSH
2243: LD_VAR 0 3
2247: PPUSH
2248: LD_VAR 0 4
2252: PPUSH
2253: CALL_OW 111
// exit ;
2257: GO 2534
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2259: LD_ADDR_VAR 0 8
2263: PUSH
2264: LD_VAR 0 7
2268: PPUSH
2269: LD_VAR 0 1
2273: PPUSH
2274: CALL_OW 74
2278: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2279: LD_VAR 0 8
2283: PPUSH
2284: CALL_OW 313
2288: PUSH
2289: LD_INT 6
2291: EQUAL
2292: IFFALSE 2312
// filter := filter diff t else
2294: LD_ADDR_VAR 0 7
2298: PUSH
2299: LD_VAR 0 7
2303: PUSH
2304: LD_VAR 0 8
2308: DIFF
2309: ST_TO_ADDR
2310: GO 2314
// break ;
2312: GO 2336
// until UnitsInside ( t ) < 6 or not filter ;
2314: LD_VAR 0 8
2318: PPUSH
2319: CALL_OW 313
2323: PUSH
2324: LD_INT 6
2326: LESS
2327: PUSH
2328: LD_VAR 0 7
2332: NOT
2333: OR
2334: IFFALSE 2259
// display_strings := [ filter , t ] ;
2336: LD_ADDR_OWVAR 47
2340: PUSH
2341: LD_VAR 0 7
2345: PUSH
2346: LD_VAR 0 8
2350: PUSH
2351: EMPTY
2352: LIST
2353: LIST
2354: ST_TO_ADDR
// if not filter then
2355: LD_VAR 0 7
2359: NOT
2360: IFFALSE 2383
// ComMoveXY ( un , x , y ) else
2362: LD_VAR 0 1
2366: PPUSH
2367: LD_VAR 0 3
2371: PPUSH
2372: LD_VAR 0 4
2376: PPUSH
2377: CALL_OW 111
2381: GO 2397
// ComEnterUnit ( un , t ) ;
2383: LD_VAR 0 1
2387: PPUSH
2388: LD_VAR 0 8
2392: PPUSH
2393: CALL_OW 120
// end else
2397: GO 2534
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2399: LD_ADDR_VAR 0 8
2403: PUSH
2404: LD_VAR 0 7
2408: PPUSH
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 74
2418: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2419: LD_VAR 0 8
2423: PPUSH
2424: CALL_OW 110
2428: PUSH
2429: LD_INT 7
2431: EQUAL
2432: IFFALSE 2450
// filter := filter diff t ;
2434: LD_ADDR_VAR 0 7
2438: PUSH
2439: LD_VAR 0 7
2443: PUSH
2444: LD_VAR 0 8
2448: DIFF
2449: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2450: LD_VAR 0 8
2454: PPUSH
2455: CALL_OW 110
2459: PUSH
2460: LD_INT 7
2462: NONEQUAL
2463: PUSH
2464: LD_VAR 0 7
2468: NOT
2469: OR
2470: IFFALSE 2399
// if GetTag ( t ) <> 7 then
2472: LD_VAR 0 8
2476: PPUSH
2477: CALL_OW 110
2481: PUSH
2482: LD_INT 7
2484: NONEQUAL
2485: IFFALSE 2515
// begin SetTag ( t , 7 ) ;
2487: LD_VAR 0 8
2491: PPUSH
2492: LD_INT 7
2494: PPUSH
2495: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2499: LD_VAR 0 1
2503: PPUSH
2504: LD_VAR 0 8
2508: PPUSH
2509: CALL_OW 120
// end else
2513: GO 2534
// ComMoveXY ( un , x , y ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 3
2524: PPUSH
2525: LD_VAR 0 4
2529: PPUSH
2530: CALL_OW 111
// end ; end ;
2534: LD_VAR 0 5
2538: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2539: LD_INT 0
2541: PPUSH
2542: PPUSH
2543: PPUSH
// if not base then
2544: LD_VAR 0 1
2548: NOT
2549: IFFALSE 2553
// exit ;
2551: GO 2611
// tmp := GetEnergy ( GetBase ( base ) ) ;
2553: LD_ADDR_VAR 0 4
2557: PUSH
2558: LD_VAR 0 1
2562: PPUSH
2563: CALL_OW 274
2567: PPUSH
2568: CALL_OW 278
2572: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2573: LD_VAR 0 4
2577: PUSH
2578: LD_INT 1
2580: ARRAY
2581: PUSH
2582: LD_VAR 0 4
2586: PUSH
2587: LD_INT 4
2589: ARRAY
2590: GREATER
2591: IFFALSE 2603
// result := true else
2593: LD_ADDR_VAR 0 2
2597: PUSH
2598: LD_INT 1
2600: ST_TO_ADDR
2601: GO 2611
// result := false ;
2603: LD_ADDR_VAR 0 2
2607: PUSH
2608: LD_INT 0
2610: ST_TO_ADDR
// end ;
2611: LD_VAR 0 2
2615: RET
// export function FilterPeople ( side ) ; begin
2616: LD_INT 0
2618: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2619: LD_ADDR_VAR 0 2
2623: PUSH
2624: LD_INT 22
2626: PUSH
2627: LD_VAR 0 1
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: PUSH
2636: LD_INT 21
2638: PUSH
2639: LD_INT 1
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: PPUSH
2650: CALL_OW 69
2654: ST_TO_ADDR
// end ;
2655: LD_VAR 0 2
2659: RET
// export function FilterDrivers ( side ) ; begin
2660: LD_INT 0
2662: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2663: LD_ADDR_VAR 0 2
2667: PUSH
2668: LD_INT 22
2670: PUSH
2671: LD_VAR 0 1
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 3
2682: PUSH
2683: LD_INT 56
2685: PUSH
2686: EMPTY
2687: LIST
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: PUSH
2693: EMPTY
2694: LIST
2695: LIST
2696: PPUSH
2697: CALL_OW 69
2701: ST_TO_ADDR
// end ;
2702: LD_VAR 0 2
2706: RET
// export function FilterPeopleArea ( side , area ) ; begin
2707: LD_INT 0
2709: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2710: LD_ADDR_VAR 0 3
2714: PUSH
2715: LD_VAR 0 2
2719: PPUSH
2720: LD_INT 22
2722: PUSH
2723: LD_INT 1
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 21
2732: PUSH
2733: LD_INT 1
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: PPUSH
2744: CALL_OW 70
2748: ST_TO_ADDR
// end ;
2749: LD_VAR 0 3
2753: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2754: LD_INT 0
2756: PPUSH
2757: PPUSH
2758: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2759: LD_ADDR_VAR 0 5
2763: PUSH
2764: LD_VAR 0 2
2768: PPUSH
2769: LD_INT 22
2771: PUSH
2772: LD_INT 1
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: LD_INT 21
2781: PUSH
2782: LD_INT 2
2784: PUSH
2785: EMPTY
2786: LIST
2787: LIST
2788: PUSH
2789: LD_INT 3
2791: PUSH
2792: LD_INT 58
2794: PUSH
2795: EMPTY
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: PPUSH
2807: CALL_OW 70
2811: ST_TO_ADDR
// result := [ ] ;
2812: LD_ADDR_VAR 0 3
2816: PUSH
2817: EMPTY
2818: ST_TO_ADDR
// if not tmp then
2819: LD_VAR 0 5
2823: NOT
2824: IFFALSE 2828
// exit ;
2826: GO 2880
// for i in tmp do
2828: LD_ADDR_VAR 0 4
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: FOR_IN
2839: IFFALSE 2864
// result := result union IsDrivenBy ( i ) ;
2841: LD_ADDR_VAR 0 3
2845: PUSH
2846: LD_VAR 0 3
2850: PUSH
2851: LD_VAR 0 4
2855: PPUSH
2856: CALL_OW 311
2860: UNION
2861: ST_TO_ADDR
2862: GO 2838
2864: POP
2865: POP
// result := result diff 0 ;
2866: LD_ADDR_VAR 0 3
2870: PUSH
2871: LD_VAR 0 3
2875: PUSH
2876: LD_INT 0
2878: DIFF
2879: ST_TO_ADDR
// end ;
2880: LD_VAR 0 3
2884: RET
// export function FilterBuildings ( side ) ; begin
2885: LD_INT 0
2887: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2888: LD_ADDR_VAR 0 2
2892: PUSH
2893: LD_INT 22
2895: PUSH
2896: LD_VAR 0 1
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: PUSH
2905: LD_INT 21
2907: PUSH
2908: LD_INT 3
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PPUSH
2919: CALL_OW 69
2923: ST_TO_ADDR
// end ;
2924: LD_VAR 0 2
2928: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
// uc_side = 0 ;
2935: LD_ADDR_OWVAR 20
2939: PUSH
2940: LD_INT 0
2942: ST_TO_ADDR
// uc_nation = 0 ;
2943: LD_ADDR_OWVAR 21
2947: PUSH
2948: LD_INT 0
2950: ST_TO_ADDR
// nat_area := wildArea ;
2951: LD_ADDR_VAR 0 4
2955: PUSH
2956: LD_INT 3
2958: ST_TO_ADDR
// InitHc ;
2959: CALL_OW 19
// for i = 1 to 4 do
2963: LD_ADDR_VAR 0 2
2967: PUSH
2968: DOUBLE
2969: LD_INT 1
2971: DEC
2972: ST_TO_ADDR
2973: LD_INT 4
2975: PUSH
2976: FOR_TO
2977: IFFALSE 3032
// begin hc_class = 18 ;
2979: LD_ADDR_OWVAR 28
2983: PUSH
2984: LD_INT 18
2986: ST_TO_ADDR
// hc_gallery =  ;
2987: LD_ADDR_OWVAR 33
2991: PUSH
2992: LD_STRING 
2994: ST_TO_ADDR
// hc_face_number = 1 ;
2995: LD_ADDR_OWVAR 34
2999: PUSH
3000: LD_INT 1
3002: ST_TO_ADDR
// animal := CreateHuman ;
3003: LD_ADDR_VAR 0 3
3007: PUSH
3008: CALL_OW 44
3012: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3013: LD_VAR 0 3
3017: PPUSH
3018: LD_VAR 0 4
3022: PPUSH
3023: LD_INT 0
3025: PPUSH
3026: CALL_OW 49
// end ;
3030: GO 2976
3032: POP
3033: POP
// for i = 1 to 6 do
3034: LD_ADDR_VAR 0 2
3038: PUSH
3039: DOUBLE
3040: LD_INT 1
3042: DEC
3043: ST_TO_ADDR
3044: LD_INT 6
3046: PUSH
3047: FOR_TO
3048: IFFALSE 3119
// begin hc_class = class_tiger ;
3050: LD_ADDR_OWVAR 28
3054: PUSH
3055: LD_INT 14
3057: ST_TO_ADDR
// hc_gallery =  ;
3058: LD_ADDR_OWVAR 33
3062: PUSH
3063: LD_STRING 
3065: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3066: LD_ADDR_OWVAR 35
3070: PUSH
3071: LD_INT 0
3073: PPUSH
3074: LD_INT 10
3076: PPUSH
3077: CALL_OW 12
3081: ST_TO_ADDR
// hc_face_number = 3 ;
3082: LD_ADDR_OWVAR 34
3086: PUSH
3087: LD_INT 3
3089: ST_TO_ADDR
// animal := CreateHuman ;
3090: LD_ADDR_VAR 0 3
3094: PUSH
3095: CALL_OW 44
3099: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3100: LD_VAR 0 3
3104: PPUSH
3105: LD_VAR 0 4
3109: PPUSH
3110: LD_INT 0
3112: PPUSH
3113: CALL_OW 49
// end ;
3117: GO 3047
3119: POP
3120: POP
// for i = 1 to 2 do
3121: LD_ADDR_VAR 0 2
3125: PUSH
3126: DOUBLE
3127: LD_INT 1
3129: DEC
3130: ST_TO_ADDR
3131: LD_INT 2
3133: PUSH
3134: FOR_TO
3135: IFFALSE 3198
// begin hc_class = 21 ;
3137: LD_ADDR_OWVAR 28
3141: PUSH
3142: LD_INT 21
3144: ST_TO_ADDR
// hc_gallery =  ;
3145: LD_ADDR_OWVAR 33
3149: PUSH
3150: LD_STRING 
3152: ST_TO_ADDR
// hc_agressivity = 0 ;
3153: LD_ADDR_OWVAR 35
3157: PUSH
3158: LD_INT 0
3160: ST_TO_ADDR
// hc_face_number = 5 ;
3161: LD_ADDR_OWVAR 34
3165: PUSH
3166: LD_INT 5
3168: ST_TO_ADDR
// animal := CreateHuman ;
3169: LD_ADDR_VAR 0 3
3173: PUSH
3174: CALL_OW 44
3178: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3179: LD_VAR 0 3
3183: PPUSH
3184: LD_VAR 0 4
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// end ;
3196: GO 3134
3198: POP
3199: POP
// for i = 1 to 6 do
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_INT 6
3212: PUSH
3213: FOR_TO
3214: IFFALSE 3269
// begin hc_class = 13 ;
3216: LD_ADDR_OWVAR 28
3220: PUSH
3221: LD_INT 13
3223: ST_TO_ADDR
// hc_gallery =  ;
3224: LD_ADDR_OWVAR 33
3228: PUSH
3229: LD_STRING 
3231: ST_TO_ADDR
// hc_face_number = 4 ;
3232: LD_ADDR_OWVAR 34
3236: PUSH
3237: LD_INT 4
3239: ST_TO_ADDR
// animal := CreateHuman ;
3240: LD_ADDR_VAR 0 3
3244: PUSH
3245: CALL_OW 44
3249: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3250: LD_VAR 0 3
3254: PPUSH
3255: LD_VAR 0 4
3259: PPUSH
3260: LD_INT 0
3262: PPUSH
3263: CALL_OW 49
// end ;
3267: GO 3213
3269: POP
3270: POP
// for i = 1 to 2 do
3271: LD_ADDR_VAR 0 2
3275: PUSH
3276: DOUBLE
3277: LD_INT 1
3279: DEC
3280: ST_TO_ADDR
3281: LD_INT 2
3283: PUSH
3284: FOR_TO
3285: IFFALSE 3344
// begin hc_class = 20 ;
3287: LD_ADDR_OWVAR 28
3291: PUSH
3292: LD_INT 20
3294: ST_TO_ADDR
// hc_gallery =  ;
3295: LD_ADDR_OWVAR 33
3299: PUSH
3300: LD_STRING 
3302: ST_TO_ADDR
// hc_face_number = 2 ;
3303: LD_ADDR_OWVAR 34
3307: PUSH
3308: LD_INT 2
3310: ST_TO_ADDR
// animal := CreateHuman ;
3311: LD_ADDR_VAR 0 3
3315: PUSH
3316: CALL_OW 44
3320: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 101
3328: PPUSH
3329: LD_INT 37
3331: PPUSH
3332: LD_INT 3
3334: PPUSH
3335: LD_INT 0
3337: PPUSH
3338: CALL_OW 50
// end ;
3342: GO 3284
3344: POP
3345: POP
// for i = 1 to 1 do
3346: LD_ADDR_VAR 0 2
3350: PUSH
3351: DOUBLE
3352: LD_INT 1
3354: DEC
3355: ST_TO_ADDR
3356: LD_INT 1
3358: PUSH
3359: FOR_TO
3360: IFFALSE 3407
// begin vc_chassis := 31 ;
3362: LD_ADDR_OWVAR 37
3366: PUSH
3367: LD_INT 31
3369: ST_TO_ADDR
// vc_control := control_rider ;
3370: LD_ADDR_OWVAR 38
3374: PUSH
3375: LD_INT 4
3377: ST_TO_ADDR
// animal := CreateVehicle ;
3378: LD_ADDR_VAR 0 3
3382: PUSH
3383: CALL_OW 45
3387: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3388: LD_VAR 0 3
3392: PPUSH
3393: LD_VAR 0 4
3397: PPUSH
3398: LD_INT 0
3400: PPUSH
3401: CALL_OW 49
// end ;
3405: GO 3359
3407: POP
3408: POP
// end ;
3409: LD_VAR 0 1
3413: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3414: LD_INT 0
3416: PPUSH
3417: PPUSH
3418: PPUSH
3419: PPUSH
// result := [ ] ;
3420: LD_ADDR_VAR 0 2
3424: PUSH
3425: EMPTY
3426: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3427: LD_ADDR_VAR 0 4
3431: PUSH
3432: LD_INT 81
3434: PUSH
3435: LD_VAR 0 1
3439: PPUSH
3440: CALL_OW 255
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PUSH
3449: LD_INT 91
3451: PUSH
3452: LD_VAR 0 1
3456: PUSH
3457: LD_INT 15
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: PUSH
3465: LD_INT 2
3467: PUSH
3468: LD_INT 30
3470: PUSH
3471: LD_INT 32
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: PUSH
3478: LD_INT 30
3480: PUSH
3481: LD_INT 33
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: LIST
3492: PUSH
3493: EMPTY
3494: LIST
3495: LIST
3496: LIST
3497: PPUSH
3498: CALL_OW 69
3502: ST_TO_ADDR
// if not tmp then
3503: LD_VAR 0 4
3507: NOT
3508: IFFALSE 3512
// exit ;
3510: GO 3581
// for i in tmp do
3512: LD_ADDR_VAR 0 3
3516: PUSH
3517: LD_VAR 0 4
3521: PUSH
3522: FOR_IN
3523: IFFALSE 3579
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3525: LD_ADDR_VAR 0 5
3529: PUSH
3530: LD_VAR 0 3
3534: PPUSH
3535: CALL_OW 274
3539: PPUSH
3540: CALL_OW 278
3544: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3545: LD_VAR 0 5
3549: PUSH
3550: LD_INT 4
3552: ARRAY
3553: PUSH
3554: LD_VAR 0 5
3558: PUSH
3559: LD_INT 1
3561: ARRAY
3562: GREATER
3563: IFFALSE 3577
// begin result := i ;
3565: LD_ADDR_VAR 0 2
3569: PUSH
3570: LD_VAR 0 3
3574: ST_TO_ADDR
// break ;
3575: GO 3579
// end ; end ;
3577: GO 3522
3579: POP
3580: POP
// end ; end_of_file
3581: LD_VAR 0 2
3585: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3586: LD_INT 0
3588: PPUSH
3589: PPUSH
3590: PPUSH
3591: PPUSH
3592: PPUSH
3593: PPUSH
// uc_side := 1 ;
3594: LD_ADDR_OWVAR 20
3598: PUSH
3599: LD_INT 1
3601: ST_TO_ADDR
// uc_nation := 1 ;
3602: LD_ADDR_OWVAR 21
3606: PUSH
3607: LD_INT 1
3609: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3610: LD_ADDR_EXP 8
3614: PUSH
3615: LD_STRING JMM
3617: PPUSH
3618: LD_EXP 1
3622: NOT
3623: PPUSH
3624: CALL 366 0 2
3628: ST_TO_ADDR
// team := [ JMM ] ;
3629: LD_ADDR_VAR 0 3
3633: PUSH
3634: LD_EXP 8
3638: PUSH
3639: EMPTY
3640: LIST
3641: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3642: LD_STRING BrownIn07
3644: PPUSH
3645: LD_EXP 1
3649: PPUSH
3650: CALL_OW 30
3654: IFFALSE 3675
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3656: LD_ADDR_EXP 9
3660: PUSH
3661: LD_STRING Brown
3663: PPUSH
3664: LD_EXP 1
3668: NOT
3669: PPUSH
3670: CALL 366 0 2
3674: ST_TO_ADDR
// if Brown then
3675: LD_EXP 9
3679: IFFALSE 3697
// team := team ^ Brown ;
3681: LD_ADDR_VAR 0 3
3685: PUSH
3686: LD_VAR 0 3
3690: PUSH
3691: LD_EXP 9
3695: ADD
3696: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3697: LD_STRING DonaldsonIn07
3699: PPUSH
3700: LD_EXP 1
3704: PPUSH
3705: CALL_OW 30
3709: IFFALSE 3730
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3711: LD_ADDR_EXP 10
3715: PUSH
3716: LD_STRING Donaldson
3718: PPUSH
3719: LD_EXP 1
3723: NOT
3724: PPUSH
3725: CALL 366 0 2
3729: ST_TO_ADDR
// if Donaldson then
3730: LD_EXP 10
3734: IFFALSE 3752
// team := team ^ Donaldson ;
3736: LD_ADDR_VAR 0 3
3740: PUSH
3741: LD_VAR 0 3
3745: PUSH
3746: LD_EXP 10
3750: ADD
3751: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3752: LD_STRING BobbyIn07
3754: PPUSH
3755: LD_EXP 1
3759: PPUSH
3760: CALL_OW 30
3764: IFFALSE 3785
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3766: LD_ADDR_EXP 11
3770: PUSH
3771: LD_STRING Bobby
3773: PPUSH
3774: LD_EXP 1
3778: NOT
3779: PPUSH
3780: CALL 366 0 2
3784: ST_TO_ADDR
// if Bobby then
3785: LD_EXP 11
3789: IFFALSE 3807
// team := team ^ Bobby ;
3791: LD_ADDR_VAR 0 3
3795: PUSH
3796: LD_VAR 0 3
3800: PUSH
3801: LD_EXP 11
3805: ADD
3806: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3807: LD_STRING CyrusIn07
3809: PPUSH
3810: LD_EXP 1
3814: PPUSH
3815: CALL_OW 30
3819: IFFALSE 3840
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3821: LD_ADDR_EXP 12
3825: PUSH
3826: LD_STRING Cyrus
3828: PPUSH
3829: LD_EXP 1
3833: NOT
3834: PPUSH
3835: CALL 366 0 2
3839: ST_TO_ADDR
// if Cyrus then
3840: LD_EXP 12
3844: IFFALSE 3862
// team := team ^ Cyrus ;
3846: LD_ADDR_VAR 0 3
3850: PUSH
3851: LD_VAR 0 3
3855: PUSH
3856: LD_EXP 12
3860: ADD
3861: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3862: LD_STRING LisaIn07
3864: PPUSH
3865: LD_EXP 1
3869: PPUSH
3870: CALL_OW 30
3874: IFFALSE 3895
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3876: LD_ADDR_EXP 13
3880: PUSH
3881: LD_STRING Lisa
3883: PPUSH
3884: LD_EXP 1
3888: NOT
3889: PPUSH
3890: CALL 366 0 2
3894: ST_TO_ADDR
// if Lisa then
3895: LD_EXP 13
3899: IFFALSE 3917
// team := team ^ Lisa ;
3901: LD_ADDR_VAR 0 3
3905: PUSH
3906: LD_VAR 0 3
3910: PUSH
3911: LD_EXP 13
3915: ADD
3916: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3917: LD_STRING GladstoneIn07
3919: PPUSH
3920: LD_EXP 1
3924: PPUSH
3925: CALL_OW 30
3929: IFFALSE 3950
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3931: LD_ADDR_EXP 15
3935: PUSH
3936: LD_STRING Gladstone
3938: PPUSH
3939: LD_EXP 1
3943: NOT
3944: PPUSH
3945: CALL 366 0 2
3949: ST_TO_ADDR
// if Gladstone then
3950: LD_EXP 15
3954: IFFALSE 3972
// team := team ^ Gladstone ;
3956: LD_ADDR_VAR 0 3
3960: PUSH
3961: LD_VAR 0 3
3965: PUSH
3966: LD_EXP 15
3970: ADD
3971: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3972: LD_STRING KhatamIn07
3974: PPUSH
3975: LD_EXP 1
3979: PPUSH
3980: CALL_OW 30
3984: IFFALSE 4005
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3986: LD_ADDR_EXP 16
3990: PUSH
3991: LD_STRING Khatam
3993: PPUSH
3994: LD_EXP 1
3998: NOT
3999: PPUSH
4000: CALL 366 0 2
4004: ST_TO_ADDR
// if Khatam then
4005: LD_EXP 16
4009: IFFALSE 4027
// team := team ^ Khatam ;
4011: LD_ADDR_VAR 0 3
4015: PUSH
4016: LD_VAR 0 3
4020: PUSH
4021: LD_EXP 16
4025: ADD
4026: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4027: LD_ADDR_VAR 0 4
4031: PUSH
4032: LD_STRING 07_others
4034: PPUSH
4035: CALL_OW 31
4039: ST_TO_ADDR
// if others then
4040: LD_VAR 0 4
4044: IFFALSE 4062
// team := team ^ others ;
4046: LD_ADDR_VAR 0 3
4050: PUSH
4051: LD_VAR 0 3
4055: PUSH
4056: LD_VAR 0 4
4060: ADD
4061: ST_TO_ADDR
// if debug then
4062: LD_EXP 1
4066: IFFALSE 4140
// begin InitHc ;
4068: CALL_OW 19
// for i = 1 to 4 do
4072: LD_ADDR_VAR 0 2
4076: PUSH
4077: DOUBLE
4078: LD_INT 1
4080: DEC
4081: ST_TO_ADDR
4082: LD_INT 4
4084: PUSH
4085: FOR_TO
4086: IFFALSE 4138
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4088: LD_INT 0
4090: PPUSH
4091: LD_INT 1
4093: PUSH
4094: LD_INT 3
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PUSH
4101: LD_INT 1
4103: PPUSH
4104: LD_INT 2
4106: PPUSH
4107: CALL_OW 12
4111: ARRAY
4112: PPUSH
4113: LD_INT 4
4115: PPUSH
4116: CALL_OW 380
// team := team ^ CreateHuman ;
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: LD_VAR 0 3
4129: PUSH
4130: CALL_OW 44
4134: ADD
4135: ST_TO_ADDR
// end ;
4136: GO 4085
4138: POP
4139: POP
// end ; m := 0 ;
4140: LD_ADDR_VAR 0 6
4144: PUSH
4145: LD_INT 0
4147: ST_TO_ADDR
// for i in team do
4148: LD_ADDR_VAR 0 2
4152: PUSH
4153: LD_VAR 0 3
4157: PUSH
4158: FOR_IN
4159: IFFALSE 4366
// if GetClass ( i ) = 3 then
4161: LD_VAR 0 2
4165: PPUSH
4166: CALL_OW 257
4170: PUSH
4171: LD_INT 3
4173: EQUAL
4174: IFFALSE 4322
// begin m := m + 1 ;
4176: LD_ADDR_VAR 0 6
4180: PUSH
4181: LD_VAR 0 6
4185: PUSH
4186: LD_INT 1
4188: PLUS
4189: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4190: LD_ADDR_VAR 0 5
4194: PUSH
4195: LD_INT 1
4197: PPUSH
4198: LD_INT 1
4200: PPUSH
4201: LD_INT 2
4203: PUSH
4204: LD_INT 3
4206: PUSH
4207: LD_INT 2
4209: PUSH
4210: LD_INT 1
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_VAR 0 6
4223: PUSH
4224: LD_INT 4
4226: MOD
4227: PUSH
4228: LD_INT 1
4230: PLUS
4231: ARRAY
4232: PPUSH
4233: LD_INT 2
4235: PPUSH
4236: LD_INT 1
4238: PPUSH
4239: LD_INT 4
4241: PUSH
4242: LD_INT 5
4244: PUSH
4245: LD_INT 3
4247: PUSH
4248: LD_INT 11
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: PUSH
4257: LD_VAR 0 6
4261: PUSH
4262: LD_INT 4
4264: MOD
4265: PUSH
4266: LD_INT 1
4268: PLUS
4269: ARRAY
4270: PPUSH
4271: LD_INT 60
4273: PPUSH
4274: CALL 429 0 7
4278: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4279: LD_VAR 0 5
4283: PPUSH
4284: LD_INT 2
4286: PPUSH
4287: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4291: LD_VAR 0 5
4295: PPUSH
4296: LD_INT 1
4298: PPUSH
4299: LD_INT 0
4301: PPUSH
4302: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4306: LD_VAR 0 2
4310: PPUSH
4311: LD_VAR 0 5
4315: PPUSH
4316: CALL_OW 52
// end else
4320: GO 4364
// begin if GetClass ( i ) = 2 then
4322: LD_VAR 0 2
4326: PPUSH
4327: CALL_OW 257
4331: PUSH
4332: LD_INT 2
4334: EQUAL
4335: IFFALSE 4349
// SetClass ( i , 1 ) ;
4337: LD_VAR 0 2
4341: PPUSH
4342: LD_INT 1
4344: PPUSH
4345: CALL_OW 336
// PlaceUnitArea ( i , startArea , false ) ;
4349: LD_VAR 0 2
4353: PPUSH
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 49
// end ;
4364: GO 4158
4366: POP
4367: POP
// uc_side := 4 ;
4368: LD_ADDR_OWVAR 20
4372: PUSH
4373: LD_INT 4
4375: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4376: LD_ADDR_EXP 18
4380: PUSH
4381: LD_STRING Harisson
4383: PPUSH
4384: LD_INT 0
4386: PPUSH
4387: CALL 366 0 2
4391: ST_TO_ADDR
// PrepareScout ;
4392: CALL 4401 0 0
// end ;
4396: LD_VAR 0 1
4400: RET
// function PrepareScout ; var ape ; begin
4401: LD_INT 0
4403: PPUSH
4404: PPUSH
// uc_side := 4 ;
4405: LD_ADDR_OWVAR 20
4409: PUSH
4410: LD_INT 4
4412: ST_TO_ADDR
// uc_nation := 1 ;
4413: LD_ADDR_OWVAR 21
4417: PUSH
4418: LD_INT 1
4420: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4421: LD_STRING FrankIn06
4423: PPUSH
4424: LD_INT 0
4426: PPUSH
4427: CALL_OW 30
4431: IFFALSE 4448
// Frank := CreateCharacter ( 06c_Frank ) else
4433: LD_ADDR_EXP 14
4437: PUSH
4438: LD_STRING 06c_Frank
4440: PPUSH
4441: CALL_OW 34
4445: ST_TO_ADDR
4446: GO 4488
// if LoadVariable ( FrankInDelta , 0 ) then
4448: LD_STRING FrankInDelta
4450: PPUSH
4451: LD_INT 0
4453: PPUSH
4454: CALL_OW 30
4458: IFFALSE 4475
// Frank := CreateCharacter ( 05_Frank ) else
4460: LD_ADDR_EXP 14
4464: PUSH
4465: LD_STRING 05_Frank
4467: PPUSH
4468: CALL_OW 34
4472: ST_TO_ADDR
4473: GO 4488
// Frank := CreateCharacter ( 04_Frank ) ;
4475: LD_ADDR_EXP 14
4479: PUSH
4480: LD_STRING 04_Frank
4482: PPUSH
4483: CALL_OW 34
4487: ST_TO_ADDR
// if Frank then
4488: LD_EXP 14
4492: IFFALSE 4625
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4494: LD_EXP 14
4498: PPUSH
4499: LD_INT 2
4501: PPUSH
4502: LD_INT 0
4504: PPUSH
4505: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4509: LD_EXP 14
4513: PPUSH
4514: LD_INT 1
4516: PPUSH
4517: CALL_OW 336
// uc_side := 0 ;
4521: LD_ADDR_OWVAR 20
4525: PUSH
4526: LD_INT 0
4528: ST_TO_ADDR
// uc_nation := 0 ;
4529: LD_ADDR_OWVAR 21
4533: PUSH
4534: LD_INT 0
4536: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4537: LD_INT 0
4539: PPUSH
4540: LD_INT 12
4542: PPUSH
4543: LD_INT 0
4545: PPUSH
4546: CALL_OW 380
// ape := CreateHuman ;
4550: LD_ADDR_VAR 0 2
4554: PUSH
4555: CALL_OW 44
4559: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4560: LD_VAR 0 2
4564: PPUSH
4565: LD_EXP 14
4569: PPUSH
4570: CALL_OW 250
4574: PPUSH
4575: LD_EXP 14
4579: PPUSH
4580: CALL_OW 251
4584: PPUSH
4585: LD_INT 5
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4595: LD_VAR 0 2
4599: PPUSH
4600: LD_EXP 14
4604: PPUSH
4605: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4609: LD_EXP 14
4613: PPUSH
4614: LD_VAR 0 2
4618: PPUSH
4619: CALL_OW 119
// exit ;
4623: GO 4665
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4625: LD_ADDR_EXP 17
4629: PUSH
4630: LD_STRING Yamoko
4632: PPUSH
4633: LD_INT 0
4635: PPUSH
4636: CALL 366 0 2
4640: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4641: LD_EXP 17
4645: PPUSH
4646: LD_INT 2
4648: PPUSH
4649: LD_INT 0
4651: PPUSH
4652: CALL_OW 49
// ComHold ( Kikuchi ) ;
4656: LD_EXP 17
4660: PPUSH
4661: CALL_OW 140
// end ; end_of_file
4665: LD_VAR 0 1
4669: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4670: LD_INT 0
4672: PPUSH
4673: PPUSH
4674: PPUSH
4675: PPUSH
4676: PPUSH
4677: PPUSH
4678: PPUSH
4679: PPUSH
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
4685: PPUSH
4686: PPUSH
4687: PPUSH
// ru_rebuild_list := [ ] ;
4688: LD_ADDR_EXP 19
4692: PUSH
4693: EMPTY
4694: ST_TO_ADDR
// uc_side := 3 ;
4695: LD_ADDR_OWVAR 20
4699: PUSH
4700: LD_INT 3
4702: ST_TO_ADDR
// uc_nation := 3 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 3
4710: ST_TO_ADDR
// if Difficulty > 1 then
4711: LD_OWVAR 67
4715: PUSH
4716: LD_INT 1
4718: GREATER
4719: IFFALSE 4855
// begin bc_type := b_breastwork ;
4721: LD_ADDR_OWVAR 42
4725: PUSH
4726: LD_INT 31
4728: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4729: LD_INT 78
4731: PPUSH
4732: LD_INT 74
4734: PPUSH
4735: LD_INT 2
4737: PPUSH
4738: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4742: LD_INT 171
4744: PPUSH
4745: LD_INT 193
4747: PPUSH
4748: LD_INT 4
4750: PPUSH
4751: CALL_OW 47
// bc_type := b_turret ;
4755: LD_ADDR_OWVAR 42
4759: PUSH
4760: LD_INT 33
4762: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4763: LD_INT 129
4765: PPUSH
4766: LD_INT 96
4768: PPUSH
4769: LD_INT 3
4771: PPUSH
4772: CALL_OW 47
// if Difficulty > 2 then
4776: LD_OWVAR 67
4780: PUSH
4781: LD_INT 2
4783: GREATER
4784: IFFALSE 4855
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4786: LD_INT 83
4788: PPUSH
4789: LD_INT 141
4791: PPUSH
4792: CALL_OW 428
4796: PPUSH
4797: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4801: LD_INT 78
4803: PPUSH
4804: LD_INT 133
4806: PPUSH
4807: CALL_OW 428
4811: PPUSH
4812: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4816: LD_INT 83
4818: PPUSH
4819: LD_INT 141
4821: PPUSH
4822: LD_INT 2
4824: PPUSH
4825: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4829: LD_INT 78
4831: PPUSH
4832: LD_INT 133
4834: PPUSH
4835: LD_INT 2
4837: PPUSH
4838: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4842: LD_INT 145
4844: PPUSH
4845: LD_INT 112
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4855: LD_ADDR_VAR 0 9
4859: PUSH
4860: LD_INT 22
4862: PUSH
4863: LD_INT 3
4865: PUSH
4866: EMPTY
4867: LIST
4868: LIST
4869: PUSH
4870: LD_INT 2
4872: PUSH
4873: LD_INT 30
4875: PUSH
4876: LD_INT 0
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PUSH
4883: LD_INT 30
4885: PUSH
4886: LD_INT 1
4888: PUSH
4889: EMPTY
4890: LIST
4891: LIST
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: LIST
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PPUSH
4902: CALL_OW 69
4906: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4907: LD_ADDR_VAR 0 10
4911: PUSH
4912: LD_INT 22
4914: PUSH
4915: LD_INT 3
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 2
4924: PUSH
4925: LD_INT 30
4927: PUSH
4928: LD_INT 6
4930: PUSH
4931: EMPTY
4932: LIST
4933: LIST
4934: PUSH
4935: LD_INT 30
4937: PUSH
4938: LD_INT 7
4940: PUSH
4941: EMPTY
4942: LIST
4943: LIST
4944: PUSH
4945: LD_INT 30
4947: PUSH
4948: LD_INT 8
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: EMPTY
4956: LIST
4957: LIST
4958: LIST
4959: LIST
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: CALL_OW 69
4969: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4970: LD_ADDR_VAR 0 11
4974: PUSH
4975: LD_INT 22
4977: PUSH
4978: LD_INT 3
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PUSH
4985: LD_INT 30
4987: PUSH
4988: LD_INT 3
4990: PUSH
4991: EMPTY
4992: LIST
4993: LIST
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PPUSH
4999: CALL_OW 69
5003: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
5004: LD_ADDR_VAR 0 12
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 3
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 31
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 69
5037: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5038: LD_ADDR_VAR 0 13
5042: PUSH
5043: LD_INT 22
5045: PUSH
5046: LD_INT 3
5048: PUSH
5049: EMPTY
5050: LIST
5051: LIST
5052: PUSH
5053: LD_INT 30
5055: PUSH
5056: LD_INT 32
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PPUSH
5067: CALL_OW 69
5071: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5072: LD_ADDR_VAR 0 14
5076: PUSH
5077: LD_INT 22
5079: PUSH
5080: LD_INT 3
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 30
5089: PUSH
5090: LD_INT 33
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PPUSH
5101: CALL_OW 69
5105: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5106: LD_ADDR_VAR 0 15
5110: PUSH
5111: LD_INT 42
5113: PUSH
5114: LD_INT 5
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: LD_INT 43
5123: PUSH
5124: LD_INT 50
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: PUSH
5131: LD_INT 44
5133: PUSH
5134: LD_INT 30
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PUSH
5141: LD_INT 46
5143: PUSH
5144: LD_INT 15
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5157: LD_ADDR_VAR 0 16
5161: PUSH
5162: LD_INT 0
5164: PUSH
5165: LD_INT 4
5167: PUSH
5168: LD_INT 6
5170: PUSH
5171: LD_INT 3
5173: PUSH
5174: EMPTY
5175: LIST
5176: LIST
5177: LIST
5178: LIST
5179: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5180: LD_ADDR_VAR 0 6
5184: PUSH
5185: LD_INT 4
5187: PUSH
5188: LD_INT 5
5190: PUSH
5191: LD_INT 6
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: LD_OWVAR 67
5203: ARRAY
5204: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5205: LD_INT 16
5207: PPUSH
5208: LD_STRING am_tukh
5210: PPUSH
5211: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5215: LD_ADDR_VAR 0 2
5219: PUSH
5220: LD_INT 21
5222: PUSH
5223: LD_INT 3
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PPUSH
5230: CALL_OW 69
5234: PUSH
5235: FOR_IN
5236: IFFALSE 5269
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5238: LD_VAR 0 2
5242: PPUSH
5243: LD_INT 4
5245: PUSH
5246: LD_INT 5
5248: PUSH
5249: LD_INT 6
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_OWVAR 67
5261: ARRAY
5262: PPUSH
5263: CALL_OW 241
5267: GO 5235
5269: POP
5270: POP
// for i in dep_list do
5271: LD_ADDR_VAR 0 2
5275: PUSH
5276: LD_VAR 0 9
5280: PUSH
5281: FOR_IN
5282: IFFALSE 5326
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5284: LD_VAR 0 2
5288: PPUSH
5289: CALL_OW 274
5293: PPUSH
5294: LD_INT 1
5296: PPUSH
5297: LD_INT 1000
5299: PPUSH
5300: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5304: LD_VAR 0 2
5308: PPUSH
5309: CALL_OW 274
5313: PPUSH
5314: LD_INT 2
5316: PPUSH
5317: LD_INT 1000
5319: PPUSH
5320: CALL_OW 277
// end ;
5324: GO 5281
5326: POP
5327: POP
// InitHc ;
5328: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5332: LD_ADDR_VAR 0 8
5336: PUSH
5337: LD_VAR 0 13
5341: PUSH
5342: LD_INT 45
5344: PUSH
5345: LD_INT 60
5347: PUSH
5348: LD_INT 75
5350: PUSH
5351: EMPTY
5352: LIST
5353: LIST
5354: LIST
5355: PUSH
5356: LD_OWVAR 67
5360: ARRAY
5361: MUL
5362: PUSH
5363: LD_INT 100
5365: DIV
5366: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5367: LD_ADDR_VAR 0 16
5371: PUSH
5372: LD_VAR 0 16
5376: PPUSH
5377: LD_INT 1
5379: PPUSH
5380: LD_VAR 0 8
5384: PPUSH
5385: CALL_OW 1
5389: ST_TO_ADDR
// tmp := [ ] ;
5390: LD_ADDR_VAR 0 8
5394: PUSH
5395: EMPTY
5396: ST_TO_ADDR
// for i in bunker_list do
5397: LD_ADDR_VAR 0 2
5401: PUSH
5402: LD_VAR 0 13
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5504
// if i mod 10 + 1 < tmp then
5410: LD_VAR 0 2
5414: PUSH
5415: LD_INT 10
5417: MOD
5418: PUSH
5419: LD_INT 1
5421: PLUS
5422: PUSH
5423: LD_VAR 0 8
5427: LESS
5428: IFFALSE 5473
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5430: LD_ADDR_VAR 0 8
5434: PUSH
5435: LD_VAR 0 8
5439: PPUSH
5440: LD_VAR 0 2
5444: PUSH
5445: LD_INT 3
5447: PPUSH
5448: LD_INT 5
5450: PPUSH
5451: CALL_OW 12
5455: MOD
5456: PUSH
5457: LD_INT 1
5459: PLUS
5460: PPUSH
5461: LD_VAR 0 2
5465: PPUSH
5466: CALL_OW 2
5470: ST_TO_ADDR
5471: GO 5502
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5473: LD_ADDR_VAR 0 8
5477: PUSH
5478: LD_VAR 0 8
5482: PPUSH
5483: LD_VAR 0 8
5487: PUSH
5488: LD_INT 1
5490: PLUS
5491: PPUSH
5492: LD_VAR 0 2
5496: PPUSH
5497: CALL_OW 2
5501: ST_TO_ADDR
5502: GO 5407
5504: POP
5505: POP
// bunker_list := tmp ;
5506: LD_ADDR_VAR 0 13
5510: PUSH
5511: LD_VAR 0 8
5515: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: LD_VAR 0 13
5525: PUSH
5526: LD_VAR 0 14
5530: ADD
5531: PUSH
5532: FOR_IN
5533: IFFALSE 5556
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5535: LD_VAR 0 2
5539: PPUSH
5540: LD_VAR 0 2
5544: PPUSH
5545: CALL 843 0 1
5549: PPUSH
5550: CALL_OW 431
5554: GO 5532
5556: POP
5557: POP
// while ( personel_counter [ 1 ] ) do
5558: LD_VAR 0 16
5562: PUSH
5563: LD_INT 1
5565: ARRAY
5566: IFFALSE 5674
// begin i := rand ( 1 , bunker_list ) ;
5568: LD_ADDR_VAR 0 2
5572: PUSH
5573: LD_INT 1
5575: PPUSH
5576: LD_VAR 0 13
5580: PPUSH
5581: CALL_OW 12
5585: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5586: LD_INT 0
5588: PPUSH
5589: LD_INT 1
5591: PPUSH
5592: LD_VAR 0 6
5596: PPUSH
5597: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5601: CALL_OW 44
5605: PPUSH
5606: LD_VAR 0 13
5610: PUSH
5611: LD_VAR 0 2
5615: ARRAY
5616: PPUSH
5617: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5621: LD_ADDR_VAR 0 13
5625: PUSH
5626: LD_VAR 0 13
5630: PPUSH
5631: LD_VAR 0 2
5635: PPUSH
5636: CALL_OW 3
5640: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5641: LD_ADDR_VAR 0 16
5645: PUSH
5646: LD_VAR 0 16
5650: PPUSH
5651: LD_INT 1
5653: PPUSH
5654: LD_VAR 0 16
5658: PUSH
5659: LD_INT 1
5661: ARRAY
5662: PUSH
5663: LD_INT 1
5665: MINUS
5666: PPUSH
5667: CALL_OW 1
5671: ST_TO_ADDR
// end ;
5672: GO 5558
// for i = 1 to personel_counter [ 2 ] do
5674: LD_ADDR_VAR 0 2
5678: PUSH
5679: DOUBLE
5680: LD_INT 1
5682: DEC
5683: ST_TO_ADDR
5684: LD_VAR 0 16
5688: PUSH
5689: LD_INT 2
5691: ARRAY
5692: PUSH
5693: FOR_TO
5694: IFFALSE 5725
// begin PrepareHuman ( false , 2 , skill ) ;
5696: LD_INT 0
5698: PPUSH
5699: LD_INT 2
5701: PPUSH
5702: LD_VAR 0 6
5706: PPUSH
5707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5711: CALL_OW 44
5715: PPUSH
5716: LD_INT 16
5718: PPUSH
5719: CALL_OW 52
// end ;
5723: GO 5693
5725: POP
5726: POP
// for i = 1 to personel_counter [ 3 ] do
5727: LD_ADDR_VAR 0 2
5731: PUSH
5732: DOUBLE
5733: LD_INT 1
5735: DEC
5736: ST_TO_ADDR
5737: LD_VAR 0 16
5741: PUSH
5742: LD_INT 3
5744: ARRAY
5745: PUSH
5746: FOR_TO
5747: IFFALSE 5794
// begin PrepareHuman ( false , 3 , skill ) ;
5749: LD_INT 0
5751: PPUSH
5752: LD_INT 3
5754: PPUSH
5755: LD_VAR 0 6
5759: PPUSH
5760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5764: CALL_OW 44
5768: PPUSH
5769: LD_VAR 0 11
5773: PUSH
5774: LD_VAR 0 2
5778: PUSH
5779: LD_INT 2
5781: MOD
5782: PUSH
5783: LD_INT 1
5785: PLUS
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
// end ;
5792: GO 5746
5794: POP
5795: POP
// for i = 1 to personel_counter [ 4 ] do
5796: LD_ADDR_VAR 0 2
5800: PUSH
5801: DOUBLE
5802: LD_INT 1
5804: DEC
5805: ST_TO_ADDR
5806: LD_VAR 0 16
5810: PUSH
5811: LD_INT 4
5813: ARRAY
5814: PUSH
5815: FOR_TO
5816: IFFALSE 5853
// begin PrepareHuman ( false , 4 , skill ) ;
5818: LD_INT 0
5820: PPUSH
5821: LD_INT 4
5823: PPUSH
5824: LD_VAR 0 6
5828: PPUSH
5829: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5833: CALL_OW 44
5837: PPUSH
5838: LD_VAR 0 10
5842: PUSH
5843: LD_INT 1
5845: ARRAY
5846: PPUSH
5847: CALL_OW 52
// end ;
5851: GO 5815
5853: POP
5854: POP
// for i in breastworks_list do
5855: LD_ADDR_VAR 0 2
5859: PUSH
5860: LD_VAR 0 12
5864: PUSH
5865: FOR_IN
5866: IFFALSE 5978
// begin r := GetDir ( i ) ;
5868: LD_ADDR_VAR 0 4
5872: PUSH
5873: LD_VAR 0 2
5877: PPUSH
5878: CALL_OW 254
5882: ST_TO_ADDR
// if r > 3 then
5883: LD_VAR 0 4
5887: PUSH
5888: LD_INT 3
5890: GREATER
5891: IFFALSE 5909
// r := r - 3 else
5893: LD_ADDR_VAR 0 4
5897: PUSH
5898: LD_VAR 0 4
5902: PUSH
5903: LD_INT 3
5905: MINUS
5906: ST_TO_ADDR
5907: GO 5923
// r := r + 3 ;
5909: LD_ADDR_VAR 0 4
5913: PUSH
5914: LD_VAR 0 4
5918: PUSH
5919: LD_INT 3
5921: PLUS
5922: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5923: LD_INT 0
5925: PPUSH
5926: LD_INT 1
5928: PPUSH
5929: LD_VAR 0 6
5933: PPUSH
5934: CALL_OW 380
// un := CreateHuman ;
5938: LD_ADDR_VAR 0 5
5942: PUSH
5943: CALL_OW 44
5947: ST_TO_ADDR
// SetDir ( un , r ) ;
5948: LD_VAR 0 5
5952: PPUSH
5953: LD_VAR 0 4
5957: PPUSH
5958: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5962: LD_VAR 0 5
5966: PPUSH
5967: LD_VAR 0 2
5971: PPUSH
5972: CALL_OW 52
// end ;
5976: GO 5865
5978: POP
5979: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5980: LD_ADDR_VAR 0 8
5984: PUSH
5985: LD_INT 22
5987: PUSH
5988: LD_INT 3
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 25
5997: PUSH
5998: LD_INT 3
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: PPUSH
6009: CALL_OW 69
6013: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
6014: LD_ADDR_VAR 0 4
6018: PUSH
6019: LD_INT 4
6021: PUSH
6022: LD_INT 5
6024: PUSH
6025: LD_INT 6
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: LIST
6032: PUSH
6033: LD_OWVAR 67
6037: ARRAY
6038: ST_TO_ADDR
// for i = 1 to r do
6039: LD_ADDR_VAR 0 2
6043: PUSH
6044: DOUBLE
6045: LD_INT 1
6047: DEC
6048: ST_TO_ADDR
6049: LD_VAR 0 4
6053: PUSH
6054: FOR_TO
6055: IFFALSE 6228
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6057: LD_ADDR_VAR 0 5
6061: PUSH
6062: LD_INT 3
6064: PPUSH
6065: LD_INT 3
6067: PPUSH
6068: LD_INT 22
6070: PUSH
6071: LD_INT 22
6073: PUSH
6074: LD_INT 24
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_VAR 0 2
6086: PUSH
6087: LD_INT 3
6089: MOD
6090: PUSH
6091: LD_INT 1
6093: PLUS
6094: ARRAY
6095: PPUSH
6096: LD_INT 1
6098: PPUSH
6099: LD_INT 1
6101: PPUSH
6102: LD_INT 43
6104: PUSH
6105: LD_INT 44
6107: PUSH
6108: LD_INT 42
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: LD_INT 3
6123: MOD
6124: PUSH
6125: LD_INT 1
6127: PLUS
6128: ARRAY
6129: PPUSH
6130: LD_INT 100
6132: PPUSH
6133: CALL 429 0 7
6137: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6138: LD_VAR 0 5
6142: PPUSH
6143: LD_INT 0
6145: PPUSH
6146: LD_INT 5
6148: PPUSH
6149: CALL_OW 12
6153: PPUSH
6154: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6158: LD_VAR 0 5
6162: PPUSH
6163: LD_INT 5
6165: PPUSH
6166: LD_INT 0
6168: PPUSH
6169: CALL_OW 49
// if i > tmp - 2 then
6173: LD_VAR 0 2
6177: PUSH
6178: LD_VAR 0 8
6182: PUSH
6183: LD_INT 2
6185: MINUS
6186: GREATER
6187: IFFALSE 6191
// continue ;
6189: GO 6054
// ComExitBuilding ( tmp [ i ] ) ;
6191: LD_VAR 0 8
6195: PUSH
6196: LD_VAR 0 2
6200: ARRAY
6201: PPUSH
6202: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6206: LD_VAR 0 8
6210: PUSH
6211: LD_VAR 0 2
6215: ARRAY
6216: PPUSH
6217: LD_VAR 0 5
6221: PPUSH
6222: CALL_OW 180
// end ;
6226: GO 6054
6228: POP
6229: POP
// end ;
6230: LD_VAR 0 1
6234: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6235: LD_INT 22
6237: PUSH
6238: LD_INT 3
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 25
6247: PUSH
6248: LD_INT 2
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PPUSH
6259: CALL_OW 69
6263: IFFALSE 6995
6265: GO 6267
6267: DISABLE
6268: LD_INT 0
6270: PPUSH
6271: PPUSH
6272: PPUSH
6273: PPUSH
6274: PPUSH
// begin enable ;
6275: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6276: LD_ADDR_VAR 0 2
6280: PUSH
6281: LD_INT 6
6283: PPUSH
6284: LD_INT 3
6286: PUSH
6287: LD_INT 24
6289: PUSH
6290: LD_INT 1000
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: PUSH
6301: LD_INT 21
6303: PUSH
6304: LD_INT 3
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PPUSH
6315: CALL_OW 70
6319: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6320: LD_ADDR_VAR 0 4
6324: PUSH
6325: LD_INT 22
6327: PUSH
6328: LD_INT 3
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 25
6337: PUSH
6338: LD_INT 2
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6354: LD_VAR 0 2
6358: NOT
6359: PUSH
6360: LD_EXP 19
6364: NOT
6365: AND
6366: IFFALSE 6436
// begin for i in engs do
6368: LD_ADDR_VAR 0 1
6372: PUSH
6373: LD_VAR 0 4
6377: PUSH
6378: FOR_IN
6379: IFFALSE 6434
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6381: LD_VAR 0 1
6385: PPUSH
6386: CALL_OW 256
6390: PUSH
6391: LD_INT 1000
6393: EQUAL
6394: PUSH
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 314
6404: NOT
6405: AND
6406: PUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 310
6416: NOT
6417: AND
6418: IFFALSE 6432
// ComEnterUnit ( i , ru_dep_main ) ;
6420: LD_VAR 0 1
6424: PPUSH
6425: LD_INT 16
6427: PPUSH
6428: CALL_OW 120
6432: GO 6378
6434: POP
6435: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6436: LD_VAR 0 4
6440: PPUSH
6441: LD_INT 3
6443: PUSH
6444: LD_INT 24
6446: PUSH
6447: LD_INT 650
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PPUSH
6458: CALL_OW 72
6462: IFFALSE 6555
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6464: LD_ADDR_VAR 0 3
6468: PUSH
6469: LD_VAR 0 4
6473: PPUSH
6474: LD_INT 3
6476: PUSH
6477: LD_INT 24
6479: PUSH
6480: LD_INT 650
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: PPUSH
6491: CALL_OW 72
6495: ST_TO_ADDR
// for i in tmp do
6496: LD_ADDR_VAR 0 1
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: FOR_IN
6507: IFFALSE 6553
// if not IsInArea ( i , mainBaseArea ) then
6509: LD_VAR 0 1
6513: PPUSH
6514: LD_INT 14
6516: PPUSH
6517: CALL_OW 308
6521: NOT
6522: IFFALSE 6551
// begin ComMoveXY ( i , 129 , 125 ) ;
6524: LD_VAR 0 1
6528: PPUSH
6529: LD_INT 129
6531: PPUSH
6532: LD_INT 125
6534: PPUSH
6535: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6539: LD_VAR 0 1
6543: PPUSH
6544: LD_INT 1050
6546: PPUSH
6547: CALL_OW 202
// end ;
6551: GO 6506
6553: POP
6554: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6555: LD_ADDR_VAR 0 4
6559: PUSH
6560: LD_VAR 0 4
6564: PPUSH
6565: LD_INT 24
6567: PUSH
6568: LD_INT 650
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PPUSH
6575: CALL_OW 72
6579: ST_TO_ADDR
// if not engs then
6580: LD_VAR 0 4
6584: NOT
6585: IFFALSE 6589
// exit ;
6587: GO 6995
// if filter then
6589: LD_VAR 0 2
6593: IFFALSE 6852
// begin for i in engs do
6595: LD_ADDR_VAR 0 1
6599: PUSH
6600: LD_VAR 0 4
6604: PUSH
6605: FOR_IN
6606: IFFALSE 6630
// if IsInUnit ( i ) then
6608: LD_VAR 0 1
6612: PPUSH
6613: CALL_OW 310
6617: IFFALSE 6628
// ComExitBuilding ( i ) ;
6619: LD_VAR 0 1
6623: PPUSH
6624: CALL_OW 122
6628: GO 6605
6630: POP
6631: POP
// wait ( 3 ) ;
6632: LD_INT 3
6634: PPUSH
6635: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6639: LD_VAR 0 2
6643: PUSH
6644: LD_INT 2
6646: GREATEREQUAL
6647: PUSH
6648: LD_VAR 0 4
6652: PUSH
6653: LD_INT 2
6655: GREATEREQUAL
6656: AND
6657: IFFALSE 6805
// begin for i = 1 to engs / 2 do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: DOUBLE
6665: LD_INT 1
6667: DEC
6668: ST_TO_ADDR
6669: LD_VAR 0 4
6673: PUSH
6674: LD_INT 2
6676: DIVREAL
6677: PUSH
6678: FOR_TO
6679: IFFALSE 6725
// if not HasTask ( engs [ i ] ) then
6681: LD_VAR 0 4
6685: PUSH
6686: LD_VAR 0 1
6690: ARRAY
6691: PPUSH
6692: CALL_OW 314
6696: NOT
6697: IFFALSE 6723
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6699: LD_VAR 0 4
6703: PUSH
6704: LD_VAR 0 1
6708: ARRAY
6709: PPUSH
6710: LD_VAR 0 2
6714: PUSH
6715: LD_INT 1
6717: ARRAY
6718: PPUSH
6719: CALL_OW 130
6723: GO 6678
6725: POP
6726: POP
// for i = engs / 2 + 1 to engs do
6727: LD_ADDR_VAR 0 1
6731: PUSH
6732: DOUBLE
6733: LD_VAR 0 4
6737: PUSH
6738: LD_INT 2
6740: DIVREAL
6741: PUSH
6742: LD_INT 1
6744: PLUS
6745: DEC
6746: ST_TO_ADDR
6747: LD_VAR 0 4
6751: PUSH
6752: FOR_TO
6753: IFFALSE 6801
// if not HasTask ( engs [ i ] ) then
6755: LD_VAR 0 4
6759: PUSH
6760: LD_VAR 0 1
6764: ARRAY
6765: PPUSH
6766: CALL_OW 314
6770: NOT
6771: IFFALSE 6799
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6773: LD_VAR 0 4
6777: PUSH
6778: LD_VAR 0 1
6782: ARRAY
6783: PPUSH
6784: LD_VAR 0 2
6788: PUSH
6789: LD_VAR 0 2
6793: ARRAY
6794: PPUSH
6795: CALL_OW 130
6799: GO 6752
6801: POP
6802: POP
// end else
6803: GO 6852
// for i in engs do
6805: LD_ADDR_VAR 0 1
6809: PUSH
6810: LD_VAR 0 4
6814: PUSH
6815: FOR_IN
6816: IFFALSE 6850
// if not HasTask ( i ) then
6818: LD_VAR 0 1
6822: PPUSH
6823: CALL_OW 314
6827: NOT
6828: IFFALSE 6848
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6830: LD_VAR 0 1
6834: PPUSH
6835: LD_VAR 0 2
6839: PUSH
6840: LD_INT 1
6842: ARRAY
6843: PPUSH
6844: CALL_OW 130
6848: GO 6815
6850: POP
6851: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6852: LD_ADDR_VAR 0 5
6856: PUSH
6857: LD_INT 81
6859: PUSH
6860: LD_INT 3
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: PPUSH
6867: CALL_OW 69
6871: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6872: LD_EXP 19
6876: PUSH
6877: LD_VAR 0 2
6881: NOT
6882: AND
6883: IFFALSE 6995
// begin ComExitBuilding ( engs ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6894: LD_VAR 0 5
6898: PPUSH
6899: LD_EXP 19
6903: PUSH
6904: LD_INT 2
6906: ARRAY
6907: PPUSH
6908: LD_EXP 19
6912: PUSH
6913: LD_INT 3
6915: ARRAY
6916: PPUSH
6917: CALL_OW 73
6921: PPUSH
6922: LD_EXP 19
6926: PUSH
6927: LD_INT 2
6929: ARRAY
6930: PPUSH
6931: LD_EXP 19
6935: PUSH
6936: LD_INT 3
6938: ARRAY
6939: PPUSH
6940: CALL_OW 297
6944: PUSH
6945: LD_INT 10
6947: GREATER
6948: IFFALSE 6995
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6950: LD_VAR 0 4
6954: PPUSH
6955: LD_EXP 19
6959: PUSH
6960: LD_INT 1
6962: ARRAY
6963: PPUSH
6964: LD_EXP 19
6968: PUSH
6969: LD_INT 2
6971: ARRAY
6972: PPUSH
6973: LD_EXP 19
6977: PUSH
6978: LD_INT 3
6980: ARRAY
6981: PPUSH
6982: LD_EXP 19
6986: PUSH
6987: LD_INT 4
6989: ARRAY
6990: PPUSH
6991: CALL_OW 145
// end ; end ;
6995: PPOPN 5
6997: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
6998: LD_INT 16
7000: PPUSH
7001: CALL_OW 256
7005: PUSH
7006: LD_INT 650
7008: LESS
7009: IFFALSE 7092
7011: GO 7013
7013: DISABLE
7014: LD_INT 0
7016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
7017: LD_ADDR_VAR 0 1
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: PUSH
7032: LD_INT 25
7034: PUSH
7035: LD_INT 1
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: PPUSH
7046: CALL_OW 69
7050: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7051: LD_VAR 0 1
7055: PPUSH
7056: CALL_OW 122
// wait ( 3 ) ;
7060: LD_INT 3
7062: PPUSH
7063: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
7067: LD_VAR 0 1
7071: PPUSH
7072: LD_INT 16
7074: PPUSH
7075: CALL_OW 250
7079: PPUSH
7080: LD_INT 16
7082: PPUSH
7083: CALL_OW 251
7087: PPUSH
7088: CALL_OW 114
// end ;
7092: PPOPN 1
7094: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7095: LD_INT 16
7097: PPUSH
7098: CALL_OW 256
7102: PUSH
7103: LD_INT 650
7105: GREATER
7106: PUSH
7107: LD_INT 22
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 25
7119: PUSH
7120: LD_INT 1
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 56
7129: PUSH
7130: EMPTY
7131: LIST
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: PPUSH
7141: CALL_OW 69
7145: AND
7146: IFFALSE 7258
7148: GO 7150
7150: DISABLE
7151: LD_INT 0
7153: PPUSH
7154: PPUSH
// begin enable ;
7155: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7156: LD_ADDR_VAR 0 2
7160: PUSH
7161: LD_INT 22
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: PUSH
7171: LD_INT 25
7173: PUSH
7174: LD_INT 1
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: LD_INT 56
7183: PUSH
7184: EMPTY
7185: LIST
7186: PUSH
7187: LD_INT 3
7189: PUSH
7190: LD_INT 60
7192: PUSH
7193: EMPTY
7194: LIST
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: EMPTY
7201: LIST
7202: LIST
7203: LIST
7204: LIST
7205: PUSH
7206: EMPTY
7207: LIST
7208: PPUSH
7209: CALL_OW 69
7213: ST_TO_ADDR
// if not tmp then
7214: LD_VAR 0 2
7218: NOT
7219: IFFALSE 7223
// exit ;
7221: GO 7258
// for i in tmp do
7223: LD_ADDR_VAR 0 1
7227: PUSH
7228: LD_VAR 0 2
7232: PUSH
7233: FOR_IN
7234: IFFALSE 7256
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7236: LD_VAR 0 1
7240: PPUSH
7241: LD_INT 0
7243: PPUSH
7244: LD_INT 143
7246: PPUSH
7247: LD_INT 143
7249: PPUSH
7250: CALL 2066 0 4
7254: GO 7233
7256: POP
7257: POP
// end ;
7258: PPOPN 2
7260: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 25
7273: PUSH
7274: LD_INT 4
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: IFFALSE 7543
7291: GO 7293
7293: DISABLE
7294: LD_INT 0
7296: PPUSH
7297: PPUSH
7298: PPUSH
// begin enable ;
7299: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7300: LD_ADDR_VAR 0 2
7304: PUSH
7305: LD_INT 14
7307: PPUSH
7308: LD_INT 22
7310: PUSH
7311: LD_INT 3
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PUSH
7318: LD_INT 21
7320: PUSH
7321: LD_INT 1
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: LIST
7349: PPUSH
7350: CALL_OW 70
7354: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7355: LD_ADDR_VAR 0 3
7359: PUSH
7360: LD_INT 22
7362: PUSH
7363: LD_INT 3
7365: PUSH
7366: EMPTY
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 25
7372: PUSH
7373: LD_INT 4
7375: PUSH
7376: EMPTY
7377: LIST
7378: LIST
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: PPUSH
7384: CALL_OW 69
7388: ST_TO_ADDR
// if not doc then
7389: LD_VAR 0 3
7393: NOT
7394: IFFALSE 7398
// exit ;
7396: GO 7543
// if not tmp then
7398: LD_VAR 0 2
7402: NOT
7403: IFFALSE 7494
// begin if not IsInUnit ( doc [ 1 ] ) then
7405: LD_VAR 0 3
7409: PUSH
7410: LD_INT 1
7412: ARRAY
7413: PPUSH
7414: CALL_OW 310
7418: NOT
7419: IFFALSE 7492
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7421: LD_VAR 0 3
7425: PPUSH
7426: LD_INT 22
7428: PUSH
7429: LD_INT 3
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 30
7441: PUSH
7442: LD_INT 6
7444: PUSH
7445: EMPTY
7446: LIST
7447: LIST
7448: PUSH
7449: LD_INT 30
7451: PUSH
7452: LD_INT 7
7454: PUSH
7455: EMPTY
7456: LIST
7457: LIST
7458: PUSH
7459: LD_INT 30
7461: PUSH
7462: LD_INT 8
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: LIST
7473: LIST
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PPUSH
7479: CALL_OW 69
7483: PUSH
7484: LD_INT 1
7486: ARRAY
7487: PPUSH
7488: CALL_OW 120
// exit ;
7492: GO 7543
// end ; if IsInUnit ( doc [ 1 ] ) then
7494: LD_VAR 0 3
7498: PUSH
7499: LD_INT 1
7501: ARRAY
7502: PPUSH
7503: CALL_OW 310
7507: IFFALSE 7518
// ComExitBuilding ( doc ) ;
7509: LD_VAR 0 3
7513: PPUSH
7514: CALL_OW 122
// wait ( 3 ) ;
7518: LD_INT 3
7520: PPUSH
7521: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7525: LD_VAR 0 3
7529: PPUSH
7530: LD_VAR 0 2
7534: PUSH
7535: LD_INT 1
7537: ARRAY
7538: PPUSH
7539: CALL_OW 128
// end ;
7543: PPOPN 3
7545: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7546: LD_INT 22
7548: PUSH
7549: LD_INT 3
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 25
7558: PUSH
7559: LD_INT 3
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 69
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_INT 3
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 21
7587: PUSH
7588: LD_INT 2
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: AND
7604: IFFALSE 8018
7606: GO 7608
7608: DISABLE
7609: LD_INT 0
7611: PPUSH
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
// begin enable ;
7616: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7617: LD_ADDR_VAR 0 2
7621: PUSH
7622: LD_INT 22
7624: PUSH
7625: LD_INT 3
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: LD_INT 21
7634: PUSH
7635: LD_INT 2
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PUSH
7642: LD_INT 3
7644: PUSH
7645: LD_INT 58
7647: PUSH
7648: EMPTY
7649: LIST
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: LIST
7659: PPUSH
7660: CALL_OW 69
7664: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7665: LD_ADDR_VAR 0 4
7669: PUSH
7670: LD_INT 10
7672: PUSH
7673: LD_INT 11
7675: PUSH
7676: LD_INT 12
7678: PUSH
7679: LD_INT 14
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: LIST
7686: LIST
7687: ST_TO_ADDR
// area := 0 ;
7688: LD_ADDR_VAR 0 5
7692: PUSH
7693: LD_INT 0
7695: ST_TO_ADDR
// attacking := false ;
7696: LD_ADDR_VAR 0 3
7700: PUSH
7701: LD_INT 0
7703: ST_TO_ADDR
// for i in tmp do
7704: LD_ADDR_VAR 0 1
7708: PUSH
7709: LD_VAR 0 2
7713: PUSH
7714: FOR_IN
7715: IFFALSE 7801
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7717: LD_VAR 0 1
7721: PPUSH
7722: LD_INT 22
7724: PUSH
7725: LD_INT 1
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PPUSH
7732: CALL_OW 69
7736: PPUSH
7737: LD_VAR 0 1
7741: PPUSH
7742: CALL_OW 74
7746: PPUSH
7747: CALL_OW 296
7751: PUSH
7752: LD_INT 10
7754: LESS
7755: IFFALSE 7799
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7757: LD_VAR 0 1
7761: PPUSH
7762: LD_INT 22
7764: PUSH
7765: LD_INT 1
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL_OW 69
7776: PPUSH
7777: LD_VAR 0 1
7781: PPUSH
7782: CALL_OW 74
7786: PPUSH
7787: CALL_OW 115
// attacking := true ;
7791: LD_ADDR_VAR 0 3
7795: PUSH
7796: LD_INT 1
7798: ST_TO_ADDR
// end ;
7799: GO 7714
7801: POP
7802: POP
// if attacking then
7803: LD_VAR 0 3
7807: IFFALSE 7811
// exit ;
7809: GO 8018
// for i in areas do
7811: LD_ADDR_VAR 0 1
7815: PUSH
7816: LD_VAR 0 4
7820: PUSH
7821: FOR_IN
7822: IFFALSE 7859
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7824: LD_VAR 0 1
7828: PPUSH
7829: LD_INT 22
7831: PUSH
7832: LD_INT 1
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PPUSH
7839: CALL_OW 70
7843: IFFALSE 7857
// begin area := i ;
7845: LD_ADDR_VAR 0 5
7849: PUSH
7850: LD_VAR 0 1
7854: ST_TO_ADDR
// break ;
7855: GO 7859
// end ;
7857: GO 7821
7859: POP
7860: POP
// if area then
7861: LD_VAR 0 5
7865: IFFALSE 8018
// begin for i in tmp do
7867: LD_ADDR_VAR 0 1
7871: PUSH
7872: LD_VAR 0 2
7876: PUSH
7877: FOR_IN
7878: IFFALSE 8016
// begin if GetFuel ( i ) < 33 then
7880: LD_VAR 0 1
7884: PPUSH
7885: CALL_OW 261
7889: PUSH
7890: LD_INT 33
7892: LESS
7893: IFFALSE 7907
// SetFuel ( i , 33 ) ;
7895: LD_VAR 0 1
7899: PPUSH
7900: LD_INT 33
7902: PPUSH
7903: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7907: LD_VAR 0 1
7911: PPUSH
7912: LD_INT 22
7914: PUSH
7915: LD_INT 1
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PPUSH
7922: CALL_OW 69
7926: PPUSH
7927: LD_VAR 0 1
7931: PPUSH
7932: CALL_OW 74
7936: PPUSH
7937: CALL_OW 296
7941: PUSH
7942: LD_INT 10
7944: LESS
7945: IFFALSE 7983
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7947: LD_VAR 0 1
7951: PPUSH
7952: LD_INT 22
7954: PUSH
7955: LD_INT 1
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PPUSH
7962: CALL_OW 69
7966: PPUSH
7967: LD_VAR 0 1
7971: PPUSH
7972: CALL_OW 74
7976: PPUSH
7977: CALL_OW 115
7981: GO 8014
// if not IsInArea ( i , area ) then
7983: LD_VAR 0 1
7987: PPUSH
7988: LD_VAR 0 5
7992: PPUSH
7993: CALL_OW 308
7997: NOT
7998: IFFALSE 8014
// ComMoveToArea ( i , area ) ;
8000: LD_VAR 0 1
8004: PPUSH
8005: LD_VAR 0 5
8009: PPUSH
8010: CALL_OW 113
// end ;
8014: GO 7877
8016: POP
8017: POP
// end ; end ;
8018: PPOPN 5
8020: END
// every 10 10$00 do var i , j , un , veh , time , count ;
8021: GO 8023
8023: DISABLE
8024: LD_INT 0
8026: PPUSH
8027: PPUSH
8028: PPUSH
8029: PPUSH
8030: PPUSH
8031: PPUSH
// begin uc_side := 3 ;
8032: LD_ADDR_OWVAR 20
8036: PUSH
8037: LD_INT 3
8039: ST_TO_ADDR
// uc_nation := 3 ;
8040: LD_ADDR_OWVAR 21
8044: PUSH
8045: LD_INT 3
8047: ST_TO_ADDR
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8048: LD_ADDR_VAR 0 5
8052: PUSH
8053: LD_INT 16800
8055: PUSH
8056: LD_INT 14700
8058: PUSH
8059: LD_INT 12600
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: LIST
8066: PUSH
8067: LD_OWVAR 67
8071: ARRAY
8072: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8073: LD_ADDR_VAR 0 6
8077: PUSH
8078: LD_INT 2
8080: PUSH
8081: LD_INT 2
8083: PUSH
8084: LD_INT 3
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: LIST
8091: PUSH
8092: LD_OWVAR 67
8096: ARRAY
8097: ST_TO_ADDR
// for i = 1 to count do
8098: LD_ADDR_VAR 0 1
8102: PUSH
8103: DOUBLE
8104: LD_INT 1
8106: DEC
8107: ST_TO_ADDR
8108: LD_VAR 0 6
8112: PUSH
8113: FOR_TO
8114: IFFALSE 8294
// begin wait ( time ) ;
8116: LD_VAR 0 5
8120: PPUSH
8121: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8125: LD_ADDR_VAR 0 2
8129: PUSH
8130: DOUBLE
8131: LD_INT 1
8133: DEC
8134: ST_TO_ADDR
8135: LD_INT 1
8137: PPUSH
8138: LD_OWVAR 67
8142: PPUSH
8143: CALL_OW 12
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8290
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8151: LD_ADDR_VAR 0 4
8155: PUSH
8156: LD_INT 3
8158: PPUSH
8159: LD_INT 3
8161: PPUSH
8162: LD_INT 22
8164: PPUSH
8165: LD_INT 1
8167: PPUSH
8168: LD_INT 1
8170: PPUSH
8171: LD_INT 43
8173: PUSH
8174: LD_INT 44
8176: PUSH
8177: LD_INT 42
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: LIST
8184: PUSH
8185: LD_VAR 0 1
8189: PUSH
8190: LD_INT 3
8192: MOD
8193: PUSH
8194: LD_INT 1
8196: PLUS
8197: ARRAY
8198: PPUSH
8199: LD_INT 80
8201: PPUSH
8202: CALL 429 0 7
8206: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8207: LD_VAR 0 4
8211: PPUSH
8212: LD_INT 13
8214: PPUSH
8215: LD_INT 0
8217: PPUSH
8218: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8222: LD_INT 0
8224: PPUSH
8225: LD_INT 3
8227: PPUSH
8228: LD_INT 4
8230: PUSH
8231: LD_INT 5
8233: PUSH
8234: LD_INT 5
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: LIST
8241: PUSH
8242: LD_OWVAR 67
8246: ARRAY
8247: PPUSH
8248: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8252: CALL_OW 44
8256: PPUSH
8257: LD_VAR 0 4
8261: PPUSH
8262: CALL_OW 52
// wait ( 0 0$01 ) ;
8266: LD_INT 35
8268: PPUSH
8269: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8273: LD_VAR 0 4
8277: PPUSH
8278: LD_INT 143
8280: PPUSH
8281: LD_INT 143
8283: PPUSH
8284: CALL_OW 111
// end ;
8288: GO 8148
8290: POP
8291: POP
// end ;
8292: GO 8113
8294: POP
8295: POP
// end ;
8296: PPOPN 6
8298: END
// every 8 8$00 do var i , un , time ;
8299: GO 8301
8301: DISABLE
8302: LD_INT 0
8304: PPUSH
8305: PPUSH
8306: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
8307: LD_ADDR_VAR 0 3
8311: PUSH
8312: LD_INT 4200
8314: PUSH
8315: LD_INT 2100
8317: PUSH
8318: LD_INT 1050
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: LIST
8325: ST_TO_ADDR
// wait ( time ) ;
8326: LD_VAR 0 3
8330: PPUSH
8331: CALL_OW 67
// uc_side := 3 ;
8335: LD_ADDR_OWVAR 20
8339: PUSH
8340: LD_INT 3
8342: ST_TO_ADDR
// uc_nation := 3 ;
8343: LD_ADDR_OWVAR 21
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// for i = 1 to 2 do
8351: LD_ADDR_VAR 0 1
8355: PUSH
8356: DOUBLE
8357: LD_INT 1
8359: DEC
8360: ST_TO_ADDR
8361: LD_INT 2
8363: PUSH
8364: FOR_TO
8365: IFFALSE 8428
// begin PrepareHuman ( false , 1 , 4 ) ;
8367: LD_INT 0
8369: PPUSH
8370: LD_INT 1
8372: PPUSH
8373: LD_INT 4
8375: PPUSH
8376: CALL_OW 380
// un := CreateHuman ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: CALL_OW 44
8389: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8390: LD_VAR 0 2
8394: PPUSH
8395: LD_INT 16
8397: PPUSH
8398: CALL_OW 52
// ComExitBuilding ( un ) ;
8402: LD_VAR 0 2
8406: PPUSH
8407: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8411: LD_VAR 0 2
8415: PPUSH
8416: LD_INT 41
8418: PPUSH
8419: LD_INT 76
8421: PPUSH
8422: CALL_OW 174
// end ;
8426: GO 8364
8428: POP
8429: POP
// end ; end_of_file
8430: PPOPN 3
8432: END
// export function Action ; begin
8433: LD_INT 0
8435: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8436: LD_INT 28
8438: PPUSH
8439: LD_INT 3
8441: PPUSH
8442: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8446: LD_INT 41
8448: PPUSH
8449: LD_INT 76
8451: PPUSH
8452: LD_INT 1
8454: PPUSH
8455: LD_INT 10
8457: PPUSH
8458: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8462: LD_INT 41
8464: PPUSH
8465: LD_INT 76
8467: PPUSH
8468: LD_INT 1
8470: PPUSH
8471: CALL_OW 331
// InGameOn ;
8475: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8479: LD_EXP 18
8483: PPUSH
8484: LD_STRING D2-Har-1
8486: PPUSH
8487: CALL_OW 94
// InGameOff ;
8491: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8495: LD_STRING M1
8497: PPUSH
8498: CALL_OW 337
// end ;
8502: LD_VAR 0 1
8506: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8507: LD_EXP 4
8511: PUSH
8512: LD_INT 1
8514: GREATER
8515: IFFALSE 8606
8517: GO 8519
8519: DISABLE
8520: LD_INT 0
8522: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8523: LD_ADDR_VAR 0 1
8527: PUSH
8528: LD_INT 1
8530: PPUSH
8531: CALL 517 0 1
8535: PUSH
8536: LD_INT 1
8538: ARRAY
8539: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8540: LD_VAR 0 1
8544: PPUSH
8545: LD_STRING D2a-Sol1-1
8547: PPUSH
8548: CALL_OW 88
// if not un then
8552: LD_VAR 0 1
8556: NOT
8557: IFFALSE 8588
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8559: LD_ADDR_VAR 0 1
8563: PUSH
8564: LD_INT 2
8566: PPUSH
8567: CALL 517 0 1
8571: PUSH
8572: LD_INT 1
8574: ARRAY
8575: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8576: LD_VAR 0 1
8580: PPUSH
8581: LD_STRING D2a-FSol1-1
8583: PPUSH
8584: CALL_OW 88
// end ; if Khatam then
8588: LD_EXP 16
8592: IFFALSE 8606
// Say ( Khatam , D3b-Khat-3 ) ;
8594: LD_EXP 16
8598: PPUSH
8599: LD_STRING D3b-Khat-3
8601: PPUSH
8602: CALL_OW 88
// end ;
8606: PPOPN 1
8608: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8609: LD_EXP 14
8613: PUSH
8614: LD_EXP 17
8618: NOT
8619: AND
8620: PUSH
8621: LD_INT 22
8623: PUSH
8624: LD_INT 1
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PUSH
8631: LD_INT 92
8633: PUSH
8634: LD_EXP 14
8638: PPUSH
8639: CALL_OW 250
8643: PUSH
8644: LD_EXP 14
8648: PPUSH
8649: CALL_OW 251
8653: PUSH
8654: LD_INT 7
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: LIST
8661: LIST
8662: PUSH
8663: EMPTY
8664: LIST
8665: LIST
8666: PPUSH
8667: CALL_OW 69
8671: AND
8672: PUSH
8673: LD_INT 1
8675: PPUSH
8676: CALL_OW 463
8680: NOT
8681: AND
8682: IFFALSE 9269
8684: GO 8686
8686: DISABLE
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// begin InGameOn ;
8691: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8695: LD_ADDR_VAR 0 2
8699: PUSH
8700: LD_INT 22
8702: PUSH
8703: LD_INT 0
8705: PUSH
8706: EMPTY
8707: LIST
8708: LIST
8709: PUSH
8710: LD_INT 25
8712: PUSH
8713: LD_INT 12
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PPUSH
8724: CALL_OW 69
8728: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8729: LD_ADDR_VAR 0 2
8733: PUSH
8734: LD_VAR 0 2
8738: PPUSH
8739: LD_EXP 14
8743: PPUSH
8744: CALL_OW 74
8748: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8749: LD_ADDR_VAR 0 1
8753: PUSH
8754: LD_INT 22
8756: PUSH
8757: LD_INT 1
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: PUSH
8764: LD_INT 21
8766: PUSH
8767: LD_INT 1
8769: PUSH
8770: EMPTY
8771: LIST
8772: LIST
8773: PUSH
8774: LD_INT 91
8776: PUSH
8777: LD_EXP 14
8781: PUSH
8782: LD_INT 20
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: LIST
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: PUSH
8800: FOR_IN
8801: IFFALSE 8819
// ComTurnUnit ( i , Frank ) ;
8803: LD_VAR 0 1
8807: PPUSH
8808: LD_EXP 14
8812: PPUSH
8813: CALL_OW 119
8817: GO 8800
8819: POP
8820: POP
// SetSide ( Frank , 1 ) ;
8821: LD_EXP 14
8825: PPUSH
8826: LD_INT 1
8828: PPUSH
8829: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8833: LD_EXP 8
8837: PPUSH
8838: LD_EXP 14
8842: PPUSH
8843: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8847: LD_EXP 8
8851: PPUSH
8852: LD_EXP 14
8856: PPUSH
8857: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8861: LD_EXP 14
8865: PPUSH
8866: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8870: LD_EXP 14
8874: PPUSH
8875: LD_STRING D3a-Frank-1
8877: PPUSH
8878: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8882: LD_VAR 0 2
8886: PPUSH
8887: LD_INT 42
8889: PPUSH
8890: LD_INT 78
8892: PPUSH
8893: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
8897: LD_VAR 0 2
8901: PPUSH
8902: LD_EXP 14
8906: PPUSH
8907: CALL_OW 179
// if Lisa then
8911: LD_EXP 13
8915: IFFALSE 8929
// Say ( Lisa , D3a-Lisa-1 ) ;
8917: LD_EXP 13
8921: PPUSH
8922: LD_STRING D3a-Lisa-1
8924: PPUSH
8925: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
8929: LD_EXP 8
8933: PPUSH
8934: LD_STRING D3a-JMM-1
8936: PPUSH
8937: CALL_OW 88
// if Cyrus then
8941: LD_EXP 12
8945: IFFALSE 8959
// Say ( Cyrus , D3a-Cyrus-1 ) ;
8947: LD_EXP 12
8951: PPUSH
8952: LD_STRING D3a-Cyrus-1
8954: PPUSH
8955: CALL_OW 88
// if GetRandom ( sex_male ) then
8959: LD_INT 1
8961: PPUSH
8962: CALL 517 0 1
8966: IFFALSE 8987
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
8968: LD_INT 1
8970: PPUSH
8971: CALL 517 0 1
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PPUSH
8980: LD_STRING D3a-Sol1-1
8982: PPUSH
8983: CALL_OW 88
// if GetRandom ( sex_female ) then
8987: LD_INT 2
8989: PPUSH
8990: CALL 517 0 1
8994: IFFALSE 9015
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
8996: LD_INT 2
8998: PPUSH
8999: CALL 517 0 1
9003: PUSH
9004: LD_INT 1
9006: ARRAY
9007: PPUSH
9008: LD_STRING D3a-FSol1-1
9010: PPUSH
9011: CALL_OW 88
// if Gladstone then
9015: LD_EXP 15
9019: IFFALSE 9033
// Say ( Gladstone , D3a-Glad-1 ) ;
9021: LD_EXP 15
9025: PPUSH
9026: LD_STRING D3a-Glad-1
9028: PPUSH
9029: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
9033: LD_VAR 0 2
9037: PPUSH
9038: LD_INT 60
9040: PPUSH
9041: LD_INT 113
9043: PPUSH
9044: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9048: LD_EXP 14
9052: PPUSH
9053: LD_STRING D3a-Frank-2
9055: PPUSH
9056: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9060: LD_EXP 14
9064: PPUSH
9065: LD_EXP 8
9069: PPUSH
9070: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9074: LD_EXP 8
9078: PPUSH
9079: LD_STRING D3a-JMM-2
9081: PPUSH
9082: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 4
9091: PPUSH
9092: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9096: LD_INT 85
9098: PPUSH
9099: LD_INT 134
9101: PPUSH
9102: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9106: LD_EXP 14
9110: PPUSH
9111: LD_STRING D3a-Frank-3
9113: PPUSH
9114: CALL_OW 88
// Wait ( 0 0$01 ) ;
9118: LD_INT 35
9120: PPUSH
9121: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9125: LD_INT 166
9127: PPUSH
9128: LD_INT 136
9130: PPUSH
9131: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9135: LD_EXP 8
9139: PPUSH
9140: LD_STRING D3a-JMM-3
9142: PPUSH
9143: CALL_OW 88
// Wait ( 0 0$01 ) ;
9147: LD_INT 35
9149: PPUSH
9150: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9154: LD_EXP 14
9158: PPUSH
9159: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9163: LD_EXP 14
9167: PPUSH
9168: LD_STRING D3a-Frank-4
9170: PPUSH
9171: CALL_OW 88
// if Lisa then
9175: LD_EXP 13
9179: IFFALSE 9193
// Say ( Lisa , D3a-Lisa-4 ) ;
9181: LD_EXP 13
9185: PPUSH
9186: LD_STRING D3a-Lisa-4
9188: PPUSH
9189: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9193: LD_EXP 8
9197: PPUSH
9198: LD_STRING D3a-JMM-4
9200: PPUSH
9201: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9205: LD_EXP 14
9209: PPUSH
9210: LD_STRING D3a-Frank-5
9212: PPUSH
9213: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9217: LD_EXP 8
9221: PPUSH
9222: LD_STRING D3a-JMM-5
9224: PPUSH
9225: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9229: LD_EXP 14
9233: PPUSH
9234: LD_STRING D3a-Frank-6
9236: PPUSH
9237: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9241: LD_EXP 8
9245: PPUSH
9246: LD_STRING D3a-JMM-6
9248: PPUSH
9249: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9253: LD_EXP 14
9257: PPUSH
9258: LD_STRING D3a-Frank-7
9260: PPUSH
9261: CALL_OW 88
// InGameOff ;
9265: CALL_OW 9
// end ;
9269: PPOPN 2
9271: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9272: LD_EXP 17
9276: PUSH
9277: LD_EXP 14
9281: NOT
9282: AND
9283: PUSH
9284: LD_INT 22
9286: PUSH
9287: LD_INT 1
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 92
9296: PUSH
9297: LD_EXP 17
9301: PPUSH
9302: CALL_OW 250
9306: PUSH
9307: LD_EXP 17
9311: PPUSH
9312: CALL_OW 251
9316: PUSH
9317: LD_INT 7
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: PPUSH
9330: CALL_OW 69
9334: AND
9335: PUSH
9336: LD_INT 1
9338: PPUSH
9339: CALL_OW 463
9343: NOT
9344: AND
9345: IFFALSE 9525
9347: GO 9349
9349: DISABLE
// begin InGameOn ;
9350: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9354: LD_EXP 8
9358: PPUSH
9359: LD_EXP 17
9363: PPUSH
9364: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9368: LD_EXP 17
9372: PPUSH
9373: LD_EXP 8
9377: PPUSH
9378: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9382: LD_EXP 17
9386: PPUSH
9387: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9391: LD_EXP 17
9395: PPUSH
9396: LD_STRING D3b-Yam-1
9398: PPUSH
9399: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9403: LD_EXP 8
9407: PPUSH
9408: LD_STRING D3b-JMM-1
9410: PPUSH
9411: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9415: LD_INT 1
9417: PPUSH
9418: LD_INT 4
9420: PPUSH
9421: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9425: LD_INT 85
9427: PPUSH
9428: LD_INT 134
9430: PPUSH
9431: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9435: LD_EXP 17
9439: PPUSH
9440: LD_STRING D3b-Yam-2
9442: PPUSH
9443: CALL_OW 88
// Wait ( 0 0$01 ) ;
9447: LD_INT 35
9449: PPUSH
9450: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9454: LD_EXP 8
9458: PPUSH
9459: LD_STRING D3b-JMM-2
9461: PPUSH
9462: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9466: LD_INT 166
9468: PPUSH
9469: LD_INT 136
9471: PPUSH
9472: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9476: LD_EXP 17
9480: PPUSH
9481: LD_STRING D3b-Yam-3
9483: PPUSH
9484: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9488: LD_EXP 8
9492: PPUSH
9493: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9497: LD_EXP 8
9501: PPUSH
9502: LD_STRING D3b-JMM-3a
9504: PPUSH
9505: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9509: LD_EXP 17
9513: PPUSH
9514: LD_INT 1
9516: PPUSH
9517: CALL_OW 235
// InGameOff ;
9521: CALL_OW 9
// end ;
9525: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9526: LD_INT 7
9528: PPUSH
9529: LD_INT 22
9531: PUSH
9532: LD_INT 1
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: LD_INT 3
9541: PUSH
9542: LD_INT 24
9544: PUSH
9545: LD_INT 1000
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: PPUSH
9560: CALL_OW 70
9564: IFFALSE 10020
9566: GO 9568
9568: DISABLE
9569: LD_INT 0
9571: PPUSH
9572: PPUSH
9573: PPUSH
9574: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9582: LD_ADDR_VAR 0 1
9586: PUSH
9587: LD_INT 7
9589: PPUSH
9590: LD_INT 22
9592: PUSH
9593: LD_INT 1
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 3
9602: PUSH
9603: LD_INT 24
9605: PUSH
9606: LD_INT 1000
9608: PUSH
9609: EMPTY
9610: LIST
9611: LIST
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PPUSH
9621: CALL_OW 70
9625: ST_TO_ADDR
// if not un then
9626: LD_VAR 0 1
9630: NOT
9631: IFFALSE 9635
// continue ;
9633: GO 9575
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9635: LD_ADDR_VAR 0 3
9639: PUSH
9640: LD_VAR 0 1
9644: PUSH
9645: LD_INT 1
9647: ARRAY
9648: PPUSH
9649: CALL 3414 0 1
9653: ST_TO_ADDR
// until tw ;
9654: LD_VAR 0 3
9658: IFFALSE 9575
// DialogueOn ;
9660: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9664: LD_VAR 0 3
9668: PPUSH
9669: CALL_OW 87
// if Lisa then
9673: LD_EXP 13
9677: IFFALSE 9705
// begin Say ( Lisa , D5-Lisa-1 ) ;
9679: LD_EXP 13
9683: PPUSH
9684: LD_STRING D5-Lisa-1
9686: PPUSH
9687: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9691: LD_EXP 8
9695: PPUSH
9696: LD_STRING D5-JMM-1a
9698: PPUSH
9699: CALL_OW 88
// end else
9703: GO 9717
// Say ( JMM , D5-JMM-1 ) ;
9705: LD_EXP 8
9709: PPUSH
9710: LD_STRING D5-JMM-1
9712: PPUSH
9713: CALL_OW 88
// DialogueOff ;
9717: CALL_OW 7
// while ( true ) do
9721: LD_INT 1
9723: IFFALSE 9779
// begin wait ( 0 0$01 ) ;
9725: LD_INT 35
9727: PPUSH
9728: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9732: LD_ADDR_VAR 0 2
9736: PUSH
9737: LD_INT 8
9739: PPUSH
9740: LD_INT 30
9742: PUSH
9743: LD_INT 26
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: LD_INT 101
9752: PUSH
9753: LD_INT 1
9755: PUSH
9756: EMPTY
9757: LIST
9758: LIST
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PPUSH
9764: CALL_OW 71
9768: ST_TO_ADDR
// if x then
9769: LD_VAR 0 2
9773: IFFALSE 9777
// break ;
9775: GO 9779
// end ;
9777: GO 9721
// CenterOnUnits ( x [ 1 ] ) ;
9779: LD_VAR 0 2
9783: PUSH
9784: LD_INT 1
9786: ARRAY
9787: PPUSH
9788: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9792: LD_EXP 14
9796: PUSH
9797: LD_EXP 14
9801: PPUSH
9802: CALL_OW 255
9806: PUSH
9807: LD_INT 1
9809: EQUAL
9810: AND
9811: IFFALSE 9827
// Say ( Frank , D5a-Frank-1 ) else
9813: LD_EXP 14
9817: PPUSH
9818: LD_STRING D5a-Frank-1
9820: PPUSH
9821: CALL_OW 88
9825: GO 9881
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9827: LD_EXP 17
9831: PUSH
9832: LD_EXP 17
9836: PPUSH
9837: CALL_OW 255
9841: PUSH
9842: LD_INT 1
9844: EQUAL
9845: AND
9846: IFFALSE 9862
// Say ( Kikuchi , D5a-Yam-1 ) else
9848: LD_EXP 17
9852: PPUSH
9853: LD_STRING D5a-Yam-1
9855: PPUSH
9856: CALL_OW 88
9860: GO 9881
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9862: LD_INT 1
9864: PPUSH
9865: CALL 517 0 1
9869: PUSH
9870: LD_INT 1
9872: ARRAY
9873: PPUSH
9874: LD_STRING D5a-Sol1-1
9876: PPUSH
9877: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9881: LD_EXP 8
9885: PPUSH
9886: LD_STRING D5a-JMM-1
9888: PPUSH
9889: CALL_OW 88
// if Cyrus then
9893: LD_EXP 12
9897: IFFALSE 9911
// Say ( Cyrus , D5a-Cyrus-1 ) ;
9899: LD_EXP 12
9903: PPUSH
9904: LD_STRING D5a-Cyrus-1
9906: PPUSH
9907: CALL_OW 88
// x := false ;
9911: LD_ADDR_VAR 0 2
9915: PUSH
9916: LD_INT 0
9918: ST_TO_ADDR
// while ( true ) do
9919: LD_INT 1
9921: IFFALSE 10008
// begin wait ( 0 0$01 ) ;
9923: LD_INT 35
9925: PPUSH
9926: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
9930: LD_ADDR_VAR 0 4
9934: PUSH
9935: LD_INT 2
9937: PUSH
9938: LD_INT 30
9940: PUSH
9941: LD_INT 0
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: PUSH
9948: LD_INT 30
9950: PUSH
9951: LD_INT 1
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PUSH
9958: EMPTY
9959: LIST
9960: LIST
9961: LIST
9962: PPUSH
9963: CALL_OW 69
9967: PUSH
9968: LD_INT 1
9970: DIFF
9971: PUSH
9972: FOR_IN
9973: IFFALSE 9996
// if BaseNeedEnergy ( i ) then
9975: LD_VAR 0 4
9979: PPUSH
9980: CALL 2539 0 1
9984: IFFALSE 9994
// x := true ;
9986: LD_ADDR_VAR 0 2
9990: PUSH
9991: LD_INT 1
9993: ST_TO_ADDR
9994: GO 9972
9996: POP
9997: POP
// if x then
9998: LD_VAR 0 2
10002: IFFALSE 10006
// break ;
10004: GO 10008
// end ;
10006: GO 9919
// Say ( JMM , D5b-JMM-1 ) ;
10008: LD_EXP 8
10012: PPUSH
10013: LD_STRING D5b-JMM-1
10015: PPUSH
10016: CALL_OW 88
// end ;
10020: PPOPN 4
10022: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
10023: LD_EXP 5
10027: PUSH
10028: LD_INT 1
10030: ARRAY
10031: PUSH
10032: LD_OWVAR 1
10036: LESS
10037: IFFALSE 10237
10039: GO 10041
10041: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10042: LD_INT 16
10044: PPUSH
10045: CALL_OW 301
10049: NOT
10050: IFFALSE 10073
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10052: LD_EXP 18
10056: PPUSH
10057: LD_STRING D3b-Har-3
10059: PPUSH
10060: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10064: LD_STRING M2a
10066: PPUSH
10067: CALL_OW 337
// end else
10071: GO 10092
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10073: LD_EXP 18
10077: PPUSH
10078: LD_STRING D3b-Har-3a
10080: PPUSH
10081: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10085: LD_STRING M2
10087: PPUSH
10088: CALL_OW 337
// end ; can_end := true ;
10092: LD_ADDR_EXP 6
10096: PUSH
10097: LD_INT 1
10099: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10100: LD_INT 9
10102: PPUSH
10103: LD_INT 1
10105: PPUSH
10106: CALL_OW 424
// Wait ( 0 0$02 ) ;
10110: LD_INT 70
10112: PPUSH
10113: CALL_OW 67
// if Lisa then
10117: LD_EXP 13
10121: IFFALSE 10135
// Say ( Lisa , D3b-Lisa ) ;
10123: LD_EXP 13
10127: PPUSH
10128: LD_STRING D3b-Lisa
10130: PPUSH
10131: CALL_OW 88
// if Bobby then
10135: LD_EXP 11
10139: IFFALSE 10153
// Say ( Bobby , D3b-Bobby-3 ) ;
10141: LD_EXP 11
10145: PPUSH
10146: LD_STRING D3b-Bobby-3
10148: PPUSH
10149: CALL_OW 88
// if Cyrus then
10153: LD_EXP 12
10157: IFFALSE 10171
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10159: LD_EXP 12
10163: PPUSH
10164: LD_STRING D3b-Cyrus-3
10166: PPUSH
10167: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10171: LD_EXP 14
10175: PUSH
10176: LD_EXP 14
10180: PPUSH
10181: CALL_OW 255
10185: PUSH
10186: LD_INT 1
10188: EQUAL
10189: AND
10190: IFFALSE 10204
// Say ( Frank , D3b-Frank-3 ) ;
10192: LD_EXP 14
10196: PPUSH
10197: LD_STRING D3b-Frank-3
10199: PPUSH
10200: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10204: LD_EXP 17
10208: PUSH
10209: LD_EXP 17
10213: PPUSH
10214: CALL_OW 255
10218: PUSH
10219: LD_INT 1
10221: EQUAL
10222: AND
10223: IFFALSE 10237
// Say ( Kikuchi , D3b-Yam-4 ) ;
10225: LD_EXP 17
10229: PPUSH
10230: LD_STRING D3b-Yam-4
10232: PPUSH
10233: CALL_OW 88
// end ;
10237: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10238: LD_EXP 5
10242: PUSH
10243: LD_INT 2
10245: ARRAY
10246: PUSH
10247: LD_OWVAR 1
10251: LESS
10252: IFFALSE 10284
10254: GO 10256
10256: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10257: LD_EXP 18
10261: PPUSH
10262: LD_STRING D4-Har-1
10264: PPUSH
10265: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10269: LD_STRING M3
10271: PPUSH
10272: CALL_OW 337
// must_end := true ;
10276: LD_ADDR_EXP 7
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// end ;
10284: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10285: LD_EXP 5
10289: PUSH
10290: LD_INT 3
10292: ARRAY
10293: PUSH
10294: LD_OWVAR 1
10298: LESS
10299: IFFALSE 10330
10301: GO 10303
10303: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10304: LD_INT 16
10306: PPUSH
10307: CALL_OW 301
10311: NOT
10312: IFFALSE 10323
// YouLost ( TimeOut1 ) else
10314: LD_STRING TimeOut1
10316: PPUSH
10317: CALL_OW 104
10321: GO 10330
// YouLost ( TimeOut2 ) ;
10323: LD_STRING TimeOut2
10325: PPUSH
10326: CALL_OW 104
// end ;
10330: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp , m1 , m2 , m3 ;
10331: LD_EXP 8
10335: PPUSH
10336: LD_INT 9
10338: PPUSH
10339: CALL_OW 308
10343: PUSH
10344: LD_EXP 6
10348: AND
10349: IFFALSE 11432
10351: GO 10353
10353: DISABLE
10354: LD_INT 0
10356: PPUSH
10357: PPUSH
10358: PPUSH
10359: PPUSH
10360: PPUSH
10361: PPUSH
// begin wait_on := false ;
10362: LD_ADDR_VAR 0 1
10366: PUSH
10367: LD_INT 0
10369: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10370: LD_INT 1
10372: PPUSH
10373: CALL 2616 0 1
10377: PUSH
10378: LD_INT 0
10380: PLUS
10381: PUSH
10382: LD_INT 1
10384: PPUSH
10385: LD_INT 9
10387: PPUSH
10388: CALL 2707 0 2
10392: PUSH
10393: LD_INT 1
10395: PPUSH
10396: LD_INT 9
10398: PPUSH
10399: CALL 2754 0 2
10403: ADD
10404: PUSH
10405: LD_INT 0
10407: PLUS
10408: GREATER
10409: IFFALSE 10458
// case Query ( Q1 ) of 1 :
10411: LD_STRING Q1
10413: PPUSH
10414: CALL_OW 97
10418: PUSH
10419: LD_INT 1
10421: DOUBLE
10422: EQUAL
10423: IFTRUE 10427
10425: GO 10438
10427: POP
// wait_on := true ; 2 :
10428: LD_ADDR_VAR 0 1
10432: PUSH
10433: LD_INT 1
10435: ST_TO_ADDR
10436: GO 10458
10438: LD_INT 2
10440: DOUBLE
10441: EQUAL
10442: IFTRUE 10446
10444: GO 10457
10446: POP
// wait_on := false ; end ;
10447: LD_ADDR_VAR 0 1
10451: PUSH
10452: LD_INT 0
10454: ST_TO_ADDR
10455: GO 10458
10457: POP
// repeat wait ( 0 0$01 ) ;
10458: LD_INT 35
10460: PPUSH
10461: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10465: LD_VAR 0 1
10469: NOT
10470: PUSH
10471: LD_INT 1
10473: PPUSH
10474: CALL 2616 0 1
10478: PUSH
10479: LD_INT 0
10481: PLUS
10482: PUSH
10483: LD_INT 1
10485: PPUSH
10486: LD_INT 9
10488: PPUSH
10489: CALL 2707 0 2
10493: PUSH
10494: LD_INT 1
10496: PPUSH
10497: LD_INT 9
10499: PPUSH
10500: CALL 2754 0 2
10504: ADD
10505: PUSH
10506: LD_INT 0
10508: PLUS
10509: EQUAL
10510: OR
10511: IFFALSE 10458
// DialogueOn ;
10513: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10517: LD_EXP 8
10521: PPUSH
10522: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10526: LD_EXP 8
10530: PPUSH
10531: LD_STRING D6-JMM-1
10533: PPUSH
10534: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10538: LD_EXP 18
10542: PPUSH
10543: LD_STRING D6-Har-1
10545: PPUSH
10546: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10550: LD_EXP 8
10554: PPUSH
10555: LD_STRING D6-JMM-2
10557: PPUSH
10558: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10562: LD_EXP 18
10566: PPUSH
10567: LD_STRING D6-Har-2
10569: PPUSH
10570: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10574: LD_EXP 8
10578: PPUSH
10579: LD_STRING D6-JMM-3
10581: PPUSH
10582: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10586: LD_EXP 18
10590: PPUSH
10591: LD_STRING D6-Har-3
10593: PPUSH
10594: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10598: LD_EXP 8
10602: PPUSH
10603: LD_STRING D6-JMM-4
10605: PPUSH
10606: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10610: LD_EXP 18
10614: PPUSH
10615: LD_STRING D6-Har-4
10617: PPUSH
10618: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10622: LD_EXP 8
10626: PPUSH
10627: LD_STRING D6-JMM-5
10629: PPUSH
10630: CALL_OW 88
// DialogueOff ;
10634: CALL_OW 7
// m1 := false ;
10638: LD_ADDR_VAR 0 4
10642: PUSH
10643: LD_INT 0
10645: ST_TO_ADDR
// m2 := false ;
10646: LD_ADDR_VAR 0 5
10650: PUSH
10651: LD_INT 0
10653: ST_TO_ADDR
// m3 := false ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_INT 0
10661: ST_TO_ADDR
// tmp := FilterBuildings ( 3 ) ;
10662: LD_ADDR_VAR 0 3
10666: PUSH
10667: LD_INT 3
10669: PPUSH
10670: CALL 2885 0 1
10674: ST_TO_ADDR
// if tmp >= 35 then
10675: LD_VAR 0 3
10679: PUSH
10680: LD_INT 35
10682: GREATEREQUAL
10683: IFFALSE 10720
// begin AddMedal ( Destroy1 , - 1 ) ;
10685: LD_STRING Destroy1
10687: PPUSH
10688: LD_INT 1
10690: NEG
10691: PPUSH
10692: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10696: LD_STRING Destroy2
10698: PPUSH
10699: LD_INT 1
10701: NEG
10702: PPUSH
10703: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10707: LD_STRING Destroy3
10709: PPUSH
10710: LD_INT 1
10712: NEG
10713: PPUSH
10714: CALL_OW 101
// end else
10718: GO 10831
// begin AddMedal ( Destroy1 , 1 ) ;
10720: LD_STRING Destroy1
10722: PPUSH
10723: LD_INT 1
10725: PPUSH
10726: CALL_OW 101
// m1 := true ;
10730: LD_ADDR_VAR 0 4
10734: PUSH
10735: LD_INT 1
10737: ST_TO_ADDR
// if tmp >= 25 then
10738: LD_VAR 0 3
10742: PUSH
10743: LD_INT 25
10745: GREATEREQUAL
10746: IFFALSE 10772
// begin AddMedal ( Destroy2 , - 1 ) ;
10748: LD_STRING Destroy2
10750: PPUSH
10751: LD_INT 1
10753: NEG
10754: PPUSH
10755: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10759: LD_STRING Destroy3
10761: PPUSH
10762: LD_INT 1
10764: NEG
10765: PPUSH
10766: CALL_OW 101
// end else
10770: GO 10831
// begin AddMedal ( Destroy2 , 1 ) ;
10772: LD_STRING Destroy2
10774: PPUSH
10775: LD_INT 1
10777: PPUSH
10778: CALL_OW 101
// m2 := true ;
10782: LD_ADDR_VAR 0 5
10786: PUSH
10787: LD_INT 1
10789: ST_TO_ADDR
// if tmp >= 15 then
10790: LD_VAR 0 3
10794: PUSH
10795: LD_INT 15
10797: GREATEREQUAL
10798: IFFALSE 10813
// AddMedal ( Destroy3 , - 1 ) else
10800: LD_STRING Destroy3
10802: PPUSH
10803: LD_INT 1
10805: NEG
10806: PPUSH
10807: CALL_OW 101
10811: GO 10831
// begin AddMedal ( Destroy3 , 1 ) ;
10813: LD_STRING Destroy3
10815: PPUSH
10816: LD_INT 1
10818: PPUSH
10819: CALL_OW 101
// m3 := true ;
10823: LD_ADDR_VAR 0 6
10827: PUSH
10828: LD_INT 1
10830: ST_TO_ADDR
// end ; end ; end ; if m1 and m2 and m3 and Difficulty = 3 then
10831: LD_VAR 0 4
10835: PUSH
10836: LD_VAR 0 5
10840: AND
10841: PUSH
10842: LD_VAR 0 6
10846: AND
10847: PUSH
10848: LD_OWVAR 67
10852: PUSH
10853: LD_INT 3
10855: EQUAL
10856: AND
10857: IFFALSE 10869
// SetAchievementEX ( ACH_AMER , 7 ) ;
10859: LD_STRING ACH_AMER
10861: PPUSH
10862: LD_INT 7
10864: PPUSH
10865: CALL_OW 564
// GiveMedals ( MAIN ) ;
10869: LD_STRING MAIN
10871: PPUSH
10872: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
10876: LD_ADDR_VAR 0 3
10880: PUSH
10881: LD_INT 1
10883: PPUSH
10884: LD_INT 9
10886: PPUSH
10887: CALL 2707 0 2
10891: PUSH
10892: LD_INT 1
10894: PPUSH
10895: LD_INT 9
10897: PPUSH
10898: CALL 2754 0 2
10902: UNION
10903: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10904: LD_VAR 0 3
10908: PPUSH
10909: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10913: LD_EXP 8
10917: PPUSH
10918: LD_EXP 3
10922: PUSH
10923: LD_STRING JMM
10925: STR
10926: PPUSH
10927: CALL_OW 38
// if Brown in tmp then
10931: LD_EXP 9
10935: PUSH
10936: LD_VAR 0 3
10940: IN
10941: IFFALSE 10961
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
10943: LD_EXP 9
10947: PPUSH
10948: LD_EXP 3
10952: PUSH
10953: LD_STRING Brown
10955: STR
10956: PPUSH
10957: CALL_OW 38
// if Donaldson in tmp then
10961: LD_EXP 10
10965: PUSH
10966: LD_VAR 0 3
10970: IN
10971: IFFALSE 10991
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
10973: LD_EXP 10
10977: PPUSH
10978: LD_EXP 3
10982: PUSH
10983: LD_STRING Donaldson
10985: STR
10986: PPUSH
10987: CALL_OW 38
// if Bobby in tmp then
10991: LD_EXP 11
10995: PUSH
10996: LD_VAR 0 3
11000: IN
11001: IFFALSE 11021
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11003: LD_EXP 11
11007: PPUSH
11008: LD_EXP 3
11012: PUSH
11013: LD_STRING Bobby
11015: STR
11016: PPUSH
11017: CALL_OW 38
// if Cyrus in tmp then
11021: LD_EXP 12
11025: PUSH
11026: LD_VAR 0 3
11030: IN
11031: IFFALSE 11051
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11033: LD_EXP 12
11037: PPUSH
11038: LD_EXP 3
11042: PUSH
11043: LD_STRING Cyrus
11045: STR
11046: PPUSH
11047: CALL_OW 38
// if Lisa in tmp then
11051: LD_EXP 13
11055: PUSH
11056: LD_VAR 0 3
11060: IN
11061: IFFALSE 11081
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11063: LD_EXP 13
11067: PPUSH
11068: LD_EXP 3
11072: PUSH
11073: LD_STRING Lisa
11075: STR
11076: PPUSH
11077: CALL_OW 38
// if Frank in tmp then
11081: LD_EXP 14
11085: PUSH
11086: LD_VAR 0 3
11090: IN
11091: IFFALSE 11111
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11093: LD_EXP 14
11097: PPUSH
11098: LD_EXP 3
11102: PUSH
11103: LD_STRING Frank
11105: STR
11106: PPUSH
11107: CALL_OW 38
// if Gladstone in tmp then
11111: LD_EXP 15
11115: PUSH
11116: LD_VAR 0 3
11120: IN
11121: IFFALSE 11141
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
11123: LD_EXP 15
11127: PPUSH
11128: LD_EXP 3
11132: PUSH
11133: LD_STRING Gladstone
11135: STR
11136: PPUSH
11137: CALL_OW 38
// if Khatam in tmp then
11141: LD_EXP 16
11145: PUSH
11146: LD_VAR 0 3
11150: IN
11151: IFFALSE 11171
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11153: LD_EXP 16
11157: PPUSH
11158: LD_EXP 3
11162: PUSH
11163: LD_STRING Khatam
11165: STR
11166: PPUSH
11167: CALL_OW 38
// if Kikuchi in tmp then
11171: LD_EXP 17
11175: PUSH
11176: LD_VAR 0 3
11180: IN
11181: IFFALSE 11201
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11183: LD_EXP 17
11187: PPUSH
11188: LD_EXP 3
11192: PUSH
11193: LD_STRING Kikuchi
11195: STR
11196: PPUSH
11197: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11201: LD_VAR 0 3
11205: PUSH
11206: LD_EXP 8
11210: PUSH
11211: LD_EXP 9
11215: PUSH
11216: LD_EXP 10
11220: PUSH
11221: LD_EXP 11
11225: PUSH
11226: LD_EXP 12
11230: PUSH
11231: LD_EXP 13
11235: PUSH
11236: LD_EXP 14
11240: PUSH
11241: LD_EXP 15
11245: PUSH
11246: LD_EXP 17
11250: PUSH
11251: LD_EXP 16
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: LIST
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: DIFF
11268: PPUSH
11269: LD_EXP 3
11273: PUSH
11274: LD_STRING others
11276: STR
11277: PPUSH
11278: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11282: LD_OWVAR 1
11286: PPUSH
11287: LD_STRING 07_time
11289: PPUSH
11290: CALL_OW 39
// tmp := [ ] ;
11294: LD_ADDR_VAR 0 3
11298: PUSH
11299: EMPTY
11300: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11301: LD_ADDR_VAR 0 2
11305: PUSH
11306: LD_INT 9
11308: PPUSH
11309: LD_INT 22
11311: PUSH
11312: LD_INT 1
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: PUSH
11319: LD_INT 23
11321: PUSH
11322: LD_INT 1
11324: PUSH
11325: EMPTY
11326: LIST
11327: LIST
11328: PUSH
11329: LD_INT 21
11331: PUSH
11332: LD_INT 2
11334: PUSH
11335: EMPTY
11336: LIST
11337: LIST
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: LIST
11343: PUSH
11344: EMPTY
11345: LIST
11346: PPUSH
11347: CALL_OW 70
11351: PUSH
11352: FOR_IN
11353: IFFALSE 11414
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11355: LD_ADDR_VAR 0 3
11359: PUSH
11360: LD_VAR 0 3
11364: PUSH
11365: LD_VAR 0 2
11369: PPUSH
11370: CALL_OW 265
11374: PUSH
11375: LD_VAR 0 2
11379: PPUSH
11380: CALL_OW 262
11384: PUSH
11385: LD_VAR 0 2
11389: PPUSH
11390: CALL_OW 263
11394: PUSH
11395: LD_VAR 0 2
11399: PPUSH
11400: CALL_OW 264
11404: PUSH
11405: EMPTY
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: ADD
11411: ST_TO_ADDR
11412: GO 11352
11414: POP
11415: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11416: LD_VAR 0 3
11420: PPUSH
11421: LD_STRING 07_vehicles
11423: PPUSH
11424: CALL_OW 39
// YouWin ;
11428: CALL_OW 103
// end ; end_of_file
11432: PPOPN 6
11434: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11435: LD_VAR 0 1
11439: PUSH
11440: LD_EXP 8
11444: EQUAL
11445: IFFALSE 11454
// YouLost ( JMM ) ;
11447: LD_STRING JMM
11449: PPUSH
11450: CALL_OW 104
// if GetType ( un ) = unit_building then
11454: LD_VAR 0 1
11458: PPUSH
11459: CALL_OW 247
11463: PUSH
11464: LD_INT 3
11466: EQUAL
11467: IFFALSE 11483
// buildings_counter := buildings_counter + 1 ;
11469: LD_ADDR_EXP 4
11473: PUSH
11474: LD_EXP 4
11478: PUSH
11479: LD_INT 1
11481: PLUS
11482: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11483: LD_VAR 0 1
11487: PUSH
11488: LD_INT 6
11490: PPUSH
11491: LD_INT 2
11493: PUSH
11494: LD_INT 30
11496: PUSH
11497: LD_INT 33
11499: PUSH
11500: EMPTY
11501: LIST
11502: LIST
11503: PUSH
11504: LD_INT 30
11506: PUSH
11507: LD_INT 32
11509: PUSH
11510: EMPTY
11511: LIST
11512: LIST
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: LIST
11518: PPUSH
11519: CALL_OW 70
11523: IN
11524: IFFALSE 11583
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11526: LD_ADDR_EXP 19
11530: PUSH
11531: LD_EXP 19
11535: PUSH
11536: LD_VAR 0 1
11540: PPUSH
11541: CALL_OW 266
11545: PUSH
11546: LD_VAR 0 1
11550: PPUSH
11551: CALL_OW 250
11555: PUSH
11556: LD_VAR 0 1
11560: PPUSH
11561: CALL_OW 251
11565: PUSH
11566: LD_VAR 0 1
11570: PPUSH
11571: CALL_OW 254
11575: PUSH
11576: EMPTY
11577: LIST
11578: LIST
11579: LIST
11580: LIST
11581: ADD
11582: ST_TO_ADDR
// if un = ru_dep_main then
11583: LD_VAR 0 1
11587: PUSH
11588: LD_INT 16
11590: EQUAL
11591: IFFALSE 11600
// ChangeMissionObjectives ( M1a ) ;
11593: LD_STRING M1a
11595: PPUSH
11596: CALL_OW 337
// end ;
11600: PPOPN 1
11602: END
// on BuildingStarted ( b , builder ) do var i ;
11603: LD_INT 0
11605: PPUSH
// begin if GetSide ( b ) = 3 then
11606: LD_VAR 0 1
11610: PPUSH
11611: CALL_OW 255
11615: PUSH
11616: LD_INT 3
11618: EQUAL
11619: IFFALSE 11659
// for i = 1 to 4 do
11621: LD_ADDR_VAR 0 3
11625: PUSH
11626: DOUBLE
11627: LD_INT 1
11629: DEC
11630: ST_TO_ADDR
11631: LD_INT 4
11633: PUSH
11634: FOR_TO
11635: IFFALSE 11657
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11637: LD_ADDR_EXP 19
11641: PUSH
11642: LD_EXP 19
11646: PPUSH
11647: LD_INT 1
11649: PPUSH
11650: CALL_OW 3
11654: ST_TO_ADDR
11655: GO 11634
11657: POP
11658: POP
// end ;
11659: PPOPN 3
11661: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11662: LD_VAR 0 1
11666: PPUSH
11667: CALL_OW 266
11671: PUSH
11672: LD_INT 32
11674: PUSH
11675: LD_INT 33
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: IN
11682: IFFALSE 11696
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11684: LD_VAR 0 1
11688: PPUSH
11689: LD_INT 43
11691: PPUSH
11692: CALL_OW 148
11696: PPOPN 1
11698: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11699: LD_VAR 0 1
11703: PUSH
11704: LD_INT 22
11706: PUSH
11707: LD_INT 3
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: LD_INT 2
11716: PUSH
11717: LD_INT 30
11719: PUSH
11720: LD_INT 31
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PUSH
11727: LD_INT 30
11729: PUSH
11730: LD_INT 32
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: LIST
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: PPUSH
11746: CALL_OW 69
11750: IN
11751: IFFALSE 11773
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11753: LD_VAR 0 2
11757: PPUSH
11758: LD_VAR 0 1
11762: PPUSH
11763: LD_INT 143
11765: PPUSH
11766: LD_INT 143
11768: PPUSH
11769: CALL 2066 0 4
// end ;
11773: PPOPN 2
11775: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11776: LD_VAR 0 1
11780: PUSH
11781: LD_INT 22
11783: PUSH
11784: LD_INT 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: LD_INT 30
11793: PUSH
11794: LD_INT 32
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PPUSH
11805: CALL_OW 69
11809: IN
11810: IFFALSE 11824
// SetTag ( b , 0 ) ;
11812: LD_VAR 0 1
11816: PPUSH
11817: LD_INT 0
11819: PPUSH
11820: CALL_OW 109
// end ; end_of_file
11824: PPOPN 2
11826: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11827: GO 11829
11829: DISABLE
// begin ru_radar := 98 ;
11830: LD_ADDR_EXP 20
11834: PUSH
11835: LD_INT 98
11837: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11838: LD_ADDR_EXP 21
11842: PUSH
11843: LD_INT 89
11845: ST_TO_ADDR
// us_hack := 99 ;
11846: LD_ADDR_EXP 22
11850: PUSH
11851: LD_INT 99
11853: ST_TO_ADDR
// us_artillery := 97 ;
11854: LD_ADDR_EXP 23
11858: PUSH
11859: LD_INT 97
11861: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11862: LD_ADDR_EXP 24
11866: PUSH
11867: LD_INT 91
11869: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
11870: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11871: LD_INT 0
11873: PPUSH
11874: PPUSH
11875: PPUSH
11876: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11877: LD_VAR 0 1
11881: PPUSH
11882: CALL_OW 264
11886: PUSH
11887: LD_EXP 24
11891: EQUAL
11892: IFFALSE 11964
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11894: LD_INT 68
11896: PPUSH
11897: LD_VAR 0 1
11901: PPUSH
11902: CALL_OW 255
11906: PPUSH
11907: CALL_OW 321
11911: PUSH
11912: LD_INT 2
11914: EQUAL
11915: IFFALSE 11927
// eff := 70 else
11917: LD_ADDR_VAR 0 6
11921: PUSH
11922: LD_INT 70
11924: ST_TO_ADDR
11925: GO 11935
// eff := 30 ;
11927: LD_ADDR_VAR 0 6
11931: PUSH
11932: LD_INT 30
11934: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11935: LD_VAR 0 1
11939: PPUSH
11940: CALL_OW 250
11944: PPUSH
11945: LD_VAR 0 1
11949: PPUSH
11950: CALL_OW 251
11954: PPUSH
11955: LD_VAR 0 6
11959: PPUSH
11960: CALL_OW 495
// end ; end ;
11964: LD_VAR 0 4
11968: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11969: LD_INT 0
11971: PPUSH
11972: PPUSH
11973: PPUSH
11974: PPUSH
11975: PPUSH
11976: PPUSH
// if cmd = 124 then
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 124
11984: EQUAL
11985: IFFALSE 12191
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11987: LD_ADDR_VAR 0 5
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: LD_INT 34
11997: PUSH
11998: LD_INT 53
12000: PUSH
12001: EMPTY
12002: LIST
12003: LIST
12004: PUSH
12005: LD_INT 34
12007: PUSH
12008: LD_INT 14
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: LIST
12019: PPUSH
12020: CALL_OW 69
12024: ST_TO_ADDR
// if not tmp then
12025: LD_VAR 0 5
12029: NOT
12030: IFFALSE 12034
// exit ;
12032: GO 12191
// for i in tmp do
12034: LD_ADDR_VAR 0 3
12038: PUSH
12039: LD_VAR 0 5
12043: PUSH
12044: FOR_IN
12045: IFFALSE 12189
// begin taskList := GetTaskList ( i ) ;
12047: LD_ADDR_VAR 0 6
12051: PUSH
12052: LD_VAR 0 3
12056: PPUSH
12057: CALL_OW 437
12061: ST_TO_ADDR
// if not taskList then
12062: LD_VAR 0 6
12066: NOT
12067: IFFALSE 12071
// continue ;
12069: GO 12044
// for j = 1 to taskList do
12071: LD_ADDR_VAR 0 4
12075: PUSH
12076: DOUBLE
12077: LD_INT 1
12079: DEC
12080: ST_TO_ADDR
12081: LD_VAR 0 6
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12185
// if taskList [ j ] [ 1 ] = | then
12089: LD_VAR 0 6
12093: PUSH
12094: LD_VAR 0 4
12098: ARRAY
12099: PUSH
12100: LD_INT 1
12102: ARRAY
12103: PUSH
12104: LD_STRING |
12106: EQUAL
12107: IFFALSE 12183
// begin _taskList := Delete ( taskList , 1 ) ;
12109: LD_ADDR_VAR 0 7
12113: PUSH
12114: LD_VAR 0 6
12118: PPUSH
12119: LD_INT 1
12121: PPUSH
12122: CALL_OW 3
12126: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
12127: LD_VAR 0 3
12131: PPUSH
12132: LD_VAR 0 7
12136: PPUSH
12137: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
12141: LD_VAR 0 3
12145: PPUSH
12146: LD_VAR 0 6
12150: PUSH
12151: LD_VAR 0 4
12155: ARRAY
12156: PUSH
12157: LD_INT 2
12159: ARRAY
12160: PPUSH
12161: LD_VAR 0 6
12165: PUSH
12166: LD_VAR 0 4
12170: ARRAY
12171: PUSH
12172: LD_INT 3
12174: ARRAY
12175: PPUSH
12176: LD_INT 8
12178: PPUSH
12179: CALL 12196 0 4
// end ;
12183: GO 12086
12185: POP
12186: POP
// end ;
12187: GO 12044
12189: POP
12190: POP
// end ; end ;
12191: LD_VAR 0 2
12195: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
12196: LD_INT 0
12198: PPUSH
12199: PPUSH
12200: PPUSH
12201: PPUSH
12202: PPUSH
12203: PPUSH
12204: PPUSH
12205: PPUSH
12206: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
12207: LD_VAR 0 1
12211: NOT
12212: PUSH
12213: LD_VAR 0 2
12217: PPUSH
12218: LD_VAR 0 3
12222: PPUSH
12223: CALL_OW 488
12227: NOT
12228: OR
12229: PUSH
12230: LD_VAR 0 4
12234: NOT
12235: OR
12236: IFFALSE 12240
// exit ;
12238: GO 12580
// list := [ ] ;
12240: LD_ADDR_VAR 0 13
12244: PUSH
12245: EMPTY
12246: ST_TO_ADDR
// if x - r < 0 then
12247: LD_VAR 0 2
12251: PUSH
12252: LD_VAR 0 4
12256: MINUS
12257: PUSH
12258: LD_INT 0
12260: LESS
12261: IFFALSE 12273
// min_x := 0 else
12263: LD_ADDR_VAR 0 7
12267: PUSH
12268: LD_INT 0
12270: ST_TO_ADDR
12271: GO 12289
// min_x := x - r ;
12273: LD_ADDR_VAR 0 7
12277: PUSH
12278: LD_VAR 0 2
12282: PUSH
12283: LD_VAR 0 4
12287: MINUS
12288: ST_TO_ADDR
// if y - r < 0 then
12289: LD_VAR 0 3
12293: PUSH
12294: LD_VAR 0 4
12298: MINUS
12299: PUSH
12300: LD_INT 0
12302: LESS
12303: IFFALSE 12315
// min_y := 0 else
12305: LD_ADDR_VAR 0 8
12309: PUSH
12310: LD_INT 0
12312: ST_TO_ADDR
12313: GO 12331
// min_y := y - r ;
12315: LD_ADDR_VAR 0 8
12319: PUSH
12320: LD_VAR 0 3
12324: PUSH
12325: LD_VAR 0 4
12329: MINUS
12330: ST_TO_ADDR
// max_x := x + r ;
12331: LD_ADDR_VAR 0 9
12335: PUSH
12336: LD_VAR 0 2
12340: PUSH
12341: LD_VAR 0 4
12345: PLUS
12346: ST_TO_ADDR
// max_y := y + r ;
12347: LD_ADDR_VAR 0 10
12351: PUSH
12352: LD_VAR 0 3
12356: PUSH
12357: LD_VAR 0 4
12361: PLUS
12362: ST_TO_ADDR
// for _x = min_x to max_x do
12363: LD_ADDR_VAR 0 11
12367: PUSH
12368: DOUBLE
12369: LD_VAR 0 7
12373: DEC
12374: ST_TO_ADDR
12375: LD_VAR 0 9
12379: PUSH
12380: FOR_TO
12381: IFFALSE 12498
// for _y = min_y to max_y do
12383: LD_ADDR_VAR 0 12
12387: PUSH
12388: DOUBLE
12389: LD_VAR 0 8
12393: DEC
12394: ST_TO_ADDR
12395: LD_VAR 0 10
12399: PUSH
12400: FOR_TO
12401: IFFALSE 12494
// begin if not ValidHex ( _x , _y ) then
12403: LD_VAR 0 11
12407: PPUSH
12408: LD_VAR 0 12
12412: PPUSH
12413: CALL_OW 488
12417: NOT
12418: IFFALSE 12422
// continue ;
12420: GO 12400
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
12422: LD_VAR 0 11
12426: PPUSH
12427: LD_VAR 0 12
12431: PPUSH
12432: CALL_OW 351
12436: PUSH
12437: LD_VAR 0 11
12441: PPUSH
12442: LD_VAR 0 12
12446: PPUSH
12447: CALL_OW 554
12451: AND
12452: IFFALSE 12492
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12454: LD_ADDR_VAR 0 13
12458: PUSH
12459: LD_VAR 0 13
12463: PPUSH
12464: LD_VAR 0 13
12468: PUSH
12469: LD_INT 1
12471: PLUS
12472: PPUSH
12473: LD_VAR 0 11
12477: PUSH
12478: LD_VAR 0 12
12482: PUSH
12483: EMPTY
12484: LIST
12485: LIST
12486: PPUSH
12487: CALL_OW 2
12491: ST_TO_ADDR
// end ;
12492: GO 12400
12494: POP
12495: POP
12496: GO 12380
12498: POP
12499: POP
// if not list then
12500: LD_VAR 0 13
12504: NOT
12505: IFFALSE 12509
// exit ;
12507: GO 12580
// for i in list do
12509: LD_ADDR_VAR 0 6
12513: PUSH
12514: LD_VAR 0 13
12518: PUSH
12519: FOR_IN
12520: IFFALSE 12578
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12522: LD_VAR 0 1
12526: PPUSH
12527: LD_STRING M
12529: PUSH
12530: LD_VAR 0 6
12534: PUSH
12535: LD_INT 1
12537: ARRAY
12538: PUSH
12539: LD_VAR 0 6
12543: PUSH
12544: LD_INT 2
12546: ARRAY
12547: PUSH
12548: LD_INT 0
12550: PUSH
12551: LD_INT 0
12553: PUSH
12554: LD_INT 0
12556: PUSH
12557: LD_INT 0
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: LIST
12567: LIST
12568: PUSH
12569: EMPTY
12570: LIST
12571: PPUSH
12572: CALL_OW 447
12576: GO 12519
12578: POP
12579: POP
// end ;
12580: LD_VAR 0 5
12584: RET
