// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 44 0 0
// DebugMode ;
  12: CALL 245 0 0
// AnimateTrees ( true ) ;
  16: LD_INT 1
  18: PPUSH
  19: CALL_OW 573
// PrepareNature ;
  23: CALL 2929 0 0
// PrepareRussians ;
  27: CALL 4670 0 0
// PrepareAmericans ;
  31: CALL 3586 0 0
// Action ;
  35: CALL 8550 0 0
// SaveForQuickRestart ;
  39: CALL_OW 22
// end ;
  43: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  44: LD_INT 0
  46: PPUSH
// debug := false ;
  47: LD_ADDR_EXP 1
  51: PUSH
  52: LD_INT 0
  54: ST_TO_ADDR
// mission_prefix := 07c_ ;
  55: LD_ADDR_EXP 3
  59: PUSH
  60: LD_STRING 07c_
  62: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  63: LD_ADDR_EXP 2
  67: PUSH
  68: LD_STRING 07_
  70: ST_TO_ADDR
// buildings_counter := 0 ;
  71: LD_ADDR_EXP 4
  75: PUSH
  76: LD_INT 0
  78: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  79: LD_ADDR_EXP 5
  83: PUSH
  84: LD_INT 67200
  86: PUSH
  87: LD_INT 60900
  89: PUSH
  90: LD_INT 54600
  92: PUSH
  93: EMPTY
  94: LIST
  95: LIST
  96: LIST
  97: PUSH
  98: LD_OWVAR 67
 102: ARRAY
 103: PUSH
 104: LD_INT 79800
 106: PUSH
 107: LD_INT 73500
 109: PUSH
 110: LD_INT 67200
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PUSH
 124: LD_INT 92400
 126: PUSH
 127: LD_INT 86100
 129: PUSH
 130: LD_INT 79800
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: PUSH
 138: LD_OWVAR 67
 142: ARRAY
 143: PUSH
 144: EMPTY
 145: LIST
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// can_end := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// must_end := false ;
 157: LD_ADDR_EXP 7
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// end ;
 165: LD_VAR 0 1
 169: RET
// every 0 0$01 trigger not debug do
 170: LD_EXP 1
 174: NOT
 175: IFFALSE 244
 177: GO 179
 179: DISABLE
// begin enable ;
 180: ENABLE
// if not must_end then
 181: LD_EXP 7
 185: NOT
 186: IFFALSE 207
// display_strings := [ #Am07-1 , tick ] else
 188: LD_ADDR_OWVAR 47
 192: PUSH
 193: LD_STRING #Am07-1
 195: PUSH
 196: LD_OWVAR 1
 200: PUSH
 201: EMPTY
 202: LIST
 203: LIST
 204: ST_TO_ADDR
 205: GO 244
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 207: LD_ADDR_OWVAR 47
 211: PUSH
 212: LD_STRING #Am07-1
 214: PUSH
 215: LD_OWVAR 1
 219: PUSH
 220: LD_STRING #Am07-2
 222: PUSH
 223: LD_EXP 5
 227: PUSH
 228: LD_INT 3
 230: ARRAY
 231: PUSH
 232: LD_OWVAR 1
 236: MINUS
 237: PUSH
 238: EMPTY
 239: LIST
 240: LIST
 241: LIST
 242: LIST
 243: ST_TO_ADDR
// end ;
 244: END
// function DebugMode ; var i ; begin
 245: LD_INT 0
 247: PPUSH
 248: PPUSH
// if not debug then
 249: LD_EXP 1
 253: NOT
 254: IFFALSE 258
// exit ;
 256: GO 265
// FogOff ( 1 ) ;
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 344
// end ;
 265: LD_VAR 0 1
 269: RET
// every 3 trigger debug do var i , filter ;
 270: LD_EXP 1
 274: IFFALSE 363
 276: GO 278
 278: DISABLE
 279: LD_INT 0
 281: PPUSH
 282: PPUSH
// begin enable ;
 283: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 284: LD_ADDR_VAR 0 2
 288: PUSH
 289: LD_INT 22
 291: PUSH
 292: LD_INT 1
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: PUSH
 299: LD_INT 3
 301: PUSH
 302: LD_INT 24
 304: PUSH
 305: LD_INT 500
 307: PUSH
 308: EMPTY
 309: LIST
 310: LIST
 311: PUSH
 312: EMPTY
 313: LIST
 314: LIST
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: PPUSH
 320: CALL_OW 69
 324: ST_TO_ADDR
// if not filter then
 325: LD_VAR 0 2
 329: NOT
 330: IFFALSE 334
// exit ;
 332: GO 363
// for i in filter do
 334: LD_ADDR_VAR 0 1
 338: PUSH
 339: LD_VAR 0 2
 343: PUSH
 344: FOR_IN
 345: IFFALSE 361
// SetLives ( i , 1000 ) ;
 347: LD_VAR 0 1
 351: PPUSH
 352: LD_INT 1000
 354: PPUSH
 355: CALL_OW 234
 359: GO 344
 361: POP
 362: POP
// end ; end_of_file
 363: PPOPN 2
 365: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 366: LD_INT 0
 368: PPUSH
 369: PPUSH
// if exist_mode then
 370: LD_VAR 0 2
 374: IFFALSE 399
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 376: LD_ADDR_VAR 0 4
 380: PUSH
 381: LD_EXP 2
 385: PUSH
 386: LD_VAR 0 1
 390: STR
 391: PPUSH
 392: CALL_OW 34
 396: ST_TO_ADDR
 397: GO 414
// unit := NewCharacter ( ident ) ;
 399: LD_ADDR_VAR 0 4
 403: PUSH
 404: LD_VAR 0 1
 408: PPUSH
 409: CALL_OW 25
 413: ST_TO_ADDR
// result := unit ;
 414: LD_ADDR_VAR 0 3
 418: PUSH
 419: LD_VAR 0 4
 423: ST_TO_ADDR
// end ;
 424: LD_VAR 0 3
 428: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 429: LD_INT 0
 431: PPUSH
// uc_side := side ;
 432: LD_ADDR_OWVAR 20
 436: PUSH
 437: LD_VAR 0 1
 441: ST_TO_ADDR
// uc_nation := nation ;
 442: LD_ADDR_OWVAR 21
 446: PUSH
 447: LD_VAR 0 2
 451: ST_TO_ADDR
// vc_chassis := chassis ;
 452: LD_ADDR_OWVAR 37
 456: PUSH
 457: LD_VAR 0 3
 461: ST_TO_ADDR
// vc_engine := engine ;
 462: LD_ADDR_OWVAR 39
 466: PUSH
 467: LD_VAR 0 4
 471: ST_TO_ADDR
// vc_control := control ;
 472: LD_ADDR_OWVAR 38
 476: PUSH
 477: LD_VAR 0 5
 481: ST_TO_ADDR
// vc_weapon := weapon ;
 482: LD_ADDR_OWVAR 40
 486: PUSH
 487: LD_VAR 0 6
 491: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 492: LD_ADDR_OWVAR 41
 496: PUSH
 497: LD_VAR 0 7
 501: ST_TO_ADDR
// result := CreateVehicle ;
 502: LD_ADDR_VAR 0 8
 506: PUSH
 507: CALL_OW 45
 511: ST_TO_ADDR
// end ;
 512: LD_VAR 0 8
 516: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 517: LD_INT 0
 519: PPUSH
 520: PPUSH
 521: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_INT 22
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: LD_INT 21
 539: PUSH
 540: LD_INT 1
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 50
 549: PUSH
 550: EMPTY
 551: LIST
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL_OW 69
 562: PUSH
 563: LD_EXP 8
 567: PUSH
 568: LD_EXP 9
 572: PUSH
 573: LD_EXP 10
 577: PUSH
 578: LD_EXP 11
 582: PUSH
 583: LD_EXP 12
 587: PUSH
 588: LD_EXP 13
 592: PUSH
 593: LD_EXP 14
 597: PUSH
 598: LD_EXP 15
 602: PUSH
 603: LD_EXP 17
 607: PUSH
 608: LD_EXP 16
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: DIFF
 625: ST_TO_ADDR
// if not filter then
 626: LD_VAR 0 4
 630: NOT
 631: IFFALSE 635
// exit ;
 633: GO 662
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 635: LD_ADDR_VAR 0 2
 639: PUSH
 640: LD_VAR 0 4
 644: PPUSH
 645: LD_INT 26
 647: PUSH
 648: LD_VAR 0 1
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PPUSH
 657: CALL_OW 72
 661: ST_TO_ADDR
// end ;
 662: LD_VAR 0 2
 666: RET
// export function SayX ( units , ident ) ; var i ; begin
 667: LD_INT 0
 669: PPUSH
 670: PPUSH
// result := false ;
 671: LD_ADDR_VAR 0 3
 675: PUSH
 676: LD_INT 0
 678: ST_TO_ADDR
// if not units then
 679: LD_VAR 0 1
 683: NOT
 684: IFFALSE 688
// exit ;
 686: GO 742
// for i in units do
 688: LD_ADDR_VAR 0 4
 692: PUSH
 693: LD_VAR 0 1
 697: PUSH
 698: FOR_IN
 699: IFFALSE 740
// if IsOk ( i ) then
 701: LD_VAR 0 4
 705: PPUSH
 706: CALL_OW 302
 710: IFFALSE 738
// begin Say ( i , ident ) ;
 712: LD_VAR 0 4
 716: PPUSH
 717: LD_VAR 0 2
 721: PPUSH
 722: CALL_OW 88
// result := i ;
 726: LD_ADDR_VAR 0 3
 730: PUSH
 731: LD_VAR 0 4
 735: ST_TO_ADDR
// break ;
 736: GO 740
// end ;
 738: GO 698
 740: POP
 741: POP
// end ;
 742: LD_VAR 0 3
 746: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 747: LD_INT 0
 749: PPUSH
 750: PPUSH
 751: PPUSH
// result := [ ] ;
 752: LD_ADDR_VAR 0 2
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 759: LD_ADDR_VAR 0 3
 763: PUSH
 764: LD_INT 21
 766: PUSH
 767: LD_INT 3
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: PPUSH
 774: CALL_OW 69
 778: ST_TO_ADDR
// if not tmp then
 779: LD_VAR 0 3
 783: NOT
 784: IFFALSE 788
// exit ;
 786: GO 838
// for i in tmp do
 788: LD_ADDR_VAR 0 4
 792: PUSH
 793: LD_VAR 0 3
 797: PUSH
 798: FOR_IN
 799: IFFALSE 836
// if GetBase ( i ) = base then
 801: LD_VAR 0 4
 805: PPUSH
 806: CALL_OW 274
 810: PUSH
 811: LD_VAR 0 1
 815: EQUAL
 816: IFFALSE 834
// result := result ^ i ;
 818: LD_ADDR_VAR 0 2
 822: PUSH
 823: LD_VAR 0 2
 827: PUSH
 828: LD_VAR 0 4
 832: ADD
 833: ST_TO_ADDR
 834: GO 798
 836: POP
 837: POP
// end ;
 838: LD_VAR 0 2
 842: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 843: LD_INT 0
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
 852: PPUSH
 853: PPUSH
 854: PPUSH
 855: PPUSH
 856: PPUSH
 857: PPUSH
 858: PPUSH
 859: PPUSH
 860: PPUSH
// result := false ;
 861: LD_ADDR_VAR 0 2
 865: PUSH
 866: LD_INT 0
 868: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 869: LD_VAR 0 1
 873: NOT
 874: PUSH
 875: LD_VAR 0 1
 879: PPUSH
 880: CALL_OW 266
 884: PUSH
 885: LD_INT 32
 887: PUSH
 888: LD_INT 33
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: IN
 895: NOT
 896: OR
 897: IFFALSE 901
// exit ;
 899: GO 2061
// nat := GetNation ( tower ) ;
 901: LD_ADDR_VAR 0 11
 905: PUSH
 906: LD_VAR 0 1
 910: PPUSH
 911: CALL_OW 248
 915: ST_TO_ADDR
// side := GetSide ( tower ) ;
 916: LD_ADDR_VAR 0 15
 920: PUSH
 921: LD_VAR 0 1
 925: PPUSH
 926: CALL_OW 255
 930: ST_TO_ADDR
// x := GetX ( tower ) ;
 931: LD_ADDR_VAR 0 9
 935: PUSH
 936: LD_VAR 0 1
 940: PPUSH
 941: CALL_OW 250
 945: ST_TO_ADDR
// y := GetY ( tower ) ;
 946: LD_ADDR_VAR 0 10
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: CALL_OW 251
 960: ST_TO_ADDR
// if not x or not y then
 961: LD_VAR 0 9
 965: NOT
 966: PUSH
 967: LD_VAR 0 10
 971: NOT
 972: OR
 973: IFFALSE 977
// exit ;
 975: GO 2061
// weapon := 0 ;
 977: LD_ADDR_VAR 0 17
 981: PUSH
 982: LD_INT 0
 984: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 985: LD_ADDR_VAR 0 16
 989: PUSH
 990: LD_INT 42
 992: PUSH
 993: LD_INT 43
 995: PUSH
 996: LD_INT 44
 998: PUSH
 999: LD_INT 46
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: ST_TO_ADDR
// if not fac_list then
1008: LD_VAR 0 16
1012: NOT
1013: IFFALSE 1017
// exit ;
1015: GO 2061
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1017: LD_ADDR_VAR 0 4
1021: PUSH
1022: LD_INT 4
1024: PUSH
1025: LD_INT 5
1027: PUSH
1028: LD_INT 9
1030: PUSH
1031: LD_INT 10
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: LD_INT 7
1039: PUSH
1040: LD_INT 11
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: PUSH
1052: LD_INT 27
1054: PUSH
1055: LD_INT 28
1057: PUSH
1058: LD_INT 26
1060: PUSH
1061: LD_INT 30
1063: PUSH
1064: EMPTY
1065: LIST
1066: LIST
1067: LIST
1068: LIST
1069: PUSH
1070: LD_INT 43
1072: PUSH
1073: LD_INT 44
1075: PUSH
1076: LD_INT 46
1078: PUSH
1079: LD_INT 45
1081: PUSH
1082: LD_INT 47
1084: PUSH
1085: LD_INT 49
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_VAR 0 11
1105: ARRAY
1106: ST_TO_ADDR
// for i in list do
1107: LD_ADDR_VAR 0 7
1111: PUSH
1112: LD_VAR 0 4
1116: PUSH
1117: FOR_IN
1118: IFFALSE 1151
// if not i in fac_list then
1120: LD_VAR 0 7
1124: PUSH
1125: LD_VAR 0 16
1129: IN
1130: NOT
1131: IFFALSE 1149
// list := list diff i ;
1133: LD_ADDR_VAR 0 4
1137: PUSH
1138: LD_VAR 0 4
1142: PUSH
1143: LD_VAR 0 7
1147: DIFF
1148: ST_TO_ADDR
1149: GO 1117
1151: POP
1152: POP
// if not list then
1153: LD_VAR 0 4
1157: NOT
1158: IFFALSE 1162
// exit ;
1160: GO 2061
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1162: LD_VAR 0 11
1166: PUSH
1167: LD_INT 3
1169: EQUAL
1170: PUSH
1171: LD_INT 49
1173: PUSH
1174: LD_VAR 0 4
1178: IN
1179: AND
1180: PUSH
1181: LD_INT 31
1183: PPUSH
1184: LD_VAR 0 15
1188: PPUSH
1189: CALL_OW 321
1193: PUSH
1194: LD_INT 2
1196: EQUAL
1197: AND
1198: IFFALSE 1258
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1200: LD_INT 22
1202: PUSH
1203: LD_VAR 0 15
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 35
1214: PUSH
1215: LD_INT 49
1217: PUSH
1218: EMPTY
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 91
1224: PUSH
1225: LD_VAR 0 1
1229: PUSH
1230: LD_INT 10
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: LIST
1237: PUSH
1238: EMPTY
1239: LIST
1240: LIST
1241: LIST
1242: PPUSH
1243: CALL_OW 69
1247: NOT
1248: IFFALSE 1258
// weapon := ru_time_lapser ;
1250: LD_ADDR_VAR 0 17
1254: PUSH
1255: LD_INT 49
1257: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1258: LD_VAR 0 11
1262: PUSH
1263: LD_INT 1
1265: PUSH
1266: LD_INT 2
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: IN
1273: PUSH
1274: LD_INT 11
1276: PUSH
1277: LD_VAR 0 4
1281: IN
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_VAR 0 4
1290: IN
1291: OR
1292: AND
1293: PUSH
1294: LD_INT 6
1296: PPUSH
1297: LD_VAR 0 15
1301: PPUSH
1302: CALL_OW 321
1306: PUSH
1307: LD_INT 2
1309: EQUAL
1310: AND
1311: IFFALSE 1476
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1313: LD_INT 22
1315: PUSH
1316: LD_VAR 0 15
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 2
1327: PUSH
1328: LD_INT 35
1330: PUSH
1331: LD_INT 11
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 35
1340: PUSH
1341: LD_INT 30
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 91
1355: PUSH
1356: LD_VAR 0 1
1360: PUSH
1361: LD_INT 18
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL_OW 69
1378: NOT
1379: PUSH
1380: LD_INT 22
1382: PUSH
1383: LD_VAR 0 15
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: PUSH
1392: LD_INT 2
1394: PUSH
1395: LD_INT 30
1397: PUSH
1398: LD_INT 32
1400: PUSH
1401: EMPTY
1402: LIST
1403: LIST
1404: PUSH
1405: LD_INT 30
1407: PUSH
1408: LD_INT 33
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: PUSH
1415: EMPTY
1416: LIST
1417: LIST
1418: LIST
1419: PUSH
1420: LD_INT 91
1422: PUSH
1423: LD_VAR 0 1
1427: PUSH
1428: LD_INT 12
1430: PUSH
1431: EMPTY
1432: LIST
1433: LIST
1434: LIST
1435: PUSH
1436: EMPTY
1437: LIST
1438: LIST
1439: LIST
1440: PUSH
1441: EMPTY
1442: LIST
1443: PPUSH
1444: CALL_OW 69
1448: PUSH
1449: LD_INT 2
1451: GREATER
1452: AND
1453: IFFALSE 1476
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1455: LD_ADDR_VAR 0 17
1459: PUSH
1460: LD_INT 11
1462: PUSH
1463: LD_INT 30
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PUSH
1470: LD_VAR 0 11
1474: ARRAY
1475: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1476: LD_VAR 0 17
1480: NOT
1481: PUSH
1482: LD_INT 40
1484: PPUSH
1485: LD_VAR 0 15
1489: PPUSH
1490: CALL_OW 321
1494: PUSH
1495: LD_INT 2
1497: EQUAL
1498: AND
1499: PUSH
1500: LD_INT 7
1502: PUSH
1503: LD_VAR 0 4
1507: IN
1508: PUSH
1509: LD_INT 28
1511: PUSH
1512: LD_VAR 0 4
1516: IN
1517: OR
1518: PUSH
1519: LD_INT 45
1521: PUSH
1522: LD_VAR 0 4
1526: IN
1527: OR
1528: AND
1529: IFFALSE 1783
// begin hex := GetHexInfo ( x , y ) ;
1531: LD_ADDR_VAR 0 3
1535: PUSH
1536: LD_VAR 0 9
1540: PPUSH
1541: LD_VAR 0 10
1545: PPUSH
1546: CALL_OW 546
1550: ST_TO_ADDR
// if hex [ 1 ] then
1551: LD_VAR 0 3
1555: PUSH
1556: LD_INT 1
1558: ARRAY
1559: IFFALSE 1563
// exit ;
1561: GO 2061
// height := hex [ 2 ] ;
1563: LD_ADDR_VAR 0 14
1567: PUSH
1568: LD_VAR 0 3
1572: PUSH
1573: LD_INT 2
1575: ARRAY
1576: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1577: LD_ADDR_VAR 0 13
1581: PUSH
1582: LD_INT 0
1584: PUSH
1585: LD_INT 2
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 5
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: ST_TO_ADDR
// for i in tmp do
1600: LD_ADDR_VAR 0 7
1604: PUSH
1605: LD_VAR 0 13
1609: PUSH
1610: FOR_IN
1611: IFFALSE 1781
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1613: LD_ADDR_VAR 0 8
1617: PUSH
1618: LD_VAR 0 9
1622: PPUSH
1623: LD_VAR 0 7
1627: PPUSH
1628: LD_INT 5
1630: PPUSH
1631: CALL_OW 272
1635: PUSH
1636: LD_VAR 0 10
1640: PPUSH
1641: LD_VAR 0 7
1645: PPUSH
1646: LD_INT 5
1648: PPUSH
1649: CALL_OW 273
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1658: LD_VAR 0 8
1662: PUSH
1663: LD_INT 1
1665: ARRAY
1666: PPUSH
1667: LD_VAR 0 8
1671: PUSH
1672: LD_INT 2
1674: ARRAY
1675: PPUSH
1676: CALL_OW 488
1680: IFFALSE 1779
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1682: LD_ADDR_VAR 0 3
1686: PUSH
1687: LD_VAR 0 8
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PPUSH
1696: LD_VAR 0 8
1700: PUSH
1701: LD_INT 2
1703: ARRAY
1704: PPUSH
1705: CALL_OW 546
1709: ST_TO_ADDR
// if hex [ 1 ] then
1710: LD_VAR 0 3
1714: PUSH
1715: LD_INT 1
1717: ARRAY
1718: IFFALSE 1722
// continue ;
1720: GO 1610
// h := hex [ 2 ] ;
1722: LD_ADDR_VAR 0 12
1726: PUSH
1727: LD_VAR 0 3
1731: PUSH
1732: LD_INT 2
1734: ARRAY
1735: ST_TO_ADDR
// if h + 7 < height then
1736: LD_VAR 0 12
1740: PUSH
1741: LD_INT 7
1743: PLUS
1744: PUSH
1745: LD_VAR 0 14
1749: LESS
1750: IFFALSE 1779
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1752: LD_ADDR_VAR 0 17
1756: PUSH
1757: LD_INT 7
1759: PUSH
1760: LD_INT 28
1762: PUSH
1763: LD_INT 45
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: PUSH
1771: LD_VAR 0 11
1775: ARRAY
1776: ST_TO_ADDR
// break ;
1777: GO 1781
// end ; end ; end ;
1779: GO 1610
1781: POP
1782: POP
// end ; if not weapon then
1783: LD_VAR 0 17
1787: NOT
1788: IFFALSE 1943
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1790: LD_ADDR_VAR 0 4
1794: PUSH
1795: LD_VAR 0 4
1799: PUSH
1800: LD_INT 11
1802: PUSH
1803: LD_INT 30
1805: PUSH
1806: LD_INT 49
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: DIFF
1814: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1815: LD_ADDR_VAR 0 13
1819: PUSH
1820: LD_INT 22
1822: PUSH
1823: LD_VAR 0 15
1827: PUSH
1828: EMPTY
1829: LIST
1830: LIST
1831: PUSH
1832: LD_INT 91
1834: PUSH
1835: LD_VAR 0 1
1839: PUSH
1840: LD_INT 6
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 3
1850: PUSH
1851: LD_INT 35
1853: PUSH
1854: LD_INT 0
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PPUSH
1870: CALL_OW 69
1874: ST_TO_ADDR
// for i in tmp do
1875: LD_ADDR_VAR 0 7
1879: PUSH
1880: LD_VAR 0 13
1884: PUSH
1885: FOR_IN
1886: IFFALSE 1911
// list := list diff GetBWeapon ( i ) ;
1888: LD_ADDR_VAR 0 4
1892: PUSH
1893: LD_VAR 0 4
1897: PUSH
1898: LD_VAR 0 7
1902: PPUSH
1903: CALL_OW 269
1907: DIFF
1908: ST_TO_ADDR
1909: GO 1885
1911: POP
1912: POP
// if list then
1913: LD_VAR 0 4
1917: IFFALSE 1943
// weapon := list [ rand ( 1 , list ) ] ;
1919: LD_ADDR_VAR 0 17
1923: PUSH
1924: LD_VAR 0 4
1928: PUSH
1929: LD_INT 1
1931: PPUSH
1932: LD_VAR 0 4
1936: PPUSH
1937: CALL_OW 12
1941: ARRAY
1942: ST_TO_ADDR
// end ; if weapon then
1943: LD_VAR 0 17
1947: IFFALSE 2061
// begin tmp := CostOfWeapon ( weapon ) ;
1949: LD_ADDR_VAR 0 13
1953: PUSH
1954: LD_VAR 0 17
1958: PPUSH
1959: CALL_OW 451
1963: ST_TO_ADDR
// j := GetBase ( tower ) ;
1964: LD_ADDR_VAR 0 8
1968: PUSH
1969: LD_VAR 0 1
1973: PPUSH
1974: CALL_OW 274
1978: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1979: LD_VAR 0 8
1983: PPUSH
1984: LD_INT 1
1986: PPUSH
1987: CALL_OW 275
1991: PUSH
1992: LD_VAR 0 13
1996: PUSH
1997: LD_INT 1
1999: ARRAY
2000: GREATEREQUAL
2001: PUSH
2002: LD_VAR 0 8
2006: PPUSH
2007: LD_INT 2
2009: PPUSH
2010: CALL_OW 275
2014: PUSH
2015: LD_VAR 0 13
2019: PUSH
2020: LD_INT 2
2022: ARRAY
2023: GREATEREQUAL
2024: AND
2025: PUSH
2026: LD_VAR 0 8
2030: PPUSH
2031: LD_INT 3
2033: PPUSH
2034: CALL_OW 275
2038: PUSH
2039: LD_VAR 0 13
2043: PUSH
2044: LD_INT 3
2046: ARRAY
2047: GREATEREQUAL
2048: AND
2049: IFFALSE 2061
// result := weapon ;
2051: LD_ADDR_VAR 0 2
2055: PUSH
2056: LD_VAR 0 17
2060: ST_TO_ADDR
// end ; end ;
2061: LD_VAR 0 2
2065: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2066: LD_INT 0
2068: PPUSH
2069: PPUSH
2070: PPUSH
2071: PPUSH
2072: PPUSH
// if not un or not IsOk ( un ) then
2073: LD_VAR 0 1
2077: NOT
2078: PUSH
2079: LD_VAR 0 1
2083: PPUSH
2084: CALL_OW 302
2088: NOT
2089: OR
2090: IFFALSE 2094
// exit ;
2092: GO 2534
// side := GetSide ( un ) ;
2094: LD_ADDR_VAR 0 9
2098: PUSH
2099: LD_VAR 0 1
2103: PPUSH
2104: CALL_OW 255
2108: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2109: LD_ADDR_VAR 0 7
2113: PUSH
2114: LD_INT 22
2116: PUSH
2117: LD_VAR 0 9
2121: PUSH
2122: EMPTY
2123: LIST
2124: LIST
2125: PUSH
2126: LD_INT 30
2128: PUSH
2129: LD_INT 32
2131: PUSH
2132: EMPTY
2133: LIST
2134: LIST
2135: PUSH
2136: LD_INT 50
2138: PUSH
2139: EMPTY
2140: LIST
2141: PUSH
2142: LD_INT 58
2144: PUSH
2145: EMPTY
2146: LIST
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: PPUSH
2154: CALL_OW 69
2158: PUSH
2159: LD_VAR 0 2
2163: DIFF
2164: ST_TO_ADDR
// if not filter then
2165: LD_VAR 0 7
2169: NOT
2170: IFFALSE 2399
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2172: LD_ADDR_VAR 0 7
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_VAR 0 9
2184: PUSH
2185: EMPTY
2186: LIST
2187: LIST
2188: PUSH
2189: LD_INT 30
2191: PUSH
2192: LD_INT 5
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 69
2207: ST_TO_ADDR
// if debug then
2208: LD_EXP 1
2212: IFFALSE 2231
// display_strings := [ filter , 1 ] ;
2214: LD_ADDR_OWVAR 47
2218: PUSH
2219: LD_VAR 0 7
2223: PUSH
2224: LD_STRING 1
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: ST_TO_ADDR
// if not filter then
2231: LD_VAR 0 7
2235: NOT
2236: IFFALSE 2259
// begin ComMoveXY ( un , x , y ) ;
2238: LD_VAR 0 1
2242: PPUSH
2243: LD_VAR 0 3
2247: PPUSH
2248: LD_VAR 0 4
2252: PPUSH
2253: CALL_OW 111
// exit ;
2257: GO 2534
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2259: LD_ADDR_VAR 0 8
2263: PUSH
2264: LD_VAR 0 7
2268: PPUSH
2269: LD_VAR 0 1
2273: PPUSH
2274: CALL_OW 74
2278: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2279: LD_VAR 0 8
2283: PPUSH
2284: CALL_OW 313
2288: PUSH
2289: LD_INT 6
2291: EQUAL
2292: IFFALSE 2312
// filter := filter diff t else
2294: LD_ADDR_VAR 0 7
2298: PUSH
2299: LD_VAR 0 7
2303: PUSH
2304: LD_VAR 0 8
2308: DIFF
2309: ST_TO_ADDR
2310: GO 2314
// break ;
2312: GO 2336
// until UnitsInside ( t ) < 6 or not filter ;
2314: LD_VAR 0 8
2318: PPUSH
2319: CALL_OW 313
2323: PUSH
2324: LD_INT 6
2326: LESS
2327: PUSH
2328: LD_VAR 0 7
2332: NOT
2333: OR
2334: IFFALSE 2259
// display_strings := [ filter , t ] ;
2336: LD_ADDR_OWVAR 47
2340: PUSH
2341: LD_VAR 0 7
2345: PUSH
2346: LD_VAR 0 8
2350: PUSH
2351: EMPTY
2352: LIST
2353: LIST
2354: ST_TO_ADDR
// if not filter then
2355: LD_VAR 0 7
2359: NOT
2360: IFFALSE 2383
// ComMoveXY ( un , x , y ) else
2362: LD_VAR 0 1
2366: PPUSH
2367: LD_VAR 0 3
2371: PPUSH
2372: LD_VAR 0 4
2376: PPUSH
2377: CALL_OW 111
2381: GO 2397
// ComEnterUnit ( un , t ) ;
2383: LD_VAR 0 1
2387: PPUSH
2388: LD_VAR 0 8
2392: PPUSH
2393: CALL_OW 120
// end else
2397: GO 2534
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2399: LD_ADDR_VAR 0 8
2403: PUSH
2404: LD_VAR 0 7
2408: PPUSH
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 74
2418: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2419: LD_VAR 0 8
2423: PPUSH
2424: CALL_OW 110
2428: PUSH
2429: LD_INT 7
2431: EQUAL
2432: IFFALSE 2450
// filter := filter diff t ;
2434: LD_ADDR_VAR 0 7
2438: PUSH
2439: LD_VAR 0 7
2443: PUSH
2444: LD_VAR 0 8
2448: DIFF
2449: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2450: LD_VAR 0 8
2454: PPUSH
2455: CALL_OW 110
2459: PUSH
2460: LD_INT 7
2462: NONEQUAL
2463: PUSH
2464: LD_VAR 0 7
2468: NOT
2469: OR
2470: IFFALSE 2399
// if GetTag ( t ) <> 7 then
2472: LD_VAR 0 8
2476: PPUSH
2477: CALL_OW 110
2481: PUSH
2482: LD_INT 7
2484: NONEQUAL
2485: IFFALSE 2515
// begin SetTag ( t , 7 ) ;
2487: LD_VAR 0 8
2491: PPUSH
2492: LD_INT 7
2494: PPUSH
2495: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2499: LD_VAR 0 1
2503: PPUSH
2504: LD_VAR 0 8
2508: PPUSH
2509: CALL_OW 120
// end else
2513: GO 2534
// ComMoveXY ( un , x , y ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 3
2524: PPUSH
2525: LD_VAR 0 4
2529: PPUSH
2530: CALL_OW 111
// end ; end ;
2534: LD_VAR 0 5
2538: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2539: LD_INT 0
2541: PPUSH
2542: PPUSH
2543: PPUSH
// if not base then
2544: LD_VAR 0 1
2548: NOT
2549: IFFALSE 2553
// exit ;
2551: GO 2611
// tmp := GetEnergy ( GetBase ( base ) ) ;
2553: LD_ADDR_VAR 0 4
2557: PUSH
2558: LD_VAR 0 1
2562: PPUSH
2563: CALL_OW 274
2567: PPUSH
2568: CALL_OW 278
2572: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2573: LD_VAR 0 4
2577: PUSH
2578: LD_INT 1
2580: ARRAY
2581: PUSH
2582: LD_VAR 0 4
2586: PUSH
2587: LD_INT 4
2589: ARRAY
2590: GREATER
2591: IFFALSE 2603
// result := true else
2593: LD_ADDR_VAR 0 2
2597: PUSH
2598: LD_INT 1
2600: ST_TO_ADDR
2601: GO 2611
// result := false ;
2603: LD_ADDR_VAR 0 2
2607: PUSH
2608: LD_INT 0
2610: ST_TO_ADDR
// end ;
2611: LD_VAR 0 2
2615: RET
// export function FilterPeople ( side ) ; begin
2616: LD_INT 0
2618: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2619: LD_ADDR_VAR 0 2
2623: PUSH
2624: LD_INT 22
2626: PUSH
2627: LD_VAR 0 1
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: PUSH
2636: LD_INT 21
2638: PUSH
2639: LD_INT 1
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: PPUSH
2650: CALL_OW 69
2654: ST_TO_ADDR
// end ;
2655: LD_VAR 0 2
2659: RET
// export function FilterDrivers ( side ) ; begin
2660: LD_INT 0
2662: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2663: LD_ADDR_VAR 0 2
2667: PUSH
2668: LD_INT 22
2670: PUSH
2671: LD_VAR 0 1
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 3
2682: PUSH
2683: LD_INT 56
2685: PUSH
2686: EMPTY
2687: LIST
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: PUSH
2693: EMPTY
2694: LIST
2695: LIST
2696: PPUSH
2697: CALL_OW 69
2701: ST_TO_ADDR
// end ;
2702: LD_VAR 0 2
2706: RET
// export function FilterPeopleArea ( side , area ) ; begin
2707: LD_INT 0
2709: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2710: LD_ADDR_VAR 0 3
2714: PUSH
2715: LD_VAR 0 2
2719: PPUSH
2720: LD_INT 22
2722: PUSH
2723: LD_INT 1
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 21
2732: PUSH
2733: LD_INT 1
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: PPUSH
2744: CALL_OW 70
2748: ST_TO_ADDR
// end ;
2749: LD_VAR 0 3
2753: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2754: LD_INT 0
2756: PPUSH
2757: PPUSH
2758: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2759: LD_ADDR_VAR 0 5
2763: PUSH
2764: LD_VAR 0 2
2768: PPUSH
2769: LD_INT 22
2771: PUSH
2772: LD_INT 1
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: LD_INT 21
2781: PUSH
2782: LD_INT 2
2784: PUSH
2785: EMPTY
2786: LIST
2787: LIST
2788: PUSH
2789: LD_INT 3
2791: PUSH
2792: LD_INT 58
2794: PUSH
2795: EMPTY
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: PPUSH
2807: CALL_OW 70
2811: ST_TO_ADDR
// result := [ ] ;
2812: LD_ADDR_VAR 0 3
2816: PUSH
2817: EMPTY
2818: ST_TO_ADDR
// if not tmp then
2819: LD_VAR 0 5
2823: NOT
2824: IFFALSE 2828
// exit ;
2826: GO 2880
// for i in tmp do
2828: LD_ADDR_VAR 0 4
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: FOR_IN
2839: IFFALSE 2864
// result := result union IsDrivenBy ( i ) ;
2841: LD_ADDR_VAR 0 3
2845: PUSH
2846: LD_VAR 0 3
2850: PUSH
2851: LD_VAR 0 4
2855: PPUSH
2856: CALL_OW 311
2860: UNION
2861: ST_TO_ADDR
2862: GO 2838
2864: POP
2865: POP
// result := result diff 0 ;
2866: LD_ADDR_VAR 0 3
2870: PUSH
2871: LD_VAR 0 3
2875: PUSH
2876: LD_INT 0
2878: DIFF
2879: ST_TO_ADDR
// end ;
2880: LD_VAR 0 3
2884: RET
// export function FilterBuildings ( side ) ; begin
2885: LD_INT 0
2887: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2888: LD_ADDR_VAR 0 2
2892: PUSH
2893: LD_INT 22
2895: PUSH
2896: LD_VAR 0 1
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: PUSH
2905: LD_INT 21
2907: PUSH
2908: LD_INT 3
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: PPUSH
2919: CALL_OW 69
2923: ST_TO_ADDR
// end ;
2924: LD_VAR 0 2
2928: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
// uc_side = 0 ;
2935: LD_ADDR_OWVAR 20
2939: PUSH
2940: LD_INT 0
2942: ST_TO_ADDR
// uc_nation = 0 ;
2943: LD_ADDR_OWVAR 21
2947: PUSH
2948: LD_INT 0
2950: ST_TO_ADDR
// nat_area := wildArea ;
2951: LD_ADDR_VAR 0 4
2955: PUSH
2956: LD_INT 3
2958: ST_TO_ADDR
// InitHc ;
2959: CALL_OW 19
// for i = 1 to 4 do
2963: LD_ADDR_VAR 0 2
2967: PUSH
2968: DOUBLE
2969: LD_INT 1
2971: DEC
2972: ST_TO_ADDR
2973: LD_INT 4
2975: PUSH
2976: FOR_TO
2977: IFFALSE 3032
// begin hc_class = 18 ;
2979: LD_ADDR_OWVAR 28
2983: PUSH
2984: LD_INT 18
2986: ST_TO_ADDR
// hc_gallery =  ;
2987: LD_ADDR_OWVAR 33
2991: PUSH
2992: LD_STRING 
2994: ST_TO_ADDR
// hc_face_number = 1 ;
2995: LD_ADDR_OWVAR 34
2999: PUSH
3000: LD_INT 1
3002: ST_TO_ADDR
// animal := CreateHuman ;
3003: LD_ADDR_VAR 0 3
3007: PUSH
3008: CALL_OW 44
3012: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3013: LD_VAR 0 3
3017: PPUSH
3018: LD_VAR 0 4
3022: PPUSH
3023: LD_INT 0
3025: PPUSH
3026: CALL_OW 49
// end ;
3030: GO 2976
3032: POP
3033: POP
// for i = 1 to 6 do
3034: LD_ADDR_VAR 0 2
3038: PUSH
3039: DOUBLE
3040: LD_INT 1
3042: DEC
3043: ST_TO_ADDR
3044: LD_INT 6
3046: PUSH
3047: FOR_TO
3048: IFFALSE 3119
// begin hc_class = class_tiger ;
3050: LD_ADDR_OWVAR 28
3054: PUSH
3055: LD_INT 14
3057: ST_TO_ADDR
// hc_gallery =  ;
3058: LD_ADDR_OWVAR 33
3062: PUSH
3063: LD_STRING 
3065: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3066: LD_ADDR_OWVAR 35
3070: PUSH
3071: LD_INT 0
3073: PPUSH
3074: LD_INT 10
3076: PPUSH
3077: CALL_OW 12
3081: ST_TO_ADDR
// hc_face_number = 3 ;
3082: LD_ADDR_OWVAR 34
3086: PUSH
3087: LD_INT 3
3089: ST_TO_ADDR
// animal := CreateHuman ;
3090: LD_ADDR_VAR 0 3
3094: PUSH
3095: CALL_OW 44
3099: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3100: LD_VAR 0 3
3104: PPUSH
3105: LD_VAR 0 4
3109: PPUSH
3110: LD_INT 0
3112: PPUSH
3113: CALL_OW 49
// end ;
3117: GO 3047
3119: POP
3120: POP
// for i = 1 to 2 do
3121: LD_ADDR_VAR 0 2
3125: PUSH
3126: DOUBLE
3127: LD_INT 1
3129: DEC
3130: ST_TO_ADDR
3131: LD_INT 2
3133: PUSH
3134: FOR_TO
3135: IFFALSE 3198
// begin hc_class = 21 ;
3137: LD_ADDR_OWVAR 28
3141: PUSH
3142: LD_INT 21
3144: ST_TO_ADDR
// hc_gallery =  ;
3145: LD_ADDR_OWVAR 33
3149: PUSH
3150: LD_STRING 
3152: ST_TO_ADDR
// hc_agressivity = 0 ;
3153: LD_ADDR_OWVAR 35
3157: PUSH
3158: LD_INT 0
3160: ST_TO_ADDR
// hc_face_number = 5 ;
3161: LD_ADDR_OWVAR 34
3165: PUSH
3166: LD_INT 5
3168: ST_TO_ADDR
// animal := CreateHuman ;
3169: LD_ADDR_VAR 0 3
3173: PUSH
3174: CALL_OW 44
3178: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3179: LD_VAR 0 3
3183: PPUSH
3184: LD_VAR 0 4
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// end ;
3196: GO 3134
3198: POP
3199: POP
// for i = 1 to 6 do
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: DOUBLE
3206: LD_INT 1
3208: DEC
3209: ST_TO_ADDR
3210: LD_INT 6
3212: PUSH
3213: FOR_TO
3214: IFFALSE 3269
// begin hc_class = 13 ;
3216: LD_ADDR_OWVAR 28
3220: PUSH
3221: LD_INT 13
3223: ST_TO_ADDR
// hc_gallery =  ;
3224: LD_ADDR_OWVAR 33
3228: PUSH
3229: LD_STRING 
3231: ST_TO_ADDR
// hc_face_number = 4 ;
3232: LD_ADDR_OWVAR 34
3236: PUSH
3237: LD_INT 4
3239: ST_TO_ADDR
// animal := CreateHuman ;
3240: LD_ADDR_VAR 0 3
3244: PUSH
3245: CALL_OW 44
3249: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3250: LD_VAR 0 3
3254: PPUSH
3255: LD_VAR 0 4
3259: PPUSH
3260: LD_INT 0
3262: PPUSH
3263: CALL_OW 49
// end ;
3267: GO 3213
3269: POP
3270: POP
// for i = 1 to 2 do
3271: LD_ADDR_VAR 0 2
3275: PUSH
3276: DOUBLE
3277: LD_INT 1
3279: DEC
3280: ST_TO_ADDR
3281: LD_INT 2
3283: PUSH
3284: FOR_TO
3285: IFFALSE 3344
// begin hc_class = 20 ;
3287: LD_ADDR_OWVAR 28
3291: PUSH
3292: LD_INT 20
3294: ST_TO_ADDR
// hc_gallery =  ;
3295: LD_ADDR_OWVAR 33
3299: PUSH
3300: LD_STRING 
3302: ST_TO_ADDR
// hc_face_number = 2 ;
3303: LD_ADDR_OWVAR 34
3307: PUSH
3308: LD_INT 2
3310: ST_TO_ADDR
// animal := CreateHuman ;
3311: LD_ADDR_VAR 0 3
3315: PUSH
3316: CALL_OW 44
3320: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 101
3328: PPUSH
3329: LD_INT 37
3331: PPUSH
3332: LD_INT 3
3334: PPUSH
3335: LD_INT 0
3337: PPUSH
3338: CALL_OW 50
// end ;
3342: GO 3284
3344: POP
3345: POP
// for i = 1 to 1 do
3346: LD_ADDR_VAR 0 2
3350: PUSH
3351: DOUBLE
3352: LD_INT 1
3354: DEC
3355: ST_TO_ADDR
3356: LD_INT 1
3358: PUSH
3359: FOR_TO
3360: IFFALSE 3407
// begin vc_chassis := 31 ;
3362: LD_ADDR_OWVAR 37
3366: PUSH
3367: LD_INT 31
3369: ST_TO_ADDR
// vc_control := control_rider ;
3370: LD_ADDR_OWVAR 38
3374: PUSH
3375: LD_INT 4
3377: ST_TO_ADDR
// animal := CreateVehicle ;
3378: LD_ADDR_VAR 0 3
3382: PUSH
3383: CALL_OW 45
3387: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3388: LD_VAR 0 3
3392: PPUSH
3393: LD_VAR 0 4
3397: PPUSH
3398: LD_INT 0
3400: PPUSH
3401: CALL_OW 49
// end ;
3405: GO 3359
3407: POP
3408: POP
// end ;
3409: LD_VAR 0 1
3413: RET
// export function NearbyTowerHasEnergy ( unit ) ; var i , tmp , energy ; begin
3414: LD_INT 0
3416: PPUSH
3417: PPUSH
3418: PPUSH
3419: PPUSH
// result := [ ] ;
3420: LD_ADDR_VAR 0 2
3424: PUSH
3425: EMPTY
3426: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( unit ) ] , [ f_dist , unit , 15 ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
3427: LD_ADDR_VAR 0 4
3431: PUSH
3432: LD_INT 81
3434: PUSH
3435: LD_VAR 0 1
3439: PPUSH
3440: CALL_OW 255
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PUSH
3449: LD_INT 91
3451: PUSH
3452: LD_VAR 0 1
3456: PUSH
3457: LD_INT 15
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: PUSH
3465: LD_INT 2
3467: PUSH
3468: LD_INT 30
3470: PUSH
3471: LD_INT 32
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: PUSH
3478: LD_INT 30
3480: PUSH
3481: LD_INT 33
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: EMPTY
3489: LIST
3490: LIST
3491: LIST
3492: PUSH
3493: EMPTY
3494: LIST
3495: LIST
3496: LIST
3497: PPUSH
3498: CALL_OW 69
3502: ST_TO_ADDR
// if not tmp then
3503: LD_VAR 0 4
3507: NOT
3508: IFFALSE 3512
// exit ;
3510: GO 3581
// for i in tmp do
3512: LD_ADDR_VAR 0 3
3516: PUSH
3517: LD_VAR 0 4
3521: PUSH
3522: FOR_IN
3523: IFFALSE 3579
// begin energy := GetEnergy ( GetBase ( i ) ) ;
3525: LD_ADDR_VAR 0 5
3529: PUSH
3530: LD_VAR 0 3
3534: PPUSH
3535: CALL_OW 274
3539: PPUSH
3540: CALL_OW 278
3544: ST_TO_ADDR
// if energy [ 4 ] > energy [ 1 ] then
3545: LD_VAR 0 5
3549: PUSH
3550: LD_INT 4
3552: ARRAY
3553: PUSH
3554: LD_VAR 0 5
3558: PUSH
3559: LD_INT 1
3561: ARRAY
3562: GREATER
3563: IFFALSE 3577
// begin result := i ;
3565: LD_ADDR_VAR 0 2
3569: PUSH
3570: LD_VAR 0 3
3574: ST_TO_ADDR
// break ;
3575: GO 3579
// end ; end ;
3577: GO 3522
3579: POP
3580: POP
// end ; end_of_file
3581: LD_VAR 0 2
3585: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3586: LD_INT 0
3588: PPUSH
3589: PPUSH
3590: PPUSH
3591: PPUSH
3592: PPUSH
3593: PPUSH
// uc_side := 1 ;
3594: LD_ADDR_OWVAR 20
3598: PUSH
3599: LD_INT 1
3601: ST_TO_ADDR
// uc_nation := 1 ;
3602: LD_ADDR_OWVAR 21
3606: PUSH
3607: LD_INT 1
3609: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3610: LD_ADDR_EXP 8
3614: PUSH
3615: LD_STRING JMM
3617: PPUSH
3618: LD_EXP 1
3622: NOT
3623: PPUSH
3624: CALL 366 0 2
3628: ST_TO_ADDR
// team := [ JMM ] ;
3629: LD_ADDR_VAR 0 3
3633: PUSH
3634: LD_EXP 8
3638: PUSH
3639: EMPTY
3640: LIST
3641: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3642: LD_STRING BrownIn07
3644: PPUSH
3645: LD_EXP 1
3649: PPUSH
3650: CALL_OW 30
3654: IFFALSE 3675
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3656: LD_ADDR_EXP 9
3660: PUSH
3661: LD_STRING Brown
3663: PPUSH
3664: LD_EXP 1
3668: NOT
3669: PPUSH
3670: CALL 366 0 2
3674: ST_TO_ADDR
// if Brown then
3675: LD_EXP 9
3679: IFFALSE 3697
// team := team ^ Brown ;
3681: LD_ADDR_VAR 0 3
3685: PUSH
3686: LD_VAR 0 3
3690: PUSH
3691: LD_EXP 9
3695: ADD
3696: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3697: LD_STRING DonaldsonIn07
3699: PPUSH
3700: LD_EXP 1
3704: PPUSH
3705: CALL_OW 30
3709: IFFALSE 3730
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3711: LD_ADDR_EXP 10
3715: PUSH
3716: LD_STRING Donaldson
3718: PPUSH
3719: LD_EXP 1
3723: NOT
3724: PPUSH
3725: CALL 366 0 2
3729: ST_TO_ADDR
// if Donaldson then
3730: LD_EXP 10
3734: IFFALSE 3752
// team := team ^ Donaldson ;
3736: LD_ADDR_VAR 0 3
3740: PUSH
3741: LD_VAR 0 3
3745: PUSH
3746: LD_EXP 10
3750: ADD
3751: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3752: LD_STRING BobbyIn07
3754: PPUSH
3755: LD_EXP 1
3759: PPUSH
3760: CALL_OW 30
3764: IFFALSE 3785
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3766: LD_ADDR_EXP 11
3770: PUSH
3771: LD_STRING Bobby
3773: PPUSH
3774: LD_EXP 1
3778: NOT
3779: PPUSH
3780: CALL 366 0 2
3784: ST_TO_ADDR
// if Bobby then
3785: LD_EXP 11
3789: IFFALSE 3807
// team := team ^ Bobby ;
3791: LD_ADDR_VAR 0 3
3795: PUSH
3796: LD_VAR 0 3
3800: PUSH
3801: LD_EXP 11
3805: ADD
3806: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3807: LD_STRING CyrusIn07
3809: PPUSH
3810: LD_EXP 1
3814: PPUSH
3815: CALL_OW 30
3819: IFFALSE 3840
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3821: LD_ADDR_EXP 12
3825: PUSH
3826: LD_STRING Cyrus
3828: PPUSH
3829: LD_EXP 1
3833: NOT
3834: PPUSH
3835: CALL 366 0 2
3839: ST_TO_ADDR
// if Cyrus then
3840: LD_EXP 12
3844: IFFALSE 3862
// team := team ^ Cyrus ;
3846: LD_ADDR_VAR 0 3
3850: PUSH
3851: LD_VAR 0 3
3855: PUSH
3856: LD_EXP 12
3860: ADD
3861: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3862: LD_STRING LisaIn07
3864: PPUSH
3865: LD_EXP 1
3869: PPUSH
3870: CALL_OW 30
3874: IFFALSE 3895
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3876: LD_ADDR_EXP 13
3880: PUSH
3881: LD_STRING Lisa
3883: PPUSH
3884: LD_EXP 1
3888: NOT
3889: PPUSH
3890: CALL 366 0 2
3894: ST_TO_ADDR
// if Lisa then
3895: LD_EXP 13
3899: IFFALSE 3917
// team := team ^ Lisa ;
3901: LD_ADDR_VAR 0 3
3905: PUSH
3906: LD_VAR 0 3
3910: PUSH
3911: LD_EXP 13
3915: ADD
3916: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3917: LD_STRING GladstoneIn07
3919: PPUSH
3920: LD_EXP 1
3924: PPUSH
3925: CALL_OW 30
3929: IFFALSE 3950
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3931: LD_ADDR_EXP 15
3935: PUSH
3936: LD_STRING Gladstone
3938: PPUSH
3939: LD_EXP 1
3943: NOT
3944: PPUSH
3945: CALL 366 0 2
3949: ST_TO_ADDR
// if Gladstone then
3950: LD_EXP 15
3954: IFFALSE 3972
// team := team ^ Gladstone ;
3956: LD_ADDR_VAR 0 3
3960: PUSH
3961: LD_VAR 0 3
3965: PUSH
3966: LD_EXP 15
3970: ADD
3971: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3972: LD_STRING KhatamIn07
3974: PPUSH
3975: LD_EXP 1
3979: PPUSH
3980: CALL_OW 30
3984: IFFALSE 4005
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3986: LD_ADDR_EXP 16
3990: PUSH
3991: LD_STRING Khatam
3993: PPUSH
3994: LD_EXP 1
3998: NOT
3999: PPUSH
4000: CALL 366 0 2
4004: ST_TO_ADDR
// if Khatam then
4005: LD_EXP 16
4009: IFFALSE 4027
// team := team ^ Khatam ;
4011: LD_ADDR_VAR 0 3
4015: PUSH
4016: LD_VAR 0 3
4020: PUSH
4021: LD_EXP 16
4025: ADD
4026: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
4027: LD_ADDR_VAR 0 4
4031: PUSH
4032: LD_STRING 07_others
4034: PPUSH
4035: CALL_OW 31
4039: ST_TO_ADDR
// if others then
4040: LD_VAR 0 4
4044: IFFALSE 4062
// team := team ^ others ;
4046: LD_ADDR_VAR 0 3
4050: PUSH
4051: LD_VAR 0 3
4055: PUSH
4056: LD_VAR 0 4
4060: ADD
4061: ST_TO_ADDR
// if debug then
4062: LD_EXP 1
4066: IFFALSE 4140
// begin InitHc ;
4068: CALL_OW 19
// for i = 1 to 4 do
4072: LD_ADDR_VAR 0 2
4076: PUSH
4077: DOUBLE
4078: LD_INT 1
4080: DEC
4081: ST_TO_ADDR
4082: LD_INT 4
4084: PUSH
4085: FOR_TO
4086: IFFALSE 4138
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
4088: LD_INT 0
4090: PPUSH
4091: LD_INT 1
4093: PUSH
4094: LD_INT 3
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PUSH
4101: LD_INT 1
4103: PPUSH
4104: LD_INT 2
4106: PPUSH
4107: CALL_OW 12
4111: ARRAY
4112: PPUSH
4113: LD_INT 4
4115: PPUSH
4116: CALL_OW 380
// team := team ^ CreateHuman ;
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: LD_VAR 0 3
4129: PUSH
4130: CALL_OW 44
4134: ADD
4135: ST_TO_ADDR
// end ;
4136: GO 4085
4138: POP
4139: POP
// end ; m := 0 ;
4140: LD_ADDR_VAR 0 6
4144: PUSH
4145: LD_INT 0
4147: ST_TO_ADDR
// for i in team do
4148: LD_ADDR_VAR 0 2
4152: PUSH
4153: LD_VAR 0 3
4157: PUSH
4158: FOR_IN
4159: IFFALSE 4366
// if GetClass ( i ) = 3 then
4161: LD_VAR 0 2
4165: PPUSH
4166: CALL_OW 257
4170: PUSH
4171: LD_INT 3
4173: EQUAL
4174: IFFALSE 4322
// begin m := m + 1 ;
4176: LD_ADDR_VAR 0 6
4180: PUSH
4181: LD_VAR 0 6
4185: PUSH
4186: LD_INT 1
4188: PLUS
4189: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4190: LD_ADDR_VAR 0 5
4194: PUSH
4195: LD_INT 1
4197: PPUSH
4198: LD_INT 1
4200: PPUSH
4201: LD_INT 2
4203: PUSH
4204: LD_INT 3
4206: PUSH
4207: LD_INT 2
4209: PUSH
4210: LD_INT 1
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_VAR 0 6
4223: PUSH
4224: LD_INT 4
4226: MOD
4227: PUSH
4228: LD_INT 1
4230: PLUS
4231: ARRAY
4232: PPUSH
4233: LD_INT 2
4235: PPUSH
4236: LD_INT 1
4238: PPUSH
4239: LD_INT 4
4241: PUSH
4242: LD_INT 5
4244: PUSH
4245: LD_INT 3
4247: PUSH
4248: LD_INT 11
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: PUSH
4257: LD_VAR 0 6
4261: PUSH
4262: LD_INT 4
4264: MOD
4265: PUSH
4266: LD_INT 1
4268: PLUS
4269: ARRAY
4270: PPUSH
4271: LD_INT 60
4273: PPUSH
4274: CALL 429 0 7
4278: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4279: LD_VAR 0 5
4283: PPUSH
4284: LD_INT 2
4286: PPUSH
4287: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4291: LD_VAR 0 5
4295: PPUSH
4296: LD_INT 1
4298: PPUSH
4299: LD_INT 0
4301: PPUSH
4302: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4306: LD_VAR 0 2
4310: PPUSH
4311: LD_VAR 0 5
4315: PPUSH
4316: CALL_OW 52
// end else
4320: GO 4364
// begin if GetClass ( i ) = 2 then
4322: LD_VAR 0 2
4326: PPUSH
4327: CALL_OW 257
4331: PUSH
4332: LD_INT 2
4334: EQUAL
4335: IFFALSE 4349
// SetClass ( i , 1 ) ;
4337: LD_VAR 0 2
4341: PPUSH
4342: LD_INT 1
4344: PPUSH
4345: CALL_OW 336
// PlaceUnitArea ( i , startArea , false ) ;
4349: LD_VAR 0 2
4353: PPUSH
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 49
// end ;
4364: GO 4158
4366: POP
4367: POP
// uc_side := 4 ;
4368: LD_ADDR_OWVAR 20
4372: PUSH
4373: LD_INT 4
4375: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4376: LD_ADDR_EXP 18
4380: PUSH
4381: LD_STRING Harisson
4383: PPUSH
4384: LD_INT 0
4386: PPUSH
4387: CALL 366 0 2
4391: ST_TO_ADDR
// PrepareScout ;
4392: CALL 4401 0 0
// end ;
4396: LD_VAR 0 1
4400: RET
// function PrepareScout ; var ape ; begin
4401: LD_INT 0
4403: PPUSH
4404: PPUSH
// uc_side := 4 ;
4405: LD_ADDR_OWVAR 20
4409: PUSH
4410: LD_INT 4
4412: ST_TO_ADDR
// uc_nation := 1 ;
4413: LD_ADDR_OWVAR 21
4417: PUSH
4418: LD_INT 1
4420: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4421: LD_STRING FrankIn06
4423: PPUSH
4424: LD_INT 0
4426: PPUSH
4427: CALL_OW 30
4431: IFFALSE 4448
// Frank := CreateCharacter ( 06c_Frank ) else
4433: LD_ADDR_EXP 14
4437: PUSH
4438: LD_STRING 06c_Frank
4440: PPUSH
4441: CALL_OW 34
4445: ST_TO_ADDR
4446: GO 4488
// if LoadVariable ( FrankInDelta , 0 ) then
4448: LD_STRING FrankInDelta
4450: PPUSH
4451: LD_INT 0
4453: PPUSH
4454: CALL_OW 30
4458: IFFALSE 4475
// Frank := CreateCharacter ( 05_Frank ) else
4460: LD_ADDR_EXP 14
4464: PUSH
4465: LD_STRING 05_Frank
4467: PPUSH
4468: CALL_OW 34
4472: ST_TO_ADDR
4473: GO 4488
// Frank := CreateCharacter ( 04_Frank ) ;
4475: LD_ADDR_EXP 14
4479: PUSH
4480: LD_STRING 04_Frank
4482: PPUSH
4483: CALL_OW 34
4487: ST_TO_ADDR
// if Frank then
4488: LD_EXP 14
4492: IFFALSE 4625
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4494: LD_EXP 14
4498: PPUSH
4499: LD_INT 2
4501: PPUSH
4502: LD_INT 0
4504: PPUSH
4505: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4509: LD_EXP 14
4513: PPUSH
4514: LD_INT 1
4516: PPUSH
4517: CALL_OW 336
// uc_side := 0 ;
4521: LD_ADDR_OWVAR 20
4525: PUSH
4526: LD_INT 0
4528: ST_TO_ADDR
// uc_nation := 0 ;
4529: LD_ADDR_OWVAR 21
4533: PUSH
4534: LD_INT 0
4536: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4537: LD_INT 0
4539: PPUSH
4540: LD_INT 12
4542: PPUSH
4543: LD_INT 0
4545: PPUSH
4546: CALL_OW 380
// ape := CreateHuman ;
4550: LD_ADDR_VAR 0 2
4554: PUSH
4555: CALL_OW 44
4559: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4560: LD_VAR 0 2
4564: PPUSH
4565: LD_EXP 14
4569: PPUSH
4570: CALL_OW 250
4574: PPUSH
4575: LD_EXP 14
4579: PPUSH
4580: CALL_OW 251
4584: PPUSH
4585: LD_INT 5
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4595: LD_VAR 0 2
4599: PPUSH
4600: LD_EXP 14
4604: PPUSH
4605: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4609: LD_EXP 14
4613: PPUSH
4614: LD_VAR 0 2
4618: PPUSH
4619: CALL_OW 119
// exit ;
4623: GO 4665
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4625: LD_ADDR_EXP 17
4629: PUSH
4630: LD_STRING Yamoko
4632: PPUSH
4633: LD_INT 0
4635: PPUSH
4636: CALL 366 0 2
4640: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4641: LD_EXP 17
4645: PPUSH
4646: LD_INT 2
4648: PPUSH
4649: LD_INT 0
4651: PPUSH
4652: CALL_OW 49
// ComHold ( Kikuchi ) ;
4656: LD_EXP 17
4660: PPUSH
4661: CALL_OW 140
// end ; end_of_file
4665: LD_VAR 0 1
4669: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4670: LD_INT 0
4672: PPUSH
4673: PPUSH
4674: PPUSH
4675: PPUSH
4676: PPUSH
4677: PPUSH
4678: PPUSH
4679: PPUSH
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
4685: PPUSH
4686: PPUSH
4687: PPUSH
// ru_rebuild_list := [ ] ;
4688: LD_ADDR_EXP 19
4692: PUSH
4693: EMPTY
4694: ST_TO_ADDR
// uc_side := 3 ;
4695: LD_ADDR_OWVAR 20
4699: PUSH
4700: LD_INT 3
4702: ST_TO_ADDR
// uc_nation := 3 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 3
4710: ST_TO_ADDR
// if Difficulty > 1 then
4711: LD_OWVAR 67
4715: PUSH
4716: LD_INT 1
4718: GREATER
4719: IFFALSE 4855
// begin bc_type := b_breastwork ;
4721: LD_ADDR_OWVAR 42
4725: PUSH
4726: LD_INT 31
4728: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4729: LD_INT 78
4731: PPUSH
4732: LD_INT 74
4734: PPUSH
4735: LD_INT 2
4737: PPUSH
4738: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4742: LD_INT 171
4744: PPUSH
4745: LD_INT 193
4747: PPUSH
4748: LD_INT 4
4750: PPUSH
4751: CALL_OW 47
// bc_type := b_turret ;
4755: LD_ADDR_OWVAR 42
4759: PUSH
4760: LD_INT 33
4762: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4763: LD_INT 129
4765: PPUSH
4766: LD_INT 96
4768: PPUSH
4769: LD_INT 3
4771: PPUSH
4772: CALL_OW 47
// if Difficulty > 2 then
4776: LD_OWVAR 67
4780: PUSH
4781: LD_INT 2
4783: GREATER
4784: IFFALSE 4855
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4786: LD_INT 83
4788: PPUSH
4789: LD_INT 141
4791: PPUSH
4792: CALL_OW 428
4796: PPUSH
4797: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4801: LD_INT 78
4803: PPUSH
4804: LD_INT 133
4806: PPUSH
4807: CALL_OW 428
4811: PPUSH
4812: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4816: LD_INT 83
4818: PPUSH
4819: LD_INT 141
4821: PPUSH
4822: LD_INT 2
4824: PPUSH
4825: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4829: LD_INT 78
4831: PPUSH
4832: LD_INT 133
4834: PPUSH
4835: LD_INT 2
4837: PPUSH
4838: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4842: LD_INT 145
4844: PPUSH
4845: LD_INT 112
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4855: LD_ADDR_VAR 0 9
4859: PUSH
4860: LD_INT 22
4862: PUSH
4863: LD_INT 3
4865: PUSH
4866: EMPTY
4867: LIST
4868: LIST
4869: PUSH
4870: LD_INT 2
4872: PUSH
4873: LD_INT 30
4875: PUSH
4876: LD_INT 0
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PUSH
4883: LD_INT 30
4885: PUSH
4886: LD_INT 1
4888: PUSH
4889: EMPTY
4890: LIST
4891: LIST
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: LIST
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PPUSH
4902: CALL_OW 69
4906: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4907: LD_ADDR_VAR 0 10
4911: PUSH
4912: LD_INT 22
4914: PUSH
4915: LD_INT 3
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 2
4924: PUSH
4925: LD_INT 30
4927: PUSH
4928: LD_INT 6
4930: PUSH
4931: EMPTY
4932: LIST
4933: LIST
4934: PUSH
4935: LD_INT 30
4937: PUSH
4938: LD_INT 7
4940: PUSH
4941: EMPTY
4942: LIST
4943: LIST
4944: PUSH
4945: LD_INT 30
4947: PUSH
4948: LD_INT 8
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: EMPTY
4956: LIST
4957: LIST
4958: LIST
4959: LIST
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: CALL_OW 69
4969: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4970: LD_ADDR_VAR 0 11
4974: PUSH
4975: LD_INT 22
4977: PUSH
4978: LD_INT 3
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PUSH
4985: LD_INT 30
4987: PUSH
4988: LD_INT 3
4990: PUSH
4991: EMPTY
4992: LIST
4993: LIST
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PPUSH
4999: CALL_OW 69
5003: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
5004: LD_ADDR_VAR 0 12
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 3
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 31
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 69
5037: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
5038: LD_ADDR_VAR 0 13
5042: PUSH
5043: LD_INT 22
5045: PUSH
5046: LD_INT 3
5048: PUSH
5049: EMPTY
5050: LIST
5051: LIST
5052: PUSH
5053: LD_INT 30
5055: PUSH
5056: LD_INT 32
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: PPUSH
5067: CALL_OW 69
5071: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
5072: LD_ADDR_VAR 0 14
5076: PUSH
5077: LD_INT 22
5079: PUSH
5080: LD_INT 3
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 30
5089: PUSH
5090: LD_INT 33
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PPUSH
5101: CALL_OW 69
5105: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
5106: LD_ADDR_VAR 0 15
5110: PUSH
5111: LD_INT 42
5113: PUSH
5114: LD_INT 5
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: LD_INT 43
5123: PUSH
5124: LD_INT 50
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: PUSH
5131: LD_INT 44
5133: PUSH
5134: LD_INT 30
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PUSH
5141: LD_INT 46
5143: PUSH
5144: LD_INT 15
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
5157: LD_ADDR_VAR 0 16
5161: PUSH
5162: LD_INT 0
5164: PUSH
5165: LD_INT 4
5167: PUSH
5168: LD_INT 6
5170: PUSH
5171: LD_INT 3
5173: PUSH
5174: EMPTY
5175: LIST
5176: LIST
5177: LIST
5178: LIST
5179: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
5180: LD_ADDR_VAR 0 6
5184: PUSH
5185: LD_INT 4
5187: PUSH
5188: LD_INT 5
5190: PUSH
5191: LD_INT 6
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: LD_OWVAR 67
5203: ARRAY
5204: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
5205: LD_INT 16
5207: PPUSH
5208: LD_STRING am_tukh
5210: PPUSH
5211: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5215: LD_ADDR_VAR 0 2
5219: PUSH
5220: LD_INT 21
5222: PUSH
5223: LD_INT 3
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PPUSH
5230: CALL_OW 69
5234: PUSH
5235: FOR_IN
5236: IFFALSE 5269
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5238: LD_VAR 0 2
5242: PPUSH
5243: LD_INT 4
5245: PUSH
5246: LD_INT 5
5248: PUSH
5249: LD_INT 6
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_OWVAR 67
5261: ARRAY
5262: PPUSH
5263: CALL_OW 241
5267: GO 5235
5269: POP
5270: POP
// for i in dep_list do
5271: LD_ADDR_VAR 0 2
5275: PUSH
5276: LD_VAR 0 9
5280: PUSH
5281: FOR_IN
5282: IFFALSE 5326
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5284: LD_VAR 0 2
5288: PPUSH
5289: CALL_OW 274
5293: PPUSH
5294: LD_INT 1
5296: PPUSH
5297: LD_INT 1000
5299: PPUSH
5300: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5304: LD_VAR 0 2
5308: PPUSH
5309: CALL_OW 274
5313: PPUSH
5314: LD_INT 2
5316: PPUSH
5317: LD_INT 1000
5319: PPUSH
5320: CALL_OW 277
// end ;
5324: GO 5281
5326: POP
5327: POP
// InitHc ;
5328: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5332: LD_ADDR_VAR 0 8
5336: PUSH
5337: LD_VAR 0 13
5341: PUSH
5342: LD_INT 45
5344: PUSH
5345: LD_INT 60
5347: PUSH
5348: LD_INT 75
5350: PUSH
5351: EMPTY
5352: LIST
5353: LIST
5354: LIST
5355: PUSH
5356: LD_OWVAR 67
5360: ARRAY
5361: MUL
5362: PUSH
5363: LD_INT 100
5365: DIV
5366: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5367: LD_ADDR_VAR 0 16
5371: PUSH
5372: LD_VAR 0 16
5376: PPUSH
5377: LD_INT 1
5379: PPUSH
5380: LD_VAR 0 8
5384: PPUSH
5385: CALL_OW 1
5389: ST_TO_ADDR
// tmp := [ ] ;
5390: LD_ADDR_VAR 0 8
5394: PUSH
5395: EMPTY
5396: ST_TO_ADDR
// for i in bunker_list do
5397: LD_ADDR_VAR 0 2
5401: PUSH
5402: LD_VAR 0 13
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5504
// if i mod 10 + 1 < tmp then
5410: LD_VAR 0 2
5414: PUSH
5415: LD_INT 10
5417: MOD
5418: PUSH
5419: LD_INT 1
5421: PLUS
5422: PUSH
5423: LD_VAR 0 8
5427: LESS
5428: IFFALSE 5473
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5430: LD_ADDR_VAR 0 8
5434: PUSH
5435: LD_VAR 0 8
5439: PPUSH
5440: LD_VAR 0 2
5444: PUSH
5445: LD_INT 3
5447: PPUSH
5448: LD_INT 5
5450: PPUSH
5451: CALL_OW 12
5455: MOD
5456: PUSH
5457: LD_INT 1
5459: PLUS
5460: PPUSH
5461: LD_VAR 0 2
5465: PPUSH
5466: CALL_OW 2
5470: ST_TO_ADDR
5471: GO 5502
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5473: LD_ADDR_VAR 0 8
5477: PUSH
5478: LD_VAR 0 8
5482: PPUSH
5483: LD_VAR 0 8
5487: PUSH
5488: LD_INT 1
5490: PLUS
5491: PPUSH
5492: LD_VAR 0 2
5496: PPUSH
5497: CALL_OW 2
5501: ST_TO_ADDR
5502: GO 5407
5504: POP
5505: POP
// bunker_list := tmp ;
5506: LD_ADDR_VAR 0 13
5510: PUSH
5511: LD_VAR 0 8
5515: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: LD_VAR 0 13
5525: PUSH
5526: LD_VAR 0 14
5530: ADD
5531: PUSH
5532: FOR_IN
5533: IFFALSE 5556
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5535: LD_VAR 0 2
5539: PPUSH
5540: LD_VAR 0 2
5544: PPUSH
5545: CALL 843 0 1
5549: PPUSH
5550: CALL_OW 431
5554: GO 5532
5556: POP
5557: POP
// while ( personel_counter [ 1 ] ) do
5558: LD_VAR 0 16
5562: PUSH
5563: LD_INT 1
5565: ARRAY
5566: IFFALSE 5674
// begin i := rand ( 1 , bunker_list ) ;
5568: LD_ADDR_VAR 0 2
5572: PUSH
5573: LD_INT 1
5575: PPUSH
5576: LD_VAR 0 13
5580: PPUSH
5581: CALL_OW 12
5585: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5586: LD_INT 0
5588: PPUSH
5589: LD_INT 1
5591: PPUSH
5592: LD_VAR 0 6
5596: PPUSH
5597: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5601: CALL_OW 44
5605: PPUSH
5606: LD_VAR 0 13
5610: PUSH
5611: LD_VAR 0 2
5615: ARRAY
5616: PPUSH
5617: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5621: LD_ADDR_VAR 0 13
5625: PUSH
5626: LD_VAR 0 13
5630: PPUSH
5631: LD_VAR 0 2
5635: PPUSH
5636: CALL_OW 3
5640: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5641: LD_ADDR_VAR 0 16
5645: PUSH
5646: LD_VAR 0 16
5650: PPUSH
5651: LD_INT 1
5653: PPUSH
5654: LD_VAR 0 16
5658: PUSH
5659: LD_INT 1
5661: ARRAY
5662: PUSH
5663: LD_INT 1
5665: MINUS
5666: PPUSH
5667: CALL_OW 1
5671: ST_TO_ADDR
// end ;
5672: GO 5558
// for i = 1 to personel_counter [ 2 ] do
5674: LD_ADDR_VAR 0 2
5678: PUSH
5679: DOUBLE
5680: LD_INT 1
5682: DEC
5683: ST_TO_ADDR
5684: LD_VAR 0 16
5688: PUSH
5689: LD_INT 2
5691: ARRAY
5692: PUSH
5693: FOR_TO
5694: IFFALSE 5725
// begin PrepareHuman ( false , 2 , skill ) ;
5696: LD_INT 0
5698: PPUSH
5699: LD_INT 2
5701: PPUSH
5702: LD_VAR 0 6
5706: PPUSH
5707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5711: CALL_OW 44
5715: PPUSH
5716: LD_INT 16
5718: PPUSH
5719: CALL_OW 52
// end ;
5723: GO 5693
5725: POP
5726: POP
// for i = 1 to personel_counter [ 3 ] do
5727: LD_ADDR_VAR 0 2
5731: PUSH
5732: DOUBLE
5733: LD_INT 1
5735: DEC
5736: ST_TO_ADDR
5737: LD_VAR 0 16
5741: PUSH
5742: LD_INT 3
5744: ARRAY
5745: PUSH
5746: FOR_TO
5747: IFFALSE 5794
// begin PrepareHuman ( false , 3 , skill ) ;
5749: LD_INT 0
5751: PPUSH
5752: LD_INT 3
5754: PPUSH
5755: LD_VAR 0 6
5759: PPUSH
5760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5764: CALL_OW 44
5768: PPUSH
5769: LD_VAR 0 11
5773: PUSH
5774: LD_VAR 0 2
5778: PUSH
5779: LD_INT 2
5781: MOD
5782: PUSH
5783: LD_INT 1
5785: PLUS
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
// end ;
5792: GO 5746
5794: POP
5795: POP
// for i = 1 to personel_counter [ 4 ] do
5796: LD_ADDR_VAR 0 2
5800: PUSH
5801: DOUBLE
5802: LD_INT 1
5804: DEC
5805: ST_TO_ADDR
5806: LD_VAR 0 16
5810: PUSH
5811: LD_INT 4
5813: ARRAY
5814: PUSH
5815: FOR_TO
5816: IFFALSE 5853
// begin PrepareHuman ( false , 4 , skill ) ;
5818: LD_INT 0
5820: PPUSH
5821: LD_INT 4
5823: PPUSH
5824: LD_VAR 0 6
5828: PPUSH
5829: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5833: CALL_OW 44
5837: PPUSH
5838: LD_VAR 0 10
5842: PUSH
5843: LD_INT 1
5845: ARRAY
5846: PPUSH
5847: CALL_OW 52
// end ;
5851: GO 5815
5853: POP
5854: POP
// for i in breastworks_list do
5855: LD_ADDR_VAR 0 2
5859: PUSH
5860: LD_VAR 0 12
5864: PUSH
5865: FOR_IN
5866: IFFALSE 5978
// begin r := GetDir ( i ) ;
5868: LD_ADDR_VAR 0 4
5872: PUSH
5873: LD_VAR 0 2
5877: PPUSH
5878: CALL_OW 254
5882: ST_TO_ADDR
// if r > 3 then
5883: LD_VAR 0 4
5887: PUSH
5888: LD_INT 3
5890: GREATER
5891: IFFALSE 5909
// r := r - 3 else
5893: LD_ADDR_VAR 0 4
5897: PUSH
5898: LD_VAR 0 4
5902: PUSH
5903: LD_INT 3
5905: MINUS
5906: ST_TO_ADDR
5907: GO 5923
// r := r + 3 ;
5909: LD_ADDR_VAR 0 4
5913: PUSH
5914: LD_VAR 0 4
5918: PUSH
5919: LD_INT 3
5921: PLUS
5922: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5923: LD_INT 0
5925: PPUSH
5926: LD_INT 1
5928: PPUSH
5929: LD_VAR 0 6
5933: PPUSH
5934: CALL_OW 380
// un := CreateHuman ;
5938: LD_ADDR_VAR 0 5
5942: PUSH
5943: CALL_OW 44
5947: ST_TO_ADDR
// SetDir ( un , r ) ;
5948: LD_VAR 0 5
5952: PPUSH
5953: LD_VAR 0 4
5957: PPUSH
5958: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5962: LD_VAR 0 5
5966: PPUSH
5967: LD_VAR 0 2
5971: PPUSH
5972: CALL_OW 52
// end ;
5976: GO 5865
5978: POP
5979: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5980: LD_ADDR_VAR 0 8
5984: PUSH
5985: LD_INT 22
5987: PUSH
5988: LD_INT 3
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 25
5997: PUSH
5998: LD_INT 3
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: PPUSH
6009: CALL_OW 69
6013: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
6014: LD_ADDR_VAR 0 4
6018: PUSH
6019: LD_INT 4
6021: PUSH
6022: LD_INT 5
6024: PUSH
6025: LD_INT 6
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: LIST
6032: PUSH
6033: LD_OWVAR 67
6037: ARRAY
6038: ST_TO_ADDR
// for i = 1 to r do
6039: LD_ADDR_VAR 0 2
6043: PUSH
6044: DOUBLE
6045: LD_INT 1
6047: DEC
6048: ST_TO_ADDR
6049: LD_VAR 0 4
6053: PUSH
6054: FOR_TO
6055: IFFALSE 6228
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
6057: LD_ADDR_VAR 0 5
6061: PUSH
6062: LD_INT 3
6064: PPUSH
6065: LD_INT 3
6067: PPUSH
6068: LD_INT 22
6070: PUSH
6071: LD_INT 22
6073: PUSH
6074: LD_INT 24
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_VAR 0 2
6086: PUSH
6087: LD_INT 3
6089: MOD
6090: PUSH
6091: LD_INT 1
6093: PLUS
6094: ARRAY
6095: PPUSH
6096: LD_INT 1
6098: PPUSH
6099: LD_INT 1
6101: PPUSH
6102: LD_INT 43
6104: PUSH
6105: LD_INT 44
6107: PUSH
6108: LD_INT 42
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: LD_INT 3
6123: MOD
6124: PUSH
6125: LD_INT 1
6127: PLUS
6128: ARRAY
6129: PPUSH
6130: LD_INT 100
6132: PPUSH
6133: CALL 429 0 7
6137: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6138: LD_VAR 0 5
6142: PPUSH
6143: LD_INT 0
6145: PPUSH
6146: LD_INT 5
6148: PPUSH
6149: CALL_OW 12
6153: PPUSH
6154: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
6158: LD_VAR 0 5
6162: PPUSH
6163: LD_INT 5
6165: PPUSH
6166: LD_INT 0
6168: PPUSH
6169: CALL_OW 49
// if i > tmp - 2 then
6173: LD_VAR 0 2
6177: PUSH
6178: LD_VAR 0 8
6182: PUSH
6183: LD_INT 2
6185: MINUS
6186: GREATER
6187: IFFALSE 6191
// continue ;
6189: GO 6054
// ComExitBuilding ( tmp [ i ] ) ;
6191: LD_VAR 0 8
6195: PUSH
6196: LD_VAR 0 2
6200: ARRAY
6201: PPUSH
6202: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
6206: LD_VAR 0 8
6210: PUSH
6211: LD_VAR 0 2
6215: ARRAY
6216: PPUSH
6217: LD_VAR 0 5
6221: PPUSH
6222: CALL_OW 180
// end ;
6226: GO 6054
6228: POP
6229: POP
// end ;
6230: LD_VAR 0 1
6234: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6235: LD_INT 22
6237: PUSH
6238: LD_INT 3
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 25
6247: PUSH
6248: LD_INT 2
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PPUSH
6259: CALL_OW 69
6263: IFFALSE 6995
6265: GO 6267
6267: DISABLE
6268: LD_INT 0
6270: PPUSH
6271: PPUSH
6272: PPUSH
6273: PPUSH
6274: PPUSH
// begin enable ;
6275: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6276: LD_ADDR_VAR 0 2
6280: PUSH
6281: LD_INT 6
6283: PPUSH
6284: LD_INT 3
6286: PUSH
6287: LD_INT 24
6289: PUSH
6290: LD_INT 1000
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: PUSH
6301: LD_INT 21
6303: PUSH
6304: LD_INT 3
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PPUSH
6315: CALL_OW 70
6319: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6320: LD_ADDR_VAR 0 4
6324: PUSH
6325: LD_INT 22
6327: PUSH
6328: LD_INT 3
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: LD_INT 25
6337: PUSH
6338: LD_INT 2
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6354: LD_VAR 0 2
6358: NOT
6359: PUSH
6360: LD_EXP 19
6364: NOT
6365: AND
6366: IFFALSE 6436
// begin for i in engs do
6368: LD_ADDR_VAR 0 1
6372: PUSH
6373: LD_VAR 0 4
6377: PUSH
6378: FOR_IN
6379: IFFALSE 6434
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6381: LD_VAR 0 1
6385: PPUSH
6386: CALL_OW 256
6390: PUSH
6391: LD_INT 1000
6393: EQUAL
6394: PUSH
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 314
6404: NOT
6405: AND
6406: PUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 310
6416: NOT
6417: AND
6418: IFFALSE 6432
// ComEnterUnit ( i , ru_dep_main ) ;
6420: LD_VAR 0 1
6424: PPUSH
6425: LD_INT 16
6427: PPUSH
6428: CALL_OW 120
6432: GO 6378
6434: POP
6435: POP
// end ; if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6436: LD_VAR 0 4
6440: PPUSH
6441: LD_INT 3
6443: PUSH
6444: LD_INT 24
6446: PUSH
6447: LD_INT 650
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PPUSH
6458: CALL_OW 72
6462: IFFALSE 6555
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6464: LD_ADDR_VAR 0 3
6468: PUSH
6469: LD_VAR 0 4
6473: PPUSH
6474: LD_INT 3
6476: PUSH
6477: LD_INT 24
6479: PUSH
6480: LD_INT 650
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: PPUSH
6491: CALL_OW 72
6495: ST_TO_ADDR
// for i in tmp do
6496: LD_ADDR_VAR 0 1
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: FOR_IN
6507: IFFALSE 6553
// if not IsInArea ( i , mainBaseArea ) then
6509: LD_VAR 0 1
6513: PPUSH
6514: LD_INT 14
6516: PPUSH
6517: CALL_OW 308
6521: NOT
6522: IFFALSE 6551
// begin ComMoveXY ( i , 129 , 125 ) ;
6524: LD_VAR 0 1
6528: PPUSH
6529: LD_INT 129
6531: PPUSH
6532: LD_INT 125
6534: PPUSH
6535: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6539: LD_VAR 0 1
6543: PPUSH
6544: LD_INT 1050
6546: PPUSH
6547: CALL_OW 202
// end ;
6551: GO 6506
6553: POP
6554: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6555: LD_ADDR_VAR 0 4
6559: PUSH
6560: LD_VAR 0 4
6564: PPUSH
6565: LD_INT 24
6567: PUSH
6568: LD_INT 650
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PPUSH
6575: CALL_OW 72
6579: ST_TO_ADDR
// if not engs then
6580: LD_VAR 0 4
6584: NOT
6585: IFFALSE 6589
// exit ;
6587: GO 6995
// if filter then
6589: LD_VAR 0 2
6593: IFFALSE 6852
// begin for i in engs do
6595: LD_ADDR_VAR 0 1
6599: PUSH
6600: LD_VAR 0 4
6604: PUSH
6605: FOR_IN
6606: IFFALSE 6630
// if IsInUnit ( i ) then
6608: LD_VAR 0 1
6612: PPUSH
6613: CALL_OW 310
6617: IFFALSE 6628
// ComExitBuilding ( i ) ;
6619: LD_VAR 0 1
6623: PPUSH
6624: CALL_OW 122
6628: GO 6605
6630: POP
6631: POP
// wait ( 3 ) ;
6632: LD_INT 3
6634: PPUSH
6635: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6639: LD_VAR 0 2
6643: PUSH
6644: LD_INT 2
6646: GREATEREQUAL
6647: PUSH
6648: LD_VAR 0 4
6652: PUSH
6653: LD_INT 2
6655: GREATEREQUAL
6656: AND
6657: IFFALSE 6805
// begin for i = 1 to engs / 2 do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: DOUBLE
6665: LD_INT 1
6667: DEC
6668: ST_TO_ADDR
6669: LD_VAR 0 4
6673: PUSH
6674: LD_INT 2
6676: DIVREAL
6677: PUSH
6678: FOR_TO
6679: IFFALSE 6725
// if not HasTask ( engs [ i ] ) then
6681: LD_VAR 0 4
6685: PUSH
6686: LD_VAR 0 1
6690: ARRAY
6691: PPUSH
6692: CALL_OW 314
6696: NOT
6697: IFFALSE 6723
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6699: LD_VAR 0 4
6703: PUSH
6704: LD_VAR 0 1
6708: ARRAY
6709: PPUSH
6710: LD_VAR 0 2
6714: PUSH
6715: LD_INT 1
6717: ARRAY
6718: PPUSH
6719: CALL_OW 130
6723: GO 6678
6725: POP
6726: POP
// for i = engs / 2 + 1 to engs do
6727: LD_ADDR_VAR 0 1
6731: PUSH
6732: DOUBLE
6733: LD_VAR 0 4
6737: PUSH
6738: LD_INT 2
6740: DIVREAL
6741: PUSH
6742: LD_INT 1
6744: PLUS
6745: DEC
6746: ST_TO_ADDR
6747: LD_VAR 0 4
6751: PUSH
6752: FOR_TO
6753: IFFALSE 6801
// if not HasTask ( engs [ i ] ) then
6755: LD_VAR 0 4
6759: PUSH
6760: LD_VAR 0 1
6764: ARRAY
6765: PPUSH
6766: CALL_OW 314
6770: NOT
6771: IFFALSE 6799
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6773: LD_VAR 0 4
6777: PUSH
6778: LD_VAR 0 1
6782: ARRAY
6783: PPUSH
6784: LD_VAR 0 2
6788: PUSH
6789: LD_VAR 0 2
6793: ARRAY
6794: PPUSH
6795: CALL_OW 130
6799: GO 6752
6801: POP
6802: POP
// end else
6803: GO 6852
// for i in engs do
6805: LD_ADDR_VAR 0 1
6809: PUSH
6810: LD_VAR 0 4
6814: PUSH
6815: FOR_IN
6816: IFFALSE 6850
// if not HasTask ( i ) then
6818: LD_VAR 0 1
6822: PPUSH
6823: CALL_OW 314
6827: NOT
6828: IFFALSE 6848
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6830: LD_VAR 0 1
6834: PPUSH
6835: LD_VAR 0 2
6839: PUSH
6840: LD_INT 1
6842: ARRAY
6843: PPUSH
6844: CALL_OW 130
6848: GO 6815
6850: POP
6851: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6852: LD_ADDR_VAR 0 5
6856: PUSH
6857: LD_INT 81
6859: PUSH
6860: LD_INT 3
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: PPUSH
6867: CALL_OW 69
6871: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6872: LD_EXP 19
6876: PUSH
6877: LD_VAR 0 2
6881: NOT
6882: AND
6883: IFFALSE 6995
// begin ComExitBuilding ( engs ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6894: LD_VAR 0 5
6898: PPUSH
6899: LD_EXP 19
6903: PUSH
6904: LD_INT 2
6906: ARRAY
6907: PPUSH
6908: LD_EXP 19
6912: PUSH
6913: LD_INT 3
6915: ARRAY
6916: PPUSH
6917: CALL_OW 73
6921: PPUSH
6922: LD_EXP 19
6926: PUSH
6927: LD_INT 2
6929: ARRAY
6930: PPUSH
6931: LD_EXP 19
6935: PUSH
6936: LD_INT 3
6938: ARRAY
6939: PPUSH
6940: CALL_OW 297
6944: PUSH
6945: LD_INT 10
6947: GREATER
6948: IFFALSE 6995
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6950: LD_VAR 0 4
6954: PPUSH
6955: LD_EXP 19
6959: PUSH
6960: LD_INT 1
6962: ARRAY
6963: PPUSH
6964: LD_EXP 19
6968: PUSH
6969: LD_INT 2
6971: ARRAY
6972: PPUSH
6973: LD_EXP 19
6977: PUSH
6978: LD_INT 3
6980: ARRAY
6981: PPUSH
6982: LD_EXP 19
6986: PUSH
6987: LD_INT 4
6989: ARRAY
6990: PPUSH
6991: CALL_OW 145
// end ; end ;
6995: PPOPN 5
6997: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 250 do var i , tmp ;
6998: LD_INT 16
7000: PPUSH
7001: CALL_OW 256
7005: PUSH
7006: LD_INT 250
7008: LESS
7009: IFFALSE 7199
7011: GO 7013
7013: DISABLE
7014: LD_INT 0
7016: PPUSH
7017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_INT 3
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 2
7035: PUSH
7036: LD_INT 25
7038: PUSH
7039: LD_INT 1
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: PUSH
7046: LD_INT 25
7048: PUSH
7049: LD_INT 3
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: PUSH
7056: LD_INT 25
7058: PUSH
7059: LD_INT 4
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PPUSH
7076: CALL_OW 69
7080: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
7081: LD_VAR 0 2
7085: PPUSH
7086: CALL_OW 122
// wait ( 3 ) ;
7090: LD_INT 3
7092: PPUSH
7093: CALL_OW 67
// ComMoveXY ( tmp , 156 , 211 ) ;
7097: LD_VAR 0 2
7101: PPUSH
7102: LD_INT 156
7104: PPUSH
7105: LD_INT 211
7107: PPUSH
7108: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7112: LD_INT 35
7114: PPUSH
7115: CALL_OW 67
// for i in tmp do
7119: LD_ADDR_VAR 0 1
7123: PUSH
7124: LD_VAR 0 2
7128: PUSH
7129: FOR_IN
7130: IFFALSE 7190
// if IsInArea ( i , escapeArea ) then
7132: LD_VAR 0 1
7136: PPUSH
7137: LD_INT 15
7139: PPUSH
7140: CALL_OW 308
7144: IFFALSE 7173
// begin RemoveUnit ( i ) ;
7146: LD_VAR 0 1
7150: PPUSH
7151: CALL_OW 64
// tmp := tmp diff i ;
7155: LD_ADDR_VAR 0 2
7159: PUSH
7160: LD_VAR 0 2
7164: PUSH
7165: LD_VAR 0 1
7169: DIFF
7170: ST_TO_ADDR
// end else
7171: GO 7188
// ComMoveXY ( i , 156 , 211 ) ;
7173: LD_VAR 0 1
7177: PPUSH
7178: LD_INT 156
7180: PPUSH
7181: LD_INT 211
7183: PPUSH
7184: CALL_OW 111
7188: GO 7129
7190: POP
7191: POP
// until not tmp ;
7192: LD_VAR 0 2
7196: NOT
7197: IFFALSE 7112
// end ;
7199: PPOPN 2
7201: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 250 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
7202: LD_INT 16
7204: PPUSH
7205: CALL_OW 256
7209: PUSH
7210: LD_INT 250
7212: GREATER
7213: PUSH
7214: LD_INT 22
7216: PUSH
7217: LD_INT 3
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 25
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 56
7236: PUSH
7237: EMPTY
7238: LIST
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: LIST
7244: PUSH
7245: EMPTY
7246: LIST
7247: PPUSH
7248: CALL_OW 69
7252: AND
7253: IFFALSE 7365
7255: GO 7257
7257: DISABLE
7258: LD_INT 0
7260: PPUSH
7261: PPUSH
// begin enable ;
7262: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
7263: LD_ADDR_VAR 0 2
7267: PUSH
7268: LD_INT 22
7270: PUSH
7271: LD_INT 3
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 25
7280: PUSH
7281: LD_INT 1
7283: PUSH
7284: EMPTY
7285: LIST
7286: LIST
7287: PUSH
7288: LD_INT 56
7290: PUSH
7291: EMPTY
7292: LIST
7293: PUSH
7294: LD_INT 3
7296: PUSH
7297: LD_INT 60
7299: PUSH
7300: EMPTY
7301: LIST
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: LIST
7311: LIST
7312: PUSH
7313: EMPTY
7314: LIST
7315: PPUSH
7316: CALL_OW 69
7320: ST_TO_ADDR
// if not tmp then
7321: LD_VAR 0 2
7325: NOT
7326: IFFALSE 7330
// exit ;
7328: GO 7365
// for i in tmp do
7330: LD_ADDR_VAR 0 1
7334: PUSH
7335: LD_VAR 0 2
7339: PUSH
7340: FOR_IN
7341: IFFALSE 7363
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7343: LD_VAR 0 1
7347: PPUSH
7348: LD_INT 0
7350: PPUSH
7351: LD_INT 143
7353: PPUSH
7354: LD_INT 143
7356: PPUSH
7357: CALL 2066 0 4
7361: GO 7340
7363: POP
7364: POP
// end ;
7365: PPOPN 2
7367: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7368: LD_INT 22
7370: PUSH
7371: LD_INT 3
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: PUSH
7378: LD_INT 25
7380: PUSH
7381: LD_INT 4
7383: PUSH
7384: EMPTY
7385: LIST
7386: LIST
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PPUSH
7392: CALL_OW 69
7396: IFFALSE 7650
7398: GO 7400
7400: DISABLE
7401: LD_INT 0
7403: PPUSH
7404: PPUSH
7405: PPUSH
// begin enable ;
7406: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7407: LD_ADDR_VAR 0 2
7411: PUSH
7412: LD_INT 14
7414: PPUSH
7415: LD_INT 22
7417: PUSH
7418: LD_INT 3
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: LD_INT 21
7427: PUSH
7428: LD_INT 1
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: PUSH
7435: LD_INT 3
7437: PUSH
7438: LD_INT 24
7440: PUSH
7441: LD_INT 1000
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: PPUSH
7457: CALL_OW 70
7461: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7462: LD_ADDR_VAR 0 3
7466: PUSH
7467: LD_INT 22
7469: PUSH
7470: LD_INT 3
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: PUSH
7477: LD_INT 25
7479: PUSH
7480: LD_INT 4
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PPUSH
7491: CALL_OW 69
7495: ST_TO_ADDR
// if not doc then
7496: LD_VAR 0 3
7500: NOT
7501: IFFALSE 7505
// exit ;
7503: GO 7650
// if not tmp then
7505: LD_VAR 0 2
7509: NOT
7510: IFFALSE 7601
// begin if not IsInUnit ( doc [ 1 ] ) then
7512: LD_VAR 0 3
7516: PUSH
7517: LD_INT 1
7519: ARRAY
7520: PPUSH
7521: CALL_OW 310
7525: NOT
7526: IFFALSE 7599
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7528: LD_VAR 0 3
7532: PPUSH
7533: LD_INT 22
7535: PUSH
7536: LD_INT 3
7538: PUSH
7539: EMPTY
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 2
7545: PUSH
7546: LD_INT 30
7548: PUSH
7549: LD_INT 6
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 30
7558: PUSH
7559: LD_INT 7
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: LD_INT 30
7568: PUSH
7569: LD_INT 8
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PPUSH
7586: CALL_OW 69
7590: PUSH
7591: LD_INT 1
7593: ARRAY
7594: PPUSH
7595: CALL_OW 120
// exit ;
7599: GO 7650
// end ; if IsInUnit ( doc [ 1 ] ) then
7601: LD_VAR 0 3
7605: PUSH
7606: LD_INT 1
7608: ARRAY
7609: PPUSH
7610: CALL_OW 310
7614: IFFALSE 7625
// ComExitBuilding ( doc ) ;
7616: LD_VAR 0 3
7620: PPUSH
7621: CALL_OW 122
// wait ( 3 ) ;
7625: LD_INT 3
7627: PPUSH
7628: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7632: LD_VAR 0 3
7636: PPUSH
7637: LD_VAR 0 2
7641: PUSH
7642: LD_INT 1
7644: ARRAY
7645: PPUSH
7646: CALL_OW 128
// end ;
7650: PPOPN 3
7652: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7653: LD_INT 22
7655: PUSH
7656: LD_INT 3
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 25
7665: PUSH
7666: LD_INT 3
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PPUSH
7677: CALL_OW 69
7681: PUSH
7682: LD_INT 22
7684: PUSH
7685: LD_INT 3
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PPUSH
7706: CALL_OW 69
7710: AND
7711: IFFALSE 8125
7713: GO 7715
7715: DISABLE
7716: LD_INT 0
7718: PPUSH
7719: PPUSH
7720: PPUSH
7721: PPUSH
7722: PPUSH
// begin enable ;
7723: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7724: LD_ADDR_VAR 0 2
7728: PUSH
7729: LD_INT 22
7731: PUSH
7732: LD_INT 3
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: LD_INT 21
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 3
7751: PUSH
7752: LD_INT 58
7754: PUSH
7755: EMPTY
7756: LIST
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7772: LD_ADDR_VAR 0 4
7776: PUSH
7777: LD_INT 10
7779: PUSH
7780: LD_INT 11
7782: PUSH
7783: LD_INT 12
7785: PUSH
7786: LD_INT 14
7788: PUSH
7789: EMPTY
7790: LIST
7791: LIST
7792: LIST
7793: LIST
7794: ST_TO_ADDR
// area := 0 ;
7795: LD_ADDR_VAR 0 5
7799: PUSH
7800: LD_INT 0
7802: ST_TO_ADDR
// attacking := false ;
7803: LD_ADDR_VAR 0 3
7807: PUSH
7808: LD_INT 0
7810: ST_TO_ADDR
// for i in tmp do
7811: LD_ADDR_VAR 0 1
7815: PUSH
7816: LD_VAR 0 2
7820: PUSH
7821: FOR_IN
7822: IFFALSE 7908
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7824: LD_VAR 0 1
7828: PPUSH
7829: LD_INT 22
7831: PUSH
7832: LD_INT 1
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PPUSH
7839: CALL_OW 69
7843: PPUSH
7844: LD_VAR 0 1
7848: PPUSH
7849: CALL_OW 74
7853: PPUSH
7854: CALL_OW 296
7858: PUSH
7859: LD_INT 10
7861: LESS
7862: IFFALSE 7906
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7864: LD_VAR 0 1
7868: PPUSH
7869: LD_INT 22
7871: PUSH
7872: LD_INT 1
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PPUSH
7879: CALL_OW 69
7883: PPUSH
7884: LD_VAR 0 1
7888: PPUSH
7889: CALL_OW 74
7893: PPUSH
7894: CALL_OW 115
// attacking := true ;
7898: LD_ADDR_VAR 0 3
7902: PUSH
7903: LD_INT 1
7905: ST_TO_ADDR
// end ;
7906: GO 7821
7908: POP
7909: POP
// if attacking then
7910: LD_VAR 0 3
7914: IFFALSE 7918
// exit ;
7916: GO 8125
// for i in areas do
7918: LD_ADDR_VAR 0 1
7922: PUSH
7923: LD_VAR 0 4
7927: PUSH
7928: FOR_IN
7929: IFFALSE 7966
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 22
7938: PUSH
7939: LD_INT 1
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PPUSH
7946: CALL_OW 70
7950: IFFALSE 7964
// begin area := i ;
7952: LD_ADDR_VAR 0 5
7956: PUSH
7957: LD_VAR 0 1
7961: ST_TO_ADDR
// break ;
7962: GO 7966
// end ;
7964: GO 7928
7966: POP
7967: POP
// if area then
7968: LD_VAR 0 5
7972: IFFALSE 8125
// begin for i in tmp do
7974: LD_ADDR_VAR 0 1
7978: PUSH
7979: LD_VAR 0 2
7983: PUSH
7984: FOR_IN
7985: IFFALSE 8123
// begin if GetFuel ( i ) < 33 then
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 261
7996: PUSH
7997: LD_INT 33
7999: LESS
8000: IFFALSE 8014
// SetFuel ( i , 33 ) ;
8002: LD_VAR 0 1
8006: PPUSH
8007: LD_INT 33
8009: PPUSH
8010: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
8014: LD_VAR 0 1
8018: PPUSH
8019: LD_INT 22
8021: PUSH
8022: LD_INT 1
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PPUSH
8029: CALL_OW 69
8033: PPUSH
8034: LD_VAR 0 1
8038: PPUSH
8039: CALL_OW 74
8043: PPUSH
8044: CALL_OW 296
8048: PUSH
8049: LD_INT 10
8051: LESS
8052: IFFALSE 8090
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8054: LD_VAR 0 1
8058: PPUSH
8059: LD_INT 22
8061: PUSH
8062: LD_INT 1
8064: PUSH
8065: EMPTY
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL_OW 69
8073: PPUSH
8074: LD_VAR 0 1
8078: PPUSH
8079: CALL_OW 74
8083: PPUSH
8084: CALL_OW 115
8088: GO 8121
// if not IsInArea ( i , area ) then
8090: LD_VAR 0 1
8094: PPUSH
8095: LD_VAR 0 5
8099: PPUSH
8100: CALL_OW 308
8104: NOT
8105: IFFALSE 8121
// ComMoveToArea ( i , area ) ;
8107: LD_VAR 0 1
8111: PPUSH
8112: LD_VAR 0 5
8116: PPUSH
8117: CALL_OW 113
// end ;
8121: GO 7984
8123: POP
8124: POP
// end ; end ;
8125: PPOPN 5
8127: END
// every 15 15$00 trigger Difficulty > 1 do var i , j , un , veh , time , count ;
8128: LD_OWVAR 67
8132: PUSH
8133: LD_INT 1
8135: GREATER
8136: IFFALSE 8413
8138: GO 8140
8140: DISABLE
8141: LD_INT 0
8143: PPUSH
8144: PPUSH
8145: PPUSH
8146: PPUSH
8147: PPUSH
8148: PPUSH
// begin uc_side := 3 ;
8149: LD_ADDR_OWVAR 20
8153: PUSH
8154: LD_INT 3
8156: ST_TO_ADDR
// uc_nation := 3 ;
8157: LD_ADDR_OWVAR 21
8161: PUSH
8162: LD_INT 3
8164: ST_TO_ADDR
// time := [ 9 9$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
8165: LD_ADDR_VAR 0 5
8169: PUSH
8170: LD_INT 18900
8172: PUSH
8173: LD_INT 14700
8175: PUSH
8176: LD_INT 12600
8178: PUSH
8179: EMPTY
8180: LIST
8181: LIST
8182: LIST
8183: PUSH
8184: LD_OWVAR 67
8188: ARRAY
8189: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
8190: LD_ADDR_VAR 0 6
8194: PUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 2
8200: PUSH
8201: LD_INT 3
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: LIST
8208: PUSH
8209: LD_OWVAR 67
8213: ARRAY
8214: ST_TO_ADDR
// for i = 1 to count do
8215: LD_ADDR_VAR 0 1
8219: PUSH
8220: DOUBLE
8221: LD_INT 1
8223: DEC
8224: ST_TO_ADDR
8225: LD_VAR 0 6
8229: PUSH
8230: FOR_TO
8231: IFFALSE 8411
// begin wait ( time ) ;
8233: LD_VAR 0 5
8237: PPUSH
8238: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
8242: LD_ADDR_VAR 0 2
8246: PUSH
8247: DOUBLE
8248: LD_INT 1
8250: DEC
8251: ST_TO_ADDR
8252: LD_INT 1
8254: PPUSH
8255: LD_OWVAR 67
8259: PPUSH
8260: CALL_OW 12
8264: PUSH
8265: FOR_TO
8266: IFFALSE 8407
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
8268: LD_ADDR_VAR 0 4
8272: PUSH
8273: LD_INT 3
8275: PPUSH
8276: LD_INT 3
8278: PPUSH
8279: LD_INT 22
8281: PPUSH
8282: LD_INT 1
8284: PPUSH
8285: LD_INT 1
8287: PPUSH
8288: LD_INT 43
8290: PUSH
8291: LD_INT 44
8293: PUSH
8294: LD_INT 42
8296: PUSH
8297: EMPTY
8298: LIST
8299: LIST
8300: LIST
8301: PUSH
8302: LD_VAR 0 1
8306: PUSH
8307: LD_INT 3
8309: MOD
8310: PUSH
8311: LD_INT 1
8313: PLUS
8314: ARRAY
8315: PPUSH
8316: LD_INT 80
8318: PPUSH
8319: CALL 429 0 7
8323: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8324: LD_VAR 0 4
8328: PPUSH
8329: LD_INT 13
8331: PPUSH
8332: LD_INT 0
8334: PPUSH
8335: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8339: LD_INT 0
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: LD_INT 4
8347: PUSH
8348: LD_INT 5
8350: PUSH
8351: LD_INT 5
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: LIST
8358: PUSH
8359: LD_OWVAR 67
8363: ARRAY
8364: PPUSH
8365: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8369: CALL_OW 44
8373: PPUSH
8374: LD_VAR 0 4
8378: PPUSH
8379: CALL_OW 52
// wait ( 0 0$01 ) ;
8383: LD_INT 35
8385: PPUSH
8386: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8390: LD_VAR 0 4
8394: PPUSH
8395: LD_INT 143
8397: PPUSH
8398: LD_INT 143
8400: PPUSH
8401: CALL_OW 111
// end ;
8405: GO 8265
8407: POP
8408: POP
// end ;
8409: GO 8230
8411: POP
8412: POP
// end ;
8413: PPOPN 6
8415: END
// every 8 8$00 do var i , un , time ;
8416: GO 8418
8418: DISABLE
8419: LD_INT 0
8421: PPUSH
8422: PPUSH
8423: PPUSH
// begin time := [ 3 3$00 , 1 1$00 , 0 0$30 ] ;
8424: LD_ADDR_VAR 0 3
8428: PUSH
8429: LD_INT 6300
8431: PUSH
8432: LD_INT 2100
8434: PUSH
8435: LD_INT 1050
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: LIST
8442: ST_TO_ADDR
// wait ( time ) ;
8443: LD_VAR 0 3
8447: PPUSH
8448: CALL_OW 67
// uc_side := 3 ;
8452: LD_ADDR_OWVAR 20
8456: PUSH
8457: LD_INT 3
8459: ST_TO_ADDR
// uc_nation := 3 ;
8460: LD_ADDR_OWVAR 21
8464: PUSH
8465: LD_INT 3
8467: ST_TO_ADDR
// for i = 1 to 2 do
8468: LD_ADDR_VAR 0 1
8472: PUSH
8473: DOUBLE
8474: LD_INT 1
8476: DEC
8477: ST_TO_ADDR
8478: LD_INT 2
8480: PUSH
8481: FOR_TO
8482: IFFALSE 8545
// begin PrepareHuman ( false , 1 , 4 ) ;
8484: LD_INT 0
8486: PPUSH
8487: LD_INT 1
8489: PPUSH
8490: LD_INT 4
8492: PPUSH
8493: CALL_OW 380
// un := CreateHuman ;
8497: LD_ADDR_VAR 0 2
8501: PUSH
8502: CALL_OW 44
8506: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8507: LD_VAR 0 2
8511: PPUSH
8512: LD_INT 16
8514: PPUSH
8515: CALL_OW 52
// ComExitBuilding ( un ) ;
8519: LD_VAR 0 2
8523: PPUSH
8524: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8528: LD_VAR 0 2
8532: PPUSH
8533: LD_INT 41
8535: PPUSH
8536: LD_INT 76
8538: PPUSH
8539: CALL_OW 174
// end ;
8543: GO 8481
8545: POP
8546: POP
// end ; end_of_file
8547: PPOPN 3
8549: END
// export function Action ; begin
8550: LD_INT 0
8552: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8553: LD_INT 28
8555: PPUSH
8556: LD_INT 3
8558: PPUSH
8559: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8563: LD_INT 41
8565: PPUSH
8566: LD_INT 76
8568: PPUSH
8569: LD_INT 1
8571: PPUSH
8572: LD_INT 10
8574: PPUSH
8575: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8579: LD_INT 41
8581: PPUSH
8582: LD_INT 76
8584: PPUSH
8585: LD_INT 1
8587: PPUSH
8588: CALL_OW 331
// InGameOn ;
8592: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8596: LD_EXP 18
8600: PPUSH
8601: LD_STRING D2-Har-1
8603: PPUSH
8604: CALL_OW 94
// InGameOff ;
8608: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8612: LD_STRING M1
8614: PPUSH
8615: CALL_OW 337
// end ;
8619: LD_VAR 0 1
8623: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8624: LD_EXP 4
8628: PUSH
8629: LD_INT 1
8631: GREATER
8632: IFFALSE 8723
8634: GO 8636
8636: DISABLE
8637: LD_INT 0
8639: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_INT 1
8647: PPUSH
8648: CALL 517 0 1
8652: PUSH
8653: LD_INT 1
8655: ARRAY
8656: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8657: LD_VAR 0 1
8661: PPUSH
8662: LD_STRING D2a-Sol1-1
8664: PPUSH
8665: CALL_OW 88
// if not un then
8669: LD_VAR 0 1
8673: NOT
8674: IFFALSE 8705
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8676: LD_ADDR_VAR 0 1
8680: PUSH
8681: LD_INT 2
8683: PPUSH
8684: CALL 517 0 1
8688: PUSH
8689: LD_INT 1
8691: ARRAY
8692: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8693: LD_VAR 0 1
8697: PPUSH
8698: LD_STRING D2a-FSol1-1
8700: PPUSH
8701: CALL_OW 88
// end ; if Khatam then
8705: LD_EXP 16
8709: IFFALSE 8723
// Say ( Khatam , D3b-Khat-3 ) ;
8711: LD_EXP 16
8715: PPUSH
8716: LD_STRING D3b-Khat-3
8718: PPUSH
8719: CALL_OW 88
// end ;
8723: PPOPN 1
8725: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8726: LD_EXP 14
8730: PUSH
8731: LD_EXP 17
8735: NOT
8736: AND
8737: PUSH
8738: LD_INT 22
8740: PUSH
8741: LD_INT 1
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: LD_INT 92
8750: PUSH
8751: LD_EXP 14
8755: PPUSH
8756: CALL_OW 250
8760: PUSH
8761: LD_EXP 14
8765: PPUSH
8766: CALL_OW 251
8770: PUSH
8771: LD_INT 7
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: LIST
8778: LIST
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PPUSH
8784: CALL_OW 69
8788: AND
8789: PUSH
8790: LD_INT 1
8792: PPUSH
8793: CALL_OW 463
8797: NOT
8798: AND
8799: IFFALSE 9386
8801: GO 8803
8803: DISABLE
8804: LD_INT 0
8806: PPUSH
8807: PPUSH
// begin InGameOn ;
8808: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8812: LD_ADDR_VAR 0 2
8816: PUSH
8817: LD_INT 22
8819: PUSH
8820: LD_INT 0
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 25
8829: PUSH
8830: LD_INT 12
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: PUSH
8837: EMPTY
8838: LIST
8839: LIST
8840: PPUSH
8841: CALL_OW 69
8845: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8846: LD_ADDR_VAR 0 2
8850: PUSH
8851: LD_VAR 0 2
8855: PPUSH
8856: LD_EXP 14
8860: PPUSH
8861: CALL_OW 74
8865: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: LD_INT 22
8873: PUSH
8874: LD_INT 1
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: LD_INT 21
8883: PUSH
8884: LD_INT 1
8886: PUSH
8887: EMPTY
8888: LIST
8889: LIST
8890: PUSH
8891: LD_INT 91
8893: PUSH
8894: LD_EXP 14
8898: PUSH
8899: LD_INT 20
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: LIST
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: LIST
8911: PPUSH
8912: CALL_OW 69
8916: PUSH
8917: FOR_IN
8918: IFFALSE 8936
// ComTurnUnit ( i , Frank ) ;
8920: LD_VAR 0 1
8924: PPUSH
8925: LD_EXP 14
8929: PPUSH
8930: CALL_OW 119
8934: GO 8917
8936: POP
8937: POP
// SetSide ( Frank , 1 ) ;
8938: LD_EXP 14
8942: PPUSH
8943: LD_INT 1
8945: PPUSH
8946: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8950: LD_EXP 8
8954: PPUSH
8955: LD_EXP 14
8959: PPUSH
8960: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8964: LD_EXP 8
8968: PPUSH
8969: LD_EXP 14
8973: PPUSH
8974: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8978: LD_EXP 14
8982: PPUSH
8983: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8987: LD_EXP 14
8991: PPUSH
8992: LD_STRING D3a-Frank-1
8994: PPUSH
8995: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8999: LD_VAR 0 2
9003: PPUSH
9004: LD_INT 42
9006: PPUSH
9007: LD_INT 78
9009: PPUSH
9010: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
9014: LD_VAR 0 2
9018: PPUSH
9019: LD_EXP 14
9023: PPUSH
9024: CALL_OW 179
// if Lisa then
9028: LD_EXP 13
9032: IFFALSE 9046
// Say ( Lisa , D3a-Lisa-1 ) ;
9034: LD_EXP 13
9038: PPUSH
9039: LD_STRING D3a-Lisa-1
9041: PPUSH
9042: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
9046: LD_EXP 8
9050: PPUSH
9051: LD_STRING D3a-JMM-1
9053: PPUSH
9054: CALL_OW 88
// if Cyrus then
9058: LD_EXP 12
9062: IFFALSE 9076
// Say ( Cyrus , D3a-Cyrus-1 ) ;
9064: LD_EXP 12
9068: PPUSH
9069: LD_STRING D3a-Cyrus-1
9071: PPUSH
9072: CALL_OW 88
// if GetRandom ( sex_male ) then
9076: LD_INT 1
9078: PPUSH
9079: CALL 517 0 1
9083: IFFALSE 9104
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
9085: LD_INT 1
9087: PPUSH
9088: CALL 517 0 1
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PPUSH
9097: LD_STRING D3a-Sol1-1
9099: PPUSH
9100: CALL_OW 88
// if GetRandom ( sex_female ) then
9104: LD_INT 2
9106: PPUSH
9107: CALL 517 0 1
9111: IFFALSE 9132
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
9113: LD_INT 2
9115: PPUSH
9116: CALL 517 0 1
9120: PUSH
9121: LD_INT 1
9123: ARRAY
9124: PPUSH
9125: LD_STRING D3a-FSol1-1
9127: PPUSH
9128: CALL_OW 88
// if Gladstone then
9132: LD_EXP 15
9136: IFFALSE 9150
// Say ( Gladstone , D3a-Glad-1 ) ;
9138: LD_EXP 15
9142: PPUSH
9143: LD_STRING D3a-Glad-1
9145: PPUSH
9146: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
9150: LD_VAR 0 2
9154: PPUSH
9155: LD_INT 60
9157: PPUSH
9158: LD_INT 113
9160: PPUSH
9161: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
9165: LD_EXP 14
9169: PPUSH
9170: LD_STRING D3a-Frank-2
9172: PPUSH
9173: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
9177: LD_EXP 14
9181: PPUSH
9182: LD_EXP 8
9186: PPUSH
9187: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
9191: LD_EXP 8
9195: PPUSH
9196: LD_STRING D3a-JMM-2
9198: PPUSH
9199: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9203: LD_INT 1
9205: PPUSH
9206: LD_INT 4
9208: PPUSH
9209: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9213: LD_INT 85
9215: PPUSH
9216: LD_INT 134
9218: PPUSH
9219: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
9223: LD_EXP 14
9227: PPUSH
9228: LD_STRING D3a-Frank-3
9230: PPUSH
9231: CALL_OW 88
// Wait ( 0 0$01 ) ;
9235: LD_INT 35
9237: PPUSH
9238: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
9242: LD_INT 166
9244: PPUSH
9245: LD_INT 136
9247: PPUSH
9248: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9252: LD_EXP 8
9256: PPUSH
9257: LD_STRING D3a-JMM-3
9259: PPUSH
9260: CALL_OW 88
// Wait ( 0 0$01 ) ;
9264: LD_INT 35
9266: PPUSH
9267: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9271: LD_EXP 14
9275: PPUSH
9276: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9280: LD_EXP 14
9284: PPUSH
9285: LD_STRING D3a-Frank-4
9287: PPUSH
9288: CALL_OW 88
// if Lisa then
9292: LD_EXP 13
9296: IFFALSE 9310
// Say ( Lisa , D3a-Lisa-4 ) ;
9298: LD_EXP 13
9302: PPUSH
9303: LD_STRING D3a-Lisa-4
9305: PPUSH
9306: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9310: LD_EXP 8
9314: PPUSH
9315: LD_STRING D3a-JMM-4
9317: PPUSH
9318: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9322: LD_EXP 14
9326: PPUSH
9327: LD_STRING D3a-Frank-5
9329: PPUSH
9330: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9334: LD_EXP 8
9338: PPUSH
9339: LD_STRING D3a-JMM-5
9341: PPUSH
9342: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9346: LD_EXP 14
9350: PPUSH
9351: LD_STRING D3a-Frank-6
9353: PPUSH
9354: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9358: LD_EXP 8
9362: PPUSH
9363: LD_STRING D3a-JMM-6
9365: PPUSH
9366: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9370: LD_EXP 14
9374: PPUSH
9375: LD_STRING D3a-Frank-7
9377: PPUSH
9378: CALL_OW 88
// InGameOff ;
9382: CALL_OW 9
// end ;
9386: PPOPN 2
9388: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9389: LD_EXP 17
9393: PUSH
9394: LD_EXP 14
9398: NOT
9399: AND
9400: PUSH
9401: LD_INT 22
9403: PUSH
9404: LD_INT 1
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 92
9413: PUSH
9414: LD_EXP 17
9418: PPUSH
9419: CALL_OW 250
9423: PUSH
9424: LD_EXP 17
9428: PPUSH
9429: CALL_OW 251
9433: PUSH
9434: LD_INT 7
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PPUSH
9447: CALL_OW 69
9451: AND
9452: PUSH
9453: LD_INT 1
9455: PPUSH
9456: CALL_OW 463
9460: NOT
9461: AND
9462: IFFALSE 9642
9464: GO 9466
9466: DISABLE
// begin InGameOn ;
9467: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9471: LD_EXP 8
9475: PPUSH
9476: LD_EXP 17
9480: PPUSH
9481: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9485: LD_EXP 17
9489: PPUSH
9490: LD_EXP 8
9494: PPUSH
9495: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9499: LD_EXP 17
9503: PPUSH
9504: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9508: LD_EXP 17
9512: PPUSH
9513: LD_STRING D3b-Yam-1
9515: PPUSH
9516: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9520: LD_EXP 8
9524: PPUSH
9525: LD_STRING D3b-JMM-1
9527: PPUSH
9528: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9532: LD_INT 1
9534: PPUSH
9535: LD_INT 4
9537: PPUSH
9538: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9542: LD_INT 85
9544: PPUSH
9545: LD_INT 134
9547: PPUSH
9548: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9552: LD_EXP 17
9556: PPUSH
9557: LD_STRING D3b-Yam-2
9559: PPUSH
9560: CALL_OW 88
// Wait ( 0 0$01 ) ;
9564: LD_INT 35
9566: PPUSH
9567: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9571: LD_EXP 8
9575: PPUSH
9576: LD_STRING D3b-JMM-2
9578: PPUSH
9579: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9583: LD_INT 166
9585: PPUSH
9586: LD_INT 136
9588: PPUSH
9589: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9593: LD_EXP 17
9597: PPUSH
9598: LD_STRING D3b-Yam-3
9600: PPUSH
9601: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9605: LD_EXP 8
9609: PPUSH
9610: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9614: LD_EXP 8
9618: PPUSH
9619: LD_STRING D3b-JMM-3a
9621: PPUSH
9622: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9626: LD_EXP 17
9630: PPUSH
9631: LD_INT 1
9633: PPUSH
9634: CALL_OW 235
// InGameOff ;
9638: CALL_OW 9
// end ;
9642: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , tw , i ;
9643: LD_INT 7
9645: PPUSH
9646: LD_INT 22
9648: PUSH
9649: LD_INT 1
9651: PUSH
9652: EMPTY
9653: LIST
9654: LIST
9655: PUSH
9656: LD_INT 3
9658: PUSH
9659: LD_INT 24
9661: PUSH
9662: LD_INT 1000
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: CALL_OW 70
9681: IFFALSE 10137
9683: GO 9685
9685: DISABLE
9686: LD_INT 0
9688: PPUSH
9689: PPUSH
9690: PPUSH
9691: PPUSH
// begin repeat wait ( 0 0$1 ) ;
9692: LD_INT 35
9694: PPUSH
9695: CALL_OW 67
// un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
9699: LD_ADDR_VAR 0 1
9703: PUSH
9704: LD_INT 7
9706: PPUSH
9707: LD_INT 22
9709: PUSH
9710: LD_INT 1
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 24
9722: PUSH
9723: LD_INT 1000
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 70
9742: ST_TO_ADDR
// if not un then
9743: LD_VAR 0 1
9747: NOT
9748: IFFALSE 9752
// continue ;
9750: GO 9692
// tw := NearbyTowerHasEnergy ( un [ 1 ] ) ;
9752: LD_ADDR_VAR 0 3
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 1
9764: ARRAY
9765: PPUSH
9766: CALL 3414 0 1
9770: ST_TO_ADDR
// until tw ;
9771: LD_VAR 0 3
9775: IFFALSE 9692
// DialogueOn ;
9777: CALL_OW 6
// CenterNowOnUnits ( tw ) ;
9781: LD_VAR 0 3
9785: PPUSH
9786: CALL_OW 87
// if Lisa then
9790: LD_EXP 13
9794: IFFALSE 9822
// begin Say ( Lisa , D5-Lisa-1 ) ;
9796: LD_EXP 13
9800: PPUSH
9801: LD_STRING D5-Lisa-1
9803: PPUSH
9804: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9808: LD_EXP 8
9812: PPUSH
9813: LD_STRING D5-JMM-1a
9815: PPUSH
9816: CALL_OW 88
// end else
9820: GO 9834
// Say ( JMM , D5-JMM-1 ) ;
9822: LD_EXP 8
9826: PPUSH
9827: LD_STRING D5-JMM-1
9829: PPUSH
9830: CALL_OW 88
// DialogueOff ;
9834: CALL_OW 7
// while ( true ) do
9838: LD_INT 1
9840: IFFALSE 9896
// begin wait ( 0 0$01 ) ;
9842: LD_INT 35
9844: PPUSH
9845: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9849: LD_ADDR_VAR 0 2
9853: PUSH
9854: LD_INT 8
9856: PPUSH
9857: LD_INT 30
9859: PUSH
9860: LD_INT 26
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PUSH
9867: LD_INT 101
9869: PUSH
9870: LD_INT 1
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PPUSH
9881: CALL_OW 71
9885: ST_TO_ADDR
// if x then
9886: LD_VAR 0 2
9890: IFFALSE 9894
// break ;
9892: GO 9896
// end ;
9894: GO 9838
// CenterOnUnits ( x [ 1 ] ) ;
9896: LD_VAR 0 2
9900: PUSH
9901: LD_INT 1
9903: ARRAY
9904: PPUSH
9905: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9909: LD_EXP 14
9913: PUSH
9914: LD_EXP 14
9918: PPUSH
9919: CALL_OW 255
9923: PUSH
9924: LD_INT 1
9926: EQUAL
9927: AND
9928: IFFALSE 9944
// Say ( Frank , D5a-Frank-1 ) else
9930: LD_EXP 14
9934: PPUSH
9935: LD_STRING D5a-Frank-1
9937: PPUSH
9938: CALL_OW 88
9942: GO 9998
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9944: LD_EXP 17
9948: PUSH
9949: LD_EXP 17
9953: PPUSH
9954: CALL_OW 255
9958: PUSH
9959: LD_INT 1
9961: EQUAL
9962: AND
9963: IFFALSE 9979
// Say ( Kikuchi , D5a-Yam-1 ) else
9965: LD_EXP 17
9969: PPUSH
9970: LD_STRING D5a-Yam-1
9972: PPUSH
9973: CALL_OW 88
9977: GO 9998
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9979: LD_INT 1
9981: PPUSH
9982: CALL 517 0 1
9986: PUSH
9987: LD_INT 1
9989: ARRAY
9990: PPUSH
9991: LD_STRING D5a-Sol1-1
9993: PPUSH
9994: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9998: LD_EXP 8
10002: PPUSH
10003: LD_STRING D5a-JMM-1
10005: PPUSH
10006: CALL_OW 88
// if Cyrus then
10010: LD_EXP 12
10014: IFFALSE 10028
// Say ( Cyrus , D5a-Cyrus-1 ) ;
10016: LD_EXP 12
10020: PPUSH
10021: LD_STRING D5a-Cyrus-1
10023: PPUSH
10024: CALL_OW 88
// x := false ;
10028: LD_ADDR_VAR 0 2
10032: PUSH
10033: LD_INT 0
10035: ST_TO_ADDR
// while ( true ) do
10036: LD_INT 1
10038: IFFALSE 10125
// begin wait ( 0 0$01 ) ;
10040: LD_INT 35
10042: PPUSH
10043: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
10047: LD_ADDR_VAR 0 4
10051: PUSH
10052: LD_INT 2
10054: PUSH
10055: LD_INT 30
10057: PUSH
10058: LD_INT 0
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: PUSH
10065: LD_INT 30
10067: PUSH
10068: LD_INT 1
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: LIST
10079: PPUSH
10080: CALL_OW 69
10084: PUSH
10085: LD_INT 1
10087: DIFF
10088: PUSH
10089: FOR_IN
10090: IFFALSE 10113
// if BaseNeedEnergy ( i ) then
10092: LD_VAR 0 4
10096: PPUSH
10097: CALL 2539 0 1
10101: IFFALSE 10111
// x := true ;
10103: LD_ADDR_VAR 0 2
10107: PUSH
10108: LD_INT 1
10110: ST_TO_ADDR
10111: GO 10089
10113: POP
10114: POP
// if x then
10115: LD_VAR 0 2
10119: IFFALSE 10123
// break ;
10121: GO 10125
// end ;
10123: GO 10036
// Say ( JMM , D5b-JMM-1 ) ;
10125: LD_EXP 8
10129: PPUSH
10130: LD_STRING D5b-JMM-1
10132: PPUSH
10133: CALL_OW 88
// end ;
10137: PPOPN 4
10139: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
10140: LD_EXP 5
10144: PUSH
10145: LD_INT 1
10147: ARRAY
10148: PUSH
10149: LD_OWVAR 1
10153: LESS
10154: IFFALSE 10354
10156: GO 10158
10158: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10159: LD_INT 16
10161: PPUSH
10162: CALL_OW 301
10166: NOT
10167: IFFALSE 10190
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
10169: LD_EXP 18
10173: PPUSH
10174: LD_STRING D3b-Har-3
10176: PPUSH
10177: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
10181: LD_STRING M2a
10183: PPUSH
10184: CALL_OW 337
// end else
10188: GO 10209
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
10190: LD_EXP 18
10194: PPUSH
10195: LD_STRING D3b-Har-3a
10197: PPUSH
10198: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
10202: LD_STRING M2
10204: PPUSH
10205: CALL_OW 337
// end ; can_end := true ;
10209: LD_ADDR_EXP 6
10213: PUSH
10214: LD_INT 1
10216: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
10217: LD_INT 9
10219: PPUSH
10220: LD_INT 1
10222: PPUSH
10223: CALL_OW 424
// Wait ( 0 0$02 ) ;
10227: LD_INT 70
10229: PPUSH
10230: CALL_OW 67
// if Lisa then
10234: LD_EXP 13
10238: IFFALSE 10252
// Say ( Lisa , D3b-Lisa ) ;
10240: LD_EXP 13
10244: PPUSH
10245: LD_STRING D3b-Lisa
10247: PPUSH
10248: CALL_OW 88
// if Bobby then
10252: LD_EXP 11
10256: IFFALSE 10270
// Say ( Bobby , D3b-Bobby-3 ) ;
10258: LD_EXP 11
10262: PPUSH
10263: LD_STRING D3b-Bobby-3
10265: PPUSH
10266: CALL_OW 88
// if Cyrus then
10270: LD_EXP 12
10274: IFFALSE 10288
// Say ( Cyrus , D3b-Cyrus-3 ) ;
10276: LD_EXP 12
10280: PPUSH
10281: LD_STRING D3b-Cyrus-3
10283: PPUSH
10284: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
10288: LD_EXP 14
10292: PUSH
10293: LD_EXP 14
10297: PPUSH
10298: CALL_OW 255
10302: PUSH
10303: LD_INT 1
10305: EQUAL
10306: AND
10307: IFFALSE 10321
// Say ( Frank , D3b-Frank-3 ) ;
10309: LD_EXP 14
10313: PPUSH
10314: LD_STRING D3b-Frank-3
10316: PPUSH
10317: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10321: LD_EXP 17
10325: PUSH
10326: LD_EXP 17
10330: PPUSH
10331: CALL_OW 255
10335: PUSH
10336: LD_INT 1
10338: EQUAL
10339: AND
10340: IFFALSE 10354
// Say ( Kikuchi , D3b-Yam-4 ) ;
10342: LD_EXP 17
10346: PPUSH
10347: LD_STRING D3b-Yam-4
10349: PPUSH
10350: CALL_OW 88
// end ;
10354: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10355: LD_EXP 5
10359: PUSH
10360: LD_INT 2
10362: ARRAY
10363: PUSH
10364: LD_OWVAR 1
10368: LESS
10369: IFFALSE 10401
10371: GO 10373
10373: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10374: LD_EXP 18
10378: PPUSH
10379: LD_STRING D4-Har-1
10381: PPUSH
10382: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10386: LD_STRING M3
10388: PPUSH
10389: CALL_OW 337
// must_end := true ;
10393: LD_ADDR_EXP 7
10397: PUSH
10398: LD_INT 1
10400: ST_TO_ADDR
// end ;
10401: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10402: LD_EXP 5
10406: PUSH
10407: LD_INT 3
10409: ARRAY
10410: PUSH
10411: LD_OWVAR 1
10415: LESS
10416: IFFALSE 10447
10418: GO 10420
10420: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10421: LD_INT 16
10423: PPUSH
10424: CALL_OW 301
10428: NOT
10429: IFFALSE 10440
// YouLost ( TimeOut1 ) else
10431: LD_STRING TimeOut1
10433: PPUSH
10434: CALL_OW 104
10438: GO 10447
// YouLost ( TimeOut2 ) ;
10440: LD_STRING TimeOut2
10442: PPUSH
10443: CALL_OW 104
// end ;
10447: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp , m1 , m2 , m3 ;
10448: LD_EXP 8
10452: PPUSH
10453: LD_INT 9
10455: PPUSH
10456: CALL_OW 308
10460: PUSH
10461: LD_EXP 6
10465: AND
10466: IFFALSE 11549
10468: GO 10470
10470: DISABLE
10471: LD_INT 0
10473: PPUSH
10474: PPUSH
10475: PPUSH
10476: PPUSH
10477: PPUSH
10478: PPUSH
// begin wait_on := false ;
10479: LD_ADDR_VAR 0 1
10483: PUSH
10484: LD_INT 0
10486: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10487: LD_INT 1
10489: PPUSH
10490: CALL 2616 0 1
10494: PUSH
10495: LD_INT 0
10497: PLUS
10498: PUSH
10499: LD_INT 1
10501: PPUSH
10502: LD_INT 9
10504: PPUSH
10505: CALL 2707 0 2
10509: PUSH
10510: LD_INT 1
10512: PPUSH
10513: LD_INT 9
10515: PPUSH
10516: CALL 2754 0 2
10520: ADD
10521: PUSH
10522: LD_INT 0
10524: PLUS
10525: GREATER
10526: IFFALSE 10575
// case Query ( Q1 ) of 1 :
10528: LD_STRING Q1
10530: PPUSH
10531: CALL_OW 97
10535: PUSH
10536: LD_INT 1
10538: DOUBLE
10539: EQUAL
10540: IFTRUE 10544
10542: GO 10555
10544: POP
// wait_on := true ; 2 :
10545: LD_ADDR_VAR 0 1
10549: PUSH
10550: LD_INT 1
10552: ST_TO_ADDR
10553: GO 10575
10555: LD_INT 2
10557: DOUBLE
10558: EQUAL
10559: IFTRUE 10563
10561: GO 10574
10563: POP
// wait_on := false ; end ;
10564: LD_ADDR_VAR 0 1
10568: PUSH
10569: LD_INT 0
10571: ST_TO_ADDR
10572: GO 10575
10574: POP
// repeat wait ( 0 0$01 ) ;
10575: LD_INT 35
10577: PPUSH
10578: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10582: LD_VAR 0 1
10586: NOT
10587: PUSH
10588: LD_INT 1
10590: PPUSH
10591: CALL 2616 0 1
10595: PUSH
10596: LD_INT 0
10598: PLUS
10599: PUSH
10600: LD_INT 1
10602: PPUSH
10603: LD_INT 9
10605: PPUSH
10606: CALL 2707 0 2
10610: PUSH
10611: LD_INT 1
10613: PPUSH
10614: LD_INT 9
10616: PPUSH
10617: CALL 2754 0 2
10621: ADD
10622: PUSH
10623: LD_INT 0
10625: PLUS
10626: EQUAL
10627: OR
10628: IFFALSE 10575
// DialogueOn ;
10630: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10634: LD_EXP 8
10638: PPUSH
10639: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10643: LD_EXP 8
10647: PPUSH
10648: LD_STRING D6-JMM-1
10650: PPUSH
10651: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10655: LD_EXP 18
10659: PPUSH
10660: LD_STRING D6-Har-1
10662: PPUSH
10663: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10667: LD_EXP 8
10671: PPUSH
10672: LD_STRING D6-JMM-2
10674: PPUSH
10675: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10679: LD_EXP 18
10683: PPUSH
10684: LD_STRING D6-Har-2
10686: PPUSH
10687: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10691: LD_EXP 8
10695: PPUSH
10696: LD_STRING D6-JMM-3
10698: PPUSH
10699: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10703: LD_EXP 18
10707: PPUSH
10708: LD_STRING D6-Har-3
10710: PPUSH
10711: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10715: LD_EXP 8
10719: PPUSH
10720: LD_STRING D6-JMM-4
10722: PPUSH
10723: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10727: LD_EXP 18
10731: PPUSH
10732: LD_STRING D6-Har-4
10734: PPUSH
10735: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10739: LD_EXP 8
10743: PPUSH
10744: LD_STRING D6-JMM-5
10746: PPUSH
10747: CALL_OW 88
// DialogueOff ;
10751: CALL_OW 7
// m1 := false ;
10755: LD_ADDR_VAR 0 4
10759: PUSH
10760: LD_INT 0
10762: ST_TO_ADDR
// m2 := false ;
10763: LD_ADDR_VAR 0 5
10767: PUSH
10768: LD_INT 0
10770: ST_TO_ADDR
// m3 := false ;
10771: LD_ADDR_VAR 0 6
10775: PUSH
10776: LD_INT 0
10778: ST_TO_ADDR
// tmp := FilterBuildings ( 3 ) ;
10779: LD_ADDR_VAR 0 3
10783: PUSH
10784: LD_INT 3
10786: PPUSH
10787: CALL 2885 0 1
10791: ST_TO_ADDR
// if tmp >= 35 then
10792: LD_VAR 0 3
10796: PUSH
10797: LD_INT 35
10799: GREATEREQUAL
10800: IFFALSE 10837
// begin AddMedal ( Destroy1 , - 1 ) ;
10802: LD_STRING Destroy1
10804: PPUSH
10805: LD_INT 1
10807: NEG
10808: PPUSH
10809: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10813: LD_STRING Destroy2
10815: PPUSH
10816: LD_INT 1
10818: NEG
10819: PPUSH
10820: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10824: LD_STRING Destroy3
10826: PPUSH
10827: LD_INT 1
10829: NEG
10830: PPUSH
10831: CALL_OW 101
// end else
10835: GO 10948
// begin AddMedal ( Destroy1 , 1 ) ;
10837: LD_STRING Destroy1
10839: PPUSH
10840: LD_INT 1
10842: PPUSH
10843: CALL_OW 101
// m1 := true ;
10847: LD_ADDR_VAR 0 4
10851: PUSH
10852: LD_INT 1
10854: ST_TO_ADDR
// if tmp >= 25 then
10855: LD_VAR 0 3
10859: PUSH
10860: LD_INT 25
10862: GREATEREQUAL
10863: IFFALSE 10889
// begin AddMedal ( Destroy2 , - 1 ) ;
10865: LD_STRING Destroy2
10867: PPUSH
10868: LD_INT 1
10870: NEG
10871: PPUSH
10872: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10876: LD_STRING Destroy3
10878: PPUSH
10879: LD_INT 1
10881: NEG
10882: PPUSH
10883: CALL_OW 101
// end else
10887: GO 10948
// begin AddMedal ( Destroy2 , 1 ) ;
10889: LD_STRING Destroy2
10891: PPUSH
10892: LD_INT 1
10894: PPUSH
10895: CALL_OW 101
// m2 := true ;
10899: LD_ADDR_VAR 0 5
10903: PUSH
10904: LD_INT 1
10906: ST_TO_ADDR
// if tmp >= 15 then
10907: LD_VAR 0 3
10911: PUSH
10912: LD_INT 15
10914: GREATEREQUAL
10915: IFFALSE 10930
// AddMedal ( Destroy3 , - 1 ) else
10917: LD_STRING Destroy3
10919: PPUSH
10920: LD_INT 1
10922: NEG
10923: PPUSH
10924: CALL_OW 101
10928: GO 10948
// begin AddMedal ( Destroy3 , 1 ) ;
10930: LD_STRING Destroy3
10932: PPUSH
10933: LD_INT 1
10935: PPUSH
10936: CALL_OW 101
// m3 := true ;
10940: LD_ADDR_VAR 0 6
10944: PUSH
10945: LD_INT 1
10947: ST_TO_ADDR
// end ; end ; end ; if m1 and m2 and m3 and Difficulty = 3 then
10948: LD_VAR 0 4
10952: PUSH
10953: LD_VAR 0 5
10957: AND
10958: PUSH
10959: LD_VAR 0 6
10963: AND
10964: PUSH
10965: LD_OWVAR 67
10969: PUSH
10970: LD_INT 3
10972: EQUAL
10973: AND
10974: IFFALSE 10986
// SetAchievementEX ( ACH_AMER , 7 ) ;
10976: LD_STRING ACH_AMER
10978: PPUSH
10979: LD_INT 7
10981: PPUSH
10982: CALL_OW 564
// GiveMedals ( MAIN ) ;
10986: LD_STRING MAIN
10988: PPUSH
10989: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) union FilterDriversArea ( 1 , endArea ) ;
10993: LD_ADDR_VAR 0 3
10997: PUSH
10998: LD_INT 1
11000: PPUSH
11001: LD_INT 9
11003: PPUSH
11004: CALL 2707 0 2
11008: PUSH
11009: LD_INT 1
11011: PPUSH
11012: LD_INT 9
11014: PPUSH
11015: CALL 2754 0 2
11019: UNION
11020: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11021: LD_VAR 0 3
11025: PPUSH
11026: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11030: LD_EXP 8
11034: PPUSH
11035: LD_EXP 3
11039: PUSH
11040: LD_STRING JMM
11042: STR
11043: PPUSH
11044: CALL_OW 38
// if Brown in tmp then
11048: LD_EXP 9
11052: PUSH
11053: LD_VAR 0 3
11057: IN
11058: IFFALSE 11078
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
11060: LD_EXP 9
11064: PPUSH
11065: LD_EXP 3
11069: PUSH
11070: LD_STRING Brown
11072: STR
11073: PPUSH
11074: CALL_OW 38
// if Donaldson in tmp then
11078: LD_EXP 10
11082: PUSH
11083: LD_VAR 0 3
11087: IN
11088: IFFALSE 11108
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
11090: LD_EXP 10
11094: PPUSH
11095: LD_EXP 3
11099: PUSH
11100: LD_STRING Donaldson
11102: STR
11103: PPUSH
11104: CALL_OW 38
// if Bobby in tmp then
11108: LD_EXP 11
11112: PUSH
11113: LD_VAR 0 3
11117: IN
11118: IFFALSE 11138
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11120: LD_EXP 11
11124: PPUSH
11125: LD_EXP 3
11129: PUSH
11130: LD_STRING Bobby
11132: STR
11133: PPUSH
11134: CALL_OW 38
// if Cyrus in tmp then
11138: LD_EXP 12
11142: PUSH
11143: LD_VAR 0 3
11147: IN
11148: IFFALSE 11168
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11150: LD_EXP 12
11154: PPUSH
11155: LD_EXP 3
11159: PUSH
11160: LD_STRING Cyrus
11162: STR
11163: PPUSH
11164: CALL_OW 38
// if Lisa in tmp then
11168: LD_EXP 13
11172: PUSH
11173: LD_VAR 0 3
11177: IN
11178: IFFALSE 11198
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11180: LD_EXP 13
11184: PPUSH
11185: LD_EXP 3
11189: PUSH
11190: LD_STRING Lisa
11192: STR
11193: PPUSH
11194: CALL_OW 38
// if Frank in tmp then
11198: LD_EXP 14
11202: PUSH
11203: LD_VAR 0 3
11207: IN
11208: IFFALSE 11228
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11210: LD_EXP 14
11214: PPUSH
11215: LD_EXP 3
11219: PUSH
11220: LD_STRING Frank
11222: STR
11223: PPUSH
11224: CALL_OW 38
// if Gladstone in tmp then
11228: LD_EXP 15
11232: PUSH
11233: LD_VAR 0 3
11237: IN
11238: IFFALSE 11258
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
11240: LD_EXP 15
11244: PPUSH
11245: LD_EXP 3
11249: PUSH
11250: LD_STRING Gladstone
11252: STR
11253: PPUSH
11254: CALL_OW 38
// if Khatam in tmp then
11258: LD_EXP 16
11262: PUSH
11263: LD_VAR 0 3
11267: IN
11268: IFFALSE 11288
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11270: LD_EXP 16
11274: PPUSH
11275: LD_EXP 3
11279: PUSH
11280: LD_STRING Khatam
11282: STR
11283: PPUSH
11284: CALL_OW 38
// if Kikuchi in tmp then
11288: LD_EXP 17
11292: PUSH
11293: LD_VAR 0 3
11297: IN
11298: IFFALSE 11318
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
11300: LD_EXP 17
11304: PPUSH
11305: LD_EXP 3
11309: PUSH
11310: LD_STRING Kikuchi
11312: STR
11313: PPUSH
11314: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
11318: LD_VAR 0 3
11322: PUSH
11323: LD_EXP 8
11327: PUSH
11328: LD_EXP 9
11332: PUSH
11333: LD_EXP 10
11337: PUSH
11338: LD_EXP 11
11342: PUSH
11343: LD_EXP 12
11347: PUSH
11348: LD_EXP 13
11352: PUSH
11353: LD_EXP 14
11357: PUSH
11358: LD_EXP 15
11362: PUSH
11363: LD_EXP 17
11367: PUSH
11368: LD_EXP 16
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: DIFF
11385: PPUSH
11386: LD_EXP 3
11390: PUSH
11391: LD_STRING others
11393: STR
11394: PPUSH
11395: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11399: LD_OWVAR 1
11403: PPUSH
11404: LD_STRING 07_time
11406: PPUSH
11407: CALL_OW 39
// tmp := [ ] ;
11411: LD_ADDR_VAR 0 3
11415: PUSH
11416: EMPTY
11417: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11418: LD_ADDR_VAR 0 2
11422: PUSH
11423: LD_INT 9
11425: PPUSH
11426: LD_INT 22
11428: PUSH
11429: LD_INT 1
11431: PUSH
11432: EMPTY
11433: LIST
11434: LIST
11435: PUSH
11436: LD_INT 23
11438: PUSH
11439: LD_INT 1
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: PUSH
11446: LD_INT 21
11448: PUSH
11449: LD_INT 2
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: PUSH
11461: EMPTY
11462: LIST
11463: PPUSH
11464: CALL_OW 70
11468: PUSH
11469: FOR_IN
11470: IFFALSE 11531
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11472: LD_ADDR_VAR 0 3
11476: PUSH
11477: LD_VAR 0 3
11481: PUSH
11482: LD_VAR 0 2
11486: PPUSH
11487: CALL_OW 265
11491: PUSH
11492: LD_VAR 0 2
11496: PPUSH
11497: CALL_OW 262
11501: PUSH
11502: LD_VAR 0 2
11506: PPUSH
11507: CALL_OW 263
11511: PUSH
11512: LD_VAR 0 2
11516: PPUSH
11517: CALL_OW 264
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: ADD
11528: ST_TO_ADDR
11529: GO 11469
11531: POP
11532: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11533: LD_VAR 0 3
11537: PPUSH
11538: LD_STRING 07_vehicles
11540: PPUSH
11541: CALL_OW 39
// YouWin ;
11545: CALL_OW 103
// end ; end_of_file
11549: PPOPN 6
11551: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11552: LD_VAR 0 1
11556: PUSH
11557: LD_EXP 8
11561: EQUAL
11562: IFFALSE 11571
// YouLost ( JMM ) ;
11564: LD_STRING JMM
11566: PPUSH
11567: CALL_OW 104
// if GetType ( un ) = unit_building then
11571: LD_VAR 0 1
11575: PPUSH
11576: CALL_OW 247
11580: PUSH
11581: LD_INT 3
11583: EQUAL
11584: IFFALSE 11600
// buildings_counter := buildings_counter + 1 ;
11586: LD_ADDR_EXP 4
11590: PUSH
11591: LD_EXP 4
11595: PUSH
11596: LD_INT 1
11598: PLUS
11599: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11600: LD_VAR 0 1
11604: PUSH
11605: LD_INT 6
11607: PPUSH
11608: LD_INT 2
11610: PUSH
11611: LD_INT 30
11613: PUSH
11614: LD_INT 33
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: PUSH
11621: LD_INT 30
11623: PUSH
11624: LD_INT 32
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 70
11640: IN
11641: IFFALSE 11700
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11643: LD_ADDR_EXP 19
11647: PUSH
11648: LD_EXP 19
11652: PUSH
11653: LD_VAR 0 1
11657: PPUSH
11658: CALL_OW 266
11662: PUSH
11663: LD_VAR 0 1
11667: PPUSH
11668: CALL_OW 250
11672: PUSH
11673: LD_VAR 0 1
11677: PPUSH
11678: CALL_OW 251
11682: PUSH
11683: LD_VAR 0 1
11687: PPUSH
11688: CALL_OW 254
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: ADD
11699: ST_TO_ADDR
// if un = ru_dep_main then
11700: LD_VAR 0 1
11704: PUSH
11705: LD_INT 16
11707: EQUAL
11708: IFFALSE 11717
// ChangeMissionObjectives ( M1a ) ;
11710: LD_STRING M1a
11712: PPUSH
11713: CALL_OW 337
// end ;
11717: PPOPN 1
11719: END
// on BuildingStarted ( b , builder ) do var i ;
11720: LD_INT 0
11722: PPUSH
// begin if GetSide ( b ) = 3 then
11723: LD_VAR 0 1
11727: PPUSH
11728: CALL_OW 255
11732: PUSH
11733: LD_INT 3
11735: EQUAL
11736: IFFALSE 11776
// for i = 1 to 4 do
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: DOUBLE
11744: LD_INT 1
11746: DEC
11747: ST_TO_ADDR
11748: LD_INT 4
11750: PUSH
11751: FOR_TO
11752: IFFALSE 11774
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11754: LD_ADDR_EXP 19
11758: PUSH
11759: LD_EXP 19
11763: PPUSH
11764: LD_INT 1
11766: PPUSH
11767: CALL_OW 3
11771: ST_TO_ADDR
11772: GO 11751
11774: POP
11775: POP
// end ;
11776: PPOPN 3
11778: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 266
11788: PUSH
11789: LD_INT 32
11791: PUSH
11792: LD_INT 33
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: IN
11799: IFFALSE 11813
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11801: LD_VAR 0 1
11805: PPUSH
11806: LD_INT 43
11808: PPUSH
11809: CALL_OW 148
11813: PPOPN 1
11815: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11816: LD_VAR 0 1
11820: PUSH
11821: LD_INT 22
11823: PUSH
11824: LD_INT 3
11826: PUSH
11827: EMPTY
11828: LIST
11829: LIST
11830: PUSH
11831: LD_INT 2
11833: PUSH
11834: LD_INT 30
11836: PUSH
11837: LD_INT 31
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 30
11846: PUSH
11847: LD_INT 32
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: EMPTY
11855: LIST
11856: LIST
11857: LIST
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PPUSH
11863: CALL_OW 69
11867: IN
11868: IFFALSE 11890
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11870: LD_VAR 0 2
11874: PPUSH
11875: LD_VAR 0 1
11879: PPUSH
11880: LD_INT 143
11882: PPUSH
11883: LD_INT 143
11885: PPUSH
11886: CALL 2066 0 4
// end ;
11890: PPOPN 2
11892: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11893: LD_VAR 0 1
11897: PUSH
11898: LD_INT 22
11900: PUSH
11901: LD_INT 3
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 30
11910: PUSH
11911: LD_INT 32
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PPUSH
11922: CALL_OW 69
11926: IN
11927: IFFALSE 11941
// SetTag ( b , 0 ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_INT 0
11936: PPUSH
11937: CALL_OW 109
// end ; end_of_file
11941: PPOPN 2
11943: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11944: GO 11946
11946: DISABLE
// begin ru_radar := 98 ;
11947: LD_ADDR_EXP 20
11951: PUSH
11952: LD_INT 98
11954: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11955: LD_ADDR_EXP 21
11959: PUSH
11960: LD_INT 89
11962: ST_TO_ADDR
// us_hack := 99 ;
11963: LD_ADDR_EXP 22
11967: PUSH
11968: LD_INT 99
11970: ST_TO_ADDR
// us_artillery := 97 ;
11971: LD_ADDR_EXP 23
11975: PUSH
11976: LD_INT 97
11978: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11979: LD_ADDR_EXP 24
11983: PUSH
11984: LD_INT 91
11986: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
11987: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11988: LD_INT 0
11990: PPUSH
11991: PPUSH
11992: PPUSH
11993: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11994: LD_VAR 0 1
11998: PPUSH
11999: CALL_OW 264
12003: PUSH
12004: LD_EXP 24
12008: EQUAL
12009: IFFALSE 12081
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
12011: LD_INT 68
12013: PPUSH
12014: LD_VAR 0 1
12018: PPUSH
12019: CALL_OW 255
12023: PPUSH
12024: CALL_OW 321
12028: PUSH
12029: LD_INT 2
12031: EQUAL
12032: IFFALSE 12044
// eff := 70 else
12034: LD_ADDR_VAR 0 6
12038: PUSH
12039: LD_INT 70
12041: ST_TO_ADDR
12042: GO 12052
// eff := 30 ;
12044: LD_ADDR_VAR 0 6
12048: PUSH
12049: LD_INT 30
12051: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
12052: LD_VAR 0 1
12056: PPUSH
12057: CALL_OW 250
12061: PPUSH
12062: LD_VAR 0 1
12066: PPUSH
12067: CALL_OW 251
12071: PPUSH
12072: LD_VAR 0 6
12076: PPUSH
12077: CALL_OW 495
// end ; end ;
12081: LD_VAR 0 4
12085: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
12086: LD_INT 0
12088: PPUSH
12089: PPUSH
12090: PPUSH
12091: PPUSH
12092: PPUSH
12093: PPUSH
// if cmd = 124 then
12094: LD_VAR 0 1
12098: PUSH
12099: LD_INT 124
12101: EQUAL
12102: IFFALSE 12308
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
12104: LD_ADDR_VAR 0 5
12108: PUSH
12109: LD_INT 2
12111: PUSH
12112: LD_INT 34
12114: PUSH
12115: LD_INT 53
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: PUSH
12122: LD_INT 34
12124: PUSH
12125: LD_INT 14
12127: PUSH
12128: EMPTY
12129: LIST
12130: LIST
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: LIST
12136: PPUSH
12137: CALL_OW 69
12141: ST_TO_ADDR
// if not tmp then
12142: LD_VAR 0 5
12146: NOT
12147: IFFALSE 12151
// exit ;
12149: GO 12308
// for i in tmp do
12151: LD_ADDR_VAR 0 3
12155: PUSH
12156: LD_VAR 0 5
12160: PUSH
12161: FOR_IN
12162: IFFALSE 12306
// begin taskList := GetTaskList ( i ) ;
12164: LD_ADDR_VAR 0 6
12168: PUSH
12169: LD_VAR 0 3
12173: PPUSH
12174: CALL_OW 437
12178: ST_TO_ADDR
// if not taskList then
12179: LD_VAR 0 6
12183: NOT
12184: IFFALSE 12188
// continue ;
12186: GO 12161
// for j = 1 to taskList do
12188: LD_ADDR_VAR 0 4
12192: PUSH
12193: DOUBLE
12194: LD_INT 1
12196: DEC
12197: ST_TO_ADDR
12198: LD_VAR 0 6
12202: PUSH
12203: FOR_TO
12204: IFFALSE 12302
// if taskList [ j ] [ 1 ] = | then
12206: LD_VAR 0 6
12210: PUSH
12211: LD_VAR 0 4
12215: ARRAY
12216: PUSH
12217: LD_INT 1
12219: ARRAY
12220: PUSH
12221: LD_STRING |
12223: EQUAL
12224: IFFALSE 12300
// begin _taskList := Delete ( taskList , 1 ) ;
12226: LD_ADDR_VAR 0 7
12230: PUSH
12231: LD_VAR 0 6
12235: PPUSH
12236: LD_INT 1
12238: PPUSH
12239: CALL_OW 3
12243: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
12244: LD_VAR 0 3
12248: PPUSH
12249: LD_VAR 0 7
12253: PPUSH
12254: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
12258: LD_VAR 0 3
12262: PPUSH
12263: LD_VAR 0 6
12267: PUSH
12268: LD_VAR 0 4
12272: ARRAY
12273: PUSH
12274: LD_INT 2
12276: ARRAY
12277: PPUSH
12278: LD_VAR 0 6
12282: PUSH
12283: LD_VAR 0 4
12287: ARRAY
12288: PUSH
12289: LD_INT 3
12291: ARRAY
12292: PPUSH
12293: LD_INT 8
12295: PPUSH
12296: CALL 12313 0 4
// end ;
12300: GO 12203
12302: POP
12303: POP
// end ;
12304: GO 12161
12306: POP
12307: POP
// end ; end ;
12308: LD_VAR 0 2
12312: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
12313: LD_INT 0
12315: PPUSH
12316: PPUSH
12317: PPUSH
12318: PPUSH
12319: PPUSH
12320: PPUSH
12321: PPUSH
12322: PPUSH
12323: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
12324: LD_VAR 0 1
12328: NOT
12329: PUSH
12330: LD_VAR 0 2
12334: PPUSH
12335: LD_VAR 0 3
12339: PPUSH
12340: CALL_OW 488
12344: NOT
12345: OR
12346: PUSH
12347: LD_VAR 0 4
12351: NOT
12352: OR
12353: IFFALSE 12357
// exit ;
12355: GO 12697
// list := [ ] ;
12357: LD_ADDR_VAR 0 13
12361: PUSH
12362: EMPTY
12363: ST_TO_ADDR
// if x - r < 0 then
12364: LD_VAR 0 2
12368: PUSH
12369: LD_VAR 0 4
12373: MINUS
12374: PUSH
12375: LD_INT 0
12377: LESS
12378: IFFALSE 12390
// min_x := 0 else
12380: LD_ADDR_VAR 0 7
12384: PUSH
12385: LD_INT 0
12387: ST_TO_ADDR
12388: GO 12406
// min_x := x - r ;
12390: LD_ADDR_VAR 0 7
12394: PUSH
12395: LD_VAR 0 2
12399: PUSH
12400: LD_VAR 0 4
12404: MINUS
12405: ST_TO_ADDR
// if y - r < 0 then
12406: LD_VAR 0 3
12410: PUSH
12411: LD_VAR 0 4
12415: MINUS
12416: PUSH
12417: LD_INT 0
12419: LESS
12420: IFFALSE 12432
// min_y := 0 else
12422: LD_ADDR_VAR 0 8
12426: PUSH
12427: LD_INT 0
12429: ST_TO_ADDR
12430: GO 12448
// min_y := y - r ;
12432: LD_ADDR_VAR 0 8
12436: PUSH
12437: LD_VAR 0 3
12441: PUSH
12442: LD_VAR 0 4
12446: MINUS
12447: ST_TO_ADDR
// max_x := x + r ;
12448: LD_ADDR_VAR 0 9
12452: PUSH
12453: LD_VAR 0 2
12457: PUSH
12458: LD_VAR 0 4
12462: PLUS
12463: ST_TO_ADDR
// max_y := y + r ;
12464: LD_ADDR_VAR 0 10
12468: PUSH
12469: LD_VAR 0 3
12473: PUSH
12474: LD_VAR 0 4
12478: PLUS
12479: ST_TO_ADDR
// for _x = min_x to max_x do
12480: LD_ADDR_VAR 0 11
12484: PUSH
12485: DOUBLE
12486: LD_VAR 0 7
12490: DEC
12491: ST_TO_ADDR
12492: LD_VAR 0 9
12496: PUSH
12497: FOR_TO
12498: IFFALSE 12615
// for _y = min_y to max_y do
12500: LD_ADDR_VAR 0 12
12504: PUSH
12505: DOUBLE
12506: LD_VAR 0 8
12510: DEC
12511: ST_TO_ADDR
12512: LD_VAR 0 10
12516: PUSH
12517: FOR_TO
12518: IFFALSE 12611
// begin if not ValidHex ( _x , _y ) then
12520: LD_VAR 0 11
12524: PPUSH
12525: LD_VAR 0 12
12529: PPUSH
12530: CALL_OW 488
12534: NOT
12535: IFFALSE 12539
// continue ;
12537: GO 12517
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
12539: LD_VAR 0 11
12543: PPUSH
12544: LD_VAR 0 12
12548: PPUSH
12549: CALL_OW 351
12553: PUSH
12554: LD_VAR 0 11
12558: PPUSH
12559: LD_VAR 0 12
12563: PPUSH
12564: CALL_OW 554
12568: AND
12569: IFFALSE 12609
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12571: LD_ADDR_VAR 0 13
12575: PUSH
12576: LD_VAR 0 13
12580: PPUSH
12581: LD_VAR 0 13
12585: PUSH
12586: LD_INT 1
12588: PLUS
12589: PPUSH
12590: LD_VAR 0 11
12594: PUSH
12595: LD_VAR 0 12
12599: PUSH
12600: EMPTY
12601: LIST
12602: LIST
12603: PPUSH
12604: CALL_OW 2
12608: ST_TO_ADDR
// end ;
12609: GO 12517
12611: POP
12612: POP
12613: GO 12497
12615: POP
12616: POP
// if not list then
12617: LD_VAR 0 13
12621: NOT
12622: IFFALSE 12626
// exit ;
12624: GO 12697
// for i in list do
12626: LD_ADDR_VAR 0 6
12630: PUSH
12631: LD_VAR 0 13
12635: PUSH
12636: FOR_IN
12637: IFFALSE 12695
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12639: LD_VAR 0 1
12643: PPUSH
12644: LD_STRING M
12646: PUSH
12647: LD_VAR 0 6
12651: PUSH
12652: LD_INT 1
12654: ARRAY
12655: PUSH
12656: LD_VAR 0 6
12660: PUSH
12661: LD_INT 2
12663: ARRAY
12664: PUSH
12665: LD_INT 0
12667: PUSH
12668: LD_INT 0
12670: PUSH
12671: LD_INT 0
12673: PUSH
12674: LD_INT 0
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: PPUSH
12689: CALL_OW 447
12693: GO 12636
12695: POP
12696: POP
// end ;
12697: LD_VAR 0 5
12701: RET
