// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 347 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 435 0 0
// PrepareRussian ;
  22: CALL 2928 0 0
// PrepareAmerican ;
  26: CALL 1169 0 0
// PrepareCornell ;
  30: CALL 2193 0 0
// PrepareWesternBase ;
  34: CALL 2419 0 0
// Action ;
  38: CALL 4957 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 33
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// end ;
 342: LD_VAR 0 1
 346: RET
// function SetDiplomacy ; begin
 347: LD_INT 0
 349: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PPUSH
 356: LD_INT 1
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 8
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 382: LD_INT 3
 384: PPUSH
 385: LD_INT 6
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 398: LD_INT 4
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 0
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 8
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// end ;
 430: LD_VAR 0 1
 434: RET
// export function DebugMode ; var i ; begin
 435: LD_INT 0
 437: PPUSH
 438: PPUSH
// FogOff ( 1 ) ;
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 344
// debug_strings := [ ] ;
 446: LD_ADDR_OWVAR 48
 450: PUSH
 451: EMPTY
 452: ST_TO_ADDR
// end ; end_of_file
 453: LD_VAR 0 1
 457: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 458: LD_INT 0
 460: PPUSH
 461: PPUSH
// if exist_mode then
 462: LD_VAR 0 2
 466: IFFALSE 491
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_EXP 3
 477: PUSH
 478: LD_VAR 0 1
 482: STR
 483: PPUSH
 484: CALL_OW 34
 488: ST_TO_ADDR
 489: GO 506
// unit := NewCharacter ( ident ) ;
 491: LD_ADDR_VAR 0 4
 495: PUSH
 496: LD_VAR 0 1
 500: PPUSH
 501: CALL_OW 25
 505: ST_TO_ADDR
// result := unit ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// end ;
 516: LD_VAR 0 3
 520: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 521: LD_INT 0
 523: PPUSH
// uc_side := side ;
 524: LD_ADDR_OWVAR 20
 528: PUSH
 529: LD_VAR 0 1
 533: ST_TO_ADDR
// uc_nation := nation ;
 534: LD_ADDR_OWVAR 21
 538: PUSH
 539: LD_VAR 0 2
 543: ST_TO_ADDR
// vc_chassis := chassis ;
 544: LD_ADDR_OWVAR 37
 548: PUSH
 549: LD_VAR 0 3
 553: ST_TO_ADDR
// vc_engine := engine ;
 554: LD_ADDR_OWVAR 39
 558: PUSH
 559: LD_VAR 0 4
 563: ST_TO_ADDR
// vc_control := control ;
 564: LD_ADDR_OWVAR 38
 568: PUSH
 569: LD_VAR 0 5
 573: ST_TO_ADDR
// vc_weapon := weapon ;
 574: LD_ADDR_OWVAR 40
 578: PUSH
 579: LD_VAR 0 6
 583: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 584: LD_ADDR_OWVAR 41
 588: PUSH
 589: LD_VAR 0 7
 593: ST_TO_ADDR
// result := CreateVehicle ;
 594: LD_ADDR_VAR 0 8
 598: PUSH
 599: CALL_OW 45
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 8
 608: RET
// export function SayX ( units , ident ) ; var i ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
// result := false ;
 613: LD_ADDR_VAR 0 3
 617: PUSH
 618: LD_INT 0
 620: ST_TO_ADDR
// if not units then
 621: LD_VAR 0 1
 625: NOT
 626: IFFALSE 630
// exit ;
 628: GO 684
// for i in units do
 630: LD_ADDR_VAR 0 4
 634: PUSH
 635: LD_VAR 0 1
 639: PUSH
 640: FOR_IN
 641: IFFALSE 682
// if IsOk ( i ) then
 643: LD_VAR 0 4
 647: PPUSH
 648: CALL_OW 302
 652: IFFALSE 680
// begin Say ( i , ident ) ;
 654: LD_VAR 0 4
 658: PPUSH
 659: LD_VAR 0 2
 663: PPUSH
 664: CALL_OW 88
// result := i ;
 668: LD_ADDR_VAR 0 3
 672: PUSH
 673: LD_VAR 0 4
 677: ST_TO_ADDR
// break ;
 678: GO 682
// end ;
 680: GO 640
 682: POP
 683: POP
// end ;
 684: LD_VAR 0 3
 688: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 689: LD_INT 0
 691: PPUSH
 692: PPUSH
 693: PPUSH
 694: PPUSH
// for i = 1 to count do
 695: LD_ADDR_VAR 0 8
 699: PUSH
 700: DOUBLE
 701: LD_INT 1
 703: DEC
 704: ST_TO_ADDR
 705: LD_VAR 0 6
 709: PUSH
 710: FOR_TO
 711: IFFALSE 792
// begin uc_side = side ;
 713: LD_ADDR_OWVAR 20
 717: PUSH
 718: LD_VAR 0 1
 722: ST_TO_ADDR
// uc_nation = nation ;
 723: LD_ADDR_OWVAR 21
 727: PUSH
 728: LD_VAR 0 2
 732: ST_TO_ADDR
// hc_gallery =  ;
 733: LD_ADDR_OWVAR 33
 737: PUSH
 738: LD_STRING 
 740: ST_TO_ADDR
// hc_name =  ;
 741: LD_ADDR_OWVAR 26
 745: PUSH
 746: LD_STRING 
 748: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 749: LD_INT 0
 751: PPUSH
 752: LD_VAR 0 5
 756: PPUSH
 757: LD_VAR 0 4
 761: PPUSH
 762: CALL_OW 380
// un = CreateHuman ;
 766: LD_ADDR_VAR 0 10
 770: PUSH
 771: CALL_OW 44
 775: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 776: LD_VAR 0 10
 780: PPUSH
 781: LD_VAR 0 3
 785: PPUSH
 786: CALL_OW 52
// end ;
 790: GO 710
 792: POP
 793: POP
// end ;
 794: LD_VAR 0 7
 798: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 799: LD_INT 0
 801: PPUSH
 802: PPUSH
 803: PPUSH
// uc_side := GetSide ( b ) ;
 804: LD_ADDR_OWVAR 20
 808: PUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: CALL_OW 255
 818: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 819: LD_ADDR_OWVAR 21
 823: PUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 248
 833: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 834: LD_INT 0
 836: PPUSH
 837: LD_INT 1
 839: PPUSH
 840: LD_VAR 0 1
 844: PPUSH
 845: CALL_OW 380
// un = CreateHuman ;
 849: LD_ADDR_VAR 0 4
 853: PUSH
 854: CALL_OW 44
 858: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 859: LD_ADDR_VAR 0 5
 863: PUSH
 864: LD_VAR 0 2
 868: PPUSH
 869: CALL_OW 254
 873: PUSH
 874: LD_INT 3
 876: MINUS
 877: ST_TO_ADDR
// if dir < 0 then
 878: LD_VAR 0 5
 882: PUSH
 883: LD_INT 0
 885: LESS
 886: IFFALSE 902
// dir := 6 + dir ;
 888: LD_ADDR_VAR 0 5
 892: PUSH
 893: LD_INT 6
 895: PUSH
 896: LD_VAR 0 5
 900: PLUS
 901: ST_TO_ADDR
// SetDir ( un , dir ) ;
 902: LD_VAR 0 4
 906: PPUSH
 907: LD_VAR 0 5
 911: PPUSH
 912: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 916: LD_VAR 0 4
 920: PPUSH
 921: LD_VAR 0 2
 925: PPUSH
 926: CALL_OW 52
// end ;
 930: LD_VAR 0 3
 934: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 935: LD_INT 0
 937: PPUSH
 938: PPUSH
 939: PPUSH
// result := false ;
 940: LD_ADDR_VAR 0 2
 944: PUSH
 945: LD_INT 0
 947: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 948: LD_ADDR_VAR 0 3
 952: PUSH
 953: LD_INT 22
 955: PUSH
 956: LD_INT 1
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: PUSH
 963: LD_INT 34
 965: PUSH
 966: LD_INT 2
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL_OW 69
 981: ST_TO_ADDR
// for i in filter do
 982: LD_ADDR_VAR 0 4
 986: PUSH
 987: LD_VAR 0 3
 991: PUSH
 992: FOR_IN
 993: IFFALSE 1024
// if IsDrivenBy ( i ) = unit then
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 311
1004: PUSH
1005: LD_VAR 0 1
1009: EQUAL
1010: IFFALSE 1022
// begin result := true ;
1012: LD_ADDR_VAR 0 2
1016: PUSH
1017: LD_INT 1
1019: ST_TO_ADDR
// break ;
1020: GO 1024
// end ;
1022: GO 992
1024: POP
1025: POP
// end ;
1026: LD_VAR 0 2
1030: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1031: LD_INT 0
1033: PPUSH
1034: PPUSH
// result := false ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_INT 0
1042: ST_TO_ADDR
// if not blist then
1043: LD_VAR 0 1
1047: NOT
1048: IFFALSE 1052
// exit ;
1050: GO 1096
// for i in blist do
1052: LD_ADDR_VAR 0 3
1056: PUSH
1057: LD_VAR 0 1
1061: PUSH
1062: FOR_IN
1063: IFFALSE 1094
// if UnitsInside ( i ) < 6 then
1065: LD_VAR 0 3
1069: PPUSH
1070: CALL_OW 313
1074: PUSH
1075: LD_INT 6
1077: LESS
1078: IFFALSE 1092
// begin result := i ;
1080: LD_ADDR_VAR 0 2
1084: PUSH
1085: LD_VAR 0 3
1089: ST_TO_ADDR
// break ;
1090: GO 1094
// end ;
1092: GO 1062
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function Count ( timer , mode ) ; begin
1101: LD_INT 0
1103: PPUSH
// if not timer then
1104: LD_VAR 0 1
1108: NOT
1109: IFFALSE 1113
// exit ;
1111: GO 1164
// if mode in [ asc , up , + ] then
1113: LD_VAR 0 2
1117: PUSH
1118: LD_STRING asc
1120: PUSH
1121: LD_STRING up
1123: PUSH
1124: LD_STRING +
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: IN
1132: IFFALSE 1150
// result := timer + 0 0$01 else
1134: LD_ADDR_VAR 0 3
1138: PUSH
1139: LD_VAR 0 1
1143: PUSH
1144: LD_INT 35
1146: PLUS
1147: ST_TO_ADDR
1148: GO 1164
// result := timer - 0 0$01 ;
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: MINUS
1163: ST_TO_ADDR
// end ; end_of_file
1164: LD_VAR 0 3
1168: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1169: LD_INT 0
1171: PPUSH
1172: PPUSH
1173: PPUSH
1174: PPUSH
1175: PPUSH
1176: PPUSH
1177: PPUSH
1178: PPUSH
// uc_side := 4 ;
1179: LD_ADDR_OWVAR 20
1183: PUSH
1184: LD_INT 4
1186: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1187: LD_ADDR_EXP 43
1191: PUSH
1192: LD_STRING Powell
1194: PPUSH
1195: LD_INT 0
1197: PPUSH
1198: CALL 458 0 2
1202: ST_TO_ADDR
// uc_side := 1 ;
1203: LD_ADDR_OWVAR 20
1207: PUSH
1208: LD_INT 1
1210: ST_TO_ADDR
// uc_nation := 1 ;
1211: LD_ADDR_OWVAR 21
1215: PUSH
1216: LD_INT 1
1218: ST_TO_ADDR
// if debug then
1219: LD_EXP 1
1223: IFFALSE 1353
// begin for i = 1 to 4 do
1225: LD_ADDR_VAR 0 2
1229: PUSH
1230: DOUBLE
1231: LD_INT 1
1233: DEC
1234: ST_TO_ADDR
1235: LD_INT 4
1237: PUSH
1238: FOR_TO
1239: IFFALSE 1290
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1241: LD_INT 0
1243: PPUSH
1244: LD_INT 1
1246: PPUSH
1247: LD_INT 2
1249: PPUSH
1250: CALL_OW 12
1254: PPUSH
1255: LD_INT 3
1257: PPUSH
1258: CALL_OW 380
// un := CreateHuman ;
1262: LD_ADDR_VAR 0 3
1266: PUSH
1267: CALL_OW 44
1271: ST_TO_ADDR
// others := others ^ un ;
1272: LD_ADDR_VAR 0 5
1276: PUSH
1277: LD_VAR 0 5
1281: PUSH
1282: LD_VAR 0 3
1286: ADD
1287: ST_TO_ADDR
// end ;
1288: GO 1238
1290: POP
1291: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1292: LD_ADDR_VAR 0 6
1296: PUSH
1297: LD_INT 21
1299: PUSH
1300: LD_INT 1
1302: PUSH
1303: LD_INT 1
1305: PUSH
1306: LD_INT 51
1308: PUSH
1309: LD_INT 90
1311: PUSH
1312: LD_INT 504
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 21
1325: PUSH
1326: LD_INT 1
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: LD_INT 51
1334: PUSH
1335: LD_INT 80
1337: PUSH
1338: LD_INT 750
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1353: LD_ADDR_EXP 34
1357: PUSH
1358: LD_STRING JMM
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: CALL 458 0 2
1371: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1372: LD_ADDR_EXP 35
1376: PUSH
1377: LD_STRING Bobby
1379: PPUSH
1380: LD_EXP 1
1384: NOT
1385: PPUSH
1386: CALL 458 0 2
1390: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1391: LD_ADDR_EXP 36
1395: PUSH
1396: LD_STRING Cyrus
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 458 0 2
1409: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1410: LD_ADDR_EXP 37
1414: PUSH
1415: LD_STRING Lisa
1417: PPUSH
1418: LD_EXP 1
1422: NOT
1423: PPUSH
1424: CALL 458 0 2
1428: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1429: LD_ADDR_EXP 38
1433: PUSH
1434: LD_STRING Khatam
1436: PPUSH
1437: LD_EXP 1
1441: NOT
1442: PPUSH
1443: CALL 458 0 2
1447: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1448: LD_ADDR_EXP 39
1452: PUSH
1453: LD_STRING Brian
1455: PPUSH
1456: LD_EXP 1
1460: NOT
1461: PPUSH
1462: CALL 458 0 2
1466: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1467: LD_ADDR_EXP 40
1471: PUSH
1472: LD_STRING Jerry
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 458 0 2
1485: ST_TO_ADDR
// if Bobby then
1486: LD_EXP 35
1490: IFFALSE 1521
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1492: LD_ADDR_VAR 0 4
1496: PUSH
1497: LD_VAR 0 4
1501: PPUSH
1502: LD_VAR 0 4
1506: PUSH
1507: LD_INT 1
1509: PLUS
1510: PPUSH
1511: LD_EXP 35
1515: PPUSH
1516: CALL_OW 2
1520: ST_TO_ADDR
// if Cyrus then
1521: LD_EXP 36
1525: IFFALSE 1556
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1527: LD_ADDR_VAR 0 4
1531: PUSH
1532: LD_VAR 0 4
1536: PPUSH
1537: LD_VAR 0 4
1541: PUSH
1542: LD_INT 1
1544: PLUS
1545: PPUSH
1546: LD_EXP 36
1550: PPUSH
1551: CALL_OW 2
1555: ST_TO_ADDR
// if Lisa then
1556: LD_EXP 37
1560: IFFALSE 1591
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1562: LD_ADDR_VAR 0 4
1566: PUSH
1567: LD_VAR 0 4
1571: PPUSH
1572: LD_VAR 0 4
1576: PUSH
1577: LD_INT 1
1579: PLUS
1580: PPUSH
1581: LD_EXP 37
1585: PPUSH
1586: CALL_OW 2
1590: ST_TO_ADDR
// if Khatam then
1591: LD_EXP 38
1595: IFFALSE 1626
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1597: LD_ADDR_VAR 0 4
1601: PUSH
1602: LD_VAR 0 4
1606: PPUSH
1607: LD_VAR 0 4
1611: PUSH
1612: LD_INT 1
1614: PLUS
1615: PPUSH
1616: LD_EXP 38
1620: PPUSH
1621: CALL_OW 2
1625: ST_TO_ADDR
// if Brian then
1626: LD_EXP 39
1630: IFFALSE 1661
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1632: LD_ADDR_VAR 0 4
1636: PUSH
1637: LD_VAR 0 4
1641: PPUSH
1642: LD_VAR 0 4
1646: PUSH
1647: LD_INT 1
1649: PLUS
1650: PPUSH
1651: LD_EXP 39
1655: PPUSH
1656: CALL_OW 2
1660: ST_TO_ADDR
// if Jerry then
1661: LD_EXP 40
1665: IFFALSE 1696
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1667: LD_ADDR_VAR 0 4
1671: PUSH
1672: LD_VAR 0 4
1676: PPUSH
1677: LD_VAR 0 4
1681: PUSH
1682: LD_INT 1
1684: PLUS
1685: PPUSH
1686: LD_EXP 40
1690: PPUSH
1691: CALL_OW 2
1695: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1696: LD_STRING 02_other_survivors
1698: PPUSH
1699: CALL_OW 28
1703: IFFALSE 1718
// others := CreateCharacterSet ( 02_other_survivors ) ;
1705: LD_ADDR_VAR 0 5
1709: PUSH
1710: LD_STRING 02_other_survivors
1712: PPUSH
1713: CALL_OW 31
1717: ST_TO_ADDR
// if others then
1718: LD_VAR 0 5
1722: IFFALSE 1747
// begin tmp := tmp ^ others ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_VAR 0 4
1733: PUSH
1734: LD_VAR 0 5
1738: ADD
1739: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 40
// end ; jmm_units := tmp ;
1747: LD_ADDR_EXP 4
1751: PUSH
1752: LD_VAR 0 4
1756: ST_TO_ADDR
// if not vehicles then
1757: LD_VAR 0 6
1761: NOT
1762: IFFALSE 1780
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1764: LD_ADDR_VAR 0 6
1768: PUSH
1769: LD_STRING 02_tanks_1
1771: PPUSH
1772: LD_INT 0
1774: PPUSH
1775: CALL_OW 30
1779: ST_TO_ADDR
// if vehicles then
1780: LD_VAR 0 6
1784: IFFALSE 1978
// begin got_mech := false ;
1786: LD_ADDR_VAR 0 7
1790: PUSH
1791: LD_INT 0
1793: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1794: LD_VAR 0 4
1798: PPUSH
1799: LD_INT 25
1801: PUSH
1802: LD_INT 3
1804: PUSH
1805: EMPTY
1806: LIST
1807: LIST
1808: PPUSH
1809: CALL_OW 72
1813: IFFALSE 1823
// got_mech := true ;
1815: LD_ADDR_VAR 0 7
1819: PUSH
1820: LD_INT 1
1822: ST_TO_ADDR
// for i = 1 to vehicles do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_VAR 0 6
1837: PUSH
1838: FOR_TO
1839: IFFALSE 1976
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1841: LD_ADDR_VAR 0 3
1845: PUSH
1846: LD_INT 1
1848: PPUSH
1849: LD_INT 3
1851: PPUSH
1852: LD_VAR 0 6
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_INT 1
1865: ARRAY
1866: PPUSH
1867: LD_VAR 0 6
1871: PUSH
1872: LD_VAR 0 2
1876: ARRAY
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PPUSH
1882: LD_VAR 0 6
1886: PUSH
1887: LD_VAR 0 2
1891: ARRAY
1892: PUSH
1893: LD_INT 3
1895: ARRAY
1896: PPUSH
1897: LD_VAR 0 6
1901: PUSH
1902: LD_VAR 0 2
1906: ARRAY
1907: PUSH
1908: LD_INT 4
1910: ARRAY
1911: PPUSH
1912: LD_INT 40
1914: PPUSH
1915: CALL 521 0 7
1919: ST_TO_ADDR
// if not got_mech then
1920: LD_VAR 0 7
1924: NOT
1925: IFFALSE 1951
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1927: LD_VAR 0 3
1931: PPUSH
1932: LD_VAR 0 6
1936: PUSH
1937: LD_VAR 0 2
1941: ARRAY
1942: PUSH
1943: LD_INT 6
1945: ARRAY
1946: PPUSH
1947: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1951: LD_ADDR_VAR 0 4
1955: PUSH
1956: LD_VAR 0 4
1960: PPUSH
1961: LD_INT 1
1963: PPUSH
1964: LD_VAR 0 3
1968: PPUSH
1969: CALL_OW 2
1973: ST_TO_ADDR
// end ;
1974: GO 1838
1976: POP
1977: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1978: LD_EXP 34
1982: PPUSH
1983: LD_INT 194
1985: PPUSH
1986: LD_INT 119
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 48
// if tmp then
1996: LD_VAR 0 4
2000: IFFALSE 2125
// begin for i in tmp do
2002: LD_ADDR_VAR 0 2
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: FOR_IN
2013: IFFALSE 2123
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2015: LD_ADDR_VAR 0 8
2019: PUSH
2020: LD_INT 22
2022: PUSH
2023: LD_INT 1
2025: PUSH
2026: EMPTY
2027: LIST
2028: LIST
2029: PUSH
2030: LD_INT 21
2032: PUSH
2033: LD_INT 2
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: PUSH
2040: LD_INT 58
2042: PUSH
2043: EMPTY
2044: LIST
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PPUSH
2051: CALL_OW 69
2055: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2056: LD_VAR 0 2
2060: PPUSH
2061: CALL_OW 247
2065: PUSH
2066: LD_INT 1
2068: EQUAL
2069: PUSH
2070: LD_VAR 0 8
2074: AND
2075: IFFALSE 2097
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2077: LD_VAR 0 2
2081: PPUSH
2082: LD_VAR 0 8
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PPUSH
2091: CALL_OW 52
2095: GO 2112
// PlaceUnitArea ( i , startArea , false ) ;
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_INT 1
2104: PPUSH
2105: LD_INT 0
2107: PPUSH
2108: CALL_OW 49
// ComHold ( i ) ;
2112: LD_VAR 0 2
2116: PPUSH
2117: CALL_OW 140
// end ;
2121: GO 2012
2123: POP
2124: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2125: LD_ADDR_EXP 7
2129: PUSH
2130: LD_STRING 02_mikhailStatus_1
2132: PPUSH
2133: LD_INT 0
2135: PPUSH
2136: CALL_OW 30
2140: ST_TO_ADDR
// if not bierezov_exist and not debug then
2141: LD_EXP 7
2145: NOT
2146: PUSH
2147: LD_EXP 1
2151: NOT
2152: AND
2153: IFFALSE 2157
// exit ;
2155: GO 2188
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2157: LD_ADDR_EXP 42
2161: PUSH
2162: LD_STRING Mikhail
2164: PPUSH
2165: LD_INT 0
2167: PPUSH
2168: CALL 458 0 2
2172: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2173: LD_EXP 42
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: LD_INT 0
2183: PPUSH
2184: CALL_OW 49
// end ;
2188: LD_VAR 0 1
2192: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2193: LD_INT 0
2195: PPUSH
2196: PPUSH
2197: PPUSH
2198: PPUSH
// uc_side := 4 ;
2199: LD_ADDR_OWVAR 20
2203: PUSH
2204: LD_INT 4
2206: ST_TO_ADDR
// uc_nation := 1 ;
2207: LD_ADDR_OWVAR 21
2211: PUSH
2212: LD_INT 1
2214: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2215: LD_ADDR_EXP 41
2219: PUSH
2220: LD_STRING Cornell
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL 458 0 2
2230: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2231: LD_ADDR_EXP 6
2235: PUSH
2236: LD_INT 8
2238: PUSH
2239: LD_EXP 4
2243: MINUS
2244: ST_TO_ADDR
// tmp := [ ] ;
2245: LD_ADDR_VAR 0 2
2249: PUSH
2250: EMPTY
2251: ST_TO_ADDR
// if cornel_units < 3 then
2252: LD_EXP 6
2256: PUSH
2257: LD_INT 3
2259: LESS
2260: IFFALSE 2270
// cornel_units := 3 ;
2262: LD_ADDR_EXP 6
2266: PUSH
2267: LD_INT 3
2269: ST_TO_ADDR
// for i = 1 to cornel_units do
2270: LD_ADDR_VAR 0 4
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_EXP 6
2284: PUSH
2285: FOR_TO
2286: IFFALSE 2384
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2288: LD_INT 0
2290: PPUSH
2291: LD_INT 1
2293: PUSH
2294: LD_INT 1
2296: PUSH
2297: LD_INT 1
2299: PUSH
2300: LD_INT 2
2302: PUSH
2303: LD_INT 4
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: LIST
2310: LIST
2311: LIST
2312: PUSH
2313: LD_VAR 0 4
2317: PUSH
2318: LD_INT 5
2320: MOD
2321: PUSH
2322: LD_INT 1
2324: PLUS
2325: ARRAY
2326: PPUSH
2327: LD_INT 2
2329: PPUSH
2330: CALL_OW 380
// un := CreateHuman ;
2334: LD_ADDR_VAR 0 3
2338: PUSH
2339: CALL_OW 44
2343: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2344: LD_ADDR_VAR 0 2
2348: PUSH
2349: LD_VAR 0 2
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: LD_VAR 0 3
2361: PPUSH
2362: CALL_OW 2
2366: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2367: LD_VAR 0 3
2371: PPUSH
2372: LD_INT 2
2374: PPUSH
2375: LD_INT 0
2377: PPUSH
2378: CALL_OW 49
// end ;
2382: GO 2285
2384: POP
2385: POP
// cornel_units := tmp ;
2386: LD_ADDR_EXP 6
2390: PUSH
2391: LD_VAR 0 2
2395: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2396: LD_EXP 41
2400: PPUSH
2401: LD_INT 191
2403: PPUSH
2404: LD_INT 106
2406: PPUSH
2407: LD_INT 0
2409: PPUSH
2410: CALL_OW 48
// end ;
2414: LD_VAR 0 1
2418: RET
// export function PrepareWesternBase ; var i ; begin
2419: LD_INT 0
2421: PPUSH
2422: PPUSH
// uc_side := 8 ;
2423: LD_ADDR_OWVAR 20
2427: PUSH
2428: LD_INT 8
2430: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2431: LD_ADDR_EXP 44
2435: PUSH
2436: LD_STRING Lynch
2438: PPUSH
2439: LD_INT 0
2441: PPUSH
2442: CALL 458 0 2
2446: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2447: LD_ADDR_EXP 45
2451: PUSH
2452: LD_STRING Walker
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL 458 0 2
2462: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2463: LD_ADDR_EXP 46
2467: PUSH
2468: LD_STRING Turner
2470: PPUSH
2471: LD_INT 0
2473: PPUSH
2474: CALL 458 0 2
2478: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2479: LD_ADDR_EXP 47
2483: PUSH
2484: LD_STRING Jillian
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: CALL 458 0 2
2494: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2495: LD_ADDR_VAR 0 2
2499: PUSH
2500: LD_EXP 44
2504: PUSH
2505: LD_EXP 45
2509: PUSH
2510: LD_EXP 46
2514: PUSH
2515: LD_EXP 47
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: LIST
2525: PUSH
2526: FOR_IN
2527: IFFALSE 2555
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2529: LD_VAR 0 2
2533: PPUSH
2534: LD_INT 3
2536: PPUSH
2537: LD_INT 0
2539: PPUSH
2540: CALL_OW 49
// ComHold ( i ) ;
2544: LD_VAR 0 2
2548: PPUSH
2549: CALL_OW 140
// end ;
2553: GO 2526
2555: POP
2556: POP
// end ;
2557: LD_VAR 0 1
2561: RET
// export function SelectGroup ; var units , selected , i ; begin
2562: LD_INT 0
2564: PPUSH
2565: PPUSH
2566: PPUSH
2567: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2568: LD_ADDR_VAR 0 2
2572: PUSH
2573: LD_EXP 34
2577: PUSH
2578: LD_INT -3
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: LD_EXP 4
2589: ADD
2590: PUSH
2591: LD_INT -2
2593: PUSH
2594: LD_INT -4
2596: PUSH
2597: LD_EXP 41
2601: PUSH
2602: LD_EXP 42
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: LIST
2611: LIST
2612: ADD
2613: PUSH
2614: LD_INT -3
2616: PUSH
2617: EMPTY
2618: LIST
2619: ADD
2620: PUSH
2621: LD_EXP 6
2625: ADD
2626: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2627: LD_ADDR_VAR 0 3
2631: PUSH
2632: LD_EXP 34
2636: PUSH
2637: LD_STRING Select five characters to go with you
2639: PPUSH
2640: LD_INT 4
2642: PPUSH
2643: LD_INT 4
2645: PPUSH
2646: LD_VAR 0 2
2650: PPUSH
2651: EMPTY
2652: PPUSH
2653: CALL_OW 42
2657: ADD
2658: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2659: LD_ADDR_EXP 6
2663: PUSH
2664: LD_EXP 4
2668: PUSH
2669: LD_EXP 6
2673: UNION
2674: PUSH
2675: LD_VAR 0 3
2679: DIFF
2680: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2681: LD_ADDR_VAR 0 4
2685: PUSH
2686: LD_EXP 6
2690: PUSH
2691: LD_EXP 42
2695: ADD
2696: PUSH
2697: FOR_IN
2698: IFFALSE 2729
// if GetSide ( i ) = 1 then
2700: LD_VAR 0 4
2704: PPUSH
2705: CALL_OW 255
2709: PUSH
2710: LD_INT 1
2712: EQUAL
2713: IFFALSE 2727
// SetSide ( i , 4 ) ;
2715: LD_VAR 0 4
2719: PPUSH
2720: LD_INT 4
2722: PPUSH
2723: CALL_OW 235
2727: GO 2697
2729: POP
2730: POP
// for i in selected do
2731: LD_ADDR_VAR 0 4
2735: PUSH
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 4 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 4
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 1 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 1
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// jmm_units := jmm_units diff cornel_units ;
2775: LD_ADDR_EXP 4
2779: PUSH
2780: LD_EXP 4
2784: PUSH
2785: LD_EXP 6
2789: DIFF
2790: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2791: LD_EXP 35
2795: PPUSH
2796: CALL_OW 255
2800: PUSH
2801: LD_INT 4
2803: EQUAL
2804: IFFALSE 2813
// DeleteCharacters ( Bobby ) ;
2806: LD_STRING Bobby
2808: PPUSH
2809: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2813: LD_EXP 36
2817: PPUSH
2818: CALL_OW 255
2822: PUSH
2823: LD_INT 4
2825: EQUAL
2826: IFFALSE 2835
// DeleteCharacters ( Cyrus ) ;
2828: LD_STRING Cyrus
2830: PPUSH
2831: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2857
// DeleteCharacters ( Lisa ) ;
2850: LD_STRING Lisa
2852: PPUSH
2853: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2857: LD_EXP 38
2861: PPUSH
2862: CALL_OW 255
2866: PUSH
2867: LD_INT 4
2869: EQUAL
2870: IFFALSE 2879
// DeleteCharacters ( Khatam ) ;
2872: LD_STRING Khatam
2874: PPUSH
2875: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2879: LD_EXP 39
2883: PPUSH
2884: CALL_OW 255
2888: PUSH
2889: LD_INT 4
2891: EQUAL
2892: IFFALSE 2901
// DeleteCharacters ( Brian ) ;
2894: LD_STRING Brian
2896: PPUSH
2897: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2901: LD_EXP 40
2905: PPUSH
2906: CALL_OW 255
2910: PUSH
2911: LD_INT 4
2913: EQUAL
2914: IFFALSE 2923
// DeleteCharacters ( Jerry ) ;
2916: LD_STRING Jerry
2918: PPUSH
2919: CALL_OW 40
// end ; end_of_file
2923: LD_VAR 0 1
2927: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2928: LD_INT 0
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
// ru_alert := false ;
2943: LD_ADDR_EXP 57
2947: PUSH
2948: LD_INT 0
2950: ST_TO_ADDR
// ru_produce_list := [ ] ;
2951: LD_ADDR_EXP 54
2955: PUSH
2956: EMPTY
2957: ST_TO_ADDR
// if Difficulty > 1 then
2958: LD_OWVAR 67
2962: PUSH
2963: LD_INT 1
2965: GREATER
2966: IFFALSE 3054
// begin uc_side := 3 ;
2968: LD_ADDR_OWVAR 20
2972: PUSH
2973: LD_INT 3
2975: ST_TO_ADDR
// uc_nation := 3 ;
2976: LD_ADDR_OWVAR 21
2980: PUSH
2981: LD_INT 3
2983: ST_TO_ADDR
// bc_type := b_breastwork ;
2984: LD_ADDR_OWVAR 42
2988: PUSH
2989: LD_INT 31
2991: ST_TO_ADDR
// bc_level := Difficulty ;
2992: LD_ADDR_OWVAR 43
2996: PUSH
2997: LD_OWVAR 67
3001: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3002: LD_INT 22
3004: PPUSH
3005: LD_INT 14
3007: PPUSH
3008: LD_INT 0
3010: PPUSH
3011: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3015: LD_INT 48
3017: PPUSH
3018: LD_INT 46
3020: PPUSH
3021: LD_INT 0
3023: PPUSH
3024: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3028: LD_INT 86
3030: PPUSH
3031: LD_INT 65
3033: PPUSH
3034: LD_INT 5
3036: PPUSH
3037: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3041: LD_INT 165
3043: PPUSH
3044: LD_INT 73
3046: PPUSH
3047: LD_INT 5
3049: PPUSH
3050: CALL_OW 47
// end ; if Difficulty = 3 then
3054: LD_OWVAR 67
3058: PUSH
3059: LD_INT 3
3061: EQUAL
3062: IFFALSE 3077
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3064: LD_INT 51
3066: PPUSH
3067: LD_INT 3
3069: PPUSH
3070: LD_INT 2
3072: PPUSH
3073: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3077: LD_ADDR_VAR 0 7
3081: PUSH
3082: LD_INT 22
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PUSH
3092: LD_INT 2
3094: PUSH
3095: LD_INT 30
3097: PUSH
3098: LD_INT 31
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PUSH
3105: LD_INT 30
3107: PUSH
3108: LD_INT 32
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: PPUSH
3124: CALL_OW 69
3128: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3129: LD_ADDR_VAR 0 8
3133: PUSH
3134: LD_INT 22
3136: PUSH
3137: LD_INT 3
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: PUSH
3144: LD_INT 30
3146: PUSH
3147: LD_INT 4
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: PPUSH
3158: CALL_OW 69
3162: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3163: LD_ADDR_VAR 0 10
3167: PUSH
3168: LD_INT 22
3170: PUSH
3171: LD_INT 3
3173: PUSH
3174: EMPTY
3175: LIST
3176: LIST
3177: PUSH
3178: LD_INT 30
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PPUSH
3192: CALL_OW 69
3196: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3197: LD_ADDR_VAR 0 9
3201: PUSH
3202: LD_INT 22
3204: PUSH
3205: LD_INT 3
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 30
3214: PUSH
3215: LD_INT 6
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: PPUSH
3226: CALL_OW 69
3230: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: LD_INT 22
3238: PUSH
3239: LD_INT 3
3241: PUSH
3242: EMPTY
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 30
3248: PUSH
3249: LD_INT 1
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: PPUSH
3260: CALL_OW 69
3264: PUSH
3265: FOR_IN
3266: IFFALSE 3310
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3268: LD_VAR 0 2
3272: PPUSH
3273: CALL_OW 274
3277: PPUSH
3278: LD_INT 1
3280: PPUSH
3281: LD_INT 5000
3283: PPUSH
3284: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3288: LD_VAR 0 2
3292: PPUSH
3293: CALL_OW 274
3297: PPUSH
3298: LD_INT 2
3300: PPUSH
3301: LD_INT 3000
3303: PPUSH
3304: CALL_OW 277
// end ;
3308: GO 3265
3310: POP
3311: POP
// uc_side := 3 ;
3312: LD_ADDR_OWVAR 20
3316: PUSH
3317: LD_INT 3
3319: ST_TO_ADDR
// uc_nation := 3 ;
3320: LD_ADDR_OWVAR 21
3324: PUSH
3325: LD_INT 3
3327: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3328: LD_ADDR_VAR 0 11
3332: PUSH
3333: LD_INT 2
3335: PUSH
3336: LD_INT 3
3338: PUSH
3339: LD_INT 4
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: LIST
3346: PUSH
3347: LD_OWVAR 67
3351: ARRAY
3352: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3353: LD_ADDR_EXP 49
3357: PUSH
3358: LD_STRING Pokryshkin
3360: PPUSH
3361: LD_INT 0
3363: PPUSH
3364: CALL 458 0 2
3368: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3369: LD_EXP 49
3373: PPUSH
3374: LD_INT 63
3376: PPUSH
3377: LD_INT 21
3379: PPUSH
3380: LD_INT 0
3382: PPUSH
3383: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3387: LD_EXP 49
3391: PPUSH
3392: CALL_OW 140
// InitHc ;
3396: CALL_OW 19
// for i in fac do
3400: LD_ADDR_VAR 0 2
3404: PUSH
3405: LD_VAR 0 10
3409: PUSH
3410: FOR_IN
3411: IFFALSE 3464
// begin for j = 1 to 6 do
3413: LD_ADDR_VAR 0 3
3417: PUSH
3418: DOUBLE
3419: LD_INT 1
3421: DEC
3422: ST_TO_ADDR
3423: LD_INT 6
3425: PUSH
3426: FOR_TO
3427: IFFALSE 3460
// begin PrepareHuman ( false , 3 , skill ) ;
3429: LD_INT 0
3431: PPUSH
3432: LD_INT 3
3434: PPUSH
3435: LD_VAR 0 11
3439: PPUSH
3440: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3444: CALL_OW 44
3448: PPUSH
3449: LD_VAR 0 2
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3426
3460: POP
3461: POP
// end ;
3462: GO 3410
3464: POP
3465: POP
// for i in lab do
3466: LD_ADDR_VAR 0 2
3470: PUSH
3471: LD_VAR 0 9
3475: PUSH
3476: FOR_IN
3477: IFFALSE 3510
// begin PrepareHuman ( false , 4 , skill ) ;
3479: LD_INT 0
3481: PPUSH
3482: LD_INT 4
3484: PPUSH
3485: LD_VAR 0 11
3489: PPUSH
3490: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3494: CALL_OW 44
3498: PPUSH
3499: LD_VAR 0 2
3503: PPUSH
3504: CALL_OW 52
// end ;
3508: GO 3476
3510: POP
3511: POP
// for i in tw do
3512: LD_ADDR_VAR 0 2
3516: PUSH
3517: LD_VAR 0 7
3521: PUSH
3522: FOR_IN
3523: IFFALSE 3572
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3525: LD_VAR 0 2
3529: PPUSH
3530: LD_INT 42
3532: PUSH
3533: LD_INT 43
3535: PUSH
3536: EMPTY
3537: LIST
3538: LIST
3539: PUSH
3540: LD_INT 1
3542: PPUSH
3543: LD_INT 2
3545: PPUSH
3546: CALL_OW 12
3550: ARRAY
3551: PPUSH
3552: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3556: LD_VAR 0 11
3560: PPUSH
3561: LD_VAR 0 2
3565: PPUSH
3566: CALL 799 0 2
// end ;
3570: GO 3522
3572: POP
3573: POP
// for i in bar do
3574: LD_ADDR_VAR 0 2
3578: PUSH
3579: LD_VAR 0 8
3583: PUSH
3584: FOR_IN
3585: IFFALSE 3618
// begin PrepareHuman ( false , 1 , skill ) ;
3587: LD_INT 0
3589: PPUSH
3590: LD_INT 1
3592: PPUSH
3593: LD_VAR 0 11
3597: PPUSH
3598: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3602: CALL_OW 44
3606: PPUSH
3607: LD_VAR 0 2
3611: PPUSH
3612: CALL_OW 52
// end ;
3616: GO 3584
3618: POP
3619: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3620: LD_ADDR_VAR 0 13
3624: PUSH
3625: LD_INT 100
3627: PUSH
3628: LD_INT 9
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 135
3637: PUSH
3638: LD_INT 60
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 41
3647: PUSH
3648: LD_INT 6
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PUSH
3655: LD_INT 22
3657: PUSH
3658: LD_INT 9
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: PUSH
3665: LD_INT 84
3667: PUSH
3668: LD_INT 14
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: LIST
3679: LIST
3680: LIST
3681: ST_TO_ADDR
// vehicles := [ ] ;
3682: LD_ADDR_VAR 0 12
3686: PUSH
3687: EMPTY
3688: ST_TO_ADDR
// for i in spot_xy do
3689: LD_ADDR_VAR 0 2
3693: PUSH
3694: LD_VAR 0 13
3698: PUSH
3699: FOR_IN
3700: IFFALSE 3858
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3702: LD_ADDR_VAR 0 6
3706: PUSH
3707: LD_INT 3
3709: PPUSH
3710: LD_INT 3
3712: PPUSH
3713: LD_INT 22
3715: PPUSH
3716: LD_INT 1
3718: PPUSH
3719: LD_INT 1
3721: PPUSH
3722: LD_INT 42
3724: PUSH
3725: LD_INT 43
3727: PUSH
3728: LD_INT 44
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: LIST
3735: PUSH
3736: LD_INT 1
3738: PPUSH
3739: LD_INT 3
3741: PPUSH
3742: CALL_OW 12
3746: ARRAY
3747: PPUSH
3748: LD_INT 100
3750: PPUSH
3751: CALL 521 0 7
3755: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3756: LD_ADDR_VAR 0 12
3760: PUSH
3761: LD_VAR 0 12
3765: PPUSH
3766: LD_VAR 0 12
3770: PUSH
3771: LD_INT 1
3773: PLUS
3774: PPUSH
3775: LD_VAR 0 6
3779: PPUSH
3780: CALL_OW 2
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 6
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3797: LD_VAR 0 6
3801: PPUSH
3802: LD_VAR 0 2
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: PPUSH
3811: LD_VAR 0 2
3815: PUSH
3816: LD_INT 2
3818: ARRAY
3819: PPUSH
3820: LD_INT 0
3822: PPUSH
3823: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3827: LD_INT 0
3829: PPUSH
3830: LD_INT 3
3832: PPUSH
3833: LD_VAR 0 11
3837: PPUSH
3838: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3842: CALL_OW 44
3846: PPUSH
3847: LD_VAR 0 6
3851: PPUSH
3852: CALL_OW 52
// end ;
3856: GO 3699
3858: POP
3859: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3860: LD_ADDR_VAR 0 2
3864: PUSH
3865: DOUBLE
3866: LD_INT 1
3868: DEC
3869: ST_TO_ADDR
3870: LD_INT 5
3872: PUSH
3873: LD_INT 7
3875: PUSH
3876: LD_INT 8
3878: PUSH
3879: EMPTY
3880: LIST
3881: LIST
3882: LIST
3883: PUSH
3884: LD_OWVAR 67
3888: ARRAY
3889: PUSH
3890: FOR_TO
3891: IFFALSE 3951
// begin PrepareHuman ( false , 1 , skill ) ;
3893: LD_INT 0
3895: PPUSH
3896: LD_INT 1
3898: PPUSH
3899: LD_VAR 0 11
3903: PPUSH
3904: CALL_OW 380
// un := CreateHuman ;
3908: LD_ADDR_VAR 0 5
3912: PUSH
3913: CALL_OW 44
3917: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3918: LD_VAR 0 5
3922: PPUSH
3923: LD_INT 11
3925: PPUSH
3926: LD_INT 0
3928: PPUSH
3929: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3933: LD_ADDR_EXP 52
3937: PUSH
3938: LD_EXP 52
3942: PUSH
3943: LD_VAR 0 5
3947: ADD
3948: ST_TO_ADDR
// end ;
3949: GO 3890
3951: POP
3952: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3953: LD_ADDR_VAR 0 2
3957: PUSH
3958: DOUBLE
3959: LD_INT 1
3961: DEC
3962: ST_TO_ADDR
3963: LD_INT 2
3965: PUSH
3966: LD_INT 3
3968: PUSH
3969: LD_INT 4
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_OWVAR 67
3981: ARRAY
3982: PUSH
3983: FOR_TO
3984: IFFALSE 4044
// begin PrepareHuman ( false , 1 , skill ) ;
3986: LD_INT 0
3988: PPUSH
3989: LD_INT 1
3991: PPUSH
3992: LD_VAR 0 11
3996: PPUSH
3997: CALL_OW 380
// un := CreateHuman ;
4001: LD_ADDR_VAR 0 5
4005: PUSH
4006: CALL_OW 44
4010: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4011: LD_VAR 0 5
4015: PPUSH
4016: LD_INT 12
4018: PPUSH
4019: LD_INT 0
4021: PPUSH
4022: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4026: LD_ADDR_EXP 50
4030: PUSH
4031: LD_EXP 50
4035: PUSH
4036: LD_VAR 0 5
4040: ADD
4041: ST_TO_ADDR
// end ;
4042: GO 3983
4044: POP
4045: POP
// for i = 1 to 2 do
4046: LD_ADDR_VAR 0 2
4050: PUSH
4051: DOUBLE
4052: LD_INT 1
4054: DEC
4055: ST_TO_ADDR
4056: LD_INT 2
4058: PUSH
4059: FOR_TO
4060: IFFALSE 4126
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4062: LD_INT 1
4064: PPUSH
4065: LD_INT 1
4067: PPUSH
4068: LD_VAR 0 11
4072: PPUSH
4073: CALL_OW 380
// un := CreateHuman ;
4077: LD_ADDR_VAR 0 5
4081: PUSH
4082: CALL_OW 44
4086: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4087: LD_VAR 0 5
4091: PPUSH
4092: LD_INT 39
4094: PPUSH
4095: LD_INT 12
4097: PPUSH
4098: LD_INT 3
4100: PPUSH
4101: LD_INT 0
4103: PPUSH
4104: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4108: LD_ADDR_EXP 51
4112: PUSH
4113: LD_EXP 51
4117: PUSH
4118: LD_VAR 0 5
4122: ADD
4123: ST_TO_ADDR
// end ;
4124: GO 4059
4126: POP
4127: POP
// for i = 1 to 3 do
4128: LD_ADDR_VAR 0 2
4132: PUSH
4133: DOUBLE
4134: LD_INT 1
4136: DEC
4137: ST_TO_ADDR
4138: LD_INT 3
4140: PUSH
4141: FOR_TO
4142: IFFALSE 4208
// begin PrepareHuman ( false , 1 , skill ) ;
4144: LD_INT 0
4146: PPUSH
4147: LD_INT 1
4149: PPUSH
4150: LD_VAR 0 11
4154: PPUSH
4155: CALL_OW 380
// un := CreateHuman ;
4159: LD_ADDR_VAR 0 5
4163: PUSH
4164: CALL_OW 44
4168: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4169: LD_VAR 0 5
4173: PPUSH
4174: LD_INT 180
4176: PPUSH
4177: LD_INT 11
4179: PPUSH
4180: LD_INT 4
4182: PPUSH
4183: LD_INT 0
4185: PPUSH
4186: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4190: LD_ADDR_EXP 55
4194: PUSH
4195: LD_EXP 55
4199: PUSH
4200: LD_VAR 0 5
4204: ADD
4205: ST_TO_ADDR
// end ;
4206: GO 4141
4208: POP
4209: POP
// ru_vehicles := vehicles ;
4210: LD_ADDR_EXP 53
4214: PUSH
4215: LD_VAR 0 12
4219: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4220: LD_ADDR_EXP 56
4224: PUSH
4225: LD_INT 131
4227: PUSH
4228: LD_INT 121
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 113
4237: PUSH
4238: LD_INT 90
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PUSH
4245: LD_INT 93
4247: PUSH
4248: LD_INT 62
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: PUSH
4260: LD_INT 106
4262: PUSH
4263: LD_INT 54
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 120
4272: PUSH
4273: LD_INT 80
4275: PUSH
4276: EMPTY
4277: LIST
4278: LIST
4279: PUSH
4280: LD_INT 143
4282: PUSH
4283: LD_INT 120
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: LIST
4294: PUSH
4295: LD_INT 154
4297: PUSH
4298: LD_INT 116
4300: PUSH
4301: EMPTY
4302: LIST
4303: LIST
4304: PUSH
4305: LD_INT 140
4307: PUSH
4308: LD_INT 93
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 130
4317: PUSH
4318: LD_INT 58
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: PUSH
4330: LD_INT 105
4332: PUSH
4333: LD_INT 106
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 134
4342: PUSH
4343: LD_INT 98
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 159
4352: PUSH
4353: LD_INT 113
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: LIST
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4371: LD_ADDR_VAR 0 2
4375: PUSH
4376: DOUBLE
4377: LD_INT 1
4379: DEC
4380: ST_TO_ADDR
4381: LD_OWVAR 67
4385: PUSH
4386: LD_INT 1
4388: MINUS
4389: PUSH
4390: FOR_TO
4391: IFFALSE 4424
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4393: LD_ADDR_EXP 54
4397: PUSH
4398: LD_EXP 54
4402: PUSH
4403: LD_INT 22
4405: PUSH
4406: LD_INT 1
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: LD_INT 43
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: ADD
4421: ST_TO_ADDR
4422: GO 4390
4424: POP
4425: POP
// end ;
4426: LD_VAR 0 1
4430: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4431: LD_INT 22
4433: PUSH
4434: LD_INT 3
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 21
4443: PUSH
4444: LD_INT 2
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PPUSH
4455: CALL_OW 69
4459: IFFALSE 4553
4461: GO 4463
4463: DISABLE
4464: LD_INT 0
4466: PPUSH
4467: PPUSH
// begin enable ;
4468: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4469: LD_ADDR_VAR 0 2
4473: PUSH
4474: LD_INT 22
4476: PUSH
4477: LD_INT 3
4479: PUSH
4480: EMPTY
4481: LIST
4482: LIST
4483: PUSH
4484: LD_INT 21
4486: PUSH
4487: LD_INT 2
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PPUSH
4498: CALL_OW 69
4502: ST_TO_ADDR
// if filter then
4503: LD_VAR 0 2
4507: IFFALSE 4553
// for i in filter do
4509: LD_ADDR_VAR 0 1
4513: PUSH
4514: LD_VAR 0 2
4518: PUSH
4519: FOR_IN
4520: IFFALSE 4551
// if GetFuel ( i ) < 20 then
4522: LD_VAR 0 1
4526: PPUSH
4527: CALL_OW 261
4531: PUSH
4532: LD_INT 20
4534: LESS
4535: IFFALSE 4549
// SetFuel ( i , 20 ) ;
4537: LD_VAR 0 1
4541: PPUSH
4542: LD_INT 20
4544: PPUSH
4545: CALL_OW 240
4549: GO 4519
4551: POP
4552: POP
// end ;
4553: PPOPN 2
4555: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4556: LD_EXP 54
4560: IFFALSE 4779
4562: GO 4564
4564: DISABLE
4565: LD_INT 0
4567: PPUSH
4568: PPUSH
4569: PPUSH
// begin enable ;
4570: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4571: LD_ADDR_VAR 0 2
4575: PUSH
4576: LD_INT 22
4578: PUSH
4579: LD_INT 3
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 30
4588: PUSH
4589: LD_INT 3
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: PPUSH
4600: CALL_OW 69
4604: ST_TO_ADDR
// can_produce := [ ] ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: EMPTY
4611: ST_TO_ADDR
// if not fac then
4612: LD_VAR 0 2
4616: NOT
4617: IFFALSE 4622
// begin disable ;
4619: DISABLE
// exit ;
4620: GO 4779
// end ; for i in fac do
4622: LD_ADDR_VAR 0 1
4626: PUSH
4627: LD_VAR 0 2
4631: PUSH
4632: FOR_IN
4633: IFFALSE 4671
// if UnitsInside ( i ) then
4635: LD_VAR 0 1
4639: PPUSH
4640: CALL_OW 313
4644: IFFALSE 4669
// can_produce := Insert ( can_produce , 1 , i ) ;
4646: LD_ADDR_VAR 0 3
4650: PUSH
4651: LD_VAR 0 3
4655: PPUSH
4656: LD_INT 1
4658: PPUSH
4659: LD_VAR 0 1
4663: PPUSH
4664: CALL_OW 2
4668: ST_TO_ADDR
4669: GO 4632
4671: POP
4672: POP
// if not can_produce then
4673: LD_VAR 0 3
4677: NOT
4678: IFFALSE 4682
// exit ;
4680: GO 4779
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4682: LD_VAR 0 3
4686: PUSH
4687: LD_INT 1
4689: PPUSH
4690: LD_VAR 0 3
4694: PPUSH
4695: CALL_OW 12
4699: ARRAY
4700: PPUSH
4701: LD_EXP 54
4705: PUSH
4706: LD_INT 1
4708: ARRAY
4709: PPUSH
4710: LD_EXP 54
4714: PUSH
4715: LD_INT 2
4717: ARRAY
4718: PPUSH
4719: LD_EXP 54
4723: PUSH
4724: LD_INT 3
4726: ARRAY
4727: PPUSH
4728: LD_EXP 54
4732: PUSH
4733: LD_INT 4
4735: ARRAY
4736: PPUSH
4737: CALL_OW 125
// for i = 1 to 4 do
4741: LD_ADDR_VAR 0 1
4745: PUSH
4746: DOUBLE
4747: LD_INT 1
4749: DEC
4750: ST_TO_ADDR
4751: LD_INT 4
4753: PUSH
4754: FOR_TO
4755: IFFALSE 4777
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4757: LD_ADDR_EXP 54
4761: PUSH
4762: LD_EXP 54
4766: PPUSH
4767: LD_INT 1
4769: PPUSH
4770: CALL_OW 3
4774: ST_TO_ADDR
4775: GO 4754
4777: POP
4778: POP
// end ;
4779: PPOPN 3
4781: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4782: LD_INT 0
4784: PPUSH
4785: PPUSH
4786: PPUSH
// for i = 1 to 6 do
4787: LD_ADDR_VAR 0 2
4791: PUSH
4792: DOUBLE
4793: LD_INT 1
4795: DEC
4796: ST_TO_ADDR
4797: LD_INT 6
4799: PUSH
4800: FOR_TO
4801: IFFALSE 4950
// begin PrepareHuman ( false , 3 , 3 ) ;
4803: LD_INT 0
4805: PPUSH
4806: LD_INT 3
4808: PPUSH
4809: LD_INT 3
4811: PPUSH
4812: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4816: LD_ADDR_VAR 0 3
4820: PUSH
4821: LD_INT 3
4823: PPUSH
4824: LD_INT 3
4826: PPUSH
4827: LD_INT 22
4829: PPUSH
4830: LD_INT 1
4832: PPUSH
4833: LD_INT 1
4835: PPUSH
4836: LD_INT 43
4838: PUSH
4839: LD_INT 42
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 2
4851: PPUSH
4852: CALL_OW 12
4856: ARRAY
4857: PPUSH
4858: LD_INT 70
4860: PPUSH
4861: CALL 521 0 7
4865: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4866: LD_VAR 0 3
4870: PPUSH
4871: LD_INT 4
4873: PPUSH
4874: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4878: LD_VAR 0 3
4882: PPUSH
4883: LD_INT 229
4885: PPUSH
4886: LD_INT 44
4888: PPUSH
4889: LD_INT 0
4891: PPUSH
4892: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4896: CALL_OW 44
4900: PPUSH
4901: LD_VAR 0 3
4905: PPUSH
4906: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4910: LD_ADDR_EXP 53
4914: PUSH
4915: LD_EXP 53
4919: PUSH
4920: LD_VAR 0 3
4924: ADD
4925: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4926: LD_VAR 0 3
4930: PPUSH
4931: LD_INT 191
4933: PPUSH
4934: LD_INT 32
4936: PPUSH
4937: CALL_OW 111
// Wait ( 0 0$02 ) ;
4941: LD_INT 70
4943: PPUSH
4944: CALL_OW 67
// end ;
4948: GO 4800
4950: POP
4951: POP
// end ; end_of_file
4952: LD_VAR 0 1
4956: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4957: LD_INT 0
4959: PPUSH
4960: PPUSH
4961: PPUSH
4962: PPUSH
4963: PPUSH
4964: PPUSH
4965: PPUSH
// InGameOn ;
4966: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4970: LD_EXP 34
4974: PPUSH
4975: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4979: LD_EXP 34
4983: PPUSH
4984: LD_EXP 41
4988: PPUSH
4989: CALL_OW 119
// if Bierezov then
4993: LD_EXP 42
4997: IFFALSE 5013
// ComTurnUnit ( Bierezov , Cornel ) ;
4999: LD_EXP 42
5003: PPUSH
5004: LD_EXP 41
5008: PPUSH
5009: CALL_OW 119
// for i in jmm_units do
5013: LD_ADDR_VAR 0 2
5017: PUSH
5018: LD_EXP 4
5022: PUSH
5023: FOR_IN
5024: IFFALSE 5042
// ComTurnUnit ( i , Cornel ) ;
5026: LD_VAR 0 2
5030: PPUSH
5031: LD_EXP 41
5035: PPUSH
5036: CALL_OW 119
5040: GO 5023
5042: POP
5043: POP
// units := cornel_units union Cornel ;
5044: LD_ADDR_VAR 0 3
5048: PUSH
5049: LD_EXP 6
5053: PUSH
5054: LD_EXP 41
5058: UNION
5059: ST_TO_ADDR
// repeat wait ( 1 ) ;
5060: LD_INT 1
5062: PPUSH
5063: CALL_OW 67
// for i in units do
5067: LD_ADDR_VAR 0 2
5071: PUSH
5072: LD_VAR 0 3
5076: PUSH
5077: FOR_IN
5078: IFFALSE 5111
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5080: LD_VAR 0 2
5084: PPUSH
5085: LD_EXP 34
5089: PPUSH
5090: CALL_OW 250
5094: PPUSH
5095: LD_EXP 34
5099: PPUSH
5100: CALL_OW 251
5104: PPUSH
5105: CALL_OW 111
5109: GO 5077
5111: POP
5112: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5113: LD_VAR 0 3
5117: PPUSH
5118: LD_INT 92
5120: PUSH
5121: LD_EXP 34
5125: PPUSH
5126: CALL_OW 250
5130: PUSH
5131: LD_EXP 34
5135: PPUSH
5136: CALL_OW 251
5140: PUSH
5141: LD_INT 10
5143: PUSH
5144: EMPTY
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: PPUSH
5150: CALL_OW 72
5154: PUSH
5155: LD_VAR 0 3
5159: EQUAL
5160: IFFALSE 5060
// for i in units do
5162: LD_ADDR_VAR 0 2
5166: PUSH
5167: LD_VAR 0 3
5171: PUSH
5172: FOR_IN
5173: IFFALSE 5191
// ComTurnUnit ( i , JMM ) ;
5175: LD_VAR 0 2
5179: PPUSH
5180: LD_EXP 34
5184: PPUSH
5185: CALL_OW 119
5189: GO 5172
5191: POP
5192: POP
// ComTurnUnit ( Cornel , JMM ) ;
5193: LD_EXP 41
5197: PPUSH
5198: LD_EXP 34
5202: PPUSH
5203: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5207: LD_EXP 34
5211: PPUSH
5212: LD_STRING D1-JMM-1
5214: PPUSH
5215: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5219: LD_EXP 41
5223: PPUSH
5224: LD_STRING D1-Corn-1
5226: PPUSH
5227: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5231: LD_EXP 34
5235: PPUSH
5236: LD_EXP 41
5240: PPUSH
5241: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5245: LD_EXP 41
5249: PPUSH
5250: LD_EXP 34
5254: PPUSH
5255: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5259: LD_INT 35
5261: PPUSH
5262: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5266: LD_EXP 34
5270: PPUSH
5271: LD_EXP 41
5275: PPUSH
5276: CALL_OW 296
5280: PUSH
5281: LD_INT 6
5283: LESS
5284: IFFALSE 5259
// ChangeSideFog ( 4 , 1 ) ;
5286: LD_INT 4
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5296: LD_EXP 34
5300: PPUSH
5301: LD_EXP 41
5305: PPUSH
5306: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5310: LD_EXP 41
5314: PPUSH
5315: LD_EXP 34
5319: PPUSH
5320: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5324: LD_EXP 34
5328: PPUSH
5329: LD_STRING D1-JMM-2
5331: PPUSH
5332: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5336: LD_EXP 34
5340: PPUSH
5341: LD_STRING D1-JMM-2a
5343: PPUSH
5344: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5348: LD_EXP 41
5352: PPUSH
5353: LD_STRING D1-Corn-2
5355: PPUSH
5356: CALL_OW 88
// if bierezov_exist or debug then
5360: LD_EXP 7
5364: PUSH
5365: LD_EXP 1
5369: OR
5370: IFFALSE 5611
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5372: LD_EXP 41
5376: PPUSH
5377: LD_EXP 42
5381: PPUSH
5382: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5386: LD_INT 10
5388: PPUSH
5389: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5393: LD_EXP 41
5397: PPUSH
5398: LD_STRING D1a-Corn-1
5400: PPUSH
5401: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5405: LD_EXP 34
5409: PPUSH
5410: LD_EXP 42
5414: PPUSH
5415: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5419: LD_EXP 42
5423: PPUSH
5424: LD_EXP 34
5428: PPUSH
5429: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5433: LD_EXP 34
5437: PPUSH
5438: LD_STRING D1a-JMM-1
5440: PPUSH
5441: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5445: LD_EXP 34
5449: PPUSH
5450: LD_EXP 41
5454: PPUSH
5455: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5459: LD_EXP 41
5463: PPUSH
5464: LD_EXP 34
5468: PPUSH
5469: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5473: LD_EXP 41
5477: PPUSH
5478: LD_STRING D1a-Corn-2
5480: PPUSH
5481: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5485: LD_EXP 34
5489: PPUSH
5490: LD_STRING D1a-JMM-2
5492: PPUSH
5493: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5497: LD_EXP 41
5501: PPUSH
5502: LD_STRING D1a-Corn-3
5504: PPUSH
5505: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5509: LD_EXP 34
5513: PPUSH
5514: LD_STRING D1a-JMM-3
5516: PPUSH
5517: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5521: LD_EXP 41
5525: PPUSH
5526: LD_STRING D1a-Corn-4
5528: PPUSH
5529: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5533: LD_EXP 34
5537: PPUSH
5538: LD_STRING D1a-JMM-4
5540: PPUSH
5541: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5545: LD_EXP 41
5549: PPUSH
5550: LD_STRING D1a-Corn-5
5552: PPUSH
5553: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5557: LD_EXP 42
5561: PPUSH
5562: LD_EXP 41
5566: PPUSH
5567: CALL_OW 250
5571: PPUSH
5572: LD_EXP 41
5576: PPUSH
5577: CALL_OW 251
5581: PUSH
5582: LD_INT 2
5584: MINUS
5585: PPUSH
5586: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5590: LD_EXP 42
5594: PPUSH
5595: LD_EXP 41
5599: PPUSH
5600: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5604: LD_INT 10
5606: PPUSH
5607: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5611: LD_EXP 34
5615: PPUSH
5616: LD_STRING D1b-JMM-1
5618: PPUSH
5619: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5623: LD_EXP 41
5627: PPUSH
5628: LD_STRING D1b-Corn-1
5630: PPUSH
5631: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5635: LD_EXP 34
5639: PPUSH
5640: LD_STRING D1b-JMM-2
5642: PPUSH
5643: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5647: LD_EXP 41
5651: PPUSH
5652: LD_STRING D1b-Corn-2
5654: PPUSH
5655: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5659: LD_EXP 34
5663: PPUSH
5664: LD_STRING D1b-JMM-3
5666: PPUSH
5667: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5671: LD_INT 10
5673: PPUSH
5674: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5678: LD_EXP 43
5682: PPUSH
5683: LD_STRING D1b-Pow-3
5685: PPUSH
5686: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5690: LD_EXP 34
5694: PPUSH
5695: LD_STRING D1b-JMM-4
5697: PPUSH
5698: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5702: LD_EXP 41
5706: PPUSH
5707: LD_STRING D1b-Corn-4
5709: PPUSH
5710: CALL_OW 88
// if Khatam then
5714: LD_EXP 38
5718: IFFALSE 5734
// Say ( Khatam , D1b-Khat-4 ) else
5720: LD_EXP 38
5724: PPUSH
5725: LD_STRING D1b-Khat-4
5727: PPUSH
5728: CALL_OW 88
5732: GO 5770
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5734: LD_EXP 6
5738: PPUSH
5739: LD_INT 26
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: PPUSH
5749: CALL_OW 72
5753: PUSH
5754: LD_EXP 41
5758: PUSH
5759: EMPTY
5760: LIST
5761: DIFF
5762: PPUSH
5763: LD_STRING D1b-Sol1-4
5765: PPUSH
5766: CALL 609 0 2
// if Cyrus then
5770: LD_EXP 36
5774: IFFALSE 5788
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5776: LD_EXP 36
5780: PPUSH
5781: LD_STRING D1b-Cyrus-4
5783: PPUSH
5784: CALL_OW 88
// if Lisa then
5788: LD_EXP 37
5792: IFFALSE 5850
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5794: LD_EXP 37
5798: PPUSH
5799: LD_STRING D1b-Lisa-4
5801: PPUSH
5802: CALL_OW 88
// if Cyrus then
5806: LD_EXP 36
5810: IFFALSE 5850
// begin if not IsInUnit ( Cyrus ) then
5812: LD_EXP 36
5816: PPUSH
5817: CALL_OW 310
5821: NOT
5822: IFFALSE 5838
// ComTurnUnit ( Cyrus , Lisa ) ;
5824: LD_EXP 36
5828: PPUSH
5829: LD_EXP 37
5833: PPUSH
5834: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5838: LD_EXP 36
5842: PPUSH
5843: LD_STRING D1b-Cyrus-5
5845: PPUSH
5846: CALL_OW 88
// end ; end ; SelectGroup ;
5850: CALL 2562 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5854: LD_EXP 34
5858: PPUSH
5859: LD_STRING D1d-JMM-1
5861: PPUSH
5862: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5866: LD_EXP 41
5870: PPUSH
5871: LD_STRING D1d-Corn-1
5873: PPUSH
5874: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5878: LD_ADDR_VAR 0 2
5882: PUSH
5883: LD_EXP 4
5887: PUSH
5888: LD_EXP 6
5892: ADD
5893: PUSH
5894: LD_EXP 34
5898: ADD
5899: PUSH
5900: FOR_IN
5901: IFFALSE 5914
// ComHold ( i ) ;
5903: LD_VAR 0 2
5907: PPUSH
5908: CALL_OW 140
5912: GO 5900
5914: POP
5915: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5916: LD_ADDR_VAR 0 4
5920: PUSH
5921: LD_INT 22
5923: PUSH
5924: LD_INT 1
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: PUSH
5931: LD_INT 21
5933: PUSH
5934: LD_INT 2
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PPUSH
5945: CALL_OW 69
5949: ST_TO_ADDR
// if vehicles then
5950: LD_VAR 0 4
5954: IFFALSE 6292
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5956: LD_EXP 6
5960: PPUSH
5961: LD_INT 55
5963: PUSH
5964: EMPTY
5965: LIST
5966: PPUSH
5967: CALL_OW 72
5971: IFFALSE 6010
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5973: LD_ADDR_VAR 0 2
5977: PUSH
5978: LD_EXP 6
5982: PPUSH
5983: LD_INT 55
5985: PUSH
5986: EMPTY
5987: LIST
5988: PPUSH
5989: CALL_OW 72
5993: PUSH
5994: FOR_IN
5995: IFFALSE 6008
// ComExitVehicle ( i ) ;
5997: LD_VAR 0 2
6001: PPUSH
6002: CALL_OW 121
6006: GO 5994
6008: POP
6009: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6010: LD_ADDR_VAR 0 5
6014: PUSH
6015: LD_VAR 0 4
6019: PPUSH
6020: LD_INT 34
6022: PUSH
6023: LD_INT 51
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PPUSH
6030: CALL_OW 72
6034: ST_TO_ADDR
// if cargos then
6035: LD_VAR 0 5
6039: IFFALSE 6222
// begin vehicles := cargos ;
6041: LD_ADDR_VAR 0 4
6045: PUSH
6046: LD_VAR 0 5
6050: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6051: LD_ADDR_VAR 0 6
6055: PUSH
6056: LD_STRING 02_resources_4
6058: PPUSH
6059: LD_INT 0
6061: PPUSH
6062: CALL_OW 30
6066: ST_TO_ADDR
// if debug and not resources then
6067: LD_EXP 1
6071: PUSH
6072: LD_VAR 0 6
6076: NOT
6077: AND
6078: IFFALSE 6088
// resources := 160 ;
6080: LD_ADDR_VAR 0 6
6084: PUSH
6085: LD_INT 160
6087: ST_TO_ADDR
// if resources mod 10 then
6088: LD_VAR 0 6
6092: PUSH
6093: LD_INT 10
6095: MOD
6096: IFFALSE 6118
// resources := resources - resources mod 10 ;
6098: LD_ADDR_VAR 0 6
6102: PUSH
6103: LD_VAR 0 6
6107: PUSH
6108: LD_VAR 0 6
6112: PUSH
6113: LD_INT 10
6115: MOD
6116: MINUS
6117: ST_TO_ADDR
// if resources then
6118: LD_VAR 0 6
6122: IFFALSE 6222
// for i in cargos do
6124: LD_ADDR_VAR 0 2
6128: PUSH
6129: LD_VAR 0 5
6133: PUSH
6134: FOR_IN
6135: IFFALSE 6220
// begin if resources < 100 then
6137: LD_VAR 0 6
6141: PUSH
6142: LD_INT 100
6144: LESS
6145: IFFALSE 6167
// begin cargo := resources ;
6147: LD_ADDR_VAR 0 7
6151: PUSH
6152: LD_VAR 0 6
6156: ST_TO_ADDR
// resources := 0 ;
6157: LD_ADDR_VAR 0 6
6161: PUSH
6162: LD_INT 0
6164: ST_TO_ADDR
// end else
6165: GO 6189
// begin cargo := 100 ;
6167: LD_ADDR_VAR 0 7
6171: PUSH
6172: LD_INT 100
6174: ST_TO_ADDR
// resources := resources - 100 ;
6175: LD_ADDR_VAR 0 6
6179: PUSH
6180: LD_VAR 0 6
6184: PUSH
6185: LD_INT 100
6187: MINUS
6188: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6189: LD_VAR 0 2
6193: PPUSH
6194: LD_INT 1
6196: PPUSH
6197: LD_VAR 0 7
6201: PPUSH
6202: CALL_OW 290
// if resources = 0 then
6206: LD_VAR 0 6
6210: PUSH
6211: LD_INT 0
6213: EQUAL
6214: IFFALSE 6218
// break ;
6216: GO 6220
// end ;
6218: GO 6134
6220: POP
6221: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6222: LD_VAR 0 4
6226: PUSH
6227: LD_INT 1
6229: ARRAY
6230: PPUSH
6231: CALL_OW 311
6235: PPUSH
6236: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6240: LD_VAR 0 4
6244: PUSH
6245: LD_INT 1
6247: ARRAY
6248: PPUSH
6249: LD_INT 4
6251: PPUSH
6252: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6256: LD_EXP 41
6260: PPUSH
6261: LD_VAR 0 4
6265: PUSH
6266: LD_INT 1
6268: ARRAY
6269: PPUSH
6270: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6274: LD_INT 35
6276: PPUSH
6277: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6281: LD_EXP 41
6285: PPUSH
6286: CALL_OW 310
6290: IFFALSE 6274
// end ; InGameOff ;
6292: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6296: LD_STRING M1
6298: PPUSH
6299: CALL_OW 337
// SaveForQuickRestart ;
6303: CALL_OW 22
// cornel_active := true ;
6307: LD_ADDR_EXP 8
6311: PUSH
6312: LD_INT 1
6314: ST_TO_ADDR
// end ;
6315: LD_VAR 0 1
6319: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6320: LD_EXP 34
6324: PPUSH
6325: LD_EXP 44
6329: PPUSH
6330: CALL_OW 296
6334: PUSH
6335: LD_INT 10
6337: LESS
6338: IFFALSE 7494
6340: GO 6342
6342: DISABLE
6343: LD_INT 0
6345: PPUSH
6346: PPUSH
6347: PPUSH
6348: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6349: LD_ADDR_VAR 0 2
6353: PUSH
6354: LD_INT 89
6356: PUSH
6357: LD_INT 34
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 138
6366: PUSH
6367: LD_INT 63
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 196
6376: PUSH
6377: LD_INT 84
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: LD_INT 135
6386: PUSH
6387: LD_INT 52
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 103
6396: PUSH
6397: LD_INT 39
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: PUSH
6404: LD_INT 58
6406: PUSH
6407: LD_INT 30
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: LD_INT 38
6416: PUSH
6417: LD_INT 51
6419: PUSH
6420: EMPTY
6421: LIST
6422: LIST
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: LIST
6431: LIST
6432: ST_TO_ADDR
// InGameOn ;
6433: CALL_OW 8
// if jmm_units then
6437: LD_EXP 4
6441: IFFALSE 6505
// for i in jmm_units do
6443: LD_ADDR_VAR 0 1
6447: PUSH
6448: LD_EXP 4
6452: PUSH
6453: FOR_IN
6454: IFFALSE 6503
// begin if GetDistUnits ( i , JMM ) < 10 then
6456: LD_VAR 0 1
6460: PPUSH
6461: LD_EXP 34
6465: PPUSH
6466: CALL_OW 296
6470: PUSH
6471: LD_INT 10
6473: LESS
6474: IFFALSE 6492
// ComTurnUnit ( i , JMM ) else
6476: LD_VAR 0 1
6480: PPUSH
6481: LD_EXP 34
6485: PPUSH
6486: CALL_OW 119
6490: GO 6501
// ComHold ( i ) ;
6492: LD_VAR 0 1
6496: PPUSH
6497: CALL_OW 140
// end ;
6501: GO 6453
6503: POP
6504: POP
// if IsInUnit ( JMM ) then
6505: LD_EXP 34
6509: PPUSH
6510: CALL_OW 310
6514: IFFALSE 6539
// begin ComExitVehicle ( JMM ) ;
6516: LD_EXP 34
6520: PPUSH
6521: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6525: LD_EXP 34
6529: PPUSH
6530: LD_EXP 44
6534: PPUSH
6535: CALL_OW 172
// end ; Wait ( 10 ) ;
6539: LD_INT 10
6541: PPUSH
6542: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6546: LD_EXP 34
6550: PPUSH
6551: LD_EXP 44
6555: PPUSH
6556: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6560: LD_INT 35
6562: PPUSH
6563: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6567: LD_EXP 34
6571: PPUSH
6572: LD_EXP 44
6576: PPUSH
6577: CALL_OW 296
6581: PUSH
6582: LD_INT 6
6584: LESS
6585: IFFALSE 6560
// ComTurnUnit ( JMM , Lynch ) ;
6587: LD_EXP 34
6591: PPUSH
6592: LD_EXP 44
6596: PPUSH
6597: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6601: LD_ADDR_VAR 0 1
6605: PUSH
6606: LD_EXP 44
6610: PUSH
6611: LD_EXP 45
6615: PUSH
6616: LD_EXP 46
6620: PUSH
6621: LD_EXP 47
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: LIST
6630: LIST
6631: PUSH
6632: FOR_IN
6633: IFFALSE 6651
// ComTurnUnit ( i , JMM ) ;
6635: LD_VAR 0 1
6639: PPUSH
6640: LD_EXP 34
6644: PPUSH
6645: CALL_OW 119
6649: GO 6632
6651: POP
6652: POP
// Wait ( 0 0$0.3 ) ;
6653: LD_INT 10
6655: PPUSH
6656: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6660: LD_EXP 34
6664: PPUSH
6665: LD_STRING D2-JMM-1
6667: PPUSH
6668: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6672: LD_EXP 44
6676: PPUSH
6677: LD_STRING D2-Sol1-1
6679: PPUSH
6680: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6684: LD_EXP 34
6688: PPUSH
6689: LD_STRING D2-JMM-2
6691: PPUSH
6692: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6696: LD_EXP 44
6700: PPUSH
6701: LD_STRING D2-Sol1-2
6703: PPUSH
6704: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6708: LD_EXP 34
6712: PPUSH
6713: LD_STRING D2-JMM-3
6715: PPUSH
6716: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6720: LD_EXP 44
6724: PPUSH
6725: LD_STRING D2-Sol1-3
6727: PPUSH
6728: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6732: LD_ADDR_VAR 0 1
6736: PUSH
6737: LD_INT 22
6739: PUSH
6740: LD_INT 8
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: PPUSH
6747: CALL_OW 69
6751: PUSH
6752: FOR_IN
6753: IFFALSE 6769
// SetSide ( i , 1 ) ;
6755: LD_VAR 0 1
6759: PPUSH
6760: LD_INT 1
6762: PPUSH
6763: CALL_OW 235
6767: GO 6752
6769: POP
6770: POP
// Say ( JMM , D2-JMM-4 ) ;
6771: LD_EXP 34
6775: PPUSH
6776: LD_STRING D2-JMM-4
6778: PPUSH
6779: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6783: LD_INT 1
6785: PPUSH
6786: LD_INT 5
6788: PPUSH
6789: CALL_OW 332
// for i = 1 to points do
6793: LD_ADDR_VAR 0 1
6797: PUSH
6798: DOUBLE
6799: LD_INT 1
6801: DEC
6802: ST_TO_ADDR
6803: LD_VAR 0 2
6807: PUSH
6808: FOR_TO
6809: IFFALSE 6984
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6811: LD_VAR 0 2
6815: PUSH
6816: LD_VAR 0 1
6820: ARRAY
6821: PUSH
6822: LD_INT 1
6824: ARRAY
6825: PPUSH
6826: LD_VAR 0 2
6830: PUSH
6831: LD_VAR 0 1
6835: ARRAY
6836: PUSH
6837: LD_INT 2
6839: ARRAY
6840: PPUSH
6841: CALL_OW 84
// if i = 1 then
6845: LD_VAR 0 1
6849: PUSH
6850: LD_INT 1
6852: EQUAL
6853: IFFALSE 6867
// Say ( Lynch , D2-Sol1-4 ) ;
6855: LD_EXP 44
6859: PPUSH
6860: LD_STRING D2-Sol1-4
6862: PPUSH
6863: CALL_OW 88
// if i = 2 then
6867: LD_VAR 0 1
6871: PUSH
6872: LD_INT 2
6874: EQUAL
6875: IFFALSE 6889
// Say ( JMM , D2-JMM-5 ) ;
6877: LD_EXP 34
6881: PPUSH
6882: LD_STRING D2-JMM-5
6884: PPUSH
6885: CALL_OW 88
// if i = 4 then
6889: LD_VAR 0 1
6893: PUSH
6894: LD_INT 4
6896: EQUAL
6897: IFFALSE 6921
// begin RevealFogArea ( 1 , troopsArea ) ;
6899: LD_INT 1
6901: PPUSH
6902: LD_INT 6
6904: PPUSH
6905: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6909: LD_EXP 44
6913: PPUSH
6914: LD_STRING D2-Sol1-5
6916: PPUSH
6917: CALL_OW 88
// end ; if i = 5 then
6921: LD_VAR 0 1
6925: PUSH
6926: LD_INT 5
6928: EQUAL
6929: IFFALSE 6943
// Say ( JMM , D2-JMM-6 ) ;
6931: LD_EXP 34
6935: PPUSH
6936: LD_STRING D2-JMM-6
6938: PPUSH
6939: CALL_OW 88
// if i = 7 then
6943: LD_VAR 0 1
6947: PUSH
6948: LD_INT 7
6950: EQUAL
6951: IFFALSE 6975
// begin RevealFogArea ( 1 , forestArea ) ;
6953: LD_INT 1
6955: PPUSH
6956: LD_INT 7
6958: PPUSH
6959: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6963: LD_EXP 44
6967: PPUSH
6968: LD_STRING D2-Sol1-6
6970: PPUSH
6971: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6975: LD_INT 46
6977: PPUSH
6978: CALL_OW 67
// end ;
6982: GO 6808
6984: POP
6985: POP
// CenterNowOnUnits ( JMM ) ;
6986: LD_EXP 34
6990: PPUSH
6991: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6995: LD_EXP 34
6999: PPUSH
7000: LD_STRING D2-JMM-7
7002: PPUSH
7003: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7007: LD_EXP 44
7011: PPUSH
7012: LD_STRING D2-Sol1-7
7014: PPUSH
7015: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7019: LD_EXP 34
7023: PPUSH
7024: LD_STRING D2-JMM-8
7026: PPUSH
7027: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: LD_INT 22
7038: PUSH
7039: LD_INT 1
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: PUSH
7046: LD_INT 30
7048: PUSH
7049: LD_INT 31
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PPUSH
7060: CALL_OW 69
7064: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7065: LD_EXP 44
7069: PPUSH
7070: LD_VAR 0 4
7074: PUSH
7075: LD_INT 1
7077: ARRAY
7078: PPUSH
7079: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7083: LD_ADDR_VAR 0 3
7087: PUSH
7088: LD_EXP 4
7092: PPUSH
7093: LD_INT 25
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: PPUSH
7103: CALL_OW 72
7107: PPUSH
7108: LD_EXP 34
7112: PPUSH
7113: CALL_OW 74
7117: ST_TO_ADDR
// if sol then
7118: LD_VAR 0 3
7122: IFFALSE 7162
// if GetDistUnits ( JMM , sol ) < 10 then
7124: LD_EXP 34
7128: PPUSH
7129: LD_VAR 0 3
7133: PPUSH
7134: CALL_OW 296
7138: PUSH
7139: LD_INT 10
7141: LESS
7142: IFFALSE 7162
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7144: LD_VAR 0 3
7148: PPUSH
7149: LD_VAR 0 4
7153: PUSH
7154: LD_INT 2
7156: ARRAY
7157: PPUSH
7158: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7162: LD_INT 10
7164: PPUSH
7165: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7169: LD_EXP 34
7173: PPUSH
7174: LD_INT 65
7176: PPUSH
7177: LD_INT 101
7179: PPUSH
7180: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7184: LD_EXP 34
7188: PPUSH
7189: LD_INT 63
7191: PPUSH
7192: LD_INT 100
7194: PPUSH
7195: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7199: LD_INT 35
7201: PPUSH
7202: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7206: LD_EXP 34
7210: PPUSH
7211: LD_INT 65
7213: PPUSH
7214: LD_INT 101
7216: PPUSH
7217: CALL_OW 307
7221: IFFALSE 7199
// Say ( JMM , D2a-JMM-1 ) ;
7223: LD_EXP 34
7227: PPUSH
7228: LD_STRING D2a-JMM-1
7230: PPUSH
7231: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7235: LD_EXP 45
7239: PPUSH
7240: LD_INT 66
7242: PPUSH
7243: LD_INT 103
7245: PPUSH
7246: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7250: LD_INT 35
7252: PPUSH
7253: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7257: LD_EXP 45
7261: PPUSH
7262: LD_INT 66
7264: PPUSH
7265: LD_INT 103
7267: PPUSH
7268: CALL_OW 307
7272: IFFALSE 7250
// ComTurnUnit ( Walker , JMM ) ;
7274: LD_EXP 45
7278: PPUSH
7279: LD_EXP 34
7283: PPUSH
7284: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7288: LD_EXP 45
7292: PPUSH
7293: LD_STRING D2a-Sci1-1
7295: PPUSH
7296: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7300: LD_EXP 34
7304: PPUSH
7305: LD_EXP 45
7309: PPUSH
7310: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7314: LD_EXP 34
7318: PPUSH
7319: LD_STRING D2a-JMM-2
7321: PPUSH
7322: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7326: LD_EXP 45
7330: PPUSH
7331: LD_STRING D2a-Sci1-2
7333: PPUSH
7334: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7338: LD_EXP 34
7342: PPUSH
7343: LD_STRING D2a-JMM-3
7345: PPUSH
7346: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7350: LD_EXP 45
7354: PPUSH
7355: LD_STRING D2a-Sci1-3
7357: PPUSH
7358: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7362: LD_ADDR_EXP 4
7366: PUSH
7367: LD_EXP 4
7371: PUSH
7372: LD_EXP 44
7376: PUSH
7377: LD_EXP 45
7381: PUSH
7382: LD_EXP 46
7386: PUSH
7387: LD_EXP 47
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: ADD
7398: ST_TO_ADDR
// for i in jmm_units do
7399: LD_ADDR_VAR 0 1
7403: PUSH
7404: LD_EXP 4
7408: PUSH
7409: FOR_IN
7410: IFFALSE 7435
// if not IsInUnit ( i ) then
7412: LD_VAR 0 1
7416: PPUSH
7417: CALL_OW 310
7421: NOT
7422: IFFALSE 7433
// ComFree ( i ) ;
7424: LD_VAR 0 1
7428: PPUSH
7429: CALL_OW 139
7433: GO 7409
7435: POP
7436: POP
// InGameOff ;
7437: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7441: LD_STRING MSolar1
7443: PPUSH
7444: CALL_OW 337
// jmm_on_west := true ;
7448: LD_ADDR_EXP 5
7452: PUSH
7453: LD_INT 1
7455: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7456: LD_INT 1050
7458: PPUSH
7459: CALL_OW 67
// frank_can_return := true ;
7463: LD_ADDR_EXP 12
7467: PUSH
7468: LD_INT 1
7470: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7471: LD_INT 6300
7473: PPUSH
7474: LD_INT 8400
7476: PPUSH
7477: CALL_OW 12
7481: PPUSH
7482: CALL_OW 67
// send_spec_patrol := true ;
7486: LD_ADDR_EXP 28
7490: PUSH
7491: LD_INT 1
7493: ST_TO_ADDR
// end ;
7494: PPOPN 4
7496: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7497: LD_INT 22
7499: PUSH
7500: LD_INT 1
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 34
7509: PUSH
7510: LD_INT 51
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 92
7519: PUSH
7520: LD_INT 63
7522: PUSH
7523: LD_INT 100
7525: PUSH
7526: LD_INT 5
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: PPUSH
7543: CALL_OW 69
7547: PUSH
7548: LD_EXP 5
7552: NOT
7553: AND
7554: IFFALSE 7667
7556: GO 7558
7558: DISABLE
7559: LD_INT 0
7561: PPUSH
7562: PPUSH
// begin enable ;
7563: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7564: LD_ADDR_VAR 0 2
7568: PUSH
7569: LD_INT 22
7571: PUSH
7572: LD_INT 1
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 34
7581: PUSH
7582: LD_INT 51
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 92
7591: PUSH
7592: LD_INT 63
7594: PUSH
7595: LD_INT 100
7597: PUSH
7598: LD_INT 5
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: PUSH
7612: EMPTY
7613: LIST
7614: PPUSH
7615: CALL_OW 69
7619: ST_TO_ADDR
// if not filter then
7620: LD_VAR 0 2
7624: NOT
7625: IFFALSE 7629
// exit ;
7627: GO 7667
// for i in filter do
7629: LD_ADDR_VAR 0 1
7633: PUSH
7634: LD_VAR 0 2
7638: PUSH
7639: FOR_IN
7640: IFFALSE 7665
// begin SetFuel ( i , 0 ) ;
7642: LD_VAR 0 1
7646: PPUSH
7647: LD_INT 0
7649: PPUSH
7650: CALL_OW 240
// ComStop ( i ) ;
7654: LD_VAR 0 1
7658: PPUSH
7659: CALL_OW 141
// end ;
7663: GO 7639
7665: POP
7666: POP
// end ;
7667: PPOPN 2
7669: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7670: LD_EXP 28
7674: IFFALSE 8639
7676: GO 7678
7678: DISABLE
7679: LD_INT 0
7681: PPUSH
7682: PPUSH
7683: PPUSH
7684: PPUSH
7685: PPUSH
7686: PPUSH
7687: PPUSH
// begin if not ru_spec_patrol then
7688: LD_EXP 51
7692: NOT
7693: IFFALSE 7697
// exit ;
7695: GO 8639
// dead1 := false ;
7697: LD_ADDR_VAR 0 1
7701: PUSH
7702: LD_INT 0
7704: ST_TO_ADDR
// dead2 := false ;
7705: LD_ADDR_VAR 0 2
7709: PUSH
7710: LD_INT 0
7712: ST_TO_ADDR
// inarea1 := false ;
7713: LD_ADDR_VAR 0 3
7717: PUSH
7718: LD_INT 0
7720: ST_TO_ADDR
// inarea2 := false ;
7721: LD_ADDR_VAR 0 4
7725: PUSH
7726: LD_INT 0
7728: ST_TO_ADDR
// tmp := [ ] ;
7729: LD_ADDR_VAR 0 6
7733: PUSH
7734: EMPTY
7735: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7736: LD_EXP 51
7740: PPUSH
7741: LD_INT 75
7743: PPUSH
7744: LD_INT 101
7746: PPUSH
7747: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7751: LD_INT 35
7753: PPUSH
7754: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7758: LD_INT 1
7760: PPUSH
7761: LD_EXP 51
7765: PUSH
7766: LD_INT 1
7768: ARRAY
7769: PPUSH
7770: CALL_OW 292
7774: IFFALSE 7751
// ComStop ( ru_spec_patrol ) ;
7776: LD_EXP 51
7780: PPUSH
7781: CALL_OW 141
// Wait ( 0 0$02 ) ;
7785: LD_INT 70
7787: PPUSH
7788: CALL_OW 67
// DialogueOn ;
7792: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7796: LD_EXP 51
7800: PUSH
7801: LD_INT 1
7803: ARRAY
7804: PPUSH
7805: LD_STRING D8-Rus1-1
7807: PPUSH
7808: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7812: LD_EXP 34
7816: PPUSH
7817: LD_STRING D8-JMM-1
7819: PPUSH
7820: CALL_OW 88
// DialogueOff ;
7824: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7828: LD_EXP 51
7832: PPUSH
7833: LD_INT 13
7835: PPUSH
7836: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7840: LD_INT 35
7842: PPUSH
7843: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7847: LD_VAR 0 1
7851: NOT
7852: PUSH
7853: LD_EXP 51
7857: PUSH
7858: LD_INT 1
7860: ARRAY
7861: PPUSH
7862: CALL_OW 301
7866: AND
7867: IFFALSE 7877
// dead1 := true ;
7869: LD_ADDR_VAR 0 1
7873: PUSH
7874: LD_INT 1
7876: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7877: LD_VAR 0 2
7881: NOT
7882: PUSH
7883: LD_EXP 51
7887: PUSH
7888: LD_INT 2
7890: ARRAY
7891: PPUSH
7892: CALL_OW 301
7896: AND
7897: IFFALSE 7907
// dead2 := true ;
7899: LD_ADDR_VAR 0 2
7903: PUSH
7904: LD_INT 1
7906: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7907: LD_VAR 0 3
7911: NOT
7912: PUSH
7913: LD_EXP 51
7917: PUSH
7918: LD_INT 1
7920: ARRAY
7921: PPUSH
7922: LD_INT 14
7924: PPUSH
7925: CALL_OW 308
7929: AND
7930: IFFALSE 7940
// inarea1 := true ;
7932: LD_ADDR_VAR 0 3
7936: PUSH
7937: LD_INT 1
7939: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7940: LD_VAR 0 4
7944: NOT
7945: PUSH
7946: LD_EXP 51
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 14
7957: PPUSH
7958: CALL_OW 308
7962: AND
7963: IFFALSE 7973
// inarea2 := true ;
7965: LD_ADDR_VAR 0 4
7969: PUSH
7970: LD_INT 1
7972: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7973: LD_VAR 0 1
7977: PUSH
7978: LD_VAR 0 2
7982: AND
7983: PUSH
7984: LD_VAR 0 1
7988: PUSH
7989: LD_VAR 0 4
7993: AND
7994: OR
7995: PUSH
7996: LD_VAR 0 2
8000: PUSH
8001: LD_VAR 0 3
8005: AND
8006: OR
8007: PUSH
8008: LD_VAR 0 3
8012: PUSH
8013: LD_VAR 0 4
8017: AND
8018: OR
8019: IFFALSE 7840
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_VAR 0 4
8030: AND
8031: PUSH
8032: LD_VAR 0 1
8036: PUSH
8037: LD_VAR 0 4
8041: AND
8042: OR
8043: PUSH
8044: LD_VAR 0 2
8048: PUSH
8049: LD_VAR 0 3
8053: AND
8054: OR
8055: IFFALSE 8619
// begin prepare_siege := true ;
8057: LD_ADDR_EXP 29
8061: PUSH
8062: LD_INT 1
8064: ST_TO_ADDR
// DialogueOn ;
8065: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8069: LD_VAR 0 3
8073: PUSH
8074: LD_VAR 0 4
8078: AND
8079: IFFALSE 8095
// Say ( JMM , D8b-JMM-1a ) else
8081: LD_EXP 34
8085: PPUSH
8086: LD_STRING D8b-JMM-1a
8088: PPUSH
8089: CALL_OW 88
8093: GO 8107
// Say ( JMM , D8b-JMM-1 ) ;
8095: LD_EXP 34
8099: PPUSH
8100: LD_STRING D8b-JMM-1
8102: PPUSH
8103: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8107: LD_EXP 4
8111: PPUSH
8112: LD_INT 26
8114: PUSH
8115: LD_INT 1
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PPUSH
8122: CALL_OW 72
8126: PUSH
8127: LD_EXP 35
8131: PUSH
8132: LD_EXP 36
8136: PUSH
8137: LD_EXP 45
8141: PUSH
8142: LD_EXP 48
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: LIST
8151: LIST
8152: DIFF
8153: PPUSH
8154: LD_STRING D8b-Sol1-1
8156: PPUSH
8157: CALL 609 0 2
// if Cyrus and Cyrus in jmm_units then
8161: LD_EXP 36
8165: PUSH
8166: LD_EXP 36
8170: PUSH
8171: LD_EXP 4
8175: IN
8176: AND
8177: IFFALSE 8193
// Say ( Cyrus , D8b-Cyrus-1 ) else
8179: LD_EXP 36
8183: PPUSH
8184: LD_STRING D8b-Cyrus-1
8186: PPUSH
8187: CALL_OW 88
8191: GO 8205
// Say ( JMM , D8b-JMM-1a ) ;
8193: LD_EXP 34
8197: PPUSH
8198: LD_STRING D8b-JMM-1a
8200: PPUSH
8201: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8205: LD_EXP 37
8209: PUSH
8210: LD_EXP 37
8214: PUSH
8215: LD_EXP 4
8219: IN
8220: AND
8221: IFFALSE 8235
// Say ( Lisa , D8b-Lisa-2 ) ;
8223: LD_EXP 37
8227: PPUSH
8228: LD_STRING D8b-Lisa-2
8230: PPUSH
8231: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8235: LD_EXP 35
8239: PUSH
8240: LD_EXP 35
8244: PUSH
8245: LD_EXP 4
8249: IN
8250: AND
8251: IFFALSE 8267
// Say ( Bobby , D8b-Bobby-1 ) else
8253: LD_EXP 35
8257: PPUSH
8258: LD_STRING D8b-Bobby-1
8260: PPUSH
8261: CALL_OW 88
8265: GO 8327
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8267: LD_ADDR_VAR 0 5
8271: PUSH
8272: LD_EXP 4
8276: PPUSH
8277: LD_INT 26
8279: PUSH
8280: LD_INT 1
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: PPUSH
8287: CALL_OW 72
8291: PUSH
8292: LD_EXP 35
8296: PUSH
8297: LD_EXP 36
8301: PUSH
8302: LD_EXP 45
8306: PUSH
8307: LD_EXP 48
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: DIFF
8318: PPUSH
8319: LD_STRING D8b-Sol2-1
8321: PPUSH
8322: CALL 609 0 2
8326: ST_TO_ADDR
// DialogueOff ;
8327: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8331: LD_EXP 36
8335: PUSH
8336: LD_EXP 36
8340: PUSH
8341: LD_EXP 4
8345: IN
8346: AND
8347: IFFALSE 8372
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8349: LD_ADDR_VAR 0 6
8353: PUSH
8354: LD_VAR 0 6
8358: PPUSH
8359: LD_INT 1
8361: PPUSH
8362: LD_EXP 36
8366: PPUSH
8367: CALL_OW 2
8371: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8372: LD_EXP 35
8376: PUSH
8377: LD_EXP 35
8381: PUSH
8382: LD_EXP 4
8386: IN
8387: AND
8388: IFFALSE 8413
// tmp := Insert ( tmp , 1 , Bobby ) ;
8390: LD_ADDR_VAR 0 6
8394: PUSH
8395: LD_VAR 0 6
8399: PPUSH
8400: LD_INT 1
8402: PPUSH
8403: LD_EXP 35
8407: PPUSH
8408: CALL_OW 2
8412: ST_TO_ADDR
// if sol then
8413: LD_VAR 0 5
8417: IFFALSE 8442
// tmp := Insert ( tmp , 1 , sol ) ;
8419: LD_ADDR_VAR 0 6
8423: PUSH
8424: LD_VAR 0 6
8428: PPUSH
8429: LD_INT 1
8431: PPUSH
8432: LD_VAR 0 5
8436: PPUSH
8437: CALL_OW 2
8441: ST_TO_ADDR
// if tmp then
8442: LD_VAR 0 6
8446: IFFALSE 8578
// begin SetSide ( tmp , 8 ) ;
8448: LD_VAR 0 6
8452: PPUSH
8453: LD_INT 8
8455: PPUSH
8456: CALL_OW 235
// ComFree ( tmp ) ;
8460: LD_VAR 0 6
8464: PPUSH
8465: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8469: LD_VAR 0 6
8473: PPUSH
8474: LD_INT 15
8476: PPUSH
8477: CALL_OW 173
// AddComHold ( tmp ) ;
8481: LD_VAR 0 6
8485: PPUSH
8486: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8490: LD_INT 35
8492: PPUSH
8493: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8497: LD_VAR 0 6
8501: PUSH
8502: LD_INT 1
8504: ARRAY
8505: PPUSH
8506: LD_INT 15
8508: PPUSH
8509: CALL_OW 308
8513: IFFALSE 8568
// begin RemoveUnit ( tmp [ 1 ] ) ;
8515: LD_VAR 0 6
8519: PUSH
8520: LD_INT 1
8522: ARRAY
8523: PPUSH
8524: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8528: LD_ADDR_EXP 4
8532: PUSH
8533: LD_EXP 4
8537: PUSH
8538: LD_VAR 0 6
8542: PUSH
8543: LD_INT 1
8545: ARRAY
8546: DIFF
8547: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8548: LD_ADDR_VAR 0 6
8552: PUSH
8553: LD_VAR 0 6
8557: PUSH
8558: LD_VAR 0 6
8562: PUSH
8563: LD_INT 1
8565: ARRAY
8566: DIFF
8567: ST_TO_ADDR
// end ; until tmp = 0 ;
8568: LD_VAR 0 6
8572: PUSH
8573: LD_INT 0
8575: EQUAL
8576: IFFALSE 8490
// end ; Wait ( 0 0$30 ) ;
8578: LD_INT 1050
8580: PPUSH
8581: CALL_OW 67
// if ru_spec_patrol then
8585: LD_EXP 51
8589: IFFALSE 8617
// for i in ru_spec_patrol do
8591: LD_ADDR_VAR 0 7
8595: PUSH
8596: LD_EXP 51
8600: PUSH
8601: FOR_IN
8602: IFFALSE 8615
// RemoveUnit ( i ) ;
8604: LD_VAR 0 7
8608: PPUSH
8609: CALL_OW 64
8613: GO 8601
8615: POP
8616: POP
// end else
8617: GO 8639
// begin prepare_siege := false ;
8619: LD_ADDR_EXP 29
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8627: LD_EXP 34
8631: PPUSH
8632: LD_STRING D8a-JMM-1
8634: PPUSH
8635: CALL_OW 88
// end ; end ;
8639: PPOPN 7
8641: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8642: LD_EXP 12
8646: IFFALSE 9780
8648: GO 8650
8650: DISABLE
8651: LD_INT 0
8653: PPUSH
8654: PPUSH
// begin uc_side := 8 ;
8655: LD_ADDR_OWVAR 20
8659: PUSH
8660: LD_INT 8
8662: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8663: LD_ADDR_VAR 0 2
8667: PUSH
8668: LD_INT 59
8670: PUSH
8671: LD_INT 71
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PUSH
8678: LD_INT 122
8680: PUSH
8681: LD_INT 117
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8692: LD_ADDR_EXP 48
8696: PUSH
8697: LD_STRING Frank
8699: PPUSH
8700: LD_INT 0
8702: PPUSH
8703: CALL 458 0 2
8707: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8708: LD_ADDR_VAR 0 1
8712: PUSH
8713: LD_INT 1
8715: PPUSH
8716: LD_INT 2
8718: PPUSH
8719: CALL_OW 12
8723: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8724: LD_EXP 48
8728: PPUSH
8729: LD_VAR 0 2
8733: PUSH
8734: LD_VAR 0 1
8738: ARRAY
8739: PUSH
8740: LD_INT 1
8742: ARRAY
8743: PPUSH
8744: LD_VAR 0 2
8748: PUSH
8749: LD_VAR 0 1
8753: ARRAY
8754: PUSH
8755: LD_INT 2
8757: ARRAY
8758: PPUSH
8759: LD_INT 0
8761: PPUSH
8762: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8766: LD_EXP 48
8770: PPUSH
8771: LD_INT 1
8773: PPUSH
8774: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8778: LD_INT 35
8780: PPUSH
8781: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8785: LD_EXP 48
8789: PPUSH
8790: LD_EXP 34
8794: PPUSH
8795: CALL_OW 296
8799: PUSH
8800: LD_INT 8
8802: LESS
8803: IFFALSE 8778
// InGameOn ;
8805: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8809: LD_EXP 34
8813: PPUSH
8814: CALL_OW 85
// if IsInUnit ( JMM ) then
8818: LD_EXP 34
8822: PPUSH
8823: CALL_OW 310
8827: IFFALSE 8838
// ComFree ( JMM ) ;
8829: LD_EXP 34
8833: PPUSH
8834: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8838: LD_EXP 34
8842: PPUSH
8843: LD_EXP 48
8847: PPUSH
8848: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8852: LD_EXP 48
8856: PPUSH
8857: LD_EXP 34
8861: PPUSH
8862: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8866: LD_EXP 34
8870: PPUSH
8871: LD_STRING D6-JMM-1
8873: PPUSH
8874: CALL_OW 88
// repeat wait ( 3 ) ;
8878: LD_INT 3
8880: PPUSH
8881: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8885: LD_EXP 34
8889: PPUSH
8890: LD_EXP 48
8894: PPUSH
8895: CALL_OW 296
8899: PUSH
8900: LD_INT 8
8902: LESS
8903: IFFALSE 8878
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8905: LD_EXP 37
8909: PUSH
8910: LD_EXP 37
8914: PPUSH
8915: LD_EXP 48
8919: PPUSH
8920: CALL_OW 296
8924: PUSH
8925: LD_INT 20
8927: LESS
8928: AND
8929: IFFALSE 8954
// begin ComFree ( Lisa ) ;
8931: LD_EXP 37
8935: PPUSH
8936: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8940: LD_EXP 37
8944: PPUSH
8945: LD_EXP 48
8949: PPUSH
8950: CALL_OW 172
// end ; if Lynch then
8954: LD_EXP 44
8958: IFFALSE 8983
// begin ComFree ( Lynch ) ;
8960: LD_EXP 44
8964: PPUSH
8965: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8969: LD_EXP 44
8973: PPUSH
8974: LD_EXP 48
8978: PPUSH
8979: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8983: LD_EXP 34
8987: PPUSH
8988: LD_EXP 48
8992: PPUSH
8993: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8997: LD_EXP 48
9001: PPUSH
9002: LD_EXP 34
9006: PPUSH
9007: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9011: LD_EXP 48
9015: PPUSH
9016: LD_STRING D6-Frank-1
9018: PPUSH
9019: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9023: LD_INT 69
9025: PPUSH
9026: LD_INT 20
9028: PPUSH
9029: LD_INT 1
9031: PPUSH
9032: LD_INT 20
9034: NEG
9035: PPUSH
9036: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9040: LD_INT 69
9042: PPUSH
9043: LD_INT 20
9045: PPUSH
9046: LD_INT 1
9048: PPUSH
9049: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9053: LD_INT 190
9055: PPUSH
9056: LD_INT 31
9058: PPUSH
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 20
9064: NEG
9065: PPUSH
9066: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9070: LD_INT 190
9072: PPUSH
9073: LD_INT 31
9075: PPUSH
9076: LD_INT 1
9078: PPUSH
9079: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9083: LD_INT 69
9085: PPUSH
9086: LD_INT 20
9088: PPUSH
9089: CALL_OW 84
// Wait ( 0 0$02 ) ;
9093: LD_INT 70
9095: PPUSH
9096: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9100: LD_EXP 34
9104: PPUSH
9105: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9109: LD_EXP 37
9113: PUSH
9114: LD_EXP 37
9118: PPUSH
9119: LD_EXP 48
9123: PPUSH
9124: CALL_OW 296
9128: PUSH
9129: LD_INT 20
9131: LESS
9132: AND
9133: PUSH
9134: LD_EXP 37
9138: PPUSH
9139: CALL_OW 302
9143: AND
9144: IFFALSE 9234
// begin ComFree ( Lisa ) ;
9146: LD_EXP 37
9150: PPUSH
9151: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9155: LD_INT 35
9157: PPUSH
9158: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9162: LD_EXP 37
9166: PPUSH
9167: LD_EXP 48
9171: PPUSH
9172: CALL_OW 296
9176: PUSH
9177: LD_INT 7
9179: LESS
9180: IFFALSE 9155
// Say ( Lisa , D6-Lisa-1 ) ;
9182: LD_EXP 37
9186: PPUSH
9187: LD_STRING D6-Lisa-1
9189: PPUSH
9190: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9194: LD_EXP 37
9198: PPUSH
9199: LD_EXP 48
9203: PPUSH
9204: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9208: LD_EXP 48
9212: PPUSH
9213: LD_EXP 37
9217: PPUSH
9218: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9222: LD_EXP 48
9226: PPUSH
9227: LD_STRING D6-Frank-2
9229: PPUSH
9230: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9234: LD_EXP 44
9238: PUSH
9239: LD_EXP 44
9243: PPUSH
9244: LD_EXP 48
9248: PPUSH
9249: CALL_OW 296
9253: PUSH
9254: LD_INT 20
9256: LESS
9257: AND
9258: PUSH
9259: LD_EXP 44
9263: PPUSH
9264: CALL_OW 302
9268: AND
9269: IFFALSE 9450
// begin ComTurnUnit ( Lynch , JMM ) ;
9271: LD_EXP 44
9275: PPUSH
9276: LD_EXP 34
9280: PPUSH
9281: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9285: LD_EXP 48
9289: PPUSH
9290: LD_EXP 34
9294: PPUSH
9295: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9299: LD_EXP 44
9303: PPUSH
9304: LD_STRING D6-Sol1-2
9306: PPUSH
9307: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9311: LD_EXP 34
9315: PPUSH
9316: LD_STRING D6-JMM-2
9318: PPUSH
9319: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9323: LD_EXP 48
9327: PPUSH
9328: LD_STRING D6-Frank-3
9330: PPUSH
9331: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9335: LD_EXP 34
9339: PPUSH
9340: LD_STRING D6-JMM-3
9342: PPUSH
9343: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9347: LD_EXP 48
9351: PPUSH
9352: LD_STRING D6-Frank-4
9354: PPUSH
9355: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9359: LD_EXP 48
9363: PPUSH
9364: LD_STRING D6-Frank-4a
9366: PPUSH
9367: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9371: LD_EXP 34
9375: PPUSH
9376: LD_STRING D6-JMM-4
9378: PPUSH
9379: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9383: LD_EXP 48
9387: PPUSH
9388: LD_STRING D6-Frank-5
9390: PPUSH
9391: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9395: LD_EXP 37
9399: PUSH
9400: LD_EXP 37
9404: PPUSH
9405: CALL_OW 302
9409: AND
9410: IFFALSE 9424
// Say ( Lisa , D6-Lisa-5 ) ;
9412: LD_EXP 37
9416: PPUSH
9417: LD_STRING D6-Lisa-5
9419: PPUSH
9420: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9424: LD_EXP 48
9428: PPUSH
9429: LD_STRING D6-Frank-6
9431: PPUSH
9432: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9436: LD_EXP 34
9440: PPUSH
9441: LD_STRING D6-JMM-6
9443: PPUSH
9444: CALL_OW 88
// end else
9448: GO 9565
// begin ComTurnUnit ( Frank , JMM ) ;
9450: LD_EXP 48
9454: PPUSH
9455: LD_EXP 34
9459: PPUSH
9460: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9464: LD_EXP 48
9468: PPUSH
9469: LD_STRING D6-Frank-4
9471: PPUSH
9472: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9476: LD_EXP 48
9480: PPUSH
9481: LD_STRING D6-Frank-4a
9483: PPUSH
9484: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9488: LD_EXP 34
9492: PPUSH
9493: LD_STRING D6-JMM-4
9495: PPUSH
9496: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9500: LD_EXP 48
9504: PPUSH
9505: LD_STRING D6-Frank-5
9507: PPUSH
9508: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9512: LD_EXP 37
9516: PUSH
9517: LD_EXP 37
9521: PPUSH
9522: CALL_OW 302
9526: AND
9527: IFFALSE 9541
// Say ( Lisa , D6-Lisa-5 ) ;
9529: LD_EXP 37
9533: PPUSH
9534: LD_STRING D6-Lisa-5
9536: PPUSH
9537: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9541: LD_EXP 48
9545: PPUSH
9546: LD_STRING D6-Frank-6
9548: PPUSH
9549: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9553: LD_EXP 34
9557: PPUSH
9558: LD_STRING D6-JMM-6
9560: PPUSH
9561: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9565: LD_STRING Q1
9567: PPUSH
9568: CALL_OW 97
9572: PUSH
9573: LD_INT 1
9575: DOUBLE
9576: EQUAL
9577: IFTRUE 9581
9579: GO 9592
9581: POP
// frank_send_to_scout := true ; 2 :
9582: LD_ADDR_EXP 14
9586: PUSH
9587: LD_INT 1
9589: ST_TO_ADDR
9590: GO 9612
9592: LD_INT 2
9594: DOUBLE
9595: EQUAL
9596: IFTRUE 9600
9598: GO 9611
9600: POP
// frank_send_to_scout := false ; end ;
9601: LD_ADDR_EXP 14
9605: PUSH
9606: LD_INT 0
9608: ST_TO_ADDR
9609: GO 9612
9611: POP
// InGameOff ;
9612: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9616: LD_EXP 34
9620: PUSH
9621: LD_EXP 37
9625: PUSH
9626: LD_EXP 44
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: PPUSH
9636: CALL_OW 139
// if frank_send_to_scout then
9640: LD_EXP 14
9644: IFFALSE 9701
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9646: LD_EXP 48
9650: PPUSH
9651: LD_INT 130
9653: PPUSH
9654: LD_INT 123
9656: PPUSH
9657: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9661: LD_INT 35
9663: PPUSH
9664: CALL_OW 67
// until not See ( 1 , Frank ) ;
9668: LD_INT 1
9670: PPUSH
9671: LD_EXP 48
9675: PPUSH
9676: CALL_OW 292
9680: NOT
9681: IFFALSE 9661
// Wait ( 0 0$02 ) ;
9683: LD_INT 70
9685: PPUSH
9686: CALL_OW 67
// RemoveUnit ( Frank ) ;
9690: LD_EXP 48
9694: PPUSH
9695: CALL_OW 64
// end else
9699: GO 9713
// SetSide ( Frank , 1 ) ;
9701: LD_EXP 48
9705: PPUSH
9706: LD_INT 1
9708: PPUSH
9709: CALL_OW 235
// send_attack_on_cornel_base := true ;
9713: LD_ADDR_EXP 25
9717: PUSH
9718: LD_INT 1
9720: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9721: LD_INT 35
9723: PPUSH
9724: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9728: LD_ADDR_EXP 27
9732: PUSH
9733: LD_EXP 27
9737: PPUSH
9738: LD_STRING -
9740: PPUSH
9741: CALL 1101 0 2
9745: ST_TO_ADDR
// if debug then
9746: LD_EXP 1
9750: IFFALSE 9762
// debug_strings := time_to_prepare ;
9752: LD_ADDR_OWVAR 48
9756: PUSH
9757: LD_EXP 27
9761: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9762: LD_EXP 27
9766: PUSH
9767: LD_INT 0
9769: EQUAL
9770: IFFALSE 9721
// cornel_prepared := true ;
9772: LD_ADDR_EXP 11
9776: PUSH
9777: LD_INT 1
9779: ST_TO_ADDR
// end ;
9780: PPOPN 2
9782: END
// every 0 0$01 trigger cornel_prepared do
9783: LD_EXP 11
9787: IFFALSE 10033
9789: GO 9791
9791: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9792: LD_EXP 41
9796: PPUSH
9797: LD_STRING D3-Corn-1
9799: PPUSH
9800: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9804: LD_INT 35
9806: PPUSH
9807: CALL_OW 67
// until cornel_counter = 0 ;
9811: LD_EXP 10
9815: PUSH
9816: LD_INT 0
9818: EQUAL
9819: IFFALSE 9804
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9821: LD_EXP 41
9825: PPUSH
9826: LD_STRING D3a-Corn-1
9828: PPUSH
9829: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9833: LD_EXP 34
9837: PPUSH
9838: LD_STRING D3a-JMM-1
9840: PPUSH
9841: CALL_OW 88
// end_mission_allowed := true ;
9845: LD_ADDR_EXP 20
9849: PUSH
9850: LD_INT 1
9852: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9853: LD_STRING M2
9855: PPUSH
9856: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9860: LD_INT 9
9862: PPUSH
9863: LD_INT 1
9865: PPUSH
9866: CALL_OW 424
// Wait ( 0 0$05 ) ;
9870: LD_INT 175
9872: PPUSH
9873: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9877: LD_EXP 41
9881: PPUSH
9882: LD_STRING D3a-Corn-2
9884: PPUSH
9885: CALL_OW 94
// cornel_attack := true ;
9889: LD_ADDR_EXP 9
9893: PUSH
9894: LD_INT 1
9896: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9897: LD_INT 105
9899: PPUSH
9900: CALL_OW 67
// AddMoreTanks ( ) ;
9904: CALL 4782 0 0
// if frank_send_to_scout then
9908: LD_EXP 14
9912: IFFALSE 10033
// begin InitHc ;
9914: CALL_OW 19
// InitUc ;
9918: CALL_OW 18
// uc_side := 8 ;
9922: LD_ADDR_OWVAR 20
9926: PUSH
9927: LD_INT 8
9929: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9930: LD_ADDR_EXP 48
9934: PUSH
9935: LD_STRING Frank
9937: PPUSH
9938: LD_INT 0
9940: PPUSH
9941: CALL 458 0 2
9945: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9946: LD_EXP 48
9950: PPUSH
9951: LD_INT 6
9953: PPUSH
9954: LD_INT 9
9956: PPUSH
9957: LD_INT 0
9959: PPUSH
9960: CALL_OW 48
// ComCrawl ( Frank ) ;
9964: LD_EXP 48
9968: PPUSH
9969: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9973: LD_INT 35
9975: PPUSH
9976: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9980: LD_EXP 34
9984: PPUSH
9985: LD_EXP 48
9989: PPUSH
9990: CALL_OW 296
9994: PUSH
9995: LD_INT 9
9997: LESS
9998: IFFALSE 9973
// SetSide ( Frank , 1 ) ;
10000: LD_EXP 48
10004: PPUSH
10005: LD_INT 1
10007: PPUSH
10008: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10012: LD_EXP 48
10016: PPUSH
10017: LD_STRING D6a-Frank-1
10019: PPUSH
10020: CALL_OW 88
// ComWalk ( Frank ) ;
10024: LD_EXP 48
10028: PPUSH
10029: CALL_OW 138
// end ; end ;
10033: END
// every 0 0$01 trigger solar_builded do
10034: LD_EXP 13
10038: IFFALSE 10142
10040: GO 10042
10042: DISABLE
// begin Wait ( 0 0$02 ) ;
10043: LD_INT 70
10045: PPUSH
10046: CALL_OW 67
// DialogueOn ;
10050: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10054: LD_EXP 34
10058: PPUSH
10059: LD_STRING D2b-JMM-1
10061: PPUSH
10062: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10066: LD_EXP 45
10070: PUSH
10071: LD_EXP 45
10075: PPUSH
10076: CALL_OW 302
10080: AND
10081: IFFALSE 10131
// begin Say ( Walker , D2b-Sci1-1 ) ;
10083: LD_EXP 45
10087: PPUSH
10088: LD_STRING D2b-Sci1-1
10090: PPUSH
10091: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10095: LD_EXP 34
10099: PPUSH
10100: LD_STRING D2b-JMM-2
10102: PPUSH
10103: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10107: LD_EXP 45
10111: PPUSH
10112: LD_STRING D2b-Sci1-2
10114: PPUSH
10115: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10119: LD_EXP 34
10123: PPUSH
10124: LD_STRING D2b-JMM-3
10126: PPUSH
10127: CALL_OW 88
// end ; DialogueOff ;
10131: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10135: LD_STRING MOutSol
10137: PPUSH
10138: CALL_OW 337
// end ;
10142: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10143: LD_EXP 13
10147: PUSH
10148: LD_EXP 34
10152: PPUSH
10153: CALL_OW 302
10157: AND
10158: PUSH
10159: LD_EXP 34
10163: PPUSH
10164: CALL 935 0 1
10168: AND
10169: PUSH
10170: LD_EXP 15
10174: NOT
10175: AND
10176: IFFALSE 10247
10178: GO 10180
10180: DISABLE
10181: LD_INT 0
10183: PPUSH
// begin jmm_in_veh := true ;
10184: LD_ADDR_EXP 15
10188: PUSH
10189: LD_INT 1
10191: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10192: LD_ADDR_VAR 0 1
10196: PUSH
10197: LD_INT 0
10199: PPUSH
10200: LD_INT 1
10202: PPUSH
10203: CALL_OW 12
10207: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10208: LD_INT 70
10210: PPUSH
10211: CALL_OW 67
// if i then
10215: LD_VAR 0 1
10219: IFFALSE 10235
// Say ( JMM , D2c-JMM-1 ) else
10221: LD_EXP 34
10225: PPUSH
10226: LD_STRING D2c-JMM-1
10228: PPUSH
10229: CALL_OW 88
10233: GO 10247
// Say ( JMM , D2c-JMM-1a ) ;
10235: LD_EXP 34
10239: PPUSH
10240: LD_STRING D2c-JMM-1a
10242: PPUSH
10243: CALL_OW 88
// end ;
10247: PPOPN 1
10249: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10250: LD_EXP 13
10254: PUSH
10255: LD_EXP 35
10259: PPUSH
10260: CALL_OW 302
10264: AND
10265: PUSH
10266: LD_EXP 35
10270: PPUSH
10271: CALL 935 0 1
10275: AND
10276: PUSH
10277: LD_EXP 16
10281: NOT
10282: AND
10283: IFFALSE 10315
10285: GO 10287
10287: DISABLE
// begin bobby_in_veh := true ;
10288: LD_ADDR_EXP 16
10292: PUSH
10293: LD_INT 1
10295: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10296: LD_INT 70
10298: PPUSH
10299: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10303: LD_EXP 35
10307: PPUSH
10308: LD_STRING D2c-Bobby-1
10310: PPUSH
10311: CALL_OW 88
10315: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10316: LD_EXP 13
10320: PUSH
10321: LD_EXP 37
10325: PPUSH
10326: CALL_OW 302
10330: AND
10331: PUSH
10332: LD_EXP 37
10336: PPUSH
10337: CALL 935 0 1
10341: AND
10342: PUSH
10343: LD_EXP 18
10347: NOT
10348: AND
10349: IFFALSE 10381
10351: GO 10353
10353: DISABLE
// begin lisa_in_veh := true ;
10354: LD_ADDR_EXP 18
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10362: LD_INT 70
10364: PPUSH
10365: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10369: LD_EXP 37
10373: PPUSH
10374: LD_STRING D2c-Lisa-1
10376: PPUSH
10377: CALL_OW 88
10381: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10382: LD_EXP 13
10386: PUSH
10387: LD_EXP 36
10391: PPUSH
10392: CALL_OW 302
10396: AND
10397: PUSH
10398: LD_EXP 36
10402: PPUSH
10403: CALL 935 0 1
10407: AND
10408: PUSH
10409: LD_EXP 17
10413: NOT
10414: AND
10415: IFFALSE 10486
10417: GO 10419
10419: DISABLE
10420: LD_INT 0
10422: PPUSH
// begin cyrus_in_veh := true ;
10423: LD_ADDR_EXP 17
10427: PUSH
10428: LD_INT 1
10430: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10431: LD_ADDR_VAR 0 1
10435: PUSH
10436: LD_INT 0
10438: PPUSH
10439: LD_INT 1
10441: PPUSH
10442: CALL_OW 12
10446: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10447: LD_INT 70
10449: PPUSH
10450: CALL_OW 67
// if i then
10454: LD_VAR 0 1
10458: IFFALSE 10474
// Say ( Cyrus , D2c-Cyrus-1 ) else
10460: LD_EXP 36
10464: PPUSH
10465: LD_STRING D2c-Cyrus-1
10467: PPUSH
10468: CALL_OW 88
10472: GO 10486
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10474: LD_EXP 36
10478: PPUSH
10479: LD_STRING D2c-Cyrus-1a
10481: PPUSH
10482: CALL_OW 88
// end ;
10486: PPOPN 1
10488: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10489: LD_EXP 41
10493: PPUSH
10494: LD_INT 16
10496: PPUSH
10497: CALL_OW 308
10501: IFFALSE 10757
10503: GO 10505
10505: DISABLE
10506: LD_INT 0
10508: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10509: LD_INT 3
10511: PPUSH
10512: LD_EXP 41
10516: PPUSH
10517: CALL_OW 471
// send_attack_on_cornel := true ;
10521: LD_ADDR_EXP 30
10525: PUSH
10526: LD_INT 1
10528: ST_TO_ADDR
// if ru_vehicles then
10529: LD_EXP 53
10533: IFFALSE 10567
// for i in ru_vehicles do
10535: LD_ADDR_VAR 0 1
10539: PUSH
10540: LD_EXP 53
10544: PUSH
10545: FOR_IN
10546: IFFALSE 10565
// ComAgressiveMove ( i , 215 , 69 ) ;
10548: LD_VAR 0 1
10552: PPUSH
10553: LD_INT 215
10555: PPUSH
10556: LD_INT 69
10558: PPUSH
10559: CALL_OW 114
10563: GO 10545
10565: POP
10566: POP
// if ru_patrol then
10567: LD_EXP 50
10571: IFFALSE 10605
// for i in ru_patrol do
10573: LD_ADDR_VAR 0 1
10577: PUSH
10578: LD_EXP 50
10582: PUSH
10583: FOR_IN
10584: IFFALSE 10603
// ComAgressiveMove ( i , 215 , 69 ) ;
10586: LD_VAR 0 1
10590: PPUSH
10591: LD_INT 215
10593: PPUSH
10594: LD_INT 69
10596: PPUSH
10597: CALL_OW 114
10601: GO 10583
10603: POP
10604: POP
// if frank_send_to_scout then
10605: LD_EXP 14
10609: IFFALSE 10623
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10611: LD_EXP 48
10615: PPUSH
10616: LD_STRING D3b-Frank-1
10618: PPUSH
10619: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10623: LD_INT 105
10625: PPUSH
10626: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10630: LD_EXP 41
10634: PPUSH
10635: LD_STRING D4-Corn-1
10637: PPUSH
10638: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10642: LD_INT 35
10644: PPUSH
10645: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10649: LD_INT 22
10651: PUSH
10652: LD_INT 4
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: LD_INT 21
10661: PUSH
10662: LD_INT 1
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: PUSH
10669: LD_INT 50
10671: PUSH
10672: EMPTY
10673: LIST
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: LIST
10679: PPUSH
10680: CALL_OW 69
10684: PUSH
10685: LD_INT 6
10687: LESS
10688: IFFALSE 10642
// SayRadio ( Cornel , D5-Corn-1 ) ;
10690: LD_EXP 41
10694: PPUSH
10695: LD_STRING D5-Corn-1
10697: PPUSH
10698: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
10702: LD_EXP 41
10706: PPUSH
10707: LD_EXP 2
10711: PUSH
10712: LD_STRING Cornel
10714: STR
10715: PPUSH
10716: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10720: LD_INT 4
10722: PPUSH
10723: LD_INT 8
10725: PPUSH
10726: CALL_OW 343
// Wait ( 0 0$01 ) ;
10730: LD_INT 35
10732: PPUSH
10733: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10737: LD_INT 3
10739: PPUSH
10740: LD_EXP 41
10744: PPUSH
10745: CALL_OW 472
// send_attack_on_cornel := false ;
10749: LD_ADDR_EXP 30
10753: PUSH
10754: LD_INT 0
10756: ST_TO_ADDR
// end ;
10757: PPOPN 1
10759: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10760: LD_INT 9
10762: PPUSH
10763: LD_INT 22
10765: PUSH
10766: LD_INT 1
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PPUSH
10773: CALL_OW 70
10777: PUSH
10778: LD_EXP 31
10782: OR
10783: IFFALSE 10965
10785: GO 10787
10787: DISABLE
10788: LD_INT 0
10790: PPUSH
10791: PPUSH
// begin enable ;
10792: ENABLE
// if not jmm_on_west then
10793: LD_EXP 5
10797: NOT
10798: IFFALSE 10809
// begin YouLost ( 4 ) ;
10800: LD_STRING 4
10802: PPUSH
10803: CALL_OW 104
// exit ;
10807: GO 10965
// end ; if not game_end then
10809: LD_EXP 31
10813: NOT
10814: IFFALSE 10824
// game_end := true ;
10816: LD_ADDR_EXP 31
10820: PUSH
10821: LD_INT 1
10823: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10824: LD_ADDR_VAR 0 2
10828: PUSH
10829: LD_INT 9
10831: PPUSH
10832: LD_INT 22
10834: PUSH
10835: LD_INT 1
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 70
10846: ST_TO_ADDR
// if not filter then
10847: LD_VAR 0 2
10851: NOT
10852: IFFALSE 10856
// exit ;
10854: GO 10965
// for i in filter do
10856: LD_ADDR_VAR 0 1
10860: PUSH
10861: LD_VAR 0 2
10865: PUSH
10866: FOR_IN
10867: IFFALSE 10963
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10869: LD_VAR 0 1
10873: PPUSH
10874: CALL_OW 302
10878: PUSH
10879: LD_VAR 0 1
10883: PPUSH
10884: CALL_OW 247
10888: PUSH
10889: LD_INT 2
10891: EQUAL
10892: AND
10893: IFFALSE 10926
// begin veh_on_meta := true ;
10895: LD_ADDR_EXP 26
10899: PUSH
10900: LD_INT 1
10902: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
10903: LD_VAR 0 1
10907: PPUSH
10908: CALL_OW 311
10912: PPUSH
10913: CALL 10968 0 1
// RemoveUnit ( i ) ;
10917: LD_VAR 0 1
10921: PPUSH
10922: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
10926: LD_VAR 0 1
10930: PPUSH
10931: CALL_OW 302
10935: PUSH
10936: LD_VAR 0 1
10940: PPUSH
10941: CALL_OW 247
10945: PUSH
10946: LD_INT 1
10948: EQUAL
10949: AND
10950: IFFALSE 10961
// Save ( i ) ;
10952: LD_VAR 0 1
10956: PPUSH
10957: CALL 10968 0 1
// end ;
10961: GO 10866
10963: POP
10964: POP
// end ;
10965: PPOPN 2
10967: END
// export function Save ( i ) ; begin
10968: LD_INT 0
10970: PPUSH
// if i = JMM then
10971: LD_VAR 0 1
10975: PUSH
10976: LD_EXP 34
10980: EQUAL
10981: IFFALSE 11103
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10983: LD_EXP 23
10987: PUSH
10988: LD_INT 22
10990: PUSH
10991: LD_INT 1
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: PUSH
10998: LD_INT 21
11000: PUSH
11001: LD_INT 1
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PPUSH
11012: CALL_OW 69
11016: PUSH
11017: LD_INT 1
11019: GREATER
11020: AND
11021: IFFALSE 11078
// begin show_query := false ;
11023: LD_ADDR_EXP 23
11027: PUSH
11028: LD_INT 0
11030: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11031: LD_STRING Q2
11033: PPUSH
11034: CALL_OW 97
11038: PUSH
11039: LD_INT 1
11041: DOUBLE
11042: EQUAL
11043: IFTRUE 11047
11045: GO 11058
11047: POP
// wait_for_them := true ; 2 :
11048: LD_ADDR_EXP 24
11052: PUSH
11053: LD_INT 1
11055: ST_TO_ADDR
11056: GO 11078
11058: LD_INT 2
11060: DOUBLE
11061: EQUAL
11062: IFTRUE 11066
11064: GO 11077
11066: POP
// wait_for_them := false ; end ;
11067: LD_ADDR_EXP 24
11071: PUSH
11072: LD_INT 0
11074: ST_TO_ADDR
11075: GO 11078
11077: POP
// end ; save_group := save_group ^ JMM ;
11078: LD_ADDR_EXP 22
11082: PUSH
11083: LD_EXP 22
11087: PUSH
11088: LD_EXP 34
11092: ADD
11093: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11094: LD_EXP 34
11098: PPUSH
11099: CALL_OW 64
// end ; if i = Lisa then
11103: LD_VAR 0 1
11107: PUSH
11108: LD_EXP 37
11112: EQUAL
11113: IFFALSE 11140
// begin save_group := save_group ^ Lisa ;
11115: LD_ADDR_EXP 22
11119: PUSH
11120: LD_EXP 22
11124: PUSH
11125: LD_EXP 37
11129: ADD
11130: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11131: LD_EXP 37
11135: PPUSH
11136: CALL_OW 64
// end ; if i = Bobby then
11140: LD_VAR 0 1
11144: PUSH
11145: LD_EXP 35
11149: EQUAL
11150: IFFALSE 11177
// begin save_group := save_group ^ Bobby ;
11152: LD_ADDR_EXP 22
11156: PUSH
11157: LD_EXP 22
11161: PUSH
11162: LD_EXP 35
11166: ADD
11167: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11168: LD_EXP 35
11172: PPUSH
11173: CALL_OW 64
// end ; if i = Cyrus then
11177: LD_VAR 0 1
11181: PUSH
11182: LD_EXP 36
11186: EQUAL
11187: IFFALSE 11214
// begin save_group := save_group ^ Cyrus ;
11189: LD_ADDR_EXP 22
11193: PUSH
11194: LD_EXP 22
11198: PUSH
11199: LD_EXP 36
11203: ADD
11204: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11205: LD_EXP 36
11209: PPUSH
11210: CALL_OW 64
// end ; if i = Khatam then
11214: LD_VAR 0 1
11218: PUSH
11219: LD_EXP 38
11223: EQUAL
11224: IFFALSE 11251
// begin save_group := save_group ^ Khatam ;
11226: LD_ADDR_EXP 22
11230: PUSH
11231: LD_EXP 22
11235: PUSH
11236: LD_EXP 38
11240: ADD
11241: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11242: LD_EXP 38
11246: PPUSH
11247: CALL_OW 64
// end ; if i = Frank then
11251: LD_VAR 0 1
11255: PUSH
11256: LD_EXP 48
11260: EQUAL
11261: IFFALSE 11288
// begin save_group := save_group ^ Frank ;
11263: LD_ADDR_EXP 22
11267: PUSH
11268: LD_EXP 22
11272: PUSH
11273: LD_EXP 48
11277: ADD
11278: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11279: LD_EXP 48
11283: PPUSH
11284: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11288: LD_VAR 0 1
11292: PPUSH
11293: CALL_OW 302
11297: PUSH
11298: LD_VAR 0 1
11302: PPUSH
11303: CALL_OW 247
11307: PUSH
11308: LD_INT 1
11310: EQUAL
11311: AND
11312: PUSH
11313: LD_VAR 0 1
11317: PUSH
11318: LD_EXP 22
11322: IN
11323: NOT
11324: AND
11325: IFFALSE 11352
// begin save_others := save_others ^ i ;
11327: LD_ADDR_EXP 21
11331: PUSH
11332: LD_EXP 21
11336: PUSH
11337: LD_VAR 0 1
11341: ADD
11342: ST_TO_ADDR
// RemoveUnit ( i ) ;
11343: LD_VAR 0 1
11347: PPUSH
11348: CALL_OW 64
// end ; end ;
11352: LD_VAR 0 2
11356: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11357: LD_EXP 23
11361: NOT
11362: PUSH
11363: LD_EXP 24
11367: NOT
11368: AND
11369: PUSH
11370: LD_INT 22
11372: PUSH
11373: LD_INT 1
11375: PUSH
11376: EMPTY
11377: LIST
11378: LIST
11379: PUSH
11380: LD_INT 21
11382: PUSH
11383: LD_INT 1
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PPUSH
11394: CALL_OW 69
11398: PUSH
11399: LD_INT 0
11401: EQUAL
11402: OR
11403: IFFALSE 11412
11405: GO 11407
11407: DISABLE
// EndMission ;
11408: CALL 11413 0 0
11412: END
// export function EndMission ; var i ; begin
11413: LD_INT 0
11415: PPUSH
11416: PPUSH
// Wait ( 0 0$02 ) ;
11417: LD_INT 70
11419: PPUSH
11420: CALL_OW 67
// if solar_builded then
11424: LD_EXP 13
11428: IFFALSE 11442
// AddMedal ( Solar1 , 1 ) else
11430: LD_STRING Solar1
11432: PPUSH
11433: LD_INT 1
11435: PPUSH
11436: CALL_OW 101
11440: GO 11453
// AddMedal ( Solar1 , - 1 ) ;
11442: LD_STRING Solar1
11444: PPUSH
11445: LD_INT 1
11447: NEG
11448: PPUSH
11449: CALL_OW 101
// if veh_on_meta then
11453: LD_EXP 26
11457: IFFALSE 11471
// AddMedal ( Solar2 , 1 ) else
11459: LD_STRING Solar2
11461: PPUSH
11462: LD_INT 1
11464: PPUSH
11465: CALL_OW 101
11469: GO 11501
// if solar_builded then
11471: LD_EXP 13
11475: IFFALSE 11490
// AddMedal ( Solar2 , - 1 ) else
11477: LD_STRING Solar2
11479: PPUSH
11480: LD_INT 1
11482: NEG
11483: PPUSH
11484: CALL_OW 101
11488: GO 11501
// AddMedal ( Solar2 , - 2 ) ;
11490: LD_STRING Solar2
11492: PPUSH
11493: LD_INT 2
11495: NEG
11496: PPUSH
11497: CALL_OW 101
// if lose_counter = 0 then
11501: LD_EXP 32
11505: PUSH
11506: LD_INT 0
11508: EQUAL
11509: IFFALSE 11523
// AddMedal ( No , 1 ) else
11511: LD_STRING No
11513: PPUSH
11514: LD_INT 1
11516: PPUSH
11517: CALL_OW 101
11521: GO 11567
// if lose_counter > 0 and lose_counter < 4 then
11523: LD_EXP 32
11527: PUSH
11528: LD_INT 0
11530: GREATER
11531: PUSH
11532: LD_EXP 32
11536: PUSH
11537: LD_INT 4
11539: LESS
11540: AND
11541: IFFALSE 11556
// AddMedal ( No , - 1 ) else
11543: LD_STRING No
11545: PPUSH
11546: LD_INT 1
11548: NEG
11549: PPUSH
11550: CALL_OW 101
11554: GO 11567
// AddMedal ( UpTo4 , - 1 ) ;
11556: LD_STRING UpTo4
11558: PPUSH
11559: LD_INT 1
11561: NEG
11562: PPUSH
11563: CALL_OW 101
// GiveMedals ( MAIN ) ;
11567: LD_STRING MAIN
11569: PPUSH
11570: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11574: LD_EXP 49
11578: PPUSH
11579: CALL_OW 301
11583: IFFALSE 11623
// for i in save_group ^ save_others do
11585: LD_ADDR_VAR 0 2
11589: PUSH
11590: LD_EXP 22
11594: PUSH
11595: LD_EXP 21
11599: ADD
11600: PUSH
11601: FOR_IN
11602: IFFALSE 11621
// AddExperience ( i , skill_combat , 1500 ) ;
11604: LD_VAR 0 2
11608: PPUSH
11609: LD_INT 1
11611: PPUSH
11612: LD_INT 1500
11614: PPUSH
11615: CALL_OW 492
11619: GO 11601
11621: POP
11622: POP
// RewardPeople ( save_group ^ save_others ) ;
11623: LD_EXP 22
11627: PUSH
11628: LD_EXP 21
11632: ADD
11633: PPUSH
11634: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11638: LD_EXP 34
11642: PPUSH
11643: LD_EXP 2
11647: PUSH
11648: LD_STRING JMM
11650: STR
11651: PPUSH
11652: CALL_OW 38
// if Bobby in save_group then
11656: LD_EXP 35
11660: PUSH
11661: LD_EXP 22
11665: IN
11666: IFFALSE 11686
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11668: LD_EXP 35
11672: PPUSH
11673: LD_EXP 2
11677: PUSH
11678: LD_STRING Bobby
11680: STR
11681: PPUSH
11682: CALL_OW 38
// if Cyrus in save_group then
11686: LD_EXP 36
11690: PUSH
11691: LD_EXP 22
11695: IN
11696: IFFALSE 11716
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11698: LD_EXP 36
11702: PPUSH
11703: LD_EXP 2
11707: PUSH
11708: LD_STRING Cyrus
11710: STR
11711: PPUSH
11712: CALL_OW 38
// if Lisa in save_group then
11716: LD_EXP 37
11720: PUSH
11721: LD_EXP 22
11725: IN
11726: IFFALSE 11746
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11728: LD_EXP 37
11732: PPUSH
11733: LD_EXP 2
11737: PUSH
11738: LD_STRING Lisa
11740: STR
11741: PPUSH
11742: CALL_OW 38
// if Frank in save_group then
11746: LD_EXP 48
11750: PUSH
11751: LD_EXP 22
11755: IN
11756: IFFALSE 11776
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11758: LD_EXP 48
11762: PPUSH
11763: LD_EXP 2
11767: PUSH
11768: LD_STRING Frank
11770: STR
11771: PPUSH
11772: CALL_OW 38
// if Khatam in save_group then
11776: LD_EXP 38
11780: PUSH
11781: LD_EXP 22
11785: IN
11786: IFFALSE 11806
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11788: LD_EXP 38
11792: PPUSH
11793: LD_EXP 2
11797: PUSH
11798: LD_STRING Khatam
11800: STR
11801: PPUSH
11802: CALL_OW 38
// if save_others then
11806: LD_EXP 21
11810: IFFALSE 11824
// SaveCharacters ( save_others , 03_others ) ;
11812: LD_EXP 21
11816: PPUSH
11817: LD_STRING 03_others
11819: PPUSH
11820: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
11824: LD_EXP 42
11828: PUSH
11829: LD_EXP 42
11833: PPUSH
11834: CALL_OW 302
11838: AND
11839: IFFALSE 11851
// begin ResetFog ;
11841: CALL_OW 335
// DisplayEndingScene ;
11845: CALL 11873 0 0
// end else
11849: GO 11864
// DeleteCharacters ( mission_prefix & Cornel ) ;
11851: LD_EXP 2
11855: PUSH
11856: LD_STRING Cornel
11858: STR
11859: PPUSH
11860: CALL_OW 40
// YouWin ;
11864: CALL_OW 103
// end ;
11868: LD_VAR 0 1
11872: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11873: LD_INT 0
11875: PPUSH
11876: PPUSH
11877: PPUSH
11878: PPUSH
11879: PPUSH
11880: PPUSH
// InGameOn ;
11881: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11885: LD_INT 208
11887: PPUSH
11888: LD_INT 62
11890: PPUSH
11891: LD_INT 1
11893: PPUSH
11894: LD_INT 10
11896: NEG
11897: PPUSH
11898: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11902: LD_INT 208
11904: PPUSH
11905: LD_INT 62
11907: PPUSH
11908: LD_INT 1
11910: PPUSH
11911: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11915: LD_ADDR_VAR 0 3
11919: PUSH
11920: LD_INT 22
11922: PUSH
11923: LD_INT 3
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: PUSH
11930: LD_INT 2
11932: PUSH
11933: LD_INT 21
11935: PUSH
11936: LD_INT 2
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: PUSH
11943: LD_INT 21
11945: PUSH
11946: LD_INT 1
11948: PUSH
11949: EMPTY
11950: LIST
11951: LIST
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PPUSH
11962: CALL_OW 69
11966: ST_TO_ADDR
// if filter then
11967: LD_VAR 0 3
11971: IFFALSE 11999
// for i in filter do
11973: LD_ADDR_VAR 0 2
11977: PUSH
11978: LD_VAR 0 3
11982: PUSH
11983: FOR_IN
11984: IFFALSE 11997
// RemoveUnit ( i ) ;
11986: LD_VAR 0 2
11990: PPUSH
11991: CALL_OW 64
11995: GO 11983
11997: POP
11998: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11999: LD_ADDR_VAR 0 3
12003: PUSH
12004: LD_INT 22
12006: PUSH
12007: LD_INT 4
12009: PUSH
12010: EMPTY
12011: LIST
12012: LIST
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 1
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PPUSH
12028: CALL_OW 69
12032: ST_TO_ADDR
// if filter then
12033: LD_VAR 0 3
12037: IFFALSE 12068
// for i in filter do
12039: LD_ADDR_VAR 0 2
12043: PUSH
12044: LD_VAR 0 3
12048: PUSH
12049: FOR_IN
12050: IFFALSE 12066
// SetLives ( i , 0 ) ;
12052: LD_VAR 0 2
12056: PPUSH
12057: LD_INT 0
12059: PPUSH
12060: CALL_OW 234
12064: GO 12049
12066: POP
12067: POP
// uc_side := 4 ;
12068: LD_ADDR_OWVAR 20
12072: PUSH
12073: LD_INT 4
12075: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12076: LD_ADDR_VAR 0 4
12080: PUSH
12081: LD_STRING Cornell
12083: PPUSH
12084: LD_INT 0
12086: PPUSH
12087: CALL 458 0 2
12091: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12092: LD_VAR 0 4
12096: PPUSH
12097: LD_INT 208
12099: PPUSH
12100: LD_INT 62
12102: PPUSH
12103: LD_INT 0
12105: PPUSH
12106: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12110: LD_VAR 0 4
12114: PPUSH
12115: LD_INT 100
12117: PPUSH
12118: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12122: LD_INT 3
12124: PPUSH
12125: LD_VAR 0 4
12129: PPUSH
12130: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12134: LD_INT 4
12136: PPUSH
12137: LD_INT 3
12139: PPUSH
12140: LD_INT 1
12142: PPUSH
12143: LD_INT 1
12145: PPUSH
12146: CALL_OW 80
// uc_side := 3 ;
12150: LD_ADDR_OWVAR 20
12154: PUSH
12155: LD_INT 3
12157: ST_TO_ADDR
// uc_nation := 3 ;
12158: LD_ADDR_OWVAR 21
12162: PUSH
12163: LD_INT 3
12165: ST_TO_ADDR
// InitHc ;
12166: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12170: LD_ADDR_VAR 0 5
12174: PUSH
12175: LD_STRING Mikhail
12177: PPUSH
12178: LD_INT 0
12180: PPUSH
12181: CALL 458 0 2
12185: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12186: LD_INT 1
12188: PPUSH
12189: LD_INT 1
12191: PPUSH
12192: LD_INT 0
12194: PPUSH
12195: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12199: LD_ADDR_VAR 0 6
12203: PUSH
12204: LD_VAR 0 6
12208: PUSH
12209: CALL_OW 44
12213: ADD
12214: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12215: LD_ADDR_VAR 0 6
12219: PUSH
12220: LD_VAR 0 6
12224: PUSH
12225: CALL_OW 44
12229: ADD
12230: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12231: LD_INT 2
12233: PPUSH
12234: LD_INT 4
12236: PPUSH
12237: LD_INT 0
12239: PPUSH
12240: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12244: LD_ADDR_VAR 0 6
12248: PUSH
12249: LD_VAR 0 6
12253: PUSH
12254: CALL_OW 44
12258: ADD
12259: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12260: LD_VAR 0 5
12264: PPUSH
12265: LD_INT 17
12267: PPUSH
12268: LD_INT 0
12270: PPUSH
12271: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12275: LD_VAR 0 5
12279: PPUSH
12280: LD_INT 210
12282: PPUSH
12283: LD_INT 63
12285: PPUSH
12286: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12290: LD_VAR 0 5
12294: PPUSH
12295: LD_INT 208
12297: PPUSH
12298: LD_INT 62
12300: PPUSH
12301: CALL_OW 178
// for i in fake_russians do
12305: LD_ADDR_VAR 0 2
12309: PUSH
12310: LD_VAR 0 6
12314: PUSH
12315: FOR_IN
12316: IFFALSE 12394
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12318: LD_VAR 0 2
12322: PPUSH
12323: LD_INT 17
12325: PPUSH
12326: LD_INT 0
12328: PPUSH
12329: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12333: LD_VAR 0 2
12337: PPUSH
12338: LD_INT 215
12340: PPUSH
12341: LD_INT 67
12343: PPUSH
12344: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_INT 208
12355: PPUSH
12356: LD_INT 62
12358: PPUSH
12359: CALL_OW 178
// if GetClass ( i ) = 4 then
12363: LD_VAR 0 2
12367: PPUSH
12368: CALL_OW 257
12372: PUSH
12373: LD_INT 4
12375: EQUAL
12376: IFFALSE 12392
// ComHeal ( i , fake_cornel ) ;
12378: LD_VAR 0 2
12382: PPUSH
12383: LD_VAR 0 4
12387: PPUSH
12388: CALL_OW 128
// end ;
12392: GO 12315
12394: POP
12395: POP
// Wait ( 0 0$01 ) ;
12396: LD_INT 35
12398: PPUSH
12399: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12403: LD_INT 208
12405: PPUSH
12406: LD_INT 62
12408: PPUSH
12409: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12413: LD_INT 208
12415: PPUSH
12416: LD_INT 62
12418: PPUSH
12419: LD_INT 1
12421: PPUSH
12422: LD_INT 10
12424: NEG
12425: PPUSH
12426: CALL_OW 330
// Wait ( 0 0$15 ) ;
12430: LD_INT 525
12432: PPUSH
12433: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12437: LD_INT 208
12439: PPUSH
12440: LD_INT 62
12442: PPUSH
12443: LD_INT 1
12445: PPUSH
12446: CALL_OW 331
// ResetFog ;
12450: CALL_OW 335
// InGameOff ;
12454: CALL_OW 9
// end ;
12458: LD_VAR 0 1
12462: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
12463: LD_INT 10
12465: PPUSH
12466: LD_INT 22
12468: PUSH
12469: LD_INT 1
12471: PUSH
12472: EMPTY
12473: LIST
12474: LIST
12475: PPUSH
12476: CALL_OW 70
12480: PUSH
12481: LD_EXP 41
12485: PPUSH
12486: CALL_OW 302
12490: AND
12491: PUSH
12492: LD_INT 22
12494: PUSH
12495: LD_INT 1
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PPUSH
12502: CALL_OW 69
12506: PPUSH
12507: LD_EXP 41
12511: PPUSH
12512: CALL_OW 74
12516: PPUSH
12517: LD_EXP 41
12521: PPUSH
12522: CALL_OW 296
12526: PUSH
12527: LD_INT 30
12529: LESS
12530: OR
12531: IFFALSE 12582
12533: GO 12535
12535: DISABLE
// begin enable ;
12536: ENABLE
// powell_warn := powell_warn + 1 ;
12537: LD_ADDR_EXP 33
12541: PUSH
12542: LD_EXP 33
12546: PUSH
12547: LD_INT 1
12549: PLUS
12550: ST_TO_ADDR
// if powell_warn = 3 then
12551: LD_EXP 33
12555: PUSH
12556: LD_INT 3
12558: EQUAL
12559: IFFALSE 12570
// begin YouLost ( 5 ) ;
12561: LD_STRING 5
12563: PPUSH
12564: CALL_OW 104
// exit ;
12568: GO 12582
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
12570: LD_EXP 43
12574: PPUSH
12575: LD_STRING DWarn-Pow-1
12577: PPUSH
12578: CALL_OW 94
// end ; end_of_file
12582: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12583: LD_EXP 8
12587: IFFALSE 13923
12589: GO 12591
12591: DISABLE
12592: LD_INT 0
12594: PPUSH
12595: PPUSH
12596: PPUSH
12597: PPUSH
12598: PPUSH
12599: PPUSH
12600: PPUSH
12601: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12602: LD_EXP 41
12606: PUSH
12607: LD_EXP 42
12611: ADD
12612: PUSH
12613: LD_EXP 6
12617: ADD
12618: PPUSH
12619: LD_INT 250
12621: PPUSH
12622: LD_INT 120
12624: PPUSH
12625: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_EXP 6
12638: PPUSH
12639: LD_INT 25
12641: PUSH
12642: LD_INT 2
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL_OW 72
12653: PUSH
12654: LD_EXP 42
12658: PUSH
12659: EMPTY
12660: LIST
12661: DIFF
12662: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12663: LD_ADDR_VAR 0 3
12667: PUSH
12668: LD_EXP 6
12672: PPUSH
12673: LD_INT 21
12675: PUSH
12676: LD_INT 1
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: PPUSH
12683: CALL_OW 72
12687: ST_TO_ADDR
// if not has_eng then
12688: LD_VAR 0 2
12692: NOT
12693: IFFALSE 12776
// begin uc_side := 4 ;
12695: LD_ADDR_OWVAR 20
12699: PUSH
12700: LD_INT 4
12702: ST_TO_ADDR
// uc_nation := 1 ;
12703: LD_ADDR_OWVAR 21
12707: PUSH
12708: LD_INT 1
12710: ST_TO_ADDR
// bc_type := b_depot ;
12711: LD_ADDR_OWVAR 42
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// bc_level := 2 ;
12719: LD_ADDR_OWVAR 43
12723: PUSH
12724: LD_INT 2
12726: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12727: LD_ADDR_VAR 0 4
12731: PUSH
12732: LD_INT 264
12734: PPUSH
12735: LD_INT 120
12737: PPUSH
12738: LD_INT 4
12740: PPUSH
12741: CALL_OW 47
12745: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12746: LD_INT 264
12748: PPUSH
12749: LD_INT 120
12751: PPUSH
12752: LD_INT 4
12754: PPUSH
12755: LD_INT 10
12757: NEG
12758: PPUSH
12759: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12763: LD_INT 264
12765: PPUSH
12766: LD_INT 120
12768: PPUSH
12769: LD_INT 4
12771: PPUSH
12772: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12776: LD_INT 35
12778: PPUSH
12779: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12783: LD_EXP 41
12787: PPUSH
12788: LD_INT 10
12790: PPUSH
12791: CALL_OW 308
12795: IFFALSE 12776
// if has_eng and not dep then
12797: LD_VAR 0 2
12801: PUSH
12802: LD_VAR 0 4
12806: NOT
12807: AND
12808: IFFALSE 12958
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12810: LD_VAR 0 2
12814: PPUSH
12815: LD_INT 0
12817: PPUSH
12818: LD_INT 264
12820: PPUSH
12821: LD_INT 120
12823: PPUSH
12824: LD_INT 4
12826: PPUSH
12827: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12831: LD_INT 35
12833: PPUSH
12834: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
12838: LD_INT 22
12840: PUSH
12841: LD_INT 4
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: PUSH
12848: LD_INT 30
12850: PUSH
12851: LD_INT 0
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PPUSH
12862: CALL_OW 69
12866: IFFALSE 12831
// ComMoveXY ( filter , 264 , 120 ) ;
12868: LD_VAR 0 3
12872: PPUSH
12873: LD_INT 264
12875: PPUSH
12876: LD_INT 120
12878: PPUSH
12879: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
12883: LD_INT 35
12885: PPUSH
12886: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12890: LD_INT 22
12892: PUSH
12893: LD_INT 4
12895: PUSH
12896: EMPTY
12897: LIST
12898: LIST
12899: PUSH
12900: LD_INT 30
12902: PUSH
12903: LD_INT 0
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 3
12912: PUSH
12913: LD_INT 57
12915: PUSH
12916: EMPTY
12917: LIST
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: PPUSH
12928: CALL_OW 69
12932: IFFALSE 12883
// ComMoveXY ( filter , 247 , 113 ) ;
12934: LD_VAR 0 3
12938: PPUSH
12939: LD_INT 247
12941: PPUSH
12942: LD_INT 113
12944: PPUSH
12945: CALL_OW 111
// Wait ( 0 0$2 ) ;
12949: LD_INT 70
12951: PPUSH
12952: CALL_OW 67
// end else
12956: GO 12970
// begin SetSide ( dep , 4 ) ;
12958: LD_VAR 0 4
12962: PPUSH
12963: LD_INT 4
12965: PPUSH
12966: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12970: LD_ADDR_VAR 0 4
12974: PUSH
12975: LD_INT 22
12977: PUSH
12978: LD_INT 4
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: PUSH
12985: LD_INT 30
12987: PUSH
12988: LD_INT 0
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PPUSH
12999: CALL_OW 69
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// for i = 1 to 3 - has_eng do
13008: LD_ADDR_VAR 0 1
13012: PUSH
13013: DOUBLE
13014: LD_INT 1
13016: DEC
13017: ST_TO_ADDR
13018: LD_INT 3
13020: PUSH
13021: LD_VAR 0 2
13025: MINUS
13026: PUSH
13027: FOR_TO
13028: IFFALSE 13108
// begin if GetClass ( filter [ i ] ) = 2 then
13030: LD_VAR 0 3
13034: PUSH
13035: LD_VAR 0 1
13039: ARRAY
13040: PPUSH
13041: CALL_OW 257
13045: PUSH
13046: LD_INT 2
13048: EQUAL
13049: IFFALSE 13053
// continue ;
13051: GO 13027
// ComEnterUnit ( filter [ i ] , dep ) ;
13053: LD_VAR 0 3
13057: PUSH
13058: LD_VAR 0 1
13062: ARRAY
13063: PPUSH
13064: LD_VAR 0 4
13068: PPUSH
13069: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
13073: LD_VAR 0 3
13077: PUSH
13078: LD_VAR 0 1
13082: ARRAY
13083: PPUSH
13084: LD_INT 2
13086: PPUSH
13087: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
13091: LD_VAR 0 3
13095: PUSH
13096: LD_VAR 0 1
13100: ARRAY
13101: PPUSH
13102: CALL_OW 182
// end ;
13106: GO 13027
13108: POP
13109: POP
// repeat wait ( 0 0$01 ) ;
13110: LD_INT 35
13112: PPUSH
13113: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
13117: LD_VAR 0 3
13121: PPUSH
13122: LD_INT 25
13124: PUSH
13125: LD_INT 2
13127: PUSH
13128: EMPTY
13129: LIST
13130: LIST
13131: PPUSH
13132: CALL_OW 72
13136: PUSH
13137: LD_INT 3
13139: EQUAL
13140: IFFALSE 13110
// if IsInUnit ( Cornel ) then
13142: LD_EXP 41
13146: PPUSH
13147: CALL_OW 310
13151: IFFALSE 13234
// begin cargo := IsInUnit ( Cornel ) ;
13153: LD_ADDR_VAR 0 7
13157: PUSH
13158: LD_EXP 41
13162: PPUSH
13163: CALL_OW 310
13167: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13168: LD_VAR 0 7
13172: PPUSH
13173: LD_INT 1
13175: PPUSH
13176: CALL_OW 289
13180: IFFALSE 13196
// ComGive ( Cornel , dep ) ;
13182: LD_EXP 41
13186: PPUSH
13187: LD_VAR 0 4
13191: PPUSH
13192: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13196: LD_EXP 41
13200: PPUSH
13201: LD_INT 235
13203: PPUSH
13204: LD_INT 122
13206: PPUSH
13207: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13211: LD_EXP 41
13215: PPUSH
13216: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13220: LD_EXP 41
13224: PPUSH
13225: LD_VAR 0 4
13229: PPUSH
13230: CALL_OW 180
// end ; if Bierezov then
13234: LD_EXP 42
13238: IFFALSE 13254
// ComEnterUnit ( Bierezov , dep ) ;
13240: LD_EXP 42
13244: PPUSH
13245: LD_VAR 0 4
13249: PPUSH
13250: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13254: LD_ADDR_VAR 0 2
13258: PUSH
13259: LD_EXP 6
13263: PPUSH
13264: LD_INT 25
13266: PUSH
13267: LD_INT 2
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PPUSH
13274: CALL_OW 72
13278: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13279: LD_INT 35
13281: PPUSH
13282: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13286: LD_ADDR_VAR 0 6
13290: PUSH
13291: LD_INT 10
13293: PPUSH
13294: CALL_OW 435
13298: ST_TO_ADDR
// if crates then
13299: LD_VAR 0 6
13303: IFFALSE 13332
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13305: LD_VAR 0 2
13309: PPUSH
13310: LD_VAR 0 6
13314: PUSH
13315: LD_INT 1
13317: ARRAY
13318: PPUSH
13319: LD_VAR 0 6
13323: PUSH
13324: LD_INT 2
13326: ARRAY
13327: PPUSH
13328: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13332: LD_VAR 0 4
13336: PPUSH
13337: CALL_OW 274
13341: PPUSH
13342: LD_INT 1
13344: PPUSH
13345: CALL_OW 275
13349: PUSH
13350: LD_INT 40
13352: GREATEREQUAL
13353: IFFALSE 13279
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13355: LD_ADDR_VAR 0 5
13359: PUSH
13360: LD_INT 4
13362: PUSH
13363: LD_INT 256
13365: PUSH
13366: LD_INT 111
13368: PUSH
13369: LD_INT 2
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: PUSH
13378: LD_INT 31
13380: PUSH
13381: LD_INT 243
13383: PUSH
13384: LD_INT 112
13386: PUSH
13387: LD_INT 2
13389: PUSH
13390: EMPTY
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: PUSH
13396: EMPTY
13397: LIST
13398: LIST
13399: ST_TO_ADDR
// for i in blist do
13400: LD_ADDR_VAR 0 1
13404: PUSH
13405: LD_VAR 0 5
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13460
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13413: LD_VAR 0 2
13417: PPUSH
13418: LD_VAR 0 1
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: LD_VAR 0 1
13431: PUSH
13432: LD_INT 2
13434: ARRAY
13435: PPUSH
13436: LD_VAR 0 1
13440: PUSH
13441: LD_INT 3
13443: ARRAY
13444: PPUSH
13445: LD_VAR 0 1
13449: PUSH
13450: LD_INT 4
13452: ARRAY
13453: PPUSH
13454: CALL_OW 205
13458: GO 13410
13460: POP
13461: POP
// repeat wait ( 0 0$01 ) ;
13462: LD_INT 35
13464: PPUSH
13465: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13469: LD_INT 22
13471: PUSH
13472: LD_INT 4
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: LD_INT 30
13481: PUSH
13482: LD_INT 4
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 3
13491: PUSH
13492: LD_INT 57
13494: PUSH
13495: EMPTY
13496: LIST
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: LIST
13506: PPUSH
13507: CALL_OW 69
13511: IFFALSE 13462
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13513: LD_VAR 0 3
13517: PUSH
13518: LD_VAR 0 2
13522: DIFF
13523: PPUSH
13524: LD_INT 22
13526: PUSH
13527: LD_INT 4
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: LD_INT 30
13536: PUSH
13537: LD_INT 4
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: PPUSH
13548: CALL_OW 69
13552: PUSH
13553: LD_INT 1
13555: ARRAY
13556: PPUSH
13557: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13561: LD_VAR 0 3
13565: PUSH
13566: LD_VAR 0 2
13570: DIFF
13571: PPUSH
13572: LD_INT 1
13574: PPUSH
13575: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13579: LD_INT 35
13581: PPUSH
13582: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13586: LD_INT 22
13588: PUSH
13589: LD_INT 4
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 30
13598: PUSH
13599: LD_INT 31
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 3
13608: PUSH
13609: LD_INT 57
13611: PUSH
13612: EMPTY
13613: LIST
13614: PUSH
13615: EMPTY
13616: LIST
13617: LIST
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: LIST
13623: PPUSH
13624: CALL_OW 69
13628: IFFALSE 13579
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13630: LD_ADDR_VAR 0 8
13634: PUSH
13635: LD_EXP 6
13639: PPUSH
13640: LD_INT 25
13642: PUSH
13643: LD_INT 1
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: PPUSH
13650: CALL_OW 72
13654: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
13655: LD_VAR 0 8
13659: PUSH
13660: LD_INT 1
13662: ARRAY
13663: PPUSH
13664: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13668: LD_VAR 0 8
13672: PUSH
13673: LD_INT 1
13675: ARRAY
13676: PPUSH
13677: LD_INT 22
13679: PUSH
13680: LD_INT 4
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: PUSH
13687: LD_INT 30
13689: PUSH
13690: LD_INT 31
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: PPUSH
13701: CALL_OW 69
13705: PUSH
13706: LD_INT 1
13708: ARRAY
13709: PPUSH
13710: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13714: LD_VAR 0 2
13718: PPUSH
13719: LD_VAR 0 4
13723: PPUSH
13724: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13728: LD_INT 35
13730: PPUSH
13731: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: LD_INT 22
13742: PUSH
13743: LD_INT 4
13745: PUSH
13746: EMPTY
13747: LIST
13748: LIST
13749: PUSH
13750: LD_INT 21
13752: PUSH
13753: LD_INT 3
13755: PUSH
13756: EMPTY
13757: LIST
13758: LIST
13759: PUSH
13760: LD_INT 3
13762: PUSH
13763: LD_INT 24
13765: PUSH
13766: LD_INT 1000
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: ST_TO_ADDR
// if filter and has_eng then
13787: LD_VAR 0 3
13791: PUSH
13792: LD_VAR 0 2
13796: AND
13797: IFFALSE 13863
// begin for i in has_eng do
13799: LD_ADDR_VAR 0 1
13803: PUSH
13804: LD_VAR 0 2
13808: PUSH
13809: FOR_IN
13810: IFFALSE 13859
// begin if IsInUnit ( i ) then
13812: LD_VAR 0 1
13816: PPUSH
13817: CALL_OW 310
13821: IFFALSE 13832
// ComExitBuilding ( i ) ;
13823: LD_VAR 0 1
13827: PPUSH
13828: CALL_OW 122
// Wait ( 3 ) ;
13832: LD_INT 3
13834: PPUSH
13835: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13839: LD_VAR 0 1
13843: PPUSH
13844: LD_VAR 0 3
13848: PUSH
13849: LD_INT 1
13851: ARRAY
13852: PPUSH
13853: CALL_OW 130
// end ;
13857: GO 13809
13859: POP
13860: POP
// end else
13861: GO 13917
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13863: LD_VAR 0 2
13867: PUSH
13868: LD_VAR 0 2
13872: PPUSH
13873: LD_INT 56
13875: PUSH
13876: EMPTY
13877: LIST
13878: PPUSH
13879: CALL_OW 72
13883: AND
13884: IFFALSE 13917
// for i in has_eng do
13886: LD_ADDR_VAR 0 1
13890: PUSH
13891: LD_VAR 0 2
13895: PUSH
13896: FOR_IN
13897: IFFALSE 13915
// ComEnterUnit ( i , dep ) ;
13899: LD_VAR 0 1
13903: PPUSH
13904: LD_VAR 0 4
13908: PPUSH
13909: CALL_OW 120
13913: GO 13896
13915: POP
13916: POP
// until cornel_prepared ;
13917: LD_EXP 11
13921: IFFALSE 13728
// end ;
13923: PPOPN 8
13925: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13926: LD_EXP 11
13930: IFFALSE 14279
13932: GO 13934
13934: DISABLE
13935: LD_INT 0
13937: PPUSH
13938: PPUSH
13939: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13940: LD_ADDR_VAR 0 2
13944: PUSH
13945: LD_INT 22
13947: PUSH
13948: LD_INT 4
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: PUSH
13955: LD_INT 30
13957: PUSH
13958: LD_INT 4
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PPUSH
13969: CALL_OW 69
13973: PUSH
13974: LD_INT 1
13976: ARRAY
13977: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13978: LD_EXP 6
13982: PPUSH
13983: CALL_OW 122
// Wait ( 0 0$03 ) ;
13987: LD_INT 105
13989: PPUSH
13990: CALL_OW 67
// for i in cornel_units do
13994: LD_ADDR_VAR 0 1
13998: PUSH
13999: LD_EXP 6
14003: PUSH
14004: FOR_IN
14005: IFFALSE 14081
// begin if GetClass ( i ) in [ 2 , 3 ] then
14007: LD_VAR 0 1
14011: PPUSH
14012: CALL_OW 257
14016: PUSH
14017: LD_INT 2
14019: PUSH
14020: LD_INT 3
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: IN
14027: IFFALSE 14064
// begin ComEnterUnit ( i , arm ) ;
14029: LD_VAR 0 1
14033: PPUSH
14034: LD_VAR 0 2
14038: PPUSH
14039: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14043: LD_VAR 0 1
14047: PPUSH
14048: LD_INT 1
14050: PPUSH
14051: CALL_OW 183
// AddComExitBuilding ( i ) ;
14055: LD_VAR 0 1
14059: PPUSH
14060: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14064: LD_VAR 0 1
14068: PPUSH
14069: LD_INT 257
14071: PPUSH
14072: LD_INT 121
14074: PPUSH
14075: CALL_OW 171
// end ;
14079: GO 14004
14081: POP
14082: POP
// Wait ( 1 1$00 ) ;
14083: LD_INT 2100
14085: PPUSH
14086: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14090: LD_ADDR_VAR 0 3
14094: PUSH
14095: LD_EXP 41
14099: PUSH
14100: LD_EXP 42
14104: ADD
14105: PUSH
14106: LD_EXP 6
14110: ADD
14111: PUSH
14112: LD_EXP 6
14116: PPUSH
14117: LD_INT 21
14119: PUSH
14120: LD_INT 2
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: PPUSH
14127: CALL_OW 72
14131: DIFF
14132: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14133: LD_VAR 0 3
14137: PPUSH
14138: LD_INT 248
14140: PPUSH
14141: LD_INT 85
14143: PPUSH
14144: CALL_OW 111
// AddComHold ( filter ) ;
14148: LD_VAR 0 3
14152: PPUSH
14153: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14157: LD_INT 35
14159: PPUSH
14160: CALL_OW 67
// until cornel_attack ;
14164: LD_EXP 9
14168: IFFALSE 14157
// ComAgressiveMove ( filter , 209 , 63 ) ;
14170: LD_VAR 0 3
14174: PPUSH
14175: LD_INT 209
14177: PPUSH
14178: LD_INT 63
14180: PPUSH
14181: CALL_OW 114
// if Bierezov then
14185: LD_EXP 42
14189: IFFALSE 14279
// begin filter := filter diff Bierezov ;
14191: LD_ADDR_VAR 0 3
14195: PUSH
14196: LD_VAR 0 3
14200: PUSH
14201: LD_EXP 42
14205: DIFF
14206: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14207: LD_EXP 42
14211: PPUSH
14212: LD_INT 6
14214: PPUSH
14215: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14219: LD_EXP 42
14223: PPUSH
14224: LD_INT 235
14226: PPUSH
14227: LD_INT 60
14229: PPUSH
14230: CALL_OW 111
// AddComHold ( Bierezov ) ;
14234: LD_EXP 42
14238: PPUSH
14239: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14243: LD_EXP 42
14247: PPUSH
14248: LD_INT 350
14250: PPUSH
14251: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14255: LD_EXP 42
14259: PPUSH
14260: LD_INT 198
14262: PPUSH
14263: LD_INT 28
14265: PPUSH
14266: CALL_OW 171
// AddComHold ( Bierezov ) ;
14270: LD_EXP 42
14274: PPUSH
14275: CALL_OW 200
// end ; end ; end_of_file
14279: PPOPN 3
14281: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14282: LD_EXP 50
14286: PUSH
14287: LD_EXP 29
14291: NOT
14292: AND
14293: PUSH
14294: LD_EXP 30
14298: NOT
14299: AND
14300: IFFALSE 14750
14302: GO 14304
14304: DISABLE
14305: LD_INT 0
14307: PPUSH
14308: PPUSH
14309: PPUSH
14310: PPUSH
// begin enable ;
14311: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14312: LD_ADDR_VAR 0 4
14316: PUSH
14317: LD_INT 81
14319: PUSH
14320: LD_INT 3
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: PPUSH
14327: CALL_OW 69
14331: ST_TO_ADDR
// for i = 1 to ru_patrol do
14332: LD_ADDR_VAR 0 2
14336: PUSH
14337: DOUBLE
14338: LD_INT 1
14340: DEC
14341: ST_TO_ADDR
14342: LD_EXP 50
14346: PUSH
14347: FOR_TO
14348: IFFALSE 14748
// begin un := ru_patrol [ i ] ;
14350: LD_ADDR_VAR 0 1
14354: PUSH
14355: LD_EXP 50
14359: PUSH
14360: LD_VAR 0 2
14364: ARRAY
14365: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14366: LD_VAR 0 1
14370: PPUSH
14371: LD_INT 13
14373: PPUSH
14374: CALL_OW 308
14378: IFFALSE 14483
// begin if not ru_alert then
14380: LD_EXP 57
14384: NOT
14385: IFFALSE 14395
// ru_alert := true ;
14387: LD_ADDR_EXP 57
14391: PUSH
14392: LD_INT 1
14394: ST_TO_ADDR
// if not See ( 1 , un ) then
14395: LD_INT 1
14397: PPUSH
14398: LD_VAR 0 1
14402: PPUSH
14403: CALL_OW 292
14407: NOT
14408: IFFALSE 14422
// SetLives ( un , 1000 ) ;
14410: LD_VAR 0 1
14414: PPUSH
14415: LD_INT 1000
14417: PPUSH
14418: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14422: LD_ADDR_EXP 50
14426: PUSH
14427: LD_EXP 50
14431: PUSH
14432: LD_VAR 0 1
14436: DIFF
14437: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14438: LD_VAR 0 1
14442: PPUSH
14443: LD_INT 22
14445: PUSH
14446: LD_INT 3
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: LD_INT 30
14455: PUSH
14456: LD_INT 4
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PPUSH
14467: CALL_OW 69
14471: PPUSH
14472: CALL 1031 0 1
14476: PPUSH
14477: CALL_OW 120
// continue ;
14481: GO 14347
// end ; if IsOk ( un ) and not HasTask ( un ) then
14483: LD_VAR 0 1
14487: PPUSH
14488: CALL_OW 302
14492: PUSH
14493: LD_VAR 0 1
14497: PPUSH
14498: CALL_OW 314
14502: NOT
14503: AND
14504: IFFALSE 14597
// begin for j = 1 to ru_firepoints_south [ i ] do
14506: LD_ADDR_VAR 0 3
14510: PUSH
14511: DOUBLE
14512: LD_INT 1
14514: DEC
14515: ST_TO_ADDR
14516: LD_EXP 56
14520: PUSH
14521: LD_VAR 0 2
14525: ARRAY
14526: PUSH
14527: FOR_TO
14528: IFFALSE 14595
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14530: LD_VAR 0 1
14534: PPUSH
14535: LD_EXP 56
14539: PUSH
14540: LD_VAR 0 2
14544: ARRAY
14545: PUSH
14546: LD_VAR 0 3
14550: ARRAY
14551: PUSH
14552: LD_INT 1
14554: ARRAY
14555: PPUSH
14556: LD_EXP 56
14560: PUSH
14561: LD_VAR 0 2
14565: ARRAY
14566: PUSH
14567: LD_VAR 0 3
14571: ARRAY
14572: PUSH
14573: LD_INT 2
14575: ARRAY
14576: PPUSH
14577: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14581: LD_VAR 0 1
14585: PPUSH
14586: LD_INT 70
14588: PPUSH
14589: CALL_OW 202
// end ;
14593: GO 14527
14595: POP
14596: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: CALL_OW 256
14606: PUSH
14607: LD_INT 700
14609: LESS
14610: PUSH
14611: LD_VAR 0 1
14615: PPUSH
14616: LD_INT 13
14618: PPUSH
14619: CALL_OW 308
14623: NOT
14624: AND
14625: IFFALSE 14677
// begin ComMoveToArea ( un , retreatArea ) ;
14627: LD_VAR 0 1
14631: PPUSH
14632: LD_INT 13
14634: PPUSH
14635: CALL_OW 113
// if not ru_alert_xy then
14639: LD_EXP 58
14643: NOT
14644: IFFALSE 14675
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14646: LD_ADDR_EXP 58
14650: PUSH
14651: LD_VAR 0 1
14655: PPUSH
14656: CALL_OW 250
14660: PUSH
14661: LD_VAR 0 1
14665: PPUSH
14666: CALL_OW 251
14670: PUSH
14671: EMPTY
14672: LIST
14673: LIST
14674: ST_TO_ADDR
// end else
14675: GO 14746
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14677: LD_VAR 0 1
14681: PPUSH
14682: LD_VAR 0 4
14686: PPUSH
14687: LD_VAR 0 1
14691: PPUSH
14692: CALL_OW 74
14696: PPUSH
14697: CALL_OW 296
14701: PUSH
14702: LD_INT 9
14704: LESS
14705: PUSH
14706: LD_VAR 0 1
14710: PPUSH
14711: CALL_OW 256
14715: PUSH
14716: LD_INT 500
14718: GREATER
14719: AND
14720: IFFALSE 14746
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14722: LD_VAR 0 1
14726: PPUSH
14727: LD_VAR 0 4
14731: PPUSH
14732: LD_VAR 0 1
14736: PPUSH
14737: CALL_OW 74
14741: PPUSH
14742: CALL_OW 115
// end ;
14746: GO 14347
14748: POP
14749: POP
// end ;
14750: PPOPN 4
14752: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14753: LD_EXP 57
14757: PUSH
14758: LD_EXP 58
14762: AND
14763: PUSH
14764: LD_EXP 29
14768: NOT
14769: AND
14770: PUSH
14771: LD_EXP 30
14775: NOT
14776: AND
14777: IFFALSE 14987
14779: GO 14781
14781: DISABLE
14782: LD_INT 0
14784: PPUSH
14785: PPUSH
// begin enable ;
14786: ENABLE
// if not ru_vehicles then
14787: LD_EXP 53
14791: NOT
14792: IFFALSE 14796
// exit ;
14794: GO 14987
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14796: LD_ADDR_VAR 0 2
14800: PUSH
14801: LD_INT 81
14803: PUSH
14804: LD_INT 3
14806: PUSH
14807: EMPTY
14808: LIST
14809: LIST
14810: PPUSH
14811: CALL_OW 69
14815: ST_TO_ADDR
// if ru_vehicles then
14816: LD_EXP 53
14820: IFFALSE 14987
// begin for i in ru_vehicles do
14822: LD_ADDR_VAR 0 1
14826: PUSH
14827: LD_EXP 53
14831: PUSH
14832: FOR_IN
14833: IFFALSE 14985
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14835: LD_VAR 0 1
14839: PPUSH
14840: CALL_OW 302
14844: PUSH
14845: LD_VAR 0 1
14849: PPUSH
14850: LD_VAR 0 2
14854: PPUSH
14855: LD_VAR 0 1
14859: PPUSH
14860: CALL_OW 74
14864: PPUSH
14865: CALL_OW 296
14869: PUSH
14870: LD_INT 9
14872: LESS
14873: AND
14874: IFFALSE 14900
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14876: LD_VAR 0 1
14880: PPUSH
14881: LD_VAR 0 2
14885: PPUSH
14886: LD_VAR 0 1
14890: PPUSH
14891: CALL_OW 74
14895: PPUSH
14896: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14900: LD_VAR 0 1
14904: PPUSH
14905: CALL_OW 314
14909: NOT
14910: PUSH
14911: LD_VAR 0 1
14915: PPUSH
14916: CALL_OW 302
14920: AND
14921: PUSH
14922: LD_VAR 0 1
14926: PPUSH
14927: LD_EXP 58
14931: PUSH
14932: LD_INT 1
14934: ARRAY
14935: PPUSH
14936: LD_EXP 58
14940: PUSH
14941: LD_INT 2
14943: ARRAY
14944: PPUSH
14945: CALL_OW 297
14949: PUSH
14950: LD_INT 10
14952: GREATER
14953: AND
14954: IFFALSE 14983
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14956: LD_VAR 0 1
14960: PPUSH
14961: LD_EXP 58
14965: PUSH
14966: LD_INT 1
14968: ARRAY
14969: PPUSH
14970: LD_EXP 58
14974: PUSH
14975: LD_INT 2
14977: ARRAY
14978: PPUSH
14979: CALL_OW 114
// end ;
14983: GO 14832
14985: POP
14986: POP
// end ; end ;
14987: PPOPN 2
14989: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14990: LD_EXP 58
14994: PUSH
14995: LD_EXP 57
14999: AND
15000: PUSH
15001: LD_INT 3
15003: PPUSH
15004: CALL_OW 463
15008: NOT
15009: AND
15010: PUSH
15011: LD_EXP 29
15015: NOT
15016: AND
15017: PUSH
15018: LD_EXP 30
15022: NOT
15023: AND
15024: IFFALSE 15119
15026: GO 15028
15028: DISABLE
15029: LD_INT 0
15031: PPUSH
// begin enable ;
15032: ENABLE
// ru_alert_xy := false ;
15033: LD_ADDR_EXP 58
15037: PUSH
15038: LD_INT 0
15040: ST_TO_ADDR
// ru_alert := false ;
15041: LD_ADDR_EXP 57
15045: PUSH
15046: LD_INT 0
15048: ST_TO_ADDR
// if ru_vehicles then
15049: LD_EXP 53
15053: IFFALSE 15119
// for i in ru_vehicles do
15055: LD_ADDR_VAR 0 1
15059: PUSH
15060: LD_EXP 53
15064: PUSH
15065: FOR_IN
15066: IFFALSE 15117
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15068: LD_VAR 0 1
15072: PPUSH
15073: CALL_OW 302
15077: PUSH
15078: LD_VAR 0 1
15082: PPUSH
15083: LD_INT 89
15085: PPUSH
15086: LD_INT 36
15088: PPUSH
15089: CALL_OW 297
15093: PUSH
15094: LD_INT 10
15096: GREATER
15097: AND
15098: IFFALSE 15115
// ComMoveXY ( i , 89 , 36 ) ;
15100: LD_VAR 0 1
15104: PPUSH
15105: LD_INT 89
15107: PPUSH
15108: LD_INT 36
15110: PPUSH
15111: CALL_OW 111
15115: GO 15065
15117: POP
15118: POP
// end ;
15119: PPOPN 1
15121: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15122: LD_EXP 52
15126: PUSH
15127: LD_EXP 29
15131: NOT
15132: AND
15133: PUSH
15134: LD_EXP 30
15138: NOT
15139: AND
15140: IFFALSE 15424
15142: GO 15144
15144: DISABLE
15145: LD_INT 0
15147: PPUSH
15148: PPUSH
15149: PPUSH
// begin enable ;
15150: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15151: LD_ADDR_VAR 0 3
15155: PUSH
15156: LD_INT 81
15158: PUSH
15159: LD_INT 3
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: PPUSH
15166: CALL_OW 69
15170: ST_TO_ADDR
// for i = 1 to ru_forest do
15171: LD_ADDR_VAR 0 1
15175: PUSH
15176: DOUBLE
15177: LD_INT 1
15179: DEC
15180: ST_TO_ADDR
15181: LD_EXP 52
15185: PUSH
15186: FOR_TO
15187: IFFALSE 15422
// begin un := ru_forest [ i ] ;
15189: LD_ADDR_VAR 0 2
15193: PUSH
15194: LD_EXP 52
15198: PUSH
15199: LD_VAR 0 1
15203: ARRAY
15204: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15205: LD_VAR 0 2
15209: PPUSH
15210: LD_INT 13
15212: PPUSH
15213: CALL_OW 308
15217: IFFALSE 15307
// begin if not See ( 1 , un ) then
15219: LD_INT 1
15221: PPUSH
15222: LD_VAR 0 2
15226: PPUSH
15227: CALL_OW 292
15231: NOT
15232: IFFALSE 15246
// SetLives ( un , 1000 ) ;
15234: LD_VAR 0 2
15238: PPUSH
15239: LD_INT 1000
15241: PPUSH
15242: CALL_OW 234
// ru_forest := ru_forest diff un ;
15246: LD_ADDR_EXP 52
15250: PUSH
15251: LD_EXP 52
15255: PUSH
15256: LD_VAR 0 2
15260: DIFF
15261: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15262: LD_VAR 0 2
15266: PPUSH
15267: LD_INT 22
15269: PUSH
15270: LD_INT 3
15272: PUSH
15273: EMPTY
15274: LIST
15275: LIST
15276: PUSH
15277: LD_INT 30
15279: PUSH
15280: LD_INT 4
15282: PUSH
15283: EMPTY
15284: LIST
15285: LIST
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: PPUSH
15291: CALL_OW 69
15295: PPUSH
15296: CALL 1031 0 1
15300: PPUSH
15301: CALL_OW 120
// continue ;
15305: GO 15186
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15307: LD_VAR 0 2
15311: PPUSH
15312: CALL_OW 256
15316: PUSH
15317: LD_INT 700
15319: LESS
15320: PUSH
15321: LD_VAR 0 2
15325: PPUSH
15326: LD_INT 13
15328: PPUSH
15329: CALL_OW 308
15333: NOT
15334: AND
15335: IFFALSE 15351
// ComMoveToArea ( un , retreatArea ) else
15337: LD_VAR 0 2
15341: PPUSH
15342: LD_INT 13
15344: PPUSH
15345: CALL_OW 113
15349: GO 15420
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15351: LD_VAR 0 2
15355: PPUSH
15356: LD_VAR 0 3
15360: PPUSH
15361: LD_VAR 0 2
15365: PPUSH
15366: CALL_OW 74
15370: PPUSH
15371: CALL_OW 296
15375: PUSH
15376: LD_INT 9
15378: LESS
15379: PUSH
15380: LD_VAR 0 2
15384: PPUSH
15385: CALL_OW 256
15389: PUSH
15390: LD_INT 500
15392: GREATER
15393: AND
15394: IFFALSE 15420
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15396: LD_VAR 0 2
15400: PPUSH
15401: LD_VAR 0 3
15405: PPUSH
15406: LD_VAR 0 2
15410: PPUSH
15411: CALL_OW 74
15415: PPUSH
15416: CALL_OW 115
// end ;
15420: GO 15186
15422: POP
15423: POP
// end ;
15424: PPOPN 3
15426: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15427: LD_EXP 30
15431: NOT
15432: IFFALSE 15553
15434: GO 15436
15436: DISABLE
15437: LD_INT 0
15439: PPUSH
15440: PPUSH
// begin enable ;
15441: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15442: LD_ADDR_VAR 0 2
15446: PUSH
15447: LD_INT 22
15449: PUSH
15450: LD_INT 3
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: PUSH
15457: LD_INT 21
15459: PUSH
15460: LD_INT 3
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: PPUSH
15471: CALL_OW 69
15475: ST_TO_ADDR
// if filter then
15476: LD_VAR 0 2
15480: IFFALSE 15553
// for i in filter do
15482: LD_ADDR_VAR 0 1
15486: PUSH
15487: LD_VAR 0 2
15491: PUSH
15492: FOR_IN
15493: IFFALSE 15551
// if GetLives ( i ) < 990 then
15495: LD_VAR 0 1
15499: PPUSH
15500: CALL_OW 256
15504: PUSH
15505: LD_INT 990
15507: LESS
15508: IFFALSE 15549
// begin ru_alert := true ;
15510: LD_ADDR_EXP 57
15514: PUSH
15515: LD_INT 1
15517: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15518: LD_ADDR_EXP 58
15522: PUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: CALL_OW 250
15532: PUSH
15533: LD_VAR 0 1
15537: PPUSH
15538: CALL_OW 251
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: ST_TO_ADDR
// break ;
15547: GO 15551
// end ;
15549: GO 15492
15551: POP
15552: POP
// end ;
15553: PPOPN 2
15555: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15556: LD_EXP 29
15560: IFFALSE 15709
15562: GO 15564
15564: DISABLE
15565: LD_INT 0
15567: PPUSH
15568: PPUSH
15569: PPUSH
15570: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15571: LD_ADDR_VAR 0 4
15575: PUSH
15576: LD_EXP 53
15580: PUSH
15581: LD_EXP 52
15585: ADD
15586: PUSH
15587: LD_EXP 50
15591: ADD
15592: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15593: LD_ADDR_VAR 0 3
15597: PUSH
15598: LD_INT 3
15600: PPUSH
15601: LD_INT 81
15603: PUSH
15604: LD_INT 3
15606: PUSH
15607: EMPTY
15608: LIST
15609: LIST
15610: PPUSH
15611: CALL_OW 70
15615: ST_TO_ADDR
// if filter and enemy then
15616: LD_VAR 0 4
15620: PUSH
15621: LD_VAR 0 3
15625: AND
15626: IFFALSE 15709
// repeat wait ( 0 0$01 ) ;
15628: LD_INT 35
15630: PPUSH
15631: CALL_OW 67
// for i in filter do
15635: LD_ADDR_VAR 0 1
15639: PUSH
15640: LD_VAR 0 4
15644: PUSH
15645: FOR_IN
15646: IFFALSE 15674
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15648: LD_VAR 0 1
15652: PPUSH
15653: LD_VAR 0 3
15657: PPUSH
15658: LD_VAR 0 1
15662: PPUSH
15663: CALL_OW 74
15667: PPUSH
15668: CALL_OW 115
// end ;
15672: GO 15645
15674: POP
15675: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15676: LD_INT 3
15678: PPUSH
15679: LD_INT 81
15681: PUSH
15682: LD_INT 3
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: PPUSH
15689: CALL_OW 70
15693: PUSH
15694: LD_INT 0
15696: EQUAL
15697: PUSH
15698: LD_VAR 0 4
15702: PUSH
15703: LD_INT 0
15705: EQUAL
15706: OR
15707: IFFALSE 15628
// end ;
15709: PPOPN 4
15711: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
15712: LD_EXP 25
15716: PUSH
15717: LD_INT 22
15719: PUSH
15720: LD_INT 4
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: PUSH
15727: LD_INT 30
15729: PUSH
15730: LD_INT 4
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: PPUSH
15741: CALL_OW 69
15745: AND
15746: IFFALSE 15795
15748: GO 15750
15750: DISABLE
15751: LD_INT 0
15753: PPUSH
// begin if not ru_cornel_attack then
15754: LD_EXP 55
15758: NOT
15759: IFFALSE 15763
// exit ;
15761: GO 15795
// for i in ru_cornel_attack do
15763: LD_ADDR_VAR 0 1
15767: PUSH
15768: LD_EXP 55
15772: PUSH
15773: FOR_IN
15774: IFFALSE 15793
// ComAgressiveMove ( i , 258 , 119 ) ;
15776: LD_VAR 0 1
15780: PPUSH
15781: LD_INT 258
15783: PPUSH
15784: LD_INT 119
15786: PPUSH
15787: CALL_OW 114
15791: GO 15773
15793: POP
15794: POP
// end ; end_of_file
15795: PPOPN 1
15797: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15798: LD_EXP 5
15802: PUSH
15803: LD_EXP 9
15807: NOT
15808: AND
15809: PUSH
15810: LD_EXP 19
15814: AND
15815: IFFALSE 15927
15817: GO 15819
15819: DISABLE
15820: LD_INT 0
15822: PPUSH
// begin enable ;
15823: ENABLE
// crates_counter := crates_counter - 50 ;
15824: LD_ADDR_EXP 19
15828: PUSH
15829: LD_EXP 19
15833: PUSH
15834: LD_INT 50
15836: MINUS
15837: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15838: LD_INT 8
15840: PPUSH
15841: LD_INT 2
15843: PPUSH
15844: LD_INT 5
15846: PPUSH
15847: CALL_OW 12
15851: PPUSH
15852: LD_INT 1
15854: PPUSH
15855: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15859: LD_INT 1785
15861: PPUSH
15862: LD_INT 2345
15864: PPUSH
15865: CALL_OW 12
15869: PPUSH
15870: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15874: LD_ADDR_VAR 0 1
15878: PUSH
15879: LD_INT 1
15881: PPUSH
15882: LD_OWVAR 67
15886: PUSH
15887: LD_INT 2
15889: PLUS
15890: PPUSH
15891: CALL_OW 12
15895: ST_TO_ADDR
// if r < 3 then
15896: LD_VAR 0 1
15900: PUSH
15901: LD_INT 3
15903: LESS
15904: IFFALSE 15927
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15906: LD_INT 4
15908: PPUSH
15909: LD_INT 1
15911: PPUSH
15912: LD_INT 5
15914: PPUSH
15915: CALL_OW 12
15919: PPUSH
15920: LD_INT 1
15922: PPUSH
15923: CALL_OW 55
// end ;
15927: PPOPN 1
15929: END
// every 0 0$01 trigger cornel_active do
15930: LD_EXP 8
15934: IFFALSE 16023
15936: GO 15938
15938: DISABLE
// begin Wait ( 0 0$03 ) ;
15939: LD_INT 105
15941: PPUSH
15942: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15946: LD_INT 2
15948: PPUSH
15949: LD_INT 5
15951: PPUSH
15952: CALL_OW 12
15956: PPUSH
15957: LD_INT 10
15959: PPUSH
15960: LD_INT 1
15962: PPUSH
15963: CALL_OW 55
// Wait ( 0 0$13 ) ;
15967: LD_INT 455
15969: PPUSH
15970: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15974: LD_INT 2
15976: PPUSH
15977: LD_INT 5
15979: PPUSH
15980: CALL_OW 12
15984: PPUSH
15985: LD_INT 10
15987: PPUSH
15988: LD_INT 1
15990: PPUSH
15991: CALL_OW 55
// Wait ( 0 0$16 ) ;
15995: LD_INT 560
15997: PPUSH
15998: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16002: LD_INT 2
16004: PPUSH
16005: LD_INT 5
16007: PPUSH
16008: CALL_OW 12
16012: PPUSH
16013: LD_INT 10
16015: PPUSH
16016: LD_INT 1
16018: PPUSH
16019: CALL_OW 55
// end ; end_of_file
16023: END
// every 0 0$01 trigger cornel_prepared do
16024: LD_EXP 11
16028: IFFALSE 16087
16030: GO 16032
16032: DISABLE
// begin enable ;
16033: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16034: LD_ADDR_OWVAR 47
16038: PUSH
16039: LD_STRING #Am03-1
16041: PUSH
16042: LD_EXP 10
16046: PUSH
16047: EMPTY
16048: LIST
16049: LIST
16050: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16051: LD_ADDR_EXP 10
16055: PUSH
16056: LD_EXP 10
16060: PPUSH
16061: LD_STRING -
16063: PPUSH
16064: CALL 1101 0 2
16068: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16069: LD_EXP 10
16073: PUSH
16074: LD_INT 0
16076: EQUAL
16077: IFFALSE 16087
// begin Display_Strings := [ ] ;
16079: LD_ADDR_OWVAR 47
16083: PUSH
16084: EMPTY
16085: ST_TO_ADDR
// disable ;
16086: DISABLE
// end ; end ;
16087: END
// every 0 0$01 trigger debug and debug_strings do
16088: LD_EXP 1
16092: PUSH
16093: LD_OWVAR 48
16097: AND
16098: IFFALSE 16114
16100: GO 16102
16102: DISABLE
// begin enable ;
16103: ENABLE
// Display_Strings := debug_strings ;
16104: LD_ADDR_OWVAR 47
16108: PUSH
16109: LD_OWVAR 48
16113: ST_TO_ADDR
// end ; end_of_file
16114: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16115: LD_VAR 0 1
16119: PPUSH
16120: CALL_OW 255
16124: PUSH
16125: LD_INT 1
16127: EQUAL
16128: PUSH
16129: LD_EXP 13
16133: NOT
16134: AND
16135: IFFALSE 16145
// solar_builded := true ;
16137: LD_ADDR_EXP 13
16141: PUSH
16142: LD_INT 1
16144: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL_OW 255
16154: PUSH
16155: LD_INT 1
16157: EQUAL
16158: PUSH
16159: LD_EXP 27
16163: AND
16164: IFFALSE 16197
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16166: LD_ADDR_EXP 27
16170: PUSH
16171: LD_EXP 27
16175: PUSH
16176: LD_INT 1750
16178: PUSH
16179: LD_INT 1400
16181: PUSH
16182: LD_INT 1225
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: LIST
16189: PUSH
16190: LD_OWVAR 67
16194: ARRAY
16195: PLUS
16196: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16197: LD_VAR 0 1
16201: PPUSH
16202: CALL_OW 255
16206: PUSH
16207: LD_INT 3
16209: EQUAL
16210: IFFALSE 16228
// ru_vehicles := ru_vehicles ^ veh ;
16212: LD_ADDR_EXP 53
16216: PUSH
16217: LD_EXP 53
16221: PUSH
16222: LD_VAR 0 1
16226: ADD
16227: ST_TO_ADDR
// end ;
16228: PPOPN 2
16230: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16231: LD_VAR 0 1
16235: PUSH
16236: LD_EXP 50
16240: IN
16241: IFFALSE 16259
// ru_patrol := ru_patrol diff un ;
16243: LD_ADDR_EXP 50
16247: PUSH
16248: LD_EXP 50
16252: PUSH
16253: LD_VAR 0 1
16257: DIFF
16258: ST_TO_ADDR
// if un in ru_forest then
16259: LD_VAR 0 1
16263: PUSH
16264: LD_EXP 52
16268: IN
16269: IFFALSE 16287
// ru_forest := ru_forest diff un ;
16271: LD_ADDR_EXP 52
16275: PUSH
16276: LD_EXP 52
16280: PUSH
16281: LD_VAR 0 1
16285: DIFF
16286: ST_TO_ADDR
// if un in ru_vehicles then
16287: LD_VAR 0 1
16291: PUSH
16292: LD_EXP 53
16296: IN
16297: IFFALSE 16372
// begin ru_vehicles := ru_vehicles diff un ;
16299: LD_ADDR_EXP 53
16303: PUSH
16304: LD_EXP 53
16308: PUSH
16309: LD_VAR 0 1
16313: DIFF
16314: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16315: LD_ADDR_EXP 54
16319: PUSH
16320: LD_EXP 54
16324: PUSH
16325: LD_VAR 0 1
16329: PPUSH
16330: CALL_OW 265
16334: PUSH
16335: LD_VAR 0 1
16339: PPUSH
16340: CALL_OW 262
16344: PUSH
16345: LD_VAR 0 1
16349: PPUSH
16350: CALL_OW 263
16354: PUSH
16355: LD_VAR 0 1
16359: PPUSH
16360: CALL_OW 264
16364: PUSH
16365: EMPTY
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: ADD
16371: ST_TO_ADDR
// end ; if un = JMM then
16372: LD_VAR 0 1
16376: PUSH
16377: LD_EXP 34
16381: EQUAL
16382: IFFALSE 16391
// YouLost ( 0 ) ;
16384: LD_STRING 0
16386: PPUSH
16387: CALL_OW 104
// if un = us_dep_west then
16391: LD_VAR 0 1
16395: PUSH
16396: LD_INT 1
16398: EQUAL
16399: IFFALSE 16408
// YouLost ( 2 ) ;
16401: LD_STRING 2
16403: PPUSH
16404: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
16408: LD_VAR 0 1
16412: PPUSH
16413: CALL_OW 255
16417: PUSH
16418: LD_INT 8
16420: EQUAL
16421: PUSH
16422: LD_EXP 5
16426: NOT
16427: AND
16428: IFFALSE 16437
// YouLost ( 4 ) ;
16430: LD_STRING 4
16432: PPUSH
16433: CALL_OW 104
// if un in jmm_units then
16437: LD_VAR 0 1
16441: PUSH
16442: LD_EXP 4
16446: IN
16447: IFFALSE 16463
// lose_counter := lose_counter + 1 ;
16449: LD_ADDR_EXP 32
16453: PUSH
16454: LD_EXP 32
16458: PUSH
16459: LD_INT 1
16461: PLUS
16462: ST_TO_ADDR
// end ;
16463: PPOPN 1
16465: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16466: LD_INT 0
16468: PPUSH
16469: PPUSH
// begin if GetSide ( driver ) = 3 then
16470: LD_VAR 0 1
16474: PPUSH
16475: CALL_OW 255
16479: PUSH
16480: LD_INT 3
16482: EQUAL
16483: IFFALSE 16561
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16485: LD_ADDR_VAR 0 6
16489: PUSH
16490: LD_INT 22
16492: PUSH
16493: LD_INT 3
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: PUSH
16500: LD_INT 30
16502: PUSH
16503: LD_INT 3
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PPUSH
16514: CALL_OW 69
16518: PPUSH
16519: CALL 1031 0 1
16523: ST_TO_ADDR
// if place then
16524: LD_VAR 0 6
16528: IFFALSE 16546
// ComEnterUnit ( driver , place ) else
16530: LD_VAR 0 1
16534: PPUSH
16535: LD_VAR 0 6
16539: PPUSH
16540: CALL_OW 120
16544: GO 16561
// ComMoveXY ( driver , 70 , 22 ) ;
16546: LD_VAR 0 1
16550: PPUSH
16551: LD_INT 70
16553: PPUSH
16554: LD_INT 22
16556: PPUSH
16557: CALL_OW 111
// end ; end ;
16561: PPOPN 6
16563: END
// every 0 0$01 trigger not game_end and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
16564: LD_EXP 31
16568: NOT
16569: PUSH
16570: LD_INT 22
16572: PUSH
16573: LD_INT 1
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: LD_INT 21
16582: PUSH
16583: LD_INT 1
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PPUSH
16594: CALL_OW 69
16598: PUSH
16599: LD_INT 22
16601: PUSH
16602: LD_INT 8
16604: PUSH
16605: EMPTY
16606: LIST
16607: LIST
16608: PUSH
16609: LD_INT 21
16611: PUSH
16612: LD_INT 1
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PUSH
16619: EMPTY
16620: LIST
16621: LIST
16622: PPUSH
16623: CALL_OW 69
16627: ADD
16628: PUSH
16629: LD_INT 5
16631: LESS
16632: AND
16633: IFFALSE 16645
16635: GO 16637
16637: DISABLE
// YouLost ( 1 ) ;
16638: LD_STRING 1
16640: PPUSH
16641: CALL_OW 104
16645: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16646: LD_INT 1
16648: PPUSH
16649: CALL_OW 255
16653: PUSH
16654: LD_INT 3
16656: EQUAL
16657: IFFALSE 16669
16659: GO 16661
16661: DISABLE
// YouLost ( 3 ) ;
16662: LD_STRING 3
16664: PPUSH
16665: CALL_OW 104
16669: END
