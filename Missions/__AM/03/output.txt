// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 50 0 0
// SetDiplomacy ;
  15: CALL 378 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 29
// DebugMode ;
  25: CALL 466 0 0
// PrepareRussian ;
  29: CALL 3023 0 0
// PrepareAmerican ;
  33: CALL 1228 0 0
// PrepareCornell ;
  37: CALL 2252 0 0
// PrepareWesternBase ;
  41: CALL 2478 0 0
// Action ;
  45: CALL 5239 0 0
// end ;
  49: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , ach_counter , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  50: LD_INT 0
  52: PPUSH
// debug := false ;
  53: LD_ADDR_EXP 1
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  61: LD_ADDR_EXP 3
  65: PUSH
  66: LD_STRING 02_
  68: ST_TO_ADDR
// mission_prefix := 03_ ;
  69: LD_ADDR_EXP 2
  73: PUSH
  74: LD_STRING 03_
  76: ST_TO_ADDR
// jmm_units := 0 ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// cornel_units := 0 ;
  85: LD_ADDR_EXP 6
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// bierezov_exist := false ;
  93: LD_ADDR_EXP 7
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// jmm_on_west := false ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// cornel_active := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// cornel_attack := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// cornel_prepared := false ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 133: LD_ADDR_EXP 10
 137: PUSH
 138: LD_INT 4200
 140: ST_TO_ADDR
// frank_can_return := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// solar_builded := false ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// frank_send_to_scout := false ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// jmm_in_veh := false ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// bobby_in_veh := false ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// cyrus_in_veh := false ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// lisa_in_veh := false ;
 189: LD_ADDR_EXP 19
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 197: LD_ADDR_EXP 29
 201: PUSH
 202: LD_INT 25200
 204: PUSH
 205: LD_INT 23100
 207: PUSH
 208: LD_INT 21000
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_OWVAR 67
 220: ARRAY
 221: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 222: LD_ADDR_EXP 20
 226: PUSH
 227: LD_INT 600
 229: PUSH
 230: LD_INT 500
 232: PUSH
 233: LD_INT 400
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_OWVAR 67
 245: ARRAY
 246: ST_TO_ADDR
// end_mission_allowed := false ;
 247: LD_ADDR_EXP 21
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// save_others := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// save_group := [ ] ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// show_query := true ;
 269: LD_ADDR_EXP 24
 273: PUSH
 274: LD_INT 1
 276: ST_TO_ADDR
// wait_for_them := false ;
 277: LD_ADDR_EXP 25
 281: PUSH
 282: LD_INT 0
 284: ST_TO_ADDR
// veh_on_meta := false ;
 285: LD_ADDR_EXP 28
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// send_spec_patrol := false ;
 293: LD_ADDR_EXP 30
 297: PUSH
 298: LD_INT 0
 300: ST_TO_ADDR
// prepare_siege := false ;
 301: LD_ADDR_EXP 31
 305: PUSH
 306: LD_INT 0
 308: ST_TO_ADDR
// send_attack_on_cornel := false ;
 309: LD_ADDR_EXP 32
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 0
 324: ST_TO_ADDR
// game_end := false ;
 325: LD_ADDR_EXP 33
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// lose_counter := 0 ;
 333: LD_ADDR_EXP 34
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// powell_warn := 0 ;
 341: LD_ADDR_EXP 35
 345: PUSH
 346: LD_INT 0
 348: ST_TO_ADDR
// save_counter := 0 ;
 349: LD_ADDR_EXP 36
 353: PUSH
 354: LD_INT 0
 356: ST_TO_ADDR
// cornel_saved := false ;
 357: LD_ADDR_EXP 27
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// ach_counter := 0 ;
 365: LD_ADDR_EXP 13
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// end ;
 373: LD_VAR 0 1
 377: RET
// function SetDiplomacy ; begin
 378: LD_INT 0
 380: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 4
 386: PPUSH
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 8
 402: PPUSH
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 1
 408: PPUSH
 409: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 413: LD_INT 3
 415: PPUSH
 416: LD_INT 6
 418: PPUSH
 419: LD_INT 1
 421: PPUSH
 422: LD_INT 1
 424: PPUSH
 425: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 429: LD_INT 4
 431: PPUSH
 432: LD_INT 6
 434: PPUSH
 435: LD_INT 0
 437: PPUSH
 438: LD_INT 1
 440: PPUSH
 441: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 445: LD_INT 3
 447: PPUSH
 448: LD_INT 8
 450: PPUSH
 451: LD_INT 0
 453: PPUSH
 454: LD_INT 1
 456: PPUSH
 457: CALL_OW 80
// end ;
 461: LD_VAR 0 1
 465: RET
// export function DebugMode ; var i ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// FogOff ( 1 ) ;
 470: LD_INT 1
 472: PPUSH
 473: CALL_OW 344
// debug_strings := [ ] ;
 477: LD_ADDR_OWVAR 48
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// end ; end_of_file
 484: LD_VAR 0 1
 488: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 489: LD_INT 0
 491: PPUSH
 492: PPUSH
// if exist_mode then
 493: LD_VAR 0 2
 497: IFFALSE 522
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_EXP 3
 508: PUSH
 509: LD_VAR 0 1
 513: STR
 514: PPUSH
 515: CALL_OW 34
 519: ST_TO_ADDR
 520: GO 537
// unit := NewCharacter ( ident ) ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_VAR 0 1
 531: PPUSH
 532: CALL_OW 25
 536: ST_TO_ADDR
// result := unit ;
 537: LD_ADDR_VAR 0 3
 541: PUSH
 542: LD_VAR 0 4
 546: ST_TO_ADDR
// end ;
 547: LD_VAR 0 3
 551: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 552: LD_INT 0
 554: PPUSH
// uc_side := side ;
 555: LD_ADDR_OWVAR 20
 559: PUSH
 560: LD_VAR 0 1
 564: ST_TO_ADDR
// uc_nation := nation ;
 565: LD_ADDR_OWVAR 21
 569: PUSH
 570: LD_VAR 0 2
 574: ST_TO_ADDR
// vc_chassis := chassis ;
 575: LD_ADDR_OWVAR 37
 579: PUSH
 580: LD_VAR 0 3
 584: ST_TO_ADDR
// vc_engine := engine ;
 585: LD_ADDR_OWVAR 39
 589: PUSH
 590: LD_VAR 0 4
 594: ST_TO_ADDR
// vc_control := control ;
 595: LD_ADDR_OWVAR 38
 599: PUSH
 600: LD_VAR 0 5
 604: ST_TO_ADDR
// vc_weapon := weapon ;
 605: LD_ADDR_OWVAR 40
 609: PUSH
 610: LD_VAR 0 6
 614: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 615: LD_ADDR_OWVAR 41
 619: PUSH
 620: LD_VAR 0 7
 624: ST_TO_ADDR
// result := CreateVehicle ;
 625: LD_ADDR_VAR 0 8
 629: PUSH
 630: CALL_OW 45
 634: ST_TO_ADDR
// end ;
 635: LD_VAR 0 8
 639: RET
// export function SayX ( units , ident ) ; var i ; begin
 640: LD_INT 0
 642: PPUSH
 643: PPUSH
// result := false ;
 644: LD_ADDR_VAR 0 3
 648: PUSH
 649: LD_INT 0
 651: ST_TO_ADDR
// if not units then
 652: LD_VAR 0 1
 656: NOT
 657: IFFALSE 661
// exit ;
 659: GO 715
// for i in units do
 661: LD_ADDR_VAR 0 4
 665: PUSH
 666: LD_VAR 0 1
 670: PUSH
 671: FOR_IN
 672: IFFALSE 713
// if IsOk ( i ) then
 674: LD_VAR 0 4
 678: PPUSH
 679: CALL_OW 302
 683: IFFALSE 711
// begin Say ( i , ident ) ;
 685: LD_VAR 0 4
 689: PPUSH
 690: LD_VAR 0 2
 694: PPUSH
 695: CALL_OW 88
// result := i ;
 699: LD_ADDR_VAR 0 3
 703: PUSH
 704: LD_VAR 0 4
 708: ST_TO_ADDR
// break ;
 709: GO 713
// end ;
 711: GO 671
 713: POP
 714: POP
// end ;
 715: LD_VAR 0 3
 719: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 720: LD_INT 0
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
// for i = 1 to count do
 726: LD_ADDR_VAR 0 8
 730: PUSH
 731: DOUBLE
 732: LD_INT 1
 734: DEC
 735: ST_TO_ADDR
 736: LD_VAR 0 6
 740: PUSH
 741: FOR_TO
 742: IFFALSE 823
// begin uc_side = side ;
 744: LD_ADDR_OWVAR 20
 748: PUSH
 749: LD_VAR 0 1
 753: ST_TO_ADDR
// uc_nation = nation ;
 754: LD_ADDR_OWVAR 21
 758: PUSH
 759: LD_VAR 0 2
 763: ST_TO_ADDR
// hc_gallery =  ;
 764: LD_ADDR_OWVAR 33
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// hc_name =  ;
 772: LD_ADDR_OWVAR 26
 776: PUSH
 777: LD_STRING 
 779: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 780: LD_INT 0
 782: PPUSH
 783: LD_VAR 0 5
 787: PPUSH
 788: LD_VAR 0 4
 792: PPUSH
 793: CALL_OW 380
// un = CreateHuman ;
 797: LD_ADDR_VAR 0 10
 801: PUSH
 802: CALL_OW 44
 806: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 807: LD_VAR 0 10
 811: PPUSH
 812: LD_VAR 0 3
 816: PPUSH
 817: CALL_OW 52
// end ;
 821: GO 741
 823: POP
 824: POP
// end ;
 825: LD_VAR 0 7
 829: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 830: LD_INT 0
 832: PPUSH
 833: PPUSH
 834: PPUSH
// uc_side := GetSide ( b ) ;
 835: LD_ADDR_OWVAR 20
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 255
 849: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 850: LD_ADDR_OWVAR 21
 854: PUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: CALL_OW 248
 864: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 865: LD_INT 0
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: LD_VAR 0 1
 875: PPUSH
 876: CALL_OW 380
// un = CreateHuman ;
 880: LD_ADDR_VAR 0 4
 884: PUSH
 885: CALL_OW 44
 889: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 890: LD_ADDR_VAR 0 5
 894: PUSH
 895: LD_VAR 0 2
 899: PPUSH
 900: CALL_OW 254
 904: PUSH
 905: LD_INT 3
 907: MINUS
 908: ST_TO_ADDR
// if dir < 0 then
 909: LD_VAR 0 5
 913: PUSH
 914: LD_INT 0
 916: LESS
 917: IFFALSE 933
// dir := 6 + dir ;
 919: LD_ADDR_VAR 0 5
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: LD_VAR 0 5
 931: PLUS
 932: ST_TO_ADDR
// SetDir ( un , dir ) ;
 933: LD_VAR 0 4
 937: PPUSH
 938: LD_VAR 0 5
 942: PPUSH
 943: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 947: LD_VAR 0 4
 951: PPUSH
 952: LD_VAR 0 2
 956: PPUSH
 957: CALL_OW 52
// end ;
 961: LD_VAR 0 3
 965: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 966: LD_INT 0
 968: PPUSH
 969: PPUSH
 970: PPUSH
// result := false ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 979: LD_ADDR_VAR 0 3
 983: PUSH
 984: LD_INT 22
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 34
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: PPUSH
1008: CALL_OW 69
1012: ST_TO_ADDR
// for i in filter do
1013: LD_ADDR_VAR 0 4
1017: PUSH
1018: LD_VAR 0 3
1022: PUSH
1023: FOR_IN
1024: IFFALSE 1055
// if IsDrivenBy ( i ) = unit then
1026: LD_VAR 0 4
1030: PPUSH
1031: CALL_OW 311
1035: PUSH
1036: LD_VAR 0 1
1040: EQUAL
1041: IFFALSE 1053
// begin result := true ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 1
1050: ST_TO_ADDR
// break ;
1051: GO 1055
// end ;
1053: GO 1023
1055: POP
1056: POP
// end ;
1057: LD_VAR 0 2
1061: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1062: LD_INT 0
1064: PPUSH
1065: PPUSH
// result := false ;
1066: LD_ADDR_VAR 0 2
1070: PUSH
1071: LD_INT 0
1073: ST_TO_ADDR
// if not blist then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1127
// for i in blist do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: LD_VAR 0 1
1092: PUSH
1093: FOR_IN
1094: IFFALSE 1125
// if UnitsInside ( i ) < 6 then
1096: LD_VAR 0 3
1100: PPUSH
1101: CALL_OW 313
1105: PUSH
1106: LD_INT 6
1108: LESS
1109: IFFALSE 1123
// begin result := i ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 3
1120: ST_TO_ADDR
// break ;
1121: GO 1125
// end ;
1123: GO 1093
1125: POP
1126: POP
// end ;
1127: LD_VAR 0 2
1131: RET
// export function Count ( timer , mode ) ; begin
1132: LD_INT 0
1134: PPUSH
// if not timer then
1135: LD_VAR 0 1
1139: NOT
1140: IFFALSE 1144
// exit ;
1142: GO 1195
// if mode in [ asc , up , + ] then
1144: LD_VAR 0 2
1148: PUSH
1149: LD_STRING asc
1151: PUSH
1152: LD_STRING up
1154: PUSH
1155: LD_STRING +
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: IN
1163: IFFALSE 1181
// result := timer + 0 0$01 else
1165: LD_ADDR_VAR 0 3
1169: PUSH
1170: LD_VAR 0 1
1174: PUSH
1175: LD_INT 35
1177: PLUS
1178: ST_TO_ADDR
1179: GO 1195
// result := timer - 0 0$01 ;
1181: LD_ADDR_VAR 0 3
1185: PUSH
1186: LD_VAR 0 1
1190: PUSH
1191: LD_INT 35
1193: MINUS
1194: ST_TO_ADDR
// end ;
1195: LD_VAR 0 3
1199: RET
// export function Video ( mode ) ; begin
1200: LD_INT 0
1202: PPUSH
// ingame_video = mode ;
1203: LD_ADDR_OWVAR 52
1207: PUSH
1208: LD_VAR 0 1
1212: ST_TO_ADDR
// interface_hidden = mode ;
1213: LD_ADDR_OWVAR 54
1217: PUSH
1218: LD_VAR 0 1
1222: ST_TO_ADDR
// end ; end_of_file
1223: LD_VAR 0 2
1227: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1228: LD_INT 0
1230: PPUSH
1231: PPUSH
1232: PPUSH
1233: PPUSH
1234: PPUSH
1235: PPUSH
1236: PPUSH
1237: PPUSH
// uc_side := 4 ;
1238: LD_ADDR_OWVAR 20
1242: PUSH
1243: LD_INT 4
1245: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1246: LD_ADDR_EXP 46
1250: PUSH
1251: LD_STRING Powell
1253: PPUSH
1254: LD_INT 0
1256: PPUSH
1257: CALL 489 0 2
1261: ST_TO_ADDR
// uc_side := 1 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
// uc_nation := 1 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 1
1277: ST_TO_ADDR
// if debug then
1278: LD_EXP 1
1282: IFFALSE 1412
// begin for i = 1 to 4 do
1284: LD_ADDR_VAR 0 2
1288: PUSH
1289: DOUBLE
1290: LD_INT 1
1292: DEC
1293: ST_TO_ADDR
1294: LD_INT 4
1296: PUSH
1297: FOR_TO
1298: IFFALSE 1349
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1300: LD_INT 0
1302: PPUSH
1303: LD_INT 1
1305: PPUSH
1306: LD_INT 2
1308: PPUSH
1309: CALL_OW 12
1313: PPUSH
1314: LD_INT 3
1316: PPUSH
1317: CALL_OW 380
// un := CreateHuman ;
1321: LD_ADDR_VAR 0 3
1325: PUSH
1326: CALL_OW 44
1330: ST_TO_ADDR
// others := others ^ un ;
1331: LD_ADDR_VAR 0 5
1335: PUSH
1336: LD_VAR 0 5
1340: PUSH
1341: LD_VAR 0 3
1345: ADD
1346: ST_TO_ADDR
// end ;
1347: GO 1297
1349: POP
1350: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1351: LD_ADDR_VAR 0 6
1355: PUSH
1356: LD_INT 21
1358: PUSH
1359: LD_INT 1
1361: PUSH
1362: LD_INT 1
1364: PUSH
1365: LD_INT 51
1367: PUSH
1368: LD_INT 90
1370: PUSH
1371: LD_INT 504
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: PUSH
1382: LD_INT 21
1384: PUSH
1385: LD_INT 1
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: LD_INT 51
1393: PUSH
1394: LD_INT 80
1396: PUSH
1397: LD_INT 750
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1412: LD_ADDR_EXP 37
1416: PUSH
1417: LD_STRING JMM
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: CALL 489 0 2
1430: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1431: LD_ADDR_EXP 38
1435: PUSH
1436: LD_STRING Bobby
1438: PPUSH
1439: LD_EXP 1
1443: NOT
1444: PPUSH
1445: CALL 489 0 2
1449: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1450: LD_ADDR_EXP 39
1454: PUSH
1455: LD_STRING Cyrus
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: CALL 489 0 2
1468: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1469: LD_ADDR_EXP 40
1473: PUSH
1474: LD_STRING Lisa
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: CALL 489 0 2
1487: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1488: LD_ADDR_EXP 41
1492: PUSH
1493: LD_STRING Khatam
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: CALL 489 0 2
1506: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1507: LD_ADDR_EXP 42
1511: PUSH
1512: LD_STRING Brian
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: CALL 489 0 2
1525: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1526: LD_ADDR_EXP 43
1530: PUSH
1531: LD_STRING Jerry
1533: PPUSH
1534: LD_EXP 1
1538: NOT
1539: PPUSH
1540: CALL 489 0 2
1544: ST_TO_ADDR
// if Bobby then
1545: LD_EXP 38
1549: IFFALSE 1580
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 4
1565: PUSH
1566: LD_INT 1
1568: PLUS
1569: PPUSH
1570: LD_EXP 38
1574: PPUSH
1575: CALL_OW 2
1579: ST_TO_ADDR
// if Cyrus then
1580: LD_EXP 39
1584: IFFALSE 1615
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_VAR 0 4
1595: PPUSH
1596: LD_VAR 0 4
1600: PUSH
1601: LD_INT 1
1603: PLUS
1604: PPUSH
1605: LD_EXP 39
1609: PPUSH
1610: CALL_OW 2
1614: ST_TO_ADDR
// if Lisa then
1615: LD_EXP 40
1619: IFFALSE 1650
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1621: LD_ADDR_VAR 0 4
1625: PUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: LD_VAR 0 4
1635: PUSH
1636: LD_INT 1
1638: PLUS
1639: PPUSH
1640: LD_EXP 40
1644: PPUSH
1645: CALL_OW 2
1649: ST_TO_ADDR
// if Khatam then
1650: LD_EXP 41
1654: IFFALSE 1685
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1656: LD_ADDR_VAR 0 4
1660: PUSH
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_VAR 0 4
1670: PUSH
1671: LD_INT 1
1673: PLUS
1674: PPUSH
1675: LD_EXP 41
1679: PPUSH
1680: CALL_OW 2
1684: ST_TO_ADDR
// if Brian then
1685: LD_EXP 42
1689: IFFALSE 1720
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_VAR 0 4
1700: PPUSH
1701: LD_VAR 0 4
1705: PUSH
1706: LD_INT 1
1708: PLUS
1709: PPUSH
1710: LD_EXP 42
1714: PPUSH
1715: CALL_OW 2
1719: ST_TO_ADDR
// if Jerry then
1720: LD_EXP 43
1724: IFFALSE 1755
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1726: LD_ADDR_VAR 0 4
1730: PUSH
1731: LD_VAR 0 4
1735: PPUSH
1736: LD_VAR 0 4
1740: PUSH
1741: LD_INT 1
1743: PLUS
1744: PPUSH
1745: LD_EXP 43
1749: PPUSH
1750: CALL_OW 2
1754: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1755: LD_STRING 02_other_survivors
1757: PPUSH
1758: CALL_OW 28
1762: IFFALSE 1777
// others := CreateCharacterSet ( 02_other_survivors ) ;
1764: LD_ADDR_VAR 0 5
1768: PUSH
1769: LD_STRING 02_other_survivors
1771: PPUSH
1772: CALL_OW 31
1776: ST_TO_ADDR
// if others then
1777: LD_VAR 0 5
1781: IFFALSE 1806
// begin tmp := tmp ^ others ;
1783: LD_ADDR_VAR 0 4
1787: PUSH
1788: LD_VAR 0 4
1792: PUSH
1793: LD_VAR 0 5
1797: ADD
1798: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1799: LD_STRING 02_other_survivors
1801: PPUSH
1802: CALL_OW 40
// end ; jmm_units := tmp ;
1806: LD_ADDR_EXP 4
1810: PUSH
1811: LD_VAR 0 4
1815: ST_TO_ADDR
// if not vehicles then
1816: LD_VAR 0 6
1820: NOT
1821: IFFALSE 1839
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1823: LD_ADDR_VAR 0 6
1827: PUSH
1828: LD_STRING 02_tanks_1
1830: PPUSH
1831: LD_INT 0
1833: PPUSH
1834: CALL_OW 30
1838: ST_TO_ADDR
// if vehicles then
1839: LD_VAR 0 6
1843: IFFALSE 2037
// begin got_mech := false ;
1845: LD_ADDR_VAR 0 7
1849: PUSH
1850: LD_INT 0
1852: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 3
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PPUSH
1868: CALL_OW 72
1872: IFFALSE 1882
// got_mech := true ;
1874: LD_ADDR_VAR 0 7
1878: PUSH
1879: LD_INT 1
1881: ST_TO_ADDR
// for i = 1 to vehicles do
1882: LD_ADDR_VAR 0 2
1886: PUSH
1887: DOUBLE
1888: LD_INT 1
1890: DEC
1891: ST_TO_ADDR
1892: LD_VAR 0 6
1896: PUSH
1897: FOR_TO
1898: IFFALSE 2035
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1900: LD_ADDR_VAR 0 3
1904: PUSH
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 3
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 2
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 3
1954: ARRAY
1955: PPUSH
1956: LD_VAR 0 6
1960: PUSH
1961: LD_VAR 0 2
1965: ARRAY
1966: PUSH
1967: LD_INT 4
1969: ARRAY
1970: PPUSH
1971: LD_INT 40
1973: PPUSH
1974: CALL 552 0 7
1978: ST_TO_ADDR
// if not got_mech then
1979: LD_VAR 0 7
1983: NOT
1984: IFFALSE 2010
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 6
1995: PUSH
1996: LD_VAR 0 2
2000: ARRAY
2001: PUSH
2002: LD_INT 6
2004: ARRAY
2005: PPUSH
2006: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
2010: LD_ADDR_VAR 0 4
2014: PUSH
2015: LD_VAR 0 4
2019: PPUSH
2020: LD_INT 1
2022: PPUSH
2023: LD_VAR 0 3
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
// end ;
2033: GO 1897
2035: POP
2036: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2037: LD_EXP 37
2041: PPUSH
2042: LD_INT 194
2044: PPUSH
2045: LD_INT 119
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 48
// if tmp then
2055: LD_VAR 0 4
2059: IFFALSE 2184
// begin for i in tmp do
2061: LD_ADDR_VAR 0 2
2065: PUSH
2066: LD_VAR 0 4
2070: PUSH
2071: FOR_IN
2072: IFFALSE 2182
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2074: LD_ADDR_VAR 0 8
2078: PUSH
2079: LD_INT 22
2081: PUSH
2082: LD_INT 1
2084: PUSH
2085: EMPTY
2086: LIST
2087: LIST
2088: PUSH
2089: LD_INT 21
2091: PUSH
2092: LD_INT 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: PUSH
2099: LD_INT 58
2101: PUSH
2102: EMPTY
2103: LIST
2104: PUSH
2105: EMPTY
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL_OW 69
2114: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2115: LD_VAR 0 2
2119: PPUSH
2120: CALL_OW 247
2124: PUSH
2125: LD_INT 1
2127: EQUAL
2128: PUSH
2129: LD_VAR 0 8
2133: AND
2134: IFFALSE 2156
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2136: LD_VAR 0 2
2140: PPUSH
2141: LD_VAR 0 8
2145: PUSH
2146: LD_INT 1
2148: ARRAY
2149: PPUSH
2150: CALL_OW 52
2154: GO 2171
// PlaceUnitArea ( i , startArea , false ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: LD_INT 1
2163: PPUSH
2164: LD_INT 0
2166: PPUSH
2167: CALL_OW 49
// ComHold ( i ) ;
2171: LD_VAR 0 2
2175: PPUSH
2176: CALL_OW 140
// end ;
2180: GO 2071
2182: POP
2183: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2184: LD_ADDR_EXP 7
2188: PUSH
2189: LD_STRING 02_mikhailStatus_1
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 30
2199: ST_TO_ADDR
// if not bierezov_exist and not debug then
2200: LD_EXP 7
2204: NOT
2205: PUSH
2206: LD_EXP 1
2210: NOT
2211: AND
2212: IFFALSE 2216
// exit ;
2214: GO 2247
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2216: LD_ADDR_EXP 45
2220: PUSH
2221: LD_STRING Mikhail
2223: PPUSH
2224: LD_INT 0
2226: PPUSH
2227: CALL 489 0 2
2231: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2232: LD_EXP 45
2236: PPUSH
2237: LD_INT 1
2239: PPUSH
2240: LD_INT 0
2242: PPUSH
2243: CALL_OW 49
// end ;
2247: LD_VAR 0 1
2251: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2252: LD_INT 0
2254: PPUSH
2255: PPUSH
2256: PPUSH
2257: PPUSH
// uc_side := 4 ;
2258: LD_ADDR_OWVAR 20
2262: PUSH
2263: LD_INT 4
2265: ST_TO_ADDR
// uc_nation := 1 ;
2266: LD_ADDR_OWVAR 21
2270: PUSH
2271: LD_INT 1
2273: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2274: LD_ADDR_EXP 44
2278: PUSH
2279: LD_STRING Cornell
2281: PPUSH
2282: LD_INT 0
2284: PPUSH
2285: CALL 489 0 2
2289: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2290: LD_ADDR_EXP 6
2294: PUSH
2295: LD_INT 9
2297: PUSH
2298: LD_EXP 4
2302: MINUS
2303: ST_TO_ADDR
// tmp := [ ] ;
2304: LD_ADDR_VAR 0 2
2308: PUSH
2309: EMPTY
2310: ST_TO_ADDR
// if cornel_units < 4 then
2311: LD_EXP 6
2315: PUSH
2316: LD_INT 4
2318: LESS
2319: IFFALSE 2329
// cornel_units := 4 ;
2321: LD_ADDR_EXP 6
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// for i = 1 to cornel_units do
2329: LD_ADDR_VAR 0 4
2333: PUSH
2334: DOUBLE
2335: LD_INT 1
2337: DEC
2338: ST_TO_ADDR
2339: LD_EXP 6
2343: PUSH
2344: FOR_TO
2345: IFFALSE 2443
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2347: LD_INT 0
2349: PPUSH
2350: LD_INT 1
2352: PUSH
2353: LD_INT 1
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 2
2361: PUSH
2362: LD_INT 4
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: PUSH
2372: LD_VAR 0 4
2376: PUSH
2377: LD_INT 5
2379: MOD
2380: PUSH
2381: LD_INT 1
2383: PLUS
2384: ARRAY
2385: PPUSH
2386: LD_INT 2
2388: PPUSH
2389: CALL_OW 380
// un := CreateHuman ;
2393: LD_ADDR_VAR 0 3
2397: PUSH
2398: CALL_OW 44
2402: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2403: LD_ADDR_VAR 0 2
2407: PUSH
2408: LD_VAR 0 2
2412: PPUSH
2413: LD_INT 1
2415: PPUSH
2416: LD_VAR 0 3
2420: PPUSH
2421: CALL_OW 2
2425: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2426: LD_VAR 0 3
2430: PPUSH
2431: LD_INT 2
2433: PPUSH
2434: LD_INT 0
2436: PPUSH
2437: CALL_OW 49
// end ;
2441: GO 2344
2443: POP
2444: POP
// cornel_units := tmp ;
2445: LD_ADDR_EXP 6
2449: PUSH
2450: LD_VAR 0 2
2454: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2455: LD_EXP 44
2459: PPUSH
2460: LD_INT 191
2462: PPUSH
2463: LD_INT 106
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL_OW 48
// end ;
2473: LD_VAR 0 1
2477: RET
// export function PrepareWesternBase ; var i ; begin
2478: LD_INT 0
2480: PPUSH
2481: PPUSH
// uc_side := 8 ;
2482: LD_ADDR_OWVAR 20
2486: PUSH
2487: LD_INT 8
2489: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2490: LD_ADDR_EXP 47
2494: PUSH
2495: LD_STRING Lynch
2497: PPUSH
2498: LD_INT 0
2500: PPUSH
2501: CALL 489 0 2
2505: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2506: LD_ADDR_EXP 48
2510: PUSH
2511: LD_STRING Walker
2513: PPUSH
2514: LD_INT 0
2516: PPUSH
2517: CALL 489 0 2
2521: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2522: LD_ADDR_EXP 49
2526: PUSH
2527: LD_STRING Turner
2529: PPUSH
2530: LD_INT 0
2532: PPUSH
2533: CALL 489 0 2
2537: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2538: LD_ADDR_EXP 50
2542: PUSH
2543: LD_STRING Jillian
2545: PPUSH
2546: LD_INT 0
2548: PPUSH
2549: CALL 489 0 2
2553: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2554: LD_ADDR_VAR 0 2
2558: PUSH
2559: LD_EXP 47
2563: PUSH
2564: LD_EXP 48
2568: PUSH
2569: LD_EXP 49
2573: PUSH
2574: LD_EXP 50
2578: PUSH
2579: EMPTY
2580: LIST
2581: LIST
2582: LIST
2583: LIST
2584: PUSH
2585: FOR_IN
2586: IFFALSE 2614
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: LD_INT 3
2595: PPUSH
2596: LD_INT 0
2598: PPUSH
2599: CALL_OW 49
// ComHold ( i ) ;
2603: LD_VAR 0 2
2607: PPUSH
2608: CALL_OW 140
// end ;
2612: GO 2585
2614: POP
2615: POP
// end ;
2616: LD_VAR 0 1
2620: RET
// export function SelectGroup ; var units , selected , i ; begin
2621: LD_INT 0
2623: PPUSH
2624: PPUSH
2625: PPUSH
2626: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_EXP 37
2636: PUSH
2637: LD_INT -3
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: PUSH
2644: LD_EXP 4
2648: ADD
2649: PUSH
2650: LD_INT -2
2652: PUSH
2653: LD_INT -4
2655: PUSH
2656: LD_EXP 44
2660: PUSH
2661: LD_EXP 45
2665: PUSH
2666: EMPTY
2667: LIST
2668: LIST
2669: LIST
2670: LIST
2671: ADD
2672: PUSH
2673: LD_INT -3
2675: PUSH
2676: EMPTY
2677: LIST
2678: ADD
2679: PUSH
2680: LD_EXP 6
2684: ADD
2685: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2686: LD_ADDR_VAR 0 3
2690: PUSH
2691: LD_EXP 37
2695: PUSH
2696: LD_STRING Select five characters to go with you
2698: PPUSH
2699: LD_INT 4
2701: PPUSH
2702: LD_INT 4
2704: PPUSH
2705: LD_VAR 0 2
2709: PPUSH
2710: EMPTY
2711: PPUSH
2712: CALL_OW 42
2716: ADD
2717: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2718: LD_ADDR_EXP 6
2722: PUSH
2723: LD_EXP 4
2727: PUSH
2728: LD_EXP 6
2732: UNION
2733: PUSH
2734: LD_VAR 0 3
2738: DIFF
2739: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2740: LD_ADDR_VAR 0 4
2744: PUSH
2745: LD_EXP 6
2749: PUSH
2750: LD_EXP 45
2754: ADD
2755: PUSH
2756: FOR_IN
2757: IFFALSE 2788
// if GetSide ( i ) = 1 then
2759: LD_VAR 0 4
2763: PPUSH
2764: CALL_OW 255
2768: PUSH
2769: LD_INT 1
2771: EQUAL
2772: IFFALSE 2786
// SetSide ( i , 4 ) ;
2774: LD_VAR 0 4
2778: PPUSH
2779: LD_INT 4
2781: PPUSH
2782: CALL_OW 235
2786: GO 2756
2788: POP
2789: POP
// for i in selected do
2790: LD_ADDR_VAR 0 4
2794: PUSH
2795: LD_VAR 0 3
2799: PUSH
2800: FOR_IN
2801: IFFALSE 2832
// if GetSide ( i ) = 4 then
2803: LD_VAR 0 4
2807: PPUSH
2808: CALL_OW 255
2812: PUSH
2813: LD_INT 4
2815: EQUAL
2816: IFFALSE 2830
// SetSide ( i , 1 ) ;
2818: LD_VAR 0 4
2822: PPUSH
2823: LD_INT 1
2825: PPUSH
2826: CALL_OW 235
2830: GO 2800
2832: POP
2833: POP
// jmm_units := jmm_units diff cornel_units ;
2834: LD_ADDR_EXP 4
2838: PUSH
2839: LD_EXP 4
2843: PUSH
2844: LD_EXP 6
2848: DIFF
2849: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2850: LD_EXP 38
2854: PPUSH
2855: CALL_OW 255
2859: PUSH
2860: LD_INT 4
2862: EQUAL
2863: IFFALSE 2878
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2865: LD_EXP 3
2869: PUSH
2870: LD_STRING Bobby
2872: STR
2873: PPUSH
2874: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2878: LD_EXP 39
2882: PPUSH
2883: CALL_OW 255
2887: PUSH
2888: LD_INT 4
2890: EQUAL
2891: IFFALSE 2906
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2893: LD_EXP 3
2897: PUSH
2898: LD_STRING Cyrus
2900: STR
2901: PPUSH
2902: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2906: LD_EXP 40
2910: PPUSH
2911: CALL_OW 255
2915: PUSH
2916: LD_INT 4
2918: EQUAL
2919: IFFALSE 2934
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2921: LD_EXP 3
2925: PUSH
2926: LD_STRING Lisa
2928: STR
2929: PPUSH
2930: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2934: LD_EXP 41
2938: PPUSH
2939: CALL_OW 255
2943: PUSH
2944: LD_INT 4
2946: EQUAL
2947: IFFALSE 2962
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2949: LD_EXP 3
2953: PUSH
2954: LD_STRING Khatam
2956: STR
2957: PPUSH
2958: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2962: LD_EXP 42
2966: PPUSH
2967: CALL_OW 255
2971: PUSH
2972: LD_INT 4
2974: EQUAL
2975: IFFALSE 2990
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2977: LD_EXP 3
2981: PUSH
2982: LD_STRING Brian
2984: STR
2985: PPUSH
2986: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2990: LD_EXP 43
2994: PPUSH
2995: CALL_OW 255
2999: PUSH
3000: LD_INT 4
3002: EQUAL
3003: IFFALSE 3018
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
3005: LD_EXP 3
3009: PUSH
3010: LD_STRING Jerry
3012: STR
3013: PPUSH
3014: CALL_OW 40
// end ; end_of_file
3018: LD_VAR 0 1
3022: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3023: LD_INT 0
3025: PPUSH
3026: PPUSH
3027: PPUSH
3028: PPUSH
3029: PPUSH
3030: PPUSH
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
3035: PPUSH
3036: PPUSH
3037: PPUSH
// ru_alert := false ;
3038: LD_ADDR_EXP 60
3042: PUSH
3043: LD_INT 0
3045: ST_TO_ADDR
// ru_produce_list := [ ] ;
3046: LD_ADDR_EXP 57
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if Difficulty > 1 then
3053: LD_OWVAR 67
3057: PUSH
3058: LD_INT 1
3060: GREATER
3061: IFFALSE 3149
// begin uc_side := 3 ;
3063: LD_ADDR_OWVAR 20
3067: PUSH
3068: LD_INT 3
3070: ST_TO_ADDR
// uc_nation := 3 ;
3071: LD_ADDR_OWVAR 21
3075: PUSH
3076: LD_INT 3
3078: ST_TO_ADDR
// bc_type := b_breastwork ;
3079: LD_ADDR_OWVAR 42
3083: PUSH
3084: LD_INT 31
3086: ST_TO_ADDR
// bc_level := Difficulty ;
3087: LD_ADDR_OWVAR 43
3091: PUSH
3092: LD_OWVAR 67
3096: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3097: LD_INT 22
3099: PPUSH
3100: LD_INT 14
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3110: LD_INT 48
3112: PPUSH
3113: LD_INT 46
3115: PPUSH
3116: LD_INT 0
3118: PPUSH
3119: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3123: LD_INT 86
3125: PPUSH
3126: LD_INT 65
3128: PPUSH
3129: LD_INT 5
3131: PPUSH
3132: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3136: LD_INT 165
3138: PPUSH
3139: LD_INT 73
3141: PPUSH
3142: LD_INT 5
3144: PPUSH
3145: CALL_OW 47
// end ; if Difficulty = 3 then
3149: LD_OWVAR 67
3153: PUSH
3154: LD_INT 3
3156: EQUAL
3157: IFFALSE 3172
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3159: LD_INT 51
3161: PPUSH
3162: LD_INT 3
3164: PPUSH
3165: LD_INT 2
3167: PPUSH
3168: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3172: LD_ADDR_VAR 0 7
3176: PUSH
3177: LD_INT 22
3179: PUSH
3180: LD_INT 3
3182: PUSH
3183: EMPTY
3184: LIST
3185: LIST
3186: PUSH
3187: LD_INT 2
3189: PUSH
3190: LD_INT 30
3192: PUSH
3193: LD_INT 31
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 30
3202: PUSH
3203: LD_INT 32
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: LIST
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: PPUSH
3219: CALL_OW 69
3223: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3224: LD_ADDR_VAR 0 8
3228: PUSH
3229: LD_INT 22
3231: PUSH
3232: LD_INT 3
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: PUSH
3239: LD_INT 30
3241: PUSH
3242: LD_INT 4
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PPUSH
3253: CALL_OW 69
3257: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3258: LD_ADDR_VAR 0 10
3262: PUSH
3263: LD_INT 22
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: LD_INT 30
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: PPUSH
3287: CALL_OW 69
3291: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3292: LD_ADDR_VAR 0 9
3296: PUSH
3297: LD_INT 22
3299: PUSH
3300: LD_INT 3
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 30
3309: PUSH
3310: LD_INT 6
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 69
3325: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_INT 22
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: PUSH
3341: LD_INT 30
3343: PUSH
3344: LD_INT 1
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: PPUSH
3355: CALL_OW 69
3359: PUSH
3360: FOR_IN
3361: IFFALSE 3405
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3363: LD_VAR 0 2
3367: PPUSH
3368: CALL_OW 274
3372: PPUSH
3373: LD_INT 1
3375: PPUSH
3376: LD_INT 5000
3378: PPUSH
3379: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3383: LD_VAR 0 2
3387: PPUSH
3388: CALL_OW 274
3392: PPUSH
3393: LD_INT 2
3395: PPUSH
3396: LD_INT 3000
3398: PPUSH
3399: CALL_OW 277
// end ;
3403: GO 3360
3405: POP
3406: POP
// uc_side := 3 ;
3407: LD_ADDR_OWVAR 20
3411: PUSH
3412: LD_INT 3
3414: ST_TO_ADDR
// uc_nation := 3 ;
3415: LD_ADDR_OWVAR 21
3419: PUSH
3420: LD_INT 3
3422: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3423: LD_ADDR_VAR 0 11
3427: PUSH
3428: LD_INT 2
3430: PUSH
3431: LD_INT 3
3433: PUSH
3434: LD_INT 4
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: LIST
3441: PUSH
3442: LD_OWVAR 67
3446: ARRAY
3447: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3448: LD_ADDR_EXP 52
3452: PUSH
3453: LD_STRING Pokryshkin
3455: PPUSH
3456: LD_INT 0
3458: PPUSH
3459: CALL 489 0 2
3463: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3464: LD_EXP 52
3468: PPUSH
3469: LD_INT 63
3471: PPUSH
3472: LD_INT 21
3474: PPUSH
3475: LD_INT 0
3477: PPUSH
3478: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3482: LD_EXP 52
3486: PPUSH
3487: CALL_OW 140
// InitHc ;
3491: CALL_OW 19
// for i in fac do
3495: LD_ADDR_VAR 0 2
3499: PUSH
3500: LD_VAR 0 10
3504: PUSH
3505: FOR_IN
3506: IFFALSE 3559
// begin for j = 1 to 6 do
3508: LD_ADDR_VAR 0 3
3512: PUSH
3513: DOUBLE
3514: LD_INT 1
3516: DEC
3517: ST_TO_ADDR
3518: LD_INT 6
3520: PUSH
3521: FOR_TO
3522: IFFALSE 3555
// begin PrepareHuman ( false , 3 , skill ) ;
3524: LD_INT 0
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_VAR 0 11
3534: PPUSH
3535: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3539: CALL_OW 44
3543: PPUSH
3544: LD_VAR 0 2
3548: PPUSH
3549: CALL_OW 52
// end ;
3553: GO 3521
3555: POP
3556: POP
// end ;
3557: GO 3505
3559: POP
3560: POP
// for i in lab do
3561: LD_ADDR_VAR 0 2
3565: PUSH
3566: LD_VAR 0 9
3570: PUSH
3571: FOR_IN
3572: IFFALSE 3605
// begin PrepareHuman ( false , 4 , skill ) ;
3574: LD_INT 0
3576: PPUSH
3577: LD_INT 4
3579: PPUSH
3580: LD_VAR 0 11
3584: PPUSH
3585: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3589: CALL_OW 44
3593: PPUSH
3594: LD_VAR 0 2
3598: PPUSH
3599: CALL_OW 52
// end ;
3603: GO 3571
3605: POP
3606: POP
// for i in tw do
3607: LD_ADDR_VAR 0 2
3611: PUSH
3612: LD_VAR 0 7
3616: PUSH
3617: FOR_IN
3618: IFFALSE 3667
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3620: LD_VAR 0 2
3624: PPUSH
3625: LD_INT 42
3627: PUSH
3628: LD_INT 43
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 1
3637: PPUSH
3638: LD_INT 2
3640: PPUSH
3641: CALL_OW 12
3645: ARRAY
3646: PPUSH
3647: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3651: LD_VAR 0 11
3655: PPUSH
3656: LD_VAR 0 2
3660: PPUSH
3661: CALL 830 0 2
// end ;
3665: GO 3617
3667: POP
3668: POP
// for i in bar do
3669: LD_ADDR_VAR 0 2
3673: PUSH
3674: LD_VAR 0 8
3678: PUSH
3679: FOR_IN
3680: IFFALSE 3713
// begin PrepareHuman ( false , 1 , skill ) ;
3682: LD_INT 0
3684: PPUSH
3685: LD_INT 1
3687: PPUSH
3688: LD_VAR 0 11
3692: PPUSH
3693: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3697: CALL_OW 44
3701: PPUSH
3702: LD_VAR 0 2
3706: PPUSH
3707: CALL_OW 52
// end ;
3711: GO 3679
3713: POP
3714: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3715: LD_ADDR_VAR 0 13
3719: PUSH
3720: LD_INT 100
3722: PUSH
3723: LD_INT 9
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: PUSH
3730: LD_INT 135
3732: PUSH
3733: LD_INT 60
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 41
3742: PUSH
3743: LD_INT 6
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 22
3752: PUSH
3753: LD_INT 9
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PUSH
3760: LD_INT 84
3762: PUSH
3763: LD_INT 14
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: LIST
3774: LIST
3775: LIST
3776: ST_TO_ADDR
// vehicles := [ ] ;
3777: LD_ADDR_VAR 0 12
3781: PUSH
3782: EMPTY
3783: ST_TO_ADDR
// for i in spot_xy do
3784: LD_ADDR_VAR 0 2
3788: PUSH
3789: LD_VAR 0 13
3793: PUSH
3794: FOR_IN
3795: IFFALSE 3953
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3797: LD_ADDR_VAR 0 6
3801: PUSH
3802: LD_INT 3
3804: PPUSH
3805: LD_INT 3
3807: PPUSH
3808: LD_INT 22
3810: PPUSH
3811: LD_INT 1
3813: PPUSH
3814: LD_INT 1
3816: PPUSH
3817: LD_INT 42
3819: PUSH
3820: LD_INT 43
3822: PUSH
3823: LD_INT 44
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: LIST
3830: PUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 12
3841: ARRAY
3842: PPUSH
3843: LD_INT 100
3845: PPUSH
3846: CALL 552 0 7
3850: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3851: LD_ADDR_VAR 0 12
3855: PUSH
3856: LD_VAR 0 12
3860: PPUSH
3861: LD_VAR 0 12
3865: PUSH
3866: LD_INT 1
3868: PLUS
3869: PPUSH
3870: LD_VAR 0 6
3874: PPUSH
3875: CALL_OW 2
3879: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3880: LD_VAR 0 6
3884: PPUSH
3885: LD_INT 3
3887: PPUSH
3888: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3892: LD_VAR 0 6
3896: PPUSH
3897: LD_VAR 0 2
3901: PUSH
3902: LD_INT 1
3904: ARRAY
3905: PPUSH
3906: LD_VAR 0 2
3910: PUSH
3911: LD_INT 2
3913: ARRAY
3914: PPUSH
3915: LD_INT 0
3917: PPUSH
3918: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 3
3927: PPUSH
3928: LD_VAR 0 11
3932: PPUSH
3933: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3937: CALL_OW 44
3941: PPUSH
3942: LD_VAR 0 6
3946: PPUSH
3947: CALL_OW 52
// end ;
3951: GO 3794
3953: POP
3954: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3955: LD_ADDR_VAR 0 2
3959: PUSH
3960: DOUBLE
3961: LD_INT 1
3963: DEC
3964: ST_TO_ADDR
3965: LD_INT 5
3967: PUSH
3968: LD_INT 7
3970: PUSH
3971: LD_INT 8
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: PUSH
3979: LD_OWVAR 67
3983: ARRAY
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4046
// begin PrepareHuman ( false , 1 , skill ) ;
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 1
3993: PPUSH
3994: LD_VAR 0 11
3998: PPUSH
3999: CALL_OW 380
// un := CreateHuman ;
4003: LD_ADDR_VAR 0 5
4007: PUSH
4008: CALL_OW 44
4012: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
4013: LD_VAR 0 5
4017: PPUSH
4018: LD_INT 11
4020: PPUSH
4021: LD_INT 0
4023: PPUSH
4024: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4028: LD_ADDR_EXP 55
4032: PUSH
4033: LD_EXP 55
4037: PUSH
4038: LD_VAR 0 5
4042: ADD
4043: ST_TO_ADDR
// end ;
4044: GO 3985
4046: POP
4047: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4048: LD_ADDR_VAR 0 2
4052: PUSH
4053: DOUBLE
4054: LD_INT 1
4056: DEC
4057: ST_TO_ADDR
4058: LD_INT 2
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PUSH
4072: LD_OWVAR 67
4076: ARRAY
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4139
// begin PrepareHuman ( false , 1 , skill ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: LD_VAR 0 11
4091: PPUSH
4092: CALL_OW 380
// un := CreateHuman ;
4096: LD_ADDR_VAR 0 5
4100: PUSH
4101: CALL_OW 44
4105: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4106: LD_VAR 0 5
4110: PPUSH
4111: LD_INT 12
4113: PPUSH
4114: LD_INT 0
4116: PPUSH
4117: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4121: LD_ADDR_EXP 53
4125: PUSH
4126: LD_EXP 53
4130: PUSH
4131: LD_VAR 0 5
4135: ADD
4136: ST_TO_ADDR
// end ;
4137: GO 4078
4139: POP
4140: POP
// for i = 1 to 2 do
4141: LD_ADDR_VAR 0 2
4145: PUSH
4146: DOUBLE
4147: LD_INT 1
4149: DEC
4150: ST_TO_ADDR
4151: LD_INT 2
4153: PUSH
4154: FOR_TO
4155: IFFALSE 4221
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4157: LD_INT 1
4159: PPUSH
4160: LD_INT 1
4162: PPUSH
4163: LD_VAR 0 11
4167: PPUSH
4168: CALL_OW 380
// un := CreateHuman ;
4172: LD_ADDR_VAR 0 5
4176: PUSH
4177: CALL_OW 44
4181: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4182: LD_VAR 0 5
4186: PPUSH
4187: LD_INT 39
4189: PPUSH
4190: LD_INT 12
4192: PPUSH
4193: LD_INT 3
4195: PPUSH
4196: LD_INT 0
4198: PPUSH
4199: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4203: LD_ADDR_EXP 54
4207: PUSH
4208: LD_EXP 54
4212: PUSH
4213: LD_VAR 0 5
4217: ADD
4218: ST_TO_ADDR
// end ;
4219: GO 4154
4221: POP
4222: POP
// for i = 1 to 3 do
4223: LD_ADDR_VAR 0 2
4227: PUSH
4228: DOUBLE
4229: LD_INT 1
4231: DEC
4232: ST_TO_ADDR
4233: LD_INT 3
4235: PUSH
4236: FOR_TO
4237: IFFALSE 4303
// begin PrepareHuman ( false , 1 , skill ) ;
4239: LD_INT 0
4241: PPUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_VAR 0 11
4249: PPUSH
4250: CALL_OW 380
// un := CreateHuman ;
4254: LD_ADDR_VAR 0 5
4258: PUSH
4259: CALL_OW 44
4263: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4264: LD_VAR 0 5
4268: PPUSH
4269: LD_INT 180
4271: PPUSH
4272: LD_INT 11
4274: PPUSH
4275: LD_INT 4
4277: PPUSH
4278: LD_INT 0
4280: PPUSH
4281: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4285: LD_ADDR_EXP 58
4289: PUSH
4290: LD_EXP 58
4294: PUSH
4295: LD_VAR 0 5
4299: ADD
4300: ST_TO_ADDR
// end ;
4301: GO 4236
4303: POP
4304: POP
// ru_vehicles := vehicles ;
4305: LD_ADDR_EXP 56
4309: PUSH
4310: LD_VAR 0 12
4314: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: LD_INT 131
4322: PUSH
4323: LD_INT 121
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: LD_INT 113
4332: PUSH
4333: LD_INT 90
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 93
4342: PUSH
4343: LD_INT 62
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: LIST
4354: PUSH
4355: LD_INT 106
4357: PUSH
4358: LD_INT 54
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: PUSH
4365: LD_INT 120
4367: PUSH
4368: LD_INT 80
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 143
4377: PUSH
4378: LD_INT 120
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: LIST
4389: PUSH
4390: LD_INT 154
4392: PUSH
4393: LD_INT 116
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PUSH
4400: LD_INT 140
4402: PUSH
4403: LD_INT 93
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 130
4412: PUSH
4413: LD_INT 58
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 105
4427: PUSH
4428: LD_INT 106
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 134
4437: PUSH
4438: LD_INT 98
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PUSH
4445: LD_INT 159
4447: PUSH
4448: LD_INT 113
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PUSH
4455: EMPTY
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: LIST
4464: LIST
4465: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4466: LD_ADDR_VAR 0 2
4470: PUSH
4471: DOUBLE
4472: LD_INT 1
4474: DEC
4475: ST_TO_ADDR
4476: LD_OWVAR 67
4480: PUSH
4481: LD_INT 1
4483: MINUS
4484: PUSH
4485: FOR_TO
4486: IFFALSE 4519
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4488: LD_ADDR_EXP 57
4492: PUSH
4493: LD_EXP 57
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 1
4503: PUSH
4504: LD_INT 1
4506: PUSH
4507: LD_INT 43
4509: PUSH
4510: EMPTY
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: ADD
4516: ST_TO_ADDR
4517: GO 4485
4519: POP
4520: POP
// end ;
4521: LD_VAR 0 1
4525: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4526: LD_INT 22
4528: PUSH
4529: LD_INT 3
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: LD_INT 21
4538: PUSH
4539: LD_INT 2
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: IFFALSE 4648
4556: GO 4558
4558: DISABLE
4559: LD_INT 0
4561: PPUSH
4562: PPUSH
// begin enable ;
4563: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4564: LD_ADDR_VAR 0 2
4568: PUSH
4569: LD_INT 22
4571: PUSH
4572: LD_INT 3
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 21
4581: PUSH
4582: LD_INT 2
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: PUSH
4589: EMPTY
4590: LIST
4591: LIST
4592: PPUSH
4593: CALL_OW 69
4597: ST_TO_ADDR
// if filter then
4598: LD_VAR 0 2
4602: IFFALSE 4648
// for i in filter do
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: FOR_IN
4615: IFFALSE 4646
// if GetFuel ( i ) < 20 then
4617: LD_VAR 0 1
4621: PPUSH
4622: CALL_OW 261
4626: PUSH
4627: LD_INT 20
4629: LESS
4630: IFFALSE 4644
// SetFuel ( i , 20 ) ;
4632: LD_VAR 0 1
4636: PPUSH
4637: LD_INT 20
4639: PPUSH
4640: CALL_OW 240
4644: GO 4614
4646: POP
4647: POP
// end ;
4648: PPOPN 2
4650: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4651: LD_EXP 57
4655: IFFALSE 4874
4657: GO 4659
4659: DISABLE
4660: LD_INT 0
4662: PPUSH
4663: PPUSH
4664: PPUSH
// begin enable ;
4665: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4666: LD_ADDR_VAR 0 2
4670: PUSH
4671: LD_INT 22
4673: PUSH
4674: LD_INT 3
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PUSH
4681: LD_INT 30
4683: PUSH
4684: LD_INT 3
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PPUSH
4695: CALL_OW 69
4699: ST_TO_ADDR
// can_produce := [ ] ;
4700: LD_ADDR_VAR 0 3
4704: PUSH
4705: EMPTY
4706: ST_TO_ADDR
// if not fac then
4707: LD_VAR 0 2
4711: NOT
4712: IFFALSE 4717
// begin disable ;
4714: DISABLE
// exit ;
4715: GO 4874
// end ; for i in fac do
4717: LD_ADDR_VAR 0 1
4721: PUSH
4722: LD_VAR 0 2
4726: PUSH
4727: FOR_IN
4728: IFFALSE 4766
// if UnitsInside ( i ) then
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 313
4739: IFFALSE 4764
// can_produce := Insert ( can_produce , 1 , i ) ;
4741: LD_ADDR_VAR 0 3
4745: PUSH
4746: LD_VAR 0 3
4750: PPUSH
4751: LD_INT 1
4753: PPUSH
4754: LD_VAR 0 1
4758: PPUSH
4759: CALL_OW 2
4763: ST_TO_ADDR
4764: GO 4727
4766: POP
4767: POP
// if not can_produce then
4768: LD_VAR 0 3
4772: NOT
4773: IFFALSE 4777
// exit ;
4775: GO 4874
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4777: LD_VAR 0 3
4781: PUSH
4782: LD_INT 1
4784: PPUSH
4785: LD_VAR 0 3
4789: PPUSH
4790: CALL_OW 12
4794: ARRAY
4795: PPUSH
4796: LD_EXP 57
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_EXP 57
4809: PUSH
4810: LD_INT 2
4812: ARRAY
4813: PPUSH
4814: LD_EXP 57
4818: PUSH
4819: LD_INT 3
4821: ARRAY
4822: PPUSH
4823: LD_EXP 57
4827: PUSH
4828: LD_INT 4
4830: ARRAY
4831: PPUSH
4832: CALL_OW 125
// for i = 1 to 4 do
4836: LD_ADDR_VAR 0 1
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_INT 4
4848: PUSH
4849: FOR_TO
4850: IFFALSE 4872
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4852: LD_ADDR_EXP 57
4856: PUSH
4857: LD_EXP 57
4861: PPUSH
4862: LD_INT 1
4864: PPUSH
4865: CALL_OW 3
4869: ST_TO_ADDR
4870: GO 4849
4872: POP
4873: POP
// end ;
4874: PPOPN 3
4876: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4877: LD_INT 0
4879: PPUSH
4880: PPUSH
4881: PPUSH
// for i = 1 to 6 do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: DOUBLE
4888: LD_INT 1
4890: DEC
4891: ST_TO_ADDR
4892: LD_INT 6
4894: PUSH
4895: FOR_TO
4896: IFFALSE 5045
// begin PrepareHuman ( false , 3 , 3 ) ;
4898: LD_INT 0
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_INT 3
4918: PPUSH
4919: LD_INT 3
4921: PPUSH
4922: LD_INT 22
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 1
4930: PPUSH
4931: LD_INT 43
4933: PUSH
4934: LD_INT 42
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: PUSH
4941: LD_INT 1
4943: PPUSH
4944: LD_INT 2
4946: PPUSH
4947: CALL_OW 12
4951: ARRAY
4952: PPUSH
4953: LD_INT 70
4955: PPUSH
4956: CALL 552 0 7
4960: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4961: LD_VAR 0 3
4965: PPUSH
4966: LD_INT 4
4968: PPUSH
4969: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4973: LD_VAR 0 3
4977: PPUSH
4978: LD_INT 229
4980: PPUSH
4981: LD_INT 44
4983: PPUSH
4984: LD_INT 0
4986: PPUSH
4987: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4991: CALL_OW 44
4995: PPUSH
4996: LD_VAR 0 3
5000: PPUSH
5001: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
5005: LD_ADDR_EXP 56
5009: PUSH
5010: LD_EXP 56
5014: PUSH
5015: LD_VAR 0 3
5019: ADD
5020: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5021: LD_VAR 0 3
5025: PPUSH
5026: LD_INT 191
5028: PPUSH
5029: LD_INT 32
5031: PPUSH
5032: CALL_OW 111
// Wait ( 0 0$02 ) ;
5036: LD_INT 70
5038: PPUSH
5039: CALL_OW 67
// end ;
5043: GO 4895
5045: POP
5046: POP
// end ;
5047: LD_VAR 0 1
5051: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5052: LD_EXP 31
5056: PUSH
5057: LD_EXP 56
5061: AND
5062: IFFALSE 5236
5064: GO 5066
5066: DISABLE
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin wait ( 0 0$50 ) ;
5072: LD_INT 1750
5074: PPUSH
5075: CALL_OW 67
// tmp := ru_vehicles ;
5079: LD_ADDR_VAR 0 3
5083: PUSH
5084: LD_EXP 56
5088: ST_TO_ADDR
// if not tmp then
5089: LD_VAR 0 3
5093: NOT
5094: IFFALSE 5098
// exit ;
5096: GO 5236
// repeat wait ( 0 0$1 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// for i in tmp do
5105: LD_ADDR_VAR 0 1
5109: PUSH
5110: LD_VAR 0 3
5114: PUSH
5115: FOR_IN
5116: IFFALSE 5227
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5118: LD_ADDR_VAR 0 2
5122: PUSH
5123: LD_INT 22
5125: PUSH
5126: LD_INT 1
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PPUSH
5133: LD_VAR 0 1
5137: PPUSH
5138: CALL_OW 74
5142: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5143: LD_VAR 0 1
5147: PPUSH
5148: LD_VAR 0 2
5152: PPUSH
5153: CALL_OW 296
5157: PUSH
5158: LD_INT 10
5160: GREATER
5161: IFFALSE 5180
// ComAgressiveMove ( i , 69 , 101 ) else
5163: LD_VAR 0 1
5167: PPUSH
5168: LD_INT 69
5170: PPUSH
5171: LD_INT 101
5173: PPUSH
5174: CALL_OW 114
5178: GO 5194
// ComAttackUnit ( i , enemy ) ;
5180: LD_VAR 0 1
5184: PPUSH
5185: LD_VAR 0 2
5189: PPUSH
5190: CALL_OW 115
// if GetLives ( i ) < 250 then
5194: LD_VAR 0 1
5198: PPUSH
5199: CALL_OW 256
5203: PUSH
5204: LD_INT 250
5206: LESS
5207: IFFALSE 5225
// tmp := tmp diff i ;
5209: LD_ADDR_VAR 0 3
5213: PUSH
5214: LD_VAR 0 3
5218: PUSH
5219: LD_VAR 0 1
5223: DIFF
5224: ST_TO_ADDR
// end ;
5225: GO 5115
5227: POP
5228: POP
// until not tmp ;
5229: LD_VAR 0 3
5233: NOT
5234: IFFALSE 5098
// end ; end_of_file
5236: PPOPN 3
5238: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5239: LD_INT 0
5241: PPUSH
5242: PPUSH
5243: PPUSH
5244: PPUSH
5245: PPUSH
5246: PPUSH
5247: PPUSH
// InGameOn ;
5248: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5252: LD_EXP 37
5256: PPUSH
5257: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5261: LD_EXP 37
5265: PPUSH
5266: LD_EXP 44
5270: PPUSH
5271: CALL_OW 119
// if Bierezov then
5275: LD_EXP 45
5279: IFFALSE 5295
// ComTurnUnit ( Bierezov , Cornel ) ;
5281: LD_EXP 45
5285: PPUSH
5286: LD_EXP 44
5290: PPUSH
5291: CALL_OW 119
// for i in jmm_units do
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: LD_EXP 4
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5324
// ComTurnUnit ( i , Cornel ) ;
5308: LD_VAR 0 2
5312: PPUSH
5313: LD_EXP 44
5317: PPUSH
5318: CALL_OW 119
5322: GO 5305
5324: POP
5325: POP
// units := cornel_units union Cornel ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_EXP 6
5335: PUSH
5336: LD_EXP 44
5340: UNION
5341: ST_TO_ADDR
// repeat wait ( 1 ) ;
5342: LD_INT 1
5344: PPUSH
5345: CALL_OW 67
// for i in units do
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: LD_VAR 0 3
5358: PUSH
5359: FOR_IN
5360: IFFALSE 5393
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5362: LD_VAR 0 2
5366: PPUSH
5367: LD_EXP 37
5371: PPUSH
5372: CALL_OW 250
5376: PPUSH
5377: LD_EXP 37
5381: PPUSH
5382: CALL_OW 251
5386: PPUSH
5387: CALL_OW 111
5391: GO 5359
5393: POP
5394: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5395: LD_VAR 0 3
5399: PPUSH
5400: LD_INT 92
5402: PUSH
5403: LD_EXP 37
5407: PPUSH
5408: CALL_OW 250
5412: PUSH
5413: LD_EXP 37
5417: PPUSH
5418: CALL_OW 251
5422: PUSH
5423: LD_INT 10
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: PPUSH
5432: CALL_OW 72
5436: PUSH
5437: LD_VAR 0 3
5441: EQUAL
5442: IFFALSE 5342
// for i in units do
5444: LD_ADDR_VAR 0 2
5448: PUSH
5449: LD_VAR 0 3
5453: PUSH
5454: FOR_IN
5455: IFFALSE 5473
// ComTurnUnit ( i , JMM ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_EXP 37
5466: PPUSH
5467: CALL_OW 119
5471: GO 5454
5473: POP
5474: POP
// ComTurnUnit ( Cornel , JMM ) ;
5475: LD_EXP 44
5479: PPUSH
5480: LD_EXP 37
5484: PPUSH
5485: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5489: LD_EXP 37
5493: PPUSH
5494: LD_STRING D1-JMM-1
5496: PPUSH
5497: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5501: LD_EXP 44
5505: PPUSH
5506: LD_STRING D1-Corn-1
5508: PPUSH
5509: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5513: LD_EXP 37
5517: PPUSH
5518: LD_EXP 44
5522: PPUSH
5523: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5527: LD_EXP 44
5531: PPUSH
5532: LD_EXP 37
5536: PPUSH
5537: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5541: LD_INT 35
5543: PPUSH
5544: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5548: LD_EXP 37
5552: PPUSH
5553: LD_EXP 44
5557: PPUSH
5558: CALL_OW 296
5562: PUSH
5563: LD_INT 6
5565: LESS
5566: IFFALSE 5541
// ChangeSideFog ( 4 , 1 ) ;
5568: LD_INT 4
5570: PPUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5578: LD_EXP 37
5582: PPUSH
5583: LD_EXP 44
5587: PPUSH
5588: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5592: LD_EXP 44
5596: PPUSH
5597: LD_EXP 37
5601: PPUSH
5602: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5606: LD_EXP 37
5610: PPUSH
5611: LD_STRING D1-JMM-2
5613: PPUSH
5614: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5618: LD_EXP 37
5622: PPUSH
5623: LD_STRING D1-JMM-2a
5625: PPUSH
5626: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5630: LD_EXP 44
5634: PPUSH
5635: LD_STRING D1-Corn-2
5637: PPUSH
5638: CALL_OW 88
// if bierezov_exist or debug then
5642: LD_EXP 7
5646: PUSH
5647: LD_EXP 1
5651: OR
5652: IFFALSE 5893
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5654: LD_EXP 44
5658: PPUSH
5659: LD_EXP 45
5663: PPUSH
5664: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5668: LD_INT 10
5670: PPUSH
5671: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5675: LD_EXP 44
5679: PPUSH
5680: LD_STRING D1a-Corn-1
5682: PPUSH
5683: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5687: LD_EXP 37
5691: PPUSH
5692: LD_EXP 45
5696: PPUSH
5697: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5701: LD_EXP 45
5705: PPUSH
5706: LD_EXP 37
5710: PPUSH
5711: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5715: LD_EXP 37
5719: PPUSH
5720: LD_STRING D1a-JMM-1
5722: PPUSH
5723: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5727: LD_EXP 37
5731: PPUSH
5732: LD_EXP 44
5736: PPUSH
5737: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5741: LD_EXP 44
5745: PPUSH
5746: LD_EXP 37
5750: PPUSH
5751: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5755: LD_EXP 44
5759: PPUSH
5760: LD_STRING D1a-Corn-2
5762: PPUSH
5763: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5767: LD_EXP 37
5771: PPUSH
5772: LD_STRING D1a-JMM-2
5774: PPUSH
5775: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5779: LD_EXP 44
5783: PPUSH
5784: LD_STRING D1a-Corn-3
5786: PPUSH
5787: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5791: LD_EXP 37
5795: PPUSH
5796: LD_STRING D1a-JMM-3
5798: PPUSH
5799: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5803: LD_EXP 44
5807: PPUSH
5808: LD_STRING D1a-Corn-4
5810: PPUSH
5811: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5815: LD_EXP 37
5819: PPUSH
5820: LD_STRING D1a-JMM-4
5822: PPUSH
5823: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5827: LD_EXP 44
5831: PPUSH
5832: LD_STRING D1a-Corn-5
5834: PPUSH
5835: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5839: LD_EXP 45
5843: PPUSH
5844: LD_EXP 44
5848: PPUSH
5849: CALL_OW 250
5853: PPUSH
5854: LD_EXP 44
5858: PPUSH
5859: CALL_OW 251
5863: PUSH
5864: LD_INT 2
5866: MINUS
5867: PPUSH
5868: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5872: LD_EXP 45
5876: PPUSH
5877: LD_EXP 44
5881: PPUSH
5882: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5886: LD_INT 10
5888: PPUSH
5889: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5893: LD_EXP 37
5897: PPUSH
5898: LD_STRING D1b-JMM-1
5900: PPUSH
5901: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5905: LD_EXP 44
5909: PPUSH
5910: LD_STRING D1b-Corn-1
5912: PPUSH
5913: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5917: LD_EXP 37
5921: PPUSH
5922: LD_STRING D1b-JMM-2
5924: PPUSH
5925: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5929: LD_EXP 44
5933: PPUSH
5934: LD_STRING D1b-Corn-2
5936: PPUSH
5937: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5941: LD_EXP 37
5945: PPUSH
5946: LD_STRING D1b-JMM-3
5948: PPUSH
5949: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5953: LD_INT 10
5955: PPUSH
5956: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5960: LD_EXP 46
5964: PPUSH
5965: LD_STRING D1b-Pow-3
5967: PPUSH
5968: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5972: LD_EXP 37
5976: PPUSH
5977: LD_STRING D1b-JMM-4
5979: PPUSH
5980: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5984: LD_EXP 44
5988: PPUSH
5989: LD_STRING D1b-Corn-4
5991: PPUSH
5992: CALL_OW 88
// if Khatam then
5996: LD_EXP 41
6000: IFFALSE 6016
// Say ( Khatam , D1b-Khat-4 ) else
6002: LD_EXP 41
6006: PPUSH
6007: LD_STRING D1b-Khat-4
6009: PPUSH
6010: CALL_OW 88
6014: GO 6052
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6016: LD_EXP 6
6020: PPUSH
6021: LD_INT 26
6023: PUSH
6024: LD_INT 1
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: PPUSH
6031: CALL_OW 72
6035: PUSH
6036: LD_EXP 44
6040: PUSH
6041: EMPTY
6042: LIST
6043: DIFF
6044: PPUSH
6045: LD_STRING D1b-Sol1-4
6047: PPUSH
6048: CALL 640 0 2
// if Cyrus then
6052: LD_EXP 39
6056: IFFALSE 6070
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6058: LD_EXP 39
6062: PPUSH
6063: LD_STRING D1b-Cyrus-4
6065: PPUSH
6066: CALL_OW 88
// if Lisa then
6070: LD_EXP 40
6074: IFFALSE 6132
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6076: LD_EXP 40
6080: PPUSH
6081: LD_STRING D1b-Lisa-4
6083: PPUSH
6084: CALL_OW 88
// if Cyrus then
6088: LD_EXP 39
6092: IFFALSE 6132
// begin if not IsInUnit ( Cyrus ) then
6094: LD_EXP 39
6098: PPUSH
6099: CALL_OW 310
6103: NOT
6104: IFFALSE 6120
// ComTurnUnit ( Cyrus , Lisa ) ;
6106: LD_EXP 39
6110: PPUSH
6111: LD_EXP 40
6115: PPUSH
6116: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6120: LD_EXP 39
6124: PPUSH
6125: LD_STRING D1b-Cyrus-5
6127: PPUSH
6128: CALL_OW 88
// end ; end ; SelectGroup ;
6132: CALL 2621 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6136: LD_EXP 37
6140: PPUSH
6141: LD_STRING D1d-JMM-1
6143: PPUSH
6144: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6148: LD_EXP 44
6152: PPUSH
6153: LD_STRING D1d-Corn-1
6155: PPUSH
6156: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_EXP 4
6169: PUSH
6170: LD_EXP 6
6174: ADD
6175: PUSH
6176: LD_EXP 37
6180: ADD
6181: PUSH
6182: FOR_IN
6183: IFFALSE 6196
// ComHold ( i ) ;
6185: LD_VAR 0 2
6189: PPUSH
6190: CALL_OW 140
6194: GO 6182
6196: POP
6197: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6198: LD_ADDR_VAR 0 4
6202: PUSH
6203: LD_INT 22
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 21
6215: PUSH
6216: LD_INT 2
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PPUSH
6227: CALL_OW 69
6231: ST_TO_ADDR
// if vehicles then
6232: LD_VAR 0 4
6236: IFFALSE 6574
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6238: LD_EXP 6
6242: PPUSH
6243: LD_INT 55
6245: PUSH
6246: EMPTY
6247: LIST
6248: PPUSH
6249: CALL_OW 72
6253: IFFALSE 6292
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6255: LD_ADDR_VAR 0 2
6259: PUSH
6260: LD_EXP 6
6264: PPUSH
6265: LD_INT 55
6267: PUSH
6268: EMPTY
6269: LIST
6270: PPUSH
6271: CALL_OW 72
6275: PUSH
6276: FOR_IN
6277: IFFALSE 6290
// ComExitVehicle ( i ) ;
6279: LD_VAR 0 2
6283: PPUSH
6284: CALL_OW 121
6288: GO 6276
6290: POP
6291: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6292: LD_ADDR_VAR 0 5
6296: PUSH
6297: LD_VAR 0 4
6301: PPUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 51
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL_OW 72
6316: ST_TO_ADDR
// if cargos then
6317: LD_VAR 0 5
6321: IFFALSE 6504
// begin vehicles := cargos ;
6323: LD_ADDR_VAR 0 4
6327: PUSH
6328: LD_VAR 0 5
6332: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6333: LD_ADDR_VAR 0 6
6337: PUSH
6338: LD_STRING 02_resources_4
6340: PPUSH
6341: LD_INT 0
6343: PPUSH
6344: CALL_OW 30
6348: ST_TO_ADDR
// if debug and not resources then
6349: LD_EXP 1
6353: PUSH
6354: LD_VAR 0 6
6358: NOT
6359: AND
6360: IFFALSE 6370
// resources := 160 ;
6362: LD_ADDR_VAR 0 6
6366: PUSH
6367: LD_INT 160
6369: ST_TO_ADDR
// if resources mod 10 then
6370: LD_VAR 0 6
6374: PUSH
6375: LD_INT 10
6377: MOD
6378: IFFALSE 6400
// resources := resources - resources mod 10 ;
6380: LD_ADDR_VAR 0 6
6384: PUSH
6385: LD_VAR 0 6
6389: PUSH
6390: LD_VAR 0 6
6394: PUSH
6395: LD_INT 10
6397: MOD
6398: MINUS
6399: ST_TO_ADDR
// if resources then
6400: LD_VAR 0 6
6404: IFFALSE 6504
// for i in cargos do
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 5
6415: PUSH
6416: FOR_IN
6417: IFFALSE 6502
// begin if resources < 100 then
6419: LD_VAR 0 6
6423: PUSH
6424: LD_INT 100
6426: LESS
6427: IFFALSE 6449
// begin cargo := resources ;
6429: LD_ADDR_VAR 0 7
6433: PUSH
6434: LD_VAR 0 6
6438: ST_TO_ADDR
// resources := 0 ;
6439: LD_ADDR_VAR 0 6
6443: PUSH
6444: LD_INT 0
6446: ST_TO_ADDR
// end else
6447: GO 6471
// begin cargo := 100 ;
6449: LD_ADDR_VAR 0 7
6453: PUSH
6454: LD_INT 100
6456: ST_TO_ADDR
// resources := resources - 100 ;
6457: LD_ADDR_VAR 0 6
6461: PUSH
6462: LD_VAR 0 6
6466: PUSH
6467: LD_INT 100
6469: MINUS
6470: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6471: LD_VAR 0 2
6475: PPUSH
6476: LD_INT 1
6478: PPUSH
6479: LD_VAR 0 7
6483: PPUSH
6484: CALL_OW 290
// if resources = 0 then
6488: LD_VAR 0 6
6492: PUSH
6493: LD_INT 0
6495: EQUAL
6496: IFFALSE 6500
// break ;
6498: GO 6502
// end ;
6500: GO 6416
6502: POP
6503: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6504: LD_VAR 0 4
6508: PUSH
6509: LD_INT 1
6511: ARRAY
6512: PPUSH
6513: CALL_OW 311
6517: PPUSH
6518: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 1
6529: ARRAY
6530: PPUSH
6531: LD_INT 4
6533: PPUSH
6534: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6538: LD_EXP 44
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6556: LD_INT 35
6558: PPUSH
6559: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6563: LD_EXP 44
6567: PPUSH
6568: CALL_OW 310
6572: IFFALSE 6556
// end ; InGameOff ;
6574: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6578: LD_STRING M1
6580: PPUSH
6581: CALL_OW 337
// SaveForQuickRestart ;
6585: CALL_OW 22
// cornel_active := true ;
6589: LD_ADDR_EXP 8
6593: PUSH
6594: LD_INT 1
6596: ST_TO_ADDR
// end ;
6597: LD_VAR 0 1
6601: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6602: LD_EXP 37
6606: PPUSH
6607: LD_EXP 47
6611: PPUSH
6612: CALL_OW 296
6616: PUSH
6617: LD_INT 10
6619: LESS
6620: IFFALSE 8003
6622: GO 6624
6624: DISABLE
6625: LD_INT 0
6627: PPUSH
6628: PPUSH
6629: PPUSH
6630: PPUSH
6631: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6632: LD_ADDR_VAR 0 2
6636: PUSH
6637: LD_INT 89
6639: PUSH
6640: LD_INT 34
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: LD_INT 138
6649: PUSH
6650: LD_INT 63
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 196
6659: PUSH
6660: LD_INT 84
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PUSH
6667: LD_INT 135
6669: PUSH
6670: LD_INT 52
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PUSH
6677: LD_INT 103
6679: PUSH
6680: LD_INT 39
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 58
6689: PUSH
6690: LD_INT 30
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: LD_INT 38
6699: PUSH
6700: LD_INT 51
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: ST_TO_ADDR
// Video ( true ) ;
6716: LD_INT 1
6718: PPUSH
6719: CALL 1200 0 1
// if jmm_units then
6723: LD_EXP 4
6727: IFFALSE 6803
// for i in jmm_units do
6729: LD_ADDR_VAR 0 1
6733: PUSH
6734: LD_EXP 4
6738: PUSH
6739: FOR_IN
6740: IFFALSE 6801
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_EXP 37
6751: PPUSH
6752: CALL_OW 296
6756: PUSH
6757: LD_INT 10
6759: LESS
6760: PUSH
6761: LD_VAR 0 1
6765: PPUSH
6766: CALL_OW 310
6770: NOT
6771: AND
6772: IFFALSE 6790
// ComTurnUnit ( i , JMM ) else
6774: LD_VAR 0 1
6778: PPUSH
6779: LD_EXP 37
6783: PPUSH
6784: CALL_OW 119
6788: GO 6799
// ComHold ( i ) ;
6790: LD_VAR 0 1
6794: PPUSH
6795: CALL_OW 140
// end ;
6799: GO 6739
6801: POP
6802: POP
// if IsInUnit ( JMM ) then
6803: LD_EXP 37
6807: PPUSH
6808: CALL_OW 310
6812: IFFALSE 6837
// begin ComExitVehicle ( JMM ) ;
6814: LD_EXP 37
6818: PPUSH
6819: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6823: LD_EXP 37
6827: PPUSH
6828: LD_EXP 47
6832: PPUSH
6833: CALL_OW 172
// end ; Wait ( 10 ) ;
6837: LD_INT 10
6839: PPUSH
6840: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6844: LD_EXP 37
6848: PPUSH
6849: LD_EXP 47
6853: PPUSH
6854: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6858: LD_INT 35
6860: PPUSH
6861: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6865: LD_EXP 37
6869: PPUSH
6870: LD_EXP 47
6874: PPUSH
6875: CALL_OW 296
6879: PUSH
6880: LD_INT 6
6882: LESS
6883: IFFALSE 6858
// ComTurnUnit ( JMM , Lynch ) ;
6885: LD_EXP 37
6889: PPUSH
6890: LD_EXP 47
6894: PPUSH
6895: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_EXP 47
6908: PUSH
6909: LD_EXP 48
6913: PUSH
6914: LD_EXP 49
6918: PUSH
6919: LD_EXP 50
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: LIST
6928: LIST
6929: PUSH
6930: FOR_IN
6931: IFFALSE 6949
// ComTurnUnit ( i , JMM ) ;
6933: LD_VAR 0 1
6937: PPUSH
6938: LD_EXP 37
6942: PPUSH
6943: CALL_OW 119
6947: GO 6930
6949: POP
6950: POP
// Wait ( 0 0$0.3 ) ;
6951: LD_INT 10
6953: PPUSH
6954: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6958: LD_EXP 37
6962: PPUSH
6963: LD_STRING D2-JMM-1
6965: PPUSH
6966: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6970: LD_EXP 47
6974: PPUSH
6975: LD_STRING D2-Sol1-1
6977: PPUSH
6978: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6982: LD_EXP 37
6986: PPUSH
6987: LD_STRING D2-JMM-2
6989: PPUSH
6990: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6994: LD_EXP 47
6998: PPUSH
6999: LD_STRING D2-Sol1-2
7001: PPUSH
7002: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7006: LD_EXP 37
7010: PPUSH
7011: LD_STRING D2-JMM-3
7013: PPUSH
7014: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7018: LD_EXP 47
7022: PPUSH
7023: LD_STRING D2-Sol1-3
7025: PPUSH
7026: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7030: LD_ADDR_VAR 0 1
7034: PUSH
7035: LD_INT 22
7037: PUSH
7038: LD_INT 8
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: FOR_IN
7051: IFFALSE 7067
// SetSide ( i , 1 ) ;
7053: LD_VAR 0 1
7057: PPUSH
7058: LD_INT 1
7060: PPUSH
7061: CALL_OW 235
7065: GO 7050
7067: POP
7068: POP
// Say ( JMM , D2-JMM-4 ) ;
7069: LD_EXP 37
7073: PPUSH
7074: LD_STRING D2-JMM-4
7076: PPUSH
7077: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 5
7086: PPUSH
7087: CALL_OW 332
// for i = 1 to points do
7091: LD_ADDR_VAR 0 1
7095: PUSH
7096: DOUBLE
7097: LD_INT 1
7099: DEC
7100: ST_TO_ADDR
7101: LD_VAR 0 2
7105: PUSH
7106: FOR_TO
7107: IFFALSE 7282
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_VAR 0 2
7128: PUSH
7129: LD_VAR 0 1
7133: ARRAY
7134: PUSH
7135: LD_INT 2
7137: ARRAY
7138: PPUSH
7139: CALL_OW 84
// if i = 1 then
7143: LD_VAR 0 1
7147: PUSH
7148: LD_INT 1
7150: EQUAL
7151: IFFALSE 7165
// Say ( Lynch , D2-Sol1-4 ) ;
7153: LD_EXP 47
7157: PPUSH
7158: LD_STRING D2-Sol1-4
7160: PPUSH
7161: CALL_OW 88
// if i = 2 then
7165: LD_VAR 0 1
7169: PUSH
7170: LD_INT 2
7172: EQUAL
7173: IFFALSE 7187
// Say ( JMM , D2-JMM-5 ) ;
7175: LD_EXP 37
7179: PPUSH
7180: LD_STRING D2-JMM-5
7182: PPUSH
7183: CALL_OW 88
// if i = 4 then
7187: LD_VAR 0 1
7191: PUSH
7192: LD_INT 4
7194: EQUAL
7195: IFFALSE 7219
// begin RevealFogArea ( 1 , troopsArea ) ;
7197: LD_INT 1
7199: PPUSH
7200: LD_INT 6
7202: PPUSH
7203: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7207: LD_EXP 47
7211: PPUSH
7212: LD_STRING D2-Sol1-5
7214: PPUSH
7215: CALL_OW 88
// end ; if i = 5 then
7219: LD_VAR 0 1
7223: PUSH
7224: LD_INT 5
7226: EQUAL
7227: IFFALSE 7241
// Say ( JMM , D2-JMM-6 ) ;
7229: LD_EXP 37
7233: PPUSH
7234: LD_STRING D2-JMM-6
7236: PPUSH
7237: CALL_OW 88
// if i = 7 then
7241: LD_VAR 0 1
7245: PUSH
7246: LD_INT 7
7248: EQUAL
7249: IFFALSE 7273
// begin RevealFogArea ( 1 , forestArea ) ;
7251: LD_INT 1
7253: PPUSH
7254: LD_INT 7
7256: PPUSH
7257: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7261: LD_EXP 47
7265: PPUSH
7266: LD_STRING D2-Sol1-6
7268: PPUSH
7269: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7273: LD_INT 46
7275: PPUSH
7276: CALL_OW 67
// end ;
7280: GO 7106
7282: POP
7283: POP
// CenterNowOnUnits ( JMM ) ;
7284: LD_EXP 37
7288: PPUSH
7289: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7293: LD_EXP 37
7297: PPUSH
7298: LD_STRING D2-JMM-7
7300: PPUSH
7301: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7305: LD_EXP 47
7309: PPUSH
7310: LD_STRING D2-Sol1-7
7312: PPUSH
7313: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7317: LD_EXP 37
7321: PPUSH
7322: LD_STRING D2-JMM-8
7324: PPUSH
7325: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7329: LD_ADDR_VAR 0 4
7333: PUSH
7334: LD_INT 22
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 30
7346: PUSH
7347: LD_INT 31
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL_OW 69
7362: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7363: LD_EXP 47
7367: PPUSH
7368: LD_VAR 0 4
7372: PUSH
7373: LD_INT 1
7375: ARRAY
7376: PPUSH
7377: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7381: LD_INT 65
7383: PPUSH
7384: LD_INT 101
7386: PPUSH
7387: CALL_OW 428
7391: IFFALSE 7414
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7393: LD_INT 65
7395: PPUSH
7396: LD_INT 101
7398: PPUSH
7399: CALL_OW 428
7403: PPUSH
7404: LD_INT 75
7406: PPUSH
7407: LD_INT 100
7409: PPUSH
7410: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7414: LD_INT 66
7416: PPUSH
7417: LD_INT 103
7419: PPUSH
7420: CALL_OW 428
7424: IFFALSE 7447
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7426: LD_INT 66
7428: PPUSH
7429: LD_INT 103
7431: PPUSH
7432: CALL_OW 428
7436: PPUSH
7437: LD_INT 75
7439: PPUSH
7440: LD_INT 100
7442: PPUSH
7443: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7447: LD_ADDR_VAR 0 5
7451: PUSH
7452: LD_INT 22
7454: PUSH
7455: LD_INT 1
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: PUSH
7462: LD_INT 21
7464: PUSH
7465: LD_INT 2
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 91
7474: PUSH
7475: LD_EXP 37
7479: PUSH
7480: LD_INT 7
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 69
7497: ST_TO_ADDR
// if tmp then
7498: LD_VAR 0 5
7502: IFFALSE 7519
// ComMoveXY ( tmp , 75 , 100 ) ;
7504: LD_VAR 0 5
7508: PPUSH
7509: LD_INT 75
7511: PPUSH
7512: LD_INT 100
7514: PPUSH
7515: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: LD_EXP 4
7528: PPUSH
7529: LD_INT 25
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PPUSH
7539: CALL_OW 72
7543: PPUSH
7544: LD_EXP 37
7548: PPUSH
7549: CALL_OW 74
7553: ST_TO_ADDR
// if sol then
7554: LD_VAR 0 3
7558: IFFALSE 7618
// if GetDistUnits ( JMM , sol ) < 10 then
7560: LD_EXP 37
7564: PPUSH
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 296
7574: PUSH
7575: LD_INT 10
7577: LESS
7578: IFFALSE 7618
// begin if IsInUnit ( sol ) then
7580: LD_VAR 0 3
7584: PPUSH
7585: CALL_OW 310
7589: IFFALSE 7600
// ComExitVehicle ( sol ) ;
7591: LD_VAR 0 3
7595: PPUSH
7596: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7600: LD_VAR 0 3
7604: PPUSH
7605: LD_VAR 0 4
7609: PUSH
7610: LD_INT 2
7612: ARRAY
7613: PPUSH
7614: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7618: LD_INT 10
7620: PPUSH
7621: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7625: LD_EXP 37
7629: PPUSH
7630: LD_INT 65
7632: PPUSH
7633: LD_INT 101
7635: PPUSH
7636: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7640: LD_EXP 37
7644: PPUSH
7645: LD_INT 63
7647: PPUSH
7648: LD_INT 100
7650: PPUSH
7651: CALL_OW 178
// tmp := 0 0$0 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_INT 0
7662: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7670: LD_ADDR_VAR 0 5
7674: PUSH
7675: LD_VAR 0 5
7679: PUSH
7680: LD_INT 35
7682: PLUS
7683: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7684: LD_EXP 37
7688: PPUSH
7689: LD_INT 65
7691: PPUSH
7692: LD_INT 101
7694: PPUSH
7695: CALL_OW 307
7699: PUSH
7700: LD_VAR 0 5
7704: PUSH
7705: LD_INT 175
7707: GREATER
7708: OR
7709: IFFALSE 7663
// Say ( JMM , D2a-JMM-1 ) ;
7711: LD_EXP 37
7715: PPUSH
7716: LD_STRING D2a-JMM-1
7718: PPUSH
7719: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7723: LD_EXP 48
7727: PPUSH
7728: LD_INT 66
7730: PPUSH
7731: LD_INT 103
7733: PPUSH
7734: CALL_OW 111
// tmp := 0 0$0 ;
7738: LD_ADDR_VAR 0 5
7742: PUSH
7743: LD_INT 0
7745: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7746: LD_INT 35
7748: PPUSH
7749: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7753: LD_EXP 48
7757: PPUSH
7758: LD_INT 66
7760: PPUSH
7761: LD_INT 103
7763: PPUSH
7764: CALL_OW 307
7768: PUSH
7769: LD_VAR 0 5
7773: PUSH
7774: LD_INT 175
7776: GREATER
7777: OR
7778: IFFALSE 7746
// ComTurnUnit ( Walker , JMM ) ;
7780: LD_EXP 48
7784: PPUSH
7785: LD_EXP 37
7789: PPUSH
7790: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7794: LD_EXP 48
7798: PPUSH
7799: LD_STRING D2a-Sci1-1
7801: PPUSH
7802: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7806: LD_EXP 37
7810: PPUSH
7811: LD_EXP 48
7815: PPUSH
7816: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7820: LD_EXP 37
7824: PPUSH
7825: LD_STRING D2a-JMM-2
7827: PPUSH
7828: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7832: LD_EXP 48
7836: PPUSH
7837: LD_STRING D2a-Sci1-2
7839: PPUSH
7840: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7844: LD_EXP 37
7848: PPUSH
7849: LD_STRING D2a-JMM-3
7851: PPUSH
7852: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7856: LD_EXP 48
7860: PPUSH
7861: LD_STRING D2a-Sci1-3
7863: PPUSH
7864: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7868: LD_ADDR_EXP 4
7872: PUSH
7873: LD_EXP 4
7877: PUSH
7878: LD_EXP 47
7882: PUSH
7883: LD_EXP 48
7887: PUSH
7888: LD_EXP 49
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: LIST
7902: LIST
7903: ADD
7904: ST_TO_ADDR
// for i in jmm_units do
7905: LD_ADDR_VAR 0 1
7909: PUSH
7910: LD_EXP 4
7914: PUSH
7915: FOR_IN
7916: IFFALSE 7941
// if not IsInUnit ( i ) then
7918: LD_VAR 0 1
7922: PPUSH
7923: CALL_OW 310
7927: NOT
7928: IFFALSE 7939
// ComFree ( i ) ;
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 139
7939: GO 7915
7941: POP
7942: POP
// Video ( false ) ;
7943: LD_INT 0
7945: PPUSH
7946: CALL 1200 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7950: LD_STRING MSolar1
7952: PPUSH
7953: CALL_OW 337
// jmm_on_west := true ;
7957: LD_ADDR_EXP 5
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7965: LD_INT 1050
7967: PPUSH
7968: CALL_OW 67
// frank_can_return := true ;
7972: LD_ADDR_EXP 12
7976: PUSH
7977: LD_INT 1
7979: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7980: LD_INT 6300
7982: PPUSH
7983: LD_INT 8400
7985: PPUSH
7986: CALL_OW 12
7990: PPUSH
7991: CALL_OW 67
// send_spec_patrol := true ;
7995: LD_ADDR_EXP 30
7999: PUSH
8000: LD_INT 1
8002: ST_TO_ADDR
// end ;
8003: PPOPN 5
8005: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
8006: LD_INT 22
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 34
8018: PUSH
8019: LD_INT 51
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 92
8028: PUSH
8029: LD_INT 63
8031: PUSH
8032: LD_INT 100
8034: PUSH
8035: LD_INT 5
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: PPUSH
8052: CALL_OW 69
8056: PUSH
8057: LD_EXP 5
8061: NOT
8062: AND
8063: IFFALSE 8176
8065: GO 8067
8067: DISABLE
8068: LD_INT 0
8070: PPUSH
8071: PPUSH
// begin enable ;
8072: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8073: LD_ADDR_VAR 0 2
8077: PUSH
8078: LD_INT 22
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 34
8090: PUSH
8091: LD_INT 51
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 92
8100: PUSH
8101: LD_INT 63
8103: PUSH
8104: LD_INT 100
8106: PUSH
8107: LD_INT 5
8109: PUSH
8110: EMPTY
8111: LIST
8112: LIST
8113: LIST
8114: LIST
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: PUSH
8121: EMPTY
8122: LIST
8123: PPUSH
8124: CALL_OW 69
8128: ST_TO_ADDR
// if not filter then
8129: LD_VAR 0 2
8133: NOT
8134: IFFALSE 8138
// exit ;
8136: GO 8176
// for i in filter do
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: LD_VAR 0 2
8147: PUSH
8148: FOR_IN
8149: IFFALSE 8174
// begin SetFuel ( i , 0 ) ;
8151: LD_VAR 0 1
8155: PPUSH
8156: LD_INT 0
8158: PPUSH
8159: CALL_OW 240
// ComStop ( i ) ;
8163: LD_VAR 0 1
8167: PPUSH
8168: CALL_OW 141
// end ;
8172: GO 8148
8174: POP
8175: POP
// end ;
8176: PPOPN 2
8178: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8179: LD_EXP 30
8183: IFFALSE 9280
8185: GO 8187
8187: DISABLE
8188: LD_INT 0
8190: PPUSH
8191: PPUSH
8192: PPUSH
8193: PPUSH
8194: PPUSH
8195: PPUSH
8196: PPUSH
// begin if not ru_spec_patrol then
8197: LD_EXP 54
8201: NOT
8202: IFFALSE 8206
// exit ;
8204: GO 9280
// dead1 := false ;
8206: LD_ADDR_VAR 0 1
8210: PUSH
8211: LD_INT 0
8213: ST_TO_ADDR
// dead2 := false ;
8214: LD_ADDR_VAR 0 2
8218: PUSH
8219: LD_INT 0
8221: ST_TO_ADDR
// inarea1 := false ;
8222: LD_ADDR_VAR 0 3
8226: PUSH
8227: LD_INT 0
8229: ST_TO_ADDR
// inarea2 := false ;
8230: LD_ADDR_VAR 0 4
8234: PUSH
8235: LD_INT 0
8237: ST_TO_ADDR
// tmp := [ ] ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: EMPTY
8244: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8245: LD_EXP 54
8249: PPUSH
8250: LD_INT 75
8252: PPUSH
8253: LD_INT 101
8255: PPUSH
8256: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8260: LD_INT 35
8262: PPUSH
8263: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8267: LD_INT 1
8269: PPUSH
8270: LD_EXP 54
8274: PUSH
8275: LD_INT 1
8277: ARRAY
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8260
// ComStop ( ru_spec_patrol ) ;
8285: LD_EXP 54
8289: PPUSH
8290: CALL_OW 141
// Wait ( 0 0$02 ) ;
8294: LD_INT 70
8296: PPUSH
8297: CALL_OW 67
// DialogueOn ;
8301: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8305: LD_EXP 54
8309: PUSH
8310: LD_INT 1
8312: ARRAY
8313: PPUSH
8314: LD_STRING D8-Rus1-1
8316: PPUSH
8317: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8321: LD_EXP 37
8325: PPUSH
8326: LD_STRING D8-JMM-1
8328: PPUSH
8329: CALL_OW 88
// DialogueOff ;
8333: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8337: LD_EXP 54
8341: PPUSH
8342: LD_INT 13
8344: PPUSH
8345: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8349: LD_INT 35
8351: PPUSH
8352: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8356: LD_VAR 0 1
8360: NOT
8361: PUSH
8362: LD_EXP 54
8366: PUSH
8367: LD_INT 1
8369: ARRAY
8370: PPUSH
8371: CALL_OW 301
8375: AND
8376: IFFALSE 8386
// dead1 := true ;
8378: LD_ADDR_VAR 0 1
8382: PUSH
8383: LD_INT 1
8385: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8386: LD_VAR 0 2
8390: NOT
8391: PUSH
8392: LD_EXP 54
8396: PUSH
8397: LD_INT 2
8399: ARRAY
8400: PPUSH
8401: CALL_OW 301
8405: AND
8406: IFFALSE 8416
// dead2 := true ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_INT 1
8415: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8416: LD_VAR 0 3
8420: NOT
8421: PUSH
8422: LD_EXP 54
8426: PUSH
8427: LD_INT 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 14
8433: PPUSH
8434: CALL_OW 308
8438: AND
8439: IFFALSE 8449
// inarea1 := true ;
8441: LD_ADDR_VAR 0 3
8445: PUSH
8446: LD_INT 1
8448: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8449: LD_VAR 0 4
8453: NOT
8454: PUSH
8455: LD_EXP 54
8459: PUSH
8460: LD_INT 2
8462: ARRAY
8463: PPUSH
8464: LD_INT 14
8466: PPUSH
8467: CALL_OW 308
8471: AND
8472: IFFALSE 8482
// inarea2 := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8482: LD_VAR 0 1
8486: PUSH
8487: LD_VAR 0 2
8491: AND
8492: PUSH
8493: LD_VAR 0 1
8497: PUSH
8498: LD_VAR 0 4
8502: AND
8503: OR
8504: PUSH
8505: LD_VAR 0 2
8509: PUSH
8510: LD_VAR 0 3
8514: AND
8515: OR
8516: PUSH
8517: LD_VAR 0 3
8521: PUSH
8522: LD_VAR 0 4
8526: AND
8527: OR
8528: IFFALSE 8349
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8530: LD_VAR 0 3
8534: PUSH
8535: LD_VAR 0 4
8539: AND
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_VAR 0 4
8550: AND
8551: OR
8552: PUSH
8553: LD_VAR 0 2
8557: PUSH
8558: LD_VAR 0 3
8562: AND
8563: OR
8564: IFFALSE 9260
// begin prepare_siege := true ;
8566: LD_ADDR_EXP 31
8570: PUSH
8571: LD_INT 1
8573: ST_TO_ADDR
// DialogueOn ;
8574: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8578: LD_VAR 0 3
8582: PUSH
8583: LD_VAR 0 4
8587: AND
8588: IFFALSE 8604
// Say ( JMM , D8b-JMM-1a ) else
8590: LD_EXP 37
8594: PPUSH
8595: LD_STRING D8b-JMM-1a
8597: PPUSH
8598: CALL_OW 88
8602: GO 8616
// Say ( JMM , D8b-JMM-1 ) ;
8604: LD_EXP 37
8608: PPUSH
8609: LD_STRING D8b-JMM-1
8611: PPUSH
8612: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8616: LD_EXP 4
8620: PPUSH
8621: LD_INT 26
8623: PUSH
8624: LD_INT 1
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PPUSH
8631: CALL_OW 72
8635: PUSH
8636: LD_EXP 38
8640: PUSH
8641: LD_EXP 39
8645: PUSH
8646: LD_EXP 48
8650: PUSH
8651: LD_EXP 51
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: DIFF
8662: PPUSH
8663: LD_STRING D8b-Sol1-1
8665: PPUSH
8666: CALL 640 0 2
// if Cyrus and Cyrus in jmm_units then
8670: LD_EXP 39
8674: PUSH
8675: LD_EXP 39
8679: PUSH
8680: LD_EXP 4
8684: IN
8685: AND
8686: IFFALSE 8702
// Say ( Cyrus , D8b-Cyrus-1 ) else
8688: LD_EXP 39
8692: PPUSH
8693: LD_STRING D8b-Cyrus-1
8695: PPUSH
8696: CALL_OW 88
8700: GO 8714
// Say ( JMM , D8b-JMM-1a ) ;
8702: LD_EXP 37
8706: PPUSH
8707: LD_STRING D8b-JMM-1a
8709: PPUSH
8710: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8714: LD_EXP 40
8718: PUSH
8719: LD_EXP 40
8723: PUSH
8724: LD_EXP 4
8728: IN
8729: AND
8730: IFFALSE 8744
// Say ( Lisa , D8b-Lisa-2 ) ;
8732: LD_EXP 40
8736: PPUSH
8737: LD_STRING D8b-Lisa-2
8739: PPUSH
8740: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8744: LD_EXP 38
8748: PUSH
8749: LD_EXP 38
8753: PUSH
8754: LD_EXP 4
8758: IN
8759: AND
8760: IFFALSE 8776
// Say ( Bobby , D8b-Bobby-1 ) else
8762: LD_EXP 38
8766: PPUSH
8767: LD_STRING D8b-Bobby-1
8769: PPUSH
8770: CALL_OW 88
8774: GO 8836
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8776: LD_ADDR_VAR 0 5
8780: PUSH
8781: LD_EXP 4
8785: PPUSH
8786: LD_INT 26
8788: PUSH
8789: LD_INT 1
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: PPUSH
8796: CALL_OW 72
8800: PUSH
8801: LD_EXP 38
8805: PUSH
8806: LD_EXP 39
8810: PUSH
8811: LD_EXP 48
8815: PUSH
8816: LD_EXP 51
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: DIFF
8827: PPUSH
8828: LD_STRING D8b-Sol2-1
8830: PPUSH
8831: CALL 640 0 2
8835: ST_TO_ADDR
// DialogueOff ;
8836: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8840: LD_EXP 39
8844: PUSH
8845: LD_EXP 39
8849: PUSH
8850: LD_EXP 4
8854: IN
8855: AND
8856: IFFALSE 8881
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8858: LD_ADDR_VAR 0 6
8862: PUSH
8863: LD_VAR 0 6
8867: PPUSH
8868: LD_INT 1
8870: PPUSH
8871: LD_EXP 39
8875: PPUSH
8876: CALL_OW 2
8880: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8881: LD_EXP 38
8885: PUSH
8886: LD_EXP 38
8890: PUSH
8891: LD_EXP 4
8895: IN
8896: AND
8897: IFFALSE 8922
// tmp := Insert ( tmp , 1 , Bobby ) ;
8899: LD_ADDR_VAR 0 6
8903: PUSH
8904: LD_VAR 0 6
8908: PPUSH
8909: LD_INT 1
8911: PPUSH
8912: LD_EXP 38
8916: PPUSH
8917: CALL_OW 2
8921: ST_TO_ADDR
// if sol then
8922: LD_VAR 0 5
8926: IFFALSE 8951
// tmp := Insert ( tmp , 1 , sol ) ;
8928: LD_ADDR_VAR 0 6
8932: PUSH
8933: LD_VAR 0 6
8937: PPUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_VAR 0 5
8945: PPUSH
8946: CALL_OW 2
8950: ST_TO_ADDR
// if tmp then
8951: LD_VAR 0 6
8955: IFFALSE 9219
// begin SetSide ( tmp , 8 ) ;
8957: LD_VAR 0 6
8961: PPUSH
8962: LD_INT 8
8964: PPUSH
8965: CALL_OW 235
// for i in tmp do
8969: LD_ADDR_VAR 0 7
8973: PUSH
8974: LD_VAR 0 6
8978: PUSH
8979: FOR_IN
8980: IFFALSE 9071
// begin if IsInUnit ( i ) and GetBType ( IsInUnit ( i ) ) = unit_building then
8982: LD_VAR 0 7
8986: PPUSH
8987: CALL_OW 310
8991: PUSH
8992: LD_VAR 0 7
8996: PPUSH
8997: CALL_OW 310
9001: PPUSH
9002: CALL_OW 266
9006: PUSH
9007: LD_INT 3
9009: EQUAL
9010: AND
9011: IFFALSE 9022
// ComExitBuilding ( i ) ;
9013: LD_VAR 0 7
9017: PPUSH
9018: CALL_OW 122
// if IsInUnit ( i ) and GetBType ( IsInUnit ( i ) ) = unit_vehicle then
9022: LD_VAR 0 7
9026: PPUSH
9027: CALL_OW 310
9031: PUSH
9032: LD_VAR 0 7
9036: PPUSH
9037: CALL_OW 310
9041: PPUSH
9042: CALL_OW 266
9046: PUSH
9047: LD_INT 2
9049: EQUAL
9050: AND
9051: IFFALSE 9062
// ComExitVehicle ( i ) ;
9053: LD_VAR 0 7
9057: PPUSH
9058: CALL_OW 121
// wait ( 0 0$1 ) ;
9062: LD_INT 35
9064: PPUSH
9065: CALL_OW 67
// end ;
9069: GO 8979
9071: POP
9072: POP
// ComFree ( tmp ) ;
9073: LD_VAR 0 6
9077: PPUSH
9078: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
9082: LD_VAR 0 6
9086: PPUSH
9087: LD_INT 15
9089: PPUSH
9090: CALL_OW 173
// AddComHold ( tmp ) ;
9094: LD_VAR 0 6
9098: PPUSH
9099: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
9103: LD_INT 35
9105: PPUSH
9106: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
9110: LD_VAR 0 6
9114: PUSH
9115: LD_INT 1
9117: ARRAY
9118: PPUSH
9119: CALL_OW 314
9123: NOT
9124: IFFALSE 9138
// ComMoveToArea ( tmp , cyrusEscape ) ;
9126: LD_VAR 0 6
9130: PPUSH
9131: LD_INT 15
9133: PPUSH
9134: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9138: LD_VAR 0 6
9142: PUSH
9143: LD_INT 1
9145: ARRAY
9146: PPUSH
9147: LD_INT 15
9149: PPUSH
9150: CALL_OW 308
9154: IFFALSE 9209
// begin RemoveUnit ( tmp [ 1 ] ) ;
9156: LD_VAR 0 6
9160: PUSH
9161: LD_INT 1
9163: ARRAY
9164: PPUSH
9165: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9169: LD_ADDR_EXP 4
9173: PUSH
9174: LD_EXP 4
9178: PUSH
9179: LD_VAR 0 6
9183: PUSH
9184: LD_INT 1
9186: ARRAY
9187: DIFF
9188: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9189: LD_ADDR_VAR 0 6
9193: PUSH
9194: LD_VAR 0 6
9198: PUSH
9199: LD_VAR 0 6
9203: PUSH
9204: LD_INT 1
9206: ARRAY
9207: DIFF
9208: ST_TO_ADDR
// end ; until tmp = 0 ;
9209: LD_VAR 0 6
9213: PUSH
9214: LD_INT 0
9216: EQUAL
9217: IFFALSE 9103
// end ; wait ( 0 0$30 ) ;
9219: LD_INT 1050
9221: PPUSH
9222: CALL_OW 67
// if ru_spec_patrol then
9226: LD_EXP 54
9230: IFFALSE 9258
// for i in ru_spec_patrol do
9232: LD_ADDR_VAR 0 7
9236: PUSH
9237: LD_EXP 54
9241: PUSH
9242: FOR_IN
9243: IFFALSE 9256
// RemoveUnit ( i ) ;
9245: LD_VAR 0 7
9249: PPUSH
9250: CALL_OW 64
9254: GO 9242
9256: POP
9257: POP
// end else
9258: GO 9280
// begin prepare_siege := false ;
9260: LD_ADDR_EXP 31
9264: PUSH
9265: LD_INT 0
9267: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9268: LD_EXP 37
9272: PPUSH
9273: LD_STRING D8a-JMM-1
9275: PPUSH
9276: CALL_OW 88
// end ; end ;
9280: PPOPN 7
9282: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9283: LD_EXP 12
9287: IFFALSE 10504
9289: GO 9291
9291: DISABLE
9292: LD_INT 0
9294: PPUSH
9295: PPUSH
9296: PPUSH
// begin uc_side := 8 ;
9297: LD_ADDR_OWVAR 20
9301: PUSH
9302: LD_INT 8
9304: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9305: LD_ADDR_VAR 0 3
9309: PUSH
9310: LD_INT 59
9312: PUSH
9313: LD_INT 71
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: PUSH
9320: LD_INT 122
9322: PUSH
9323: LD_INT 117
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9334: LD_ADDR_EXP 51
9338: PUSH
9339: LD_STRING Frank
9341: PPUSH
9342: LD_INT 0
9344: PPUSH
9345: CALL 489 0 2
9349: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9350: LD_ADDR_VAR 0 1
9354: PUSH
9355: LD_INT 1
9357: PPUSH
9358: LD_INT 2
9360: PPUSH
9361: CALL_OW 12
9365: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9366: LD_EXP 51
9370: PPUSH
9371: LD_VAR 0 3
9375: PUSH
9376: LD_VAR 0 1
9380: ARRAY
9381: PUSH
9382: LD_INT 1
9384: ARRAY
9385: PPUSH
9386: LD_VAR 0 3
9390: PUSH
9391: LD_VAR 0 1
9395: ARRAY
9396: PUSH
9397: LD_INT 2
9399: ARRAY
9400: PPUSH
9401: LD_INT 0
9403: PPUSH
9404: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9408: LD_EXP 51
9412: PPUSH
9413: LD_INT 1
9415: PPUSH
9416: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9420: LD_INT 35
9422: PPUSH
9423: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9427: LD_EXP 51
9431: PPUSH
9432: LD_EXP 37
9436: PPUSH
9437: CALL_OW 296
9441: PUSH
9442: LD_INT 8
9444: LESS
9445: PUSH
9446: LD_EXP 51
9450: PPUSH
9451: CALL_OW 256
9455: PUSH
9456: LD_INT 250
9458: GREATER
9459: AND
9460: IFFALSE 9420
// Video ( true ) ;
9462: LD_INT 1
9464: PPUSH
9465: CALL 1200 0 1
// CenterOnUnits ( JMM ) ;
9469: LD_EXP 37
9473: PPUSH
9474: CALL_OW 85
// if IsInUnit ( JMM ) then
9478: LD_EXP 37
9482: PPUSH
9483: CALL_OW 310
9487: IFFALSE 9498
// ComFree ( JMM ) ;
9489: LD_EXP 37
9493: PPUSH
9494: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9498: LD_EXP 37
9502: PPUSH
9503: LD_EXP 51
9507: PPUSH
9508: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9512: LD_EXP 51
9516: PPUSH
9517: LD_EXP 37
9521: PPUSH
9522: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9526: LD_EXP 37
9530: PPUSH
9531: LD_STRING D6-JMM-1
9533: PPUSH
9534: CALL_OW 88
// p := 0 ;
9538: LD_ADDR_VAR 0 2
9542: PUSH
9543: LD_INT 0
9545: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9546: LD_INT 35
9548: PPUSH
9549: CALL_OW 67
// p := p + 1 ;
9553: LD_ADDR_VAR 0 2
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 1
9565: PLUS
9566: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9567: LD_EXP 37
9571: PPUSH
9572: LD_EXP 51
9576: PPUSH
9577: CALL_OW 296
9581: PUSH
9582: LD_INT 8
9584: LESS
9585: PUSH
9586: LD_VAR 0 2
9590: PUSH
9591: LD_INT 7
9593: GREATER
9594: OR
9595: IFFALSE 9546
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9597: LD_EXP 40
9601: PUSH
9602: LD_EXP 40
9606: PPUSH
9607: LD_EXP 51
9611: PPUSH
9612: CALL_OW 296
9616: PUSH
9617: LD_INT 20
9619: LESS
9620: AND
9621: IFFALSE 9646
// begin ComFree ( Lisa ) ;
9623: LD_EXP 40
9627: PPUSH
9628: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9632: LD_EXP 40
9636: PPUSH
9637: LD_EXP 51
9641: PPUSH
9642: CALL_OW 172
// end ; if Lynch then
9646: LD_EXP 47
9650: IFFALSE 9675
// begin ComFree ( Lynch ) ;
9652: LD_EXP 47
9656: PPUSH
9657: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9661: LD_EXP 47
9665: PPUSH
9666: LD_EXP 51
9670: PPUSH
9671: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9675: LD_EXP 37
9679: PPUSH
9680: LD_EXP 51
9684: PPUSH
9685: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9689: LD_EXP 51
9693: PPUSH
9694: LD_EXP 37
9698: PPUSH
9699: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9703: LD_EXP 51
9707: PPUSH
9708: LD_STRING D6-Frank-1
9710: PPUSH
9711: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9715: LD_INT 69
9717: PPUSH
9718: LD_INT 20
9720: PPUSH
9721: LD_INT 1
9723: PPUSH
9724: LD_INT 20
9726: NEG
9727: PPUSH
9728: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9732: LD_INT 69
9734: PPUSH
9735: LD_INT 20
9737: PPUSH
9738: LD_INT 1
9740: PPUSH
9741: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9745: LD_INT 190
9747: PPUSH
9748: LD_INT 31
9750: PPUSH
9751: LD_INT 1
9753: PPUSH
9754: LD_INT 20
9756: NEG
9757: PPUSH
9758: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9762: LD_INT 190
9764: PPUSH
9765: LD_INT 31
9767: PPUSH
9768: LD_INT 1
9770: PPUSH
9771: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9775: LD_INT 69
9777: PPUSH
9778: LD_INT 20
9780: PPUSH
9781: CALL_OW 84
// Wait ( 0 0$02 ) ;
9785: LD_INT 70
9787: PPUSH
9788: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9792: LD_EXP 37
9796: PPUSH
9797: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9801: LD_EXP 40
9805: PUSH
9806: LD_EXP 40
9810: PPUSH
9811: LD_EXP 51
9815: PPUSH
9816: CALL_OW 296
9820: PUSH
9821: LD_INT 20
9823: LESS
9824: AND
9825: PUSH
9826: LD_EXP 40
9830: PPUSH
9831: CALL_OW 302
9835: AND
9836: IFFALSE 9958
// begin ComFree ( Lisa ) ;
9838: LD_EXP 40
9842: PPUSH
9843: CALL_OW 139
// p := 0 ;
9847: LD_ADDR_VAR 0 2
9851: PUSH
9852: LD_INT 0
9854: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9855: LD_INT 35
9857: PPUSH
9858: CALL_OW 67
// p := p + 1 ;
9862: LD_ADDR_VAR 0 2
9866: PUSH
9867: LD_VAR 0 2
9871: PUSH
9872: LD_INT 1
9874: PLUS
9875: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9876: LD_EXP 40
9880: PPUSH
9881: LD_EXP 51
9885: PPUSH
9886: CALL_OW 296
9890: PUSH
9891: LD_INT 7
9893: LESS
9894: PUSH
9895: LD_VAR 0 2
9899: PUSH
9900: LD_INT 7
9902: GREATER
9903: OR
9904: IFFALSE 9855
// Say ( Lisa , D6-Lisa-1 ) ;
9906: LD_EXP 40
9910: PPUSH
9911: LD_STRING D6-Lisa-1
9913: PPUSH
9914: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9918: LD_EXP 40
9922: PPUSH
9923: LD_EXP 51
9927: PPUSH
9928: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9932: LD_EXP 51
9936: PPUSH
9937: LD_EXP 40
9941: PPUSH
9942: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9946: LD_EXP 51
9950: PPUSH
9951: LD_STRING D6-Frank-2
9953: PPUSH
9954: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9958: LD_EXP 47
9962: PUSH
9963: LD_EXP 47
9967: PPUSH
9968: LD_EXP 51
9972: PPUSH
9973: CALL_OW 296
9977: PUSH
9978: LD_INT 20
9980: LESS
9981: AND
9982: PUSH
9983: LD_EXP 47
9987: PPUSH
9988: CALL_OW 302
9992: AND
9993: IFFALSE 10174
// begin ComTurnUnit ( Lynch , JMM ) ;
9995: LD_EXP 47
9999: PPUSH
10000: LD_EXP 37
10004: PPUSH
10005: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
10009: LD_EXP 51
10013: PPUSH
10014: LD_EXP 37
10018: PPUSH
10019: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
10023: LD_EXP 47
10027: PPUSH
10028: LD_STRING D6-Sol1-2
10030: PPUSH
10031: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
10035: LD_EXP 37
10039: PPUSH
10040: LD_STRING D6-JMM-2
10042: PPUSH
10043: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
10047: LD_EXP 51
10051: PPUSH
10052: LD_STRING D6-Frank-3
10054: PPUSH
10055: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
10059: LD_EXP 37
10063: PPUSH
10064: LD_STRING D6-JMM-3
10066: PPUSH
10067: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
10071: LD_EXP 51
10075: PPUSH
10076: LD_STRING D6-Frank-4
10078: PPUSH
10079: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10083: LD_EXP 51
10087: PPUSH
10088: LD_STRING D6-Frank-4a
10090: PPUSH
10091: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10095: LD_EXP 37
10099: PPUSH
10100: LD_STRING D6-JMM-4
10102: PPUSH
10103: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10107: LD_EXP 51
10111: PPUSH
10112: LD_STRING D6-Frank-5
10114: PPUSH
10115: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10119: LD_EXP 40
10123: PUSH
10124: LD_EXP 40
10128: PPUSH
10129: CALL_OW 302
10133: AND
10134: IFFALSE 10148
// Say ( Lisa , D6-Lisa-5 ) ;
10136: LD_EXP 40
10140: PPUSH
10141: LD_STRING D6-Lisa-5
10143: PPUSH
10144: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10148: LD_EXP 51
10152: PPUSH
10153: LD_STRING D6-Frank-6
10155: PPUSH
10156: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10160: LD_EXP 37
10164: PPUSH
10165: LD_STRING D6-JMM-6
10167: PPUSH
10168: CALL_OW 88
// end else
10172: GO 10289
// begin ComTurnUnit ( Frank , JMM ) ;
10174: LD_EXP 51
10178: PPUSH
10179: LD_EXP 37
10183: PPUSH
10184: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10188: LD_EXP 51
10192: PPUSH
10193: LD_STRING D6-Frank-4
10195: PPUSH
10196: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10200: LD_EXP 51
10204: PPUSH
10205: LD_STRING D6-Frank-4a
10207: PPUSH
10208: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10212: LD_EXP 37
10216: PPUSH
10217: LD_STRING D6-JMM-4
10219: PPUSH
10220: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10224: LD_EXP 51
10228: PPUSH
10229: LD_STRING D6-Frank-5
10231: PPUSH
10232: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10236: LD_EXP 40
10240: PUSH
10241: LD_EXP 40
10245: PPUSH
10246: CALL_OW 302
10250: AND
10251: IFFALSE 10265
// Say ( Lisa , D6-Lisa-5 ) ;
10253: LD_EXP 40
10257: PPUSH
10258: LD_STRING D6-Lisa-5
10260: PPUSH
10261: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10265: LD_EXP 51
10269: PPUSH
10270: LD_STRING D6-Frank-6
10272: PPUSH
10273: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10277: LD_EXP 37
10281: PPUSH
10282: LD_STRING D6-JMM-6
10284: PPUSH
10285: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10289: LD_STRING Q1
10291: PPUSH
10292: CALL_OW 97
10296: PUSH
10297: LD_INT 1
10299: DOUBLE
10300: EQUAL
10301: IFTRUE 10305
10303: GO 10316
10305: POP
// frank_send_to_scout := true ; 2 :
10306: LD_ADDR_EXP 15
10310: PUSH
10311: LD_INT 1
10313: ST_TO_ADDR
10314: GO 10336
10316: LD_INT 2
10318: DOUBLE
10319: EQUAL
10320: IFTRUE 10324
10322: GO 10335
10324: POP
// frank_send_to_scout := false ; end ;
10325: LD_ADDR_EXP 15
10329: PUSH
10330: LD_INT 0
10332: ST_TO_ADDR
10333: GO 10336
10335: POP
// Video ( false ) ;
10336: LD_INT 0
10338: PPUSH
10339: CALL 1200 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10343: LD_EXP 37
10347: PUSH
10348: LD_EXP 40
10352: PUSH
10353: LD_EXP 47
10357: PUSH
10358: EMPTY
10359: LIST
10360: LIST
10361: LIST
10362: PPUSH
10363: CALL_OW 139
// if frank_send_to_scout then
10367: LD_EXP 15
10371: IFFALSE 10425
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10373: LD_EXP 51
10377: PPUSH
10378: LD_INT 15
10380: PPUSH
10381: CALL_OW 113
// wait ( 0 0$01 ) ;
10385: LD_INT 35
10387: PPUSH
10388: CALL_OW 67
// until not See ( 1 , Frank ) ;
10392: LD_INT 1
10394: PPUSH
10395: LD_EXP 51
10399: PPUSH
10400: CALL_OW 292
10404: NOT
10405: IFFALSE 10373
// wait ( 0 0$02 ) ;
10407: LD_INT 70
10409: PPUSH
10410: CALL_OW 67
// RemoveUnit ( Frank ) ;
10414: LD_EXP 51
10418: PPUSH
10419: CALL_OW 64
// end else
10423: GO 10437
// SetSide ( Frank , 1 ) ;
10425: LD_EXP 51
10429: PPUSH
10430: LD_INT 1
10432: PPUSH
10433: CALL_OW 235
// send_attack_on_cornel_base := true ;
10437: LD_ADDR_EXP 26
10441: PUSH
10442: LD_INT 1
10444: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10445: LD_INT 35
10447: PPUSH
10448: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10452: LD_ADDR_EXP 29
10456: PUSH
10457: LD_EXP 29
10461: PPUSH
10462: LD_STRING -
10464: PPUSH
10465: CALL 1132 0 2
10469: ST_TO_ADDR
// if debug then
10470: LD_EXP 1
10474: IFFALSE 10486
// debug_strings := time_to_prepare ;
10476: LD_ADDR_OWVAR 48
10480: PUSH
10481: LD_EXP 29
10485: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10486: LD_EXP 29
10490: PUSH
10491: LD_INT 0
10493: EQUAL
10494: IFFALSE 10445
// cornel_prepared := true ;
10496: LD_ADDR_EXP 11
10500: PUSH
10501: LD_INT 1
10503: ST_TO_ADDR
// end ;
10504: PPOPN 3
10506: END
// every 0 0$01 trigger cornel_prepared do
10507: LD_EXP 11
10511: IFFALSE 10775
10513: GO 10515
10515: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10516: LD_EXP 44
10520: PPUSH
10521: LD_STRING D3-Corn-1
10523: PPUSH
10524: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10528: LD_STRING MOutWait
10530: PPUSH
10531: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10535: LD_INT 35
10537: PPUSH
10538: CALL_OW 67
// until cornel_counter = 0 ;
10542: LD_EXP 10
10546: PUSH
10547: LD_INT 0
10549: EQUAL
10550: IFFALSE 10535
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10552: LD_EXP 44
10556: PPUSH
10557: LD_STRING D3a-Corn-1
10559: PPUSH
10560: CALL_OW 94
// if IsOk ( Cornel ) then
10564: LD_EXP 44
10568: PPUSH
10569: CALL_OW 302
10573: IFFALSE 10587
// Say ( JMM , D3a-JMM-1 ) ;
10575: LD_EXP 37
10579: PPUSH
10580: LD_STRING D3a-JMM-1
10582: PPUSH
10583: CALL_OW 88
// end_mission_allowed := true ;
10587: LD_ADDR_EXP 21
10591: PUSH
10592: LD_INT 1
10594: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10595: LD_STRING M2
10597: PPUSH
10598: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10602: LD_INT 9
10604: PPUSH
10605: LD_INT 1
10607: PPUSH
10608: CALL_OW 424
// Wait ( 0 0$05 ) ;
10612: LD_INT 175
10614: PPUSH
10615: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10619: LD_EXP 44
10623: PPUSH
10624: LD_STRING D3a-Corn-2
10626: PPUSH
10627: CALL_OW 94
// cornel_attack := true ;
10631: LD_ADDR_EXP 9
10635: PUSH
10636: LD_INT 1
10638: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10639: LD_INT 105
10641: PPUSH
10642: CALL_OW 67
// AddMoreTanks ( ) ;
10646: CALL 4877 0 0
// if frank_send_to_scout then
10650: LD_EXP 15
10654: IFFALSE 10775
// begin InitHc ;
10656: CALL_OW 19
// InitUc ;
10660: CALL_OW 18
// uc_side := 8 ;
10664: LD_ADDR_OWVAR 20
10668: PUSH
10669: LD_INT 8
10671: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10672: LD_ADDR_EXP 51
10676: PUSH
10677: LD_STRING Frank
10679: PPUSH
10680: LD_INT 0
10682: PPUSH
10683: CALL 489 0 2
10687: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10688: LD_EXP 51
10692: PPUSH
10693: LD_INT 6
10695: PPUSH
10696: LD_INT 9
10698: PPUSH
10699: LD_INT 0
10701: PPUSH
10702: CALL_OW 48
// ComCrawl ( Frank ) ;
10706: LD_EXP 51
10710: PPUSH
10711: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10715: LD_INT 35
10717: PPUSH
10718: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10722: LD_EXP 37
10726: PPUSH
10727: LD_EXP 51
10731: PPUSH
10732: CALL_OW 296
10736: PUSH
10737: LD_INT 9
10739: LESS
10740: IFFALSE 10715
// SetSide ( Frank , 1 ) ;
10742: LD_EXP 51
10746: PPUSH
10747: LD_INT 1
10749: PPUSH
10750: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10754: LD_EXP 51
10758: PPUSH
10759: LD_STRING D6a-Frank-1
10761: PPUSH
10762: CALL_OW 88
// ComWalk ( Frank ) ;
10766: LD_EXP 51
10770: PPUSH
10771: CALL_OW 138
// end ; end ;
10775: END
// every 0 0$01 trigger solar_builded do
10776: LD_EXP 14
10780: IFFALSE 10884
10782: GO 10784
10784: DISABLE
// begin Wait ( 0 0$02 ) ;
10785: LD_INT 70
10787: PPUSH
10788: CALL_OW 67
// DialogueOn ;
10792: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10796: LD_EXP 37
10800: PPUSH
10801: LD_STRING D2b-JMM-1
10803: PPUSH
10804: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10808: LD_EXP 48
10812: PUSH
10813: LD_EXP 48
10817: PPUSH
10818: CALL_OW 302
10822: AND
10823: IFFALSE 10873
// begin Say ( Walker , D2b-Sci1-1 ) ;
10825: LD_EXP 48
10829: PPUSH
10830: LD_STRING D2b-Sci1-1
10832: PPUSH
10833: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10837: LD_EXP 37
10841: PPUSH
10842: LD_STRING D2b-JMM-2
10844: PPUSH
10845: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10849: LD_EXP 48
10853: PPUSH
10854: LD_STRING D2b-Sci1-2
10856: PPUSH
10857: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10861: LD_EXP 37
10865: PPUSH
10866: LD_STRING D2b-JMM-3
10868: PPUSH
10869: CALL_OW 88
// end ; DialogueOff ;
10873: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10877: LD_STRING MOutSol
10879: PPUSH
10880: CALL_OW 337
// end ;
10884: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10885: LD_EXP 14
10889: PUSH
10890: LD_EXP 37
10894: PPUSH
10895: CALL_OW 302
10899: AND
10900: PUSH
10901: LD_EXP 37
10905: PPUSH
10906: CALL 966 0 1
10910: AND
10911: PUSH
10912: LD_EXP 16
10916: NOT
10917: AND
10918: IFFALSE 10989
10920: GO 10922
10922: DISABLE
10923: LD_INT 0
10925: PPUSH
// begin jmm_in_veh := true ;
10926: LD_ADDR_EXP 16
10930: PUSH
10931: LD_INT 1
10933: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10934: LD_ADDR_VAR 0 1
10938: PUSH
10939: LD_INT 0
10941: PPUSH
10942: LD_INT 1
10944: PPUSH
10945: CALL_OW 12
10949: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10950: LD_INT 70
10952: PPUSH
10953: CALL_OW 67
// if i then
10957: LD_VAR 0 1
10961: IFFALSE 10977
// Say ( JMM , D2c-JMM-1 ) else
10963: LD_EXP 37
10967: PPUSH
10968: LD_STRING D2c-JMM-1
10970: PPUSH
10971: CALL_OW 88
10975: GO 10989
// Say ( JMM , D2c-JMM-1a ) ;
10977: LD_EXP 37
10981: PPUSH
10982: LD_STRING D2c-JMM-1a
10984: PPUSH
10985: CALL_OW 88
// end ;
10989: PPOPN 1
10991: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10992: LD_EXP 14
10996: PUSH
10997: LD_EXP 38
11001: PPUSH
11002: CALL_OW 302
11006: AND
11007: PUSH
11008: LD_EXP 38
11012: PPUSH
11013: CALL 966 0 1
11017: AND
11018: PUSH
11019: LD_EXP 17
11023: NOT
11024: AND
11025: IFFALSE 11057
11027: GO 11029
11029: DISABLE
// begin bobby_in_veh := true ;
11030: LD_ADDR_EXP 17
11034: PUSH
11035: LD_INT 1
11037: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11038: LD_INT 70
11040: PPUSH
11041: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
11045: LD_EXP 38
11049: PPUSH
11050: LD_STRING D2c-Bobby-1
11052: PPUSH
11053: CALL_OW 88
11057: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
11058: LD_EXP 14
11062: PUSH
11063: LD_EXP 40
11067: PPUSH
11068: CALL_OW 302
11072: AND
11073: PUSH
11074: LD_EXP 40
11078: PPUSH
11079: CALL 966 0 1
11083: AND
11084: PUSH
11085: LD_EXP 19
11089: NOT
11090: AND
11091: IFFALSE 11123
11093: GO 11095
11095: DISABLE
// begin lisa_in_veh := true ;
11096: LD_ADDR_EXP 19
11100: PUSH
11101: LD_INT 1
11103: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11104: LD_INT 70
11106: PPUSH
11107: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
11111: LD_EXP 40
11115: PPUSH
11116: LD_STRING D2c-Lisa-1
11118: PPUSH
11119: CALL_OW 88
11123: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11124: LD_EXP 14
11128: PUSH
11129: LD_EXP 39
11133: PPUSH
11134: CALL_OW 302
11138: AND
11139: PUSH
11140: LD_EXP 39
11144: PPUSH
11145: CALL 966 0 1
11149: AND
11150: PUSH
11151: LD_EXP 18
11155: NOT
11156: AND
11157: IFFALSE 11228
11159: GO 11161
11161: DISABLE
11162: LD_INT 0
11164: PPUSH
// begin cyrus_in_veh := true ;
11165: LD_ADDR_EXP 18
11169: PUSH
11170: LD_INT 1
11172: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11173: LD_ADDR_VAR 0 1
11177: PUSH
11178: LD_INT 0
11180: PPUSH
11181: LD_INT 1
11183: PPUSH
11184: CALL_OW 12
11188: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11189: LD_INT 70
11191: PPUSH
11192: CALL_OW 67
// if i then
11196: LD_VAR 0 1
11200: IFFALSE 11216
// Say ( Cyrus , D2c-Cyrus-1 ) else
11202: LD_EXP 39
11206: PPUSH
11207: LD_STRING D2c-Cyrus-1
11209: PPUSH
11210: CALL_OW 88
11214: GO 11228
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11216: LD_EXP 39
11220: PPUSH
11221: LD_STRING D2c-Cyrus-1a
11223: PPUSH
11224: CALL_OW 88
// end ;
11228: PPOPN 1
11230: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11231: LD_EXP 44
11235: PPUSH
11236: LD_INT 16
11238: PPUSH
11239: CALL_OW 308
11243: IFFALSE 11524
11245: GO 11247
11247: DISABLE
11248: LD_INT 0
11250: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11251: LD_INT 3
11253: PPUSH
11254: LD_EXP 44
11258: PPUSH
11259: CALL_OW 471
// send_attack_on_cornel := true ;
11263: LD_ADDR_EXP 32
11267: PUSH
11268: LD_INT 1
11270: ST_TO_ADDR
// if ru_vehicles then
11271: LD_EXP 56
11275: IFFALSE 11309
// for i in ru_vehicles do
11277: LD_ADDR_VAR 0 1
11281: PUSH
11282: LD_EXP 56
11286: PUSH
11287: FOR_IN
11288: IFFALSE 11307
// ComAgressiveMove ( i , 215 , 69 ) ;
11290: LD_VAR 0 1
11294: PPUSH
11295: LD_INT 215
11297: PPUSH
11298: LD_INT 69
11300: PPUSH
11301: CALL_OW 114
11305: GO 11287
11307: POP
11308: POP
// if ru_patrol then
11309: LD_EXP 53
11313: IFFALSE 11347
// for i in ru_patrol do
11315: LD_ADDR_VAR 0 1
11319: PUSH
11320: LD_EXP 53
11324: PUSH
11325: FOR_IN
11326: IFFALSE 11345
// ComAgressiveMove ( i , 215 , 69 ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_INT 215
11335: PPUSH
11336: LD_INT 69
11338: PPUSH
11339: CALL_OW 114
11343: GO 11325
11345: POP
11346: POP
// if frank_send_to_scout then
11347: LD_EXP 15
11351: IFFALSE 11365
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11353: LD_EXP 51
11357: PPUSH
11358: LD_STRING D3b-Frank-1
11360: PPUSH
11361: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11365: LD_INT 105
11367: PPUSH
11368: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11372: LD_EXP 44
11376: PPUSH
11377: LD_STRING D4-Corn-1
11379: PPUSH
11380: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11384: LD_INT 35
11386: PPUSH
11387: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11391: LD_INT 22
11393: PUSH
11394: LD_INT 4
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: PUSH
11401: LD_INT 21
11403: PUSH
11404: LD_INT 1
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PUSH
11411: LD_INT 3
11413: PUSH
11414: LD_INT 24
11416: PUSH
11417: LD_INT 1000
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PUSH
11428: EMPTY
11429: LIST
11430: LIST
11431: LIST
11432: PPUSH
11433: CALL_OW 69
11437: PUSH
11438: LD_INT 6
11440: LESS
11441: IFFALSE 11384
// if Cornel then
11443: LD_EXP 44
11447: IFFALSE 11487
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11449: LD_EXP 44
11453: PPUSH
11454: LD_STRING D5-Corn-1
11456: PPUSH
11457: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11461: LD_EXP 44
11465: PPUSH
11466: LD_EXP 2
11470: PUSH
11471: LD_STRING Cornel
11473: STR
11474: PPUSH
11475: CALL_OW 38
// cornel_saved := true ;
11479: LD_ADDR_EXP 27
11483: PUSH
11484: LD_INT 1
11486: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11487: LD_INT 4
11489: PPUSH
11490: LD_INT 8
11492: PPUSH
11493: CALL_OW 343
// Wait ( 0 0$01 ) ;
11497: LD_INT 35
11499: PPUSH
11500: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11504: LD_INT 3
11506: PPUSH
11507: LD_EXP 44
11511: PPUSH
11512: CALL_OW 472
// send_attack_on_cornel := false ;
11516: LD_ADDR_EXP 32
11520: PUSH
11521: LD_INT 0
11523: ST_TO_ADDR
// end ;
11524: PPOPN 1
11526: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11527: LD_INT 9
11529: PPUSH
11530: LD_INT 22
11532: PUSH
11533: LD_INT 1
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: PPUSH
11540: CALL_OW 70
11544: PUSH
11545: LD_EXP 33
11549: OR
11550: IFFALSE 11747
11552: GO 11554
11554: DISABLE
11555: LD_INT 0
11557: PPUSH
11558: PPUSH
// begin enable ;
11559: ENABLE
// if not jmm_on_west then
11560: LD_EXP 5
11564: NOT
11565: IFFALSE 11576
// begin YouLost ( 4 ) ;
11567: LD_STRING 4
11569: PPUSH
11570: CALL_OW 104
// exit ;
11574: GO 11747
// end ; if not game_end then
11576: LD_EXP 33
11580: NOT
11581: IFFALSE 11591
// game_end := true ;
11583: LD_ADDR_EXP 33
11587: PUSH
11588: LD_INT 1
11590: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11591: LD_ADDR_VAR 0 2
11595: PUSH
11596: LD_INT 9
11598: PPUSH
11599: LD_INT 22
11601: PUSH
11602: LD_INT 1
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PPUSH
11609: CALL_OW 70
11613: ST_TO_ADDR
// if not filter then
11614: LD_VAR 0 2
11618: NOT
11619: IFFALSE 11623
// exit ;
11621: GO 11747
// for i in filter do
11623: LD_ADDR_VAR 0 1
11627: PUSH
11628: LD_VAR 0 2
11632: PUSH
11633: FOR_IN
11634: IFFALSE 11745
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11636: LD_VAR 0 1
11640: PPUSH
11641: CALL_OW 302
11645: PUSH
11646: LD_VAR 0 1
11650: PPUSH
11651: CALL_OW 247
11655: PUSH
11656: LD_INT 2
11658: EQUAL
11659: AND
11660: PUSH
11661: LD_VAR 0 1
11665: PPUSH
11666: CALL_OW 248
11670: PUSH
11671: LD_INT 1
11673: EQUAL
11674: AND
11675: IFFALSE 11708
// begin veh_on_meta := true ;
11677: LD_ADDR_EXP 28
11681: PUSH
11682: LD_INT 1
11684: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11685: LD_VAR 0 1
11689: PPUSH
11690: CALL_OW 311
11694: PPUSH
11695: CALL 11750 0 1
// RemoveUnit ( i ) ;
11699: LD_VAR 0 1
11703: PPUSH
11704: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL_OW 302
11717: PUSH
11718: LD_VAR 0 1
11722: PPUSH
11723: CALL_OW 247
11727: PUSH
11728: LD_INT 1
11730: EQUAL
11731: AND
11732: IFFALSE 11743
// Save ( i ) ;
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL 11750 0 1
// end ;
11743: GO 11633
11745: POP
11746: POP
// end ;
11747: PPOPN 2
11749: END
// export function Save ( i ) ; begin
11750: LD_INT 0
11752: PPUSH
// save_counter := save_counter + 1 ;
11753: LD_ADDR_EXP 36
11757: PUSH
11758: LD_EXP 36
11762: PUSH
11763: LD_INT 1
11765: PLUS
11766: ST_TO_ADDR
// if i = JMM then
11767: LD_VAR 0 1
11771: PUSH
11772: LD_EXP 37
11776: EQUAL
11777: IFFALSE 11899
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11779: LD_EXP 24
11783: PUSH
11784: LD_INT 22
11786: PUSH
11787: LD_INT 1
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: PUSH
11794: LD_INT 21
11796: PUSH
11797: LD_INT 1
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PPUSH
11808: CALL_OW 69
11812: PUSH
11813: LD_INT 1
11815: GREATER
11816: AND
11817: IFFALSE 11874
// begin show_query := false ;
11819: LD_ADDR_EXP 24
11823: PUSH
11824: LD_INT 0
11826: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11827: LD_STRING Q2
11829: PPUSH
11830: CALL_OW 97
11834: PUSH
11835: LD_INT 1
11837: DOUBLE
11838: EQUAL
11839: IFTRUE 11843
11841: GO 11854
11843: POP
// wait_for_them := true ; 2 :
11844: LD_ADDR_EXP 25
11848: PUSH
11849: LD_INT 1
11851: ST_TO_ADDR
11852: GO 11874
11854: LD_INT 2
11856: DOUBLE
11857: EQUAL
11858: IFTRUE 11862
11860: GO 11873
11862: POP
// wait_for_them := false ; end ;
11863: LD_ADDR_EXP 25
11867: PUSH
11868: LD_INT 0
11870: ST_TO_ADDR
11871: GO 11874
11873: POP
// end ; save_group := save_group ^ JMM ;
11874: LD_ADDR_EXP 23
11878: PUSH
11879: LD_EXP 23
11883: PUSH
11884: LD_EXP 37
11888: ADD
11889: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11890: LD_EXP 37
11894: PPUSH
11895: CALL_OW 64
// end ; if i = Lisa then
11899: LD_VAR 0 1
11903: PUSH
11904: LD_EXP 40
11908: EQUAL
11909: IFFALSE 11936
// begin save_group := save_group ^ Lisa ;
11911: LD_ADDR_EXP 23
11915: PUSH
11916: LD_EXP 23
11920: PUSH
11921: LD_EXP 40
11925: ADD
11926: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11927: LD_EXP 40
11931: PPUSH
11932: CALL_OW 64
// end ; if i = Bobby then
11936: LD_VAR 0 1
11940: PUSH
11941: LD_EXP 38
11945: EQUAL
11946: IFFALSE 11973
// begin save_group := save_group ^ Bobby ;
11948: LD_ADDR_EXP 23
11952: PUSH
11953: LD_EXP 23
11957: PUSH
11958: LD_EXP 38
11962: ADD
11963: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11964: LD_EXP 38
11968: PPUSH
11969: CALL_OW 64
// end ; if i = Cyrus then
11973: LD_VAR 0 1
11977: PUSH
11978: LD_EXP 39
11982: EQUAL
11983: IFFALSE 12010
// begin save_group := save_group ^ Cyrus ;
11985: LD_ADDR_EXP 23
11989: PUSH
11990: LD_EXP 23
11994: PUSH
11995: LD_EXP 39
11999: ADD
12000: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
12001: LD_EXP 39
12005: PPUSH
12006: CALL_OW 64
// end ; if i = Khatam then
12010: LD_VAR 0 1
12014: PUSH
12015: LD_EXP 41
12019: EQUAL
12020: IFFALSE 12047
// begin save_group := save_group ^ Khatam ;
12022: LD_ADDR_EXP 23
12026: PUSH
12027: LD_EXP 23
12031: PUSH
12032: LD_EXP 41
12036: ADD
12037: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
12038: LD_EXP 41
12042: PPUSH
12043: CALL_OW 64
// end ; if i = Frank then
12047: LD_VAR 0 1
12051: PUSH
12052: LD_EXP 51
12056: EQUAL
12057: IFFALSE 12084
// begin save_group := save_group ^ Frank ;
12059: LD_ADDR_EXP 23
12063: PUSH
12064: LD_EXP 23
12068: PUSH
12069: LD_EXP 51
12073: ADD
12074: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
12075: LD_EXP 51
12079: PPUSH
12080: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
12084: LD_VAR 0 1
12088: PPUSH
12089: CALL_OW 302
12093: PUSH
12094: LD_VAR 0 1
12098: PPUSH
12099: CALL_OW 247
12103: PUSH
12104: LD_INT 1
12106: EQUAL
12107: AND
12108: PUSH
12109: LD_VAR 0 1
12113: PUSH
12114: LD_EXP 23
12118: IN
12119: NOT
12120: AND
12121: IFFALSE 12148
// begin save_others := save_others ^ i ;
12123: LD_ADDR_EXP 22
12127: PUSH
12128: LD_EXP 22
12132: PUSH
12133: LD_VAR 0 1
12137: ADD
12138: ST_TO_ADDR
// RemoveUnit ( i ) ;
12139: LD_VAR 0 1
12143: PPUSH
12144: CALL_OW 64
// end ; end ;
12148: LD_VAR 0 2
12152: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12153: LD_EXP 24
12157: NOT
12158: PUSH
12159: LD_EXP 25
12163: NOT
12164: AND
12165: PUSH
12166: LD_INT 22
12168: PUSH
12169: LD_INT 1
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: PUSH
12176: LD_INT 21
12178: PUSH
12179: LD_INT 1
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PPUSH
12190: CALL_OW 69
12194: PUSH
12195: LD_INT 0
12197: EQUAL
12198: OR
12199: IFFALSE 12208
12201: GO 12203
12203: DISABLE
// EndMission ;
12204: CALL 12209 0 0
12208: END
// export function EndMission ; var i , m1 , m2 , m3 ; begin
12209: LD_INT 0
12211: PPUSH
12212: PPUSH
12213: PPUSH
12214: PPUSH
12215: PPUSH
// Wait ( 0 0$02 ) ;
12216: LD_INT 70
12218: PPUSH
12219: CALL_OW 67
// if tick <= 10 10$00 then
12223: LD_OWVAR 1
12227: PUSH
12228: LD_INT 21000
12230: LESSEQUAL
12231: IFFALSE 12240
// SetAchievement ( ACH_ASPEED_3 ) ;
12233: LD_STRING ACH_ASPEED_3
12235: PPUSH
12236: CALL_OW 543
// if UnitFilter ( save_group ^ save_others , [ f_class , 4 ] ) = 0 then
12240: LD_EXP 23
12244: PUSH
12245: LD_EXP 22
12249: ADD
12250: PPUSH
12251: LD_INT 25
12253: PUSH
12254: LD_INT 4
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PPUSH
12261: CALL_OW 72
12265: PUSH
12266: LD_INT 0
12268: EQUAL
12269: IFFALSE 12285
// begin wait ( 3 ) ;
12271: LD_INT 3
12273: PPUSH
12274: CALL_OW 67
// SetAchievement ( ACH_NOSCI ) ;
12278: LD_STRING ACH_NOSCI
12280: PPUSH
12281: CALL_OW 543
// end ; m1 := solar_builded ;
12285: LD_ADDR_VAR 0 3
12289: PUSH
12290: LD_EXP 14
12294: ST_TO_ADDR
// m2 := veh_on_meta ;
12295: LD_ADDR_VAR 0 4
12299: PUSH
12300: LD_EXP 28
12304: ST_TO_ADDR
// m3 := ( lose_counter = 0 ) ;
12305: LD_ADDR_VAR 0 5
12309: PUSH
12310: LD_EXP 34
12314: PUSH
12315: LD_INT 0
12317: EQUAL
12318: ST_TO_ADDR
// if solar_builded then
12319: LD_EXP 14
12323: IFFALSE 12337
// AddMedal ( Solar1 , 1 ) else
12325: LD_STRING Solar1
12327: PPUSH
12328: LD_INT 1
12330: PPUSH
12331: CALL_OW 101
12335: GO 12348
// AddMedal ( Solar1 , - 1 ) ;
12337: LD_STRING Solar1
12339: PPUSH
12340: LD_INT 1
12342: NEG
12343: PPUSH
12344: CALL_OW 101
// if veh_on_meta then
12348: LD_EXP 28
12352: IFFALSE 12366
// AddMedal ( Solar2 , 1 ) else
12354: LD_STRING Solar2
12356: PPUSH
12357: LD_INT 1
12359: PPUSH
12360: CALL_OW 101
12364: GO 12396
// if solar_builded then
12366: LD_EXP 14
12370: IFFALSE 12385
// AddMedal ( Solar2 , - 1 ) else
12372: LD_STRING Solar2
12374: PPUSH
12375: LD_INT 1
12377: NEG
12378: PPUSH
12379: CALL_OW 101
12383: GO 12396
// AddMedal ( Solar2 , - 2 ) ;
12385: LD_STRING Solar2
12387: PPUSH
12388: LD_INT 2
12390: NEG
12391: PPUSH
12392: CALL_OW 101
// if lose_counter = 0 then
12396: LD_EXP 34
12400: PUSH
12401: LD_INT 0
12403: EQUAL
12404: IFFALSE 12418
// AddMedal ( No , 1 ) else
12406: LD_STRING No
12408: PPUSH
12409: LD_INT 1
12411: PPUSH
12412: CALL_OW 101
12416: GO 12462
// if lose_counter > 0 and lose_counter < 4 then
12418: LD_EXP 34
12422: PUSH
12423: LD_INT 0
12425: GREATER
12426: PUSH
12427: LD_EXP 34
12431: PUSH
12432: LD_INT 4
12434: LESS
12435: AND
12436: IFFALSE 12451
// AddMedal ( No , - 1 ) else
12438: LD_STRING No
12440: PPUSH
12441: LD_INT 1
12443: NEG
12444: PPUSH
12445: CALL_OW 101
12449: GO 12462
// AddMedal ( UpTo4 , - 1 ) ;
12451: LD_STRING UpTo4
12453: PPUSH
12454: LD_INT 1
12456: NEG
12457: PPUSH
12458: CALL_OW 101
// GiveMedals ( MAIN ) ;
12462: LD_STRING MAIN
12464: PPUSH
12465: CALL_OW 102
// if Difficulty = 3 and m1 and m2 and m3 then
12469: LD_OWVAR 67
12473: PUSH
12474: LD_INT 3
12476: EQUAL
12477: PUSH
12478: LD_VAR 0 3
12482: AND
12483: PUSH
12484: LD_VAR 0 4
12488: AND
12489: PUSH
12490: LD_VAR 0 5
12494: AND
12495: IFFALSE 12507
// SetAchievementEX ( ACH_AMER , 3 ) ;
12497: LD_STRING ACH_AMER
12499: PPUSH
12500: LD_INT 3
12502: PPUSH
12503: CALL_OW 564
// if IsDead ( Pokryshkin ) then
12507: LD_EXP 52
12511: PPUSH
12512: CALL_OW 301
12516: IFFALSE 12572
// begin stop_talking := true ;
12518: LD_ADDR_OWVAR 56
12522: PUSH
12523: LD_INT 1
12525: ST_TO_ADDR
// for i in save_group ^ save_others do
12526: LD_ADDR_VAR 0 2
12530: PUSH
12531: LD_EXP 23
12535: PUSH
12536: LD_EXP 22
12540: ADD
12541: PUSH
12542: FOR_IN
12543: IFFALSE 12562
// AddExperience ( i , skill_combat , 1500 ) ;
12545: LD_VAR 0 2
12549: PPUSH
12550: LD_INT 1
12552: PPUSH
12553: LD_INT 1500
12555: PPUSH
12556: CALL_OW 492
12560: GO 12542
12562: POP
12563: POP
// stop_talking := false ;
12564: LD_ADDR_OWVAR 56
12568: PUSH
12569: LD_INT 0
12571: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12572: LD_EXP 23
12576: PUSH
12577: LD_EXP 22
12581: ADD
12582: PPUSH
12583: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12587: LD_EXP 37
12591: PPUSH
12592: LD_EXP 2
12596: PUSH
12597: LD_STRING JMM
12599: STR
12600: PPUSH
12601: CALL_OW 38
// if Bobby in save_group then
12605: LD_EXP 38
12609: PUSH
12610: LD_EXP 23
12614: IN
12615: IFFALSE 12635
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12617: LD_EXP 38
12621: PPUSH
12622: LD_EXP 2
12626: PUSH
12627: LD_STRING Bobby
12629: STR
12630: PPUSH
12631: CALL_OW 38
// if Cyrus in save_group then
12635: LD_EXP 39
12639: PUSH
12640: LD_EXP 23
12644: IN
12645: IFFALSE 12665
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12647: LD_EXP 39
12651: PPUSH
12652: LD_EXP 2
12656: PUSH
12657: LD_STRING Cyrus
12659: STR
12660: PPUSH
12661: CALL_OW 38
// if Lisa in save_group then
12665: LD_EXP 40
12669: PUSH
12670: LD_EXP 23
12674: IN
12675: IFFALSE 12695
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12677: LD_EXP 40
12681: PPUSH
12682: LD_EXP 2
12686: PUSH
12687: LD_STRING Lisa
12689: STR
12690: PPUSH
12691: CALL_OW 38
// if Frank in save_group then
12695: LD_EXP 51
12699: PUSH
12700: LD_EXP 23
12704: IN
12705: IFFALSE 12725
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12707: LD_EXP 51
12711: PPUSH
12712: LD_EXP 2
12716: PUSH
12717: LD_STRING Frank
12719: STR
12720: PPUSH
12721: CALL_OW 38
// if Khatam in save_group then
12725: LD_EXP 41
12729: PUSH
12730: LD_EXP 23
12734: IN
12735: IFFALSE 12755
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12737: LD_EXP 41
12741: PPUSH
12742: LD_EXP 2
12746: PUSH
12747: LD_STRING Khatam
12749: STR
12750: PPUSH
12751: CALL_OW 38
// if save_others then
12755: LD_EXP 22
12759: IFFALSE 12773
// SaveCharacters ( save_others , 03_others ) ;
12761: LD_EXP 22
12765: PPUSH
12766: LD_STRING 03_others
12768: PPUSH
12769: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12773: LD_EXP 45
12777: PUSH
12778: LD_EXP 45
12782: PPUSH
12783: CALL_OW 302
12787: AND
12788: PUSH
12789: LD_EXP 27
12793: AND
12794: IFFALSE 12806
// begin ResetFog ;
12796: CALL_OW 335
// DisplayEndingScene ;
12800: CALL 12828 0 0
// end else
12804: GO 12819
// DeleteCharacters ( mission_prefix & Cornel ) ;
12806: LD_EXP 2
12810: PUSH
12811: LD_STRING Cornel
12813: STR
12814: PPUSH
12815: CALL_OW 40
// YouWin ;
12819: CALL_OW 103
// end ;
12823: LD_VAR 0 1
12827: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12828: LD_INT 0
12830: PPUSH
12831: PPUSH
12832: PPUSH
12833: PPUSH
12834: PPUSH
12835: PPUSH
// InGameOn ;
12836: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12840: LD_INT 208
12842: PPUSH
12843: LD_INT 62
12845: PPUSH
12846: LD_INT 1
12848: PPUSH
12849: LD_INT 10
12851: NEG
12852: PPUSH
12853: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12857: LD_INT 208
12859: PPUSH
12860: LD_INT 62
12862: PPUSH
12863: LD_INT 1
12865: PPUSH
12866: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12870: LD_ADDR_VAR 0 3
12874: PUSH
12875: LD_INT 22
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 2
12887: PUSH
12888: LD_INT 21
12890: PUSH
12891: LD_INT 2
12893: PUSH
12894: EMPTY
12895: LIST
12896: LIST
12897: PUSH
12898: LD_INT 21
12900: PUSH
12901: LD_INT 1
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PPUSH
12917: CALL_OW 69
12921: ST_TO_ADDR
// if filter then
12922: LD_VAR 0 3
12926: IFFALSE 12954
// for i in filter do
12928: LD_ADDR_VAR 0 2
12932: PUSH
12933: LD_VAR 0 3
12937: PUSH
12938: FOR_IN
12939: IFFALSE 12952
// RemoveUnit ( i ) ;
12941: LD_VAR 0 2
12945: PPUSH
12946: CALL_OW 64
12950: GO 12938
12952: POP
12953: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12954: LD_ADDR_VAR 0 3
12958: PUSH
12959: LD_INT 22
12961: PUSH
12962: LD_INT 4
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PUSH
12969: LD_INT 21
12971: PUSH
12972: LD_INT 1
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: PPUSH
12983: CALL_OW 69
12987: ST_TO_ADDR
// if filter then
12988: LD_VAR 0 3
12992: IFFALSE 13023
// for i in filter do
12994: LD_ADDR_VAR 0 2
12998: PUSH
12999: LD_VAR 0 3
13003: PUSH
13004: FOR_IN
13005: IFFALSE 13021
// SetLives ( i , 0 ) ;
13007: LD_VAR 0 2
13011: PPUSH
13012: LD_INT 0
13014: PPUSH
13015: CALL_OW 234
13019: GO 13004
13021: POP
13022: POP
// uc_side := 4 ;
13023: LD_ADDR_OWVAR 20
13027: PUSH
13028: LD_INT 4
13030: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
13031: LD_ADDR_VAR 0 4
13035: PUSH
13036: LD_STRING Cornell
13038: PPUSH
13039: LD_INT 0
13041: PPUSH
13042: CALL 489 0 2
13046: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
13047: LD_VAR 0 4
13051: PPUSH
13052: LD_INT 208
13054: PPUSH
13055: LD_INT 62
13057: PPUSH
13058: LD_INT 0
13060: PPUSH
13061: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
13065: LD_VAR 0 4
13069: PPUSH
13070: LD_INT 100
13072: PPUSH
13073: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
13077: LD_INT 3
13079: PPUSH
13080: LD_VAR 0 4
13084: PPUSH
13085: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
13089: LD_INT 4
13091: PPUSH
13092: LD_INT 3
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 80
// uc_side := 3 ;
13105: LD_ADDR_OWVAR 20
13109: PUSH
13110: LD_INT 3
13112: ST_TO_ADDR
// uc_nation := 3 ;
13113: LD_ADDR_OWVAR 21
13117: PUSH
13118: LD_INT 3
13120: ST_TO_ADDR
// InitHc ;
13121: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
13125: LD_ADDR_VAR 0 5
13129: PUSH
13130: LD_STRING Mikhail
13132: PPUSH
13133: LD_INT 0
13135: PPUSH
13136: CALL 489 0 2
13140: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
13141: LD_INT 1
13143: PPUSH
13144: LD_INT 1
13146: PPUSH
13147: LD_INT 0
13149: PPUSH
13150: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13154: LD_ADDR_VAR 0 6
13158: PUSH
13159: LD_VAR 0 6
13163: PUSH
13164: CALL_OW 44
13168: ADD
13169: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
13170: LD_ADDR_VAR 0 6
13174: PUSH
13175: LD_VAR 0 6
13179: PUSH
13180: CALL_OW 44
13184: ADD
13185: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
13186: LD_INT 2
13188: PPUSH
13189: LD_INT 4
13191: PPUSH
13192: LD_INT 0
13194: PPUSH
13195: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13199: LD_ADDR_VAR 0 6
13203: PUSH
13204: LD_VAR 0 6
13208: PUSH
13209: CALL_OW 44
13213: ADD
13214: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
13215: LD_VAR 0 5
13219: PPUSH
13220: LD_INT 17
13222: PPUSH
13223: LD_INT 0
13225: PPUSH
13226: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
13230: LD_VAR 0 5
13234: PPUSH
13235: LD_INT 210
13237: PPUSH
13238: LD_INT 63
13240: PPUSH
13241: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
13245: LD_VAR 0 5
13249: PPUSH
13250: LD_INT 208
13252: PPUSH
13253: LD_INT 62
13255: PPUSH
13256: CALL_OW 178
// for i in fake_russians do
13260: LD_ADDR_VAR 0 2
13264: PUSH
13265: LD_VAR 0 6
13269: PUSH
13270: FOR_IN
13271: IFFALSE 13349
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13273: LD_VAR 0 2
13277: PPUSH
13278: LD_INT 17
13280: PPUSH
13281: LD_INT 0
13283: PPUSH
13284: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13288: LD_VAR 0 2
13292: PPUSH
13293: LD_INT 215
13295: PPUSH
13296: LD_INT 67
13298: PPUSH
13299: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13303: LD_VAR 0 2
13307: PPUSH
13308: LD_INT 208
13310: PPUSH
13311: LD_INT 62
13313: PPUSH
13314: CALL_OW 178
// if GetClass ( i ) = 4 then
13318: LD_VAR 0 2
13322: PPUSH
13323: CALL_OW 257
13327: PUSH
13328: LD_INT 4
13330: EQUAL
13331: IFFALSE 13347
// ComHeal ( i , fake_cornel ) ;
13333: LD_VAR 0 2
13337: PPUSH
13338: LD_VAR 0 4
13342: PPUSH
13343: CALL_OW 128
// end ;
13347: GO 13270
13349: POP
13350: POP
// Wait ( 0 0$01 ) ;
13351: LD_INT 35
13353: PPUSH
13354: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13358: LD_INT 208
13360: PPUSH
13361: LD_INT 62
13363: PPUSH
13364: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13368: LD_INT 208
13370: PPUSH
13371: LD_INT 62
13373: PPUSH
13374: LD_INT 1
13376: PPUSH
13377: LD_INT 10
13379: NEG
13380: PPUSH
13381: CALL_OW 330
// Wait ( 0 0$15 ) ;
13385: LD_INT 525
13387: PPUSH
13388: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13392: LD_INT 208
13394: PPUSH
13395: LD_INT 62
13397: PPUSH
13398: LD_INT 1
13400: PPUSH
13401: CALL_OW 331
// ResetFog ;
13405: CALL_OW 335
// InGameOff ;
13409: CALL_OW 9
// end ;
13413: LD_VAR 0 1
13417: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13418: LD_INT 10
13420: PPUSH
13421: LD_INT 22
13423: PUSH
13424: LD_INT 1
13426: PUSH
13427: EMPTY
13428: LIST
13429: LIST
13430: PPUSH
13431: CALL_OW 70
13435: PUSH
13436: LD_EXP 44
13440: PPUSH
13441: CALL_OW 302
13445: AND
13446: PUSH
13447: LD_INT 22
13449: PUSH
13450: LD_INT 1
13452: PUSH
13453: EMPTY
13454: LIST
13455: LIST
13456: PPUSH
13457: CALL_OW 69
13461: PPUSH
13462: LD_EXP 44
13466: PPUSH
13467: CALL_OW 74
13471: PPUSH
13472: LD_EXP 44
13476: PPUSH
13477: CALL_OW 296
13481: PUSH
13482: LD_INT 30
13484: LESS
13485: OR
13486: IFFALSE 13537
13488: GO 13490
13490: DISABLE
// begin enable ;
13491: ENABLE
// powell_warn := powell_warn + 1 ;
13492: LD_ADDR_EXP 35
13496: PUSH
13497: LD_EXP 35
13501: PUSH
13502: LD_INT 1
13504: PLUS
13505: ST_TO_ADDR
// if powell_warn = 3 then
13506: LD_EXP 35
13510: PUSH
13511: LD_INT 3
13513: EQUAL
13514: IFFALSE 13525
// begin YouLost ( 5 ) ;
13516: LD_STRING 5
13518: PPUSH
13519: CALL_OW 104
// exit ;
13523: GO 13537
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13525: LD_EXP 46
13529: PPUSH
13530: LD_STRING DWarn-Pow-1
13532: PPUSH
13533: CALL_OW 94
// end ; end_of_file
13537: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13538: LD_EXP 8
13542: IFFALSE 15379
13544: GO 13546
13546: DISABLE
13547: LD_INT 0
13549: PPUSH
13550: PPUSH
13551: PPUSH
13552: PPUSH
13553: PPUSH
13554: PPUSH
13555: PPUSH
13556: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13557: LD_EXP 44
13561: PUSH
13562: LD_EXP 45
13566: ADD
13567: PUSH
13568: LD_EXP 6
13572: ADD
13573: PPUSH
13574: LD_INT 250
13576: PPUSH
13577: LD_INT 120
13579: PPUSH
13580: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13584: LD_ADDR_VAR 0 2
13588: PUSH
13589: LD_EXP 6
13593: PPUSH
13594: LD_INT 25
13596: PUSH
13597: LD_INT 2
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PPUSH
13604: CALL_OW 72
13608: PUSH
13609: LD_EXP 45
13613: DIFF
13614: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13615: LD_ADDR_VAR 0 3
13619: PUSH
13620: LD_EXP 6
13624: PPUSH
13625: LD_INT 21
13627: PUSH
13628: LD_INT 1
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 72
13639: PUSH
13640: LD_VAR 0 2
13644: DIFF
13645: ST_TO_ADDR
// if not has_eng then
13646: LD_VAR 0 2
13650: NOT
13651: IFFALSE 13734
// begin uc_side := 4 ;
13653: LD_ADDR_OWVAR 20
13657: PUSH
13658: LD_INT 4
13660: ST_TO_ADDR
// uc_nation := 1 ;
13661: LD_ADDR_OWVAR 21
13665: PUSH
13666: LD_INT 1
13668: ST_TO_ADDR
// bc_type := b_depot ;
13669: LD_ADDR_OWVAR 42
13673: PUSH
13674: LD_INT 0
13676: ST_TO_ADDR
// bc_level := 2 ;
13677: LD_ADDR_OWVAR 43
13681: PUSH
13682: LD_INT 2
13684: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13685: LD_ADDR_VAR 0 4
13689: PUSH
13690: LD_INT 264
13692: PPUSH
13693: LD_INT 120
13695: PPUSH
13696: LD_INT 4
13698: PPUSH
13699: CALL_OW 47
13703: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13704: LD_INT 264
13706: PPUSH
13707: LD_INT 120
13709: PPUSH
13710: LD_INT 4
13712: PPUSH
13713: LD_INT 10
13715: NEG
13716: PPUSH
13717: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13721: LD_INT 264
13723: PPUSH
13724: LD_INT 120
13726: PPUSH
13727: LD_INT 4
13729: PPUSH
13730: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13734: LD_INT 35
13736: PPUSH
13737: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13741: LD_EXP 44
13745: PPUSH
13746: LD_INT 10
13748: PPUSH
13749: CALL_OW 308
13753: PUSH
13754: LD_EXP 44
13758: PPUSH
13759: CALL_OW 310
13763: PPUSH
13764: LD_INT 10
13766: PPUSH
13767: CALL_OW 308
13771: OR
13772: IFFALSE 13734
// if has_eng and not dep then
13774: LD_VAR 0 2
13778: PUSH
13779: LD_VAR 0 4
13783: NOT
13784: AND
13785: IFFALSE 13935
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13787: LD_VAR 0 2
13791: PPUSH
13792: LD_INT 0
13794: PPUSH
13795: LD_INT 264
13797: PPUSH
13798: LD_INT 120
13800: PPUSH
13801: LD_INT 4
13803: PPUSH
13804: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13808: LD_INT 35
13810: PPUSH
13811: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13815: LD_INT 22
13817: PUSH
13818: LD_INT 4
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PUSH
13825: LD_INT 30
13827: PUSH
13828: LD_INT 0
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PPUSH
13839: CALL_OW 69
13843: IFFALSE 13808
// ComMoveXY ( filter , 264 , 120 ) ;
13845: LD_VAR 0 3
13849: PPUSH
13850: LD_INT 264
13852: PPUSH
13853: LD_INT 120
13855: PPUSH
13856: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13860: LD_INT 35
13862: PPUSH
13863: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13867: LD_INT 22
13869: PUSH
13870: LD_INT 4
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: PUSH
13877: LD_INT 30
13879: PUSH
13880: LD_INT 0
13882: PUSH
13883: EMPTY
13884: LIST
13885: LIST
13886: PUSH
13887: LD_INT 3
13889: PUSH
13890: LD_INT 57
13892: PUSH
13893: EMPTY
13894: LIST
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: EMPTY
13901: LIST
13902: LIST
13903: LIST
13904: PPUSH
13905: CALL_OW 69
13909: IFFALSE 13860
// ComMoveXY ( filter , 247 , 113 ) ;
13911: LD_VAR 0 3
13915: PPUSH
13916: LD_INT 247
13918: PPUSH
13919: LD_INT 113
13921: PPUSH
13922: CALL_OW 111
// Wait ( 0 0$2 ) ;
13926: LD_INT 70
13928: PPUSH
13929: CALL_OW 67
// end else
13933: GO 13947
// begin SetSide ( dep , 4 ) ;
13935: LD_VAR 0 4
13939: PPUSH
13940: LD_INT 4
13942: PPUSH
13943: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13947: LD_ADDR_VAR 0 4
13951: PUSH
13952: LD_INT 22
13954: PUSH
13955: LD_INT 4
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: LD_INT 30
13964: PUSH
13965: LD_INT 0
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PPUSH
13976: CALL_OW 69
13980: PUSH
13981: LD_INT 1
13983: ARRAY
13984: ST_TO_ADDR
// if not has_eng then
13985: LD_VAR 0 2
13989: NOT
13990: IFFALSE 14077
// for i = 1 to 2 do
13992: LD_ADDR_VAR 0 1
13996: PUSH
13997: DOUBLE
13998: LD_INT 1
14000: DEC
14001: ST_TO_ADDR
14002: LD_INT 2
14004: PUSH
14005: FOR_TO
14006: IFFALSE 14075
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
14008: LD_VAR 0 3
14012: PUSH
14013: LD_INT 1
14015: ARRAY
14016: PPUSH
14017: LD_VAR 0 4
14021: PPUSH
14022: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
14026: LD_VAR 0 3
14030: PUSH
14031: LD_INT 1
14033: ARRAY
14034: PPUSH
14035: LD_INT 2
14037: PPUSH
14038: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
14042: LD_VAR 0 3
14046: PUSH
14047: LD_INT 1
14049: ARRAY
14050: PPUSH
14051: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
14055: LD_ADDR_VAR 0 3
14059: PUSH
14060: LD_VAR 0 3
14064: PPUSH
14065: LD_INT 1
14067: PPUSH
14068: CALL_OW 3
14072: ST_TO_ADDR
// end ;
14073: GO 14005
14075: POP
14076: POP
// if IsInUnit ( Cornel ) then
14077: LD_EXP 44
14081: PPUSH
14082: CALL_OW 310
14086: IFFALSE 14164
// begin cargo := IsInUnit ( Cornel ) ;
14088: LD_ADDR_VAR 0 7
14092: PUSH
14093: LD_EXP 44
14097: PPUSH
14098: CALL_OW 310
14102: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
14103: LD_VAR 0 7
14107: PPUSH
14108: LD_INT 1
14110: PPUSH
14111: CALL_OW 289
14115: IFFALSE 14126
// ComUnload ( cargo ) ;
14117: LD_VAR 0 7
14121: PPUSH
14122: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
14126: LD_EXP 44
14130: PPUSH
14131: LD_INT 235
14133: PPUSH
14134: LD_INT 122
14136: PPUSH
14137: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
14141: LD_EXP 44
14145: PPUSH
14146: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
14150: LD_EXP 44
14154: PPUSH
14155: LD_VAR 0 4
14159: PPUSH
14160: CALL_OW 180
// end ; if Bierezov then
14164: LD_EXP 45
14168: IFFALSE 14216
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
14170: LD_EXP 45
14174: PPUSH
14175: LD_INT 260
14177: PPUSH
14178: LD_INT 120
14180: PPUSH
14181: CALL_OW 111
// if dep then
14185: LD_VAR 0 4
14189: IFFALSE 14207
// AddComEnterUnit ( Bierezov , dep ) else
14191: LD_EXP 45
14195: PPUSH
14196: LD_VAR 0 4
14200: PPUSH
14201: CALL_OW 180
14205: GO 14216
// AddComHold ( Bierezov ) ;
14207: LD_EXP 45
14211: PPUSH
14212: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
14216: LD_INT 525
14218: PPUSH
14219: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
14223: LD_ADDR_VAR 0 2
14227: PUSH
14228: LD_INT 22
14230: PUSH
14231: LD_INT 4
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 25
14240: PUSH
14241: LD_INT 2
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: EMPTY
14249: LIST
14250: LIST
14251: PPUSH
14252: CALL_OW 69
14256: PUSH
14257: LD_EXP 45
14261: DIFF
14262: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14263: LD_INT 35
14265: PPUSH
14266: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14270: LD_ADDR_VAR 0 6
14274: PUSH
14275: LD_INT 10
14277: PPUSH
14278: CALL_OW 435
14282: ST_TO_ADDR
// if crates then
14283: LD_VAR 0 6
14287: IFFALSE 14316
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14289: LD_VAR 0 2
14293: PPUSH
14294: LD_VAR 0 6
14298: PUSH
14299: LD_INT 1
14301: ARRAY
14302: PPUSH
14303: LD_VAR 0 6
14307: PUSH
14308: LD_INT 2
14310: ARRAY
14311: PPUSH
14312: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14316: LD_VAR 0 4
14320: PPUSH
14321: CALL_OW 274
14325: PPUSH
14326: LD_INT 1
14328: PPUSH
14329: CALL_OW 275
14333: PUSH
14334: LD_INT 40
14336: GREATEREQUAL
14337: IFFALSE 14263
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14339: LD_ADDR_VAR 0 5
14343: PUSH
14344: LD_INT 4
14346: PUSH
14347: LD_INT 256
14349: PUSH
14350: LD_INT 111
14352: PUSH
14353: LD_INT 2
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: PUSH
14362: LD_INT 31
14364: PUSH
14365: LD_INT 243
14367: PUSH
14368: LD_INT 112
14370: PUSH
14371: LD_INT 2
14373: PUSH
14374: EMPTY
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: PUSH
14380: LD_INT 31
14382: PUSH
14383: LD_INT 254
14385: PUSH
14386: LD_INT 114
14388: PUSH
14389: LD_INT 2
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: ST_TO_ADDR
// for i in blist do
14403: LD_ADDR_VAR 0 1
14407: PUSH
14408: LD_VAR 0 5
14412: PUSH
14413: FOR_IN
14414: IFFALSE 14463
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14416: LD_VAR 0 2
14420: PPUSH
14421: LD_VAR 0 1
14425: PUSH
14426: LD_INT 1
14428: ARRAY
14429: PPUSH
14430: LD_VAR 0 1
14434: PUSH
14435: LD_INT 2
14437: ARRAY
14438: PPUSH
14439: LD_VAR 0 1
14443: PUSH
14444: LD_INT 3
14446: ARRAY
14447: PPUSH
14448: LD_VAR 0 1
14452: PUSH
14453: LD_INT 4
14455: ARRAY
14456: PPUSH
14457: CALL_OW 205
14461: GO 14413
14463: POP
14464: POP
// repeat wait ( 0 0$01 ) ;
14465: LD_INT 35
14467: PPUSH
14468: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14472: LD_INT 22
14474: PUSH
14475: LD_INT 4
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PUSH
14482: LD_INT 30
14484: PUSH
14485: LD_INT 4
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: PUSH
14492: LD_INT 3
14494: PUSH
14495: LD_INT 57
14497: PUSH
14498: EMPTY
14499: LIST
14500: PUSH
14501: EMPTY
14502: LIST
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: IFFALSE 14465
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14516: LD_VAR 0 3
14520: PPUSH
14521: LD_INT 22
14523: PUSH
14524: LD_INT 4
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: LD_INT 30
14533: PUSH
14534: LD_INT 4
14536: PUSH
14537: EMPTY
14538: LIST
14539: LIST
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PPUSH
14545: CALL_OW 69
14549: PUSH
14550: LD_INT 1
14552: ARRAY
14553: PPUSH
14554: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14558: LD_VAR 0 3
14562: PPUSH
14563: LD_INT 1
14565: PPUSH
14566: CALL_OW 183
// if has_eng > 1 then
14570: LD_VAR 0 2
14574: PUSH
14575: LD_INT 1
14577: GREATER
14578: IFFALSE 14720
// for i = has_eng downto 2 do
14580: LD_ADDR_VAR 0 1
14584: PUSH
14585: DOUBLE
14586: LD_VAR 0 2
14590: INC
14591: ST_TO_ADDR
14592: LD_INT 2
14594: PUSH
14595: FOR_DOWNTO
14596: IFFALSE 14718
// begin if IsInUnit ( has_eng [ i ] ) then
14598: LD_VAR 0 2
14602: PUSH
14603: LD_VAR 0 1
14607: ARRAY
14608: PPUSH
14609: CALL_OW 310
14613: IFFALSE 14630
// ComExitBuilding ( has_eng [ i ] ) ;
14615: LD_VAR 0 2
14619: PUSH
14620: LD_VAR 0 1
14624: ARRAY
14625: PPUSH
14626: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14630: LD_VAR 0 2
14634: PUSH
14635: LD_VAR 0 1
14639: ARRAY
14640: PPUSH
14641: LD_INT 22
14643: PUSH
14644: LD_INT 4
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PUSH
14651: LD_INT 30
14653: PUSH
14654: LD_INT 4
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PPUSH
14665: CALL_OW 69
14669: PUSH
14670: LD_INT 1
14672: ARRAY
14673: PPUSH
14674: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14678: LD_VAR 0 2
14682: PUSH
14683: LD_VAR 0 1
14687: ARRAY
14688: PPUSH
14689: LD_INT 1
14691: PPUSH
14692: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14696: LD_ADDR_VAR 0 2
14700: PUSH
14701: LD_VAR 0 2
14705: PPUSH
14706: LD_VAR 0 1
14710: PPUSH
14711: CALL_OW 3
14715: ST_TO_ADDR
// end ;
14716: GO 14595
14718: POP
14719: POP
// repeat wait ( 0 0$01 ) ;
14720: LD_INT 35
14722: PPUSH
14723: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14727: LD_INT 22
14729: PUSH
14730: LD_INT 4
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PUSH
14737: LD_INT 30
14739: PUSH
14740: LD_INT 31
14742: PUSH
14743: EMPTY
14744: LIST
14745: LIST
14746: PUSH
14747: LD_INT 3
14749: PUSH
14750: LD_INT 57
14752: PUSH
14753: EMPTY
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: LIST
14764: PPUSH
14765: CALL_OW 69
14769: PUSH
14770: LD_INT 1
14772: GREATER
14773: IFFALSE 14720
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14775: LD_ADDR_VAR 0 8
14779: PUSH
14780: LD_EXP 6
14784: PPUSH
14785: LD_INT 25
14787: PUSH
14788: LD_INT 1
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: PPUSH
14795: CALL_OW 72
14799: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14800: LD_ADDR_VAR 0 1
14804: PUSH
14805: DOUBLE
14806: LD_INT 1
14808: DEC
14809: ST_TO_ADDR
14810: LD_INT 22
14812: PUSH
14813: LD_INT 4
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: PUSH
14820: LD_INT 30
14822: PUSH
14823: LD_INT 31
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PUSH
14830: LD_INT 3
14832: PUSH
14833: LD_INT 57
14835: PUSH
14836: EMPTY
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: LIST
14847: PPUSH
14848: CALL_OW 69
14852: PUSH
14853: FOR_TO
14854: IFFALSE 14938
// begin if not sol [ i ] then
14856: LD_VAR 0 8
14860: PUSH
14861: LD_VAR 0 1
14865: ARRAY
14866: NOT
14867: IFFALSE 14871
// break ;
14869: GO 14938
// ComExitBuilding ( sol [ i ] ) ;
14871: LD_VAR 0 8
14875: PUSH
14876: LD_VAR 0 1
14880: ARRAY
14881: PPUSH
14882: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14886: LD_VAR 0 8
14890: PUSH
14891: LD_VAR 0 1
14895: ARRAY
14896: PPUSH
14897: LD_INT 22
14899: PUSH
14900: LD_INT 4
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 30
14909: PUSH
14910: LD_INT 31
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PPUSH
14921: CALL_OW 69
14925: PUSH
14926: LD_VAR 0 1
14930: ARRAY
14931: PPUSH
14932: CALL_OW 180
// end ;
14936: GO 14853
14938: POP
14939: POP
// if sol > 3 then
14940: LD_VAR 0 8
14944: PUSH
14945: LD_INT 3
14947: GREATER
14948: IFFALSE 15065
// begin ComExitBuilding ( sol [ 3 ] ) ;
14950: LD_VAR 0 8
14954: PUSH
14955: LD_INT 3
14957: ARRAY
14958: PPUSH
14959: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14963: LD_VAR 0 8
14967: PUSH
14968: LD_INT 3
14970: ARRAY
14971: PPUSH
14972: LD_INT 246
14974: PPUSH
14975: LD_INT 94
14977: PPUSH
14978: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14982: LD_VAR 0 8
14986: PUSH
14987: LD_INT 3
14989: ARRAY
14990: PPUSH
14991: LD_INT 175
14993: PPUSH
14994: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14998: LD_VAR 0 8
15002: PUSH
15003: LD_INT 3
15005: ARRAY
15006: PPUSH
15007: LD_INT 224
15009: PPUSH
15010: LD_INT 90
15012: PPUSH
15013: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
15017: LD_VAR 0 8
15021: PUSH
15022: LD_INT 3
15024: ARRAY
15025: PPUSH
15026: LD_INT 245
15028: PPUSH
15029: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
15033: LD_VAR 0 8
15037: PUSH
15038: LD_INT 3
15040: ARRAY
15041: PPUSH
15042: LD_INT 223
15044: PPUSH
15045: LD_INT 110
15047: PPUSH
15048: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
15052: LD_VAR 0 8
15056: PUSH
15057: LD_INT 3
15059: ARRAY
15060: PPUSH
15061: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
15065: LD_VAR 0 2
15069: PPUSH
15070: LD_VAR 0 4
15074: PPUSH
15075: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
15079: LD_INT 22
15081: PUSH
15082: LD_INT 4
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_INT 30
15091: PUSH
15092: LD_INT 4
15094: PUSH
15095: EMPTY
15096: LIST
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: PPUSH
15103: CALL_OW 69
15107: PUSH
15108: LD_INT 1
15110: ARRAY
15111: PPUSH
15112: CALL_OW 313
15116: PUSH
15117: LD_INT 6
15119: LESS
15120: IFFALSE 15184
// begin if IsInUnit ( Cornel ) then
15122: LD_EXP 44
15126: PPUSH
15127: CALL_OW 310
15131: IFFALSE 15142
// ComExitBuilding ( Cornel ) ;
15133: LD_EXP 44
15137: PPUSH
15138: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
15142: LD_EXP 44
15146: PPUSH
15147: LD_INT 22
15149: PUSH
15150: LD_INT 4
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: PUSH
15157: LD_INT 30
15159: PUSH
15160: LD_INT 4
15162: PUSH
15163: EMPTY
15164: LIST
15165: LIST
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: PPUSH
15171: CALL_OW 69
15175: PUSH
15176: LD_INT 1
15178: ARRAY
15179: PPUSH
15180: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
15184: LD_INT 35
15186: PPUSH
15187: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
15191: LD_ADDR_VAR 0 3
15195: PUSH
15196: LD_INT 22
15198: PUSH
15199: LD_INT 4
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PUSH
15206: LD_INT 21
15208: PUSH
15209: LD_INT 3
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: PUSH
15216: LD_INT 3
15218: PUSH
15219: LD_INT 24
15221: PUSH
15222: LD_INT 1000
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PUSH
15229: EMPTY
15230: LIST
15231: LIST
15232: PUSH
15233: EMPTY
15234: LIST
15235: LIST
15236: LIST
15237: PPUSH
15238: CALL_OW 69
15242: ST_TO_ADDR
// if filter and has_eng then
15243: LD_VAR 0 3
15247: PUSH
15248: LD_VAR 0 2
15252: AND
15253: IFFALSE 15319
// begin for i in has_eng do
15255: LD_ADDR_VAR 0 1
15259: PUSH
15260: LD_VAR 0 2
15264: PUSH
15265: FOR_IN
15266: IFFALSE 15315
// begin if IsInUnit ( i ) then
15268: LD_VAR 0 1
15272: PPUSH
15273: CALL_OW 310
15277: IFFALSE 15288
// ComExitBuilding ( i ) ;
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 122
// Wait ( 3 ) ;
15288: LD_INT 3
15290: PPUSH
15291: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15295: LD_VAR 0 1
15299: PPUSH
15300: LD_VAR 0 3
15304: PUSH
15305: LD_INT 1
15307: ARRAY
15308: PPUSH
15309: CALL_OW 130
// end ;
15313: GO 15265
15315: POP
15316: POP
// end else
15317: GO 15373
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15319: LD_VAR 0 2
15323: PUSH
15324: LD_VAR 0 2
15328: PPUSH
15329: LD_INT 56
15331: PUSH
15332: EMPTY
15333: LIST
15334: PPUSH
15335: CALL_OW 72
15339: AND
15340: IFFALSE 15373
// for i in has_eng do
15342: LD_ADDR_VAR 0 1
15346: PUSH
15347: LD_VAR 0 2
15351: PUSH
15352: FOR_IN
15353: IFFALSE 15371
// ComEnterUnit ( i , dep ) ;
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 4
15364: PPUSH
15365: CALL_OW 120
15369: GO 15352
15371: POP
15372: POP
// until cornel_prepared ;
15373: LD_EXP 11
15377: IFFALSE 15184
// end ;
15379: PPOPN 8
15381: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15382: LD_EXP 11
15386: IFFALSE 15785
15388: GO 15390
15390: DISABLE
15391: LD_INT 0
15393: PPUSH
15394: PPUSH
15395: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_INT 22
15403: PUSH
15404: LD_INT 4
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PUSH
15411: LD_INT 30
15413: PUSH
15414: LD_INT 4
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: PPUSH
15425: CALL_OW 69
15429: PUSH
15430: LD_INT 1
15432: ARRAY
15433: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15434: LD_EXP 6
15438: PPUSH
15439: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15443: LD_EXP 45
15447: PUSH
15448: LD_EXP 45
15452: PPUSH
15453: CALL_OW 310
15457: AND
15458: IFFALSE 15469
// ComExitBuilding ( Bierezov ) ;
15460: LD_EXP 45
15464: PPUSH
15465: CALL_OW 122
// Wait ( 0 0$03 ) ;
15469: LD_INT 105
15471: PPUSH
15472: CALL_OW 67
// for i in cornel_units do
15476: LD_ADDR_VAR 0 1
15480: PUSH
15481: LD_EXP 6
15485: PUSH
15486: FOR_IN
15487: IFFALSE 15563
// begin if GetClass ( i ) in [ 2 , 3 ] then
15489: LD_VAR 0 1
15493: PPUSH
15494: CALL_OW 257
15498: PUSH
15499: LD_INT 2
15501: PUSH
15502: LD_INT 3
15504: PUSH
15505: EMPTY
15506: LIST
15507: LIST
15508: IN
15509: IFFALSE 15546
// begin ComEnterUnit ( i , arm ) ;
15511: LD_VAR 0 1
15515: PPUSH
15516: LD_VAR 0 2
15520: PPUSH
15521: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15525: LD_VAR 0 1
15529: PPUSH
15530: LD_INT 1
15532: PPUSH
15533: CALL_OW 183
// AddComExitBuilding ( i ) ;
15537: LD_VAR 0 1
15541: PPUSH
15542: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15546: LD_VAR 0 1
15550: PPUSH
15551: LD_INT 257
15553: PPUSH
15554: LD_INT 121
15556: PPUSH
15557: CALL_OW 171
// end ;
15561: GO 15486
15563: POP
15564: POP
// Wait ( 1 1$00 ) ;
15565: LD_INT 2100
15567: PPUSH
15568: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15572: LD_ADDR_VAR 0 3
15576: PUSH
15577: LD_EXP 44
15581: PUSH
15582: LD_EXP 45
15586: ADD
15587: PUSH
15588: LD_EXP 6
15592: ADD
15593: PUSH
15594: LD_EXP 6
15598: PPUSH
15599: LD_INT 21
15601: PUSH
15602: LD_INT 2
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PPUSH
15609: CALL_OW 72
15613: DIFF
15614: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15615: LD_VAR 0 3
15619: PPUSH
15620: LD_INT 248
15622: PPUSH
15623: LD_INT 85
15625: PPUSH
15626: CALL_OW 111
// AddComHold ( filter ) ;
15630: LD_VAR 0 3
15634: PPUSH
15635: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15639: LD_INT 35
15641: PPUSH
15642: CALL_OW 67
// until cornel_attack ;
15646: LD_EXP 9
15650: IFFALSE 15639
// ComAgressiveMove ( filter , 209 , 63 ) ;
15652: LD_VAR 0 3
15656: PPUSH
15657: LD_INT 209
15659: PPUSH
15660: LD_INT 63
15662: PPUSH
15663: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15667: LD_EXP 44
15671: PPUSH
15672: LD_INT 208
15674: PPUSH
15675: LD_INT 62
15677: PPUSH
15678: CALL_OW 114
// AddComHold ( Cornel ) ;
15682: LD_EXP 44
15686: PPUSH
15687: CALL_OW 200
// if Bierezov then
15691: LD_EXP 45
15695: IFFALSE 15785
// begin filter := filter diff Bierezov ;
15697: LD_ADDR_VAR 0 3
15701: PUSH
15702: LD_VAR 0 3
15706: PUSH
15707: LD_EXP 45
15711: DIFF
15712: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15713: LD_EXP 45
15717: PPUSH
15718: LD_INT 6
15720: PPUSH
15721: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15725: LD_EXP 45
15729: PPUSH
15730: LD_INT 235
15732: PPUSH
15733: LD_INT 60
15735: PPUSH
15736: CALL_OW 111
// AddComHold ( Bierezov ) ;
15740: LD_EXP 45
15744: PPUSH
15745: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15749: LD_EXP 45
15753: PPUSH
15754: LD_INT 350
15756: PPUSH
15757: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15761: LD_EXP 45
15765: PPUSH
15766: LD_INT 198
15768: PPUSH
15769: LD_INT 28
15771: PPUSH
15772: CALL_OW 171
// AddComHold ( Bierezov ) ;
15776: LD_EXP 45
15780: PPUSH
15781: CALL_OW 200
// end ; end ; end_of_file
15785: PPOPN 3
15787: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15788: LD_EXP 53
15792: PUSH
15793: LD_EXP 31
15797: NOT
15798: AND
15799: PUSH
15800: LD_EXP 32
15804: NOT
15805: AND
15806: IFFALSE 16256
15808: GO 15810
15810: DISABLE
15811: LD_INT 0
15813: PPUSH
15814: PPUSH
15815: PPUSH
15816: PPUSH
// begin enable ;
15817: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15818: LD_ADDR_VAR 0 4
15822: PUSH
15823: LD_INT 81
15825: PUSH
15826: LD_INT 3
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: PPUSH
15833: CALL_OW 69
15837: ST_TO_ADDR
// for i = 1 to ru_patrol do
15838: LD_ADDR_VAR 0 2
15842: PUSH
15843: DOUBLE
15844: LD_INT 1
15846: DEC
15847: ST_TO_ADDR
15848: LD_EXP 53
15852: PUSH
15853: FOR_TO
15854: IFFALSE 16254
// begin un := ru_patrol [ i ] ;
15856: LD_ADDR_VAR 0 1
15860: PUSH
15861: LD_EXP 53
15865: PUSH
15866: LD_VAR 0 2
15870: ARRAY
15871: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15872: LD_VAR 0 1
15876: PPUSH
15877: LD_INT 13
15879: PPUSH
15880: CALL_OW 308
15884: IFFALSE 15989
// begin if not ru_alert then
15886: LD_EXP 60
15890: NOT
15891: IFFALSE 15901
// ru_alert := true ;
15893: LD_ADDR_EXP 60
15897: PUSH
15898: LD_INT 1
15900: ST_TO_ADDR
// if not See ( 1 , un ) then
15901: LD_INT 1
15903: PPUSH
15904: LD_VAR 0 1
15908: PPUSH
15909: CALL_OW 292
15913: NOT
15914: IFFALSE 15928
// SetLives ( un , 1000 ) ;
15916: LD_VAR 0 1
15920: PPUSH
15921: LD_INT 1000
15923: PPUSH
15924: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15928: LD_ADDR_EXP 53
15932: PUSH
15933: LD_EXP 53
15937: PUSH
15938: LD_VAR 0 1
15942: DIFF
15943: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15944: LD_VAR 0 1
15948: PPUSH
15949: LD_INT 22
15951: PUSH
15952: LD_INT 3
15954: PUSH
15955: EMPTY
15956: LIST
15957: LIST
15958: PUSH
15959: LD_INT 30
15961: PUSH
15962: LD_INT 4
15964: PUSH
15965: EMPTY
15966: LIST
15967: LIST
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 69
15977: PPUSH
15978: CALL 1062 0 1
15982: PPUSH
15983: CALL_OW 120
// continue ;
15987: GO 15853
// end ; if IsOk ( un ) and not HasTask ( un ) then
15989: LD_VAR 0 1
15993: PPUSH
15994: CALL_OW 302
15998: PUSH
15999: LD_VAR 0 1
16003: PPUSH
16004: CALL_OW 314
16008: NOT
16009: AND
16010: IFFALSE 16103
// begin for j = 1 to ru_firepoints_south [ i ] do
16012: LD_ADDR_VAR 0 3
16016: PUSH
16017: DOUBLE
16018: LD_INT 1
16020: DEC
16021: ST_TO_ADDR
16022: LD_EXP 59
16026: PUSH
16027: LD_VAR 0 2
16031: ARRAY
16032: PUSH
16033: FOR_TO
16034: IFFALSE 16101
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_EXP 59
16045: PUSH
16046: LD_VAR 0 2
16050: ARRAY
16051: PUSH
16052: LD_VAR 0 3
16056: ARRAY
16057: PUSH
16058: LD_INT 1
16060: ARRAY
16061: PPUSH
16062: LD_EXP 59
16066: PUSH
16067: LD_VAR 0 2
16071: ARRAY
16072: PUSH
16073: LD_VAR 0 3
16077: ARRAY
16078: PUSH
16079: LD_INT 2
16081: ARRAY
16082: PPUSH
16083: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
16087: LD_VAR 0 1
16091: PPUSH
16092: LD_INT 70
16094: PPUSH
16095: CALL_OW 202
// end ;
16099: GO 16033
16101: POP
16102: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16103: LD_VAR 0 1
16107: PPUSH
16108: CALL_OW 256
16112: PUSH
16113: LD_INT 700
16115: LESS
16116: PUSH
16117: LD_VAR 0 1
16121: PPUSH
16122: LD_INT 13
16124: PPUSH
16125: CALL_OW 308
16129: NOT
16130: AND
16131: IFFALSE 16183
// begin ComMoveToArea ( un , retreatArea ) ;
16133: LD_VAR 0 1
16137: PPUSH
16138: LD_INT 13
16140: PPUSH
16141: CALL_OW 113
// if not ru_alert_xy then
16145: LD_EXP 61
16149: NOT
16150: IFFALSE 16181
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
16152: LD_ADDR_EXP 61
16156: PUSH
16157: LD_VAR 0 1
16161: PPUSH
16162: CALL_OW 250
16166: PUSH
16167: LD_VAR 0 1
16171: PPUSH
16172: CALL_OW 251
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: ST_TO_ADDR
// end else
16181: GO 16252
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16183: LD_VAR 0 1
16187: PPUSH
16188: LD_VAR 0 4
16192: PPUSH
16193: LD_VAR 0 1
16197: PPUSH
16198: CALL_OW 74
16202: PPUSH
16203: CALL_OW 296
16207: PUSH
16208: LD_INT 9
16210: LESS
16211: PUSH
16212: LD_VAR 0 1
16216: PPUSH
16217: CALL_OW 256
16221: PUSH
16222: LD_INT 500
16224: GREATER
16225: AND
16226: IFFALSE 16252
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16228: LD_VAR 0 1
16232: PPUSH
16233: LD_VAR 0 4
16237: PPUSH
16238: LD_VAR 0 1
16242: PPUSH
16243: CALL_OW 74
16247: PPUSH
16248: CALL_OW 115
// end ;
16252: GO 15853
16254: POP
16255: POP
// end ;
16256: PPOPN 4
16258: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16259: LD_EXP 60
16263: PUSH
16264: LD_EXP 61
16268: AND
16269: PUSH
16270: LD_EXP 31
16274: NOT
16275: AND
16276: PUSH
16277: LD_EXP 32
16281: NOT
16282: AND
16283: IFFALSE 16493
16285: GO 16287
16287: DISABLE
16288: LD_INT 0
16290: PPUSH
16291: PPUSH
// begin enable ;
16292: ENABLE
// if not ru_vehicles then
16293: LD_EXP 56
16297: NOT
16298: IFFALSE 16302
// exit ;
16300: GO 16493
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16302: LD_ADDR_VAR 0 2
16306: PUSH
16307: LD_INT 81
16309: PUSH
16310: LD_INT 3
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PPUSH
16317: CALL_OW 69
16321: ST_TO_ADDR
// if ru_vehicles then
16322: LD_EXP 56
16326: IFFALSE 16493
// begin for i in ru_vehicles do
16328: LD_ADDR_VAR 0 1
16332: PUSH
16333: LD_EXP 56
16337: PUSH
16338: FOR_IN
16339: IFFALSE 16491
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16341: LD_VAR 0 1
16345: PPUSH
16346: CALL_OW 302
16350: PUSH
16351: LD_VAR 0 1
16355: PPUSH
16356: LD_VAR 0 2
16360: PPUSH
16361: LD_VAR 0 1
16365: PPUSH
16366: CALL_OW 74
16370: PPUSH
16371: CALL_OW 296
16375: PUSH
16376: LD_INT 9
16378: LESS
16379: AND
16380: IFFALSE 16406
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16382: LD_VAR 0 1
16386: PPUSH
16387: LD_VAR 0 2
16391: PPUSH
16392: LD_VAR 0 1
16396: PPUSH
16397: CALL_OW 74
16401: PPUSH
16402: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16406: LD_VAR 0 1
16410: PPUSH
16411: CALL_OW 314
16415: NOT
16416: PUSH
16417: LD_VAR 0 1
16421: PPUSH
16422: CALL_OW 302
16426: AND
16427: PUSH
16428: LD_VAR 0 1
16432: PPUSH
16433: LD_EXP 61
16437: PUSH
16438: LD_INT 1
16440: ARRAY
16441: PPUSH
16442: LD_EXP 61
16446: PUSH
16447: LD_INT 2
16449: ARRAY
16450: PPUSH
16451: CALL_OW 297
16455: PUSH
16456: LD_INT 10
16458: GREATER
16459: AND
16460: IFFALSE 16489
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16462: LD_VAR 0 1
16466: PPUSH
16467: LD_EXP 61
16471: PUSH
16472: LD_INT 1
16474: ARRAY
16475: PPUSH
16476: LD_EXP 61
16480: PUSH
16481: LD_INT 2
16483: ARRAY
16484: PPUSH
16485: CALL_OW 114
// end ;
16489: GO 16338
16491: POP
16492: POP
// end ; end ;
16493: PPOPN 2
16495: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16496: LD_EXP 61
16500: PUSH
16501: LD_EXP 60
16505: AND
16506: PUSH
16507: LD_INT 3
16509: PPUSH
16510: CALL_OW 463
16514: NOT
16515: AND
16516: PUSH
16517: LD_EXP 31
16521: NOT
16522: AND
16523: PUSH
16524: LD_EXP 32
16528: NOT
16529: AND
16530: IFFALSE 16625
16532: GO 16534
16534: DISABLE
16535: LD_INT 0
16537: PPUSH
// begin enable ;
16538: ENABLE
// ru_alert_xy := false ;
16539: LD_ADDR_EXP 61
16543: PUSH
16544: LD_INT 0
16546: ST_TO_ADDR
// ru_alert := false ;
16547: LD_ADDR_EXP 60
16551: PUSH
16552: LD_INT 0
16554: ST_TO_ADDR
// if ru_vehicles then
16555: LD_EXP 56
16559: IFFALSE 16625
// for i in ru_vehicles do
16561: LD_ADDR_VAR 0 1
16565: PUSH
16566: LD_EXP 56
16570: PUSH
16571: FOR_IN
16572: IFFALSE 16623
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16574: LD_VAR 0 1
16578: PPUSH
16579: CALL_OW 302
16583: PUSH
16584: LD_VAR 0 1
16588: PPUSH
16589: LD_INT 89
16591: PPUSH
16592: LD_INT 36
16594: PPUSH
16595: CALL_OW 297
16599: PUSH
16600: LD_INT 10
16602: GREATER
16603: AND
16604: IFFALSE 16621
// ComMoveXY ( i , 89 , 36 ) ;
16606: LD_VAR 0 1
16610: PPUSH
16611: LD_INT 89
16613: PPUSH
16614: LD_INT 36
16616: PPUSH
16617: CALL_OW 111
16621: GO 16571
16623: POP
16624: POP
// end ;
16625: PPOPN 1
16627: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16628: LD_EXP 55
16632: PUSH
16633: LD_EXP 31
16637: NOT
16638: AND
16639: PUSH
16640: LD_EXP 32
16644: NOT
16645: AND
16646: IFFALSE 16930
16648: GO 16650
16650: DISABLE
16651: LD_INT 0
16653: PPUSH
16654: PPUSH
16655: PPUSH
// begin enable ;
16656: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16657: LD_ADDR_VAR 0 3
16661: PUSH
16662: LD_INT 81
16664: PUSH
16665: LD_INT 3
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PPUSH
16672: CALL_OW 69
16676: ST_TO_ADDR
// for i = 1 to ru_forest do
16677: LD_ADDR_VAR 0 1
16681: PUSH
16682: DOUBLE
16683: LD_INT 1
16685: DEC
16686: ST_TO_ADDR
16687: LD_EXP 55
16691: PUSH
16692: FOR_TO
16693: IFFALSE 16928
// begin un := ru_forest [ i ] ;
16695: LD_ADDR_VAR 0 2
16699: PUSH
16700: LD_EXP 55
16704: PUSH
16705: LD_VAR 0 1
16709: ARRAY
16710: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16711: LD_VAR 0 2
16715: PPUSH
16716: LD_INT 13
16718: PPUSH
16719: CALL_OW 308
16723: IFFALSE 16813
// begin if not See ( 1 , un ) then
16725: LD_INT 1
16727: PPUSH
16728: LD_VAR 0 2
16732: PPUSH
16733: CALL_OW 292
16737: NOT
16738: IFFALSE 16752
// SetLives ( un , 1000 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 1000
16747: PPUSH
16748: CALL_OW 234
// ru_forest := ru_forest diff un ;
16752: LD_ADDR_EXP 55
16756: PUSH
16757: LD_EXP 55
16761: PUSH
16762: LD_VAR 0 2
16766: DIFF
16767: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16768: LD_VAR 0 2
16772: PPUSH
16773: LD_INT 22
16775: PUSH
16776: LD_INT 3
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: PUSH
16783: LD_INT 30
16785: PUSH
16786: LD_INT 4
16788: PUSH
16789: EMPTY
16790: LIST
16791: LIST
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PPUSH
16797: CALL_OW 69
16801: PPUSH
16802: CALL 1062 0 1
16806: PPUSH
16807: CALL_OW 120
// continue ;
16811: GO 16692
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16813: LD_VAR 0 2
16817: PPUSH
16818: CALL_OW 256
16822: PUSH
16823: LD_INT 700
16825: LESS
16826: PUSH
16827: LD_VAR 0 2
16831: PPUSH
16832: LD_INT 13
16834: PPUSH
16835: CALL_OW 308
16839: NOT
16840: AND
16841: IFFALSE 16857
// ComMoveToArea ( un , retreatArea ) else
16843: LD_VAR 0 2
16847: PPUSH
16848: LD_INT 13
16850: PPUSH
16851: CALL_OW 113
16855: GO 16926
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16857: LD_VAR 0 2
16861: PPUSH
16862: LD_VAR 0 3
16866: PPUSH
16867: LD_VAR 0 2
16871: PPUSH
16872: CALL_OW 74
16876: PPUSH
16877: CALL_OW 296
16881: PUSH
16882: LD_INT 9
16884: LESS
16885: PUSH
16886: LD_VAR 0 2
16890: PPUSH
16891: CALL_OW 256
16895: PUSH
16896: LD_INT 500
16898: GREATER
16899: AND
16900: IFFALSE 16926
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16902: LD_VAR 0 2
16906: PPUSH
16907: LD_VAR 0 3
16911: PPUSH
16912: LD_VAR 0 2
16916: PPUSH
16917: CALL_OW 74
16921: PPUSH
16922: CALL_OW 115
// end ;
16926: GO 16692
16928: POP
16929: POP
// end ;
16930: PPOPN 3
16932: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16933: LD_EXP 32
16937: NOT
16938: IFFALSE 17059
16940: GO 16942
16942: DISABLE
16943: LD_INT 0
16945: PPUSH
16946: PPUSH
// begin enable ;
16947: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16948: LD_ADDR_VAR 0 2
16952: PUSH
16953: LD_INT 22
16955: PUSH
16956: LD_INT 3
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: PUSH
16963: LD_INT 21
16965: PUSH
16966: LD_INT 3
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: PPUSH
16977: CALL_OW 69
16981: ST_TO_ADDR
// if filter then
16982: LD_VAR 0 2
16986: IFFALSE 17059
// for i in filter do
16988: LD_ADDR_VAR 0 1
16992: PUSH
16993: LD_VAR 0 2
16997: PUSH
16998: FOR_IN
16999: IFFALSE 17057
// if GetLives ( i ) < 990 then
17001: LD_VAR 0 1
17005: PPUSH
17006: CALL_OW 256
17010: PUSH
17011: LD_INT 990
17013: LESS
17014: IFFALSE 17055
// begin ru_alert := true ;
17016: LD_ADDR_EXP 60
17020: PUSH
17021: LD_INT 1
17023: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
17024: LD_ADDR_EXP 61
17028: PUSH
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL_OW 250
17038: PUSH
17039: LD_VAR 0 1
17043: PPUSH
17044: CALL_OW 251
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: ST_TO_ADDR
// break ;
17053: GO 17057
// end ;
17055: GO 16998
17057: POP
17058: POP
// end ;
17059: PPOPN 2
17061: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
17062: LD_EXP 31
17066: IFFALSE 17215
17068: GO 17070
17070: DISABLE
17071: LD_INT 0
17073: PPUSH
17074: PPUSH
17075: PPUSH
17076: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
17077: LD_ADDR_VAR 0 4
17081: PUSH
17082: LD_EXP 56
17086: PUSH
17087: LD_EXP 55
17091: ADD
17092: PUSH
17093: LD_EXP 53
17097: ADD
17098: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
17099: LD_ADDR_VAR 0 3
17103: PUSH
17104: LD_INT 3
17106: PPUSH
17107: LD_INT 81
17109: PUSH
17110: LD_INT 3
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: PPUSH
17117: CALL_OW 70
17121: ST_TO_ADDR
// if filter and enemy then
17122: LD_VAR 0 4
17126: PUSH
17127: LD_VAR 0 3
17131: AND
17132: IFFALSE 17215
// repeat wait ( 0 0$01 ) ;
17134: LD_INT 35
17136: PPUSH
17137: CALL_OW 67
// for i in filter do
17141: LD_ADDR_VAR 0 1
17145: PUSH
17146: LD_VAR 0 4
17150: PUSH
17151: FOR_IN
17152: IFFALSE 17180
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17154: LD_VAR 0 1
17158: PPUSH
17159: LD_VAR 0 3
17163: PPUSH
17164: LD_VAR 0 1
17168: PPUSH
17169: CALL_OW 74
17173: PPUSH
17174: CALL_OW 115
// end ;
17178: GO 17151
17180: POP
17181: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
17182: LD_INT 3
17184: PPUSH
17185: LD_INT 81
17187: PUSH
17188: LD_INT 3
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PPUSH
17195: CALL_OW 70
17199: PUSH
17200: LD_INT 0
17202: EQUAL
17203: PUSH
17204: LD_VAR 0 4
17208: PUSH
17209: LD_INT 0
17211: EQUAL
17212: OR
17213: IFFALSE 17134
// end ;
17215: PPOPN 4
17217: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
17218: LD_EXP 26
17222: PUSH
17223: LD_INT 22
17225: PUSH
17226: LD_INT 4
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: PUSH
17233: LD_INT 30
17235: PUSH
17236: LD_INT 4
17238: PUSH
17239: EMPTY
17240: LIST
17241: LIST
17242: PUSH
17243: LD_INT 3
17245: PUSH
17246: LD_INT 57
17248: PUSH
17249: EMPTY
17250: LIST
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: LIST
17260: PPUSH
17261: CALL_OW 69
17265: AND
17266: IFFALSE 17315
17268: GO 17270
17270: DISABLE
17271: LD_INT 0
17273: PPUSH
// begin if not ru_cornel_attack then
17274: LD_EXP 58
17278: NOT
17279: IFFALSE 17283
// exit ;
17281: GO 17315
// for i in ru_cornel_attack do
17283: LD_ADDR_VAR 0 1
17287: PUSH
17288: LD_EXP 58
17292: PUSH
17293: FOR_IN
17294: IFFALSE 17313
// ComAgressiveMove ( i , 258 , 119 ) ;
17296: LD_VAR 0 1
17300: PPUSH
17301: LD_INT 258
17303: PPUSH
17304: LD_INT 119
17306: PPUSH
17307: CALL_OW 114
17311: GO 17293
17313: POP
17314: POP
// end ; end_of_file
17315: PPOPN 1
17317: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17318: LD_EXP 5
17322: PUSH
17323: LD_EXP 9
17327: NOT
17328: AND
17329: PUSH
17330: LD_EXP 20
17334: AND
17335: IFFALSE 17447
17337: GO 17339
17339: DISABLE
17340: LD_INT 0
17342: PPUSH
// begin enable ;
17343: ENABLE
// crates_counter := crates_counter - 50 ;
17344: LD_ADDR_EXP 20
17348: PUSH
17349: LD_EXP 20
17353: PUSH
17354: LD_INT 50
17356: MINUS
17357: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17358: LD_INT 8
17360: PPUSH
17361: LD_INT 2
17363: PPUSH
17364: LD_INT 5
17366: PPUSH
17367: CALL_OW 12
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17379: LD_INT 1785
17381: PPUSH
17382: LD_INT 2345
17384: PPUSH
17385: CALL_OW 12
17389: PPUSH
17390: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17394: LD_ADDR_VAR 0 1
17398: PUSH
17399: LD_INT 1
17401: PPUSH
17402: LD_OWVAR 67
17406: PUSH
17407: LD_INT 2
17409: PLUS
17410: PPUSH
17411: CALL_OW 12
17415: ST_TO_ADDR
// if r < 3 then
17416: LD_VAR 0 1
17420: PUSH
17421: LD_INT 3
17423: LESS
17424: IFFALSE 17447
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17426: LD_INT 4
17428: PPUSH
17429: LD_INT 1
17431: PPUSH
17432: LD_INT 5
17434: PPUSH
17435: CALL_OW 12
17439: PPUSH
17440: LD_INT 1
17442: PPUSH
17443: CALL_OW 55
// end ;
17447: PPOPN 1
17449: END
// every 0 0$01 trigger cornel_active do
17450: LD_EXP 8
17454: IFFALSE 17543
17456: GO 17458
17458: DISABLE
// begin Wait ( 0 0$03 ) ;
17459: LD_INT 105
17461: PPUSH
17462: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17466: LD_INT 2
17468: PPUSH
17469: LD_INT 5
17471: PPUSH
17472: CALL_OW 12
17476: PPUSH
17477: LD_INT 10
17479: PPUSH
17480: LD_INT 1
17482: PPUSH
17483: CALL_OW 55
// Wait ( 0 0$13 ) ;
17487: LD_INT 455
17489: PPUSH
17490: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17494: LD_INT 2
17496: PPUSH
17497: LD_INT 5
17499: PPUSH
17500: CALL_OW 12
17504: PPUSH
17505: LD_INT 10
17507: PPUSH
17508: LD_INT 1
17510: PPUSH
17511: CALL_OW 55
// Wait ( 0 0$16 ) ;
17515: LD_INT 560
17517: PPUSH
17518: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17522: LD_INT 2
17524: PPUSH
17525: LD_INT 5
17527: PPUSH
17528: CALL_OW 12
17532: PPUSH
17533: LD_INT 10
17535: PPUSH
17536: LD_INT 1
17538: PPUSH
17539: CALL_OW 55
// end ; end_of_file
17543: END
// every 0 0$01 trigger cornel_prepared do
17544: LD_EXP 11
17548: IFFALSE 17607
17550: GO 17552
17552: DISABLE
// begin enable ;
17553: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17554: LD_ADDR_OWVAR 47
17558: PUSH
17559: LD_STRING #Am03-1
17561: PUSH
17562: LD_EXP 10
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17571: LD_ADDR_EXP 10
17575: PUSH
17576: LD_EXP 10
17580: PPUSH
17581: LD_STRING -
17583: PPUSH
17584: CALL 1132 0 2
17588: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17589: LD_EXP 10
17593: PUSH
17594: LD_INT 0
17596: EQUAL
17597: IFFALSE 17607
// begin Display_Strings := [ ] ;
17599: LD_ADDR_OWVAR 47
17603: PUSH
17604: EMPTY
17605: ST_TO_ADDR
// disable ;
17606: DISABLE
// end ; end ;
17607: END
// every 0 0$01 trigger debug and debug_strings do
17608: LD_EXP 1
17612: PUSH
17613: LD_OWVAR 48
17617: AND
17618: IFFALSE 17634
17620: GO 17622
17622: DISABLE
// begin enable ;
17623: ENABLE
// Display_Strings := debug_strings ;
17624: LD_ADDR_OWVAR 47
17628: PUSH
17629: LD_OWVAR 48
17633: ST_TO_ADDR
// end ; end_of_file
17634: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 255
17644: PUSH
17645: LD_INT 1
17647: EQUAL
17648: PUSH
17649: LD_EXP 14
17653: NOT
17654: AND
17655: IFFALSE 17665
// solar_builded := true ;
17657: LD_ADDR_EXP 14
17661: PUSH
17662: LD_INT 1
17664: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17665: LD_VAR 0 1
17669: PPUSH
17670: CALL_OW 255
17674: PUSH
17675: LD_INT 1
17677: EQUAL
17678: PUSH
17679: LD_EXP 29
17683: AND
17684: IFFALSE 17717
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17686: LD_ADDR_EXP 29
17690: PUSH
17691: LD_EXP 29
17695: PUSH
17696: LD_INT 1750
17698: PUSH
17699: LD_INT 1400
17701: PUSH
17702: LD_INT 1225
17704: PUSH
17705: EMPTY
17706: LIST
17707: LIST
17708: LIST
17709: PUSH
17710: LD_OWVAR 67
17714: ARRAY
17715: PLUS
17716: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17717: LD_VAR 0 1
17721: PPUSH
17722: CALL_OW 255
17726: PUSH
17727: LD_INT 3
17729: EQUAL
17730: IFFALSE 17748
// ru_vehicles := ru_vehicles ^ veh ;
17732: LD_ADDR_EXP 56
17736: PUSH
17737: LD_EXP 56
17741: PUSH
17742: LD_VAR 0 1
17746: ADD
17747: ST_TO_ADDR
// end ;
17748: PPOPN 2
17750: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17751: LD_VAR 0 1
17755: PUSH
17756: LD_EXP 53
17760: IN
17761: IFFALSE 17779
// ru_patrol := ru_patrol diff un ;
17763: LD_ADDR_EXP 53
17767: PUSH
17768: LD_EXP 53
17772: PUSH
17773: LD_VAR 0 1
17777: DIFF
17778: ST_TO_ADDR
// if un in ru_forest then
17779: LD_VAR 0 1
17783: PUSH
17784: LD_EXP 55
17788: IN
17789: IFFALSE 17807
// ru_forest := ru_forest diff un ;
17791: LD_ADDR_EXP 55
17795: PUSH
17796: LD_EXP 55
17800: PUSH
17801: LD_VAR 0 1
17805: DIFF
17806: ST_TO_ADDR
// if un in ru_vehicles then
17807: LD_VAR 0 1
17811: PUSH
17812: LD_EXP 56
17816: IN
17817: IFFALSE 17923
// begin ru_vehicles := ru_vehicles diff un ;
17819: LD_ADDR_EXP 56
17823: PUSH
17824: LD_EXP 56
17828: PUSH
17829: LD_VAR 0 1
17833: DIFF
17834: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17835: LD_ADDR_EXP 57
17839: PUSH
17840: LD_EXP 57
17844: PUSH
17845: LD_VAR 0 1
17849: PPUSH
17850: CALL_OW 265
17854: PUSH
17855: LD_VAR 0 1
17859: PPUSH
17860: CALL_OW 262
17864: PUSH
17865: LD_VAR 0 1
17869: PPUSH
17870: CALL_OW 263
17874: PUSH
17875: LD_VAR 0 1
17879: PPUSH
17880: CALL_OW 264
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: LIST
17890: ADD
17891: ST_TO_ADDR
// ach_counter := ach_counter + 1 ;
17892: LD_ADDR_EXP 13
17896: PUSH
17897: LD_EXP 13
17901: PUSH
17902: LD_INT 1
17904: PLUS
17905: ST_TO_ADDR
// if ach_counter = 10 then
17906: LD_EXP 13
17910: PUSH
17911: LD_INT 10
17913: EQUAL
17914: IFFALSE 17923
// SetAchievement ( ACH_FAUST ) ;
17916: LD_STRING ACH_FAUST
17918: PPUSH
17919: CALL_OW 543
// end ; if un = Pokryshkin then
17923: LD_VAR 0 1
17927: PUSH
17928: LD_EXP 52
17932: EQUAL
17933: IFFALSE 17942
// SetAchievement ( ACH_POKR ) ;
17935: LD_STRING ACH_POKR
17937: PPUSH
17938: CALL_OW 543
// if un = JMM then
17942: LD_VAR 0 1
17946: PUSH
17947: LD_EXP 37
17951: EQUAL
17952: IFFALSE 17961
// YouLost ( 0 ) ;
17954: LD_STRING 0
17956: PPUSH
17957: CALL_OW 104
// if un = us_dep_west then
17961: LD_VAR 0 1
17965: PUSH
17966: LD_INT 1
17968: EQUAL
17969: IFFALSE 17978
// YouLost ( 2 ) ;
17971: LD_STRING 2
17973: PPUSH
17974: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17978: LD_VAR 0 1
17982: PPUSH
17983: CALL_OW 255
17987: PUSH
17988: LD_INT 8
17990: EQUAL
17991: PUSH
17992: LD_EXP 5
17996: NOT
17997: AND
17998: IFFALSE 18007
// YouLost ( 4 ) ;
18000: LD_STRING 4
18002: PPUSH
18003: CALL_OW 104
// if un in jmm_units then
18007: LD_VAR 0 1
18011: PUSH
18012: LD_EXP 4
18016: IN
18017: IFFALSE 18033
// lose_counter := lose_counter + 1 ;
18019: LD_ADDR_EXP 34
18023: PUSH
18024: LD_EXP 34
18028: PUSH
18029: LD_INT 1
18031: PLUS
18032: ST_TO_ADDR
// end ;
18033: PPOPN 1
18035: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
18036: LD_INT 0
18038: PPUSH
18039: PPUSH
// begin if GetSide ( driver ) = 3 then
18040: LD_VAR 0 1
18044: PPUSH
18045: CALL_OW 255
18049: PUSH
18050: LD_INT 3
18052: EQUAL
18053: IFFALSE 18131
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
18055: LD_ADDR_VAR 0 6
18059: PUSH
18060: LD_INT 22
18062: PUSH
18063: LD_INT 3
18065: PUSH
18066: EMPTY
18067: LIST
18068: LIST
18069: PUSH
18070: LD_INT 30
18072: PUSH
18073: LD_INT 3
18075: PUSH
18076: EMPTY
18077: LIST
18078: LIST
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: PPUSH
18084: CALL_OW 69
18088: PPUSH
18089: CALL 1062 0 1
18093: ST_TO_ADDR
// if place then
18094: LD_VAR 0 6
18098: IFFALSE 18116
// ComEnterUnit ( driver , place ) else
18100: LD_VAR 0 1
18104: PPUSH
18105: LD_VAR 0 6
18109: PPUSH
18110: CALL_OW 120
18114: GO 18131
// ComMoveXY ( driver , 70 , 22 ) ;
18116: LD_VAR 0 1
18120: PPUSH
18121: LD_INT 70
18123: PPUSH
18124: LD_INT 22
18126: PPUSH
18127: CALL_OW 111
// end ; end ;
18131: PPOPN 6
18133: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
18134: LD_VAR 0 1
18138: PUSH
18139: LD_INT 1
18141: EQUAL
18142: PUSH
18143: LD_VAR 0 2
18147: PUSH
18148: LD_INT 4
18150: EQUAL
18151: PUSH
18152: LD_VAR 0 2
18156: PUSH
18157: LD_INT 8
18159: EQUAL
18160: PUSH
18161: LD_EXP 5
18165: NOT
18166: AND
18167: OR
18168: AND
18169: IFFALSE 18178
// YouLost ( 5 ) ;
18171: LD_STRING 5
18173: PPUSH
18174: CALL_OW 104
// end ;
18178: PPOPN 2
18180: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
18181: LD_EXP 36
18185: PUSH
18186: LD_INT 22
18188: PUSH
18189: LD_INT 1
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PUSH
18196: LD_INT 21
18198: PUSH
18199: LD_INT 1
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: PPUSH
18210: CALL_OW 69
18214: PUSH
18215: LD_INT 22
18217: PUSH
18218: LD_INT 8
18220: PUSH
18221: EMPTY
18222: LIST
18223: LIST
18224: PUSH
18225: LD_INT 21
18227: PUSH
18228: LD_INT 1
18230: PUSH
18231: EMPTY
18232: LIST
18233: LIST
18234: PUSH
18235: EMPTY
18236: LIST
18237: LIST
18238: PPUSH
18239: CALL_OW 69
18243: ADD
18244: PLUS
18245: PUSH
18246: LD_INT 5
18248: LESS
18249: IFFALSE 18261
18251: GO 18253
18253: DISABLE
// YouLost ( 1 ) ;
18254: LD_STRING 1
18256: PPUSH
18257: CALL_OW 104
18261: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
18262: LD_INT 1
18264: PPUSH
18265: CALL_OW 255
18269: PUSH
18270: LD_INT 3
18272: EQUAL
18273: IFFALSE 18285
18275: GO 18277
18277: DISABLE
// YouLost ( 3 ) ; end_of_file
18278: LD_STRING 3
18280: PPUSH
18281: CALL_OW 104
18285: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18286: GO 18288
18288: DISABLE
// begin ru_radar := 98 ;
18289: LD_ADDR_EXP 62
18293: PUSH
18294: LD_INT 98
18296: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18297: LD_ADDR_EXP 63
18301: PUSH
18302: LD_INT 89
18304: ST_TO_ADDR
// us_hack := 99 ;
18305: LD_ADDR_EXP 64
18309: PUSH
18310: LD_INT 99
18312: ST_TO_ADDR
// us_artillery := 97 ;
18313: LD_ADDR_EXP 65
18317: PUSH
18318: LD_INT 97
18320: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18321: LD_ADDR_EXP 66
18325: PUSH
18326: LD_INT 91
18328: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
18329: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
18330: LD_INT 0
18332: PPUSH
18333: PPUSH
18334: PPUSH
18335: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18336: LD_VAR 0 1
18340: PPUSH
18341: CALL_OW 264
18345: PUSH
18346: LD_EXP 66
18350: EQUAL
18351: IFFALSE 18423
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18353: LD_INT 68
18355: PPUSH
18356: LD_VAR 0 1
18360: PPUSH
18361: CALL_OW 255
18365: PPUSH
18366: CALL_OW 321
18370: PUSH
18371: LD_INT 2
18373: EQUAL
18374: IFFALSE 18386
// eff := 70 else
18376: LD_ADDR_VAR 0 6
18380: PUSH
18381: LD_INT 70
18383: ST_TO_ADDR
18384: GO 18394
// eff := 30 ;
18386: LD_ADDR_VAR 0 6
18390: PUSH
18391: LD_INT 30
18393: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18394: LD_VAR 0 1
18398: PPUSH
18399: CALL_OW 250
18403: PPUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: CALL_OW 251
18413: PPUSH
18414: LD_VAR 0 6
18418: PPUSH
18419: CALL_OW 495
// end ; end ;
18423: LD_VAR 0 4
18427: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18428: LD_INT 0
18430: PPUSH
18431: PPUSH
18432: PPUSH
18433: PPUSH
18434: PPUSH
18435: PPUSH
// if cmd = 124 then
18436: LD_VAR 0 1
18440: PUSH
18441: LD_INT 124
18443: EQUAL
18444: IFFALSE 18650
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18446: LD_ADDR_VAR 0 5
18450: PUSH
18451: LD_INT 2
18453: PUSH
18454: LD_INT 34
18456: PUSH
18457: LD_INT 53
18459: PUSH
18460: EMPTY
18461: LIST
18462: LIST
18463: PUSH
18464: LD_INT 34
18466: PUSH
18467: LD_INT 14
18469: PUSH
18470: EMPTY
18471: LIST
18472: LIST
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: LIST
18478: PPUSH
18479: CALL_OW 69
18483: ST_TO_ADDR
// if not tmp then
18484: LD_VAR 0 5
18488: NOT
18489: IFFALSE 18493
// exit ;
18491: GO 18650
// for i in tmp do
18493: LD_ADDR_VAR 0 3
18497: PUSH
18498: LD_VAR 0 5
18502: PUSH
18503: FOR_IN
18504: IFFALSE 18648
// begin taskList := GetTaskList ( i ) ;
18506: LD_ADDR_VAR 0 6
18510: PUSH
18511: LD_VAR 0 3
18515: PPUSH
18516: CALL_OW 437
18520: ST_TO_ADDR
// if not taskList then
18521: LD_VAR 0 6
18525: NOT
18526: IFFALSE 18530
// continue ;
18528: GO 18503
// for j = 1 to taskList do
18530: LD_ADDR_VAR 0 4
18534: PUSH
18535: DOUBLE
18536: LD_INT 1
18538: DEC
18539: ST_TO_ADDR
18540: LD_VAR 0 6
18544: PUSH
18545: FOR_TO
18546: IFFALSE 18644
// if taskList [ j ] [ 1 ] = | then
18548: LD_VAR 0 6
18552: PUSH
18553: LD_VAR 0 4
18557: ARRAY
18558: PUSH
18559: LD_INT 1
18561: ARRAY
18562: PUSH
18563: LD_STRING |
18565: EQUAL
18566: IFFALSE 18642
// begin _taskList := Delete ( taskList , 1 ) ;
18568: LD_ADDR_VAR 0 7
18572: PUSH
18573: LD_VAR 0 6
18577: PPUSH
18578: LD_INT 1
18580: PPUSH
18581: CALL_OW 3
18585: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18586: LD_VAR 0 3
18590: PPUSH
18591: LD_VAR 0 7
18595: PPUSH
18596: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18600: LD_VAR 0 3
18604: PPUSH
18605: LD_VAR 0 6
18609: PUSH
18610: LD_VAR 0 4
18614: ARRAY
18615: PUSH
18616: LD_INT 2
18618: ARRAY
18619: PPUSH
18620: LD_VAR 0 6
18624: PUSH
18625: LD_VAR 0 4
18629: ARRAY
18630: PUSH
18631: LD_INT 3
18633: ARRAY
18634: PPUSH
18635: LD_INT 8
18637: PPUSH
18638: CALL 18655 0 4
// end ;
18642: GO 18545
18644: POP
18645: POP
// end ;
18646: GO 18503
18648: POP
18649: POP
// end ; end ;
18650: LD_VAR 0 2
18654: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18655: LD_INT 0
18657: PPUSH
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
18662: PPUSH
18663: PPUSH
18664: PPUSH
18665: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18666: LD_VAR 0 1
18670: NOT
18671: PUSH
18672: LD_VAR 0 2
18676: PPUSH
18677: LD_VAR 0 3
18681: PPUSH
18682: CALL_OW 488
18686: NOT
18687: OR
18688: PUSH
18689: LD_VAR 0 4
18693: NOT
18694: OR
18695: IFFALSE 18699
// exit ;
18697: GO 19039
// list := [ ] ;
18699: LD_ADDR_VAR 0 13
18703: PUSH
18704: EMPTY
18705: ST_TO_ADDR
// if x - r < 0 then
18706: LD_VAR 0 2
18710: PUSH
18711: LD_VAR 0 4
18715: MINUS
18716: PUSH
18717: LD_INT 0
18719: LESS
18720: IFFALSE 18732
// min_x := 0 else
18722: LD_ADDR_VAR 0 7
18726: PUSH
18727: LD_INT 0
18729: ST_TO_ADDR
18730: GO 18748
// min_x := x - r ;
18732: LD_ADDR_VAR 0 7
18736: PUSH
18737: LD_VAR 0 2
18741: PUSH
18742: LD_VAR 0 4
18746: MINUS
18747: ST_TO_ADDR
// if y - r < 0 then
18748: LD_VAR 0 3
18752: PUSH
18753: LD_VAR 0 4
18757: MINUS
18758: PUSH
18759: LD_INT 0
18761: LESS
18762: IFFALSE 18774
// min_y := 0 else
18764: LD_ADDR_VAR 0 8
18768: PUSH
18769: LD_INT 0
18771: ST_TO_ADDR
18772: GO 18790
// min_y := y - r ;
18774: LD_ADDR_VAR 0 8
18778: PUSH
18779: LD_VAR 0 3
18783: PUSH
18784: LD_VAR 0 4
18788: MINUS
18789: ST_TO_ADDR
// max_x := x + r ;
18790: LD_ADDR_VAR 0 9
18794: PUSH
18795: LD_VAR 0 2
18799: PUSH
18800: LD_VAR 0 4
18804: PLUS
18805: ST_TO_ADDR
// max_y := y + r ;
18806: LD_ADDR_VAR 0 10
18810: PUSH
18811: LD_VAR 0 3
18815: PUSH
18816: LD_VAR 0 4
18820: PLUS
18821: ST_TO_ADDR
// for _x = min_x to max_x do
18822: LD_ADDR_VAR 0 11
18826: PUSH
18827: DOUBLE
18828: LD_VAR 0 7
18832: DEC
18833: ST_TO_ADDR
18834: LD_VAR 0 9
18838: PUSH
18839: FOR_TO
18840: IFFALSE 18957
// for _y = min_y to max_y do
18842: LD_ADDR_VAR 0 12
18846: PUSH
18847: DOUBLE
18848: LD_VAR 0 8
18852: DEC
18853: ST_TO_ADDR
18854: LD_VAR 0 10
18858: PUSH
18859: FOR_TO
18860: IFFALSE 18953
// begin if not ValidHex ( _x , _y ) then
18862: LD_VAR 0 11
18866: PPUSH
18867: LD_VAR 0 12
18871: PPUSH
18872: CALL_OW 488
18876: NOT
18877: IFFALSE 18881
// continue ;
18879: GO 18859
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18881: LD_VAR 0 11
18885: PPUSH
18886: LD_VAR 0 12
18890: PPUSH
18891: CALL_OW 351
18895: PUSH
18896: LD_VAR 0 11
18900: PPUSH
18901: LD_VAR 0 12
18905: PPUSH
18906: CALL_OW 554
18910: AND
18911: IFFALSE 18951
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18913: LD_ADDR_VAR 0 13
18917: PUSH
18918: LD_VAR 0 13
18922: PPUSH
18923: LD_VAR 0 13
18927: PUSH
18928: LD_INT 1
18930: PLUS
18931: PPUSH
18932: LD_VAR 0 11
18936: PUSH
18937: LD_VAR 0 12
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PPUSH
18946: CALL_OW 2
18950: ST_TO_ADDR
// end ;
18951: GO 18859
18953: POP
18954: POP
18955: GO 18839
18957: POP
18958: POP
// if not list then
18959: LD_VAR 0 13
18963: NOT
18964: IFFALSE 18968
// exit ;
18966: GO 19039
// for i in list do
18968: LD_ADDR_VAR 0 6
18972: PUSH
18973: LD_VAR 0 13
18977: PUSH
18978: FOR_IN
18979: IFFALSE 19037
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18981: LD_VAR 0 1
18985: PPUSH
18986: LD_STRING M
18988: PUSH
18989: LD_VAR 0 6
18993: PUSH
18994: LD_INT 1
18996: ARRAY
18997: PUSH
18998: LD_VAR 0 6
19002: PUSH
19003: LD_INT 2
19005: ARRAY
19006: PUSH
19007: LD_INT 0
19009: PUSH
19010: LD_INT 0
19012: PUSH
19013: LD_INT 0
19015: PUSH
19016: LD_INT 0
19018: PUSH
19019: EMPTY
19020: LIST
19021: LIST
19022: LIST
19023: LIST
19024: LIST
19025: LIST
19026: LIST
19027: PUSH
19028: EMPTY
19029: LIST
19030: PPUSH
19031: CALL_OW 447
19035: GO 18978
19037: POP
19038: POP
// end ;
19039: LD_VAR 0 5
19043: RET
