// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 50 0 0
// SetDiplomacy ;
  15: CALL 378 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 29
// DebugMode ;
  25: CALL 466 0 0
// PrepareRussian ;
  29: CALL 3023 0 0
// PrepareAmerican ;
  33: CALL 1228 0 0
// PrepareCornell ;
  37: CALL 2252 0 0
// PrepareWesternBase ;
  41: CALL 2478 0 0
// Action ;
  45: CALL 5239 0 0
// end ;
  49: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , ach_counter , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  50: LD_INT 0
  52: PPUSH
// debug := false ;
  53: LD_ADDR_EXP 1
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  61: LD_ADDR_EXP 3
  65: PUSH
  66: LD_STRING 02_
  68: ST_TO_ADDR
// mission_prefix := 03_ ;
  69: LD_ADDR_EXP 2
  73: PUSH
  74: LD_STRING 03_
  76: ST_TO_ADDR
// jmm_units := 0 ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// cornel_units := 0 ;
  85: LD_ADDR_EXP 6
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// bierezov_exist := false ;
  93: LD_ADDR_EXP 7
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// jmm_on_west := false ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// cornel_active := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// cornel_attack := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// cornel_prepared := false ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 133: LD_ADDR_EXP 10
 137: PUSH
 138: LD_INT 4200
 140: ST_TO_ADDR
// frank_can_return := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// solar_builded := false ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// frank_send_to_scout := false ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// jmm_in_veh := false ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// bobby_in_veh := false ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// cyrus_in_veh := false ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// lisa_in_veh := false ;
 189: LD_ADDR_EXP 19
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 197: LD_ADDR_EXP 29
 201: PUSH
 202: LD_INT 25200
 204: PUSH
 205: LD_INT 23100
 207: PUSH
 208: LD_INT 21000
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_OWVAR 67
 220: ARRAY
 221: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 222: LD_ADDR_EXP 20
 226: PUSH
 227: LD_INT 600
 229: PUSH
 230: LD_INT 500
 232: PUSH
 233: LD_INT 400
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_OWVAR 67
 245: ARRAY
 246: ST_TO_ADDR
// end_mission_allowed := false ;
 247: LD_ADDR_EXP 21
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// save_others := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// save_group := [ ] ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// show_query := true ;
 269: LD_ADDR_EXP 24
 273: PUSH
 274: LD_INT 1
 276: ST_TO_ADDR
// wait_for_them := false ;
 277: LD_ADDR_EXP 25
 281: PUSH
 282: LD_INT 0
 284: ST_TO_ADDR
// veh_on_meta := false ;
 285: LD_ADDR_EXP 28
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// send_spec_patrol := false ;
 293: LD_ADDR_EXP 30
 297: PUSH
 298: LD_INT 0
 300: ST_TO_ADDR
// prepare_siege := false ;
 301: LD_ADDR_EXP 31
 305: PUSH
 306: LD_INT 0
 308: ST_TO_ADDR
// send_attack_on_cornel := false ;
 309: LD_ADDR_EXP 32
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 0
 324: ST_TO_ADDR
// game_end := false ;
 325: LD_ADDR_EXP 33
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// lose_counter := 0 ;
 333: LD_ADDR_EXP 34
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// powell_warn := 0 ;
 341: LD_ADDR_EXP 35
 345: PUSH
 346: LD_INT 0
 348: ST_TO_ADDR
// save_counter := 0 ;
 349: LD_ADDR_EXP 36
 353: PUSH
 354: LD_INT 0
 356: ST_TO_ADDR
// cornel_saved := false ;
 357: LD_ADDR_EXP 27
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// ach_counter := 0 ;
 365: LD_ADDR_EXP 13
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// end ;
 373: LD_VAR 0 1
 377: RET
// function SetDiplomacy ; begin
 378: LD_INT 0
 380: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 4
 386: PPUSH
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 8
 402: PPUSH
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 1
 408: PPUSH
 409: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 413: LD_INT 3
 415: PPUSH
 416: LD_INT 6
 418: PPUSH
 419: LD_INT 1
 421: PPUSH
 422: LD_INT 1
 424: PPUSH
 425: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 429: LD_INT 4
 431: PPUSH
 432: LD_INT 6
 434: PPUSH
 435: LD_INT 0
 437: PPUSH
 438: LD_INT 1
 440: PPUSH
 441: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 445: LD_INT 3
 447: PPUSH
 448: LD_INT 8
 450: PPUSH
 451: LD_INT 0
 453: PPUSH
 454: LD_INT 1
 456: PPUSH
 457: CALL_OW 80
// end ;
 461: LD_VAR 0 1
 465: RET
// export function DebugMode ; var i ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// FogOff ( 1 ) ;
 470: LD_INT 1
 472: PPUSH
 473: CALL_OW 344
// debug_strings := [ ] ;
 477: LD_ADDR_OWVAR 48
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// end ; end_of_file
 484: LD_VAR 0 1
 488: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 489: LD_INT 0
 491: PPUSH
 492: PPUSH
// if exist_mode then
 493: LD_VAR 0 2
 497: IFFALSE 522
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_EXP 3
 508: PUSH
 509: LD_VAR 0 1
 513: STR
 514: PPUSH
 515: CALL_OW 34
 519: ST_TO_ADDR
 520: GO 537
// unit := NewCharacter ( ident ) ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_VAR 0 1
 531: PPUSH
 532: CALL_OW 25
 536: ST_TO_ADDR
// result := unit ;
 537: LD_ADDR_VAR 0 3
 541: PUSH
 542: LD_VAR 0 4
 546: ST_TO_ADDR
// end ;
 547: LD_VAR 0 3
 551: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 552: LD_INT 0
 554: PPUSH
// uc_side := side ;
 555: LD_ADDR_OWVAR 20
 559: PUSH
 560: LD_VAR 0 1
 564: ST_TO_ADDR
// uc_nation := nation ;
 565: LD_ADDR_OWVAR 21
 569: PUSH
 570: LD_VAR 0 2
 574: ST_TO_ADDR
// vc_chassis := chassis ;
 575: LD_ADDR_OWVAR 37
 579: PUSH
 580: LD_VAR 0 3
 584: ST_TO_ADDR
// vc_engine := engine ;
 585: LD_ADDR_OWVAR 39
 589: PUSH
 590: LD_VAR 0 4
 594: ST_TO_ADDR
// vc_control := control ;
 595: LD_ADDR_OWVAR 38
 599: PUSH
 600: LD_VAR 0 5
 604: ST_TO_ADDR
// vc_weapon := weapon ;
 605: LD_ADDR_OWVAR 40
 609: PUSH
 610: LD_VAR 0 6
 614: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 615: LD_ADDR_OWVAR 41
 619: PUSH
 620: LD_VAR 0 7
 624: ST_TO_ADDR
// result := CreateVehicle ;
 625: LD_ADDR_VAR 0 8
 629: PUSH
 630: CALL_OW 45
 634: ST_TO_ADDR
// end ;
 635: LD_VAR 0 8
 639: RET
// export function SayX ( units , ident ) ; var i ; begin
 640: LD_INT 0
 642: PPUSH
 643: PPUSH
// result := false ;
 644: LD_ADDR_VAR 0 3
 648: PUSH
 649: LD_INT 0
 651: ST_TO_ADDR
// if not units then
 652: LD_VAR 0 1
 656: NOT
 657: IFFALSE 661
// exit ;
 659: GO 715
// for i in units do
 661: LD_ADDR_VAR 0 4
 665: PUSH
 666: LD_VAR 0 1
 670: PUSH
 671: FOR_IN
 672: IFFALSE 713
// if IsOk ( i ) then
 674: LD_VAR 0 4
 678: PPUSH
 679: CALL_OW 302
 683: IFFALSE 711
// begin Say ( i , ident ) ;
 685: LD_VAR 0 4
 689: PPUSH
 690: LD_VAR 0 2
 694: PPUSH
 695: CALL_OW 88
// result := i ;
 699: LD_ADDR_VAR 0 3
 703: PUSH
 704: LD_VAR 0 4
 708: ST_TO_ADDR
// break ;
 709: GO 713
// end ;
 711: GO 671
 713: POP
 714: POP
// end ;
 715: LD_VAR 0 3
 719: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 720: LD_INT 0
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
// for i = 1 to count do
 726: LD_ADDR_VAR 0 8
 730: PUSH
 731: DOUBLE
 732: LD_INT 1
 734: DEC
 735: ST_TO_ADDR
 736: LD_VAR 0 6
 740: PUSH
 741: FOR_TO
 742: IFFALSE 823
// begin uc_side = side ;
 744: LD_ADDR_OWVAR 20
 748: PUSH
 749: LD_VAR 0 1
 753: ST_TO_ADDR
// uc_nation = nation ;
 754: LD_ADDR_OWVAR 21
 758: PUSH
 759: LD_VAR 0 2
 763: ST_TO_ADDR
// hc_gallery =  ;
 764: LD_ADDR_OWVAR 33
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// hc_name =  ;
 772: LD_ADDR_OWVAR 26
 776: PUSH
 777: LD_STRING 
 779: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 780: LD_INT 0
 782: PPUSH
 783: LD_VAR 0 5
 787: PPUSH
 788: LD_VAR 0 4
 792: PPUSH
 793: CALL_OW 380
// un = CreateHuman ;
 797: LD_ADDR_VAR 0 10
 801: PUSH
 802: CALL_OW 44
 806: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 807: LD_VAR 0 10
 811: PPUSH
 812: LD_VAR 0 3
 816: PPUSH
 817: CALL_OW 52
// end ;
 821: GO 741
 823: POP
 824: POP
// end ;
 825: LD_VAR 0 7
 829: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 830: LD_INT 0
 832: PPUSH
 833: PPUSH
 834: PPUSH
// uc_side := GetSide ( b ) ;
 835: LD_ADDR_OWVAR 20
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 255
 849: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 850: LD_ADDR_OWVAR 21
 854: PUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: CALL_OW 248
 864: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 865: LD_INT 0
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: LD_VAR 0 1
 875: PPUSH
 876: CALL_OW 380
// un = CreateHuman ;
 880: LD_ADDR_VAR 0 4
 884: PUSH
 885: CALL_OW 44
 889: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 890: LD_ADDR_VAR 0 5
 894: PUSH
 895: LD_VAR 0 2
 899: PPUSH
 900: CALL_OW 254
 904: PUSH
 905: LD_INT 3
 907: MINUS
 908: ST_TO_ADDR
// if dir < 0 then
 909: LD_VAR 0 5
 913: PUSH
 914: LD_INT 0
 916: LESS
 917: IFFALSE 933
// dir := 6 + dir ;
 919: LD_ADDR_VAR 0 5
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: LD_VAR 0 5
 931: PLUS
 932: ST_TO_ADDR
// SetDir ( un , dir ) ;
 933: LD_VAR 0 4
 937: PPUSH
 938: LD_VAR 0 5
 942: PPUSH
 943: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 947: LD_VAR 0 4
 951: PPUSH
 952: LD_VAR 0 2
 956: PPUSH
 957: CALL_OW 52
// end ;
 961: LD_VAR 0 3
 965: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 966: LD_INT 0
 968: PPUSH
 969: PPUSH
 970: PPUSH
// result := false ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 979: LD_ADDR_VAR 0 3
 983: PUSH
 984: LD_INT 22
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 34
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: PPUSH
1008: CALL_OW 69
1012: ST_TO_ADDR
// for i in filter do
1013: LD_ADDR_VAR 0 4
1017: PUSH
1018: LD_VAR 0 3
1022: PUSH
1023: FOR_IN
1024: IFFALSE 1055
// if IsDrivenBy ( i ) = unit then
1026: LD_VAR 0 4
1030: PPUSH
1031: CALL_OW 311
1035: PUSH
1036: LD_VAR 0 1
1040: EQUAL
1041: IFFALSE 1053
// begin result := true ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 1
1050: ST_TO_ADDR
// break ;
1051: GO 1055
// end ;
1053: GO 1023
1055: POP
1056: POP
// end ;
1057: LD_VAR 0 2
1061: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1062: LD_INT 0
1064: PPUSH
1065: PPUSH
// result := false ;
1066: LD_ADDR_VAR 0 2
1070: PUSH
1071: LD_INT 0
1073: ST_TO_ADDR
// if not blist then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1127
// for i in blist do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: LD_VAR 0 1
1092: PUSH
1093: FOR_IN
1094: IFFALSE 1125
// if UnitsInside ( i ) < 6 then
1096: LD_VAR 0 3
1100: PPUSH
1101: CALL_OW 313
1105: PUSH
1106: LD_INT 6
1108: LESS
1109: IFFALSE 1123
// begin result := i ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 3
1120: ST_TO_ADDR
// break ;
1121: GO 1125
// end ;
1123: GO 1093
1125: POP
1126: POP
// end ;
1127: LD_VAR 0 2
1131: RET
// export function Count ( timer , mode ) ; begin
1132: LD_INT 0
1134: PPUSH
// if not timer then
1135: LD_VAR 0 1
1139: NOT
1140: IFFALSE 1144
// exit ;
1142: GO 1195
// if mode in [ asc , up , + ] then
1144: LD_VAR 0 2
1148: PUSH
1149: LD_STRING asc
1151: PUSH
1152: LD_STRING up
1154: PUSH
1155: LD_STRING +
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: IN
1163: IFFALSE 1181
// result := timer + 0 0$01 else
1165: LD_ADDR_VAR 0 3
1169: PUSH
1170: LD_VAR 0 1
1174: PUSH
1175: LD_INT 35
1177: PLUS
1178: ST_TO_ADDR
1179: GO 1195
// result := timer - 0 0$01 ;
1181: LD_ADDR_VAR 0 3
1185: PUSH
1186: LD_VAR 0 1
1190: PUSH
1191: LD_INT 35
1193: MINUS
1194: ST_TO_ADDR
// end ;
1195: LD_VAR 0 3
1199: RET
// export function Video ( mode ) ; begin
1200: LD_INT 0
1202: PPUSH
// ingame_video = mode ;
1203: LD_ADDR_OWVAR 52
1207: PUSH
1208: LD_VAR 0 1
1212: ST_TO_ADDR
// interface_hidden = mode ;
1213: LD_ADDR_OWVAR 54
1217: PUSH
1218: LD_VAR 0 1
1222: ST_TO_ADDR
// end ; end_of_file
1223: LD_VAR 0 2
1227: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1228: LD_INT 0
1230: PPUSH
1231: PPUSH
1232: PPUSH
1233: PPUSH
1234: PPUSH
1235: PPUSH
1236: PPUSH
1237: PPUSH
// uc_side := 4 ;
1238: LD_ADDR_OWVAR 20
1242: PUSH
1243: LD_INT 4
1245: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1246: LD_ADDR_EXP 46
1250: PUSH
1251: LD_STRING Powell
1253: PPUSH
1254: LD_INT 0
1256: PPUSH
1257: CALL 489 0 2
1261: ST_TO_ADDR
// uc_side := 1 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
// uc_nation := 1 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 1
1277: ST_TO_ADDR
// if debug then
1278: LD_EXP 1
1282: IFFALSE 1412
// begin for i = 1 to 4 do
1284: LD_ADDR_VAR 0 2
1288: PUSH
1289: DOUBLE
1290: LD_INT 1
1292: DEC
1293: ST_TO_ADDR
1294: LD_INT 4
1296: PUSH
1297: FOR_TO
1298: IFFALSE 1349
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1300: LD_INT 0
1302: PPUSH
1303: LD_INT 1
1305: PPUSH
1306: LD_INT 2
1308: PPUSH
1309: CALL_OW 12
1313: PPUSH
1314: LD_INT 3
1316: PPUSH
1317: CALL_OW 380
// un := CreateHuman ;
1321: LD_ADDR_VAR 0 3
1325: PUSH
1326: CALL_OW 44
1330: ST_TO_ADDR
// others := others ^ un ;
1331: LD_ADDR_VAR 0 5
1335: PUSH
1336: LD_VAR 0 5
1340: PUSH
1341: LD_VAR 0 3
1345: ADD
1346: ST_TO_ADDR
// end ;
1347: GO 1297
1349: POP
1350: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1351: LD_ADDR_VAR 0 6
1355: PUSH
1356: LD_INT 21
1358: PUSH
1359: LD_INT 1
1361: PUSH
1362: LD_INT 1
1364: PUSH
1365: LD_INT 51
1367: PUSH
1368: LD_INT 90
1370: PUSH
1371: LD_INT 504
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: PUSH
1382: LD_INT 21
1384: PUSH
1385: LD_INT 1
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: LD_INT 51
1393: PUSH
1394: LD_INT 80
1396: PUSH
1397: LD_INT 750
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1412: LD_ADDR_EXP 37
1416: PUSH
1417: LD_STRING JMM
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: CALL 489 0 2
1430: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1431: LD_ADDR_EXP 38
1435: PUSH
1436: LD_STRING Bobby
1438: PPUSH
1439: LD_EXP 1
1443: NOT
1444: PPUSH
1445: CALL 489 0 2
1449: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1450: LD_ADDR_EXP 39
1454: PUSH
1455: LD_STRING Cyrus
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: CALL 489 0 2
1468: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1469: LD_ADDR_EXP 40
1473: PUSH
1474: LD_STRING Lisa
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: CALL 489 0 2
1487: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1488: LD_ADDR_EXP 41
1492: PUSH
1493: LD_STRING Khatam
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: CALL 489 0 2
1506: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1507: LD_ADDR_EXP 42
1511: PUSH
1512: LD_STRING Brian
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: CALL 489 0 2
1525: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1526: LD_ADDR_EXP 43
1530: PUSH
1531: LD_STRING Jerry
1533: PPUSH
1534: LD_EXP 1
1538: NOT
1539: PPUSH
1540: CALL 489 0 2
1544: ST_TO_ADDR
// if Bobby then
1545: LD_EXP 38
1549: IFFALSE 1580
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 4
1565: PUSH
1566: LD_INT 1
1568: PLUS
1569: PPUSH
1570: LD_EXP 38
1574: PPUSH
1575: CALL_OW 2
1579: ST_TO_ADDR
// if Cyrus then
1580: LD_EXP 39
1584: IFFALSE 1615
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_VAR 0 4
1595: PPUSH
1596: LD_VAR 0 4
1600: PUSH
1601: LD_INT 1
1603: PLUS
1604: PPUSH
1605: LD_EXP 39
1609: PPUSH
1610: CALL_OW 2
1614: ST_TO_ADDR
// if Lisa then
1615: LD_EXP 40
1619: IFFALSE 1650
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1621: LD_ADDR_VAR 0 4
1625: PUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: LD_VAR 0 4
1635: PUSH
1636: LD_INT 1
1638: PLUS
1639: PPUSH
1640: LD_EXP 40
1644: PPUSH
1645: CALL_OW 2
1649: ST_TO_ADDR
// if Khatam then
1650: LD_EXP 41
1654: IFFALSE 1685
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1656: LD_ADDR_VAR 0 4
1660: PUSH
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_VAR 0 4
1670: PUSH
1671: LD_INT 1
1673: PLUS
1674: PPUSH
1675: LD_EXP 41
1679: PPUSH
1680: CALL_OW 2
1684: ST_TO_ADDR
// if Brian then
1685: LD_EXP 42
1689: IFFALSE 1720
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_VAR 0 4
1700: PPUSH
1701: LD_VAR 0 4
1705: PUSH
1706: LD_INT 1
1708: PLUS
1709: PPUSH
1710: LD_EXP 42
1714: PPUSH
1715: CALL_OW 2
1719: ST_TO_ADDR
// if Jerry then
1720: LD_EXP 43
1724: IFFALSE 1755
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1726: LD_ADDR_VAR 0 4
1730: PUSH
1731: LD_VAR 0 4
1735: PPUSH
1736: LD_VAR 0 4
1740: PUSH
1741: LD_INT 1
1743: PLUS
1744: PPUSH
1745: LD_EXP 43
1749: PPUSH
1750: CALL_OW 2
1754: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1755: LD_STRING 02_other_survivors
1757: PPUSH
1758: CALL_OW 28
1762: IFFALSE 1777
// others := CreateCharacterSet ( 02_other_survivors ) ;
1764: LD_ADDR_VAR 0 5
1768: PUSH
1769: LD_STRING 02_other_survivors
1771: PPUSH
1772: CALL_OW 31
1776: ST_TO_ADDR
// if others then
1777: LD_VAR 0 5
1781: IFFALSE 1806
// begin tmp := tmp ^ others ;
1783: LD_ADDR_VAR 0 4
1787: PUSH
1788: LD_VAR 0 4
1792: PUSH
1793: LD_VAR 0 5
1797: ADD
1798: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1799: LD_STRING 02_other_survivors
1801: PPUSH
1802: CALL_OW 40
// end ; jmm_units := tmp ;
1806: LD_ADDR_EXP 4
1810: PUSH
1811: LD_VAR 0 4
1815: ST_TO_ADDR
// if not vehicles then
1816: LD_VAR 0 6
1820: NOT
1821: IFFALSE 1839
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1823: LD_ADDR_VAR 0 6
1827: PUSH
1828: LD_STRING 02_tanks_1
1830: PPUSH
1831: LD_INT 0
1833: PPUSH
1834: CALL_OW 30
1838: ST_TO_ADDR
// if vehicles then
1839: LD_VAR 0 6
1843: IFFALSE 2037
// begin got_mech := false ;
1845: LD_ADDR_VAR 0 7
1849: PUSH
1850: LD_INT 0
1852: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 3
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PPUSH
1868: CALL_OW 72
1872: IFFALSE 1882
// got_mech := true ;
1874: LD_ADDR_VAR 0 7
1878: PUSH
1879: LD_INT 1
1881: ST_TO_ADDR
// for i = 1 to vehicles do
1882: LD_ADDR_VAR 0 2
1886: PUSH
1887: DOUBLE
1888: LD_INT 1
1890: DEC
1891: ST_TO_ADDR
1892: LD_VAR 0 6
1896: PUSH
1897: FOR_TO
1898: IFFALSE 2035
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1900: LD_ADDR_VAR 0 3
1904: PUSH
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 3
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 2
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 3
1954: ARRAY
1955: PPUSH
1956: LD_VAR 0 6
1960: PUSH
1961: LD_VAR 0 2
1965: ARRAY
1966: PUSH
1967: LD_INT 4
1969: ARRAY
1970: PPUSH
1971: LD_INT 40
1973: PPUSH
1974: CALL 552 0 7
1978: ST_TO_ADDR
// if not got_mech then
1979: LD_VAR 0 7
1983: NOT
1984: IFFALSE 2010
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 6
1995: PUSH
1996: LD_VAR 0 2
2000: ARRAY
2001: PUSH
2002: LD_INT 6
2004: ARRAY
2005: PPUSH
2006: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
2010: LD_ADDR_VAR 0 4
2014: PUSH
2015: LD_VAR 0 4
2019: PPUSH
2020: LD_INT 1
2022: PPUSH
2023: LD_VAR 0 3
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
// end ;
2033: GO 1897
2035: POP
2036: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2037: LD_EXP 37
2041: PPUSH
2042: LD_INT 194
2044: PPUSH
2045: LD_INT 119
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 48
// if tmp then
2055: LD_VAR 0 4
2059: IFFALSE 2184
// begin for i in tmp do
2061: LD_ADDR_VAR 0 2
2065: PUSH
2066: LD_VAR 0 4
2070: PUSH
2071: FOR_IN
2072: IFFALSE 2182
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2074: LD_ADDR_VAR 0 8
2078: PUSH
2079: LD_INT 22
2081: PUSH
2082: LD_INT 1
2084: PUSH
2085: EMPTY
2086: LIST
2087: LIST
2088: PUSH
2089: LD_INT 21
2091: PUSH
2092: LD_INT 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: PUSH
2099: LD_INT 58
2101: PUSH
2102: EMPTY
2103: LIST
2104: PUSH
2105: EMPTY
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL_OW 69
2114: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2115: LD_VAR 0 2
2119: PPUSH
2120: CALL_OW 247
2124: PUSH
2125: LD_INT 1
2127: EQUAL
2128: PUSH
2129: LD_VAR 0 8
2133: AND
2134: IFFALSE 2156
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2136: LD_VAR 0 2
2140: PPUSH
2141: LD_VAR 0 8
2145: PUSH
2146: LD_INT 1
2148: ARRAY
2149: PPUSH
2150: CALL_OW 52
2154: GO 2171
// PlaceUnitArea ( i , startArea , false ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: LD_INT 1
2163: PPUSH
2164: LD_INT 0
2166: PPUSH
2167: CALL_OW 49
// ComHold ( i ) ;
2171: LD_VAR 0 2
2175: PPUSH
2176: CALL_OW 140
// end ;
2180: GO 2071
2182: POP
2183: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2184: LD_ADDR_EXP 7
2188: PUSH
2189: LD_STRING 02_mikhailStatus_1
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 30
2199: ST_TO_ADDR
// if not bierezov_exist and not debug then
2200: LD_EXP 7
2204: NOT
2205: PUSH
2206: LD_EXP 1
2210: NOT
2211: AND
2212: IFFALSE 2216
// exit ;
2214: GO 2247
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2216: LD_ADDR_EXP 45
2220: PUSH
2221: LD_STRING Mikhail
2223: PPUSH
2224: LD_INT 0
2226: PPUSH
2227: CALL 489 0 2
2231: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2232: LD_EXP 45
2236: PPUSH
2237: LD_INT 1
2239: PPUSH
2240: LD_INT 0
2242: PPUSH
2243: CALL_OW 49
// end ;
2247: LD_VAR 0 1
2251: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2252: LD_INT 0
2254: PPUSH
2255: PPUSH
2256: PPUSH
2257: PPUSH
// uc_side := 4 ;
2258: LD_ADDR_OWVAR 20
2262: PUSH
2263: LD_INT 4
2265: ST_TO_ADDR
// uc_nation := 1 ;
2266: LD_ADDR_OWVAR 21
2270: PUSH
2271: LD_INT 1
2273: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2274: LD_ADDR_EXP 44
2278: PUSH
2279: LD_STRING Cornell
2281: PPUSH
2282: LD_INT 0
2284: PPUSH
2285: CALL 489 0 2
2289: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2290: LD_ADDR_EXP 6
2294: PUSH
2295: LD_INT 9
2297: PUSH
2298: LD_EXP 4
2302: MINUS
2303: ST_TO_ADDR
// tmp := [ ] ;
2304: LD_ADDR_VAR 0 2
2308: PUSH
2309: EMPTY
2310: ST_TO_ADDR
// if cornel_units < 4 then
2311: LD_EXP 6
2315: PUSH
2316: LD_INT 4
2318: LESS
2319: IFFALSE 2329
// cornel_units := 4 ;
2321: LD_ADDR_EXP 6
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// for i = 1 to cornel_units do
2329: LD_ADDR_VAR 0 4
2333: PUSH
2334: DOUBLE
2335: LD_INT 1
2337: DEC
2338: ST_TO_ADDR
2339: LD_EXP 6
2343: PUSH
2344: FOR_TO
2345: IFFALSE 2443
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2347: LD_INT 0
2349: PPUSH
2350: LD_INT 1
2352: PUSH
2353: LD_INT 1
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 2
2361: PUSH
2362: LD_INT 4
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: PUSH
2372: LD_VAR 0 4
2376: PUSH
2377: LD_INT 5
2379: MOD
2380: PUSH
2381: LD_INT 1
2383: PLUS
2384: ARRAY
2385: PPUSH
2386: LD_INT 2
2388: PPUSH
2389: CALL_OW 380
// un := CreateHuman ;
2393: LD_ADDR_VAR 0 3
2397: PUSH
2398: CALL_OW 44
2402: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2403: LD_ADDR_VAR 0 2
2407: PUSH
2408: LD_VAR 0 2
2412: PPUSH
2413: LD_INT 1
2415: PPUSH
2416: LD_VAR 0 3
2420: PPUSH
2421: CALL_OW 2
2425: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2426: LD_VAR 0 3
2430: PPUSH
2431: LD_INT 2
2433: PPUSH
2434: LD_INT 0
2436: PPUSH
2437: CALL_OW 49
// end ;
2441: GO 2344
2443: POP
2444: POP
// cornel_units := tmp ;
2445: LD_ADDR_EXP 6
2449: PUSH
2450: LD_VAR 0 2
2454: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2455: LD_EXP 44
2459: PPUSH
2460: LD_INT 191
2462: PPUSH
2463: LD_INT 106
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL_OW 48
// end ;
2473: LD_VAR 0 1
2477: RET
// export function PrepareWesternBase ; var i ; begin
2478: LD_INT 0
2480: PPUSH
2481: PPUSH
// uc_side := 8 ;
2482: LD_ADDR_OWVAR 20
2486: PUSH
2487: LD_INT 8
2489: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2490: LD_ADDR_EXP 47
2494: PUSH
2495: LD_STRING Lynch
2497: PPUSH
2498: LD_INT 0
2500: PPUSH
2501: CALL 489 0 2
2505: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2506: LD_ADDR_EXP 48
2510: PUSH
2511: LD_STRING Walker
2513: PPUSH
2514: LD_INT 0
2516: PPUSH
2517: CALL 489 0 2
2521: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2522: LD_ADDR_EXP 49
2526: PUSH
2527: LD_STRING Turner
2529: PPUSH
2530: LD_INT 0
2532: PPUSH
2533: CALL 489 0 2
2537: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2538: LD_ADDR_EXP 50
2542: PUSH
2543: LD_STRING Jillian
2545: PPUSH
2546: LD_INT 0
2548: PPUSH
2549: CALL 489 0 2
2553: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2554: LD_ADDR_VAR 0 2
2558: PUSH
2559: LD_EXP 47
2563: PUSH
2564: LD_EXP 48
2568: PUSH
2569: LD_EXP 49
2573: PUSH
2574: LD_EXP 50
2578: PUSH
2579: EMPTY
2580: LIST
2581: LIST
2582: LIST
2583: LIST
2584: PUSH
2585: FOR_IN
2586: IFFALSE 2614
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: LD_INT 3
2595: PPUSH
2596: LD_INT 0
2598: PPUSH
2599: CALL_OW 49
// ComHold ( i ) ;
2603: LD_VAR 0 2
2607: PPUSH
2608: CALL_OW 140
// end ;
2612: GO 2585
2614: POP
2615: POP
// end ;
2616: LD_VAR 0 1
2620: RET
// export function SelectGroup ; var units , selected , i ; begin
2621: LD_INT 0
2623: PPUSH
2624: PPUSH
2625: PPUSH
2626: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_EXP 37
2636: PUSH
2637: LD_INT -3
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: PUSH
2644: LD_EXP 4
2648: ADD
2649: PUSH
2650: LD_INT -2
2652: PUSH
2653: LD_INT -4
2655: PUSH
2656: LD_EXP 44
2660: PUSH
2661: LD_EXP 45
2665: PUSH
2666: EMPTY
2667: LIST
2668: LIST
2669: LIST
2670: LIST
2671: ADD
2672: PUSH
2673: LD_INT -3
2675: PUSH
2676: EMPTY
2677: LIST
2678: ADD
2679: PUSH
2680: LD_EXP 6
2684: ADD
2685: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2686: LD_ADDR_VAR 0 3
2690: PUSH
2691: LD_EXP 37
2695: PUSH
2696: LD_STRING Select five characters to go with you
2698: PPUSH
2699: LD_INT 4
2701: PPUSH
2702: LD_INT 4
2704: PPUSH
2705: LD_VAR 0 2
2709: PPUSH
2710: EMPTY
2711: PPUSH
2712: CALL_OW 42
2716: ADD
2717: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2718: LD_ADDR_EXP 6
2722: PUSH
2723: LD_EXP 4
2727: PUSH
2728: LD_EXP 6
2732: UNION
2733: PUSH
2734: LD_VAR 0 3
2738: DIFF
2739: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2740: LD_ADDR_VAR 0 4
2744: PUSH
2745: LD_EXP 6
2749: PUSH
2750: LD_EXP 45
2754: ADD
2755: PUSH
2756: FOR_IN
2757: IFFALSE 2788
// if GetSide ( i ) = 1 then
2759: LD_VAR 0 4
2763: PPUSH
2764: CALL_OW 255
2768: PUSH
2769: LD_INT 1
2771: EQUAL
2772: IFFALSE 2786
// SetSide ( i , 4 ) ;
2774: LD_VAR 0 4
2778: PPUSH
2779: LD_INT 4
2781: PPUSH
2782: CALL_OW 235
2786: GO 2756
2788: POP
2789: POP
// for i in selected do
2790: LD_ADDR_VAR 0 4
2794: PUSH
2795: LD_VAR 0 3
2799: PUSH
2800: FOR_IN
2801: IFFALSE 2832
// if GetSide ( i ) = 4 then
2803: LD_VAR 0 4
2807: PPUSH
2808: CALL_OW 255
2812: PUSH
2813: LD_INT 4
2815: EQUAL
2816: IFFALSE 2830
// SetSide ( i , 1 ) ;
2818: LD_VAR 0 4
2822: PPUSH
2823: LD_INT 1
2825: PPUSH
2826: CALL_OW 235
2830: GO 2800
2832: POP
2833: POP
// jmm_units := jmm_units diff cornel_units ;
2834: LD_ADDR_EXP 4
2838: PUSH
2839: LD_EXP 4
2843: PUSH
2844: LD_EXP 6
2848: DIFF
2849: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2850: LD_EXP 38
2854: PPUSH
2855: CALL_OW 255
2859: PUSH
2860: LD_INT 4
2862: EQUAL
2863: IFFALSE 2878
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2865: LD_EXP 3
2869: PUSH
2870: LD_STRING Bobby
2872: STR
2873: PPUSH
2874: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2878: LD_EXP 39
2882: PPUSH
2883: CALL_OW 255
2887: PUSH
2888: LD_INT 4
2890: EQUAL
2891: IFFALSE 2906
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2893: LD_EXP 3
2897: PUSH
2898: LD_STRING Cyrus
2900: STR
2901: PPUSH
2902: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2906: LD_EXP 40
2910: PPUSH
2911: CALL_OW 255
2915: PUSH
2916: LD_INT 4
2918: EQUAL
2919: IFFALSE 2934
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2921: LD_EXP 3
2925: PUSH
2926: LD_STRING Lisa
2928: STR
2929: PPUSH
2930: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2934: LD_EXP 41
2938: PPUSH
2939: CALL_OW 255
2943: PUSH
2944: LD_INT 4
2946: EQUAL
2947: IFFALSE 2962
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2949: LD_EXP 3
2953: PUSH
2954: LD_STRING Khatam
2956: STR
2957: PPUSH
2958: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2962: LD_EXP 42
2966: PPUSH
2967: CALL_OW 255
2971: PUSH
2972: LD_INT 4
2974: EQUAL
2975: IFFALSE 2990
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2977: LD_EXP 3
2981: PUSH
2982: LD_STRING Brian
2984: STR
2985: PPUSH
2986: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2990: LD_EXP 43
2994: PPUSH
2995: CALL_OW 255
2999: PUSH
3000: LD_INT 4
3002: EQUAL
3003: IFFALSE 3018
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
3005: LD_EXP 3
3009: PUSH
3010: LD_STRING Jerry
3012: STR
3013: PPUSH
3014: CALL_OW 40
// end ; end_of_file
3018: LD_VAR 0 1
3022: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3023: LD_INT 0
3025: PPUSH
3026: PPUSH
3027: PPUSH
3028: PPUSH
3029: PPUSH
3030: PPUSH
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
3035: PPUSH
3036: PPUSH
3037: PPUSH
// ru_alert := false ;
3038: LD_ADDR_EXP 60
3042: PUSH
3043: LD_INT 0
3045: ST_TO_ADDR
// ru_produce_list := [ ] ;
3046: LD_ADDR_EXP 57
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if Difficulty > 1 then
3053: LD_OWVAR 67
3057: PUSH
3058: LD_INT 1
3060: GREATER
3061: IFFALSE 3149
// begin uc_side := 3 ;
3063: LD_ADDR_OWVAR 20
3067: PUSH
3068: LD_INT 3
3070: ST_TO_ADDR
// uc_nation := 3 ;
3071: LD_ADDR_OWVAR 21
3075: PUSH
3076: LD_INT 3
3078: ST_TO_ADDR
// bc_type := b_breastwork ;
3079: LD_ADDR_OWVAR 42
3083: PUSH
3084: LD_INT 31
3086: ST_TO_ADDR
// bc_level := Difficulty ;
3087: LD_ADDR_OWVAR 43
3091: PUSH
3092: LD_OWVAR 67
3096: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3097: LD_INT 22
3099: PPUSH
3100: LD_INT 14
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3110: LD_INT 48
3112: PPUSH
3113: LD_INT 46
3115: PPUSH
3116: LD_INT 0
3118: PPUSH
3119: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3123: LD_INT 86
3125: PPUSH
3126: LD_INT 65
3128: PPUSH
3129: LD_INT 5
3131: PPUSH
3132: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3136: LD_INT 165
3138: PPUSH
3139: LD_INT 73
3141: PPUSH
3142: LD_INT 5
3144: PPUSH
3145: CALL_OW 47
// end ; if Difficulty = 3 then
3149: LD_OWVAR 67
3153: PUSH
3154: LD_INT 3
3156: EQUAL
3157: IFFALSE 3172
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3159: LD_INT 51
3161: PPUSH
3162: LD_INT 3
3164: PPUSH
3165: LD_INT 2
3167: PPUSH
3168: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3172: LD_ADDR_VAR 0 7
3176: PUSH
3177: LD_INT 22
3179: PUSH
3180: LD_INT 3
3182: PUSH
3183: EMPTY
3184: LIST
3185: LIST
3186: PUSH
3187: LD_INT 2
3189: PUSH
3190: LD_INT 30
3192: PUSH
3193: LD_INT 31
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 30
3202: PUSH
3203: LD_INT 32
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: LIST
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: PPUSH
3219: CALL_OW 69
3223: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3224: LD_ADDR_VAR 0 8
3228: PUSH
3229: LD_INT 22
3231: PUSH
3232: LD_INT 3
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: PUSH
3239: LD_INT 30
3241: PUSH
3242: LD_INT 4
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PPUSH
3253: CALL_OW 69
3257: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3258: LD_ADDR_VAR 0 10
3262: PUSH
3263: LD_INT 22
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: LD_INT 30
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: PPUSH
3287: CALL_OW 69
3291: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3292: LD_ADDR_VAR 0 9
3296: PUSH
3297: LD_INT 22
3299: PUSH
3300: LD_INT 3
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 30
3309: PUSH
3310: LD_INT 6
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 69
3325: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_INT 22
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: PUSH
3341: LD_INT 30
3343: PUSH
3344: LD_INT 1
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: PPUSH
3355: CALL_OW 69
3359: PUSH
3360: FOR_IN
3361: IFFALSE 3405
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3363: LD_VAR 0 2
3367: PPUSH
3368: CALL_OW 274
3372: PPUSH
3373: LD_INT 1
3375: PPUSH
3376: LD_INT 5000
3378: PPUSH
3379: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3383: LD_VAR 0 2
3387: PPUSH
3388: CALL_OW 274
3392: PPUSH
3393: LD_INT 2
3395: PPUSH
3396: LD_INT 3000
3398: PPUSH
3399: CALL_OW 277
// end ;
3403: GO 3360
3405: POP
3406: POP
// uc_side := 3 ;
3407: LD_ADDR_OWVAR 20
3411: PUSH
3412: LD_INT 3
3414: ST_TO_ADDR
// uc_nation := 3 ;
3415: LD_ADDR_OWVAR 21
3419: PUSH
3420: LD_INT 3
3422: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3423: LD_ADDR_VAR 0 11
3427: PUSH
3428: LD_INT 2
3430: PUSH
3431: LD_INT 3
3433: PUSH
3434: LD_INT 4
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: LIST
3441: PUSH
3442: LD_OWVAR 67
3446: ARRAY
3447: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3448: LD_ADDR_EXP 52
3452: PUSH
3453: LD_STRING Pokryshkin
3455: PPUSH
3456: LD_INT 0
3458: PPUSH
3459: CALL 489 0 2
3463: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3464: LD_EXP 52
3468: PPUSH
3469: LD_INT 63
3471: PPUSH
3472: LD_INT 21
3474: PPUSH
3475: LD_INT 0
3477: PPUSH
3478: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3482: LD_EXP 52
3486: PPUSH
3487: CALL_OW 140
// InitHc ;
3491: CALL_OW 19
// for i in fac do
3495: LD_ADDR_VAR 0 2
3499: PUSH
3500: LD_VAR 0 10
3504: PUSH
3505: FOR_IN
3506: IFFALSE 3559
// begin for j = 1 to 6 do
3508: LD_ADDR_VAR 0 3
3512: PUSH
3513: DOUBLE
3514: LD_INT 1
3516: DEC
3517: ST_TO_ADDR
3518: LD_INT 6
3520: PUSH
3521: FOR_TO
3522: IFFALSE 3555
// begin PrepareHuman ( false , 3 , skill ) ;
3524: LD_INT 0
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_VAR 0 11
3534: PPUSH
3535: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3539: CALL_OW 44
3543: PPUSH
3544: LD_VAR 0 2
3548: PPUSH
3549: CALL_OW 52
// end ;
3553: GO 3521
3555: POP
3556: POP
// end ;
3557: GO 3505
3559: POP
3560: POP
// for i in lab do
3561: LD_ADDR_VAR 0 2
3565: PUSH
3566: LD_VAR 0 9
3570: PUSH
3571: FOR_IN
3572: IFFALSE 3605
// begin PrepareHuman ( false , 4 , skill ) ;
3574: LD_INT 0
3576: PPUSH
3577: LD_INT 4
3579: PPUSH
3580: LD_VAR 0 11
3584: PPUSH
3585: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3589: CALL_OW 44
3593: PPUSH
3594: LD_VAR 0 2
3598: PPUSH
3599: CALL_OW 52
// end ;
3603: GO 3571
3605: POP
3606: POP
// for i in tw do
3607: LD_ADDR_VAR 0 2
3611: PUSH
3612: LD_VAR 0 7
3616: PUSH
3617: FOR_IN
3618: IFFALSE 3667
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3620: LD_VAR 0 2
3624: PPUSH
3625: LD_INT 42
3627: PUSH
3628: LD_INT 43
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 1
3637: PPUSH
3638: LD_INT 2
3640: PPUSH
3641: CALL_OW 12
3645: ARRAY
3646: PPUSH
3647: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3651: LD_VAR 0 11
3655: PPUSH
3656: LD_VAR 0 2
3660: PPUSH
3661: CALL 830 0 2
// end ;
3665: GO 3617
3667: POP
3668: POP
// for i in bar do
3669: LD_ADDR_VAR 0 2
3673: PUSH
3674: LD_VAR 0 8
3678: PUSH
3679: FOR_IN
3680: IFFALSE 3713
// begin PrepareHuman ( false , 1 , skill ) ;
3682: LD_INT 0
3684: PPUSH
3685: LD_INT 1
3687: PPUSH
3688: LD_VAR 0 11
3692: PPUSH
3693: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3697: CALL_OW 44
3701: PPUSH
3702: LD_VAR 0 2
3706: PPUSH
3707: CALL_OW 52
// end ;
3711: GO 3679
3713: POP
3714: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3715: LD_ADDR_VAR 0 13
3719: PUSH
3720: LD_INT 100
3722: PUSH
3723: LD_INT 9
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: PUSH
3730: LD_INT 135
3732: PUSH
3733: LD_INT 60
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 41
3742: PUSH
3743: LD_INT 6
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 22
3752: PUSH
3753: LD_INT 9
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PUSH
3760: LD_INT 84
3762: PUSH
3763: LD_INT 14
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: LIST
3774: LIST
3775: LIST
3776: ST_TO_ADDR
// vehicles := [ ] ;
3777: LD_ADDR_VAR 0 12
3781: PUSH
3782: EMPTY
3783: ST_TO_ADDR
// for i in spot_xy do
3784: LD_ADDR_VAR 0 2
3788: PUSH
3789: LD_VAR 0 13
3793: PUSH
3794: FOR_IN
3795: IFFALSE 3953
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3797: LD_ADDR_VAR 0 6
3801: PUSH
3802: LD_INT 3
3804: PPUSH
3805: LD_INT 3
3807: PPUSH
3808: LD_INT 22
3810: PPUSH
3811: LD_INT 1
3813: PPUSH
3814: LD_INT 1
3816: PPUSH
3817: LD_INT 42
3819: PUSH
3820: LD_INT 43
3822: PUSH
3823: LD_INT 44
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: LIST
3830: PUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 12
3841: ARRAY
3842: PPUSH
3843: LD_INT 100
3845: PPUSH
3846: CALL 552 0 7
3850: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3851: LD_ADDR_VAR 0 12
3855: PUSH
3856: LD_VAR 0 12
3860: PPUSH
3861: LD_VAR 0 12
3865: PUSH
3866: LD_INT 1
3868: PLUS
3869: PPUSH
3870: LD_VAR 0 6
3874: PPUSH
3875: CALL_OW 2
3879: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3880: LD_VAR 0 6
3884: PPUSH
3885: LD_INT 3
3887: PPUSH
3888: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3892: LD_VAR 0 6
3896: PPUSH
3897: LD_VAR 0 2
3901: PUSH
3902: LD_INT 1
3904: ARRAY
3905: PPUSH
3906: LD_VAR 0 2
3910: PUSH
3911: LD_INT 2
3913: ARRAY
3914: PPUSH
3915: LD_INT 0
3917: PPUSH
3918: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 3
3927: PPUSH
3928: LD_VAR 0 11
3932: PPUSH
3933: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3937: CALL_OW 44
3941: PPUSH
3942: LD_VAR 0 6
3946: PPUSH
3947: CALL_OW 52
// end ;
3951: GO 3794
3953: POP
3954: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3955: LD_ADDR_VAR 0 2
3959: PUSH
3960: DOUBLE
3961: LD_INT 1
3963: DEC
3964: ST_TO_ADDR
3965: LD_INT 5
3967: PUSH
3968: LD_INT 7
3970: PUSH
3971: LD_INT 8
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: PUSH
3979: LD_OWVAR 67
3983: ARRAY
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4046
// begin PrepareHuman ( false , 1 , skill ) ;
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 1
3993: PPUSH
3994: LD_VAR 0 11
3998: PPUSH
3999: CALL_OW 380
// un := CreateHuman ;
4003: LD_ADDR_VAR 0 5
4007: PUSH
4008: CALL_OW 44
4012: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
4013: LD_VAR 0 5
4017: PPUSH
4018: LD_INT 11
4020: PPUSH
4021: LD_INT 0
4023: PPUSH
4024: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4028: LD_ADDR_EXP 55
4032: PUSH
4033: LD_EXP 55
4037: PUSH
4038: LD_VAR 0 5
4042: ADD
4043: ST_TO_ADDR
// end ;
4044: GO 3985
4046: POP
4047: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4048: LD_ADDR_VAR 0 2
4052: PUSH
4053: DOUBLE
4054: LD_INT 1
4056: DEC
4057: ST_TO_ADDR
4058: LD_INT 2
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PUSH
4072: LD_OWVAR 67
4076: ARRAY
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4139
// begin PrepareHuman ( false , 1 , skill ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: LD_VAR 0 11
4091: PPUSH
4092: CALL_OW 380
// un := CreateHuman ;
4096: LD_ADDR_VAR 0 5
4100: PUSH
4101: CALL_OW 44
4105: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4106: LD_VAR 0 5
4110: PPUSH
4111: LD_INT 12
4113: PPUSH
4114: LD_INT 0
4116: PPUSH
4117: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4121: LD_ADDR_EXP 53
4125: PUSH
4126: LD_EXP 53
4130: PUSH
4131: LD_VAR 0 5
4135: ADD
4136: ST_TO_ADDR
// end ;
4137: GO 4078
4139: POP
4140: POP
// for i = 1 to 2 do
4141: LD_ADDR_VAR 0 2
4145: PUSH
4146: DOUBLE
4147: LD_INT 1
4149: DEC
4150: ST_TO_ADDR
4151: LD_INT 2
4153: PUSH
4154: FOR_TO
4155: IFFALSE 4221
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4157: LD_INT 1
4159: PPUSH
4160: LD_INT 1
4162: PPUSH
4163: LD_VAR 0 11
4167: PPUSH
4168: CALL_OW 380
// un := CreateHuman ;
4172: LD_ADDR_VAR 0 5
4176: PUSH
4177: CALL_OW 44
4181: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4182: LD_VAR 0 5
4186: PPUSH
4187: LD_INT 39
4189: PPUSH
4190: LD_INT 12
4192: PPUSH
4193: LD_INT 3
4195: PPUSH
4196: LD_INT 0
4198: PPUSH
4199: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4203: LD_ADDR_EXP 54
4207: PUSH
4208: LD_EXP 54
4212: PUSH
4213: LD_VAR 0 5
4217: ADD
4218: ST_TO_ADDR
// end ;
4219: GO 4154
4221: POP
4222: POP
// for i = 1 to 3 do
4223: LD_ADDR_VAR 0 2
4227: PUSH
4228: DOUBLE
4229: LD_INT 1
4231: DEC
4232: ST_TO_ADDR
4233: LD_INT 3
4235: PUSH
4236: FOR_TO
4237: IFFALSE 4303
// begin PrepareHuman ( false , 1 , skill ) ;
4239: LD_INT 0
4241: PPUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_VAR 0 11
4249: PPUSH
4250: CALL_OW 380
// un := CreateHuman ;
4254: LD_ADDR_VAR 0 5
4258: PUSH
4259: CALL_OW 44
4263: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4264: LD_VAR 0 5
4268: PPUSH
4269: LD_INT 180
4271: PPUSH
4272: LD_INT 11
4274: PPUSH
4275: LD_INT 4
4277: PPUSH
4278: LD_INT 0
4280: PPUSH
4281: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4285: LD_ADDR_EXP 58
4289: PUSH
4290: LD_EXP 58
4294: PUSH
4295: LD_VAR 0 5
4299: ADD
4300: ST_TO_ADDR
// end ;
4301: GO 4236
4303: POP
4304: POP
// ru_vehicles := vehicles ;
4305: LD_ADDR_EXP 56
4309: PUSH
4310: LD_VAR 0 12
4314: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: LD_INT 131
4322: PUSH
4323: LD_INT 121
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: LD_INT 113
4332: PUSH
4333: LD_INT 90
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 93
4342: PUSH
4343: LD_INT 62
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: LIST
4354: PUSH
4355: LD_INT 106
4357: PUSH
4358: LD_INT 54
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: PUSH
4365: LD_INT 120
4367: PUSH
4368: LD_INT 80
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 143
4377: PUSH
4378: LD_INT 120
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: LIST
4389: PUSH
4390: LD_INT 154
4392: PUSH
4393: LD_INT 116
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PUSH
4400: LD_INT 140
4402: PUSH
4403: LD_INT 93
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 130
4412: PUSH
4413: LD_INT 58
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 105
4427: PUSH
4428: LD_INT 106
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 134
4437: PUSH
4438: LD_INT 98
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PUSH
4445: LD_INT 159
4447: PUSH
4448: LD_INT 113
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PUSH
4455: EMPTY
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: LIST
4464: LIST
4465: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4466: LD_ADDR_VAR 0 2
4470: PUSH
4471: DOUBLE
4472: LD_INT 1
4474: DEC
4475: ST_TO_ADDR
4476: LD_OWVAR 67
4480: PUSH
4481: LD_INT 1
4483: MINUS
4484: PUSH
4485: FOR_TO
4486: IFFALSE 4519
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4488: LD_ADDR_EXP 57
4492: PUSH
4493: LD_EXP 57
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 1
4503: PUSH
4504: LD_INT 1
4506: PUSH
4507: LD_INT 43
4509: PUSH
4510: EMPTY
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: ADD
4516: ST_TO_ADDR
4517: GO 4485
4519: POP
4520: POP
// end ;
4521: LD_VAR 0 1
4525: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4526: LD_INT 22
4528: PUSH
4529: LD_INT 3
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: LD_INT 21
4538: PUSH
4539: LD_INT 2
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: IFFALSE 4648
4556: GO 4558
4558: DISABLE
4559: LD_INT 0
4561: PPUSH
4562: PPUSH
// begin enable ;
4563: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4564: LD_ADDR_VAR 0 2
4568: PUSH
4569: LD_INT 22
4571: PUSH
4572: LD_INT 3
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 21
4581: PUSH
4582: LD_INT 2
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: PUSH
4589: EMPTY
4590: LIST
4591: LIST
4592: PPUSH
4593: CALL_OW 69
4597: ST_TO_ADDR
// if filter then
4598: LD_VAR 0 2
4602: IFFALSE 4648
// for i in filter do
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: FOR_IN
4615: IFFALSE 4646
// if GetFuel ( i ) < 20 then
4617: LD_VAR 0 1
4621: PPUSH
4622: CALL_OW 261
4626: PUSH
4627: LD_INT 20
4629: LESS
4630: IFFALSE 4644
// SetFuel ( i , 20 ) ;
4632: LD_VAR 0 1
4636: PPUSH
4637: LD_INT 20
4639: PPUSH
4640: CALL_OW 240
4644: GO 4614
4646: POP
4647: POP
// end ;
4648: PPOPN 2
4650: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4651: LD_EXP 57
4655: IFFALSE 4874
4657: GO 4659
4659: DISABLE
4660: LD_INT 0
4662: PPUSH
4663: PPUSH
4664: PPUSH
// begin enable ;
4665: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4666: LD_ADDR_VAR 0 2
4670: PUSH
4671: LD_INT 22
4673: PUSH
4674: LD_INT 3
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PUSH
4681: LD_INT 30
4683: PUSH
4684: LD_INT 3
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PPUSH
4695: CALL_OW 69
4699: ST_TO_ADDR
// can_produce := [ ] ;
4700: LD_ADDR_VAR 0 3
4704: PUSH
4705: EMPTY
4706: ST_TO_ADDR
// if not fac then
4707: LD_VAR 0 2
4711: NOT
4712: IFFALSE 4717
// begin disable ;
4714: DISABLE
// exit ;
4715: GO 4874
// end ; for i in fac do
4717: LD_ADDR_VAR 0 1
4721: PUSH
4722: LD_VAR 0 2
4726: PUSH
4727: FOR_IN
4728: IFFALSE 4766
// if UnitsInside ( i ) then
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 313
4739: IFFALSE 4764
// can_produce := Insert ( can_produce , 1 , i ) ;
4741: LD_ADDR_VAR 0 3
4745: PUSH
4746: LD_VAR 0 3
4750: PPUSH
4751: LD_INT 1
4753: PPUSH
4754: LD_VAR 0 1
4758: PPUSH
4759: CALL_OW 2
4763: ST_TO_ADDR
4764: GO 4727
4766: POP
4767: POP
// if not can_produce then
4768: LD_VAR 0 3
4772: NOT
4773: IFFALSE 4777
// exit ;
4775: GO 4874
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4777: LD_VAR 0 3
4781: PUSH
4782: LD_INT 1
4784: PPUSH
4785: LD_VAR 0 3
4789: PPUSH
4790: CALL_OW 12
4794: ARRAY
4795: PPUSH
4796: LD_EXP 57
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_EXP 57
4809: PUSH
4810: LD_INT 2
4812: ARRAY
4813: PPUSH
4814: LD_EXP 57
4818: PUSH
4819: LD_INT 3
4821: ARRAY
4822: PPUSH
4823: LD_EXP 57
4827: PUSH
4828: LD_INT 4
4830: ARRAY
4831: PPUSH
4832: CALL_OW 125
// for i = 1 to 4 do
4836: LD_ADDR_VAR 0 1
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_INT 4
4848: PUSH
4849: FOR_TO
4850: IFFALSE 4872
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4852: LD_ADDR_EXP 57
4856: PUSH
4857: LD_EXP 57
4861: PPUSH
4862: LD_INT 1
4864: PPUSH
4865: CALL_OW 3
4869: ST_TO_ADDR
4870: GO 4849
4872: POP
4873: POP
// end ;
4874: PPOPN 3
4876: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4877: LD_INT 0
4879: PPUSH
4880: PPUSH
4881: PPUSH
// for i = 1 to 6 do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: DOUBLE
4888: LD_INT 1
4890: DEC
4891: ST_TO_ADDR
4892: LD_INT 6
4894: PUSH
4895: FOR_TO
4896: IFFALSE 5045
// begin PrepareHuman ( false , 3 , 3 ) ;
4898: LD_INT 0
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_INT 3
4918: PPUSH
4919: LD_INT 3
4921: PPUSH
4922: LD_INT 22
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 1
4930: PPUSH
4931: LD_INT 43
4933: PUSH
4934: LD_INT 42
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: PUSH
4941: LD_INT 1
4943: PPUSH
4944: LD_INT 2
4946: PPUSH
4947: CALL_OW 12
4951: ARRAY
4952: PPUSH
4953: LD_INT 70
4955: PPUSH
4956: CALL 552 0 7
4960: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4961: LD_VAR 0 3
4965: PPUSH
4966: LD_INT 4
4968: PPUSH
4969: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4973: LD_VAR 0 3
4977: PPUSH
4978: LD_INT 229
4980: PPUSH
4981: LD_INT 44
4983: PPUSH
4984: LD_INT 0
4986: PPUSH
4987: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4991: CALL_OW 44
4995: PPUSH
4996: LD_VAR 0 3
5000: PPUSH
5001: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
5005: LD_ADDR_EXP 56
5009: PUSH
5010: LD_EXP 56
5014: PUSH
5015: LD_VAR 0 3
5019: ADD
5020: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5021: LD_VAR 0 3
5025: PPUSH
5026: LD_INT 191
5028: PPUSH
5029: LD_INT 32
5031: PPUSH
5032: CALL_OW 111
// Wait ( 0 0$02 ) ;
5036: LD_INT 70
5038: PPUSH
5039: CALL_OW 67
// end ;
5043: GO 4895
5045: POP
5046: POP
// end ;
5047: LD_VAR 0 1
5051: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5052: LD_EXP 31
5056: PUSH
5057: LD_EXP 56
5061: AND
5062: IFFALSE 5236
5064: GO 5066
5066: DISABLE
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin wait ( 0 0$50 ) ;
5072: LD_INT 1750
5074: PPUSH
5075: CALL_OW 67
// tmp := ru_vehicles ;
5079: LD_ADDR_VAR 0 3
5083: PUSH
5084: LD_EXP 56
5088: ST_TO_ADDR
// if not tmp then
5089: LD_VAR 0 3
5093: NOT
5094: IFFALSE 5098
// exit ;
5096: GO 5236
// repeat wait ( 0 0$1 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// for i in tmp do
5105: LD_ADDR_VAR 0 1
5109: PUSH
5110: LD_VAR 0 3
5114: PUSH
5115: FOR_IN
5116: IFFALSE 5227
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5118: LD_ADDR_VAR 0 2
5122: PUSH
5123: LD_INT 22
5125: PUSH
5126: LD_INT 1
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PPUSH
5133: LD_VAR 0 1
5137: PPUSH
5138: CALL_OW 74
5142: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5143: LD_VAR 0 1
5147: PPUSH
5148: LD_VAR 0 2
5152: PPUSH
5153: CALL_OW 296
5157: PUSH
5158: LD_INT 10
5160: GREATER
5161: IFFALSE 5180
// ComAgressiveMove ( i , 69 , 101 ) else
5163: LD_VAR 0 1
5167: PPUSH
5168: LD_INT 69
5170: PPUSH
5171: LD_INT 101
5173: PPUSH
5174: CALL_OW 114
5178: GO 5194
// ComAttackUnit ( i , enemy ) ;
5180: LD_VAR 0 1
5184: PPUSH
5185: LD_VAR 0 2
5189: PPUSH
5190: CALL_OW 115
// if GetLives ( i ) < 250 then
5194: LD_VAR 0 1
5198: PPUSH
5199: CALL_OW 256
5203: PUSH
5204: LD_INT 250
5206: LESS
5207: IFFALSE 5225
// tmp := tmp diff i ;
5209: LD_ADDR_VAR 0 3
5213: PUSH
5214: LD_VAR 0 3
5218: PUSH
5219: LD_VAR 0 1
5223: DIFF
5224: ST_TO_ADDR
// end ;
5225: GO 5115
5227: POP
5228: POP
// until not tmp ;
5229: LD_VAR 0 3
5233: NOT
5234: IFFALSE 5098
// end ; end_of_file
5236: PPOPN 3
5238: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5239: LD_INT 0
5241: PPUSH
5242: PPUSH
5243: PPUSH
5244: PPUSH
5245: PPUSH
5246: PPUSH
5247: PPUSH
// InGameOn ;
5248: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5252: LD_EXP 37
5256: PPUSH
5257: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5261: LD_EXP 37
5265: PPUSH
5266: LD_EXP 44
5270: PPUSH
5271: CALL_OW 119
// if Bierezov then
5275: LD_EXP 45
5279: IFFALSE 5295
// ComTurnUnit ( Bierezov , Cornel ) ;
5281: LD_EXP 45
5285: PPUSH
5286: LD_EXP 44
5290: PPUSH
5291: CALL_OW 119
// for i in jmm_units do
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: LD_EXP 4
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5324
// ComTurnUnit ( i , Cornel ) ;
5308: LD_VAR 0 2
5312: PPUSH
5313: LD_EXP 44
5317: PPUSH
5318: CALL_OW 119
5322: GO 5305
5324: POP
5325: POP
// units := cornel_units union Cornel ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_EXP 6
5335: PUSH
5336: LD_EXP 44
5340: UNION
5341: ST_TO_ADDR
// repeat wait ( 1 ) ;
5342: LD_INT 1
5344: PPUSH
5345: CALL_OW 67
// for i in units do
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: LD_VAR 0 3
5358: PUSH
5359: FOR_IN
5360: IFFALSE 5393
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5362: LD_VAR 0 2
5366: PPUSH
5367: LD_EXP 37
5371: PPUSH
5372: CALL_OW 250
5376: PPUSH
5377: LD_EXP 37
5381: PPUSH
5382: CALL_OW 251
5386: PPUSH
5387: CALL_OW 111
5391: GO 5359
5393: POP
5394: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5395: LD_VAR 0 3
5399: PPUSH
5400: LD_INT 92
5402: PUSH
5403: LD_EXP 37
5407: PPUSH
5408: CALL_OW 250
5412: PUSH
5413: LD_EXP 37
5417: PPUSH
5418: CALL_OW 251
5422: PUSH
5423: LD_INT 10
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: PPUSH
5432: CALL_OW 72
5436: PUSH
5437: LD_VAR 0 3
5441: EQUAL
5442: IFFALSE 5342
// for i in units do
5444: LD_ADDR_VAR 0 2
5448: PUSH
5449: LD_VAR 0 3
5453: PUSH
5454: FOR_IN
5455: IFFALSE 5473
// ComTurnUnit ( i , JMM ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_EXP 37
5466: PPUSH
5467: CALL_OW 119
5471: GO 5454
5473: POP
5474: POP
// ComTurnUnit ( Cornel , JMM ) ;
5475: LD_EXP 44
5479: PPUSH
5480: LD_EXP 37
5484: PPUSH
5485: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5489: LD_EXP 37
5493: PPUSH
5494: LD_STRING D1-JMM-1
5496: PPUSH
5497: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5501: LD_EXP 44
5505: PPUSH
5506: LD_STRING D1-Corn-1
5508: PPUSH
5509: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5513: LD_EXP 37
5517: PPUSH
5518: LD_EXP 44
5522: PPUSH
5523: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5527: LD_EXP 44
5531: PPUSH
5532: LD_EXP 37
5536: PPUSH
5537: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5541: LD_INT 35
5543: PPUSH
5544: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5548: LD_EXP 37
5552: PPUSH
5553: LD_EXP 44
5557: PPUSH
5558: CALL_OW 296
5562: PUSH
5563: LD_INT 6
5565: LESS
5566: IFFALSE 5541
// ChangeSideFog ( 4 , 1 ) ;
5568: LD_INT 4
5570: PPUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5578: LD_EXP 37
5582: PPUSH
5583: LD_EXP 44
5587: PPUSH
5588: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5592: LD_EXP 44
5596: PPUSH
5597: LD_EXP 37
5601: PPUSH
5602: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5606: LD_EXP 37
5610: PPUSH
5611: LD_STRING D1-JMM-2
5613: PPUSH
5614: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5618: LD_EXP 37
5622: PPUSH
5623: LD_STRING D1-JMM-2a
5625: PPUSH
5626: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5630: LD_EXP 44
5634: PPUSH
5635: LD_STRING D1-Corn-2
5637: PPUSH
5638: CALL_OW 88
// if bierezov_exist or debug then
5642: LD_EXP 7
5646: PUSH
5647: LD_EXP 1
5651: OR
5652: IFFALSE 5893
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5654: LD_EXP 44
5658: PPUSH
5659: LD_EXP 45
5663: PPUSH
5664: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5668: LD_INT 10
5670: PPUSH
5671: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5675: LD_EXP 44
5679: PPUSH
5680: LD_STRING D1a-Corn-1
5682: PPUSH
5683: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5687: LD_EXP 37
5691: PPUSH
5692: LD_EXP 45
5696: PPUSH
5697: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5701: LD_EXP 45
5705: PPUSH
5706: LD_EXP 37
5710: PPUSH
5711: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5715: LD_EXP 37
5719: PPUSH
5720: LD_STRING D1a-JMM-1
5722: PPUSH
5723: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5727: LD_EXP 37
5731: PPUSH
5732: LD_EXP 44
5736: PPUSH
5737: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5741: LD_EXP 44
5745: PPUSH
5746: LD_EXP 37
5750: PPUSH
5751: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5755: LD_EXP 44
5759: PPUSH
5760: LD_STRING D1a-Corn-2
5762: PPUSH
5763: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5767: LD_EXP 37
5771: PPUSH
5772: LD_STRING D1a-JMM-2
5774: PPUSH
5775: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5779: LD_EXP 44
5783: PPUSH
5784: LD_STRING D1a-Corn-3
5786: PPUSH
5787: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5791: LD_EXP 37
5795: PPUSH
5796: LD_STRING D1a-JMM-3
5798: PPUSH
5799: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5803: LD_EXP 44
5807: PPUSH
5808: LD_STRING D1a-Corn-4
5810: PPUSH
5811: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5815: LD_EXP 37
5819: PPUSH
5820: LD_STRING D1a-JMM-4
5822: PPUSH
5823: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5827: LD_EXP 44
5831: PPUSH
5832: LD_STRING D1a-Corn-5
5834: PPUSH
5835: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5839: LD_EXP 45
5843: PPUSH
5844: LD_EXP 44
5848: PPUSH
5849: CALL_OW 250
5853: PPUSH
5854: LD_EXP 44
5858: PPUSH
5859: CALL_OW 251
5863: PUSH
5864: LD_INT 2
5866: MINUS
5867: PPUSH
5868: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5872: LD_EXP 45
5876: PPUSH
5877: LD_EXP 44
5881: PPUSH
5882: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5886: LD_INT 10
5888: PPUSH
5889: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5893: LD_EXP 37
5897: PPUSH
5898: LD_STRING D1b-JMM-1
5900: PPUSH
5901: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5905: LD_EXP 44
5909: PPUSH
5910: LD_STRING D1b-Corn-1
5912: PPUSH
5913: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5917: LD_EXP 37
5921: PPUSH
5922: LD_STRING D1b-JMM-2
5924: PPUSH
5925: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5929: LD_EXP 44
5933: PPUSH
5934: LD_STRING D1b-Corn-2
5936: PPUSH
5937: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5941: LD_EXP 37
5945: PPUSH
5946: LD_STRING D1b-JMM-3
5948: PPUSH
5949: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5953: LD_INT 10
5955: PPUSH
5956: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5960: LD_EXP 46
5964: PPUSH
5965: LD_STRING D1b-Pow-3
5967: PPUSH
5968: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5972: LD_EXP 37
5976: PPUSH
5977: LD_STRING D1b-JMM-4
5979: PPUSH
5980: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5984: LD_EXP 44
5988: PPUSH
5989: LD_STRING D1b-Corn-4
5991: PPUSH
5992: CALL_OW 88
// if Khatam then
5996: LD_EXP 41
6000: IFFALSE 6016
// Say ( Khatam , D1b-Khat-4 ) else
6002: LD_EXP 41
6006: PPUSH
6007: LD_STRING D1b-Khat-4
6009: PPUSH
6010: CALL_OW 88
6014: GO 6052
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6016: LD_EXP 6
6020: PPUSH
6021: LD_INT 26
6023: PUSH
6024: LD_INT 1
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: PPUSH
6031: CALL_OW 72
6035: PUSH
6036: LD_EXP 44
6040: PUSH
6041: EMPTY
6042: LIST
6043: DIFF
6044: PPUSH
6045: LD_STRING D1b-Sol1-4
6047: PPUSH
6048: CALL 640 0 2
// if Cyrus then
6052: LD_EXP 39
6056: IFFALSE 6070
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6058: LD_EXP 39
6062: PPUSH
6063: LD_STRING D1b-Cyrus-4
6065: PPUSH
6066: CALL_OW 88
// if Lisa then
6070: LD_EXP 40
6074: IFFALSE 6132
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6076: LD_EXP 40
6080: PPUSH
6081: LD_STRING D1b-Lisa-4
6083: PPUSH
6084: CALL_OW 88
// if Cyrus then
6088: LD_EXP 39
6092: IFFALSE 6132
// begin if not IsInUnit ( Cyrus ) then
6094: LD_EXP 39
6098: PPUSH
6099: CALL_OW 310
6103: NOT
6104: IFFALSE 6120
// ComTurnUnit ( Cyrus , Lisa ) ;
6106: LD_EXP 39
6110: PPUSH
6111: LD_EXP 40
6115: PPUSH
6116: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6120: LD_EXP 39
6124: PPUSH
6125: LD_STRING D1b-Cyrus-5
6127: PPUSH
6128: CALL_OW 88
// end ; end ; SelectGroup ;
6132: CALL 2621 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6136: LD_EXP 37
6140: PPUSH
6141: LD_STRING D1d-JMM-1
6143: PPUSH
6144: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6148: LD_EXP 44
6152: PPUSH
6153: LD_STRING D1d-Corn-1
6155: PPUSH
6156: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_EXP 4
6169: PUSH
6170: LD_EXP 6
6174: ADD
6175: PUSH
6176: LD_EXP 37
6180: ADD
6181: PUSH
6182: FOR_IN
6183: IFFALSE 6196
// ComHold ( i ) ;
6185: LD_VAR 0 2
6189: PPUSH
6190: CALL_OW 140
6194: GO 6182
6196: POP
6197: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6198: LD_ADDR_VAR 0 4
6202: PUSH
6203: LD_INT 22
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 21
6215: PUSH
6216: LD_INT 2
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PPUSH
6227: CALL_OW 69
6231: ST_TO_ADDR
// if vehicles then
6232: LD_VAR 0 4
6236: IFFALSE 6574
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6238: LD_EXP 6
6242: PPUSH
6243: LD_INT 55
6245: PUSH
6246: EMPTY
6247: LIST
6248: PPUSH
6249: CALL_OW 72
6253: IFFALSE 6292
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6255: LD_ADDR_VAR 0 2
6259: PUSH
6260: LD_EXP 6
6264: PPUSH
6265: LD_INT 55
6267: PUSH
6268: EMPTY
6269: LIST
6270: PPUSH
6271: CALL_OW 72
6275: PUSH
6276: FOR_IN
6277: IFFALSE 6290
// ComExitVehicle ( i ) ;
6279: LD_VAR 0 2
6283: PPUSH
6284: CALL_OW 121
6288: GO 6276
6290: POP
6291: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6292: LD_ADDR_VAR 0 5
6296: PUSH
6297: LD_VAR 0 4
6301: PPUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 51
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL_OW 72
6316: ST_TO_ADDR
// if cargos then
6317: LD_VAR 0 5
6321: IFFALSE 6504
// begin vehicles := cargos ;
6323: LD_ADDR_VAR 0 4
6327: PUSH
6328: LD_VAR 0 5
6332: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6333: LD_ADDR_VAR 0 6
6337: PUSH
6338: LD_STRING 02_resources_4
6340: PPUSH
6341: LD_INT 0
6343: PPUSH
6344: CALL_OW 30
6348: ST_TO_ADDR
// if debug and not resources then
6349: LD_EXP 1
6353: PUSH
6354: LD_VAR 0 6
6358: NOT
6359: AND
6360: IFFALSE 6370
// resources := 160 ;
6362: LD_ADDR_VAR 0 6
6366: PUSH
6367: LD_INT 160
6369: ST_TO_ADDR
// if resources mod 10 then
6370: LD_VAR 0 6
6374: PUSH
6375: LD_INT 10
6377: MOD
6378: IFFALSE 6400
// resources := resources - resources mod 10 ;
6380: LD_ADDR_VAR 0 6
6384: PUSH
6385: LD_VAR 0 6
6389: PUSH
6390: LD_VAR 0 6
6394: PUSH
6395: LD_INT 10
6397: MOD
6398: MINUS
6399: ST_TO_ADDR
// if resources then
6400: LD_VAR 0 6
6404: IFFALSE 6504
// for i in cargos do
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 5
6415: PUSH
6416: FOR_IN
6417: IFFALSE 6502
// begin if resources < 100 then
6419: LD_VAR 0 6
6423: PUSH
6424: LD_INT 100
6426: LESS
6427: IFFALSE 6449
// begin cargo := resources ;
6429: LD_ADDR_VAR 0 7
6433: PUSH
6434: LD_VAR 0 6
6438: ST_TO_ADDR
// resources := 0 ;
6439: LD_ADDR_VAR 0 6
6443: PUSH
6444: LD_INT 0
6446: ST_TO_ADDR
// end else
6447: GO 6471
// begin cargo := 100 ;
6449: LD_ADDR_VAR 0 7
6453: PUSH
6454: LD_INT 100
6456: ST_TO_ADDR
// resources := resources - 100 ;
6457: LD_ADDR_VAR 0 6
6461: PUSH
6462: LD_VAR 0 6
6466: PUSH
6467: LD_INT 100
6469: MINUS
6470: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6471: LD_VAR 0 2
6475: PPUSH
6476: LD_INT 1
6478: PPUSH
6479: LD_VAR 0 7
6483: PPUSH
6484: CALL_OW 290
// if resources = 0 then
6488: LD_VAR 0 6
6492: PUSH
6493: LD_INT 0
6495: EQUAL
6496: IFFALSE 6500
// break ;
6498: GO 6502
// end ;
6500: GO 6416
6502: POP
6503: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6504: LD_VAR 0 4
6508: PUSH
6509: LD_INT 1
6511: ARRAY
6512: PPUSH
6513: CALL_OW 311
6517: PPUSH
6518: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 1
6529: ARRAY
6530: PPUSH
6531: LD_INT 4
6533: PPUSH
6534: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6538: LD_EXP 44
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6556: LD_INT 35
6558: PPUSH
6559: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6563: LD_EXP 44
6567: PPUSH
6568: CALL_OW 310
6572: IFFALSE 6556
// end ; InGameOff ;
6574: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6578: LD_STRING M1
6580: PPUSH
6581: CALL_OW 337
// SaveForQuickRestart ;
6585: CALL_OW 22
// cornel_active := true ;
6589: LD_ADDR_EXP 8
6593: PUSH
6594: LD_INT 1
6596: ST_TO_ADDR
// end ;
6597: LD_VAR 0 1
6601: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6602: LD_EXP 37
6606: PPUSH
6607: LD_EXP 47
6611: PPUSH
6612: CALL_OW 296
6616: PUSH
6617: LD_INT 10
6619: LESS
6620: IFFALSE 8003
6622: GO 6624
6624: DISABLE
6625: LD_INT 0
6627: PPUSH
6628: PPUSH
6629: PPUSH
6630: PPUSH
6631: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6632: LD_ADDR_VAR 0 2
6636: PUSH
6637: LD_INT 89
6639: PUSH
6640: LD_INT 34
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: LD_INT 138
6649: PUSH
6650: LD_INT 63
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 196
6659: PUSH
6660: LD_INT 84
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PUSH
6667: LD_INT 135
6669: PUSH
6670: LD_INT 52
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PUSH
6677: LD_INT 103
6679: PUSH
6680: LD_INT 39
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 58
6689: PUSH
6690: LD_INT 30
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: LD_INT 38
6699: PUSH
6700: LD_INT 51
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: ST_TO_ADDR
// Video ( true ) ;
6716: LD_INT 1
6718: PPUSH
6719: CALL 1200 0 1
// if jmm_units then
6723: LD_EXP 4
6727: IFFALSE 6803
// for i in jmm_units do
6729: LD_ADDR_VAR 0 1
6733: PUSH
6734: LD_EXP 4
6738: PUSH
6739: FOR_IN
6740: IFFALSE 6801
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_EXP 37
6751: PPUSH
6752: CALL_OW 296
6756: PUSH
6757: LD_INT 10
6759: LESS
6760: PUSH
6761: LD_VAR 0 1
6765: PPUSH
6766: CALL_OW 310
6770: NOT
6771: AND
6772: IFFALSE 6790
// ComTurnUnit ( i , JMM ) else
6774: LD_VAR 0 1
6778: PPUSH
6779: LD_EXP 37
6783: PPUSH
6784: CALL_OW 119
6788: GO 6799
// ComHold ( i ) ;
6790: LD_VAR 0 1
6794: PPUSH
6795: CALL_OW 140
// end ;
6799: GO 6739
6801: POP
6802: POP
// if IsInUnit ( JMM ) then
6803: LD_EXP 37
6807: PPUSH
6808: CALL_OW 310
6812: IFFALSE 6837
// begin ComExitVehicle ( JMM ) ;
6814: LD_EXP 37
6818: PPUSH
6819: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6823: LD_EXP 37
6827: PPUSH
6828: LD_EXP 47
6832: PPUSH
6833: CALL_OW 172
// end ; Wait ( 10 ) ;
6837: LD_INT 10
6839: PPUSH
6840: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6844: LD_EXP 37
6848: PPUSH
6849: LD_EXP 47
6853: PPUSH
6854: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6858: LD_INT 35
6860: PPUSH
6861: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6865: LD_EXP 37
6869: PPUSH
6870: LD_EXP 47
6874: PPUSH
6875: CALL_OW 296
6879: PUSH
6880: LD_INT 6
6882: LESS
6883: IFFALSE 6858
// ComTurnUnit ( JMM , Lynch ) ;
6885: LD_EXP 37
6889: PPUSH
6890: LD_EXP 47
6894: PPUSH
6895: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_EXP 47
6908: PUSH
6909: LD_EXP 48
6913: PUSH
6914: LD_EXP 49
6918: PUSH
6919: LD_EXP 50
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: LIST
6928: LIST
6929: PUSH
6930: FOR_IN
6931: IFFALSE 6949
// ComTurnUnit ( i , JMM ) ;
6933: LD_VAR 0 1
6937: PPUSH
6938: LD_EXP 37
6942: PPUSH
6943: CALL_OW 119
6947: GO 6930
6949: POP
6950: POP
// Wait ( 0 0$0.3 ) ;
6951: LD_INT 10
6953: PPUSH
6954: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6958: LD_EXP 37
6962: PPUSH
6963: LD_STRING D2-JMM-1
6965: PPUSH
6966: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6970: LD_EXP 47
6974: PPUSH
6975: LD_STRING D2-Sol1-1
6977: PPUSH
6978: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6982: LD_EXP 37
6986: PPUSH
6987: LD_STRING D2-JMM-2
6989: PPUSH
6990: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6994: LD_EXP 47
6998: PPUSH
6999: LD_STRING D2-Sol1-2
7001: PPUSH
7002: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7006: LD_EXP 37
7010: PPUSH
7011: LD_STRING D2-JMM-3
7013: PPUSH
7014: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7018: LD_EXP 47
7022: PPUSH
7023: LD_STRING D2-Sol1-3
7025: PPUSH
7026: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7030: LD_ADDR_VAR 0 1
7034: PUSH
7035: LD_INT 22
7037: PUSH
7038: LD_INT 8
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: FOR_IN
7051: IFFALSE 7067
// SetSide ( i , 1 ) ;
7053: LD_VAR 0 1
7057: PPUSH
7058: LD_INT 1
7060: PPUSH
7061: CALL_OW 235
7065: GO 7050
7067: POP
7068: POP
// Say ( JMM , D2-JMM-4 ) ;
7069: LD_EXP 37
7073: PPUSH
7074: LD_STRING D2-JMM-4
7076: PPUSH
7077: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 5
7086: PPUSH
7087: CALL_OW 332
// for i = 1 to points do
7091: LD_ADDR_VAR 0 1
7095: PUSH
7096: DOUBLE
7097: LD_INT 1
7099: DEC
7100: ST_TO_ADDR
7101: LD_VAR 0 2
7105: PUSH
7106: FOR_TO
7107: IFFALSE 7282
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_VAR 0 2
7128: PUSH
7129: LD_VAR 0 1
7133: ARRAY
7134: PUSH
7135: LD_INT 2
7137: ARRAY
7138: PPUSH
7139: CALL_OW 84
// if i = 1 then
7143: LD_VAR 0 1
7147: PUSH
7148: LD_INT 1
7150: EQUAL
7151: IFFALSE 7165
// Say ( Lynch , D2-Sol1-4 ) ;
7153: LD_EXP 47
7157: PPUSH
7158: LD_STRING D2-Sol1-4
7160: PPUSH
7161: CALL_OW 88
// if i = 2 then
7165: LD_VAR 0 1
7169: PUSH
7170: LD_INT 2
7172: EQUAL
7173: IFFALSE 7187
// Say ( JMM , D2-JMM-5 ) ;
7175: LD_EXP 37
7179: PPUSH
7180: LD_STRING D2-JMM-5
7182: PPUSH
7183: CALL_OW 88
// if i = 4 then
7187: LD_VAR 0 1
7191: PUSH
7192: LD_INT 4
7194: EQUAL
7195: IFFALSE 7219
// begin RevealFogArea ( 1 , troopsArea ) ;
7197: LD_INT 1
7199: PPUSH
7200: LD_INT 6
7202: PPUSH
7203: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7207: LD_EXP 47
7211: PPUSH
7212: LD_STRING D2-Sol1-5
7214: PPUSH
7215: CALL_OW 88
// end ; if i = 5 then
7219: LD_VAR 0 1
7223: PUSH
7224: LD_INT 5
7226: EQUAL
7227: IFFALSE 7241
// Say ( JMM , D2-JMM-6 ) ;
7229: LD_EXP 37
7233: PPUSH
7234: LD_STRING D2-JMM-6
7236: PPUSH
7237: CALL_OW 88
// if i = 7 then
7241: LD_VAR 0 1
7245: PUSH
7246: LD_INT 7
7248: EQUAL
7249: IFFALSE 7273
// begin RevealFogArea ( 1 , forestArea ) ;
7251: LD_INT 1
7253: PPUSH
7254: LD_INT 7
7256: PPUSH
7257: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7261: LD_EXP 47
7265: PPUSH
7266: LD_STRING D2-Sol1-6
7268: PPUSH
7269: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7273: LD_INT 46
7275: PPUSH
7276: CALL_OW 67
// end ;
7280: GO 7106
7282: POP
7283: POP
// CenterNowOnUnits ( JMM ) ;
7284: LD_EXP 37
7288: PPUSH
7289: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7293: LD_EXP 37
7297: PPUSH
7298: LD_STRING D2-JMM-7
7300: PPUSH
7301: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7305: LD_EXP 47
7309: PPUSH
7310: LD_STRING D2-Sol1-7
7312: PPUSH
7313: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7317: LD_EXP 37
7321: PPUSH
7322: LD_STRING D2-JMM-8
7324: PPUSH
7325: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7329: LD_ADDR_VAR 0 4
7333: PUSH
7334: LD_INT 22
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 30
7346: PUSH
7347: LD_INT 31
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL_OW 69
7362: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7363: LD_EXP 47
7367: PPUSH
7368: LD_VAR 0 4
7372: PUSH
7373: LD_INT 1
7375: ARRAY
7376: PPUSH
7377: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7381: LD_INT 65
7383: PPUSH
7384: LD_INT 101
7386: PPUSH
7387: CALL_OW 428
7391: IFFALSE 7414
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7393: LD_INT 65
7395: PPUSH
7396: LD_INT 101
7398: PPUSH
7399: CALL_OW 428
7403: PPUSH
7404: LD_INT 75
7406: PPUSH
7407: LD_INT 100
7409: PPUSH
7410: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7414: LD_INT 66
7416: PPUSH
7417: LD_INT 103
7419: PPUSH
7420: CALL_OW 428
7424: IFFALSE 7447
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7426: LD_INT 66
7428: PPUSH
7429: LD_INT 103
7431: PPUSH
7432: CALL_OW 428
7436: PPUSH
7437: LD_INT 75
7439: PPUSH
7440: LD_INT 100
7442: PPUSH
7443: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7447: LD_ADDR_VAR 0 5
7451: PUSH
7452: LD_INT 22
7454: PUSH
7455: LD_INT 1
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: PUSH
7462: LD_INT 21
7464: PUSH
7465: LD_INT 2
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 91
7474: PUSH
7475: LD_EXP 37
7479: PUSH
7480: LD_INT 7
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 69
7497: ST_TO_ADDR
// if tmp then
7498: LD_VAR 0 5
7502: IFFALSE 7519
// ComMoveXY ( tmp , 75 , 100 ) ;
7504: LD_VAR 0 5
7508: PPUSH
7509: LD_INT 75
7511: PPUSH
7512: LD_INT 100
7514: PPUSH
7515: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: LD_EXP 4
7528: PPUSH
7529: LD_INT 25
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PPUSH
7539: CALL_OW 72
7543: PPUSH
7544: LD_EXP 37
7548: PPUSH
7549: CALL_OW 74
7553: ST_TO_ADDR
// if sol then
7554: LD_VAR 0 3
7558: IFFALSE 7618
// if GetDistUnits ( JMM , sol ) < 10 then
7560: LD_EXP 37
7564: PPUSH
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 296
7574: PUSH
7575: LD_INT 10
7577: LESS
7578: IFFALSE 7618
// begin if IsInUnit ( sol ) then
7580: LD_VAR 0 3
7584: PPUSH
7585: CALL_OW 310
7589: IFFALSE 7600
// ComExitVehicle ( sol ) ;
7591: LD_VAR 0 3
7595: PPUSH
7596: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7600: LD_VAR 0 3
7604: PPUSH
7605: LD_VAR 0 4
7609: PUSH
7610: LD_INT 2
7612: ARRAY
7613: PPUSH
7614: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7618: LD_INT 10
7620: PPUSH
7621: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7625: LD_EXP 37
7629: PPUSH
7630: LD_INT 65
7632: PPUSH
7633: LD_INT 101
7635: PPUSH
7636: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7640: LD_EXP 37
7644: PPUSH
7645: LD_INT 63
7647: PPUSH
7648: LD_INT 100
7650: PPUSH
7651: CALL_OW 178
// tmp := 0 0$0 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_INT 0
7662: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7670: LD_ADDR_VAR 0 5
7674: PUSH
7675: LD_VAR 0 5
7679: PUSH
7680: LD_INT 35
7682: PLUS
7683: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7684: LD_EXP 37
7688: PPUSH
7689: LD_INT 65
7691: PPUSH
7692: LD_INT 101
7694: PPUSH
7695: CALL_OW 307
7699: PUSH
7700: LD_VAR 0 5
7704: PUSH
7705: LD_INT 175
7707: GREATER
7708: OR
7709: IFFALSE 7663
// Say ( JMM , D2a-JMM-1 ) ;
7711: LD_EXP 37
7715: PPUSH
7716: LD_STRING D2a-JMM-1
7718: PPUSH
7719: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7723: LD_EXP 48
7727: PPUSH
7728: LD_INT 66
7730: PPUSH
7731: LD_INT 103
7733: PPUSH
7734: CALL_OW 111
// tmp := 0 0$0 ;
7738: LD_ADDR_VAR 0 5
7742: PUSH
7743: LD_INT 0
7745: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7746: LD_INT 35
7748: PPUSH
7749: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7753: LD_EXP 48
7757: PPUSH
7758: LD_INT 66
7760: PPUSH
7761: LD_INT 103
7763: PPUSH
7764: CALL_OW 307
7768: PUSH
7769: LD_VAR 0 5
7773: PUSH
7774: LD_INT 175
7776: GREATER
7777: OR
7778: IFFALSE 7746
// ComTurnUnit ( Walker , JMM ) ;
7780: LD_EXP 48
7784: PPUSH
7785: LD_EXP 37
7789: PPUSH
7790: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7794: LD_EXP 48
7798: PPUSH
7799: LD_STRING D2a-Sci1-1
7801: PPUSH
7802: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7806: LD_EXP 37
7810: PPUSH
7811: LD_EXP 48
7815: PPUSH
7816: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7820: LD_EXP 37
7824: PPUSH
7825: LD_STRING D2a-JMM-2
7827: PPUSH
7828: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7832: LD_EXP 48
7836: PPUSH
7837: LD_STRING D2a-Sci1-2
7839: PPUSH
7840: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7844: LD_EXP 37
7848: PPUSH
7849: LD_STRING D2a-JMM-3
7851: PPUSH
7852: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7856: LD_EXP 48
7860: PPUSH
7861: LD_STRING D2a-Sci1-3
7863: PPUSH
7864: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7868: LD_ADDR_EXP 4
7872: PUSH
7873: LD_EXP 4
7877: PUSH
7878: LD_EXP 47
7882: PUSH
7883: LD_EXP 48
7887: PUSH
7888: LD_EXP 49
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: LIST
7902: LIST
7903: ADD
7904: ST_TO_ADDR
// for i in jmm_units do
7905: LD_ADDR_VAR 0 1
7909: PUSH
7910: LD_EXP 4
7914: PUSH
7915: FOR_IN
7916: IFFALSE 7941
// if not IsInUnit ( i ) then
7918: LD_VAR 0 1
7922: PPUSH
7923: CALL_OW 310
7927: NOT
7928: IFFALSE 7939
// ComFree ( i ) ;
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 139
7939: GO 7915
7941: POP
7942: POP
// Video ( false ) ;
7943: LD_INT 0
7945: PPUSH
7946: CALL 1200 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7950: LD_STRING MSolar1
7952: PPUSH
7953: CALL_OW 337
// jmm_on_west := true ;
7957: LD_ADDR_EXP 5
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7965: LD_INT 1050
7967: PPUSH
7968: CALL_OW 67
// frank_can_return := true ;
7972: LD_ADDR_EXP 12
7976: PUSH
7977: LD_INT 1
7979: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7980: LD_INT 6300
7982: PPUSH
7983: LD_INT 8400
7985: PPUSH
7986: CALL_OW 12
7990: PPUSH
7991: CALL_OW 67
// send_spec_patrol := true ;
7995: LD_ADDR_EXP 30
7999: PUSH
8000: LD_INT 1
8002: ST_TO_ADDR
// end ;
8003: PPOPN 5
8005: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
8006: LD_INT 22
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 34
8018: PUSH
8019: LD_INT 51
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 92
8028: PUSH
8029: LD_INT 63
8031: PUSH
8032: LD_INT 100
8034: PUSH
8035: LD_INT 5
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: PPUSH
8052: CALL_OW 69
8056: PUSH
8057: LD_EXP 5
8061: NOT
8062: AND
8063: IFFALSE 8176
8065: GO 8067
8067: DISABLE
8068: LD_INT 0
8070: PPUSH
8071: PPUSH
// begin enable ;
8072: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8073: LD_ADDR_VAR 0 2
8077: PUSH
8078: LD_INT 22
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 34
8090: PUSH
8091: LD_INT 51
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 92
8100: PUSH
8101: LD_INT 63
8103: PUSH
8104: LD_INT 100
8106: PUSH
8107: LD_INT 5
8109: PUSH
8110: EMPTY
8111: LIST
8112: LIST
8113: LIST
8114: LIST
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: PUSH
8121: EMPTY
8122: LIST
8123: PPUSH
8124: CALL_OW 69
8128: ST_TO_ADDR
// if not filter then
8129: LD_VAR 0 2
8133: NOT
8134: IFFALSE 8138
// exit ;
8136: GO 8176
// for i in filter do
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: LD_VAR 0 2
8147: PUSH
8148: FOR_IN
8149: IFFALSE 8174
// begin SetFuel ( i , 0 ) ;
8151: LD_VAR 0 1
8155: PPUSH
8156: LD_INT 0
8158: PPUSH
8159: CALL_OW 240
// ComStop ( i ) ;
8163: LD_VAR 0 1
8167: PPUSH
8168: CALL_OW 141
// end ;
8172: GO 8148
8174: POP
8175: POP
// end ;
8176: PPOPN 2
8178: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8179: LD_EXP 30
8183: IFFALSE 9176
8185: GO 8187
8187: DISABLE
8188: LD_INT 0
8190: PPUSH
8191: PPUSH
8192: PPUSH
8193: PPUSH
8194: PPUSH
8195: PPUSH
8196: PPUSH
// begin if not ru_spec_patrol then
8197: LD_EXP 54
8201: NOT
8202: IFFALSE 8206
// exit ;
8204: GO 9176
// dead1 := false ;
8206: LD_ADDR_VAR 0 1
8210: PUSH
8211: LD_INT 0
8213: ST_TO_ADDR
// dead2 := false ;
8214: LD_ADDR_VAR 0 2
8218: PUSH
8219: LD_INT 0
8221: ST_TO_ADDR
// inarea1 := false ;
8222: LD_ADDR_VAR 0 3
8226: PUSH
8227: LD_INT 0
8229: ST_TO_ADDR
// inarea2 := false ;
8230: LD_ADDR_VAR 0 4
8234: PUSH
8235: LD_INT 0
8237: ST_TO_ADDR
// tmp := [ ] ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: EMPTY
8244: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8245: LD_EXP 54
8249: PPUSH
8250: LD_INT 75
8252: PPUSH
8253: LD_INT 101
8255: PPUSH
8256: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8260: LD_INT 35
8262: PPUSH
8263: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8267: LD_INT 1
8269: PPUSH
8270: LD_EXP 54
8274: PUSH
8275: LD_INT 1
8277: ARRAY
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8260
// ComStop ( ru_spec_patrol ) ;
8285: LD_EXP 54
8289: PPUSH
8290: CALL_OW 141
// Wait ( 0 0$02 ) ;
8294: LD_INT 70
8296: PPUSH
8297: CALL_OW 67
// DialogueOn ;
8301: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8305: LD_EXP 54
8309: PUSH
8310: LD_INT 1
8312: ARRAY
8313: PPUSH
8314: LD_STRING D8-Rus1-1
8316: PPUSH
8317: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8321: LD_EXP 37
8325: PPUSH
8326: LD_STRING D8-JMM-1
8328: PPUSH
8329: CALL_OW 88
// DialogueOff ;
8333: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8337: LD_EXP 54
8341: PPUSH
8342: LD_INT 13
8344: PPUSH
8345: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8349: LD_INT 35
8351: PPUSH
8352: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8356: LD_VAR 0 1
8360: NOT
8361: PUSH
8362: LD_EXP 54
8366: PUSH
8367: LD_INT 1
8369: ARRAY
8370: PPUSH
8371: CALL_OW 301
8375: AND
8376: IFFALSE 8386
// dead1 := true ;
8378: LD_ADDR_VAR 0 1
8382: PUSH
8383: LD_INT 1
8385: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8386: LD_VAR 0 2
8390: NOT
8391: PUSH
8392: LD_EXP 54
8396: PUSH
8397: LD_INT 2
8399: ARRAY
8400: PPUSH
8401: CALL_OW 301
8405: AND
8406: IFFALSE 8416
// dead2 := true ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_INT 1
8415: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8416: LD_VAR 0 3
8420: NOT
8421: PUSH
8422: LD_EXP 54
8426: PUSH
8427: LD_INT 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 14
8433: PPUSH
8434: CALL_OW 308
8438: AND
8439: IFFALSE 8449
// inarea1 := true ;
8441: LD_ADDR_VAR 0 3
8445: PUSH
8446: LD_INT 1
8448: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8449: LD_VAR 0 4
8453: NOT
8454: PUSH
8455: LD_EXP 54
8459: PUSH
8460: LD_INT 2
8462: ARRAY
8463: PPUSH
8464: LD_INT 14
8466: PPUSH
8467: CALL_OW 308
8471: AND
8472: IFFALSE 8482
// inarea2 := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8482: LD_VAR 0 1
8486: PUSH
8487: LD_VAR 0 2
8491: AND
8492: PUSH
8493: LD_VAR 0 1
8497: PUSH
8498: LD_VAR 0 4
8502: AND
8503: OR
8504: PUSH
8505: LD_VAR 0 2
8509: PUSH
8510: LD_VAR 0 3
8514: AND
8515: OR
8516: PUSH
8517: LD_VAR 0 3
8521: PUSH
8522: LD_VAR 0 4
8526: AND
8527: OR
8528: IFFALSE 8349
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8530: LD_VAR 0 3
8534: PUSH
8535: LD_VAR 0 4
8539: AND
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_VAR 0 4
8550: AND
8551: OR
8552: PUSH
8553: LD_VAR 0 2
8557: PUSH
8558: LD_VAR 0 3
8562: AND
8563: OR
8564: IFFALSE 9156
// begin prepare_siege := true ;
8566: LD_ADDR_EXP 31
8570: PUSH
8571: LD_INT 1
8573: ST_TO_ADDR
// DialogueOn ;
8574: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8578: LD_VAR 0 3
8582: PUSH
8583: LD_VAR 0 4
8587: AND
8588: IFFALSE 8604
// Say ( JMM , D8b-JMM-1a ) else
8590: LD_EXP 37
8594: PPUSH
8595: LD_STRING D8b-JMM-1a
8597: PPUSH
8598: CALL_OW 88
8602: GO 8616
// Say ( JMM , D8b-JMM-1 ) ;
8604: LD_EXP 37
8608: PPUSH
8609: LD_STRING D8b-JMM-1
8611: PPUSH
8612: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8616: LD_EXP 4
8620: PPUSH
8621: LD_INT 26
8623: PUSH
8624: LD_INT 1
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PPUSH
8631: CALL_OW 72
8635: PUSH
8636: LD_EXP 38
8640: PUSH
8641: LD_EXP 39
8645: PUSH
8646: LD_EXP 48
8650: PUSH
8651: LD_EXP 51
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: DIFF
8662: PPUSH
8663: LD_STRING D8b-Sol1-1
8665: PPUSH
8666: CALL 640 0 2
// if Cyrus and Cyrus in jmm_units then
8670: LD_EXP 39
8674: PUSH
8675: LD_EXP 39
8679: PUSH
8680: LD_EXP 4
8684: IN
8685: AND
8686: IFFALSE 8702
// Say ( Cyrus , D8b-Cyrus-1 ) else
8688: LD_EXP 39
8692: PPUSH
8693: LD_STRING D8b-Cyrus-1
8695: PPUSH
8696: CALL_OW 88
8700: GO 8714
// Say ( JMM , D8b-JMM-1a ) ;
8702: LD_EXP 37
8706: PPUSH
8707: LD_STRING D8b-JMM-1a
8709: PPUSH
8710: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8714: LD_EXP 40
8718: PUSH
8719: LD_EXP 40
8723: PUSH
8724: LD_EXP 4
8728: IN
8729: AND
8730: IFFALSE 8744
// Say ( Lisa , D8b-Lisa-2 ) ;
8732: LD_EXP 40
8736: PPUSH
8737: LD_STRING D8b-Lisa-2
8739: PPUSH
8740: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8744: LD_EXP 38
8748: PUSH
8749: LD_EXP 38
8753: PUSH
8754: LD_EXP 4
8758: IN
8759: AND
8760: IFFALSE 8776
// Say ( Bobby , D8b-Bobby-1 ) else
8762: LD_EXP 38
8766: PPUSH
8767: LD_STRING D8b-Bobby-1
8769: PPUSH
8770: CALL_OW 88
8774: GO 8836
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8776: LD_ADDR_VAR 0 5
8780: PUSH
8781: LD_EXP 4
8785: PPUSH
8786: LD_INT 26
8788: PUSH
8789: LD_INT 1
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: PPUSH
8796: CALL_OW 72
8800: PUSH
8801: LD_EXP 38
8805: PUSH
8806: LD_EXP 39
8810: PUSH
8811: LD_EXP 48
8815: PUSH
8816: LD_EXP 51
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: DIFF
8827: PPUSH
8828: LD_STRING D8b-Sol2-1
8830: PPUSH
8831: CALL 640 0 2
8835: ST_TO_ADDR
// DialogueOff ;
8836: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8840: LD_EXP 39
8844: PUSH
8845: LD_EXP 39
8849: PUSH
8850: LD_EXP 4
8854: IN
8855: AND
8856: IFFALSE 8881
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8858: LD_ADDR_VAR 0 6
8862: PUSH
8863: LD_VAR 0 6
8867: PPUSH
8868: LD_INT 1
8870: PPUSH
8871: LD_EXP 39
8875: PPUSH
8876: CALL_OW 2
8880: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8881: LD_EXP 38
8885: PUSH
8886: LD_EXP 38
8890: PUSH
8891: LD_EXP 4
8895: IN
8896: AND
8897: IFFALSE 8922
// tmp := Insert ( tmp , 1 , Bobby ) ;
8899: LD_ADDR_VAR 0 6
8903: PUSH
8904: LD_VAR 0 6
8908: PPUSH
8909: LD_INT 1
8911: PPUSH
8912: LD_EXP 38
8916: PPUSH
8917: CALL_OW 2
8921: ST_TO_ADDR
// if sol then
8922: LD_VAR 0 5
8926: IFFALSE 8951
// tmp := Insert ( tmp , 1 , sol ) ;
8928: LD_ADDR_VAR 0 6
8932: PUSH
8933: LD_VAR 0 6
8937: PPUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_VAR 0 5
8945: PPUSH
8946: CALL_OW 2
8950: ST_TO_ADDR
// if tmp then
8951: LD_VAR 0 6
8955: IFFALSE 9115
// begin SetSide ( tmp , 8 ) ;
8957: LD_VAR 0 6
8961: PPUSH
8962: LD_INT 8
8964: PPUSH
8965: CALL_OW 235
// ComFree ( tmp ) ;
8969: LD_VAR 0 6
8973: PPUSH
8974: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8978: LD_VAR 0 6
8982: PPUSH
8983: LD_INT 15
8985: PPUSH
8986: CALL_OW 173
// AddComHold ( tmp ) ;
8990: LD_VAR 0 6
8994: PPUSH
8995: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8999: LD_INT 35
9001: PPUSH
9002: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
9006: LD_VAR 0 6
9010: PUSH
9011: LD_INT 1
9013: ARRAY
9014: PPUSH
9015: CALL_OW 314
9019: NOT
9020: IFFALSE 9034
// ComMoveToArea ( tmp , cyrusEscape ) ;
9022: LD_VAR 0 6
9026: PPUSH
9027: LD_INT 15
9029: PPUSH
9030: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9034: LD_VAR 0 6
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 15
9045: PPUSH
9046: CALL_OW 308
9050: IFFALSE 9105
// begin RemoveUnit ( tmp [ 1 ] ) ;
9052: LD_VAR 0 6
9056: PUSH
9057: LD_INT 1
9059: ARRAY
9060: PPUSH
9061: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9065: LD_ADDR_EXP 4
9069: PUSH
9070: LD_EXP 4
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_INT 1
9082: ARRAY
9083: DIFF
9084: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9085: LD_ADDR_VAR 0 6
9089: PUSH
9090: LD_VAR 0 6
9094: PUSH
9095: LD_VAR 0 6
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: DIFF
9104: ST_TO_ADDR
// end ; until tmp = 0 ;
9105: LD_VAR 0 6
9109: PUSH
9110: LD_INT 0
9112: EQUAL
9113: IFFALSE 8999
// end ; Wait ( 0 0$30 ) ;
9115: LD_INT 1050
9117: PPUSH
9118: CALL_OW 67
// if ru_spec_patrol then
9122: LD_EXP 54
9126: IFFALSE 9154
// for i in ru_spec_patrol do
9128: LD_ADDR_VAR 0 7
9132: PUSH
9133: LD_EXP 54
9137: PUSH
9138: FOR_IN
9139: IFFALSE 9152
// RemoveUnit ( i ) ;
9141: LD_VAR 0 7
9145: PPUSH
9146: CALL_OW 64
9150: GO 9138
9152: POP
9153: POP
// end else
9154: GO 9176
// begin prepare_siege := false ;
9156: LD_ADDR_EXP 31
9160: PUSH
9161: LD_INT 0
9163: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9164: LD_EXP 37
9168: PPUSH
9169: LD_STRING D8a-JMM-1
9171: PPUSH
9172: CALL_OW 88
// end ; end ;
9176: PPOPN 7
9178: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9179: LD_EXP 12
9183: IFFALSE 10400
9185: GO 9187
9187: DISABLE
9188: LD_INT 0
9190: PPUSH
9191: PPUSH
9192: PPUSH
// begin uc_side := 8 ;
9193: LD_ADDR_OWVAR 20
9197: PUSH
9198: LD_INT 8
9200: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9201: LD_ADDR_VAR 0 3
9205: PUSH
9206: LD_INT 59
9208: PUSH
9209: LD_INT 71
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: PUSH
9216: LD_INT 122
9218: PUSH
9219: LD_INT 117
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9230: LD_ADDR_EXP 51
9234: PUSH
9235: LD_STRING Frank
9237: PPUSH
9238: LD_INT 0
9240: PPUSH
9241: CALL 489 0 2
9245: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9246: LD_ADDR_VAR 0 1
9250: PUSH
9251: LD_INT 1
9253: PPUSH
9254: LD_INT 2
9256: PPUSH
9257: CALL_OW 12
9261: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9262: LD_EXP 51
9266: PPUSH
9267: LD_VAR 0 3
9271: PUSH
9272: LD_VAR 0 1
9276: ARRAY
9277: PUSH
9278: LD_INT 1
9280: ARRAY
9281: PPUSH
9282: LD_VAR 0 3
9286: PUSH
9287: LD_VAR 0 1
9291: ARRAY
9292: PUSH
9293: LD_INT 2
9295: ARRAY
9296: PPUSH
9297: LD_INT 0
9299: PPUSH
9300: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9304: LD_EXP 51
9308: PPUSH
9309: LD_INT 1
9311: PPUSH
9312: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9316: LD_INT 35
9318: PPUSH
9319: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9323: LD_EXP 51
9327: PPUSH
9328: LD_EXP 37
9332: PPUSH
9333: CALL_OW 296
9337: PUSH
9338: LD_INT 8
9340: LESS
9341: PUSH
9342: LD_EXP 51
9346: PPUSH
9347: CALL_OW 256
9351: PUSH
9352: LD_INT 250
9354: GREATER
9355: AND
9356: IFFALSE 9316
// Video ( true ) ;
9358: LD_INT 1
9360: PPUSH
9361: CALL 1200 0 1
// CenterOnUnits ( JMM ) ;
9365: LD_EXP 37
9369: PPUSH
9370: CALL_OW 85
// if IsInUnit ( JMM ) then
9374: LD_EXP 37
9378: PPUSH
9379: CALL_OW 310
9383: IFFALSE 9394
// ComFree ( JMM ) ;
9385: LD_EXP 37
9389: PPUSH
9390: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9394: LD_EXP 37
9398: PPUSH
9399: LD_EXP 51
9403: PPUSH
9404: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9408: LD_EXP 51
9412: PPUSH
9413: LD_EXP 37
9417: PPUSH
9418: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9422: LD_EXP 37
9426: PPUSH
9427: LD_STRING D6-JMM-1
9429: PPUSH
9430: CALL_OW 88
// p := 0 ;
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_INT 0
9441: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9442: LD_INT 35
9444: PPUSH
9445: CALL_OW 67
// p := p + 1 ;
9449: LD_ADDR_VAR 0 2
9453: PUSH
9454: LD_VAR 0 2
9458: PUSH
9459: LD_INT 1
9461: PLUS
9462: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9463: LD_EXP 37
9467: PPUSH
9468: LD_EXP 51
9472: PPUSH
9473: CALL_OW 296
9477: PUSH
9478: LD_INT 8
9480: LESS
9481: PUSH
9482: LD_VAR 0 2
9486: PUSH
9487: LD_INT 7
9489: GREATER
9490: OR
9491: IFFALSE 9442
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9493: LD_EXP 40
9497: PUSH
9498: LD_EXP 40
9502: PPUSH
9503: LD_EXP 51
9507: PPUSH
9508: CALL_OW 296
9512: PUSH
9513: LD_INT 20
9515: LESS
9516: AND
9517: IFFALSE 9542
// begin ComFree ( Lisa ) ;
9519: LD_EXP 40
9523: PPUSH
9524: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9528: LD_EXP 40
9532: PPUSH
9533: LD_EXP 51
9537: PPUSH
9538: CALL_OW 172
// end ; if Lynch then
9542: LD_EXP 47
9546: IFFALSE 9571
// begin ComFree ( Lynch ) ;
9548: LD_EXP 47
9552: PPUSH
9553: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9557: LD_EXP 47
9561: PPUSH
9562: LD_EXP 51
9566: PPUSH
9567: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9571: LD_EXP 37
9575: PPUSH
9576: LD_EXP 51
9580: PPUSH
9581: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9585: LD_EXP 51
9589: PPUSH
9590: LD_EXP 37
9594: PPUSH
9595: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9599: LD_EXP 51
9603: PPUSH
9604: LD_STRING D6-Frank-1
9606: PPUSH
9607: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9611: LD_INT 69
9613: PPUSH
9614: LD_INT 20
9616: PPUSH
9617: LD_INT 1
9619: PPUSH
9620: LD_INT 20
9622: NEG
9623: PPUSH
9624: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9628: LD_INT 69
9630: PPUSH
9631: LD_INT 20
9633: PPUSH
9634: LD_INT 1
9636: PPUSH
9637: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9641: LD_INT 190
9643: PPUSH
9644: LD_INT 31
9646: PPUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 20
9652: NEG
9653: PPUSH
9654: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9658: LD_INT 190
9660: PPUSH
9661: LD_INT 31
9663: PPUSH
9664: LD_INT 1
9666: PPUSH
9667: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9671: LD_INT 69
9673: PPUSH
9674: LD_INT 20
9676: PPUSH
9677: CALL_OW 84
// Wait ( 0 0$02 ) ;
9681: LD_INT 70
9683: PPUSH
9684: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9688: LD_EXP 37
9692: PPUSH
9693: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9697: LD_EXP 40
9701: PUSH
9702: LD_EXP 40
9706: PPUSH
9707: LD_EXP 51
9711: PPUSH
9712: CALL_OW 296
9716: PUSH
9717: LD_INT 20
9719: LESS
9720: AND
9721: PUSH
9722: LD_EXP 40
9726: PPUSH
9727: CALL_OW 302
9731: AND
9732: IFFALSE 9854
// begin ComFree ( Lisa ) ;
9734: LD_EXP 40
9738: PPUSH
9739: CALL_OW 139
// p := 0 ;
9743: LD_ADDR_VAR 0 2
9747: PUSH
9748: LD_INT 0
9750: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// p := p + 1 ;
9758: LD_ADDR_VAR 0 2
9762: PUSH
9763: LD_VAR 0 2
9767: PUSH
9768: LD_INT 1
9770: PLUS
9771: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9772: LD_EXP 40
9776: PPUSH
9777: LD_EXP 51
9781: PPUSH
9782: CALL_OW 296
9786: PUSH
9787: LD_INT 7
9789: LESS
9790: PUSH
9791: LD_VAR 0 2
9795: PUSH
9796: LD_INT 7
9798: GREATER
9799: OR
9800: IFFALSE 9751
// Say ( Lisa , D6-Lisa-1 ) ;
9802: LD_EXP 40
9806: PPUSH
9807: LD_STRING D6-Lisa-1
9809: PPUSH
9810: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9814: LD_EXP 40
9818: PPUSH
9819: LD_EXP 51
9823: PPUSH
9824: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9828: LD_EXP 51
9832: PPUSH
9833: LD_EXP 40
9837: PPUSH
9838: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9842: LD_EXP 51
9846: PPUSH
9847: LD_STRING D6-Frank-2
9849: PPUSH
9850: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9854: LD_EXP 47
9858: PUSH
9859: LD_EXP 47
9863: PPUSH
9864: LD_EXP 51
9868: PPUSH
9869: CALL_OW 296
9873: PUSH
9874: LD_INT 20
9876: LESS
9877: AND
9878: PUSH
9879: LD_EXP 47
9883: PPUSH
9884: CALL_OW 302
9888: AND
9889: IFFALSE 10070
// begin ComTurnUnit ( Lynch , JMM ) ;
9891: LD_EXP 47
9895: PPUSH
9896: LD_EXP 37
9900: PPUSH
9901: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9905: LD_EXP 51
9909: PPUSH
9910: LD_EXP 37
9914: PPUSH
9915: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9919: LD_EXP 47
9923: PPUSH
9924: LD_STRING D6-Sol1-2
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9931: LD_EXP 37
9935: PPUSH
9936: LD_STRING D6-JMM-2
9938: PPUSH
9939: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9943: LD_EXP 51
9947: PPUSH
9948: LD_STRING D6-Frank-3
9950: PPUSH
9951: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9955: LD_EXP 37
9959: PPUSH
9960: LD_STRING D6-JMM-3
9962: PPUSH
9963: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9967: LD_EXP 51
9971: PPUSH
9972: LD_STRING D6-Frank-4
9974: PPUSH
9975: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9979: LD_EXP 51
9983: PPUSH
9984: LD_STRING D6-Frank-4a
9986: PPUSH
9987: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9991: LD_EXP 37
9995: PPUSH
9996: LD_STRING D6-JMM-4
9998: PPUSH
9999: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10003: LD_EXP 51
10007: PPUSH
10008: LD_STRING D6-Frank-5
10010: PPUSH
10011: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10015: LD_EXP 40
10019: PUSH
10020: LD_EXP 40
10024: PPUSH
10025: CALL_OW 302
10029: AND
10030: IFFALSE 10044
// Say ( Lisa , D6-Lisa-5 ) ;
10032: LD_EXP 40
10036: PPUSH
10037: LD_STRING D6-Lisa-5
10039: PPUSH
10040: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10044: LD_EXP 51
10048: PPUSH
10049: LD_STRING D6-Frank-6
10051: PPUSH
10052: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10056: LD_EXP 37
10060: PPUSH
10061: LD_STRING D6-JMM-6
10063: PPUSH
10064: CALL_OW 88
// end else
10068: GO 10185
// begin ComTurnUnit ( Frank , JMM ) ;
10070: LD_EXP 51
10074: PPUSH
10075: LD_EXP 37
10079: PPUSH
10080: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10084: LD_EXP 51
10088: PPUSH
10089: LD_STRING D6-Frank-4
10091: PPUSH
10092: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10096: LD_EXP 51
10100: PPUSH
10101: LD_STRING D6-Frank-4a
10103: PPUSH
10104: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10108: LD_EXP 37
10112: PPUSH
10113: LD_STRING D6-JMM-4
10115: PPUSH
10116: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10120: LD_EXP 51
10124: PPUSH
10125: LD_STRING D6-Frank-5
10127: PPUSH
10128: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10132: LD_EXP 40
10136: PUSH
10137: LD_EXP 40
10141: PPUSH
10142: CALL_OW 302
10146: AND
10147: IFFALSE 10161
// Say ( Lisa , D6-Lisa-5 ) ;
10149: LD_EXP 40
10153: PPUSH
10154: LD_STRING D6-Lisa-5
10156: PPUSH
10157: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10161: LD_EXP 51
10165: PPUSH
10166: LD_STRING D6-Frank-6
10168: PPUSH
10169: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10173: LD_EXP 37
10177: PPUSH
10178: LD_STRING D6-JMM-6
10180: PPUSH
10181: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10185: LD_STRING Q1
10187: PPUSH
10188: CALL_OW 97
10192: PUSH
10193: LD_INT 1
10195: DOUBLE
10196: EQUAL
10197: IFTRUE 10201
10199: GO 10212
10201: POP
// frank_send_to_scout := true ; 2 :
10202: LD_ADDR_EXP 15
10206: PUSH
10207: LD_INT 1
10209: ST_TO_ADDR
10210: GO 10232
10212: LD_INT 2
10214: DOUBLE
10215: EQUAL
10216: IFTRUE 10220
10218: GO 10231
10220: POP
// frank_send_to_scout := false ; end ;
10221: LD_ADDR_EXP 15
10225: PUSH
10226: LD_INT 0
10228: ST_TO_ADDR
10229: GO 10232
10231: POP
// Video ( false ) ;
10232: LD_INT 0
10234: PPUSH
10235: CALL 1200 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10239: LD_EXP 37
10243: PUSH
10244: LD_EXP 40
10248: PUSH
10249: LD_EXP 47
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 139
// if frank_send_to_scout then
10263: LD_EXP 15
10267: IFFALSE 10321
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10269: LD_EXP 51
10273: PPUSH
10274: LD_INT 15
10276: PPUSH
10277: CALL_OW 113
// wait ( 0 0$01 ) ;
10281: LD_INT 35
10283: PPUSH
10284: CALL_OW 67
// until not See ( 1 , Frank ) ;
10288: LD_INT 1
10290: PPUSH
10291: LD_EXP 51
10295: PPUSH
10296: CALL_OW 292
10300: NOT
10301: IFFALSE 10269
// wait ( 0 0$02 ) ;
10303: LD_INT 70
10305: PPUSH
10306: CALL_OW 67
// RemoveUnit ( Frank ) ;
10310: LD_EXP 51
10314: PPUSH
10315: CALL_OW 64
// end else
10319: GO 10333
// SetSide ( Frank , 1 ) ;
10321: LD_EXP 51
10325: PPUSH
10326: LD_INT 1
10328: PPUSH
10329: CALL_OW 235
// send_attack_on_cornel_base := true ;
10333: LD_ADDR_EXP 26
10337: PUSH
10338: LD_INT 1
10340: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10341: LD_INT 35
10343: PPUSH
10344: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10348: LD_ADDR_EXP 29
10352: PUSH
10353: LD_EXP 29
10357: PPUSH
10358: LD_STRING -
10360: PPUSH
10361: CALL 1132 0 2
10365: ST_TO_ADDR
// if debug then
10366: LD_EXP 1
10370: IFFALSE 10382
// debug_strings := time_to_prepare ;
10372: LD_ADDR_OWVAR 48
10376: PUSH
10377: LD_EXP 29
10381: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10382: LD_EXP 29
10386: PUSH
10387: LD_INT 0
10389: EQUAL
10390: IFFALSE 10341
// cornel_prepared := true ;
10392: LD_ADDR_EXP 11
10396: PUSH
10397: LD_INT 1
10399: ST_TO_ADDR
// end ;
10400: PPOPN 3
10402: END
// every 0 0$01 trigger cornel_prepared do
10403: LD_EXP 11
10407: IFFALSE 10671
10409: GO 10411
10411: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10412: LD_EXP 44
10416: PPUSH
10417: LD_STRING D3-Corn-1
10419: PPUSH
10420: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10424: LD_STRING MOutWait
10426: PPUSH
10427: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10431: LD_INT 35
10433: PPUSH
10434: CALL_OW 67
// until cornel_counter = 0 ;
10438: LD_EXP 10
10442: PUSH
10443: LD_INT 0
10445: EQUAL
10446: IFFALSE 10431
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10448: LD_EXP 44
10452: PPUSH
10453: LD_STRING D3a-Corn-1
10455: PPUSH
10456: CALL_OW 94
// if IsOk ( Cornel ) then
10460: LD_EXP 44
10464: PPUSH
10465: CALL_OW 302
10469: IFFALSE 10483
// Say ( JMM , D3a-JMM-1 ) ;
10471: LD_EXP 37
10475: PPUSH
10476: LD_STRING D3a-JMM-1
10478: PPUSH
10479: CALL_OW 88
// end_mission_allowed := true ;
10483: LD_ADDR_EXP 21
10487: PUSH
10488: LD_INT 1
10490: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10491: LD_STRING M2
10493: PPUSH
10494: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10498: LD_INT 9
10500: PPUSH
10501: LD_INT 1
10503: PPUSH
10504: CALL_OW 424
// Wait ( 0 0$05 ) ;
10508: LD_INT 175
10510: PPUSH
10511: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10515: LD_EXP 44
10519: PPUSH
10520: LD_STRING D3a-Corn-2
10522: PPUSH
10523: CALL_OW 94
// cornel_attack := true ;
10527: LD_ADDR_EXP 9
10531: PUSH
10532: LD_INT 1
10534: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10535: LD_INT 105
10537: PPUSH
10538: CALL_OW 67
// AddMoreTanks ( ) ;
10542: CALL 4877 0 0
// if frank_send_to_scout then
10546: LD_EXP 15
10550: IFFALSE 10671
// begin InitHc ;
10552: CALL_OW 19
// InitUc ;
10556: CALL_OW 18
// uc_side := 8 ;
10560: LD_ADDR_OWVAR 20
10564: PUSH
10565: LD_INT 8
10567: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10568: LD_ADDR_EXP 51
10572: PUSH
10573: LD_STRING Frank
10575: PPUSH
10576: LD_INT 0
10578: PPUSH
10579: CALL 489 0 2
10583: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10584: LD_EXP 51
10588: PPUSH
10589: LD_INT 6
10591: PPUSH
10592: LD_INT 9
10594: PPUSH
10595: LD_INT 0
10597: PPUSH
10598: CALL_OW 48
// ComCrawl ( Frank ) ;
10602: LD_EXP 51
10606: PPUSH
10607: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10611: LD_INT 35
10613: PPUSH
10614: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10618: LD_EXP 37
10622: PPUSH
10623: LD_EXP 51
10627: PPUSH
10628: CALL_OW 296
10632: PUSH
10633: LD_INT 9
10635: LESS
10636: IFFALSE 10611
// SetSide ( Frank , 1 ) ;
10638: LD_EXP 51
10642: PPUSH
10643: LD_INT 1
10645: PPUSH
10646: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10650: LD_EXP 51
10654: PPUSH
10655: LD_STRING D6a-Frank-1
10657: PPUSH
10658: CALL_OW 88
// ComWalk ( Frank ) ;
10662: LD_EXP 51
10666: PPUSH
10667: CALL_OW 138
// end ; end ;
10671: END
// every 0 0$01 trigger solar_builded do
10672: LD_EXP 14
10676: IFFALSE 10780
10678: GO 10680
10680: DISABLE
// begin Wait ( 0 0$02 ) ;
10681: LD_INT 70
10683: PPUSH
10684: CALL_OW 67
// DialogueOn ;
10688: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10692: LD_EXP 37
10696: PPUSH
10697: LD_STRING D2b-JMM-1
10699: PPUSH
10700: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10704: LD_EXP 48
10708: PUSH
10709: LD_EXP 48
10713: PPUSH
10714: CALL_OW 302
10718: AND
10719: IFFALSE 10769
// begin Say ( Walker , D2b-Sci1-1 ) ;
10721: LD_EXP 48
10725: PPUSH
10726: LD_STRING D2b-Sci1-1
10728: PPUSH
10729: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10733: LD_EXP 37
10737: PPUSH
10738: LD_STRING D2b-JMM-2
10740: PPUSH
10741: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10745: LD_EXP 48
10749: PPUSH
10750: LD_STRING D2b-Sci1-2
10752: PPUSH
10753: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10757: LD_EXP 37
10761: PPUSH
10762: LD_STRING D2b-JMM-3
10764: PPUSH
10765: CALL_OW 88
// end ; DialogueOff ;
10769: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10773: LD_STRING MOutSol
10775: PPUSH
10776: CALL_OW 337
// end ;
10780: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10781: LD_EXP 14
10785: PUSH
10786: LD_EXP 37
10790: PPUSH
10791: CALL_OW 302
10795: AND
10796: PUSH
10797: LD_EXP 37
10801: PPUSH
10802: CALL 966 0 1
10806: AND
10807: PUSH
10808: LD_EXP 16
10812: NOT
10813: AND
10814: IFFALSE 10885
10816: GO 10818
10818: DISABLE
10819: LD_INT 0
10821: PPUSH
// begin jmm_in_veh := true ;
10822: LD_ADDR_EXP 16
10826: PUSH
10827: LD_INT 1
10829: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10830: LD_ADDR_VAR 0 1
10834: PUSH
10835: LD_INT 0
10837: PPUSH
10838: LD_INT 1
10840: PPUSH
10841: CALL_OW 12
10845: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10846: LD_INT 70
10848: PPUSH
10849: CALL_OW 67
// if i then
10853: LD_VAR 0 1
10857: IFFALSE 10873
// Say ( JMM , D2c-JMM-1 ) else
10859: LD_EXP 37
10863: PPUSH
10864: LD_STRING D2c-JMM-1
10866: PPUSH
10867: CALL_OW 88
10871: GO 10885
// Say ( JMM , D2c-JMM-1a ) ;
10873: LD_EXP 37
10877: PPUSH
10878: LD_STRING D2c-JMM-1a
10880: PPUSH
10881: CALL_OW 88
// end ;
10885: PPOPN 1
10887: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10888: LD_EXP 14
10892: PUSH
10893: LD_EXP 38
10897: PPUSH
10898: CALL_OW 302
10902: AND
10903: PUSH
10904: LD_EXP 38
10908: PPUSH
10909: CALL 966 0 1
10913: AND
10914: PUSH
10915: LD_EXP 17
10919: NOT
10920: AND
10921: IFFALSE 10953
10923: GO 10925
10925: DISABLE
// begin bobby_in_veh := true ;
10926: LD_ADDR_EXP 17
10930: PUSH
10931: LD_INT 1
10933: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10934: LD_INT 70
10936: PPUSH
10937: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10941: LD_EXP 38
10945: PPUSH
10946: LD_STRING D2c-Bobby-1
10948: PPUSH
10949: CALL_OW 88
10953: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10954: LD_EXP 14
10958: PUSH
10959: LD_EXP 40
10963: PPUSH
10964: CALL_OW 302
10968: AND
10969: PUSH
10970: LD_EXP 40
10974: PPUSH
10975: CALL 966 0 1
10979: AND
10980: PUSH
10981: LD_EXP 19
10985: NOT
10986: AND
10987: IFFALSE 11019
10989: GO 10991
10991: DISABLE
// begin lisa_in_veh := true ;
10992: LD_ADDR_EXP 19
10996: PUSH
10997: LD_INT 1
10999: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11000: LD_INT 70
11002: PPUSH
11003: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
11007: LD_EXP 40
11011: PPUSH
11012: LD_STRING D2c-Lisa-1
11014: PPUSH
11015: CALL_OW 88
11019: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11020: LD_EXP 14
11024: PUSH
11025: LD_EXP 39
11029: PPUSH
11030: CALL_OW 302
11034: AND
11035: PUSH
11036: LD_EXP 39
11040: PPUSH
11041: CALL 966 0 1
11045: AND
11046: PUSH
11047: LD_EXP 18
11051: NOT
11052: AND
11053: IFFALSE 11124
11055: GO 11057
11057: DISABLE
11058: LD_INT 0
11060: PPUSH
// begin cyrus_in_veh := true ;
11061: LD_ADDR_EXP 18
11065: PUSH
11066: LD_INT 1
11068: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11069: LD_ADDR_VAR 0 1
11073: PUSH
11074: LD_INT 0
11076: PPUSH
11077: LD_INT 1
11079: PPUSH
11080: CALL_OW 12
11084: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11085: LD_INT 70
11087: PPUSH
11088: CALL_OW 67
// if i then
11092: LD_VAR 0 1
11096: IFFALSE 11112
// Say ( Cyrus , D2c-Cyrus-1 ) else
11098: LD_EXP 39
11102: PPUSH
11103: LD_STRING D2c-Cyrus-1
11105: PPUSH
11106: CALL_OW 88
11110: GO 11124
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11112: LD_EXP 39
11116: PPUSH
11117: LD_STRING D2c-Cyrus-1a
11119: PPUSH
11120: CALL_OW 88
// end ;
11124: PPOPN 1
11126: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11127: LD_EXP 44
11131: PPUSH
11132: LD_INT 16
11134: PPUSH
11135: CALL_OW 308
11139: IFFALSE 11420
11141: GO 11143
11143: DISABLE
11144: LD_INT 0
11146: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11147: LD_INT 3
11149: PPUSH
11150: LD_EXP 44
11154: PPUSH
11155: CALL_OW 471
// send_attack_on_cornel := true ;
11159: LD_ADDR_EXP 32
11163: PUSH
11164: LD_INT 1
11166: ST_TO_ADDR
// if ru_vehicles then
11167: LD_EXP 56
11171: IFFALSE 11205
// for i in ru_vehicles do
11173: LD_ADDR_VAR 0 1
11177: PUSH
11178: LD_EXP 56
11182: PUSH
11183: FOR_IN
11184: IFFALSE 11203
// ComAgressiveMove ( i , 215 , 69 ) ;
11186: LD_VAR 0 1
11190: PPUSH
11191: LD_INT 215
11193: PPUSH
11194: LD_INT 69
11196: PPUSH
11197: CALL_OW 114
11201: GO 11183
11203: POP
11204: POP
// if ru_patrol then
11205: LD_EXP 53
11209: IFFALSE 11243
// for i in ru_patrol do
11211: LD_ADDR_VAR 0 1
11215: PUSH
11216: LD_EXP 53
11220: PUSH
11221: FOR_IN
11222: IFFALSE 11241
// ComAgressiveMove ( i , 215 , 69 ) ;
11224: LD_VAR 0 1
11228: PPUSH
11229: LD_INT 215
11231: PPUSH
11232: LD_INT 69
11234: PPUSH
11235: CALL_OW 114
11239: GO 11221
11241: POP
11242: POP
// if frank_send_to_scout then
11243: LD_EXP 15
11247: IFFALSE 11261
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11249: LD_EXP 51
11253: PPUSH
11254: LD_STRING D3b-Frank-1
11256: PPUSH
11257: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11261: LD_INT 105
11263: PPUSH
11264: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11268: LD_EXP 44
11272: PPUSH
11273: LD_STRING D4-Corn-1
11275: PPUSH
11276: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11280: LD_INT 35
11282: PPUSH
11283: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11287: LD_INT 22
11289: PUSH
11290: LD_INT 4
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 21
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 3
11309: PUSH
11310: LD_INT 24
11312: PUSH
11313: LD_INT 1000
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: LIST
11328: PPUSH
11329: CALL_OW 69
11333: PUSH
11334: LD_INT 6
11336: LESS
11337: IFFALSE 11280
// if Cornel then
11339: LD_EXP 44
11343: IFFALSE 11383
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11345: LD_EXP 44
11349: PPUSH
11350: LD_STRING D5-Corn-1
11352: PPUSH
11353: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11357: LD_EXP 44
11361: PPUSH
11362: LD_EXP 2
11366: PUSH
11367: LD_STRING Cornel
11369: STR
11370: PPUSH
11371: CALL_OW 38
// cornel_saved := true ;
11375: LD_ADDR_EXP 27
11379: PUSH
11380: LD_INT 1
11382: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11383: LD_INT 4
11385: PPUSH
11386: LD_INT 8
11388: PPUSH
11389: CALL_OW 343
// Wait ( 0 0$01 ) ;
11393: LD_INT 35
11395: PPUSH
11396: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11400: LD_INT 3
11402: PPUSH
11403: LD_EXP 44
11407: PPUSH
11408: CALL_OW 472
// send_attack_on_cornel := false ;
11412: LD_ADDR_EXP 32
11416: PUSH
11417: LD_INT 0
11419: ST_TO_ADDR
// end ;
11420: PPOPN 1
11422: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11423: LD_INT 9
11425: PPUSH
11426: LD_INT 22
11428: PUSH
11429: LD_INT 1
11431: PUSH
11432: EMPTY
11433: LIST
11434: LIST
11435: PPUSH
11436: CALL_OW 70
11440: PUSH
11441: LD_EXP 33
11445: OR
11446: IFFALSE 11643
11448: GO 11450
11450: DISABLE
11451: LD_INT 0
11453: PPUSH
11454: PPUSH
// begin enable ;
11455: ENABLE
// if not jmm_on_west then
11456: LD_EXP 5
11460: NOT
11461: IFFALSE 11472
// begin YouLost ( 4 ) ;
11463: LD_STRING 4
11465: PPUSH
11466: CALL_OW 104
// exit ;
11470: GO 11643
// end ; if not game_end then
11472: LD_EXP 33
11476: NOT
11477: IFFALSE 11487
// game_end := true ;
11479: LD_ADDR_EXP 33
11483: PUSH
11484: LD_INT 1
11486: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11487: LD_ADDR_VAR 0 2
11491: PUSH
11492: LD_INT 9
11494: PPUSH
11495: LD_INT 22
11497: PUSH
11498: LD_INT 1
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: PPUSH
11505: CALL_OW 70
11509: ST_TO_ADDR
// if not filter then
11510: LD_VAR 0 2
11514: NOT
11515: IFFALSE 11519
// exit ;
11517: GO 11643
// for i in filter do
11519: LD_ADDR_VAR 0 1
11523: PUSH
11524: LD_VAR 0 2
11528: PUSH
11529: FOR_IN
11530: IFFALSE 11641
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11532: LD_VAR 0 1
11536: PPUSH
11537: CALL_OW 302
11541: PUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 247
11551: PUSH
11552: LD_INT 2
11554: EQUAL
11555: AND
11556: PUSH
11557: LD_VAR 0 1
11561: PPUSH
11562: CALL_OW 248
11566: PUSH
11567: LD_INT 1
11569: EQUAL
11570: AND
11571: IFFALSE 11604
// begin veh_on_meta := true ;
11573: LD_ADDR_EXP 28
11577: PUSH
11578: LD_INT 1
11580: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11581: LD_VAR 0 1
11585: PPUSH
11586: CALL_OW 311
11590: PPUSH
11591: CALL 11646 0 1
// RemoveUnit ( i ) ;
11595: LD_VAR 0 1
11599: PPUSH
11600: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11604: LD_VAR 0 1
11608: PPUSH
11609: CALL_OW 302
11613: PUSH
11614: LD_VAR 0 1
11618: PPUSH
11619: CALL_OW 247
11623: PUSH
11624: LD_INT 1
11626: EQUAL
11627: AND
11628: IFFALSE 11639
// Save ( i ) ;
11630: LD_VAR 0 1
11634: PPUSH
11635: CALL 11646 0 1
// end ;
11639: GO 11529
11641: POP
11642: POP
// end ;
11643: PPOPN 2
11645: END
// export function Save ( i ) ; begin
11646: LD_INT 0
11648: PPUSH
// save_counter := save_counter + 1 ;
11649: LD_ADDR_EXP 36
11653: PUSH
11654: LD_EXP 36
11658: PUSH
11659: LD_INT 1
11661: PLUS
11662: ST_TO_ADDR
// if i = JMM then
11663: LD_VAR 0 1
11667: PUSH
11668: LD_EXP 37
11672: EQUAL
11673: IFFALSE 11795
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11675: LD_EXP 24
11679: PUSH
11680: LD_INT 22
11682: PUSH
11683: LD_INT 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 21
11692: PUSH
11693: LD_INT 1
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PPUSH
11704: CALL_OW 69
11708: PUSH
11709: LD_INT 1
11711: GREATER
11712: AND
11713: IFFALSE 11770
// begin show_query := false ;
11715: LD_ADDR_EXP 24
11719: PUSH
11720: LD_INT 0
11722: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11723: LD_STRING Q2
11725: PPUSH
11726: CALL_OW 97
11730: PUSH
11731: LD_INT 1
11733: DOUBLE
11734: EQUAL
11735: IFTRUE 11739
11737: GO 11750
11739: POP
// wait_for_them := true ; 2 :
11740: LD_ADDR_EXP 25
11744: PUSH
11745: LD_INT 1
11747: ST_TO_ADDR
11748: GO 11770
11750: LD_INT 2
11752: DOUBLE
11753: EQUAL
11754: IFTRUE 11758
11756: GO 11769
11758: POP
// wait_for_them := false ; end ;
11759: LD_ADDR_EXP 25
11763: PUSH
11764: LD_INT 0
11766: ST_TO_ADDR
11767: GO 11770
11769: POP
// end ; save_group := save_group ^ JMM ;
11770: LD_ADDR_EXP 23
11774: PUSH
11775: LD_EXP 23
11779: PUSH
11780: LD_EXP 37
11784: ADD
11785: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11786: LD_EXP 37
11790: PPUSH
11791: CALL_OW 64
// end ; if i = Lisa then
11795: LD_VAR 0 1
11799: PUSH
11800: LD_EXP 40
11804: EQUAL
11805: IFFALSE 11832
// begin save_group := save_group ^ Lisa ;
11807: LD_ADDR_EXP 23
11811: PUSH
11812: LD_EXP 23
11816: PUSH
11817: LD_EXP 40
11821: ADD
11822: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11823: LD_EXP 40
11827: PPUSH
11828: CALL_OW 64
// end ; if i = Bobby then
11832: LD_VAR 0 1
11836: PUSH
11837: LD_EXP 38
11841: EQUAL
11842: IFFALSE 11869
// begin save_group := save_group ^ Bobby ;
11844: LD_ADDR_EXP 23
11848: PUSH
11849: LD_EXP 23
11853: PUSH
11854: LD_EXP 38
11858: ADD
11859: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11860: LD_EXP 38
11864: PPUSH
11865: CALL_OW 64
// end ; if i = Cyrus then
11869: LD_VAR 0 1
11873: PUSH
11874: LD_EXP 39
11878: EQUAL
11879: IFFALSE 11906
// begin save_group := save_group ^ Cyrus ;
11881: LD_ADDR_EXP 23
11885: PUSH
11886: LD_EXP 23
11890: PUSH
11891: LD_EXP 39
11895: ADD
11896: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11897: LD_EXP 39
11901: PPUSH
11902: CALL_OW 64
// end ; if i = Khatam then
11906: LD_VAR 0 1
11910: PUSH
11911: LD_EXP 41
11915: EQUAL
11916: IFFALSE 11943
// begin save_group := save_group ^ Khatam ;
11918: LD_ADDR_EXP 23
11922: PUSH
11923: LD_EXP 23
11927: PUSH
11928: LD_EXP 41
11932: ADD
11933: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11934: LD_EXP 41
11938: PPUSH
11939: CALL_OW 64
// end ; if i = Frank then
11943: LD_VAR 0 1
11947: PUSH
11948: LD_EXP 51
11952: EQUAL
11953: IFFALSE 11980
// begin save_group := save_group ^ Frank ;
11955: LD_ADDR_EXP 23
11959: PUSH
11960: LD_EXP 23
11964: PUSH
11965: LD_EXP 51
11969: ADD
11970: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11971: LD_EXP 51
11975: PPUSH
11976: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11980: LD_VAR 0 1
11984: PPUSH
11985: CALL_OW 302
11989: PUSH
11990: LD_VAR 0 1
11994: PPUSH
11995: CALL_OW 247
11999: PUSH
12000: LD_INT 1
12002: EQUAL
12003: AND
12004: PUSH
12005: LD_VAR 0 1
12009: PUSH
12010: LD_EXP 23
12014: IN
12015: NOT
12016: AND
12017: IFFALSE 12044
// begin save_others := save_others ^ i ;
12019: LD_ADDR_EXP 22
12023: PUSH
12024: LD_EXP 22
12028: PUSH
12029: LD_VAR 0 1
12033: ADD
12034: ST_TO_ADDR
// RemoveUnit ( i ) ;
12035: LD_VAR 0 1
12039: PPUSH
12040: CALL_OW 64
// end ; end ;
12044: LD_VAR 0 2
12048: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12049: LD_EXP 24
12053: NOT
12054: PUSH
12055: LD_EXP 25
12059: NOT
12060: AND
12061: PUSH
12062: LD_INT 22
12064: PUSH
12065: LD_INT 1
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: LD_INT 21
12074: PUSH
12075: LD_INT 1
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PPUSH
12086: CALL_OW 69
12090: PUSH
12091: LD_INT 0
12093: EQUAL
12094: OR
12095: IFFALSE 12104
12097: GO 12099
12099: DISABLE
// EndMission ;
12100: CALL 12105 0 0
12104: END
// export function EndMission ; var i , m1 , m2 , m3 ; begin
12105: LD_INT 0
12107: PPUSH
12108: PPUSH
12109: PPUSH
12110: PPUSH
12111: PPUSH
// Wait ( 0 0$02 ) ;
12112: LD_INT 70
12114: PPUSH
12115: CALL_OW 67
// if tick <= 10 10$00 then
12119: LD_OWVAR 1
12123: PUSH
12124: LD_INT 21000
12126: LESSEQUAL
12127: IFFALSE 12136
// SetAchievement ( ACH_ASPEED_3 ) ;
12129: LD_STRING ACH_ASPEED_3
12131: PPUSH
12132: CALL_OW 543
// if UnitFilter ( save_group ^ save_others , [ f_class , 4 ] ) = 0 then
12136: LD_EXP 23
12140: PUSH
12141: LD_EXP 22
12145: ADD
12146: PPUSH
12147: LD_INT 25
12149: PUSH
12150: LD_INT 4
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PPUSH
12157: CALL_OW 72
12161: PUSH
12162: LD_INT 0
12164: EQUAL
12165: IFFALSE 12181
// begin wait ( 3 ) ;
12167: LD_INT 3
12169: PPUSH
12170: CALL_OW 67
// SetAchievement ( ACH_NOSCI ) ;
12174: LD_STRING ACH_NOSCI
12176: PPUSH
12177: CALL_OW 543
// end ; m1 := solar_builded ;
12181: LD_ADDR_VAR 0 3
12185: PUSH
12186: LD_EXP 14
12190: ST_TO_ADDR
// m2 := veh_on_meta ;
12191: LD_ADDR_VAR 0 4
12195: PUSH
12196: LD_EXP 28
12200: ST_TO_ADDR
// m3 := ( lose_counter = 0 ) ;
12201: LD_ADDR_VAR 0 5
12205: PUSH
12206: LD_EXP 34
12210: PUSH
12211: LD_INT 0
12213: EQUAL
12214: ST_TO_ADDR
// if solar_builded then
12215: LD_EXP 14
12219: IFFALSE 12233
// AddMedal ( Solar1 , 1 ) else
12221: LD_STRING Solar1
12223: PPUSH
12224: LD_INT 1
12226: PPUSH
12227: CALL_OW 101
12231: GO 12244
// AddMedal ( Solar1 , - 1 ) ;
12233: LD_STRING Solar1
12235: PPUSH
12236: LD_INT 1
12238: NEG
12239: PPUSH
12240: CALL_OW 101
// if veh_on_meta then
12244: LD_EXP 28
12248: IFFALSE 12262
// AddMedal ( Solar2 , 1 ) else
12250: LD_STRING Solar2
12252: PPUSH
12253: LD_INT 1
12255: PPUSH
12256: CALL_OW 101
12260: GO 12292
// if solar_builded then
12262: LD_EXP 14
12266: IFFALSE 12281
// AddMedal ( Solar2 , - 1 ) else
12268: LD_STRING Solar2
12270: PPUSH
12271: LD_INT 1
12273: NEG
12274: PPUSH
12275: CALL_OW 101
12279: GO 12292
// AddMedal ( Solar2 , - 2 ) ;
12281: LD_STRING Solar2
12283: PPUSH
12284: LD_INT 2
12286: NEG
12287: PPUSH
12288: CALL_OW 101
// if lose_counter = 0 then
12292: LD_EXP 34
12296: PUSH
12297: LD_INT 0
12299: EQUAL
12300: IFFALSE 12314
// AddMedal ( No , 1 ) else
12302: LD_STRING No
12304: PPUSH
12305: LD_INT 1
12307: PPUSH
12308: CALL_OW 101
12312: GO 12358
// if lose_counter > 0 and lose_counter < 4 then
12314: LD_EXP 34
12318: PUSH
12319: LD_INT 0
12321: GREATER
12322: PUSH
12323: LD_EXP 34
12327: PUSH
12328: LD_INT 4
12330: LESS
12331: AND
12332: IFFALSE 12347
// AddMedal ( No , - 1 ) else
12334: LD_STRING No
12336: PPUSH
12337: LD_INT 1
12339: NEG
12340: PPUSH
12341: CALL_OW 101
12345: GO 12358
// AddMedal ( UpTo4 , - 1 ) ;
12347: LD_STRING UpTo4
12349: PPUSH
12350: LD_INT 1
12352: NEG
12353: PPUSH
12354: CALL_OW 101
// GiveMedals ( MAIN ) ;
12358: LD_STRING MAIN
12360: PPUSH
12361: CALL_OW 102
// if Difficulty = 3 and m1 and m2 and m3 then
12365: LD_OWVAR 67
12369: PUSH
12370: LD_INT 3
12372: EQUAL
12373: PUSH
12374: LD_VAR 0 3
12378: AND
12379: PUSH
12380: LD_VAR 0 4
12384: AND
12385: PUSH
12386: LD_VAR 0 5
12390: AND
12391: IFFALSE 12403
// SetAchievementEX ( ACH_AMER , 3 ) ;
12393: LD_STRING ACH_AMER
12395: PPUSH
12396: LD_INT 3
12398: PPUSH
12399: CALL_OW 564
// if IsDead ( Pokryshkin ) then
12403: LD_EXP 52
12407: PPUSH
12408: CALL_OW 301
12412: IFFALSE 12468
// begin stop_talking := true ;
12414: LD_ADDR_OWVAR 56
12418: PUSH
12419: LD_INT 1
12421: ST_TO_ADDR
// for i in save_group ^ save_others do
12422: LD_ADDR_VAR 0 2
12426: PUSH
12427: LD_EXP 23
12431: PUSH
12432: LD_EXP 22
12436: ADD
12437: PUSH
12438: FOR_IN
12439: IFFALSE 12458
// AddExperience ( i , skill_combat , 1500 ) ;
12441: LD_VAR 0 2
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: LD_INT 1500
12451: PPUSH
12452: CALL_OW 492
12456: GO 12438
12458: POP
12459: POP
// stop_talking := false ;
12460: LD_ADDR_OWVAR 56
12464: PUSH
12465: LD_INT 0
12467: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12468: LD_EXP 23
12472: PUSH
12473: LD_EXP 22
12477: ADD
12478: PPUSH
12479: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12483: LD_EXP 37
12487: PPUSH
12488: LD_EXP 2
12492: PUSH
12493: LD_STRING JMM
12495: STR
12496: PPUSH
12497: CALL_OW 38
// if Bobby in save_group then
12501: LD_EXP 38
12505: PUSH
12506: LD_EXP 23
12510: IN
12511: IFFALSE 12531
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12513: LD_EXP 38
12517: PPUSH
12518: LD_EXP 2
12522: PUSH
12523: LD_STRING Bobby
12525: STR
12526: PPUSH
12527: CALL_OW 38
// if Cyrus in save_group then
12531: LD_EXP 39
12535: PUSH
12536: LD_EXP 23
12540: IN
12541: IFFALSE 12561
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12543: LD_EXP 39
12547: PPUSH
12548: LD_EXP 2
12552: PUSH
12553: LD_STRING Cyrus
12555: STR
12556: PPUSH
12557: CALL_OW 38
// if Lisa in save_group then
12561: LD_EXP 40
12565: PUSH
12566: LD_EXP 23
12570: IN
12571: IFFALSE 12591
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12573: LD_EXP 40
12577: PPUSH
12578: LD_EXP 2
12582: PUSH
12583: LD_STRING Lisa
12585: STR
12586: PPUSH
12587: CALL_OW 38
// if Frank in save_group then
12591: LD_EXP 51
12595: PUSH
12596: LD_EXP 23
12600: IN
12601: IFFALSE 12621
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12603: LD_EXP 51
12607: PPUSH
12608: LD_EXP 2
12612: PUSH
12613: LD_STRING Frank
12615: STR
12616: PPUSH
12617: CALL_OW 38
// if Khatam in save_group then
12621: LD_EXP 41
12625: PUSH
12626: LD_EXP 23
12630: IN
12631: IFFALSE 12651
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12633: LD_EXP 41
12637: PPUSH
12638: LD_EXP 2
12642: PUSH
12643: LD_STRING Khatam
12645: STR
12646: PPUSH
12647: CALL_OW 38
// if save_others then
12651: LD_EXP 22
12655: IFFALSE 12669
// SaveCharacters ( save_others , 03_others ) ;
12657: LD_EXP 22
12661: PPUSH
12662: LD_STRING 03_others
12664: PPUSH
12665: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12669: LD_EXP 45
12673: PUSH
12674: LD_EXP 45
12678: PPUSH
12679: CALL_OW 302
12683: AND
12684: PUSH
12685: LD_EXP 27
12689: AND
12690: IFFALSE 12702
// begin ResetFog ;
12692: CALL_OW 335
// DisplayEndingScene ;
12696: CALL 12724 0 0
// end else
12700: GO 12715
// DeleteCharacters ( mission_prefix & Cornel ) ;
12702: LD_EXP 2
12706: PUSH
12707: LD_STRING Cornel
12709: STR
12710: PPUSH
12711: CALL_OW 40
// YouWin ;
12715: CALL_OW 103
// end ;
12719: LD_VAR 0 1
12723: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12724: LD_INT 0
12726: PPUSH
12727: PPUSH
12728: PPUSH
12729: PPUSH
12730: PPUSH
12731: PPUSH
// InGameOn ;
12732: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12736: LD_INT 208
12738: PPUSH
12739: LD_INT 62
12741: PPUSH
12742: LD_INT 1
12744: PPUSH
12745: LD_INT 10
12747: NEG
12748: PPUSH
12749: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12753: LD_INT 208
12755: PPUSH
12756: LD_INT 62
12758: PPUSH
12759: LD_INT 1
12761: PPUSH
12762: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12766: LD_ADDR_VAR 0 3
12770: PUSH
12771: LD_INT 22
12773: PUSH
12774: LD_INT 3
12776: PUSH
12777: EMPTY
12778: LIST
12779: LIST
12780: PUSH
12781: LD_INT 2
12783: PUSH
12784: LD_INT 21
12786: PUSH
12787: LD_INT 2
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: LIST
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PPUSH
12813: CALL_OW 69
12817: ST_TO_ADDR
// if filter then
12818: LD_VAR 0 3
12822: IFFALSE 12850
// for i in filter do
12824: LD_ADDR_VAR 0 2
12828: PUSH
12829: LD_VAR 0 3
12833: PUSH
12834: FOR_IN
12835: IFFALSE 12848
// RemoveUnit ( i ) ;
12837: LD_VAR 0 2
12841: PPUSH
12842: CALL_OW 64
12846: GO 12834
12848: POP
12849: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: LD_INT 22
12857: PUSH
12858: LD_INT 4
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: PUSH
12865: LD_INT 21
12867: PUSH
12868: LD_INT 1
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: PPUSH
12879: CALL_OW 69
12883: ST_TO_ADDR
// if filter then
12884: LD_VAR 0 3
12888: IFFALSE 12919
// for i in filter do
12890: LD_ADDR_VAR 0 2
12894: PUSH
12895: LD_VAR 0 3
12899: PUSH
12900: FOR_IN
12901: IFFALSE 12917
// SetLives ( i , 0 ) ;
12903: LD_VAR 0 2
12907: PPUSH
12908: LD_INT 0
12910: PPUSH
12911: CALL_OW 234
12915: GO 12900
12917: POP
12918: POP
// uc_side := 4 ;
12919: LD_ADDR_OWVAR 20
12923: PUSH
12924: LD_INT 4
12926: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12927: LD_ADDR_VAR 0 4
12931: PUSH
12932: LD_STRING Cornell
12934: PPUSH
12935: LD_INT 0
12937: PPUSH
12938: CALL 489 0 2
12942: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12943: LD_VAR 0 4
12947: PPUSH
12948: LD_INT 208
12950: PPUSH
12951: LD_INT 62
12953: PPUSH
12954: LD_INT 0
12956: PPUSH
12957: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12961: LD_VAR 0 4
12965: PPUSH
12966: LD_INT 100
12968: PPUSH
12969: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12973: LD_INT 3
12975: PPUSH
12976: LD_VAR 0 4
12980: PPUSH
12981: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12985: LD_INT 4
12987: PPUSH
12988: LD_INT 3
12990: PPUSH
12991: LD_INT 1
12993: PPUSH
12994: LD_INT 1
12996: PPUSH
12997: CALL_OW 80
// uc_side := 3 ;
13001: LD_ADDR_OWVAR 20
13005: PUSH
13006: LD_INT 3
13008: ST_TO_ADDR
// uc_nation := 3 ;
13009: LD_ADDR_OWVAR 21
13013: PUSH
13014: LD_INT 3
13016: ST_TO_ADDR
// InitHc ;
13017: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
13021: LD_ADDR_VAR 0 5
13025: PUSH
13026: LD_STRING Mikhail
13028: PPUSH
13029: LD_INT 0
13031: PPUSH
13032: CALL 489 0 2
13036: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
13037: LD_INT 1
13039: PPUSH
13040: LD_INT 1
13042: PPUSH
13043: LD_INT 0
13045: PPUSH
13046: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13050: LD_ADDR_VAR 0 6
13054: PUSH
13055: LD_VAR 0 6
13059: PUSH
13060: CALL_OW 44
13064: ADD
13065: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
13066: LD_ADDR_VAR 0 6
13070: PUSH
13071: LD_VAR 0 6
13075: PUSH
13076: CALL_OW 44
13080: ADD
13081: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
13082: LD_INT 2
13084: PPUSH
13085: LD_INT 4
13087: PPUSH
13088: LD_INT 0
13090: PPUSH
13091: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13095: LD_ADDR_VAR 0 6
13099: PUSH
13100: LD_VAR 0 6
13104: PUSH
13105: CALL_OW 44
13109: ADD
13110: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
13111: LD_VAR 0 5
13115: PPUSH
13116: LD_INT 17
13118: PPUSH
13119: LD_INT 0
13121: PPUSH
13122: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
13126: LD_VAR 0 5
13130: PPUSH
13131: LD_INT 210
13133: PPUSH
13134: LD_INT 63
13136: PPUSH
13137: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
13141: LD_VAR 0 5
13145: PPUSH
13146: LD_INT 208
13148: PPUSH
13149: LD_INT 62
13151: PPUSH
13152: CALL_OW 178
// for i in fake_russians do
13156: LD_ADDR_VAR 0 2
13160: PUSH
13161: LD_VAR 0 6
13165: PUSH
13166: FOR_IN
13167: IFFALSE 13245
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13169: LD_VAR 0 2
13173: PPUSH
13174: LD_INT 17
13176: PPUSH
13177: LD_INT 0
13179: PPUSH
13180: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13184: LD_VAR 0 2
13188: PPUSH
13189: LD_INT 215
13191: PPUSH
13192: LD_INT 67
13194: PPUSH
13195: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13199: LD_VAR 0 2
13203: PPUSH
13204: LD_INT 208
13206: PPUSH
13207: LD_INT 62
13209: PPUSH
13210: CALL_OW 178
// if GetClass ( i ) = 4 then
13214: LD_VAR 0 2
13218: PPUSH
13219: CALL_OW 257
13223: PUSH
13224: LD_INT 4
13226: EQUAL
13227: IFFALSE 13243
// ComHeal ( i , fake_cornel ) ;
13229: LD_VAR 0 2
13233: PPUSH
13234: LD_VAR 0 4
13238: PPUSH
13239: CALL_OW 128
// end ;
13243: GO 13166
13245: POP
13246: POP
// Wait ( 0 0$01 ) ;
13247: LD_INT 35
13249: PPUSH
13250: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13254: LD_INT 208
13256: PPUSH
13257: LD_INT 62
13259: PPUSH
13260: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13264: LD_INT 208
13266: PPUSH
13267: LD_INT 62
13269: PPUSH
13270: LD_INT 1
13272: PPUSH
13273: LD_INT 10
13275: NEG
13276: PPUSH
13277: CALL_OW 330
// Wait ( 0 0$15 ) ;
13281: LD_INT 525
13283: PPUSH
13284: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13288: LD_INT 208
13290: PPUSH
13291: LD_INT 62
13293: PPUSH
13294: LD_INT 1
13296: PPUSH
13297: CALL_OW 331
// ResetFog ;
13301: CALL_OW 335
// InGameOff ;
13305: CALL_OW 9
// end ;
13309: LD_VAR 0 1
13313: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13314: LD_INT 10
13316: PPUSH
13317: LD_INT 22
13319: PUSH
13320: LD_INT 1
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PPUSH
13327: CALL_OW 70
13331: PUSH
13332: LD_EXP 44
13336: PPUSH
13337: CALL_OW 302
13341: AND
13342: PUSH
13343: LD_INT 22
13345: PUSH
13346: LD_INT 1
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PPUSH
13353: CALL_OW 69
13357: PPUSH
13358: LD_EXP 44
13362: PPUSH
13363: CALL_OW 74
13367: PPUSH
13368: LD_EXP 44
13372: PPUSH
13373: CALL_OW 296
13377: PUSH
13378: LD_INT 30
13380: LESS
13381: OR
13382: IFFALSE 13433
13384: GO 13386
13386: DISABLE
// begin enable ;
13387: ENABLE
// powell_warn := powell_warn + 1 ;
13388: LD_ADDR_EXP 35
13392: PUSH
13393: LD_EXP 35
13397: PUSH
13398: LD_INT 1
13400: PLUS
13401: ST_TO_ADDR
// if powell_warn = 3 then
13402: LD_EXP 35
13406: PUSH
13407: LD_INT 3
13409: EQUAL
13410: IFFALSE 13421
// begin YouLost ( 5 ) ;
13412: LD_STRING 5
13414: PPUSH
13415: CALL_OW 104
// exit ;
13419: GO 13433
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13421: LD_EXP 46
13425: PPUSH
13426: LD_STRING DWarn-Pow-1
13428: PPUSH
13429: CALL_OW 94
// end ; end_of_file
13433: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13434: LD_EXP 8
13438: IFFALSE 15275
13440: GO 13442
13442: DISABLE
13443: LD_INT 0
13445: PPUSH
13446: PPUSH
13447: PPUSH
13448: PPUSH
13449: PPUSH
13450: PPUSH
13451: PPUSH
13452: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13453: LD_EXP 44
13457: PUSH
13458: LD_EXP 45
13462: ADD
13463: PUSH
13464: LD_EXP 6
13468: ADD
13469: PPUSH
13470: LD_INT 250
13472: PPUSH
13473: LD_INT 120
13475: PPUSH
13476: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13480: LD_ADDR_VAR 0 2
13484: PUSH
13485: LD_EXP 6
13489: PPUSH
13490: LD_INT 25
13492: PUSH
13493: LD_INT 2
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PPUSH
13500: CALL_OW 72
13504: PUSH
13505: LD_EXP 45
13509: DIFF
13510: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13511: LD_ADDR_VAR 0 3
13515: PUSH
13516: LD_EXP 6
13520: PPUSH
13521: LD_INT 21
13523: PUSH
13524: LD_INT 1
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PPUSH
13531: CALL_OW 72
13535: PUSH
13536: LD_VAR 0 2
13540: DIFF
13541: ST_TO_ADDR
// if not has_eng then
13542: LD_VAR 0 2
13546: NOT
13547: IFFALSE 13630
// begin uc_side := 4 ;
13549: LD_ADDR_OWVAR 20
13553: PUSH
13554: LD_INT 4
13556: ST_TO_ADDR
// uc_nation := 1 ;
13557: LD_ADDR_OWVAR 21
13561: PUSH
13562: LD_INT 1
13564: ST_TO_ADDR
// bc_type := b_depot ;
13565: LD_ADDR_OWVAR 42
13569: PUSH
13570: LD_INT 0
13572: ST_TO_ADDR
// bc_level := 2 ;
13573: LD_ADDR_OWVAR 43
13577: PUSH
13578: LD_INT 2
13580: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13581: LD_ADDR_VAR 0 4
13585: PUSH
13586: LD_INT 264
13588: PPUSH
13589: LD_INT 120
13591: PPUSH
13592: LD_INT 4
13594: PPUSH
13595: CALL_OW 47
13599: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13600: LD_INT 264
13602: PPUSH
13603: LD_INT 120
13605: PPUSH
13606: LD_INT 4
13608: PPUSH
13609: LD_INT 10
13611: NEG
13612: PPUSH
13613: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13617: LD_INT 264
13619: PPUSH
13620: LD_INT 120
13622: PPUSH
13623: LD_INT 4
13625: PPUSH
13626: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13630: LD_INT 35
13632: PPUSH
13633: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13637: LD_EXP 44
13641: PPUSH
13642: LD_INT 10
13644: PPUSH
13645: CALL_OW 308
13649: PUSH
13650: LD_EXP 44
13654: PPUSH
13655: CALL_OW 310
13659: PPUSH
13660: LD_INT 10
13662: PPUSH
13663: CALL_OW 308
13667: OR
13668: IFFALSE 13630
// if has_eng and not dep then
13670: LD_VAR 0 2
13674: PUSH
13675: LD_VAR 0 4
13679: NOT
13680: AND
13681: IFFALSE 13831
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13683: LD_VAR 0 2
13687: PPUSH
13688: LD_INT 0
13690: PPUSH
13691: LD_INT 264
13693: PPUSH
13694: LD_INT 120
13696: PPUSH
13697: LD_INT 4
13699: PPUSH
13700: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13704: LD_INT 35
13706: PPUSH
13707: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13711: LD_INT 22
13713: PUSH
13714: LD_INT 4
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PUSH
13721: LD_INT 30
13723: PUSH
13724: LD_INT 0
13726: PUSH
13727: EMPTY
13728: LIST
13729: LIST
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 69
13739: IFFALSE 13704
// ComMoveXY ( filter , 264 , 120 ) ;
13741: LD_VAR 0 3
13745: PPUSH
13746: LD_INT 264
13748: PPUSH
13749: LD_INT 120
13751: PPUSH
13752: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13756: LD_INT 35
13758: PPUSH
13759: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13763: LD_INT 22
13765: PUSH
13766: LD_INT 4
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PUSH
13773: LD_INT 30
13775: PUSH
13776: LD_INT 0
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PUSH
13783: LD_INT 3
13785: PUSH
13786: LD_INT 57
13788: PUSH
13789: EMPTY
13790: LIST
13791: PUSH
13792: EMPTY
13793: LIST
13794: LIST
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: LIST
13800: PPUSH
13801: CALL_OW 69
13805: IFFALSE 13756
// ComMoveXY ( filter , 247 , 113 ) ;
13807: LD_VAR 0 3
13811: PPUSH
13812: LD_INT 247
13814: PPUSH
13815: LD_INT 113
13817: PPUSH
13818: CALL_OW 111
// Wait ( 0 0$2 ) ;
13822: LD_INT 70
13824: PPUSH
13825: CALL_OW 67
// end else
13829: GO 13843
// begin SetSide ( dep , 4 ) ;
13831: LD_VAR 0 4
13835: PPUSH
13836: LD_INT 4
13838: PPUSH
13839: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13843: LD_ADDR_VAR 0 4
13847: PUSH
13848: LD_INT 22
13850: PUSH
13851: LD_INT 4
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: PUSH
13858: LD_INT 30
13860: PUSH
13861: LD_INT 0
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: PPUSH
13872: CALL_OW 69
13876: PUSH
13877: LD_INT 1
13879: ARRAY
13880: ST_TO_ADDR
// if not has_eng then
13881: LD_VAR 0 2
13885: NOT
13886: IFFALSE 13973
// for i = 1 to 2 do
13888: LD_ADDR_VAR 0 1
13892: PUSH
13893: DOUBLE
13894: LD_INT 1
13896: DEC
13897: ST_TO_ADDR
13898: LD_INT 2
13900: PUSH
13901: FOR_TO
13902: IFFALSE 13971
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13904: LD_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: ARRAY
13912: PPUSH
13913: LD_VAR 0 4
13917: PPUSH
13918: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13922: LD_VAR 0 3
13926: PUSH
13927: LD_INT 1
13929: ARRAY
13930: PPUSH
13931: LD_INT 2
13933: PPUSH
13934: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13938: LD_VAR 0 3
13942: PUSH
13943: LD_INT 1
13945: ARRAY
13946: PPUSH
13947: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
13951: LD_ADDR_VAR 0 3
13955: PUSH
13956: LD_VAR 0 3
13960: PPUSH
13961: LD_INT 1
13963: PPUSH
13964: CALL_OW 3
13968: ST_TO_ADDR
// end ;
13969: GO 13901
13971: POP
13972: POP
// if IsInUnit ( Cornel ) then
13973: LD_EXP 44
13977: PPUSH
13978: CALL_OW 310
13982: IFFALSE 14060
// begin cargo := IsInUnit ( Cornel ) ;
13984: LD_ADDR_VAR 0 7
13988: PUSH
13989: LD_EXP 44
13993: PPUSH
13994: CALL_OW 310
13998: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13999: LD_VAR 0 7
14003: PPUSH
14004: LD_INT 1
14006: PPUSH
14007: CALL_OW 289
14011: IFFALSE 14022
// ComUnload ( cargo ) ;
14013: LD_VAR 0 7
14017: PPUSH
14018: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
14022: LD_EXP 44
14026: PPUSH
14027: LD_INT 235
14029: PPUSH
14030: LD_INT 122
14032: PPUSH
14033: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
14037: LD_EXP 44
14041: PPUSH
14042: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
14046: LD_EXP 44
14050: PPUSH
14051: LD_VAR 0 4
14055: PPUSH
14056: CALL_OW 180
// end ; if Bierezov then
14060: LD_EXP 45
14064: IFFALSE 14112
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
14066: LD_EXP 45
14070: PPUSH
14071: LD_INT 260
14073: PPUSH
14074: LD_INT 120
14076: PPUSH
14077: CALL_OW 111
// if dep then
14081: LD_VAR 0 4
14085: IFFALSE 14103
// AddComEnterUnit ( Bierezov , dep ) else
14087: LD_EXP 45
14091: PPUSH
14092: LD_VAR 0 4
14096: PPUSH
14097: CALL_OW 180
14101: GO 14112
// AddComHold ( Bierezov ) ;
14103: LD_EXP 45
14107: PPUSH
14108: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
14112: LD_INT 525
14114: PPUSH
14115: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
14119: LD_ADDR_VAR 0 2
14123: PUSH
14124: LD_INT 22
14126: PUSH
14127: LD_INT 4
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: PUSH
14134: LD_INT 25
14136: PUSH
14137: LD_INT 2
14139: PUSH
14140: EMPTY
14141: LIST
14142: LIST
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PPUSH
14148: CALL_OW 69
14152: PUSH
14153: LD_EXP 45
14157: DIFF
14158: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14159: LD_INT 35
14161: PPUSH
14162: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14166: LD_ADDR_VAR 0 6
14170: PUSH
14171: LD_INT 10
14173: PPUSH
14174: CALL_OW 435
14178: ST_TO_ADDR
// if crates then
14179: LD_VAR 0 6
14183: IFFALSE 14212
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14185: LD_VAR 0 2
14189: PPUSH
14190: LD_VAR 0 6
14194: PUSH
14195: LD_INT 1
14197: ARRAY
14198: PPUSH
14199: LD_VAR 0 6
14203: PUSH
14204: LD_INT 2
14206: ARRAY
14207: PPUSH
14208: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14212: LD_VAR 0 4
14216: PPUSH
14217: CALL_OW 274
14221: PPUSH
14222: LD_INT 1
14224: PPUSH
14225: CALL_OW 275
14229: PUSH
14230: LD_INT 40
14232: GREATEREQUAL
14233: IFFALSE 14159
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14235: LD_ADDR_VAR 0 5
14239: PUSH
14240: LD_INT 4
14242: PUSH
14243: LD_INT 256
14245: PUSH
14246: LD_INT 111
14248: PUSH
14249: LD_INT 2
14251: PUSH
14252: EMPTY
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: PUSH
14258: LD_INT 31
14260: PUSH
14261: LD_INT 243
14263: PUSH
14264: LD_INT 112
14266: PUSH
14267: LD_INT 2
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: PUSH
14276: LD_INT 31
14278: PUSH
14279: LD_INT 254
14281: PUSH
14282: LD_INT 114
14284: PUSH
14285: LD_INT 2
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: LIST
14298: ST_TO_ADDR
// for i in blist do
14299: LD_ADDR_VAR 0 1
14303: PUSH
14304: LD_VAR 0 5
14308: PUSH
14309: FOR_IN
14310: IFFALSE 14359
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14312: LD_VAR 0 2
14316: PPUSH
14317: LD_VAR 0 1
14321: PUSH
14322: LD_INT 1
14324: ARRAY
14325: PPUSH
14326: LD_VAR 0 1
14330: PUSH
14331: LD_INT 2
14333: ARRAY
14334: PPUSH
14335: LD_VAR 0 1
14339: PUSH
14340: LD_INT 3
14342: ARRAY
14343: PPUSH
14344: LD_VAR 0 1
14348: PUSH
14349: LD_INT 4
14351: ARRAY
14352: PPUSH
14353: CALL_OW 205
14357: GO 14309
14359: POP
14360: POP
// repeat wait ( 0 0$01 ) ;
14361: LD_INT 35
14363: PPUSH
14364: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14368: LD_INT 22
14370: PUSH
14371: LD_INT 4
14373: PUSH
14374: EMPTY
14375: LIST
14376: LIST
14377: PUSH
14378: LD_INT 30
14380: PUSH
14381: LD_INT 4
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: PUSH
14388: LD_INT 3
14390: PUSH
14391: LD_INT 57
14393: PUSH
14394: EMPTY
14395: LIST
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: LIST
14405: PPUSH
14406: CALL_OW 69
14410: IFFALSE 14361
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14412: LD_VAR 0 3
14416: PPUSH
14417: LD_INT 22
14419: PUSH
14420: LD_INT 4
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: PUSH
14427: LD_INT 30
14429: PUSH
14430: LD_INT 4
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PPUSH
14441: CALL_OW 69
14445: PUSH
14446: LD_INT 1
14448: ARRAY
14449: PPUSH
14450: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14454: LD_VAR 0 3
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 183
// if has_eng > 1 then
14466: LD_VAR 0 2
14470: PUSH
14471: LD_INT 1
14473: GREATER
14474: IFFALSE 14616
// for i = has_eng downto 2 do
14476: LD_ADDR_VAR 0 1
14480: PUSH
14481: DOUBLE
14482: LD_VAR 0 2
14486: INC
14487: ST_TO_ADDR
14488: LD_INT 2
14490: PUSH
14491: FOR_DOWNTO
14492: IFFALSE 14614
// begin if IsInUnit ( has_eng [ i ] ) then
14494: LD_VAR 0 2
14498: PUSH
14499: LD_VAR 0 1
14503: ARRAY
14504: PPUSH
14505: CALL_OW 310
14509: IFFALSE 14526
// ComExitBuilding ( has_eng [ i ] ) ;
14511: LD_VAR 0 2
14515: PUSH
14516: LD_VAR 0 1
14520: ARRAY
14521: PPUSH
14522: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14526: LD_VAR 0 2
14530: PUSH
14531: LD_VAR 0 1
14535: ARRAY
14536: PPUSH
14537: LD_INT 22
14539: PUSH
14540: LD_INT 4
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PUSH
14547: LD_INT 30
14549: PUSH
14550: LD_INT 4
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: PPUSH
14561: CALL_OW 69
14565: PUSH
14566: LD_INT 1
14568: ARRAY
14569: PPUSH
14570: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14574: LD_VAR 0 2
14578: PUSH
14579: LD_VAR 0 1
14583: ARRAY
14584: PPUSH
14585: LD_INT 1
14587: PPUSH
14588: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14592: LD_ADDR_VAR 0 2
14596: PUSH
14597: LD_VAR 0 2
14601: PPUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 3
14611: ST_TO_ADDR
// end ;
14612: GO 14491
14614: POP
14615: POP
// repeat wait ( 0 0$01 ) ;
14616: LD_INT 35
14618: PPUSH
14619: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14623: LD_INT 22
14625: PUSH
14626: LD_INT 4
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PUSH
14633: LD_INT 30
14635: PUSH
14636: LD_INT 31
14638: PUSH
14639: EMPTY
14640: LIST
14641: LIST
14642: PUSH
14643: LD_INT 3
14645: PUSH
14646: LD_INT 57
14648: PUSH
14649: EMPTY
14650: LIST
14651: PUSH
14652: EMPTY
14653: LIST
14654: LIST
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: LIST
14660: PPUSH
14661: CALL_OW 69
14665: PUSH
14666: LD_INT 1
14668: GREATER
14669: IFFALSE 14616
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14671: LD_ADDR_VAR 0 8
14675: PUSH
14676: LD_EXP 6
14680: PPUSH
14681: LD_INT 25
14683: PUSH
14684: LD_INT 1
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PPUSH
14691: CALL_OW 72
14695: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14696: LD_ADDR_VAR 0 1
14700: PUSH
14701: DOUBLE
14702: LD_INT 1
14704: DEC
14705: ST_TO_ADDR
14706: LD_INT 22
14708: PUSH
14709: LD_INT 4
14711: PUSH
14712: EMPTY
14713: LIST
14714: LIST
14715: PUSH
14716: LD_INT 30
14718: PUSH
14719: LD_INT 31
14721: PUSH
14722: EMPTY
14723: LIST
14724: LIST
14725: PUSH
14726: LD_INT 3
14728: PUSH
14729: LD_INT 57
14731: PUSH
14732: EMPTY
14733: LIST
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: LIST
14743: PPUSH
14744: CALL_OW 69
14748: PUSH
14749: FOR_TO
14750: IFFALSE 14834
// begin if not sol [ i ] then
14752: LD_VAR 0 8
14756: PUSH
14757: LD_VAR 0 1
14761: ARRAY
14762: NOT
14763: IFFALSE 14767
// break ;
14765: GO 14834
// ComExitBuilding ( sol [ i ] ) ;
14767: LD_VAR 0 8
14771: PUSH
14772: LD_VAR 0 1
14776: ARRAY
14777: PPUSH
14778: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14782: LD_VAR 0 8
14786: PUSH
14787: LD_VAR 0 1
14791: ARRAY
14792: PPUSH
14793: LD_INT 22
14795: PUSH
14796: LD_INT 4
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: LD_INT 30
14805: PUSH
14806: LD_INT 31
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: EMPTY
14814: LIST
14815: LIST
14816: PPUSH
14817: CALL_OW 69
14821: PUSH
14822: LD_VAR 0 1
14826: ARRAY
14827: PPUSH
14828: CALL_OW 180
// end ;
14832: GO 14749
14834: POP
14835: POP
// if sol > 3 then
14836: LD_VAR 0 8
14840: PUSH
14841: LD_INT 3
14843: GREATER
14844: IFFALSE 14961
// begin ComExitBuilding ( sol [ 3 ] ) ;
14846: LD_VAR 0 8
14850: PUSH
14851: LD_INT 3
14853: ARRAY
14854: PPUSH
14855: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14859: LD_VAR 0 8
14863: PUSH
14864: LD_INT 3
14866: ARRAY
14867: PPUSH
14868: LD_INT 246
14870: PPUSH
14871: LD_INT 94
14873: PPUSH
14874: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14878: LD_VAR 0 8
14882: PUSH
14883: LD_INT 3
14885: ARRAY
14886: PPUSH
14887: LD_INT 175
14889: PPUSH
14890: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14894: LD_VAR 0 8
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 224
14905: PPUSH
14906: LD_INT 90
14908: PPUSH
14909: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14913: LD_VAR 0 8
14917: PUSH
14918: LD_INT 3
14920: ARRAY
14921: PPUSH
14922: LD_INT 245
14924: PPUSH
14925: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14929: LD_VAR 0 8
14933: PUSH
14934: LD_INT 3
14936: ARRAY
14937: PPUSH
14938: LD_INT 223
14940: PPUSH
14941: LD_INT 110
14943: PPUSH
14944: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14948: LD_VAR 0 8
14952: PUSH
14953: LD_INT 3
14955: ARRAY
14956: PPUSH
14957: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14961: LD_VAR 0 2
14965: PPUSH
14966: LD_VAR 0 4
14970: PPUSH
14971: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
14975: LD_INT 22
14977: PUSH
14978: LD_INT 4
14980: PUSH
14981: EMPTY
14982: LIST
14983: LIST
14984: PUSH
14985: LD_INT 30
14987: PUSH
14988: LD_INT 4
14990: PUSH
14991: EMPTY
14992: LIST
14993: LIST
14994: PUSH
14995: EMPTY
14996: LIST
14997: LIST
14998: PPUSH
14999: CALL_OW 69
15003: PUSH
15004: LD_INT 1
15006: ARRAY
15007: PPUSH
15008: CALL_OW 313
15012: PUSH
15013: LD_INT 6
15015: LESS
15016: IFFALSE 15080
// begin if IsInUnit ( Cornel ) then
15018: LD_EXP 44
15022: PPUSH
15023: CALL_OW 310
15027: IFFALSE 15038
// ComExitBuilding ( Cornel ) ;
15029: LD_EXP 44
15033: PPUSH
15034: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
15038: LD_EXP 44
15042: PPUSH
15043: LD_INT 22
15045: PUSH
15046: LD_INT 4
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 30
15055: PUSH
15056: LD_INT 4
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: PUSH
15063: EMPTY
15064: LIST
15065: LIST
15066: PPUSH
15067: CALL_OW 69
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: PPUSH
15076: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
15080: LD_INT 35
15082: PPUSH
15083: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
15087: LD_ADDR_VAR 0 3
15091: PUSH
15092: LD_INT 22
15094: PUSH
15095: LD_INT 4
15097: PUSH
15098: EMPTY
15099: LIST
15100: LIST
15101: PUSH
15102: LD_INT 21
15104: PUSH
15105: LD_INT 3
15107: PUSH
15108: EMPTY
15109: LIST
15110: LIST
15111: PUSH
15112: LD_INT 3
15114: PUSH
15115: LD_INT 24
15117: PUSH
15118: LD_INT 1000
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: LIST
15133: PPUSH
15134: CALL_OW 69
15138: ST_TO_ADDR
// if filter and has_eng then
15139: LD_VAR 0 3
15143: PUSH
15144: LD_VAR 0 2
15148: AND
15149: IFFALSE 15215
// begin for i in has_eng do
15151: LD_ADDR_VAR 0 1
15155: PUSH
15156: LD_VAR 0 2
15160: PUSH
15161: FOR_IN
15162: IFFALSE 15211
// begin if IsInUnit ( i ) then
15164: LD_VAR 0 1
15168: PPUSH
15169: CALL_OW 310
15173: IFFALSE 15184
// ComExitBuilding ( i ) ;
15175: LD_VAR 0 1
15179: PPUSH
15180: CALL_OW 122
// Wait ( 3 ) ;
15184: LD_INT 3
15186: PPUSH
15187: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15191: LD_VAR 0 1
15195: PPUSH
15196: LD_VAR 0 3
15200: PUSH
15201: LD_INT 1
15203: ARRAY
15204: PPUSH
15205: CALL_OW 130
// end ;
15209: GO 15161
15211: POP
15212: POP
// end else
15213: GO 15269
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15215: LD_VAR 0 2
15219: PUSH
15220: LD_VAR 0 2
15224: PPUSH
15225: LD_INT 56
15227: PUSH
15228: EMPTY
15229: LIST
15230: PPUSH
15231: CALL_OW 72
15235: AND
15236: IFFALSE 15269
// for i in has_eng do
15238: LD_ADDR_VAR 0 1
15242: PUSH
15243: LD_VAR 0 2
15247: PUSH
15248: FOR_IN
15249: IFFALSE 15267
// ComEnterUnit ( i , dep ) ;
15251: LD_VAR 0 1
15255: PPUSH
15256: LD_VAR 0 4
15260: PPUSH
15261: CALL_OW 120
15265: GO 15248
15267: POP
15268: POP
// until cornel_prepared ;
15269: LD_EXP 11
15273: IFFALSE 15080
// end ;
15275: PPOPN 8
15277: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15278: LD_EXP 11
15282: IFFALSE 15681
15284: GO 15286
15286: DISABLE
15287: LD_INT 0
15289: PPUSH
15290: PPUSH
15291: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15292: LD_ADDR_VAR 0 2
15296: PUSH
15297: LD_INT 22
15299: PUSH
15300: LD_INT 4
15302: PUSH
15303: EMPTY
15304: LIST
15305: LIST
15306: PUSH
15307: LD_INT 30
15309: PUSH
15310: LD_INT 4
15312: PUSH
15313: EMPTY
15314: LIST
15315: LIST
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PPUSH
15321: CALL_OW 69
15325: PUSH
15326: LD_INT 1
15328: ARRAY
15329: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15330: LD_EXP 6
15334: PPUSH
15335: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15339: LD_EXP 45
15343: PUSH
15344: LD_EXP 45
15348: PPUSH
15349: CALL_OW 310
15353: AND
15354: IFFALSE 15365
// ComExitBuilding ( Bierezov ) ;
15356: LD_EXP 45
15360: PPUSH
15361: CALL_OW 122
// Wait ( 0 0$03 ) ;
15365: LD_INT 105
15367: PPUSH
15368: CALL_OW 67
// for i in cornel_units do
15372: LD_ADDR_VAR 0 1
15376: PUSH
15377: LD_EXP 6
15381: PUSH
15382: FOR_IN
15383: IFFALSE 15459
// begin if GetClass ( i ) in [ 2 , 3 ] then
15385: LD_VAR 0 1
15389: PPUSH
15390: CALL_OW 257
15394: PUSH
15395: LD_INT 2
15397: PUSH
15398: LD_INT 3
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: IN
15405: IFFALSE 15442
// begin ComEnterUnit ( i , arm ) ;
15407: LD_VAR 0 1
15411: PPUSH
15412: LD_VAR 0 2
15416: PPUSH
15417: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15421: LD_VAR 0 1
15425: PPUSH
15426: LD_INT 1
15428: PPUSH
15429: CALL_OW 183
// AddComExitBuilding ( i ) ;
15433: LD_VAR 0 1
15437: PPUSH
15438: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15442: LD_VAR 0 1
15446: PPUSH
15447: LD_INT 257
15449: PPUSH
15450: LD_INT 121
15452: PPUSH
15453: CALL_OW 171
// end ;
15457: GO 15382
15459: POP
15460: POP
// Wait ( 1 1$00 ) ;
15461: LD_INT 2100
15463: PPUSH
15464: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15468: LD_ADDR_VAR 0 3
15472: PUSH
15473: LD_EXP 44
15477: PUSH
15478: LD_EXP 45
15482: ADD
15483: PUSH
15484: LD_EXP 6
15488: ADD
15489: PUSH
15490: LD_EXP 6
15494: PPUSH
15495: LD_INT 21
15497: PUSH
15498: LD_INT 2
15500: PUSH
15501: EMPTY
15502: LIST
15503: LIST
15504: PPUSH
15505: CALL_OW 72
15509: DIFF
15510: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15511: LD_VAR 0 3
15515: PPUSH
15516: LD_INT 248
15518: PPUSH
15519: LD_INT 85
15521: PPUSH
15522: CALL_OW 111
// AddComHold ( filter ) ;
15526: LD_VAR 0 3
15530: PPUSH
15531: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15535: LD_INT 35
15537: PPUSH
15538: CALL_OW 67
// until cornel_attack ;
15542: LD_EXP 9
15546: IFFALSE 15535
// ComAgressiveMove ( filter , 209 , 63 ) ;
15548: LD_VAR 0 3
15552: PPUSH
15553: LD_INT 209
15555: PPUSH
15556: LD_INT 63
15558: PPUSH
15559: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15563: LD_EXP 44
15567: PPUSH
15568: LD_INT 208
15570: PPUSH
15571: LD_INT 62
15573: PPUSH
15574: CALL_OW 114
// AddComHold ( Cornel ) ;
15578: LD_EXP 44
15582: PPUSH
15583: CALL_OW 200
// if Bierezov then
15587: LD_EXP 45
15591: IFFALSE 15681
// begin filter := filter diff Bierezov ;
15593: LD_ADDR_VAR 0 3
15597: PUSH
15598: LD_VAR 0 3
15602: PUSH
15603: LD_EXP 45
15607: DIFF
15608: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15609: LD_EXP 45
15613: PPUSH
15614: LD_INT 6
15616: PPUSH
15617: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15621: LD_EXP 45
15625: PPUSH
15626: LD_INT 235
15628: PPUSH
15629: LD_INT 60
15631: PPUSH
15632: CALL_OW 111
// AddComHold ( Bierezov ) ;
15636: LD_EXP 45
15640: PPUSH
15641: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15645: LD_EXP 45
15649: PPUSH
15650: LD_INT 350
15652: PPUSH
15653: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15657: LD_EXP 45
15661: PPUSH
15662: LD_INT 198
15664: PPUSH
15665: LD_INT 28
15667: PPUSH
15668: CALL_OW 171
// AddComHold ( Bierezov ) ;
15672: LD_EXP 45
15676: PPUSH
15677: CALL_OW 200
// end ; end ; end_of_file
15681: PPOPN 3
15683: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15684: LD_EXP 53
15688: PUSH
15689: LD_EXP 31
15693: NOT
15694: AND
15695: PUSH
15696: LD_EXP 32
15700: NOT
15701: AND
15702: IFFALSE 16152
15704: GO 15706
15706: DISABLE
15707: LD_INT 0
15709: PPUSH
15710: PPUSH
15711: PPUSH
15712: PPUSH
// begin enable ;
15713: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15714: LD_ADDR_VAR 0 4
15718: PUSH
15719: LD_INT 81
15721: PUSH
15722: LD_INT 3
15724: PUSH
15725: EMPTY
15726: LIST
15727: LIST
15728: PPUSH
15729: CALL_OW 69
15733: ST_TO_ADDR
// for i = 1 to ru_patrol do
15734: LD_ADDR_VAR 0 2
15738: PUSH
15739: DOUBLE
15740: LD_INT 1
15742: DEC
15743: ST_TO_ADDR
15744: LD_EXP 53
15748: PUSH
15749: FOR_TO
15750: IFFALSE 16150
// begin un := ru_patrol [ i ] ;
15752: LD_ADDR_VAR 0 1
15756: PUSH
15757: LD_EXP 53
15761: PUSH
15762: LD_VAR 0 2
15766: ARRAY
15767: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15768: LD_VAR 0 1
15772: PPUSH
15773: LD_INT 13
15775: PPUSH
15776: CALL_OW 308
15780: IFFALSE 15885
// begin if not ru_alert then
15782: LD_EXP 60
15786: NOT
15787: IFFALSE 15797
// ru_alert := true ;
15789: LD_ADDR_EXP 60
15793: PUSH
15794: LD_INT 1
15796: ST_TO_ADDR
// if not See ( 1 , un ) then
15797: LD_INT 1
15799: PPUSH
15800: LD_VAR 0 1
15804: PPUSH
15805: CALL_OW 292
15809: NOT
15810: IFFALSE 15824
// SetLives ( un , 1000 ) ;
15812: LD_VAR 0 1
15816: PPUSH
15817: LD_INT 1000
15819: PPUSH
15820: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15824: LD_ADDR_EXP 53
15828: PUSH
15829: LD_EXP 53
15833: PUSH
15834: LD_VAR 0 1
15838: DIFF
15839: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15840: LD_VAR 0 1
15844: PPUSH
15845: LD_INT 22
15847: PUSH
15848: LD_INT 3
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PUSH
15855: LD_INT 30
15857: PUSH
15858: LD_INT 4
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PPUSH
15869: CALL_OW 69
15873: PPUSH
15874: CALL 1062 0 1
15878: PPUSH
15879: CALL_OW 120
// continue ;
15883: GO 15749
// end ; if IsOk ( un ) and not HasTask ( un ) then
15885: LD_VAR 0 1
15889: PPUSH
15890: CALL_OW 302
15894: PUSH
15895: LD_VAR 0 1
15899: PPUSH
15900: CALL_OW 314
15904: NOT
15905: AND
15906: IFFALSE 15999
// begin for j = 1 to ru_firepoints_south [ i ] do
15908: LD_ADDR_VAR 0 3
15912: PUSH
15913: DOUBLE
15914: LD_INT 1
15916: DEC
15917: ST_TO_ADDR
15918: LD_EXP 59
15922: PUSH
15923: LD_VAR 0 2
15927: ARRAY
15928: PUSH
15929: FOR_TO
15930: IFFALSE 15997
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15932: LD_VAR 0 1
15936: PPUSH
15937: LD_EXP 59
15941: PUSH
15942: LD_VAR 0 2
15946: ARRAY
15947: PUSH
15948: LD_VAR 0 3
15952: ARRAY
15953: PUSH
15954: LD_INT 1
15956: ARRAY
15957: PPUSH
15958: LD_EXP 59
15962: PUSH
15963: LD_VAR 0 2
15967: ARRAY
15968: PUSH
15969: LD_VAR 0 3
15973: ARRAY
15974: PUSH
15975: LD_INT 2
15977: ARRAY
15978: PPUSH
15979: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15983: LD_VAR 0 1
15987: PPUSH
15988: LD_INT 70
15990: PPUSH
15991: CALL_OW 202
// end ;
15995: GO 15929
15997: POP
15998: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15999: LD_VAR 0 1
16003: PPUSH
16004: CALL_OW 256
16008: PUSH
16009: LD_INT 700
16011: LESS
16012: PUSH
16013: LD_VAR 0 1
16017: PPUSH
16018: LD_INT 13
16020: PPUSH
16021: CALL_OW 308
16025: NOT
16026: AND
16027: IFFALSE 16079
// begin ComMoveToArea ( un , retreatArea ) ;
16029: LD_VAR 0 1
16033: PPUSH
16034: LD_INT 13
16036: PPUSH
16037: CALL_OW 113
// if not ru_alert_xy then
16041: LD_EXP 61
16045: NOT
16046: IFFALSE 16077
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
16048: LD_ADDR_EXP 61
16052: PUSH
16053: LD_VAR 0 1
16057: PPUSH
16058: CALL_OW 250
16062: PUSH
16063: LD_VAR 0 1
16067: PPUSH
16068: CALL_OW 251
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: ST_TO_ADDR
// end else
16077: GO 16148
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16079: LD_VAR 0 1
16083: PPUSH
16084: LD_VAR 0 4
16088: PPUSH
16089: LD_VAR 0 1
16093: PPUSH
16094: CALL_OW 74
16098: PPUSH
16099: CALL_OW 296
16103: PUSH
16104: LD_INT 9
16106: LESS
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 256
16117: PUSH
16118: LD_INT 500
16120: GREATER
16121: AND
16122: IFFALSE 16148
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16124: LD_VAR 0 1
16128: PPUSH
16129: LD_VAR 0 4
16133: PPUSH
16134: LD_VAR 0 1
16138: PPUSH
16139: CALL_OW 74
16143: PPUSH
16144: CALL_OW 115
// end ;
16148: GO 15749
16150: POP
16151: POP
// end ;
16152: PPOPN 4
16154: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16155: LD_EXP 60
16159: PUSH
16160: LD_EXP 61
16164: AND
16165: PUSH
16166: LD_EXP 31
16170: NOT
16171: AND
16172: PUSH
16173: LD_EXP 32
16177: NOT
16178: AND
16179: IFFALSE 16389
16181: GO 16183
16183: DISABLE
16184: LD_INT 0
16186: PPUSH
16187: PPUSH
// begin enable ;
16188: ENABLE
// if not ru_vehicles then
16189: LD_EXP 56
16193: NOT
16194: IFFALSE 16198
// exit ;
16196: GO 16389
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16198: LD_ADDR_VAR 0 2
16202: PUSH
16203: LD_INT 81
16205: PUSH
16206: LD_INT 3
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PPUSH
16213: CALL_OW 69
16217: ST_TO_ADDR
// if ru_vehicles then
16218: LD_EXP 56
16222: IFFALSE 16389
// begin for i in ru_vehicles do
16224: LD_ADDR_VAR 0 1
16228: PUSH
16229: LD_EXP 56
16233: PUSH
16234: FOR_IN
16235: IFFALSE 16387
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16237: LD_VAR 0 1
16241: PPUSH
16242: CALL_OW 302
16246: PUSH
16247: LD_VAR 0 1
16251: PPUSH
16252: LD_VAR 0 2
16256: PPUSH
16257: LD_VAR 0 1
16261: PPUSH
16262: CALL_OW 74
16266: PPUSH
16267: CALL_OW 296
16271: PUSH
16272: LD_INT 9
16274: LESS
16275: AND
16276: IFFALSE 16302
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16278: LD_VAR 0 1
16282: PPUSH
16283: LD_VAR 0 2
16287: PPUSH
16288: LD_VAR 0 1
16292: PPUSH
16293: CALL_OW 74
16297: PPUSH
16298: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 314
16311: NOT
16312: PUSH
16313: LD_VAR 0 1
16317: PPUSH
16318: CALL_OW 302
16322: AND
16323: PUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 61
16333: PUSH
16334: LD_INT 1
16336: ARRAY
16337: PPUSH
16338: LD_EXP 61
16342: PUSH
16343: LD_INT 2
16345: ARRAY
16346: PPUSH
16347: CALL_OW 297
16351: PUSH
16352: LD_INT 10
16354: GREATER
16355: AND
16356: IFFALSE 16385
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16358: LD_VAR 0 1
16362: PPUSH
16363: LD_EXP 61
16367: PUSH
16368: LD_INT 1
16370: ARRAY
16371: PPUSH
16372: LD_EXP 61
16376: PUSH
16377: LD_INT 2
16379: ARRAY
16380: PPUSH
16381: CALL_OW 114
// end ;
16385: GO 16234
16387: POP
16388: POP
// end ; end ;
16389: PPOPN 2
16391: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16392: LD_EXP 61
16396: PUSH
16397: LD_EXP 60
16401: AND
16402: PUSH
16403: LD_INT 3
16405: PPUSH
16406: CALL_OW 463
16410: NOT
16411: AND
16412: PUSH
16413: LD_EXP 31
16417: NOT
16418: AND
16419: PUSH
16420: LD_EXP 32
16424: NOT
16425: AND
16426: IFFALSE 16521
16428: GO 16430
16430: DISABLE
16431: LD_INT 0
16433: PPUSH
// begin enable ;
16434: ENABLE
// ru_alert_xy := false ;
16435: LD_ADDR_EXP 61
16439: PUSH
16440: LD_INT 0
16442: ST_TO_ADDR
// ru_alert := false ;
16443: LD_ADDR_EXP 60
16447: PUSH
16448: LD_INT 0
16450: ST_TO_ADDR
// if ru_vehicles then
16451: LD_EXP 56
16455: IFFALSE 16521
// for i in ru_vehicles do
16457: LD_ADDR_VAR 0 1
16461: PUSH
16462: LD_EXP 56
16466: PUSH
16467: FOR_IN
16468: IFFALSE 16519
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16470: LD_VAR 0 1
16474: PPUSH
16475: CALL_OW 302
16479: PUSH
16480: LD_VAR 0 1
16484: PPUSH
16485: LD_INT 89
16487: PPUSH
16488: LD_INT 36
16490: PPUSH
16491: CALL_OW 297
16495: PUSH
16496: LD_INT 10
16498: GREATER
16499: AND
16500: IFFALSE 16517
// ComMoveXY ( i , 89 , 36 ) ;
16502: LD_VAR 0 1
16506: PPUSH
16507: LD_INT 89
16509: PPUSH
16510: LD_INT 36
16512: PPUSH
16513: CALL_OW 111
16517: GO 16467
16519: POP
16520: POP
// end ;
16521: PPOPN 1
16523: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16524: LD_EXP 55
16528: PUSH
16529: LD_EXP 31
16533: NOT
16534: AND
16535: PUSH
16536: LD_EXP 32
16540: NOT
16541: AND
16542: IFFALSE 16826
16544: GO 16546
16546: DISABLE
16547: LD_INT 0
16549: PPUSH
16550: PPUSH
16551: PPUSH
// begin enable ;
16552: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16553: LD_ADDR_VAR 0 3
16557: PUSH
16558: LD_INT 81
16560: PUSH
16561: LD_INT 3
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PPUSH
16568: CALL_OW 69
16572: ST_TO_ADDR
// for i = 1 to ru_forest do
16573: LD_ADDR_VAR 0 1
16577: PUSH
16578: DOUBLE
16579: LD_INT 1
16581: DEC
16582: ST_TO_ADDR
16583: LD_EXP 55
16587: PUSH
16588: FOR_TO
16589: IFFALSE 16824
// begin un := ru_forest [ i ] ;
16591: LD_ADDR_VAR 0 2
16595: PUSH
16596: LD_EXP 55
16600: PUSH
16601: LD_VAR 0 1
16605: ARRAY
16606: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16607: LD_VAR 0 2
16611: PPUSH
16612: LD_INT 13
16614: PPUSH
16615: CALL_OW 308
16619: IFFALSE 16709
// begin if not See ( 1 , un ) then
16621: LD_INT 1
16623: PPUSH
16624: LD_VAR 0 2
16628: PPUSH
16629: CALL_OW 292
16633: NOT
16634: IFFALSE 16648
// SetLives ( un , 1000 ) ;
16636: LD_VAR 0 2
16640: PPUSH
16641: LD_INT 1000
16643: PPUSH
16644: CALL_OW 234
// ru_forest := ru_forest diff un ;
16648: LD_ADDR_EXP 55
16652: PUSH
16653: LD_EXP 55
16657: PUSH
16658: LD_VAR 0 2
16662: DIFF
16663: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16664: LD_VAR 0 2
16668: PPUSH
16669: LD_INT 22
16671: PUSH
16672: LD_INT 3
16674: PUSH
16675: EMPTY
16676: LIST
16677: LIST
16678: PUSH
16679: LD_INT 30
16681: PUSH
16682: LD_INT 4
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: PPUSH
16698: CALL 1062 0 1
16702: PPUSH
16703: CALL_OW 120
// continue ;
16707: GO 16588
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16709: LD_VAR 0 2
16713: PPUSH
16714: CALL_OW 256
16718: PUSH
16719: LD_INT 700
16721: LESS
16722: PUSH
16723: LD_VAR 0 2
16727: PPUSH
16728: LD_INT 13
16730: PPUSH
16731: CALL_OW 308
16735: NOT
16736: AND
16737: IFFALSE 16753
// ComMoveToArea ( un , retreatArea ) else
16739: LD_VAR 0 2
16743: PPUSH
16744: LD_INT 13
16746: PPUSH
16747: CALL_OW 113
16751: GO 16822
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16753: LD_VAR 0 2
16757: PPUSH
16758: LD_VAR 0 3
16762: PPUSH
16763: LD_VAR 0 2
16767: PPUSH
16768: CALL_OW 74
16772: PPUSH
16773: CALL_OW 296
16777: PUSH
16778: LD_INT 9
16780: LESS
16781: PUSH
16782: LD_VAR 0 2
16786: PPUSH
16787: CALL_OW 256
16791: PUSH
16792: LD_INT 500
16794: GREATER
16795: AND
16796: IFFALSE 16822
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16798: LD_VAR 0 2
16802: PPUSH
16803: LD_VAR 0 3
16807: PPUSH
16808: LD_VAR 0 2
16812: PPUSH
16813: CALL_OW 74
16817: PPUSH
16818: CALL_OW 115
// end ;
16822: GO 16588
16824: POP
16825: POP
// end ;
16826: PPOPN 3
16828: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16829: LD_EXP 32
16833: NOT
16834: IFFALSE 16955
16836: GO 16838
16838: DISABLE
16839: LD_INT 0
16841: PPUSH
16842: PPUSH
// begin enable ;
16843: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16844: LD_ADDR_VAR 0 2
16848: PUSH
16849: LD_INT 22
16851: PUSH
16852: LD_INT 3
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: PUSH
16859: LD_INT 21
16861: PUSH
16862: LD_INT 3
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: PUSH
16869: EMPTY
16870: LIST
16871: LIST
16872: PPUSH
16873: CALL_OW 69
16877: ST_TO_ADDR
// if filter then
16878: LD_VAR 0 2
16882: IFFALSE 16955
// for i in filter do
16884: LD_ADDR_VAR 0 1
16888: PUSH
16889: LD_VAR 0 2
16893: PUSH
16894: FOR_IN
16895: IFFALSE 16953
// if GetLives ( i ) < 990 then
16897: LD_VAR 0 1
16901: PPUSH
16902: CALL_OW 256
16906: PUSH
16907: LD_INT 990
16909: LESS
16910: IFFALSE 16951
// begin ru_alert := true ;
16912: LD_ADDR_EXP 60
16916: PUSH
16917: LD_INT 1
16919: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16920: LD_ADDR_EXP 61
16924: PUSH
16925: LD_VAR 0 1
16929: PPUSH
16930: CALL_OW 250
16934: PUSH
16935: LD_VAR 0 1
16939: PPUSH
16940: CALL_OW 251
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: ST_TO_ADDR
// break ;
16949: GO 16953
// end ;
16951: GO 16894
16953: POP
16954: POP
// end ;
16955: PPOPN 2
16957: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16958: LD_EXP 31
16962: IFFALSE 17111
16964: GO 16966
16966: DISABLE
16967: LD_INT 0
16969: PPUSH
16970: PPUSH
16971: PPUSH
16972: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16973: LD_ADDR_VAR 0 4
16977: PUSH
16978: LD_EXP 56
16982: PUSH
16983: LD_EXP 55
16987: ADD
16988: PUSH
16989: LD_EXP 53
16993: ADD
16994: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16995: LD_ADDR_VAR 0 3
16999: PUSH
17000: LD_INT 3
17002: PPUSH
17003: LD_INT 81
17005: PUSH
17006: LD_INT 3
17008: PUSH
17009: EMPTY
17010: LIST
17011: LIST
17012: PPUSH
17013: CALL_OW 70
17017: ST_TO_ADDR
// if filter and enemy then
17018: LD_VAR 0 4
17022: PUSH
17023: LD_VAR 0 3
17027: AND
17028: IFFALSE 17111
// repeat wait ( 0 0$01 ) ;
17030: LD_INT 35
17032: PPUSH
17033: CALL_OW 67
// for i in filter do
17037: LD_ADDR_VAR 0 1
17041: PUSH
17042: LD_VAR 0 4
17046: PUSH
17047: FOR_IN
17048: IFFALSE 17076
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17050: LD_VAR 0 1
17054: PPUSH
17055: LD_VAR 0 3
17059: PPUSH
17060: LD_VAR 0 1
17064: PPUSH
17065: CALL_OW 74
17069: PPUSH
17070: CALL_OW 115
// end ;
17074: GO 17047
17076: POP
17077: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
17078: LD_INT 3
17080: PPUSH
17081: LD_INT 81
17083: PUSH
17084: LD_INT 3
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PPUSH
17091: CALL_OW 70
17095: PUSH
17096: LD_INT 0
17098: EQUAL
17099: PUSH
17100: LD_VAR 0 4
17104: PUSH
17105: LD_INT 0
17107: EQUAL
17108: OR
17109: IFFALSE 17030
// end ;
17111: PPOPN 4
17113: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
17114: LD_EXP 26
17118: PUSH
17119: LD_INT 22
17121: PUSH
17122: LD_INT 4
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: PUSH
17129: LD_INT 30
17131: PUSH
17132: LD_INT 4
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: LD_INT 57
17144: PUSH
17145: EMPTY
17146: LIST
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: PPUSH
17157: CALL_OW 69
17161: AND
17162: IFFALSE 17211
17164: GO 17166
17166: DISABLE
17167: LD_INT 0
17169: PPUSH
// begin if not ru_cornel_attack then
17170: LD_EXP 58
17174: NOT
17175: IFFALSE 17179
// exit ;
17177: GO 17211
// for i in ru_cornel_attack do
17179: LD_ADDR_VAR 0 1
17183: PUSH
17184: LD_EXP 58
17188: PUSH
17189: FOR_IN
17190: IFFALSE 17209
// ComAgressiveMove ( i , 258 , 119 ) ;
17192: LD_VAR 0 1
17196: PPUSH
17197: LD_INT 258
17199: PPUSH
17200: LD_INT 119
17202: PPUSH
17203: CALL_OW 114
17207: GO 17189
17209: POP
17210: POP
// end ; end_of_file
17211: PPOPN 1
17213: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17214: LD_EXP 5
17218: PUSH
17219: LD_EXP 9
17223: NOT
17224: AND
17225: PUSH
17226: LD_EXP 20
17230: AND
17231: IFFALSE 17343
17233: GO 17235
17235: DISABLE
17236: LD_INT 0
17238: PPUSH
// begin enable ;
17239: ENABLE
// crates_counter := crates_counter - 50 ;
17240: LD_ADDR_EXP 20
17244: PUSH
17245: LD_EXP 20
17249: PUSH
17250: LD_INT 50
17252: MINUS
17253: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17254: LD_INT 8
17256: PPUSH
17257: LD_INT 2
17259: PPUSH
17260: LD_INT 5
17262: PPUSH
17263: CALL_OW 12
17267: PPUSH
17268: LD_INT 1
17270: PPUSH
17271: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17275: LD_INT 1785
17277: PPUSH
17278: LD_INT 2345
17280: PPUSH
17281: CALL_OW 12
17285: PPUSH
17286: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17290: LD_ADDR_VAR 0 1
17294: PUSH
17295: LD_INT 1
17297: PPUSH
17298: LD_OWVAR 67
17302: PUSH
17303: LD_INT 2
17305: PLUS
17306: PPUSH
17307: CALL_OW 12
17311: ST_TO_ADDR
// if r < 3 then
17312: LD_VAR 0 1
17316: PUSH
17317: LD_INT 3
17319: LESS
17320: IFFALSE 17343
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17322: LD_INT 4
17324: PPUSH
17325: LD_INT 1
17327: PPUSH
17328: LD_INT 5
17330: PPUSH
17331: CALL_OW 12
17335: PPUSH
17336: LD_INT 1
17338: PPUSH
17339: CALL_OW 55
// end ;
17343: PPOPN 1
17345: END
// every 0 0$01 trigger cornel_active do
17346: LD_EXP 8
17350: IFFALSE 17439
17352: GO 17354
17354: DISABLE
// begin Wait ( 0 0$03 ) ;
17355: LD_INT 105
17357: PPUSH
17358: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17362: LD_INT 2
17364: PPUSH
17365: LD_INT 5
17367: PPUSH
17368: CALL_OW 12
17372: PPUSH
17373: LD_INT 10
17375: PPUSH
17376: LD_INT 1
17378: PPUSH
17379: CALL_OW 55
// Wait ( 0 0$13 ) ;
17383: LD_INT 455
17385: PPUSH
17386: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17390: LD_INT 2
17392: PPUSH
17393: LD_INT 5
17395: PPUSH
17396: CALL_OW 12
17400: PPUSH
17401: LD_INT 10
17403: PPUSH
17404: LD_INT 1
17406: PPUSH
17407: CALL_OW 55
// Wait ( 0 0$16 ) ;
17411: LD_INT 560
17413: PPUSH
17414: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17418: LD_INT 2
17420: PPUSH
17421: LD_INT 5
17423: PPUSH
17424: CALL_OW 12
17428: PPUSH
17429: LD_INT 10
17431: PPUSH
17432: LD_INT 1
17434: PPUSH
17435: CALL_OW 55
// end ; end_of_file
17439: END
// every 0 0$01 trigger cornel_prepared do
17440: LD_EXP 11
17444: IFFALSE 17503
17446: GO 17448
17448: DISABLE
// begin enable ;
17449: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17450: LD_ADDR_OWVAR 47
17454: PUSH
17455: LD_STRING #Am03-1
17457: PUSH
17458: LD_EXP 10
17462: PUSH
17463: EMPTY
17464: LIST
17465: LIST
17466: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17467: LD_ADDR_EXP 10
17471: PUSH
17472: LD_EXP 10
17476: PPUSH
17477: LD_STRING -
17479: PPUSH
17480: CALL 1132 0 2
17484: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17485: LD_EXP 10
17489: PUSH
17490: LD_INT 0
17492: EQUAL
17493: IFFALSE 17503
// begin Display_Strings := [ ] ;
17495: LD_ADDR_OWVAR 47
17499: PUSH
17500: EMPTY
17501: ST_TO_ADDR
// disable ;
17502: DISABLE
// end ; end ;
17503: END
// every 0 0$01 trigger debug and debug_strings do
17504: LD_EXP 1
17508: PUSH
17509: LD_OWVAR 48
17513: AND
17514: IFFALSE 17530
17516: GO 17518
17518: DISABLE
// begin enable ;
17519: ENABLE
// Display_Strings := debug_strings ;
17520: LD_ADDR_OWVAR 47
17524: PUSH
17525: LD_OWVAR 48
17529: ST_TO_ADDR
// end ; end_of_file
17530: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17531: LD_VAR 0 1
17535: PPUSH
17536: CALL_OW 255
17540: PUSH
17541: LD_INT 1
17543: EQUAL
17544: PUSH
17545: LD_EXP 14
17549: NOT
17550: AND
17551: IFFALSE 17561
// solar_builded := true ;
17553: LD_ADDR_EXP 14
17557: PUSH
17558: LD_INT 1
17560: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17561: LD_VAR 0 1
17565: PPUSH
17566: CALL_OW 255
17570: PUSH
17571: LD_INT 1
17573: EQUAL
17574: PUSH
17575: LD_EXP 29
17579: AND
17580: IFFALSE 17613
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17582: LD_ADDR_EXP 29
17586: PUSH
17587: LD_EXP 29
17591: PUSH
17592: LD_INT 1750
17594: PUSH
17595: LD_INT 1400
17597: PUSH
17598: LD_INT 1225
17600: PUSH
17601: EMPTY
17602: LIST
17603: LIST
17604: LIST
17605: PUSH
17606: LD_OWVAR 67
17610: ARRAY
17611: PLUS
17612: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL_OW 255
17622: PUSH
17623: LD_INT 3
17625: EQUAL
17626: IFFALSE 17644
// ru_vehicles := ru_vehicles ^ veh ;
17628: LD_ADDR_EXP 56
17632: PUSH
17633: LD_EXP 56
17637: PUSH
17638: LD_VAR 0 1
17642: ADD
17643: ST_TO_ADDR
// end ;
17644: PPOPN 2
17646: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17647: LD_VAR 0 1
17651: PUSH
17652: LD_EXP 53
17656: IN
17657: IFFALSE 17675
// ru_patrol := ru_patrol diff un ;
17659: LD_ADDR_EXP 53
17663: PUSH
17664: LD_EXP 53
17668: PUSH
17669: LD_VAR 0 1
17673: DIFF
17674: ST_TO_ADDR
// if un in ru_forest then
17675: LD_VAR 0 1
17679: PUSH
17680: LD_EXP 55
17684: IN
17685: IFFALSE 17703
// ru_forest := ru_forest diff un ;
17687: LD_ADDR_EXP 55
17691: PUSH
17692: LD_EXP 55
17696: PUSH
17697: LD_VAR 0 1
17701: DIFF
17702: ST_TO_ADDR
// if un in ru_vehicles then
17703: LD_VAR 0 1
17707: PUSH
17708: LD_EXP 56
17712: IN
17713: IFFALSE 17819
// begin ru_vehicles := ru_vehicles diff un ;
17715: LD_ADDR_EXP 56
17719: PUSH
17720: LD_EXP 56
17724: PUSH
17725: LD_VAR 0 1
17729: DIFF
17730: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17731: LD_ADDR_EXP 57
17735: PUSH
17736: LD_EXP 57
17740: PUSH
17741: LD_VAR 0 1
17745: PPUSH
17746: CALL_OW 265
17750: PUSH
17751: LD_VAR 0 1
17755: PPUSH
17756: CALL_OW 262
17760: PUSH
17761: LD_VAR 0 1
17765: PPUSH
17766: CALL_OW 263
17770: PUSH
17771: LD_VAR 0 1
17775: PPUSH
17776: CALL_OW 264
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: ADD
17787: ST_TO_ADDR
// ach_counter := ach_counter + 1 ;
17788: LD_ADDR_EXP 13
17792: PUSH
17793: LD_EXP 13
17797: PUSH
17798: LD_INT 1
17800: PLUS
17801: ST_TO_ADDR
// if ach_counter = 10 then
17802: LD_EXP 13
17806: PUSH
17807: LD_INT 10
17809: EQUAL
17810: IFFALSE 17819
// SetAchievement ( ACH_FAUST ) ;
17812: LD_STRING ACH_FAUST
17814: PPUSH
17815: CALL_OW 543
// end ; if un = Pokryshkin then
17819: LD_VAR 0 1
17823: PUSH
17824: LD_EXP 52
17828: EQUAL
17829: IFFALSE 17838
// SetAchievement ( ACH_POKR ) ;
17831: LD_STRING ACH_POKR
17833: PPUSH
17834: CALL_OW 543
// if un = JMM then
17838: LD_VAR 0 1
17842: PUSH
17843: LD_EXP 37
17847: EQUAL
17848: IFFALSE 17857
// YouLost ( 0 ) ;
17850: LD_STRING 0
17852: PPUSH
17853: CALL_OW 104
// if un = us_dep_west then
17857: LD_VAR 0 1
17861: PUSH
17862: LD_INT 1
17864: EQUAL
17865: IFFALSE 17874
// YouLost ( 2 ) ;
17867: LD_STRING 2
17869: PPUSH
17870: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17874: LD_VAR 0 1
17878: PPUSH
17879: CALL_OW 255
17883: PUSH
17884: LD_INT 8
17886: EQUAL
17887: PUSH
17888: LD_EXP 5
17892: NOT
17893: AND
17894: IFFALSE 17903
// YouLost ( 4 ) ;
17896: LD_STRING 4
17898: PPUSH
17899: CALL_OW 104
// if un in jmm_units then
17903: LD_VAR 0 1
17907: PUSH
17908: LD_EXP 4
17912: IN
17913: IFFALSE 17929
// lose_counter := lose_counter + 1 ;
17915: LD_ADDR_EXP 34
17919: PUSH
17920: LD_EXP 34
17924: PUSH
17925: LD_INT 1
17927: PLUS
17928: ST_TO_ADDR
// end ;
17929: PPOPN 1
17931: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17932: LD_INT 0
17934: PPUSH
17935: PPUSH
// begin if GetSide ( driver ) = 3 then
17936: LD_VAR 0 1
17940: PPUSH
17941: CALL_OW 255
17945: PUSH
17946: LD_INT 3
17948: EQUAL
17949: IFFALSE 18027
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17951: LD_ADDR_VAR 0 6
17955: PUSH
17956: LD_INT 22
17958: PUSH
17959: LD_INT 3
17961: PUSH
17962: EMPTY
17963: LIST
17964: LIST
17965: PUSH
17966: LD_INT 30
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: EMPTY
17973: LIST
17974: LIST
17975: PUSH
17976: EMPTY
17977: LIST
17978: LIST
17979: PPUSH
17980: CALL_OW 69
17984: PPUSH
17985: CALL 1062 0 1
17989: ST_TO_ADDR
// if place then
17990: LD_VAR 0 6
17994: IFFALSE 18012
// ComEnterUnit ( driver , place ) else
17996: LD_VAR 0 1
18000: PPUSH
18001: LD_VAR 0 6
18005: PPUSH
18006: CALL_OW 120
18010: GO 18027
// ComMoveXY ( driver , 70 , 22 ) ;
18012: LD_VAR 0 1
18016: PPUSH
18017: LD_INT 70
18019: PPUSH
18020: LD_INT 22
18022: PPUSH
18023: CALL_OW 111
// end ; end ;
18027: PPOPN 6
18029: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
18030: LD_VAR 0 1
18034: PUSH
18035: LD_INT 1
18037: EQUAL
18038: PUSH
18039: LD_VAR 0 2
18043: PUSH
18044: LD_INT 4
18046: EQUAL
18047: PUSH
18048: LD_VAR 0 2
18052: PUSH
18053: LD_INT 8
18055: EQUAL
18056: PUSH
18057: LD_EXP 5
18061: NOT
18062: AND
18063: OR
18064: AND
18065: IFFALSE 18074
// YouLost ( 5 ) ;
18067: LD_STRING 5
18069: PPUSH
18070: CALL_OW 104
// end ;
18074: PPOPN 2
18076: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
18077: LD_EXP 36
18081: PUSH
18082: LD_INT 22
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: EMPTY
18089: LIST
18090: LIST
18091: PUSH
18092: LD_INT 21
18094: PUSH
18095: LD_INT 1
18097: PUSH
18098: EMPTY
18099: LIST
18100: LIST
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: PPUSH
18106: CALL_OW 69
18110: PUSH
18111: LD_INT 22
18113: PUSH
18114: LD_INT 8
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: PUSH
18121: LD_INT 21
18123: PUSH
18124: LD_INT 1
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PPUSH
18135: CALL_OW 69
18139: ADD
18140: PLUS
18141: PUSH
18142: LD_INT 5
18144: LESS
18145: IFFALSE 18157
18147: GO 18149
18149: DISABLE
// YouLost ( 1 ) ;
18150: LD_STRING 1
18152: PPUSH
18153: CALL_OW 104
18157: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
18158: LD_INT 1
18160: PPUSH
18161: CALL_OW 255
18165: PUSH
18166: LD_INT 3
18168: EQUAL
18169: IFFALSE 18181
18171: GO 18173
18173: DISABLE
// YouLost ( 3 ) ; end_of_file
18174: LD_STRING 3
18176: PPUSH
18177: CALL_OW 104
18181: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18182: GO 18184
18184: DISABLE
// begin ru_radar := 98 ;
18185: LD_ADDR_EXP 62
18189: PUSH
18190: LD_INT 98
18192: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18193: LD_ADDR_EXP 63
18197: PUSH
18198: LD_INT 89
18200: ST_TO_ADDR
// us_hack := 99 ;
18201: LD_ADDR_EXP 64
18205: PUSH
18206: LD_INT 99
18208: ST_TO_ADDR
// us_artillery := 97 ;
18209: LD_ADDR_EXP 65
18213: PUSH
18214: LD_INT 97
18216: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18217: LD_ADDR_EXP 66
18221: PUSH
18222: LD_INT 91
18224: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
18225: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
18226: LD_INT 0
18228: PPUSH
18229: PPUSH
18230: PPUSH
18231: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18232: LD_VAR 0 1
18236: PPUSH
18237: CALL_OW 264
18241: PUSH
18242: LD_EXP 66
18246: EQUAL
18247: IFFALSE 18319
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18249: LD_INT 68
18251: PPUSH
18252: LD_VAR 0 1
18256: PPUSH
18257: CALL_OW 255
18261: PPUSH
18262: CALL_OW 321
18266: PUSH
18267: LD_INT 2
18269: EQUAL
18270: IFFALSE 18282
// eff := 70 else
18272: LD_ADDR_VAR 0 6
18276: PUSH
18277: LD_INT 70
18279: ST_TO_ADDR
18280: GO 18290
// eff := 30 ;
18282: LD_ADDR_VAR 0 6
18286: PUSH
18287: LD_INT 30
18289: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18290: LD_VAR 0 1
18294: PPUSH
18295: CALL_OW 250
18299: PPUSH
18300: LD_VAR 0 1
18304: PPUSH
18305: CALL_OW 251
18309: PPUSH
18310: LD_VAR 0 6
18314: PPUSH
18315: CALL_OW 495
// end ; end ;
18319: LD_VAR 0 4
18323: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18324: LD_INT 0
18326: PPUSH
18327: PPUSH
18328: PPUSH
18329: PPUSH
18330: PPUSH
18331: PPUSH
// if cmd = 124 then
18332: LD_VAR 0 1
18336: PUSH
18337: LD_INT 124
18339: EQUAL
18340: IFFALSE 18546
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18342: LD_ADDR_VAR 0 5
18346: PUSH
18347: LD_INT 2
18349: PUSH
18350: LD_INT 34
18352: PUSH
18353: LD_INT 53
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 34
18362: PUSH
18363: LD_INT 14
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: PUSH
18370: EMPTY
18371: LIST
18372: LIST
18373: LIST
18374: PPUSH
18375: CALL_OW 69
18379: ST_TO_ADDR
// if not tmp then
18380: LD_VAR 0 5
18384: NOT
18385: IFFALSE 18389
// exit ;
18387: GO 18546
// for i in tmp do
18389: LD_ADDR_VAR 0 3
18393: PUSH
18394: LD_VAR 0 5
18398: PUSH
18399: FOR_IN
18400: IFFALSE 18544
// begin taskList := GetTaskList ( i ) ;
18402: LD_ADDR_VAR 0 6
18406: PUSH
18407: LD_VAR 0 3
18411: PPUSH
18412: CALL_OW 437
18416: ST_TO_ADDR
// if not taskList then
18417: LD_VAR 0 6
18421: NOT
18422: IFFALSE 18426
// continue ;
18424: GO 18399
// for j = 1 to taskList do
18426: LD_ADDR_VAR 0 4
18430: PUSH
18431: DOUBLE
18432: LD_INT 1
18434: DEC
18435: ST_TO_ADDR
18436: LD_VAR 0 6
18440: PUSH
18441: FOR_TO
18442: IFFALSE 18540
// if taskList [ j ] [ 1 ] = | then
18444: LD_VAR 0 6
18448: PUSH
18449: LD_VAR 0 4
18453: ARRAY
18454: PUSH
18455: LD_INT 1
18457: ARRAY
18458: PUSH
18459: LD_STRING |
18461: EQUAL
18462: IFFALSE 18538
// begin _taskList := Delete ( taskList , 1 ) ;
18464: LD_ADDR_VAR 0 7
18468: PUSH
18469: LD_VAR 0 6
18473: PPUSH
18474: LD_INT 1
18476: PPUSH
18477: CALL_OW 3
18481: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18482: LD_VAR 0 3
18486: PPUSH
18487: LD_VAR 0 7
18491: PPUSH
18492: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18496: LD_VAR 0 3
18500: PPUSH
18501: LD_VAR 0 6
18505: PUSH
18506: LD_VAR 0 4
18510: ARRAY
18511: PUSH
18512: LD_INT 2
18514: ARRAY
18515: PPUSH
18516: LD_VAR 0 6
18520: PUSH
18521: LD_VAR 0 4
18525: ARRAY
18526: PUSH
18527: LD_INT 3
18529: ARRAY
18530: PPUSH
18531: LD_INT 8
18533: PPUSH
18534: CALL 18551 0 4
// end ;
18538: GO 18441
18540: POP
18541: POP
// end ;
18542: GO 18399
18544: POP
18545: POP
// end ; end ;
18546: LD_VAR 0 2
18550: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18551: LD_INT 0
18553: PPUSH
18554: PPUSH
18555: PPUSH
18556: PPUSH
18557: PPUSH
18558: PPUSH
18559: PPUSH
18560: PPUSH
18561: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18562: LD_VAR 0 1
18566: NOT
18567: PUSH
18568: LD_VAR 0 2
18572: PPUSH
18573: LD_VAR 0 3
18577: PPUSH
18578: CALL_OW 488
18582: NOT
18583: OR
18584: PUSH
18585: LD_VAR 0 4
18589: NOT
18590: OR
18591: IFFALSE 18595
// exit ;
18593: GO 18935
// list := [ ] ;
18595: LD_ADDR_VAR 0 13
18599: PUSH
18600: EMPTY
18601: ST_TO_ADDR
// if x - r < 0 then
18602: LD_VAR 0 2
18606: PUSH
18607: LD_VAR 0 4
18611: MINUS
18612: PUSH
18613: LD_INT 0
18615: LESS
18616: IFFALSE 18628
// min_x := 0 else
18618: LD_ADDR_VAR 0 7
18622: PUSH
18623: LD_INT 0
18625: ST_TO_ADDR
18626: GO 18644
// min_x := x - r ;
18628: LD_ADDR_VAR 0 7
18632: PUSH
18633: LD_VAR 0 2
18637: PUSH
18638: LD_VAR 0 4
18642: MINUS
18643: ST_TO_ADDR
// if y - r < 0 then
18644: LD_VAR 0 3
18648: PUSH
18649: LD_VAR 0 4
18653: MINUS
18654: PUSH
18655: LD_INT 0
18657: LESS
18658: IFFALSE 18670
// min_y := 0 else
18660: LD_ADDR_VAR 0 8
18664: PUSH
18665: LD_INT 0
18667: ST_TO_ADDR
18668: GO 18686
// min_y := y - r ;
18670: LD_ADDR_VAR 0 8
18674: PUSH
18675: LD_VAR 0 3
18679: PUSH
18680: LD_VAR 0 4
18684: MINUS
18685: ST_TO_ADDR
// max_x := x + r ;
18686: LD_ADDR_VAR 0 9
18690: PUSH
18691: LD_VAR 0 2
18695: PUSH
18696: LD_VAR 0 4
18700: PLUS
18701: ST_TO_ADDR
// max_y := y + r ;
18702: LD_ADDR_VAR 0 10
18706: PUSH
18707: LD_VAR 0 3
18711: PUSH
18712: LD_VAR 0 4
18716: PLUS
18717: ST_TO_ADDR
// for _x = min_x to max_x do
18718: LD_ADDR_VAR 0 11
18722: PUSH
18723: DOUBLE
18724: LD_VAR 0 7
18728: DEC
18729: ST_TO_ADDR
18730: LD_VAR 0 9
18734: PUSH
18735: FOR_TO
18736: IFFALSE 18853
// for _y = min_y to max_y do
18738: LD_ADDR_VAR 0 12
18742: PUSH
18743: DOUBLE
18744: LD_VAR 0 8
18748: DEC
18749: ST_TO_ADDR
18750: LD_VAR 0 10
18754: PUSH
18755: FOR_TO
18756: IFFALSE 18849
// begin if not ValidHex ( _x , _y ) then
18758: LD_VAR 0 11
18762: PPUSH
18763: LD_VAR 0 12
18767: PPUSH
18768: CALL_OW 488
18772: NOT
18773: IFFALSE 18777
// continue ;
18775: GO 18755
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18777: LD_VAR 0 11
18781: PPUSH
18782: LD_VAR 0 12
18786: PPUSH
18787: CALL_OW 351
18791: PUSH
18792: LD_VAR 0 11
18796: PPUSH
18797: LD_VAR 0 12
18801: PPUSH
18802: CALL_OW 554
18806: AND
18807: IFFALSE 18847
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18809: LD_ADDR_VAR 0 13
18813: PUSH
18814: LD_VAR 0 13
18818: PPUSH
18819: LD_VAR 0 13
18823: PUSH
18824: LD_INT 1
18826: PLUS
18827: PPUSH
18828: LD_VAR 0 11
18832: PUSH
18833: LD_VAR 0 12
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PPUSH
18842: CALL_OW 2
18846: ST_TO_ADDR
// end ;
18847: GO 18755
18849: POP
18850: POP
18851: GO 18735
18853: POP
18854: POP
// if not list then
18855: LD_VAR 0 13
18859: NOT
18860: IFFALSE 18864
// exit ;
18862: GO 18935
// for i in list do
18864: LD_ADDR_VAR 0 6
18868: PUSH
18869: LD_VAR 0 13
18873: PUSH
18874: FOR_IN
18875: IFFALSE 18933
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18877: LD_VAR 0 1
18881: PPUSH
18882: LD_STRING M
18884: PUSH
18885: LD_VAR 0 6
18889: PUSH
18890: LD_INT 1
18892: ARRAY
18893: PUSH
18894: LD_VAR 0 6
18898: PUSH
18899: LD_INT 2
18901: ARRAY
18902: PUSH
18903: LD_INT 0
18905: PUSH
18906: LD_INT 0
18908: PUSH
18909: LD_INT 0
18911: PUSH
18912: LD_INT 0
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: PUSH
18924: EMPTY
18925: LIST
18926: PPUSH
18927: CALL_OW 447
18931: GO 18874
18933: POP
18934: POP
// end ;
18935: LD_VAR 0 5
18939: RET
