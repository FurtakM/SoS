// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 50 0 0
// SetDiplomacy ;
  15: CALL 370 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 29
// DebugMode ;
  25: CALL 458 0 0
// PrepareRussian ;
  29: CALL 3015 0 0
// PrepareAmerican ;
  33: CALL 1220 0 0
// PrepareCornell ;
  37: CALL 2244 0 0
// PrepareWesternBase ;
  41: CALL 2470 0 0
// Action ;
  45: CALL 5231 0 0
// end ;
  49: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  50: LD_INT 0
  52: PPUSH
// debug := false ;
  53: LD_ADDR_EXP 1
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  61: LD_ADDR_EXP 3
  65: PUSH
  66: LD_STRING 02_
  68: ST_TO_ADDR
// mission_prefix := 03_ ;
  69: LD_ADDR_EXP 2
  73: PUSH
  74: LD_STRING 03_
  76: ST_TO_ADDR
// jmm_units := 0 ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// cornel_units := 0 ;
  85: LD_ADDR_EXP 6
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// bierezov_exist := false ;
  93: LD_ADDR_EXP 7
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// jmm_on_west := false ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// cornel_active := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// cornel_attack := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// cornel_prepared := false ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 133: LD_ADDR_EXP 10
 137: PUSH
 138: LD_INT 4200
 140: ST_TO_ADDR
// frank_can_return := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// solar_builded := false ;
 149: LD_ADDR_EXP 13
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// frank_send_to_scout := false ;
 157: LD_ADDR_EXP 14
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// jmm_in_veh := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// bobby_in_veh := false ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// cyrus_in_veh := false ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// lisa_in_veh := false ;
 189: LD_ADDR_EXP 18
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 197: LD_ADDR_EXP 28
 201: PUSH
 202: LD_INT 25200
 204: PUSH
 205: LD_INT 23100
 207: PUSH
 208: LD_INT 21000
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_OWVAR 67
 220: ARRAY
 221: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 222: LD_ADDR_EXP 19
 226: PUSH
 227: LD_INT 600
 229: PUSH
 230: LD_INT 500
 232: PUSH
 233: LD_INT 400
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_OWVAR 67
 245: ARRAY
 246: ST_TO_ADDR
// end_mission_allowed := false ;
 247: LD_ADDR_EXP 20
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// save_others := [ ] ;
 255: LD_ADDR_EXP 21
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// save_group := [ ] ;
 262: LD_ADDR_EXP 22
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// show_query := true ;
 269: LD_ADDR_EXP 23
 273: PUSH
 274: LD_INT 1
 276: ST_TO_ADDR
// wait_for_them := false ;
 277: LD_ADDR_EXP 24
 281: PUSH
 282: LD_INT 0
 284: ST_TO_ADDR
// veh_on_meta := false ;
 285: LD_ADDR_EXP 27
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// send_spec_patrol := false ;
 293: LD_ADDR_EXP 29
 297: PUSH
 298: LD_INT 0
 300: ST_TO_ADDR
// prepare_siege := false ;
 301: LD_ADDR_EXP 30
 305: PUSH
 306: LD_INT 0
 308: ST_TO_ADDR
// send_attack_on_cornel := false ;
 309: LD_ADDR_EXP 31
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 317: LD_ADDR_EXP 25
 321: PUSH
 322: LD_INT 0
 324: ST_TO_ADDR
// game_end := false ;
 325: LD_ADDR_EXP 32
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// lose_counter := 0 ;
 333: LD_ADDR_EXP 33
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// powell_warn := 0 ;
 341: LD_ADDR_EXP 34
 345: PUSH
 346: LD_INT 0
 348: ST_TO_ADDR
// save_counter := 0 ;
 349: LD_ADDR_EXP 35
 353: PUSH
 354: LD_INT 0
 356: ST_TO_ADDR
// cornel_saved := false ;
 357: LD_ADDR_EXP 26
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// end ;
 365: LD_VAR 0 1
 369: RET
// function SetDiplomacy ; begin
 370: LD_INT 0
 372: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 373: LD_INT 1
 375: PPUSH
 376: LD_INT 4
 378: PPUSH
 379: LD_INT 1
 381: PPUSH
 382: LD_INT 1
 384: PPUSH
 385: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 389: LD_INT 1
 391: PPUSH
 392: LD_INT 8
 394: PPUSH
 395: LD_INT 1
 397: PPUSH
 398: LD_INT 1
 400: PPUSH
 401: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 405: LD_INT 3
 407: PPUSH
 408: LD_INT 6
 410: PPUSH
 411: LD_INT 1
 413: PPUSH
 414: LD_INT 1
 416: PPUSH
 417: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 421: LD_INT 4
 423: PPUSH
 424: LD_INT 6
 426: PPUSH
 427: LD_INT 0
 429: PPUSH
 430: LD_INT 1
 432: PPUSH
 433: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 437: LD_INT 3
 439: PPUSH
 440: LD_INT 8
 442: PPUSH
 443: LD_INT 0
 445: PPUSH
 446: LD_INT 1
 448: PPUSH
 449: CALL_OW 80
// end ;
 453: LD_VAR 0 1
 457: RET
// export function DebugMode ; var i ; begin
 458: LD_INT 0
 460: PPUSH
 461: PPUSH
// FogOff ( 1 ) ;
 462: LD_INT 1
 464: PPUSH
 465: CALL_OW 344
// debug_strings := [ ] ;
 469: LD_ADDR_OWVAR 48
 473: PUSH
 474: EMPTY
 475: ST_TO_ADDR
// end ; end_of_file
 476: LD_VAR 0 1
 480: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 481: LD_INT 0
 483: PPUSH
 484: PPUSH
// if exist_mode then
 485: LD_VAR 0 2
 489: IFFALSE 514
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 491: LD_ADDR_VAR 0 4
 495: PUSH
 496: LD_EXP 3
 500: PUSH
 501: LD_VAR 0 1
 505: STR
 506: PPUSH
 507: CALL_OW 34
 511: ST_TO_ADDR
 512: GO 529
// unit := NewCharacter ( ident ) ;
 514: LD_ADDR_VAR 0 4
 518: PUSH
 519: LD_VAR 0 1
 523: PPUSH
 524: CALL_OW 25
 528: ST_TO_ADDR
// result := unit ;
 529: LD_ADDR_VAR 0 3
 533: PUSH
 534: LD_VAR 0 4
 538: ST_TO_ADDR
// end ;
 539: LD_VAR 0 3
 543: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 544: LD_INT 0
 546: PPUSH
// uc_side := side ;
 547: LD_ADDR_OWVAR 20
 551: PUSH
 552: LD_VAR 0 1
 556: ST_TO_ADDR
// uc_nation := nation ;
 557: LD_ADDR_OWVAR 21
 561: PUSH
 562: LD_VAR 0 2
 566: ST_TO_ADDR
// vc_chassis := chassis ;
 567: LD_ADDR_OWVAR 37
 571: PUSH
 572: LD_VAR 0 3
 576: ST_TO_ADDR
// vc_engine := engine ;
 577: LD_ADDR_OWVAR 39
 581: PUSH
 582: LD_VAR 0 4
 586: ST_TO_ADDR
// vc_control := control ;
 587: LD_ADDR_OWVAR 38
 591: PUSH
 592: LD_VAR 0 5
 596: ST_TO_ADDR
// vc_weapon := weapon ;
 597: LD_ADDR_OWVAR 40
 601: PUSH
 602: LD_VAR 0 6
 606: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 607: LD_ADDR_OWVAR 41
 611: PUSH
 612: LD_VAR 0 7
 616: ST_TO_ADDR
// result := CreateVehicle ;
 617: LD_ADDR_VAR 0 8
 621: PUSH
 622: CALL_OW 45
 626: ST_TO_ADDR
// end ;
 627: LD_VAR 0 8
 631: RET
// export function SayX ( units , ident ) ; var i ; begin
 632: LD_INT 0
 634: PPUSH
 635: PPUSH
// result := false ;
 636: LD_ADDR_VAR 0 3
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// if not units then
 644: LD_VAR 0 1
 648: NOT
 649: IFFALSE 653
// exit ;
 651: GO 707
// for i in units do
 653: LD_ADDR_VAR 0 4
 657: PUSH
 658: LD_VAR 0 1
 662: PUSH
 663: FOR_IN
 664: IFFALSE 705
// if IsOk ( i ) then
 666: LD_VAR 0 4
 670: PPUSH
 671: CALL_OW 302
 675: IFFALSE 703
// begin Say ( i , ident ) ;
 677: LD_VAR 0 4
 681: PPUSH
 682: LD_VAR 0 2
 686: PPUSH
 687: CALL_OW 88
// result := i ;
 691: LD_ADDR_VAR 0 3
 695: PUSH
 696: LD_VAR 0 4
 700: ST_TO_ADDR
// break ;
 701: GO 705
// end ;
 703: GO 663
 705: POP
 706: POP
// end ;
 707: LD_VAR 0 3
 711: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 712: LD_INT 0
 714: PPUSH
 715: PPUSH
 716: PPUSH
 717: PPUSH
// for i = 1 to count do
 718: LD_ADDR_VAR 0 8
 722: PUSH
 723: DOUBLE
 724: LD_INT 1
 726: DEC
 727: ST_TO_ADDR
 728: LD_VAR 0 6
 732: PUSH
 733: FOR_TO
 734: IFFALSE 815
// begin uc_side = side ;
 736: LD_ADDR_OWVAR 20
 740: PUSH
 741: LD_VAR 0 1
 745: ST_TO_ADDR
// uc_nation = nation ;
 746: LD_ADDR_OWVAR 21
 750: PUSH
 751: LD_VAR 0 2
 755: ST_TO_ADDR
// hc_gallery =  ;
 756: LD_ADDR_OWVAR 33
 760: PUSH
 761: LD_STRING 
 763: ST_TO_ADDR
// hc_name =  ;
 764: LD_ADDR_OWVAR 26
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 772: LD_INT 0
 774: PPUSH
 775: LD_VAR 0 5
 779: PPUSH
 780: LD_VAR 0 4
 784: PPUSH
 785: CALL_OW 380
// un = CreateHuman ;
 789: LD_ADDR_VAR 0 10
 793: PUSH
 794: CALL_OW 44
 798: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 799: LD_VAR 0 10
 803: PPUSH
 804: LD_VAR 0 3
 808: PPUSH
 809: CALL_OW 52
// end ;
 813: GO 733
 815: POP
 816: POP
// end ;
 817: LD_VAR 0 7
 821: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 822: LD_INT 0
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := GetSide ( b ) ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_VAR 0 2
 836: PPUSH
 837: CALL_OW 255
 841: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 842: LD_ADDR_OWVAR 21
 846: PUSH
 847: LD_VAR 0 2
 851: PPUSH
 852: CALL_OW 248
 856: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 857: LD_INT 0
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_VAR 0 1
 867: PPUSH
 868: CALL_OW 380
// un = CreateHuman ;
 872: LD_ADDR_VAR 0 4
 876: PUSH
 877: CALL_OW 44
 881: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 882: LD_ADDR_VAR 0 5
 886: PUSH
 887: LD_VAR 0 2
 891: PPUSH
 892: CALL_OW 254
 896: PUSH
 897: LD_INT 3
 899: MINUS
 900: ST_TO_ADDR
// if dir < 0 then
 901: LD_VAR 0 5
 905: PUSH
 906: LD_INT 0
 908: LESS
 909: IFFALSE 925
// dir := 6 + dir ;
 911: LD_ADDR_VAR 0 5
 915: PUSH
 916: LD_INT 6
 918: PUSH
 919: LD_VAR 0 5
 923: PLUS
 924: ST_TO_ADDR
// SetDir ( un , dir ) ;
 925: LD_VAR 0 4
 929: PPUSH
 930: LD_VAR 0 5
 934: PPUSH
 935: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 939: LD_VAR 0 4
 943: PPUSH
 944: LD_VAR 0 2
 948: PPUSH
 949: CALL_OW 52
// end ;
 953: LD_VAR 0 3
 957: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 958: LD_INT 0
 960: PPUSH
 961: PPUSH
 962: PPUSH
// result := false ;
 963: LD_ADDR_VAR 0 2
 967: PUSH
 968: LD_INT 0
 970: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 971: LD_ADDR_VAR 0 3
 975: PUSH
 976: LD_INT 22
 978: PUSH
 979: LD_INT 1
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 34
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL_OW 69
1004: ST_TO_ADDR
// for i in filter do
1005: LD_ADDR_VAR 0 4
1009: PUSH
1010: LD_VAR 0 3
1014: PUSH
1015: FOR_IN
1016: IFFALSE 1047
// if IsDrivenBy ( i ) = unit then
1018: LD_VAR 0 4
1022: PPUSH
1023: CALL_OW 311
1027: PUSH
1028: LD_VAR 0 1
1032: EQUAL
1033: IFFALSE 1045
// begin result := true ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ST_TO_ADDR
// break ;
1043: GO 1047
// end ;
1045: GO 1015
1047: POP
1048: POP
// end ;
1049: LD_VAR 0 2
1053: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1054: LD_INT 0
1056: PPUSH
1057: PPUSH
// result := false ;
1058: LD_ADDR_VAR 0 2
1062: PUSH
1063: LD_INT 0
1065: ST_TO_ADDR
// if not blist then
1066: LD_VAR 0 1
1070: NOT
1071: IFFALSE 1075
// exit ;
1073: GO 1119
// for i in blist do
1075: LD_ADDR_VAR 0 3
1079: PUSH
1080: LD_VAR 0 1
1084: PUSH
1085: FOR_IN
1086: IFFALSE 1117
// if UnitsInside ( i ) < 6 then
1088: LD_VAR 0 3
1092: PPUSH
1093: CALL_OW 313
1097: PUSH
1098: LD_INT 6
1100: LESS
1101: IFFALSE 1115
// begin result := i ;
1103: LD_ADDR_VAR 0 2
1107: PUSH
1108: LD_VAR 0 3
1112: ST_TO_ADDR
// break ;
1113: GO 1117
// end ;
1115: GO 1085
1117: POP
1118: POP
// end ;
1119: LD_VAR 0 2
1123: RET
// export function Count ( timer , mode ) ; begin
1124: LD_INT 0
1126: PPUSH
// if not timer then
1127: LD_VAR 0 1
1131: NOT
1132: IFFALSE 1136
// exit ;
1134: GO 1187
// if mode in [ asc , up , + ] then
1136: LD_VAR 0 2
1140: PUSH
1141: LD_STRING asc
1143: PUSH
1144: LD_STRING up
1146: PUSH
1147: LD_STRING +
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: IN
1155: IFFALSE 1173
// result := timer + 0 0$01 else
1157: LD_ADDR_VAR 0 3
1161: PUSH
1162: LD_VAR 0 1
1166: PUSH
1167: LD_INT 35
1169: PLUS
1170: ST_TO_ADDR
1171: GO 1187
// result := timer - 0 0$01 ;
1173: LD_ADDR_VAR 0 3
1177: PUSH
1178: LD_VAR 0 1
1182: PUSH
1183: LD_INT 35
1185: MINUS
1186: ST_TO_ADDR
// end ;
1187: LD_VAR 0 3
1191: RET
// export function Video ( mode ) ; begin
1192: LD_INT 0
1194: PPUSH
// ingame_video = mode ;
1195: LD_ADDR_OWVAR 52
1199: PUSH
1200: LD_VAR 0 1
1204: ST_TO_ADDR
// interface_hidden = mode ;
1205: LD_ADDR_OWVAR 54
1209: PUSH
1210: LD_VAR 0 1
1214: ST_TO_ADDR
// end ; end_of_file
1215: LD_VAR 0 2
1219: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1220: LD_INT 0
1222: PPUSH
1223: PPUSH
1224: PPUSH
1225: PPUSH
1226: PPUSH
1227: PPUSH
1228: PPUSH
1229: PPUSH
// uc_side := 4 ;
1230: LD_ADDR_OWVAR 20
1234: PUSH
1235: LD_INT 4
1237: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1238: LD_ADDR_EXP 45
1242: PUSH
1243: LD_STRING Powell
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL 481 0 2
1253: ST_TO_ADDR
// uc_side := 1 ;
1254: LD_ADDR_OWVAR 20
1258: PUSH
1259: LD_INT 1
1261: ST_TO_ADDR
// uc_nation := 1 ;
1262: LD_ADDR_OWVAR 21
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
// if debug then
1270: LD_EXP 1
1274: IFFALSE 1404
// begin for i = 1 to 4 do
1276: LD_ADDR_VAR 0 2
1280: PUSH
1281: DOUBLE
1282: LD_INT 1
1284: DEC
1285: ST_TO_ADDR
1286: LD_INT 4
1288: PUSH
1289: FOR_TO
1290: IFFALSE 1341
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1292: LD_INT 0
1294: PPUSH
1295: LD_INT 1
1297: PPUSH
1298: LD_INT 2
1300: PPUSH
1301: CALL_OW 12
1305: PPUSH
1306: LD_INT 3
1308: PPUSH
1309: CALL_OW 380
// un := CreateHuman ;
1313: LD_ADDR_VAR 0 3
1317: PUSH
1318: CALL_OW 44
1322: ST_TO_ADDR
// others := others ^ un ;
1323: LD_ADDR_VAR 0 5
1327: PUSH
1328: LD_VAR 0 5
1332: PUSH
1333: LD_VAR 0 3
1337: ADD
1338: ST_TO_ADDR
// end ;
1339: GO 1289
1341: POP
1342: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1343: LD_ADDR_VAR 0 6
1347: PUSH
1348: LD_INT 21
1350: PUSH
1351: LD_INT 1
1353: PUSH
1354: LD_INT 1
1356: PUSH
1357: LD_INT 51
1359: PUSH
1360: LD_INT 90
1362: PUSH
1363: LD_INT 504
1365: PUSH
1366: EMPTY
1367: LIST
1368: LIST
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 21
1376: PUSH
1377: LD_INT 1
1379: PUSH
1380: LD_INT 1
1382: PUSH
1383: LD_INT 51
1385: PUSH
1386: LD_INT 80
1388: PUSH
1389: LD_INT 750
1391: PUSH
1392: EMPTY
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1404: LD_ADDR_EXP 36
1408: PUSH
1409: LD_STRING JMM
1411: PPUSH
1412: LD_EXP 1
1416: NOT
1417: PPUSH
1418: CALL 481 0 2
1422: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1423: LD_ADDR_EXP 37
1427: PUSH
1428: LD_STRING Bobby
1430: PPUSH
1431: LD_EXP 1
1435: NOT
1436: PPUSH
1437: CALL 481 0 2
1441: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1442: LD_ADDR_EXP 38
1446: PUSH
1447: LD_STRING Cyrus
1449: PPUSH
1450: LD_EXP 1
1454: NOT
1455: PPUSH
1456: CALL 481 0 2
1460: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1461: LD_ADDR_EXP 39
1465: PUSH
1466: LD_STRING Lisa
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: CALL 481 0 2
1479: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1480: LD_ADDR_EXP 40
1484: PUSH
1485: LD_STRING Khatam
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: CALL 481 0 2
1498: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1499: LD_ADDR_EXP 41
1503: PUSH
1504: LD_STRING Brian
1506: PPUSH
1507: LD_EXP 1
1511: NOT
1512: PPUSH
1513: CALL 481 0 2
1517: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1518: LD_ADDR_EXP 42
1522: PUSH
1523: LD_STRING Jerry
1525: PPUSH
1526: LD_EXP 1
1530: NOT
1531: PPUSH
1532: CALL 481 0 2
1536: ST_TO_ADDR
// if Bobby then
1537: LD_EXP 37
1541: IFFALSE 1572
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1543: LD_ADDR_VAR 0 4
1547: PUSH
1548: LD_VAR 0 4
1552: PPUSH
1553: LD_VAR 0 4
1557: PUSH
1558: LD_INT 1
1560: PLUS
1561: PPUSH
1562: LD_EXP 37
1566: PPUSH
1567: CALL_OW 2
1571: ST_TO_ADDR
// if Cyrus then
1572: LD_EXP 38
1576: IFFALSE 1607
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1578: LD_ADDR_VAR 0 4
1582: PUSH
1583: LD_VAR 0 4
1587: PPUSH
1588: LD_VAR 0 4
1592: PUSH
1593: LD_INT 1
1595: PLUS
1596: PPUSH
1597: LD_EXP 38
1601: PPUSH
1602: CALL_OW 2
1606: ST_TO_ADDR
// if Lisa then
1607: LD_EXP 39
1611: IFFALSE 1642
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1613: LD_ADDR_VAR 0 4
1617: PUSH
1618: LD_VAR 0 4
1622: PPUSH
1623: LD_VAR 0 4
1627: PUSH
1628: LD_INT 1
1630: PLUS
1631: PPUSH
1632: LD_EXP 39
1636: PPUSH
1637: CALL_OW 2
1641: ST_TO_ADDR
// if Khatam then
1642: LD_EXP 40
1646: IFFALSE 1677
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_VAR 0 4
1657: PPUSH
1658: LD_VAR 0 4
1662: PUSH
1663: LD_INT 1
1665: PLUS
1666: PPUSH
1667: LD_EXP 40
1671: PPUSH
1672: CALL_OW 2
1676: ST_TO_ADDR
// if Brian then
1677: LD_EXP 41
1681: IFFALSE 1712
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_VAR 0 4
1692: PPUSH
1693: LD_VAR 0 4
1697: PUSH
1698: LD_INT 1
1700: PLUS
1701: PPUSH
1702: LD_EXP 41
1706: PPUSH
1707: CALL_OW 2
1711: ST_TO_ADDR
// if Jerry then
1712: LD_EXP 42
1716: IFFALSE 1747
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1718: LD_ADDR_VAR 0 4
1722: PUSH
1723: LD_VAR 0 4
1727: PPUSH
1728: LD_VAR 0 4
1732: PUSH
1733: LD_INT 1
1735: PLUS
1736: PPUSH
1737: LD_EXP 42
1741: PPUSH
1742: CALL_OW 2
1746: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1747: LD_STRING 02_other_survivors
1749: PPUSH
1750: CALL_OW 28
1754: IFFALSE 1769
// others := CreateCharacterSet ( 02_other_survivors ) ;
1756: LD_ADDR_VAR 0 5
1760: PUSH
1761: LD_STRING 02_other_survivors
1763: PPUSH
1764: CALL_OW 31
1768: ST_TO_ADDR
// if others then
1769: LD_VAR 0 5
1773: IFFALSE 1798
// begin tmp := tmp ^ others ;
1775: LD_ADDR_VAR 0 4
1779: PUSH
1780: LD_VAR 0 4
1784: PUSH
1785: LD_VAR 0 5
1789: ADD
1790: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1791: LD_STRING 02_other_survivors
1793: PPUSH
1794: CALL_OW 40
// end ; jmm_units := tmp ;
1798: LD_ADDR_EXP 4
1802: PUSH
1803: LD_VAR 0 4
1807: ST_TO_ADDR
// if not vehicles then
1808: LD_VAR 0 6
1812: NOT
1813: IFFALSE 1831
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1815: LD_ADDR_VAR 0 6
1819: PUSH
1820: LD_STRING 02_tanks_1
1822: PPUSH
1823: LD_INT 0
1825: PPUSH
1826: CALL_OW 30
1830: ST_TO_ADDR
// if vehicles then
1831: LD_VAR 0 6
1835: IFFALSE 2029
// begin got_mech := false ;
1837: LD_ADDR_VAR 0 7
1841: PUSH
1842: LD_INT 0
1844: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 25
1852: PUSH
1853: LD_INT 3
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: PPUSH
1860: CALL_OW 72
1864: IFFALSE 1874
// got_mech := true ;
1866: LD_ADDR_VAR 0 7
1870: PUSH
1871: LD_INT 1
1873: ST_TO_ADDR
// for i = 1 to vehicles do
1874: LD_ADDR_VAR 0 2
1878: PUSH
1879: DOUBLE
1880: LD_INT 1
1882: DEC
1883: ST_TO_ADDR
1884: LD_VAR 0 6
1888: PUSH
1889: FOR_TO
1890: IFFALSE 2027
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1892: LD_ADDR_VAR 0 3
1896: PUSH
1897: LD_INT 1
1899: PPUSH
1900: LD_INT 3
1902: PPUSH
1903: LD_VAR 0 6
1907: PUSH
1908: LD_VAR 0 2
1912: ARRAY
1913: PUSH
1914: LD_INT 1
1916: ARRAY
1917: PPUSH
1918: LD_VAR 0 6
1922: PUSH
1923: LD_VAR 0 2
1927: ARRAY
1928: PUSH
1929: LD_INT 2
1931: ARRAY
1932: PPUSH
1933: LD_VAR 0 6
1937: PUSH
1938: LD_VAR 0 2
1942: ARRAY
1943: PUSH
1944: LD_INT 3
1946: ARRAY
1947: PPUSH
1948: LD_VAR 0 6
1952: PUSH
1953: LD_VAR 0 2
1957: ARRAY
1958: PUSH
1959: LD_INT 4
1961: ARRAY
1962: PPUSH
1963: LD_INT 40
1965: PPUSH
1966: CALL 544 0 7
1970: ST_TO_ADDR
// if not got_mech then
1971: LD_VAR 0 7
1975: NOT
1976: IFFALSE 2002
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1978: LD_VAR 0 3
1982: PPUSH
1983: LD_VAR 0 6
1987: PUSH
1988: LD_VAR 0 2
1992: ARRAY
1993: PUSH
1994: LD_INT 6
1996: ARRAY
1997: PPUSH
1998: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PPUSH
2012: LD_INT 1
2014: PPUSH
2015: LD_VAR 0 3
2019: PPUSH
2020: CALL_OW 2
2024: ST_TO_ADDR
// end ;
2025: GO 1889
2027: POP
2028: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2029: LD_EXP 36
2033: PPUSH
2034: LD_INT 194
2036: PPUSH
2037: LD_INT 119
2039: PPUSH
2040: LD_INT 0
2042: PPUSH
2043: CALL_OW 48
// if tmp then
2047: LD_VAR 0 4
2051: IFFALSE 2176
// begin for i in tmp do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: LD_VAR 0 4
2062: PUSH
2063: FOR_IN
2064: IFFALSE 2174
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2066: LD_ADDR_VAR 0 8
2070: PUSH
2071: LD_INT 22
2073: PUSH
2074: LD_INT 1
2076: PUSH
2077: EMPTY
2078: LIST
2079: LIST
2080: PUSH
2081: LD_INT 21
2083: PUSH
2084: LD_INT 2
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: PUSH
2091: LD_INT 58
2093: PUSH
2094: EMPTY
2095: LIST
2096: PUSH
2097: EMPTY
2098: LIST
2099: LIST
2100: LIST
2101: PPUSH
2102: CALL_OW 69
2106: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2107: LD_VAR 0 2
2111: PPUSH
2112: CALL_OW 247
2116: PUSH
2117: LD_INT 1
2119: EQUAL
2120: PUSH
2121: LD_VAR 0 8
2125: AND
2126: IFFALSE 2148
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2128: LD_VAR 0 2
2132: PPUSH
2133: LD_VAR 0 8
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: CALL_OW 52
2146: GO 2163
// PlaceUnitArea ( i , startArea , false ) ;
2148: LD_VAR 0 2
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_INT 0
2158: PPUSH
2159: CALL_OW 49
// ComHold ( i ) ;
2163: LD_VAR 0 2
2167: PPUSH
2168: CALL_OW 140
// end ;
2172: GO 2063
2174: POP
2175: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2176: LD_ADDR_EXP 7
2180: PUSH
2181: LD_STRING 02_mikhailStatus_1
2183: PPUSH
2184: LD_INT 0
2186: PPUSH
2187: CALL_OW 30
2191: ST_TO_ADDR
// if not bierezov_exist and not debug then
2192: LD_EXP 7
2196: NOT
2197: PUSH
2198: LD_EXP 1
2202: NOT
2203: AND
2204: IFFALSE 2208
// exit ;
2206: GO 2239
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2208: LD_ADDR_EXP 44
2212: PUSH
2213: LD_STRING Mikhail
2215: PPUSH
2216: LD_INT 0
2218: PPUSH
2219: CALL 481 0 2
2223: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2224: LD_EXP 44
2228: PPUSH
2229: LD_INT 1
2231: PPUSH
2232: LD_INT 0
2234: PPUSH
2235: CALL_OW 49
// end ;
2239: LD_VAR 0 1
2243: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2244: LD_INT 0
2246: PPUSH
2247: PPUSH
2248: PPUSH
2249: PPUSH
// uc_side := 4 ;
2250: LD_ADDR_OWVAR 20
2254: PUSH
2255: LD_INT 4
2257: ST_TO_ADDR
// uc_nation := 1 ;
2258: LD_ADDR_OWVAR 21
2262: PUSH
2263: LD_INT 1
2265: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2266: LD_ADDR_EXP 43
2270: PUSH
2271: LD_STRING Cornell
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL 481 0 2
2281: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2282: LD_ADDR_EXP 6
2286: PUSH
2287: LD_INT 9
2289: PUSH
2290: LD_EXP 4
2294: MINUS
2295: ST_TO_ADDR
// tmp := [ ] ;
2296: LD_ADDR_VAR 0 2
2300: PUSH
2301: EMPTY
2302: ST_TO_ADDR
// if cornel_units < 4 then
2303: LD_EXP 6
2307: PUSH
2308: LD_INT 4
2310: LESS
2311: IFFALSE 2321
// cornel_units := 4 ;
2313: LD_ADDR_EXP 6
2317: PUSH
2318: LD_INT 4
2320: ST_TO_ADDR
// for i = 1 to cornel_units do
2321: LD_ADDR_VAR 0 4
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_EXP 6
2335: PUSH
2336: FOR_TO
2337: IFFALSE 2435
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2339: LD_INT 0
2341: PPUSH
2342: LD_INT 1
2344: PUSH
2345: LD_INT 1
2347: PUSH
2348: LD_INT 1
2350: PUSH
2351: LD_INT 2
2353: PUSH
2354: LD_INT 4
2356: PUSH
2357: EMPTY
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_VAR 0 4
2368: PUSH
2369: LD_INT 5
2371: MOD
2372: PUSH
2373: LD_INT 1
2375: PLUS
2376: ARRAY
2377: PPUSH
2378: LD_INT 2
2380: PPUSH
2381: CALL_OW 380
// un := CreateHuman ;
2385: LD_ADDR_VAR 0 3
2389: PUSH
2390: CALL_OW 44
2394: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2395: LD_ADDR_VAR 0 2
2399: PUSH
2400: LD_VAR 0 2
2404: PPUSH
2405: LD_INT 1
2407: PPUSH
2408: LD_VAR 0 3
2412: PPUSH
2413: CALL_OW 2
2417: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2418: LD_VAR 0 3
2422: PPUSH
2423: LD_INT 2
2425: PPUSH
2426: LD_INT 0
2428: PPUSH
2429: CALL_OW 49
// end ;
2433: GO 2336
2435: POP
2436: POP
// cornel_units := tmp ;
2437: LD_ADDR_EXP 6
2441: PUSH
2442: LD_VAR 0 2
2446: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2447: LD_EXP 43
2451: PPUSH
2452: LD_INT 191
2454: PPUSH
2455: LD_INT 106
2457: PPUSH
2458: LD_INT 0
2460: PPUSH
2461: CALL_OW 48
// end ;
2465: LD_VAR 0 1
2469: RET
// export function PrepareWesternBase ; var i ; begin
2470: LD_INT 0
2472: PPUSH
2473: PPUSH
// uc_side := 8 ;
2474: LD_ADDR_OWVAR 20
2478: PUSH
2479: LD_INT 8
2481: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2482: LD_ADDR_EXP 46
2486: PUSH
2487: LD_STRING Lynch
2489: PPUSH
2490: LD_INT 0
2492: PPUSH
2493: CALL 481 0 2
2497: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2498: LD_ADDR_EXP 47
2502: PUSH
2503: LD_STRING Walker
2505: PPUSH
2506: LD_INT 0
2508: PPUSH
2509: CALL 481 0 2
2513: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2514: LD_ADDR_EXP 48
2518: PUSH
2519: LD_STRING Turner
2521: PPUSH
2522: LD_INT 0
2524: PPUSH
2525: CALL 481 0 2
2529: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2530: LD_ADDR_EXP 49
2534: PUSH
2535: LD_STRING Jillian
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 481 0 2
2545: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: LD_EXP 46
2555: PUSH
2556: LD_EXP 47
2560: PUSH
2561: LD_EXP 48
2565: PUSH
2566: LD_EXP 49
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: LIST
2576: PUSH
2577: FOR_IN
2578: IFFALSE 2606
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2580: LD_VAR 0 2
2584: PPUSH
2585: LD_INT 3
2587: PPUSH
2588: LD_INT 0
2590: PPUSH
2591: CALL_OW 49
// ComHold ( i ) ;
2595: LD_VAR 0 2
2599: PPUSH
2600: CALL_OW 140
// end ;
2604: GO 2577
2606: POP
2607: POP
// end ;
2608: LD_VAR 0 1
2612: RET
// export function SelectGroup ; var units , selected , i ; begin
2613: LD_INT 0
2615: PPUSH
2616: PPUSH
2617: PPUSH
2618: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2619: LD_ADDR_VAR 0 2
2623: PUSH
2624: LD_EXP 36
2628: PUSH
2629: LD_INT -3
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: PUSH
2636: LD_EXP 4
2640: ADD
2641: PUSH
2642: LD_INT -2
2644: PUSH
2645: LD_INT -4
2647: PUSH
2648: LD_EXP 43
2652: PUSH
2653: LD_EXP 44
2657: PUSH
2658: EMPTY
2659: LIST
2660: LIST
2661: LIST
2662: LIST
2663: ADD
2664: PUSH
2665: LD_INT -3
2667: PUSH
2668: EMPTY
2669: LIST
2670: ADD
2671: PUSH
2672: LD_EXP 6
2676: ADD
2677: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2678: LD_ADDR_VAR 0 3
2682: PUSH
2683: LD_EXP 36
2687: PUSH
2688: LD_STRING Select five characters to go with you
2690: PPUSH
2691: LD_INT 4
2693: PPUSH
2694: LD_INT 4
2696: PPUSH
2697: LD_VAR 0 2
2701: PPUSH
2702: EMPTY
2703: PPUSH
2704: CALL_OW 42
2708: ADD
2709: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2710: LD_ADDR_EXP 6
2714: PUSH
2715: LD_EXP 4
2719: PUSH
2720: LD_EXP 6
2724: UNION
2725: PUSH
2726: LD_VAR 0 3
2730: DIFF
2731: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2732: LD_ADDR_VAR 0 4
2736: PUSH
2737: LD_EXP 6
2741: PUSH
2742: LD_EXP 44
2746: ADD
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2780
// if GetSide ( i ) = 1 then
2751: LD_VAR 0 4
2755: PPUSH
2756: CALL_OW 255
2760: PUSH
2761: LD_INT 1
2763: EQUAL
2764: IFFALSE 2778
// SetSide ( i , 4 ) ;
2766: LD_VAR 0 4
2770: PPUSH
2771: LD_INT 4
2773: PPUSH
2774: CALL_OW 235
2778: GO 2748
2780: POP
2781: POP
// for i in selected do
2782: LD_ADDR_VAR 0 4
2786: PUSH
2787: LD_VAR 0 3
2791: PUSH
2792: FOR_IN
2793: IFFALSE 2824
// if GetSide ( i ) = 4 then
2795: LD_VAR 0 4
2799: PPUSH
2800: CALL_OW 255
2804: PUSH
2805: LD_INT 4
2807: EQUAL
2808: IFFALSE 2822
// SetSide ( i , 1 ) ;
2810: LD_VAR 0 4
2814: PPUSH
2815: LD_INT 1
2817: PPUSH
2818: CALL_OW 235
2822: GO 2792
2824: POP
2825: POP
// jmm_units := jmm_units diff cornel_units ;
2826: LD_ADDR_EXP 4
2830: PUSH
2831: LD_EXP 4
2835: PUSH
2836: LD_EXP 6
2840: DIFF
2841: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2842: LD_EXP 37
2846: PPUSH
2847: CALL_OW 255
2851: PUSH
2852: LD_INT 4
2854: EQUAL
2855: IFFALSE 2870
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2857: LD_EXP 3
2861: PUSH
2862: LD_STRING Bobby
2864: STR
2865: PPUSH
2866: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2870: LD_EXP 38
2874: PPUSH
2875: CALL_OW 255
2879: PUSH
2880: LD_INT 4
2882: EQUAL
2883: IFFALSE 2898
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2885: LD_EXP 3
2889: PUSH
2890: LD_STRING Cyrus
2892: STR
2893: PPUSH
2894: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2898: LD_EXP 39
2902: PPUSH
2903: CALL_OW 255
2907: PUSH
2908: LD_INT 4
2910: EQUAL
2911: IFFALSE 2926
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2913: LD_EXP 3
2917: PUSH
2918: LD_STRING Lisa
2920: STR
2921: PPUSH
2922: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2926: LD_EXP 40
2930: PPUSH
2931: CALL_OW 255
2935: PUSH
2936: LD_INT 4
2938: EQUAL
2939: IFFALSE 2954
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2941: LD_EXP 3
2945: PUSH
2946: LD_STRING Khatam
2948: STR
2949: PPUSH
2950: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2954: LD_EXP 41
2958: PPUSH
2959: CALL_OW 255
2963: PUSH
2964: LD_INT 4
2966: EQUAL
2967: IFFALSE 2982
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2969: LD_EXP 3
2973: PUSH
2974: LD_STRING Brian
2976: STR
2977: PPUSH
2978: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2982: LD_EXP 42
2986: PPUSH
2987: CALL_OW 255
2991: PUSH
2992: LD_INT 4
2994: EQUAL
2995: IFFALSE 3010
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2997: LD_EXP 3
3001: PUSH
3002: LD_STRING Jerry
3004: STR
3005: PPUSH
3006: CALL_OW 40
// end ; end_of_file
3010: LD_VAR 0 1
3014: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3015: LD_INT 0
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
3023: PPUSH
3024: PPUSH
3025: PPUSH
3026: PPUSH
3027: PPUSH
3028: PPUSH
3029: PPUSH
// ru_alert := false ;
3030: LD_ADDR_EXP 59
3034: PUSH
3035: LD_INT 0
3037: ST_TO_ADDR
// ru_produce_list := [ ] ;
3038: LD_ADDR_EXP 56
3042: PUSH
3043: EMPTY
3044: ST_TO_ADDR
// if Difficulty > 1 then
3045: LD_OWVAR 67
3049: PUSH
3050: LD_INT 1
3052: GREATER
3053: IFFALSE 3141
// begin uc_side := 3 ;
3055: LD_ADDR_OWVAR 20
3059: PUSH
3060: LD_INT 3
3062: ST_TO_ADDR
// uc_nation := 3 ;
3063: LD_ADDR_OWVAR 21
3067: PUSH
3068: LD_INT 3
3070: ST_TO_ADDR
// bc_type := b_breastwork ;
3071: LD_ADDR_OWVAR 42
3075: PUSH
3076: LD_INT 31
3078: ST_TO_ADDR
// bc_level := Difficulty ;
3079: LD_ADDR_OWVAR 43
3083: PUSH
3084: LD_OWVAR 67
3088: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3089: LD_INT 22
3091: PPUSH
3092: LD_INT 14
3094: PPUSH
3095: LD_INT 0
3097: PPUSH
3098: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3102: LD_INT 48
3104: PPUSH
3105: LD_INT 46
3107: PPUSH
3108: LD_INT 0
3110: PPUSH
3111: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3115: LD_INT 86
3117: PPUSH
3118: LD_INT 65
3120: PPUSH
3121: LD_INT 5
3123: PPUSH
3124: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3128: LD_INT 165
3130: PPUSH
3131: LD_INT 73
3133: PPUSH
3134: LD_INT 5
3136: PPUSH
3137: CALL_OW 47
// end ; if Difficulty = 3 then
3141: LD_OWVAR 67
3145: PUSH
3146: LD_INT 3
3148: EQUAL
3149: IFFALSE 3164
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3151: LD_INT 51
3153: PPUSH
3154: LD_INT 3
3156: PPUSH
3157: LD_INT 2
3159: PPUSH
3160: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3164: LD_ADDR_VAR 0 7
3168: PUSH
3169: LD_INT 22
3171: PUSH
3172: LD_INT 3
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: LD_INT 2
3181: PUSH
3182: LD_INT 30
3184: PUSH
3185: LD_INT 31
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 30
3194: PUSH
3195: LD_INT 32
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: PPUSH
3211: CALL_OW 69
3215: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3216: LD_ADDR_VAR 0 8
3220: PUSH
3221: LD_INT 22
3223: PUSH
3224: LD_INT 3
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PUSH
3231: LD_INT 30
3233: PUSH
3234: LD_INT 4
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PPUSH
3245: CALL_OW 69
3249: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3250: LD_ADDR_VAR 0 10
3254: PUSH
3255: LD_INT 22
3257: PUSH
3258: LD_INT 3
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: PUSH
3265: LD_INT 30
3267: PUSH
3268: LD_INT 3
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL_OW 69
3283: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3284: LD_ADDR_VAR 0 9
3288: PUSH
3289: LD_INT 22
3291: PUSH
3292: LD_INT 3
3294: PUSH
3295: EMPTY
3296: LIST
3297: LIST
3298: PUSH
3299: LD_INT 30
3301: PUSH
3302: LD_INT 6
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: PPUSH
3313: CALL_OW 69
3317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3318: LD_ADDR_VAR 0 2
3322: PUSH
3323: LD_INT 22
3325: PUSH
3326: LD_INT 3
3328: PUSH
3329: EMPTY
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 30
3335: PUSH
3336: LD_INT 1
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: EMPTY
3344: LIST
3345: LIST
3346: PPUSH
3347: CALL_OW 69
3351: PUSH
3352: FOR_IN
3353: IFFALSE 3397
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3355: LD_VAR 0 2
3359: PPUSH
3360: CALL_OW 274
3364: PPUSH
3365: LD_INT 1
3367: PPUSH
3368: LD_INT 5000
3370: PPUSH
3371: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3375: LD_VAR 0 2
3379: PPUSH
3380: CALL_OW 274
3384: PPUSH
3385: LD_INT 2
3387: PPUSH
3388: LD_INT 3000
3390: PPUSH
3391: CALL_OW 277
// end ;
3395: GO 3352
3397: POP
3398: POP
// uc_side := 3 ;
3399: LD_ADDR_OWVAR 20
3403: PUSH
3404: LD_INT 3
3406: ST_TO_ADDR
// uc_nation := 3 ;
3407: LD_ADDR_OWVAR 21
3411: PUSH
3412: LD_INT 3
3414: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3415: LD_ADDR_VAR 0 11
3419: PUSH
3420: LD_INT 2
3422: PUSH
3423: LD_INT 3
3425: PUSH
3426: LD_INT 4
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: LD_OWVAR 67
3438: ARRAY
3439: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3440: LD_ADDR_EXP 51
3444: PUSH
3445: LD_STRING Pokryshkin
3447: PPUSH
3448: LD_INT 0
3450: PPUSH
3451: CALL 481 0 2
3455: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3456: LD_EXP 51
3460: PPUSH
3461: LD_INT 63
3463: PPUSH
3464: LD_INT 21
3466: PPUSH
3467: LD_INT 0
3469: PPUSH
3470: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3474: LD_EXP 51
3478: PPUSH
3479: CALL_OW 140
// InitHc ;
3483: CALL_OW 19
// for i in fac do
3487: LD_ADDR_VAR 0 2
3491: PUSH
3492: LD_VAR 0 10
3496: PUSH
3497: FOR_IN
3498: IFFALSE 3551
// begin for j = 1 to 6 do
3500: LD_ADDR_VAR 0 3
3504: PUSH
3505: DOUBLE
3506: LD_INT 1
3508: DEC
3509: ST_TO_ADDR
3510: LD_INT 6
3512: PUSH
3513: FOR_TO
3514: IFFALSE 3547
// begin PrepareHuman ( false , 3 , skill ) ;
3516: LD_INT 0
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_VAR 0 11
3526: PPUSH
3527: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3531: CALL_OW 44
3535: PPUSH
3536: LD_VAR 0 2
3540: PPUSH
3541: CALL_OW 52
// end ;
3545: GO 3513
3547: POP
3548: POP
// end ;
3549: GO 3497
3551: POP
3552: POP
// for i in lab do
3553: LD_ADDR_VAR 0 2
3557: PUSH
3558: LD_VAR 0 9
3562: PUSH
3563: FOR_IN
3564: IFFALSE 3597
// begin PrepareHuman ( false , 4 , skill ) ;
3566: LD_INT 0
3568: PPUSH
3569: LD_INT 4
3571: PPUSH
3572: LD_VAR 0 11
3576: PPUSH
3577: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3581: CALL_OW 44
3585: PPUSH
3586: LD_VAR 0 2
3590: PPUSH
3591: CALL_OW 52
// end ;
3595: GO 3563
3597: POP
3598: POP
// for i in tw do
3599: LD_ADDR_VAR 0 2
3603: PUSH
3604: LD_VAR 0 7
3608: PUSH
3609: FOR_IN
3610: IFFALSE 3659
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3612: LD_VAR 0 2
3616: PPUSH
3617: LD_INT 42
3619: PUSH
3620: LD_INT 43
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 1
3629: PPUSH
3630: LD_INT 2
3632: PPUSH
3633: CALL_OW 12
3637: ARRAY
3638: PPUSH
3639: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3643: LD_VAR 0 11
3647: PPUSH
3648: LD_VAR 0 2
3652: PPUSH
3653: CALL 822 0 2
// end ;
3657: GO 3609
3659: POP
3660: POP
// for i in bar do
3661: LD_ADDR_VAR 0 2
3665: PUSH
3666: LD_VAR 0 8
3670: PUSH
3671: FOR_IN
3672: IFFALSE 3705
// begin PrepareHuman ( false , 1 , skill ) ;
3674: LD_INT 0
3676: PPUSH
3677: LD_INT 1
3679: PPUSH
3680: LD_VAR 0 11
3684: PPUSH
3685: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3689: CALL_OW 44
3693: PPUSH
3694: LD_VAR 0 2
3698: PPUSH
3699: CALL_OW 52
// end ;
3703: GO 3671
3705: POP
3706: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3707: LD_ADDR_VAR 0 13
3711: PUSH
3712: LD_INT 100
3714: PUSH
3715: LD_INT 9
3717: PUSH
3718: EMPTY
3719: LIST
3720: LIST
3721: PUSH
3722: LD_INT 135
3724: PUSH
3725: LD_INT 60
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: PUSH
3732: LD_INT 41
3734: PUSH
3735: LD_INT 6
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 22
3744: PUSH
3745: LD_INT 9
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: LD_INT 84
3754: PUSH
3755: LD_INT 14
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: LIST
3766: LIST
3767: LIST
3768: ST_TO_ADDR
// vehicles := [ ] ;
3769: LD_ADDR_VAR 0 12
3773: PUSH
3774: EMPTY
3775: ST_TO_ADDR
// for i in spot_xy do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 13
3785: PUSH
3786: FOR_IN
3787: IFFALSE 3945
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3789: LD_ADDR_VAR 0 6
3793: PUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 3
3799: PPUSH
3800: LD_INT 22
3802: PPUSH
3803: LD_INT 1
3805: PPUSH
3806: LD_INT 1
3808: PPUSH
3809: LD_INT 42
3811: PUSH
3812: LD_INT 43
3814: PUSH
3815: LD_INT 44
3817: PUSH
3818: EMPTY
3819: LIST
3820: LIST
3821: LIST
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: LD_INT 3
3828: PPUSH
3829: CALL_OW 12
3833: ARRAY
3834: PPUSH
3835: LD_INT 100
3837: PPUSH
3838: CALL 544 0 7
3842: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3843: LD_ADDR_VAR 0 12
3847: PUSH
3848: LD_VAR 0 12
3852: PPUSH
3853: LD_VAR 0 12
3857: PUSH
3858: LD_INT 1
3860: PLUS
3861: PPUSH
3862: LD_VAR 0 6
3866: PPUSH
3867: CALL_OW 2
3871: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_INT 3
3879: PPUSH
3880: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3884: LD_VAR 0 6
3888: PPUSH
3889: LD_VAR 0 2
3893: PUSH
3894: LD_INT 1
3896: ARRAY
3897: PPUSH
3898: LD_VAR 0 2
3902: PUSH
3903: LD_INT 2
3905: ARRAY
3906: PPUSH
3907: LD_INT 0
3909: PPUSH
3910: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3914: LD_INT 0
3916: PPUSH
3917: LD_INT 3
3919: PPUSH
3920: LD_VAR 0 11
3924: PPUSH
3925: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3929: CALL_OW 44
3933: PPUSH
3934: LD_VAR 0 6
3938: PPUSH
3939: CALL_OW 52
// end ;
3943: GO 3786
3945: POP
3946: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3947: LD_ADDR_VAR 0 2
3951: PUSH
3952: DOUBLE
3953: LD_INT 1
3955: DEC
3956: ST_TO_ADDR
3957: LD_INT 5
3959: PUSH
3960: LD_INT 7
3962: PUSH
3963: LD_INT 8
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: LIST
3970: PUSH
3971: LD_OWVAR 67
3975: ARRAY
3976: PUSH
3977: FOR_TO
3978: IFFALSE 4038
// begin PrepareHuman ( false , 1 , skill ) ;
3980: LD_INT 0
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_VAR 0 11
3990: PPUSH
3991: CALL_OW 380
// un := CreateHuman ;
3995: LD_ADDR_VAR 0 5
3999: PUSH
4000: CALL_OW 44
4004: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
4005: LD_VAR 0 5
4009: PPUSH
4010: LD_INT 11
4012: PPUSH
4013: LD_INT 0
4015: PPUSH
4016: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4020: LD_ADDR_EXP 54
4024: PUSH
4025: LD_EXP 54
4029: PUSH
4030: LD_VAR 0 5
4034: ADD
4035: ST_TO_ADDR
// end ;
4036: GO 3977
4038: POP
4039: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4040: LD_ADDR_VAR 0 2
4044: PUSH
4045: DOUBLE
4046: LD_INT 1
4048: DEC
4049: ST_TO_ADDR
4050: LD_INT 2
4052: PUSH
4053: LD_INT 3
4055: PUSH
4056: LD_INT 4
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: LIST
4063: PUSH
4064: LD_OWVAR 67
4068: ARRAY
4069: PUSH
4070: FOR_TO
4071: IFFALSE 4131
// begin PrepareHuman ( false , 1 , skill ) ;
4073: LD_INT 0
4075: PPUSH
4076: LD_INT 1
4078: PPUSH
4079: LD_VAR 0 11
4083: PPUSH
4084: CALL_OW 380
// un := CreateHuman ;
4088: LD_ADDR_VAR 0 5
4092: PUSH
4093: CALL_OW 44
4097: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4098: LD_VAR 0 5
4102: PPUSH
4103: LD_INT 12
4105: PPUSH
4106: LD_INT 0
4108: PPUSH
4109: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4113: LD_ADDR_EXP 52
4117: PUSH
4118: LD_EXP 52
4122: PUSH
4123: LD_VAR 0 5
4127: ADD
4128: ST_TO_ADDR
// end ;
4129: GO 4070
4131: POP
4132: POP
// for i = 1 to 2 do
4133: LD_ADDR_VAR 0 2
4137: PUSH
4138: DOUBLE
4139: LD_INT 1
4141: DEC
4142: ST_TO_ADDR
4143: LD_INT 2
4145: PUSH
4146: FOR_TO
4147: IFFALSE 4213
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4149: LD_INT 1
4151: PPUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_VAR 0 11
4159: PPUSH
4160: CALL_OW 380
// un := CreateHuman ;
4164: LD_ADDR_VAR 0 5
4168: PUSH
4169: CALL_OW 44
4173: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4174: LD_VAR 0 5
4178: PPUSH
4179: LD_INT 39
4181: PPUSH
4182: LD_INT 12
4184: PPUSH
4185: LD_INT 3
4187: PPUSH
4188: LD_INT 0
4190: PPUSH
4191: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4195: LD_ADDR_EXP 53
4199: PUSH
4200: LD_EXP 53
4204: PUSH
4205: LD_VAR 0 5
4209: ADD
4210: ST_TO_ADDR
// end ;
4211: GO 4146
4213: POP
4214: POP
// for i = 1 to 3 do
4215: LD_ADDR_VAR 0 2
4219: PUSH
4220: DOUBLE
4221: LD_INT 1
4223: DEC
4224: ST_TO_ADDR
4225: LD_INT 3
4227: PUSH
4228: FOR_TO
4229: IFFALSE 4295
// begin PrepareHuman ( false , 1 , skill ) ;
4231: LD_INT 0
4233: PPUSH
4234: LD_INT 1
4236: PPUSH
4237: LD_VAR 0 11
4241: PPUSH
4242: CALL_OW 380
// un := CreateHuman ;
4246: LD_ADDR_VAR 0 5
4250: PUSH
4251: CALL_OW 44
4255: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4256: LD_VAR 0 5
4260: PPUSH
4261: LD_INT 180
4263: PPUSH
4264: LD_INT 11
4266: PPUSH
4267: LD_INT 4
4269: PPUSH
4270: LD_INT 0
4272: PPUSH
4273: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4277: LD_ADDR_EXP 57
4281: PUSH
4282: LD_EXP 57
4286: PUSH
4287: LD_VAR 0 5
4291: ADD
4292: ST_TO_ADDR
// end ;
4293: GO 4228
4295: POP
4296: POP
// ru_vehicles := vehicles ;
4297: LD_ADDR_EXP 55
4301: PUSH
4302: LD_VAR 0 12
4306: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4307: LD_ADDR_EXP 58
4311: PUSH
4312: LD_INT 131
4314: PUSH
4315: LD_INT 121
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: LD_INT 113
4324: PUSH
4325: LD_INT 90
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: PUSH
4332: LD_INT 93
4334: PUSH
4335: LD_INT 62
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 106
4349: PUSH
4350: LD_INT 54
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: LD_INT 120
4359: PUSH
4360: LD_INT 80
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 143
4369: PUSH
4370: LD_INT 120
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 154
4384: PUSH
4385: LD_INT 116
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 140
4394: PUSH
4395: LD_INT 93
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 130
4404: PUSH
4405: LD_INT 58
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 105
4419: PUSH
4420: LD_INT 106
4422: PUSH
4423: EMPTY
4424: LIST
4425: LIST
4426: PUSH
4427: LD_INT 134
4429: PUSH
4430: LD_INT 98
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PUSH
4437: LD_INT 159
4439: PUSH
4440: LD_INT 113
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: LIST
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4458: LD_ADDR_VAR 0 2
4462: PUSH
4463: DOUBLE
4464: LD_INT 1
4466: DEC
4467: ST_TO_ADDR
4468: LD_OWVAR 67
4472: PUSH
4473: LD_INT 1
4475: MINUS
4476: PUSH
4477: FOR_TO
4478: IFFALSE 4511
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4480: LD_ADDR_EXP 56
4484: PUSH
4485: LD_EXP 56
4489: PUSH
4490: LD_INT 22
4492: PUSH
4493: LD_INT 1
4495: PUSH
4496: LD_INT 1
4498: PUSH
4499: LD_INT 43
4501: PUSH
4502: EMPTY
4503: LIST
4504: LIST
4505: LIST
4506: LIST
4507: ADD
4508: ST_TO_ADDR
4509: GO 4477
4511: POP
4512: POP
// end ;
4513: LD_VAR 0 1
4517: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4518: LD_INT 22
4520: PUSH
4521: LD_INT 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 2
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: IFFALSE 4640
4548: GO 4550
4550: DISABLE
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
// begin enable ;
4555: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4556: LD_ADDR_VAR 0 2
4560: PUSH
4561: LD_INT 22
4563: PUSH
4564: LD_INT 3
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 2
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 69
4589: ST_TO_ADDR
// if filter then
4590: LD_VAR 0 2
4594: IFFALSE 4640
// for i in filter do
4596: LD_ADDR_VAR 0 1
4600: PUSH
4601: LD_VAR 0 2
4605: PUSH
4606: FOR_IN
4607: IFFALSE 4638
// if GetFuel ( i ) < 20 then
4609: LD_VAR 0 1
4613: PPUSH
4614: CALL_OW 261
4618: PUSH
4619: LD_INT 20
4621: LESS
4622: IFFALSE 4636
// SetFuel ( i , 20 ) ;
4624: LD_VAR 0 1
4628: PPUSH
4629: LD_INT 20
4631: PPUSH
4632: CALL_OW 240
4636: GO 4606
4638: POP
4639: POP
// end ;
4640: PPOPN 2
4642: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4643: LD_EXP 56
4647: IFFALSE 4866
4649: GO 4651
4651: DISABLE
4652: LD_INT 0
4654: PPUSH
4655: PPUSH
4656: PPUSH
// begin enable ;
4657: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4658: LD_ADDR_VAR 0 2
4662: PUSH
4663: LD_INT 22
4665: PUSH
4666: LD_INT 3
4668: PUSH
4669: EMPTY
4670: LIST
4671: LIST
4672: PUSH
4673: LD_INT 30
4675: PUSH
4676: LD_INT 3
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 69
4691: ST_TO_ADDR
// can_produce := [ ] ;
4692: LD_ADDR_VAR 0 3
4696: PUSH
4697: EMPTY
4698: ST_TO_ADDR
// if not fac then
4699: LD_VAR 0 2
4703: NOT
4704: IFFALSE 4709
// begin disable ;
4706: DISABLE
// exit ;
4707: GO 4866
// end ; for i in fac do
4709: LD_ADDR_VAR 0 1
4713: PUSH
4714: LD_VAR 0 2
4718: PUSH
4719: FOR_IN
4720: IFFALSE 4758
// if UnitsInside ( i ) then
4722: LD_VAR 0 1
4726: PPUSH
4727: CALL_OW 313
4731: IFFALSE 4756
// can_produce := Insert ( can_produce , 1 , i ) ;
4733: LD_ADDR_VAR 0 3
4737: PUSH
4738: LD_VAR 0 3
4742: PPUSH
4743: LD_INT 1
4745: PPUSH
4746: LD_VAR 0 1
4750: PPUSH
4751: CALL_OW 2
4755: ST_TO_ADDR
4756: GO 4719
4758: POP
4759: POP
// if not can_produce then
4760: LD_VAR 0 3
4764: NOT
4765: IFFALSE 4769
// exit ;
4767: GO 4866
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4769: LD_VAR 0 3
4773: PUSH
4774: LD_INT 1
4776: PPUSH
4777: LD_VAR 0 3
4781: PPUSH
4782: CALL_OW 12
4786: ARRAY
4787: PPUSH
4788: LD_EXP 56
4792: PUSH
4793: LD_INT 1
4795: ARRAY
4796: PPUSH
4797: LD_EXP 56
4801: PUSH
4802: LD_INT 2
4804: ARRAY
4805: PPUSH
4806: LD_EXP 56
4810: PUSH
4811: LD_INT 3
4813: ARRAY
4814: PPUSH
4815: LD_EXP 56
4819: PUSH
4820: LD_INT 4
4822: ARRAY
4823: PPUSH
4824: CALL_OW 125
// for i = 1 to 4 do
4828: LD_ADDR_VAR 0 1
4832: PUSH
4833: DOUBLE
4834: LD_INT 1
4836: DEC
4837: ST_TO_ADDR
4838: LD_INT 4
4840: PUSH
4841: FOR_TO
4842: IFFALSE 4864
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4844: LD_ADDR_EXP 56
4848: PUSH
4849: LD_EXP 56
4853: PPUSH
4854: LD_INT 1
4856: PPUSH
4857: CALL_OW 3
4861: ST_TO_ADDR
4862: GO 4841
4864: POP
4865: POP
// end ;
4866: PPOPN 3
4868: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4869: LD_INT 0
4871: PPUSH
4872: PPUSH
4873: PPUSH
// for i = 1 to 6 do
4874: LD_ADDR_VAR 0 2
4878: PUSH
4879: DOUBLE
4880: LD_INT 1
4882: DEC
4883: ST_TO_ADDR
4884: LD_INT 6
4886: PUSH
4887: FOR_TO
4888: IFFALSE 5037
// begin PrepareHuman ( false , 3 , 3 ) ;
4890: LD_INT 0
4892: PPUSH
4893: LD_INT 3
4895: PPUSH
4896: LD_INT 3
4898: PPUSH
4899: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 3
4910: PPUSH
4911: LD_INT 3
4913: PPUSH
4914: LD_INT 22
4916: PPUSH
4917: LD_INT 1
4919: PPUSH
4920: LD_INT 1
4922: PPUSH
4923: LD_INT 43
4925: PUSH
4926: LD_INT 42
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PUSH
4933: LD_INT 1
4935: PPUSH
4936: LD_INT 2
4938: PPUSH
4939: CALL_OW 12
4943: ARRAY
4944: PPUSH
4945: LD_INT 70
4947: PPUSH
4948: CALL 544 0 7
4952: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4953: LD_VAR 0 3
4957: PPUSH
4958: LD_INT 4
4960: PPUSH
4961: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4965: LD_VAR 0 3
4969: PPUSH
4970: LD_INT 229
4972: PPUSH
4973: LD_INT 44
4975: PPUSH
4976: LD_INT 0
4978: PPUSH
4979: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4983: CALL_OW 44
4987: PPUSH
4988: LD_VAR 0 3
4992: PPUSH
4993: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4997: LD_ADDR_EXP 55
5001: PUSH
5002: LD_EXP 55
5006: PUSH
5007: LD_VAR 0 3
5011: ADD
5012: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 191
5020: PPUSH
5021: LD_INT 32
5023: PPUSH
5024: CALL_OW 111
// Wait ( 0 0$02 ) ;
5028: LD_INT 70
5030: PPUSH
5031: CALL_OW 67
// end ;
5035: GO 4887
5037: POP
5038: POP
// end ;
5039: LD_VAR 0 1
5043: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5044: LD_EXP 30
5048: PUSH
5049: LD_EXP 55
5053: AND
5054: IFFALSE 5228
5056: GO 5058
5058: DISABLE
5059: LD_INT 0
5061: PPUSH
5062: PPUSH
5063: PPUSH
// begin wait ( 0 0$50 ) ;
5064: LD_INT 1750
5066: PPUSH
5067: CALL_OW 67
// tmp := ru_vehicles ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: LD_EXP 55
5080: ST_TO_ADDR
// if not tmp then
5081: LD_VAR 0 3
5085: NOT
5086: IFFALSE 5090
// exit ;
5088: GO 5228
// repeat wait ( 0 0$1 ) ;
5090: LD_INT 35
5092: PPUSH
5093: CALL_OW 67
// for i in tmp do
5097: LD_ADDR_VAR 0 1
5101: PUSH
5102: LD_VAR 0 3
5106: PUSH
5107: FOR_IN
5108: IFFALSE 5219
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_INT 22
5117: PUSH
5118: LD_INT 1
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: LD_VAR 0 1
5129: PPUSH
5130: CALL_OW 74
5134: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5135: LD_VAR 0 1
5139: PPUSH
5140: LD_VAR 0 2
5144: PPUSH
5145: CALL_OW 296
5149: PUSH
5150: LD_INT 10
5152: GREATER
5153: IFFALSE 5172
// ComAgressiveMove ( i , 69 , 101 ) else
5155: LD_VAR 0 1
5159: PPUSH
5160: LD_INT 69
5162: PPUSH
5163: LD_INT 101
5165: PPUSH
5166: CALL_OW 114
5170: GO 5186
// ComAttackUnit ( i , enemy ) ;
5172: LD_VAR 0 1
5176: PPUSH
5177: LD_VAR 0 2
5181: PPUSH
5182: CALL_OW 115
// if GetLives ( i ) < 250 then
5186: LD_VAR 0 1
5190: PPUSH
5191: CALL_OW 256
5195: PUSH
5196: LD_INT 250
5198: LESS
5199: IFFALSE 5217
// tmp := tmp diff i ;
5201: LD_ADDR_VAR 0 3
5205: PUSH
5206: LD_VAR 0 3
5210: PUSH
5211: LD_VAR 0 1
5215: DIFF
5216: ST_TO_ADDR
// end ;
5217: GO 5107
5219: POP
5220: POP
// until not tmp ;
5221: LD_VAR 0 3
5225: NOT
5226: IFFALSE 5090
// end ; end_of_file
5228: PPOPN 3
5230: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5231: LD_INT 0
5233: PPUSH
5234: PPUSH
5235: PPUSH
5236: PPUSH
5237: PPUSH
5238: PPUSH
5239: PPUSH
// InGameOn ;
5240: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5244: LD_EXP 36
5248: PPUSH
5249: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5253: LD_EXP 36
5257: PPUSH
5258: LD_EXP 43
5262: PPUSH
5263: CALL_OW 119
// if Bierezov then
5267: LD_EXP 44
5271: IFFALSE 5287
// ComTurnUnit ( Bierezov , Cornel ) ;
5273: LD_EXP 44
5277: PPUSH
5278: LD_EXP 43
5282: PPUSH
5283: CALL_OW 119
// for i in jmm_units do
5287: LD_ADDR_VAR 0 2
5291: PUSH
5292: LD_EXP 4
5296: PUSH
5297: FOR_IN
5298: IFFALSE 5316
// ComTurnUnit ( i , Cornel ) ;
5300: LD_VAR 0 2
5304: PPUSH
5305: LD_EXP 43
5309: PPUSH
5310: CALL_OW 119
5314: GO 5297
5316: POP
5317: POP
// units := cornel_units union Cornel ;
5318: LD_ADDR_VAR 0 3
5322: PUSH
5323: LD_EXP 6
5327: PUSH
5328: LD_EXP 43
5332: UNION
5333: ST_TO_ADDR
// repeat wait ( 1 ) ;
5334: LD_INT 1
5336: PPUSH
5337: CALL_OW 67
// for i in units do
5341: LD_ADDR_VAR 0 2
5345: PUSH
5346: LD_VAR 0 3
5350: PUSH
5351: FOR_IN
5352: IFFALSE 5385
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5354: LD_VAR 0 2
5358: PPUSH
5359: LD_EXP 36
5363: PPUSH
5364: CALL_OW 250
5368: PPUSH
5369: LD_EXP 36
5373: PPUSH
5374: CALL_OW 251
5378: PPUSH
5379: CALL_OW 111
5383: GO 5351
5385: POP
5386: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5387: LD_VAR 0 3
5391: PPUSH
5392: LD_INT 92
5394: PUSH
5395: LD_EXP 36
5399: PPUSH
5400: CALL_OW 250
5404: PUSH
5405: LD_EXP 36
5409: PPUSH
5410: CALL_OW 251
5414: PUSH
5415: LD_INT 10
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: PPUSH
5424: CALL_OW 72
5428: PUSH
5429: LD_VAR 0 3
5433: EQUAL
5434: IFFALSE 5334
// for i in units do
5436: LD_ADDR_VAR 0 2
5440: PUSH
5441: LD_VAR 0 3
5445: PUSH
5446: FOR_IN
5447: IFFALSE 5465
// ComTurnUnit ( i , JMM ) ;
5449: LD_VAR 0 2
5453: PPUSH
5454: LD_EXP 36
5458: PPUSH
5459: CALL_OW 119
5463: GO 5446
5465: POP
5466: POP
// ComTurnUnit ( Cornel , JMM ) ;
5467: LD_EXP 43
5471: PPUSH
5472: LD_EXP 36
5476: PPUSH
5477: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5481: LD_EXP 36
5485: PPUSH
5486: LD_STRING D1-JMM-1
5488: PPUSH
5489: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5493: LD_EXP 43
5497: PPUSH
5498: LD_STRING D1-Corn-1
5500: PPUSH
5501: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5505: LD_EXP 36
5509: PPUSH
5510: LD_EXP 43
5514: PPUSH
5515: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5519: LD_EXP 43
5523: PPUSH
5524: LD_EXP 36
5528: PPUSH
5529: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5533: LD_INT 35
5535: PPUSH
5536: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5540: LD_EXP 36
5544: PPUSH
5545: LD_EXP 43
5549: PPUSH
5550: CALL_OW 296
5554: PUSH
5555: LD_INT 6
5557: LESS
5558: IFFALSE 5533
// ChangeSideFog ( 4 , 1 ) ;
5560: LD_INT 4
5562: PPUSH
5563: LD_INT 1
5565: PPUSH
5566: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5570: LD_EXP 36
5574: PPUSH
5575: LD_EXP 43
5579: PPUSH
5580: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5584: LD_EXP 43
5588: PPUSH
5589: LD_EXP 36
5593: PPUSH
5594: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5598: LD_EXP 36
5602: PPUSH
5603: LD_STRING D1-JMM-2
5605: PPUSH
5606: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5610: LD_EXP 36
5614: PPUSH
5615: LD_STRING D1-JMM-2a
5617: PPUSH
5618: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5622: LD_EXP 43
5626: PPUSH
5627: LD_STRING D1-Corn-2
5629: PPUSH
5630: CALL_OW 88
// if bierezov_exist or debug then
5634: LD_EXP 7
5638: PUSH
5639: LD_EXP 1
5643: OR
5644: IFFALSE 5885
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5646: LD_EXP 43
5650: PPUSH
5651: LD_EXP 44
5655: PPUSH
5656: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5660: LD_INT 10
5662: PPUSH
5663: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5667: LD_EXP 43
5671: PPUSH
5672: LD_STRING D1a-Corn-1
5674: PPUSH
5675: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5679: LD_EXP 36
5683: PPUSH
5684: LD_EXP 44
5688: PPUSH
5689: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5693: LD_EXP 44
5697: PPUSH
5698: LD_EXP 36
5702: PPUSH
5703: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5707: LD_EXP 36
5711: PPUSH
5712: LD_STRING D1a-JMM-1
5714: PPUSH
5715: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5719: LD_EXP 36
5723: PPUSH
5724: LD_EXP 43
5728: PPUSH
5729: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5733: LD_EXP 43
5737: PPUSH
5738: LD_EXP 36
5742: PPUSH
5743: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5747: LD_EXP 43
5751: PPUSH
5752: LD_STRING D1a-Corn-2
5754: PPUSH
5755: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5759: LD_EXP 36
5763: PPUSH
5764: LD_STRING D1a-JMM-2
5766: PPUSH
5767: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5771: LD_EXP 43
5775: PPUSH
5776: LD_STRING D1a-Corn-3
5778: PPUSH
5779: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5783: LD_EXP 36
5787: PPUSH
5788: LD_STRING D1a-JMM-3
5790: PPUSH
5791: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5795: LD_EXP 43
5799: PPUSH
5800: LD_STRING D1a-Corn-4
5802: PPUSH
5803: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5807: LD_EXP 36
5811: PPUSH
5812: LD_STRING D1a-JMM-4
5814: PPUSH
5815: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5819: LD_EXP 43
5823: PPUSH
5824: LD_STRING D1a-Corn-5
5826: PPUSH
5827: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5831: LD_EXP 44
5835: PPUSH
5836: LD_EXP 43
5840: PPUSH
5841: CALL_OW 250
5845: PPUSH
5846: LD_EXP 43
5850: PPUSH
5851: CALL_OW 251
5855: PUSH
5856: LD_INT 2
5858: MINUS
5859: PPUSH
5860: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5864: LD_EXP 44
5868: PPUSH
5869: LD_EXP 43
5873: PPUSH
5874: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5878: LD_INT 10
5880: PPUSH
5881: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5885: LD_EXP 36
5889: PPUSH
5890: LD_STRING D1b-JMM-1
5892: PPUSH
5893: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5897: LD_EXP 43
5901: PPUSH
5902: LD_STRING D1b-Corn-1
5904: PPUSH
5905: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5909: LD_EXP 36
5913: PPUSH
5914: LD_STRING D1b-JMM-2
5916: PPUSH
5917: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5921: LD_EXP 43
5925: PPUSH
5926: LD_STRING D1b-Corn-2
5928: PPUSH
5929: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5933: LD_EXP 36
5937: PPUSH
5938: LD_STRING D1b-JMM-3
5940: PPUSH
5941: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5945: LD_INT 10
5947: PPUSH
5948: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5952: LD_EXP 45
5956: PPUSH
5957: LD_STRING D1b-Pow-3
5959: PPUSH
5960: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5964: LD_EXP 36
5968: PPUSH
5969: LD_STRING D1b-JMM-4
5971: PPUSH
5972: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5976: LD_EXP 43
5980: PPUSH
5981: LD_STRING D1b-Corn-4
5983: PPUSH
5984: CALL_OW 88
// if Khatam then
5988: LD_EXP 40
5992: IFFALSE 6008
// Say ( Khatam , D1b-Khat-4 ) else
5994: LD_EXP 40
5998: PPUSH
5999: LD_STRING D1b-Khat-4
6001: PPUSH
6002: CALL_OW 88
6006: GO 6044
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6008: LD_EXP 6
6012: PPUSH
6013: LD_INT 26
6015: PUSH
6016: LD_INT 1
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL_OW 72
6027: PUSH
6028: LD_EXP 43
6032: PUSH
6033: EMPTY
6034: LIST
6035: DIFF
6036: PPUSH
6037: LD_STRING D1b-Sol1-4
6039: PPUSH
6040: CALL 632 0 2
// if Cyrus then
6044: LD_EXP 38
6048: IFFALSE 6062
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6050: LD_EXP 38
6054: PPUSH
6055: LD_STRING D1b-Cyrus-4
6057: PPUSH
6058: CALL_OW 88
// if Lisa then
6062: LD_EXP 39
6066: IFFALSE 6124
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6068: LD_EXP 39
6072: PPUSH
6073: LD_STRING D1b-Lisa-4
6075: PPUSH
6076: CALL_OW 88
// if Cyrus then
6080: LD_EXP 38
6084: IFFALSE 6124
// begin if not IsInUnit ( Cyrus ) then
6086: LD_EXP 38
6090: PPUSH
6091: CALL_OW 310
6095: NOT
6096: IFFALSE 6112
// ComTurnUnit ( Cyrus , Lisa ) ;
6098: LD_EXP 38
6102: PPUSH
6103: LD_EXP 39
6107: PPUSH
6108: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6112: LD_EXP 38
6116: PPUSH
6117: LD_STRING D1b-Cyrus-5
6119: PPUSH
6120: CALL_OW 88
// end ; end ; SelectGroup ;
6124: CALL 2613 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6128: LD_EXP 36
6132: PPUSH
6133: LD_STRING D1d-JMM-1
6135: PPUSH
6136: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6140: LD_EXP 43
6144: PPUSH
6145: LD_STRING D1d-Corn-1
6147: PPUSH
6148: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6152: LD_ADDR_VAR 0 2
6156: PUSH
6157: LD_EXP 4
6161: PUSH
6162: LD_EXP 6
6166: ADD
6167: PUSH
6168: LD_EXP 36
6172: ADD
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6188
// ComHold ( i ) ;
6177: LD_VAR 0 2
6181: PPUSH
6182: CALL_OW 140
6186: GO 6174
6188: POP
6189: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6190: LD_ADDR_VAR 0 4
6194: PUSH
6195: LD_INT 22
6197: PUSH
6198: LD_INT 1
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: PUSH
6205: LD_INT 21
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: PPUSH
6219: CALL_OW 69
6223: ST_TO_ADDR
// if vehicles then
6224: LD_VAR 0 4
6228: IFFALSE 6566
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6230: LD_EXP 6
6234: PPUSH
6235: LD_INT 55
6237: PUSH
6238: EMPTY
6239: LIST
6240: PPUSH
6241: CALL_OW 72
6245: IFFALSE 6284
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6247: LD_ADDR_VAR 0 2
6251: PUSH
6252: LD_EXP 6
6256: PPUSH
6257: LD_INT 55
6259: PUSH
6260: EMPTY
6261: LIST
6262: PPUSH
6263: CALL_OW 72
6267: PUSH
6268: FOR_IN
6269: IFFALSE 6282
// ComExitVehicle ( i ) ;
6271: LD_VAR 0 2
6275: PPUSH
6276: CALL_OW 121
6280: GO 6268
6282: POP
6283: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6284: LD_ADDR_VAR 0 5
6288: PUSH
6289: LD_VAR 0 4
6293: PPUSH
6294: LD_INT 34
6296: PUSH
6297: LD_INT 51
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PPUSH
6304: CALL_OW 72
6308: ST_TO_ADDR
// if cargos then
6309: LD_VAR 0 5
6313: IFFALSE 6496
// begin vehicles := cargos ;
6315: LD_ADDR_VAR 0 4
6319: PUSH
6320: LD_VAR 0 5
6324: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6325: LD_ADDR_VAR 0 6
6329: PUSH
6330: LD_STRING 02_resources_4
6332: PPUSH
6333: LD_INT 0
6335: PPUSH
6336: CALL_OW 30
6340: ST_TO_ADDR
// if debug and not resources then
6341: LD_EXP 1
6345: PUSH
6346: LD_VAR 0 6
6350: NOT
6351: AND
6352: IFFALSE 6362
// resources := 160 ;
6354: LD_ADDR_VAR 0 6
6358: PUSH
6359: LD_INT 160
6361: ST_TO_ADDR
// if resources mod 10 then
6362: LD_VAR 0 6
6366: PUSH
6367: LD_INT 10
6369: MOD
6370: IFFALSE 6392
// resources := resources - resources mod 10 ;
6372: LD_ADDR_VAR 0 6
6376: PUSH
6377: LD_VAR 0 6
6381: PUSH
6382: LD_VAR 0 6
6386: PUSH
6387: LD_INT 10
6389: MOD
6390: MINUS
6391: ST_TO_ADDR
// if resources then
6392: LD_VAR 0 6
6396: IFFALSE 6496
// for i in cargos do
6398: LD_ADDR_VAR 0 2
6402: PUSH
6403: LD_VAR 0 5
6407: PUSH
6408: FOR_IN
6409: IFFALSE 6494
// begin if resources < 100 then
6411: LD_VAR 0 6
6415: PUSH
6416: LD_INT 100
6418: LESS
6419: IFFALSE 6441
// begin cargo := resources ;
6421: LD_ADDR_VAR 0 7
6425: PUSH
6426: LD_VAR 0 6
6430: ST_TO_ADDR
// resources := 0 ;
6431: LD_ADDR_VAR 0 6
6435: PUSH
6436: LD_INT 0
6438: ST_TO_ADDR
// end else
6439: GO 6463
// begin cargo := 100 ;
6441: LD_ADDR_VAR 0 7
6445: PUSH
6446: LD_INT 100
6448: ST_TO_ADDR
// resources := resources - 100 ;
6449: LD_ADDR_VAR 0 6
6453: PUSH
6454: LD_VAR 0 6
6458: PUSH
6459: LD_INT 100
6461: MINUS
6462: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6463: LD_VAR 0 2
6467: PPUSH
6468: LD_INT 1
6470: PPUSH
6471: LD_VAR 0 7
6475: PPUSH
6476: CALL_OW 290
// if resources = 0 then
6480: LD_VAR 0 6
6484: PUSH
6485: LD_INT 0
6487: EQUAL
6488: IFFALSE 6492
// break ;
6490: GO 6494
// end ;
6492: GO 6408
6494: POP
6495: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6496: LD_VAR 0 4
6500: PUSH
6501: LD_INT 1
6503: ARRAY
6504: PPUSH
6505: CALL_OW 311
6509: PPUSH
6510: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6514: LD_VAR 0 4
6518: PUSH
6519: LD_INT 1
6521: ARRAY
6522: PPUSH
6523: LD_INT 4
6525: PPUSH
6526: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6530: LD_EXP 43
6534: PPUSH
6535: LD_VAR 0 4
6539: PUSH
6540: LD_INT 1
6542: ARRAY
6543: PPUSH
6544: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6548: LD_INT 35
6550: PPUSH
6551: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6555: LD_EXP 43
6559: PPUSH
6560: CALL_OW 310
6564: IFFALSE 6548
// end ; InGameOff ;
6566: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6570: LD_STRING M1
6572: PPUSH
6573: CALL_OW 337
// SaveForQuickRestart ;
6577: CALL_OW 22
// cornel_active := true ;
6581: LD_ADDR_EXP 8
6585: PUSH
6586: LD_INT 1
6588: ST_TO_ADDR
// end ;
6589: LD_VAR 0 1
6593: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6594: LD_EXP 36
6598: PPUSH
6599: LD_EXP 46
6603: PPUSH
6604: CALL_OW 296
6608: PUSH
6609: LD_INT 10
6611: LESS
6612: IFFALSE 7995
6614: GO 6616
6616: DISABLE
6617: LD_INT 0
6619: PPUSH
6620: PPUSH
6621: PPUSH
6622: PPUSH
6623: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6624: LD_ADDR_VAR 0 2
6628: PUSH
6629: LD_INT 89
6631: PUSH
6632: LD_INT 34
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: LD_INT 138
6641: PUSH
6642: LD_INT 63
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: PUSH
6649: LD_INT 196
6651: PUSH
6652: LD_INT 84
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: PUSH
6659: LD_INT 135
6661: PUSH
6662: LD_INT 52
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 103
6671: PUSH
6672: LD_INT 39
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: PUSH
6679: LD_INT 58
6681: PUSH
6682: LD_INT 30
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 38
6691: PUSH
6692: LD_INT 51
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: ST_TO_ADDR
// Video ( true ) ;
6708: LD_INT 1
6710: PPUSH
6711: CALL 1192 0 1
// if jmm_units then
6715: LD_EXP 4
6719: IFFALSE 6795
// for i in jmm_units do
6721: LD_ADDR_VAR 0 1
6725: PUSH
6726: LD_EXP 4
6730: PUSH
6731: FOR_IN
6732: IFFALSE 6793
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6734: LD_VAR 0 1
6738: PPUSH
6739: LD_EXP 36
6743: PPUSH
6744: CALL_OW 296
6748: PUSH
6749: LD_INT 10
6751: LESS
6752: PUSH
6753: LD_VAR 0 1
6757: PPUSH
6758: CALL_OW 310
6762: NOT
6763: AND
6764: IFFALSE 6782
// ComTurnUnit ( i , JMM ) else
6766: LD_VAR 0 1
6770: PPUSH
6771: LD_EXP 36
6775: PPUSH
6776: CALL_OW 119
6780: GO 6791
// ComHold ( i ) ;
6782: LD_VAR 0 1
6786: PPUSH
6787: CALL_OW 140
// end ;
6791: GO 6731
6793: POP
6794: POP
// if IsInUnit ( JMM ) then
6795: LD_EXP 36
6799: PPUSH
6800: CALL_OW 310
6804: IFFALSE 6829
// begin ComExitVehicle ( JMM ) ;
6806: LD_EXP 36
6810: PPUSH
6811: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6815: LD_EXP 36
6819: PPUSH
6820: LD_EXP 46
6824: PPUSH
6825: CALL_OW 172
// end ; Wait ( 10 ) ;
6829: LD_INT 10
6831: PPUSH
6832: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6836: LD_EXP 36
6840: PPUSH
6841: LD_EXP 46
6845: PPUSH
6846: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6850: LD_INT 35
6852: PPUSH
6853: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6857: LD_EXP 36
6861: PPUSH
6862: LD_EXP 46
6866: PPUSH
6867: CALL_OW 296
6871: PUSH
6872: LD_INT 6
6874: LESS
6875: IFFALSE 6850
// ComTurnUnit ( JMM , Lynch ) ;
6877: LD_EXP 36
6881: PPUSH
6882: LD_EXP 46
6886: PPUSH
6887: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6891: LD_ADDR_VAR 0 1
6895: PUSH
6896: LD_EXP 46
6900: PUSH
6901: LD_EXP 47
6905: PUSH
6906: LD_EXP 48
6910: PUSH
6911: LD_EXP 49
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: PUSH
6922: FOR_IN
6923: IFFALSE 6941
// ComTurnUnit ( i , JMM ) ;
6925: LD_VAR 0 1
6929: PPUSH
6930: LD_EXP 36
6934: PPUSH
6935: CALL_OW 119
6939: GO 6922
6941: POP
6942: POP
// Wait ( 0 0$0.3 ) ;
6943: LD_INT 10
6945: PPUSH
6946: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6950: LD_EXP 36
6954: PPUSH
6955: LD_STRING D2-JMM-1
6957: PPUSH
6958: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6962: LD_EXP 46
6966: PPUSH
6967: LD_STRING D2-Sol1-1
6969: PPUSH
6970: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6974: LD_EXP 36
6978: PPUSH
6979: LD_STRING D2-JMM-2
6981: PPUSH
6982: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6986: LD_EXP 46
6990: PPUSH
6991: LD_STRING D2-Sol1-2
6993: PPUSH
6994: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6998: LD_EXP 36
7002: PPUSH
7003: LD_STRING D2-JMM-3
7005: PPUSH
7006: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7010: LD_EXP 46
7014: PPUSH
7015: LD_STRING D2-Sol1-3
7017: PPUSH
7018: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7022: LD_ADDR_VAR 0 1
7026: PUSH
7027: LD_INT 22
7029: PUSH
7030: LD_INT 8
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PPUSH
7037: CALL_OW 69
7041: PUSH
7042: FOR_IN
7043: IFFALSE 7059
// SetSide ( i , 1 ) ;
7045: LD_VAR 0 1
7049: PPUSH
7050: LD_INT 1
7052: PPUSH
7053: CALL_OW 235
7057: GO 7042
7059: POP
7060: POP
// Say ( JMM , D2-JMM-4 ) ;
7061: LD_EXP 36
7065: PPUSH
7066: LD_STRING D2-JMM-4
7068: PPUSH
7069: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7073: LD_INT 1
7075: PPUSH
7076: LD_INT 5
7078: PPUSH
7079: CALL_OW 332
// for i = 1 to points do
7083: LD_ADDR_VAR 0 1
7087: PUSH
7088: DOUBLE
7089: LD_INT 1
7091: DEC
7092: ST_TO_ADDR
7093: LD_VAR 0 2
7097: PUSH
7098: FOR_TO
7099: IFFALSE 7274
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7101: LD_VAR 0 2
7105: PUSH
7106: LD_VAR 0 1
7110: ARRAY
7111: PUSH
7112: LD_INT 1
7114: ARRAY
7115: PPUSH
7116: LD_VAR 0 2
7120: PUSH
7121: LD_VAR 0 1
7125: ARRAY
7126: PUSH
7127: LD_INT 2
7129: ARRAY
7130: PPUSH
7131: CALL_OW 84
// if i = 1 then
7135: LD_VAR 0 1
7139: PUSH
7140: LD_INT 1
7142: EQUAL
7143: IFFALSE 7157
// Say ( Lynch , D2-Sol1-4 ) ;
7145: LD_EXP 46
7149: PPUSH
7150: LD_STRING D2-Sol1-4
7152: PPUSH
7153: CALL_OW 88
// if i = 2 then
7157: LD_VAR 0 1
7161: PUSH
7162: LD_INT 2
7164: EQUAL
7165: IFFALSE 7179
// Say ( JMM , D2-JMM-5 ) ;
7167: LD_EXP 36
7171: PPUSH
7172: LD_STRING D2-JMM-5
7174: PPUSH
7175: CALL_OW 88
// if i = 4 then
7179: LD_VAR 0 1
7183: PUSH
7184: LD_INT 4
7186: EQUAL
7187: IFFALSE 7211
// begin RevealFogArea ( 1 , troopsArea ) ;
7189: LD_INT 1
7191: PPUSH
7192: LD_INT 6
7194: PPUSH
7195: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7199: LD_EXP 46
7203: PPUSH
7204: LD_STRING D2-Sol1-5
7206: PPUSH
7207: CALL_OW 88
// end ; if i = 5 then
7211: LD_VAR 0 1
7215: PUSH
7216: LD_INT 5
7218: EQUAL
7219: IFFALSE 7233
// Say ( JMM , D2-JMM-6 ) ;
7221: LD_EXP 36
7225: PPUSH
7226: LD_STRING D2-JMM-6
7228: PPUSH
7229: CALL_OW 88
// if i = 7 then
7233: LD_VAR 0 1
7237: PUSH
7238: LD_INT 7
7240: EQUAL
7241: IFFALSE 7265
// begin RevealFogArea ( 1 , forestArea ) ;
7243: LD_INT 1
7245: PPUSH
7246: LD_INT 7
7248: PPUSH
7249: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7253: LD_EXP 46
7257: PPUSH
7258: LD_STRING D2-Sol1-6
7260: PPUSH
7261: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7265: LD_INT 46
7267: PPUSH
7268: CALL_OW 67
// end ;
7272: GO 7098
7274: POP
7275: POP
// CenterNowOnUnits ( JMM ) ;
7276: LD_EXP 36
7280: PPUSH
7281: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7285: LD_EXP 36
7289: PPUSH
7290: LD_STRING D2-JMM-7
7292: PPUSH
7293: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7297: LD_EXP 46
7301: PPUSH
7302: LD_STRING D2-Sol1-7
7304: PPUSH
7305: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7309: LD_EXP 36
7313: PPUSH
7314: LD_STRING D2-JMM-8
7316: PPUSH
7317: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7321: LD_ADDR_VAR 0 4
7325: PUSH
7326: LD_INT 22
7328: PUSH
7329: LD_INT 1
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: LD_INT 30
7338: PUSH
7339: LD_INT 31
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: PPUSH
7350: CALL_OW 69
7354: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7355: LD_EXP 46
7359: PPUSH
7360: LD_VAR 0 4
7364: PUSH
7365: LD_INT 1
7367: ARRAY
7368: PPUSH
7369: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 101
7378: PPUSH
7379: CALL_OW 428
7383: IFFALSE 7406
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7385: LD_INT 65
7387: PPUSH
7388: LD_INT 101
7390: PPUSH
7391: CALL_OW 428
7395: PPUSH
7396: LD_INT 75
7398: PPUSH
7399: LD_INT 100
7401: PPUSH
7402: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7406: LD_INT 66
7408: PPUSH
7409: LD_INT 103
7411: PPUSH
7412: CALL_OW 428
7416: IFFALSE 7439
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7418: LD_INT 66
7420: PPUSH
7421: LD_INT 103
7423: PPUSH
7424: CALL_OW 428
7428: PPUSH
7429: LD_INT 75
7431: PPUSH
7432: LD_INT 100
7434: PPUSH
7435: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7439: LD_ADDR_VAR 0 5
7443: PUSH
7444: LD_INT 22
7446: PUSH
7447: LD_INT 1
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PUSH
7454: LD_INT 21
7456: PUSH
7457: LD_INT 2
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: PUSH
7464: LD_INT 91
7466: PUSH
7467: LD_EXP 36
7471: PUSH
7472: LD_INT 7
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: LIST
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: PPUSH
7485: CALL_OW 69
7489: ST_TO_ADDR
// if tmp then
7490: LD_VAR 0 5
7494: IFFALSE 7511
// ComMoveXY ( tmp , 75 , 100 ) ;
7496: LD_VAR 0 5
7500: PPUSH
7501: LD_INT 75
7503: PPUSH
7504: LD_INT 100
7506: PPUSH
7507: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7511: LD_ADDR_VAR 0 3
7515: PUSH
7516: LD_EXP 4
7520: PPUSH
7521: LD_INT 25
7523: PUSH
7524: LD_INT 1
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: PPUSH
7531: CALL_OW 72
7535: PPUSH
7536: LD_EXP 36
7540: PPUSH
7541: CALL_OW 74
7545: ST_TO_ADDR
// if sol then
7546: LD_VAR 0 3
7550: IFFALSE 7610
// if GetDistUnits ( JMM , sol ) < 10 then
7552: LD_EXP 36
7556: PPUSH
7557: LD_VAR 0 3
7561: PPUSH
7562: CALL_OW 296
7566: PUSH
7567: LD_INT 10
7569: LESS
7570: IFFALSE 7610
// begin if IsInUnit ( sol ) then
7572: LD_VAR 0 3
7576: PPUSH
7577: CALL_OW 310
7581: IFFALSE 7592
// ComExitVehicle ( sol ) ;
7583: LD_VAR 0 3
7587: PPUSH
7588: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7592: LD_VAR 0 3
7596: PPUSH
7597: LD_VAR 0 4
7601: PUSH
7602: LD_INT 2
7604: ARRAY
7605: PPUSH
7606: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7610: LD_INT 10
7612: PPUSH
7613: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7617: LD_EXP 36
7621: PPUSH
7622: LD_INT 65
7624: PPUSH
7625: LD_INT 101
7627: PPUSH
7628: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7632: LD_EXP 36
7636: PPUSH
7637: LD_INT 63
7639: PPUSH
7640: LD_INT 100
7642: PPUSH
7643: CALL_OW 178
// tmp := 0 0$0 ;
7647: LD_ADDR_VAR 0 5
7651: PUSH
7652: LD_INT 0
7654: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7655: LD_INT 35
7657: PPUSH
7658: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7662: LD_ADDR_VAR 0 5
7666: PUSH
7667: LD_VAR 0 5
7671: PUSH
7672: LD_INT 35
7674: PLUS
7675: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7676: LD_EXP 36
7680: PPUSH
7681: LD_INT 65
7683: PPUSH
7684: LD_INT 101
7686: PPUSH
7687: CALL_OW 307
7691: PUSH
7692: LD_VAR 0 5
7696: PUSH
7697: LD_INT 175
7699: GREATER
7700: OR
7701: IFFALSE 7655
// Say ( JMM , D2a-JMM-1 ) ;
7703: LD_EXP 36
7707: PPUSH
7708: LD_STRING D2a-JMM-1
7710: PPUSH
7711: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7715: LD_EXP 47
7719: PPUSH
7720: LD_INT 66
7722: PPUSH
7723: LD_INT 103
7725: PPUSH
7726: CALL_OW 111
// tmp := 0 0$0 ;
7730: LD_ADDR_VAR 0 5
7734: PUSH
7735: LD_INT 0
7737: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7738: LD_INT 35
7740: PPUSH
7741: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7745: LD_EXP 47
7749: PPUSH
7750: LD_INT 66
7752: PPUSH
7753: LD_INT 103
7755: PPUSH
7756: CALL_OW 307
7760: PUSH
7761: LD_VAR 0 5
7765: PUSH
7766: LD_INT 175
7768: GREATER
7769: OR
7770: IFFALSE 7738
// ComTurnUnit ( Walker , JMM ) ;
7772: LD_EXP 47
7776: PPUSH
7777: LD_EXP 36
7781: PPUSH
7782: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7786: LD_EXP 47
7790: PPUSH
7791: LD_STRING D2a-Sci1-1
7793: PPUSH
7794: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7798: LD_EXP 36
7802: PPUSH
7803: LD_EXP 47
7807: PPUSH
7808: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7812: LD_EXP 36
7816: PPUSH
7817: LD_STRING D2a-JMM-2
7819: PPUSH
7820: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7824: LD_EXP 47
7828: PPUSH
7829: LD_STRING D2a-Sci1-2
7831: PPUSH
7832: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7836: LD_EXP 36
7840: PPUSH
7841: LD_STRING D2a-JMM-3
7843: PPUSH
7844: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7848: LD_EXP 47
7852: PPUSH
7853: LD_STRING D2a-Sci1-3
7855: PPUSH
7856: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7860: LD_ADDR_EXP 4
7864: PUSH
7865: LD_EXP 4
7869: PUSH
7870: LD_EXP 46
7874: PUSH
7875: LD_EXP 47
7879: PUSH
7880: LD_EXP 48
7884: PUSH
7885: LD_EXP 49
7889: PUSH
7890: EMPTY
7891: LIST
7892: LIST
7893: LIST
7894: LIST
7895: ADD
7896: ST_TO_ADDR
// for i in jmm_units do
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: LD_EXP 4
7906: PUSH
7907: FOR_IN
7908: IFFALSE 7933
// if not IsInUnit ( i ) then
7910: LD_VAR 0 1
7914: PPUSH
7915: CALL_OW 310
7919: NOT
7920: IFFALSE 7931
// ComFree ( i ) ;
7922: LD_VAR 0 1
7926: PPUSH
7927: CALL_OW 139
7931: GO 7907
7933: POP
7934: POP
// Video ( false ) ;
7935: LD_INT 0
7937: PPUSH
7938: CALL 1192 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7942: LD_STRING MSolar1
7944: PPUSH
7945: CALL_OW 337
// jmm_on_west := true ;
7949: LD_ADDR_EXP 5
7953: PUSH
7954: LD_INT 1
7956: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7957: LD_INT 1050
7959: PPUSH
7960: CALL_OW 67
// frank_can_return := true ;
7964: LD_ADDR_EXP 12
7968: PUSH
7969: LD_INT 1
7971: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7972: LD_INT 6300
7974: PPUSH
7975: LD_INT 8400
7977: PPUSH
7978: CALL_OW 12
7982: PPUSH
7983: CALL_OW 67
// send_spec_patrol := true ;
7987: LD_ADDR_EXP 29
7991: PUSH
7992: LD_INT 1
7994: ST_TO_ADDR
// end ;
7995: PPOPN 5
7997: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7998: LD_INT 22
8000: PUSH
8001: LD_INT 1
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PUSH
8008: LD_INT 34
8010: PUSH
8011: LD_INT 51
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: LD_INT 92
8020: PUSH
8021: LD_INT 63
8023: PUSH
8024: LD_INT 100
8026: PUSH
8027: LD_INT 5
8029: PUSH
8030: EMPTY
8031: LIST
8032: LIST
8033: LIST
8034: LIST
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: LIST
8040: PUSH
8041: EMPTY
8042: LIST
8043: PPUSH
8044: CALL_OW 69
8048: PUSH
8049: LD_EXP 5
8053: NOT
8054: AND
8055: IFFALSE 8168
8057: GO 8059
8059: DISABLE
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
// begin enable ;
8064: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8065: LD_ADDR_VAR 0 2
8069: PUSH
8070: LD_INT 22
8072: PUSH
8073: LD_INT 1
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: PUSH
8080: LD_INT 34
8082: PUSH
8083: LD_INT 51
8085: PUSH
8086: EMPTY
8087: LIST
8088: LIST
8089: PUSH
8090: LD_INT 92
8092: PUSH
8093: LD_INT 63
8095: PUSH
8096: LD_INT 100
8098: PUSH
8099: LD_INT 5
8101: PUSH
8102: EMPTY
8103: LIST
8104: LIST
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: LIST
8112: PUSH
8113: EMPTY
8114: LIST
8115: PPUSH
8116: CALL_OW 69
8120: ST_TO_ADDR
// if not filter then
8121: LD_VAR 0 2
8125: NOT
8126: IFFALSE 8130
// exit ;
8128: GO 8168
// for i in filter do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: LD_VAR 0 2
8139: PUSH
8140: FOR_IN
8141: IFFALSE 8166
// begin SetFuel ( i , 0 ) ;
8143: LD_VAR 0 1
8147: PPUSH
8148: LD_INT 0
8150: PPUSH
8151: CALL_OW 240
// ComStop ( i ) ;
8155: LD_VAR 0 1
8159: PPUSH
8160: CALL_OW 141
// end ;
8164: GO 8140
8166: POP
8167: POP
// end ;
8168: PPOPN 2
8170: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8171: LD_EXP 29
8175: IFFALSE 9168
8177: GO 8179
8179: DISABLE
8180: LD_INT 0
8182: PPUSH
8183: PPUSH
8184: PPUSH
8185: PPUSH
8186: PPUSH
8187: PPUSH
8188: PPUSH
// begin if not ru_spec_patrol then
8189: LD_EXP 53
8193: NOT
8194: IFFALSE 8198
// exit ;
8196: GO 9168
// dead1 := false ;
8198: LD_ADDR_VAR 0 1
8202: PUSH
8203: LD_INT 0
8205: ST_TO_ADDR
// dead2 := false ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_INT 0
8213: ST_TO_ADDR
// inarea1 := false ;
8214: LD_ADDR_VAR 0 3
8218: PUSH
8219: LD_INT 0
8221: ST_TO_ADDR
// inarea2 := false ;
8222: LD_ADDR_VAR 0 4
8226: PUSH
8227: LD_INT 0
8229: ST_TO_ADDR
// tmp := [ ] ;
8230: LD_ADDR_VAR 0 6
8234: PUSH
8235: EMPTY
8236: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8237: LD_EXP 53
8241: PPUSH
8242: LD_INT 75
8244: PPUSH
8245: LD_INT 101
8247: PPUSH
8248: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8252: LD_INT 35
8254: PPUSH
8255: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8259: LD_INT 1
8261: PPUSH
8262: LD_EXP 53
8266: PUSH
8267: LD_INT 1
8269: ARRAY
8270: PPUSH
8271: CALL_OW 292
8275: IFFALSE 8252
// ComStop ( ru_spec_patrol ) ;
8277: LD_EXP 53
8281: PPUSH
8282: CALL_OW 141
// Wait ( 0 0$02 ) ;
8286: LD_INT 70
8288: PPUSH
8289: CALL_OW 67
// DialogueOn ;
8293: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8297: LD_EXP 53
8301: PUSH
8302: LD_INT 1
8304: ARRAY
8305: PPUSH
8306: LD_STRING D8-Rus1-1
8308: PPUSH
8309: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8313: LD_EXP 36
8317: PPUSH
8318: LD_STRING D8-JMM-1
8320: PPUSH
8321: CALL_OW 88
// DialogueOff ;
8325: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8329: LD_EXP 53
8333: PPUSH
8334: LD_INT 13
8336: PPUSH
8337: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8341: LD_INT 35
8343: PPUSH
8344: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8348: LD_VAR 0 1
8352: NOT
8353: PUSH
8354: LD_EXP 53
8358: PUSH
8359: LD_INT 1
8361: ARRAY
8362: PPUSH
8363: CALL_OW 301
8367: AND
8368: IFFALSE 8378
// dead1 := true ;
8370: LD_ADDR_VAR 0 1
8374: PUSH
8375: LD_INT 1
8377: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8378: LD_VAR 0 2
8382: NOT
8383: PUSH
8384: LD_EXP 53
8388: PUSH
8389: LD_INT 2
8391: ARRAY
8392: PPUSH
8393: CALL_OW 301
8397: AND
8398: IFFALSE 8408
// dead2 := true ;
8400: LD_ADDR_VAR 0 2
8404: PUSH
8405: LD_INT 1
8407: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8408: LD_VAR 0 3
8412: NOT
8413: PUSH
8414: LD_EXP 53
8418: PUSH
8419: LD_INT 1
8421: ARRAY
8422: PPUSH
8423: LD_INT 14
8425: PPUSH
8426: CALL_OW 308
8430: AND
8431: IFFALSE 8441
// inarea1 := true ;
8433: LD_ADDR_VAR 0 3
8437: PUSH
8438: LD_INT 1
8440: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8441: LD_VAR 0 4
8445: NOT
8446: PUSH
8447: LD_EXP 53
8451: PUSH
8452: LD_INT 2
8454: ARRAY
8455: PPUSH
8456: LD_INT 14
8458: PPUSH
8459: CALL_OW 308
8463: AND
8464: IFFALSE 8474
// inarea2 := true ;
8466: LD_ADDR_VAR 0 4
8470: PUSH
8471: LD_INT 1
8473: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8474: LD_VAR 0 1
8478: PUSH
8479: LD_VAR 0 2
8483: AND
8484: PUSH
8485: LD_VAR 0 1
8489: PUSH
8490: LD_VAR 0 4
8494: AND
8495: OR
8496: PUSH
8497: LD_VAR 0 2
8501: PUSH
8502: LD_VAR 0 3
8506: AND
8507: OR
8508: PUSH
8509: LD_VAR 0 3
8513: PUSH
8514: LD_VAR 0 4
8518: AND
8519: OR
8520: IFFALSE 8341
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8522: LD_VAR 0 3
8526: PUSH
8527: LD_VAR 0 4
8531: AND
8532: PUSH
8533: LD_VAR 0 1
8537: PUSH
8538: LD_VAR 0 4
8542: AND
8543: OR
8544: PUSH
8545: LD_VAR 0 2
8549: PUSH
8550: LD_VAR 0 3
8554: AND
8555: OR
8556: IFFALSE 9148
// begin prepare_siege := true ;
8558: LD_ADDR_EXP 30
8562: PUSH
8563: LD_INT 1
8565: ST_TO_ADDR
// DialogueOn ;
8566: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8570: LD_VAR 0 3
8574: PUSH
8575: LD_VAR 0 4
8579: AND
8580: IFFALSE 8596
// Say ( JMM , D8b-JMM-1a ) else
8582: LD_EXP 36
8586: PPUSH
8587: LD_STRING D8b-JMM-1a
8589: PPUSH
8590: CALL_OW 88
8594: GO 8608
// Say ( JMM , D8b-JMM-1 ) ;
8596: LD_EXP 36
8600: PPUSH
8601: LD_STRING D8b-JMM-1
8603: PPUSH
8604: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8608: LD_EXP 4
8612: PPUSH
8613: LD_INT 26
8615: PUSH
8616: LD_INT 1
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: PPUSH
8623: CALL_OW 72
8627: PUSH
8628: LD_EXP 37
8632: PUSH
8633: LD_EXP 38
8637: PUSH
8638: LD_EXP 47
8642: PUSH
8643: LD_EXP 50
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: DIFF
8654: PPUSH
8655: LD_STRING D8b-Sol1-1
8657: PPUSH
8658: CALL 632 0 2
// if Cyrus and Cyrus in jmm_units then
8662: LD_EXP 38
8666: PUSH
8667: LD_EXP 38
8671: PUSH
8672: LD_EXP 4
8676: IN
8677: AND
8678: IFFALSE 8694
// Say ( Cyrus , D8b-Cyrus-1 ) else
8680: LD_EXP 38
8684: PPUSH
8685: LD_STRING D8b-Cyrus-1
8687: PPUSH
8688: CALL_OW 88
8692: GO 8706
// Say ( JMM , D8b-JMM-1a ) ;
8694: LD_EXP 36
8698: PPUSH
8699: LD_STRING D8b-JMM-1a
8701: PPUSH
8702: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8706: LD_EXP 39
8710: PUSH
8711: LD_EXP 39
8715: PUSH
8716: LD_EXP 4
8720: IN
8721: AND
8722: IFFALSE 8736
// Say ( Lisa , D8b-Lisa-2 ) ;
8724: LD_EXP 39
8728: PPUSH
8729: LD_STRING D8b-Lisa-2
8731: PPUSH
8732: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8736: LD_EXP 37
8740: PUSH
8741: LD_EXP 37
8745: PUSH
8746: LD_EXP 4
8750: IN
8751: AND
8752: IFFALSE 8768
// Say ( Bobby , D8b-Bobby-1 ) else
8754: LD_EXP 37
8758: PPUSH
8759: LD_STRING D8b-Bobby-1
8761: PPUSH
8762: CALL_OW 88
8766: GO 8828
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8768: LD_ADDR_VAR 0 5
8772: PUSH
8773: LD_EXP 4
8777: PPUSH
8778: LD_INT 26
8780: PUSH
8781: LD_INT 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PPUSH
8788: CALL_OW 72
8792: PUSH
8793: LD_EXP 37
8797: PUSH
8798: LD_EXP 38
8802: PUSH
8803: LD_EXP 47
8807: PUSH
8808: LD_EXP 50
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: DIFF
8819: PPUSH
8820: LD_STRING D8b-Sol2-1
8822: PPUSH
8823: CALL 632 0 2
8827: ST_TO_ADDR
// DialogueOff ;
8828: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8832: LD_EXP 38
8836: PUSH
8837: LD_EXP 38
8841: PUSH
8842: LD_EXP 4
8846: IN
8847: AND
8848: IFFALSE 8873
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8850: LD_ADDR_VAR 0 6
8854: PUSH
8855: LD_VAR 0 6
8859: PPUSH
8860: LD_INT 1
8862: PPUSH
8863: LD_EXP 38
8867: PPUSH
8868: CALL_OW 2
8872: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8873: LD_EXP 37
8877: PUSH
8878: LD_EXP 37
8882: PUSH
8883: LD_EXP 4
8887: IN
8888: AND
8889: IFFALSE 8914
// tmp := Insert ( tmp , 1 , Bobby ) ;
8891: LD_ADDR_VAR 0 6
8895: PUSH
8896: LD_VAR 0 6
8900: PPUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_EXP 37
8908: PPUSH
8909: CALL_OW 2
8913: ST_TO_ADDR
// if sol then
8914: LD_VAR 0 5
8918: IFFALSE 8943
// tmp := Insert ( tmp , 1 , sol ) ;
8920: LD_ADDR_VAR 0 6
8924: PUSH
8925: LD_VAR 0 6
8929: PPUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_VAR 0 5
8937: PPUSH
8938: CALL_OW 2
8942: ST_TO_ADDR
// if tmp then
8943: LD_VAR 0 6
8947: IFFALSE 9107
// begin SetSide ( tmp , 8 ) ;
8949: LD_VAR 0 6
8953: PPUSH
8954: LD_INT 8
8956: PPUSH
8957: CALL_OW 235
// ComFree ( tmp ) ;
8961: LD_VAR 0 6
8965: PPUSH
8966: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8970: LD_VAR 0 6
8974: PPUSH
8975: LD_INT 15
8977: PPUSH
8978: CALL_OW 173
// AddComHold ( tmp ) ;
8982: LD_VAR 0 6
8986: PPUSH
8987: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8991: LD_INT 35
8993: PPUSH
8994: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8998: LD_VAR 0 6
9002: PUSH
9003: LD_INT 1
9005: ARRAY
9006: PPUSH
9007: CALL_OW 314
9011: NOT
9012: IFFALSE 9026
// ComMoveToArea ( tmp , cyrusEscape ) ;
9014: LD_VAR 0 6
9018: PPUSH
9019: LD_INT 15
9021: PPUSH
9022: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9026: LD_VAR 0 6
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: PPUSH
9035: LD_INT 15
9037: PPUSH
9038: CALL_OW 308
9042: IFFALSE 9097
// begin RemoveUnit ( tmp [ 1 ] ) ;
9044: LD_VAR 0 6
9048: PUSH
9049: LD_INT 1
9051: ARRAY
9052: PPUSH
9053: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9057: LD_ADDR_EXP 4
9061: PUSH
9062: LD_EXP 4
9066: PUSH
9067: LD_VAR 0 6
9071: PUSH
9072: LD_INT 1
9074: ARRAY
9075: DIFF
9076: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9077: LD_ADDR_VAR 0 6
9081: PUSH
9082: LD_VAR 0 6
9086: PUSH
9087: LD_VAR 0 6
9091: PUSH
9092: LD_INT 1
9094: ARRAY
9095: DIFF
9096: ST_TO_ADDR
// end ; until tmp = 0 ;
9097: LD_VAR 0 6
9101: PUSH
9102: LD_INT 0
9104: EQUAL
9105: IFFALSE 8991
// end ; Wait ( 0 0$30 ) ;
9107: LD_INT 1050
9109: PPUSH
9110: CALL_OW 67
// if ru_spec_patrol then
9114: LD_EXP 53
9118: IFFALSE 9146
// for i in ru_spec_patrol do
9120: LD_ADDR_VAR 0 7
9124: PUSH
9125: LD_EXP 53
9129: PUSH
9130: FOR_IN
9131: IFFALSE 9144
// RemoveUnit ( i ) ;
9133: LD_VAR 0 7
9137: PPUSH
9138: CALL_OW 64
9142: GO 9130
9144: POP
9145: POP
// end else
9146: GO 9168
// begin prepare_siege := false ;
9148: LD_ADDR_EXP 30
9152: PUSH
9153: LD_INT 0
9155: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9156: LD_EXP 36
9160: PPUSH
9161: LD_STRING D8a-JMM-1
9163: PPUSH
9164: CALL_OW 88
// end ; end ;
9168: PPOPN 7
9170: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9171: LD_EXP 12
9175: IFFALSE 10392
9177: GO 9179
9179: DISABLE
9180: LD_INT 0
9182: PPUSH
9183: PPUSH
9184: PPUSH
// begin uc_side := 8 ;
9185: LD_ADDR_OWVAR 20
9189: PUSH
9190: LD_INT 8
9192: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9193: LD_ADDR_VAR 0 3
9197: PUSH
9198: LD_INT 59
9200: PUSH
9201: LD_INT 71
9203: PUSH
9204: EMPTY
9205: LIST
9206: LIST
9207: PUSH
9208: LD_INT 122
9210: PUSH
9211: LD_INT 117
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9222: LD_ADDR_EXP 50
9226: PUSH
9227: LD_STRING Frank
9229: PPUSH
9230: LD_INT 0
9232: PPUSH
9233: CALL 481 0 2
9237: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9238: LD_ADDR_VAR 0 1
9242: PUSH
9243: LD_INT 1
9245: PPUSH
9246: LD_INT 2
9248: PPUSH
9249: CALL_OW 12
9253: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9254: LD_EXP 50
9258: PPUSH
9259: LD_VAR 0 3
9263: PUSH
9264: LD_VAR 0 1
9268: ARRAY
9269: PUSH
9270: LD_INT 1
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 3
9278: PUSH
9279: LD_VAR 0 1
9283: ARRAY
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9296: LD_EXP 50
9300: PPUSH
9301: LD_INT 1
9303: PPUSH
9304: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9308: LD_INT 35
9310: PPUSH
9311: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9315: LD_EXP 50
9319: PPUSH
9320: LD_EXP 36
9324: PPUSH
9325: CALL_OW 296
9329: PUSH
9330: LD_INT 8
9332: LESS
9333: PUSH
9334: LD_EXP 50
9338: PPUSH
9339: CALL_OW 256
9343: PUSH
9344: LD_INT 250
9346: GREATER
9347: AND
9348: IFFALSE 9308
// Video ( true ) ;
9350: LD_INT 1
9352: PPUSH
9353: CALL 1192 0 1
// CenterOnUnits ( JMM ) ;
9357: LD_EXP 36
9361: PPUSH
9362: CALL_OW 85
// if IsInUnit ( JMM ) then
9366: LD_EXP 36
9370: PPUSH
9371: CALL_OW 310
9375: IFFALSE 9386
// ComFree ( JMM ) ;
9377: LD_EXP 36
9381: PPUSH
9382: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9386: LD_EXP 36
9390: PPUSH
9391: LD_EXP 50
9395: PPUSH
9396: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9400: LD_EXP 50
9404: PPUSH
9405: LD_EXP 36
9409: PPUSH
9410: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9414: LD_EXP 36
9418: PPUSH
9419: LD_STRING D6-JMM-1
9421: PPUSH
9422: CALL_OW 88
// p := 0 ;
9426: LD_ADDR_VAR 0 2
9430: PUSH
9431: LD_INT 0
9433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9434: LD_INT 35
9436: PPUSH
9437: CALL_OW 67
// p := p + 1 ;
9441: LD_ADDR_VAR 0 2
9445: PUSH
9446: LD_VAR 0 2
9450: PUSH
9451: LD_INT 1
9453: PLUS
9454: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9455: LD_EXP 36
9459: PPUSH
9460: LD_EXP 50
9464: PPUSH
9465: CALL_OW 296
9469: PUSH
9470: LD_INT 8
9472: LESS
9473: PUSH
9474: LD_VAR 0 2
9478: PUSH
9479: LD_INT 7
9481: GREATER
9482: OR
9483: IFFALSE 9434
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9485: LD_EXP 39
9489: PUSH
9490: LD_EXP 39
9494: PPUSH
9495: LD_EXP 50
9499: PPUSH
9500: CALL_OW 296
9504: PUSH
9505: LD_INT 20
9507: LESS
9508: AND
9509: IFFALSE 9534
// begin ComFree ( Lisa ) ;
9511: LD_EXP 39
9515: PPUSH
9516: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9520: LD_EXP 39
9524: PPUSH
9525: LD_EXP 50
9529: PPUSH
9530: CALL_OW 172
// end ; if Lynch then
9534: LD_EXP 46
9538: IFFALSE 9563
// begin ComFree ( Lynch ) ;
9540: LD_EXP 46
9544: PPUSH
9545: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9549: LD_EXP 46
9553: PPUSH
9554: LD_EXP 50
9558: PPUSH
9559: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9563: LD_EXP 36
9567: PPUSH
9568: LD_EXP 50
9572: PPUSH
9573: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9577: LD_EXP 50
9581: PPUSH
9582: LD_EXP 36
9586: PPUSH
9587: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9591: LD_EXP 50
9595: PPUSH
9596: LD_STRING D6-Frank-1
9598: PPUSH
9599: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9603: LD_INT 69
9605: PPUSH
9606: LD_INT 20
9608: PPUSH
9609: LD_INT 1
9611: PPUSH
9612: LD_INT 20
9614: NEG
9615: PPUSH
9616: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9620: LD_INT 69
9622: PPUSH
9623: LD_INT 20
9625: PPUSH
9626: LD_INT 1
9628: PPUSH
9629: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9633: LD_INT 190
9635: PPUSH
9636: LD_INT 31
9638: PPUSH
9639: LD_INT 1
9641: PPUSH
9642: LD_INT 20
9644: NEG
9645: PPUSH
9646: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9650: LD_INT 190
9652: PPUSH
9653: LD_INT 31
9655: PPUSH
9656: LD_INT 1
9658: PPUSH
9659: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9663: LD_INT 69
9665: PPUSH
9666: LD_INT 20
9668: PPUSH
9669: CALL_OW 84
// Wait ( 0 0$02 ) ;
9673: LD_INT 70
9675: PPUSH
9676: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9680: LD_EXP 36
9684: PPUSH
9685: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9689: LD_EXP 39
9693: PUSH
9694: LD_EXP 39
9698: PPUSH
9699: LD_EXP 50
9703: PPUSH
9704: CALL_OW 296
9708: PUSH
9709: LD_INT 20
9711: LESS
9712: AND
9713: PUSH
9714: LD_EXP 39
9718: PPUSH
9719: CALL_OW 302
9723: AND
9724: IFFALSE 9846
// begin ComFree ( Lisa ) ;
9726: LD_EXP 39
9730: PPUSH
9731: CALL_OW 139
// p := 0 ;
9735: LD_ADDR_VAR 0 2
9739: PUSH
9740: LD_INT 0
9742: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9743: LD_INT 35
9745: PPUSH
9746: CALL_OW 67
// p := p + 1 ;
9750: LD_ADDR_VAR 0 2
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: LD_INT 1
9762: PLUS
9763: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9764: LD_EXP 39
9768: PPUSH
9769: LD_EXP 50
9773: PPUSH
9774: CALL_OW 296
9778: PUSH
9779: LD_INT 7
9781: LESS
9782: PUSH
9783: LD_VAR 0 2
9787: PUSH
9788: LD_INT 7
9790: GREATER
9791: OR
9792: IFFALSE 9743
// Say ( Lisa , D6-Lisa-1 ) ;
9794: LD_EXP 39
9798: PPUSH
9799: LD_STRING D6-Lisa-1
9801: PPUSH
9802: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9806: LD_EXP 39
9810: PPUSH
9811: LD_EXP 50
9815: PPUSH
9816: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9820: LD_EXP 50
9824: PPUSH
9825: LD_EXP 39
9829: PPUSH
9830: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9834: LD_EXP 50
9838: PPUSH
9839: LD_STRING D6-Frank-2
9841: PPUSH
9842: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9846: LD_EXP 46
9850: PUSH
9851: LD_EXP 46
9855: PPUSH
9856: LD_EXP 50
9860: PPUSH
9861: CALL_OW 296
9865: PUSH
9866: LD_INT 20
9868: LESS
9869: AND
9870: PUSH
9871: LD_EXP 46
9875: PPUSH
9876: CALL_OW 302
9880: AND
9881: IFFALSE 10062
// begin ComTurnUnit ( Lynch , JMM ) ;
9883: LD_EXP 46
9887: PPUSH
9888: LD_EXP 36
9892: PPUSH
9893: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9897: LD_EXP 50
9901: PPUSH
9902: LD_EXP 36
9906: PPUSH
9907: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9911: LD_EXP 46
9915: PPUSH
9916: LD_STRING D6-Sol1-2
9918: PPUSH
9919: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9923: LD_EXP 36
9927: PPUSH
9928: LD_STRING D6-JMM-2
9930: PPUSH
9931: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9935: LD_EXP 50
9939: PPUSH
9940: LD_STRING D6-Frank-3
9942: PPUSH
9943: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9947: LD_EXP 36
9951: PPUSH
9952: LD_STRING D6-JMM-3
9954: PPUSH
9955: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9959: LD_EXP 50
9963: PPUSH
9964: LD_STRING D6-Frank-4
9966: PPUSH
9967: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9971: LD_EXP 50
9975: PPUSH
9976: LD_STRING D6-Frank-4a
9978: PPUSH
9979: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9983: LD_EXP 36
9987: PPUSH
9988: LD_STRING D6-JMM-4
9990: PPUSH
9991: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9995: LD_EXP 50
9999: PPUSH
10000: LD_STRING D6-Frank-5
10002: PPUSH
10003: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10007: LD_EXP 39
10011: PUSH
10012: LD_EXP 39
10016: PPUSH
10017: CALL_OW 302
10021: AND
10022: IFFALSE 10036
// Say ( Lisa , D6-Lisa-5 ) ;
10024: LD_EXP 39
10028: PPUSH
10029: LD_STRING D6-Lisa-5
10031: PPUSH
10032: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10036: LD_EXP 50
10040: PPUSH
10041: LD_STRING D6-Frank-6
10043: PPUSH
10044: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10048: LD_EXP 36
10052: PPUSH
10053: LD_STRING D6-JMM-6
10055: PPUSH
10056: CALL_OW 88
// end else
10060: GO 10177
// begin ComTurnUnit ( Frank , JMM ) ;
10062: LD_EXP 50
10066: PPUSH
10067: LD_EXP 36
10071: PPUSH
10072: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10076: LD_EXP 50
10080: PPUSH
10081: LD_STRING D6-Frank-4
10083: PPUSH
10084: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10088: LD_EXP 50
10092: PPUSH
10093: LD_STRING D6-Frank-4a
10095: PPUSH
10096: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10100: LD_EXP 36
10104: PPUSH
10105: LD_STRING D6-JMM-4
10107: PPUSH
10108: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10112: LD_EXP 50
10116: PPUSH
10117: LD_STRING D6-Frank-5
10119: PPUSH
10120: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10124: LD_EXP 39
10128: PUSH
10129: LD_EXP 39
10133: PPUSH
10134: CALL_OW 302
10138: AND
10139: IFFALSE 10153
// Say ( Lisa , D6-Lisa-5 ) ;
10141: LD_EXP 39
10145: PPUSH
10146: LD_STRING D6-Lisa-5
10148: PPUSH
10149: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10153: LD_EXP 50
10157: PPUSH
10158: LD_STRING D6-Frank-6
10160: PPUSH
10161: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10165: LD_EXP 36
10169: PPUSH
10170: LD_STRING D6-JMM-6
10172: PPUSH
10173: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10177: LD_STRING Q1
10179: PPUSH
10180: CALL_OW 97
10184: PUSH
10185: LD_INT 1
10187: DOUBLE
10188: EQUAL
10189: IFTRUE 10193
10191: GO 10204
10193: POP
// frank_send_to_scout := true ; 2 :
10194: LD_ADDR_EXP 14
10198: PUSH
10199: LD_INT 1
10201: ST_TO_ADDR
10202: GO 10224
10204: LD_INT 2
10206: DOUBLE
10207: EQUAL
10208: IFTRUE 10212
10210: GO 10223
10212: POP
// frank_send_to_scout := false ; end ;
10213: LD_ADDR_EXP 14
10217: PUSH
10218: LD_INT 0
10220: ST_TO_ADDR
10221: GO 10224
10223: POP
// Video ( false ) ;
10224: LD_INT 0
10226: PPUSH
10227: CALL 1192 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10231: LD_EXP 36
10235: PUSH
10236: LD_EXP 39
10240: PUSH
10241: LD_EXP 46
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: PPUSH
10251: CALL_OW 139
// if frank_send_to_scout then
10255: LD_EXP 14
10259: IFFALSE 10313
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10261: LD_EXP 50
10265: PPUSH
10266: LD_INT 15
10268: PPUSH
10269: CALL_OW 113
// wait ( 0 0$01 ) ;
10273: LD_INT 35
10275: PPUSH
10276: CALL_OW 67
// until not See ( 1 , Frank ) ;
10280: LD_INT 1
10282: PPUSH
10283: LD_EXP 50
10287: PPUSH
10288: CALL_OW 292
10292: NOT
10293: IFFALSE 10261
// wait ( 0 0$02 ) ;
10295: LD_INT 70
10297: PPUSH
10298: CALL_OW 67
// RemoveUnit ( Frank ) ;
10302: LD_EXP 50
10306: PPUSH
10307: CALL_OW 64
// end else
10311: GO 10325
// SetSide ( Frank , 1 ) ;
10313: LD_EXP 50
10317: PPUSH
10318: LD_INT 1
10320: PPUSH
10321: CALL_OW 235
// send_attack_on_cornel_base := true ;
10325: LD_ADDR_EXP 25
10329: PUSH
10330: LD_INT 1
10332: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10333: LD_INT 35
10335: PPUSH
10336: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10340: LD_ADDR_EXP 28
10344: PUSH
10345: LD_EXP 28
10349: PPUSH
10350: LD_STRING -
10352: PPUSH
10353: CALL 1124 0 2
10357: ST_TO_ADDR
// if debug then
10358: LD_EXP 1
10362: IFFALSE 10374
// debug_strings := time_to_prepare ;
10364: LD_ADDR_OWVAR 48
10368: PUSH
10369: LD_EXP 28
10373: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10374: LD_EXP 28
10378: PUSH
10379: LD_INT 0
10381: EQUAL
10382: IFFALSE 10333
// cornel_prepared := true ;
10384: LD_ADDR_EXP 11
10388: PUSH
10389: LD_INT 1
10391: ST_TO_ADDR
// end ;
10392: PPOPN 3
10394: END
// every 0 0$01 trigger cornel_prepared do
10395: LD_EXP 11
10399: IFFALSE 10663
10401: GO 10403
10403: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10404: LD_EXP 43
10408: PPUSH
10409: LD_STRING D3-Corn-1
10411: PPUSH
10412: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10416: LD_STRING MOutWait
10418: PPUSH
10419: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10423: LD_INT 35
10425: PPUSH
10426: CALL_OW 67
// until cornel_counter = 0 ;
10430: LD_EXP 10
10434: PUSH
10435: LD_INT 0
10437: EQUAL
10438: IFFALSE 10423
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10440: LD_EXP 43
10444: PPUSH
10445: LD_STRING D3a-Corn-1
10447: PPUSH
10448: CALL_OW 94
// if IsOk ( Cornel ) then
10452: LD_EXP 43
10456: PPUSH
10457: CALL_OW 302
10461: IFFALSE 10475
// Say ( JMM , D3a-JMM-1 ) ;
10463: LD_EXP 36
10467: PPUSH
10468: LD_STRING D3a-JMM-1
10470: PPUSH
10471: CALL_OW 88
// end_mission_allowed := true ;
10475: LD_ADDR_EXP 20
10479: PUSH
10480: LD_INT 1
10482: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10483: LD_STRING M2
10485: PPUSH
10486: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10490: LD_INT 9
10492: PPUSH
10493: LD_INT 1
10495: PPUSH
10496: CALL_OW 424
// Wait ( 0 0$05 ) ;
10500: LD_INT 175
10502: PPUSH
10503: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10507: LD_EXP 43
10511: PPUSH
10512: LD_STRING D3a-Corn-2
10514: PPUSH
10515: CALL_OW 94
// cornel_attack := true ;
10519: LD_ADDR_EXP 9
10523: PUSH
10524: LD_INT 1
10526: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10527: LD_INT 105
10529: PPUSH
10530: CALL_OW 67
// AddMoreTanks ( ) ;
10534: CALL 4869 0 0
// if frank_send_to_scout then
10538: LD_EXP 14
10542: IFFALSE 10663
// begin InitHc ;
10544: CALL_OW 19
// InitUc ;
10548: CALL_OW 18
// uc_side := 8 ;
10552: LD_ADDR_OWVAR 20
10556: PUSH
10557: LD_INT 8
10559: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10560: LD_ADDR_EXP 50
10564: PUSH
10565: LD_STRING Frank
10567: PPUSH
10568: LD_INT 0
10570: PPUSH
10571: CALL 481 0 2
10575: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10576: LD_EXP 50
10580: PPUSH
10581: LD_INT 6
10583: PPUSH
10584: LD_INT 9
10586: PPUSH
10587: LD_INT 0
10589: PPUSH
10590: CALL_OW 48
// ComCrawl ( Frank ) ;
10594: LD_EXP 50
10598: PPUSH
10599: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10603: LD_INT 35
10605: PPUSH
10606: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10610: LD_EXP 36
10614: PPUSH
10615: LD_EXP 50
10619: PPUSH
10620: CALL_OW 296
10624: PUSH
10625: LD_INT 9
10627: LESS
10628: IFFALSE 10603
// SetSide ( Frank , 1 ) ;
10630: LD_EXP 50
10634: PPUSH
10635: LD_INT 1
10637: PPUSH
10638: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10642: LD_EXP 50
10646: PPUSH
10647: LD_STRING D6a-Frank-1
10649: PPUSH
10650: CALL_OW 88
// ComWalk ( Frank ) ;
10654: LD_EXP 50
10658: PPUSH
10659: CALL_OW 138
// end ; end ;
10663: END
// every 0 0$01 trigger solar_builded do
10664: LD_EXP 13
10668: IFFALSE 10772
10670: GO 10672
10672: DISABLE
// begin Wait ( 0 0$02 ) ;
10673: LD_INT 70
10675: PPUSH
10676: CALL_OW 67
// DialogueOn ;
10680: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10684: LD_EXP 36
10688: PPUSH
10689: LD_STRING D2b-JMM-1
10691: PPUSH
10692: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10696: LD_EXP 47
10700: PUSH
10701: LD_EXP 47
10705: PPUSH
10706: CALL_OW 302
10710: AND
10711: IFFALSE 10761
// begin Say ( Walker , D2b-Sci1-1 ) ;
10713: LD_EXP 47
10717: PPUSH
10718: LD_STRING D2b-Sci1-1
10720: PPUSH
10721: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10725: LD_EXP 36
10729: PPUSH
10730: LD_STRING D2b-JMM-2
10732: PPUSH
10733: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10737: LD_EXP 47
10741: PPUSH
10742: LD_STRING D2b-Sci1-2
10744: PPUSH
10745: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10749: LD_EXP 36
10753: PPUSH
10754: LD_STRING D2b-JMM-3
10756: PPUSH
10757: CALL_OW 88
// end ; DialogueOff ;
10761: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10765: LD_STRING MOutSol
10767: PPUSH
10768: CALL_OW 337
// end ;
10772: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10773: LD_EXP 13
10777: PUSH
10778: LD_EXP 36
10782: PPUSH
10783: CALL_OW 302
10787: AND
10788: PUSH
10789: LD_EXP 36
10793: PPUSH
10794: CALL 958 0 1
10798: AND
10799: PUSH
10800: LD_EXP 15
10804: NOT
10805: AND
10806: IFFALSE 10877
10808: GO 10810
10810: DISABLE
10811: LD_INT 0
10813: PPUSH
// begin jmm_in_veh := true ;
10814: LD_ADDR_EXP 15
10818: PUSH
10819: LD_INT 1
10821: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10822: LD_ADDR_VAR 0 1
10826: PUSH
10827: LD_INT 0
10829: PPUSH
10830: LD_INT 1
10832: PPUSH
10833: CALL_OW 12
10837: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10838: LD_INT 70
10840: PPUSH
10841: CALL_OW 67
// if i then
10845: LD_VAR 0 1
10849: IFFALSE 10865
// Say ( JMM , D2c-JMM-1 ) else
10851: LD_EXP 36
10855: PPUSH
10856: LD_STRING D2c-JMM-1
10858: PPUSH
10859: CALL_OW 88
10863: GO 10877
// Say ( JMM , D2c-JMM-1a ) ;
10865: LD_EXP 36
10869: PPUSH
10870: LD_STRING D2c-JMM-1a
10872: PPUSH
10873: CALL_OW 88
// end ;
10877: PPOPN 1
10879: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10880: LD_EXP 13
10884: PUSH
10885: LD_EXP 37
10889: PPUSH
10890: CALL_OW 302
10894: AND
10895: PUSH
10896: LD_EXP 37
10900: PPUSH
10901: CALL 958 0 1
10905: AND
10906: PUSH
10907: LD_EXP 16
10911: NOT
10912: AND
10913: IFFALSE 10945
10915: GO 10917
10917: DISABLE
// begin bobby_in_veh := true ;
10918: LD_ADDR_EXP 16
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10926: LD_INT 70
10928: PPUSH
10929: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10933: LD_EXP 37
10937: PPUSH
10938: LD_STRING D2c-Bobby-1
10940: PPUSH
10941: CALL_OW 88
10945: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10946: LD_EXP 13
10950: PUSH
10951: LD_EXP 39
10955: PPUSH
10956: CALL_OW 302
10960: AND
10961: PUSH
10962: LD_EXP 39
10966: PPUSH
10967: CALL 958 0 1
10971: AND
10972: PUSH
10973: LD_EXP 18
10977: NOT
10978: AND
10979: IFFALSE 11011
10981: GO 10983
10983: DISABLE
// begin lisa_in_veh := true ;
10984: LD_ADDR_EXP 18
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10992: LD_INT 70
10994: PPUSH
10995: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10999: LD_EXP 39
11003: PPUSH
11004: LD_STRING D2c-Lisa-1
11006: PPUSH
11007: CALL_OW 88
11011: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11012: LD_EXP 13
11016: PUSH
11017: LD_EXP 38
11021: PPUSH
11022: CALL_OW 302
11026: AND
11027: PUSH
11028: LD_EXP 38
11032: PPUSH
11033: CALL 958 0 1
11037: AND
11038: PUSH
11039: LD_EXP 17
11043: NOT
11044: AND
11045: IFFALSE 11116
11047: GO 11049
11049: DISABLE
11050: LD_INT 0
11052: PPUSH
// begin cyrus_in_veh := true ;
11053: LD_ADDR_EXP 17
11057: PUSH
11058: LD_INT 1
11060: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_INT 0
11068: PPUSH
11069: LD_INT 1
11071: PPUSH
11072: CALL_OW 12
11076: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11077: LD_INT 70
11079: PPUSH
11080: CALL_OW 67
// if i then
11084: LD_VAR 0 1
11088: IFFALSE 11104
// Say ( Cyrus , D2c-Cyrus-1 ) else
11090: LD_EXP 38
11094: PPUSH
11095: LD_STRING D2c-Cyrus-1
11097: PPUSH
11098: CALL_OW 88
11102: GO 11116
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11104: LD_EXP 38
11108: PPUSH
11109: LD_STRING D2c-Cyrus-1a
11111: PPUSH
11112: CALL_OW 88
// end ;
11116: PPOPN 1
11118: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11119: LD_EXP 43
11123: PPUSH
11124: LD_INT 16
11126: PPUSH
11127: CALL_OW 308
11131: IFFALSE 11412
11133: GO 11135
11135: DISABLE
11136: LD_INT 0
11138: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11139: LD_INT 3
11141: PPUSH
11142: LD_EXP 43
11146: PPUSH
11147: CALL_OW 471
// send_attack_on_cornel := true ;
11151: LD_ADDR_EXP 31
11155: PUSH
11156: LD_INT 1
11158: ST_TO_ADDR
// if ru_vehicles then
11159: LD_EXP 55
11163: IFFALSE 11197
// for i in ru_vehicles do
11165: LD_ADDR_VAR 0 1
11169: PUSH
11170: LD_EXP 55
11174: PUSH
11175: FOR_IN
11176: IFFALSE 11195
// ComAgressiveMove ( i , 215 , 69 ) ;
11178: LD_VAR 0 1
11182: PPUSH
11183: LD_INT 215
11185: PPUSH
11186: LD_INT 69
11188: PPUSH
11189: CALL_OW 114
11193: GO 11175
11195: POP
11196: POP
// if ru_patrol then
11197: LD_EXP 52
11201: IFFALSE 11235
// for i in ru_patrol do
11203: LD_ADDR_VAR 0 1
11207: PUSH
11208: LD_EXP 52
11212: PUSH
11213: FOR_IN
11214: IFFALSE 11233
// ComAgressiveMove ( i , 215 , 69 ) ;
11216: LD_VAR 0 1
11220: PPUSH
11221: LD_INT 215
11223: PPUSH
11224: LD_INT 69
11226: PPUSH
11227: CALL_OW 114
11231: GO 11213
11233: POP
11234: POP
// if frank_send_to_scout then
11235: LD_EXP 14
11239: IFFALSE 11253
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11241: LD_EXP 50
11245: PPUSH
11246: LD_STRING D3b-Frank-1
11248: PPUSH
11249: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11253: LD_INT 105
11255: PPUSH
11256: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11260: LD_EXP 43
11264: PPUSH
11265: LD_STRING D4-Corn-1
11267: PPUSH
11268: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11272: LD_INT 35
11274: PPUSH
11275: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11279: LD_INT 22
11281: PUSH
11282: LD_INT 4
11284: PUSH
11285: EMPTY
11286: LIST
11287: LIST
11288: PUSH
11289: LD_INT 21
11291: PUSH
11292: LD_INT 1
11294: PUSH
11295: EMPTY
11296: LIST
11297: LIST
11298: PUSH
11299: LD_INT 3
11301: PUSH
11302: LD_INT 24
11304: PUSH
11305: LD_INT 1000
11307: PUSH
11308: EMPTY
11309: LIST
11310: LIST
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: LIST
11320: PPUSH
11321: CALL_OW 69
11325: PUSH
11326: LD_INT 6
11328: LESS
11329: IFFALSE 11272
// if Cornel then
11331: LD_EXP 43
11335: IFFALSE 11375
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11337: LD_EXP 43
11341: PPUSH
11342: LD_STRING D5-Corn-1
11344: PPUSH
11345: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11349: LD_EXP 43
11353: PPUSH
11354: LD_EXP 2
11358: PUSH
11359: LD_STRING Cornel
11361: STR
11362: PPUSH
11363: CALL_OW 38
// cornel_saved := true ;
11367: LD_ADDR_EXP 26
11371: PUSH
11372: LD_INT 1
11374: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11375: LD_INT 4
11377: PPUSH
11378: LD_INT 8
11380: PPUSH
11381: CALL_OW 343
// Wait ( 0 0$01 ) ;
11385: LD_INT 35
11387: PPUSH
11388: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11392: LD_INT 3
11394: PPUSH
11395: LD_EXP 43
11399: PPUSH
11400: CALL_OW 472
// send_attack_on_cornel := false ;
11404: LD_ADDR_EXP 31
11408: PUSH
11409: LD_INT 0
11411: ST_TO_ADDR
// end ;
11412: PPOPN 1
11414: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11415: LD_INT 9
11417: PPUSH
11418: LD_INT 22
11420: PUSH
11421: LD_INT 1
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 70
11432: PUSH
11433: LD_EXP 32
11437: OR
11438: IFFALSE 11635
11440: GO 11442
11442: DISABLE
11443: LD_INT 0
11445: PPUSH
11446: PPUSH
// begin enable ;
11447: ENABLE
// if not jmm_on_west then
11448: LD_EXP 5
11452: NOT
11453: IFFALSE 11464
// begin YouLost ( 4 ) ;
11455: LD_STRING 4
11457: PPUSH
11458: CALL_OW 104
// exit ;
11462: GO 11635
// end ; if not game_end then
11464: LD_EXP 32
11468: NOT
11469: IFFALSE 11479
// game_end := true ;
11471: LD_ADDR_EXP 32
11475: PUSH
11476: LD_INT 1
11478: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11479: LD_ADDR_VAR 0 2
11483: PUSH
11484: LD_INT 9
11486: PPUSH
11487: LD_INT 22
11489: PUSH
11490: LD_INT 1
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: PPUSH
11497: CALL_OW 70
11501: ST_TO_ADDR
// if not filter then
11502: LD_VAR 0 2
11506: NOT
11507: IFFALSE 11511
// exit ;
11509: GO 11635
// for i in filter do
11511: LD_ADDR_VAR 0 1
11515: PUSH
11516: LD_VAR 0 2
11520: PUSH
11521: FOR_IN
11522: IFFALSE 11633
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11524: LD_VAR 0 1
11528: PPUSH
11529: CALL_OW 302
11533: PUSH
11534: LD_VAR 0 1
11538: PPUSH
11539: CALL_OW 247
11543: PUSH
11544: LD_INT 2
11546: EQUAL
11547: AND
11548: PUSH
11549: LD_VAR 0 1
11553: PPUSH
11554: CALL_OW 248
11558: PUSH
11559: LD_INT 1
11561: EQUAL
11562: AND
11563: IFFALSE 11596
// begin veh_on_meta := true ;
11565: LD_ADDR_EXP 27
11569: PUSH
11570: LD_INT 1
11572: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11573: LD_VAR 0 1
11577: PPUSH
11578: CALL_OW 311
11582: PPUSH
11583: CALL 11638 0 1
// RemoveUnit ( i ) ;
11587: LD_VAR 0 1
11591: PPUSH
11592: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11596: LD_VAR 0 1
11600: PPUSH
11601: CALL_OW 302
11605: PUSH
11606: LD_VAR 0 1
11610: PPUSH
11611: CALL_OW 247
11615: PUSH
11616: LD_INT 1
11618: EQUAL
11619: AND
11620: IFFALSE 11631
// Save ( i ) ;
11622: LD_VAR 0 1
11626: PPUSH
11627: CALL 11638 0 1
// end ;
11631: GO 11521
11633: POP
11634: POP
// end ;
11635: PPOPN 2
11637: END
// export function Save ( i ) ; begin
11638: LD_INT 0
11640: PPUSH
// save_counter := save_counter + 1 ;
11641: LD_ADDR_EXP 35
11645: PUSH
11646: LD_EXP 35
11650: PUSH
11651: LD_INT 1
11653: PLUS
11654: ST_TO_ADDR
// if i = JMM then
11655: LD_VAR 0 1
11659: PUSH
11660: LD_EXP 36
11664: EQUAL
11665: IFFALSE 11787
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11667: LD_EXP 23
11671: PUSH
11672: LD_INT 22
11674: PUSH
11675: LD_INT 1
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: PUSH
11682: LD_INT 21
11684: PUSH
11685: LD_INT 1
11687: PUSH
11688: EMPTY
11689: LIST
11690: LIST
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: PUSH
11701: LD_INT 1
11703: GREATER
11704: AND
11705: IFFALSE 11762
// begin show_query := false ;
11707: LD_ADDR_EXP 23
11711: PUSH
11712: LD_INT 0
11714: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11715: LD_STRING Q2
11717: PPUSH
11718: CALL_OW 97
11722: PUSH
11723: LD_INT 1
11725: DOUBLE
11726: EQUAL
11727: IFTRUE 11731
11729: GO 11742
11731: POP
// wait_for_them := true ; 2 :
11732: LD_ADDR_EXP 24
11736: PUSH
11737: LD_INT 1
11739: ST_TO_ADDR
11740: GO 11762
11742: LD_INT 2
11744: DOUBLE
11745: EQUAL
11746: IFTRUE 11750
11748: GO 11761
11750: POP
// wait_for_them := false ; end ;
11751: LD_ADDR_EXP 24
11755: PUSH
11756: LD_INT 0
11758: ST_TO_ADDR
11759: GO 11762
11761: POP
// end ; save_group := save_group ^ JMM ;
11762: LD_ADDR_EXP 22
11766: PUSH
11767: LD_EXP 22
11771: PUSH
11772: LD_EXP 36
11776: ADD
11777: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11778: LD_EXP 36
11782: PPUSH
11783: CALL_OW 64
// end ; if i = Lisa then
11787: LD_VAR 0 1
11791: PUSH
11792: LD_EXP 39
11796: EQUAL
11797: IFFALSE 11824
// begin save_group := save_group ^ Lisa ;
11799: LD_ADDR_EXP 22
11803: PUSH
11804: LD_EXP 22
11808: PUSH
11809: LD_EXP 39
11813: ADD
11814: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11815: LD_EXP 39
11819: PPUSH
11820: CALL_OW 64
// end ; if i = Bobby then
11824: LD_VAR 0 1
11828: PUSH
11829: LD_EXP 37
11833: EQUAL
11834: IFFALSE 11861
// begin save_group := save_group ^ Bobby ;
11836: LD_ADDR_EXP 22
11840: PUSH
11841: LD_EXP 22
11845: PUSH
11846: LD_EXP 37
11850: ADD
11851: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11852: LD_EXP 37
11856: PPUSH
11857: CALL_OW 64
// end ; if i = Cyrus then
11861: LD_VAR 0 1
11865: PUSH
11866: LD_EXP 38
11870: EQUAL
11871: IFFALSE 11898
// begin save_group := save_group ^ Cyrus ;
11873: LD_ADDR_EXP 22
11877: PUSH
11878: LD_EXP 22
11882: PUSH
11883: LD_EXP 38
11887: ADD
11888: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11889: LD_EXP 38
11893: PPUSH
11894: CALL_OW 64
// end ; if i = Khatam then
11898: LD_VAR 0 1
11902: PUSH
11903: LD_EXP 40
11907: EQUAL
11908: IFFALSE 11935
// begin save_group := save_group ^ Khatam ;
11910: LD_ADDR_EXP 22
11914: PUSH
11915: LD_EXP 22
11919: PUSH
11920: LD_EXP 40
11924: ADD
11925: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11926: LD_EXP 40
11930: PPUSH
11931: CALL_OW 64
// end ; if i = Frank then
11935: LD_VAR 0 1
11939: PUSH
11940: LD_EXP 50
11944: EQUAL
11945: IFFALSE 11972
// begin save_group := save_group ^ Frank ;
11947: LD_ADDR_EXP 22
11951: PUSH
11952: LD_EXP 22
11956: PUSH
11957: LD_EXP 50
11961: ADD
11962: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11963: LD_EXP 50
11967: PPUSH
11968: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 302
11981: PUSH
11982: LD_VAR 0 1
11986: PPUSH
11987: CALL_OW 247
11991: PUSH
11992: LD_INT 1
11994: EQUAL
11995: AND
11996: PUSH
11997: LD_VAR 0 1
12001: PUSH
12002: LD_EXP 22
12006: IN
12007: NOT
12008: AND
12009: IFFALSE 12036
// begin save_others := save_others ^ i ;
12011: LD_ADDR_EXP 21
12015: PUSH
12016: LD_EXP 21
12020: PUSH
12021: LD_VAR 0 1
12025: ADD
12026: ST_TO_ADDR
// RemoveUnit ( i ) ;
12027: LD_VAR 0 1
12031: PPUSH
12032: CALL_OW 64
// end ; end ;
12036: LD_VAR 0 2
12040: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12041: LD_EXP 23
12045: NOT
12046: PUSH
12047: LD_EXP 24
12051: NOT
12052: AND
12053: PUSH
12054: LD_INT 22
12056: PUSH
12057: LD_INT 1
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 21
12066: PUSH
12067: LD_INT 1
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: EMPTY
12075: LIST
12076: LIST
12077: PPUSH
12078: CALL_OW 69
12082: PUSH
12083: LD_INT 0
12085: EQUAL
12086: OR
12087: IFFALSE 12096
12089: GO 12091
12091: DISABLE
// EndMission ;
12092: CALL 12097 0 0
12096: END
// export function EndMission ; var i ; begin
12097: LD_INT 0
12099: PPUSH
12100: PPUSH
// Wait ( 0 0$02 ) ;
12101: LD_INT 70
12103: PPUSH
12104: CALL_OW 67
// if solar_builded then
12108: LD_EXP 13
12112: IFFALSE 12126
// AddMedal ( Solar1 , 1 ) else
12114: LD_STRING Solar1
12116: PPUSH
12117: LD_INT 1
12119: PPUSH
12120: CALL_OW 101
12124: GO 12137
// AddMedal ( Solar1 , - 1 ) ;
12126: LD_STRING Solar1
12128: PPUSH
12129: LD_INT 1
12131: NEG
12132: PPUSH
12133: CALL_OW 101
// if veh_on_meta then
12137: LD_EXP 27
12141: IFFALSE 12155
// AddMedal ( Solar2 , 1 ) else
12143: LD_STRING Solar2
12145: PPUSH
12146: LD_INT 1
12148: PPUSH
12149: CALL_OW 101
12153: GO 12185
// if solar_builded then
12155: LD_EXP 13
12159: IFFALSE 12174
// AddMedal ( Solar2 , - 1 ) else
12161: LD_STRING Solar2
12163: PPUSH
12164: LD_INT 1
12166: NEG
12167: PPUSH
12168: CALL_OW 101
12172: GO 12185
// AddMedal ( Solar2 , - 2 ) ;
12174: LD_STRING Solar2
12176: PPUSH
12177: LD_INT 2
12179: NEG
12180: PPUSH
12181: CALL_OW 101
// if lose_counter = 0 then
12185: LD_EXP 33
12189: PUSH
12190: LD_INT 0
12192: EQUAL
12193: IFFALSE 12207
// AddMedal ( No , 1 ) else
12195: LD_STRING No
12197: PPUSH
12198: LD_INT 1
12200: PPUSH
12201: CALL_OW 101
12205: GO 12251
// if lose_counter > 0 and lose_counter < 4 then
12207: LD_EXP 33
12211: PUSH
12212: LD_INT 0
12214: GREATER
12215: PUSH
12216: LD_EXP 33
12220: PUSH
12221: LD_INT 4
12223: LESS
12224: AND
12225: IFFALSE 12240
// AddMedal ( No , - 1 ) else
12227: LD_STRING No
12229: PPUSH
12230: LD_INT 1
12232: NEG
12233: PPUSH
12234: CALL_OW 101
12238: GO 12251
// AddMedal ( UpTo4 , - 1 ) ;
12240: LD_STRING UpTo4
12242: PPUSH
12243: LD_INT 1
12245: NEG
12246: PPUSH
12247: CALL_OW 101
// GiveMedals ( MAIN ) ;
12251: LD_STRING MAIN
12253: PPUSH
12254: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12258: LD_EXP 51
12262: PPUSH
12263: CALL_OW 301
12267: IFFALSE 12323
// begin stop_talking := true ;
12269: LD_ADDR_OWVAR 56
12273: PUSH
12274: LD_INT 1
12276: ST_TO_ADDR
// for i in save_group ^ save_others do
12277: LD_ADDR_VAR 0 2
12281: PUSH
12282: LD_EXP 22
12286: PUSH
12287: LD_EXP 21
12291: ADD
12292: PUSH
12293: FOR_IN
12294: IFFALSE 12313
// AddExperience ( i , skill_combat , 1500 ) ;
12296: LD_VAR 0 2
12300: PPUSH
12301: LD_INT 1
12303: PPUSH
12304: LD_INT 1500
12306: PPUSH
12307: CALL_OW 492
12311: GO 12293
12313: POP
12314: POP
// stop_talking := false ;
12315: LD_ADDR_OWVAR 56
12319: PUSH
12320: LD_INT 0
12322: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12323: LD_EXP 22
12327: PUSH
12328: LD_EXP 21
12332: ADD
12333: PPUSH
12334: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12338: LD_EXP 36
12342: PPUSH
12343: LD_EXP 2
12347: PUSH
12348: LD_STRING JMM
12350: STR
12351: PPUSH
12352: CALL_OW 38
// if Bobby in save_group then
12356: LD_EXP 37
12360: PUSH
12361: LD_EXP 22
12365: IN
12366: IFFALSE 12386
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12368: LD_EXP 37
12372: PPUSH
12373: LD_EXP 2
12377: PUSH
12378: LD_STRING Bobby
12380: STR
12381: PPUSH
12382: CALL_OW 38
// if Cyrus in save_group then
12386: LD_EXP 38
12390: PUSH
12391: LD_EXP 22
12395: IN
12396: IFFALSE 12416
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12398: LD_EXP 38
12402: PPUSH
12403: LD_EXP 2
12407: PUSH
12408: LD_STRING Cyrus
12410: STR
12411: PPUSH
12412: CALL_OW 38
// if Lisa in save_group then
12416: LD_EXP 39
12420: PUSH
12421: LD_EXP 22
12425: IN
12426: IFFALSE 12446
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12428: LD_EXP 39
12432: PPUSH
12433: LD_EXP 2
12437: PUSH
12438: LD_STRING Lisa
12440: STR
12441: PPUSH
12442: CALL_OW 38
// if Frank in save_group then
12446: LD_EXP 50
12450: PUSH
12451: LD_EXP 22
12455: IN
12456: IFFALSE 12476
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12458: LD_EXP 50
12462: PPUSH
12463: LD_EXP 2
12467: PUSH
12468: LD_STRING Frank
12470: STR
12471: PPUSH
12472: CALL_OW 38
// if Khatam in save_group then
12476: LD_EXP 40
12480: PUSH
12481: LD_EXP 22
12485: IN
12486: IFFALSE 12506
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12488: LD_EXP 40
12492: PPUSH
12493: LD_EXP 2
12497: PUSH
12498: LD_STRING Khatam
12500: STR
12501: PPUSH
12502: CALL_OW 38
// if save_others then
12506: LD_EXP 21
12510: IFFALSE 12524
// SaveCharacters ( save_others , 03_others ) ;
12512: LD_EXP 21
12516: PPUSH
12517: LD_STRING 03_others
12519: PPUSH
12520: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12524: LD_EXP 44
12528: PUSH
12529: LD_EXP 44
12533: PPUSH
12534: CALL_OW 302
12538: AND
12539: PUSH
12540: LD_EXP 26
12544: AND
12545: IFFALSE 12557
// begin ResetFog ;
12547: CALL_OW 335
// DisplayEndingScene ;
12551: CALL 12579 0 0
// end else
12555: GO 12570
// DeleteCharacters ( mission_prefix & Cornel ) ;
12557: LD_EXP 2
12561: PUSH
12562: LD_STRING Cornel
12564: STR
12565: PPUSH
12566: CALL_OW 40
// YouWin ;
12570: CALL_OW 103
// end ;
12574: LD_VAR 0 1
12578: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12579: LD_INT 0
12581: PPUSH
12582: PPUSH
12583: PPUSH
12584: PPUSH
12585: PPUSH
12586: PPUSH
// InGameOn ;
12587: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12591: LD_INT 208
12593: PPUSH
12594: LD_INT 62
12596: PPUSH
12597: LD_INT 1
12599: PPUSH
12600: LD_INT 10
12602: NEG
12603: PPUSH
12604: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12608: LD_INT 208
12610: PPUSH
12611: LD_INT 62
12613: PPUSH
12614: LD_INT 1
12616: PPUSH
12617: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12621: LD_ADDR_VAR 0 3
12625: PUSH
12626: LD_INT 22
12628: PUSH
12629: LD_INT 3
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: LD_INT 2
12638: PUSH
12639: LD_INT 21
12641: PUSH
12642: LD_INT 2
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: LD_INT 21
12651: PUSH
12652: LD_INT 1
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: PUSH
12659: EMPTY
12660: LIST
12661: LIST
12662: LIST
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PPUSH
12668: CALL_OW 69
12672: ST_TO_ADDR
// if filter then
12673: LD_VAR 0 3
12677: IFFALSE 12705
// for i in filter do
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_VAR 0 3
12688: PUSH
12689: FOR_IN
12690: IFFALSE 12703
// RemoveUnit ( i ) ;
12692: LD_VAR 0 2
12696: PPUSH
12697: CALL_OW 64
12701: GO 12689
12703: POP
12704: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: LD_INT 22
12712: PUSH
12713: LD_INT 4
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PUSH
12720: LD_INT 21
12722: PUSH
12723: LD_INT 1
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: ST_TO_ADDR
// if filter then
12739: LD_VAR 0 3
12743: IFFALSE 12774
// for i in filter do
12745: LD_ADDR_VAR 0 2
12749: PUSH
12750: LD_VAR 0 3
12754: PUSH
12755: FOR_IN
12756: IFFALSE 12772
// SetLives ( i , 0 ) ;
12758: LD_VAR 0 2
12762: PPUSH
12763: LD_INT 0
12765: PPUSH
12766: CALL_OW 234
12770: GO 12755
12772: POP
12773: POP
// uc_side := 4 ;
12774: LD_ADDR_OWVAR 20
12778: PUSH
12779: LD_INT 4
12781: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12782: LD_ADDR_VAR 0 4
12786: PUSH
12787: LD_STRING Cornell
12789: PPUSH
12790: LD_INT 0
12792: PPUSH
12793: CALL 481 0 2
12797: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12798: LD_VAR 0 4
12802: PPUSH
12803: LD_INT 208
12805: PPUSH
12806: LD_INT 62
12808: PPUSH
12809: LD_INT 0
12811: PPUSH
12812: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12816: LD_VAR 0 4
12820: PPUSH
12821: LD_INT 100
12823: PPUSH
12824: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12828: LD_INT 3
12830: PPUSH
12831: LD_VAR 0 4
12835: PPUSH
12836: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12840: LD_INT 4
12842: PPUSH
12843: LD_INT 3
12845: PPUSH
12846: LD_INT 1
12848: PPUSH
12849: LD_INT 1
12851: PPUSH
12852: CALL_OW 80
// uc_side := 3 ;
12856: LD_ADDR_OWVAR 20
12860: PUSH
12861: LD_INT 3
12863: ST_TO_ADDR
// uc_nation := 3 ;
12864: LD_ADDR_OWVAR 21
12868: PUSH
12869: LD_INT 3
12871: ST_TO_ADDR
// InitHc ;
12872: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12876: LD_ADDR_VAR 0 5
12880: PUSH
12881: LD_STRING Mikhail
12883: PPUSH
12884: LD_INT 0
12886: PPUSH
12887: CALL 481 0 2
12891: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12892: LD_INT 1
12894: PPUSH
12895: LD_INT 1
12897: PPUSH
12898: LD_INT 0
12900: PPUSH
12901: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12905: LD_ADDR_VAR 0 6
12909: PUSH
12910: LD_VAR 0 6
12914: PUSH
12915: CALL_OW 44
12919: ADD
12920: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12921: LD_ADDR_VAR 0 6
12925: PUSH
12926: LD_VAR 0 6
12930: PUSH
12931: CALL_OW 44
12935: ADD
12936: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12937: LD_INT 2
12939: PPUSH
12940: LD_INT 4
12942: PPUSH
12943: LD_INT 0
12945: PPUSH
12946: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12950: LD_ADDR_VAR 0 6
12954: PUSH
12955: LD_VAR 0 6
12959: PUSH
12960: CALL_OW 44
12964: ADD
12965: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12966: LD_VAR 0 5
12970: PPUSH
12971: LD_INT 17
12973: PPUSH
12974: LD_INT 0
12976: PPUSH
12977: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12981: LD_VAR 0 5
12985: PPUSH
12986: LD_INT 210
12988: PPUSH
12989: LD_INT 63
12991: PPUSH
12992: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12996: LD_VAR 0 5
13000: PPUSH
13001: LD_INT 208
13003: PPUSH
13004: LD_INT 62
13006: PPUSH
13007: CALL_OW 178
// for i in fake_russians do
13011: LD_ADDR_VAR 0 2
13015: PUSH
13016: LD_VAR 0 6
13020: PUSH
13021: FOR_IN
13022: IFFALSE 13100
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13024: LD_VAR 0 2
13028: PPUSH
13029: LD_INT 17
13031: PPUSH
13032: LD_INT 0
13034: PPUSH
13035: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13039: LD_VAR 0 2
13043: PPUSH
13044: LD_INT 215
13046: PPUSH
13047: LD_INT 67
13049: PPUSH
13050: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13054: LD_VAR 0 2
13058: PPUSH
13059: LD_INT 208
13061: PPUSH
13062: LD_INT 62
13064: PPUSH
13065: CALL_OW 178
// if GetClass ( i ) = 4 then
13069: LD_VAR 0 2
13073: PPUSH
13074: CALL_OW 257
13078: PUSH
13079: LD_INT 4
13081: EQUAL
13082: IFFALSE 13098
// ComHeal ( i , fake_cornel ) ;
13084: LD_VAR 0 2
13088: PPUSH
13089: LD_VAR 0 4
13093: PPUSH
13094: CALL_OW 128
// end ;
13098: GO 13021
13100: POP
13101: POP
// Wait ( 0 0$01 ) ;
13102: LD_INT 35
13104: PPUSH
13105: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13109: LD_INT 208
13111: PPUSH
13112: LD_INT 62
13114: PPUSH
13115: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13119: LD_INT 208
13121: PPUSH
13122: LD_INT 62
13124: PPUSH
13125: LD_INT 1
13127: PPUSH
13128: LD_INT 10
13130: NEG
13131: PPUSH
13132: CALL_OW 330
// Wait ( 0 0$15 ) ;
13136: LD_INT 525
13138: PPUSH
13139: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13143: LD_INT 208
13145: PPUSH
13146: LD_INT 62
13148: PPUSH
13149: LD_INT 1
13151: PPUSH
13152: CALL_OW 331
// ResetFog ;
13156: CALL_OW 335
// InGameOff ;
13160: CALL_OW 9
// end ;
13164: LD_VAR 0 1
13168: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13169: LD_INT 10
13171: PPUSH
13172: LD_INT 22
13174: PUSH
13175: LD_INT 1
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: PPUSH
13182: CALL_OW 70
13186: PUSH
13187: LD_EXP 43
13191: PPUSH
13192: CALL_OW 302
13196: AND
13197: PUSH
13198: LD_INT 22
13200: PUSH
13201: LD_INT 1
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: PPUSH
13208: CALL_OW 69
13212: PPUSH
13213: LD_EXP 43
13217: PPUSH
13218: CALL_OW 74
13222: PPUSH
13223: LD_EXP 43
13227: PPUSH
13228: CALL_OW 296
13232: PUSH
13233: LD_INT 30
13235: LESS
13236: OR
13237: IFFALSE 13288
13239: GO 13241
13241: DISABLE
// begin enable ;
13242: ENABLE
// powell_warn := powell_warn + 1 ;
13243: LD_ADDR_EXP 34
13247: PUSH
13248: LD_EXP 34
13252: PUSH
13253: LD_INT 1
13255: PLUS
13256: ST_TO_ADDR
// if powell_warn = 3 then
13257: LD_EXP 34
13261: PUSH
13262: LD_INT 3
13264: EQUAL
13265: IFFALSE 13276
// begin YouLost ( 5 ) ;
13267: LD_STRING 5
13269: PPUSH
13270: CALL_OW 104
// exit ;
13274: GO 13288
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13276: LD_EXP 45
13280: PPUSH
13281: LD_STRING DWarn-Pow-1
13283: PPUSH
13284: CALL_OW 94
// end ; end_of_file
13288: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13289: LD_EXP 8
13293: IFFALSE 15130
13295: GO 13297
13297: DISABLE
13298: LD_INT 0
13300: PPUSH
13301: PPUSH
13302: PPUSH
13303: PPUSH
13304: PPUSH
13305: PPUSH
13306: PPUSH
13307: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13308: LD_EXP 43
13312: PUSH
13313: LD_EXP 44
13317: ADD
13318: PUSH
13319: LD_EXP 6
13323: ADD
13324: PPUSH
13325: LD_INT 250
13327: PPUSH
13328: LD_INT 120
13330: PPUSH
13331: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13335: LD_ADDR_VAR 0 2
13339: PUSH
13340: LD_EXP 6
13344: PPUSH
13345: LD_INT 25
13347: PUSH
13348: LD_INT 2
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PPUSH
13355: CALL_OW 72
13359: PUSH
13360: LD_EXP 44
13364: DIFF
13365: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13366: LD_ADDR_VAR 0 3
13370: PUSH
13371: LD_EXP 6
13375: PPUSH
13376: LD_INT 21
13378: PUSH
13379: LD_INT 1
13381: PUSH
13382: EMPTY
13383: LIST
13384: LIST
13385: PPUSH
13386: CALL_OW 72
13390: PUSH
13391: LD_VAR 0 2
13395: DIFF
13396: ST_TO_ADDR
// if not has_eng then
13397: LD_VAR 0 2
13401: NOT
13402: IFFALSE 13485
// begin uc_side := 4 ;
13404: LD_ADDR_OWVAR 20
13408: PUSH
13409: LD_INT 4
13411: ST_TO_ADDR
// uc_nation := 1 ;
13412: LD_ADDR_OWVAR 21
13416: PUSH
13417: LD_INT 1
13419: ST_TO_ADDR
// bc_type := b_depot ;
13420: LD_ADDR_OWVAR 42
13424: PUSH
13425: LD_INT 0
13427: ST_TO_ADDR
// bc_level := 2 ;
13428: LD_ADDR_OWVAR 43
13432: PUSH
13433: LD_INT 2
13435: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13436: LD_ADDR_VAR 0 4
13440: PUSH
13441: LD_INT 264
13443: PPUSH
13444: LD_INT 120
13446: PPUSH
13447: LD_INT 4
13449: PPUSH
13450: CALL_OW 47
13454: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13455: LD_INT 264
13457: PPUSH
13458: LD_INT 120
13460: PPUSH
13461: LD_INT 4
13463: PPUSH
13464: LD_INT 10
13466: NEG
13467: PPUSH
13468: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13472: LD_INT 264
13474: PPUSH
13475: LD_INT 120
13477: PPUSH
13478: LD_INT 4
13480: PPUSH
13481: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13485: LD_INT 35
13487: PPUSH
13488: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13492: LD_EXP 43
13496: PPUSH
13497: LD_INT 10
13499: PPUSH
13500: CALL_OW 308
13504: PUSH
13505: LD_EXP 43
13509: PPUSH
13510: CALL_OW 310
13514: PPUSH
13515: LD_INT 10
13517: PPUSH
13518: CALL_OW 308
13522: OR
13523: IFFALSE 13485
// if has_eng and not dep then
13525: LD_VAR 0 2
13529: PUSH
13530: LD_VAR 0 4
13534: NOT
13535: AND
13536: IFFALSE 13686
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13538: LD_VAR 0 2
13542: PPUSH
13543: LD_INT 0
13545: PPUSH
13546: LD_INT 264
13548: PPUSH
13549: LD_INT 120
13551: PPUSH
13552: LD_INT 4
13554: PPUSH
13555: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13559: LD_INT 35
13561: PPUSH
13562: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13566: LD_INT 22
13568: PUSH
13569: LD_INT 4
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 30
13578: PUSH
13579: LD_INT 0
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PPUSH
13590: CALL_OW 69
13594: IFFALSE 13559
// ComMoveXY ( filter , 264 , 120 ) ;
13596: LD_VAR 0 3
13600: PPUSH
13601: LD_INT 264
13603: PPUSH
13604: LD_INT 120
13606: PPUSH
13607: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13611: LD_INT 35
13613: PPUSH
13614: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13618: LD_INT 22
13620: PUSH
13621: LD_INT 4
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 30
13630: PUSH
13631: LD_INT 0
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: LD_INT 3
13640: PUSH
13641: LD_INT 57
13643: PUSH
13644: EMPTY
13645: LIST
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: LIST
13655: PPUSH
13656: CALL_OW 69
13660: IFFALSE 13611
// ComMoveXY ( filter , 247 , 113 ) ;
13662: LD_VAR 0 3
13666: PPUSH
13667: LD_INT 247
13669: PPUSH
13670: LD_INT 113
13672: PPUSH
13673: CALL_OW 111
// Wait ( 0 0$2 ) ;
13677: LD_INT 70
13679: PPUSH
13680: CALL_OW 67
// end else
13684: GO 13698
// begin SetSide ( dep , 4 ) ;
13686: LD_VAR 0 4
13690: PPUSH
13691: LD_INT 4
13693: PPUSH
13694: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13698: LD_ADDR_VAR 0 4
13702: PUSH
13703: LD_INT 22
13705: PUSH
13706: LD_INT 4
13708: PUSH
13709: EMPTY
13710: LIST
13711: LIST
13712: PUSH
13713: LD_INT 30
13715: PUSH
13716: LD_INT 0
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 69
13731: PUSH
13732: LD_INT 1
13734: ARRAY
13735: ST_TO_ADDR
// if not has_eng then
13736: LD_VAR 0 2
13740: NOT
13741: IFFALSE 13828
// for i = 1 to 2 do
13743: LD_ADDR_VAR 0 1
13747: PUSH
13748: DOUBLE
13749: LD_INT 1
13751: DEC
13752: ST_TO_ADDR
13753: LD_INT 2
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13826
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13759: LD_VAR 0 3
13763: PUSH
13764: LD_INT 1
13766: ARRAY
13767: PPUSH
13768: LD_VAR 0 4
13772: PPUSH
13773: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13777: LD_VAR 0 3
13781: PUSH
13782: LD_INT 1
13784: ARRAY
13785: PPUSH
13786: LD_INT 2
13788: PPUSH
13789: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13793: LD_VAR 0 3
13797: PUSH
13798: LD_INT 1
13800: ARRAY
13801: PPUSH
13802: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
13806: LD_ADDR_VAR 0 3
13810: PUSH
13811: LD_VAR 0 3
13815: PPUSH
13816: LD_INT 1
13818: PPUSH
13819: CALL_OW 3
13823: ST_TO_ADDR
// end ;
13824: GO 13756
13826: POP
13827: POP
// if IsInUnit ( Cornel ) then
13828: LD_EXP 43
13832: PPUSH
13833: CALL_OW 310
13837: IFFALSE 13915
// begin cargo := IsInUnit ( Cornel ) ;
13839: LD_ADDR_VAR 0 7
13843: PUSH
13844: LD_EXP 43
13848: PPUSH
13849: CALL_OW 310
13853: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13854: LD_VAR 0 7
13858: PPUSH
13859: LD_INT 1
13861: PPUSH
13862: CALL_OW 289
13866: IFFALSE 13877
// ComUnload ( cargo ) ;
13868: LD_VAR 0 7
13872: PPUSH
13873: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13877: LD_EXP 43
13881: PPUSH
13882: LD_INT 235
13884: PPUSH
13885: LD_INT 122
13887: PPUSH
13888: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13892: LD_EXP 43
13896: PPUSH
13897: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13901: LD_EXP 43
13905: PPUSH
13906: LD_VAR 0 4
13910: PPUSH
13911: CALL_OW 180
// end ; if Bierezov then
13915: LD_EXP 44
13919: IFFALSE 13967
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
13921: LD_EXP 44
13925: PPUSH
13926: LD_INT 260
13928: PPUSH
13929: LD_INT 120
13931: PPUSH
13932: CALL_OW 111
// if dep then
13936: LD_VAR 0 4
13940: IFFALSE 13958
// AddComEnterUnit ( Bierezov , dep ) else
13942: LD_EXP 44
13946: PPUSH
13947: LD_VAR 0 4
13951: PPUSH
13952: CALL_OW 180
13956: GO 13967
// AddComHold ( Bierezov ) ;
13958: LD_EXP 44
13962: PPUSH
13963: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
13967: LD_INT 525
13969: PPUSH
13970: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13974: LD_ADDR_VAR 0 2
13978: PUSH
13979: LD_INT 22
13981: PUSH
13982: LD_INT 4
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PUSH
13989: LD_INT 25
13991: PUSH
13992: LD_INT 2
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: EMPTY
14000: LIST
14001: LIST
14002: PPUSH
14003: CALL_OW 69
14007: PUSH
14008: LD_EXP 44
14012: DIFF
14013: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14014: LD_INT 35
14016: PPUSH
14017: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14021: LD_ADDR_VAR 0 6
14025: PUSH
14026: LD_INT 10
14028: PPUSH
14029: CALL_OW 435
14033: ST_TO_ADDR
// if crates then
14034: LD_VAR 0 6
14038: IFFALSE 14067
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14040: LD_VAR 0 2
14044: PPUSH
14045: LD_VAR 0 6
14049: PUSH
14050: LD_INT 1
14052: ARRAY
14053: PPUSH
14054: LD_VAR 0 6
14058: PUSH
14059: LD_INT 2
14061: ARRAY
14062: PPUSH
14063: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14067: LD_VAR 0 4
14071: PPUSH
14072: CALL_OW 274
14076: PPUSH
14077: LD_INT 1
14079: PPUSH
14080: CALL_OW 275
14084: PUSH
14085: LD_INT 40
14087: GREATEREQUAL
14088: IFFALSE 14014
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14090: LD_ADDR_VAR 0 5
14094: PUSH
14095: LD_INT 4
14097: PUSH
14098: LD_INT 256
14100: PUSH
14101: LD_INT 111
14103: PUSH
14104: LD_INT 2
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: PUSH
14113: LD_INT 31
14115: PUSH
14116: LD_INT 243
14118: PUSH
14119: LD_INT 112
14121: PUSH
14122: LD_INT 2
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: PUSH
14131: LD_INT 31
14133: PUSH
14134: LD_INT 254
14136: PUSH
14137: LD_INT 114
14139: PUSH
14140: LD_INT 2
14142: PUSH
14143: EMPTY
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: PUSH
14149: EMPTY
14150: LIST
14151: LIST
14152: LIST
14153: ST_TO_ADDR
// for i in blist do
14154: LD_ADDR_VAR 0 1
14158: PUSH
14159: LD_VAR 0 5
14163: PUSH
14164: FOR_IN
14165: IFFALSE 14214
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14167: LD_VAR 0 2
14171: PPUSH
14172: LD_VAR 0 1
14176: PUSH
14177: LD_INT 1
14179: ARRAY
14180: PPUSH
14181: LD_VAR 0 1
14185: PUSH
14186: LD_INT 2
14188: ARRAY
14189: PPUSH
14190: LD_VAR 0 1
14194: PUSH
14195: LD_INT 3
14197: ARRAY
14198: PPUSH
14199: LD_VAR 0 1
14203: PUSH
14204: LD_INT 4
14206: ARRAY
14207: PPUSH
14208: CALL_OW 205
14212: GO 14164
14214: POP
14215: POP
// repeat wait ( 0 0$01 ) ;
14216: LD_INT 35
14218: PPUSH
14219: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14223: LD_INT 22
14225: PUSH
14226: LD_INT 4
14228: PUSH
14229: EMPTY
14230: LIST
14231: LIST
14232: PUSH
14233: LD_INT 30
14235: PUSH
14236: LD_INT 4
14238: PUSH
14239: EMPTY
14240: LIST
14241: LIST
14242: PUSH
14243: LD_INT 3
14245: PUSH
14246: LD_INT 57
14248: PUSH
14249: EMPTY
14250: LIST
14251: PUSH
14252: EMPTY
14253: LIST
14254: LIST
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: LIST
14260: PPUSH
14261: CALL_OW 69
14265: IFFALSE 14216
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14267: LD_VAR 0 3
14271: PPUSH
14272: LD_INT 22
14274: PUSH
14275: LD_INT 4
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PUSH
14282: LD_INT 30
14284: PUSH
14285: LD_INT 4
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PUSH
14292: EMPTY
14293: LIST
14294: LIST
14295: PPUSH
14296: CALL_OW 69
14300: PUSH
14301: LD_INT 1
14303: ARRAY
14304: PPUSH
14305: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14309: LD_VAR 0 3
14313: PPUSH
14314: LD_INT 1
14316: PPUSH
14317: CALL_OW 183
// if has_eng > 1 then
14321: LD_VAR 0 2
14325: PUSH
14326: LD_INT 1
14328: GREATER
14329: IFFALSE 14471
// for i = has_eng downto 2 do
14331: LD_ADDR_VAR 0 1
14335: PUSH
14336: DOUBLE
14337: LD_VAR 0 2
14341: INC
14342: ST_TO_ADDR
14343: LD_INT 2
14345: PUSH
14346: FOR_DOWNTO
14347: IFFALSE 14469
// begin if IsInUnit ( has_eng [ i ] ) then
14349: LD_VAR 0 2
14353: PUSH
14354: LD_VAR 0 1
14358: ARRAY
14359: PPUSH
14360: CALL_OW 310
14364: IFFALSE 14381
// ComExitBuilding ( has_eng [ i ] ) ;
14366: LD_VAR 0 2
14370: PUSH
14371: LD_VAR 0 1
14375: ARRAY
14376: PPUSH
14377: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14381: LD_VAR 0 2
14385: PUSH
14386: LD_VAR 0 1
14390: ARRAY
14391: PPUSH
14392: LD_INT 22
14394: PUSH
14395: LD_INT 4
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: PUSH
14402: LD_INT 30
14404: PUSH
14405: LD_INT 4
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: PUSH
14412: EMPTY
14413: LIST
14414: LIST
14415: PPUSH
14416: CALL_OW 69
14420: PUSH
14421: LD_INT 1
14423: ARRAY
14424: PPUSH
14425: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14429: LD_VAR 0 2
14433: PUSH
14434: LD_VAR 0 1
14438: ARRAY
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14447: LD_ADDR_VAR 0 2
14451: PUSH
14452: LD_VAR 0 2
14456: PPUSH
14457: LD_VAR 0 1
14461: PPUSH
14462: CALL_OW 3
14466: ST_TO_ADDR
// end ;
14467: GO 14346
14469: POP
14470: POP
// repeat wait ( 0 0$01 ) ;
14471: LD_INT 35
14473: PPUSH
14474: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14478: LD_INT 22
14480: PUSH
14481: LD_INT 4
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: PUSH
14488: LD_INT 30
14490: PUSH
14491: LD_INT 31
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: LD_INT 3
14500: PUSH
14501: LD_INT 57
14503: PUSH
14504: EMPTY
14505: LIST
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: EMPTY
14512: LIST
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 69
14520: PUSH
14521: LD_INT 1
14523: GREATER
14524: IFFALSE 14471
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14526: LD_ADDR_VAR 0 8
14530: PUSH
14531: LD_EXP 6
14535: PPUSH
14536: LD_INT 25
14538: PUSH
14539: LD_INT 1
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: PPUSH
14546: CALL_OW 72
14550: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14551: LD_ADDR_VAR 0 1
14555: PUSH
14556: DOUBLE
14557: LD_INT 1
14559: DEC
14560: ST_TO_ADDR
14561: LD_INT 22
14563: PUSH
14564: LD_INT 4
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: LD_INT 30
14573: PUSH
14574: LD_INT 31
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PUSH
14581: LD_INT 3
14583: PUSH
14584: LD_INT 57
14586: PUSH
14587: EMPTY
14588: LIST
14589: PUSH
14590: EMPTY
14591: LIST
14592: LIST
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: LIST
14598: PPUSH
14599: CALL_OW 69
14603: PUSH
14604: FOR_TO
14605: IFFALSE 14689
// begin if not sol [ i ] then
14607: LD_VAR 0 8
14611: PUSH
14612: LD_VAR 0 1
14616: ARRAY
14617: NOT
14618: IFFALSE 14622
// break ;
14620: GO 14689
// ComExitBuilding ( sol [ i ] ) ;
14622: LD_VAR 0 8
14626: PUSH
14627: LD_VAR 0 1
14631: ARRAY
14632: PPUSH
14633: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14637: LD_VAR 0 8
14641: PUSH
14642: LD_VAR 0 1
14646: ARRAY
14647: PPUSH
14648: LD_INT 22
14650: PUSH
14651: LD_INT 4
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 30
14660: PUSH
14661: LD_INT 31
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: PPUSH
14672: CALL_OW 69
14676: PUSH
14677: LD_VAR 0 1
14681: ARRAY
14682: PPUSH
14683: CALL_OW 180
// end ;
14687: GO 14604
14689: POP
14690: POP
// if sol > 3 then
14691: LD_VAR 0 8
14695: PUSH
14696: LD_INT 3
14698: GREATER
14699: IFFALSE 14816
// begin ComExitBuilding ( sol [ 3 ] ) ;
14701: LD_VAR 0 8
14705: PUSH
14706: LD_INT 3
14708: ARRAY
14709: PPUSH
14710: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14714: LD_VAR 0 8
14718: PUSH
14719: LD_INT 3
14721: ARRAY
14722: PPUSH
14723: LD_INT 246
14725: PPUSH
14726: LD_INT 94
14728: PPUSH
14729: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14733: LD_VAR 0 8
14737: PUSH
14738: LD_INT 3
14740: ARRAY
14741: PPUSH
14742: LD_INT 175
14744: PPUSH
14745: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14749: LD_VAR 0 8
14753: PUSH
14754: LD_INT 3
14756: ARRAY
14757: PPUSH
14758: LD_INT 224
14760: PPUSH
14761: LD_INT 90
14763: PPUSH
14764: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14768: LD_VAR 0 8
14772: PUSH
14773: LD_INT 3
14775: ARRAY
14776: PPUSH
14777: LD_INT 245
14779: PPUSH
14780: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14784: LD_VAR 0 8
14788: PUSH
14789: LD_INT 3
14791: ARRAY
14792: PPUSH
14793: LD_INT 223
14795: PPUSH
14796: LD_INT 110
14798: PPUSH
14799: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14803: LD_VAR 0 8
14807: PUSH
14808: LD_INT 3
14810: ARRAY
14811: PPUSH
14812: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14816: LD_VAR 0 2
14820: PPUSH
14821: LD_VAR 0 4
14825: PPUSH
14826: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
14830: LD_INT 22
14832: PUSH
14833: LD_INT 4
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PUSH
14840: LD_INT 30
14842: PUSH
14843: LD_INT 4
14845: PUSH
14846: EMPTY
14847: LIST
14848: LIST
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: PPUSH
14854: CALL_OW 69
14858: PUSH
14859: LD_INT 1
14861: ARRAY
14862: PPUSH
14863: CALL_OW 313
14867: PUSH
14868: LD_INT 6
14870: LESS
14871: IFFALSE 14935
// begin if IsInUnit ( Cornel ) then
14873: LD_EXP 43
14877: PPUSH
14878: CALL_OW 310
14882: IFFALSE 14893
// ComExitBuilding ( Cornel ) ;
14884: LD_EXP 43
14888: PPUSH
14889: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14893: LD_EXP 43
14897: PPUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 4
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 30
14910: PUSH
14911: LD_INT 4
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: PPUSH
14922: CALL_OW 69
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: PPUSH
14931: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
14935: LD_INT 35
14937: PPUSH
14938: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14942: LD_ADDR_VAR 0 3
14946: PUSH
14947: LD_INT 22
14949: PUSH
14950: LD_INT 4
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 21
14959: PUSH
14960: LD_INT 3
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 3
14969: PUSH
14970: LD_INT 24
14972: PUSH
14973: LD_INT 1000
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PUSH
14980: EMPTY
14981: LIST
14982: LIST
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: LIST
14988: PPUSH
14989: CALL_OW 69
14993: ST_TO_ADDR
// if filter and has_eng then
14994: LD_VAR 0 3
14998: PUSH
14999: LD_VAR 0 2
15003: AND
15004: IFFALSE 15070
// begin for i in has_eng do
15006: LD_ADDR_VAR 0 1
15010: PUSH
15011: LD_VAR 0 2
15015: PUSH
15016: FOR_IN
15017: IFFALSE 15066
// begin if IsInUnit ( i ) then
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 310
15028: IFFALSE 15039
// ComExitBuilding ( i ) ;
15030: LD_VAR 0 1
15034: PPUSH
15035: CALL_OW 122
// Wait ( 3 ) ;
15039: LD_INT 3
15041: PPUSH
15042: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15046: LD_VAR 0 1
15050: PPUSH
15051: LD_VAR 0 3
15055: PUSH
15056: LD_INT 1
15058: ARRAY
15059: PPUSH
15060: CALL_OW 130
// end ;
15064: GO 15016
15066: POP
15067: POP
// end else
15068: GO 15124
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15070: LD_VAR 0 2
15074: PUSH
15075: LD_VAR 0 2
15079: PPUSH
15080: LD_INT 56
15082: PUSH
15083: EMPTY
15084: LIST
15085: PPUSH
15086: CALL_OW 72
15090: AND
15091: IFFALSE 15124
// for i in has_eng do
15093: LD_ADDR_VAR 0 1
15097: PUSH
15098: LD_VAR 0 2
15102: PUSH
15103: FOR_IN
15104: IFFALSE 15122
// ComEnterUnit ( i , dep ) ;
15106: LD_VAR 0 1
15110: PPUSH
15111: LD_VAR 0 4
15115: PPUSH
15116: CALL_OW 120
15120: GO 15103
15122: POP
15123: POP
// until cornel_prepared ;
15124: LD_EXP 11
15128: IFFALSE 14935
// end ;
15130: PPOPN 8
15132: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15133: LD_EXP 11
15137: IFFALSE 15536
15139: GO 15141
15141: DISABLE
15142: LD_INT 0
15144: PPUSH
15145: PPUSH
15146: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15147: LD_ADDR_VAR 0 2
15151: PUSH
15152: LD_INT 22
15154: PUSH
15155: LD_INT 4
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 30
15164: PUSH
15165: LD_INT 4
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PPUSH
15176: CALL_OW 69
15180: PUSH
15181: LD_INT 1
15183: ARRAY
15184: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15185: LD_EXP 6
15189: PPUSH
15190: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15194: LD_EXP 44
15198: PUSH
15199: LD_EXP 44
15203: PPUSH
15204: CALL_OW 310
15208: AND
15209: IFFALSE 15220
// ComExitBuilding ( Bierezov ) ;
15211: LD_EXP 44
15215: PPUSH
15216: CALL_OW 122
// Wait ( 0 0$03 ) ;
15220: LD_INT 105
15222: PPUSH
15223: CALL_OW 67
// for i in cornel_units do
15227: LD_ADDR_VAR 0 1
15231: PUSH
15232: LD_EXP 6
15236: PUSH
15237: FOR_IN
15238: IFFALSE 15314
// begin if GetClass ( i ) in [ 2 , 3 ] then
15240: LD_VAR 0 1
15244: PPUSH
15245: CALL_OW 257
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: LD_INT 3
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: IN
15260: IFFALSE 15297
// begin ComEnterUnit ( i , arm ) ;
15262: LD_VAR 0 1
15266: PPUSH
15267: LD_VAR 0 2
15271: PPUSH
15272: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15276: LD_VAR 0 1
15280: PPUSH
15281: LD_INT 1
15283: PPUSH
15284: CALL_OW 183
// AddComExitBuilding ( i ) ;
15288: LD_VAR 0 1
15292: PPUSH
15293: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15297: LD_VAR 0 1
15301: PPUSH
15302: LD_INT 257
15304: PPUSH
15305: LD_INT 121
15307: PPUSH
15308: CALL_OW 171
// end ;
15312: GO 15237
15314: POP
15315: POP
// Wait ( 1 1$00 ) ;
15316: LD_INT 2100
15318: PPUSH
15319: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15323: LD_ADDR_VAR 0 3
15327: PUSH
15328: LD_EXP 43
15332: PUSH
15333: LD_EXP 44
15337: ADD
15338: PUSH
15339: LD_EXP 6
15343: ADD
15344: PUSH
15345: LD_EXP 6
15349: PPUSH
15350: LD_INT 21
15352: PUSH
15353: LD_INT 2
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PPUSH
15360: CALL_OW 72
15364: DIFF
15365: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15366: LD_VAR 0 3
15370: PPUSH
15371: LD_INT 248
15373: PPUSH
15374: LD_INT 85
15376: PPUSH
15377: CALL_OW 111
// AddComHold ( filter ) ;
15381: LD_VAR 0 3
15385: PPUSH
15386: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15390: LD_INT 35
15392: PPUSH
15393: CALL_OW 67
// until cornel_attack ;
15397: LD_EXP 9
15401: IFFALSE 15390
// ComAgressiveMove ( filter , 209 , 63 ) ;
15403: LD_VAR 0 3
15407: PPUSH
15408: LD_INT 209
15410: PPUSH
15411: LD_INT 63
15413: PPUSH
15414: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15418: LD_EXP 43
15422: PPUSH
15423: LD_INT 208
15425: PPUSH
15426: LD_INT 62
15428: PPUSH
15429: CALL_OW 114
// AddComHold ( Cornel ) ;
15433: LD_EXP 43
15437: PPUSH
15438: CALL_OW 200
// if Bierezov then
15442: LD_EXP 44
15446: IFFALSE 15536
// begin filter := filter diff Bierezov ;
15448: LD_ADDR_VAR 0 3
15452: PUSH
15453: LD_VAR 0 3
15457: PUSH
15458: LD_EXP 44
15462: DIFF
15463: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15464: LD_EXP 44
15468: PPUSH
15469: LD_INT 6
15471: PPUSH
15472: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15476: LD_EXP 44
15480: PPUSH
15481: LD_INT 235
15483: PPUSH
15484: LD_INT 60
15486: PPUSH
15487: CALL_OW 111
// AddComHold ( Bierezov ) ;
15491: LD_EXP 44
15495: PPUSH
15496: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15500: LD_EXP 44
15504: PPUSH
15505: LD_INT 350
15507: PPUSH
15508: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15512: LD_EXP 44
15516: PPUSH
15517: LD_INT 198
15519: PPUSH
15520: LD_INT 28
15522: PPUSH
15523: CALL_OW 171
// AddComHold ( Bierezov ) ;
15527: LD_EXP 44
15531: PPUSH
15532: CALL_OW 200
// end ; end ; end_of_file
15536: PPOPN 3
15538: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15539: LD_EXP 52
15543: PUSH
15544: LD_EXP 30
15548: NOT
15549: AND
15550: PUSH
15551: LD_EXP 31
15555: NOT
15556: AND
15557: IFFALSE 16007
15559: GO 15561
15561: DISABLE
15562: LD_INT 0
15564: PPUSH
15565: PPUSH
15566: PPUSH
15567: PPUSH
// begin enable ;
15568: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15569: LD_ADDR_VAR 0 4
15573: PUSH
15574: LD_INT 81
15576: PUSH
15577: LD_INT 3
15579: PUSH
15580: EMPTY
15581: LIST
15582: LIST
15583: PPUSH
15584: CALL_OW 69
15588: ST_TO_ADDR
// for i = 1 to ru_patrol do
15589: LD_ADDR_VAR 0 2
15593: PUSH
15594: DOUBLE
15595: LD_INT 1
15597: DEC
15598: ST_TO_ADDR
15599: LD_EXP 52
15603: PUSH
15604: FOR_TO
15605: IFFALSE 16005
// begin un := ru_patrol [ i ] ;
15607: LD_ADDR_VAR 0 1
15611: PUSH
15612: LD_EXP 52
15616: PUSH
15617: LD_VAR 0 2
15621: ARRAY
15622: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15623: LD_VAR 0 1
15627: PPUSH
15628: LD_INT 13
15630: PPUSH
15631: CALL_OW 308
15635: IFFALSE 15740
// begin if not ru_alert then
15637: LD_EXP 59
15641: NOT
15642: IFFALSE 15652
// ru_alert := true ;
15644: LD_ADDR_EXP 59
15648: PUSH
15649: LD_INT 1
15651: ST_TO_ADDR
// if not See ( 1 , un ) then
15652: LD_INT 1
15654: PPUSH
15655: LD_VAR 0 1
15659: PPUSH
15660: CALL_OW 292
15664: NOT
15665: IFFALSE 15679
// SetLives ( un , 1000 ) ;
15667: LD_VAR 0 1
15671: PPUSH
15672: LD_INT 1000
15674: PPUSH
15675: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15679: LD_ADDR_EXP 52
15683: PUSH
15684: LD_EXP 52
15688: PUSH
15689: LD_VAR 0 1
15693: DIFF
15694: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15695: LD_VAR 0 1
15699: PPUSH
15700: LD_INT 22
15702: PUSH
15703: LD_INT 3
15705: PUSH
15706: EMPTY
15707: LIST
15708: LIST
15709: PUSH
15710: LD_INT 30
15712: PUSH
15713: LD_INT 4
15715: PUSH
15716: EMPTY
15717: LIST
15718: LIST
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PPUSH
15724: CALL_OW 69
15728: PPUSH
15729: CALL 1054 0 1
15733: PPUSH
15734: CALL_OW 120
// continue ;
15738: GO 15604
// end ; if IsOk ( un ) and not HasTask ( un ) then
15740: LD_VAR 0 1
15744: PPUSH
15745: CALL_OW 302
15749: PUSH
15750: LD_VAR 0 1
15754: PPUSH
15755: CALL_OW 314
15759: NOT
15760: AND
15761: IFFALSE 15854
// begin for j = 1 to ru_firepoints_south [ i ] do
15763: LD_ADDR_VAR 0 3
15767: PUSH
15768: DOUBLE
15769: LD_INT 1
15771: DEC
15772: ST_TO_ADDR
15773: LD_EXP 58
15777: PUSH
15778: LD_VAR 0 2
15782: ARRAY
15783: PUSH
15784: FOR_TO
15785: IFFALSE 15852
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15787: LD_VAR 0 1
15791: PPUSH
15792: LD_EXP 58
15796: PUSH
15797: LD_VAR 0 2
15801: ARRAY
15802: PUSH
15803: LD_VAR 0 3
15807: ARRAY
15808: PUSH
15809: LD_INT 1
15811: ARRAY
15812: PPUSH
15813: LD_EXP 58
15817: PUSH
15818: LD_VAR 0 2
15822: ARRAY
15823: PUSH
15824: LD_VAR 0 3
15828: ARRAY
15829: PUSH
15830: LD_INT 2
15832: ARRAY
15833: PPUSH
15834: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15838: LD_VAR 0 1
15842: PPUSH
15843: LD_INT 70
15845: PPUSH
15846: CALL_OW 202
// end ;
15850: GO 15784
15852: POP
15853: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15854: LD_VAR 0 1
15858: PPUSH
15859: CALL_OW 256
15863: PUSH
15864: LD_INT 700
15866: LESS
15867: PUSH
15868: LD_VAR 0 1
15872: PPUSH
15873: LD_INT 13
15875: PPUSH
15876: CALL_OW 308
15880: NOT
15881: AND
15882: IFFALSE 15934
// begin ComMoveToArea ( un , retreatArea ) ;
15884: LD_VAR 0 1
15888: PPUSH
15889: LD_INT 13
15891: PPUSH
15892: CALL_OW 113
// if not ru_alert_xy then
15896: LD_EXP 60
15900: NOT
15901: IFFALSE 15932
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15903: LD_ADDR_EXP 60
15907: PUSH
15908: LD_VAR 0 1
15912: PPUSH
15913: CALL_OW 250
15917: PUSH
15918: LD_VAR 0 1
15922: PPUSH
15923: CALL_OW 251
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: ST_TO_ADDR
// end else
15932: GO 16003
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15934: LD_VAR 0 1
15938: PPUSH
15939: LD_VAR 0 4
15943: PPUSH
15944: LD_VAR 0 1
15948: PPUSH
15949: CALL_OW 74
15953: PPUSH
15954: CALL_OW 296
15958: PUSH
15959: LD_INT 9
15961: LESS
15962: PUSH
15963: LD_VAR 0 1
15967: PPUSH
15968: CALL_OW 256
15972: PUSH
15973: LD_INT 500
15975: GREATER
15976: AND
15977: IFFALSE 16003
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15979: LD_VAR 0 1
15983: PPUSH
15984: LD_VAR 0 4
15988: PPUSH
15989: LD_VAR 0 1
15993: PPUSH
15994: CALL_OW 74
15998: PPUSH
15999: CALL_OW 115
// end ;
16003: GO 15604
16005: POP
16006: POP
// end ;
16007: PPOPN 4
16009: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16010: LD_EXP 59
16014: PUSH
16015: LD_EXP 60
16019: AND
16020: PUSH
16021: LD_EXP 30
16025: NOT
16026: AND
16027: PUSH
16028: LD_EXP 31
16032: NOT
16033: AND
16034: IFFALSE 16244
16036: GO 16038
16038: DISABLE
16039: LD_INT 0
16041: PPUSH
16042: PPUSH
// begin enable ;
16043: ENABLE
// if not ru_vehicles then
16044: LD_EXP 55
16048: NOT
16049: IFFALSE 16053
// exit ;
16051: GO 16244
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16053: LD_ADDR_VAR 0 2
16057: PUSH
16058: LD_INT 81
16060: PUSH
16061: LD_INT 3
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: PPUSH
16068: CALL_OW 69
16072: ST_TO_ADDR
// if ru_vehicles then
16073: LD_EXP 55
16077: IFFALSE 16244
// begin for i in ru_vehicles do
16079: LD_ADDR_VAR 0 1
16083: PUSH
16084: LD_EXP 55
16088: PUSH
16089: FOR_IN
16090: IFFALSE 16242
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16092: LD_VAR 0 1
16096: PPUSH
16097: CALL_OW 302
16101: PUSH
16102: LD_VAR 0 1
16106: PPUSH
16107: LD_VAR 0 2
16111: PPUSH
16112: LD_VAR 0 1
16116: PPUSH
16117: CALL_OW 74
16121: PPUSH
16122: CALL_OW 296
16126: PUSH
16127: LD_INT 9
16129: LESS
16130: AND
16131: IFFALSE 16157
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16133: LD_VAR 0 1
16137: PPUSH
16138: LD_VAR 0 2
16142: PPUSH
16143: LD_VAR 0 1
16147: PPUSH
16148: CALL_OW 74
16152: PPUSH
16153: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16157: LD_VAR 0 1
16161: PPUSH
16162: CALL_OW 314
16166: NOT
16167: PUSH
16168: LD_VAR 0 1
16172: PPUSH
16173: CALL_OW 302
16177: AND
16178: PUSH
16179: LD_VAR 0 1
16183: PPUSH
16184: LD_EXP 60
16188: PUSH
16189: LD_INT 1
16191: ARRAY
16192: PPUSH
16193: LD_EXP 60
16197: PUSH
16198: LD_INT 2
16200: ARRAY
16201: PPUSH
16202: CALL_OW 297
16206: PUSH
16207: LD_INT 10
16209: GREATER
16210: AND
16211: IFFALSE 16240
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16213: LD_VAR 0 1
16217: PPUSH
16218: LD_EXP 60
16222: PUSH
16223: LD_INT 1
16225: ARRAY
16226: PPUSH
16227: LD_EXP 60
16231: PUSH
16232: LD_INT 2
16234: ARRAY
16235: PPUSH
16236: CALL_OW 114
// end ;
16240: GO 16089
16242: POP
16243: POP
// end ; end ;
16244: PPOPN 2
16246: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16247: LD_EXP 60
16251: PUSH
16252: LD_EXP 59
16256: AND
16257: PUSH
16258: LD_INT 3
16260: PPUSH
16261: CALL_OW 463
16265: NOT
16266: AND
16267: PUSH
16268: LD_EXP 30
16272: NOT
16273: AND
16274: PUSH
16275: LD_EXP 31
16279: NOT
16280: AND
16281: IFFALSE 16376
16283: GO 16285
16285: DISABLE
16286: LD_INT 0
16288: PPUSH
// begin enable ;
16289: ENABLE
// ru_alert_xy := false ;
16290: LD_ADDR_EXP 60
16294: PUSH
16295: LD_INT 0
16297: ST_TO_ADDR
// ru_alert := false ;
16298: LD_ADDR_EXP 59
16302: PUSH
16303: LD_INT 0
16305: ST_TO_ADDR
// if ru_vehicles then
16306: LD_EXP 55
16310: IFFALSE 16376
// for i in ru_vehicles do
16312: LD_ADDR_VAR 0 1
16316: PUSH
16317: LD_EXP 55
16321: PUSH
16322: FOR_IN
16323: IFFALSE 16374
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16325: LD_VAR 0 1
16329: PPUSH
16330: CALL_OW 302
16334: PUSH
16335: LD_VAR 0 1
16339: PPUSH
16340: LD_INT 89
16342: PPUSH
16343: LD_INT 36
16345: PPUSH
16346: CALL_OW 297
16350: PUSH
16351: LD_INT 10
16353: GREATER
16354: AND
16355: IFFALSE 16372
// ComMoveXY ( i , 89 , 36 ) ;
16357: LD_VAR 0 1
16361: PPUSH
16362: LD_INT 89
16364: PPUSH
16365: LD_INT 36
16367: PPUSH
16368: CALL_OW 111
16372: GO 16322
16374: POP
16375: POP
// end ;
16376: PPOPN 1
16378: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16379: LD_EXP 54
16383: PUSH
16384: LD_EXP 30
16388: NOT
16389: AND
16390: PUSH
16391: LD_EXP 31
16395: NOT
16396: AND
16397: IFFALSE 16681
16399: GO 16401
16401: DISABLE
16402: LD_INT 0
16404: PPUSH
16405: PPUSH
16406: PPUSH
// begin enable ;
16407: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16408: LD_ADDR_VAR 0 3
16412: PUSH
16413: LD_INT 81
16415: PUSH
16416: LD_INT 3
16418: PUSH
16419: EMPTY
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL_OW 69
16427: ST_TO_ADDR
// for i = 1 to ru_forest do
16428: LD_ADDR_VAR 0 1
16432: PUSH
16433: DOUBLE
16434: LD_INT 1
16436: DEC
16437: ST_TO_ADDR
16438: LD_EXP 54
16442: PUSH
16443: FOR_TO
16444: IFFALSE 16679
// begin un := ru_forest [ i ] ;
16446: LD_ADDR_VAR 0 2
16450: PUSH
16451: LD_EXP 54
16455: PUSH
16456: LD_VAR 0 1
16460: ARRAY
16461: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16462: LD_VAR 0 2
16466: PPUSH
16467: LD_INT 13
16469: PPUSH
16470: CALL_OW 308
16474: IFFALSE 16564
// begin if not See ( 1 , un ) then
16476: LD_INT 1
16478: PPUSH
16479: LD_VAR 0 2
16483: PPUSH
16484: CALL_OW 292
16488: NOT
16489: IFFALSE 16503
// SetLives ( un , 1000 ) ;
16491: LD_VAR 0 2
16495: PPUSH
16496: LD_INT 1000
16498: PPUSH
16499: CALL_OW 234
// ru_forest := ru_forest diff un ;
16503: LD_ADDR_EXP 54
16507: PUSH
16508: LD_EXP 54
16512: PUSH
16513: LD_VAR 0 2
16517: DIFF
16518: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16519: LD_VAR 0 2
16523: PPUSH
16524: LD_INT 22
16526: PUSH
16527: LD_INT 3
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PUSH
16534: LD_INT 30
16536: PUSH
16537: LD_INT 4
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: PPUSH
16548: CALL_OW 69
16552: PPUSH
16553: CALL 1054 0 1
16557: PPUSH
16558: CALL_OW 120
// continue ;
16562: GO 16443
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16564: LD_VAR 0 2
16568: PPUSH
16569: CALL_OW 256
16573: PUSH
16574: LD_INT 700
16576: LESS
16577: PUSH
16578: LD_VAR 0 2
16582: PPUSH
16583: LD_INT 13
16585: PPUSH
16586: CALL_OW 308
16590: NOT
16591: AND
16592: IFFALSE 16608
// ComMoveToArea ( un , retreatArea ) else
16594: LD_VAR 0 2
16598: PPUSH
16599: LD_INT 13
16601: PPUSH
16602: CALL_OW 113
16606: GO 16677
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16608: LD_VAR 0 2
16612: PPUSH
16613: LD_VAR 0 3
16617: PPUSH
16618: LD_VAR 0 2
16622: PPUSH
16623: CALL_OW 74
16627: PPUSH
16628: CALL_OW 296
16632: PUSH
16633: LD_INT 9
16635: LESS
16636: PUSH
16637: LD_VAR 0 2
16641: PPUSH
16642: CALL_OW 256
16646: PUSH
16647: LD_INT 500
16649: GREATER
16650: AND
16651: IFFALSE 16677
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16653: LD_VAR 0 2
16657: PPUSH
16658: LD_VAR 0 3
16662: PPUSH
16663: LD_VAR 0 2
16667: PPUSH
16668: CALL_OW 74
16672: PPUSH
16673: CALL_OW 115
// end ;
16677: GO 16443
16679: POP
16680: POP
// end ;
16681: PPOPN 3
16683: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16684: LD_EXP 31
16688: NOT
16689: IFFALSE 16810
16691: GO 16693
16693: DISABLE
16694: LD_INT 0
16696: PPUSH
16697: PPUSH
// begin enable ;
16698: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16699: LD_ADDR_VAR 0 2
16703: PUSH
16704: LD_INT 22
16706: PUSH
16707: LD_INT 3
16709: PUSH
16710: EMPTY
16711: LIST
16712: LIST
16713: PUSH
16714: LD_INT 21
16716: PUSH
16717: LD_INT 3
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PUSH
16724: EMPTY
16725: LIST
16726: LIST
16727: PPUSH
16728: CALL_OW 69
16732: ST_TO_ADDR
// if filter then
16733: LD_VAR 0 2
16737: IFFALSE 16810
// for i in filter do
16739: LD_ADDR_VAR 0 1
16743: PUSH
16744: LD_VAR 0 2
16748: PUSH
16749: FOR_IN
16750: IFFALSE 16808
// if GetLives ( i ) < 990 then
16752: LD_VAR 0 1
16756: PPUSH
16757: CALL_OW 256
16761: PUSH
16762: LD_INT 990
16764: LESS
16765: IFFALSE 16806
// begin ru_alert := true ;
16767: LD_ADDR_EXP 59
16771: PUSH
16772: LD_INT 1
16774: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16775: LD_ADDR_EXP 60
16779: PUSH
16780: LD_VAR 0 1
16784: PPUSH
16785: CALL_OW 250
16789: PUSH
16790: LD_VAR 0 1
16794: PPUSH
16795: CALL_OW 251
16799: PUSH
16800: EMPTY
16801: LIST
16802: LIST
16803: ST_TO_ADDR
// break ;
16804: GO 16808
// end ;
16806: GO 16749
16808: POP
16809: POP
// end ;
16810: PPOPN 2
16812: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16813: LD_EXP 30
16817: IFFALSE 16966
16819: GO 16821
16821: DISABLE
16822: LD_INT 0
16824: PPUSH
16825: PPUSH
16826: PPUSH
16827: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16828: LD_ADDR_VAR 0 4
16832: PUSH
16833: LD_EXP 55
16837: PUSH
16838: LD_EXP 54
16842: ADD
16843: PUSH
16844: LD_EXP 52
16848: ADD
16849: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16850: LD_ADDR_VAR 0 3
16854: PUSH
16855: LD_INT 3
16857: PPUSH
16858: LD_INT 81
16860: PUSH
16861: LD_INT 3
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PPUSH
16868: CALL_OW 70
16872: ST_TO_ADDR
// if filter and enemy then
16873: LD_VAR 0 4
16877: PUSH
16878: LD_VAR 0 3
16882: AND
16883: IFFALSE 16966
// repeat wait ( 0 0$01 ) ;
16885: LD_INT 35
16887: PPUSH
16888: CALL_OW 67
// for i in filter do
16892: LD_ADDR_VAR 0 1
16896: PUSH
16897: LD_VAR 0 4
16901: PUSH
16902: FOR_IN
16903: IFFALSE 16931
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16905: LD_VAR 0 1
16909: PPUSH
16910: LD_VAR 0 3
16914: PPUSH
16915: LD_VAR 0 1
16919: PPUSH
16920: CALL_OW 74
16924: PPUSH
16925: CALL_OW 115
// end ;
16929: GO 16902
16931: POP
16932: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16933: LD_INT 3
16935: PPUSH
16936: LD_INT 81
16938: PUSH
16939: LD_INT 3
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PPUSH
16946: CALL_OW 70
16950: PUSH
16951: LD_INT 0
16953: EQUAL
16954: PUSH
16955: LD_VAR 0 4
16959: PUSH
16960: LD_INT 0
16962: EQUAL
16963: OR
16964: IFFALSE 16885
// end ;
16966: PPOPN 4
16968: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16969: LD_EXP 25
16973: PUSH
16974: LD_INT 22
16976: PUSH
16977: LD_INT 4
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PUSH
16984: LD_INT 30
16986: PUSH
16987: LD_INT 4
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PUSH
16994: LD_INT 3
16996: PUSH
16997: LD_INT 57
16999: PUSH
17000: EMPTY
17001: LIST
17002: PUSH
17003: EMPTY
17004: LIST
17005: LIST
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: PPUSH
17012: CALL_OW 69
17016: AND
17017: IFFALSE 17066
17019: GO 17021
17021: DISABLE
17022: LD_INT 0
17024: PPUSH
// begin if not ru_cornel_attack then
17025: LD_EXP 57
17029: NOT
17030: IFFALSE 17034
// exit ;
17032: GO 17066
// for i in ru_cornel_attack do
17034: LD_ADDR_VAR 0 1
17038: PUSH
17039: LD_EXP 57
17043: PUSH
17044: FOR_IN
17045: IFFALSE 17064
// ComAgressiveMove ( i , 258 , 119 ) ;
17047: LD_VAR 0 1
17051: PPUSH
17052: LD_INT 258
17054: PPUSH
17055: LD_INT 119
17057: PPUSH
17058: CALL_OW 114
17062: GO 17044
17064: POP
17065: POP
// end ; end_of_file
17066: PPOPN 1
17068: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17069: LD_EXP 5
17073: PUSH
17074: LD_EXP 9
17078: NOT
17079: AND
17080: PUSH
17081: LD_EXP 19
17085: AND
17086: IFFALSE 17198
17088: GO 17090
17090: DISABLE
17091: LD_INT 0
17093: PPUSH
// begin enable ;
17094: ENABLE
// crates_counter := crates_counter - 50 ;
17095: LD_ADDR_EXP 19
17099: PUSH
17100: LD_EXP 19
17104: PUSH
17105: LD_INT 50
17107: MINUS
17108: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17109: LD_INT 8
17111: PPUSH
17112: LD_INT 2
17114: PPUSH
17115: LD_INT 5
17117: PPUSH
17118: CALL_OW 12
17122: PPUSH
17123: LD_INT 1
17125: PPUSH
17126: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17130: LD_INT 1785
17132: PPUSH
17133: LD_INT 2345
17135: PPUSH
17136: CALL_OW 12
17140: PPUSH
17141: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17145: LD_ADDR_VAR 0 1
17149: PUSH
17150: LD_INT 1
17152: PPUSH
17153: LD_OWVAR 67
17157: PUSH
17158: LD_INT 2
17160: PLUS
17161: PPUSH
17162: CALL_OW 12
17166: ST_TO_ADDR
// if r < 3 then
17167: LD_VAR 0 1
17171: PUSH
17172: LD_INT 3
17174: LESS
17175: IFFALSE 17198
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17177: LD_INT 4
17179: PPUSH
17180: LD_INT 1
17182: PPUSH
17183: LD_INT 5
17185: PPUSH
17186: CALL_OW 12
17190: PPUSH
17191: LD_INT 1
17193: PPUSH
17194: CALL_OW 55
// end ;
17198: PPOPN 1
17200: END
// every 0 0$01 trigger cornel_active do
17201: LD_EXP 8
17205: IFFALSE 17294
17207: GO 17209
17209: DISABLE
// begin Wait ( 0 0$03 ) ;
17210: LD_INT 105
17212: PPUSH
17213: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17217: LD_INT 2
17219: PPUSH
17220: LD_INT 5
17222: PPUSH
17223: CALL_OW 12
17227: PPUSH
17228: LD_INT 10
17230: PPUSH
17231: LD_INT 1
17233: PPUSH
17234: CALL_OW 55
// Wait ( 0 0$13 ) ;
17238: LD_INT 455
17240: PPUSH
17241: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17245: LD_INT 2
17247: PPUSH
17248: LD_INT 5
17250: PPUSH
17251: CALL_OW 12
17255: PPUSH
17256: LD_INT 10
17258: PPUSH
17259: LD_INT 1
17261: PPUSH
17262: CALL_OW 55
// Wait ( 0 0$16 ) ;
17266: LD_INT 560
17268: PPUSH
17269: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17273: LD_INT 2
17275: PPUSH
17276: LD_INT 5
17278: PPUSH
17279: CALL_OW 12
17283: PPUSH
17284: LD_INT 10
17286: PPUSH
17287: LD_INT 1
17289: PPUSH
17290: CALL_OW 55
// end ; end_of_file
17294: END
// every 0 0$01 trigger cornel_prepared do
17295: LD_EXP 11
17299: IFFALSE 17358
17301: GO 17303
17303: DISABLE
// begin enable ;
17304: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17305: LD_ADDR_OWVAR 47
17309: PUSH
17310: LD_STRING #Am03-1
17312: PUSH
17313: LD_EXP 10
17317: PUSH
17318: EMPTY
17319: LIST
17320: LIST
17321: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17322: LD_ADDR_EXP 10
17326: PUSH
17327: LD_EXP 10
17331: PPUSH
17332: LD_STRING -
17334: PPUSH
17335: CALL 1124 0 2
17339: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17340: LD_EXP 10
17344: PUSH
17345: LD_INT 0
17347: EQUAL
17348: IFFALSE 17358
// begin Display_Strings := [ ] ;
17350: LD_ADDR_OWVAR 47
17354: PUSH
17355: EMPTY
17356: ST_TO_ADDR
// disable ;
17357: DISABLE
// end ; end ;
17358: END
// every 0 0$01 trigger debug and debug_strings do
17359: LD_EXP 1
17363: PUSH
17364: LD_OWVAR 48
17368: AND
17369: IFFALSE 17385
17371: GO 17373
17373: DISABLE
// begin enable ;
17374: ENABLE
// Display_Strings := debug_strings ;
17375: LD_ADDR_OWVAR 47
17379: PUSH
17380: LD_OWVAR 48
17384: ST_TO_ADDR
// end ; end_of_file
17385: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17386: LD_VAR 0 1
17390: PPUSH
17391: CALL_OW 255
17395: PUSH
17396: LD_INT 1
17398: EQUAL
17399: PUSH
17400: LD_EXP 13
17404: NOT
17405: AND
17406: IFFALSE 17416
// solar_builded := true ;
17408: LD_ADDR_EXP 13
17412: PUSH
17413: LD_INT 1
17415: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17416: LD_VAR 0 1
17420: PPUSH
17421: CALL_OW 255
17425: PUSH
17426: LD_INT 1
17428: EQUAL
17429: PUSH
17430: LD_EXP 28
17434: AND
17435: IFFALSE 17468
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17437: LD_ADDR_EXP 28
17441: PUSH
17442: LD_EXP 28
17446: PUSH
17447: LD_INT 1750
17449: PUSH
17450: LD_INT 1400
17452: PUSH
17453: LD_INT 1225
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: LIST
17460: PUSH
17461: LD_OWVAR 67
17465: ARRAY
17466: PLUS
17467: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17468: LD_VAR 0 1
17472: PPUSH
17473: CALL_OW 255
17477: PUSH
17478: LD_INT 3
17480: EQUAL
17481: IFFALSE 17499
// ru_vehicles := ru_vehicles ^ veh ;
17483: LD_ADDR_EXP 55
17487: PUSH
17488: LD_EXP 55
17492: PUSH
17493: LD_VAR 0 1
17497: ADD
17498: ST_TO_ADDR
// end ;
17499: PPOPN 2
17501: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17502: LD_VAR 0 1
17506: PUSH
17507: LD_EXP 52
17511: IN
17512: IFFALSE 17530
// ru_patrol := ru_patrol diff un ;
17514: LD_ADDR_EXP 52
17518: PUSH
17519: LD_EXP 52
17523: PUSH
17524: LD_VAR 0 1
17528: DIFF
17529: ST_TO_ADDR
// if un in ru_forest then
17530: LD_VAR 0 1
17534: PUSH
17535: LD_EXP 54
17539: IN
17540: IFFALSE 17558
// ru_forest := ru_forest diff un ;
17542: LD_ADDR_EXP 54
17546: PUSH
17547: LD_EXP 54
17551: PUSH
17552: LD_VAR 0 1
17556: DIFF
17557: ST_TO_ADDR
// if un in ru_vehicles then
17558: LD_VAR 0 1
17562: PUSH
17563: LD_EXP 55
17567: IN
17568: IFFALSE 17643
// begin ru_vehicles := ru_vehicles diff un ;
17570: LD_ADDR_EXP 55
17574: PUSH
17575: LD_EXP 55
17579: PUSH
17580: LD_VAR 0 1
17584: DIFF
17585: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17586: LD_ADDR_EXP 56
17590: PUSH
17591: LD_EXP 56
17595: PUSH
17596: LD_VAR 0 1
17600: PPUSH
17601: CALL_OW 265
17605: PUSH
17606: LD_VAR 0 1
17610: PPUSH
17611: CALL_OW 262
17615: PUSH
17616: LD_VAR 0 1
17620: PPUSH
17621: CALL_OW 263
17625: PUSH
17626: LD_VAR 0 1
17630: PPUSH
17631: CALL_OW 264
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: LIST
17640: LIST
17641: ADD
17642: ST_TO_ADDR
// end ; if un = JMM then
17643: LD_VAR 0 1
17647: PUSH
17648: LD_EXP 36
17652: EQUAL
17653: IFFALSE 17662
// YouLost ( 0 ) ;
17655: LD_STRING 0
17657: PPUSH
17658: CALL_OW 104
// if un = us_dep_west then
17662: LD_VAR 0 1
17666: PUSH
17667: LD_INT 1
17669: EQUAL
17670: IFFALSE 17679
// YouLost ( 2 ) ;
17672: LD_STRING 2
17674: PPUSH
17675: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17679: LD_VAR 0 1
17683: PPUSH
17684: CALL_OW 255
17688: PUSH
17689: LD_INT 8
17691: EQUAL
17692: PUSH
17693: LD_EXP 5
17697: NOT
17698: AND
17699: IFFALSE 17708
// YouLost ( 4 ) ;
17701: LD_STRING 4
17703: PPUSH
17704: CALL_OW 104
// if un in jmm_units then
17708: LD_VAR 0 1
17712: PUSH
17713: LD_EXP 4
17717: IN
17718: IFFALSE 17734
// lose_counter := lose_counter + 1 ;
17720: LD_ADDR_EXP 33
17724: PUSH
17725: LD_EXP 33
17729: PUSH
17730: LD_INT 1
17732: PLUS
17733: ST_TO_ADDR
// end ;
17734: PPOPN 1
17736: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17737: LD_INT 0
17739: PPUSH
17740: PPUSH
// begin if GetSide ( driver ) = 3 then
17741: LD_VAR 0 1
17745: PPUSH
17746: CALL_OW 255
17750: PUSH
17751: LD_INT 3
17753: EQUAL
17754: IFFALSE 17832
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17756: LD_ADDR_VAR 0 6
17760: PUSH
17761: LD_INT 22
17763: PUSH
17764: LD_INT 3
17766: PUSH
17767: EMPTY
17768: LIST
17769: LIST
17770: PUSH
17771: LD_INT 30
17773: PUSH
17774: LD_INT 3
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: PPUSH
17785: CALL_OW 69
17789: PPUSH
17790: CALL 1054 0 1
17794: ST_TO_ADDR
// if place then
17795: LD_VAR 0 6
17799: IFFALSE 17817
// ComEnterUnit ( driver , place ) else
17801: LD_VAR 0 1
17805: PPUSH
17806: LD_VAR 0 6
17810: PPUSH
17811: CALL_OW 120
17815: GO 17832
// ComMoveXY ( driver , 70 , 22 ) ;
17817: LD_VAR 0 1
17821: PPUSH
17822: LD_INT 70
17824: PPUSH
17825: LD_INT 22
17827: PPUSH
17828: CALL_OW 111
// end ; end ;
17832: PPOPN 6
17834: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 1
17842: EQUAL
17843: PUSH
17844: LD_VAR 0 2
17848: PUSH
17849: LD_INT 4
17851: EQUAL
17852: PUSH
17853: LD_VAR 0 2
17857: PUSH
17858: LD_INT 8
17860: EQUAL
17861: PUSH
17862: LD_EXP 5
17866: NOT
17867: AND
17868: OR
17869: AND
17870: IFFALSE 17879
// YouLost ( 5 ) ;
17872: LD_STRING 5
17874: PPUSH
17875: CALL_OW 104
// end ;
17879: PPOPN 2
17881: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17882: LD_EXP 35
17886: PUSH
17887: LD_INT 22
17889: PUSH
17890: LD_INT 1
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: PUSH
17897: LD_INT 21
17899: PUSH
17900: LD_INT 1
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: PPUSH
17911: CALL_OW 69
17915: PUSH
17916: LD_INT 22
17918: PUSH
17919: LD_INT 8
17921: PUSH
17922: EMPTY
17923: LIST
17924: LIST
17925: PUSH
17926: LD_INT 21
17928: PUSH
17929: LD_INT 1
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: PPUSH
17940: CALL_OW 69
17944: ADD
17945: PLUS
17946: PUSH
17947: LD_INT 5
17949: LESS
17950: IFFALSE 17962
17952: GO 17954
17954: DISABLE
// YouLost ( 1 ) ;
17955: LD_STRING 1
17957: PPUSH
17958: CALL_OW 104
17962: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17963: LD_INT 1
17965: PPUSH
17966: CALL_OW 255
17970: PUSH
17971: LD_INT 3
17973: EQUAL
17974: IFFALSE 17986
17976: GO 17978
17978: DISABLE
// YouLost ( 3 ) ;
17979: LD_STRING 3
17981: PPUSH
17982: CALL_OW 104
17986: END
