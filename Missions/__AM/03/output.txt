// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 3008 0 0
// PrepareAmerican ;
  26: CALL 1213 0 0
// PrepareCornell ;
  30: CALL 2237 0 0
// PrepareWesternBase ;
  34: CALL 2463 0 0
// Action ;
  38: CALL 5224 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ;
1180: LD_VAR 0 3
1184: RET
// export function Video ( mode ) ; begin
1185: LD_INT 0
1187: PPUSH
// ingame_video = mode ;
1188: LD_ADDR_OWVAR 52
1192: PUSH
1193: LD_VAR 0 1
1197: ST_TO_ADDR
// interface_hidden = mode ;
1198: LD_ADDR_OWVAR 54
1202: PUSH
1203: LD_VAR 0 1
1207: ST_TO_ADDR
// end ; end_of_file
1208: LD_VAR 0 2
1212: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1213: LD_INT 0
1215: PPUSH
1216: PPUSH
1217: PPUSH
1218: PPUSH
1219: PPUSH
1220: PPUSH
1221: PPUSH
1222: PPUSH
// uc_side := 4 ;
1223: LD_ADDR_OWVAR 20
1227: PUSH
1228: LD_INT 4
1230: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1231: LD_ADDR_EXP 45
1235: PUSH
1236: LD_STRING Powell
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL 474 0 2
1246: ST_TO_ADDR
// uc_side := 1 ;
1247: LD_ADDR_OWVAR 20
1251: PUSH
1252: LD_INT 1
1254: ST_TO_ADDR
// uc_nation := 1 ;
1255: LD_ADDR_OWVAR 21
1259: PUSH
1260: LD_INT 1
1262: ST_TO_ADDR
// if debug then
1263: LD_EXP 1
1267: IFFALSE 1397
// begin for i = 1 to 4 do
1269: LD_ADDR_VAR 0 2
1273: PUSH
1274: DOUBLE
1275: LD_INT 1
1277: DEC
1278: ST_TO_ADDR
1279: LD_INT 4
1281: PUSH
1282: FOR_TO
1283: IFFALSE 1334
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 12
1298: PPUSH
1299: LD_INT 3
1301: PPUSH
1302: CALL_OW 380
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 3
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// others := others ^ un ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_VAR 0 3
1330: ADD
1331: ST_TO_ADDR
// end ;
1332: GO 1282
1334: POP
1335: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1336: LD_ADDR_VAR 0 6
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: LD_INT 1
1349: PUSH
1350: LD_INT 51
1352: PUSH
1353: LD_INT 90
1355: PUSH
1356: LD_INT 504
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: PUSH
1367: LD_INT 21
1369: PUSH
1370: LD_INT 1
1372: PUSH
1373: LD_INT 1
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 80
1381: PUSH
1382: LD_INT 750
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1397: LD_ADDR_EXP 36
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: CALL 474 0 2
1415: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1416: LD_ADDR_EXP 37
1420: PUSH
1421: LD_STRING Bobby
1423: PPUSH
1424: LD_EXP 1
1428: NOT
1429: PPUSH
1430: CALL 474 0 2
1434: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1435: LD_ADDR_EXP 38
1439: PUSH
1440: LD_STRING Cyrus
1442: PPUSH
1443: LD_EXP 1
1447: NOT
1448: PPUSH
1449: CALL 474 0 2
1453: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1454: LD_ADDR_EXP 39
1458: PUSH
1459: LD_STRING Lisa
1461: PPUSH
1462: LD_EXP 1
1466: NOT
1467: PPUSH
1468: CALL 474 0 2
1472: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1473: LD_ADDR_EXP 40
1477: PUSH
1478: LD_STRING Khatam
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: CALL 474 0 2
1491: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1492: LD_ADDR_EXP 41
1496: PUSH
1497: LD_STRING Brian
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: CALL 474 0 2
1510: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1511: LD_ADDR_EXP 42
1515: PUSH
1516: LD_STRING Jerry
1518: PPUSH
1519: LD_EXP 1
1523: NOT
1524: PPUSH
1525: CALL 474 0 2
1529: ST_TO_ADDR
// if Bobby then
1530: LD_EXP 37
1534: IFFALSE 1565
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1536: LD_ADDR_VAR 0 4
1540: PUSH
1541: LD_VAR 0 4
1545: PPUSH
1546: LD_VAR 0 4
1550: PUSH
1551: LD_INT 1
1553: PLUS
1554: PPUSH
1555: LD_EXP 37
1559: PPUSH
1560: CALL_OW 2
1564: ST_TO_ADDR
// if Cyrus then
1565: LD_EXP 38
1569: IFFALSE 1600
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1571: LD_ADDR_VAR 0 4
1575: PUSH
1576: LD_VAR 0 4
1580: PPUSH
1581: LD_VAR 0 4
1585: PUSH
1586: LD_INT 1
1588: PLUS
1589: PPUSH
1590: LD_EXP 38
1594: PPUSH
1595: CALL_OW 2
1599: ST_TO_ADDR
// if Lisa then
1600: LD_EXP 39
1604: IFFALSE 1635
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1606: LD_ADDR_VAR 0 4
1610: PUSH
1611: LD_VAR 0 4
1615: PPUSH
1616: LD_VAR 0 4
1620: PUSH
1621: LD_INT 1
1623: PLUS
1624: PPUSH
1625: LD_EXP 39
1629: PPUSH
1630: CALL_OW 2
1634: ST_TO_ADDR
// if Khatam then
1635: LD_EXP 40
1639: IFFALSE 1670
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1641: LD_ADDR_VAR 0 4
1645: PUSH
1646: LD_VAR 0 4
1650: PPUSH
1651: LD_VAR 0 4
1655: PUSH
1656: LD_INT 1
1658: PLUS
1659: PPUSH
1660: LD_EXP 40
1664: PPUSH
1665: CALL_OW 2
1669: ST_TO_ADDR
// if Brian then
1670: LD_EXP 41
1674: IFFALSE 1705
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1676: LD_ADDR_VAR 0 4
1680: PUSH
1681: LD_VAR 0 4
1685: PPUSH
1686: LD_VAR 0 4
1690: PUSH
1691: LD_INT 1
1693: PLUS
1694: PPUSH
1695: LD_EXP 41
1699: PPUSH
1700: CALL_OW 2
1704: ST_TO_ADDR
// if Jerry then
1705: LD_EXP 42
1709: IFFALSE 1740
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1711: LD_ADDR_VAR 0 4
1715: PUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: PPUSH
1730: LD_EXP 42
1734: PPUSH
1735: CALL_OW 2
1739: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 28
1747: IFFALSE 1762
// others := CreateCharacterSet ( 02_other_survivors ) ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_STRING 02_other_survivors
1756: PPUSH
1757: CALL_OW 31
1761: ST_TO_ADDR
// if others then
1762: LD_VAR 0 5
1766: IFFALSE 1791
// begin tmp := tmp ^ others ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_VAR 0 4
1777: PUSH
1778: LD_VAR 0 5
1782: ADD
1783: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1784: LD_STRING 02_other_survivors
1786: PPUSH
1787: CALL_OW 40
// end ; jmm_units := tmp ;
1791: LD_ADDR_EXP 4
1795: PUSH
1796: LD_VAR 0 4
1800: ST_TO_ADDR
// if not vehicles then
1801: LD_VAR 0 6
1805: NOT
1806: IFFALSE 1824
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1808: LD_ADDR_VAR 0 6
1812: PUSH
1813: LD_STRING 02_tanks_1
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if vehicles then
1824: LD_VAR 0 6
1828: IFFALSE 2022
// begin got_mech := false ;
1830: LD_ADDR_VAR 0 7
1834: PUSH
1835: LD_INT 0
1837: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1838: LD_VAR 0 4
1842: PPUSH
1843: LD_INT 25
1845: PUSH
1846: LD_INT 3
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 72
1857: IFFALSE 1867
// got_mech := true ;
1859: LD_ADDR_VAR 0 7
1863: PUSH
1864: LD_INT 1
1866: ST_TO_ADDR
// for i = 1 to vehicles do
1867: LD_ADDR_VAR 0 2
1871: PUSH
1872: DOUBLE
1873: LD_INT 1
1875: DEC
1876: ST_TO_ADDR
1877: LD_VAR 0 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 2020
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_INT 1
1892: PPUSH
1893: LD_INT 3
1895: PPUSH
1896: LD_VAR 0 6
1900: PUSH
1901: LD_VAR 0 2
1905: ARRAY
1906: PUSH
1907: LD_INT 1
1909: ARRAY
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 2
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 3
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 4
1954: ARRAY
1955: PPUSH
1956: LD_INT 40
1958: PPUSH
1959: CALL 537 0 7
1963: ST_TO_ADDR
// if not got_mech then
1964: LD_VAR 0 7
1968: NOT
1969: IFFALSE 1995
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_VAR 0 6
1980: PUSH
1981: LD_VAR 0 2
1985: ARRAY
1986: PUSH
1987: LD_INT 6
1989: ARRAY
1990: PPUSH
1991: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1995: LD_ADDR_VAR 0 4
1999: PUSH
2000: LD_VAR 0 4
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_VAR 0 3
2012: PPUSH
2013: CALL_OW 2
2017: ST_TO_ADDR
// end ;
2018: GO 1882
2020: POP
2021: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2022: LD_EXP 36
2026: PPUSH
2027: LD_INT 194
2029: PPUSH
2030: LD_INT 119
2032: PPUSH
2033: LD_INT 0
2035: PPUSH
2036: CALL_OW 48
// if tmp then
2040: LD_VAR 0 4
2044: IFFALSE 2169
// begin for i in tmp do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_VAR 0 4
2055: PUSH
2056: FOR_IN
2057: IFFALSE 2167
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2059: LD_ADDR_VAR 0 8
2063: PUSH
2064: LD_INT 22
2066: PUSH
2067: LD_INT 1
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PUSH
2074: LD_INT 21
2076: PUSH
2077: LD_INT 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 58
2086: PUSH
2087: EMPTY
2088: LIST
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: LIST
2094: PPUSH
2095: CALL_OW 69
2099: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2100: LD_VAR 0 2
2104: PPUSH
2105: CALL_OW 247
2109: PUSH
2110: LD_INT 1
2112: EQUAL
2113: PUSH
2114: LD_VAR 0 8
2118: AND
2119: IFFALSE 2141
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2121: LD_VAR 0 2
2125: PPUSH
2126: LD_VAR 0 8
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: PPUSH
2135: CALL_OW 52
2139: GO 2156
// PlaceUnitArea ( i , startArea , false ) ;
2141: LD_VAR 0 2
2145: PPUSH
2146: LD_INT 1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 49
// ComHold ( i ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: CALL_OW 140
// end ;
2165: GO 2056
2167: POP
2168: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2169: LD_ADDR_EXP 7
2173: PUSH
2174: LD_STRING 02_mikhailStatus_1
2176: PPUSH
2177: LD_INT 0
2179: PPUSH
2180: CALL_OW 30
2184: ST_TO_ADDR
// if not bierezov_exist and not debug then
2185: LD_EXP 7
2189: NOT
2190: PUSH
2191: LD_EXP 1
2195: NOT
2196: AND
2197: IFFALSE 2201
// exit ;
2199: GO 2232
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2201: LD_ADDR_EXP 44
2205: PUSH
2206: LD_STRING Mikhail
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 474 0 2
2216: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2217: LD_EXP 44
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: LD_INT 0
2227: PPUSH
2228: CALL_OW 49
// end ;
2232: LD_VAR 0 1
2236: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2237: LD_INT 0
2239: PPUSH
2240: PPUSH
2241: PPUSH
2242: PPUSH
// uc_side := 4 ;
2243: LD_ADDR_OWVAR 20
2247: PUSH
2248: LD_INT 4
2250: ST_TO_ADDR
// uc_nation := 1 ;
2251: LD_ADDR_OWVAR 21
2255: PUSH
2256: LD_INT 1
2258: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2259: LD_ADDR_EXP 43
2263: PUSH
2264: LD_STRING Cornell
2266: PPUSH
2267: LD_INT 0
2269: PPUSH
2270: CALL 474 0 2
2274: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2275: LD_ADDR_EXP 6
2279: PUSH
2280: LD_INT 9
2282: PUSH
2283: LD_EXP 4
2287: MINUS
2288: ST_TO_ADDR
// tmp := [ ] ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: EMPTY
2295: ST_TO_ADDR
// if cornel_units < 4 then
2296: LD_EXP 6
2300: PUSH
2301: LD_INT 4
2303: LESS
2304: IFFALSE 2314
// cornel_units := 4 ;
2306: LD_ADDR_EXP 6
2310: PUSH
2311: LD_INT 4
2313: ST_TO_ADDR
// for i = 1 to cornel_units do
2314: LD_ADDR_VAR 0 4
2318: PUSH
2319: DOUBLE
2320: LD_INT 1
2322: DEC
2323: ST_TO_ADDR
2324: LD_EXP 6
2328: PUSH
2329: FOR_TO
2330: IFFALSE 2428
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2332: LD_INT 0
2334: PPUSH
2335: LD_INT 1
2337: PUSH
2338: LD_INT 1
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: LD_INT 2
2346: PUSH
2347: LD_INT 4
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: LIST
2356: PUSH
2357: LD_VAR 0 4
2361: PUSH
2362: LD_INT 5
2364: MOD
2365: PUSH
2366: LD_INT 1
2368: PLUS
2369: ARRAY
2370: PPUSH
2371: LD_INT 2
2373: PPUSH
2374: CALL_OW 380
// un := CreateHuman ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: CALL_OW 44
2387: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 2
2397: PPUSH
2398: LD_INT 1
2400: PPUSH
2401: LD_VAR 0 3
2405: PPUSH
2406: CALL_OW 2
2410: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2411: LD_VAR 0 3
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: LD_INT 0
2421: PPUSH
2422: CALL_OW 49
// end ;
2426: GO 2329
2428: POP
2429: POP
// cornel_units := tmp ;
2430: LD_ADDR_EXP 6
2434: PUSH
2435: LD_VAR 0 2
2439: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2440: LD_EXP 43
2444: PPUSH
2445: LD_INT 191
2447: PPUSH
2448: LD_INT 106
2450: PPUSH
2451: LD_INT 0
2453: PPUSH
2454: CALL_OW 48
// end ;
2458: LD_VAR 0 1
2462: RET
// export function PrepareWesternBase ; var i ; begin
2463: LD_INT 0
2465: PPUSH
2466: PPUSH
// uc_side := 8 ;
2467: LD_ADDR_OWVAR 20
2471: PUSH
2472: LD_INT 8
2474: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2475: LD_ADDR_EXP 46
2479: PUSH
2480: LD_STRING Lynch
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL 474 0 2
2490: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2491: LD_ADDR_EXP 47
2495: PUSH
2496: LD_STRING Walker
2498: PPUSH
2499: LD_INT 0
2501: PPUSH
2502: CALL 474 0 2
2506: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2507: LD_ADDR_EXP 48
2511: PUSH
2512: LD_STRING Turner
2514: PPUSH
2515: LD_INT 0
2517: PPUSH
2518: CALL 474 0 2
2522: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2523: LD_ADDR_EXP 49
2527: PUSH
2528: LD_STRING Jillian
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: CALL 474 0 2
2538: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_EXP 46
2548: PUSH
2549: LD_EXP 47
2553: PUSH
2554: LD_EXP 48
2558: PUSH
2559: LD_EXP 49
2563: PUSH
2564: EMPTY
2565: LIST
2566: LIST
2567: LIST
2568: LIST
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2599
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 3
2580: PPUSH
2581: LD_INT 0
2583: PPUSH
2584: CALL_OW 49
// ComHold ( i ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: CALL_OW 140
// end ;
2597: GO 2570
2599: POP
2600: POP
// end ;
2601: LD_VAR 0 1
2605: RET
// export function SelectGroup ; var units , selected , i ; begin
2606: LD_INT 0
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2612: LD_ADDR_VAR 0 2
2616: PUSH
2617: LD_EXP 36
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_EXP 4
2633: ADD
2634: PUSH
2635: LD_INT -2
2637: PUSH
2638: LD_INT -4
2640: PUSH
2641: LD_EXP 43
2645: PUSH
2646: LD_EXP 44
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: ADD
2657: PUSH
2658: LD_INT -3
2660: PUSH
2661: EMPTY
2662: LIST
2663: ADD
2664: PUSH
2665: LD_EXP 6
2669: ADD
2670: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 36
2680: PUSH
2681: LD_STRING Select five characters to go with you
2683: PPUSH
2684: LD_INT 4
2686: PPUSH
2687: LD_INT 4
2689: PPUSH
2690: LD_VAR 0 2
2694: PPUSH
2695: EMPTY
2696: PPUSH
2697: CALL_OW 42
2701: ADD
2702: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2703: LD_ADDR_EXP 6
2707: PUSH
2708: LD_EXP 4
2712: PUSH
2713: LD_EXP 6
2717: UNION
2718: PUSH
2719: LD_VAR 0 3
2723: DIFF
2724: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2725: LD_ADDR_VAR 0 4
2729: PUSH
2730: LD_EXP 6
2734: PUSH
2735: LD_EXP 44
2739: ADD
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 1 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 1
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 4 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 4
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// for i in selected do
2775: LD_ADDR_VAR 0 4
2779: PUSH
2780: LD_VAR 0 3
2784: PUSH
2785: FOR_IN
2786: IFFALSE 2817
// if GetSide ( i ) = 4 then
2788: LD_VAR 0 4
2792: PPUSH
2793: CALL_OW 255
2797: PUSH
2798: LD_INT 4
2800: EQUAL
2801: IFFALSE 2815
// SetSide ( i , 1 ) ;
2803: LD_VAR 0 4
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: CALL_OW 235
2815: GO 2785
2817: POP
2818: POP
// jmm_units := jmm_units diff cornel_units ;
2819: LD_ADDR_EXP 4
2823: PUSH
2824: LD_EXP 4
2828: PUSH
2829: LD_EXP 6
2833: DIFF
2834: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Bobby
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2863: LD_EXP 38
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Cyrus
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2891: LD_EXP 39
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Lisa
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2919: LD_EXP 40
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Khatam
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2947: LD_EXP 41
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Brian
2969: STR
2970: PPUSH
2971: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2975: LD_EXP 42
2979: PPUSH
2980: CALL_OW 255
2984: PUSH
2985: LD_INT 4
2987: EQUAL
2988: IFFALSE 3003
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2990: LD_EXP 3
2994: PUSH
2995: LD_STRING Jerry
2997: STR
2998: PPUSH
2999: CALL_OW 40
// end ; end_of_file
3003: LD_VAR 0 1
3007: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
// ru_alert := false ;
3023: LD_ADDR_EXP 59
3027: PUSH
3028: LD_INT 0
3030: ST_TO_ADDR
// ru_produce_list := [ ] ;
3031: LD_ADDR_EXP 56
3035: PUSH
3036: EMPTY
3037: ST_TO_ADDR
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3134
// begin uc_side := 3 ;
3048: LD_ADDR_OWVAR 20
3052: PUSH
3053: LD_INT 3
3055: ST_TO_ADDR
// uc_nation := 3 ;
3056: LD_ADDR_OWVAR 21
3060: PUSH
3061: LD_INT 3
3063: ST_TO_ADDR
// bc_type := b_breastwork ;
3064: LD_ADDR_OWVAR 42
3068: PUSH
3069: LD_INT 31
3071: ST_TO_ADDR
// bc_level := Difficulty ;
3072: LD_ADDR_OWVAR 43
3076: PUSH
3077: LD_OWVAR 67
3081: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3082: LD_INT 22
3084: PPUSH
3085: LD_INT 14
3087: PPUSH
3088: LD_INT 0
3090: PPUSH
3091: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3095: LD_INT 48
3097: PPUSH
3098: LD_INT 46
3100: PPUSH
3101: LD_INT 0
3103: PPUSH
3104: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3108: LD_INT 86
3110: PPUSH
3111: LD_INT 65
3113: PPUSH
3114: LD_INT 5
3116: PPUSH
3117: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3121: LD_INT 165
3123: PPUSH
3124: LD_INT 73
3126: PPUSH
3127: LD_INT 5
3129: PPUSH
3130: CALL_OW 47
// end ; if Difficulty = 3 then
3134: LD_OWVAR 67
3138: PUSH
3139: LD_INT 3
3141: EQUAL
3142: IFFALSE 3157
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3144: LD_INT 51
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 2
3152: PPUSH
3153: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3157: LD_ADDR_VAR 0 7
3161: PUSH
3162: LD_INT 22
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 2
3174: PUSH
3175: LD_INT 30
3177: PUSH
3178: LD_INT 31
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 30
3187: PUSH
3188: LD_INT 32
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 69
3208: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3209: LD_ADDR_VAR 0 8
3213: PUSH
3214: LD_INT 22
3216: PUSH
3217: LD_INT 3
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 30
3226: PUSH
3227: LD_INT 4
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PPUSH
3238: CALL_OW 69
3242: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3243: LD_ADDR_VAR 0 10
3247: PUSH
3248: LD_INT 22
3250: PUSH
3251: LD_INT 3
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: LD_INT 30
3260: PUSH
3261: LD_INT 3
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 69
3276: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3277: LD_ADDR_VAR 0 9
3281: PUSH
3282: LD_INT 22
3284: PUSH
3285: LD_INT 3
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 30
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3311: LD_ADDR_VAR 0 2
3315: PUSH
3316: LD_INT 22
3318: PUSH
3319: LD_INT 3
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 30
3328: PUSH
3329: LD_INT 1
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PPUSH
3340: CALL_OW 69
3344: PUSH
3345: FOR_IN
3346: IFFALSE 3390
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 274
3357: PPUSH
3358: LD_INT 1
3360: PPUSH
3361: LD_INT 5000
3363: PPUSH
3364: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 274
3377: PPUSH
3378: LD_INT 2
3380: PPUSH
3381: LD_INT 3000
3383: PPUSH
3384: CALL_OW 277
// end ;
3388: GO 3345
3390: POP
3391: POP
// uc_side := 3 ;
3392: LD_ADDR_OWVAR 20
3396: PUSH
3397: LD_INT 3
3399: ST_TO_ADDR
// uc_nation := 3 ;
3400: LD_ADDR_OWVAR 21
3404: PUSH
3405: LD_INT 3
3407: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3408: LD_ADDR_VAR 0 11
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 4
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: LD_OWVAR 67
3431: ARRAY
3432: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3433: LD_ADDR_EXP 51
3437: PUSH
3438: LD_STRING Pokryshkin
3440: PPUSH
3441: LD_INT 0
3443: PPUSH
3444: CALL 474 0 2
3448: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3449: LD_EXP 51
3453: PPUSH
3454: LD_INT 63
3456: PPUSH
3457: LD_INT 21
3459: PPUSH
3460: LD_INT 0
3462: PPUSH
3463: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3467: LD_EXP 51
3471: PPUSH
3472: CALL_OW 140
// InitHc ;
3476: CALL_OW 19
// for i in fac do
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: LD_VAR 0 10
3489: PUSH
3490: FOR_IN
3491: IFFALSE 3544
// begin for j = 1 to 6 do
3493: LD_ADDR_VAR 0 3
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 6
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3540
// begin PrepareHuman ( false , 3 , skill ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: LD_VAR 0 11
3519: PPUSH
3520: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3524: CALL_OW 44
3528: PPUSH
3529: LD_VAR 0 2
3533: PPUSH
3534: CALL_OW 52
// end ;
3538: GO 3506
3540: POP
3541: POP
// end ;
3542: GO 3490
3544: POP
3545: POP
// for i in lab do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 9
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 4 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// for i in tw do
3592: LD_ADDR_VAR 0 2
3596: PUSH
3597: LD_VAR 0 7
3601: PUSH
3602: FOR_IN
3603: IFFALSE 3652
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3605: LD_VAR 0 2
3609: PPUSH
3610: LD_INT 42
3612: PUSH
3613: LD_INT 43
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: CALL_OW 12
3630: ARRAY
3631: PPUSH
3632: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3636: LD_VAR 0 11
3640: PPUSH
3641: LD_VAR 0 2
3645: PPUSH
3646: CALL 815 0 2
// end ;
3650: GO 3602
3652: POP
3653: POP
// for i in bar do
3654: LD_ADDR_VAR 0 2
3658: PUSH
3659: LD_VAR 0 8
3663: PUSH
3664: FOR_IN
3665: IFFALSE 3698
// begin PrepareHuman ( false , 1 , skill ) ;
3667: LD_INT 0
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: LD_VAR 0 11
3677: PPUSH
3678: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3682: CALL_OW 44
3686: PPUSH
3687: LD_VAR 0 2
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3664
3698: POP
3699: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3700: LD_ADDR_VAR 0 13
3704: PUSH
3705: LD_INT 100
3707: PUSH
3708: LD_INT 9
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 135
3717: PUSH
3718: LD_INT 60
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 41
3727: PUSH
3728: LD_INT 6
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: LD_INT 22
3737: PUSH
3738: LD_INT 9
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PUSH
3745: LD_INT 84
3747: PUSH
3748: LD_INT 14
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: LIST
3760: LIST
3761: ST_TO_ADDR
// vehicles := [ ] ;
3762: LD_ADDR_VAR 0 12
3766: PUSH
3767: EMPTY
3768: ST_TO_ADDR
// for i in spot_xy do
3769: LD_ADDR_VAR 0 2
3773: PUSH
3774: LD_VAR 0 13
3778: PUSH
3779: FOR_IN
3780: IFFALSE 3938
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3782: LD_ADDR_VAR 0 6
3786: PUSH
3787: LD_INT 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 22
3795: PPUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 1
3801: PPUSH
3802: LD_INT 42
3804: PUSH
3805: LD_INT 43
3807: PUSH
3808: LD_INT 44
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: PUSH
3816: LD_INT 1
3818: PPUSH
3819: LD_INT 3
3821: PPUSH
3822: CALL_OW 12
3826: ARRAY
3827: PPUSH
3828: LD_INT 100
3830: PPUSH
3831: CALL 537 0 7
3835: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3836: LD_ADDR_VAR 0 12
3840: PUSH
3841: LD_VAR 0 12
3845: PPUSH
3846: LD_VAR 0 12
3850: PUSH
3851: LD_INT 1
3853: PLUS
3854: PPUSH
3855: LD_VAR 0 6
3859: PPUSH
3860: CALL_OW 2
3864: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_INT 3
3872: PPUSH
3873: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3877: LD_VAR 0 6
3881: PPUSH
3882: LD_VAR 0 2
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_VAR 0 2
3895: PUSH
3896: LD_INT 2
3898: ARRAY
3899: PPUSH
3900: LD_INT 0
3902: PPUSH
3903: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3907: LD_INT 0
3909: PPUSH
3910: LD_INT 3
3912: PPUSH
3913: LD_VAR 0 11
3917: PPUSH
3918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3922: CALL_OW 44
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: CALL_OW 52
// end ;
3936: GO 3779
3938: POP
3939: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: DOUBLE
3946: LD_INT 1
3948: DEC
3949: ST_TO_ADDR
3950: LD_INT 5
3952: PUSH
3953: LD_INT 7
3955: PUSH
3956: LD_INT 8
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 67
3968: ARRAY
3969: PUSH
3970: FOR_TO
3971: IFFALSE 4031
// begin PrepareHuman ( false , 1 , skill ) ;
3973: LD_INT 0
3975: PPUSH
3976: LD_INT 1
3978: PPUSH
3979: LD_VAR 0 11
3983: PPUSH
3984: CALL_OW 380
// un := CreateHuman ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: CALL_OW 44
3997: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3998: LD_VAR 0 5
4002: PPUSH
4003: LD_INT 11
4005: PPUSH
4006: LD_INT 0
4008: PPUSH
4009: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4013: LD_ADDR_EXP 54
4017: PUSH
4018: LD_EXP 54
4022: PUSH
4023: LD_VAR 0 5
4027: ADD
4028: ST_TO_ADDR
// end ;
4029: GO 3970
4031: POP
4032: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4033: LD_ADDR_VAR 0 2
4037: PUSH
4038: DOUBLE
4039: LD_INT 1
4041: DEC
4042: ST_TO_ADDR
4043: LD_INT 2
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: LD_INT 4
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: LIST
4056: PUSH
4057: LD_OWVAR 67
4061: ARRAY
4062: PUSH
4063: FOR_TO
4064: IFFALSE 4124
// begin PrepareHuman ( false , 1 , skill ) ;
4066: LD_INT 0
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_VAR 0 11
4076: PPUSH
4077: CALL_OW 380
// un := CreateHuman ;
4081: LD_ADDR_VAR 0 5
4085: PUSH
4086: CALL_OW 44
4090: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4091: LD_VAR 0 5
4095: PPUSH
4096: LD_INT 12
4098: PPUSH
4099: LD_INT 0
4101: PPUSH
4102: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4106: LD_ADDR_EXP 52
4110: PUSH
4111: LD_EXP 52
4115: PUSH
4116: LD_VAR 0 5
4120: ADD
4121: ST_TO_ADDR
// end ;
4122: GO 4063
4124: POP
4125: POP
// for i = 1 to 2 do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: DOUBLE
4132: LD_INT 1
4134: DEC
4135: ST_TO_ADDR
4136: LD_INT 2
4138: PUSH
4139: FOR_TO
4140: IFFALSE 4206
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4142: LD_INT 1
4144: PPUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 11
4152: PPUSH
4153: CALL_OW 380
// un := CreateHuman ;
4157: LD_ADDR_VAR 0 5
4161: PUSH
4162: CALL_OW 44
4166: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4167: LD_VAR 0 5
4171: PPUSH
4172: LD_INT 39
4174: PPUSH
4175: LD_INT 12
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: LD_INT 0
4183: PPUSH
4184: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4188: LD_ADDR_EXP 53
4192: PUSH
4193: LD_EXP 53
4197: PUSH
4198: LD_VAR 0 5
4202: ADD
4203: ST_TO_ADDR
// end ;
4204: GO 4139
4206: POP
4207: POP
// for i = 1 to 3 do
4208: LD_ADDR_VAR 0 2
4212: PUSH
4213: DOUBLE
4214: LD_INT 1
4216: DEC
4217: ST_TO_ADDR
4218: LD_INT 3
4220: PUSH
4221: FOR_TO
4222: IFFALSE 4288
// begin PrepareHuman ( false , 1 , skill ) ;
4224: LD_INT 0
4226: PPUSH
4227: LD_INT 1
4229: PPUSH
4230: LD_VAR 0 11
4234: PPUSH
4235: CALL_OW 380
// un := CreateHuman ;
4239: LD_ADDR_VAR 0 5
4243: PUSH
4244: CALL_OW 44
4248: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4249: LD_VAR 0 5
4253: PPUSH
4254: LD_INT 180
4256: PPUSH
4257: LD_INT 11
4259: PPUSH
4260: LD_INT 4
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4270: LD_ADDR_EXP 57
4274: PUSH
4275: LD_EXP 57
4279: PUSH
4280: LD_VAR 0 5
4284: ADD
4285: ST_TO_ADDR
// end ;
4286: GO 4221
4288: POP
4289: POP
// ru_vehicles := vehicles ;
4290: LD_ADDR_EXP 55
4294: PUSH
4295: LD_VAR 0 12
4299: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4300: LD_ADDR_EXP 58
4304: PUSH
4305: LD_INT 131
4307: PUSH
4308: LD_INT 121
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 113
4317: PUSH
4318: LD_INT 90
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 93
4327: PUSH
4328: LD_INT 62
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 106
4342: PUSH
4343: LD_INT 54
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 120
4352: PUSH
4353: LD_INT 80
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 143
4362: PUSH
4363: LD_INT 120
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 154
4377: PUSH
4378: LD_INT 116
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: LD_INT 140
4387: PUSH
4388: LD_INT 93
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 130
4397: PUSH
4398: LD_INT 58
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 105
4412: PUSH
4413: LD_INT 106
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 134
4422: PUSH
4423: LD_INT 98
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 159
4432: PUSH
4433: LD_INT 113
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: DOUBLE
4457: LD_INT 1
4459: DEC
4460: ST_TO_ADDR
4461: LD_OWVAR 67
4465: PUSH
4466: LD_INT 1
4468: MINUS
4469: PUSH
4470: FOR_TO
4471: IFFALSE 4504
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4473: LD_ADDR_EXP 56
4477: PUSH
4478: LD_EXP 56
4482: PUSH
4483: LD_INT 22
4485: PUSH
4486: LD_INT 1
4488: PUSH
4489: LD_INT 1
4491: PUSH
4492: LD_INT 43
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: ADD
4501: ST_TO_ADDR
4502: GO 4470
4504: POP
4505: POP
// end ;
4506: LD_VAR 0 1
4510: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4511: LD_INT 22
4513: PUSH
4514: LD_INT 3
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 21
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: IFFALSE 4633
4541: GO 4543
4543: DISABLE
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// begin enable ;
4548: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4549: LD_ADDR_VAR 0 2
4553: PUSH
4554: LD_INT 22
4556: PUSH
4557: LD_INT 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 21
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PPUSH
4578: CALL_OW 69
4582: ST_TO_ADDR
// if filter then
4583: LD_VAR 0 2
4587: IFFALSE 4633
// for i in filter do
4589: LD_ADDR_VAR 0 1
4593: PUSH
4594: LD_VAR 0 2
4598: PUSH
4599: FOR_IN
4600: IFFALSE 4631
// if GetFuel ( i ) < 20 then
4602: LD_VAR 0 1
4606: PPUSH
4607: CALL_OW 261
4611: PUSH
4612: LD_INT 20
4614: LESS
4615: IFFALSE 4629
// SetFuel ( i , 20 ) ;
4617: LD_VAR 0 1
4621: PPUSH
4622: LD_INT 20
4624: PPUSH
4625: CALL_OW 240
4629: GO 4599
4631: POP
4632: POP
// end ;
4633: PPOPN 2
4635: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4636: LD_EXP 56
4640: IFFALSE 4859
4642: GO 4644
4644: DISABLE
4645: LD_INT 0
4647: PPUSH
4648: PPUSH
4649: PPUSH
// begin enable ;
4650: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4651: LD_ADDR_VAR 0 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 3
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 30
4668: PUSH
4669: LD_INT 3
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PPUSH
4680: CALL_OW 69
4684: ST_TO_ADDR
// can_produce := [ ] ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: EMPTY
4691: ST_TO_ADDR
// if not fac then
4692: LD_VAR 0 2
4696: NOT
4697: IFFALSE 4702
// begin disable ;
4699: DISABLE
// exit ;
4700: GO 4859
// end ; for i in fac do
4702: LD_ADDR_VAR 0 1
4706: PUSH
4707: LD_VAR 0 2
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4751
// if UnitsInside ( i ) then
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 313
4724: IFFALSE 4749
// can_produce := Insert ( can_produce , 1 , i ) ;
4726: LD_ADDR_VAR 0 3
4730: PUSH
4731: LD_VAR 0 3
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: LD_VAR 0 1
4743: PPUSH
4744: CALL_OW 2
4748: ST_TO_ADDR
4749: GO 4712
4751: POP
4752: POP
// if not can_produce then
4753: LD_VAR 0 3
4757: NOT
4758: IFFALSE 4762
// exit ;
4760: GO 4859
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4762: LD_VAR 0 3
4766: PUSH
4767: LD_INT 1
4769: PPUSH
4770: LD_VAR 0 3
4774: PPUSH
4775: CALL_OW 12
4779: ARRAY
4780: PPUSH
4781: LD_EXP 56
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_EXP 56
4794: PUSH
4795: LD_INT 2
4797: ARRAY
4798: PPUSH
4799: LD_EXP 56
4803: PUSH
4804: LD_INT 3
4806: ARRAY
4807: PPUSH
4808: LD_EXP 56
4812: PUSH
4813: LD_INT 4
4815: ARRAY
4816: PPUSH
4817: CALL_OW 125
// for i = 1 to 4 do
4821: LD_ADDR_VAR 0 1
4825: PUSH
4826: DOUBLE
4827: LD_INT 1
4829: DEC
4830: ST_TO_ADDR
4831: LD_INT 4
4833: PUSH
4834: FOR_TO
4835: IFFALSE 4857
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4837: LD_ADDR_EXP 56
4841: PUSH
4842: LD_EXP 56
4846: PPUSH
4847: LD_INT 1
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
4855: GO 4834
4857: POP
4858: POP
// end ;
4859: PPOPN 3
4861: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
4866: PPUSH
// for i = 1 to 6 do
4867: LD_ADDR_VAR 0 2
4871: PUSH
4872: DOUBLE
4873: LD_INT 1
4875: DEC
4876: ST_TO_ADDR
4877: LD_INT 6
4879: PUSH
4880: FOR_TO
4881: IFFALSE 5030
// begin PrepareHuman ( false , 3 , 3 ) ;
4883: LD_INT 0
4885: PPUSH
4886: LD_INT 3
4888: PPUSH
4889: LD_INT 3
4891: PPUSH
4892: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4896: LD_ADDR_VAR 0 3
4900: PUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: LD_INT 22
4909: PPUSH
4910: LD_INT 1
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: LD_INT 43
4918: PUSH
4919: LD_INT 42
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_INT 2
4931: PPUSH
4932: CALL_OW 12
4936: ARRAY
4937: PPUSH
4938: LD_INT 70
4940: PPUSH
4941: CALL 537 0 7
4945: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 4
4953: PPUSH
4954: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4958: LD_VAR 0 3
4962: PPUSH
4963: LD_INT 229
4965: PPUSH
4966: LD_INT 44
4968: PPUSH
4969: LD_INT 0
4971: PPUSH
4972: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4976: CALL_OW 44
4980: PPUSH
4981: LD_VAR 0 3
4985: PPUSH
4986: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4990: LD_ADDR_EXP 55
4994: PUSH
4995: LD_EXP 55
4999: PUSH
5000: LD_VAR 0 3
5004: ADD
5005: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5006: LD_VAR 0 3
5010: PPUSH
5011: LD_INT 191
5013: PPUSH
5014: LD_INT 32
5016: PPUSH
5017: CALL_OW 111
// Wait ( 0 0$02 ) ;
5021: LD_INT 70
5023: PPUSH
5024: CALL_OW 67
// end ;
5028: GO 4880
5030: POP
5031: POP
// end ;
5032: LD_VAR 0 1
5036: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5037: LD_EXP 30
5041: PUSH
5042: LD_EXP 55
5046: AND
5047: IFFALSE 5221
5049: GO 5051
5051: DISABLE
5052: LD_INT 0
5054: PPUSH
5055: PPUSH
5056: PPUSH
// begin wait ( 0 0$50 ) ;
5057: LD_INT 1750
5059: PPUSH
5060: CALL_OW 67
// tmp := ru_vehicles ;
5064: LD_ADDR_VAR 0 3
5068: PUSH
5069: LD_EXP 55
5073: ST_TO_ADDR
// if not tmp then
5074: LD_VAR 0 3
5078: NOT
5079: IFFALSE 5083
// exit ;
5081: GO 5221
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// for i in tmp do
5090: LD_ADDR_VAR 0 1
5094: PUSH
5095: LD_VAR 0 3
5099: PUSH
5100: FOR_IN
5101: IFFALSE 5212
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5103: LD_ADDR_VAR 0 2
5107: PUSH
5108: LD_INT 22
5110: PUSH
5111: LD_INT 1
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PPUSH
5118: LD_VAR 0 1
5122: PPUSH
5123: CALL_OW 74
5127: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5128: LD_VAR 0 1
5132: PPUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL_OW 296
5142: PUSH
5143: LD_INT 10
5145: GREATER
5146: IFFALSE 5165
// ComAgressiveMove ( i , 69 , 101 ) else
5148: LD_VAR 0 1
5152: PPUSH
5153: LD_INT 69
5155: PPUSH
5156: LD_INT 101
5158: PPUSH
5159: CALL_OW 114
5163: GO 5179
// ComAttackUnit ( i , enemy ) ;
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 115
// if GetLives ( i ) < 250 then
5179: LD_VAR 0 1
5183: PPUSH
5184: CALL_OW 256
5188: PUSH
5189: LD_INT 250
5191: LESS
5192: IFFALSE 5210
// tmp := tmp diff i ;
5194: LD_ADDR_VAR 0 3
5198: PUSH
5199: LD_VAR 0 3
5203: PUSH
5204: LD_VAR 0 1
5208: DIFF
5209: ST_TO_ADDR
// end ;
5210: GO 5100
5212: POP
5213: POP
// until not tmp ;
5214: LD_VAR 0 3
5218: NOT
5219: IFFALSE 5083
// end ; end_of_file
5221: PPOPN 3
5223: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5224: LD_INT 0
5226: PPUSH
5227: PPUSH
5228: PPUSH
5229: PPUSH
5230: PPUSH
5231: PPUSH
5232: PPUSH
// InGameOn ;
5233: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5237: LD_EXP 36
5241: PPUSH
5242: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5246: LD_EXP 36
5250: PPUSH
5251: LD_EXP 43
5255: PPUSH
5256: CALL_OW 119
// if Bierezov then
5260: LD_EXP 44
5264: IFFALSE 5280
// ComTurnUnit ( Bierezov , Cornel ) ;
5266: LD_EXP 44
5270: PPUSH
5271: LD_EXP 43
5275: PPUSH
5276: CALL_OW 119
// for i in jmm_units do
5280: LD_ADDR_VAR 0 2
5284: PUSH
5285: LD_EXP 4
5289: PUSH
5290: FOR_IN
5291: IFFALSE 5309
// ComTurnUnit ( i , Cornel ) ;
5293: LD_VAR 0 2
5297: PPUSH
5298: LD_EXP 43
5302: PPUSH
5303: CALL_OW 119
5307: GO 5290
5309: POP
5310: POP
// units := cornel_units union Cornel ;
5311: LD_ADDR_VAR 0 3
5315: PUSH
5316: LD_EXP 6
5320: PUSH
5321: LD_EXP 43
5325: UNION
5326: ST_TO_ADDR
// repeat wait ( 1 ) ;
5327: LD_INT 1
5329: PPUSH
5330: CALL_OW 67
// for i in units do
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: LD_VAR 0 3
5343: PUSH
5344: FOR_IN
5345: IFFALSE 5378
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5347: LD_VAR 0 2
5351: PPUSH
5352: LD_EXP 36
5356: PPUSH
5357: CALL_OW 250
5361: PPUSH
5362: LD_EXP 36
5366: PPUSH
5367: CALL_OW 251
5371: PPUSH
5372: CALL_OW 111
5376: GO 5344
5378: POP
5379: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5380: LD_VAR 0 3
5384: PPUSH
5385: LD_INT 92
5387: PUSH
5388: LD_EXP 36
5392: PPUSH
5393: CALL_OW 250
5397: PUSH
5398: LD_EXP 36
5402: PPUSH
5403: CALL_OW 251
5407: PUSH
5408: LD_INT 10
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: PPUSH
5417: CALL_OW 72
5421: PUSH
5422: LD_VAR 0 3
5426: EQUAL
5427: IFFALSE 5327
// for i in units do
5429: LD_ADDR_VAR 0 2
5433: PUSH
5434: LD_VAR 0 3
5438: PUSH
5439: FOR_IN
5440: IFFALSE 5458
// ComTurnUnit ( i , JMM ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_EXP 36
5451: PPUSH
5452: CALL_OW 119
5456: GO 5439
5458: POP
5459: POP
// ComTurnUnit ( Cornel , JMM ) ;
5460: LD_EXP 43
5464: PPUSH
5465: LD_EXP 36
5469: PPUSH
5470: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5474: LD_EXP 36
5478: PPUSH
5479: LD_STRING D1-JMM-1
5481: PPUSH
5482: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5486: LD_EXP 43
5490: PPUSH
5491: LD_STRING D1-Corn-1
5493: PPUSH
5494: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5498: LD_EXP 36
5502: PPUSH
5503: LD_EXP 43
5507: PPUSH
5508: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5512: LD_EXP 43
5516: PPUSH
5517: LD_EXP 36
5521: PPUSH
5522: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5526: LD_INT 35
5528: PPUSH
5529: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5533: LD_EXP 36
5537: PPUSH
5538: LD_EXP 43
5542: PPUSH
5543: CALL_OW 296
5547: PUSH
5548: LD_INT 6
5550: LESS
5551: IFFALSE 5526
// ChangeSideFog ( 4 , 1 ) ;
5553: LD_INT 4
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_EXP 43
5572: PPUSH
5573: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5577: LD_EXP 43
5581: PPUSH
5582: LD_EXP 36
5586: PPUSH
5587: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5591: LD_EXP 36
5595: PPUSH
5596: LD_STRING D1-JMM-2
5598: PPUSH
5599: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5603: LD_EXP 36
5607: PPUSH
5608: LD_STRING D1-JMM-2a
5610: PPUSH
5611: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5615: LD_EXP 43
5619: PPUSH
5620: LD_STRING D1-Corn-2
5622: PPUSH
5623: CALL_OW 88
// if bierezov_exist or debug then
5627: LD_EXP 7
5631: PUSH
5632: LD_EXP 1
5636: OR
5637: IFFALSE 5878
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5639: LD_EXP 43
5643: PPUSH
5644: LD_EXP 44
5648: PPUSH
5649: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5653: LD_INT 10
5655: PPUSH
5656: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5660: LD_EXP 43
5664: PPUSH
5665: LD_STRING D1a-Corn-1
5667: PPUSH
5668: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_EXP 44
5681: PPUSH
5682: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5686: LD_EXP 44
5690: PPUSH
5691: LD_EXP 36
5695: PPUSH
5696: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5700: LD_EXP 36
5704: PPUSH
5705: LD_STRING D1a-JMM-1
5707: PPUSH
5708: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5712: LD_EXP 36
5716: PPUSH
5717: LD_EXP 43
5721: PPUSH
5722: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5726: LD_EXP 43
5730: PPUSH
5731: LD_EXP 36
5735: PPUSH
5736: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5740: LD_EXP 43
5744: PPUSH
5745: LD_STRING D1a-Corn-2
5747: PPUSH
5748: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5752: LD_EXP 36
5756: PPUSH
5757: LD_STRING D1a-JMM-2
5759: PPUSH
5760: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5764: LD_EXP 43
5768: PPUSH
5769: LD_STRING D1a-Corn-3
5771: PPUSH
5772: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5776: LD_EXP 36
5780: PPUSH
5781: LD_STRING D1a-JMM-3
5783: PPUSH
5784: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_STRING D1a-Corn-4
5795: PPUSH
5796: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5800: LD_EXP 36
5804: PPUSH
5805: LD_STRING D1a-JMM-4
5807: PPUSH
5808: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5812: LD_EXP 43
5816: PPUSH
5817: LD_STRING D1a-Corn-5
5819: PPUSH
5820: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5824: LD_EXP 44
5828: PPUSH
5829: LD_EXP 43
5833: PPUSH
5834: CALL_OW 250
5838: PPUSH
5839: LD_EXP 43
5843: PPUSH
5844: CALL_OW 251
5848: PUSH
5849: LD_INT 2
5851: MINUS
5852: PPUSH
5853: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5857: LD_EXP 44
5861: PPUSH
5862: LD_EXP 43
5866: PPUSH
5867: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5871: LD_INT 10
5873: PPUSH
5874: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5878: LD_EXP 36
5882: PPUSH
5883: LD_STRING D1b-JMM-1
5885: PPUSH
5886: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5890: LD_EXP 43
5894: PPUSH
5895: LD_STRING D1b-Corn-1
5897: PPUSH
5898: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5902: LD_EXP 36
5906: PPUSH
5907: LD_STRING D1b-JMM-2
5909: PPUSH
5910: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5914: LD_EXP 43
5918: PPUSH
5919: LD_STRING D1b-Corn-2
5921: PPUSH
5922: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5926: LD_EXP 36
5930: PPUSH
5931: LD_STRING D1b-JMM-3
5933: PPUSH
5934: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5938: LD_INT 10
5940: PPUSH
5941: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5945: LD_EXP 45
5949: PPUSH
5950: LD_STRING D1b-Pow-3
5952: PPUSH
5953: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5957: LD_EXP 36
5961: PPUSH
5962: LD_STRING D1b-JMM-4
5964: PPUSH
5965: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5969: LD_EXP 43
5973: PPUSH
5974: LD_STRING D1b-Corn-4
5976: PPUSH
5977: CALL_OW 88
// if Khatam then
5981: LD_EXP 40
5985: IFFALSE 6001
// Say ( Khatam , D1b-Khat-4 ) else
5987: LD_EXP 40
5991: PPUSH
5992: LD_STRING D1b-Khat-4
5994: PPUSH
5995: CALL_OW 88
5999: GO 6037
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6001: LD_EXP 6
6005: PPUSH
6006: LD_INT 26
6008: PUSH
6009: LD_INT 1
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 72
6020: PUSH
6021: LD_EXP 43
6025: PUSH
6026: EMPTY
6027: LIST
6028: DIFF
6029: PPUSH
6030: LD_STRING D1b-Sol1-4
6032: PPUSH
6033: CALL 625 0 2
// if Cyrus then
6037: LD_EXP 38
6041: IFFALSE 6055
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6043: LD_EXP 38
6047: PPUSH
6048: LD_STRING D1b-Cyrus-4
6050: PPUSH
6051: CALL_OW 88
// if Lisa then
6055: LD_EXP 39
6059: IFFALSE 6117
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6061: LD_EXP 39
6065: PPUSH
6066: LD_STRING D1b-Lisa-4
6068: PPUSH
6069: CALL_OW 88
// if Cyrus then
6073: LD_EXP 38
6077: IFFALSE 6117
// begin if not IsInUnit ( Cyrus ) then
6079: LD_EXP 38
6083: PPUSH
6084: CALL_OW 310
6088: NOT
6089: IFFALSE 6105
// ComTurnUnit ( Cyrus , Lisa ) ;
6091: LD_EXP 38
6095: PPUSH
6096: LD_EXP 39
6100: PPUSH
6101: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6105: LD_EXP 38
6109: PPUSH
6110: LD_STRING D1b-Cyrus-5
6112: PPUSH
6113: CALL_OW 88
// end ; end ; SelectGroup ;
6117: CALL 2606 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6121: LD_EXP 36
6125: PPUSH
6126: LD_STRING D1d-JMM-1
6128: PPUSH
6129: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6133: LD_EXP 43
6137: PPUSH
6138: LD_STRING D1d-Corn-1
6140: PPUSH
6141: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6145: LD_ADDR_VAR 0 2
6149: PUSH
6150: LD_EXP 4
6154: PUSH
6155: LD_EXP 6
6159: ADD
6160: PUSH
6161: LD_EXP 36
6165: ADD
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6181
// ComHold ( i ) ;
6170: LD_VAR 0 2
6174: PPUSH
6175: CALL_OW 140
6179: GO 6167
6181: POP
6182: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6183: LD_ADDR_VAR 0 4
6187: PUSH
6188: LD_INT 22
6190: PUSH
6191: LD_INT 1
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 21
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: ST_TO_ADDR
// if vehicles then
6217: LD_VAR 0 4
6221: IFFALSE 6559
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6223: LD_EXP 6
6227: PPUSH
6228: LD_INT 55
6230: PUSH
6231: EMPTY
6232: LIST
6233: PPUSH
6234: CALL_OW 72
6238: IFFALSE 6277
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6240: LD_ADDR_VAR 0 2
6244: PUSH
6245: LD_EXP 6
6249: PPUSH
6250: LD_INT 55
6252: PUSH
6253: EMPTY
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6275
// ComExitVehicle ( i ) ;
6264: LD_VAR 0 2
6268: PPUSH
6269: CALL_OW 121
6273: GO 6261
6275: POP
6276: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6277: LD_ADDR_VAR 0 5
6281: PUSH
6282: LD_VAR 0 4
6286: PPUSH
6287: LD_INT 34
6289: PUSH
6290: LD_INT 51
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: ST_TO_ADDR
// if cargos then
6302: LD_VAR 0 5
6306: IFFALSE 6489
// begin vehicles := cargos ;
6308: LD_ADDR_VAR 0 4
6312: PUSH
6313: LD_VAR 0 5
6317: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6318: LD_ADDR_VAR 0 6
6322: PUSH
6323: LD_STRING 02_resources_4
6325: PPUSH
6326: LD_INT 0
6328: PPUSH
6329: CALL_OW 30
6333: ST_TO_ADDR
// if debug and not resources then
6334: LD_EXP 1
6338: PUSH
6339: LD_VAR 0 6
6343: NOT
6344: AND
6345: IFFALSE 6355
// resources := 160 ;
6347: LD_ADDR_VAR 0 6
6351: PUSH
6352: LD_INT 160
6354: ST_TO_ADDR
// if resources mod 10 then
6355: LD_VAR 0 6
6359: PUSH
6360: LD_INT 10
6362: MOD
6363: IFFALSE 6385
// resources := resources - resources mod 10 ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_VAR 0 6
6374: PUSH
6375: LD_VAR 0 6
6379: PUSH
6380: LD_INT 10
6382: MOD
6383: MINUS
6384: ST_TO_ADDR
// if resources then
6385: LD_VAR 0 6
6389: IFFALSE 6489
// for i in cargos do
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 5
6400: PUSH
6401: FOR_IN
6402: IFFALSE 6487
// begin if resources < 100 then
6404: LD_VAR 0 6
6408: PUSH
6409: LD_INT 100
6411: LESS
6412: IFFALSE 6434
// begin cargo := resources ;
6414: LD_ADDR_VAR 0 7
6418: PUSH
6419: LD_VAR 0 6
6423: ST_TO_ADDR
// resources := 0 ;
6424: LD_ADDR_VAR 0 6
6428: PUSH
6429: LD_INT 0
6431: ST_TO_ADDR
// end else
6432: GO 6456
// begin cargo := 100 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_INT 100
6441: ST_TO_ADDR
// resources := resources - 100 ;
6442: LD_ADDR_VAR 0 6
6446: PUSH
6447: LD_VAR 0 6
6451: PUSH
6452: LD_INT 100
6454: MINUS
6455: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6456: LD_VAR 0 2
6460: PPUSH
6461: LD_INT 1
6463: PPUSH
6464: LD_VAR 0 7
6468: PPUSH
6469: CALL_OW 290
// if resources = 0 then
6473: LD_VAR 0 6
6477: PUSH
6478: LD_INT 0
6480: EQUAL
6481: IFFALSE 6485
// break ;
6483: GO 6487
// end ;
6485: GO 6401
6487: POP
6488: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6489: LD_VAR 0 4
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 311
6502: PPUSH
6503: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6507: LD_VAR 0 4
6511: PUSH
6512: LD_INT 1
6514: ARRAY
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6523: LD_EXP 43
6527: PPUSH
6528: LD_VAR 0 4
6532: PUSH
6533: LD_INT 1
6535: ARRAY
6536: PPUSH
6537: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6541: LD_INT 35
6543: PPUSH
6544: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6548: LD_EXP 43
6552: PPUSH
6553: CALL_OW 310
6557: IFFALSE 6541
// end ; InGameOff ;
6559: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6563: LD_STRING M1
6565: PPUSH
6566: CALL_OW 337
// SaveForQuickRestart ;
6570: CALL_OW 22
// cornel_active := true ;
6574: LD_ADDR_EXP 8
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// end ;
6582: LD_VAR 0 1
6586: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6587: LD_EXP 36
6591: PPUSH
6592: LD_EXP 46
6596: PPUSH
6597: CALL_OW 296
6601: PUSH
6602: LD_INT 10
6604: LESS
6605: IFFALSE 7988
6607: GO 6609
6609: DISABLE
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
6616: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: LD_INT 89
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 138
6634: PUSH
6635: LD_INT 63
6637: PUSH
6638: EMPTY
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 196
6644: PUSH
6645: LD_INT 84
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 135
6654: PUSH
6655: LD_INT 52
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 103
6664: PUSH
6665: LD_INT 39
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: LD_INT 30
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 38
6684: PUSH
6685: LD_INT 51
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// Video ( true ) ;
6701: LD_INT 1
6703: PPUSH
6704: CALL 1185 0 1
// if jmm_units then
6708: LD_EXP 4
6712: IFFALSE 6788
// for i in jmm_units do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: LD_EXP 4
6723: PUSH
6724: FOR_IN
6725: IFFALSE 6786
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6727: LD_VAR 0 1
6731: PPUSH
6732: LD_EXP 36
6736: PPUSH
6737: CALL_OW 296
6741: PUSH
6742: LD_INT 10
6744: LESS
6745: PUSH
6746: LD_VAR 0 1
6750: PPUSH
6751: CALL_OW 310
6755: NOT
6756: AND
6757: IFFALSE 6775
// ComTurnUnit ( i , JMM ) else
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_EXP 36
6768: PPUSH
6769: CALL_OW 119
6773: GO 6784
// ComHold ( i ) ;
6775: LD_VAR 0 1
6779: PPUSH
6780: CALL_OW 140
// end ;
6784: GO 6724
6786: POP
6787: POP
// if IsInUnit ( JMM ) then
6788: LD_EXP 36
6792: PPUSH
6793: CALL_OW 310
6797: IFFALSE 6822
// begin ComExitVehicle ( JMM ) ;
6799: LD_EXP 36
6803: PPUSH
6804: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6808: LD_EXP 36
6812: PPUSH
6813: LD_EXP 46
6817: PPUSH
6818: CALL_OW 172
// end ; Wait ( 10 ) ;
6822: LD_INT 10
6824: PPUSH
6825: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6829: LD_EXP 36
6833: PPUSH
6834: LD_EXP 46
6838: PPUSH
6839: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6843: LD_INT 35
6845: PPUSH
6846: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6850: LD_EXP 36
6854: PPUSH
6855: LD_EXP 46
6859: PPUSH
6860: CALL_OW 296
6864: PUSH
6865: LD_INT 6
6867: LESS
6868: IFFALSE 6843
// ComTurnUnit ( JMM , Lynch ) ;
6870: LD_EXP 36
6874: PPUSH
6875: LD_EXP 46
6879: PPUSH
6880: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6884: LD_ADDR_VAR 0 1
6888: PUSH
6889: LD_EXP 46
6893: PUSH
6894: LD_EXP 47
6898: PUSH
6899: LD_EXP 48
6903: PUSH
6904: LD_EXP 49
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: FOR_IN
6916: IFFALSE 6934
// ComTurnUnit ( i , JMM ) ;
6918: LD_VAR 0 1
6922: PPUSH
6923: LD_EXP 36
6927: PPUSH
6928: CALL_OW 119
6932: GO 6915
6934: POP
6935: POP
// Wait ( 0 0$0.3 ) ;
6936: LD_INT 10
6938: PPUSH
6939: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6943: LD_EXP 36
6947: PPUSH
6948: LD_STRING D2-JMM-1
6950: PPUSH
6951: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6955: LD_EXP 46
6959: PPUSH
6960: LD_STRING D2-Sol1-1
6962: PPUSH
6963: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6967: LD_EXP 36
6971: PPUSH
6972: LD_STRING D2-JMM-2
6974: PPUSH
6975: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6979: LD_EXP 46
6983: PPUSH
6984: LD_STRING D2-Sol1-2
6986: PPUSH
6987: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6991: LD_EXP 36
6995: PPUSH
6996: LD_STRING D2-JMM-3
6998: PPUSH
6999: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7003: LD_EXP 46
7007: PPUSH
7008: LD_STRING D2-Sol1-3
7010: PPUSH
7011: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7015: LD_ADDR_VAR 0 1
7019: PUSH
7020: LD_INT 22
7022: PUSH
7023: LD_INT 8
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: PUSH
7035: FOR_IN
7036: IFFALSE 7052
// SetSide ( i , 1 ) ;
7038: LD_VAR 0 1
7042: PPUSH
7043: LD_INT 1
7045: PPUSH
7046: CALL_OW 235
7050: GO 7035
7052: POP
7053: POP
// Say ( JMM , D2-JMM-4 ) ;
7054: LD_EXP 36
7058: PPUSH
7059: LD_STRING D2-JMM-4
7061: PPUSH
7062: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7066: LD_INT 1
7068: PPUSH
7069: LD_INT 5
7071: PPUSH
7072: CALL_OW 332
// for i = 1 to points do
7076: LD_ADDR_VAR 0 1
7080: PUSH
7081: DOUBLE
7082: LD_INT 1
7084: DEC
7085: ST_TO_ADDR
7086: LD_VAR 0 2
7090: PUSH
7091: FOR_TO
7092: IFFALSE 7267
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7094: LD_VAR 0 2
7098: PUSH
7099: LD_VAR 0 1
7103: ARRAY
7104: PUSH
7105: LD_INT 1
7107: ARRAY
7108: PPUSH
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: CALL_OW 84
// if i = 1 then
7128: LD_VAR 0 1
7132: PUSH
7133: LD_INT 1
7135: EQUAL
7136: IFFALSE 7150
// Say ( Lynch , D2-Sol1-4 ) ;
7138: LD_EXP 46
7142: PPUSH
7143: LD_STRING D2-Sol1-4
7145: PPUSH
7146: CALL_OW 88
// if i = 2 then
7150: LD_VAR 0 1
7154: PUSH
7155: LD_INT 2
7157: EQUAL
7158: IFFALSE 7172
// Say ( JMM , D2-JMM-5 ) ;
7160: LD_EXP 36
7164: PPUSH
7165: LD_STRING D2-JMM-5
7167: PPUSH
7168: CALL_OW 88
// if i = 4 then
7172: LD_VAR 0 1
7176: PUSH
7177: LD_INT 4
7179: EQUAL
7180: IFFALSE 7204
// begin RevealFogArea ( 1 , troopsArea ) ;
7182: LD_INT 1
7184: PPUSH
7185: LD_INT 6
7187: PPUSH
7188: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7192: LD_EXP 46
7196: PPUSH
7197: LD_STRING D2-Sol1-5
7199: PPUSH
7200: CALL_OW 88
// end ; if i = 5 then
7204: LD_VAR 0 1
7208: PUSH
7209: LD_INT 5
7211: EQUAL
7212: IFFALSE 7226
// Say ( JMM , D2-JMM-6 ) ;
7214: LD_EXP 36
7218: PPUSH
7219: LD_STRING D2-JMM-6
7221: PPUSH
7222: CALL_OW 88
// if i = 7 then
7226: LD_VAR 0 1
7230: PUSH
7231: LD_INT 7
7233: EQUAL
7234: IFFALSE 7258
// begin RevealFogArea ( 1 , forestArea ) ;
7236: LD_INT 1
7238: PPUSH
7239: LD_INT 7
7241: PPUSH
7242: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7246: LD_EXP 46
7250: PPUSH
7251: LD_STRING D2-Sol1-6
7253: PPUSH
7254: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7258: LD_INT 46
7260: PPUSH
7261: CALL_OW 67
// end ;
7265: GO 7091
7267: POP
7268: POP
// CenterNowOnUnits ( JMM ) ;
7269: LD_EXP 36
7273: PPUSH
7274: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7278: LD_EXP 36
7282: PPUSH
7283: LD_STRING D2-JMM-7
7285: PPUSH
7286: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7290: LD_EXP 46
7294: PPUSH
7295: LD_STRING D2-Sol1-7
7297: PPUSH
7298: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7302: LD_EXP 36
7306: PPUSH
7307: LD_STRING D2-JMM-8
7309: PPUSH
7310: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7314: LD_ADDR_VAR 0 4
7318: PUSH
7319: LD_INT 22
7321: PUSH
7322: LD_INT 1
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PUSH
7329: LD_INT 30
7331: PUSH
7332: LD_INT 31
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL_OW 69
7347: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7348: LD_EXP 46
7352: PPUSH
7353: LD_VAR 0 4
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: PPUSH
7362: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7366: LD_INT 65
7368: PPUSH
7369: LD_INT 101
7371: PPUSH
7372: CALL_OW 428
7376: IFFALSE 7399
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7378: LD_INT 65
7380: PPUSH
7381: LD_INT 101
7383: PPUSH
7384: CALL_OW 428
7388: PPUSH
7389: LD_INT 75
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7399: LD_INT 66
7401: PPUSH
7402: LD_INT 103
7404: PPUSH
7405: CALL_OW 428
7409: IFFALSE 7432
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7411: LD_INT 66
7413: PPUSH
7414: LD_INT 103
7416: PPUSH
7417: CALL_OW 428
7421: PPUSH
7422: LD_INT 75
7424: PPUSH
7425: LD_INT 100
7427: PPUSH
7428: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7432: LD_ADDR_VAR 0 5
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 21
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 91
7459: PUSH
7460: LD_EXP 36
7464: PUSH
7465: LD_INT 7
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: ST_TO_ADDR
// if tmp then
7483: LD_VAR 0 5
7487: IFFALSE 7504
// ComMoveXY ( tmp , 75 , 100 ) ;
7489: LD_VAR 0 5
7493: PPUSH
7494: LD_INT 75
7496: PPUSH
7497: LD_INT 100
7499: PPUSH
7500: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_EXP 4
7513: PPUSH
7514: LD_INT 25
7516: PUSH
7517: LD_INT 1
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PPUSH
7524: CALL_OW 72
7528: PPUSH
7529: LD_EXP 36
7533: PPUSH
7534: CALL_OW 74
7538: ST_TO_ADDR
// if sol then
7539: LD_VAR 0 3
7543: IFFALSE 7603
// if GetDistUnits ( JMM , sol ) < 10 then
7545: LD_EXP 36
7549: PPUSH
7550: LD_VAR 0 3
7554: PPUSH
7555: CALL_OW 296
7559: PUSH
7560: LD_INT 10
7562: LESS
7563: IFFALSE 7603
// begin if IsInUnit ( sol ) then
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 310
7574: IFFALSE 7585
// ComExitVehicle ( sol ) ;
7576: LD_VAR 0 3
7580: PPUSH
7581: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_VAR 0 4
7594: PUSH
7595: LD_INT 2
7597: ARRAY
7598: PPUSH
7599: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7603: LD_INT 10
7605: PPUSH
7606: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7610: LD_EXP 36
7614: PPUSH
7615: LD_INT 65
7617: PPUSH
7618: LD_INT 101
7620: PPUSH
7621: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7625: LD_EXP 36
7629: PPUSH
7630: LD_INT 63
7632: PPUSH
7633: LD_INT 100
7635: PPUSH
7636: CALL_OW 178
// tmp := 0 0$0 ;
7640: LD_ADDR_VAR 0 5
7644: PUSH
7645: LD_INT 0
7647: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7648: LD_INT 35
7650: PPUSH
7651: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_VAR 0 5
7664: PUSH
7665: LD_INT 35
7667: PLUS
7668: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7669: LD_EXP 36
7673: PPUSH
7674: LD_INT 65
7676: PPUSH
7677: LD_INT 101
7679: PPUSH
7680: CALL_OW 307
7684: PUSH
7685: LD_VAR 0 5
7689: PUSH
7690: LD_INT 175
7692: GREATER
7693: OR
7694: IFFALSE 7648
// Say ( JMM , D2a-JMM-1 ) ;
7696: LD_EXP 36
7700: PPUSH
7701: LD_STRING D2a-JMM-1
7703: PPUSH
7704: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7708: LD_EXP 47
7712: PPUSH
7713: LD_INT 66
7715: PPUSH
7716: LD_INT 103
7718: PPUSH
7719: CALL_OW 111
// tmp := 0 0$0 ;
7723: LD_ADDR_VAR 0 5
7727: PUSH
7728: LD_INT 0
7730: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7731: LD_INT 35
7733: PPUSH
7734: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7738: LD_EXP 47
7742: PPUSH
7743: LD_INT 66
7745: PPUSH
7746: LD_INT 103
7748: PPUSH
7749: CALL_OW 307
7753: PUSH
7754: LD_VAR 0 5
7758: PUSH
7759: LD_INT 175
7761: GREATER
7762: OR
7763: IFFALSE 7731
// ComTurnUnit ( Walker , JMM ) ;
7765: LD_EXP 47
7769: PPUSH
7770: LD_EXP 36
7774: PPUSH
7775: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7779: LD_EXP 47
7783: PPUSH
7784: LD_STRING D2a-Sci1-1
7786: PPUSH
7787: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7791: LD_EXP 36
7795: PPUSH
7796: LD_EXP 47
7800: PPUSH
7801: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7805: LD_EXP 36
7809: PPUSH
7810: LD_STRING D2a-JMM-2
7812: PPUSH
7813: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7817: LD_EXP 47
7821: PPUSH
7822: LD_STRING D2a-Sci1-2
7824: PPUSH
7825: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7829: LD_EXP 36
7833: PPUSH
7834: LD_STRING D2a-JMM-3
7836: PPUSH
7837: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7841: LD_EXP 47
7845: PPUSH
7846: LD_STRING D2a-Sci1-3
7848: PPUSH
7849: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7853: LD_ADDR_EXP 4
7857: PUSH
7858: LD_EXP 4
7862: PUSH
7863: LD_EXP 46
7867: PUSH
7868: LD_EXP 47
7872: PUSH
7873: LD_EXP 48
7877: PUSH
7878: LD_EXP 49
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: ADD
7889: ST_TO_ADDR
// for i in jmm_units do
7890: LD_ADDR_VAR 0 1
7894: PUSH
7895: LD_EXP 4
7899: PUSH
7900: FOR_IN
7901: IFFALSE 7926
// if not IsInUnit ( i ) then
7903: LD_VAR 0 1
7907: PPUSH
7908: CALL_OW 310
7912: NOT
7913: IFFALSE 7924
// ComFree ( i ) ;
7915: LD_VAR 0 1
7919: PPUSH
7920: CALL_OW 139
7924: GO 7900
7926: POP
7927: POP
// Video ( false ) ;
7928: LD_INT 0
7930: PPUSH
7931: CALL 1185 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7935: LD_STRING MSolar1
7937: PPUSH
7938: CALL_OW 337
// jmm_on_west := true ;
7942: LD_ADDR_EXP 5
7946: PUSH
7947: LD_INT 1
7949: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7950: LD_INT 1050
7952: PPUSH
7953: CALL_OW 67
// frank_can_return := true ;
7957: LD_ADDR_EXP 12
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7965: LD_INT 6300
7967: PPUSH
7968: LD_INT 8400
7970: PPUSH
7971: CALL_OW 12
7975: PPUSH
7976: CALL_OW 67
// send_spec_patrol := true ;
7980: LD_ADDR_EXP 29
7984: PUSH
7985: LD_INT 1
7987: ST_TO_ADDR
// end ;
7988: PPOPN 5
7990: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7991: LD_INT 22
7993: PUSH
7994: LD_INT 1
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 51
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 92
8013: PUSH
8014: LD_INT 63
8016: PUSH
8017: LD_INT 100
8019: PUSH
8020: LD_INT 5
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: PUSH
8034: EMPTY
8035: LIST
8036: PPUSH
8037: CALL_OW 69
8041: PUSH
8042: LD_EXP 5
8046: NOT
8047: AND
8048: IFFALSE 8161
8050: GO 8052
8052: DISABLE
8053: LD_INT 0
8055: PPUSH
8056: PPUSH
// begin enable ;
8057: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8058: LD_ADDR_VAR 0 2
8062: PUSH
8063: LD_INT 22
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 34
8075: PUSH
8076: LD_INT 51
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 63
8088: PUSH
8089: LD_INT 100
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: PUSH
8106: EMPTY
8107: LIST
8108: PPUSH
8109: CALL_OW 69
8113: ST_TO_ADDR
// if not filter then
8114: LD_VAR 0 2
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8161
// for i in filter do
8123: LD_ADDR_VAR 0 1
8127: PUSH
8128: LD_VAR 0 2
8132: PUSH
8133: FOR_IN
8134: IFFALSE 8159
// begin SetFuel ( i , 0 ) ;
8136: LD_VAR 0 1
8140: PPUSH
8141: LD_INT 0
8143: PPUSH
8144: CALL_OW 240
// ComStop ( i ) ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 141
// end ;
8157: GO 8133
8159: POP
8160: POP
// end ;
8161: PPOPN 2
8163: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8164: LD_EXP 29
8168: IFFALSE 9161
8170: GO 8172
8172: DISABLE
8173: LD_INT 0
8175: PPUSH
8176: PPUSH
8177: PPUSH
8178: PPUSH
8179: PPUSH
8180: PPUSH
8181: PPUSH
// begin if not ru_spec_patrol then
8182: LD_EXP 53
8186: NOT
8187: IFFALSE 8191
// exit ;
8189: GO 9161
// dead1 := false ;
8191: LD_ADDR_VAR 0 1
8195: PUSH
8196: LD_INT 0
8198: ST_TO_ADDR
// dead2 := false ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_INT 0
8206: ST_TO_ADDR
// inarea1 := false ;
8207: LD_ADDR_VAR 0 3
8211: PUSH
8212: LD_INT 0
8214: ST_TO_ADDR
// inarea2 := false ;
8215: LD_ADDR_VAR 0 4
8219: PUSH
8220: LD_INT 0
8222: ST_TO_ADDR
// tmp := [ ] ;
8223: LD_ADDR_VAR 0 6
8227: PUSH
8228: EMPTY
8229: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8230: LD_EXP 53
8234: PPUSH
8235: LD_INT 75
8237: PPUSH
8238: LD_INT 101
8240: PPUSH
8241: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8245: LD_INT 35
8247: PPUSH
8248: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8252: LD_INT 1
8254: PPUSH
8255: LD_EXP 53
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: PPUSH
8264: CALL_OW 292
8268: IFFALSE 8245
// ComStop ( ru_spec_patrol ) ;
8270: LD_EXP 53
8274: PPUSH
8275: CALL_OW 141
// Wait ( 0 0$02 ) ;
8279: LD_INT 70
8281: PPUSH
8282: CALL_OW 67
// DialogueOn ;
8286: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8290: LD_EXP 53
8294: PUSH
8295: LD_INT 1
8297: ARRAY
8298: PPUSH
8299: LD_STRING D8-Rus1-1
8301: PPUSH
8302: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8306: LD_EXP 36
8310: PPUSH
8311: LD_STRING D8-JMM-1
8313: PPUSH
8314: CALL_OW 88
// DialogueOff ;
8318: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8322: LD_EXP 53
8326: PPUSH
8327: LD_INT 13
8329: PPUSH
8330: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8334: LD_INT 35
8336: PPUSH
8337: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8341: LD_VAR 0 1
8345: NOT
8346: PUSH
8347: LD_EXP 53
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: PPUSH
8356: CALL_OW 301
8360: AND
8361: IFFALSE 8371
// dead1 := true ;
8363: LD_ADDR_VAR 0 1
8367: PUSH
8368: LD_INT 1
8370: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8371: LD_VAR 0 2
8375: NOT
8376: PUSH
8377: LD_EXP 53
8381: PUSH
8382: LD_INT 2
8384: ARRAY
8385: PPUSH
8386: CALL_OW 301
8390: AND
8391: IFFALSE 8401
// dead2 := true ;
8393: LD_ADDR_VAR 0 2
8397: PUSH
8398: LD_INT 1
8400: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8401: LD_VAR 0 3
8405: NOT
8406: PUSH
8407: LD_EXP 53
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: PPUSH
8416: LD_INT 14
8418: PPUSH
8419: CALL_OW 308
8423: AND
8424: IFFALSE 8434
// inarea1 := true ;
8426: LD_ADDR_VAR 0 3
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8434: LD_VAR 0 4
8438: NOT
8439: PUSH
8440: LD_EXP 53
8444: PUSH
8445: LD_INT 2
8447: ARRAY
8448: PPUSH
8449: LD_INT 14
8451: PPUSH
8452: CALL_OW 308
8456: AND
8457: IFFALSE 8467
// inarea2 := true ;
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_INT 1
8466: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8467: LD_VAR 0 1
8471: PUSH
8472: LD_VAR 0 2
8476: AND
8477: PUSH
8478: LD_VAR 0 1
8482: PUSH
8483: LD_VAR 0 4
8487: AND
8488: OR
8489: PUSH
8490: LD_VAR 0 2
8494: PUSH
8495: LD_VAR 0 3
8499: AND
8500: OR
8501: PUSH
8502: LD_VAR 0 3
8506: PUSH
8507: LD_VAR 0 4
8511: AND
8512: OR
8513: IFFALSE 8334
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8515: LD_VAR 0 3
8519: PUSH
8520: LD_VAR 0 4
8524: AND
8525: PUSH
8526: LD_VAR 0 1
8530: PUSH
8531: LD_VAR 0 4
8535: AND
8536: OR
8537: PUSH
8538: LD_VAR 0 2
8542: PUSH
8543: LD_VAR 0 3
8547: AND
8548: OR
8549: IFFALSE 9141
// begin prepare_siege := true ;
8551: LD_ADDR_EXP 30
8555: PUSH
8556: LD_INT 1
8558: ST_TO_ADDR
// DialogueOn ;
8559: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8563: LD_VAR 0 3
8567: PUSH
8568: LD_VAR 0 4
8572: AND
8573: IFFALSE 8589
// Say ( JMM , D8b-JMM-1a ) else
8575: LD_EXP 36
8579: PPUSH
8580: LD_STRING D8b-JMM-1a
8582: PPUSH
8583: CALL_OW 88
8587: GO 8601
// Say ( JMM , D8b-JMM-1 ) ;
8589: LD_EXP 36
8593: PPUSH
8594: LD_STRING D8b-JMM-1
8596: PPUSH
8597: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8601: LD_EXP 4
8605: PPUSH
8606: LD_INT 26
8608: PUSH
8609: LD_INT 1
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: PUSH
8621: LD_EXP 37
8625: PUSH
8626: LD_EXP 38
8630: PUSH
8631: LD_EXP 47
8635: PUSH
8636: LD_EXP 50
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: DIFF
8647: PPUSH
8648: LD_STRING D8b-Sol1-1
8650: PPUSH
8651: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8655: LD_EXP 38
8659: PUSH
8660: LD_EXP 38
8664: PUSH
8665: LD_EXP 4
8669: IN
8670: AND
8671: IFFALSE 8687
// Say ( Cyrus , D8b-Cyrus-1 ) else
8673: LD_EXP 38
8677: PPUSH
8678: LD_STRING D8b-Cyrus-1
8680: PPUSH
8681: CALL_OW 88
8685: GO 8699
// Say ( JMM , D8b-JMM-1a ) ;
8687: LD_EXP 36
8691: PPUSH
8692: LD_STRING D8b-JMM-1a
8694: PPUSH
8695: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8699: LD_EXP 39
8703: PUSH
8704: LD_EXP 39
8708: PUSH
8709: LD_EXP 4
8713: IN
8714: AND
8715: IFFALSE 8729
// Say ( Lisa , D8b-Lisa-2 ) ;
8717: LD_EXP 39
8721: PPUSH
8722: LD_STRING D8b-Lisa-2
8724: PPUSH
8725: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8729: LD_EXP 37
8733: PUSH
8734: LD_EXP 37
8738: PUSH
8739: LD_EXP 4
8743: IN
8744: AND
8745: IFFALSE 8761
// Say ( Bobby , D8b-Bobby-1 ) else
8747: LD_EXP 37
8751: PPUSH
8752: LD_STRING D8b-Bobby-1
8754: PPUSH
8755: CALL_OW 88
8759: GO 8821
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8761: LD_ADDR_VAR 0 5
8765: PUSH
8766: LD_EXP 4
8770: PPUSH
8771: LD_INT 26
8773: PUSH
8774: LD_INT 1
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PPUSH
8781: CALL_OW 72
8785: PUSH
8786: LD_EXP 37
8790: PUSH
8791: LD_EXP 38
8795: PUSH
8796: LD_EXP 47
8800: PUSH
8801: LD_EXP 50
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: DIFF
8812: PPUSH
8813: LD_STRING D8b-Sol2-1
8815: PPUSH
8816: CALL 625 0 2
8820: ST_TO_ADDR
// DialogueOff ;
8821: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8825: LD_EXP 38
8829: PUSH
8830: LD_EXP 38
8834: PUSH
8835: LD_EXP 4
8839: IN
8840: AND
8841: IFFALSE 8866
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_VAR 0 6
8852: PPUSH
8853: LD_INT 1
8855: PPUSH
8856: LD_EXP 38
8860: PPUSH
8861: CALL_OW 2
8865: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8866: LD_EXP 37
8870: PUSH
8871: LD_EXP 37
8875: PUSH
8876: LD_EXP 4
8880: IN
8881: AND
8882: IFFALSE 8907
// tmp := Insert ( tmp , 1 , Bobby ) ;
8884: LD_ADDR_VAR 0 6
8888: PUSH
8889: LD_VAR 0 6
8893: PPUSH
8894: LD_INT 1
8896: PPUSH
8897: LD_EXP 37
8901: PPUSH
8902: CALL_OW 2
8906: ST_TO_ADDR
// if sol then
8907: LD_VAR 0 5
8911: IFFALSE 8936
// tmp := Insert ( tmp , 1 , sol ) ;
8913: LD_ADDR_VAR 0 6
8917: PUSH
8918: LD_VAR 0 6
8922: PPUSH
8923: LD_INT 1
8925: PPUSH
8926: LD_VAR 0 5
8930: PPUSH
8931: CALL_OW 2
8935: ST_TO_ADDR
// if tmp then
8936: LD_VAR 0 6
8940: IFFALSE 9100
// begin SetSide ( tmp , 8 ) ;
8942: LD_VAR 0 6
8946: PPUSH
8947: LD_INT 8
8949: PPUSH
8950: CALL_OW 235
// ComFree ( tmp ) ;
8954: LD_VAR 0 6
8958: PPUSH
8959: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8963: LD_VAR 0 6
8967: PPUSH
8968: LD_INT 15
8970: PPUSH
8971: CALL_OW 173
// AddComHold ( tmp ) ;
8975: LD_VAR 0 6
8979: PPUSH
8980: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8984: LD_INT 35
8986: PPUSH
8987: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8991: LD_VAR 0 6
8995: PUSH
8996: LD_INT 1
8998: ARRAY
8999: PPUSH
9000: CALL_OW 314
9004: NOT
9005: IFFALSE 9019
// ComMoveToArea ( tmp , cyrusEscape ) ;
9007: LD_VAR 0 6
9011: PPUSH
9012: LD_INT 15
9014: PPUSH
9015: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9019: LD_VAR 0 6
9023: PUSH
9024: LD_INT 1
9026: ARRAY
9027: PPUSH
9028: LD_INT 15
9030: PPUSH
9031: CALL_OW 308
9035: IFFALSE 9090
// begin RemoveUnit ( tmp [ 1 ] ) ;
9037: LD_VAR 0 6
9041: PUSH
9042: LD_INT 1
9044: ARRAY
9045: PPUSH
9046: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9050: LD_ADDR_EXP 4
9054: PUSH
9055: LD_EXP 4
9059: PUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 1
9067: ARRAY
9068: DIFF
9069: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9070: LD_ADDR_VAR 0 6
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_VAR 0 6
9084: PUSH
9085: LD_INT 1
9087: ARRAY
9088: DIFF
9089: ST_TO_ADDR
// end ; until tmp = 0 ;
9090: LD_VAR 0 6
9094: PUSH
9095: LD_INT 0
9097: EQUAL
9098: IFFALSE 8984
// end ; Wait ( 0 0$30 ) ;
9100: LD_INT 1050
9102: PPUSH
9103: CALL_OW 67
// if ru_spec_patrol then
9107: LD_EXP 53
9111: IFFALSE 9139
// for i in ru_spec_patrol do
9113: LD_ADDR_VAR 0 7
9117: PUSH
9118: LD_EXP 53
9122: PUSH
9123: FOR_IN
9124: IFFALSE 9137
// RemoveUnit ( i ) ;
9126: LD_VAR 0 7
9130: PPUSH
9131: CALL_OW 64
9135: GO 9123
9137: POP
9138: POP
// end else
9139: GO 9161
// begin prepare_siege := false ;
9141: LD_ADDR_EXP 30
9145: PUSH
9146: LD_INT 0
9148: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9149: LD_EXP 36
9153: PPUSH
9154: LD_STRING D8a-JMM-1
9156: PPUSH
9157: CALL_OW 88
// end ; end ;
9161: PPOPN 7
9163: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9164: LD_EXP 12
9168: IFFALSE 10385
9170: GO 9172
9172: DISABLE
9173: LD_INT 0
9175: PPUSH
9176: PPUSH
9177: PPUSH
// begin uc_side := 8 ;
9178: LD_ADDR_OWVAR 20
9182: PUSH
9183: LD_INT 8
9185: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9186: LD_ADDR_VAR 0 3
9190: PUSH
9191: LD_INT 59
9193: PUSH
9194: LD_INT 71
9196: PUSH
9197: EMPTY
9198: LIST
9199: LIST
9200: PUSH
9201: LD_INT 122
9203: PUSH
9204: LD_INT 117
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9215: LD_ADDR_EXP 50
9219: PUSH
9220: LD_STRING Frank
9222: PPUSH
9223: LD_INT 0
9225: PPUSH
9226: CALL 474 0 2
9230: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9231: LD_ADDR_VAR 0 1
9235: PUSH
9236: LD_INT 1
9238: PPUSH
9239: LD_INT 2
9241: PPUSH
9242: CALL_OW 12
9246: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9247: LD_EXP 50
9251: PPUSH
9252: LD_VAR 0 3
9256: PUSH
9257: LD_VAR 0 1
9261: ARRAY
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_VAR 0 3
9271: PUSH
9272: LD_VAR 0 1
9276: ARRAY
9277: PUSH
9278: LD_INT 2
9280: ARRAY
9281: PPUSH
9282: LD_INT 0
9284: PPUSH
9285: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9289: LD_EXP 50
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9301: LD_INT 35
9303: PPUSH
9304: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9308: LD_EXP 50
9312: PPUSH
9313: LD_EXP 36
9317: PPUSH
9318: CALL_OW 296
9322: PUSH
9323: LD_INT 8
9325: LESS
9326: PUSH
9327: LD_EXP 50
9331: PPUSH
9332: CALL_OW 256
9336: PUSH
9337: LD_INT 250
9339: GREATER
9340: AND
9341: IFFALSE 9301
// Video ( true ) ;
9343: LD_INT 1
9345: PPUSH
9346: CALL 1185 0 1
// CenterOnUnits ( JMM ) ;
9350: LD_EXP 36
9354: PPUSH
9355: CALL_OW 85
// if IsInUnit ( JMM ) then
9359: LD_EXP 36
9363: PPUSH
9364: CALL_OW 310
9368: IFFALSE 9379
// ComFree ( JMM ) ;
9370: LD_EXP 36
9374: PPUSH
9375: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9379: LD_EXP 36
9383: PPUSH
9384: LD_EXP 50
9388: PPUSH
9389: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9393: LD_EXP 50
9397: PPUSH
9398: LD_EXP 36
9402: PPUSH
9403: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9407: LD_EXP 36
9411: PPUSH
9412: LD_STRING D6-JMM-1
9414: PPUSH
9415: CALL_OW 88
// p := 0 ;
9419: LD_ADDR_VAR 0 2
9423: PUSH
9424: LD_INT 0
9426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9427: LD_INT 35
9429: PPUSH
9430: CALL_OW 67
// p := p + 1 ;
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_VAR 0 2
9443: PUSH
9444: LD_INT 1
9446: PLUS
9447: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9448: LD_EXP 36
9452: PPUSH
9453: LD_EXP 50
9457: PPUSH
9458: CALL_OW 296
9462: PUSH
9463: LD_INT 8
9465: LESS
9466: PUSH
9467: LD_VAR 0 2
9471: PUSH
9472: LD_INT 7
9474: GREATER
9475: OR
9476: IFFALSE 9427
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9478: LD_EXP 39
9482: PUSH
9483: LD_EXP 39
9487: PPUSH
9488: LD_EXP 50
9492: PPUSH
9493: CALL_OW 296
9497: PUSH
9498: LD_INT 20
9500: LESS
9501: AND
9502: IFFALSE 9527
// begin ComFree ( Lisa ) ;
9504: LD_EXP 39
9508: PPUSH
9509: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9513: LD_EXP 39
9517: PPUSH
9518: LD_EXP 50
9522: PPUSH
9523: CALL_OW 172
// end ; if Lynch then
9527: LD_EXP 46
9531: IFFALSE 9556
// begin ComFree ( Lynch ) ;
9533: LD_EXP 46
9537: PPUSH
9538: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9542: LD_EXP 46
9546: PPUSH
9547: LD_EXP 50
9551: PPUSH
9552: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9556: LD_EXP 36
9560: PPUSH
9561: LD_EXP 50
9565: PPUSH
9566: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9570: LD_EXP 50
9574: PPUSH
9575: LD_EXP 36
9579: PPUSH
9580: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9584: LD_EXP 50
9588: PPUSH
9589: LD_STRING D6-Frank-1
9591: PPUSH
9592: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9596: LD_INT 69
9598: PPUSH
9599: LD_INT 20
9601: PPUSH
9602: LD_INT 1
9604: PPUSH
9605: LD_INT 20
9607: NEG
9608: PPUSH
9609: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9613: LD_INT 69
9615: PPUSH
9616: LD_INT 20
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9626: LD_INT 190
9628: PPUSH
9629: LD_INT 31
9631: PPUSH
9632: LD_INT 1
9634: PPUSH
9635: LD_INT 20
9637: NEG
9638: PPUSH
9639: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9643: LD_INT 190
9645: PPUSH
9646: LD_INT 31
9648: PPUSH
9649: LD_INT 1
9651: PPUSH
9652: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9656: LD_INT 69
9658: PPUSH
9659: LD_INT 20
9661: PPUSH
9662: CALL_OW 84
// Wait ( 0 0$02 ) ;
9666: LD_INT 70
9668: PPUSH
9669: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9673: LD_EXP 36
9677: PPUSH
9678: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9682: LD_EXP 39
9686: PUSH
9687: LD_EXP 39
9691: PPUSH
9692: LD_EXP 50
9696: PPUSH
9697: CALL_OW 296
9701: PUSH
9702: LD_INT 20
9704: LESS
9705: AND
9706: PUSH
9707: LD_EXP 39
9711: PPUSH
9712: CALL_OW 302
9716: AND
9717: IFFALSE 9839
// begin ComFree ( Lisa ) ;
9719: LD_EXP 39
9723: PPUSH
9724: CALL_OW 139
// p := 0 ;
9728: LD_ADDR_VAR 0 2
9732: PUSH
9733: LD_INT 0
9735: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9736: LD_INT 35
9738: PPUSH
9739: CALL_OW 67
// p := p + 1 ;
9743: LD_ADDR_VAR 0 2
9747: PUSH
9748: LD_VAR 0 2
9752: PUSH
9753: LD_INT 1
9755: PLUS
9756: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9757: LD_EXP 39
9761: PPUSH
9762: LD_EXP 50
9766: PPUSH
9767: CALL_OW 296
9771: PUSH
9772: LD_INT 7
9774: LESS
9775: PUSH
9776: LD_VAR 0 2
9780: PUSH
9781: LD_INT 7
9783: GREATER
9784: OR
9785: IFFALSE 9736
// Say ( Lisa , D6-Lisa-1 ) ;
9787: LD_EXP 39
9791: PPUSH
9792: LD_STRING D6-Lisa-1
9794: PPUSH
9795: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9799: LD_EXP 39
9803: PPUSH
9804: LD_EXP 50
9808: PPUSH
9809: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9813: LD_EXP 50
9817: PPUSH
9818: LD_EXP 39
9822: PPUSH
9823: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9827: LD_EXP 50
9831: PPUSH
9832: LD_STRING D6-Frank-2
9834: PPUSH
9835: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9839: LD_EXP 46
9843: PUSH
9844: LD_EXP 46
9848: PPUSH
9849: LD_EXP 50
9853: PPUSH
9854: CALL_OW 296
9858: PUSH
9859: LD_INT 20
9861: LESS
9862: AND
9863: PUSH
9864: LD_EXP 46
9868: PPUSH
9869: CALL_OW 302
9873: AND
9874: IFFALSE 10055
// begin ComTurnUnit ( Lynch , JMM ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_EXP 36
9885: PPUSH
9886: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9890: LD_EXP 50
9894: PPUSH
9895: LD_EXP 36
9899: PPUSH
9900: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9904: LD_EXP 46
9908: PPUSH
9909: LD_STRING D6-Sol1-2
9911: PPUSH
9912: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9916: LD_EXP 36
9920: PPUSH
9921: LD_STRING D6-JMM-2
9923: PPUSH
9924: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9928: LD_EXP 50
9932: PPUSH
9933: LD_STRING D6-Frank-3
9935: PPUSH
9936: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9940: LD_EXP 36
9944: PPUSH
9945: LD_STRING D6-JMM-3
9947: PPUSH
9948: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9952: LD_EXP 50
9956: PPUSH
9957: LD_STRING D6-Frank-4
9959: PPUSH
9960: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9964: LD_EXP 50
9968: PPUSH
9969: LD_STRING D6-Frank-4a
9971: PPUSH
9972: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9976: LD_EXP 36
9980: PPUSH
9981: LD_STRING D6-JMM-4
9983: PPUSH
9984: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9988: LD_EXP 50
9992: PPUSH
9993: LD_STRING D6-Frank-5
9995: PPUSH
9996: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10000: LD_EXP 39
10004: PUSH
10005: LD_EXP 39
10009: PPUSH
10010: CALL_OW 302
10014: AND
10015: IFFALSE 10029
// Say ( Lisa , D6-Lisa-5 ) ;
10017: LD_EXP 39
10021: PPUSH
10022: LD_STRING D6-Lisa-5
10024: PPUSH
10025: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10029: LD_EXP 50
10033: PPUSH
10034: LD_STRING D6-Frank-6
10036: PPUSH
10037: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10041: LD_EXP 36
10045: PPUSH
10046: LD_STRING D6-JMM-6
10048: PPUSH
10049: CALL_OW 88
// end else
10053: GO 10170
// begin ComTurnUnit ( Frank , JMM ) ;
10055: LD_EXP 50
10059: PPUSH
10060: LD_EXP 36
10064: PPUSH
10065: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10069: LD_EXP 50
10073: PPUSH
10074: LD_STRING D6-Frank-4
10076: PPUSH
10077: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10081: LD_EXP 50
10085: PPUSH
10086: LD_STRING D6-Frank-4a
10088: PPUSH
10089: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10093: LD_EXP 36
10097: PPUSH
10098: LD_STRING D6-JMM-4
10100: PPUSH
10101: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10105: LD_EXP 50
10109: PPUSH
10110: LD_STRING D6-Frank-5
10112: PPUSH
10113: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10117: LD_EXP 39
10121: PUSH
10122: LD_EXP 39
10126: PPUSH
10127: CALL_OW 302
10131: AND
10132: IFFALSE 10146
// Say ( Lisa , D6-Lisa-5 ) ;
10134: LD_EXP 39
10138: PPUSH
10139: LD_STRING D6-Lisa-5
10141: PPUSH
10142: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10146: LD_EXP 50
10150: PPUSH
10151: LD_STRING D6-Frank-6
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10158: LD_EXP 36
10162: PPUSH
10163: LD_STRING D6-JMM-6
10165: PPUSH
10166: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10170: LD_STRING Q1
10172: PPUSH
10173: CALL_OW 97
10177: PUSH
10178: LD_INT 1
10180: DOUBLE
10181: EQUAL
10182: IFTRUE 10186
10184: GO 10197
10186: POP
// frank_send_to_scout := true ; 2 :
10187: LD_ADDR_EXP 14
10191: PUSH
10192: LD_INT 1
10194: ST_TO_ADDR
10195: GO 10217
10197: LD_INT 2
10199: DOUBLE
10200: EQUAL
10201: IFTRUE 10205
10203: GO 10216
10205: POP
// frank_send_to_scout := false ; end ;
10206: LD_ADDR_EXP 14
10210: PUSH
10211: LD_INT 0
10213: ST_TO_ADDR
10214: GO 10217
10216: POP
// Video ( false ) ;
10217: LD_INT 0
10219: PPUSH
10220: CALL 1185 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10224: LD_EXP 36
10228: PUSH
10229: LD_EXP 39
10233: PUSH
10234: LD_EXP 46
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL_OW 139
// if frank_send_to_scout then
10248: LD_EXP 14
10252: IFFALSE 10306
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10254: LD_EXP 50
10258: PPUSH
10259: LD_INT 15
10261: PPUSH
10262: CALL_OW 113
// wait ( 0 0$01 ) ;
10266: LD_INT 35
10268: PPUSH
10269: CALL_OW 67
// until not See ( 1 , Frank ) ;
10273: LD_INT 1
10275: PPUSH
10276: LD_EXP 50
10280: PPUSH
10281: CALL_OW 292
10285: NOT
10286: IFFALSE 10254
// wait ( 0 0$02 ) ;
10288: LD_INT 70
10290: PPUSH
10291: CALL_OW 67
// RemoveUnit ( Frank ) ;
10295: LD_EXP 50
10299: PPUSH
10300: CALL_OW 64
// end else
10304: GO 10318
// SetSide ( Frank , 1 ) ;
10306: LD_EXP 50
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 235
// send_attack_on_cornel_base := true ;
10318: LD_ADDR_EXP 25
10322: PUSH
10323: LD_INT 1
10325: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10326: LD_INT 35
10328: PPUSH
10329: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10333: LD_ADDR_EXP 28
10337: PUSH
10338: LD_EXP 28
10342: PPUSH
10343: LD_STRING -
10345: PPUSH
10346: CALL 1117 0 2
10350: ST_TO_ADDR
// if debug then
10351: LD_EXP 1
10355: IFFALSE 10367
// debug_strings := time_to_prepare ;
10357: LD_ADDR_OWVAR 48
10361: PUSH
10362: LD_EXP 28
10366: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10367: LD_EXP 28
10371: PUSH
10372: LD_INT 0
10374: EQUAL
10375: IFFALSE 10326
// cornel_prepared := true ;
10377: LD_ADDR_EXP 11
10381: PUSH
10382: LD_INT 1
10384: ST_TO_ADDR
// end ;
10385: PPOPN 3
10387: END
// every 0 0$01 trigger cornel_prepared do
10388: LD_EXP 11
10392: IFFALSE 10656
10394: GO 10396
10396: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10397: LD_EXP 43
10401: PPUSH
10402: LD_STRING D3-Corn-1
10404: PPUSH
10405: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10409: LD_STRING MOutWait
10411: PPUSH
10412: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10416: LD_INT 35
10418: PPUSH
10419: CALL_OW 67
// until cornel_counter = 0 ;
10423: LD_EXP 10
10427: PUSH
10428: LD_INT 0
10430: EQUAL
10431: IFFALSE 10416
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10433: LD_EXP 43
10437: PPUSH
10438: LD_STRING D3a-Corn-1
10440: PPUSH
10441: CALL_OW 94
// if IsOk ( Cornel ) then
10445: LD_EXP 43
10449: PPUSH
10450: CALL_OW 302
10454: IFFALSE 10468
// Say ( JMM , D3a-JMM-1 ) ;
10456: LD_EXP 36
10460: PPUSH
10461: LD_STRING D3a-JMM-1
10463: PPUSH
10464: CALL_OW 88
// end_mission_allowed := true ;
10468: LD_ADDR_EXP 20
10472: PUSH
10473: LD_INT 1
10475: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10476: LD_STRING M2
10478: PPUSH
10479: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10483: LD_INT 9
10485: PPUSH
10486: LD_INT 1
10488: PPUSH
10489: CALL_OW 424
// Wait ( 0 0$05 ) ;
10493: LD_INT 175
10495: PPUSH
10496: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10500: LD_EXP 43
10504: PPUSH
10505: LD_STRING D3a-Corn-2
10507: PPUSH
10508: CALL_OW 94
// cornel_attack := true ;
10512: LD_ADDR_EXP 9
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10520: LD_INT 105
10522: PPUSH
10523: CALL_OW 67
// AddMoreTanks ( ) ;
10527: CALL 4862 0 0
// if frank_send_to_scout then
10531: LD_EXP 14
10535: IFFALSE 10656
// begin InitHc ;
10537: CALL_OW 19
// InitUc ;
10541: CALL_OW 18
// uc_side := 8 ;
10545: LD_ADDR_OWVAR 20
10549: PUSH
10550: LD_INT 8
10552: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10553: LD_ADDR_EXP 50
10557: PUSH
10558: LD_STRING Frank
10560: PPUSH
10561: LD_INT 0
10563: PPUSH
10564: CALL 474 0 2
10568: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10569: LD_EXP 50
10573: PPUSH
10574: LD_INT 6
10576: PPUSH
10577: LD_INT 9
10579: PPUSH
10580: LD_INT 0
10582: PPUSH
10583: CALL_OW 48
// ComCrawl ( Frank ) ;
10587: LD_EXP 50
10591: PPUSH
10592: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10596: LD_INT 35
10598: PPUSH
10599: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10603: LD_EXP 36
10607: PPUSH
10608: LD_EXP 50
10612: PPUSH
10613: CALL_OW 296
10617: PUSH
10618: LD_INT 9
10620: LESS
10621: IFFALSE 10596
// SetSide ( Frank , 1 ) ;
10623: LD_EXP 50
10627: PPUSH
10628: LD_INT 1
10630: PPUSH
10631: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10635: LD_EXP 50
10639: PPUSH
10640: LD_STRING D6a-Frank-1
10642: PPUSH
10643: CALL_OW 88
// ComWalk ( Frank ) ;
10647: LD_EXP 50
10651: PPUSH
10652: CALL_OW 138
// end ; end ;
10656: END
// every 0 0$01 trigger solar_builded do
10657: LD_EXP 13
10661: IFFALSE 10765
10663: GO 10665
10665: DISABLE
// begin Wait ( 0 0$02 ) ;
10666: LD_INT 70
10668: PPUSH
10669: CALL_OW 67
// DialogueOn ;
10673: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10677: LD_EXP 36
10681: PPUSH
10682: LD_STRING D2b-JMM-1
10684: PPUSH
10685: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10689: LD_EXP 47
10693: PUSH
10694: LD_EXP 47
10698: PPUSH
10699: CALL_OW 302
10703: AND
10704: IFFALSE 10754
// begin Say ( Walker , D2b-Sci1-1 ) ;
10706: LD_EXP 47
10710: PPUSH
10711: LD_STRING D2b-Sci1-1
10713: PPUSH
10714: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10718: LD_EXP 36
10722: PPUSH
10723: LD_STRING D2b-JMM-2
10725: PPUSH
10726: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10730: LD_EXP 47
10734: PPUSH
10735: LD_STRING D2b-Sci1-2
10737: PPUSH
10738: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10742: LD_EXP 36
10746: PPUSH
10747: LD_STRING D2b-JMM-3
10749: PPUSH
10750: CALL_OW 88
// end ; DialogueOff ;
10754: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10758: LD_STRING MOutSol
10760: PPUSH
10761: CALL_OW 337
// end ;
10765: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10766: LD_EXP 13
10770: PUSH
10771: LD_EXP 36
10775: PPUSH
10776: CALL_OW 302
10780: AND
10781: PUSH
10782: LD_EXP 36
10786: PPUSH
10787: CALL 951 0 1
10791: AND
10792: PUSH
10793: LD_EXP 15
10797: NOT
10798: AND
10799: IFFALSE 10870
10801: GO 10803
10803: DISABLE
10804: LD_INT 0
10806: PPUSH
// begin jmm_in_veh := true ;
10807: LD_ADDR_EXP 15
10811: PUSH
10812: LD_INT 1
10814: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10815: LD_ADDR_VAR 0 1
10819: PUSH
10820: LD_INT 0
10822: PPUSH
10823: LD_INT 1
10825: PPUSH
10826: CALL_OW 12
10830: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10831: LD_INT 70
10833: PPUSH
10834: CALL_OW 67
// if i then
10838: LD_VAR 0 1
10842: IFFALSE 10858
// Say ( JMM , D2c-JMM-1 ) else
10844: LD_EXP 36
10848: PPUSH
10849: LD_STRING D2c-JMM-1
10851: PPUSH
10852: CALL_OW 88
10856: GO 10870
// Say ( JMM , D2c-JMM-1a ) ;
10858: LD_EXP 36
10862: PPUSH
10863: LD_STRING D2c-JMM-1a
10865: PPUSH
10866: CALL_OW 88
// end ;
10870: PPOPN 1
10872: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10873: LD_EXP 13
10877: PUSH
10878: LD_EXP 37
10882: PPUSH
10883: CALL_OW 302
10887: AND
10888: PUSH
10889: LD_EXP 37
10893: PPUSH
10894: CALL 951 0 1
10898: AND
10899: PUSH
10900: LD_EXP 16
10904: NOT
10905: AND
10906: IFFALSE 10938
10908: GO 10910
10910: DISABLE
// begin bobby_in_veh := true ;
10911: LD_ADDR_EXP 16
10915: PUSH
10916: LD_INT 1
10918: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10919: LD_INT 70
10921: PPUSH
10922: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10926: LD_EXP 37
10930: PPUSH
10931: LD_STRING D2c-Bobby-1
10933: PPUSH
10934: CALL_OW 88
10938: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10939: LD_EXP 13
10943: PUSH
10944: LD_EXP 39
10948: PPUSH
10949: CALL_OW 302
10953: AND
10954: PUSH
10955: LD_EXP 39
10959: PPUSH
10960: CALL 951 0 1
10964: AND
10965: PUSH
10966: LD_EXP 18
10970: NOT
10971: AND
10972: IFFALSE 11004
10974: GO 10976
10976: DISABLE
// begin lisa_in_veh := true ;
10977: LD_ADDR_EXP 18
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10985: LD_INT 70
10987: PPUSH
10988: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10992: LD_EXP 39
10996: PPUSH
10997: LD_STRING D2c-Lisa-1
10999: PPUSH
11000: CALL_OW 88
11004: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11005: LD_EXP 13
11009: PUSH
11010: LD_EXP 38
11014: PPUSH
11015: CALL_OW 302
11019: AND
11020: PUSH
11021: LD_EXP 38
11025: PPUSH
11026: CALL 951 0 1
11030: AND
11031: PUSH
11032: LD_EXP 17
11036: NOT
11037: AND
11038: IFFALSE 11109
11040: GO 11042
11042: DISABLE
11043: LD_INT 0
11045: PPUSH
// begin cyrus_in_veh := true ;
11046: LD_ADDR_EXP 17
11050: PUSH
11051: LD_INT 1
11053: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_INT 0
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: CALL_OW 12
11069: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11070: LD_INT 70
11072: PPUSH
11073: CALL_OW 67
// if i then
11077: LD_VAR 0 1
11081: IFFALSE 11097
// Say ( Cyrus , D2c-Cyrus-1 ) else
11083: LD_EXP 38
11087: PPUSH
11088: LD_STRING D2c-Cyrus-1
11090: PPUSH
11091: CALL_OW 88
11095: GO 11109
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11097: LD_EXP 38
11101: PPUSH
11102: LD_STRING D2c-Cyrus-1a
11104: PPUSH
11105: CALL_OW 88
// end ;
11109: PPOPN 1
11111: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11112: LD_EXP 43
11116: PPUSH
11117: LD_INT 16
11119: PPUSH
11120: CALL_OW 308
11124: IFFALSE 11405
11126: GO 11128
11128: DISABLE
11129: LD_INT 0
11131: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11132: LD_INT 3
11134: PPUSH
11135: LD_EXP 43
11139: PPUSH
11140: CALL_OW 471
// send_attack_on_cornel := true ;
11144: LD_ADDR_EXP 31
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// if ru_vehicles then
11152: LD_EXP 55
11156: IFFALSE 11190
// for i in ru_vehicles do
11158: LD_ADDR_VAR 0 1
11162: PUSH
11163: LD_EXP 55
11167: PUSH
11168: FOR_IN
11169: IFFALSE 11188
// ComAgressiveMove ( i , 215 , 69 ) ;
11171: LD_VAR 0 1
11175: PPUSH
11176: LD_INT 215
11178: PPUSH
11179: LD_INT 69
11181: PPUSH
11182: CALL_OW 114
11186: GO 11168
11188: POP
11189: POP
// if ru_patrol then
11190: LD_EXP 52
11194: IFFALSE 11228
// for i in ru_patrol do
11196: LD_ADDR_VAR 0 1
11200: PUSH
11201: LD_EXP 52
11205: PUSH
11206: FOR_IN
11207: IFFALSE 11226
// ComAgressiveMove ( i , 215 , 69 ) ;
11209: LD_VAR 0 1
11213: PPUSH
11214: LD_INT 215
11216: PPUSH
11217: LD_INT 69
11219: PPUSH
11220: CALL_OW 114
11224: GO 11206
11226: POP
11227: POP
// if frank_send_to_scout then
11228: LD_EXP 14
11232: IFFALSE 11246
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11234: LD_EXP 50
11238: PPUSH
11239: LD_STRING D3b-Frank-1
11241: PPUSH
11242: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11246: LD_INT 105
11248: PPUSH
11249: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11253: LD_EXP 43
11257: PPUSH
11258: LD_STRING D4-Corn-1
11260: PPUSH
11261: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11265: LD_INT 35
11267: PPUSH
11268: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11272: LD_INT 22
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 3
11294: PUSH
11295: LD_INT 24
11297: PUSH
11298: LD_INT 1000
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: LIST
11313: PPUSH
11314: CALL_OW 69
11318: PUSH
11319: LD_INT 6
11321: LESS
11322: IFFALSE 11265
// if Cornel then
11324: LD_EXP 43
11328: IFFALSE 11368
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11330: LD_EXP 43
11334: PPUSH
11335: LD_STRING D5-Corn-1
11337: PPUSH
11338: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11342: LD_EXP 43
11346: PPUSH
11347: LD_EXP 2
11351: PUSH
11352: LD_STRING Cornel
11354: STR
11355: PPUSH
11356: CALL_OW 38
// cornel_saved := true ;
11360: LD_ADDR_EXP 26
11364: PUSH
11365: LD_INT 1
11367: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11368: LD_INT 4
11370: PPUSH
11371: LD_INT 8
11373: PPUSH
11374: CALL_OW 343
// Wait ( 0 0$01 ) ;
11378: LD_INT 35
11380: PPUSH
11381: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11385: LD_INT 3
11387: PPUSH
11388: LD_EXP 43
11392: PPUSH
11393: CALL_OW 472
// send_attack_on_cornel := false ;
11397: LD_ADDR_EXP 31
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// end ;
11405: PPOPN 1
11407: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11408: LD_INT 9
11410: PPUSH
11411: LD_INT 22
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PPUSH
11421: CALL_OW 70
11425: PUSH
11426: LD_EXP 32
11430: OR
11431: IFFALSE 11628
11433: GO 11435
11435: DISABLE
11436: LD_INT 0
11438: PPUSH
11439: PPUSH
// begin enable ;
11440: ENABLE
// if not jmm_on_west then
11441: LD_EXP 5
11445: NOT
11446: IFFALSE 11457
// begin YouLost ( 4 ) ;
11448: LD_STRING 4
11450: PPUSH
11451: CALL_OW 104
// exit ;
11455: GO 11628
// end ; if not game_end then
11457: LD_EXP 32
11461: NOT
11462: IFFALSE 11472
// game_end := true ;
11464: LD_ADDR_EXP 32
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11472: LD_ADDR_VAR 0 2
11476: PUSH
11477: LD_INT 9
11479: PPUSH
11480: LD_INT 22
11482: PUSH
11483: LD_INT 1
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PPUSH
11490: CALL_OW 70
11494: ST_TO_ADDR
// if not filter then
11495: LD_VAR 0 2
11499: NOT
11500: IFFALSE 11504
// exit ;
11502: GO 11628
// for i in filter do
11504: LD_ADDR_VAR 0 1
11508: PUSH
11509: LD_VAR 0 2
11513: PUSH
11514: FOR_IN
11515: IFFALSE 11626
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11517: LD_VAR 0 1
11521: PPUSH
11522: CALL_OW 302
11526: PUSH
11527: LD_VAR 0 1
11531: PPUSH
11532: CALL_OW 247
11536: PUSH
11537: LD_INT 2
11539: EQUAL
11540: AND
11541: PUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 248
11551: PUSH
11552: LD_INT 1
11554: EQUAL
11555: AND
11556: IFFALSE 11589
// begin veh_on_meta := true ;
11558: LD_ADDR_EXP 27
11562: PUSH
11563: LD_INT 1
11565: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: CALL_OW 311
11575: PPUSH
11576: CALL 11631 0 1
// RemoveUnit ( i ) ;
11580: LD_VAR 0 1
11584: PPUSH
11585: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11589: LD_VAR 0 1
11593: PPUSH
11594: CALL_OW 302
11598: PUSH
11599: LD_VAR 0 1
11603: PPUSH
11604: CALL_OW 247
11608: PUSH
11609: LD_INT 1
11611: EQUAL
11612: AND
11613: IFFALSE 11624
// Save ( i ) ;
11615: LD_VAR 0 1
11619: PPUSH
11620: CALL 11631 0 1
// end ;
11624: GO 11514
11626: POP
11627: POP
// end ;
11628: PPOPN 2
11630: END
// export function Save ( i ) ; begin
11631: LD_INT 0
11633: PPUSH
// save_counter := save_counter + 1 ;
11634: LD_ADDR_EXP 35
11638: PUSH
11639: LD_EXP 35
11643: PUSH
11644: LD_INT 1
11646: PLUS
11647: ST_TO_ADDR
// if i = JMM then
11648: LD_VAR 0 1
11652: PUSH
11653: LD_EXP 36
11657: EQUAL
11658: IFFALSE 11780
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11660: LD_EXP 23
11664: PUSH
11665: LD_INT 22
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: LD_INT 21
11677: PUSH
11678: LD_INT 1
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: PUSH
11694: LD_INT 1
11696: GREATER
11697: AND
11698: IFFALSE 11755
// begin show_query := false ;
11700: LD_ADDR_EXP 23
11704: PUSH
11705: LD_INT 0
11707: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11708: LD_STRING Q2
11710: PPUSH
11711: CALL_OW 97
11715: PUSH
11716: LD_INT 1
11718: DOUBLE
11719: EQUAL
11720: IFTRUE 11724
11722: GO 11735
11724: POP
// wait_for_them := true ; 2 :
11725: LD_ADDR_EXP 24
11729: PUSH
11730: LD_INT 1
11732: ST_TO_ADDR
11733: GO 11755
11735: LD_INT 2
11737: DOUBLE
11738: EQUAL
11739: IFTRUE 11743
11741: GO 11754
11743: POP
// wait_for_them := false ; end ;
11744: LD_ADDR_EXP 24
11748: PUSH
11749: LD_INT 0
11751: ST_TO_ADDR
11752: GO 11755
11754: POP
// end ; save_group := save_group ^ JMM ;
11755: LD_ADDR_EXP 22
11759: PUSH
11760: LD_EXP 22
11764: PUSH
11765: LD_EXP 36
11769: ADD
11770: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11771: LD_EXP 36
11775: PPUSH
11776: CALL_OW 64
// end ; if i = Lisa then
11780: LD_VAR 0 1
11784: PUSH
11785: LD_EXP 39
11789: EQUAL
11790: IFFALSE 11817
// begin save_group := save_group ^ Lisa ;
11792: LD_ADDR_EXP 22
11796: PUSH
11797: LD_EXP 22
11801: PUSH
11802: LD_EXP 39
11806: ADD
11807: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11808: LD_EXP 39
11812: PPUSH
11813: CALL_OW 64
// end ; if i = Bobby then
11817: LD_VAR 0 1
11821: PUSH
11822: LD_EXP 37
11826: EQUAL
11827: IFFALSE 11854
// begin save_group := save_group ^ Bobby ;
11829: LD_ADDR_EXP 22
11833: PUSH
11834: LD_EXP 22
11838: PUSH
11839: LD_EXP 37
11843: ADD
11844: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11845: LD_EXP 37
11849: PPUSH
11850: CALL_OW 64
// end ; if i = Cyrus then
11854: LD_VAR 0 1
11858: PUSH
11859: LD_EXP 38
11863: EQUAL
11864: IFFALSE 11891
// begin save_group := save_group ^ Cyrus ;
11866: LD_ADDR_EXP 22
11870: PUSH
11871: LD_EXP 22
11875: PUSH
11876: LD_EXP 38
11880: ADD
11881: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11882: LD_EXP 38
11886: PPUSH
11887: CALL_OW 64
// end ; if i = Khatam then
11891: LD_VAR 0 1
11895: PUSH
11896: LD_EXP 40
11900: EQUAL
11901: IFFALSE 11928
// begin save_group := save_group ^ Khatam ;
11903: LD_ADDR_EXP 22
11907: PUSH
11908: LD_EXP 22
11912: PUSH
11913: LD_EXP 40
11917: ADD
11918: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11919: LD_EXP 40
11923: PPUSH
11924: CALL_OW 64
// end ; if i = Frank then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_EXP 50
11937: EQUAL
11938: IFFALSE 11965
// begin save_group := save_group ^ Frank ;
11940: LD_ADDR_EXP 22
11944: PUSH
11945: LD_EXP 22
11949: PUSH
11950: LD_EXP 50
11954: ADD
11955: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11956: LD_EXP 50
11960: PPUSH
11961: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11965: LD_VAR 0 1
11969: PPUSH
11970: CALL_OW 302
11974: PUSH
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 247
11984: PUSH
11985: LD_INT 1
11987: EQUAL
11988: AND
11989: PUSH
11990: LD_VAR 0 1
11994: PUSH
11995: LD_EXP 22
11999: IN
12000: NOT
12001: AND
12002: IFFALSE 12029
// begin save_others := save_others ^ i ;
12004: LD_ADDR_EXP 21
12008: PUSH
12009: LD_EXP 21
12013: PUSH
12014: LD_VAR 0 1
12018: ADD
12019: ST_TO_ADDR
// RemoveUnit ( i ) ;
12020: LD_VAR 0 1
12024: PPUSH
12025: CALL_OW 64
// end ; end ;
12029: LD_VAR 0 2
12033: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12034: LD_EXP 23
12038: NOT
12039: PUSH
12040: LD_EXP 24
12044: NOT
12045: AND
12046: PUSH
12047: LD_INT 22
12049: PUSH
12050: LD_INT 1
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PPUSH
12071: CALL_OW 69
12075: PUSH
12076: LD_INT 0
12078: EQUAL
12079: OR
12080: IFFALSE 12089
12082: GO 12084
12084: DISABLE
// EndMission ;
12085: CALL 12090 0 0
12089: END
// export function EndMission ; var i ; begin
12090: LD_INT 0
12092: PPUSH
12093: PPUSH
// Wait ( 0 0$02 ) ;
12094: LD_INT 70
12096: PPUSH
12097: CALL_OW 67
// if solar_builded then
12101: LD_EXP 13
12105: IFFALSE 12119
// AddMedal ( Solar1 , 1 ) else
12107: LD_STRING Solar1
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: CALL_OW 101
12117: GO 12130
// AddMedal ( Solar1 , - 1 ) ;
12119: LD_STRING Solar1
12121: PPUSH
12122: LD_INT 1
12124: NEG
12125: PPUSH
12126: CALL_OW 101
// if veh_on_meta then
12130: LD_EXP 27
12134: IFFALSE 12148
// AddMedal ( Solar2 , 1 ) else
12136: LD_STRING Solar2
12138: PPUSH
12139: LD_INT 1
12141: PPUSH
12142: CALL_OW 101
12146: GO 12178
// if solar_builded then
12148: LD_EXP 13
12152: IFFALSE 12167
// AddMedal ( Solar2 , - 1 ) else
12154: LD_STRING Solar2
12156: PPUSH
12157: LD_INT 1
12159: NEG
12160: PPUSH
12161: CALL_OW 101
12165: GO 12178
// AddMedal ( Solar2 , - 2 ) ;
12167: LD_STRING Solar2
12169: PPUSH
12170: LD_INT 2
12172: NEG
12173: PPUSH
12174: CALL_OW 101
// if lose_counter = 0 then
12178: LD_EXP 33
12182: PUSH
12183: LD_INT 0
12185: EQUAL
12186: IFFALSE 12200
// AddMedal ( No , 1 ) else
12188: LD_STRING No
12190: PPUSH
12191: LD_INT 1
12193: PPUSH
12194: CALL_OW 101
12198: GO 12244
// if lose_counter > 0 and lose_counter < 4 then
12200: LD_EXP 33
12204: PUSH
12205: LD_INT 0
12207: GREATER
12208: PUSH
12209: LD_EXP 33
12213: PUSH
12214: LD_INT 4
12216: LESS
12217: AND
12218: IFFALSE 12233
// AddMedal ( No , - 1 ) else
12220: LD_STRING No
12222: PPUSH
12223: LD_INT 1
12225: NEG
12226: PPUSH
12227: CALL_OW 101
12231: GO 12244
// AddMedal ( UpTo4 , - 1 ) ;
12233: LD_STRING UpTo4
12235: PPUSH
12236: LD_INT 1
12238: NEG
12239: PPUSH
12240: CALL_OW 101
// GiveMedals ( MAIN ) ;
12244: LD_STRING MAIN
12246: PPUSH
12247: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12251: LD_EXP 51
12255: PPUSH
12256: CALL_OW 301
12260: IFFALSE 12316
// begin stop_talking := true ;
12262: LD_ADDR_OWVAR 56
12266: PUSH
12267: LD_INT 1
12269: ST_TO_ADDR
// for i in save_group ^ save_others do
12270: LD_ADDR_VAR 0 2
12274: PUSH
12275: LD_EXP 22
12279: PUSH
12280: LD_EXP 21
12284: ADD
12285: PUSH
12286: FOR_IN
12287: IFFALSE 12306
// AddExperience ( i , skill_combat , 1500 ) ;
12289: LD_VAR 0 2
12293: PPUSH
12294: LD_INT 1
12296: PPUSH
12297: LD_INT 1500
12299: PPUSH
12300: CALL_OW 492
12304: GO 12286
12306: POP
12307: POP
// stop_talking := false ;
12308: LD_ADDR_OWVAR 56
12312: PUSH
12313: LD_INT 0
12315: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12316: LD_EXP 22
12320: PUSH
12321: LD_EXP 21
12325: ADD
12326: PPUSH
12327: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12331: LD_EXP 36
12335: PPUSH
12336: LD_EXP 2
12340: PUSH
12341: LD_STRING JMM
12343: STR
12344: PPUSH
12345: CALL_OW 38
// if Bobby in save_group then
12349: LD_EXP 37
12353: PUSH
12354: LD_EXP 22
12358: IN
12359: IFFALSE 12379
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12361: LD_EXP 37
12365: PPUSH
12366: LD_EXP 2
12370: PUSH
12371: LD_STRING Bobby
12373: STR
12374: PPUSH
12375: CALL_OW 38
// if Cyrus in save_group then
12379: LD_EXP 38
12383: PUSH
12384: LD_EXP 22
12388: IN
12389: IFFALSE 12409
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12391: LD_EXP 38
12395: PPUSH
12396: LD_EXP 2
12400: PUSH
12401: LD_STRING Cyrus
12403: STR
12404: PPUSH
12405: CALL_OW 38
// if Lisa in save_group then
12409: LD_EXP 39
12413: PUSH
12414: LD_EXP 22
12418: IN
12419: IFFALSE 12439
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12421: LD_EXP 39
12425: PPUSH
12426: LD_EXP 2
12430: PUSH
12431: LD_STRING Lisa
12433: STR
12434: PPUSH
12435: CALL_OW 38
// if Frank in save_group then
12439: LD_EXP 50
12443: PUSH
12444: LD_EXP 22
12448: IN
12449: IFFALSE 12469
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12451: LD_EXP 50
12455: PPUSH
12456: LD_EXP 2
12460: PUSH
12461: LD_STRING Frank
12463: STR
12464: PPUSH
12465: CALL_OW 38
// if Khatam in save_group then
12469: LD_EXP 40
12473: PUSH
12474: LD_EXP 22
12478: IN
12479: IFFALSE 12499
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12481: LD_EXP 40
12485: PPUSH
12486: LD_EXP 2
12490: PUSH
12491: LD_STRING Khatam
12493: STR
12494: PPUSH
12495: CALL_OW 38
// if save_others then
12499: LD_EXP 21
12503: IFFALSE 12517
// SaveCharacters ( save_others , 03_others ) ;
12505: LD_EXP 21
12509: PPUSH
12510: LD_STRING 03_others
12512: PPUSH
12513: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12517: LD_EXP 44
12521: PUSH
12522: LD_EXP 44
12526: PPUSH
12527: CALL_OW 302
12531: AND
12532: PUSH
12533: LD_EXP 26
12537: AND
12538: IFFALSE 12550
// begin ResetFog ;
12540: CALL_OW 335
// DisplayEndingScene ;
12544: CALL 12572 0 0
// end else
12548: GO 12563
// DeleteCharacters ( mission_prefix & Cornel ) ;
12550: LD_EXP 2
12554: PUSH
12555: LD_STRING Cornel
12557: STR
12558: PPUSH
12559: CALL_OW 40
// YouWin ;
12563: CALL_OW 103
// end ;
12567: LD_VAR 0 1
12571: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
12576: PPUSH
12577: PPUSH
12578: PPUSH
12579: PPUSH
// InGameOn ;
12580: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12584: LD_INT 208
12586: PPUSH
12587: LD_INT 62
12589: PPUSH
12590: LD_INT 1
12592: PPUSH
12593: LD_INT 10
12595: NEG
12596: PPUSH
12597: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12601: LD_INT 208
12603: PPUSH
12604: LD_INT 62
12606: PPUSH
12607: LD_INT 1
12609: PPUSH
12610: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 22
12621: PUSH
12622: LD_INT 3
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 2
12631: PUSH
12632: LD_INT 21
12634: PUSH
12635: LD_INT 2
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 21
12644: PUSH
12645: LD_INT 1
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: LIST
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PPUSH
12661: CALL_OW 69
12665: ST_TO_ADDR
// if filter then
12666: LD_VAR 0 3
12670: IFFALSE 12698
// for i in filter do
12672: LD_ADDR_VAR 0 2
12676: PUSH
12677: LD_VAR 0 3
12681: PUSH
12682: FOR_IN
12683: IFFALSE 12696
// RemoveUnit ( i ) ;
12685: LD_VAR 0 2
12689: PPUSH
12690: CALL_OW 64
12694: GO 12682
12696: POP
12697: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12698: LD_ADDR_VAR 0 3
12702: PUSH
12703: LD_INT 22
12705: PUSH
12706: LD_INT 4
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: LD_INT 21
12715: PUSH
12716: LD_INT 1
12718: PUSH
12719: EMPTY
12720: LIST
12721: LIST
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PPUSH
12727: CALL_OW 69
12731: ST_TO_ADDR
// if filter then
12732: LD_VAR 0 3
12736: IFFALSE 12767
// for i in filter do
12738: LD_ADDR_VAR 0 2
12742: PUSH
12743: LD_VAR 0 3
12747: PUSH
12748: FOR_IN
12749: IFFALSE 12765
// SetLives ( i , 0 ) ;
12751: LD_VAR 0 2
12755: PPUSH
12756: LD_INT 0
12758: PPUSH
12759: CALL_OW 234
12763: GO 12748
12765: POP
12766: POP
// uc_side := 4 ;
12767: LD_ADDR_OWVAR 20
12771: PUSH
12772: LD_INT 4
12774: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12775: LD_ADDR_VAR 0 4
12779: PUSH
12780: LD_STRING Cornell
12782: PPUSH
12783: LD_INT 0
12785: PPUSH
12786: CALL 474 0 2
12790: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12791: LD_VAR 0 4
12795: PPUSH
12796: LD_INT 208
12798: PPUSH
12799: LD_INT 62
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12809: LD_VAR 0 4
12813: PPUSH
12814: LD_INT 100
12816: PPUSH
12817: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12821: LD_INT 3
12823: PPUSH
12824: LD_VAR 0 4
12828: PPUSH
12829: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12833: LD_INT 4
12835: PPUSH
12836: LD_INT 3
12838: PPUSH
12839: LD_INT 1
12841: PPUSH
12842: LD_INT 1
12844: PPUSH
12845: CALL_OW 80
// uc_side := 3 ;
12849: LD_ADDR_OWVAR 20
12853: PUSH
12854: LD_INT 3
12856: ST_TO_ADDR
// uc_nation := 3 ;
12857: LD_ADDR_OWVAR 21
12861: PUSH
12862: LD_INT 3
12864: ST_TO_ADDR
// InitHc ;
12865: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12869: LD_ADDR_VAR 0 5
12873: PUSH
12874: LD_STRING Mikhail
12876: PPUSH
12877: LD_INT 0
12879: PPUSH
12880: CALL 474 0 2
12884: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12885: LD_INT 1
12887: PPUSH
12888: LD_INT 1
12890: PPUSH
12891: LD_INT 0
12893: PPUSH
12894: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12898: LD_ADDR_VAR 0 6
12902: PUSH
12903: LD_VAR 0 6
12907: PUSH
12908: CALL_OW 44
12912: ADD
12913: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12914: LD_ADDR_VAR 0 6
12918: PUSH
12919: LD_VAR 0 6
12923: PUSH
12924: CALL_OW 44
12928: ADD
12929: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12930: LD_INT 2
12932: PPUSH
12933: LD_INT 4
12935: PPUSH
12936: LD_INT 0
12938: PPUSH
12939: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12943: LD_ADDR_VAR 0 6
12947: PUSH
12948: LD_VAR 0 6
12952: PUSH
12953: CALL_OW 44
12957: ADD
12958: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12959: LD_VAR 0 5
12963: PPUSH
12964: LD_INT 17
12966: PPUSH
12967: LD_INT 0
12969: PPUSH
12970: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12974: LD_VAR 0 5
12978: PPUSH
12979: LD_INT 210
12981: PPUSH
12982: LD_INT 63
12984: PPUSH
12985: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12989: LD_VAR 0 5
12993: PPUSH
12994: LD_INT 208
12996: PPUSH
12997: LD_INT 62
12999: PPUSH
13000: CALL_OW 178
// for i in fake_russians do
13004: LD_ADDR_VAR 0 2
13008: PUSH
13009: LD_VAR 0 6
13013: PUSH
13014: FOR_IN
13015: IFFALSE 13093
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13017: LD_VAR 0 2
13021: PPUSH
13022: LD_INT 17
13024: PPUSH
13025: LD_INT 0
13027: PPUSH
13028: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13032: LD_VAR 0 2
13036: PPUSH
13037: LD_INT 215
13039: PPUSH
13040: LD_INT 67
13042: PPUSH
13043: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13047: LD_VAR 0 2
13051: PPUSH
13052: LD_INT 208
13054: PPUSH
13055: LD_INT 62
13057: PPUSH
13058: CALL_OW 178
// if GetClass ( i ) = 4 then
13062: LD_VAR 0 2
13066: PPUSH
13067: CALL_OW 257
13071: PUSH
13072: LD_INT 4
13074: EQUAL
13075: IFFALSE 13091
// ComHeal ( i , fake_cornel ) ;
13077: LD_VAR 0 2
13081: PPUSH
13082: LD_VAR 0 4
13086: PPUSH
13087: CALL_OW 128
// end ;
13091: GO 13014
13093: POP
13094: POP
// Wait ( 0 0$01 ) ;
13095: LD_INT 35
13097: PPUSH
13098: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13102: LD_INT 208
13104: PPUSH
13105: LD_INT 62
13107: PPUSH
13108: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13112: LD_INT 208
13114: PPUSH
13115: LD_INT 62
13117: PPUSH
13118: LD_INT 1
13120: PPUSH
13121: LD_INT 10
13123: NEG
13124: PPUSH
13125: CALL_OW 330
// Wait ( 0 0$15 ) ;
13129: LD_INT 525
13131: PPUSH
13132: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13136: LD_INT 208
13138: PPUSH
13139: LD_INT 62
13141: PPUSH
13142: LD_INT 1
13144: PPUSH
13145: CALL_OW 331
// ResetFog ;
13149: CALL_OW 335
// InGameOff ;
13153: CALL_OW 9
// end ;
13157: LD_VAR 0 1
13161: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13162: LD_INT 10
13164: PPUSH
13165: LD_INT 22
13167: PUSH
13168: LD_INT 1
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: PPUSH
13175: CALL_OW 70
13179: PUSH
13180: LD_EXP 43
13184: PPUSH
13185: CALL_OW 302
13189: AND
13190: PUSH
13191: LD_INT 22
13193: PUSH
13194: LD_INT 1
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: PPUSH
13201: CALL_OW 69
13205: PPUSH
13206: LD_EXP 43
13210: PPUSH
13211: CALL_OW 74
13215: PPUSH
13216: LD_EXP 43
13220: PPUSH
13221: CALL_OW 296
13225: PUSH
13226: LD_INT 30
13228: LESS
13229: OR
13230: IFFALSE 13281
13232: GO 13234
13234: DISABLE
// begin enable ;
13235: ENABLE
// powell_warn := powell_warn + 1 ;
13236: LD_ADDR_EXP 34
13240: PUSH
13241: LD_EXP 34
13245: PUSH
13246: LD_INT 1
13248: PLUS
13249: ST_TO_ADDR
// if powell_warn = 3 then
13250: LD_EXP 34
13254: PUSH
13255: LD_INT 3
13257: EQUAL
13258: IFFALSE 13269
// begin YouLost ( 5 ) ;
13260: LD_STRING 5
13262: PPUSH
13263: CALL_OW 104
// exit ;
13267: GO 13281
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13269: LD_EXP 45
13273: PPUSH
13274: LD_STRING DWarn-Pow-1
13276: PPUSH
13277: CALL_OW 94
// end ; end_of_file
13281: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13282: LD_EXP 8
13286: IFFALSE 15123
13288: GO 13290
13290: DISABLE
13291: LD_INT 0
13293: PPUSH
13294: PPUSH
13295: PPUSH
13296: PPUSH
13297: PPUSH
13298: PPUSH
13299: PPUSH
13300: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13301: LD_EXP 43
13305: PUSH
13306: LD_EXP 44
13310: ADD
13311: PUSH
13312: LD_EXP 6
13316: ADD
13317: PPUSH
13318: LD_INT 250
13320: PPUSH
13321: LD_INT 120
13323: PPUSH
13324: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13328: LD_ADDR_VAR 0 2
13332: PUSH
13333: LD_EXP 6
13337: PPUSH
13338: LD_INT 25
13340: PUSH
13341: LD_INT 2
13343: PUSH
13344: EMPTY
13345: LIST
13346: LIST
13347: PPUSH
13348: CALL_OW 72
13352: PUSH
13353: LD_EXP 44
13357: DIFF
13358: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13359: LD_ADDR_VAR 0 3
13363: PUSH
13364: LD_EXP 6
13368: PPUSH
13369: LD_INT 21
13371: PUSH
13372: LD_INT 1
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 72
13383: PUSH
13384: LD_VAR 0 2
13388: DIFF
13389: ST_TO_ADDR
// if not has_eng then
13390: LD_VAR 0 2
13394: NOT
13395: IFFALSE 13478
// begin uc_side := 4 ;
13397: LD_ADDR_OWVAR 20
13401: PUSH
13402: LD_INT 4
13404: ST_TO_ADDR
// uc_nation := 1 ;
13405: LD_ADDR_OWVAR 21
13409: PUSH
13410: LD_INT 1
13412: ST_TO_ADDR
// bc_type := b_depot ;
13413: LD_ADDR_OWVAR 42
13417: PUSH
13418: LD_INT 0
13420: ST_TO_ADDR
// bc_level := 2 ;
13421: LD_ADDR_OWVAR 43
13425: PUSH
13426: LD_INT 2
13428: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13429: LD_ADDR_VAR 0 4
13433: PUSH
13434: LD_INT 264
13436: PPUSH
13437: LD_INT 120
13439: PPUSH
13440: LD_INT 4
13442: PPUSH
13443: CALL_OW 47
13447: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13448: LD_INT 264
13450: PPUSH
13451: LD_INT 120
13453: PPUSH
13454: LD_INT 4
13456: PPUSH
13457: LD_INT 10
13459: NEG
13460: PPUSH
13461: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13465: LD_INT 264
13467: PPUSH
13468: LD_INT 120
13470: PPUSH
13471: LD_INT 4
13473: PPUSH
13474: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13478: LD_INT 35
13480: PPUSH
13481: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13485: LD_EXP 43
13489: PPUSH
13490: LD_INT 10
13492: PPUSH
13493: CALL_OW 308
13497: PUSH
13498: LD_EXP 43
13502: PPUSH
13503: CALL_OW 310
13507: PPUSH
13508: LD_INT 10
13510: PPUSH
13511: CALL_OW 308
13515: OR
13516: IFFALSE 13478
// if has_eng and not dep then
13518: LD_VAR 0 2
13522: PUSH
13523: LD_VAR 0 4
13527: NOT
13528: AND
13529: IFFALSE 13679
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13531: LD_VAR 0 2
13535: PPUSH
13536: LD_INT 0
13538: PPUSH
13539: LD_INT 264
13541: PPUSH
13542: LD_INT 120
13544: PPUSH
13545: LD_INT 4
13547: PPUSH
13548: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13552: LD_INT 35
13554: PPUSH
13555: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13559: LD_INT 22
13561: PUSH
13562: LD_INT 4
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: LD_INT 30
13571: PUSH
13572: LD_INT 0
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PPUSH
13583: CALL_OW 69
13587: IFFALSE 13552
// ComMoveXY ( filter , 264 , 120 ) ;
13589: LD_VAR 0 3
13593: PPUSH
13594: LD_INT 264
13596: PPUSH
13597: LD_INT 120
13599: PPUSH
13600: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13604: LD_INT 35
13606: PPUSH
13607: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13611: LD_INT 22
13613: PUSH
13614: LD_INT 4
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 30
13623: PUSH
13624: LD_INT 0
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 3
13633: PUSH
13634: LD_INT 57
13636: PUSH
13637: EMPTY
13638: LIST
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PUSH
13644: EMPTY
13645: LIST
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: IFFALSE 13604
// ComMoveXY ( filter , 247 , 113 ) ;
13655: LD_VAR 0 3
13659: PPUSH
13660: LD_INT 247
13662: PPUSH
13663: LD_INT 113
13665: PPUSH
13666: CALL_OW 111
// Wait ( 0 0$2 ) ;
13670: LD_INT 70
13672: PPUSH
13673: CALL_OW 67
// end else
13677: GO 13691
// begin SetSide ( dep , 4 ) ;
13679: LD_VAR 0 4
13683: PPUSH
13684: LD_INT 4
13686: PPUSH
13687: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13691: LD_ADDR_VAR 0 4
13695: PUSH
13696: LD_INT 22
13698: PUSH
13699: LD_INT 4
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: PUSH
13706: LD_INT 30
13708: PUSH
13709: LD_INT 0
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PPUSH
13720: CALL_OW 69
13724: PUSH
13725: LD_INT 1
13727: ARRAY
13728: ST_TO_ADDR
// if not has_eng then
13729: LD_VAR 0 2
13733: NOT
13734: IFFALSE 13821
// for i = 1 to 2 do
13736: LD_ADDR_VAR 0 1
13740: PUSH
13741: DOUBLE
13742: LD_INT 1
13744: DEC
13745: ST_TO_ADDR
13746: LD_INT 2
13748: PUSH
13749: FOR_TO
13750: IFFALSE 13819
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13752: LD_VAR 0 3
13756: PUSH
13757: LD_INT 1
13759: ARRAY
13760: PPUSH
13761: LD_VAR 0 4
13765: PPUSH
13766: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13770: LD_VAR 0 3
13774: PUSH
13775: LD_INT 1
13777: ARRAY
13778: PPUSH
13779: LD_INT 2
13781: PPUSH
13782: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13786: LD_VAR 0 3
13790: PUSH
13791: LD_INT 1
13793: ARRAY
13794: PPUSH
13795: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
13799: LD_ADDR_VAR 0 3
13803: PUSH
13804: LD_VAR 0 3
13808: PPUSH
13809: LD_INT 1
13811: PPUSH
13812: CALL_OW 3
13816: ST_TO_ADDR
// end ;
13817: GO 13749
13819: POP
13820: POP
// if IsInUnit ( Cornel ) then
13821: LD_EXP 43
13825: PPUSH
13826: CALL_OW 310
13830: IFFALSE 13908
// begin cargo := IsInUnit ( Cornel ) ;
13832: LD_ADDR_VAR 0 7
13836: PUSH
13837: LD_EXP 43
13841: PPUSH
13842: CALL_OW 310
13846: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13847: LD_VAR 0 7
13851: PPUSH
13852: LD_INT 1
13854: PPUSH
13855: CALL_OW 289
13859: IFFALSE 13870
// ComUnload ( cargo ) ;
13861: LD_VAR 0 7
13865: PPUSH
13866: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13870: LD_EXP 43
13874: PPUSH
13875: LD_INT 235
13877: PPUSH
13878: LD_INT 122
13880: PPUSH
13881: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13885: LD_EXP 43
13889: PPUSH
13890: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13894: LD_EXP 43
13898: PPUSH
13899: LD_VAR 0 4
13903: PPUSH
13904: CALL_OW 180
// end ; if Bierezov then
13908: LD_EXP 44
13912: IFFALSE 13960
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
13914: LD_EXP 44
13918: PPUSH
13919: LD_INT 260
13921: PPUSH
13922: LD_INT 120
13924: PPUSH
13925: CALL_OW 111
// if dep then
13929: LD_VAR 0 4
13933: IFFALSE 13951
// AddComEnterUnit ( Bierezov , dep ) else
13935: LD_EXP 44
13939: PPUSH
13940: LD_VAR 0 4
13944: PPUSH
13945: CALL_OW 180
13949: GO 13960
// AddComHold ( Bierezov ) ;
13951: LD_EXP 44
13955: PPUSH
13956: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
13960: LD_INT 525
13962: PPUSH
13963: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13967: LD_ADDR_VAR 0 2
13971: PUSH
13972: LD_INT 22
13974: PUSH
13975: LD_INT 4
13977: PUSH
13978: EMPTY
13979: LIST
13980: LIST
13981: PUSH
13982: LD_INT 25
13984: PUSH
13985: LD_INT 2
13987: PUSH
13988: EMPTY
13989: LIST
13990: LIST
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PPUSH
13996: CALL_OW 69
14000: PUSH
14001: LD_EXP 44
14005: DIFF
14006: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14007: LD_INT 35
14009: PPUSH
14010: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14014: LD_ADDR_VAR 0 6
14018: PUSH
14019: LD_INT 10
14021: PPUSH
14022: CALL_OW 435
14026: ST_TO_ADDR
// if crates then
14027: LD_VAR 0 6
14031: IFFALSE 14060
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14033: LD_VAR 0 2
14037: PPUSH
14038: LD_VAR 0 6
14042: PUSH
14043: LD_INT 1
14045: ARRAY
14046: PPUSH
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 2
14054: ARRAY
14055: PPUSH
14056: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14060: LD_VAR 0 4
14064: PPUSH
14065: CALL_OW 274
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 275
14077: PUSH
14078: LD_INT 40
14080: GREATEREQUAL
14081: IFFALSE 14007
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14083: LD_ADDR_VAR 0 5
14087: PUSH
14088: LD_INT 4
14090: PUSH
14091: LD_INT 256
14093: PUSH
14094: LD_INT 111
14096: PUSH
14097: LD_INT 2
14099: PUSH
14100: EMPTY
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: PUSH
14106: LD_INT 31
14108: PUSH
14109: LD_INT 243
14111: PUSH
14112: LD_INT 112
14114: PUSH
14115: LD_INT 2
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: PUSH
14124: LD_INT 31
14126: PUSH
14127: LD_INT 254
14129: PUSH
14130: LD_INT 114
14132: PUSH
14133: LD_INT 2
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: LIST
14146: ST_TO_ADDR
// for i in blist do
14147: LD_ADDR_VAR 0 1
14151: PUSH
14152: LD_VAR 0 5
14156: PUSH
14157: FOR_IN
14158: IFFALSE 14207
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14160: LD_VAR 0 2
14164: PPUSH
14165: LD_VAR 0 1
14169: PUSH
14170: LD_INT 1
14172: ARRAY
14173: PPUSH
14174: LD_VAR 0 1
14178: PUSH
14179: LD_INT 2
14181: ARRAY
14182: PPUSH
14183: LD_VAR 0 1
14187: PUSH
14188: LD_INT 3
14190: ARRAY
14191: PPUSH
14192: LD_VAR 0 1
14196: PUSH
14197: LD_INT 4
14199: ARRAY
14200: PPUSH
14201: CALL_OW 205
14205: GO 14157
14207: POP
14208: POP
// repeat wait ( 0 0$01 ) ;
14209: LD_INT 35
14211: PPUSH
14212: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14216: LD_INT 22
14218: PUSH
14219: LD_INT 4
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 4
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: LD_INT 3
14238: PUSH
14239: LD_INT 57
14241: PUSH
14242: EMPTY
14243: LIST
14244: PUSH
14245: EMPTY
14246: LIST
14247: LIST
14248: PUSH
14249: EMPTY
14250: LIST
14251: LIST
14252: LIST
14253: PPUSH
14254: CALL_OW 69
14258: IFFALSE 14209
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14260: LD_VAR 0 3
14264: PPUSH
14265: LD_INT 22
14267: PUSH
14268: LD_INT 4
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: PUSH
14275: LD_INT 30
14277: PUSH
14278: LD_INT 4
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: LIST
14288: PPUSH
14289: CALL_OW 69
14293: PUSH
14294: LD_INT 1
14296: ARRAY
14297: PPUSH
14298: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14302: LD_VAR 0 3
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 183
// if has_eng > 1 then
14314: LD_VAR 0 2
14318: PUSH
14319: LD_INT 1
14321: GREATER
14322: IFFALSE 14464
// for i = has_eng downto 2 do
14324: LD_ADDR_VAR 0 1
14328: PUSH
14329: DOUBLE
14330: LD_VAR 0 2
14334: INC
14335: ST_TO_ADDR
14336: LD_INT 2
14338: PUSH
14339: FOR_DOWNTO
14340: IFFALSE 14462
// begin if IsInUnit ( has_eng [ i ] ) then
14342: LD_VAR 0 2
14346: PUSH
14347: LD_VAR 0 1
14351: ARRAY
14352: PPUSH
14353: CALL_OW 310
14357: IFFALSE 14374
// ComExitBuilding ( has_eng [ i ] ) ;
14359: LD_VAR 0 2
14363: PUSH
14364: LD_VAR 0 1
14368: ARRAY
14369: PPUSH
14370: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14374: LD_VAR 0 2
14378: PUSH
14379: LD_VAR 0 1
14383: ARRAY
14384: PPUSH
14385: LD_INT 22
14387: PUSH
14388: LD_INT 4
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PUSH
14395: LD_INT 30
14397: PUSH
14398: LD_INT 4
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PPUSH
14409: CALL_OW 69
14413: PUSH
14414: LD_INT 1
14416: ARRAY
14417: PPUSH
14418: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14422: LD_VAR 0 2
14426: PUSH
14427: LD_VAR 0 1
14431: ARRAY
14432: PPUSH
14433: LD_INT 1
14435: PPUSH
14436: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14440: LD_ADDR_VAR 0 2
14444: PUSH
14445: LD_VAR 0 2
14449: PPUSH
14450: LD_VAR 0 1
14454: PPUSH
14455: CALL_OW 3
14459: ST_TO_ADDR
// end ;
14460: GO 14339
14462: POP
14463: POP
// repeat wait ( 0 0$01 ) ;
14464: LD_INT 35
14466: PPUSH
14467: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14471: LD_INT 22
14473: PUSH
14474: LD_INT 4
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 30
14483: PUSH
14484: LD_INT 31
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 3
14493: PUSH
14494: LD_INT 57
14496: PUSH
14497: EMPTY
14498: LIST
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: LIST
14508: PPUSH
14509: CALL_OW 69
14513: PUSH
14514: LD_INT 1
14516: GREATER
14517: IFFALSE 14464
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14519: LD_ADDR_VAR 0 8
14523: PUSH
14524: LD_EXP 6
14528: PPUSH
14529: LD_INT 25
14531: PUSH
14532: LD_INT 1
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: PPUSH
14539: CALL_OW 72
14543: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14544: LD_ADDR_VAR 0 1
14548: PUSH
14549: DOUBLE
14550: LD_INT 1
14552: DEC
14553: ST_TO_ADDR
14554: LD_INT 22
14556: PUSH
14557: LD_INT 4
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: PUSH
14564: LD_INT 30
14566: PUSH
14567: LD_INT 31
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: PUSH
14574: LD_INT 3
14576: PUSH
14577: LD_INT 57
14579: PUSH
14580: EMPTY
14581: LIST
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: EMPTY
14588: LIST
14589: LIST
14590: LIST
14591: PPUSH
14592: CALL_OW 69
14596: PUSH
14597: FOR_TO
14598: IFFALSE 14682
// begin if not sol [ i ] then
14600: LD_VAR 0 8
14604: PUSH
14605: LD_VAR 0 1
14609: ARRAY
14610: NOT
14611: IFFALSE 14615
// break ;
14613: GO 14682
// ComExitBuilding ( sol [ i ] ) ;
14615: LD_VAR 0 8
14619: PUSH
14620: LD_VAR 0 1
14624: ARRAY
14625: PPUSH
14626: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14630: LD_VAR 0 8
14634: PUSH
14635: LD_VAR 0 1
14639: ARRAY
14640: PPUSH
14641: LD_INT 22
14643: PUSH
14644: LD_INT 4
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PUSH
14651: LD_INT 30
14653: PUSH
14654: LD_INT 31
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PPUSH
14665: CALL_OW 69
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PPUSH
14676: CALL_OW 180
// end ;
14680: GO 14597
14682: POP
14683: POP
// if sol > 3 then
14684: LD_VAR 0 8
14688: PUSH
14689: LD_INT 3
14691: GREATER
14692: IFFALSE 14809
// begin ComExitBuilding ( sol [ 3 ] ) ;
14694: LD_VAR 0 8
14698: PUSH
14699: LD_INT 3
14701: ARRAY
14702: PPUSH
14703: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14707: LD_VAR 0 8
14711: PUSH
14712: LD_INT 3
14714: ARRAY
14715: PPUSH
14716: LD_INT 246
14718: PPUSH
14719: LD_INT 94
14721: PPUSH
14722: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14726: LD_VAR 0 8
14730: PUSH
14731: LD_INT 3
14733: ARRAY
14734: PPUSH
14735: LD_INT 175
14737: PPUSH
14738: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14742: LD_VAR 0 8
14746: PUSH
14747: LD_INT 3
14749: ARRAY
14750: PPUSH
14751: LD_INT 224
14753: PPUSH
14754: LD_INT 90
14756: PPUSH
14757: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14761: LD_VAR 0 8
14765: PUSH
14766: LD_INT 3
14768: ARRAY
14769: PPUSH
14770: LD_INT 245
14772: PPUSH
14773: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14777: LD_VAR 0 8
14781: PUSH
14782: LD_INT 3
14784: ARRAY
14785: PPUSH
14786: LD_INT 223
14788: PPUSH
14789: LD_INT 110
14791: PPUSH
14792: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14796: LD_VAR 0 8
14800: PUSH
14801: LD_INT 3
14803: ARRAY
14804: PPUSH
14805: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14809: LD_VAR 0 2
14813: PPUSH
14814: LD_VAR 0 4
14818: PPUSH
14819: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
14823: LD_INT 22
14825: PUSH
14826: LD_INT 4
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PUSH
14833: LD_INT 30
14835: PUSH
14836: LD_INT 4
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: PPUSH
14847: CALL_OW 69
14851: PUSH
14852: LD_INT 1
14854: ARRAY
14855: PPUSH
14856: CALL_OW 313
14860: PUSH
14861: LD_INT 6
14863: LESS
14864: IFFALSE 14928
// begin if IsInUnit ( Cornel ) then
14866: LD_EXP 43
14870: PPUSH
14871: CALL_OW 310
14875: IFFALSE 14886
// ComExitBuilding ( Cornel ) ;
14877: LD_EXP 43
14881: PPUSH
14882: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14886: LD_EXP 43
14890: PPUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 4
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: PUSH
14901: LD_INT 30
14903: PUSH
14904: LD_INT 4
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PUSH
14911: EMPTY
14912: LIST
14913: LIST
14914: PPUSH
14915: CALL_OW 69
14919: PUSH
14920: LD_INT 1
14922: ARRAY
14923: PPUSH
14924: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
14928: LD_INT 35
14930: PPUSH
14931: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14935: LD_ADDR_VAR 0 3
14939: PUSH
14940: LD_INT 22
14942: PUSH
14943: LD_INT 4
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 21
14952: PUSH
14953: LD_INT 3
14955: PUSH
14956: EMPTY
14957: LIST
14958: LIST
14959: PUSH
14960: LD_INT 3
14962: PUSH
14963: LD_INT 24
14965: PUSH
14966: LD_INT 1000
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: LIST
14981: PPUSH
14982: CALL_OW 69
14986: ST_TO_ADDR
// if filter and has_eng then
14987: LD_VAR 0 3
14991: PUSH
14992: LD_VAR 0 2
14996: AND
14997: IFFALSE 15063
// begin for i in has_eng do
14999: LD_ADDR_VAR 0 1
15003: PUSH
15004: LD_VAR 0 2
15008: PUSH
15009: FOR_IN
15010: IFFALSE 15059
// begin if IsInUnit ( i ) then
15012: LD_VAR 0 1
15016: PPUSH
15017: CALL_OW 310
15021: IFFALSE 15032
// ComExitBuilding ( i ) ;
15023: LD_VAR 0 1
15027: PPUSH
15028: CALL_OW 122
// Wait ( 3 ) ;
15032: LD_INT 3
15034: PPUSH
15035: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_VAR 0 3
15048: PUSH
15049: LD_INT 1
15051: ARRAY
15052: PPUSH
15053: CALL_OW 130
// end ;
15057: GO 15009
15059: POP
15060: POP
// end else
15061: GO 15117
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15063: LD_VAR 0 2
15067: PUSH
15068: LD_VAR 0 2
15072: PPUSH
15073: LD_INT 56
15075: PUSH
15076: EMPTY
15077: LIST
15078: PPUSH
15079: CALL_OW 72
15083: AND
15084: IFFALSE 15117
// for i in has_eng do
15086: LD_ADDR_VAR 0 1
15090: PUSH
15091: LD_VAR 0 2
15095: PUSH
15096: FOR_IN
15097: IFFALSE 15115
// ComEnterUnit ( i , dep ) ;
15099: LD_VAR 0 1
15103: PPUSH
15104: LD_VAR 0 4
15108: PPUSH
15109: CALL_OW 120
15113: GO 15096
15115: POP
15116: POP
// until cornel_prepared ;
15117: LD_EXP 11
15121: IFFALSE 14928
// end ;
15123: PPOPN 8
15125: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15126: LD_EXP 11
15130: IFFALSE 15529
15132: GO 15134
15134: DISABLE
15135: LD_INT 0
15137: PPUSH
15138: PPUSH
15139: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15140: LD_ADDR_VAR 0 2
15144: PUSH
15145: LD_INT 22
15147: PUSH
15148: LD_INT 4
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 30
15157: PUSH
15158: LD_INT 4
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PPUSH
15169: CALL_OW 69
15173: PUSH
15174: LD_INT 1
15176: ARRAY
15177: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15178: LD_EXP 6
15182: PPUSH
15183: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15187: LD_EXP 44
15191: PUSH
15192: LD_EXP 44
15196: PPUSH
15197: CALL_OW 310
15201: AND
15202: IFFALSE 15213
// ComExitBuilding ( Bierezov ) ;
15204: LD_EXP 44
15208: PPUSH
15209: CALL_OW 122
// Wait ( 0 0$03 ) ;
15213: LD_INT 105
15215: PPUSH
15216: CALL_OW 67
// for i in cornel_units do
15220: LD_ADDR_VAR 0 1
15224: PUSH
15225: LD_EXP 6
15229: PUSH
15230: FOR_IN
15231: IFFALSE 15307
// begin if GetClass ( i ) in [ 2 , 3 ] then
15233: LD_VAR 0 1
15237: PPUSH
15238: CALL_OW 257
15242: PUSH
15243: LD_INT 2
15245: PUSH
15246: LD_INT 3
15248: PUSH
15249: EMPTY
15250: LIST
15251: LIST
15252: IN
15253: IFFALSE 15290
// begin ComEnterUnit ( i , arm ) ;
15255: LD_VAR 0 1
15259: PPUSH
15260: LD_VAR 0 2
15264: PPUSH
15265: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15269: LD_VAR 0 1
15273: PPUSH
15274: LD_INT 1
15276: PPUSH
15277: CALL_OW 183
// AddComExitBuilding ( i ) ;
15281: LD_VAR 0 1
15285: PPUSH
15286: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15290: LD_VAR 0 1
15294: PPUSH
15295: LD_INT 257
15297: PPUSH
15298: LD_INT 121
15300: PPUSH
15301: CALL_OW 171
// end ;
15305: GO 15230
15307: POP
15308: POP
// Wait ( 1 1$00 ) ;
15309: LD_INT 2100
15311: PPUSH
15312: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15316: LD_ADDR_VAR 0 3
15320: PUSH
15321: LD_EXP 43
15325: PUSH
15326: LD_EXP 44
15330: ADD
15331: PUSH
15332: LD_EXP 6
15336: ADD
15337: PUSH
15338: LD_EXP 6
15342: PPUSH
15343: LD_INT 21
15345: PUSH
15346: LD_INT 2
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: PPUSH
15353: CALL_OW 72
15357: DIFF
15358: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15359: LD_VAR 0 3
15363: PPUSH
15364: LD_INT 248
15366: PPUSH
15367: LD_INT 85
15369: PPUSH
15370: CALL_OW 111
// AddComHold ( filter ) ;
15374: LD_VAR 0 3
15378: PPUSH
15379: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15383: LD_INT 35
15385: PPUSH
15386: CALL_OW 67
// until cornel_attack ;
15390: LD_EXP 9
15394: IFFALSE 15383
// ComAgressiveMove ( filter , 209 , 63 ) ;
15396: LD_VAR 0 3
15400: PPUSH
15401: LD_INT 209
15403: PPUSH
15404: LD_INT 63
15406: PPUSH
15407: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15411: LD_EXP 43
15415: PPUSH
15416: LD_INT 208
15418: PPUSH
15419: LD_INT 62
15421: PPUSH
15422: CALL_OW 114
// AddComHold ( Cornel ) ;
15426: LD_EXP 43
15430: PPUSH
15431: CALL_OW 200
// if Bierezov then
15435: LD_EXP 44
15439: IFFALSE 15529
// begin filter := filter diff Bierezov ;
15441: LD_ADDR_VAR 0 3
15445: PUSH
15446: LD_VAR 0 3
15450: PUSH
15451: LD_EXP 44
15455: DIFF
15456: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15457: LD_EXP 44
15461: PPUSH
15462: LD_INT 6
15464: PPUSH
15465: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15469: LD_EXP 44
15473: PPUSH
15474: LD_INT 235
15476: PPUSH
15477: LD_INT 60
15479: PPUSH
15480: CALL_OW 111
// AddComHold ( Bierezov ) ;
15484: LD_EXP 44
15488: PPUSH
15489: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15493: LD_EXP 44
15497: PPUSH
15498: LD_INT 350
15500: PPUSH
15501: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15505: LD_EXP 44
15509: PPUSH
15510: LD_INT 198
15512: PPUSH
15513: LD_INT 28
15515: PPUSH
15516: CALL_OW 171
// AddComHold ( Bierezov ) ;
15520: LD_EXP 44
15524: PPUSH
15525: CALL_OW 200
// end ; end ; end_of_file
15529: PPOPN 3
15531: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15532: LD_EXP 52
15536: PUSH
15537: LD_EXP 30
15541: NOT
15542: AND
15543: PUSH
15544: LD_EXP 31
15548: NOT
15549: AND
15550: IFFALSE 16000
15552: GO 15554
15554: DISABLE
15555: LD_INT 0
15557: PPUSH
15558: PPUSH
15559: PPUSH
15560: PPUSH
// begin enable ;
15561: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15562: LD_ADDR_VAR 0 4
15566: PUSH
15567: LD_INT 81
15569: PUSH
15570: LD_INT 3
15572: PUSH
15573: EMPTY
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: ST_TO_ADDR
// for i = 1 to ru_patrol do
15582: LD_ADDR_VAR 0 2
15586: PUSH
15587: DOUBLE
15588: LD_INT 1
15590: DEC
15591: ST_TO_ADDR
15592: LD_EXP 52
15596: PUSH
15597: FOR_TO
15598: IFFALSE 15998
// begin un := ru_patrol [ i ] ;
15600: LD_ADDR_VAR 0 1
15604: PUSH
15605: LD_EXP 52
15609: PUSH
15610: LD_VAR 0 2
15614: ARRAY
15615: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15616: LD_VAR 0 1
15620: PPUSH
15621: LD_INT 13
15623: PPUSH
15624: CALL_OW 308
15628: IFFALSE 15733
// begin if not ru_alert then
15630: LD_EXP 59
15634: NOT
15635: IFFALSE 15645
// ru_alert := true ;
15637: LD_ADDR_EXP 59
15641: PUSH
15642: LD_INT 1
15644: ST_TO_ADDR
// if not See ( 1 , un ) then
15645: LD_INT 1
15647: PPUSH
15648: LD_VAR 0 1
15652: PPUSH
15653: CALL_OW 292
15657: NOT
15658: IFFALSE 15672
// SetLives ( un , 1000 ) ;
15660: LD_VAR 0 1
15664: PPUSH
15665: LD_INT 1000
15667: PPUSH
15668: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15672: LD_ADDR_EXP 52
15676: PUSH
15677: LD_EXP 52
15681: PUSH
15682: LD_VAR 0 1
15686: DIFF
15687: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15688: LD_VAR 0 1
15692: PPUSH
15693: LD_INT 22
15695: PUSH
15696: LD_INT 3
15698: PUSH
15699: EMPTY
15700: LIST
15701: LIST
15702: PUSH
15703: LD_INT 30
15705: PUSH
15706: LD_INT 4
15708: PUSH
15709: EMPTY
15710: LIST
15711: LIST
15712: PUSH
15713: EMPTY
15714: LIST
15715: LIST
15716: PPUSH
15717: CALL_OW 69
15721: PPUSH
15722: CALL 1047 0 1
15726: PPUSH
15727: CALL_OW 120
// continue ;
15731: GO 15597
// end ; if IsOk ( un ) and not HasTask ( un ) then
15733: LD_VAR 0 1
15737: PPUSH
15738: CALL_OW 302
15742: PUSH
15743: LD_VAR 0 1
15747: PPUSH
15748: CALL_OW 314
15752: NOT
15753: AND
15754: IFFALSE 15847
// begin for j = 1 to ru_firepoints_south [ i ] do
15756: LD_ADDR_VAR 0 3
15760: PUSH
15761: DOUBLE
15762: LD_INT 1
15764: DEC
15765: ST_TO_ADDR
15766: LD_EXP 58
15770: PUSH
15771: LD_VAR 0 2
15775: ARRAY
15776: PUSH
15777: FOR_TO
15778: IFFALSE 15845
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15780: LD_VAR 0 1
15784: PPUSH
15785: LD_EXP 58
15789: PUSH
15790: LD_VAR 0 2
15794: ARRAY
15795: PUSH
15796: LD_VAR 0 3
15800: ARRAY
15801: PUSH
15802: LD_INT 1
15804: ARRAY
15805: PPUSH
15806: LD_EXP 58
15810: PUSH
15811: LD_VAR 0 2
15815: ARRAY
15816: PUSH
15817: LD_VAR 0 3
15821: ARRAY
15822: PUSH
15823: LD_INT 2
15825: ARRAY
15826: PPUSH
15827: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_INT 70
15838: PPUSH
15839: CALL_OW 202
// end ;
15843: GO 15777
15845: POP
15846: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15847: LD_VAR 0 1
15851: PPUSH
15852: CALL_OW 256
15856: PUSH
15857: LD_INT 700
15859: LESS
15860: PUSH
15861: LD_VAR 0 1
15865: PPUSH
15866: LD_INT 13
15868: PPUSH
15869: CALL_OW 308
15873: NOT
15874: AND
15875: IFFALSE 15927
// begin ComMoveToArea ( un , retreatArea ) ;
15877: LD_VAR 0 1
15881: PPUSH
15882: LD_INT 13
15884: PPUSH
15885: CALL_OW 113
// if not ru_alert_xy then
15889: LD_EXP 60
15893: NOT
15894: IFFALSE 15925
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15896: LD_ADDR_EXP 60
15900: PUSH
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 250
15910: PUSH
15911: LD_VAR 0 1
15915: PPUSH
15916: CALL_OW 251
15920: PUSH
15921: EMPTY
15922: LIST
15923: LIST
15924: ST_TO_ADDR
// end else
15925: GO 15996
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15927: LD_VAR 0 1
15931: PPUSH
15932: LD_VAR 0 4
15936: PPUSH
15937: LD_VAR 0 1
15941: PPUSH
15942: CALL_OW 74
15946: PPUSH
15947: CALL_OW 296
15951: PUSH
15952: LD_INT 9
15954: LESS
15955: PUSH
15956: LD_VAR 0 1
15960: PPUSH
15961: CALL_OW 256
15965: PUSH
15966: LD_INT 500
15968: GREATER
15969: AND
15970: IFFALSE 15996
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15972: LD_VAR 0 1
15976: PPUSH
15977: LD_VAR 0 4
15981: PPUSH
15982: LD_VAR 0 1
15986: PPUSH
15987: CALL_OW 74
15991: PPUSH
15992: CALL_OW 115
// end ;
15996: GO 15597
15998: POP
15999: POP
// end ;
16000: PPOPN 4
16002: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16003: LD_EXP 59
16007: PUSH
16008: LD_EXP 60
16012: AND
16013: PUSH
16014: LD_EXP 30
16018: NOT
16019: AND
16020: PUSH
16021: LD_EXP 31
16025: NOT
16026: AND
16027: IFFALSE 16237
16029: GO 16031
16031: DISABLE
16032: LD_INT 0
16034: PPUSH
16035: PPUSH
// begin enable ;
16036: ENABLE
// if not ru_vehicles then
16037: LD_EXP 55
16041: NOT
16042: IFFALSE 16046
// exit ;
16044: GO 16237
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16046: LD_ADDR_VAR 0 2
16050: PUSH
16051: LD_INT 81
16053: PUSH
16054: LD_INT 3
16056: PUSH
16057: EMPTY
16058: LIST
16059: LIST
16060: PPUSH
16061: CALL_OW 69
16065: ST_TO_ADDR
// if ru_vehicles then
16066: LD_EXP 55
16070: IFFALSE 16237
// begin for i in ru_vehicles do
16072: LD_ADDR_VAR 0 1
16076: PUSH
16077: LD_EXP 55
16081: PUSH
16082: FOR_IN
16083: IFFALSE 16235
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16085: LD_VAR 0 1
16089: PPUSH
16090: CALL_OW 302
16094: PUSH
16095: LD_VAR 0 1
16099: PPUSH
16100: LD_VAR 0 2
16104: PPUSH
16105: LD_VAR 0 1
16109: PPUSH
16110: CALL_OW 74
16114: PPUSH
16115: CALL_OW 296
16119: PUSH
16120: LD_INT 9
16122: LESS
16123: AND
16124: IFFALSE 16150
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16126: LD_VAR 0 1
16130: PPUSH
16131: LD_VAR 0 2
16135: PPUSH
16136: LD_VAR 0 1
16140: PPUSH
16141: CALL_OW 74
16145: PPUSH
16146: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16150: LD_VAR 0 1
16154: PPUSH
16155: CALL_OW 314
16159: NOT
16160: PUSH
16161: LD_VAR 0 1
16165: PPUSH
16166: CALL_OW 302
16170: AND
16171: PUSH
16172: LD_VAR 0 1
16176: PPUSH
16177: LD_EXP 60
16181: PUSH
16182: LD_INT 1
16184: ARRAY
16185: PPUSH
16186: LD_EXP 60
16190: PUSH
16191: LD_INT 2
16193: ARRAY
16194: PPUSH
16195: CALL_OW 297
16199: PUSH
16200: LD_INT 10
16202: GREATER
16203: AND
16204: IFFALSE 16233
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_EXP 60
16215: PUSH
16216: LD_INT 1
16218: ARRAY
16219: PPUSH
16220: LD_EXP 60
16224: PUSH
16225: LD_INT 2
16227: ARRAY
16228: PPUSH
16229: CALL_OW 114
// end ;
16233: GO 16082
16235: POP
16236: POP
// end ; end ;
16237: PPOPN 2
16239: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16240: LD_EXP 60
16244: PUSH
16245: LD_EXP 59
16249: AND
16250: PUSH
16251: LD_INT 3
16253: PPUSH
16254: CALL_OW 463
16258: NOT
16259: AND
16260: PUSH
16261: LD_EXP 30
16265: NOT
16266: AND
16267: PUSH
16268: LD_EXP 31
16272: NOT
16273: AND
16274: IFFALSE 16369
16276: GO 16278
16278: DISABLE
16279: LD_INT 0
16281: PPUSH
// begin enable ;
16282: ENABLE
// ru_alert_xy := false ;
16283: LD_ADDR_EXP 60
16287: PUSH
16288: LD_INT 0
16290: ST_TO_ADDR
// ru_alert := false ;
16291: LD_ADDR_EXP 59
16295: PUSH
16296: LD_INT 0
16298: ST_TO_ADDR
// if ru_vehicles then
16299: LD_EXP 55
16303: IFFALSE 16369
// for i in ru_vehicles do
16305: LD_ADDR_VAR 0 1
16309: PUSH
16310: LD_EXP 55
16314: PUSH
16315: FOR_IN
16316: IFFALSE 16367
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16318: LD_VAR 0 1
16322: PPUSH
16323: CALL_OW 302
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: LD_INT 89
16335: PPUSH
16336: LD_INT 36
16338: PPUSH
16339: CALL_OW 297
16343: PUSH
16344: LD_INT 10
16346: GREATER
16347: AND
16348: IFFALSE 16365
// ComMoveXY ( i , 89 , 36 ) ;
16350: LD_VAR 0 1
16354: PPUSH
16355: LD_INT 89
16357: PPUSH
16358: LD_INT 36
16360: PPUSH
16361: CALL_OW 111
16365: GO 16315
16367: POP
16368: POP
// end ;
16369: PPOPN 1
16371: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16372: LD_EXP 54
16376: PUSH
16377: LD_EXP 30
16381: NOT
16382: AND
16383: PUSH
16384: LD_EXP 31
16388: NOT
16389: AND
16390: IFFALSE 16674
16392: GO 16394
16394: DISABLE
16395: LD_INT 0
16397: PPUSH
16398: PPUSH
16399: PPUSH
// begin enable ;
16400: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16401: LD_ADDR_VAR 0 3
16405: PUSH
16406: LD_INT 81
16408: PUSH
16409: LD_INT 3
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PPUSH
16416: CALL_OW 69
16420: ST_TO_ADDR
// for i = 1 to ru_forest do
16421: LD_ADDR_VAR 0 1
16425: PUSH
16426: DOUBLE
16427: LD_INT 1
16429: DEC
16430: ST_TO_ADDR
16431: LD_EXP 54
16435: PUSH
16436: FOR_TO
16437: IFFALSE 16672
// begin un := ru_forest [ i ] ;
16439: LD_ADDR_VAR 0 2
16443: PUSH
16444: LD_EXP 54
16448: PUSH
16449: LD_VAR 0 1
16453: ARRAY
16454: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16455: LD_VAR 0 2
16459: PPUSH
16460: LD_INT 13
16462: PPUSH
16463: CALL_OW 308
16467: IFFALSE 16557
// begin if not See ( 1 , un ) then
16469: LD_INT 1
16471: PPUSH
16472: LD_VAR 0 2
16476: PPUSH
16477: CALL_OW 292
16481: NOT
16482: IFFALSE 16496
// SetLives ( un , 1000 ) ;
16484: LD_VAR 0 2
16488: PPUSH
16489: LD_INT 1000
16491: PPUSH
16492: CALL_OW 234
// ru_forest := ru_forest diff un ;
16496: LD_ADDR_EXP 54
16500: PUSH
16501: LD_EXP 54
16505: PUSH
16506: LD_VAR 0 2
16510: DIFF
16511: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16512: LD_VAR 0 2
16516: PPUSH
16517: LD_INT 22
16519: PUSH
16520: LD_INT 3
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: PUSH
16527: LD_INT 30
16529: PUSH
16530: LD_INT 4
16532: PUSH
16533: EMPTY
16534: LIST
16535: LIST
16536: PUSH
16537: EMPTY
16538: LIST
16539: LIST
16540: PPUSH
16541: CALL_OW 69
16545: PPUSH
16546: CALL 1047 0 1
16550: PPUSH
16551: CALL_OW 120
// continue ;
16555: GO 16436
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16557: LD_VAR 0 2
16561: PPUSH
16562: CALL_OW 256
16566: PUSH
16567: LD_INT 700
16569: LESS
16570: PUSH
16571: LD_VAR 0 2
16575: PPUSH
16576: LD_INT 13
16578: PPUSH
16579: CALL_OW 308
16583: NOT
16584: AND
16585: IFFALSE 16601
// ComMoveToArea ( un , retreatArea ) else
16587: LD_VAR 0 2
16591: PPUSH
16592: LD_INT 13
16594: PPUSH
16595: CALL_OW 113
16599: GO 16670
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16601: LD_VAR 0 2
16605: PPUSH
16606: LD_VAR 0 3
16610: PPUSH
16611: LD_VAR 0 2
16615: PPUSH
16616: CALL_OW 74
16620: PPUSH
16621: CALL_OW 296
16625: PUSH
16626: LD_INT 9
16628: LESS
16629: PUSH
16630: LD_VAR 0 2
16634: PPUSH
16635: CALL_OW 256
16639: PUSH
16640: LD_INT 500
16642: GREATER
16643: AND
16644: IFFALSE 16670
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16646: LD_VAR 0 2
16650: PPUSH
16651: LD_VAR 0 3
16655: PPUSH
16656: LD_VAR 0 2
16660: PPUSH
16661: CALL_OW 74
16665: PPUSH
16666: CALL_OW 115
// end ;
16670: GO 16436
16672: POP
16673: POP
// end ;
16674: PPOPN 3
16676: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16677: LD_EXP 31
16681: NOT
16682: IFFALSE 16803
16684: GO 16686
16686: DISABLE
16687: LD_INT 0
16689: PPUSH
16690: PPUSH
// begin enable ;
16691: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16692: LD_ADDR_VAR 0 2
16696: PUSH
16697: LD_INT 22
16699: PUSH
16700: LD_INT 3
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: PUSH
16707: LD_INT 21
16709: PUSH
16710: LD_INT 3
16712: PUSH
16713: EMPTY
16714: LIST
16715: LIST
16716: PUSH
16717: EMPTY
16718: LIST
16719: LIST
16720: PPUSH
16721: CALL_OW 69
16725: ST_TO_ADDR
// if filter then
16726: LD_VAR 0 2
16730: IFFALSE 16803
// for i in filter do
16732: LD_ADDR_VAR 0 1
16736: PUSH
16737: LD_VAR 0 2
16741: PUSH
16742: FOR_IN
16743: IFFALSE 16801
// if GetLives ( i ) < 990 then
16745: LD_VAR 0 1
16749: PPUSH
16750: CALL_OW 256
16754: PUSH
16755: LD_INT 990
16757: LESS
16758: IFFALSE 16799
// begin ru_alert := true ;
16760: LD_ADDR_EXP 59
16764: PUSH
16765: LD_INT 1
16767: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16768: LD_ADDR_EXP 60
16772: PUSH
16773: LD_VAR 0 1
16777: PPUSH
16778: CALL_OW 250
16782: PUSH
16783: LD_VAR 0 1
16787: PPUSH
16788: CALL_OW 251
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: ST_TO_ADDR
// break ;
16797: GO 16801
// end ;
16799: GO 16742
16801: POP
16802: POP
// end ;
16803: PPOPN 2
16805: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16806: LD_EXP 30
16810: IFFALSE 16959
16812: GO 16814
16814: DISABLE
16815: LD_INT 0
16817: PPUSH
16818: PPUSH
16819: PPUSH
16820: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16821: LD_ADDR_VAR 0 4
16825: PUSH
16826: LD_EXP 55
16830: PUSH
16831: LD_EXP 54
16835: ADD
16836: PUSH
16837: LD_EXP 52
16841: ADD
16842: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16843: LD_ADDR_VAR 0 3
16847: PUSH
16848: LD_INT 3
16850: PPUSH
16851: LD_INT 81
16853: PUSH
16854: LD_INT 3
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: PPUSH
16861: CALL_OW 70
16865: ST_TO_ADDR
// if filter and enemy then
16866: LD_VAR 0 4
16870: PUSH
16871: LD_VAR 0 3
16875: AND
16876: IFFALSE 16959
// repeat wait ( 0 0$01 ) ;
16878: LD_INT 35
16880: PPUSH
16881: CALL_OW 67
// for i in filter do
16885: LD_ADDR_VAR 0 1
16889: PUSH
16890: LD_VAR 0 4
16894: PUSH
16895: FOR_IN
16896: IFFALSE 16924
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16898: LD_VAR 0 1
16902: PPUSH
16903: LD_VAR 0 3
16907: PPUSH
16908: LD_VAR 0 1
16912: PPUSH
16913: CALL_OW 74
16917: PPUSH
16918: CALL_OW 115
// end ;
16922: GO 16895
16924: POP
16925: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16926: LD_INT 3
16928: PPUSH
16929: LD_INT 81
16931: PUSH
16932: LD_INT 3
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PPUSH
16939: CALL_OW 70
16943: PUSH
16944: LD_INT 0
16946: EQUAL
16947: PUSH
16948: LD_VAR 0 4
16952: PUSH
16953: LD_INT 0
16955: EQUAL
16956: OR
16957: IFFALSE 16878
// end ;
16959: PPOPN 4
16961: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16962: LD_EXP 25
16966: PUSH
16967: LD_INT 22
16969: PUSH
16970: LD_INT 4
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 30
16979: PUSH
16980: LD_INT 4
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 3
16989: PUSH
16990: LD_INT 57
16992: PUSH
16993: EMPTY
16994: LIST
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: LIST
17004: PPUSH
17005: CALL_OW 69
17009: AND
17010: IFFALSE 17059
17012: GO 17014
17014: DISABLE
17015: LD_INT 0
17017: PPUSH
// begin if not ru_cornel_attack then
17018: LD_EXP 57
17022: NOT
17023: IFFALSE 17027
// exit ;
17025: GO 17059
// for i in ru_cornel_attack do
17027: LD_ADDR_VAR 0 1
17031: PUSH
17032: LD_EXP 57
17036: PUSH
17037: FOR_IN
17038: IFFALSE 17057
// ComAgressiveMove ( i , 258 , 119 ) ;
17040: LD_VAR 0 1
17044: PPUSH
17045: LD_INT 258
17047: PPUSH
17048: LD_INT 119
17050: PPUSH
17051: CALL_OW 114
17055: GO 17037
17057: POP
17058: POP
// end ; end_of_file
17059: PPOPN 1
17061: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17062: LD_EXP 5
17066: PUSH
17067: LD_EXP 9
17071: NOT
17072: AND
17073: PUSH
17074: LD_EXP 19
17078: AND
17079: IFFALSE 17191
17081: GO 17083
17083: DISABLE
17084: LD_INT 0
17086: PPUSH
// begin enable ;
17087: ENABLE
// crates_counter := crates_counter - 50 ;
17088: LD_ADDR_EXP 19
17092: PUSH
17093: LD_EXP 19
17097: PUSH
17098: LD_INT 50
17100: MINUS
17101: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17102: LD_INT 8
17104: PPUSH
17105: LD_INT 2
17107: PPUSH
17108: LD_INT 5
17110: PPUSH
17111: CALL_OW 12
17115: PPUSH
17116: LD_INT 1
17118: PPUSH
17119: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17123: LD_INT 1785
17125: PPUSH
17126: LD_INT 2345
17128: PPUSH
17129: CALL_OW 12
17133: PPUSH
17134: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17138: LD_ADDR_VAR 0 1
17142: PUSH
17143: LD_INT 1
17145: PPUSH
17146: LD_OWVAR 67
17150: PUSH
17151: LD_INT 2
17153: PLUS
17154: PPUSH
17155: CALL_OW 12
17159: ST_TO_ADDR
// if r < 3 then
17160: LD_VAR 0 1
17164: PUSH
17165: LD_INT 3
17167: LESS
17168: IFFALSE 17191
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17170: LD_INT 4
17172: PPUSH
17173: LD_INT 1
17175: PPUSH
17176: LD_INT 5
17178: PPUSH
17179: CALL_OW 12
17183: PPUSH
17184: LD_INT 1
17186: PPUSH
17187: CALL_OW 55
// end ;
17191: PPOPN 1
17193: END
// every 0 0$01 trigger cornel_active do
17194: LD_EXP 8
17198: IFFALSE 17287
17200: GO 17202
17202: DISABLE
// begin Wait ( 0 0$03 ) ;
17203: LD_INT 105
17205: PPUSH
17206: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17210: LD_INT 2
17212: PPUSH
17213: LD_INT 5
17215: PPUSH
17216: CALL_OW 12
17220: PPUSH
17221: LD_INT 10
17223: PPUSH
17224: LD_INT 1
17226: PPUSH
17227: CALL_OW 55
// Wait ( 0 0$13 ) ;
17231: LD_INT 455
17233: PPUSH
17234: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17238: LD_INT 2
17240: PPUSH
17241: LD_INT 5
17243: PPUSH
17244: CALL_OW 12
17248: PPUSH
17249: LD_INT 10
17251: PPUSH
17252: LD_INT 1
17254: PPUSH
17255: CALL_OW 55
// Wait ( 0 0$16 ) ;
17259: LD_INT 560
17261: PPUSH
17262: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17266: LD_INT 2
17268: PPUSH
17269: LD_INT 5
17271: PPUSH
17272: CALL_OW 12
17276: PPUSH
17277: LD_INT 10
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL_OW 55
// end ; end_of_file
17287: END
// every 0 0$01 trigger cornel_prepared do
17288: LD_EXP 11
17292: IFFALSE 17351
17294: GO 17296
17296: DISABLE
// begin enable ;
17297: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17298: LD_ADDR_OWVAR 47
17302: PUSH
17303: LD_STRING #Am03-1
17305: PUSH
17306: LD_EXP 10
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17315: LD_ADDR_EXP 10
17319: PUSH
17320: LD_EXP 10
17324: PPUSH
17325: LD_STRING -
17327: PPUSH
17328: CALL 1117 0 2
17332: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17333: LD_EXP 10
17337: PUSH
17338: LD_INT 0
17340: EQUAL
17341: IFFALSE 17351
// begin Display_Strings := [ ] ;
17343: LD_ADDR_OWVAR 47
17347: PUSH
17348: EMPTY
17349: ST_TO_ADDR
// disable ;
17350: DISABLE
// end ; end ;
17351: END
// every 0 0$01 trigger debug and debug_strings do
17352: LD_EXP 1
17356: PUSH
17357: LD_OWVAR 48
17361: AND
17362: IFFALSE 17378
17364: GO 17366
17366: DISABLE
// begin enable ;
17367: ENABLE
// Display_Strings := debug_strings ;
17368: LD_ADDR_OWVAR 47
17372: PUSH
17373: LD_OWVAR 48
17377: ST_TO_ADDR
// end ; end_of_file
17378: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17379: LD_VAR 0 1
17383: PPUSH
17384: CALL_OW 255
17388: PUSH
17389: LD_INT 1
17391: EQUAL
17392: PUSH
17393: LD_EXP 13
17397: NOT
17398: AND
17399: IFFALSE 17409
// solar_builded := true ;
17401: LD_ADDR_EXP 13
17405: PUSH
17406: LD_INT 1
17408: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17409: LD_VAR 0 1
17413: PPUSH
17414: CALL_OW 255
17418: PUSH
17419: LD_INT 1
17421: EQUAL
17422: PUSH
17423: LD_EXP 28
17427: AND
17428: IFFALSE 17461
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17430: LD_ADDR_EXP 28
17434: PUSH
17435: LD_EXP 28
17439: PUSH
17440: LD_INT 1750
17442: PUSH
17443: LD_INT 1400
17445: PUSH
17446: LD_INT 1225
17448: PUSH
17449: EMPTY
17450: LIST
17451: LIST
17452: LIST
17453: PUSH
17454: LD_OWVAR 67
17458: ARRAY
17459: PLUS
17460: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17461: LD_VAR 0 1
17465: PPUSH
17466: CALL_OW 255
17470: PUSH
17471: LD_INT 3
17473: EQUAL
17474: IFFALSE 17492
// ru_vehicles := ru_vehicles ^ veh ;
17476: LD_ADDR_EXP 55
17480: PUSH
17481: LD_EXP 55
17485: PUSH
17486: LD_VAR 0 1
17490: ADD
17491: ST_TO_ADDR
// end ;
17492: PPOPN 2
17494: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17495: LD_VAR 0 1
17499: PUSH
17500: LD_EXP 52
17504: IN
17505: IFFALSE 17523
// ru_patrol := ru_patrol diff un ;
17507: LD_ADDR_EXP 52
17511: PUSH
17512: LD_EXP 52
17516: PUSH
17517: LD_VAR 0 1
17521: DIFF
17522: ST_TO_ADDR
// if un in ru_forest then
17523: LD_VAR 0 1
17527: PUSH
17528: LD_EXP 54
17532: IN
17533: IFFALSE 17551
// ru_forest := ru_forest diff un ;
17535: LD_ADDR_EXP 54
17539: PUSH
17540: LD_EXP 54
17544: PUSH
17545: LD_VAR 0 1
17549: DIFF
17550: ST_TO_ADDR
// if un in ru_vehicles then
17551: LD_VAR 0 1
17555: PUSH
17556: LD_EXP 55
17560: IN
17561: IFFALSE 17636
// begin ru_vehicles := ru_vehicles diff un ;
17563: LD_ADDR_EXP 55
17567: PUSH
17568: LD_EXP 55
17572: PUSH
17573: LD_VAR 0 1
17577: DIFF
17578: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17579: LD_ADDR_EXP 56
17583: PUSH
17584: LD_EXP 56
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: CALL_OW 265
17598: PUSH
17599: LD_VAR 0 1
17603: PPUSH
17604: CALL_OW 262
17608: PUSH
17609: LD_VAR 0 1
17613: PPUSH
17614: CALL_OW 263
17618: PUSH
17619: LD_VAR 0 1
17623: PPUSH
17624: CALL_OW 264
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: LIST
17633: LIST
17634: ADD
17635: ST_TO_ADDR
// end ; if un = JMM then
17636: LD_VAR 0 1
17640: PUSH
17641: LD_EXP 36
17645: EQUAL
17646: IFFALSE 17655
// YouLost ( 0 ) ;
17648: LD_STRING 0
17650: PPUSH
17651: CALL_OW 104
// if un = us_dep_west then
17655: LD_VAR 0 1
17659: PUSH
17660: LD_INT 1
17662: EQUAL
17663: IFFALSE 17672
// YouLost ( 2 ) ;
17665: LD_STRING 2
17667: PPUSH
17668: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17672: LD_VAR 0 1
17676: PPUSH
17677: CALL_OW 255
17681: PUSH
17682: LD_INT 8
17684: EQUAL
17685: PUSH
17686: LD_EXP 5
17690: NOT
17691: AND
17692: IFFALSE 17701
// YouLost ( 4 ) ;
17694: LD_STRING 4
17696: PPUSH
17697: CALL_OW 104
// if un in jmm_units then
17701: LD_VAR 0 1
17705: PUSH
17706: LD_EXP 4
17710: IN
17711: IFFALSE 17727
// lose_counter := lose_counter + 1 ;
17713: LD_ADDR_EXP 33
17717: PUSH
17718: LD_EXP 33
17722: PUSH
17723: LD_INT 1
17725: PLUS
17726: ST_TO_ADDR
// end ;
17727: PPOPN 1
17729: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17730: LD_INT 0
17732: PPUSH
17733: PPUSH
// begin if GetSide ( driver ) = 3 then
17734: LD_VAR 0 1
17738: PPUSH
17739: CALL_OW 255
17743: PUSH
17744: LD_INT 3
17746: EQUAL
17747: IFFALSE 17825
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17749: LD_ADDR_VAR 0 6
17753: PUSH
17754: LD_INT 22
17756: PUSH
17757: LD_INT 3
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: PUSH
17764: LD_INT 30
17766: PUSH
17767: LD_INT 3
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: PPUSH
17778: CALL_OW 69
17782: PPUSH
17783: CALL 1047 0 1
17787: ST_TO_ADDR
// if place then
17788: LD_VAR 0 6
17792: IFFALSE 17810
// ComEnterUnit ( driver , place ) else
17794: LD_VAR 0 1
17798: PPUSH
17799: LD_VAR 0 6
17803: PPUSH
17804: CALL_OW 120
17808: GO 17825
// ComMoveXY ( driver , 70 , 22 ) ;
17810: LD_VAR 0 1
17814: PPUSH
17815: LD_INT 70
17817: PPUSH
17818: LD_INT 22
17820: PPUSH
17821: CALL_OW 111
// end ; end ;
17825: PPOPN 6
17827: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17828: LD_VAR 0 1
17832: PUSH
17833: LD_INT 1
17835: EQUAL
17836: PUSH
17837: LD_VAR 0 2
17841: PUSH
17842: LD_INT 4
17844: EQUAL
17845: PUSH
17846: LD_VAR 0 2
17850: PUSH
17851: LD_INT 8
17853: EQUAL
17854: PUSH
17855: LD_EXP 5
17859: NOT
17860: AND
17861: OR
17862: AND
17863: IFFALSE 17872
// YouLost ( 5 ) ;
17865: LD_STRING 5
17867: PPUSH
17868: CALL_OW 104
// end ;
17872: PPOPN 2
17874: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17875: LD_EXP 35
17879: PUSH
17880: LD_INT 22
17882: PUSH
17883: LD_INT 1
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: PUSH
17890: LD_INT 21
17892: PUSH
17893: LD_INT 1
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: PUSH
17900: EMPTY
17901: LIST
17902: LIST
17903: PPUSH
17904: CALL_OW 69
17908: PUSH
17909: LD_INT 22
17911: PUSH
17912: LD_INT 8
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: PUSH
17919: LD_INT 21
17921: PUSH
17922: LD_INT 1
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PPUSH
17933: CALL_OW 69
17937: ADD
17938: PLUS
17939: PUSH
17940: LD_INT 5
17942: LESS
17943: IFFALSE 17955
17945: GO 17947
17947: DISABLE
// YouLost ( 1 ) ;
17948: LD_STRING 1
17950: PPUSH
17951: CALL_OW 104
17955: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17956: LD_INT 1
17958: PPUSH
17959: CALL_OW 255
17963: PUSH
17964: LD_INT 3
17966: EQUAL
17967: IFFALSE 17979
17969: GO 17971
17971: DISABLE
// YouLost ( 3 ) ;
17972: LD_STRING 3
17974: PPUSH
17975: CALL_OW 104
17979: END
