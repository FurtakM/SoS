// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 50 0 0
// SetDiplomacy ;
  15: CALL 378 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 29
// DebugMode ;
  25: CALL 466 0 0
// PrepareRussian ;
  29: CALL 3086 0 0
// PrepareAmerican ;
  33: CALL 1228 0 0
// PrepareCornell ;
  37: CALL 2315 0 0
// PrepareWesternBase ;
  41: CALL 2541 0 0
// Action ;
  45: CALL 5331 0 0
// end ;
  49: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , ach_counter , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  50: LD_INT 0
  52: PPUSH
// debug := false ;
  53: LD_ADDR_EXP 1
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  61: LD_ADDR_EXP 3
  65: PUSH
  66: LD_STRING 02_
  68: ST_TO_ADDR
// mission_prefix := 03_ ;
  69: LD_ADDR_EXP 2
  73: PUSH
  74: LD_STRING 03_
  76: ST_TO_ADDR
// jmm_units := 0 ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// cornel_units := 0 ;
  85: LD_ADDR_EXP 6
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// bierezov_exist := false ;
  93: LD_ADDR_EXP 7
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// jmm_on_west := false ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// cornel_active := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// cornel_attack := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// cornel_prepared := false ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 133: LD_ADDR_EXP 10
 137: PUSH
 138: LD_INT 4200
 140: ST_TO_ADDR
// frank_can_return := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// solar_builded := false ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// frank_send_to_scout := false ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// jmm_in_veh := false ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// bobby_in_veh := false ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// cyrus_in_veh := false ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// lisa_in_veh := false ;
 189: LD_ADDR_EXP 19
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 197: LD_ADDR_EXP 29
 201: PUSH
 202: LD_INT 25200
 204: PUSH
 205: LD_INT 23100
 207: PUSH
 208: LD_INT 21000
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_OWVAR 67
 220: ARRAY
 221: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 222: LD_ADDR_EXP 20
 226: PUSH
 227: LD_INT 600
 229: PUSH
 230: LD_INT 500
 232: PUSH
 233: LD_INT 400
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_OWVAR 67
 245: ARRAY
 246: ST_TO_ADDR
// end_mission_allowed := false ;
 247: LD_ADDR_EXP 21
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// save_others := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// save_group := [ ] ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// show_query := true ;
 269: LD_ADDR_EXP 24
 273: PUSH
 274: LD_INT 1
 276: ST_TO_ADDR
// wait_for_them := false ;
 277: LD_ADDR_EXP 25
 281: PUSH
 282: LD_INT 0
 284: ST_TO_ADDR
// veh_on_meta := false ;
 285: LD_ADDR_EXP 28
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// send_spec_patrol := false ;
 293: LD_ADDR_EXP 30
 297: PUSH
 298: LD_INT 0
 300: ST_TO_ADDR
// prepare_siege := false ;
 301: LD_ADDR_EXP 31
 305: PUSH
 306: LD_INT 0
 308: ST_TO_ADDR
// send_attack_on_cornel := false ;
 309: LD_ADDR_EXP 32
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 0
 324: ST_TO_ADDR
// game_end := false ;
 325: LD_ADDR_EXP 33
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// lose_counter := 0 ;
 333: LD_ADDR_EXP 34
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// powell_warn := 0 ;
 341: LD_ADDR_EXP 35
 345: PUSH
 346: LD_INT 0
 348: ST_TO_ADDR
// save_counter := 0 ;
 349: LD_ADDR_EXP 36
 353: PUSH
 354: LD_INT 0
 356: ST_TO_ADDR
// cornel_saved := false ;
 357: LD_ADDR_EXP 27
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// ach_counter := 0 ;
 365: LD_ADDR_EXP 13
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// end ;
 373: LD_VAR 0 1
 377: RET
// function SetDiplomacy ; begin
 378: LD_INT 0
 380: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 4
 386: PPUSH
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 8
 402: PPUSH
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 1
 408: PPUSH
 409: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 413: LD_INT 3
 415: PPUSH
 416: LD_INT 6
 418: PPUSH
 419: LD_INT 1
 421: PPUSH
 422: LD_INT 1
 424: PPUSH
 425: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 429: LD_INT 4
 431: PPUSH
 432: LD_INT 6
 434: PPUSH
 435: LD_INT 0
 437: PPUSH
 438: LD_INT 1
 440: PPUSH
 441: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 445: LD_INT 3
 447: PPUSH
 448: LD_INT 8
 450: PPUSH
 451: LD_INT 0
 453: PPUSH
 454: LD_INT 1
 456: PPUSH
 457: CALL_OW 80
// end ;
 461: LD_VAR 0 1
 465: RET
// export function DebugMode ; var i ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// FogOff ( 1 ) ;
 470: LD_INT 1
 472: PPUSH
 473: CALL_OW 344
// debug_strings := [ ] ;
 477: LD_ADDR_OWVAR 48
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// end ; end_of_file
 484: LD_VAR 0 1
 488: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 489: LD_INT 0
 491: PPUSH
 492: PPUSH
// if exist_mode then
 493: LD_VAR 0 2
 497: IFFALSE 522
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_EXP 3
 508: PUSH
 509: LD_VAR 0 1
 513: STR
 514: PPUSH
 515: CALL_OW 34
 519: ST_TO_ADDR
 520: GO 537
// unit := NewCharacter ( ident ) ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_VAR 0 1
 531: PPUSH
 532: CALL_OW 25
 536: ST_TO_ADDR
// result := unit ;
 537: LD_ADDR_VAR 0 3
 541: PUSH
 542: LD_VAR 0 4
 546: ST_TO_ADDR
// end ;
 547: LD_VAR 0 3
 551: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 552: LD_INT 0
 554: PPUSH
// uc_side := side ;
 555: LD_ADDR_OWVAR 20
 559: PUSH
 560: LD_VAR 0 1
 564: ST_TO_ADDR
// uc_nation := nation ;
 565: LD_ADDR_OWVAR 21
 569: PUSH
 570: LD_VAR 0 2
 574: ST_TO_ADDR
// vc_chassis := chassis ;
 575: LD_ADDR_OWVAR 37
 579: PUSH
 580: LD_VAR 0 3
 584: ST_TO_ADDR
// vc_engine := engine ;
 585: LD_ADDR_OWVAR 39
 589: PUSH
 590: LD_VAR 0 4
 594: ST_TO_ADDR
// vc_control := control ;
 595: LD_ADDR_OWVAR 38
 599: PUSH
 600: LD_VAR 0 5
 604: ST_TO_ADDR
// vc_weapon := weapon ;
 605: LD_ADDR_OWVAR 40
 609: PUSH
 610: LD_VAR 0 6
 614: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 615: LD_ADDR_OWVAR 41
 619: PUSH
 620: LD_VAR 0 7
 624: ST_TO_ADDR
// result := CreateVehicle ;
 625: LD_ADDR_VAR 0 8
 629: PUSH
 630: CALL_OW 45
 634: ST_TO_ADDR
// end ;
 635: LD_VAR 0 8
 639: RET
// export function SayX ( units , ident ) ; var i ; begin
 640: LD_INT 0
 642: PPUSH
 643: PPUSH
// result := false ;
 644: LD_ADDR_VAR 0 3
 648: PUSH
 649: LD_INT 0
 651: ST_TO_ADDR
// if not units then
 652: LD_VAR 0 1
 656: NOT
 657: IFFALSE 661
// exit ;
 659: GO 715
// for i in units do
 661: LD_ADDR_VAR 0 4
 665: PUSH
 666: LD_VAR 0 1
 670: PUSH
 671: FOR_IN
 672: IFFALSE 713
// if IsOk ( i ) then
 674: LD_VAR 0 4
 678: PPUSH
 679: CALL_OW 302
 683: IFFALSE 711
// begin Say ( i , ident ) ;
 685: LD_VAR 0 4
 689: PPUSH
 690: LD_VAR 0 2
 694: PPUSH
 695: CALL_OW 88
// result := i ;
 699: LD_ADDR_VAR 0 3
 703: PUSH
 704: LD_VAR 0 4
 708: ST_TO_ADDR
// break ;
 709: GO 713
// end ;
 711: GO 671
 713: POP
 714: POP
// end ;
 715: LD_VAR 0 3
 719: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 720: LD_INT 0
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
// for i = 1 to count do
 726: LD_ADDR_VAR 0 8
 730: PUSH
 731: DOUBLE
 732: LD_INT 1
 734: DEC
 735: ST_TO_ADDR
 736: LD_VAR 0 6
 740: PUSH
 741: FOR_TO
 742: IFFALSE 823
// begin uc_side = side ;
 744: LD_ADDR_OWVAR 20
 748: PUSH
 749: LD_VAR 0 1
 753: ST_TO_ADDR
// uc_nation = nation ;
 754: LD_ADDR_OWVAR 21
 758: PUSH
 759: LD_VAR 0 2
 763: ST_TO_ADDR
// hc_gallery =  ;
 764: LD_ADDR_OWVAR 33
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// hc_name =  ;
 772: LD_ADDR_OWVAR 26
 776: PUSH
 777: LD_STRING 
 779: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 780: LD_INT 0
 782: PPUSH
 783: LD_VAR 0 5
 787: PPUSH
 788: LD_VAR 0 4
 792: PPUSH
 793: CALL_OW 380
// un = CreateHuman ;
 797: LD_ADDR_VAR 0 10
 801: PUSH
 802: CALL_OW 44
 806: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 807: LD_VAR 0 10
 811: PPUSH
 812: LD_VAR 0 3
 816: PPUSH
 817: CALL_OW 52
// end ;
 821: GO 741
 823: POP
 824: POP
// end ;
 825: LD_VAR 0 7
 829: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 830: LD_INT 0
 832: PPUSH
 833: PPUSH
 834: PPUSH
// uc_side := GetSide ( b ) ;
 835: LD_ADDR_OWVAR 20
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 255
 849: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 850: LD_ADDR_OWVAR 21
 854: PUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: CALL_OW 248
 864: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 865: LD_INT 0
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: LD_VAR 0 1
 875: PPUSH
 876: CALL_OW 380
// un = CreateHuman ;
 880: LD_ADDR_VAR 0 4
 884: PUSH
 885: CALL_OW 44
 889: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 890: LD_ADDR_VAR 0 5
 894: PUSH
 895: LD_VAR 0 2
 899: PPUSH
 900: CALL_OW 254
 904: PUSH
 905: LD_INT 3
 907: MINUS
 908: ST_TO_ADDR
// if dir < 0 then
 909: LD_VAR 0 5
 913: PUSH
 914: LD_INT 0
 916: LESS
 917: IFFALSE 933
// dir := 6 + dir ;
 919: LD_ADDR_VAR 0 5
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: LD_VAR 0 5
 931: PLUS
 932: ST_TO_ADDR
// SetDir ( un , dir ) ;
 933: LD_VAR 0 4
 937: PPUSH
 938: LD_VAR 0 5
 942: PPUSH
 943: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 947: LD_VAR 0 4
 951: PPUSH
 952: LD_VAR 0 2
 956: PPUSH
 957: CALL_OW 52
// end ;
 961: LD_VAR 0 3
 965: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 966: LD_INT 0
 968: PPUSH
 969: PPUSH
 970: PPUSH
// result := false ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 979: LD_ADDR_VAR 0 3
 983: PUSH
 984: LD_INT 22
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 34
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: PPUSH
1008: CALL_OW 69
1012: ST_TO_ADDR
// for i in filter do
1013: LD_ADDR_VAR 0 4
1017: PUSH
1018: LD_VAR 0 3
1022: PUSH
1023: FOR_IN
1024: IFFALSE 1055
// if IsDrivenBy ( i ) = unit then
1026: LD_VAR 0 4
1030: PPUSH
1031: CALL_OW 311
1035: PUSH
1036: LD_VAR 0 1
1040: EQUAL
1041: IFFALSE 1053
// begin result := true ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 1
1050: ST_TO_ADDR
// break ;
1051: GO 1055
// end ;
1053: GO 1023
1055: POP
1056: POP
// end ;
1057: LD_VAR 0 2
1061: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1062: LD_INT 0
1064: PPUSH
1065: PPUSH
// result := false ;
1066: LD_ADDR_VAR 0 2
1070: PUSH
1071: LD_INT 0
1073: ST_TO_ADDR
// if not blist then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1127
// for i in blist do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: LD_VAR 0 1
1092: PUSH
1093: FOR_IN
1094: IFFALSE 1125
// if UnitsInside ( i ) < 6 then
1096: LD_VAR 0 3
1100: PPUSH
1101: CALL_OW 313
1105: PUSH
1106: LD_INT 6
1108: LESS
1109: IFFALSE 1123
// begin result := i ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 3
1120: ST_TO_ADDR
// break ;
1121: GO 1125
// end ;
1123: GO 1093
1125: POP
1126: POP
// end ;
1127: LD_VAR 0 2
1131: RET
// export function Count ( timer , mode ) ; begin
1132: LD_INT 0
1134: PPUSH
// if not timer then
1135: LD_VAR 0 1
1139: NOT
1140: IFFALSE 1144
// exit ;
1142: GO 1195
// if mode in [ asc , up , + ] then
1144: LD_VAR 0 2
1148: PUSH
1149: LD_STRING asc
1151: PUSH
1152: LD_STRING up
1154: PUSH
1155: LD_STRING +
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: IN
1163: IFFALSE 1181
// result := timer + 0 0$01 else
1165: LD_ADDR_VAR 0 3
1169: PUSH
1170: LD_VAR 0 1
1174: PUSH
1175: LD_INT 35
1177: PLUS
1178: ST_TO_ADDR
1179: GO 1195
// result := timer - 0 0$01 ;
1181: LD_ADDR_VAR 0 3
1185: PUSH
1186: LD_VAR 0 1
1190: PUSH
1191: LD_INT 35
1193: MINUS
1194: ST_TO_ADDR
// end ;
1195: LD_VAR 0 3
1199: RET
// export function Video ( mode ) ; begin
1200: LD_INT 0
1202: PPUSH
// ingame_video = mode ;
1203: LD_ADDR_OWVAR 52
1207: PUSH
1208: LD_VAR 0 1
1212: ST_TO_ADDR
// interface_hidden = mode ;
1213: LD_ADDR_OWVAR 54
1217: PUSH
1218: LD_VAR 0 1
1222: ST_TO_ADDR
// end ; end_of_file
1223: LD_VAR 0 2
1227: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1228: LD_INT 0
1230: PPUSH
1231: PPUSH
1232: PPUSH
1233: PPUSH
1234: PPUSH
1235: PPUSH
1236: PPUSH
1237: PPUSH
// uc_side := 4 ;
1238: LD_ADDR_OWVAR 20
1242: PUSH
1243: LD_INT 4
1245: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1246: LD_ADDR_EXP 46
1250: PUSH
1251: LD_STRING Powell
1253: PPUSH
1254: LD_INT 0
1256: PPUSH
1257: CALL 489 0 2
1261: ST_TO_ADDR
// uc_side := 1 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
// uc_nation := 1 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 1
1277: ST_TO_ADDR
// if debug then
1278: LD_EXP 1
1282: IFFALSE 1412
// begin for i = 1 to 4 do
1284: LD_ADDR_VAR 0 2
1288: PUSH
1289: DOUBLE
1290: LD_INT 1
1292: DEC
1293: ST_TO_ADDR
1294: LD_INT 4
1296: PUSH
1297: FOR_TO
1298: IFFALSE 1349
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1300: LD_INT 0
1302: PPUSH
1303: LD_INT 1
1305: PPUSH
1306: LD_INT 2
1308: PPUSH
1309: CALL_OW 12
1313: PPUSH
1314: LD_INT 3
1316: PPUSH
1317: CALL_OW 380
// un := CreateHuman ;
1321: LD_ADDR_VAR 0 3
1325: PUSH
1326: CALL_OW 44
1330: ST_TO_ADDR
// others := others ^ un ;
1331: LD_ADDR_VAR 0 5
1335: PUSH
1336: LD_VAR 0 5
1340: PUSH
1341: LD_VAR 0 3
1345: ADD
1346: ST_TO_ADDR
// end ;
1347: GO 1297
1349: POP
1350: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1351: LD_ADDR_VAR 0 6
1355: PUSH
1356: LD_INT 21
1358: PUSH
1359: LD_INT 1
1361: PUSH
1362: LD_INT 1
1364: PUSH
1365: LD_INT 51
1367: PUSH
1368: LD_INT 90
1370: PUSH
1371: LD_INT 504
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: PUSH
1382: LD_INT 21
1384: PUSH
1385: LD_INT 1
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: LD_INT 51
1393: PUSH
1394: LD_INT 80
1396: PUSH
1397: LD_INT 750
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1412: LD_ADDR_EXP 37
1416: PUSH
1417: LD_STRING JMM
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: CALL 489 0 2
1430: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1431: LD_ADDR_EXP 38
1435: PUSH
1436: LD_STRING Bobby
1438: PPUSH
1439: LD_EXP 1
1443: NOT
1444: PPUSH
1445: CALL 489 0 2
1449: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1450: LD_ADDR_EXP 39
1454: PUSH
1455: LD_STRING Cyrus
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: CALL 489 0 2
1468: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1469: LD_ADDR_EXP 40
1473: PUSH
1474: LD_STRING Lisa
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: CALL 489 0 2
1487: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1488: LD_ADDR_EXP 41
1492: PUSH
1493: LD_STRING Khatam
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: CALL 489 0 2
1506: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1507: LD_ADDR_EXP 42
1511: PUSH
1512: LD_STRING Brian
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: CALL 489 0 2
1525: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1526: LD_ADDR_EXP 43
1530: PUSH
1531: LD_STRING Jerry
1533: PPUSH
1534: LD_EXP 1
1538: NOT
1539: PPUSH
1540: CALL 489 0 2
1544: ST_TO_ADDR
// if Bobby then
1545: LD_EXP 38
1549: IFFALSE 1580
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 4
1565: PUSH
1566: LD_INT 1
1568: PLUS
1569: PPUSH
1570: LD_EXP 38
1574: PPUSH
1575: CALL_OW 2
1579: ST_TO_ADDR
// if Cyrus then
1580: LD_EXP 39
1584: IFFALSE 1615
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_VAR 0 4
1595: PPUSH
1596: LD_VAR 0 4
1600: PUSH
1601: LD_INT 1
1603: PLUS
1604: PPUSH
1605: LD_EXP 39
1609: PPUSH
1610: CALL_OW 2
1614: ST_TO_ADDR
// if Lisa then
1615: LD_EXP 40
1619: IFFALSE 1650
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1621: LD_ADDR_VAR 0 4
1625: PUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: LD_VAR 0 4
1635: PUSH
1636: LD_INT 1
1638: PLUS
1639: PPUSH
1640: LD_EXP 40
1644: PPUSH
1645: CALL_OW 2
1649: ST_TO_ADDR
// if Khatam then
1650: LD_EXP 41
1654: IFFALSE 1685
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1656: LD_ADDR_VAR 0 4
1660: PUSH
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_VAR 0 4
1670: PUSH
1671: LD_INT 1
1673: PLUS
1674: PPUSH
1675: LD_EXP 41
1679: PPUSH
1680: CALL_OW 2
1684: ST_TO_ADDR
// if Brian then
1685: LD_EXP 42
1689: IFFALSE 1720
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_VAR 0 4
1700: PPUSH
1701: LD_VAR 0 4
1705: PUSH
1706: LD_INT 1
1708: PLUS
1709: PPUSH
1710: LD_EXP 42
1714: PPUSH
1715: CALL_OW 2
1719: ST_TO_ADDR
// if Jerry then
1720: LD_EXP 43
1724: IFFALSE 1755
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1726: LD_ADDR_VAR 0 4
1730: PUSH
1731: LD_VAR 0 4
1735: PPUSH
1736: LD_VAR 0 4
1740: PUSH
1741: LD_INT 1
1743: PLUS
1744: PPUSH
1745: LD_EXP 43
1749: PPUSH
1750: CALL_OW 2
1754: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1755: LD_STRING 02_other_survivors
1757: PPUSH
1758: CALL_OW 28
1762: IFFALSE 1777
// others := CreateCharacterSet ( 02_other_survivors ) ;
1764: LD_ADDR_VAR 0 5
1768: PUSH
1769: LD_STRING 02_other_survivors
1771: PPUSH
1772: CALL_OW 31
1776: ST_TO_ADDR
// if others then
1777: LD_VAR 0 5
1781: IFFALSE 1806
// begin tmp := tmp ^ others ;
1783: LD_ADDR_VAR 0 4
1787: PUSH
1788: LD_VAR 0 4
1792: PUSH
1793: LD_VAR 0 5
1797: ADD
1798: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1799: LD_STRING 02_other_survivors
1801: PPUSH
1802: CALL_OW 40
// end ; jmm_units := tmp ;
1806: LD_ADDR_EXP 4
1810: PUSH
1811: LD_VAR 0 4
1815: ST_TO_ADDR
// if not vehicles then
1816: LD_VAR 0 6
1820: NOT
1821: IFFALSE 1839
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1823: LD_ADDR_VAR 0 6
1827: PUSH
1828: LD_STRING 02_tanks_1
1830: PPUSH
1831: LD_INT 0
1833: PPUSH
1834: CALL_OW 30
1838: ST_TO_ADDR
// if vehicles then
1839: LD_VAR 0 6
1843: IFFALSE 2037
// begin got_mech := false ;
1845: LD_ADDR_VAR 0 7
1849: PUSH
1850: LD_INT 0
1852: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 3
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PPUSH
1868: CALL_OW 72
1872: IFFALSE 1882
// got_mech := true ;
1874: LD_ADDR_VAR 0 7
1878: PUSH
1879: LD_INT 1
1881: ST_TO_ADDR
// for i = 1 to vehicles do
1882: LD_ADDR_VAR 0 2
1886: PUSH
1887: DOUBLE
1888: LD_INT 1
1890: DEC
1891: ST_TO_ADDR
1892: LD_VAR 0 6
1896: PUSH
1897: FOR_TO
1898: IFFALSE 2035
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1900: LD_ADDR_VAR 0 3
1904: PUSH
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 3
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 2
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 3
1954: ARRAY
1955: PPUSH
1956: LD_VAR 0 6
1960: PUSH
1961: LD_VAR 0 2
1965: ARRAY
1966: PUSH
1967: LD_INT 4
1969: ARRAY
1970: PPUSH
1971: LD_INT 40
1973: PPUSH
1974: CALL 552 0 7
1978: ST_TO_ADDR
// if not got_mech then
1979: LD_VAR 0 7
1983: NOT
1984: IFFALSE 2010
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 6
1995: PUSH
1996: LD_VAR 0 2
2000: ARRAY
2001: PUSH
2002: LD_INT 6
2004: ARRAY
2005: PPUSH
2006: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
2010: LD_ADDR_VAR 0 4
2014: PUSH
2015: LD_VAR 0 4
2019: PPUSH
2020: LD_INT 1
2022: PPUSH
2023: LD_VAR 0 3
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
// end ;
2033: GO 1897
2035: POP
2036: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2037: LD_EXP 37
2041: PPUSH
2042: LD_INT 194
2044: PPUSH
2045: LD_INT 119
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 48
// if tmp then
2055: LD_VAR 0 4
2059: IFFALSE 2247
// begin for i in tmp do
2061: LD_ADDR_VAR 0 2
2065: PUSH
2066: LD_VAR 0 4
2070: PUSH
2071: FOR_IN
2072: IFFALSE 2245
// begin if GetClass ( i ) <> 1 and i <> Khatam then
2074: LD_VAR 0 2
2078: PPUSH
2079: CALL_OW 257
2083: PUSH
2084: LD_INT 1
2086: NONEQUAL
2087: PUSH
2088: LD_VAR 0 2
2092: PUSH
2093: LD_EXP 41
2097: NONEQUAL
2098: AND
2099: IFFALSE 2113
// SetClass ( i , 1 ) ;
2101: LD_VAR 0 2
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: CALL_OW 336
// if i = Khatam then
2113: LD_VAR 0 2
2117: PUSH
2118: LD_EXP 41
2122: EQUAL
2123: IFFALSE 2137
// SetClass ( i , 4 ) ;
2125: LD_VAR 0 2
2129: PPUSH
2130: LD_INT 4
2132: PPUSH
2133: CALL_OW 336
// empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2137: LD_ADDR_VAR 0 8
2141: PUSH
2142: LD_INT 22
2144: PUSH
2145: LD_INT 1
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 21
2154: PUSH
2155: LD_INT 2
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: LD_INT 58
2164: PUSH
2165: EMPTY
2166: LIST
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 69
2177: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2178: LD_VAR 0 2
2182: PPUSH
2183: CALL_OW 247
2187: PUSH
2188: LD_INT 1
2190: EQUAL
2191: PUSH
2192: LD_VAR 0 8
2196: AND
2197: IFFALSE 2219
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2199: LD_VAR 0 2
2203: PPUSH
2204: LD_VAR 0 8
2208: PUSH
2209: LD_INT 1
2211: ARRAY
2212: PPUSH
2213: CALL_OW 52
2217: GO 2234
// PlaceUnitArea ( i , startArea , false ) ;
2219: LD_VAR 0 2
2223: PPUSH
2224: LD_INT 1
2226: PPUSH
2227: LD_INT 0
2229: PPUSH
2230: CALL_OW 49
// ComHold ( i ) ;
2234: LD_VAR 0 2
2238: PPUSH
2239: CALL_OW 140
// end ;
2243: GO 2071
2245: POP
2246: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2247: LD_ADDR_EXP 7
2251: PUSH
2252: LD_STRING 02_mikhailStatus_1
2254: PPUSH
2255: LD_INT 0
2257: PPUSH
2258: CALL_OW 30
2262: ST_TO_ADDR
// if not bierezov_exist and not debug then
2263: LD_EXP 7
2267: NOT
2268: PUSH
2269: LD_EXP 1
2273: NOT
2274: AND
2275: IFFALSE 2279
// exit ;
2277: GO 2310
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2279: LD_ADDR_EXP 45
2283: PUSH
2284: LD_STRING Mikhail
2286: PPUSH
2287: LD_INT 0
2289: PPUSH
2290: CALL 489 0 2
2294: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2295: LD_EXP 45
2299: PPUSH
2300: LD_INT 1
2302: PPUSH
2303: LD_INT 0
2305: PPUSH
2306: CALL_OW 49
// end ;
2310: LD_VAR 0 1
2314: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2315: LD_INT 0
2317: PPUSH
2318: PPUSH
2319: PPUSH
2320: PPUSH
// uc_side := 4 ;
2321: LD_ADDR_OWVAR 20
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// uc_nation := 1 ;
2329: LD_ADDR_OWVAR 21
2333: PUSH
2334: LD_INT 1
2336: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2337: LD_ADDR_EXP 44
2341: PUSH
2342: LD_STRING Cornell
2344: PPUSH
2345: LD_INT 0
2347: PPUSH
2348: CALL 489 0 2
2352: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2353: LD_ADDR_EXP 6
2357: PUSH
2358: LD_INT 9
2360: PUSH
2361: LD_EXP 4
2365: MINUS
2366: ST_TO_ADDR
// tmp := [ ] ;
2367: LD_ADDR_VAR 0 2
2371: PUSH
2372: EMPTY
2373: ST_TO_ADDR
// if cornel_units < 4 then
2374: LD_EXP 6
2378: PUSH
2379: LD_INT 4
2381: LESS
2382: IFFALSE 2392
// cornel_units := 4 ;
2384: LD_ADDR_EXP 6
2388: PUSH
2389: LD_INT 4
2391: ST_TO_ADDR
// for i = 1 to cornel_units do
2392: LD_ADDR_VAR 0 4
2396: PUSH
2397: DOUBLE
2398: LD_INT 1
2400: DEC
2401: ST_TO_ADDR
2402: LD_EXP 6
2406: PUSH
2407: FOR_TO
2408: IFFALSE 2506
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2410: LD_INT 0
2412: PPUSH
2413: LD_INT 1
2415: PUSH
2416: LD_INT 1
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: LD_INT 2
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_VAR 0 4
2439: PUSH
2440: LD_INT 5
2442: MOD
2443: PUSH
2444: LD_INT 1
2446: PLUS
2447: ARRAY
2448: PPUSH
2449: LD_INT 2
2451: PPUSH
2452: CALL_OW 380
// un := CreateHuman ;
2456: LD_ADDR_VAR 0 3
2460: PUSH
2461: CALL_OW 44
2465: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2466: LD_ADDR_VAR 0 2
2470: PUSH
2471: LD_VAR 0 2
2475: PPUSH
2476: LD_INT 1
2478: PPUSH
2479: LD_VAR 0 3
2483: PPUSH
2484: CALL_OW 2
2488: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2489: LD_VAR 0 3
2493: PPUSH
2494: LD_INT 2
2496: PPUSH
2497: LD_INT 0
2499: PPUSH
2500: CALL_OW 49
// end ;
2504: GO 2407
2506: POP
2507: POP
// cornel_units := tmp ;
2508: LD_ADDR_EXP 6
2512: PUSH
2513: LD_VAR 0 2
2517: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2518: LD_EXP 44
2522: PPUSH
2523: LD_INT 191
2525: PPUSH
2526: LD_INT 106
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: CALL_OW 48
// end ;
2536: LD_VAR 0 1
2540: RET
// export function PrepareWesternBase ; var i ; begin
2541: LD_INT 0
2543: PPUSH
2544: PPUSH
// uc_side := 8 ;
2545: LD_ADDR_OWVAR 20
2549: PUSH
2550: LD_INT 8
2552: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2553: LD_ADDR_EXP 47
2557: PUSH
2558: LD_STRING Lynch
2560: PPUSH
2561: LD_INT 0
2563: PPUSH
2564: CALL 489 0 2
2568: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2569: LD_ADDR_EXP 48
2573: PUSH
2574: LD_STRING Walker
2576: PPUSH
2577: LD_INT 0
2579: PPUSH
2580: CALL 489 0 2
2584: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2585: LD_ADDR_EXP 49
2589: PUSH
2590: LD_STRING Turner
2592: PPUSH
2593: LD_INT 0
2595: PPUSH
2596: CALL 489 0 2
2600: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2601: LD_ADDR_EXP 50
2605: PUSH
2606: LD_STRING Jillian
2608: PPUSH
2609: LD_INT 0
2611: PPUSH
2612: CALL 489 0 2
2616: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2617: LD_ADDR_VAR 0 2
2621: PUSH
2622: LD_EXP 47
2626: PUSH
2627: LD_EXP 48
2631: PUSH
2632: LD_EXP 49
2636: PUSH
2637: LD_EXP 50
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: PUSH
2648: FOR_IN
2649: IFFALSE 2677
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 3
2658: PPUSH
2659: LD_INT 0
2661: PPUSH
2662: CALL_OW 49
// ComHold ( i ) ;
2666: LD_VAR 0 2
2670: PPUSH
2671: CALL_OW 140
// end ;
2675: GO 2648
2677: POP
2678: POP
// end ;
2679: LD_VAR 0 1
2683: RET
// export function SelectGroup ; var units , selected , i ; begin
2684: LD_INT 0
2686: PPUSH
2687: PPUSH
2688: PPUSH
2689: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2690: LD_ADDR_VAR 0 2
2694: PUSH
2695: LD_EXP 37
2699: PUSH
2700: LD_INT -3
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_EXP 4
2711: ADD
2712: PUSH
2713: LD_INT -2
2715: PUSH
2716: LD_INT -4
2718: PUSH
2719: LD_EXP 44
2723: PUSH
2724: LD_EXP 45
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: LIST
2734: ADD
2735: PUSH
2736: LD_INT -3
2738: PUSH
2739: EMPTY
2740: LIST
2741: ADD
2742: PUSH
2743: LD_EXP 6
2747: ADD
2748: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 37
2758: PUSH
2759: LD_STRING Select five characters to go with you
2761: PPUSH
2762: LD_INT 4
2764: PPUSH
2765: LD_INT 4
2767: PPUSH
2768: LD_VAR 0 2
2772: PPUSH
2773: EMPTY
2774: PPUSH
2775: CALL_OW 42
2779: ADD
2780: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2781: LD_ADDR_EXP 6
2785: PUSH
2786: LD_EXP 4
2790: PUSH
2791: LD_EXP 6
2795: UNION
2796: PUSH
2797: LD_VAR 0 3
2801: DIFF
2802: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2803: LD_ADDR_VAR 0 4
2807: PUSH
2808: LD_EXP 6
2812: PUSH
2813: LD_EXP 45
2817: ADD
2818: PUSH
2819: FOR_IN
2820: IFFALSE 2851
// if GetSide ( i ) = 1 then
2822: LD_VAR 0 4
2826: PPUSH
2827: CALL_OW 255
2831: PUSH
2832: LD_INT 1
2834: EQUAL
2835: IFFALSE 2849
// SetSide ( i , 4 ) ;
2837: LD_VAR 0 4
2841: PPUSH
2842: LD_INT 4
2844: PPUSH
2845: CALL_OW 235
2849: GO 2819
2851: POP
2852: POP
// for i in selected do
2853: LD_ADDR_VAR 0 4
2857: PUSH
2858: LD_VAR 0 3
2862: PUSH
2863: FOR_IN
2864: IFFALSE 2895
// if GetSide ( i ) = 4 then
2866: LD_VAR 0 4
2870: PPUSH
2871: CALL_OW 255
2875: PUSH
2876: LD_INT 4
2878: EQUAL
2879: IFFALSE 2893
// SetSide ( i , 1 ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 1
2888: PPUSH
2889: CALL_OW 235
2893: GO 2863
2895: POP
2896: POP
// jmm_units := jmm_units diff cornel_units ;
2897: LD_ADDR_EXP 4
2901: PUSH
2902: LD_EXP 4
2906: PUSH
2907: LD_EXP 6
2911: DIFF
2912: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2913: LD_EXP 38
2917: PPUSH
2918: CALL_OW 255
2922: PUSH
2923: LD_INT 4
2925: EQUAL
2926: IFFALSE 2941
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2928: LD_EXP 3
2932: PUSH
2933: LD_STRING Bobby
2935: STR
2936: PPUSH
2937: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2941: LD_EXP 39
2945: PPUSH
2946: CALL_OW 255
2950: PUSH
2951: LD_INT 4
2953: EQUAL
2954: IFFALSE 2969
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2956: LD_EXP 3
2960: PUSH
2961: LD_STRING Cyrus
2963: STR
2964: PPUSH
2965: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2969: LD_EXP 40
2973: PPUSH
2974: CALL_OW 255
2978: PUSH
2979: LD_INT 4
2981: EQUAL
2982: IFFALSE 2997
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2984: LD_EXP 3
2988: PUSH
2989: LD_STRING Lisa
2991: STR
2992: PPUSH
2993: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2997: LD_EXP 41
3001: PPUSH
3002: CALL_OW 255
3006: PUSH
3007: LD_INT 4
3009: EQUAL
3010: IFFALSE 3025
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
3012: LD_EXP 3
3016: PUSH
3017: LD_STRING Khatam
3019: STR
3020: PPUSH
3021: CALL_OW 40
// if GetSide ( Brian ) = 4 then
3025: LD_EXP 42
3029: PPUSH
3030: CALL_OW 255
3034: PUSH
3035: LD_INT 4
3037: EQUAL
3038: IFFALSE 3053
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
3040: LD_EXP 3
3044: PUSH
3045: LD_STRING Brian
3047: STR
3048: PPUSH
3049: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
3053: LD_EXP 43
3057: PPUSH
3058: CALL_OW 255
3062: PUSH
3063: LD_INT 4
3065: EQUAL
3066: IFFALSE 3081
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
3068: LD_EXP 3
3072: PUSH
3073: LD_STRING Jerry
3075: STR
3076: PPUSH
3077: CALL_OW 40
// end ; end_of_file
3081: LD_VAR 0 1
3085: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3086: LD_INT 0
3088: PPUSH
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
3100: PPUSH
// ru_alert := false ;
3101: LD_ADDR_EXP 60
3105: PUSH
3106: LD_INT 0
3108: ST_TO_ADDR
// ru_produce_list := [ ] ;
3109: LD_ADDR_EXP 57
3113: PUSH
3114: EMPTY
3115: ST_TO_ADDR
// if Difficulty > 1 then
3116: LD_OWVAR 67
3120: PUSH
3121: LD_INT 1
3123: GREATER
3124: IFFALSE 3212
// begin uc_side := 3 ;
3126: LD_ADDR_OWVAR 20
3130: PUSH
3131: LD_INT 3
3133: ST_TO_ADDR
// uc_nation := 3 ;
3134: LD_ADDR_OWVAR 21
3138: PUSH
3139: LD_INT 3
3141: ST_TO_ADDR
// bc_type := b_breastwork ;
3142: LD_ADDR_OWVAR 42
3146: PUSH
3147: LD_INT 31
3149: ST_TO_ADDR
// bc_level := Difficulty ;
3150: LD_ADDR_OWVAR 43
3154: PUSH
3155: LD_OWVAR 67
3159: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3160: LD_INT 22
3162: PPUSH
3163: LD_INT 14
3165: PPUSH
3166: LD_INT 0
3168: PPUSH
3169: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3173: LD_INT 48
3175: PPUSH
3176: LD_INT 46
3178: PPUSH
3179: LD_INT 0
3181: PPUSH
3182: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3186: LD_INT 86
3188: PPUSH
3189: LD_INT 65
3191: PPUSH
3192: LD_INT 5
3194: PPUSH
3195: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3199: LD_INT 165
3201: PPUSH
3202: LD_INT 73
3204: PPUSH
3205: LD_INT 5
3207: PPUSH
3208: CALL_OW 47
// end ; if Difficulty = 3 then
3212: LD_OWVAR 67
3216: PUSH
3217: LD_INT 3
3219: EQUAL
3220: IFFALSE 3235
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3222: LD_INT 51
3224: PPUSH
3225: LD_INT 3
3227: PPUSH
3228: LD_INT 2
3230: PPUSH
3231: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3235: LD_ADDR_VAR 0 7
3239: PUSH
3240: LD_INT 22
3242: PUSH
3243: LD_INT 3
3245: PUSH
3246: EMPTY
3247: LIST
3248: LIST
3249: PUSH
3250: LD_INT 2
3252: PUSH
3253: LD_INT 30
3255: PUSH
3256: LD_INT 31
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 30
3265: PUSH
3266: LD_INT 32
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 69
3286: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3287: LD_ADDR_VAR 0 8
3291: PUSH
3292: LD_INT 22
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 30
3304: PUSH
3305: LD_INT 4
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PPUSH
3316: CALL_OW 69
3320: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3321: LD_ADDR_VAR 0 10
3325: PUSH
3326: LD_INT 22
3328: PUSH
3329: LD_INT 3
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: LD_INT 30
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: PPUSH
3350: CALL_OW 69
3354: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3355: LD_ADDR_VAR 0 9
3359: PUSH
3360: LD_INT 22
3362: PUSH
3363: LD_INT 3
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: PUSH
3370: LD_INT 30
3372: PUSH
3373: LD_INT 6
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PPUSH
3384: CALL_OW 69
3388: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3389: LD_ADDR_VAR 0 2
3393: PUSH
3394: LD_INT 22
3396: PUSH
3397: LD_INT 3
3399: PUSH
3400: EMPTY
3401: LIST
3402: LIST
3403: PUSH
3404: LD_INT 30
3406: PUSH
3407: LD_INT 1
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PPUSH
3418: CALL_OW 69
3422: PUSH
3423: FOR_IN
3424: IFFALSE 3468
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3426: LD_VAR 0 2
3430: PPUSH
3431: CALL_OW 274
3435: PPUSH
3436: LD_INT 1
3438: PPUSH
3439: LD_INT 5000
3441: PPUSH
3442: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 274
3455: PPUSH
3456: LD_INT 2
3458: PPUSH
3459: LD_INT 3000
3461: PPUSH
3462: CALL_OW 277
// end ;
3466: GO 3423
3468: POP
3469: POP
// uc_side := 3 ;
3470: LD_ADDR_OWVAR 20
3474: PUSH
3475: LD_INT 3
3477: ST_TO_ADDR
// uc_nation := 3 ;
3478: LD_ADDR_OWVAR 21
3482: PUSH
3483: LD_INT 3
3485: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3486: LD_ADDR_VAR 0 11
3490: PUSH
3491: LD_INT 2
3493: PUSH
3494: LD_INT 3
3496: PUSH
3497: LD_INT 4
3499: PUSH
3500: EMPTY
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_OWVAR 67
3509: ARRAY
3510: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3511: LD_ADDR_EXP 52
3515: PUSH
3516: LD_STRING Pokryshkin
3518: PPUSH
3519: LD_INT 0
3521: PPUSH
3522: CALL 489 0 2
3526: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3527: LD_EXP 52
3531: PPUSH
3532: LD_INT 63
3534: PPUSH
3535: LD_INT 21
3537: PPUSH
3538: LD_INT 0
3540: PPUSH
3541: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3545: LD_EXP 52
3549: PPUSH
3550: CALL_OW 140
// InitHc ;
3554: CALL_OW 19
// for i in fac do
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: LD_VAR 0 10
3567: PUSH
3568: FOR_IN
3569: IFFALSE 3622
// begin for j = 1 to 6 do
3571: LD_ADDR_VAR 0 3
3575: PUSH
3576: DOUBLE
3577: LD_INT 1
3579: DEC
3580: ST_TO_ADDR
3581: LD_INT 6
3583: PUSH
3584: FOR_TO
3585: IFFALSE 3618
// begin PrepareHuman ( false , 3 , skill ) ;
3587: LD_INT 0
3589: PPUSH
3590: LD_INT 3
3592: PPUSH
3593: LD_VAR 0 11
3597: PPUSH
3598: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3602: CALL_OW 44
3606: PPUSH
3607: LD_VAR 0 2
3611: PPUSH
3612: CALL_OW 52
// end ;
3616: GO 3584
3618: POP
3619: POP
// end ;
3620: GO 3568
3622: POP
3623: POP
// for i in lab do
3624: LD_ADDR_VAR 0 2
3628: PUSH
3629: LD_VAR 0 9
3633: PUSH
3634: FOR_IN
3635: IFFALSE 3668
// begin PrepareHuman ( false , 4 , skill ) ;
3637: LD_INT 0
3639: PPUSH
3640: LD_INT 4
3642: PPUSH
3643: LD_VAR 0 11
3647: PPUSH
3648: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3652: CALL_OW 44
3656: PPUSH
3657: LD_VAR 0 2
3661: PPUSH
3662: CALL_OW 52
// end ;
3666: GO 3634
3668: POP
3669: POP
// for i in tw do
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 7
3679: PUSH
3680: FOR_IN
3681: IFFALSE 3730
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3683: LD_VAR 0 2
3687: PPUSH
3688: LD_INT 42
3690: PUSH
3691: LD_INT 43
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: PUSH
3698: LD_INT 1
3700: PPUSH
3701: LD_INT 2
3703: PPUSH
3704: CALL_OW 12
3708: ARRAY
3709: PPUSH
3710: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3714: LD_VAR 0 11
3718: PPUSH
3719: LD_VAR 0 2
3723: PPUSH
3724: CALL 830 0 2
// end ;
3728: GO 3680
3730: POP
3731: POP
// for i in bar do
3732: LD_ADDR_VAR 0 2
3736: PUSH
3737: LD_VAR 0 8
3741: PUSH
3742: FOR_IN
3743: IFFALSE 3776
// begin PrepareHuman ( false , 1 , skill ) ;
3745: LD_INT 0
3747: PPUSH
3748: LD_INT 1
3750: PPUSH
3751: LD_VAR 0 11
3755: PPUSH
3756: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3760: CALL_OW 44
3764: PPUSH
3765: LD_VAR 0 2
3769: PPUSH
3770: CALL_OW 52
// end ;
3774: GO 3742
3776: POP
3777: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3778: LD_ADDR_VAR 0 13
3782: PUSH
3783: LD_INT 100
3785: PUSH
3786: LD_INT 9
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: LD_INT 135
3795: PUSH
3796: LD_INT 60
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 41
3805: PUSH
3806: LD_INT 6
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 22
3815: PUSH
3816: LD_INT 9
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: LD_INT 84
3825: PUSH
3826: LD_INT 14
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: LIST
3837: LIST
3838: LIST
3839: ST_TO_ADDR
// vehicles := [ ] ;
3840: LD_ADDR_VAR 0 12
3844: PUSH
3845: EMPTY
3846: ST_TO_ADDR
// for i in spot_xy do
3847: LD_ADDR_VAR 0 2
3851: PUSH
3852: LD_VAR 0 13
3856: PUSH
3857: FOR_IN
3858: IFFALSE 4016
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3860: LD_ADDR_VAR 0 6
3864: PUSH
3865: LD_INT 3
3867: PPUSH
3868: LD_INT 3
3870: PPUSH
3871: LD_INT 22
3873: PPUSH
3874: LD_INT 1
3876: PPUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 42
3882: PUSH
3883: LD_INT 43
3885: PUSH
3886: LD_INT 44
3888: PUSH
3889: EMPTY
3890: LIST
3891: LIST
3892: LIST
3893: PUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 3
3899: PPUSH
3900: CALL_OW 12
3904: ARRAY
3905: PPUSH
3906: LD_INT 100
3908: PPUSH
3909: CALL 552 0 7
3913: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3914: LD_ADDR_VAR 0 12
3918: PUSH
3919: LD_VAR 0 12
3923: PPUSH
3924: LD_VAR 0 12
3928: PUSH
3929: LD_INT 1
3931: PLUS
3932: PPUSH
3933: LD_VAR 0 6
3937: PPUSH
3938: CALL_OW 2
3942: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3943: LD_VAR 0 6
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3955: LD_VAR 0 6
3959: PPUSH
3960: LD_VAR 0 2
3964: PUSH
3965: LD_INT 1
3967: ARRAY
3968: PPUSH
3969: LD_VAR 0 2
3973: PUSH
3974: LD_INT 2
3976: ARRAY
3977: PPUSH
3978: LD_INT 0
3980: PPUSH
3981: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3985: LD_INT 0
3987: PPUSH
3988: LD_INT 3
3990: PPUSH
3991: LD_VAR 0 11
3995: PPUSH
3996: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4000: CALL_OW 44
4004: PPUSH
4005: LD_VAR 0 6
4009: PPUSH
4010: CALL_OW 52
// end ;
4014: GO 3857
4016: POP
4017: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
4018: LD_ADDR_VAR 0 2
4022: PUSH
4023: DOUBLE
4024: LD_INT 1
4026: DEC
4027: ST_TO_ADDR
4028: LD_INT 5
4030: PUSH
4031: LD_INT 7
4033: PUSH
4034: LD_INT 8
4036: PUSH
4037: EMPTY
4038: LIST
4039: LIST
4040: LIST
4041: PUSH
4042: LD_OWVAR 67
4046: ARRAY
4047: PUSH
4048: FOR_TO
4049: IFFALSE 4109
// begin PrepareHuman ( false , 1 , skill ) ;
4051: LD_INT 0
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_VAR 0 11
4061: PPUSH
4062: CALL_OW 380
// un := CreateHuman ;
4066: LD_ADDR_VAR 0 5
4070: PUSH
4071: CALL_OW 44
4075: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
4076: LD_VAR 0 5
4080: PPUSH
4081: LD_INT 11
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4091: LD_ADDR_EXP 55
4095: PUSH
4096: LD_EXP 55
4100: PUSH
4101: LD_VAR 0 5
4105: ADD
4106: ST_TO_ADDR
// end ;
4107: GO 4048
4109: POP
4110: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4111: LD_ADDR_VAR 0 2
4115: PUSH
4116: DOUBLE
4117: LD_INT 1
4119: DEC
4120: ST_TO_ADDR
4121: LD_INT 2
4123: PUSH
4124: LD_INT 3
4126: PUSH
4127: LD_INT 4
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_OWVAR 67
4139: ARRAY
4140: PUSH
4141: FOR_TO
4142: IFFALSE 4202
// begin PrepareHuman ( false , 1 , skill ) ;
4144: LD_INT 0
4146: PPUSH
4147: LD_INT 1
4149: PPUSH
4150: LD_VAR 0 11
4154: PPUSH
4155: CALL_OW 380
// un := CreateHuman ;
4159: LD_ADDR_VAR 0 5
4163: PUSH
4164: CALL_OW 44
4168: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4169: LD_VAR 0 5
4173: PPUSH
4174: LD_INT 12
4176: PPUSH
4177: LD_INT 0
4179: PPUSH
4180: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4184: LD_ADDR_EXP 53
4188: PUSH
4189: LD_EXP 53
4193: PUSH
4194: LD_VAR 0 5
4198: ADD
4199: ST_TO_ADDR
// end ;
4200: GO 4141
4202: POP
4203: POP
// for i = 1 to 2 do
4204: LD_ADDR_VAR 0 2
4208: PUSH
4209: DOUBLE
4210: LD_INT 1
4212: DEC
4213: ST_TO_ADDR
4214: LD_INT 2
4216: PUSH
4217: FOR_TO
4218: IFFALSE 4284
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4220: LD_INT 1
4222: PPUSH
4223: LD_INT 1
4225: PPUSH
4226: LD_VAR 0 11
4230: PPUSH
4231: CALL_OW 380
// un := CreateHuman ;
4235: LD_ADDR_VAR 0 5
4239: PUSH
4240: CALL_OW 44
4244: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4245: LD_VAR 0 5
4249: PPUSH
4250: LD_INT 39
4252: PPUSH
4253: LD_INT 12
4255: PPUSH
4256: LD_INT 3
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4266: LD_ADDR_EXP 54
4270: PUSH
4271: LD_EXP 54
4275: PUSH
4276: LD_VAR 0 5
4280: ADD
4281: ST_TO_ADDR
// end ;
4282: GO 4217
4284: POP
4285: POP
// for i = 1 to 3 do
4286: LD_ADDR_VAR 0 2
4290: PUSH
4291: DOUBLE
4292: LD_INT 1
4294: DEC
4295: ST_TO_ADDR
4296: LD_INT 3
4298: PUSH
4299: FOR_TO
4300: IFFALSE 4366
// begin PrepareHuman ( false , 1 , skill ) ;
4302: LD_INT 0
4304: PPUSH
4305: LD_INT 1
4307: PPUSH
4308: LD_VAR 0 11
4312: PPUSH
4313: CALL_OW 380
// un := CreateHuman ;
4317: LD_ADDR_VAR 0 5
4321: PUSH
4322: CALL_OW 44
4326: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4327: LD_VAR 0 5
4331: PPUSH
4332: LD_INT 180
4334: PPUSH
4335: LD_INT 11
4337: PPUSH
4338: LD_INT 4
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4348: LD_ADDR_EXP 58
4352: PUSH
4353: LD_EXP 58
4357: PUSH
4358: LD_VAR 0 5
4362: ADD
4363: ST_TO_ADDR
// end ;
4364: GO 4299
4366: POP
4367: POP
// ru_vehicles := vehicles ;
4368: LD_ADDR_EXP 56
4372: PUSH
4373: LD_VAR 0 12
4377: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4378: LD_ADDR_EXP 59
4382: PUSH
4383: LD_INT 131
4385: PUSH
4386: LD_INT 121
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: PUSH
4393: LD_INT 113
4395: PUSH
4396: LD_INT 90
4398: PUSH
4399: EMPTY
4400: LIST
4401: LIST
4402: PUSH
4403: LD_INT 93
4405: PUSH
4406: LD_INT 62
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 106
4420: PUSH
4421: LD_INT 54
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 120
4430: PUSH
4431: LD_INT 80
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 143
4440: PUSH
4441: LD_INT 120
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 154
4455: PUSH
4456: LD_INT 116
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 140
4465: PUSH
4466: LD_INT 93
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: LD_INT 130
4475: PUSH
4476: LD_INT 58
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: PUSH
4483: EMPTY
4484: LIST
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 105
4490: PUSH
4491: LD_INT 106
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 134
4500: PUSH
4501: LD_INT 98
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 159
4510: PUSH
4511: LD_INT 113
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: LIST
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: ST_TO_ADDR
// if Difficulty = 1 then
4529: LD_OWVAR 67
4533: PUSH
4534: LD_INT 1
4536: EQUAL
4537: IFFALSE 4541
// exit ;
4539: GO 4596
// for i = 1 to Difficulty - 1 do
4541: LD_ADDR_VAR 0 2
4545: PUSH
4546: DOUBLE
4547: LD_INT 1
4549: DEC
4550: ST_TO_ADDR
4551: LD_OWVAR 67
4555: PUSH
4556: LD_INT 1
4558: MINUS
4559: PUSH
4560: FOR_TO
4561: IFFALSE 4594
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4563: LD_ADDR_EXP 57
4567: PUSH
4568: LD_EXP 57
4572: PUSH
4573: LD_INT 22
4575: PUSH
4576: LD_INT 1
4578: PUSH
4579: LD_INT 1
4581: PUSH
4582: LD_INT 43
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: LIST
4589: LIST
4590: ADD
4591: ST_TO_ADDR
4592: GO 4560
4594: POP
4595: POP
// end ;
4596: LD_VAR 0 1
4600: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4601: LD_INT 22
4603: PUSH
4604: LD_INT 3
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 2
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: PPUSH
4625: CALL_OW 69
4629: IFFALSE 4723
4631: GO 4633
4633: DISABLE
4634: LD_INT 0
4636: PPUSH
4637: PPUSH
// begin enable ;
4638: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4639: LD_ADDR_VAR 0 2
4643: PUSH
4644: LD_INT 22
4646: PUSH
4647: LD_INT 3
4649: PUSH
4650: EMPTY
4651: LIST
4652: LIST
4653: PUSH
4654: LD_INT 21
4656: PUSH
4657: LD_INT 2
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: PPUSH
4668: CALL_OW 69
4672: ST_TO_ADDR
// if filter then
4673: LD_VAR 0 2
4677: IFFALSE 4723
// for i in filter do
4679: LD_ADDR_VAR 0 1
4683: PUSH
4684: LD_VAR 0 2
4688: PUSH
4689: FOR_IN
4690: IFFALSE 4721
// if GetFuel ( i ) < 20 then
4692: LD_VAR 0 1
4696: PPUSH
4697: CALL_OW 261
4701: PUSH
4702: LD_INT 20
4704: LESS
4705: IFFALSE 4719
// SetFuel ( i , 20 ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 20
4714: PPUSH
4715: CALL_OW 240
4719: GO 4689
4721: POP
4722: POP
// end ;
4723: PPOPN 2
4725: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4726: LD_EXP 57
4730: IFFALSE 4949
4732: GO 4734
4734: DISABLE
4735: LD_INT 0
4737: PPUSH
4738: PPUSH
4739: PPUSH
// begin enable ;
4740: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4741: LD_ADDR_VAR 0 2
4745: PUSH
4746: LD_INT 22
4748: PUSH
4749: LD_INT 3
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: PUSH
4756: LD_INT 30
4758: PUSH
4759: LD_INT 3
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PPUSH
4770: CALL_OW 69
4774: ST_TO_ADDR
// can_produce := [ ] ;
4775: LD_ADDR_VAR 0 3
4779: PUSH
4780: EMPTY
4781: ST_TO_ADDR
// if not fac then
4782: LD_VAR 0 2
4786: NOT
4787: IFFALSE 4792
// begin disable ;
4789: DISABLE
// exit ;
4790: GO 4949
// end ; for i in fac do
4792: LD_ADDR_VAR 0 1
4796: PUSH
4797: LD_VAR 0 2
4801: PUSH
4802: FOR_IN
4803: IFFALSE 4841
// if UnitsInside ( i ) then
4805: LD_VAR 0 1
4809: PPUSH
4810: CALL_OW 313
4814: IFFALSE 4839
// can_produce := Insert ( can_produce , 1 , i ) ;
4816: LD_ADDR_VAR 0 3
4820: PUSH
4821: LD_VAR 0 3
4825: PPUSH
4826: LD_INT 1
4828: PPUSH
4829: LD_VAR 0 1
4833: PPUSH
4834: CALL_OW 2
4838: ST_TO_ADDR
4839: GO 4802
4841: POP
4842: POP
// if not can_produce then
4843: LD_VAR 0 3
4847: NOT
4848: IFFALSE 4852
// exit ;
4850: GO 4949
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4852: LD_VAR 0 3
4856: PUSH
4857: LD_INT 1
4859: PPUSH
4860: LD_VAR 0 3
4864: PPUSH
4865: CALL_OW 12
4869: ARRAY
4870: PPUSH
4871: LD_EXP 57
4875: PUSH
4876: LD_INT 1
4878: ARRAY
4879: PPUSH
4880: LD_EXP 57
4884: PUSH
4885: LD_INT 2
4887: ARRAY
4888: PPUSH
4889: LD_EXP 57
4893: PUSH
4894: LD_INT 3
4896: ARRAY
4897: PPUSH
4898: LD_EXP 57
4902: PUSH
4903: LD_INT 4
4905: ARRAY
4906: PPUSH
4907: CALL_OW 125
// for i = 1 to 4 do
4911: LD_ADDR_VAR 0 1
4915: PUSH
4916: DOUBLE
4917: LD_INT 1
4919: DEC
4920: ST_TO_ADDR
4921: LD_INT 4
4923: PUSH
4924: FOR_TO
4925: IFFALSE 4947
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4927: LD_ADDR_EXP 57
4931: PUSH
4932: LD_EXP 57
4936: PPUSH
4937: LD_INT 1
4939: PPUSH
4940: CALL_OW 3
4944: ST_TO_ADDR
4945: GO 4924
4947: POP
4948: POP
// end ;
4949: PPOPN 3
4951: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4952: LD_INT 0
4954: PPUSH
4955: PPUSH
4956: PPUSH
// for i = 1 to [ 3 , 5 , 6 ] [ Difficulty ] do
4957: LD_ADDR_VAR 0 2
4961: PUSH
4962: DOUBLE
4963: LD_INT 1
4965: DEC
4966: ST_TO_ADDR
4967: LD_INT 3
4969: PUSH
4970: LD_INT 5
4972: PUSH
4973: LD_INT 6
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: LIST
4980: PUSH
4981: LD_OWVAR 67
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5137
// begin PrepareHuman ( false , 3 , 3 ) ;
4990: LD_INT 0
4992: PPUSH
4993: LD_INT 3
4995: PPUSH
4996: LD_INT 3
4998: PPUSH
4999: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: LD_INT 3
5010: PPUSH
5011: LD_INT 3
5013: PPUSH
5014: LD_INT 22
5016: PPUSH
5017: LD_INT 1
5019: PPUSH
5020: LD_INT 1
5022: PPUSH
5023: LD_INT 43
5025: PUSH
5026: LD_INT 42
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PUSH
5033: LD_INT 1
5035: PPUSH
5036: LD_INT 2
5038: PPUSH
5039: CALL_OW 12
5043: ARRAY
5044: PPUSH
5045: LD_INT 70
5047: PPUSH
5048: CALL 552 0 7
5052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5053: LD_VAR 0 3
5057: PPUSH
5058: LD_INT 4
5060: PPUSH
5061: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
5065: LD_VAR 0 3
5069: PPUSH
5070: LD_INT 229
5072: PPUSH
5073: LD_INT 44
5075: PPUSH
5076: LD_INT 0
5078: PPUSH
5079: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
5083: CALL_OW 44
5087: PPUSH
5088: LD_VAR 0 3
5092: PPUSH
5093: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
5097: LD_ADDR_EXP 56
5101: PUSH
5102: LD_EXP 56
5106: PUSH
5107: LD_VAR 0 3
5111: ADD
5112: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5113: LD_VAR 0 3
5117: PPUSH
5118: LD_INT 191
5120: PPUSH
5121: LD_INT 32
5123: PPUSH
5124: CALL_OW 111
// Wait ( 0 0$02 ) ;
5128: LD_INT 70
5130: PPUSH
5131: CALL_OW 67
// end ;
5135: GO 4987
5137: POP
5138: POP
// end ;
5139: LD_VAR 0 1
5143: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5144: LD_EXP 31
5148: PUSH
5149: LD_EXP 56
5153: AND
5154: IFFALSE 5328
5156: GO 5158
5158: DISABLE
5159: LD_INT 0
5161: PPUSH
5162: PPUSH
5163: PPUSH
// begin wait ( 0 0$50 ) ;
5164: LD_INT 1750
5166: PPUSH
5167: CALL_OW 67
// tmp := ru_vehicles ;
5171: LD_ADDR_VAR 0 3
5175: PUSH
5176: LD_EXP 56
5180: ST_TO_ADDR
// if not tmp then
5181: LD_VAR 0 3
5185: NOT
5186: IFFALSE 5190
// exit ;
5188: GO 5328
// repeat wait ( 0 0$1 ) ;
5190: LD_INT 35
5192: PPUSH
5193: CALL_OW 67
// for i in tmp do
5197: LD_ADDR_VAR 0 1
5201: PUSH
5202: LD_VAR 0 3
5206: PUSH
5207: FOR_IN
5208: IFFALSE 5319
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5210: LD_ADDR_VAR 0 2
5214: PUSH
5215: LD_INT 22
5217: PUSH
5218: LD_INT 1
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PPUSH
5225: LD_VAR 0 1
5229: PPUSH
5230: CALL_OW 74
5234: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5235: LD_VAR 0 1
5239: PPUSH
5240: LD_VAR 0 2
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 10
5252: GREATER
5253: IFFALSE 5272
// ComAgressiveMove ( i , 69 , 101 ) else
5255: LD_VAR 0 1
5259: PPUSH
5260: LD_INT 69
5262: PPUSH
5263: LD_INT 101
5265: PPUSH
5266: CALL_OW 114
5270: GO 5286
// ComAttackUnit ( i , enemy ) ;
5272: LD_VAR 0 1
5276: PPUSH
5277: LD_VAR 0 2
5281: PPUSH
5282: CALL_OW 115
// if GetLives ( i ) < 250 then
5286: LD_VAR 0 1
5290: PPUSH
5291: CALL_OW 256
5295: PUSH
5296: LD_INT 250
5298: LESS
5299: IFFALSE 5317
// tmp := tmp diff i ;
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: LD_VAR 0 3
5310: PUSH
5311: LD_VAR 0 1
5315: DIFF
5316: ST_TO_ADDR
// end ;
5317: GO 5207
5319: POP
5320: POP
// until not tmp ;
5321: LD_VAR 0 3
5325: NOT
5326: IFFALSE 5190
// end ; end_of_file
5328: PPOPN 3
5330: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5331: LD_INT 0
5333: PPUSH
5334: PPUSH
5335: PPUSH
5336: PPUSH
5337: PPUSH
5338: PPUSH
5339: PPUSH
// InGameOn ;
5340: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5344: LD_EXP 37
5348: PPUSH
5349: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5353: LD_EXP 37
5357: PPUSH
5358: LD_EXP 44
5362: PPUSH
5363: CALL_OW 119
// if Bierezov then
5367: LD_EXP 45
5371: IFFALSE 5387
// ComTurnUnit ( Bierezov , Cornel ) ;
5373: LD_EXP 45
5377: PPUSH
5378: LD_EXP 44
5382: PPUSH
5383: CALL_OW 119
// for i in jmm_units do
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_EXP 4
5396: PUSH
5397: FOR_IN
5398: IFFALSE 5416
// ComTurnUnit ( i , Cornel ) ;
5400: LD_VAR 0 2
5404: PPUSH
5405: LD_EXP 44
5409: PPUSH
5410: CALL_OW 119
5414: GO 5397
5416: POP
5417: POP
// units := cornel_units union Cornel ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: LD_EXP 6
5427: PUSH
5428: LD_EXP 44
5432: UNION
5433: ST_TO_ADDR
// repeat wait ( 1 ) ;
5434: LD_INT 1
5436: PPUSH
5437: CALL_OW 67
// for i in units do
5441: LD_ADDR_VAR 0 2
5445: PUSH
5446: LD_VAR 0 3
5450: PUSH
5451: FOR_IN
5452: IFFALSE 5485
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_EXP 37
5463: PPUSH
5464: CALL_OW 250
5468: PPUSH
5469: LD_EXP 37
5473: PPUSH
5474: CALL_OW 251
5478: PPUSH
5479: CALL_OW 111
5483: GO 5451
5485: POP
5486: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5487: LD_VAR 0 3
5491: PPUSH
5492: LD_INT 92
5494: PUSH
5495: LD_EXP 37
5499: PPUSH
5500: CALL_OW 250
5504: PUSH
5505: LD_EXP 37
5509: PPUSH
5510: CALL_OW 251
5514: PUSH
5515: LD_INT 10
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 72
5528: PUSH
5529: LD_VAR 0 3
5533: EQUAL
5534: IFFALSE 5434
// for i in units do
5536: LD_ADDR_VAR 0 2
5540: PUSH
5541: LD_VAR 0 3
5545: PUSH
5546: FOR_IN
5547: IFFALSE 5565
// ComTurnUnit ( i , JMM ) ;
5549: LD_VAR 0 2
5553: PPUSH
5554: LD_EXP 37
5558: PPUSH
5559: CALL_OW 119
5563: GO 5546
5565: POP
5566: POP
// ComTurnUnit ( Cornel , JMM ) ;
5567: LD_EXP 44
5571: PPUSH
5572: LD_EXP 37
5576: PPUSH
5577: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5581: LD_EXP 37
5585: PPUSH
5586: LD_STRING D1-JMM-1
5588: PPUSH
5589: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5593: LD_EXP 44
5597: PPUSH
5598: LD_STRING D1-Corn-1
5600: PPUSH
5601: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5605: LD_EXP 37
5609: PPUSH
5610: LD_EXP 44
5614: PPUSH
5615: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5619: LD_EXP 44
5623: PPUSH
5624: LD_EXP 37
5628: PPUSH
5629: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5633: LD_INT 35
5635: PPUSH
5636: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5640: LD_EXP 37
5644: PPUSH
5645: LD_EXP 44
5649: PPUSH
5650: CALL_OW 296
5654: PUSH
5655: LD_INT 6
5657: LESS
5658: IFFALSE 5633
// ChangeSideFog ( 4 , 1 ) ;
5660: LD_INT 4
5662: PPUSH
5663: LD_INT 1
5665: PPUSH
5666: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5670: LD_EXP 37
5674: PPUSH
5675: LD_EXP 44
5679: PPUSH
5680: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5684: LD_EXP 44
5688: PPUSH
5689: LD_EXP 37
5693: PPUSH
5694: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5698: LD_EXP 37
5702: PPUSH
5703: LD_STRING D1-JMM-2
5705: PPUSH
5706: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5710: LD_EXP 37
5714: PPUSH
5715: LD_STRING D1-JMM-2a
5717: PPUSH
5718: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5722: LD_EXP 44
5726: PPUSH
5727: LD_STRING D1-Corn-2
5729: PPUSH
5730: CALL_OW 88
// if bierezov_exist or debug then
5734: LD_EXP 7
5738: PUSH
5739: LD_EXP 1
5743: OR
5744: IFFALSE 5985
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5746: LD_EXP 44
5750: PPUSH
5751: LD_EXP 45
5755: PPUSH
5756: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5760: LD_INT 10
5762: PPUSH
5763: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5767: LD_EXP 44
5771: PPUSH
5772: LD_STRING D1a-Corn-1
5774: PPUSH
5775: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5779: LD_EXP 37
5783: PPUSH
5784: LD_EXP 45
5788: PPUSH
5789: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5793: LD_EXP 45
5797: PPUSH
5798: LD_EXP 37
5802: PPUSH
5803: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5807: LD_EXP 37
5811: PPUSH
5812: LD_STRING D1a-JMM-1
5814: PPUSH
5815: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5819: LD_EXP 37
5823: PPUSH
5824: LD_EXP 44
5828: PPUSH
5829: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5833: LD_EXP 44
5837: PPUSH
5838: LD_EXP 37
5842: PPUSH
5843: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5847: LD_EXP 44
5851: PPUSH
5852: LD_STRING D1a-Corn-2
5854: PPUSH
5855: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5859: LD_EXP 37
5863: PPUSH
5864: LD_STRING D1a-JMM-2
5866: PPUSH
5867: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5871: LD_EXP 44
5875: PPUSH
5876: LD_STRING D1a-Corn-3
5878: PPUSH
5879: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5883: LD_EXP 37
5887: PPUSH
5888: LD_STRING D1a-JMM-3
5890: PPUSH
5891: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5895: LD_EXP 44
5899: PPUSH
5900: LD_STRING D1a-Corn-4
5902: PPUSH
5903: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5907: LD_EXP 37
5911: PPUSH
5912: LD_STRING D1a-JMM-4
5914: PPUSH
5915: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5919: LD_EXP 44
5923: PPUSH
5924: LD_STRING D1a-Corn-5
5926: PPUSH
5927: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5931: LD_EXP 45
5935: PPUSH
5936: LD_EXP 44
5940: PPUSH
5941: CALL_OW 250
5945: PPUSH
5946: LD_EXP 44
5950: PPUSH
5951: CALL_OW 251
5955: PUSH
5956: LD_INT 2
5958: MINUS
5959: PPUSH
5960: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5964: LD_EXP 45
5968: PPUSH
5969: LD_EXP 44
5973: PPUSH
5974: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5978: LD_INT 10
5980: PPUSH
5981: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5985: LD_EXP 37
5989: PPUSH
5990: LD_STRING D1b-JMM-1
5992: PPUSH
5993: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5997: LD_EXP 44
6001: PPUSH
6002: LD_STRING D1b-Corn-1
6004: PPUSH
6005: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
6009: LD_EXP 37
6013: PPUSH
6014: LD_STRING D1b-JMM-2
6016: PPUSH
6017: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
6021: LD_EXP 44
6025: PPUSH
6026: LD_STRING D1b-Corn-2
6028: PPUSH
6029: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
6033: LD_EXP 37
6037: PPUSH
6038: LD_STRING D1b-JMM-3
6040: PPUSH
6041: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
6045: LD_INT 10
6047: PPUSH
6048: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
6052: LD_EXP 46
6056: PPUSH
6057: LD_STRING D1b-Pow-3
6059: PPUSH
6060: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
6064: LD_EXP 37
6068: PPUSH
6069: LD_STRING D1b-JMM-4
6071: PPUSH
6072: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
6076: LD_EXP 44
6080: PPUSH
6081: LD_STRING D1b-Corn-4
6083: PPUSH
6084: CALL_OW 88
// if Khatam then
6088: LD_EXP 41
6092: IFFALSE 6108
// Say ( Khatam , D1b-Khat-4 ) else
6094: LD_EXP 41
6098: PPUSH
6099: LD_STRING D1b-Khat-4
6101: PPUSH
6102: CALL_OW 88
6106: GO 6144
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6108: LD_EXP 6
6112: PPUSH
6113: LD_INT 26
6115: PUSH
6116: LD_INT 1
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 72
6127: PUSH
6128: LD_EXP 44
6132: PUSH
6133: EMPTY
6134: LIST
6135: DIFF
6136: PPUSH
6137: LD_STRING D1b-Sol1-4
6139: PPUSH
6140: CALL 640 0 2
// if Cyrus then
6144: LD_EXP 39
6148: IFFALSE 6162
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6150: LD_EXP 39
6154: PPUSH
6155: LD_STRING D1b-Cyrus-4
6157: PPUSH
6158: CALL_OW 88
// if Lisa then
6162: LD_EXP 40
6166: IFFALSE 6224
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6168: LD_EXP 40
6172: PPUSH
6173: LD_STRING D1b-Lisa-4
6175: PPUSH
6176: CALL_OW 88
// if Cyrus then
6180: LD_EXP 39
6184: IFFALSE 6224
// begin if not IsInUnit ( Cyrus ) then
6186: LD_EXP 39
6190: PPUSH
6191: CALL_OW 310
6195: NOT
6196: IFFALSE 6212
// ComTurnUnit ( Cyrus , Lisa ) ;
6198: LD_EXP 39
6202: PPUSH
6203: LD_EXP 40
6207: PPUSH
6208: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6212: LD_EXP 39
6216: PPUSH
6217: LD_STRING D1b-Cyrus-5
6219: PPUSH
6220: CALL_OW 88
// end ; end ; SelectGroup ;
6224: CALL 2684 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6228: LD_EXP 37
6232: PPUSH
6233: LD_STRING D1d-JMM-1
6235: PPUSH
6236: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6240: LD_EXP 44
6244: PPUSH
6245: LD_STRING D1d-Corn-1
6247: PPUSH
6248: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6252: LD_ADDR_VAR 0 2
6256: PUSH
6257: LD_EXP 4
6261: PUSH
6262: LD_EXP 6
6266: ADD
6267: PUSH
6268: LD_EXP 37
6272: ADD
6273: PUSH
6274: FOR_IN
6275: IFFALSE 6288
// ComHold ( i ) ;
6277: LD_VAR 0 2
6281: PPUSH
6282: CALL_OW 140
6286: GO 6274
6288: POP
6289: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6290: LD_ADDR_VAR 0 4
6294: PUSH
6295: LD_INT 22
6297: PUSH
6298: LD_INT 1
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 21
6307: PUSH
6308: LD_INT 2
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PPUSH
6319: CALL_OW 69
6323: ST_TO_ADDR
// if vehicles then
6324: LD_VAR 0 4
6328: IFFALSE 6666
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6330: LD_EXP 6
6334: PPUSH
6335: LD_INT 55
6337: PUSH
6338: EMPTY
6339: LIST
6340: PPUSH
6341: CALL_OW 72
6345: IFFALSE 6384
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6347: LD_ADDR_VAR 0 2
6351: PUSH
6352: LD_EXP 6
6356: PPUSH
6357: LD_INT 55
6359: PUSH
6360: EMPTY
6361: LIST
6362: PPUSH
6363: CALL_OW 72
6367: PUSH
6368: FOR_IN
6369: IFFALSE 6382
// ComExitVehicle ( i ) ;
6371: LD_VAR 0 2
6375: PPUSH
6376: CALL_OW 121
6380: GO 6368
6382: POP
6383: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6384: LD_ADDR_VAR 0 5
6388: PUSH
6389: LD_VAR 0 4
6393: PPUSH
6394: LD_INT 34
6396: PUSH
6397: LD_INT 51
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: PPUSH
6404: CALL_OW 72
6408: ST_TO_ADDR
// if cargos then
6409: LD_VAR 0 5
6413: IFFALSE 6596
// begin vehicles := cargos ;
6415: LD_ADDR_VAR 0 4
6419: PUSH
6420: LD_VAR 0 5
6424: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6425: LD_ADDR_VAR 0 6
6429: PUSH
6430: LD_STRING 02_resources_4
6432: PPUSH
6433: LD_INT 0
6435: PPUSH
6436: CALL_OW 30
6440: ST_TO_ADDR
// if debug and not resources then
6441: LD_EXP 1
6445: PUSH
6446: LD_VAR 0 6
6450: NOT
6451: AND
6452: IFFALSE 6462
// resources := 160 ;
6454: LD_ADDR_VAR 0 6
6458: PUSH
6459: LD_INT 160
6461: ST_TO_ADDR
// if resources mod 10 then
6462: LD_VAR 0 6
6466: PUSH
6467: LD_INT 10
6469: MOD
6470: IFFALSE 6492
// resources := resources - resources mod 10 ;
6472: LD_ADDR_VAR 0 6
6476: PUSH
6477: LD_VAR 0 6
6481: PUSH
6482: LD_VAR 0 6
6486: PUSH
6487: LD_INT 10
6489: MOD
6490: MINUS
6491: ST_TO_ADDR
// if resources then
6492: LD_VAR 0 6
6496: IFFALSE 6596
// for i in cargos do
6498: LD_ADDR_VAR 0 2
6502: PUSH
6503: LD_VAR 0 5
6507: PUSH
6508: FOR_IN
6509: IFFALSE 6594
// begin if resources < 100 then
6511: LD_VAR 0 6
6515: PUSH
6516: LD_INT 100
6518: LESS
6519: IFFALSE 6541
// begin cargo := resources ;
6521: LD_ADDR_VAR 0 7
6525: PUSH
6526: LD_VAR 0 6
6530: ST_TO_ADDR
// resources := 0 ;
6531: LD_ADDR_VAR 0 6
6535: PUSH
6536: LD_INT 0
6538: ST_TO_ADDR
// end else
6539: GO 6563
// begin cargo := 100 ;
6541: LD_ADDR_VAR 0 7
6545: PUSH
6546: LD_INT 100
6548: ST_TO_ADDR
// resources := resources - 100 ;
6549: LD_ADDR_VAR 0 6
6553: PUSH
6554: LD_VAR 0 6
6558: PUSH
6559: LD_INT 100
6561: MINUS
6562: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6563: LD_VAR 0 2
6567: PPUSH
6568: LD_INT 1
6570: PPUSH
6571: LD_VAR 0 7
6575: PPUSH
6576: CALL_OW 290
// if resources = 0 then
6580: LD_VAR 0 6
6584: PUSH
6585: LD_INT 0
6587: EQUAL
6588: IFFALSE 6592
// break ;
6590: GO 6594
// end ;
6592: GO 6508
6594: POP
6595: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6596: LD_VAR 0 4
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 311
6609: PPUSH
6610: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6614: LD_VAR 0 4
6618: PUSH
6619: LD_INT 1
6621: ARRAY
6622: PPUSH
6623: LD_INT 4
6625: PPUSH
6626: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6630: LD_EXP 44
6634: PPUSH
6635: LD_VAR 0 4
6639: PUSH
6640: LD_INT 1
6642: ARRAY
6643: PPUSH
6644: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6648: LD_INT 35
6650: PPUSH
6651: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6655: LD_EXP 44
6659: PPUSH
6660: CALL_OW 310
6664: IFFALSE 6648
// end ; InGameOff ;
6666: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6670: LD_STRING M1
6672: PPUSH
6673: CALL_OW 337
// SaveForQuickRestart ;
6677: CALL_OW 22
// cornel_active := true ;
6681: LD_ADDR_EXP 8
6685: PUSH
6686: LD_INT 1
6688: ST_TO_ADDR
// end ;
6689: LD_VAR 0 1
6693: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6694: LD_EXP 37
6698: PPUSH
6699: LD_EXP 47
6703: PPUSH
6704: CALL_OW 296
6708: PUSH
6709: LD_INT 10
6711: LESS
6712: IFFALSE 8095
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
6723: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 89
6731: PUSH
6732: LD_INT 34
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 138
6741: PUSH
6742: LD_INT 63
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 196
6751: PUSH
6752: LD_INT 84
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 135
6761: PUSH
6762: LD_INT 52
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: LD_INT 103
6771: PUSH
6772: LD_INT 39
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PUSH
6779: LD_INT 58
6781: PUSH
6782: LD_INT 30
6784: PUSH
6785: EMPTY
6786: LIST
6787: LIST
6788: PUSH
6789: LD_INT 38
6791: PUSH
6792: LD_INT 51
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: ST_TO_ADDR
// Video ( true ) ;
6808: LD_INT 1
6810: PPUSH
6811: CALL 1200 0 1
// if jmm_units then
6815: LD_EXP 4
6819: IFFALSE 6895
// for i in jmm_units do
6821: LD_ADDR_VAR 0 1
6825: PUSH
6826: LD_EXP 4
6830: PUSH
6831: FOR_IN
6832: IFFALSE 6893
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6834: LD_VAR 0 1
6838: PPUSH
6839: LD_EXP 37
6843: PPUSH
6844: CALL_OW 296
6848: PUSH
6849: LD_INT 10
6851: LESS
6852: PUSH
6853: LD_VAR 0 1
6857: PPUSH
6858: CALL_OW 310
6862: NOT
6863: AND
6864: IFFALSE 6882
// ComTurnUnit ( i , JMM ) else
6866: LD_VAR 0 1
6870: PPUSH
6871: LD_EXP 37
6875: PPUSH
6876: CALL_OW 119
6880: GO 6891
// ComHold ( i ) ;
6882: LD_VAR 0 1
6886: PPUSH
6887: CALL_OW 140
// end ;
6891: GO 6831
6893: POP
6894: POP
// if IsInUnit ( JMM ) then
6895: LD_EXP 37
6899: PPUSH
6900: CALL_OW 310
6904: IFFALSE 6929
// begin ComExitVehicle ( JMM ) ;
6906: LD_EXP 37
6910: PPUSH
6911: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6915: LD_EXP 37
6919: PPUSH
6920: LD_EXP 47
6924: PPUSH
6925: CALL_OW 172
// end ; Wait ( 10 ) ;
6929: LD_INT 10
6931: PPUSH
6932: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6936: LD_EXP 37
6940: PPUSH
6941: LD_EXP 47
6945: PPUSH
6946: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6950: LD_INT 35
6952: PPUSH
6953: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6957: LD_EXP 37
6961: PPUSH
6962: LD_EXP 47
6966: PPUSH
6967: CALL_OW 296
6971: PUSH
6972: LD_INT 6
6974: LESS
6975: IFFALSE 6950
// ComTurnUnit ( JMM , Lynch ) ;
6977: LD_EXP 37
6981: PPUSH
6982: LD_EXP 47
6986: PPUSH
6987: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6991: LD_ADDR_VAR 0 1
6995: PUSH
6996: LD_EXP 47
7000: PUSH
7001: LD_EXP 48
7005: PUSH
7006: LD_EXP 49
7010: PUSH
7011: LD_EXP 50
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: PUSH
7022: FOR_IN
7023: IFFALSE 7041
// ComTurnUnit ( i , JMM ) ;
7025: LD_VAR 0 1
7029: PPUSH
7030: LD_EXP 37
7034: PPUSH
7035: CALL_OW 119
7039: GO 7022
7041: POP
7042: POP
// Wait ( 0 0$0.3 ) ;
7043: LD_INT 10
7045: PPUSH
7046: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
7050: LD_EXP 37
7054: PPUSH
7055: LD_STRING D2-JMM-1
7057: PPUSH
7058: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
7062: LD_EXP 47
7066: PPUSH
7067: LD_STRING D2-Sol1-1
7069: PPUSH
7070: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7074: LD_EXP 37
7078: PPUSH
7079: LD_STRING D2-JMM-2
7081: PPUSH
7082: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
7086: LD_EXP 47
7090: PPUSH
7091: LD_STRING D2-Sol1-2
7093: PPUSH
7094: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7098: LD_EXP 37
7102: PPUSH
7103: LD_STRING D2-JMM-3
7105: PPUSH
7106: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7110: LD_EXP 47
7114: PPUSH
7115: LD_STRING D2-Sol1-3
7117: PPUSH
7118: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7122: LD_ADDR_VAR 0 1
7126: PUSH
7127: LD_INT 22
7129: PUSH
7130: LD_INT 8
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: PPUSH
7137: CALL_OW 69
7141: PUSH
7142: FOR_IN
7143: IFFALSE 7159
// SetSide ( i , 1 ) ;
7145: LD_VAR 0 1
7149: PPUSH
7150: LD_INT 1
7152: PPUSH
7153: CALL_OW 235
7157: GO 7142
7159: POP
7160: POP
// Say ( JMM , D2-JMM-4 ) ;
7161: LD_EXP 37
7165: PPUSH
7166: LD_STRING D2-JMM-4
7168: PPUSH
7169: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7173: LD_INT 1
7175: PPUSH
7176: LD_INT 5
7178: PPUSH
7179: CALL_OW 332
// for i = 1 to points do
7183: LD_ADDR_VAR 0 1
7187: PUSH
7188: DOUBLE
7189: LD_INT 1
7191: DEC
7192: ST_TO_ADDR
7193: LD_VAR 0 2
7197: PUSH
7198: FOR_TO
7199: IFFALSE 7374
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7201: LD_VAR 0 2
7205: PUSH
7206: LD_VAR 0 1
7210: ARRAY
7211: PUSH
7212: LD_INT 1
7214: ARRAY
7215: PPUSH
7216: LD_VAR 0 2
7220: PUSH
7221: LD_VAR 0 1
7225: ARRAY
7226: PUSH
7227: LD_INT 2
7229: ARRAY
7230: PPUSH
7231: CALL_OW 84
// if i = 1 then
7235: LD_VAR 0 1
7239: PUSH
7240: LD_INT 1
7242: EQUAL
7243: IFFALSE 7257
// Say ( Lynch , D2-Sol1-4 ) ;
7245: LD_EXP 47
7249: PPUSH
7250: LD_STRING D2-Sol1-4
7252: PPUSH
7253: CALL_OW 88
// if i = 2 then
7257: LD_VAR 0 1
7261: PUSH
7262: LD_INT 2
7264: EQUAL
7265: IFFALSE 7279
// Say ( JMM , D2-JMM-5 ) ;
7267: LD_EXP 37
7271: PPUSH
7272: LD_STRING D2-JMM-5
7274: PPUSH
7275: CALL_OW 88
// if i = 4 then
7279: LD_VAR 0 1
7283: PUSH
7284: LD_INT 4
7286: EQUAL
7287: IFFALSE 7311
// begin RevealFogArea ( 1 , troopsArea ) ;
7289: LD_INT 1
7291: PPUSH
7292: LD_INT 6
7294: PPUSH
7295: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7299: LD_EXP 47
7303: PPUSH
7304: LD_STRING D2-Sol1-5
7306: PPUSH
7307: CALL_OW 88
// end ; if i = 5 then
7311: LD_VAR 0 1
7315: PUSH
7316: LD_INT 5
7318: EQUAL
7319: IFFALSE 7333
// Say ( JMM , D2-JMM-6 ) ;
7321: LD_EXP 37
7325: PPUSH
7326: LD_STRING D2-JMM-6
7328: PPUSH
7329: CALL_OW 88
// if i = 7 then
7333: LD_VAR 0 1
7337: PUSH
7338: LD_INT 7
7340: EQUAL
7341: IFFALSE 7365
// begin RevealFogArea ( 1 , forestArea ) ;
7343: LD_INT 1
7345: PPUSH
7346: LD_INT 7
7348: PPUSH
7349: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7353: LD_EXP 47
7357: PPUSH
7358: LD_STRING D2-Sol1-6
7360: PPUSH
7361: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7365: LD_INT 46
7367: PPUSH
7368: CALL_OW 67
// end ;
7372: GO 7198
7374: POP
7375: POP
// CenterNowOnUnits ( JMM ) ;
7376: LD_EXP 37
7380: PPUSH
7381: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7385: LD_EXP 37
7389: PPUSH
7390: LD_STRING D2-JMM-7
7392: PPUSH
7393: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7397: LD_EXP 47
7401: PPUSH
7402: LD_STRING D2-Sol1-7
7404: PPUSH
7405: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7409: LD_EXP 37
7413: PPUSH
7414: LD_STRING D2-JMM-8
7416: PPUSH
7417: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 22
7428: PUSH
7429: LD_INT 1
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 30
7438: PUSH
7439: LD_INT 31
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PPUSH
7450: CALL_OW 69
7454: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7455: LD_EXP 47
7459: PPUSH
7460: LD_VAR 0 4
7464: PUSH
7465: LD_INT 1
7467: ARRAY
7468: PPUSH
7469: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7473: LD_INT 65
7475: PPUSH
7476: LD_INT 101
7478: PPUSH
7479: CALL_OW 428
7483: IFFALSE 7506
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7485: LD_INT 65
7487: PPUSH
7488: LD_INT 101
7490: PPUSH
7491: CALL_OW 428
7495: PPUSH
7496: LD_INT 75
7498: PPUSH
7499: LD_INT 100
7501: PPUSH
7502: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7506: LD_INT 66
7508: PPUSH
7509: LD_INT 103
7511: PPUSH
7512: CALL_OW 428
7516: IFFALSE 7539
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7518: LD_INT 66
7520: PPUSH
7521: LD_INT 103
7523: PPUSH
7524: CALL_OW 428
7528: PPUSH
7529: LD_INT 75
7531: PPUSH
7532: LD_INT 100
7534: PPUSH
7535: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7539: LD_ADDR_VAR 0 5
7543: PUSH
7544: LD_INT 22
7546: PUSH
7547: LD_INT 1
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PUSH
7554: LD_INT 21
7556: PUSH
7557: LD_INT 2
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PUSH
7564: LD_INT 91
7566: PUSH
7567: LD_EXP 37
7571: PUSH
7572: LD_INT 7
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: LIST
7584: PPUSH
7585: CALL_OW 69
7589: ST_TO_ADDR
// if tmp then
7590: LD_VAR 0 5
7594: IFFALSE 7611
// ComMoveXY ( tmp , 75 , 100 ) ;
7596: LD_VAR 0 5
7600: PPUSH
7601: LD_INT 75
7603: PPUSH
7604: LD_INT 100
7606: PPUSH
7607: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7611: LD_ADDR_VAR 0 3
7615: PUSH
7616: LD_EXP 4
7620: PPUSH
7621: LD_INT 25
7623: PUSH
7624: LD_INT 1
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PPUSH
7631: CALL_OW 72
7635: PPUSH
7636: LD_EXP 37
7640: PPUSH
7641: CALL_OW 74
7645: ST_TO_ADDR
// if sol then
7646: LD_VAR 0 3
7650: IFFALSE 7710
// if GetDistUnits ( JMM , sol ) < 10 then
7652: LD_EXP 37
7656: PPUSH
7657: LD_VAR 0 3
7661: PPUSH
7662: CALL_OW 296
7666: PUSH
7667: LD_INT 10
7669: LESS
7670: IFFALSE 7710
// begin if IsInUnit ( sol ) then
7672: LD_VAR 0 3
7676: PPUSH
7677: CALL_OW 310
7681: IFFALSE 7692
// ComExitVehicle ( sol ) ;
7683: LD_VAR 0 3
7687: PPUSH
7688: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7692: LD_VAR 0 3
7696: PPUSH
7697: LD_VAR 0 4
7701: PUSH
7702: LD_INT 2
7704: ARRAY
7705: PPUSH
7706: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7710: LD_INT 10
7712: PPUSH
7713: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7717: LD_EXP 37
7721: PPUSH
7722: LD_INT 65
7724: PPUSH
7725: LD_INT 101
7727: PPUSH
7728: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7732: LD_EXP 37
7736: PPUSH
7737: LD_INT 63
7739: PPUSH
7740: LD_INT 100
7742: PPUSH
7743: CALL_OW 178
// tmp := 0 0$0 ;
7747: LD_ADDR_VAR 0 5
7751: PUSH
7752: LD_INT 0
7754: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7755: LD_INT 35
7757: PPUSH
7758: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7762: LD_ADDR_VAR 0 5
7766: PUSH
7767: LD_VAR 0 5
7771: PUSH
7772: LD_INT 35
7774: PLUS
7775: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7776: LD_EXP 37
7780: PPUSH
7781: LD_INT 65
7783: PPUSH
7784: LD_INT 101
7786: PPUSH
7787: CALL_OW 307
7791: PUSH
7792: LD_VAR 0 5
7796: PUSH
7797: LD_INT 175
7799: GREATER
7800: OR
7801: IFFALSE 7755
// Say ( JMM , D2a-JMM-1 ) ;
7803: LD_EXP 37
7807: PPUSH
7808: LD_STRING D2a-JMM-1
7810: PPUSH
7811: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7815: LD_EXP 48
7819: PPUSH
7820: LD_INT 66
7822: PPUSH
7823: LD_INT 103
7825: PPUSH
7826: CALL_OW 111
// tmp := 0 0$0 ;
7830: LD_ADDR_VAR 0 5
7834: PUSH
7835: LD_INT 0
7837: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7838: LD_INT 35
7840: PPUSH
7841: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7845: LD_EXP 48
7849: PPUSH
7850: LD_INT 66
7852: PPUSH
7853: LD_INT 103
7855: PPUSH
7856: CALL_OW 307
7860: PUSH
7861: LD_VAR 0 5
7865: PUSH
7866: LD_INT 175
7868: GREATER
7869: OR
7870: IFFALSE 7838
// ComTurnUnit ( Walker , JMM ) ;
7872: LD_EXP 48
7876: PPUSH
7877: LD_EXP 37
7881: PPUSH
7882: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7886: LD_EXP 48
7890: PPUSH
7891: LD_STRING D2a-Sci1-1
7893: PPUSH
7894: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7898: LD_EXP 37
7902: PPUSH
7903: LD_EXP 48
7907: PPUSH
7908: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7912: LD_EXP 37
7916: PPUSH
7917: LD_STRING D2a-JMM-2
7919: PPUSH
7920: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7924: LD_EXP 48
7928: PPUSH
7929: LD_STRING D2a-Sci1-2
7931: PPUSH
7932: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7936: LD_EXP 37
7940: PPUSH
7941: LD_STRING D2a-JMM-3
7943: PPUSH
7944: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7948: LD_EXP 48
7952: PPUSH
7953: LD_STRING D2a-Sci1-3
7955: PPUSH
7956: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7960: LD_ADDR_EXP 4
7964: PUSH
7965: LD_EXP 4
7969: PUSH
7970: LD_EXP 47
7974: PUSH
7975: LD_EXP 48
7979: PUSH
7980: LD_EXP 49
7984: PUSH
7985: LD_EXP 50
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: ADD
7996: ST_TO_ADDR
// for i in jmm_units do
7997: LD_ADDR_VAR 0 1
8001: PUSH
8002: LD_EXP 4
8006: PUSH
8007: FOR_IN
8008: IFFALSE 8033
// if not IsInUnit ( i ) then
8010: LD_VAR 0 1
8014: PPUSH
8015: CALL_OW 310
8019: NOT
8020: IFFALSE 8031
// ComFree ( i ) ;
8022: LD_VAR 0 1
8026: PPUSH
8027: CALL_OW 139
8031: GO 8007
8033: POP
8034: POP
// Video ( false ) ;
8035: LD_INT 0
8037: PPUSH
8038: CALL 1200 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
8042: LD_STRING MSolar1
8044: PPUSH
8045: CALL_OW 337
// jmm_on_west := true ;
8049: LD_ADDR_EXP 5
8053: PUSH
8054: LD_INT 1
8056: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
8057: LD_INT 1050
8059: PPUSH
8060: CALL_OW 67
// frank_can_return := true ;
8064: LD_ADDR_EXP 12
8068: PUSH
8069: LD_INT 1
8071: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
8072: LD_INT 6300
8074: PPUSH
8075: LD_INT 8400
8077: PPUSH
8078: CALL_OW 12
8082: PPUSH
8083: CALL_OW 67
// send_spec_patrol := true ;
8087: LD_ADDR_EXP 30
8091: PUSH
8092: LD_INT 1
8094: ST_TO_ADDR
// end ;
8095: PPOPN 5
8097: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
8098: LD_INT 22
8100: PUSH
8101: LD_INT 1
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: LD_INT 34
8110: PUSH
8111: LD_INT 51
8113: PUSH
8114: EMPTY
8115: LIST
8116: LIST
8117: PUSH
8118: LD_INT 92
8120: PUSH
8121: LD_INT 63
8123: PUSH
8124: LD_INT 100
8126: PUSH
8127: LD_INT 5
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: LIST
8134: LIST
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: PUSH
8141: EMPTY
8142: LIST
8143: PPUSH
8144: CALL_OW 69
8148: PUSH
8149: LD_EXP 5
8153: NOT
8154: AND
8155: IFFALSE 8268
8157: GO 8159
8159: DISABLE
8160: LD_INT 0
8162: PPUSH
8163: PPUSH
// begin enable ;
8164: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8165: LD_ADDR_VAR 0 2
8169: PUSH
8170: LD_INT 22
8172: PUSH
8173: LD_INT 1
8175: PUSH
8176: EMPTY
8177: LIST
8178: LIST
8179: PUSH
8180: LD_INT 34
8182: PUSH
8183: LD_INT 51
8185: PUSH
8186: EMPTY
8187: LIST
8188: LIST
8189: PUSH
8190: LD_INT 92
8192: PUSH
8193: LD_INT 63
8195: PUSH
8196: LD_INT 100
8198: PUSH
8199: LD_INT 5
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: LIST
8206: LIST
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: PUSH
8213: EMPTY
8214: LIST
8215: PPUSH
8216: CALL_OW 69
8220: ST_TO_ADDR
// if not filter then
8221: LD_VAR 0 2
8225: NOT
8226: IFFALSE 8230
// exit ;
8228: GO 8268
// for i in filter do
8230: LD_ADDR_VAR 0 1
8234: PUSH
8235: LD_VAR 0 2
8239: PUSH
8240: FOR_IN
8241: IFFALSE 8266
// begin SetFuel ( i , 0 ) ;
8243: LD_VAR 0 1
8247: PPUSH
8248: LD_INT 0
8250: PPUSH
8251: CALL_OW 240
// ComStop ( i ) ;
8255: LD_VAR 0 1
8259: PPUSH
8260: CALL_OW 141
// end ;
8264: GO 8240
8266: POP
8267: POP
// end ;
8268: PPOPN 2
8270: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8271: LD_EXP 30
8275: IFFALSE 9372
8277: GO 8279
8279: DISABLE
8280: LD_INT 0
8282: PPUSH
8283: PPUSH
8284: PPUSH
8285: PPUSH
8286: PPUSH
8287: PPUSH
8288: PPUSH
// begin if not ru_spec_patrol then
8289: LD_EXP 54
8293: NOT
8294: IFFALSE 8298
// exit ;
8296: GO 9372
// dead1 := false ;
8298: LD_ADDR_VAR 0 1
8302: PUSH
8303: LD_INT 0
8305: ST_TO_ADDR
// dead2 := false ;
8306: LD_ADDR_VAR 0 2
8310: PUSH
8311: LD_INT 0
8313: ST_TO_ADDR
// inarea1 := false ;
8314: LD_ADDR_VAR 0 3
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// inarea2 := false ;
8322: LD_ADDR_VAR 0 4
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
// tmp := [ ] ;
8330: LD_ADDR_VAR 0 6
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8337: LD_EXP 54
8341: PPUSH
8342: LD_INT 75
8344: PPUSH
8345: LD_INT 101
8347: PPUSH
8348: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8352: LD_INT 35
8354: PPUSH
8355: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8359: LD_INT 1
8361: PPUSH
8362: LD_EXP 54
8366: PUSH
8367: LD_INT 1
8369: ARRAY
8370: PPUSH
8371: CALL_OW 292
8375: IFFALSE 8352
// ComStop ( ru_spec_patrol ) ;
8377: LD_EXP 54
8381: PPUSH
8382: CALL_OW 141
// Wait ( 0 0$02 ) ;
8386: LD_INT 70
8388: PPUSH
8389: CALL_OW 67
// DialogueOn ;
8393: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8397: LD_EXP 54
8401: PUSH
8402: LD_INT 1
8404: ARRAY
8405: PPUSH
8406: LD_STRING D8-Rus1-1
8408: PPUSH
8409: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8413: LD_EXP 37
8417: PPUSH
8418: LD_STRING D8-JMM-1
8420: PPUSH
8421: CALL_OW 88
// DialogueOff ;
8425: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8429: LD_EXP 54
8433: PPUSH
8434: LD_INT 13
8436: PPUSH
8437: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8448: LD_VAR 0 1
8452: NOT
8453: PUSH
8454: LD_EXP 54
8458: PUSH
8459: LD_INT 1
8461: ARRAY
8462: PPUSH
8463: CALL_OW 301
8467: AND
8468: IFFALSE 8478
// dead1 := true ;
8470: LD_ADDR_VAR 0 1
8474: PUSH
8475: LD_INT 1
8477: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8478: LD_VAR 0 2
8482: NOT
8483: PUSH
8484: LD_EXP 54
8488: PUSH
8489: LD_INT 2
8491: ARRAY
8492: PPUSH
8493: CALL_OW 301
8497: AND
8498: IFFALSE 8508
// dead2 := true ;
8500: LD_ADDR_VAR 0 2
8504: PUSH
8505: LD_INT 1
8507: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8508: LD_VAR 0 3
8512: NOT
8513: PUSH
8514: LD_EXP 54
8518: PUSH
8519: LD_INT 1
8521: ARRAY
8522: PPUSH
8523: LD_INT 14
8525: PPUSH
8526: CALL_OW 308
8530: AND
8531: IFFALSE 8541
// inarea1 := true ;
8533: LD_ADDR_VAR 0 3
8537: PUSH
8538: LD_INT 1
8540: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8541: LD_VAR 0 4
8545: NOT
8546: PUSH
8547: LD_EXP 54
8551: PUSH
8552: LD_INT 2
8554: ARRAY
8555: PPUSH
8556: LD_INT 14
8558: PPUSH
8559: CALL_OW 308
8563: AND
8564: IFFALSE 8574
// inarea2 := true ;
8566: LD_ADDR_VAR 0 4
8570: PUSH
8571: LD_INT 1
8573: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8574: LD_VAR 0 1
8578: PUSH
8579: LD_VAR 0 2
8583: AND
8584: PUSH
8585: LD_VAR 0 1
8589: PUSH
8590: LD_VAR 0 4
8594: AND
8595: OR
8596: PUSH
8597: LD_VAR 0 2
8601: PUSH
8602: LD_VAR 0 3
8606: AND
8607: OR
8608: PUSH
8609: LD_VAR 0 3
8613: PUSH
8614: LD_VAR 0 4
8618: AND
8619: OR
8620: IFFALSE 8441
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8622: LD_VAR 0 3
8626: PUSH
8627: LD_VAR 0 4
8631: AND
8632: PUSH
8633: LD_VAR 0 1
8637: PUSH
8638: LD_VAR 0 4
8642: AND
8643: OR
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: LD_VAR 0 3
8654: AND
8655: OR
8656: IFFALSE 9352
// begin prepare_siege := true ;
8658: LD_ADDR_EXP 31
8662: PUSH
8663: LD_INT 1
8665: ST_TO_ADDR
// DialogueOn ;
8666: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8670: LD_VAR 0 3
8674: PUSH
8675: LD_VAR 0 4
8679: AND
8680: IFFALSE 8696
// Say ( JMM , D8b-JMM-1a ) else
8682: LD_EXP 37
8686: PPUSH
8687: LD_STRING D8b-JMM-1a
8689: PPUSH
8690: CALL_OW 88
8694: GO 8708
// Say ( JMM , D8b-JMM-1 ) ;
8696: LD_EXP 37
8700: PPUSH
8701: LD_STRING D8b-JMM-1
8703: PPUSH
8704: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8708: LD_EXP 4
8712: PPUSH
8713: LD_INT 26
8715: PUSH
8716: LD_INT 1
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PPUSH
8723: CALL_OW 72
8727: PUSH
8728: LD_EXP 38
8732: PUSH
8733: LD_EXP 39
8737: PUSH
8738: LD_EXP 48
8742: PUSH
8743: LD_EXP 51
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: DIFF
8754: PPUSH
8755: LD_STRING D8b-Sol1-1
8757: PPUSH
8758: CALL 640 0 2
// if Cyrus and Cyrus in jmm_units then
8762: LD_EXP 39
8766: PUSH
8767: LD_EXP 39
8771: PUSH
8772: LD_EXP 4
8776: IN
8777: AND
8778: IFFALSE 8794
// Say ( Cyrus , D8b-Cyrus-1 ) else
8780: LD_EXP 39
8784: PPUSH
8785: LD_STRING D8b-Cyrus-1
8787: PPUSH
8788: CALL_OW 88
8792: GO 8806
// Say ( JMM , D8b-JMM-1a ) ;
8794: LD_EXP 37
8798: PPUSH
8799: LD_STRING D8b-JMM-1a
8801: PPUSH
8802: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8806: LD_EXP 40
8810: PUSH
8811: LD_EXP 40
8815: PUSH
8816: LD_EXP 4
8820: IN
8821: AND
8822: IFFALSE 8836
// Say ( Lisa , D8b-Lisa-2 ) ;
8824: LD_EXP 40
8828: PPUSH
8829: LD_STRING D8b-Lisa-2
8831: PPUSH
8832: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8836: LD_EXP 38
8840: PUSH
8841: LD_EXP 38
8845: PUSH
8846: LD_EXP 4
8850: IN
8851: AND
8852: IFFALSE 8868
// Say ( Bobby , D8b-Bobby-1 ) else
8854: LD_EXP 38
8858: PPUSH
8859: LD_STRING D8b-Bobby-1
8861: PPUSH
8862: CALL_OW 88
8866: GO 8928
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8868: LD_ADDR_VAR 0 5
8872: PUSH
8873: LD_EXP 4
8877: PPUSH
8878: LD_INT 26
8880: PUSH
8881: LD_INT 1
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PPUSH
8888: CALL_OW 72
8892: PUSH
8893: LD_EXP 38
8897: PUSH
8898: LD_EXP 39
8902: PUSH
8903: LD_EXP 48
8907: PUSH
8908: LD_EXP 51
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: LIST
8917: LIST
8918: DIFF
8919: PPUSH
8920: LD_STRING D8b-Sol2-1
8922: PPUSH
8923: CALL 640 0 2
8927: ST_TO_ADDR
// DialogueOff ;
8928: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8932: LD_EXP 39
8936: PUSH
8937: LD_EXP 39
8941: PUSH
8942: LD_EXP 4
8946: IN
8947: AND
8948: IFFALSE 8973
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8950: LD_ADDR_VAR 0 6
8954: PUSH
8955: LD_VAR 0 6
8959: PPUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_EXP 39
8967: PPUSH
8968: CALL_OW 2
8972: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8973: LD_EXP 38
8977: PUSH
8978: LD_EXP 38
8982: PUSH
8983: LD_EXP 4
8987: IN
8988: AND
8989: IFFALSE 9014
// tmp := Insert ( tmp , 1 , Bobby ) ;
8991: LD_ADDR_VAR 0 6
8995: PUSH
8996: LD_VAR 0 6
9000: PPUSH
9001: LD_INT 1
9003: PPUSH
9004: LD_EXP 38
9008: PPUSH
9009: CALL_OW 2
9013: ST_TO_ADDR
// if sol then
9014: LD_VAR 0 5
9018: IFFALSE 9043
// tmp := Insert ( tmp , 1 , sol ) ;
9020: LD_ADDR_VAR 0 6
9024: PUSH
9025: LD_VAR 0 6
9029: PPUSH
9030: LD_INT 1
9032: PPUSH
9033: LD_VAR 0 5
9037: PPUSH
9038: CALL_OW 2
9042: ST_TO_ADDR
// if tmp then
9043: LD_VAR 0 6
9047: IFFALSE 9311
// begin SetSide ( tmp , 8 ) ;
9049: LD_VAR 0 6
9053: PPUSH
9054: LD_INT 8
9056: PPUSH
9057: CALL_OW 235
// for i in tmp do
9061: LD_ADDR_VAR 0 7
9065: PUSH
9066: LD_VAR 0 6
9070: PUSH
9071: FOR_IN
9072: IFFALSE 9163
// begin if IsInUnit ( i ) and GetBType ( IsInUnit ( i ) ) = unit_building then
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 310
9083: PUSH
9084: LD_VAR 0 7
9088: PPUSH
9089: CALL_OW 310
9093: PPUSH
9094: CALL_OW 266
9098: PUSH
9099: LD_INT 3
9101: EQUAL
9102: AND
9103: IFFALSE 9114
// ComExitBuilding ( i ) ;
9105: LD_VAR 0 7
9109: PPUSH
9110: CALL_OW 122
// if IsInUnit ( i ) and GetBType ( IsInUnit ( i ) ) = unit_vehicle then
9114: LD_VAR 0 7
9118: PPUSH
9119: CALL_OW 310
9123: PUSH
9124: LD_VAR 0 7
9128: PPUSH
9129: CALL_OW 310
9133: PPUSH
9134: CALL_OW 266
9138: PUSH
9139: LD_INT 2
9141: EQUAL
9142: AND
9143: IFFALSE 9154
// ComExitVehicle ( i ) ;
9145: LD_VAR 0 7
9149: PPUSH
9150: CALL_OW 121
// wait ( 0 0$1 ) ;
9154: LD_INT 35
9156: PPUSH
9157: CALL_OW 67
// end ;
9161: GO 9071
9163: POP
9164: POP
// ComFree ( tmp ) ;
9165: LD_VAR 0 6
9169: PPUSH
9170: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
9174: LD_VAR 0 6
9178: PPUSH
9179: LD_INT 15
9181: PPUSH
9182: CALL_OW 173
// AddComHold ( tmp ) ;
9186: LD_VAR 0 6
9190: PPUSH
9191: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
9195: LD_INT 35
9197: PPUSH
9198: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
9202: LD_VAR 0 6
9206: PUSH
9207: LD_INT 1
9209: ARRAY
9210: PPUSH
9211: CALL_OW 314
9215: NOT
9216: IFFALSE 9230
// ComMoveToArea ( tmp , cyrusEscape ) ;
9218: LD_VAR 0 6
9222: PPUSH
9223: LD_INT 15
9225: PPUSH
9226: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9230: LD_VAR 0 6
9234: PUSH
9235: LD_INT 1
9237: ARRAY
9238: PPUSH
9239: LD_INT 15
9241: PPUSH
9242: CALL_OW 308
9246: IFFALSE 9301
// begin RemoveUnit ( tmp [ 1 ] ) ;
9248: LD_VAR 0 6
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9261: LD_ADDR_EXP 4
9265: PUSH
9266: LD_EXP 4
9270: PUSH
9271: LD_VAR 0 6
9275: PUSH
9276: LD_INT 1
9278: ARRAY
9279: DIFF
9280: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9281: LD_ADDR_VAR 0 6
9285: PUSH
9286: LD_VAR 0 6
9290: PUSH
9291: LD_VAR 0 6
9295: PUSH
9296: LD_INT 1
9298: ARRAY
9299: DIFF
9300: ST_TO_ADDR
// end ; until tmp = 0 ;
9301: LD_VAR 0 6
9305: PUSH
9306: LD_INT 0
9308: EQUAL
9309: IFFALSE 9195
// end ; wait ( 0 0$30 ) ;
9311: LD_INT 1050
9313: PPUSH
9314: CALL_OW 67
// if ru_spec_patrol then
9318: LD_EXP 54
9322: IFFALSE 9350
// for i in ru_spec_patrol do
9324: LD_ADDR_VAR 0 7
9328: PUSH
9329: LD_EXP 54
9333: PUSH
9334: FOR_IN
9335: IFFALSE 9348
// RemoveUnit ( i ) ;
9337: LD_VAR 0 7
9341: PPUSH
9342: CALL_OW 64
9346: GO 9334
9348: POP
9349: POP
// end else
9350: GO 9372
// begin prepare_siege := false ;
9352: LD_ADDR_EXP 31
9356: PUSH
9357: LD_INT 0
9359: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9360: LD_EXP 37
9364: PPUSH
9365: LD_STRING D8a-JMM-1
9367: PPUSH
9368: CALL_OW 88
// end ; end ;
9372: PPOPN 7
9374: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9375: LD_EXP 12
9379: IFFALSE 10596
9381: GO 9383
9383: DISABLE
9384: LD_INT 0
9386: PPUSH
9387: PPUSH
9388: PPUSH
// begin uc_side := 8 ;
9389: LD_ADDR_OWVAR 20
9393: PUSH
9394: LD_INT 8
9396: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9397: LD_ADDR_VAR 0 3
9401: PUSH
9402: LD_INT 59
9404: PUSH
9405: LD_INT 71
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: LD_INT 122
9414: PUSH
9415: LD_INT 117
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9426: LD_ADDR_EXP 51
9430: PUSH
9431: LD_STRING Frank
9433: PPUSH
9434: LD_INT 0
9436: PPUSH
9437: CALL 489 0 2
9441: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9442: LD_ADDR_VAR 0 1
9446: PUSH
9447: LD_INT 1
9449: PPUSH
9450: LD_INT 2
9452: PPUSH
9453: CALL_OW 12
9457: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9458: LD_EXP 51
9462: PPUSH
9463: LD_VAR 0 3
9467: PUSH
9468: LD_VAR 0 1
9472: ARRAY
9473: PUSH
9474: LD_INT 1
9476: ARRAY
9477: PPUSH
9478: LD_VAR 0 3
9482: PUSH
9483: LD_VAR 0 1
9487: ARRAY
9488: PUSH
9489: LD_INT 2
9491: ARRAY
9492: PPUSH
9493: LD_INT 0
9495: PPUSH
9496: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9500: LD_EXP 51
9504: PPUSH
9505: LD_INT 1
9507: PPUSH
9508: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9512: LD_INT 35
9514: PPUSH
9515: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9519: LD_EXP 51
9523: PPUSH
9524: LD_EXP 37
9528: PPUSH
9529: CALL_OW 296
9533: PUSH
9534: LD_INT 8
9536: LESS
9537: PUSH
9538: LD_EXP 51
9542: PPUSH
9543: CALL_OW 256
9547: PUSH
9548: LD_INT 250
9550: GREATER
9551: AND
9552: IFFALSE 9512
// Video ( true ) ;
9554: LD_INT 1
9556: PPUSH
9557: CALL 1200 0 1
// CenterOnUnits ( JMM ) ;
9561: LD_EXP 37
9565: PPUSH
9566: CALL_OW 85
// if IsInUnit ( JMM ) then
9570: LD_EXP 37
9574: PPUSH
9575: CALL_OW 310
9579: IFFALSE 9590
// ComFree ( JMM ) ;
9581: LD_EXP 37
9585: PPUSH
9586: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9590: LD_EXP 37
9594: PPUSH
9595: LD_EXP 51
9599: PPUSH
9600: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9604: LD_EXP 51
9608: PPUSH
9609: LD_EXP 37
9613: PPUSH
9614: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9618: LD_EXP 37
9622: PPUSH
9623: LD_STRING D6-JMM-1
9625: PPUSH
9626: CALL_OW 88
// p := 0 ;
9630: LD_ADDR_VAR 0 2
9634: PUSH
9635: LD_INT 0
9637: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9638: LD_INT 35
9640: PPUSH
9641: CALL_OW 67
// p := p + 1 ;
9645: LD_ADDR_VAR 0 2
9649: PUSH
9650: LD_VAR 0 2
9654: PUSH
9655: LD_INT 1
9657: PLUS
9658: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9659: LD_EXP 37
9663: PPUSH
9664: LD_EXP 51
9668: PPUSH
9669: CALL_OW 296
9673: PUSH
9674: LD_INT 8
9676: LESS
9677: PUSH
9678: LD_VAR 0 2
9682: PUSH
9683: LD_INT 7
9685: GREATER
9686: OR
9687: IFFALSE 9638
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9689: LD_EXP 40
9693: PUSH
9694: LD_EXP 40
9698: PPUSH
9699: LD_EXP 51
9703: PPUSH
9704: CALL_OW 296
9708: PUSH
9709: LD_INT 20
9711: LESS
9712: AND
9713: IFFALSE 9738
// begin ComFree ( Lisa ) ;
9715: LD_EXP 40
9719: PPUSH
9720: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9724: LD_EXP 40
9728: PPUSH
9729: LD_EXP 51
9733: PPUSH
9734: CALL_OW 172
// end ; if Lynch then
9738: LD_EXP 47
9742: IFFALSE 9767
// begin ComFree ( Lynch ) ;
9744: LD_EXP 47
9748: PPUSH
9749: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9753: LD_EXP 47
9757: PPUSH
9758: LD_EXP 51
9762: PPUSH
9763: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9767: LD_EXP 37
9771: PPUSH
9772: LD_EXP 51
9776: PPUSH
9777: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9781: LD_EXP 51
9785: PPUSH
9786: LD_EXP 37
9790: PPUSH
9791: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9795: LD_EXP 51
9799: PPUSH
9800: LD_STRING D6-Frank-1
9802: PPUSH
9803: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9807: LD_INT 69
9809: PPUSH
9810: LD_INT 20
9812: PPUSH
9813: LD_INT 1
9815: PPUSH
9816: LD_INT 20
9818: NEG
9819: PPUSH
9820: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9824: LD_INT 69
9826: PPUSH
9827: LD_INT 20
9829: PPUSH
9830: LD_INT 1
9832: PPUSH
9833: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9837: LD_INT 190
9839: PPUSH
9840: LD_INT 31
9842: PPUSH
9843: LD_INT 1
9845: PPUSH
9846: LD_INT 20
9848: NEG
9849: PPUSH
9850: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9854: LD_INT 190
9856: PPUSH
9857: LD_INT 31
9859: PPUSH
9860: LD_INT 1
9862: PPUSH
9863: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9867: LD_INT 69
9869: PPUSH
9870: LD_INT 20
9872: PPUSH
9873: CALL_OW 84
// Wait ( 0 0$02 ) ;
9877: LD_INT 70
9879: PPUSH
9880: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9884: LD_EXP 37
9888: PPUSH
9889: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9893: LD_EXP 40
9897: PUSH
9898: LD_EXP 40
9902: PPUSH
9903: LD_EXP 51
9907: PPUSH
9908: CALL_OW 296
9912: PUSH
9913: LD_INT 20
9915: LESS
9916: AND
9917: PUSH
9918: LD_EXP 40
9922: PPUSH
9923: CALL_OW 302
9927: AND
9928: IFFALSE 10050
// begin ComFree ( Lisa ) ;
9930: LD_EXP 40
9934: PPUSH
9935: CALL_OW 139
// p := 0 ;
9939: LD_ADDR_VAR 0 2
9943: PUSH
9944: LD_INT 0
9946: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// p := p + 1 ;
9954: LD_ADDR_VAR 0 2
9958: PUSH
9959: LD_VAR 0 2
9963: PUSH
9964: LD_INT 1
9966: PLUS
9967: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9968: LD_EXP 40
9972: PPUSH
9973: LD_EXP 51
9977: PPUSH
9978: CALL_OW 296
9982: PUSH
9983: LD_INT 7
9985: LESS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 7
9994: GREATER
9995: OR
9996: IFFALSE 9947
// Say ( Lisa , D6-Lisa-1 ) ;
9998: LD_EXP 40
10002: PPUSH
10003: LD_STRING D6-Lisa-1
10005: PPUSH
10006: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
10010: LD_EXP 40
10014: PPUSH
10015: LD_EXP 51
10019: PPUSH
10020: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
10024: LD_EXP 51
10028: PPUSH
10029: LD_EXP 40
10033: PPUSH
10034: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
10038: LD_EXP 51
10042: PPUSH
10043: LD_STRING D6-Frank-2
10045: PPUSH
10046: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
10050: LD_EXP 47
10054: PUSH
10055: LD_EXP 47
10059: PPUSH
10060: LD_EXP 51
10064: PPUSH
10065: CALL_OW 296
10069: PUSH
10070: LD_INT 20
10072: LESS
10073: AND
10074: PUSH
10075: LD_EXP 47
10079: PPUSH
10080: CALL_OW 302
10084: AND
10085: IFFALSE 10266
// begin ComTurnUnit ( Lynch , JMM ) ;
10087: LD_EXP 47
10091: PPUSH
10092: LD_EXP 37
10096: PPUSH
10097: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
10101: LD_EXP 51
10105: PPUSH
10106: LD_EXP 37
10110: PPUSH
10111: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
10115: LD_EXP 47
10119: PPUSH
10120: LD_STRING D6-Sol1-2
10122: PPUSH
10123: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
10127: LD_EXP 37
10131: PPUSH
10132: LD_STRING D6-JMM-2
10134: PPUSH
10135: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
10139: LD_EXP 51
10143: PPUSH
10144: LD_STRING D6-Frank-3
10146: PPUSH
10147: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
10151: LD_EXP 37
10155: PPUSH
10156: LD_STRING D6-JMM-3
10158: PPUSH
10159: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
10163: LD_EXP 51
10167: PPUSH
10168: LD_STRING D6-Frank-4
10170: PPUSH
10171: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10175: LD_EXP 51
10179: PPUSH
10180: LD_STRING D6-Frank-4a
10182: PPUSH
10183: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10187: LD_EXP 37
10191: PPUSH
10192: LD_STRING D6-JMM-4
10194: PPUSH
10195: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10199: LD_EXP 51
10203: PPUSH
10204: LD_STRING D6-Frank-5
10206: PPUSH
10207: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10211: LD_EXP 40
10215: PUSH
10216: LD_EXP 40
10220: PPUSH
10221: CALL_OW 302
10225: AND
10226: IFFALSE 10240
// Say ( Lisa , D6-Lisa-5 ) ;
10228: LD_EXP 40
10232: PPUSH
10233: LD_STRING D6-Lisa-5
10235: PPUSH
10236: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10240: LD_EXP 51
10244: PPUSH
10245: LD_STRING D6-Frank-6
10247: PPUSH
10248: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10252: LD_EXP 37
10256: PPUSH
10257: LD_STRING D6-JMM-6
10259: PPUSH
10260: CALL_OW 88
// end else
10264: GO 10381
// begin ComTurnUnit ( Frank , JMM ) ;
10266: LD_EXP 51
10270: PPUSH
10271: LD_EXP 37
10275: PPUSH
10276: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10280: LD_EXP 51
10284: PPUSH
10285: LD_STRING D6-Frank-4
10287: PPUSH
10288: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10292: LD_EXP 51
10296: PPUSH
10297: LD_STRING D6-Frank-4a
10299: PPUSH
10300: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10304: LD_EXP 37
10308: PPUSH
10309: LD_STRING D6-JMM-4
10311: PPUSH
10312: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10316: LD_EXP 51
10320: PPUSH
10321: LD_STRING D6-Frank-5
10323: PPUSH
10324: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10328: LD_EXP 40
10332: PUSH
10333: LD_EXP 40
10337: PPUSH
10338: CALL_OW 302
10342: AND
10343: IFFALSE 10357
// Say ( Lisa , D6-Lisa-5 ) ;
10345: LD_EXP 40
10349: PPUSH
10350: LD_STRING D6-Lisa-5
10352: PPUSH
10353: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10357: LD_EXP 51
10361: PPUSH
10362: LD_STRING D6-Frank-6
10364: PPUSH
10365: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10369: LD_EXP 37
10373: PPUSH
10374: LD_STRING D6-JMM-6
10376: PPUSH
10377: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10381: LD_STRING Q1
10383: PPUSH
10384: CALL_OW 97
10388: PUSH
10389: LD_INT 1
10391: DOUBLE
10392: EQUAL
10393: IFTRUE 10397
10395: GO 10408
10397: POP
// frank_send_to_scout := true ; 2 :
10398: LD_ADDR_EXP 15
10402: PUSH
10403: LD_INT 1
10405: ST_TO_ADDR
10406: GO 10428
10408: LD_INT 2
10410: DOUBLE
10411: EQUAL
10412: IFTRUE 10416
10414: GO 10427
10416: POP
// frank_send_to_scout := false ; end ;
10417: LD_ADDR_EXP 15
10421: PUSH
10422: LD_INT 0
10424: ST_TO_ADDR
10425: GO 10428
10427: POP
// Video ( false ) ;
10428: LD_INT 0
10430: PPUSH
10431: CALL 1200 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10435: LD_EXP 37
10439: PUSH
10440: LD_EXP 40
10444: PUSH
10445: LD_EXP 47
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: LIST
10454: PPUSH
10455: CALL_OW 139
// if frank_send_to_scout then
10459: LD_EXP 15
10463: IFFALSE 10517
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10465: LD_EXP 51
10469: PPUSH
10470: LD_INT 15
10472: PPUSH
10473: CALL_OW 113
// wait ( 0 0$01 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until not See ( 1 , Frank ) ;
10484: LD_INT 1
10486: PPUSH
10487: LD_EXP 51
10491: PPUSH
10492: CALL_OW 292
10496: NOT
10497: IFFALSE 10465
// wait ( 0 0$02 ) ;
10499: LD_INT 70
10501: PPUSH
10502: CALL_OW 67
// RemoveUnit ( Frank ) ;
10506: LD_EXP 51
10510: PPUSH
10511: CALL_OW 64
// end else
10515: GO 10529
// SetSide ( Frank , 1 ) ;
10517: LD_EXP 51
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL_OW 235
// send_attack_on_cornel_base := true ;
10529: LD_ADDR_EXP 26
10533: PUSH
10534: LD_INT 1
10536: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10537: LD_INT 35
10539: PPUSH
10540: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10544: LD_ADDR_EXP 29
10548: PUSH
10549: LD_EXP 29
10553: PPUSH
10554: LD_STRING -
10556: PPUSH
10557: CALL 1132 0 2
10561: ST_TO_ADDR
// if debug then
10562: LD_EXP 1
10566: IFFALSE 10578
// debug_strings := time_to_prepare ;
10568: LD_ADDR_OWVAR 48
10572: PUSH
10573: LD_EXP 29
10577: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10578: LD_EXP 29
10582: PUSH
10583: LD_INT 0
10585: EQUAL
10586: IFFALSE 10537
// cornel_prepared := true ;
10588: LD_ADDR_EXP 11
10592: PUSH
10593: LD_INT 1
10595: ST_TO_ADDR
// end ;
10596: PPOPN 3
10598: END
// every 0 0$01 trigger cornel_prepared do
10599: LD_EXP 11
10603: IFFALSE 10908
10605: GO 10607
10607: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10608: LD_EXP 44
10612: PPUSH
10613: LD_STRING D3-Corn-1
10615: PPUSH
10616: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10620: LD_STRING MOutWait
10622: PPUSH
10623: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10627: LD_INT 35
10629: PPUSH
10630: CALL_OW 67
// until cornel_counter = 0 ;
10634: LD_EXP 10
10638: PUSH
10639: LD_INT 0
10641: EQUAL
10642: IFFALSE 10627
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10644: LD_EXP 44
10648: PPUSH
10649: LD_STRING D3a-Corn-1
10651: PPUSH
10652: CALL_OW 94
// if IsOk ( Cornel ) then
10656: LD_EXP 44
10660: PPUSH
10661: CALL_OW 302
10665: IFFALSE 10679
// Say ( JMM , D3a-JMM-1 ) ;
10667: LD_EXP 37
10671: PPUSH
10672: LD_STRING D3a-JMM-1
10674: PPUSH
10675: CALL_OW 88
// end_mission_allowed := true ;
10679: LD_ADDR_EXP 21
10683: PUSH
10684: LD_INT 1
10686: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10687: LD_STRING M2
10689: PPUSH
10690: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10694: LD_INT 9
10696: PPUSH
10697: LD_INT 1
10699: PPUSH
10700: CALL_OW 424
// Wait ( 0 0$05 ) ;
10704: LD_INT 175
10706: PPUSH
10707: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10711: LD_EXP 44
10715: PPUSH
10716: LD_STRING D3a-Corn-2
10718: PPUSH
10719: CALL_OW 94
// cornel_attack := true ;
10723: LD_ADDR_EXP 9
10727: PUSH
10728: LD_INT 1
10730: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10731: LD_INT 105
10733: PPUSH
10734: CALL_OW 67
// AddMoreTanks ( ) ;
10738: CALL 4952 0 0
// if frank_send_to_scout then
10742: LD_EXP 15
10746: IFFALSE 10908
// begin InitHc ;
10748: CALL_OW 19
// InitUc ;
10752: CALL_OW 18
// uc_side := 8 ;
10756: LD_ADDR_OWVAR 20
10760: PUSH
10761: LD_INT 8
10763: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10764: LD_ADDR_EXP 51
10768: PUSH
10769: LD_STRING Frank
10771: PPUSH
10772: LD_INT 0
10774: PPUSH
10775: CALL 489 0 2
10779: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10780: LD_EXP 51
10784: PPUSH
10785: LD_INT 6
10787: PPUSH
10788: LD_INT 9
10790: PPUSH
10791: LD_INT 0
10793: PPUSH
10794: CALL_OW 48
// ComCrawl ( Frank ) ;
10798: LD_EXP 51
10802: PPUSH
10803: CALL_OW 137
// repeat wait ( 10 ) ;
10807: LD_INT 10
10809: PPUSH
10810: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 or FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10814: LD_EXP 37
10818: PPUSH
10819: LD_EXP 51
10823: PPUSH
10824: CALL_OW 296
10828: PUSH
10829: LD_INT 9
10831: LESS
10832: PUSH
10833: LD_INT 9
10835: PPUSH
10836: LD_INT 22
10838: PUSH
10839: LD_INT 1
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PPUSH
10846: CALL_OW 70
10850: OR
10851: IFFALSE 10807
// if IsDead ( Frank ) then
10853: LD_EXP 51
10857: PPUSH
10858: CALL_OW 301
10862: IFFALSE 10866
// exit ;
10864: GO 10908
// CenterOnUnits ( Frank ) ;
10866: LD_EXP 51
10870: PPUSH
10871: CALL_OW 85
// SetSide ( Frank , 1 ) ;
10875: LD_EXP 51
10879: PPUSH
10880: LD_INT 1
10882: PPUSH
10883: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10887: LD_EXP 51
10891: PPUSH
10892: LD_STRING D6a-Frank-1
10894: PPUSH
10895: CALL_OW 88
// ComWalk ( Frank ) ;
10899: LD_EXP 51
10903: PPUSH
10904: CALL_OW 138
// end ; end ;
10908: END
// every 0 0$01 trigger solar_builded do
10909: LD_EXP 14
10913: IFFALSE 11017
10915: GO 10917
10917: DISABLE
// begin Wait ( 0 0$02 ) ;
10918: LD_INT 70
10920: PPUSH
10921: CALL_OW 67
// DialogueOn ;
10925: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10929: LD_EXP 37
10933: PPUSH
10934: LD_STRING D2b-JMM-1
10936: PPUSH
10937: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10941: LD_EXP 48
10945: PUSH
10946: LD_EXP 48
10950: PPUSH
10951: CALL_OW 302
10955: AND
10956: IFFALSE 11006
// begin Say ( Walker , D2b-Sci1-1 ) ;
10958: LD_EXP 48
10962: PPUSH
10963: LD_STRING D2b-Sci1-1
10965: PPUSH
10966: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10970: LD_EXP 37
10974: PPUSH
10975: LD_STRING D2b-JMM-2
10977: PPUSH
10978: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10982: LD_EXP 48
10986: PPUSH
10987: LD_STRING D2b-Sci1-2
10989: PPUSH
10990: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10994: LD_EXP 37
10998: PPUSH
10999: LD_STRING D2b-JMM-3
11001: PPUSH
11002: CALL_OW 88
// end ; DialogueOff ;
11006: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
11010: LD_STRING MOutSol
11012: PPUSH
11013: CALL_OW 337
// end ;
11017: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
11018: LD_EXP 14
11022: PUSH
11023: LD_EXP 37
11027: PPUSH
11028: CALL_OW 302
11032: AND
11033: PUSH
11034: LD_EXP 37
11038: PPUSH
11039: CALL 966 0 1
11043: AND
11044: PUSH
11045: LD_EXP 16
11049: NOT
11050: AND
11051: IFFALSE 11122
11053: GO 11055
11055: DISABLE
11056: LD_INT 0
11058: PPUSH
// begin jmm_in_veh := true ;
11059: LD_ADDR_EXP 16
11063: PUSH
11064: LD_INT 1
11066: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11067: LD_ADDR_VAR 0 1
11071: PUSH
11072: LD_INT 0
11074: PPUSH
11075: LD_INT 1
11077: PPUSH
11078: CALL_OW 12
11082: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11083: LD_INT 70
11085: PPUSH
11086: CALL_OW 67
// if i then
11090: LD_VAR 0 1
11094: IFFALSE 11110
// Say ( JMM , D2c-JMM-1 ) else
11096: LD_EXP 37
11100: PPUSH
11101: LD_STRING D2c-JMM-1
11103: PPUSH
11104: CALL_OW 88
11108: GO 11122
// Say ( JMM , D2c-JMM-1a ) ;
11110: LD_EXP 37
11114: PPUSH
11115: LD_STRING D2c-JMM-1a
11117: PPUSH
11118: CALL_OW 88
// end ;
11122: PPOPN 1
11124: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
11125: LD_EXP 14
11129: PUSH
11130: LD_EXP 38
11134: PPUSH
11135: CALL_OW 302
11139: AND
11140: PUSH
11141: LD_EXP 38
11145: PPUSH
11146: CALL 966 0 1
11150: AND
11151: PUSH
11152: LD_EXP 17
11156: NOT
11157: AND
11158: IFFALSE 11190
11160: GO 11162
11162: DISABLE
// begin bobby_in_veh := true ;
11163: LD_ADDR_EXP 17
11167: PUSH
11168: LD_INT 1
11170: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11171: LD_INT 70
11173: PPUSH
11174: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
11178: LD_EXP 38
11182: PPUSH
11183: LD_STRING D2c-Bobby-1
11185: PPUSH
11186: CALL_OW 88
11190: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
11191: LD_EXP 14
11195: PUSH
11196: LD_EXP 40
11200: PPUSH
11201: CALL_OW 302
11205: AND
11206: PUSH
11207: LD_EXP 40
11211: PPUSH
11212: CALL 966 0 1
11216: AND
11217: PUSH
11218: LD_EXP 19
11222: NOT
11223: AND
11224: IFFALSE 11256
11226: GO 11228
11228: DISABLE
// begin lisa_in_veh := true ;
11229: LD_ADDR_EXP 19
11233: PUSH
11234: LD_INT 1
11236: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11237: LD_INT 70
11239: PPUSH
11240: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
11244: LD_EXP 40
11248: PPUSH
11249: LD_STRING D2c-Lisa-1
11251: PPUSH
11252: CALL_OW 88
11256: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11257: LD_EXP 14
11261: PUSH
11262: LD_EXP 39
11266: PPUSH
11267: CALL_OW 302
11271: AND
11272: PUSH
11273: LD_EXP 39
11277: PPUSH
11278: CALL 966 0 1
11282: AND
11283: PUSH
11284: LD_EXP 18
11288: NOT
11289: AND
11290: IFFALSE 11361
11292: GO 11294
11294: DISABLE
11295: LD_INT 0
11297: PPUSH
// begin cyrus_in_veh := true ;
11298: LD_ADDR_EXP 18
11302: PUSH
11303: LD_INT 1
11305: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11306: LD_ADDR_VAR 0 1
11310: PUSH
11311: LD_INT 0
11313: PPUSH
11314: LD_INT 1
11316: PPUSH
11317: CALL_OW 12
11321: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11322: LD_INT 70
11324: PPUSH
11325: CALL_OW 67
// if i then
11329: LD_VAR 0 1
11333: IFFALSE 11349
// Say ( Cyrus , D2c-Cyrus-1 ) else
11335: LD_EXP 39
11339: PPUSH
11340: LD_STRING D2c-Cyrus-1
11342: PPUSH
11343: CALL_OW 88
11347: GO 11361
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11349: LD_EXP 39
11353: PPUSH
11354: LD_STRING D2c-Cyrus-1a
11356: PPUSH
11357: CALL_OW 88
// end ;
11361: PPOPN 1
11363: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11364: LD_EXP 44
11368: PPUSH
11369: LD_INT 16
11371: PPUSH
11372: CALL_OW 308
11376: IFFALSE 11657
11378: GO 11380
11380: DISABLE
11381: LD_INT 0
11383: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11384: LD_INT 3
11386: PPUSH
11387: LD_EXP 44
11391: PPUSH
11392: CALL_OW 471
// send_attack_on_cornel := true ;
11396: LD_ADDR_EXP 32
11400: PUSH
11401: LD_INT 1
11403: ST_TO_ADDR
// if ru_vehicles then
11404: LD_EXP 56
11408: IFFALSE 11442
// for i in ru_vehicles do
11410: LD_ADDR_VAR 0 1
11414: PUSH
11415: LD_EXP 56
11419: PUSH
11420: FOR_IN
11421: IFFALSE 11440
// ComAgressiveMove ( i , 215 , 69 ) ;
11423: LD_VAR 0 1
11427: PPUSH
11428: LD_INT 215
11430: PPUSH
11431: LD_INT 69
11433: PPUSH
11434: CALL_OW 114
11438: GO 11420
11440: POP
11441: POP
// if ru_patrol then
11442: LD_EXP 53
11446: IFFALSE 11480
// for i in ru_patrol do
11448: LD_ADDR_VAR 0 1
11452: PUSH
11453: LD_EXP 53
11457: PUSH
11458: FOR_IN
11459: IFFALSE 11478
// ComAgressiveMove ( i , 215 , 69 ) ;
11461: LD_VAR 0 1
11465: PPUSH
11466: LD_INT 215
11468: PPUSH
11469: LD_INT 69
11471: PPUSH
11472: CALL_OW 114
11476: GO 11458
11478: POP
11479: POP
// if frank_send_to_scout then
11480: LD_EXP 15
11484: IFFALSE 11498
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11486: LD_EXP 51
11490: PPUSH
11491: LD_STRING D3b-Frank-1
11493: PPUSH
11494: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11498: LD_INT 105
11500: PPUSH
11501: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11505: LD_EXP 44
11509: PPUSH
11510: LD_STRING D4-Corn-1
11512: PPUSH
11513: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11517: LD_INT 35
11519: PPUSH
11520: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11524: LD_INT 22
11526: PUSH
11527: LD_INT 4
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 21
11536: PUSH
11537: LD_INT 1
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: PUSH
11544: LD_INT 3
11546: PUSH
11547: LD_INT 24
11549: PUSH
11550: LD_INT 1000
11552: PUSH
11553: EMPTY
11554: LIST
11555: LIST
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: LIST
11565: PPUSH
11566: CALL_OW 69
11570: PUSH
11571: LD_INT 6
11573: LESS
11574: IFFALSE 11517
// if Cornel then
11576: LD_EXP 44
11580: IFFALSE 11620
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11582: LD_EXP 44
11586: PPUSH
11587: LD_STRING D5-Corn-1
11589: PPUSH
11590: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11594: LD_EXP 44
11598: PPUSH
11599: LD_EXP 2
11603: PUSH
11604: LD_STRING Cornel
11606: STR
11607: PPUSH
11608: CALL_OW 38
// cornel_saved := true ;
11612: LD_ADDR_EXP 27
11616: PUSH
11617: LD_INT 1
11619: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11620: LD_INT 4
11622: PPUSH
11623: LD_INT 8
11625: PPUSH
11626: CALL_OW 343
// Wait ( 0 0$01 ) ;
11630: LD_INT 35
11632: PPUSH
11633: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11637: LD_INT 3
11639: PPUSH
11640: LD_EXP 44
11644: PPUSH
11645: CALL_OW 472
// send_attack_on_cornel := false ;
11649: LD_ADDR_EXP 32
11653: PUSH
11654: LD_INT 0
11656: ST_TO_ADDR
// end ;
11657: PPOPN 1
11659: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11660: LD_INT 9
11662: PPUSH
11663: LD_INT 22
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PPUSH
11673: CALL_OW 70
11677: PUSH
11678: LD_EXP 33
11682: OR
11683: IFFALSE 11904
11685: GO 11687
11687: DISABLE
11688: LD_INT 0
11690: PPUSH
11691: PPUSH
// begin enable ;
11692: ENABLE
// if not jmm_on_west then
11693: LD_EXP 5
11697: NOT
11698: IFFALSE 11709
// begin YouLost ( 4 ) ;
11700: LD_STRING 4
11702: PPUSH
11703: CALL_OW 104
// exit ;
11707: GO 11904
// end ; if not game_end then
11709: LD_EXP 33
11713: NOT
11714: IFFALSE 11724
// game_end := true ;
11716: LD_ADDR_EXP 33
11720: PUSH
11721: LD_INT 1
11723: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11724: LD_ADDR_VAR 0 2
11728: PUSH
11729: LD_INT 9
11731: PPUSH
11732: LD_INT 22
11734: PUSH
11735: LD_INT 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PPUSH
11742: CALL_OW 70
11746: ST_TO_ADDR
// if not filter then
11747: LD_VAR 0 2
11751: NOT
11752: IFFALSE 11756
// exit ;
11754: GO 11904
// for i in filter do
11756: LD_ADDR_VAR 0 1
11760: PUSH
11761: LD_VAR 0 2
11765: PUSH
11766: FOR_IN
11767: IFFALSE 11902
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11769: LD_VAR 0 1
11773: PPUSH
11774: CALL_OW 302
11778: PUSH
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 247
11788: PUSH
11789: LD_INT 2
11791: EQUAL
11792: AND
11793: PUSH
11794: LD_VAR 0 1
11798: PPUSH
11799: CALL_OW 248
11803: PUSH
11804: LD_INT 1
11806: EQUAL
11807: AND
11808: IFFALSE 11865
// begin if i = JMM and save_group < 4 then
11810: LD_VAR 0 1
11814: PUSH
11815: LD_EXP 37
11819: EQUAL
11820: PUSH
11821: LD_EXP 23
11825: PUSH
11826: LD_INT 4
11828: LESS
11829: AND
11830: IFFALSE 11834
// continue ;
11832: GO 11766
// veh_on_meta := true ;
11834: LD_ADDR_EXP 28
11838: PUSH
11839: LD_INT 1
11841: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11842: LD_VAR 0 1
11846: PPUSH
11847: CALL_OW 311
11851: PPUSH
11852: CALL 11907 0 1
// RemoveUnit ( i ) ;
11856: LD_VAR 0 1
11860: PPUSH
11861: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11865: LD_VAR 0 1
11869: PPUSH
11870: CALL_OW 302
11874: PUSH
11875: LD_VAR 0 1
11879: PPUSH
11880: CALL_OW 247
11884: PUSH
11885: LD_INT 1
11887: EQUAL
11888: AND
11889: IFFALSE 11900
// Save ( i ) ;
11891: LD_VAR 0 1
11895: PPUSH
11896: CALL 11907 0 1
// end ;
11900: GO 11766
11902: POP
11903: POP
// end ;
11904: PPOPN 2
11906: END
// export function Save ( i ) ; begin
11907: LD_INT 0
11909: PPUSH
// if i = JMM and save_group >= 4 then
11910: LD_VAR 0 1
11914: PUSH
11915: LD_EXP 37
11919: EQUAL
11920: PUSH
11921: LD_EXP 23
11925: PUSH
11926: LD_INT 4
11928: GREATEREQUAL
11929: AND
11930: IFFALSE 12066
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11932: LD_EXP 24
11936: PUSH
11937: LD_INT 22
11939: PUSH
11940: LD_INT 1
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 21
11949: PUSH
11950: LD_INT 1
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PPUSH
11961: CALL_OW 69
11965: PUSH
11966: LD_INT 1
11968: GREATER
11969: AND
11970: IFFALSE 12027
// begin show_query := false ;
11972: LD_ADDR_EXP 24
11976: PUSH
11977: LD_INT 0
11979: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11980: LD_STRING Q2
11982: PPUSH
11983: CALL_OW 97
11987: PUSH
11988: LD_INT 1
11990: DOUBLE
11991: EQUAL
11992: IFTRUE 11996
11994: GO 12007
11996: POP
// wait_for_them := true ; 2 :
11997: LD_ADDR_EXP 25
12001: PUSH
12002: LD_INT 1
12004: ST_TO_ADDR
12005: GO 12027
12007: LD_INT 2
12009: DOUBLE
12010: EQUAL
12011: IFTRUE 12015
12013: GO 12026
12015: POP
// wait_for_them := false ; end ;
12016: LD_ADDR_EXP 25
12020: PUSH
12021: LD_INT 0
12023: ST_TO_ADDR
12024: GO 12027
12026: POP
// end ; save_counter := save_counter + 1 ;
12027: LD_ADDR_EXP 36
12031: PUSH
12032: LD_EXP 36
12036: PUSH
12037: LD_INT 1
12039: PLUS
12040: ST_TO_ADDR
// save_group := save_group ^ JMM ;
12041: LD_ADDR_EXP 23
12045: PUSH
12046: LD_EXP 23
12050: PUSH
12051: LD_EXP 37
12055: ADD
12056: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
12057: LD_EXP 37
12061: PPUSH
12062: CALL_OW 64
// end ; if i = Lisa then
12066: LD_VAR 0 1
12070: PUSH
12071: LD_EXP 40
12075: EQUAL
12076: IFFALSE 12117
// begin save_counter := save_counter + 1 ;
12078: LD_ADDR_EXP 36
12082: PUSH
12083: LD_EXP 36
12087: PUSH
12088: LD_INT 1
12090: PLUS
12091: ST_TO_ADDR
// save_group := save_group ^ Lisa ;
12092: LD_ADDR_EXP 23
12096: PUSH
12097: LD_EXP 23
12101: PUSH
12102: LD_EXP 40
12106: ADD
12107: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
12108: LD_EXP 40
12112: PPUSH
12113: CALL_OW 64
// end ; if i = Bobby then
12117: LD_VAR 0 1
12121: PUSH
12122: LD_EXP 38
12126: EQUAL
12127: IFFALSE 12168
// begin save_counter := save_counter + 1 ;
12129: LD_ADDR_EXP 36
12133: PUSH
12134: LD_EXP 36
12138: PUSH
12139: LD_INT 1
12141: PLUS
12142: ST_TO_ADDR
// save_group := save_group ^ Bobby ;
12143: LD_ADDR_EXP 23
12147: PUSH
12148: LD_EXP 23
12152: PUSH
12153: LD_EXP 38
12157: ADD
12158: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
12159: LD_EXP 38
12163: PPUSH
12164: CALL_OW 64
// end ; if i = Cyrus then
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 39
12177: EQUAL
12178: IFFALSE 12219
// begin save_counter := save_counter + 1 ;
12180: LD_ADDR_EXP 36
12184: PUSH
12185: LD_EXP 36
12189: PUSH
12190: LD_INT 1
12192: PLUS
12193: ST_TO_ADDR
// save_group := save_group ^ Cyrus ;
12194: LD_ADDR_EXP 23
12198: PUSH
12199: LD_EXP 23
12203: PUSH
12204: LD_EXP 39
12208: ADD
12209: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
12210: LD_EXP 39
12214: PPUSH
12215: CALL_OW 64
// end ; if i = Khatam then
12219: LD_VAR 0 1
12223: PUSH
12224: LD_EXP 41
12228: EQUAL
12229: IFFALSE 12270
// begin save_counter := save_counter + 1 ;
12231: LD_ADDR_EXP 36
12235: PUSH
12236: LD_EXP 36
12240: PUSH
12241: LD_INT 1
12243: PLUS
12244: ST_TO_ADDR
// save_group := save_group ^ Khatam ;
12245: LD_ADDR_EXP 23
12249: PUSH
12250: LD_EXP 23
12254: PUSH
12255: LD_EXP 41
12259: ADD
12260: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
12261: LD_EXP 41
12265: PPUSH
12266: CALL_OW 64
// end ; if i = Frank then
12270: LD_VAR 0 1
12274: PUSH
12275: LD_EXP 51
12279: EQUAL
12280: IFFALSE 12321
// begin save_counter := save_counter + 1 ;
12282: LD_ADDR_EXP 36
12286: PUSH
12287: LD_EXP 36
12291: PUSH
12292: LD_INT 1
12294: PLUS
12295: ST_TO_ADDR
// save_group := save_group ^ Frank ;
12296: LD_ADDR_EXP 23
12300: PUSH
12301: LD_EXP 23
12305: PUSH
12306: LD_EXP 51
12310: ADD
12311: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
12312: LD_EXP 51
12316: PPUSH
12317: CALL_OW 64
// end ; if i <> JMM and IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
12321: LD_VAR 0 1
12325: PUSH
12326: LD_EXP 37
12330: NONEQUAL
12331: PUSH
12332: LD_VAR 0 1
12336: PPUSH
12337: CALL_OW 302
12341: AND
12342: PUSH
12343: LD_VAR 0 1
12347: PPUSH
12348: CALL_OW 247
12352: PUSH
12353: LD_INT 1
12355: EQUAL
12356: AND
12357: PUSH
12358: LD_VAR 0 1
12362: PUSH
12363: LD_EXP 23
12367: IN
12368: NOT
12369: AND
12370: IFFALSE 12411
// begin save_counter := save_counter + 1 ;
12372: LD_ADDR_EXP 36
12376: PUSH
12377: LD_EXP 36
12381: PUSH
12382: LD_INT 1
12384: PLUS
12385: ST_TO_ADDR
// save_others := save_others ^ i ;
12386: LD_ADDR_EXP 22
12390: PUSH
12391: LD_EXP 22
12395: PUSH
12396: LD_VAR 0 1
12400: ADD
12401: ST_TO_ADDR
// RemoveUnit ( i ) ;
12402: LD_VAR 0 1
12406: PPUSH
12407: CALL_OW 64
// end ; end ;
12411: LD_VAR 0 2
12415: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12416: LD_EXP 24
12420: NOT
12421: PUSH
12422: LD_EXP 25
12426: NOT
12427: AND
12428: PUSH
12429: LD_INT 22
12431: PUSH
12432: LD_INT 1
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: PUSH
12439: LD_INT 21
12441: PUSH
12442: LD_INT 1
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 69
12457: PUSH
12458: LD_INT 0
12460: EQUAL
12461: OR
12462: IFFALSE 12471
12464: GO 12466
12466: DISABLE
// EndMission ;
12467: CALL 12472 0 0
12471: END
// export function EndMission ; var i , m1 , m2 , m3 ; begin
12472: LD_INT 0
12474: PPUSH
12475: PPUSH
12476: PPUSH
12477: PPUSH
12478: PPUSH
// wait ( 0 0$01 ) ;
12479: LD_INT 35
12481: PPUSH
12482: CALL_OW 67
// if tick <= 12 12$00 then
12486: LD_OWVAR 1
12490: PUSH
12491: LD_INT 25200
12493: LESSEQUAL
12494: IFFALSE 12503
// SetAchievement ( ACH_ASPEED_3 ) ;
12496: LD_STRING ACH_ASPEED_3
12498: PPUSH
12499: CALL_OW 543
// if UnitFilter ( save_group ^ save_others , [ f_class , 4 ] ) = 0 then
12503: LD_EXP 23
12507: PUSH
12508: LD_EXP 22
12512: ADD
12513: PPUSH
12514: LD_INT 25
12516: PUSH
12517: LD_INT 4
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: PPUSH
12524: CALL_OW 72
12528: PUSH
12529: LD_INT 0
12531: EQUAL
12532: IFFALSE 12548
// begin wait ( 3 ) ;
12534: LD_INT 3
12536: PPUSH
12537: CALL_OW 67
// SetAchievement ( ACH_NOSCI ) ;
12541: LD_STRING ACH_NOSCI
12543: PPUSH
12544: CALL_OW 543
// end ; m1 := solar_builded ;
12548: LD_ADDR_VAR 0 3
12552: PUSH
12553: LD_EXP 14
12557: ST_TO_ADDR
// m2 := veh_on_meta ;
12558: LD_ADDR_VAR 0 4
12562: PUSH
12563: LD_EXP 28
12567: ST_TO_ADDR
// m3 := ( lose_counter = 0 ) ;
12568: LD_ADDR_VAR 0 5
12572: PUSH
12573: LD_EXP 34
12577: PUSH
12578: LD_INT 0
12580: EQUAL
12581: ST_TO_ADDR
// if solar_builded then
12582: LD_EXP 14
12586: IFFALSE 12600
// AddMedal ( Solar1 , 1 ) else
12588: LD_STRING Solar1
12590: PPUSH
12591: LD_INT 1
12593: PPUSH
12594: CALL_OW 101
12598: GO 12611
// AddMedal ( Solar1 , - 1 ) ;
12600: LD_STRING Solar1
12602: PPUSH
12603: LD_INT 1
12605: NEG
12606: PPUSH
12607: CALL_OW 101
// if veh_on_meta then
12611: LD_EXP 28
12615: IFFALSE 12629
// AddMedal ( Solar2 , 1 ) else
12617: LD_STRING Solar2
12619: PPUSH
12620: LD_INT 1
12622: PPUSH
12623: CALL_OW 101
12627: GO 12659
// if solar_builded then
12629: LD_EXP 14
12633: IFFALSE 12648
// AddMedal ( Solar2 , - 1 ) else
12635: LD_STRING Solar2
12637: PPUSH
12638: LD_INT 1
12640: NEG
12641: PPUSH
12642: CALL_OW 101
12646: GO 12659
// AddMedal ( Solar2 , - 2 ) ;
12648: LD_STRING Solar2
12650: PPUSH
12651: LD_INT 2
12653: NEG
12654: PPUSH
12655: CALL_OW 101
// if lose_counter = 0 then
12659: LD_EXP 34
12663: PUSH
12664: LD_INT 0
12666: EQUAL
12667: IFFALSE 12681
// AddMedal ( No , 1 ) else
12669: LD_STRING No
12671: PPUSH
12672: LD_INT 1
12674: PPUSH
12675: CALL_OW 101
12679: GO 12725
// if lose_counter > 0 and lose_counter < 4 then
12681: LD_EXP 34
12685: PUSH
12686: LD_INT 0
12688: GREATER
12689: PUSH
12690: LD_EXP 34
12694: PUSH
12695: LD_INT 4
12697: LESS
12698: AND
12699: IFFALSE 12714
// AddMedal ( No , - 1 ) else
12701: LD_STRING No
12703: PPUSH
12704: LD_INT 1
12706: NEG
12707: PPUSH
12708: CALL_OW 101
12712: GO 12725
// AddMedal ( UpTo4 , - 1 ) ;
12714: LD_STRING UpTo4
12716: PPUSH
12717: LD_INT 1
12719: NEG
12720: PPUSH
12721: CALL_OW 101
// GiveMedals ( MAIN ) ;
12725: LD_STRING MAIN
12727: PPUSH
12728: CALL_OW 102
// if Difficulty = 3 and m1 and m2 and m3 then
12732: LD_OWVAR 67
12736: PUSH
12737: LD_INT 3
12739: EQUAL
12740: PUSH
12741: LD_VAR 0 3
12745: AND
12746: PUSH
12747: LD_VAR 0 4
12751: AND
12752: PUSH
12753: LD_VAR 0 5
12757: AND
12758: IFFALSE 12770
// SetAchievementEX ( ACH_AMER , 3 ) ;
12760: LD_STRING ACH_AMER
12762: PPUSH
12763: LD_INT 3
12765: PPUSH
12766: CALL_OW 564
// if IsDead ( Pokryshkin ) then
12770: LD_EXP 52
12774: PPUSH
12775: CALL_OW 301
12779: IFFALSE 12835
// begin stop_talking := true ;
12781: LD_ADDR_OWVAR 56
12785: PUSH
12786: LD_INT 1
12788: ST_TO_ADDR
// for i in save_group ^ save_others do
12789: LD_ADDR_VAR 0 2
12793: PUSH
12794: LD_EXP 23
12798: PUSH
12799: LD_EXP 22
12803: ADD
12804: PUSH
12805: FOR_IN
12806: IFFALSE 12825
// AddExperience ( i , skill_combat , 1500 ) ;
12808: LD_VAR 0 2
12812: PPUSH
12813: LD_INT 1
12815: PPUSH
12816: LD_INT 1500
12818: PPUSH
12819: CALL_OW 492
12823: GO 12805
12825: POP
12826: POP
// stop_talking := false ;
12827: LD_ADDR_OWVAR 56
12831: PUSH
12832: LD_INT 0
12834: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12835: LD_EXP 23
12839: PUSH
12840: LD_EXP 22
12844: ADD
12845: PPUSH
12846: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12850: LD_EXP 37
12854: PPUSH
12855: LD_EXP 2
12859: PUSH
12860: LD_STRING JMM
12862: STR
12863: PPUSH
12864: CALL_OW 38
// if Bobby in save_group then
12868: LD_EXP 38
12872: PUSH
12873: LD_EXP 23
12877: IN
12878: IFFALSE 12898
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12880: LD_EXP 38
12884: PPUSH
12885: LD_EXP 2
12889: PUSH
12890: LD_STRING Bobby
12892: STR
12893: PPUSH
12894: CALL_OW 38
// if Cyrus in save_group then
12898: LD_EXP 39
12902: PUSH
12903: LD_EXP 23
12907: IN
12908: IFFALSE 12928
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12910: LD_EXP 39
12914: PPUSH
12915: LD_EXP 2
12919: PUSH
12920: LD_STRING Cyrus
12922: STR
12923: PPUSH
12924: CALL_OW 38
// if Lisa in save_group then
12928: LD_EXP 40
12932: PUSH
12933: LD_EXP 23
12937: IN
12938: IFFALSE 12958
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12940: LD_EXP 40
12944: PPUSH
12945: LD_EXP 2
12949: PUSH
12950: LD_STRING Lisa
12952: STR
12953: PPUSH
12954: CALL_OW 38
// if Frank in save_group then
12958: LD_EXP 51
12962: PUSH
12963: LD_EXP 23
12967: IN
12968: IFFALSE 12988
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12970: LD_EXP 51
12974: PPUSH
12975: LD_EXP 2
12979: PUSH
12980: LD_STRING Frank
12982: STR
12983: PPUSH
12984: CALL_OW 38
// if Khatam in save_group then
12988: LD_EXP 41
12992: PUSH
12993: LD_EXP 23
12997: IN
12998: IFFALSE 13018
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
13000: LD_EXP 41
13004: PPUSH
13005: LD_EXP 2
13009: PUSH
13010: LD_STRING Khatam
13012: STR
13013: PPUSH
13014: CALL_OW 38
// if save_others then
13018: LD_EXP 22
13022: IFFALSE 13036
// SaveCharacters ( save_others , 03_others ) ;
13024: LD_EXP 22
13028: PPUSH
13029: LD_STRING 03_others
13031: PPUSH
13032: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
13036: LD_EXP 45
13040: PUSH
13041: LD_EXP 45
13045: PPUSH
13046: CALL_OW 302
13050: AND
13051: PUSH
13052: LD_EXP 27
13056: AND
13057: IFFALSE 13069
// begin ResetFog ;
13059: CALL_OW 335
// DisplayEndingScene ;
13063: CALL 13091 0 0
// end else
13067: GO 13082
// DeleteCharacters ( mission_prefix & Cornel ) ;
13069: LD_EXP 2
13073: PUSH
13074: LD_STRING Cornel
13076: STR
13077: PPUSH
13078: CALL_OW 40
// YouWin ;
13082: CALL_OW 103
// end ;
13086: LD_VAR 0 1
13090: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
13091: LD_INT 0
13093: PPUSH
13094: PPUSH
13095: PPUSH
13096: PPUSH
13097: PPUSH
13098: PPUSH
// InGameOn ;
13099: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13103: LD_INT 208
13105: PPUSH
13106: LD_INT 62
13108: PPUSH
13109: LD_INT 1
13111: PPUSH
13112: LD_INT 10
13114: NEG
13115: PPUSH
13116: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
13120: LD_INT 208
13122: PPUSH
13123: LD_INT 62
13125: PPUSH
13126: LD_INT 1
13128: PPUSH
13129: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
13133: LD_ADDR_VAR 0 3
13137: PUSH
13138: LD_INT 22
13140: PUSH
13141: LD_INT 3
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: LD_INT 2
13150: PUSH
13151: LD_INT 21
13153: PUSH
13154: LD_INT 2
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 21
13163: PUSH
13164: LD_INT 1
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: LIST
13175: PUSH
13176: EMPTY
13177: LIST
13178: LIST
13179: PPUSH
13180: CALL_OW 69
13184: ST_TO_ADDR
// if filter then
13185: LD_VAR 0 3
13189: IFFALSE 13217
// for i in filter do
13191: LD_ADDR_VAR 0 2
13195: PUSH
13196: LD_VAR 0 3
13200: PUSH
13201: FOR_IN
13202: IFFALSE 13215
// RemoveUnit ( i ) ;
13204: LD_VAR 0 2
13208: PPUSH
13209: CALL_OW 64
13213: GO 13201
13215: POP
13216: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
13217: LD_ADDR_VAR 0 3
13221: PUSH
13222: LD_INT 22
13224: PUSH
13225: LD_INT 4
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 21
13234: PUSH
13235: LD_INT 1
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PPUSH
13246: CALL_OW 69
13250: ST_TO_ADDR
// if filter then
13251: LD_VAR 0 3
13255: IFFALSE 13286
// for i in filter do
13257: LD_ADDR_VAR 0 2
13261: PUSH
13262: LD_VAR 0 3
13266: PUSH
13267: FOR_IN
13268: IFFALSE 13284
// SetLives ( i , 0 ) ;
13270: LD_VAR 0 2
13274: PPUSH
13275: LD_INT 0
13277: PPUSH
13278: CALL_OW 234
13282: GO 13267
13284: POP
13285: POP
// uc_side := 4 ;
13286: LD_ADDR_OWVAR 20
13290: PUSH
13291: LD_INT 4
13293: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
13294: LD_ADDR_VAR 0 4
13298: PUSH
13299: LD_STRING Cornell
13301: PPUSH
13302: LD_INT 0
13304: PPUSH
13305: CALL 489 0 2
13309: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
13310: LD_VAR 0 4
13314: PPUSH
13315: LD_INT 208
13317: PPUSH
13318: LD_INT 62
13320: PPUSH
13321: LD_INT 0
13323: PPUSH
13324: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
13328: LD_VAR 0 4
13332: PPUSH
13333: LD_INT 100
13335: PPUSH
13336: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
13340: LD_INT 3
13342: PPUSH
13343: LD_VAR 0 4
13347: PPUSH
13348: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
13352: LD_INT 4
13354: PPUSH
13355: LD_INT 3
13357: PPUSH
13358: LD_INT 1
13360: PPUSH
13361: LD_INT 1
13363: PPUSH
13364: CALL_OW 80
// uc_side := 3 ;
13368: LD_ADDR_OWVAR 20
13372: PUSH
13373: LD_INT 3
13375: ST_TO_ADDR
// uc_nation := 3 ;
13376: LD_ADDR_OWVAR 21
13380: PUSH
13381: LD_INT 3
13383: ST_TO_ADDR
// InitHc ;
13384: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
13388: LD_ADDR_VAR 0 5
13392: PUSH
13393: LD_STRING Mikhail
13395: PPUSH
13396: LD_INT 0
13398: PPUSH
13399: CALL 489 0 2
13403: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
13404: LD_INT 1
13406: PPUSH
13407: LD_INT 1
13409: PPUSH
13410: LD_INT 0
13412: PPUSH
13413: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13417: LD_ADDR_VAR 0 6
13421: PUSH
13422: LD_VAR 0 6
13426: PUSH
13427: CALL_OW 44
13431: ADD
13432: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
13433: LD_ADDR_VAR 0 6
13437: PUSH
13438: LD_VAR 0 6
13442: PUSH
13443: CALL_OW 44
13447: ADD
13448: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
13449: LD_INT 2
13451: PPUSH
13452: LD_INT 4
13454: PPUSH
13455: LD_INT 0
13457: PPUSH
13458: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13462: LD_ADDR_VAR 0 6
13466: PUSH
13467: LD_VAR 0 6
13471: PUSH
13472: CALL_OW 44
13476: ADD
13477: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
13478: LD_VAR 0 5
13482: PPUSH
13483: LD_INT 17
13485: PPUSH
13486: LD_INT 0
13488: PPUSH
13489: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
13493: LD_VAR 0 5
13497: PPUSH
13498: LD_INT 210
13500: PPUSH
13501: LD_INT 63
13503: PPUSH
13504: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
13508: LD_VAR 0 5
13512: PPUSH
13513: LD_INT 208
13515: PPUSH
13516: LD_INT 62
13518: PPUSH
13519: CALL_OW 178
// for i in fake_russians do
13523: LD_ADDR_VAR 0 2
13527: PUSH
13528: LD_VAR 0 6
13532: PUSH
13533: FOR_IN
13534: IFFALSE 13612
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13536: LD_VAR 0 2
13540: PPUSH
13541: LD_INT 17
13543: PPUSH
13544: LD_INT 0
13546: PPUSH
13547: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13551: LD_VAR 0 2
13555: PPUSH
13556: LD_INT 215
13558: PPUSH
13559: LD_INT 67
13561: PPUSH
13562: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13566: LD_VAR 0 2
13570: PPUSH
13571: LD_INT 208
13573: PPUSH
13574: LD_INT 62
13576: PPUSH
13577: CALL_OW 178
// if GetClass ( i ) = 4 then
13581: LD_VAR 0 2
13585: PPUSH
13586: CALL_OW 257
13590: PUSH
13591: LD_INT 4
13593: EQUAL
13594: IFFALSE 13610
// ComHeal ( i , fake_cornel ) ;
13596: LD_VAR 0 2
13600: PPUSH
13601: LD_VAR 0 4
13605: PPUSH
13606: CALL_OW 128
// end ;
13610: GO 13533
13612: POP
13613: POP
// Wait ( 0 0$01 ) ;
13614: LD_INT 35
13616: PPUSH
13617: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13621: LD_INT 208
13623: PPUSH
13624: LD_INT 62
13626: PPUSH
13627: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13631: LD_INT 208
13633: PPUSH
13634: LD_INT 62
13636: PPUSH
13637: LD_INT 1
13639: PPUSH
13640: LD_INT 10
13642: NEG
13643: PPUSH
13644: CALL_OW 330
// Wait ( 0 0$15 ) ;
13648: LD_INT 525
13650: PPUSH
13651: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13655: LD_INT 208
13657: PPUSH
13658: LD_INT 62
13660: PPUSH
13661: LD_INT 1
13663: PPUSH
13664: CALL_OW 331
// ResetFog ;
13668: CALL_OW 335
// InGameOff ;
13672: CALL_OW 9
// end ;
13676: LD_VAR 0 1
13680: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13681: LD_INT 10
13683: PPUSH
13684: LD_INT 22
13686: PUSH
13687: LD_INT 1
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: PPUSH
13694: CALL_OW 70
13698: PUSH
13699: LD_EXP 44
13703: PPUSH
13704: CALL_OW 302
13708: AND
13709: PUSH
13710: LD_INT 22
13712: PUSH
13713: LD_INT 1
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PPUSH
13720: CALL_OW 69
13724: PPUSH
13725: LD_EXP 44
13729: PPUSH
13730: CALL_OW 74
13734: PPUSH
13735: LD_EXP 44
13739: PPUSH
13740: CALL_OW 296
13744: PUSH
13745: LD_INT 30
13747: LESS
13748: OR
13749: IFFALSE 13800
13751: GO 13753
13753: DISABLE
// begin enable ;
13754: ENABLE
// powell_warn := powell_warn + 1 ;
13755: LD_ADDR_EXP 35
13759: PUSH
13760: LD_EXP 35
13764: PUSH
13765: LD_INT 1
13767: PLUS
13768: ST_TO_ADDR
// if powell_warn = 3 then
13769: LD_EXP 35
13773: PUSH
13774: LD_INT 3
13776: EQUAL
13777: IFFALSE 13788
// begin YouLost ( 5 ) ;
13779: LD_STRING 5
13781: PPUSH
13782: CALL_OW 104
// exit ;
13786: GO 13800
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13788: LD_EXP 46
13792: PPUSH
13793: LD_STRING DWarn-Pow-1
13795: PPUSH
13796: CALL_OW 94
// end ; end_of_file
13800: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13801: LD_EXP 8
13805: IFFALSE 15642
13807: GO 13809
13809: DISABLE
13810: LD_INT 0
13812: PPUSH
13813: PPUSH
13814: PPUSH
13815: PPUSH
13816: PPUSH
13817: PPUSH
13818: PPUSH
13819: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13820: LD_EXP 44
13824: PUSH
13825: LD_EXP 45
13829: ADD
13830: PUSH
13831: LD_EXP 6
13835: ADD
13836: PPUSH
13837: LD_INT 250
13839: PPUSH
13840: LD_INT 120
13842: PPUSH
13843: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13847: LD_ADDR_VAR 0 2
13851: PUSH
13852: LD_EXP 6
13856: PPUSH
13857: LD_INT 25
13859: PUSH
13860: LD_INT 2
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PPUSH
13867: CALL_OW 72
13871: PUSH
13872: LD_EXP 45
13876: DIFF
13877: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13878: LD_ADDR_VAR 0 3
13882: PUSH
13883: LD_EXP 6
13887: PPUSH
13888: LD_INT 21
13890: PUSH
13891: LD_INT 1
13893: PUSH
13894: EMPTY
13895: LIST
13896: LIST
13897: PPUSH
13898: CALL_OW 72
13902: PUSH
13903: LD_VAR 0 2
13907: DIFF
13908: ST_TO_ADDR
// if not has_eng then
13909: LD_VAR 0 2
13913: NOT
13914: IFFALSE 13997
// begin uc_side := 4 ;
13916: LD_ADDR_OWVAR 20
13920: PUSH
13921: LD_INT 4
13923: ST_TO_ADDR
// uc_nation := 1 ;
13924: LD_ADDR_OWVAR 21
13928: PUSH
13929: LD_INT 1
13931: ST_TO_ADDR
// bc_type := b_depot ;
13932: LD_ADDR_OWVAR 42
13936: PUSH
13937: LD_INT 0
13939: ST_TO_ADDR
// bc_level := 2 ;
13940: LD_ADDR_OWVAR 43
13944: PUSH
13945: LD_INT 2
13947: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13948: LD_ADDR_VAR 0 4
13952: PUSH
13953: LD_INT 264
13955: PPUSH
13956: LD_INT 120
13958: PPUSH
13959: LD_INT 4
13961: PPUSH
13962: CALL_OW 47
13966: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13967: LD_INT 264
13969: PPUSH
13970: LD_INT 120
13972: PPUSH
13973: LD_INT 4
13975: PPUSH
13976: LD_INT 10
13978: NEG
13979: PPUSH
13980: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13984: LD_INT 264
13986: PPUSH
13987: LD_INT 120
13989: PPUSH
13990: LD_INT 4
13992: PPUSH
13993: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13997: LD_INT 35
13999: PPUSH
14000: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
14004: LD_EXP 44
14008: PPUSH
14009: LD_INT 10
14011: PPUSH
14012: CALL_OW 308
14016: PUSH
14017: LD_EXP 44
14021: PPUSH
14022: CALL_OW 310
14026: PPUSH
14027: LD_INT 10
14029: PPUSH
14030: CALL_OW 308
14034: OR
14035: IFFALSE 13997
// if has_eng and not dep then
14037: LD_VAR 0 2
14041: PUSH
14042: LD_VAR 0 4
14046: NOT
14047: AND
14048: IFFALSE 14198
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
14050: LD_VAR 0 2
14054: PPUSH
14055: LD_INT 0
14057: PPUSH
14058: LD_INT 264
14060: PPUSH
14061: LD_INT 120
14063: PPUSH
14064: LD_INT 4
14066: PPUSH
14067: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
14071: LD_INT 35
14073: PPUSH
14074: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
14078: LD_INT 22
14080: PUSH
14081: LD_INT 4
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: PUSH
14088: LD_INT 30
14090: PUSH
14091: LD_INT 0
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: PUSH
14098: EMPTY
14099: LIST
14100: LIST
14101: PPUSH
14102: CALL_OW 69
14106: IFFALSE 14071
// ComMoveXY ( filter , 264 , 120 ) ;
14108: LD_VAR 0 3
14112: PPUSH
14113: LD_INT 264
14115: PPUSH
14116: LD_INT 120
14118: PPUSH
14119: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
14123: LD_INT 35
14125: PPUSH
14126: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
14130: LD_INT 22
14132: PUSH
14133: LD_INT 4
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: PUSH
14140: LD_INT 30
14142: PUSH
14143: LD_INT 0
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PUSH
14150: LD_INT 3
14152: PUSH
14153: LD_INT 57
14155: PUSH
14156: EMPTY
14157: LIST
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: EMPTY
14164: LIST
14165: LIST
14166: LIST
14167: PPUSH
14168: CALL_OW 69
14172: IFFALSE 14123
// ComMoveXY ( filter , 247 , 113 ) ;
14174: LD_VAR 0 3
14178: PPUSH
14179: LD_INT 247
14181: PPUSH
14182: LD_INT 113
14184: PPUSH
14185: CALL_OW 111
// Wait ( 0 0$2 ) ;
14189: LD_INT 70
14191: PPUSH
14192: CALL_OW 67
// end else
14196: GO 14210
// begin SetSide ( dep , 4 ) ;
14198: LD_VAR 0 4
14202: PPUSH
14203: LD_INT 4
14205: PPUSH
14206: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
14210: LD_ADDR_VAR 0 4
14214: PUSH
14215: LD_INT 22
14217: PUSH
14218: LD_INT 4
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: PUSH
14225: LD_INT 30
14227: PUSH
14228: LD_INT 0
14230: PUSH
14231: EMPTY
14232: LIST
14233: LIST
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 69
14243: PUSH
14244: LD_INT 1
14246: ARRAY
14247: ST_TO_ADDR
// if not has_eng then
14248: LD_VAR 0 2
14252: NOT
14253: IFFALSE 14340
// for i = 1 to 2 do
14255: LD_ADDR_VAR 0 1
14259: PUSH
14260: DOUBLE
14261: LD_INT 1
14263: DEC
14264: ST_TO_ADDR
14265: LD_INT 2
14267: PUSH
14268: FOR_TO
14269: IFFALSE 14338
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
14271: LD_VAR 0 3
14275: PUSH
14276: LD_INT 1
14278: ARRAY
14279: PPUSH
14280: LD_VAR 0 4
14284: PPUSH
14285: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
14289: LD_VAR 0 3
14293: PUSH
14294: LD_INT 1
14296: ARRAY
14297: PPUSH
14298: LD_INT 2
14300: PPUSH
14301: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
14305: LD_VAR 0 3
14309: PUSH
14310: LD_INT 1
14312: ARRAY
14313: PPUSH
14314: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
14318: LD_ADDR_VAR 0 3
14322: PUSH
14323: LD_VAR 0 3
14327: PPUSH
14328: LD_INT 1
14330: PPUSH
14331: CALL_OW 3
14335: ST_TO_ADDR
// end ;
14336: GO 14268
14338: POP
14339: POP
// if IsInUnit ( Cornel ) then
14340: LD_EXP 44
14344: PPUSH
14345: CALL_OW 310
14349: IFFALSE 14427
// begin cargo := IsInUnit ( Cornel ) ;
14351: LD_ADDR_VAR 0 7
14355: PUSH
14356: LD_EXP 44
14360: PPUSH
14361: CALL_OW 310
14365: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
14366: LD_VAR 0 7
14370: PPUSH
14371: LD_INT 1
14373: PPUSH
14374: CALL_OW 289
14378: IFFALSE 14389
// ComUnload ( cargo ) ;
14380: LD_VAR 0 7
14384: PPUSH
14385: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
14389: LD_EXP 44
14393: PPUSH
14394: LD_INT 235
14396: PPUSH
14397: LD_INT 122
14399: PPUSH
14400: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
14404: LD_EXP 44
14408: PPUSH
14409: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
14413: LD_EXP 44
14417: PPUSH
14418: LD_VAR 0 4
14422: PPUSH
14423: CALL_OW 180
// end ; if Bierezov then
14427: LD_EXP 45
14431: IFFALSE 14479
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
14433: LD_EXP 45
14437: PPUSH
14438: LD_INT 260
14440: PPUSH
14441: LD_INT 120
14443: PPUSH
14444: CALL_OW 111
// if dep then
14448: LD_VAR 0 4
14452: IFFALSE 14470
// AddComEnterUnit ( Bierezov , dep ) else
14454: LD_EXP 45
14458: PPUSH
14459: LD_VAR 0 4
14463: PPUSH
14464: CALL_OW 180
14468: GO 14479
// AddComHold ( Bierezov ) ;
14470: LD_EXP 45
14474: PPUSH
14475: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
14479: LD_INT 525
14481: PPUSH
14482: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
14486: LD_ADDR_VAR 0 2
14490: PUSH
14491: LD_INT 22
14493: PUSH
14494: LD_INT 4
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: PUSH
14501: LD_INT 25
14503: PUSH
14504: LD_INT 2
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: EMPTY
14512: LIST
14513: LIST
14514: PPUSH
14515: CALL_OW 69
14519: PUSH
14520: LD_EXP 45
14524: DIFF
14525: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14526: LD_INT 35
14528: PPUSH
14529: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14533: LD_ADDR_VAR 0 6
14537: PUSH
14538: LD_INT 10
14540: PPUSH
14541: CALL_OW 435
14545: ST_TO_ADDR
// if crates then
14546: LD_VAR 0 6
14550: IFFALSE 14579
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14552: LD_VAR 0 2
14556: PPUSH
14557: LD_VAR 0 6
14561: PUSH
14562: LD_INT 1
14564: ARRAY
14565: PPUSH
14566: LD_VAR 0 6
14570: PUSH
14571: LD_INT 2
14573: ARRAY
14574: PPUSH
14575: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14579: LD_VAR 0 4
14583: PPUSH
14584: CALL_OW 274
14588: PPUSH
14589: LD_INT 1
14591: PPUSH
14592: CALL_OW 275
14596: PUSH
14597: LD_INT 40
14599: GREATEREQUAL
14600: IFFALSE 14526
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14602: LD_ADDR_VAR 0 5
14606: PUSH
14607: LD_INT 4
14609: PUSH
14610: LD_INT 256
14612: PUSH
14613: LD_INT 111
14615: PUSH
14616: LD_INT 2
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: PUSH
14625: LD_INT 31
14627: PUSH
14628: LD_INT 243
14630: PUSH
14631: LD_INT 112
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: PUSH
14643: LD_INT 31
14645: PUSH
14646: LD_INT 254
14648: PUSH
14649: LD_INT 114
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: LIST
14665: ST_TO_ADDR
// for i in blist do
14666: LD_ADDR_VAR 0 1
14670: PUSH
14671: LD_VAR 0 5
14675: PUSH
14676: FOR_IN
14677: IFFALSE 14726
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14679: LD_VAR 0 2
14683: PPUSH
14684: LD_VAR 0 1
14688: PUSH
14689: LD_INT 1
14691: ARRAY
14692: PPUSH
14693: LD_VAR 0 1
14697: PUSH
14698: LD_INT 2
14700: ARRAY
14701: PPUSH
14702: LD_VAR 0 1
14706: PUSH
14707: LD_INT 3
14709: ARRAY
14710: PPUSH
14711: LD_VAR 0 1
14715: PUSH
14716: LD_INT 4
14718: ARRAY
14719: PPUSH
14720: CALL_OW 205
14724: GO 14676
14726: POP
14727: POP
// repeat wait ( 0 0$01 ) ;
14728: LD_INT 35
14730: PPUSH
14731: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14735: LD_INT 22
14737: PUSH
14738: LD_INT 4
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: PUSH
14745: LD_INT 30
14747: PUSH
14748: LD_INT 4
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: LD_INT 57
14760: PUSH
14761: EMPTY
14762: LIST
14763: PUSH
14764: EMPTY
14765: LIST
14766: LIST
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: LIST
14772: PPUSH
14773: CALL_OW 69
14777: IFFALSE 14728
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14779: LD_VAR 0 3
14783: PPUSH
14784: LD_INT 22
14786: PUSH
14787: LD_INT 4
14789: PUSH
14790: EMPTY
14791: LIST
14792: LIST
14793: PUSH
14794: LD_INT 30
14796: PUSH
14797: LD_INT 4
14799: PUSH
14800: EMPTY
14801: LIST
14802: LIST
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: PPUSH
14808: CALL_OW 69
14812: PUSH
14813: LD_INT 1
14815: ARRAY
14816: PPUSH
14817: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14821: LD_VAR 0 3
14825: PPUSH
14826: LD_INT 1
14828: PPUSH
14829: CALL_OW 183
// if has_eng > 1 then
14833: LD_VAR 0 2
14837: PUSH
14838: LD_INT 1
14840: GREATER
14841: IFFALSE 14983
// for i = has_eng downto 2 do
14843: LD_ADDR_VAR 0 1
14847: PUSH
14848: DOUBLE
14849: LD_VAR 0 2
14853: INC
14854: ST_TO_ADDR
14855: LD_INT 2
14857: PUSH
14858: FOR_DOWNTO
14859: IFFALSE 14981
// begin if IsInUnit ( has_eng [ i ] ) then
14861: LD_VAR 0 2
14865: PUSH
14866: LD_VAR 0 1
14870: ARRAY
14871: PPUSH
14872: CALL_OW 310
14876: IFFALSE 14893
// ComExitBuilding ( has_eng [ i ] ) ;
14878: LD_VAR 0 2
14882: PUSH
14883: LD_VAR 0 1
14887: ARRAY
14888: PPUSH
14889: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14893: LD_VAR 0 2
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PPUSH
14904: LD_INT 22
14906: PUSH
14907: LD_INT 4
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: PUSH
14914: LD_INT 30
14916: PUSH
14917: LD_INT 4
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PPUSH
14928: CALL_OW 69
14932: PUSH
14933: LD_INT 1
14935: ARRAY
14936: PPUSH
14937: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14941: LD_VAR 0 2
14945: PUSH
14946: LD_VAR 0 1
14950: ARRAY
14951: PPUSH
14952: LD_INT 1
14954: PPUSH
14955: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14959: LD_ADDR_VAR 0 2
14963: PUSH
14964: LD_VAR 0 2
14968: PPUSH
14969: LD_VAR 0 1
14973: PPUSH
14974: CALL_OW 3
14978: ST_TO_ADDR
// end ;
14979: GO 14858
14981: POP
14982: POP
// repeat wait ( 0 0$01 ) ;
14983: LD_INT 35
14985: PPUSH
14986: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14990: LD_INT 22
14992: PUSH
14993: LD_INT 4
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: PUSH
15000: LD_INT 30
15002: PUSH
15003: LD_INT 31
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PUSH
15010: LD_INT 3
15012: PUSH
15013: LD_INT 57
15015: PUSH
15016: EMPTY
15017: LIST
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: PUSH
15033: LD_INT 1
15035: GREATER
15036: IFFALSE 14983
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
15038: LD_ADDR_VAR 0 8
15042: PUSH
15043: LD_EXP 6
15047: PPUSH
15048: LD_INT 25
15050: PUSH
15051: LD_INT 1
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PPUSH
15058: CALL_OW 72
15062: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
15063: LD_ADDR_VAR 0 1
15067: PUSH
15068: DOUBLE
15069: LD_INT 1
15071: DEC
15072: ST_TO_ADDR
15073: LD_INT 22
15075: PUSH
15076: LD_INT 4
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 30
15085: PUSH
15086: LD_INT 31
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 3
15095: PUSH
15096: LD_INT 57
15098: PUSH
15099: EMPTY
15100: LIST
15101: PUSH
15102: EMPTY
15103: LIST
15104: LIST
15105: PUSH
15106: EMPTY
15107: LIST
15108: LIST
15109: LIST
15110: PPUSH
15111: CALL_OW 69
15115: PUSH
15116: FOR_TO
15117: IFFALSE 15201
// begin if not sol [ i ] then
15119: LD_VAR 0 8
15123: PUSH
15124: LD_VAR 0 1
15128: ARRAY
15129: NOT
15130: IFFALSE 15134
// break ;
15132: GO 15201
// ComExitBuilding ( sol [ i ] ) ;
15134: LD_VAR 0 8
15138: PUSH
15139: LD_VAR 0 1
15143: ARRAY
15144: PPUSH
15145: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
15149: LD_VAR 0 8
15153: PUSH
15154: LD_VAR 0 1
15158: ARRAY
15159: PPUSH
15160: LD_INT 22
15162: PUSH
15163: LD_INT 4
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: LD_INT 30
15172: PUSH
15173: LD_INT 31
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: PPUSH
15184: CALL_OW 69
15188: PUSH
15189: LD_VAR 0 1
15193: ARRAY
15194: PPUSH
15195: CALL_OW 180
// end ;
15199: GO 15116
15201: POP
15202: POP
// if sol > 3 then
15203: LD_VAR 0 8
15207: PUSH
15208: LD_INT 3
15210: GREATER
15211: IFFALSE 15328
// begin ComExitBuilding ( sol [ 3 ] ) ;
15213: LD_VAR 0 8
15217: PUSH
15218: LD_INT 3
15220: ARRAY
15221: PPUSH
15222: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
15226: LD_VAR 0 8
15230: PUSH
15231: LD_INT 3
15233: ARRAY
15234: PPUSH
15235: LD_INT 246
15237: PPUSH
15238: LD_INT 94
15240: PPUSH
15241: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
15245: LD_VAR 0 8
15249: PUSH
15250: LD_INT 3
15252: ARRAY
15253: PPUSH
15254: LD_INT 175
15256: PPUSH
15257: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
15261: LD_VAR 0 8
15265: PUSH
15266: LD_INT 3
15268: ARRAY
15269: PPUSH
15270: LD_INT 224
15272: PPUSH
15273: LD_INT 90
15275: PPUSH
15276: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
15280: LD_VAR 0 8
15284: PUSH
15285: LD_INT 3
15287: ARRAY
15288: PPUSH
15289: LD_INT 245
15291: PPUSH
15292: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
15296: LD_VAR 0 8
15300: PUSH
15301: LD_INT 3
15303: ARRAY
15304: PPUSH
15305: LD_INT 223
15307: PPUSH
15308: LD_INT 110
15310: PPUSH
15311: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
15315: LD_VAR 0 8
15319: PUSH
15320: LD_INT 3
15322: ARRAY
15323: PPUSH
15324: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
15328: LD_VAR 0 2
15332: PPUSH
15333: LD_VAR 0 4
15337: PPUSH
15338: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
15342: LD_INT 22
15344: PUSH
15345: LD_INT 4
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PUSH
15352: LD_INT 30
15354: PUSH
15355: LD_INT 4
15357: PUSH
15358: EMPTY
15359: LIST
15360: LIST
15361: PUSH
15362: EMPTY
15363: LIST
15364: LIST
15365: PPUSH
15366: CALL_OW 69
15370: PUSH
15371: LD_INT 1
15373: ARRAY
15374: PPUSH
15375: CALL_OW 313
15379: PUSH
15380: LD_INT 6
15382: LESS
15383: IFFALSE 15447
// begin if IsInUnit ( Cornel ) then
15385: LD_EXP 44
15389: PPUSH
15390: CALL_OW 310
15394: IFFALSE 15405
// ComExitBuilding ( Cornel ) ;
15396: LD_EXP 44
15400: PPUSH
15401: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
15405: LD_EXP 44
15409: PPUSH
15410: LD_INT 22
15412: PUSH
15413: LD_INT 4
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PUSH
15420: LD_INT 30
15422: PUSH
15423: LD_INT 4
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: PPUSH
15434: CALL_OW 69
15438: PUSH
15439: LD_INT 1
15441: ARRAY
15442: PPUSH
15443: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
15447: LD_INT 35
15449: PPUSH
15450: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
15454: LD_ADDR_VAR 0 3
15458: PUSH
15459: LD_INT 22
15461: PUSH
15462: LD_INT 4
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: PUSH
15469: LD_INT 21
15471: PUSH
15472: LD_INT 3
15474: PUSH
15475: EMPTY
15476: LIST
15477: LIST
15478: PUSH
15479: LD_INT 3
15481: PUSH
15482: LD_INT 24
15484: PUSH
15485: LD_INT 1000
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: LIST
15500: PPUSH
15501: CALL_OW 69
15505: ST_TO_ADDR
// if filter and has_eng then
15506: LD_VAR 0 3
15510: PUSH
15511: LD_VAR 0 2
15515: AND
15516: IFFALSE 15582
// begin for i in has_eng do
15518: LD_ADDR_VAR 0 1
15522: PUSH
15523: LD_VAR 0 2
15527: PUSH
15528: FOR_IN
15529: IFFALSE 15578
// begin if IsInUnit ( i ) then
15531: LD_VAR 0 1
15535: PPUSH
15536: CALL_OW 310
15540: IFFALSE 15551
// ComExitBuilding ( i ) ;
15542: LD_VAR 0 1
15546: PPUSH
15547: CALL_OW 122
// Wait ( 3 ) ;
15551: LD_INT 3
15553: PPUSH
15554: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15558: LD_VAR 0 1
15562: PPUSH
15563: LD_VAR 0 3
15567: PUSH
15568: LD_INT 1
15570: ARRAY
15571: PPUSH
15572: CALL_OW 130
// end ;
15576: GO 15528
15578: POP
15579: POP
// end else
15580: GO 15636
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15582: LD_VAR 0 2
15586: PUSH
15587: LD_VAR 0 2
15591: PPUSH
15592: LD_INT 56
15594: PUSH
15595: EMPTY
15596: LIST
15597: PPUSH
15598: CALL_OW 72
15602: AND
15603: IFFALSE 15636
// for i in has_eng do
15605: LD_ADDR_VAR 0 1
15609: PUSH
15610: LD_VAR 0 2
15614: PUSH
15615: FOR_IN
15616: IFFALSE 15634
// ComEnterUnit ( i , dep ) ;
15618: LD_VAR 0 1
15622: PPUSH
15623: LD_VAR 0 4
15627: PPUSH
15628: CALL_OW 120
15632: GO 15615
15634: POP
15635: POP
// until cornel_prepared ;
15636: LD_EXP 11
15640: IFFALSE 15447
// end ;
15642: PPOPN 8
15644: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15645: LD_EXP 11
15649: IFFALSE 16048
15651: GO 15653
15653: DISABLE
15654: LD_INT 0
15656: PPUSH
15657: PPUSH
15658: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15659: LD_ADDR_VAR 0 2
15663: PUSH
15664: LD_INT 22
15666: PUSH
15667: LD_INT 4
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PUSH
15674: LD_INT 30
15676: PUSH
15677: LD_INT 4
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PPUSH
15688: CALL_OW 69
15692: PUSH
15693: LD_INT 1
15695: ARRAY
15696: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15697: LD_EXP 6
15701: PPUSH
15702: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15706: LD_EXP 45
15710: PUSH
15711: LD_EXP 45
15715: PPUSH
15716: CALL_OW 310
15720: AND
15721: IFFALSE 15732
// ComExitBuilding ( Bierezov ) ;
15723: LD_EXP 45
15727: PPUSH
15728: CALL_OW 122
// Wait ( 0 0$03 ) ;
15732: LD_INT 105
15734: PPUSH
15735: CALL_OW 67
// for i in cornel_units do
15739: LD_ADDR_VAR 0 1
15743: PUSH
15744: LD_EXP 6
15748: PUSH
15749: FOR_IN
15750: IFFALSE 15826
// begin if GetClass ( i ) in [ 2 , 3 ] then
15752: LD_VAR 0 1
15756: PPUSH
15757: CALL_OW 257
15761: PUSH
15762: LD_INT 2
15764: PUSH
15765: LD_INT 3
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: IN
15772: IFFALSE 15809
// begin ComEnterUnit ( i , arm ) ;
15774: LD_VAR 0 1
15778: PPUSH
15779: LD_VAR 0 2
15783: PPUSH
15784: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 1
15795: PPUSH
15796: CALL_OW 183
// AddComExitBuilding ( i ) ;
15800: LD_VAR 0 1
15804: PPUSH
15805: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15809: LD_VAR 0 1
15813: PPUSH
15814: LD_INT 257
15816: PPUSH
15817: LD_INT 121
15819: PPUSH
15820: CALL_OW 171
// end ;
15824: GO 15749
15826: POP
15827: POP
// Wait ( 1 1$00 ) ;
15828: LD_INT 2100
15830: PPUSH
15831: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15835: LD_ADDR_VAR 0 3
15839: PUSH
15840: LD_EXP 44
15844: PUSH
15845: LD_EXP 45
15849: ADD
15850: PUSH
15851: LD_EXP 6
15855: ADD
15856: PUSH
15857: LD_EXP 6
15861: PPUSH
15862: LD_INT 21
15864: PUSH
15865: LD_INT 2
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PPUSH
15872: CALL_OW 72
15876: DIFF
15877: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15878: LD_VAR 0 3
15882: PPUSH
15883: LD_INT 248
15885: PPUSH
15886: LD_INT 85
15888: PPUSH
15889: CALL_OW 111
// AddComHold ( filter ) ;
15893: LD_VAR 0 3
15897: PPUSH
15898: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15902: LD_INT 35
15904: PPUSH
15905: CALL_OW 67
// until cornel_attack ;
15909: LD_EXP 9
15913: IFFALSE 15902
// ComAgressiveMove ( filter , 209 , 63 ) ;
15915: LD_VAR 0 3
15919: PPUSH
15920: LD_INT 209
15922: PPUSH
15923: LD_INT 63
15925: PPUSH
15926: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15930: LD_EXP 44
15934: PPUSH
15935: LD_INT 208
15937: PPUSH
15938: LD_INT 62
15940: PPUSH
15941: CALL_OW 114
// AddComHold ( Cornel ) ;
15945: LD_EXP 44
15949: PPUSH
15950: CALL_OW 200
// if Bierezov then
15954: LD_EXP 45
15958: IFFALSE 16048
// begin filter := filter diff Bierezov ;
15960: LD_ADDR_VAR 0 3
15964: PUSH
15965: LD_VAR 0 3
15969: PUSH
15970: LD_EXP 45
15974: DIFF
15975: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15976: LD_EXP 45
15980: PPUSH
15981: LD_INT 6
15983: PPUSH
15984: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15988: LD_EXP 45
15992: PPUSH
15993: LD_INT 235
15995: PPUSH
15996: LD_INT 60
15998: PPUSH
15999: CALL_OW 111
// AddComHold ( Bierezov ) ;
16003: LD_EXP 45
16007: PPUSH
16008: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
16012: LD_EXP 45
16016: PPUSH
16017: LD_INT 350
16019: PPUSH
16020: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
16024: LD_EXP 45
16028: PPUSH
16029: LD_INT 198
16031: PPUSH
16032: LD_INT 28
16034: PPUSH
16035: CALL_OW 171
// AddComHold ( Bierezov ) ;
16039: LD_EXP 45
16043: PPUSH
16044: CALL_OW 200
// end ; end ; end_of_file
16048: PPOPN 3
16050: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
16051: LD_EXP 53
16055: PUSH
16056: LD_EXP 31
16060: NOT
16061: AND
16062: PUSH
16063: LD_EXP 32
16067: NOT
16068: AND
16069: IFFALSE 16519
16071: GO 16073
16073: DISABLE
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// begin enable ;
16080: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16081: LD_ADDR_VAR 0 4
16085: PUSH
16086: LD_INT 81
16088: PUSH
16089: LD_INT 3
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PPUSH
16096: CALL_OW 69
16100: ST_TO_ADDR
// for i = 1 to ru_patrol do
16101: LD_ADDR_VAR 0 2
16105: PUSH
16106: DOUBLE
16107: LD_INT 1
16109: DEC
16110: ST_TO_ADDR
16111: LD_EXP 53
16115: PUSH
16116: FOR_TO
16117: IFFALSE 16517
// begin un := ru_patrol [ i ] ;
16119: LD_ADDR_VAR 0 1
16123: PUSH
16124: LD_EXP 53
16128: PUSH
16129: LD_VAR 0 2
16133: ARRAY
16134: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16135: LD_VAR 0 1
16139: PPUSH
16140: LD_INT 13
16142: PPUSH
16143: CALL_OW 308
16147: IFFALSE 16252
// begin if not ru_alert then
16149: LD_EXP 60
16153: NOT
16154: IFFALSE 16164
// ru_alert := true ;
16156: LD_ADDR_EXP 60
16160: PUSH
16161: LD_INT 1
16163: ST_TO_ADDR
// if not See ( 1 , un ) then
16164: LD_INT 1
16166: PPUSH
16167: LD_VAR 0 1
16171: PPUSH
16172: CALL_OW 292
16176: NOT
16177: IFFALSE 16191
// SetLives ( un , 1000 ) ;
16179: LD_VAR 0 1
16183: PPUSH
16184: LD_INT 1000
16186: PPUSH
16187: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
16191: LD_ADDR_EXP 53
16195: PUSH
16196: LD_EXP 53
16200: PUSH
16201: LD_VAR 0 1
16205: DIFF
16206: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16207: LD_VAR 0 1
16211: PPUSH
16212: LD_INT 22
16214: PUSH
16215: LD_INT 3
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: PUSH
16222: LD_INT 30
16224: PUSH
16225: LD_INT 4
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: PUSH
16232: EMPTY
16233: LIST
16234: LIST
16235: PPUSH
16236: CALL_OW 69
16240: PPUSH
16241: CALL 1062 0 1
16245: PPUSH
16246: CALL_OW 120
// continue ;
16250: GO 16116
// end ; if IsOk ( un ) and not HasTask ( un ) then
16252: LD_VAR 0 1
16256: PPUSH
16257: CALL_OW 302
16261: PUSH
16262: LD_VAR 0 1
16266: PPUSH
16267: CALL_OW 314
16271: NOT
16272: AND
16273: IFFALSE 16366
// begin for j = 1 to ru_firepoints_south [ i ] do
16275: LD_ADDR_VAR 0 3
16279: PUSH
16280: DOUBLE
16281: LD_INT 1
16283: DEC
16284: ST_TO_ADDR
16285: LD_EXP 59
16289: PUSH
16290: LD_VAR 0 2
16294: ARRAY
16295: PUSH
16296: FOR_TO
16297: IFFALSE 16364
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
16299: LD_VAR 0 1
16303: PPUSH
16304: LD_EXP 59
16308: PUSH
16309: LD_VAR 0 2
16313: ARRAY
16314: PUSH
16315: LD_VAR 0 3
16319: ARRAY
16320: PUSH
16321: LD_INT 1
16323: ARRAY
16324: PPUSH
16325: LD_EXP 59
16329: PUSH
16330: LD_VAR 0 2
16334: ARRAY
16335: PUSH
16336: LD_VAR 0 3
16340: ARRAY
16341: PUSH
16342: LD_INT 2
16344: ARRAY
16345: PPUSH
16346: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
16350: LD_VAR 0 1
16354: PPUSH
16355: LD_INT 70
16357: PPUSH
16358: CALL_OW 202
// end ;
16362: GO 16296
16364: POP
16365: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16366: LD_VAR 0 1
16370: PPUSH
16371: CALL_OW 256
16375: PUSH
16376: LD_INT 700
16378: LESS
16379: PUSH
16380: LD_VAR 0 1
16384: PPUSH
16385: LD_INT 13
16387: PPUSH
16388: CALL_OW 308
16392: NOT
16393: AND
16394: IFFALSE 16446
// begin ComMoveToArea ( un , retreatArea ) ;
16396: LD_VAR 0 1
16400: PPUSH
16401: LD_INT 13
16403: PPUSH
16404: CALL_OW 113
// if not ru_alert_xy then
16408: LD_EXP 61
16412: NOT
16413: IFFALSE 16444
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
16415: LD_ADDR_EXP 61
16419: PUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 250
16429: PUSH
16430: LD_VAR 0 1
16434: PPUSH
16435: CALL_OW 251
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: ST_TO_ADDR
// end else
16444: GO 16515
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16446: LD_VAR 0 1
16450: PPUSH
16451: LD_VAR 0 4
16455: PPUSH
16456: LD_VAR 0 1
16460: PPUSH
16461: CALL_OW 74
16465: PPUSH
16466: CALL_OW 296
16470: PUSH
16471: LD_INT 9
16473: LESS
16474: PUSH
16475: LD_VAR 0 1
16479: PPUSH
16480: CALL_OW 256
16484: PUSH
16485: LD_INT 500
16487: GREATER
16488: AND
16489: IFFALSE 16515
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16491: LD_VAR 0 1
16495: PPUSH
16496: LD_VAR 0 4
16500: PPUSH
16501: LD_VAR 0 1
16505: PPUSH
16506: CALL_OW 74
16510: PPUSH
16511: CALL_OW 115
// end ;
16515: GO 16116
16517: POP
16518: POP
// end ;
16519: PPOPN 4
16521: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16522: LD_EXP 60
16526: PUSH
16527: LD_EXP 61
16531: AND
16532: PUSH
16533: LD_EXP 31
16537: NOT
16538: AND
16539: PUSH
16540: LD_EXP 32
16544: NOT
16545: AND
16546: IFFALSE 16756
16548: GO 16550
16550: DISABLE
16551: LD_INT 0
16553: PPUSH
16554: PPUSH
// begin enable ;
16555: ENABLE
// if not ru_vehicles then
16556: LD_EXP 56
16560: NOT
16561: IFFALSE 16565
// exit ;
16563: GO 16756
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16565: LD_ADDR_VAR 0 2
16569: PUSH
16570: LD_INT 81
16572: PUSH
16573: LD_INT 3
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PPUSH
16580: CALL_OW 69
16584: ST_TO_ADDR
// if ru_vehicles then
16585: LD_EXP 56
16589: IFFALSE 16756
// begin for i in ru_vehicles do
16591: LD_ADDR_VAR 0 1
16595: PUSH
16596: LD_EXP 56
16600: PUSH
16601: FOR_IN
16602: IFFALSE 16754
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16604: LD_VAR 0 1
16608: PPUSH
16609: CALL_OW 302
16613: PUSH
16614: LD_VAR 0 1
16618: PPUSH
16619: LD_VAR 0 2
16623: PPUSH
16624: LD_VAR 0 1
16628: PPUSH
16629: CALL_OW 74
16633: PPUSH
16634: CALL_OW 296
16638: PUSH
16639: LD_INT 9
16641: LESS
16642: AND
16643: IFFALSE 16669
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16645: LD_VAR 0 1
16649: PPUSH
16650: LD_VAR 0 2
16654: PPUSH
16655: LD_VAR 0 1
16659: PPUSH
16660: CALL_OW 74
16664: PPUSH
16665: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16669: LD_VAR 0 1
16673: PPUSH
16674: CALL_OW 314
16678: NOT
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 302
16689: AND
16690: PUSH
16691: LD_VAR 0 1
16695: PPUSH
16696: LD_EXP 61
16700: PUSH
16701: LD_INT 1
16703: ARRAY
16704: PPUSH
16705: LD_EXP 61
16709: PUSH
16710: LD_INT 2
16712: ARRAY
16713: PPUSH
16714: CALL_OW 297
16718: PUSH
16719: LD_INT 10
16721: GREATER
16722: AND
16723: IFFALSE 16752
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16725: LD_VAR 0 1
16729: PPUSH
16730: LD_EXP 61
16734: PUSH
16735: LD_INT 1
16737: ARRAY
16738: PPUSH
16739: LD_EXP 61
16743: PUSH
16744: LD_INT 2
16746: ARRAY
16747: PPUSH
16748: CALL_OW 114
// end ;
16752: GO 16601
16754: POP
16755: POP
// end ; end ;
16756: PPOPN 2
16758: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16759: LD_EXP 61
16763: PUSH
16764: LD_EXP 60
16768: AND
16769: PUSH
16770: LD_INT 3
16772: PPUSH
16773: CALL_OW 463
16777: NOT
16778: AND
16779: PUSH
16780: LD_EXP 31
16784: NOT
16785: AND
16786: PUSH
16787: LD_EXP 32
16791: NOT
16792: AND
16793: IFFALSE 16888
16795: GO 16797
16797: DISABLE
16798: LD_INT 0
16800: PPUSH
// begin enable ;
16801: ENABLE
// ru_alert_xy := false ;
16802: LD_ADDR_EXP 61
16806: PUSH
16807: LD_INT 0
16809: ST_TO_ADDR
// ru_alert := false ;
16810: LD_ADDR_EXP 60
16814: PUSH
16815: LD_INT 0
16817: ST_TO_ADDR
// if ru_vehicles then
16818: LD_EXP 56
16822: IFFALSE 16888
// for i in ru_vehicles do
16824: LD_ADDR_VAR 0 1
16828: PUSH
16829: LD_EXP 56
16833: PUSH
16834: FOR_IN
16835: IFFALSE 16886
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16837: LD_VAR 0 1
16841: PPUSH
16842: CALL_OW 302
16846: PUSH
16847: LD_VAR 0 1
16851: PPUSH
16852: LD_INT 89
16854: PPUSH
16855: LD_INT 36
16857: PPUSH
16858: CALL_OW 297
16862: PUSH
16863: LD_INT 10
16865: GREATER
16866: AND
16867: IFFALSE 16884
// ComMoveXY ( i , 89 , 36 ) ;
16869: LD_VAR 0 1
16873: PPUSH
16874: LD_INT 89
16876: PPUSH
16877: LD_INT 36
16879: PPUSH
16880: CALL_OW 111
16884: GO 16834
16886: POP
16887: POP
// end ;
16888: PPOPN 1
16890: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16891: LD_EXP 55
16895: PUSH
16896: LD_EXP 31
16900: NOT
16901: AND
16902: PUSH
16903: LD_EXP 32
16907: NOT
16908: AND
16909: IFFALSE 17193
16911: GO 16913
16913: DISABLE
16914: LD_INT 0
16916: PPUSH
16917: PPUSH
16918: PPUSH
// begin enable ;
16919: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16920: LD_ADDR_VAR 0 3
16924: PUSH
16925: LD_INT 81
16927: PUSH
16928: LD_INT 3
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PPUSH
16935: CALL_OW 69
16939: ST_TO_ADDR
// for i = 1 to ru_forest do
16940: LD_ADDR_VAR 0 1
16944: PUSH
16945: DOUBLE
16946: LD_INT 1
16948: DEC
16949: ST_TO_ADDR
16950: LD_EXP 55
16954: PUSH
16955: FOR_TO
16956: IFFALSE 17191
// begin un := ru_forest [ i ] ;
16958: LD_ADDR_VAR 0 2
16962: PUSH
16963: LD_EXP 55
16967: PUSH
16968: LD_VAR 0 1
16972: ARRAY
16973: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16974: LD_VAR 0 2
16978: PPUSH
16979: LD_INT 13
16981: PPUSH
16982: CALL_OW 308
16986: IFFALSE 17076
// begin if not See ( 1 , un ) then
16988: LD_INT 1
16990: PPUSH
16991: LD_VAR 0 2
16995: PPUSH
16996: CALL_OW 292
17000: NOT
17001: IFFALSE 17015
// SetLives ( un , 1000 ) ;
17003: LD_VAR 0 2
17007: PPUSH
17008: LD_INT 1000
17010: PPUSH
17011: CALL_OW 234
// ru_forest := ru_forest diff un ;
17015: LD_ADDR_EXP 55
17019: PUSH
17020: LD_EXP 55
17024: PUSH
17025: LD_VAR 0 2
17029: DIFF
17030: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
17031: LD_VAR 0 2
17035: PPUSH
17036: LD_INT 22
17038: PUSH
17039: LD_INT 3
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: PUSH
17046: LD_INT 30
17048: PUSH
17049: LD_INT 4
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PPUSH
17060: CALL_OW 69
17064: PPUSH
17065: CALL 1062 0 1
17069: PPUSH
17070: CALL_OW 120
// continue ;
17074: GO 16955
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
17076: LD_VAR 0 2
17080: PPUSH
17081: CALL_OW 256
17085: PUSH
17086: LD_INT 700
17088: LESS
17089: PUSH
17090: LD_VAR 0 2
17094: PPUSH
17095: LD_INT 13
17097: PPUSH
17098: CALL_OW 308
17102: NOT
17103: AND
17104: IFFALSE 17120
// ComMoveToArea ( un , retreatArea ) else
17106: LD_VAR 0 2
17110: PPUSH
17111: LD_INT 13
17113: PPUSH
17114: CALL_OW 113
17118: GO 17189
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
17120: LD_VAR 0 2
17124: PPUSH
17125: LD_VAR 0 3
17129: PPUSH
17130: LD_VAR 0 2
17134: PPUSH
17135: CALL_OW 74
17139: PPUSH
17140: CALL_OW 296
17144: PUSH
17145: LD_INT 9
17147: LESS
17148: PUSH
17149: LD_VAR 0 2
17153: PPUSH
17154: CALL_OW 256
17158: PUSH
17159: LD_INT 500
17161: GREATER
17162: AND
17163: IFFALSE 17189
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
17165: LD_VAR 0 2
17169: PPUSH
17170: LD_VAR 0 3
17174: PPUSH
17175: LD_VAR 0 2
17179: PPUSH
17180: CALL_OW 74
17184: PPUSH
17185: CALL_OW 115
// end ;
17189: GO 16955
17191: POP
17192: POP
// end ;
17193: PPOPN 3
17195: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
17196: LD_EXP 32
17200: NOT
17201: IFFALSE 17322
17203: GO 17205
17205: DISABLE
17206: LD_INT 0
17208: PPUSH
17209: PPUSH
// begin enable ;
17210: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
17211: LD_ADDR_VAR 0 2
17215: PUSH
17216: LD_INT 22
17218: PUSH
17219: LD_INT 3
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 21
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PPUSH
17240: CALL_OW 69
17244: ST_TO_ADDR
// if filter then
17245: LD_VAR 0 2
17249: IFFALSE 17322
// for i in filter do
17251: LD_ADDR_VAR 0 1
17255: PUSH
17256: LD_VAR 0 2
17260: PUSH
17261: FOR_IN
17262: IFFALSE 17320
// if GetLives ( i ) < 990 then
17264: LD_VAR 0 1
17268: PPUSH
17269: CALL_OW 256
17273: PUSH
17274: LD_INT 990
17276: LESS
17277: IFFALSE 17318
// begin ru_alert := true ;
17279: LD_ADDR_EXP 60
17283: PUSH
17284: LD_INT 1
17286: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
17287: LD_ADDR_EXP 61
17291: PUSH
17292: LD_VAR 0 1
17296: PPUSH
17297: CALL_OW 250
17301: PUSH
17302: LD_VAR 0 1
17306: PPUSH
17307: CALL_OW 251
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: ST_TO_ADDR
// break ;
17316: GO 17320
// end ;
17318: GO 17261
17320: POP
17321: POP
// end ;
17322: PPOPN 2
17324: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
17325: LD_EXP 31
17329: IFFALSE 17478
17331: GO 17333
17333: DISABLE
17334: LD_INT 0
17336: PPUSH
17337: PPUSH
17338: PPUSH
17339: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
17340: LD_ADDR_VAR 0 4
17344: PUSH
17345: LD_EXP 56
17349: PUSH
17350: LD_EXP 55
17354: ADD
17355: PUSH
17356: LD_EXP 53
17360: ADD
17361: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
17362: LD_ADDR_VAR 0 3
17366: PUSH
17367: LD_INT 3
17369: PPUSH
17370: LD_INT 81
17372: PUSH
17373: LD_INT 3
17375: PUSH
17376: EMPTY
17377: LIST
17378: LIST
17379: PPUSH
17380: CALL_OW 70
17384: ST_TO_ADDR
// if filter and enemy then
17385: LD_VAR 0 4
17389: PUSH
17390: LD_VAR 0 3
17394: AND
17395: IFFALSE 17478
// repeat wait ( 0 0$01 ) ;
17397: LD_INT 35
17399: PPUSH
17400: CALL_OW 67
// for i in filter do
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_VAR 0 4
17413: PUSH
17414: FOR_IN
17415: IFFALSE 17443
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17417: LD_VAR 0 1
17421: PPUSH
17422: LD_VAR 0 3
17426: PPUSH
17427: LD_VAR 0 1
17431: PPUSH
17432: CALL_OW 74
17436: PPUSH
17437: CALL_OW 115
// end ;
17441: GO 17414
17443: POP
17444: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
17445: LD_INT 3
17447: PPUSH
17448: LD_INT 81
17450: PUSH
17451: LD_INT 3
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: PPUSH
17458: CALL_OW 70
17462: PUSH
17463: LD_INT 0
17465: EQUAL
17466: PUSH
17467: LD_VAR 0 4
17471: PUSH
17472: LD_INT 0
17474: EQUAL
17475: OR
17476: IFFALSE 17397
// end ;
17478: PPOPN 4
17480: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
17481: LD_EXP 26
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 4
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: LD_INT 30
17498: PUSH
17499: LD_INT 4
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: PUSH
17506: LD_INT 3
17508: PUSH
17509: LD_INT 57
17511: PUSH
17512: EMPTY
17513: LIST
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: LIST
17523: PPUSH
17524: CALL_OW 69
17528: AND
17529: IFFALSE 17578
17531: GO 17533
17533: DISABLE
17534: LD_INT 0
17536: PPUSH
// begin if not ru_cornel_attack then
17537: LD_EXP 58
17541: NOT
17542: IFFALSE 17546
// exit ;
17544: GO 17578
// for i in ru_cornel_attack do
17546: LD_ADDR_VAR 0 1
17550: PUSH
17551: LD_EXP 58
17555: PUSH
17556: FOR_IN
17557: IFFALSE 17576
// ComAgressiveMove ( i , 258 , 119 ) ;
17559: LD_VAR 0 1
17563: PPUSH
17564: LD_INT 258
17566: PPUSH
17567: LD_INT 119
17569: PPUSH
17570: CALL_OW 114
17574: GO 17556
17576: POP
17577: POP
// end ; end_of_file
17578: PPOPN 1
17580: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17581: LD_EXP 5
17585: PUSH
17586: LD_EXP 9
17590: NOT
17591: AND
17592: PUSH
17593: LD_EXP 20
17597: AND
17598: IFFALSE 17710
17600: GO 17602
17602: DISABLE
17603: LD_INT 0
17605: PPUSH
// begin enable ;
17606: ENABLE
// crates_counter := crates_counter - 50 ;
17607: LD_ADDR_EXP 20
17611: PUSH
17612: LD_EXP 20
17616: PUSH
17617: LD_INT 50
17619: MINUS
17620: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17621: LD_INT 8
17623: PPUSH
17624: LD_INT 2
17626: PPUSH
17627: LD_INT 5
17629: PPUSH
17630: CALL_OW 12
17634: PPUSH
17635: LD_INT 1
17637: PPUSH
17638: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17642: LD_INT 1785
17644: PPUSH
17645: LD_INT 2345
17647: PPUSH
17648: CALL_OW 12
17652: PPUSH
17653: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17657: LD_ADDR_VAR 0 1
17661: PUSH
17662: LD_INT 1
17664: PPUSH
17665: LD_OWVAR 67
17669: PUSH
17670: LD_INT 2
17672: PLUS
17673: PPUSH
17674: CALL_OW 12
17678: ST_TO_ADDR
// if r < 3 then
17679: LD_VAR 0 1
17683: PUSH
17684: LD_INT 3
17686: LESS
17687: IFFALSE 17710
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17689: LD_INT 4
17691: PPUSH
17692: LD_INT 1
17694: PPUSH
17695: LD_INT 5
17697: PPUSH
17698: CALL_OW 12
17702: PPUSH
17703: LD_INT 1
17705: PPUSH
17706: CALL_OW 55
// end ;
17710: PPOPN 1
17712: END
// every 0 0$01 trigger cornel_active do
17713: LD_EXP 8
17717: IFFALSE 17806
17719: GO 17721
17721: DISABLE
// begin Wait ( 0 0$03 ) ;
17722: LD_INT 105
17724: PPUSH
17725: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17729: LD_INT 2
17731: PPUSH
17732: LD_INT 5
17734: PPUSH
17735: CALL_OW 12
17739: PPUSH
17740: LD_INT 10
17742: PPUSH
17743: LD_INT 1
17745: PPUSH
17746: CALL_OW 55
// Wait ( 0 0$13 ) ;
17750: LD_INT 455
17752: PPUSH
17753: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17757: LD_INT 2
17759: PPUSH
17760: LD_INT 5
17762: PPUSH
17763: CALL_OW 12
17767: PPUSH
17768: LD_INT 10
17770: PPUSH
17771: LD_INT 1
17773: PPUSH
17774: CALL_OW 55
// Wait ( 0 0$16 ) ;
17778: LD_INT 560
17780: PPUSH
17781: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17785: LD_INT 2
17787: PPUSH
17788: LD_INT 5
17790: PPUSH
17791: CALL_OW 12
17795: PPUSH
17796: LD_INT 10
17798: PPUSH
17799: LD_INT 1
17801: PPUSH
17802: CALL_OW 55
// end ; end_of_file
17806: END
// every 0 0$01 trigger cornel_prepared do
17807: LD_EXP 11
17811: IFFALSE 17870
17813: GO 17815
17815: DISABLE
// begin enable ;
17816: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17817: LD_ADDR_OWVAR 47
17821: PUSH
17822: LD_STRING #Am03-1
17824: PUSH
17825: LD_EXP 10
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17834: LD_ADDR_EXP 10
17838: PUSH
17839: LD_EXP 10
17843: PPUSH
17844: LD_STRING -
17846: PPUSH
17847: CALL 1132 0 2
17851: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17852: LD_EXP 10
17856: PUSH
17857: LD_INT 0
17859: EQUAL
17860: IFFALSE 17870
// begin Display_Strings := [ ] ;
17862: LD_ADDR_OWVAR 47
17866: PUSH
17867: EMPTY
17868: ST_TO_ADDR
// disable ;
17869: DISABLE
// end ; end ;
17870: END
// every 0 0$01 trigger debug and debug_strings do
17871: LD_EXP 1
17875: PUSH
17876: LD_OWVAR 48
17880: AND
17881: IFFALSE 17897
17883: GO 17885
17885: DISABLE
// begin enable ;
17886: ENABLE
// Display_Strings := debug_strings ;
17887: LD_ADDR_OWVAR 47
17891: PUSH
17892: LD_OWVAR 48
17896: ST_TO_ADDR
// end ; end_of_file
17897: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17898: LD_VAR 0 1
17902: PPUSH
17903: CALL_OW 255
17907: PUSH
17908: LD_INT 1
17910: EQUAL
17911: PUSH
17912: LD_EXP 14
17916: NOT
17917: AND
17918: IFFALSE 17928
// solar_builded := true ;
17920: LD_ADDR_EXP 14
17924: PUSH
17925: LD_INT 1
17927: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17928: LD_VAR 0 1
17932: PPUSH
17933: CALL_OW 255
17937: PUSH
17938: LD_INT 1
17940: EQUAL
17941: PUSH
17942: LD_EXP 29
17946: AND
17947: IFFALSE 17980
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17949: LD_ADDR_EXP 29
17953: PUSH
17954: LD_EXP 29
17958: PUSH
17959: LD_INT 1750
17961: PUSH
17962: LD_INT 1400
17964: PUSH
17965: LD_INT 1225
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: LIST
17972: PUSH
17973: LD_OWVAR 67
17977: ARRAY
17978: PLUS
17979: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17980: LD_VAR 0 1
17984: PPUSH
17985: CALL_OW 255
17989: PUSH
17990: LD_INT 3
17992: EQUAL
17993: IFFALSE 18011
// ru_vehicles := ru_vehicles ^ veh ;
17995: LD_ADDR_EXP 56
17999: PUSH
18000: LD_EXP 56
18004: PUSH
18005: LD_VAR 0 1
18009: ADD
18010: ST_TO_ADDR
// end ;
18011: PPOPN 2
18013: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
18014: LD_VAR 0 1
18018: PUSH
18019: LD_EXP 53
18023: IN
18024: IFFALSE 18042
// ru_patrol := ru_patrol diff un ;
18026: LD_ADDR_EXP 53
18030: PUSH
18031: LD_EXP 53
18035: PUSH
18036: LD_VAR 0 1
18040: DIFF
18041: ST_TO_ADDR
// if un in ru_forest then
18042: LD_VAR 0 1
18046: PUSH
18047: LD_EXP 55
18051: IN
18052: IFFALSE 18070
// ru_forest := ru_forest diff un ;
18054: LD_ADDR_EXP 55
18058: PUSH
18059: LD_EXP 55
18063: PUSH
18064: LD_VAR 0 1
18068: DIFF
18069: ST_TO_ADDR
// if un in ru_vehicles then
18070: LD_VAR 0 1
18074: PUSH
18075: LD_EXP 56
18079: IN
18080: IFFALSE 18186
// begin ru_vehicles := ru_vehicles diff un ;
18082: LD_ADDR_EXP 56
18086: PUSH
18087: LD_EXP 56
18091: PUSH
18092: LD_VAR 0 1
18096: DIFF
18097: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
18098: LD_ADDR_EXP 57
18102: PUSH
18103: LD_EXP 57
18107: PUSH
18108: LD_VAR 0 1
18112: PPUSH
18113: CALL_OW 265
18117: PUSH
18118: LD_VAR 0 1
18122: PPUSH
18123: CALL_OW 262
18127: PUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: CALL_OW 263
18137: PUSH
18138: LD_VAR 0 1
18142: PPUSH
18143: CALL_OW 264
18147: PUSH
18148: EMPTY
18149: LIST
18150: LIST
18151: LIST
18152: LIST
18153: ADD
18154: ST_TO_ADDR
// ach_counter := ach_counter + 1 ;
18155: LD_ADDR_EXP 13
18159: PUSH
18160: LD_EXP 13
18164: PUSH
18165: LD_INT 1
18167: PLUS
18168: ST_TO_ADDR
// if ach_counter = 10 then
18169: LD_EXP 13
18173: PUSH
18174: LD_INT 10
18176: EQUAL
18177: IFFALSE 18186
// SetAchievement ( ACH_FAUST ) ;
18179: LD_STRING ACH_FAUST
18181: PPUSH
18182: CALL_OW 543
// end ; if un = Pokryshkin then
18186: LD_VAR 0 1
18190: PUSH
18191: LD_EXP 52
18195: EQUAL
18196: IFFALSE 18205
// SetAchievement ( ACH_POKR ) ;
18198: LD_STRING ACH_POKR
18200: PPUSH
18201: CALL_OW 543
// if un = JMM then
18205: LD_VAR 0 1
18209: PUSH
18210: LD_EXP 37
18214: EQUAL
18215: IFFALSE 18224
// YouLost ( 0 ) ;
18217: LD_STRING 0
18219: PPUSH
18220: CALL_OW 104
// if un = us_dep_west then
18224: LD_VAR 0 1
18228: PUSH
18229: LD_INT 1
18231: EQUAL
18232: IFFALSE 18241
// YouLost ( 2 ) ;
18234: LD_STRING 2
18236: PPUSH
18237: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
18241: LD_VAR 0 1
18245: PPUSH
18246: CALL_OW 255
18250: PUSH
18251: LD_INT 8
18253: EQUAL
18254: PUSH
18255: LD_EXP 5
18259: NOT
18260: AND
18261: IFFALSE 18270
// YouLost ( 4 ) ;
18263: LD_STRING 4
18265: PPUSH
18266: CALL_OW 104
// if un in jmm_units then
18270: LD_VAR 0 1
18274: PUSH
18275: LD_EXP 4
18279: IN
18280: IFFALSE 18296
// lose_counter := lose_counter + 1 ;
18282: LD_ADDR_EXP 34
18286: PUSH
18287: LD_EXP 34
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// end ;
18296: PPOPN 1
18298: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
18299: LD_INT 0
18301: PPUSH
18302: PPUSH
// begin if GetSide ( driver ) = 3 then
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 255
18312: PUSH
18313: LD_INT 3
18315: EQUAL
18316: IFFALSE 18394
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
18318: LD_ADDR_VAR 0 6
18322: PUSH
18323: LD_INT 22
18325: PUSH
18326: LD_INT 3
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: LD_INT 30
18335: PUSH
18336: LD_INT 3
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: PUSH
18343: EMPTY
18344: LIST
18345: LIST
18346: PPUSH
18347: CALL_OW 69
18351: PPUSH
18352: CALL 1062 0 1
18356: ST_TO_ADDR
// if place then
18357: LD_VAR 0 6
18361: IFFALSE 18379
// ComEnterUnit ( driver , place ) else
18363: LD_VAR 0 1
18367: PPUSH
18368: LD_VAR 0 6
18372: PPUSH
18373: CALL_OW 120
18377: GO 18394
// ComMoveXY ( driver , 70 , 22 ) ;
18379: LD_VAR 0 1
18383: PPUSH
18384: LD_INT 70
18386: PPUSH
18387: LD_INT 22
18389: PPUSH
18390: CALL_OW 111
// end ; end ;
18394: PPOPN 6
18396: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
18397: LD_VAR 0 1
18401: PUSH
18402: LD_INT 1
18404: EQUAL
18405: PUSH
18406: LD_VAR 0 2
18410: PUSH
18411: LD_INT 4
18413: EQUAL
18414: PUSH
18415: LD_VAR 0 2
18419: PUSH
18420: LD_INT 8
18422: EQUAL
18423: PUSH
18424: LD_EXP 5
18428: NOT
18429: AND
18430: OR
18431: AND
18432: IFFALSE 18441
// YouLost ( 5 ) ;
18434: LD_STRING 5
18436: PPUSH
18437: CALL_OW 104
// end ;
18441: PPOPN 2
18443: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
18444: LD_EXP 36
18448: PUSH
18449: LD_INT 22
18451: PUSH
18452: LD_INT 1
18454: PUSH
18455: EMPTY
18456: LIST
18457: LIST
18458: PUSH
18459: LD_INT 21
18461: PUSH
18462: LD_INT 1
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PUSH
18469: EMPTY
18470: LIST
18471: LIST
18472: PPUSH
18473: CALL_OW 69
18477: PUSH
18478: LD_INT 22
18480: PUSH
18481: LD_INT 8
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: PUSH
18488: LD_INT 21
18490: PUSH
18491: LD_INT 1
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PPUSH
18502: CALL_OW 69
18506: ADD
18507: PLUS
18508: PUSH
18509: LD_INT 5
18511: LESS
18512: IFFALSE 18524
18514: GO 18516
18516: DISABLE
// YouLost ( 1 ) ;
18517: LD_STRING 1
18519: PPUSH
18520: CALL_OW 104
18524: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
18525: LD_INT 1
18527: PPUSH
18528: CALL_OW 255
18532: PUSH
18533: LD_INT 3
18535: EQUAL
18536: IFFALSE 18548
18538: GO 18540
18540: DISABLE
// YouLost ( 3 ) ; end_of_file
18541: LD_STRING 3
18543: PPUSH
18544: CALL_OW 104
18548: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18549: GO 18551
18551: DISABLE
// begin ru_radar := 98 ;
18552: LD_ADDR_EXP 62
18556: PUSH
18557: LD_INT 98
18559: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18560: LD_ADDR_EXP 63
18564: PUSH
18565: LD_INT 89
18567: ST_TO_ADDR
// us_hack := 99 ;
18568: LD_ADDR_EXP 64
18572: PUSH
18573: LD_INT 99
18575: ST_TO_ADDR
// us_artillery := 97 ;
18576: LD_ADDR_EXP 65
18580: PUSH
18581: LD_INT 97
18583: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18584: LD_ADDR_EXP 66
18588: PUSH
18589: LD_INT 91
18591: ST_TO_ADDR
// tech_Artillery := 80 ;
18592: LD_ADDR_EXP 67
18596: PUSH
18597: LD_INT 80
18599: ST_TO_ADDR
// tech_RadMat := 81 ;
18600: LD_ADDR_EXP 68
18604: PUSH
18605: LD_INT 81
18607: ST_TO_ADDR
// tech_BasicTools := 82 ;
18608: LD_ADDR_EXP 69
18612: PUSH
18613: LD_INT 82
18615: ST_TO_ADDR
// tech_Cargo := 83 ;
18616: LD_ADDR_EXP 70
18620: PUSH
18621: LD_INT 83
18623: ST_TO_ADDR
// tech_Track := 84 ;
18624: LD_ADDR_EXP 71
18628: PUSH
18629: LD_INT 84
18631: ST_TO_ADDR
// tech_Crane := 85 ;
18632: LD_ADDR_EXP 72
18636: PUSH
18637: LD_INT 85
18639: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18640: LD_ADDR_EXP 73
18644: PUSH
18645: LD_INT 86
18647: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18648: LD_ADDR_EXP 74
18652: PUSH
18653: LD_INT 87
18655: ST_TO_ADDR
// end ; end_of_file end_of_file
18656: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
18657: GO 18659
18659: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
18660: LD_STRING initStreamRollete();
18662: PPUSH
18663: CALL_OW 559
// InitStreamMode ;
18667: CALL 18676 0 0
// DefineStreamItems ( ) ;
18671: CALL 19116 0 0
// end ;
18675: END
// function InitStreamMode ; begin
18676: LD_INT 0
18678: PPUSH
// streamModeActive := false ;
18679: LD_ADDR_EXP 75
18683: PUSH
18684: LD_INT 0
18686: ST_TO_ADDR
// normalCounter := 36 ;
18687: LD_ADDR_EXP 76
18691: PUSH
18692: LD_INT 36
18694: ST_TO_ADDR
// hardcoreCounter := 16 ;
18695: LD_ADDR_EXP 77
18699: PUSH
18700: LD_INT 16
18702: ST_TO_ADDR
// sRocket := false ;
18703: LD_ADDR_EXP 80
18707: PUSH
18708: LD_INT 0
18710: ST_TO_ADDR
// sSpeed := false ;
18711: LD_ADDR_EXP 79
18715: PUSH
18716: LD_INT 0
18718: ST_TO_ADDR
// sEngine := false ;
18719: LD_ADDR_EXP 81
18723: PUSH
18724: LD_INT 0
18726: ST_TO_ADDR
// sSpec := false ;
18727: LD_ADDR_EXP 78
18731: PUSH
18732: LD_INT 0
18734: ST_TO_ADDR
// sLevel := false ;
18735: LD_ADDR_EXP 82
18739: PUSH
18740: LD_INT 0
18742: ST_TO_ADDR
// sArmoury := false ;
18743: LD_ADDR_EXP 83
18747: PUSH
18748: LD_INT 0
18750: ST_TO_ADDR
// sRadar := false ;
18751: LD_ADDR_EXP 84
18755: PUSH
18756: LD_INT 0
18758: ST_TO_ADDR
// sBunker := false ;
18759: LD_ADDR_EXP 85
18763: PUSH
18764: LD_INT 0
18766: ST_TO_ADDR
// sHack := false ;
18767: LD_ADDR_EXP 86
18771: PUSH
18772: LD_INT 0
18774: ST_TO_ADDR
// sFire := false ;
18775: LD_ADDR_EXP 87
18779: PUSH
18780: LD_INT 0
18782: ST_TO_ADDR
// sRefresh := false ;
18783: LD_ADDR_EXP 88
18787: PUSH
18788: LD_INT 0
18790: ST_TO_ADDR
// sExp := false ;
18791: LD_ADDR_EXP 89
18795: PUSH
18796: LD_INT 0
18798: ST_TO_ADDR
// sDepot := false ;
18799: LD_ADDR_EXP 90
18803: PUSH
18804: LD_INT 0
18806: ST_TO_ADDR
// sFlag := false ;
18807: LD_ADDR_EXP 91
18811: PUSH
18812: LD_INT 0
18814: ST_TO_ADDR
// sKamikadze := false ;
18815: LD_ADDR_EXP 99
18819: PUSH
18820: LD_INT 0
18822: ST_TO_ADDR
// sTroll := false ;
18823: LD_ADDR_EXP 100
18827: PUSH
18828: LD_INT 0
18830: ST_TO_ADDR
// sSlow := false ;
18831: LD_ADDR_EXP 101
18835: PUSH
18836: LD_INT 0
18838: ST_TO_ADDR
// sLack := false ;
18839: LD_ADDR_EXP 102
18843: PUSH
18844: LD_INT 0
18846: ST_TO_ADDR
// sTank := false ;
18847: LD_ADDR_EXP 104
18851: PUSH
18852: LD_INT 0
18854: ST_TO_ADDR
// sRemote := false ;
18855: LD_ADDR_EXP 105
18859: PUSH
18860: LD_INT 0
18862: ST_TO_ADDR
// sPowell := false ;
18863: LD_ADDR_EXP 106
18867: PUSH
18868: LD_INT 0
18870: ST_TO_ADDR
// sTeleport := false ;
18871: LD_ADDR_EXP 109
18875: PUSH
18876: LD_INT 0
18878: ST_TO_ADDR
// sOilTower := false ;
18879: LD_ADDR_EXP 111
18883: PUSH
18884: LD_INT 0
18886: ST_TO_ADDR
// sShovel := false ;
18887: LD_ADDR_EXP 112
18891: PUSH
18892: LD_INT 0
18894: ST_TO_ADDR
// sSheik := false ;
18895: LD_ADDR_EXP 113
18899: PUSH
18900: LD_INT 0
18902: ST_TO_ADDR
// sEarthquake := false ;
18903: LD_ADDR_EXP 115
18907: PUSH
18908: LD_INT 0
18910: ST_TO_ADDR
// sAI := false ;
18911: LD_ADDR_EXP 116
18915: PUSH
18916: LD_INT 0
18918: ST_TO_ADDR
// sCargo := false ;
18919: LD_ADDR_EXP 119
18923: PUSH
18924: LD_INT 0
18926: ST_TO_ADDR
// sDLaser := false ;
18927: LD_ADDR_EXP 120
18931: PUSH
18932: LD_INT 0
18934: ST_TO_ADDR
// sExchange := false ;
18935: LD_ADDR_EXP 121
18939: PUSH
18940: LD_INT 0
18942: ST_TO_ADDR
// sFac := false ;
18943: LD_ADDR_EXP 122
18947: PUSH
18948: LD_INT 0
18950: ST_TO_ADDR
// sPower := false ;
18951: LD_ADDR_EXP 123
18955: PUSH
18956: LD_INT 0
18958: ST_TO_ADDR
// sRandom := false ;
18959: LD_ADDR_EXP 124
18963: PUSH
18964: LD_INT 0
18966: ST_TO_ADDR
// sShield := false ;
18967: LD_ADDR_EXP 125
18971: PUSH
18972: LD_INT 0
18974: ST_TO_ADDR
// sTime := false ;
18975: LD_ADDR_EXP 126
18979: PUSH
18980: LD_INT 0
18982: ST_TO_ADDR
// sTools := false ;
18983: LD_ADDR_EXP 127
18987: PUSH
18988: LD_INT 0
18990: ST_TO_ADDR
// sSold := false ;
18991: LD_ADDR_EXP 92
18995: PUSH
18996: LD_INT 0
18998: ST_TO_ADDR
// sDiff := false ;
18999: LD_ADDR_EXP 93
19003: PUSH
19004: LD_INT 0
19006: ST_TO_ADDR
// sFog := false ;
19007: LD_ADDR_EXP 96
19011: PUSH
19012: LD_INT 0
19014: ST_TO_ADDR
// sReset := false ;
19015: LD_ADDR_EXP 97
19019: PUSH
19020: LD_INT 0
19022: ST_TO_ADDR
// sSun := false ;
19023: LD_ADDR_EXP 98
19027: PUSH
19028: LD_INT 0
19030: ST_TO_ADDR
// sTiger := false ;
19031: LD_ADDR_EXP 94
19035: PUSH
19036: LD_INT 0
19038: ST_TO_ADDR
// sBomb := false ;
19039: LD_ADDR_EXP 95
19043: PUSH
19044: LD_INT 0
19046: ST_TO_ADDR
// sWound := false ;
19047: LD_ADDR_EXP 103
19051: PUSH
19052: LD_INT 0
19054: ST_TO_ADDR
// sBetray := false ;
19055: LD_ADDR_EXP 107
19059: PUSH
19060: LD_INT 0
19062: ST_TO_ADDR
// sContamin := false ;
19063: LD_ADDR_EXP 108
19067: PUSH
19068: LD_INT 0
19070: ST_TO_ADDR
// sOil := false ;
19071: LD_ADDR_EXP 110
19075: PUSH
19076: LD_INT 0
19078: ST_TO_ADDR
// sStu := false ;
19079: LD_ADDR_EXP 114
19083: PUSH
19084: LD_INT 0
19086: ST_TO_ADDR
// sBazooka := false ;
19087: LD_ADDR_EXP 117
19091: PUSH
19092: LD_INT 0
19094: ST_TO_ADDR
// sMortar := false ;
19095: LD_ADDR_EXP 118
19099: PUSH
19100: LD_INT 0
19102: ST_TO_ADDR
// sRanger := false ;
19103: LD_ADDR_EXP 128
19107: PUSH
19108: LD_INT 0
19110: ST_TO_ADDR
// end ;
19111: LD_VAR 0 1
19115: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
19116: LD_INT 0
19118: PPUSH
19119: PPUSH
19120: PPUSH
19121: PPUSH
19122: PPUSH
// result := [ ] ;
19123: LD_ADDR_VAR 0 1
19127: PUSH
19128: EMPTY
19129: ST_TO_ADDR
// if campaign_id = 1 then
19130: LD_OWVAR 69
19134: PUSH
19135: LD_INT 1
19137: EQUAL
19138: IFFALSE 22076
// begin case mission_number of 1 :
19140: LD_OWVAR 70
19144: PUSH
19145: LD_INT 1
19147: DOUBLE
19148: EQUAL
19149: IFTRUE 19153
19151: GO 19217
19153: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
19154: LD_ADDR_VAR 0 1
19158: PUSH
19159: LD_INT 2
19161: PUSH
19162: LD_INT 4
19164: PUSH
19165: LD_INT 11
19167: PUSH
19168: LD_INT 12
19170: PUSH
19171: LD_INT 15
19173: PUSH
19174: LD_INT 16
19176: PUSH
19177: LD_INT 22
19179: PUSH
19180: LD_INT 23
19182: PUSH
19183: LD_INT 26
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: LIST
19195: LIST
19196: PUSH
19197: LD_INT 101
19199: PUSH
19200: LD_INT 102
19202: PUSH
19203: LD_INT 106
19205: PUSH
19206: EMPTY
19207: LIST
19208: LIST
19209: LIST
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: ST_TO_ADDR
19215: GO 22074
19217: LD_INT 2
19219: DOUBLE
19220: EQUAL
19221: IFTRUE 19225
19223: GO 19297
19225: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
19226: LD_ADDR_VAR 0 1
19230: PUSH
19231: LD_INT 2
19233: PUSH
19234: LD_INT 4
19236: PUSH
19237: LD_INT 11
19239: PUSH
19240: LD_INT 12
19242: PUSH
19243: LD_INT 15
19245: PUSH
19246: LD_INT 16
19248: PUSH
19249: LD_INT 22
19251: PUSH
19252: LD_INT 23
19254: PUSH
19255: LD_INT 26
19257: PUSH
19258: EMPTY
19259: LIST
19260: LIST
19261: LIST
19262: LIST
19263: LIST
19264: LIST
19265: LIST
19266: LIST
19267: LIST
19268: PUSH
19269: LD_INT 101
19271: PUSH
19272: LD_INT 102
19274: PUSH
19275: LD_INT 105
19277: PUSH
19278: LD_INT 106
19280: PUSH
19281: LD_INT 108
19283: PUSH
19284: EMPTY
19285: LIST
19286: LIST
19287: LIST
19288: LIST
19289: LIST
19290: PUSH
19291: EMPTY
19292: LIST
19293: LIST
19294: ST_TO_ADDR
19295: GO 22074
19297: LD_INT 3
19299: DOUBLE
19300: EQUAL
19301: IFTRUE 19305
19303: GO 19381
19305: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
19306: LD_ADDR_VAR 0 1
19310: PUSH
19311: LD_INT 2
19313: PUSH
19314: LD_INT 4
19316: PUSH
19317: LD_INT 5
19319: PUSH
19320: LD_INT 11
19322: PUSH
19323: LD_INT 12
19325: PUSH
19326: LD_INT 15
19328: PUSH
19329: LD_INT 16
19331: PUSH
19332: LD_INT 22
19334: PUSH
19335: LD_INT 26
19337: PUSH
19338: LD_INT 36
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: LIST
19345: LIST
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 101
19355: PUSH
19356: LD_INT 102
19358: PUSH
19359: LD_INT 105
19361: PUSH
19362: LD_INT 106
19364: PUSH
19365: LD_INT 108
19367: PUSH
19368: EMPTY
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: ST_TO_ADDR
19379: GO 22074
19381: LD_INT 4
19383: DOUBLE
19384: EQUAL
19385: IFTRUE 19389
19387: GO 19473
19389: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
19390: LD_ADDR_VAR 0 1
19394: PUSH
19395: LD_INT 2
19397: PUSH
19398: LD_INT 4
19400: PUSH
19401: LD_INT 5
19403: PUSH
19404: LD_INT 8
19406: PUSH
19407: LD_INT 11
19409: PUSH
19410: LD_INT 12
19412: PUSH
19413: LD_INT 15
19415: PUSH
19416: LD_INT 16
19418: PUSH
19419: LD_INT 22
19421: PUSH
19422: LD_INT 23
19424: PUSH
19425: LD_INT 26
19427: PUSH
19428: LD_INT 36
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: LIST
19437: LIST
19438: LIST
19439: LIST
19440: LIST
19441: LIST
19442: LIST
19443: LIST
19444: PUSH
19445: LD_INT 101
19447: PUSH
19448: LD_INT 102
19450: PUSH
19451: LD_INT 105
19453: PUSH
19454: LD_INT 106
19456: PUSH
19457: LD_INT 108
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: LIST
19464: LIST
19465: LIST
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: ST_TO_ADDR
19471: GO 22074
19473: LD_INT 5
19475: DOUBLE
19476: EQUAL
19477: IFTRUE 19481
19479: GO 19581
19481: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
19482: LD_ADDR_VAR 0 1
19486: PUSH
19487: LD_INT 2
19489: PUSH
19490: LD_INT 4
19492: PUSH
19493: LD_INT 5
19495: PUSH
19496: LD_INT 6
19498: PUSH
19499: LD_INT 8
19501: PUSH
19502: LD_INT 11
19504: PUSH
19505: LD_INT 12
19507: PUSH
19508: LD_INT 15
19510: PUSH
19511: LD_INT 16
19513: PUSH
19514: LD_INT 22
19516: PUSH
19517: LD_INT 23
19519: PUSH
19520: LD_INT 25
19522: PUSH
19523: LD_INT 26
19525: PUSH
19526: LD_INT 36
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: LIST
19533: LIST
19534: LIST
19535: LIST
19536: LIST
19537: LIST
19538: LIST
19539: LIST
19540: LIST
19541: LIST
19542: LIST
19543: LIST
19544: PUSH
19545: LD_INT 101
19547: PUSH
19548: LD_INT 102
19550: PUSH
19551: LD_INT 105
19553: PUSH
19554: LD_INT 106
19556: PUSH
19557: LD_INT 108
19559: PUSH
19560: LD_INT 109
19562: PUSH
19563: LD_INT 112
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: LIST
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: PUSH
19575: EMPTY
19576: LIST
19577: LIST
19578: ST_TO_ADDR
19579: GO 22074
19581: LD_INT 6
19583: DOUBLE
19584: EQUAL
19585: IFTRUE 19589
19587: GO 19709
19589: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
19590: LD_ADDR_VAR 0 1
19594: PUSH
19595: LD_INT 2
19597: PUSH
19598: LD_INT 4
19600: PUSH
19601: LD_INT 5
19603: PUSH
19604: LD_INT 6
19606: PUSH
19607: LD_INT 8
19609: PUSH
19610: LD_INT 11
19612: PUSH
19613: LD_INT 12
19615: PUSH
19616: LD_INT 15
19618: PUSH
19619: LD_INT 16
19621: PUSH
19622: LD_INT 20
19624: PUSH
19625: LD_INT 21
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 23
19633: PUSH
19634: LD_INT 25
19636: PUSH
19637: LD_INT 26
19639: PUSH
19640: LD_INT 30
19642: PUSH
19643: LD_INT 31
19645: PUSH
19646: LD_INT 32
19648: PUSH
19649: LD_INT 36
19651: PUSH
19652: EMPTY
19653: LIST
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: LIST
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: LIST
19672: PUSH
19673: LD_INT 101
19675: PUSH
19676: LD_INT 102
19678: PUSH
19679: LD_INT 105
19681: PUSH
19682: LD_INT 106
19684: PUSH
19685: LD_INT 108
19687: PUSH
19688: LD_INT 109
19690: PUSH
19691: LD_INT 112
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: ST_TO_ADDR
19707: GO 22074
19709: LD_INT 7
19711: DOUBLE
19712: EQUAL
19713: IFTRUE 19717
19715: GO 19817
19717: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
19718: LD_ADDR_VAR 0 1
19722: PUSH
19723: LD_INT 2
19725: PUSH
19726: LD_INT 4
19728: PUSH
19729: LD_INT 5
19731: PUSH
19732: LD_INT 7
19734: PUSH
19735: LD_INT 11
19737: PUSH
19738: LD_INT 12
19740: PUSH
19741: LD_INT 15
19743: PUSH
19744: LD_INT 16
19746: PUSH
19747: LD_INT 20
19749: PUSH
19750: LD_INT 21
19752: PUSH
19753: LD_INT 22
19755: PUSH
19756: LD_INT 23
19758: PUSH
19759: LD_INT 25
19761: PUSH
19762: LD_INT 26
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: PUSH
19781: LD_INT 101
19783: PUSH
19784: LD_INT 102
19786: PUSH
19787: LD_INT 103
19789: PUSH
19790: LD_INT 105
19792: PUSH
19793: LD_INT 106
19795: PUSH
19796: LD_INT 108
19798: PUSH
19799: LD_INT 112
19801: PUSH
19802: EMPTY
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: ST_TO_ADDR
19815: GO 22074
19817: LD_INT 8
19819: DOUBLE
19820: EQUAL
19821: IFTRUE 19825
19823: GO 19953
19825: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
19826: LD_ADDR_VAR 0 1
19830: PUSH
19831: LD_INT 2
19833: PUSH
19834: LD_INT 4
19836: PUSH
19837: LD_INT 5
19839: PUSH
19840: LD_INT 6
19842: PUSH
19843: LD_INT 7
19845: PUSH
19846: LD_INT 8
19848: PUSH
19849: LD_INT 11
19851: PUSH
19852: LD_INT 12
19854: PUSH
19855: LD_INT 15
19857: PUSH
19858: LD_INT 16
19860: PUSH
19861: LD_INT 20
19863: PUSH
19864: LD_INT 21
19866: PUSH
19867: LD_INT 22
19869: PUSH
19870: LD_INT 23
19872: PUSH
19873: LD_INT 25
19875: PUSH
19876: LD_INT 26
19878: PUSH
19879: LD_INT 30
19881: PUSH
19882: LD_INT 31
19884: PUSH
19885: LD_INT 32
19887: PUSH
19888: LD_INT 36
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 101
19915: PUSH
19916: LD_INT 102
19918: PUSH
19919: LD_INT 103
19921: PUSH
19922: LD_INT 105
19924: PUSH
19925: LD_INT 106
19927: PUSH
19928: LD_INT 108
19930: PUSH
19931: LD_INT 109
19933: PUSH
19934: LD_INT 112
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: ST_TO_ADDR
19951: GO 22074
19953: LD_INT 9
19955: DOUBLE
19956: EQUAL
19957: IFTRUE 19961
19959: GO 20097
19961: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
19962: LD_ADDR_VAR 0 1
19966: PUSH
19967: LD_INT 2
19969: PUSH
19970: LD_INT 4
19972: PUSH
19973: LD_INT 5
19975: PUSH
19976: LD_INT 6
19978: PUSH
19979: LD_INT 7
19981: PUSH
19982: LD_INT 8
19984: PUSH
19985: LD_INT 11
19987: PUSH
19988: LD_INT 12
19990: PUSH
19991: LD_INT 15
19993: PUSH
19994: LD_INT 16
19996: PUSH
19997: LD_INT 20
19999: PUSH
20000: LD_INT 21
20002: PUSH
20003: LD_INT 22
20005: PUSH
20006: LD_INT 23
20008: PUSH
20009: LD_INT 25
20011: PUSH
20012: LD_INT 26
20014: PUSH
20015: LD_INT 28
20017: PUSH
20018: LD_INT 30
20020: PUSH
20021: LD_INT 31
20023: PUSH
20024: LD_INT 32
20026: PUSH
20027: LD_INT 36
20029: PUSH
20030: EMPTY
20031: LIST
20032: LIST
20033: LIST
20034: LIST
20035: LIST
20036: LIST
20037: LIST
20038: LIST
20039: LIST
20040: LIST
20041: LIST
20042: LIST
20043: LIST
20044: LIST
20045: LIST
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: PUSH
20053: LD_INT 101
20055: PUSH
20056: LD_INT 102
20058: PUSH
20059: LD_INT 103
20061: PUSH
20062: LD_INT 105
20064: PUSH
20065: LD_INT 106
20067: PUSH
20068: LD_INT 108
20070: PUSH
20071: LD_INT 109
20073: PUSH
20074: LD_INT 112
20076: PUSH
20077: LD_INT 114
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: ST_TO_ADDR
20095: GO 22074
20097: LD_INT 10
20099: DOUBLE
20100: EQUAL
20101: IFTRUE 20105
20103: GO 20289
20105: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
20106: LD_ADDR_VAR 0 1
20110: PUSH
20111: LD_INT 2
20113: PUSH
20114: LD_INT 4
20116: PUSH
20117: LD_INT 5
20119: PUSH
20120: LD_INT 6
20122: PUSH
20123: LD_INT 7
20125: PUSH
20126: LD_INT 8
20128: PUSH
20129: LD_INT 9
20131: PUSH
20132: LD_INT 10
20134: PUSH
20135: LD_INT 11
20137: PUSH
20138: LD_INT 12
20140: PUSH
20141: LD_INT 13
20143: PUSH
20144: LD_INT 14
20146: PUSH
20147: LD_INT 15
20149: PUSH
20150: LD_INT 16
20152: PUSH
20153: LD_INT 17
20155: PUSH
20156: LD_INT 18
20158: PUSH
20159: LD_INT 19
20161: PUSH
20162: LD_INT 20
20164: PUSH
20165: LD_INT 21
20167: PUSH
20168: LD_INT 22
20170: PUSH
20171: LD_INT 23
20173: PUSH
20174: LD_INT 24
20176: PUSH
20177: LD_INT 25
20179: PUSH
20180: LD_INT 26
20182: PUSH
20183: LD_INT 28
20185: PUSH
20186: LD_INT 30
20188: PUSH
20189: LD_INT 31
20191: PUSH
20192: LD_INT 32
20194: PUSH
20195: LD_INT 36
20197: PUSH
20198: EMPTY
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: LIST
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: PUSH
20229: LD_INT 101
20231: PUSH
20232: LD_INT 102
20234: PUSH
20235: LD_INT 103
20237: PUSH
20238: LD_INT 104
20240: PUSH
20241: LD_INT 105
20243: PUSH
20244: LD_INT 106
20246: PUSH
20247: LD_INT 107
20249: PUSH
20250: LD_INT 108
20252: PUSH
20253: LD_INT 109
20255: PUSH
20256: LD_INT 110
20258: PUSH
20259: LD_INT 111
20261: PUSH
20262: LD_INT 112
20264: PUSH
20265: LD_INT 114
20267: PUSH
20268: EMPTY
20269: LIST
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: ST_TO_ADDR
20287: GO 22074
20289: LD_INT 11
20291: DOUBLE
20292: EQUAL
20293: IFTRUE 20297
20295: GO 20489
20297: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
20298: LD_ADDR_VAR 0 1
20302: PUSH
20303: LD_INT 2
20305: PUSH
20306: LD_INT 3
20308: PUSH
20309: LD_INT 4
20311: PUSH
20312: LD_INT 5
20314: PUSH
20315: LD_INT 6
20317: PUSH
20318: LD_INT 7
20320: PUSH
20321: LD_INT 8
20323: PUSH
20324: LD_INT 9
20326: PUSH
20327: LD_INT 10
20329: PUSH
20330: LD_INT 11
20332: PUSH
20333: LD_INT 12
20335: PUSH
20336: LD_INT 13
20338: PUSH
20339: LD_INT 14
20341: PUSH
20342: LD_INT 15
20344: PUSH
20345: LD_INT 16
20347: PUSH
20348: LD_INT 17
20350: PUSH
20351: LD_INT 18
20353: PUSH
20354: LD_INT 19
20356: PUSH
20357: LD_INT 20
20359: PUSH
20360: LD_INT 21
20362: PUSH
20363: LD_INT 22
20365: PUSH
20366: LD_INT 23
20368: PUSH
20369: LD_INT 24
20371: PUSH
20372: LD_INT 25
20374: PUSH
20375: LD_INT 26
20377: PUSH
20378: LD_INT 28
20380: PUSH
20381: LD_INT 30
20383: PUSH
20384: LD_INT 31
20386: PUSH
20387: LD_INT 32
20389: PUSH
20390: LD_INT 34
20392: PUSH
20393: LD_INT 36
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: PUSH
20429: LD_INT 101
20431: PUSH
20432: LD_INT 102
20434: PUSH
20435: LD_INT 103
20437: PUSH
20438: LD_INT 104
20440: PUSH
20441: LD_INT 105
20443: PUSH
20444: LD_INT 106
20446: PUSH
20447: LD_INT 107
20449: PUSH
20450: LD_INT 108
20452: PUSH
20453: LD_INT 109
20455: PUSH
20456: LD_INT 110
20458: PUSH
20459: LD_INT 111
20461: PUSH
20462: LD_INT 112
20464: PUSH
20465: LD_INT 114
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: LIST
20472: LIST
20473: LIST
20474: LIST
20475: LIST
20476: LIST
20477: LIST
20478: LIST
20479: LIST
20480: LIST
20481: LIST
20482: PUSH
20483: EMPTY
20484: LIST
20485: LIST
20486: ST_TO_ADDR
20487: GO 22074
20489: LD_INT 12
20491: DOUBLE
20492: EQUAL
20493: IFTRUE 20497
20495: GO 20705
20497: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
20498: LD_ADDR_VAR 0 1
20502: PUSH
20503: LD_INT 1
20505: PUSH
20506: LD_INT 2
20508: PUSH
20509: LD_INT 3
20511: PUSH
20512: LD_INT 4
20514: PUSH
20515: LD_INT 5
20517: PUSH
20518: LD_INT 6
20520: PUSH
20521: LD_INT 7
20523: PUSH
20524: LD_INT 8
20526: PUSH
20527: LD_INT 9
20529: PUSH
20530: LD_INT 10
20532: PUSH
20533: LD_INT 11
20535: PUSH
20536: LD_INT 12
20538: PUSH
20539: LD_INT 13
20541: PUSH
20542: LD_INT 14
20544: PUSH
20545: LD_INT 15
20547: PUSH
20548: LD_INT 16
20550: PUSH
20551: LD_INT 17
20553: PUSH
20554: LD_INT 18
20556: PUSH
20557: LD_INT 19
20559: PUSH
20560: LD_INT 20
20562: PUSH
20563: LD_INT 21
20565: PUSH
20566: LD_INT 22
20568: PUSH
20569: LD_INT 23
20571: PUSH
20572: LD_INT 24
20574: PUSH
20575: LD_INT 25
20577: PUSH
20578: LD_INT 26
20580: PUSH
20581: LD_INT 27
20583: PUSH
20584: LD_INT 28
20586: PUSH
20587: LD_INT 30
20589: PUSH
20590: LD_INT 31
20592: PUSH
20593: LD_INT 32
20595: PUSH
20596: LD_INT 33
20598: PUSH
20599: LD_INT 34
20601: PUSH
20602: LD_INT 36
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: PUSH
20641: LD_INT 101
20643: PUSH
20644: LD_INT 102
20646: PUSH
20647: LD_INT 103
20649: PUSH
20650: LD_INT 104
20652: PUSH
20653: LD_INT 105
20655: PUSH
20656: LD_INT 106
20658: PUSH
20659: LD_INT 107
20661: PUSH
20662: LD_INT 108
20664: PUSH
20665: LD_INT 109
20667: PUSH
20668: LD_INT 110
20670: PUSH
20671: LD_INT 111
20673: PUSH
20674: LD_INT 112
20676: PUSH
20677: LD_INT 113
20679: PUSH
20680: LD_INT 114
20682: PUSH
20683: EMPTY
20684: LIST
20685: LIST
20686: LIST
20687: LIST
20688: LIST
20689: LIST
20690: LIST
20691: LIST
20692: LIST
20693: LIST
20694: LIST
20695: LIST
20696: LIST
20697: LIST
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: ST_TO_ADDR
20703: GO 22074
20705: LD_INT 13
20707: DOUBLE
20708: EQUAL
20709: IFTRUE 20713
20711: GO 20909
20713: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
20714: LD_ADDR_VAR 0 1
20718: PUSH
20719: LD_INT 1
20721: PUSH
20722: LD_INT 2
20724: PUSH
20725: LD_INT 3
20727: PUSH
20728: LD_INT 4
20730: PUSH
20731: LD_INT 5
20733: PUSH
20734: LD_INT 8
20736: PUSH
20737: LD_INT 9
20739: PUSH
20740: LD_INT 10
20742: PUSH
20743: LD_INT 11
20745: PUSH
20746: LD_INT 12
20748: PUSH
20749: LD_INT 14
20751: PUSH
20752: LD_INT 15
20754: PUSH
20755: LD_INT 16
20757: PUSH
20758: LD_INT 17
20760: PUSH
20761: LD_INT 18
20763: PUSH
20764: LD_INT 19
20766: PUSH
20767: LD_INT 20
20769: PUSH
20770: LD_INT 21
20772: PUSH
20773: LD_INT 22
20775: PUSH
20776: LD_INT 23
20778: PUSH
20779: LD_INT 24
20781: PUSH
20782: LD_INT 25
20784: PUSH
20785: LD_INT 26
20787: PUSH
20788: LD_INT 27
20790: PUSH
20791: LD_INT 28
20793: PUSH
20794: LD_INT 30
20796: PUSH
20797: LD_INT 31
20799: PUSH
20800: LD_INT 32
20802: PUSH
20803: LD_INT 33
20805: PUSH
20806: LD_INT 34
20808: PUSH
20809: LD_INT 36
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: LIST
20829: LIST
20830: LIST
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: PUSH
20845: LD_INT 101
20847: PUSH
20848: LD_INT 102
20850: PUSH
20851: LD_INT 103
20853: PUSH
20854: LD_INT 104
20856: PUSH
20857: LD_INT 105
20859: PUSH
20860: LD_INT 106
20862: PUSH
20863: LD_INT 107
20865: PUSH
20866: LD_INT 108
20868: PUSH
20869: LD_INT 109
20871: PUSH
20872: LD_INT 110
20874: PUSH
20875: LD_INT 111
20877: PUSH
20878: LD_INT 112
20880: PUSH
20881: LD_INT 113
20883: PUSH
20884: LD_INT 114
20886: PUSH
20887: EMPTY
20888: LIST
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: LIST
20900: LIST
20901: LIST
20902: PUSH
20903: EMPTY
20904: LIST
20905: LIST
20906: ST_TO_ADDR
20907: GO 22074
20909: LD_INT 14
20911: DOUBLE
20912: EQUAL
20913: IFTRUE 20917
20915: GO 21129
20917: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
20918: LD_ADDR_VAR 0 1
20922: PUSH
20923: LD_INT 1
20925: PUSH
20926: LD_INT 2
20928: PUSH
20929: LD_INT 3
20931: PUSH
20932: LD_INT 4
20934: PUSH
20935: LD_INT 5
20937: PUSH
20938: LD_INT 6
20940: PUSH
20941: LD_INT 7
20943: PUSH
20944: LD_INT 8
20946: PUSH
20947: LD_INT 9
20949: PUSH
20950: LD_INT 10
20952: PUSH
20953: LD_INT 11
20955: PUSH
20956: LD_INT 12
20958: PUSH
20959: LD_INT 13
20961: PUSH
20962: LD_INT 14
20964: PUSH
20965: LD_INT 15
20967: PUSH
20968: LD_INT 16
20970: PUSH
20971: LD_INT 17
20973: PUSH
20974: LD_INT 18
20976: PUSH
20977: LD_INT 19
20979: PUSH
20980: LD_INT 20
20982: PUSH
20983: LD_INT 21
20985: PUSH
20986: LD_INT 22
20988: PUSH
20989: LD_INT 23
20991: PUSH
20992: LD_INT 24
20994: PUSH
20995: LD_INT 25
20997: PUSH
20998: LD_INT 26
21000: PUSH
21001: LD_INT 27
21003: PUSH
21004: LD_INT 28
21006: PUSH
21007: LD_INT 29
21009: PUSH
21010: LD_INT 30
21012: PUSH
21013: LD_INT 31
21015: PUSH
21016: LD_INT 32
21018: PUSH
21019: LD_INT 33
21021: PUSH
21022: LD_INT 34
21024: PUSH
21025: LD_INT 36
21027: PUSH
21028: EMPTY
21029: LIST
21030: LIST
21031: LIST
21032: LIST
21033: LIST
21034: LIST
21035: LIST
21036: LIST
21037: LIST
21038: LIST
21039: LIST
21040: LIST
21041: LIST
21042: LIST
21043: LIST
21044: LIST
21045: LIST
21046: LIST
21047: LIST
21048: LIST
21049: LIST
21050: LIST
21051: LIST
21052: LIST
21053: LIST
21054: LIST
21055: LIST
21056: LIST
21057: LIST
21058: LIST
21059: LIST
21060: LIST
21061: LIST
21062: LIST
21063: LIST
21064: PUSH
21065: LD_INT 101
21067: PUSH
21068: LD_INT 102
21070: PUSH
21071: LD_INT 103
21073: PUSH
21074: LD_INT 104
21076: PUSH
21077: LD_INT 105
21079: PUSH
21080: LD_INT 106
21082: PUSH
21083: LD_INT 107
21085: PUSH
21086: LD_INT 108
21088: PUSH
21089: LD_INT 109
21091: PUSH
21092: LD_INT 110
21094: PUSH
21095: LD_INT 111
21097: PUSH
21098: LD_INT 112
21100: PUSH
21101: LD_INT 113
21103: PUSH
21104: LD_INT 114
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: LIST
21111: LIST
21112: LIST
21113: LIST
21114: LIST
21115: LIST
21116: LIST
21117: LIST
21118: LIST
21119: LIST
21120: LIST
21121: LIST
21122: PUSH
21123: EMPTY
21124: LIST
21125: LIST
21126: ST_TO_ADDR
21127: GO 22074
21129: LD_INT 15
21131: DOUBLE
21132: EQUAL
21133: IFTRUE 21137
21135: GO 21349
21137: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
21138: LD_ADDR_VAR 0 1
21142: PUSH
21143: LD_INT 1
21145: PUSH
21146: LD_INT 2
21148: PUSH
21149: LD_INT 3
21151: PUSH
21152: LD_INT 4
21154: PUSH
21155: LD_INT 5
21157: PUSH
21158: LD_INT 6
21160: PUSH
21161: LD_INT 7
21163: PUSH
21164: LD_INT 8
21166: PUSH
21167: LD_INT 9
21169: PUSH
21170: LD_INT 10
21172: PUSH
21173: LD_INT 11
21175: PUSH
21176: LD_INT 12
21178: PUSH
21179: LD_INT 13
21181: PUSH
21182: LD_INT 14
21184: PUSH
21185: LD_INT 15
21187: PUSH
21188: LD_INT 16
21190: PUSH
21191: LD_INT 17
21193: PUSH
21194: LD_INT 18
21196: PUSH
21197: LD_INT 19
21199: PUSH
21200: LD_INT 20
21202: PUSH
21203: LD_INT 21
21205: PUSH
21206: LD_INT 22
21208: PUSH
21209: LD_INT 23
21211: PUSH
21212: LD_INT 24
21214: PUSH
21215: LD_INT 25
21217: PUSH
21218: LD_INT 26
21220: PUSH
21221: LD_INT 27
21223: PUSH
21224: LD_INT 28
21226: PUSH
21227: LD_INT 29
21229: PUSH
21230: LD_INT 30
21232: PUSH
21233: LD_INT 31
21235: PUSH
21236: LD_INT 32
21238: PUSH
21239: LD_INT 33
21241: PUSH
21242: LD_INT 34
21244: PUSH
21245: LD_INT 36
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: LIST
21252: LIST
21253: LIST
21254: LIST
21255: LIST
21256: LIST
21257: LIST
21258: LIST
21259: LIST
21260: LIST
21261: LIST
21262: LIST
21263: LIST
21264: LIST
21265: LIST
21266: LIST
21267: LIST
21268: LIST
21269: LIST
21270: LIST
21271: LIST
21272: LIST
21273: LIST
21274: LIST
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: LIST
21283: LIST
21284: PUSH
21285: LD_INT 101
21287: PUSH
21288: LD_INT 102
21290: PUSH
21291: LD_INT 103
21293: PUSH
21294: LD_INT 104
21296: PUSH
21297: LD_INT 105
21299: PUSH
21300: LD_INT 106
21302: PUSH
21303: LD_INT 107
21305: PUSH
21306: LD_INT 108
21308: PUSH
21309: LD_INT 109
21311: PUSH
21312: LD_INT 110
21314: PUSH
21315: LD_INT 111
21317: PUSH
21318: LD_INT 112
21320: PUSH
21321: LD_INT 113
21323: PUSH
21324: LD_INT 114
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: LIST
21332: LIST
21333: LIST
21334: LIST
21335: LIST
21336: LIST
21337: LIST
21338: LIST
21339: LIST
21340: LIST
21341: LIST
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: ST_TO_ADDR
21347: GO 22074
21349: LD_INT 16
21351: DOUBLE
21352: EQUAL
21353: IFTRUE 21357
21355: GO 21481
21357: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
21358: LD_ADDR_VAR 0 1
21362: PUSH
21363: LD_INT 2
21365: PUSH
21366: LD_INT 4
21368: PUSH
21369: LD_INT 5
21371: PUSH
21372: LD_INT 7
21374: PUSH
21375: LD_INT 11
21377: PUSH
21378: LD_INT 12
21380: PUSH
21381: LD_INT 15
21383: PUSH
21384: LD_INT 16
21386: PUSH
21387: LD_INT 20
21389: PUSH
21390: LD_INT 21
21392: PUSH
21393: LD_INT 22
21395: PUSH
21396: LD_INT 23
21398: PUSH
21399: LD_INT 25
21401: PUSH
21402: LD_INT 26
21404: PUSH
21405: LD_INT 30
21407: PUSH
21408: LD_INT 31
21410: PUSH
21411: LD_INT 32
21413: PUSH
21414: LD_INT 33
21416: PUSH
21417: LD_INT 34
21419: PUSH
21420: EMPTY
21421: LIST
21422: LIST
21423: LIST
21424: LIST
21425: LIST
21426: LIST
21427: LIST
21428: LIST
21429: LIST
21430: LIST
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: PUSH
21441: LD_INT 101
21443: PUSH
21444: LD_INT 102
21446: PUSH
21447: LD_INT 103
21449: PUSH
21450: LD_INT 106
21452: PUSH
21453: LD_INT 108
21455: PUSH
21456: LD_INT 112
21458: PUSH
21459: LD_INT 113
21461: PUSH
21462: LD_INT 114
21464: PUSH
21465: EMPTY
21466: LIST
21467: LIST
21468: LIST
21469: LIST
21470: LIST
21471: LIST
21472: LIST
21473: LIST
21474: PUSH
21475: EMPTY
21476: LIST
21477: LIST
21478: ST_TO_ADDR
21479: GO 22074
21481: LD_INT 17
21483: DOUBLE
21484: EQUAL
21485: IFTRUE 21489
21487: GO 21701
21489: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
21490: LD_ADDR_VAR 0 1
21494: PUSH
21495: LD_INT 1
21497: PUSH
21498: LD_INT 2
21500: PUSH
21501: LD_INT 3
21503: PUSH
21504: LD_INT 4
21506: PUSH
21507: LD_INT 5
21509: PUSH
21510: LD_INT 6
21512: PUSH
21513: LD_INT 7
21515: PUSH
21516: LD_INT 8
21518: PUSH
21519: LD_INT 9
21521: PUSH
21522: LD_INT 10
21524: PUSH
21525: LD_INT 11
21527: PUSH
21528: LD_INT 12
21530: PUSH
21531: LD_INT 13
21533: PUSH
21534: LD_INT 14
21536: PUSH
21537: LD_INT 15
21539: PUSH
21540: LD_INT 16
21542: PUSH
21543: LD_INT 17
21545: PUSH
21546: LD_INT 18
21548: PUSH
21549: LD_INT 19
21551: PUSH
21552: LD_INT 20
21554: PUSH
21555: LD_INT 21
21557: PUSH
21558: LD_INT 22
21560: PUSH
21561: LD_INT 23
21563: PUSH
21564: LD_INT 24
21566: PUSH
21567: LD_INT 25
21569: PUSH
21570: LD_INT 26
21572: PUSH
21573: LD_INT 27
21575: PUSH
21576: LD_INT 28
21578: PUSH
21579: LD_INT 29
21581: PUSH
21582: LD_INT 30
21584: PUSH
21585: LD_INT 31
21587: PUSH
21588: LD_INT 32
21590: PUSH
21591: LD_INT 33
21593: PUSH
21594: LD_INT 34
21596: PUSH
21597: LD_INT 36
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: LIST
21607: LIST
21608: LIST
21609: LIST
21610: LIST
21611: LIST
21612: LIST
21613: LIST
21614: LIST
21615: LIST
21616: LIST
21617: LIST
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: LIST
21623: LIST
21624: LIST
21625: LIST
21626: LIST
21627: LIST
21628: LIST
21629: LIST
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: LD_INT 101
21639: PUSH
21640: LD_INT 102
21642: PUSH
21643: LD_INT 103
21645: PUSH
21646: LD_INT 104
21648: PUSH
21649: LD_INT 105
21651: PUSH
21652: LD_INT 106
21654: PUSH
21655: LD_INT 107
21657: PUSH
21658: LD_INT 108
21660: PUSH
21661: LD_INT 109
21663: PUSH
21664: LD_INT 110
21666: PUSH
21667: LD_INT 111
21669: PUSH
21670: LD_INT 112
21672: PUSH
21673: LD_INT 113
21675: PUSH
21676: LD_INT 114
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: LIST
21683: LIST
21684: LIST
21685: LIST
21686: LIST
21687: LIST
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: LIST
21693: LIST
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: ST_TO_ADDR
21699: GO 22074
21701: LD_INT 18
21703: DOUBLE
21704: EQUAL
21705: IFTRUE 21709
21707: GO 21845
21709: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
21710: LD_ADDR_VAR 0 1
21714: PUSH
21715: LD_INT 2
21717: PUSH
21718: LD_INT 4
21720: PUSH
21721: LD_INT 5
21723: PUSH
21724: LD_INT 7
21726: PUSH
21727: LD_INT 11
21729: PUSH
21730: LD_INT 12
21732: PUSH
21733: LD_INT 15
21735: PUSH
21736: LD_INT 16
21738: PUSH
21739: LD_INT 20
21741: PUSH
21742: LD_INT 21
21744: PUSH
21745: LD_INT 22
21747: PUSH
21748: LD_INT 23
21750: PUSH
21751: LD_INT 25
21753: PUSH
21754: LD_INT 26
21756: PUSH
21757: LD_INT 30
21759: PUSH
21760: LD_INT 31
21762: PUSH
21763: LD_INT 32
21765: PUSH
21766: LD_INT 33
21768: PUSH
21769: LD_INT 34
21771: PUSH
21772: LD_INT 35
21774: PUSH
21775: LD_INT 36
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: LIST
21782: LIST
21783: LIST
21784: LIST
21785: LIST
21786: LIST
21787: LIST
21788: LIST
21789: LIST
21790: LIST
21791: LIST
21792: LIST
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: PUSH
21801: LD_INT 101
21803: PUSH
21804: LD_INT 102
21806: PUSH
21807: LD_INT 103
21809: PUSH
21810: LD_INT 106
21812: PUSH
21813: LD_INT 108
21815: PUSH
21816: LD_INT 112
21818: PUSH
21819: LD_INT 113
21821: PUSH
21822: LD_INT 114
21824: PUSH
21825: LD_INT 115
21827: PUSH
21828: EMPTY
21829: LIST
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: LIST
21836: LIST
21837: LIST
21838: PUSH
21839: EMPTY
21840: LIST
21841: LIST
21842: ST_TO_ADDR
21843: GO 22074
21845: LD_INT 19
21847: DOUBLE
21848: EQUAL
21849: IFTRUE 21853
21851: GO 22073
21853: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
21854: LD_ADDR_VAR 0 1
21858: PUSH
21859: LD_INT 1
21861: PUSH
21862: LD_INT 2
21864: PUSH
21865: LD_INT 3
21867: PUSH
21868: LD_INT 4
21870: PUSH
21871: LD_INT 5
21873: PUSH
21874: LD_INT 6
21876: PUSH
21877: LD_INT 7
21879: PUSH
21880: LD_INT 8
21882: PUSH
21883: LD_INT 9
21885: PUSH
21886: LD_INT 10
21888: PUSH
21889: LD_INT 11
21891: PUSH
21892: LD_INT 12
21894: PUSH
21895: LD_INT 13
21897: PUSH
21898: LD_INT 14
21900: PUSH
21901: LD_INT 15
21903: PUSH
21904: LD_INT 16
21906: PUSH
21907: LD_INT 17
21909: PUSH
21910: LD_INT 18
21912: PUSH
21913: LD_INT 19
21915: PUSH
21916: LD_INT 20
21918: PUSH
21919: LD_INT 21
21921: PUSH
21922: LD_INT 22
21924: PUSH
21925: LD_INT 23
21927: PUSH
21928: LD_INT 24
21930: PUSH
21931: LD_INT 25
21933: PUSH
21934: LD_INT 26
21936: PUSH
21937: LD_INT 27
21939: PUSH
21940: LD_INT 28
21942: PUSH
21943: LD_INT 29
21945: PUSH
21946: LD_INT 30
21948: PUSH
21949: LD_INT 31
21951: PUSH
21952: LD_INT 32
21954: PUSH
21955: LD_INT 33
21957: PUSH
21958: LD_INT 34
21960: PUSH
21961: LD_INT 35
21963: PUSH
21964: LD_INT 36
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: LIST
21986: LIST
21987: LIST
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: LIST
21997: LIST
21998: LIST
21999: LIST
22000: LIST
22001: LIST
22002: LIST
22003: LIST
22004: PUSH
22005: LD_INT 101
22007: PUSH
22008: LD_INT 102
22010: PUSH
22011: LD_INT 103
22013: PUSH
22014: LD_INT 104
22016: PUSH
22017: LD_INT 105
22019: PUSH
22020: LD_INT 106
22022: PUSH
22023: LD_INT 107
22025: PUSH
22026: LD_INT 108
22028: PUSH
22029: LD_INT 109
22031: PUSH
22032: LD_INT 110
22034: PUSH
22035: LD_INT 111
22037: PUSH
22038: LD_INT 112
22040: PUSH
22041: LD_INT 113
22043: PUSH
22044: LD_INT 114
22046: PUSH
22047: LD_INT 115
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: LIST
22059: LIST
22060: LIST
22061: LIST
22062: LIST
22063: LIST
22064: LIST
22065: LIST
22066: PUSH
22067: EMPTY
22068: LIST
22069: LIST
22070: ST_TO_ADDR
22071: GO 22074
22073: POP
// end else
22074: GO 22293
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
22076: LD_ADDR_VAR 0 1
22080: PUSH
22081: LD_INT 1
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: LD_INT 3
22089: PUSH
22090: LD_INT 4
22092: PUSH
22093: LD_INT 5
22095: PUSH
22096: LD_INT 6
22098: PUSH
22099: LD_INT 7
22101: PUSH
22102: LD_INT 8
22104: PUSH
22105: LD_INT 9
22107: PUSH
22108: LD_INT 10
22110: PUSH
22111: LD_INT 11
22113: PUSH
22114: LD_INT 12
22116: PUSH
22117: LD_INT 13
22119: PUSH
22120: LD_INT 14
22122: PUSH
22123: LD_INT 15
22125: PUSH
22126: LD_INT 16
22128: PUSH
22129: LD_INT 17
22131: PUSH
22132: LD_INT 18
22134: PUSH
22135: LD_INT 19
22137: PUSH
22138: LD_INT 20
22140: PUSH
22141: LD_INT 21
22143: PUSH
22144: LD_INT 22
22146: PUSH
22147: LD_INT 23
22149: PUSH
22150: LD_INT 24
22152: PUSH
22153: LD_INT 25
22155: PUSH
22156: LD_INT 26
22158: PUSH
22159: LD_INT 27
22161: PUSH
22162: LD_INT 28
22164: PUSH
22165: LD_INT 29
22167: PUSH
22168: LD_INT 30
22170: PUSH
22171: LD_INT 31
22173: PUSH
22174: LD_INT 32
22176: PUSH
22177: LD_INT 33
22179: PUSH
22180: LD_INT 34
22182: PUSH
22183: LD_INT 35
22185: PUSH
22186: LD_INT 36
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: LIST
22193: LIST
22194: LIST
22195: LIST
22196: LIST
22197: LIST
22198: LIST
22199: LIST
22200: LIST
22201: LIST
22202: LIST
22203: LIST
22204: LIST
22205: LIST
22206: LIST
22207: LIST
22208: LIST
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: LIST
22217: LIST
22218: LIST
22219: LIST
22220: LIST
22221: LIST
22222: LIST
22223: LIST
22224: LIST
22225: LIST
22226: PUSH
22227: LD_INT 101
22229: PUSH
22230: LD_INT 102
22232: PUSH
22233: LD_INT 103
22235: PUSH
22236: LD_INT 104
22238: PUSH
22239: LD_INT 105
22241: PUSH
22242: LD_INT 106
22244: PUSH
22245: LD_INT 107
22247: PUSH
22248: LD_INT 108
22250: PUSH
22251: LD_INT 109
22253: PUSH
22254: LD_INT 110
22256: PUSH
22257: LD_INT 111
22259: PUSH
22260: LD_INT 112
22262: PUSH
22263: LD_INT 113
22265: PUSH
22266: LD_INT 114
22268: PUSH
22269: LD_INT 115
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: LIST
22276: LIST
22277: LIST
22278: LIST
22279: LIST
22280: LIST
22281: LIST
22282: LIST
22283: LIST
22284: LIST
22285: LIST
22286: LIST
22287: LIST
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: ST_TO_ADDR
// if result then
22293: LD_VAR 0 1
22297: IFFALSE 22586
// begin normal :=  ;
22299: LD_ADDR_VAR 0 3
22303: PUSH
22304: LD_STRING 
22306: ST_TO_ADDR
// hardcore :=  ;
22307: LD_ADDR_VAR 0 4
22311: PUSH
22312: LD_STRING 
22314: ST_TO_ADDR
// for i = 1 to normalCounter do
22315: LD_ADDR_VAR 0 5
22319: PUSH
22320: DOUBLE
22321: LD_INT 1
22323: DEC
22324: ST_TO_ADDR
22325: LD_EXP 76
22329: PUSH
22330: FOR_TO
22331: IFFALSE 22432
// begin tmp := 0 ;
22333: LD_ADDR_VAR 0 2
22337: PUSH
22338: LD_STRING 0
22340: ST_TO_ADDR
// if result [ 1 ] then
22341: LD_VAR 0 1
22345: PUSH
22346: LD_INT 1
22348: ARRAY
22349: IFFALSE 22414
// if result [ 1 ] [ 1 ] = i then
22351: LD_VAR 0 1
22355: PUSH
22356: LD_INT 1
22358: ARRAY
22359: PUSH
22360: LD_INT 1
22362: ARRAY
22363: PUSH
22364: LD_VAR 0 5
22368: EQUAL
22369: IFFALSE 22414
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
22371: LD_ADDR_VAR 0 1
22375: PUSH
22376: LD_VAR 0 1
22380: PPUSH
22381: LD_INT 1
22383: PPUSH
22384: LD_VAR 0 1
22388: PUSH
22389: LD_INT 1
22391: ARRAY
22392: PPUSH
22393: LD_INT 1
22395: PPUSH
22396: CALL_OW 3
22400: PPUSH
22401: CALL_OW 1
22405: ST_TO_ADDR
// tmp := 1 ;
22406: LD_ADDR_VAR 0 2
22410: PUSH
22411: LD_STRING 1
22413: ST_TO_ADDR
// end ; normal := normal & tmp ;
22414: LD_ADDR_VAR 0 3
22418: PUSH
22419: LD_VAR 0 3
22423: PUSH
22424: LD_VAR 0 2
22428: STR
22429: ST_TO_ADDR
// end ;
22430: GO 22330
22432: POP
22433: POP
// for i = 1 to hardcoreCounter do
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: DOUBLE
22440: LD_INT 1
22442: DEC
22443: ST_TO_ADDR
22444: LD_EXP 77
22448: PUSH
22449: FOR_TO
22450: IFFALSE 22555
// begin tmp := 0 ;
22452: LD_ADDR_VAR 0 2
22456: PUSH
22457: LD_STRING 0
22459: ST_TO_ADDR
// if result [ 2 ] then
22460: LD_VAR 0 1
22464: PUSH
22465: LD_INT 2
22467: ARRAY
22468: IFFALSE 22537
// if result [ 2 ] [ 1 ] = 100 + i then
22470: LD_VAR 0 1
22474: PUSH
22475: LD_INT 2
22477: ARRAY
22478: PUSH
22479: LD_INT 1
22481: ARRAY
22482: PUSH
22483: LD_INT 100
22485: PUSH
22486: LD_VAR 0 5
22490: PLUS
22491: EQUAL
22492: IFFALSE 22537
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
22494: LD_ADDR_VAR 0 1
22498: PUSH
22499: LD_VAR 0 1
22503: PPUSH
22504: LD_INT 2
22506: PPUSH
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 2
22514: ARRAY
22515: PPUSH
22516: LD_INT 1
22518: PPUSH
22519: CALL_OW 3
22523: PPUSH
22524: CALL_OW 1
22528: ST_TO_ADDR
// tmp := 1 ;
22529: LD_ADDR_VAR 0 2
22533: PUSH
22534: LD_STRING 1
22536: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
22537: LD_ADDR_VAR 0 4
22541: PUSH
22542: LD_VAR 0 4
22546: PUSH
22547: LD_VAR 0 2
22551: STR
22552: ST_TO_ADDR
// end ;
22553: GO 22449
22555: POP
22556: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
22557: LD_STRING getStreamItemsFromMission("
22559: PUSH
22560: LD_VAR 0 3
22564: STR
22565: PUSH
22566: LD_STRING ","
22568: STR
22569: PUSH
22570: LD_VAR 0 4
22574: STR
22575: PUSH
22576: LD_STRING ")
22578: STR
22579: PPUSH
22580: CALL_OW 559
// end else
22584: GO 22593
// ToLua ( getStreamItemsFromMission("","") ) ;
22586: LD_STRING getStreamItemsFromMission("","")
22588: PPUSH
22589: CALL_OW 559
// end ;
22593: LD_VAR 0 1
22597: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
22598: LD_VAR 0 2
22602: PUSH
22603: LD_INT 100
22605: EQUAL
22606: IFFALSE 23555
// begin if not StreamModeActive then
22608: LD_EXP 75
22612: NOT
22613: IFFALSE 22623
// StreamModeActive := true ;
22615: LD_ADDR_EXP 75
22619: PUSH
22620: LD_INT 1
22622: ST_TO_ADDR
// if p3 = 0 then
22623: LD_VAR 0 3
22627: PUSH
22628: LD_INT 0
22630: EQUAL
22631: IFFALSE 22637
// InitStreamMode ;
22633: CALL 18676 0 0
// if p3 = 1 then
22637: LD_VAR 0 3
22641: PUSH
22642: LD_INT 1
22644: EQUAL
22645: IFFALSE 22655
// sRocket := true ;
22647: LD_ADDR_EXP 80
22651: PUSH
22652: LD_INT 1
22654: ST_TO_ADDR
// if p3 = 2 then
22655: LD_VAR 0 3
22659: PUSH
22660: LD_INT 2
22662: EQUAL
22663: IFFALSE 22673
// sSpeed := true ;
22665: LD_ADDR_EXP 79
22669: PUSH
22670: LD_INT 1
22672: ST_TO_ADDR
// if p3 = 3 then
22673: LD_VAR 0 3
22677: PUSH
22678: LD_INT 3
22680: EQUAL
22681: IFFALSE 22691
// sEngine := true ;
22683: LD_ADDR_EXP 81
22687: PUSH
22688: LD_INT 1
22690: ST_TO_ADDR
// if p3 = 4 then
22691: LD_VAR 0 3
22695: PUSH
22696: LD_INT 4
22698: EQUAL
22699: IFFALSE 22709
// sSpec := true ;
22701: LD_ADDR_EXP 78
22705: PUSH
22706: LD_INT 1
22708: ST_TO_ADDR
// if p3 = 5 then
22709: LD_VAR 0 3
22713: PUSH
22714: LD_INT 5
22716: EQUAL
22717: IFFALSE 22727
// sLevel := true ;
22719: LD_ADDR_EXP 82
22723: PUSH
22724: LD_INT 1
22726: ST_TO_ADDR
// if p3 = 6 then
22727: LD_VAR 0 3
22731: PUSH
22732: LD_INT 6
22734: EQUAL
22735: IFFALSE 22745
// sArmoury := true ;
22737: LD_ADDR_EXP 83
22741: PUSH
22742: LD_INT 1
22744: ST_TO_ADDR
// if p3 = 7 then
22745: LD_VAR 0 3
22749: PUSH
22750: LD_INT 7
22752: EQUAL
22753: IFFALSE 22763
// sRadar := true ;
22755: LD_ADDR_EXP 84
22759: PUSH
22760: LD_INT 1
22762: ST_TO_ADDR
// if p3 = 8 then
22763: LD_VAR 0 3
22767: PUSH
22768: LD_INT 8
22770: EQUAL
22771: IFFALSE 22781
// sBunker := true ;
22773: LD_ADDR_EXP 85
22777: PUSH
22778: LD_INT 1
22780: ST_TO_ADDR
// if p3 = 9 then
22781: LD_VAR 0 3
22785: PUSH
22786: LD_INT 9
22788: EQUAL
22789: IFFALSE 22799
// sHack := true ;
22791: LD_ADDR_EXP 86
22795: PUSH
22796: LD_INT 1
22798: ST_TO_ADDR
// if p3 = 10 then
22799: LD_VAR 0 3
22803: PUSH
22804: LD_INT 10
22806: EQUAL
22807: IFFALSE 22817
// sFire := true ;
22809: LD_ADDR_EXP 87
22813: PUSH
22814: LD_INT 1
22816: ST_TO_ADDR
// if p3 = 11 then
22817: LD_VAR 0 3
22821: PUSH
22822: LD_INT 11
22824: EQUAL
22825: IFFALSE 22835
// sRefresh := true ;
22827: LD_ADDR_EXP 88
22831: PUSH
22832: LD_INT 1
22834: ST_TO_ADDR
// if p3 = 12 then
22835: LD_VAR 0 3
22839: PUSH
22840: LD_INT 12
22842: EQUAL
22843: IFFALSE 22853
// sExp := true ;
22845: LD_ADDR_EXP 89
22849: PUSH
22850: LD_INT 1
22852: ST_TO_ADDR
// if p3 = 13 then
22853: LD_VAR 0 3
22857: PUSH
22858: LD_INT 13
22860: EQUAL
22861: IFFALSE 22871
// sDepot := true ;
22863: LD_ADDR_EXP 90
22867: PUSH
22868: LD_INT 1
22870: ST_TO_ADDR
// if p3 = 14 then
22871: LD_VAR 0 3
22875: PUSH
22876: LD_INT 14
22878: EQUAL
22879: IFFALSE 22889
// sFlag := true ;
22881: LD_ADDR_EXP 91
22885: PUSH
22886: LD_INT 1
22888: ST_TO_ADDR
// if p3 = 15 then
22889: LD_VAR 0 3
22893: PUSH
22894: LD_INT 15
22896: EQUAL
22897: IFFALSE 22907
// sKamikadze := true ;
22899: LD_ADDR_EXP 99
22903: PUSH
22904: LD_INT 1
22906: ST_TO_ADDR
// if p3 = 16 then
22907: LD_VAR 0 3
22911: PUSH
22912: LD_INT 16
22914: EQUAL
22915: IFFALSE 22925
// sTroll := true ;
22917: LD_ADDR_EXP 100
22921: PUSH
22922: LD_INT 1
22924: ST_TO_ADDR
// if p3 = 17 then
22925: LD_VAR 0 3
22929: PUSH
22930: LD_INT 17
22932: EQUAL
22933: IFFALSE 22943
// sSlow := true ;
22935: LD_ADDR_EXP 101
22939: PUSH
22940: LD_INT 1
22942: ST_TO_ADDR
// if p3 = 18 then
22943: LD_VAR 0 3
22947: PUSH
22948: LD_INT 18
22950: EQUAL
22951: IFFALSE 22961
// sLack := true ;
22953: LD_ADDR_EXP 102
22957: PUSH
22958: LD_INT 1
22960: ST_TO_ADDR
// if p3 = 19 then
22961: LD_VAR 0 3
22965: PUSH
22966: LD_INT 19
22968: EQUAL
22969: IFFALSE 22979
// sTank := true ;
22971: LD_ADDR_EXP 104
22975: PUSH
22976: LD_INT 1
22978: ST_TO_ADDR
// if p3 = 20 then
22979: LD_VAR 0 3
22983: PUSH
22984: LD_INT 20
22986: EQUAL
22987: IFFALSE 22997
// sRemote := true ;
22989: LD_ADDR_EXP 105
22993: PUSH
22994: LD_INT 1
22996: ST_TO_ADDR
// if p3 = 21 then
22997: LD_VAR 0 3
23001: PUSH
23002: LD_INT 21
23004: EQUAL
23005: IFFALSE 23015
// sPowell := true ;
23007: LD_ADDR_EXP 106
23011: PUSH
23012: LD_INT 1
23014: ST_TO_ADDR
// if p3 = 22 then
23015: LD_VAR 0 3
23019: PUSH
23020: LD_INT 22
23022: EQUAL
23023: IFFALSE 23033
// sTeleport := true ;
23025: LD_ADDR_EXP 109
23029: PUSH
23030: LD_INT 1
23032: ST_TO_ADDR
// if p3 = 23 then
23033: LD_VAR 0 3
23037: PUSH
23038: LD_INT 23
23040: EQUAL
23041: IFFALSE 23051
// sOilTower := true ;
23043: LD_ADDR_EXP 111
23047: PUSH
23048: LD_INT 1
23050: ST_TO_ADDR
// if p3 = 24 then
23051: LD_VAR 0 3
23055: PUSH
23056: LD_INT 24
23058: EQUAL
23059: IFFALSE 23069
// sShovel := true ;
23061: LD_ADDR_EXP 112
23065: PUSH
23066: LD_INT 1
23068: ST_TO_ADDR
// if p3 = 25 then
23069: LD_VAR 0 3
23073: PUSH
23074: LD_INT 25
23076: EQUAL
23077: IFFALSE 23087
// sSheik := true ;
23079: LD_ADDR_EXP 113
23083: PUSH
23084: LD_INT 1
23086: ST_TO_ADDR
// if p3 = 26 then
23087: LD_VAR 0 3
23091: PUSH
23092: LD_INT 26
23094: EQUAL
23095: IFFALSE 23105
// sEarthquake := true ;
23097: LD_ADDR_EXP 115
23101: PUSH
23102: LD_INT 1
23104: ST_TO_ADDR
// if p3 = 27 then
23105: LD_VAR 0 3
23109: PUSH
23110: LD_INT 27
23112: EQUAL
23113: IFFALSE 23123
// sAI := true ;
23115: LD_ADDR_EXP 116
23119: PUSH
23120: LD_INT 1
23122: ST_TO_ADDR
// if p3 = 28 then
23123: LD_VAR 0 3
23127: PUSH
23128: LD_INT 28
23130: EQUAL
23131: IFFALSE 23141
// sCargo := true ;
23133: LD_ADDR_EXP 119
23137: PUSH
23138: LD_INT 1
23140: ST_TO_ADDR
// if p3 = 29 then
23141: LD_VAR 0 3
23145: PUSH
23146: LD_INT 29
23148: EQUAL
23149: IFFALSE 23159
// sDLaser := true ;
23151: LD_ADDR_EXP 120
23155: PUSH
23156: LD_INT 1
23158: ST_TO_ADDR
// if p3 = 30 then
23159: LD_VAR 0 3
23163: PUSH
23164: LD_INT 30
23166: EQUAL
23167: IFFALSE 23177
// sExchange := true ;
23169: LD_ADDR_EXP 121
23173: PUSH
23174: LD_INT 1
23176: ST_TO_ADDR
// if p3 = 31 then
23177: LD_VAR 0 3
23181: PUSH
23182: LD_INT 31
23184: EQUAL
23185: IFFALSE 23195
// sFac := true ;
23187: LD_ADDR_EXP 122
23191: PUSH
23192: LD_INT 1
23194: ST_TO_ADDR
// if p3 = 32 then
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 32
23202: EQUAL
23203: IFFALSE 23213
// sPower := true ;
23205: LD_ADDR_EXP 123
23209: PUSH
23210: LD_INT 1
23212: ST_TO_ADDR
// if p3 = 33 then
23213: LD_VAR 0 3
23217: PUSH
23218: LD_INT 33
23220: EQUAL
23221: IFFALSE 23231
// sRandom := true ;
23223: LD_ADDR_EXP 124
23227: PUSH
23228: LD_INT 1
23230: ST_TO_ADDR
// if p3 = 34 then
23231: LD_VAR 0 3
23235: PUSH
23236: LD_INT 34
23238: EQUAL
23239: IFFALSE 23249
// sShield := true ;
23241: LD_ADDR_EXP 125
23245: PUSH
23246: LD_INT 1
23248: ST_TO_ADDR
// if p3 = 35 then
23249: LD_VAR 0 3
23253: PUSH
23254: LD_INT 35
23256: EQUAL
23257: IFFALSE 23267
// sTime := true ;
23259: LD_ADDR_EXP 126
23263: PUSH
23264: LD_INT 1
23266: ST_TO_ADDR
// if p3 = 36 then
23267: LD_VAR 0 3
23271: PUSH
23272: LD_INT 36
23274: EQUAL
23275: IFFALSE 23285
// sTools := true ;
23277: LD_ADDR_EXP 127
23281: PUSH
23282: LD_INT 1
23284: ST_TO_ADDR
// if p3 = 101 then
23285: LD_VAR 0 3
23289: PUSH
23290: LD_INT 101
23292: EQUAL
23293: IFFALSE 23303
// sSold := true ;
23295: LD_ADDR_EXP 92
23299: PUSH
23300: LD_INT 1
23302: ST_TO_ADDR
// if p3 = 102 then
23303: LD_VAR 0 3
23307: PUSH
23308: LD_INT 102
23310: EQUAL
23311: IFFALSE 23321
// sDiff := true ;
23313: LD_ADDR_EXP 93
23317: PUSH
23318: LD_INT 1
23320: ST_TO_ADDR
// if p3 = 103 then
23321: LD_VAR 0 3
23325: PUSH
23326: LD_INT 103
23328: EQUAL
23329: IFFALSE 23339
// sFog := true ;
23331: LD_ADDR_EXP 96
23335: PUSH
23336: LD_INT 1
23338: ST_TO_ADDR
// if p3 = 104 then
23339: LD_VAR 0 3
23343: PUSH
23344: LD_INT 104
23346: EQUAL
23347: IFFALSE 23357
// sReset := true ;
23349: LD_ADDR_EXP 97
23353: PUSH
23354: LD_INT 1
23356: ST_TO_ADDR
// if p3 = 105 then
23357: LD_VAR 0 3
23361: PUSH
23362: LD_INT 105
23364: EQUAL
23365: IFFALSE 23375
// sSun := true ;
23367: LD_ADDR_EXP 98
23371: PUSH
23372: LD_INT 1
23374: ST_TO_ADDR
// if p3 = 106 then
23375: LD_VAR 0 3
23379: PUSH
23380: LD_INT 106
23382: EQUAL
23383: IFFALSE 23393
// sTiger := true ;
23385: LD_ADDR_EXP 94
23389: PUSH
23390: LD_INT 1
23392: ST_TO_ADDR
// if p3 = 107 then
23393: LD_VAR 0 3
23397: PUSH
23398: LD_INT 107
23400: EQUAL
23401: IFFALSE 23411
// sBomb := true ;
23403: LD_ADDR_EXP 95
23407: PUSH
23408: LD_INT 1
23410: ST_TO_ADDR
// if p3 = 108 then
23411: LD_VAR 0 3
23415: PUSH
23416: LD_INT 108
23418: EQUAL
23419: IFFALSE 23429
// sWound := true ;
23421: LD_ADDR_EXP 103
23425: PUSH
23426: LD_INT 1
23428: ST_TO_ADDR
// if p3 = 109 then
23429: LD_VAR 0 3
23433: PUSH
23434: LD_INT 109
23436: EQUAL
23437: IFFALSE 23447
// sBetray := true ;
23439: LD_ADDR_EXP 107
23443: PUSH
23444: LD_INT 1
23446: ST_TO_ADDR
// if p3 = 110 then
23447: LD_VAR 0 3
23451: PUSH
23452: LD_INT 110
23454: EQUAL
23455: IFFALSE 23465
// sContamin := true ;
23457: LD_ADDR_EXP 108
23461: PUSH
23462: LD_INT 1
23464: ST_TO_ADDR
// if p3 = 111 then
23465: LD_VAR 0 3
23469: PUSH
23470: LD_INT 111
23472: EQUAL
23473: IFFALSE 23483
// sOil := true ;
23475: LD_ADDR_EXP 110
23479: PUSH
23480: LD_INT 1
23482: ST_TO_ADDR
// if p3 = 112 then
23483: LD_VAR 0 3
23487: PUSH
23488: LD_INT 112
23490: EQUAL
23491: IFFALSE 23501
// sStu := true ;
23493: LD_ADDR_EXP 114
23497: PUSH
23498: LD_INT 1
23500: ST_TO_ADDR
// if p3 = 113 then
23501: LD_VAR 0 3
23505: PUSH
23506: LD_INT 113
23508: EQUAL
23509: IFFALSE 23519
// sBazooka := true ;
23511: LD_ADDR_EXP 117
23515: PUSH
23516: LD_INT 1
23518: ST_TO_ADDR
// if p3 = 114 then
23519: LD_VAR 0 3
23523: PUSH
23524: LD_INT 114
23526: EQUAL
23527: IFFALSE 23537
// sMortar := true ;
23529: LD_ADDR_EXP 118
23533: PUSH
23534: LD_INT 1
23536: ST_TO_ADDR
// if p3 = 115 then
23537: LD_VAR 0 3
23541: PUSH
23542: LD_INT 115
23544: EQUAL
23545: IFFALSE 23555
// sRanger := true ;
23547: LD_ADDR_EXP 128
23551: PUSH
23552: LD_INT 1
23554: ST_TO_ADDR
// end ; end ;
23555: PPOPN 6
23557: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
23558: LD_EXP 75
23562: PUSH
23563: LD_EXP 80
23567: AND
23568: IFFALSE 23692
23570: GO 23572
23572: DISABLE
23573: LD_INT 0
23575: PPUSH
23576: PPUSH
// begin enable ;
23577: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
23578: LD_ADDR_VAR 0 2
23582: PUSH
23583: LD_INT 22
23585: PUSH
23586: LD_OWVAR 2
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PUSH
23595: LD_INT 2
23597: PUSH
23598: LD_INT 34
23600: PUSH
23601: LD_INT 7
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: LD_INT 34
23610: PUSH
23611: LD_INT 45
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: LD_INT 34
23620: PUSH
23621: LD_INT 28
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PUSH
23628: LD_INT 34
23630: PUSH
23631: LD_INT 47
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PPUSH
23649: CALL_OW 69
23653: ST_TO_ADDR
// if not tmp then
23654: LD_VAR 0 2
23658: NOT
23659: IFFALSE 23663
// exit ;
23661: GO 23692
// for i in tmp do
23663: LD_ADDR_VAR 0 1
23667: PUSH
23668: LD_VAR 0 2
23672: PUSH
23673: FOR_IN
23674: IFFALSE 23690
// begin SetLives ( i , 0 ) ;
23676: LD_VAR 0 1
23680: PPUSH
23681: LD_INT 0
23683: PPUSH
23684: CALL_OW 234
// end ;
23688: GO 23673
23690: POP
23691: POP
// end ;
23692: PPOPN 2
23694: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
23695: LD_EXP 75
23699: PUSH
23700: LD_EXP 81
23704: AND
23705: IFFALSE 23789
23707: GO 23709
23709: DISABLE
23710: LD_INT 0
23712: PPUSH
23713: PPUSH
// begin enable ;
23714: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
23715: LD_ADDR_VAR 0 2
23719: PUSH
23720: LD_INT 22
23722: PUSH
23723: LD_OWVAR 2
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PUSH
23732: LD_INT 32
23734: PUSH
23735: LD_INT 3
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: PPUSH
23746: CALL_OW 69
23750: ST_TO_ADDR
// if not tmp then
23751: LD_VAR 0 2
23755: NOT
23756: IFFALSE 23760
// exit ;
23758: GO 23789
// for i in tmp do
23760: LD_ADDR_VAR 0 1
23764: PUSH
23765: LD_VAR 0 2
23769: PUSH
23770: FOR_IN
23771: IFFALSE 23787
// begin SetLives ( i , 0 ) ;
23773: LD_VAR 0 1
23777: PPUSH
23778: LD_INT 0
23780: PPUSH
23781: CALL_OW 234
// end ;
23785: GO 23770
23787: POP
23788: POP
// end ;
23789: PPOPN 2
23791: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
23792: LD_EXP 75
23796: PUSH
23797: LD_EXP 78
23801: AND
23802: IFFALSE 23895
23804: GO 23806
23806: DISABLE
23807: LD_INT 0
23809: PPUSH
// begin enable ;
23810: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
23811: LD_ADDR_VAR 0 1
23815: PUSH
23816: LD_INT 22
23818: PUSH
23819: LD_OWVAR 2
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PUSH
23828: LD_INT 2
23830: PUSH
23831: LD_INT 25
23833: PUSH
23834: LD_INT 5
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PUSH
23841: LD_INT 25
23843: PUSH
23844: LD_INT 9
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PUSH
23851: LD_INT 25
23853: PUSH
23854: LD_INT 8
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: LIST
23865: LIST
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PPUSH
23871: CALL_OW 69
23875: PUSH
23876: FOR_IN
23877: IFFALSE 23893
// begin SetClass ( i , 1 ) ;
23879: LD_VAR 0 1
23883: PPUSH
23884: LD_INT 1
23886: PPUSH
23887: CALL_OW 336
// end ;
23891: GO 23876
23893: POP
23894: POP
// end ;
23895: PPOPN 1
23897: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
23898: LD_EXP 75
23902: PUSH
23903: LD_EXP 79
23907: AND
23908: PUSH
23909: LD_OWVAR 65
23913: PUSH
23914: LD_INT 7
23916: LESS
23917: AND
23918: IFFALSE 23932
23920: GO 23922
23922: DISABLE
// begin enable ;
23923: ENABLE
// game_speed := 7 ;
23924: LD_ADDR_OWVAR 65
23928: PUSH
23929: LD_INT 7
23931: ST_TO_ADDR
// end ;
23932: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
23933: LD_EXP 75
23937: PUSH
23938: LD_EXP 82
23942: AND
23943: IFFALSE 24145
23945: GO 23947
23947: DISABLE
23948: LD_INT 0
23950: PPUSH
23951: PPUSH
23952: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
23953: LD_ADDR_VAR 0 3
23957: PUSH
23958: LD_INT 81
23960: PUSH
23961: LD_OWVAR 2
23965: PUSH
23966: EMPTY
23967: LIST
23968: LIST
23969: PUSH
23970: LD_INT 21
23972: PUSH
23973: LD_INT 1
23975: PUSH
23976: EMPTY
23977: LIST
23978: LIST
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PPUSH
23984: CALL_OW 69
23988: ST_TO_ADDR
// if not tmp then
23989: LD_VAR 0 3
23993: NOT
23994: IFFALSE 23998
// exit ;
23996: GO 24145
// if tmp > 5 then
23998: LD_VAR 0 3
24002: PUSH
24003: LD_INT 5
24005: GREATER
24006: IFFALSE 24018
// k := 5 else
24008: LD_ADDR_VAR 0 2
24012: PUSH
24013: LD_INT 5
24015: ST_TO_ADDR
24016: GO 24028
// k := tmp ;
24018: LD_ADDR_VAR 0 2
24022: PUSH
24023: LD_VAR 0 3
24027: ST_TO_ADDR
// for i := 1 to k do
24028: LD_ADDR_VAR 0 1
24032: PUSH
24033: DOUBLE
24034: LD_INT 1
24036: DEC
24037: ST_TO_ADDR
24038: LD_VAR 0 2
24042: PUSH
24043: FOR_TO
24044: IFFALSE 24143
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
24046: LD_VAR 0 3
24050: PUSH
24051: LD_VAR 0 1
24055: ARRAY
24056: PPUSH
24057: LD_VAR 0 1
24061: PUSH
24062: LD_INT 4
24064: MOD
24065: PUSH
24066: LD_INT 1
24068: PLUS
24069: PPUSH
24070: CALL_OW 259
24074: PUSH
24075: LD_INT 10
24077: LESS
24078: IFFALSE 24141
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
24080: LD_VAR 0 3
24084: PUSH
24085: LD_VAR 0 1
24089: ARRAY
24090: PPUSH
24091: LD_VAR 0 1
24095: PUSH
24096: LD_INT 4
24098: MOD
24099: PUSH
24100: LD_INT 1
24102: PLUS
24103: PPUSH
24104: LD_VAR 0 3
24108: PUSH
24109: LD_VAR 0 1
24113: ARRAY
24114: PPUSH
24115: LD_VAR 0 1
24119: PUSH
24120: LD_INT 4
24122: MOD
24123: PUSH
24124: LD_INT 1
24126: PLUS
24127: PPUSH
24128: CALL_OW 259
24132: PUSH
24133: LD_INT 1
24135: PLUS
24136: PPUSH
24137: CALL_OW 237
24141: GO 24043
24143: POP
24144: POP
// end ;
24145: PPOPN 3
24147: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
24148: LD_EXP 75
24152: PUSH
24153: LD_EXP 83
24157: AND
24158: IFFALSE 24178
24160: GO 24162
24162: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
24163: LD_INT 4
24165: PPUSH
24166: LD_OWVAR 2
24170: PPUSH
24171: LD_INT 0
24173: PPUSH
24174: CALL_OW 324
24178: END
// every 0 0$1 trigger StreamModeActive and sShovel do
24179: LD_EXP 75
24183: PUSH
24184: LD_EXP 112
24188: AND
24189: IFFALSE 24209
24191: GO 24193
24193: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
24194: LD_INT 19
24196: PPUSH
24197: LD_OWVAR 2
24201: PPUSH
24202: LD_INT 0
24204: PPUSH
24205: CALL_OW 324
24209: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
24210: LD_EXP 75
24214: PUSH
24215: LD_EXP 84
24219: AND
24220: IFFALSE 24322
24222: GO 24224
24224: DISABLE
24225: LD_INT 0
24227: PPUSH
24228: PPUSH
// begin enable ;
24229: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
24230: LD_ADDR_VAR 0 2
24234: PUSH
24235: LD_INT 22
24237: PUSH
24238: LD_OWVAR 2
24242: PUSH
24243: EMPTY
24244: LIST
24245: LIST
24246: PUSH
24247: LD_INT 2
24249: PUSH
24250: LD_INT 34
24252: PUSH
24253: LD_INT 11
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: LD_INT 34
24262: PUSH
24263: LD_INT 30
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PPUSH
24279: CALL_OW 69
24283: ST_TO_ADDR
// if not tmp then
24284: LD_VAR 0 2
24288: NOT
24289: IFFALSE 24293
// exit ;
24291: GO 24322
// for i in tmp do
24293: LD_ADDR_VAR 0 1
24297: PUSH
24298: LD_VAR 0 2
24302: PUSH
24303: FOR_IN
24304: IFFALSE 24320
// begin SetLives ( i , 0 ) ;
24306: LD_VAR 0 1
24310: PPUSH
24311: LD_INT 0
24313: PPUSH
24314: CALL_OW 234
// end ;
24318: GO 24303
24320: POP
24321: POP
// end ;
24322: PPOPN 2
24324: END
// every 0 0$1 trigger StreamModeActive and sBunker do
24325: LD_EXP 75
24329: PUSH
24330: LD_EXP 85
24334: AND
24335: IFFALSE 24355
24337: GO 24339
24339: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
24340: LD_INT 32
24342: PPUSH
24343: LD_OWVAR 2
24347: PPUSH
24348: LD_INT 0
24350: PPUSH
24351: CALL_OW 324
24355: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
24356: LD_EXP 75
24360: PUSH
24361: LD_EXP 86
24365: AND
24366: IFFALSE 24547
24368: GO 24370
24370: DISABLE
24371: LD_INT 0
24373: PPUSH
24374: PPUSH
24375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
24376: LD_ADDR_VAR 0 2
24380: PUSH
24381: LD_INT 22
24383: PUSH
24384: LD_OWVAR 2
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: PUSH
24393: LD_INT 33
24395: PUSH
24396: LD_INT 3
24398: PUSH
24399: EMPTY
24400: LIST
24401: LIST
24402: PUSH
24403: EMPTY
24404: LIST
24405: LIST
24406: PPUSH
24407: CALL_OW 69
24411: ST_TO_ADDR
// if not tmp then
24412: LD_VAR 0 2
24416: NOT
24417: IFFALSE 24421
// exit ;
24419: GO 24547
// side := 0 ;
24421: LD_ADDR_VAR 0 3
24425: PUSH
24426: LD_INT 0
24428: ST_TO_ADDR
// for i := 1 to 8 do
24429: LD_ADDR_VAR 0 1
24433: PUSH
24434: DOUBLE
24435: LD_INT 1
24437: DEC
24438: ST_TO_ADDR
24439: LD_INT 8
24441: PUSH
24442: FOR_TO
24443: IFFALSE 24491
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
24445: LD_OWVAR 2
24449: PUSH
24450: LD_VAR 0 1
24454: NONEQUAL
24455: PUSH
24456: LD_OWVAR 2
24460: PPUSH
24461: LD_VAR 0 1
24465: PPUSH
24466: CALL_OW 81
24470: PUSH
24471: LD_INT 2
24473: EQUAL
24474: AND
24475: IFFALSE 24489
// begin side := i ;
24477: LD_ADDR_VAR 0 3
24481: PUSH
24482: LD_VAR 0 1
24486: ST_TO_ADDR
// break ;
24487: GO 24491
// end ;
24489: GO 24442
24491: POP
24492: POP
// if not side then
24493: LD_VAR 0 3
24497: NOT
24498: IFFALSE 24502
// exit ;
24500: GO 24547
// for i := 1 to tmp do
24502: LD_ADDR_VAR 0 1
24506: PUSH
24507: DOUBLE
24508: LD_INT 1
24510: DEC
24511: ST_TO_ADDR
24512: LD_VAR 0 2
24516: PUSH
24517: FOR_TO
24518: IFFALSE 24545
// if Prob ( 60 ) then
24520: LD_INT 60
24522: PPUSH
24523: CALL_OW 13
24527: IFFALSE 24543
// SetSide ( i , side ) ;
24529: LD_VAR 0 1
24533: PPUSH
24534: LD_VAR 0 3
24538: PPUSH
24539: CALL_OW 235
24543: GO 24517
24545: POP
24546: POP
// end ;
24547: PPOPN 3
24549: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
24550: LD_EXP 75
24554: PUSH
24555: LD_EXP 88
24559: AND
24560: IFFALSE 24679
24562: GO 24564
24564: DISABLE
24565: LD_INT 0
24567: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
24568: LD_ADDR_VAR 0 1
24572: PUSH
24573: LD_INT 22
24575: PUSH
24576: LD_OWVAR 2
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: PUSH
24585: LD_INT 21
24587: PUSH
24588: LD_INT 1
24590: PUSH
24591: EMPTY
24592: LIST
24593: LIST
24594: PUSH
24595: LD_INT 3
24597: PUSH
24598: LD_INT 23
24600: PUSH
24601: LD_INT 0
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: EMPTY
24613: LIST
24614: LIST
24615: LIST
24616: PPUSH
24617: CALL_OW 69
24621: PUSH
24622: FOR_IN
24623: IFFALSE 24677
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
24625: LD_VAR 0 1
24629: PPUSH
24630: CALL_OW 257
24634: PUSH
24635: LD_INT 1
24637: PUSH
24638: LD_INT 2
24640: PUSH
24641: LD_INT 3
24643: PUSH
24644: LD_INT 4
24646: PUSH
24647: EMPTY
24648: LIST
24649: LIST
24650: LIST
24651: LIST
24652: IN
24653: IFFALSE 24675
// SetClass ( un , rand ( 1 , 4 ) ) ;
24655: LD_VAR 0 1
24659: PPUSH
24660: LD_INT 1
24662: PPUSH
24663: LD_INT 4
24665: PPUSH
24666: CALL_OW 12
24670: PPUSH
24671: CALL_OW 336
24675: GO 24622
24677: POP
24678: POP
// end ;
24679: PPOPN 1
24681: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
24682: LD_EXP 75
24686: PUSH
24687: LD_EXP 87
24691: AND
24692: IFFALSE 24771
24694: GO 24696
24696: DISABLE
24697: LD_INT 0
24699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24700: LD_ADDR_VAR 0 1
24704: PUSH
24705: LD_INT 22
24707: PUSH
24708: LD_OWVAR 2
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 21
24719: PUSH
24720: LD_INT 3
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PPUSH
24731: CALL_OW 69
24735: ST_TO_ADDR
// if not tmp then
24736: LD_VAR 0 1
24740: NOT
24741: IFFALSE 24745
// exit ;
24743: GO 24771
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
24745: LD_VAR 0 1
24749: PUSH
24750: LD_INT 1
24752: PPUSH
24753: LD_VAR 0 1
24757: PPUSH
24758: CALL_OW 12
24762: ARRAY
24763: PPUSH
24764: LD_INT 100
24766: PPUSH
24767: CALL_OW 234
// end ;
24771: PPOPN 1
24773: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
24774: LD_EXP 75
24778: PUSH
24779: LD_EXP 89
24783: AND
24784: IFFALSE 24882
24786: GO 24788
24788: DISABLE
24789: LD_INT 0
24791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24792: LD_ADDR_VAR 0 1
24796: PUSH
24797: LD_INT 22
24799: PUSH
24800: LD_OWVAR 2
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 21
24811: PUSH
24812: LD_INT 1
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: PPUSH
24823: CALL_OW 69
24827: ST_TO_ADDR
// if not tmp then
24828: LD_VAR 0 1
24832: NOT
24833: IFFALSE 24837
// exit ;
24835: GO 24882
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
24837: LD_VAR 0 1
24841: PUSH
24842: LD_INT 1
24844: PPUSH
24845: LD_VAR 0 1
24849: PPUSH
24850: CALL_OW 12
24854: ARRAY
24855: PPUSH
24856: LD_INT 1
24858: PPUSH
24859: LD_INT 4
24861: PPUSH
24862: CALL_OW 12
24866: PPUSH
24867: LD_INT 3000
24869: PPUSH
24870: LD_INT 9000
24872: PPUSH
24873: CALL_OW 12
24877: PPUSH
24878: CALL_OW 492
// end ;
24882: PPOPN 1
24884: END
// every 0 0$1 trigger StreamModeActive and sDepot do
24885: LD_EXP 75
24889: PUSH
24890: LD_EXP 90
24894: AND
24895: IFFALSE 24915
24897: GO 24899
24899: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
24900: LD_INT 1
24902: PPUSH
24903: LD_OWVAR 2
24907: PPUSH
24908: LD_INT 0
24910: PPUSH
24911: CALL_OW 324
24915: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
24916: LD_EXP 75
24920: PUSH
24921: LD_EXP 91
24925: AND
24926: IFFALSE 25009
24928: GO 24930
24930: DISABLE
24931: LD_INT 0
24933: PPUSH
24934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
24935: LD_ADDR_VAR 0 2
24939: PUSH
24940: LD_INT 22
24942: PUSH
24943: LD_OWVAR 2
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: LD_INT 21
24954: PUSH
24955: LD_INT 3
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: PUSH
24962: EMPTY
24963: LIST
24964: LIST
24965: PPUSH
24966: CALL_OW 69
24970: ST_TO_ADDR
// if not tmp then
24971: LD_VAR 0 2
24975: NOT
24976: IFFALSE 24980
// exit ;
24978: GO 25009
// for i in tmp do
24980: LD_ADDR_VAR 0 1
24984: PUSH
24985: LD_VAR 0 2
24989: PUSH
24990: FOR_IN
24991: IFFALSE 25007
// SetBLevel ( i , 10 ) ;
24993: LD_VAR 0 1
24997: PPUSH
24998: LD_INT 10
25000: PPUSH
25001: CALL_OW 241
25005: GO 24990
25007: POP
25008: POP
// end ;
25009: PPOPN 2
25011: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
25012: LD_EXP 75
25016: PUSH
25017: LD_EXP 92
25021: AND
25022: IFFALSE 25133
25024: GO 25026
25026: DISABLE
25027: LD_INT 0
25029: PPUSH
25030: PPUSH
25031: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25032: LD_ADDR_VAR 0 3
25036: PUSH
25037: LD_INT 22
25039: PUSH
25040: LD_OWVAR 2
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 25
25051: PUSH
25052: LD_INT 1
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PPUSH
25063: CALL_OW 69
25067: ST_TO_ADDR
// if not tmp then
25068: LD_VAR 0 3
25072: NOT
25073: IFFALSE 25077
// exit ;
25075: GO 25133
// un := tmp [ rand ( 1 , tmp ) ] ;
25077: LD_ADDR_VAR 0 2
25081: PUSH
25082: LD_VAR 0 3
25086: PUSH
25087: LD_INT 1
25089: PPUSH
25090: LD_VAR 0 3
25094: PPUSH
25095: CALL_OW 12
25099: ARRAY
25100: ST_TO_ADDR
// if Crawls ( un ) then
25101: LD_VAR 0 2
25105: PPUSH
25106: CALL_OW 318
25110: IFFALSE 25121
// ComWalk ( un ) ;
25112: LD_VAR 0 2
25116: PPUSH
25117: CALL_OW 138
// SetClass ( un , class_sniper ) ;
25121: LD_VAR 0 2
25125: PPUSH
25126: LD_INT 5
25128: PPUSH
25129: CALL_OW 336
// end ;
25133: PPOPN 3
25135: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
25136: LD_EXP 75
25140: PUSH
25141: LD_EXP 93
25145: AND
25146: PUSH
25147: LD_OWVAR 67
25151: PUSH
25152: LD_INT 3
25154: LESS
25155: AND
25156: IFFALSE 25175
25158: GO 25160
25160: DISABLE
// Difficulty := Difficulty + 1 ;
25161: LD_ADDR_OWVAR 67
25165: PUSH
25166: LD_OWVAR 67
25170: PUSH
25171: LD_INT 1
25173: PLUS
25174: ST_TO_ADDR
25175: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
25176: LD_EXP 75
25180: PUSH
25181: LD_EXP 94
25185: AND
25186: IFFALSE 25289
25188: GO 25190
25190: DISABLE
25191: LD_INT 0
25193: PPUSH
// begin for i := 1 to 5 do
25194: LD_ADDR_VAR 0 1
25198: PUSH
25199: DOUBLE
25200: LD_INT 1
25202: DEC
25203: ST_TO_ADDR
25204: LD_INT 5
25206: PUSH
25207: FOR_TO
25208: IFFALSE 25287
// begin uc_nation := nation_nature ;
25210: LD_ADDR_OWVAR 21
25214: PUSH
25215: LD_INT 0
25217: ST_TO_ADDR
// uc_side := 0 ;
25218: LD_ADDR_OWVAR 20
25222: PUSH
25223: LD_INT 0
25225: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25226: LD_ADDR_OWVAR 29
25230: PUSH
25231: LD_INT 12
25233: PUSH
25234: LD_INT 12
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: ST_TO_ADDR
// hc_agressivity := 20 ;
25241: LD_ADDR_OWVAR 35
25245: PUSH
25246: LD_INT 20
25248: ST_TO_ADDR
// hc_class := class_tiger ;
25249: LD_ADDR_OWVAR 28
25253: PUSH
25254: LD_INT 14
25256: ST_TO_ADDR
// hc_gallery :=  ;
25257: LD_ADDR_OWVAR 33
25261: PUSH
25262: LD_STRING 
25264: ST_TO_ADDR
// hc_name :=  ;
25265: LD_ADDR_OWVAR 26
25269: PUSH
25270: LD_STRING 
25272: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
25273: CALL_OW 44
25277: PPUSH
25278: LD_INT 0
25280: PPUSH
25281: CALL_OW 51
// end ;
25285: GO 25207
25287: POP
25288: POP
// end ;
25289: PPOPN 1
25291: END
// every 0 0$1 trigger StreamModeActive and sBomb do
25292: LD_EXP 75
25296: PUSH
25297: LD_EXP 95
25301: AND
25302: IFFALSE 25311
25304: GO 25306
25306: DISABLE
// StreamSibBomb ;
25307: CALL 25312 0 0
25311: END
// export function StreamSibBomb ; var i , x , y ; begin
25312: LD_INT 0
25314: PPUSH
25315: PPUSH
25316: PPUSH
25317: PPUSH
// result := false ;
25318: LD_ADDR_VAR 0 1
25322: PUSH
25323: LD_INT 0
25325: ST_TO_ADDR
// for i := 1 to 16 do
25326: LD_ADDR_VAR 0 2
25330: PUSH
25331: DOUBLE
25332: LD_INT 1
25334: DEC
25335: ST_TO_ADDR
25336: LD_INT 16
25338: PUSH
25339: FOR_TO
25340: IFFALSE 25539
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25342: LD_ADDR_VAR 0 3
25346: PUSH
25347: LD_INT 10
25349: PUSH
25350: LD_INT 20
25352: PUSH
25353: LD_INT 30
25355: PUSH
25356: LD_INT 40
25358: PUSH
25359: LD_INT 50
25361: PUSH
25362: LD_INT 60
25364: PUSH
25365: LD_INT 70
25367: PUSH
25368: LD_INT 80
25370: PUSH
25371: LD_INT 90
25373: PUSH
25374: LD_INT 100
25376: PUSH
25377: LD_INT 110
25379: PUSH
25380: LD_INT 120
25382: PUSH
25383: LD_INT 130
25385: PUSH
25386: LD_INT 140
25388: PUSH
25389: LD_INT 150
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: LIST
25396: LIST
25397: LIST
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: LIST
25405: LIST
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 1
25411: PPUSH
25412: LD_INT 15
25414: PPUSH
25415: CALL_OW 12
25419: ARRAY
25420: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
25421: LD_ADDR_VAR 0 4
25425: PUSH
25426: LD_INT 10
25428: PUSH
25429: LD_INT 20
25431: PUSH
25432: LD_INT 30
25434: PUSH
25435: LD_INT 40
25437: PUSH
25438: LD_INT 50
25440: PUSH
25441: LD_INT 60
25443: PUSH
25444: LD_INT 70
25446: PUSH
25447: LD_INT 80
25449: PUSH
25450: LD_INT 90
25452: PUSH
25453: LD_INT 100
25455: PUSH
25456: LD_INT 110
25458: PUSH
25459: LD_INT 120
25461: PUSH
25462: LD_INT 130
25464: PUSH
25465: LD_INT 140
25467: PUSH
25468: LD_INT 150
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: LIST
25475: LIST
25476: LIST
25477: LIST
25478: LIST
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: LIST
25484: LIST
25485: LIST
25486: LIST
25487: PUSH
25488: LD_INT 1
25490: PPUSH
25491: LD_INT 15
25493: PPUSH
25494: CALL_OW 12
25498: ARRAY
25499: ST_TO_ADDR
// if ValidHex ( x , y ) then
25500: LD_VAR 0 3
25504: PPUSH
25505: LD_VAR 0 4
25509: PPUSH
25510: CALL_OW 488
25514: IFFALSE 25537
// begin result := [ x , y ] ;
25516: LD_ADDR_VAR 0 1
25520: PUSH
25521: LD_VAR 0 3
25525: PUSH
25526: LD_VAR 0 4
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: ST_TO_ADDR
// break ;
25535: GO 25539
// end ; end ;
25537: GO 25339
25539: POP
25540: POP
// if result then
25541: LD_VAR 0 1
25545: IFFALSE 25605
// begin ToLua ( playSibBomb() ) ;
25547: LD_STRING playSibBomb()
25549: PPUSH
25550: CALL_OW 559
// wait ( 0 0$14 ) ;
25554: LD_INT 490
25556: PPUSH
25557: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
25561: LD_VAR 0 1
25565: PUSH
25566: LD_INT 1
25568: ARRAY
25569: PPUSH
25570: LD_VAR 0 1
25574: PUSH
25575: LD_INT 2
25577: ARRAY
25578: PPUSH
25579: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
25583: LD_VAR 0 1
25587: PUSH
25588: LD_INT 1
25590: ARRAY
25591: PPUSH
25592: LD_VAR 0 1
25596: PUSH
25597: LD_INT 2
25599: ARRAY
25600: PPUSH
25601: CALL_OW 429
// end ; end ;
25605: LD_VAR 0 1
25609: RET
// every 0 0$1 trigger StreamModeActive and sReset do
25610: LD_EXP 75
25614: PUSH
25615: LD_EXP 97
25619: AND
25620: IFFALSE 25632
25622: GO 25624
25624: DISABLE
// YouLost (  ) ;
25625: LD_STRING 
25627: PPUSH
25628: CALL_OW 104
25632: END
// every 0 0$1 trigger StreamModeActive and sFog do
25633: LD_EXP 75
25637: PUSH
25638: LD_EXP 96
25642: AND
25643: IFFALSE 25657
25645: GO 25647
25647: DISABLE
// FogOff ( your_side ) ;
25648: LD_OWVAR 2
25652: PPUSH
25653: CALL_OW 344
25657: END
// every 0 0$1 trigger StreamModeActive and sSun do
25658: LD_EXP 75
25662: PUSH
25663: LD_EXP 98
25667: AND
25668: IFFALSE 25696
25670: GO 25672
25672: DISABLE
// begin solar_recharge_percent := 0 ;
25673: LD_ADDR_OWVAR 79
25677: PUSH
25678: LD_INT 0
25680: ST_TO_ADDR
// wait ( 5 5$00 ) ;
25681: LD_INT 10500
25683: PPUSH
25684: CALL_OW 67
// solar_recharge_percent := 100 ;
25688: LD_ADDR_OWVAR 79
25692: PUSH
25693: LD_INT 100
25695: ST_TO_ADDR
// end ;
25696: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
25697: LD_EXP 75
25701: PUSH
25702: LD_EXP 99
25706: AND
25707: IFFALSE 25946
25709: GO 25711
25711: DISABLE
25712: LD_INT 0
25714: PPUSH
25715: PPUSH
25716: PPUSH
// begin tmp := [ ] ;
25717: LD_ADDR_VAR 0 3
25721: PUSH
25722: EMPTY
25723: ST_TO_ADDR
// for i := 1 to 6 do
25724: LD_ADDR_VAR 0 1
25728: PUSH
25729: DOUBLE
25730: LD_INT 1
25732: DEC
25733: ST_TO_ADDR
25734: LD_INT 6
25736: PUSH
25737: FOR_TO
25738: IFFALSE 25843
// begin uc_nation := nation_nature ;
25740: LD_ADDR_OWVAR 21
25744: PUSH
25745: LD_INT 0
25747: ST_TO_ADDR
// uc_side := 0 ;
25748: LD_ADDR_OWVAR 20
25752: PUSH
25753: LD_INT 0
25755: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
25756: LD_ADDR_OWVAR 29
25760: PUSH
25761: LD_INT 12
25763: PUSH
25764: LD_INT 12
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: ST_TO_ADDR
// hc_agressivity := 20 ;
25771: LD_ADDR_OWVAR 35
25775: PUSH
25776: LD_INT 20
25778: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
25779: LD_ADDR_OWVAR 28
25783: PUSH
25784: LD_INT 17
25786: ST_TO_ADDR
// hc_gallery :=  ;
25787: LD_ADDR_OWVAR 33
25791: PUSH
25792: LD_STRING 
25794: ST_TO_ADDR
// hc_name :=  ;
25795: LD_ADDR_OWVAR 26
25799: PUSH
25800: LD_STRING 
25802: ST_TO_ADDR
// un := CreateHuman ;
25803: LD_ADDR_VAR 0 2
25807: PUSH
25808: CALL_OW 44
25812: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
25813: LD_VAR 0 2
25817: PPUSH
25818: LD_INT 1
25820: PPUSH
25821: CALL_OW 51
// tmp := tmp ^ un ;
25825: LD_ADDR_VAR 0 3
25829: PUSH
25830: LD_VAR 0 3
25834: PUSH
25835: LD_VAR 0 2
25839: ADD
25840: ST_TO_ADDR
// end ;
25841: GO 25737
25843: POP
25844: POP
// repeat wait ( 0 0$1 ) ;
25845: LD_INT 35
25847: PPUSH
25848: CALL_OW 67
// for un in tmp do
25852: LD_ADDR_VAR 0 2
25856: PUSH
25857: LD_VAR 0 3
25861: PUSH
25862: FOR_IN
25863: IFFALSE 25937
// begin if IsDead ( un ) then
25865: LD_VAR 0 2
25869: PPUSH
25870: CALL_OW 301
25874: IFFALSE 25894
// begin tmp := tmp diff un ;
25876: LD_ADDR_VAR 0 3
25880: PUSH
25881: LD_VAR 0 3
25885: PUSH
25886: LD_VAR 0 2
25890: DIFF
25891: ST_TO_ADDR
// continue ;
25892: GO 25862
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
25894: LD_VAR 0 2
25898: PPUSH
25899: LD_INT 3
25901: PUSH
25902: LD_INT 22
25904: PUSH
25905: LD_INT 0
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: EMPTY
25913: LIST
25914: LIST
25915: PPUSH
25916: CALL_OW 69
25920: PPUSH
25921: LD_VAR 0 2
25925: PPUSH
25926: CALL_OW 74
25930: PPUSH
25931: CALL_OW 115
// end ;
25935: GO 25862
25937: POP
25938: POP
// until not tmp ;
25939: LD_VAR 0 3
25943: NOT
25944: IFFALSE 25845
// end ;
25946: PPOPN 3
25948: END
// every 0 0$1 trigger StreamModeActive and sTroll do
25949: LD_EXP 75
25953: PUSH
25954: LD_EXP 100
25958: AND
25959: IFFALSE 26013
25961: GO 25963
25963: DISABLE
// begin ToLua ( displayTroll(); ) ;
25964: LD_STRING displayTroll();
25966: PPUSH
25967: CALL_OW 559
// wait ( 3 3$00 ) ;
25971: LD_INT 6300
25973: PPUSH
25974: CALL_OW 67
// ToLua ( hideTroll(); ) ;
25978: LD_STRING hideTroll();
25980: PPUSH
25981: CALL_OW 559
// wait ( 1 1$00 ) ;
25985: LD_INT 2100
25987: PPUSH
25988: CALL_OW 67
// ToLua ( displayTroll(); ) ;
25992: LD_STRING displayTroll();
25994: PPUSH
25995: CALL_OW 559
// wait ( 1 1$00 ) ;
25999: LD_INT 2100
26001: PPUSH
26002: CALL_OW 67
// ToLua ( hideTroll(); ) ;
26006: LD_STRING hideTroll();
26008: PPUSH
26009: CALL_OW 559
// end ;
26013: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
26014: LD_EXP 75
26018: PUSH
26019: LD_EXP 101
26023: AND
26024: IFFALSE 26087
26026: GO 26028
26028: DISABLE
26029: LD_INT 0
26031: PPUSH
// begin p := 0 ;
26032: LD_ADDR_VAR 0 1
26036: PUSH
26037: LD_INT 0
26039: ST_TO_ADDR
// repeat game_speed := 1 ;
26040: LD_ADDR_OWVAR 65
26044: PUSH
26045: LD_INT 1
26047: ST_TO_ADDR
// wait ( 0 0$1 ) ;
26048: LD_INT 35
26050: PPUSH
26051: CALL_OW 67
// p := p + 1 ;
26055: LD_ADDR_VAR 0 1
26059: PUSH
26060: LD_VAR 0 1
26064: PUSH
26065: LD_INT 1
26067: PLUS
26068: ST_TO_ADDR
// until p >= 60 ;
26069: LD_VAR 0 1
26073: PUSH
26074: LD_INT 60
26076: GREATEREQUAL
26077: IFFALSE 26040
// game_speed := 4 ;
26079: LD_ADDR_OWVAR 65
26083: PUSH
26084: LD_INT 4
26086: ST_TO_ADDR
// end ;
26087: PPOPN 1
26089: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
26090: LD_EXP 75
26094: PUSH
26095: LD_EXP 102
26099: AND
26100: IFFALSE 26246
26102: GO 26104
26104: DISABLE
26105: LD_INT 0
26107: PPUSH
26108: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26109: LD_ADDR_VAR 0 1
26113: PUSH
26114: LD_INT 22
26116: PUSH
26117: LD_OWVAR 2
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 2
26128: PUSH
26129: LD_INT 30
26131: PUSH
26132: LD_INT 0
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PUSH
26139: LD_INT 30
26141: PUSH
26142: LD_INT 1
26144: PUSH
26145: EMPTY
26146: LIST
26147: LIST
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: LIST
26153: PUSH
26154: EMPTY
26155: LIST
26156: LIST
26157: PPUSH
26158: CALL_OW 69
26162: ST_TO_ADDR
// if not depot then
26163: LD_VAR 0 1
26167: NOT
26168: IFFALSE 26172
// exit ;
26170: GO 26246
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
26172: LD_ADDR_VAR 0 2
26176: PUSH
26177: LD_VAR 0 1
26181: PUSH
26182: LD_INT 1
26184: PPUSH
26185: LD_VAR 0 1
26189: PPUSH
26190: CALL_OW 12
26194: ARRAY
26195: PPUSH
26196: CALL_OW 274
26200: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
26201: LD_VAR 0 2
26205: PPUSH
26206: LD_INT 1
26208: PPUSH
26209: LD_INT 0
26211: PPUSH
26212: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
26216: LD_VAR 0 2
26220: PPUSH
26221: LD_INT 2
26223: PPUSH
26224: LD_INT 0
26226: PPUSH
26227: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
26231: LD_VAR 0 2
26235: PPUSH
26236: LD_INT 3
26238: PPUSH
26239: LD_INT 0
26241: PPUSH
26242: CALL_OW 277
// end ;
26246: PPOPN 2
26248: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
26249: LD_EXP 75
26253: PUSH
26254: LD_EXP 103
26258: AND
26259: IFFALSE 26356
26261: GO 26263
26263: DISABLE
26264: LD_INT 0
26266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26267: LD_ADDR_VAR 0 1
26271: PUSH
26272: LD_INT 22
26274: PUSH
26275: LD_OWVAR 2
26279: PUSH
26280: EMPTY
26281: LIST
26282: LIST
26283: PUSH
26284: LD_INT 21
26286: PUSH
26287: LD_INT 1
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: PUSH
26294: LD_INT 3
26296: PUSH
26297: LD_INT 23
26299: PUSH
26300: LD_INT 0
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: LIST
26315: PPUSH
26316: CALL_OW 69
26320: ST_TO_ADDR
// if not tmp then
26321: LD_VAR 0 1
26325: NOT
26326: IFFALSE 26330
// exit ;
26328: GO 26356
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
26330: LD_VAR 0 1
26334: PUSH
26335: LD_INT 1
26337: PPUSH
26338: LD_VAR 0 1
26342: PPUSH
26343: CALL_OW 12
26347: ARRAY
26348: PPUSH
26349: LD_INT 200
26351: PPUSH
26352: CALL_OW 234
// end ;
26356: PPOPN 1
26358: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
26359: LD_EXP 75
26363: PUSH
26364: LD_EXP 104
26368: AND
26369: IFFALSE 26448
26371: GO 26373
26373: DISABLE
26374: LD_INT 0
26376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
26377: LD_ADDR_VAR 0 1
26381: PUSH
26382: LD_INT 22
26384: PUSH
26385: LD_OWVAR 2
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: PUSH
26394: LD_INT 21
26396: PUSH
26397: LD_INT 2
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PPUSH
26408: CALL_OW 69
26412: ST_TO_ADDR
// if not tmp then
26413: LD_VAR 0 1
26417: NOT
26418: IFFALSE 26422
// exit ;
26420: GO 26448
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
26422: LD_VAR 0 1
26426: PUSH
26427: LD_INT 1
26429: PPUSH
26430: LD_VAR 0 1
26434: PPUSH
26435: CALL_OW 12
26439: ARRAY
26440: PPUSH
26441: LD_INT 60
26443: PPUSH
26444: CALL_OW 234
// end ;
26448: PPOPN 1
26450: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
26451: LD_EXP 75
26455: PUSH
26456: LD_EXP 105
26460: AND
26461: IFFALSE 26560
26463: GO 26465
26465: DISABLE
26466: LD_INT 0
26468: PPUSH
26469: PPUSH
// begin enable ;
26470: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
26471: LD_ADDR_VAR 0 1
26475: PUSH
26476: LD_INT 22
26478: PUSH
26479: LD_OWVAR 2
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 61
26490: PUSH
26491: EMPTY
26492: LIST
26493: PUSH
26494: LD_INT 33
26496: PUSH
26497: LD_INT 2
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: LIST
26508: PPUSH
26509: CALL_OW 69
26513: ST_TO_ADDR
// if not tmp then
26514: LD_VAR 0 1
26518: NOT
26519: IFFALSE 26523
// exit ;
26521: GO 26560
// for i in tmp do
26523: LD_ADDR_VAR 0 2
26527: PUSH
26528: LD_VAR 0 1
26532: PUSH
26533: FOR_IN
26534: IFFALSE 26558
// if IsControledBy ( i ) then
26536: LD_VAR 0 2
26540: PPUSH
26541: CALL_OW 312
26545: IFFALSE 26556
// ComUnlink ( i ) ;
26547: LD_VAR 0 2
26551: PPUSH
26552: CALL_OW 136
26556: GO 26533
26558: POP
26559: POP
// end ;
26560: PPOPN 2
26562: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
26563: LD_EXP 75
26567: PUSH
26568: LD_EXP 106
26572: AND
26573: IFFALSE 26713
26575: GO 26577
26577: DISABLE
26578: LD_INT 0
26580: PPUSH
26581: PPUSH
// begin ToLua ( displayPowell(); ) ;
26582: LD_STRING displayPowell();
26584: PPUSH
26585: CALL_OW 559
// uc_side := 0 ;
26589: LD_ADDR_OWVAR 20
26593: PUSH
26594: LD_INT 0
26596: ST_TO_ADDR
// uc_nation := 2 ;
26597: LD_ADDR_OWVAR 21
26601: PUSH
26602: LD_INT 2
26604: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
26605: LD_ADDR_OWVAR 37
26609: PUSH
26610: LD_INT 14
26612: ST_TO_ADDR
// vc_engine := engine_siberite ;
26613: LD_ADDR_OWVAR 39
26617: PUSH
26618: LD_INT 3
26620: ST_TO_ADDR
// vc_control := control_apeman ;
26621: LD_ADDR_OWVAR 38
26625: PUSH
26626: LD_INT 5
26628: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
26629: LD_ADDR_OWVAR 40
26633: PUSH
26634: LD_INT 29
26636: ST_TO_ADDR
// un := CreateVehicle ;
26637: LD_ADDR_VAR 0 2
26641: PUSH
26642: CALL_OW 45
26646: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26647: LD_VAR 0 2
26651: PPUSH
26652: LD_INT 1
26654: PPUSH
26655: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
26659: LD_INT 35
26661: PPUSH
26662: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
26666: LD_VAR 0 2
26670: PPUSH
26671: LD_INT 22
26673: PUSH
26674: LD_OWVAR 2
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: PPUSH
26683: CALL_OW 69
26687: PPUSH
26688: LD_VAR 0 2
26692: PPUSH
26693: CALL_OW 74
26697: PPUSH
26698: CALL_OW 115
// until IsDead ( un ) ;
26702: LD_VAR 0 2
26706: PPUSH
26707: CALL_OW 301
26711: IFFALSE 26659
// end ;
26713: PPOPN 2
26715: END
// every 0 0$1 trigger StreamModeActive and sStu do
26716: LD_EXP 75
26720: PUSH
26721: LD_EXP 114
26725: AND
26726: IFFALSE 26742
26728: GO 26730
26730: DISABLE
// begin ToLua ( displayStucuk(); ) ;
26731: LD_STRING displayStucuk();
26733: PPUSH
26734: CALL_OW 559
// ResetFog ;
26738: CALL_OW 335
// end ;
26742: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
26743: LD_EXP 75
26747: PUSH
26748: LD_EXP 107
26752: AND
26753: IFFALSE 26894
26755: GO 26757
26757: DISABLE
26758: LD_INT 0
26760: PPUSH
26761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26762: LD_ADDR_VAR 0 2
26766: PUSH
26767: LD_INT 22
26769: PUSH
26770: LD_OWVAR 2
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PUSH
26779: LD_INT 21
26781: PUSH
26782: LD_INT 1
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PPUSH
26793: CALL_OW 69
26797: ST_TO_ADDR
// if not tmp then
26798: LD_VAR 0 2
26802: NOT
26803: IFFALSE 26807
// exit ;
26805: GO 26894
// un := tmp [ rand ( 1 , tmp ) ] ;
26807: LD_ADDR_VAR 0 1
26811: PUSH
26812: LD_VAR 0 2
26816: PUSH
26817: LD_INT 1
26819: PPUSH
26820: LD_VAR 0 2
26824: PPUSH
26825: CALL_OW 12
26829: ARRAY
26830: ST_TO_ADDR
// SetSide ( un , 0 ) ;
26831: LD_VAR 0 1
26835: PPUSH
26836: LD_INT 0
26838: PPUSH
26839: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
26843: LD_VAR 0 1
26847: PPUSH
26848: LD_OWVAR 3
26852: PUSH
26853: LD_VAR 0 1
26857: DIFF
26858: PPUSH
26859: LD_VAR 0 1
26863: PPUSH
26864: CALL_OW 74
26868: PPUSH
26869: CALL_OW 115
// wait ( 0 0$20 ) ;
26873: LD_INT 700
26875: PPUSH
26876: CALL_OW 67
// SetSide ( un , your_side ) ;
26880: LD_VAR 0 1
26884: PPUSH
26885: LD_OWVAR 2
26889: PPUSH
26890: CALL_OW 235
// end ;
26894: PPOPN 2
26896: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
26897: LD_EXP 75
26901: PUSH
26902: LD_EXP 108
26906: AND
26907: IFFALSE 27013
26909: GO 26911
26911: DISABLE
26912: LD_INT 0
26914: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26915: LD_ADDR_VAR 0 1
26919: PUSH
26920: LD_INT 22
26922: PUSH
26923: LD_OWVAR 2
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: PUSH
26932: LD_INT 2
26934: PUSH
26935: LD_INT 30
26937: PUSH
26938: LD_INT 0
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PUSH
26945: LD_INT 30
26947: PUSH
26948: LD_INT 1
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PPUSH
26964: CALL_OW 69
26968: ST_TO_ADDR
// if not depot then
26969: LD_VAR 0 1
26973: NOT
26974: IFFALSE 26978
// exit ;
26976: GO 27013
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
26978: LD_VAR 0 1
26982: PUSH
26983: LD_INT 1
26985: ARRAY
26986: PPUSH
26987: CALL_OW 250
26991: PPUSH
26992: LD_VAR 0 1
26996: PUSH
26997: LD_INT 1
26999: ARRAY
27000: PPUSH
27001: CALL_OW 251
27005: PPUSH
27006: LD_INT 70
27008: PPUSH
27009: CALL_OW 495
// end ;
27013: PPOPN 1
27015: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
27016: LD_EXP 75
27020: PUSH
27021: LD_EXP 109
27025: AND
27026: IFFALSE 27237
27028: GO 27030
27030: DISABLE
27031: LD_INT 0
27033: PPUSH
27034: PPUSH
27035: PPUSH
27036: PPUSH
27037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27038: LD_ADDR_VAR 0 5
27042: PUSH
27043: LD_INT 22
27045: PUSH
27046: LD_OWVAR 2
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 21
27057: PUSH
27058: LD_INT 1
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PPUSH
27069: CALL_OW 69
27073: ST_TO_ADDR
// if not tmp then
27074: LD_VAR 0 5
27078: NOT
27079: IFFALSE 27083
// exit ;
27081: GO 27237
// for i in tmp do
27083: LD_ADDR_VAR 0 1
27087: PUSH
27088: LD_VAR 0 5
27092: PUSH
27093: FOR_IN
27094: IFFALSE 27235
// begin d := rand ( 0 , 5 ) ;
27096: LD_ADDR_VAR 0 4
27100: PUSH
27101: LD_INT 0
27103: PPUSH
27104: LD_INT 5
27106: PPUSH
27107: CALL_OW 12
27111: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
27112: LD_ADDR_VAR 0 2
27116: PUSH
27117: LD_VAR 0 1
27121: PPUSH
27122: CALL_OW 250
27126: PPUSH
27127: LD_VAR 0 4
27131: PPUSH
27132: LD_INT 3
27134: PPUSH
27135: LD_INT 12
27137: PPUSH
27138: CALL_OW 12
27142: PPUSH
27143: CALL_OW 272
27147: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
27148: LD_ADDR_VAR 0 3
27152: PUSH
27153: LD_VAR 0 1
27157: PPUSH
27158: CALL_OW 251
27162: PPUSH
27163: LD_VAR 0 4
27167: PPUSH
27168: LD_INT 3
27170: PPUSH
27171: LD_INT 12
27173: PPUSH
27174: CALL_OW 12
27178: PPUSH
27179: CALL_OW 273
27183: ST_TO_ADDR
// if ValidHex ( x , y ) then
27184: LD_VAR 0 2
27188: PPUSH
27189: LD_VAR 0 3
27193: PPUSH
27194: CALL_OW 488
27198: IFFALSE 27233
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
27200: LD_VAR 0 1
27204: PPUSH
27205: LD_VAR 0 2
27209: PPUSH
27210: LD_VAR 0 3
27214: PPUSH
27215: LD_INT 3
27217: PPUSH
27218: LD_INT 6
27220: PPUSH
27221: CALL_OW 12
27225: PPUSH
27226: LD_INT 1
27228: PPUSH
27229: CALL_OW 483
// end ;
27233: GO 27093
27235: POP
27236: POP
// end ;
27237: PPOPN 5
27239: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
27240: LD_EXP 75
27244: PUSH
27245: LD_EXP 110
27249: AND
27250: IFFALSE 27344
27252: GO 27254
27254: DISABLE
27255: LD_INT 0
27257: PPUSH
27258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
27259: LD_ADDR_VAR 0 2
27263: PUSH
27264: LD_INT 22
27266: PUSH
27267: LD_OWVAR 2
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 32
27278: PUSH
27279: LD_INT 1
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 21
27288: PUSH
27289: LD_INT 2
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: LIST
27300: PPUSH
27301: CALL_OW 69
27305: ST_TO_ADDR
// if not tmp then
27306: LD_VAR 0 2
27310: NOT
27311: IFFALSE 27315
// exit ;
27313: GO 27344
// for i in tmp do
27315: LD_ADDR_VAR 0 1
27319: PUSH
27320: LD_VAR 0 2
27324: PUSH
27325: FOR_IN
27326: IFFALSE 27342
// SetFuel ( i , 0 ) ;
27328: LD_VAR 0 1
27332: PPUSH
27333: LD_INT 0
27335: PPUSH
27336: CALL_OW 240
27340: GO 27325
27342: POP
27343: POP
// end ;
27344: PPOPN 2
27346: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
27347: LD_EXP 75
27351: PUSH
27352: LD_EXP 111
27356: AND
27357: IFFALSE 27423
27359: GO 27361
27361: DISABLE
27362: LD_INT 0
27364: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
27365: LD_ADDR_VAR 0 1
27369: PUSH
27370: LD_INT 22
27372: PUSH
27373: LD_OWVAR 2
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 30
27384: PUSH
27385: LD_INT 29
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PPUSH
27396: CALL_OW 69
27400: ST_TO_ADDR
// if not tmp then
27401: LD_VAR 0 1
27405: NOT
27406: IFFALSE 27410
// exit ;
27408: GO 27423
// DestroyUnit ( tmp [ 1 ] ) ;
27410: LD_VAR 0 1
27414: PUSH
27415: LD_INT 1
27417: ARRAY
27418: PPUSH
27419: CALL_OW 65
// end ;
27423: PPOPN 1
27425: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
27426: LD_EXP 75
27430: PUSH
27431: LD_EXP 113
27435: AND
27436: IFFALSE 27565
27438: GO 27440
27440: DISABLE
27441: LD_INT 0
27443: PPUSH
// begin uc_side := 0 ;
27444: LD_ADDR_OWVAR 20
27448: PUSH
27449: LD_INT 0
27451: ST_TO_ADDR
// uc_nation := nation_arabian ;
27452: LD_ADDR_OWVAR 21
27456: PUSH
27457: LD_INT 2
27459: ST_TO_ADDR
// hc_gallery :=  ;
27460: LD_ADDR_OWVAR 33
27464: PUSH
27465: LD_STRING 
27467: ST_TO_ADDR
// hc_name :=  ;
27468: LD_ADDR_OWVAR 26
27472: PUSH
27473: LD_STRING 
27475: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
27476: LD_INT 1
27478: PPUSH
27479: LD_INT 11
27481: PPUSH
27482: LD_INT 10
27484: PPUSH
27485: CALL_OW 380
// un := CreateHuman ;
27489: LD_ADDR_VAR 0 1
27493: PUSH
27494: CALL_OW 44
27498: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27499: LD_VAR 0 1
27503: PPUSH
27504: LD_INT 1
27506: PPUSH
27507: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27511: LD_INT 35
27513: PPUSH
27514: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27518: LD_VAR 0 1
27522: PPUSH
27523: LD_INT 22
27525: PUSH
27526: LD_OWVAR 2
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: PPUSH
27535: CALL_OW 69
27539: PPUSH
27540: LD_VAR 0 1
27544: PPUSH
27545: CALL_OW 74
27549: PPUSH
27550: CALL_OW 115
// until IsDead ( un ) ;
27554: LD_VAR 0 1
27558: PPUSH
27559: CALL_OW 301
27563: IFFALSE 27511
// end ;
27565: PPOPN 1
27567: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
27568: LD_EXP 75
27572: PUSH
27573: LD_EXP 115
27577: AND
27578: IFFALSE 27590
27580: GO 27582
27582: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
27583: LD_STRING earthquake(getX(game), 0, 32)
27585: PPUSH
27586: CALL_OW 559
27590: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
27591: LD_EXP 75
27595: PUSH
27596: LD_EXP 116
27600: AND
27601: IFFALSE 27692
27603: GO 27605
27605: DISABLE
27606: LD_INT 0
27608: PPUSH
// begin enable ;
27609: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
27610: LD_ADDR_VAR 0 1
27614: PUSH
27615: LD_INT 22
27617: PUSH
27618: LD_OWVAR 2
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: PUSH
27627: LD_INT 21
27629: PUSH
27630: LD_INT 2
27632: PUSH
27633: EMPTY
27634: LIST
27635: LIST
27636: PUSH
27637: LD_INT 33
27639: PUSH
27640: LD_INT 3
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: LIST
27651: PPUSH
27652: CALL_OW 69
27656: ST_TO_ADDR
// if not tmp then
27657: LD_VAR 0 1
27661: NOT
27662: IFFALSE 27666
// exit ;
27664: GO 27692
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
27666: LD_VAR 0 1
27670: PUSH
27671: LD_INT 1
27673: PPUSH
27674: LD_VAR 0 1
27678: PPUSH
27679: CALL_OW 12
27683: ARRAY
27684: PPUSH
27685: LD_INT 1
27687: PPUSH
27688: CALL_OW 234
// end ;
27692: PPOPN 1
27694: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
27695: LD_EXP 75
27699: PUSH
27700: LD_EXP 117
27704: AND
27705: IFFALSE 27846
27707: GO 27709
27709: DISABLE
27710: LD_INT 0
27712: PPUSH
27713: PPUSH
27714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27715: LD_ADDR_VAR 0 3
27719: PUSH
27720: LD_INT 22
27722: PUSH
27723: LD_OWVAR 2
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: LD_INT 25
27734: PUSH
27735: LD_INT 1
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PPUSH
27746: CALL_OW 69
27750: ST_TO_ADDR
// if not tmp then
27751: LD_VAR 0 3
27755: NOT
27756: IFFALSE 27760
// exit ;
27758: GO 27846
// un := tmp [ rand ( 1 , tmp ) ] ;
27760: LD_ADDR_VAR 0 2
27764: PUSH
27765: LD_VAR 0 3
27769: PUSH
27770: LD_INT 1
27772: PPUSH
27773: LD_VAR 0 3
27777: PPUSH
27778: CALL_OW 12
27782: ARRAY
27783: ST_TO_ADDR
// if Crawls ( un ) then
27784: LD_VAR 0 2
27788: PPUSH
27789: CALL_OW 318
27793: IFFALSE 27804
// ComWalk ( un ) ;
27795: LD_VAR 0 2
27799: PPUSH
27800: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
27804: LD_VAR 0 2
27808: PPUSH
27809: LD_INT 9
27811: PPUSH
27812: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
27816: LD_INT 28
27818: PPUSH
27819: LD_OWVAR 2
27823: PPUSH
27824: LD_INT 2
27826: PPUSH
27827: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
27831: LD_INT 29
27833: PPUSH
27834: LD_OWVAR 2
27838: PPUSH
27839: LD_INT 2
27841: PPUSH
27842: CALL_OW 322
// end ;
27846: PPOPN 3
27848: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
27849: LD_EXP 75
27853: PUSH
27854: LD_EXP 118
27858: AND
27859: IFFALSE 27970
27861: GO 27863
27863: DISABLE
27864: LD_INT 0
27866: PPUSH
27867: PPUSH
27868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
27869: LD_ADDR_VAR 0 3
27873: PUSH
27874: LD_INT 22
27876: PUSH
27877: LD_OWVAR 2
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 25
27888: PUSH
27889: LD_INT 1
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PPUSH
27900: CALL_OW 69
27904: ST_TO_ADDR
// if not tmp then
27905: LD_VAR 0 3
27909: NOT
27910: IFFALSE 27914
// exit ;
27912: GO 27970
// un := tmp [ rand ( 1 , tmp ) ] ;
27914: LD_ADDR_VAR 0 2
27918: PUSH
27919: LD_VAR 0 3
27923: PUSH
27924: LD_INT 1
27926: PPUSH
27927: LD_VAR 0 3
27931: PPUSH
27932: CALL_OW 12
27936: ARRAY
27937: ST_TO_ADDR
// if Crawls ( un ) then
27938: LD_VAR 0 2
27942: PPUSH
27943: CALL_OW 318
27947: IFFALSE 27958
// ComWalk ( un ) ;
27949: LD_VAR 0 2
27953: PPUSH
27954: CALL_OW 138
// SetClass ( un , class_mortar ) ;
27958: LD_VAR 0 2
27962: PPUSH
27963: LD_INT 8
27965: PPUSH
27966: CALL_OW 336
// end ;
27970: PPOPN 3
27972: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
27973: LD_EXP 75
27977: PUSH
27978: LD_EXP 119
27982: AND
27983: IFFALSE 28127
27985: GO 27987
27987: DISABLE
27988: LD_INT 0
27990: PPUSH
27991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
27992: LD_ADDR_VAR 0 2
27996: PUSH
27997: LD_INT 22
27999: PUSH
28000: LD_OWVAR 2
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: PUSH
28009: LD_INT 21
28011: PUSH
28012: LD_INT 2
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: LD_INT 2
28021: PUSH
28022: LD_INT 34
28024: PUSH
28025: LD_INT 12
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PUSH
28032: LD_INT 34
28034: PUSH
28035: LD_INT 51
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 34
28044: PUSH
28045: LD_INT 32
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: LIST
28062: PPUSH
28063: CALL_OW 69
28067: ST_TO_ADDR
// if not tmp then
28068: LD_VAR 0 2
28072: NOT
28073: IFFALSE 28077
// exit ;
28075: GO 28127
// for i in tmp do
28077: LD_ADDR_VAR 0 1
28081: PUSH
28082: LD_VAR 0 2
28086: PUSH
28087: FOR_IN
28088: IFFALSE 28125
// if GetCargo ( i , mat_artifact ) = 0 then
28090: LD_VAR 0 1
28094: PPUSH
28095: LD_INT 4
28097: PPUSH
28098: CALL_OW 289
28102: PUSH
28103: LD_INT 0
28105: EQUAL
28106: IFFALSE 28123
// SetCargo ( i , mat_siberit , 100 ) ;
28108: LD_VAR 0 1
28112: PPUSH
28113: LD_INT 3
28115: PPUSH
28116: LD_INT 100
28118: PPUSH
28119: CALL_OW 290
28123: GO 28087
28125: POP
28126: POP
// end ;
28127: PPOPN 2
28129: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
28130: LD_EXP 75
28134: PUSH
28135: LD_EXP 120
28139: AND
28140: IFFALSE 28293
28142: GO 28144
28144: DISABLE
28145: LD_INT 0
28147: PPUSH
28148: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
28149: LD_ADDR_VAR 0 2
28153: PUSH
28154: LD_INT 22
28156: PUSH
28157: LD_OWVAR 2
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PPUSH
28166: CALL_OW 69
28170: ST_TO_ADDR
// if not tmp then
28171: LD_VAR 0 2
28175: NOT
28176: IFFALSE 28180
// exit ;
28178: GO 28293
// for i := 1 to 2 do
28180: LD_ADDR_VAR 0 1
28184: PUSH
28185: DOUBLE
28186: LD_INT 1
28188: DEC
28189: ST_TO_ADDR
28190: LD_INT 2
28192: PUSH
28193: FOR_TO
28194: IFFALSE 28291
// begin uc_side := your_side ;
28196: LD_ADDR_OWVAR 20
28200: PUSH
28201: LD_OWVAR 2
28205: ST_TO_ADDR
// uc_nation := nation_american ;
28206: LD_ADDR_OWVAR 21
28210: PUSH
28211: LD_INT 1
28213: ST_TO_ADDR
// vc_chassis := us_morphling ;
28214: LD_ADDR_OWVAR 37
28218: PUSH
28219: LD_INT 5
28221: ST_TO_ADDR
// vc_engine := engine_siberite ;
28222: LD_ADDR_OWVAR 39
28226: PUSH
28227: LD_INT 3
28229: ST_TO_ADDR
// vc_control := control_computer ;
28230: LD_ADDR_OWVAR 38
28234: PUSH
28235: LD_INT 3
28237: ST_TO_ADDR
// vc_weapon := us_double_laser ;
28238: LD_ADDR_OWVAR 40
28242: PUSH
28243: LD_INT 10
28245: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
28246: CALL_OW 45
28250: PPUSH
28251: LD_VAR 0 2
28255: PUSH
28256: LD_INT 1
28258: ARRAY
28259: PPUSH
28260: CALL_OW 250
28264: PPUSH
28265: LD_VAR 0 2
28269: PUSH
28270: LD_INT 1
28272: ARRAY
28273: PPUSH
28274: CALL_OW 251
28278: PPUSH
28279: LD_INT 12
28281: PPUSH
28282: LD_INT 1
28284: PPUSH
28285: CALL_OW 50
// end ;
28289: GO 28193
28291: POP
28292: POP
// end ;
28293: PPOPN 2
28295: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
28296: LD_EXP 75
28300: PUSH
28301: LD_EXP 121
28305: AND
28306: IFFALSE 28528
28308: GO 28310
28310: DISABLE
28311: LD_INT 0
28313: PPUSH
28314: PPUSH
28315: PPUSH
28316: PPUSH
28317: PPUSH
28318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
28319: LD_ADDR_VAR 0 6
28323: PUSH
28324: LD_INT 22
28326: PUSH
28327: LD_OWVAR 2
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 21
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 3
28348: PUSH
28349: LD_INT 23
28351: PUSH
28352: LD_INT 0
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: LIST
28367: PPUSH
28368: CALL_OW 69
28372: ST_TO_ADDR
// if not tmp then
28373: LD_VAR 0 6
28377: NOT
28378: IFFALSE 28382
// exit ;
28380: GO 28528
// s1 := rand ( 1 , 4 ) ;
28382: LD_ADDR_VAR 0 2
28386: PUSH
28387: LD_INT 1
28389: PPUSH
28390: LD_INT 4
28392: PPUSH
28393: CALL_OW 12
28397: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
28398: LD_ADDR_VAR 0 4
28402: PUSH
28403: LD_VAR 0 6
28407: PUSH
28408: LD_INT 1
28410: ARRAY
28411: PPUSH
28412: LD_VAR 0 2
28416: PPUSH
28417: CALL_OW 259
28421: ST_TO_ADDR
// if s1 = 1 then
28422: LD_VAR 0 2
28426: PUSH
28427: LD_INT 1
28429: EQUAL
28430: IFFALSE 28450
// s2 := rand ( 2 , 4 ) else
28432: LD_ADDR_VAR 0 3
28436: PUSH
28437: LD_INT 2
28439: PPUSH
28440: LD_INT 4
28442: PPUSH
28443: CALL_OW 12
28447: ST_TO_ADDR
28448: GO 28458
// s2 := 1 ;
28450: LD_ADDR_VAR 0 3
28454: PUSH
28455: LD_INT 1
28457: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
28458: LD_ADDR_VAR 0 5
28462: PUSH
28463: LD_VAR 0 6
28467: PUSH
28468: LD_INT 1
28470: ARRAY
28471: PPUSH
28472: LD_VAR 0 3
28476: PPUSH
28477: CALL_OW 259
28481: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
28482: LD_VAR 0 6
28486: PUSH
28487: LD_INT 1
28489: ARRAY
28490: PPUSH
28491: LD_VAR 0 2
28495: PPUSH
28496: LD_VAR 0 5
28500: PPUSH
28501: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
28505: LD_VAR 0 6
28509: PUSH
28510: LD_INT 1
28512: ARRAY
28513: PPUSH
28514: LD_VAR 0 3
28518: PPUSH
28519: LD_VAR 0 4
28523: PPUSH
28524: CALL_OW 237
// end ;
28528: PPOPN 6
28530: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
28531: LD_EXP 75
28535: PUSH
28536: LD_EXP 122
28540: AND
28541: IFFALSE 28620
28543: GO 28545
28545: DISABLE
28546: LD_INT 0
28548: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
28549: LD_ADDR_VAR 0 1
28553: PUSH
28554: LD_INT 22
28556: PUSH
28557: LD_OWVAR 2
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: LD_INT 30
28568: PUSH
28569: LD_INT 3
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PPUSH
28580: CALL_OW 69
28584: ST_TO_ADDR
// if not tmp then
28585: LD_VAR 0 1
28589: NOT
28590: IFFALSE 28594
// exit ;
28592: GO 28620
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28594: LD_VAR 0 1
28598: PUSH
28599: LD_INT 1
28601: PPUSH
28602: LD_VAR 0 1
28606: PPUSH
28607: CALL_OW 12
28611: ARRAY
28612: PPUSH
28613: LD_INT 1
28615: PPUSH
28616: CALL_OW 234
// end ;
28620: PPOPN 1
28622: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
28623: LD_EXP 75
28627: PUSH
28628: LD_EXP 123
28632: AND
28633: IFFALSE 28745
28635: GO 28637
28637: DISABLE
28638: LD_INT 0
28640: PPUSH
28641: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
28642: LD_ADDR_VAR 0 2
28646: PUSH
28647: LD_INT 22
28649: PUSH
28650: LD_OWVAR 2
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: PUSH
28659: LD_INT 2
28661: PUSH
28662: LD_INT 30
28664: PUSH
28665: LD_INT 27
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: PUSH
28672: LD_INT 30
28674: PUSH
28675: LD_INT 26
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 30
28684: PUSH
28685: LD_INT 28
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: LIST
28696: LIST
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PPUSH
28702: CALL_OW 69
28706: ST_TO_ADDR
// if not tmp then
28707: LD_VAR 0 2
28711: NOT
28712: IFFALSE 28716
// exit ;
28714: GO 28745
// for i in tmp do
28716: LD_ADDR_VAR 0 1
28720: PUSH
28721: LD_VAR 0 2
28725: PUSH
28726: FOR_IN
28727: IFFALSE 28743
// SetLives ( i , 1 ) ;
28729: LD_VAR 0 1
28733: PPUSH
28734: LD_INT 1
28736: PPUSH
28737: CALL_OW 234
28741: GO 28726
28743: POP
28744: POP
// end ;
28745: PPOPN 2
28747: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
28748: LD_EXP 75
28752: PUSH
28753: LD_EXP 124
28757: AND
28758: IFFALSE 29032
28760: GO 28762
28762: DISABLE
28763: LD_INT 0
28765: PPUSH
28766: PPUSH
28767: PPUSH
// begin i := rand ( 1 , 7 ) ;
28768: LD_ADDR_VAR 0 1
28772: PUSH
28773: LD_INT 1
28775: PPUSH
28776: LD_INT 7
28778: PPUSH
28779: CALL_OW 12
28783: ST_TO_ADDR
// case i of 1 :
28784: LD_VAR 0 1
28788: PUSH
28789: LD_INT 1
28791: DOUBLE
28792: EQUAL
28793: IFTRUE 28797
28795: GO 28807
28797: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
28798: LD_STRING earthquake(getX(game), 0, 32)
28800: PPUSH
28801: CALL_OW 559
28805: GO 29032
28807: LD_INT 2
28809: DOUBLE
28810: EQUAL
28811: IFTRUE 28815
28813: GO 28829
28815: POP
// begin ToLua ( displayStucuk(); ) ;
28816: LD_STRING displayStucuk();
28818: PPUSH
28819: CALL_OW 559
// ResetFog ;
28823: CALL_OW 335
// end ; 3 :
28827: GO 29032
28829: LD_INT 3
28831: DOUBLE
28832: EQUAL
28833: IFTRUE 28837
28835: GO 28941
28837: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28838: LD_ADDR_VAR 0 2
28842: PUSH
28843: LD_INT 22
28845: PUSH
28846: LD_OWVAR 2
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 25
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PPUSH
28869: CALL_OW 69
28873: ST_TO_ADDR
// if not tmp then
28874: LD_VAR 0 2
28878: NOT
28879: IFFALSE 28883
// exit ;
28881: GO 29032
// un := tmp [ rand ( 1 , tmp ) ] ;
28883: LD_ADDR_VAR 0 3
28887: PUSH
28888: LD_VAR 0 2
28892: PUSH
28893: LD_INT 1
28895: PPUSH
28896: LD_VAR 0 2
28900: PPUSH
28901: CALL_OW 12
28905: ARRAY
28906: ST_TO_ADDR
// if Crawls ( un ) then
28907: LD_VAR 0 3
28911: PPUSH
28912: CALL_OW 318
28916: IFFALSE 28927
// ComWalk ( un ) ;
28918: LD_VAR 0 3
28922: PPUSH
28923: CALL_OW 138
// SetClass ( un , class_mortar ) ;
28927: LD_VAR 0 3
28931: PPUSH
28932: LD_INT 8
28934: PPUSH
28935: CALL_OW 336
// end ; 4 :
28939: GO 29032
28941: LD_INT 4
28943: DOUBLE
28944: EQUAL
28945: IFTRUE 28949
28947: GO 29010
28949: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28950: LD_ADDR_VAR 0 2
28954: PUSH
28955: LD_INT 22
28957: PUSH
28958: LD_OWVAR 2
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 30
28969: PUSH
28970: LD_INT 29
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PPUSH
28981: CALL_OW 69
28985: ST_TO_ADDR
// if not tmp then
28986: LD_VAR 0 2
28990: NOT
28991: IFFALSE 28995
// exit ;
28993: GO 29032
// DestroyUnit ( tmp [ 1 ] ) ;
28995: LD_VAR 0 2
28999: PUSH
29000: LD_INT 1
29002: ARRAY
29003: PPUSH
29004: CALL_OW 65
// end ; 5 .. 7 :
29008: GO 29032
29010: LD_INT 5
29012: DOUBLE
29013: GREATEREQUAL
29014: IFFALSE 29022
29016: LD_INT 7
29018: DOUBLE
29019: LESSEQUAL
29020: IFTRUE 29024
29022: GO 29031
29024: POP
// StreamSibBomb ; end ;
29025: CALL 25312 0 0
29029: GO 29032
29031: POP
// end ;
29032: PPOPN 3
29034: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
29035: LD_EXP 75
29039: PUSH
29040: LD_EXP 125
29044: AND
29045: IFFALSE 29201
29047: GO 29049
29049: DISABLE
29050: LD_INT 0
29052: PPUSH
29053: PPUSH
29054: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
29055: LD_ADDR_VAR 0 2
29059: PUSH
29060: LD_INT 81
29062: PUSH
29063: LD_OWVAR 2
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: LD_INT 21
29077: PUSH
29078: LD_INT 1
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 21
29087: PUSH
29088: LD_INT 2
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PPUSH
29104: CALL_OW 69
29108: ST_TO_ADDR
// if not tmp then
29109: LD_VAR 0 2
29113: NOT
29114: IFFALSE 29118
// exit ;
29116: GO 29201
// p := 0 ;
29118: LD_ADDR_VAR 0 3
29122: PUSH
29123: LD_INT 0
29125: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29126: LD_INT 35
29128: PPUSH
29129: CALL_OW 67
// p := p + 1 ;
29133: LD_ADDR_VAR 0 3
29137: PUSH
29138: LD_VAR 0 3
29142: PUSH
29143: LD_INT 1
29145: PLUS
29146: ST_TO_ADDR
// for i in tmp do
29147: LD_ADDR_VAR 0 1
29151: PUSH
29152: LD_VAR 0 2
29156: PUSH
29157: FOR_IN
29158: IFFALSE 29189
// if GetLives ( i ) < 1000 then
29160: LD_VAR 0 1
29164: PPUSH
29165: CALL_OW 256
29169: PUSH
29170: LD_INT 1000
29172: LESS
29173: IFFALSE 29187
// SetLives ( i , 1000 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 1000
29182: PPUSH
29183: CALL_OW 234
29187: GO 29157
29189: POP
29190: POP
// until p > 20 ;
29191: LD_VAR 0 3
29195: PUSH
29196: LD_INT 20
29198: GREATER
29199: IFFALSE 29126
// end ;
29201: PPOPN 3
29203: END
// every 0 0$1 trigger StreamModeActive and sTime do
29204: LD_EXP 75
29208: PUSH
29209: LD_EXP 126
29213: AND
29214: IFFALSE 29249
29216: GO 29218
29218: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
29219: LD_INT 28
29221: PPUSH
29222: LD_OWVAR 2
29226: PPUSH
29227: LD_INT 2
29229: PPUSH
29230: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
29234: LD_INT 30
29236: PPUSH
29237: LD_OWVAR 2
29241: PPUSH
29242: LD_INT 2
29244: PPUSH
29245: CALL_OW 322
// end ;
29249: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
29250: LD_EXP 75
29254: PUSH
29255: LD_EXP 127
29259: AND
29260: IFFALSE 29381
29262: GO 29264
29264: DISABLE
29265: LD_INT 0
29267: PPUSH
29268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29269: LD_ADDR_VAR 0 2
29273: PUSH
29274: LD_INT 22
29276: PUSH
29277: LD_OWVAR 2
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 21
29288: PUSH
29289: LD_INT 1
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 3
29298: PUSH
29299: LD_INT 23
29301: PUSH
29302: LD_INT 0
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: LIST
29317: PPUSH
29318: CALL_OW 69
29322: ST_TO_ADDR
// if not tmp then
29323: LD_VAR 0 2
29327: NOT
29328: IFFALSE 29332
// exit ;
29330: GO 29381
// for i in tmp do
29332: LD_ADDR_VAR 0 1
29336: PUSH
29337: LD_VAR 0 2
29341: PUSH
29342: FOR_IN
29343: IFFALSE 29379
// begin if Crawls ( i ) then
29345: LD_VAR 0 1
29349: PPUSH
29350: CALL_OW 318
29354: IFFALSE 29365
// ComWalk ( i ) ;
29356: LD_VAR 0 1
29360: PPUSH
29361: CALL_OW 138
// SetClass ( i , 2 ) ;
29365: LD_VAR 0 1
29369: PPUSH
29370: LD_INT 2
29372: PPUSH
29373: CALL_OW 336
// end ;
29377: GO 29342
29379: POP
29380: POP
// end ;
29381: PPOPN 2
29383: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
29384: LD_EXP 75
29388: PUSH
29389: LD_EXP 128
29393: AND
29394: IFFALSE 29675
29396: GO 29398
29398: DISABLE
29399: LD_INT 0
29401: PPUSH
29402: PPUSH
29403: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
29404: LD_OWVAR 2
29408: PPUSH
29409: LD_INT 9
29411: PPUSH
29412: LD_INT 1
29414: PPUSH
29415: LD_INT 1
29417: PPUSH
29418: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
29422: LD_INT 9
29424: PPUSH
29425: LD_OWVAR 2
29429: PPUSH
29430: CALL_OW 343
// uc_side := 9 ;
29434: LD_ADDR_OWVAR 20
29438: PUSH
29439: LD_INT 9
29441: ST_TO_ADDR
// uc_nation := 2 ;
29442: LD_ADDR_OWVAR 21
29446: PUSH
29447: LD_INT 2
29449: ST_TO_ADDR
// hc_name := Dark Warrior ;
29450: LD_ADDR_OWVAR 26
29454: PUSH
29455: LD_STRING Dark Warrior
29457: ST_TO_ADDR
// hc_gallery :=  ;
29458: LD_ADDR_OWVAR 33
29462: PUSH
29463: LD_STRING 
29465: ST_TO_ADDR
// hc_noskilllimit := true ;
29466: LD_ADDR_OWVAR 76
29470: PUSH
29471: LD_INT 1
29473: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
29474: LD_ADDR_OWVAR 31
29478: PUSH
29479: LD_INT 30
29481: PUSH
29482: LD_INT 30
29484: PUSH
29485: LD_INT 30
29487: PUSH
29488: LD_INT 30
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: ST_TO_ADDR
// un := CreateHuman ;
29497: LD_ADDR_VAR 0 3
29501: PUSH
29502: CALL_OW 44
29506: ST_TO_ADDR
// hc_noskilllimit := false ;
29507: LD_ADDR_OWVAR 76
29511: PUSH
29512: LD_INT 0
29514: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
29515: LD_VAR 0 3
29519: PPUSH
29520: LD_INT 1
29522: PPUSH
29523: CALL_OW 51
// p := 0 ;
29527: LD_ADDR_VAR 0 2
29531: PUSH
29532: LD_INT 0
29534: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29535: LD_INT 35
29537: PPUSH
29538: CALL_OW 67
// p := p + 1 ;
29542: LD_ADDR_VAR 0 2
29546: PUSH
29547: LD_VAR 0 2
29551: PUSH
29552: LD_INT 1
29554: PLUS
29555: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
29556: LD_VAR 0 3
29560: PPUSH
29561: CALL_OW 256
29565: PUSH
29566: LD_INT 1000
29568: LESS
29569: IFFALSE 29583
// SetLives ( un , 1000 ) ;
29571: LD_VAR 0 3
29575: PPUSH
29576: LD_INT 1000
29578: PPUSH
29579: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
29583: LD_VAR 0 3
29587: PPUSH
29588: LD_INT 81
29590: PUSH
29591: LD_OWVAR 2
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PUSH
29600: LD_INT 91
29602: PUSH
29603: LD_VAR 0 3
29607: PUSH
29608: LD_INT 30
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: LIST
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PPUSH
29620: CALL_OW 69
29624: PPUSH
29625: LD_VAR 0 3
29629: PPUSH
29630: CALL_OW 74
29634: PPUSH
29635: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
29639: LD_VAR 0 2
29643: PUSH
29644: LD_INT 60
29646: GREATER
29647: PUSH
29648: LD_VAR 0 3
29652: PPUSH
29653: CALL_OW 301
29657: OR
29658: IFFALSE 29535
// if un then
29660: LD_VAR 0 3
29664: IFFALSE 29675
// RemoveUnit ( un ) ;
29666: LD_VAR 0 3
29670: PPUSH
29671: CALL_OW 64
// end ; end_of_file
29675: PPOPN 3
29677: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
29678: LD_INT 0
29680: PPUSH
29681: PPUSH
29682: PPUSH
29683: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
29684: LD_VAR 0 1
29688: PPUSH
29689: CALL_OW 264
29693: PUSH
29694: LD_EXP 66
29698: EQUAL
29699: IFFALSE 29771
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
29701: LD_INT 68
29703: PPUSH
29704: LD_VAR 0 1
29708: PPUSH
29709: CALL_OW 255
29713: PPUSH
29714: CALL_OW 321
29718: PUSH
29719: LD_INT 2
29721: EQUAL
29722: IFFALSE 29734
// eff := 70 else
29724: LD_ADDR_VAR 0 4
29728: PUSH
29729: LD_INT 70
29731: ST_TO_ADDR
29732: GO 29742
// eff := 30 ;
29734: LD_ADDR_VAR 0 4
29738: PUSH
29739: LD_INT 30
29741: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
29742: LD_VAR 0 1
29746: PPUSH
29747: CALL_OW 250
29751: PPUSH
29752: LD_VAR 0 1
29756: PPUSH
29757: CALL_OW 251
29761: PPUSH
29762: LD_VAR 0 4
29766: PPUSH
29767: CALL_OW 495
// end ; end ;
29771: LD_VAR 0 2
29775: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
29776: LD_INT 0
29778: PPUSH
// end ;
29779: LD_VAR 0 4
29783: RET
// export function SOS_Command ( cmd ) ; begin
29784: LD_INT 0
29786: PPUSH
// end ;
29787: LD_VAR 0 2
29791: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
29792: LD_VAR 0 1
29796: PUSH
29797: LD_INT 255
29799: EQUAL
29800: PUSH
29801: LD_VAR 0 2
29805: PPUSH
29806: CALL_OW 264
29810: PUSH
29811: LD_INT 14
29813: PUSH
29814: LD_INT 53
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: IN
29821: AND
29822: PUSH
29823: LD_VAR 0 4
29827: PPUSH
29828: LD_VAR 0 5
29832: PPUSH
29833: CALL_OW 488
29837: AND
29838: IFFALSE 29862
// CutTreeXYR ( unit , x , y , 12 ) ;
29840: LD_VAR 0 2
29844: PPUSH
29845: LD_VAR 0 4
29849: PPUSH
29850: LD_VAR 0 5
29854: PPUSH
29855: LD_INT 12
29857: PPUSH
29858: CALL 29865 0 4
// end ;
29862: PPOPN 5
29864: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
29865: LD_INT 0
29867: PPUSH
29868: PPUSH
29869: PPUSH
29870: PPUSH
29871: PPUSH
29872: PPUSH
29873: PPUSH
29874: PPUSH
29875: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
29876: LD_VAR 0 1
29880: NOT
29881: PUSH
29882: LD_VAR 0 2
29886: PPUSH
29887: LD_VAR 0 3
29891: PPUSH
29892: CALL_OW 488
29896: NOT
29897: OR
29898: PUSH
29899: LD_VAR 0 4
29903: NOT
29904: OR
29905: IFFALSE 29909
// exit ;
29907: GO 30249
// list := [ ] ;
29909: LD_ADDR_VAR 0 13
29913: PUSH
29914: EMPTY
29915: ST_TO_ADDR
// if x - r < 0 then
29916: LD_VAR 0 2
29920: PUSH
29921: LD_VAR 0 4
29925: MINUS
29926: PUSH
29927: LD_INT 0
29929: LESS
29930: IFFALSE 29942
// min_x := 0 else
29932: LD_ADDR_VAR 0 7
29936: PUSH
29937: LD_INT 0
29939: ST_TO_ADDR
29940: GO 29958
// min_x := x - r ;
29942: LD_ADDR_VAR 0 7
29946: PUSH
29947: LD_VAR 0 2
29951: PUSH
29952: LD_VAR 0 4
29956: MINUS
29957: ST_TO_ADDR
// if y - r < 0 then
29958: LD_VAR 0 3
29962: PUSH
29963: LD_VAR 0 4
29967: MINUS
29968: PUSH
29969: LD_INT 0
29971: LESS
29972: IFFALSE 29984
// min_y := 0 else
29974: LD_ADDR_VAR 0 8
29978: PUSH
29979: LD_INT 0
29981: ST_TO_ADDR
29982: GO 30000
// min_y := y - r ;
29984: LD_ADDR_VAR 0 8
29988: PUSH
29989: LD_VAR 0 3
29993: PUSH
29994: LD_VAR 0 4
29998: MINUS
29999: ST_TO_ADDR
// max_x := x + r ;
30000: LD_ADDR_VAR 0 9
30004: PUSH
30005: LD_VAR 0 2
30009: PUSH
30010: LD_VAR 0 4
30014: PLUS
30015: ST_TO_ADDR
// max_y := y + r ;
30016: LD_ADDR_VAR 0 10
30020: PUSH
30021: LD_VAR 0 3
30025: PUSH
30026: LD_VAR 0 4
30030: PLUS
30031: ST_TO_ADDR
// for _x = min_x to max_x do
30032: LD_ADDR_VAR 0 11
30036: PUSH
30037: DOUBLE
30038: LD_VAR 0 7
30042: DEC
30043: ST_TO_ADDR
30044: LD_VAR 0 9
30048: PUSH
30049: FOR_TO
30050: IFFALSE 30167
// for _y = min_y to max_y do
30052: LD_ADDR_VAR 0 12
30056: PUSH
30057: DOUBLE
30058: LD_VAR 0 8
30062: DEC
30063: ST_TO_ADDR
30064: LD_VAR 0 10
30068: PUSH
30069: FOR_TO
30070: IFFALSE 30163
// begin if not ValidHex ( _x , _y ) then
30072: LD_VAR 0 11
30076: PPUSH
30077: LD_VAR 0 12
30081: PPUSH
30082: CALL_OW 488
30086: NOT
30087: IFFALSE 30091
// continue ;
30089: GO 30069
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
30091: LD_VAR 0 11
30095: PPUSH
30096: LD_VAR 0 12
30100: PPUSH
30101: CALL_OW 351
30105: PUSH
30106: LD_VAR 0 11
30110: PPUSH
30111: LD_VAR 0 12
30115: PPUSH
30116: CALL_OW 554
30120: AND
30121: IFFALSE 30161
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
30123: LD_ADDR_VAR 0 13
30127: PUSH
30128: LD_VAR 0 13
30132: PPUSH
30133: LD_VAR 0 13
30137: PUSH
30138: LD_INT 1
30140: PLUS
30141: PPUSH
30142: LD_VAR 0 11
30146: PUSH
30147: LD_VAR 0 12
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PPUSH
30156: CALL_OW 2
30160: ST_TO_ADDR
// end ;
30161: GO 30069
30163: POP
30164: POP
30165: GO 30049
30167: POP
30168: POP
// if not list then
30169: LD_VAR 0 13
30173: NOT
30174: IFFALSE 30178
// exit ;
30176: GO 30249
// for i in list do
30178: LD_ADDR_VAR 0 6
30182: PUSH
30183: LD_VAR 0 13
30187: PUSH
30188: FOR_IN
30189: IFFALSE 30247
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
30191: LD_VAR 0 1
30195: PPUSH
30196: LD_STRING M
30198: PUSH
30199: LD_VAR 0 6
30203: PUSH
30204: LD_INT 1
30206: ARRAY
30207: PUSH
30208: LD_VAR 0 6
30212: PUSH
30213: LD_INT 2
30215: ARRAY
30216: PUSH
30217: LD_INT 0
30219: PUSH
30220: LD_INT 0
30222: PUSH
30223: LD_INT 0
30225: PUSH
30226: LD_INT 0
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: LIST
30237: PUSH
30238: EMPTY
30239: LIST
30240: PPUSH
30241: CALL_OW 447
30245: GO 30188
30247: POP
30248: POP
// end ;
30249: LD_VAR 0 5
30253: RET
