// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 50 0 0
// SetDiplomacy ;
  15: CALL 378 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 29
// DebugMode ;
  25: CALL 466 0 0
// PrepareRussian ;
  29: CALL 3086 0 0
// PrepareAmerican ;
  33: CALL 1228 0 0
// PrepareCornell ;
  37: CALL 2315 0 0
// PrepareWesternBase ;
  41: CALL 2541 0 0
// Action ;
  45: CALL 5331 0 0
// end ;
  49: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , ach_counter , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  50: LD_INT 0
  52: PPUSH
// debug := false ;
  53: LD_ADDR_EXP 1
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  61: LD_ADDR_EXP 3
  65: PUSH
  66: LD_STRING 02_
  68: ST_TO_ADDR
// mission_prefix := 03_ ;
  69: LD_ADDR_EXP 2
  73: PUSH
  74: LD_STRING 03_
  76: ST_TO_ADDR
// jmm_units := 0 ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// cornel_units := 0 ;
  85: LD_ADDR_EXP 6
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// bierezov_exist := false ;
  93: LD_ADDR_EXP 7
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// jmm_on_west := false ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// cornel_active := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// cornel_attack := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// cornel_prepared := false ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 133: LD_ADDR_EXP 10
 137: PUSH
 138: LD_INT 4200
 140: ST_TO_ADDR
// frank_can_return := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// solar_builded := false ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// frank_send_to_scout := false ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// jmm_in_veh := false ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// bobby_in_veh := false ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// cyrus_in_veh := false ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// lisa_in_veh := false ;
 189: LD_ADDR_EXP 19
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 197: LD_ADDR_EXP 29
 201: PUSH
 202: LD_INT 25200
 204: PUSH
 205: LD_INT 23100
 207: PUSH
 208: LD_INT 21000
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_OWVAR 67
 220: ARRAY
 221: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 222: LD_ADDR_EXP 20
 226: PUSH
 227: LD_INT 600
 229: PUSH
 230: LD_INT 500
 232: PUSH
 233: LD_INT 400
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_OWVAR 67
 245: ARRAY
 246: ST_TO_ADDR
// end_mission_allowed := false ;
 247: LD_ADDR_EXP 21
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// save_others := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// save_group := [ ] ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// show_query := true ;
 269: LD_ADDR_EXP 24
 273: PUSH
 274: LD_INT 1
 276: ST_TO_ADDR
// wait_for_them := false ;
 277: LD_ADDR_EXP 25
 281: PUSH
 282: LD_INT 0
 284: ST_TO_ADDR
// veh_on_meta := false ;
 285: LD_ADDR_EXP 28
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// send_spec_patrol := false ;
 293: LD_ADDR_EXP 30
 297: PUSH
 298: LD_INT 0
 300: ST_TO_ADDR
// prepare_siege := false ;
 301: LD_ADDR_EXP 31
 305: PUSH
 306: LD_INT 0
 308: ST_TO_ADDR
// send_attack_on_cornel := false ;
 309: LD_ADDR_EXP 32
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 0
 324: ST_TO_ADDR
// game_end := false ;
 325: LD_ADDR_EXP 33
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// lose_counter := 0 ;
 333: LD_ADDR_EXP 34
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// powell_warn := 0 ;
 341: LD_ADDR_EXP 35
 345: PUSH
 346: LD_INT 0
 348: ST_TO_ADDR
// save_counter := 0 ;
 349: LD_ADDR_EXP 36
 353: PUSH
 354: LD_INT 0
 356: ST_TO_ADDR
// cornel_saved := false ;
 357: LD_ADDR_EXP 27
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// ach_counter := 0 ;
 365: LD_ADDR_EXP 13
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// end ;
 373: LD_VAR 0 1
 377: RET
// function SetDiplomacy ; begin
 378: LD_INT 0
 380: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 4
 386: PPUSH
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 8
 402: PPUSH
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 1
 408: PPUSH
 409: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 413: LD_INT 3
 415: PPUSH
 416: LD_INT 6
 418: PPUSH
 419: LD_INT 1
 421: PPUSH
 422: LD_INT 1
 424: PPUSH
 425: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 429: LD_INT 4
 431: PPUSH
 432: LD_INT 6
 434: PPUSH
 435: LD_INT 0
 437: PPUSH
 438: LD_INT 1
 440: PPUSH
 441: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 445: LD_INT 3
 447: PPUSH
 448: LD_INT 8
 450: PPUSH
 451: LD_INT 0
 453: PPUSH
 454: LD_INT 1
 456: PPUSH
 457: CALL_OW 80
// end ;
 461: LD_VAR 0 1
 465: RET
// export function DebugMode ; var i ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// FogOff ( 1 ) ;
 470: LD_INT 1
 472: PPUSH
 473: CALL_OW 344
// debug_strings := [ ] ;
 477: LD_ADDR_OWVAR 48
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// end ; end_of_file
 484: LD_VAR 0 1
 488: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 489: LD_INT 0
 491: PPUSH
 492: PPUSH
// if exist_mode then
 493: LD_VAR 0 2
 497: IFFALSE 522
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_EXP 3
 508: PUSH
 509: LD_VAR 0 1
 513: STR
 514: PPUSH
 515: CALL_OW 34
 519: ST_TO_ADDR
 520: GO 537
// unit := NewCharacter ( ident ) ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_VAR 0 1
 531: PPUSH
 532: CALL_OW 25
 536: ST_TO_ADDR
// result := unit ;
 537: LD_ADDR_VAR 0 3
 541: PUSH
 542: LD_VAR 0 4
 546: ST_TO_ADDR
// end ;
 547: LD_VAR 0 3
 551: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 552: LD_INT 0
 554: PPUSH
// uc_side := side ;
 555: LD_ADDR_OWVAR 20
 559: PUSH
 560: LD_VAR 0 1
 564: ST_TO_ADDR
// uc_nation := nation ;
 565: LD_ADDR_OWVAR 21
 569: PUSH
 570: LD_VAR 0 2
 574: ST_TO_ADDR
// vc_chassis := chassis ;
 575: LD_ADDR_OWVAR 37
 579: PUSH
 580: LD_VAR 0 3
 584: ST_TO_ADDR
// vc_engine := engine ;
 585: LD_ADDR_OWVAR 39
 589: PUSH
 590: LD_VAR 0 4
 594: ST_TO_ADDR
// vc_control := control ;
 595: LD_ADDR_OWVAR 38
 599: PUSH
 600: LD_VAR 0 5
 604: ST_TO_ADDR
// vc_weapon := weapon ;
 605: LD_ADDR_OWVAR 40
 609: PUSH
 610: LD_VAR 0 6
 614: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 615: LD_ADDR_OWVAR 41
 619: PUSH
 620: LD_VAR 0 7
 624: ST_TO_ADDR
// result := CreateVehicle ;
 625: LD_ADDR_VAR 0 8
 629: PUSH
 630: CALL_OW 45
 634: ST_TO_ADDR
// end ;
 635: LD_VAR 0 8
 639: RET
// export function SayX ( units , ident ) ; var i ; begin
 640: LD_INT 0
 642: PPUSH
 643: PPUSH
// result := false ;
 644: LD_ADDR_VAR 0 3
 648: PUSH
 649: LD_INT 0
 651: ST_TO_ADDR
// if not units then
 652: LD_VAR 0 1
 656: NOT
 657: IFFALSE 661
// exit ;
 659: GO 715
// for i in units do
 661: LD_ADDR_VAR 0 4
 665: PUSH
 666: LD_VAR 0 1
 670: PUSH
 671: FOR_IN
 672: IFFALSE 713
// if IsOk ( i ) then
 674: LD_VAR 0 4
 678: PPUSH
 679: CALL_OW 302
 683: IFFALSE 711
// begin Say ( i , ident ) ;
 685: LD_VAR 0 4
 689: PPUSH
 690: LD_VAR 0 2
 694: PPUSH
 695: CALL_OW 88
// result := i ;
 699: LD_ADDR_VAR 0 3
 703: PUSH
 704: LD_VAR 0 4
 708: ST_TO_ADDR
// break ;
 709: GO 713
// end ;
 711: GO 671
 713: POP
 714: POP
// end ;
 715: LD_VAR 0 3
 719: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 720: LD_INT 0
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
// for i = 1 to count do
 726: LD_ADDR_VAR 0 8
 730: PUSH
 731: DOUBLE
 732: LD_INT 1
 734: DEC
 735: ST_TO_ADDR
 736: LD_VAR 0 6
 740: PUSH
 741: FOR_TO
 742: IFFALSE 823
// begin uc_side = side ;
 744: LD_ADDR_OWVAR 20
 748: PUSH
 749: LD_VAR 0 1
 753: ST_TO_ADDR
// uc_nation = nation ;
 754: LD_ADDR_OWVAR 21
 758: PUSH
 759: LD_VAR 0 2
 763: ST_TO_ADDR
// hc_gallery =  ;
 764: LD_ADDR_OWVAR 33
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// hc_name =  ;
 772: LD_ADDR_OWVAR 26
 776: PUSH
 777: LD_STRING 
 779: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 780: LD_INT 0
 782: PPUSH
 783: LD_VAR 0 5
 787: PPUSH
 788: LD_VAR 0 4
 792: PPUSH
 793: CALL_OW 380
// un = CreateHuman ;
 797: LD_ADDR_VAR 0 10
 801: PUSH
 802: CALL_OW 44
 806: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 807: LD_VAR 0 10
 811: PPUSH
 812: LD_VAR 0 3
 816: PPUSH
 817: CALL_OW 52
// end ;
 821: GO 741
 823: POP
 824: POP
// end ;
 825: LD_VAR 0 7
 829: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 830: LD_INT 0
 832: PPUSH
 833: PPUSH
 834: PPUSH
// uc_side := GetSide ( b ) ;
 835: LD_ADDR_OWVAR 20
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 255
 849: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 850: LD_ADDR_OWVAR 21
 854: PUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: CALL_OW 248
 864: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 865: LD_INT 0
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: LD_VAR 0 1
 875: PPUSH
 876: CALL_OW 380
// un = CreateHuman ;
 880: LD_ADDR_VAR 0 4
 884: PUSH
 885: CALL_OW 44
 889: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 890: LD_ADDR_VAR 0 5
 894: PUSH
 895: LD_VAR 0 2
 899: PPUSH
 900: CALL_OW 254
 904: PUSH
 905: LD_INT 3
 907: MINUS
 908: ST_TO_ADDR
// if dir < 0 then
 909: LD_VAR 0 5
 913: PUSH
 914: LD_INT 0
 916: LESS
 917: IFFALSE 933
// dir := 6 + dir ;
 919: LD_ADDR_VAR 0 5
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: LD_VAR 0 5
 931: PLUS
 932: ST_TO_ADDR
// SetDir ( un , dir ) ;
 933: LD_VAR 0 4
 937: PPUSH
 938: LD_VAR 0 5
 942: PPUSH
 943: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 947: LD_VAR 0 4
 951: PPUSH
 952: LD_VAR 0 2
 956: PPUSH
 957: CALL_OW 52
// end ;
 961: LD_VAR 0 3
 965: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 966: LD_INT 0
 968: PPUSH
 969: PPUSH
 970: PPUSH
// result := false ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 979: LD_ADDR_VAR 0 3
 983: PUSH
 984: LD_INT 22
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 34
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: PPUSH
1008: CALL_OW 69
1012: ST_TO_ADDR
// for i in filter do
1013: LD_ADDR_VAR 0 4
1017: PUSH
1018: LD_VAR 0 3
1022: PUSH
1023: FOR_IN
1024: IFFALSE 1055
// if IsDrivenBy ( i ) = unit then
1026: LD_VAR 0 4
1030: PPUSH
1031: CALL_OW 311
1035: PUSH
1036: LD_VAR 0 1
1040: EQUAL
1041: IFFALSE 1053
// begin result := true ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 1
1050: ST_TO_ADDR
// break ;
1051: GO 1055
// end ;
1053: GO 1023
1055: POP
1056: POP
// end ;
1057: LD_VAR 0 2
1061: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1062: LD_INT 0
1064: PPUSH
1065: PPUSH
// result := false ;
1066: LD_ADDR_VAR 0 2
1070: PUSH
1071: LD_INT 0
1073: ST_TO_ADDR
// if not blist then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1127
// for i in blist do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: LD_VAR 0 1
1092: PUSH
1093: FOR_IN
1094: IFFALSE 1125
// if UnitsInside ( i ) < 6 then
1096: LD_VAR 0 3
1100: PPUSH
1101: CALL_OW 313
1105: PUSH
1106: LD_INT 6
1108: LESS
1109: IFFALSE 1123
// begin result := i ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 3
1120: ST_TO_ADDR
// break ;
1121: GO 1125
// end ;
1123: GO 1093
1125: POP
1126: POP
// end ;
1127: LD_VAR 0 2
1131: RET
// export function Count ( timer , mode ) ; begin
1132: LD_INT 0
1134: PPUSH
// if not timer then
1135: LD_VAR 0 1
1139: NOT
1140: IFFALSE 1144
// exit ;
1142: GO 1195
// if mode in [ asc , up , + ] then
1144: LD_VAR 0 2
1148: PUSH
1149: LD_STRING asc
1151: PUSH
1152: LD_STRING up
1154: PUSH
1155: LD_STRING +
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: IN
1163: IFFALSE 1181
// result := timer + 0 0$01 else
1165: LD_ADDR_VAR 0 3
1169: PUSH
1170: LD_VAR 0 1
1174: PUSH
1175: LD_INT 35
1177: PLUS
1178: ST_TO_ADDR
1179: GO 1195
// result := timer - 0 0$01 ;
1181: LD_ADDR_VAR 0 3
1185: PUSH
1186: LD_VAR 0 1
1190: PUSH
1191: LD_INT 35
1193: MINUS
1194: ST_TO_ADDR
// end ;
1195: LD_VAR 0 3
1199: RET
// export function Video ( mode ) ; begin
1200: LD_INT 0
1202: PPUSH
// ingame_video = mode ;
1203: LD_ADDR_OWVAR 52
1207: PUSH
1208: LD_VAR 0 1
1212: ST_TO_ADDR
// interface_hidden = mode ;
1213: LD_ADDR_OWVAR 54
1217: PUSH
1218: LD_VAR 0 1
1222: ST_TO_ADDR
// end ; end_of_file
1223: LD_VAR 0 2
1227: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1228: LD_INT 0
1230: PPUSH
1231: PPUSH
1232: PPUSH
1233: PPUSH
1234: PPUSH
1235: PPUSH
1236: PPUSH
1237: PPUSH
// uc_side := 4 ;
1238: LD_ADDR_OWVAR 20
1242: PUSH
1243: LD_INT 4
1245: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1246: LD_ADDR_EXP 46
1250: PUSH
1251: LD_STRING Powell
1253: PPUSH
1254: LD_INT 0
1256: PPUSH
1257: CALL 489 0 2
1261: ST_TO_ADDR
// uc_side := 1 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
// uc_nation := 1 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 1
1277: ST_TO_ADDR
// if debug then
1278: LD_EXP 1
1282: IFFALSE 1412
// begin for i = 1 to 4 do
1284: LD_ADDR_VAR 0 2
1288: PUSH
1289: DOUBLE
1290: LD_INT 1
1292: DEC
1293: ST_TO_ADDR
1294: LD_INT 4
1296: PUSH
1297: FOR_TO
1298: IFFALSE 1349
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1300: LD_INT 0
1302: PPUSH
1303: LD_INT 1
1305: PPUSH
1306: LD_INT 2
1308: PPUSH
1309: CALL_OW 12
1313: PPUSH
1314: LD_INT 3
1316: PPUSH
1317: CALL_OW 380
// un := CreateHuman ;
1321: LD_ADDR_VAR 0 3
1325: PUSH
1326: CALL_OW 44
1330: ST_TO_ADDR
// others := others ^ un ;
1331: LD_ADDR_VAR 0 5
1335: PUSH
1336: LD_VAR 0 5
1340: PUSH
1341: LD_VAR 0 3
1345: ADD
1346: ST_TO_ADDR
// end ;
1347: GO 1297
1349: POP
1350: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1351: LD_ADDR_VAR 0 6
1355: PUSH
1356: LD_INT 21
1358: PUSH
1359: LD_INT 1
1361: PUSH
1362: LD_INT 1
1364: PUSH
1365: LD_INT 51
1367: PUSH
1368: LD_INT 90
1370: PUSH
1371: LD_INT 504
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: PUSH
1382: LD_INT 21
1384: PUSH
1385: LD_INT 1
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: LD_INT 51
1393: PUSH
1394: LD_INT 80
1396: PUSH
1397: LD_INT 750
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1412: LD_ADDR_EXP 37
1416: PUSH
1417: LD_STRING JMM
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: CALL 489 0 2
1430: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1431: LD_ADDR_EXP 38
1435: PUSH
1436: LD_STRING Bobby
1438: PPUSH
1439: LD_EXP 1
1443: NOT
1444: PPUSH
1445: CALL 489 0 2
1449: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1450: LD_ADDR_EXP 39
1454: PUSH
1455: LD_STRING Cyrus
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: CALL 489 0 2
1468: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1469: LD_ADDR_EXP 40
1473: PUSH
1474: LD_STRING Lisa
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: CALL 489 0 2
1487: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1488: LD_ADDR_EXP 41
1492: PUSH
1493: LD_STRING Khatam
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: CALL 489 0 2
1506: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1507: LD_ADDR_EXP 42
1511: PUSH
1512: LD_STRING Brian
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: CALL 489 0 2
1525: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1526: LD_ADDR_EXP 43
1530: PUSH
1531: LD_STRING Jerry
1533: PPUSH
1534: LD_EXP 1
1538: NOT
1539: PPUSH
1540: CALL 489 0 2
1544: ST_TO_ADDR
// if Bobby then
1545: LD_EXP 38
1549: IFFALSE 1580
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 4
1565: PUSH
1566: LD_INT 1
1568: PLUS
1569: PPUSH
1570: LD_EXP 38
1574: PPUSH
1575: CALL_OW 2
1579: ST_TO_ADDR
// if Cyrus then
1580: LD_EXP 39
1584: IFFALSE 1615
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_VAR 0 4
1595: PPUSH
1596: LD_VAR 0 4
1600: PUSH
1601: LD_INT 1
1603: PLUS
1604: PPUSH
1605: LD_EXP 39
1609: PPUSH
1610: CALL_OW 2
1614: ST_TO_ADDR
// if Lisa then
1615: LD_EXP 40
1619: IFFALSE 1650
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1621: LD_ADDR_VAR 0 4
1625: PUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: LD_VAR 0 4
1635: PUSH
1636: LD_INT 1
1638: PLUS
1639: PPUSH
1640: LD_EXP 40
1644: PPUSH
1645: CALL_OW 2
1649: ST_TO_ADDR
// if Khatam then
1650: LD_EXP 41
1654: IFFALSE 1685
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1656: LD_ADDR_VAR 0 4
1660: PUSH
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_VAR 0 4
1670: PUSH
1671: LD_INT 1
1673: PLUS
1674: PPUSH
1675: LD_EXP 41
1679: PPUSH
1680: CALL_OW 2
1684: ST_TO_ADDR
// if Brian then
1685: LD_EXP 42
1689: IFFALSE 1720
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_VAR 0 4
1700: PPUSH
1701: LD_VAR 0 4
1705: PUSH
1706: LD_INT 1
1708: PLUS
1709: PPUSH
1710: LD_EXP 42
1714: PPUSH
1715: CALL_OW 2
1719: ST_TO_ADDR
// if Jerry then
1720: LD_EXP 43
1724: IFFALSE 1755
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1726: LD_ADDR_VAR 0 4
1730: PUSH
1731: LD_VAR 0 4
1735: PPUSH
1736: LD_VAR 0 4
1740: PUSH
1741: LD_INT 1
1743: PLUS
1744: PPUSH
1745: LD_EXP 43
1749: PPUSH
1750: CALL_OW 2
1754: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1755: LD_STRING 02_other_survivors
1757: PPUSH
1758: CALL_OW 28
1762: IFFALSE 1777
// others := CreateCharacterSet ( 02_other_survivors ) ;
1764: LD_ADDR_VAR 0 5
1768: PUSH
1769: LD_STRING 02_other_survivors
1771: PPUSH
1772: CALL_OW 31
1776: ST_TO_ADDR
// if others then
1777: LD_VAR 0 5
1781: IFFALSE 1806
// begin tmp := tmp ^ others ;
1783: LD_ADDR_VAR 0 4
1787: PUSH
1788: LD_VAR 0 4
1792: PUSH
1793: LD_VAR 0 5
1797: ADD
1798: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1799: LD_STRING 02_other_survivors
1801: PPUSH
1802: CALL_OW 40
// end ; jmm_units := tmp ;
1806: LD_ADDR_EXP 4
1810: PUSH
1811: LD_VAR 0 4
1815: ST_TO_ADDR
// if not vehicles then
1816: LD_VAR 0 6
1820: NOT
1821: IFFALSE 1839
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1823: LD_ADDR_VAR 0 6
1827: PUSH
1828: LD_STRING 02_tanks_1
1830: PPUSH
1831: LD_INT 0
1833: PPUSH
1834: CALL_OW 30
1838: ST_TO_ADDR
// if vehicles then
1839: LD_VAR 0 6
1843: IFFALSE 2037
// begin got_mech := false ;
1845: LD_ADDR_VAR 0 7
1849: PUSH
1850: LD_INT 0
1852: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 3
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PPUSH
1868: CALL_OW 72
1872: IFFALSE 1882
// got_mech := true ;
1874: LD_ADDR_VAR 0 7
1878: PUSH
1879: LD_INT 1
1881: ST_TO_ADDR
// for i = 1 to vehicles do
1882: LD_ADDR_VAR 0 2
1886: PUSH
1887: DOUBLE
1888: LD_INT 1
1890: DEC
1891: ST_TO_ADDR
1892: LD_VAR 0 6
1896: PUSH
1897: FOR_TO
1898: IFFALSE 2035
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1900: LD_ADDR_VAR 0 3
1904: PUSH
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 3
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 2
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 3
1954: ARRAY
1955: PPUSH
1956: LD_VAR 0 6
1960: PUSH
1961: LD_VAR 0 2
1965: ARRAY
1966: PUSH
1967: LD_INT 4
1969: ARRAY
1970: PPUSH
1971: LD_INT 40
1973: PPUSH
1974: CALL 552 0 7
1978: ST_TO_ADDR
// if not got_mech then
1979: LD_VAR 0 7
1983: NOT
1984: IFFALSE 2010
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 6
1995: PUSH
1996: LD_VAR 0 2
2000: ARRAY
2001: PUSH
2002: LD_INT 6
2004: ARRAY
2005: PPUSH
2006: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
2010: LD_ADDR_VAR 0 4
2014: PUSH
2015: LD_VAR 0 4
2019: PPUSH
2020: LD_INT 1
2022: PPUSH
2023: LD_VAR 0 3
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
// end ;
2033: GO 1897
2035: POP
2036: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2037: LD_EXP 37
2041: PPUSH
2042: LD_INT 194
2044: PPUSH
2045: LD_INT 119
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 48
// if tmp then
2055: LD_VAR 0 4
2059: IFFALSE 2247
// begin for i in tmp do
2061: LD_ADDR_VAR 0 2
2065: PUSH
2066: LD_VAR 0 4
2070: PUSH
2071: FOR_IN
2072: IFFALSE 2245
// begin if GetClass ( i ) <> 1 and i <> Khatam then
2074: LD_VAR 0 2
2078: PPUSH
2079: CALL_OW 257
2083: PUSH
2084: LD_INT 1
2086: NONEQUAL
2087: PUSH
2088: LD_VAR 0 2
2092: PUSH
2093: LD_EXP 41
2097: NONEQUAL
2098: AND
2099: IFFALSE 2113
// SetClass ( i , 1 ) ;
2101: LD_VAR 0 2
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: CALL_OW 336
// if i = Khatam then
2113: LD_VAR 0 2
2117: PUSH
2118: LD_EXP 41
2122: EQUAL
2123: IFFALSE 2137
// SetClass ( i , 4 ) ;
2125: LD_VAR 0 2
2129: PPUSH
2130: LD_INT 4
2132: PPUSH
2133: CALL_OW 336
// empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2137: LD_ADDR_VAR 0 8
2141: PUSH
2142: LD_INT 22
2144: PUSH
2145: LD_INT 1
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 21
2154: PUSH
2155: LD_INT 2
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: LD_INT 58
2164: PUSH
2165: EMPTY
2166: LIST
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 69
2177: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2178: LD_VAR 0 2
2182: PPUSH
2183: CALL_OW 247
2187: PUSH
2188: LD_INT 1
2190: EQUAL
2191: PUSH
2192: LD_VAR 0 8
2196: AND
2197: IFFALSE 2219
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2199: LD_VAR 0 2
2203: PPUSH
2204: LD_VAR 0 8
2208: PUSH
2209: LD_INT 1
2211: ARRAY
2212: PPUSH
2213: CALL_OW 52
2217: GO 2234
// PlaceUnitArea ( i , startArea , false ) ;
2219: LD_VAR 0 2
2223: PPUSH
2224: LD_INT 1
2226: PPUSH
2227: LD_INT 0
2229: PPUSH
2230: CALL_OW 49
// ComHold ( i ) ;
2234: LD_VAR 0 2
2238: PPUSH
2239: CALL_OW 140
// end ;
2243: GO 2071
2245: POP
2246: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2247: LD_ADDR_EXP 7
2251: PUSH
2252: LD_STRING 02_mikhailStatus_1
2254: PPUSH
2255: LD_INT 0
2257: PPUSH
2258: CALL_OW 30
2262: ST_TO_ADDR
// if not bierezov_exist and not debug then
2263: LD_EXP 7
2267: NOT
2268: PUSH
2269: LD_EXP 1
2273: NOT
2274: AND
2275: IFFALSE 2279
// exit ;
2277: GO 2310
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2279: LD_ADDR_EXP 45
2283: PUSH
2284: LD_STRING Mikhail
2286: PPUSH
2287: LD_INT 0
2289: PPUSH
2290: CALL 489 0 2
2294: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2295: LD_EXP 45
2299: PPUSH
2300: LD_INT 1
2302: PPUSH
2303: LD_INT 0
2305: PPUSH
2306: CALL_OW 49
// end ;
2310: LD_VAR 0 1
2314: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2315: LD_INT 0
2317: PPUSH
2318: PPUSH
2319: PPUSH
2320: PPUSH
// uc_side := 4 ;
2321: LD_ADDR_OWVAR 20
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// uc_nation := 1 ;
2329: LD_ADDR_OWVAR 21
2333: PUSH
2334: LD_INT 1
2336: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2337: LD_ADDR_EXP 44
2341: PUSH
2342: LD_STRING Cornell
2344: PPUSH
2345: LD_INT 0
2347: PPUSH
2348: CALL 489 0 2
2352: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2353: LD_ADDR_EXP 6
2357: PUSH
2358: LD_INT 9
2360: PUSH
2361: LD_EXP 4
2365: MINUS
2366: ST_TO_ADDR
// tmp := [ ] ;
2367: LD_ADDR_VAR 0 2
2371: PUSH
2372: EMPTY
2373: ST_TO_ADDR
// if cornel_units < 4 then
2374: LD_EXP 6
2378: PUSH
2379: LD_INT 4
2381: LESS
2382: IFFALSE 2392
// cornel_units := 4 ;
2384: LD_ADDR_EXP 6
2388: PUSH
2389: LD_INT 4
2391: ST_TO_ADDR
// for i = 1 to cornel_units do
2392: LD_ADDR_VAR 0 4
2396: PUSH
2397: DOUBLE
2398: LD_INT 1
2400: DEC
2401: ST_TO_ADDR
2402: LD_EXP 6
2406: PUSH
2407: FOR_TO
2408: IFFALSE 2506
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2410: LD_INT 0
2412: PPUSH
2413: LD_INT 1
2415: PUSH
2416: LD_INT 1
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: LD_INT 2
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_VAR 0 4
2439: PUSH
2440: LD_INT 5
2442: MOD
2443: PUSH
2444: LD_INT 1
2446: PLUS
2447: ARRAY
2448: PPUSH
2449: LD_INT 2
2451: PPUSH
2452: CALL_OW 380
// un := CreateHuman ;
2456: LD_ADDR_VAR 0 3
2460: PUSH
2461: CALL_OW 44
2465: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2466: LD_ADDR_VAR 0 2
2470: PUSH
2471: LD_VAR 0 2
2475: PPUSH
2476: LD_INT 1
2478: PPUSH
2479: LD_VAR 0 3
2483: PPUSH
2484: CALL_OW 2
2488: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2489: LD_VAR 0 3
2493: PPUSH
2494: LD_INT 2
2496: PPUSH
2497: LD_INT 0
2499: PPUSH
2500: CALL_OW 49
// end ;
2504: GO 2407
2506: POP
2507: POP
// cornel_units := tmp ;
2508: LD_ADDR_EXP 6
2512: PUSH
2513: LD_VAR 0 2
2517: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2518: LD_EXP 44
2522: PPUSH
2523: LD_INT 191
2525: PPUSH
2526: LD_INT 106
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: CALL_OW 48
// end ;
2536: LD_VAR 0 1
2540: RET
// export function PrepareWesternBase ; var i ; begin
2541: LD_INT 0
2543: PPUSH
2544: PPUSH
// uc_side := 8 ;
2545: LD_ADDR_OWVAR 20
2549: PUSH
2550: LD_INT 8
2552: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2553: LD_ADDR_EXP 47
2557: PUSH
2558: LD_STRING Lynch
2560: PPUSH
2561: LD_INT 0
2563: PPUSH
2564: CALL 489 0 2
2568: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2569: LD_ADDR_EXP 48
2573: PUSH
2574: LD_STRING Walker
2576: PPUSH
2577: LD_INT 0
2579: PPUSH
2580: CALL 489 0 2
2584: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2585: LD_ADDR_EXP 49
2589: PUSH
2590: LD_STRING Turner
2592: PPUSH
2593: LD_INT 0
2595: PPUSH
2596: CALL 489 0 2
2600: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2601: LD_ADDR_EXP 50
2605: PUSH
2606: LD_STRING Jillian
2608: PPUSH
2609: LD_INT 0
2611: PPUSH
2612: CALL 489 0 2
2616: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2617: LD_ADDR_VAR 0 2
2621: PUSH
2622: LD_EXP 47
2626: PUSH
2627: LD_EXP 48
2631: PUSH
2632: LD_EXP 49
2636: PUSH
2637: LD_EXP 50
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: PUSH
2648: FOR_IN
2649: IFFALSE 2677
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2651: LD_VAR 0 2
2655: PPUSH
2656: LD_INT 3
2658: PPUSH
2659: LD_INT 0
2661: PPUSH
2662: CALL_OW 49
// ComHold ( i ) ;
2666: LD_VAR 0 2
2670: PPUSH
2671: CALL_OW 140
// end ;
2675: GO 2648
2677: POP
2678: POP
// end ;
2679: LD_VAR 0 1
2683: RET
// export function SelectGroup ; var units , selected , i ; begin
2684: LD_INT 0
2686: PPUSH
2687: PPUSH
2688: PPUSH
2689: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2690: LD_ADDR_VAR 0 2
2694: PUSH
2695: LD_EXP 37
2699: PUSH
2700: LD_INT -3
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: PUSH
2707: LD_EXP 4
2711: ADD
2712: PUSH
2713: LD_INT -2
2715: PUSH
2716: LD_INT -4
2718: PUSH
2719: LD_EXP 44
2723: PUSH
2724: LD_EXP 45
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: LIST
2734: ADD
2735: PUSH
2736: LD_INT -3
2738: PUSH
2739: EMPTY
2740: LIST
2741: ADD
2742: PUSH
2743: LD_EXP 6
2747: ADD
2748: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 37
2758: PUSH
2759: LD_STRING Select five characters to go with you
2761: PPUSH
2762: LD_INT 4
2764: PPUSH
2765: LD_INT 4
2767: PPUSH
2768: LD_VAR 0 2
2772: PPUSH
2773: EMPTY
2774: PPUSH
2775: CALL_OW 42
2779: ADD
2780: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2781: LD_ADDR_EXP 6
2785: PUSH
2786: LD_EXP 4
2790: PUSH
2791: LD_EXP 6
2795: UNION
2796: PUSH
2797: LD_VAR 0 3
2801: DIFF
2802: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2803: LD_ADDR_VAR 0 4
2807: PUSH
2808: LD_EXP 6
2812: PUSH
2813: LD_EXP 45
2817: ADD
2818: PUSH
2819: FOR_IN
2820: IFFALSE 2851
// if GetSide ( i ) = 1 then
2822: LD_VAR 0 4
2826: PPUSH
2827: CALL_OW 255
2831: PUSH
2832: LD_INT 1
2834: EQUAL
2835: IFFALSE 2849
// SetSide ( i , 4 ) ;
2837: LD_VAR 0 4
2841: PPUSH
2842: LD_INT 4
2844: PPUSH
2845: CALL_OW 235
2849: GO 2819
2851: POP
2852: POP
// for i in selected do
2853: LD_ADDR_VAR 0 4
2857: PUSH
2858: LD_VAR 0 3
2862: PUSH
2863: FOR_IN
2864: IFFALSE 2895
// if GetSide ( i ) = 4 then
2866: LD_VAR 0 4
2870: PPUSH
2871: CALL_OW 255
2875: PUSH
2876: LD_INT 4
2878: EQUAL
2879: IFFALSE 2893
// SetSide ( i , 1 ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 1
2888: PPUSH
2889: CALL_OW 235
2893: GO 2863
2895: POP
2896: POP
// jmm_units := jmm_units diff cornel_units ;
2897: LD_ADDR_EXP 4
2901: PUSH
2902: LD_EXP 4
2906: PUSH
2907: LD_EXP 6
2911: DIFF
2912: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2913: LD_EXP 38
2917: PPUSH
2918: CALL_OW 255
2922: PUSH
2923: LD_INT 4
2925: EQUAL
2926: IFFALSE 2941
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2928: LD_EXP 3
2932: PUSH
2933: LD_STRING Bobby
2935: STR
2936: PPUSH
2937: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2941: LD_EXP 39
2945: PPUSH
2946: CALL_OW 255
2950: PUSH
2951: LD_INT 4
2953: EQUAL
2954: IFFALSE 2969
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2956: LD_EXP 3
2960: PUSH
2961: LD_STRING Cyrus
2963: STR
2964: PPUSH
2965: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2969: LD_EXP 40
2973: PPUSH
2974: CALL_OW 255
2978: PUSH
2979: LD_INT 4
2981: EQUAL
2982: IFFALSE 2997
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2984: LD_EXP 3
2988: PUSH
2989: LD_STRING Lisa
2991: STR
2992: PPUSH
2993: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2997: LD_EXP 41
3001: PPUSH
3002: CALL_OW 255
3006: PUSH
3007: LD_INT 4
3009: EQUAL
3010: IFFALSE 3025
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
3012: LD_EXP 3
3016: PUSH
3017: LD_STRING Khatam
3019: STR
3020: PPUSH
3021: CALL_OW 40
// if GetSide ( Brian ) = 4 then
3025: LD_EXP 42
3029: PPUSH
3030: CALL_OW 255
3034: PUSH
3035: LD_INT 4
3037: EQUAL
3038: IFFALSE 3053
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
3040: LD_EXP 3
3044: PUSH
3045: LD_STRING Brian
3047: STR
3048: PPUSH
3049: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
3053: LD_EXP 43
3057: PPUSH
3058: CALL_OW 255
3062: PUSH
3063: LD_INT 4
3065: EQUAL
3066: IFFALSE 3081
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
3068: LD_EXP 3
3072: PUSH
3073: LD_STRING Jerry
3075: STR
3076: PPUSH
3077: CALL_OW 40
// end ; end_of_file
3081: LD_VAR 0 1
3085: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3086: LD_INT 0
3088: PPUSH
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
3100: PPUSH
// ru_alert := false ;
3101: LD_ADDR_EXP 60
3105: PUSH
3106: LD_INT 0
3108: ST_TO_ADDR
// ru_produce_list := [ ] ;
3109: LD_ADDR_EXP 57
3113: PUSH
3114: EMPTY
3115: ST_TO_ADDR
// if Difficulty > 1 then
3116: LD_OWVAR 67
3120: PUSH
3121: LD_INT 1
3123: GREATER
3124: IFFALSE 3212
// begin uc_side := 3 ;
3126: LD_ADDR_OWVAR 20
3130: PUSH
3131: LD_INT 3
3133: ST_TO_ADDR
// uc_nation := 3 ;
3134: LD_ADDR_OWVAR 21
3138: PUSH
3139: LD_INT 3
3141: ST_TO_ADDR
// bc_type := b_breastwork ;
3142: LD_ADDR_OWVAR 42
3146: PUSH
3147: LD_INT 31
3149: ST_TO_ADDR
// bc_level := Difficulty ;
3150: LD_ADDR_OWVAR 43
3154: PUSH
3155: LD_OWVAR 67
3159: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3160: LD_INT 22
3162: PPUSH
3163: LD_INT 14
3165: PPUSH
3166: LD_INT 0
3168: PPUSH
3169: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3173: LD_INT 48
3175: PPUSH
3176: LD_INT 46
3178: PPUSH
3179: LD_INT 0
3181: PPUSH
3182: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3186: LD_INT 86
3188: PPUSH
3189: LD_INT 65
3191: PPUSH
3192: LD_INT 5
3194: PPUSH
3195: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3199: LD_INT 165
3201: PPUSH
3202: LD_INT 73
3204: PPUSH
3205: LD_INT 5
3207: PPUSH
3208: CALL_OW 47
// end ; if Difficulty = 3 then
3212: LD_OWVAR 67
3216: PUSH
3217: LD_INT 3
3219: EQUAL
3220: IFFALSE 3235
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3222: LD_INT 51
3224: PPUSH
3225: LD_INT 3
3227: PPUSH
3228: LD_INT 2
3230: PPUSH
3231: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3235: LD_ADDR_VAR 0 7
3239: PUSH
3240: LD_INT 22
3242: PUSH
3243: LD_INT 3
3245: PUSH
3246: EMPTY
3247: LIST
3248: LIST
3249: PUSH
3250: LD_INT 2
3252: PUSH
3253: LD_INT 30
3255: PUSH
3256: LD_INT 31
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 30
3265: PUSH
3266: LD_INT 32
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 69
3286: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3287: LD_ADDR_VAR 0 8
3291: PUSH
3292: LD_INT 22
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 30
3304: PUSH
3305: LD_INT 4
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: PPUSH
3316: CALL_OW 69
3320: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3321: LD_ADDR_VAR 0 10
3325: PUSH
3326: LD_INT 22
3328: PUSH
3329: LD_INT 3
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: LD_INT 30
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: PPUSH
3350: CALL_OW 69
3354: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3355: LD_ADDR_VAR 0 9
3359: PUSH
3360: LD_INT 22
3362: PUSH
3363: LD_INT 3
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: PUSH
3370: LD_INT 30
3372: PUSH
3373: LD_INT 6
3375: PUSH
3376: EMPTY
3377: LIST
3378: LIST
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PPUSH
3384: CALL_OW 69
3388: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3389: LD_ADDR_VAR 0 2
3393: PUSH
3394: LD_INT 22
3396: PUSH
3397: LD_INT 3
3399: PUSH
3400: EMPTY
3401: LIST
3402: LIST
3403: PUSH
3404: LD_INT 30
3406: PUSH
3407: LD_INT 1
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PPUSH
3418: CALL_OW 69
3422: PUSH
3423: FOR_IN
3424: IFFALSE 3468
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3426: LD_VAR 0 2
3430: PPUSH
3431: CALL_OW 274
3435: PPUSH
3436: LD_INT 1
3438: PPUSH
3439: LD_INT 5000
3441: PPUSH
3442: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 274
3455: PPUSH
3456: LD_INT 2
3458: PPUSH
3459: LD_INT 3000
3461: PPUSH
3462: CALL_OW 277
// end ;
3466: GO 3423
3468: POP
3469: POP
// uc_side := 3 ;
3470: LD_ADDR_OWVAR 20
3474: PUSH
3475: LD_INT 3
3477: ST_TO_ADDR
// uc_nation := 3 ;
3478: LD_ADDR_OWVAR 21
3482: PUSH
3483: LD_INT 3
3485: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3486: LD_ADDR_VAR 0 11
3490: PUSH
3491: LD_INT 2
3493: PUSH
3494: LD_INT 3
3496: PUSH
3497: LD_INT 4
3499: PUSH
3500: EMPTY
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_OWVAR 67
3509: ARRAY
3510: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3511: LD_ADDR_EXP 52
3515: PUSH
3516: LD_STRING Pokryshkin
3518: PPUSH
3519: LD_INT 0
3521: PPUSH
3522: CALL 489 0 2
3526: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3527: LD_EXP 52
3531: PPUSH
3532: LD_INT 63
3534: PPUSH
3535: LD_INT 21
3537: PPUSH
3538: LD_INT 0
3540: PPUSH
3541: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3545: LD_EXP 52
3549: PPUSH
3550: CALL_OW 140
// InitHc ;
3554: CALL_OW 19
// for i in fac do
3558: LD_ADDR_VAR 0 2
3562: PUSH
3563: LD_VAR 0 10
3567: PUSH
3568: FOR_IN
3569: IFFALSE 3622
// begin for j = 1 to 6 do
3571: LD_ADDR_VAR 0 3
3575: PUSH
3576: DOUBLE
3577: LD_INT 1
3579: DEC
3580: ST_TO_ADDR
3581: LD_INT 6
3583: PUSH
3584: FOR_TO
3585: IFFALSE 3618
// begin PrepareHuman ( false , 3 , skill ) ;
3587: LD_INT 0
3589: PPUSH
3590: LD_INT 3
3592: PPUSH
3593: LD_VAR 0 11
3597: PPUSH
3598: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3602: CALL_OW 44
3606: PPUSH
3607: LD_VAR 0 2
3611: PPUSH
3612: CALL_OW 52
// end ;
3616: GO 3584
3618: POP
3619: POP
// end ;
3620: GO 3568
3622: POP
3623: POP
// for i in lab do
3624: LD_ADDR_VAR 0 2
3628: PUSH
3629: LD_VAR 0 9
3633: PUSH
3634: FOR_IN
3635: IFFALSE 3668
// begin PrepareHuman ( false , 4 , skill ) ;
3637: LD_INT 0
3639: PPUSH
3640: LD_INT 4
3642: PPUSH
3643: LD_VAR 0 11
3647: PPUSH
3648: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3652: CALL_OW 44
3656: PPUSH
3657: LD_VAR 0 2
3661: PPUSH
3662: CALL_OW 52
// end ;
3666: GO 3634
3668: POP
3669: POP
// for i in tw do
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 7
3679: PUSH
3680: FOR_IN
3681: IFFALSE 3730
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3683: LD_VAR 0 2
3687: PPUSH
3688: LD_INT 42
3690: PUSH
3691: LD_INT 43
3693: PUSH
3694: EMPTY
3695: LIST
3696: LIST
3697: PUSH
3698: LD_INT 1
3700: PPUSH
3701: LD_INT 2
3703: PPUSH
3704: CALL_OW 12
3708: ARRAY
3709: PPUSH
3710: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3714: LD_VAR 0 11
3718: PPUSH
3719: LD_VAR 0 2
3723: PPUSH
3724: CALL 830 0 2
// end ;
3728: GO 3680
3730: POP
3731: POP
// for i in bar do
3732: LD_ADDR_VAR 0 2
3736: PUSH
3737: LD_VAR 0 8
3741: PUSH
3742: FOR_IN
3743: IFFALSE 3776
// begin PrepareHuman ( false , 1 , skill ) ;
3745: LD_INT 0
3747: PPUSH
3748: LD_INT 1
3750: PPUSH
3751: LD_VAR 0 11
3755: PPUSH
3756: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3760: CALL_OW 44
3764: PPUSH
3765: LD_VAR 0 2
3769: PPUSH
3770: CALL_OW 52
// end ;
3774: GO 3742
3776: POP
3777: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3778: LD_ADDR_VAR 0 13
3782: PUSH
3783: LD_INT 100
3785: PUSH
3786: LD_INT 9
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: LD_INT 135
3795: PUSH
3796: LD_INT 60
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 41
3805: PUSH
3806: LD_INT 6
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 22
3815: PUSH
3816: LD_INT 9
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: LD_INT 84
3825: PUSH
3826: LD_INT 14
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: LIST
3837: LIST
3838: LIST
3839: ST_TO_ADDR
// vehicles := [ ] ;
3840: LD_ADDR_VAR 0 12
3844: PUSH
3845: EMPTY
3846: ST_TO_ADDR
// for i in spot_xy do
3847: LD_ADDR_VAR 0 2
3851: PUSH
3852: LD_VAR 0 13
3856: PUSH
3857: FOR_IN
3858: IFFALSE 4016
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3860: LD_ADDR_VAR 0 6
3864: PUSH
3865: LD_INT 3
3867: PPUSH
3868: LD_INT 3
3870: PPUSH
3871: LD_INT 22
3873: PPUSH
3874: LD_INT 1
3876: PPUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 42
3882: PUSH
3883: LD_INT 43
3885: PUSH
3886: LD_INT 44
3888: PUSH
3889: EMPTY
3890: LIST
3891: LIST
3892: LIST
3893: PUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 3
3899: PPUSH
3900: CALL_OW 12
3904: ARRAY
3905: PPUSH
3906: LD_INT 100
3908: PPUSH
3909: CALL 552 0 7
3913: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3914: LD_ADDR_VAR 0 12
3918: PUSH
3919: LD_VAR 0 12
3923: PPUSH
3924: LD_VAR 0 12
3928: PUSH
3929: LD_INT 1
3931: PLUS
3932: PPUSH
3933: LD_VAR 0 6
3937: PPUSH
3938: CALL_OW 2
3942: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3943: LD_VAR 0 6
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3955: LD_VAR 0 6
3959: PPUSH
3960: LD_VAR 0 2
3964: PUSH
3965: LD_INT 1
3967: ARRAY
3968: PPUSH
3969: LD_VAR 0 2
3973: PUSH
3974: LD_INT 2
3976: ARRAY
3977: PPUSH
3978: LD_INT 0
3980: PPUSH
3981: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3985: LD_INT 0
3987: PPUSH
3988: LD_INT 3
3990: PPUSH
3991: LD_VAR 0 11
3995: PPUSH
3996: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4000: CALL_OW 44
4004: PPUSH
4005: LD_VAR 0 6
4009: PPUSH
4010: CALL_OW 52
// end ;
4014: GO 3857
4016: POP
4017: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
4018: LD_ADDR_VAR 0 2
4022: PUSH
4023: DOUBLE
4024: LD_INT 1
4026: DEC
4027: ST_TO_ADDR
4028: LD_INT 5
4030: PUSH
4031: LD_INT 7
4033: PUSH
4034: LD_INT 8
4036: PUSH
4037: EMPTY
4038: LIST
4039: LIST
4040: LIST
4041: PUSH
4042: LD_OWVAR 67
4046: ARRAY
4047: PUSH
4048: FOR_TO
4049: IFFALSE 4109
// begin PrepareHuman ( false , 1 , skill ) ;
4051: LD_INT 0
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_VAR 0 11
4061: PPUSH
4062: CALL_OW 380
// un := CreateHuman ;
4066: LD_ADDR_VAR 0 5
4070: PUSH
4071: CALL_OW 44
4075: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
4076: LD_VAR 0 5
4080: PPUSH
4081: LD_INT 11
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4091: LD_ADDR_EXP 55
4095: PUSH
4096: LD_EXP 55
4100: PUSH
4101: LD_VAR 0 5
4105: ADD
4106: ST_TO_ADDR
// end ;
4107: GO 4048
4109: POP
4110: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4111: LD_ADDR_VAR 0 2
4115: PUSH
4116: DOUBLE
4117: LD_INT 1
4119: DEC
4120: ST_TO_ADDR
4121: LD_INT 2
4123: PUSH
4124: LD_INT 3
4126: PUSH
4127: LD_INT 4
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_OWVAR 67
4139: ARRAY
4140: PUSH
4141: FOR_TO
4142: IFFALSE 4202
// begin PrepareHuman ( false , 1 , skill ) ;
4144: LD_INT 0
4146: PPUSH
4147: LD_INT 1
4149: PPUSH
4150: LD_VAR 0 11
4154: PPUSH
4155: CALL_OW 380
// un := CreateHuman ;
4159: LD_ADDR_VAR 0 5
4163: PUSH
4164: CALL_OW 44
4168: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4169: LD_VAR 0 5
4173: PPUSH
4174: LD_INT 12
4176: PPUSH
4177: LD_INT 0
4179: PPUSH
4180: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4184: LD_ADDR_EXP 53
4188: PUSH
4189: LD_EXP 53
4193: PUSH
4194: LD_VAR 0 5
4198: ADD
4199: ST_TO_ADDR
// end ;
4200: GO 4141
4202: POP
4203: POP
// for i = 1 to 2 do
4204: LD_ADDR_VAR 0 2
4208: PUSH
4209: DOUBLE
4210: LD_INT 1
4212: DEC
4213: ST_TO_ADDR
4214: LD_INT 2
4216: PUSH
4217: FOR_TO
4218: IFFALSE 4284
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4220: LD_INT 1
4222: PPUSH
4223: LD_INT 1
4225: PPUSH
4226: LD_VAR 0 11
4230: PPUSH
4231: CALL_OW 380
// un := CreateHuman ;
4235: LD_ADDR_VAR 0 5
4239: PUSH
4240: CALL_OW 44
4244: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4245: LD_VAR 0 5
4249: PPUSH
4250: LD_INT 39
4252: PPUSH
4253: LD_INT 12
4255: PPUSH
4256: LD_INT 3
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4266: LD_ADDR_EXP 54
4270: PUSH
4271: LD_EXP 54
4275: PUSH
4276: LD_VAR 0 5
4280: ADD
4281: ST_TO_ADDR
// end ;
4282: GO 4217
4284: POP
4285: POP
// for i = 1 to 3 do
4286: LD_ADDR_VAR 0 2
4290: PUSH
4291: DOUBLE
4292: LD_INT 1
4294: DEC
4295: ST_TO_ADDR
4296: LD_INT 3
4298: PUSH
4299: FOR_TO
4300: IFFALSE 4366
// begin PrepareHuman ( false , 1 , skill ) ;
4302: LD_INT 0
4304: PPUSH
4305: LD_INT 1
4307: PPUSH
4308: LD_VAR 0 11
4312: PPUSH
4313: CALL_OW 380
// un := CreateHuman ;
4317: LD_ADDR_VAR 0 5
4321: PUSH
4322: CALL_OW 44
4326: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4327: LD_VAR 0 5
4331: PPUSH
4332: LD_INT 180
4334: PPUSH
4335: LD_INT 11
4337: PPUSH
4338: LD_INT 4
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4348: LD_ADDR_EXP 58
4352: PUSH
4353: LD_EXP 58
4357: PUSH
4358: LD_VAR 0 5
4362: ADD
4363: ST_TO_ADDR
// end ;
4364: GO 4299
4366: POP
4367: POP
// ru_vehicles := vehicles ;
4368: LD_ADDR_EXP 56
4372: PUSH
4373: LD_VAR 0 12
4377: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4378: LD_ADDR_EXP 59
4382: PUSH
4383: LD_INT 131
4385: PUSH
4386: LD_INT 121
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: PUSH
4393: LD_INT 113
4395: PUSH
4396: LD_INT 90
4398: PUSH
4399: EMPTY
4400: LIST
4401: LIST
4402: PUSH
4403: LD_INT 93
4405: PUSH
4406: LD_INT 62
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 106
4420: PUSH
4421: LD_INT 54
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 120
4430: PUSH
4431: LD_INT 80
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 143
4440: PUSH
4441: LD_INT 120
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 154
4455: PUSH
4456: LD_INT 116
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 140
4465: PUSH
4466: LD_INT 93
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: LD_INT 130
4475: PUSH
4476: LD_INT 58
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: PUSH
4483: EMPTY
4484: LIST
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 105
4490: PUSH
4491: LD_INT 106
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 134
4500: PUSH
4501: LD_INT 98
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 159
4510: PUSH
4511: LD_INT 113
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: LIST
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: LIST
4527: LIST
4528: ST_TO_ADDR
// if Difficulty = 1 then
4529: LD_OWVAR 67
4533: PUSH
4534: LD_INT 1
4536: EQUAL
4537: IFFALSE 4541
// exit ;
4539: GO 4596
// for i = 1 to Difficulty - 1 do
4541: LD_ADDR_VAR 0 2
4545: PUSH
4546: DOUBLE
4547: LD_INT 1
4549: DEC
4550: ST_TO_ADDR
4551: LD_OWVAR 67
4555: PUSH
4556: LD_INT 1
4558: MINUS
4559: PUSH
4560: FOR_TO
4561: IFFALSE 4594
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4563: LD_ADDR_EXP 57
4567: PUSH
4568: LD_EXP 57
4572: PUSH
4573: LD_INT 22
4575: PUSH
4576: LD_INT 1
4578: PUSH
4579: LD_INT 1
4581: PUSH
4582: LD_INT 43
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: LIST
4589: LIST
4590: ADD
4591: ST_TO_ADDR
4592: GO 4560
4594: POP
4595: POP
// end ;
4596: LD_VAR 0 1
4600: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4601: LD_INT 22
4603: PUSH
4604: LD_INT 3
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 2
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: PPUSH
4625: CALL_OW 69
4629: IFFALSE 4723
4631: GO 4633
4633: DISABLE
4634: LD_INT 0
4636: PPUSH
4637: PPUSH
// begin enable ;
4638: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4639: LD_ADDR_VAR 0 2
4643: PUSH
4644: LD_INT 22
4646: PUSH
4647: LD_INT 3
4649: PUSH
4650: EMPTY
4651: LIST
4652: LIST
4653: PUSH
4654: LD_INT 21
4656: PUSH
4657: LD_INT 2
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: PPUSH
4668: CALL_OW 69
4672: ST_TO_ADDR
// if filter then
4673: LD_VAR 0 2
4677: IFFALSE 4723
// for i in filter do
4679: LD_ADDR_VAR 0 1
4683: PUSH
4684: LD_VAR 0 2
4688: PUSH
4689: FOR_IN
4690: IFFALSE 4721
// if GetFuel ( i ) < 20 then
4692: LD_VAR 0 1
4696: PPUSH
4697: CALL_OW 261
4701: PUSH
4702: LD_INT 20
4704: LESS
4705: IFFALSE 4719
// SetFuel ( i , 20 ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 20
4714: PPUSH
4715: CALL_OW 240
4719: GO 4689
4721: POP
4722: POP
// end ;
4723: PPOPN 2
4725: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4726: LD_EXP 57
4730: IFFALSE 4949
4732: GO 4734
4734: DISABLE
4735: LD_INT 0
4737: PPUSH
4738: PPUSH
4739: PPUSH
// begin enable ;
4740: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4741: LD_ADDR_VAR 0 2
4745: PUSH
4746: LD_INT 22
4748: PUSH
4749: LD_INT 3
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: PUSH
4756: LD_INT 30
4758: PUSH
4759: LD_INT 3
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PPUSH
4770: CALL_OW 69
4774: ST_TO_ADDR
// can_produce := [ ] ;
4775: LD_ADDR_VAR 0 3
4779: PUSH
4780: EMPTY
4781: ST_TO_ADDR
// if not fac then
4782: LD_VAR 0 2
4786: NOT
4787: IFFALSE 4792
// begin disable ;
4789: DISABLE
// exit ;
4790: GO 4949
// end ; for i in fac do
4792: LD_ADDR_VAR 0 1
4796: PUSH
4797: LD_VAR 0 2
4801: PUSH
4802: FOR_IN
4803: IFFALSE 4841
// if UnitsInside ( i ) then
4805: LD_VAR 0 1
4809: PPUSH
4810: CALL_OW 313
4814: IFFALSE 4839
// can_produce := Insert ( can_produce , 1 , i ) ;
4816: LD_ADDR_VAR 0 3
4820: PUSH
4821: LD_VAR 0 3
4825: PPUSH
4826: LD_INT 1
4828: PPUSH
4829: LD_VAR 0 1
4833: PPUSH
4834: CALL_OW 2
4838: ST_TO_ADDR
4839: GO 4802
4841: POP
4842: POP
// if not can_produce then
4843: LD_VAR 0 3
4847: NOT
4848: IFFALSE 4852
// exit ;
4850: GO 4949
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4852: LD_VAR 0 3
4856: PUSH
4857: LD_INT 1
4859: PPUSH
4860: LD_VAR 0 3
4864: PPUSH
4865: CALL_OW 12
4869: ARRAY
4870: PPUSH
4871: LD_EXP 57
4875: PUSH
4876: LD_INT 1
4878: ARRAY
4879: PPUSH
4880: LD_EXP 57
4884: PUSH
4885: LD_INT 2
4887: ARRAY
4888: PPUSH
4889: LD_EXP 57
4893: PUSH
4894: LD_INT 3
4896: ARRAY
4897: PPUSH
4898: LD_EXP 57
4902: PUSH
4903: LD_INT 4
4905: ARRAY
4906: PPUSH
4907: CALL_OW 125
// for i = 1 to 4 do
4911: LD_ADDR_VAR 0 1
4915: PUSH
4916: DOUBLE
4917: LD_INT 1
4919: DEC
4920: ST_TO_ADDR
4921: LD_INT 4
4923: PUSH
4924: FOR_TO
4925: IFFALSE 4947
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4927: LD_ADDR_EXP 57
4931: PUSH
4932: LD_EXP 57
4936: PPUSH
4937: LD_INT 1
4939: PPUSH
4940: CALL_OW 3
4944: ST_TO_ADDR
4945: GO 4924
4947: POP
4948: POP
// end ;
4949: PPOPN 3
4951: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4952: LD_INT 0
4954: PPUSH
4955: PPUSH
4956: PPUSH
// for i = 1 to [ 3 , 5 , 6 ] [ Difficulty ] do
4957: LD_ADDR_VAR 0 2
4961: PUSH
4962: DOUBLE
4963: LD_INT 1
4965: DEC
4966: ST_TO_ADDR
4967: LD_INT 3
4969: PUSH
4970: LD_INT 5
4972: PUSH
4973: LD_INT 6
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: LIST
4980: PUSH
4981: LD_OWVAR 67
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5137
// begin PrepareHuman ( false , 3 , 3 ) ;
4990: LD_INT 0
4992: PPUSH
4993: LD_INT 3
4995: PPUSH
4996: LD_INT 3
4998: PPUSH
4999: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: LD_INT 3
5010: PPUSH
5011: LD_INT 3
5013: PPUSH
5014: LD_INT 22
5016: PPUSH
5017: LD_INT 1
5019: PPUSH
5020: LD_INT 1
5022: PPUSH
5023: LD_INT 43
5025: PUSH
5026: LD_INT 42
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PUSH
5033: LD_INT 1
5035: PPUSH
5036: LD_INT 2
5038: PPUSH
5039: CALL_OW 12
5043: ARRAY
5044: PPUSH
5045: LD_INT 70
5047: PPUSH
5048: CALL 552 0 7
5052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5053: LD_VAR 0 3
5057: PPUSH
5058: LD_INT 4
5060: PPUSH
5061: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
5065: LD_VAR 0 3
5069: PPUSH
5070: LD_INT 229
5072: PPUSH
5073: LD_INT 44
5075: PPUSH
5076: LD_INT 0
5078: PPUSH
5079: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
5083: CALL_OW 44
5087: PPUSH
5088: LD_VAR 0 3
5092: PPUSH
5093: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
5097: LD_ADDR_EXP 56
5101: PUSH
5102: LD_EXP 56
5106: PUSH
5107: LD_VAR 0 3
5111: ADD
5112: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5113: LD_VAR 0 3
5117: PPUSH
5118: LD_INT 191
5120: PPUSH
5121: LD_INT 32
5123: PPUSH
5124: CALL_OW 111
// Wait ( 0 0$02 ) ;
5128: LD_INT 70
5130: PPUSH
5131: CALL_OW 67
// end ;
5135: GO 4987
5137: POP
5138: POP
// end ;
5139: LD_VAR 0 1
5143: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5144: LD_EXP 31
5148: PUSH
5149: LD_EXP 56
5153: AND
5154: IFFALSE 5328
5156: GO 5158
5158: DISABLE
5159: LD_INT 0
5161: PPUSH
5162: PPUSH
5163: PPUSH
// begin wait ( 0 0$50 ) ;
5164: LD_INT 1750
5166: PPUSH
5167: CALL_OW 67
// tmp := ru_vehicles ;
5171: LD_ADDR_VAR 0 3
5175: PUSH
5176: LD_EXP 56
5180: ST_TO_ADDR
// if not tmp then
5181: LD_VAR 0 3
5185: NOT
5186: IFFALSE 5190
// exit ;
5188: GO 5328
// repeat wait ( 0 0$1 ) ;
5190: LD_INT 35
5192: PPUSH
5193: CALL_OW 67
// for i in tmp do
5197: LD_ADDR_VAR 0 1
5201: PUSH
5202: LD_VAR 0 3
5206: PUSH
5207: FOR_IN
5208: IFFALSE 5319
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5210: LD_ADDR_VAR 0 2
5214: PUSH
5215: LD_INT 22
5217: PUSH
5218: LD_INT 1
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PPUSH
5225: LD_VAR 0 1
5229: PPUSH
5230: CALL_OW 74
5234: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5235: LD_VAR 0 1
5239: PPUSH
5240: LD_VAR 0 2
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 10
5252: GREATER
5253: IFFALSE 5272
// ComAgressiveMove ( i , 69 , 101 ) else
5255: LD_VAR 0 1
5259: PPUSH
5260: LD_INT 69
5262: PPUSH
5263: LD_INT 101
5265: PPUSH
5266: CALL_OW 114
5270: GO 5286
// ComAttackUnit ( i , enemy ) ;
5272: LD_VAR 0 1
5276: PPUSH
5277: LD_VAR 0 2
5281: PPUSH
5282: CALL_OW 115
// if GetLives ( i ) < 250 then
5286: LD_VAR 0 1
5290: PPUSH
5291: CALL_OW 256
5295: PUSH
5296: LD_INT 250
5298: LESS
5299: IFFALSE 5317
// tmp := tmp diff i ;
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: LD_VAR 0 3
5310: PUSH
5311: LD_VAR 0 1
5315: DIFF
5316: ST_TO_ADDR
// end ;
5317: GO 5207
5319: POP
5320: POP
// until not tmp ;
5321: LD_VAR 0 3
5325: NOT
5326: IFFALSE 5190
// end ; end_of_file
5328: PPOPN 3
5330: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5331: LD_INT 0
5333: PPUSH
5334: PPUSH
5335: PPUSH
5336: PPUSH
5337: PPUSH
5338: PPUSH
5339: PPUSH
// InGameOn ;
5340: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5344: LD_EXP 37
5348: PPUSH
5349: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5353: LD_EXP 37
5357: PPUSH
5358: LD_EXP 44
5362: PPUSH
5363: CALL_OW 119
// if Bierezov then
5367: LD_EXP 45
5371: IFFALSE 5387
// ComTurnUnit ( Bierezov , Cornel ) ;
5373: LD_EXP 45
5377: PPUSH
5378: LD_EXP 44
5382: PPUSH
5383: CALL_OW 119
// for i in jmm_units do
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_EXP 4
5396: PUSH
5397: FOR_IN
5398: IFFALSE 5416
// ComTurnUnit ( i , Cornel ) ;
5400: LD_VAR 0 2
5404: PPUSH
5405: LD_EXP 44
5409: PPUSH
5410: CALL_OW 119
5414: GO 5397
5416: POP
5417: POP
// units := cornel_units union Cornel ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: LD_EXP 6
5427: PUSH
5428: LD_EXP 44
5432: UNION
5433: ST_TO_ADDR
// repeat wait ( 1 ) ;
5434: LD_INT 1
5436: PPUSH
5437: CALL_OW 67
// for i in units do
5441: LD_ADDR_VAR 0 2
5445: PUSH
5446: LD_VAR 0 3
5450: PUSH
5451: FOR_IN
5452: IFFALSE 5485
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_EXP 37
5463: PPUSH
5464: CALL_OW 250
5468: PPUSH
5469: LD_EXP 37
5473: PPUSH
5474: CALL_OW 251
5478: PPUSH
5479: CALL_OW 111
5483: GO 5451
5485: POP
5486: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5487: LD_VAR 0 3
5491: PPUSH
5492: LD_INT 92
5494: PUSH
5495: LD_EXP 37
5499: PPUSH
5500: CALL_OW 250
5504: PUSH
5505: LD_EXP 37
5509: PPUSH
5510: CALL_OW 251
5514: PUSH
5515: LD_INT 10
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: PPUSH
5524: CALL_OW 72
5528: PUSH
5529: LD_VAR 0 3
5533: EQUAL
5534: IFFALSE 5434
// for i in units do
5536: LD_ADDR_VAR 0 2
5540: PUSH
5541: LD_VAR 0 3
5545: PUSH
5546: FOR_IN
5547: IFFALSE 5565
// ComTurnUnit ( i , JMM ) ;
5549: LD_VAR 0 2
5553: PPUSH
5554: LD_EXP 37
5558: PPUSH
5559: CALL_OW 119
5563: GO 5546
5565: POP
5566: POP
// ComTurnUnit ( Cornel , JMM ) ;
5567: LD_EXP 44
5571: PPUSH
5572: LD_EXP 37
5576: PPUSH
5577: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5581: LD_EXP 37
5585: PPUSH
5586: LD_STRING D1-JMM-1
5588: PPUSH
5589: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5593: LD_EXP 44
5597: PPUSH
5598: LD_STRING D1-Corn-1
5600: PPUSH
5601: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5605: LD_EXP 37
5609: PPUSH
5610: LD_EXP 44
5614: PPUSH
5615: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5619: LD_EXP 44
5623: PPUSH
5624: LD_EXP 37
5628: PPUSH
5629: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5633: LD_INT 35
5635: PPUSH
5636: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5640: LD_EXP 37
5644: PPUSH
5645: LD_EXP 44
5649: PPUSH
5650: CALL_OW 296
5654: PUSH
5655: LD_INT 6
5657: LESS
5658: IFFALSE 5633
// ChangeSideFog ( 4 , 1 ) ;
5660: LD_INT 4
5662: PPUSH
5663: LD_INT 1
5665: PPUSH
5666: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5670: LD_EXP 37
5674: PPUSH
5675: LD_EXP 44
5679: PPUSH
5680: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5684: LD_EXP 44
5688: PPUSH
5689: LD_EXP 37
5693: PPUSH
5694: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5698: LD_EXP 37
5702: PPUSH
5703: LD_STRING D1-JMM-2
5705: PPUSH
5706: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5710: LD_EXP 37
5714: PPUSH
5715: LD_STRING D1-JMM-2a
5717: PPUSH
5718: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5722: LD_EXP 44
5726: PPUSH
5727: LD_STRING D1-Corn-2
5729: PPUSH
5730: CALL_OW 88
// if bierezov_exist or debug then
5734: LD_EXP 7
5738: PUSH
5739: LD_EXP 1
5743: OR
5744: IFFALSE 5985
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5746: LD_EXP 44
5750: PPUSH
5751: LD_EXP 45
5755: PPUSH
5756: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5760: LD_INT 10
5762: PPUSH
5763: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5767: LD_EXP 44
5771: PPUSH
5772: LD_STRING D1a-Corn-1
5774: PPUSH
5775: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5779: LD_EXP 37
5783: PPUSH
5784: LD_EXP 45
5788: PPUSH
5789: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5793: LD_EXP 45
5797: PPUSH
5798: LD_EXP 37
5802: PPUSH
5803: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5807: LD_EXP 37
5811: PPUSH
5812: LD_STRING D1a-JMM-1
5814: PPUSH
5815: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5819: LD_EXP 37
5823: PPUSH
5824: LD_EXP 44
5828: PPUSH
5829: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5833: LD_EXP 44
5837: PPUSH
5838: LD_EXP 37
5842: PPUSH
5843: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5847: LD_EXP 44
5851: PPUSH
5852: LD_STRING D1a-Corn-2
5854: PPUSH
5855: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5859: LD_EXP 37
5863: PPUSH
5864: LD_STRING D1a-JMM-2
5866: PPUSH
5867: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5871: LD_EXP 44
5875: PPUSH
5876: LD_STRING D1a-Corn-3
5878: PPUSH
5879: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5883: LD_EXP 37
5887: PPUSH
5888: LD_STRING D1a-JMM-3
5890: PPUSH
5891: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5895: LD_EXP 44
5899: PPUSH
5900: LD_STRING D1a-Corn-4
5902: PPUSH
5903: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5907: LD_EXP 37
5911: PPUSH
5912: LD_STRING D1a-JMM-4
5914: PPUSH
5915: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5919: LD_EXP 44
5923: PPUSH
5924: LD_STRING D1a-Corn-5
5926: PPUSH
5927: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5931: LD_EXP 45
5935: PPUSH
5936: LD_EXP 44
5940: PPUSH
5941: CALL_OW 250
5945: PPUSH
5946: LD_EXP 44
5950: PPUSH
5951: CALL_OW 251
5955: PUSH
5956: LD_INT 2
5958: MINUS
5959: PPUSH
5960: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5964: LD_EXP 45
5968: PPUSH
5969: LD_EXP 44
5973: PPUSH
5974: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5978: LD_INT 10
5980: PPUSH
5981: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5985: LD_EXP 37
5989: PPUSH
5990: LD_STRING D1b-JMM-1
5992: PPUSH
5993: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5997: LD_EXP 44
6001: PPUSH
6002: LD_STRING D1b-Corn-1
6004: PPUSH
6005: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
6009: LD_EXP 37
6013: PPUSH
6014: LD_STRING D1b-JMM-2
6016: PPUSH
6017: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
6021: LD_EXP 44
6025: PPUSH
6026: LD_STRING D1b-Corn-2
6028: PPUSH
6029: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
6033: LD_EXP 37
6037: PPUSH
6038: LD_STRING D1b-JMM-3
6040: PPUSH
6041: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
6045: LD_INT 10
6047: PPUSH
6048: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
6052: LD_EXP 46
6056: PPUSH
6057: LD_STRING D1b-Pow-3
6059: PPUSH
6060: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
6064: LD_EXP 37
6068: PPUSH
6069: LD_STRING D1b-JMM-4
6071: PPUSH
6072: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
6076: LD_EXP 44
6080: PPUSH
6081: LD_STRING D1b-Corn-4
6083: PPUSH
6084: CALL_OW 88
// if Khatam then
6088: LD_EXP 41
6092: IFFALSE 6108
// Say ( Khatam , D1b-Khat-4 ) else
6094: LD_EXP 41
6098: PPUSH
6099: LD_STRING D1b-Khat-4
6101: PPUSH
6102: CALL_OW 88
6106: GO 6144
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6108: LD_EXP 6
6112: PPUSH
6113: LD_INT 26
6115: PUSH
6116: LD_INT 1
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 72
6127: PUSH
6128: LD_EXP 44
6132: PUSH
6133: EMPTY
6134: LIST
6135: DIFF
6136: PPUSH
6137: LD_STRING D1b-Sol1-4
6139: PPUSH
6140: CALL 640 0 2
// if Cyrus then
6144: LD_EXP 39
6148: IFFALSE 6162
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6150: LD_EXP 39
6154: PPUSH
6155: LD_STRING D1b-Cyrus-4
6157: PPUSH
6158: CALL_OW 88
// if Lisa then
6162: LD_EXP 40
6166: IFFALSE 6224
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6168: LD_EXP 40
6172: PPUSH
6173: LD_STRING D1b-Lisa-4
6175: PPUSH
6176: CALL_OW 88
// if Cyrus then
6180: LD_EXP 39
6184: IFFALSE 6224
// begin if not IsInUnit ( Cyrus ) then
6186: LD_EXP 39
6190: PPUSH
6191: CALL_OW 310
6195: NOT
6196: IFFALSE 6212
// ComTurnUnit ( Cyrus , Lisa ) ;
6198: LD_EXP 39
6202: PPUSH
6203: LD_EXP 40
6207: PPUSH
6208: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6212: LD_EXP 39
6216: PPUSH
6217: LD_STRING D1b-Cyrus-5
6219: PPUSH
6220: CALL_OW 88
// end ; end ; SelectGroup ;
6224: CALL 2684 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6228: LD_EXP 37
6232: PPUSH
6233: LD_STRING D1d-JMM-1
6235: PPUSH
6236: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6240: LD_EXP 44
6244: PPUSH
6245: LD_STRING D1d-Corn-1
6247: PPUSH
6248: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6252: LD_ADDR_VAR 0 2
6256: PUSH
6257: LD_EXP 4
6261: PUSH
6262: LD_EXP 6
6266: ADD
6267: PUSH
6268: LD_EXP 37
6272: ADD
6273: PUSH
6274: FOR_IN
6275: IFFALSE 6288
// ComHold ( i ) ;
6277: LD_VAR 0 2
6281: PPUSH
6282: CALL_OW 140
6286: GO 6274
6288: POP
6289: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6290: LD_ADDR_VAR 0 4
6294: PUSH
6295: LD_INT 22
6297: PUSH
6298: LD_INT 1
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 21
6307: PUSH
6308: LD_INT 2
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PPUSH
6319: CALL_OW 69
6323: ST_TO_ADDR
// if vehicles then
6324: LD_VAR 0 4
6328: IFFALSE 6666
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6330: LD_EXP 6
6334: PPUSH
6335: LD_INT 55
6337: PUSH
6338: EMPTY
6339: LIST
6340: PPUSH
6341: CALL_OW 72
6345: IFFALSE 6384
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6347: LD_ADDR_VAR 0 2
6351: PUSH
6352: LD_EXP 6
6356: PPUSH
6357: LD_INT 55
6359: PUSH
6360: EMPTY
6361: LIST
6362: PPUSH
6363: CALL_OW 72
6367: PUSH
6368: FOR_IN
6369: IFFALSE 6382
// ComExitVehicle ( i ) ;
6371: LD_VAR 0 2
6375: PPUSH
6376: CALL_OW 121
6380: GO 6368
6382: POP
6383: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6384: LD_ADDR_VAR 0 5
6388: PUSH
6389: LD_VAR 0 4
6393: PPUSH
6394: LD_INT 34
6396: PUSH
6397: LD_INT 51
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: PPUSH
6404: CALL_OW 72
6408: ST_TO_ADDR
// if cargos then
6409: LD_VAR 0 5
6413: IFFALSE 6596
// begin vehicles := cargos ;
6415: LD_ADDR_VAR 0 4
6419: PUSH
6420: LD_VAR 0 5
6424: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6425: LD_ADDR_VAR 0 6
6429: PUSH
6430: LD_STRING 02_resources_4
6432: PPUSH
6433: LD_INT 0
6435: PPUSH
6436: CALL_OW 30
6440: ST_TO_ADDR
// if debug and not resources then
6441: LD_EXP 1
6445: PUSH
6446: LD_VAR 0 6
6450: NOT
6451: AND
6452: IFFALSE 6462
// resources := 160 ;
6454: LD_ADDR_VAR 0 6
6458: PUSH
6459: LD_INT 160
6461: ST_TO_ADDR
// if resources mod 10 then
6462: LD_VAR 0 6
6466: PUSH
6467: LD_INT 10
6469: MOD
6470: IFFALSE 6492
// resources := resources - resources mod 10 ;
6472: LD_ADDR_VAR 0 6
6476: PUSH
6477: LD_VAR 0 6
6481: PUSH
6482: LD_VAR 0 6
6486: PUSH
6487: LD_INT 10
6489: MOD
6490: MINUS
6491: ST_TO_ADDR
// if resources then
6492: LD_VAR 0 6
6496: IFFALSE 6596
// for i in cargos do
6498: LD_ADDR_VAR 0 2
6502: PUSH
6503: LD_VAR 0 5
6507: PUSH
6508: FOR_IN
6509: IFFALSE 6594
// begin if resources < 100 then
6511: LD_VAR 0 6
6515: PUSH
6516: LD_INT 100
6518: LESS
6519: IFFALSE 6541
// begin cargo := resources ;
6521: LD_ADDR_VAR 0 7
6525: PUSH
6526: LD_VAR 0 6
6530: ST_TO_ADDR
// resources := 0 ;
6531: LD_ADDR_VAR 0 6
6535: PUSH
6536: LD_INT 0
6538: ST_TO_ADDR
// end else
6539: GO 6563
// begin cargo := 100 ;
6541: LD_ADDR_VAR 0 7
6545: PUSH
6546: LD_INT 100
6548: ST_TO_ADDR
// resources := resources - 100 ;
6549: LD_ADDR_VAR 0 6
6553: PUSH
6554: LD_VAR 0 6
6558: PUSH
6559: LD_INT 100
6561: MINUS
6562: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6563: LD_VAR 0 2
6567: PPUSH
6568: LD_INT 1
6570: PPUSH
6571: LD_VAR 0 7
6575: PPUSH
6576: CALL_OW 290
// if resources = 0 then
6580: LD_VAR 0 6
6584: PUSH
6585: LD_INT 0
6587: EQUAL
6588: IFFALSE 6592
// break ;
6590: GO 6594
// end ;
6592: GO 6508
6594: POP
6595: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6596: LD_VAR 0 4
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 311
6609: PPUSH
6610: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6614: LD_VAR 0 4
6618: PUSH
6619: LD_INT 1
6621: ARRAY
6622: PPUSH
6623: LD_INT 4
6625: PPUSH
6626: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6630: LD_EXP 44
6634: PPUSH
6635: LD_VAR 0 4
6639: PUSH
6640: LD_INT 1
6642: ARRAY
6643: PPUSH
6644: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6648: LD_INT 35
6650: PPUSH
6651: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6655: LD_EXP 44
6659: PPUSH
6660: CALL_OW 310
6664: IFFALSE 6648
// end ; InGameOff ;
6666: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6670: LD_STRING M1
6672: PPUSH
6673: CALL_OW 337
// SaveForQuickRestart ;
6677: CALL_OW 22
// cornel_active := true ;
6681: LD_ADDR_EXP 8
6685: PUSH
6686: LD_INT 1
6688: ST_TO_ADDR
// end ;
6689: LD_VAR 0 1
6693: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6694: LD_EXP 37
6698: PPUSH
6699: LD_EXP 47
6703: PPUSH
6704: CALL_OW 296
6708: PUSH
6709: LD_INT 10
6711: LESS
6712: IFFALSE 8095
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
6723: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 89
6731: PUSH
6732: LD_INT 34
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 138
6741: PUSH
6742: LD_INT 63
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 196
6751: PUSH
6752: LD_INT 84
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 135
6761: PUSH
6762: LD_INT 52
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: LD_INT 103
6771: PUSH
6772: LD_INT 39
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PUSH
6779: LD_INT 58
6781: PUSH
6782: LD_INT 30
6784: PUSH
6785: EMPTY
6786: LIST
6787: LIST
6788: PUSH
6789: LD_INT 38
6791: PUSH
6792: LD_INT 51
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: ST_TO_ADDR
// Video ( true ) ;
6808: LD_INT 1
6810: PPUSH
6811: CALL 1200 0 1
// if jmm_units then
6815: LD_EXP 4
6819: IFFALSE 6895
// for i in jmm_units do
6821: LD_ADDR_VAR 0 1
6825: PUSH
6826: LD_EXP 4
6830: PUSH
6831: FOR_IN
6832: IFFALSE 6893
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6834: LD_VAR 0 1
6838: PPUSH
6839: LD_EXP 37
6843: PPUSH
6844: CALL_OW 296
6848: PUSH
6849: LD_INT 10
6851: LESS
6852: PUSH
6853: LD_VAR 0 1
6857: PPUSH
6858: CALL_OW 310
6862: NOT
6863: AND
6864: IFFALSE 6882
// ComTurnUnit ( i , JMM ) else
6866: LD_VAR 0 1
6870: PPUSH
6871: LD_EXP 37
6875: PPUSH
6876: CALL_OW 119
6880: GO 6891
// ComHold ( i ) ;
6882: LD_VAR 0 1
6886: PPUSH
6887: CALL_OW 140
// end ;
6891: GO 6831
6893: POP
6894: POP
// if IsInUnit ( JMM ) then
6895: LD_EXP 37
6899: PPUSH
6900: CALL_OW 310
6904: IFFALSE 6929
// begin ComExitVehicle ( JMM ) ;
6906: LD_EXP 37
6910: PPUSH
6911: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6915: LD_EXP 37
6919: PPUSH
6920: LD_EXP 47
6924: PPUSH
6925: CALL_OW 172
// end ; Wait ( 10 ) ;
6929: LD_INT 10
6931: PPUSH
6932: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6936: LD_EXP 37
6940: PPUSH
6941: LD_EXP 47
6945: PPUSH
6946: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6950: LD_INT 35
6952: PPUSH
6953: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6957: LD_EXP 37
6961: PPUSH
6962: LD_EXP 47
6966: PPUSH
6967: CALL_OW 296
6971: PUSH
6972: LD_INT 6
6974: LESS
6975: IFFALSE 6950
// ComTurnUnit ( JMM , Lynch ) ;
6977: LD_EXP 37
6981: PPUSH
6982: LD_EXP 47
6986: PPUSH
6987: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6991: LD_ADDR_VAR 0 1
6995: PUSH
6996: LD_EXP 47
7000: PUSH
7001: LD_EXP 48
7005: PUSH
7006: LD_EXP 49
7010: PUSH
7011: LD_EXP 50
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: PUSH
7022: FOR_IN
7023: IFFALSE 7041
// ComTurnUnit ( i , JMM ) ;
7025: LD_VAR 0 1
7029: PPUSH
7030: LD_EXP 37
7034: PPUSH
7035: CALL_OW 119
7039: GO 7022
7041: POP
7042: POP
// Wait ( 0 0$0.3 ) ;
7043: LD_INT 10
7045: PPUSH
7046: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
7050: LD_EXP 37
7054: PPUSH
7055: LD_STRING D2-JMM-1
7057: PPUSH
7058: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
7062: LD_EXP 47
7066: PPUSH
7067: LD_STRING D2-Sol1-1
7069: PPUSH
7070: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7074: LD_EXP 37
7078: PPUSH
7079: LD_STRING D2-JMM-2
7081: PPUSH
7082: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
7086: LD_EXP 47
7090: PPUSH
7091: LD_STRING D2-Sol1-2
7093: PPUSH
7094: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7098: LD_EXP 37
7102: PPUSH
7103: LD_STRING D2-JMM-3
7105: PPUSH
7106: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7110: LD_EXP 47
7114: PPUSH
7115: LD_STRING D2-Sol1-3
7117: PPUSH
7118: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7122: LD_ADDR_VAR 0 1
7126: PUSH
7127: LD_INT 22
7129: PUSH
7130: LD_INT 8
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: PPUSH
7137: CALL_OW 69
7141: PUSH
7142: FOR_IN
7143: IFFALSE 7159
// SetSide ( i , 1 ) ;
7145: LD_VAR 0 1
7149: PPUSH
7150: LD_INT 1
7152: PPUSH
7153: CALL_OW 235
7157: GO 7142
7159: POP
7160: POP
// Say ( JMM , D2-JMM-4 ) ;
7161: LD_EXP 37
7165: PPUSH
7166: LD_STRING D2-JMM-4
7168: PPUSH
7169: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7173: LD_INT 1
7175: PPUSH
7176: LD_INT 5
7178: PPUSH
7179: CALL_OW 332
// for i = 1 to points do
7183: LD_ADDR_VAR 0 1
7187: PUSH
7188: DOUBLE
7189: LD_INT 1
7191: DEC
7192: ST_TO_ADDR
7193: LD_VAR 0 2
7197: PUSH
7198: FOR_TO
7199: IFFALSE 7374
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7201: LD_VAR 0 2
7205: PUSH
7206: LD_VAR 0 1
7210: ARRAY
7211: PUSH
7212: LD_INT 1
7214: ARRAY
7215: PPUSH
7216: LD_VAR 0 2
7220: PUSH
7221: LD_VAR 0 1
7225: ARRAY
7226: PUSH
7227: LD_INT 2
7229: ARRAY
7230: PPUSH
7231: CALL_OW 84
// if i = 1 then
7235: LD_VAR 0 1
7239: PUSH
7240: LD_INT 1
7242: EQUAL
7243: IFFALSE 7257
// Say ( Lynch , D2-Sol1-4 ) ;
7245: LD_EXP 47
7249: PPUSH
7250: LD_STRING D2-Sol1-4
7252: PPUSH
7253: CALL_OW 88
// if i = 2 then
7257: LD_VAR 0 1
7261: PUSH
7262: LD_INT 2
7264: EQUAL
7265: IFFALSE 7279
// Say ( JMM , D2-JMM-5 ) ;
7267: LD_EXP 37
7271: PPUSH
7272: LD_STRING D2-JMM-5
7274: PPUSH
7275: CALL_OW 88
// if i = 4 then
7279: LD_VAR 0 1
7283: PUSH
7284: LD_INT 4
7286: EQUAL
7287: IFFALSE 7311
// begin RevealFogArea ( 1 , troopsArea ) ;
7289: LD_INT 1
7291: PPUSH
7292: LD_INT 6
7294: PPUSH
7295: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7299: LD_EXP 47
7303: PPUSH
7304: LD_STRING D2-Sol1-5
7306: PPUSH
7307: CALL_OW 88
// end ; if i = 5 then
7311: LD_VAR 0 1
7315: PUSH
7316: LD_INT 5
7318: EQUAL
7319: IFFALSE 7333
// Say ( JMM , D2-JMM-6 ) ;
7321: LD_EXP 37
7325: PPUSH
7326: LD_STRING D2-JMM-6
7328: PPUSH
7329: CALL_OW 88
// if i = 7 then
7333: LD_VAR 0 1
7337: PUSH
7338: LD_INT 7
7340: EQUAL
7341: IFFALSE 7365
// begin RevealFogArea ( 1 , forestArea ) ;
7343: LD_INT 1
7345: PPUSH
7346: LD_INT 7
7348: PPUSH
7349: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7353: LD_EXP 47
7357: PPUSH
7358: LD_STRING D2-Sol1-6
7360: PPUSH
7361: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7365: LD_INT 46
7367: PPUSH
7368: CALL_OW 67
// end ;
7372: GO 7198
7374: POP
7375: POP
// CenterNowOnUnits ( JMM ) ;
7376: LD_EXP 37
7380: PPUSH
7381: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7385: LD_EXP 37
7389: PPUSH
7390: LD_STRING D2-JMM-7
7392: PPUSH
7393: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7397: LD_EXP 47
7401: PPUSH
7402: LD_STRING D2-Sol1-7
7404: PPUSH
7405: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7409: LD_EXP 37
7413: PPUSH
7414: LD_STRING D2-JMM-8
7416: PPUSH
7417: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 22
7428: PUSH
7429: LD_INT 1
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 30
7438: PUSH
7439: LD_INT 31
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PPUSH
7450: CALL_OW 69
7454: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7455: LD_EXP 47
7459: PPUSH
7460: LD_VAR 0 4
7464: PUSH
7465: LD_INT 1
7467: ARRAY
7468: PPUSH
7469: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7473: LD_INT 65
7475: PPUSH
7476: LD_INT 101
7478: PPUSH
7479: CALL_OW 428
7483: IFFALSE 7506
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7485: LD_INT 65
7487: PPUSH
7488: LD_INT 101
7490: PPUSH
7491: CALL_OW 428
7495: PPUSH
7496: LD_INT 75
7498: PPUSH
7499: LD_INT 100
7501: PPUSH
7502: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7506: LD_INT 66
7508: PPUSH
7509: LD_INT 103
7511: PPUSH
7512: CALL_OW 428
7516: IFFALSE 7539
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7518: LD_INT 66
7520: PPUSH
7521: LD_INT 103
7523: PPUSH
7524: CALL_OW 428
7528: PPUSH
7529: LD_INT 75
7531: PPUSH
7532: LD_INT 100
7534: PPUSH
7535: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7539: LD_ADDR_VAR 0 5
7543: PUSH
7544: LD_INT 22
7546: PUSH
7547: LD_INT 1
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PUSH
7554: LD_INT 21
7556: PUSH
7557: LD_INT 2
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PUSH
7564: LD_INT 91
7566: PUSH
7567: LD_EXP 37
7571: PUSH
7572: LD_INT 7
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: LIST
7584: PPUSH
7585: CALL_OW 69
7589: ST_TO_ADDR
// if tmp then
7590: LD_VAR 0 5
7594: IFFALSE 7611
// ComMoveXY ( tmp , 75 , 100 ) ;
7596: LD_VAR 0 5
7600: PPUSH
7601: LD_INT 75
7603: PPUSH
7604: LD_INT 100
7606: PPUSH
7607: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7611: LD_ADDR_VAR 0 3
7615: PUSH
7616: LD_EXP 4
7620: PPUSH
7621: LD_INT 25
7623: PUSH
7624: LD_INT 1
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PPUSH
7631: CALL_OW 72
7635: PPUSH
7636: LD_EXP 37
7640: PPUSH
7641: CALL_OW 74
7645: ST_TO_ADDR
// if sol then
7646: LD_VAR 0 3
7650: IFFALSE 7710
// if GetDistUnits ( JMM , sol ) < 10 then
7652: LD_EXP 37
7656: PPUSH
7657: LD_VAR 0 3
7661: PPUSH
7662: CALL_OW 296
7666: PUSH
7667: LD_INT 10
7669: LESS
7670: IFFALSE 7710
// begin if IsInUnit ( sol ) then
7672: LD_VAR 0 3
7676: PPUSH
7677: CALL_OW 310
7681: IFFALSE 7692
// ComExitVehicle ( sol ) ;
7683: LD_VAR 0 3
7687: PPUSH
7688: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7692: LD_VAR 0 3
7696: PPUSH
7697: LD_VAR 0 4
7701: PUSH
7702: LD_INT 2
7704: ARRAY
7705: PPUSH
7706: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7710: LD_INT 10
7712: PPUSH
7713: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7717: LD_EXP 37
7721: PPUSH
7722: LD_INT 65
7724: PPUSH
7725: LD_INT 101
7727: PPUSH
7728: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7732: LD_EXP 37
7736: PPUSH
7737: LD_INT 63
7739: PPUSH
7740: LD_INT 100
7742: PPUSH
7743: CALL_OW 178
// tmp := 0 0$0 ;
7747: LD_ADDR_VAR 0 5
7751: PUSH
7752: LD_INT 0
7754: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7755: LD_INT 35
7757: PPUSH
7758: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7762: LD_ADDR_VAR 0 5
7766: PUSH
7767: LD_VAR 0 5
7771: PUSH
7772: LD_INT 35
7774: PLUS
7775: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7776: LD_EXP 37
7780: PPUSH
7781: LD_INT 65
7783: PPUSH
7784: LD_INT 101
7786: PPUSH
7787: CALL_OW 307
7791: PUSH
7792: LD_VAR 0 5
7796: PUSH
7797: LD_INT 175
7799: GREATER
7800: OR
7801: IFFALSE 7755
// Say ( JMM , D2a-JMM-1 ) ;
7803: LD_EXP 37
7807: PPUSH
7808: LD_STRING D2a-JMM-1
7810: PPUSH
7811: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7815: LD_EXP 48
7819: PPUSH
7820: LD_INT 66
7822: PPUSH
7823: LD_INT 103
7825: PPUSH
7826: CALL_OW 111
// tmp := 0 0$0 ;
7830: LD_ADDR_VAR 0 5
7834: PUSH
7835: LD_INT 0
7837: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7838: LD_INT 35
7840: PPUSH
7841: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7845: LD_EXP 48
7849: PPUSH
7850: LD_INT 66
7852: PPUSH
7853: LD_INT 103
7855: PPUSH
7856: CALL_OW 307
7860: PUSH
7861: LD_VAR 0 5
7865: PUSH
7866: LD_INT 175
7868: GREATER
7869: OR
7870: IFFALSE 7838
// ComTurnUnit ( Walker , JMM ) ;
7872: LD_EXP 48
7876: PPUSH
7877: LD_EXP 37
7881: PPUSH
7882: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7886: LD_EXP 48
7890: PPUSH
7891: LD_STRING D2a-Sci1-1
7893: PPUSH
7894: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7898: LD_EXP 37
7902: PPUSH
7903: LD_EXP 48
7907: PPUSH
7908: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7912: LD_EXP 37
7916: PPUSH
7917: LD_STRING D2a-JMM-2
7919: PPUSH
7920: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7924: LD_EXP 48
7928: PPUSH
7929: LD_STRING D2a-Sci1-2
7931: PPUSH
7932: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7936: LD_EXP 37
7940: PPUSH
7941: LD_STRING D2a-JMM-3
7943: PPUSH
7944: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7948: LD_EXP 48
7952: PPUSH
7953: LD_STRING D2a-Sci1-3
7955: PPUSH
7956: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7960: LD_ADDR_EXP 4
7964: PUSH
7965: LD_EXP 4
7969: PUSH
7970: LD_EXP 47
7974: PUSH
7975: LD_EXP 48
7979: PUSH
7980: LD_EXP 49
7984: PUSH
7985: LD_EXP 50
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: ADD
7996: ST_TO_ADDR
// for i in jmm_units do
7997: LD_ADDR_VAR 0 1
8001: PUSH
8002: LD_EXP 4
8006: PUSH
8007: FOR_IN
8008: IFFALSE 8033
// if not IsInUnit ( i ) then
8010: LD_VAR 0 1
8014: PPUSH
8015: CALL_OW 310
8019: NOT
8020: IFFALSE 8031
// ComFree ( i ) ;
8022: LD_VAR 0 1
8026: PPUSH
8027: CALL_OW 139
8031: GO 8007
8033: POP
8034: POP
// Video ( false ) ;
8035: LD_INT 0
8037: PPUSH
8038: CALL 1200 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
8042: LD_STRING MSolar1
8044: PPUSH
8045: CALL_OW 337
// jmm_on_west := true ;
8049: LD_ADDR_EXP 5
8053: PUSH
8054: LD_INT 1
8056: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
8057: LD_INT 1050
8059: PPUSH
8060: CALL_OW 67
// frank_can_return := true ;
8064: LD_ADDR_EXP 12
8068: PUSH
8069: LD_INT 1
8071: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
8072: LD_INT 6300
8074: PPUSH
8075: LD_INT 8400
8077: PPUSH
8078: CALL_OW 12
8082: PPUSH
8083: CALL_OW 67
// send_spec_patrol := true ;
8087: LD_ADDR_EXP 30
8091: PUSH
8092: LD_INT 1
8094: ST_TO_ADDR
// end ;
8095: PPOPN 5
8097: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
8098: LD_INT 22
8100: PUSH
8101: LD_INT 1
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: LD_INT 34
8110: PUSH
8111: LD_INT 51
8113: PUSH
8114: EMPTY
8115: LIST
8116: LIST
8117: PUSH
8118: LD_INT 92
8120: PUSH
8121: LD_INT 63
8123: PUSH
8124: LD_INT 100
8126: PUSH
8127: LD_INT 5
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: LIST
8134: LIST
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: PUSH
8141: EMPTY
8142: LIST
8143: PPUSH
8144: CALL_OW 69
8148: PUSH
8149: LD_EXP 5
8153: NOT
8154: AND
8155: IFFALSE 8268
8157: GO 8159
8159: DISABLE
8160: LD_INT 0
8162: PPUSH
8163: PPUSH
// begin enable ;
8164: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8165: LD_ADDR_VAR 0 2
8169: PUSH
8170: LD_INT 22
8172: PUSH
8173: LD_INT 1
8175: PUSH
8176: EMPTY
8177: LIST
8178: LIST
8179: PUSH
8180: LD_INT 34
8182: PUSH
8183: LD_INT 51
8185: PUSH
8186: EMPTY
8187: LIST
8188: LIST
8189: PUSH
8190: LD_INT 92
8192: PUSH
8193: LD_INT 63
8195: PUSH
8196: LD_INT 100
8198: PUSH
8199: LD_INT 5
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: LIST
8206: LIST
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: PUSH
8213: EMPTY
8214: LIST
8215: PPUSH
8216: CALL_OW 69
8220: ST_TO_ADDR
// if not filter then
8221: LD_VAR 0 2
8225: NOT
8226: IFFALSE 8230
// exit ;
8228: GO 8268
// for i in filter do
8230: LD_ADDR_VAR 0 1
8234: PUSH
8235: LD_VAR 0 2
8239: PUSH
8240: FOR_IN
8241: IFFALSE 8266
// begin SetFuel ( i , 0 ) ;
8243: LD_VAR 0 1
8247: PPUSH
8248: LD_INT 0
8250: PPUSH
8251: CALL_OW 240
// ComStop ( i ) ;
8255: LD_VAR 0 1
8259: PPUSH
8260: CALL_OW 141
// end ;
8264: GO 8240
8266: POP
8267: POP
// end ;
8268: PPOPN 2
8270: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8271: LD_EXP 30
8275: IFFALSE 9372
8277: GO 8279
8279: DISABLE
8280: LD_INT 0
8282: PPUSH
8283: PPUSH
8284: PPUSH
8285: PPUSH
8286: PPUSH
8287: PPUSH
8288: PPUSH
// begin if not ru_spec_patrol then
8289: LD_EXP 54
8293: NOT
8294: IFFALSE 8298
// exit ;
8296: GO 9372
// dead1 := false ;
8298: LD_ADDR_VAR 0 1
8302: PUSH
8303: LD_INT 0
8305: ST_TO_ADDR
// dead2 := false ;
8306: LD_ADDR_VAR 0 2
8310: PUSH
8311: LD_INT 0
8313: ST_TO_ADDR
// inarea1 := false ;
8314: LD_ADDR_VAR 0 3
8318: PUSH
8319: LD_INT 0
8321: ST_TO_ADDR
// inarea2 := false ;
8322: LD_ADDR_VAR 0 4
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
// tmp := [ ] ;
8330: LD_ADDR_VAR 0 6
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8337: LD_EXP 54
8341: PPUSH
8342: LD_INT 75
8344: PPUSH
8345: LD_INT 101
8347: PPUSH
8348: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8352: LD_INT 35
8354: PPUSH
8355: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8359: LD_INT 1
8361: PPUSH
8362: LD_EXP 54
8366: PUSH
8367: LD_INT 1
8369: ARRAY
8370: PPUSH
8371: CALL_OW 292
8375: IFFALSE 8352
// ComStop ( ru_spec_patrol ) ;
8377: LD_EXP 54
8381: PPUSH
8382: CALL_OW 141
// Wait ( 0 0$02 ) ;
8386: LD_INT 70
8388: PPUSH
8389: CALL_OW 67
// DialogueOn ;
8393: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8397: LD_EXP 54
8401: PUSH
8402: LD_INT 1
8404: ARRAY
8405: PPUSH
8406: LD_STRING D8-Rus1-1
8408: PPUSH
8409: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8413: LD_EXP 37
8417: PPUSH
8418: LD_STRING D8-JMM-1
8420: PPUSH
8421: CALL_OW 88
// DialogueOff ;
8425: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8429: LD_EXP 54
8433: PPUSH
8434: LD_INT 13
8436: PPUSH
8437: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8448: LD_VAR 0 1
8452: NOT
8453: PUSH
8454: LD_EXP 54
8458: PUSH
8459: LD_INT 1
8461: ARRAY
8462: PPUSH
8463: CALL_OW 301
8467: AND
8468: IFFALSE 8478
// dead1 := true ;
8470: LD_ADDR_VAR 0 1
8474: PUSH
8475: LD_INT 1
8477: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8478: LD_VAR 0 2
8482: NOT
8483: PUSH
8484: LD_EXP 54
8488: PUSH
8489: LD_INT 2
8491: ARRAY
8492: PPUSH
8493: CALL_OW 301
8497: AND
8498: IFFALSE 8508
// dead2 := true ;
8500: LD_ADDR_VAR 0 2
8504: PUSH
8505: LD_INT 1
8507: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8508: LD_VAR 0 3
8512: NOT
8513: PUSH
8514: LD_EXP 54
8518: PUSH
8519: LD_INT 1
8521: ARRAY
8522: PPUSH
8523: LD_INT 14
8525: PPUSH
8526: CALL_OW 308
8530: AND
8531: IFFALSE 8541
// inarea1 := true ;
8533: LD_ADDR_VAR 0 3
8537: PUSH
8538: LD_INT 1
8540: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8541: LD_VAR 0 4
8545: NOT
8546: PUSH
8547: LD_EXP 54
8551: PUSH
8552: LD_INT 2
8554: ARRAY
8555: PPUSH
8556: LD_INT 14
8558: PPUSH
8559: CALL_OW 308
8563: AND
8564: IFFALSE 8574
// inarea2 := true ;
8566: LD_ADDR_VAR 0 4
8570: PUSH
8571: LD_INT 1
8573: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8574: LD_VAR 0 1
8578: PUSH
8579: LD_VAR 0 2
8583: AND
8584: PUSH
8585: LD_VAR 0 1
8589: PUSH
8590: LD_VAR 0 4
8594: AND
8595: OR
8596: PUSH
8597: LD_VAR 0 2
8601: PUSH
8602: LD_VAR 0 3
8606: AND
8607: OR
8608: PUSH
8609: LD_VAR 0 3
8613: PUSH
8614: LD_VAR 0 4
8618: AND
8619: OR
8620: IFFALSE 8441
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8622: LD_VAR 0 3
8626: PUSH
8627: LD_VAR 0 4
8631: AND
8632: PUSH
8633: LD_VAR 0 1
8637: PUSH
8638: LD_VAR 0 4
8642: AND
8643: OR
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: LD_VAR 0 3
8654: AND
8655: OR
8656: IFFALSE 9352
// begin prepare_siege := true ;
8658: LD_ADDR_EXP 31
8662: PUSH
8663: LD_INT 1
8665: ST_TO_ADDR
// DialogueOn ;
8666: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8670: LD_VAR 0 3
8674: PUSH
8675: LD_VAR 0 4
8679: AND
8680: IFFALSE 8696
// Say ( JMM , D8b-JMM-1a ) else
8682: LD_EXP 37
8686: PPUSH
8687: LD_STRING D8b-JMM-1a
8689: PPUSH
8690: CALL_OW 88
8694: GO 8708
// Say ( JMM , D8b-JMM-1 ) ;
8696: LD_EXP 37
8700: PPUSH
8701: LD_STRING D8b-JMM-1
8703: PPUSH
8704: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8708: LD_EXP 4
8712: PPUSH
8713: LD_INT 26
8715: PUSH
8716: LD_INT 1
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PPUSH
8723: CALL_OW 72
8727: PUSH
8728: LD_EXP 38
8732: PUSH
8733: LD_EXP 39
8737: PUSH
8738: LD_EXP 48
8742: PUSH
8743: LD_EXP 51
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: DIFF
8754: PPUSH
8755: LD_STRING D8b-Sol1-1
8757: PPUSH
8758: CALL 640 0 2
// if Cyrus and Cyrus in jmm_units then
8762: LD_EXP 39
8766: PUSH
8767: LD_EXP 39
8771: PUSH
8772: LD_EXP 4
8776: IN
8777: AND
8778: IFFALSE 8794
// Say ( Cyrus , D8b-Cyrus-1 ) else
8780: LD_EXP 39
8784: PPUSH
8785: LD_STRING D8b-Cyrus-1
8787: PPUSH
8788: CALL_OW 88
8792: GO 8806
// Say ( JMM , D8b-JMM-1a ) ;
8794: LD_EXP 37
8798: PPUSH
8799: LD_STRING D8b-JMM-1a
8801: PPUSH
8802: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8806: LD_EXP 40
8810: PUSH
8811: LD_EXP 40
8815: PUSH
8816: LD_EXP 4
8820: IN
8821: AND
8822: IFFALSE 8836
// Say ( Lisa , D8b-Lisa-2 ) ;
8824: LD_EXP 40
8828: PPUSH
8829: LD_STRING D8b-Lisa-2
8831: PPUSH
8832: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8836: LD_EXP 38
8840: PUSH
8841: LD_EXP 38
8845: PUSH
8846: LD_EXP 4
8850: IN
8851: AND
8852: IFFALSE 8868
// Say ( Bobby , D8b-Bobby-1 ) else
8854: LD_EXP 38
8858: PPUSH
8859: LD_STRING D8b-Bobby-1
8861: PPUSH
8862: CALL_OW 88
8866: GO 8928
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8868: LD_ADDR_VAR 0 5
8872: PUSH
8873: LD_EXP 4
8877: PPUSH
8878: LD_INT 26
8880: PUSH
8881: LD_INT 1
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PPUSH
8888: CALL_OW 72
8892: PUSH
8893: LD_EXP 38
8897: PUSH
8898: LD_EXP 39
8902: PUSH
8903: LD_EXP 48
8907: PUSH
8908: LD_EXP 51
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: LIST
8917: LIST
8918: DIFF
8919: PPUSH
8920: LD_STRING D8b-Sol2-1
8922: PPUSH
8923: CALL 640 0 2
8927: ST_TO_ADDR
// DialogueOff ;
8928: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8932: LD_EXP 39
8936: PUSH
8937: LD_EXP 39
8941: PUSH
8942: LD_EXP 4
8946: IN
8947: AND
8948: IFFALSE 8973
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8950: LD_ADDR_VAR 0 6
8954: PUSH
8955: LD_VAR 0 6
8959: PPUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_EXP 39
8967: PPUSH
8968: CALL_OW 2
8972: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8973: LD_EXP 38
8977: PUSH
8978: LD_EXP 38
8982: PUSH
8983: LD_EXP 4
8987: IN
8988: AND
8989: IFFALSE 9014
// tmp := Insert ( tmp , 1 , Bobby ) ;
8991: LD_ADDR_VAR 0 6
8995: PUSH
8996: LD_VAR 0 6
9000: PPUSH
9001: LD_INT 1
9003: PPUSH
9004: LD_EXP 38
9008: PPUSH
9009: CALL_OW 2
9013: ST_TO_ADDR
// if sol then
9014: LD_VAR 0 5
9018: IFFALSE 9043
// tmp := Insert ( tmp , 1 , sol ) ;
9020: LD_ADDR_VAR 0 6
9024: PUSH
9025: LD_VAR 0 6
9029: PPUSH
9030: LD_INT 1
9032: PPUSH
9033: LD_VAR 0 5
9037: PPUSH
9038: CALL_OW 2
9042: ST_TO_ADDR
// if tmp then
9043: LD_VAR 0 6
9047: IFFALSE 9311
// begin SetSide ( tmp , 8 ) ;
9049: LD_VAR 0 6
9053: PPUSH
9054: LD_INT 8
9056: PPUSH
9057: CALL_OW 235
// for i in tmp do
9061: LD_ADDR_VAR 0 7
9065: PUSH
9066: LD_VAR 0 6
9070: PUSH
9071: FOR_IN
9072: IFFALSE 9163
// begin if IsInUnit ( i ) and GetBType ( IsInUnit ( i ) ) = unit_building then
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 310
9083: PUSH
9084: LD_VAR 0 7
9088: PPUSH
9089: CALL_OW 310
9093: PPUSH
9094: CALL_OW 266
9098: PUSH
9099: LD_INT 3
9101: EQUAL
9102: AND
9103: IFFALSE 9114
// ComExitBuilding ( i ) ;
9105: LD_VAR 0 7
9109: PPUSH
9110: CALL_OW 122
// if IsInUnit ( i ) and GetBType ( IsInUnit ( i ) ) = unit_vehicle then
9114: LD_VAR 0 7
9118: PPUSH
9119: CALL_OW 310
9123: PUSH
9124: LD_VAR 0 7
9128: PPUSH
9129: CALL_OW 310
9133: PPUSH
9134: CALL_OW 266
9138: PUSH
9139: LD_INT 2
9141: EQUAL
9142: AND
9143: IFFALSE 9154
// ComExitVehicle ( i ) ;
9145: LD_VAR 0 7
9149: PPUSH
9150: CALL_OW 121
// wait ( 0 0$1 ) ;
9154: LD_INT 35
9156: PPUSH
9157: CALL_OW 67
// end ;
9161: GO 9071
9163: POP
9164: POP
// ComFree ( tmp ) ;
9165: LD_VAR 0 6
9169: PPUSH
9170: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
9174: LD_VAR 0 6
9178: PPUSH
9179: LD_INT 15
9181: PPUSH
9182: CALL_OW 173
// AddComHold ( tmp ) ;
9186: LD_VAR 0 6
9190: PPUSH
9191: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
9195: LD_INT 35
9197: PPUSH
9198: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
9202: LD_VAR 0 6
9206: PUSH
9207: LD_INT 1
9209: ARRAY
9210: PPUSH
9211: CALL_OW 314
9215: NOT
9216: IFFALSE 9230
// ComMoveToArea ( tmp , cyrusEscape ) ;
9218: LD_VAR 0 6
9222: PPUSH
9223: LD_INT 15
9225: PPUSH
9226: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9230: LD_VAR 0 6
9234: PUSH
9235: LD_INT 1
9237: ARRAY
9238: PPUSH
9239: LD_INT 15
9241: PPUSH
9242: CALL_OW 308
9246: IFFALSE 9301
// begin RemoveUnit ( tmp [ 1 ] ) ;
9248: LD_VAR 0 6
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9261: LD_ADDR_EXP 4
9265: PUSH
9266: LD_EXP 4
9270: PUSH
9271: LD_VAR 0 6
9275: PUSH
9276: LD_INT 1
9278: ARRAY
9279: DIFF
9280: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9281: LD_ADDR_VAR 0 6
9285: PUSH
9286: LD_VAR 0 6
9290: PUSH
9291: LD_VAR 0 6
9295: PUSH
9296: LD_INT 1
9298: ARRAY
9299: DIFF
9300: ST_TO_ADDR
// end ; until tmp = 0 ;
9301: LD_VAR 0 6
9305: PUSH
9306: LD_INT 0
9308: EQUAL
9309: IFFALSE 9195
// end ; wait ( 0 0$30 ) ;
9311: LD_INT 1050
9313: PPUSH
9314: CALL_OW 67
// if ru_spec_patrol then
9318: LD_EXP 54
9322: IFFALSE 9350
// for i in ru_spec_patrol do
9324: LD_ADDR_VAR 0 7
9328: PUSH
9329: LD_EXP 54
9333: PUSH
9334: FOR_IN
9335: IFFALSE 9348
// RemoveUnit ( i ) ;
9337: LD_VAR 0 7
9341: PPUSH
9342: CALL_OW 64
9346: GO 9334
9348: POP
9349: POP
// end else
9350: GO 9372
// begin prepare_siege := false ;
9352: LD_ADDR_EXP 31
9356: PUSH
9357: LD_INT 0
9359: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9360: LD_EXP 37
9364: PPUSH
9365: LD_STRING D8a-JMM-1
9367: PPUSH
9368: CALL_OW 88
// end ; end ;
9372: PPOPN 7
9374: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9375: LD_EXP 12
9379: IFFALSE 10596
9381: GO 9383
9383: DISABLE
9384: LD_INT 0
9386: PPUSH
9387: PPUSH
9388: PPUSH
// begin uc_side := 8 ;
9389: LD_ADDR_OWVAR 20
9393: PUSH
9394: LD_INT 8
9396: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9397: LD_ADDR_VAR 0 3
9401: PUSH
9402: LD_INT 59
9404: PUSH
9405: LD_INT 71
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: LD_INT 122
9414: PUSH
9415: LD_INT 117
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9426: LD_ADDR_EXP 51
9430: PUSH
9431: LD_STRING Frank
9433: PPUSH
9434: LD_INT 0
9436: PPUSH
9437: CALL 489 0 2
9441: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9442: LD_ADDR_VAR 0 1
9446: PUSH
9447: LD_INT 1
9449: PPUSH
9450: LD_INT 2
9452: PPUSH
9453: CALL_OW 12
9457: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9458: LD_EXP 51
9462: PPUSH
9463: LD_VAR 0 3
9467: PUSH
9468: LD_VAR 0 1
9472: ARRAY
9473: PUSH
9474: LD_INT 1
9476: ARRAY
9477: PPUSH
9478: LD_VAR 0 3
9482: PUSH
9483: LD_VAR 0 1
9487: ARRAY
9488: PUSH
9489: LD_INT 2
9491: ARRAY
9492: PPUSH
9493: LD_INT 0
9495: PPUSH
9496: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9500: LD_EXP 51
9504: PPUSH
9505: LD_INT 1
9507: PPUSH
9508: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9512: LD_INT 35
9514: PPUSH
9515: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9519: LD_EXP 51
9523: PPUSH
9524: LD_EXP 37
9528: PPUSH
9529: CALL_OW 296
9533: PUSH
9534: LD_INT 8
9536: LESS
9537: PUSH
9538: LD_EXP 51
9542: PPUSH
9543: CALL_OW 256
9547: PUSH
9548: LD_INT 250
9550: GREATER
9551: AND
9552: IFFALSE 9512
// Video ( true ) ;
9554: LD_INT 1
9556: PPUSH
9557: CALL 1200 0 1
// CenterOnUnits ( JMM ) ;
9561: LD_EXP 37
9565: PPUSH
9566: CALL_OW 85
// if IsInUnit ( JMM ) then
9570: LD_EXP 37
9574: PPUSH
9575: CALL_OW 310
9579: IFFALSE 9590
// ComFree ( JMM ) ;
9581: LD_EXP 37
9585: PPUSH
9586: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9590: LD_EXP 37
9594: PPUSH
9595: LD_EXP 51
9599: PPUSH
9600: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9604: LD_EXP 51
9608: PPUSH
9609: LD_EXP 37
9613: PPUSH
9614: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9618: LD_EXP 37
9622: PPUSH
9623: LD_STRING D6-JMM-1
9625: PPUSH
9626: CALL_OW 88
// p := 0 ;
9630: LD_ADDR_VAR 0 2
9634: PUSH
9635: LD_INT 0
9637: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9638: LD_INT 35
9640: PPUSH
9641: CALL_OW 67
// p := p + 1 ;
9645: LD_ADDR_VAR 0 2
9649: PUSH
9650: LD_VAR 0 2
9654: PUSH
9655: LD_INT 1
9657: PLUS
9658: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9659: LD_EXP 37
9663: PPUSH
9664: LD_EXP 51
9668: PPUSH
9669: CALL_OW 296
9673: PUSH
9674: LD_INT 8
9676: LESS
9677: PUSH
9678: LD_VAR 0 2
9682: PUSH
9683: LD_INT 7
9685: GREATER
9686: OR
9687: IFFALSE 9638
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9689: LD_EXP 40
9693: PUSH
9694: LD_EXP 40
9698: PPUSH
9699: LD_EXP 51
9703: PPUSH
9704: CALL_OW 296
9708: PUSH
9709: LD_INT 20
9711: LESS
9712: AND
9713: IFFALSE 9738
// begin ComFree ( Lisa ) ;
9715: LD_EXP 40
9719: PPUSH
9720: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9724: LD_EXP 40
9728: PPUSH
9729: LD_EXP 51
9733: PPUSH
9734: CALL_OW 172
// end ; if Lynch then
9738: LD_EXP 47
9742: IFFALSE 9767
// begin ComFree ( Lynch ) ;
9744: LD_EXP 47
9748: PPUSH
9749: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9753: LD_EXP 47
9757: PPUSH
9758: LD_EXP 51
9762: PPUSH
9763: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9767: LD_EXP 37
9771: PPUSH
9772: LD_EXP 51
9776: PPUSH
9777: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9781: LD_EXP 51
9785: PPUSH
9786: LD_EXP 37
9790: PPUSH
9791: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9795: LD_EXP 51
9799: PPUSH
9800: LD_STRING D6-Frank-1
9802: PPUSH
9803: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9807: LD_INT 69
9809: PPUSH
9810: LD_INT 20
9812: PPUSH
9813: LD_INT 1
9815: PPUSH
9816: LD_INT 20
9818: NEG
9819: PPUSH
9820: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9824: LD_INT 69
9826: PPUSH
9827: LD_INT 20
9829: PPUSH
9830: LD_INT 1
9832: PPUSH
9833: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9837: LD_INT 190
9839: PPUSH
9840: LD_INT 31
9842: PPUSH
9843: LD_INT 1
9845: PPUSH
9846: LD_INT 20
9848: NEG
9849: PPUSH
9850: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9854: LD_INT 190
9856: PPUSH
9857: LD_INT 31
9859: PPUSH
9860: LD_INT 1
9862: PPUSH
9863: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9867: LD_INT 69
9869: PPUSH
9870: LD_INT 20
9872: PPUSH
9873: CALL_OW 84
// Wait ( 0 0$02 ) ;
9877: LD_INT 70
9879: PPUSH
9880: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9884: LD_EXP 37
9888: PPUSH
9889: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9893: LD_EXP 40
9897: PUSH
9898: LD_EXP 40
9902: PPUSH
9903: LD_EXP 51
9907: PPUSH
9908: CALL_OW 296
9912: PUSH
9913: LD_INT 20
9915: LESS
9916: AND
9917: PUSH
9918: LD_EXP 40
9922: PPUSH
9923: CALL_OW 302
9927: AND
9928: IFFALSE 10050
// begin ComFree ( Lisa ) ;
9930: LD_EXP 40
9934: PPUSH
9935: CALL_OW 139
// p := 0 ;
9939: LD_ADDR_VAR 0 2
9943: PUSH
9944: LD_INT 0
9946: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// p := p + 1 ;
9954: LD_ADDR_VAR 0 2
9958: PUSH
9959: LD_VAR 0 2
9963: PUSH
9964: LD_INT 1
9966: PLUS
9967: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9968: LD_EXP 40
9972: PPUSH
9973: LD_EXP 51
9977: PPUSH
9978: CALL_OW 296
9982: PUSH
9983: LD_INT 7
9985: LESS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 7
9994: GREATER
9995: OR
9996: IFFALSE 9947
// Say ( Lisa , D6-Lisa-1 ) ;
9998: LD_EXP 40
10002: PPUSH
10003: LD_STRING D6-Lisa-1
10005: PPUSH
10006: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
10010: LD_EXP 40
10014: PPUSH
10015: LD_EXP 51
10019: PPUSH
10020: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
10024: LD_EXP 51
10028: PPUSH
10029: LD_EXP 40
10033: PPUSH
10034: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
10038: LD_EXP 51
10042: PPUSH
10043: LD_STRING D6-Frank-2
10045: PPUSH
10046: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
10050: LD_EXP 47
10054: PUSH
10055: LD_EXP 47
10059: PPUSH
10060: LD_EXP 51
10064: PPUSH
10065: CALL_OW 296
10069: PUSH
10070: LD_INT 20
10072: LESS
10073: AND
10074: PUSH
10075: LD_EXP 47
10079: PPUSH
10080: CALL_OW 302
10084: AND
10085: IFFALSE 10266
// begin ComTurnUnit ( Lynch , JMM ) ;
10087: LD_EXP 47
10091: PPUSH
10092: LD_EXP 37
10096: PPUSH
10097: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
10101: LD_EXP 51
10105: PPUSH
10106: LD_EXP 37
10110: PPUSH
10111: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
10115: LD_EXP 47
10119: PPUSH
10120: LD_STRING D6-Sol1-2
10122: PPUSH
10123: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
10127: LD_EXP 37
10131: PPUSH
10132: LD_STRING D6-JMM-2
10134: PPUSH
10135: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
10139: LD_EXP 51
10143: PPUSH
10144: LD_STRING D6-Frank-3
10146: PPUSH
10147: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
10151: LD_EXP 37
10155: PPUSH
10156: LD_STRING D6-JMM-3
10158: PPUSH
10159: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
10163: LD_EXP 51
10167: PPUSH
10168: LD_STRING D6-Frank-4
10170: PPUSH
10171: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10175: LD_EXP 51
10179: PPUSH
10180: LD_STRING D6-Frank-4a
10182: PPUSH
10183: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10187: LD_EXP 37
10191: PPUSH
10192: LD_STRING D6-JMM-4
10194: PPUSH
10195: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10199: LD_EXP 51
10203: PPUSH
10204: LD_STRING D6-Frank-5
10206: PPUSH
10207: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10211: LD_EXP 40
10215: PUSH
10216: LD_EXP 40
10220: PPUSH
10221: CALL_OW 302
10225: AND
10226: IFFALSE 10240
// Say ( Lisa , D6-Lisa-5 ) ;
10228: LD_EXP 40
10232: PPUSH
10233: LD_STRING D6-Lisa-5
10235: PPUSH
10236: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10240: LD_EXP 51
10244: PPUSH
10245: LD_STRING D6-Frank-6
10247: PPUSH
10248: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10252: LD_EXP 37
10256: PPUSH
10257: LD_STRING D6-JMM-6
10259: PPUSH
10260: CALL_OW 88
// end else
10264: GO 10381
// begin ComTurnUnit ( Frank , JMM ) ;
10266: LD_EXP 51
10270: PPUSH
10271: LD_EXP 37
10275: PPUSH
10276: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10280: LD_EXP 51
10284: PPUSH
10285: LD_STRING D6-Frank-4
10287: PPUSH
10288: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10292: LD_EXP 51
10296: PPUSH
10297: LD_STRING D6-Frank-4a
10299: PPUSH
10300: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10304: LD_EXP 37
10308: PPUSH
10309: LD_STRING D6-JMM-4
10311: PPUSH
10312: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10316: LD_EXP 51
10320: PPUSH
10321: LD_STRING D6-Frank-5
10323: PPUSH
10324: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10328: LD_EXP 40
10332: PUSH
10333: LD_EXP 40
10337: PPUSH
10338: CALL_OW 302
10342: AND
10343: IFFALSE 10357
// Say ( Lisa , D6-Lisa-5 ) ;
10345: LD_EXP 40
10349: PPUSH
10350: LD_STRING D6-Lisa-5
10352: PPUSH
10353: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10357: LD_EXP 51
10361: PPUSH
10362: LD_STRING D6-Frank-6
10364: PPUSH
10365: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10369: LD_EXP 37
10373: PPUSH
10374: LD_STRING D6-JMM-6
10376: PPUSH
10377: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10381: LD_STRING Q1
10383: PPUSH
10384: CALL_OW 97
10388: PUSH
10389: LD_INT 1
10391: DOUBLE
10392: EQUAL
10393: IFTRUE 10397
10395: GO 10408
10397: POP
// frank_send_to_scout := true ; 2 :
10398: LD_ADDR_EXP 15
10402: PUSH
10403: LD_INT 1
10405: ST_TO_ADDR
10406: GO 10428
10408: LD_INT 2
10410: DOUBLE
10411: EQUAL
10412: IFTRUE 10416
10414: GO 10427
10416: POP
// frank_send_to_scout := false ; end ;
10417: LD_ADDR_EXP 15
10421: PUSH
10422: LD_INT 0
10424: ST_TO_ADDR
10425: GO 10428
10427: POP
// Video ( false ) ;
10428: LD_INT 0
10430: PPUSH
10431: CALL 1200 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10435: LD_EXP 37
10439: PUSH
10440: LD_EXP 40
10444: PUSH
10445: LD_EXP 47
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: LIST
10454: PPUSH
10455: CALL_OW 139
// if frank_send_to_scout then
10459: LD_EXP 15
10463: IFFALSE 10517
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10465: LD_EXP 51
10469: PPUSH
10470: LD_INT 15
10472: PPUSH
10473: CALL_OW 113
// wait ( 0 0$01 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until not See ( 1 , Frank ) ;
10484: LD_INT 1
10486: PPUSH
10487: LD_EXP 51
10491: PPUSH
10492: CALL_OW 292
10496: NOT
10497: IFFALSE 10465
// wait ( 0 0$02 ) ;
10499: LD_INT 70
10501: PPUSH
10502: CALL_OW 67
// RemoveUnit ( Frank ) ;
10506: LD_EXP 51
10510: PPUSH
10511: CALL_OW 64
// end else
10515: GO 10529
// SetSide ( Frank , 1 ) ;
10517: LD_EXP 51
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL_OW 235
// send_attack_on_cornel_base := true ;
10529: LD_ADDR_EXP 26
10533: PUSH
10534: LD_INT 1
10536: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10537: LD_INT 35
10539: PPUSH
10540: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10544: LD_ADDR_EXP 29
10548: PUSH
10549: LD_EXP 29
10553: PPUSH
10554: LD_STRING -
10556: PPUSH
10557: CALL 1132 0 2
10561: ST_TO_ADDR
// if debug then
10562: LD_EXP 1
10566: IFFALSE 10578
// debug_strings := time_to_prepare ;
10568: LD_ADDR_OWVAR 48
10572: PUSH
10573: LD_EXP 29
10577: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10578: LD_EXP 29
10582: PUSH
10583: LD_INT 0
10585: EQUAL
10586: IFFALSE 10537
// cornel_prepared := true ;
10588: LD_ADDR_EXP 11
10592: PUSH
10593: LD_INT 1
10595: ST_TO_ADDR
// end ;
10596: PPOPN 3
10598: END
// every 0 0$01 trigger cornel_prepared do
10599: LD_EXP 11
10603: IFFALSE 10867
10605: GO 10607
10607: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10608: LD_EXP 44
10612: PPUSH
10613: LD_STRING D3-Corn-1
10615: PPUSH
10616: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10620: LD_STRING MOutWait
10622: PPUSH
10623: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10627: LD_INT 35
10629: PPUSH
10630: CALL_OW 67
// until cornel_counter = 0 ;
10634: LD_EXP 10
10638: PUSH
10639: LD_INT 0
10641: EQUAL
10642: IFFALSE 10627
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10644: LD_EXP 44
10648: PPUSH
10649: LD_STRING D3a-Corn-1
10651: PPUSH
10652: CALL_OW 94
// if IsOk ( Cornel ) then
10656: LD_EXP 44
10660: PPUSH
10661: CALL_OW 302
10665: IFFALSE 10679
// Say ( JMM , D3a-JMM-1 ) ;
10667: LD_EXP 37
10671: PPUSH
10672: LD_STRING D3a-JMM-1
10674: PPUSH
10675: CALL_OW 88
// end_mission_allowed := true ;
10679: LD_ADDR_EXP 21
10683: PUSH
10684: LD_INT 1
10686: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10687: LD_STRING M2
10689: PPUSH
10690: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10694: LD_INT 9
10696: PPUSH
10697: LD_INT 1
10699: PPUSH
10700: CALL_OW 424
// Wait ( 0 0$05 ) ;
10704: LD_INT 175
10706: PPUSH
10707: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10711: LD_EXP 44
10715: PPUSH
10716: LD_STRING D3a-Corn-2
10718: PPUSH
10719: CALL_OW 94
// cornel_attack := true ;
10723: LD_ADDR_EXP 9
10727: PUSH
10728: LD_INT 1
10730: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10731: LD_INT 105
10733: PPUSH
10734: CALL_OW 67
// AddMoreTanks ( ) ;
10738: CALL 4952 0 0
// if frank_send_to_scout then
10742: LD_EXP 15
10746: IFFALSE 10867
// begin InitHc ;
10748: CALL_OW 19
// InitUc ;
10752: CALL_OW 18
// uc_side := 8 ;
10756: LD_ADDR_OWVAR 20
10760: PUSH
10761: LD_INT 8
10763: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10764: LD_ADDR_EXP 51
10768: PUSH
10769: LD_STRING Frank
10771: PPUSH
10772: LD_INT 0
10774: PPUSH
10775: CALL 489 0 2
10779: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10780: LD_EXP 51
10784: PPUSH
10785: LD_INT 6
10787: PPUSH
10788: LD_INT 9
10790: PPUSH
10791: LD_INT 0
10793: PPUSH
10794: CALL_OW 48
// ComCrawl ( Frank ) ;
10798: LD_EXP 51
10802: PPUSH
10803: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10807: LD_INT 35
10809: PPUSH
10810: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10814: LD_EXP 37
10818: PPUSH
10819: LD_EXP 51
10823: PPUSH
10824: CALL_OW 296
10828: PUSH
10829: LD_INT 9
10831: LESS
10832: IFFALSE 10807
// SetSide ( Frank , 1 ) ;
10834: LD_EXP 51
10838: PPUSH
10839: LD_INT 1
10841: PPUSH
10842: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10846: LD_EXP 51
10850: PPUSH
10851: LD_STRING D6a-Frank-1
10853: PPUSH
10854: CALL_OW 88
// ComWalk ( Frank ) ;
10858: LD_EXP 51
10862: PPUSH
10863: CALL_OW 138
// end ; end ;
10867: END
// every 0 0$01 trigger solar_builded do
10868: LD_EXP 14
10872: IFFALSE 10976
10874: GO 10876
10876: DISABLE
// begin Wait ( 0 0$02 ) ;
10877: LD_INT 70
10879: PPUSH
10880: CALL_OW 67
// DialogueOn ;
10884: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10888: LD_EXP 37
10892: PPUSH
10893: LD_STRING D2b-JMM-1
10895: PPUSH
10896: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10900: LD_EXP 48
10904: PUSH
10905: LD_EXP 48
10909: PPUSH
10910: CALL_OW 302
10914: AND
10915: IFFALSE 10965
// begin Say ( Walker , D2b-Sci1-1 ) ;
10917: LD_EXP 48
10921: PPUSH
10922: LD_STRING D2b-Sci1-1
10924: PPUSH
10925: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10929: LD_EXP 37
10933: PPUSH
10934: LD_STRING D2b-JMM-2
10936: PPUSH
10937: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10941: LD_EXP 48
10945: PPUSH
10946: LD_STRING D2b-Sci1-2
10948: PPUSH
10949: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10953: LD_EXP 37
10957: PPUSH
10958: LD_STRING D2b-JMM-3
10960: PPUSH
10961: CALL_OW 88
// end ; DialogueOff ;
10965: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10969: LD_STRING MOutSol
10971: PPUSH
10972: CALL_OW 337
// end ;
10976: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10977: LD_EXP 14
10981: PUSH
10982: LD_EXP 37
10986: PPUSH
10987: CALL_OW 302
10991: AND
10992: PUSH
10993: LD_EXP 37
10997: PPUSH
10998: CALL 966 0 1
11002: AND
11003: PUSH
11004: LD_EXP 16
11008: NOT
11009: AND
11010: IFFALSE 11081
11012: GO 11014
11014: DISABLE
11015: LD_INT 0
11017: PPUSH
// begin jmm_in_veh := true ;
11018: LD_ADDR_EXP 16
11022: PUSH
11023: LD_INT 1
11025: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11026: LD_ADDR_VAR 0 1
11030: PUSH
11031: LD_INT 0
11033: PPUSH
11034: LD_INT 1
11036: PPUSH
11037: CALL_OW 12
11041: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11042: LD_INT 70
11044: PPUSH
11045: CALL_OW 67
// if i then
11049: LD_VAR 0 1
11053: IFFALSE 11069
// Say ( JMM , D2c-JMM-1 ) else
11055: LD_EXP 37
11059: PPUSH
11060: LD_STRING D2c-JMM-1
11062: PPUSH
11063: CALL_OW 88
11067: GO 11081
// Say ( JMM , D2c-JMM-1a ) ;
11069: LD_EXP 37
11073: PPUSH
11074: LD_STRING D2c-JMM-1a
11076: PPUSH
11077: CALL_OW 88
// end ;
11081: PPOPN 1
11083: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
11084: LD_EXP 14
11088: PUSH
11089: LD_EXP 38
11093: PPUSH
11094: CALL_OW 302
11098: AND
11099: PUSH
11100: LD_EXP 38
11104: PPUSH
11105: CALL 966 0 1
11109: AND
11110: PUSH
11111: LD_EXP 17
11115: NOT
11116: AND
11117: IFFALSE 11149
11119: GO 11121
11121: DISABLE
// begin bobby_in_veh := true ;
11122: LD_ADDR_EXP 17
11126: PUSH
11127: LD_INT 1
11129: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11130: LD_INT 70
11132: PPUSH
11133: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
11137: LD_EXP 38
11141: PPUSH
11142: LD_STRING D2c-Bobby-1
11144: PPUSH
11145: CALL_OW 88
11149: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
11150: LD_EXP 14
11154: PUSH
11155: LD_EXP 40
11159: PPUSH
11160: CALL_OW 302
11164: AND
11165: PUSH
11166: LD_EXP 40
11170: PPUSH
11171: CALL 966 0 1
11175: AND
11176: PUSH
11177: LD_EXP 19
11181: NOT
11182: AND
11183: IFFALSE 11215
11185: GO 11187
11187: DISABLE
// begin lisa_in_veh := true ;
11188: LD_ADDR_EXP 19
11192: PUSH
11193: LD_INT 1
11195: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11196: LD_INT 70
11198: PPUSH
11199: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
11203: LD_EXP 40
11207: PPUSH
11208: LD_STRING D2c-Lisa-1
11210: PPUSH
11211: CALL_OW 88
11215: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11216: LD_EXP 14
11220: PUSH
11221: LD_EXP 39
11225: PPUSH
11226: CALL_OW 302
11230: AND
11231: PUSH
11232: LD_EXP 39
11236: PPUSH
11237: CALL 966 0 1
11241: AND
11242: PUSH
11243: LD_EXP 18
11247: NOT
11248: AND
11249: IFFALSE 11320
11251: GO 11253
11253: DISABLE
11254: LD_INT 0
11256: PPUSH
// begin cyrus_in_veh := true ;
11257: LD_ADDR_EXP 18
11261: PUSH
11262: LD_INT 1
11264: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11265: LD_ADDR_VAR 0 1
11269: PUSH
11270: LD_INT 0
11272: PPUSH
11273: LD_INT 1
11275: PPUSH
11276: CALL_OW 12
11280: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11281: LD_INT 70
11283: PPUSH
11284: CALL_OW 67
// if i then
11288: LD_VAR 0 1
11292: IFFALSE 11308
// Say ( Cyrus , D2c-Cyrus-1 ) else
11294: LD_EXP 39
11298: PPUSH
11299: LD_STRING D2c-Cyrus-1
11301: PPUSH
11302: CALL_OW 88
11306: GO 11320
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11308: LD_EXP 39
11312: PPUSH
11313: LD_STRING D2c-Cyrus-1a
11315: PPUSH
11316: CALL_OW 88
// end ;
11320: PPOPN 1
11322: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11323: LD_EXP 44
11327: PPUSH
11328: LD_INT 16
11330: PPUSH
11331: CALL_OW 308
11335: IFFALSE 11616
11337: GO 11339
11339: DISABLE
11340: LD_INT 0
11342: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11343: LD_INT 3
11345: PPUSH
11346: LD_EXP 44
11350: PPUSH
11351: CALL_OW 471
// send_attack_on_cornel := true ;
11355: LD_ADDR_EXP 32
11359: PUSH
11360: LD_INT 1
11362: ST_TO_ADDR
// if ru_vehicles then
11363: LD_EXP 56
11367: IFFALSE 11401
// for i in ru_vehicles do
11369: LD_ADDR_VAR 0 1
11373: PUSH
11374: LD_EXP 56
11378: PUSH
11379: FOR_IN
11380: IFFALSE 11399
// ComAgressiveMove ( i , 215 , 69 ) ;
11382: LD_VAR 0 1
11386: PPUSH
11387: LD_INT 215
11389: PPUSH
11390: LD_INT 69
11392: PPUSH
11393: CALL_OW 114
11397: GO 11379
11399: POP
11400: POP
// if ru_patrol then
11401: LD_EXP 53
11405: IFFALSE 11439
// for i in ru_patrol do
11407: LD_ADDR_VAR 0 1
11411: PUSH
11412: LD_EXP 53
11416: PUSH
11417: FOR_IN
11418: IFFALSE 11437
// ComAgressiveMove ( i , 215 , 69 ) ;
11420: LD_VAR 0 1
11424: PPUSH
11425: LD_INT 215
11427: PPUSH
11428: LD_INT 69
11430: PPUSH
11431: CALL_OW 114
11435: GO 11417
11437: POP
11438: POP
// if frank_send_to_scout then
11439: LD_EXP 15
11443: IFFALSE 11457
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11445: LD_EXP 51
11449: PPUSH
11450: LD_STRING D3b-Frank-1
11452: PPUSH
11453: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11457: LD_INT 105
11459: PPUSH
11460: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11464: LD_EXP 44
11468: PPUSH
11469: LD_STRING D4-Corn-1
11471: PPUSH
11472: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11476: LD_INT 35
11478: PPUSH
11479: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11483: LD_INT 22
11485: PUSH
11486: LD_INT 4
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PUSH
11493: LD_INT 21
11495: PUSH
11496: LD_INT 1
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: PUSH
11503: LD_INT 3
11505: PUSH
11506: LD_INT 24
11508: PUSH
11509: LD_INT 1000
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: EMPTY
11517: LIST
11518: LIST
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: LIST
11524: PPUSH
11525: CALL_OW 69
11529: PUSH
11530: LD_INT 6
11532: LESS
11533: IFFALSE 11476
// if Cornel then
11535: LD_EXP 44
11539: IFFALSE 11579
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11541: LD_EXP 44
11545: PPUSH
11546: LD_STRING D5-Corn-1
11548: PPUSH
11549: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11553: LD_EXP 44
11557: PPUSH
11558: LD_EXP 2
11562: PUSH
11563: LD_STRING Cornel
11565: STR
11566: PPUSH
11567: CALL_OW 38
// cornel_saved := true ;
11571: LD_ADDR_EXP 27
11575: PUSH
11576: LD_INT 1
11578: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11579: LD_INT 4
11581: PPUSH
11582: LD_INT 8
11584: PPUSH
11585: CALL_OW 343
// Wait ( 0 0$01 ) ;
11589: LD_INT 35
11591: PPUSH
11592: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11596: LD_INT 3
11598: PPUSH
11599: LD_EXP 44
11603: PPUSH
11604: CALL_OW 472
// send_attack_on_cornel := false ;
11608: LD_ADDR_EXP 32
11612: PUSH
11613: LD_INT 0
11615: ST_TO_ADDR
// end ;
11616: PPOPN 1
11618: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11619: LD_INT 9
11621: PPUSH
11622: LD_INT 22
11624: PUSH
11625: LD_INT 1
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PPUSH
11632: CALL_OW 70
11636: PUSH
11637: LD_EXP 33
11641: OR
11642: IFFALSE 11863
11644: GO 11646
11646: DISABLE
11647: LD_INT 0
11649: PPUSH
11650: PPUSH
// begin enable ;
11651: ENABLE
// if not jmm_on_west then
11652: LD_EXP 5
11656: NOT
11657: IFFALSE 11668
// begin YouLost ( 4 ) ;
11659: LD_STRING 4
11661: PPUSH
11662: CALL_OW 104
// exit ;
11666: GO 11863
// end ; if not game_end then
11668: LD_EXP 33
11672: NOT
11673: IFFALSE 11683
// game_end := true ;
11675: LD_ADDR_EXP 33
11679: PUSH
11680: LD_INT 1
11682: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11683: LD_ADDR_VAR 0 2
11687: PUSH
11688: LD_INT 9
11690: PPUSH
11691: LD_INT 22
11693: PUSH
11694: LD_INT 1
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PPUSH
11701: CALL_OW 70
11705: ST_TO_ADDR
// if not filter then
11706: LD_VAR 0 2
11710: NOT
11711: IFFALSE 11715
// exit ;
11713: GO 11863
// for i in filter do
11715: LD_ADDR_VAR 0 1
11719: PUSH
11720: LD_VAR 0 2
11724: PUSH
11725: FOR_IN
11726: IFFALSE 11861
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11728: LD_VAR 0 1
11732: PPUSH
11733: CALL_OW 302
11737: PUSH
11738: LD_VAR 0 1
11742: PPUSH
11743: CALL_OW 247
11747: PUSH
11748: LD_INT 2
11750: EQUAL
11751: AND
11752: PUSH
11753: LD_VAR 0 1
11757: PPUSH
11758: CALL_OW 248
11762: PUSH
11763: LD_INT 1
11765: EQUAL
11766: AND
11767: IFFALSE 11824
// begin if i = JMM and save_group < 4 then
11769: LD_VAR 0 1
11773: PUSH
11774: LD_EXP 37
11778: EQUAL
11779: PUSH
11780: LD_EXP 23
11784: PUSH
11785: LD_INT 4
11787: LESS
11788: AND
11789: IFFALSE 11793
// continue ;
11791: GO 11725
// veh_on_meta := true ;
11793: LD_ADDR_EXP 28
11797: PUSH
11798: LD_INT 1
11800: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11801: LD_VAR 0 1
11805: PPUSH
11806: CALL_OW 311
11810: PPUSH
11811: CALL 11866 0 1
// RemoveUnit ( i ) ;
11815: LD_VAR 0 1
11819: PPUSH
11820: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11824: LD_VAR 0 1
11828: PPUSH
11829: CALL_OW 302
11833: PUSH
11834: LD_VAR 0 1
11838: PPUSH
11839: CALL_OW 247
11843: PUSH
11844: LD_INT 1
11846: EQUAL
11847: AND
11848: IFFALSE 11859
// Save ( i ) ;
11850: LD_VAR 0 1
11854: PPUSH
11855: CALL 11866 0 1
// end ;
11859: GO 11725
11861: POP
11862: POP
// end ;
11863: PPOPN 2
11865: END
// export function Save ( i ) ; begin
11866: LD_INT 0
11868: PPUSH
// if i = JMM and save_group >= 4 then
11869: LD_VAR 0 1
11873: PUSH
11874: LD_EXP 37
11878: EQUAL
11879: PUSH
11880: LD_EXP 23
11884: PUSH
11885: LD_INT 4
11887: GREATEREQUAL
11888: AND
11889: IFFALSE 12025
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11891: LD_EXP 24
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_INT 1
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PUSH
11906: LD_INT 21
11908: PUSH
11909: LD_INT 1
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PPUSH
11920: CALL_OW 69
11924: PUSH
11925: LD_INT 1
11927: GREATER
11928: AND
11929: IFFALSE 11986
// begin show_query := false ;
11931: LD_ADDR_EXP 24
11935: PUSH
11936: LD_INT 0
11938: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11939: LD_STRING Q2
11941: PPUSH
11942: CALL_OW 97
11946: PUSH
11947: LD_INT 1
11949: DOUBLE
11950: EQUAL
11951: IFTRUE 11955
11953: GO 11966
11955: POP
// wait_for_them := true ; 2 :
11956: LD_ADDR_EXP 25
11960: PUSH
11961: LD_INT 1
11963: ST_TO_ADDR
11964: GO 11986
11966: LD_INT 2
11968: DOUBLE
11969: EQUAL
11970: IFTRUE 11974
11972: GO 11985
11974: POP
// wait_for_them := false ; end ;
11975: LD_ADDR_EXP 25
11979: PUSH
11980: LD_INT 0
11982: ST_TO_ADDR
11983: GO 11986
11985: POP
// end ; save_counter := save_counter + 1 ;
11986: LD_ADDR_EXP 36
11990: PUSH
11991: LD_EXP 36
11995: PUSH
11996: LD_INT 1
11998: PLUS
11999: ST_TO_ADDR
// save_group := save_group ^ JMM ;
12000: LD_ADDR_EXP 23
12004: PUSH
12005: LD_EXP 23
12009: PUSH
12010: LD_EXP 37
12014: ADD
12015: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
12016: LD_EXP 37
12020: PPUSH
12021: CALL_OW 64
// end ; if i = Lisa then
12025: LD_VAR 0 1
12029: PUSH
12030: LD_EXP 40
12034: EQUAL
12035: IFFALSE 12076
// begin save_counter := save_counter + 1 ;
12037: LD_ADDR_EXP 36
12041: PUSH
12042: LD_EXP 36
12046: PUSH
12047: LD_INT 1
12049: PLUS
12050: ST_TO_ADDR
// save_group := save_group ^ Lisa ;
12051: LD_ADDR_EXP 23
12055: PUSH
12056: LD_EXP 23
12060: PUSH
12061: LD_EXP 40
12065: ADD
12066: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
12067: LD_EXP 40
12071: PPUSH
12072: CALL_OW 64
// end ; if i = Bobby then
12076: LD_VAR 0 1
12080: PUSH
12081: LD_EXP 38
12085: EQUAL
12086: IFFALSE 12127
// begin save_counter := save_counter + 1 ;
12088: LD_ADDR_EXP 36
12092: PUSH
12093: LD_EXP 36
12097: PUSH
12098: LD_INT 1
12100: PLUS
12101: ST_TO_ADDR
// save_group := save_group ^ Bobby ;
12102: LD_ADDR_EXP 23
12106: PUSH
12107: LD_EXP 23
12111: PUSH
12112: LD_EXP 38
12116: ADD
12117: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
12118: LD_EXP 38
12122: PPUSH
12123: CALL_OW 64
// end ; if i = Cyrus then
12127: LD_VAR 0 1
12131: PUSH
12132: LD_EXP 39
12136: EQUAL
12137: IFFALSE 12178
// begin save_counter := save_counter + 1 ;
12139: LD_ADDR_EXP 36
12143: PUSH
12144: LD_EXP 36
12148: PUSH
12149: LD_INT 1
12151: PLUS
12152: ST_TO_ADDR
// save_group := save_group ^ Cyrus ;
12153: LD_ADDR_EXP 23
12157: PUSH
12158: LD_EXP 23
12162: PUSH
12163: LD_EXP 39
12167: ADD
12168: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
12169: LD_EXP 39
12173: PPUSH
12174: CALL_OW 64
// end ; if i = Khatam then
12178: LD_VAR 0 1
12182: PUSH
12183: LD_EXP 41
12187: EQUAL
12188: IFFALSE 12229
// begin save_counter := save_counter + 1 ;
12190: LD_ADDR_EXP 36
12194: PUSH
12195: LD_EXP 36
12199: PUSH
12200: LD_INT 1
12202: PLUS
12203: ST_TO_ADDR
// save_group := save_group ^ Khatam ;
12204: LD_ADDR_EXP 23
12208: PUSH
12209: LD_EXP 23
12213: PUSH
12214: LD_EXP 41
12218: ADD
12219: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
12220: LD_EXP 41
12224: PPUSH
12225: CALL_OW 64
// end ; if i = Frank then
12229: LD_VAR 0 1
12233: PUSH
12234: LD_EXP 51
12238: EQUAL
12239: IFFALSE 12280
// begin save_counter := save_counter + 1 ;
12241: LD_ADDR_EXP 36
12245: PUSH
12246: LD_EXP 36
12250: PUSH
12251: LD_INT 1
12253: PLUS
12254: ST_TO_ADDR
// save_group := save_group ^ Frank ;
12255: LD_ADDR_EXP 23
12259: PUSH
12260: LD_EXP 23
12264: PUSH
12265: LD_EXP 51
12269: ADD
12270: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
12271: LD_EXP 51
12275: PPUSH
12276: CALL_OW 64
// end ; if i <> JMM and IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
12280: LD_VAR 0 1
12284: PUSH
12285: LD_EXP 37
12289: NONEQUAL
12290: PUSH
12291: LD_VAR 0 1
12295: PPUSH
12296: CALL_OW 302
12300: AND
12301: PUSH
12302: LD_VAR 0 1
12306: PPUSH
12307: CALL_OW 247
12311: PUSH
12312: LD_INT 1
12314: EQUAL
12315: AND
12316: PUSH
12317: LD_VAR 0 1
12321: PUSH
12322: LD_EXP 23
12326: IN
12327: NOT
12328: AND
12329: IFFALSE 12370
// begin save_counter := save_counter + 1 ;
12331: LD_ADDR_EXP 36
12335: PUSH
12336: LD_EXP 36
12340: PUSH
12341: LD_INT 1
12343: PLUS
12344: ST_TO_ADDR
// save_others := save_others ^ i ;
12345: LD_ADDR_EXP 22
12349: PUSH
12350: LD_EXP 22
12354: PUSH
12355: LD_VAR 0 1
12359: ADD
12360: ST_TO_ADDR
// RemoveUnit ( i ) ;
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 64
// end ; end ;
12370: LD_VAR 0 2
12374: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12375: LD_EXP 24
12379: NOT
12380: PUSH
12381: LD_EXP 25
12385: NOT
12386: AND
12387: PUSH
12388: LD_INT 22
12390: PUSH
12391: LD_INT 1
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 21
12400: PUSH
12401: LD_INT 1
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PPUSH
12412: CALL_OW 69
12416: PUSH
12417: LD_INT 0
12419: EQUAL
12420: OR
12421: IFFALSE 12430
12423: GO 12425
12425: DISABLE
// EndMission ;
12426: CALL 12431 0 0
12430: END
// export function EndMission ; var i , m1 , m2 , m3 ; begin
12431: LD_INT 0
12433: PPUSH
12434: PPUSH
12435: PPUSH
12436: PPUSH
12437: PPUSH
// wait ( 0 0$01 ) ;
12438: LD_INT 35
12440: PPUSH
12441: CALL_OW 67
// if tick <= 12 12$00 then
12445: LD_OWVAR 1
12449: PUSH
12450: LD_INT 25200
12452: LESSEQUAL
12453: IFFALSE 12462
// SetAchievement ( ACH_ASPEED_3 ) ;
12455: LD_STRING ACH_ASPEED_3
12457: PPUSH
12458: CALL_OW 543
// if UnitFilter ( save_group ^ save_others , [ f_class , 4 ] ) = 0 then
12462: LD_EXP 23
12466: PUSH
12467: LD_EXP 22
12471: ADD
12472: PPUSH
12473: LD_INT 25
12475: PUSH
12476: LD_INT 4
12478: PUSH
12479: EMPTY
12480: LIST
12481: LIST
12482: PPUSH
12483: CALL_OW 72
12487: PUSH
12488: LD_INT 0
12490: EQUAL
12491: IFFALSE 12507
// begin wait ( 3 ) ;
12493: LD_INT 3
12495: PPUSH
12496: CALL_OW 67
// SetAchievement ( ACH_NOSCI ) ;
12500: LD_STRING ACH_NOSCI
12502: PPUSH
12503: CALL_OW 543
// end ; m1 := solar_builded ;
12507: LD_ADDR_VAR 0 3
12511: PUSH
12512: LD_EXP 14
12516: ST_TO_ADDR
// m2 := veh_on_meta ;
12517: LD_ADDR_VAR 0 4
12521: PUSH
12522: LD_EXP 28
12526: ST_TO_ADDR
// m3 := ( lose_counter = 0 ) ;
12527: LD_ADDR_VAR 0 5
12531: PUSH
12532: LD_EXP 34
12536: PUSH
12537: LD_INT 0
12539: EQUAL
12540: ST_TO_ADDR
// if solar_builded then
12541: LD_EXP 14
12545: IFFALSE 12559
// AddMedal ( Solar1 , 1 ) else
12547: LD_STRING Solar1
12549: PPUSH
12550: LD_INT 1
12552: PPUSH
12553: CALL_OW 101
12557: GO 12570
// AddMedal ( Solar1 , - 1 ) ;
12559: LD_STRING Solar1
12561: PPUSH
12562: LD_INT 1
12564: NEG
12565: PPUSH
12566: CALL_OW 101
// if veh_on_meta then
12570: LD_EXP 28
12574: IFFALSE 12588
// AddMedal ( Solar2 , 1 ) else
12576: LD_STRING Solar2
12578: PPUSH
12579: LD_INT 1
12581: PPUSH
12582: CALL_OW 101
12586: GO 12618
// if solar_builded then
12588: LD_EXP 14
12592: IFFALSE 12607
// AddMedal ( Solar2 , - 1 ) else
12594: LD_STRING Solar2
12596: PPUSH
12597: LD_INT 1
12599: NEG
12600: PPUSH
12601: CALL_OW 101
12605: GO 12618
// AddMedal ( Solar2 , - 2 ) ;
12607: LD_STRING Solar2
12609: PPUSH
12610: LD_INT 2
12612: NEG
12613: PPUSH
12614: CALL_OW 101
// if lose_counter = 0 then
12618: LD_EXP 34
12622: PUSH
12623: LD_INT 0
12625: EQUAL
12626: IFFALSE 12640
// AddMedal ( No , 1 ) else
12628: LD_STRING No
12630: PPUSH
12631: LD_INT 1
12633: PPUSH
12634: CALL_OW 101
12638: GO 12684
// if lose_counter > 0 and lose_counter < 4 then
12640: LD_EXP 34
12644: PUSH
12645: LD_INT 0
12647: GREATER
12648: PUSH
12649: LD_EXP 34
12653: PUSH
12654: LD_INT 4
12656: LESS
12657: AND
12658: IFFALSE 12673
// AddMedal ( No , - 1 ) else
12660: LD_STRING No
12662: PPUSH
12663: LD_INT 1
12665: NEG
12666: PPUSH
12667: CALL_OW 101
12671: GO 12684
// AddMedal ( UpTo4 , - 1 ) ;
12673: LD_STRING UpTo4
12675: PPUSH
12676: LD_INT 1
12678: NEG
12679: PPUSH
12680: CALL_OW 101
// GiveMedals ( MAIN ) ;
12684: LD_STRING MAIN
12686: PPUSH
12687: CALL_OW 102
// if Difficulty = 3 and m1 and m2 and m3 then
12691: LD_OWVAR 67
12695: PUSH
12696: LD_INT 3
12698: EQUAL
12699: PUSH
12700: LD_VAR 0 3
12704: AND
12705: PUSH
12706: LD_VAR 0 4
12710: AND
12711: PUSH
12712: LD_VAR 0 5
12716: AND
12717: IFFALSE 12729
// SetAchievementEX ( ACH_AMER , 3 ) ;
12719: LD_STRING ACH_AMER
12721: PPUSH
12722: LD_INT 3
12724: PPUSH
12725: CALL_OW 564
// if IsDead ( Pokryshkin ) then
12729: LD_EXP 52
12733: PPUSH
12734: CALL_OW 301
12738: IFFALSE 12794
// begin stop_talking := true ;
12740: LD_ADDR_OWVAR 56
12744: PUSH
12745: LD_INT 1
12747: ST_TO_ADDR
// for i in save_group ^ save_others do
12748: LD_ADDR_VAR 0 2
12752: PUSH
12753: LD_EXP 23
12757: PUSH
12758: LD_EXP 22
12762: ADD
12763: PUSH
12764: FOR_IN
12765: IFFALSE 12784
// AddExperience ( i , skill_combat , 1500 ) ;
12767: LD_VAR 0 2
12771: PPUSH
12772: LD_INT 1
12774: PPUSH
12775: LD_INT 1500
12777: PPUSH
12778: CALL_OW 492
12782: GO 12764
12784: POP
12785: POP
// stop_talking := false ;
12786: LD_ADDR_OWVAR 56
12790: PUSH
12791: LD_INT 0
12793: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12794: LD_EXP 23
12798: PUSH
12799: LD_EXP 22
12803: ADD
12804: PPUSH
12805: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12809: LD_EXP 37
12813: PPUSH
12814: LD_EXP 2
12818: PUSH
12819: LD_STRING JMM
12821: STR
12822: PPUSH
12823: CALL_OW 38
// if Bobby in save_group then
12827: LD_EXP 38
12831: PUSH
12832: LD_EXP 23
12836: IN
12837: IFFALSE 12857
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12839: LD_EXP 38
12843: PPUSH
12844: LD_EXP 2
12848: PUSH
12849: LD_STRING Bobby
12851: STR
12852: PPUSH
12853: CALL_OW 38
// if Cyrus in save_group then
12857: LD_EXP 39
12861: PUSH
12862: LD_EXP 23
12866: IN
12867: IFFALSE 12887
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12869: LD_EXP 39
12873: PPUSH
12874: LD_EXP 2
12878: PUSH
12879: LD_STRING Cyrus
12881: STR
12882: PPUSH
12883: CALL_OW 38
// if Lisa in save_group then
12887: LD_EXP 40
12891: PUSH
12892: LD_EXP 23
12896: IN
12897: IFFALSE 12917
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12899: LD_EXP 40
12903: PPUSH
12904: LD_EXP 2
12908: PUSH
12909: LD_STRING Lisa
12911: STR
12912: PPUSH
12913: CALL_OW 38
// if Frank in save_group then
12917: LD_EXP 51
12921: PUSH
12922: LD_EXP 23
12926: IN
12927: IFFALSE 12947
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12929: LD_EXP 51
12933: PPUSH
12934: LD_EXP 2
12938: PUSH
12939: LD_STRING Frank
12941: STR
12942: PPUSH
12943: CALL_OW 38
// if Khatam in save_group then
12947: LD_EXP 41
12951: PUSH
12952: LD_EXP 23
12956: IN
12957: IFFALSE 12977
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12959: LD_EXP 41
12963: PPUSH
12964: LD_EXP 2
12968: PUSH
12969: LD_STRING Khatam
12971: STR
12972: PPUSH
12973: CALL_OW 38
// if save_others then
12977: LD_EXP 22
12981: IFFALSE 12995
// SaveCharacters ( save_others , 03_others ) ;
12983: LD_EXP 22
12987: PPUSH
12988: LD_STRING 03_others
12990: PPUSH
12991: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12995: LD_EXP 45
12999: PUSH
13000: LD_EXP 45
13004: PPUSH
13005: CALL_OW 302
13009: AND
13010: PUSH
13011: LD_EXP 27
13015: AND
13016: IFFALSE 13028
// begin ResetFog ;
13018: CALL_OW 335
// DisplayEndingScene ;
13022: CALL 13050 0 0
// end else
13026: GO 13041
// DeleteCharacters ( mission_prefix & Cornel ) ;
13028: LD_EXP 2
13032: PUSH
13033: LD_STRING Cornel
13035: STR
13036: PPUSH
13037: CALL_OW 40
// YouWin ;
13041: CALL_OW 103
// end ;
13045: LD_VAR 0 1
13049: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
13050: LD_INT 0
13052: PPUSH
13053: PPUSH
13054: PPUSH
13055: PPUSH
13056: PPUSH
13057: PPUSH
// InGameOn ;
13058: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13062: LD_INT 208
13064: PPUSH
13065: LD_INT 62
13067: PPUSH
13068: LD_INT 1
13070: PPUSH
13071: LD_INT 10
13073: NEG
13074: PPUSH
13075: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
13079: LD_INT 208
13081: PPUSH
13082: LD_INT 62
13084: PPUSH
13085: LD_INT 1
13087: PPUSH
13088: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
13092: LD_ADDR_VAR 0 3
13096: PUSH
13097: LD_INT 22
13099: PUSH
13100: LD_INT 3
13102: PUSH
13103: EMPTY
13104: LIST
13105: LIST
13106: PUSH
13107: LD_INT 2
13109: PUSH
13110: LD_INT 21
13112: PUSH
13113: LD_INT 2
13115: PUSH
13116: EMPTY
13117: LIST
13118: LIST
13119: PUSH
13120: LD_INT 21
13122: PUSH
13123: LD_INT 1
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if filter then
13144: LD_VAR 0 3
13148: IFFALSE 13176
// for i in filter do
13150: LD_ADDR_VAR 0 2
13154: PUSH
13155: LD_VAR 0 3
13159: PUSH
13160: FOR_IN
13161: IFFALSE 13174
// RemoveUnit ( i ) ;
13163: LD_VAR 0 2
13167: PPUSH
13168: CALL_OW 64
13172: GO 13160
13174: POP
13175: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
13176: LD_ADDR_VAR 0 3
13180: PUSH
13181: LD_INT 22
13183: PUSH
13184: LD_INT 4
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: PUSH
13191: LD_INT 21
13193: PUSH
13194: LD_INT 1
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: PUSH
13201: EMPTY
13202: LIST
13203: LIST
13204: PPUSH
13205: CALL_OW 69
13209: ST_TO_ADDR
// if filter then
13210: LD_VAR 0 3
13214: IFFALSE 13245
// for i in filter do
13216: LD_ADDR_VAR 0 2
13220: PUSH
13221: LD_VAR 0 3
13225: PUSH
13226: FOR_IN
13227: IFFALSE 13243
// SetLives ( i , 0 ) ;
13229: LD_VAR 0 2
13233: PPUSH
13234: LD_INT 0
13236: PPUSH
13237: CALL_OW 234
13241: GO 13226
13243: POP
13244: POP
// uc_side := 4 ;
13245: LD_ADDR_OWVAR 20
13249: PUSH
13250: LD_INT 4
13252: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
13253: LD_ADDR_VAR 0 4
13257: PUSH
13258: LD_STRING Cornell
13260: PPUSH
13261: LD_INT 0
13263: PPUSH
13264: CALL 489 0 2
13268: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
13269: LD_VAR 0 4
13273: PPUSH
13274: LD_INT 208
13276: PPUSH
13277: LD_INT 62
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
13287: LD_VAR 0 4
13291: PPUSH
13292: LD_INT 100
13294: PPUSH
13295: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
13299: LD_INT 3
13301: PPUSH
13302: LD_VAR 0 4
13306: PPUSH
13307: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
13311: LD_INT 4
13313: PPUSH
13314: LD_INT 3
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: LD_INT 1
13322: PPUSH
13323: CALL_OW 80
// uc_side := 3 ;
13327: LD_ADDR_OWVAR 20
13331: PUSH
13332: LD_INT 3
13334: ST_TO_ADDR
// uc_nation := 3 ;
13335: LD_ADDR_OWVAR 21
13339: PUSH
13340: LD_INT 3
13342: ST_TO_ADDR
// InitHc ;
13343: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
13347: LD_ADDR_VAR 0 5
13351: PUSH
13352: LD_STRING Mikhail
13354: PPUSH
13355: LD_INT 0
13357: PPUSH
13358: CALL 489 0 2
13362: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
13363: LD_INT 1
13365: PPUSH
13366: LD_INT 1
13368: PPUSH
13369: LD_INT 0
13371: PPUSH
13372: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13376: LD_ADDR_VAR 0 6
13380: PUSH
13381: LD_VAR 0 6
13385: PUSH
13386: CALL_OW 44
13390: ADD
13391: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
13392: LD_ADDR_VAR 0 6
13396: PUSH
13397: LD_VAR 0 6
13401: PUSH
13402: CALL_OW 44
13406: ADD
13407: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
13408: LD_INT 2
13410: PPUSH
13411: LD_INT 4
13413: PPUSH
13414: LD_INT 0
13416: PPUSH
13417: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13421: LD_ADDR_VAR 0 6
13425: PUSH
13426: LD_VAR 0 6
13430: PUSH
13431: CALL_OW 44
13435: ADD
13436: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
13437: LD_VAR 0 5
13441: PPUSH
13442: LD_INT 17
13444: PPUSH
13445: LD_INT 0
13447: PPUSH
13448: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
13452: LD_VAR 0 5
13456: PPUSH
13457: LD_INT 210
13459: PPUSH
13460: LD_INT 63
13462: PPUSH
13463: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
13467: LD_VAR 0 5
13471: PPUSH
13472: LD_INT 208
13474: PPUSH
13475: LD_INT 62
13477: PPUSH
13478: CALL_OW 178
// for i in fake_russians do
13482: LD_ADDR_VAR 0 2
13486: PUSH
13487: LD_VAR 0 6
13491: PUSH
13492: FOR_IN
13493: IFFALSE 13571
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13495: LD_VAR 0 2
13499: PPUSH
13500: LD_INT 17
13502: PPUSH
13503: LD_INT 0
13505: PPUSH
13506: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13510: LD_VAR 0 2
13514: PPUSH
13515: LD_INT 215
13517: PPUSH
13518: LD_INT 67
13520: PPUSH
13521: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13525: LD_VAR 0 2
13529: PPUSH
13530: LD_INT 208
13532: PPUSH
13533: LD_INT 62
13535: PPUSH
13536: CALL_OW 178
// if GetClass ( i ) = 4 then
13540: LD_VAR 0 2
13544: PPUSH
13545: CALL_OW 257
13549: PUSH
13550: LD_INT 4
13552: EQUAL
13553: IFFALSE 13569
// ComHeal ( i , fake_cornel ) ;
13555: LD_VAR 0 2
13559: PPUSH
13560: LD_VAR 0 4
13564: PPUSH
13565: CALL_OW 128
// end ;
13569: GO 13492
13571: POP
13572: POP
// Wait ( 0 0$01 ) ;
13573: LD_INT 35
13575: PPUSH
13576: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13580: LD_INT 208
13582: PPUSH
13583: LD_INT 62
13585: PPUSH
13586: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13590: LD_INT 208
13592: PPUSH
13593: LD_INT 62
13595: PPUSH
13596: LD_INT 1
13598: PPUSH
13599: LD_INT 10
13601: NEG
13602: PPUSH
13603: CALL_OW 330
// Wait ( 0 0$15 ) ;
13607: LD_INT 525
13609: PPUSH
13610: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13614: LD_INT 208
13616: PPUSH
13617: LD_INT 62
13619: PPUSH
13620: LD_INT 1
13622: PPUSH
13623: CALL_OW 331
// ResetFog ;
13627: CALL_OW 335
// InGameOff ;
13631: CALL_OW 9
// end ;
13635: LD_VAR 0 1
13639: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13640: LD_INT 10
13642: PPUSH
13643: LD_INT 22
13645: PUSH
13646: LD_INT 1
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: PPUSH
13653: CALL_OW 70
13657: PUSH
13658: LD_EXP 44
13662: PPUSH
13663: CALL_OW 302
13667: AND
13668: PUSH
13669: LD_INT 22
13671: PUSH
13672: LD_INT 1
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: PPUSH
13679: CALL_OW 69
13683: PPUSH
13684: LD_EXP 44
13688: PPUSH
13689: CALL_OW 74
13693: PPUSH
13694: LD_EXP 44
13698: PPUSH
13699: CALL_OW 296
13703: PUSH
13704: LD_INT 30
13706: LESS
13707: OR
13708: IFFALSE 13759
13710: GO 13712
13712: DISABLE
// begin enable ;
13713: ENABLE
// powell_warn := powell_warn + 1 ;
13714: LD_ADDR_EXP 35
13718: PUSH
13719: LD_EXP 35
13723: PUSH
13724: LD_INT 1
13726: PLUS
13727: ST_TO_ADDR
// if powell_warn = 3 then
13728: LD_EXP 35
13732: PUSH
13733: LD_INT 3
13735: EQUAL
13736: IFFALSE 13747
// begin YouLost ( 5 ) ;
13738: LD_STRING 5
13740: PPUSH
13741: CALL_OW 104
// exit ;
13745: GO 13759
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13747: LD_EXP 46
13751: PPUSH
13752: LD_STRING DWarn-Pow-1
13754: PPUSH
13755: CALL_OW 94
// end ; end_of_file
13759: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13760: LD_EXP 8
13764: IFFALSE 15601
13766: GO 13768
13768: DISABLE
13769: LD_INT 0
13771: PPUSH
13772: PPUSH
13773: PPUSH
13774: PPUSH
13775: PPUSH
13776: PPUSH
13777: PPUSH
13778: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13779: LD_EXP 44
13783: PUSH
13784: LD_EXP 45
13788: ADD
13789: PUSH
13790: LD_EXP 6
13794: ADD
13795: PPUSH
13796: LD_INT 250
13798: PPUSH
13799: LD_INT 120
13801: PPUSH
13802: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13806: LD_ADDR_VAR 0 2
13810: PUSH
13811: LD_EXP 6
13815: PPUSH
13816: LD_INT 25
13818: PUSH
13819: LD_INT 2
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PPUSH
13826: CALL_OW 72
13830: PUSH
13831: LD_EXP 45
13835: DIFF
13836: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13837: LD_ADDR_VAR 0 3
13841: PUSH
13842: LD_EXP 6
13846: PPUSH
13847: LD_INT 21
13849: PUSH
13850: LD_INT 1
13852: PUSH
13853: EMPTY
13854: LIST
13855: LIST
13856: PPUSH
13857: CALL_OW 72
13861: PUSH
13862: LD_VAR 0 2
13866: DIFF
13867: ST_TO_ADDR
// if not has_eng then
13868: LD_VAR 0 2
13872: NOT
13873: IFFALSE 13956
// begin uc_side := 4 ;
13875: LD_ADDR_OWVAR 20
13879: PUSH
13880: LD_INT 4
13882: ST_TO_ADDR
// uc_nation := 1 ;
13883: LD_ADDR_OWVAR 21
13887: PUSH
13888: LD_INT 1
13890: ST_TO_ADDR
// bc_type := b_depot ;
13891: LD_ADDR_OWVAR 42
13895: PUSH
13896: LD_INT 0
13898: ST_TO_ADDR
// bc_level := 2 ;
13899: LD_ADDR_OWVAR 43
13903: PUSH
13904: LD_INT 2
13906: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13907: LD_ADDR_VAR 0 4
13911: PUSH
13912: LD_INT 264
13914: PPUSH
13915: LD_INT 120
13917: PPUSH
13918: LD_INT 4
13920: PPUSH
13921: CALL_OW 47
13925: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13926: LD_INT 264
13928: PPUSH
13929: LD_INT 120
13931: PPUSH
13932: LD_INT 4
13934: PPUSH
13935: LD_INT 10
13937: NEG
13938: PPUSH
13939: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13943: LD_INT 264
13945: PPUSH
13946: LD_INT 120
13948: PPUSH
13949: LD_INT 4
13951: PPUSH
13952: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13956: LD_INT 35
13958: PPUSH
13959: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13963: LD_EXP 44
13967: PPUSH
13968: LD_INT 10
13970: PPUSH
13971: CALL_OW 308
13975: PUSH
13976: LD_EXP 44
13980: PPUSH
13981: CALL_OW 310
13985: PPUSH
13986: LD_INT 10
13988: PPUSH
13989: CALL_OW 308
13993: OR
13994: IFFALSE 13956
// if has_eng and not dep then
13996: LD_VAR 0 2
14000: PUSH
14001: LD_VAR 0 4
14005: NOT
14006: AND
14007: IFFALSE 14157
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
14009: LD_VAR 0 2
14013: PPUSH
14014: LD_INT 0
14016: PPUSH
14017: LD_INT 264
14019: PPUSH
14020: LD_INT 120
14022: PPUSH
14023: LD_INT 4
14025: PPUSH
14026: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
14030: LD_INT 35
14032: PPUSH
14033: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
14037: LD_INT 22
14039: PUSH
14040: LD_INT 4
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PUSH
14047: LD_INT 30
14049: PUSH
14050: LD_INT 0
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: PPUSH
14061: CALL_OW 69
14065: IFFALSE 14030
// ComMoveXY ( filter , 264 , 120 ) ;
14067: LD_VAR 0 3
14071: PPUSH
14072: LD_INT 264
14074: PPUSH
14075: LD_INT 120
14077: PPUSH
14078: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
14082: LD_INT 35
14084: PPUSH
14085: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
14089: LD_INT 22
14091: PUSH
14092: LD_INT 4
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 30
14101: PUSH
14102: LD_INT 0
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: PUSH
14109: LD_INT 3
14111: PUSH
14112: LD_INT 57
14114: PUSH
14115: EMPTY
14116: LIST
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: LIST
14126: PPUSH
14127: CALL_OW 69
14131: IFFALSE 14082
// ComMoveXY ( filter , 247 , 113 ) ;
14133: LD_VAR 0 3
14137: PPUSH
14138: LD_INT 247
14140: PPUSH
14141: LD_INT 113
14143: PPUSH
14144: CALL_OW 111
// Wait ( 0 0$2 ) ;
14148: LD_INT 70
14150: PPUSH
14151: CALL_OW 67
// end else
14155: GO 14169
// begin SetSide ( dep , 4 ) ;
14157: LD_VAR 0 4
14161: PPUSH
14162: LD_INT 4
14164: PPUSH
14165: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
14169: LD_ADDR_VAR 0 4
14173: PUSH
14174: LD_INT 22
14176: PUSH
14177: LD_INT 4
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: PUSH
14184: LD_INT 30
14186: PUSH
14187: LD_INT 0
14189: PUSH
14190: EMPTY
14191: LIST
14192: LIST
14193: PUSH
14194: EMPTY
14195: LIST
14196: LIST
14197: PPUSH
14198: CALL_OW 69
14202: PUSH
14203: LD_INT 1
14205: ARRAY
14206: ST_TO_ADDR
// if not has_eng then
14207: LD_VAR 0 2
14211: NOT
14212: IFFALSE 14299
// for i = 1 to 2 do
14214: LD_ADDR_VAR 0 1
14218: PUSH
14219: DOUBLE
14220: LD_INT 1
14222: DEC
14223: ST_TO_ADDR
14224: LD_INT 2
14226: PUSH
14227: FOR_TO
14228: IFFALSE 14297
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
14230: LD_VAR 0 3
14234: PUSH
14235: LD_INT 1
14237: ARRAY
14238: PPUSH
14239: LD_VAR 0 4
14243: PPUSH
14244: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
14248: LD_VAR 0 3
14252: PUSH
14253: LD_INT 1
14255: ARRAY
14256: PPUSH
14257: LD_INT 2
14259: PPUSH
14260: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
14264: LD_VAR 0 3
14268: PUSH
14269: LD_INT 1
14271: ARRAY
14272: PPUSH
14273: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_VAR 0 3
14286: PPUSH
14287: LD_INT 1
14289: PPUSH
14290: CALL_OW 3
14294: ST_TO_ADDR
// end ;
14295: GO 14227
14297: POP
14298: POP
// if IsInUnit ( Cornel ) then
14299: LD_EXP 44
14303: PPUSH
14304: CALL_OW 310
14308: IFFALSE 14386
// begin cargo := IsInUnit ( Cornel ) ;
14310: LD_ADDR_VAR 0 7
14314: PUSH
14315: LD_EXP 44
14319: PPUSH
14320: CALL_OW 310
14324: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
14325: LD_VAR 0 7
14329: PPUSH
14330: LD_INT 1
14332: PPUSH
14333: CALL_OW 289
14337: IFFALSE 14348
// ComUnload ( cargo ) ;
14339: LD_VAR 0 7
14343: PPUSH
14344: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
14348: LD_EXP 44
14352: PPUSH
14353: LD_INT 235
14355: PPUSH
14356: LD_INT 122
14358: PPUSH
14359: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
14363: LD_EXP 44
14367: PPUSH
14368: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
14372: LD_EXP 44
14376: PPUSH
14377: LD_VAR 0 4
14381: PPUSH
14382: CALL_OW 180
// end ; if Bierezov then
14386: LD_EXP 45
14390: IFFALSE 14438
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
14392: LD_EXP 45
14396: PPUSH
14397: LD_INT 260
14399: PPUSH
14400: LD_INT 120
14402: PPUSH
14403: CALL_OW 111
// if dep then
14407: LD_VAR 0 4
14411: IFFALSE 14429
// AddComEnterUnit ( Bierezov , dep ) else
14413: LD_EXP 45
14417: PPUSH
14418: LD_VAR 0 4
14422: PPUSH
14423: CALL_OW 180
14427: GO 14438
// AddComHold ( Bierezov ) ;
14429: LD_EXP 45
14433: PPUSH
14434: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
14438: LD_INT 525
14440: PPUSH
14441: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 4
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 2
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_EXP 45
14483: DIFF
14484: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14485: LD_INT 35
14487: PPUSH
14488: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14492: LD_ADDR_VAR 0 6
14496: PUSH
14497: LD_INT 10
14499: PPUSH
14500: CALL_OW 435
14504: ST_TO_ADDR
// if crates then
14505: LD_VAR 0 6
14509: IFFALSE 14538
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14511: LD_VAR 0 2
14515: PPUSH
14516: LD_VAR 0 6
14520: PUSH
14521: LD_INT 1
14523: ARRAY
14524: PPUSH
14525: LD_VAR 0 6
14529: PUSH
14530: LD_INT 2
14532: ARRAY
14533: PPUSH
14534: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14538: LD_VAR 0 4
14542: PPUSH
14543: CALL_OW 274
14547: PPUSH
14548: LD_INT 1
14550: PPUSH
14551: CALL_OW 275
14555: PUSH
14556: LD_INT 40
14558: GREATEREQUAL
14559: IFFALSE 14485
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14561: LD_ADDR_VAR 0 5
14565: PUSH
14566: LD_INT 4
14568: PUSH
14569: LD_INT 256
14571: PUSH
14572: LD_INT 111
14574: PUSH
14575: LD_INT 2
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: PUSH
14584: LD_INT 31
14586: PUSH
14587: LD_INT 243
14589: PUSH
14590: LD_INT 112
14592: PUSH
14593: LD_INT 2
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: PUSH
14602: LD_INT 31
14604: PUSH
14605: LD_INT 254
14607: PUSH
14608: LD_INT 114
14610: PUSH
14611: LD_INT 2
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: LIST
14624: ST_TO_ADDR
// for i in blist do
14625: LD_ADDR_VAR 0 1
14629: PUSH
14630: LD_VAR 0 5
14634: PUSH
14635: FOR_IN
14636: IFFALSE 14685
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14638: LD_VAR 0 2
14642: PPUSH
14643: LD_VAR 0 1
14647: PUSH
14648: LD_INT 1
14650: ARRAY
14651: PPUSH
14652: LD_VAR 0 1
14656: PUSH
14657: LD_INT 2
14659: ARRAY
14660: PPUSH
14661: LD_VAR 0 1
14665: PUSH
14666: LD_INT 3
14668: ARRAY
14669: PPUSH
14670: LD_VAR 0 1
14674: PUSH
14675: LD_INT 4
14677: ARRAY
14678: PPUSH
14679: CALL_OW 205
14683: GO 14635
14685: POP
14686: POP
// repeat wait ( 0 0$01 ) ;
14687: LD_INT 35
14689: PPUSH
14690: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14694: LD_INT 22
14696: PUSH
14697: LD_INT 4
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: PUSH
14704: LD_INT 30
14706: PUSH
14707: LD_INT 4
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 3
14716: PUSH
14717: LD_INT 57
14719: PUSH
14720: EMPTY
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: LIST
14731: PPUSH
14732: CALL_OW 69
14736: IFFALSE 14687
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14738: LD_VAR 0 3
14742: PPUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 4
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PUSH
14753: LD_INT 30
14755: PUSH
14756: LD_INT 4
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PUSH
14763: EMPTY
14764: LIST
14765: LIST
14766: PPUSH
14767: CALL_OW 69
14771: PUSH
14772: LD_INT 1
14774: ARRAY
14775: PPUSH
14776: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14780: LD_VAR 0 3
14784: PPUSH
14785: LD_INT 1
14787: PPUSH
14788: CALL_OW 183
// if has_eng > 1 then
14792: LD_VAR 0 2
14796: PUSH
14797: LD_INT 1
14799: GREATER
14800: IFFALSE 14942
// for i = has_eng downto 2 do
14802: LD_ADDR_VAR 0 1
14806: PUSH
14807: DOUBLE
14808: LD_VAR 0 2
14812: INC
14813: ST_TO_ADDR
14814: LD_INT 2
14816: PUSH
14817: FOR_DOWNTO
14818: IFFALSE 14940
// begin if IsInUnit ( has_eng [ i ] ) then
14820: LD_VAR 0 2
14824: PUSH
14825: LD_VAR 0 1
14829: ARRAY
14830: PPUSH
14831: CALL_OW 310
14835: IFFALSE 14852
// ComExitBuilding ( has_eng [ i ] ) ;
14837: LD_VAR 0 2
14841: PUSH
14842: LD_VAR 0 1
14846: ARRAY
14847: PPUSH
14848: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14852: LD_VAR 0 2
14856: PUSH
14857: LD_VAR 0 1
14861: ARRAY
14862: PPUSH
14863: LD_INT 22
14865: PUSH
14866: LD_INT 4
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PUSH
14873: LD_INT 30
14875: PUSH
14876: LD_INT 4
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PPUSH
14887: CALL_OW 69
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: PPUSH
14896: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14900: LD_VAR 0 2
14904: PUSH
14905: LD_VAR 0 1
14909: ARRAY
14910: PPUSH
14911: LD_INT 1
14913: PPUSH
14914: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14918: LD_ADDR_VAR 0 2
14922: PUSH
14923: LD_VAR 0 2
14927: PPUSH
14928: LD_VAR 0 1
14932: PPUSH
14933: CALL_OW 3
14937: ST_TO_ADDR
// end ;
14938: GO 14817
14940: POP
14941: POP
// repeat wait ( 0 0$01 ) ;
14942: LD_INT 35
14944: PPUSH
14945: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14949: LD_INT 22
14951: PUSH
14952: LD_INT 4
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PUSH
14959: LD_INT 30
14961: PUSH
14962: LD_INT 31
14964: PUSH
14965: EMPTY
14966: LIST
14967: LIST
14968: PUSH
14969: LD_INT 3
14971: PUSH
14972: LD_INT 57
14974: PUSH
14975: EMPTY
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: PUSH
14982: EMPTY
14983: LIST
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 1
14994: GREATER
14995: IFFALSE 14942
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14997: LD_ADDR_VAR 0 8
15001: PUSH
15002: LD_EXP 6
15006: PPUSH
15007: LD_INT 25
15009: PUSH
15010: LD_INT 1
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PPUSH
15017: CALL_OW 72
15021: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
15022: LD_ADDR_VAR 0 1
15026: PUSH
15027: DOUBLE
15028: LD_INT 1
15030: DEC
15031: ST_TO_ADDR
15032: LD_INT 22
15034: PUSH
15035: LD_INT 4
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 30
15044: PUSH
15045: LD_INT 31
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PUSH
15052: LD_INT 3
15054: PUSH
15055: LD_INT 57
15057: PUSH
15058: EMPTY
15059: LIST
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PPUSH
15070: CALL_OW 69
15074: PUSH
15075: FOR_TO
15076: IFFALSE 15160
// begin if not sol [ i ] then
15078: LD_VAR 0 8
15082: PUSH
15083: LD_VAR 0 1
15087: ARRAY
15088: NOT
15089: IFFALSE 15093
// break ;
15091: GO 15160
// ComExitBuilding ( sol [ i ] ) ;
15093: LD_VAR 0 8
15097: PUSH
15098: LD_VAR 0 1
15102: ARRAY
15103: PPUSH
15104: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
15108: LD_VAR 0 8
15112: PUSH
15113: LD_VAR 0 1
15117: ARRAY
15118: PPUSH
15119: LD_INT 22
15121: PUSH
15122: LD_INT 4
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: LD_INT 30
15131: PUSH
15132: LD_INT 31
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: EMPTY
15140: LIST
15141: LIST
15142: PPUSH
15143: CALL_OW 69
15147: PUSH
15148: LD_VAR 0 1
15152: ARRAY
15153: PPUSH
15154: CALL_OW 180
// end ;
15158: GO 15075
15160: POP
15161: POP
// if sol > 3 then
15162: LD_VAR 0 8
15166: PUSH
15167: LD_INT 3
15169: GREATER
15170: IFFALSE 15287
// begin ComExitBuilding ( sol [ 3 ] ) ;
15172: LD_VAR 0 8
15176: PUSH
15177: LD_INT 3
15179: ARRAY
15180: PPUSH
15181: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
15185: LD_VAR 0 8
15189: PUSH
15190: LD_INT 3
15192: ARRAY
15193: PPUSH
15194: LD_INT 246
15196: PPUSH
15197: LD_INT 94
15199: PPUSH
15200: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
15204: LD_VAR 0 8
15208: PUSH
15209: LD_INT 3
15211: ARRAY
15212: PPUSH
15213: LD_INT 175
15215: PPUSH
15216: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
15220: LD_VAR 0 8
15224: PUSH
15225: LD_INT 3
15227: ARRAY
15228: PPUSH
15229: LD_INT 224
15231: PPUSH
15232: LD_INT 90
15234: PPUSH
15235: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
15239: LD_VAR 0 8
15243: PUSH
15244: LD_INT 3
15246: ARRAY
15247: PPUSH
15248: LD_INT 245
15250: PPUSH
15251: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
15255: LD_VAR 0 8
15259: PUSH
15260: LD_INT 3
15262: ARRAY
15263: PPUSH
15264: LD_INT 223
15266: PPUSH
15267: LD_INT 110
15269: PPUSH
15270: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
15274: LD_VAR 0 8
15278: PUSH
15279: LD_INT 3
15281: ARRAY
15282: PPUSH
15283: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
15287: LD_VAR 0 2
15291: PPUSH
15292: LD_VAR 0 4
15296: PPUSH
15297: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
15301: LD_INT 22
15303: PUSH
15304: LD_INT 4
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 30
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PPUSH
15325: CALL_OW 69
15329: PUSH
15330: LD_INT 1
15332: ARRAY
15333: PPUSH
15334: CALL_OW 313
15338: PUSH
15339: LD_INT 6
15341: LESS
15342: IFFALSE 15406
// begin if IsInUnit ( Cornel ) then
15344: LD_EXP 44
15348: PPUSH
15349: CALL_OW 310
15353: IFFALSE 15364
// ComExitBuilding ( Cornel ) ;
15355: LD_EXP 44
15359: PPUSH
15360: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
15364: LD_EXP 44
15368: PPUSH
15369: LD_INT 22
15371: PUSH
15372: LD_INT 4
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: PUSH
15379: LD_INT 30
15381: PUSH
15382: LD_INT 4
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PPUSH
15393: CALL_OW 69
15397: PUSH
15398: LD_INT 1
15400: ARRAY
15401: PPUSH
15402: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
15406: LD_INT 35
15408: PPUSH
15409: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
15413: LD_ADDR_VAR 0 3
15417: PUSH
15418: LD_INT 22
15420: PUSH
15421: LD_INT 4
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 21
15430: PUSH
15431: LD_INT 3
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: LD_INT 3
15440: PUSH
15441: LD_INT 24
15443: PUSH
15444: LD_INT 1000
15446: PUSH
15447: EMPTY
15448: LIST
15449: LIST
15450: PUSH
15451: EMPTY
15452: LIST
15453: LIST
15454: PUSH
15455: EMPTY
15456: LIST
15457: LIST
15458: LIST
15459: PPUSH
15460: CALL_OW 69
15464: ST_TO_ADDR
// if filter and has_eng then
15465: LD_VAR 0 3
15469: PUSH
15470: LD_VAR 0 2
15474: AND
15475: IFFALSE 15541
// begin for i in has_eng do
15477: LD_ADDR_VAR 0 1
15481: PUSH
15482: LD_VAR 0 2
15486: PUSH
15487: FOR_IN
15488: IFFALSE 15537
// begin if IsInUnit ( i ) then
15490: LD_VAR 0 1
15494: PPUSH
15495: CALL_OW 310
15499: IFFALSE 15510
// ComExitBuilding ( i ) ;
15501: LD_VAR 0 1
15505: PPUSH
15506: CALL_OW 122
// Wait ( 3 ) ;
15510: LD_INT 3
15512: PPUSH
15513: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15517: LD_VAR 0 1
15521: PPUSH
15522: LD_VAR 0 3
15526: PUSH
15527: LD_INT 1
15529: ARRAY
15530: PPUSH
15531: CALL_OW 130
// end ;
15535: GO 15487
15537: POP
15538: POP
// end else
15539: GO 15595
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15541: LD_VAR 0 2
15545: PUSH
15546: LD_VAR 0 2
15550: PPUSH
15551: LD_INT 56
15553: PUSH
15554: EMPTY
15555: LIST
15556: PPUSH
15557: CALL_OW 72
15561: AND
15562: IFFALSE 15595
// for i in has_eng do
15564: LD_ADDR_VAR 0 1
15568: PUSH
15569: LD_VAR 0 2
15573: PUSH
15574: FOR_IN
15575: IFFALSE 15593
// ComEnterUnit ( i , dep ) ;
15577: LD_VAR 0 1
15581: PPUSH
15582: LD_VAR 0 4
15586: PPUSH
15587: CALL_OW 120
15591: GO 15574
15593: POP
15594: POP
// until cornel_prepared ;
15595: LD_EXP 11
15599: IFFALSE 15406
// end ;
15601: PPOPN 8
15603: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15604: LD_EXP 11
15608: IFFALSE 16007
15610: GO 15612
15612: DISABLE
15613: LD_INT 0
15615: PPUSH
15616: PPUSH
15617: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15618: LD_ADDR_VAR 0 2
15622: PUSH
15623: LD_INT 22
15625: PUSH
15626: LD_INT 4
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 30
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: PPUSH
15647: CALL_OW 69
15651: PUSH
15652: LD_INT 1
15654: ARRAY
15655: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15656: LD_EXP 6
15660: PPUSH
15661: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15665: LD_EXP 45
15669: PUSH
15670: LD_EXP 45
15674: PPUSH
15675: CALL_OW 310
15679: AND
15680: IFFALSE 15691
// ComExitBuilding ( Bierezov ) ;
15682: LD_EXP 45
15686: PPUSH
15687: CALL_OW 122
// Wait ( 0 0$03 ) ;
15691: LD_INT 105
15693: PPUSH
15694: CALL_OW 67
// for i in cornel_units do
15698: LD_ADDR_VAR 0 1
15702: PUSH
15703: LD_EXP 6
15707: PUSH
15708: FOR_IN
15709: IFFALSE 15785
// begin if GetClass ( i ) in [ 2 , 3 ] then
15711: LD_VAR 0 1
15715: PPUSH
15716: CALL_OW 257
15720: PUSH
15721: LD_INT 2
15723: PUSH
15724: LD_INT 3
15726: PUSH
15727: EMPTY
15728: LIST
15729: LIST
15730: IN
15731: IFFALSE 15768
// begin ComEnterUnit ( i , arm ) ;
15733: LD_VAR 0 1
15737: PPUSH
15738: LD_VAR 0 2
15742: PPUSH
15743: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15747: LD_VAR 0 1
15751: PPUSH
15752: LD_INT 1
15754: PPUSH
15755: CALL_OW 183
// AddComExitBuilding ( i ) ;
15759: LD_VAR 0 1
15763: PPUSH
15764: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15768: LD_VAR 0 1
15772: PPUSH
15773: LD_INT 257
15775: PPUSH
15776: LD_INT 121
15778: PPUSH
15779: CALL_OW 171
// end ;
15783: GO 15708
15785: POP
15786: POP
// Wait ( 1 1$00 ) ;
15787: LD_INT 2100
15789: PPUSH
15790: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15794: LD_ADDR_VAR 0 3
15798: PUSH
15799: LD_EXP 44
15803: PUSH
15804: LD_EXP 45
15808: ADD
15809: PUSH
15810: LD_EXP 6
15814: ADD
15815: PUSH
15816: LD_EXP 6
15820: PPUSH
15821: LD_INT 21
15823: PUSH
15824: LD_INT 2
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: PPUSH
15831: CALL_OW 72
15835: DIFF
15836: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15837: LD_VAR 0 3
15841: PPUSH
15842: LD_INT 248
15844: PPUSH
15845: LD_INT 85
15847: PPUSH
15848: CALL_OW 111
// AddComHold ( filter ) ;
15852: LD_VAR 0 3
15856: PPUSH
15857: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15861: LD_INT 35
15863: PPUSH
15864: CALL_OW 67
// until cornel_attack ;
15868: LD_EXP 9
15872: IFFALSE 15861
// ComAgressiveMove ( filter , 209 , 63 ) ;
15874: LD_VAR 0 3
15878: PPUSH
15879: LD_INT 209
15881: PPUSH
15882: LD_INT 63
15884: PPUSH
15885: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15889: LD_EXP 44
15893: PPUSH
15894: LD_INT 208
15896: PPUSH
15897: LD_INT 62
15899: PPUSH
15900: CALL_OW 114
// AddComHold ( Cornel ) ;
15904: LD_EXP 44
15908: PPUSH
15909: CALL_OW 200
// if Bierezov then
15913: LD_EXP 45
15917: IFFALSE 16007
// begin filter := filter diff Bierezov ;
15919: LD_ADDR_VAR 0 3
15923: PUSH
15924: LD_VAR 0 3
15928: PUSH
15929: LD_EXP 45
15933: DIFF
15934: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15935: LD_EXP 45
15939: PPUSH
15940: LD_INT 6
15942: PPUSH
15943: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15947: LD_EXP 45
15951: PPUSH
15952: LD_INT 235
15954: PPUSH
15955: LD_INT 60
15957: PPUSH
15958: CALL_OW 111
// AddComHold ( Bierezov ) ;
15962: LD_EXP 45
15966: PPUSH
15967: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15971: LD_EXP 45
15975: PPUSH
15976: LD_INT 350
15978: PPUSH
15979: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15983: LD_EXP 45
15987: PPUSH
15988: LD_INT 198
15990: PPUSH
15991: LD_INT 28
15993: PPUSH
15994: CALL_OW 171
// AddComHold ( Bierezov ) ;
15998: LD_EXP 45
16002: PPUSH
16003: CALL_OW 200
// end ; end ; end_of_file
16007: PPOPN 3
16009: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
16010: LD_EXP 53
16014: PUSH
16015: LD_EXP 31
16019: NOT
16020: AND
16021: PUSH
16022: LD_EXP 32
16026: NOT
16027: AND
16028: IFFALSE 16478
16030: GO 16032
16032: DISABLE
16033: LD_INT 0
16035: PPUSH
16036: PPUSH
16037: PPUSH
16038: PPUSH
// begin enable ;
16039: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16040: LD_ADDR_VAR 0 4
16044: PUSH
16045: LD_INT 81
16047: PUSH
16048: LD_INT 3
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: PPUSH
16055: CALL_OW 69
16059: ST_TO_ADDR
// for i = 1 to ru_patrol do
16060: LD_ADDR_VAR 0 2
16064: PUSH
16065: DOUBLE
16066: LD_INT 1
16068: DEC
16069: ST_TO_ADDR
16070: LD_EXP 53
16074: PUSH
16075: FOR_TO
16076: IFFALSE 16476
// begin un := ru_patrol [ i ] ;
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_EXP 53
16087: PUSH
16088: LD_VAR 0 2
16092: ARRAY
16093: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16094: LD_VAR 0 1
16098: PPUSH
16099: LD_INT 13
16101: PPUSH
16102: CALL_OW 308
16106: IFFALSE 16211
// begin if not ru_alert then
16108: LD_EXP 60
16112: NOT
16113: IFFALSE 16123
// ru_alert := true ;
16115: LD_ADDR_EXP 60
16119: PUSH
16120: LD_INT 1
16122: ST_TO_ADDR
// if not See ( 1 , un ) then
16123: LD_INT 1
16125: PPUSH
16126: LD_VAR 0 1
16130: PPUSH
16131: CALL_OW 292
16135: NOT
16136: IFFALSE 16150
// SetLives ( un , 1000 ) ;
16138: LD_VAR 0 1
16142: PPUSH
16143: LD_INT 1000
16145: PPUSH
16146: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
16150: LD_ADDR_EXP 53
16154: PUSH
16155: LD_EXP 53
16159: PUSH
16160: LD_VAR 0 1
16164: DIFF
16165: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16166: LD_VAR 0 1
16170: PPUSH
16171: LD_INT 22
16173: PUSH
16174: LD_INT 3
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: PUSH
16181: LD_INT 30
16183: PUSH
16184: LD_INT 4
16186: PUSH
16187: EMPTY
16188: LIST
16189: LIST
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PPUSH
16195: CALL_OW 69
16199: PPUSH
16200: CALL 1062 0 1
16204: PPUSH
16205: CALL_OW 120
// continue ;
16209: GO 16075
// end ; if IsOk ( un ) and not HasTask ( un ) then
16211: LD_VAR 0 1
16215: PPUSH
16216: CALL_OW 302
16220: PUSH
16221: LD_VAR 0 1
16225: PPUSH
16226: CALL_OW 314
16230: NOT
16231: AND
16232: IFFALSE 16325
// begin for j = 1 to ru_firepoints_south [ i ] do
16234: LD_ADDR_VAR 0 3
16238: PUSH
16239: DOUBLE
16240: LD_INT 1
16242: DEC
16243: ST_TO_ADDR
16244: LD_EXP 59
16248: PUSH
16249: LD_VAR 0 2
16253: ARRAY
16254: PUSH
16255: FOR_TO
16256: IFFALSE 16323
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
16258: LD_VAR 0 1
16262: PPUSH
16263: LD_EXP 59
16267: PUSH
16268: LD_VAR 0 2
16272: ARRAY
16273: PUSH
16274: LD_VAR 0 3
16278: ARRAY
16279: PUSH
16280: LD_INT 1
16282: ARRAY
16283: PPUSH
16284: LD_EXP 59
16288: PUSH
16289: LD_VAR 0 2
16293: ARRAY
16294: PUSH
16295: LD_VAR 0 3
16299: ARRAY
16300: PUSH
16301: LD_INT 2
16303: ARRAY
16304: PPUSH
16305: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
16309: LD_VAR 0 1
16313: PPUSH
16314: LD_INT 70
16316: PPUSH
16317: CALL_OW 202
// end ;
16321: GO 16255
16323: POP
16324: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16325: LD_VAR 0 1
16329: PPUSH
16330: CALL_OW 256
16334: PUSH
16335: LD_INT 700
16337: LESS
16338: PUSH
16339: LD_VAR 0 1
16343: PPUSH
16344: LD_INT 13
16346: PPUSH
16347: CALL_OW 308
16351: NOT
16352: AND
16353: IFFALSE 16405
// begin ComMoveToArea ( un , retreatArea ) ;
16355: LD_VAR 0 1
16359: PPUSH
16360: LD_INT 13
16362: PPUSH
16363: CALL_OW 113
// if not ru_alert_xy then
16367: LD_EXP 61
16371: NOT
16372: IFFALSE 16403
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
16374: LD_ADDR_EXP 61
16378: PUSH
16379: LD_VAR 0 1
16383: PPUSH
16384: CALL_OW 250
16388: PUSH
16389: LD_VAR 0 1
16393: PPUSH
16394: CALL_OW 251
16398: PUSH
16399: EMPTY
16400: LIST
16401: LIST
16402: ST_TO_ADDR
// end else
16403: GO 16474
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16405: LD_VAR 0 1
16409: PPUSH
16410: LD_VAR 0 4
16414: PPUSH
16415: LD_VAR 0 1
16419: PPUSH
16420: CALL_OW 74
16424: PPUSH
16425: CALL_OW 296
16429: PUSH
16430: LD_INT 9
16432: LESS
16433: PUSH
16434: LD_VAR 0 1
16438: PPUSH
16439: CALL_OW 256
16443: PUSH
16444: LD_INT 500
16446: GREATER
16447: AND
16448: IFFALSE 16474
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16450: LD_VAR 0 1
16454: PPUSH
16455: LD_VAR 0 4
16459: PPUSH
16460: LD_VAR 0 1
16464: PPUSH
16465: CALL_OW 74
16469: PPUSH
16470: CALL_OW 115
// end ;
16474: GO 16075
16476: POP
16477: POP
// end ;
16478: PPOPN 4
16480: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16481: LD_EXP 60
16485: PUSH
16486: LD_EXP 61
16490: AND
16491: PUSH
16492: LD_EXP 31
16496: NOT
16497: AND
16498: PUSH
16499: LD_EXP 32
16503: NOT
16504: AND
16505: IFFALSE 16715
16507: GO 16509
16509: DISABLE
16510: LD_INT 0
16512: PPUSH
16513: PPUSH
// begin enable ;
16514: ENABLE
// if not ru_vehicles then
16515: LD_EXP 56
16519: NOT
16520: IFFALSE 16524
// exit ;
16522: GO 16715
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16524: LD_ADDR_VAR 0 2
16528: PUSH
16529: LD_INT 81
16531: PUSH
16532: LD_INT 3
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PPUSH
16539: CALL_OW 69
16543: ST_TO_ADDR
// if ru_vehicles then
16544: LD_EXP 56
16548: IFFALSE 16715
// begin for i in ru_vehicles do
16550: LD_ADDR_VAR 0 1
16554: PUSH
16555: LD_EXP 56
16559: PUSH
16560: FOR_IN
16561: IFFALSE 16713
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16563: LD_VAR 0 1
16567: PPUSH
16568: CALL_OW 302
16572: PUSH
16573: LD_VAR 0 1
16577: PPUSH
16578: LD_VAR 0 2
16582: PPUSH
16583: LD_VAR 0 1
16587: PPUSH
16588: CALL_OW 74
16592: PPUSH
16593: CALL_OW 296
16597: PUSH
16598: LD_INT 9
16600: LESS
16601: AND
16602: IFFALSE 16628
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16604: LD_VAR 0 1
16608: PPUSH
16609: LD_VAR 0 2
16613: PPUSH
16614: LD_VAR 0 1
16618: PPUSH
16619: CALL_OW 74
16623: PPUSH
16624: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16628: LD_VAR 0 1
16632: PPUSH
16633: CALL_OW 314
16637: NOT
16638: PUSH
16639: LD_VAR 0 1
16643: PPUSH
16644: CALL_OW 302
16648: AND
16649: PUSH
16650: LD_VAR 0 1
16654: PPUSH
16655: LD_EXP 61
16659: PUSH
16660: LD_INT 1
16662: ARRAY
16663: PPUSH
16664: LD_EXP 61
16668: PUSH
16669: LD_INT 2
16671: ARRAY
16672: PPUSH
16673: CALL_OW 297
16677: PUSH
16678: LD_INT 10
16680: GREATER
16681: AND
16682: IFFALSE 16711
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16684: LD_VAR 0 1
16688: PPUSH
16689: LD_EXP 61
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: PPUSH
16698: LD_EXP 61
16702: PUSH
16703: LD_INT 2
16705: ARRAY
16706: PPUSH
16707: CALL_OW 114
// end ;
16711: GO 16560
16713: POP
16714: POP
// end ; end ;
16715: PPOPN 2
16717: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16718: LD_EXP 61
16722: PUSH
16723: LD_EXP 60
16727: AND
16728: PUSH
16729: LD_INT 3
16731: PPUSH
16732: CALL_OW 463
16736: NOT
16737: AND
16738: PUSH
16739: LD_EXP 31
16743: NOT
16744: AND
16745: PUSH
16746: LD_EXP 32
16750: NOT
16751: AND
16752: IFFALSE 16847
16754: GO 16756
16756: DISABLE
16757: LD_INT 0
16759: PPUSH
// begin enable ;
16760: ENABLE
// ru_alert_xy := false ;
16761: LD_ADDR_EXP 61
16765: PUSH
16766: LD_INT 0
16768: ST_TO_ADDR
// ru_alert := false ;
16769: LD_ADDR_EXP 60
16773: PUSH
16774: LD_INT 0
16776: ST_TO_ADDR
// if ru_vehicles then
16777: LD_EXP 56
16781: IFFALSE 16847
// for i in ru_vehicles do
16783: LD_ADDR_VAR 0 1
16787: PUSH
16788: LD_EXP 56
16792: PUSH
16793: FOR_IN
16794: IFFALSE 16845
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16796: LD_VAR 0 1
16800: PPUSH
16801: CALL_OW 302
16805: PUSH
16806: LD_VAR 0 1
16810: PPUSH
16811: LD_INT 89
16813: PPUSH
16814: LD_INT 36
16816: PPUSH
16817: CALL_OW 297
16821: PUSH
16822: LD_INT 10
16824: GREATER
16825: AND
16826: IFFALSE 16843
// ComMoveXY ( i , 89 , 36 ) ;
16828: LD_VAR 0 1
16832: PPUSH
16833: LD_INT 89
16835: PPUSH
16836: LD_INT 36
16838: PPUSH
16839: CALL_OW 111
16843: GO 16793
16845: POP
16846: POP
// end ;
16847: PPOPN 1
16849: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16850: LD_EXP 55
16854: PUSH
16855: LD_EXP 31
16859: NOT
16860: AND
16861: PUSH
16862: LD_EXP 32
16866: NOT
16867: AND
16868: IFFALSE 17152
16870: GO 16872
16872: DISABLE
16873: LD_INT 0
16875: PPUSH
16876: PPUSH
16877: PPUSH
// begin enable ;
16878: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16879: LD_ADDR_VAR 0 3
16883: PUSH
16884: LD_INT 81
16886: PUSH
16887: LD_INT 3
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PPUSH
16894: CALL_OW 69
16898: ST_TO_ADDR
// for i = 1 to ru_forest do
16899: LD_ADDR_VAR 0 1
16903: PUSH
16904: DOUBLE
16905: LD_INT 1
16907: DEC
16908: ST_TO_ADDR
16909: LD_EXP 55
16913: PUSH
16914: FOR_TO
16915: IFFALSE 17150
// begin un := ru_forest [ i ] ;
16917: LD_ADDR_VAR 0 2
16921: PUSH
16922: LD_EXP 55
16926: PUSH
16927: LD_VAR 0 1
16931: ARRAY
16932: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16933: LD_VAR 0 2
16937: PPUSH
16938: LD_INT 13
16940: PPUSH
16941: CALL_OW 308
16945: IFFALSE 17035
// begin if not See ( 1 , un ) then
16947: LD_INT 1
16949: PPUSH
16950: LD_VAR 0 2
16954: PPUSH
16955: CALL_OW 292
16959: NOT
16960: IFFALSE 16974
// SetLives ( un , 1000 ) ;
16962: LD_VAR 0 2
16966: PPUSH
16967: LD_INT 1000
16969: PPUSH
16970: CALL_OW 234
// ru_forest := ru_forest diff un ;
16974: LD_ADDR_EXP 55
16978: PUSH
16979: LD_EXP 55
16983: PUSH
16984: LD_VAR 0 2
16988: DIFF
16989: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16990: LD_VAR 0 2
16994: PPUSH
16995: LD_INT 22
16997: PUSH
16998: LD_INT 3
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: LD_INT 30
17007: PUSH
17008: LD_INT 4
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PUSH
17015: EMPTY
17016: LIST
17017: LIST
17018: PPUSH
17019: CALL_OW 69
17023: PPUSH
17024: CALL 1062 0 1
17028: PPUSH
17029: CALL_OW 120
// continue ;
17033: GO 16914
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
17035: LD_VAR 0 2
17039: PPUSH
17040: CALL_OW 256
17044: PUSH
17045: LD_INT 700
17047: LESS
17048: PUSH
17049: LD_VAR 0 2
17053: PPUSH
17054: LD_INT 13
17056: PPUSH
17057: CALL_OW 308
17061: NOT
17062: AND
17063: IFFALSE 17079
// ComMoveToArea ( un , retreatArea ) else
17065: LD_VAR 0 2
17069: PPUSH
17070: LD_INT 13
17072: PPUSH
17073: CALL_OW 113
17077: GO 17148
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
17079: LD_VAR 0 2
17083: PPUSH
17084: LD_VAR 0 3
17088: PPUSH
17089: LD_VAR 0 2
17093: PPUSH
17094: CALL_OW 74
17098: PPUSH
17099: CALL_OW 296
17103: PUSH
17104: LD_INT 9
17106: LESS
17107: PUSH
17108: LD_VAR 0 2
17112: PPUSH
17113: CALL_OW 256
17117: PUSH
17118: LD_INT 500
17120: GREATER
17121: AND
17122: IFFALSE 17148
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
17124: LD_VAR 0 2
17128: PPUSH
17129: LD_VAR 0 3
17133: PPUSH
17134: LD_VAR 0 2
17138: PPUSH
17139: CALL_OW 74
17143: PPUSH
17144: CALL_OW 115
// end ;
17148: GO 16914
17150: POP
17151: POP
// end ;
17152: PPOPN 3
17154: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
17155: LD_EXP 32
17159: NOT
17160: IFFALSE 17281
17162: GO 17164
17164: DISABLE
17165: LD_INT 0
17167: PPUSH
17168: PPUSH
// begin enable ;
17169: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
17170: LD_ADDR_VAR 0 2
17174: PUSH
17175: LD_INT 22
17177: PUSH
17178: LD_INT 3
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 21
17187: PUSH
17188: LD_INT 3
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: PPUSH
17199: CALL_OW 69
17203: ST_TO_ADDR
// if filter then
17204: LD_VAR 0 2
17208: IFFALSE 17281
// for i in filter do
17210: LD_ADDR_VAR 0 1
17214: PUSH
17215: LD_VAR 0 2
17219: PUSH
17220: FOR_IN
17221: IFFALSE 17279
// if GetLives ( i ) < 990 then
17223: LD_VAR 0 1
17227: PPUSH
17228: CALL_OW 256
17232: PUSH
17233: LD_INT 990
17235: LESS
17236: IFFALSE 17277
// begin ru_alert := true ;
17238: LD_ADDR_EXP 60
17242: PUSH
17243: LD_INT 1
17245: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
17246: LD_ADDR_EXP 61
17250: PUSH
17251: LD_VAR 0 1
17255: PPUSH
17256: CALL_OW 250
17260: PUSH
17261: LD_VAR 0 1
17265: PPUSH
17266: CALL_OW 251
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: ST_TO_ADDR
// break ;
17275: GO 17279
// end ;
17277: GO 17220
17279: POP
17280: POP
// end ;
17281: PPOPN 2
17283: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
17284: LD_EXP 31
17288: IFFALSE 17437
17290: GO 17292
17292: DISABLE
17293: LD_INT 0
17295: PPUSH
17296: PPUSH
17297: PPUSH
17298: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
17299: LD_ADDR_VAR 0 4
17303: PUSH
17304: LD_EXP 56
17308: PUSH
17309: LD_EXP 55
17313: ADD
17314: PUSH
17315: LD_EXP 53
17319: ADD
17320: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
17321: LD_ADDR_VAR 0 3
17325: PUSH
17326: LD_INT 3
17328: PPUSH
17329: LD_INT 81
17331: PUSH
17332: LD_INT 3
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: PPUSH
17339: CALL_OW 70
17343: ST_TO_ADDR
// if filter and enemy then
17344: LD_VAR 0 4
17348: PUSH
17349: LD_VAR 0 3
17353: AND
17354: IFFALSE 17437
// repeat wait ( 0 0$01 ) ;
17356: LD_INT 35
17358: PPUSH
17359: CALL_OW 67
// for i in filter do
17363: LD_ADDR_VAR 0 1
17367: PUSH
17368: LD_VAR 0 4
17372: PUSH
17373: FOR_IN
17374: IFFALSE 17402
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17376: LD_VAR 0 1
17380: PPUSH
17381: LD_VAR 0 3
17385: PPUSH
17386: LD_VAR 0 1
17390: PPUSH
17391: CALL_OW 74
17395: PPUSH
17396: CALL_OW 115
// end ;
17400: GO 17373
17402: POP
17403: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
17404: LD_INT 3
17406: PPUSH
17407: LD_INT 81
17409: PUSH
17410: LD_INT 3
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: PPUSH
17417: CALL_OW 70
17421: PUSH
17422: LD_INT 0
17424: EQUAL
17425: PUSH
17426: LD_VAR 0 4
17430: PUSH
17431: LD_INT 0
17433: EQUAL
17434: OR
17435: IFFALSE 17356
// end ;
17437: PPOPN 4
17439: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
17440: LD_EXP 26
17444: PUSH
17445: LD_INT 22
17447: PUSH
17448: LD_INT 4
17450: PUSH
17451: EMPTY
17452: LIST
17453: LIST
17454: PUSH
17455: LD_INT 30
17457: PUSH
17458: LD_INT 4
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: PUSH
17465: LD_INT 3
17467: PUSH
17468: LD_INT 57
17470: PUSH
17471: EMPTY
17472: LIST
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: LIST
17482: PPUSH
17483: CALL_OW 69
17487: AND
17488: IFFALSE 17537
17490: GO 17492
17492: DISABLE
17493: LD_INT 0
17495: PPUSH
// begin if not ru_cornel_attack then
17496: LD_EXP 58
17500: NOT
17501: IFFALSE 17505
// exit ;
17503: GO 17537
// for i in ru_cornel_attack do
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_EXP 58
17514: PUSH
17515: FOR_IN
17516: IFFALSE 17535
// ComAgressiveMove ( i , 258 , 119 ) ;
17518: LD_VAR 0 1
17522: PPUSH
17523: LD_INT 258
17525: PPUSH
17526: LD_INT 119
17528: PPUSH
17529: CALL_OW 114
17533: GO 17515
17535: POP
17536: POP
// end ; end_of_file
17537: PPOPN 1
17539: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17540: LD_EXP 5
17544: PUSH
17545: LD_EXP 9
17549: NOT
17550: AND
17551: PUSH
17552: LD_EXP 20
17556: AND
17557: IFFALSE 17669
17559: GO 17561
17561: DISABLE
17562: LD_INT 0
17564: PPUSH
// begin enable ;
17565: ENABLE
// crates_counter := crates_counter - 50 ;
17566: LD_ADDR_EXP 20
17570: PUSH
17571: LD_EXP 20
17575: PUSH
17576: LD_INT 50
17578: MINUS
17579: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17580: LD_INT 8
17582: PPUSH
17583: LD_INT 2
17585: PPUSH
17586: LD_INT 5
17588: PPUSH
17589: CALL_OW 12
17593: PPUSH
17594: LD_INT 1
17596: PPUSH
17597: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17601: LD_INT 1785
17603: PPUSH
17604: LD_INT 2345
17606: PPUSH
17607: CALL_OW 12
17611: PPUSH
17612: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17616: LD_ADDR_VAR 0 1
17620: PUSH
17621: LD_INT 1
17623: PPUSH
17624: LD_OWVAR 67
17628: PUSH
17629: LD_INT 2
17631: PLUS
17632: PPUSH
17633: CALL_OW 12
17637: ST_TO_ADDR
// if r < 3 then
17638: LD_VAR 0 1
17642: PUSH
17643: LD_INT 3
17645: LESS
17646: IFFALSE 17669
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17648: LD_INT 4
17650: PPUSH
17651: LD_INT 1
17653: PPUSH
17654: LD_INT 5
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: LD_INT 1
17664: PPUSH
17665: CALL_OW 55
// end ;
17669: PPOPN 1
17671: END
// every 0 0$01 trigger cornel_active do
17672: LD_EXP 8
17676: IFFALSE 17765
17678: GO 17680
17680: DISABLE
// begin Wait ( 0 0$03 ) ;
17681: LD_INT 105
17683: PPUSH
17684: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17688: LD_INT 2
17690: PPUSH
17691: LD_INT 5
17693: PPUSH
17694: CALL_OW 12
17698: PPUSH
17699: LD_INT 10
17701: PPUSH
17702: LD_INT 1
17704: PPUSH
17705: CALL_OW 55
// Wait ( 0 0$13 ) ;
17709: LD_INT 455
17711: PPUSH
17712: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17716: LD_INT 2
17718: PPUSH
17719: LD_INT 5
17721: PPUSH
17722: CALL_OW 12
17726: PPUSH
17727: LD_INT 10
17729: PPUSH
17730: LD_INT 1
17732: PPUSH
17733: CALL_OW 55
// Wait ( 0 0$16 ) ;
17737: LD_INT 560
17739: PPUSH
17740: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17744: LD_INT 2
17746: PPUSH
17747: LD_INT 5
17749: PPUSH
17750: CALL_OW 12
17754: PPUSH
17755: LD_INT 10
17757: PPUSH
17758: LD_INT 1
17760: PPUSH
17761: CALL_OW 55
// end ; end_of_file
17765: END
// every 0 0$01 trigger cornel_prepared do
17766: LD_EXP 11
17770: IFFALSE 17829
17772: GO 17774
17774: DISABLE
// begin enable ;
17775: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17776: LD_ADDR_OWVAR 47
17780: PUSH
17781: LD_STRING #Am03-1
17783: PUSH
17784: LD_EXP 10
17788: PUSH
17789: EMPTY
17790: LIST
17791: LIST
17792: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17793: LD_ADDR_EXP 10
17797: PUSH
17798: LD_EXP 10
17802: PPUSH
17803: LD_STRING -
17805: PPUSH
17806: CALL 1132 0 2
17810: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17811: LD_EXP 10
17815: PUSH
17816: LD_INT 0
17818: EQUAL
17819: IFFALSE 17829
// begin Display_Strings := [ ] ;
17821: LD_ADDR_OWVAR 47
17825: PUSH
17826: EMPTY
17827: ST_TO_ADDR
// disable ;
17828: DISABLE
// end ; end ;
17829: END
// every 0 0$01 trigger debug and debug_strings do
17830: LD_EXP 1
17834: PUSH
17835: LD_OWVAR 48
17839: AND
17840: IFFALSE 17856
17842: GO 17844
17844: DISABLE
// begin enable ;
17845: ENABLE
// Display_Strings := debug_strings ;
17846: LD_ADDR_OWVAR 47
17850: PUSH
17851: LD_OWVAR 48
17855: ST_TO_ADDR
// end ; end_of_file
17856: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17857: LD_VAR 0 1
17861: PPUSH
17862: CALL_OW 255
17866: PUSH
17867: LD_INT 1
17869: EQUAL
17870: PUSH
17871: LD_EXP 14
17875: NOT
17876: AND
17877: IFFALSE 17887
// solar_builded := true ;
17879: LD_ADDR_EXP 14
17883: PUSH
17884: LD_INT 1
17886: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17887: LD_VAR 0 1
17891: PPUSH
17892: CALL_OW 255
17896: PUSH
17897: LD_INT 1
17899: EQUAL
17900: PUSH
17901: LD_EXP 29
17905: AND
17906: IFFALSE 17939
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17908: LD_ADDR_EXP 29
17912: PUSH
17913: LD_EXP 29
17917: PUSH
17918: LD_INT 1750
17920: PUSH
17921: LD_INT 1400
17923: PUSH
17924: LD_INT 1225
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: LIST
17931: PUSH
17932: LD_OWVAR 67
17936: ARRAY
17937: PLUS
17938: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17939: LD_VAR 0 1
17943: PPUSH
17944: CALL_OW 255
17948: PUSH
17949: LD_INT 3
17951: EQUAL
17952: IFFALSE 17970
// ru_vehicles := ru_vehicles ^ veh ;
17954: LD_ADDR_EXP 56
17958: PUSH
17959: LD_EXP 56
17963: PUSH
17964: LD_VAR 0 1
17968: ADD
17969: ST_TO_ADDR
// end ;
17970: PPOPN 2
17972: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17973: LD_VAR 0 1
17977: PUSH
17978: LD_EXP 53
17982: IN
17983: IFFALSE 18001
// ru_patrol := ru_patrol diff un ;
17985: LD_ADDR_EXP 53
17989: PUSH
17990: LD_EXP 53
17994: PUSH
17995: LD_VAR 0 1
17999: DIFF
18000: ST_TO_ADDR
// if un in ru_forest then
18001: LD_VAR 0 1
18005: PUSH
18006: LD_EXP 55
18010: IN
18011: IFFALSE 18029
// ru_forest := ru_forest diff un ;
18013: LD_ADDR_EXP 55
18017: PUSH
18018: LD_EXP 55
18022: PUSH
18023: LD_VAR 0 1
18027: DIFF
18028: ST_TO_ADDR
// if un in ru_vehicles then
18029: LD_VAR 0 1
18033: PUSH
18034: LD_EXP 56
18038: IN
18039: IFFALSE 18145
// begin ru_vehicles := ru_vehicles diff un ;
18041: LD_ADDR_EXP 56
18045: PUSH
18046: LD_EXP 56
18050: PUSH
18051: LD_VAR 0 1
18055: DIFF
18056: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
18057: LD_ADDR_EXP 57
18061: PUSH
18062: LD_EXP 57
18066: PUSH
18067: LD_VAR 0 1
18071: PPUSH
18072: CALL_OW 265
18076: PUSH
18077: LD_VAR 0 1
18081: PPUSH
18082: CALL_OW 262
18086: PUSH
18087: LD_VAR 0 1
18091: PPUSH
18092: CALL_OW 263
18096: PUSH
18097: LD_VAR 0 1
18101: PPUSH
18102: CALL_OW 264
18106: PUSH
18107: EMPTY
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: ADD
18113: ST_TO_ADDR
// ach_counter := ach_counter + 1 ;
18114: LD_ADDR_EXP 13
18118: PUSH
18119: LD_EXP 13
18123: PUSH
18124: LD_INT 1
18126: PLUS
18127: ST_TO_ADDR
// if ach_counter = 10 then
18128: LD_EXP 13
18132: PUSH
18133: LD_INT 10
18135: EQUAL
18136: IFFALSE 18145
// SetAchievement ( ACH_FAUST ) ;
18138: LD_STRING ACH_FAUST
18140: PPUSH
18141: CALL_OW 543
// end ; if un = Pokryshkin then
18145: LD_VAR 0 1
18149: PUSH
18150: LD_EXP 52
18154: EQUAL
18155: IFFALSE 18164
// SetAchievement ( ACH_POKR ) ;
18157: LD_STRING ACH_POKR
18159: PPUSH
18160: CALL_OW 543
// if un = JMM then
18164: LD_VAR 0 1
18168: PUSH
18169: LD_EXP 37
18173: EQUAL
18174: IFFALSE 18183
// YouLost ( 0 ) ;
18176: LD_STRING 0
18178: PPUSH
18179: CALL_OW 104
// if un = us_dep_west then
18183: LD_VAR 0 1
18187: PUSH
18188: LD_INT 1
18190: EQUAL
18191: IFFALSE 18200
// YouLost ( 2 ) ;
18193: LD_STRING 2
18195: PPUSH
18196: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
18200: LD_VAR 0 1
18204: PPUSH
18205: CALL_OW 255
18209: PUSH
18210: LD_INT 8
18212: EQUAL
18213: PUSH
18214: LD_EXP 5
18218: NOT
18219: AND
18220: IFFALSE 18229
// YouLost ( 4 ) ;
18222: LD_STRING 4
18224: PPUSH
18225: CALL_OW 104
// if un in jmm_units then
18229: LD_VAR 0 1
18233: PUSH
18234: LD_EXP 4
18238: IN
18239: IFFALSE 18255
// lose_counter := lose_counter + 1 ;
18241: LD_ADDR_EXP 34
18245: PUSH
18246: LD_EXP 34
18250: PUSH
18251: LD_INT 1
18253: PLUS
18254: ST_TO_ADDR
// end ;
18255: PPOPN 1
18257: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
18258: LD_INT 0
18260: PPUSH
18261: PPUSH
// begin if GetSide ( driver ) = 3 then
18262: LD_VAR 0 1
18266: PPUSH
18267: CALL_OW 255
18271: PUSH
18272: LD_INT 3
18274: EQUAL
18275: IFFALSE 18353
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
18277: LD_ADDR_VAR 0 6
18281: PUSH
18282: LD_INT 22
18284: PUSH
18285: LD_INT 3
18287: PUSH
18288: EMPTY
18289: LIST
18290: LIST
18291: PUSH
18292: LD_INT 30
18294: PUSH
18295: LD_INT 3
18297: PUSH
18298: EMPTY
18299: LIST
18300: LIST
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: PPUSH
18306: CALL_OW 69
18310: PPUSH
18311: CALL 1062 0 1
18315: ST_TO_ADDR
// if place then
18316: LD_VAR 0 6
18320: IFFALSE 18338
// ComEnterUnit ( driver , place ) else
18322: LD_VAR 0 1
18326: PPUSH
18327: LD_VAR 0 6
18331: PPUSH
18332: CALL_OW 120
18336: GO 18353
// ComMoveXY ( driver , 70 , 22 ) ;
18338: LD_VAR 0 1
18342: PPUSH
18343: LD_INT 70
18345: PPUSH
18346: LD_INT 22
18348: PPUSH
18349: CALL_OW 111
// end ; end ;
18353: PPOPN 6
18355: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
18356: LD_VAR 0 1
18360: PUSH
18361: LD_INT 1
18363: EQUAL
18364: PUSH
18365: LD_VAR 0 2
18369: PUSH
18370: LD_INT 4
18372: EQUAL
18373: PUSH
18374: LD_VAR 0 2
18378: PUSH
18379: LD_INT 8
18381: EQUAL
18382: PUSH
18383: LD_EXP 5
18387: NOT
18388: AND
18389: OR
18390: AND
18391: IFFALSE 18400
// YouLost ( 5 ) ;
18393: LD_STRING 5
18395: PPUSH
18396: CALL_OW 104
// end ;
18400: PPOPN 2
18402: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
18403: LD_EXP 36
18407: PUSH
18408: LD_INT 22
18410: PUSH
18411: LD_INT 1
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: LD_INT 21
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: PUSH
18428: EMPTY
18429: LIST
18430: LIST
18431: PPUSH
18432: CALL_OW 69
18436: PUSH
18437: LD_INT 22
18439: PUSH
18440: LD_INT 8
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 21
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: PPUSH
18461: CALL_OW 69
18465: ADD
18466: PLUS
18467: PUSH
18468: LD_INT 5
18470: LESS
18471: IFFALSE 18483
18473: GO 18475
18475: DISABLE
// YouLost ( 1 ) ;
18476: LD_STRING 1
18478: PPUSH
18479: CALL_OW 104
18483: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
18484: LD_INT 1
18486: PPUSH
18487: CALL_OW 255
18491: PUSH
18492: LD_INT 3
18494: EQUAL
18495: IFFALSE 18507
18497: GO 18499
18499: DISABLE
// YouLost ( 3 ) ; end_of_file
18500: LD_STRING 3
18502: PPUSH
18503: CALL_OW 104
18507: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18508: GO 18510
18510: DISABLE
// begin ru_radar := 98 ;
18511: LD_ADDR_EXP 62
18515: PUSH
18516: LD_INT 98
18518: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18519: LD_ADDR_EXP 63
18523: PUSH
18524: LD_INT 89
18526: ST_TO_ADDR
// us_hack := 99 ;
18527: LD_ADDR_EXP 64
18531: PUSH
18532: LD_INT 99
18534: ST_TO_ADDR
// us_artillery := 97 ;
18535: LD_ADDR_EXP 65
18539: PUSH
18540: LD_INT 97
18542: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18543: LD_ADDR_EXP 66
18547: PUSH
18548: LD_INT 91
18550: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
18551: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
18552: LD_INT 0
18554: PPUSH
18555: PPUSH
18556: PPUSH
18557: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18558: LD_VAR 0 1
18562: PPUSH
18563: CALL_OW 264
18567: PUSH
18568: LD_EXP 66
18572: EQUAL
18573: IFFALSE 18645
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18575: LD_INT 68
18577: PPUSH
18578: LD_VAR 0 1
18582: PPUSH
18583: CALL_OW 255
18587: PPUSH
18588: CALL_OW 321
18592: PUSH
18593: LD_INT 2
18595: EQUAL
18596: IFFALSE 18608
// eff := 70 else
18598: LD_ADDR_VAR 0 6
18602: PUSH
18603: LD_INT 70
18605: ST_TO_ADDR
18606: GO 18616
// eff := 30 ;
18608: LD_ADDR_VAR 0 6
18612: PUSH
18613: LD_INT 30
18615: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18616: LD_VAR 0 1
18620: PPUSH
18621: CALL_OW 250
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: CALL_OW 251
18635: PPUSH
18636: LD_VAR 0 6
18640: PPUSH
18641: CALL_OW 495
// end ; end ;
18645: LD_VAR 0 4
18649: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18650: LD_INT 0
18652: PPUSH
18653: PPUSH
18654: PPUSH
18655: PPUSH
18656: PPUSH
18657: PPUSH
// if cmd = 124 then
18658: LD_VAR 0 1
18662: PUSH
18663: LD_INT 124
18665: EQUAL
18666: IFFALSE 18872
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18668: LD_ADDR_VAR 0 5
18672: PUSH
18673: LD_INT 2
18675: PUSH
18676: LD_INT 34
18678: PUSH
18679: LD_INT 53
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: LD_INT 34
18688: PUSH
18689: LD_INT 14
18691: PUSH
18692: EMPTY
18693: LIST
18694: LIST
18695: PUSH
18696: EMPTY
18697: LIST
18698: LIST
18699: LIST
18700: PPUSH
18701: CALL_OW 69
18705: ST_TO_ADDR
// if not tmp then
18706: LD_VAR 0 5
18710: NOT
18711: IFFALSE 18715
// exit ;
18713: GO 18872
// for i in tmp do
18715: LD_ADDR_VAR 0 3
18719: PUSH
18720: LD_VAR 0 5
18724: PUSH
18725: FOR_IN
18726: IFFALSE 18870
// begin taskList := GetTaskList ( i ) ;
18728: LD_ADDR_VAR 0 6
18732: PUSH
18733: LD_VAR 0 3
18737: PPUSH
18738: CALL_OW 437
18742: ST_TO_ADDR
// if not taskList then
18743: LD_VAR 0 6
18747: NOT
18748: IFFALSE 18752
// continue ;
18750: GO 18725
// for j = 1 to taskList do
18752: LD_ADDR_VAR 0 4
18756: PUSH
18757: DOUBLE
18758: LD_INT 1
18760: DEC
18761: ST_TO_ADDR
18762: LD_VAR 0 6
18766: PUSH
18767: FOR_TO
18768: IFFALSE 18866
// if taskList [ j ] [ 1 ] = | then
18770: LD_VAR 0 6
18774: PUSH
18775: LD_VAR 0 4
18779: ARRAY
18780: PUSH
18781: LD_INT 1
18783: ARRAY
18784: PUSH
18785: LD_STRING |
18787: EQUAL
18788: IFFALSE 18864
// begin _taskList := Delete ( taskList , 1 ) ;
18790: LD_ADDR_VAR 0 7
18794: PUSH
18795: LD_VAR 0 6
18799: PPUSH
18800: LD_INT 1
18802: PPUSH
18803: CALL_OW 3
18807: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18808: LD_VAR 0 3
18812: PPUSH
18813: LD_VAR 0 7
18817: PPUSH
18818: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18822: LD_VAR 0 3
18826: PPUSH
18827: LD_VAR 0 6
18831: PUSH
18832: LD_VAR 0 4
18836: ARRAY
18837: PUSH
18838: LD_INT 2
18840: ARRAY
18841: PPUSH
18842: LD_VAR 0 6
18846: PUSH
18847: LD_VAR 0 4
18851: ARRAY
18852: PUSH
18853: LD_INT 3
18855: ARRAY
18856: PPUSH
18857: LD_INT 8
18859: PPUSH
18860: CALL 18877 0 4
// end ;
18864: GO 18767
18866: POP
18867: POP
// end ;
18868: GO 18725
18870: POP
18871: POP
// end ; end ;
18872: LD_VAR 0 2
18876: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18877: LD_INT 0
18879: PPUSH
18880: PPUSH
18881: PPUSH
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
18886: PPUSH
18887: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18888: LD_VAR 0 1
18892: NOT
18893: PUSH
18894: LD_VAR 0 2
18898: PPUSH
18899: LD_VAR 0 3
18903: PPUSH
18904: CALL_OW 488
18908: NOT
18909: OR
18910: PUSH
18911: LD_VAR 0 4
18915: NOT
18916: OR
18917: IFFALSE 18921
// exit ;
18919: GO 19261
// list := [ ] ;
18921: LD_ADDR_VAR 0 13
18925: PUSH
18926: EMPTY
18927: ST_TO_ADDR
// if x - r < 0 then
18928: LD_VAR 0 2
18932: PUSH
18933: LD_VAR 0 4
18937: MINUS
18938: PUSH
18939: LD_INT 0
18941: LESS
18942: IFFALSE 18954
// min_x := 0 else
18944: LD_ADDR_VAR 0 7
18948: PUSH
18949: LD_INT 0
18951: ST_TO_ADDR
18952: GO 18970
// min_x := x - r ;
18954: LD_ADDR_VAR 0 7
18958: PUSH
18959: LD_VAR 0 2
18963: PUSH
18964: LD_VAR 0 4
18968: MINUS
18969: ST_TO_ADDR
// if y - r < 0 then
18970: LD_VAR 0 3
18974: PUSH
18975: LD_VAR 0 4
18979: MINUS
18980: PUSH
18981: LD_INT 0
18983: LESS
18984: IFFALSE 18996
// min_y := 0 else
18986: LD_ADDR_VAR 0 8
18990: PUSH
18991: LD_INT 0
18993: ST_TO_ADDR
18994: GO 19012
// min_y := y - r ;
18996: LD_ADDR_VAR 0 8
19000: PUSH
19001: LD_VAR 0 3
19005: PUSH
19006: LD_VAR 0 4
19010: MINUS
19011: ST_TO_ADDR
// max_x := x + r ;
19012: LD_ADDR_VAR 0 9
19016: PUSH
19017: LD_VAR 0 2
19021: PUSH
19022: LD_VAR 0 4
19026: PLUS
19027: ST_TO_ADDR
// max_y := y + r ;
19028: LD_ADDR_VAR 0 10
19032: PUSH
19033: LD_VAR 0 3
19037: PUSH
19038: LD_VAR 0 4
19042: PLUS
19043: ST_TO_ADDR
// for _x = min_x to max_x do
19044: LD_ADDR_VAR 0 11
19048: PUSH
19049: DOUBLE
19050: LD_VAR 0 7
19054: DEC
19055: ST_TO_ADDR
19056: LD_VAR 0 9
19060: PUSH
19061: FOR_TO
19062: IFFALSE 19179
// for _y = min_y to max_y do
19064: LD_ADDR_VAR 0 12
19068: PUSH
19069: DOUBLE
19070: LD_VAR 0 8
19074: DEC
19075: ST_TO_ADDR
19076: LD_VAR 0 10
19080: PUSH
19081: FOR_TO
19082: IFFALSE 19175
// begin if not ValidHex ( _x , _y ) then
19084: LD_VAR 0 11
19088: PPUSH
19089: LD_VAR 0 12
19093: PPUSH
19094: CALL_OW 488
19098: NOT
19099: IFFALSE 19103
// continue ;
19101: GO 19081
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19103: LD_VAR 0 11
19107: PPUSH
19108: LD_VAR 0 12
19112: PPUSH
19113: CALL_OW 351
19117: PUSH
19118: LD_VAR 0 11
19122: PPUSH
19123: LD_VAR 0 12
19127: PPUSH
19128: CALL_OW 554
19132: AND
19133: IFFALSE 19173
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19135: LD_ADDR_VAR 0 13
19139: PUSH
19140: LD_VAR 0 13
19144: PPUSH
19145: LD_VAR 0 13
19149: PUSH
19150: LD_INT 1
19152: PLUS
19153: PPUSH
19154: LD_VAR 0 11
19158: PUSH
19159: LD_VAR 0 12
19163: PUSH
19164: EMPTY
19165: LIST
19166: LIST
19167: PPUSH
19168: CALL_OW 2
19172: ST_TO_ADDR
// end ;
19173: GO 19081
19175: POP
19176: POP
19177: GO 19061
19179: POP
19180: POP
// if not list then
19181: LD_VAR 0 13
19185: NOT
19186: IFFALSE 19190
// exit ;
19188: GO 19261
// for i in list do
19190: LD_ADDR_VAR 0 6
19194: PUSH
19195: LD_VAR 0 13
19199: PUSH
19200: FOR_IN
19201: IFFALSE 19259
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19203: LD_VAR 0 1
19207: PPUSH
19208: LD_STRING M
19210: PUSH
19211: LD_VAR 0 6
19215: PUSH
19216: LD_INT 1
19218: ARRAY
19219: PUSH
19220: LD_VAR 0 6
19224: PUSH
19225: LD_INT 2
19227: ARRAY
19228: PUSH
19229: LD_INT 0
19231: PUSH
19232: LD_INT 0
19234: PUSH
19235: LD_INT 0
19237: PUSH
19238: LD_INT 0
19240: PUSH
19241: EMPTY
19242: LIST
19243: LIST
19244: LIST
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: PUSH
19250: EMPTY
19251: LIST
19252: PPUSH
19253: CALL_OW 447
19257: GO 19200
19259: POP
19260: POP
// end ;
19261: LD_VAR 0 5
19265: RET
