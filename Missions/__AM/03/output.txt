// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 50 0 0
// SetDiplomacy ;
  15: CALL 378 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 29
// DebugMode ;
  25: CALL 466 0 0
// PrepareRussian ;
  29: CALL 3023 0 0
// PrepareAmerican ;
  33: CALL 1228 0 0
// PrepareCornell ;
  37: CALL 2252 0 0
// PrepareWesternBase ;
  41: CALL 2478 0 0
// Action ;
  45: CALL 5239 0 0
// end ;
  49: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , ach_counter , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  50: LD_INT 0
  52: PPUSH
// debug := false ;
  53: LD_ADDR_EXP 1
  57: PUSH
  58: LD_INT 0
  60: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  61: LD_ADDR_EXP 3
  65: PUSH
  66: LD_STRING 02_
  68: ST_TO_ADDR
// mission_prefix := 03_ ;
  69: LD_ADDR_EXP 2
  73: PUSH
  74: LD_STRING 03_
  76: ST_TO_ADDR
// jmm_units := 0 ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// cornel_units := 0 ;
  85: LD_ADDR_EXP 6
  89: PUSH
  90: LD_INT 0
  92: ST_TO_ADDR
// bierezov_exist := false ;
  93: LD_ADDR_EXP 7
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// jmm_on_west := false ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// cornel_active := false ;
 109: LD_ADDR_EXP 8
 113: PUSH
 114: LD_INT 0
 116: ST_TO_ADDR
// cornel_attack := false ;
 117: LD_ADDR_EXP 9
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// cornel_prepared := false ;
 125: LD_ADDR_EXP 11
 129: PUSH
 130: LD_INT 0
 132: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 133: LD_ADDR_EXP 10
 137: PUSH
 138: LD_INT 4200
 140: ST_TO_ADDR
// frank_can_return := false ;
 141: LD_ADDR_EXP 12
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// solar_builded := false ;
 149: LD_ADDR_EXP 14
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// frank_send_to_scout := false ;
 157: LD_ADDR_EXP 15
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// jmm_in_veh := false ;
 165: LD_ADDR_EXP 16
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// bobby_in_veh := false ;
 173: LD_ADDR_EXP 17
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// cyrus_in_veh := false ;
 181: LD_ADDR_EXP 18
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// lisa_in_veh := false ;
 189: LD_ADDR_EXP 19
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 197: LD_ADDR_EXP 29
 201: PUSH
 202: LD_INT 25200
 204: PUSH
 205: LD_INT 23100
 207: PUSH
 208: LD_INT 21000
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_OWVAR 67
 220: ARRAY
 221: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 222: LD_ADDR_EXP 20
 226: PUSH
 227: LD_INT 600
 229: PUSH
 230: LD_INT 500
 232: PUSH
 233: LD_INT 400
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_OWVAR 67
 245: ARRAY
 246: ST_TO_ADDR
// end_mission_allowed := false ;
 247: LD_ADDR_EXP 21
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// save_others := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// save_group := [ ] ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: EMPTY
 268: ST_TO_ADDR
// show_query := true ;
 269: LD_ADDR_EXP 24
 273: PUSH
 274: LD_INT 1
 276: ST_TO_ADDR
// wait_for_them := false ;
 277: LD_ADDR_EXP 25
 281: PUSH
 282: LD_INT 0
 284: ST_TO_ADDR
// veh_on_meta := false ;
 285: LD_ADDR_EXP 28
 289: PUSH
 290: LD_INT 0
 292: ST_TO_ADDR
// send_spec_patrol := false ;
 293: LD_ADDR_EXP 30
 297: PUSH
 298: LD_INT 0
 300: ST_TO_ADDR
// prepare_siege := false ;
 301: LD_ADDR_EXP 31
 305: PUSH
 306: LD_INT 0
 308: ST_TO_ADDR
// send_attack_on_cornel := false ;
 309: LD_ADDR_EXP 32
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 0
 324: ST_TO_ADDR
// game_end := false ;
 325: LD_ADDR_EXP 33
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// lose_counter := 0 ;
 333: LD_ADDR_EXP 34
 337: PUSH
 338: LD_INT 0
 340: ST_TO_ADDR
// powell_warn := 0 ;
 341: LD_ADDR_EXP 35
 345: PUSH
 346: LD_INT 0
 348: ST_TO_ADDR
// save_counter := 0 ;
 349: LD_ADDR_EXP 36
 353: PUSH
 354: LD_INT 0
 356: ST_TO_ADDR
// cornel_saved := false ;
 357: LD_ADDR_EXP 27
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// ach_counter := 0 ;
 365: LD_ADDR_EXP 13
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// end ;
 373: LD_VAR 0 1
 377: RET
// function SetDiplomacy ; begin
 378: LD_INT 0
 380: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 4
 386: PPUSH
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 1
 392: PPUSH
 393: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 8
 402: PPUSH
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 1
 408: PPUSH
 409: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 413: LD_INT 3
 415: PPUSH
 416: LD_INT 6
 418: PPUSH
 419: LD_INT 1
 421: PPUSH
 422: LD_INT 1
 424: PPUSH
 425: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 429: LD_INT 4
 431: PPUSH
 432: LD_INT 6
 434: PPUSH
 435: LD_INT 0
 437: PPUSH
 438: LD_INT 1
 440: PPUSH
 441: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 445: LD_INT 3
 447: PPUSH
 448: LD_INT 8
 450: PPUSH
 451: LD_INT 0
 453: PPUSH
 454: LD_INT 1
 456: PPUSH
 457: CALL_OW 80
// end ;
 461: LD_VAR 0 1
 465: RET
// export function DebugMode ; var i ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// FogOff ( 1 ) ;
 470: LD_INT 1
 472: PPUSH
 473: CALL_OW 344
// debug_strings := [ ] ;
 477: LD_ADDR_OWVAR 48
 481: PUSH
 482: EMPTY
 483: ST_TO_ADDR
// end ; end_of_file
 484: LD_VAR 0 1
 488: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 489: LD_INT 0
 491: PPUSH
 492: PPUSH
// if exist_mode then
 493: LD_VAR 0 2
 497: IFFALSE 522
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_EXP 3
 508: PUSH
 509: LD_VAR 0 1
 513: STR
 514: PPUSH
 515: CALL_OW 34
 519: ST_TO_ADDR
 520: GO 537
// unit := NewCharacter ( ident ) ;
 522: LD_ADDR_VAR 0 4
 526: PUSH
 527: LD_VAR 0 1
 531: PPUSH
 532: CALL_OW 25
 536: ST_TO_ADDR
// result := unit ;
 537: LD_ADDR_VAR 0 3
 541: PUSH
 542: LD_VAR 0 4
 546: ST_TO_ADDR
// end ;
 547: LD_VAR 0 3
 551: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 552: LD_INT 0
 554: PPUSH
// uc_side := side ;
 555: LD_ADDR_OWVAR 20
 559: PUSH
 560: LD_VAR 0 1
 564: ST_TO_ADDR
// uc_nation := nation ;
 565: LD_ADDR_OWVAR 21
 569: PUSH
 570: LD_VAR 0 2
 574: ST_TO_ADDR
// vc_chassis := chassis ;
 575: LD_ADDR_OWVAR 37
 579: PUSH
 580: LD_VAR 0 3
 584: ST_TO_ADDR
// vc_engine := engine ;
 585: LD_ADDR_OWVAR 39
 589: PUSH
 590: LD_VAR 0 4
 594: ST_TO_ADDR
// vc_control := control ;
 595: LD_ADDR_OWVAR 38
 599: PUSH
 600: LD_VAR 0 5
 604: ST_TO_ADDR
// vc_weapon := weapon ;
 605: LD_ADDR_OWVAR 40
 609: PUSH
 610: LD_VAR 0 6
 614: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 615: LD_ADDR_OWVAR 41
 619: PUSH
 620: LD_VAR 0 7
 624: ST_TO_ADDR
// result := CreateVehicle ;
 625: LD_ADDR_VAR 0 8
 629: PUSH
 630: CALL_OW 45
 634: ST_TO_ADDR
// end ;
 635: LD_VAR 0 8
 639: RET
// export function SayX ( units , ident ) ; var i ; begin
 640: LD_INT 0
 642: PPUSH
 643: PPUSH
// result := false ;
 644: LD_ADDR_VAR 0 3
 648: PUSH
 649: LD_INT 0
 651: ST_TO_ADDR
// if not units then
 652: LD_VAR 0 1
 656: NOT
 657: IFFALSE 661
// exit ;
 659: GO 715
// for i in units do
 661: LD_ADDR_VAR 0 4
 665: PUSH
 666: LD_VAR 0 1
 670: PUSH
 671: FOR_IN
 672: IFFALSE 713
// if IsOk ( i ) then
 674: LD_VAR 0 4
 678: PPUSH
 679: CALL_OW 302
 683: IFFALSE 711
// begin Say ( i , ident ) ;
 685: LD_VAR 0 4
 689: PPUSH
 690: LD_VAR 0 2
 694: PPUSH
 695: CALL_OW 88
// result := i ;
 699: LD_ADDR_VAR 0 3
 703: PUSH
 704: LD_VAR 0 4
 708: ST_TO_ADDR
// break ;
 709: GO 713
// end ;
 711: GO 671
 713: POP
 714: POP
// end ;
 715: LD_VAR 0 3
 719: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 720: LD_INT 0
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
// for i = 1 to count do
 726: LD_ADDR_VAR 0 8
 730: PUSH
 731: DOUBLE
 732: LD_INT 1
 734: DEC
 735: ST_TO_ADDR
 736: LD_VAR 0 6
 740: PUSH
 741: FOR_TO
 742: IFFALSE 823
// begin uc_side = side ;
 744: LD_ADDR_OWVAR 20
 748: PUSH
 749: LD_VAR 0 1
 753: ST_TO_ADDR
// uc_nation = nation ;
 754: LD_ADDR_OWVAR 21
 758: PUSH
 759: LD_VAR 0 2
 763: ST_TO_ADDR
// hc_gallery =  ;
 764: LD_ADDR_OWVAR 33
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// hc_name =  ;
 772: LD_ADDR_OWVAR 26
 776: PUSH
 777: LD_STRING 
 779: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 780: LD_INT 0
 782: PPUSH
 783: LD_VAR 0 5
 787: PPUSH
 788: LD_VAR 0 4
 792: PPUSH
 793: CALL_OW 380
// un = CreateHuman ;
 797: LD_ADDR_VAR 0 10
 801: PUSH
 802: CALL_OW 44
 806: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 807: LD_VAR 0 10
 811: PPUSH
 812: LD_VAR 0 3
 816: PPUSH
 817: CALL_OW 52
// end ;
 821: GO 741
 823: POP
 824: POP
// end ;
 825: LD_VAR 0 7
 829: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 830: LD_INT 0
 832: PPUSH
 833: PPUSH
 834: PPUSH
// uc_side := GetSide ( b ) ;
 835: LD_ADDR_OWVAR 20
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 255
 849: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 850: LD_ADDR_OWVAR 21
 854: PUSH
 855: LD_VAR 0 2
 859: PPUSH
 860: CALL_OW 248
 864: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 865: LD_INT 0
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: LD_VAR 0 1
 875: PPUSH
 876: CALL_OW 380
// un = CreateHuman ;
 880: LD_ADDR_VAR 0 4
 884: PUSH
 885: CALL_OW 44
 889: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 890: LD_ADDR_VAR 0 5
 894: PUSH
 895: LD_VAR 0 2
 899: PPUSH
 900: CALL_OW 254
 904: PUSH
 905: LD_INT 3
 907: MINUS
 908: ST_TO_ADDR
// if dir < 0 then
 909: LD_VAR 0 5
 913: PUSH
 914: LD_INT 0
 916: LESS
 917: IFFALSE 933
// dir := 6 + dir ;
 919: LD_ADDR_VAR 0 5
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: LD_VAR 0 5
 931: PLUS
 932: ST_TO_ADDR
// SetDir ( un , dir ) ;
 933: LD_VAR 0 4
 937: PPUSH
 938: LD_VAR 0 5
 942: PPUSH
 943: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 947: LD_VAR 0 4
 951: PPUSH
 952: LD_VAR 0 2
 956: PPUSH
 957: CALL_OW 52
// end ;
 961: LD_VAR 0 3
 965: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 966: LD_INT 0
 968: PPUSH
 969: PPUSH
 970: PPUSH
// result := false ;
 971: LD_ADDR_VAR 0 2
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 979: LD_ADDR_VAR 0 3
 983: PUSH
 984: LD_INT 22
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: PUSH
 994: LD_INT 34
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: PPUSH
1008: CALL_OW 69
1012: ST_TO_ADDR
// for i in filter do
1013: LD_ADDR_VAR 0 4
1017: PUSH
1018: LD_VAR 0 3
1022: PUSH
1023: FOR_IN
1024: IFFALSE 1055
// if IsDrivenBy ( i ) = unit then
1026: LD_VAR 0 4
1030: PPUSH
1031: CALL_OW 311
1035: PUSH
1036: LD_VAR 0 1
1040: EQUAL
1041: IFFALSE 1053
// begin result := true ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 1
1050: ST_TO_ADDR
// break ;
1051: GO 1055
// end ;
1053: GO 1023
1055: POP
1056: POP
// end ;
1057: LD_VAR 0 2
1061: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1062: LD_INT 0
1064: PPUSH
1065: PPUSH
// result := false ;
1066: LD_ADDR_VAR 0 2
1070: PUSH
1071: LD_INT 0
1073: ST_TO_ADDR
// if not blist then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1127
// for i in blist do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: LD_VAR 0 1
1092: PUSH
1093: FOR_IN
1094: IFFALSE 1125
// if UnitsInside ( i ) < 6 then
1096: LD_VAR 0 3
1100: PPUSH
1101: CALL_OW 313
1105: PUSH
1106: LD_INT 6
1108: LESS
1109: IFFALSE 1123
// begin result := i ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 3
1120: ST_TO_ADDR
// break ;
1121: GO 1125
// end ;
1123: GO 1093
1125: POP
1126: POP
// end ;
1127: LD_VAR 0 2
1131: RET
// export function Count ( timer , mode ) ; begin
1132: LD_INT 0
1134: PPUSH
// if not timer then
1135: LD_VAR 0 1
1139: NOT
1140: IFFALSE 1144
// exit ;
1142: GO 1195
// if mode in [ asc , up , + ] then
1144: LD_VAR 0 2
1148: PUSH
1149: LD_STRING asc
1151: PUSH
1152: LD_STRING up
1154: PUSH
1155: LD_STRING +
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: IN
1163: IFFALSE 1181
// result := timer + 0 0$01 else
1165: LD_ADDR_VAR 0 3
1169: PUSH
1170: LD_VAR 0 1
1174: PUSH
1175: LD_INT 35
1177: PLUS
1178: ST_TO_ADDR
1179: GO 1195
// result := timer - 0 0$01 ;
1181: LD_ADDR_VAR 0 3
1185: PUSH
1186: LD_VAR 0 1
1190: PUSH
1191: LD_INT 35
1193: MINUS
1194: ST_TO_ADDR
// end ;
1195: LD_VAR 0 3
1199: RET
// export function Video ( mode ) ; begin
1200: LD_INT 0
1202: PPUSH
// ingame_video = mode ;
1203: LD_ADDR_OWVAR 52
1207: PUSH
1208: LD_VAR 0 1
1212: ST_TO_ADDR
// interface_hidden = mode ;
1213: LD_ADDR_OWVAR 54
1217: PUSH
1218: LD_VAR 0 1
1222: ST_TO_ADDR
// end ; end_of_file
1223: LD_VAR 0 2
1227: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1228: LD_INT 0
1230: PPUSH
1231: PPUSH
1232: PPUSH
1233: PPUSH
1234: PPUSH
1235: PPUSH
1236: PPUSH
1237: PPUSH
// uc_side := 4 ;
1238: LD_ADDR_OWVAR 20
1242: PUSH
1243: LD_INT 4
1245: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1246: LD_ADDR_EXP 46
1250: PUSH
1251: LD_STRING Powell
1253: PPUSH
1254: LD_INT 0
1256: PPUSH
1257: CALL 489 0 2
1261: ST_TO_ADDR
// uc_side := 1 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
// uc_nation := 1 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 1
1277: ST_TO_ADDR
// if debug then
1278: LD_EXP 1
1282: IFFALSE 1412
// begin for i = 1 to 4 do
1284: LD_ADDR_VAR 0 2
1288: PUSH
1289: DOUBLE
1290: LD_INT 1
1292: DEC
1293: ST_TO_ADDR
1294: LD_INT 4
1296: PUSH
1297: FOR_TO
1298: IFFALSE 1349
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1300: LD_INT 0
1302: PPUSH
1303: LD_INT 1
1305: PPUSH
1306: LD_INT 2
1308: PPUSH
1309: CALL_OW 12
1313: PPUSH
1314: LD_INT 3
1316: PPUSH
1317: CALL_OW 380
// un := CreateHuman ;
1321: LD_ADDR_VAR 0 3
1325: PUSH
1326: CALL_OW 44
1330: ST_TO_ADDR
// others := others ^ un ;
1331: LD_ADDR_VAR 0 5
1335: PUSH
1336: LD_VAR 0 5
1340: PUSH
1341: LD_VAR 0 3
1345: ADD
1346: ST_TO_ADDR
// end ;
1347: GO 1297
1349: POP
1350: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1351: LD_ADDR_VAR 0 6
1355: PUSH
1356: LD_INT 21
1358: PUSH
1359: LD_INT 1
1361: PUSH
1362: LD_INT 1
1364: PUSH
1365: LD_INT 51
1367: PUSH
1368: LD_INT 90
1370: PUSH
1371: LD_INT 504
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: PUSH
1382: LD_INT 21
1384: PUSH
1385: LD_INT 1
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: LD_INT 51
1393: PUSH
1394: LD_INT 80
1396: PUSH
1397: LD_INT 750
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1412: LD_ADDR_EXP 37
1416: PUSH
1417: LD_STRING JMM
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: CALL 489 0 2
1430: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1431: LD_ADDR_EXP 38
1435: PUSH
1436: LD_STRING Bobby
1438: PPUSH
1439: LD_EXP 1
1443: NOT
1444: PPUSH
1445: CALL 489 0 2
1449: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1450: LD_ADDR_EXP 39
1454: PUSH
1455: LD_STRING Cyrus
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: CALL 489 0 2
1468: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1469: LD_ADDR_EXP 40
1473: PUSH
1474: LD_STRING Lisa
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: CALL 489 0 2
1487: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1488: LD_ADDR_EXP 41
1492: PUSH
1493: LD_STRING Khatam
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: CALL 489 0 2
1506: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1507: LD_ADDR_EXP 42
1511: PUSH
1512: LD_STRING Brian
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: CALL 489 0 2
1525: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1526: LD_ADDR_EXP 43
1530: PUSH
1531: LD_STRING Jerry
1533: PPUSH
1534: LD_EXP 1
1538: NOT
1539: PPUSH
1540: CALL 489 0 2
1544: ST_TO_ADDR
// if Bobby then
1545: LD_EXP 38
1549: IFFALSE 1580
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1551: LD_ADDR_VAR 0 4
1555: PUSH
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 4
1565: PUSH
1566: LD_INT 1
1568: PLUS
1569: PPUSH
1570: LD_EXP 38
1574: PPUSH
1575: CALL_OW 2
1579: ST_TO_ADDR
// if Cyrus then
1580: LD_EXP 39
1584: IFFALSE 1615
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_VAR 0 4
1595: PPUSH
1596: LD_VAR 0 4
1600: PUSH
1601: LD_INT 1
1603: PLUS
1604: PPUSH
1605: LD_EXP 39
1609: PPUSH
1610: CALL_OW 2
1614: ST_TO_ADDR
// if Lisa then
1615: LD_EXP 40
1619: IFFALSE 1650
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1621: LD_ADDR_VAR 0 4
1625: PUSH
1626: LD_VAR 0 4
1630: PPUSH
1631: LD_VAR 0 4
1635: PUSH
1636: LD_INT 1
1638: PLUS
1639: PPUSH
1640: LD_EXP 40
1644: PPUSH
1645: CALL_OW 2
1649: ST_TO_ADDR
// if Khatam then
1650: LD_EXP 41
1654: IFFALSE 1685
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1656: LD_ADDR_VAR 0 4
1660: PUSH
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_VAR 0 4
1670: PUSH
1671: LD_INT 1
1673: PLUS
1674: PPUSH
1675: LD_EXP 41
1679: PPUSH
1680: CALL_OW 2
1684: ST_TO_ADDR
// if Brian then
1685: LD_EXP 42
1689: IFFALSE 1720
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_VAR 0 4
1700: PPUSH
1701: LD_VAR 0 4
1705: PUSH
1706: LD_INT 1
1708: PLUS
1709: PPUSH
1710: LD_EXP 42
1714: PPUSH
1715: CALL_OW 2
1719: ST_TO_ADDR
// if Jerry then
1720: LD_EXP 43
1724: IFFALSE 1755
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1726: LD_ADDR_VAR 0 4
1730: PUSH
1731: LD_VAR 0 4
1735: PPUSH
1736: LD_VAR 0 4
1740: PUSH
1741: LD_INT 1
1743: PLUS
1744: PPUSH
1745: LD_EXP 43
1749: PPUSH
1750: CALL_OW 2
1754: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1755: LD_STRING 02_other_survivors
1757: PPUSH
1758: CALL_OW 28
1762: IFFALSE 1777
// others := CreateCharacterSet ( 02_other_survivors ) ;
1764: LD_ADDR_VAR 0 5
1768: PUSH
1769: LD_STRING 02_other_survivors
1771: PPUSH
1772: CALL_OW 31
1776: ST_TO_ADDR
// if others then
1777: LD_VAR 0 5
1781: IFFALSE 1806
// begin tmp := tmp ^ others ;
1783: LD_ADDR_VAR 0 4
1787: PUSH
1788: LD_VAR 0 4
1792: PUSH
1793: LD_VAR 0 5
1797: ADD
1798: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1799: LD_STRING 02_other_survivors
1801: PPUSH
1802: CALL_OW 40
// end ; jmm_units := tmp ;
1806: LD_ADDR_EXP 4
1810: PUSH
1811: LD_VAR 0 4
1815: ST_TO_ADDR
// if not vehicles then
1816: LD_VAR 0 6
1820: NOT
1821: IFFALSE 1839
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1823: LD_ADDR_VAR 0 6
1827: PUSH
1828: LD_STRING 02_tanks_1
1830: PPUSH
1831: LD_INT 0
1833: PPUSH
1834: CALL_OW 30
1838: ST_TO_ADDR
// if vehicles then
1839: LD_VAR 0 6
1843: IFFALSE 2037
// begin got_mech := false ;
1845: LD_ADDR_VAR 0 7
1849: PUSH
1850: LD_INT 0
1852: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 3
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PPUSH
1868: CALL_OW 72
1872: IFFALSE 1882
// got_mech := true ;
1874: LD_ADDR_VAR 0 7
1878: PUSH
1879: LD_INT 1
1881: ST_TO_ADDR
// for i = 1 to vehicles do
1882: LD_ADDR_VAR 0 2
1886: PUSH
1887: DOUBLE
1888: LD_INT 1
1890: DEC
1891: ST_TO_ADDR
1892: LD_VAR 0 6
1896: PUSH
1897: FOR_TO
1898: IFFALSE 2035
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1900: LD_ADDR_VAR 0 3
1904: PUSH
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 3
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 2
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 3
1954: ARRAY
1955: PPUSH
1956: LD_VAR 0 6
1960: PUSH
1961: LD_VAR 0 2
1965: ARRAY
1966: PUSH
1967: LD_INT 4
1969: ARRAY
1970: PPUSH
1971: LD_INT 40
1973: PPUSH
1974: CALL 552 0 7
1978: ST_TO_ADDR
// if not got_mech then
1979: LD_VAR 0 7
1983: NOT
1984: IFFALSE 2010
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 6
1995: PUSH
1996: LD_VAR 0 2
2000: ARRAY
2001: PUSH
2002: LD_INT 6
2004: ARRAY
2005: PPUSH
2006: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
2010: LD_ADDR_VAR 0 4
2014: PUSH
2015: LD_VAR 0 4
2019: PPUSH
2020: LD_INT 1
2022: PPUSH
2023: LD_VAR 0 3
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
// end ;
2033: GO 1897
2035: POP
2036: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2037: LD_EXP 37
2041: PPUSH
2042: LD_INT 194
2044: PPUSH
2045: LD_INT 119
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 48
// if tmp then
2055: LD_VAR 0 4
2059: IFFALSE 2184
// begin for i in tmp do
2061: LD_ADDR_VAR 0 2
2065: PUSH
2066: LD_VAR 0 4
2070: PUSH
2071: FOR_IN
2072: IFFALSE 2182
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2074: LD_ADDR_VAR 0 8
2078: PUSH
2079: LD_INT 22
2081: PUSH
2082: LD_INT 1
2084: PUSH
2085: EMPTY
2086: LIST
2087: LIST
2088: PUSH
2089: LD_INT 21
2091: PUSH
2092: LD_INT 2
2094: PUSH
2095: EMPTY
2096: LIST
2097: LIST
2098: PUSH
2099: LD_INT 58
2101: PUSH
2102: EMPTY
2103: LIST
2104: PUSH
2105: EMPTY
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL_OW 69
2114: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2115: LD_VAR 0 2
2119: PPUSH
2120: CALL_OW 247
2124: PUSH
2125: LD_INT 1
2127: EQUAL
2128: PUSH
2129: LD_VAR 0 8
2133: AND
2134: IFFALSE 2156
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2136: LD_VAR 0 2
2140: PPUSH
2141: LD_VAR 0 8
2145: PUSH
2146: LD_INT 1
2148: ARRAY
2149: PPUSH
2150: CALL_OW 52
2154: GO 2171
// PlaceUnitArea ( i , startArea , false ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: LD_INT 1
2163: PPUSH
2164: LD_INT 0
2166: PPUSH
2167: CALL_OW 49
// ComHold ( i ) ;
2171: LD_VAR 0 2
2175: PPUSH
2176: CALL_OW 140
// end ;
2180: GO 2071
2182: POP
2183: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2184: LD_ADDR_EXP 7
2188: PUSH
2189: LD_STRING 02_mikhailStatus_1
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 30
2199: ST_TO_ADDR
// if not bierezov_exist and not debug then
2200: LD_EXP 7
2204: NOT
2205: PUSH
2206: LD_EXP 1
2210: NOT
2211: AND
2212: IFFALSE 2216
// exit ;
2214: GO 2247
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2216: LD_ADDR_EXP 45
2220: PUSH
2221: LD_STRING Mikhail
2223: PPUSH
2224: LD_INT 0
2226: PPUSH
2227: CALL 489 0 2
2231: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2232: LD_EXP 45
2236: PPUSH
2237: LD_INT 1
2239: PPUSH
2240: LD_INT 0
2242: PPUSH
2243: CALL_OW 49
// end ;
2247: LD_VAR 0 1
2251: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2252: LD_INT 0
2254: PPUSH
2255: PPUSH
2256: PPUSH
2257: PPUSH
// uc_side := 4 ;
2258: LD_ADDR_OWVAR 20
2262: PUSH
2263: LD_INT 4
2265: ST_TO_ADDR
// uc_nation := 1 ;
2266: LD_ADDR_OWVAR 21
2270: PUSH
2271: LD_INT 1
2273: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2274: LD_ADDR_EXP 44
2278: PUSH
2279: LD_STRING Cornell
2281: PPUSH
2282: LD_INT 0
2284: PPUSH
2285: CALL 489 0 2
2289: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2290: LD_ADDR_EXP 6
2294: PUSH
2295: LD_INT 9
2297: PUSH
2298: LD_EXP 4
2302: MINUS
2303: ST_TO_ADDR
// tmp := [ ] ;
2304: LD_ADDR_VAR 0 2
2308: PUSH
2309: EMPTY
2310: ST_TO_ADDR
// if cornel_units < 4 then
2311: LD_EXP 6
2315: PUSH
2316: LD_INT 4
2318: LESS
2319: IFFALSE 2329
// cornel_units := 4 ;
2321: LD_ADDR_EXP 6
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// for i = 1 to cornel_units do
2329: LD_ADDR_VAR 0 4
2333: PUSH
2334: DOUBLE
2335: LD_INT 1
2337: DEC
2338: ST_TO_ADDR
2339: LD_EXP 6
2343: PUSH
2344: FOR_TO
2345: IFFALSE 2443
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2347: LD_INT 0
2349: PPUSH
2350: LD_INT 1
2352: PUSH
2353: LD_INT 1
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 2
2361: PUSH
2362: LD_INT 4
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: PUSH
2372: LD_VAR 0 4
2376: PUSH
2377: LD_INT 5
2379: MOD
2380: PUSH
2381: LD_INT 1
2383: PLUS
2384: ARRAY
2385: PPUSH
2386: LD_INT 2
2388: PPUSH
2389: CALL_OW 380
// un := CreateHuman ;
2393: LD_ADDR_VAR 0 3
2397: PUSH
2398: CALL_OW 44
2402: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2403: LD_ADDR_VAR 0 2
2407: PUSH
2408: LD_VAR 0 2
2412: PPUSH
2413: LD_INT 1
2415: PPUSH
2416: LD_VAR 0 3
2420: PPUSH
2421: CALL_OW 2
2425: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2426: LD_VAR 0 3
2430: PPUSH
2431: LD_INT 2
2433: PPUSH
2434: LD_INT 0
2436: PPUSH
2437: CALL_OW 49
// end ;
2441: GO 2344
2443: POP
2444: POP
// cornel_units := tmp ;
2445: LD_ADDR_EXP 6
2449: PUSH
2450: LD_VAR 0 2
2454: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2455: LD_EXP 44
2459: PPUSH
2460: LD_INT 191
2462: PPUSH
2463: LD_INT 106
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL_OW 48
// end ;
2473: LD_VAR 0 1
2477: RET
// export function PrepareWesternBase ; var i ; begin
2478: LD_INT 0
2480: PPUSH
2481: PPUSH
// uc_side := 8 ;
2482: LD_ADDR_OWVAR 20
2486: PUSH
2487: LD_INT 8
2489: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2490: LD_ADDR_EXP 47
2494: PUSH
2495: LD_STRING Lynch
2497: PPUSH
2498: LD_INT 0
2500: PPUSH
2501: CALL 489 0 2
2505: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2506: LD_ADDR_EXP 48
2510: PUSH
2511: LD_STRING Walker
2513: PPUSH
2514: LD_INT 0
2516: PPUSH
2517: CALL 489 0 2
2521: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2522: LD_ADDR_EXP 49
2526: PUSH
2527: LD_STRING Turner
2529: PPUSH
2530: LD_INT 0
2532: PPUSH
2533: CALL 489 0 2
2537: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2538: LD_ADDR_EXP 50
2542: PUSH
2543: LD_STRING Jillian
2545: PPUSH
2546: LD_INT 0
2548: PPUSH
2549: CALL 489 0 2
2553: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2554: LD_ADDR_VAR 0 2
2558: PUSH
2559: LD_EXP 47
2563: PUSH
2564: LD_EXP 48
2568: PUSH
2569: LD_EXP 49
2573: PUSH
2574: LD_EXP 50
2578: PUSH
2579: EMPTY
2580: LIST
2581: LIST
2582: LIST
2583: LIST
2584: PUSH
2585: FOR_IN
2586: IFFALSE 2614
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: LD_INT 3
2595: PPUSH
2596: LD_INT 0
2598: PPUSH
2599: CALL_OW 49
// ComHold ( i ) ;
2603: LD_VAR 0 2
2607: PPUSH
2608: CALL_OW 140
// end ;
2612: GO 2585
2614: POP
2615: POP
// end ;
2616: LD_VAR 0 1
2620: RET
// export function SelectGroup ; var units , selected , i ; begin
2621: LD_INT 0
2623: PPUSH
2624: PPUSH
2625: PPUSH
2626: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_EXP 37
2636: PUSH
2637: LD_INT -3
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: PUSH
2644: LD_EXP 4
2648: ADD
2649: PUSH
2650: LD_INT -2
2652: PUSH
2653: LD_INT -4
2655: PUSH
2656: LD_EXP 44
2660: PUSH
2661: LD_EXP 45
2665: PUSH
2666: EMPTY
2667: LIST
2668: LIST
2669: LIST
2670: LIST
2671: ADD
2672: PUSH
2673: LD_INT -3
2675: PUSH
2676: EMPTY
2677: LIST
2678: ADD
2679: PUSH
2680: LD_EXP 6
2684: ADD
2685: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2686: LD_ADDR_VAR 0 3
2690: PUSH
2691: LD_EXP 37
2695: PUSH
2696: LD_STRING Select five characters to go with you
2698: PPUSH
2699: LD_INT 4
2701: PPUSH
2702: LD_INT 4
2704: PPUSH
2705: LD_VAR 0 2
2709: PPUSH
2710: EMPTY
2711: PPUSH
2712: CALL_OW 42
2716: ADD
2717: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2718: LD_ADDR_EXP 6
2722: PUSH
2723: LD_EXP 4
2727: PUSH
2728: LD_EXP 6
2732: UNION
2733: PUSH
2734: LD_VAR 0 3
2738: DIFF
2739: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2740: LD_ADDR_VAR 0 4
2744: PUSH
2745: LD_EXP 6
2749: PUSH
2750: LD_EXP 45
2754: ADD
2755: PUSH
2756: FOR_IN
2757: IFFALSE 2788
// if GetSide ( i ) = 1 then
2759: LD_VAR 0 4
2763: PPUSH
2764: CALL_OW 255
2768: PUSH
2769: LD_INT 1
2771: EQUAL
2772: IFFALSE 2786
// SetSide ( i , 4 ) ;
2774: LD_VAR 0 4
2778: PPUSH
2779: LD_INT 4
2781: PPUSH
2782: CALL_OW 235
2786: GO 2756
2788: POP
2789: POP
// for i in selected do
2790: LD_ADDR_VAR 0 4
2794: PUSH
2795: LD_VAR 0 3
2799: PUSH
2800: FOR_IN
2801: IFFALSE 2832
// if GetSide ( i ) = 4 then
2803: LD_VAR 0 4
2807: PPUSH
2808: CALL_OW 255
2812: PUSH
2813: LD_INT 4
2815: EQUAL
2816: IFFALSE 2830
// SetSide ( i , 1 ) ;
2818: LD_VAR 0 4
2822: PPUSH
2823: LD_INT 1
2825: PPUSH
2826: CALL_OW 235
2830: GO 2800
2832: POP
2833: POP
// jmm_units := jmm_units diff cornel_units ;
2834: LD_ADDR_EXP 4
2838: PUSH
2839: LD_EXP 4
2843: PUSH
2844: LD_EXP 6
2848: DIFF
2849: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2850: LD_EXP 38
2854: PPUSH
2855: CALL_OW 255
2859: PUSH
2860: LD_INT 4
2862: EQUAL
2863: IFFALSE 2878
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2865: LD_EXP 3
2869: PUSH
2870: LD_STRING Bobby
2872: STR
2873: PPUSH
2874: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2878: LD_EXP 39
2882: PPUSH
2883: CALL_OW 255
2887: PUSH
2888: LD_INT 4
2890: EQUAL
2891: IFFALSE 2906
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2893: LD_EXP 3
2897: PUSH
2898: LD_STRING Cyrus
2900: STR
2901: PPUSH
2902: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2906: LD_EXP 40
2910: PPUSH
2911: CALL_OW 255
2915: PUSH
2916: LD_INT 4
2918: EQUAL
2919: IFFALSE 2934
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2921: LD_EXP 3
2925: PUSH
2926: LD_STRING Lisa
2928: STR
2929: PPUSH
2930: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2934: LD_EXP 41
2938: PPUSH
2939: CALL_OW 255
2943: PUSH
2944: LD_INT 4
2946: EQUAL
2947: IFFALSE 2962
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2949: LD_EXP 3
2953: PUSH
2954: LD_STRING Khatam
2956: STR
2957: PPUSH
2958: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2962: LD_EXP 42
2966: PPUSH
2967: CALL_OW 255
2971: PUSH
2972: LD_INT 4
2974: EQUAL
2975: IFFALSE 2990
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2977: LD_EXP 3
2981: PUSH
2982: LD_STRING Brian
2984: STR
2985: PPUSH
2986: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2990: LD_EXP 43
2994: PPUSH
2995: CALL_OW 255
2999: PUSH
3000: LD_INT 4
3002: EQUAL
3003: IFFALSE 3018
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
3005: LD_EXP 3
3009: PUSH
3010: LD_STRING Jerry
3012: STR
3013: PPUSH
3014: CALL_OW 40
// end ; end_of_file
3018: LD_VAR 0 1
3022: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3023: LD_INT 0
3025: PPUSH
3026: PPUSH
3027: PPUSH
3028: PPUSH
3029: PPUSH
3030: PPUSH
3031: PPUSH
3032: PPUSH
3033: PPUSH
3034: PPUSH
3035: PPUSH
3036: PPUSH
3037: PPUSH
// ru_alert := false ;
3038: LD_ADDR_EXP 60
3042: PUSH
3043: LD_INT 0
3045: ST_TO_ADDR
// ru_produce_list := [ ] ;
3046: LD_ADDR_EXP 57
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if Difficulty > 1 then
3053: LD_OWVAR 67
3057: PUSH
3058: LD_INT 1
3060: GREATER
3061: IFFALSE 3149
// begin uc_side := 3 ;
3063: LD_ADDR_OWVAR 20
3067: PUSH
3068: LD_INT 3
3070: ST_TO_ADDR
// uc_nation := 3 ;
3071: LD_ADDR_OWVAR 21
3075: PUSH
3076: LD_INT 3
3078: ST_TO_ADDR
// bc_type := b_breastwork ;
3079: LD_ADDR_OWVAR 42
3083: PUSH
3084: LD_INT 31
3086: ST_TO_ADDR
// bc_level := Difficulty ;
3087: LD_ADDR_OWVAR 43
3091: PUSH
3092: LD_OWVAR 67
3096: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3097: LD_INT 22
3099: PPUSH
3100: LD_INT 14
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3110: LD_INT 48
3112: PPUSH
3113: LD_INT 46
3115: PPUSH
3116: LD_INT 0
3118: PPUSH
3119: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3123: LD_INT 86
3125: PPUSH
3126: LD_INT 65
3128: PPUSH
3129: LD_INT 5
3131: PPUSH
3132: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3136: LD_INT 165
3138: PPUSH
3139: LD_INT 73
3141: PPUSH
3142: LD_INT 5
3144: PPUSH
3145: CALL_OW 47
// end ; if Difficulty = 3 then
3149: LD_OWVAR 67
3153: PUSH
3154: LD_INT 3
3156: EQUAL
3157: IFFALSE 3172
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3159: LD_INT 51
3161: PPUSH
3162: LD_INT 3
3164: PPUSH
3165: LD_INT 2
3167: PPUSH
3168: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3172: LD_ADDR_VAR 0 7
3176: PUSH
3177: LD_INT 22
3179: PUSH
3180: LD_INT 3
3182: PUSH
3183: EMPTY
3184: LIST
3185: LIST
3186: PUSH
3187: LD_INT 2
3189: PUSH
3190: LD_INT 30
3192: PUSH
3193: LD_INT 31
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 30
3202: PUSH
3203: LD_INT 32
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: LIST
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: PPUSH
3219: CALL_OW 69
3223: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3224: LD_ADDR_VAR 0 8
3228: PUSH
3229: LD_INT 22
3231: PUSH
3232: LD_INT 3
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: PUSH
3239: LD_INT 30
3241: PUSH
3242: LD_INT 4
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PPUSH
3253: CALL_OW 69
3257: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3258: LD_ADDR_VAR 0 10
3262: PUSH
3263: LD_INT 22
3265: PUSH
3266: LD_INT 3
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: PUSH
3273: LD_INT 30
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: EMPTY
3280: LIST
3281: LIST
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: PPUSH
3287: CALL_OW 69
3291: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3292: LD_ADDR_VAR 0 9
3296: PUSH
3297: LD_INT 22
3299: PUSH
3300: LD_INT 3
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 30
3309: PUSH
3310: LD_INT 6
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: PPUSH
3321: CALL_OW 69
3325: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_INT 22
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: PUSH
3341: LD_INT 30
3343: PUSH
3344: LD_INT 1
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: PPUSH
3355: CALL_OW 69
3359: PUSH
3360: FOR_IN
3361: IFFALSE 3405
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3363: LD_VAR 0 2
3367: PPUSH
3368: CALL_OW 274
3372: PPUSH
3373: LD_INT 1
3375: PPUSH
3376: LD_INT 5000
3378: PPUSH
3379: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3383: LD_VAR 0 2
3387: PPUSH
3388: CALL_OW 274
3392: PPUSH
3393: LD_INT 2
3395: PPUSH
3396: LD_INT 3000
3398: PPUSH
3399: CALL_OW 277
// end ;
3403: GO 3360
3405: POP
3406: POP
// uc_side := 3 ;
3407: LD_ADDR_OWVAR 20
3411: PUSH
3412: LD_INT 3
3414: ST_TO_ADDR
// uc_nation := 3 ;
3415: LD_ADDR_OWVAR 21
3419: PUSH
3420: LD_INT 3
3422: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3423: LD_ADDR_VAR 0 11
3427: PUSH
3428: LD_INT 2
3430: PUSH
3431: LD_INT 3
3433: PUSH
3434: LD_INT 4
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: LIST
3441: PUSH
3442: LD_OWVAR 67
3446: ARRAY
3447: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3448: LD_ADDR_EXP 52
3452: PUSH
3453: LD_STRING Pokryshkin
3455: PPUSH
3456: LD_INT 0
3458: PPUSH
3459: CALL 489 0 2
3463: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3464: LD_EXP 52
3468: PPUSH
3469: LD_INT 63
3471: PPUSH
3472: LD_INT 21
3474: PPUSH
3475: LD_INT 0
3477: PPUSH
3478: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3482: LD_EXP 52
3486: PPUSH
3487: CALL_OW 140
// InitHc ;
3491: CALL_OW 19
// for i in fac do
3495: LD_ADDR_VAR 0 2
3499: PUSH
3500: LD_VAR 0 10
3504: PUSH
3505: FOR_IN
3506: IFFALSE 3559
// begin for j = 1 to 6 do
3508: LD_ADDR_VAR 0 3
3512: PUSH
3513: DOUBLE
3514: LD_INT 1
3516: DEC
3517: ST_TO_ADDR
3518: LD_INT 6
3520: PUSH
3521: FOR_TO
3522: IFFALSE 3555
// begin PrepareHuman ( false , 3 , skill ) ;
3524: LD_INT 0
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_VAR 0 11
3534: PPUSH
3535: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3539: CALL_OW 44
3543: PPUSH
3544: LD_VAR 0 2
3548: PPUSH
3549: CALL_OW 52
// end ;
3553: GO 3521
3555: POP
3556: POP
// end ;
3557: GO 3505
3559: POP
3560: POP
// for i in lab do
3561: LD_ADDR_VAR 0 2
3565: PUSH
3566: LD_VAR 0 9
3570: PUSH
3571: FOR_IN
3572: IFFALSE 3605
// begin PrepareHuman ( false , 4 , skill ) ;
3574: LD_INT 0
3576: PPUSH
3577: LD_INT 4
3579: PPUSH
3580: LD_VAR 0 11
3584: PPUSH
3585: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3589: CALL_OW 44
3593: PPUSH
3594: LD_VAR 0 2
3598: PPUSH
3599: CALL_OW 52
// end ;
3603: GO 3571
3605: POP
3606: POP
// for i in tw do
3607: LD_ADDR_VAR 0 2
3611: PUSH
3612: LD_VAR 0 7
3616: PUSH
3617: FOR_IN
3618: IFFALSE 3667
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3620: LD_VAR 0 2
3624: PPUSH
3625: LD_INT 42
3627: PUSH
3628: LD_INT 43
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 1
3637: PPUSH
3638: LD_INT 2
3640: PPUSH
3641: CALL_OW 12
3645: ARRAY
3646: PPUSH
3647: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3651: LD_VAR 0 11
3655: PPUSH
3656: LD_VAR 0 2
3660: PPUSH
3661: CALL 830 0 2
// end ;
3665: GO 3617
3667: POP
3668: POP
// for i in bar do
3669: LD_ADDR_VAR 0 2
3673: PUSH
3674: LD_VAR 0 8
3678: PUSH
3679: FOR_IN
3680: IFFALSE 3713
// begin PrepareHuman ( false , 1 , skill ) ;
3682: LD_INT 0
3684: PPUSH
3685: LD_INT 1
3687: PPUSH
3688: LD_VAR 0 11
3692: PPUSH
3693: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3697: CALL_OW 44
3701: PPUSH
3702: LD_VAR 0 2
3706: PPUSH
3707: CALL_OW 52
// end ;
3711: GO 3679
3713: POP
3714: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3715: LD_ADDR_VAR 0 13
3719: PUSH
3720: LD_INT 100
3722: PUSH
3723: LD_INT 9
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: PUSH
3730: LD_INT 135
3732: PUSH
3733: LD_INT 60
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 41
3742: PUSH
3743: LD_INT 6
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 22
3752: PUSH
3753: LD_INT 9
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PUSH
3760: LD_INT 84
3762: PUSH
3763: LD_INT 14
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: LIST
3774: LIST
3775: LIST
3776: ST_TO_ADDR
// vehicles := [ ] ;
3777: LD_ADDR_VAR 0 12
3781: PUSH
3782: EMPTY
3783: ST_TO_ADDR
// for i in spot_xy do
3784: LD_ADDR_VAR 0 2
3788: PUSH
3789: LD_VAR 0 13
3793: PUSH
3794: FOR_IN
3795: IFFALSE 3953
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3797: LD_ADDR_VAR 0 6
3801: PUSH
3802: LD_INT 3
3804: PPUSH
3805: LD_INT 3
3807: PPUSH
3808: LD_INT 22
3810: PPUSH
3811: LD_INT 1
3813: PPUSH
3814: LD_INT 1
3816: PPUSH
3817: LD_INT 42
3819: PUSH
3820: LD_INT 43
3822: PUSH
3823: LD_INT 44
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: LIST
3830: PUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 12
3841: ARRAY
3842: PPUSH
3843: LD_INT 100
3845: PPUSH
3846: CALL 552 0 7
3850: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3851: LD_ADDR_VAR 0 12
3855: PUSH
3856: LD_VAR 0 12
3860: PPUSH
3861: LD_VAR 0 12
3865: PUSH
3866: LD_INT 1
3868: PLUS
3869: PPUSH
3870: LD_VAR 0 6
3874: PPUSH
3875: CALL_OW 2
3879: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3880: LD_VAR 0 6
3884: PPUSH
3885: LD_INT 3
3887: PPUSH
3888: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3892: LD_VAR 0 6
3896: PPUSH
3897: LD_VAR 0 2
3901: PUSH
3902: LD_INT 1
3904: ARRAY
3905: PPUSH
3906: LD_VAR 0 2
3910: PUSH
3911: LD_INT 2
3913: ARRAY
3914: PPUSH
3915: LD_INT 0
3917: PPUSH
3918: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 3
3927: PPUSH
3928: LD_VAR 0 11
3932: PPUSH
3933: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3937: CALL_OW 44
3941: PPUSH
3942: LD_VAR 0 6
3946: PPUSH
3947: CALL_OW 52
// end ;
3951: GO 3794
3953: POP
3954: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3955: LD_ADDR_VAR 0 2
3959: PUSH
3960: DOUBLE
3961: LD_INT 1
3963: DEC
3964: ST_TO_ADDR
3965: LD_INT 5
3967: PUSH
3968: LD_INT 7
3970: PUSH
3971: LD_INT 8
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: LIST
3978: PUSH
3979: LD_OWVAR 67
3983: ARRAY
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4046
// begin PrepareHuman ( false , 1 , skill ) ;
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 1
3993: PPUSH
3994: LD_VAR 0 11
3998: PPUSH
3999: CALL_OW 380
// un := CreateHuman ;
4003: LD_ADDR_VAR 0 5
4007: PUSH
4008: CALL_OW 44
4012: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
4013: LD_VAR 0 5
4017: PPUSH
4018: LD_INT 11
4020: PPUSH
4021: LD_INT 0
4023: PPUSH
4024: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4028: LD_ADDR_EXP 55
4032: PUSH
4033: LD_EXP 55
4037: PUSH
4038: LD_VAR 0 5
4042: ADD
4043: ST_TO_ADDR
// end ;
4044: GO 3985
4046: POP
4047: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4048: LD_ADDR_VAR 0 2
4052: PUSH
4053: DOUBLE
4054: LD_INT 1
4056: DEC
4057: ST_TO_ADDR
4058: LD_INT 2
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PUSH
4072: LD_OWVAR 67
4076: ARRAY
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4139
// begin PrepareHuman ( false , 1 , skill ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 1
4086: PPUSH
4087: LD_VAR 0 11
4091: PPUSH
4092: CALL_OW 380
// un := CreateHuman ;
4096: LD_ADDR_VAR 0 5
4100: PUSH
4101: CALL_OW 44
4105: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4106: LD_VAR 0 5
4110: PPUSH
4111: LD_INT 12
4113: PPUSH
4114: LD_INT 0
4116: PPUSH
4117: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4121: LD_ADDR_EXP 53
4125: PUSH
4126: LD_EXP 53
4130: PUSH
4131: LD_VAR 0 5
4135: ADD
4136: ST_TO_ADDR
// end ;
4137: GO 4078
4139: POP
4140: POP
// for i = 1 to 2 do
4141: LD_ADDR_VAR 0 2
4145: PUSH
4146: DOUBLE
4147: LD_INT 1
4149: DEC
4150: ST_TO_ADDR
4151: LD_INT 2
4153: PUSH
4154: FOR_TO
4155: IFFALSE 4221
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4157: LD_INT 1
4159: PPUSH
4160: LD_INT 1
4162: PPUSH
4163: LD_VAR 0 11
4167: PPUSH
4168: CALL_OW 380
// un := CreateHuman ;
4172: LD_ADDR_VAR 0 5
4176: PUSH
4177: CALL_OW 44
4181: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4182: LD_VAR 0 5
4186: PPUSH
4187: LD_INT 39
4189: PPUSH
4190: LD_INT 12
4192: PPUSH
4193: LD_INT 3
4195: PPUSH
4196: LD_INT 0
4198: PPUSH
4199: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4203: LD_ADDR_EXP 54
4207: PUSH
4208: LD_EXP 54
4212: PUSH
4213: LD_VAR 0 5
4217: ADD
4218: ST_TO_ADDR
// end ;
4219: GO 4154
4221: POP
4222: POP
// for i = 1 to 3 do
4223: LD_ADDR_VAR 0 2
4227: PUSH
4228: DOUBLE
4229: LD_INT 1
4231: DEC
4232: ST_TO_ADDR
4233: LD_INT 3
4235: PUSH
4236: FOR_TO
4237: IFFALSE 4303
// begin PrepareHuman ( false , 1 , skill ) ;
4239: LD_INT 0
4241: PPUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_VAR 0 11
4249: PPUSH
4250: CALL_OW 380
// un := CreateHuman ;
4254: LD_ADDR_VAR 0 5
4258: PUSH
4259: CALL_OW 44
4263: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4264: LD_VAR 0 5
4268: PPUSH
4269: LD_INT 180
4271: PPUSH
4272: LD_INT 11
4274: PPUSH
4275: LD_INT 4
4277: PPUSH
4278: LD_INT 0
4280: PPUSH
4281: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4285: LD_ADDR_EXP 58
4289: PUSH
4290: LD_EXP 58
4294: PUSH
4295: LD_VAR 0 5
4299: ADD
4300: ST_TO_ADDR
// end ;
4301: GO 4236
4303: POP
4304: POP
// ru_vehicles := vehicles ;
4305: LD_ADDR_EXP 56
4309: PUSH
4310: LD_VAR 0 12
4314: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: LD_INT 131
4322: PUSH
4323: LD_INT 121
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: PUSH
4330: LD_INT 113
4332: PUSH
4333: LD_INT 90
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 93
4342: PUSH
4343: LD_INT 62
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: LIST
4354: PUSH
4355: LD_INT 106
4357: PUSH
4358: LD_INT 54
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: PUSH
4365: LD_INT 120
4367: PUSH
4368: LD_INT 80
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 143
4377: PUSH
4378: LD_INT 120
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: LIST
4389: PUSH
4390: LD_INT 154
4392: PUSH
4393: LD_INT 116
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PUSH
4400: LD_INT 140
4402: PUSH
4403: LD_INT 93
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 130
4412: PUSH
4413: LD_INT 58
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 105
4427: PUSH
4428: LD_INT 106
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 134
4437: PUSH
4438: LD_INT 98
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PUSH
4445: LD_INT 159
4447: PUSH
4448: LD_INT 113
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PUSH
4455: EMPTY
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: LIST
4464: LIST
4465: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4466: LD_ADDR_VAR 0 2
4470: PUSH
4471: DOUBLE
4472: LD_INT 1
4474: DEC
4475: ST_TO_ADDR
4476: LD_OWVAR 67
4480: PUSH
4481: LD_INT 1
4483: MINUS
4484: PUSH
4485: FOR_TO
4486: IFFALSE 4519
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4488: LD_ADDR_EXP 57
4492: PUSH
4493: LD_EXP 57
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 1
4503: PUSH
4504: LD_INT 1
4506: PUSH
4507: LD_INT 43
4509: PUSH
4510: EMPTY
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: ADD
4516: ST_TO_ADDR
4517: GO 4485
4519: POP
4520: POP
// end ;
4521: LD_VAR 0 1
4525: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4526: LD_INT 22
4528: PUSH
4529: LD_INT 3
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: LD_INT 21
4538: PUSH
4539: LD_INT 2
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: IFFALSE 4648
4556: GO 4558
4558: DISABLE
4559: LD_INT 0
4561: PPUSH
4562: PPUSH
// begin enable ;
4563: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4564: LD_ADDR_VAR 0 2
4568: PUSH
4569: LD_INT 22
4571: PUSH
4572: LD_INT 3
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 21
4581: PUSH
4582: LD_INT 2
4584: PUSH
4585: EMPTY
4586: LIST
4587: LIST
4588: PUSH
4589: EMPTY
4590: LIST
4591: LIST
4592: PPUSH
4593: CALL_OW 69
4597: ST_TO_ADDR
// if filter then
4598: LD_VAR 0 2
4602: IFFALSE 4648
// for i in filter do
4604: LD_ADDR_VAR 0 1
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: FOR_IN
4615: IFFALSE 4646
// if GetFuel ( i ) < 20 then
4617: LD_VAR 0 1
4621: PPUSH
4622: CALL_OW 261
4626: PUSH
4627: LD_INT 20
4629: LESS
4630: IFFALSE 4644
// SetFuel ( i , 20 ) ;
4632: LD_VAR 0 1
4636: PPUSH
4637: LD_INT 20
4639: PPUSH
4640: CALL_OW 240
4644: GO 4614
4646: POP
4647: POP
// end ;
4648: PPOPN 2
4650: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4651: LD_EXP 57
4655: IFFALSE 4874
4657: GO 4659
4659: DISABLE
4660: LD_INT 0
4662: PPUSH
4663: PPUSH
4664: PPUSH
// begin enable ;
4665: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4666: LD_ADDR_VAR 0 2
4670: PUSH
4671: LD_INT 22
4673: PUSH
4674: LD_INT 3
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PUSH
4681: LD_INT 30
4683: PUSH
4684: LD_INT 3
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PPUSH
4695: CALL_OW 69
4699: ST_TO_ADDR
// can_produce := [ ] ;
4700: LD_ADDR_VAR 0 3
4704: PUSH
4705: EMPTY
4706: ST_TO_ADDR
// if not fac then
4707: LD_VAR 0 2
4711: NOT
4712: IFFALSE 4717
// begin disable ;
4714: DISABLE
// exit ;
4715: GO 4874
// end ; for i in fac do
4717: LD_ADDR_VAR 0 1
4721: PUSH
4722: LD_VAR 0 2
4726: PUSH
4727: FOR_IN
4728: IFFALSE 4766
// if UnitsInside ( i ) then
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 313
4739: IFFALSE 4764
// can_produce := Insert ( can_produce , 1 , i ) ;
4741: LD_ADDR_VAR 0 3
4745: PUSH
4746: LD_VAR 0 3
4750: PPUSH
4751: LD_INT 1
4753: PPUSH
4754: LD_VAR 0 1
4758: PPUSH
4759: CALL_OW 2
4763: ST_TO_ADDR
4764: GO 4727
4766: POP
4767: POP
// if not can_produce then
4768: LD_VAR 0 3
4772: NOT
4773: IFFALSE 4777
// exit ;
4775: GO 4874
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4777: LD_VAR 0 3
4781: PUSH
4782: LD_INT 1
4784: PPUSH
4785: LD_VAR 0 3
4789: PPUSH
4790: CALL_OW 12
4794: ARRAY
4795: PPUSH
4796: LD_EXP 57
4800: PUSH
4801: LD_INT 1
4803: ARRAY
4804: PPUSH
4805: LD_EXP 57
4809: PUSH
4810: LD_INT 2
4812: ARRAY
4813: PPUSH
4814: LD_EXP 57
4818: PUSH
4819: LD_INT 3
4821: ARRAY
4822: PPUSH
4823: LD_EXP 57
4827: PUSH
4828: LD_INT 4
4830: ARRAY
4831: PPUSH
4832: CALL_OW 125
// for i = 1 to 4 do
4836: LD_ADDR_VAR 0 1
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_INT 4
4848: PUSH
4849: FOR_TO
4850: IFFALSE 4872
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4852: LD_ADDR_EXP 57
4856: PUSH
4857: LD_EXP 57
4861: PPUSH
4862: LD_INT 1
4864: PPUSH
4865: CALL_OW 3
4869: ST_TO_ADDR
4870: GO 4849
4872: POP
4873: POP
// end ;
4874: PPOPN 3
4876: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4877: LD_INT 0
4879: PPUSH
4880: PPUSH
4881: PPUSH
// for i = 1 to 6 do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: DOUBLE
4888: LD_INT 1
4890: DEC
4891: ST_TO_ADDR
4892: LD_INT 6
4894: PUSH
4895: FOR_TO
4896: IFFALSE 5045
// begin PrepareHuman ( false , 3 , 3 ) ;
4898: LD_INT 0
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_INT 3
4918: PPUSH
4919: LD_INT 3
4921: PPUSH
4922: LD_INT 22
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 1
4930: PPUSH
4931: LD_INT 43
4933: PUSH
4934: LD_INT 42
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: PUSH
4941: LD_INT 1
4943: PPUSH
4944: LD_INT 2
4946: PPUSH
4947: CALL_OW 12
4951: ARRAY
4952: PPUSH
4953: LD_INT 70
4955: PPUSH
4956: CALL 552 0 7
4960: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4961: LD_VAR 0 3
4965: PPUSH
4966: LD_INT 4
4968: PPUSH
4969: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4973: LD_VAR 0 3
4977: PPUSH
4978: LD_INT 229
4980: PPUSH
4981: LD_INT 44
4983: PPUSH
4984: LD_INT 0
4986: PPUSH
4987: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4991: CALL_OW 44
4995: PPUSH
4996: LD_VAR 0 3
5000: PPUSH
5001: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
5005: LD_ADDR_EXP 56
5009: PUSH
5010: LD_EXP 56
5014: PUSH
5015: LD_VAR 0 3
5019: ADD
5020: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5021: LD_VAR 0 3
5025: PPUSH
5026: LD_INT 191
5028: PPUSH
5029: LD_INT 32
5031: PPUSH
5032: CALL_OW 111
// Wait ( 0 0$02 ) ;
5036: LD_INT 70
5038: PPUSH
5039: CALL_OW 67
// end ;
5043: GO 4895
5045: POP
5046: POP
// end ;
5047: LD_VAR 0 1
5051: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5052: LD_EXP 31
5056: PUSH
5057: LD_EXP 56
5061: AND
5062: IFFALSE 5236
5064: GO 5066
5066: DISABLE
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin wait ( 0 0$50 ) ;
5072: LD_INT 1750
5074: PPUSH
5075: CALL_OW 67
// tmp := ru_vehicles ;
5079: LD_ADDR_VAR 0 3
5083: PUSH
5084: LD_EXP 56
5088: ST_TO_ADDR
// if not tmp then
5089: LD_VAR 0 3
5093: NOT
5094: IFFALSE 5098
// exit ;
5096: GO 5236
// repeat wait ( 0 0$1 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// for i in tmp do
5105: LD_ADDR_VAR 0 1
5109: PUSH
5110: LD_VAR 0 3
5114: PUSH
5115: FOR_IN
5116: IFFALSE 5227
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5118: LD_ADDR_VAR 0 2
5122: PUSH
5123: LD_INT 22
5125: PUSH
5126: LD_INT 1
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PPUSH
5133: LD_VAR 0 1
5137: PPUSH
5138: CALL_OW 74
5142: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5143: LD_VAR 0 1
5147: PPUSH
5148: LD_VAR 0 2
5152: PPUSH
5153: CALL_OW 296
5157: PUSH
5158: LD_INT 10
5160: GREATER
5161: IFFALSE 5180
// ComAgressiveMove ( i , 69 , 101 ) else
5163: LD_VAR 0 1
5167: PPUSH
5168: LD_INT 69
5170: PPUSH
5171: LD_INT 101
5173: PPUSH
5174: CALL_OW 114
5178: GO 5194
// ComAttackUnit ( i , enemy ) ;
5180: LD_VAR 0 1
5184: PPUSH
5185: LD_VAR 0 2
5189: PPUSH
5190: CALL_OW 115
// if GetLives ( i ) < 250 then
5194: LD_VAR 0 1
5198: PPUSH
5199: CALL_OW 256
5203: PUSH
5204: LD_INT 250
5206: LESS
5207: IFFALSE 5225
// tmp := tmp diff i ;
5209: LD_ADDR_VAR 0 3
5213: PUSH
5214: LD_VAR 0 3
5218: PUSH
5219: LD_VAR 0 1
5223: DIFF
5224: ST_TO_ADDR
// end ;
5225: GO 5115
5227: POP
5228: POP
// until not tmp ;
5229: LD_VAR 0 3
5233: NOT
5234: IFFALSE 5098
// end ; end_of_file
5236: PPOPN 3
5238: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5239: LD_INT 0
5241: PPUSH
5242: PPUSH
5243: PPUSH
5244: PPUSH
5245: PPUSH
5246: PPUSH
5247: PPUSH
// InGameOn ;
5248: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5252: LD_EXP 37
5256: PPUSH
5257: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5261: LD_EXP 37
5265: PPUSH
5266: LD_EXP 44
5270: PPUSH
5271: CALL_OW 119
// if Bierezov then
5275: LD_EXP 45
5279: IFFALSE 5295
// ComTurnUnit ( Bierezov , Cornel ) ;
5281: LD_EXP 45
5285: PPUSH
5286: LD_EXP 44
5290: PPUSH
5291: CALL_OW 119
// for i in jmm_units do
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: LD_EXP 4
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5324
// ComTurnUnit ( i , Cornel ) ;
5308: LD_VAR 0 2
5312: PPUSH
5313: LD_EXP 44
5317: PPUSH
5318: CALL_OW 119
5322: GO 5305
5324: POP
5325: POP
// units := cornel_units union Cornel ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: LD_EXP 6
5335: PUSH
5336: LD_EXP 44
5340: UNION
5341: ST_TO_ADDR
// repeat wait ( 1 ) ;
5342: LD_INT 1
5344: PPUSH
5345: CALL_OW 67
// for i in units do
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: LD_VAR 0 3
5358: PUSH
5359: FOR_IN
5360: IFFALSE 5393
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5362: LD_VAR 0 2
5366: PPUSH
5367: LD_EXP 37
5371: PPUSH
5372: CALL_OW 250
5376: PPUSH
5377: LD_EXP 37
5381: PPUSH
5382: CALL_OW 251
5386: PPUSH
5387: CALL_OW 111
5391: GO 5359
5393: POP
5394: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5395: LD_VAR 0 3
5399: PPUSH
5400: LD_INT 92
5402: PUSH
5403: LD_EXP 37
5407: PPUSH
5408: CALL_OW 250
5412: PUSH
5413: LD_EXP 37
5417: PPUSH
5418: CALL_OW 251
5422: PUSH
5423: LD_INT 10
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: PPUSH
5432: CALL_OW 72
5436: PUSH
5437: LD_VAR 0 3
5441: EQUAL
5442: IFFALSE 5342
// for i in units do
5444: LD_ADDR_VAR 0 2
5448: PUSH
5449: LD_VAR 0 3
5453: PUSH
5454: FOR_IN
5455: IFFALSE 5473
// ComTurnUnit ( i , JMM ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_EXP 37
5466: PPUSH
5467: CALL_OW 119
5471: GO 5454
5473: POP
5474: POP
// ComTurnUnit ( Cornel , JMM ) ;
5475: LD_EXP 44
5479: PPUSH
5480: LD_EXP 37
5484: PPUSH
5485: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5489: LD_EXP 37
5493: PPUSH
5494: LD_STRING D1-JMM-1
5496: PPUSH
5497: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5501: LD_EXP 44
5505: PPUSH
5506: LD_STRING D1-Corn-1
5508: PPUSH
5509: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5513: LD_EXP 37
5517: PPUSH
5518: LD_EXP 44
5522: PPUSH
5523: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5527: LD_EXP 44
5531: PPUSH
5532: LD_EXP 37
5536: PPUSH
5537: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5541: LD_INT 35
5543: PPUSH
5544: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5548: LD_EXP 37
5552: PPUSH
5553: LD_EXP 44
5557: PPUSH
5558: CALL_OW 296
5562: PUSH
5563: LD_INT 6
5565: LESS
5566: IFFALSE 5541
// ChangeSideFog ( 4 , 1 ) ;
5568: LD_INT 4
5570: PPUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5578: LD_EXP 37
5582: PPUSH
5583: LD_EXP 44
5587: PPUSH
5588: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5592: LD_EXP 44
5596: PPUSH
5597: LD_EXP 37
5601: PPUSH
5602: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5606: LD_EXP 37
5610: PPUSH
5611: LD_STRING D1-JMM-2
5613: PPUSH
5614: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5618: LD_EXP 37
5622: PPUSH
5623: LD_STRING D1-JMM-2a
5625: PPUSH
5626: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5630: LD_EXP 44
5634: PPUSH
5635: LD_STRING D1-Corn-2
5637: PPUSH
5638: CALL_OW 88
// if bierezov_exist or debug then
5642: LD_EXP 7
5646: PUSH
5647: LD_EXP 1
5651: OR
5652: IFFALSE 5893
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5654: LD_EXP 44
5658: PPUSH
5659: LD_EXP 45
5663: PPUSH
5664: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5668: LD_INT 10
5670: PPUSH
5671: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5675: LD_EXP 44
5679: PPUSH
5680: LD_STRING D1a-Corn-1
5682: PPUSH
5683: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5687: LD_EXP 37
5691: PPUSH
5692: LD_EXP 45
5696: PPUSH
5697: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5701: LD_EXP 45
5705: PPUSH
5706: LD_EXP 37
5710: PPUSH
5711: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5715: LD_EXP 37
5719: PPUSH
5720: LD_STRING D1a-JMM-1
5722: PPUSH
5723: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5727: LD_EXP 37
5731: PPUSH
5732: LD_EXP 44
5736: PPUSH
5737: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5741: LD_EXP 44
5745: PPUSH
5746: LD_EXP 37
5750: PPUSH
5751: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5755: LD_EXP 44
5759: PPUSH
5760: LD_STRING D1a-Corn-2
5762: PPUSH
5763: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5767: LD_EXP 37
5771: PPUSH
5772: LD_STRING D1a-JMM-2
5774: PPUSH
5775: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5779: LD_EXP 44
5783: PPUSH
5784: LD_STRING D1a-Corn-3
5786: PPUSH
5787: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5791: LD_EXP 37
5795: PPUSH
5796: LD_STRING D1a-JMM-3
5798: PPUSH
5799: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5803: LD_EXP 44
5807: PPUSH
5808: LD_STRING D1a-Corn-4
5810: PPUSH
5811: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5815: LD_EXP 37
5819: PPUSH
5820: LD_STRING D1a-JMM-4
5822: PPUSH
5823: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5827: LD_EXP 44
5831: PPUSH
5832: LD_STRING D1a-Corn-5
5834: PPUSH
5835: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5839: LD_EXP 45
5843: PPUSH
5844: LD_EXP 44
5848: PPUSH
5849: CALL_OW 250
5853: PPUSH
5854: LD_EXP 44
5858: PPUSH
5859: CALL_OW 251
5863: PUSH
5864: LD_INT 2
5866: MINUS
5867: PPUSH
5868: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5872: LD_EXP 45
5876: PPUSH
5877: LD_EXP 44
5881: PPUSH
5882: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5886: LD_INT 10
5888: PPUSH
5889: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5893: LD_EXP 37
5897: PPUSH
5898: LD_STRING D1b-JMM-1
5900: PPUSH
5901: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5905: LD_EXP 44
5909: PPUSH
5910: LD_STRING D1b-Corn-1
5912: PPUSH
5913: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5917: LD_EXP 37
5921: PPUSH
5922: LD_STRING D1b-JMM-2
5924: PPUSH
5925: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5929: LD_EXP 44
5933: PPUSH
5934: LD_STRING D1b-Corn-2
5936: PPUSH
5937: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5941: LD_EXP 37
5945: PPUSH
5946: LD_STRING D1b-JMM-3
5948: PPUSH
5949: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5953: LD_INT 10
5955: PPUSH
5956: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5960: LD_EXP 46
5964: PPUSH
5965: LD_STRING D1b-Pow-3
5967: PPUSH
5968: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5972: LD_EXP 37
5976: PPUSH
5977: LD_STRING D1b-JMM-4
5979: PPUSH
5980: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5984: LD_EXP 44
5988: PPUSH
5989: LD_STRING D1b-Corn-4
5991: PPUSH
5992: CALL_OW 88
// if Khatam then
5996: LD_EXP 41
6000: IFFALSE 6016
// Say ( Khatam , D1b-Khat-4 ) else
6002: LD_EXP 41
6006: PPUSH
6007: LD_STRING D1b-Khat-4
6009: PPUSH
6010: CALL_OW 88
6014: GO 6052
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6016: LD_EXP 6
6020: PPUSH
6021: LD_INT 26
6023: PUSH
6024: LD_INT 1
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: PPUSH
6031: CALL_OW 72
6035: PUSH
6036: LD_EXP 44
6040: PUSH
6041: EMPTY
6042: LIST
6043: DIFF
6044: PPUSH
6045: LD_STRING D1b-Sol1-4
6047: PPUSH
6048: CALL 640 0 2
// if Cyrus then
6052: LD_EXP 39
6056: IFFALSE 6070
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6058: LD_EXP 39
6062: PPUSH
6063: LD_STRING D1b-Cyrus-4
6065: PPUSH
6066: CALL_OW 88
// if Lisa then
6070: LD_EXP 40
6074: IFFALSE 6132
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6076: LD_EXP 40
6080: PPUSH
6081: LD_STRING D1b-Lisa-4
6083: PPUSH
6084: CALL_OW 88
// if Cyrus then
6088: LD_EXP 39
6092: IFFALSE 6132
// begin if not IsInUnit ( Cyrus ) then
6094: LD_EXP 39
6098: PPUSH
6099: CALL_OW 310
6103: NOT
6104: IFFALSE 6120
// ComTurnUnit ( Cyrus , Lisa ) ;
6106: LD_EXP 39
6110: PPUSH
6111: LD_EXP 40
6115: PPUSH
6116: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6120: LD_EXP 39
6124: PPUSH
6125: LD_STRING D1b-Cyrus-5
6127: PPUSH
6128: CALL_OW 88
// end ; end ; SelectGroup ;
6132: CALL 2621 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6136: LD_EXP 37
6140: PPUSH
6141: LD_STRING D1d-JMM-1
6143: PPUSH
6144: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6148: LD_EXP 44
6152: PPUSH
6153: LD_STRING D1d-Corn-1
6155: PPUSH
6156: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_EXP 4
6169: PUSH
6170: LD_EXP 6
6174: ADD
6175: PUSH
6176: LD_EXP 37
6180: ADD
6181: PUSH
6182: FOR_IN
6183: IFFALSE 6196
// ComHold ( i ) ;
6185: LD_VAR 0 2
6189: PPUSH
6190: CALL_OW 140
6194: GO 6182
6196: POP
6197: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6198: LD_ADDR_VAR 0 4
6202: PUSH
6203: LD_INT 22
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 21
6215: PUSH
6216: LD_INT 2
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PPUSH
6227: CALL_OW 69
6231: ST_TO_ADDR
// if vehicles then
6232: LD_VAR 0 4
6236: IFFALSE 6574
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6238: LD_EXP 6
6242: PPUSH
6243: LD_INT 55
6245: PUSH
6246: EMPTY
6247: LIST
6248: PPUSH
6249: CALL_OW 72
6253: IFFALSE 6292
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6255: LD_ADDR_VAR 0 2
6259: PUSH
6260: LD_EXP 6
6264: PPUSH
6265: LD_INT 55
6267: PUSH
6268: EMPTY
6269: LIST
6270: PPUSH
6271: CALL_OW 72
6275: PUSH
6276: FOR_IN
6277: IFFALSE 6290
// ComExitVehicle ( i ) ;
6279: LD_VAR 0 2
6283: PPUSH
6284: CALL_OW 121
6288: GO 6276
6290: POP
6291: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6292: LD_ADDR_VAR 0 5
6296: PUSH
6297: LD_VAR 0 4
6301: PPUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 51
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL_OW 72
6316: ST_TO_ADDR
// if cargos then
6317: LD_VAR 0 5
6321: IFFALSE 6504
// begin vehicles := cargos ;
6323: LD_ADDR_VAR 0 4
6327: PUSH
6328: LD_VAR 0 5
6332: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6333: LD_ADDR_VAR 0 6
6337: PUSH
6338: LD_STRING 02_resources_4
6340: PPUSH
6341: LD_INT 0
6343: PPUSH
6344: CALL_OW 30
6348: ST_TO_ADDR
// if debug and not resources then
6349: LD_EXP 1
6353: PUSH
6354: LD_VAR 0 6
6358: NOT
6359: AND
6360: IFFALSE 6370
// resources := 160 ;
6362: LD_ADDR_VAR 0 6
6366: PUSH
6367: LD_INT 160
6369: ST_TO_ADDR
// if resources mod 10 then
6370: LD_VAR 0 6
6374: PUSH
6375: LD_INT 10
6377: MOD
6378: IFFALSE 6400
// resources := resources - resources mod 10 ;
6380: LD_ADDR_VAR 0 6
6384: PUSH
6385: LD_VAR 0 6
6389: PUSH
6390: LD_VAR 0 6
6394: PUSH
6395: LD_INT 10
6397: MOD
6398: MINUS
6399: ST_TO_ADDR
// if resources then
6400: LD_VAR 0 6
6404: IFFALSE 6504
// for i in cargos do
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 5
6415: PUSH
6416: FOR_IN
6417: IFFALSE 6502
// begin if resources < 100 then
6419: LD_VAR 0 6
6423: PUSH
6424: LD_INT 100
6426: LESS
6427: IFFALSE 6449
// begin cargo := resources ;
6429: LD_ADDR_VAR 0 7
6433: PUSH
6434: LD_VAR 0 6
6438: ST_TO_ADDR
// resources := 0 ;
6439: LD_ADDR_VAR 0 6
6443: PUSH
6444: LD_INT 0
6446: ST_TO_ADDR
// end else
6447: GO 6471
// begin cargo := 100 ;
6449: LD_ADDR_VAR 0 7
6453: PUSH
6454: LD_INT 100
6456: ST_TO_ADDR
// resources := resources - 100 ;
6457: LD_ADDR_VAR 0 6
6461: PUSH
6462: LD_VAR 0 6
6466: PUSH
6467: LD_INT 100
6469: MINUS
6470: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6471: LD_VAR 0 2
6475: PPUSH
6476: LD_INT 1
6478: PPUSH
6479: LD_VAR 0 7
6483: PPUSH
6484: CALL_OW 290
// if resources = 0 then
6488: LD_VAR 0 6
6492: PUSH
6493: LD_INT 0
6495: EQUAL
6496: IFFALSE 6500
// break ;
6498: GO 6502
// end ;
6500: GO 6416
6502: POP
6503: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6504: LD_VAR 0 4
6508: PUSH
6509: LD_INT 1
6511: ARRAY
6512: PPUSH
6513: CALL_OW 311
6517: PPUSH
6518: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 1
6529: ARRAY
6530: PPUSH
6531: LD_INT 4
6533: PPUSH
6534: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6538: LD_EXP 44
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6556: LD_INT 35
6558: PPUSH
6559: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6563: LD_EXP 44
6567: PPUSH
6568: CALL_OW 310
6572: IFFALSE 6556
// end ; InGameOff ;
6574: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6578: LD_STRING M1
6580: PPUSH
6581: CALL_OW 337
// SaveForQuickRestart ;
6585: CALL_OW 22
// cornel_active := true ;
6589: LD_ADDR_EXP 8
6593: PUSH
6594: LD_INT 1
6596: ST_TO_ADDR
// end ;
6597: LD_VAR 0 1
6601: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6602: LD_EXP 37
6606: PPUSH
6607: LD_EXP 47
6611: PPUSH
6612: CALL_OW 296
6616: PUSH
6617: LD_INT 10
6619: LESS
6620: IFFALSE 8003
6622: GO 6624
6624: DISABLE
6625: LD_INT 0
6627: PPUSH
6628: PPUSH
6629: PPUSH
6630: PPUSH
6631: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6632: LD_ADDR_VAR 0 2
6636: PUSH
6637: LD_INT 89
6639: PUSH
6640: LD_INT 34
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: LD_INT 138
6649: PUSH
6650: LD_INT 63
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 196
6659: PUSH
6660: LD_INT 84
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PUSH
6667: LD_INT 135
6669: PUSH
6670: LD_INT 52
6672: PUSH
6673: EMPTY
6674: LIST
6675: LIST
6676: PUSH
6677: LD_INT 103
6679: PUSH
6680: LD_INT 39
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 58
6689: PUSH
6690: LD_INT 30
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: LD_INT 38
6699: PUSH
6700: LD_INT 51
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: ST_TO_ADDR
// Video ( true ) ;
6716: LD_INT 1
6718: PPUSH
6719: CALL 1200 0 1
// if jmm_units then
6723: LD_EXP 4
6727: IFFALSE 6803
// for i in jmm_units do
6729: LD_ADDR_VAR 0 1
6733: PUSH
6734: LD_EXP 4
6738: PUSH
6739: FOR_IN
6740: IFFALSE 6801
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_EXP 37
6751: PPUSH
6752: CALL_OW 296
6756: PUSH
6757: LD_INT 10
6759: LESS
6760: PUSH
6761: LD_VAR 0 1
6765: PPUSH
6766: CALL_OW 310
6770: NOT
6771: AND
6772: IFFALSE 6790
// ComTurnUnit ( i , JMM ) else
6774: LD_VAR 0 1
6778: PPUSH
6779: LD_EXP 37
6783: PPUSH
6784: CALL_OW 119
6788: GO 6799
// ComHold ( i ) ;
6790: LD_VAR 0 1
6794: PPUSH
6795: CALL_OW 140
// end ;
6799: GO 6739
6801: POP
6802: POP
// if IsInUnit ( JMM ) then
6803: LD_EXP 37
6807: PPUSH
6808: CALL_OW 310
6812: IFFALSE 6837
// begin ComExitVehicle ( JMM ) ;
6814: LD_EXP 37
6818: PPUSH
6819: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6823: LD_EXP 37
6827: PPUSH
6828: LD_EXP 47
6832: PPUSH
6833: CALL_OW 172
// end ; Wait ( 10 ) ;
6837: LD_INT 10
6839: PPUSH
6840: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6844: LD_EXP 37
6848: PPUSH
6849: LD_EXP 47
6853: PPUSH
6854: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6858: LD_INT 35
6860: PPUSH
6861: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6865: LD_EXP 37
6869: PPUSH
6870: LD_EXP 47
6874: PPUSH
6875: CALL_OW 296
6879: PUSH
6880: LD_INT 6
6882: LESS
6883: IFFALSE 6858
// ComTurnUnit ( JMM , Lynch ) ;
6885: LD_EXP 37
6889: PPUSH
6890: LD_EXP 47
6894: PPUSH
6895: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_EXP 47
6908: PUSH
6909: LD_EXP 48
6913: PUSH
6914: LD_EXP 49
6918: PUSH
6919: LD_EXP 50
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: LIST
6928: LIST
6929: PUSH
6930: FOR_IN
6931: IFFALSE 6949
// ComTurnUnit ( i , JMM ) ;
6933: LD_VAR 0 1
6937: PPUSH
6938: LD_EXP 37
6942: PPUSH
6943: CALL_OW 119
6947: GO 6930
6949: POP
6950: POP
// Wait ( 0 0$0.3 ) ;
6951: LD_INT 10
6953: PPUSH
6954: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6958: LD_EXP 37
6962: PPUSH
6963: LD_STRING D2-JMM-1
6965: PPUSH
6966: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6970: LD_EXP 47
6974: PPUSH
6975: LD_STRING D2-Sol1-1
6977: PPUSH
6978: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6982: LD_EXP 37
6986: PPUSH
6987: LD_STRING D2-JMM-2
6989: PPUSH
6990: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6994: LD_EXP 47
6998: PPUSH
6999: LD_STRING D2-Sol1-2
7001: PPUSH
7002: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7006: LD_EXP 37
7010: PPUSH
7011: LD_STRING D2-JMM-3
7013: PPUSH
7014: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7018: LD_EXP 47
7022: PPUSH
7023: LD_STRING D2-Sol1-3
7025: PPUSH
7026: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7030: LD_ADDR_VAR 0 1
7034: PUSH
7035: LD_INT 22
7037: PUSH
7038: LD_INT 8
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: PUSH
7050: FOR_IN
7051: IFFALSE 7067
// SetSide ( i , 1 ) ;
7053: LD_VAR 0 1
7057: PPUSH
7058: LD_INT 1
7060: PPUSH
7061: CALL_OW 235
7065: GO 7050
7067: POP
7068: POP
// Say ( JMM , D2-JMM-4 ) ;
7069: LD_EXP 37
7073: PPUSH
7074: LD_STRING D2-JMM-4
7076: PPUSH
7077: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 5
7086: PPUSH
7087: CALL_OW 332
// for i = 1 to points do
7091: LD_ADDR_VAR 0 1
7095: PUSH
7096: DOUBLE
7097: LD_INT 1
7099: DEC
7100: ST_TO_ADDR
7101: LD_VAR 0 2
7105: PUSH
7106: FOR_TO
7107: IFFALSE 7282
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_VAR 0 2
7128: PUSH
7129: LD_VAR 0 1
7133: ARRAY
7134: PUSH
7135: LD_INT 2
7137: ARRAY
7138: PPUSH
7139: CALL_OW 84
// if i = 1 then
7143: LD_VAR 0 1
7147: PUSH
7148: LD_INT 1
7150: EQUAL
7151: IFFALSE 7165
// Say ( Lynch , D2-Sol1-4 ) ;
7153: LD_EXP 47
7157: PPUSH
7158: LD_STRING D2-Sol1-4
7160: PPUSH
7161: CALL_OW 88
// if i = 2 then
7165: LD_VAR 0 1
7169: PUSH
7170: LD_INT 2
7172: EQUAL
7173: IFFALSE 7187
// Say ( JMM , D2-JMM-5 ) ;
7175: LD_EXP 37
7179: PPUSH
7180: LD_STRING D2-JMM-5
7182: PPUSH
7183: CALL_OW 88
// if i = 4 then
7187: LD_VAR 0 1
7191: PUSH
7192: LD_INT 4
7194: EQUAL
7195: IFFALSE 7219
// begin RevealFogArea ( 1 , troopsArea ) ;
7197: LD_INT 1
7199: PPUSH
7200: LD_INT 6
7202: PPUSH
7203: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7207: LD_EXP 47
7211: PPUSH
7212: LD_STRING D2-Sol1-5
7214: PPUSH
7215: CALL_OW 88
// end ; if i = 5 then
7219: LD_VAR 0 1
7223: PUSH
7224: LD_INT 5
7226: EQUAL
7227: IFFALSE 7241
// Say ( JMM , D2-JMM-6 ) ;
7229: LD_EXP 37
7233: PPUSH
7234: LD_STRING D2-JMM-6
7236: PPUSH
7237: CALL_OW 88
// if i = 7 then
7241: LD_VAR 0 1
7245: PUSH
7246: LD_INT 7
7248: EQUAL
7249: IFFALSE 7273
// begin RevealFogArea ( 1 , forestArea ) ;
7251: LD_INT 1
7253: PPUSH
7254: LD_INT 7
7256: PPUSH
7257: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7261: LD_EXP 47
7265: PPUSH
7266: LD_STRING D2-Sol1-6
7268: PPUSH
7269: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7273: LD_INT 46
7275: PPUSH
7276: CALL_OW 67
// end ;
7280: GO 7106
7282: POP
7283: POP
// CenterNowOnUnits ( JMM ) ;
7284: LD_EXP 37
7288: PPUSH
7289: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7293: LD_EXP 37
7297: PPUSH
7298: LD_STRING D2-JMM-7
7300: PPUSH
7301: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7305: LD_EXP 47
7309: PPUSH
7310: LD_STRING D2-Sol1-7
7312: PPUSH
7313: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7317: LD_EXP 37
7321: PPUSH
7322: LD_STRING D2-JMM-8
7324: PPUSH
7325: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7329: LD_ADDR_VAR 0 4
7333: PUSH
7334: LD_INT 22
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 30
7346: PUSH
7347: LD_INT 31
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL_OW 69
7362: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7363: LD_EXP 47
7367: PPUSH
7368: LD_VAR 0 4
7372: PUSH
7373: LD_INT 1
7375: ARRAY
7376: PPUSH
7377: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7381: LD_INT 65
7383: PPUSH
7384: LD_INT 101
7386: PPUSH
7387: CALL_OW 428
7391: IFFALSE 7414
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7393: LD_INT 65
7395: PPUSH
7396: LD_INT 101
7398: PPUSH
7399: CALL_OW 428
7403: PPUSH
7404: LD_INT 75
7406: PPUSH
7407: LD_INT 100
7409: PPUSH
7410: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7414: LD_INT 66
7416: PPUSH
7417: LD_INT 103
7419: PPUSH
7420: CALL_OW 428
7424: IFFALSE 7447
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7426: LD_INT 66
7428: PPUSH
7429: LD_INT 103
7431: PPUSH
7432: CALL_OW 428
7436: PPUSH
7437: LD_INT 75
7439: PPUSH
7440: LD_INT 100
7442: PPUSH
7443: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7447: LD_ADDR_VAR 0 5
7451: PUSH
7452: LD_INT 22
7454: PUSH
7455: LD_INT 1
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: PUSH
7462: LD_INT 21
7464: PUSH
7465: LD_INT 2
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 91
7474: PUSH
7475: LD_EXP 37
7479: PUSH
7480: LD_INT 7
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 69
7497: ST_TO_ADDR
// if tmp then
7498: LD_VAR 0 5
7502: IFFALSE 7519
// ComMoveXY ( tmp , 75 , 100 ) ;
7504: LD_VAR 0 5
7508: PPUSH
7509: LD_INT 75
7511: PPUSH
7512: LD_INT 100
7514: PPUSH
7515: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7519: LD_ADDR_VAR 0 3
7523: PUSH
7524: LD_EXP 4
7528: PPUSH
7529: LD_INT 25
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PPUSH
7539: CALL_OW 72
7543: PPUSH
7544: LD_EXP 37
7548: PPUSH
7549: CALL_OW 74
7553: ST_TO_ADDR
// if sol then
7554: LD_VAR 0 3
7558: IFFALSE 7618
// if GetDistUnits ( JMM , sol ) < 10 then
7560: LD_EXP 37
7564: PPUSH
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 296
7574: PUSH
7575: LD_INT 10
7577: LESS
7578: IFFALSE 7618
// begin if IsInUnit ( sol ) then
7580: LD_VAR 0 3
7584: PPUSH
7585: CALL_OW 310
7589: IFFALSE 7600
// ComExitVehicle ( sol ) ;
7591: LD_VAR 0 3
7595: PPUSH
7596: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7600: LD_VAR 0 3
7604: PPUSH
7605: LD_VAR 0 4
7609: PUSH
7610: LD_INT 2
7612: ARRAY
7613: PPUSH
7614: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7618: LD_INT 10
7620: PPUSH
7621: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7625: LD_EXP 37
7629: PPUSH
7630: LD_INT 65
7632: PPUSH
7633: LD_INT 101
7635: PPUSH
7636: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7640: LD_EXP 37
7644: PPUSH
7645: LD_INT 63
7647: PPUSH
7648: LD_INT 100
7650: PPUSH
7651: CALL_OW 178
// tmp := 0 0$0 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_INT 0
7662: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7670: LD_ADDR_VAR 0 5
7674: PUSH
7675: LD_VAR 0 5
7679: PUSH
7680: LD_INT 35
7682: PLUS
7683: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7684: LD_EXP 37
7688: PPUSH
7689: LD_INT 65
7691: PPUSH
7692: LD_INT 101
7694: PPUSH
7695: CALL_OW 307
7699: PUSH
7700: LD_VAR 0 5
7704: PUSH
7705: LD_INT 175
7707: GREATER
7708: OR
7709: IFFALSE 7663
// Say ( JMM , D2a-JMM-1 ) ;
7711: LD_EXP 37
7715: PPUSH
7716: LD_STRING D2a-JMM-1
7718: PPUSH
7719: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7723: LD_EXP 48
7727: PPUSH
7728: LD_INT 66
7730: PPUSH
7731: LD_INT 103
7733: PPUSH
7734: CALL_OW 111
// tmp := 0 0$0 ;
7738: LD_ADDR_VAR 0 5
7742: PUSH
7743: LD_INT 0
7745: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7746: LD_INT 35
7748: PPUSH
7749: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7753: LD_EXP 48
7757: PPUSH
7758: LD_INT 66
7760: PPUSH
7761: LD_INT 103
7763: PPUSH
7764: CALL_OW 307
7768: PUSH
7769: LD_VAR 0 5
7773: PUSH
7774: LD_INT 175
7776: GREATER
7777: OR
7778: IFFALSE 7746
// ComTurnUnit ( Walker , JMM ) ;
7780: LD_EXP 48
7784: PPUSH
7785: LD_EXP 37
7789: PPUSH
7790: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7794: LD_EXP 48
7798: PPUSH
7799: LD_STRING D2a-Sci1-1
7801: PPUSH
7802: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7806: LD_EXP 37
7810: PPUSH
7811: LD_EXP 48
7815: PPUSH
7816: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7820: LD_EXP 37
7824: PPUSH
7825: LD_STRING D2a-JMM-2
7827: PPUSH
7828: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7832: LD_EXP 48
7836: PPUSH
7837: LD_STRING D2a-Sci1-2
7839: PPUSH
7840: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7844: LD_EXP 37
7848: PPUSH
7849: LD_STRING D2a-JMM-3
7851: PPUSH
7852: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7856: LD_EXP 48
7860: PPUSH
7861: LD_STRING D2a-Sci1-3
7863: PPUSH
7864: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7868: LD_ADDR_EXP 4
7872: PUSH
7873: LD_EXP 4
7877: PUSH
7878: LD_EXP 47
7882: PUSH
7883: LD_EXP 48
7887: PUSH
7888: LD_EXP 49
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: LIST
7902: LIST
7903: ADD
7904: ST_TO_ADDR
// for i in jmm_units do
7905: LD_ADDR_VAR 0 1
7909: PUSH
7910: LD_EXP 4
7914: PUSH
7915: FOR_IN
7916: IFFALSE 7941
// if not IsInUnit ( i ) then
7918: LD_VAR 0 1
7922: PPUSH
7923: CALL_OW 310
7927: NOT
7928: IFFALSE 7939
// ComFree ( i ) ;
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 139
7939: GO 7915
7941: POP
7942: POP
// Video ( false ) ;
7943: LD_INT 0
7945: PPUSH
7946: CALL 1200 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7950: LD_STRING MSolar1
7952: PPUSH
7953: CALL_OW 337
// jmm_on_west := true ;
7957: LD_ADDR_EXP 5
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7965: LD_INT 1050
7967: PPUSH
7968: CALL_OW 67
// frank_can_return := true ;
7972: LD_ADDR_EXP 12
7976: PUSH
7977: LD_INT 1
7979: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7980: LD_INT 6300
7982: PPUSH
7983: LD_INT 8400
7985: PPUSH
7986: CALL_OW 12
7990: PPUSH
7991: CALL_OW 67
// send_spec_patrol := true ;
7995: LD_ADDR_EXP 30
7999: PUSH
8000: LD_INT 1
8002: ST_TO_ADDR
// end ;
8003: PPOPN 5
8005: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
8006: LD_INT 22
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 34
8018: PUSH
8019: LD_INT 51
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 92
8028: PUSH
8029: LD_INT 63
8031: PUSH
8032: LD_INT 100
8034: PUSH
8035: LD_INT 5
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: PPUSH
8052: CALL_OW 69
8056: PUSH
8057: LD_EXP 5
8061: NOT
8062: AND
8063: IFFALSE 8176
8065: GO 8067
8067: DISABLE
8068: LD_INT 0
8070: PPUSH
8071: PPUSH
// begin enable ;
8072: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8073: LD_ADDR_VAR 0 2
8077: PUSH
8078: LD_INT 22
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 34
8090: PUSH
8091: LD_INT 51
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 92
8100: PUSH
8101: LD_INT 63
8103: PUSH
8104: LD_INT 100
8106: PUSH
8107: LD_INT 5
8109: PUSH
8110: EMPTY
8111: LIST
8112: LIST
8113: LIST
8114: LIST
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: PUSH
8121: EMPTY
8122: LIST
8123: PPUSH
8124: CALL_OW 69
8128: ST_TO_ADDR
// if not filter then
8129: LD_VAR 0 2
8133: NOT
8134: IFFALSE 8138
// exit ;
8136: GO 8176
// for i in filter do
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: LD_VAR 0 2
8147: PUSH
8148: FOR_IN
8149: IFFALSE 8174
// begin SetFuel ( i , 0 ) ;
8151: LD_VAR 0 1
8155: PPUSH
8156: LD_INT 0
8158: PPUSH
8159: CALL_OW 240
// ComStop ( i ) ;
8163: LD_VAR 0 1
8167: PPUSH
8168: CALL_OW 141
// end ;
8172: GO 8148
8174: POP
8175: POP
// end ;
8176: PPOPN 2
8178: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8179: LD_EXP 30
8183: IFFALSE 9176
8185: GO 8187
8187: DISABLE
8188: LD_INT 0
8190: PPUSH
8191: PPUSH
8192: PPUSH
8193: PPUSH
8194: PPUSH
8195: PPUSH
8196: PPUSH
// begin if not ru_spec_patrol then
8197: LD_EXP 54
8201: NOT
8202: IFFALSE 8206
// exit ;
8204: GO 9176
// dead1 := false ;
8206: LD_ADDR_VAR 0 1
8210: PUSH
8211: LD_INT 0
8213: ST_TO_ADDR
// dead2 := false ;
8214: LD_ADDR_VAR 0 2
8218: PUSH
8219: LD_INT 0
8221: ST_TO_ADDR
// inarea1 := false ;
8222: LD_ADDR_VAR 0 3
8226: PUSH
8227: LD_INT 0
8229: ST_TO_ADDR
// inarea2 := false ;
8230: LD_ADDR_VAR 0 4
8234: PUSH
8235: LD_INT 0
8237: ST_TO_ADDR
// tmp := [ ] ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: EMPTY
8244: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8245: LD_EXP 54
8249: PPUSH
8250: LD_INT 75
8252: PPUSH
8253: LD_INT 101
8255: PPUSH
8256: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8260: LD_INT 35
8262: PPUSH
8263: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8267: LD_INT 1
8269: PPUSH
8270: LD_EXP 54
8274: PUSH
8275: LD_INT 1
8277: ARRAY
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8260
// ComStop ( ru_spec_patrol ) ;
8285: LD_EXP 54
8289: PPUSH
8290: CALL_OW 141
// Wait ( 0 0$02 ) ;
8294: LD_INT 70
8296: PPUSH
8297: CALL_OW 67
// DialogueOn ;
8301: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8305: LD_EXP 54
8309: PUSH
8310: LD_INT 1
8312: ARRAY
8313: PPUSH
8314: LD_STRING D8-Rus1-1
8316: PPUSH
8317: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8321: LD_EXP 37
8325: PPUSH
8326: LD_STRING D8-JMM-1
8328: PPUSH
8329: CALL_OW 88
// DialogueOff ;
8333: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8337: LD_EXP 54
8341: PPUSH
8342: LD_INT 13
8344: PPUSH
8345: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8349: LD_INT 35
8351: PPUSH
8352: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8356: LD_VAR 0 1
8360: NOT
8361: PUSH
8362: LD_EXP 54
8366: PUSH
8367: LD_INT 1
8369: ARRAY
8370: PPUSH
8371: CALL_OW 301
8375: AND
8376: IFFALSE 8386
// dead1 := true ;
8378: LD_ADDR_VAR 0 1
8382: PUSH
8383: LD_INT 1
8385: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8386: LD_VAR 0 2
8390: NOT
8391: PUSH
8392: LD_EXP 54
8396: PUSH
8397: LD_INT 2
8399: ARRAY
8400: PPUSH
8401: CALL_OW 301
8405: AND
8406: IFFALSE 8416
// dead2 := true ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_INT 1
8415: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8416: LD_VAR 0 3
8420: NOT
8421: PUSH
8422: LD_EXP 54
8426: PUSH
8427: LD_INT 1
8429: ARRAY
8430: PPUSH
8431: LD_INT 14
8433: PPUSH
8434: CALL_OW 308
8438: AND
8439: IFFALSE 8449
// inarea1 := true ;
8441: LD_ADDR_VAR 0 3
8445: PUSH
8446: LD_INT 1
8448: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8449: LD_VAR 0 4
8453: NOT
8454: PUSH
8455: LD_EXP 54
8459: PUSH
8460: LD_INT 2
8462: ARRAY
8463: PPUSH
8464: LD_INT 14
8466: PPUSH
8467: CALL_OW 308
8471: AND
8472: IFFALSE 8482
// inarea2 := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8482: LD_VAR 0 1
8486: PUSH
8487: LD_VAR 0 2
8491: AND
8492: PUSH
8493: LD_VAR 0 1
8497: PUSH
8498: LD_VAR 0 4
8502: AND
8503: OR
8504: PUSH
8505: LD_VAR 0 2
8509: PUSH
8510: LD_VAR 0 3
8514: AND
8515: OR
8516: PUSH
8517: LD_VAR 0 3
8521: PUSH
8522: LD_VAR 0 4
8526: AND
8527: OR
8528: IFFALSE 8349
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8530: LD_VAR 0 3
8534: PUSH
8535: LD_VAR 0 4
8539: AND
8540: PUSH
8541: LD_VAR 0 1
8545: PUSH
8546: LD_VAR 0 4
8550: AND
8551: OR
8552: PUSH
8553: LD_VAR 0 2
8557: PUSH
8558: LD_VAR 0 3
8562: AND
8563: OR
8564: IFFALSE 9156
// begin prepare_siege := true ;
8566: LD_ADDR_EXP 31
8570: PUSH
8571: LD_INT 1
8573: ST_TO_ADDR
// DialogueOn ;
8574: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8578: LD_VAR 0 3
8582: PUSH
8583: LD_VAR 0 4
8587: AND
8588: IFFALSE 8604
// Say ( JMM , D8b-JMM-1a ) else
8590: LD_EXP 37
8594: PPUSH
8595: LD_STRING D8b-JMM-1a
8597: PPUSH
8598: CALL_OW 88
8602: GO 8616
// Say ( JMM , D8b-JMM-1 ) ;
8604: LD_EXP 37
8608: PPUSH
8609: LD_STRING D8b-JMM-1
8611: PPUSH
8612: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8616: LD_EXP 4
8620: PPUSH
8621: LD_INT 26
8623: PUSH
8624: LD_INT 1
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PPUSH
8631: CALL_OW 72
8635: PUSH
8636: LD_EXP 38
8640: PUSH
8641: LD_EXP 39
8645: PUSH
8646: LD_EXP 48
8650: PUSH
8651: LD_EXP 51
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: DIFF
8662: PPUSH
8663: LD_STRING D8b-Sol1-1
8665: PPUSH
8666: CALL 640 0 2
// if Cyrus and Cyrus in jmm_units then
8670: LD_EXP 39
8674: PUSH
8675: LD_EXP 39
8679: PUSH
8680: LD_EXP 4
8684: IN
8685: AND
8686: IFFALSE 8702
// Say ( Cyrus , D8b-Cyrus-1 ) else
8688: LD_EXP 39
8692: PPUSH
8693: LD_STRING D8b-Cyrus-1
8695: PPUSH
8696: CALL_OW 88
8700: GO 8714
// Say ( JMM , D8b-JMM-1a ) ;
8702: LD_EXP 37
8706: PPUSH
8707: LD_STRING D8b-JMM-1a
8709: PPUSH
8710: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8714: LD_EXP 40
8718: PUSH
8719: LD_EXP 40
8723: PUSH
8724: LD_EXP 4
8728: IN
8729: AND
8730: IFFALSE 8744
// Say ( Lisa , D8b-Lisa-2 ) ;
8732: LD_EXP 40
8736: PPUSH
8737: LD_STRING D8b-Lisa-2
8739: PPUSH
8740: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8744: LD_EXP 38
8748: PUSH
8749: LD_EXP 38
8753: PUSH
8754: LD_EXP 4
8758: IN
8759: AND
8760: IFFALSE 8776
// Say ( Bobby , D8b-Bobby-1 ) else
8762: LD_EXP 38
8766: PPUSH
8767: LD_STRING D8b-Bobby-1
8769: PPUSH
8770: CALL_OW 88
8774: GO 8836
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8776: LD_ADDR_VAR 0 5
8780: PUSH
8781: LD_EXP 4
8785: PPUSH
8786: LD_INT 26
8788: PUSH
8789: LD_INT 1
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: PPUSH
8796: CALL_OW 72
8800: PUSH
8801: LD_EXP 38
8805: PUSH
8806: LD_EXP 39
8810: PUSH
8811: LD_EXP 48
8815: PUSH
8816: LD_EXP 51
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: DIFF
8827: PPUSH
8828: LD_STRING D8b-Sol2-1
8830: PPUSH
8831: CALL 640 0 2
8835: ST_TO_ADDR
// DialogueOff ;
8836: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8840: LD_EXP 39
8844: PUSH
8845: LD_EXP 39
8849: PUSH
8850: LD_EXP 4
8854: IN
8855: AND
8856: IFFALSE 8881
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8858: LD_ADDR_VAR 0 6
8862: PUSH
8863: LD_VAR 0 6
8867: PPUSH
8868: LD_INT 1
8870: PPUSH
8871: LD_EXP 39
8875: PPUSH
8876: CALL_OW 2
8880: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8881: LD_EXP 38
8885: PUSH
8886: LD_EXP 38
8890: PUSH
8891: LD_EXP 4
8895: IN
8896: AND
8897: IFFALSE 8922
// tmp := Insert ( tmp , 1 , Bobby ) ;
8899: LD_ADDR_VAR 0 6
8903: PUSH
8904: LD_VAR 0 6
8908: PPUSH
8909: LD_INT 1
8911: PPUSH
8912: LD_EXP 38
8916: PPUSH
8917: CALL_OW 2
8921: ST_TO_ADDR
// if sol then
8922: LD_VAR 0 5
8926: IFFALSE 8951
// tmp := Insert ( tmp , 1 , sol ) ;
8928: LD_ADDR_VAR 0 6
8932: PUSH
8933: LD_VAR 0 6
8937: PPUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_VAR 0 5
8945: PPUSH
8946: CALL_OW 2
8950: ST_TO_ADDR
// if tmp then
8951: LD_VAR 0 6
8955: IFFALSE 9115
// begin SetSide ( tmp , 8 ) ;
8957: LD_VAR 0 6
8961: PPUSH
8962: LD_INT 8
8964: PPUSH
8965: CALL_OW 235
// ComFree ( tmp ) ;
8969: LD_VAR 0 6
8973: PPUSH
8974: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8978: LD_VAR 0 6
8982: PPUSH
8983: LD_INT 15
8985: PPUSH
8986: CALL_OW 173
// AddComHold ( tmp ) ;
8990: LD_VAR 0 6
8994: PPUSH
8995: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8999: LD_INT 35
9001: PPUSH
9002: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
9006: LD_VAR 0 6
9010: PUSH
9011: LD_INT 1
9013: ARRAY
9014: PPUSH
9015: CALL_OW 314
9019: NOT
9020: IFFALSE 9034
// ComMoveToArea ( tmp , cyrusEscape ) ;
9022: LD_VAR 0 6
9026: PPUSH
9027: LD_INT 15
9029: PPUSH
9030: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9034: LD_VAR 0 6
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 15
9045: PPUSH
9046: CALL_OW 308
9050: IFFALSE 9105
// begin RemoveUnit ( tmp [ 1 ] ) ;
9052: LD_VAR 0 6
9056: PUSH
9057: LD_INT 1
9059: ARRAY
9060: PPUSH
9061: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9065: LD_ADDR_EXP 4
9069: PUSH
9070: LD_EXP 4
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_INT 1
9082: ARRAY
9083: DIFF
9084: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9085: LD_ADDR_VAR 0 6
9089: PUSH
9090: LD_VAR 0 6
9094: PUSH
9095: LD_VAR 0 6
9099: PUSH
9100: LD_INT 1
9102: ARRAY
9103: DIFF
9104: ST_TO_ADDR
// end ; until tmp = 0 ;
9105: LD_VAR 0 6
9109: PUSH
9110: LD_INT 0
9112: EQUAL
9113: IFFALSE 8999
// end ; Wait ( 0 0$30 ) ;
9115: LD_INT 1050
9117: PPUSH
9118: CALL_OW 67
// if ru_spec_patrol then
9122: LD_EXP 54
9126: IFFALSE 9154
// for i in ru_spec_patrol do
9128: LD_ADDR_VAR 0 7
9132: PUSH
9133: LD_EXP 54
9137: PUSH
9138: FOR_IN
9139: IFFALSE 9152
// RemoveUnit ( i ) ;
9141: LD_VAR 0 7
9145: PPUSH
9146: CALL_OW 64
9150: GO 9138
9152: POP
9153: POP
// end else
9154: GO 9176
// begin prepare_siege := false ;
9156: LD_ADDR_EXP 31
9160: PUSH
9161: LD_INT 0
9163: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9164: LD_EXP 37
9168: PPUSH
9169: LD_STRING D8a-JMM-1
9171: PPUSH
9172: CALL_OW 88
// end ; end ;
9176: PPOPN 7
9178: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9179: LD_EXP 12
9183: IFFALSE 10400
9185: GO 9187
9187: DISABLE
9188: LD_INT 0
9190: PPUSH
9191: PPUSH
9192: PPUSH
// begin uc_side := 8 ;
9193: LD_ADDR_OWVAR 20
9197: PUSH
9198: LD_INT 8
9200: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9201: LD_ADDR_VAR 0 3
9205: PUSH
9206: LD_INT 59
9208: PUSH
9209: LD_INT 71
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: PUSH
9216: LD_INT 122
9218: PUSH
9219: LD_INT 117
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9230: LD_ADDR_EXP 51
9234: PUSH
9235: LD_STRING Frank
9237: PPUSH
9238: LD_INT 0
9240: PPUSH
9241: CALL 489 0 2
9245: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9246: LD_ADDR_VAR 0 1
9250: PUSH
9251: LD_INT 1
9253: PPUSH
9254: LD_INT 2
9256: PPUSH
9257: CALL_OW 12
9261: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9262: LD_EXP 51
9266: PPUSH
9267: LD_VAR 0 3
9271: PUSH
9272: LD_VAR 0 1
9276: ARRAY
9277: PUSH
9278: LD_INT 1
9280: ARRAY
9281: PPUSH
9282: LD_VAR 0 3
9286: PUSH
9287: LD_VAR 0 1
9291: ARRAY
9292: PUSH
9293: LD_INT 2
9295: ARRAY
9296: PPUSH
9297: LD_INT 0
9299: PPUSH
9300: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9304: LD_EXP 51
9308: PPUSH
9309: LD_INT 1
9311: PPUSH
9312: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9316: LD_INT 35
9318: PPUSH
9319: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9323: LD_EXP 51
9327: PPUSH
9328: LD_EXP 37
9332: PPUSH
9333: CALL_OW 296
9337: PUSH
9338: LD_INT 8
9340: LESS
9341: PUSH
9342: LD_EXP 51
9346: PPUSH
9347: CALL_OW 256
9351: PUSH
9352: LD_INT 250
9354: GREATER
9355: AND
9356: IFFALSE 9316
// Video ( true ) ;
9358: LD_INT 1
9360: PPUSH
9361: CALL 1200 0 1
// CenterOnUnits ( JMM ) ;
9365: LD_EXP 37
9369: PPUSH
9370: CALL_OW 85
// if IsInUnit ( JMM ) then
9374: LD_EXP 37
9378: PPUSH
9379: CALL_OW 310
9383: IFFALSE 9394
// ComFree ( JMM ) ;
9385: LD_EXP 37
9389: PPUSH
9390: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9394: LD_EXP 37
9398: PPUSH
9399: LD_EXP 51
9403: PPUSH
9404: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9408: LD_EXP 51
9412: PPUSH
9413: LD_EXP 37
9417: PPUSH
9418: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9422: LD_EXP 37
9426: PPUSH
9427: LD_STRING D6-JMM-1
9429: PPUSH
9430: CALL_OW 88
// p := 0 ;
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_INT 0
9441: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9442: LD_INT 35
9444: PPUSH
9445: CALL_OW 67
// p := p + 1 ;
9449: LD_ADDR_VAR 0 2
9453: PUSH
9454: LD_VAR 0 2
9458: PUSH
9459: LD_INT 1
9461: PLUS
9462: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9463: LD_EXP 37
9467: PPUSH
9468: LD_EXP 51
9472: PPUSH
9473: CALL_OW 296
9477: PUSH
9478: LD_INT 8
9480: LESS
9481: PUSH
9482: LD_VAR 0 2
9486: PUSH
9487: LD_INT 7
9489: GREATER
9490: OR
9491: IFFALSE 9442
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9493: LD_EXP 40
9497: PUSH
9498: LD_EXP 40
9502: PPUSH
9503: LD_EXP 51
9507: PPUSH
9508: CALL_OW 296
9512: PUSH
9513: LD_INT 20
9515: LESS
9516: AND
9517: IFFALSE 9542
// begin ComFree ( Lisa ) ;
9519: LD_EXP 40
9523: PPUSH
9524: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9528: LD_EXP 40
9532: PPUSH
9533: LD_EXP 51
9537: PPUSH
9538: CALL_OW 172
// end ; if Lynch then
9542: LD_EXP 47
9546: IFFALSE 9571
// begin ComFree ( Lynch ) ;
9548: LD_EXP 47
9552: PPUSH
9553: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9557: LD_EXP 47
9561: PPUSH
9562: LD_EXP 51
9566: PPUSH
9567: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9571: LD_EXP 37
9575: PPUSH
9576: LD_EXP 51
9580: PPUSH
9581: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9585: LD_EXP 51
9589: PPUSH
9590: LD_EXP 37
9594: PPUSH
9595: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9599: LD_EXP 51
9603: PPUSH
9604: LD_STRING D6-Frank-1
9606: PPUSH
9607: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9611: LD_INT 69
9613: PPUSH
9614: LD_INT 20
9616: PPUSH
9617: LD_INT 1
9619: PPUSH
9620: LD_INT 20
9622: NEG
9623: PPUSH
9624: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9628: LD_INT 69
9630: PPUSH
9631: LD_INT 20
9633: PPUSH
9634: LD_INT 1
9636: PPUSH
9637: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9641: LD_INT 190
9643: PPUSH
9644: LD_INT 31
9646: PPUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 20
9652: NEG
9653: PPUSH
9654: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9658: LD_INT 190
9660: PPUSH
9661: LD_INT 31
9663: PPUSH
9664: LD_INT 1
9666: PPUSH
9667: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9671: LD_INT 69
9673: PPUSH
9674: LD_INT 20
9676: PPUSH
9677: CALL_OW 84
// Wait ( 0 0$02 ) ;
9681: LD_INT 70
9683: PPUSH
9684: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9688: LD_EXP 37
9692: PPUSH
9693: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9697: LD_EXP 40
9701: PUSH
9702: LD_EXP 40
9706: PPUSH
9707: LD_EXP 51
9711: PPUSH
9712: CALL_OW 296
9716: PUSH
9717: LD_INT 20
9719: LESS
9720: AND
9721: PUSH
9722: LD_EXP 40
9726: PPUSH
9727: CALL_OW 302
9731: AND
9732: IFFALSE 9854
// begin ComFree ( Lisa ) ;
9734: LD_EXP 40
9738: PPUSH
9739: CALL_OW 139
// p := 0 ;
9743: LD_ADDR_VAR 0 2
9747: PUSH
9748: LD_INT 0
9750: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// p := p + 1 ;
9758: LD_ADDR_VAR 0 2
9762: PUSH
9763: LD_VAR 0 2
9767: PUSH
9768: LD_INT 1
9770: PLUS
9771: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9772: LD_EXP 40
9776: PPUSH
9777: LD_EXP 51
9781: PPUSH
9782: CALL_OW 296
9786: PUSH
9787: LD_INT 7
9789: LESS
9790: PUSH
9791: LD_VAR 0 2
9795: PUSH
9796: LD_INT 7
9798: GREATER
9799: OR
9800: IFFALSE 9751
// Say ( Lisa , D6-Lisa-1 ) ;
9802: LD_EXP 40
9806: PPUSH
9807: LD_STRING D6-Lisa-1
9809: PPUSH
9810: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9814: LD_EXP 40
9818: PPUSH
9819: LD_EXP 51
9823: PPUSH
9824: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9828: LD_EXP 51
9832: PPUSH
9833: LD_EXP 40
9837: PPUSH
9838: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9842: LD_EXP 51
9846: PPUSH
9847: LD_STRING D6-Frank-2
9849: PPUSH
9850: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9854: LD_EXP 47
9858: PUSH
9859: LD_EXP 47
9863: PPUSH
9864: LD_EXP 51
9868: PPUSH
9869: CALL_OW 296
9873: PUSH
9874: LD_INT 20
9876: LESS
9877: AND
9878: PUSH
9879: LD_EXP 47
9883: PPUSH
9884: CALL_OW 302
9888: AND
9889: IFFALSE 10070
// begin ComTurnUnit ( Lynch , JMM ) ;
9891: LD_EXP 47
9895: PPUSH
9896: LD_EXP 37
9900: PPUSH
9901: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9905: LD_EXP 51
9909: PPUSH
9910: LD_EXP 37
9914: PPUSH
9915: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9919: LD_EXP 47
9923: PPUSH
9924: LD_STRING D6-Sol1-2
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9931: LD_EXP 37
9935: PPUSH
9936: LD_STRING D6-JMM-2
9938: PPUSH
9939: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9943: LD_EXP 51
9947: PPUSH
9948: LD_STRING D6-Frank-3
9950: PPUSH
9951: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9955: LD_EXP 37
9959: PPUSH
9960: LD_STRING D6-JMM-3
9962: PPUSH
9963: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9967: LD_EXP 51
9971: PPUSH
9972: LD_STRING D6-Frank-4
9974: PPUSH
9975: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9979: LD_EXP 51
9983: PPUSH
9984: LD_STRING D6-Frank-4a
9986: PPUSH
9987: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9991: LD_EXP 37
9995: PPUSH
9996: LD_STRING D6-JMM-4
9998: PPUSH
9999: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10003: LD_EXP 51
10007: PPUSH
10008: LD_STRING D6-Frank-5
10010: PPUSH
10011: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10015: LD_EXP 40
10019: PUSH
10020: LD_EXP 40
10024: PPUSH
10025: CALL_OW 302
10029: AND
10030: IFFALSE 10044
// Say ( Lisa , D6-Lisa-5 ) ;
10032: LD_EXP 40
10036: PPUSH
10037: LD_STRING D6-Lisa-5
10039: PPUSH
10040: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10044: LD_EXP 51
10048: PPUSH
10049: LD_STRING D6-Frank-6
10051: PPUSH
10052: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10056: LD_EXP 37
10060: PPUSH
10061: LD_STRING D6-JMM-6
10063: PPUSH
10064: CALL_OW 88
// end else
10068: GO 10185
// begin ComTurnUnit ( Frank , JMM ) ;
10070: LD_EXP 51
10074: PPUSH
10075: LD_EXP 37
10079: PPUSH
10080: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10084: LD_EXP 51
10088: PPUSH
10089: LD_STRING D6-Frank-4
10091: PPUSH
10092: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10096: LD_EXP 51
10100: PPUSH
10101: LD_STRING D6-Frank-4a
10103: PPUSH
10104: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10108: LD_EXP 37
10112: PPUSH
10113: LD_STRING D6-JMM-4
10115: PPUSH
10116: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10120: LD_EXP 51
10124: PPUSH
10125: LD_STRING D6-Frank-5
10127: PPUSH
10128: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10132: LD_EXP 40
10136: PUSH
10137: LD_EXP 40
10141: PPUSH
10142: CALL_OW 302
10146: AND
10147: IFFALSE 10161
// Say ( Lisa , D6-Lisa-5 ) ;
10149: LD_EXP 40
10153: PPUSH
10154: LD_STRING D6-Lisa-5
10156: PPUSH
10157: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10161: LD_EXP 51
10165: PPUSH
10166: LD_STRING D6-Frank-6
10168: PPUSH
10169: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10173: LD_EXP 37
10177: PPUSH
10178: LD_STRING D6-JMM-6
10180: PPUSH
10181: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10185: LD_STRING Q1
10187: PPUSH
10188: CALL_OW 97
10192: PUSH
10193: LD_INT 1
10195: DOUBLE
10196: EQUAL
10197: IFTRUE 10201
10199: GO 10212
10201: POP
// frank_send_to_scout := true ; 2 :
10202: LD_ADDR_EXP 15
10206: PUSH
10207: LD_INT 1
10209: ST_TO_ADDR
10210: GO 10232
10212: LD_INT 2
10214: DOUBLE
10215: EQUAL
10216: IFTRUE 10220
10218: GO 10231
10220: POP
// frank_send_to_scout := false ; end ;
10221: LD_ADDR_EXP 15
10225: PUSH
10226: LD_INT 0
10228: ST_TO_ADDR
10229: GO 10232
10231: POP
// Video ( false ) ;
10232: LD_INT 0
10234: PPUSH
10235: CALL 1200 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10239: LD_EXP 37
10243: PUSH
10244: LD_EXP 40
10248: PUSH
10249: LD_EXP 47
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 139
// if frank_send_to_scout then
10263: LD_EXP 15
10267: IFFALSE 10321
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10269: LD_EXP 51
10273: PPUSH
10274: LD_INT 15
10276: PPUSH
10277: CALL_OW 113
// wait ( 0 0$01 ) ;
10281: LD_INT 35
10283: PPUSH
10284: CALL_OW 67
// until not See ( 1 , Frank ) ;
10288: LD_INT 1
10290: PPUSH
10291: LD_EXP 51
10295: PPUSH
10296: CALL_OW 292
10300: NOT
10301: IFFALSE 10269
// wait ( 0 0$02 ) ;
10303: LD_INT 70
10305: PPUSH
10306: CALL_OW 67
// RemoveUnit ( Frank ) ;
10310: LD_EXP 51
10314: PPUSH
10315: CALL_OW 64
// end else
10319: GO 10333
// SetSide ( Frank , 1 ) ;
10321: LD_EXP 51
10325: PPUSH
10326: LD_INT 1
10328: PPUSH
10329: CALL_OW 235
// send_attack_on_cornel_base := true ;
10333: LD_ADDR_EXP 26
10337: PUSH
10338: LD_INT 1
10340: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10341: LD_INT 35
10343: PPUSH
10344: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10348: LD_ADDR_EXP 29
10352: PUSH
10353: LD_EXP 29
10357: PPUSH
10358: LD_STRING -
10360: PPUSH
10361: CALL 1132 0 2
10365: ST_TO_ADDR
// if debug then
10366: LD_EXP 1
10370: IFFALSE 10382
// debug_strings := time_to_prepare ;
10372: LD_ADDR_OWVAR 48
10376: PUSH
10377: LD_EXP 29
10381: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10382: LD_EXP 29
10386: PUSH
10387: LD_INT 0
10389: EQUAL
10390: IFFALSE 10341
// cornel_prepared := true ;
10392: LD_ADDR_EXP 11
10396: PUSH
10397: LD_INT 1
10399: ST_TO_ADDR
// end ;
10400: PPOPN 3
10402: END
// every 0 0$01 trigger cornel_prepared do
10403: LD_EXP 11
10407: IFFALSE 10671
10409: GO 10411
10411: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10412: LD_EXP 44
10416: PPUSH
10417: LD_STRING D3-Corn-1
10419: PPUSH
10420: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10424: LD_STRING MOutWait
10426: PPUSH
10427: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10431: LD_INT 35
10433: PPUSH
10434: CALL_OW 67
// until cornel_counter = 0 ;
10438: LD_EXP 10
10442: PUSH
10443: LD_INT 0
10445: EQUAL
10446: IFFALSE 10431
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10448: LD_EXP 44
10452: PPUSH
10453: LD_STRING D3a-Corn-1
10455: PPUSH
10456: CALL_OW 94
// if IsOk ( Cornel ) then
10460: LD_EXP 44
10464: PPUSH
10465: CALL_OW 302
10469: IFFALSE 10483
// Say ( JMM , D3a-JMM-1 ) ;
10471: LD_EXP 37
10475: PPUSH
10476: LD_STRING D3a-JMM-1
10478: PPUSH
10479: CALL_OW 88
// end_mission_allowed := true ;
10483: LD_ADDR_EXP 21
10487: PUSH
10488: LD_INT 1
10490: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10491: LD_STRING M2
10493: PPUSH
10494: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10498: LD_INT 9
10500: PPUSH
10501: LD_INT 1
10503: PPUSH
10504: CALL_OW 424
// Wait ( 0 0$05 ) ;
10508: LD_INT 175
10510: PPUSH
10511: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10515: LD_EXP 44
10519: PPUSH
10520: LD_STRING D3a-Corn-2
10522: PPUSH
10523: CALL_OW 94
// cornel_attack := true ;
10527: LD_ADDR_EXP 9
10531: PUSH
10532: LD_INT 1
10534: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10535: LD_INT 105
10537: PPUSH
10538: CALL_OW 67
// AddMoreTanks ( ) ;
10542: CALL 4877 0 0
// if frank_send_to_scout then
10546: LD_EXP 15
10550: IFFALSE 10671
// begin InitHc ;
10552: CALL_OW 19
// InitUc ;
10556: CALL_OW 18
// uc_side := 8 ;
10560: LD_ADDR_OWVAR 20
10564: PUSH
10565: LD_INT 8
10567: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10568: LD_ADDR_EXP 51
10572: PUSH
10573: LD_STRING Frank
10575: PPUSH
10576: LD_INT 0
10578: PPUSH
10579: CALL 489 0 2
10583: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10584: LD_EXP 51
10588: PPUSH
10589: LD_INT 6
10591: PPUSH
10592: LD_INT 9
10594: PPUSH
10595: LD_INT 0
10597: PPUSH
10598: CALL_OW 48
// ComCrawl ( Frank ) ;
10602: LD_EXP 51
10606: PPUSH
10607: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10611: LD_INT 35
10613: PPUSH
10614: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10618: LD_EXP 37
10622: PPUSH
10623: LD_EXP 51
10627: PPUSH
10628: CALL_OW 296
10632: PUSH
10633: LD_INT 9
10635: LESS
10636: IFFALSE 10611
// SetSide ( Frank , 1 ) ;
10638: LD_EXP 51
10642: PPUSH
10643: LD_INT 1
10645: PPUSH
10646: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10650: LD_EXP 51
10654: PPUSH
10655: LD_STRING D6a-Frank-1
10657: PPUSH
10658: CALL_OW 88
// ComWalk ( Frank ) ;
10662: LD_EXP 51
10666: PPUSH
10667: CALL_OW 138
// end ; end ;
10671: END
// every 0 0$01 trigger solar_builded do
10672: LD_EXP 14
10676: IFFALSE 10780
10678: GO 10680
10680: DISABLE
// begin Wait ( 0 0$02 ) ;
10681: LD_INT 70
10683: PPUSH
10684: CALL_OW 67
// DialogueOn ;
10688: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10692: LD_EXP 37
10696: PPUSH
10697: LD_STRING D2b-JMM-1
10699: PPUSH
10700: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10704: LD_EXP 48
10708: PUSH
10709: LD_EXP 48
10713: PPUSH
10714: CALL_OW 302
10718: AND
10719: IFFALSE 10769
// begin Say ( Walker , D2b-Sci1-1 ) ;
10721: LD_EXP 48
10725: PPUSH
10726: LD_STRING D2b-Sci1-1
10728: PPUSH
10729: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10733: LD_EXP 37
10737: PPUSH
10738: LD_STRING D2b-JMM-2
10740: PPUSH
10741: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10745: LD_EXP 48
10749: PPUSH
10750: LD_STRING D2b-Sci1-2
10752: PPUSH
10753: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10757: LD_EXP 37
10761: PPUSH
10762: LD_STRING D2b-JMM-3
10764: PPUSH
10765: CALL_OW 88
// end ; DialogueOff ;
10769: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10773: LD_STRING MOutSol
10775: PPUSH
10776: CALL_OW 337
// end ;
10780: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10781: LD_EXP 14
10785: PUSH
10786: LD_EXP 37
10790: PPUSH
10791: CALL_OW 302
10795: AND
10796: PUSH
10797: LD_EXP 37
10801: PPUSH
10802: CALL 966 0 1
10806: AND
10807: PUSH
10808: LD_EXP 16
10812: NOT
10813: AND
10814: IFFALSE 10885
10816: GO 10818
10818: DISABLE
10819: LD_INT 0
10821: PPUSH
// begin jmm_in_veh := true ;
10822: LD_ADDR_EXP 16
10826: PUSH
10827: LD_INT 1
10829: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10830: LD_ADDR_VAR 0 1
10834: PUSH
10835: LD_INT 0
10837: PPUSH
10838: LD_INT 1
10840: PPUSH
10841: CALL_OW 12
10845: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10846: LD_INT 70
10848: PPUSH
10849: CALL_OW 67
// if i then
10853: LD_VAR 0 1
10857: IFFALSE 10873
// Say ( JMM , D2c-JMM-1 ) else
10859: LD_EXP 37
10863: PPUSH
10864: LD_STRING D2c-JMM-1
10866: PPUSH
10867: CALL_OW 88
10871: GO 10885
// Say ( JMM , D2c-JMM-1a ) ;
10873: LD_EXP 37
10877: PPUSH
10878: LD_STRING D2c-JMM-1a
10880: PPUSH
10881: CALL_OW 88
// end ;
10885: PPOPN 1
10887: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10888: LD_EXP 14
10892: PUSH
10893: LD_EXP 38
10897: PPUSH
10898: CALL_OW 302
10902: AND
10903: PUSH
10904: LD_EXP 38
10908: PPUSH
10909: CALL 966 0 1
10913: AND
10914: PUSH
10915: LD_EXP 17
10919: NOT
10920: AND
10921: IFFALSE 10953
10923: GO 10925
10925: DISABLE
// begin bobby_in_veh := true ;
10926: LD_ADDR_EXP 17
10930: PUSH
10931: LD_INT 1
10933: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10934: LD_INT 70
10936: PPUSH
10937: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10941: LD_EXP 38
10945: PPUSH
10946: LD_STRING D2c-Bobby-1
10948: PPUSH
10949: CALL_OW 88
10953: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10954: LD_EXP 14
10958: PUSH
10959: LD_EXP 40
10963: PPUSH
10964: CALL_OW 302
10968: AND
10969: PUSH
10970: LD_EXP 40
10974: PPUSH
10975: CALL 966 0 1
10979: AND
10980: PUSH
10981: LD_EXP 19
10985: NOT
10986: AND
10987: IFFALSE 11019
10989: GO 10991
10991: DISABLE
// begin lisa_in_veh := true ;
10992: LD_ADDR_EXP 19
10996: PUSH
10997: LD_INT 1
10999: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11000: LD_INT 70
11002: PPUSH
11003: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
11007: LD_EXP 40
11011: PPUSH
11012: LD_STRING D2c-Lisa-1
11014: PPUSH
11015: CALL_OW 88
11019: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11020: LD_EXP 14
11024: PUSH
11025: LD_EXP 39
11029: PPUSH
11030: CALL_OW 302
11034: AND
11035: PUSH
11036: LD_EXP 39
11040: PPUSH
11041: CALL 966 0 1
11045: AND
11046: PUSH
11047: LD_EXP 18
11051: NOT
11052: AND
11053: IFFALSE 11124
11055: GO 11057
11057: DISABLE
11058: LD_INT 0
11060: PPUSH
// begin cyrus_in_veh := true ;
11061: LD_ADDR_EXP 18
11065: PUSH
11066: LD_INT 1
11068: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11069: LD_ADDR_VAR 0 1
11073: PUSH
11074: LD_INT 0
11076: PPUSH
11077: LD_INT 1
11079: PPUSH
11080: CALL_OW 12
11084: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11085: LD_INT 70
11087: PPUSH
11088: CALL_OW 67
// if i then
11092: LD_VAR 0 1
11096: IFFALSE 11112
// Say ( Cyrus , D2c-Cyrus-1 ) else
11098: LD_EXP 39
11102: PPUSH
11103: LD_STRING D2c-Cyrus-1
11105: PPUSH
11106: CALL_OW 88
11110: GO 11124
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11112: LD_EXP 39
11116: PPUSH
11117: LD_STRING D2c-Cyrus-1a
11119: PPUSH
11120: CALL_OW 88
// end ;
11124: PPOPN 1
11126: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11127: LD_EXP 44
11131: PPUSH
11132: LD_INT 16
11134: PPUSH
11135: CALL_OW 308
11139: IFFALSE 11420
11141: GO 11143
11143: DISABLE
11144: LD_INT 0
11146: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11147: LD_INT 3
11149: PPUSH
11150: LD_EXP 44
11154: PPUSH
11155: CALL_OW 471
// send_attack_on_cornel := true ;
11159: LD_ADDR_EXP 32
11163: PUSH
11164: LD_INT 1
11166: ST_TO_ADDR
// if ru_vehicles then
11167: LD_EXP 56
11171: IFFALSE 11205
// for i in ru_vehicles do
11173: LD_ADDR_VAR 0 1
11177: PUSH
11178: LD_EXP 56
11182: PUSH
11183: FOR_IN
11184: IFFALSE 11203
// ComAgressiveMove ( i , 215 , 69 ) ;
11186: LD_VAR 0 1
11190: PPUSH
11191: LD_INT 215
11193: PPUSH
11194: LD_INT 69
11196: PPUSH
11197: CALL_OW 114
11201: GO 11183
11203: POP
11204: POP
// if ru_patrol then
11205: LD_EXP 53
11209: IFFALSE 11243
// for i in ru_patrol do
11211: LD_ADDR_VAR 0 1
11215: PUSH
11216: LD_EXP 53
11220: PUSH
11221: FOR_IN
11222: IFFALSE 11241
// ComAgressiveMove ( i , 215 , 69 ) ;
11224: LD_VAR 0 1
11228: PPUSH
11229: LD_INT 215
11231: PPUSH
11232: LD_INT 69
11234: PPUSH
11235: CALL_OW 114
11239: GO 11221
11241: POP
11242: POP
// if frank_send_to_scout then
11243: LD_EXP 15
11247: IFFALSE 11261
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11249: LD_EXP 51
11253: PPUSH
11254: LD_STRING D3b-Frank-1
11256: PPUSH
11257: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11261: LD_INT 105
11263: PPUSH
11264: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11268: LD_EXP 44
11272: PPUSH
11273: LD_STRING D4-Corn-1
11275: PPUSH
11276: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11280: LD_INT 35
11282: PPUSH
11283: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11287: LD_INT 22
11289: PUSH
11290: LD_INT 4
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 21
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 3
11309: PUSH
11310: LD_INT 24
11312: PUSH
11313: LD_INT 1000
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: LIST
11328: PPUSH
11329: CALL_OW 69
11333: PUSH
11334: LD_INT 6
11336: LESS
11337: IFFALSE 11280
// if Cornel then
11339: LD_EXP 44
11343: IFFALSE 11383
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11345: LD_EXP 44
11349: PPUSH
11350: LD_STRING D5-Corn-1
11352: PPUSH
11353: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11357: LD_EXP 44
11361: PPUSH
11362: LD_EXP 2
11366: PUSH
11367: LD_STRING Cornel
11369: STR
11370: PPUSH
11371: CALL_OW 38
// cornel_saved := true ;
11375: LD_ADDR_EXP 27
11379: PUSH
11380: LD_INT 1
11382: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11383: LD_INT 4
11385: PPUSH
11386: LD_INT 8
11388: PPUSH
11389: CALL_OW 343
// Wait ( 0 0$01 ) ;
11393: LD_INT 35
11395: PPUSH
11396: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11400: LD_INT 3
11402: PPUSH
11403: LD_EXP 44
11407: PPUSH
11408: CALL_OW 472
// send_attack_on_cornel := false ;
11412: LD_ADDR_EXP 32
11416: PUSH
11417: LD_INT 0
11419: ST_TO_ADDR
// end ;
11420: PPOPN 1
11422: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11423: LD_INT 9
11425: PPUSH
11426: LD_INT 22
11428: PUSH
11429: LD_INT 1
11431: PUSH
11432: EMPTY
11433: LIST
11434: LIST
11435: PPUSH
11436: CALL_OW 70
11440: PUSH
11441: LD_EXP 33
11445: OR
11446: IFFALSE 11643
11448: GO 11450
11450: DISABLE
11451: LD_INT 0
11453: PPUSH
11454: PPUSH
// begin enable ;
11455: ENABLE
// if not jmm_on_west then
11456: LD_EXP 5
11460: NOT
11461: IFFALSE 11472
// begin YouLost ( 4 ) ;
11463: LD_STRING 4
11465: PPUSH
11466: CALL_OW 104
// exit ;
11470: GO 11643
// end ; if not game_end then
11472: LD_EXP 33
11476: NOT
11477: IFFALSE 11487
// game_end := true ;
11479: LD_ADDR_EXP 33
11483: PUSH
11484: LD_INT 1
11486: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11487: LD_ADDR_VAR 0 2
11491: PUSH
11492: LD_INT 9
11494: PPUSH
11495: LD_INT 22
11497: PUSH
11498: LD_INT 1
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: PPUSH
11505: CALL_OW 70
11509: ST_TO_ADDR
// if not filter then
11510: LD_VAR 0 2
11514: NOT
11515: IFFALSE 11519
// exit ;
11517: GO 11643
// for i in filter do
11519: LD_ADDR_VAR 0 1
11523: PUSH
11524: LD_VAR 0 2
11528: PUSH
11529: FOR_IN
11530: IFFALSE 11641
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11532: LD_VAR 0 1
11536: PPUSH
11537: CALL_OW 302
11541: PUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 247
11551: PUSH
11552: LD_INT 2
11554: EQUAL
11555: AND
11556: PUSH
11557: LD_VAR 0 1
11561: PPUSH
11562: CALL_OW 248
11566: PUSH
11567: LD_INT 1
11569: EQUAL
11570: AND
11571: IFFALSE 11604
// begin veh_on_meta := true ;
11573: LD_ADDR_EXP 28
11577: PUSH
11578: LD_INT 1
11580: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11581: LD_VAR 0 1
11585: PPUSH
11586: CALL_OW 311
11590: PPUSH
11591: CALL 11646 0 1
// RemoveUnit ( i ) ;
11595: LD_VAR 0 1
11599: PPUSH
11600: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11604: LD_VAR 0 1
11608: PPUSH
11609: CALL_OW 302
11613: PUSH
11614: LD_VAR 0 1
11618: PPUSH
11619: CALL_OW 247
11623: PUSH
11624: LD_INT 1
11626: EQUAL
11627: AND
11628: IFFALSE 11639
// Save ( i ) ;
11630: LD_VAR 0 1
11634: PPUSH
11635: CALL 11646 0 1
// end ;
11639: GO 11529
11641: POP
11642: POP
// end ;
11643: PPOPN 2
11645: END
// export function Save ( i ) ; begin
11646: LD_INT 0
11648: PPUSH
// save_counter := save_counter + 1 ;
11649: LD_ADDR_EXP 36
11653: PUSH
11654: LD_EXP 36
11658: PUSH
11659: LD_INT 1
11661: PLUS
11662: ST_TO_ADDR
// if i = JMM then
11663: LD_VAR 0 1
11667: PUSH
11668: LD_EXP 37
11672: EQUAL
11673: IFFALSE 11795
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11675: LD_EXP 24
11679: PUSH
11680: LD_INT 22
11682: PUSH
11683: LD_INT 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 21
11692: PUSH
11693: LD_INT 1
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PPUSH
11704: CALL_OW 69
11708: PUSH
11709: LD_INT 1
11711: GREATER
11712: AND
11713: IFFALSE 11770
// begin show_query := false ;
11715: LD_ADDR_EXP 24
11719: PUSH
11720: LD_INT 0
11722: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11723: LD_STRING Q2
11725: PPUSH
11726: CALL_OW 97
11730: PUSH
11731: LD_INT 1
11733: DOUBLE
11734: EQUAL
11735: IFTRUE 11739
11737: GO 11750
11739: POP
// wait_for_them := true ; 2 :
11740: LD_ADDR_EXP 25
11744: PUSH
11745: LD_INT 1
11747: ST_TO_ADDR
11748: GO 11770
11750: LD_INT 2
11752: DOUBLE
11753: EQUAL
11754: IFTRUE 11758
11756: GO 11769
11758: POP
// wait_for_them := false ; end ;
11759: LD_ADDR_EXP 25
11763: PUSH
11764: LD_INT 0
11766: ST_TO_ADDR
11767: GO 11770
11769: POP
// end ; save_group := save_group ^ JMM ;
11770: LD_ADDR_EXP 23
11774: PUSH
11775: LD_EXP 23
11779: PUSH
11780: LD_EXP 37
11784: ADD
11785: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11786: LD_EXP 37
11790: PPUSH
11791: CALL_OW 64
// end ; if i = Lisa then
11795: LD_VAR 0 1
11799: PUSH
11800: LD_EXP 40
11804: EQUAL
11805: IFFALSE 11832
// begin save_group := save_group ^ Lisa ;
11807: LD_ADDR_EXP 23
11811: PUSH
11812: LD_EXP 23
11816: PUSH
11817: LD_EXP 40
11821: ADD
11822: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11823: LD_EXP 40
11827: PPUSH
11828: CALL_OW 64
// end ; if i = Bobby then
11832: LD_VAR 0 1
11836: PUSH
11837: LD_EXP 38
11841: EQUAL
11842: IFFALSE 11869
// begin save_group := save_group ^ Bobby ;
11844: LD_ADDR_EXP 23
11848: PUSH
11849: LD_EXP 23
11853: PUSH
11854: LD_EXP 38
11858: ADD
11859: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11860: LD_EXP 38
11864: PPUSH
11865: CALL_OW 64
// end ; if i = Cyrus then
11869: LD_VAR 0 1
11873: PUSH
11874: LD_EXP 39
11878: EQUAL
11879: IFFALSE 11906
// begin save_group := save_group ^ Cyrus ;
11881: LD_ADDR_EXP 23
11885: PUSH
11886: LD_EXP 23
11890: PUSH
11891: LD_EXP 39
11895: ADD
11896: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11897: LD_EXP 39
11901: PPUSH
11902: CALL_OW 64
// end ; if i = Khatam then
11906: LD_VAR 0 1
11910: PUSH
11911: LD_EXP 41
11915: EQUAL
11916: IFFALSE 11943
// begin save_group := save_group ^ Khatam ;
11918: LD_ADDR_EXP 23
11922: PUSH
11923: LD_EXP 23
11927: PUSH
11928: LD_EXP 41
11932: ADD
11933: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11934: LD_EXP 41
11938: PPUSH
11939: CALL_OW 64
// end ; if i = Frank then
11943: LD_VAR 0 1
11947: PUSH
11948: LD_EXP 51
11952: EQUAL
11953: IFFALSE 11980
// begin save_group := save_group ^ Frank ;
11955: LD_ADDR_EXP 23
11959: PUSH
11960: LD_EXP 23
11964: PUSH
11965: LD_EXP 51
11969: ADD
11970: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11971: LD_EXP 51
11975: PPUSH
11976: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11980: LD_VAR 0 1
11984: PPUSH
11985: CALL_OW 302
11989: PUSH
11990: LD_VAR 0 1
11994: PPUSH
11995: CALL_OW 247
11999: PUSH
12000: LD_INT 1
12002: EQUAL
12003: AND
12004: PUSH
12005: LD_VAR 0 1
12009: PUSH
12010: LD_EXP 23
12014: IN
12015: NOT
12016: AND
12017: IFFALSE 12044
// begin save_others := save_others ^ i ;
12019: LD_ADDR_EXP 22
12023: PUSH
12024: LD_EXP 22
12028: PUSH
12029: LD_VAR 0 1
12033: ADD
12034: ST_TO_ADDR
// RemoveUnit ( i ) ;
12035: LD_VAR 0 1
12039: PPUSH
12040: CALL_OW 64
// end ; end ;
12044: LD_VAR 0 2
12048: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12049: LD_EXP 24
12053: NOT
12054: PUSH
12055: LD_EXP 25
12059: NOT
12060: AND
12061: PUSH
12062: LD_INT 22
12064: PUSH
12065: LD_INT 1
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: LD_INT 21
12074: PUSH
12075: LD_INT 1
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PPUSH
12086: CALL_OW 69
12090: PUSH
12091: LD_INT 0
12093: EQUAL
12094: OR
12095: IFFALSE 12104
12097: GO 12099
12099: DISABLE
// EndMission ;
12100: CALL 12105 0 0
12104: END
// export function EndMission ; var i , m1 , m2 , m3 ; begin
12105: LD_INT 0
12107: PPUSH
12108: PPUSH
12109: PPUSH
12110: PPUSH
12111: PPUSH
// Wait ( 0 0$02 ) ;
12112: LD_INT 70
12114: PPUSH
12115: CALL_OW 67
// if tick <= 10 10$00 then
12119: LD_OWVAR 1
12123: PUSH
12124: LD_INT 21000
12126: LESSEQUAL
12127: IFFALSE 12136
// SetAchievement ( ACH_ASPEED_3 ) ;
12129: LD_STRING ACH_ASPEED_3
12131: PPUSH
12132: CALL_OW 543
// m1 := solar_builded ;
12136: LD_ADDR_VAR 0 3
12140: PUSH
12141: LD_EXP 14
12145: ST_TO_ADDR
// m2 := veh_on_meta ;
12146: LD_ADDR_VAR 0 4
12150: PUSH
12151: LD_EXP 28
12155: ST_TO_ADDR
// m3 := ( lose_counter = 0 ) ;
12156: LD_ADDR_VAR 0 5
12160: PUSH
12161: LD_EXP 34
12165: PUSH
12166: LD_INT 0
12168: EQUAL
12169: ST_TO_ADDR
// if solar_builded then
12170: LD_EXP 14
12174: IFFALSE 12188
// AddMedal ( Solar1 , 1 ) else
12176: LD_STRING Solar1
12178: PPUSH
12179: LD_INT 1
12181: PPUSH
12182: CALL_OW 101
12186: GO 12199
// AddMedal ( Solar1 , - 1 ) ;
12188: LD_STRING Solar1
12190: PPUSH
12191: LD_INT 1
12193: NEG
12194: PPUSH
12195: CALL_OW 101
// if veh_on_meta then
12199: LD_EXP 28
12203: IFFALSE 12217
// AddMedal ( Solar2 , 1 ) else
12205: LD_STRING Solar2
12207: PPUSH
12208: LD_INT 1
12210: PPUSH
12211: CALL_OW 101
12215: GO 12247
// if solar_builded then
12217: LD_EXP 14
12221: IFFALSE 12236
// AddMedal ( Solar2 , - 1 ) else
12223: LD_STRING Solar2
12225: PPUSH
12226: LD_INT 1
12228: NEG
12229: PPUSH
12230: CALL_OW 101
12234: GO 12247
// AddMedal ( Solar2 , - 2 ) ;
12236: LD_STRING Solar2
12238: PPUSH
12239: LD_INT 2
12241: NEG
12242: PPUSH
12243: CALL_OW 101
// if lose_counter = 0 then
12247: LD_EXP 34
12251: PUSH
12252: LD_INT 0
12254: EQUAL
12255: IFFALSE 12269
// AddMedal ( No , 1 ) else
12257: LD_STRING No
12259: PPUSH
12260: LD_INT 1
12262: PPUSH
12263: CALL_OW 101
12267: GO 12313
// if lose_counter > 0 and lose_counter < 4 then
12269: LD_EXP 34
12273: PUSH
12274: LD_INT 0
12276: GREATER
12277: PUSH
12278: LD_EXP 34
12282: PUSH
12283: LD_INT 4
12285: LESS
12286: AND
12287: IFFALSE 12302
// AddMedal ( No , - 1 ) else
12289: LD_STRING No
12291: PPUSH
12292: LD_INT 1
12294: NEG
12295: PPUSH
12296: CALL_OW 101
12300: GO 12313
// AddMedal ( UpTo4 , - 1 ) ;
12302: LD_STRING UpTo4
12304: PPUSH
12305: LD_INT 1
12307: NEG
12308: PPUSH
12309: CALL_OW 101
// GiveMedals ( MAIN ) ;
12313: LD_STRING MAIN
12315: PPUSH
12316: CALL_OW 102
// if Difficulty = 3 and m1 and m2 and m3 then
12320: LD_OWVAR 67
12324: PUSH
12325: LD_INT 3
12327: EQUAL
12328: PUSH
12329: LD_VAR 0 3
12333: AND
12334: PUSH
12335: LD_VAR 0 4
12339: AND
12340: PUSH
12341: LD_VAR 0 5
12345: AND
12346: IFFALSE 12358
// SetAchievementEX ( ACH_AMER , 3 ) ;
12348: LD_STRING ACH_AMER
12350: PPUSH
12351: LD_INT 3
12353: PPUSH
12354: CALL_OW 564
// if IsDead ( Pokryshkin ) then
12358: LD_EXP 52
12362: PPUSH
12363: CALL_OW 301
12367: IFFALSE 12423
// begin stop_talking := true ;
12369: LD_ADDR_OWVAR 56
12373: PUSH
12374: LD_INT 1
12376: ST_TO_ADDR
// for i in save_group ^ save_others do
12377: LD_ADDR_VAR 0 2
12381: PUSH
12382: LD_EXP 23
12386: PUSH
12387: LD_EXP 22
12391: ADD
12392: PUSH
12393: FOR_IN
12394: IFFALSE 12413
// AddExperience ( i , skill_combat , 1500 ) ;
12396: LD_VAR 0 2
12400: PPUSH
12401: LD_INT 1
12403: PPUSH
12404: LD_INT 1500
12406: PPUSH
12407: CALL_OW 492
12411: GO 12393
12413: POP
12414: POP
// stop_talking := false ;
12415: LD_ADDR_OWVAR 56
12419: PUSH
12420: LD_INT 0
12422: ST_TO_ADDR
// end ; RewardPeople ( save_group ^ save_others ) ;
12423: LD_EXP 23
12427: PUSH
12428: LD_EXP 22
12432: ADD
12433: PPUSH
12434: CALL_OW 43
// if UnitFilter ( save_group ^ save_others , [ f_class , 4 ] ) = 0 then
12438: LD_EXP 23
12442: PUSH
12443: LD_EXP 22
12447: ADD
12448: PPUSH
12449: LD_INT 25
12451: PUSH
12452: LD_INT 4
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PPUSH
12459: CALL_OW 72
12463: PUSH
12464: LD_INT 0
12466: EQUAL
12467: IFFALSE 12476
// SetAchievement ( ACH_NOSCI ) ;
12469: LD_STRING ACH_NOSCI
12471: PPUSH
12472: CALL_OW 543
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12476: LD_EXP 37
12480: PPUSH
12481: LD_EXP 2
12485: PUSH
12486: LD_STRING JMM
12488: STR
12489: PPUSH
12490: CALL_OW 38
// if Bobby in save_group then
12494: LD_EXP 38
12498: PUSH
12499: LD_EXP 23
12503: IN
12504: IFFALSE 12524
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12506: LD_EXP 38
12510: PPUSH
12511: LD_EXP 2
12515: PUSH
12516: LD_STRING Bobby
12518: STR
12519: PPUSH
12520: CALL_OW 38
// if Cyrus in save_group then
12524: LD_EXP 39
12528: PUSH
12529: LD_EXP 23
12533: IN
12534: IFFALSE 12554
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12536: LD_EXP 39
12540: PPUSH
12541: LD_EXP 2
12545: PUSH
12546: LD_STRING Cyrus
12548: STR
12549: PPUSH
12550: CALL_OW 38
// if Lisa in save_group then
12554: LD_EXP 40
12558: PUSH
12559: LD_EXP 23
12563: IN
12564: IFFALSE 12584
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12566: LD_EXP 40
12570: PPUSH
12571: LD_EXP 2
12575: PUSH
12576: LD_STRING Lisa
12578: STR
12579: PPUSH
12580: CALL_OW 38
// if Frank in save_group then
12584: LD_EXP 51
12588: PUSH
12589: LD_EXP 23
12593: IN
12594: IFFALSE 12614
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12596: LD_EXP 51
12600: PPUSH
12601: LD_EXP 2
12605: PUSH
12606: LD_STRING Frank
12608: STR
12609: PPUSH
12610: CALL_OW 38
// if Khatam in save_group then
12614: LD_EXP 41
12618: PUSH
12619: LD_EXP 23
12623: IN
12624: IFFALSE 12644
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12626: LD_EXP 41
12630: PPUSH
12631: LD_EXP 2
12635: PUSH
12636: LD_STRING Khatam
12638: STR
12639: PPUSH
12640: CALL_OW 38
// if save_others then
12644: LD_EXP 22
12648: IFFALSE 12662
// SaveCharacters ( save_others , 03_others ) ;
12650: LD_EXP 22
12654: PPUSH
12655: LD_STRING 03_others
12657: PPUSH
12658: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12662: LD_EXP 45
12666: PUSH
12667: LD_EXP 45
12671: PPUSH
12672: CALL_OW 302
12676: AND
12677: PUSH
12678: LD_EXP 27
12682: AND
12683: IFFALSE 12695
// begin ResetFog ;
12685: CALL_OW 335
// DisplayEndingScene ;
12689: CALL 12717 0 0
// end else
12693: GO 12708
// DeleteCharacters ( mission_prefix & Cornel ) ;
12695: LD_EXP 2
12699: PUSH
12700: LD_STRING Cornel
12702: STR
12703: PPUSH
12704: CALL_OW 40
// YouWin ;
12708: CALL_OW 103
// end ;
12712: LD_VAR 0 1
12716: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12717: LD_INT 0
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
12724: PPUSH
// InGameOn ;
12725: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12729: LD_INT 208
12731: PPUSH
12732: LD_INT 62
12734: PPUSH
12735: LD_INT 1
12737: PPUSH
12738: LD_INT 10
12740: NEG
12741: PPUSH
12742: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12746: LD_INT 208
12748: PPUSH
12749: LD_INT 62
12751: PPUSH
12752: LD_INT 1
12754: PPUSH
12755: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12759: LD_ADDR_VAR 0 3
12763: PUSH
12764: LD_INT 22
12766: PUSH
12767: LD_INT 3
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 2
12776: PUSH
12777: LD_INT 21
12779: PUSH
12780: LD_INT 2
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: LD_INT 21
12789: PUSH
12790: LD_INT 1
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: LIST
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PPUSH
12806: CALL_OW 69
12810: ST_TO_ADDR
// if filter then
12811: LD_VAR 0 3
12815: IFFALSE 12843
// for i in filter do
12817: LD_ADDR_VAR 0 2
12821: PUSH
12822: LD_VAR 0 3
12826: PUSH
12827: FOR_IN
12828: IFFALSE 12841
// RemoveUnit ( i ) ;
12830: LD_VAR 0 2
12834: PPUSH
12835: CALL_OW 64
12839: GO 12827
12841: POP
12842: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12843: LD_ADDR_VAR 0 3
12847: PUSH
12848: LD_INT 22
12850: PUSH
12851: LD_INT 4
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: LD_INT 21
12860: PUSH
12861: LD_INT 1
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PUSH
12868: EMPTY
12869: LIST
12870: LIST
12871: PPUSH
12872: CALL_OW 69
12876: ST_TO_ADDR
// if filter then
12877: LD_VAR 0 3
12881: IFFALSE 12912
// for i in filter do
12883: LD_ADDR_VAR 0 2
12887: PUSH
12888: LD_VAR 0 3
12892: PUSH
12893: FOR_IN
12894: IFFALSE 12910
// SetLives ( i , 0 ) ;
12896: LD_VAR 0 2
12900: PPUSH
12901: LD_INT 0
12903: PPUSH
12904: CALL_OW 234
12908: GO 12893
12910: POP
12911: POP
// uc_side := 4 ;
12912: LD_ADDR_OWVAR 20
12916: PUSH
12917: LD_INT 4
12919: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12920: LD_ADDR_VAR 0 4
12924: PUSH
12925: LD_STRING Cornell
12927: PPUSH
12928: LD_INT 0
12930: PPUSH
12931: CALL 489 0 2
12935: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12936: LD_VAR 0 4
12940: PPUSH
12941: LD_INT 208
12943: PPUSH
12944: LD_INT 62
12946: PPUSH
12947: LD_INT 0
12949: PPUSH
12950: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12954: LD_VAR 0 4
12958: PPUSH
12959: LD_INT 100
12961: PPUSH
12962: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12966: LD_INT 3
12968: PPUSH
12969: LD_VAR 0 4
12973: PPUSH
12974: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12978: LD_INT 4
12980: PPUSH
12981: LD_INT 3
12983: PPUSH
12984: LD_INT 1
12986: PPUSH
12987: LD_INT 1
12989: PPUSH
12990: CALL_OW 80
// uc_side := 3 ;
12994: LD_ADDR_OWVAR 20
12998: PUSH
12999: LD_INT 3
13001: ST_TO_ADDR
// uc_nation := 3 ;
13002: LD_ADDR_OWVAR 21
13006: PUSH
13007: LD_INT 3
13009: ST_TO_ADDR
// InitHc ;
13010: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
13014: LD_ADDR_VAR 0 5
13018: PUSH
13019: LD_STRING Mikhail
13021: PPUSH
13022: LD_INT 0
13024: PPUSH
13025: CALL 489 0 2
13029: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
13030: LD_INT 1
13032: PPUSH
13033: LD_INT 1
13035: PPUSH
13036: LD_INT 0
13038: PPUSH
13039: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13043: LD_ADDR_VAR 0 6
13047: PUSH
13048: LD_VAR 0 6
13052: PUSH
13053: CALL_OW 44
13057: ADD
13058: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
13059: LD_ADDR_VAR 0 6
13063: PUSH
13064: LD_VAR 0 6
13068: PUSH
13069: CALL_OW 44
13073: ADD
13074: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
13075: LD_INT 2
13077: PPUSH
13078: LD_INT 4
13080: PPUSH
13081: LD_INT 0
13083: PPUSH
13084: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
13088: LD_ADDR_VAR 0 6
13092: PUSH
13093: LD_VAR 0 6
13097: PUSH
13098: CALL_OW 44
13102: ADD
13103: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
13104: LD_VAR 0 5
13108: PPUSH
13109: LD_INT 17
13111: PPUSH
13112: LD_INT 0
13114: PPUSH
13115: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
13119: LD_VAR 0 5
13123: PPUSH
13124: LD_INT 210
13126: PPUSH
13127: LD_INT 63
13129: PPUSH
13130: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
13134: LD_VAR 0 5
13138: PPUSH
13139: LD_INT 208
13141: PPUSH
13142: LD_INT 62
13144: PPUSH
13145: CALL_OW 178
// for i in fake_russians do
13149: LD_ADDR_VAR 0 2
13153: PUSH
13154: LD_VAR 0 6
13158: PUSH
13159: FOR_IN
13160: IFFALSE 13238
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13162: LD_VAR 0 2
13166: PPUSH
13167: LD_INT 17
13169: PPUSH
13170: LD_INT 0
13172: PPUSH
13173: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13177: LD_VAR 0 2
13181: PPUSH
13182: LD_INT 215
13184: PPUSH
13185: LD_INT 67
13187: PPUSH
13188: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13192: LD_VAR 0 2
13196: PPUSH
13197: LD_INT 208
13199: PPUSH
13200: LD_INT 62
13202: PPUSH
13203: CALL_OW 178
// if GetClass ( i ) = 4 then
13207: LD_VAR 0 2
13211: PPUSH
13212: CALL_OW 257
13216: PUSH
13217: LD_INT 4
13219: EQUAL
13220: IFFALSE 13236
// ComHeal ( i , fake_cornel ) ;
13222: LD_VAR 0 2
13226: PPUSH
13227: LD_VAR 0 4
13231: PPUSH
13232: CALL_OW 128
// end ;
13236: GO 13159
13238: POP
13239: POP
// Wait ( 0 0$01 ) ;
13240: LD_INT 35
13242: PPUSH
13243: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13247: LD_INT 208
13249: PPUSH
13250: LD_INT 62
13252: PPUSH
13253: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13257: LD_INT 208
13259: PPUSH
13260: LD_INT 62
13262: PPUSH
13263: LD_INT 1
13265: PPUSH
13266: LD_INT 10
13268: NEG
13269: PPUSH
13270: CALL_OW 330
// Wait ( 0 0$15 ) ;
13274: LD_INT 525
13276: PPUSH
13277: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13281: LD_INT 208
13283: PPUSH
13284: LD_INT 62
13286: PPUSH
13287: LD_INT 1
13289: PPUSH
13290: CALL_OW 331
// ResetFog ;
13294: CALL_OW 335
// InGameOff ;
13298: CALL_OW 9
// end ;
13302: LD_VAR 0 1
13306: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13307: LD_INT 10
13309: PPUSH
13310: LD_INT 22
13312: PUSH
13313: LD_INT 1
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PPUSH
13320: CALL_OW 70
13324: PUSH
13325: LD_EXP 44
13329: PPUSH
13330: CALL_OW 302
13334: AND
13335: PUSH
13336: LD_INT 22
13338: PUSH
13339: LD_INT 1
13341: PUSH
13342: EMPTY
13343: LIST
13344: LIST
13345: PPUSH
13346: CALL_OW 69
13350: PPUSH
13351: LD_EXP 44
13355: PPUSH
13356: CALL_OW 74
13360: PPUSH
13361: LD_EXP 44
13365: PPUSH
13366: CALL_OW 296
13370: PUSH
13371: LD_INT 30
13373: LESS
13374: OR
13375: IFFALSE 13426
13377: GO 13379
13379: DISABLE
// begin enable ;
13380: ENABLE
// powell_warn := powell_warn + 1 ;
13381: LD_ADDR_EXP 35
13385: PUSH
13386: LD_EXP 35
13390: PUSH
13391: LD_INT 1
13393: PLUS
13394: ST_TO_ADDR
// if powell_warn = 3 then
13395: LD_EXP 35
13399: PUSH
13400: LD_INT 3
13402: EQUAL
13403: IFFALSE 13414
// begin YouLost ( 5 ) ;
13405: LD_STRING 5
13407: PPUSH
13408: CALL_OW 104
// exit ;
13412: GO 13426
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13414: LD_EXP 46
13418: PPUSH
13419: LD_STRING DWarn-Pow-1
13421: PPUSH
13422: CALL_OW 94
// end ; end_of_file
13426: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13427: LD_EXP 8
13431: IFFALSE 15268
13433: GO 13435
13435: DISABLE
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
13444: PPUSH
13445: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13446: LD_EXP 44
13450: PUSH
13451: LD_EXP 45
13455: ADD
13456: PUSH
13457: LD_EXP 6
13461: ADD
13462: PPUSH
13463: LD_INT 250
13465: PPUSH
13466: LD_INT 120
13468: PPUSH
13469: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13473: LD_ADDR_VAR 0 2
13477: PUSH
13478: LD_EXP 6
13482: PPUSH
13483: LD_INT 25
13485: PUSH
13486: LD_INT 2
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: PPUSH
13493: CALL_OW 72
13497: PUSH
13498: LD_EXP 45
13502: DIFF
13503: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13504: LD_ADDR_VAR 0 3
13508: PUSH
13509: LD_EXP 6
13513: PPUSH
13514: LD_INT 21
13516: PUSH
13517: LD_INT 1
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 72
13528: PUSH
13529: LD_VAR 0 2
13533: DIFF
13534: ST_TO_ADDR
// if not has_eng then
13535: LD_VAR 0 2
13539: NOT
13540: IFFALSE 13623
// begin uc_side := 4 ;
13542: LD_ADDR_OWVAR 20
13546: PUSH
13547: LD_INT 4
13549: ST_TO_ADDR
// uc_nation := 1 ;
13550: LD_ADDR_OWVAR 21
13554: PUSH
13555: LD_INT 1
13557: ST_TO_ADDR
// bc_type := b_depot ;
13558: LD_ADDR_OWVAR 42
13562: PUSH
13563: LD_INT 0
13565: ST_TO_ADDR
// bc_level := 2 ;
13566: LD_ADDR_OWVAR 43
13570: PUSH
13571: LD_INT 2
13573: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13574: LD_ADDR_VAR 0 4
13578: PUSH
13579: LD_INT 264
13581: PPUSH
13582: LD_INT 120
13584: PPUSH
13585: LD_INT 4
13587: PPUSH
13588: CALL_OW 47
13592: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13593: LD_INT 264
13595: PPUSH
13596: LD_INT 120
13598: PPUSH
13599: LD_INT 4
13601: PPUSH
13602: LD_INT 10
13604: NEG
13605: PPUSH
13606: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13610: LD_INT 264
13612: PPUSH
13613: LD_INT 120
13615: PPUSH
13616: LD_INT 4
13618: PPUSH
13619: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13623: LD_INT 35
13625: PPUSH
13626: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13630: LD_EXP 44
13634: PPUSH
13635: LD_INT 10
13637: PPUSH
13638: CALL_OW 308
13642: PUSH
13643: LD_EXP 44
13647: PPUSH
13648: CALL_OW 310
13652: PPUSH
13653: LD_INT 10
13655: PPUSH
13656: CALL_OW 308
13660: OR
13661: IFFALSE 13623
// if has_eng and not dep then
13663: LD_VAR 0 2
13667: PUSH
13668: LD_VAR 0 4
13672: NOT
13673: AND
13674: IFFALSE 13824
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13676: LD_VAR 0 2
13680: PPUSH
13681: LD_INT 0
13683: PPUSH
13684: LD_INT 264
13686: PPUSH
13687: LD_INT 120
13689: PPUSH
13690: LD_INT 4
13692: PPUSH
13693: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13697: LD_INT 35
13699: PPUSH
13700: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13704: LD_INT 22
13706: PUSH
13707: LD_INT 4
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: PUSH
13714: LD_INT 30
13716: PUSH
13717: LD_INT 0
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PPUSH
13728: CALL_OW 69
13732: IFFALSE 13697
// ComMoveXY ( filter , 264 , 120 ) ;
13734: LD_VAR 0 3
13738: PPUSH
13739: LD_INT 264
13741: PPUSH
13742: LD_INT 120
13744: PPUSH
13745: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13749: LD_INT 35
13751: PPUSH
13752: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13756: LD_INT 22
13758: PUSH
13759: LD_INT 4
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: PUSH
13766: LD_INT 30
13768: PUSH
13769: LD_INT 0
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PUSH
13776: LD_INT 3
13778: PUSH
13779: LD_INT 57
13781: PUSH
13782: EMPTY
13783: LIST
13784: PUSH
13785: EMPTY
13786: LIST
13787: LIST
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: LIST
13793: PPUSH
13794: CALL_OW 69
13798: IFFALSE 13749
// ComMoveXY ( filter , 247 , 113 ) ;
13800: LD_VAR 0 3
13804: PPUSH
13805: LD_INT 247
13807: PPUSH
13808: LD_INT 113
13810: PPUSH
13811: CALL_OW 111
// Wait ( 0 0$2 ) ;
13815: LD_INT 70
13817: PPUSH
13818: CALL_OW 67
// end else
13822: GO 13836
// begin SetSide ( dep , 4 ) ;
13824: LD_VAR 0 4
13828: PPUSH
13829: LD_INT 4
13831: PPUSH
13832: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13836: LD_ADDR_VAR 0 4
13840: PUSH
13841: LD_INT 22
13843: PUSH
13844: LD_INT 4
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: LD_INT 30
13853: PUSH
13854: LD_INT 0
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: PPUSH
13865: CALL_OW 69
13869: PUSH
13870: LD_INT 1
13872: ARRAY
13873: ST_TO_ADDR
// if not has_eng then
13874: LD_VAR 0 2
13878: NOT
13879: IFFALSE 13966
// for i = 1 to 2 do
13881: LD_ADDR_VAR 0 1
13885: PUSH
13886: DOUBLE
13887: LD_INT 1
13889: DEC
13890: ST_TO_ADDR
13891: LD_INT 2
13893: PUSH
13894: FOR_TO
13895: IFFALSE 13964
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13897: LD_VAR 0 3
13901: PUSH
13902: LD_INT 1
13904: ARRAY
13905: PPUSH
13906: LD_VAR 0 4
13910: PPUSH
13911: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13915: LD_VAR 0 3
13919: PUSH
13920: LD_INT 1
13922: ARRAY
13923: PPUSH
13924: LD_INT 2
13926: PPUSH
13927: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13931: LD_VAR 0 3
13935: PUSH
13936: LD_INT 1
13938: ARRAY
13939: PPUSH
13940: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
13944: LD_ADDR_VAR 0 3
13948: PUSH
13949: LD_VAR 0 3
13953: PPUSH
13954: LD_INT 1
13956: PPUSH
13957: CALL_OW 3
13961: ST_TO_ADDR
// end ;
13962: GO 13894
13964: POP
13965: POP
// if IsInUnit ( Cornel ) then
13966: LD_EXP 44
13970: PPUSH
13971: CALL_OW 310
13975: IFFALSE 14053
// begin cargo := IsInUnit ( Cornel ) ;
13977: LD_ADDR_VAR 0 7
13981: PUSH
13982: LD_EXP 44
13986: PPUSH
13987: CALL_OW 310
13991: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13992: LD_VAR 0 7
13996: PPUSH
13997: LD_INT 1
13999: PPUSH
14000: CALL_OW 289
14004: IFFALSE 14015
// ComUnload ( cargo ) ;
14006: LD_VAR 0 7
14010: PPUSH
14011: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
14015: LD_EXP 44
14019: PPUSH
14020: LD_INT 235
14022: PPUSH
14023: LD_INT 122
14025: PPUSH
14026: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
14030: LD_EXP 44
14034: PPUSH
14035: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
14039: LD_EXP 44
14043: PPUSH
14044: LD_VAR 0 4
14048: PPUSH
14049: CALL_OW 180
// end ; if Bierezov then
14053: LD_EXP 45
14057: IFFALSE 14105
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
14059: LD_EXP 45
14063: PPUSH
14064: LD_INT 260
14066: PPUSH
14067: LD_INT 120
14069: PPUSH
14070: CALL_OW 111
// if dep then
14074: LD_VAR 0 4
14078: IFFALSE 14096
// AddComEnterUnit ( Bierezov , dep ) else
14080: LD_EXP 45
14084: PPUSH
14085: LD_VAR 0 4
14089: PPUSH
14090: CALL_OW 180
14094: GO 14105
// AddComHold ( Bierezov ) ;
14096: LD_EXP 45
14100: PPUSH
14101: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
14105: LD_INT 525
14107: PPUSH
14108: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
14112: LD_ADDR_VAR 0 2
14116: PUSH
14117: LD_INT 22
14119: PUSH
14120: LD_INT 4
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: PUSH
14127: LD_INT 25
14129: PUSH
14130: LD_INT 2
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PPUSH
14141: CALL_OW 69
14145: PUSH
14146: LD_EXP 45
14150: DIFF
14151: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14152: LD_INT 35
14154: PPUSH
14155: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14159: LD_ADDR_VAR 0 6
14163: PUSH
14164: LD_INT 10
14166: PPUSH
14167: CALL_OW 435
14171: ST_TO_ADDR
// if crates then
14172: LD_VAR 0 6
14176: IFFALSE 14205
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14178: LD_VAR 0 2
14182: PPUSH
14183: LD_VAR 0 6
14187: PUSH
14188: LD_INT 1
14190: ARRAY
14191: PPUSH
14192: LD_VAR 0 6
14196: PUSH
14197: LD_INT 2
14199: ARRAY
14200: PPUSH
14201: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14205: LD_VAR 0 4
14209: PPUSH
14210: CALL_OW 274
14214: PPUSH
14215: LD_INT 1
14217: PPUSH
14218: CALL_OW 275
14222: PUSH
14223: LD_INT 40
14225: GREATEREQUAL
14226: IFFALSE 14152
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14228: LD_ADDR_VAR 0 5
14232: PUSH
14233: LD_INT 4
14235: PUSH
14236: LD_INT 256
14238: PUSH
14239: LD_INT 111
14241: PUSH
14242: LD_INT 2
14244: PUSH
14245: EMPTY
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: PUSH
14251: LD_INT 31
14253: PUSH
14254: LD_INT 243
14256: PUSH
14257: LD_INT 112
14259: PUSH
14260: LD_INT 2
14262: PUSH
14263: EMPTY
14264: LIST
14265: LIST
14266: LIST
14267: LIST
14268: PUSH
14269: LD_INT 31
14271: PUSH
14272: LD_INT 254
14274: PUSH
14275: LD_INT 114
14277: PUSH
14278: LD_INT 2
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: LIST
14291: ST_TO_ADDR
// for i in blist do
14292: LD_ADDR_VAR 0 1
14296: PUSH
14297: LD_VAR 0 5
14301: PUSH
14302: FOR_IN
14303: IFFALSE 14352
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14305: LD_VAR 0 2
14309: PPUSH
14310: LD_VAR 0 1
14314: PUSH
14315: LD_INT 1
14317: ARRAY
14318: PPUSH
14319: LD_VAR 0 1
14323: PUSH
14324: LD_INT 2
14326: ARRAY
14327: PPUSH
14328: LD_VAR 0 1
14332: PUSH
14333: LD_INT 3
14335: ARRAY
14336: PPUSH
14337: LD_VAR 0 1
14341: PUSH
14342: LD_INT 4
14344: ARRAY
14345: PPUSH
14346: CALL_OW 205
14350: GO 14302
14352: POP
14353: POP
// repeat wait ( 0 0$01 ) ;
14354: LD_INT 35
14356: PPUSH
14357: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14361: LD_INT 22
14363: PUSH
14364: LD_INT 4
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: PUSH
14371: LD_INT 30
14373: PUSH
14374: LD_INT 4
14376: PUSH
14377: EMPTY
14378: LIST
14379: LIST
14380: PUSH
14381: LD_INT 3
14383: PUSH
14384: LD_INT 57
14386: PUSH
14387: EMPTY
14388: LIST
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: LIST
14398: PPUSH
14399: CALL_OW 69
14403: IFFALSE 14354
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14405: LD_VAR 0 3
14409: PPUSH
14410: LD_INT 22
14412: PUSH
14413: LD_INT 4
14415: PUSH
14416: EMPTY
14417: LIST
14418: LIST
14419: PUSH
14420: LD_INT 30
14422: PUSH
14423: LD_INT 4
14425: PUSH
14426: EMPTY
14427: LIST
14428: LIST
14429: PUSH
14430: EMPTY
14431: LIST
14432: LIST
14433: PPUSH
14434: CALL_OW 69
14438: PUSH
14439: LD_INT 1
14441: ARRAY
14442: PPUSH
14443: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14447: LD_VAR 0 3
14451: PPUSH
14452: LD_INT 1
14454: PPUSH
14455: CALL_OW 183
// if has_eng > 1 then
14459: LD_VAR 0 2
14463: PUSH
14464: LD_INT 1
14466: GREATER
14467: IFFALSE 14609
// for i = has_eng downto 2 do
14469: LD_ADDR_VAR 0 1
14473: PUSH
14474: DOUBLE
14475: LD_VAR 0 2
14479: INC
14480: ST_TO_ADDR
14481: LD_INT 2
14483: PUSH
14484: FOR_DOWNTO
14485: IFFALSE 14607
// begin if IsInUnit ( has_eng [ i ] ) then
14487: LD_VAR 0 2
14491: PUSH
14492: LD_VAR 0 1
14496: ARRAY
14497: PPUSH
14498: CALL_OW 310
14502: IFFALSE 14519
// ComExitBuilding ( has_eng [ i ] ) ;
14504: LD_VAR 0 2
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PPUSH
14515: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14519: LD_VAR 0 2
14523: PUSH
14524: LD_VAR 0 1
14528: ARRAY
14529: PPUSH
14530: LD_INT 22
14532: PUSH
14533: LD_INT 4
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PUSH
14540: LD_INT 30
14542: PUSH
14543: LD_INT 4
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PUSH
14550: EMPTY
14551: LIST
14552: LIST
14553: PPUSH
14554: CALL_OW 69
14558: PUSH
14559: LD_INT 1
14561: ARRAY
14562: PPUSH
14563: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14567: LD_VAR 0 2
14571: PUSH
14572: LD_VAR 0 1
14576: ARRAY
14577: PPUSH
14578: LD_INT 1
14580: PPUSH
14581: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14585: LD_ADDR_VAR 0 2
14589: PUSH
14590: LD_VAR 0 2
14594: PPUSH
14595: LD_VAR 0 1
14599: PPUSH
14600: CALL_OW 3
14604: ST_TO_ADDR
// end ;
14605: GO 14484
14607: POP
14608: POP
// repeat wait ( 0 0$01 ) ;
14609: LD_INT 35
14611: PPUSH
14612: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14616: LD_INT 22
14618: PUSH
14619: LD_INT 4
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PUSH
14626: LD_INT 30
14628: PUSH
14629: LD_INT 31
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: PUSH
14636: LD_INT 3
14638: PUSH
14639: LD_INT 57
14641: PUSH
14642: EMPTY
14643: LIST
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: LIST
14653: PPUSH
14654: CALL_OW 69
14658: PUSH
14659: LD_INT 1
14661: GREATER
14662: IFFALSE 14609
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14664: LD_ADDR_VAR 0 8
14668: PUSH
14669: LD_EXP 6
14673: PPUSH
14674: LD_INT 25
14676: PUSH
14677: LD_INT 1
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 72
14688: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14689: LD_ADDR_VAR 0 1
14693: PUSH
14694: DOUBLE
14695: LD_INT 1
14697: DEC
14698: ST_TO_ADDR
14699: LD_INT 22
14701: PUSH
14702: LD_INT 4
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: PUSH
14709: LD_INT 30
14711: PUSH
14712: LD_INT 31
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: LD_INT 3
14721: PUSH
14722: LD_INT 57
14724: PUSH
14725: EMPTY
14726: LIST
14727: PUSH
14728: EMPTY
14729: LIST
14730: LIST
14731: PUSH
14732: EMPTY
14733: LIST
14734: LIST
14735: LIST
14736: PPUSH
14737: CALL_OW 69
14741: PUSH
14742: FOR_TO
14743: IFFALSE 14827
// begin if not sol [ i ] then
14745: LD_VAR 0 8
14749: PUSH
14750: LD_VAR 0 1
14754: ARRAY
14755: NOT
14756: IFFALSE 14760
// break ;
14758: GO 14827
// ComExitBuilding ( sol [ i ] ) ;
14760: LD_VAR 0 8
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: PPUSH
14771: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14775: LD_VAR 0 8
14779: PUSH
14780: LD_VAR 0 1
14784: ARRAY
14785: PPUSH
14786: LD_INT 22
14788: PUSH
14789: LD_INT 4
14791: PUSH
14792: EMPTY
14793: LIST
14794: LIST
14795: PUSH
14796: LD_INT 30
14798: PUSH
14799: LD_INT 31
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: PPUSH
14810: CALL_OW 69
14814: PUSH
14815: LD_VAR 0 1
14819: ARRAY
14820: PPUSH
14821: CALL_OW 180
// end ;
14825: GO 14742
14827: POP
14828: POP
// if sol > 3 then
14829: LD_VAR 0 8
14833: PUSH
14834: LD_INT 3
14836: GREATER
14837: IFFALSE 14954
// begin ComExitBuilding ( sol [ 3 ] ) ;
14839: LD_VAR 0 8
14843: PUSH
14844: LD_INT 3
14846: ARRAY
14847: PPUSH
14848: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14852: LD_VAR 0 8
14856: PUSH
14857: LD_INT 3
14859: ARRAY
14860: PPUSH
14861: LD_INT 246
14863: PPUSH
14864: LD_INT 94
14866: PPUSH
14867: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14871: LD_VAR 0 8
14875: PUSH
14876: LD_INT 3
14878: ARRAY
14879: PPUSH
14880: LD_INT 175
14882: PPUSH
14883: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14887: LD_VAR 0 8
14891: PUSH
14892: LD_INT 3
14894: ARRAY
14895: PPUSH
14896: LD_INT 224
14898: PPUSH
14899: LD_INT 90
14901: PPUSH
14902: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14906: LD_VAR 0 8
14910: PUSH
14911: LD_INT 3
14913: ARRAY
14914: PPUSH
14915: LD_INT 245
14917: PPUSH
14918: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14922: LD_VAR 0 8
14926: PUSH
14927: LD_INT 3
14929: ARRAY
14930: PPUSH
14931: LD_INT 223
14933: PPUSH
14934: LD_INT 110
14936: PPUSH
14937: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14941: LD_VAR 0 8
14945: PUSH
14946: LD_INT 3
14948: ARRAY
14949: PPUSH
14950: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14954: LD_VAR 0 2
14958: PPUSH
14959: LD_VAR 0 4
14963: PPUSH
14964: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
14968: LD_INT 22
14970: PUSH
14971: LD_INT 4
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 30
14980: PUSH
14981: LD_INT 4
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: PPUSH
14992: CALL_OW 69
14996: PUSH
14997: LD_INT 1
14999: ARRAY
15000: PPUSH
15001: CALL_OW 313
15005: PUSH
15006: LD_INT 6
15008: LESS
15009: IFFALSE 15073
// begin if IsInUnit ( Cornel ) then
15011: LD_EXP 44
15015: PPUSH
15016: CALL_OW 310
15020: IFFALSE 15031
// ComExitBuilding ( Cornel ) ;
15022: LD_EXP 44
15026: PPUSH
15027: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
15031: LD_EXP 44
15035: PPUSH
15036: LD_INT 22
15038: PUSH
15039: LD_INT 4
15041: PUSH
15042: EMPTY
15043: LIST
15044: LIST
15045: PUSH
15046: LD_INT 30
15048: PUSH
15049: LD_INT 4
15051: PUSH
15052: EMPTY
15053: LIST
15054: LIST
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: PPUSH
15060: CALL_OW 69
15064: PUSH
15065: LD_INT 1
15067: ARRAY
15068: PPUSH
15069: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
15073: LD_INT 35
15075: PPUSH
15076: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
15080: LD_ADDR_VAR 0 3
15084: PUSH
15085: LD_INT 22
15087: PUSH
15088: LD_INT 4
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: PUSH
15095: LD_INT 21
15097: PUSH
15098: LD_INT 3
15100: PUSH
15101: EMPTY
15102: LIST
15103: LIST
15104: PUSH
15105: LD_INT 3
15107: PUSH
15108: LD_INT 24
15110: PUSH
15111: LD_INT 1000
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: PUSH
15118: EMPTY
15119: LIST
15120: LIST
15121: PUSH
15122: EMPTY
15123: LIST
15124: LIST
15125: LIST
15126: PPUSH
15127: CALL_OW 69
15131: ST_TO_ADDR
// if filter and has_eng then
15132: LD_VAR 0 3
15136: PUSH
15137: LD_VAR 0 2
15141: AND
15142: IFFALSE 15208
// begin for i in has_eng do
15144: LD_ADDR_VAR 0 1
15148: PUSH
15149: LD_VAR 0 2
15153: PUSH
15154: FOR_IN
15155: IFFALSE 15204
// begin if IsInUnit ( i ) then
15157: LD_VAR 0 1
15161: PPUSH
15162: CALL_OW 310
15166: IFFALSE 15177
// ComExitBuilding ( i ) ;
15168: LD_VAR 0 1
15172: PPUSH
15173: CALL_OW 122
// Wait ( 3 ) ;
15177: LD_INT 3
15179: PPUSH
15180: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15184: LD_VAR 0 1
15188: PPUSH
15189: LD_VAR 0 3
15193: PUSH
15194: LD_INT 1
15196: ARRAY
15197: PPUSH
15198: CALL_OW 130
// end ;
15202: GO 15154
15204: POP
15205: POP
// end else
15206: GO 15262
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15208: LD_VAR 0 2
15212: PUSH
15213: LD_VAR 0 2
15217: PPUSH
15218: LD_INT 56
15220: PUSH
15221: EMPTY
15222: LIST
15223: PPUSH
15224: CALL_OW 72
15228: AND
15229: IFFALSE 15262
// for i in has_eng do
15231: LD_ADDR_VAR 0 1
15235: PUSH
15236: LD_VAR 0 2
15240: PUSH
15241: FOR_IN
15242: IFFALSE 15260
// ComEnterUnit ( i , dep ) ;
15244: LD_VAR 0 1
15248: PPUSH
15249: LD_VAR 0 4
15253: PPUSH
15254: CALL_OW 120
15258: GO 15241
15260: POP
15261: POP
// until cornel_prepared ;
15262: LD_EXP 11
15266: IFFALSE 15073
// end ;
15268: PPOPN 8
15270: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15271: LD_EXP 11
15275: IFFALSE 15674
15277: GO 15279
15279: DISABLE
15280: LD_INT 0
15282: PPUSH
15283: PPUSH
15284: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15285: LD_ADDR_VAR 0 2
15289: PUSH
15290: LD_INT 22
15292: PUSH
15293: LD_INT 4
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: LD_INT 30
15302: PUSH
15303: LD_INT 4
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PPUSH
15314: CALL_OW 69
15318: PUSH
15319: LD_INT 1
15321: ARRAY
15322: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15323: LD_EXP 6
15327: PPUSH
15328: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15332: LD_EXP 45
15336: PUSH
15337: LD_EXP 45
15341: PPUSH
15342: CALL_OW 310
15346: AND
15347: IFFALSE 15358
// ComExitBuilding ( Bierezov ) ;
15349: LD_EXP 45
15353: PPUSH
15354: CALL_OW 122
// Wait ( 0 0$03 ) ;
15358: LD_INT 105
15360: PPUSH
15361: CALL_OW 67
// for i in cornel_units do
15365: LD_ADDR_VAR 0 1
15369: PUSH
15370: LD_EXP 6
15374: PUSH
15375: FOR_IN
15376: IFFALSE 15452
// begin if GetClass ( i ) in [ 2 , 3 ] then
15378: LD_VAR 0 1
15382: PPUSH
15383: CALL_OW 257
15387: PUSH
15388: LD_INT 2
15390: PUSH
15391: LD_INT 3
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: IN
15398: IFFALSE 15435
// begin ComEnterUnit ( i , arm ) ;
15400: LD_VAR 0 1
15404: PPUSH
15405: LD_VAR 0 2
15409: PPUSH
15410: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15414: LD_VAR 0 1
15418: PPUSH
15419: LD_INT 1
15421: PPUSH
15422: CALL_OW 183
// AddComExitBuilding ( i ) ;
15426: LD_VAR 0 1
15430: PPUSH
15431: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_INT 257
15442: PPUSH
15443: LD_INT 121
15445: PPUSH
15446: CALL_OW 171
// end ;
15450: GO 15375
15452: POP
15453: POP
// Wait ( 1 1$00 ) ;
15454: LD_INT 2100
15456: PPUSH
15457: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15461: LD_ADDR_VAR 0 3
15465: PUSH
15466: LD_EXP 44
15470: PUSH
15471: LD_EXP 45
15475: ADD
15476: PUSH
15477: LD_EXP 6
15481: ADD
15482: PUSH
15483: LD_EXP 6
15487: PPUSH
15488: LD_INT 21
15490: PUSH
15491: LD_INT 2
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PPUSH
15498: CALL_OW 72
15502: DIFF
15503: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15504: LD_VAR 0 3
15508: PPUSH
15509: LD_INT 248
15511: PPUSH
15512: LD_INT 85
15514: PPUSH
15515: CALL_OW 111
// AddComHold ( filter ) ;
15519: LD_VAR 0 3
15523: PPUSH
15524: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15528: LD_INT 35
15530: PPUSH
15531: CALL_OW 67
// until cornel_attack ;
15535: LD_EXP 9
15539: IFFALSE 15528
// ComAgressiveMove ( filter , 209 , 63 ) ;
15541: LD_VAR 0 3
15545: PPUSH
15546: LD_INT 209
15548: PPUSH
15549: LD_INT 63
15551: PPUSH
15552: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15556: LD_EXP 44
15560: PPUSH
15561: LD_INT 208
15563: PPUSH
15564: LD_INT 62
15566: PPUSH
15567: CALL_OW 114
// AddComHold ( Cornel ) ;
15571: LD_EXP 44
15575: PPUSH
15576: CALL_OW 200
// if Bierezov then
15580: LD_EXP 45
15584: IFFALSE 15674
// begin filter := filter diff Bierezov ;
15586: LD_ADDR_VAR 0 3
15590: PUSH
15591: LD_VAR 0 3
15595: PUSH
15596: LD_EXP 45
15600: DIFF
15601: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15602: LD_EXP 45
15606: PPUSH
15607: LD_INT 6
15609: PPUSH
15610: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15614: LD_EXP 45
15618: PPUSH
15619: LD_INT 235
15621: PPUSH
15622: LD_INT 60
15624: PPUSH
15625: CALL_OW 111
// AddComHold ( Bierezov ) ;
15629: LD_EXP 45
15633: PPUSH
15634: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15638: LD_EXP 45
15642: PPUSH
15643: LD_INT 350
15645: PPUSH
15646: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15650: LD_EXP 45
15654: PPUSH
15655: LD_INT 198
15657: PPUSH
15658: LD_INT 28
15660: PPUSH
15661: CALL_OW 171
// AddComHold ( Bierezov ) ;
15665: LD_EXP 45
15669: PPUSH
15670: CALL_OW 200
// end ; end ; end_of_file
15674: PPOPN 3
15676: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15677: LD_EXP 53
15681: PUSH
15682: LD_EXP 31
15686: NOT
15687: AND
15688: PUSH
15689: LD_EXP 32
15693: NOT
15694: AND
15695: IFFALSE 16145
15697: GO 15699
15699: DISABLE
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
15704: PPUSH
15705: PPUSH
// begin enable ;
15706: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15707: LD_ADDR_VAR 0 4
15711: PUSH
15712: LD_INT 81
15714: PUSH
15715: LD_INT 3
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PPUSH
15722: CALL_OW 69
15726: ST_TO_ADDR
// for i = 1 to ru_patrol do
15727: LD_ADDR_VAR 0 2
15731: PUSH
15732: DOUBLE
15733: LD_INT 1
15735: DEC
15736: ST_TO_ADDR
15737: LD_EXP 53
15741: PUSH
15742: FOR_TO
15743: IFFALSE 16143
// begin un := ru_patrol [ i ] ;
15745: LD_ADDR_VAR 0 1
15749: PUSH
15750: LD_EXP 53
15754: PUSH
15755: LD_VAR 0 2
15759: ARRAY
15760: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15761: LD_VAR 0 1
15765: PPUSH
15766: LD_INT 13
15768: PPUSH
15769: CALL_OW 308
15773: IFFALSE 15878
// begin if not ru_alert then
15775: LD_EXP 60
15779: NOT
15780: IFFALSE 15790
// ru_alert := true ;
15782: LD_ADDR_EXP 60
15786: PUSH
15787: LD_INT 1
15789: ST_TO_ADDR
// if not See ( 1 , un ) then
15790: LD_INT 1
15792: PPUSH
15793: LD_VAR 0 1
15797: PPUSH
15798: CALL_OW 292
15802: NOT
15803: IFFALSE 15817
// SetLives ( un , 1000 ) ;
15805: LD_VAR 0 1
15809: PPUSH
15810: LD_INT 1000
15812: PPUSH
15813: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15817: LD_ADDR_EXP 53
15821: PUSH
15822: LD_EXP 53
15826: PUSH
15827: LD_VAR 0 1
15831: DIFF
15832: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15833: LD_VAR 0 1
15837: PPUSH
15838: LD_INT 22
15840: PUSH
15841: LD_INT 3
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PUSH
15848: LD_INT 30
15850: PUSH
15851: LD_INT 4
15853: PUSH
15854: EMPTY
15855: LIST
15856: LIST
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 69
15866: PPUSH
15867: CALL 1062 0 1
15871: PPUSH
15872: CALL_OW 120
// continue ;
15876: GO 15742
// end ; if IsOk ( un ) and not HasTask ( un ) then
15878: LD_VAR 0 1
15882: PPUSH
15883: CALL_OW 302
15887: PUSH
15888: LD_VAR 0 1
15892: PPUSH
15893: CALL_OW 314
15897: NOT
15898: AND
15899: IFFALSE 15992
// begin for j = 1 to ru_firepoints_south [ i ] do
15901: LD_ADDR_VAR 0 3
15905: PUSH
15906: DOUBLE
15907: LD_INT 1
15909: DEC
15910: ST_TO_ADDR
15911: LD_EXP 59
15915: PUSH
15916: LD_VAR 0 2
15920: ARRAY
15921: PUSH
15922: FOR_TO
15923: IFFALSE 15990
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15925: LD_VAR 0 1
15929: PPUSH
15930: LD_EXP 59
15934: PUSH
15935: LD_VAR 0 2
15939: ARRAY
15940: PUSH
15941: LD_VAR 0 3
15945: ARRAY
15946: PUSH
15947: LD_INT 1
15949: ARRAY
15950: PPUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_VAR 0 2
15960: ARRAY
15961: PUSH
15962: LD_VAR 0 3
15966: ARRAY
15967: PUSH
15968: LD_INT 2
15970: ARRAY
15971: PPUSH
15972: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15976: LD_VAR 0 1
15980: PPUSH
15981: LD_INT 70
15983: PPUSH
15984: CALL_OW 202
// end ;
15988: GO 15922
15990: POP
15991: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15992: LD_VAR 0 1
15996: PPUSH
15997: CALL_OW 256
16001: PUSH
16002: LD_INT 700
16004: LESS
16005: PUSH
16006: LD_VAR 0 1
16010: PPUSH
16011: LD_INT 13
16013: PPUSH
16014: CALL_OW 308
16018: NOT
16019: AND
16020: IFFALSE 16072
// begin ComMoveToArea ( un , retreatArea ) ;
16022: LD_VAR 0 1
16026: PPUSH
16027: LD_INT 13
16029: PPUSH
16030: CALL_OW 113
// if not ru_alert_xy then
16034: LD_EXP 61
16038: NOT
16039: IFFALSE 16070
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
16041: LD_ADDR_EXP 61
16045: PUSH
16046: LD_VAR 0 1
16050: PPUSH
16051: CALL_OW 250
16055: PUSH
16056: LD_VAR 0 1
16060: PPUSH
16061: CALL_OW 251
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: ST_TO_ADDR
// end else
16070: GO 16141
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16072: LD_VAR 0 1
16076: PPUSH
16077: LD_VAR 0 4
16081: PPUSH
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 74
16091: PPUSH
16092: CALL_OW 296
16096: PUSH
16097: LD_INT 9
16099: LESS
16100: PUSH
16101: LD_VAR 0 1
16105: PPUSH
16106: CALL_OW 256
16110: PUSH
16111: LD_INT 500
16113: GREATER
16114: AND
16115: IFFALSE 16141
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16117: LD_VAR 0 1
16121: PPUSH
16122: LD_VAR 0 4
16126: PPUSH
16127: LD_VAR 0 1
16131: PPUSH
16132: CALL_OW 74
16136: PPUSH
16137: CALL_OW 115
// end ;
16141: GO 15742
16143: POP
16144: POP
// end ;
16145: PPOPN 4
16147: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
16148: LD_EXP 60
16152: PUSH
16153: LD_EXP 61
16157: AND
16158: PUSH
16159: LD_EXP 31
16163: NOT
16164: AND
16165: PUSH
16166: LD_EXP 32
16170: NOT
16171: AND
16172: IFFALSE 16382
16174: GO 16176
16176: DISABLE
16177: LD_INT 0
16179: PPUSH
16180: PPUSH
// begin enable ;
16181: ENABLE
// if not ru_vehicles then
16182: LD_EXP 56
16186: NOT
16187: IFFALSE 16191
// exit ;
16189: GO 16382
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16191: LD_ADDR_VAR 0 2
16195: PUSH
16196: LD_INT 81
16198: PUSH
16199: LD_INT 3
16201: PUSH
16202: EMPTY
16203: LIST
16204: LIST
16205: PPUSH
16206: CALL_OW 69
16210: ST_TO_ADDR
// if ru_vehicles then
16211: LD_EXP 56
16215: IFFALSE 16382
// begin for i in ru_vehicles do
16217: LD_ADDR_VAR 0 1
16221: PUSH
16222: LD_EXP 56
16226: PUSH
16227: FOR_IN
16228: IFFALSE 16380
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16230: LD_VAR 0 1
16234: PPUSH
16235: CALL_OW 302
16239: PUSH
16240: LD_VAR 0 1
16244: PPUSH
16245: LD_VAR 0 2
16249: PPUSH
16250: LD_VAR 0 1
16254: PPUSH
16255: CALL_OW 74
16259: PPUSH
16260: CALL_OW 296
16264: PUSH
16265: LD_INT 9
16267: LESS
16268: AND
16269: IFFALSE 16295
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16271: LD_VAR 0 1
16275: PPUSH
16276: LD_VAR 0 2
16280: PPUSH
16281: LD_VAR 0 1
16285: PPUSH
16286: CALL_OW 74
16290: PPUSH
16291: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16295: LD_VAR 0 1
16299: PPUSH
16300: CALL_OW 314
16304: NOT
16305: PUSH
16306: LD_VAR 0 1
16310: PPUSH
16311: CALL_OW 302
16315: AND
16316: PUSH
16317: LD_VAR 0 1
16321: PPUSH
16322: LD_EXP 61
16326: PUSH
16327: LD_INT 1
16329: ARRAY
16330: PPUSH
16331: LD_EXP 61
16335: PUSH
16336: LD_INT 2
16338: ARRAY
16339: PPUSH
16340: CALL_OW 297
16344: PUSH
16345: LD_INT 10
16347: GREATER
16348: AND
16349: IFFALSE 16378
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16351: LD_VAR 0 1
16355: PPUSH
16356: LD_EXP 61
16360: PUSH
16361: LD_INT 1
16363: ARRAY
16364: PPUSH
16365: LD_EXP 61
16369: PUSH
16370: LD_INT 2
16372: ARRAY
16373: PPUSH
16374: CALL_OW 114
// end ;
16378: GO 16227
16380: POP
16381: POP
// end ; end ;
16382: PPOPN 2
16384: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16385: LD_EXP 61
16389: PUSH
16390: LD_EXP 60
16394: AND
16395: PUSH
16396: LD_INT 3
16398: PPUSH
16399: CALL_OW 463
16403: NOT
16404: AND
16405: PUSH
16406: LD_EXP 31
16410: NOT
16411: AND
16412: PUSH
16413: LD_EXP 32
16417: NOT
16418: AND
16419: IFFALSE 16514
16421: GO 16423
16423: DISABLE
16424: LD_INT 0
16426: PPUSH
// begin enable ;
16427: ENABLE
// ru_alert_xy := false ;
16428: LD_ADDR_EXP 61
16432: PUSH
16433: LD_INT 0
16435: ST_TO_ADDR
// ru_alert := false ;
16436: LD_ADDR_EXP 60
16440: PUSH
16441: LD_INT 0
16443: ST_TO_ADDR
// if ru_vehicles then
16444: LD_EXP 56
16448: IFFALSE 16514
// for i in ru_vehicles do
16450: LD_ADDR_VAR 0 1
16454: PUSH
16455: LD_EXP 56
16459: PUSH
16460: FOR_IN
16461: IFFALSE 16512
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16463: LD_VAR 0 1
16467: PPUSH
16468: CALL_OW 302
16472: PUSH
16473: LD_VAR 0 1
16477: PPUSH
16478: LD_INT 89
16480: PPUSH
16481: LD_INT 36
16483: PPUSH
16484: CALL_OW 297
16488: PUSH
16489: LD_INT 10
16491: GREATER
16492: AND
16493: IFFALSE 16510
// ComMoveXY ( i , 89 , 36 ) ;
16495: LD_VAR 0 1
16499: PPUSH
16500: LD_INT 89
16502: PPUSH
16503: LD_INT 36
16505: PPUSH
16506: CALL_OW 111
16510: GO 16460
16512: POP
16513: POP
// end ;
16514: PPOPN 1
16516: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16517: LD_EXP 55
16521: PUSH
16522: LD_EXP 31
16526: NOT
16527: AND
16528: PUSH
16529: LD_EXP 32
16533: NOT
16534: AND
16535: IFFALSE 16819
16537: GO 16539
16539: DISABLE
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
16544: PPUSH
// begin enable ;
16545: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16546: LD_ADDR_VAR 0 3
16550: PUSH
16551: LD_INT 81
16553: PUSH
16554: LD_INT 3
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PPUSH
16561: CALL_OW 69
16565: ST_TO_ADDR
// for i = 1 to ru_forest do
16566: LD_ADDR_VAR 0 1
16570: PUSH
16571: DOUBLE
16572: LD_INT 1
16574: DEC
16575: ST_TO_ADDR
16576: LD_EXP 55
16580: PUSH
16581: FOR_TO
16582: IFFALSE 16817
// begin un := ru_forest [ i ] ;
16584: LD_ADDR_VAR 0 2
16588: PUSH
16589: LD_EXP 55
16593: PUSH
16594: LD_VAR 0 1
16598: ARRAY
16599: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16600: LD_VAR 0 2
16604: PPUSH
16605: LD_INT 13
16607: PPUSH
16608: CALL_OW 308
16612: IFFALSE 16702
// begin if not See ( 1 , un ) then
16614: LD_INT 1
16616: PPUSH
16617: LD_VAR 0 2
16621: PPUSH
16622: CALL_OW 292
16626: NOT
16627: IFFALSE 16641
// SetLives ( un , 1000 ) ;
16629: LD_VAR 0 2
16633: PPUSH
16634: LD_INT 1000
16636: PPUSH
16637: CALL_OW 234
// ru_forest := ru_forest diff un ;
16641: LD_ADDR_EXP 55
16645: PUSH
16646: LD_EXP 55
16650: PUSH
16651: LD_VAR 0 2
16655: DIFF
16656: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16657: LD_VAR 0 2
16661: PPUSH
16662: LD_INT 22
16664: PUSH
16665: LD_INT 3
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PUSH
16672: LD_INT 30
16674: PUSH
16675: LD_INT 4
16677: PUSH
16678: EMPTY
16679: LIST
16680: LIST
16681: PUSH
16682: EMPTY
16683: LIST
16684: LIST
16685: PPUSH
16686: CALL_OW 69
16690: PPUSH
16691: CALL 1062 0 1
16695: PPUSH
16696: CALL_OW 120
// continue ;
16700: GO 16581
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16702: LD_VAR 0 2
16706: PPUSH
16707: CALL_OW 256
16711: PUSH
16712: LD_INT 700
16714: LESS
16715: PUSH
16716: LD_VAR 0 2
16720: PPUSH
16721: LD_INT 13
16723: PPUSH
16724: CALL_OW 308
16728: NOT
16729: AND
16730: IFFALSE 16746
// ComMoveToArea ( un , retreatArea ) else
16732: LD_VAR 0 2
16736: PPUSH
16737: LD_INT 13
16739: PPUSH
16740: CALL_OW 113
16744: GO 16815
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16746: LD_VAR 0 2
16750: PPUSH
16751: LD_VAR 0 3
16755: PPUSH
16756: LD_VAR 0 2
16760: PPUSH
16761: CALL_OW 74
16765: PPUSH
16766: CALL_OW 296
16770: PUSH
16771: LD_INT 9
16773: LESS
16774: PUSH
16775: LD_VAR 0 2
16779: PPUSH
16780: CALL_OW 256
16784: PUSH
16785: LD_INT 500
16787: GREATER
16788: AND
16789: IFFALSE 16815
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16791: LD_VAR 0 2
16795: PPUSH
16796: LD_VAR 0 3
16800: PPUSH
16801: LD_VAR 0 2
16805: PPUSH
16806: CALL_OW 74
16810: PPUSH
16811: CALL_OW 115
// end ;
16815: GO 16581
16817: POP
16818: POP
// end ;
16819: PPOPN 3
16821: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16822: LD_EXP 32
16826: NOT
16827: IFFALSE 16948
16829: GO 16831
16831: DISABLE
16832: LD_INT 0
16834: PPUSH
16835: PPUSH
// begin enable ;
16836: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16837: LD_ADDR_VAR 0 2
16841: PUSH
16842: LD_INT 22
16844: PUSH
16845: LD_INT 3
16847: PUSH
16848: EMPTY
16849: LIST
16850: LIST
16851: PUSH
16852: LD_INT 21
16854: PUSH
16855: LD_INT 3
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PPUSH
16866: CALL_OW 69
16870: ST_TO_ADDR
// if filter then
16871: LD_VAR 0 2
16875: IFFALSE 16948
// for i in filter do
16877: LD_ADDR_VAR 0 1
16881: PUSH
16882: LD_VAR 0 2
16886: PUSH
16887: FOR_IN
16888: IFFALSE 16946
// if GetLives ( i ) < 990 then
16890: LD_VAR 0 1
16894: PPUSH
16895: CALL_OW 256
16899: PUSH
16900: LD_INT 990
16902: LESS
16903: IFFALSE 16944
// begin ru_alert := true ;
16905: LD_ADDR_EXP 60
16909: PUSH
16910: LD_INT 1
16912: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16913: LD_ADDR_EXP 61
16917: PUSH
16918: LD_VAR 0 1
16922: PPUSH
16923: CALL_OW 250
16927: PUSH
16928: LD_VAR 0 1
16932: PPUSH
16933: CALL_OW 251
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: ST_TO_ADDR
// break ;
16942: GO 16946
// end ;
16944: GO 16887
16946: POP
16947: POP
// end ;
16948: PPOPN 2
16950: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16951: LD_EXP 31
16955: IFFALSE 17104
16957: GO 16959
16959: DISABLE
16960: LD_INT 0
16962: PPUSH
16963: PPUSH
16964: PPUSH
16965: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16966: LD_ADDR_VAR 0 4
16970: PUSH
16971: LD_EXP 56
16975: PUSH
16976: LD_EXP 55
16980: ADD
16981: PUSH
16982: LD_EXP 53
16986: ADD
16987: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16988: LD_ADDR_VAR 0 3
16992: PUSH
16993: LD_INT 3
16995: PPUSH
16996: LD_INT 81
16998: PUSH
16999: LD_INT 3
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PPUSH
17006: CALL_OW 70
17010: ST_TO_ADDR
// if filter and enemy then
17011: LD_VAR 0 4
17015: PUSH
17016: LD_VAR 0 3
17020: AND
17021: IFFALSE 17104
// repeat wait ( 0 0$01 ) ;
17023: LD_INT 35
17025: PPUSH
17026: CALL_OW 67
// for i in filter do
17030: LD_ADDR_VAR 0 1
17034: PUSH
17035: LD_VAR 0 4
17039: PUSH
17040: FOR_IN
17041: IFFALSE 17069
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
17043: LD_VAR 0 1
17047: PPUSH
17048: LD_VAR 0 3
17052: PPUSH
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 74
17062: PPUSH
17063: CALL_OW 115
// end ;
17067: GO 17040
17069: POP
17070: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
17071: LD_INT 3
17073: PPUSH
17074: LD_INT 81
17076: PUSH
17077: LD_INT 3
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PPUSH
17084: CALL_OW 70
17088: PUSH
17089: LD_INT 0
17091: EQUAL
17092: PUSH
17093: LD_VAR 0 4
17097: PUSH
17098: LD_INT 0
17100: EQUAL
17101: OR
17102: IFFALSE 17023
// end ;
17104: PPOPN 4
17106: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
17107: LD_EXP 26
17111: PUSH
17112: LD_INT 22
17114: PUSH
17115: LD_INT 4
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: PUSH
17122: LD_INT 30
17124: PUSH
17125: LD_INT 4
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: PUSH
17132: LD_INT 3
17134: PUSH
17135: LD_INT 57
17137: PUSH
17138: EMPTY
17139: LIST
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: EMPTY
17146: LIST
17147: LIST
17148: LIST
17149: PPUSH
17150: CALL_OW 69
17154: AND
17155: IFFALSE 17204
17157: GO 17159
17159: DISABLE
17160: LD_INT 0
17162: PPUSH
// begin if not ru_cornel_attack then
17163: LD_EXP 58
17167: NOT
17168: IFFALSE 17172
// exit ;
17170: GO 17204
// for i in ru_cornel_attack do
17172: LD_ADDR_VAR 0 1
17176: PUSH
17177: LD_EXP 58
17181: PUSH
17182: FOR_IN
17183: IFFALSE 17202
// ComAgressiveMove ( i , 258 , 119 ) ;
17185: LD_VAR 0 1
17189: PPUSH
17190: LD_INT 258
17192: PPUSH
17193: LD_INT 119
17195: PPUSH
17196: CALL_OW 114
17200: GO 17182
17202: POP
17203: POP
// end ; end_of_file
17204: PPOPN 1
17206: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17207: LD_EXP 5
17211: PUSH
17212: LD_EXP 9
17216: NOT
17217: AND
17218: PUSH
17219: LD_EXP 20
17223: AND
17224: IFFALSE 17336
17226: GO 17228
17228: DISABLE
17229: LD_INT 0
17231: PPUSH
// begin enable ;
17232: ENABLE
// crates_counter := crates_counter - 50 ;
17233: LD_ADDR_EXP 20
17237: PUSH
17238: LD_EXP 20
17242: PUSH
17243: LD_INT 50
17245: MINUS
17246: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17247: LD_INT 8
17249: PPUSH
17250: LD_INT 2
17252: PPUSH
17253: LD_INT 5
17255: PPUSH
17256: CALL_OW 12
17260: PPUSH
17261: LD_INT 1
17263: PPUSH
17264: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17268: LD_INT 1785
17270: PPUSH
17271: LD_INT 2345
17273: PPUSH
17274: CALL_OW 12
17278: PPUSH
17279: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17283: LD_ADDR_VAR 0 1
17287: PUSH
17288: LD_INT 1
17290: PPUSH
17291: LD_OWVAR 67
17295: PUSH
17296: LD_INT 2
17298: PLUS
17299: PPUSH
17300: CALL_OW 12
17304: ST_TO_ADDR
// if r < 3 then
17305: LD_VAR 0 1
17309: PUSH
17310: LD_INT 3
17312: LESS
17313: IFFALSE 17336
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17315: LD_INT 4
17317: PPUSH
17318: LD_INT 1
17320: PPUSH
17321: LD_INT 5
17323: PPUSH
17324: CALL_OW 12
17328: PPUSH
17329: LD_INT 1
17331: PPUSH
17332: CALL_OW 55
// end ;
17336: PPOPN 1
17338: END
// every 0 0$01 trigger cornel_active do
17339: LD_EXP 8
17343: IFFALSE 17432
17345: GO 17347
17347: DISABLE
// begin Wait ( 0 0$03 ) ;
17348: LD_INT 105
17350: PPUSH
17351: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17355: LD_INT 2
17357: PPUSH
17358: LD_INT 5
17360: PPUSH
17361: CALL_OW 12
17365: PPUSH
17366: LD_INT 10
17368: PPUSH
17369: LD_INT 1
17371: PPUSH
17372: CALL_OW 55
// Wait ( 0 0$13 ) ;
17376: LD_INT 455
17378: PPUSH
17379: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17383: LD_INT 2
17385: PPUSH
17386: LD_INT 5
17388: PPUSH
17389: CALL_OW 12
17393: PPUSH
17394: LD_INT 10
17396: PPUSH
17397: LD_INT 1
17399: PPUSH
17400: CALL_OW 55
// Wait ( 0 0$16 ) ;
17404: LD_INT 560
17406: PPUSH
17407: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17411: LD_INT 2
17413: PPUSH
17414: LD_INT 5
17416: PPUSH
17417: CALL_OW 12
17421: PPUSH
17422: LD_INT 10
17424: PPUSH
17425: LD_INT 1
17427: PPUSH
17428: CALL_OW 55
// end ; end_of_file
17432: END
// every 0 0$01 trigger cornel_prepared do
17433: LD_EXP 11
17437: IFFALSE 17496
17439: GO 17441
17441: DISABLE
// begin enable ;
17442: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17443: LD_ADDR_OWVAR 47
17447: PUSH
17448: LD_STRING #Am03-1
17450: PUSH
17451: LD_EXP 10
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17460: LD_ADDR_EXP 10
17464: PUSH
17465: LD_EXP 10
17469: PPUSH
17470: LD_STRING -
17472: PPUSH
17473: CALL 1132 0 2
17477: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17478: LD_EXP 10
17482: PUSH
17483: LD_INT 0
17485: EQUAL
17486: IFFALSE 17496
// begin Display_Strings := [ ] ;
17488: LD_ADDR_OWVAR 47
17492: PUSH
17493: EMPTY
17494: ST_TO_ADDR
// disable ;
17495: DISABLE
// end ; end ;
17496: END
// every 0 0$01 trigger debug and debug_strings do
17497: LD_EXP 1
17501: PUSH
17502: LD_OWVAR 48
17506: AND
17507: IFFALSE 17523
17509: GO 17511
17511: DISABLE
// begin enable ;
17512: ENABLE
// Display_Strings := debug_strings ;
17513: LD_ADDR_OWVAR 47
17517: PUSH
17518: LD_OWVAR 48
17522: ST_TO_ADDR
// end ; end_of_file
17523: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17524: LD_VAR 0 1
17528: PPUSH
17529: CALL_OW 255
17533: PUSH
17534: LD_INT 1
17536: EQUAL
17537: PUSH
17538: LD_EXP 14
17542: NOT
17543: AND
17544: IFFALSE 17554
// solar_builded := true ;
17546: LD_ADDR_EXP 14
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17554: LD_VAR 0 1
17558: PPUSH
17559: CALL_OW 255
17563: PUSH
17564: LD_INT 1
17566: EQUAL
17567: PUSH
17568: LD_EXP 29
17572: AND
17573: IFFALSE 17606
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17575: LD_ADDR_EXP 29
17579: PUSH
17580: LD_EXP 29
17584: PUSH
17585: LD_INT 1750
17587: PUSH
17588: LD_INT 1400
17590: PUSH
17591: LD_INT 1225
17593: PUSH
17594: EMPTY
17595: LIST
17596: LIST
17597: LIST
17598: PUSH
17599: LD_OWVAR 67
17603: ARRAY
17604: PLUS
17605: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17606: LD_VAR 0 1
17610: PPUSH
17611: CALL_OW 255
17615: PUSH
17616: LD_INT 3
17618: EQUAL
17619: IFFALSE 17637
// ru_vehicles := ru_vehicles ^ veh ;
17621: LD_ADDR_EXP 56
17625: PUSH
17626: LD_EXP 56
17630: PUSH
17631: LD_VAR 0 1
17635: ADD
17636: ST_TO_ADDR
// end ;
17637: PPOPN 2
17639: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17640: LD_VAR 0 1
17644: PUSH
17645: LD_EXP 53
17649: IN
17650: IFFALSE 17668
// ru_patrol := ru_patrol diff un ;
17652: LD_ADDR_EXP 53
17656: PUSH
17657: LD_EXP 53
17661: PUSH
17662: LD_VAR 0 1
17666: DIFF
17667: ST_TO_ADDR
// if un in ru_forest then
17668: LD_VAR 0 1
17672: PUSH
17673: LD_EXP 55
17677: IN
17678: IFFALSE 17696
// ru_forest := ru_forest diff un ;
17680: LD_ADDR_EXP 55
17684: PUSH
17685: LD_EXP 55
17689: PUSH
17690: LD_VAR 0 1
17694: DIFF
17695: ST_TO_ADDR
// if un in ru_vehicles then
17696: LD_VAR 0 1
17700: PUSH
17701: LD_EXP 56
17705: IN
17706: IFFALSE 17812
// begin ru_vehicles := ru_vehicles diff un ;
17708: LD_ADDR_EXP 56
17712: PUSH
17713: LD_EXP 56
17717: PUSH
17718: LD_VAR 0 1
17722: DIFF
17723: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17724: LD_ADDR_EXP 57
17728: PUSH
17729: LD_EXP 57
17733: PUSH
17734: LD_VAR 0 1
17738: PPUSH
17739: CALL_OW 265
17743: PUSH
17744: LD_VAR 0 1
17748: PPUSH
17749: CALL_OW 262
17753: PUSH
17754: LD_VAR 0 1
17758: PPUSH
17759: CALL_OW 263
17763: PUSH
17764: LD_VAR 0 1
17768: PPUSH
17769: CALL_OW 264
17773: PUSH
17774: EMPTY
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: ADD
17780: ST_TO_ADDR
// ach_counter := ach_counter + 1 ;
17781: LD_ADDR_EXP 13
17785: PUSH
17786: LD_EXP 13
17790: PUSH
17791: LD_INT 1
17793: PLUS
17794: ST_TO_ADDR
// if ach_counter = 10 then
17795: LD_EXP 13
17799: PUSH
17800: LD_INT 10
17802: EQUAL
17803: IFFALSE 17812
// SetAchievement ( ACH_FAUST ) ;
17805: LD_STRING ACH_FAUST
17807: PPUSH
17808: CALL_OW 543
// end ; if un = Pokryshkin then
17812: LD_VAR 0 1
17816: PUSH
17817: LD_EXP 52
17821: EQUAL
17822: IFFALSE 17831
// SetAchievement ( ACH_POKR ) ;
17824: LD_STRING ACH_POKR
17826: PPUSH
17827: CALL_OW 543
// if un = JMM then
17831: LD_VAR 0 1
17835: PUSH
17836: LD_EXP 37
17840: EQUAL
17841: IFFALSE 17850
// YouLost ( 0 ) ;
17843: LD_STRING 0
17845: PPUSH
17846: CALL_OW 104
// if un = us_dep_west then
17850: LD_VAR 0 1
17854: PUSH
17855: LD_INT 1
17857: EQUAL
17858: IFFALSE 17867
// YouLost ( 2 ) ;
17860: LD_STRING 2
17862: PPUSH
17863: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17867: LD_VAR 0 1
17871: PPUSH
17872: CALL_OW 255
17876: PUSH
17877: LD_INT 8
17879: EQUAL
17880: PUSH
17881: LD_EXP 5
17885: NOT
17886: AND
17887: IFFALSE 17896
// YouLost ( 4 ) ;
17889: LD_STRING 4
17891: PPUSH
17892: CALL_OW 104
// if un in jmm_units then
17896: LD_VAR 0 1
17900: PUSH
17901: LD_EXP 4
17905: IN
17906: IFFALSE 17922
// lose_counter := lose_counter + 1 ;
17908: LD_ADDR_EXP 34
17912: PUSH
17913: LD_EXP 34
17917: PUSH
17918: LD_INT 1
17920: PLUS
17921: ST_TO_ADDR
// end ;
17922: PPOPN 1
17924: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17925: LD_INT 0
17927: PPUSH
17928: PPUSH
// begin if GetSide ( driver ) = 3 then
17929: LD_VAR 0 1
17933: PPUSH
17934: CALL_OW 255
17938: PUSH
17939: LD_INT 3
17941: EQUAL
17942: IFFALSE 18020
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17944: LD_ADDR_VAR 0 6
17948: PUSH
17949: LD_INT 22
17951: PUSH
17952: LD_INT 3
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: PUSH
17959: LD_INT 30
17961: PUSH
17962: LD_INT 3
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: PPUSH
17973: CALL_OW 69
17977: PPUSH
17978: CALL 1062 0 1
17982: ST_TO_ADDR
// if place then
17983: LD_VAR 0 6
17987: IFFALSE 18005
// ComEnterUnit ( driver , place ) else
17989: LD_VAR 0 1
17993: PPUSH
17994: LD_VAR 0 6
17998: PPUSH
17999: CALL_OW 120
18003: GO 18020
// ComMoveXY ( driver , 70 , 22 ) ;
18005: LD_VAR 0 1
18009: PPUSH
18010: LD_INT 70
18012: PPUSH
18013: LD_INT 22
18015: PPUSH
18016: CALL_OW 111
// end ; end ;
18020: PPOPN 6
18022: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
18023: LD_VAR 0 1
18027: PUSH
18028: LD_INT 1
18030: EQUAL
18031: PUSH
18032: LD_VAR 0 2
18036: PUSH
18037: LD_INT 4
18039: EQUAL
18040: PUSH
18041: LD_VAR 0 2
18045: PUSH
18046: LD_INT 8
18048: EQUAL
18049: PUSH
18050: LD_EXP 5
18054: NOT
18055: AND
18056: OR
18057: AND
18058: IFFALSE 18067
// YouLost ( 5 ) ;
18060: LD_STRING 5
18062: PPUSH
18063: CALL_OW 104
// end ;
18067: PPOPN 2
18069: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
18070: LD_EXP 36
18074: PUSH
18075: LD_INT 22
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PUSH
18085: LD_INT 21
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PUSH
18095: EMPTY
18096: LIST
18097: LIST
18098: PPUSH
18099: CALL_OW 69
18103: PUSH
18104: LD_INT 22
18106: PUSH
18107: LD_INT 8
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: PUSH
18114: LD_INT 21
18116: PUSH
18117: LD_INT 1
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: PPUSH
18128: CALL_OW 69
18132: ADD
18133: PLUS
18134: PUSH
18135: LD_INT 5
18137: LESS
18138: IFFALSE 18150
18140: GO 18142
18142: DISABLE
// YouLost ( 1 ) ;
18143: LD_STRING 1
18145: PPUSH
18146: CALL_OW 104
18150: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
18151: LD_INT 1
18153: PPUSH
18154: CALL_OW 255
18158: PUSH
18159: LD_INT 3
18161: EQUAL
18162: IFFALSE 18174
18164: GO 18166
18166: DISABLE
// YouLost ( 3 ) ; end_of_file
18167: LD_STRING 3
18169: PPUSH
18170: CALL_OW 104
18174: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
18175: GO 18177
18177: DISABLE
// begin ru_radar := 98 ;
18178: LD_ADDR_EXP 62
18182: PUSH
18183: LD_INT 98
18185: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18186: LD_ADDR_EXP 63
18190: PUSH
18191: LD_INT 89
18193: ST_TO_ADDR
// us_hack := 99 ;
18194: LD_ADDR_EXP 64
18198: PUSH
18199: LD_INT 99
18201: ST_TO_ADDR
// us_artillery := 97 ;
18202: LD_ADDR_EXP 65
18206: PUSH
18207: LD_INT 97
18209: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18210: LD_ADDR_EXP 66
18214: PUSH
18215: LD_INT 91
18217: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
18218: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
18219: LD_INT 0
18221: PPUSH
18222: PPUSH
18223: PPUSH
18224: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
18225: LD_VAR 0 1
18229: PPUSH
18230: CALL_OW 264
18234: PUSH
18235: LD_EXP 66
18239: EQUAL
18240: IFFALSE 18312
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
18242: LD_INT 68
18244: PPUSH
18245: LD_VAR 0 1
18249: PPUSH
18250: CALL_OW 255
18254: PPUSH
18255: CALL_OW 321
18259: PUSH
18260: LD_INT 2
18262: EQUAL
18263: IFFALSE 18275
// eff := 70 else
18265: LD_ADDR_VAR 0 6
18269: PUSH
18270: LD_INT 70
18272: ST_TO_ADDR
18273: GO 18283
// eff := 30 ;
18275: LD_ADDR_VAR 0 6
18279: PUSH
18280: LD_INT 30
18282: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
18283: LD_VAR 0 1
18287: PPUSH
18288: CALL_OW 250
18292: PPUSH
18293: LD_VAR 0 1
18297: PPUSH
18298: CALL_OW 251
18302: PPUSH
18303: LD_VAR 0 6
18307: PPUSH
18308: CALL_OW 495
// end ; end ;
18312: LD_VAR 0 4
18316: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
18317: LD_INT 0
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
18323: PPUSH
18324: PPUSH
// if cmd = 124 then
18325: LD_VAR 0 1
18329: PUSH
18330: LD_INT 124
18332: EQUAL
18333: IFFALSE 18539
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
18335: LD_ADDR_VAR 0 5
18339: PUSH
18340: LD_INT 2
18342: PUSH
18343: LD_INT 34
18345: PUSH
18346: LD_INT 53
18348: PUSH
18349: EMPTY
18350: LIST
18351: LIST
18352: PUSH
18353: LD_INT 34
18355: PUSH
18356: LD_INT 14
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: LIST
18367: PPUSH
18368: CALL_OW 69
18372: ST_TO_ADDR
// if not tmp then
18373: LD_VAR 0 5
18377: NOT
18378: IFFALSE 18382
// exit ;
18380: GO 18539
// for i in tmp do
18382: LD_ADDR_VAR 0 3
18386: PUSH
18387: LD_VAR 0 5
18391: PUSH
18392: FOR_IN
18393: IFFALSE 18537
// begin taskList := GetTaskList ( i ) ;
18395: LD_ADDR_VAR 0 6
18399: PUSH
18400: LD_VAR 0 3
18404: PPUSH
18405: CALL_OW 437
18409: ST_TO_ADDR
// if not taskList then
18410: LD_VAR 0 6
18414: NOT
18415: IFFALSE 18419
// continue ;
18417: GO 18392
// for j = 1 to taskList do
18419: LD_ADDR_VAR 0 4
18423: PUSH
18424: DOUBLE
18425: LD_INT 1
18427: DEC
18428: ST_TO_ADDR
18429: LD_VAR 0 6
18433: PUSH
18434: FOR_TO
18435: IFFALSE 18533
// if taskList [ j ] [ 1 ] = | then
18437: LD_VAR 0 6
18441: PUSH
18442: LD_VAR 0 4
18446: ARRAY
18447: PUSH
18448: LD_INT 1
18450: ARRAY
18451: PUSH
18452: LD_STRING |
18454: EQUAL
18455: IFFALSE 18531
// begin _taskList := Delete ( taskList , 1 ) ;
18457: LD_ADDR_VAR 0 7
18461: PUSH
18462: LD_VAR 0 6
18466: PPUSH
18467: LD_INT 1
18469: PPUSH
18470: CALL_OW 3
18474: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
18475: LD_VAR 0 3
18479: PPUSH
18480: LD_VAR 0 7
18484: PPUSH
18485: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
18489: LD_VAR 0 3
18493: PPUSH
18494: LD_VAR 0 6
18498: PUSH
18499: LD_VAR 0 4
18503: ARRAY
18504: PUSH
18505: LD_INT 2
18507: ARRAY
18508: PPUSH
18509: LD_VAR 0 6
18513: PUSH
18514: LD_VAR 0 4
18518: ARRAY
18519: PUSH
18520: LD_INT 3
18522: ARRAY
18523: PPUSH
18524: LD_INT 8
18526: PPUSH
18527: CALL 18544 0 4
// end ;
18531: GO 18434
18533: POP
18534: POP
// end ;
18535: GO 18392
18537: POP
18538: POP
// end ; end ;
18539: LD_VAR 0 2
18543: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
18544: LD_INT 0
18546: PPUSH
18547: PPUSH
18548: PPUSH
18549: PPUSH
18550: PPUSH
18551: PPUSH
18552: PPUSH
18553: PPUSH
18554: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
18555: LD_VAR 0 1
18559: NOT
18560: PUSH
18561: LD_VAR 0 2
18565: PPUSH
18566: LD_VAR 0 3
18570: PPUSH
18571: CALL_OW 488
18575: NOT
18576: OR
18577: PUSH
18578: LD_VAR 0 4
18582: NOT
18583: OR
18584: IFFALSE 18588
// exit ;
18586: GO 18928
// list := [ ] ;
18588: LD_ADDR_VAR 0 13
18592: PUSH
18593: EMPTY
18594: ST_TO_ADDR
// if x - r < 0 then
18595: LD_VAR 0 2
18599: PUSH
18600: LD_VAR 0 4
18604: MINUS
18605: PUSH
18606: LD_INT 0
18608: LESS
18609: IFFALSE 18621
// min_x := 0 else
18611: LD_ADDR_VAR 0 7
18615: PUSH
18616: LD_INT 0
18618: ST_TO_ADDR
18619: GO 18637
// min_x := x - r ;
18621: LD_ADDR_VAR 0 7
18625: PUSH
18626: LD_VAR 0 2
18630: PUSH
18631: LD_VAR 0 4
18635: MINUS
18636: ST_TO_ADDR
// if y - r < 0 then
18637: LD_VAR 0 3
18641: PUSH
18642: LD_VAR 0 4
18646: MINUS
18647: PUSH
18648: LD_INT 0
18650: LESS
18651: IFFALSE 18663
// min_y := 0 else
18653: LD_ADDR_VAR 0 8
18657: PUSH
18658: LD_INT 0
18660: ST_TO_ADDR
18661: GO 18679
// min_y := y - r ;
18663: LD_ADDR_VAR 0 8
18667: PUSH
18668: LD_VAR 0 3
18672: PUSH
18673: LD_VAR 0 4
18677: MINUS
18678: ST_TO_ADDR
// max_x := x + r ;
18679: LD_ADDR_VAR 0 9
18683: PUSH
18684: LD_VAR 0 2
18688: PUSH
18689: LD_VAR 0 4
18693: PLUS
18694: ST_TO_ADDR
// max_y := y + r ;
18695: LD_ADDR_VAR 0 10
18699: PUSH
18700: LD_VAR 0 3
18704: PUSH
18705: LD_VAR 0 4
18709: PLUS
18710: ST_TO_ADDR
// for _x = min_x to max_x do
18711: LD_ADDR_VAR 0 11
18715: PUSH
18716: DOUBLE
18717: LD_VAR 0 7
18721: DEC
18722: ST_TO_ADDR
18723: LD_VAR 0 9
18727: PUSH
18728: FOR_TO
18729: IFFALSE 18846
// for _y = min_y to max_y do
18731: LD_ADDR_VAR 0 12
18735: PUSH
18736: DOUBLE
18737: LD_VAR 0 8
18741: DEC
18742: ST_TO_ADDR
18743: LD_VAR 0 10
18747: PUSH
18748: FOR_TO
18749: IFFALSE 18842
// begin if not ValidHex ( _x , _y ) then
18751: LD_VAR 0 11
18755: PPUSH
18756: LD_VAR 0 12
18760: PPUSH
18761: CALL_OW 488
18765: NOT
18766: IFFALSE 18770
// continue ;
18768: GO 18748
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
18770: LD_VAR 0 11
18774: PPUSH
18775: LD_VAR 0 12
18779: PPUSH
18780: CALL_OW 351
18784: PUSH
18785: LD_VAR 0 11
18789: PPUSH
18790: LD_VAR 0 12
18794: PPUSH
18795: CALL_OW 554
18799: AND
18800: IFFALSE 18840
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
18802: LD_ADDR_VAR 0 13
18806: PUSH
18807: LD_VAR 0 13
18811: PPUSH
18812: LD_VAR 0 13
18816: PUSH
18817: LD_INT 1
18819: PLUS
18820: PPUSH
18821: LD_VAR 0 11
18825: PUSH
18826: LD_VAR 0 12
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: PPUSH
18835: CALL_OW 2
18839: ST_TO_ADDR
// end ;
18840: GO 18748
18842: POP
18843: POP
18844: GO 18728
18846: POP
18847: POP
// if not list then
18848: LD_VAR 0 13
18852: NOT
18853: IFFALSE 18857
// exit ;
18855: GO 18928
// for i in list do
18857: LD_ADDR_VAR 0 6
18861: PUSH
18862: LD_VAR 0 13
18866: PUSH
18867: FOR_IN
18868: IFFALSE 18926
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
18870: LD_VAR 0 1
18874: PPUSH
18875: LD_STRING M
18877: PUSH
18878: LD_VAR 0 6
18882: PUSH
18883: LD_INT 1
18885: ARRAY
18886: PUSH
18887: LD_VAR 0 6
18891: PUSH
18892: LD_INT 2
18894: ARRAY
18895: PUSH
18896: LD_INT 0
18898: PUSH
18899: LD_INT 0
18901: PUSH
18902: LD_INT 0
18904: PUSH
18905: LD_INT 0
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: LIST
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: PPUSH
18920: CALL_OW 447
18924: GO 18867
18926: POP
18927: POP
// end ;
18928: LD_VAR 0 5
18932: RET
