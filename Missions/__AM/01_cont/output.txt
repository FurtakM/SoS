// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 32 0 0
// InitAmerican ;
  15: CALL 915 0 0
// InitRussian ;
  19: CALL 1154 0 0
// DebugMode ;
  23: CALL 152 0 0
// Action ;
  27: CALL 2710 0 0
// end ;
  31: END
// export debug ; export mission_prefix ; export active_russian_dialog , bobby_in_squad , powell_contact , macmilan_use_radio , cyrus_in_squad , active_road_patrol , macmilan_in_trap , meta_action , end_mission , bobby_saved , cyrus_saved , send_troops_to_forest ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// mission_prefix := 01_ ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_STRING 01_
  42: ST_TO_ADDR
// debug := 0 ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// active_russian_dialog := false ;
  51: LD_ADDR_EXP 3
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// bobby_in_squad := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// cyrus_in_squad := false ;
  67: LD_ADDR_EXP 7
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// powell_contact := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// macmilan_use_radio := false ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// active_road_patrol := false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// macmilan_in_trap := false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// meta_action := false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// end_mission := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// bobby_saved := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// cyrus_saved := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// send_troops_to_forest := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// function DebugMode ; var i ; begin
 152: LD_INT 0
 154: PPUSH
 155: PPUSH
// if not debug then
 156: LD_EXP 1
 160: NOT
 161: IFFALSE 165
// exit ;
 163: GO 184
// Difficulty := 3 ;
 165: LD_ADDR_OWVAR 67
 169: PUSH
 170: LD_INT 3
 172: ST_TO_ADDR
// TurnFogOff ( ) ;
 173: CALL_OW 537
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 216
// unit := CreateCharacter ( ident ) else
 199: LD_ADDR_VAR 0 4
 203: PUSH
 204: LD_VAR 0 1
 208: PPUSH
 209: CALL_OW 34
 213: ST_TO_ADDR
 214: GO 231
// unit := NewCharacter ( ident ) ;
 216: LD_ADDR_VAR 0 4
 220: PUSH
 221: LD_VAR 0 1
 225: PPUSH
 226: CALL_OW 25
 230: ST_TO_ADDR
// result := unit ;
 231: LD_ADDR_VAR 0 3
 235: PUSH
 236: LD_VAR 0 4
 240: ST_TO_ADDR
// end ;
 241: LD_VAR 0 3
 245: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 246: LD_INT 0
 248: PPUSH
 249: PPUSH
 250: PPUSH
// uc_side := GetSide ( b ) ;
 251: LD_ADDR_OWVAR 20
 255: PUSH
 256: LD_VAR 0 2
 260: PPUSH
 261: CALL_OW 255
 265: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 266: LD_ADDR_OWVAR 21
 270: PUSH
 271: LD_VAR 0 2
 275: PPUSH
 276: CALL_OW 248
 280: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 281: LD_INT 0
 283: PPUSH
 284: LD_INT 1
 286: PPUSH
 287: LD_VAR 0 1
 291: PPUSH
 292: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
 296: LD_ADDR_VAR 0 5
 300: PUSH
 301: LD_VAR 0 2
 305: PPUSH
 306: CALL_OW 254
 310: PUSH
 311: LD_INT 3
 313: MINUS
 314: ST_TO_ADDR
// if dir < 0 then
 315: LD_VAR 0 5
 319: PUSH
 320: LD_INT 0
 322: LESS
 323: IFFALSE 339
// dir := 6 + dir ;
 325: LD_ADDR_VAR 0 5
 329: PUSH
 330: LD_INT 6
 332: PUSH
 333: LD_VAR 0 5
 337: PLUS
 338: ST_TO_ADDR
// un := CreateHuman ;
 339: LD_ADDR_VAR 0 4
 343: PUSH
 344: CALL_OW 44
 348: ST_TO_ADDR
// SetDir ( un , dir ) ;
 349: LD_VAR 0 4
 353: PPUSH
 354: LD_VAR 0 5
 358: PPUSH
 359: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 363: LD_VAR 0 4
 367: PPUSH
 368: LD_VAR 0 2
 372: PPUSH
 373: CALL_OW 52
// end ;
 377: LD_VAR 0 3
 381: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 382: LD_INT 0
 384: PPUSH
// uc_side := side ;
 385: LD_ADDR_OWVAR 20
 389: PUSH
 390: LD_VAR 0 1
 394: ST_TO_ADDR
// uc_nation := nation ;
 395: LD_ADDR_OWVAR 21
 399: PUSH
 400: LD_VAR 0 2
 404: ST_TO_ADDR
// vc_chassis := chassis ;
 405: LD_ADDR_OWVAR 37
 409: PUSH
 410: LD_VAR 0 3
 414: ST_TO_ADDR
// vc_engine := engine ;
 415: LD_ADDR_OWVAR 39
 419: PUSH
 420: LD_VAR 0 4
 424: ST_TO_ADDR
// vc_control := control ;
 425: LD_ADDR_OWVAR 38
 429: PUSH
 430: LD_VAR 0 5
 434: ST_TO_ADDR
// vc_weapon := weapon ;
 435: LD_ADDR_OWVAR 40
 439: PUSH
 440: LD_VAR 0 6
 444: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 445: LD_ADDR_OWVAR 41
 449: PUSH
 450: LD_VAR 0 7
 454: ST_TO_ADDR
// result := CreateVehicle ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: CALL_OW 45
 464: ST_TO_ADDR
// end ;
 465: LD_VAR 0 8
 469: RET
// export function ComPatrol ( unit , mode , pause , coords ) ; var i ; begin
 470: LD_INT 0
 472: PPUSH
 473: PPUSH
// while ( active_road_patrol ) do
 474: LD_EXP 8
 478: IFFALSE 832
// begin Wait ( 0 0$01 ) ;
 480: LD_INT 35
 482: PPUSH
 483: CALL_OW 67
// if not unit then
 487: LD_VAR 0 1
 491: NOT
 492: IFFALSE 496
// exit ;
 494: GO 832
// if mode = road then
 496: LD_VAR 0 2
 500: PUSH
 501: LD_STRING road
 503: EQUAL
 504: IFFALSE 560
// if GetFuel ( unit ) < 50 and not See ( 1 , unit ) and not HasTask ( unit ) then
 506: LD_VAR 0 1
 510: PPUSH
 511: CALL_OW 261
 515: PUSH
 516: LD_INT 50
 518: LESS
 519: PUSH
 520: LD_INT 1
 522: PPUSH
 523: LD_VAR 0 1
 527: PPUSH
 528: CALL_OW 292
 532: NOT
 533: AND
 534: PUSH
 535: LD_VAR 0 1
 539: PPUSH
 540: CALL_OW 314
 544: NOT
 545: AND
 546: IFFALSE 560
// SetFuel ( unit , 100 ) ;
 548: LD_VAR 0 1
 552: PPUSH
 553: LD_INT 100
 555: PPUSH
 556: CALL_OW 240
// if mode = forest then
 560: LD_VAR 0 2
 564: PUSH
 565: LD_STRING forest
 567: EQUAL
 568: IFFALSE 648
// if GetLives ( unit ) < 600 then
 570: LD_VAR 0 1
 574: PPUSH
 575: CALL_OW 256
 579: PUSH
 580: LD_INT 600
 582: LESS
 583: IFFALSE 648
// begin ComMoveXY ( unit , 42 , 3 ) ;
 585: LD_VAR 0 1
 589: PPUSH
 590: LD_INT 42
 592: PPUSH
 593: LD_INT 3
 595: PPUSH
 596: CALL_OW 111
// SetRememberedX ( unit , GetX ( unit ) ) ;
 600: LD_VAR 0 1
 604: PPUSH
 605: LD_VAR 0 1
 609: PPUSH
 610: CALL_OW 250
 614: PPUSH
 615: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
 619: LD_VAR 0 1
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: CALL_OW 251
 633: PPUSH
 634: CALL_OW 232
// send_troops_to_forest := true ;
 638: LD_ADDR_EXP 14
 642: PUSH
 643: LD_INT 1
 645: ST_TO_ADDR
// break ;
 646: GO 832
// end ; if not HasTask ( unit ) then
 648: LD_VAR 0 1
 652: PPUSH
 653: CALL_OW 314
 657: NOT
 658: IFFALSE 830
// begin for i = 1 to coords do
 660: LD_ADDR_VAR 0 6
 664: PUSH
 665: DOUBLE
 666: LD_INT 1
 668: DEC
 669: ST_TO_ADDR
 670: LD_VAR 0 4
 674: PUSH
 675: FOR_TO
 676: IFFALSE 743
// begin AddComAgressiveMove ( unit , coords [ i ] , coords [ i + 1 ] ) ;
 678: LD_VAR 0 1
 682: PPUSH
 683: LD_VAR 0 4
 687: PUSH
 688: LD_VAR 0 6
 692: ARRAY
 693: PPUSH
 694: LD_VAR 0 4
 698: PUSH
 699: LD_VAR 0 6
 703: PUSH
 704: LD_INT 1
 706: PLUS
 707: ARRAY
 708: PPUSH
 709: CALL_OW 174
// AddComWait ( unit , pause ) ;
 713: LD_VAR 0 1
 717: PPUSH
 718: LD_VAR 0 3
 722: PPUSH
 723: CALL_OW 202
// i := i + 1 ;
 727: LD_ADDR_VAR 0 6
 731: PUSH
 732: LD_VAR 0 6
 736: PUSH
 737: LD_INT 1
 739: PLUS
 740: ST_TO_ADDR
// end ;
 741: GO 675
 743: POP
 744: POP
// for i = coords downto 1 do
 745: LD_ADDR_VAR 0 6
 749: PUSH
 750: DOUBLE
 751: LD_VAR 0 4
 755: INC
 756: ST_TO_ADDR
 757: LD_INT 1
 759: PUSH
 760: FOR_DOWNTO
 761: IFFALSE 828
// begin AddComAgressiveMove ( unit , coords [ i - 1 ] , coords [ i ] ) ;
 763: LD_VAR 0 1
 767: PPUSH
 768: LD_VAR 0 4
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_INT 1
 780: MINUS
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 4
 787: PUSH
 788: LD_VAR 0 6
 792: ARRAY
 793: PPUSH
 794: CALL_OW 174
// AddComWait ( unit , pause ) ;
 798: LD_VAR 0 1
 802: PPUSH
 803: LD_VAR 0 3
 807: PPUSH
 808: CALL_OW 202
// i := i - 1 ;
 812: LD_ADDR_VAR 0 6
 816: PUSH
 817: LD_VAR 0 6
 821: PUSH
 822: LD_INT 1
 824: MINUS
 825: ST_TO_ADDR
// end ;
 826: GO 760
 828: POP
 829: POP
// end ; end ;
 830: GO 474
// end ;
 832: LD_VAR 0 5
 836: RET
// export function DebugSay ( dialog ) ; var speaker ; begin
 837: LD_INT 0
 839: PPUSH
 840: PPUSH
// uc_nation := 1 ;
 841: LD_ADDR_OWVAR 21
 845: PUSH
 846: LD_INT 1
 848: ST_TO_ADDR
// uc_side := 0 ;
 849: LD_ADDR_OWVAR 20
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
 857: LD_INT 0
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: CALL_OW 380
// hc_name := speaker ;
 870: LD_ADDR_OWVAR 26
 874: PUSH
 875: LD_STRING speaker
 877: ST_TO_ADDR
// hc_gallery :=  ;
 878: LD_ADDR_OWVAR 33
 882: PUSH
 883: LD_STRING 
 885: ST_TO_ADDR
// speaker := CreateHuman ;
 886: LD_ADDR_VAR 0 3
 890: PUSH
 891: CALL_OW 44
 895: ST_TO_ADDR
// Say ( speaker , dialog ) ;
 896: LD_VAR 0 3
 900: PPUSH
 901: LD_VAR 0 1
 905: PPUSH
 906: CALL_OW 88
// end ; end_of_file
 910: LD_VAR 0 2
 914: RET
// export JMM , Bobby , Cyrus , Powell , fakePokryshkin ; export function InitAmerican ; begin
 915: LD_INT 0
 917: PPUSH
// uc_nation := 1 ;
 918: LD_ADDR_OWVAR 21
 922: PUSH
 923: LD_INT 1
 925: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , false ) ;
 926: LD_ADDR_EXP 15
 930: PUSH
 931: LD_STRING JMM
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL 189 0 2
 941: ST_TO_ADDR
// uc_side := 4 ;
 942: LD_ADDR_OWVAR 20
 946: PUSH
 947: LD_INT 4
 949: ST_TO_ADDR
// hc_gallery := us ;
 950: LD_ADDR_OWVAR 33
 954: PUSH
 955: LD_STRING us
 957: ST_TO_ADDR
// hc_face_number := 7 ;
 958: LD_ADDR_OWVAR 34
 962: PUSH
 963: LD_INT 7
 965: ST_TO_ADDR
// hc_sex := sex_male ;
 966: LD_ADDR_OWVAR 27
 970: PUSH
 971: LD_INT 1
 973: ST_TO_ADDR
// hc_name := . ;
 974: LD_ADDR_OWVAR 26
 978: PUSH
 979: LD_STRING .
 981: ST_TO_ADDR
// hc_class := 1 ;
 982: LD_ADDR_OWVAR 28
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// Powell := CreateHuman ;
 990: LD_ADDR_EXP 18
 994: PUSH
 995: CALL_OW 44
 999: ST_TO_ADDR
// hc_name := . ;
1000: LD_ADDR_OWVAR 26
1004: PUSH
1005: LD_STRING .
1007: ST_TO_ADDR
// hc_gallery := ru ;
1008: LD_ADDR_OWVAR 33
1012: PUSH
1013: LD_STRING ru
1015: ST_TO_ADDR
// hc_face_number := 4 ;
1016: LD_ADDR_OWVAR 34
1020: PUSH
1021: LD_INT 4
1023: ST_TO_ADDR
// hc_sex := sex_male ;
1024: LD_ADDR_OWVAR 27
1028: PUSH
1029: LD_INT 1
1031: ST_TO_ADDR
// fakePokryshkin := CreateHuman ;
1032: LD_ADDR_EXP 19
1036: PUSH
1037: CALL_OW 44
1041: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , false ) ;
1042: LD_ADDR_EXP 16
1046: PUSH
1047: LD_STRING Bobby
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL 189 0 2
1057: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , false ) ;
1058: LD_ADDR_EXP 17
1062: PUSH
1063: LD_STRING Cyrus
1065: PPUSH
1066: LD_INT 0
1068: PPUSH
1069: CALL 189 0 2
1073: ST_TO_ADDR
// case Difficulty of 1 :
1074: LD_OWVAR 67
1078: PUSH
1079: LD_INT 1
1081: DOUBLE
1082: EQUAL
1083: IFTRUE 1087
1085: GO 1102
1087: POP
// SetLives ( Bobby , 500 ) ; 2 :
1088: LD_EXP 16
1092: PPUSH
1093: LD_INT 500
1095: PPUSH
1096: CALL_OW 234
1100: GO 1149
1102: LD_INT 2
1104: DOUBLE
1105: EQUAL
1106: IFTRUE 1110
1108: GO 1125
1110: POP
// SetLives ( Bobby , 460 ) ; 3 :
1111: LD_EXP 16
1115: PPUSH
1116: LD_INT 460
1118: PPUSH
1119: CALL_OW 234
1123: GO 1149
1125: LD_INT 3
1127: DOUBLE
1128: EQUAL
1129: IFTRUE 1133
1131: GO 1148
1133: POP
// SetLives ( Bobby , 420 ) ; end ;
1134: LD_EXP 16
1138: PPUSH
1139: LD_INT 420
1141: PPUSH
1142: CALL_OW 234
1146: GO 1149
1148: POP
// end ; end_of_file
1149: LD_VAR 0 1
1153: RET
// export russian_troops_1 , russian_troops_2 , russian_patrol_tanks , russian_meta_guards , russian_patrol_forest ; export Pokryshkin ; export function InitRussian ; var skill , i , un ; begin
1154: LD_INT 0
1156: PPUSH
1157: PPUSH
1158: PPUSH
1159: PPUSH
// skill := [ 1 , 2 , 3 ] [ Difficulty ] ;
1160: LD_ADDR_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: PUSH
1168: LD_INT 2
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: PUSH
1179: LD_OWVAR 67
1183: ARRAY
1184: ST_TO_ADDR
// uc_side := 3 ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_INT 3
1192: ST_TO_ADDR
// uc_nation := 3 ;
1193: LD_ADDR_OWVAR 21
1197: PUSH
1198: LD_INT 3
1200: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
1201: LD_ADDR_EXP 25
1205: PUSH
1206: LD_STRING Pokryshkin
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL 189 0 2
1216: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 44 , 5 , false ) ;
1217: LD_EXP 25
1221: PPUSH
1222: LD_INT 44
1224: PPUSH
1225: LD_INT 5
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 48
// hc_importance := 0 ;
1235: LD_ADDR_OWVAR 32
1239: PUSH
1240: LD_INT 0
1242: ST_TO_ADDR
// hc_gallery :=  ;
1243: LD_ADDR_OWVAR 33
1247: PUSH
1248: LD_STRING 
1250: ST_TO_ADDR
// hc_name :=  ;
1251: LD_ADDR_OWVAR 26
1255: PUSH
1256: LD_STRING 
1258: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
1259: LD_INT 1
1261: PPUSH
1262: LD_INT 1
1264: PPUSH
1265: LD_VAR 0 2
1269: PPUSH
1270: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1274: LD_ADDR_OWVAR 33
1278: PUSH
1279: LD_STRING SecondCharsGal
1281: ST_TO_ADDR
// hc_face_number := 69 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 69
1289: ST_TO_ADDR
// hc_sex := sex_male ;
1290: LD_ADDR_OWVAR 27
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// hc_name := Ilja Ivanov ;
1298: LD_ADDR_OWVAR 26
1302: PUSH
1303: LD_STRING Ilja Ivanov
1305: ST_TO_ADDR
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 4
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 1 , un ) ;
1316: LD_ADDR_EXP 20
1320: PUSH
1321: LD_EXP 20
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 4
1333: PPUSH
1334: CALL_OW 2
1338: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 3
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 49
// PrepareHuman ( sex_male , 1 , skill ) ;
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: LD_VAR 0 2
1364: PPUSH
1365: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1369: LD_ADDR_OWVAR 33
1373: PUSH
1374: LD_STRING SecondCharsGal
1376: ST_TO_ADDR
// hc_face_number := 70 ;
1377: LD_ADDR_OWVAR 34
1381: PUSH
1382: LD_INT 70
1384: ST_TO_ADDR
// hc_name := Pavel Starczy ;
1385: LD_ADDR_OWVAR 26
1389: PUSH
1390: LD_STRING Pavel Starczy
1392: ST_TO_ADDR
// un := CreateHuman ;
1393: LD_ADDR_VAR 0 4
1397: PUSH
1398: CALL_OW 44
1402: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 2 , un ) ;
1403: LD_ADDR_EXP 20
1407: PUSH
1408: LD_EXP 20
1412: PPUSH
1413: LD_INT 2
1415: PPUSH
1416: LD_VAR 0 4
1420: PPUSH
1421: CALL_OW 2
1425: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1426: LD_VAR 0 4
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: LD_INT 0
1436: PPUSH
1437: CALL_OW 49
// InitHc ;
1441: CALL_OW 19
// for i = 1 to 7 do
1445: LD_ADDR_VAR 0 3
1449: PUSH
1450: DOUBLE
1451: LD_INT 1
1453: DEC
1454: ST_TO_ADDR
1455: LD_INT 7
1457: PUSH
1458: FOR_TO
1459: IFFALSE 1610
// begin PrepareHuman ( false , 1 , skill ) ;
1461: LD_INT 0
1463: PPUSH
1464: LD_INT 1
1466: PPUSH
1467: LD_VAR 0 2
1471: PPUSH
1472: CALL_OW 380
// un := CreateHuman ;
1476: LD_ADDR_VAR 0 4
1480: PUSH
1481: CALL_OW 44
1485: ST_TO_ADDR
// if i mod 2 = 0 then
1486: LD_VAR 0 3
1490: PUSH
1491: LD_INT 2
1493: MOD
1494: PUSH
1495: LD_INT 0
1497: EQUAL
1498: IFFALSE 1555
// begin russian_troops_1 := Insert ( russian_troops_1 , russian_troops_1 + 1 , un ) ;
1500: LD_ADDR_EXP 20
1504: PUSH
1505: LD_EXP 20
1509: PPUSH
1510: LD_EXP 20
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1529: LD_VAR 0 4
1533: PPUSH
1534: LD_INT 3
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 49
// ComHold ( un ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: CALL_OW 140
// end else
1553: GO 1608
// begin russian_troops_2 := Insert ( russian_troops_2 , russian_troops_2 + 1 , un ) ;
1555: LD_ADDR_EXP 21
1559: PUSH
1560: LD_EXP 21
1564: PPUSH
1565: LD_EXP 21
1569: PUSH
1570: LD_INT 1
1572: PLUS
1573: PPUSH
1574: LD_VAR 0 4
1578: PPUSH
1579: CALL_OW 2
1583: ST_TO_ADDR
// PlaceUnitArea ( un , guard_south , false ) ;
1584: LD_VAR 0 4
1588: PPUSH
1589: LD_INT 4
1591: PPUSH
1592: LD_INT 0
1594: PPUSH
1595: CALL_OW 49
// ComHold ( un ) ;
1599: LD_VAR 0 4
1603: PPUSH
1604: CALL_OW 140
// end ; end ;
1608: GO 1458
1610: POP
1611: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) do
1612: LD_ADDR_VAR 0 3
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 3
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 30
1629: PUSH
1630: LD_INT 31
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: PPUSH
1641: CALL_OW 69
1645: PUSH
1646: FOR_IN
1647: IFFALSE 1665
// PrepareSolBun ( skill , i ) ;
1649: LD_VAR 0 2
1653: PPUSH
1654: LD_VAR 0 3
1658: PPUSH
1659: CALL 246 0 2
1663: GO 1646
1665: POP
1666: POP
// for i = 1 to 2 do
1667: LD_ADDR_VAR 0 3
1671: PUSH
1672: DOUBLE
1673: LD_INT 1
1675: DEC
1676: ST_TO_ADDR
1677: LD_INT 2
1679: PUSH
1680: FOR_TO
1681: IFFALSE 1812
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , 100 ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_INT 3
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: LD_INT 22
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 1
1702: PPUSH
1703: LD_INT 42
1705: PPUSH
1706: LD_INT 100
1708: PPUSH
1709: CALL 382 0 7
1713: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
1714: LD_INT 0
1716: PPUSH
1717: LD_INT 3
1719: PPUSH
1720: LD_VAR 0 2
1724: PPUSH
1725: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
1729: CALL_OW 44
1733: PPUSH
1734: LD_VAR 0 4
1738: PPUSH
1739: CALL_OW 52
// PlaceUnitXY ( un , [ 23 , 131 ] [ i ] , [ 14 , 87 ] [ i ] , false ) ;
1743: LD_VAR 0 4
1747: PPUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 131
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_VAR 0 3
1762: ARRAY
1763: PPUSH
1764: LD_INT 14
1766: PUSH
1767: LD_INT 87
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: LD_VAR 0 3
1778: ARRAY
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 48
// russian_patrol_tanks := Insert ( russian_patrol_tanks , 1 , un ) ;
1787: LD_ADDR_EXP 22
1791: PUSH
1792: LD_EXP 22
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_VAR 0 4
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// end ;
1810: GO 1680
1812: POP
1813: POP
// for i = 1 to 2 do
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: DOUBLE
1820: LD_INT 1
1822: DEC
1823: ST_TO_ADDR
1824: LD_INT 2
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1919
// begin PrepareHuman ( [ sex_female , sex_male , sex_male ] [ i ] , 1 , 1 ) ;
1830: LD_INT 2
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: PUSH
1844: LD_VAR 0 3
1848: ARRAY
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: LD_INT 1
1855: PPUSH
1856: CALL_OW 380
// un := CreateHuman ;
1860: LD_ADDR_VAR 0 4
1864: PUSH
1865: CALL_OW 44
1869: ST_TO_ADDR
// russian_meta_guards := Insert ( russian_meta_guards , 1 , un ) ;
1870: LD_ADDR_EXP 23
1874: PUSH
1875: LD_EXP 23
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: LD_VAR 0 4
1887: PPUSH
1888: CALL_OW 2
1892: ST_TO_ADDR
// PlaceUnitArea ( un , exitArea , false ) ;
1893: LD_VAR 0 4
1897: PPUSH
1898: LD_INT 10
1900: PPUSH
1901: LD_INT 0
1903: PPUSH
1904: CALL_OW 49
// ComHold ( un ) ;
1908: LD_VAR 0 4
1912: PPUSH
1913: CALL_OW 140
// end ;
1917: GO 1827
1919: POP
1920: POP
// if Difficulty < 3 then
1921: LD_OWVAR 67
1925: PUSH
1926: LD_INT 3
1928: LESS
1929: IFFALSE 1933
// exit ;
1931: GO 1976
// PrepareHuman ( false , 1 , skill ) ;
1933: LD_INT 0
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: LD_VAR 0 2
1943: PPUSH
1944: CALL_OW 380
// russian_patrol_forest := CreateHuman ;
1948: LD_ADDR_EXP 24
1952: PUSH
1953: CALL_OW 44
1957: ST_TO_ADDR
// PlaceUnitXY ( russian_patrol_forest , 82 , 2 , false ) ;
1958: LD_EXP 24
1962: PPUSH
1963: LD_INT 82
1965: PPUSH
1966: LD_INT 2
1968: PPUSH
1969: LD_INT 0
1971: PPUSH
1972: CALL_OW 48
// end ;
1976: LD_VAR 0 1
1980: RET
// every 0 0$01 trigger active_road_patrol do
1981: LD_EXP 8
1985: IFFALSE 2051
1987: GO 1989
1989: DISABLE
// ComPatrol ( russian_patrol_tanks [ 1 ] , road , 0 0$02 , [ 131 , 87 , 107 , 75 , 107 , 66 , 114 , 61 , 107 , 34 ] ) ;
1990: LD_EXP 22
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_STRING road
2001: PPUSH
2002: LD_INT 70
2004: PPUSH
2005: LD_INT 131
2007: PUSH
2008: LD_INT 87
2010: PUSH
2011: LD_INT 107
2013: PUSH
2014: LD_INT 75
2016: PUSH
2017: LD_INT 107
2019: PUSH
2020: LD_INT 66
2022: PUSH
2023: LD_INT 114
2025: PUSH
2026: LD_INT 61
2028: PUSH
2029: LD_INT 107
2031: PUSH
2032: LD_INT 34
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 470 0 4
2051: END
// every 0 0$01 trigger active_road_patrol do
2052: LD_EXP 8
2056: IFFALSE 2114
2058: GO 2060
2060: DISABLE
// ComPatrol ( russian_patrol_tanks [ 2 ] , road , 0 0$02 , [ 21 , 12 , 37 , 30 , 65 , 62 , 107 , 76 ] ) ;
2061: LD_EXP 22
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: LD_STRING road
2072: PPUSH
2073: LD_INT 70
2075: PPUSH
2076: LD_INT 21
2078: PUSH
2079: LD_INT 12
2081: PUSH
2082: LD_INT 37
2084: PUSH
2085: LD_INT 30
2087: PUSH
2088: LD_INT 65
2090: PUSH
2091: LD_INT 62
2093: PUSH
2094: LD_INT 107
2096: PUSH
2097: LD_INT 76
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL 470 0 4
2114: END
// every 0 0$01 trigger IsOk ( russian_patrol_forest ) do
2115: LD_EXP 24
2119: PPUSH
2120: CALL_OW 302
2124: IFFALSE 2186
2126: GO 2128
2128: DISABLE
// ComPatrol ( russian_patrol_forest , forest , 0 0$01 , [ 52 , 15 , 81 , 9 , 120 , 52 , 135 , 80 , 122 , 95 ] ) ;
2129: LD_EXP 24
2133: PPUSH
2134: LD_STRING forest
2136: PPUSH
2137: LD_INT 35
2139: PPUSH
2140: LD_INT 52
2142: PUSH
2143: LD_INT 15
2145: PUSH
2146: LD_INT 81
2148: PUSH
2149: LD_INT 9
2151: PUSH
2152: LD_INT 120
2154: PUSH
2155: LD_INT 52
2157: PUSH
2158: LD_INT 135
2160: PUSH
2161: LD_INT 80
2163: PUSH
2164: LD_INT 122
2166: PUSH
2167: LD_INT 95
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL 470 0 4
2186: END
// every 0 0$01 trigger macmilan_use_radio do
2187: LD_EXP 6
2191: IFFALSE 2252
2193: GO 2195
2195: DISABLE
// begin active_road_patrol := false ;
2196: LD_ADDR_EXP 8
2200: PUSH
2201: LD_INT 0
2203: ST_TO_ADDR
// ComStop ( russian_patrol_tanks ) ;
2204: LD_EXP 22
2208: PPUSH
2209: CALL_OW 141
// AddComAgressiveMove ( russian_patrol_tanks , 72 , 41 ) ;
2213: LD_EXP 22
2217: PPUSH
2218: LD_INT 72
2220: PPUSH
2221: LD_INT 41
2223: PPUSH
2224: CALL_OW 174
// ComExitBuilding ( russian_troops_2 ) ;
2228: LD_EXP 21
2232: PPUSH
2233: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , 72 , 41 ) ;
2237: LD_EXP 21
2241: PPUSH
2242: LD_INT 72
2244: PPUSH
2245: LD_INT 41
2247: PPUSH
2248: CALL_OW 174
// end ;
2252: END
// every 0 0$03 trigger FilterUnitsInArea ( def_south , [ f_side , 1 ] ) do var un ;
2253: LD_INT 9
2255: PPUSH
2256: LD_INT 22
2258: PUSH
2259: LD_INT 1
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL_OW 70
2270: IFFALSE 2344
2272: GO 2274
2274: DISABLE
2275: LD_INT 0
2277: PPUSH
// begin enable ;
2278: ENABLE
// un := FilterUnitsInArea ( def_south , [ f_side , 1 ] ) [ 1 ] ;
2279: LD_ADDR_VAR 0 1
2283: PUSH
2284: LD_INT 9
2286: PPUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL_OW 70
2301: PUSH
2302: LD_INT 1
2304: ARRAY
2305: ST_TO_ADDR
// ComExitBuilding ( russian_troops_2 ) ;
2306: LD_EXP 21
2310: PPUSH
2311: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , GetX ( un ) , GetY ( un ) ) ;
2315: LD_EXP 21
2319: PPUSH
2320: LD_VAR 0 1
2324: PPUSH
2325: CALL_OW 250
2329: PPUSH
2330: LD_VAR 0 1
2334: PPUSH
2335: CALL_OW 251
2339: PPUSH
2340: CALL_OW 174
// end ;
2344: PPOPN 1
2346: END
// every 0 0$01 trigger ( GetLives ( russian_patrol_tanks [ 1 ] ) < 999 or GetLives ( russian_patrol_tanks [ 2 ] ) < 999 ) and See ( 3 , JMM ) do
2347: LD_EXP 22
2351: PUSH
2352: LD_INT 1
2354: ARRAY
2355: PPUSH
2356: CALL_OW 256
2360: PUSH
2361: LD_INT 999
2363: LESS
2364: PUSH
2365: LD_EXP 22
2369: PUSH
2370: LD_INT 2
2372: ARRAY
2373: PPUSH
2374: CALL_OW 256
2378: PUSH
2379: LD_INT 999
2381: LESS
2382: OR
2383: PUSH
2384: LD_INT 3
2386: PPUSH
2387: LD_EXP 15
2391: PPUSH
2392: CALL_OW 292
2396: AND
2397: IFFALSE 2424
2399: GO 2401
2401: DISABLE
// begin active_road_patrol := false ;
2402: LD_ADDR_EXP 8
2406: PUSH
2407: LD_INT 0
2409: ST_TO_ADDR
// ComAttackUnit ( russian_patrol_tanks , JMM ) ;
2410: LD_EXP 22
2414: PPUSH
2415: LD_EXP 15
2419: PPUSH
2420: CALL_OW 115
// end ;
2424: END
// every 0 0$01 trigger macmilan_in_trap do
2425: LD_EXP 9
2429: IFFALSE 2475
2431: GO 2433
2433: DISABLE
// begin ComExitBuilding ( russian_troops_2 ) ;
2434: LD_EXP 21
2438: PPUSH
2439: CALL_OW 122
// ComAttackUnit ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , JMM ) ;
2443: LD_EXP 20
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: PUSH
2454: LD_EXP 25
2458: ADD
2459: PUSH
2460: LD_EXP 22
2464: ADD
2465: PPUSH
2466: LD_EXP 15
2470: PPUSH
2471: CALL_OW 115
// end ;
2475: END
// every 0 0$01 trigger meta_action do
2476: LD_EXP 10
2480: IFFALSE 2526
2482: GO 2484
2484: DISABLE
// begin active_road_patrol := false ;
2485: LD_ADDR_EXP 8
2489: PUSH
2490: LD_INT 0
2492: ST_TO_ADDR
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , 93 , 1 ) ;
2493: LD_EXP 20
2497: PUSH
2498: LD_EXP 21
2502: ADD
2503: PUSH
2504: LD_EXP 25
2508: ADD
2509: PUSH
2510: LD_EXP 22
2514: ADD
2515: PPUSH
2516: LD_INT 93
2518: PPUSH
2519: LD_INT 1
2521: PPUSH
2522: CALL_OW 114
// end ;
2526: END
// every 0 0$1 trigger GetLives ( Pokryshkin ) < 1000 do
2527: LD_EXP 25
2531: PPUSH
2532: CALL_OW 256
2536: PUSH
2537: LD_INT 1000
2539: LESS
2540: IFFALSE 2591
2542: GO 2544
2544: DISABLE
// begin enable ;
2545: ENABLE
// if HexInfo ( 18 , 1 ) = Pokryshkin then
2546: LD_INT 18
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 428
2556: PUSH
2557: LD_EXP 25
2561: EQUAL
2562: IFFALSE 2576
// begin RemoveUnit ( Pokryshkin ) ;
2564: LD_EXP 25
2568: PPUSH
2569: CALL_OW 64
// disable ;
2573: DISABLE
// end else
2574: GO 2591
// ComMoveXY ( Pokryshkin , 18 , 1 ) ;
2576: LD_EXP 25
2580: PPUSH
2581: LD_INT 18
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: CALL_OW 111
// end ;
2591: END
// every 0 0$20 trigger send_troops_to_forest do
2592: LD_EXP 14
2596: IFFALSE 2650
2598: GO 2600
2600: DISABLE
// begin if not IsOk ( russian_patrol_forest ) then
2601: LD_EXP 24
2605: PPUSH
2606: CALL_OW 302
2610: NOT
2611: IFFALSE 2615
// exit ;
2613: GO 2650
// ComAgressiveMove ( russian_troops_1 ^ Pokryshkin , GetRememberedX ( russian_patrol_forest ) , GetRememberedY ( russian_patrol_forest ) ) ;
2615: LD_EXP 20
2619: PUSH
2620: LD_EXP 25
2624: ADD
2625: PPUSH
2626: LD_EXP 24
2630: PPUSH
2631: CALL_OW 252
2635: PPUSH
2636: LD_EXP 24
2640: PPUSH
2641: CALL_OW 253
2645: PPUSH
2646: CALL_OW 114
// end ;
2650: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do begin if GetSide ( driver ) = 3 then
2651: LD_VAR 0 1
2655: PPUSH
2656: CALL_OW 255
2660: PUSH
2661: LD_INT 3
2663: EQUAL
2664: IFFALSE 2707
// begin wait ( 11 ) ;
2666: LD_INT 11
2668: PPUSH
2669: CALL_OW 67
// ComEnterUnit ( driver , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_depot ] ) , driver ) ) ;
2673: LD_VAR 0 1
2677: PPUSH
2678: LD_INT 30
2680: PUSH
2681: LD_INT 0
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: PPUSH
2693: LD_VAR 0 1
2697: PPUSH
2698: CALL_OW 74
2702: PPUSH
2703: CALL_OW 120
// end ; end ; end_of_file
2707: PPOPN 4
2709: END
// export function Action ; var i ; begin
2710: LD_INT 0
2712: PPUSH
2713: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_INT 22
2721: PUSH
2722: LD_INT 3
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 25
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2762
// ComHold ( i ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: CALL_OW 140
2760: GO 2748
2762: POP
2763: POP
// InGameOn ;
2764: CALL_OW 8
// CenterOnXY ( 79 , 76 ) ;
2768: LD_INT 79
2770: PPUSH
2771: LD_INT 76
2773: PPUSH
2774: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
2778: LD_INT 10
2780: PPUSH
2781: CALL_OW 67
// PlaceUnitXY ( JMM , 80 , 79 , true ) ;
2785: LD_EXP 15
2789: PPUSH
2790: LD_INT 80
2792: PPUSH
2793: LD_INT 79
2795: PPUSH
2796: LD_INT 1
2798: PPUSH
2799: CALL_OW 48
// Wait ( 0 0$03 ) ;
2803: LD_INT 105
2805: PPUSH
2806: CALL_OW 67
// ComMoveXY ( JMM , 80 , 76 ) ;
2810: LD_EXP 15
2814: PPUSH
2815: LD_INT 80
2817: PPUSH
2818: LD_INT 76
2820: PPUSH
2821: CALL_OW 111
// Say ( JMM , D1-JMM-1 ) ;
2825: LD_EXP 15
2829: PPUSH
2830: LD_STRING D1-JMM-1
2832: PPUSH
2833: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2837: LD_INT 10
2839: PPUSH
2840: CALL_OW 67
// ComMoveXY ( JMM , 76 , 76 ) ;
2844: LD_EXP 15
2848: PPUSH
2849: LD_INT 76
2851: PPUSH
2852: LD_INT 76
2854: PPUSH
2855: CALL_OW 111
// Say ( JMM , D1-JMM-1a ) ;
2859: LD_EXP 15
2863: PPUSH
2864: LD_STRING D1-JMM-1a
2866: PPUSH
2867: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2871: LD_INT 10
2873: PPUSH
2874: CALL_OW 67
// ComTurnXY ( JMM , 83 , 66 ) ;
2878: LD_EXP 15
2882: PPUSH
2883: LD_INT 83
2885: PPUSH
2886: LD_INT 66
2888: PPUSH
2889: CALL_OW 118
// Say ( JMM , D1-JMM-1b ) ;
2893: LD_EXP 15
2897: PPUSH
2898: LD_STRING D1-JMM-1b
2900: PPUSH
2901: CALL_OW 88
// Wait ( 0 0$0.5 ) ;
2905: LD_INT 18
2907: PPUSH
2908: CALL_OW 67
// Say ( JMM , D1-JMM-1c ) ;
2912: LD_EXP 15
2916: PPUSH
2917: LD_STRING D1-JMM-1c
2919: PPUSH
2920: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
2924: LD_INT 7
2926: PPUSH
2927: CALL_OW 67
// SayRadio ( Powell , D1-Pow-1 ) ;
2931: LD_EXP 18
2935: PPUSH
2936: LD_STRING D1-Pow-1
2938: PPUSH
2939: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
2943: LD_EXP 15
2947: PPUSH
2948: LD_STRING D1-JMM-2
2950: PPUSH
2951: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
2955: LD_EXP 18
2959: PPUSH
2960: LD_STRING D1-Pow-2
2962: PPUSH
2963: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
2967: LD_EXP 15
2971: PPUSH
2972: LD_STRING D1-JMM-3
2974: PPUSH
2975: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_STRING D1-Pow-3
2986: PPUSH
2987: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
2991: LD_EXP 15
2995: PPUSH
2996: LD_STRING D1-JMM-4
2998: PPUSH
2999: CALL_OW 88
// ComFree ( JMM ) ;
3003: LD_EXP 15
3007: PPUSH
3008: CALL_OW 139
// Wait ( 0 0$0.3 ) ;
3012: LD_INT 10
3014: PPUSH
3015: CALL_OW 67
// InGameOff ;
3019: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3023: LD_STRING M1
3025: PPUSH
3026: CALL_OW 337
// SaveForQuickRestart ;
3030: CALL_OW 22
// active_russian_dialog := true ;
3034: LD_ADDR_EXP 3
3038: PUSH
3039: LD_INT 1
3041: ST_TO_ADDR
// active_road_patrol := true ;
3042: LD_ADDR_EXP 8
3046: PUSH
3047: LD_INT 1
3049: ST_TO_ADDR
// if Difficulty < 3 then
3050: LD_OWVAR 67
3054: PUSH
3055: LD_INT 3
3057: LESS
3058: IFFALSE 3089
// begin PlaceUnitXY ( Bobby , 41 , 71 , false ) ;
3060: LD_EXP 16
3064: PPUSH
3065: LD_INT 41
3067: PPUSH
3068: LD_INT 71
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 48
// ComHold ( Bobby ) ;
3078: LD_EXP 16
3082: PPUSH
3083: CALL_OW 140
// end else
3087: GO 3137
// begin SetDir ( Bobby , 5 ) ;
3089: LD_EXP 16
3093: PPUSH
3094: LD_INT 5
3096: PPUSH
3097: CALL_OW 233
// PlaceUnitXY ( Bobby , 105 , 98 , false ) ;
3101: LD_EXP 16
3105: PPUSH
3106: LD_INT 105
3108: PPUSH
3109: LD_INT 98
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 48
// ComCrawl ( Bobby ) ;
3119: LD_EXP 16
3123: PPUSH
3124: CALL_OW 137
// AddComHold ( Bobby ) ;
3128: LD_EXP 16
3132: PPUSH
3133: CALL_OW 200
// end ; PlaceUnitXY ( Cyrus , 90 , 42 , false ) ;
3137: LD_EXP 17
3141: PPUSH
3142: LD_INT 90
3144: PPUSH
3145: LD_INT 42
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 48
// ComMoveXY ( Cyrus , 79 , 34 ) ;
3155: LD_EXP 17
3159: PPUSH
3160: LD_INT 79
3162: PPUSH
3163: LD_INT 34
3165: PPUSH
3166: CALL_OW 111
// AddComCrawl ( Cyrus ) ;
3170: LD_EXP 17
3174: PPUSH
3175: CALL_OW 197
// end ;
3179: LD_VAR 0 1
3183: RET
// every 0 0$01 trigger active_russian_dialog do var wait_points ;
3184: LD_EXP 3
3188: IFFALSE 3811
3190: GO 3192
3192: DISABLE
3193: LD_INT 0
3195: PPUSH
// begin wait_points := 0 ;
3196: LD_ADDR_VAR 0 1
3200: PUSH
3201: LD_INT 0
3203: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
3204: LD_INT 70
3206: PPUSH
3207: CALL_OW 67
// ComAgressiveMove ( russian_troops_1 , 79 , 83 ) ;
3211: LD_EXP 20
3215: PPUSH
3216: LD_INT 79
3218: PPUSH
3219: LD_INT 83
3221: PPUSH
3222: CALL_OW 114
// Say ( russian_troops_1 [ 2 ] , D1R-Rus1-1 ) ;
3226: LD_EXP 20
3230: PUSH
3231: LD_INT 2
3233: ARRAY
3234: PPUSH
3235: LD_STRING D1R-Rus1-1
3237: PPUSH
3238: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1R-Rus2-1 ) ;
3242: LD_EXP 20
3246: PUSH
3247: LD_INT 1
3249: ARRAY
3250: PPUSH
3251: LD_STRING D1R-Rus2-1
3253: PPUSH
3254: CALL_OW 88
// ComAgressiveMove ( russian_troops_2 , 91 , 80 ) ;
3258: LD_EXP 21
3262: PPUSH
3263: LD_INT 91
3265: PPUSH
3266: LD_INT 80
3268: PPUSH
3269: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3273: LD_INT 35
3275: PPUSH
3276: CALL_OW 67
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 79 , 82 ) < 5 ;
3280: LD_EXP 20
3284: PUSH
3285: LD_INT 1
3287: ARRAY
3288: PPUSH
3289: LD_INT 79
3291: PPUSH
3292: LD_INT 82
3294: PPUSH
3295: CALL_OW 297
3299: PUSH
3300: LD_INT 5
3302: LESS
3303: IFFALSE 3273
// if not IsInArea ( JMM , jmm_spot ) then
3305: LD_EXP 15
3309: PPUSH
3310: LD_INT 5
3312: PPUSH
3313: CALL_OW 308
3317: NOT
3318: IFFALSE 3338
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1 ) else
3320: LD_EXP 20
3324: PUSH
3325: LD_INT 1
3327: ARRAY
3328: PPUSH
3329: LD_STRING D1Ra-Rus2-1
3331: PPUSH
3332: CALL_OW 88
3336: GO 3474
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3338: LD_EXP 20
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PPUSH
3347: LD_STRING D1Rb-Rus1-1
3349: PPUSH
3350: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Rb-Rus2-1 ) ;
3354: LD_EXP 20
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: LD_STRING D1Rb-Rus2-1
3365: PPUSH
3366: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 , GetX ( JMM ) , GetY ( JMM ) ) ;
3370: LD_EXP 20
3374: PUSH
3375: LD_EXP 21
3379: ADD
3380: PPUSH
3381: LD_EXP 15
3385: PPUSH
3386: CALL_OW 250
3390: PPUSH
3391: LD_EXP 15
3395: PPUSH
3396: CALL_OW 251
3400: PPUSH
3401: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3405: LD_INT 35
3407: PPUSH
3408: CALL_OW 67
// until not IsInArea ( JMM , jmm_spot ) and not See ( 3 , jmm ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_INT 5
3419: PPUSH
3420: CALL_OW 308
3424: NOT
3425: PUSH
3426: LD_INT 3
3428: PPUSH
3429: LD_EXP 15
3433: PPUSH
3434: CALL_OW 292
3438: NOT
3439: AND
3440: IFFALSE 3405
// Say ( russian_troops_1 [ 2 ] , D1Rc-Rus1-1 ) ;
3442: LD_EXP 20
3446: PUSH
3447: LD_INT 2
3449: ARRAY
3450: PPUSH
3451: LD_STRING D1Rc-Rus1-1
3453: PPUSH
3454: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1a ) ;
3458: LD_EXP 20
3462: PUSH
3463: LD_INT 1
3465: ARRAY
3466: PPUSH
3467: LD_STRING D1Ra-Rus2-1a
3469: PPUSH
3470: CALL_OW 88
// end ; wait_points := 10 ;
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: LD_INT 10
3481: ST_TO_ADDR
// if Difficulty > 1 then
3482: LD_OWVAR 67
3486: PUSH
3487: LD_INT 1
3489: GREATER
3490: IFFALSE 3572
// begin ComAgressiveMove ( russian_troops_1 , 78 , 95 ) ;
3492: LD_EXP 20
3496: PPUSH
3497: LD_INT 78
3499: PPUSH
3500: LD_INT 95
3502: PPUSH
3503: CALL_OW 114
// AddComWait ( russian_troops_1 , 0 0$05 ) ;
3507: LD_EXP 20
3511: PPUSH
3512: LD_INT 175
3514: PPUSH
3515: CALL_OW 202
// wait_points := wait_points + 15 ;
3519: LD_ADDR_VAR 0 1
3523: PUSH
3524: LD_VAR 0 1
3528: PUSH
3529: LD_INT 15
3531: PLUS
3532: ST_TO_ADDR
// if Difficulty > 2 then
3533: LD_OWVAR 67
3537: PUSH
3538: LD_INT 2
3540: GREATER
3541: IFFALSE 3572
// begin AddComAgressiveMove ( russian_troops_1 , 65 , 79 ) ;
3543: LD_EXP 20
3547: PPUSH
3548: LD_INT 65
3550: PPUSH
3551: LD_INT 79
3553: PPUSH
3554: CALL_OW 174
// wait_points := wait_points + 5 ;
3558: LD_ADDR_VAR 0 1
3562: PUSH
3563: LD_VAR 0 1
3567: PUSH
3568: LD_INT 5
3570: PLUS
3571: ST_TO_ADDR
// end ; end ; repeat wait ( 0 0$01 ) ;
3572: LD_INT 35
3574: PPUSH
3575: CALL_OW 67
// wait_points := wait_points - 1 ;
3579: LD_ADDR_VAR 0 1
3583: PUSH
3584: LD_VAR 0 1
3588: PUSH
3589: LD_INT 1
3591: MINUS
3592: ST_TO_ADDR
// if See ( 3 , JMM ) then
3593: LD_INT 3
3595: PPUSH
3596: LD_EXP 15
3600: PPUSH
3601: CALL_OW 292
3605: IFFALSE 3659
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3607: LD_EXP 20
3611: PUSH
3612: LD_INT 2
3614: ARRAY
3615: PPUSH
3616: LD_STRING D1Rb-Rus1-1
3618: PPUSH
3619: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3623: LD_EXP 20
3627: PPUSH
3628: LD_EXP 15
3632: PPUSH
3633: CALL_OW 250
3637: PPUSH
3638: LD_EXP 15
3642: PPUSH
3643: CALL_OW 251
3647: PPUSH
3648: CALL_OW 114
// Wait ( 0 0$03 ) ;
3652: LD_INT 105
3654: PPUSH
3655: CALL_OW 67
// end ; until wait_points = 0 ;
3659: LD_VAR 0 1
3663: PUSH
3664: LD_INT 0
3666: EQUAL
3667: IFFALSE 3572
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3669: LD_EXP 20
3673: PPUSH
3674: LD_INT 45
3676: PPUSH
3677: LD_INT 5
3679: PPUSH
3680: CALL_OW 114
// ComEnterUnit ( russian_troops_2 , rbar1 ) ;
3684: LD_EXP 21
3688: PPUSH
3689: LD_INT 26
3691: PPUSH
3692: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
3696: LD_INT 35
3698: PPUSH
3699: CALL_OW 67
// if See ( 3 , JMM ) then
3703: LD_INT 3
3705: PPUSH
3706: LD_EXP 15
3710: PPUSH
3711: CALL_OW 292
3715: IFFALSE 3771
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3717: LD_EXP 20
3721: PUSH
3722: LD_INT 2
3724: ARRAY
3725: PPUSH
3726: LD_STRING D1Rb-Rus1-1
3728: PPUSH
3729: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3733: LD_EXP 20
3737: PPUSH
3738: LD_EXP 15
3742: PPUSH
3743: CALL_OW 250
3747: PPUSH
3748: LD_EXP 15
3752: PPUSH
3753: CALL_OW 251
3757: PPUSH
3758: CALL_OW 114
// Wait ( 0 0$50 ) ;
3762: LD_INT 1750
3764: PPUSH
3765: CALL_OW 67
// end else
3769: GO 3786
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3771: LD_EXP 20
3775: PPUSH
3776: LD_INT 45
3778: PPUSH
3779: LD_INT 5
3781: PPUSH
3782: CALL_OW 114
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 45 , 5 ) < 10 ;
3786: LD_EXP 20
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: PPUSH
3795: LD_INT 45
3797: PPUSH
3798: LD_INT 5
3800: PPUSH
3801: CALL_OW 297
3805: PUSH
3806: LD_INT 10
3808: LESS
3809: IFFALSE 3696
// end ;
3811: PPOPN 1
3813: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 6 ] ] ) and Difficulty = 1 do
3814: LD_INT 22
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 92
3826: PUSH
3827: LD_INT 80
3829: PUSH
3830: LD_INT 83
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PPUSH
3846: CALL_OW 69
3850: PUSH
3851: LD_OWVAR 67
3855: PUSH
3856: LD_INT 1
3858: EQUAL
3859: AND
3860: IFFALSE 3941
3862: GO 3864
3864: DISABLE
// begin PlaceSeeing ( 80 , 83 , 1 , - 7 ) ;
3865: LD_INT 80
3867: PPUSH
3868: LD_INT 83
3870: PPUSH
3871: LD_INT 1
3873: PPUSH
3874: LD_INT 7
3876: NEG
3877: PPUSH
3878: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
3882: LD_INT 35
3884: PPUSH
3885: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 10 ] ] ) ;
3889: LD_INT 22
3891: PUSH
3892: LD_INT 3
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PUSH
3899: LD_INT 92
3901: PUSH
3902: LD_INT 80
3904: PUSH
3905: LD_INT 83
3907: PUSH
3908: LD_INT 10
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: PPUSH
3921: CALL_OW 69
3925: NOT
3926: IFFALSE 3882
// RemoveSeeing ( 80 , 83 , 1 ) ;
3928: LD_INT 80
3930: PPUSH
3931: LD_INT 83
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 331
// end ;
3941: END
// every 0 0$02 trigger GetDistUnits ( JMM , Bobby ) < 9 do
3942: LD_EXP 15
3946: PPUSH
3947: LD_EXP 16
3951: PPUSH
3952: CALL_OW 296
3956: PUSH
3957: LD_INT 9
3959: LESS
3960: IFFALSE 4411
3962: GO 3964
3964: DISABLE
// begin ComWalk ( Bobby ) ;
3965: LD_EXP 16
3969: PPUSH
3970: CALL_OW 138
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
3974: LD_EXP 16
3978: PPUSH
3979: LD_EXP 15
3983: PPUSH
3984: CALL_OW 250
3988: PPUSH
3989: LD_EXP 15
3993: PPUSH
3994: CALL_OW 251
3998: PPUSH
3999: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
4003: LD_INT 35
4005: PPUSH
4006: CALL_OW 67
// until See ( 4 , JMM ) ;
4010: LD_INT 4
4012: PPUSH
4013: LD_EXP 15
4017: PPUSH
4018: CALL_OW 292
4022: IFFALSE 4003
// InGameOn ;
4024: CALL_OW 8
// ComTurnUnit ( JMM , Bobby ) ;
4028: LD_EXP 15
4032: PPUSH
4033: LD_EXP 16
4037: PPUSH
4038: CALL_OW 119
// if cyrus_in_squad and IsOk ( Cyrus ) and GetDistUnits ( JMM , Cyrus ) < 10 then
4042: LD_EXP 7
4046: PUSH
4047: LD_EXP 17
4051: PPUSH
4052: CALL_OW 302
4056: AND
4057: PUSH
4058: LD_EXP 15
4062: PPUSH
4063: LD_EXP 17
4067: PPUSH
4068: CALL_OW 296
4072: PUSH
4073: LD_INT 10
4075: LESS
4076: AND
4077: IFFALSE 4122
// begin ComMoveXY ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4079: LD_EXP 17
4083: PPUSH
4084: LD_EXP 15
4088: PPUSH
4089: CALL_OW 250
4093: PPUSH
4094: LD_EXP 15
4098: PPUSH
4099: CALL_OW 251
4103: PPUSH
4104: CALL_OW 111
// AddComTurnUnit ( Cyrus , Bobby ) ;
4108: LD_EXP 17
4112: PPUSH
4113: LD_EXP 16
4117: PPUSH
4118: CALL_OW 179
// end ; Say ( JMM , D2-JMM-1 ) ;
4122: LD_EXP 15
4126: PPUSH
4127: LD_STRING D2-JMM-1
4129: PPUSH
4130: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4134: LD_INT 10
4136: PPUSH
4137: CALL_OW 67
// ComTurnUnit ( Bobby , JMM ) ;
4141: LD_EXP 16
4145: PPUSH
4146: LD_EXP 15
4150: PPUSH
4151: CALL_OW 119
// Say ( Bobby , D2-Bobby-1 ) ;
4155: LD_EXP 16
4159: PPUSH
4160: LD_STRING D2-Bobby-1
4162: PPUSH
4163: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
4167: LD_EXP 15
4171: PPUSH
4172: LD_STRING D2-JMM-2
4174: PPUSH
4175: CALL_OW 88
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4179: LD_EXP 16
4183: PPUSH
4184: LD_EXP 15
4188: PPUSH
4189: CALL_OW 250
4193: PPUSH
4194: LD_EXP 15
4198: PPUSH
4199: CALL_OW 251
4203: PPUSH
4204: CALL_OW 111
// Say ( Bobby , D2-Bobby-2 ) ;
4208: LD_EXP 16
4212: PPUSH
4213: LD_STRING D2-Bobby-2
4215: PPUSH
4216: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
4220: LD_EXP 15
4224: PPUSH
4225: LD_STRING D2-JMM-3
4227: PPUSH
4228: CALL_OW 88
// ComTurnUnit ( Bobby , JMM ) ;
4232: LD_EXP 16
4236: PPUSH
4237: LD_EXP 15
4241: PPUSH
4242: CALL_OW 119
// Say ( Bobby , D2-Bobby-3 ) ;
4246: LD_EXP 16
4250: PPUSH
4251: LD_STRING D2-Bobby-3
4253: PPUSH
4254: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
4258: LD_EXP 15
4262: PPUSH
4263: LD_STRING D2-JMM-4
4265: PPUSH
4266: CALL_OW 88
// Say ( Bobby , D2-Bobby-4 ) ;
4270: LD_EXP 16
4274: PPUSH
4275: LD_STRING D2-Bobby-4
4277: PPUSH
4278: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
4282: LD_EXP 15
4286: PPUSH
4287: LD_STRING D2-JMM-5
4289: PPUSH
4290: CALL_OW 88
// Say ( Bobby , D2-Bobby-5 ) ;
4294: LD_EXP 16
4298: PPUSH
4299: LD_STRING D2-Bobby-5
4301: PPUSH
4302: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
4306: LD_EXP 15
4310: PPUSH
4311: LD_STRING D2-JMM-6
4313: PPUSH
4314: CALL_OW 88
// if not powell_contact then
4318: LD_EXP 5
4322: NOT
4323: IFFALSE 4349
// begin Say ( Bobby , D2-Bobby-6 ) ;
4325: LD_EXP 16
4329: PPUSH
4330: LD_STRING D2-Bobby-6
4332: PPUSH
4333: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4337: LD_EXP 15
4341: PPUSH
4342: LD_STRING D2-JMM-7
4344: PPUSH
4345: CALL_OW 88
// end ; InGameOff ;
4349: CALL_OW 9
// SetSide ( Bobby , 1 ) ;
4353: LD_EXP 16
4357: PPUSH
4358: LD_INT 1
4360: PPUSH
4361: CALL_OW 235
// ComFree ( [ JMM , Bobby ] ) ;
4365: LD_EXP 15
4369: PUSH
4370: LD_EXP 16
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PPUSH
4379: CALL_OW 139
// bobby_in_squad := true ;
4383: LD_ADDR_EXP 4
4387: PUSH
4388: LD_INT 1
4390: ST_TO_ADDR
// if powell_contact and not cyrus_in_squad then
4391: LD_EXP 5
4395: PUSH
4396: LD_EXP 7
4400: NOT
4401: AND
4402: IFFALSE 4411
// ChangeMissionObjectives ( M2b ) ;
4404: LD_STRING M2b
4406: PPUSH
4407: CALL_OW 337
// end ;
4411: END
// every 0 0$45 trigger active_russian_dialog and not bobby_in_squad and Difficulty < 3 do
4412: LD_EXP 3
4416: PUSH
4417: LD_EXP 4
4421: NOT
4422: AND
4423: PUSH
4424: LD_OWVAR 67
4428: PUSH
4429: LD_INT 3
4431: LESS
4432: AND
4433: IFFALSE 4453
4435: GO 4437
4437: DISABLE
// ComMoveXY ( Bobby , 75 , 83 ) ;
4438: LD_EXP 16
4442: PPUSH
4443: LD_INT 75
4445: PPUSH
4446: LD_INT 83
4448: PPUSH
4449: CALL_OW 111
4453: END
// every 0 0$10 trigger cyrus_in_squad and not bobby_in_squad do
4454: LD_EXP 7
4458: PUSH
4459: LD_EXP 4
4463: NOT
4464: AND
4465: IFFALSE 4494
4467: GO 4469
4469: DISABLE
// begin ComMoveXY ( Bobby , 105 , 97 ) ;
4470: LD_EXP 16
4474: PPUSH
4475: LD_INT 105
4477: PPUSH
4478: LD_INT 97
4480: PPUSH
4481: CALL_OW 111
// AddComCrawl ( Bobby ) ;
4485: LD_EXP 16
4489: PPUSH
4490: CALL_OW 197
// end ;
4494: END
// every 0 0$01 trigger IsInArea ( JMM , obstacle_area ) and GetDistUnits ( JMM , Bobby ) < 7 and bobby_in_squad do
4495: LD_EXP 15
4499: PPUSH
4500: LD_INT 6
4502: PPUSH
4503: CALL_OW 308
4507: PUSH
4508: LD_EXP 15
4512: PPUSH
4513: LD_EXP 16
4517: PPUSH
4518: CALL_OW 296
4522: PUSH
4523: LD_INT 7
4525: LESS
4526: AND
4527: PUSH
4528: LD_EXP 4
4532: AND
4533: IFFALSE 4580
4535: GO 4537
4537: DISABLE
// begin ComHold ( [ JMM , Bobby ] ) ;
4538: LD_EXP 15
4542: PUSH
4543: LD_EXP 16
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: PPUSH
4552: CALL_OW 140
// Say ( JMM , D2a-JMM-1 ) ;
4556: LD_EXP 15
4560: PPUSH
4561: LD_STRING D2a-JMM-1
4563: PPUSH
4564: CALL_OW 88
// Say ( Bobby , D2a-Bobby-1 ) ;
4568: LD_EXP 16
4572: PPUSH
4573: LD_STRING D2a-Bobby-1
4575: PPUSH
4576: CALL_OW 88
// end ;
4580: END
// every 0 0$50 trigger active_russian_dialog and not See ( 3 , JMM ) do
4581: LD_EXP 3
4585: PUSH
4586: LD_INT 3
4588: PPUSH
4589: LD_EXP 15
4593: PPUSH
4594: CALL_OW 292
4598: NOT
4599: AND
4600: IFFALSE 4776
4602: GO 4604
4604: DISABLE
// begin Wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
4605: LD_INT 350
4607: PPUSH
4608: LD_INT 700
4610: PPUSH
4611: CALL_OW 12
4615: PPUSH
4616: CALL_OW 67
// InGameOn ;
4620: CALL_OW 8
// DialogueOn ;
4624: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4628: LD_EXP 18
4632: PPUSH
4633: LD_STRING D3-Pow-1
4635: PPUSH
4636: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
4640: LD_EXP 15
4644: PPUSH
4645: LD_STRING D3-JMM-1
4647: PPUSH
4648: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4652: LD_EXP 18
4656: PPUSH
4657: LD_STRING D3-Pow-2
4659: PPUSH
4660: CALL_OW 94
// Say ( JMM , D3-JMM-2 ) ;
4664: LD_EXP 15
4668: PPUSH
4669: LD_STRING D3-JMM-2
4671: PPUSH
4672: CALL_OW 88
// SayRadio ( Powell , D3-Pow-3 ) ;
4676: LD_EXP 18
4680: PPUSH
4681: LD_STRING D3-Pow-3
4683: PPUSH
4684: CALL_OW 94
// DialogueOff ;
4688: CALL_OW 7
// InGameOff ;
4692: CALL_OW 9
// powell_contact := true ;
4696: LD_ADDR_EXP 5
4700: PUSH
4701: LD_INT 1
4703: ST_TO_ADDR
// SetAreaMapShow ( exitArea , 1 ) ;
4704: LD_INT 10
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 424
// uc_side := 4 ;
4714: LD_ADDR_OWVAR 20
4718: PUSH
4719: LD_INT 4
4721: ST_TO_ADDR
// uc_nation := 1 ;
4722: LD_ADDR_OWVAR 21
4726: PUSH
4727: LD_INT 1
4729: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
4730: LD_ADDR_EXP 18
4734: PUSH
4735: LD_STRING Powell
4737: PPUSH
4738: LD_INT 0
4740: PPUSH
4741: CALL 189 0 2
4745: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
4746: LD_STRING M2
4748: PPUSH
4749: CALL_OW 337
// if not bobby_in_squad then
4753: LD_EXP 4
4757: NOT
4758: IFFALSE 4769
// ChangeMissionObjectives ( M2a ) else
4760: LD_STRING M2a
4762: PPUSH
4763: CALL_OW 337
4767: GO 4776
// ChangeMissionObjectives ( M2b ) ;
4769: LD_STRING M2b
4771: PPUSH
4772: CALL_OW 337
// end ;
4776: END
// every 0 0$01 trigger IsInArea ( JMM , fakeArea ) do
4777: LD_EXP 15
4781: PPUSH
4782: LD_INT 7
4784: PPUSH
4785: CALL_OW 308
4789: IFFALSE 4924
4791: GO 4793
4793: DISABLE
// begin DialogueOn ;
4794: CALL_OW 6
// SayRadio ( fakePokryshkin , D4-Rus3-1 ) ;
4798: LD_EXP 19
4802: PPUSH
4803: LD_STRING D4-Rus3-1
4805: PPUSH
4806: CALL_OW 94
// DialogueOff ;
4810: CALL_OW 7
// ChangeMissionObjectives ( M3a ) ;
4814: LD_STRING M3a
4816: PPUSH
4817: CALL_OW 337
// SetAreaMapShow ( fakeEnd , 1 ) ;
4821: LD_INT 11
4823: PPUSH
4824: LD_INT 1
4826: PPUSH
4827: CALL_OW 424
// Wait ( 0 0$02 ) ;
4831: LD_INT 70
4833: PPUSH
4834: CALL_OW 67
// DialogueOn ;
4838: CALL_OW 6
// SayRadio ( Powell , D4-Pow-1 ) ;
4842: LD_EXP 18
4846: PPUSH
4847: LD_STRING D4-Pow-1
4849: PPUSH
4850: CALL_OW 94
// DialogueOff ;
4854: CALL_OW 7
// ChangeMissionObjectives ( M3b ) ;
4858: LD_STRING M3b
4860: PPUSH
4861: CALL_OW 337
// case Query ( Q1 ) of 1 :
4865: LD_STRING Q1
4867: PPUSH
4868: CALL_OW 97
4872: PUSH
4873: LD_INT 1
4875: DOUBLE
4876: EQUAL
4877: IFTRUE 4881
4879: GO 4912
4881: POP
// begin macmilan_use_radio := true ;
4882: LD_ADDR_EXP 6
4886: PUSH
4887: LD_INT 1
4889: ST_TO_ADDR
// DialogueOn ;
4890: CALL_OW 6
// Say ( JMM , D4a-JMM-1 ) ;
4894: LD_EXP 15
4898: PPUSH
4899: LD_STRING D4a-JMM-1
4901: PPUSH
4902: CALL_OW 88
// DialogueOff ;
4906: CALL_OW 7
// end ; 2 :
4910: GO 4924
4912: LD_INT 2
4914: DOUBLE
4915: EQUAL
4916: IFTRUE 4920
4918: GO 4923
4920: POP
// ; end ;
4921: GO 4924
4923: POP
// end ;
4924: END
// every 0 0$02 trigger GetDistUnits ( JMM , Cyrus ) < 8 do
4925: LD_EXP 15
4929: PPUSH
4930: LD_EXP 17
4934: PPUSH
4935: CALL_OW 296
4939: PUSH
4940: LD_INT 8
4942: LESS
4943: IFFALSE 5234
4945: GO 4947
4947: DISABLE
// begin InGameOn ;
4948: CALL_OW 8
// ComMoveXY ( JMM , GetX ( Cyrus ) , GetY ( Cyrus ) ) ;
4952: LD_EXP 15
4956: PPUSH
4957: LD_EXP 17
4961: PPUSH
4962: CALL_OW 250
4966: PPUSH
4967: LD_EXP 17
4971: PPUSH
4972: CALL_OW 251
4976: PPUSH
4977: CALL_OW 111
// if IsOk ( Bobby ) and bobby_in_squad then
4981: LD_EXP 16
4985: PPUSH
4986: CALL_OW 302
4990: PUSH
4991: LD_EXP 4
4995: AND
4996: IFFALSE 5027
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4998: LD_EXP 16
5002: PPUSH
5003: LD_EXP 15
5007: PPUSH
5008: CALL_OW 250
5012: PPUSH
5013: LD_EXP 15
5017: PPUSH
5018: CALL_OW 251
5022: PPUSH
5023: CALL_OW 111
// Say ( JMM , D5-JMM-1 ) ;
5027: LD_EXP 15
5031: PPUSH
5032: LD_STRING D5-JMM-1
5034: PPUSH
5035: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5039: LD_INT 10
5041: PPUSH
5042: CALL_OW 67
// ComTurnUnit ( JMM , Cyrus ) ;
5046: LD_EXP 15
5050: PPUSH
5051: LD_EXP 17
5055: PPUSH
5056: CALL_OW 119
// ComWalk ( Cyrus ) ;
5060: LD_EXP 17
5064: PPUSH
5065: CALL_OW 138
// ComTurnUnit ( Cyrus , JMM ) ;
5069: LD_EXP 17
5073: PPUSH
5074: LD_EXP 15
5078: PPUSH
5079: CALL_OW 119
// Say ( Cyrus , D5-Cyrus-1 ) ;
5083: LD_EXP 17
5087: PPUSH
5088: LD_STRING D5-Cyrus-1
5090: PPUSH
5091: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5095: LD_EXP 16
5099: PPUSH
5100: CALL_OW 302
5104: PUSH
5105: LD_EXP 4
5109: AND
5110: IFFALSE 5150
// begin ComTurnUnit ( Bobby , Cyrus ) ;
5112: LD_EXP 16
5116: PPUSH
5117: LD_EXP 17
5121: PPUSH
5122: CALL_OW 119
// Say ( Bobby , D5-Bobby-1 ) ;
5126: LD_EXP 16
5130: PPUSH
5131: LD_STRING D5-Bobby-1
5133: PPUSH
5134: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
5138: LD_EXP 15
5142: PPUSH
5143: LD_STRING D5-JMM-2
5145: PPUSH
5146: CALL_OW 88
// end ; InGameOff ;
5150: CALL_OW 9
// cyrus_in_squad := true ;
5154: LD_ADDR_EXP 7
5158: PUSH
5159: LD_INT 1
5161: ST_TO_ADDR
// SetSide ( Cyrus , 1 ) ;
5162: LD_EXP 17
5166: PPUSH
5167: LD_INT 1
5169: PPUSH
5170: CALL_OW 235
// if powell_contact and not bobby_in_squad then
5174: LD_EXP 5
5178: PUSH
5179: LD_EXP 4
5183: NOT
5184: AND
5185: IFFALSE 5194
// ChangeMissionObjectives ( M2b ) ;
5187: LD_STRING M2b
5189: PPUSH
5190: CALL_OW 337
// if not bobby_in_squad and GetSide ( Bobby ) = 4 and IsOk ( Bobby ) then
5194: LD_EXP 4
5198: NOT
5199: PUSH
5200: LD_EXP 16
5204: PPUSH
5205: CALL_OW 255
5209: PUSH
5210: LD_INT 4
5212: EQUAL
5213: AND
5214: PUSH
5215: LD_EXP 16
5219: PPUSH
5220: CALL_OW 302
5224: AND
5225: IFFALSE 5234
// SetAchievement ( ACH_CYRUS ) ;
5227: LD_STRING ACH_CYRUS
5229: PPUSH
5230: CALL_OW 543
// end ;
5234: END
// every 0 0$01 trigger bobby_in_squad and cyrus_in_squad do
5235: LD_EXP 4
5239: PUSH
5240: LD_EXP 7
5244: AND
5245: IFFALSE 5257
5247: GO 5249
5249: DISABLE
// ChangeMissionObjectives ( M2c ) ;
5250: LD_STRING M2c
5252: PPUSH
5253: CALL_OW 337
5257: END
// every 0 0$01 trigger IsInArea ( JMM , trap ) do
5258: LD_EXP 15
5262: PPUSH
5263: LD_INT 8
5265: PPUSH
5266: CALL_OW 308
5270: IFFALSE 5322
5272: GO 5274
5274: DISABLE
// begin macmilan_in_trap := true ;
5275: LD_ADDR_EXP 9
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5283: LD_INT 35
5285: PPUSH
5286: CALL_OW 67
// DialogueOn ;
5290: CALL_OW 6
// Say ( Pokryshkin , D5-Pok-1 ) ;
5294: LD_EXP 25
5298: PPUSH
5299: LD_STRING D5-Pok-1
5301: PPUSH
5302: CALL_OW 88
// DialogueOff ;
5306: CALL_OW 7
// Say ( JMM , D4b-JMM-1 ) ;
5310: LD_EXP 15
5314: PPUSH
5315: LD_STRING D4b-JMM-1
5317: PPUSH
5318: CALL_OW 88
// end ;
5322: END
// every 0 0$01 trigger GetDistUnits ( JMM , russian_meta_guards [ russian_meta_guards ] ) < 12 or UnitFilter ( russian_meta_guards , [ f_not , [ f_lives , 990 ] ] ) do var i , hp ;
5323: LD_EXP 15
5327: PPUSH
5328: LD_EXP 23
5332: PUSH
5333: LD_EXP 23
5337: ARRAY
5338: PPUSH
5339: CALL_OW 296
5343: PUSH
5344: LD_INT 12
5346: LESS
5347: PUSH
5348: LD_EXP 23
5352: PPUSH
5353: LD_INT 3
5355: PUSH
5356: LD_INT 24
5358: PUSH
5359: LD_INT 990
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PPUSH
5370: CALL_OW 72
5374: OR
5375: IFFALSE 5605
5377: GO 5379
5379: DISABLE
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
// begin hp := [ 300 , 250 , 200 ] [ Difficulty ] ;
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_INT 300
5391: PUSH
5392: LD_INT 250
5394: PUSH
5395: LD_INT 200
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: LIST
5402: PUSH
5403: LD_OWVAR 67
5407: ARRAY
5408: ST_TO_ADDR
// for i in russian_meta_guards do
5409: LD_ADDR_VAR 0 1
5413: PUSH
5414: LD_EXP 23
5418: PUSH
5419: FOR_IN
5420: IFFALSE 5460
// if IsOk ( i ) then
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 302
5431: IFFALSE 5458
// SetLives ( i , GetLives ( i ) - hp ) ;
5433: LD_VAR 0 1
5437: PPUSH
5438: LD_VAR 0 1
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_VAR 0 2
5452: MINUS
5453: PPUSH
5454: CALL_OW 234
5458: GO 5419
5460: POP
5461: POP
// DialogueOn ;
5462: CALL_OW 6
// Say ( russian_meta_guards [ russian_meta_guards ] , D6-FRus1-1 ) ;
5466: LD_EXP 23
5470: PUSH
5471: LD_EXP 23
5475: ARRAY
5476: PPUSH
5477: LD_STRING D6-FRus1-1
5479: PPUSH
5480: CALL_OW 88
// Say ( JMM , D6-JMM-1 ) ;
5484: LD_EXP 15
5488: PPUSH
5489: LD_STRING D6-JMM-1
5491: PPUSH
5492: CALL_OW 88
// if IsOk ( Cyrus ) and cyrus_in_squad then
5496: LD_EXP 17
5500: PPUSH
5501: CALL_OW 302
5505: PUSH
5506: LD_EXP 7
5510: AND
5511: IFFALSE 5525
// Say ( Cyrus , D6-Cyrus-1 ) ;
5513: LD_EXP 17
5517: PPUSH
5518: LD_STRING D6-Cyrus-1
5520: PPUSH
5521: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5525: LD_EXP 16
5529: PPUSH
5530: CALL_OW 302
5534: PUSH
5535: LD_EXP 4
5539: AND
5540: IFFALSE 5554
// Say ( Bobby , D6-Bobby-1 ) ;
5542: LD_EXP 16
5546: PPUSH
5547: LD_STRING D6-Bobby-1
5549: PPUSH
5550: CALL_OW 88
// DialogueOff ;
5554: CALL_OW 7
// Wait ( [ 0 0$04 , 0 0$03 , 0 0$02 ] [ Difficulty ] ) ;
5558: LD_INT 140
5560: PUSH
5561: LD_INT 105
5563: PUSH
5564: LD_INT 70
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: LD_OWVAR 67
5576: ARRAY
5577: PPUSH
5578: CALL_OW 67
// meta_action := true ;
5582: LD_ADDR_EXP 10
5586: PUSH
5587: LD_INT 1
5589: ST_TO_ADDR
// ComAgressiveMove ( russian_meta_guards , 94 , 8 ) ;
5590: LD_EXP 23
5594: PPUSH
5595: LD_INT 94
5597: PPUSH
5598: LD_INT 8
5600: PPUSH
5601: CALL_OW 114
// end ;
5605: PPOPN 2
5607: END
// every 0 0$01 trigger GetDistUnitXY ( JMM , 93 , 1 ) < 5 and FilterAllUnits ( [ f_side , 1 ] ) > 1 do
5608: LD_EXP 15
5612: PPUSH
5613: LD_INT 93
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 297
5623: PUSH
5624: LD_INT 5
5626: LESS
5627: PUSH
5628: LD_INT 22
5630: PUSH
5631: LD_INT 1
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: PPUSH
5638: CALL_OW 69
5642: PUSH
5643: LD_INT 1
5645: GREATER
5646: AND
5647: IFFALSE 5664
5649: GO 5651
5651: DISABLE
// Say ( JMM , D6a-JMM-1 ) ;
5652: LD_EXP 15
5656: PPUSH
5657: LD_STRING D6a-JMM-1
5659: PPUSH
5660: CALL_OW 88
5664: END
// on UnitGoesToRed ( un ) do begin if un = JMM then
5665: LD_VAR 0 1
5669: PUSH
5670: LD_EXP 15
5674: EQUAL
5675: IFFALSE 5684
// YouLost ( JMM ) ;
5677: LD_STRING JMM
5679: PPUSH
5680: CALL_OW 104
// end ;
5684: PPOPN 1
5686: END
// on UnitDestroyed ( un ) do begin if un = JMM then
5687: LD_VAR 0 1
5691: PUSH
5692: LD_EXP 15
5696: EQUAL
5697: IFFALSE 5706
// YouLost ( JMM ) ;
5699: LD_STRING JMM
5701: PPUSH
5702: CALL_OW 104
// end ;
5706: PPOPN 1
5708: END
// every 0 0$01 trigger IsInArea ( Bobby , exitArea ) do
5709: LD_EXP 16
5713: PPUSH
5714: LD_INT 10
5716: PPUSH
5717: CALL_OW 308
5721: IFFALSE 5770
5723: GO 5725
5725: DISABLE
// begin bobby_saved := true ;
5726: LD_ADDR_EXP 12
5730: PUSH
5731: LD_INT 1
5733: ST_TO_ADDR
// SaveVariable ( GetLives ( Bobby ) , 01_BobbyLifePoints_1 ) ;
5734: LD_EXP 16
5738: PPUSH
5739: CALL_OW 256
5743: PPUSH
5744: LD_STRING 01_BobbyLifePoints_1
5746: PPUSH
5747: CALL_OW 39
// RemoveUnit ( Bobby ) ;
5751: LD_EXP 16
5755: PPUSH
5756: CALL_OW 64
// AddMedal ( Bobby , 1 ) ;
5760: LD_STRING Bobby
5762: PPUSH
5763: LD_INT 1
5765: PPUSH
5766: CALL_OW 101
// end ;
5770: END
// every 0 0$01 trigger IsInArea ( Cyrus , exitArea ) do
5771: LD_EXP 17
5775: PPUSH
5776: LD_INT 10
5778: PPUSH
5779: CALL_OW 308
5783: IFFALSE 5832
5785: GO 5787
5787: DISABLE
// begin cyrus_saved := true ;
5788: LD_ADDR_EXP 13
5792: PUSH
5793: LD_INT 1
5795: ST_TO_ADDR
// SaveVariable ( GetLives ( Cyrus ) , 01_CyrusLifePoints_1 ) ;
5796: LD_EXP 17
5800: PPUSH
5801: CALL_OW 256
5805: PPUSH
5806: LD_STRING 01_CyrusLifePoints_1
5808: PPUSH
5809: CALL_OW 39
// RemoveUnit ( Cyrus ) ;
5813: LD_EXP 17
5817: PPUSH
5818: CALL_OW 64
// AddMedal ( Cyrus , 1 ) ;
5822: LD_STRING Cyrus
5824: PPUSH
5825: LD_INT 1
5827: PPUSH
5828: CALL_OW 101
// end ;
5832: END
// every 0 0$01 trigger IsInArea ( JMM , exitArea ) do var i , to_reward , wait_for_them , m1 , m2 , m3 ;
5833: LD_EXP 15
5837: PPUSH
5838: LD_INT 10
5840: PPUSH
5841: CALL_OW 308
5845: IFFALSE 6453
5847: GO 5849
5849: DISABLE
5850: LD_INT 0
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
// begin if macmilan_use_radio then
5858: LD_EXP 6
5862: IFFALSE 5871
// SetAchievement ( ACH_RADIO ) ;
5864: LD_STRING ACH_RADIO
5866: PPUSH
5867: CALL_OW 543
// if ( not cyrus_saved and cyrus_in_squad and IsOk ( Cyrus ) ) or ( not bobby_saved and bobby_in_squad and IsOk ( Bobby ) ) then
5871: LD_EXP 13
5875: NOT
5876: PUSH
5877: LD_EXP 7
5881: AND
5882: PUSH
5883: LD_EXP 17
5887: PPUSH
5888: CALL_OW 302
5892: AND
5893: PUSH
5894: LD_EXP 12
5898: NOT
5899: PUSH
5900: LD_EXP 4
5904: AND
5905: PUSH
5906: LD_EXP 16
5910: PPUSH
5911: CALL_OW 302
5915: AND
5916: OR
5917: IFFALSE 5958
// case Query ( Q2 ) of 1 :
5919: LD_STRING Q2
5921: PPUSH
5922: CALL_OW 97
5926: PUSH
5927: LD_INT 1
5929: DOUBLE
5930: EQUAL
5931: IFTRUE 5935
5933: GO 5946
5935: POP
// wait_for_them := true ; 2 :
5936: LD_ADDR_VAR 0 3
5940: PUSH
5941: LD_INT 1
5943: ST_TO_ADDR
5944: GO 5958
5946: LD_INT 2
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5954
5952: GO 5957
5954: POP
// ; end ;
5955: GO 5958
5957: POP
// if wait_for_them then
5958: LD_VAR 0 3
5962: IFFALSE 6075
// repeat wait ( 0 0$01 ) ;
5964: LD_INT 35
5966: PPUSH
5967: CALL_OW 67
// until ( cyrus_saved and bobby_saved ) or ( cyrus_saved and ( not bobby_in_squad or IsDying ( Bobby ) or IsDead ( Bobby ) ) ) or ( bobby_saved and ( not cyrus_in_squad or IsDying ( Cyrus ) or IsDead ( Cyrus ) ) ) or ( IsDead ( Bobby ) and IsDead ( Cyrus ) ) ;
5971: LD_EXP 13
5975: PUSH
5976: LD_EXP 12
5980: AND
5981: PUSH
5982: LD_EXP 13
5986: PUSH
5987: LD_EXP 4
5991: NOT
5992: PUSH
5993: LD_EXP 16
5997: PPUSH
5998: CALL_OW 303
6002: OR
6003: PUSH
6004: LD_EXP 16
6008: PPUSH
6009: CALL_OW 301
6013: OR
6014: AND
6015: OR
6016: PUSH
6017: LD_EXP 12
6021: PUSH
6022: LD_EXP 7
6026: NOT
6027: PUSH
6028: LD_EXP 17
6032: PPUSH
6033: CALL_OW 303
6037: OR
6038: PUSH
6039: LD_EXP 17
6043: PPUSH
6044: CALL_OW 301
6048: OR
6049: AND
6050: OR
6051: PUSH
6052: LD_EXP 16
6056: PPUSH
6057: CALL_OW 301
6061: PUSH
6062: LD_EXP 17
6066: PPUSH
6067: CALL_OW 301
6071: AND
6072: OR
6073: IFFALSE 5964
// SaveVariable ( GetLives ( JMM ) , 01_JMMLifePoints_1 ) ;
6075: LD_EXP 15
6079: PPUSH
6080: CALL_OW 256
6084: PPUSH
6085: LD_STRING 01_JMMLifePoints_1
6087: PPUSH
6088: CALL_OW 39
// RemoveUnit ( JMM ) ;
6092: LD_EXP 15
6096: PPUSH
6097: CALL_OW 64
// to_reward := [ JMM ] ;
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_EXP 15
6110: PUSH
6111: EMPTY
6112: LIST
6113: ST_TO_ADDR
// if bobby_saved then
6114: LD_EXP 12
6118: IFFALSE 6136
// to_reward := to_reward ^ Bobby ;
6120: LD_ADDR_VAR 0 2
6124: PUSH
6125: LD_VAR 0 2
6129: PUSH
6130: LD_EXP 16
6134: ADD
6135: ST_TO_ADDR
// if cyrus_saved then
6136: LD_EXP 13
6140: IFFALSE 6158
// to_reward := to_reward ^ Cyrus ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_EXP 17
6156: ADD
6157: ST_TO_ADDR
// m1 := true ;
6158: LD_ADDR_VAR 0 4
6162: PUSH
6163: LD_INT 1
6165: ST_TO_ADDR
// m2 := bobby_saved ;
6166: LD_ADDR_VAR 0 5
6170: PUSH
6171: LD_EXP 12
6175: ST_TO_ADDR
// m3 := cyrus_saved ;
6176: LD_ADDR_VAR 0 6
6180: PUSH
6181: LD_EXP 13
6185: ST_TO_ADDR
// AddMedal ( JMM , 1 ) ;
6186: LD_STRING JMM
6188: PPUSH
6189: LD_INT 1
6191: PPUSH
6192: CALL_OW 101
// if not bobby_in_squad then
6196: LD_EXP 4
6200: NOT
6201: IFFALSE 6214
// AddMedal ( Bobby , - 1 ) ;
6203: LD_STRING Bobby
6205: PPUSH
6206: LD_INT 1
6208: NEG
6209: PPUSH
6210: CALL_OW 101
// if not bobby_saved and ( IsDying ( Bobby ) or IsDead ( Bobby ) ) then
6214: LD_EXP 12
6218: NOT
6219: PUSH
6220: LD_EXP 16
6224: PPUSH
6225: CALL_OW 303
6229: PUSH
6230: LD_EXP 16
6234: PPUSH
6235: CALL_OW 301
6239: OR
6240: AND
6241: IFFALSE 6254
// AddMedal ( Bobby , - 2 ) ;
6243: LD_STRING Bobby
6245: PPUSH
6246: LD_INT 2
6248: NEG
6249: PPUSH
6250: CALL_OW 101
// if not cyrus_in_squad then
6254: LD_EXP 7
6258: NOT
6259: IFFALSE 6272
// AddMedal ( Cyrus , - 1 ) ;
6261: LD_STRING Cyrus
6263: PPUSH
6264: LD_INT 1
6266: NEG
6267: PPUSH
6268: CALL_OW 101
// if not cyrus_saved and ( IsDying ( Cyrus ) or IsDead ( Cyrus ) ) then
6272: LD_EXP 13
6276: NOT
6277: PUSH
6278: LD_EXP 17
6282: PPUSH
6283: CALL_OW 303
6287: PUSH
6288: LD_EXP 17
6292: PPUSH
6293: CALL_OW 301
6297: OR
6298: AND
6299: IFFALSE 6312
// AddMedal ( Cyrus , - 2 ) ;
6301: LD_STRING Cyrus
6303: PPUSH
6304: LD_INT 2
6306: NEG
6307: PPUSH
6308: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
6312: LD_OWVAR 67
6316: PUSH
6317: LD_INT 3
6319: EQUAL
6320: PUSH
6321: LD_VAR 0 4
6325: AND
6326: PUSH
6327: LD_VAR 0 5
6331: AND
6332: PUSH
6333: LD_VAR 0 6
6337: AND
6338: IFFALSE 6350
// SetAchievementEX ( ACH_AMER , 1 ) ;
6340: LD_STRING ACH_AMER
6342: PPUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL_OW 564
// GiveMedals ( MAIN ) ;
6350: LD_STRING MAIN
6352: PPUSH
6353: CALL_OW 102
// RewardPeople ( to_reward ) ;
6357: LD_VAR 0 2
6361: PPUSH
6362: CALL_OW 43
// if bobby_saved then
6366: LD_EXP 12
6370: IFFALSE 6390
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
6372: LD_EXP 16
6376: PPUSH
6377: LD_EXP 2
6381: PUSH
6382: LD_STRING Bobby
6384: STR
6385: PPUSH
6386: CALL_OW 38
// if cyrus_saved then
6390: LD_EXP 13
6394: IFFALSE 6414
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
6396: LD_EXP 17
6400: PPUSH
6401: LD_EXP 2
6405: PUSH
6406: LD_STRING Cyrus
6408: STR
6409: PPUSH
6410: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
6414: LD_EXP 15
6418: PPUSH
6419: LD_EXP 2
6423: PUSH
6424: LD_STRING JMM
6426: STR
6427: PPUSH
6428: CALL_OW 38
// if tick <= 3 3$00 then
6432: LD_OWVAR 1
6436: PUSH
6437: LD_INT 6300
6439: LESSEQUAL
6440: IFFALSE 6449
// SetAchievement ( ACH_ASPEED_1 ) ;
6442: LD_STRING ACH_ASPEED_1
6444: PPUSH
6445: CALL_OW 543
// YouWin ;
6449: CALL_OW 103
// end ; end_of_file end_of_file
6453: PPOPN 6
6455: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
6456: GO 6458
6458: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6459: LD_STRING initStreamRollete();
6461: PPUSH
6462: CALL_OW 559
// InitStreamMode ;
6466: CALL 6475 0 0
// DefineStreamItems ( ) ;
6470: CALL 6915 0 0
// end ;
6474: END
// function InitStreamMode ; begin
6475: LD_INT 0
6477: PPUSH
// streamModeActive := false ;
6478: LD_ADDR_EXP 26
6482: PUSH
6483: LD_INT 0
6485: ST_TO_ADDR
// normalCounter := 26 ;
6486: LD_ADDR_EXP 27
6490: PUSH
6491: LD_INT 26
6493: ST_TO_ADDR
// hardcoreCounter := 12 ;
6494: LD_ADDR_EXP 28
6498: PUSH
6499: LD_INT 12
6501: ST_TO_ADDR
// sRocket := false ;
6502: LD_ADDR_EXP 31
6506: PUSH
6507: LD_INT 0
6509: ST_TO_ADDR
// sSpeed := false ;
6510: LD_ADDR_EXP 30
6514: PUSH
6515: LD_INT 0
6517: ST_TO_ADDR
// sEngine := false ;
6518: LD_ADDR_EXP 32
6522: PUSH
6523: LD_INT 0
6525: ST_TO_ADDR
// sSpec := false ;
6526: LD_ADDR_EXP 29
6530: PUSH
6531: LD_INT 0
6533: ST_TO_ADDR
// sLevel := false ;
6534: LD_ADDR_EXP 33
6538: PUSH
6539: LD_INT 0
6541: ST_TO_ADDR
// sArmoury := false ;
6542: LD_ADDR_EXP 34
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// sRadar := false ;
6550: LD_ADDR_EXP 35
6554: PUSH
6555: LD_INT 0
6557: ST_TO_ADDR
// sBunker := false ;
6558: LD_ADDR_EXP 36
6562: PUSH
6563: LD_INT 0
6565: ST_TO_ADDR
// sHack := false ;
6566: LD_ADDR_EXP 37
6570: PUSH
6571: LD_INT 0
6573: ST_TO_ADDR
// sFire := false ;
6574: LD_ADDR_EXP 38
6578: PUSH
6579: LD_INT 0
6581: ST_TO_ADDR
// sRefresh := false ;
6582: LD_ADDR_EXP 39
6586: PUSH
6587: LD_INT 0
6589: ST_TO_ADDR
// sExp := false ;
6590: LD_ADDR_EXP 40
6594: PUSH
6595: LD_INT 0
6597: ST_TO_ADDR
// sDepot := false ;
6598: LD_ADDR_EXP 41
6602: PUSH
6603: LD_INT 0
6605: ST_TO_ADDR
// sFlag := false ;
6606: LD_ADDR_EXP 42
6610: PUSH
6611: LD_INT 0
6613: ST_TO_ADDR
// sKamikadze := false ;
6614: LD_ADDR_EXP 50
6618: PUSH
6619: LD_INT 0
6621: ST_TO_ADDR
// sTroll := false ;
6622: LD_ADDR_EXP 51
6626: PUSH
6627: LD_INT 0
6629: ST_TO_ADDR
// sSlow := false ;
6630: LD_ADDR_EXP 52
6634: PUSH
6635: LD_INT 0
6637: ST_TO_ADDR
// sLack := false ;
6638: LD_ADDR_EXP 53
6642: PUSH
6643: LD_INT 0
6645: ST_TO_ADDR
// sTank := false ;
6646: LD_ADDR_EXP 55
6650: PUSH
6651: LD_INT 0
6653: ST_TO_ADDR
// sRemote := false ;
6654: LD_ADDR_EXP 56
6658: PUSH
6659: LD_INT 0
6661: ST_TO_ADDR
// sPowell := false ;
6662: LD_ADDR_EXP 57
6666: PUSH
6667: LD_INT 0
6669: ST_TO_ADDR
// sTeleport := false ;
6670: LD_ADDR_EXP 60
6674: PUSH
6675: LD_INT 0
6677: ST_TO_ADDR
// sOilTower := false ;
6678: LD_ADDR_EXP 62
6682: PUSH
6683: LD_INT 0
6685: ST_TO_ADDR
// sShovel := false ;
6686: LD_ADDR_EXP 63
6690: PUSH
6691: LD_INT 0
6693: ST_TO_ADDR
// sSheik := false ;
6694: LD_ADDR_EXP 64
6698: PUSH
6699: LD_INT 0
6701: ST_TO_ADDR
// sEarthquake := false ;
6702: LD_ADDR_EXP 66
6706: PUSH
6707: LD_INT 0
6709: ST_TO_ADDR
// sAI := false ;
6710: LD_ADDR_EXP 67
6714: PUSH
6715: LD_INT 0
6717: ST_TO_ADDR
// sCargo := false ;
6718: LD_ADDR_EXP 70
6722: PUSH
6723: LD_INT 0
6725: ST_TO_ADDR
// sDLaser := false ;
6726: LD_ADDR_EXP 71
6730: PUSH
6731: LD_INT 0
6733: ST_TO_ADDR
// sExchange := false ;
6734: LD_ADDR_EXP 72
6738: PUSH
6739: LD_INT 0
6741: ST_TO_ADDR
// sFac := false ;
6742: LD_ADDR_EXP 73
6746: PUSH
6747: LD_INT 0
6749: ST_TO_ADDR
// sPower := false ;
6750: LD_ADDR_EXP 74
6754: PUSH
6755: LD_INT 0
6757: ST_TO_ADDR
// sRandom := false ;
6758: LD_ADDR_EXP 75
6762: PUSH
6763: LD_INT 0
6765: ST_TO_ADDR
// sShield := false ;
6766: LD_ADDR_EXP 76
6770: PUSH
6771: LD_INT 0
6773: ST_TO_ADDR
// sTime := false ;
6774: LD_ADDR_EXP 77
6778: PUSH
6779: LD_INT 0
6781: ST_TO_ADDR
// sTools := false ;
6782: LD_ADDR_EXP 78
6786: PUSH
6787: LD_INT 0
6789: ST_TO_ADDR
// sSold := false ;
6790: LD_ADDR_EXP 43
6794: PUSH
6795: LD_INT 0
6797: ST_TO_ADDR
// sDiff := false ;
6798: LD_ADDR_EXP 44
6802: PUSH
6803: LD_INT 0
6805: ST_TO_ADDR
// sFog := false ;
6806: LD_ADDR_EXP 47
6810: PUSH
6811: LD_INT 0
6813: ST_TO_ADDR
// sReset := false ;
6814: LD_ADDR_EXP 48
6818: PUSH
6819: LD_INT 0
6821: ST_TO_ADDR
// sSun := false ;
6822: LD_ADDR_EXP 49
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// sTiger := false ;
6830: LD_ADDR_EXP 45
6834: PUSH
6835: LD_INT 0
6837: ST_TO_ADDR
// sBomb := false ;
6838: LD_ADDR_EXP 46
6842: PUSH
6843: LD_INT 0
6845: ST_TO_ADDR
// sWound := false ;
6846: LD_ADDR_EXP 54
6850: PUSH
6851: LD_INT 0
6853: ST_TO_ADDR
// sBetray := false ;
6854: LD_ADDR_EXP 58
6858: PUSH
6859: LD_INT 0
6861: ST_TO_ADDR
// sContamin := false ;
6862: LD_ADDR_EXP 59
6866: PUSH
6867: LD_INT 0
6869: ST_TO_ADDR
// sOil := false ;
6870: LD_ADDR_EXP 61
6874: PUSH
6875: LD_INT 0
6877: ST_TO_ADDR
// sStu := false ;
6878: LD_ADDR_EXP 65
6882: PUSH
6883: LD_INT 0
6885: ST_TO_ADDR
// sBazooka := false ;
6886: LD_ADDR_EXP 68
6890: PUSH
6891: LD_INT 0
6893: ST_TO_ADDR
// sMortar := false ;
6894: LD_ADDR_EXP 69
6898: PUSH
6899: LD_INT 0
6901: ST_TO_ADDR
// sRanger := false ;
6902: LD_ADDR_EXP 79
6906: PUSH
6907: LD_INT 0
6909: ST_TO_ADDR
// end ;
6910: LD_VAR 0 1
6914: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
6915: LD_INT 0
6917: PPUSH
6918: PPUSH
6919: PPUSH
6920: PPUSH
6921: PPUSH
// result := [ ] ;
6922: LD_ADDR_VAR 0 1
6926: PUSH
6927: EMPTY
6928: ST_TO_ADDR
// if campaign_id = 1 then
6929: LD_OWVAR 69
6933: PUSH
6934: LD_INT 1
6936: EQUAL
6937: IFFALSE 9885
// begin case mission_number of 1 :
6939: LD_OWVAR 70
6943: PUSH
6944: LD_INT 1
6946: DOUBLE
6947: EQUAL
6948: IFTRUE 6952
6950: GO 7016
6952: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
6953: LD_ADDR_VAR 0 1
6957: PUSH
6958: LD_INT 2
6960: PUSH
6961: LD_INT 4
6963: PUSH
6964: LD_INT 11
6966: PUSH
6967: LD_INT 12
6969: PUSH
6970: LD_INT 15
6972: PUSH
6973: LD_INT 16
6975: PUSH
6976: LD_INT 22
6978: PUSH
6979: LD_INT 23
6981: PUSH
6982: LD_INT 26
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: LIST
6991: LIST
6992: LIST
6993: LIST
6994: LIST
6995: PUSH
6996: LD_INT 101
6998: PUSH
6999: LD_INT 102
7001: PUSH
7002: LD_INT 106
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: ST_TO_ADDR
7014: GO 9885
7016: LD_INT 2
7018: DOUBLE
7019: EQUAL
7020: IFTRUE 7024
7022: GO 7096
7024: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
7025: LD_ADDR_VAR 0 1
7029: PUSH
7030: LD_INT 2
7032: PUSH
7033: LD_INT 4
7035: PUSH
7036: LD_INT 11
7038: PUSH
7039: LD_INT 12
7041: PUSH
7042: LD_INT 15
7044: PUSH
7045: LD_INT 16
7047: PUSH
7048: LD_INT 22
7050: PUSH
7051: LD_INT 23
7053: PUSH
7054: LD_INT 26
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: LIST
7061: LIST
7062: LIST
7063: LIST
7064: LIST
7065: LIST
7066: LIST
7067: PUSH
7068: LD_INT 101
7070: PUSH
7071: LD_INT 102
7073: PUSH
7074: LD_INT 105
7076: PUSH
7077: LD_INT 106
7079: PUSH
7080: LD_INT 108
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: ST_TO_ADDR
7094: GO 9885
7096: LD_INT 3
7098: DOUBLE
7099: EQUAL
7100: IFTRUE 7104
7102: GO 7180
7104: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
7105: LD_ADDR_VAR 0 1
7109: PUSH
7110: LD_INT 2
7112: PUSH
7113: LD_INT 4
7115: PUSH
7116: LD_INT 5
7118: PUSH
7119: LD_INT 11
7121: PUSH
7122: LD_INT 12
7124: PUSH
7125: LD_INT 15
7127: PUSH
7128: LD_INT 16
7130: PUSH
7131: LD_INT 22
7133: PUSH
7134: LD_INT 26
7136: PUSH
7137: LD_INT 36
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: PUSH
7152: LD_INT 101
7154: PUSH
7155: LD_INT 102
7157: PUSH
7158: LD_INT 105
7160: PUSH
7161: LD_INT 106
7163: PUSH
7164: LD_INT 108
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: ST_TO_ADDR
7178: GO 9885
7180: LD_INT 4
7182: DOUBLE
7183: EQUAL
7184: IFTRUE 7188
7186: GO 7272
7188: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
7189: LD_ADDR_VAR 0 1
7193: PUSH
7194: LD_INT 2
7196: PUSH
7197: LD_INT 4
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: LD_INT 8
7205: PUSH
7206: LD_INT 11
7208: PUSH
7209: LD_INT 12
7211: PUSH
7212: LD_INT 15
7214: PUSH
7215: LD_INT 16
7217: PUSH
7218: LD_INT 22
7220: PUSH
7221: LD_INT 23
7223: PUSH
7224: LD_INT 26
7226: PUSH
7227: LD_INT 36
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 101
7246: PUSH
7247: LD_INT 102
7249: PUSH
7250: LD_INT 105
7252: PUSH
7253: LD_INT 106
7255: PUSH
7256: LD_INT 108
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: LIST
7263: LIST
7264: LIST
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: ST_TO_ADDR
7270: GO 9885
7272: LD_INT 5
7274: DOUBLE
7275: EQUAL
7276: IFTRUE 7280
7278: GO 7380
7280: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
7281: LD_ADDR_VAR 0 1
7285: PUSH
7286: LD_INT 2
7288: PUSH
7289: LD_INT 4
7291: PUSH
7292: LD_INT 5
7294: PUSH
7295: LD_INT 6
7297: PUSH
7298: LD_INT 8
7300: PUSH
7301: LD_INT 11
7303: PUSH
7304: LD_INT 12
7306: PUSH
7307: LD_INT 15
7309: PUSH
7310: LD_INT 16
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_INT 23
7318: PUSH
7319: LD_INT 25
7321: PUSH
7322: LD_INT 26
7324: PUSH
7325: LD_INT 36
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: LIST
7334: LIST
7335: LIST
7336: LIST
7337: LIST
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 101
7346: PUSH
7347: LD_INT 102
7349: PUSH
7350: LD_INT 105
7352: PUSH
7353: LD_INT 106
7355: PUSH
7356: LD_INT 108
7358: PUSH
7359: LD_INT 109
7361: PUSH
7362: LD_INT 112
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: LIST
7369: LIST
7370: LIST
7371: LIST
7372: LIST
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: ST_TO_ADDR
7378: GO 9885
7380: LD_INT 6
7382: DOUBLE
7383: EQUAL
7384: IFTRUE 7388
7386: GO 7508
7388: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
7389: LD_ADDR_VAR 0 1
7393: PUSH
7394: LD_INT 2
7396: PUSH
7397: LD_INT 4
7399: PUSH
7400: LD_INT 5
7402: PUSH
7403: LD_INT 6
7405: PUSH
7406: LD_INT 8
7408: PUSH
7409: LD_INT 11
7411: PUSH
7412: LD_INT 12
7414: PUSH
7415: LD_INT 15
7417: PUSH
7418: LD_INT 16
7420: PUSH
7421: LD_INT 20
7423: PUSH
7424: LD_INT 21
7426: PUSH
7427: LD_INT 22
7429: PUSH
7430: LD_INT 23
7432: PUSH
7433: LD_INT 25
7435: PUSH
7436: LD_INT 26
7438: PUSH
7439: LD_INT 30
7441: PUSH
7442: LD_INT 31
7444: PUSH
7445: LD_INT 32
7447: PUSH
7448: LD_INT 36
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 101
7474: PUSH
7475: LD_INT 102
7477: PUSH
7478: LD_INT 105
7480: PUSH
7481: LD_INT 106
7483: PUSH
7484: LD_INT 108
7486: PUSH
7487: LD_INT 109
7489: PUSH
7490: LD_INT 112
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: ST_TO_ADDR
7506: GO 9885
7508: LD_INT 7
7510: DOUBLE
7511: EQUAL
7512: IFTRUE 7516
7514: GO 7616
7516: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
7517: LD_ADDR_VAR 0 1
7521: PUSH
7522: LD_INT 2
7524: PUSH
7525: LD_INT 4
7527: PUSH
7528: LD_INT 5
7530: PUSH
7531: LD_INT 7
7533: PUSH
7534: LD_INT 11
7536: PUSH
7537: LD_INT 12
7539: PUSH
7540: LD_INT 15
7542: PUSH
7543: LD_INT 16
7545: PUSH
7546: LD_INT 20
7548: PUSH
7549: LD_INT 21
7551: PUSH
7552: LD_INT 22
7554: PUSH
7555: LD_INT 23
7557: PUSH
7558: LD_INT 25
7560: PUSH
7561: LD_INT 26
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: LIST
7578: LIST
7579: PUSH
7580: LD_INT 101
7582: PUSH
7583: LD_INT 102
7585: PUSH
7586: LD_INT 103
7588: PUSH
7589: LD_INT 105
7591: PUSH
7592: LD_INT 106
7594: PUSH
7595: LD_INT 108
7597: PUSH
7598: LD_INT 112
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: LIST
7607: LIST
7608: LIST
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: ST_TO_ADDR
7614: GO 9885
7616: LD_INT 8
7618: DOUBLE
7619: EQUAL
7620: IFTRUE 7624
7622: GO 7752
7624: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
7625: LD_ADDR_VAR 0 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 4
7635: PUSH
7636: LD_INT 5
7638: PUSH
7639: LD_INT 6
7641: PUSH
7642: LD_INT 7
7644: PUSH
7645: LD_INT 8
7647: PUSH
7648: LD_INT 11
7650: PUSH
7651: LD_INT 12
7653: PUSH
7654: LD_INT 15
7656: PUSH
7657: LD_INT 16
7659: PUSH
7660: LD_INT 20
7662: PUSH
7663: LD_INT 21
7665: PUSH
7666: LD_INT 22
7668: PUSH
7669: LD_INT 23
7671: PUSH
7672: LD_INT 25
7674: PUSH
7675: LD_INT 26
7677: PUSH
7678: LD_INT 30
7680: PUSH
7681: LD_INT 31
7683: PUSH
7684: LD_INT 32
7686: PUSH
7687: LD_INT 36
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: LIST
7695: LIST
7696: LIST
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: PUSH
7712: LD_INT 101
7714: PUSH
7715: LD_INT 102
7717: PUSH
7718: LD_INT 103
7720: PUSH
7721: LD_INT 105
7723: PUSH
7724: LD_INT 106
7726: PUSH
7727: LD_INT 108
7729: PUSH
7730: LD_INT 109
7732: PUSH
7733: LD_INT 112
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: LIST
7743: LIST
7744: LIST
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: ST_TO_ADDR
7750: GO 9885
7752: LD_INT 9
7754: DOUBLE
7755: EQUAL
7756: IFTRUE 7760
7758: GO 7896
7760: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
7761: LD_ADDR_VAR 0 1
7765: PUSH
7766: LD_INT 2
7768: PUSH
7769: LD_INT 4
7771: PUSH
7772: LD_INT 5
7774: PUSH
7775: LD_INT 6
7777: PUSH
7778: LD_INT 7
7780: PUSH
7781: LD_INT 8
7783: PUSH
7784: LD_INT 11
7786: PUSH
7787: LD_INT 12
7789: PUSH
7790: LD_INT 15
7792: PUSH
7793: LD_INT 16
7795: PUSH
7796: LD_INT 20
7798: PUSH
7799: LD_INT 21
7801: PUSH
7802: LD_INT 22
7804: PUSH
7805: LD_INT 23
7807: PUSH
7808: LD_INT 25
7810: PUSH
7811: LD_INT 26
7813: PUSH
7814: LD_INT 28
7816: PUSH
7817: LD_INT 30
7819: PUSH
7820: LD_INT 31
7822: PUSH
7823: LD_INT 32
7825: PUSH
7826: LD_INT 36
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: LIST
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: PUSH
7852: LD_INT 101
7854: PUSH
7855: LD_INT 102
7857: PUSH
7858: LD_INT 103
7860: PUSH
7861: LD_INT 105
7863: PUSH
7864: LD_INT 106
7866: PUSH
7867: LD_INT 108
7869: PUSH
7870: LD_INT 109
7872: PUSH
7873: LD_INT 112
7875: PUSH
7876: LD_INT 114
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: PUSH
7890: EMPTY
7891: LIST
7892: LIST
7893: ST_TO_ADDR
7894: GO 9885
7896: LD_INT 10
7898: DOUBLE
7899: EQUAL
7900: IFTRUE 7904
7902: GO 8088
7904: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
7905: LD_ADDR_VAR 0 1
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: LD_INT 4
7915: PUSH
7916: LD_INT 5
7918: PUSH
7919: LD_INT 6
7921: PUSH
7922: LD_INT 7
7924: PUSH
7925: LD_INT 8
7927: PUSH
7928: LD_INT 9
7930: PUSH
7931: LD_INT 10
7933: PUSH
7934: LD_INT 11
7936: PUSH
7937: LD_INT 12
7939: PUSH
7940: LD_INT 13
7942: PUSH
7943: LD_INT 14
7945: PUSH
7946: LD_INT 15
7948: PUSH
7949: LD_INT 16
7951: PUSH
7952: LD_INT 17
7954: PUSH
7955: LD_INT 18
7957: PUSH
7958: LD_INT 19
7960: PUSH
7961: LD_INT 20
7963: PUSH
7964: LD_INT 21
7966: PUSH
7967: LD_INT 22
7969: PUSH
7970: LD_INT 23
7972: PUSH
7973: LD_INT 24
7975: PUSH
7976: LD_INT 25
7978: PUSH
7979: LD_INT 26
7981: PUSH
7982: LD_INT 28
7984: PUSH
7985: LD_INT 30
7987: PUSH
7988: LD_INT 31
7990: PUSH
7991: LD_INT 32
7993: PUSH
7994: LD_INT 36
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: LIST
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: LIST
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: LIST
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: LIST
8027: PUSH
8028: LD_INT 101
8030: PUSH
8031: LD_INT 102
8033: PUSH
8034: LD_INT 103
8036: PUSH
8037: LD_INT 104
8039: PUSH
8040: LD_INT 105
8042: PUSH
8043: LD_INT 106
8045: PUSH
8046: LD_INT 107
8048: PUSH
8049: LD_INT 108
8051: PUSH
8052: LD_INT 109
8054: PUSH
8055: LD_INT 110
8057: PUSH
8058: LD_INT 111
8060: PUSH
8061: LD_INT 112
8063: PUSH
8064: LD_INT 114
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: LIST
8074: LIST
8075: LIST
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 9885
8088: LD_INT 11
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8288
8096: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
8097: LD_ADDR_VAR 0 1
8101: PUSH
8102: LD_INT 2
8104: PUSH
8105: LD_INT 3
8107: PUSH
8108: LD_INT 4
8110: PUSH
8111: LD_INT 5
8113: PUSH
8114: LD_INT 6
8116: PUSH
8117: LD_INT 7
8119: PUSH
8120: LD_INT 8
8122: PUSH
8123: LD_INT 9
8125: PUSH
8126: LD_INT 10
8128: PUSH
8129: LD_INT 11
8131: PUSH
8132: LD_INT 12
8134: PUSH
8135: LD_INT 13
8137: PUSH
8138: LD_INT 14
8140: PUSH
8141: LD_INT 15
8143: PUSH
8144: LD_INT 16
8146: PUSH
8147: LD_INT 17
8149: PUSH
8150: LD_INT 18
8152: PUSH
8153: LD_INT 19
8155: PUSH
8156: LD_INT 20
8158: PUSH
8159: LD_INT 21
8161: PUSH
8162: LD_INT 22
8164: PUSH
8165: LD_INT 23
8167: PUSH
8168: LD_INT 24
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 26
8176: PUSH
8177: LD_INT 28
8179: PUSH
8180: LD_INT 30
8182: PUSH
8183: LD_INT 31
8185: PUSH
8186: LD_INT 32
8188: PUSH
8189: LD_INT 34
8191: PUSH
8192: LD_INT 36
8194: PUSH
8195: EMPTY
8196: LIST
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: PUSH
8228: LD_INT 101
8230: PUSH
8231: LD_INT 102
8233: PUSH
8234: LD_INT 103
8236: PUSH
8237: LD_INT 104
8239: PUSH
8240: LD_INT 105
8242: PUSH
8243: LD_INT 106
8245: PUSH
8246: LD_INT 107
8248: PUSH
8249: LD_INT 108
8251: PUSH
8252: LD_INT 109
8254: PUSH
8255: LD_INT 110
8257: PUSH
8258: LD_INT 111
8260: PUSH
8261: LD_INT 112
8263: PUSH
8264: LD_INT 114
8266: PUSH
8267: EMPTY
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: LIST
8281: PUSH
8282: EMPTY
8283: LIST
8284: LIST
8285: ST_TO_ADDR
8286: GO 9885
8288: LD_INT 12
8290: DOUBLE
8291: EQUAL
8292: IFTRUE 8296
8294: GO 8504
8296: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
8297: LD_ADDR_VAR 0 1
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: LD_INT 2
8307: PUSH
8308: LD_INT 3
8310: PUSH
8311: LD_INT 4
8313: PUSH
8314: LD_INT 5
8316: PUSH
8317: LD_INT 6
8319: PUSH
8320: LD_INT 7
8322: PUSH
8323: LD_INT 8
8325: PUSH
8326: LD_INT 9
8328: PUSH
8329: LD_INT 10
8331: PUSH
8332: LD_INT 11
8334: PUSH
8335: LD_INT 12
8337: PUSH
8338: LD_INT 13
8340: PUSH
8341: LD_INT 14
8343: PUSH
8344: LD_INT 15
8346: PUSH
8347: LD_INT 16
8349: PUSH
8350: LD_INT 17
8352: PUSH
8353: LD_INT 18
8355: PUSH
8356: LD_INT 19
8358: PUSH
8359: LD_INT 20
8361: PUSH
8362: LD_INT 21
8364: PUSH
8365: LD_INT 22
8367: PUSH
8368: LD_INT 23
8370: PUSH
8371: LD_INT 24
8373: PUSH
8374: LD_INT 25
8376: PUSH
8377: LD_INT 26
8379: PUSH
8380: LD_INT 27
8382: PUSH
8383: LD_INT 28
8385: PUSH
8386: LD_INT 30
8388: PUSH
8389: LD_INT 31
8391: PUSH
8392: LD_INT 32
8394: PUSH
8395: LD_INT 33
8397: PUSH
8398: LD_INT 34
8400: PUSH
8401: LD_INT 36
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: LIST
8408: LIST
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: LIST
8416: LIST
8417: LIST
8418: LIST
8419: LIST
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: LIST
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: LIST
8435: LIST
8436: LIST
8437: LIST
8438: LIST
8439: PUSH
8440: LD_INT 101
8442: PUSH
8443: LD_INT 102
8445: PUSH
8446: LD_INT 103
8448: PUSH
8449: LD_INT 104
8451: PUSH
8452: LD_INT 105
8454: PUSH
8455: LD_INT 106
8457: PUSH
8458: LD_INT 107
8460: PUSH
8461: LD_INT 108
8463: PUSH
8464: LD_INT 109
8466: PUSH
8467: LD_INT 110
8469: PUSH
8470: LD_INT 111
8472: PUSH
8473: LD_INT 112
8475: PUSH
8476: LD_INT 113
8478: PUSH
8479: LD_INT 114
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: LIST
8491: LIST
8492: LIST
8493: LIST
8494: LIST
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: ST_TO_ADDR
8502: GO 9885
8504: LD_INT 13
8506: DOUBLE
8507: EQUAL
8508: IFTRUE 8512
8510: GO 8720
8512: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
8513: LD_ADDR_VAR 0 1
8517: PUSH
8518: LD_INT 1
8520: PUSH
8521: LD_INT 2
8523: PUSH
8524: LD_INT 3
8526: PUSH
8527: LD_INT 4
8529: PUSH
8530: LD_INT 5
8532: PUSH
8533: LD_INT 6
8535: PUSH
8536: LD_INT 7
8538: PUSH
8539: LD_INT 8
8541: PUSH
8542: LD_INT 9
8544: PUSH
8545: LD_INT 10
8547: PUSH
8548: LD_INT 11
8550: PUSH
8551: LD_INT 12
8553: PUSH
8554: LD_INT 13
8556: PUSH
8557: LD_INT 14
8559: PUSH
8560: LD_INT 15
8562: PUSH
8563: LD_INT 16
8565: PUSH
8566: LD_INT 17
8568: PUSH
8569: LD_INT 18
8571: PUSH
8572: LD_INT 19
8574: PUSH
8575: LD_INT 20
8577: PUSH
8578: LD_INT 21
8580: PUSH
8581: LD_INT 22
8583: PUSH
8584: LD_INT 23
8586: PUSH
8587: LD_INT 24
8589: PUSH
8590: LD_INT 25
8592: PUSH
8593: LD_INT 26
8595: PUSH
8596: LD_INT 27
8598: PUSH
8599: LD_INT 28
8601: PUSH
8602: LD_INT 30
8604: PUSH
8605: LD_INT 31
8607: PUSH
8608: LD_INT 32
8610: PUSH
8611: LD_INT 33
8613: PUSH
8614: LD_INT 34
8616: PUSH
8617: LD_INT 36
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: LIST
8630: LIST
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: PUSH
8656: LD_INT 101
8658: PUSH
8659: LD_INT 102
8661: PUSH
8662: LD_INT 103
8664: PUSH
8665: LD_INT 104
8667: PUSH
8668: LD_INT 105
8670: PUSH
8671: LD_INT 106
8673: PUSH
8674: LD_INT 107
8676: PUSH
8677: LD_INT 108
8679: PUSH
8680: LD_INT 109
8682: PUSH
8683: LD_INT 110
8685: PUSH
8686: LD_INT 111
8688: PUSH
8689: LD_INT 112
8691: PUSH
8692: LD_INT 113
8694: PUSH
8695: LD_INT 114
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: LIST
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: ST_TO_ADDR
8718: GO 9885
8720: LD_INT 14
8722: DOUBLE
8723: EQUAL
8724: IFTRUE 8728
8726: GO 8940
8728: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
8729: LD_ADDR_VAR 0 1
8733: PUSH
8734: LD_INT 1
8736: PUSH
8737: LD_INT 2
8739: PUSH
8740: LD_INT 3
8742: PUSH
8743: LD_INT 4
8745: PUSH
8746: LD_INT 5
8748: PUSH
8749: LD_INT 6
8751: PUSH
8752: LD_INT 7
8754: PUSH
8755: LD_INT 8
8757: PUSH
8758: LD_INT 9
8760: PUSH
8761: LD_INT 10
8763: PUSH
8764: LD_INT 11
8766: PUSH
8767: LD_INT 12
8769: PUSH
8770: LD_INT 13
8772: PUSH
8773: LD_INT 14
8775: PUSH
8776: LD_INT 15
8778: PUSH
8779: LD_INT 16
8781: PUSH
8782: LD_INT 17
8784: PUSH
8785: LD_INT 18
8787: PUSH
8788: LD_INT 19
8790: PUSH
8791: LD_INT 20
8793: PUSH
8794: LD_INT 21
8796: PUSH
8797: LD_INT 22
8799: PUSH
8800: LD_INT 23
8802: PUSH
8803: LD_INT 24
8805: PUSH
8806: LD_INT 25
8808: PUSH
8809: LD_INT 26
8811: PUSH
8812: LD_INT 27
8814: PUSH
8815: LD_INT 28
8817: PUSH
8818: LD_INT 29
8820: PUSH
8821: LD_INT 30
8823: PUSH
8824: LD_INT 31
8826: PUSH
8827: LD_INT 32
8829: PUSH
8830: LD_INT 33
8832: PUSH
8833: LD_INT 34
8835: PUSH
8836: LD_INT 36
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: LIST
8845: LIST
8846: LIST
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: LIST
8860: LIST
8861: LIST
8862: LIST
8863: LIST
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: LIST
8875: PUSH
8876: LD_INT 101
8878: PUSH
8879: LD_INT 102
8881: PUSH
8882: LD_INT 103
8884: PUSH
8885: LD_INT 104
8887: PUSH
8888: LD_INT 105
8890: PUSH
8891: LD_INT 106
8893: PUSH
8894: LD_INT 107
8896: PUSH
8897: LD_INT 108
8899: PUSH
8900: LD_INT 109
8902: PUSH
8903: LD_INT 110
8905: PUSH
8906: LD_INT 111
8908: PUSH
8909: LD_INT 112
8911: PUSH
8912: LD_INT 113
8914: PUSH
8915: LD_INT 114
8917: PUSH
8918: EMPTY
8919: LIST
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: PUSH
8934: EMPTY
8935: LIST
8936: LIST
8937: ST_TO_ADDR
8938: GO 9885
8940: LD_INT 15
8942: DOUBLE
8943: EQUAL
8944: IFTRUE 8948
8946: GO 9160
8948: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_INT 1
8956: PUSH
8957: LD_INT 2
8959: PUSH
8960: LD_INT 3
8962: PUSH
8963: LD_INT 4
8965: PUSH
8966: LD_INT 5
8968: PUSH
8969: LD_INT 6
8971: PUSH
8972: LD_INT 7
8974: PUSH
8975: LD_INT 8
8977: PUSH
8978: LD_INT 9
8980: PUSH
8981: LD_INT 10
8983: PUSH
8984: LD_INT 11
8986: PUSH
8987: LD_INT 12
8989: PUSH
8990: LD_INT 13
8992: PUSH
8993: LD_INT 14
8995: PUSH
8996: LD_INT 15
8998: PUSH
8999: LD_INT 16
9001: PUSH
9002: LD_INT 17
9004: PUSH
9005: LD_INT 18
9007: PUSH
9008: LD_INT 19
9010: PUSH
9011: LD_INT 20
9013: PUSH
9014: LD_INT 21
9016: PUSH
9017: LD_INT 22
9019: PUSH
9020: LD_INT 23
9022: PUSH
9023: LD_INT 24
9025: PUSH
9026: LD_INT 25
9028: PUSH
9029: LD_INT 26
9031: PUSH
9032: LD_INT 27
9034: PUSH
9035: LD_INT 28
9037: PUSH
9038: LD_INT 29
9040: PUSH
9041: LD_INT 30
9043: PUSH
9044: LD_INT 31
9046: PUSH
9047: LD_INT 32
9049: PUSH
9050: LD_INT 33
9052: PUSH
9053: LD_INT 34
9055: PUSH
9056: LD_INT 36
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: LIST
9063: LIST
9064: LIST
9065: LIST
9066: LIST
9067: LIST
9068: LIST
9069: LIST
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: LIST
9079: LIST
9080: LIST
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: LIST
9086: LIST
9087: LIST
9088: LIST
9089: LIST
9090: LIST
9091: LIST
9092: LIST
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 101
9098: PUSH
9099: LD_INT 102
9101: PUSH
9102: LD_INT 103
9104: PUSH
9105: LD_INT 104
9107: PUSH
9108: LD_INT 105
9110: PUSH
9111: LD_INT 106
9113: PUSH
9114: LD_INT 107
9116: PUSH
9117: LD_INT 108
9119: PUSH
9120: LD_INT 109
9122: PUSH
9123: LD_INT 110
9125: PUSH
9126: LD_INT 111
9128: PUSH
9129: LD_INT 112
9131: PUSH
9132: LD_INT 113
9134: PUSH
9135: LD_INT 114
9137: PUSH
9138: EMPTY
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
9158: GO 9885
9160: LD_INT 16
9162: DOUBLE
9163: EQUAL
9164: IFTRUE 9168
9166: GO 9292
9168: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
9169: LD_ADDR_VAR 0 1
9173: PUSH
9174: LD_INT 2
9176: PUSH
9177: LD_INT 4
9179: PUSH
9180: LD_INT 5
9182: PUSH
9183: LD_INT 7
9185: PUSH
9186: LD_INT 11
9188: PUSH
9189: LD_INT 12
9191: PUSH
9192: LD_INT 15
9194: PUSH
9195: LD_INT 16
9197: PUSH
9198: LD_INT 20
9200: PUSH
9201: LD_INT 21
9203: PUSH
9204: LD_INT 22
9206: PUSH
9207: LD_INT 23
9209: PUSH
9210: LD_INT 25
9212: PUSH
9213: LD_INT 26
9215: PUSH
9216: LD_INT 30
9218: PUSH
9219: LD_INT 31
9221: PUSH
9222: LD_INT 32
9224: PUSH
9225: LD_INT 33
9227: PUSH
9228: LD_INT 34
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: PUSH
9252: LD_INT 101
9254: PUSH
9255: LD_INT 102
9257: PUSH
9258: LD_INT 103
9260: PUSH
9261: LD_INT 106
9263: PUSH
9264: LD_INT 108
9266: PUSH
9267: LD_INT 112
9269: PUSH
9270: LD_INT 113
9272: PUSH
9273: LD_INT 114
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: LIST
9280: LIST
9281: LIST
9282: LIST
9283: LIST
9284: LIST
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: ST_TO_ADDR
9290: GO 9885
9292: LD_INT 17
9294: DOUBLE
9295: EQUAL
9296: IFTRUE 9300
9298: GO 9512
9300: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
9301: LD_ADDR_VAR 0 1
9305: PUSH
9306: LD_INT 1
9308: PUSH
9309: LD_INT 2
9311: PUSH
9312: LD_INT 3
9314: PUSH
9315: LD_INT 4
9317: PUSH
9318: LD_INT 5
9320: PUSH
9321: LD_INT 6
9323: PUSH
9324: LD_INT 7
9326: PUSH
9327: LD_INT 8
9329: PUSH
9330: LD_INT 9
9332: PUSH
9333: LD_INT 10
9335: PUSH
9336: LD_INT 11
9338: PUSH
9339: LD_INT 12
9341: PUSH
9342: LD_INT 13
9344: PUSH
9345: LD_INT 14
9347: PUSH
9348: LD_INT 15
9350: PUSH
9351: LD_INT 16
9353: PUSH
9354: LD_INT 17
9356: PUSH
9357: LD_INT 18
9359: PUSH
9360: LD_INT 19
9362: PUSH
9363: LD_INT 20
9365: PUSH
9366: LD_INT 21
9368: PUSH
9369: LD_INT 22
9371: PUSH
9372: LD_INT 23
9374: PUSH
9375: LD_INT 24
9377: PUSH
9378: LD_INT 25
9380: PUSH
9381: LD_INT 26
9383: PUSH
9384: LD_INT 27
9386: PUSH
9387: LD_INT 28
9389: PUSH
9390: LD_INT 29
9392: PUSH
9393: LD_INT 30
9395: PUSH
9396: LD_INT 31
9398: PUSH
9399: LD_INT 32
9401: PUSH
9402: LD_INT 33
9404: PUSH
9405: LD_INT 34
9407: PUSH
9408: LD_INT 36
9410: PUSH
9411: EMPTY
9412: LIST
9413: LIST
9414: LIST
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: LIST
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: LIST
9429: LIST
9430: LIST
9431: LIST
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: PUSH
9448: LD_INT 101
9450: PUSH
9451: LD_INT 102
9453: PUSH
9454: LD_INT 103
9456: PUSH
9457: LD_INT 104
9459: PUSH
9460: LD_INT 105
9462: PUSH
9463: LD_INT 106
9465: PUSH
9466: LD_INT 107
9468: PUSH
9469: LD_INT 108
9471: PUSH
9472: LD_INT 109
9474: PUSH
9475: LD_INT 110
9477: PUSH
9478: LD_INT 111
9480: PUSH
9481: LD_INT 112
9483: PUSH
9484: LD_INT 113
9486: PUSH
9487: LD_INT 114
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: LIST
9494: LIST
9495: LIST
9496: LIST
9497: LIST
9498: LIST
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: ST_TO_ADDR
9510: GO 9885
9512: LD_INT 18
9514: DOUBLE
9515: EQUAL
9516: IFTRUE 9520
9518: GO 9656
9520: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
9521: LD_ADDR_VAR 0 1
9525: PUSH
9526: LD_INT 2
9528: PUSH
9529: LD_INT 4
9531: PUSH
9532: LD_INT 5
9534: PUSH
9535: LD_INT 7
9537: PUSH
9538: LD_INT 11
9540: PUSH
9541: LD_INT 12
9543: PUSH
9544: LD_INT 15
9546: PUSH
9547: LD_INT 16
9549: PUSH
9550: LD_INT 20
9552: PUSH
9553: LD_INT 21
9555: PUSH
9556: LD_INT 22
9558: PUSH
9559: LD_INT 23
9561: PUSH
9562: LD_INT 25
9564: PUSH
9565: LD_INT 26
9567: PUSH
9568: LD_INT 30
9570: PUSH
9571: LD_INT 31
9573: PUSH
9574: LD_INT 32
9576: PUSH
9577: LD_INT 33
9579: PUSH
9580: LD_INT 34
9582: PUSH
9583: LD_INT 35
9585: PUSH
9586: LD_INT 36
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: LIST
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: LIST
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: PUSH
9612: LD_INT 101
9614: PUSH
9615: LD_INT 102
9617: PUSH
9618: LD_INT 103
9620: PUSH
9621: LD_INT 106
9623: PUSH
9624: LD_INT 108
9626: PUSH
9627: LD_INT 112
9629: PUSH
9630: LD_INT 113
9632: PUSH
9633: LD_INT 114
9635: PUSH
9636: LD_INT 115
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: ST_TO_ADDR
9654: GO 9885
9656: LD_INT 19
9658: DOUBLE
9659: EQUAL
9660: IFTRUE 9664
9662: GO 9884
9664: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
9665: LD_ADDR_VAR 0 1
9669: PUSH
9670: LD_INT 1
9672: PUSH
9673: LD_INT 2
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: LD_INT 4
9681: PUSH
9682: LD_INT 5
9684: PUSH
9685: LD_INT 6
9687: PUSH
9688: LD_INT 7
9690: PUSH
9691: LD_INT 8
9693: PUSH
9694: LD_INT 9
9696: PUSH
9697: LD_INT 10
9699: PUSH
9700: LD_INT 11
9702: PUSH
9703: LD_INT 12
9705: PUSH
9706: LD_INT 13
9708: PUSH
9709: LD_INT 14
9711: PUSH
9712: LD_INT 15
9714: PUSH
9715: LD_INT 16
9717: PUSH
9718: LD_INT 17
9720: PUSH
9721: LD_INT 18
9723: PUSH
9724: LD_INT 19
9726: PUSH
9727: LD_INT 20
9729: PUSH
9730: LD_INT 21
9732: PUSH
9733: LD_INT 22
9735: PUSH
9736: LD_INT 23
9738: PUSH
9739: LD_INT 24
9741: PUSH
9742: LD_INT 25
9744: PUSH
9745: LD_INT 26
9747: PUSH
9748: LD_INT 27
9750: PUSH
9751: LD_INT 28
9753: PUSH
9754: LD_INT 29
9756: PUSH
9757: LD_INT 30
9759: PUSH
9760: LD_INT 31
9762: PUSH
9763: LD_INT 32
9765: PUSH
9766: LD_INT 33
9768: PUSH
9769: LD_INT 34
9771: PUSH
9772: LD_INT 35
9774: PUSH
9775: LD_INT 36
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: LIST
9783: LIST
9784: LIST
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: LIST
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 101
9818: PUSH
9819: LD_INT 102
9821: PUSH
9822: LD_INT 103
9824: PUSH
9825: LD_INT 104
9827: PUSH
9828: LD_INT 105
9830: PUSH
9831: LD_INT 106
9833: PUSH
9834: LD_INT 107
9836: PUSH
9837: LD_INT 108
9839: PUSH
9840: LD_INT 109
9842: PUSH
9843: LD_INT 110
9845: PUSH
9846: LD_INT 111
9848: PUSH
9849: LD_INT 112
9851: PUSH
9852: LD_INT 113
9854: PUSH
9855: LD_INT 114
9857: PUSH
9858: LD_INT 115
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: ST_TO_ADDR
9882: GO 9885
9884: POP
// end ; if result then
9885: LD_VAR 0 1
9889: IFFALSE 10178
// begin normal :=  ;
9891: LD_ADDR_VAR 0 3
9895: PUSH
9896: LD_STRING 
9898: ST_TO_ADDR
// hardcore :=  ;
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: LD_STRING 
9906: ST_TO_ADDR
// for i = 1 to normalCounter do
9907: LD_ADDR_VAR 0 5
9911: PUSH
9912: DOUBLE
9913: LD_INT 1
9915: DEC
9916: ST_TO_ADDR
9917: LD_EXP 27
9921: PUSH
9922: FOR_TO
9923: IFFALSE 10024
// begin tmp := 0 ;
9925: LD_ADDR_VAR 0 2
9929: PUSH
9930: LD_STRING 0
9932: ST_TO_ADDR
// if result [ 1 ] then
9933: LD_VAR 0 1
9937: PUSH
9938: LD_INT 1
9940: ARRAY
9941: IFFALSE 10006
// if result [ 1 ] [ 1 ] = i then
9943: LD_VAR 0 1
9947: PUSH
9948: LD_INT 1
9950: ARRAY
9951: PUSH
9952: LD_INT 1
9954: ARRAY
9955: PUSH
9956: LD_VAR 0 5
9960: EQUAL
9961: IFFALSE 10006
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
9963: LD_ADDR_VAR 0 1
9967: PUSH
9968: LD_VAR 0 1
9972: PPUSH
9973: LD_INT 1
9975: PPUSH
9976: LD_VAR 0 1
9980: PUSH
9981: LD_INT 1
9983: ARRAY
9984: PPUSH
9985: LD_INT 1
9987: PPUSH
9988: CALL_OW 3
9992: PPUSH
9993: CALL_OW 1
9997: ST_TO_ADDR
// tmp := 1 ;
9998: LD_ADDR_VAR 0 2
10002: PUSH
10003: LD_STRING 1
10005: ST_TO_ADDR
// end ; normal := normal & tmp ;
10006: LD_ADDR_VAR 0 3
10010: PUSH
10011: LD_VAR 0 3
10015: PUSH
10016: LD_VAR 0 2
10020: STR
10021: ST_TO_ADDR
// end ;
10022: GO 9922
10024: POP
10025: POP
// for i = 1 to hardcoreCounter do
10026: LD_ADDR_VAR 0 5
10030: PUSH
10031: DOUBLE
10032: LD_INT 1
10034: DEC
10035: ST_TO_ADDR
10036: LD_EXP 28
10040: PUSH
10041: FOR_TO
10042: IFFALSE 10147
// begin tmp := 0 ;
10044: LD_ADDR_VAR 0 2
10048: PUSH
10049: LD_STRING 0
10051: ST_TO_ADDR
// if result [ 2 ] then
10052: LD_VAR 0 1
10056: PUSH
10057: LD_INT 2
10059: ARRAY
10060: IFFALSE 10129
// if result [ 2 ] [ 1 ] = 100 + i then
10062: LD_VAR 0 1
10066: PUSH
10067: LD_INT 2
10069: ARRAY
10070: PUSH
10071: LD_INT 1
10073: ARRAY
10074: PUSH
10075: LD_INT 100
10077: PUSH
10078: LD_VAR 0 5
10082: PLUS
10083: EQUAL
10084: IFFALSE 10129
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
10086: LD_ADDR_VAR 0 1
10090: PUSH
10091: LD_VAR 0 1
10095: PPUSH
10096: LD_INT 2
10098: PPUSH
10099: LD_VAR 0 1
10103: PUSH
10104: LD_INT 2
10106: ARRAY
10107: PPUSH
10108: LD_INT 1
10110: PPUSH
10111: CALL_OW 3
10115: PPUSH
10116: CALL_OW 1
10120: ST_TO_ADDR
// tmp := 1 ;
10121: LD_ADDR_VAR 0 2
10125: PUSH
10126: LD_STRING 1
10128: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
10129: LD_ADDR_VAR 0 4
10133: PUSH
10134: LD_VAR 0 4
10138: PUSH
10139: LD_VAR 0 2
10143: STR
10144: ST_TO_ADDR
// end ;
10145: GO 10041
10147: POP
10148: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
10149: LD_STRING getStreamItemsFromMission("
10151: PUSH
10152: LD_VAR 0 3
10156: STR
10157: PUSH
10158: LD_STRING ","
10160: STR
10161: PUSH
10162: LD_VAR 0 4
10166: STR
10167: PUSH
10168: LD_STRING ")
10170: STR
10171: PPUSH
10172: CALL_OW 559
// end else
10176: GO 10185
// ToLua ( getStreamItemsFromMission("","") ) ;
10178: LD_STRING getStreamItemsFromMission("","")
10180: PPUSH
10181: CALL_OW 559
// end ;
10185: LD_VAR 0 1
10189: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
10190: LD_VAR 0 2
10194: PUSH
10195: LD_INT 100
10197: EQUAL
10198: IFFALSE 11147
// begin if not StreamModeActive then
10200: LD_EXP 26
10204: NOT
10205: IFFALSE 10215
// StreamModeActive := true ;
10207: LD_ADDR_EXP 26
10211: PUSH
10212: LD_INT 1
10214: ST_TO_ADDR
// if p3 = 0 then
10215: LD_VAR 0 3
10219: PUSH
10220: LD_INT 0
10222: EQUAL
10223: IFFALSE 10229
// InitStreamMode ;
10225: CALL 6475 0 0
// if p3 = 1 then
10229: LD_VAR 0 3
10233: PUSH
10234: LD_INT 1
10236: EQUAL
10237: IFFALSE 10247
// sRocket := true ;
10239: LD_ADDR_EXP 31
10243: PUSH
10244: LD_INT 1
10246: ST_TO_ADDR
// if p3 = 2 then
10247: LD_VAR 0 3
10251: PUSH
10252: LD_INT 2
10254: EQUAL
10255: IFFALSE 10265
// sSpeed := true ;
10257: LD_ADDR_EXP 30
10261: PUSH
10262: LD_INT 1
10264: ST_TO_ADDR
// if p3 = 3 then
10265: LD_VAR 0 3
10269: PUSH
10270: LD_INT 3
10272: EQUAL
10273: IFFALSE 10283
// sEngine := true ;
10275: LD_ADDR_EXP 32
10279: PUSH
10280: LD_INT 1
10282: ST_TO_ADDR
// if p3 = 4 then
10283: LD_VAR 0 3
10287: PUSH
10288: LD_INT 4
10290: EQUAL
10291: IFFALSE 10301
// sSpec := true ;
10293: LD_ADDR_EXP 29
10297: PUSH
10298: LD_INT 1
10300: ST_TO_ADDR
// if p3 = 5 then
10301: LD_VAR 0 3
10305: PUSH
10306: LD_INT 5
10308: EQUAL
10309: IFFALSE 10319
// sLevel := true ;
10311: LD_ADDR_EXP 33
10315: PUSH
10316: LD_INT 1
10318: ST_TO_ADDR
// if p3 = 6 then
10319: LD_VAR 0 3
10323: PUSH
10324: LD_INT 6
10326: EQUAL
10327: IFFALSE 10337
// sArmoury := true ;
10329: LD_ADDR_EXP 34
10333: PUSH
10334: LD_INT 1
10336: ST_TO_ADDR
// if p3 = 7 then
10337: LD_VAR 0 3
10341: PUSH
10342: LD_INT 7
10344: EQUAL
10345: IFFALSE 10355
// sRadar := true ;
10347: LD_ADDR_EXP 35
10351: PUSH
10352: LD_INT 1
10354: ST_TO_ADDR
// if p3 = 8 then
10355: LD_VAR 0 3
10359: PUSH
10360: LD_INT 8
10362: EQUAL
10363: IFFALSE 10373
// sBunker := true ;
10365: LD_ADDR_EXP 36
10369: PUSH
10370: LD_INT 1
10372: ST_TO_ADDR
// if p3 = 9 then
10373: LD_VAR 0 3
10377: PUSH
10378: LD_INT 9
10380: EQUAL
10381: IFFALSE 10391
// sHack := true ;
10383: LD_ADDR_EXP 37
10387: PUSH
10388: LD_INT 1
10390: ST_TO_ADDR
// if p3 = 10 then
10391: LD_VAR 0 3
10395: PUSH
10396: LD_INT 10
10398: EQUAL
10399: IFFALSE 10409
// sFire := true ;
10401: LD_ADDR_EXP 38
10405: PUSH
10406: LD_INT 1
10408: ST_TO_ADDR
// if p3 = 11 then
10409: LD_VAR 0 3
10413: PUSH
10414: LD_INT 11
10416: EQUAL
10417: IFFALSE 10427
// sRefresh := true ;
10419: LD_ADDR_EXP 39
10423: PUSH
10424: LD_INT 1
10426: ST_TO_ADDR
// if p3 = 12 then
10427: LD_VAR 0 3
10431: PUSH
10432: LD_INT 12
10434: EQUAL
10435: IFFALSE 10445
// sExp := true ;
10437: LD_ADDR_EXP 40
10441: PUSH
10442: LD_INT 1
10444: ST_TO_ADDR
// if p3 = 13 then
10445: LD_VAR 0 3
10449: PUSH
10450: LD_INT 13
10452: EQUAL
10453: IFFALSE 10463
// sDepot := true ;
10455: LD_ADDR_EXP 41
10459: PUSH
10460: LD_INT 1
10462: ST_TO_ADDR
// if p3 = 14 then
10463: LD_VAR 0 3
10467: PUSH
10468: LD_INT 14
10470: EQUAL
10471: IFFALSE 10481
// sFlag := true ;
10473: LD_ADDR_EXP 42
10477: PUSH
10478: LD_INT 1
10480: ST_TO_ADDR
// if p3 = 15 then
10481: LD_VAR 0 3
10485: PUSH
10486: LD_INT 15
10488: EQUAL
10489: IFFALSE 10499
// sKamikadze := true ;
10491: LD_ADDR_EXP 50
10495: PUSH
10496: LD_INT 1
10498: ST_TO_ADDR
// if p3 = 16 then
10499: LD_VAR 0 3
10503: PUSH
10504: LD_INT 16
10506: EQUAL
10507: IFFALSE 10517
// sTroll := true ;
10509: LD_ADDR_EXP 51
10513: PUSH
10514: LD_INT 1
10516: ST_TO_ADDR
// if p3 = 17 then
10517: LD_VAR 0 3
10521: PUSH
10522: LD_INT 17
10524: EQUAL
10525: IFFALSE 10535
// sSlow := true ;
10527: LD_ADDR_EXP 52
10531: PUSH
10532: LD_INT 1
10534: ST_TO_ADDR
// if p3 = 18 then
10535: LD_VAR 0 3
10539: PUSH
10540: LD_INT 18
10542: EQUAL
10543: IFFALSE 10553
// sLack := true ;
10545: LD_ADDR_EXP 53
10549: PUSH
10550: LD_INT 1
10552: ST_TO_ADDR
// if p3 = 19 then
10553: LD_VAR 0 3
10557: PUSH
10558: LD_INT 19
10560: EQUAL
10561: IFFALSE 10571
// sTank := true ;
10563: LD_ADDR_EXP 55
10567: PUSH
10568: LD_INT 1
10570: ST_TO_ADDR
// if p3 = 20 then
10571: LD_VAR 0 3
10575: PUSH
10576: LD_INT 20
10578: EQUAL
10579: IFFALSE 10589
// sRemote := true ;
10581: LD_ADDR_EXP 56
10585: PUSH
10586: LD_INT 1
10588: ST_TO_ADDR
// if p3 = 21 then
10589: LD_VAR 0 3
10593: PUSH
10594: LD_INT 21
10596: EQUAL
10597: IFFALSE 10607
// sPowell := true ;
10599: LD_ADDR_EXP 57
10603: PUSH
10604: LD_INT 1
10606: ST_TO_ADDR
// if p3 = 22 then
10607: LD_VAR 0 3
10611: PUSH
10612: LD_INT 22
10614: EQUAL
10615: IFFALSE 10625
// sTeleport := true ;
10617: LD_ADDR_EXP 60
10621: PUSH
10622: LD_INT 1
10624: ST_TO_ADDR
// if p3 = 23 then
10625: LD_VAR 0 3
10629: PUSH
10630: LD_INT 23
10632: EQUAL
10633: IFFALSE 10643
// sOilTower := true ;
10635: LD_ADDR_EXP 62
10639: PUSH
10640: LD_INT 1
10642: ST_TO_ADDR
// if p3 = 24 then
10643: LD_VAR 0 3
10647: PUSH
10648: LD_INT 24
10650: EQUAL
10651: IFFALSE 10661
// sShovel := true ;
10653: LD_ADDR_EXP 63
10657: PUSH
10658: LD_INT 1
10660: ST_TO_ADDR
// if p3 = 25 then
10661: LD_VAR 0 3
10665: PUSH
10666: LD_INT 25
10668: EQUAL
10669: IFFALSE 10679
// sSheik := true ;
10671: LD_ADDR_EXP 64
10675: PUSH
10676: LD_INT 1
10678: ST_TO_ADDR
// if p3 = 26 then
10679: LD_VAR 0 3
10683: PUSH
10684: LD_INT 26
10686: EQUAL
10687: IFFALSE 10697
// sEarthquake := true ;
10689: LD_ADDR_EXP 66
10693: PUSH
10694: LD_INT 1
10696: ST_TO_ADDR
// if p3 = 27 then
10697: LD_VAR 0 3
10701: PUSH
10702: LD_INT 27
10704: EQUAL
10705: IFFALSE 10715
// sAI := true ;
10707: LD_ADDR_EXP 67
10711: PUSH
10712: LD_INT 1
10714: ST_TO_ADDR
// if p3 = 28 then
10715: LD_VAR 0 3
10719: PUSH
10720: LD_INT 28
10722: EQUAL
10723: IFFALSE 10733
// sCargo := true ;
10725: LD_ADDR_EXP 70
10729: PUSH
10730: LD_INT 1
10732: ST_TO_ADDR
// if p3 = 29 then
10733: LD_VAR 0 3
10737: PUSH
10738: LD_INT 29
10740: EQUAL
10741: IFFALSE 10751
// sDLaser := true ;
10743: LD_ADDR_EXP 71
10747: PUSH
10748: LD_INT 1
10750: ST_TO_ADDR
// if p3 = 30 then
10751: LD_VAR 0 3
10755: PUSH
10756: LD_INT 30
10758: EQUAL
10759: IFFALSE 10769
// sExchange := true ;
10761: LD_ADDR_EXP 72
10765: PUSH
10766: LD_INT 1
10768: ST_TO_ADDR
// if p3 = 31 then
10769: LD_VAR 0 3
10773: PUSH
10774: LD_INT 31
10776: EQUAL
10777: IFFALSE 10787
// sFac := true ;
10779: LD_ADDR_EXP 73
10783: PUSH
10784: LD_INT 1
10786: ST_TO_ADDR
// if p3 = 32 then
10787: LD_VAR 0 3
10791: PUSH
10792: LD_INT 32
10794: EQUAL
10795: IFFALSE 10805
// sPower := true ;
10797: LD_ADDR_EXP 74
10801: PUSH
10802: LD_INT 1
10804: ST_TO_ADDR
// if p3 = 33 then
10805: LD_VAR 0 3
10809: PUSH
10810: LD_INT 33
10812: EQUAL
10813: IFFALSE 10823
// sRandom := true ;
10815: LD_ADDR_EXP 75
10819: PUSH
10820: LD_INT 1
10822: ST_TO_ADDR
// if p3 = 34 then
10823: LD_VAR 0 3
10827: PUSH
10828: LD_INT 34
10830: EQUAL
10831: IFFALSE 10841
// sShield := true ;
10833: LD_ADDR_EXP 76
10837: PUSH
10838: LD_INT 1
10840: ST_TO_ADDR
// if p3 = 35 then
10841: LD_VAR 0 3
10845: PUSH
10846: LD_INT 35
10848: EQUAL
10849: IFFALSE 10859
// sTime := true ;
10851: LD_ADDR_EXP 77
10855: PUSH
10856: LD_INT 1
10858: ST_TO_ADDR
// if p3 = 36 then
10859: LD_VAR 0 3
10863: PUSH
10864: LD_INT 36
10866: EQUAL
10867: IFFALSE 10877
// sTools := true ;
10869: LD_ADDR_EXP 78
10873: PUSH
10874: LD_INT 1
10876: ST_TO_ADDR
// if p3 = 101 then
10877: LD_VAR 0 3
10881: PUSH
10882: LD_INT 101
10884: EQUAL
10885: IFFALSE 10895
// sSold := true ;
10887: LD_ADDR_EXP 43
10891: PUSH
10892: LD_INT 1
10894: ST_TO_ADDR
// if p3 = 102 then
10895: LD_VAR 0 3
10899: PUSH
10900: LD_INT 102
10902: EQUAL
10903: IFFALSE 10913
// sDiff := true ;
10905: LD_ADDR_EXP 44
10909: PUSH
10910: LD_INT 1
10912: ST_TO_ADDR
// if p3 = 103 then
10913: LD_VAR 0 3
10917: PUSH
10918: LD_INT 103
10920: EQUAL
10921: IFFALSE 10931
// sFog := true ;
10923: LD_ADDR_EXP 47
10927: PUSH
10928: LD_INT 1
10930: ST_TO_ADDR
// if p3 = 104 then
10931: LD_VAR 0 3
10935: PUSH
10936: LD_INT 104
10938: EQUAL
10939: IFFALSE 10949
// sReset := true ;
10941: LD_ADDR_EXP 48
10945: PUSH
10946: LD_INT 1
10948: ST_TO_ADDR
// if p3 = 105 then
10949: LD_VAR 0 3
10953: PUSH
10954: LD_INT 105
10956: EQUAL
10957: IFFALSE 10967
// sSun := true ;
10959: LD_ADDR_EXP 49
10963: PUSH
10964: LD_INT 1
10966: ST_TO_ADDR
// if p3 = 106 then
10967: LD_VAR 0 3
10971: PUSH
10972: LD_INT 106
10974: EQUAL
10975: IFFALSE 10985
// sTiger := true ;
10977: LD_ADDR_EXP 45
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// if p3 = 107 then
10985: LD_VAR 0 3
10989: PUSH
10990: LD_INT 107
10992: EQUAL
10993: IFFALSE 11003
// sBomb := true ;
10995: LD_ADDR_EXP 46
10999: PUSH
11000: LD_INT 1
11002: ST_TO_ADDR
// if p3 = 108 then
11003: LD_VAR 0 3
11007: PUSH
11008: LD_INT 108
11010: EQUAL
11011: IFFALSE 11021
// sWound := true ;
11013: LD_ADDR_EXP 54
11017: PUSH
11018: LD_INT 1
11020: ST_TO_ADDR
// if p3 = 109 then
11021: LD_VAR 0 3
11025: PUSH
11026: LD_INT 109
11028: EQUAL
11029: IFFALSE 11039
// sBetray := true ;
11031: LD_ADDR_EXP 58
11035: PUSH
11036: LD_INT 1
11038: ST_TO_ADDR
// if p3 = 110 then
11039: LD_VAR 0 3
11043: PUSH
11044: LD_INT 110
11046: EQUAL
11047: IFFALSE 11057
// sContamin := true ;
11049: LD_ADDR_EXP 59
11053: PUSH
11054: LD_INT 1
11056: ST_TO_ADDR
// if p3 = 111 then
11057: LD_VAR 0 3
11061: PUSH
11062: LD_INT 111
11064: EQUAL
11065: IFFALSE 11075
// sOil := true ;
11067: LD_ADDR_EXP 61
11071: PUSH
11072: LD_INT 1
11074: ST_TO_ADDR
// if p3 = 112 then
11075: LD_VAR 0 3
11079: PUSH
11080: LD_INT 112
11082: EQUAL
11083: IFFALSE 11093
// sStu := true ;
11085: LD_ADDR_EXP 65
11089: PUSH
11090: LD_INT 1
11092: ST_TO_ADDR
// if p3 = 113 then
11093: LD_VAR 0 3
11097: PUSH
11098: LD_INT 113
11100: EQUAL
11101: IFFALSE 11111
// sBazooka := true ;
11103: LD_ADDR_EXP 68
11107: PUSH
11108: LD_INT 1
11110: ST_TO_ADDR
// if p3 = 114 then
11111: LD_VAR 0 3
11115: PUSH
11116: LD_INT 114
11118: EQUAL
11119: IFFALSE 11129
// sMortar := true ;
11121: LD_ADDR_EXP 69
11125: PUSH
11126: LD_INT 1
11128: ST_TO_ADDR
// if p3 = 115 then
11129: LD_VAR 0 3
11133: PUSH
11134: LD_INT 115
11136: EQUAL
11137: IFFALSE 11147
// sRanger := true ;
11139: LD_ADDR_EXP 79
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// end ; end ;
11147: PPOPN 6
11149: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11150: LD_EXP 26
11154: PUSH
11155: LD_EXP 31
11159: AND
11160: IFFALSE 11284
11162: GO 11164
11164: DISABLE
11165: LD_INT 0
11167: PPUSH
11168: PPUSH
// begin enable ;
11169: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11170: LD_ADDR_VAR 0 2
11174: PUSH
11175: LD_INT 22
11177: PUSH
11178: LD_OWVAR 2
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: PUSH
11187: LD_INT 2
11189: PUSH
11190: LD_INT 34
11192: PUSH
11193: LD_INT 7
11195: PUSH
11196: EMPTY
11197: LIST
11198: LIST
11199: PUSH
11200: LD_INT 34
11202: PUSH
11203: LD_INT 45
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: PUSH
11210: LD_INT 34
11212: PUSH
11213: LD_INT 28
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 34
11222: PUSH
11223: LD_INT 47
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PPUSH
11241: CALL_OW 69
11245: ST_TO_ADDR
// if not tmp then
11246: LD_VAR 0 2
11250: NOT
11251: IFFALSE 11255
// exit ;
11253: GO 11284
// for i in tmp do
11255: LD_ADDR_VAR 0 1
11259: PUSH
11260: LD_VAR 0 2
11264: PUSH
11265: FOR_IN
11266: IFFALSE 11282
// begin SetLives ( i , 0 ) ;
11268: LD_VAR 0 1
11272: PPUSH
11273: LD_INT 0
11275: PPUSH
11276: CALL_OW 234
// end ;
11280: GO 11265
11282: POP
11283: POP
// end ;
11284: PPOPN 2
11286: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11287: LD_EXP 26
11291: PUSH
11292: LD_EXP 32
11296: AND
11297: IFFALSE 11381
11299: GO 11301
11301: DISABLE
11302: LD_INT 0
11304: PPUSH
11305: PPUSH
// begin enable ;
11306: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11307: LD_ADDR_VAR 0 2
11311: PUSH
11312: LD_INT 22
11314: PUSH
11315: LD_OWVAR 2
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: PUSH
11324: LD_INT 32
11326: PUSH
11327: LD_INT 3
11329: PUSH
11330: EMPTY
11331: LIST
11332: LIST
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PPUSH
11338: CALL_OW 69
11342: ST_TO_ADDR
// if not tmp then
11343: LD_VAR 0 2
11347: NOT
11348: IFFALSE 11352
// exit ;
11350: GO 11381
// for i in tmp do
11352: LD_ADDR_VAR 0 1
11356: PUSH
11357: LD_VAR 0 2
11361: PUSH
11362: FOR_IN
11363: IFFALSE 11379
// begin SetLives ( i , 0 ) ;
11365: LD_VAR 0 1
11369: PPUSH
11370: LD_INT 0
11372: PPUSH
11373: CALL_OW 234
// end ;
11377: GO 11362
11379: POP
11380: POP
// end ;
11381: PPOPN 2
11383: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
11384: LD_EXP 26
11388: PUSH
11389: LD_EXP 29
11393: AND
11394: IFFALSE 11487
11396: GO 11398
11398: DISABLE
11399: LD_INT 0
11401: PPUSH
// begin enable ;
11402: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
11403: LD_ADDR_VAR 0 1
11407: PUSH
11408: LD_INT 22
11410: PUSH
11411: LD_OWVAR 2
11415: PUSH
11416: EMPTY
11417: LIST
11418: LIST
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: LD_INT 25
11425: PUSH
11426: LD_INT 5
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 9
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 8
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: LIST
11457: LIST
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PPUSH
11463: CALL_OW 69
11467: PUSH
11468: FOR_IN
11469: IFFALSE 11485
// begin SetClass ( i , 1 ) ;
11471: LD_VAR 0 1
11475: PPUSH
11476: LD_INT 1
11478: PPUSH
11479: CALL_OW 336
// end ;
11483: GO 11468
11485: POP
11486: POP
// end ;
11487: PPOPN 1
11489: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
11490: LD_EXP 26
11494: PUSH
11495: LD_EXP 30
11499: AND
11500: PUSH
11501: LD_OWVAR 65
11505: PUSH
11506: LD_INT 7
11508: LESS
11509: AND
11510: IFFALSE 11524
11512: GO 11514
11514: DISABLE
// begin enable ;
11515: ENABLE
// game_speed := 7 ;
11516: LD_ADDR_OWVAR 65
11520: PUSH
11521: LD_INT 7
11523: ST_TO_ADDR
// end ;
11524: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
11525: LD_EXP 26
11529: PUSH
11530: LD_EXP 33
11534: AND
11535: IFFALSE 11737
11537: GO 11539
11539: DISABLE
11540: LD_INT 0
11542: PPUSH
11543: PPUSH
11544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
11545: LD_ADDR_VAR 0 3
11549: PUSH
11550: LD_INT 81
11552: PUSH
11553: LD_OWVAR 2
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 21
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PPUSH
11576: CALL_OW 69
11580: ST_TO_ADDR
// if not tmp then
11581: LD_VAR 0 3
11585: NOT
11586: IFFALSE 11590
// exit ;
11588: GO 11737
// if tmp > 5 then
11590: LD_VAR 0 3
11594: PUSH
11595: LD_INT 5
11597: GREATER
11598: IFFALSE 11610
// k := 5 else
11600: LD_ADDR_VAR 0 2
11604: PUSH
11605: LD_INT 5
11607: ST_TO_ADDR
11608: GO 11620
// k := tmp ;
11610: LD_ADDR_VAR 0 2
11614: PUSH
11615: LD_VAR 0 3
11619: ST_TO_ADDR
// for i := 1 to k do
11620: LD_ADDR_VAR 0 1
11624: PUSH
11625: DOUBLE
11626: LD_INT 1
11628: DEC
11629: ST_TO_ADDR
11630: LD_VAR 0 2
11634: PUSH
11635: FOR_TO
11636: IFFALSE 11735
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
11638: LD_VAR 0 3
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PPUSH
11649: LD_VAR 0 1
11653: PUSH
11654: LD_INT 4
11656: MOD
11657: PUSH
11658: LD_INT 1
11660: PLUS
11661: PPUSH
11662: CALL_OW 259
11666: PUSH
11667: LD_INT 10
11669: LESS
11670: IFFALSE 11733
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
11672: LD_VAR 0 3
11676: PUSH
11677: LD_VAR 0 1
11681: ARRAY
11682: PPUSH
11683: LD_VAR 0 1
11687: PUSH
11688: LD_INT 4
11690: MOD
11691: PUSH
11692: LD_INT 1
11694: PLUS
11695: PPUSH
11696: LD_VAR 0 3
11700: PUSH
11701: LD_VAR 0 1
11705: ARRAY
11706: PPUSH
11707: LD_VAR 0 1
11711: PUSH
11712: LD_INT 4
11714: MOD
11715: PUSH
11716: LD_INT 1
11718: PLUS
11719: PPUSH
11720: CALL_OW 259
11724: PUSH
11725: LD_INT 1
11727: PLUS
11728: PPUSH
11729: CALL_OW 237
11733: GO 11635
11735: POP
11736: POP
// end ;
11737: PPOPN 3
11739: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
11740: LD_EXP 26
11744: PUSH
11745: LD_EXP 34
11749: AND
11750: IFFALSE 11770
11752: GO 11754
11754: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
11755: LD_INT 4
11757: PPUSH
11758: LD_OWVAR 2
11762: PPUSH
11763: LD_INT 0
11765: PPUSH
11766: CALL_OW 324
11770: END
// every 0 0$1 trigger StreamModeActive and sShovel do
11771: LD_EXP 26
11775: PUSH
11776: LD_EXP 63
11780: AND
11781: IFFALSE 11801
11783: GO 11785
11785: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
11786: LD_INT 19
11788: PPUSH
11789: LD_OWVAR 2
11793: PPUSH
11794: LD_INT 0
11796: PPUSH
11797: CALL_OW 324
11801: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
11802: LD_EXP 26
11806: PUSH
11807: LD_EXP 35
11811: AND
11812: IFFALSE 11914
11814: GO 11816
11816: DISABLE
11817: LD_INT 0
11819: PPUSH
11820: PPUSH
// begin enable ;
11821: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
11822: LD_ADDR_VAR 0 2
11826: PUSH
11827: LD_INT 22
11829: PUSH
11830: LD_OWVAR 2
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 2
11841: PUSH
11842: LD_INT 34
11844: PUSH
11845: LD_INT 11
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: PUSH
11852: LD_INT 34
11854: PUSH
11855: LD_INT 30
11857: PUSH
11858: EMPTY
11859: LIST
11860: LIST
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: PUSH
11867: EMPTY
11868: LIST
11869: LIST
11870: PPUSH
11871: CALL_OW 69
11875: ST_TO_ADDR
// if not tmp then
11876: LD_VAR 0 2
11880: NOT
11881: IFFALSE 11885
// exit ;
11883: GO 11914
// for i in tmp do
11885: LD_ADDR_VAR 0 1
11889: PUSH
11890: LD_VAR 0 2
11894: PUSH
11895: FOR_IN
11896: IFFALSE 11912
// begin SetLives ( i , 0 ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_INT 0
11905: PPUSH
11906: CALL_OW 234
// end ;
11910: GO 11895
11912: POP
11913: POP
// end ;
11914: PPOPN 2
11916: END
// every 0 0$1 trigger StreamModeActive and sBunker do
11917: LD_EXP 26
11921: PUSH
11922: LD_EXP 36
11926: AND
11927: IFFALSE 11947
11929: GO 11931
11931: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
11932: LD_INT 32
11934: PPUSH
11935: LD_OWVAR 2
11939: PPUSH
11940: LD_INT 0
11942: PPUSH
11943: CALL_OW 324
11947: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
11948: LD_EXP 26
11952: PUSH
11953: LD_EXP 37
11957: AND
11958: IFFALSE 12139
11960: GO 11962
11962: DISABLE
11963: LD_INT 0
11965: PPUSH
11966: PPUSH
11967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
11968: LD_ADDR_VAR 0 2
11972: PUSH
11973: LD_INT 22
11975: PUSH
11976: LD_OWVAR 2
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PUSH
11985: LD_INT 33
11987: PUSH
11988: LD_INT 3
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PPUSH
11999: CALL_OW 69
12003: ST_TO_ADDR
// if not tmp then
12004: LD_VAR 0 2
12008: NOT
12009: IFFALSE 12013
// exit ;
12011: GO 12139
// side := 0 ;
12013: LD_ADDR_VAR 0 3
12017: PUSH
12018: LD_INT 0
12020: ST_TO_ADDR
// for i := 1 to 8 do
12021: LD_ADDR_VAR 0 1
12025: PUSH
12026: DOUBLE
12027: LD_INT 1
12029: DEC
12030: ST_TO_ADDR
12031: LD_INT 8
12033: PUSH
12034: FOR_TO
12035: IFFALSE 12083
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12037: LD_OWVAR 2
12041: PUSH
12042: LD_VAR 0 1
12046: NONEQUAL
12047: PUSH
12048: LD_OWVAR 2
12052: PPUSH
12053: LD_VAR 0 1
12057: PPUSH
12058: CALL_OW 81
12062: PUSH
12063: LD_INT 2
12065: EQUAL
12066: AND
12067: IFFALSE 12081
// begin side := i ;
12069: LD_ADDR_VAR 0 3
12073: PUSH
12074: LD_VAR 0 1
12078: ST_TO_ADDR
// break ;
12079: GO 12083
// end ;
12081: GO 12034
12083: POP
12084: POP
// if not side then
12085: LD_VAR 0 3
12089: NOT
12090: IFFALSE 12094
// exit ;
12092: GO 12139
// for i := 1 to tmp do
12094: LD_ADDR_VAR 0 1
12098: PUSH
12099: DOUBLE
12100: LD_INT 1
12102: DEC
12103: ST_TO_ADDR
12104: LD_VAR 0 2
12108: PUSH
12109: FOR_TO
12110: IFFALSE 12137
// if Prob ( 30 ) then
12112: LD_INT 30
12114: PPUSH
12115: CALL_OW 13
12119: IFFALSE 12135
// SetSide ( i , side ) ;
12121: LD_VAR 0 1
12125: PPUSH
12126: LD_VAR 0 3
12130: PPUSH
12131: CALL_OW 235
12135: GO 12109
12137: POP
12138: POP
// end ;
12139: PPOPN 3
12141: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12142: LD_EXP 26
12146: PUSH
12147: LD_EXP 39
12151: AND
12152: IFFALSE 12271
12154: GO 12156
12156: DISABLE
12157: LD_INT 0
12159: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12160: LD_ADDR_VAR 0 1
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_OWVAR 2
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 21
12179: PUSH
12180: LD_INT 1
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 3
12189: PUSH
12190: LD_INT 23
12192: PUSH
12193: LD_INT 0
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: PUSH
12214: FOR_IN
12215: IFFALSE 12269
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12217: LD_VAR 0 1
12221: PPUSH
12222: CALL_OW 257
12226: PUSH
12227: LD_INT 1
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 3
12235: PUSH
12236: LD_INT 4
12238: PUSH
12239: EMPTY
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: IN
12245: IFFALSE 12267
// SetClass ( un , rand ( 1 , 4 ) ) ;
12247: LD_VAR 0 1
12251: PPUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_INT 4
12257: PPUSH
12258: CALL_OW 12
12262: PPUSH
12263: CALL_OW 336
12267: GO 12214
12269: POP
12270: POP
// end ;
12271: PPOPN 1
12273: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12274: LD_EXP 26
12278: PUSH
12279: LD_EXP 38
12283: AND
12284: IFFALSE 12363
12286: GO 12288
12288: DISABLE
12289: LD_INT 0
12291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12292: LD_ADDR_VAR 0 1
12296: PUSH
12297: LD_INT 22
12299: PUSH
12300: LD_OWVAR 2
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: LD_INT 21
12311: PUSH
12312: LD_INT 3
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: PPUSH
12323: CALL_OW 69
12327: ST_TO_ADDR
// if not tmp then
12328: LD_VAR 0 1
12332: NOT
12333: IFFALSE 12337
// exit ;
12335: GO 12363
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12337: LD_VAR 0 1
12341: PUSH
12342: LD_INT 1
12344: PPUSH
12345: LD_VAR 0 1
12349: PPUSH
12350: CALL_OW 12
12354: ARRAY
12355: PPUSH
12356: LD_INT 100
12358: PPUSH
12359: CALL_OW 234
// end ;
12363: PPOPN 1
12365: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12366: LD_EXP 26
12370: PUSH
12371: LD_EXP 40
12375: AND
12376: IFFALSE 12474
12378: GO 12380
12380: DISABLE
12381: LD_INT 0
12383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12384: LD_ADDR_VAR 0 1
12388: PUSH
12389: LD_INT 22
12391: PUSH
12392: LD_OWVAR 2
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: PUSH
12401: LD_INT 21
12403: PUSH
12404: LD_INT 1
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PPUSH
12415: CALL_OW 69
12419: ST_TO_ADDR
// if not tmp then
12420: LD_VAR 0 1
12424: NOT
12425: IFFALSE 12429
// exit ;
12427: GO 12474
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
12429: LD_VAR 0 1
12433: PUSH
12434: LD_INT 1
12436: PPUSH
12437: LD_VAR 0 1
12441: PPUSH
12442: CALL_OW 12
12446: ARRAY
12447: PPUSH
12448: LD_INT 1
12450: PPUSH
12451: LD_INT 4
12453: PPUSH
12454: CALL_OW 12
12458: PPUSH
12459: LD_INT 3000
12461: PPUSH
12462: LD_INT 9000
12464: PPUSH
12465: CALL_OW 12
12469: PPUSH
12470: CALL_OW 492
// end ;
12474: PPOPN 1
12476: END
// every 0 0$1 trigger StreamModeActive and sDepot do
12477: LD_EXP 26
12481: PUSH
12482: LD_EXP 41
12486: AND
12487: IFFALSE 12507
12489: GO 12491
12491: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
12492: LD_INT 1
12494: PPUSH
12495: LD_OWVAR 2
12499: PPUSH
12500: LD_INT 0
12502: PPUSH
12503: CALL_OW 324
12507: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
12508: LD_EXP 26
12512: PUSH
12513: LD_EXP 42
12517: AND
12518: IFFALSE 12601
12520: GO 12522
12522: DISABLE
12523: LD_INT 0
12525: PPUSH
12526: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12527: LD_ADDR_VAR 0 2
12531: PUSH
12532: LD_INT 22
12534: PUSH
12535: LD_OWVAR 2
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PUSH
12544: LD_INT 21
12546: PUSH
12547: LD_INT 3
12549: PUSH
12550: EMPTY
12551: LIST
12552: LIST
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: PPUSH
12558: CALL_OW 69
12562: ST_TO_ADDR
// if not tmp then
12563: LD_VAR 0 2
12567: NOT
12568: IFFALSE 12572
// exit ;
12570: GO 12601
// for i in tmp do
12572: LD_ADDR_VAR 0 1
12576: PUSH
12577: LD_VAR 0 2
12581: PUSH
12582: FOR_IN
12583: IFFALSE 12599
// SetBLevel ( i , 10 ) ;
12585: LD_VAR 0 1
12589: PPUSH
12590: LD_INT 10
12592: PPUSH
12593: CALL_OW 241
12597: GO 12582
12599: POP
12600: POP
// end ;
12601: PPOPN 2
12603: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
12604: LD_EXP 26
12608: PUSH
12609: LD_EXP 43
12613: AND
12614: IFFALSE 12725
12616: GO 12618
12618: DISABLE
12619: LD_INT 0
12621: PPUSH
12622: PPUSH
12623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12624: LD_ADDR_VAR 0 3
12628: PUSH
12629: LD_INT 22
12631: PUSH
12632: LD_OWVAR 2
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 25
12643: PUSH
12644: LD_INT 1
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: PPUSH
12655: CALL_OW 69
12659: ST_TO_ADDR
// if not tmp then
12660: LD_VAR 0 3
12664: NOT
12665: IFFALSE 12669
// exit ;
12667: GO 12725
// un := tmp [ rand ( 1 , tmp ) ] ;
12669: LD_ADDR_VAR 0 2
12673: PUSH
12674: LD_VAR 0 3
12678: PUSH
12679: LD_INT 1
12681: PPUSH
12682: LD_VAR 0 3
12686: PPUSH
12687: CALL_OW 12
12691: ARRAY
12692: ST_TO_ADDR
// if Crawls ( un ) then
12693: LD_VAR 0 2
12697: PPUSH
12698: CALL_OW 318
12702: IFFALSE 12713
// ComWalk ( un ) ;
12704: LD_VAR 0 2
12708: PPUSH
12709: CALL_OW 138
// SetClass ( un , class_sniper ) ;
12713: LD_VAR 0 2
12717: PPUSH
12718: LD_INT 5
12720: PPUSH
12721: CALL_OW 336
// end ;
12725: PPOPN 3
12727: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
12728: LD_EXP 26
12732: PUSH
12733: LD_EXP 44
12737: AND
12738: PUSH
12739: LD_OWVAR 67
12743: PUSH
12744: LD_INT 3
12746: LESS
12747: AND
12748: IFFALSE 12767
12750: GO 12752
12752: DISABLE
// Difficulty := Difficulty + 1 ;
12753: LD_ADDR_OWVAR 67
12757: PUSH
12758: LD_OWVAR 67
12762: PUSH
12763: LD_INT 1
12765: PLUS
12766: ST_TO_ADDR
12767: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
12768: LD_EXP 26
12772: PUSH
12773: LD_EXP 45
12777: AND
12778: IFFALSE 12881
12780: GO 12782
12782: DISABLE
12783: LD_INT 0
12785: PPUSH
// begin for i := 1 to 5 do
12786: LD_ADDR_VAR 0 1
12790: PUSH
12791: DOUBLE
12792: LD_INT 1
12794: DEC
12795: ST_TO_ADDR
12796: LD_INT 5
12798: PUSH
12799: FOR_TO
12800: IFFALSE 12879
// begin uc_nation := nation_nature ;
12802: LD_ADDR_OWVAR 21
12806: PUSH
12807: LD_INT 0
12809: ST_TO_ADDR
// uc_side := 0 ;
12810: LD_ADDR_OWVAR 20
12814: PUSH
12815: LD_INT 0
12817: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
12818: LD_ADDR_OWVAR 29
12822: PUSH
12823: LD_INT 12
12825: PUSH
12826: LD_INT 12
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: ST_TO_ADDR
// hc_agressivity := 20 ;
12833: LD_ADDR_OWVAR 35
12837: PUSH
12838: LD_INT 20
12840: ST_TO_ADDR
// hc_class := class_tiger ;
12841: LD_ADDR_OWVAR 28
12845: PUSH
12846: LD_INT 14
12848: ST_TO_ADDR
// hc_gallery :=  ;
12849: LD_ADDR_OWVAR 33
12853: PUSH
12854: LD_STRING 
12856: ST_TO_ADDR
// hc_name :=  ;
12857: LD_ADDR_OWVAR 26
12861: PUSH
12862: LD_STRING 
12864: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
12865: CALL_OW 44
12869: PPUSH
12870: LD_INT 0
12872: PPUSH
12873: CALL_OW 51
// end ;
12877: GO 12799
12879: POP
12880: POP
// end ;
12881: PPOPN 1
12883: END
// every 0 0$1 trigger StreamModeActive and sBomb do
12884: LD_EXP 26
12888: PUSH
12889: LD_EXP 46
12893: AND
12894: IFFALSE 12903
12896: GO 12898
12898: DISABLE
// StreamSibBomb ;
12899: CALL 12904 0 0
12903: END
// export function StreamSibBomb ; var i , x , y ; begin
12904: LD_INT 0
12906: PPUSH
12907: PPUSH
12908: PPUSH
12909: PPUSH
// result := false ;
12910: LD_ADDR_VAR 0 1
12914: PUSH
12915: LD_INT 0
12917: ST_TO_ADDR
// for i := 1 to 16 do
12918: LD_ADDR_VAR 0 2
12922: PUSH
12923: DOUBLE
12924: LD_INT 1
12926: DEC
12927: ST_TO_ADDR
12928: LD_INT 16
12930: PUSH
12931: FOR_TO
12932: IFFALSE 13131
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
12934: LD_ADDR_VAR 0 3
12938: PUSH
12939: LD_INT 10
12941: PUSH
12942: LD_INT 20
12944: PUSH
12945: LD_INT 30
12947: PUSH
12948: LD_INT 40
12950: PUSH
12951: LD_INT 50
12953: PUSH
12954: LD_INT 60
12956: PUSH
12957: LD_INT 70
12959: PUSH
12960: LD_INT 80
12962: PUSH
12963: LD_INT 90
12965: PUSH
12966: LD_INT 100
12968: PUSH
12969: LD_INT 110
12971: PUSH
12972: LD_INT 120
12974: PUSH
12975: LD_INT 130
12977: PUSH
12978: LD_INT 140
12980: PUSH
12981: LD_INT 150
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: LIST
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: PUSH
13001: LD_INT 1
13003: PPUSH
13004: LD_INT 15
13006: PPUSH
13007: CALL_OW 12
13011: ARRAY
13012: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13013: LD_ADDR_VAR 0 4
13017: PUSH
13018: LD_INT 10
13020: PUSH
13021: LD_INT 20
13023: PUSH
13024: LD_INT 30
13026: PUSH
13027: LD_INT 40
13029: PUSH
13030: LD_INT 50
13032: PUSH
13033: LD_INT 60
13035: PUSH
13036: LD_INT 70
13038: PUSH
13039: LD_INT 80
13041: PUSH
13042: LD_INT 90
13044: PUSH
13045: LD_INT 100
13047: PUSH
13048: LD_INT 110
13050: PUSH
13051: LD_INT 120
13053: PUSH
13054: LD_INT 130
13056: PUSH
13057: LD_INT 140
13059: PUSH
13060: LD_INT 150
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: PUSH
13080: LD_INT 1
13082: PPUSH
13083: LD_INT 15
13085: PPUSH
13086: CALL_OW 12
13090: ARRAY
13091: ST_TO_ADDR
// if ValidHex ( x , y ) then
13092: LD_VAR 0 3
13096: PPUSH
13097: LD_VAR 0 4
13101: PPUSH
13102: CALL_OW 488
13106: IFFALSE 13129
// begin result := [ x , y ] ;
13108: LD_ADDR_VAR 0 1
13112: PUSH
13113: LD_VAR 0 3
13117: PUSH
13118: LD_VAR 0 4
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: ST_TO_ADDR
// break ;
13127: GO 13131
// end ; end ;
13129: GO 12931
13131: POP
13132: POP
// if result then
13133: LD_VAR 0 1
13137: IFFALSE 13197
// begin ToLua ( playSibBomb() ) ;
13139: LD_STRING playSibBomb()
13141: PPUSH
13142: CALL_OW 559
// wait ( 0 0$14 ) ;
13146: LD_INT 490
13148: PPUSH
13149: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
13153: LD_VAR 0 1
13157: PUSH
13158: LD_INT 1
13160: ARRAY
13161: PPUSH
13162: LD_VAR 0 1
13166: PUSH
13167: LD_INT 2
13169: ARRAY
13170: PPUSH
13171: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13175: LD_VAR 0 1
13179: PUSH
13180: LD_INT 1
13182: ARRAY
13183: PPUSH
13184: LD_VAR 0 1
13188: PUSH
13189: LD_INT 2
13191: ARRAY
13192: PPUSH
13193: CALL_OW 429
// end ; end ;
13197: LD_VAR 0 1
13201: RET
// every 0 0$1 trigger StreamModeActive and sReset do
13202: LD_EXP 26
13206: PUSH
13207: LD_EXP 48
13211: AND
13212: IFFALSE 13224
13214: GO 13216
13216: DISABLE
// YouLost (  ) ;
13217: LD_STRING 
13219: PPUSH
13220: CALL_OW 104
13224: END
// every 0 0$1 trigger StreamModeActive and sFog do
13225: LD_EXP 26
13229: PUSH
13230: LD_EXP 47
13234: AND
13235: IFFALSE 13249
13237: GO 13239
13239: DISABLE
// FogOff ( your_side ) ;
13240: LD_OWVAR 2
13244: PPUSH
13245: CALL_OW 344
13249: END
// every 0 0$1 trigger StreamModeActive and sSun do
13250: LD_EXP 26
13254: PUSH
13255: LD_EXP 49
13259: AND
13260: IFFALSE 13288
13262: GO 13264
13264: DISABLE
// begin solar_recharge_percent := 0 ;
13265: LD_ADDR_OWVAR 79
13269: PUSH
13270: LD_INT 0
13272: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13273: LD_INT 10500
13275: PPUSH
13276: CALL_OW 67
// solar_recharge_percent := 100 ;
13280: LD_ADDR_OWVAR 79
13284: PUSH
13285: LD_INT 100
13287: ST_TO_ADDR
// end ;
13288: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13289: LD_EXP 26
13293: PUSH
13294: LD_EXP 50
13298: AND
13299: IFFALSE 13538
13301: GO 13303
13303: DISABLE
13304: LD_INT 0
13306: PPUSH
13307: PPUSH
13308: PPUSH
// begin tmp := [ ] ;
13309: LD_ADDR_VAR 0 3
13313: PUSH
13314: EMPTY
13315: ST_TO_ADDR
// for i := 1 to 6 do
13316: LD_ADDR_VAR 0 1
13320: PUSH
13321: DOUBLE
13322: LD_INT 1
13324: DEC
13325: ST_TO_ADDR
13326: LD_INT 6
13328: PUSH
13329: FOR_TO
13330: IFFALSE 13435
// begin uc_nation := nation_nature ;
13332: LD_ADDR_OWVAR 21
13336: PUSH
13337: LD_INT 0
13339: ST_TO_ADDR
// uc_side := 0 ;
13340: LD_ADDR_OWVAR 20
13344: PUSH
13345: LD_INT 0
13347: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13348: LD_ADDR_OWVAR 29
13352: PUSH
13353: LD_INT 12
13355: PUSH
13356: LD_INT 12
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: ST_TO_ADDR
// hc_agressivity := 20 ;
13363: LD_ADDR_OWVAR 35
13367: PUSH
13368: LD_INT 20
13370: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13371: LD_ADDR_OWVAR 28
13375: PUSH
13376: LD_INT 17
13378: ST_TO_ADDR
// hc_gallery :=  ;
13379: LD_ADDR_OWVAR 33
13383: PUSH
13384: LD_STRING 
13386: ST_TO_ADDR
// hc_name :=  ;
13387: LD_ADDR_OWVAR 26
13391: PUSH
13392: LD_STRING 
13394: ST_TO_ADDR
// un := CreateHuman ;
13395: LD_ADDR_VAR 0 2
13399: PUSH
13400: CALL_OW 44
13404: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13405: LD_VAR 0 2
13409: PPUSH
13410: LD_INT 1
13412: PPUSH
13413: CALL_OW 51
// tmp := tmp ^ un ;
13417: LD_ADDR_VAR 0 3
13421: PUSH
13422: LD_VAR 0 3
13426: PUSH
13427: LD_VAR 0 2
13431: ADD
13432: ST_TO_ADDR
// end ;
13433: GO 13329
13435: POP
13436: POP
// repeat wait ( 0 0$1 ) ;
13437: LD_INT 35
13439: PPUSH
13440: CALL_OW 67
// for un in tmp do
13444: LD_ADDR_VAR 0 2
13448: PUSH
13449: LD_VAR 0 3
13453: PUSH
13454: FOR_IN
13455: IFFALSE 13529
// begin if IsDead ( un ) then
13457: LD_VAR 0 2
13461: PPUSH
13462: CALL_OW 301
13466: IFFALSE 13486
// begin tmp := tmp diff un ;
13468: LD_ADDR_VAR 0 3
13472: PUSH
13473: LD_VAR 0 3
13477: PUSH
13478: LD_VAR 0 2
13482: DIFF
13483: ST_TO_ADDR
// continue ;
13484: GO 13454
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
13486: LD_VAR 0 2
13490: PPUSH
13491: LD_INT 3
13493: PUSH
13494: LD_INT 22
13496: PUSH
13497: LD_INT 0
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PPUSH
13508: CALL_OW 69
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL_OW 74
13522: PPUSH
13523: CALL_OW 115
// end ;
13527: GO 13454
13529: POP
13530: POP
// until not tmp ;
13531: LD_VAR 0 3
13535: NOT
13536: IFFALSE 13437
// end ;
13538: PPOPN 3
13540: END
// every 0 0$1 trigger StreamModeActive and sTroll do
13541: LD_EXP 26
13545: PUSH
13546: LD_EXP 51
13550: AND
13551: IFFALSE 13605
13553: GO 13555
13555: DISABLE
// begin ToLua ( displayTroll(); ) ;
13556: LD_STRING displayTroll();
13558: PPUSH
13559: CALL_OW 559
// wait ( 3 3$00 ) ;
13563: LD_INT 6300
13565: PPUSH
13566: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13570: LD_STRING hideTroll();
13572: PPUSH
13573: CALL_OW 559
// wait ( 1 1$00 ) ;
13577: LD_INT 2100
13579: PPUSH
13580: CALL_OW 67
// ToLua ( displayTroll(); ) ;
13584: LD_STRING displayTroll();
13586: PPUSH
13587: CALL_OW 559
// wait ( 1 1$00 ) ;
13591: LD_INT 2100
13593: PPUSH
13594: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13598: LD_STRING hideTroll();
13600: PPUSH
13601: CALL_OW 559
// end ;
13605: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
13606: LD_EXP 26
13610: PUSH
13611: LD_EXP 52
13615: AND
13616: IFFALSE 13679
13618: GO 13620
13620: DISABLE
13621: LD_INT 0
13623: PPUSH
// begin p := 0 ;
13624: LD_ADDR_VAR 0 1
13628: PUSH
13629: LD_INT 0
13631: ST_TO_ADDR
// repeat game_speed := 1 ;
13632: LD_ADDR_OWVAR 65
13636: PUSH
13637: LD_INT 1
13639: ST_TO_ADDR
// wait ( 0 0$1 ) ;
13640: LD_INT 35
13642: PPUSH
13643: CALL_OW 67
// p := p + 1 ;
13647: LD_ADDR_VAR 0 1
13651: PUSH
13652: LD_VAR 0 1
13656: PUSH
13657: LD_INT 1
13659: PLUS
13660: ST_TO_ADDR
// until p >= 60 ;
13661: LD_VAR 0 1
13665: PUSH
13666: LD_INT 60
13668: GREATEREQUAL
13669: IFFALSE 13632
// game_speed := 4 ;
13671: LD_ADDR_OWVAR 65
13675: PUSH
13676: LD_INT 4
13678: ST_TO_ADDR
// end ;
13679: PPOPN 1
13681: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
13682: LD_EXP 26
13686: PUSH
13687: LD_EXP 53
13691: AND
13692: IFFALSE 13838
13694: GO 13696
13696: DISABLE
13697: LD_INT 0
13699: PPUSH
13700: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
13701: LD_ADDR_VAR 0 1
13705: PUSH
13706: LD_INT 22
13708: PUSH
13709: LD_OWVAR 2
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: PUSH
13718: LD_INT 2
13720: PUSH
13721: LD_INT 30
13723: PUSH
13724: LD_INT 0
13726: PUSH
13727: EMPTY
13728: LIST
13729: LIST
13730: PUSH
13731: LD_INT 30
13733: PUSH
13734: LD_INT 1
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: LIST
13745: PUSH
13746: EMPTY
13747: LIST
13748: LIST
13749: PPUSH
13750: CALL_OW 69
13754: ST_TO_ADDR
// if not depot then
13755: LD_VAR 0 1
13759: NOT
13760: IFFALSE 13764
// exit ;
13762: GO 13838
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_VAR 0 1
13773: PUSH
13774: LD_INT 1
13776: PPUSH
13777: LD_VAR 0 1
13781: PPUSH
13782: CALL_OW 12
13786: ARRAY
13787: PPUSH
13788: CALL_OW 274
13792: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
13793: LD_VAR 0 2
13797: PPUSH
13798: LD_INT 1
13800: PPUSH
13801: LD_INT 0
13803: PPUSH
13804: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
13808: LD_VAR 0 2
13812: PPUSH
13813: LD_INT 2
13815: PPUSH
13816: LD_INT 0
13818: PPUSH
13819: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
13823: LD_VAR 0 2
13827: PPUSH
13828: LD_INT 3
13830: PPUSH
13831: LD_INT 0
13833: PPUSH
13834: CALL_OW 277
// end ;
13838: PPOPN 2
13840: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
13841: LD_EXP 26
13845: PUSH
13846: LD_EXP 54
13850: AND
13851: IFFALSE 13948
13853: GO 13855
13855: DISABLE
13856: LD_INT 0
13858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13859: LD_ADDR_VAR 0 1
13863: PUSH
13864: LD_INT 22
13866: PUSH
13867: LD_OWVAR 2
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: PUSH
13876: LD_INT 21
13878: PUSH
13879: LD_INT 1
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PUSH
13886: LD_INT 3
13888: PUSH
13889: LD_INT 23
13891: PUSH
13892: LD_INT 0
13894: PUSH
13895: EMPTY
13896: LIST
13897: LIST
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: LIST
13907: PPUSH
13908: CALL_OW 69
13912: ST_TO_ADDR
// if not tmp then
13913: LD_VAR 0 1
13917: NOT
13918: IFFALSE 13922
// exit ;
13920: GO 13948
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
13922: LD_VAR 0 1
13926: PUSH
13927: LD_INT 1
13929: PPUSH
13930: LD_VAR 0 1
13934: PPUSH
13935: CALL_OW 12
13939: ARRAY
13940: PPUSH
13941: LD_INT 200
13943: PPUSH
13944: CALL_OW 234
// end ;
13948: PPOPN 1
13950: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
13951: LD_EXP 26
13955: PUSH
13956: LD_EXP 55
13960: AND
13961: IFFALSE 14040
13963: GO 13965
13965: DISABLE
13966: LD_INT 0
13968: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
13969: LD_ADDR_VAR 0 1
13973: PUSH
13974: LD_INT 22
13976: PUSH
13977: LD_OWVAR 2
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 21
13988: PUSH
13989: LD_INT 2
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PPUSH
14000: CALL_OW 69
14004: ST_TO_ADDR
// if not tmp then
14005: LD_VAR 0 1
14009: NOT
14010: IFFALSE 14014
// exit ;
14012: GO 14040
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14014: LD_VAR 0 1
14018: PUSH
14019: LD_INT 1
14021: PPUSH
14022: LD_VAR 0 1
14026: PPUSH
14027: CALL_OW 12
14031: ARRAY
14032: PPUSH
14033: LD_INT 60
14035: PPUSH
14036: CALL_OW 234
// end ;
14040: PPOPN 1
14042: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14043: LD_EXP 26
14047: PUSH
14048: LD_EXP 56
14052: AND
14053: IFFALSE 14152
14055: GO 14057
14057: DISABLE
14058: LD_INT 0
14060: PPUSH
14061: PPUSH
// begin enable ;
14062: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14063: LD_ADDR_VAR 0 1
14067: PUSH
14068: LD_INT 22
14070: PUSH
14071: LD_OWVAR 2
14075: PUSH
14076: EMPTY
14077: LIST
14078: LIST
14079: PUSH
14080: LD_INT 61
14082: PUSH
14083: EMPTY
14084: LIST
14085: PUSH
14086: LD_INT 33
14088: PUSH
14089: LD_INT 2
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: LIST
14100: PPUSH
14101: CALL_OW 69
14105: ST_TO_ADDR
// if not tmp then
14106: LD_VAR 0 1
14110: NOT
14111: IFFALSE 14115
// exit ;
14113: GO 14152
// for i in tmp do
14115: LD_ADDR_VAR 0 2
14119: PUSH
14120: LD_VAR 0 1
14124: PUSH
14125: FOR_IN
14126: IFFALSE 14150
// if IsControledBy ( i ) then
14128: LD_VAR 0 2
14132: PPUSH
14133: CALL_OW 312
14137: IFFALSE 14148
// ComUnlink ( i ) ;
14139: LD_VAR 0 2
14143: PPUSH
14144: CALL_OW 136
14148: GO 14125
14150: POP
14151: POP
// end ;
14152: PPOPN 2
14154: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
14155: LD_EXP 26
14159: PUSH
14160: LD_EXP 57
14164: AND
14165: IFFALSE 14299
14167: GO 14169
14169: DISABLE
14170: LD_INT 0
14172: PPUSH
14173: PPUSH
// begin ToLua ( displayPowell(); ) ;
14174: LD_STRING displayPowell();
14176: PPUSH
14177: CALL_OW 559
// uc_side := 0 ;
14181: LD_ADDR_OWVAR 20
14185: PUSH
14186: LD_INT 0
14188: ST_TO_ADDR
// uc_nation := 2 ;
14189: LD_ADDR_OWVAR 21
14193: PUSH
14194: LD_INT 2
14196: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
14197: LD_ADDR_OWVAR 37
14201: PUSH
14202: LD_INT 14
14204: ST_TO_ADDR
// vc_engine := engine_siberite ;
14205: LD_ADDR_OWVAR 39
14209: PUSH
14210: LD_INT 3
14212: ST_TO_ADDR
// vc_control := control_apeman ;
14213: LD_ADDR_OWVAR 38
14217: PUSH
14218: LD_INT 5
14220: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
14221: LD_ADDR_OWVAR 40
14225: PUSH
14226: LD_INT 29
14228: ST_TO_ADDR
// un := CreateVehicle ;
14229: LD_ADDR_VAR 0 2
14233: PUSH
14234: CALL_OW 45
14238: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14239: LD_VAR 0 2
14243: PPUSH
14244: LD_INT 1
14246: PPUSH
14247: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
14251: LD_INT 35
14253: PPUSH
14254: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14258: LD_VAR 0 2
14262: PPUSH
14263: LD_OWVAR 3
14267: PUSH
14268: LD_VAR 0 2
14272: DIFF
14273: PPUSH
14274: LD_VAR 0 2
14278: PPUSH
14279: CALL_OW 74
14283: PPUSH
14284: CALL_OW 115
// until IsOk ( un ) ;
14288: LD_VAR 0 2
14292: PPUSH
14293: CALL_OW 302
14297: IFFALSE 14251
// end ;
14299: PPOPN 2
14301: END
// every 0 0$1 trigger StreamModeActive and sStu do
14302: LD_EXP 26
14306: PUSH
14307: LD_EXP 65
14311: AND
14312: IFFALSE 14324
14314: GO 14316
14316: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14317: LD_STRING displayStucuk();
14319: PPUSH
14320: CALL_OW 559
// end ;
14324: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14325: LD_EXP 26
14329: PUSH
14330: LD_EXP 58
14334: AND
14335: IFFALSE 14476
14337: GO 14339
14339: DISABLE
14340: LD_INT 0
14342: PPUSH
14343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14344: LD_ADDR_VAR 0 2
14348: PUSH
14349: LD_INT 22
14351: PUSH
14352: LD_OWVAR 2
14356: PUSH
14357: EMPTY
14358: LIST
14359: LIST
14360: PUSH
14361: LD_INT 21
14363: PUSH
14364: LD_INT 1
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: PUSH
14371: EMPTY
14372: LIST
14373: LIST
14374: PPUSH
14375: CALL_OW 69
14379: ST_TO_ADDR
// if not tmp then
14380: LD_VAR 0 2
14384: NOT
14385: IFFALSE 14389
// exit ;
14387: GO 14476
// un := tmp [ rand ( 1 , tmp ) ] ;
14389: LD_ADDR_VAR 0 1
14393: PUSH
14394: LD_VAR 0 2
14398: PUSH
14399: LD_INT 1
14401: PPUSH
14402: LD_VAR 0 2
14406: PPUSH
14407: CALL_OW 12
14411: ARRAY
14412: ST_TO_ADDR
// SetSide ( un , 0 ) ;
14413: LD_VAR 0 1
14417: PPUSH
14418: LD_INT 0
14420: PPUSH
14421: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14425: LD_VAR 0 1
14429: PPUSH
14430: LD_OWVAR 3
14434: PUSH
14435: LD_VAR 0 1
14439: DIFF
14440: PPUSH
14441: LD_VAR 0 1
14445: PPUSH
14446: CALL_OW 74
14450: PPUSH
14451: CALL_OW 115
// wait ( 0 0$20 ) ;
14455: LD_INT 700
14457: PPUSH
14458: CALL_OW 67
// SetSide ( un , your_side ) ;
14462: LD_VAR 0 1
14466: PPUSH
14467: LD_OWVAR 2
14471: PPUSH
14472: CALL_OW 235
// end ;
14476: PPOPN 2
14478: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
14479: LD_EXP 26
14483: PUSH
14484: LD_EXP 59
14488: AND
14489: IFFALSE 14595
14491: GO 14493
14493: DISABLE
14494: LD_INT 0
14496: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14497: LD_ADDR_VAR 0 1
14501: PUSH
14502: LD_INT 22
14504: PUSH
14505: LD_OWVAR 2
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: PUSH
14514: LD_INT 2
14516: PUSH
14517: LD_INT 30
14519: PUSH
14520: LD_INT 0
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: LD_INT 30
14529: PUSH
14530: LD_INT 1
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: EMPTY
14538: LIST
14539: LIST
14540: LIST
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: PPUSH
14546: CALL_OW 69
14550: ST_TO_ADDR
// if not depot then
14551: LD_VAR 0 1
14555: NOT
14556: IFFALSE 14560
// exit ;
14558: GO 14595
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
14560: LD_VAR 0 1
14564: PUSH
14565: LD_INT 1
14567: ARRAY
14568: PPUSH
14569: CALL_OW 250
14573: PPUSH
14574: LD_VAR 0 1
14578: PUSH
14579: LD_INT 1
14581: ARRAY
14582: PPUSH
14583: CALL_OW 251
14587: PPUSH
14588: LD_INT 70
14590: PPUSH
14591: CALL_OW 495
// end ;
14595: PPOPN 1
14597: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
14598: LD_EXP 26
14602: PUSH
14603: LD_EXP 60
14607: AND
14608: IFFALSE 14819
14610: GO 14612
14612: DISABLE
14613: LD_INT 0
14615: PPUSH
14616: PPUSH
14617: PPUSH
14618: PPUSH
14619: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14620: LD_ADDR_VAR 0 5
14624: PUSH
14625: LD_INT 22
14627: PUSH
14628: LD_OWVAR 2
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PPUSH
14651: CALL_OW 69
14655: ST_TO_ADDR
// if not tmp then
14656: LD_VAR 0 5
14660: NOT
14661: IFFALSE 14665
// exit ;
14663: GO 14819
// for i in tmp do
14665: LD_ADDR_VAR 0 1
14669: PUSH
14670: LD_VAR 0 5
14674: PUSH
14675: FOR_IN
14676: IFFALSE 14817
// begin d := rand ( 0 , 5 ) ;
14678: LD_ADDR_VAR 0 4
14682: PUSH
14683: LD_INT 0
14685: PPUSH
14686: LD_INT 5
14688: PPUSH
14689: CALL_OW 12
14693: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
14694: LD_ADDR_VAR 0 2
14698: PUSH
14699: LD_VAR 0 1
14703: PPUSH
14704: CALL_OW 250
14708: PPUSH
14709: LD_VAR 0 4
14713: PPUSH
14714: LD_INT 3
14716: PPUSH
14717: LD_INT 12
14719: PPUSH
14720: CALL_OW 12
14724: PPUSH
14725: CALL_OW 272
14729: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
14730: LD_ADDR_VAR 0 3
14734: PUSH
14735: LD_VAR 0 1
14739: PPUSH
14740: CALL_OW 251
14744: PPUSH
14745: LD_VAR 0 4
14749: PPUSH
14750: LD_INT 3
14752: PPUSH
14753: LD_INT 12
14755: PPUSH
14756: CALL_OW 12
14760: PPUSH
14761: CALL_OW 273
14765: ST_TO_ADDR
// if ValidHex ( x , y ) then
14766: LD_VAR 0 2
14770: PPUSH
14771: LD_VAR 0 3
14775: PPUSH
14776: CALL_OW 488
14780: IFFALSE 14815
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
14782: LD_VAR 0 1
14786: PPUSH
14787: LD_VAR 0 2
14791: PPUSH
14792: LD_VAR 0 3
14796: PPUSH
14797: LD_INT 3
14799: PPUSH
14800: LD_INT 6
14802: PPUSH
14803: CALL_OW 12
14807: PPUSH
14808: LD_INT 1
14810: PPUSH
14811: CALL_OW 483
// end ;
14815: GO 14675
14817: POP
14818: POP
// end ;
14819: PPOPN 5
14821: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
14822: LD_EXP 26
14826: PUSH
14827: LD_EXP 61
14831: AND
14832: IFFALSE 14926
14834: GO 14836
14836: DISABLE
14837: LD_INT 0
14839: PPUSH
14840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
14841: LD_ADDR_VAR 0 2
14845: PUSH
14846: LD_INT 22
14848: PUSH
14849: LD_OWVAR 2
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: PUSH
14858: LD_INT 32
14860: PUSH
14861: LD_INT 1
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 2
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 69
14887: ST_TO_ADDR
// if not tmp then
14888: LD_VAR 0 2
14892: NOT
14893: IFFALSE 14897
// exit ;
14895: GO 14926
// for i in tmp do
14897: LD_ADDR_VAR 0 1
14901: PUSH
14902: LD_VAR 0 2
14906: PUSH
14907: FOR_IN
14908: IFFALSE 14924
// SetFuel ( i , 0 ) ;
14910: LD_VAR 0 1
14914: PPUSH
14915: LD_INT 0
14917: PPUSH
14918: CALL_OW 240
14922: GO 14907
14924: POP
14925: POP
// end ;
14926: PPOPN 2
14928: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
14929: LD_EXP 26
14933: PUSH
14934: LD_EXP 62
14938: AND
14939: IFFALSE 15005
14941: GO 14943
14943: DISABLE
14944: LD_INT 0
14946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14947: LD_ADDR_VAR 0 1
14951: PUSH
14952: LD_INT 22
14954: PUSH
14955: LD_OWVAR 2
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: PUSH
14964: LD_INT 30
14966: PUSH
14967: LD_INT 29
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: PPUSH
14978: CALL_OW 69
14982: ST_TO_ADDR
// if not tmp then
14983: LD_VAR 0 1
14987: NOT
14988: IFFALSE 14992
// exit ;
14990: GO 15005
// DestroyUnit ( tmp [ 1 ] ) ;
14992: LD_VAR 0 1
14996: PUSH
14997: LD_INT 1
14999: ARRAY
15000: PPUSH
15001: CALL_OW 65
// end ;
15005: PPOPN 1
15007: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15008: LD_EXP 26
15012: PUSH
15013: LD_EXP 64
15017: AND
15018: IFFALSE 15147
15020: GO 15022
15022: DISABLE
15023: LD_INT 0
15025: PPUSH
// begin uc_side := 0 ;
15026: LD_ADDR_OWVAR 20
15030: PUSH
15031: LD_INT 0
15033: ST_TO_ADDR
// uc_nation := nation_arabian ;
15034: LD_ADDR_OWVAR 21
15038: PUSH
15039: LD_INT 2
15041: ST_TO_ADDR
// hc_gallery :=  ;
15042: LD_ADDR_OWVAR 33
15046: PUSH
15047: LD_STRING 
15049: ST_TO_ADDR
// hc_name :=  ;
15050: LD_ADDR_OWVAR 26
15054: PUSH
15055: LD_STRING 
15057: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
15058: LD_INT 1
15060: PPUSH
15061: LD_INT 11
15063: PPUSH
15064: LD_INT 10
15066: PPUSH
15067: CALL_OW 380
// un := CreateHuman ;
15071: LD_ADDR_VAR 0 1
15075: PUSH
15076: CALL_OW 44
15080: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15081: LD_VAR 0 1
15085: PPUSH
15086: LD_INT 1
15088: PPUSH
15089: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15093: LD_INT 35
15095: PPUSH
15096: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15100: LD_VAR 0 1
15104: PPUSH
15105: LD_INT 22
15107: PUSH
15108: LD_OWVAR 2
15112: PUSH
15113: EMPTY
15114: LIST
15115: LIST
15116: PPUSH
15117: CALL_OW 69
15121: PPUSH
15122: LD_VAR 0 1
15126: PPUSH
15127: CALL_OW 74
15131: PPUSH
15132: CALL_OW 115
// until IsDead ( un ) ;
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 301
15145: IFFALSE 15093
// end ;
15147: PPOPN 1
15149: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
15150: LD_EXP 26
15154: PUSH
15155: LD_EXP 66
15159: AND
15160: IFFALSE 15172
15162: GO 15164
15164: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
15165: LD_STRING earthquake(getX(game), 0, 32)
15167: PPUSH
15168: CALL_OW 559
15172: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
15173: LD_EXP 26
15177: PUSH
15178: LD_EXP 67
15182: AND
15183: IFFALSE 15274
15185: GO 15187
15187: DISABLE
15188: LD_INT 0
15190: PPUSH
// begin enable ;
15191: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
15192: LD_ADDR_VAR 0 1
15196: PUSH
15197: LD_INT 22
15199: PUSH
15200: LD_OWVAR 2
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PUSH
15209: LD_INT 21
15211: PUSH
15212: LD_INT 2
15214: PUSH
15215: EMPTY
15216: LIST
15217: LIST
15218: PUSH
15219: LD_INT 33
15221: PUSH
15222: LD_INT 3
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PUSH
15229: EMPTY
15230: LIST
15231: LIST
15232: LIST
15233: PPUSH
15234: CALL_OW 69
15238: ST_TO_ADDR
// if not tmp then
15239: LD_VAR 0 1
15243: NOT
15244: IFFALSE 15248
// exit ;
15246: GO 15274
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
15248: LD_VAR 0 1
15252: PUSH
15253: LD_INT 1
15255: PPUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 12
15265: ARRAY
15266: PPUSH
15267: LD_INT 1
15269: PPUSH
15270: CALL_OW 234
// end ;
15274: PPOPN 1
15276: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
15277: LD_EXP 26
15281: PUSH
15282: LD_EXP 68
15286: AND
15287: IFFALSE 15428
15289: GO 15291
15291: DISABLE
15292: LD_INT 0
15294: PPUSH
15295: PPUSH
15296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15297: LD_ADDR_VAR 0 3
15301: PUSH
15302: LD_INT 22
15304: PUSH
15305: LD_OWVAR 2
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 25
15316: PUSH
15317: LD_INT 1
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PPUSH
15328: CALL_OW 69
15332: ST_TO_ADDR
// if not tmp then
15333: LD_VAR 0 3
15337: NOT
15338: IFFALSE 15342
// exit ;
15340: GO 15428
// un := tmp [ rand ( 1 , tmp ) ] ;
15342: LD_ADDR_VAR 0 2
15346: PUSH
15347: LD_VAR 0 3
15351: PUSH
15352: LD_INT 1
15354: PPUSH
15355: LD_VAR 0 3
15359: PPUSH
15360: CALL_OW 12
15364: ARRAY
15365: ST_TO_ADDR
// if Crawls ( un ) then
15366: LD_VAR 0 2
15370: PPUSH
15371: CALL_OW 318
15375: IFFALSE 15386
// ComWalk ( un ) ;
15377: LD_VAR 0 2
15381: PPUSH
15382: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
15386: LD_VAR 0 2
15390: PPUSH
15391: LD_INT 9
15393: PPUSH
15394: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
15398: LD_INT 28
15400: PPUSH
15401: LD_OWVAR 2
15405: PPUSH
15406: LD_INT 2
15408: PPUSH
15409: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
15413: LD_INT 29
15415: PPUSH
15416: LD_OWVAR 2
15420: PPUSH
15421: LD_INT 2
15423: PPUSH
15424: CALL_OW 322
// end ;
15428: PPOPN 3
15430: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
15431: LD_EXP 26
15435: PUSH
15436: LD_EXP 69
15440: AND
15441: IFFALSE 15552
15443: GO 15445
15445: DISABLE
15446: LD_INT 0
15448: PPUSH
15449: PPUSH
15450: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15451: LD_ADDR_VAR 0 3
15455: PUSH
15456: LD_INT 22
15458: PUSH
15459: LD_OWVAR 2
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PUSH
15468: LD_INT 25
15470: PUSH
15471: LD_INT 1
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 69
15486: ST_TO_ADDR
// if not tmp then
15487: LD_VAR 0 3
15491: NOT
15492: IFFALSE 15496
// exit ;
15494: GO 15552
// un := tmp [ rand ( 1 , tmp ) ] ;
15496: LD_ADDR_VAR 0 2
15500: PUSH
15501: LD_VAR 0 3
15505: PUSH
15506: LD_INT 1
15508: PPUSH
15509: LD_VAR 0 3
15513: PPUSH
15514: CALL_OW 12
15518: ARRAY
15519: ST_TO_ADDR
// if Crawls ( un ) then
15520: LD_VAR 0 2
15524: PPUSH
15525: CALL_OW 318
15529: IFFALSE 15540
// ComWalk ( un ) ;
15531: LD_VAR 0 2
15535: PPUSH
15536: CALL_OW 138
// SetClass ( un , class_mortar ) ;
15540: LD_VAR 0 2
15544: PPUSH
15545: LD_INT 8
15547: PPUSH
15548: CALL_OW 336
// end ;
15552: PPOPN 3
15554: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
15555: LD_EXP 26
15559: PUSH
15560: LD_EXP 70
15564: AND
15565: IFFALSE 15709
15567: GO 15569
15569: DISABLE
15570: LD_INT 0
15572: PPUSH
15573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
15574: LD_ADDR_VAR 0 2
15578: PUSH
15579: LD_INT 22
15581: PUSH
15582: LD_OWVAR 2
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: PUSH
15591: LD_INT 21
15593: PUSH
15594: LD_INT 2
15596: PUSH
15597: EMPTY
15598: LIST
15599: LIST
15600: PUSH
15601: LD_INT 2
15603: PUSH
15604: LD_INT 34
15606: PUSH
15607: LD_INT 12
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PUSH
15614: LD_INT 34
15616: PUSH
15617: LD_INT 51
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PUSH
15624: LD_INT 34
15626: PUSH
15627: LD_INT 32
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: PPUSH
15645: CALL_OW 69
15649: ST_TO_ADDR
// if not tmp then
15650: LD_VAR 0 2
15654: NOT
15655: IFFALSE 15659
// exit ;
15657: GO 15709
// for i in tmp do
15659: LD_ADDR_VAR 0 1
15663: PUSH
15664: LD_VAR 0 2
15668: PUSH
15669: FOR_IN
15670: IFFALSE 15707
// if GetCargo ( i , mat_artifact ) = 0 then
15672: LD_VAR 0 1
15676: PPUSH
15677: LD_INT 4
15679: PPUSH
15680: CALL_OW 289
15684: PUSH
15685: LD_INT 0
15687: EQUAL
15688: IFFALSE 15705
// SetCargo ( i , mat_siberit , 100 ) ;
15690: LD_VAR 0 1
15694: PPUSH
15695: LD_INT 3
15697: PPUSH
15698: LD_INT 100
15700: PPUSH
15701: CALL_OW 290
15705: GO 15669
15707: POP
15708: POP
// end ;
15709: PPOPN 2
15711: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
15712: LD_EXP 26
15716: PUSH
15717: LD_EXP 71
15721: AND
15722: IFFALSE 15875
15724: GO 15726
15726: DISABLE
15727: LD_INT 0
15729: PPUSH
15730: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
15731: LD_ADDR_VAR 0 2
15735: PUSH
15736: LD_INT 22
15738: PUSH
15739: LD_OWVAR 2
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: PPUSH
15748: CALL_OW 69
15752: ST_TO_ADDR
// if not tmp then
15753: LD_VAR 0 2
15757: NOT
15758: IFFALSE 15762
// exit ;
15760: GO 15875
// for i := 1 to 2 do
15762: LD_ADDR_VAR 0 1
15766: PUSH
15767: DOUBLE
15768: LD_INT 1
15770: DEC
15771: ST_TO_ADDR
15772: LD_INT 2
15774: PUSH
15775: FOR_TO
15776: IFFALSE 15873
// begin uc_side := your_side ;
15778: LD_ADDR_OWVAR 20
15782: PUSH
15783: LD_OWVAR 2
15787: ST_TO_ADDR
// uc_nation := nation_american ;
15788: LD_ADDR_OWVAR 21
15792: PUSH
15793: LD_INT 1
15795: ST_TO_ADDR
// vc_chassis := us_morphling ;
15796: LD_ADDR_OWVAR 37
15800: PUSH
15801: LD_INT 5
15803: ST_TO_ADDR
// vc_engine := engine_siberite ;
15804: LD_ADDR_OWVAR 39
15808: PUSH
15809: LD_INT 3
15811: ST_TO_ADDR
// vc_control := control_computer ;
15812: LD_ADDR_OWVAR 38
15816: PUSH
15817: LD_INT 3
15819: ST_TO_ADDR
// vc_weapon := us_double_laser ;
15820: LD_ADDR_OWVAR 40
15824: PUSH
15825: LD_INT 10
15827: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
15828: CALL_OW 45
15832: PPUSH
15833: LD_VAR 0 2
15837: PUSH
15838: LD_INT 1
15840: ARRAY
15841: PPUSH
15842: CALL_OW 250
15846: PPUSH
15847: LD_VAR 0 2
15851: PUSH
15852: LD_INT 1
15854: ARRAY
15855: PPUSH
15856: CALL_OW 251
15860: PPUSH
15861: LD_INT 12
15863: PPUSH
15864: LD_INT 1
15866: PPUSH
15867: CALL_OW 50
// end ;
15871: GO 15775
15873: POP
15874: POP
// end ;
15875: PPOPN 2
15877: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
15878: LD_EXP 26
15882: PUSH
15883: LD_EXP 72
15887: AND
15888: IFFALSE 16110
15890: GO 15892
15892: DISABLE
15893: LD_INT 0
15895: PPUSH
15896: PPUSH
15897: PPUSH
15898: PPUSH
15899: PPUSH
15900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15901: LD_ADDR_VAR 0 6
15905: PUSH
15906: LD_INT 22
15908: PUSH
15909: LD_OWVAR 2
15913: PUSH
15914: EMPTY
15915: LIST
15916: LIST
15917: PUSH
15918: LD_INT 21
15920: PUSH
15921: LD_INT 1
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PUSH
15928: LD_INT 3
15930: PUSH
15931: LD_INT 23
15933: PUSH
15934: LD_INT 0
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: LIST
15949: PPUSH
15950: CALL_OW 69
15954: ST_TO_ADDR
// if not tmp then
15955: LD_VAR 0 6
15959: NOT
15960: IFFALSE 15964
// exit ;
15962: GO 16110
// s1 := rand ( 1 , 4 ) ;
15964: LD_ADDR_VAR 0 2
15968: PUSH
15969: LD_INT 1
15971: PPUSH
15972: LD_INT 4
15974: PPUSH
15975: CALL_OW 12
15979: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
15980: LD_ADDR_VAR 0 4
15984: PUSH
15985: LD_VAR 0 6
15989: PUSH
15990: LD_INT 1
15992: ARRAY
15993: PPUSH
15994: LD_VAR 0 2
15998: PPUSH
15999: CALL_OW 259
16003: ST_TO_ADDR
// if s1 = 1 then
16004: LD_VAR 0 2
16008: PUSH
16009: LD_INT 1
16011: EQUAL
16012: IFFALSE 16032
// s2 := rand ( 2 , 4 ) else
16014: LD_ADDR_VAR 0 3
16018: PUSH
16019: LD_INT 2
16021: PPUSH
16022: LD_INT 4
16024: PPUSH
16025: CALL_OW 12
16029: ST_TO_ADDR
16030: GO 16040
// s2 := 1 ;
16032: LD_ADDR_VAR 0 3
16036: PUSH
16037: LD_INT 1
16039: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
16040: LD_ADDR_VAR 0 5
16044: PUSH
16045: LD_VAR 0 6
16049: PUSH
16050: LD_INT 1
16052: ARRAY
16053: PPUSH
16054: LD_VAR 0 3
16058: PPUSH
16059: CALL_OW 259
16063: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
16064: LD_VAR 0 6
16068: PUSH
16069: LD_INT 1
16071: ARRAY
16072: PPUSH
16073: LD_VAR 0 2
16077: PPUSH
16078: LD_VAR 0 5
16082: PPUSH
16083: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
16087: LD_VAR 0 6
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: LD_VAR 0 3
16100: PPUSH
16101: LD_VAR 0 4
16105: PPUSH
16106: CALL_OW 237
// end ;
16110: PPOPN 6
16112: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
16113: LD_EXP 26
16117: PUSH
16118: LD_EXP 73
16122: AND
16123: IFFALSE 16202
16125: GO 16127
16127: DISABLE
16128: LD_INT 0
16130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
16131: LD_ADDR_VAR 0 1
16135: PUSH
16136: LD_INT 22
16138: PUSH
16139: LD_OWVAR 2
16143: PUSH
16144: EMPTY
16145: LIST
16146: LIST
16147: PUSH
16148: LD_INT 30
16150: PUSH
16151: LD_INT 3
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: PPUSH
16162: CALL_OW 69
16166: ST_TO_ADDR
// if not tmp then
16167: LD_VAR 0 1
16171: NOT
16172: IFFALSE 16176
// exit ;
16174: GO 16202
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16176: LD_VAR 0 1
16180: PUSH
16181: LD_INT 1
16183: PPUSH
16184: LD_VAR 0 1
16188: PPUSH
16189: CALL_OW 12
16193: ARRAY
16194: PPUSH
16195: LD_INT 1
16197: PPUSH
16198: CALL_OW 234
// end ;
16202: PPOPN 1
16204: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
16205: LD_EXP 26
16209: PUSH
16210: LD_EXP 74
16214: AND
16215: IFFALSE 16327
16217: GO 16219
16219: DISABLE
16220: LD_INT 0
16222: PPUSH
16223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
16224: LD_ADDR_VAR 0 2
16228: PUSH
16229: LD_INT 22
16231: PUSH
16232: LD_OWVAR 2
16236: PUSH
16237: EMPTY
16238: LIST
16239: LIST
16240: PUSH
16241: LD_INT 2
16243: PUSH
16244: LD_INT 30
16246: PUSH
16247: LD_INT 27
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: PUSH
16254: LD_INT 30
16256: PUSH
16257: LD_INT 26
16259: PUSH
16260: EMPTY
16261: LIST
16262: LIST
16263: PUSH
16264: LD_INT 30
16266: PUSH
16267: LD_INT 28
16269: PUSH
16270: EMPTY
16271: LIST
16272: LIST
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: LIST
16278: LIST
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PPUSH
16284: CALL_OW 69
16288: ST_TO_ADDR
// if not tmp then
16289: LD_VAR 0 2
16293: NOT
16294: IFFALSE 16298
// exit ;
16296: GO 16327
// for i in tmp do
16298: LD_ADDR_VAR 0 1
16302: PUSH
16303: LD_VAR 0 2
16307: PUSH
16308: FOR_IN
16309: IFFALSE 16325
// SetLives ( i , 1 ) ;
16311: LD_VAR 0 1
16315: PPUSH
16316: LD_INT 1
16318: PPUSH
16319: CALL_OW 234
16323: GO 16308
16325: POP
16326: POP
// end ;
16327: PPOPN 2
16329: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
16330: LD_EXP 26
16334: PUSH
16335: LD_EXP 75
16339: AND
16340: IFFALSE 16610
16342: GO 16344
16344: DISABLE
16345: LD_INT 0
16347: PPUSH
16348: PPUSH
16349: PPUSH
// begin i := rand ( 1 , 7 ) ;
16350: LD_ADDR_VAR 0 1
16354: PUSH
16355: LD_INT 1
16357: PPUSH
16358: LD_INT 7
16360: PPUSH
16361: CALL_OW 12
16365: ST_TO_ADDR
// case i of 1 :
16366: LD_VAR 0 1
16370: PUSH
16371: LD_INT 1
16373: DOUBLE
16374: EQUAL
16375: IFTRUE 16379
16377: GO 16389
16379: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
16380: LD_STRING earthquake(getX(game), 0, 32)
16382: PPUSH
16383: CALL_OW 559
16387: GO 16610
16389: LD_INT 2
16391: DOUBLE
16392: EQUAL
16393: IFTRUE 16397
16395: GO 16407
16397: POP
// ToLua ( displayStucuk(); ) ; 3 :
16398: LD_STRING displayStucuk();
16400: PPUSH
16401: CALL_OW 559
16405: GO 16610
16407: LD_INT 3
16409: DOUBLE
16410: EQUAL
16411: IFTRUE 16415
16413: GO 16519
16415: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16416: LD_ADDR_VAR 0 2
16420: PUSH
16421: LD_INT 22
16423: PUSH
16424: LD_OWVAR 2
16428: PUSH
16429: EMPTY
16430: LIST
16431: LIST
16432: PUSH
16433: LD_INT 25
16435: PUSH
16436: LD_INT 1
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PUSH
16443: EMPTY
16444: LIST
16445: LIST
16446: PPUSH
16447: CALL_OW 69
16451: ST_TO_ADDR
// if not tmp then
16452: LD_VAR 0 2
16456: NOT
16457: IFFALSE 16461
// exit ;
16459: GO 16610
// un := tmp [ rand ( 1 , tmp ) ] ;
16461: LD_ADDR_VAR 0 3
16465: PUSH
16466: LD_VAR 0 2
16470: PUSH
16471: LD_INT 1
16473: PPUSH
16474: LD_VAR 0 2
16478: PPUSH
16479: CALL_OW 12
16483: ARRAY
16484: ST_TO_ADDR
// if Crawls ( un ) then
16485: LD_VAR 0 3
16489: PPUSH
16490: CALL_OW 318
16494: IFFALSE 16505
// ComWalk ( un ) ;
16496: LD_VAR 0 3
16500: PPUSH
16501: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16505: LD_VAR 0 3
16509: PPUSH
16510: LD_INT 8
16512: PPUSH
16513: CALL_OW 336
// end ; 4 :
16517: GO 16610
16519: LD_INT 4
16521: DOUBLE
16522: EQUAL
16523: IFTRUE 16527
16525: GO 16588
16527: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16528: LD_ADDR_VAR 0 2
16532: PUSH
16533: LD_INT 22
16535: PUSH
16536: LD_OWVAR 2
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: LD_INT 30
16547: PUSH
16548: LD_INT 29
16550: PUSH
16551: EMPTY
16552: LIST
16553: LIST
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PPUSH
16559: CALL_OW 69
16563: ST_TO_ADDR
// if not tmp then
16564: LD_VAR 0 2
16568: NOT
16569: IFFALSE 16573
// exit ;
16571: GO 16610
// DestroyUnit ( tmp [ 1 ] ) ;
16573: LD_VAR 0 2
16577: PUSH
16578: LD_INT 1
16580: ARRAY
16581: PPUSH
16582: CALL_OW 65
// end ; 5 .. 7 :
16586: GO 16610
16588: LD_INT 5
16590: DOUBLE
16591: GREATEREQUAL
16592: IFFALSE 16600
16594: LD_INT 7
16596: DOUBLE
16597: LESSEQUAL
16598: IFTRUE 16602
16600: GO 16609
16602: POP
// StreamSibBomb ; end ;
16603: CALL 12904 0 0
16607: GO 16610
16609: POP
// end ;
16610: PPOPN 3
16612: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
16613: LD_EXP 26
16617: PUSH
16618: LD_EXP 76
16622: AND
16623: IFFALSE 16779
16625: GO 16627
16627: DISABLE
16628: LD_INT 0
16630: PPUSH
16631: PPUSH
16632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
16633: LD_ADDR_VAR 0 2
16637: PUSH
16638: LD_INT 81
16640: PUSH
16641: LD_OWVAR 2
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: PUSH
16650: LD_INT 2
16652: PUSH
16653: LD_INT 21
16655: PUSH
16656: LD_INT 1
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: PUSH
16663: LD_INT 21
16665: PUSH
16666: LD_INT 2
16668: PUSH
16669: EMPTY
16670: LIST
16671: LIST
16672: PUSH
16673: EMPTY
16674: LIST
16675: LIST
16676: LIST
16677: PUSH
16678: EMPTY
16679: LIST
16680: LIST
16681: PPUSH
16682: CALL_OW 69
16686: ST_TO_ADDR
// if not tmp then
16687: LD_VAR 0 2
16691: NOT
16692: IFFALSE 16696
// exit ;
16694: GO 16779
// p := 0 ;
16696: LD_ADDR_VAR 0 3
16700: PUSH
16701: LD_INT 0
16703: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
16704: LD_INT 35
16706: PPUSH
16707: CALL_OW 67
// p := p + 1 ;
16711: LD_ADDR_VAR 0 3
16715: PUSH
16716: LD_VAR 0 3
16720: PUSH
16721: LD_INT 1
16723: PLUS
16724: ST_TO_ADDR
// for i in tmp do
16725: LD_ADDR_VAR 0 1
16729: PUSH
16730: LD_VAR 0 2
16734: PUSH
16735: FOR_IN
16736: IFFALSE 16767
// if GetLives ( i ) < 1000 then
16738: LD_VAR 0 1
16742: PPUSH
16743: CALL_OW 256
16747: PUSH
16748: LD_INT 1000
16750: LESS
16751: IFFALSE 16765
// SetLives ( i , 1000 ) ;
16753: LD_VAR 0 1
16757: PPUSH
16758: LD_INT 1000
16760: PPUSH
16761: CALL_OW 234
16765: GO 16735
16767: POP
16768: POP
// until p > 20 ;
16769: LD_VAR 0 3
16773: PUSH
16774: LD_INT 20
16776: GREATER
16777: IFFALSE 16704
// end ;
16779: PPOPN 3
16781: END
// every 0 0$1 trigger StreamModeActive and sTime do
16782: LD_EXP 26
16786: PUSH
16787: LD_EXP 77
16791: AND
16792: IFFALSE 16827
16794: GO 16796
16796: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
16797: LD_INT 28
16799: PPUSH
16800: LD_OWVAR 2
16804: PPUSH
16805: LD_INT 2
16807: PPUSH
16808: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
16812: LD_INT 30
16814: PPUSH
16815: LD_OWVAR 2
16819: PPUSH
16820: LD_INT 2
16822: PPUSH
16823: CALL_OW 322
// end ;
16827: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
16828: LD_EXP 26
16832: PUSH
16833: LD_EXP 78
16837: AND
16838: IFFALSE 16959
16840: GO 16842
16842: DISABLE
16843: LD_INT 0
16845: PPUSH
16846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16847: LD_ADDR_VAR 0 2
16851: PUSH
16852: LD_INT 22
16854: PUSH
16855: LD_OWVAR 2
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PUSH
16864: LD_INT 21
16866: PUSH
16867: LD_INT 1
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: PUSH
16874: LD_INT 3
16876: PUSH
16877: LD_INT 23
16879: PUSH
16880: LD_INT 0
16882: PUSH
16883: EMPTY
16884: LIST
16885: LIST
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: LIST
16895: PPUSH
16896: CALL_OW 69
16900: ST_TO_ADDR
// if not tmp then
16901: LD_VAR 0 2
16905: NOT
16906: IFFALSE 16910
// exit ;
16908: GO 16959
// for i in tmp do
16910: LD_ADDR_VAR 0 1
16914: PUSH
16915: LD_VAR 0 2
16919: PUSH
16920: FOR_IN
16921: IFFALSE 16957
// begin if Crawls ( i ) then
16923: LD_VAR 0 1
16927: PPUSH
16928: CALL_OW 318
16932: IFFALSE 16943
// ComWalk ( i ) ;
16934: LD_VAR 0 1
16938: PPUSH
16939: CALL_OW 138
// SetClass ( i , 2 ) ;
16943: LD_VAR 0 1
16947: PPUSH
16948: LD_INT 2
16950: PPUSH
16951: CALL_OW 336
// end ;
16955: GO 16920
16957: POP
16958: POP
// end ;
16959: PPOPN 2
16961: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
16962: LD_EXP 26
16966: PUSH
16967: LD_EXP 79
16971: AND
16972: IFFALSE 17177
16974: GO 16976
16976: DISABLE
16977: LD_INT 0
16979: PPUSH
16980: PPUSH
16981: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
16982: LD_OWVAR 2
16986: PPUSH
16987: LD_INT 9
16989: PPUSH
16990: LD_INT 1
16992: PPUSH
16993: LD_INT 1
16995: PPUSH
16996: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
17000: LD_INT 9
17002: PPUSH
17003: LD_OWVAR 2
17007: PPUSH
17008: CALL_OW 343
// hc_name := Dark Warrior ;
17012: LD_ADDR_OWVAR 26
17016: PUSH
17017: LD_STRING Dark Warrior
17019: ST_TO_ADDR
// hc_gallery :=  ;
17020: LD_ADDR_OWVAR 33
17024: PUSH
17025: LD_STRING 
17027: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
17028: LD_INT 1
17030: PPUSH
17031: LD_INT 1
17033: PPUSH
17034: LD_INT 10
17036: PPUSH
17037: CALL_OW 380
// un := CreateHuman ;
17041: LD_ADDR_VAR 0 3
17045: PUSH
17046: CALL_OW 44
17050: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17051: LD_VAR 0 3
17055: PPUSH
17056: LD_INT 1
17058: PPUSH
17059: CALL_OW 51
// p := 0 ;
17063: LD_ADDR_VAR 0 2
17067: PUSH
17068: LD_INT 0
17070: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17071: LD_INT 35
17073: PPUSH
17074: CALL_OW 67
// if GetLives ( un ) < 1000 then
17078: LD_VAR 0 3
17082: PPUSH
17083: CALL_OW 256
17087: PUSH
17088: LD_INT 1000
17090: LESS
17091: IFFALSE 17105
// SetLives ( un , 1000 ) ;
17093: LD_VAR 0 3
17097: PPUSH
17098: LD_INT 1000
17100: PPUSH
17101: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
17105: LD_VAR 0 3
17109: PPUSH
17110: LD_INT 81
17112: PUSH
17113: LD_OWVAR 2
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: PPUSH
17122: CALL_OW 69
17126: PPUSH
17127: LD_VAR 0 3
17131: PPUSH
17132: CALL_OW 74
17136: PPUSH
17137: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
17141: LD_VAR 0 2
17145: PUSH
17146: LD_INT 60
17148: GREATER
17149: PUSH
17150: LD_VAR 0 3
17154: PPUSH
17155: CALL_OW 301
17159: OR
17160: IFFALSE 17071
// if un then
17162: LD_VAR 0 3
17166: IFFALSE 17177
// RemoveUnit ( un ) ;
17168: LD_VAR 0 3
17172: PPUSH
17173: CALL_OW 64
// end ; end_of_file
17177: PPOPN 3
17179: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17180: LD_INT 0
17182: PPUSH
17183: PPUSH
17184: PPUSH
17185: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17186: LD_VAR 0 1
17190: PPUSH
17191: CALL_OW 264
17195: PUSH
17196: LD_EXP 84
17200: EQUAL
17201: IFFALSE 17273
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17203: LD_INT 68
17205: PPUSH
17206: LD_VAR 0 1
17210: PPUSH
17211: CALL_OW 255
17215: PPUSH
17216: CALL_OW 321
17220: PUSH
17221: LD_INT 2
17223: EQUAL
17224: IFFALSE 17236
// eff := 70 else
17226: LD_ADDR_VAR 0 6
17230: PUSH
17231: LD_INT 70
17233: ST_TO_ADDR
17234: GO 17244
// eff := 30 ;
17236: LD_ADDR_VAR 0 6
17240: PUSH
17241: LD_INT 30
17243: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17244: LD_VAR 0 1
17248: PPUSH
17249: CALL_OW 250
17253: PPUSH
17254: LD_VAR 0 1
17258: PPUSH
17259: CALL_OW 251
17263: PPUSH
17264: LD_VAR 0 6
17268: PPUSH
17269: CALL_OW 495
// end ; end ;
17273: LD_VAR 0 4
17277: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17278: LD_INT 0
17280: PPUSH
17281: PPUSH
17282: PPUSH
17283: PPUSH
17284: PPUSH
17285: PPUSH
// if cmd = 124 then
17286: LD_VAR 0 1
17290: PUSH
17291: LD_INT 124
17293: EQUAL
17294: IFFALSE 17500
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17296: LD_ADDR_VAR 0 5
17300: PUSH
17301: LD_INT 2
17303: PUSH
17304: LD_INT 34
17306: PUSH
17307: LD_INT 53
17309: PUSH
17310: EMPTY
17311: LIST
17312: LIST
17313: PUSH
17314: LD_INT 34
17316: PUSH
17317: LD_INT 14
17319: PUSH
17320: EMPTY
17321: LIST
17322: LIST
17323: PUSH
17324: EMPTY
17325: LIST
17326: LIST
17327: LIST
17328: PPUSH
17329: CALL_OW 69
17333: ST_TO_ADDR
// if not tmp then
17334: LD_VAR 0 5
17338: NOT
17339: IFFALSE 17343
// exit ;
17341: GO 17500
// for i in tmp do
17343: LD_ADDR_VAR 0 3
17347: PUSH
17348: LD_VAR 0 5
17352: PUSH
17353: FOR_IN
17354: IFFALSE 17498
// begin taskList := GetTaskList ( i ) ;
17356: LD_ADDR_VAR 0 6
17360: PUSH
17361: LD_VAR 0 3
17365: PPUSH
17366: CALL_OW 437
17370: ST_TO_ADDR
// if not taskList then
17371: LD_VAR 0 6
17375: NOT
17376: IFFALSE 17380
// continue ;
17378: GO 17353
// for j = 1 to taskList do
17380: LD_ADDR_VAR 0 4
17384: PUSH
17385: DOUBLE
17386: LD_INT 1
17388: DEC
17389: ST_TO_ADDR
17390: LD_VAR 0 6
17394: PUSH
17395: FOR_TO
17396: IFFALSE 17494
// if taskList [ j ] [ 1 ] = | then
17398: LD_VAR 0 6
17402: PUSH
17403: LD_VAR 0 4
17407: ARRAY
17408: PUSH
17409: LD_INT 1
17411: ARRAY
17412: PUSH
17413: LD_STRING |
17415: EQUAL
17416: IFFALSE 17492
// begin _taskList := Delete ( taskList , 1 ) ;
17418: LD_ADDR_VAR 0 7
17422: PUSH
17423: LD_VAR 0 6
17427: PPUSH
17428: LD_INT 1
17430: PPUSH
17431: CALL_OW 3
17435: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17436: LD_VAR 0 3
17440: PPUSH
17441: LD_VAR 0 7
17445: PPUSH
17446: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_VAR 0 6
17459: PUSH
17460: LD_VAR 0 4
17464: ARRAY
17465: PUSH
17466: LD_INT 2
17468: ARRAY
17469: PPUSH
17470: LD_VAR 0 6
17474: PUSH
17475: LD_VAR 0 4
17479: ARRAY
17480: PUSH
17481: LD_INT 3
17483: ARRAY
17484: PPUSH
17485: LD_INT 8
17487: PPUSH
17488: CALL 17505 0 4
// end ;
17492: GO 17395
17494: POP
17495: POP
// end ;
17496: GO 17353
17498: POP
17499: POP
// end ; end ;
17500: LD_VAR 0 2
17504: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17505: LD_INT 0
17507: PPUSH
17508: PPUSH
17509: PPUSH
17510: PPUSH
17511: PPUSH
17512: PPUSH
17513: PPUSH
17514: PPUSH
17515: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17516: LD_VAR 0 1
17520: NOT
17521: PUSH
17522: LD_VAR 0 2
17526: PPUSH
17527: LD_VAR 0 3
17531: PPUSH
17532: CALL_OW 488
17536: NOT
17537: OR
17538: PUSH
17539: LD_VAR 0 4
17543: NOT
17544: OR
17545: IFFALSE 17549
// exit ;
17547: GO 17889
// list := [ ] ;
17549: LD_ADDR_VAR 0 13
17553: PUSH
17554: EMPTY
17555: ST_TO_ADDR
// if x - r < 0 then
17556: LD_VAR 0 2
17560: PUSH
17561: LD_VAR 0 4
17565: MINUS
17566: PUSH
17567: LD_INT 0
17569: LESS
17570: IFFALSE 17582
// min_x := 0 else
17572: LD_ADDR_VAR 0 7
17576: PUSH
17577: LD_INT 0
17579: ST_TO_ADDR
17580: GO 17598
// min_x := x - r ;
17582: LD_ADDR_VAR 0 7
17586: PUSH
17587: LD_VAR 0 2
17591: PUSH
17592: LD_VAR 0 4
17596: MINUS
17597: ST_TO_ADDR
// if y - r < 0 then
17598: LD_VAR 0 3
17602: PUSH
17603: LD_VAR 0 4
17607: MINUS
17608: PUSH
17609: LD_INT 0
17611: LESS
17612: IFFALSE 17624
// min_y := 0 else
17614: LD_ADDR_VAR 0 8
17618: PUSH
17619: LD_INT 0
17621: ST_TO_ADDR
17622: GO 17640
// min_y := y - r ;
17624: LD_ADDR_VAR 0 8
17628: PUSH
17629: LD_VAR 0 3
17633: PUSH
17634: LD_VAR 0 4
17638: MINUS
17639: ST_TO_ADDR
// max_x := x + r ;
17640: LD_ADDR_VAR 0 9
17644: PUSH
17645: LD_VAR 0 2
17649: PUSH
17650: LD_VAR 0 4
17654: PLUS
17655: ST_TO_ADDR
// max_y := y + r ;
17656: LD_ADDR_VAR 0 10
17660: PUSH
17661: LD_VAR 0 3
17665: PUSH
17666: LD_VAR 0 4
17670: PLUS
17671: ST_TO_ADDR
// for _x = min_x to max_x do
17672: LD_ADDR_VAR 0 11
17676: PUSH
17677: DOUBLE
17678: LD_VAR 0 7
17682: DEC
17683: ST_TO_ADDR
17684: LD_VAR 0 9
17688: PUSH
17689: FOR_TO
17690: IFFALSE 17807
// for _y = min_y to max_y do
17692: LD_ADDR_VAR 0 12
17696: PUSH
17697: DOUBLE
17698: LD_VAR 0 8
17702: DEC
17703: ST_TO_ADDR
17704: LD_VAR 0 10
17708: PUSH
17709: FOR_TO
17710: IFFALSE 17803
// begin if not ValidHex ( _x , _y ) then
17712: LD_VAR 0 11
17716: PPUSH
17717: LD_VAR 0 12
17721: PPUSH
17722: CALL_OW 488
17726: NOT
17727: IFFALSE 17731
// continue ;
17729: GO 17709
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
17731: LD_VAR 0 11
17735: PPUSH
17736: LD_VAR 0 12
17740: PPUSH
17741: CALL_OW 351
17745: PUSH
17746: LD_VAR 0 11
17750: PPUSH
17751: LD_VAR 0 12
17755: PPUSH
17756: CALL_OW 554
17760: AND
17761: IFFALSE 17801
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
17763: LD_ADDR_VAR 0 13
17767: PUSH
17768: LD_VAR 0 13
17772: PPUSH
17773: LD_VAR 0 13
17777: PUSH
17778: LD_INT 1
17780: PLUS
17781: PPUSH
17782: LD_VAR 0 11
17786: PUSH
17787: LD_VAR 0 12
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: PPUSH
17796: CALL_OW 2
17800: ST_TO_ADDR
// end ;
17801: GO 17709
17803: POP
17804: POP
17805: GO 17689
17807: POP
17808: POP
// if not list then
17809: LD_VAR 0 13
17813: NOT
17814: IFFALSE 17818
// exit ;
17816: GO 17889
// for i in list do
17818: LD_ADDR_VAR 0 6
17822: PUSH
17823: LD_VAR 0 13
17827: PUSH
17828: FOR_IN
17829: IFFALSE 17887
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
17831: LD_VAR 0 1
17835: PPUSH
17836: LD_STRING M
17838: PUSH
17839: LD_VAR 0 6
17843: PUSH
17844: LD_INT 1
17846: ARRAY
17847: PUSH
17848: LD_VAR 0 6
17852: PUSH
17853: LD_INT 2
17855: ARRAY
17856: PUSH
17857: LD_INT 0
17859: PUSH
17860: LD_INT 0
17862: PUSH
17863: LD_INT 0
17865: PUSH
17866: LD_INT 0
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: LIST
17873: LIST
17874: LIST
17875: LIST
17876: LIST
17877: PUSH
17878: EMPTY
17879: LIST
17880: PPUSH
17881: CALL_OW 447
17885: GO 17828
17887: POP
17888: POP
// end ; end_of_file
17889: LD_VAR 0 5
17893: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17894: GO 17896
17896: DISABLE
// begin ru_radar := 98 ;
17897: LD_ADDR_EXP 80
17901: PUSH
17902: LD_INT 98
17904: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17905: LD_ADDR_EXP 81
17909: PUSH
17910: LD_INT 89
17912: ST_TO_ADDR
// us_hack := 99 ;
17913: LD_ADDR_EXP 82
17917: PUSH
17918: LD_INT 99
17920: ST_TO_ADDR
// us_artillery := 97 ;
17921: LD_ADDR_EXP 83
17925: PUSH
17926: LD_INT 97
17928: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17929: LD_ADDR_EXP 84
17933: PUSH
17934: LD_INT 91
17936: ST_TO_ADDR
// end ;
17937: END
