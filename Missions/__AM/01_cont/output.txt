// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 32 0 0
// InitAmerican ;
  15: CALL 915 0 0
// InitRussian ;
  19: CALL 1154 0 0
// DebugMode ;
  23: CALL 152 0 0
// Action ;
  27: CALL 2710 0 0
// end ;
  31: END
// export debug ; export mission_prefix ; export active_russian_dialog , bobby_in_squad , powell_contact , macmilan_use_radio , cyrus_in_squad , active_road_patrol , macmilan_in_trap , meta_action , end_mission , bobby_saved , cyrus_saved , send_troops_to_forest ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// mission_prefix := 01_ ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_STRING 01_
  42: ST_TO_ADDR
// debug := 0 ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// active_russian_dialog := false ;
  51: LD_ADDR_EXP 3
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// bobby_in_squad := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// cyrus_in_squad := false ;
  67: LD_ADDR_EXP 7
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// powell_contact := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// macmilan_use_radio := false ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// active_road_patrol := false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// macmilan_in_trap := false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// meta_action := false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// end_mission := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// bobby_saved := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// cyrus_saved := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// send_troops_to_forest := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// function DebugMode ; var i ; begin
 152: LD_INT 0
 154: PPUSH
 155: PPUSH
// if not debug then
 156: LD_EXP 1
 160: NOT
 161: IFFALSE 165
// exit ;
 163: GO 184
// Difficulty := 3 ;
 165: LD_ADDR_OWVAR 67
 169: PUSH
 170: LD_INT 3
 172: ST_TO_ADDR
// TurnFogOff ( ) ;
 173: CALL_OW 537
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 216
// unit := CreateCharacter ( ident ) else
 199: LD_ADDR_VAR 0 4
 203: PUSH
 204: LD_VAR 0 1
 208: PPUSH
 209: CALL_OW 34
 213: ST_TO_ADDR
 214: GO 231
// unit := NewCharacter ( ident ) ;
 216: LD_ADDR_VAR 0 4
 220: PUSH
 221: LD_VAR 0 1
 225: PPUSH
 226: CALL_OW 25
 230: ST_TO_ADDR
// result := unit ;
 231: LD_ADDR_VAR 0 3
 235: PUSH
 236: LD_VAR 0 4
 240: ST_TO_ADDR
// end ;
 241: LD_VAR 0 3
 245: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 246: LD_INT 0
 248: PPUSH
 249: PPUSH
 250: PPUSH
// uc_side := GetSide ( b ) ;
 251: LD_ADDR_OWVAR 20
 255: PUSH
 256: LD_VAR 0 2
 260: PPUSH
 261: CALL_OW 255
 265: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 266: LD_ADDR_OWVAR 21
 270: PUSH
 271: LD_VAR 0 2
 275: PPUSH
 276: CALL_OW 248
 280: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 281: LD_INT 0
 283: PPUSH
 284: LD_INT 1
 286: PPUSH
 287: LD_VAR 0 1
 291: PPUSH
 292: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
 296: LD_ADDR_VAR 0 5
 300: PUSH
 301: LD_VAR 0 2
 305: PPUSH
 306: CALL_OW 254
 310: PUSH
 311: LD_INT 3
 313: MINUS
 314: ST_TO_ADDR
// if dir < 0 then
 315: LD_VAR 0 5
 319: PUSH
 320: LD_INT 0
 322: LESS
 323: IFFALSE 339
// dir := 6 + dir ;
 325: LD_ADDR_VAR 0 5
 329: PUSH
 330: LD_INT 6
 332: PUSH
 333: LD_VAR 0 5
 337: PLUS
 338: ST_TO_ADDR
// un := CreateHuman ;
 339: LD_ADDR_VAR 0 4
 343: PUSH
 344: CALL_OW 44
 348: ST_TO_ADDR
// SetDir ( un , dir ) ;
 349: LD_VAR 0 4
 353: PPUSH
 354: LD_VAR 0 5
 358: PPUSH
 359: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 363: LD_VAR 0 4
 367: PPUSH
 368: LD_VAR 0 2
 372: PPUSH
 373: CALL_OW 52
// end ;
 377: LD_VAR 0 3
 381: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 382: LD_INT 0
 384: PPUSH
// uc_side := side ;
 385: LD_ADDR_OWVAR 20
 389: PUSH
 390: LD_VAR 0 1
 394: ST_TO_ADDR
// uc_nation := nation ;
 395: LD_ADDR_OWVAR 21
 399: PUSH
 400: LD_VAR 0 2
 404: ST_TO_ADDR
// vc_chassis := chassis ;
 405: LD_ADDR_OWVAR 37
 409: PUSH
 410: LD_VAR 0 3
 414: ST_TO_ADDR
// vc_engine := engine ;
 415: LD_ADDR_OWVAR 39
 419: PUSH
 420: LD_VAR 0 4
 424: ST_TO_ADDR
// vc_control := control ;
 425: LD_ADDR_OWVAR 38
 429: PUSH
 430: LD_VAR 0 5
 434: ST_TO_ADDR
// vc_weapon := weapon ;
 435: LD_ADDR_OWVAR 40
 439: PUSH
 440: LD_VAR 0 6
 444: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 445: LD_ADDR_OWVAR 41
 449: PUSH
 450: LD_VAR 0 7
 454: ST_TO_ADDR
// result := CreateVehicle ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: CALL_OW 45
 464: ST_TO_ADDR
// end ;
 465: LD_VAR 0 8
 469: RET
// export function ComPatrol ( unit , mode , pause , coords ) ; var i ; begin
 470: LD_INT 0
 472: PPUSH
 473: PPUSH
// while ( active_road_patrol ) do
 474: LD_EXP 8
 478: IFFALSE 832
// begin Wait ( 0 0$01 ) ;
 480: LD_INT 35
 482: PPUSH
 483: CALL_OW 67
// if not unit then
 487: LD_VAR 0 1
 491: NOT
 492: IFFALSE 496
// exit ;
 494: GO 832
// if mode = road then
 496: LD_VAR 0 2
 500: PUSH
 501: LD_STRING road
 503: EQUAL
 504: IFFALSE 560
// if GetFuel ( unit ) < 50 and not See ( 1 , unit ) and not HasTask ( unit ) then
 506: LD_VAR 0 1
 510: PPUSH
 511: CALL_OW 261
 515: PUSH
 516: LD_INT 50
 518: LESS
 519: PUSH
 520: LD_INT 1
 522: PPUSH
 523: LD_VAR 0 1
 527: PPUSH
 528: CALL_OW 292
 532: NOT
 533: AND
 534: PUSH
 535: LD_VAR 0 1
 539: PPUSH
 540: CALL_OW 314
 544: NOT
 545: AND
 546: IFFALSE 560
// SetFuel ( unit , 100 ) ;
 548: LD_VAR 0 1
 552: PPUSH
 553: LD_INT 100
 555: PPUSH
 556: CALL_OW 240
// if mode = forest then
 560: LD_VAR 0 2
 564: PUSH
 565: LD_STRING forest
 567: EQUAL
 568: IFFALSE 648
// if GetLives ( unit ) < 600 then
 570: LD_VAR 0 1
 574: PPUSH
 575: CALL_OW 256
 579: PUSH
 580: LD_INT 600
 582: LESS
 583: IFFALSE 648
// begin ComMoveXY ( unit , 42 , 3 ) ;
 585: LD_VAR 0 1
 589: PPUSH
 590: LD_INT 42
 592: PPUSH
 593: LD_INT 3
 595: PPUSH
 596: CALL_OW 111
// SetRememberedX ( unit , GetX ( unit ) ) ;
 600: LD_VAR 0 1
 604: PPUSH
 605: LD_VAR 0 1
 609: PPUSH
 610: CALL_OW 250
 614: PPUSH
 615: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
 619: LD_VAR 0 1
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: CALL_OW 251
 633: PPUSH
 634: CALL_OW 232
// send_troops_to_forest := true ;
 638: LD_ADDR_EXP 14
 642: PUSH
 643: LD_INT 1
 645: ST_TO_ADDR
// break ;
 646: GO 832
// end ; if not HasTask ( unit ) then
 648: LD_VAR 0 1
 652: PPUSH
 653: CALL_OW 314
 657: NOT
 658: IFFALSE 830
// begin for i = 1 to coords do
 660: LD_ADDR_VAR 0 6
 664: PUSH
 665: DOUBLE
 666: LD_INT 1
 668: DEC
 669: ST_TO_ADDR
 670: LD_VAR 0 4
 674: PUSH
 675: FOR_TO
 676: IFFALSE 743
// begin AddComAgressiveMove ( unit , coords [ i ] , coords [ i + 1 ] ) ;
 678: LD_VAR 0 1
 682: PPUSH
 683: LD_VAR 0 4
 687: PUSH
 688: LD_VAR 0 6
 692: ARRAY
 693: PPUSH
 694: LD_VAR 0 4
 698: PUSH
 699: LD_VAR 0 6
 703: PUSH
 704: LD_INT 1
 706: PLUS
 707: ARRAY
 708: PPUSH
 709: CALL_OW 174
// AddComWait ( unit , pause ) ;
 713: LD_VAR 0 1
 717: PPUSH
 718: LD_VAR 0 3
 722: PPUSH
 723: CALL_OW 202
// i := i + 1 ;
 727: LD_ADDR_VAR 0 6
 731: PUSH
 732: LD_VAR 0 6
 736: PUSH
 737: LD_INT 1
 739: PLUS
 740: ST_TO_ADDR
// end ;
 741: GO 675
 743: POP
 744: POP
// for i = coords downto 1 do
 745: LD_ADDR_VAR 0 6
 749: PUSH
 750: DOUBLE
 751: LD_VAR 0 4
 755: INC
 756: ST_TO_ADDR
 757: LD_INT 1
 759: PUSH
 760: FOR_DOWNTO
 761: IFFALSE 828
// begin AddComAgressiveMove ( unit , coords [ i - 1 ] , coords [ i ] ) ;
 763: LD_VAR 0 1
 767: PPUSH
 768: LD_VAR 0 4
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_INT 1
 780: MINUS
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 4
 787: PUSH
 788: LD_VAR 0 6
 792: ARRAY
 793: PPUSH
 794: CALL_OW 174
// AddComWait ( unit , pause ) ;
 798: LD_VAR 0 1
 802: PPUSH
 803: LD_VAR 0 3
 807: PPUSH
 808: CALL_OW 202
// i := i - 1 ;
 812: LD_ADDR_VAR 0 6
 816: PUSH
 817: LD_VAR 0 6
 821: PUSH
 822: LD_INT 1
 824: MINUS
 825: ST_TO_ADDR
// end ;
 826: GO 760
 828: POP
 829: POP
// end ; end ;
 830: GO 474
// end ;
 832: LD_VAR 0 5
 836: RET
// export function DebugSay ( dialog ) ; var speaker ; begin
 837: LD_INT 0
 839: PPUSH
 840: PPUSH
// uc_nation := 1 ;
 841: LD_ADDR_OWVAR 21
 845: PUSH
 846: LD_INT 1
 848: ST_TO_ADDR
// uc_side := 0 ;
 849: LD_ADDR_OWVAR 20
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
 857: LD_INT 0
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: CALL_OW 380
// hc_name := speaker ;
 870: LD_ADDR_OWVAR 26
 874: PUSH
 875: LD_STRING speaker
 877: ST_TO_ADDR
// hc_gallery :=  ;
 878: LD_ADDR_OWVAR 33
 882: PUSH
 883: LD_STRING 
 885: ST_TO_ADDR
// speaker := CreateHuman ;
 886: LD_ADDR_VAR 0 3
 890: PUSH
 891: CALL_OW 44
 895: ST_TO_ADDR
// Say ( speaker , dialog ) ;
 896: LD_VAR 0 3
 900: PPUSH
 901: LD_VAR 0 1
 905: PPUSH
 906: CALL_OW 88
// end ; end_of_file
 910: LD_VAR 0 2
 914: RET
// export JMM , Bobby , Cyrus , Powell , fakePokryshkin ; export function InitAmerican ; begin
 915: LD_INT 0
 917: PPUSH
// uc_nation := 1 ;
 918: LD_ADDR_OWVAR 21
 922: PUSH
 923: LD_INT 1
 925: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , false ) ;
 926: LD_ADDR_EXP 15
 930: PUSH
 931: LD_STRING JMM
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL 189 0 2
 941: ST_TO_ADDR
// uc_side := 4 ;
 942: LD_ADDR_OWVAR 20
 946: PUSH
 947: LD_INT 4
 949: ST_TO_ADDR
// hc_gallery := us ;
 950: LD_ADDR_OWVAR 33
 954: PUSH
 955: LD_STRING us
 957: ST_TO_ADDR
// hc_face_number := 7 ;
 958: LD_ADDR_OWVAR 34
 962: PUSH
 963: LD_INT 7
 965: ST_TO_ADDR
// hc_sex := sex_male ;
 966: LD_ADDR_OWVAR 27
 970: PUSH
 971: LD_INT 1
 973: ST_TO_ADDR
// hc_name := . ;
 974: LD_ADDR_OWVAR 26
 978: PUSH
 979: LD_STRING .
 981: ST_TO_ADDR
// hc_class := 1 ;
 982: LD_ADDR_OWVAR 28
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// Powell := CreateHuman ;
 990: LD_ADDR_EXP 18
 994: PUSH
 995: CALL_OW 44
 999: ST_TO_ADDR
// hc_name := . ;
1000: LD_ADDR_OWVAR 26
1004: PUSH
1005: LD_STRING .
1007: ST_TO_ADDR
// hc_gallery := ru ;
1008: LD_ADDR_OWVAR 33
1012: PUSH
1013: LD_STRING ru
1015: ST_TO_ADDR
// hc_face_number := 4 ;
1016: LD_ADDR_OWVAR 34
1020: PUSH
1021: LD_INT 4
1023: ST_TO_ADDR
// hc_sex := sex_male ;
1024: LD_ADDR_OWVAR 27
1028: PUSH
1029: LD_INT 1
1031: ST_TO_ADDR
// fakePokryshkin := CreateHuman ;
1032: LD_ADDR_EXP 19
1036: PUSH
1037: CALL_OW 44
1041: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , false ) ;
1042: LD_ADDR_EXP 16
1046: PUSH
1047: LD_STRING Bobby
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL 189 0 2
1057: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , false ) ;
1058: LD_ADDR_EXP 17
1062: PUSH
1063: LD_STRING Cyrus
1065: PPUSH
1066: LD_INT 0
1068: PPUSH
1069: CALL 189 0 2
1073: ST_TO_ADDR
// case Difficulty of 1 :
1074: LD_OWVAR 67
1078: PUSH
1079: LD_INT 1
1081: DOUBLE
1082: EQUAL
1083: IFTRUE 1087
1085: GO 1102
1087: POP
// SetLives ( Bobby , 500 ) ; 2 :
1088: LD_EXP 16
1092: PPUSH
1093: LD_INT 500
1095: PPUSH
1096: CALL_OW 234
1100: GO 1149
1102: LD_INT 2
1104: DOUBLE
1105: EQUAL
1106: IFTRUE 1110
1108: GO 1125
1110: POP
// SetLives ( Bobby , 460 ) ; 3 :
1111: LD_EXP 16
1115: PPUSH
1116: LD_INT 460
1118: PPUSH
1119: CALL_OW 234
1123: GO 1149
1125: LD_INT 3
1127: DOUBLE
1128: EQUAL
1129: IFTRUE 1133
1131: GO 1148
1133: POP
// SetLives ( Bobby , 420 ) ; end ;
1134: LD_EXP 16
1138: PPUSH
1139: LD_INT 420
1141: PPUSH
1142: CALL_OW 234
1146: GO 1149
1148: POP
// end ; end_of_file
1149: LD_VAR 0 1
1153: RET
// export russian_troops_1 , russian_troops_2 , russian_patrol_tanks , russian_meta_guards , russian_patrol_forest ; export Pokryshkin ; export function InitRussian ; var skill , i , un ; begin
1154: LD_INT 0
1156: PPUSH
1157: PPUSH
1158: PPUSH
1159: PPUSH
// skill := [ 1 , 2 , 3 ] [ Difficulty ] ;
1160: LD_ADDR_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: PUSH
1168: LD_INT 2
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: PUSH
1179: LD_OWVAR 67
1183: ARRAY
1184: ST_TO_ADDR
// uc_side := 3 ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_INT 3
1192: ST_TO_ADDR
// uc_nation := 3 ;
1193: LD_ADDR_OWVAR 21
1197: PUSH
1198: LD_INT 3
1200: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
1201: LD_ADDR_EXP 25
1205: PUSH
1206: LD_STRING Pokryshkin
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL 189 0 2
1216: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 44 , 5 , false ) ;
1217: LD_EXP 25
1221: PPUSH
1222: LD_INT 44
1224: PPUSH
1225: LD_INT 5
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 48
// hc_importance := 0 ;
1235: LD_ADDR_OWVAR 32
1239: PUSH
1240: LD_INT 0
1242: ST_TO_ADDR
// hc_gallery :=  ;
1243: LD_ADDR_OWVAR 33
1247: PUSH
1248: LD_STRING 
1250: ST_TO_ADDR
// hc_name :=  ;
1251: LD_ADDR_OWVAR 26
1255: PUSH
1256: LD_STRING 
1258: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
1259: LD_INT 1
1261: PPUSH
1262: LD_INT 1
1264: PPUSH
1265: LD_VAR 0 2
1269: PPUSH
1270: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1274: LD_ADDR_OWVAR 33
1278: PUSH
1279: LD_STRING SecondCharsGal
1281: ST_TO_ADDR
// hc_face_number := 69 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 69
1289: ST_TO_ADDR
// hc_sex := sex_male ;
1290: LD_ADDR_OWVAR 27
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// hc_name := Ilja Ivanov ;
1298: LD_ADDR_OWVAR 26
1302: PUSH
1303: LD_STRING Ilja Ivanov
1305: ST_TO_ADDR
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 4
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 1 , un ) ;
1316: LD_ADDR_EXP 20
1320: PUSH
1321: LD_EXP 20
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 4
1333: PPUSH
1334: CALL_OW 2
1338: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 3
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 49
// PrepareHuman ( sex_male , 1 , skill ) ;
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: LD_VAR 0 2
1364: PPUSH
1365: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1369: LD_ADDR_OWVAR 33
1373: PUSH
1374: LD_STRING SecondCharsGal
1376: ST_TO_ADDR
// hc_face_number := 70 ;
1377: LD_ADDR_OWVAR 34
1381: PUSH
1382: LD_INT 70
1384: ST_TO_ADDR
// hc_name := Pavel Starczy ;
1385: LD_ADDR_OWVAR 26
1389: PUSH
1390: LD_STRING Pavel Starczy
1392: ST_TO_ADDR
// un := CreateHuman ;
1393: LD_ADDR_VAR 0 4
1397: PUSH
1398: CALL_OW 44
1402: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 2 , un ) ;
1403: LD_ADDR_EXP 20
1407: PUSH
1408: LD_EXP 20
1412: PPUSH
1413: LD_INT 2
1415: PPUSH
1416: LD_VAR 0 4
1420: PPUSH
1421: CALL_OW 2
1425: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1426: LD_VAR 0 4
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: LD_INT 0
1436: PPUSH
1437: CALL_OW 49
// InitHc ;
1441: CALL_OW 19
// for i = 1 to 7 do
1445: LD_ADDR_VAR 0 3
1449: PUSH
1450: DOUBLE
1451: LD_INT 1
1453: DEC
1454: ST_TO_ADDR
1455: LD_INT 7
1457: PUSH
1458: FOR_TO
1459: IFFALSE 1610
// begin PrepareHuman ( false , 1 , skill ) ;
1461: LD_INT 0
1463: PPUSH
1464: LD_INT 1
1466: PPUSH
1467: LD_VAR 0 2
1471: PPUSH
1472: CALL_OW 380
// un := CreateHuman ;
1476: LD_ADDR_VAR 0 4
1480: PUSH
1481: CALL_OW 44
1485: ST_TO_ADDR
// if i mod 2 = 0 then
1486: LD_VAR 0 3
1490: PUSH
1491: LD_INT 2
1493: MOD
1494: PUSH
1495: LD_INT 0
1497: EQUAL
1498: IFFALSE 1555
// begin russian_troops_1 := Insert ( russian_troops_1 , russian_troops_1 + 1 , un ) ;
1500: LD_ADDR_EXP 20
1504: PUSH
1505: LD_EXP 20
1509: PPUSH
1510: LD_EXP 20
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1529: LD_VAR 0 4
1533: PPUSH
1534: LD_INT 3
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 49
// ComHold ( un ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: CALL_OW 140
// end else
1553: GO 1608
// begin russian_troops_2 := Insert ( russian_troops_2 , russian_troops_2 + 1 , un ) ;
1555: LD_ADDR_EXP 21
1559: PUSH
1560: LD_EXP 21
1564: PPUSH
1565: LD_EXP 21
1569: PUSH
1570: LD_INT 1
1572: PLUS
1573: PPUSH
1574: LD_VAR 0 4
1578: PPUSH
1579: CALL_OW 2
1583: ST_TO_ADDR
// PlaceUnitArea ( un , guard_south , false ) ;
1584: LD_VAR 0 4
1588: PPUSH
1589: LD_INT 4
1591: PPUSH
1592: LD_INT 0
1594: PPUSH
1595: CALL_OW 49
// ComHold ( un ) ;
1599: LD_VAR 0 4
1603: PPUSH
1604: CALL_OW 140
// end ; end ;
1608: GO 1458
1610: POP
1611: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) do
1612: LD_ADDR_VAR 0 3
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 3
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 30
1629: PUSH
1630: LD_INT 31
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: PPUSH
1641: CALL_OW 69
1645: PUSH
1646: FOR_IN
1647: IFFALSE 1665
// PrepareSolBun ( skill , i ) ;
1649: LD_VAR 0 2
1653: PPUSH
1654: LD_VAR 0 3
1658: PPUSH
1659: CALL 246 0 2
1663: GO 1646
1665: POP
1666: POP
// for i = 1 to 2 do
1667: LD_ADDR_VAR 0 3
1671: PUSH
1672: DOUBLE
1673: LD_INT 1
1675: DEC
1676: ST_TO_ADDR
1677: LD_INT 2
1679: PUSH
1680: FOR_TO
1681: IFFALSE 1812
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , 100 ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_INT 3
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: LD_INT 22
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 1
1702: PPUSH
1703: LD_INT 42
1705: PPUSH
1706: LD_INT 100
1708: PPUSH
1709: CALL 382 0 7
1713: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
1714: LD_INT 0
1716: PPUSH
1717: LD_INT 3
1719: PPUSH
1720: LD_VAR 0 2
1724: PPUSH
1725: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
1729: CALL_OW 44
1733: PPUSH
1734: LD_VAR 0 4
1738: PPUSH
1739: CALL_OW 52
// PlaceUnitXY ( un , [ 23 , 131 ] [ i ] , [ 14 , 87 ] [ i ] , false ) ;
1743: LD_VAR 0 4
1747: PPUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 131
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_VAR 0 3
1762: ARRAY
1763: PPUSH
1764: LD_INT 14
1766: PUSH
1767: LD_INT 87
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: LD_VAR 0 3
1778: ARRAY
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 48
// russian_patrol_tanks := Insert ( russian_patrol_tanks , 1 , un ) ;
1787: LD_ADDR_EXP 22
1791: PUSH
1792: LD_EXP 22
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_VAR 0 4
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// end ;
1810: GO 1680
1812: POP
1813: POP
// for i = 1 to 2 do
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: DOUBLE
1820: LD_INT 1
1822: DEC
1823: ST_TO_ADDR
1824: LD_INT 2
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1919
// begin PrepareHuman ( [ sex_female , sex_male , sex_male ] [ i ] , 1 , 1 ) ;
1830: LD_INT 2
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: PUSH
1844: LD_VAR 0 3
1848: ARRAY
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: LD_INT 1
1855: PPUSH
1856: CALL_OW 380
// un := CreateHuman ;
1860: LD_ADDR_VAR 0 4
1864: PUSH
1865: CALL_OW 44
1869: ST_TO_ADDR
// russian_meta_guards := Insert ( russian_meta_guards , 1 , un ) ;
1870: LD_ADDR_EXP 23
1874: PUSH
1875: LD_EXP 23
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: LD_VAR 0 4
1887: PPUSH
1888: CALL_OW 2
1892: ST_TO_ADDR
// PlaceUnitArea ( un , exitArea , false ) ;
1893: LD_VAR 0 4
1897: PPUSH
1898: LD_INT 10
1900: PPUSH
1901: LD_INT 0
1903: PPUSH
1904: CALL_OW 49
// ComHold ( un ) ;
1908: LD_VAR 0 4
1912: PPUSH
1913: CALL_OW 140
// end ;
1917: GO 1827
1919: POP
1920: POP
// if Difficulty < 3 then
1921: LD_OWVAR 67
1925: PUSH
1926: LD_INT 3
1928: LESS
1929: IFFALSE 1933
// exit ;
1931: GO 1976
// PrepareHuman ( false , 1 , skill ) ;
1933: LD_INT 0
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: LD_VAR 0 2
1943: PPUSH
1944: CALL_OW 380
// russian_patrol_forest := CreateHuman ;
1948: LD_ADDR_EXP 24
1952: PUSH
1953: CALL_OW 44
1957: ST_TO_ADDR
// PlaceUnitXY ( russian_patrol_forest , 82 , 2 , false ) ;
1958: LD_EXP 24
1962: PPUSH
1963: LD_INT 82
1965: PPUSH
1966: LD_INT 2
1968: PPUSH
1969: LD_INT 0
1971: PPUSH
1972: CALL_OW 48
// end ;
1976: LD_VAR 0 1
1980: RET
// every 0 0$01 trigger active_road_patrol do
1981: LD_EXP 8
1985: IFFALSE 2051
1987: GO 1989
1989: DISABLE
// ComPatrol ( russian_patrol_tanks [ 1 ] , road , 0 0$02 , [ 131 , 87 , 107 , 75 , 107 , 66 , 114 , 61 , 107 , 34 ] ) ;
1990: LD_EXP 22
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_STRING road
2001: PPUSH
2002: LD_INT 70
2004: PPUSH
2005: LD_INT 131
2007: PUSH
2008: LD_INT 87
2010: PUSH
2011: LD_INT 107
2013: PUSH
2014: LD_INT 75
2016: PUSH
2017: LD_INT 107
2019: PUSH
2020: LD_INT 66
2022: PUSH
2023: LD_INT 114
2025: PUSH
2026: LD_INT 61
2028: PUSH
2029: LD_INT 107
2031: PUSH
2032: LD_INT 34
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 470 0 4
2051: END
// every 0 0$01 trigger active_road_patrol do
2052: LD_EXP 8
2056: IFFALSE 2114
2058: GO 2060
2060: DISABLE
// ComPatrol ( russian_patrol_tanks [ 2 ] , road , 0 0$02 , [ 21 , 12 , 37 , 30 , 65 , 62 , 107 , 76 ] ) ;
2061: LD_EXP 22
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: LD_STRING road
2072: PPUSH
2073: LD_INT 70
2075: PPUSH
2076: LD_INT 21
2078: PUSH
2079: LD_INT 12
2081: PUSH
2082: LD_INT 37
2084: PUSH
2085: LD_INT 30
2087: PUSH
2088: LD_INT 65
2090: PUSH
2091: LD_INT 62
2093: PUSH
2094: LD_INT 107
2096: PUSH
2097: LD_INT 76
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL 470 0 4
2114: END
// every 0 0$01 trigger IsOk ( russian_patrol_forest ) do
2115: LD_EXP 24
2119: PPUSH
2120: CALL_OW 302
2124: IFFALSE 2186
2126: GO 2128
2128: DISABLE
// ComPatrol ( russian_patrol_forest , forest , 0 0$01 , [ 52 , 15 , 81 , 9 , 120 , 52 , 135 , 80 , 122 , 95 ] ) ;
2129: LD_EXP 24
2133: PPUSH
2134: LD_STRING forest
2136: PPUSH
2137: LD_INT 35
2139: PPUSH
2140: LD_INT 52
2142: PUSH
2143: LD_INT 15
2145: PUSH
2146: LD_INT 81
2148: PUSH
2149: LD_INT 9
2151: PUSH
2152: LD_INT 120
2154: PUSH
2155: LD_INT 52
2157: PUSH
2158: LD_INT 135
2160: PUSH
2161: LD_INT 80
2163: PUSH
2164: LD_INT 122
2166: PUSH
2167: LD_INT 95
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL 470 0 4
2186: END
// every 0 0$01 trigger macmilan_use_radio do
2187: LD_EXP 6
2191: IFFALSE 2252
2193: GO 2195
2195: DISABLE
// begin active_road_patrol := false ;
2196: LD_ADDR_EXP 8
2200: PUSH
2201: LD_INT 0
2203: ST_TO_ADDR
// ComStop ( russian_patrol_tanks ) ;
2204: LD_EXP 22
2208: PPUSH
2209: CALL_OW 141
// AddComAgressiveMove ( russian_patrol_tanks , 72 , 41 ) ;
2213: LD_EXP 22
2217: PPUSH
2218: LD_INT 72
2220: PPUSH
2221: LD_INT 41
2223: PPUSH
2224: CALL_OW 174
// ComExitBuilding ( russian_troops_2 ) ;
2228: LD_EXP 21
2232: PPUSH
2233: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , 72 , 41 ) ;
2237: LD_EXP 21
2241: PPUSH
2242: LD_INT 72
2244: PPUSH
2245: LD_INT 41
2247: PPUSH
2248: CALL_OW 174
// end ;
2252: END
// every 0 0$03 trigger FilterUnitsInArea ( def_south , [ f_side , 1 ] ) do var un ;
2253: LD_INT 9
2255: PPUSH
2256: LD_INT 22
2258: PUSH
2259: LD_INT 1
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL_OW 70
2270: IFFALSE 2344
2272: GO 2274
2274: DISABLE
2275: LD_INT 0
2277: PPUSH
// begin enable ;
2278: ENABLE
// un := FilterUnitsInArea ( def_south , [ f_side , 1 ] ) [ 1 ] ;
2279: LD_ADDR_VAR 0 1
2283: PUSH
2284: LD_INT 9
2286: PPUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL_OW 70
2301: PUSH
2302: LD_INT 1
2304: ARRAY
2305: ST_TO_ADDR
// ComExitBuilding ( russian_troops_2 ) ;
2306: LD_EXP 21
2310: PPUSH
2311: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , GetX ( un ) , GetY ( un ) ) ;
2315: LD_EXP 21
2319: PPUSH
2320: LD_VAR 0 1
2324: PPUSH
2325: CALL_OW 250
2329: PPUSH
2330: LD_VAR 0 1
2334: PPUSH
2335: CALL_OW 251
2339: PPUSH
2340: CALL_OW 174
// end ;
2344: PPOPN 1
2346: END
// every 0 0$01 trigger ( GetLives ( russian_patrol_tanks [ 1 ] ) < 999 or GetLives ( russian_patrol_tanks [ 2 ] ) < 999 ) and See ( 3 , JMM ) do
2347: LD_EXP 22
2351: PUSH
2352: LD_INT 1
2354: ARRAY
2355: PPUSH
2356: CALL_OW 256
2360: PUSH
2361: LD_INT 999
2363: LESS
2364: PUSH
2365: LD_EXP 22
2369: PUSH
2370: LD_INT 2
2372: ARRAY
2373: PPUSH
2374: CALL_OW 256
2378: PUSH
2379: LD_INT 999
2381: LESS
2382: OR
2383: PUSH
2384: LD_INT 3
2386: PPUSH
2387: LD_EXP 15
2391: PPUSH
2392: CALL_OW 292
2396: AND
2397: IFFALSE 2424
2399: GO 2401
2401: DISABLE
// begin active_road_patrol := false ;
2402: LD_ADDR_EXP 8
2406: PUSH
2407: LD_INT 0
2409: ST_TO_ADDR
// ComAttackUnit ( russian_patrol_tanks , JMM ) ;
2410: LD_EXP 22
2414: PPUSH
2415: LD_EXP 15
2419: PPUSH
2420: CALL_OW 115
// end ;
2424: END
// every 0 0$01 trigger macmilan_in_trap do
2425: LD_EXP 9
2429: IFFALSE 2475
2431: GO 2433
2433: DISABLE
// begin ComExitBuilding ( russian_troops_2 ) ;
2434: LD_EXP 21
2438: PPUSH
2439: CALL_OW 122
// ComAttackUnit ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , JMM ) ;
2443: LD_EXP 20
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: PUSH
2454: LD_EXP 25
2458: ADD
2459: PUSH
2460: LD_EXP 22
2464: ADD
2465: PPUSH
2466: LD_EXP 15
2470: PPUSH
2471: CALL_OW 115
// end ;
2475: END
// every 0 0$01 trigger meta_action do
2476: LD_EXP 10
2480: IFFALSE 2526
2482: GO 2484
2484: DISABLE
// begin active_road_patrol := false ;
2485: LD_ADDR_EXP 8
2489: PUSH
2490: LD_INT 0
2492: ST_TO_ADDR
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , 93 , 1 ) ;
2493: LD_EXP 20
2497: PUSH
2498: LD_EXP 21
2502: ADD
2503: PUSH
2504: LD_EXP 25
2508: ADD
2509: PUSH
2510: LD_EXP 22
2514: ADD
2515: PPUSH
2516: LD_INT 93
2518: PPUSH
2519: LD_INT 1
2521: PPUSH
2522: CALL_OW 114
// end ;
2526: END
// every 0 0$1 trigger GetLives ( Pokryshkin ) < 1000 do
2527: LD_EXP 25
2531: PPUSH
2532: CALL_OW 256
2536: PUSH
2537: LD_INT 1000
2539: LESS
2540: IFFALSE 2591
2542: GO 2544
2544: DISABLE
// begin enable ;
2545: ENABLE
// if HexInfo ( 18 , 1 ) = Pokryshkin then
2546: LD_INT 18
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 428
2556: PUSH
2557: LD_EXP 25
2561: EQUAL
2562: IFFALSE 2576
// begin RemoveUnit ( Pokryshkin ) ;
2564: LD_EXP 25
2568: PPUSH
2569: CALL_OW 64
// disable ;
2573: DISABLE
// end else
2574: GO 2591
// ComMoveXY ( Pokryshkin , 18 , 1 ) ;
2576: LD_EXP 25
2580: PPUSH
2581: LD_INT 18
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: CALL_OW 111
// end ;
2591: END
// every 0 0$20 trigger send_troops_to_forest do
2592: LD_EXP 14
2596: IFFALSE 2650
2598: GO 2600
2600: DISABLE
// begin if not IsOk ( russian_patrol_forest ) then
2601: LD_EXP 24
2605: PPUSH
2606: CALL_OW 302
2610: NOT
2611: IFFALSE 2615
// exit ;
2613: GO 2650
// ComAgressiveMove ( russian_troops_1 ^ Pokryshkin , GetRememberedX ( russian_patrol_forest ) , GetRememberedY ( russian_patrol_forest ) ) ;
2615: LD_EXP 20
2619: PUSH
2620: LD_EXP 25
2624: ADD
2625: PPUSH
2626: LD_EXP 24
2630: PPUSH
2631: CALL_OW 252
2635: PPUSH
2636: LD_EXP 24
2640: PPUSH
2641: CALL_OW 253
2645: PPUSH
2646: CALL_OW 114
// end ;
2650: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do begin if GetSide ( driver ) = 3 then
2651: LD_VAR 0 1
2655: PPUSH
2656: CALL_OW 255
2660: PUSH
2661: LD_INT 3
2663: EQUAL
2664: IFFALSE 2707
// begin wait ( 11 ) ;
2666: LD_INT 11
2668: PPUSH
2669: CALL_OW 67
// ComEnterUnit ( driver , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_depot ] ) , driver ) ) ;
2673: LD_VAR 0 1
2677: PPUSH
2678: LD_INT 30
2680: PUSH
2681: LD_INT 0
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: PPUSH
2693: LD_VAR 0 1
2697: PPUSH
2698: CALL_OW 74
2702: PPUSH
2703: CALL_OW 120
// end ; end ; end_of_file
2707: PPOPN 4
2709: END
// export function Action ; var i ; begin
2710: LD_INT 0
2712: PPUSH
2713: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_INT 22
2721: PUSH
2722: LD_INT 3
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 25
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2762
// ComHold ( i ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: CALL_OW 140
2760: GO 2748
2762: POP
2763: POP
// InGameOn ;
2764: CALL_OW 8
// CenterOnXY ( 79 , 76 ) ;
2768: LD_INT 79
2770: PPUSH
2771: LD_INT 76
2773: PPUSH
2774: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
2778: LD_INT 10
2780: PPUSH
2781: CALL_OW 67
// PlaceUnitXY ( JMM , 80 , 79 , true ) ;
2785: LD_EXP 15
2789: PPUSH
2790: LD_INT 80
2792: PPUSH
2793: LD_INT 79
2795: PPUSH
2796: LD_INT 1
2798: PPUSH
2799: CALL_OW 48
// Wait ( 0 0$03 ) ;
2803: LD_INT 105
2805: PPUSH
2806: CALL_OW 67
// ComMoveXY ( JMM , 80 , 76 ) ;
2810: LD_EXP 15
2814: PPUSH
2815: LD_INT 80
2817: PPUSH
2818: LD_INT 76
2820: PPUSH
2821: CALL_OW 111
// Say ( JMM , D1-JMM-1 ) ;
2825: LD_EXP 15
2829: PPUSH
2830: LD_STRING D1-JMM-1
2832: PPUSH
2833: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2837: LD_INT 10
2839: PPUSH
2840: CALL_OW 67
// ComMoveXY ( JMM , 76 , 76 ) ;
2844: LD_EXP 15
2848: PPUSH
2849: LD_INT 76
2851: PPUSH
2852: LD_INT 76
2854: PPUSH
2855: CALL_OW 111
// Say ( JMM , D1-JMM-1a ) ;
2859: LD_EXP 15
2863: PPUSH
2864: LD_STRING D1-JMM-1a
2866: PPUSH
2867: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2871: LD_INT 10
2873: PPUSH
2874: CALL_OW 67
// ComTurnXY ( JMM , 83 , 66 ) ;
2878: LD_EXP 15
2882: PPUSH
2883: LD_INT 83
2885: PPUSH
2886: LD_INT 66
2888: PPUSH
2889: CALL_OW 118
// Say ( JMM , D1-JMM-1b ) ;
2893: LD_EXP 15
2897: PPUSH
2898: LD_STRING D1-JMM-1b
2900: PPUSH
2901: CALL_OW 88
// Wait ( 0 0$0.5 ) ;
2905: LD_INT 18
2907: PPUSH
2908: CALL_OW 67
// Say ( JMM , D1-JMM-1c ) ;
2912: LD_EXP 15
2916: PPUSH
2917: LD_STRING D1-JMM-1c
2919: PPUSH
2920: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
2924: LD_INT 7
2926: PPUSH
2927: CALL_OW 67
// SayRadio ( Powell , D1-Pow-1 ) ;
2931: LD_EXP 18
2935: PPUSH
2936: LD_STRING D1-Pow-1
2938: PPUSH
2939: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
2943: LD_EXP 15
2947: PPUSH
2948: LD_STRING D1-JMM-2
2950: PPUSH
2951: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
2955: LD_EXP 18
2959: PPUSH
2960: LD_STRING D1-Pow-2
2962: PPUSH
2963: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
2967: LD_EXP 15
2971: PPUSH
2972: LD_STRING D1-JMM-3
2974: PPUSH
2975: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_STRING D1-Pow-3
2986: PPUSH
2987: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
2991: LD_EXP 15
2995: PPUSH
2996: LD_STRING D1-JMM-4
2998: PPUSH
2999: CALL_OW 88
// ComFree ( JMM ) ;
3003: LD_EXP 15
3007: PPUSH
3008: CALL_OW 139
// Wait ( 0 0$0.3 ) ;
3012: LD_INT 10
3014: PPUSH
3015: CALL_OW 67
// InGameOff ;
3019: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3023: LD_STRING M1
3025: PPUSH
3026: CALL_OW 337
// SaveForQuickRestart ;
3030: CALL_OW 22
// active_russian_dialog := true ;
3034: LD_ADDR_EXP 3
3038: PUSH
3039: LD_INT 1
3041: ST_TO_ADDR
// active_road_patrol := true ;
3042: LD_ADDR_EXP 8
3046: PUSH
3047: LD_INT 1
3049: ST_TO_ADDR
// if Difficulty < 3 then
3050: LD_OWVAR 67
3054: PUSH
3055: LD_INT 3
3057: LESS
3058: IFFALSE 3089
// begin PlaceUnitXY ( Bobby , 41 , 71 , false ) ;
3060: LD_EXP 16
3064: PPUSH
3065: LD_INT 41
3067: PPUSH
3068: LD_INT 71
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 48
// ComHold ( Bobby ) ;
3078: LD_EXP 16
3082: PPUSH
3083: CALL_OW 140
// end else
3087: GO 3137
// begin SetDir ( Bobby , 5 ) ;
3089: LD_EXP 16
3093: PPUSH
3094: LD_INT 5
3096: PPUSH
3097: CALL_OW 233
// PlaceUnitXY ( Bobby , 105 , 98 , false ) ;
3101: LD_EXP 16
3105: PPUSH
3106: LD_INT 105
3108: PPUSH
3109: LD_INT 98
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 48
// ComCrawl ( Bobby ) ;
3119: LD_EXP 16
3123: PPUSH
3124: CALL_OW 137
// AddComHold ( Bobby ) ;
3128: LD_EXP 16
3132: PPUSH
3133: CALL_OW 200
// end ; PlaceUnitXY ( Cyrus , 90 , 42 , false ) ;
3137: LD_EXP 17
3141: PPUSH
3142: LD_INT 90
3144: PPUSH
3145: LD_INT 42
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 48
// ComMoveXY ( Cyrus , 79 , 34 ) ;
3155: LD_EXP 17
3159: PPUSH
3160: LD_INT 79
3162: PPUSH
3163: LD_INT 34
3165: PPUSH
3166: CALL_OW 111
// AddComCrawl ( Cyrus ) ;
3170: LD_EXP 17
3174: PPUSH
3175: CALL_OW 197
// end ;
3179: LD_VAR 0 1
3183: RET
// every 0 0$01 trigger active_russian_dialog do var wait_points ;
3184: LD_EXP 3
3188: IFFALSE 3811
3190: GO 3192
3192: DISABLE
3193: LD_INT 0
3195: PPUSH
// begin wait_points := 0 ;
3196: LD_ADDR_VAR 0 1
3200: PUSH
3201: LD_INT 0
3203: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
3204: LD_INT 70
3206: PPUSH
3207: CALL_OW 67
// ComAgressiveMove ( russian_troops_1 , 79 , 83 ) ;
3211: LD_EXP 20
3215: PPUSH
3216: LD_INT 79
3218: PPUSH
3219: LD_INT 83
3221: PPUSH
3222: CALL_OW 114
// Say ( russian_troops_1 [ 2 ] , D1R-Rus1-1 ) ;
3226: LD_EXP 20
3230: PUSH
3231: LD_INT 2
3233: ARRAY
3234: PPUSH
3235: LD_STRING D1R-Rus1-1
3237: PPUSH
3238: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1R-Rus2-1 ) ;
3242: LD_EXP 20
3246: PUSH
3247: LD_INT 1
3249: ARRAY
3250: PPUSH
3251: LD_STRING D1R-Rus2-1
3253: PPUSH
3254: CALL_OW 88
// ComAgressiveMove ( russian_troops_2 , 91 , 80 ) ;
3258: LD_EXP 21
3262: PPUSH
3263: LD_INT 91
3265: PPUSH
3266: LD_INT 80
3268: PPUSH
3269: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3273: LD_INT 35
3275: PPUSH
3276: CALL_OW 67
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 79 , 82 ) < 5 ;
3280: LD_EXP 20
3284: PUSH
3285: LD_INT 1
3287: ARRAY
3288: PPUSH
3289: LD_INT 79
3291: PPUSH
3292: LD_INT 82
3294: PPUSH
3295: CALL_OW 297
3299: PUSH
3300: LD_INT 5
3302: LESS
3303: IFFALSE 3273
// if not IsInArea ( JMM , jmm_spot ) then
3305: LD_EXP 15
3309: PPUSH
3310: LD_INT 5
3312: PPUSH
3313: CALL_OW 308
3317: NOT
3318: IFFALSE 3338
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1 ) else
3320: LD_EXP 20
3324: PUSH
3325: LD_INT 1
3327: ARRAY
3328: PPUSH
3329: LD_STRING D1Ra-Rus2-1
3331: PPUSH
3332: CALL_OW 88
3336: GO 3474
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3338: LD_EXP 20
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PPUSH
3347: LD_STRING D1Rb-Rus1-1
3349: PPUSH
3350: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Rb-Rus2-1 ) ;
3354: LD_EXP 20
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: LD_STRING D1Rb-Rus2-1
3365: PPUSH
3366: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 , GetX ( JMM ) , GetY ( JMM ) ) ;
3370: LD_EXP 20
3374: PUSH
3375: LD_EXP 21
3379: ADD
3380: PPUSH
3381: LD_EXP 15
3385: PPUSH
3386: CALL_OW 250
3390: PPUSH
3391: LD_EXP 15
3395: PPUSH
3396: CALL_OW 251
3400: PPUSH
3401: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3405: LD_INT 35
3407: PPUSH
3408: CALL_OW 67
// until not IsInArea ( JMM , jmm_spot ) and not See ( 3 , jmm ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_INT 5
3419: PPUSH
3420: CALL_OW 308
3424: NOT
3425: PUSH
3426: LD_INT 3
3428: PPUSH
3429: LD_EXP 15
3433: PPUSH
3434: CALL_OW 292
3438: NOT
3439: AND
3440: IFFALSE 3405
// Say ( russian_troops_1 [ 2 ] , D1Rc-Rus1-1 ) ;
3442: LD_EXP 20
3446: PUSH
3447: LD_INT 2
3449: ARRAY
3450: PPUSH
3451: LD_STRING D1Rc-Rus1-1
3453: PPUSH
3454: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1a ) ;
3458: LD_EXP 20
3462: PUSH
3463: LD_INT 1
3465: ARRAY
3466: PPUSH
3467: LD_STRING D1Ra-Rus2-1a
3469: PPUSH
3470: CALL_OW 88
// end ; wait_points := 10 ;
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: LD_INT 10
3481: ST_TO_ADDR
// if Difficulty > 1 then
3482: LD_OWVAR 67
3486: PUSH
3487: LD_INT 1
3489: GREATER
3490: IFFALSE 3572
// begin ComAgressiveMove ( russian_troops_1 , 78 , 95 ) ;
3492: LD_EXP 20
3496: PPUSH
3497: LD_INT 78
3499: PPUSH
3500: LD_INT 95
3502: PPUSH
3503: CALL_OW 114
// AddComWait ( russian_troops_1 , 0 0$05 ) ;
3507: LD_EXP 20
3511: PPUSH
3512: LD_INT 175
3514: PPUSH
3515: CALL_OW 202
// wait_points := wait_points + 15 ;
3519: LD_ADDR_VAR 0 1
3523: PUSH
3524: LD_VAR 0 1
3528: PUSH
3529: LD_INT 15
3531: PLUS
3532: ST_TO_ADDR
// if Difficulty > 2 then
3533: LD_OWVAR 67
3537: PUSH
3538: LD_INT 2
3540: GREATER
3541: IFFALSE 3572
// begin AddComAgressiveMove ( russian_troops_1 , 65 , 79 ) ;
3543: LD_EXP 20
3547: PPUSH
3548: LD_INT 65
3550: PPUSH
3551: LD_INT 79
3553: PPUSH
3554: CALL_OW 174
// wait_points := wait_points + 5 ;
3558: LD_ADDR_VAR 0 1
3562: PUSH
3563: LD_VAR 0 1
3567: PUSH
3568: LD_INT 5
3570: PLUS
3571: ST_TO_ADDR
// end ; end ; repeat wait ( 0 0$01 ) ;
3572: LD_INT 35
3574: PPUSH
3575: CALL_OW 67
// wait_points := wait_points - 1 ;
3579: LD_ADDR_VAR 0 1
3583: PUSH
3584: LD_VAR 0 1
3588: PUSH
3589: LD_INT 1
3591: MINUS
3592: ST_TO_ADDR
// if See ( 3 , JMM ) then
3593: LD_INT 3
3595: PPUSH
3596: LD_EXP 15
3600: PPUSH
3601: CALL_OW 292
3605: IFFALSE 3659
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3607: LD_EXP 20
3611: PUSH
3612: LD_INT 2
3614: ARRAY
3615: PPUSH
3616: LD_STRING D1Rb-Rus1-1
3618: PPUSH
3619: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3623: LD_EXP 20
3627: PPUSH
3628: LD_EXP 15
3632: PPUSH
3633: CALL_OW 250
3637: PPUSH
3638: LD_EXP 15
3642: PPUSH
3643: CALL_OW 251
3647: PPUSH
3648: CALL_OW 114
// Wait ( 0 0$03 ) ;
3652: LD_INT 105
3654: PPUSH
3655: CALL_OW 67
// end ; until wait_points = 0 ;
3659: LD_VAR 0 1
3663: PUSH
3664: LD_INT 0
3666: EQUAL
3667: IFFALSE 3572
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3669: LD_EXP 20
3673: PPUSH
3674: LD_INT 45
3676: PPUSH
3677: LD_INT 5
3679: PPUSH
3680: CALL_OW 114
// ComEnterUnit ( russian_troops_2 , rbar1 ) ;
3684: LD_EXP 21
3688: PPUSH
3689: LD_INT 26
3691: PPUSH
3692: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
3696: LD_INT 35
3698: PPUSH
3699: CALL_OW 67
// if See ( 3 , JMM ) then
3703: LD_INT 3
3705: PPUSH
3706: LD_EXP 15
3710: PPUSH
3711: CALL_OW 292
3715: IFFALSE 3771
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3717: LD_EXP 20
3721: PUSH
3722: LD_INT 2
3724: ARRAY
3725: PPUSH
3726: LD_STRING D1Rb-Rus1-1
3728: PPUSH
3729: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3733: LD_EXP 20
3737: PPUSH
3738: LD_EXP 15
3742: PPUSH
3743: CALL_OW 250
3747: PPUSH
3748: LD_EXP 15
3752: PPUSH
3753: CALL_OW 251
3757: PPUSH
3758: CALL_OW 114
// Wait ( 0 0$50 ) ;
3762: LD_INT 1750
3764: PPUSH
3765: CALL_OW 67
// end else
3769: GO 3786
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3771: LD_EXP 20
3775: PPUSH
3776: LD_INT 45
3778: PPUSH
3779: LD_INT 5
3781: PPUSH
3782: CALL_OW 114
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 45 , 5 ) < 10 ;
3786: LD_EXP 20
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: PPUSH
3795: LD_INT 45
3797: PPUSH
3798: LD_INT 5
3800: PPUSH
3801: CALL_OW 297
3805: PUSH
3806: LD_INT 10
3808: LESS
3809: IFFALSE 3696
// end ;
3811: PPOPN 1
3813: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 6 ] ] ) and Difficulty = 1 do
3814: LD_INT 22
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 92
3826: PUSH
3827: LD_INT 80
3829: PUSH
3830: LD_INT 83
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PPUSH
3846: CALL_OW 69
3850: PUSH
3851: LD_OWVAR 67
3855: PUSH
3856: LD_INT 1
3858: EQUAL
3859: AND
3860: IFFALSE 3941
3862: GO 3864
3864: DISABLE
// begin PlaceSeeing ( 80 , 83 , 1 , - 7 ) ;
3865: LD_INT 80
3867: PPUSH
3868: LD_INT 83
3870: PPUSH
3871: LD_INT 1
3873: PPUSH
3874: LD_INT 7
3876: NEG
3877: PPUSH
3878: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
3882: LD_INT 35
3884: PPUSH
3885: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 10 ] ] ) ;
3889: LD_INT 22
3891: PUSH
3892: LD_INT 3
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PUSH
3899: LD_INT 92
3901: PUSH
3902: LD_INT 80
3904: PUSH
3905: LD_INT 83
3907: PUSH
3908: LD_INT 10
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: PPUSH
3921: CALL_OW 69
3925: NOT
3926: IFFALSE 3882
// RemoveSeeing ( 80 , 83 , 1 ) ;
3928: LD_INT 80
3930: PPUSH
3931: LD_INT 83
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 331
// end ;
3941: END
// every 0 0$02 trigger GetDistUnits ( JMM , Bobby ) < 9 do
3942: LD_EXP 15
3946: PPUSH
3947: LD_EXP 16
3951: PPUSH
3952: CALL_OW 296
3956: PUSH
3957: LD_INT 9
3959: LESS
3960: IFFALSE 4411
3962: GO 3964
3964: DISABLE
// begin ComWalk ( Bobby ) ;
3965: LD_EXP 16
3969: PPUSH
3970: CALL_OW 138
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
3974: LD_EXP 16
3978: PPUSH
3979: LD_EXP 15
3983: PPUSH
3984: CALL_OW 250
3988: PPUSH
3989: LD_EXP 15
3993: PPUSH
3994: CALL_OW 251
3998: PPUSH
3999: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
4003: LD_INT 35
4005: PPUSH
4006: CALL_OW 67
// until See ( 4 , JMM ) ;
4010: LD_INT 4
4012: PPUSH
4013: LD_EXP 15
4017: PPUSH
4018: CALL_OW 292
4022: IFFALSE 4003
// InGameOn ;
4024: CALL_OW 8
// ComTurnUnit ( JMM , Bobby ) ;
4028: LD_EXP 15
4032: PPUSH
4033: LD_EXP 16
4037: PPUSH
4038: CALL_OW 119
// if cyrus_in_squad and IsOk ( Cyrus ) and GetDistUnits ( JMM , Cyrus ) < 10 then
4042: LD_EXP 7
4046: PUSH
4047: LD_EXP 17
4051: PPUSH
4052: CALL_OW 302
4056: AND
4057: PUSH
4058: LD_EXP 15
4062: PPUSH
4063: LD_EXP 17
4067: PPUSH
4068: CALL_OW 296
4072: PUSH
4073: LD_INT 10
4075: LESS
4076: AND
4077: IFFALSE 4122
// begin ComMoveXY ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4079: LD_EXP 17
4083: PPUSH
4084: LD_EXP 15
4088: PPUSH
4089: CALL_OW 250
4093: PPUSH
4094: LD_EXP 15
4098: PPUSH
4099: CALL_OW 251
4103: PPUSH
4104: CALL_OW 111
// AddComTurnUnit ( Cyrus , Bobby ) ;
4108: LD_EXP 17
4112: PPUSH
4113: LD_EXP 16
4117: PPUSH
4118: CALL_OW 179
// end ; Say ( JMM , D2-JMM-1 ) ;
4122: LD_EXP 15
4126: PPUSH
4127: LD_STRING D2-JMM-1
4129: PPUSH
4130: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4134: LD_INT 10
4136: PPUSH
4137: CALL_OW 67
// ComTurnUnit ( Bobby , JMM ) ;
4141: LD_EXP 16
4145: PPUSH
4146: LD_EXP 15
4150: PPUSH
4151: CALL_OW 119
// Say ( Bobby , D2-Bobby-1 ) ;
4155: LD_EXP 16
4159: PPUSH
4160: LD_STRING D2-Bobby-1
4162: PPUSH
4163: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
4167: LD_EXP 15
4171: PPUSH
4172: LD_STRING D2-JMM-2
4174: PPUSH
4175: CALL_OW 88
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4179: LD_EXP 16
4183: PPUSH
4184: LD_EXP 15
4188: PPUSH
4189: CALL_OW 250
4193: PPUSH
4194: LD_EXP 15
4198: PPUSH
4199: CALL_OW 251
4203: PPUSH
4204: CALL_OW 111
// Say ( Bobby , D2-Bobby-2 ) ;
4208: LD_EXP 16
4212: PPUSH
4213: LD_STRING D2-Bobby-2
4215: PPUSH
4216: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
4220: LD_EXP 15
4224: PPUSH
4225: LD_STRING D2-JMM-3
4227: PPUSH
4228: CALL_OW 88
// ComTurnUnit ( Bobby , JMM ) ;
4232: LD_EXP 16
4236: PPUSH
4237: LD_EXP 15
4241: PPUSH
4242: CALL_OW 119
// Say ( Bobby , D2-Bobby-3 ) ;
4246: LD_EXP 16
4250: PPUSH
4251: LD_STRING D2-Bobby-3
4253: PPUSH
4254: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
4258: LD_EXP 15
4262: PPUSH
4263: LD_STRING D2-JMM-4
4265: PPUSH
4266: CALL_OW 88
// Say ( Bobby , D2-Bobby-4 ) ;
4270: LD_EXP 16
4274: PPUSH
4275: LD_STRING D2-Bobby-4
4277: PPUSH
4278: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
4282: LD_EXP 15
4286: PPUSH
4287: LD_STRING D2-JMM-5
4289: PPUSH
4290: CALL_OW 88
// Say ( Bobby , D2-Bobby-5 ) ;
4294: LD_EXP 16
4298: PPUSH
4299: LD_STRING D2-Bobby-5
4301: PPUSH
4302: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
4306: LD_EXP 15
4310: PPUSH
4311: LD_STRING D2-JMM-6
4313: PPUSH
4314: CALL_OW 88
// if not powell_contact then
4318: LD_EXP 5
4322: NOT
4323: IFFALSE 4349
// begin Say ( Bobby , D2-Bobby-6 ) ;
4325: LD_EXP 16
4329: PPUSH
4330: LD_STRING D2-Bobby-6
4332: PPUSH
4333: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4337: LD_EXP 15
4341: PPUSH
4342: LD_STRING D2-JMM-7
4344: PPUSH
4345: CALL_OW 88
// end ; InGameOff ;
4349: CALL_OW 9
// SetSide ( Bobby , 1 ) ;
4353: LD_EXP 16
4357: PPUSH
4358: LD_INT 1
4360: PPUSH
4361: CALL_OW 235
// ComFree ( [ JMM , Bobby ] ) ;
4365: LD_EXP 15
4369: PUSH
4370: LD_EXP 16
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PPUSH
4379: CALL_OW 139
// bobby_in_squad := true ;
4383: LD_ADDR_EXP 4
4387: PUSH
4388: LD_INT 1
4390: ST_TO_ADDR
// if powell_contact and not cyrus_in_squad then
4391: LD_EXP 5
4395: PUSH
4396: LD_EXP 7
4400: NOT
4401: AND
4402: IFFALSE 4411
// ChangeMissionObjectives ( M2b ) ;
4404: LD_STRING M2b
4406: PPUSH
4407: CALL_OW 337
// end ;
4411: END
// every 0 0$45 trigger active_russian_dialog and not bobby_in_squad and Difficulty < 3 do
4412: LD_EXP 3
4416: PUSH
4417: LD_EXP 4
4421: NOT
4422: AND
4423: PUSH
4424: LD_OWVAR 67
4428: PUSH
4429: LD_INT 3
4431: LESS
4432: AND
4433: IFFALSE 4453
4435: GO 4437
4437: DISABLE
// ComMoveXY ( Bobby , 75 , 83 ) ;
4438: LD_EXP 16
4442: PPUSH
4443: LD_INT 75
4445: PPUSH
4446: LD_INT 83
4448: PPUSH
4449: CALL_OW 111
4453: END
// every 0 0$10 trigger cyrus_in_squad and not bobby_in_squad do
4454: LD_EXP 7
4458: PUSH
4459: LD_EXP 4
4463: NOT
4464: AND
4465: IFFALSE 4494
4467: GO 4469
4469: DISABLE
// begin ComMoveXY ( Bobby , 105 , 97 ) ;
4470: LD_EXP 16
4474: PPUSH
4475: LD_INT 105
4477: PPUSH
4478: LD_INT 97
4480: PPUSH
4481: CALL_OW 111
// AddComCrawl ( Bobby ) ;
4485: LD_EXP 16
4489: PPUSH
4490: CALL_OW 197
// end ;
4494: END
// every 0 0$01 trigger IsInArea ( JMM , obstacle_area ) and GetDistUnits ( JMM , Bobby ) < 7 and bobby_in_squad do
4495: LD_EXP 15
4499: PPUSH
4500: LD_INT 6
4502: PPUSH
4503: CALL_OW 308
4507: PUSH
4508: LD_EXP 15
4512: PPUSH
4513: LD_EXP 16
4517: PPUSH
4518: CALL_OW 296
4522: PUSH
4523: LD_INT 7
4525: LESS
4526: AND
4527: PUSH
4528: LD_EXP 4
4532: AND
4533: IFFALSE 4580
4535: GO 4537
4537: DISABLE
// begin ComHold ( [ JMM , Bobby ] ) ;
4538: LD_EXP 15
4542: PUSH
4543: LD_EXP 16
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: PPUSH
4552: CALL_OW 140
// Say ( JMM , D2a-JMM-1 ) ;
4556: LD_EXP 15
4560: PPUSH
4561: LD_STRING D2a-JMM-1
4563: PPUSH
4564: CALL_OW 88
// Say ( Bobby , D2a-Bobby-1 ) ;
4568: LD_EXP 16
4572: PPUSH
4573: LD_STRING D2a-Bobby-1
4575: PPUSH
4576: CALL_OW 88
// end ;
4580: END
// every 0 0$50 trigger active_russian_dialog and not See ( 3 , JMM ) do
4581: LD_EXP 3
4585: PUSH
4586: LD_INT 3
4588: PPUSH
4589: LD_EXP 15
4593: PPUSH
4594: CALL_OW 292
4598: NOT
4599: AND
4600: IFFALSE 4776
4602: GO 4604
4604: DISABLE
// begin Wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
4605: LD_INT 350
4607: PPUSH
4608: LD_INT 700
4610: PPUSH
4611: CALL_OW 12
4615: PPUSH
4616: CALL_OW 67
// InGameOn ;
4620: CALL_OW 8
// DialogueOn ;
4624: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4628: LD_EXP 18
4632: PPUSH
4633: LD_STRING D3-Pow-1
4635: PPUSH
4636: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
4640: LD_EXP 15
4644: PPUSH
4645: LD_STRING D3-JMM-1
4647: PPUSH
4648: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4652: LD_EXP 18
4656: PPUSH
4657: LD_STRING D3-Pow-2
4659: PPUSH
4660: CALL_OW 94
// Say ( JMM , D3-JMM-2 ) ;
4664: LD_EXP 15
4668: PPUSH
4669: LD_STRING D3-JMM-2
4671: PPUSH
4672: CALL_OW 88
// SayRadio ( Powell , D3-Pow-3 ) ;
4676: LD_EXP 18
4680: PPUSH
4681: LD_STRING D3-Pow-3
4683: PPUSH
4684: CALL_OW 94
// DialogueOff ;
4688: CALL_OW 7
// InGameOff ;
4692: CALL_OW 9
// powell_contact := true ;
4696: LD_ADDR_EXP 5
4700: PUSH
4701: LD_INT 1
4703: ST_TO_ADDR
// SetAreaMapShow ( exitArea , 1 ) ;
4704: LD_INT 10
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 424
// uc_side := 4 ;
4714: LD_ADDR_OWVAR 20
4718: PUSH
4719: LD_INT 4
4721: ST_TO_ADDR
// uc_nation := 1 ;
4722: LD_ADDR_OWVAR 21
4726: PUSH
4727: LD_INT 1
4729: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
4730: LD_ADDR_EXP 18
4734: PUSH
4735: LD_STRING Powell
4737: PPUSH
4738: LD_INT 0
4740: PPUSH
4741: CALL 189 0 2
4745: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
4746: LD_STRING M2
4748: PPUSH
4749: CALL_OW 337
// if not bobby_in_squad then
4753: LD_EXP 4
4757: NOT
4758: IFFALSE 4769
// ChangeMissionObjectives ( M2a ) else
4760: LD_STRING M2a
4762: PPUSH
4763: CALL_OW 337
4767: GO 4776
// ChangeMissionObjectives ( M2b ) ;
4769: LD_STRING M2b
4771: PPUSH
4772: CALL_OW 337
// end ;
4776: END
// every 0 0$01 trigger IsInArea ( JMM , fakeArea ) do
4777: LD_EXP 15
4781: PPUSH
4782: LD_INT 7
4784: PPUSH
4785: CALL_OW 308
4789: IFFALSE 4924
4791: GO 4793
4793: DISABLE
// begin DialogueOn ;
4794: CALL_OW 6
// SayRadio ( fakePokryshkin , D4-Rus3-1 ) ;
4798: LD_EXP 19
4802: PPUSH
4803: LD_STRING D4-Rus3-1
4805: PPUSH
4806: CALL_OW 94
// DialogueOff ;
4810: CALL_OW 7
// ChangeMissionObjectives ( M3a ) ;
4814: LD_STRING M3a
4816: PPUSH
4817: CALL_OW 337
// SetAreaMapShow ( fakeEnd , 1 ) ;
4821: LD_INT 11
4823: PPUSH
4824: LD_INT 1
4826: PPUSH
4827: CALL_OW 424
// Wait ( 0 0$02 ) ;
4831: LD_INT 70
4833: PPUSH
4834: CALL_OW 67
// DialogueOn ;
4838: CALL_OW 6
// SayRadio ( Powell , D4-Pow-1 ) ;
4842: LD_EXP 18
4846: PPUSH
4847: LD_STRING D4-Pow-1
4849: PPUSH
4850: CALL_OW 94
// DialogueOff ;
4854: CALL_OW 7
// ChangeMissionObjectives ( M3b ) ;
4858: LD_STRING M3b
4860: PPUSH
4861: CALL_OW 337
// case Query ( Q1 ) of 1 :
4865: LD_STRING Q1
4867: PPUSH
4868: CALL_OW 97
4872: PUSH
4873: LD_INT 1
4875: DOUBLE
4876: EQUAL
4877: IFTRUE 4881
4879: GO 4912
4881: POP
// begin macmilan_use_radio := true ;
4882: LD_ADDR_EXP 6
4886: PUSH
4887: LD_INT 1
4889: ST_TO_ADDR
// DialogueOn ;
4890: CALL_OW 6
// Say ( JMM , D4a-JMM-1 ) ;
4894: LD_EXP 15
4898: PPUSH
4899: LD_STRING D4a-JMM-1
4901: PPUSH
4902: CALL_OW 88
// DialogueOff ;
4906: CALL_OW 7
// end ; 2 :
4910: GO 4924
4912: LD_INT 2
4914: DOUBLE
4915: EQUAL
4916: IFTRUE 4920
4918: GO 4923
4920: POP
// ; end ;
4921: GO 4924
4923: POP
// end ;
4924: END
// every 0 0$02 trigger GetDistUnits ( JMM , Cyrus ) < 8 do
4925: LD_EXP 15
4929: PPUSH
4930: LD_EXP 17
4934: PPUSH
4935: CALL_OW 296
4939: PUSH
4940: LD_INT 8
4942: LESS
4943: IFFALSE 5234
4945: GO 4947
4947: DISABLE
// begin InGameOn ;
4948: CALL_OW 8
// ComMoveXY ( JMM , GetX ( Cyrus ) , GetY ( Cyrus ) ) ;
4952: LD_EXP 15
4956: PPUSH
4957: LD_EXP 17
4961: PPUSH
4962: CALL_OW 250
4966: PPUSH
4967: LD_EXP 17
4971: PPUSH
4972: CALL_OW 251
4976: PPUSH
4977: CALL_OW 111
// if IsOk ( Bobby ) and bobby_in_squad then
4981: LD_EXP 16
4985: PPUSH
4986: CALL_OW 302
4990: PUSH
4991: LD_EXP 4
4995: AND
4996: IFFALSE 5027
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4998: LD_EXP 16
5002: PPUSH
5003: LD_EXP 15
5007: PPUSH
5008: CALL_OW 250
5012: PPUSH
5013: LD_EXP 15
5017: PPUSH
5018: CALL_OW 251
5022: PPUSH
5023: CALL_OW 111
// Say ( JMM , D5-JMM-1 ) ;
5027: LD_EXP 15
5031: PPUSH
5032: LD_STRING D5-JMM-1
5034: PPUSH
5035: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5039: LD_INT 10
5041: PPUSH
5042: CALL_OW 67
// ComTurnUnit ( JMM , Cyrus ) ;
5046: LD_EXP 15
5050: PPUSH
5051: LD_EXP 17
5055: PPUSH
5056: CALL_OW 119
// ComWalk ( Cyrus ) ;
5060: LD_EXP 17
5064: PPUSH
5065: CALL_OW 138
// ComTurnUnit ( Cyrus , JMM ) ;
5069: LD_EXP 17
5073: PPUSH
5074: LD_EXP 15
5078: PPUSH
5079: CALL_OW 119
// Say ( Cyrus , D5-Cyrus-1 ) ;
5083: LD_EXP 17
5087: PPUSH
5088: LD_STRING D5-Cyrus-1
5090: PPUSH
5091: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5095: LD_EXP 16
5099: PPUSH
5100: CALL_OW 302
5104: PUSH
5105: LD_EXP 4
5109: AND
5110: IFFALSE 5150
// begin ComTurnUnit ( Bobby , Cyrus ) ;
5112: LD_EXP 16
5116: PPUSH
5117: LD_EXP 17
5121: PPUSH
5122: CALL_OW 119
// Say ( Bobby , D5-Bobby-1 ) ;
5126: LD_EXP 16
5130: PPUSH
5131: LD_STRING D5-Bobby-1
5133: PPUSH
5134: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
5138: LD_EXP 15
5142: PPUSH
5143: LD_STRING D5-JMM-2
5145: PPUSH
5146: CALL_OW 88
// end ; InGameOff ;
5150: CALL_OW 9
// cyrus_in_squad := true ;
5154: LD_ADDR_EXP 7
5158: PUSH
5159: LD_INT 1
5161: ST_TO_ADDR
// SetSide ( Cyrus , 1 ) ;
5162: LD_EXP 17
5166: PPUSH
5167: LD_INT 1
5169: PPUSH
5170: CALL_OW 235
// if powell_contact and not bobby_in_squad then
5174: LD_EXP 5
5178: PUSH
5179: LD_EXP 4
5183: NOT
5184: AND
5185: IFFALSE 5194
// ChangeMissionObjectives ( M2b ) ;
5187: LD_STRING M2b
5189: PPUSH
5190: CALL_OW 337
// if not bobby_in_squad and GetSide ( Bobby ) = 4 and IsOk ( Bobby ) then
5194: LD_EXP 4
5198: NOT
5199: PUSH
5200: LD_EXP 16
5204: PPUSH
5205: CALL_OW 255
5209: PUSH
5210: LD_INT 4
5212: EQUAL
5213: AND
5214: PUSH
5215: LD_EXP 16
5219: PPUSH
5220: CALL_OW 302
5224: AND
5225: IFFALSE 5234
// SetAchievement ( ACH_CYRUS ) ;
5227: LD_STRING ACH_CYRUS
5229: PPUSH
5230: CALL_OW 543
// end ;
5234: END
// every 0 0$01 trigger bobby_in_squad and cyrus_in_squad do
5235: LD_EXP 4
5239: PUSH
5240: LD_EXP 7
5244: AND
5245: IFFALSE 5257
5247: GO 5249
5249: DISABLE
// ChangeMissionObjectives ( M2c ) ;
5250: LD_STRING M2c
5252: PPUSH
5253: CALL_OW 337
5257: END
// every 0 0$01 trigger IsInArea ( JMM , trap ) do
5258: LD_EXP 15
5262: PPUSH
5263: LD_INT 8
5265: PPUSH
5266: CALL_OW 308
5270: IFFALSE 5322
5272: GO 5274
5274: DISABLE
// begin macmilan_in_trap := true ;
5275: LD_ADDR_EXP 9
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5283: LD_INT 35
5285: PPUSH
5286: CALL_OW 67
// DialogueOn ;
5290: CALL_OW 6
// Say ( Pokryshkin , D5-Pok-1 ) ;
5294: LD_EXP 25
5298: PPUSH
5299: LD_STRING D5-Pok-1
5301: PPUSH
5302: CALL_OW 88
// DialogueOff ;
5306: CALL_OW 7
// Say ( JMM , D4b-JMM-1 ) ;
5310: LD_EXP 15
5314: PPUSH
5315: LD_STRING D4b-JMM-1
5317: PPUSH
5318: CALL_OW 88
// end ;
5322: END
// every 0 0$01 trigger GetDistUnits ( JMM , russian_meta_guards [ russian_meta_guards ] ) < 12 or UnitFilter ( russian_meta_guards , [ f_not , [ f_lives , 990 ] ] ) do var i , hp ;
5323: LD_EXP 15
5327: PPUSH
5328: LD_EXP 23
5332: PUSH
5333: LD_EXP 23
5337: ARRAY
5338: PPUSH
5339: CALL_OW 296
5343: PUSH
5344: LD_INT 12
5346: LESS
5347: PUSH
5348: LD_EXP 23
5352: PPUSH
5353: LD_INT 3
5355: PUSH
5356: LD_INT 24
5358: PUSH
5359: LD_INT 990
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PPUSH
5370: CALL_OW 72
5374: OR
5375: IFFALSE 5605
5377: GO 5379
5379: DISABLE
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
// begin hp := [ 300 , 250 , 200 ] [ Difficulty ] ;
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_INT 300
5391: PUSH
5392: LD_INT 250
5394: PUSH
5395: LD_INT 200
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: LIST
5402: PUSH
5403: LD_OWVAR 67
5407: ARRAY
5408: ST_TO_ADDR
// for i in russian_meta_guards do
5409: LD_ADDR_VAR 0 1
5413: PUSH
5414: LD_EXP 23
5418: PUSH
5419: FOR_IN
5420: IFFALSE 5460
// if IsOk ( i ) then
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 302
5431: IFFALSE 5458
// SetLives ( i , GetLives ( i ) - hp ) ;
5433: LD_VAR 0 1
5437: PPUSH
5438: LD_VAR 0 1
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_VAR 0 2
5452: MINUS
5453: PPUSH
5454: CALL_OW 234
5458: GO 5419
5460: POP
5461: POP
// DialogueOn ;
5462: CALL_OW 6
// Say ( russian_meta_guards [ russian_meta_guards ] , D6-FRus1-1 ) ;
5466: LD_EXP 23
5470: PUSH
5471: LD_EXP 23
5475: ARRAY
5476: PPUSH
5477: LD_STRING D6-FRus1-1
5479: PPUSH
5480: CALL_OW 88
// Say ( JMM , D6-JMM-1 ) ;
5484: LD_EXP 15
5488: PPUSH
5489: LD_STRING D6-JMM-1
5491: PPUSH
5492: CALL_OW 88
// if IsOk ( Cyrus ) and cyrus_in_squad then
5496: LD_EXP 17
5500: PPUSH
5501: CALL_OW 302
5505: PUSH
5506: LD_EXP 7
5510: AND
5511: IFFALSE 5525
// Say ( Cyrus , D6-Cyrus-1 ) ;
5513: LD_EXP 17
5517: PPUSH
5518: LD_STRING D6-Cyrus-1
5520: PPUSH
5521: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5525: LD_EXP 16
5529: PPUSH
5530: CALL_OW 302
5534: PUSH
5535: LD_EXP 4
5539: AND
5540: IFFALSE 5554
// Say ( Bobby , D6-Bobby-1 ) ;
5542: LD_EXP 16
5546: PPUSH
5547: LD_STRING D6-Bobby-1
5549: PPUSH
5550: CALL_OW 88
// DialogueOff ;
5554: CALL_OW 7
// Wait ( [ 0 0$04 , 0 0$03 , 0 0$02 ] [ Difficulty ] ) ;
5558: LD_INT 140
5560: PUSH
5561: LD_INT 105
5563: PUSH
5564: LD_INT 70
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: LD_OWVAR 67
5576: ARRAY
5577: PPUSH
5578: CALL_OW 67
// meta_action := true ;
5582: LD_ADDR_EXP 10
5586: PUSH
5587: LD_INT 1
5589: ST_TO_ADDR
// ComAgressiveMove ( russian_meta_guards , 94 , 8 ) ;
5590: LD_EXP 23
5594: PPUSH
5595: LD_INT 94
5597: PPUSH
5598: LD_INT 8
5600: PPUSH
5601: CALL_OW 114
// end ;
5605: PPOPN 2
5607: END
// every 0 0$01 trigger GetDistUnitXY ( JMM , 93 , 1 ) < 5 and FilterAllUnits ( [ f_side , 1 ] ) > 1 do
5608: LD_EXP 15
5612: PPUSH
5613: LD_INT 93
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 297
5623: PUSH
5624: LD_INT 5
5626: LESS
5627: PUSH
5628: LD_INT 22
5630: PUSH
5631: LD_INT 1
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: PPUSH
5638: CALL_OW 69
5642: PUSH
5643: LD_INT 1
5645: GREATER
5646: AND
5647: IFFALSE 5664
5649: GO 5651
5651: DISABLE
// Say ( JMM , D6a-JMM-1 ) ;
5652: LD_EXP 15
5656: PPUSH
5657: LD_STRING D6a-JMM-1
5659: PPUSH
5660: CALL_OW 88
5664: END
// on UnitGoesToRed ( un ) do begin if un = JMM then
5665: LD_VAR 0 1
5669: PUSH
5670: LD_EXP 15
5674: EQUAL
5675: IFFALSE 5684
// YouLost ( JMM ) ;
5677: LD_STRING JMM
5679: PPUSH
5680: CALL_OW 104
// end ;
5684: PPOPN 1
5686: END
// on UnitDestroyed ( un ) do begin if un = JMM then
5687: LD_VAR 0 1
5691: PUSH
5692: LD_EXP 15
5696: EQUAL
5697: IFFALSE 5706
// YouLost ( JMM ) ;
5699: LD_STRING JMM
5701: PPUSH
5702: CALL_OW 104
// end ;
5706: PPOPN 1
5708: END
// every 0 0$01 trigger IsInArea ( Bobby , exitArea ) do
5709: LD_EXP 16
5713: PPUSH
5714: LD_INT 10
5716: PPUSH
5717: CALL_OW 308
5721: IFFALSE 5770
5723: GO 5725
5725: DISABLE
// begin bobby_saved := true ;
5726: LD_ADDR_EXP 12
5730: PUSH
5731: LD_INT 1
5733: ST_TO_ADDR
// SaveVariable ( GetLives ( Bobby ) , 01_BobbyLifePoints_1 ) ;
5734: LD_EXP 16
5738: PPUSH
5739: CALL_OW 256
5743: PPUSH
5744: LD_STRING 01_BobbyLifePoints_1
5746: PPUSH
5747: CALL_OW 39
// RemoveUnit ( Bobby ) ;
5751: LD_EXP 16
5755: PPUSH
5756: CALL_OW 64
// AddMedal ( Bobby , 1 ) ;
5760: LD_STRING Bobby
5762: PPUSH
5763: LD_INT 1
5765: PPUSH
5766: CALL_OW 101
// end ;
5770: END
// every 0 0$01 trigger IsInArea ( Cyrus , exitArea ) do
5771: LD_EXP 17
5775: PPUSH
5776: LD_INT 10
5778: PPUSH
5779: CALL_OW 308
5783: IFFALSE 5832
5785: GO 5787
5787: DISABLE
// begin cyrus_saved := true ;
5788: LD_ADDR_EXP 13
5792: PUSH
5793: LD_INT 1
5795: ST_TO_ADDR
// SaveVariable ( GetLives ( Cyrus ) , 01_CyrusLifePoints_1 ) ;
5796: LD_EXP 17
5800: PPUSH
5801: CALL_OW 256
5805: PPUSH
5806: LD_STRING 01_CyrusLifePoints_1
5808: PPUSH
5809: CALL_OW 39
// RemoveUnit ( Cyrus ) ;
5813: LD_EXP 17
5817: PPUSH
5818: CALL_OW 64
// AddMedal ( Cyrus , 1 ) ;
5822: LD_STRING Cyrus
5824: PPUSH
5825: LD_INT 1
5827: PPUSH
5828: CALL_OW 101
// end ;
5832: END
// every 0 0$01 trigger IsInArea ( JMM , exitArea ) do var i , to_reward , wait_for_them , m1 , m2 , m3 ;
5833: LD_EXP 15
5837: PPUSH
5838: LD_INT 10
5840: PPUSH
5841: CALL_OW 308
5845: IFFALSE 6453
5847: GO 5849
5849: DISABLE
5850: LD_INT 0
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
// begin if macmilan_use_radio then
5858: LD_EXP 6
5862: IFFALSE 5871
// SetAchievement ( ACH_RADIO ) ;
5864: LD_STRING ACH_RADIO
5866: PPUSH
5867: CALL_OW 543
// if ( not cyrus_saved and cyrus_in_squad and IsOk ( Cyrus ) ) or ( not bobby_saved and bobby_in_squad and IsOk ( Bobby ) ) then
5871: LD_EXP 13
5875: NOT
5876: PUSH
5877: LD_EXP 7
5881: AND
5882: PUSH
5883: LD_EXP 17
5887: PPUSH
5888: CALL_OW 302
5892: AND
5893: PUSH
5894: LD_EXP 12
5898: NOT
5899: PUSH
5900: LD_EXP 4
5904: AND
5905: PUSH
5906: LD_EXP 16
5910: PPUSH
5911: CALL_OW 302
5915: AND
5916: OR
5917: IFFALSE 5958
// case Query ( Q2 ) of 1 :
5919: LD_STRING Q2
5921: PPUSH
5922: CALL_OW 97
5926: PUSH
5927: LD_INT 1
5929: DOUBLE
5930: EQUAL
5931: IFTRUE 5935
5933: GO 5946
5935: POP
// wait_for_them := true ; 2 :
5936: LD_ADDR_VAR 0 3
5940: PUSH
5941: LD_INT 1
5943: ST_TO_ADDR
5944: GO 5958
5946: LD_INT 2
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5954
5952: GO 5957
5954: POP
// ; end ;
5955: GO 5958
5957: POP
// if wait_for_them then
5958: LD_VAR 0 3
5962: IFFALSE 6075
// repeat wait ( 0 0$01 ) ;
5964: LD_INT 35
5966: PPUSH
5967: CALL_OW 67
// until ( cyrus_saved and bobby_saved ) or ( cyrus_saved and ( not bobby_in_squad or IsDying ( Bobby ) or IsDead ( Bobby ) ) ) or ( bobby_saved and ( not cyrus_in_squad or IsDying ( Cyrus ) or IsDead ( Cyrus ) ) ) or ( IsDead ( Bobby ) and IsDead ( Cyrus ) ) ;
5971: LD_EXP 13
5975: PUSH
5976: LD_EXP 12
5980: AND
5981: PUSH
5982: LD_EXP 13
5986: PUSH
5987: LD_EXP 4
5991: NOT
5992: PUSH
5993: LD_EXP 16
5997: PPUSH
5998: CALL_OW 303
6002: OR
6003: PUSH
6004: LD_EXP 16
6008: PPUSH
6009: CALL_OW 301
6013: OR
6014: AND
6015: OR
6016: PUSH
6017: LD_EXP 12
6021: PUSH
6022: LD_EXP 7
6026: NOT
6027: PUSH
6028: LD_EXP 17
6032: PPUSH
6033: CALL_OW 303
6037: OR
6038: PUSH
6039: LD_EXP 17
6043: PPUSH
6044: CALL_OW 301
6048: OR
6049: AND
6050: OR
6051: PUSH
6052: LD_EXP 16
6056: PPUSH
6057: CALL_OW 301
6061: PUSH
6062: LD_EXP 17
6066: PPUSH
6067: CALL_OW 301
6071: AND
6072: OR
6073: IFFALSE 5964
// SaveVariable ( GetLives ( JMM ) , 01_JMMLifePoints_1 ) ;
6075: LD_EXP 15
6079: PPUSH
6080: CALL_OW 256
6084: PPUSH
6085: LD_STRING 01_JMMLifePoints_1
6087: PPUSH
6088: CALL_OW 39
// RemoveUnit ( JMM ) ;
6092: LD_EXP 15
6096: PPUSH
6097: CALL_OW 64
// to_reward := [ JMM ] ;
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_EXP 15
6110: PUSH
6111: EMPTY
6112: LIST
6113: ST_TO_ADDR
// if bobby_saved then
6114: LD_EXP 12
6118: IFFALSE 6136
// to_reward := to_reward ^ Bobby ;
6120: LD_ADDR_VAR 0 2
6124: PUSH
6125: LD_VAR 0 2
6129: PUSH
6130: LD_EXP 16
6134: ADD
6135: ST_TO_ADDR
// if cyrus_saved then
6136: LD_EXP 13
6140: IFFALSE 6158
// to_reward := to_reward ^ Cyrus ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_EXP 17
6156: ADD
6157: ST_TO_ADDR
// m1 := true ;
6158: LD_ADDR_VAR 0 4
6162: PUSH
6163: LD_INT 1
6165: ST_TO_ADDR
// m2 := bobby_saved ;
6166: LD_ADDR_VAR 0 5
6170: PUSH
6171: LD_EXP 12
6175: ST_TO_ADDR
// m3 := cyrus_saved ;
6176: LD_ADDR_VAR 0 6
6180: PUSH
6181: LD_EXP 13
6185: ST_TO_ADDR
// AddMedal ( JMM , 1 ) ;
6186: LD_STRING JMM
6188: PPUSH
6189: LD_INT 1
6191: PPUSH
6192: CALL_OW 101
// if not bobby_in_squad then
6196: LD_EXP 4
6200: NOT
6201: IFFALSE 6214
// AddMedal ( Bobby , - 1 ) ;
6203: LD_STRING Bobby
6205: PPUSH
6206: LD_INT 1
6208: NEG
6209: PPUSH
6210: CALL_OW 101
// if not bobby_saved and ( IsDying ( Bobby ) or IsDead ( Bobby ) ) then
6214: LD_EXP 12
6218: NOT
6219: PUSH
6220: LD_EXP 16
6224: PPUSH
6225: CALL_OW 303
6229: PUSH
6230: LD_EXP 16
6234: PPUSH
6235: CALL_OW 301
6239: OR
6240: AND
6241: IFFALSE 6254
// AddMedal ( Bobby , - 2 ) ;
6243: LD_STRING Bobby
6245: PPUSH
6246: LD_INT 2
6248: NEG
6249: PPUSH
6250: CALL_OW 101
// if not cyrus_in_squad then
6254: LD_EXP 7
6258: NOT
6259: IFFALSE 6272
// AddMedal ( Cyrus , - 1 ) ;
6261: LD_STRING Cyrus
6263: PPUSH
6264: LD_INT 1
6266: NEG
6267: PPUSH
6268: CALL_OW 101
// if not cyrus_saved and ( IsDying ( Cyrus ) or IsDead ( Cyrus ) ) then
6272: LD_EXP 13
6276: NOT
6277: PUSH
6278: LD_EXP 17
6282: PPUSH
6283: CALL_OW 303
6287: PUSH
6288: LD_EXP 17
6292: PPUSH
6293: CALL_OW 301
6297: OR
6298: AND
6299: IFFALSE 6312
// AddMedal ( Cyrus , - 2 ) ;
6301: LD_STRING Cyrus
6303: PPUSH
6304: LD_INT 2
6306: NEG
6307: PPUSH
6308: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
6312: LD_OWVAR 67
6316: PUSH
6317: LD_INT 3
6319: EQUAL
6320: PUSH
6321: LD_VAR 0 4
6325: AND
6326: PUSH
6327: LD_VAR 0 5
6331: AND
6332: PUSH
6333: LD_VAR 0 6
6337: AND
6338: IFFALSE 6350
// SetAchievementEX ( ACH_AMER , 1 ) ;
6340: LD_STRING ACH_AMER
6342: PPUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL_OW 564
// GiveMedals ( MAIN ) ;
6350: LD_STRING MAIN
6352: PPUSH
6353: CALL_OW 102
// RewardPeople ( to_reward ) ;
6357: LD_VAR 0 2
6361: PPUSH
6362: CALL_OW 43
// if bobby_saved then
6366: LD_EXP 12
6370: IFFALSE 6390
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
6372: LD_EXP 16
6376: PPUSH
6377: LD_EXP 2
6381: PUSH
6382: LD_STRING Bobby
6384: STR
6385: PPUSH
6386: CALL_OW 38
// if cyrus_saved then
6390: LD_EXP 13
6394: IFFALSE 6414
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
6396: LD_EXP 17
6400: PPUSH
6401: LD_EXP 2
6405: PUSH
6406: LD_STRING Cyrus
6408: STR
6409: PPUSH
6410: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
6414: LD_EXP 15
6418: PPUSH
6419: LD_EXP 2
6423: PUSH
6424: LD_STRING JMM
6426: STR
6427: PPUSH
6428: CALL_OW 38
// if tick <= 3 3$00 then
6432: LD_OWVAR 1
6436: PUSH
6437: LD_INT 6300
6439: LESSEQUAL
6440: IFFALSE 6449
// SetAchievement ( ACH_ASPEED_1 ) ;
6442: LD_STRING ACH_ASPEED_1
6444: PPUSH
6445: CALL_OW 543
// YouWin ;
6449: CALL_OW 103
// end ; end_of_file end_of_file
6453: PPOPN 6
6455: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
6456: GO 6458
6458: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6459: LD_STRING initStreamRollete();
6461: PPUSH
6462: CALL_OW 559
// InitStreamMode ;
6466: CALL 6471 0 0
// end ;
6470: END
// function InitStreamMode ; begin
6471: LD_INT 0
6473: PPUSH
// streamModeActive := false ;
6474: LD_ADDR_EXP 26
6478: PUSH
6479: LD_INT 0
6481: ST_TO_ADDR
// sRocket := false ;
6482: LD_ADDR_EXP 29
6486: PUSH
6487: LD_INT 0
6489: ST_TO_ADDR
// sSpeed := false ;
6490: LD_ADDR_EXP 28
6494: PUSH
6495: LD_INT 0
6497: ST_TO_ADDR
// sEngine := false ;
6498: LD_ADDR_EXP 30
6502: PUSH
6503: LD_INT 0
6505: ST_TO_ADDR
// sSpec := false ;
6506: LD_ADDR_EXP 27
6510: PUSH
6511: LD_INT 0
6513: ST_TO_ADDR
// sLevel := false ;
6514: LD_ADDR_EXP 31
6518: PUSH
6519: LD_INT 0
6521: ST_TO_ADDR
// sArmoury := false ;
6522: LD_ADDR_EXP 32
6526: PUSH
6527: LD_INT 0
6529: ST_TO_ADDR
// sRadar := false ;
6530: LD_ADDR_EXP 33
6534: PUSH
6535: LD_INT 0
6537: ST_TO_ADDR
// sBunker := false ;
6538: LD_ADDR_EXP 34
6542: PUSH
6543: LD_INT 0
6545: ST_TO_ADDR
// sHack := false ;
6546: LD_ADDR_EXP 35
6550: PUSH
6551: LD_INT 0
6553: ST_TO_ADDR
// sFire := false ;
6554: LD_ADDR_EXP 36
6558: PUSH
6559: LD_INT 0
6561: ST_TO_ADDR
// sRefresh := false ;
6562: LD_ADDR_EXP 37
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// sExp := false ;
6570: LD_ADDR_EXP 38
6574: PUSH
6575: LD_INT 0
6577: ST_TO_ADDR
// sDepot := false ;
6578: LD_ADDR_EXP 39
6582: PUSH
6583: LD_INT 0
6585: ST_TO_ADDR
// sFlag := false ;
6586: LD_ADDR_EXP 40
6590: PUSH
6591: LD_INT 0
6593: ST_TO_ADDR
// sSold := false ;
6594: LD_ADDR_EXP 41
6598: PUSH
6599: LD_INT 0
6601: ST_TO_ADDR
// sDiff := false ;
6602: LD_ADDR_EXP 42
6606: PUSH
6607: LD_INT 0
6609: ST_TO_ADDR
// sTiger := false ;
6610: LD_ADDR_EXP 43
6614: PUSH
6615: LD_INT 0
6617: ST_TO_ADDR
// sBomb := false ;
6618: LD_ADDR_EXP 44
6622: PUSH
6623: LD_INT 0
6625: ST_TO_ADDR
// sFog := false ;
6626: LD_ADDR_EXP 45
6630: PUSH
6631: LD_INT 0
6633: ST_TO_ADDR
// sReset := false ;
6634: LD_ADDR_EXP 46
6638: PUSH
6639: LD_INT 0
6641: ST_TO_ADDR
// sSun := false ;
6642: LD_ADDR_EXP 47
6646: PUSH
6647: LD_INT 0
6649: ST_TO_ADDR
// end ;
6650: LD_VAR 0 1
6654: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
6655: LD_VAR 0 2
6659: PUSH
6660: LD_INT 100
6662: EQUAL
6663: IFFALSE 7072
// begin if not StreamModeActive then
6665: LD_EXP 26
6669: NOT
6670: IFFALSE 6680
// StreamModeActive := true ;
6672: LD_ADDR_EXP 26
6676: PUSH
6677: LD_INT 1
6679: ST_TO_ADDR
// if p3 = 0 then
6680: LD_VAR 0 3
6684: PUSH
6685: LD_INT 0
6687: EQUAL
6688: IFFALSE 6694
// InitStreamMode ;
6690: CALL 6471 0 0
// if p3 = 1 then
6694: LD_VAR 0 3
6698: PUSH
6699: LD_INT 1
6701: EQUAL
6702: IFFALSE 6712
// sRocket := true ;
6704: LD_ADDR_EXP 29
6708: PUSH
6709: LD_INT 1
6711: ST_TO_ADDR
// if p3 = 2 then
6712: LD_VAR 0 3
6716: PUSH
6717: LD_INT 2
6719: EQUAL
6720: IFFALSE 6730
// sSpeed := true ;
6722: LD_ADDR_EXP 28
6726: PUSH
6727: LD_INT 1
6729: ST_TO_ADDR
// if p3 = 3 then
6730: LD_VAR 0 3
6734: PUSH
6735: LD_INT 3
6737: EQUAL
6738: IFFALSE 6748
// sEngine := true ;
6740: LD_ADDR_EXP 30
6744: PUSH
6745: LD_INT 1
6747: ST_TO_ADDR
// if p3 = 4 then
6748: LD_VAR 0 3
6752: PUSH
6753: LD_INT 4
6755: EQUAL
6756: IFFALSE 6766
// sSpec := true ;
6758: LD_ADDR_EXP 27
6762: PUSH
6763: LD_INT 1
6765: ST_TO_ADDR
// if p3 = 5 then
6766: LD_VAR 0 3
6770: PUSH
6771: LD_INT 5
6773: EQUAL
6774: IFFALSE 6784
// sLevel := true ;
6776: LD_ADDR_EXP 31
6780: PUSH
6781: LD_INT 1
6783: ST_TO_ADDR
// if p3 = 6 then
6784: LD_VAR 0 3
6788: PUSH
6789: LD_INT 6
6791: EQUAL
6792: IFFALSE 6802
// sArmoury := true ;
6794: LD_ADDR_EXP 32
6798: PUSH
6799: LD_INT 1
6801: ST_TO_ADDR
// if p3 = 7 then
6802: LD_VAR 0 3
6806: PUSH
6807: LD_INT 7
6809: EQUAL
6810: IFFALSE 6820
// sRadar := true ;
6812: LD_ADDR_EXP 33
6816: PUSH
6817: LD_INT 1
6819: ST_TO_ADDR
// if p3 = 8 then
6820: LD_VAR 0 3
6824: PUSH
6825: LD_INT 8
6827: EQUAL
6828: IFFALSE 6838
// sBunker := true ;
6830: LD_ADDR_EXP 34
6834: PUSH
6835: LD_INT 1
6837: ST_TO_ADDR
// if p3 = 9 then
6838: LD_VAR 0 3
6842: PUSH
6843: LD_INT 9
6845: EQUAL
6846: IFFALSE 6856
// sHack := true ;
6848: LD_ADDR_EXP 35
6852: PUSH
6853: LD_INT 1
6855: ST_TO_ADDR
// if p3 = 10 then
6856: LD_VAR 0 3
6860: PUSH
6861: LD_INT 10
6863: EQUAL
6864: IFFALSE 6874
// sFire := true ;
6866: LD_ADDR_EXP 36
6870: PUSH
6871: LD_INT 1
6873: ST_TO_ADDR
// if p3 = 11 then
6874: LD_VAR 0 3
6878: PUSH
6879: LD_INT 11
6881: EQUAL
6882: IFFALSE 6892
// sRefresh := true ;
6884: LD_ADDR_EXP 37
6888: PUSH
6889: LD_INT 1
6891: ST_TO_ADDR
// if p3 = 12 then
6892: LD_VAR 0 3
6896: PUSH
6897: LD_INT 12
6899: EQUAL
6900: IFFALSE 6910
// sExp := true ;
6902: LD_ADDR_EXP 38
6906: PUSH
6907: LD_INT 1
6909: ST_TO_ADDR
// if p3 = 13 then
6910: LD_VAR 0 3
6914: PUSH
6915: LD_INT 13
6917: EQUAL
6918: IFFALSE 6928
// sDepot := true ;
6920: LD_ADDR_EXP 39
6924: PUSH
6925: LD_INT 1
6927: ST_TO_ADDR
// if p3 = 14 then
6928: LD_VAR 0 3
6932: PUSH
6933: LD_INT 14
6935: EQUAL
6936: IFFALSE 6946
// sFlag := true ;
6938: LD_ADDR_EXP 40
6942: PUSH
6943: LD_INT 1
6945: ST_TO_ADDR
// if p3 = 101 then
6946: LD_VAR 0 3
6950: PUSH
6951: LD_INT 101
6953: EQUAL
6954: IFFALSE 6964
// sSold := true ;
6956: LD_ADDR_EXP 41
6960: PUSH
6961: LD_INT 1
6963: ST_TO_ADDR
// if p3 = 102 then
6964: LD_VAR 0 3
6968: PUSH
6969: LD_INT 102
6971: EQUAL
6972: IFFALSE 6982
// sDiff := true ;
6974: LD_ADDR_EXP 42
6978: PUSH
6979: LD_INT 1
6981: ST_TO_ADDR
// if p3 = 103 then
6982: LD_VAR 0 3
6986: PUSH
6987: LD_INT 103
6989: EQUAL
6990: IFFALSE 7000
// sFog := true ;
6992: LD_ADDR_EXP 45
6996: PUSH
6997: LD_INT 1
6999: ST_TO_ADDR
// if p3 = 104 then
7000: LD_VAR 0 3
7004: PUSH
7005: LD_INT 104
7007: EQUAL
7008: IFFALSE 7018
// sReset := true ;
7010: LD_ADDR_EXP 46
7014: PUSH
7015: LD_INT 1
7017: ST_TO_ADDR
// if p3 = 105 then
7018: LD_VAR 0 3
7022: PUSH
7023: LD_INT 105
7025: EQUAL
7026: IFFALSE 7036
// sSun := true ;
7028: LD_ADDR_EXP 47
7032: PUSH
7033: LD_INT 1
7035: ST_TO_ADDR
// if p3 = 106 then
7036: LD_VAR 0 3
7040: PUSH
7041: LD_INT 106
7043: EQUAL
7044: IFFALSE 7054
// sTiger := true ;
7046: LD_ADDR_EXP 43
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// if p3 = 107 then
7054: LD_VAR 0 3
7058: PUSH
7059: LD_INT 107
7061: EQUAL
7062: IFFALSE 7072
// sBomb := true ;
7064: LD_ADDR_EXP 44
7068: PUSH
7069: LD_INT 1
7071: ST_TO_ADDR
// end ; end ;
7072: PPOPN 6
7074: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7075: LD_EXP 26
7079: PUSH
7080: LD_EXP 29
7084: AND
7085: IFFALSE 7206
7087: GO 7089
7089: DISABLE
7090: LD_INT 0
7092: PPUSH
7093: PPUSH
// begin enable ;
7094: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
7095: LD_ADDR_VAR 0 2
7099: PUSH
7100: LD_INT 22
7102: PUSH
7103: LD_OWVAR 2
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 2
7114: PUSH
7115: LD_INT 34
7117: PUSH
7118: LD_INT 7
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 34
7127: PUSH
7128: LD_INT 45
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: LD_INT 34
7137: PUSH
7138: LD_INT 28
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: PUSH
7145: LD_INT 34
7147: PUSH
7148: LD_INT 47
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: LIST
7159: LIST
7160: LIST
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PPUSH
7166: CALL_OW 69
7170: ST_TO_ADDR
// if not tmp then
7171: LD_VAR 0 2
7175: NOT
7176: IFFALSE 7180
// exit ;
7178: GO 7206
// for i in tmp do
7180: LD_ADDR_VAR 0 1
7184: PUSH
7185: LD_VAR 0 2
7189: PUSH
7190: FOR_IN
7191: IFFALSE 7204
// begin DestroyUnit ( i ) ;
7193: LD_VAR 0 1
7197: PPUSH
7198: CALL_OW 65
// end ;
7202: GO 7190
7204: POP
7205: POP
// end ;
7206: PPOPN 2
7208: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
7209: LD_EXP 26
7213: PUSH
7214: LD_EXP 30
7218: AND
7219: IFFALSE 7300
7221: GO 7223
7223: DISABLE
7224: LD_INT 0
7226: PPUSH
7227: PPUSH
// begin enable ;
7228: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
7229: LD_ADDR_VAR 0 2
7233: PUSH
7234: LD_INT 22
7236: PUSH
7237: LD_OWVAR 2
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: PUSH
7246: LD_INT 32
7248: PUSH
7249: LD_INT 3
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: PPUSH
7260: CALL_OW 69
7264: ST_TO_ADDR
// if not tmp then
7265: LD_VAR 0 2
7269: NOT
7270: IFFALSE 7274
// exit ;
7272: GO 7300
// for i in tmp do
7274: LD_ADDR_VAR 0 1
7278: PUSH
7279: LD_VAR 0 2
7283: PUSH
7284: FOR_IN
7285: IFFALSE 7298
// begin DestroyUnit ( i ) ;
7287: LD_VAR 0 1
7291: PPUSH
7292: CALL_OW 65
// end ;
7296: GO 7284
7298: POP
7299: POP
// end ;
7300: PPOPN 2
7302: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7303: LD_EXP 26
7307: PUSH
7308: LD_EXP 27
7312: AND
7313: IFFALSE 7406
7315: GO 7317
7317: DISABLE
7318: LD_INT 0
7320: PPUSH
// begin enable ;
7321: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7322: LD_ADDR_VAR 0 1
7326: PUSH
7327: LD_INT 22
7329: PUSH
7330: LD_OWVAR 2
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: LD_INT 2
7341: PUSH
7342: LD_INT 25
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 25
7354: PUSH
7355: LD_INT 9
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: PUSH
7362: LD_INT 25
7364: PUSH
7365: LD_INT 8
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: PPUSH
7382: CALL_OW 69
7386: PUSH
7387: FOR_IN
7388: IFFALSE 7404
// begin SetClass ( i , 1 ) ;
7390: LD_VAR 0 1
7394: PPUSH
7395: LD_INT 1
7397: PPUSH
7398: CALL_OW 336
// end ;
7402: GO 7387
7404: POP
7405: POP
// end ;
7406: PPOPN 1
7408: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7409: LD_EXP 26
7413: PUSH
7414: LD_EXP 28
7418: AND
7419: PUSH
7420: LD_OWVAR 65
7424: PUSH
7425: LD_INT 7
7427: LESS
7428: AND
7429: IFFALSE 7443
7431: GO 7433
7433: DISABLE
// begin enable ;
7434: ENABLE
// game_speed := 7 ;
7435: LD_ADDR_OWVAR 65
7439: PUSH
7440: LD_INT 7
7442: ST_TO_ADDR
// end ;
7443: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7444: LD_EXP 26
7448: PUSH
7449: LD_EXP 31
7453: AND
7454: IFFALSE 7656
7456: GO 7458
7458: DISABLE
7459: LD_INT 0
7461: PPUSH
7462: PPUSH
7463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_INT 81
7471: PUSH
7472: LD_OWVAR 2
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PUSH
7481: LD_INT 21
7483: PUSH
7484: LD_INT 1
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: EMPTY
7492: LIST
7493: LIST
7494: PPUSH
7495: CALL_OW 69
7499: ST_TO_ADDR
// if not tmp then
7500: LD_VAR 0 3
7504: NOT
7505: IFFALSE 7509
// exit ;
7507: GO 7656
// if tmp > 5 then
7509: LD_VAR 0 3
7513: PUSH
7514: LD_INT 5
7516: GREATER
7517: IFFALSE 7529
// k := 5 else
7519: LD_ADDR_VAR 0 2
7523: PUSH
7524: LD_INT 5
7526: ST_TO_ADDR
7527: GO 7539
// k := tmp ;
7529: LD_ADDR_VAR 0 2
7533: PUSH
7534: LD_VAR 0 3
7538: ST_TO_ADDR
// for i := 1 to k do
7539: LD_ADDR_VAR 0 1
7543: PUSH
7544: DOUBLE
7545: LD_INT 1
7547: DEC
7548: ST_TO_ADDR
7549: LD_VAR 0 2
7553: PUSH
7554: FOR_TO
7555: IFFALSE 7654
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7557: LD_VAR 0 3
7561: PUSH
7562: LD_VAR 0 1
7566: ARRAY
7567: PPUSH
7568: LD_VAR 0 1
7572: PUSH
7573: LD_INT 4
7575: MOD
7576: PUSH
7577: LD_INT 1
7579: PLUS
7580: PPUSH
7581: CALL_OW 259
7585: PUSH
7586: LD_INT 10
7588: LESS
7589: IFFALSE 7652
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7591: LD_VAR 0 3
7595: PUSH
7596: LD_VAR 0 1
7600: ARRAY
7601: PPUSH
7602: LD_VAR 0 1
7606: PUSH
7607: LD_INT 4
7609: MOD
7610: PUSH
7611: LD_INT 1
7613: PLUS
7614: PPUSH
7615: LD_VAR 0 3
7619: PUSH
7620: LD_VAR 0 1
7624: ARRAY
7625: PPUSH
7626: LD_VAR 0 1
7630: PUSH
7631: LD_INT 4
7633: MOD
7634: PUSH
7635: LD_INT 1
7637: PLUS
7638: PPUSH
7639: CALL_OW 259
7643: PUSH
7644: LD_INT 1
7646: PLUS
7647: PPUSH
7648: CALL_OW 237
7652: GO 7554
7654: POP
7655: POP
// end ;
7656: PPOPN 3
7658: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7659: LD_EXP 26
7663: PUSH
7664: LD_EXP 32
7668: AND
7669: IFFALSE 7689
7671: GO 7673
7673: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7674: LD_INT 4
7676: PPUSH
7677: LD_OWVAR 2
7681: PPUSH
7682: LD_INT 0
7684: PPUSH
7685: CALL_OW 324
7689: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7690: LD_EXP 26
7694: PUSH
7695: LD_EXP 33
7699: AND
7700: IFFALSE 7799
7702: GO 7704
7704: DISABLE
7705: LD_INT 0
7707: PPUSH
7708: PPUSH
// begin enable ;
7709: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7710: LD_ADDR_VAR 0 2
7714: PUSH
7715: LD_INT 22
7717: PUSH
7718: LD_OWVAR 2
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PUSH
7727: LD_INT 2
7729: PUSH
7730: LD_INT 34
7732: PUSH
7733: LD_INT 11
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 34
7742: PUSH
7743: LD_INT 30
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PPUSH
7759: CALL_OW 69
7763: ST_TO_ADDR
// if not tmp then
7764: LD_VAR 0 2
7768: NOT
7769: IFFALSE 7773
// exit ;
7771: GO 7799
// for i in tmp do
7773: LD_ADDR_VAR 0 1
7777: PUSH
7778: LD_VAR 0 2
7782: PUSH
7783: FOR_IN
7784: IFFALSE 7797
// begin DestroyUnit ( i ) ;
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 65
// end ;
7795: GO 7783
7797: POP
7798: POP
// end ;
7799: PPOPN 2
7801: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7802: LD_EXP 26
7806: PUSH
7807: LD_EXP 34
7811: AND
7812: IFFALSE 7832
7814: GO 7816
7816: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7817: LD_INT 32
7819: PPUSH
7820: LD_OWVAR 2
7824: PPUSH
7825: LD_INT 0
7827: PPUSH
7828: CALL_OW 324
7832: END
// every 0 0$1 trigger StreamModeActive and sHack do
7833: LD_EXP 26
7837: PUSH
7838: LD_EXP 35
7842: AND
7843: IFFALSE 7863
7845: GO 7847
7847: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
7848: LD_INT 33
7850: PPUSH
7851: LD_OWVAR 2
7855: PPUSH
7856: LD_INT 0
7858: PPUSH
7859: CALL_OW 322
7863: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
7864: LD_EXP 26
7868: PUSH
7869: LD_EXP 36
7873: AND
7874: IFFALSE 7953
7876: GO 7878
7878: DISABLE
7879: LD_INT 0
7881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
7882: LD_ADDR_VAR 0 1
7886: PUSH
7887: LD_INT 22
7889: PUSH
7890: LD_OWVAR 2
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: PUSH
7899: LD_INT 21
7901: PUSH
7902: LD_INT 3
7904: PUSH
7905: EMPTY
7906: LIST
7907: LIST
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PPUSH
7913: CALL_OW 69
7917: ST_TO_ADDR
// if not tmp then
7918: LD_VAR 0 1
7922: NOT
7923: IFFALSE 7927
// exit ;
7925: GO 7953
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
7927: LD_VAR 0 1
7931: PUSH
7932: LD_INT 1
7934: PPUSH
7935: LD_VAR 0 1
7939: PPUSH
7940: CALL_OW 12
7944: ARRAY
7945: PPUSH
7946: LD_INT 100
7948: PPUSH
7949: CALL_OW 234
// end ;
7953: PPOPN 1
7955: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
7956: LD_EXP 26
7960: PUSH
7961: LD_EXP 38
7965: AND
7966: IFFALSE 8064
7968: GO 7970
7970: DISABLE
7971: LD_INT 0
7973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
7974: LD_ADDR_VAR 0 1
7978: PUSH
7979: LD_INT 22
7981: PUSH
7982: LD_OWVAR 2
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: PUSH
7991: LD_INT 21
7993: PUSH
7994: LD_INT 1
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PPUSH
8005: CALL_OW 69
8009: ST_TO_ADDR
// if not tmp then
8010: LD_VAR 0 1
8014: NOT
8015: IFFALSE 8019
// exit ;
8017: GO 8064
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8019: LD_VAR 0 1
8023: PUSH
8024: LD_INT 1
8026: PPUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 12
8036: ARRAY
8037: PPUSH
8038: LD_INT 1
8040: PPUSH
8041: LD_INT 4
8043: PPUSH
8044: CALL_OW 12
8048: PPUSH
8049: LD_INT 3000
8051: PPUSH
8052: LD_INT 9000
8054: PPUSH
8055: CALL_OW 12
8059: PPUSH
8060: CALL_OW 492
// end ;
8064: PPOPN 1
8066: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8067: LD_EXP 26
8071: PUSH
8072: LD_EXP 39
8076: AND
8077: IFFALSE 8097
8079: GO 8081
8081: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8082: LD_INT 1
8084: PPUSH
8085: LD_OWVAR 2
8089: PPUSH
8090: LD_INT 0
8092: PPUSH
8093: CALL_OW 324
8097: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8098: LD_EXP 26
8102: PUSH
8103: LD_EXP 40
8107: AND
8108: IFFALSE 8191
8110: GO 8112
8112: DISABLE
8113: LD_INT 0
8115: PPUSH
8116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8117: LD_ADDR_VAR 0 2
8121: PUSH
8122: LD_INT 22
8124: PUSH
8125: LD_OWVAR 2
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: LD_INT 21
8136: PUSH
8137: LD_INT 3
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 69
8152: ST_TO_ADDR
// if not tmp then
8153: LD_VAR 0 2
8157: NOT
8158: IFFALSE 8162
// exit ;
8160: GO 8191
// for i in tmp do
8162: LD_ADDR_VAR 0 1
8166: PUSH
8167: LD_VAR 0 2
8171: PUSH
8172: FOR_IN
8173: IFFALSE 8189
// SetBLevel ( i , 10 ) ;
8175: LD_VAR 0 1
8179: PPUSH
8180: LD_INT 10
8182: PPUSH
8183: CALL_OW 241
8187: GO 8172
8189: POP
8190: POP
// end ;
8191: PPOPN 2
8193: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
8194: LD_EXP 26
8198: PUSH
8199: LD_EXP 41
8203: AND
8204: IFFALSE 8287
8206: GO 8208
8208: DISABLE
8209: LD_INT 0
8211: PPUSH
8212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8213: LD_ADDR_VAR 0 2
8217: PUSH
8218: LD_INT 22
8220: PUSH
8221: LD_OWVAR 2
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 25
8232: PUSH
8233: LD_INT 1
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PUSH
8240: EMPTY
8241: LIST
8242: LIST
8243: PPUSH
8244: CALL_OW 69
8248: ST_TO_ADDR
// if not tmp then
8249: LD_VAR 0 2
8253: NOT
8254: IFFALSE 8258
// exit ;
8256: GO 8287
// for i in tmp do
8258: LD_ADDR_VAR 0 1
8262: PUSH
8263: LD_VAR 0 2
8267: PUSH
8268: FOR_IN
8269: IFFALSE 8285
// SetClass ( i , 4 ) ;
8271: LD_VAR 0 1
8275: PPUSH
8276: LD_INT 4
8278: PPUSH
8279: CALL_OW 336
8283: GO 8268
8285: POP
8286: POP
// end ;
8287: PPOPN 2
8289: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8290: LD_EXP 26
8294: PUSH
8295: LD_EXP 42
8299: AND
8300: PUSH
8301: LD_OWVAR 67
8305: PUSH
8306: LD_INT 3
8308: LESS
8309: AND
8310: IFFALSE 8329
8312: GO 8314
8314: DISABLE
// Difficulty := Difficulty + 1 ;
8315: LD_ADDR_OWVAR 67
8319: PUSH
8320: LD_OWVAR 67
8324: PUSH
8325: LD_INT 1
8327: PLUS
8328: ST_TO_ADDR
8329: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8330: LD_EXP 26
8334: PUSH
8335: LD_EXP 43
8339: AND
8340: IFFALSE 8443
8342: GO 8344
8344: DISABLE
8345: LD_INT 0
8347: PPUSH
// begin for i := 1 to 5 do
8348: LD_ADDR_VAR 0 1
8352: PUSH
8353: DOUBLE
8354: LD_INT 1
8356: DEC
8357: ST_TO_ADDR
8358: LD_INT 5
8360: PUSH
8361: FOR_TO
8362: IFFALSE 8441
// begin uc_nation := nation_nature ;
8364: LD_ADDR_OWVAR 21
8368: PUSH
8369: LD_INT 0
8371: ST_TO_ADDR
// uc_side := 0 ;
8372: LD_ADDR_OWVAR 20
8376: PUSH
8377: LD_INT 0
8379: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8380: LD_ADDR_OWVAR 29
8384: PUSH
8385: LD_INT 12
8387: PUSH
8388: LD_INT 12
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: ST_TO_ADDR
// hc_agressivity := 20 ;
8395: LD_ADDR_OWVAR 35
8399: PUSH
8400: LD_INT 20
8402: ST_TO_ADDR
// hc_class := class_tiger ;
8403: LD_ADDR_OWVAR 28
8407: PUSH
8408: LD_INT 14
8410: ST_TO_ADDR
// hc_gallery :=  ;
8411: LD_ADDR_OWVAR 33
8415: PUSH
8416: LD_STRING 
8418: ST_TO_ADDR
// hc_name :=  ;
8419: LD_ADDR_OWVAR 26
8423: PUSH
8424: LD_STRING 
8426: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8427: CALL_OW 44
8431: PPUSH
8432: LD_INT 0
8434: PPUSH
8435: CALL_OW 51
// end ;
8439: GO 8361
8441: POP
8442: POP
// end ;
8443: PPOPN 1
8445: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
8446: LD_EXP 26
8450: PUSH
8451: LD_EXP 44
8455: AND
8456: IFFALSE 8630
8458: GO 8460
8460: DISABLE
8461: LD_INT 0
8463: PPUSH
8464: PPUSH
8465: PPUSH
8466: PPUSH
// begin result := false ;
8467: LD_ADDR_VAR 0 4
8471: PUSH
8472: LD_INT 0
8474: ST_TO_ADDR
// for i := 1 to 8 do
8475: LD_ADDR_VAR 0 1
8479: PUSH
8480: DOUBLE
8481: LD_INT 1
8483: DEC
8484: ST_TO_ADDR
8485: LD_INT 8
8487: PUSH
8488: FOR_TO
8489: IFFALSE 8600
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
8491: LD_ADDR_VAR 0 2
8495: PUSH
8496: LD_INT 10
8498: PUSH
8499: LD_INT 50
8501: PUSH
8502: LD_INT 90
8504: PUSH
8505: LD_INT 140
8507: PUSH
8508: EMPTY
8509: LIST
8510: LIST
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 1
8516: PPUSH
8517: LD_INT 4
8519: PPUSH
8520: CALL_OW 12
8524: ARRAY
8525: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
8526: LD_ADDR_VAR 0 3
8530: PUSH
8531: LD_INT 10
8533: PUSH
8534: LD_INT 50
8536: PUSH
8537: LD_INT 90
8539: PUSH
8540: LD_INT 140
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 1
8551: PPUSH
8552: LD_INT 4
8554: PPUSH
8555: CALL_OW 12
8559: ARRAY
8560: ST_TO_ADDR
// if ValidHex ( x , y ) then
8561: LD_VAR 0 2
8565: PPUSH
8566: LD_VAR 0 3
8570: PPUSH
8571: CALL_OW 488
8575: IFFALSE 8598
// begin result := [ x , y ] ;
8577: LD_ADDR_VAR 0 4
8581: PUSH
8582: LD_VAR 0 2
8586: PUSH
8587: LD_VAR 0 3
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: ST_TO_ADDR
// break ;
8596: GO 8600
// end ; end ;
8598: GO 8488
8600: POP
8601: POP
// if result then
8602: LD_VAR 0 4
8606: IFFALSE 8630
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
8608: LD_VAR 0 4
8612: PUSH
8613: LD_INT 1
8615: ARRAY
8616: PPUSH
8617: LD_VAR 0 4
8621: PUSH
8622: LD_INT 2
8624: ARRAY
8625: PPUSH
8626: CALL_OW 429
// end ;
8630: PPOPN 4
8632: END
// every 0 0$1 trigger StreamModeActive and sReset do
8633: LD_EXP 26
8637: PUSH
8638: LD_EXP 46
8642: AND
8643: IFFALSE 8655
8645: GO 8647
8647: DISABLE
// YouLost (  ) ;
8648: LD_STRING 
8650: PPUSH
8651: CALL_OW 104
8655: END
// every 0 0$1 trigger StreamModeActive and sFog do
8656: LD_EXP 26
8660: PUSH
8661: LD_EXP 45
8665: AND
8666: IFFALSE 8680
8668: GO 8670
8670: DISABLE
// FogOff ( your_side ) ;
8671: LD_OWVAR 2
8675: PPUSH
8676: CALL_OW 344
8680: END
// every 0 0$1 trigger StreamModeActive and sSun do
8681: LD_EXP 26
8685: PUSH
8686: LD_EXP 47
8690: AND
8691: IFFALSE 8719
8693: GO 8695
8695: DISABLE
// begin solar_recharge_percent := 0 ;
8696: LD_ADDR_OWVAR 79
8700: PUSH
8701: LD_INT 0
8703: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8704: LD_INT 10500
8706: PPUSH
8707: CALL_OW 67
// solar_recharge_percent := 100 ;
8711: LD_ADDR_OWVAR 79
8715: PUSH
8716: LD_INT 100
8718: ST_TO_ADDR
// end ; end_of_file
8719: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8720: LD_INT 0
8722: PPUSH
8723: PPUSH
8724: PPUSH
8725: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8726: LD_VAR 0 1
8730: PPUSH
8731: CALL_OW 264
8735: PUSH
8736: LD_EXP 52
8740: EQUAL
8741: IFFALSE 8813
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8743: LD_INT 68
8745: PPUSH
8746: LD_VAR 0 1
8750: PPUSH
8751: CALL_OW 255
8755: PPUSH
8756: CALL_OW 321
8760: PUSH
8761: LD_INT 2
8763: EQUAL
8764: IFFALSE 8776
// eff := 70 else
8766: LD_ADDR_VAR 0 6
8770: PUSH
8771: LD_INT 70
8773: ST_TO_ADDR
8774: GO 8784
// eff := 30 ;
8776: LD_ADDR_VAR 0 6
8780: PUSH
8781: LD_INT 30
8783: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8784: LD_VAR 0 1
8788: PPUSH
8789: CALL_OW 250
8793: PPUSH
8794: LD_VAR 0 1
8798: PPUSH
8799: CALL_OW 251
8803: PPUSH
8804: LD_VAR 0 6
8808: PPUSH
8809: CALL_OW 495
// end ; end ;
8813: LD_VAR 0 4
8817: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8818: LD_INT 0
8820: PPUSH
8821: PPUSH
8822: PPUSH
8823: PPUSH
8824: PPUSH
8825: PPUSH
// if cmd = 124 then
8826: LD_VAR 0 1
8830: PUSH
8831: LD_INT 124
8833: EQUAL
8834: IFFALSE 9040
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8836: LD_ADDR_VAR 0 5
8840: PUSH
8841: LD_INT 2
8843: PUSH
8844: LD_INT 34
8846: PUSH
8847: LD_INT 53
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 14
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: LIST
8868: PPUSH
8869: CALL_OW 69
8873: ST_TO_ADDR
// if not tmp then
8874: LD_VAR 0 5
8878: NOT
8879: IFFALSE 8883
// exit ;
8881: GO 9040
// for i in tmp do
8883: LD_ADDR_VAR 0 3
8887: PUSH
8888: LD_VAR 0 5
8892: PUSH
8893: FOR_IN
8894: IFFALSE 9038
// begin taskList := GetTaskList ( i ) ;
8896: LD_ADDR_VAR 0 6
8900: PUSH
8901: LD_VAR 0 3
8905: PPUSH
8906: CALL_OW 437
8910: ST_TO_ADDR
// if not taskList then
8911: LD_VAR 0 6
8915: NOT
8916: IFFALSE 8920
// continue ;
8918: GO 8893
// for j = 1 to taskList do
8920: LD_ADDR_VAR 0 4
8924: PUSH
8925: DOUBLE
8926: LD_INT 1
8928: DEC
8929: ST_TO_ADDR
8930: LD_VAR 0 6
8934: PUSH
8935: FOR_TO
8936: IFFALSE 9034
// if taskList [ j ] [ 1 ] = | then
8938: LD_VAR 0 6
8942: PUSH
8943: LD_VAR 0 4
8947: ARRAY
8948: PUSH
8949: LD_INT 1
8951: ARRAY
8952: PUSH
8953: LD_STRING |
8955: EQUAL
8956: IFFALSE 9032
// begin _taskList := Delete ( taskList , 1 ) ;
8958: LD_ADDR_VAR 0 7
8962: PUSH
8963: LD_VAR 0 6
8967: PPUSH
8968: LD_INT 1
8970: PPUSH
8971: CALL_OW 3
8975: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8976: LD_VAR 0 3
8980: PPUSH
8981: LD_VAR 0 7
8985: PPUSH
8986: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8990: LD_VAR 0 3
8994: PPUSH
8995: LD_VAR 0 6
8999: PUSH
9000: LD_VAR 0 4
9004: ARRAY
9005: PUSH
9006: LD_INT 2
9008: ARRAY
9009: PPUSH
9010: LD_VAR 0 6
9014: PUSH
9015: LD_VAR 0 4
9019: ARRAY
9020: PUSH
9021: LD_INT 3
9023: ARRAY
9024: PPUSH
9025: LD_INT 8
9027: PPUSH
9028: CALL 9045 0 4
// end ;
9032: GO 8935
9034: POP
9035: POP
// end ;
9036: GO 8893
9038: POP
9039: POP
// end ; end ;
9040: LD_VAR 0 2
9044: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
9045: LD_INT 0
9047: PPUSH
9048: PPUSH
9049: PPUSH
9050: PPUSH
9051: PPUSH
9052: PPUSH
9053: PPUSH
9054: PPUSH
9055: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
9056: LD_VAR 0 1
9060: NOT
9061: PUSH
9062: LD_VAR 0 2
9066: PPUSH
9067: LD_VAR 0 3
9071: PPUSH
9072: CALL_OW 488
9076: NOT
9077: OR
9078: PUSH
9079: LD_VAR 0 4
9083: NOT
9084: OR
9085: IFFALSE 9089
// exit ;
9087: GO 9429
// list := [ ] ;
9089: LD_ADDR_VAR 0 13
9093: PUSH
9094: EMPTY
9095: ST_TO_ADDR
// if x - r < 0 then
9096: LD_VAR 0 2
9100: PUSH
9101: LD_VAR 0 4
9105: MINUS
9106: PUSH
9107: LD_INT 0
9109: LESS
9110: IFFALSE 9122
// min_x := 0 else
9112: LD_ADDR_VAR 0 7
9116: PUSH
9117: LD_INT 0
9119: ST_TO_ADDR
9120: GO 9138
// min_x := x - r ;
9122: LD_ADDR_VAR 0 7
9126: PUSH
9127: LD_VAR 0 2
9131: PUSH
9132: LD_VAR 0 4
9136: MINUS
9137: ST_TO_ADDR
// if y - r < 0 then
9138: LD_VAR 0 3
9142: PUSH
9143: LD_VAR 0 4
9147: MINUS
9148: PUSH
9149: LD_INT 0
9151: LESS
9152: IFFALSE 9164
// min_y := 0 else
9154: LD_ADDR_VAR 0 8
9158: PUSH
9159: LD_INT 0
9161: ST_TO_ADDR
9162: GO 9180
// min_y := y - r ;
9164: LD_ADDR_VAR 0 8
9168: PUSH
9169: LD_VAR 0 3
9173: PUSH
9174: LD_VAR 0 4
9178: MINUS
9179: ST_TO_ADDR
// max_x := x + r ;
9180: LD_ADDR_VAR 0 9
9184: PUSH
9185: LD_VAR 0 2
9189: PUSH
9190: LD_VAR 0 4
9194: PLUS
9195: ST_TO_ADDR
// max_y := y + r ;
9196: LD_ADDR_VAR 0 10
9200: PUSH
9201: LD_VAR 0 3
9205: PUSH
9206: LD_VAR 0 4
9210: PLUS
9211: ST_TO_ADDR
// for _x = min_x to max_x do
9212: LD_ADDR_VAR 0 11
9216: PUSH
9217: DOUBLE
9218: LD_VAR 0 7
9222: DEC
9223: ST_TO_ADDR
9224: LD_VAR 0 9
9228: PUSH
9229: FOR_TO
9230: IFFALSE 9347
// for _y = min_y to max_y do
9232: LD_ADDR_VAR 0 12
9236: PUSH
9237: DOUBLE
9238: LD_VAR 0 8
9242: DEC
9243: ST_TO_ADDR
9244: LD_VAR 0 10
9248: PUSH
9249: FOR_TO
9250: IFFALSE 9343
// begin if not ValidHex ( _x , _y ) then
9252: LD_VAR 0 11
9256: PPUSH
9257: LD_VAR 0 12
9261: PPUSH
9262: CALL_OW 488
9266: NOT
9267: IFFALSE 9271
// continue ;
9269: GO 9249
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
9271: LD_VAR 0 11
9275: PPUSH
9276: LD_VAR 0 12
9280: PPUSH
9281: CALL_OW 351
9285: PUSH
9286: LD_VAR 0 11
9290: PPUSH
9291: LD_VAR 0 12
9295: PPUSH
9296: CALL_OW 554
9300: AND
9301: IFFALSE 9341
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
9303: LD_ADDR_VAR 0 13
9307: PUSH
9308: LD_VAR 0 13
9312: PPUSH
9313: LD_VAR 0 13
9317: PUSH
9318: LD_INT 1
9320: PLUS
9321: PPUSH
9322: LD_VAR 0 11
9326: PUSH
9327: LD_VAR 0 12
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL_OW 2
9340: ST_TO_ADDR
// end ;
9341: GO 9249
9343: POP
9344: POP
9345: GO 9229
9347: POP
9348: POP
// if not list then
9349: LD_VAR 0 13
9353: NOT
9354: IFFALSE 9358
// exit ;
9356: GO 9429
// for i in list do
9358: LD_ADDR_VAR 0 6
9362: PUSH
9363: LD_VAR 0 13
9367: PUSH
9368: FOR_IN
9369: IFFALSE 9427
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
9371: LD_VAR 0 1
9375: PPUSH
9376: LD_STRING M
9378: PUSH
9379: LD_VAR 0 6
9383: PUSH
9384: LD_INT 1
9386: ARRAY
9387: PUSH
9388: LD_VAR 0 6
9392: PUSH
9393: LD_INT 2
9395: ARRAY
9396: PUSH
9397: LD_INT 0
9399: PUSH
9400: LD_INT 0
9402: PUSH
9403: LD_INT 0
9405: PUSH
9406: LD_INT 0
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: LIST
9415: LIST
9416: LIST
9417: PUSH
9418: EMPTY
9419: LIST
9420: PPUSH
9421: CALL_OW 447
9425: GO 9368
9427: POP
9428: POP
// end ; end_of_file
9429: LD_VAR 0 5
9433: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
9434: GO 9436
9436: DISABLE
// begin ru_radar := 98 ;
9437: LD_ADDR_EXP 48
9441: PUSH
9442: LD_INT 98
9444: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
9445: LD_ADDR_EXP 49
9449: PUSH
9450: LD_INT 89
9452: ST_TO_ADDR
// us_hack := 99 ;
9453: LD_ADDR_EXP 50
9457: PUSH
9458: LD_INT 99
9460: ST_TO_ADDR
// us_artillery := 97 ;
9461: LD_ADDR_EXP 51
9465: PUSH
9466: LD_INT 97
9468: ST_TO_ADDR
// ar_bio_bomb := 91 ;
9469: LD_ADDR_EXP 52
9473: PUSH
9474: LD_INT 91
9476: ST_TO_ADDR
// end ;
9477: END
