// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 32 0 0
// InitAmerican ;
  15: CALL 915 0 0
// InitRussian ;
  19: CALL 1154 0 0
// DebugMode ;
  23: CALL 152 0 0
// Action ;
  27: CALL 2710 0 0
// end ;
  31: END
// export debug ; export mission_prefix ; export active_russian_dialog , bobby_in_squad , powell_contact , macmilan_use_radio , cyrus_in_squad , active_road_patrol , macmilan_in_trap , meta_action , end_mission , bobby_saved , cyrus_saved , send_troops_to_forest ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// mission_prefix := 01_ ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_STRING 01_
  42: ST_TO_ADDR
// debug := 0 ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// active_russian_dialog := false ;
  51: LD_ADDR_EXP 3
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// bobby_in_squad := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// cyrus_in_squad := false ;
  67: LD_ADDR_EXP 7
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// powell_contact := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// macmilan_use_radio := false ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// active_road_patrol := false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// macmilan_in_trap := false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// meta_action := false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// end_mission := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// bobby_saved := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// cyrus_saved := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// send_troops_to_forest := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// function DebugMode ; var i ; begin
 152: LD_INT 0
 154: PPUSH
 155: PPUSH
// if not debug then
 156: LD_EXP 1
 160: NOT
 161: IFFALSE 165
// exit ;
 163: GO 184
// Difficulty := 3 ;
 165: LD_ADDR_OWVAR 67
 169: PUSH
 170: LD_INT 3
 172: ST_TO_ADDR
// TurnFogOff ( ) ;
 173: CALL_OW 537
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 216
// unit := CreateCharacter ( ident ) else
 199: LD_ADDR_VAR 0 4
 203: PUSH
 204: LD_VAR 0 1
 208: PPUSH
 209: CALL_OW 34
 213: ST_TO_ADDR
 214: GO 231
// unit := NewCharacter ( ident ) ;
 216: LD_ADDR_VAR 0 4
 220: PUSH
 221: LD_VAR 0 1
 225: PPUSH
 226: CALL_OW 25
 230: ST_TO_ADDR
// result := unit ;
 231: LD_ADDR_VAR 0 3
 235: PUSH
 236: LD_VAR 0 4
 240: ST_TO_ADDR
// end ;
 241: LD_VAR 0 3
 245: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 246: LD_INT 0
 248: PPUSH
 249: PPUSH
 250: PPUSH
// uc_side := GetSide ( b ) ;
 251: LD_ADDR_OWVAR 20
 255: PUSH
 256: LD_VAR 0 2
 260: PPUSH
 261: CALL_OW 255
 265: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 266: LD_ADDR_OWVAR 21
 270: PUSH
 271: LD_VAR 0 2
 275: PPUSH
 276: CALL_OW 248
 280: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 281: LD_INT 0
 283: PPUSH
 284: LD_INT 1
 286: PPUSH
 287: LD_VAR 0 1
 291: PPUSH
 292: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
 296: LD_ADDR_VAR 0 5
 300: PUSH
 301: LD_VAR 0 2
 305: PPUSH
 306: CALL_OW 254
 310: PUSH
 311: LD_INT 3
 313: MINUS
 314: ST_TO_ADDR
// if dir < 0 then
 315: LD_VAR 0 5
 319: PUSH
 320: LD_INT 0
 322: LESS
 323: IFFALSE 339
// dir := 6 + dir ;
 325: LD_ADDR_VAR 0 5
 329: PUSH
 330: LD_INT 6
 332: PUSH
 333: LD_VAR 0 5
 337: PLUS
 338: ST_TO_ADDR
// un := CreateHuman ;
 339: LD_ADDR_VAR 0 4
 343: PUSH
 344: CALL_OW 44
 348: ST_TO_ADDR
// SetDir ( un , dir ) ;
 349: LD_VAR 0 4
 353: PPUSH
 354: LD_VAR 0 5
 358: PPUSH
 359: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 363: LD_VAR 0 4
 367: PPUSH
 368: LD_VAR 0 2
 372: PPUSH
 373: CALL_OW 52
// end ;
 377: LD_VAR 0 3
 381: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 382: LD_INT 0
 384: PPUSH
// uc_side := side ;
 385: LD_ADDR_OWVAR 20
 389: PUSH
 390: LD_VAR 0 1
 394: ST_TO_ADDR
// uc_nation := nation ;
 395: LD_ADDR_OWVAR 21
 399: PUSH
 400: LD_VAR 0 2
 404: ST_TO_ADDR
// vc_chassis := chassis ;
 405: LD_ADDR_OWVAR 37
 409: PUSH
 410: LD_VAR 0 3
 414: ST_TO_ADDR
// vc_engine := engine ;
 415: LD_ADDR_OWVAR 39
 419: PUSH
 420: LD_VAR 0 4
 424: ST_TO_ADDR
// vc_control := control ;
 425: LD_ADDR_OWVAR 38
 429: PUSH
 430: LD_VAR 0 5
 434: ST_TO_ADDR
// vc_weapon := weapon ;
 435: LD_ADDR_OWVAR 40
 439: PUSH
 440: LD_VAR 0 6
 444: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 445: LD_ADDR_OWVAR 41
 449: PUSH
 450: LD_VAR 0 7
 454: ST_TO_ADDR
// result := CreateVehicle ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: CALL_OW 45
 464: ST_TO_ADDR
// end ;
 465: LD_VAR 0 8
 469: RET
// export function ComPatrol ( unit , mode , pause , coords ) ; var i ; begin
 470: LD_INT 0
 472: PPUSH
 473: PPUSH
// while ( active_road_patrol ) do
 474: LD_EXP 8
 478: IFFALSE 832
// begin Wait ( 0 0$01 ) ;
 480: LD_INT 35
 482: PPUSH
 483: CALL_OW 67
// if not unit then
 487: LD_VAR 0 1
 491: NOT
 492: IFFALSE 496
// exit ;
 494: GO 832
// if mode = road then
 496: LD_VAR 0 2
 500: PUSH
 501: LD_STRING road
 503: EQUAL
 504: IFFALSE 560
// if GetFuel ( unit ) < 50 and not See ( 1 , unit ) and not HasTask ( unit ) then
 506: LD_VAR 0 1
 510: PPUSH
 511: CALL_OW 261
 515: PUSH
 516: LD_INT 50
 518: LESS
 519: PUSH
 520: LD_INT 1
 522: PPUSH
 523: LD_VAR 0 1
 527: PPUSH
 528: CALL_OW 292
 532: NOT
 533: AND
 534: PUSH
 535: LD_VAR 0 1
 539: PPUSH
 540: CALL_OW 314
 544: NOT
 545: AND
 546: IFFALSE 560
// SetFuel ( unit , 100 ) ;
 548: LD_VAR 0 1
 552: PPUSH
 553: LD_INT 100
 555: PPUSH
 556: CALL_OW 240
// if mode = forest then
 560: LD_VAR 0 2
 564: PUSH
 565: LD_STRING forest
 567: EQUAL
 568: IFFALSE 648
// if GetLives ( unit ) < 600 then
 570: LD_VAR 0 1
 574: PPUSH
 575: CALL_OW 256
 579: PUSH
 580: LD_INT 600
 582: LESS
 583: IFFALSE 648
// begin ComMoveXY ( unit , 42 , 3 ) ;
 585: LD_VAR 0 1
 589: PPUSH
 590: LD_INT 42
 592: PPUSH
 593: LD_INT 3
 595: PPUSH
 596: CALL_OW 111
// SetRememberedX ( unit , GetX ( unit ) ) ;
 600: LD_VAR 0 1
 604: PPUSH
 605: LD_VAR 0 1
 609: PPUSH
 610: CALL_OW 250
 614: PPUSH
 615: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
 619: LD_VAR 0 1
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: CALL_OW 251
 633: PPUSH
 634: CALL_OW 232
// send_troops_to_forest := true ;
 638: LD_ADDR_EXP 14
 642: PUSH
 643: LD_INT 1
 645: ST_TO_ADDR
// break ;
 646: GO 832
// end ; if not HasTask ( unit ) then
 648: LD_VAR 0 1
 652: PPUSH
 653: CALL_OW 314
 657: NOT
 658: IFFALSE 830
// begin for i = 1 to coords do
 660: LD_ADDR_VAR 0 6
 664: PUSH
 665: DOUBLE
 666: LD_INT 1
 668: DEC
 669: ST_TO_ADDR
 670: LD_VAR 0 4
 674: PUSH
 675: FOR_TO
 676: IFFALSE 743
// begin AddComAgressiveMove ( unit , coords [ i ] , coords [ i + 1 ] ) ;
 678: LD_VAR 0 1
 682: PPUSH
 683: LD_VAR 0 4
 687: PUSH
 688: LD_VAR 0 6
 692: ARRAY
 693: PPUSH
 694: LD_VAR 0 4
 698: PUSH
 699: LD_VAR 0 6
 703: PUSH
 704: LD_INT 1
 706: PLUS
 707: ARRAY
 708: PPUSH
 709: CALL_OW 174
// AddComWait ( unit , pause ) ;
 713: LD_VAR 0 1
 717: PPUSH
 718: LD_VAR 0 3
 722: PPUSH
 723: CALL_OW 202
// i := i + 1 ;
 727: LD_ADDR_VAR 0 6
 731: PUSH
 732: LD_VAR 0 6
 736: PUSH
 737: LD_INT 1
 739: PLUS
 740: ST_TO_ADDR
// end ;
 741: GO 675
 743: POP
 744: POP
// for i = coords downto 1 do
 745: LD_ADDR_VAR 0 6
 749: PUSH
 750: DOUBLE
 751: LD_VAR 0 4
 755: INC
 756: ST_TO_ADDR
 757: LD_INT 1
 759: PUSH
 760: FOR_DOWNTO
 761: IFFALSE 828
// begin AddComAgressiveMove ( unit , coords [ i - 1 ] , coords [ i ] ) ;
 763: LD_VAR 0 1
 767: PPUSH
 768: LD_VAR 0 4
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_INT 1
 780: MINUS
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 4
 787: PUSH
 788: LD_VAR 0 6
 792: ARRAY
 793: PPUSH
 794: CALL_OW 174
// AddComWait ( unit , pause ) ;
 798: LD_VAR 0 1
 802: PPUSH
 803: LD_VAR 0 3
 807: PPUSH
 808: CALL_OW 202
// i := i - 1 ;
 812: LD_ADDR_VAR 0 6
 816: PUSH
 817: LD_VAR 0 6
 821: PUSH
 822: LD_INT 1
 824: MINUS
 825: ST_TO_ADDR
// end ;
 826: GO 760
 828: POP
 829: POP
// end ; end ;
 830: GO 474
// end ;
 832: LD_VAR 0 5
 836: RET
// export function DebugSay ( dialog ) ; var speaker ; begin
 837: LD_INT 0
 839: PPUSH
 840: PPUSH
// uc_nation := 1 ;
 841: LD_ADDR_OWVAR 21
 845: PUSH
 846: LD_INT 1
 848: ST_TO_ADDR
// uc_side := 0 ;
 849: LD_ADDR_OWVAR 20
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
 857: LD_INT 0
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: CALL_OW 380
// hc_name := speaker ;
 870: LD_ADDR_OWVAR 26
 874: PUSH
 875: LD_STRING speaker
 877: ST_TO_ADDR
// hc_gallery :=  ;
 878: LD_ADDR_OWVAR 33
 882: PUSH
 883: LD_STRING 
 885: ST_TO_ADDR
// speaker := CreateHuman ;
 886: LD_ADDR_VAR 0 3
 890: PUSH
 891: CALL_OW 44
 895: ST_TO_ADDR
// Say ( speaker , dialog ) ;
 896: LD_VAR 0 3
 900: PPUSH
 901: LD_VAR 0 1
 905: PPUSH
 906: CALL_OW 88
// end ; end_of_file
 910: LD_VAR 0 2
 914: RET
// export JMM , Bobby , Cyrus , Powell , fakePokryshkin ; export function InitAmerican ; begin
 915: LD_INT 0
 917: PPUSH
// uc_nation := 1 ;
 918: LD_ADDR_OWVAR 21
 922: PUSH
 923: LD_INT 1
 925: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , false ) ;
 926: LD_ADDR_EXP 15
 930: PUSH
 931: LD_STRING JMM
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL 189 0 2
 941: ST_TO_ADDR
// uc_side := 4 ;
 942: LD_ADDR_OWVAR 20
 946: PUSH
 947: LD_INT 4
 949: ST_TO_ADDR
// hc_gallery := us ;
 950: LD_ADDR_OWVAR 33
 954: PUSH
 955: LD_STRING us
 957: ST_TO_ADDR
// hc_face_number := 7 ;
 958: LD_ADDR_OWVAR 34
 962: PUSH
 963: LD_INT 7
 965: ST_TO_ADDR
// hc_sex := sex_male ;
 966: LD_ADDR_OWVAR 27
 970: PUSH
 971: LD_INT 1
 973: ST_TO_ADDR
// hc_name := . ;
 974: LD_ADDR_OWVAR 26
 978: PUSH
 979: LD_STRING .
 981: ST_TO_ADDR
// hc_class := 1 ;
 982: LD_ADDR_OWVAR 28
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// Powell := CreateHuman ;
 990: LD_ADDR_EXP 18
 994: PUSH
 995: CALL_OW 44
 999: ST_TO_ADDR
// hc_name := . ;
1000: LD_ADDR_OWVAR 26
1004: PUSH
1005: LD_STRING .
1007: ST_TO_ADDR
// hc_gallery := ru ;
1008: LD_ADDR_OWVAR 33
1012: PUSH
1013: LD_STRING ru
1015: ST_TO_ADDR
// hc_face_number := 4 ;
1016: LD_ADDR_OWVAR 34
1020: PUSH
1021: LD_INT 4
1023: ST_TO_ADDR
// hc_sex := sex_male ;
1024: LD_ADDR_OWVAR 27
1028: PUSH
1029: LD_INT 1
1031: ST_TO_ADDR
// fakePokryshkin := CreateHuman ;
1032: LD_ADDR_EXP 19
1036: PUSH
1037: CALL_OW 44
1041: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , false ) ;
1042: LD_ADDR_EXP 16
1046: PUSH
1047: LD_STRING Bobby
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL 189 0 2
1057: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , false ) ;
1058: LD_ADDR_EXP 17
1062: PUSH
1063: LD_STRING Cyrus
1065: PPUSH
1066: LD_INT 0
1068: PPUSH
1069: CALL 189 0 2
1073: ST_TO_ADDR
// case Difficulty of 1 :
1074: LD_OWVAR 67
1078: PUSH
1079: LD_INT 1
1081: DOUBLE
1082: EQUAL
1083: IFTRUE 1087
1085: GO 1102
1087: POP
// SetLives ( Bobby , 500 ) ; 2 :
1088: LD_EXP 16
1092: PPUSH
1093: LD_INT 500
1095: PPUSH
1096: CALL_OW 234
1100: GO 1149
1102: LD_INT 2
1104: DOUBLE
1105: EQUAL
1106: IFTRUE 1110
1108: GO 1125
1110: POP
// SetLives ( Bobby , 460 ) ; 3 :
1111: LD_EXP 16
1115: PPUSH
1116: LD_INT 460
1118: PPUSH
1119: CALL_OW 234
1123: GO 1149
1125: LD_INT 3
1127: DOUBLE
1128: EQUAL
1129: IFTRUE 1133
1131: GO 1148
1133: POP
// SetLives ( Bobby , 420 ) ; end ;
1134: LD_EXP 16
1138: PPUSH
1139: LD_INT 420
1141: PPUSH
1142: CALL_OW 234
1146: GO 1149
1148: POP
// end ; end_of_file
1149: LD_VAR 0 1
1153: RET
// export russian_troops_1 , russian_troops_2 , russian_patrol_tanks , russian_meta_guards , russian_patrol_forest ; export Pokryshkin ; export function InitRussian ; var skill , i , un ; begin
1154: LD_INT 0
1156: PPUSH
1157: PPUSH
1158: PPUSH
1159: PPUSH
// skill := [ 1 , 2 , 3 ] [ Difficulty ] ;
1160: LD_ADDR_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: PUSH
1168: LD_INT 2
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: PUSH
1179: LD_OWVAR 67
1183: ARRAY
1184: ST_TO_ADDR
// uc_side := 3 ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_INT 3
1192: ST_TO_ADDR
// uc_nation := 3 ;
1193: LD_ADDR_OWVAR 21
1197: PUSH
1198: LD_INT 3
1200: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
1201: LD_ADDR_EXP 25
1205: PUSH
1206: LD_STRING Pokryshkin
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL 189 0 2
1216: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 44 , 5 , false ) ;
1217: LD_EXP 25
1221: PPUSH
1222: LD_INT 44
1224: PPUSH
1225: LD_INT 5
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 48
// hc_importance := 0 ;
1235: LD_ADDR_OWVAR 32
1239: PUSH
1240: LD_INT 0
1242: ST_TO_ADDR
// hc_gallery :=  ;
1243: LD_ADDR_OWVAR 33
1247: PUSH
1248: LD_STRING 
1250: ST_TO_ADDR
// hc_name :=  ;
1251: LD_ADDR_OWVAR 26
1255: PUSH
1256: LD_STRING 
1258: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
1259: LD_INT 1
1261: PPUSH
1262: LD_INT 1
1264: PPUSH
1265: LD_VAR 0 2
1269: PPUSH
1270: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1274: LD_ADDR_OWVAR 33
1278: PUSH
1279: LD_STRING SecondCharsGal
1281: ST_TO_ADDR
// hc_face_number := 69 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 69
1289: ST_TO_ADDR
// hc_sex := sex_male ;
1290: LD_ADDR_OWVAR 27
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// hc_name := Ilja Ivanov ;
1298: LD_ADDR_OWVAR 26
1302: PUSH
1303: LD_STRING Ilja Ivanov
1305: ST_TO_ADDR
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 4
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 1 , un ) ;
1316: LD_ADDR_EXP 20
1320: PUSH
1321: LD_EXP 20
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 4
1333: PPUSH
1334: CALL_OW 2
1338: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 3
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 49
// PrepareHuman ( sex_male , 1 , skill ) ;
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: LD_VAR 0 2
1364: PPUSH
1365: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1369: LD_ADDR_OWVAR 33
1373: PUSH
1374: LD_STRING SecondCharsGal
1376: ST_TO_ADDR
// hc_face_number := 70 ;
1377: LD_ADDR_OWVAR 34
1381: PUSH
1382: LD_INT 70
1384: ST_TO_ADDR
// hc_name := Pavel Starczy ;
1385: LD_ADDR_OWVAR 26
1389: PUSH
1390: LD_STRING Pavel Starczy
1392: ST_TO_ADDR
// un := CreateHuman ;
1393: LD_ADDR_VAR 0 4
1397: PUSH
1398: CALL_OW 44
1402: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 2 , un ) ;
1403: LD_ADDR_EXP 20
1407: PUSH
1408: LD_EXP 20
1412: PPUSH
1413: LD_INT 2
1415: PPUSH
1416: LD_VAR 0 4
1420: PPUSH
1421: CALL_OW 2
1425: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1426: LD_VAR 0 4
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: LD_INT 0
1436: PPUSH
1437: CALL_OW 49
// InitHc ;
1441: CALL_OW 19
// for i = 1 to 7 do
1445: LD_ADDR_VAR 0 3
1449: PUSH
1450: DOUBLE
1451: LD_INT 1
1453: DEC
1454: ST_TO_ADDR
1455: LD_INT 7
1457: PUSH
1458: FOR_TO
1459: IFFALSE 1610
// begin PrepareHuman ( false , 1 , skill ) ;
1461: LD_INT 0
1463: PPUSH
1464: LD_INT 1
1466: PPUSH
1467: LD_VAR 0 2
1471: PPUSH
1472: CALL_OW 380
// un := CreateHuman ;
1476: LD_ADDR_VAR 0 4
1480: PUSH
1481: CALL_OW 44
1485: ST_TO_ADDR
// if i mod 2 = 0 then
1486: LD_VAR 0 3
1490: PUSH
1491: LD_INT 2
1493: MOD
1494: PUSH
1495: LD_INT 0
1497: EQUAL
1498: IFFALSE 1555
// begin russian_troops_1 := Insert ( russian_troops_1 , russian_troops_1 + 1 , un ) ;
1500: LD_ADDR_EXP 20
1504: PUSH
1505: LD_EXP 20
1509: PPUSH
1510: LD_EXP 20
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1529: LD_VAR 0 4
1533: PPUSH
1534: LD_INT 3
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 49
// ComHold ( un ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: CALL_OW 140
// end else
1553: GO 1608
// begin russian_troops_2 := Insert ( russian_troops_2 , russian_troops_2 + 1 , un ) ;
1555: LD_ADDR_EXP 21
1559: PUSH
1560: LD_EXP 21
1564: PPUSH
1565: LD_EXP 21
1569: PUSH
1570: LD_INT 1
1572: PLUS
1573: PPUSH
1574: LD_VAR 0 4
1578: PPUSH
1579: CALL_OW 2
1583: ST_TO_ADDR
// PlaceUnitArea ( un , guard_south , false ) ;
1584: LD_VAR 0 4
1588: PPUSH
1589: LD_INT 4
1591: PPUSH
1592: LD_INT 0
1594: PPUSH
1595: CALL_OW 49
// ComHold ( un ) ;
1599: LD_VAR 0 4
1603: PPUSH
1604: CALL_OW 140
// end ; end ;
1608: GO 1458
1610: POP
1611: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) do
1612: LD_ADDR_VAR 0 3
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 3
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 30
1629: PUSH
1630: LD_INT 31
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: PPUSH
1641: CALL_OW 69
1645: PUSH
1646: FOR_IN
1647: IFFALSE 1665
// PrepareSolBun ( skill , i ) ;
1649: LD_VAR 0 2
1653: PPUSH
1654: LD_VAR 0 3
1658: PPUSH
1659: CALL 246 0 2
1663: GO 1646
1665: POP
1666: POP
// for i = 1 to 2 do
1667: LD_ADDR_VAR 0 3
1671: PUSH
1672: DOUBLE
1673: LD_INT 1
1675: DEC
1676: ST_TO_ADDR
1677: LD_INT 2
1679: PUSH
1680: FOR_TO
1681: IFFALSE 1812
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , 100 ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_INT 3
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: LD_INT 22
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 1
1702: PPUSH
1703: LD_INT 42
1705: PPUSH
1706: LD_INT 100
1708: PPUSH
1709: CALL 382 0 7
1713: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
1714: LD_INT 0
1716: PPUSH
1717: LD_INT 3
1719: PPUSH
1720: LD_VAR 0 2
1724: PPUSH
1725: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
1729: CALL_OW 44
1733: PPUSH
1734: LD_VAR 0 4
1738: PPUSH
1739: CALL_OW 52
// PlaceUnitXY ( un , [ 23 , 131 ] [ i ] , [ 14 , 87 ] [ i ] , false ) ;
1743: LD_VAR 0 4
1747: PPUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 131
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_VAR 0 3
1762: ARRAY
1763: PPUSH
1764: LD_INT 14
1766: PUSH
1767: LD_INT 87
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: LD_VAR 0 3
1778: ARRAY
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 48
// russian_patrol_tanks := Insert ( russian_patrol_tanks , 1 , un ) ;
1787: LD_ADDR_EXP 22
1791: PUSH
1792: LD_EXP 22
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_VAR 0 4
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// end ;
1810: GO 1680
1812: POP
1813: POP
// for i = 1 to 2 do
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: DOUBLE
1820: LD_INT 1
1822: DEC
1823: ST_TO_ADDR
1824: LD_INT 2
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1919
// begin PrepareHuman ( [ sex_female , sex_male , sex_male ] [ i ] , 1 , 1 ) ;
1830: LD_INT 2
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: PUSH
1844: LD_VAR 0 3
1848: ARRAY
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: LD_INT 1
1855: PPUSH
1856: CALL_OW 380
// un := CreateHuman ;
1860: LD_ADDR_VAR 0 4
1864: PUSH
1865: CALL_OW 44
1869: ST_TO_ADDR
// russian_meta_guards := Insert ( russian_meta_guards , 1 , un ) ;
1870: LD_ADDR_EXP 23
1874: PUSH
1875: LD_EXP 23
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: LD_VAR 0 4
1887: PPUSH
1888: CALL_OW 2
1892: ST_TO_ADDR
// PlaceUnitArea ( un , exitArea , false ) ;
1893: LD_VAR 0 4
1897: PPUSH
1898: LD_INT 10
1900: PPUSH
1901: LD_INT 0
1903: PPUSH
1904: CALL_OW 49
// ComHold ( un ) ;
1908: LD_VAR 0 4
1912: PPUSH
1913: CALL_OW 140
// end ;
1917: GO 1827
1919: POP
1920: POP
// if Difficulty < 3 then
1921: LD_OWVAR 67
1925: PUSH
1926: LD_INT 3
1928: LESS
1929: IFFALSE 1933
// exit ;
1931: GO 1976
// PrepareHuman ( false , 1 , skill ) ;
1933: LD_INT 0
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: LD_VAR 0 2
1943: PPUSH
1944: CALL_OW 380
// russian_patrol_forest := CreateHuman ;
1948: LD_ADDR_EXP 24
1952: PUSH
1953: CALL_OW 44
1957: ST_TO_ADDR
// PlaceUnitXY ( russian_patrol_forest , 82 , 2 , false ) ;
1958: LD_EXP 24
1962: PPUSH
1963: LD_INT 82
1965: PPUSH
1966: LD_INT 2
1968: PPUSH
1969: LD_INT 0
1971: PPUSH
1972: CALL_OW 48
// end ;
1976: LD_VAR 0 1
1980: RET
// every 0 0$01 trigger active_road_patrol do
1981: LD_EXP 8
1985: IFFALSE 2051
1987: GO 1989
1989: DISABLE
// ComPatrol ( russian_patrol_tanks [ 1 ] , road , 0 0$02 , [ 131 , 87 , 107 , 75 , 107 , 66 , 114 , 61 , 107 , 34 ] ) ;
1990: LD_EXP 22
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_STRING road
2001: PPUSH
2002: LD_INT 70
2004: PPUSH
2005: LD_INT 131
2007: PUSH
2008: LD_INT 87
2010: PUSH
2011: LD_INT 107
2013: PUSH
2014: LD_INT 75
2016: PUSH
2017: LD_INT 107
2019: PUSH
2020: LD_INT 66
2022: PUSH
2023: LD_INT 114
2025: PUSH
2026: LD_INT 61
2028: PUSH
2029: LD_INT 107
2031: PUSH
2032: LD_INT 34
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 470 0 4
2051: END
// every 0 0$01 trigger active_road_patrol do
2052: LD_EXP 8
2056: IFFALSE 2114
2058: GO 2060
2060: DISABLE
// ComPatrol ( russian_patrol_tanks [ 2 ] , road , 0 0$02 , [ 21 , 12 , 37 , 30 , 65 , 62 , 107 , 76 ] ) ;
2061: LD_EXP 22
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: LD_STRING road
2072: PPUSH
2073: LD_INT 70
2075: PPUSH
2076: LD_INT 21
2078: PUSH
2079: LD_INT 12
2081: PUSH
2082: LD_INT 37
2084: PUSH
2085: LD_INT 30
2087: PUSH
2088: LD_INT 65
2090: PUSH
2091: LD_INT 62
2093: PUSH
2094: LD_INT 107
2096: PUSH
2097: LD_INT 76
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL 470 0 4
2114: END
// every 0 0$01 trigger IsOk ( russian_patrol_forest ) do
2115: LD_EXP 24
2119: PPUSH
2120: CALL_OW 302
2124: IFFALSE 2186
2126: GO 2128
2128: DISABLE
// ComPatrol ( russian_patrol_forest , forest , 0 0$01 , [ 52 , 15 , 81 , 9 , 120 , 52 , 135 , 80 , 122 , 95 ] ) ;
2129: LD_EXP 24
2133: PPUSH
2134: LD_STRING forest
2136: PPUSH
2137: LD_INT 35
2139: PPUSH
2140: LD_INT 52
2142: PUSH
2143: LD_INT 15
2145: PUSH
2146: LD_INT 81
2148: PUSH
2149: LD_INT 9
2151: PUSH
2152: LD_INT 120
2154: PUSH
2155: LD_INT 52
2157: PUSH
2158: LD_INT 135
2160: PUSH
2161: LD_INT 80
2163: PUSH
2164: LD_INT 122
2166: PUSH
2167: LD_INT 95
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL 470 0 4
2186: END
// every 0 0$01 trigger macmilan_use_radio do
2187: LD_EXP 6
2191: IFFALSE 2252
2193: GO 2195
2195: DISABLE
// begin active_road_patrol := false ;
2196: LD_ADDR_EXP 8
2200: PUSH
2201: LD_INT 0
2203: ST_TO_ADDR
// ComStop ( russian_patrol_tanks ) ;
2204: LD_EXP 22
2208: PPUSH
2209: CALL_OW 141
// AddComAgressiveMove ( russian_patrol_tanks , 72 , 41 ) ;
2213: LD_EXP 22
2217: PPUSH
2218: LD_INT 72
2220: PPUSH
2221: LD_INT 41
2223: PPUSH
2224: CALL_OW 174
// ComExitBuilding ( russian_troops_2 ) ;
2228: LD_EXP 21
2232: PPUSH
2233: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , 72 , 41 ) ;
2237: LD_EXP 21
2241: PPUSH
2242: LD_INT 72
2244: PPUSH
2245: LD_INT 41
2247: PPUSH
2248: CALL_OW 174
// end ;
2252: END
// every 0 0$03 trigger FilterUnitsInArea ( def_south , [ f_side , 1 ] ) do var un ;
2253: LD_INT 9
2255: PPUSH
2256: LD_INT 22
2258: PUSH
2259: LD_INT 1
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL_OW 70
2270: IFFALSE 2344
2272: GO 2274
2274: DISABLE
2275: LD_INT 0
2277: PPUSH
// begin enable ;
2278: ENABLE
// un := FilterUnitsInArea ( def_south , [ f_side , 1 ] ) [ 1 ] ;
2279: LD_ADDR_VAR 0 1
2283: PUSH
2284: LD_INT 9
2286: PPUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL_OW 70
2301: PUSH
2302: LD_INT 1
2304: ARRAY
2305: ST_TO_ADDR
// ComExitBuilding ( russian_troops_2 ) ;
2306: LD_EXP 21
2310: PPUSH
2311: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , GetX ( un ) , GetY ( un ) ) ;
2315: LD_EXP 21
2319: PPUSH
2320: LD_VAR 0 1
2324: PPUSH
2325: CALL_OW 250
2329: PPUSH
2330: LD_VAR 0 1
2334: PPUSH
2335: CALL_OW 251
2339: PPUSH
2340: CALL_OW 174
// end ;
2344: PPOPN 1
2346: END
// every 0 0$01 trigger ( GetLives ( russian_patrol_tanks [ 1 ] ) < 999 or GetLives ( russian_patrol_tanks [ 2 ] ) < 999 ) and See ( 3 , JMM ) do
2347: LD_EXP 22
2351: PUSH
2352: LD_INT 1
2354: ARRAY
2355: PPUSH
2356: CALL_OW 256
2360: PUSH
2361: LD_INT 999
2363: LESS
2364: PUSH
2365: LD_EXP 22
2369: PUSH
2370: LD_INT 2
2372: ARRAY
2373: PPUSH
2374: CALL_OW 256
2378: PUSH
2379: LD_INT 999
2381: LESS
2382: OR
2383: PUSH
2384: LD_INT 3
2386: PPUSH
2387: LD_EXP 15
2391: PPUSH
2392: CALL_OW 292
2396: AND
2397: IFFALSE 2424
2399: GO 2401
2401: DISABLE
// begin active_road_patrol := false ;
2402: LD_ADDR_EXP 8
2406: PUSH
2407: LD_INT 0
2409: ST_TO_ADDR
// ComAttackUnit ( russian_patrol_tanks , JMM ) ;
2410: LD_EXP 22
2414: PPUSH
2415: LD_EXP 15
2419: PPUSH
2420: CALL_OW 115
// end ;
2424: END
// every 0 0$01 trigger macmilan_in_trap do
2425: LD_EXP 9
2429: IFFALSE 2475
2431: GO 2433
2433: DISABLE
// begin ComExitBuilding ( russian_troops_2 ) ;
2434: LD_EXP 21
2438: PPUSH
2439: CALL_OW 122
// ComAttackUnit ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , JMM ) ;
2443: LD_EXP 20
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: PUSH
2454: LD_EXP 25
2458: ADD
2459: PUSH
2460: LD_EXP 22
2464: ADD
2465: PPUSH
2466: LD_EXP 15
2470: PPUSH
2471: CALL_OW 115
// end ;
2475: END
// every 0 0$01 trigger meta_action do
2476: LD_EXP 10
2480: IFFALSE 2526
2482: GO 2484
2484: DISABLE
// begin active_road_patrol := false ;
2485: LD_ADDR_EXP 8
2489: PUSH
2490: LD_INT 0
2492: ST_TO_ADDR
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , 93 , 1 ) ;
2493: LD_EXP 20
2497: PUSH
2498: LD_EXP 21
2502: ADD
2503: PUSH
2504: LD_EXP 25
2508: ADD
2509: PUSH
2510: LD_EXP 22
2514: ADD
2515: PPUSH
2516: LD_INT 93
2518: PPUSH
2519: LD_INT 1
2521: PPUSH
2522: CALL_OW 114
// end ;
2526: END
// every 0 0$1 trigger GetLives ( Pokryshkin ) < 1000 do
2527: LD_EXP 25
2531: PPUSH
2532: CALL_OW 256
2536: PUSH
2537: LD_INT 1000
2539: LESS
2540: IFFALSE 2591
2542: GO 2544
2544: DISABLE
// begin enable ;
2545: ENABLE
// if HexInfo ( 18 , 1 ) = Pokryshkin then
2546: LD_INT 18
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 428
2556: PUSH
2557: LD_EXP 25
2561: EQUAL
2562: IFFALSE 2576
// begin RemoveUnit ( Pokryshkin ) ;
2564: LD_EXP 25
2568: PPUSH
2569: CALL_OW 64
// disable ;
2573: DISABLE
// end else
2574: GO 2591
// ComMoveXY ( Pokryshkin , 18 , 1 ) ;
2576: LD_EXP 25
2580: PPUSH
2581: LD_INT 18
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: CALL_OW 111
// end ;
2591: END
// every 0 0$20 trigger send_troops_to_forest do
2592: LD_EXP 14
2596: IFFALSE 2650
2598: GO 2600
2600: DISABLE
// begin if not IsOk ( russian_patrol_forest ) then
2601: LD_EXP 24
2605: PPUSH
2606: CALL_OW 302
2610: NOT
2611: IFFALSE 2615
// exit ;
2613: GO 2650
// ComAgressiveMove ( russian_troops_1 ^ Pokryshkin , GetRememberedX ( russian_patrol_forest ) , GetRememberedY ( russian_patrol_forest ) ) ;
2615: LD_EXP 20
2619: PUSH
2620: LD_EXP 25
2624: ADD
2625: PPUSH
2626: LD_EXP 24
2630: PPUSH
2631: CALL_OW 252
2635: PPUSH
2636: LD_EXP 24
2640: PPUSH
2641: CALL_OW 253
2645: PPUSH
2646: CALL_OW 114
// end ;
2650: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do begin if GetSide ( driver ) = 3 then
2651: LD_VAR 0 1
2655: PPUSH
2656: CALL_OW 255
2660: PUSH
2661: LD_INT 3
2663: EQUAL
2664: IFFALSE 2707
// begin wait ( 11 ) ;
2666: LD_INT 11
2668: PPUSH
2669: CALL_OW 67
// ComEnterUnit ( driver , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_depot ] ) , driver ) ) ;
2673: LD_VAR 0 1
2677: PPUSH
2678: LD_INT 30
2680: PUSH
2681: LD_INT 0
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: PPUSH
2693: LD_VAR 0 1
2697: PPUSH
2698: CALL_OW 74
2702: PPUSH
2703: CALL_OW 120
// end ; end ; end_of_file
2707: PPOPN 4
2709: END
// export function Action ; var i ; begin
2710: LD_INT 0
2712: PPUSH
2713: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_INT 22
2721: PUSH
2722: LD_INT 3
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 25
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2762
// ComHold ( i ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: CALL_OW 140
2760: GO 2748
2762: POP
2763: POP
// InGameOn ;
2764: CALL_OW 8
// CenterOnXY ( 79 , 76 ) ;
2768: LD_INT 79
2770: PPUSH
2771: LD_INT 76
2773: PPUSH
2774: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
2778: LD_INT 10
2780: PPUSH
2781: CALL_OW 67
// PlaceUnitXY ( JMM , 80 , 79 , true ) ;
2785: LD_EXP 15
2789: PPUSH
2790: LD_INT 80
2792: PPUSH
2793: LD_INT 79
2795: PPUSH
2796: LD_INT 1
2798: PPUSH
2799: CALL_OW 48
// Wait ( 0 0$03 ) ;
2803: LD_INT 105
2805: PPUSH
2806: CALL_OW 67
// ComMoveXY ( JMM , 80 , 76 ) ;
2810: LD_EXP 15
2814: PPUSH
2815: LD_INT 80
2817: PPUSH
2818: LD_INT 76
2820: PPUSH
2821: CALL_OW 111
// Say ( JMM , D1-JMM-1 ) ;
2825: LD_EXP 15
2829: PPUSH
2830: LD_STRING D1-JMM-1
2832: PPUSH
2833: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2837: LD_INT 10
2839: PPUSH
2840: CALL_OW 67
// ComMoveXY ( JMM , 76 , 76 ) ;
2844: LD_EXP 15
2848: PPUSH
2849: LD_INT 76
2851: PPUSH
2852: LD_INT 76
2854: PPUSH
2855: CALL_OW 111
// Say ( JMM , D1-JMM-1a ) ;
2859: LD_EXP 15
2863: PPUSH
2864: LD_STRING D1-JMM-1a
2866: PPUSH
2867: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2871: LD_INT 10
2873: PPUSH
2874: CALL_OW 67
// ComTurnXY ( JMM , 83 , 66 ) ;
2878: LD_EXP 15
2882: PPUSH
2883: LD_INT 83
2885: PPUSH
2886: LD_INT 66
2888: PPUSH
2889: CALL_OW 118
// Say ( JMM , D1-JMM-1b ) ;
2893: LD_EXP 15
2897: PPUSH
2898: LD_STRING D1-JMM-1b
2900: PPUSH
2901: CALL_OW 88
// Wait ( 0 0$0.5 ) ;
2905: LD_INT 18
2907: PPUSH
2908: CALL_OW 67
// Say ( JMM , D1-JMM-1c ) ;
2912: LD_EXP 15
2916: PPUSH
2917: LD_STRING D1-JMM-1c
2919: PPUSH
2920: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
2924: LD_INT 7
2926: PPUSH
2927: CALL_OW 67
// SayRadio ( Powell , D1-Pow-1 ) ;
2931: LD_EXP 18
2935: PPUSH
2936: LD_STRING D1-Pow-1
2938: PPUSH
2939: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
2943: LD_EXP 15
2947: PPUSH
2948: LD_STRING D1-JMM-2
2950: PPUSH
2951: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
2955: LD_EXP 18
2959: PPUSH
2960: LD_STRING D1-Pow-2
2962: PPUSH
2963: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
2967: LD_EXP 15
2971: PPUSH
2972: LD_STRING D1-JMM-3
2974: PPUSH
2975: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_STRING D1-Pow-3
2986: PPUSH
2987: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
2991: LD_EXP 15
2995: PPUSH
2996: LD_STRING D1-JMM-4
2998: PPUSH
2999: CALL_OW 88
// ComFree ( JMM ) ;
3003: LD_EXP 15
3007: PPUSH
3008: CALL_OW 139
// Wait ( 0 0$0.3 ) ;
3012: LD_INT 10
3014: PPUSH
3015: CALL_OW 67
// InGameOff ;
3019: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3023: LD_STRING M1
3025: PPUSH
3026: CALL_OW 337
// SaveForQuickRestart ;
3030: CALL_OW 22
// active_russian_dialog := true ;
3034: LD_ADDR_EXP 3
3038: PUSH
3039: LD_INT 1
3041: ST_TO_ADDR
// active_road_patrol := true ;
3042: LD_ADDR_EXP 8
3046: PUSH
3047: LD_INT 1
3049: ST_TO_ADDR
// if Difficulty < 3 then
3050: LD_OWVAR 67
3054: PUSH
3055: LD_INT 3
3057: LESS
3058: IFFALSE 3089
// begin PlaceUnitXY ( Bobby , 41 , 71 , false ) ;
3060: LD_EXP 16
3064: PPUSH
3065: LD_INT 41
3067: PPUSH
3068: LD_INT 71
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 48
// ComHold ( Bobby ) ;
3078: LD_EXP 16
3082: PPUSH
3083: CALL_OW 140
// end else
3087: GO 3137
// begin SetDir ( Bobby , 5 ) ;
3089: LD_EXP 16
3093: PPUSH
3094: LD_INT 5
3096: PPUSH
3097: CALL_OW 233
// PlaceUnitXY ( Bobby , 105 , 98 , false ) ;
3101: LD_EXP 16
3105: PPUSH
3106: LD_INT 105
3108: PPUSH
3109: LD_INT 98
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 48
// ComCrawl ( Bobby ) ;
3119: LD_EXP 16
3123: PPUSH
3124: CALL_OW 137
// AddComHold ( Bobby ) ;
3128: LD_EXP 16
3132: PPUSH
3133: CALL_OW 200
// end ; PlaceUnitXY ( Cyrus , 90 , 42 , false ) ;
3137: LD_EXP 17
3141: PPUSH
3142: LD_INT 90
3144: PPUSH
3145: LD_INT 42
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 48
// ComMoveXY ( Cyrus , 79 , 34 ) ;
3155: LD_EXP 17
3159: PPUSH
3160: LD_INT 79
3162: PPUSH
3163: LD_INT 34
3165: PPUSH
3166: CALL_OW 111
// AddComCrawl ( Cyrus ) ;
3170: LD_EXP 17
3174: PPUSH
3175: CALL_OW 197
// end ;
3179: LD_VAR 0 1
3183: RET
// every 0 0$01 trigger active_russian_dialog do var wait_points ;
3184: LD_EXP 3
3188: IFFALSE 3811
3190: GO 3192
3192: DISABLE
3193: LD_INT 0
3195: PPUSH
// begin wait_points := 0 ;
3196: LD_ADDR_VAR 0 1
3200: PUSH
3201: LD_INT 0
3203: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
3204: LD_INT 70
3206: PPUSH
3207: CALL_OW 67
// ComAgressiveMove ( russian_troops_1 , 79 , 83 ) ;
3211: LD_EXP 20
3215: PPUSH
3216: LD_INT 79
3218: PPUSH
3219: LD_INT 83
3221: PPUSH
3222: CALL_OW 114
// Say ( russian_troops_1 [ 2 ] , D1R-Rus1-1 ) ;
3226: LD_EXP 20
3230: PUSH
3231: LD_INT 2
3233: ARRAY
3234: PPUSH
3235: LD_STRING D1R-Rus1-1
3237: PPUSH
3238: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1R-Rus2-1 ) ;
3242: LD_EXP 20
3246: PUSH
3247: LD_INT 1
3249: ARRAY
3250: PPUSH
3251: LD_STRING D1R-Rus2-1
3253: PPUSH
3254: CALL_OW 88
// ComAgressiveMove ( russian_troops_2 , 91 , 80 ) ;
3258: LD_EXP 21
3262: PPUSH
3263: LD_INT 91
3265: PPUSH
3266: LD_INT 80
3268: PPUSH
3269: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3273: LD_INT 35
3275: PPUSH
3276: CALL_OW 67
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 79 , 82 ) < 5 ;
3280: LD_EXP 20
3284: PUSH
3285: LD_INT 1
3287: ARRAY
3288: PPUSH
3289: LD_INT 79
3291: PPUSH
3292: LD_INT 82
3294: PPUSH
3295: CALL_OW 297
3299: PUSH
3300: LD_INT 5
3302: LESS
3303: IFFALSE 3273
// if not IsInArea ( JMM , jmm_spot ) then
3305: LD_EXP 15
3309: PPUSH
3310: LD_INT 5
3312: PPUSH
3313: CALL_OW 308
3317: NOT
3318: IFFALSE 3338
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1 ) else
3320: LD_EXP 20
3324: PUSH
3325: LD_INT 1
3327: ARRAY
3328: PPUSH
3329: LD_STRING D1Ra-Rus2-1
3331: PPUSH
3332: CALL_OW 88
3336: GO 3474
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3338: LD_EXP 20
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PPUSH
3347: LD_STRING D1Rb-Rus1-1
3349: PPUSH
3350: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Rb-Rus2-1 ) ;
3354: LD_EXP 20
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: LD_STRING D1Rb-Rus2-1
3365: PPUSH
3366: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 , GetX ( JMM ) , GetY ( JMM ) ) ;
3370: LD_EXP 20
3374: PUSH
3375: LD_EXP 21
3379: ADD
3380: PPUSH
3381: LD_EXP 15
3385: PPUSH
3386: CALL_OW 250
3390: PPUSH
3391: LD_EXP 15
3395: PPUSH
3396: CALL_OW 251
3400: PPUSH
3401: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3405: LD_INT 35
3407: PPUSH
3408: CALL_OW 67
// until not IsInArea ( JMM , jmm_spot ) and not See ( 3 , jmm ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_INT 5
3419: PPUSH
3420: CALL_OW 308
3424: NOT
3425: PUSH
3426: LD_INT 3
3428: PPUSH
3429: LD_EXP 15
3433: PPUSH
3434: CALL_OW 292
3438: NOT
3439: AND
3440: IFFALSE 3405
// Say ( russian_troops_1 [ 2 ] , D1Rc-Rus1-1 ) ;
3442: LD_EXP 20
3446: PUSH
3447: LD_INT 2
3449: ARRAY
3450: PPUSH
3451: LD_STRING D1Rc-Rus1-1
3453: PPUSH
3454: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1a ) ;
3458: LD_EXP 20
3462: PUSH
3463: LD_INT 1
3465: ARRAY
3466: PPUSH
3467: LD_STRING D1Ra-Rus2-1a
3469: PPUSH
3470: CALL_OW 88
// end ; wait_points := 10 ;
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: LD_INT 10
3481: ST_TO_ADDR
// if Difficulty > 1 then
3482: LD_OWVAR 67
3486: PUSH
3487: LD_INT 1
3489: GREATER
3490: IFFALSE 3572
// begin ComAgressiveMove ( russian_troops_1 , 78 , 95 ) ;
3492: LD_EXP 20
3496: PPUSH
3497: LD_INT 78
3499: PPUSH
3500: LD_INT 95
3502: PPUSH
3503: CALL_OW 114
// AddComWait ( russian_troops_1 , 0 0$05 ) ;
3507: LD_EXP 20
3511: PPUSH
3512: LD_INT 175
3514: PPUSH
3515: CALL_OW 202
// wait_points := wait_points + 15 ;
3519: LD_ADDR_VAR 0 1
3523: PUSH
3524: LD_VAR 0 1
3528: PUSH
3529: LD_INT 15
3531: PLUS
3532: ST_TO_ADDR
// if Difficulty > 2 then
3533: LD_OWVAR 67
3537: PUSH
3538: LD_INT 2
3540: GREATER
3541: IFFALSE 3572
// begin AddComAgressiveMove ( russian_troops_1 , 65 , 79 ) ;
3543: LD_EXP 20
3547: PPUSH
3548: LD_INT 65
3550: PPUSH
3551: LD_INT 79
3553: PPUSH
3554: CALL_OW 174
// wait_points := wait_points + 5 ;
3558: LD_ADDR_VAR 0 1
3562: PUSH
3563: LD_VAR 0 1
3567: PUSH
3568: LD_INT 5
3570: PLUS
3571: ST_TO_ADDR
// end ; end ; repeat wait ( 0 0$01 ) ;
3572: LD_INT 35
3574: PPUSH
3575: CALL_OW 67
// wait_points := wait_points - 1 ;
3579: LD_ADDR_VAR 0 1
3583: PUSH
3584: LD_VAR 0 1
3588: PUSH
3589: LD_INT 1
3591: MINUS
3592: ST_TO_ADDR
// if See ( 3 , JMM ) then
3593: LD_INT 3
3595: PPUSH
3596: LD_EXP 15
3600: PPUSH
3601: CALL_OW 292
3605: IFFALSE 3659
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3607: LD_EXP 20
3611: PUSH
3612: LD_INT 2
3614: ARRAY
3615: PPUSH
3616: LD_STRING D1Rb-Rus1-1
3618: PPUSH
3619: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3623: LD_EXP 20
3627: PPUSH
3628: LD_EXP 15
3632: PPUSH
3633: CALL_OW 250
3637: PPUSH
3638: LD_EXP 15
3642: PPUSH
3643: CALL_OW 251
3647: PPUSH
3648: CALL_OW 114
// Wait ( 0 0$03 ) ;
3652: LD_INT 105
3654: PPUSH
3655: CALL_OW 67
// end ; until wait_points = 0 ;
3659: LD_VAR 0 1
3663: PUSH
3664: LD_INT 0
3666: EQUAL
3667: IFFALSE 3572
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3669: LD_EXP 20
3673: PPUSH
3674: LD_INT 45
3676: PPUSH
3677: LD_INT 5
3679: PPUSH
3680: CALL_OW 114
// ComEnterUnit ( russian_troops_2 , rbar1 ) ;
3684: LD_EXP 21
3688: PPUSH
3689: LD_INT 26
3691: PPUSH
3692: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
3696: LD_INT 35
3698: PPUSH
3699: CALL_OW 67
// if See ( 3 , JMM ) then
3703: LD_INT 3
3705: PPUSH
3706: LD_EXP 15
3710: PPUSH
3711: CALL_OW 292
3715: IFFALSE 3771
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3717: LD_EXP 20
3721: PUSH
3722: LD_INT 2
3724: ARRAY
3725: PPUSH
3726: LD_STRING D1Rb-Rus1-1
3728: PPUSH
3729: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3733: LD_EXP 20
3737: PPUSH
3738: LD_EXP 15
3742: PPUSH
3743: CALL_OW 250
3747: PPUSH
3748: LD_EXP 15
3752: PPUSH
3753: CALL_OW 251
3757: PPUSH
3758: CALL_OW 114
// Wait ( 0 0$50 ) ;
3762: LD_INT 1750
3764: PPUSH
3765: CALL_OW 67
// end else
3769: GO 3786
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3771: LD_EXP 20
3775: PPUSH
3776: LD_INT 45
3778: PPUSH
3779: LD_INT 5
3781: PPUSH
3782: CALL_OW 114
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 45 , 5 ) < 10 ;
3786: LD_EXP 20
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: PPUSH
3795: LD_INT 45
3797: PPUSH
3798: LD_INT 5
3800: PPUSH
3801: CALL_OW 297
3805: PUSH
3806: LD_INT 10
3808: LESS
3809: IFFALSE 3696
// end ;
3811: PPOPN 1
3813: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 6 ] ] ) and Difficulty = 1 do
3814: LD_INT 22
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 92
3826: PUSH
3827: LD_INT 80
3829: PUSH
3830: LD_INT 83
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PPUSH
3846: CALL_OW 69
3850: PUSH
3851: LD_OWVAR 67
3855: PUSH
3856: LD_INT 1
3858: EQUAL
3859: AND
3860: IFFALSE 3941
3862: GO 3864
3864: DISABLE
// begin PlaceSeeing ( 80 , 83 , 1 , - 7 ) ;
3865: LD_INT 80
3867: PPUSH
3868: LD_INT 83
3870: PPUSH
3871: LD_INT 1
3873: PPUSH
3874: LD_INT 7
3876: NEG
3877: PPUSH
3878: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
3882: LD_INT 35
3884: PPUSH
3885: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 10 ] ] ) ;
3889: LD_INT 22
3891: PUSH
3892: LD_INT 3
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PUSH
3899: LD_INT 92
3901: PUSH
3902: LD_INT 80
3904: PUSH
3905: LD_INT 83
3907: PUSH
3908: LD_INT 10
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: PPUSH
3921: CALL_OW 69
3925: NOT
3926: IFFALSE 3882
// RemoveSeeing ( 80 , 83 , 1 ) ;
3928: LD_INT 80
3930: PPUSH
3931: LD_INT 83
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 331
// end ;
3941: END
// every 0 0$02 trigger GetDistUnits ( JMM , Bobby ) < 9 do
3942: LD_EXP 15
3946: PPUSH
3947: LD_EXP 16
3951: PPUSH
3952: CALL_OW 296
3956: PUSH
3957: LD_INT 9
3959: LESS
3960: IFFALSE 4411
3962: GO 3964
3964: DISABLE
// begin ComWalk ( Bobby ) ;
3965: LD_EXP 16
3969: PPUSH
3970: CALL_OW 138
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
3974: LD_EXP 16
3978: PPUSH
3979: LD_EXP 15
3983: PPUSH
3984: CALL_OW 250
3988: PPUSH
3989: LD_EXP 15
3993: PPUSH
3994: CALL_OW 251
3998: PPUSH
3999: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
4003: LD_INT 35
4005: PPUSH
4006: CALL_OW 67
// until See ( 4 , JMM ) ;
4010: LD_INT 4
4012: PPUSH
4013: LD_EXP 15
4017: PPUSH
4018: CALL_OW 292
4022: IFFALSE 4003
// InGameOn ;
4024: CALL_OW 8
// ComTurnUnit ( JMM , Bobby ) ;
4028: LD_EXP 15
4032: PPUSH
4033: LD_EXP 16
4037: PPUSH
4038: CALL_OW 119
// if cyrus_in_squad and IsOk ( Cyrus ) and GetDistUnits ( JMM , Cyrus ) < 10 then
4042: LD_EXP 7
4046: PUSH
4047: LD_EXP 17
4051: PPUSH
4052: CALL_OW 302
4056: AND
4057: PUSH
4058: LD_EXP 15
4062: PPUSH
4063: LD_EXP 17
4067: PPUSH
4068: CALL_OW 296
4072: PUSH
4073: LD_INT 10
4075: LESS
4076: AND
4077: IFFALSE 4122
// begin ComMoveXY ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4079: LD_EXP 17
4083: PPUSH
4084: LD_EXP 15
4088: PPUSH
4089: CALL_OW 250
4093: PPUSH
4094: LD_EXP 15
4098: PPUSH
4099: CALL_OW 251
4103: PPUSH
4104: CALL_OW 111
// AddComTurnUnit ( Cyrus , Bobby ) ;
4108: LD_EXP 17
4112: PPUSH
4113: LD_EXP 16
4117: PPUSH
4118: CALL_OW 179
// end ; Say ( JMM , D2-JMM-1 ) ;
4122: LD_EXP 15
4126: PPUSH
4127: LD_STRING D2-JMM-1
4129: PPUSH
4130: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4134: LD_INT 10
4136: PPUSH
4137: CALL_OW 67
// ComTurnUnit ( Bobby , JMM ) ;
4141: LD_EXP 16
4145: PPUSH
4146: LD_EXP 15
4150: PPUSH
4151: CALL_OW 119
// Say ( Bobby , D2-Bobby-1 ) ;
4155: LD_EXP 16
4159: PPUSH
4160: LD_STRING D2-Bobby-1
4162: PPUSH
4163: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
4167: LD_EXP 15
4171: PPUSH
4172: LD_STRING D2-JMM-2
4174: PPUSH
4175: CALL_OW 88
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4179: LD_EXP 16
4183: PPUSH
4184: LD_EXP 15
4188: PPUSH
4189: CALL_OW 250
4193: PPUSH
4194: LD_EXP 15
4198: PPUSH
4199: CALL_OW 251
4203: PPUSH
4204: CALL_OW 111
// Say ( Bobby , D2-Bobby-2 ) ;
4208: LD_EXP 16
4212: PPUSH
4213: LD_STRING D2-Bobby-2
4215: PPUSH
4216: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
4220: LD_EXP 15
4224: PPUSH
4225: LD_STRING D2-JMM-3
4227: PPUSH
4228: CALL_OW 88
// ComTurnUnit ( Bobby , JMM ) ;
4232: LD_EXP 16
4236: PPUSH
4237: LD_EXP 15
4241: PPUSH
4242: CALL_OW 119
// Say ( Bobby , D2-Bobby-3 ) ;
4246: LD_EXP 16
4250: PPUSH
4251: LD_STRING D2-Bobby-3
4253: PPUSH
4254: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
4258: LD_EXP 15
4262: PPUSH
4263: LD_STRING D2-JMM-4
4265: PPUSH
4266: CALL_OW 88
// Say ( Bobby , D2-Bobby-4 ) ;
4270: LD_EXP 16
4274: PPUSH
4275: LD_STRING D2-Bobby-4
4277: PPUSH
4278: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
4282: LD_EXP 15
4286: PPUSH
4287: LD_STRING D2-JMM-5
4289: PPUSH
4290: CALL_OW 88
// Say ( Bobby , D2-Bobby-5 ) ;
4294: LD_EXP 16
4298: PPUSH
4299: LD_STRING D2-Bobby-5
4301: PPUSH
4302: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
4306: LD_EXP 15
4310: PPUSH
4311: LD_STRING D2-JMM-6
4313: PPUSH
4314: CALL_OW 88
// if not powell_contact then
4318: LD_EXP 5
4322: NOT
4323: IFFALSE 4349
// begin Say ( Bobby , D2-Bobby-6 ) ;
4325: LD_EXP 16
4329: PPUSH
4330: LD_STRING D2-Bobby-6
4332: PPUSH
4333: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4337: LD_EXP 15
4341: PPUSH
4342: LD_STRING D2-JMM-7
4344: PPUSH
4345: CALL_OW 88
// end ; InGameOff ;
4349: CALL_OW 9
// SetSide ( Bobby , 1 ) ;
4353: LD_EXP 16
4357: PPUSH
4358: LD_INT 1
4360: PPUSH
4361: CALL_OW 235
// ComFree ( [ JMM , Bobby ] ) ;
4365: LD_EXP 15
4369: PUSH
4370: LD_EXP 16
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PPUSH
4379: CALL_OW 139
// bobby_in_squad := true ;
4383: LD_ADDR_EXP 4
4387: PUSH
4388: LD_INT 1
4390: ST_TO_ADDR
// if powell_contact and not cyrus_in_squad then
4391: LD_EXP 5
4395: PUSH
4396: LD_EXP 7
4400: NOT
4401: AND
4402: IFFALSE 4411
// ChangeMissionObjectives ( M2b ) ;
4404: LD_STRING M2b
4406: PPUSH
4407: CALL_OW 337
// end ;
4411: END
// every 0 0$45 trigger active_russian_dialog and not bobby_in_squad and Difficulty < 3 do
4412: LD_EXP 3
4416: PUSH
4417: LD_EXP 4
4421: NOT
4422: AND
4423: PUSH
4424: LD_OWVAR 67
4428: PUSH
4429: LD_INT 3
4431: LESS
4432: AND
4433: IFFALSE 4453
4435: GO 4437
4437: DISABLE
// ComMoveXY ( Bobby , 75 , 83 ) ;
4438: LD_EXP 16
4442: PPUSH
4443: LD_INT 75
4445: PPUSH
4446: LD_INT 83
4448: PPUSH
4449: CALL_OW 111
4453: END
// every 0 0$10 trigger cyrus_in_squad and not bobby_in_squad do
4454: LD_EXP 7
4458: PUSH
4459: LD_EXP 4
4463: NOT
4464: AND
4465: IFFALSE 4494
4467: GO 4469
4469: DISABLE
// begin ComMoveXY ( Bobby , 105 , 97 ) ;
4470: LD_EXP 16
4474: PPUSH
4475: LD_INT 105
4477: PPUSH
4478: LD_INT 97
4480: PPUSH
4481: CALL_OW 111
// AddComCrawl ( Bobby ) ;
4485: LD_EXP 16
4489: PPUSH
4490: CALL_OW 197
// end ;
4494: END
// every 0 0$01 trigger IsInArea ( JMM , obstacle_area ) and GetDistUnits ( JMM , Bobby ) < 7 and bobby_in_squad do
4495: LD_EXP 15
4499: PPUSH
4500: LD_INT 6
4502: PPUSH
4503: CALL_OW 308
4507: PUSH
4508: LD_EXP 15
4512: PPUSH
4513: LD_EXP 16
4517: PPUSH
4518: CALL_OW 296
4522: PUSH
4523: LD_INT 7
4525: LESS
4526: AND
4527: PUSH
4528: LD_EXP 4
4532: AND
4533: IFFALSE 4580
4535: GO 4537
4537: DISABLE
// begin ComHold ( [ JMM , Bobby ] ) ;
4538: LD_EXP 15
4542: PUSH
4543: LD_EXP 16
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: PPUSH
4552: CALL_OW 140
// Say ( JMM , D2a-JMM-1 ) ;
4556: LD_EXP 15
4560: PPUSH
4561: LD_STRING D2a-JMM-1
4563: PPUSH
4564: CALL_OW 88
// Say ( Bobby , D2a-Bobby-1 ) ;
4568: LD_EXP 16
4572: PPUSH
4573: LD_STRING D2a-Bobby-1
4575: PPUSH
4576: CALL_OW 88
// end ;
4580: END
// every 0 0$50 trigger active_russian_dialog and not See ( 3 , JMM ) do
4581: LD_EXP 3
4585: PUSH
4586: LD_INT 3
4588: PPUSH
4589: LD_EXP 15
4593: PPUSH
4594: CALL_OW 292
4598: NOT
4599: AND
4600: IFFALSE 4776
4602: GO 4604
4604: DISABLE
// begin Wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
4605: LD_INT 350
4607: PPUSH
4608: LD_INT 700
4610: PPUSH
4611: CALL_OW 12
4615: PPUSH
4616: CALL_OW 67
// InGameOn ;
4620: CALL_OW 8
// DialogueOn ;
4624: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4628: LD_EXP 18
4632: PPUSH
4633: LD_STRING D3-Pow-1
4635: PPUSH
4636: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
4640: LD_EXP 15
4644: PPUSH
4645: LD_STRING D3-JMM-1
4647: PPUSH
4648: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4652: LD_EXP 18
4656: PPUSH
4657: LD_STRING D3-Pow-2
4659: PPUSH
4660: CALL_OW 94
// Say ( JMM , D3-JMM-2 ) ;
4664: LD_EXP 15
4668: PPUSH
4669: LD_STRING D3-JMM-2
4671: PPUSH
4672: CALL_OW 88
// SayRadio ( Powell , D3-Pow-3 ) ;
4676: LD_EXP 18
4680: PPUSH
4681: LD_STRING D3-Pow-3
4683: PPUSH
4684: CALL_OW 94
// DialogueOff ;
4688: CALL_OW 7
// InGameOff ;
4692: CALL_OW 9
// powell_contact := true ;
4696: LD_ADDR_EXP 5
4700: PUSH
4701: LD_INT 1
4703: ST_TO_ADDR
// SetAreaMapShow ( exitArea , 1 ) ;
4704: LD_INT 10
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 424
// uc_side := 4 ;
4714: LD_ADDR_OWVAR 20
4718: PUSH
4719: LD_INT 4
4721: ST_TO_ADDR
// uc_nation := 1 ;
4722: LD_ADDR_OWVAR 21
4726: PUSH
4727: LD_INT 1
4729: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
4730: LD_ADDR_EXP 18
4734: PUSH
4735: LD_STRING Powell
4737: PPUSH
4738: LD_INT 0
4740: PPUSH
4741: CALL 189 0 2
4745: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
4746: LD_STRING M2
4748: PPUSH
4749: CALL_OW 337
// if not bobby_in_squad then
4753: LD_EXP 4
4757: NOT
4758: IFFALSE 4769
// ChangeMissionObjectives ( M2a ) else
4760: LD_STRING M2a
4762: PPUSH
4763: CALL_OW 337
4767: GO 4776
// ChangeMissionObjectives ( M2b ) ;
4769: LD_STRING M2b
4771: PPUSH
4772: CALL_OW 337
// end ;
4776: END
// every 0 0$01 trigger IsInArea ( JMM , fakeArea ) do
4777: LD_EXP 15
4781: PPUSH
4782: LD_INT 7
4784: PPUSH
4785: CALL_OW 308
4789: IFFALSE 4924
4791: GO 4793
4793: DISABLE
// begin DialogueOn ;
4794: CALL_OW 6
// SayRadio ( fakePokryshkin , D4-Rus3-1 ) ;
4798: LD_EXP 19
4802: PPUSH
4803: LD_STRING D4-Rus3-1
4805: PPUSH
4806: CALL_OW 94
// DialogueOff ;
4810: CALL_OW 7
// ChangeMissionObjectives ( M3a ) ;
4814: LD_STRING M3a
4816: PPUSH
4817: CALL_OW 337
// SetAreaMapShow ( fakeEnd , 1 ) ;
4821: LD_INT 11
4823: PPUSH
4824: LD_INT 1
4826: PPUSH
4827: CALL_OW 424
// Wait ( 0 0$02 ) ;
4831: LD_INT 70
4833: PPUSH
4834: CALL_OW 67
// DialogueOn ;
4838: CALL_OW 6
// SayRadio ( Powell , D4-Pow-1 ) ;
4842: LD_EXP 18
4846: PPUSH
4847: LD_STRING D4-Pow-1
4849: PPUSH
4850: CALL_OW 94
// DialogueOff ;
4854: CALL_OW 7
// ChangeMissionObjectives ( M3b ) ;
4858: LD_STRING M3b
4860: PPUSH
4861: CALL_OW 337
// case Query ( Q1 ) of 1 :
4865: LD_STRING Q1
4867: PPUSH
4868: CALL_OW 97
4872: PUSH
4873: LD_INT 1
4875: DOUBLE
4876: EQUAL
4877: IFTRUE 4881
4879: GO 4912
4881: POP
// begin macmilan_use_radio := true ;
4882: LD_ADDR_EXP 6
4886: PUSH
4887: LD_INT 1
4889: ST_TO_ADDR
// DialogueOn ;
4890: CALL_OW 6
// Say ( JMM , D4a-JMM-1 ) ;
4894: LD_EXP 15
4898: PPUSH
4899: LD_STRING D4a-JMM-1
4901: PPUSH
4902: CALL_OW 88
// DialogueOff ;
4906: CALL_OW 7
// end ; 2 :
4910: GO 4924
4912: LD_INT 2
4914: DOUBLE
4915: EQUAL
4916: IFTRUE 4920
4918: GO 4923
4920: POP
// ; end ;
4921: GO 4924
4923: POP
// end ;
4924: END
// every 0 0$02 trigger GetDistUnits ( JMM , Cyrus ) < 8 do
4925: LD_EXP 15
4929: PPUSH
4930: LD_EXP 17
4934: PPUSH
4935: CALL_OW 296
4939: PUSH
4940: LD_INT 8
4942: LESS
4943: IFFALSE 5234
4945: GO 4947
4947: DISABLE
// begin InGameOn ;
4948: CALL_OW 8
// ComMoveXY ( JMM , GetX ( Cyrus ) , GetY ( Cyrus ) ) ;
4952: LD_EXP 15
4956: PPUSH
4957: LD_EXP 17
4961: PPUSH
4962: CALL_OW 250
4966: PPUSH
4967: LD_EXP 17
4971: PPUSH
4972: CALL_OW 251
4976: PPUSH
4977: CALL_OW 111
// if IsOk ( Bobby ) and bobby_in_squad then
4981: LD_EXP 16
4985: PPUSH
4986: CALL_OW 302
4990: PUSH
4991: LD_EXP 4
4995: AND
4996: IFFALSE 5027
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4998: LD_EXP 16
5002: PPUSH
5003: LD_EXP 15
5007: PPUSH
5008: CALL_OW 250
5012: PPUSH
5013: LD_EXP 15
5017: PPUSH
5018: CALL_OW 251
5022: PPUSH
5023: CALL_OW 111
// Say ( JMM , D5-JMM-1 ) ;
5027: LD_EXP 15
5031: PPUSH
5032: LD_STRING D5-JMM-1
5034: PPUSH
5035: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5039: LD_INT 10
5041: PPUSH
5042: CALL_OW 67
// ComTurnUnit ( JMM , Cyrus ) ;
5046: LD_EXP 15
5050: PPUSH
5051: LD_EXP 17
5055: PPUSH
5056: CALL_OW 119
// ComWalk ( Cyrus ) ;
5060: LD_EXP 17
5064: PPUSH
5065: CALL_OW 138
// ComTurnUnit ( Cyrus , JMM ) ;
5069: LD_EXP 17
5073: PPUSH
5074: LD_EXP 15
5078: PPUSH
5079: CALL_OW 119
// Say ( Cyrus , D5-Cyrus-1 ) ;
5083: LD_EXP 17
5087: PPUSH
5088: LD_STRING D5-Cyrus-1
5090: PPUSH
5091: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5095: LD_EXP 16
5099: PPUSH
5100: CALL_OW 302
5104: PUSH
5105: LD_EXP 4
5109: AND
5110: IFFALSE 5150
// begin ComTurnUnit ( Bobby , Cyrus ) ;
5112: LD_EXP 16
5116: PPUSH
5117: LD_EXP 17
5121: PPUSH
5122: CALL_OW 119
// Say ( Bobby , D5-Bobby-1 ) ;
5126: LD_EXP 16
5130: PPUSH
5131: LD_STRING D5-Bobby-1
5133: PPUSH
5134: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
5138: LD_EXP 15
5142: PPUSH
5143: LD_STRING D5-JMM-2
5145: PPUSH
5146: CALL_OW 88
// end ; InGameOff ;
5150: CALL_OW 9
// cyrus_in_squad := true ;
5154: LD_ADDR_EXP 7
5158: PUSH
5159: LD_INT 1
5161: ST_TO_ADDR
// SetSide ( Cyrus , 1 ) ;
5162: LD_EXP 17
5166: PPUSH
5167: LD_INT 1
5169: PPUSH
5170: CALL_OW 235
// if powell_contact and not bobby_in_squad then
5174: LD_EXP 5
5178: PUSH
5179: LD_EXP 4
5183: NOT
5184: AND
5185: IFFALSE 5194
// ChangeMissionObjectives ( M2b ) ;
5187: LD_STRING M2b
5189: PPUSH
5190: CALL_OW 337
// if not bobby_in_squad and GetSide ( Bobby ) = 4 and IsOk ( Bobby ) then
5194: LD_EXP 4
5198: NOT
5199: PUSH
5200: LD_EXP 16
5204: PPUSH
5205: CALL_OW 255
5209: PUSH
5210: LD_INT 4
5212: EQUAL
5213: AND
5214: PUSH
5215: LD_EXP 16
5219: PPUSH
5220: CALL_OW 302
5224: AND
5225: IFFALSE 5234
// SetAchievement ( ACH_CYRUS ) ;
5227: LD_STRING ACH_CYRUS
5229: PPUSH
5230: CALL_OW 543
// end ;
5234: END
// every 0 0$01 trigger bobby_in_squad and cyrus_in_squad do
5235: LD_EXP 4
5239: PUSH
5240: LD_EXP 7
5244: AND
5245: IFFALSE 5257
5247: GO 5249
5249: DISABLE
// ChangeMissionObjectives ( M2c ) ;
5250: LD_STRING M2c
5252: PPUSH
5253: CALL_OW 337
5257: END
// every 0 0$01 trigger IsInArea ( JMM , trap ) do
5258: LD_EXP 15
5262: PPUSH
5263: LD_INT 8
5265: PPUSH
5266: CALL_OW 308
5270: IFFALSE 5322
5272: GO 5274
5274: DISABLE
// begin macmilan_in_trap := true ;
5275: LD_ADDR_EXP 9
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5283: LD_INT 35
5285: PPUSH
5286: CALL_OW 67
// DialogueOn ;
5290: CALL_OW 6
// Say ( Pokryshkin , D5-Pok-1 ) ;
5294: LD_EXP 25
5298: PPUSH
5299: LD_STRING D5-Pok-1
5301: PPUSH
5302: CALL_OW 88
// DialogueOff ;
5306: CALL_OW 7
// Say ( JMM , D4b-JMM-1 ) ;
5310: LD_EXP 15
5314: PPUSH
5315: LD_STRING D4b-JMM-1
5317: PPUSH
5318: CALL_OW 88
// end ;
5322: END
// every 0 0$01 trigger GetDistUnits ( JMM , russian_meta_guards [ russian_meta_guards ] ) < 12 or UnitFilter ( russian_meta_guards , [ f_not , [ f_lives , 990 ] ] ) do var i , hp ;
5323: LD_EXP 15
5327: PPUSH
5328: LD_EXP 23
5332: PUSH
5333: LD_EXP 23
5337: ARRAY
5338: PPUSH
5339: CALL_OW 296
5343: PUSH
5344: LD_INT 12
5346: LESS
5347: PUSH
5348: LD_EXP 23
5352: PPUSH
5353: LD_INT 3
5355: PUSH
5356: LD_INT 24
5358: PUSH
5359: LD_INT 990
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PPUSH
5370: CALL_OW 72
5374: OR
5375: IFFALSE 5605
5377: GO 5379
5379: DISABLE
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
// begin hp := [ 300 , 250 , 200 ] [ Difficulty ] ;
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_INT 300
5391: PUSH
5392: LD_INT 250
5394: PUSH
5395: LD_INT 200
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: LIST
5402: PUSH
5403: LD_OWVAR 67
5407: ARRAY
5408: ST_TO_ADDR
// for i in russian_meta_guards do
5409: LD_ADDR_VAR 0 1
5413: PUSH
5414: LD_EXP 23
5418: PUSH
5419: FOR_IN
5420: IFFALSE 5460
// if IsOk ( i ) then
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 302
5431: IFFALSE 5458
// SetLives ( i , GetLives ( i ) - hp ) ;
5433: LD_VAR 0 1
5437: PPUSH
5438: LD_VAR 0 1
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_VAR 0 2
5452: MINUS
5453: PPUSH
5454: CALL_OW 234
5458: GO 5419
5460: POP
5461: POP
// DialogueOn ;
5462: CALL_OW 6
// Say ( russian_meta_guards [ russian_meta_guards ] , D6-FRus1-1 ) ;
5466: LD_EXP 23
5470: PUSH
5471: LD_EXP 23
5475: ARRAY
5476: PPUSH
5477: LD_STRING D6-FRus1-1
5479: PPUSH
5480: CALL_OW 88
// Say ( JMM , D6-JMM-1 ) ;
5484: LD_EXP 15
5488: PPUSH
5489: LD_STRING D6-JMM-1
5491: PPUSH
5492: CALL_OW 88
// if IsOk ( Cyrus ) and cyrus_in_squad then
5496: LD_EXP 17
5500: PPUSH
5501: CALL_OW 302
5505: PUSH
5506: LD_EXP 7
5510: AND
5511: IFFALSE 5525
// Say ( Cyrus , D6-Cyrus-1 ) ;
5513: LD_EXP 17
5517: PPUSH
5518: LD_STRING D6-Cyrus-1
5520: PPUSH
5521: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5525: LD_EXP 16
5529: PPUSH
5530: CALL_OW 302
5534: PUSH
5535: LD_EXP 4
5539: AND
5540: IFFALSE 5554
// Say ( Bobby , D6-Bobby-1 ) ;
5542: LD_EXP 16
5546: PPUSH
5547: LD_STRING D6-Bobby-1
5549: PPUSH
5550: CALL_OW 88
// DialogueOff ;
5554: CALL_OW 7
// Wait ( [ 0 0$04 , 0 0$03 , 0 0$02 ] [ Difficulty ] ) ;
5558: LD_INT 140
5560: PUSH
5561: LD_INT 105
5563: PUSH
5564: LD_INT 70
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: LD_OWVAR 67
5576: ARRAY
5577: PPUSH
5578: CALL_OW 67
// meta_action := true ;
5582: LD_ADDR_EXP 10
5586: PUSH
5587: LD_INT 1
5589: ST_TO_ADDR
// ComAgressiveMove ( russian_meta_guards , 94 , 8 ) ;
5590: LD_EXP 23
5594: PPUSH
5595: LD_INT 94
5597: PPUSH
5598: LD_INT 8
5600: PPUSH
5601: CALL_OW 114
// end ;
5605: PPOPN 2
5607: END
// every 0 0$01 trigger GetDistUnitXY ( JMM , 93 , 1 ) < 5 and FilterAllUnits ( [ f_side , 1 ] ) > 1 do
5608: LD_EXP 15
5612: PPUSH
5613: LD_INT 93
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 297
5623: PUSH
5624: LD_INT 5
5626: LESS
5627: PUSH
5628: LD_INT 22
5630: PUSH
5631: LD_INT 1
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: PPUSH
5638: CALL_OW 69
5642: PUSH
5643: LD_INT 1
5645: GREATER
5646: AND
5647: IFFALSE 5664
5649: GO 5651
5651: DISABLE
// Say ( JMM , D6a-JMM-1 ) ;
5652: LD_EXP 15
5656: PPUSH
5657: LD_STRING D6a-JMM-1
5659: PPUSH
5660: CALL_OW 88
5664: END
// on UnitGoesToRed ( un ) do begin if un = JMM then
5665: LD_VAR 0 1
5669: PUSH
5670: LD_EXP 15
5674: EQUAL
5675: IFFALSE 5684
// YouLost ( JMM ) ;
5677: LD_STRING JMM
5679: PPUSH
5680: CALL_OW 104
// end ;
5684: PPOPN 1
5686: END
// on UnitDestroyed ( un ) do begin if un = JMM then
5687: LD_VAR 0 1
5691: PUSH
5692: LD_EXP 15
5696: EQUAL
5697: IFFALSE 5706
// YouLost ( JMM ) ;
5699: LD_STRING JMM
5701: PPUSH
5702: CALL_OW 104
// end ;
5706: PPOPN 1
5708: END
// every 0 0$01 trigger IsInArea ( Bobby , exitArea ) do
5709: LD_EXP 16
5713: PPUSH
5714: LD_INT 10
5716: PPUSH
5717: CALL_OW 308
5721: IFFALSE 5770
5723: GO 5725
5725: DISABLE
// begin bobby_saved := true ;
5726: LD_ADDR_EXP 12
5730: PUSH
5731: LD_INT 1
5733: ST_TO_ADDR
// SaveVariable ( GetLives ( Bobby ) , 01_BobbyLifePoints_1 ) ;
5734: LD_EXP 16
5738: PPUSH
5739: CALL_OW 256
5743: PPUSH
5744: LD_STRING 01_BobbyLifePoints_1
5746: PPUSH
5747: CALL_OW 39
// RemoveUnit ( Bobby ) ;
5751: LD_EXP 16
5755: PPUSH
5756: CALL_OW 64
// AddMedal ( Bobby , 1 ) ;
5760: LD_STRING Bobby
5762: PPUSH
5763: LD_INT 1
5765: PPUSH
5766: CALL_OW 101
// end ;
5770: END
// every 0 0$01 trigger IsInArea ( Cyrus , exitArea ) do
5771: LD_EXP 17
5775: PPUSH
5776: LD_INT 10
5778: PPUSH
5779: CALL_OW 308
5783: IFFALSE 5832
5785: GO 5787
5787: DISABLE
// begin cyrus_saved := true ;
5788: LD_ADDR_EXP 13
5792: PUSH
5793: LD_INT 1
5795: ST_TO_ADDR
// SaveVariable ( GetLives ( Cyrus ) , 01_CyrusLifePoints_1 ) ;
5796: LD_EXP 17
5800: PPUSH
5801: CALL_OW 256
5805: PPUSH
5806: LD_STRING 01_CyrusLifePoints_1
5808: PPUSH
5809: CALL_OW 39
// RemoveUnit ( Cyrus ) ;
5813: LD_EXP 17
5817: PPUSH
5818: CALL_OW 64
// AddMedal ( Cyrus , 1 ) ;
5822: LD_STRING Cyrus
5824: PPUSH
5825: LD_INT 1
5827: PPUSH
5828: CALL_OW 101
// end ;
5832: END
// every 0 0$01 trigger IsInArea ( JMM , exitArea ) do var i , to_reward , wait_for_them , m1 , m2 , m3 ;
5833: LD_EXP 15
5837: PPUSH
5838: LD_INT 10
5840: PPUSH
5841: CALL_OW 308
5845: IFFALSE 6453
5847: GO 5849
5849: DISABLE
5850: LD_INT 0
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
// begin if macmilan_use_radio then
5858: LD_EXP 6
5862: IFFALSE 5871
// SetAchievement ( ACH_RADIO ) ;
5864: LD_STRING ACH_RADIO
5866: PPUSH
5867: CALL_OW 543
// if ( not cyrus_saved and cyrus_in_squad and IsOk ( Cyrus ) ) or ( not bobby_saved and bobby_in_squad and IsOk ( Bobby ) ) then
5871: LD_EXP 13
5875: NOT
5876: PUSH
5877: LD_EXP 7
5881: AND
5882: PUSH
5883: LD_EXP 17
5887: PPUSH
5888: CALL_OW 302
5892: AND
5893: PUSH
5894: LD_EXP 12
5898: NOT
5899: PUSH
5900: LD_EXP 4
5904: AND
5905: PUSH
5906: LD_EXP 16
5910: PPUSH
5911: CALL_OW 302
5915: AND
5916: OR
5917: IFFALSE 5958
// case Query ( Q2 ) of 1 :
5919: LD_STRING Q2
5921: PPUSH
5922: CALL_OW 97
5926: PUSH
5927: LD_INT 1
5929: DOUBLE
5930: EQUAL
5931: IFTRUE 5935
5933: GO 5946
5935: POP
// wait_for_them := true ; 2 :
5936: LD_ADDR_VAR 0 3
5940: PUSH
5941: LD_INT 1
5943: ST_TO_ADDR
5944: GO 5958
5946: LD_INT 2
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5954
5952: GO 5957
5954: POP
// ; end ;
5955: GO 5958
5957: POP
// if wait_for_them then
5958: LD_VAR 0 3
5962: IFFALSE 6075
// repeat wait ( 0 0$01 ) ;
5964: LD_INT 35
5966: PPUSH
5967: CALL_OW 67
// until ( cyrus_saved and bobby_saved ) or ( cyrus_saved and ( not bobby_in_squad or IsDying ( Bobby ) or IsDead ( Bobby ) ) ) or ( bobby_saved and ( not cyrus_in_squad or IsDying ( Cyrus ) or IsDead ( Cyrus ) ) ) or ( IsDead ( Bobby ) and IsDead ( Cyrus ) ) ;
5971: LD_EXP 13
5975: PUSH
5976: LD_EXP 12
5980: AND
5981: PUSH
5982: LD_EXP 13
5986: PUSH
5987: LD_EXP 4
5991: NOT
5992: PUSH
5993: LD_EXP 16
5997: PPUSH
5998: CALL_OW 303
6002: OR
6003: PUSH
6004: LD_EXP 16
6008: PPUSH
6009: CALL_OW 301
6013: OR
6014: AND
6015: OR
6016: PUSH
6017: LD_EXP 12
6021: PUSH
6022: LD_EXP 7
6026: NOT
6027: PUSH
6028: LD_EXP 17
6032: PPUSH
6033: CALL_OW 303
6037: OR
6038: PUSH
6039: LD_EXP 17
6043: PPUSH
6044: CALL_OW 301
6048: OR
6049: AND
6050: OR
6051: PUSH
6052: LD_EXP 16
6056: PPUSH
6057: CALL_OW 301
6061: PUSH
6062: LD_EXP 17
6066: PPUSH
6067: CALL_OW 301
6071: AND
6072: OR
6073: IFFALSE 5964
// SaveVariable ( GetLives ( JMM ) , 01_JMMLifePoints_1 ) ;
6075: LD_EXP 15
6079: PPUSH
6080: CALL_OW 256
6084: PPUSH
6085: LD_STRING 01_JMMLifePoints_1
6087: PPUSH
6088: CALL_OW 39
// RemoveUnit ( JMM ) ;
6092: LD_EXP 15
6096: PPUSH
6097: CALL_OW 64
// to_reward := [ JMM ] ;
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_EXP 15
6110: PUSH
6111: EMPTY
6112: LIST
6113: ST_TO_ADDR
// if bobby_saved then
6114: LD_EXP 12
6118: IFFALSE 6136
// to_reward := to_reward ^ Bobby ;
6120: LD_ADDR_VAR 0 2
6124: PUSH
6125: LD_VAR 0 2
6129: PUSH
6130: LD_EXP 16
6134: ADD
6135: ST_TO_ADDR
// if cyrus_saved then
6136: LD_EXP 13
6140: IFFALSE 6158
// to_reward := to_reward ^ Cyrus ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_EXP 17
6156: ADD
6157: ST_TO_ADDR
// m1 := true ;
6158: LD_ADDR_VAR 0 4
6162: PUSH
6163: LD_INT 1
6165: ST_TO_ADDR
// m2 := bobby_saved ;
6166: LD_ADDR_VAR 0 5
6170: PUSH
6171: LD_EXP 12
6175: ST_TO_ADDR
// m3 := cyrus_saved ;
6176: LD_ADDR_VAR 0 6
6180: PUSH
6181: LD_EXP 13
6185: ST_TO_ADDR
// AddMedal ( JMM , 1 ) ;
6186: LD_STRING JMM
6188: PPUSH
6189: LD_INT 1
6191: PPUSH
6192: CALL_OW 101
// if not bobby_in_squad then
6196: LD_EXP 4
6200: NOT
6201: IFFALSE 6214
// AddMedal ( Bobby , - 1 ) ;
6203: LD_STRING Bobby
6205: PPUSH
6206: LD_INT 1
6208: NEG
6209: PPUSH
6210: CALL_OW 101
// if not bobby_saved and ( IsDying ( Bobby ) or IsDead ( Bobby ) ) then
6214: LD_EXP 12
6218: NOT
6219: PUSH
6220: LD_EXP 16
6224: PPUSH
6225: CALL_OW 303
6229: PUSH
6230: LD_EXP 16
6234: PPUSH
6235: CALL_OW 301
6239: OR
6240: AND
6241: IFFALSE 6254
// AddMedal ( Bobby , - 2 ) ;
6243: LD_STRING Bobby
6245: PPUSH
6246: LD_INT 2
6248: NEG
6249: PPUSH
6250: CALL_OW 101
// if not cyrus_in_squad then
6254: LD_EXP 7
6258: NOT
6259: IFFALSE 6272
// AddMedal ( Cyrus , - 1 ) ;
6261: LD_STRING Cyrus
6263: PPUSH
6264: LD_INT 1
6266: NEG
6267: PPUSH
6268: CALL_OW 101
// if not cyrus_saved and ( IsDying ( Cyrus ) or IsDead ( Cyrus ) ) then
6272: LD_EXP 13
6276: NOT
6277: PUSH
6278: LD_EXP 17
6282: PPUSH
6283: CALL_OW 303
6287: PUSH
6288: LD_EXP 17
6292: PPUSH
6293: CALL_OW 301
6297: OR
6298: AND
6299: IFFALSE 6312
// AddMedal ( Cyrus , - 2 ) ;
6301: LD_STRING Cyrus
6303: PPUSH
6304: LD_INT 2
6306: NEG
6307: PPUSH
6308: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
6312: LD_OWVAR 67
6316: PUSH
6317: LD_INT 3
6319: EQUAL
6320: PUSH
6321: LD_VAR 0 4
6325: AND
6326: PUSH
6327: LD_VAR 0 5
6331: AND
6332: PUSH
6333: LD_VAR 0 6
6337: AND
6338: IFFALSE 6350
// SetAchievementEX ( ACH_AMER , 1 ) ;
6340: LD_STRING ACH_AMER
6342: PPUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL_OW 564
// GiveMedals ( MAIN ) ;
6350: LD_STRING MAIN
6352: PPUSH
6353: CALL_OW 102
// RewardPeople ( to_reward ) ;
6357: LD_VAR 0 2
6361: PPUSH
6362: CALL_OW 43
// if bobby_saved then
6366: LD_EXP 12
6370: IFFALSE 6390
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
6372: LD_EXP 16
6376: PPUSH
6377: LD_EXP 2
6381: PUSH
6382: LD_STRING Bobby
6384: STR
6385: PPUSH
6386: CALL_OW 38
// if cyrus_saved then
6390: LD_EXP 13
6394: IFFALSE 6414
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
6396: LD_EXP 17
6400: PPUSH
6401: LD_EXP 2
6405: PUSH
6406: LD_STRING Cyrus
6408: STR
6409: PPUSH
6410: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
6414: LD_EXP 15
6418: PPUSH
6419: LD_EXP 2
6423: PUSH
6424: LD_STRING JMM
6426: STR
6427: PPUSH
6428: CALL_OW 38
// if tick <= 3 3$00 then
6432: LD_OWVAR 1
6436: PUSH
6437: LD_INT 6300
6439: LESSEQUAL
6440: IFFALSE 6449
// SetAchievement ( ACH_ASPEED_1 ) ;
6442: LD_STRING ACH_ASPEED_1
6444: PPUSH
6445: CALL_OW 543
// YouWin ;
6449: CALL_OW 103
// end ; end_of_file end_of_file
6453: PPOPN 6
6455: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
6456: GO 6458
6458: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6459: LD_STRING initStreamRollete();
6461: PPUSH
6462: CALL_OW 559
// InitStreamMode ;
6466: CALL 6471 0 0
// end ;
6470: END
// function InitStreamMode ; begin
6471: LD_INT 0
6473: PPUSH
// streamModeActive := false ;
6474: LD_ADDR_EXP 26
6478: PUSH
6479: LD_INT 0
6481: ST_TO_ADDR
// sRocket := false ;
6482: LD_ADDR_EXP 29
6486: PUSH
6487: LD_INT 0
6489: ST_TO_ADDR
// sSpeed := false ;
6490: LD_ADDR_EXP 28
6494: PUSH
6495: LD_INT 0
6497: ST_TO_ADDR
// sEngine := false ;
6498: LD_ADDR_EXP 30
6502: PUSH
6503: LD_INT 0
6505: ST_TO_ADDR
// sSpec := false ;
6506: LD_ADDR_EXP 27
6510: PUSH
6511: LD_INT 0
6513: ST_TO_ADDR
// sLevel := false ;
6514: LD_ADDR_EXP 31
6518: PUSH
6519: LD_INT 0
6521: ST_TO_ADDR
// sArmoury := false ;
6522: LD_ADDR_EXP 32
6526: PUSH
6527: LD_INT 0
6529: ST_TO_ADDR
// sRadar := false ;
6530: LD_ADDR_EXP 33
6534: PUSH
6535: LD_INT 0
6537: ST_TO_ADDR
// sBunker := false ;
6538: LD_ADDR_EXP 34
6542: PUSH
6543: LD_INT 0
6545: ST_TO_ADDR
// sHack := false ;
6546: LD_ADDR_EXP 35
6550: PUSH
6551: LD_INT 0
6553: ST_TO_ADDR
// sFire := false ;
6554: LD_ADDR_EXP 36
6558: PUSH
6559: LD_INT 0
6561: ST_TO_ADDR
// sRefresh := false ;
6562: LD_ADDR_EXP 37
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// sExp := false ;
6570: LD_ADDR_EXP 38
6574: PUSH
6575: LD_INT 0
6577: ST_TO_ADDR
// sDepot := false ;
6578: LD_ADDR_EXP 39
6582: PUSH
6583: LD_INT 0
6585: ST_TO_ADDR
// sFlag := false ;
6586: LD_ADDR_EXP 40
6590: PUSH
6591: LD_INT 0
6593: ST_TO_ADDR
// sKamikadze := false ;
6594: LD_ADDR_EXP 48
6598: PUSH
6599: LD_INT 0
6601: ST_TO_ADDR
// sTroll := false ;
6602: LD_ADDR_EXP 49
6606: PUSH
6607: LD_INT 0
6609: ST_TO_ADDR
// sSlow := false ;
6610: LD_ADDR_EXP 50
6614: PUSH
6615: LD_INT 0
6617: ST_TO_ADDR
// sLack := false ;
6618: LD_ADDR_EXP 51
6622: PUSH
6623: LD_INT 0
6625: ST_TO_ADDR
// sTank := false ;
6626: LD_ADDR_EXP 53
6630: PUSH
6631: LD_INT 0
6633: ST_TO_ADDR
// sRemote := false ;
6634: LD_ADDR_EXP 54
6638: PUSH
6639: LD_INT 0
6641: ST_TO_ADDR
// sSold := false ;
6642: LD_ADDR_EXP 41
6646: PUSH
6647: LD_INT 0
6649: ST_TO_ADDR
// sDiff := false ;
6650: LD_ADDR_EXP 42
6654: PUSH
6655: LD_INT 0
6657: ST_TO_ADDR
// sFog := false ;
6658: LD_ADDR_EXP 45
6662: PUSH
6663: LD_INT 0
6665: ST_TO_ADDR
// sReset := false ;
6666: LD_ADDR_EXP 46
6670: PUSH
6671: LD_INT 0
6673: ST_TO_ADDR
// sSun := false ;
6674: LD_ADDR_EXP 47
6678: PUSH
6679: LD_INT 0
6681: ST_TO_ADDR
// sTiger := false ;
6682: LD_ADDR_EXP 43
6686: PUSH
6687: LD_INT 0
6689: ST_TO_ADDR
// sBomb := false ;
6690: LD_ADDR_EXP 44
6694: PUSH
6695: LD_INT 0
6697: ST_TO_ADDR
// sWound := false ;
6698: LD_ADDR_EXP 52
6702: PUSH
6703: LD_INT 0
6705: ST_TO_ADDR
// end ;
6706: LD_VAR 0 1
6710: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
6711: LD_VAR 0 2
6715: PUSH
6716: LD_INT 100
6718: EQUAL
6719: IFFALSE 7254
// begin if not StreamModeActive then
6721: LD_EXP 26
6725: NOT
6726: IFFALSE 6736
// StreamModeActive := true ;
6728: LD_ADDR_EXP 26
6732: PUSH
6733: LD_INT 1
6735: ST_TO_ADDR
// if p3 = 0 then
6736: LD_VAR 0 3
6740: PUSH
6741: LD_INT 0
6743: EQUAL
6744: IFFALSE 6750
// InitStreamMode ;
6746: CALL 6471 0 0
// if p3 = 1 then
6750: LD_VAR 0 3
6754: PUSH
6755: LD_INT 1
6757: EQUAL
6758: IFFALSE 6768
// sRocket := true ;
6760: LD_ADDR_EXP 29
6764: PUSH
6765: LD_INT 1
6767: ST_TO_ADDR
// if p3 = 2 then
6768: LD_VAR 0 3
6772: PUSH
6773: LD_INT 2
6775: EQUAL
6776: IFFALSE 6786
// sSpeed := true ;
6778: LD_ADDR_EXP 28
6782: PUSH
6783: LD_INT 1
6785: ST_TO_ADDR
// if p3 = 3 then
6786: LD_VAR 0 3
6790: PUSH
6791: LD_INT 3
6793: EQUAL
6794: IFFALSE 6804
// sEngine := true ;
6796: LD_ADDR_EXP 30
6800: PUSH
6801: LD_INT 1
6803: ST_TO_ADDR
// if p3 = 4 then
6804: LD_VAR 0 3
6808: PUSH
6809: LD_INT 4
6811: EQUAL
6812: IFFALSE 6822
// sSpec := true ;
6814: LD_ADDR_EXP 27
6818: PUSH
6819: LD_INT 1
6821: ST_TO_ADDR
// if p3 = 5 then
6822: LD_VAR 0 3
6826: PUSH
6827: LD_INT 5
6829: EQUAL
6830: IFFALSE 6840
// sLevel := true ;
6832: LD_ADDR_EXP 31
6836: PUSH
6837: LD_INT 1
6839: ST_TO_ADDR
// if p3 = 6 then
6840: LD_VAR 0 3
6844: PUSH
6845: LD_INT 6
6847: EQUAL
6848: IFFALSE 6858
// sArmoury := true ;
6850: LD_ADDR_EXP 32
6854: PUSH
6855: LD_INT 1
6857: ST_TO_ADDR
// if p3 = 7 then
6858: LD_VAR 0 3
6862: PUSH
6863: LD_INT 7
6865: EQUAL
6866: IFFALSE 6876
// sRadar := true ;
6868: LD_ADDR_EXP 33
6872: PUSH
6873: LD_INT 1
6875: ST_TO_ADDR
// if p3 = 8 then
6876: LD_VAR 0 3
6880: PUSH
6881: LD_INT 8
6883: EQUAL
6884: IFFALSE 6894
// sBunker := true ;
6886: LD_ADDR_EXP 34
6890: PUSH
6891: LD_INT 1
6893: ST_TO_ADDR
// if p3 = 9 then
6894: LD_VAR 0 3
6898: PUSH
6899: LD_INT 9
6901: EQUAL
6902: IFFALSE 6912
// sHack := true ;
6904: LD_ADDR_EXP 35
6908: PUSH
6909: LD_INT 1
6911: ST_TO_ADDR
// if p3 = 10 then
6912: LD_VAR 0 3
6916: PUSH
6917: LD_INT 10
6919: EQUAL
6920: IFFALSE 6930
// sFire := true ;
6922: LD_ADDR_EXP 36
6926: PUSH
6927: LD_INT 1
6929: ST_TO_ADDR
// if p3 = 11 then
6930: LD_VAR 0 3
6934: PUSH
6935: LD_INT 11
6937: EQUAL
6938: IFFALSE 6948
// sRefresh := true ;
6940: LD_ADDR_EXP 37
6944: PUSH
6945: LD_INT 1
6947: ST_TO_ADDR
// if p3 = 12 then
6948: LD_VAR 0 3
6952: PUSH
6953: LD_INT 12
6955: EQUAL
6956: IFFALSE 6966
// sExp := true ;
6958: LD_ADDR_EXP 38
6962: PUSH
6963: LD_INT 1
6965: ST_TO_ADDR
// if p3 = 13 then
6966: LD_VAR 0 3
6970: PUSH
6971: LD_INT 13
6973: EQUAL
6974: IFFALSE 6984
// sDepot := true ;
6976: LD_ADDR_EXP 39
6980: PUSH
6981: LD_INT 1
6983: ST_TO_ADDR
// if p3 = 14 then
6984: LD_VAR 0 3
6988: PUSH
6989: LD_INT 14
6991: EQUAL
6992: IFFALSE 7002
// sFlag := true ;
6994: LD_ADDR_EXP 40
6998: PUSH
6999: LD_INT 1
7001: ST_TO_ADDR
// if p3 = 15 then
7002: LD_VAR 0 3
7006: PUSH
7007: LD_INT 15
7009: EQUAL
7010: IFFALSE 7020
// sKamikadze := true ;
7012: LD_ADDR_EXP 48
7016: PUSH
7017: LD_INT 1
7019: ST_TO_ADDR
// if p3 = 16 then
7020: LD_VAR 0 3
7024: PUSH
7025: LD_INT 16
7027: EQUAL
7028: IFFALSE 7038
// sTroll := true ;
7030: LD_ADDR_EXP 49
7034: PUSH
7035: LD_INT 1
7037: ST_TO_ADDR
// if p3 = 17 then
7038: LD_VAR 0 3
7042: PUSH
7043: LD_INT 17
7045: EQUAL
7046: IFFALSE 7056
// sSlow := true ;
7048: LD_ADDR_EXP 50
7052: PUSH
7053: LD_INT 1
7055: ST_TO_ADDR
// if p3 = 18 then
7056: LD_VAR 0 3
7060: PUSH
7061: LD_INT 18
7063: EQUAL
7064: IFFALSE 7074
// sLack := true ;
7066: LD_ADDR_EXP 51
7070: PUSH
7071: LD_INT 1
7073: ST_TO_ADDR
// if p3 = 19 then
7074: LD_VAR 0 3
7078: PUSH
7079: LD_INT 19
7081: EQUAL
7082: IFFALSE 7092
// sTank := true ;
7084: LD_ADDR_EXP 53
7088: PUSH
7089: LD_INT 1
7091: ST_TO_ADDR
// if p3 = 20 then
7092: LD_VAR 0 3
7096: PUSH
7097: LD_INT 20
7099: EQUAL
7100: IFFALSE 7110
// sRemote := true ;
7102: LD_ADDR_EXP 54
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// if p3 = 101 then
7110: LD_VAR 0 3
7114: PUSH
7115: LD_INT 101
7117: EQUAL
7118: IFFALSE 7128
// sSold := true ;
7120: LD_ADDR_EXP 41
7124: PUSH
7125: LD_INT 1
7127: ST_TO_ADDR
// if p3 = 102 then
7128: LD_VAR 0 3
7132: PUSH
7133: LD_INT 102
7135: EQUAL
7136: IFFALSE 7146
// sDiff := true ;
7138: LD_ADDR_EXP 42
7142: PUSH
7143: LD_INT 1
7145: ST_TO_ADDR
// if p3 = 103 then
7146: LD_VAR 0 3
7150: PUSH
7151: LD_INT 103
7153: EQUAL
7154: IFFALSE 7164
// sFog := true ;
7156: LD_ADDR_EXP 45
7160: PUSH
7161: LD_INT 1
7163: ST_TO_ADDR
// if p3 = 104 then
7164: LD_VAR 0 3
7168: PUSH
7169: LD_INT 104
7171: EQUAL
7172: IFFALSE 7182
// sReset := true ;
7174: LD_ADDR_EXP 46
7178: PUSH
7179: LD_INT 1
7181: ST_TO_ADDR
// if p3 = 105 then
7182: LD_VAR 0 3
7186: PUSH
7187: LD_INT 105
7189: EQUAL
7190: IFFALSE 7200
// sSun := true ;
7192: LD_ADDR_EXP 47
7196: PUSH
7197: LD_INT 1
7199: ST_TO_ADDR
// if p3 = 106 then
7200: LD_VAR 0 3
7204: PUSH
7205: LD_INT 106
7207: EQUAL
7208: IFFALSE 7218
// sTiger := true ;
7210: LD_ADDR_EXP 43
7214: PUSH
7215: LD_INT 1
7217: ST_TO_ADDR
// if p3 = 107 then
7218: LD_VAR 0 3
7222: PUSH
7223: LD_INT 107
7225: EQUAL
7226: IFFALSE 7236
// sBomb := true ;
7228: LD_ADDR_EXP 44
7232: PUSH
7233: LD_INT 1
7235: ST_TO_ADDR
// if p3 = 108 then
7236: LD_VAR 0 3
7240: PUSH
7241: LD_INT 108
7243: EQUAL
7244: IFFALSE 7254
// sWound := true ;
7246: LD_ADDR_EXP 52
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// end ; end ;
7254: PPOPN 6
7256: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7257: LD_EXP 26
7261: PUSH
7262: LD_EXP 29
7266: AND
7267: IFFALSE 7388
7269: GO 7271
7271: DISABLE
7272: LD_INT 0
7274: PPUSH
7275: PPUSH
// begin enable ;
7276: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
7277: LD_ADDR_VAR 0 2
7281: PUSH
7282: LD_INT 22
7284: PUSH
7285: LD_OWVAR 2
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: PUSH
7294: LD_INT 2
7296: PUSH
7297: LD_INT 34
7299: PUSH
7300: LD_INT 7
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 34
7309: PUSH
7310: LD_INT 45
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: LD_INT 34
7319: PUSH
7320: LD_INT 28
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: LD_INT 34
7329: PUSH
7330: LD_INT 47
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: LIST
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: PPUSH
7348: CALL_OW 69
7352: ST_TO_ADDR
// if not tmp then
7353: LD_VAR 0 2
7357: NOT
7358: IFFALSE 7362
// exit ;
7360: GO 7388
// for i in tmp do
7362: LD_ADDR_VAR 0 1
7366: PUSH
7367: LD_VAR 0 2
7371: PUSH
7372: FOR_IN
7373: IFFALSE 7386
// begin DestroyUnit ( i ) ;
7375: LD_VAR 0 1
7379: PPUSH
7380: CALL_OW 65
// end ;
7384: GO 7372
7386: POP
7387: POP
// end ;
7388: PPOPN 2
7390: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
7391: LD_EXP 26
7395: PUSH
7396: LD_EXP 30
7400: AND
7401: IFFALSE 7482
7403: GO 7405
7405: DISABLE
7406: LD_INT 0
7408: PPUSH
7409: PPUSH
// begin enable ;
7410: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
7411: LD_ADDR_VAR 0 2
7415: PUSH
7416: LD_INT 22
7418: PUSH
7419: LD_OWVAR 2
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: PUSH
7428: LD_INT 32
7430: PUSH
7431: LD_INT 3
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: PPUSH
7442: CALL_OW 69
7446: ST_TO_ADDR
// if not tmp then
7447: LD_VAR 0 2
7451: NOT
7452: IFFALSE 7456
// exit ;
7454: GO 7482
// for i in tmp do
7456: LD_ADDR_VAR 0 1
7460: PUSH
7461: LD_VAR 0 2
7465: PUSH
7466: FOR_IN
7467: IFFALSE 7480
// begin DestroyUnit ( i ) ;
7469: LD_VAR 0 1
7473: PPUSH
7474: CALL_OW 65
// end ;
7478: GO 7466
7480: POP
7481: POP
// end ;
7482: PPOPN 2
7484: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7485: LD_EXP 26
7489: PUSH
7490: LD_EXP 27
7494: AND
7495: IFFALSE 7588
7497: GO 7499
7499: DISABLE
7500: LD_INT 0
7502: PPUSH
// begin enable ;
7503: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7504: LD_ADDR_VAR 0 1
7508: PUSH
7509: LD_INT 22
7511: PUSH
7512: LD_OWVAR 2
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: LD_INT 2
7523: PUSH
7524: LD_INT 25
7526: PUSH
7527: LD_INT 5
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: LD_INT 25
7536: PUSH
7537: LD_INT 9
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 25
7546: PUSH
7547: LD_INT 8
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 69
7568: PUSH
7569: FOR_IN
7570: IFFALSE 7586
// begin SetClass ( i , 1 ) ;
7572: LD_VAR 0 1
7576: PPUSH
7577: LD_INT 1
7579: PPUSH
7580: CALL_OW 336
// end ;
7584: GO 7569
7586: POP
7587: POP
// end ;
7588: PPOPN 1
7590: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7591: LD_EXP 26
7595: PUSH
7596: LD_EXP 28
7600: AND
7601: PUSH
7602: LD_OWVAR 65
7606: PUSH
7607: LD_INT 7
7609: LESS
7610: AND
7611: IFFALSE 7625
7613: GO 7615
7615: DISABLE
// begin enable ;
7616: ENABLE
// game_speed := 7 ;
7617: LD_ADDR_OWVAR 65
7621: PUSH
7622: LD_INT 7
7624: ST_TO_ADDR
// end ;
7625: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7626: LD_EXP 26
7630: PUSH
7631: LD_EXP 31
7635: AND
7636: IFFALSE 7838
7638: GO 7640
7640: DISABLE
7641: LD_INT 0
7643: PPUSH
7644: PPUSH
7645: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: LD_INT 81
7653: PUSH
7654: LD_OWVAR 2
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 21
7665: PUSH
7666: LD_INT 1
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PPUSH
7677: CALL_OW 69
7681: ST_TO_ADDR
// if not tmp then
7682: LD_VAR 0 3
7686: NOT
7687: IFFALSE 7691
// exit ;
7689: GO 7838
// if tmp > 5 then
7691: LD_VAR 0 3
7695: PUSH
7696: LD_INT 5
7698: GREATER
7699: IFFALSE 7711
// k := 5 else
7701: LD_ADDR_VAR 0 2
7705: PUSH
7706: LD_INT 5
7708: ST_TO_ADDR
7709: GO 7721
// k := tmp ;
7711: LD_ADDR_VAR 0 2
7715: PUSH
7716: LD_VAR 0 3
7720: ST_TO_ADDR
// for i := 1 to k do
7721: LD_ADDR_VAR 0 1
7725: PUSH
7726: DOUBLE
7727: LD_INT 1
7729: DEC
7730: ST_TO_ADDR
7731: LD_VAR 0 2
7735: PUSH
7736: FOR_TO
7737: IFFALSE 7836
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7739: LD_VAR 0 3
7743: PUSH
7744: LD_VAR 0 1
7748: ARRAY
7749: PPUSH
7750: LD_VAR 0 1
7754: PUSH
7755: LD_INT 4
7757: MOD
7758: PUSH
7759: LD_INT 1
7761: PLUS
7762: PPUSH
7763: CALL_OW 259
7767: PUSH
7768: LD_INT 10
7770: LESS
7771: IFFALSE 7834
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
7773: LD_VAR 0 3
7777: PUSH
7778: LD_VAR 0 1
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 1
7788: PUSH
7789: LD_INT 4
7791: MOD
7792: PUSH
7793: LD_INT 1
7795: PLUS
7796: PPUSH
7797: LD_VAR 0 3
7801: PUSH
7802: LD_VAR 0 1
7806: ARRAY
7807: PPUSH
7808: LD_VAR 0 1
7812: PUSH
7813: LD_INT 4
7815: MOD
7816: PUSH
7817: LD_INT 1
7819: PLUS
7820: PPUSH
7821: CALL_OW 259
7825: PUSH
7826: LD_INT 1
7828: PLUS
7829: PPUSH
7830: CALL_OW 237
7834: GO 7736
7836: POP
7837: POP
// end ;
7838: PPOPN 3
7840: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
7841: LD_EXP 26
7845: PUSH
7846: LD_EXP 32
7850: AND
7851: IFFALSE 7871
7853: GO 7855
7855: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
7856: LD_INT 4
7858: PPUSH
7859: LD_OWVAR 2
7863: PPUSH
7864: LD_INT 0
7866: PPUSH
7867: CALL_OW 324
7871: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
7872: LD_EXP 26
7876: PUSH
7877: LD_EXP 33
7881: AND
7882: IFFALSE 7981
7884: GO 7886
7886: DISABLE
7887: LD_INT 0
7889: PPUSH
7890: PPUSH
// begin enable ;
7891: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
7892: LD_ADDR_VAR 0 2
7896: PUSH
7897: LD_INT 22
7899: PUSH
7900: LD_OWVAR 2
7904: PUSH
7905: EMPTY
7906: LIST
7907: LIST
7908: PUSH
7909: LD_INT 2
7911: PUSH
7912: LD_INT 34
7914: PUSH
7915: LD_INT 11
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PUSH
7922: LD_INT 34
7924: PUSH
7925: LD_INT 30
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: LIST
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: ST_TO_ADDR
// if not tmp then
7946: LD_VAR 0 2
7950: NOT
7951: IFFALSE 7955
// exit ;
7953: GO 7981
// for i in tmp do
7955: LD_ADDR_VAR 0 1
7959: PUSH
7960: LD_VAR 0 2
7964: PUSH
7965: FOR_IN
7966: IFFALSE 7979
// begin DestroyUnit ( i ) ;
7968: LD_VAR 0 1
7972: PPUSH
7973: CALL_OW 65
// end ;
7977: GO 7965
7979: POP
7980: POP
// end ;
7981: PPOPN 2
7983: END
// every 0 0$1 trigger StreamModeActive and sBunker do
7984: LD_EXP 26
7988: PUSH
7989: LD_EXP 34
7993: AND
7994: IFFALSE 8014
7996: GO 7998
7998: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
7999: LD_INT 32
8001: PPUSH
8002: LD_OWVAR 2
8006: PPUSH
8007: LD_INT 0
8009: PPUSH
8010: CALL_OW 324
8014: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
8015: LD_EXP 26
8019: PUSH
8020: LD_EXP 35
8024: AND
8025: IFFALSE 8206
8027: GO 8029
8029: DISABLE
8030: LD_INT 0
8032: PPUSH
8033: PPUSH
8034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
8035: LD_ADDR_VAR 0 2
8039: PUSH
8040: LD_INT 22
8042: PUSH
8043: LD_OWVAR 2
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PUSH
8052: LD_INT 33
8054: PUSH
8055: LD_INT 3
8057: PUSH
8058: EMPTY
8059: LIST
8060: LIST
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PPUSH
8066: CALL_OW 69
8070: ST_TO_ADDR
// if not tmp then
8071: LD_VAR 0 2
8075: NOT
8076: IFFALSE 8080
// exit ;
8078: GO 8206
// side := 0 ;
8080: LD_ADDR_VAR 0 3
8084: PUSH
8085: LD_INT 0
8087: ST_TO_ADDR
// for i := 1 to 8 do
8088: LD_ADDR_VAR 0 1
8092: PUSH
8093: DOUBLE
8094: LD_INT 1
8096: DEC
8097: ST_TO_ADDR
8098: LD_INT 8
8100: PUSH
8101: FOR_TO
8102: IFFALSE 8150
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
8104: LD_OWVAR 2
8108: PUSH
8109: LD_VAR 0 1
8113: NONEQUAL
8114: PUSH
8115: LD_OWVAR 2
8119: PPUSH
8120: LD_VAR 0 1
8124: PPUSH
8125: CALL_OW 81
8129: PUSH
8130: LD_INT 2
8132: EQUAL
8133: AND
8134: IFFALSE 8148
// begin side := i ;
8136: LD_ADDR_VAR 0 3
8140: PUSH
8141: LD_VAR 0 1
8145: ST_TO_ADDR
// break ;
8146: GO 8150
// end ;
8148: GO 8101
8150: POP
8151: POP
// if not side then
8152: LD_VAR 0 3
8156: NOT
8157: IFFALSE 8161
// exit ;
8159: GO 8206
// for i := 1 to tmp do
8161: LD_ADDR_VAR 0 1
8165: PUSH
8166: DOUBLE
8167: LD_INT 1
8169: DEC
8170: ST_TO_ADDR
8171: LD_VAR 0 2
8175: PUSH
8176: FOR_TO
8177: IFFALSE 8204
// if Prob ( 30 ) then
8179: LD_INT 30
8181: PPUSH
8182: CALL_OW 13
8186: IFFALSE 8202
// SetSide ( i , side ) ;
8188: LD_VAR 0 1
8192: PPUSH
8193: LD_VAR 0 3
8197: PPUSH
8198: CALL_OW 235
8202: GO 8176
8204: POP
8205: POP
// end ;
8206: PPOPN 3
8208: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
8209: LD_EXP 26
8213: PUSH
8214: LD_EXP 37
8218: AND
8219: IFFALSE 8338
8221: GO 8223
8223: DISABLE
8224: LD_INT 0
8226: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
8227: LD_ADDR_VAR 0 1
8231: PUSH
8232: LD_INT 22
8234: PUSH
8235: LD_OWVAR 2
8239: PUSH
8240: EMPTY
8241: LIST
8242: LIST
8243: PUSH
8244: LD_INT 21
8246: PUSH
8247: LD_INT 1
8249: PUSH
8250: EMPTY
8251: LIST
8252: LIST
8253: PUSH
8254: LD_INT 3
8256: PUSH
8257: LD_INT 23
8259: PUSH
8260: LD_INT 0
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: PUSH
8267: EMPTY
8268: LIST
8269: LIST
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: LIST
8275: PPUSH
8276: CALL_OW 69
8280: PUSH
8281: FOR_IN
8282: IFFALSE 8336
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
8284: LD_VAR 0 1
8288: PPUSH
8289: CALL_OW 257
8293: PUSH
8294: LD_INT 1
8296: PUSH
8297: LD_INT 2
8299: PUSH
8300: LD_INT 3
8302: PUSH
8303: LD_INT 4
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: LIST
8311: IN
8312: IFFALSE 8334
// SetClass ( un , rand ( 1 , 4 ) ) ;
8314: LD_VAR 0 1
8318: PPUSH
8319: LD_INT 1
8321: PPUSH
8322: LD_INT 4
8324: PPUSH
8325: CALL_OW 12
8329: PPUSH
8330: CALL_OW 336
8334: GO 8281
8336: POP
8337: POP
// end ;
8338: PPOPN 1
8340: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
8341: LD_EXP 26
8345: PUSH
8346: LD_EXP 36
8350: AND
8351: IFFALSE 8430
8353: GO 8355
8355: DISABLE
8356: LD_INT 0
8358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8359: LD_ADDR_VAR 0 1
8363: PUSH
8364: LD_INT 22
8366: PUSH
8367: LD_OWVAR 2
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PUSH
8376: LD_INT 21
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PPUSH
8390: CALL_OW 69
8394: ST_TO_ADDR
// if not tmp then
8395: LD_VAR 0 1
8399: NOT
8400: IFFALSE 8404
// exit ;
8402: GO 8430
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
8404: LD_VAR 0 1
8408: PUSH
8409: LD_INT 1
8411: PPUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 12
8421: ARRAY
8422: PPUSH
8423: LD_INT 100
8425: PPUSH
8426: CALL_OW 234
// end ;
8430: PPOPN 1
8432: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
8433: LD_EXP 26
8437: PUSH
8438: LD_EXP 38
8442: AND
8443: IFFALSE 8541
8445: GO 8447
8447: DISABLE
8448: LD_INT 0
8450: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8451: LD_ADDR_VAR 0 1
8455: PUSH
8456: LD_INT 22
8458: PUSH
8459: LD_OWVAR 2
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: PUSH
8468: LD_INT 21
8470: PUSH
8471: LD_INT 1
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PUSH
8478: EMPTY
8479: LIST
8480: LIST
8481: PPUSH
8482: CALL_OW 69
8486: ST_TO_ADDR
// if not tmp then
8487: LD_VAR 0 1
8491: NOT
8492: IFFALSE 8496
// exit ;
8494: GO 8541
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8496: LD_VAR 0 1
8500: PUSH
8501: LD_INT 1
8503: PPUSH
8504: LD_VAR 0 1
8508: PPUSH
8509: CALL_OW 12
8513: ARRAY
8514: PPUSH
8515: LD_INT 1
8517: PPUSH
8518: LD_INT 4
8520: PPUSH
8521: CALL_OW 12
8525: PPUSH
8526: LD_INT 3000
8528: PPUSH
8529: LD_INT 9000
8531: PPUSH
8532: CALL_OW 12
8536: PPUSH
8537: CALL_OW 492
// end ;
8541: PPOPN 1
8543: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8544: LD_EXP 26
8548: PUSH
8549: LD_EXP 39
8553: AND
8554: IFFALSE 8574
8556: GO 8558
8558: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8559: LD_INT 1
8561: PPUSH
8562: LD_OWVAR 2
8566: PPUSH
8567: LD_INT 0
8569: PPUSH
8570: CALL_OW 324
8574: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8575: LD_EXP 26
8579: PUSH
8580: LD_EXP 40
8584: AND
8585: IFFALSE 8668
8587: GO 8589
8589: DISABLE
8590: LD_INT 0
8592: PPUSH
8593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8594: LD_ADDR_VAR 0 2
8598: PUSH
8599: LD_INT 22
8601: PUSH
8602: LD_OWVAR 2
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 21
8613: PUSH
8614: LD_INT 3
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PPUSH
8625: CALL_OW 69
8629: ST_TO_ADDR
// if not tmp then
8630: LD_VAR 0 2
8634: NOT
8635: IFFALSE 8639
// exit ;
8637: GO 8668
// for i in tmp do
8639: LD_ADDR_VAR 0 1
8643: PUSH
8644: LD_VAR 0 2
8648: PUSH
8649: FOR_IN
8650: IFFALSE 8666
// SetBLevel ( i , 10 ) ;
8652: LD_VAR 0 1
8656: PPUSH
8657: LD_INT 10
8659: PPUSH
8660: CALL_OW 241
8664: GO 8649
8666: POP
8667: POP
// end ;
8668: PPOPN 2
8670: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
8671: LD_EXP 26
8675: PUSH
8676: LD_EXP 41
8680: AND
8681: IFFALSE 8784
8683: GO 8685
8685: DISABLE
8686: LD_INT 0
8688: PPUSH
8689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8690: LD_ADDR_VAR 0 2
8694: PUSH
8695: LD_INT 22
8697: PUSH
8698: LD_OWVAR 2
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: LD_INT 25
8709: PUSH
8710: LD_INT 1
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PPUSH
8721: CALL_OW 69
8725: ST_TO_ADDR
// if not tmp then
8726: LD_VAR 0 2
8730: NOT
8731: IFFALSE 8735
// exit ;
8733: GO 8784
// for i in tmp do
8735: LD_ADDR_VAR 0 1
8739: PUSH
8740: LD_VAR 0 2
8744: PUSH
8745: FOR_IN
8746: IFFALSE 8782
// begin if Crawls ( i ) then
8748: LD_VAR 0 1
8752: PPUSH
8753: CALL_OW 318
8757: IFFALSE 8768
// ComWalk ( i ) ;
8759: LD_VAR 0 1
8763: PPUSH
8764: CALL_OW 138
// SetClass ( i , 4 ) ;
8768: LD_VAR 0 1
8772: PPUSH
8773: LD_INT 4
8775: PPUSH
8776: CALL_OW 336
// end ;
8780: GO 8745
8782: POP
8783: POP
// end ;
8784: PPOPN 2
8786: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
8787: LD_EXP 26
8791: PUSH
8792: LD_EXP 42
8796: AND
8797: PUSH
8798: LD_OWVAR 67
8802: PUSH
8803: LD_INT 3
8805: LESS
8806: AND
8807: IFFALSE 8826
8809: GO 8811
8811: DISABLE
// Difficulty := Difficulty + 1 ;
8812: LD_ADDR_OWVAR 67
8816: PUSH
8817: LD_OWVAR 67
8821: PUSH
8822: LD_INT 1
8824: PLUS
8825: ST_TO_ADDR
8826: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
8827: LD_EXP 26
8831: PUSH
8832: LD_EXP 43
8836: AND
8837: IFFALSE 8940
8839: GO 8841
8841: DISABLE
8842: LD_INT 0
8844: PPUSH
// begin for i := 1 to 5 do
8845: LD_ADDR_VAR 0 1
8849: PUSH
8850: DOUBLE
8851: LD_INT 1
8853: DEC
8854: ST_TO_ADDR
8855: LD_INT 5
8857: PUSH
8858: FOR_TO
8859: IFFALSE 8938
// begin uc_nation := nation_nature ;
8861: LD_ADDR_OWVAR 21
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// uc_side := 0 ;
8869: LD_ADDR_OWVAR 20
8873: PUSH
8874: LD_INT 0
8876: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8877: LD_ADDR_OWVAR 29
8881: PUSH
8882: LD_INT 12
8884: PUSH
8885: LD_INT 12
8887: PUSH
8888: EMPTY
8889: LIST
8890: LIST
8891: ST_TO_ADDR
// hc_agressivity := 20 ;
8892: LD_ADDR_OWVAR 35
8896: PUSH
8897: LD_INT 20
8899: ST_TO_ADDR
// hc_class := class_tiger ;
8900: LD_ADDR_OWVAR 28
8904: PUSH
8905: LD_INT 14
8907: ST_TO_ADDR
// hc_gallery :=  ;
8908: LD_ADDR_OWVAR 33
8912: PUSH
8913: LD_STRING 
8915: ST_TO_ADDR
// hc_name :=  ;
8916: LD_ADDR_OWVAR 26
8920: PUSH
8921: LD_STRING 
8923: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
8924: CALL_OW 44
8928: PPUSH
8929: LD_INT 0
8931: PPUSH
8932: CALL_OW 51
// end ;
8936: GO 8858
8938: POP
8939: POP
// end ;
8940: PPOPN 1
8942: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
8943: LD_EXP 26
8947: PUSH
8948: LD_EXP 44
8952: AND
8953: IFFALSE 9127
8955: GO 8957
8957: DISABLE
8958: LD_INT 0
8960: PPUSH
8961: PPUSH
8962: PPUSH
8963: PPUSH
// begin result := false ;
8964: LD_ADDR_VAR 0 4
8968: PUSH
8969: LD_INT 0
8971: ST_TO_ADDR
// for i := 1 to 8 do
8972: LD_ADDR_VAR 0 1
8976: PUSH
8977: DOUBLE
8978: LD_INT 1
8980: DEC
8981: ST_TO_ADDR
8982: LD_INT 8
8984: PUSH
8985: FOR_TO
8986: IFFALSE 9097
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
8988: LD_ADDR_VAR 0 2
8992: PUSH
8993: LD_INT 10
8995: PUSH
8996: LD_INT 50
8998: PUSH
8999: LD_INT 90
9001: PUSH
9002: LD_INT 140
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: PUSH
9011: LD_INT 1
9013: PPUSH
9014: LD_INT 4
9016: PPUSH
9017: CALL_OW 12
9021: ARRAY
9022: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 10
9030: PUSH
9031: LD_INT 50
9033: PUSH
9034: LD_INT 90
9036: PUSH
9037: LD_INT 140
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: PUSH
9046: LD_INT 1
9048: PPUSH
9049: LD_INT 4
9051: PPUSH
9052: CALL_OW 12
9056: ARRAY
9057: ST_TO_ADDR
// if ValidHex ( x , y ) then
9058: LD_VAR 0 2
9062: PPUSH
9063: LD_VAR 0 3
9067: PPUSH
9068: CALL_OW 488
9072: IFFALSE 9095
// begin result := [ x , y ] ;
9074: LD_ADDR_VAR 0 4
9078: PUSH
9079: LD_VAR 0 2
9083: PUSH
9084: LD_VAR 0 3
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: ST_TO_ADDR
// break ;
9093: GO 9097
// end ; end ;
9095: GO 8985
9097: POP
9098: POP
// if result then
9099: LD_VAR 0 4
9103: IFFALSE 9127
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
9105: LD_VAR 0 4
9109: PUSH
9110: LD_INT 1
9112: ARRAY
9113: PPUSH
9114: LD_VAR 0 4
9118: PUSH
9119: LD_INT 2
9121: ARRAY
9122: PPUSH
9123: CALL_OW 429
// end ;
9127: PPOPN 4
9129: END
// every 0 0$1 trigger StreamModeActive and sReset do
9130: LD_EXP 26
9134: PUSH
9135: LD_EXP 46
9139: AND
9140: IFFALSE 9152
9142: GO 9144
9144: DISABLE
// YouLost (  ) ;
9145: LD_STRING 
9147: PPUSH
9148: CALL_OW 104
9152: END
// every 0 0$1 trigger StreamModeActive and sFog do
9153: LD_EXP 26
9157: PUSH
9158: LD_EXP 45
9162: AND
9163: IFFALSE 9177
9165: GO 9167
9167: DISABLE
// FogOff ( your_side ) ;
9168: LD_OWVAR 2
9172: PPUSH
9173: CALL_OW 344
9177: END
// every 0 0$1 trigger StreamModeActive and sSun do
9178: LD_EXP 26
9182: PUSH
9183: LD_EXP 47
9187: AND
9188: IFFALSE 9216
9190: GO 9192
9192: DISABLE
// begin solar_recharge_percent := 0 ;
9193: LD_ADDR_OWVAR 79
9197: PUSH
9198: LD_INT 0
9200: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9201: LD_INT 10500
9203: PPUSH
9204: CALL_OW 67
// solar_recharge_percent := 100 ;
9208: LD_ADDR_OWVAR 79
9212: PUSH
9213: LD_INT 100
9215: ST_TO_ADDR
// end ;
9216: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
9217: LD_EXP 26
9221: PUSH
9222: LD_EXP 48
9226: AND
9227: IFFALSE 9382
9229: GO 9231
9231: DISABLE
9232: LD_INT 0
9234: PPUSH
9235: PPUSH
// begin for i := 1 to 6 do
9236: LD_ADDR_VAR 0 1
9240: PUSH
9241: DOUBLE
9242: LD_INT 1
9244: DEC
9245: ST_TO_ADDR
9246: LD_INT 6
9248: PUSH
9249: FOR_TO
9250: IFFALSE 9380
// begin uc_nation := nation_nature ;
9252: LD_ADDR_OWVAR 21
9256: PUSH
9257: LD_INT 0
9259: ST_TO_ADDR
// uc_side := 0 ;
9260: LD_ADDR_OWVAR 20
9264: PUSH
9265: LD_INT 0
9267: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9268: LD_ADDR_OWVAR 29
9272: PUSH
9273: LD_INT 12
9275: PUSH
9276: LD_INT 12
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: ST_TO_ADDR
// hc_agressivity := 20 ;
9283: LD_ADDR_OWVAR 35
9287: PUSH
9288: LD_INT 20
9290: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
9291: LD_ADDR_OWVAR 28
9295: PUSH
9296: LD_INT 17
9298: ST_TO_ADDR
// hc_gallery :=  ;
9299: LD_ADDR_OWVAR 33
9303: PUSH
9304: LD_STRING 
9306: ST_TO_ADDR
// hc_name :=  ;
9307: LD_ADDR_OWVAR 26
9311: PUSH
9312: LD_STRING 
9314: ST_TO_ADDR
// un := CreateHuman ;
9315: LD_ADDR_VAR 0 2
9319: PUSH
9320: CALL_OW 44
9324: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9325: LD_VAR 0 2
9329: PPUSH
9330: LD_INT 1
9332: PPUSH
9333: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9337: LD_VAR 0 2
9341: PPUSH
9342: LD_INT 3
9344: PUSH
9345: LD_INT 22
9347: PUSH
9348: LD_INT 0
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PPUSH
9359: CALL_OW 69
9363: PPUSH
9364: LD_VAR 0 2
9368: PPUSH
9369: CALL_OW 74
9373: PPUSH
9374: CALL_OW 115
// end ;
9378: GO 9249
9380: POP
9381: POP
// end ;
9382: PPOPN 2
9384: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9385: LD_EXP 26
9389: PUSH
9390: LD_EXP 49
9394: AND
9395: IFFALSE 9421
9397: GO 9399
9399: DISABLE
// begin ToLua ( displayTroll(); ) ;
9400: LD_STRING displayTroll();
9402: PPUSH
9403: CALL_OW 559
// wait ( 3 3$00 ) ;
9407: LD_INT 6300
9409: PPUSH
9410: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9414: LD_STRING hideTroll();
9416: PPUSH
9417: CALL_OW 559
// end ;
9421: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9422: LD_EXP 26
9426: PUSH
9427: LD_EXP 50
9431: AND
9432: IFFALSE 9495
9434: GO 9436
9436: DISABLE
9437: LD_INT 0
9439: PPUSH
// begin p := 0 ;
9440: LD_ADDR_VAR 0 1
9444: PUSH
9445: LD_INT 0
9447: ST_TO_ADDR
// repeat game_speed := 1 ;
9448: LD_ADDR_OWVAR 65
9452: PUSH
9453: LD_INT 1
9455: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9456: LD_INT 35
9458: PPUSH
9459: CALL_OW 67
// p := p + 1 ;
9463: LD_ADDR_VAR 0 1
9467: PUSH
9468: LD_VAR 0 1
9472: PUSH
9473: LD_INT 1
9475: PLUS
9476: ST_TO_ADDR
// until p >= 60 ;
9477: LD_VAR 0 1
9481: PUSH
9482: LD_INT 60
9484: GREATEREQUAL
9485: IFFALSE 9448
// game_speed := 4 ;
9487: LD_ADDR_OWVAR 65
9491: PUSH
9492: LD_INT 4
9494: ST_TO_ADDR
// end ;
9495: PPOPN 1
9497: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9498: LD_EXP 26
9502: PUSH
9503: LD_EXP 51
9507: AND
9508: IFFALSE 9654
9510: GO 9512
9512: DISABLE
9513: LD_INT 0
9515: PPUSH
9516: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9517: LD_ADDR_VAR 0 1
9521: PUSH
9522: LD_INT 22
9524: PUSH
9525: LD_OWVAR 2
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: PUSH
9534: LD_INT 2
9536: PUSH
9537: LD_INT 30
9539: PUSH
9540: LD_INT 0
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: PUSH
9547: LD_INT 30
9549: PUSH
9550: LD_INT 1
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: LIST
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: PPUSH
9566: CALL_OW 69
9570: ST_TO_ADDR
// if not depot then
9571: LD_VAR 0 1
9575: NOT
9576: IFFALSE 9580
// exit ;
9578: GO 9654
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9580: LD_ADDR_VAR 0 2
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 1
9592: PPUSH
9593: LD_VAR 0 1
9597: PPUSH
9598: CALL_OW 12
9602: ARRAY
9603: PPUSH
9604: CALL_OW 274
9608: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9609: LD_VAR 0 2
9613: PPUSH
9614: LD_INT 1
9616: PPUSH
9617: LD_INT 0
9619: PPUSH
9620: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9624: LD_VAR 0 2
9628: PPUSH
9629: LD_INT 2
9631: PPUSH
9632: LD_INT 0
9634: PPUSH
9635: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9639: LD_VAR 0 2
9643: PPUSH
9644: LD_INT 3
9646: PPUSH
9647: LD_INT 0
9649: PPUSH
9650: CALL_OW 277
// end ;
9654: PPOPN 2
9656: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
9657: LD_EXP 26
9661: PUSH
9662: LD_EXP 52
9666: AND
9667: IFFALSE 9764
9669: GO 9671
9671: DISABLE
9672: LD_INT 0
9674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9675: LD_ADDR_VAR 0 1
9679: PUSH
9680: LD_INT 22
9682: PUSH
9683: LD_OWVAR 2
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PUSH
9692: LD_INT 21
9694: PUSH
9695: LD_INT 1
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PUSH
9702: LD_INT 3
9704: PUSH
9705: LD_INT 23
9707: PUSH
9708: LD_INT 0
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PUSH
9715: EMPTY
9716: LIST
9717: LIST
9718: PUSH
9719: EMPTY
9720: LIST
9721: LIST
9722: LIST
9723: PPUSH
9724: CALL_OW 69
9728: ST_TO_ADDR
// if not tmp then
9729: LD_VAR 0 1
9733: NOT
9734: IFFALSE 9738
// exit ;
9736: GO 9764
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
9738: LD_VAR 0 1
9742: PUSH
9743: LD_INT 1
9745: PPUSH
9746: LD_VAR 0 1
9750: PPUSH
9751: CALL_OW 12
9755: ARRAY
9756: PPUSH
9757: LD_INT 200
9759: PPUSH
9760: CALL_OW 234
// end ;
9764: PPOPN 1
9766: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
9767: LD_EXP 26
9771: PUSH
9772: LD_EXP 53
9776: AND
9777: IFFALSE 9856
9779: GO 9781
9781: DISABLE
9782: LD_INT 0
9784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: LD_INT 22
9792: PUSH
9793: LD_OWVAR 2
9797: PUSH
9798: EMPTY
9799: LIST
9800: LIST
9801: PUSH
9802: LD_INT 21
9804: PUSH
9805: LD_INT 2
9807: PUSH
9808: EMPTY
9809: LIST
9810: LIST
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PPUSH
9816: CALL_OW 69
9820: ST_TO_ADDR
// if not tmp then
9821: LD_VAR 0 1
9825: NOT
9826: IFFALSE 9830
// exit ;
9828: GO 9856
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
9830: LD_VAR 0 1
9834: PUSH
9835: LD_INT 1
9837: PPUSH
9838: LD_VAR 0 1
9842: PPUSH
9843: CALL_OW 12
9847: ARRAY
9848: PPUSH
9849: LD_INT 10
9851: PPUSH
9852: CALL_OW 234
// end ;
9856: PPOPN 1
9858: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9859: LD_EXP 26
9863: PUSH
9864: LD_EXP 54
9868: AND
9869: IFFALSE 9968
9871: GO 9873
9873: DISABLE
9874: LD_INT 0
9876: PPUSH
9877: PPUSH
// begin enable ;
9878: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9879: LD_ADDR_VAR 0 1
9883: PUSH
9884: LD_INT 22
9886: PUSH
9887: LD_OWVAR 2
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: PUSH
9896: LD_INT 61
9898: PUSH
9899: EMPTY
9900: LIST
9901: PUSH
9902: LD_INT 33
9904: PUSH
9905: LD_INT 2
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PPUSH
9917: CALL_OW 69
9921: ST_TO_ADDR
// if not tmp then
9922: LD_VAR 0 1
9926: NOT
9927: IFFALSE 9931
// exit ;
9929: GO 9968
// for i in tmp do
9931: LD_ADDR_VAR 0 2
9935: PUSH
9936: LD_VAR 0 1
9940: PUSH
9941: FOR_IN
9942: IFFALSE 9966
// if IsControledBy ( i ) then
9944: LD_VAR 0 2
9948: PPUSH
9949: CALL_OW 312
9953: IFFALSE 9964
// ComUnlink ( i ) ;
9955: LD_VAR 0 2
9959: PPUSH
9960: CALL_OW 136
9964: GO 9941
9966: POP
9967: POP
// end ; end_of_file
9968: PPOPN 2
9970: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
9971: LD_INT 0
9973: PPUSH
9974: PPUSH
9975: PPUSH
9976: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
9977: LD_VAR 0 1
9981: PPUSH
9982: CALL_OW 264
9986: PUSH
9987: LD_EXP 59
9991: EQUAL
9992: IFFALSE 10064
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
9994: LD_INT 68
9996: PPUSH
9997: LD_VAR 0 1
10001: PPUSH
10002: CALL_OW 255
10006: PPUSH
10007: CALL_OW 321
10011: PUSH
10012: LD_INT 2
10014: EQUAL
10015: IFFALSE 10027
// eff := 70 else
10017: LD_ADDR_VAR 0 6
10021: PUSH
10022: LD_INT 70
10024: ST_TO_ADDR
10025: GO 10035
// eff := 30 ;
10027: LD_ADDR_VAR 0 6
10031: PUSH
10032: LD_INT 30
10034: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
10035: LD_VAR 0 1
10039: PPUSH
10040: CALL_OW 250
10044: PPUSH
10045: LD_VAR 0 1
10049: PPUSH
10050: CALL_OW 251
10054: PPUSH
10055: LD_VAR 0 6
10059: PPUSH
10060: CALL_OW 495
// end ; end ;
10064: LD_VAR 0 4
10068: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
10069: LD_INT 0
10071: PPUSH
10072: PPUSH
10073: PPUSH
10074: PPUSH
10075: PPUSH
10076: PPUSH
// if cmd = 124 then
10077: LD_VAR 0 1
10081: PUSH
10082: LD_INT 124
10084: EQUAL
10085: IFFALSE 10291
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
10087: LD_ADDR_VAR 0 5
10091: PUSH
10092: LD_INT 2
10094: PUSH
10095: LD_INT 34
10097: PUSH
10098: LD_INT 53
10100: PUSH
10101: EMPTY
10102: LIST
10103: LIST
10104: PUSH
10105: LD_INT 34
10107: PUSH
10108: LD_INT 14
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: ST_TO_ADDR
// if not tmp then
10125: LD_VAR 0 5
10129: NOT
10130: IFFALSE 10134
// exit ;
10132: GO 10291
// for i in tmp do
10134: LD_ADDR_VAR 0 3
10138: PUSH
10139: LD_VAR 0 5
10143: PUSH
10144: FOR_IN
10145: IFFALSE 10289
// begin taskList := GetTaskList ( i ) ;
10147: LD_ADDR_VAR 0 6
10151: PUSH
10152: LD_VAR 0 3
10156: PPUSH
10157: CALL_OW 437
10161: ST_TO_ADDR
// if not taskList then
10162: LD_VAR 0 6
10166: NOT
10167: IFFALSE 10171
// continue ;
10169: GO 10144
// for j = 1 to taskList do
10171: LD_ADDR_VAR 0 4
10175: PUSH
10176: DOUBLE
10177: LD_INT 1
10179: DEC
10180: ST_TO_ADDR
10181: LD_VAR 0 6
10185: PUSH
10186: FOR_TO
10187: IFFALSE 10285
// if taskList [ j ] [ 1 ] = | then
10189: LD_VAR 0 6
10193: PUSH
10194: LD_VAR 0 4
10198: ARRAY
10199: PUSH
10200: LD_INT 1
10202: ARRAY
10203: PUSH
10204: LD_STRING |
10206: EQUAL
10207: IFFALSE 10283
// begin _taskList := Delete ( taskList , 1 ) ;
10209: LD_ADDR_VAR 0 7
10213: PUSH
10214: LD_VAR 0 6
10218: PPUSH
10219: LD_INT 1
10221: PPUSH
10222: CALL_OW 3
10226: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
10227: LD_VAR 0 3
10231: PPUSH
10232: LD_VAR 0 7
10236: PPUSH
10237: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
10241: LD_VAR 0 3
10245: PPUSH
10246: LD_VAR 0 6
10250: PUSH
10251: LD_VAR 0 4
10255: ARRAY
10256: PUSH
10257: LD_INT 2
10259: ARRAY
10260: PPUSH
10261: LD_VAR 0 6
10265: PUSH
10266: LD_VAR 0 4
10270: ARRAY
10271: PUSH
10272: LD_INT 3
10274: ARRAY
10275: PPUSH
10276: LD_INT 8
10278: PPUSH
10279: CALL 10296 0 4
// end ;
10283: GO 10186
10285: POP
10286: POP
// end ;
10287: GO 10144
10289: POP
10290: POP
// end ; end ;
10291: LD_VAR 0 2
10295: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
10296: LD_INT 0
10298: PPUSH
10299: PPUSH
10300: PPUSH
10301: PPUSH
10302: PPUSH
10303: PPUSH
10304: PPUSH
10305: PPUSH
10306: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
10307: LD_VAR 0 1
10311: NOT
10312: PUSH
10313: LD_VAR 0 2
10317: PPUSH
10318: LD_VAR 0 3
10322: PPUSH
10323: CALL_OW 488
10327: NOT
10328: OR
10329: PUSH
10330: LD_VAR 0 4
10334: NOT
10335: OR
10336: IFFALSE 10340
// exit ;
10338: GO 10680
// list := [ ] ;
10340: LD_ADDR_VAR 0 13
10344: PUSH
10345: EMPTY
10346: ST_TO_ADDR
// if x - r < 0 then
10347: LD_VAR 0 2
10351: PUSH
10352: LD_VAR 0 4
10356: MINUS
10357: PUSH
10358: LD_INT 0
10360: LESS
10361: IFFALSE 10373
// min_x := 0 else
10363: LD_ADDR_VAR 0 7
10367: PUSH
10368: LD_INT 0
10370: ST_TO_ADDR
10371: GO 10389
// min_x := x - r ;
10373: LD_ADDR_VAR 0 7
10377: PUSH
10378: LD_VAR 0 2
10382: PUSH
10383: LD_VAR 0 4
10387: MINUS
10388: ST_TO_ADDR
// if y - r < 0 then
10389: LD_VAR 0 3
10393: PUSH
10394: LD_VAR 0 4
10398: MINUS
10399: PUSH
10400: LD_INT 0
10402: LESS
10403: IFFALSE 10415
// min_y := 0 else
10405: LD_ADDR_VAR 0 8
10409: PUSH
10410: LD_INT 0
10412: ST_TO_ADDR
10413: GO 10431
// min_y := y - r ;
10415: LD_ADDR_VAR 0 8
10419: PUSH
10420: LD_VAR 0 3
10424: PUSH
10425: LD_VAR 0 4
10429: MINUS
10430: ST_TO_ADDR
// max_x := x + r ;
10431: LD_ADDR_VAR 0 9
10435: PUSH
10436: LD_VAR 0 2
10440: PUSH
10441: LD_VAR 0 4
10445: PLUS
10446: ST_TO_ADDR
// max_y := y + r ;
10447: LD_ADDR_VAR 0 10
10451: PUSH
10452: LD_VAR 0 3
10456: PUSH
10457: LD_VAR 0 4
10461: PLUS
10462: ST_TO_ADDR
// for _x = min_x to max_x do
10463: LD_ADDR_VAR 0 11
10467: PUSH
10468: DOUBLE
10469: LD_VAR 0 7
10473: DEC
10474: ST_TO_ADDR
10475: LD_VAR 0 9
10479: PUSH
10480: FOR_TO
10481: IFFALSE 10598
// for _y = min_y to max_y do
10483: LD_ADDR_VAR 0 12
10487: PUSH
10488: DOUBLE
10489: LD_VAR 0 8
10493: DEC
10494: ST_TO_ADDR
10495: LD_VAR 0 10
10499: PUSH
10500: FOR_TO
10501: IFFALSE 10594
// begin if not ValidHex ( _x , _y ) then
10503: LD_VAR 0 11
10507: PPUSH
10508: LD_VAR 0 12
10512: PPUSH
10513: CALL_OW 488
10517: NOT
10518: IFFALSE 10522
// continue ;
10520: GO 10500
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
10522: LD_VAR 0 11
10526: PPUSH
10527: LD_VAR 0 12
10531: PPUSH
10532: CALL_OW 351
10536: PUSH
10537: LD_VAR 0 11
10541: PPUSH
10542: LD_VAR 0 12
10546: PPUSH
10547: CALL_OW 554
10551: AND
10552: IFFALSE 10592
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
10554: LD_ADDR_VAR 0 13
10558: PUSH
10559: LD_VAR 0 13
10563: PPUSH
10564: LD_VAR 0 13
10568: PUSH
10569: LD_INT 1
10571: PLUS
10572: PPUSH
10573: LD_VAR 0 11
10577: PUSH
10578: LD_VAR 0 12
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PPUSH
10587: CALL_OW 2
10591: ST_TO_ADDR
// end ;
10592: GO 10500
10594: POP
10595: POP
10596: GO 10480
10598: POP
10599: POP
// if not list then
10600: LD_VAR 0 13
10604: NOT
10605: IFFALSE 10609
// exit ;
10607: GO 10680
// for i in list do
10609: LD_ADDR_VAR 0 6
10613: PUSH
10614: LD_VAR 0 13
10618: PUSH
10619: FOR_IN
10620: IFFALSE 10678
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
10622: LD_VAR 0 1
10626: PPUSH
10627: LD_STRING M
10629: PUSH
10630: LD_VAR 0 6
10634: PUSH
10635: LD_INT 1
10637: ARRAY
10638: PUSH
10639: LD_VAR 0 6
10643: PUSH
10644: LD_INT 2
10646: ARRAY
10647: PUSH
10648: LD_INT 0
10650: PUSH
10651: LD_INT 0
10653: PUSH
10654: LD_INT 0
10656: PUSH
10657: LD_INT 0
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: LIST
10668: PUSH
10669: EMPTY
10670: LIST
10671: PPUSH
10672: CALL_OW 447
10676: GO 10619
10678: POP
10679: POP
// end ; end_of_file
10680: LD_VAR 0 5
10684: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10685: GO 10687
10687: DISABLE
// begin ru_radar := 98 ;
10688: LD_ADDR_EXP 55
10692: PUSH
10693: LD_INT 98
10695: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10696: LD_ADDR_EXP 56
10700: PUSH
10701: LD_INT 89
10703: ST_TO_ADDR
// us_hack := 99 ;
10704: LD_ADDR_EXP 57
10708: PUSH
10709: LD_INT 99
10711: ST_TO_ADDR
// us_artillery := 97 ;
10712: LD_ADDR_EXP 58
10716: PUSH
10717: LD_INT 97
10719: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10720: LD_ADDR_EXP 59
10724: PUSH
10725: LD_INT 91
10727: ST_TO_ADDR
// end ;
10728: END
