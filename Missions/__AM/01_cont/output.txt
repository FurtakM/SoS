// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 32 0 0
// InitAmerican ;
  15: CALL 915 0 0
// InitRussian ;
  19: CALL 1154 0 0
// DebugMode ;
  23: CALL 152 0 0
// Action ;
  27: CALL 2710 0 0
// end ;
  31: END
// export debug ; export mission_prefix ; export active_russian_dialog , bobby_in_squad , powell_contact , macmilan_use_radio , cyrus_in_squad , active_road_patrol , macmilan_in_trap , meta_action , end_mission , bobby_saved , cyrus_saved , send_troops_to_forest ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// mission_prefix := 01_ ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_STRING 01_
  42: ST_TO_ADDR
// debug := 0 ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// active_russian_dialog := false ;
  51: LD_ADDR_EXP 3
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// bobby_in_squad := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// cyrus_in_squad := false ;
  67: LD_ADDR_EXP 7
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// powell_contact := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// macmilan_use_radio := false ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// active_road_patrol := false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// macmilan_in_trap := false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// meta_action := false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// end_mission := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// bobby_saved := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// cyrus_saved := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// send_troops_to_forest := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// function DebugMode ; var i ; begin
 152: LD_INT 0
 154: PPUSH
 155: PPUSH
// if not debug then
 156: LD_EXP 1
 160: NOT
 161: IFFALSE 165
// exit ;
 163: GO 184
// Difficulty := 3 ;
 165: LD_ADDR_OWVAR 67
 169: PUSH
 170: LD_INT 3
 172: ST_TO_ADDR
// TurnFogOff ( ) ;
 173: CALL_OW 537
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 216
// unit := CreateCharacter ( ident ) else
 199: LD_ADDR_VAR 0 4
 203: PUSH
 204: LD_VAR 0 1
 208: PPUSH
 209: CALL_OW 34
 213: ST_TO_ADDR
 214: GO 231
// unit := NewCharacter ( ident ) ;
 216: LD_ADDR_VAR 0 4
 220: PUSH
 221: LD_VAR 0 1
 225: PPUSH
 226: CALL_OW 25
 230: ST_TO_ADDR
// result := unit ;
 231: LD_ADDR_VAR 0 3
 235: PUSH
 236: LD_VAR 0 4
 240: ST_TO_ADDR
// end ;
 241: LD_VAR 0 3
 245: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 246: LD_INT 0
 248: PPUSH
 249: PPUSH
 250: PPUSH
// uc_side := GetSide ( b ) ;
 251: LD_ADDR_OWVAR 20
 255: PUSH
 256: LD_VAR 0 2
 260: PPUSH
 261: CALL_OW 255
 265: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 266: LD_ADDR_OWVAR 21
 270: PUSH
 271: LD_VAR 0 2
 275: PPUSH
 276: CALL_OW 248
 280: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 281: LD_INT 0
 283: PPUSH
 284: LD_INT 1
 286: PPUSH
 287: LD_VAR 0 1
 291: PPUSH
 292: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
 296: LD_ADDR_VAR 0 5
 300: PUSH
 301: LD_VAR 0 2
 305: PPUSH
 306: CALL_OW 254
 310: PUSH
 311: LD_INT 3
 313: MINUS
 314: ST_TO_ADDR
// if dir < 0 then
 315: LD_VAR 0 5
 319: PUSH
 320: LD_INT 0
 322: LESS
 323: IFFALSE 339
// dir := 6 + dir ;
 325: LD_ADDR_VAR 0 5
 329: PUSH
 330: LD_INT 6
 332: PUSH
 333: LD_VAR 0 5
 337: PLUS
 338: ST_TO_ADDR
// un := CreateHuman ;
 339: LD_ADDR_VAR 0 4
 343: PUSH
 344: CALL_OW 44
 348: ST_TO_ADDR
// SetDir ( un , dir ) ;
 349: LD_VAR 0 4
 353: PPUSH
 354: LD_VAR 0 5
 358: PPUSH
 359: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 363: LD_VAR 0 4
 367: PPUSH
 368: LD_VAR 0 2
 372: PPUSH
 373: CALL_OW 52
// end ;
 377: LD_VAR 0 3
 381: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 382: LD_INT 0
 384: PPUSH
// uc_side := side ;
 385: LD_ADDR_OWVAR 20
 389: PUSH
 390: LD_VAR 0 1
 394: ST_TO_ADDR
// uc_nation := nation ;
 395: LD_ADDR_OWVAR 21
 399: PUSH
 400: LD_VAR 0 2
 404: ST_TO_ADDR
// vc_chassis := chassis ;
 405: LD_ADDR_OWVAR 37
 409: PUSH
 410: LD_VAR 0 3
 414: ST_TO_ADDR
// vc_engine := engine ;
 415: LD_ADDR_OWVAR 39
 419: PUSH
 420: LD_VAR 0 4
 424: ST_TO_ADDR
// vc_control := control ;
 425: LD_ADDR_OWVAR 38
 429: PUSH
 430: LD_VAR 0 5
 434: ST_TO_ADDR
// vc_weapon := weapon ;
 435: LD_ADDR_OWVAR 40
 439: PUSH
 440: LD_VAR 0 6
 444: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 445: LD_ADDR_OWVAR 41
 449: PUSH
 450: LD_VAR 0 7
 454: ST_TO_ADDR
// result := CreateVehicle ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: CALL_OW 45
 464: ST_TO_ADDR
// end ;
 465: LD_VAR 0 8
 469: RET
// export function ComPatrol ( unit , mode , pause , coords ) ; var i ; begin
 470: LD_INT 0
 472: PPUSH
 473: PPUSH
// while ( active_road_patrol ) do
 474: LD_EXP 8
 478: IFFALSE 832
// begin Wait ( 0 0$01 ) ;
 480: LD_INT 35
 482: PPUSH
 483: CALL_OW 67
// if not unit then
 487: LD_VAR 0 1
 491: NOT
 492: IFFALSE 496
// exit ;
 494: GO 832
// if mode = road then
 496: LD_VAR 0 2
 500: PUSH
 501: LD_STRING road
 503: EQUAL
 504: IFFALSE 560
// if GetFuel ( unit ) < 50 and not See ( 1 , unit ) and not HasTask ( unit ) then
 506: LD_VAR 0 1
 510: PPUSH
 511: CALL_OW 261
 515: PUSH
 516: LD_INT 50
 518: LESS
 519: PUSH
 520: LD_INT 1
 522: PPUSH
 523: LD_VAR 0 1
 527: PPUSH
 528: CALL_OW 292
 532: NOT
 533: AND
 534: PUSH
 535: LD_VAR 0 1
 539: PPUSH
 540: CALL_OW 314
 544: NOT
 545: AND
 546: IFFALSE 560
// SetFuel ( unit , 100 ) ;
 548: LD_VAR 0 1
 552: PPUSH
 553: LD_INT 100
 555: PPUSH
 556: CALL_OW 240
// if mode = forest then
 560: LD_VAR 0 2
 564: PUSH
 565: LD_STRING forest
 567: EQUAL
 568: IFFALSE 648
// if GetLives ( unit ) < 600 then
 570: LD_VAR 0 1
 574: PPUSH
 575: CALL_OW 256
 579: PUSH
 580: LD_INT 600
 582: LESS
 583: IFFALSE 648
// begin ComMoveXY ( unit , 42 , 3 ) ;
 585: LD_VAR 0 1
 589: PPUSH
 590: LD_INT 42
 592: PPUSH
 593: LD_INT 3
 595: PPUSH
 596: CALL_OW 111
// SetRememberedX ( unit , GetX ( unit ) ) ;
 600: LD_VAR 0 1
 604: PPUSH
 605: LD_VAR 0 1
 609: PPUSH
 610: CALL_OW 250
 614: PPUSH
 615: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
 619: LD_VAR 0 1
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: CALL_OW 251
 633: PPUSH
 634: CALL_OW 232
// send_troops_to_forest := true ;
 638: LD_ADDR_EXP 14
 642: PUSH
 643: LD_INT 1
 645: ST_TO_ADDR
// break ;
 646: GO 832
// end ; if not HasTask ( unit ) then
 648: LD_VAR 0 1
 652: PPUSH
 653: CALL_OW 314
 657: NOT
 658: IFFALSE 830
// begin for i = 1 to coords do
 660: LD_ADDR_VAR 0 6
 664: PUSH
 665: DOUBLE
 666: LD_INT 1
 668: DEC
 669: ST_TO_ADDR
 670: LD_VAR 0 4
 674: PUSH
 675: FOR_TO
 676: IFFALSE 743
// begin AddComAgressiveMove ( unit , coords [ i ] , coords [ i + 1 ] ) ;
 678: LD_VAR 0 1
 682: PPUSH
 683: LD_VAR 0 4
 687: PUSH
 688: LD_VAR 0 6
 692: ARRAY
 693: PPUSH
 694: LD_VAR 0 4
 698: PUSH
 699: LD_VAR 0 6
 703: PUSH
 704: LD_INT 1
 706: PLUS
 707: ARRAY
 708: PPUSH
 709: CALL_OW 174
// AddComWait ( unit , pause ) ;
 713: LD_VAR 0 1
 717: PPUSH
 718: LD_VAR 0 3
 722: PPUSH
 723: CALL_OW 202
// i := i + 1 ;
 727: LD_ADDR_VAR 0 6
 731: PUSH
 732: LD_VAR 0 6
 736: PUSH
 737: LD_INT 1
 739: PLUS
 740: ST_TO_ADDR
// end ;
 741: GO 675
 743: POP
 744: POP
// for i = coords downto 1 do
 745: LD_ADDR_VAR 0 6
 749: PUSH
 750: DOUBLE
 751: LD_VAR 0 4
 755: INC
 756: ST_TO_ADDR
 757: LD_INT 1
 759: PUSH
 760: FOR_DOWNTO
 761: IFFALSE 828
// begin AddComAgressiveMove ( unit , coords [ i - 1 ] , coords [ i ] ) ;
 763: LD_VAR 0 1
 767: PPUSH
 768: LD_VAR 0 4
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_INT 1
 780: MINUS
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 4
 787: PUSH
 788: LD_VAR 0 6
 792: ARRAY
 793: PPUSH
 794: CALL_OW 174
// AddComWait ( unit , pause ) ;
 798: LD_VAR 0 1
 802: PPUSH
 803: LD_VAR 0 3
 807: PPUSH
 808: CALL_OW 202
// i := i - 1 ;
 812: LD_ADDR_VAR 0 6
 816: PUSH
 817: LD_VAR 0 6
 821: PUSH
 822: LD_INT 1
 824: MINUS
 825: ST_TO_ADDR
// end ;
 826: GO 760
 828: POP
 829: POP
// end ; end ;
 830: GO 474
// end ;
 832: LD_VAR 0 5
 836: RET
// export function DebugSay ( dialog ) ; var speaker ; begin
 837: LD_INT 0
 839: PPUSH
 840: PPUSH
// uc_nation := 1 ;
 841: LD_ADDR_OWVAR 21
 845: PUSH
 846: LD_INT 1
 848: ST_TO_ADDR
// uc_side := 0 ;
 849: LD_ADDR_OWVAR 20
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
 857: LD_INT 0
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: CALL_OW 380
// hc_name := speaker ;
 870: LD_ADDR_OWVAR 26
 874: PUSH
 875: LD_STRING speaker
 877: ST_TO_ADDR
// hc_gallery :=  ;
 878: LD_ADDR_OWVAR 33
 882: PUSH
 883: LD_STRING 
 885: ST_TO_ADDR
// speaker := CreateHuman ;
 886: LD_ADDR_VAR 0 3
 890: PUSH
 891: CALL_OW 44
 895: ST_TO_ADDR
// Say ( speaker , dialog ) ;
 896: LD_VAR 0 3
 900: PPUSH
 901: LD_VAR 0 1
 905: PPUSH
 906: CALL_OW 88
// end ; end_of_file
 910: LD_VAR 0 2
 914: RET
// export JMM , Bobby , Cyrus , Powell , fakePokryshkin ; export function InitAmerican ; begin
 915: LD_INT 0
 917: PPUSH
// uc_nation := 1 ;
 918: LD_ADDR_OWVAR 21
 922: PUSH
 923: LD_INT 1
 925: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , false ) ;
 926: LD_ADDR_EXP 15
 930: PUSH
 931: LD_STRING JMM
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL 189 0 2
 941: ST_TO_ADDR
// uc_side := 4 ;
 942: LD_ADDR_OWVAR 20
 946: PUSH
 947: LD_INT 4
 949: ST_TO_ADDR
// hc_gallery := us ;
 950: LD_ADDR_OWVAR 33
 954: PUSH
 955: LD_STRING us
 957: ST_TO_ADDR
// hc_face_number := 7 ;
 958: LD_ADDR_OWVAR 34
 962: PUSH
 963: LD_INT 7
 965: ST_TO_ADDR
// hc_sex := sex_male ;
 966: LD_ADDR_OWVAR 27
 970: PUSH
 971: LD_INT 1
 973: ST_TO_ADDR
// hc_name := . ;
 974: LD_ADDR_OWVAR 26
 978: PUSH
 979: LD_STRING .
 981: ST_TO_ADDR
// hc_class := 1 ;
 982: LD_ADDR_OWVAR 28
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// Powell := CreateHuman ;
 990: LD_ADDR_EXP 18
 994: PUSH
 995: CALL_OW 44
 999: ST_TO_ADDR
// hc_name := . ;
1000: LD_ADDR_OWVAR 26
1004: PUSH
1005: LD_STRING .
1007: ST_TO_ADDR
// hc_gallery := ru ;
1008: LD_ADDR_OWVAR 33
1012: PUSH
1013: LD_STRING ru
1015: ST_TO_ADDR
// hc_face_number := 4 ;
1016: LD_ADDR_OWVAR 34
1020: PUSH
1021: LD_INT 4
1023: ST_TO_ADDR
// hc_sex := sex_male ;
1024: LD_ADDR_OWVAR 27
1028: PUSH
1029: LD_INT 1
1031: ST_TO_ADDR
// fakePokryshkin := CreateHuman ;
1032: LD_ADDR_EXP 19
1036: PUSH
1037: CALL_OW 44
1041: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , false ) ;
1042: LD_ADDR_EXP 16
1046: PUSH
1047: LD_STRING Bobby
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL 189 0 2
1057: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , false ) ;
1058: LD_ADDR_EXP 17
1062: PUSH
1063: LD_STRING Cyrus
1065: PPUSH
1066: LD_INT 0
1068: PPUSH
1069: CALL 189 0 2
1073: ST_TO_ADDR
// case Difficulty of 1 :
1074: LD_OWVAR 67
1078: PUSH
1079: LD_INT 1
1081: DOUBLE
1082: EQUAL
1083: IFTRUE 1087
1085: GO 1102
1087: POP
// SetLives ( Bobby , 500 ) ; 2 :
1088: LD_EXP 16
1092: PPUSH
1093: LD_INT 500
1095: PPUSH
1096: CALL_OW 234
1100: GO 1149
1102: LD_INT 2
1104: DOUBLE
1105: EQUAL
1106: IFTRUE 1110
1108: GO 1125
1110: POP
// SetLives ( Bobby , 460 ) ; 3 :
1111: LD_EXP 16
1115: PPUSH
1116: LD_INT 460
1118: PPUSH
1119: CALL_OW 234
1123: GO 1149
1125: LD_INT 3
1127: DOUBLE
1128: EQUAL
1129: IFTRUE 1133
1131: GO 1148
1133: POP
// SetLives ( Bobby , 420 ) ; end ;
1134: LD_EXP 16
1138: PPUSH
1139: LD_INT 420
1141: PPUSH
1142: CALL_OW 234
1146: GO 1149
1148: POP
// end ; end_of_file
1149: LD_VAR 0 1
1153: RET
// export russian_troops_1 , russian_troops_2 , russian_patrol_tanks , russian_meta_guards , russian_patrol_forest ; export Pokryshkin ; export function InitRussian ; var skill , i , un ; begin
1154: LD_INT 0
1156: PPUSH
1157: PPUSH
1158: PPUSH
1159: PPUSH
// skill := [ 1 , 2 , 3 ] [ Difficulty ] ;
1160: LD_ADDR_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: PUSH
1168: LD_INT 2
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: PUSH
1179: LD_OWVAR 67
1183: ARRAY
1184: ST_TO_ADDR
// uc_side := 3 ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_INT 3
1192: ST_TO_ADDR
// uc_nation := 3 ;
1193: LD_ADDR_OWVAR 21
1197: PUSH
1198: LD_INT 3
1200: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
1201: LD_ADDR_EXP 25
1205: PUSH
1206: LD_STRING Pokryshkin
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL 189 0 2
1216: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 44 , 5 , false ) ;
1217: LD_EXP 25
1221: PPUSH
1222: LD_INT 44
1224: PPUSH
1225: LD_INT 5
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 48
// hc_importance := 0 ;
1235: LD_ADDR_OWVAR 32
1239: PUSH
1240: LD_INT 0
1242: ST_TO_ADDR
// hc_gallery :=  ;
1243: LD_ADDR_OWVAR 33
1247: PUSH
1248: LD_STRING 
1250: ST_TO_ADDR
// hc_name :=  ;
1251: LD_ADDR_OWVAR 26
1255: PUSH
1256: LD_STRING 
1258: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
1259: LD_INT 1
1261: PPUSH
1262: LD_INT 1
1264: PPUSH
1265: LD_VAR 0 2
1269: PPUSH
1270: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1274: LD_ADDR_OWVAR 33
1278: PUSH
1279: LD_STRING SecondCharsGal
1281: ST_TO_ADDR
// hc_face_number := 69 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 69
1289: ST_TO_ADDR
// hc_sex := sex_male ;
1290: LD_ADDR_OWVAR 27
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// hc_name := Ilja Ivanov ;
1298: LD_ADDR_OWVAR 26
1302: PUSH
1303: LD_STRING Ilja Ivanov
1305: ST_TO_ADDR
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 4
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 1 , un ) ;
1316: LD_ADDR_EXP 20
1320: PUSH
1321: LD_EXP 20
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 4
1333: PPUSH
1334: CALL_OW 2
1338: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 3
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 49
// PrepareHuman ( sex_male , 1 , skill ) ;
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: LD_VAR 0 2
1364: PPUSH
1365: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1369: LD_ADDR_OWVAR 33
1373: PUSH
1374: LD_STRING SecondCharsGal
1376: ST_TO_ADDR
// hc_face_number := 70 ;
1377: LD_ADDR_OWVAR 34
1381: PUSH
1382: LD_INT 70
1384: ST_TO_ADDR
// hc_name := Pavel Starczy ;
1385: LD_ADDR_OWVAR 26
1389: PUSH
1390: LD_STRING Pavel Starczy
1392: ST_TO_ADDR
// un := CreateHuman ;
1393: LD_ADDR_VAR 0 4
1397: PUSH
1398: CALL_OW 44
1402: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 2 , un ) ;
1403: LD_ADDR_EXP 20
1407: PUSH
1408: LD_EXP 20
1412: PPUSH
1413: LD_INT 2
1415: PPUSH
1416: LD_VAR 0 4
1420: PPUSH
1421: CALL_OW 2
1425: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1426: LD_VAR 0 4
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: LD_INT 0
1436: PPUSH
1437: CALL_OW 49
// InitHc ;
1441: CALL_OW 19
// for i = 1 to 7 do
1445: LD_ADDR_VAR 0 3
1449: PUSH
1450: DOUBLE
1451: LD_INT 1
1453: DEC
1454: ST_TO_ADDR
1455: LD_INT 7
1457: PUSH
1458: FOR_TO
1459: IFFALSE 1610
// begin PrepareHuman ( false , 1 , skill ) ;
1461: LD_INT 0
1463: PPUSH
1464: LD_INT 1
1466: PPUSH
1467: LD_VAR 0 2
1471: PPUSH
1472: CALL_OW 380
// un := CreateHuman ;
1476: LD_ADDR_VAR 0 4
1480: PUSH
1481: CALL_OW 44
1485: ST_TO_ADDR
// if i mod 2 = 0 then
1486: LD_VAR 0 3
1490: PUSH
1491: LD_INT 2
1493: MOD
1494: PUSH
1495: LD_INT 0
1497: EQUAL
1498: IFFALSE 1555
// begin russian_troops_1 := Insert ( russian_troops_1 , russian_troops_1 + 1 , un ) ;
1500: LD_ADDR_EXP 20
1504: PUSH
1505: LD_EXP 20
1509: PPUSH
1510: LD_EXP 20
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1529: LD_VAR 0 4
1533: PPUSH
1534: LD_INT 3
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 49
// ComHold ( un ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: CALL_OW 140
// end else
1553: GO 1608
// begin russian_troops_2 := Insert ( russian_troops_2 , russian_troops_2 + 1 , un ) ;
1555: LD_ADDR_EXP 21
1559: PUSH
1560: LD_EXP 21
1564: PPUSH
1565: LD_EXP 21
1569: PUSH
1570: LD_INT 1
1572: PLUS
1573: PPUSH
1574: LD_VAR 0 4
1578: PPUSH
1579: CALL_OW 2
1583: ST_TO_ADDR
// PlaceUnitArea ( un , guard_south , false ) ;
1584: LD_VAR 0 4
1588: PPUSH
1589: LD_INT 4
1591: PPUSH
1592: LD_INT 0
1594: PPUSH
1595: CALL_OW 49
// ComHold ( un ) ;
1599: LD_VAR 0 4
1603: PPUSH
1604: CALL_OW 140
// end ; end ;
1608: GO 1458
1610: POP
1611: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) do
1612: LD_ADDR_VAR 0 3
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 3
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 30
1629: PUSH
1630: LD_INT 31
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: PPUSH
1641: CALL_OW 69
1645: PUSH
1646: FOR_IN
1647: IFFALSE 1665
// PrepareSolBun ( skill , i ) ;
1649: LD_VAR 0 2
1653: PPUSH
1654: LD_VAR 0 3
1658: PPUSH
1659: CALL 246 0 2
1663: GO 1646
1665: POP
1666: POP
// for i = 1 to 2 do
1667: LD_ADDR_VAR 0 3
1671: PUSH
1672: DOUBLE
1673: LD_INT 1
1675: DEC
1676: ST_TO_ADDR
1677: LD_INT 2
1679: PUSH
1680: FOR_TO
1681: IFFALSE 1812
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , 100 ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_INT 3
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: LD_INT 22
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 1
1702: PPUSH
1703: LD_INT 42
1705: PPUSH
1706: LD_INT 100
1708: PPUSH
1709: CALL 382 0 7
1713: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
1714: LD_INT 0
1716: PPUSH
1717: LD_INT 3
1719: PPUSH
1720: LD_VAR 0 2
1724: PPUSH
1725: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
1729: CALL_OW 44
1733: PPUSH
1734: LD_VAR 0 4
1738: PPUSH
1739: CALL_OW 52
// PlaceUnitXY ( un , [ 23 , 131 ] [ i ] , [ 14 , 87 ] [ i ] , false ) ;
1743: LD_VAR 0 4
1747: PPUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 131
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_VAR 0 3
1762: ARRAY
1763: PPUSH
1764: LD_INT 14
1766: PUSH
1767: LD_INT 87
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: LD_VAR 0 3
1778: ARRAY
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 48
// russian_patrol_tanks := Insert ( russian_patrol_tanks , 1 , un ) ;
1787: LD_ADDR_EXP 22
1791: PUSH
1792: LD_EXP 22
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_VAR 0 4
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// end ;
1810: GO 1680
1812: POP
1813: POP
// for i = 1 to 2 do
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: DOUBLE
1820: LD_INT 1
1822: DEC
1823: ST_TO_ADDR
1824: LD_INT 2
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1919
// begin PrepareHuman ( [ sex_female , sex_male , sex_male ] [ i ] , 1 , 1 ) ;
1830: LD_INT 2
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: PUSH
1844: LD_VAR 0 3
1848: ARRAY
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: LD_INT 1
1855: PPUSH
1856: CALL_OW 380
// un := CreateHuman ;
1860: LD_ADDR_VAR 0 4
1864: PUSH
1865: CALL_OW 44
1869: ST_TO_ADDR
// russian_meta_guards := Insert ( russian_meta_guards , 1 , un ) ;
1870: LD_ADDR_EXP 23
1874: PUSH
1875: LD_EXP 23
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: LD_VAR 0 4
1887: PPUSH
1888: CALL_OW 2
1892: ST_TO_ADDR
// PlaceUnitArea ( un , exitArea , false ) ;
1893: LD_VAR 0 4
1897: PPUSH
1898: LD_INT 10
1900: PPUSH
1901: LD_INT 0
1903: PPUSH
1904: CALL_OW 49
// ComHold ( un ) ;
1908: LD_VAR 0 4
1912: PPUSH
1913: CALL_OW 140
// end ;
1917: GO 1827
1919: POP
1920: POP
// if Difficulty < 3 then
1921: LD_OWVAR 67
1925: PUSH
1926: LD_INT 3
1928: LESS
1929: IFFALSE 1933
// exit ;
1931: GO 1976
// PrepareHuman ( false , 1 , skill ) ;
1933: LD_INT 0
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: LD_VAR 0 2
1943: PPUSH
1944: CALL_OW 380
// russian_patrol_forest := CreateHuman ;
1948: LD_ADDR_EXP 24
1952: PUSH
1953: CALL_OW 44
1957: ST_TO_ADDR
// PlaceUnitXY ( russian_patrol_forest , 82 , 2 , false ) ;
1958: LD_EXP 24
1962: PPUSH
1963: LD_INT 82
1965: PPUSH
1966: LD_INT 2
1968: PPUSH
1969: LD_INT 0
1971: PPUSH
1972: CALL_OW 48
// end ;
1976: LD_VAR 0 1
1980: RET
// every 0 0$01 trigger active_road_patrol do
1981: LD_EXP 8
1985: IFFALSE 2051
1987: GO 1989
1989: DISABLE
// ComPatrol ( russian_patrol_tanks [ 1 ] , road , 0 0$02 , [ 131 , 87 , 107 , 75 , 107 , 66 , 114 , 61 , 107 , 34 ] ) ;
1990: LD_EXP 22
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_STRING road
2001: PPUSH
2002: LD_INT 70
2004: PPUSH
2005: LD_INT 131
2007: PUSH
2008: LD_INT 87
2010: PUSH
2011: LD_INT 107
2013: PUSH
2014: LD_INT 75
2016: PUSH
2017: LD_INT 107
2019: PUSH
2020: LD_INT 66
2022: PUSH
2023: LD_INT 114
2025: PUSH
2026: LD_INT 61
2028: PUSH
2029: LD_INT 107
2031: PUSH
2032: LD_INT 34
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 470 0 4
2051: END
// every 0 0$01 trigger active_road_patrol do
2052: LD_EXP 8
2056: IFFALSE 2114
2058: GO 2060
2060: DISABLE
// ComPatrol ( russian_patrol_tanks [ 2 ] , road , 0 0$02 , [ 21 , 12 , 37 , 30 , 65 , 62 , 107 , 76 ] ) ;
2061: LD_EXP 22
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: LD_STRING road
2072: PPUSH
2073: LD_INT 70
2075: PPUSH
2076: LD_INT 21
2078: PUSH
2079: LD_INT 12
2081: PUSH
2082: LD_INT 37
2084: PUSH
2085: LD_INT 30
2087: PUSH
2088: LD_INT 65
2090: PUSH
2091: LD_INT 62
2093: PUSH
2094: LD_INT 107
2096: PUSH
2097: LD_INT 76
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL 470 0 4
2114: END
// every 0 0$01 trigger IsOk ( russian_patrol_forest ) do
2115: LD_EXP 24
2119: PPUSH
2120: CALL_OW 302
2124: IFFALSE 2186
2126: GO 2128
2128: DISABLE
// ComPatrol ( russian_patrol_forest , forest , 0 0$01 , [ 52 , 15 , 81 , 9 , 120 , 52 , 135 , 80 , 122 , 95 ] ) ;
2129: LD_EXP 24
2133: PPUSH
2134: LD_STRING forest
2136: PPUSH
2137: LD_INT 35
2139: PPUSH
2140: LD_INT 52
2142: PUSH
2143: LD_INT 15
2145: PUSH
2146: LD_INT 81
2148: PUSH
2149: LD_INT 9
2151: PUSH
2152: LD_INT 120
2154: PUSH
2155: LD_INT 52
2157: PUSH
2158: LD_INT 135
2160: PUSH
2161: LD_INT 80
2163: PUSH
2164: LD_INT 122
2166: PUSH
2167: LD_INT 95
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL 470 0 4
2186: END
// every 0 0$01 trigger macmilan_use_radio do
2187: LD_EXP 6
2191: IFFALSE 2252
2193: GO 2195
2195: DISABLE
// begin active_road_patrol := false ;
2196: LD_ADDR_EXP 8
2200: PUSH
2201: LD_INT 0
2203: ST_TO_ADDR
// ComStop ( russian_patrol_tanks ) ;
2204: LD_EXP 22
2208: PPUSH
2209: CALL_OW 141
// AddComAgressiveMove ( russian_patrol_tanks , 72 , 41 ) ;
2213: LD_EXP 22
2217: PPUSH
2218: LD_INT 72
2220: PPUSH
2221: LD_INT 41
2223: PPUSH
2224: CALL_OW 174
// ComExitBuilding ( russian_troops_2 ) ;
2228: LD_EXP 21
2232: PPUSH
2233: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , 72 , 41 ) ;
2237: LD_EXP 21
2241: PPUSH
2242: LD_INT 72
2244: PPUSH
2245: LD_INT 41
2247: PPUSH
2248: CALL_OW 174
// end ;
2252: END
// every 0 0$03 trigger FilterUnitsInArea ( def_south , [ f_side , 1 ] ) do var un ;
2253: LD_INT 9
2255: PPUSH
2256: LD_INT 22
2258: PUSH
2259: LD_INT 1
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL_OW 70
2270: IFFALSE 2344
2272: GO 2274
2274: DISABLE
2275: LD_INT 0
2277: PPUSH
// begin enable ;
2278: ENABLE
// un := FilterUnitsInArea ( def_south , [ f_side , 1 ] ) [ 1 ] ;
2279: LD_ADDR_VAR 0 1
2283: PUSH
2284: LD_INT 9
2286: PPUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL_OW 70
2301: PUSH
2302: LD_INT 1
2304: ARRAY
2305: ST_TO_ADDR
// ComExitBuilding ( russian_troops_2 ) ;
2306: LD_EXP 21
2310: PPUSH
2311: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , GetX ( un ) , GetY ( un ) ) ;
2315: LD_EXP 21
2319: PPUSH
2320: LD_VAR 0 1
2324: PPUSH
2325: CALL_OW 250
2329: PPUSH
2330: LD_VAR 0 1
2334: PPUSH
2335: CALL_OW 251
2339: PPUSH
2340: CALL_OW 174
// end ;
2344: PPOPN 1
2346: END
// every 0 0$01 trigger ( GetLives ( russian_patrol_tanks [ 1 ] ) < 999 or GetLives ( russian_patrol_tanks [ 2 ] ) < 999 ) and See ( 3 , JMM ) do
2347: LD_EXP 22
2351: PUSH
2352: LD_INT 1
2354: ARRAY
2355: PPUSH
2356: CALL_OW 256
2360: PUSH
2361: LD_INT 999
2363: LESS
2364: PUSH
2365: LD_EXP 22
2369: PUSH
2370: LD_INT 2
2372: ARRAY
2373: PPUSH
2374: CALL_OW 256
2378: PUSH
2379: LD_INT 999
2381: LESS
2382: OR
2383: PUSH
2384: LD_INT 3
2386: PPUSH
2387: LD_EXP 15
2391: PPUSH
2392: CALL_OW 292
2396: AND
2397: IFFALSE 2424
2399: GO 2401
2401: DISABLE
// begin active_road_patrol := false ;
2402: LD_ADDR_EXP 8
2406: PUSH
2407: LD_INT 0
2409: ST_TO_ADDR
// ComAttackUnit ( russian_patrol_tanks , JMM ) ;
2410: LD_EXP 22
2414: PPUSH
2415: LD_EXP 15
2419: PPUSH
2420: CALL_OW 115
// end ;
2424: END
// every 0 0$01 trigger macmilan_in_trap do
2425: LD_EXP 9
2429: IFFALSE 2475
2431: GO 2433
2433: DISABLE
// begin ComExitBuilding ( russian_troops_2 ) ;
2434: LD_EXP 21
2438: PPUSH
2439: CALL_OW 122
// ComAttackUnit ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , JMM ) ;
2443: LD_EXP 20
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: PUSH
2454: LD_EXP 25
2458: ADD
2459: PUSH
2460: LD_EXP 22
2464: ADD
2465: PPUSH
2466: LD_EXP 15
2470: PPUSH
2471: CALL_OW 115
// end ;
2475: END
// every 0 0$01 trigger meta_action do
2476: LD_EXP 10
2480: IFFALSE 2526
2482: GO 2484
2484: DISABLE
// begin active_road_patrol := false ;
2485: LD_ADDR_EXP 8
2489: PUSH
2490: LD_INT 0
2492: ST_TO_ADDR
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , 93 , 1 ) ;
2493: LD_EXP 20
2497: PUSH
2498: LD_EXP 21
2502: ADD
2503: PUSH
2504: LD_EXP 25
2508: ADD
2509: PUSH
2510: LD_EXP 22
2514: ADD
2515: PPUSH
2516: LD_INT 93
2518: PPUSH
2519: LD_INT 1
2521: PPUSH
2522: CALL_OW 114
// end ;
2526: END
// every 0 0$1 trigger GetLives ( Pokryshkin ) < 1000 do
2527: LD_EXP 25
2531: PPUSH
2532: CALL_OW 256
2536: PUSH
2537: LD_INT 1000
2539: LESS
2540: IFFALSE 2591
2542: GO 2544
2544: DISABLE
// begin enable ;
2545: ENABLE
// if HexInfo ( 18 , 1 ) = Pokryshkin then
2546: LD_INT 18
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 428
2556: PUSH
2557: LD_EXP 25
2561: EQUAL
2562: IFFALSE 2576
// begin RemoveUnit ( Pokryshkin ) ;
2564: LD_EXP 25
2568: PPUSH
2569: CALL_OW 64
// disable ;
2573: DISABLE
// end else
2574: GO 2591
// ComMoveXY ( Pokryshkin , 18 , 1 ) ;
2576: LD_EXP 25
2580: PPUSH
2581: LD_INT 18
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: CALL_OW 111
// end ;
2591: END
// every 0 0$20 trigger send_troops_to_forest do
2592: LD_EXP 14
2596: IFFALSE 2650
2598: GO 2600
2600: DISABLE
// begin if not IsOk ( russian_patrol_forest ) then
2601: LD_EXP 24
2605: PPUSH
2606: CALL_OW 302
2610: NOT
2611: IFFALSE 2615
// exit ;
2613: GO 2650
// ComAgressiveMove ( russian_troops_1 ^ Pokryshkin , GetRememberedX ( russian_patrol_forest ) , GetRememberedY ( russian_patrol_forest ) ) ;
2615: LD_EXP 20
2619: PUSH
2620: LD_EXP 25
2624: ADD
2625: PPUSH
2626: LD_EXP 24
2630: PPUSH
2631: CALL_OW 252
2635: PPUSH
2636: LD_EXP 24
2640: PPUSH
2641: CALL_OW 253
2645: PPUSH
2646: CALL_OW 114
// end ;
2650: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do begin if GetSide ( driver ) = 3 then
2651: LD_VAR 0 1
2655: PPUSH
2656: CALL_OW 255
2660: PUSH
2661: LD_INT 3
2663: EQUAL
2664: IFFALSE 2707
// begin wait ( 11 ) ;
2666: LD_INT 11
2668: PPUSH
2669: CALL_OW 67
// ComEnterUnit ( driver , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_depot ] ) , driver ) ) ;
2673: LD_VAR 0 1
2677: PPUSH
2678: LD_INT 30
2680: PUSH
2681: LD_INT 0
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: PPUSH
2693: LD_VAR 0 1
2697: PPUSH
2698: CALL_OW 74
2702: PPUSH
2703: CALL_OW 120
// end ; end ; end_of_file
2707: PPOPN 4
2709: END
// export function Action ; var i ; begin
2710: LD_INT 0
2712: PPUSH
2713: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_INT 22
2721: PUSH
2722: LD_INT 3
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 25
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2762
// ComHold ( i ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: CALL_OW 140
2760: GO 2748
2762: POP
2763: POP
// InGameOn ;
2764: CALL_OW 8
// CenterOnXY ( 79 , 76 ) ;
2768: LD_INT 79
2770: PPUSH
2771: LD_INT 76
2773: PPUSH
2774: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
2778: LD_INT 10
2780: PPUSH
2781: CALL_OW 67
// PlaceUnitXY ( JMM , 80 , 79 , true ) ;
2785: LD_EXP 15
2789: PPUSH
2790: LD_INT 80
2792: PPUSH
2793: LD_INT 79
2795: PPUSH
2796: LD_INT 1
2798: PPUSH
2799: CALL_OW 48
// Wait ( 0 0$03 ) ;
2803: LD_INT 105
2805: PPUSH
2806: CALL_OW 67
// ComMoveXY ( JMM , 80 , 76 ) ;
2810: LD_EXP 15
2814: PPUSH
2815: LD_INT 80
2817: PPUSH
2818: LD_INT 76
2820: PPUSH
2821: CALL_OW 111
// Say ( JMM , D1-JMM-1 ) ;
2825: LD_EXP 15
2829: PPUSH
2830: LD_STRING D1-JMM-1
2832: PPUSH
2833: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2837: LD_INT 10
2839: PPUSH
2840: CALL_OW 67
// ComMoveXY ( JMM , 76 , 76 ) ;
2844: LD_EXP 15
2848: PPUSH
2849: LD_INT 76
2851: PPUSH
2852: LD_INT 76
2854: PPUSH
2855: CALL_OW 111
// Say ( JMM , D1-JMM-1a ) ;
2859: LD_EXP 15
2863: PPUSH
2864: LD_STRING D1-JMM-1a
2866: PPUSH
2867: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2871: LD_INT 10
2873: PPUSH
2874: CALL_OW 67
// ComTurnXY ( JMM , 83 , 66 ) ;
2878: LD_EXP 15
2882: PPUSH
2883: LD_INT 83
2885: PPUSH
2886: LD_INT 66
2888: PPUSH
2889: CALL_OW 118
// Say ( JMM , D1-JMM-1b ) ;
2893: LD_EXP 15
2897: PPUSH
2898: LD_STRING D1-JMM-1b
2900: PPUSH
2901: CALL_OW 88
// Wait ( 0 0$0.5 ) ;
2905: LD_INT 18
2907: PPUSH
2908: CALL_OW 67
// Say ( JMM , D1-JMM-1c ) ;
2912: LD_EXP 15
2916: PPUSH
2917: LD_STRING D1-JMM-1c
2919: PPUSH
2920: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
2924: LD_INT 7
2926: PPUSH
2927: CALL_OW 67
// SayRadio ( Powell , D1-Pow-1 ) ;
2931: LD_EXP 18
2935: PPUSH
2936: LD_STRING D1-Pow-1
2938: PPUSH
2939: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
2943: LD_EXP 15
2947: PPUSH
2948: LD_STRING D1-JMM-2
2950: PPUSH
2951: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
2955: LD_EXP 18
2959: PPUSH
2960: LD_STRING D1-Pow-2
2962: PPUSH
2963: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
2967: LD_EXP 15
2971: PPUSH
2972: LD_STRING D1-JMM-3
2974: PPUSH
2975: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_STRING D1-Pow-3
2986: PPUSH
2987: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
2991: LD_EXP 15
2995: PPUSH
2996: LD_STRING D1-JMM-4
2998: PPUSH
2999: CALL_OW 88
// ComFree ( JMM ) ;
3003: LD_EXP 15
3007: PPUSH
3008: CALL_OW 139
// Wait ( 0 0$0.3 ) ;
3012: LD_INT 10
3014: PPUSH
3015: CALL_OW 67
// InGameOff ;
3019: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3023: LD_STRING M1
3025: PPUSH
3026: CALL_OW 337
// SaveForQuickRestart ;
3030: CALL_OW 22
// active_russian_dialog := true ;
3034: LD_ADDR_EXP 3
3038: PUSH
3039: LD_INT 1
3041: ST_TO_ADDR
// active_road_patrol := true ;
3042: LD_ADDR_EXP 8
3046: PUSH
3047: LD_INT 1
3049: ST_TO_ADDR
// if Difficulty < 3 then
3050: LD_OWVAR 67
3054: PUSH
3055: LD_INT 3
3057: LESS
3058: IFFALSE 3089
// begin PlaceUnitXY ( Bobby , 41 , 71 , false ) ;
3060: LD_EXP 16
3064: PPUSH
3065: LD_INT 41
3067: PPUSH
3068: LD_INT 71
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 48
// ComHold ( Bobby ) ;
3078: LD_EXP 16
3082: PPUSH
3083: CALL_OW 140
// end else
3087: GO 3137
// begin SetDir ( Bobby , 5 ) ;
3089: LD_EXP 16
3093: PPUSH
3094: LD_INT 5
3096: PPUSH
3097: CALL_OW 233
// PlaceUnitXY ( Bobby , 105 , 98 , false ) ;
3101: LD_EXP 16
3105: PPUSH
3106: LD_INT 105
3108: PPUSH
3109: LD_INT 98
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 48
// ComCrawl ( Bobby ) ;
3119: LD_EXP 16
3123: PPUSH
3124: CALL_OW 137
// AddComHold ( Bobby ) ;
3128: LD_EXP 16
3132: PPUSH
3133: CALL_OW 200
// end ; PlaceUnitXY ( Cyrus , 90 , 42 , false ) ;
3137: LD_EXP 17
3141: PPUSH
3142: LD_INT 90
3144: PPUSH
3145: LD_INT 42
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 48
// ComMoveXY ( Cyrus , 79 , 34 ) ;
3155: LD_EXP 17
3159: PPUSH
3160: LD_INT 79
3162: PPUSH
3163: LD_INT 34
3165: PPUSH
3166: CALL_OW 111
// AddComCrawl ( Cyrus ) ;
3170: LD_EXP 17
3174: PPUSH
3175: CALL_OW 197
// end ;
3179: LD_VAR 0 1
3183: RET
// every 0 0$01 trigger active_russian_dialog do var wait_points ;
3184: LD_EXP 3
3188: IFFALSE 3811
3190: GO 3192
3192: DISABLE
3193: LD_INT 0
3195: PPUSH
// begin wait_points := 0 ;
3196: LD_ADDR_VAR 0 1
3200: PUSH
3201: LD_INT 0
3203: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
3204: LD_INT 70
3206: PPUSH
3207: CALL_OW 67
// ComAgressiveMove ( russian_troops_1 , 79 , 83 ) ;
3211: LD_EXP 20
3215: PPUSH
3216: LD_INT 79
3218: PPUSH
3219: LD_INT 83
3221: PPUSH
3222: CALL_OW 114
// Say ( russian_troops_1 [ 2 ] , D1R-Rus1-1 ) ;
3226: LD_EXP 20
3230: PUSH
3231: LD_INT 2
3233: ARRAY
3234: PPUSH
3235: LD_STRING D1R-Rus1-1
3237: PPUSH
3238: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1R-Rus2-1 ) ;
3242: LD_EXP 20
3246: PUSH
3247: LD_INT 1
3249: ARRAY
3250: PPUSH
3251: LD_STRING D1R-Rus2-1
3253: PPUSH
3254: CALL_OW 88
// ComAgressiveMove ( russian_troops_2 , 91 , 80 ) ;
3258: LD_EXP 21
3262: PPUSH
3263: LD_INT 91
3265: PPUSH
3266: LD_INT 80
3268: PPUSH
3269: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3273: LD_INT 35
3275: PPUSH
3276: CALL_OW 67
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 79 , 82 ) < 5 ;
3280: LD_EXP 20
3284: PUSH
3285: LD_INT 1
3287: ARRAY
3288: PPUSH
3289: LD_INT 79
3291: PPUSH
3292: LD_INT 82
3294: PPUSH
3295: CALL_OW 297
3299: PUSH
3300: LD_INT 5
3302: LESS
3303: IFFALSE 3273
// if not IsInArea ( JMM , jmm_spot ) then
3305: LD_EXP 15
3309: PPUSH
3310: LD_INT 5
3312: PPUSH
3313: CALL_OW 308
3317: NOT
3318: IFFALSE 3338
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1 ) else
3320: LD_EXP 20
3324: PUSH
3325: LD_INT 1
3327: ARRAY
3328: PPUSH
3329: LD_STRING D1Ra-Rus2-1
3331: PPUSH
3332: CALL_OW 88
3336: GO 3474
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3338: LD_EXP 20
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PPUSH
3347: LD_STRING D1Rb-Rus1-1
3349: PPUSH
3350: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Rb-Rus2-1 ) ;
3354: LD_EXP 20
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: LD_STRING D1Rb-Rus2-1
3365: PPUSH
3366: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 , GetX ( JMM ) , GetY ( JMM ) ) ;
3370: LD_EXP 20
3374: PUSH
3375: LD_EXP 21
3379: ADD
3380: PPUSH
3381: LD_EXP 15
3385: PPUSH
3386: CALL_OW 250
3390: PPUSH
3391: LD_EXP 15
3395: PPUSH
3396: CALL_OW 251
3400: PPUSH
3401: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3405: LD_INT 35
3407: PPUSH
3408: CALL_OW 67
// until not IsInArea ( JMM , jmm_spot ) and not See ( 3 , jmm ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_INT 5
3419: PPUSH
3420: CALL_OW 308
3424: NOT
3425: PUSH
3426: LD_INT 3
3428: PPUSH
3429: LD_EXP 15
3433: PPUSH
3434: CALL_OW 292
3438: NOT
3439: AND
3440: IFFALSE 3405
// Say ( russian_troops_1 [ 2 ] , D1Rc-Rus1-1 ) ;
3442: LD_EXP 20
3446: PUSH
3447: LD_INT 2
3449: ARRAY
3450: PPUSH
3451: LD_STRING D1Rc-Rus1-1
3453: PPUSH
3454: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1a ) ;
3458: LD_EXP 20
3462: PUSH
3463: LD_INT 1
3465: ARRAY
3466: PPUSH
3467: LD_STRING D1Ra-Rus2-1a
3469: PPUSH
3470: CALL_OW 88
// end ; wait_points := 10 ;
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: LD_INT 10
3481: ST_TO_ADDR
// if Difficulty > 1 then
3482: LD_OWVAR 67
3486: PUSH
3487: LD_INT 1
3489: GREATER
3490: IFFALSE 3572
// begin ComAgressiveMove ( russian_troops_1 , 78 , 95 ) ;
3492: LD_EXP 20
3496: PPUSH
3497: LD_INT 78
3499: PPUSH
3500: LD_INT 95
3502: PPUSH
3503: CALL_OW 114
// AddComWait ( russian_troops_1 , 0 0$05 ) ;
3507: LD_EXP 20
3511: PPUSH
3512: LD_INT 175
3514: PPUSH
3515: CALL_OW 202
// wait_points := wait_points + 15 ;
3519: LD_ADDR_VAR 0 1
3523: PUSH
3524: LD_VAR 0 1
3528: PUSH
3529: LD_INT 15
3531: PLUS
3532: ST_TO_ADDR
// if Difficulty > 2 then
3533: LD_OWVAR 67
3537: PUSH
3538: LD_INT 2
3540: GREATER
3541: IFFALSE 3572
// begin AddComAgressiveMove ( russian_troops_1 , 65 , 79 ) ;
3543: LD_EXP 20
3547: PPUSH
3548: LD_INT 65
3550: PPUSH
3551: LD_INT 79
3553: PPUSH
3554: CALL_OW 174
// wait_points := wait_points + 5 ;
3558: LD_ADDR_VAR 0 1
3562: PUSH
3563: LD_VAR 0 1
3567: PUSH
3568: LD_INT 5
3570: PLUS
3571: ST_TO_ADDR
// end ; end ; repeat wait ( 0 0$01 ) ;
3572: LD_INT 35
3574: PPUSH
3575: CALL_OW 67
// wait_points := wait_points - 1 ;
3579: LD_ADDR_VAR 0 1
3583: PUSH
3584: LD_VAR 0 1
3588: PUSH
3589: LD_INT 1
3591: MINUS
3592: ST_TO_ADDR
// if See ( 3 , JMM ) then
3593: LD_INT 3
3595: PPUSH
3596: LD_EXP 15
3600: PPUSH
3601: CALL_OW 292
3605: IFFALSE 3659
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3607: LD_EXP 20
3611: PUSH
3612: LD_INT 2
3614: ARRAY
3615: PPUSH
3616: LD_STRING D1Rb-Rus1-1
3618: PPUSH
3619: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3623: LD_EXP 20
3627: PPUSH
3628: LD_EXP 15
3632: PPUSH
3633: CALL_OW 250
3637: PPUSH
3638: LD_EXP 15
3642: PPUSH
3643: CALL_OW 251
3647: PPUSH
3648: CALL_OW 114
// Wait ( 0 0$03 ) ;
3652: LD_INT 105
3654: PPUSH
3655: CALL_OW 67
// end ; until wait_points = 0 ;
3659: LD_VAR 0 1
3663: PUSH
3664: LD_INT 0
3666: EQUAL
3667: IFFALSE 3572
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3669: LD_EXP 20
3673: PPUSH
3674: LD_INT 45
3676: PPUSH
3677: LD_INT 5
3679: PPUSH
3680: CALL_OW 114
// ComEnterUnit ( russian_troops_2 , rbar1 ) ;
3684: LD_EXP 21
3688: PPUSH
3689: LD_INT 26
3691: PPUSH
3692: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
3696: LD_INT 35
3698: PPUSH
3699: CALL_OW 67
// if See ( 3 , JMM ) then
3703: LD_INT 3
3705: PPUSH
3706: LD_EXP 15
3710: PPUSH
3711: CALL_OW 292
3715: IFFALSE 3771
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3717: LD_EXP 20
3721: PUSH
3722: LD_INT 2
3724: ARRAY
3725: PPUSH
3726: LD_STRING D1Rb-Rus1-1
3728: PPUSH
3729: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3733: LD_EXP 20
3737: PPUSH
3738: LD_EXP 15
3742: PPUSH
3743: CALL_OW 250
3747: PPUSH
3748: LD_EXP 15
3752: PPUSH
3753: CALL_OW 251
3757: PPUSH
3758: CALL_OW 114
// Wait ( 0 0$50 ) ;
3762: LD_INT 1750
3764: PPUSH
3765: CALL_OW 67
// end else
3769: GO 3786
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3771: LD_EXP 20
3775: PPUSH
3776: LD_INT 45
3778: PPUSH
3779: LD_INT 5
3781: PPUSH
3782: CALL_OW 114
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 45 , 5 ) < 10 ;
3786: LD_EXP 20
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: PPUSH
3795: LD_INT 45
3797: PPUSH
3798: LD_INT 5
3800: PPUSH
3801: CALL_OW 297
3805: PUSH
3806: LD_INT 10
3808: LESS
3809: IFFALSE 3696
// end ;
3811: PPOPN 1
3813: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 6 ] ] ) and Difficulty = 1 do
3814: LD_INT 22
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 92
3826: PUSH
3827: LD_INT 80
3829: PUSH
3830: LD_INT 83
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PPUSH
3846: CALL_OW 69
3850: PUSH
3851: LD_OWVAR 67
3855: PUSH
3856: LD_INT 1
3858: EQUAL
3859: AND
3860: IFFALSE 3941
3862: GO 3864
3864: DISABLE
// begin PlaceSeeing ( 80 , 83 , 1 , - 7 ) ;
3865: LD_INT 80
3867: PPUSH
3868: LD_INT 83
3870: PPUSH
3871: LD_INT 1
3873: PPUSH
3874: LD_INT 7
3876: NEG
3877: PPUSH
3878: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
3882: LD_INT 35
3884: PPUSH
3885: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 10 ] ] ) ;
3889: LD_INT 22
3891: PUSH
3892: LD_INT 3
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PUSH
3899: LD_INT 92
3901: PUSH
3902: LD_INT 80
3904: PUSH
3905: LD_INT 83
3907: PUSH
3908: LD_INT 10
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: PPUSH
3921: CALL_OW 69
3925: NOT
3926: IFFALSE 3882
// RemoveSeeing ( 80 , 83 , 1 ) ;
3928: LD_INT 80
3930: PPUSH
3931: LD_INT 83
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 331
// end ;
3941: END
// every 0 0$02 trigger GetDistUnits ( JMM , Bobby ) < 9 do
3942: LD_EXP 15
3946: PPUSH
3947: LD_EXP 16
3951: PPUSH
3952: CALL_OW 296
3956: PUSH
3957: LD_INT 9
3959: LESS
3960: IFFALSE 4411
3962: GO 3964
3964: DISABLE
// begin ComWalk ( Bobby ) ;
3965: LD_EXP 16
3969: PPUSH
3970: CALL_OW 138
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
3974: LD_EXP 16
3978: PPUSH
3979: LD_EXP 15
3983: PPUSH
3984: CALL_OW 250
3988: PPUSH
3989: LD_EXP 15
3993: PPUSH
3994: CALL_OW 251
3998: PPUSH
3999: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
4003: LD_INT 35
4005: PPUSH
4006: CALL_OW 67
// until See ( 4 , JMM ) ;
4010: LD_INT 4
4012: PPUSH
4013: LD_EXP 15
4017: PPUSH
4018: CALL_OW 292
4022: IFFALSE 4003
// InGameOn ;
4024: CALL_OW 8
// ComTurnUnit ( JMM , Bobby ) ;
4028: LD_EXP 15
4032: PPUSH
4033: LD_EXP 16
4037: PPUSH
4038: CALL_OW 119
// if cyrus_in_squad and IsOk ( Cyrus ) and GetDistUnits ( JMM , Cyrus ) < 10 then
4042: LD_EXP 7
4046: PUSH
4047: LD_EXP 17
4051: PPUSH
4052: CALL_OW 302
4056: AND
4057: PUSH
4058: LD_EXP 15
4062: PPUSH
4063: LD_EXP 17
4067: PPUSH
4068: CALL_OW 296
4072: PUSH
4073: LD_INT 10
4075: LESS
4076: AND
4077: IFFALSE 4122
// begin ComMoveXY ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4079: LD_EXP 17
4083: PPUSH
4084: LD_EXP 15
4088: PPUSH
4089: CALL_OW 250
4093: PPUSH
4094: LD_EXP 15
4098: PPUSH
4099: CALL_OW 251
4103: PPUSH
4104: CALL_OW 111
// AddComTurnUnit ( Cyrus , Bobby ) ;
4108: LD_EXP 17
4112: PPUSH
4113: LD_EXP 16
4117: PPUSH
4118: CALL_OW 179
// end ; Say ( JMM , D2-JMM-1 ) ;
4122: LD_EXP 15
4126: PPUSH
4127: LD_STRING D2-JMM-1
4129: PPUSH
4130: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4134: LD_INT 10
4136: PPUSH
4137: CALL_OW 67
// ComTurnUnit ( Bobby , JMM ) ;
4141: LD_EXP 16
4145: PPUSH
4146: LD_EXP 15
4150: PPUSH
4151: CALL_OW 119
// Say ( Bobby , D2-Bobby-1 ) ;
4155: LD_EXP 16
4159: PPUSH
4160: LD_STRING D2-Bobby-1
4162: PPUSH
4163: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
4167: LD_EXP 15
4171: PPUSH
4172: LD_STRING D2-JMM-2
4174: PPUSH
4175: CALL_OW 88
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4179: LD_EXP 16
4183: PPUSH
4184: LD_EXP 15
4188: PPUSH
4189: CALL_OW 250
4193: PPUSH
4194: LD_EXP 15
4198: PPUSH
4199: CALL_OW 251
4203: PPUSH
4204: CALL_OW 111
// Say ( Bobby , D2-Bobby-2 ) ;
4208: LD_EXP 16
4212: PPUSH
4213: LD_STRING D2-Bobby-2
4215: PPUSH
4216: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
4220: LD_EXP 15
4224: PPUSH
4225: LD_STRING D2-JMM-3
4227: PPUSH
4228: CALL_OW 88
// ComTurnUnit ( Bobby , JMM ) ;
4232: LD_EXP 16
4236: PPUSH
4237: LD_EXP 15
4241: PPUSH
4242: CALL_OW 119
// Say ( Bobby , D2-Bobby-3 ) ;
4246: LD_EXP 16
4250: PPUSH
4251: LD_STRING D2-Bobby-3
4253: PPUSH
4254: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
4258: LD_EXP 15
4262: PPUSH
4263: LD_STRING D2-JMM-4
4265: PPUSH
4266: CALL_OW 88
// Say ( Bobby , D2-Bobby-4 ) ;
4270: LD_EXP 16
4274: PPUSH
4275: LD_STRING D2-Bobby-4
4277: PPUSH
4278: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
4282: LD_EXP 15
4286: PPUSH
4287: LD_STRING D2-JMM-5
4289: PPUSH
4290: CALL_OW 88
// Say ( Bobby , D2-Bobby-5 ) ;
4294: LD_EXP 16
4298: PPUSH
4299: LD_STRING D2-Bobby-5
4301: PPUSH
4302: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
4306: LD_EXP 15
4310: PPUSH
4311: LD_STRING D2-JMM-6
4313: PPUSH
4314: CALL_OW 88
// if not powell_contact then
4318: LD_EXP 5
4322: NOT
4323: IFFALSE 4349
// begin Say ( Bobby , D2-Bobby-6 ) ;
4325: LD_EXP 16
4329: PPUSH
4330: LD_STRING D2-Bobby-6
4332: PPUSH
4333: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4337: LD_EXP 15
4341: PPUSH
4342: LD_STRING D2-JMM-7
4344: PPUSH
4345: CALL_OW 88
// end ; InGameOff ;
4349: CALL_OW 9
// SetSide ( Bobby , 1 ) ;
4353: LD_EXP 16
4357: PPUSH
4358: LD_INT 1
4360: PPUSH
4361: CALL_OW 235
// ComFree ( [ JMM , Bobby ] ) ;
4365: LD_EXP 15
4369: PUSH
4370: LD_EXP 16
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PPUSH
4379: CALL_OW 139
// bobby_in_squad := true ;
4383: LD_ADDR_EXP 4
4387: PUSH
4388: LD_INT 1
4390: ST_TO_ADDR
// if powell_contact and not cyrus_in_squad then
4391: LD_EXP 5
4395: PUSH
4396: LD_EXP 7
4400: NOT
4401: AND
4402: IFFALSE 4411
// ChangeMissionObjectives ( M2b ) ;
4404: LD_STRING M2b
4406: PPUSH
4407: CALL_OW 337
// end ;
4411: END
// every 0 0$45 trigger active_russian_dialog and not bobby_in_squad and Difficulty < 3 do
4412: LD_EXP 3
4416: PUSH
4417: LD_EXP 4
4421: NOT
4422: AND
4423: PUSH
4424: LD_OWVAR 67
4428: PUSH
4429: LD_INT 3
4431: LESS
4432: AND
4433: IFFALSE 4453
4435: GO 4437
4437: DISABLE
// ComMoveXY ( Bobby , 75 , 83 ) ;
4438: LD_EXP 16
4442: PPUSH
4443: LD_INT 75
4445: PPUSH
4446: LD_INT 83
4448: PPUSH
4449: CALL_OW 111
4453: END
// every 0 0$10 trigger cyrus_in_squad and not bobby_in_squad do
4454: LD_EXP 7
4458: PUSH
4459: LD_EXP 4
4463: NOT
4464: AND
4465: IFFALSE 4494
4467: GO 4469
4469: DISABLE
// begin ComMoveXY ( Bobby , 105 , 97 ) ;
4470: LD_EXP 16
4474: PPUSH
4475: LD_INT 105
4477: PPUSH
4478: LD_INT 97
4480: PPUSH
4481: CALL_OW 111
// AddComCrawl ( Bobby ) ;
4485: LD_EXP 16
4489: PPUSH
4490: CALL_OW 197
// end ;
4494: END
// every 0 0$01 trigger IsInArea ( JMM , obstacle_area ) and GetDistUnits ( JMM , Bobby ) < 7 and bobby_in_squad do
4495: LD_EXP 15
4499: PPUSH
4500: LD_INT 6
4502: PPUSH
4503: CALL_OW 308
4507: PUSH
4508: LD_EXP 15
4512: PPUSH
4513: LD_EXP 16
4517: PPUSH
4518: CALL_OW 296
4522: PUSH
4523: LD_INT 7
4525: LESS
4526: AND
4527: PUSH
4528: LD_EXP 4
4532: AND
4533: IFFALSE 4580
4535: GO 4537
4537: DISABLE
// begin ComHold ( [ JMM , Bobby ] ) ;
4538: LD_EXP 15
4542: PUSH
4543: LD_EXP 16
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: PPUSH
4552: CALL_OW 140
// Say ( JMM , D2a-JMM-1 ) ;
4556: LD_EXP 15
4560: PPUSH
4561: LD_STRING D2a-JMM-1
4563: PPUSH
4564: CALL_OW 88
// Say ( Bobby , D2a-Bobby-1 ) ;
4568: LD_EXP 16
4572: PPUSH
4573: LD_STRING D2a-Bobby-1
4575: PPUSH
4576: CALL_OW 88
// end ;
4580: END
// every 0 0$50 trigger active_russian_dialog and not See ( 3 , JMM ) do
4581: LD_EXP 3
4585: PUSH
4586: LD_INT 3
4588: PPUSH
4589: LD_EXP 15
4593: PPUSH
4594: CALL_OW 292
4598: NOT
4599: AND
4600: IFFALSE 4776
4602: GO 4604
4604: DISABLE
// begin Wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
4605: LD_INT 350
4607: PPUSH
4608: LD_INT 700
4610: PPUSH
4611: CALL_OW 12
4615: PPUSH
4616: CALL_OW 67
// InGameOn ;
4620: CALL_OW 8
// DialogueOn ;
4624: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4628: LD_EXP 18
4632: PPUSH
4633: LD_STRING D3-Pow-1
4635: PPUSH
4636: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
4640: LD_EXP 15
4644: PPUSH
4645: LD_STRING D3-JMM-1
4647: PPUSH
4648: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4652: LD_EXP 18
4656: PPUSH
4657: LD_STRING D3-Pow-2
4659: PPUSH
4660: CALL_OW 94
// Say ( JMM , D3-JMM-2 ) ;
4664: LD_EXP 15
4668: PPUSH
4669: LD_STRING D3-JMM-2
4671: PPUSH
4672: CALL_OW 88
// SayRadio ( Powell , D3-Pow-3 ) ;
4676: LD_EXP 18
4680: PPUSH
4681: LD_STRING D3-Pow-3
4683: PPUSH
4684: CALL_OW 94
// DialogueOff ;
4688: CALL_OW 7
// InGameOff ;
4692: CALL_OW 9
// powell_contact := true ;
4696: LD_ADDR_EXP 5
4700: PUSH
4701: LD_INT 1
4703: ST_TO_ADDR
// SetAreaMapShow ( exitArea , 1 ) ;
4704: LD_INT 10
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 424
// uc_side := 4 ;
4714: LD_ADDR_OWVAR 20
4718: PUSH
4719: LD_INT 4
4721: ST_TO_ADDR
// uc_nation := 1 ;
4722: LD_ADDR_OWVAR 21
4726: PUSH
4727: LD_INT 1
4729: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
4730: LD_ADDR_EXP 18
4734: PUSH
4735: LD_STRING Powell
4737: PPUSH
4738: LD_INT 0
4740: PPUSH
4741: CALL 189 0 2
4745: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
4746: LD_STRING M2
4748: PPUSH
4749: CALL_OW 337
// if not bobby_in_squad then
4753: LD_EXP 4
4757: NOT
4758: IFFALSE 4769
// ChangeMissionObjectives ( M2a ) else
4760: LD_STRING M2a
4762: PPUSH
4763: CALL_OW 337
4767: GO 4776
// ChangeMissionObjectives ( M2b ) ;
4769: LD_STRING M2b
4771: PPUSH
4772: CALL_OW 337
// end ;
4776: END
// every 0 0$01 trigger IsInArea ( JMM , fakeArea ) do
4777: LD_EXP 15
4781: PPUSH
4782: LD_INT 7
4784: PPUSH
4785: CALL_OW 308
4789: IFFALSE 4924
4791: GO 4793
4793: DISABLE
// begin DialogueOn ;
4794: CALL_OW 6
// SayRadio ( fakePokryshkin , D4-Rus3-1 ) ;
4798: LD_EXP 19
4802: PPUSH
4803: LD_STRING D4-Rus3-1
4805: PPUSH
4806: CALL_OW 94
// DialogueOff ;
4810: CALL_OW 7
// ChangeMissionObjectives ( M3a ) ;
4814: LD_STRING M3a
4816: PPUSH
4817: CALL_OW 337
// SetAreaMapShow ( fakeEnd , 1 ) ;
4821: LD_INT 11
4823: PPUSH
4824: LD_INT 1
4826: PPUSH
4827: CALL_OW 424
// Wait ( 0 0$02 ) ;
4831: LD_INT 70
4833: PPUSH
4834: CALL_OW 67
// DialogueOn ;
4838: CALL_OW 6
// SayRadio ( Powell , D4-Pow-1 ) ;
4842: LD_EXP 18
4846: PPUSH
4847: LD_STRING D4-Pow-1
4849: PPUSH
4850: CALL_OW 94
// DialogueOff ;
4854: CALL_OW 7
// ChangeMissionObjectives ( M3b ) ;
4858: LD_STRING M3b
4860: PPUSH
4861: CALL_OW 337
// case Query ( Q1 ) of 1 :
4865: LD_STRING Q1
4867: PPUSH
4868: CALL_OW 97
4872: PUSH
4873: LD_INT 1
4875: DOUBLE
4876: EQUAL
4877: IFTRUE 4881
4879: GO 4912
4881: POP
// begin macmilan_use_radio := true ;
4882: LD_ADDR_EXP 6
4886: PUSH
4887: LD_INT 1
4889: ST_TO_ADDR
// DialogueOn ;
4890: CALL_OW 6
// Say ( JMM , D4a-JMM-1 ) ;
4894: LD_EXP 15
4898: PPUSH
4899: LD_STRING D4a-JMM-1
4901: PPUSH
4902: CALL_OW 88
// DialogueOff ;
4906: CALL_OW 7
// end ; 2 :
4910: GO 4924
4912: LD_INT 2
4914: DOUBLE
4915: EQUAL
4916: IFTRUE 4920
4918: GO 4923
4920: POP
// ; end ;
4921: GO 4924
4923: POP
// end ;
4924: END
// every 0 0$02 trigger GetDistUnits ( JMM , Cyrus ) < 8 do
4925: LD_EXP 15
4929: PPUSH
4930: LD_EXP 17
4934: PPUSH
4935: CALL_OW 296
4939: PUSH
4940: LD_INT 8
4942: LESS
4943: IFFALSE 5234
4945: GO 4947
4947: DISABLE
// begin InGameOn ;
4948: CALL_OW 8
// ComMoveXY ( JMM , GetX ( Cyrus ) , GetY ( Cyrus ) ) ;
4952: LD_EXP 15
4956: PPUSH
4957: LD_EXP 17
4961: PPUSH
4962: CALL_OW 250
4966: PPUSH
4967: LD_EXP 17
4971: PPUSH
4972: CALL_OW 251
4976: PPUSH
4977: CALL_OW 111
// if IsOk ( Bobby ) and bobby_in_squad then
4981: LD_EXP 16
4985: PPUSH
4986: CALL_OW 302
4990: PUSH
4991: LD_EXP 4
4995: AND
4996: IFFALSE 5027
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4998: LD_EXP 16
5002: PPUSH
5003: LD_EXP 15
5007: PPUSH
5008: CALL_OW 250
5012: PPUSH
5013: LD_EXP 15
5017: PPUSH
5018: CALL_OW 251
5022: PPUSH
5023: CALL_OW 111
// Say ( JMM , D5-JMM-1 ) ;
5027: LD_EXP 15
5031: PPUSH
5032: LD_STRING D5-JMM-1
5034: PPUSH
5035: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5039: LD_INT 10
5041: PPUSH
5042: CALL_OW 67
// ComTurnUnit ( JMM , Cyrus ) ;
5046: LD_EXP 15
5050: PPUSH
5051: LD_EXP 17
5055: PPUSH
5056: CALL_OW 119
// ComWalk ( Cyrus ) ;
5060: LD_EXP 17
5064: PPUSH
5065: CALL_OW 138
// ComTurnUnit ( Cyrus , JMM ) ;
5069: LD_EXP 17
5073: PPUSH
5074: LD_EXP 15
5078: PPUSH
5079: CALL_OW 119
// Say ( Cyrus , D5-Cyrus-1 ) ;
5083: LD_EXP 17
5087: PPUSH
5088: LD_STRING D5-Cyrus-1
5090: PPUSH
5091: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5095: LD_EXP 16
5099: PPUSH
5100: CALL_OW 302
5104: PUSH
5105: LD_EXP 4
5109: AND
5110: IFFALSE 5150
// begin ComTurnUnit ( Bobby , Cyrus ) ;
5112: LD_EXP 16
5116: PPUSH
5117: LD_EXP 17
5121: PPUSH
5122: CALL_OW 119
// Say ( Bobby , D5-Bobby-1 ) ;
5126: LD_EXP 16
5130: PPUSH
5131: LD_STRING D5-Bobby-1
5133: PPUSH
5134: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
5138: LD_EXP 15
5142: PPUSH
5143: LD_STRING D5-JMM-2
5145: PPUSH
5146: CALL_OW 88
// end ; InGameOff ;
5150: CALL_OW 9
// cyrus_in_squad := true ;
5154: LD_ADDR_EXP 7
5158: PUSH
5159: LD_INT 1
5161: ST_TO_ADDR
// SetSide ( Cyrus , 1 ) ;
5162: LD_EXP 17
5166: PPUSH
5167: LD_INT 1
5169: PPUSH
5170: CALL_OW 235
// if powell_contact and not bobby_in_squad then
5174: LD_EXP 5
5178: PUSH
5179: LD_EXP 4
5183: NOT
5184: AND
5185: IFFALSE 5194
// ChangeMissionObjectives ( M2b ) ;
5187: LD_STRING M2b
5189: PPUSH
5190: CALL_OW 337
// if not bobby_in_squad and GetSide ( Bobby ) = 4 and IsOk ( Bobby ) then
5194: LD_EXP 4
5198: NOT
5199: PUSH
5200: LD_EXP 16
5204: PPUSH
5205: CALL_OW 255
5209: PUSH
5210: LD_INT 4
5212: EQUAL
5213: AND
5214: PUSH
5215: LD_EXP 16
5219: PPUSH
5220: CALL_OW 302
5224: AND
5225: IFFALSE 5234
// SetAchievement ( ACH_CYRUS ) ;
5227: LD_STRING ACH_CYRUS
5229: PPUSH
5230: CALL_OW 543
// end ;
5234: END
// every 0 0$01 trigger bobby_in_squad and cyrus_in_squad do
5235: LD_EXP 4
5239: PUSH
5240: LD_EXP 7
5244: AND
5245: IFFALSE 5257
5247: GO 5249
5249: DISABLE
// ChangeMissionObjectives ( M2c ) ;
5250: LD_STRING M2c
5252: PPUSH
5253: CALL_OW 337
5257: END
// every 0 0$01 trigger IsInArea ( JMM , trap ) do
5258: LD_EXP 15
5262: PPUSH
5263: LD_INT 8
5265: PPUSH
5266: CALL_OW 308
5270: IFFALSE 5322
5272: GO 5274
5274: DISABLE
// begin macmilan_in_trap := true ;
5275: LD_ADDR_EXP 9
5279: PUSH
5280: LD_INT 1
5282: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5283: LD_INT 35
5285: PPUSH
5286: CALL_OW 67
// DialogueOn ;
5290: CALL_OW 6
// Say ( Pokryshkin , D5-Pok-1 ) ;
5294: LD_EXP 25
5298: PPUSH
5299: LD_STRING D5-Pok-1
5301: PPUSH
5302: CALL_OW 88
// DialogueOff ;
5306: CALL_OW 7
// Say ( JMM , D4b-JMM-1 ) ;
5310: LD_EXP 15
5314: PPUSH
5315: LD_STRING D4b-JMM-1
5317: PPUSH
5318: CALL_OW 88
// end ;
5322: END
// every 0 0$01 trigger GetDistUnits ( JMM , russian_meta_guards [ russian_meta_guards ] ) < 12 or UnitFilter ( russian_meta_guards , [ f_not , [ f_lives , 990 ] ] ) do var i , hp ;
5323: LD_EXP 15
5327: PPUSH
5328: LD_EXP 23
5332: PUSH
5333: LD_EXP 23
5337: ARRAY
5338: PPUSH
5339: CALL_OW 296
5343: PUSH
5344: LD_INT 12
5346: LESS
5347: PUSH
5348: LD_EXP 23
5352: PPUSH
5353: LD_INT 3
5355: PUSH
5356: LD_INT 24
5358: PUSH
5359: LD_INT 990
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PPUSH
5370: CALL_OW 72
5374: OR
5375: IFFALSE 5605
5377: GO 5379
5379: DISABLE
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
// begin hp := [ 300 , 250 , 200 ] [ Difficulty ] ;
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_INT 300
5391: PUSH
5392: LD_INT 250
5394: PUSH
5395: LD_INT 200
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: LIST
5402: PUSH
5403: LD_OWVAR 67
5407: ARRAY
5408: ST_TO_ADDR
// for i in russian_meta_guards do
5409: LD_ADDR_VAR 0 1
5413: PUSH
5414: LD_EXP 23
5418: PUSH
5419: FOR_IN
5420: IFFALSE 5460
// if IsOk ( i ) then
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 302
5431: IFFALSE 5458
// SetLives ( i , GetLives ( i ) - hp ) ;
5433: LD_VAR 0 1
5437: PPUSH
5438: LD_VAR 0 1
5442: PPUSH
5443: CALL_OW 256
5447: PUSH
5448: LD_VAR 0 2
5452: MINUS
5453: PPUSH
5454: CALL_OW 234
5458: GO 5419
5460: POP
5461: POP
// DialogueOn ;
5462: CALL_OW 6
// Say ( russian_meta_guards [ russian_meta_guards ] , D6-FRus1-1 ) ;
5466: LD_EXP 23
5470: PUSH
5471: LD_EXP 23
5475: ARRAY
5476: PPUSH
5477: LD_STRING D6-FRus1-1
5479: PPUSH
5480: CALL_OW 88
// Say ( JMM , D6-JMM-1 ) ;
5484: LD_EXP 15
5488: PPUSH
5489: LD_STRING D6-JMM-1
5491: PPUSH
5492: CALL_OW 88
// if IsOk ( Cyrus ) and cyrus_in_squad then
5496: LD_EXP 17
5500: PPUSH
5501: CALL_OW 302
5505: PUSH
5506: LD_EXP 7
5510: AND
5511: IFFALSE 5525
// Say ( Cyrus , D6-Cyrus-1 ) ;
5513: LD_EXP 17
5517: PPUSH
5518: LD_STRING D6-Cyrus-1
5520: PPUSH
5521: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5525: LD_EXP 16
5529: PPUSH
5530: CALL_OW 302
5534: PUSH
5535: LD_EXP 4
5539: AND
5540: IFFALSE 5554
// Say ( Bobby , D6-Bobby-1 ) ;
5542: LD_EXP 16
5546: PPUSH
5547: LD_STRING D6-Bobby-1
5549: PPUSH
5550: CALL_OW 88
// DialogueOff ;
5554: CALL_OW 7
// Wait ( [ 0 0$04 , 0 0$03 , 0 0$02 ] [ Difficulty ] ) ;
5558: LD_INT 140
5560: PUSH
5561: LD_INT 105
5563: PUSH
5564: LD_INT 70
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: LD_OWVAR 67
5576: ARRAY
5577: PPUSH
5578: CALL_OW 67
// meta_action := true ;
5582: LD_ADDR_EXP 10
5586: PUSH
5587: LD_INT 1
5589: ST_TO_ADDR
// ComAgressiveMove ( russian_meta_guards , 94 , 8 ) ;
5590: LD_EXP 23
5594: PPUSH
5595: LD_INT 94
5597: PPUSH
5598: LD_INT 8
5600: PPUSH
5601: CALL_OW 114
// end ;
5605: PPOPN 2
5607: END
// every 0 0$01 trigger GetDistUnitXY ( JMM , 93 , 1 ) < 5 and FilterAllUnits ( [ f_side , 1 ] ) > 1 do
5608: LD_EXP 15
5612: PPUSH
5613: LD_INT 93
5615: PPUSH
5616: LD_INT 1
5618: PPUSH
5619: CALL_OW 297
5623: PUSH
5624: LD_INT 5
5626: LESS
5627: PUSH
5628: LD_INT 22
5630: PUSH
5631: LD_INT 1
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: PPUSH
5638: CALL_OW 69
5642: PUSH
5643: LD_INT 1
5645: GREATER
5646: AND
5647: IFFALSE 5664
5649: GO 5651
5651: DISABLE
// Say ( JMM , D6a-JMM-1 ) ;
5652: LD_EXP 15
5656: PPUSH
5657: LD_STRING D6a-JMM-1
5659: PPUSH
5660: CALL_OW 88
5664: END
// on UnitGoesToRed ( un ) do begin if un = JMM then
5665: LD_VAR 0 1
5669: PUSH
5670: LD_EXP 15
5674: EQUAL
5675: IFFALSE 5684
// YouLost ( JMM ) ;
5677: LD_STRING JMM
5679: PPUSH
5680: CALL_OW 104
// end ;
5684: PPOPN 1
5686: END
// on UnitDestroyed ( un ) do begin if un = JMM then
5687: LD_VAR 0 1
5691: PUSH
5692: LD_EXP 15
5696: EQUAL
5697: IFFALSE 5706
// YouLost ( JMM ) ;
5699: LD_STRING JMM
5701: PPUSH
5702: CALL_OW 104
// end ;
5706: PPOPN 1
5708: END
// every 0 0$01 trigger IsInArea ( Bobby , exitArea ) do
5709: LD_EXP 16
5713: PPUSH
5714: LD_INT 10
5716: PPUSH
5717: CALL_OW 308
5721: IFFALSE 5770
5723: GO 5725
5725: DISABLE
// begin bobby_saved := true ;
5726: LD_ADDR_EXP 12
5730: PUSH
5731: LD_INT 1
5733: ST_TO_ADDR
// SaveVariable ( GetLives ( Bobby ) , 01_BobbyLifePoints_1 ) ;
5734: LD_EXP 16
5738: PPUSH
5739: CALL_OW 256
5743: PPUSH
5744: LD_STRING 01_BobbyLifePoints_1
5746: PPUSH
5747: CALL_OW 39
// RemoveUnit ( Bobby ) ;
5751: LD_EXP 16
5755: PPUSH
5756: CALL_OW 64
// AddMedal ( Bobby , 1 ) ;
5760: LD_STRING Bobby
5762: PPUSH
5763: LD_INT 1
5765: PPUSH
5766: CALL_OW 101
// end ;
5770: END
// every 0 0$01 trigger IsInArea ( Cyrus , exitArea ) do
5771: LD_EXP 17
5775: PPUSH
5776: LD_INT 10
5778: PPUSH
5779: CALL_OW 308
5783: IFFALSE 5832
5785: GO 5787
5787: DISABLE
// begin cyrus_saved := true ;
5788: LD_ADDR_EXP 13
5792: PUSH
5793: LD_INT 1
5795: ST_TO_ADDR
// SaveVariable ( GetLives ( Cyrus ) , 01_CyrusLifePoints_1 ) ;
5796: LD_EXP 17
5800: PPUSH
5801: CALL_OW 256
5805: PPUSH
5806: LD_STRING 01_CyrusLifePoints_1
5808: PPUSH
5809: CALL_OW 39
// RemoveUnit ( Cyrus ) ;
5813: LD_EXP 17
5817: PPUSH
5818: CALL_OW 64
// AddMedal ( Cyrus , 1 ) ;
5822: LD_STRING Cyrus
5824: PPUSH
5825: LD_INT 1
5827: PPUSH
5828: CALL_OW 101
// end ;
5832: END
// every 0 0$01 trigger IsInArea ( JMM , exitArea ) do var i , to_reward , wait_for_them , m1 , m2 , m3 ;
5833: LD_EXP 15
5837: PPUSH
5838: LD_INT 10
5840: PPUSH
5841: CALL_OW 308
5845: IFFALSE 6453
5847: GO 5849
5849: DISABLE
5850: LD_INT 0
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
// begin if macmilan_use_radio then
5858: LD_EXP 6
5862: IFFALSE 5871
// SetAchievement ( ACH_RADIO ) ;
5864: LD_STRING ACH_RADIO
5866: PPUSH
5867: CALL_OW 543
// if ( not cyrus_saved and cyrus_in_squad and IsOk ( Cyrus ) ) or ( not bobby_saved and bobby_in_squad and IsOk ( Bobby ) ) then
5871: LD_EXP 13
5875: NOT
5876: PUSH
5877: LD_EXP 7
5881: AND
5882: PUSH
5883: LD_EXP 17
5887: PPUSH
5888: CALL_OW 302
5892: AND
5893: PUSH
5894: LD_EXP 12
5898: NOT
5899: PUSH
5900: LD_EXP 4
5904: AND
5905: PUSH
5906: LD_EXP 16
5910: PPUSH
5911: CALL_OW 302
5915: AND
5916: OR
5917: IFFALSE 5958
// case Query ( Q2 ) of 1 :
5919: LD_STRING Q2
5921: PPUSH
5922: CALL_OW 97
5926: PUSH
5927: LD_INT 1
5929: DOUBLE
5930: EQUAL
5931: IFTRUE 5935
5933: GO 5946
5935: POP
// wait_for_them := true ; 2 :
5936: LD_ADDR_VAR 0 3
5940: PUSH
5941: LD_INT 1
5943: ST_TO_ADDR
5944: GO 5958
5946: LD_INT 2
5948: DOUBLE
5949: EQUAL
5950: IFTRUE 5954
5952: GO 5957
5954: POP
// ; end ;
5955: GO 5958
5957: POP
// if wait_for_them then
5958: LD_VAR 0 3
5962: IFFALSE 6075
// repeat wait ( 0 0$01 ) ;
5964: LD_INT 35
5966: PPUSH
5967: CALL_OW 67
// until ( cyrus_saved and bobby_saved ) or ( cyrus_saved and ( not bobby_in_squad or IsDying ( Bobby ) or IsDead ( Bobby ) ) ) or ( bobby_saved and ( not cyrus_in_squad or IsDying ( Cyrus ) or IsDead ( Cyrus ) ) ) or ( IsDead ( Bobby ) and IsDead ( Cyrus ) ) ;
5971: LD_EXP 13
5975: PUSH
5976: LD_EXP 12
5980: AND
5981: PUSH
5982: LD_EXP 13
5986: PUSH
5987: LD_EXP 4
5991: NOT
5992: PUSH
5993: LD_EXP 16
5997: PPUSH
5998: CALL_OW 303
6002: OR
6003: PUSH
6004: LD_EXP 16
6008: PPUSH
6009: CALL_OW 301
6013: OR
6014: AND
6015: OR
6016: PUSH
6017: LD_EXP 12
6021: PUSH
6022: LD_EXP 7
6026: NOT
6027: PUSH
6028: LD_EXP 17
6032: PPUSH
6033: CALL_OW 303
6037: OR
6038: PUSH
6039: LD_EXP 17
6043: PPUSH
6044: CALL_OW 301
6048: OR
6049: AND
6050: OR
6051: PUSH
6052: LD_EXP 16
6056: PPUSH
6057: CALL_OW 301
6061: PUSH
6062: LD_EXP 17
6066: PPUSH
6067: CALL_OW 301
6071: AND
6072: OR
6073: IFFALSE 5964
// SaveVariable ( GetLives ( JMM ) , 01_JMMLifePoints_1 ) ;
6075: LD_EXP 15
6079: PPUSH
6080: CALL_OW 256
6084: PPUSH
6085: LD_STRING 01_JMMLifePoints_1
6087: PPUSH
6088: CALL_OW 39
// RemoveUnit ( JMM ) ;
6092: LD_EXP 15
6096: PPUSH
6097: CALL_OW 64
// to_reward := [ JMM ] ;
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_EXP 15
6110: PUSH
6111: EMPTY
6112: LIST
6113: ST_TO_ADDR
// if bobby_saved then
6114: LD_EXP 12
6118: IFFALSE 6136
// to_reward := to_reward ^ Bobby ;
6120: LD_ADDR_VAR 0 2
6124: PUSH
6125: LD_VAR 0 2
6129: PUSH
6130: LD_EXP 16
6134: ADD
6135: ST_TO_ADDR
// if cyrus_saved then
6136: LD_EXP 13
6140: IFFALSE 6158
// to_reward := to_reward ^ Cyrus ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_EXP 17
6156: ADD
6157: ST_TO_ADDR
// m1 := true ;
6158: LD_ADDR_VAR 0 4
6162: PUSH
6163: LD_INT 1
6165: ST_TO_ADDR
// m2 := bobby_saved ;
6166: LD_ADDR_VAR 0 5
6170: PUSH
6171: LD_EXP 12
6175: ST_TO_ADDR
// m3 := cyrus_saved ;
6176: LD_ADDR_VAR 0 6
6180: PUSH
6181: LD_EXP 13
6185: ST_TO_ADDR
// AddMedal ( JMM , 1 ) ;
6186: LD_STRING JMM
6188: PPUSH
6189: LD_INT 1
6191: PPUSH
6192: CALL_OW 101
// if not bobby_in_squad then
6196: LD_EXP 4
6200: NOT
6201: IFFALSE 6214
// AddMedal ( Bobby , - 1 ) ;
6203: LD_STRING Bobby
6205: PPUSH
6206: LD_INT 1
6208: NEG
6209: PPUSH
6210: CALL_OW 101
// if not bobby_saved and ( IsDying ( Bobby ) or IsDead ( Bobby ) ) then
6214: LD_EXP 12
6218: NOT
6219: PUSH
6220: LD_EXP 16
6224: PPUSH
6225: CALL_OW 303
6229: PUSH
6230: LD_EXP 16
6234: PPUSH
6235: CALL_OW 301
6239: OR
6240: AND
6241: IFFALSE 6254
// AddMedal ( Bobby , - 2 ) ;
6243: LD_STRING Bobby
6245: PPUSH
6246: LD_INT 2
6248: NEG
6249: PPUSH
6250: CALL_OW 101
// if not cyrus_in_squad then
6254: LD_EXP 7
6258: NOT
6259: IFFALSE 6272
// AddMedal ( Cyrus , - 1 ) ;
6261: LD_STRING Cyrus
6263: PPUSH
6264: LD_INT 1
6266: NEG
6267: PPUSH
6268: CALL_OW 101
// if not cyrus_saved and ( IsDying ( Cyrus ) or IsDead ( Cyrus ) ) then
6272: LD_EXP 13
6276: NOT
6277: PUSH
6278: LD_EXP 17
6282: PPUSH
6283: CALL_OW 303
6287: PUSH
6288: LD_EXP 17
6292: PPUSH
6293: CALL_OW 301
6297: OR
6298: AND
6299: IFFALSE 6312
// AddMedal ( Cyrus , - 2 ) ;
6301: LD_STRING Cyrus
6303: PPUSH
6304: LD_INT 2
6306: NEG
6307: PPUSH
6308: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
6312: LD_OWVAR 67
6316: PUSH
6317: LD_INT 3
6319: EQUAL
6320: PUSH
6321: LD_VAR 0 4
6325: AND
6326: PUSH
6327: LD_VAR 0 5
6331: AND
6332: PUSH
6333: LD_VAR 0 6
6337: AND
6338: IFFALSE 6350
// SetAchievementEX ( ACH_AMER , 1 ) ;
6340: LD_STRING ACH_AMER
6342: PPUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL_OW 564
// GiveMedals ( MAIN ) ;
6350: LD_STRING MAIN
6352: PPUSH
6353: CALL_OW 102
// RewardPeople ( to_reward ) ;
6357: LD_VAR 0 2
6361: PPUSH
6362: CALL_OW 43
// if bobby_saved then
6366: LD_EXP 12
6370: IFFALSE 6390
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
6372: LD_EXP 16
6376: PPUSH
6377: LD_EXP 2
6381: PUSH
6382: LD_STRING Bobby
6384: STR
6385: PPUSH
6386: CALL_OW 38
// if cyrus_saved then
6390: LD_EXP 13
6394: IFFALSE 6414
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
6396: LD_EXP 17
6400: PPUSH
6401: LD_EXP 2
6405: PUSH
6406: LD_STRING Cyrus
6408: STR
6409: PPUSH
6410: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
6414: LD_EXP 15
6418: PPUSH
6419: LD_EXP 2
6423: PUSH
6424: LD_STRING JMM
6426: STR
6427: PPUSH
6428: CALL_OW 38
// if tick <= 3 3$00 then
6432: LD_OWVAR 1
6436: PUSH
6437: LD_INT 6300
6439: LESSEQUAL
6440: IFFALSE 6449
// SetAchievement ( ACH_ASPEED_1 ) ;
6442: LD_STRING ACH_ASPEED_1
6444: PPUSH
6445: CALL_OW 543
// YouWin ;
6449: CALL_OW 103
// end ; end_of_file end_of_file
6453: PPOPN 6
6455: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
6456: GO 6458
6458: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6459: LD_STRING initStreamRollete();
6461: PPUSH
6462: CALL_OW 559
// InitStreamMode ;
6466: CALL 6471 0 0
// end ;
6470: END
// function InitStreamMode ; begin
6471: LD_INT 0
6473: PPUSH
// streamModeActive := false ;
6474: LD_ADDR_EXP 26
6478: PUSH
6479: LD_INT 0
6481: ST_TO_ADDR
// sRocket := false ;
6482: LD_ADDR_EXP 29
6486: PUSH
6487: LD_INT 0
6489: ST_TO_ADDR
// sSpeed := false ;
6490: LD_ADDR_EXP 28
6494: PUSH
6495: LD_INT 0
6497: ST_TO_ADDR
// sEngine := false ;
6498: LD_ADDR_EXP 30
6502: PUSH
6503: LD_INT 0
6505: ST_TO_ADDR
// sSpec := false ;
6506: LD_ADDR_EXP 27
6510: PUSH
6511: LD_INT 0
6513: ST_TO_ADDR
// sLevel := false ;
6514: LD_ADDR_EXP 31
6518: PUSH
6519: LD_INT 0
6521: ST_TO_ADDR
// sArmoury := false ;
6522: LD_ADDR_EXP 32
6526: PUSH
6527: LD_INT 0
6529: ST_TO_ADDR
// sRadar := false ;
6530: LD_ADDR_EXP 33
6534: PUSH
6535: LD_INT 0
6537: ST_TO_ADDR
// sBunker := false ;
6538: LD_ADDR_EXP 34
6542: PUSH
6543: LD_INT 0
6545: ST_TO_ADDR
// sHack := false ;
6546: LD_ADDR_EXP 35
6550: PUSH
6551: LD_INT 0
6553: ST_TO_ADDR
// sFire := false ;
6554: LD_ADDR_EXP 36
6558: PUSH
6559: LD_INT 0
6561: ST_TO_ADDR
// sRefresh := false ;
6562: LD_ADDR_EXP 37
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// sExp := false ;
6570: LD_ADDR_EXP 38
6574: PUSH
6575: LD_INT 0
6577: ST_TO_ADDR
// sDepot := false ;
6578: LD_ADDR_EXP 39
6582: PUSH
6583: LD_INT 0
6585: ST_TO_ADDR
// sFlag := false ;
6586: LD_ADDR_EXP 40
6590: PUSH
6591: LD_INT 0
6593: ST_TO_ADDR
// sKamikadze := false ;
6594: LD_ADDR_EXP 48
6598: PUSH
6599: LD_INT 0
6601: ST_TO_ADDR
// sTroll := false ;
6602: LD_ADDR_EXP 49
6606: PUSH
6607: LD_INT 0
6609: ST_TO_ADDR
// sSlow := false ;
6610: LD_ADDR_EXP 50
6614: PUSH
6615: LD_INT 0
6617: ST_TO_ADDR
// sLack := false ;
6618: LD_ADDR_EXP 51
6622: PUSH
6623: LD_INT 0
6625: ST_TO_ADDR
// sTank := false ;
6626: LD_ADDR_EXP 53
6630: PUSH
6631: LD_INT 0
6633: ST_TO_ADDR
// sRemote := false ;
6634: LD_ADDR_EXP 54
6638: PUSH
6639: LD_INT 0
6641: ST_TO_ADDR
// sPowell := false ;
6642: LD_ADDR_EXP 55
6646: PUSH
6647: LD_INT 0
6649: ST_TO_ADDR
// sTeleport := false ;
6650: LD_ADDR_EXP 58
6654: PUSH
6655: LD_INT 0
6657: ST_TO_ADDR
// sOilTower := false ;
6658: LD_ADDR_EXP 60
6662: PUSH
6663: LD_INT 0
6665: ST_TO_ADDR
// sShovel := false ;
6666: LD_ADDR_EXP 61
6670: PUSH
6671: LD_INT 0
6673: ST_TO_ADDR
// sSheik := false ;
6674: LD_ADDR_EXP 62
6678: PUSH
6679: LD_INT 0
6681: ST_TO_ADDR
// sSold := false ;
6682: LD_ADDR_EXP 41
6686: PUSH
6687: LD_INT 0
6689: ST_TO_ADDR
// sDiff := false ;
6690: LD_ADDR_EXP 42
6694: PUSH
6695: LD_INT 0
6697: ST_TO_ADDR
// sFog := false ;
6698: LD_ADDR_EXP 45
6702: PUSH
6703: LD_INT 0
6705: ST_TO_ADDR
// sReset := false ;
6706: LD_ADDR_EXP 46
6710: PUSH
6711: LD_INT 0
6713: ST_TO_ADDR
// sSun := false ;
6714: LD_ADDR_EXP 47
6718: PUSH
6719: LD_INT 0
6721: ST_TO_ADDR
// sTiger := false ;
6722: LD_ADDR_EXP 43
6726: PUSH
6727: LD_INT 0
6729: ST_TO_ADDR
// sBomb := false ;
6730: LD_ADDR_EXP 44
6734: PUSH
6735: LD_INT 0
6737: ST_TO_ADDR
// sWound := false ;
6738: LD_ADDR_EXP 52
6742: PUSH
6743: LD_INT 0
6745: ST_TO_ADDR
// sBetray := false ;
6746: LD_ADDR_EXP 56
6750: PUSH
6751: LD_INT 0
6753: ST_TO_ADDR
// sContamin := false ;
6754: LD_ADDR_EXP 57
6758: PUSH
6759: LD_INT 0
6761: ST_TO_ADDR
// sOil := false ;
6762: LD_ADDR_EXP 59
6766: PUSH
6767: LD_INT 0
6769: ST_TO_ADDR
// sStu := false ;
6770: LD_ADDR_EXP 63
6774: PUSH
6775: LD_INT 0
6777: ST_TO_ADDR
// end ;
6778: LD_VAR 0 1
6782: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 100
6790: EQUAL
6791: IFFALSE 7488
// begin if not StreamModeActive then
6793: LD_EXP 26
6797: NOT
6798: IFFALSE 6808
// StreamModeActive := true ;
6800: LD_ADDR_EXP 26
6804: PUSH
6805: LD_INT 1
6807: ST_TO_ADDR
// if p3 = 0 then
6808: LD_VAR 0 3
6812: PUSH
6813: LD_INT 0
6815: EQUAL
6816: IFFALSE 6822
// InitStreamMode ;
6818: CALL 6471 0 0
// if p3 = 1 then
6822: LD_VAR 0 3
6826: PUSH
6827: LD_INT 1
6829: EQUAL
6830: IFFALSE 6840
// sRocket := true ;
6832: LD_ADDR_EXP 29
6836: PUSH
6837: LD_INT 1
6839: ST_TO_ADDR
// if p3 = 2 then
6840: LD_VAR 0 3
6844: PUSH
6845: LD_INT 2
6847: EQUAL
6848: IFFALSE 6858
// sSpeed := true ;
6850: LD_ADDR_EXP 28
6854: PUSH
6855: LD_INT 1
6857: ST_TO_ADDR
// if p3 = 3 then
6858: LD_VAR 0 3
6862: PUSH
6863: LD_INT 3
6865: EQUAL
6866: IFFALSE 6876
// sEngine := true ;
6868: LD_ADDR_EXP 30
6872: PUSH
6873: LD_INT 1
6875: ST_TO_ADDR
// if p3 = 4 then
6876: LD_VAR 0 3
6880: PUSH
6881: LD_INT 4
6883: EQUAL
6884: IFFALSE 6894
// sSpec := true ;
6886: LD_ADDR_EXP 27
6890: PUSH
6891: LD_INT 1
6893: ST_TO_ADDR
// if p3 = 5 then
6894: LD_VAR 0 3
6898: PUSH
6899: LD_INT 5
6901: EQUAL
6902: IFFALSE 6912
// sLevel := true ;
6904: LD_ADDR_EXP 31
6908: PUSH
6909: LD_INT 1
6911: ST_TO_ADDR
// if p3 = 6 then
6912: LD_VAR 0 3
6916: PUSH
6917: LD_INT 6
6919: EQUAL
6920: IFFALSE 6930
// sArmoury := true ;
6922: LD_ADDR_EXP 32
6926: PUSH
6927: LD_INT 1
6929: ST_TO_ADDR
// if p3 = 7 then
6930: LD_VAR 0 3
6934: PUSH
6935: LD_INT 7
6937: EQUAL
6938: IFFALSE 6948
// sRadar := true ;
6940: LD_ADDR_EXP 33
6944: PUSH
6945: LD_INT 1
6947: ST_TO_ADDR
// if p3 = 8 then
6948: LD_VAR 0 3
6952: PUSH
6953: LD_INT 8
6955: EQUAL
6956: IFFALSE 6966
// sBunker := true ;
6958: LD_ADDR_EXP 34
6962: PUSH
6963: LD_INT 1
6965: ST_TO_ADDR
// if p3 = 9 then
6966: LD_VAR 0 3
6970: PUSH
6971: LD_INT 9
6973: EQUAL
6974: IFFALSE 6984
// sHack := true ;
6976: LD_ADDR_EXP 35
6980: PUSH
6981: LD_INT 1
6983: ST_TO_ADDR
// if p3 = 10 then
6984: LD_VAR 0 3
6988: PUSH
6989: LD_INT 10
6991: EQUAL
6992: IFFALSE 7002
// sFire := true ;
6994: LD_ADDR_EXP 36
6998: PUSH
6999: LD_INT 1
7001: ST_TO_ADDR
// if p3 = 11 then
7002: LD_VAR 0 3
7006: PUSH
7007: LD_INT 11
7009: EQUAL
7010: IFFALSE 7020
// sRefresh := true ;
7012: LD_ADDR_EXP 37
7016: PUSH
7017: LD_INT 1
7019: ST_TO_ADDR
// if p3 = 12 then
7020: LD_VAR 0 3
7024: PUSH
7025: LD_INT 12
7027: EQUAL
7028: IFFALSE 7038
// sExp := true ;
7030: LD_ADDR_EXP 38
7034: PUSH
7035: LD_INT 1
7037: ST_TO_ADDR
// if p3 = 13 then
7038: LD_VAR 0 3
7042: PUSH
7043: LD_INT 13
7045: EQUAL
7046: IFFALSE 7056
// sDepot := true ;
7048: LD_ADDR_EXP 39
7052: PUSH
7053: LD_INT 1
7055: ST_TO_ADDR
// if p3 = 14 then
7056: LD_VAR 0 3
7060: PUSH
7061: LD_INT 14
7063: EQUAL
7064: IFFALSE 7074
// sFlag := true ;
7066: LD_ADDR_EXP 40
7070: PUSH
7071: LD_INT 1
7073: ST_TO_ADDR
// if p3 = 15 then
7074: LD_VAR 0 3
7078: PUSH
7079: LD_INT 15
7081: EQUAL
7082: IFFALSE 7092
// sKamikadze := true ;
7084: LD_ADDR_EXP 48
7088: PUSH
7089: LD_INT 1
7091: ST_TO_ADDR
// if p3 = 16 then
7092: LD_VAR 0 3
7096: PUSH
7097: LD_INT 16
7099: EQUAL
7100: IFFALSE 7110
// sTroll := true ;
7102: LD_ADDR_EXP 49
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// if p3 = 17 then
7110: LD_VAR 0 3
7114: PUSH
7115: LD_INT 17
7117: EQUAL
7118: IFFALSE 7128
// sSlow := true ;
7120: LD_ADDR_EXP 50
7124: PUSH
7125: LD_INT 1
7127: ST_TO_ADDR
// if p3 = 18 then
7128: LD_VAR 0 3
7132: PUSH
7133: LD_INT 18
7135: EQUAL
7136: IFFALSE 7146
// sLack := true ;
7138: LD_ADDR_EXP 51
7142: PUSH
7143: LD_INT 1
7145: ST_TO_ADDR
// if p3 = 19 then
7146: LD_VAR 0 3
7150: PUSH
7151: LD_INT 19
7153: EQUAL
7154: IFFALSE 7164
// sTank := true ;
7156: LD_ADDR_EXP 53
7160: PUSH
7161: LD_INT 1
7163: ST_TO_ADDR
// if p3 = 20 then
7164: LD_VAR 0 3
7168: PUSH
7169: LD_INT 20
7171: EQUAL
7172: IFFALSE 7182
// sRemote := true ;
7174: LD_ADDR_EXP 54
7178: PUSH
7179: LD_INT 1
7181: ST_TO_ADDR
// if p3 = 21 then
7182: LD_VAR 0 3
7186: PUSH
7187: LD_INT 21
7189: EQUAL
7190: IFFALSE 7200
// sPowell := true ;
7192: LD_ADDR_EXP 55
7196: PUSH
7197: LD_INT 1
7199: ST_TO_ADDR
// if p3 = 22 then
7200: LD_VAR 0 3
7204: PUSH
7205: LD_INT 22
7207: EQUAL
7208: IFFALSE 7218
// sTeleport := true ;
7210: LD_ADDR_EXP 58
7214: PUSH
7215: LD_INT 1
7217: ST_TO_ADDR
// if p3 = 23 then
7218: LD_VAR 0 3
7222: PUSH
7223: LD_INT 23
7225: EQUAL
7226: IFFALSE 7236
// sOilTower := true ;
7228: LD_ADDR_EXP 60
7232: PUSH
7233: LD_INT 1
7235: ST_TO_ADDR
// if p3 = 24 then
7236: LD_VAR 0 3
7240: PUSH
7241: LD_INT 24
7243: EQUAL
7244: IFFALSE 7254
// sShovel := true ;
7246: LD_ADDR_EXP 61
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// if p3 = 25 then
7254: LD_VAR 0 3
7258: PUSH
7259: LD_INT 25
7261: EQUAL
7262: IFFALSE 7272
// sSheik := true ;
7264: LD_ADDR_EXP 62
7268: PUSH
7269: LD_INT 1
7271: ST_TO_ADDR
// if p3 = 101 then
7272: LD_VAR 0 3
7276: PUSH
7277: LD_INT 101
7279: EQUAL
7280: IFFALSE 7290
// sSold := true ;
7282: LD_ADDR_EXP 41
7286: PUSH
7287: LD_INT 1
7289: ST_TO_ADDR
// if p3 = 102 then
7290: LD_VAR 0 3
7294: PUSH
7295: LD_INT 102
7297: EQUAL
7298: IFFALSE 7308
// sDiff := true ;
7300: LD_ADDR_EXP 42
7304: PUSH
7305: LD_INT 1
7307: ST_TO_ADDR
// if p3 = 103 then
7308: LD_VAR 0 3
7312: PUSH
7313: LD_INT 103
7315: EQUAL
7316: IFFALSE 7326
// sFog := true ;
7318: LD_ADDR_EXP 45
7322: PUSH
7323: LD_INT 1
7325: ST_TO_ADDR
// if p3 = 104 then
7326: LD_VAR 0 3
7330: PUSH
7331: LD_INT 104
7333: EQUAL
7334: IFFALSE 7344
// sReset := true ;
7336: LD_ADDR_EXP 46
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// if p3 = 105 then
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 105
7351: EQUAL
7352: IFFALSE 7362
// sSun := true ;
7354: LD_ADDR_EXP 47
7358: PUSH
7359: LD_INT 1
7361: ST_TO_ADDR
// if p3 = 106 then
7362: LD_VAR 0 3
7366: PUSH
7367: LD_INT 106
7369: EQUAL
7370: IFFALSE 7380
// sTiger := true ;
7372: LD_ADDR_EXP 43
7376: PUSH
7377: LD_INT 1
7379: ST_TO_ADDR
// if p3 = 107 then
7380: LD_VAR 0 3
7384: PUSH
7385: LD_INT 107
7387: EQUAL
7388: IFFALSE 7398
// sBomb := true ;
7390: LD_ADDR_EXP 44
7394: PUSH
7395: LD_INT 1
7397: ST_TO_ADDR
// if p3 = 108 then
7398: LD_VAR 0 3
7402: PUSH
7403: LD_INT 108
7405: EQUAL
7406: IFFALSE 7416
// sWound := true ;
7408: LD_ADDR_EXP 52
7412: PUSH
7413: LD_INT 1
7415: ST_TO_ADDR
// if p3 = 109 then
7416: LD_VAR 0 3
7420: PUSH
7421: LD_INT 109
7423: EQUAL
7424: IFFALSE 7434
// sBetray := true ;
7426: LD_ADDR_EXP 56
7430: PUSH
7431: LD_INT 1
7433: ST_TO_ADDR
// if p3 = 110 then
7434: LD_VAR 0 3
7438: PUSH
7439: LD_INT 110
7441: EQUAL
7442: IFFALSE 7452
// sContamin := true ;
7444: LD_ADDR_EXP 57
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// if p3 = 111 then
7452: LD_VAR 0 3
7456: PUSH
7457: LD_INT 111
7459: EQUAL
7460: IFFALSE 7470
// sOil := true ;
7462: LD_ADDR_EXP 59
7466: PUSH
7467: LD_INT 1
7469: ST_TO_ADDR
// if p3 = 112 then
7470: LD_VAR 0 3
7474: PUSH
7475: LD_INT 112
7477: EQUAL
7478: IFFALSE 7488
// sStu := true ;
7480: LD_ADDR_EXP 63
7484: PUSH
7485: LD_INT 1
7487: ST_TO_ADDR
// end ; end ;
7488: PPOPN 6
7490: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7491: LD_EXP 26
7495: PUSH
7496: LD_EXP 29
7500: AND
7501: IFFALSE 7625
7503: GO 7505
7505: DISABLE
7506: LD_INT 0
7508: PPUSH
7509: PPUSH
// begin enable ;
7510: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
7511: LD_ADDR_VAR 0 2
7515: PUSH
7516: LD_INT 22
7518: PUSH
7519: LD_OWVAR 2
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 2
7530: PUSH
7531: LD_INT 34
7533: PUSH
7534: LD_INT 7
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: PUSH
7541: LD_INT 34
7543: PUSH
7544: LD_INT 45
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_INT 34
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 34
7563: PUSH
7564: LD_INT 47
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: LIST
7575: LIST
7576: LIST
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PPUSH
7582: CALL_OW 69
7586: ST_TO_ADDR
// if not tmp then
7587: LD_VAR 0 2
7591: NOT
7592: IFFALSE 7596
// exit ;
7594: GO 7625
// for i in tmp do
7596: LD_ADDR_VAR 0 1
7600: PUSH
7601: LD_VAR 0 2
7605: PUSH
7606: FOR_IN
7607: IFFALSE 7623
// begin SetLives ( i , 0 ) ;
7609: LD_VAR 0 1
7613: PPUSH
7614: LD_INT 0
7616: PPUSH
7617: CALL_OW 234
// end ;
7621: GO 7606
7623: POP
7624: POP
// end ;
7625: PPOPN 2
7627: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
7628: LD_EXP 26
7632: PUSH
7633: LD_EXP 30
7637: AND
7638: IFFALSE 7719
7640: GO 7642
7642: DISABLE
7643: LD_INT 0
7645: PPUSH
7646: PPUSH
// begin enable ;
7647: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
7648: LD_ADDR_VAR 0 2
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_OWVAR 2
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 32
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PPUSH
7679: CALL_OW 69
7683: ST_TO_ADDR
// if not tmp then
7684: LD_VAR 0 2
7688: NOT
7689: IFFALSE 7693
// exit ;
7691: GO 7719
// for i in tmp do
7693: LD_ADDR_VAR 0 1
7697: PUSH
7698: LD_VAR 0 2
7702: PUSH
7703: FOR_IN
7704: IFFALSE 7717
// begin DestroyUnit ( i ) ;
7706: LD_VAR 0 1
7710: PPUSH
7711: CALL_OW 65
// end ;
7715: GO 7703
7717: POP
7718: POP
// end ;
7719: PPOPN 2
7721: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
7722: LD_EXP 26
7726: PUSH
7727: LD_EXP 27
7731: AND
7732: IFFALSE 7825
7734: GO 7736
7736: DISABLE
7737: LD_INT 0
7739: PPUSH
// begin enable ;
7740: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
7741: LD_ADDR_VAR 0 1
7745: PUSH
7746: LD_INT 22
7748: PUSH
7749: LD_OWVAR 2
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: PUSH
7758: LD_INT 2
7760: PUSH
7761: LD_INT 25
7763: PUSH
7764: LD_INT 5
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: PUSH
7771: LD_INT 25
7773: PUSH
7774: LD_INT 9
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 25
7783: PUSH
7784: LD_INT 8
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PPUSH
7801: CALL_OW 69
7805: PUSH
7806: FOR_IN
7807: IFFALSE 7823
// begin SetClass ( i , 1 ) ;
7809: LD_VAR 0 1
7813: PPUSH
7814: LD_INT 1
7816: PPUSH
7817: CALL_OW 336
// end ;
7821: GO 7806
7823: POP
7824: POP
// end ;
7825: PPOPN 1
7827: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
7828: LD_EXP 26
7832: PUSH
7833: LD_EXP 28
7837: AND
7838: PUSH
7839: LD_OWVAR 65
7843: PUSH
7844: LD_INT 7
7846: LESS
7847: AND
7848: IFFALSE 7862
7850: GO 7852
7852: DISABLE
// begin enable ;
7853: ENABLE
// game_speed := 7 ;
7854: LD_ADDR_OWVAR 65
7858: PUSH
7859: LD_INT 7
7861: ST_TO_ADDR
// end ;
7862: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
7863: LD_EXP 26
7867: PUSH
7868: LD_EXP 31
7872: AND
7873: IFFALSE 8075
7875: GO 7877
7877: DISABLE
7878: LD_INT 0
7880: PPUSH
7881: PPUSH
7882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
7883: LD_ADDR_VAR 0 3
7887: PUSH
7888: LD_INT 81
7890: PUSH
7891: LD_OWVAR 2
7895: PUSH
7896: EMPTY
7897: LIST
7898: LIST
7899: PUSH
7900: LD_INT 21
7902: PUSH
7903: LD_INT 1
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PPUSH
7914: CALL_OW 69
7918: ST_TO_ADDR
// if not tmp then
7919: LD_VAR 0 3
7923: NOT
7924: IFFALSE 7928
// exit ;
7926: GO 8075
// if tmp > 5 then
7928: LD_VAR 0 3
7932: PUSH
7933: LD_INT 5
7935: GREATER
7936: IFFALSE 7948
// k := 5 else
7938: LD_ADDR_VAR 0 2
7942: PUSH
7943: LD_INT 5
7945: ST_TO_ADDR
7946: GO 7958
// k := tmp ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_VAR 0 3
7957: ST_TO_ADDR
// for i := 1 to k do
7958: LD_ADDR_VAR 0 1
7962: PUSH
7963: DOUBLE
7964: LD_INT 1
7966: DEC
7967: ST_TO_ADDR
7968: LD_VAR 0 2
7972: PUSH
7973: FOR_TO
7974: IFFALSE 8073
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
7976: LD_VAR 0 3
7980: PUSH
7981: LD_VAR 0 1
7985: ARRAY
7986: PPUSH
7987: LD_VAR 0 1
7991: PUSH
7992: LD_INT 4
7994: MOD
7995: PUSH
7996: LD_INT 1
7998: PLUS
7999: PPUSH
8000: CALL_OW 259
8004: PUSH
8005: LD_INT 10
8007: LESS
8008: IFFALSE 8071
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
8010: LD_VAR 0 3
8014: PUSH
8015: LD_VAR 0 1
8019: ARRAY
8020: PPUSH
8021: LD_VAR 0 1
8025: PUSH
8026: LD_INT 4
8028: MOD
8029: PUSH
8030: LD_INT 1
8032: PLUS
8033: PPUSH
8034: LD_VAR 0 3
8038: PUSH
8039: LD_VAR 0 1
8043: ARRAY
8044: PPUSH
8045: LD_VAR 0 1
8049: PUSH
8050: LD_INT 4
8052: MOD
8053: PUSH
8054: LD_INT 1
8056: PLUS
8057: PPUSH
8058: CALL_OW 259
8062: PUSH
8063: LD_INT 1
8065: PLUS
8066: PPUSH
8067: CALL_OW 237
8071: GO 7973
8073: POP
8074: POP
// end ;
8075: PPOPN 3
8077: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
8078: LD_EXP 26
8082: PUSH
8083: LD_EXP 32
8087: AND
8088: IFFALSE 8108
8090: GO 8092
8092: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
8093: LD_INT 4
8095: PPUSH
8096: LD_OWVAR 2
8100: PPUSH
8101: LD_INT 0
8103: PPUSH
8104: CALL_OW 324
8108: END
// every 0 0$1 trigger StreamModeActive and sShovel do
8109: LD_EXP 26
8113: PUSH
8114: LD_EXP 61
8118: AND
8119: IFFALSE 8139
8121: GO 8123
8123: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
8124: LD_INT 19
8126: PPUSH
8127: LD_OWVAR 2
8131: PPUSH
8132: LD_INT 0
8134: PPUSH
8135: CALL_OW 324
8139: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
8140: LD_EXP 26
8144: PUSH
8145: LD_EXP 33
8149: AND
8150: IFFALSE 8249
8152: GO 8154
8154: DISABLE
8155: LD_INT 0
8157: PPUSH
8158: PPUSH
// begin enable ;
8159: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
8160: LD_ADDR_VAR 0 2
8164: PUSH
8165: LD_INT 22
8167: PUSH
8168: LD_OWVAR 2
8172: PUSH
8173: EMPTY
8174: LIST
8175: LIST
8176: PUSH
8177: LD_INT 2
8179: PUSH
8180: LD_INT 34
8182: PUSH
8183: LD_INT 11
8185: PUSH
8186: EMPTY
8187: LIST
8188: LIST
8189: PUSH
8190: LD_INT 34
8192: PUSH
8193: LD_INT 30
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: LIST
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: PPUSH
8209: CALL_OW 69
8213: ST_TO_ADDR
// if not tmp then
8214: LD_VAR 0 2
8218: NOT
8219: IFFALSE 8223
// exit ;
8221: GO 8249
// for i in tmp do
8223: LD_ADDR_VAR 0 1
8227: PUSH
8228: LD_VAR 0 2
8232: PUSH
8233: FOR_IN
8234: IFFALSE 8247
// begin DestroyUnit ( i ) ;
8236: LD_VAR 0 1
8240: PPUSH
8241: CALL_OW 65
// end ;
8245: GO 8233
8247: POP
8248: POP
// end ;
8249: PPOPN 2
8251: END
// every 0 0$1 trigger StreamModeActive and sBunker do
8252: LD_EXP 26
8256: PUSH
8257: LD_EXP 34
8261: AND
8262: IFFALSE 8282
8264: GO 8266
8266: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
8267: LD_INT 32
8269: PPUSH
8270: LD_OWVAR 2
8274: PPUSH
8275: LD_INT 0
8277: PPUSH
8278: CALL_OW 324
8282: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
8283: LD_EXP 26
8287: PUSH
8288: LD_EXP 35
8292: AND
8293: IFFALSE 8474
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
8301: PPUSH
8302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
8303: LD_ADDR_VAR 0 2
8307: PUSH
8308: LD_INT 22
8310: PUSH
8311: LD_OWVAR 2
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: PUSH
8320: LD_INT 33
8322: PUSH
8323: LD_INT 3
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: PPUSH
8334: CALL_OW 69
8338: ST_TO_ADDR
// if not tmp then
8339: LD_VAR 0 2
8343: NOT
8344: IFFALSE 8348
// exit ;
8346: GO 8474
// side := 0 ;
8348: LD_ADDR_VAR 0 3
8352: PUSH
8353: LD_INT 0
8355: ST_TO_ADDR
// for i := 1 to 8 do
8356: LD_ADDR_VAR 0 1
8360: PUSH
8361: DOUBLE
8362: LD_INT 1
8364: DEC
8365: ST_TO_ADDR
8366: LD_INT 8
8368: PUSH
8369: FOR_TO
8370: IFFALSE 8418
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
8372: LD_OWVAR 2
8376: PUSH
8377: LD_VAR 0 1
8381: NONEQUAL
8382: PUSH
8383: LD_OWVAR 2
8387: PPUSH
8388: LD_VAR 0 1
8392: PPUSH
8393: CALL_OW 81
8397: PUSH
8398: LD_INT 2
8400: EQUAL
8401: AND
8402: IFFALSE 8416
// begin side := i ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_VAR 0 1
8413: ST_TO_ADDR
// break ;
8414: GO 8418
// end ;
8416: GO 8369
8418: POP
8419: POP
// if not side then
8420: LD_VAR 0 3
8424: NOT
8425: IFFALSE 8429
// exit ;
8427: GO 8474
// for i := 1 to tmp do
8429: LD_ADDR_VAR 0 1
8433: PUSH
8434: DOUBLE
8435: LD_INT 1
8437: DEC
8438: ST_TO_ADDR
8439: LD_VAR 0 2
8443: PUSH
8444: FOR_TO
8445: IFFALSE 8472
// if Prob ( 30 ) then
8447: LD_INT 30
8449: PPUSH
8450: CALL_OW 13
8454: IFFALSE 8470
// SetSide ( i , side ) ;
8456: LD_VAR 0 1
8460: PPUSH
8461: LD_VAR 0 3
8465: PPUSH
8466: CALL_OW 235
8470: GO 8444
8472: POP
8473: POP
// end ;
8474: PPOPN 3
8476: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
8477: LD_EXP 26
8481: PUSH
8482: LD_EXP 37
8486: AND
8487: IFFALSE 8606
8489: GO 8491
8491: DISABLE
8492: LD_INT 0
8494: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
8495: LD_ADDR_VAR 0 1
8499: PUSH
8500: LD_INT 22
8502: PUSH
8503: LD_OWVAR 2
8507: PUSH
8508: EMPTY
8509: LIST
8510: LIST
8511: PUSH
8512: LD_INT 21
8514: PUSH
8515: LD_INT 1
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PUSH
8522: LD_INT 3
8524: PUSH
8525: LD_INT 23
8527: PUSH
8528: LD_INT 0
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PPUSH
8544: CALL_OW 69
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8604
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
8552: LD_VAR 0 1
8556: PPUSH
8557: CALL_OW 257
8561: PUSH
8562: LD_INT 1
8564: PUSH
8565: LD_INT 2
8567: PUSH
8568: LD_INT 3
8570: PUSH
8571: LD_INT 4
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: LIST
8578: LIST
8579: IN
8580: IFFALSE 8602
// SetClass ( un , rand ( 1 , 4 ) ) ;
8582: LD_VAR 0 1
8586: PPUSH
8587: LD_INT 1
8589: PPUSH
8590: LD_INT 4
8592: PPUSH
8593: CALL_OW 12
8597: PPUSH
8598: CALL_OW 336
8602: GO 8549
8604: POP
8605: POP
// end ;
8606: PPOPN 1
8608: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
8609: LD_EXP 26
8613: PUSH
8614: LD_EXP 36
8618: AND
8619: IFFALSE 8698
8621: GO 8623
8623: DISABLE
8624: LD_INT 0
8626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8627: LD_ADDR_VAR 0 1
8631: PUSH
8632: LD_INT 22
8634: PUSH
8635: LD_OWVAR 2
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PUSH
8644: LD_INT 21
8646: PUSH
8647: LD_INT 3
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: PPUSH
8658: CALL_OW 69
8662: ST_TO_ADDR
// if not tmp then
8663: LD_VAR 0 1
8667: NOT
8668: IFFALSE 8672
// exit ;
8670: GO 8698
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
8672: LD_VAR 0 1
8676: PUSH
8677: LD_INT 1
8679: PPUSH
8680: LD_VAR 0 1
8684: PPUSH
8685: CALL_OW 12
8689: ARRAY
8690: PPUSH
8691: LD_INT 100
8693: PPUSH
8694: CALL_OW 234
// end ;
8698: PPOPN 1
8700: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
8701: LD_EXP 26
8705: PUSH
8706: LD_EXP 38
8710: AND
8711: IFFALSE 8809
8713: GO 8715
8715: DISABLE
8716: LD_INT 0
8718: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8719: LD_ADDR_VAR 0 1
8723: PUSH
8724: LD_INT 22
8726: PUSH
8727: LD_OWVAR 2
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PUSH
8736: LD_INT 21
8738: PUSH
8739: LD_INT 1
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PPUSH
8750: CALL_OW 69
8754: ST_TO_ADDR
// if not tmp then
8755: LD_VAR 0 1
8759: NOT
8760: IFFALSE 8764
// exit ;
8762: GO 8809
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
8764: LD_VAR 0 1
8768: PUSH
8769: LD_INT 1
8771: PPUSH
8772: LD_VAR 0 1
8776: PPUSH
8777: CALL_OW 12
8781: ARRAY
8782: PPUSH
8783: LD_INT 1
8785: PPUSH
8786: LD_INT 4
8788: PPUSH
8789: CALL_OW 12
8793: PPUSH
8794: LD_INT 3000
8796: PPUSH
8797: LD_INT 9000
8799: PPUSH
8800: CALL_OW 12
8804: PPUSH
8805: CALL_OW 492
// end ;
8809: PPOPN 1
8811: END
// every 0 0$1 trigger StreamModeActive and sDepot do
8812: LD_EXP 26
8816: PUSH
8817: LD_EXP 39
8821: AND
8822: IFFALSE 8842
8824: GO 8826
8826: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
8827: LD_INT 1
8829: PPUSH
8830: LD_OWVAR 2
8834: PPUSH
8835: LD_INT 0
8837: PPUSH
8838: CALL_OW 324
8842: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
8843: LD_EXP 26
8847: PUSH
8848: LD_EXP 40
8852: AND
8853: IFFALSE 8936
8855: GO 8857
8857: DISABLE
8858: LD_INT 0
8860: PPUSH
8861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
8862: LD_ADDR_VAR 0 2
8866: PUSH
8867: LD_INT 22
8869: PUSH
8870: LD_OWVAR 2
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 21
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: ST_TO_ADDR
// if not tmp then
8898: LD_VAR 0 2
8902: NOT
8903: IFFALSE 8907
// exit ;
8905: GO 8936
// for i in tmp do
8907: LD_ADDR_VAR 0 1
8911: PUSH
8912: LD_VAR 0 2
8916: PUSH
8917: FOR_IN
8918: IFFALSE 8934
// SetBLevel ( i , 10 ) ;
8920: LD_VAR 0 1
8924: PPUSH
8925: LD_INT 10
8927: PPUSH
8928: CALL_OW 241
8932: GO 8917
8934: POP
8935: POP
// end ;
8936: PPOPN 2
8938: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
8939: LD_EXP 26
8943: PUSH
8944: LD_EXP 41
8948: AND
8949: IFFALSE 9060
8951: GO 8953
8953: DISABLE
8954: LD_INT 0
8956: PPUSH
8957: PPUSH
8958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
8959: LD_ADDR_VAR 0 3
8963: PUSH
8964: LD_INT 22
8966: PUSH
8967: LD_OWVAR 2
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: PUSH
8976: LD_INT 25
8978: PUSH
8979: LD_INT 1
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: PPUSH
8990: CALL_OW 69
8994: ST_TO_ADDR
// if not tmp then
8995: LD_VAR 0 3
8999: NOT
9000: IFFALSE 9004
// exit ;
9002: GO 9060
// un := tmp [ rand ( 1 , tmp ) ] ;
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 1
9016: PPUSH
9017: LD_VAR 0 3
9021: PPUSH
9022: CALL_OW 12
9026: ARRAY
9027: ST_TO_ADDR
// if Crawls ( un ) then
9028: LD_VAR 0 2
9032: PPUSH
9033: CALL_OW 318
9037: IFFALSE 9048
// ComWalk ( un ) ;
9039: LD_VAR 0 2
9043: PPUSH
9044: CALL_OW 138
// SetClass ( un , class_sniper ) ;
9048: LD_VAR 0 2
9052: PPUSH
9053: LD_INT 5
9055: PPUSH
9056: CALL_OW 336
// end ;
9060: PPOPN 3
9062: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
9063: LD_EXP 26
9067: PUSH
9068: LD_EXP 42
9072: AND
9073: PUSH
9074: LD_OWVAR 67
9078: PUSH
9079: LD_INT 3
9081: LESS
9082: AND
9083: IFFALSE 9102
9085: GO 9087
9087: DISABLE
// Difficulty := Difficulty + 1 ;
9088: LD_ADDR_OWVAR 67
9092: PUSH
9093: LD_OWVAR 67
9097: PUSH
9098: LD_INT 1
9100: PLUS
9101: ST_TO_ADDR
9102: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
9103: LD_EXP 26
9107: PUSH
9108: LD_EXP 43
9112: AND
9113: IFFALSE 9216
9115: GO 9117
9117: DISABLE
9118: LD_INT 0
9120: PPUSH
// begin for i := 1 to 5 do
9121: LD_ADDR_VAR 0 1
9125: PUSH
9126: DOUBLE
9127: LD_INT 1
9129: DEC
9130: ST_TO_ADDR
9131: LD_INT 5
9133: PUSH
9134: FOR_TO
9135: IFFALSE 9214
// begin uc_nation := nation_nature ;
9137: LD_ADDR_OWVAR 21
9141: PUSH
9142: LD_INT 0
9144: ST_TO_ADDR
// uc_side := 0 ;
9145: LD_ADDR_OWVAR 20
9149: PUSH
9150: LD_INT 0
9152: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9153: LD_ADDR_OWVAR 29
9157: PUSH
9158: LD_INT 12
9160: PUSH
9161: LD_INT 12
9163: PUSH
9164: EMPTY
9165: LIST
9166: LIST
9167: ST_TO_ADDR
// hc_agressivity := 20 ;
9168: LD_ADDR_OWVAR 35
9172: PUSH
9173: LD_INT 20
9175: ST_TO_ADDR
// hc_class := class_tiger ;
9176: LD_ADDR_OWVAR 28
9180: PUSH
9181: LD_INT 14
9183: ST_TO_ADDR
// hc_gallery :=  ;
9184: LD_ADDR_OWVAR 33
9188: PUSH
9189: LD_STRING 
9191: ST_TO_ADDR
// hc_name :=  ;
9192: LD_ADDR_OWVAR 26
9196: PUSH
9197: LD_STRING 
9199: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
9200: CALL_OW 44
9204: PPUSH
9205: LD_INT 0
9207: PPUSH
9208: CALL_OW 51
// end ;
9212: GO 9134
9214: POP
9215: POP
// end ;
9216: PPOPN 1
9218: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
9219: LD_EXP 26
9223: PUSH
9224: LD_EXP 44
9228: AND
9229: IFFALSE 9403
9231: GO 9233
9233: DISABLE
9234: LD_INT 0
9236: PPUSH
9237: PPUSH
9238: PPUSH
9239: PPUSH
// begin result := false ;
9240: LD_ADDR_VAR 0 4
9244: PUSH
9245: LD_INT 0
9247: ST_TO_ADDR
// for i := 1 to 8 do
9248: LD_ADDR_VAR 0 1
9252: PUSH
9253: DOUBLE
9254: LD_INT 1
9256: DEC
9257: ST_TO_ADDR
9258: LD_INT 8
9260: PUSH
9261: FOR_TO
9262: IFFALSE 9373
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
9264: LD_ADDR_VAR 0 2
9268: PUSH
9269: LD_INT 10
9271: PUSH
9272: LD_INT 50
9274: PUSH
9275: LD_INT 90
9277: PUSH
9278: LD_INT 140
9280: PUSH
9281: EMPTY
9282: LIST
9283: LIST
9284: LIST
9285: LIST
9286: PUSH
9287: LD_INT 1
9289: PPUSH
9290: LD_INT 4
9292: PPUSH
9293: CALL_OW 12
9297: ARRAY
9298: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
9299: LD_ADDR_VAR 0 3
9303: PUSH
9304: LD_INT 10
9306: PUSH
9307: LD_INT 50
9309: PUSH
9310: LD_INT 90
9312: PUSH
9313: LD_INT 140
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: PUSH
9322: LD_INT 1
9324: PPUSH
9325: LD_INT 4
9327: PPUSH
9328: CALL_OW 12
9332: ARRAY
9333: ST_TO_ADDR
// if ValidHex ( x , y ) then
9334: LD_VAR 0 2
9338: PPUSH
9339: LD_VAR 0 3
9343: PPUSH
9344: CALL_OW 488
9348: IFFALSE 9371
// begin result := [ x , y ] ;
9350: LD_ADDR_VAR 0 4
9354: PUSH
9355: LD_VAR 0 2
9359: PUSH
9360: LD_VAR 0 3
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: ST_TO_ADDR
// break ;
9369: GO 9373
// end ; end ;
9371: GO 9261
9373: POP
9374: POP
// if result then
9375: LD_VAR 0 4
9379: IFFALSE 9403
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
9381: LD_VAR 0 4
9385: PUSH
9386: LD_INT 1
9388: ARRAY
9389: PPUSH
9390: LD_VAR 0 4
9394: PUSH
9395: LD_INT 2
9397: ARRAY
9398: PPUSH
9399: CALL_OW 429
// end ;
9403: PPOPN 4
9405: END
// every 0 0$1 trigger StreamModeActive and sReset do
9406: LD_EXP 26
9410: PUSH
9411: LD_EXP 46
9415: AND
9416: IFFALSE 9428
9418: GO 9420
9420: DISABLE
// YouLost (  ) ;
9421: LD_STRING 
9423: PPUSH
9424: CALL_OW 104
9428: END
// every 0 0$1 trigger StreamModeActive and sFog do
9429: LD_EXP 26
9433: PUSH
9434: LD_EXP 45
9438: AND
9439: IFFALSE 9453
9441: GO 9443
9443: DISABLE
// FogOff ( your_side ) ;
9444: LD_OWVAR 2
9448: PPUSH
9449: CALL_OW 344
9453: END
// every 0 0$1 trigger StreamModeActive and sSun do
9454: LD_EXP 26
9458: PUSH
9459: LD_EXP 47
9463: AND
9464: IFFALSE 9492
9466: GO 9468
9468: DISABLE
// begin solar_recharge_percent := 0 ;
9469: LD_ADDR_OWVAR 79
9473: PUSH
9474: LD_INT 0
9476: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9477: LD_INT 10500
9479: PPUSH
9480: CALL_OW 67
// solar_recharge_percent := 100 ;
9484: LD_ADDR_OWVAR 79
9488: PUSH
9489: LD_INT 100
9491: ST_TO_ADDR
// end ;
9492: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
9493: LD_EXP 26
9497: PUSH
9498: LD_EXP 48
9502: AND
9503: IFFALSE 9742
9505: GO 9507
9507: DISABLE
9508: LD_INT 0
9510: PPUSH
9511: PPUSH
9512: PPUSH
// begin tmp := [ ] ;
9513: LD_ADDR_VAR 0 3
9517: PUSH
9518: EMPTY
9519: ST_TO_ADDR
// for i := 1 to 6 do
9520: LD_ADDR_VAR 0 1
9524: PUSH
9525: DOUBLE
9526: LD_INT 1
9528: DEC
9529: ST_TO_ADDR
9530: LD_INT 6
9532: PUSH
9533: FOR_TO
9534: IFFALSE 9639
// begin uc_nation := nation_nature ;
9536: LD_ADDR_OWVAR 21
9540: PUSH
9541: LD_INT 0
9543: ST_TO_ADDR
// uc_side := 0 ;
9544: LD_ADDR_OWVAR 20
9548: PUSH
9549: LD_INT 0
9551: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9552: LD_ADDR_OWVAR 29
9556: PUSH
9557: LD_INT 12
9559: PUSH
9560: LD_INT 12
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: ST_TO_ADDR
// hc_agressivity := 20 ;
9567: LD_ADDR_OWVAR 35
9571: PUSH
9572: LD_INT 20
9574: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
9575: LD_ADDR_OWVAR 28
9579: PUSH
9580: LD_INT 17
9582: ST_TO_ADDR
// hc_gallery :=  ;
9583: LD_ADDR_OWVAR 33
9587: PUSH
9588: LD_STRING 
9590: ST_TO_ADDR
// hc_name :=  ;
9591: LD_ADDR_OWVAR 26
9595: PUSH
9596: LD_STRING 
9598: ST_TO_ADDR
// un := CreateHuman ;
9599: LD_ADDR_VAR 0 2
9603: PUSH
9604: CALL_OW 44
9608: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
9609: LD_VAR 0 2
9613: PPUSH
9614: LD_INT 1
9616: PPUSH
9617: CALL_OW 51
// tmp := tmp * un ;
9621: LD_ADDR_VAR 0 3
9625: PUSH
9626: LD_VAR 0 3
9630: PUSH
9631: LD_VAR 0 2
9635: MUL
9636: ST_TO_ADDR
// end ;
9637: GO 9533
9639: POP
9640: POP
// repeat wait ( 0 0$1 ) ;
9641: LD_INT 35
9643: PPUSH
9644: CALL_OW 67
// for un in tmp do
9648: LD_ADDR_VAR 0 2
9652: PUSH
9653: LD_VAR 0 3
9657: PUSH
9658: FOR_IN
9659: IFFALSE 9733
// begin if IsDead ( un ) then
9661: LD_VAR 0 2
9665: PPUSH
9666: CALL_OW 301
9670: IFFALSE 9690
// begin tmp := tmp diff un ;
9672: LD_ADDR_VAR 0 3
9676: PUSH
9677: LD_VAR 0 3
9681: PUSH
9682: LD_VAR 0 2
9686: DIFF
9687: ST_TO_ADDR
// continue ;
9688: GO 9658
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
9690: LD_VAR 0 2
9694: PPUSH
9695: LD_INT 3
9697: PUSH
9698: LD_INT 22
9700: PUSH
9701: LD_INT 0
9703: PUSH
9704: EMPTY
9705: LIST
9706: LIST
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PPUSH
9712: CALL_OW 69
9716: PPUSH
9717: LD_VAR 0 2
9721: PPUSH
9722: CALL_OW 74
9726: PPUSH
9727: CALL_OW 115
// end ;
9731: GO 9658
9733: POP
9734: POP
// until not tmp ;
9735: LD_VAR 0 3
9739: NOT
9740: IFFALSE 9641
// end ;
9742: PPOPN 3
9744: END
// every 0 0$1 trigger StreamModeActive and sTroll do
9745: LD_EXP 26
9749: PUSH
9750: LD_EXP 49
9754: AND
9755: IFFALSE 9781
9757: GO 9759
9759: DISABLE
// begin ToLua ( displayTroll(); ) ;
9760: LD_STRING displayTroll();
9762: PPUSH
9763: CALL_OW 559
// wait ( 3 3$00 ) ;
9767: LD_INT 6300
9769: PPUSH
9770: CALL_OW 67
// ToLua ( hideTroll(); ) ;
9774: LD_STRING hideTroll();
9776: PPUSH
9777: CALL_OW 559
// end ;
9781: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
9782: LD_EXP 26
9786: PUSH
9787: LD_EXP 50
9791: AND
9792: IFFALSE 9855
9794: GO 9796
9796: DISABLE
9797: LD_INT 0
9799: PPUSH
// begin p := 0 ;
9800: LD_ADDR_VAR 0 1
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// repeat game_speed := 1 ;
9808: LD_ADDR_OWVAR 65
9812: PUSH
9813: LD_INT 1
9815: ST_TO_ADDR
// wait ( 0 0$1 ) ;
9816: LD_INT 35
9818: PPUSH
9819: CALL_OW 67
// p := p + 1 ;
9823: LD_ADDR_VAR 0 1
9827: PUSH
9828: LD_VAR 0 1
9832: PUSH
9833: LD_INT 1
9835: PLUS
9836: ST_TO_ADDR
// until p >= 60 ;
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 60
9844: GREATEREQUAL
9845: IFFALSE 9808
// game_speed := 4 ;
9847: LD_ADDR_OWVAR 65
9851: PUSH
9852: LD_INT 4
9854: ST_TO_ADDR
// end ;
9855: PPOPN 1
9857: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
9858: LD_EXP 26
9862: PUSH
9863: LD_EXP 51
9867: AND
9868: IFFALSE 10014
9870: GO 9872
9872: DISABLE
9873: LD_INT 0
9875: PPUSH
9876: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9877: LD_ADDR_VAR 0 1
9881: PUSH
9882: LD_INT 22
9884: PUSH
9885: LD_OWVAR 2
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: LD_INT 2
9896: PUSH
9897: LD_INT 30
9899: PUSH
9900: LD_INT 0
9902: PUSH
9903: EMPTY
9904: LIST
9905: LIST
9906: PUSH
9907: LD_INT 30
9909: PUSH
9910: LD_INT 1
9912: PUSH
9913: EMPTY
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: PPUSH
9926: CALL_OW 69
9930: ST_TO_ADDR
// if not depot then
9931: LD_VAR 0 1
9935: NOT
9936: IFFALSE 9940
// exit ;
9938: GO 10014
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
9940: LD_ADDR_VAR 0 2
9944: PUSH
9945: LD_VAR 0 1
9949: PUSH
9950: LD_INT 1
9952: PPUSH
9953: LD_VAR 0 1
9957: PPUSH
9958: CALL_OW 12
9962: ARRAY
9963: PPUSH
9964: CALL_OW 274
9968: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
9969: LD_VAR 0 2
9973: PPUSH
9974: LD_INT 1
9976: PPUSH
9977: LD_INT 0
9979: PPUSH
9980: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
9984: LD_VAR 0 2
9988: PPUSH
9989: LD_INT 2
9991: PPUSH
9992: LD_INT 0
9994: PPUSH
9995: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
9999: LD_VAR 0 2
10003: PPUSH
10004: LD_INT 3
10006: PPUSH
10007: LD_INT 0
10009: PPUSH
10010: CALL_OW 277
// end ;
10014: PPOPN 2
10016: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
10017: LD_EXP 26
10021: PUSH
10022: LD_EXP 52
10026: AND
10027: IFFALSE 10124
10029: GO 10031
10031: DISABLE
10032: LD_INT 0
10034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10035: LD_ADDR_VAR 0 1
10039: PUSH
10040: LD_INT 22
10042: PUSH
10043: LD_OWVAR 2
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PUSH
10052: LD_INT 21
10054: PUSH
10055: LD_INT 1
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: PUSH
10062: LD_INT 3
10064: PUSH
10065: LD_INT 23
10067: PUSH
10068: LD_INT 0
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: PPUSH
10084: CALL_OW 69
10088: ST_TO_ADDR
// if not tmp then
10089: LD_VAR 0 1
10093: NOT
10094: IFFALSE 10098
// exit ;
10096: GO 10124
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
10098: LD_VAR 0 1
10102: PUSH
10103: LD_INT 1
10105: PPUSH
10106: LD_VAR 0 1
10110: PPUSH
10111: CALL_OW 12
10115: ARRAY
10116: PPUSH
10117: LD_INT 200
10119: PPUSH
10120: CALL_OW 234
// end ;
10124: PPOPN 1
10126: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
10127: LD_EXP 26
10131: PUSH
10132: LD_EXP 53
10136: AND
10137: IFFALSE 10216
10139: GO 10141
10141: DISABLE
10142: LD_INT 0
10144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
10145: LD_ADDR_VAR 0 1
10149: PUSH
10150: LD_INT 22
10152: PUSH
10153: LD_OWVAR 2
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PUSH
10162: LD_INT 21
10164: PUSH
10165: LD_INT 2
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PUSH
10172: EMPTY
10173: LIST
10174: LIST
10175: PPUSH
10176: CALL_OW 69
10180: ST_TO_ADDR
// if not tmp then
10181: LD_VAR 0 1
10185: NOT
10186: IFFALSE 10190
// exit ;
10188: GO 10216
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
10190: LD_VAR 0 1
10194: PUSH
10195: LD_INT 1
10197: PPUSH
10198: LD_VAR 0 1
10202: PPUSH
10203: CALL_OW 12
10207: ARRAY
10208: PPUSH
10209: LD_INT 60
10211: PPUSH
10212: CALL_OW 234
// end ;
10216: PPOPN 1
10218: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
10219: LD_EXP 26
10223: PUSH
10224: LD_EXP 54
10228: AND
10229: IFFALSE 10328
10231: GO 10233
10233: DISABLE
10234: LD_INT 0
10236: PPUSH
10237: PPUSH
// begin enable ;
10238: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
10239: LD_ADDR_VAR 0 1
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_OWVAR 2
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: PUSH
10256: LD_INT 61
10258: PUSH
10259: EMPTY
10260: LIST
10261: PUSH
10262: LD_INT 33
10264: PUSH
10265: LD_INT 2
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: LIST
10276: PPUSH
10277: CALL_OW 69
10281: ST_TO_ADDR
// if not tmp then
10282: LD_VAR 0 1
10286: NOT
10287: IFFALSE 10291
// exit ;
10289: GO 10328
// for i in tmp do
10291: LD_ADDR_VAR 0 2
10295: PUSH
10296: LD_VAR 0 1
10300: PUSH
10301: FOR_IN
10302: IFFALSE 10326
// if IsControledBy ( i ) then
10304: LD_VAR 0 2
10308: PPUSH
10309: CALL_OW 312
10313: IFFALSE 10324
// ComUnlink ( i ) ;
10315: LD_VAR 0 2
10319: PPUSH
10320: CALL_OW 136
10324: GO 10301
10326: POP
10327: POP
// end ;
10328: PPOPN 2
10330: END
// every 0 0$1 trigger StreamModeActive and sPowell do
10331: LD_EXP 26
10335: PUSH
10336: LD_EXP 55
10340: AND
10341: IFFALSE 10381
10343: GO 10345
10345: DISABLE
// begin ToLua ( displayPowell(); ) ;
10346: LD_STRING displayPowell();
10348: PPUSH
10349: CALL_OW 559
// wait ( 0 0$20 ) ;
10353: LD_INT 700
10355: PPUSH
10356: CALL_OW 67
// ToLua ( displayPowell(); ) ;
10360: LD_STRING displayPowell();
10362: PPUSH
10363: CALL_OW 559
// wait ( 0 0$40 ) ;
10367: LD_INT 1400
10369: PPUSH
10370: CALL_OW 67
// ToLua ( displayPowell(); ) ;
10374: LD_STRING displayPowell();
10376: PPUSH
10377: CALL_OW 559
// end ;
10381: END
// every 0 0$1 trigger StreamModeActive and sStu do
10382: LD_EXP 26
10386: PUSH
10387: LD_EXP 63
10391: AND
10392: IFFALSE 10404
10394: GO 10396
10396: DISABLE
// begin ToLua ( displayStucuk(); ) ;
10397: LD_STRING displayStucuk();
10399: PPUSH
10400: CALL_OW 559
// end ;
10404: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
10405: LD_EXP 26
10409: PUSH
10410: LD_EXP 56
10414: AND
10415: IFFALSE 10556
10417: GO 10419
10419: DISABLE
10420: LD_INT 0
10422: PPUSH
10423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_INT 22
10431: PUSH
10432: LD_OWVAR 2
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: PUSH
10441: LD_INT 21
10443: PUSH
10444: LD_INT 1
10446: PUSH
10447: EMPTY
10448: LIST
10449: LIST
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PPUSH
10455: CALL_OW 69
10459: ST_TO_ADDR
// if not tmp then
10460: LD_VAR 0 2
10464: NOT
10465: IFFALSE 10469
// exit ;
10467: GO 10556
// un := tmp [ rand ( 1 , tmp ) ] ;
10469: LD_ADDR_VAR 0 1
10473: PUSH
10474: LD_VAR 0 2
10478: PUSH
10479: LD_INT 1
10481: PPUSH
10482: LD_VAR 0 2
10486: PPUSH
10487: CALL_OW 12
10491: ARRAY
10492: ST_TO_ADDR
// SetSide ( un , 0 ) ;
10493: LD_VAR 0 1
10497: PPUSH
10498: LD_INT 0
10500: PPUSH
10501: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_OWVAR 3
10514: PUSH
10515: LD_VAR 0 1
10519: DIFF
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 74
10530: PPUSH
10531: CALL_OW 115
// wait ( 0 0$20 ) ;
10535: LD_INT 700
10537: PPUSH
10538: CALL_OW 67
// SetSide ( un , your_side ) ;
10542: LD_VAR 0 1
10546: PPUSH
10547: LD_OWVAR 2
10551: PPUSH
10552: CALL_OW 235
// end ;
10556: PPOPN 2
10558: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
10559: LD_EXP 26
10563: PUSH
10564: LD_EXP 57
10568: AND
10569: IFFALSE 10675
10571: GO 10573
10573: DISABLE
10574: LD_INT 0
10576: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: LD_INT 22
10584: PUSH
10585: LD_OWVAR 2
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PUSH
10594: LD_INT 2
10596: PUSH
10597: LD_INT 30
10599: PUSH
10600: LD_INT 0
10602: PUSH
10603: EMPTY
10604: LIST
10605: LIST
10606: PUSH
10607: LD_INT 30
10609: PUSH
10610: LD_INT 1
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: LIST
10621: PUSH
10622: EMPTY
10623: LIST
10624: LIST
10625: PPUSH
10626: CALL_OW 69
10630: ST_TO_ADDR
// if not depot then
10631: LD_VAR 0 1
10635: NOT
10636: IFFALSE 10640
// exit ;
10638: GO 10675
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
10640: LD_VAR 0 1
10644: PUSH
10645: LD_INT 1
10647: ARRAY
10648: PPUSH
10649: CALL_OW 250
10653: PPUSH
10654: LD_VAR 0 1
10658: PUSH
10659: LD_INT 1
10661: ARRAY
10662: PPUSH
10663: CALL_OW 251
10667: PPUSH
10668: LD_INT 70
10670: PPUSH
10671: CALL_OW 495
// end ;
10675: PPOPN 1
10677: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
10678: LD_EXP 26
10682: PUSH
10683: LD_EXP 58
10687: AND
10688: IFFALSE 10899
10690: GO 10692
10692: DISABLE
10693: LD_INT 0
10695: PPUSH
10696: PPUSH
10697: PPUSH
10698: PPUSH
10699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10700: LD_ADDR_VAR 0 5
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_OWVAR 2
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: PUSH
10717: LD_INT 21
10719: PUSH
10720: LD_INT 1
10722: PUSH
10723: EMPTY
10724: LIST
10725: LIST
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: PPUSH
10731: CALL_OW 69
10735: ST_TO_ADDR
// if not tmp then
10736: LD_VAR 0 5
10740: NOT
10741: IFFALSE 10745
// exit ;
10743: GO 10899
// for i in tmp do
10745: LD_ADDR_VAR 0 1
10749: PUSH
10750: LD_VAR 0 5
10754: PUSH
10755: FOR_IN
10756: IFFALSE 10897
// begin d := rand ( 0 , 5 ) ;
10758: LD_ADDR_VAR 0 4
10762: PUSH
10763: LD_INT 0
10765: PPUSH
10766: LD_INT 5
10768: PPUSH
10769: CALL_OW 12
10773: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 1
10783: PPUSH
10784: CALL_OW 250
10788: PPUSH
10789: LD_VAR 0 4
10793: PPUSH
10794: LD_INT 3
10796: PPUSH
10797: LD_INT 12
10799: PPUSH
10800: CALL_OW 12
10804: PPUSH
10805: CALL_OW 272
10809: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
10810: LD_ADDR_VAR 0 3
10814: PUSH
10815: LD_VAR 0 1
10819: PPUSH
10820: CALL_OW 251
10824: PPUSH
10825: LD_VAR 0 4
10829: PPUSH
10830: LD_INT 3
10832: PPUSH
10833: LD_INT 12
10835: PPUSH
10836: CALL_OW 12
10840: PPUSH
10841: CALL_OW 273
10845: ST_TO_ADDR
// if ValidHex ( x , y ) then
10846: LD_VAR 0 2
10850: PPUSH
10851: LD_VAR 0 3
10855: PPUSH
10856: CALL_OW 488
10860: IFFALSE 10895
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
10862: LD_VAR 0 1
10866: PPUSH
10867: LD_VAR 0 2
10871: PPUSH
10872: LD_VAR 0 3
10876: PPUSH
10877: LD_INT 3
10879: PPUSH
10880: LD_INT 6
10882: PPUSH
10883: CALL_OW 12
10887: PPUSH
10888: LD_INT 1
10890: PPUSH
10891: CALL_OW 483
// end ;
10895: GO 10755
10897: POP
10898: POP
// end ;
10899: PPOPN 5
10901: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
10902: LD_EXP 26
10906: PUSH
10907: LD_EXP 59
10911: AND
10912: IFFALSE 11006
10914: GO 10916
10916: DISABLE
10917: LD_INT 0
10919: PPUSH
10920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
10921: LD_ADDR_VAR 0 2
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_OWVAR 2
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PUSH
10938: LD_INT 32
10940: PUSH
10941: LD_INT 1
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 21
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: LIST
10962: PPUSH
10963: CALL_OW 69
10967: ST_TO_ADDR
// if not tmp then
10968: LD_VAR 0 2
10972: NOT
10973: IFFALSE 10977
// exit ;
10975: GO 11006
// for i in tmp do
10977: LD_ADDR_VAR 0 1
10981: PUSH
10982: LD_VAR 0 2
10986: PUSH
10987: FOR_IN
10988: IFFALSE 11004
// SetFuel ( i , 0 ) ;
10990: LD_VAR 0 1
10994: PPUSH
10995: LD_INT 0
10997: PPUSH
10998: CALL_OW 240
11002: GO 10987
11004: POP
11005: POP
// end ;
11006: PPOPN 2
11008: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
11009: LD_EXP 26
11013: PUSH
11014: LD_EXP 60
11018: AND
11019: IFFALSE 11085
11021: GO 11023
11023: DISABLE
11024: LD_INT 0
11026: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
11027: LD_ADDR_VAR 0 1
11031: PUSH
11032: LD_INT 22
11034: PUSH
11035: LD_OWVAR 2
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: LD_INT 30
11046: PUSH
11047: LD_INT 29
11049: PUSH
11050: EMPTY
11051: LIST
11052: LIST
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PPUSH
11058: CALL_OW 69
11062: ST_TO_ADDR
// if not tmp then
11063: LD_VAR 0 1
11067: NOT
11068: IFFALSE 11072
// exit ;
11070: GO 11085
// DestroyUnit ( tmp [ 1 ] ) ;
11072: LD_VAR 0 1
11076: PUSH
11077: LD_INT 1
11079: ARRAY
11080: PPUSH
11081: CALL_OW 65
// end ;
11085: PPOPN 1
11087: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
11088: LD_EXP 26
11092: PUSH
11093: LD_EXP 62
11097: AND
11098: IFFALSE 11211
11100: GO 11102
11102: DISABLE
11103: LD_INT 0
11105: PPUSH
// begin uc_side := 0 ;
11106: LD_ADDR_OWVAR 20
11110: PUSH
11111: LD_INT 0
11113: ST_TO_ADDR
// uc_nation := nation_arabian ;
11114: LD_ADDR_OWVAR 21
11118: PUSH
11119: LD_INT 2
11121: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
11122: LD_INT 1
11124: PPUSH
11125: LD_INT 10
11127: PPUSH
11128: LD_INT 11
11130: PPUSH
11131: CALL_OW 380
// un := CreateHuman ;
11135: LD_ADDR_VAR 0 1
11139: PUSH
11140: CALL_OW 44
11144: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11145: LD_VAR 0 1
11149: PPUSH
11150: LD_INT 1
11152: PPUSH
11153: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11157: LD_INT 35
11159: PPUSH
11160: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11164: LD_VAR 0 1
11168: PPUSH
11169: LD_INT 22
11171: PUSH
11172: LD_OWVAR 2
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PPUSH
11181: CALL_OW 69
11185: PPUSH
11186: LD_VAR 0 1
11190: PPUSH
11191: CALL_OW 74
11195: PPUSH
11196: CALL_OW 115
// until IsDead ( un ) ;
11200: LD_VAR 0 1
11204: PPUSH
11205: CALL_OW 301
11209: IFFALSE 11157
// end ; end_of_file
11211: PPOPN 1
11213: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11214: LD_INT 0
11216: PPUSH
11217: PPUSH
11218: PPUSH
11219: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11220: LD_VAR 0 1
11224: PPUSH
11225: CALL_OW 264
11229: PUSH
11230: LD_EXP 68
11234: EQUAL
11235: IFFALSE 11307
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11237: LD_INT 68
11239: PPUSH
11240: LD_VAR 0 1
11244: PPUSH
11245: CALL_OW 255
11249: PPUSH
11250: CALL_OW 321
11254: PUSH
11255: LD_INT 2
11257: EQUAL
11258: IFFALSE 11270
// eff := 70 else
11260: LD_ADDR_VAR 0 6
11264: PUSH
11265: LD_INT 70
11267: ST_TO_ADDR
11268: GO 11278
// eff := 30 ;
11270: LD_ADDR_VAR 0 6
11274: PUSH
11275: LD_INT 30
11277: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11278: LD_VAR 0 1
11282: PPUSH
11283: CALL_OW 250
11287: PPUSH
11288: LD_VAR 0 1
11292: PPUSH
11293: CALL_OW 251
11297: PPUSH
11298: LD_VAR 0 6
11302: PPUSH
11303: CALL_OW 495
// end ; end ;
11307: LD_VAR 0 4
11311: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11312: LD_INT 0
11314: PPUSH
11315: PPUSH
11316: PPUSH
11317: PPUSH
11318: PPUSH
11319: PPUSH
// if cmd = 124 then
11320: LD_VAR 0 1
11324: PUSH
11325: LD_INT 124
11327: EQUAL
11328: IFFALSE 11534
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11330: LD_ADDR_VAR 0 5
11334: PUSH
11335: LD_INT 2
11337: PUSH
11338: LD_INT 34
11340: PUSH
11341: LD_INT 53
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: LD_INT 34
11350: PUSH
11351: LD_INT 14
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: PUSH
11358: EMPTY
11359: LIST
11360: LIST
11361: LIST
11362: PPUSH
11363: CALL_OW 69
11367: ST_TO_ADDR
// if not tmp then
11368: LD_VAR 0 5
11372: NOT
11373: IFFALSE 11377
// exit ;
11375: GO 11534
// for i in tmp do
11377: LD_ADDR_VAR 0 3
11381: PUSH
11382: LD_VAR 0 5
11386: PUSH
11387: FOR_IN
11388: IFFALSE 11532
// begin taskList := GetTaskList ( i ) ;
11390: LD_ADDR_VAR 0 6
11394: PUSH
11395: LD_VAR 0 3
11399: PPUSH
11400: CALL_OW 437
11404: ST_TO_ADDR
// if not taskList then
11405: LD_VAR 0 6
11409: NOT
11410: IFFALSE 11414
// continue ;
11412: GO 11387
// for j = 1 to taskList do
11414: LD_ADDR_VAR 0 4
11418: PUSH
11419: DOUBLE
11420: LD_INT 1
11422: DEC
11423: ST_TO_ADDR
11424: LD_VAR 0 6
11428: PUSH
11429: FOR_TO
11430: IFFALSE 11528
// if taskList [ j ] [ 1 ] = | then
11432: LD_VAR 0 6
11436: PUSH
11437: LD_VAR 0 4
11441: ARRAY
11442: PUSH
11443: LD_INT 1
11445: ARRAY
11446: PUSH
11447: LD_STRING |
11449: EQUAL
11450: IFFALSE 11526
// begin _taskList := Delete ( taskList , 1 ) ;
11452: LD_ADDR_VAR 0 7
11456: PUSH
11457: LD_VAR 0 6
11461: PPUSH
11462: LD_INT 1
11464: PPUSH
11465: CALL_OW 3
11469: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11470: LD_VAR 0 3
11474: PPUSH
11475: LD_VAR 0 7
11479: PPUSH
11480: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11484: LD_VAR 0 3
11488: PPUSH
11489: LD_VAR 0 6
11493: PUSH
11494: LD_VAR 0 4
11498: ARRAY
11499: PUSH
11500: LD_INT 2
11502: ARRAY
11503: PPUSH
11504: LD_VAR 0 6
11508: PUSH
11509: LD_VAR 0 4
11513: ARRAY
11514: PUSH
11515: LD_INT 3
11517: ARRAY
11518: PPUSH
11519: LD_INT 8
11521: PPUSH
11522: CALL 11539 0 4
// end ;
11526: GO 11429
11528: POP
11529: POP
// end ;
11530: GO 11387
11532: POP
11533: POP
// end ; end ;
11534: LD_VAR 0 2
11538: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11539: LD_INT 0
11541: PPUSH
11542: PPUSH
11543: PPUSH
11544: PPUSH
11545: PPUSH
11546: PPUSH
11547: PPUSH
11548: PPUSH
11549: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11550: LD_VAR 0 1
11554: NOT
11555: PUSH
11556: LD_VAR 0 2
11560: PPUSH
11561: LD_VAR 0 3
11565: PPUSH
11566: CALL_OW 488
11570: NOT
11571: OR
11572: PUSH
11573: LD_VAR 0 4
11577: NOT
11578: OR
11579: IFFALSE 11583
// exit ;
11581: GO 11923
// list := [ ] ;
11583: LD_ADDR_VAR 0 13
11587: PUSH
11588: EMPTY
11589: ST_TO_ADDR
// if x - r < 0 then
11590: LD_VAR 0 2
11594: PUSH
11595: LD_VAR 0 4
11599: MINUS
11600: PUSH
11601: LD_INT 0
11603: LESS
11604: IFFALSE 11616
// min_x := 0 else
11606: LD_ADDR_VAR 0 7
11610: PUSH
11611: LD_INT 0
11613: ST_TO_ADDR
11614: GO 11632
// min_x := x - r ;
11616: LD_ADDR_VAR 0 7
11620: PUSH
11621: LD_VAR 0 2
11625: PUSH
11626: LD_VAR 0 4
11630: MINUS
11631: ST_TO_ADDR
// if y - r < 0 then
11632: LD_VAR 0 3
11636: PUSH
11637: LD_VAR 0 4
11641: MINUS
11642: PUSH
11643: LD_INT 0
11645: LESS
11646: IFFALSE 11658
// min_y := 0 else
11648: LD_ADDR_VAR 0 8
11652: PUSH
11653: LD_INT 0
11655: ST_TO_ADDR
11656: GO 11674
// min_y := y - r ;
11658: LD_ADDR_VAR 0 8
11662: PUSH
11663: LD_VAR 0 3
11667: PUSH
11668: LD_VAR 0 4
11672: MINUS
11673: ST_TO_ADDR
// max_x := x + r ;
11674: LD_ADDR_VAR 0 9
11678: PUSH
11679: LD_VAR 0 2
11683: PUSH
11684: LD_VAR 0 4
11688: PLUS
11689: ST_TO_ADDR
// max_y := y + r ;
11690: LD_ADDR_VAR 0 10
11694: PUSH
11695: LD_VAR 0 3
11699: PUSH
11700: LD_VAR 0 4
11704: PLUS
11705: ST_TO_ADDR
// for _x = min_x to max_x do
11706: LD_ADDR_VAR 0 11
11710: PUSH
11711: DOUBLE
11712: LD_VAR 0 7
11716: DEC
11717: ST_TO_ADDR
11718: LD_VAR 0 9
11722: PUSH
11723: FOR_TO
11724: IFFALSE 11841
// for _y = min_y to max_y do
11726: LD_ADDR_VAR 0 12
11730: PUSH
11731: DOUBLE
11732: LD_VAR 0 8
11736: DEC
11737: ST_TO_ADDR
11738: LD_VAR 0 10
11742: PUSH
11743: FOR_TO
11744: IFFALSE 11837
// begin if not ValidHex ( _x , _y ) then
11746: LD_VAR 0 11
11750: PPUSH
11751: LD_VAR 0 12
11755: PPUSH
11756: CALL_OW 488
11760: NOT
11761: IFFALSE 11765
// continue ;
11763: GO 11743
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11765: LD_VAR 0 11
11769: PPUSH
11770: LD_VAR 0 12
11774: PPUSH
11775: CALL_OW 351
11779: PUSH
11780: LD_VAR 0 11
11784: PPUSH
11785: LD_VAR 0 12
11789: PPUSH
11790: CALL_OW 554
11794: AND
11795: IFFALSE 11835
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11797: LD_ADDR_VAR 0 13
11801: PUSH
11802: LD_VAR 0 13
11806: PPUSH
11807: LD_VAR 0 13
11811: PUSH
11812: LD_INT 1
11814: PLUS
11815: PPUSH
11816: LD_VAR 0 11
11820: PUSH
11821: LD_VAR 0 12
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PPUSH
11830: CALL_OW 2
11834: ST_TO_ADDR
// end ;
11835: GO 11743
11837: POP
11838: POP
11839: GO 11723
11841: POP
11842: POP
// if not list then
11843: LD_VAR 0 13
11847: NOT
11848: IFFALSE 11852
// exit ;
11850: GO 11923
// for i in list do
11852: LD_ADDR_VAR 0 6
11856: PUSH
11857: LD_VAR 0 13
11861: PUSH
11862: FOR_IN
11863: IFFALSE 11921
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
11865: LD_VAR 0 1
11869: PPUSH
11870: LD_STRING M
11872: PUSH
11873: LD_VAR 0 6
11877: PUSH
11878: LD_INT 1
11880: ARRAY
11881: PUSH
11882: LD_VAR 0 6
11886: PUSH
11887: LD_INT 2
11889: ARRAY
11890: PUSH
11891: LD_INT 0
11893: PUSH
11894: LD_INT 0
11896: PUSH
11897: LD_INT 0
11899: PUSH
11900: LD_INT 0
11902: PUSH
11903: EMPTY
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: LIST
11909: LIST
11910: LIST
11911: PUSH
11912: EMPTY
11913: LIST
11914: PPUSH
11915: CALL_OW 447
11919: GO 11862
11921: POP
11922: POP
// end ; end_of_file
11923: LD_VAR 0 5
11927: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
11928: GO 11930
11930: DISABLE
// begin ru_radar := 98 ;
11931: LD_ADDR_EXP 64
11935: PUSH
11936: LD_INT 98
11938: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11939: LD_ADDR_EXP 65
11943: PUSH
11944: LD_INT 89
11946: ST_TO_ADDR
// us_hack := 99 ;
11947: LD_ADDR_EXP 66
11951: PUSH
11952: LD_INT 99
11954: ST_TO_ADDR
// us_artillery := 97 ;
11955: LD_ADDR_EXP 67
11959: PUSH
11960: LD_INT 97
11962: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11963: LD_ADDR_EXP 68
11967: PUSH
11968: LD_INT 91
11970: ST_TO_ADDR
// end ;
11971: END
