// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 32 0 0
// InitAmerican ;
  15: CALL 915 0 0
// InitRussian ;
  19: CALL 1154 0 0
// DebugMode ;
  23: CALL 152 0 0
// Action ;
  27: CALL 2710 0 0
// end ;
  31: END
// export debug ; export mission_prefix ; export active_russian_dialog , bobby_in_squad , powell_contact , macmilan_use_radio , cyrus_in_squad , active_road_patrol , macmilan_in_trap , meta_action , end_mission , bobby_saved , cyrus_saved , send_troops_to_forest ; function Init ; begin
  32: LD_INT 0
  34: PPUSH
// mission_prefix := 01_ ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_STRING 01_
  42: ST_TO_ADDR
// debug := 0 ;
  43: LD_ADDR_EXP 1
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// active_russian_dialog := false ;
  51: LD_ADDR_EXP 3
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// bobby_in_squad := false ;
  59: LD_ADDR_EXP 4
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// cyrus_in_squad := false ;
  67: LD_ADDR_EXP 7
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// powell_contact := false ;
  75: LD_ADDR_EXP 5
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// macmilan_use_radio := false ;
  83: LD_ADDR_EXP 6
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// active_road_patrol := false ;
  91: LD_ADDR_EXP 8
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// macmilan_in_trap := false ;
  99: LD_ADDR_EXP 9
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// meta_action := false ;
 107: LD_ADDR_EXP 10
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// end_mission := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// bobby_saved := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// cyrus_saved := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// send_troops_to_forest := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// function DebugMode ; var i ; begin
 152: LD_INT 0
 154: PPUSH
 155: PPUSH
// if not debug then
 156: LD_EXP 1
 160: NOT
 161: IFFALSE 165
// exit ;
 163: GO 184
// Difficulty := 3 ;
 165: LD_ADDR_OWVAR 67
 169: PUSH
 170: LD_INT 3
 172: ST_TO_ADDR
// TurnFogOff ( ) ;
 173: CALL_OW 537
// FogOff ( 1 ) ;
 177: LD_INT 1
 179: PPUSH
 180: CALL_OW 344
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
// if exist_mode then
 193: LD_VAR 0 2
 197: IFFALSE 216
// unit := CreateCharacter ( ident ) else
 199: LD_ADDR_VAR 0 4
 203: PUSH
 204: LD_VAR 0 1
 208: PPUSH
 209: CALL_OW 34
 213: ST_TO_ADDR
 214: GO 231
// unit := NewCharacter ( ident ) ;
 216: LD_ADDR_VAR 0 4
 220: PUSH
 221: LD_VAR 0 1
 225: PPUSH
 226: CALL_OW 25
 230: ST_TO_ADDR
// result := unit ;
 231: LD_ADDR_VAR 0 3
 235: PUSH
 236: LD_VAR 0 4
 240: ST_TO_ADDR
// end ;
 241: LD_VAR 0 3
 245: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 246: LD_INT 0
 248: PPUSH
 249: PPUSH
 250: PPUSH
// uc_side := GetSide ( b ) ;
 251: LD_ADDR_OWVAR 20
 255: PUSH
 256: LD_VAR 0 2
 260: PPUSH
 261: CALL_OW 255
 265: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 266: LD_ADDR_OWVAR 21
 270: PUSH
 271: LD_VAR 0 2
 275: PPUSH
 276: CALL_OW 248
 280: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 281: LD_INT 0
 283: PPUSH
 284: LD_INT 1
 286: PPUSH
 287: LD_VAR 0 1
 291: PPUSH
 292: CALL_OW 380
// dir := GetDir ( b ) - 3 ;
 296: LD_ADDR_VAR 0 5
 300: PUSH
 301: LD_VAR 0 2
 305: PPUSH
 306: CALL_OW 254
 310: PUSH
 311: LD_INT 3
 313: MINUS
 314: ST_TO_ADDR
// if dir < 0 then
 315: LD_VAR 0 5
 319: PUSH
 320: LD_INT 0
 322: LESS
 323: IFFALSE 339
// dir := 6 + dir ;
 325: LD_ADDR_VAR 0 5
 329: PUSH
 330: LD_INT 6
 332: PUSH
 333: LD_VAR 0 5
 337: PLUS
 338: ST_TO_ADDR
// un := CreateHuman ;
 339: LD_ADDR_VAR 0 4
 343: PUSH
 344: CALL_OW 44
 348: ST_TO_ADDR
// SetDir ( un , dir ) ;
 349: LD_VAR 0 4
 353: PPUSH
 354: LD_VAR 0 5
 358: PPUSH
 359: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 363: LD_VAR 0 4
 367: PPUSH
 368: LD_VAR 0 2
 372: PPUSH
 373: CALL_OW 52
// end ;
 377: LD_VAR 0 3
 381: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 382: LD_INT 0
 384: PPUSH
// uc_side := side ;
 385: LD_ADDR_OWVAR 20
 389: PUSH
 390: LD_VAR 0 1
 394: ST_TO_ADDR
// uc_nation := nation ;
 395: LD_ADDR_OWVAR 21
 399: PUSH
 400: LD_VAR 0 2
 404: ST_TO_ADDR
// vc_chassis := chassis ;
 405: LD_ADDR_OWVAR 37
 409: PUSH
 410: LD_VAR 0 3
 414: ST_TO_ADDR
// vc_engine := engine ;
 415: LD_ADDR_OWVAR 39
 419: PUSH
 420: LD_VAR 0 4
 424: ST_TO_ADDR
// vc_control := control ;
 425: LD_ADDR_OWVAR 38
 429: PUSH
 430: LD_VAR 0 5
 434: ST_TO_ADDR
// vc_weapon := weapon ;
 435: LD_ADDR_OWVAR 40
 439: PUSH
 440: LD_VAR 0 6
 444: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 445: LD_ADDR_OWVAR 41
 449: PUSH
 450: LD_VAR 0 7
 454: ST_TO_ADDR
// result := CreateVehicle ;
 455: LD_ADDR_VAR 0 8
 459: PUSH
 460: CALL_OW 45
 464: ST_TO_ADDR
// end ;
 465: LD_VAR 0 8
 469: RET
// export function ComPatrol ( unit , mode , pause , coords ) ; var i ; begin
 470: LD_INT 0
 472: PPUSH
 473: PPUSH
// while ( active_road_patrol ) do
 474: LD_EXP 8
 478: IFFALSE 832
// begin Wait ( 0 0$01 ) ;
 480: LD_INT 35
 482: PPUSH
 483: CALL_OW 67
// if not unit then
 487: LD_VAR 0 1
 491: NOT
 492: IFFALSE 496
// exit ;
 494: GO 832
// if mode = road then
 496: LD_VAR 0 2
 500: PUSH
 501: LD_STRING road
 503: EQUAL
 504: IFFALSE 560
// if GetFuel ( unit ) < 50 and not See ( 1 , unit ) and not HasTask ( unit ) then
 506: LD_VAR 0 1
 510: PPUSH
 511: CALL_OW 261
 515: PUSH
 516: LD_INT 50
 518: LESS
 519: PUSH
 520: LD_INT 1
 522: PPUSH
 523: LD_VAR 0 1
 527: PPUSH
 528: CALL_OW 292
 532: NOT
 533: AND
 534: PUSH
 535: LD_VAR 0 1
 539: PPUSH
 540: CALL_OW 314
 544: NOT
 545: AND
 546: IFFALSE 560
// SetFuel ( unit , 100 ) ;
 548: LD_VAR 0 1
 552: PPUSH
 553: LD_INT 100
 555: PPUSH
 556: CALL_OW 240
// if mode = forest then
 560: LD_VAR 0 2
 564: PUSH
 565: LD_STRING forest
 567: EQUAL
 568: IFFALSE 648
// if GetLives ( unit ) < 600 then
 570: LD_VAR 0 1
 574: PPUSH
 575: CALL_OW 256
 579: PUSH
 580: LD_INT 600
 582: LESS
 583: IFFALSE 648
// begin ComMoveXY ( unit , 42 , 3 ) ;
 585: LD_VAR 0 1
 589: PPUSH
 590: LD_INT 42
 592: PPUSH
 593: LD_INT 3
 595: PPUSH
 596: CALL_OW 111
// SetRememberedX ( unit , GetX ( unit ) ) ;
 600: LD_VAR 0 1
 604: PPUSH
 605: LD_VAR 0 1
 609: PPUSH
 610: CALL_OW 250
 614: PPUSH
 615: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
 619: LD_VAR 0 1
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: CALL_OW 251
 633: PPUSH
 634: CALL_OW 232
// send_troops_to_forest := true ;
 638: LD_ADDR_EXP 14
 642: PUSH
 643: LD_INT 1
 645: ST_TO_ADDR
// break ;
 646: GO 832
// end ; if not HasTask ( unit ) then
 648: LD_VAR 0 1
 652: PPUSH
 653: CALL_OW 314
 657: NOT
 658: IFFALSE 830
// begin for i = 1 to coords do
 660: LD_ADDR_VAR 0 6
 664: PUSH
 665: DOUBLE
 666: LD_INT 1
 668: DEC
 669: ST_TO_ADDR
 670: LD_VAR 0 4
 674: PUSH
 675: FOR_TO
 676: IFFALSE 743
// begin AddComAgressiveMove ( unit , coords [ i ] , coords [ i + 1 ] ) ;
 678: LD_VAR 0 1
 682: PPUSH
 683: LD_VAR 0 4
 687: PUSH
 688: LD_VAR 0 6
 692: ARRAY
 693: PPUSH
 694: LD_VAR 0 4
 698: PUSH
 699: LD_VAR 0 6
 703: PUSH
 704: LD_INT 1
 706: PLUS
 707: ARRAY
 708: PPUSH
 709: CALL_OW 174
// AddComWait ( unit , pause ) ;
 713: LD_VAR 0 1
 717: PPUSH
 718: LD_VAR 0 3
 722: PPUSH
 723: CALL_OW 202
// i := i + 1 ;
 727: LD_ADDR_VAR 0 6
 731: PUSH
 732: LD_VAR 0 6
 736: PUSH
 737: LD_INT 1
 739: PLUS
 740: ST_TO_ADDR
// end ;
 741: GO 675
 743: POP
 744: POP
// for i = coords downto 1 do
 745: LD_ADDR_VAR 0 6
 749: PUSH
 750: DOUBLE
 751: LD_VAR 0 4
 755: INC
 756: ST_TO_ADDR
 757: LD_INT 1
 759: PUSH
 760: FOR_DOWNTO
 761: IFFALSE 828
// begin AddComAgressiveMove ( unit , coords [ i - 1 ] , coords [ i ] ) ;
 763: LD_VAR 0 1
 767: PPUSH
 768: LD_VAR 0 4
 772: PUSH
 773: LD_VAR 0 6
 777: PUSH
 778: LD_INT 1
 780: MINUS
 781: ARRAY
 782: PPUSH
 783: LD_VAR 0 4
 787: PUSH
 788: LD_VAR 0 6
 792: ARRAY
 793: PPUSH
 794: CALL_OW 174
// AddComWait ( unit , pause ) ;
 798: LD_VAR 0 1
 802: PPUSH
 803: LD_VAR 0 3
 807: PPUSH
 808: CALL_OW 202
// i := i - 1 ;
 812: LD_ADDR_VAR 0 6
 816: PUSH
 817: LD_VAR 0 6
 821: PUSH
 822: LD_INT 1
 824: MINUS
 825: ST_TO_ADDR
// end ;
 826: GO 760
 828: POP
 829: POP
// end ; end ;
 830: GO 474
// end ;
 832: LD_VAR 0 5
 836: RET
// export function DebugSay ( dialog ) ; var speaker ; begin
 837: LD_INT 0
 839: PPUSH
 840: PPUSH
// uc_nation := 1 ;
 841: LD_ADDR_OWVAR 21
 845: PUSH
 846: LD_INT 1
 848: ST_TO_ADDR
// uc_side := 0 ;
 849: LD_ADDR_OWVAR 20
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
 857: LD_INT 0
 859: PPUSH
 860: LD_INT 1
 862: PPUSH
 863: LD_INT 0
 865: PPUSH
 866: CALL_OW 380
// hc_name := speaker ;
 870: LD_ADDR_OWVAR 26
 874: PUSH
 875: LD_STRING speaker
 877: ST_TO_ADDR
// hc_gallery :=  ;
 878: LD_ADDR_OWVAR 33
 882: PUSH
 883: LD_STRING 
 885: ST_TO_ADDR
// speaker := CreateHuman ;
 886: LD_ADDR_VAR 0 3
 890: PUSH
 891: CALL_OW 44
 895: ST_TO_ADDR
// Say ( speaker , dialog ) ;
 896: LD_VAR 0 3
 900: PPUSH
 901: LD_VAR 0 1
 905: PPUSH
 906: CALL_OW 88
// end ; end_of_file
 910: LD_VAR 0 2
 914: RET
// export JMM , Bobby , Cyrus , Powell , fakePokryshkin ; export function InitAmerican ; begin
 915: LD_INT 0
 917: PPUSH
// uc_nation := 1 ;
 918: LD_ADDR_OWVAR 21
 922: PUSH
 923: LD_INT 1
 925: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , false ) ;
 926: LD_ADDR_EXP 15
 930: PUSH
 931: LD_STRING JMM
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL 189 0 2
 941: ST_TO_ADDR
// uc_side := 4 ;
 942: LD_ADDR_OWVAR 20
 946: PUSH
 947: LD_INT 4
 949: ST_TO_ADDR
// hc_gallery := us ;
 950: LD_ADDR_OWVAR 33
 954: PUSH
 955: LD_STRING us
 957: ST_TO_ADDR
// hc_face_number := 7 ;
 958: LD_ADDR_OWVAR 34
 962: PUSH
 963: LD_INT 7
 965: ST_TO_ADDR
// hc_sex := sex_male ;
 966: LD_ADDR_OWVAR 27
 970: PUSH
 971: LD_INT 1
 973: ST_TO_ADDR
// hc_name := . ;
 974: LD_ADDR_OWVAR 26
 978: PUSH
 979: LD_STRING .
 981: ST_TO_ADDR
// hc_class := 1 ;
 982: LD_ADDR_OWVAR 28
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// Powell := CreateHuman ;
 990: LD_ADDR_EXP 18
 994: PUSH
 995: CALL_OW 44
 999: ST_TO_ADDR
// hc_name := . ;
1000: LD_ADDR_OWVAR 26
1004: PUSH
1005: LD_STRING .
1007: ST_TO_ADDR
// hc_gallery := ru ;
1008: LD_ADDR_OWVAR 33
1012: PUSH
1013: LD_STRING ru
1015: ST_TO_ADDR
// hc_face_number := 4 ;
1016: LD_ADDR_OWVAR 34
1020: PUSH
1021: LD_INT 4
1023: ST_TO_ADDR
// hc_sex := sex_male ;
1024: LD_ADDR_OWVAR 27
1028: PUSH
1029: LD_INT 1
1031: ST_TO_ADDR
// fakePokryshkin := CreateHuman ;
1032: LD_ADDR_EXP 19
1036: PUSH
1037: CALL_OW 44
1041: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , false ) ;
1042: LD_ADDR_EXP 16
1046: PUSH
1047: LD_STRING Bobby
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL 189 0 2
1057: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , false ) ;
1058: LD_ADDR_EXP 17
1062: PUSH
1063: LD_STRING Cyrus
1065: PPUSH
1066: LD_INT 0
1068: PPUSH
1069: CALL 189 0 2
1073: ST_TO_ADDR
// case Difficulty of 1 :
1074: LD_OWVAR 67
1078: PUSH
1079: LD_INT 1
1081: DOUBLE
1082: EQUAL
1083: IFTRUE 1087
1085: GO 1102
1087: POP
// SetLives ( Bobby , 500 ) ; 2 :
1088: LD_EXP 16
1092: PPUSH
1093: LD_INT 500
1095: PPUSH
1096: CALL_OW 234
1100: GO 1149
1102: LD_INT 2
1104: DOUBLE
1105: EQUAL
1106: IFTRUE 1110
1108: GO 1125
1110: POP
// SetLives ( Bobby , 460 ) ; 3 :
1111: LD_EXP 16
1115: PPUSH
1116: LD_INT 460
1118: PPUSH
1119: CALL_OW 234
1123: GO 1149
1125: LD_INT 3
1127: DOUBLE
1128: EQUAL
1129: IFTRUE 1133
1131: GO 1148
1133: POP
// SetLives ( Bobby , 420 ) ; end ;
1134: LD_EXP 16
1138: PPUSH
1139: LD_INT 420
1141: PPUSH
1142: CALL_OW 234
1146: GO 1149
1148: POP
// end ; end_of_file
1149: LD_VAR 0 1
1153: RET
// export russian_troops_1 , russian_troops_2 , russian_patrol_tanks , russian_meta_guards , russian_patrol_forest ; export Pokryshkin ; export function InitRussian ; var skill , i , un ; begin
1154: LD_INT 0
1156: PPUSH
1157: PPUSH
1158: PPUSH
1159: PPUSH
// skill := [ 1 , 2 , 3 ] [ Difficulty ] ;
1160: LD_ADDR_VAR 0 2
1164: PUSH
1165: LD_INT 1
1167: PUSH
1168: LD_INT 2
1170: PUSH
1171: LD_INT 3
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: PUSH
1179: LD_OWVAR 67
1183: ARRAY
1184: ST_TO_ADDR
// uc_side := 3 ;
1185: LD_ADDR_OWVAR 20
1189: PUSH
1190: LD_INT 3
1192: ST_TO_ADDR
// uc_nation := 3 ;
1193: LD_ADDR_OWVAR 21
1197: PUSH
1198: LD_INT 3
1200: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
1201: LD_ADDR_EXP 25
1205: PUSH
1206: LD_STRING Pokryshkin
1208: PPUSH
1209: LD_INT 0
1211: PPUSH
1212: CALL 189 0 2
1216: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 44 , 5 , false ) ;
1217: LD_EXP 25
1221: PPUSH
1222: LD_INT 44
1224: PPUSH
1225: LD_INT 5
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 48
// hc_importance := 0 ;
1235: LD_ADDR_OWVAR 32
1239: PUSH
1240: LD_INT 0
1242: ST_TO_ADDR
// hc_gallery :=  ;
1243: LD_ADDR_OWVAR 33
1247: PUSH
1248: LD_STRING 
1250: ST_TO_ADDR
// hc_name :=  ;
1251: LD_ADDR_OWVAR 26
1255: PUSH
1256: LD_STRING 
1258: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
1259: LD_INT 1
1261: PPUSH
1262: LD_INT 1
1264: PPUSH
1265: LD_VAR 0 2
1269: PPUSH
1270: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1274: LD_ADDR_OWVAR 33
1278: PUSH
1279: LD_STRING SecondCharsGal
1281: ST_TO_ADDR
// hc_face_number := 69 ;
1282: LD_ADDR_OWVAR 34
1286: PUSH
1287: LD_INT 69
1289: ST_TO_ADDR
// hc_sex := sex_male ;
1290: LD_ADDR_OWVAR 27
1294: PUSH
1295: LD_INT 1
1297: ST_TO_ADDR
// hc_name := Ilja Ivanov ;
1298: LD_ADDR_OWVAR 26
1302: PUSH
1303: LD_STRING Ilja Ivanov
1305: ST_TO_ADDR
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 4
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 1 , un ) ;
1316: LD_ADDR_EXP 20
1320: PUSH
1321: LD_EXP 20
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_VAR 0 4
1333: PPUSH
1334: CALL_OW 2
1338: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 3
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 49
// PrepareHuman ( sex_male , 1 , skill ) ;
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 1
1359: PPUSH
1360: LD_VAR 0 2
1364: PPUSH
1365: CALL_OW 380
// hc_gallery := SecondCharsGal ;
1369: LD_ADDR_OWVAR 33
1373: PUSH
1374: LD_STRING SecondCharsGal
1376: ST_TO_ADDR
// hc_face_number := 70 ;
1377: LD_ADDR_OWVAR 34
1381: PUSH
1382: LD_INT 70
1384: ST_TO_ADDR
// hc_name := Pavel Starczy ;
1385: LD_ADDR_OWVAR 26
1389: PUSH
1390: LD_STRING Pavel Starczy
1392: ST_TO_ADDR
// un := CreateHuman ;
1393: LD_ADDR_VAR 0 4
1397: PUSH
1398: CALL_OW 44
1402: ST_TO_ADDR
// russian_troops_1 := Insert ( russian_troops_1 , 2 , un ) ;
1403: LD_ADDR_EXP 20
1407: PUSH
1408: LD_EXP 20
1412: PPUSH
1413: LD_INT 2
1415: PPUSH
1416: LD_VAR 0 4
1420: PPUSH
1421: CALL_OW 2
1425: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1426: LD_VAR 0 4
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: LD_INT 0
1436: PPUSH
1437: CALL_OW 49
// InitHc ;
1441: CALL_OW 19
// for i = 1 to 7 do
1445: LD_ADDR_VAR 0 3
1449: PUSH
1450: DOUBLE
1451: LD_INT 1
1453: DEC
1454: ST_TO_ADDR
1455: LD_INT 7
1457: PUSH
1458: FOR_TO
1459: IFFALSE 1610
// begin PrepareHuman ( false , 1 , skill ) ;
1461: LD_INT 0
1463: PPUSH
1464: LD_INT 1
1466: PPUSH
1467: LD_VAR 0 2
1471: PPUSH
1472: CALL_OW 380
// un := CreateHuman ;
1476: LD_ADDR_VAR 0 4
1480: PUSH
1481: CALL_OW 44
1485: ST_TO_ADDR
// if i mod 2 = 0 then
1486: LD_VAR 0 3
1490: PUSH
1491: LD_INT 2
1493: MOD
1494: PUSH
1495: LD_INT 0
1497: EQUAL
1498: IFFALSE 1555
// begin russian_troops_1 := Insert ( russian_troops_1 , russian_troops_1 + 1 , un ) ;
1500: LD_ADDR_EXP 20
1504: PUSH
1505: LD_EXP 20
1509: PPUSH
1510: LD_EXP 20
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// PlaceUnitArea ( un , guard_north , false ) ;
1529: LD_VAR 0 4
1533: PPUSH
1534: LD_INT 3
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: CALL_OW 49
// ComHold ( un ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: CALL_OW 140
// end else
1553: GO 1608
// begin russian_troops_2 := Insert ( russian_troops_2 , russian_troops_2 + 1 , un ) ;
1555: LD_ADDR_EXP 21
1559: PUSH
1560: LD_EXP 21
1564: PPUSH
1565: LD_EXP 21
1569: PUSH
1570: LD_INT 1
1572: PLUS
1573: PPUSH
1574: LD_VAR 0 4
1578: PPUSH
1579: CALL_OW 2
1583: ST_TO_ADDR
// PlaceUnitArea ( un , guard_south , false ) ;
1584: LD_VAR 0 4
1588: PPUSH
1589: LD_INT 4
1591: PPUSH
1592: LD_INT 0
1594: PPUSH
1595: CALL_OW 49
// ComHold ( un ) ;
1599: LD_VAR 0 4
1603: PPUSH
1604: CALL_OW 140
// end ; end ;
1608: GO 1458
1610: POP
1611: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) do
1612: LD_ADDR_VAR 0 3
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 3
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 30
1629: PUSH
1630: LD_INT 31
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: PPUSH
1641: CALL_OW 69
1645: PUSH
1646: FOR_IN
1647: IFFALSE 1665
// PrepareSolBun ( skill , i ) ;
1649: LD_VAR 0 2
1653: PPUSH
1654: LD_VAR 0 3
1658: PPUSH
1659: CALL 246 0 2
1663: GO 1646
1665: POP
1666: POP
// for i = 1 to 2 do
1667: LD_ADDR_VAR 0 3
1671: PUSH
1672: DOUBLE
1673: LD_INT 1
1675: DEC
1676: ST_TO_ADDR
1677: LD_INT 2
1679: PUSH
1680: FOR_TO
1681: IFFALSE 1812
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , ru_heavy_machine_gun , 100 ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_INT 3
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: LD_INT 22
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 1
1702: PPUSH
1703: LD_INT 42
1705: PPUSH
1706: LD_INT 100
1708: PPUSH
1709: CALL 382 0 7
1713: ST_TO_ADDR
// PrepareHuman ( false , 3 , skill ) ;
1714: LD_INT 0
1716: PPUSH
1717: LD_INT 3
1719: PPUSH
1720: LD_VAR 0 2
1724: PPUSH
1725: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
1729: CALL_OW 44
1733: PPUSH
1734: LD_VAR 0 4
1738: PPUSH
1739: CALL_OW 52
// PlaceUnitXY ( un , [ 23 , 131 ] [ i ] , [ 14 , 87 ] [ i ] , false ) ;
1743: LD_VAR 0 4
1747: PPUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 131
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_VAR 0 3
1762: ARRAY
1763: PPUSH
1764: LD_INT 14
1766: PUSH
1767: LD_INT 87
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: LD_VAR 0 3
1778: ARRAY
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 48
// russian_patrol_tanks := Insert ( russian_patrol_tanks , 1 , un ) ;
1787: LD_ADDR_EXP 22
1791: PUSH
1792: LD_EXP 22
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_VAR 0 4
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// end ;
1810: GO 1680
1812: POP
1813: POP
// for i = 1 to 2 do
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: DOUBLE
1820: LD_INT 1
1822: DEC
1823: ST_TO_ADDR
1824: LD_INT 2
1826: PUSH
1827: FOR_TO
1828: IFFALSE 1919
// begin PrepareHuman ( [ sex_female , sex_male , sex_male ] [ i ] , 1 , 1 ) ;
1830: LD_INT 2
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: PUSH
1844: LD_VAR 0 3
1848: ARRAY
1849: PPUSH
1850: LD_INT 1
1852: PPUSH
1853: LD_INT 1
1855: PPUSH
1856: CALL_OW 380
// un := CreateHuman ;
1860: LD_ADDR_VAR 0 4
1864: PUSH
1865: CALL_OW 44
1869: ST_TO_ADDR
// russian_meta_guards := Insert ( russian_meta_guards , 1 , un ) ;
1870: LD_ADDR_EXP 23
1874: PUSH
1875: LD_EXP 23
1879: PPUSH
1880: LD_INT 1
1882: PPUSH
1883: LD_VAR 0 4
1887: PPUSH
1888: CALL_OW 2
1892: ST_TO_ADDR
// PlaceUnitArea ( un , exitArea , false ) ;
1893: LD_VAR 0 4
1897: PPUSH
1898: LD_INT 10
1900: PPUSH
1901: LD_INT 0
1903: PPUSH
1904: CALL_OW 49
// ComHold ( un ) ;
1908: LD_VAR 0 4
1912: PPUSH
1913: CALL_OW 140
// end ;
1917: GO 1827
1919: POP
1920: POP
// if Difficulty < 3 then
1921: LD_OWVAR 67
1925: PUSH
1926: LD_INT 3
1928: LESS
1929: IFFALSE 1933
// exit ;
1931: GO 1976
// PrepareHuman ( false , 1 , skill ) ;
1933: LD_INT 0
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: LD_VAR 0 2
1943: PPUSH
1944: CALL_OW 380
// russian_patrol_forest := CreateHuman ;
1948: LD_ADDR_EXP 24
1952: PUSH
1953: CALL_OW 44
1957: ST_TO_ADDR
// PlaceUnitXY ( russian_patrol_forest , 82 , 2 , false ) ;
1958: LD_EXP 24
1962: PPUSH
1963: LD_INT 82
1965: PPUSH
1966: LD_INT 2
1968: PPUSH
1969: LD_INT 0
1971: PPUSH
1972: CALL_OW 48
// end ;
1976: LD_VAR 0 1
1980: RET
// every 0 0$01 trigger active_road_patrol do
1981: LD_EXP 8
1985: IFFALSE 2051
1987: GO 1989
1989: DISABLE
// ComPatrol ( russian_patrol_tanks [ 1 ] , road , 0 0$02 , [ 131 , 87 , 107 , 75 , 107 , 66 , 114 , 61 , 107 , 34 ] ) ;
1990: LD_EXP 22
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_STRING road
2001: PPUSH
2002: LD_INT 70
2004: PPUSH
2005: LD_INT 131
2007: PUSH
2008: LD_INT 87
2010: PUSH
2011: LD_INT 107
2013: PUSH
2014: LD_INT 75
2016: PUSH
2017: LD_INT 107
2019: PUSH
2020: LD_INT 66
2022: PUSH
2023: LD_INT 114
2025: PUSH
2026: LD_INT 61
2028: PUSH
2029: LD_INT 107
2031: PUSH
2032: LD_INT 34
2034: PUSH
2035: EMPTY
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 470 0 4
2051: END
// every 0 0$01 trigger active_road_patrol do
2052: LD_EXP 8
2056: IFFALSE 2114
2058: GO 2060
2060: DISABLE
// ComPatrol ( russian_patrol_tanks [ 2 ] , road , 0 0$02 , [ 21 , 12 , 37 , 30 , 65 , 62 , 107 , 76 ] ) ;
2061: LD_EXP 22
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: LD_STRING road
2072: PPUSH
2073: LD_INT 70
2075: PPUSH
2076: LD_INT 21
2078: PUSH
2079: LD_INT 12
2081: PUSH
2082: LD_INT 37
2084: PUSH
2085: LD_INT 30
2087: PUSH
2088: LD_INT 65
2090: PUSH
2091: LD_INT 62
2093: PUSH
2094: LD_INT 107
2096: PUSH
2097: LD_INT 76
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: PPUSH
2110: CALL 470 0 4
2114: END
// every 0 0$01 trigger IsOk ( russian_patrol_forest ) do
2115: LD_EXP 24
2119: PPUSH
2120: CALL_OW 302
2124: IFFALSE 2186
2126: GO 2128
2128: DISABLE
// ComPatrol ( russian_patrol_forest , forest , 0 0$01 , [ 52 , 15 , 81 , 9 , 120 , 52 , 135 , 80 , 122 , 95 ] ) ;
2129: LD_EXP 24
2133: PPUSH
2134: LD_STRING forest
2136: PPUSH
2137: LD_INT 35
2139: PPUSH
2140: LD_INT 52
2142: PUSH
2143: LD_INT 15
2145: PUSH
2146: LD_INT 81
2148: PUSH
2149: LD_INT 9
2151: PUSH
2152: LD_INT 120
2154: PUSH
2155: LD_INT 52
2157: PUSH
2158: LD_INT 135
2160: PUSH
2161: LD_INT 80
2163: PUSH
2164: LD_INT 122
2166: PUSH
2167: LD_INT 95
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL 470 0 4
2186: END
// every 0 0$01 trigger macmilan_use_radio do
2187: LD_EXP 6
2191: IFFALSE 2252
2193: GO 2195
2195: DISABLE
// begin active_road_patrol := false ;
2196: LD_ADDR_EXP 8
2200: PUSH
2201: LD_INT 0
2203: ST_TO_ADDR
// ComStop ( russian_patrol_tanks ) ;
2204: LD_EXP 22
2208: PPUSH
2209: CALL_OW 141
// AddComAgressiveMove ( russian_patrol_tanks , 72 , 41 ) ;
2213: LD_EXP 22
2217: PPUSH
2218: LD_INT 72
2220: PPUSH
2221: LD_INT 41
2223: PPUSH
2224: CALL_OW 174
// ComExitBuilding ( russian_troops_2 ) ;
2228: LD_EXP 21
2232: PPUSH
2233: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , 72 , 41 ) ;
2237: LD_EXP 21
2241: PPUSH
2242: LD_INT 72
2244: PPUSH
2245: LD_INT 41
2247: PPUSH
2248: CALL_OW 174
// end ;
2252: END
// every 0 0$03 trigger FilterUnitsInArea ( def_south , [ f_side , 1 ] ) do var un ;
2253: LD_INT 9
2255: PPUSH
2256: LD_INT 22
2258: PUSH
2259: LD_INT 1
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL_OW 70
2270: IFFALSE 2344
2272: GO 2274
2274: DISABLE
2275: LD_INT 0
2277: PPUSH
// begin enable ;
2278: ENABLE
// un := FilterUnitsInArea ( def_south , [ f_side , 1 ] ) [ 1 ] ;
2279: LD_ADDR_VAR 0 1
2283: PUSH
2284: LD_INT 9
2286: PPUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PPUSH
2297: CALL_OW 70
2301: PUSH
2302: LD_INT 1
2304: ARRAY
2305: ST_TO_ADDR
// ComExitBuilding ( russian_troops_2 ) ;
2306: LD_EXP 21
2310: PPUSH
2311: CALL_OW 122
// AddComAgressiveMove ( russian_troops_2 , GetX ( un ) , GetY ( un ) ) ;
2315: LD_EXP 21
2319: PPUSH
2320: LD_VAR 0 1
2324: PPUSH
2325: CALL_OW 250
2329: PPUSH
2330: LD_VAR 0 1
2334: PPUSH
2335: CALL_OW 251
2339: PPUSH
2340: CALL_OW 174
// end ;
2344: PPOPN 1
2346: END
// every 0 0$01 trigger ( GetLives ( russian_patrol_tanks [ 1 ] ) < 999 or GetLives ( russian_patrol_tanks [ 2 ] ) < 999 ) and See ( 3 , JMM ) do
2347: LD_EXP 22
2351: PUSH
2352: LD_INT 1
2354: ARRAY
2355: PPUSH
2356: CALL_OW 256
2360: PUSH
2361: LD_INT 999
2363: LESS
2364: PUSH
2365: LD_EXP 22
2369: PUSH
2370: LD_INT 2
2372: ARRAY
2373: PPUSH
2374: CALL_OW 256
2378: PUSH
2379: LD_INT 999
2381: LESS
2382: OR
2383: PUSH
2384: LD_INT 3
2386: PPUSH
2387: LD_EXP 15
2391: PPUSH
2392: CALL_OW 292
2396: AND
2397: IFFALSE 2424
2399: GO 2401
2401: DISABLE
// begin active_road_patrol := false ;
2402: LD_ADDR_EXP 8
2406: PUSH
2407: LD_INT 0
2409: ST_TO_ADDR
// ComAttackUnit ( russian_patrol_tanks , JMM ) ;
2410: LD_EXP 22
2414: PPUSH
2415: LD_EXP 15
2419: PPUSH
2420: CALL_OW 115
// end ;
2424: END
// every 0 0$01 trigger macmilan_in_trap do
2425: LD_EXP 9
2429: IFFALSE 2475
2431: GO 2433
2433: DISABLE
// begin ComExitBuilding ( russian_troops_2 ) ;
2434: LD_EXP 21
2438: PPUSH
2439: CALL_OW 122
// ComAttackUnit ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , JMM ) ;
2443: LD_EXP 20
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: PUSH
2454: LD_EXP 25
2458: ADD
2459: PUSH
2460: LD_EXP 22
2464: ADD
2465: PPUSH
2466: LD_EXP 15
2470: PPUSH
2471: CALL_OW 115
// end ;
2475: END
// every 0 0$01 trigger meta_action do
2476: LD_EXP 10
2480: IFFALSE 2526
2482: GO 2484
2484: DISABLE
// begin active_road_patrol := false ;
2485: LD_ADDR_EXP 8
2489: PUSH
2490: LD_INT 0
2492: ST_TO_ADDR
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 ^ Pokryshkin ^ russian_patrol_tanks , 93 , 1 ) ;
2493: LD_EXP 20
2497: PUSH
2498: LD_EXP 21
2502: ADD
2503: PUSH
2504: LD_EXP 25
2508: ADD
2509: PUSH
2510: LD_EXP 22
2514: ADD
2515: PPUSH
2516: LD_INT 93
2518: PPUSH
2519: LD_INT 1
2521: PPUSH
2522: CALL_OW 114
// end ;
2526: END
// every 0 0$1 trigger GetLives ( Pokryshkin ) < 1000 do
2527: LD_EXP 25
2531: PPUSH
2532: CALL_OW 256
2536: PUSH
2537: LD_INT 1000
2539: LESS
2540: IFFALSE 2591
2542: GO 2544
2544: DISABLE
// begin enable ;
2545: ENABLE
// if HexInfo ( 18 , 1 ) = Pokryshkin then
2546: LD_INT 18
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 428
2556: PUSH
2557: LD_EXP 25
2561: EQUAL
2562: IFFALSE 2576
// begin RemoveUnit ( Pokryshkin ) ;
2564: LD_EXP 25
2568: PPUSH
2569: CALL_OW 64
// disable ;
2573: DISABLE
// end else
2574: GO 2591
// ComMoveXY ( Pokryshkin , 18 , 1 ) ;
2576: LD_EXP 25
2580: PPUSH
2581: LD_INT 18
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: CALL_OW 111
// end ;
2591: END
// every 0 0$20 trigger send_troops_to_forest do
2592: LD_EXP 14
2596: IFFALSE 2650
2598: GO 2600
2600: DISABLE
// begin if not IsOk ( russian_patrol_forest ) then
2601: LD_EXP 24
2605: PPUSH
2606: CALL_OW 302
2610: NOT
2611: IFFALSE 2615
// exit ;
2613: GO 2650
// ComAgressiveMove ( russian_troops_1 ^ Pokryshkin , GetRememberedX ( russian_patrol_forest ) , GetRememberedY ( russian_patrol_forest ) ) ;
2615: LD_EXP 20
2619: PUSH
2620: LD_EXP 25
2624: ADD
2625: PPUSH
2626: LD_EXP 24
2630: PPUSH
2631: CALL_OW 252
2635: PPUSH
2636: LD_EXP 24
2640: PPUSH
2641: CALL_OW 253
2645: PPUSH
2646: CALL_OW 114
// end ;
2650: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do begin if GetSide ( driver ) = 3 then
2651: LD_VAR 0 1
2655: PPUSH
2656: CALL_OW 255
2660: PUSH
2661: LD_INT 3
2663: EQUAL
2664: IFFALSE 2707
// begin wait ( 11 ) ;
2666: LD_INT 11
2668: PPUSH
2669: CALL_OW 67
// ComEnterUnit ( driver , NearestUnitToUnit ( FilterAllUnits ( [ f_btype , b_depot ] ) , driver ) ) ;
2673: LD_VAR 0 1
2677: PPUSH
2678: LD_INT 30
2680: PUSH
2681: LD_INT 0
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL_OW 69
2692: PPUSH
2693: LD_VAR 0 1
2697: PPUSH
2698: CALL_OW 74
2702: PPUSH
2703: CALL_OW 120
// end ; end ; end_of_file
2707: PPOPN 4
2709: END
// export function Action ; var i ; begin
2710: LD_INT 0
2712: PPUSH
2713: PPUSH
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_INT 22
2721: PUSH
2722: LD_INT 3
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 25
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2762
// ComHold ( i ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: CALL_OW 140
2760: GO 2748
2762: POP
2763: POP
// InGameOn ;
2764: CALL_OW 8
// CenterOnXY ( 79 , 76 ) ;
2768: LD_INT 79
2770: PPUSH
2771: LD_INT 76
2773: PPUSH
2774: CALL_OW 84
// Wait ( 0 0$0.3 ) ;
2778: LD_INT 10
2780: PPUSH
2781: CALL_OW 67
// PlaceUnitXY ( JMM , 80 , 79 , true ) ;
2785: LD_EXP 15
2789: PPUSH
2790: LD_INT 80
2792: PPUSH
2793: LD_INT 79
2795: PPUSH
2796: LD_INT 1
2798: PPUSH
2799: CALL_OW 48
// Wait ( 0 0$03 ) ;
2803: LD_INT 105
2805: PPUSH
2806: CALL_OW 67
// ComMoveXY ( JMM , 80 , 76 ) ;
2810: LD_EXP 15
2814: PPUSH
2815: LD_INT 80
2817: PPUSH
2818: LD_INT 76
2820: PPUSH
2821: CALL_OW 111
// Say ( JMM , D1-JMM-1 ) ;
2825: LD_EXP 15
2829: PPUSH
2830: LD_STRING D1-JMM-1
2832: PPUSH
2833: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2837: LD_INT 10
2839: PPUSH
2840: CALL_OW 67
// ComMoveXY ( JMM , 76 , 76 ) ;
2844: LD_EXP 15
2848: PPUSH
2849: LD_INT 76
2851: PPUSH
2852: LD_INT 76
2854: PPUSH
2855: CALL_OW 111
// Say ( JMM , D1-JMM-1a ) ;
2859: LD_EXP 15
2863: PPUSH
2864: LD_STRING D1-JMM-1a
2866: PPUSH
2867: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2871: LD_INT 10
2873: PPUSH
2874: CALL_OW 67
// ComTurnXY ( JMM , 83 , 66 ) ;
2878: LD_EXP 15
2882: PPUSH
2883: LD_INT 83
2885: PPUSH
2886: LD_INT 66
2888: PPUSH
2889: CALL_OW 118
// Say ( JMM , D1-JMM-1b ) ;
2893: LD_EXP 15
2897: PPUSH
2898: LD_STRING D1-JMM-1b
2900: PPUSH
2901: CALL_OW 88
// Wait ( 0 0$0.5 ) ;
2905: LD_INT 18
2907: PPUSH
2908: CALL_OW 67
// Say ( JMM , D1-JMM-1c ) ;
2912: LD_EXP 15
2916: PPUSH
2917: LD_STRING D1-JMM-1c
2919: PPUSH
2920: CALL_OW 88
// Wait ( 0 0$0.2 ) ;
2924: LD_INT 7
2926: PPUSH
2927: CALL_OW 67
// SayRadio ( Powell , D1-Pow-1 ) ;
2931: LD_EXP 18
2935: PPUSH
2936: LD_STRING D1-Pow-1
2938: PPUSH
2939: CALL_OW 94
// Say ( JMM , D1-JMM-2 ) ;
2943: LD_EXP 15
2947: PPUSH
2948: LD_STRING D1-JMM-2
2950: PPUSH
2951: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
2955: LD_EXP 18
2959: PPUSH
2960: LD_STRING D1-Pow-2
2962: PPUSH
2963: CALL_OW 94
// Say ( JMM , D1-JMM-3 ) ;
2967: LD_EXP 15
2971: PPUSH
2972: LD_STRING D1-JMM-3
2974: PPUSH
2975: CALL_OW 88
// SayRadio ( Powell , D1-Pow-3 ) ;
2979: LD_EXP 18
2983: PPUSH
2984: LD_STRING D1-Pow-3
2986: PPUSH
2987: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
2991: LD_EXP 15
2995: PPUSH
2996: LD_STRING D1-JMM-4
2998: PPUSH
2999: CALL_OW 88
// ComFree ( JMM ) ;
3003: LD_EXP 15
3007: PPUSH
3008: CALL_OW 139
// Wait ( 0 0$0.3 ) ;
3012: LD_INT 10
3014: PPUSH
3015: CALL_OW 67
// InGameOff ;
3019: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3023: LD_STRING M1
3025: PPUSH
3026: CALL_OW 337
// SaveForQuickRestart ;
3030: CALL_OW 22
// active_russian_dialog := true ;
3034: LD_ADDR_EXP 3
3038: PUSH
3039: LD_INT 1
3041: ST_TO_ADDR
// active_road_patrol := true ;
3042: LD_ADDR_EXP 8
3046: PUSH
3047: LD_INT 1
3049: ST_TO_ADDR
// if Difficulty < 3 then
3050: LD_OWVAR 67
3054: PUSH
3055: LD_INT 3
3057: LESS
3058: IFFALSE 3089
// begin PlaceUnitXY ( Bobby , 41 , 71 , false ) ;
3060: LD_EXP 16
3064: PPUSH
3065: LD_INT 41
3067: PPUSH
3068: LD_INT 71
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 48
// ComHold ( Bobby ) ;
3078: LD_EXP 16
3082: PPUSH
3083: CALL_OW 140
// end else
3087: GO 3137
// begin SetDir ( Bobby , 5 ) ;
3089: LD_EXP 16
3093: PPUSH
3094: LD_INT 5
3096: PPUSH
3097: CALL_OW 233
// PlaceUnitXY ( Bobby , 105 , 98 , false ) ;
3101: LD_EXP 16
3105: PPUSH
3106: LD_INT 105
3108: PPUSH
3109: LD_INT 98
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 48
// ComCrawl ( Bobby ) ;
3119: LD_EXP 16
3123: PPUSH
3124: CALL_OW 137
// AddComHold ( Bobby ) ;
3128: LD_EXP 16
3132: PPUSH
3133: CALL_OW 200
// end ; PlaceUnitXY ( Cyrus , 90 , 42 , false ) ;
3137: LD_EXP 17
3141: PPUSH
3142: LD_INT 90
3144: PPUSH
3145: LD_INT 42
3147: PPUSH
3148: LD_INT 0
3150: PPUSH
3151: CALL_OW 48
// ComMoveXY ( Cyrus , 79 , 34 ) ;
3155: LD_EXP 17
3159: PPUSH
3160: LD_INT 79
3162: PPUSH
3163: LD_INT 34
3165: PPUSH
3166: CALL_OW 111
// AddComCrawl ( Cyrus ) ;
3170: LD_EXP 17
3174: PPUSH
3175: CALL_OW 197
// end ;
3179: LD_VAR 0 1
3183: RET
// every 0 0$01 trigger active_russian_dialog do var wait_points ;
3184: LD_EXP 3
3188: IFFALSE 3811
3190: GO 3192
3192: DISABLE
3193: LD_INT 0
3195: PPUSH
// begin wait_points := 0 ;
3196: LD_ADDR_VAR 0 1
3200: PUSH
3201: LD_INT 0
3203: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
3204: LD_INT 70
3206: PPUSH
3207: CALL_OW 67
// ComAgressiveMove ( russian_troops_1 , 79 , 83 ) ;
3211: LD_EXP 20
3215: PPUSH
3216: LD_INT 79
3218: PPUSH
3219: LD_INT 83
3221: PPUSH
3222: CALL_OW 114
// Say ( russian_troops_1 [ 2 ] , D1R-Rus1-1 ) ;
3226: LD_EXP 20
3230: PUSH
3231: LD_INT 2
3233: ARRAY
3234: PPUSH
3235: LD_STRING D1R-Rus1-1
3237: PPUSH
3238: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1R-Rus2-1 ) ;
3242: LD_EXP 20
3246: PUSH
3247: LD_INT 1
3249: ARRAY
3250: PPUSH
3251: LD_STRING D1R-Rus2-1
3253: PPUSH
3254: CALL_OW 88
// ComAgressiveMove ( russian_troops_2 , 91 , 80 ) ;
3258: LD_EXP 21
3262: PPUSH
3263: LD_INT 91
3265: PPUSH
3266: LD_INT 80
3268: PPUSH
3269: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3273: LD_INT 35
3275: PPUSH
3276: CALL_OW 67
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 79 , 82 ) < 5 ;
3280: LD_EXP 20
3284: PUSH
3285: LD_INT 1
3287: ARRAY
3288: PPUSH
3289: LD_INT 79
3291: PPUSH
3292: LD_INT 82
3294: PPUSH
3295: CALL_OW 297
3299: PUSH
3300: LD_INT 5
3302: LESS
3303: IFFALSE 3273
// if not IsInArea ( JMM , jmm_spot ) then
3305: LD_EXP 15
3309: PPUSH
3310: LD_INT 5
3312: PPUSH
3313: CALL_OW 308
3317: NOT
3318: IFFALSE 3338
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1 ) else
3320: LD_EXP 20
3324: PUSH
3325: LD_INT 1
3327: ARRAY
3328: PPUSH
3329: LD_STRING D1Ra-Rus2-1
3331: PPUSH
3332: CALL_OW 88
3336: GO 3474
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3338: LD_EXP 20
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PPUSH
3347: LD_STRING D1Rb-Rus1-1
3349: PPUSH
3350: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Rb-Rus2-1 ) ;
3354: LD_EXP 20
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: LD_STRING D1Rb-Rus2-1
3365: PPUSH
3366: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 ^ russian_troops_2 , GetX ( JMM ) , GetY ( JMM ) ) ;
3370: LD_EXP 20
3374: PUSH
3375: LD_EXP 21
3379: ADD
3380: PPUSH
3381: LD_EXP 15
3385: PPUSH
3386: CALL_OW 250
3390: PPUSH
3391: LD_EXP 15
3395: PPUSH
3396: CALL_OW 251
3400: PPUSH
3401: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
3405: LD_INT 35
3407: PPUSH
3408: CALL_OW 67
// until not IsInArea ( JMM , jmm_spot ) and not See ( 3 , jmm ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_INT 5
3419: PPUSH
3420: CALL_OW 308
3424: NOT
3425: PUSH
3426: LD_INT 3
3428: PPUSH
3429: LD_EXP 15
3433: PPUSH
3434: CALL_OW 292
3438: NOT
3439: AND
3440: IFFALSE 3405
// Say ( russian_troops_1 [ 2 ] , D1Rc-Rus1-1 ) ;
3442: LD_EXP 20
3446: PUSH
3447: LD_INT 2
3449: ARRAY
3450: PPUSH
3451: LD_STRING D1Rc-Rus1-1
3453: PPUSH
3454: CALL_OW 88
// Say ( russian_troops_1 [ 1 ] , D1Ra-Rus2-1a ) ;
3458: LD_EXP 20
3462: PUSH
3463: LD_INT 1
3465: ARRAY
3466: PPUSH
3467: LD_STRING D1Ra-Rus2-1a
3469: PPUSH
3470: CALL_OW 88
// end ; wait_points := 10 ;
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: LD_INT 10
3481: ST_TO_ADDR
// if Difficulty > 1 then
3482: LD_OWVAR 67
3486: PUSH
3487: LD_INT 1
3489: GREATER
3490: IFFALSE 3572
// begin ComAgressiveMove ( russian_troops_1 , 78 , 95 ) ;
3492: LD_EXP 20
3496: PPUSH
3497: LD_INT 78
3499: PPUSH
3500: LD_INT 95
3502: PPUSH
3503: CALL_OW 114
// AddComWait ( russian_troops_1 , 0 0$05 ) ;
3507: LD_EXP 20
3511: PPUSH
3512: LD_INT 175
3514: PPUSH
3515: CALL_OW 202
// wait_points := wait_points + 15 ;
3519: LD_ADDR_VAR 0 1
3523: PUSH
3524: LD_VAR 0 1
3528: PUSH
3529: LD_INT 15
3531: PLUS
3532: ST_TO_ADDR
// if Difficulty > 2 then
3533: LD_OWVAR 67
3537: PUSH
3538: LD_INT 2
3540: GREATER
3541: IFFALSE 3572
// begin AddComAgressiveMove ( russian_troops_1 , 65 , 79 ) ;
3543: LD_EXP 20
3547: PPUSH
3548: LD_INT 65
3550: PPUSH
3551: LD_INT 79
3553: PPUSH
3554: CALL_OW 174
// wait_points := wait_points + 5 ;
3558: LD_ADDR_VAR 0 1
3562: PUSH
3563: LD_VAR 0 1
3567: PUSH
3568: LD_INT 5
3570: PLUS
3571: ST_TO_ADDR
// end ; end ; repeat wait ( 0 0$01 ) ;
3572: LD_INT 35
3574: PPUSH
3575: CALL_OW 67
// wait_points := wait_points - 1 ;
3579: LD_ADDR_VAR 0 1
3583: PUSH
3584: LD_VAR 0 1
3588: PUSH
3589: LD_INT 1
3591: MINUS
3592: ST_TO_ADDR
// if See ( 3 , JMM ) then
3593: LD_INT 3
3595: PPUSH
3596: LD_EXP 15
3600: PPUSH
3601: CALL_OW 292
3605: IFFALSE 3659
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3607: LD_EXP 20
3611: PUSH
3612: LD_INT 2
3614: ARRAY
3615: PPUSH
3616: LD_STRING D1Rb-Rus1-1
3618: PPUSH
3619: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3623: LD_EXP 20
3627: PPUSH
3628: LD_EXP 15
3632: PPUSH
3633: CALL_OW 250
3637: PPUSH
3638: LD_EXP 15
3642: PPUSH
3643: CALL_OW 251
3647: PPUSH
3648: CALL_OW 114
// Wait ( 0 0$03 ) ;
3652: LD_INT 105
3654: PPUSH
3655: CALL_OW 67
// end ; until wait_points = 0 ;
3659: LD_VAR 0 1
3663: PUSH
3664: LD_INT 0
3666: EQUAL
3667: IFFALSE 3572
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3669: LD_EXP 20
3673: PPUSH
3674: LD_INT 45
3676: PPUSH
3677: LD_INT 5
3679: PPUSH
3680: CALL_OW 114
// ComEnterUnit ( russian_troops_2 , rbar1 ) ;
3684: LD_EXP 21
3688: PPUSH
3689: LD_INT 26
3691: PPUSH
3692: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
3696: LD_INT 35
3698: PPUSH
3699: CALL_OW 67
// if See ( 3 , JMM ) then
3703: LD_INT 3
3705: PPUSH
3706: LD_EXP 15
3710: PPUSH
3711: CALL_OW 292
3715: IFFALSE 3771
// begin Say ( russian_troops_1 [ 2 ] , D1Rb-Rus1-1 ) ;
3717: LD_EXP 20
3721: PUSH
3722: LD_INT 2
3724: ARRAY
3725: PPUSH
3726: LD_STRING D1Rb-Rus1-1
3728: PPUSH
3729: CALL_OW 88
// ComAgressiveMove ( russian_troops_1 , GetX ( JMM ) , GetY ( JMM ) ) ;
3733: LD_EXP 20
3737: PPUSH
3738: LD_EXP 15
3742: PPUSH
3743: CALL_OW 250
3747: PPUSH
3748: LD_EXP 15
3752: PPUSH
3753: CALL_OW 251
3757: PPUSH
3758: CALL_OW 114
// Wait ( 0 0$50 ) ;
3762: LD_INT 1750
3764: PPUSH
3765: CALL_OW 67
// end else
3769: GO 3786
// ComAgressiveMove ( russian_troops_1 , 45 , 5 ) ;
3771: LD_EXP 20
3775: PPUSH
3776: LD_INT 45
3778: PPUSH
3779: LD_INT 5
3781: PPUSH
3782: CALL_OW 114
// until GetDistUnitXY ( russian_troops_1 [ 1 ] , 45 , 5 ) < 10 ;
3786: LD_EXP 20
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: PPUSH
3795: LD_INT 45
3797: PPUSH
3798: LD_INT 5
3800: PPUSH
3801: CALL_OW 297
3805: PUSH
3806: LD_INT 10
3808: LESS
3809: IFFALSE 3696
// end ;
3811: PPOPN 1
3813: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 6 ] ] ) and Difficulty = 1 do
3814: LD_INT 22
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 92
3826: PUSH
3827: LD_INT 80
3829: PUSH
3830: LD_INT 83
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PPUSH
3846: CALL_OW 69
3850: PUSH
3851: LD_OWVAR 67
3855: PUSH
3856: LD_INT 1
3858: EQUAL
3859: AND
3860: IFFALSE 3941
3862: GO 3864
3864: DISABLE
// begin PlaceSeeing ( 80 , 83 , 1 , - 7 ) ;
3865: LD_INT 80
3867: PPUSH
3868: LD_INT 83
3870: PPUSH
3871: LD_INT 1
3873: PPUSH
3874: LD_INT 7
3876: NEG
3877: PPUSH
3878: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
3882: LD_INT 35
3884: PPUSH
3885: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 80 , 83 , 10 ] ] ) ;
3889: LD_INT 22
3891: PUSH
3892: LD_INT 3
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PUSH
3899: LD_INT 92
3901: PUSH
3902: LD_INT 80
3904: PUSH
3905: LD_INT 83
3907: PUSH
3908: LD_INT 10
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: PUSH
3917: EMPTY
3918: LIST
3919: LIST
3920: PPUSH
3921: CALL_OW 69
3925: NOT
3926: IFFALSE 3882
// RemoveSeeing ( 80 , 83 , 1 ) ;
3928: LD_INT 80
3930: PPUSH
3931: LD_INT 83
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 331
// end ;
3941: END
// every 0 0$02 trigger GetDistUnits ( JMM , Bobby ) < 9 and IsOk ( Bobby ) do
3942: LD_EXP 15
3946: PPUSH
3947: LD_EXP 16
3951: PPUSH
3952: CALL_OW 296
3956: PUSH
3957: LD_INT 9
3959: LESS
3960: PUSH
3961: LD_EXP 16
3965: PPUSH
3966: CALL_OW 302
3970: AND
3971: IFFALSE 4422
3973: GO 3975
3975: DISABLE
// begin ComWalk ( Bobby ) ;
3976: LD_EXP 16
3980: PPUSH
3981: CALL_OW 138
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
3985: LD_EXP 16
3989: PPUSH
3990: LD_EXP 15
3994: PPUSH
3995: CALL_OW 250
3999: PPUSH
4000: LD_EXP 15
4004: PPUSH
4005: CALL_OW 251
4009: PPUSH
4010: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
4014: LD_INT 35
4016: PPUSH
4017: CALL_OW 67
// until See ( 4 , JMM ) ;
4021: LD_INT 4
4023: PPUSH
4024: LD_EXP 15
4028: PPUSH
4029: CALL_OW 292
4033: IFFALSE 4014
// InGameOn ;
4035: CALL_OW 8
// ComTurnUnit ( JMM , Bobby ) ;
4039: LD_EXP 15
4043: PPUSH
4044: LD_EXP 16
4048: PPUSH
4049: CALL_OW 119
// if cyrus_in_squad and IsOk ( Cyrus ) and GetDistUnits ( JMM , Cyrus ) < 10 then
4053: LD_EXP 7
4057: PUSH
4058: LD_EXP 17
4062: PPUSH
4063: CALL_OW 302
4067: AND
4068: PUSH
4069: LD_EXP 15
4073: PPUSH
4074: LD_EXP 17
4078: PPUSH
4079: CALL_OW 296
4083: PUSH
4084: LD_INT 10
4086: LESS
4087: AND
4088: IFFALSE 4133
// begin ComMoveXY ( Cyrus , GetX ( JMM ) , GetY ( JMM ) ) ;
4090: LD_EXP 17
4094: PPUSH
4095: LD_EXP 15
4099: PPUSH
4100: CALL_OW 250
4104: PPUSH
4105: LD_EXP 15
4109: PPUSH
4110: CALL_OW 251
4114: PPUSH
4115: CALL_OW 111
// AddComTurnUnit ( Cyrus , Bobby ) ;
4119: LD_EXP 17
4123: PPUSH
4124: LD_EXP 16
4128: PPUSH
4129: CALL_OW 179
// end ; Say ( JMM , D2-JMM-1 ) ;
4133: LD_EXP 15
4137: PPUSH
4138: LD_STRING D2-JMM-1
4140: PPUSH
4141: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4145: LD_INT 10
4147: PPUSH
4148: CALL_OW 67
// ComTurnUnit ( Bobby , JMM ) ;
4152: LD_EXP 16
4156: PPUSH
4157: LD_EXP 15
4161: PPUSH
4162: CALL_OW 119
// Say ( Bobby , D2-Bobby-1 ) ;
4166: LD_EXP 16
4170: PPUSH
4171: LD_STRING D2-Bobby-1
4173: PPUSH
4174: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
4178: LD_EXP 15
4182: PPUSH
4183: LD_STRING D2-JMM-2
4185: PPUSH
4186: CALL_OW 88
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
4190: LD_EXP 16
4194: PPUSH
4195: LD_EXP 15
4199: PPUSH
4200: CALL_OW 250
4204: PPUSH
4205: LD_EXP 15
4209: PPUSH
4210: CALL_OW 251
4214: PPUSH
4215: CALL_OW 111
// Say ( Bobby , D2-Bobby-2 ) ;
4219: LD_EXP 16
4223: PPUSH
4224: LD_STRING D2-Bobby-2
4226: PPUSH
4227: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
4231: LD_EXP 15
4235: PPUSH
4236: LD_STRING D2-JMM-3
4238: PPUSH
4239: CALL_OW 88
// ComTurnUnit ( Bobby , JMM ) ;
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 15
4252: PPUSH
4253: CALL_OW 119
// Say ( Bobby , D2-Bobby-3 ) ;
4257: LD_EXP 16
4261: PPUSH
4262: LD_STRING D2-Bobby-3
4264: PPUSH
4265: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
4269: LD_EXP 15
4273: PPUSH
4274: LD_STRING D2-JMM-4
4276: PPUSH
4277: CALL_OW 88
// Say ( Bobby , D2-Bobby-4 ) ;
4281: LD_EXP 16
4285: PPUSH
4286: LD_STRING D2-Bobby-4
4288: PPUSH
4289: CALL_OW 88
// Say ( JMM , D2-JMM-5 ) ;
4293: LD_EXP 15
4297: PPUSH
4298: LD_STRING D2-JMM-5
4300: PPUSH
4301: CALL_OW 88
// Say ( Bobby , D2-Bobby-5 ) ;
4305: LD_EXP 16
4309: PPUSH
4310: LD_STRING D2-Bobby-5
4312: PPUSH
4313: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
4317: LD_EXP 15
4321: PPUSH
4322: LD_STRING D2-JMM-6
4324: PPUSH
4325: CALL_OW 88
// if not powell_contact then
4329: LD_EXP 5
4333: NOT
4334: IFFALSE 4360
// begin Say ( Bobby , D2-Bobby-6 ) ;
4336: LD_EXP 16
4340: PPUSH
4341: LD_STRING D2-Bobby-6
4343: PPUSH
4344: CALL_OW 88
// Say ( JMM , D2-JMM-7 ) ;
4348: LD_EXP 15
4352: PPUSH
4353: LD_STRING D2-JMM-7
4355: PPUSH
4356: CALL_OW 88
// end ; InGameOff ;
4360: CALL_OW 9
// SetSide ( Bobby , 1 ) ;
4364: LD_EXP 16
4368: PPUSH
4369: LD_INT 1
4371: PPUSH
4372: CALL_OW 235
// ComFree ( [ JMM , Bobby ] ) ;
4376: LD_EXP 15
4380: PUSH
4381: LD_EXP 16
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PPUSH
4390: CALL_OW 139
// bobby_in_squad := true ;
4394: LD_ADDR_EXP 4
4398: PUSH
4399: LD_INT 1
4401: ST_TO_ADDR
// if powell_contact and not cyrus_in_squad then
4402: LD_EXP 5
4406: PUSH
4407: LD_EXP 7
4411: NOT
4412: AND
4413: IFFALSE 4422
// ChangeMissionObjectives ( M2b ) ;
4415: LD_STRING M2b
4417: PPUSH
4418: CALL_OW 337
// end ;
4422: END
// every 0 0$45 trigger active_russian_dialog and not bobby_in_squad and Difficulty < 3 do
4423: LD_EXP 3
4427: PUSH
4428: LD_EXP 4
4432: NOT
4433: AND
4434: PUSH
4435: LD_OWVAR 67
4439: PUSH
4440: LD_INT 3
4442: LESS
4443: AND
4444: IFFALSE 4464
4446: GO 4448
4448: DISABLE
// ComMoveXY ( Bobby , 75 , 83 ) ;
4449: LD_EXP 16
4453: PPUSH
4454: LD_INT 75
4456: PPUSH
4457: LD_INT 83
4459: PPUSH
4460: CALL_OW 111
4464: END
// every 0 0$10 trigger cyrus_in_squad and not bobby_in_squad do
4465: LD_EXP 7
4469: PUSH
4470: LD_EXP 4
4474: NOT
4475: AND
4476: IFFALSE 4505
4478: GO 4480
4480: DISABLE
// begin ComMoveXY ( Bobby , 105 , 97 ) ;
4481: LD_EXP 16
4485: PPUSH
4486: LD_INT 105
4488: PPUSH
4489: LD_INT 97
4491: PPUSH
4492: CALL_OW 111
// AddComCrawl ( Bobby ) ;
4496: LD_EXP 16
4500: PPUSH
4501: CALL_OW 197
// end ;
4505: END
// every 0 0$01 trigger IsInArea ( JMM , obstacle_area ) and GetDistUnits ( JMM , Bobby ) < 7 and bobby_in_squad do
4506: LD_EXP 15
4510: PPUSH
4511: LD_INT 6
4513: PPUSH
4514: CALL_OW 308
4518: PUSH
4519: LD_EXP 15
4523: PPUSH
4524: LD_EXP 16
4528: PPUSH
4529: CALL_OW 296
4533: PUSH
4534: LD_INT 7
4536: LESS
4537: AND
4538: PUSH
4539: LD_EXP 4
4543: AND
4544: IFFALSE 4591
4546: GO 4548
4548: DISABLE
// begin ComHold ( [ JMM , Bobby ] ) ;
4549: LD_EXP 15
4553: PUSH
4554: LD_EXP 16
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PPUSH
4563: CALL_OW 140
// Say ( JMM , D2a-JMM-1 ) ;
4567: LD_EXP 15
4571: PPUSH
4572: LD_STRING D2a-JMM-1
4574: PPUSH
4575: CALL_OW 88
// Say ( Bobby , D2a-Bobby-1 ) ;
4579: LD_EXP 16
4583: PPUSH
4584: LD_STRING D2a-Bobby-1
4586: PPUSH
4587: CALL_OW 88
// end ;
4591: END
// every 0 0$50 trigger active_russian_dialog and not See ( 3 , JMM ) do
4592: LD_EXP 3
4596: PUSH
4597: LD_INT 3
4599: PPUSH
4600: LD_EXP 15
4604: PPUSH
4605: CALL_OW 292
4609: NOT
4610: AND
4611: IFFALSE 4787
4613: GO 4615
4615: DISABLE
// begin Wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
4616: LD_INT 350
4618: PPUSH
4619: LD_INT 700
4621: PPUSH
4622: CALL_OW 12
4626: PPUSH
4627: CALL_OW 67
// InGameOn ;
4631: CALL_OW 8
// DialogueOn ;
4635: CALL_OW 6
// SayRadio ( Powell , D3-Pow-1 ) ;
4639: LD_EXP 18
4643: PPUSH
4644: LD_STRING D3-Pow-1
4646: PPUSH
4647: CALL_OW 94
// Say ( JMM , D3-JMM-1 ) ;
4651: LD_EXP 15
4655: PPUSH
4656: LD_STRING D3-JMM-1
4658: PPUSH
4659: CALL_OW 88
// SayRadio ( Powell , D3-Pow-2 ) ;
4663: LD_EXP 18
4667: PPUSH
4668: LD_STRING D3-Pow-2
4670: PPUSH
4671: CALL_OW 94
// Say ( JMM , D3-JMM-2 ) ;
4675: LD_EXP 15
4679: PPUSH
4680: LD_STRING D3-JMM-2
4682: PPUSH
4683: CALL_OW 88
// SayRadio ( Powell , D3-Pow-3 ) ;
4687: LD_EXP 18
4691: PPUSH
4692: LD_STRING D3-Pow-3
4694: PPUSH
4695: CALL_OW 94
// DialogueOff ;
4699: CALL_OW 7
// InGameOff ;
4703: CALL_OW 9
// powell_contact := true ;
4707: LD_ADDR_EXP 5
4711: PUSH
4712: LD_INT 1
4714: ST_TO_ADDR
// SetAreaMapShow ( exitArea , 1 ) ;
4715: LD_INT 10
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: CALL_OW 424
// uc_side := 4 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 4
4732: ST_TO_ADDR
// uc_nation := 1 ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 1
4740: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
4741: LD_ADDR_EXP 18
4745: PUSH
4746: LD_STRING Powell
4748: PPUSH
4749: LD_INT 0
4751: PPUSH
4752: CALL 189 0 2
4756: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
4757: LD_STRING M2
4759: PPUSH
4760: CALL_OW 337
// if not bobby_in_squad then
4764: LD_EXP 4
4768: NOT
4769: IFFALSE 4780
// ChangeMissionObjectives ( M2a ) else
4771: LD_STRING M2a
4773: PPUSH
4774: CALL_OW 337
4778: GO 4787
// ChangeMissionObjectives ( M2b ) ;
4780: LD_STRING M2b
4782: PPUSH
4783: CALL_OW 337
// end ;
4787: END
// every 0 0$01 trigger IsInArea ( JMM , fakeArea ) do
4788: LD_EXP 15
4792: PPUSH
4793: LD_INT 7
4795: PPUSH
4796: CALL_OW 308
4800: IFFALSE 4935
4802: GO 4804
4804: DISABLE
// begin DialogueOn ;
4805: CALL_OW 6
// SayRadio ( fakePokryshkin , D4-Rus3-1 ) ;
4809: LD_EXP 19
4813: PPUSH
4814: LD_STRING D4-Rus3-1
4816: PPUSH
4817: CALL_OW 94
// DialogueOff ;
4821: CALL_OW 7
// ChangeMissionObjectives ( M3a ) ;
4825: LD_STRING M3a
4827: PPUSH
4828: CALL_OW 337
// SetAreaMapShow ( fakeEnd , 1 ) ;
4832: LD_INT 11
4834: PPUSH
4835: LD_INT 1
4837: PPUSH
4838: CALL_OW 424
// Wait ( 0 0$02 ) ;
4842: LD_INT 70
4844: PPUSH
4845: CALL_OW 67
// DialogueOn ;
4849: CALL_OW 6
// SayRadio ( Powell , D4-Pow-1 ) ;
4853: LD_EXP 18
4857: PPUSH
4858: LD_STRING D4-Pow-1
4860: PPUSH
4861: CALL_OW 94
// DialogueOff ;
4865: CALL_OW 7
// ChangeMissionObjectives ( M3b ) ;
4869: LD_STRING M3b
4871: PPUSH
4872: CALL_OW 337
// case Query ( Q1 ) of 1 :
4876: LD_STRING Q1
4878: PPUSH
4879: CALL_OW 97
4883: PUSH
4884: LD_INT 1
4886: DOUBLE
4887: EQUAL
4888: IFTRUE 4892
4890: GO 4923
4892: POP
// begin macmilan_use_radio := true ;
4893: LD_ADDR_EXP 6
4897: PUSH
4898: LD_INT 1
4900: ST_TO_ADDR
// DialogueOn ;
4901: CALL_OW 6
// Say ( JMM , D4a-JMM-1 ) ;
4905: LD_EXP 15
4909: PPUSH
4910: LD_STRING D4a-JMM-1
4912: PPUSH
4913: CALL_OW 88
// DialogueOff ;
4917: CALL_OW 7
// end ; 2 :
4921: GO 4935
4923: LD_INT 2
4925: DOUBLE
4926: EQUAL
4927: IFTRUE 4931
4929: GO 4934
4931: POP
// ; end ;
4932: GO 4935
4934: POP
// end ;
4935: END
// every 0 0$02 trigger GetDistUnits ( JMM , Cyrus ) < 8 and IsOk ( Cyrus ) do
4936: LD_EXP 15
4940: PPUSH
4941: LD_EXP 17
4945: PPUSH
4946: CALL_OW 296
4950: PUSH
4951: LD_INT 8
4953: LESS
4954: PUSH
4955: LD_EXP 17
4959: PPUSH
4960: CALL_OW 302
4964: AND
4965: IFFALSE 5256
4967: GO 4969
4969: DISABLE
// begin InGameOn ;
4970: CALL_OW 8
// ComMoveXY ( JMM , GetX ( Cyrus ) , GetY ( Cyrus ) ) ;
4974: LD_EXP 15
4978: PPUSH
4979: LD_EXP 17
4983: PPUSH
4984: CALL_OW 250
4988: PPUSH
4989: LD_EXP 17
4993: PPUSH
4994: CALL_OW 251
4998: PPUSH
4999: CALL_OW 111
// if IsOk ( Bobby ) and bobby_in_squad then
5003: LD_EXP 16
5007: PPUSH
5008: CALL_OW 302
5012: PUSH
5013: LD_EXP 4
5017: AND
5018: IFFALSE 5049
// ComMoveXY ( Bobby , GetX ( JMM ) , GetY ( JMM ) ) ;
5020: LD_EXP 16
5024: PPUSH
5025: LD_EXP 15
5029: PPUSH
5030: CALL_OW 250
5034: PPUSH
5035: LD_EXP 15
5039: PPUSH
5040: CALL_OW 251
5044: PPUSH
5045: CALL_OW 111
// Say ( JMM , D5-JMM-1 ) ;
5049: LD_EXP 15
5053: PPUSH
5054: LD_STRING D5-JMM-1
5056: PPUSH
5057: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5061: LD_INT 10
5063: PPUSH
5064: CALL_OW 67
// ComTurnUnit ( JMM , Cyrus ) ;
5068: LD_EXP 15
5072: PPUSH
5073: LD_EXP 17
5077: PPUSH
5078: CALL_OW 119
// ComWalk ( Cyrus ) ;
5082: LD_EXP 17
5086: PPUSH
5087: CALL_OW 138
// ComTurnUnit ( Cyrus , JMM ) ;
5091: LD_EXP 17
5095: PPUSH
5096: LD_EXP 15
5100: PPUSH
5101: CALL_OW 119
// Say ( Cyrus , D5-Cyrus-1 ) ;
5105: LD_EXP 17
5109: PPUSH
5110: LD_STRING D5-Cyrus-1
5112: PPUSH
5113: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5117: LD_EXP 16
5121: PPUSH
5122: CALL_OW 302
5126: PUSH
5127: LD_EXP 4
5131: AND
5132: IFFALSE 5172
// begin ComTurnUnit ( Bobby , Cyrus ) ;
5134: LD_EXP 16
5138: PPUSH
5139: LD_EXP 17
5143: PPUSH
5144: CALL_OW 119
// Say ( Bobby , D5-Bobby-1 ) ;
5148: LD_EXP 16
5152: PPUSH
5153: LD_STRING D5-Bobby-1
5155: PPUSH
5156: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
5160: LD_EXP 15
5164: PPUSH
5165: LD_STRING D5-JMM-2
5167: PPUSH
5168: CALL_OW 88
// end ; InGameOff ;
5172: CALL_OW 9
// cyrus_in_squad := true ;
5176: LD_ADDR_EXP 7
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// SetSide ( Cyrus , 1 ) ;
5184: LD_EXP 17
5188: PPUSH
5189: LD_INT 1
5191: PPUSH
5192: CALL_OW 235
// if powell_contact and not bobby_in_squad then
5196: LD_EXP 5
5200: PUSH
5201: LD_EXP 4
5205: NOT
5206: AND
5207: IFFALSE 5216
// ChangeMissionObjectives ( M2b ) ;
5209: LD_STRING M2b
5211: PPUSH
5212: CALL_OW 337
// if not bobby_in_squad and GetSide ( Bobby ) = 4 and IsOk ( Bobby ) then
5216: LD_EXP 4
5220: NOT
5221: PUSH
5222: LD_EXP 16
5226: PPUSH
5227: CALL_OW 255
5231: PUSH
5232: LD_INT 4
5234: EQUAL
5235: AND
5236: PUSH
5237: LD_EXP 16
5241: PPUSH
5242: CALL_OW 302
5246: AND
5247: IFFALSE 5256
// SetAchievement ( ACH_CYRUS ) ;
5249: LD_STRING ACH_CYRUS
5251: PPUSH
5252: CALL_OW 543
// end ;
5256: END
// every 0 0$01 trigger bobby_in_squad and cyrus_in_squad do
5257: LD_EXP 4
5261: PUSH
5262: LD_EXP 7
5266: AND
5267: IFFALSE 5279
5269: GO 5271
5271: DISABLE
// ChangeMissionObjectives ( M2c ) ;
5272: LD_STRING M2c
5274: PPUSH
5275: CALL_OW 337
5279: END
// every 0 0$01 trigger IsInArea ( JMM , trap ) do
5280: LD_EXP 15
5284: PPUSH
5285: LD_INT 8
5287: PPUSH
5288: CALL_OW 308
5292: IFFALSE 5344
5294: GO 5296
5296: DISABLE
// begin macmilan_in_trap := true ;
5297: LD_ADDR_EXP 9
5301: PUSH
5302: LD_INT 1
5304: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5305: LD_INT 35
5307: PPUSH
5308: CALL_OW 67
// DialogueOn ;
5312: CALL_OW 6
// Say ( Pokryshkin , D5-Pok-1 ) ;
5316: LD_EXP 25
5320: PPUSH
5321: LD_STRING D5-Pok-1
5323: PPUSH
5324: CALL_OW 88
// DialogueOff ;
5328: CALL_OW 7
// Say ( JMM , D4b-JMM-1 ) ;
5332: LD_EXP 15
5336: PPUSH
5337: LD_STRING D4b-JMM-1
5339: PPUSH
5340: CALL_OW 88
// end ;
5344: END
// every 0 0$01 trigger GetDistUnits ( JMM , russian_meta_guards [ russian_meta_guards ] ) < 12 or UnitFilter ( russian_meta_guards , [ f_not , [ f_lives , 990 ] ] ) do var i , hp ;
5345: LD_EXP 15
5349: PPUSH
5350: LD_EXP 23
5354: PUSH
5355: LD_EXP 23
5359: ARRAY
5360: PPUSH
5361: CALL_OW 296
5365: PUSH
5366: LD_INT 12
5368: LESS
5369: PUSH
5370: LD_EXP 23
5374: PPUSH
5375: LD_INT 3
5377: PUSH
5378: LD_INT 24
5380: PUSH
5381: LD_INT 990
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PPUSH
5392: CALL_OW 72
5396: OR
5397: IFFALSE 5627
5399: GO 5401
5401: DISABLE
5402: LD_INT 0
5404: PPUSH
5405: PPUSH
// begin hp := [ 300 , 250 , 200 ] [ Difficulty ] ;
5406: LD_ADDR_VAR 0 2
5410: PUSH
5411: LD_INT 300
5413: PUSH
5414: LD_INT 250
5416: PUSH
5417: LD_INT 200
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: LIST
5424: PUSH
5425: LD_OWVAR 67
5429: ARRAY
5430: ST_TO_ADDR
// for i in russian_meta_guards do
5431: LD_ADDR_VAR 0 1
5435: PUSH
5436: LD_EXP 23
5440: PUSH
5441: FOR_IN
5442: IFFALSE 5482
// if IsOk ( i ) then
5444: LD_VAR 0 1
5448: PPUSH
5449: CALL_OW 302
5453: IFFALSE 5480
// SetLives ( i , GetLives ( i ) - hp ) ;
5455: LD_VAR 0 1
5459: PPUSH
5460: LD_VAR 0 1
5464: PPUSH
5465: CALL_OW 256
5469: PUSH
5470: LD_VAR 0 2
5474: MINUS
5475: PPUSH
5476: CALL_OW 234
5480: GO 5441
5482: POP
5483: POP
// DialogueOn ;
5484: CALL_OW 6
// Say ( russian_meta_guards [ russian_meta_guards ] , D6-FRus1-1 ) ;
5488: LD_EXP 23
5492: PUSH
5493: LD_EXP 23
5497: ARRAY
5498: PPUSH
5499: LD_STRING D6-FRus1-1
5501: PPUSH
5502: CALL_OW 88
// Say ( JMM , D6-JMM-1 ) ;
5506: LD_EXP 15
5510: PPUSH
5511: LD_STRING D6-JMM-1
5513: PPUSH
5514: CALL_OW 88
// if IsOk ( Cyrus ) and cyrus_in_squad then
5518: LD_EXP 17
5522: PPUSH
5523: CALL_OW 302
5527: PUSH
5528: LD_EXP 7
5532: AND
5533: IFFALSE 5547
// Say ( Cyrus , D6-Cyrus-1 ) ;
5535: LD_EXP 17
5539: PPUSH
5540: LD_STRING D6-Cyrus-1
5542: PPUSH
5543: CALL_OW 88
// if IsOk ( Bobby ) and bobby_in_squad then
5547: LD_EXP 16
5551: PPUSH
5552: CALL_OW 302
5556: PUSH
5557: LD_EXP 4
5561: AND
5562: IFFALSE 5576
// Say ( Bobby , D6-Bobby-1 ) ;
5564: LD_EXP 16
5568: PPUSH
5569: LD_STRING D6-Bobby-1
5571: PPUSH
5572: CALL_OW 88
// DialogueOff ;
5576: CALL_OW 7
// Wait ( [ 0 0$04 , 0 0$03 , 0 0$02 ] [ Difficulty ] ) ;
5580: LD_INT 140
5582: PUSH
5583: LD_INT 105
5585: PUSH
5586: LD_INT 70
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: PUSH
5594: LD_OWVAR 67
5598: ARRAY
5599: PPUSH
5600: CALL_OW 67
// meta_action := true ;
5604: LD_ADDR_EXP 10
5608: PUSH
5609: LD_INT 1
5611: ST_TO_ADDR
// ComAgressiveMove ( russian_meta_guards , 94 , 8 ) ;
5612: LD_EXP 23
5616: PPUSH
5617: LD_INT 94
5619: PPUSH
5620: LD_INT 8
5622: PPUSH
5623: CALL_OW 114
// end ;
5627: PPOPN 2
5629: END
// every 0 0$01 trigger GetDistUnitXY ( JMM , 93 , 1 ) < 5 and FilterAllUnits ( [ f_side , 1 ] ) > 1 do
5630: LD_EXP 15
5634: PPUSH
5635: LD_INT 93
5637: PPUSH
5638: LD_INT 1
5640: PPUSH
5641: CALL_OW 297
5645: PUSH
5646: LD_INT 5
5648: LESS
5649: PUSH
5650: LD_INT 22
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PPUSH
5660: CALL_OW 69
5664: PUSH
5665: LD_INT 1
5667: GREATER
5668: AND
5669: IFFALSE 5686
5671: GO 5673
5673: DISABLE
// Say ( JMM , D6a-JMM-1 ) ;
5674: LD_EXP 15
5678: PPUSH
5679: LD_STRING D6a-JMM-1
5681: PPUSH
5682: CALL_OW 88
5686: END
// on UnitGoesToRed ( un ) do begin if un = JMM then
5687: LD_VAR 0 1
5691: PUSH
5692: LD_EXP 15
5696: EQUAL
5697: IFFALSE 5706
// YouLost ( JMM ) ;
5699: LD_STRING JMM
5701: PPUSH
5702: CALL_OW 104
// end ;
5706: PPOPN 1
5708: END
// on UnitDestroyed ( un ) do begin if un = JMM then
5709: LD_VAR 0 1
5713: PUSH
5714: LD_EXP 15
5718: EQUAL
5719: IFFALSE 5728
// YouLost ( JMM ) ;
5721: LD_STRING JMM
5723: PPUSH
5724: CALL_OW 104
// end ;
5728: PPOPN 1
5730: END
// every 0 0$01 trigger IsInArea ( Bobby , exitArea ) do
5731: LD_EXP 16
5735: PPUSH
5736: LD_INT 10
5738: PPUSH
5739: CALL_OW 308
5743: IFFALSE 5792
5745: GO 5747
5747: DISABLE
// begin bobby_saved := true ;
5748: LD_ADDR_EXP 12
5752: PUSH
5753: LD_INT 1
5755: ST_TO_ADDR
// SaveVariable ( GetLives ( Bobby ) , 01_BobbyLifePoints_1 ) ;
5756: LD_EXP 16
5760: PPUSH
5761: CALL_OW 256
5765: PPUSH
5766: LD_STRING 01_BobbyLifePoints_1
5768: PPUSH
5769: CALL_OW 39
// RemoveUnit ( Bobby ) ;
5773: LD_EXP 16
5777: PPUSH
5778: CALL_OW 64
// AddMedal ( Bobby , 1 ) ;
5782: LD_STRING Bobby
5784: PPUSH
5785: LD_INT 1
5787: PPUSH
5788: CALL_OW 101
// end ;
5792: END
// every 0 0$01 trigger IsInArea ( Cyrus , exitArea ) do
5793: LD_EXP 17
5797: PPUSH
5798: LD_INT 10
5800: PPUSH
5801: CALL_OW 308
5805: IFFALSE 5854
5807: GO 5809
5809: DISABLE
// begin cyrus_saved := true ;
5810: LD_ADDR_EXP 13
5814: PUSH
5815: LD_INT 1
5817: ST_TO_ADDR
// SaveVariable ( GetLives ( Cyrus ) , 01_CyrusLifePoints_1 ) ;
5818: LD_EXP 17
5822: PPUSH
5823: CALL_OW 256
5827: PPUSH
5828: LD_STRING 01_CyrusLifePoints_1
5830: PPUSH
5831: CALL_OW 39
// RemoveUnit ( Cyrus ) ;
5835: LD_EXP 17
5839: PPUSH
5840: CALL_OW 64
// AddMedal ( Cyrus , 1 ) ;
5844: LD_STRING Cyrus
5846: PPUSH
5847: LD_INT 1
5849: PPUSH
5850: CALL_OW 101
// end ;
5854: END
// every 0 0$01 trigger IsInArea ( JMM , exitArea ) do var i , to_reward , wait_for_them , m1 , m2 , m3 ;
5855: LD_EXP 15
5859: PPUSH
5860: LD_INT 10
5862: PPUSH
5863: CALL_OW 308
5867: IFFALSE 6475
5869: GO 5871
5871: DISABLE
5872: LD_INT 0
5874: PPUSH
5875: PPUSH
5876: PPUSH
5877: PPUSH
5878: PPUSH
5879: PPUSH
// begin if macmilan_use_radio then
5880: LD_EXP 6
5884: IFFALSE 5893
// SetAchievement ( ACH_RADIO ) ;
5886: LD_STRING ACH_RADIO
5888: PPUSH
5889: CALL_OW 543
// if ( not cyrus_saved and cyrus_in_squad and IsOk ( Cyrus ) ) or ( not bobby_saved and bobby_in_squad and IsOk ( Bobby ) ) then
5893: LD_EXP 13
5897: NOT
5898: PUSH
5899: LD_EXP 7
5903: AND
5904: PUSH
5905: LD_EXP 17
5909: PPUSH
5910: CALL_OW 302
5914: AND
5915: PUSH
5916: LD_EXP 12
5920: NOT
5921: PUSH
5922: LD_EXP 4
5926: AND
5927: PUSH
5928: LD_EXP 16
5932: PPUSH
5933: CALL_OW 302
5937: AND
5938: OR
5939: IFFALSE 5980
// case Query ( Q2 ) of 1 :
5941: LD_STRING Q2
5943: PPUSH
5944: CALL_OW 97
5948: PUSH
5949: LD_INT 1
5951: DOUBLE
5952: EQUAL
5953: IFTRUE 5957
5955: GO 5968
5957: POP
// wait_for_them := true ; 2 :
5958: LD_ADDR_VAR 0 3
5962: PUSH
5963: LD_INT 1
5965: ST_TO_ADDR
5966: GO 5980
5968: LD_INT 2
5970: DOUBLE
5971: EQUAL
5972: IFTRUE 5976
5974: GO 5979
5976: POP
// ; end ;
5977: GO 5980
5979: POP
// if wait_for_them then
5980: LD_VAR 0 3
5984: IFFALSE 6097
// repeat wait ( 0 0$01 ) ;
5986: LD_INT 35
5988: PPUSH
5989: CALL_OW 67
// until ( cyrus_saved and bobby_saved ) or ( cyrus_saved and ( not bobby_in_squad or IsDying ( Bobby ) or IsDead ( Bobby ) ) ) or ( bobby_saved and ( not cyrus_in_squad or IsDying ( Cyrus ) or IsDead ( Cyrus ) ) ) or ( IsDead ( Bobby ) and IsDead ( Cyrus ) ) ;
5993: LD_EXP 13
5997: PUSH
5998: LD_EXP 12
6002: AND
6003: PUSH
6004: LD_EXP 13
6008: PUSH
6009: LD_EXP 4
6013: NOT
6014: PUSH
6015: LD_EXP 16
6019: PPUSH
6020: CALL_OW 303
6024: OR
6025: PUSH
6026: LD_EXP 16
6030: PPUSH
6031: CALL_OW 301
6035: OR
6036: AND
6037: OR
6038: PUSH
6039: LD_EXP 12
6043: PUSH
6044: LD_EXP 7
6048: NOT
6049: PUSH
6050: LD_EXP 17
6054: PPUSH
6055: CALL_OW 303
6059: OR
6060: PUSH
6061: LD_EXP 17
6065: PPUSH
6066: CALL_OW 301
6070: OR
6071: AND
6072: OR
6073: PUSH
6074: LD_EXP 16
6078: PPUSH
6079: CALL_OW 301
6083: PUSH
6084: LD_EXP 17
6088: PPUSH
6089: CALL_OW 301
6093: AND
6094: OR
6095: IFFALSE 5986
// SaveVariable ( GetLives ( JMM ) , 01_JMMLifePoints_1 ) ;
6097: LD_EXP 15
6101: PPUSH
6102: CALL_OW 256
6106: PPUSH
6107: LD_STRING 01_JMMLifePoints_1
6109: PPUSH
6110: CALL_OW 39
// RemoveUnit ( JMM ) ;
6114: LD_EXP 15
6118: PPUSH
6119: CALL_OW 64
// to_reward := [ JMM ] ;
6123: LD_ADDR_VAR 0 2
6127: PUSH
6128: LD_EXP 15
6132: PUSH
6133: EMPTY
6134: LIST
6135: ST_TO_ADDR
// if bobby_saved then
6136: LD_EXP 12
6140: IFFALSE 6158
// to_reward := to_reward ^ Bobby ;
6142: LD_ADDR_VAR 0 2
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_EXP 16
6156: ADD
6157: ST_TO_ADDR
// if cyrus_saved then
6158: LD_EXP 13
6162: IFFALSE 6180
// to_reward := to_reward ^ Cyrus ;
6164: LD_ADDR_VAR 0 2
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: LD_EXP 17
6178: ADD
6179: ST_TO_ADDR
// m1 := true ;
6180: LD_ADDR_VAR 0 4
6184: PUSH
6185: LD_INT 1
6187: ST_TO_ADDR
// m2 := bobby_saved ;
6188: LD_ADDR_VAR 0 5
6192: PUSH
6193: LD_EXP 12
6197: ST_TO_ADDR
// m3 := cyrus_saved ;
6198: LD_ADDR_VAR 0 6
6202: PUSH
6203: LD_EXP 13
6207: ST_TO_ADDR
// AddMedal ( JMM , 1 ) ;
6208: LD_STRING JMM
6210: PPUSH
6211: LD_INT 1
6213: PPUSH
6214: CALL_OW 101
// if not bobby_in_squad then
6218: LD_EXP 4
6222: NOT
6223: IFFALSE 6236
// AddMedal ( Bobby , - 1 ) ;
6225: LD_STRING Bobby
6227: PPUSH
6228: LD_INT 1
6230: NEG
6231: PPUSH
6232: CALL_OW 101
// if not bobby_saved and ( IsDying ( Bobby ) or IsDead ( Bobby ) ) then
6236: LD_EXP 12
6240: NOT
6241: PUSH
6242: LD_EXP 16
6246: PPUSH
6247: CALL_OW 303
6251: PUSH
6252: LD_EXP 16
6256: PPUSH
6257: CALL_OW 301
6261: OR
6262: AND
6263: IFFALSE 6276
// AddMedal ( Bobby , - 2 ) ;
6265: LD_STRING Bobby
6267: PPUSH
6268: LD_INT 2
6270: NEG
6271: PPUSH
6272: CALL_OW 101
// if not cyrus_in_squad then
6276: LD_EXP 7
6280: NOT
6281: IFFALSE 6294
// AddMedal ( Cyrus , - 1 ) ;
6283: LD_STRING Cyrus
6285: PPUSH
6286: LD_INT 1
6288: NEG
6289: PPUSH
6290: CALL_OW 101
// if not cyrus_saved and ( IsDying ( Cyrus ) or IsDead ( Cyrus ) ) then
6294: LD_EXP 13
6298: NOT
6299: PUSH
6300: LD_EXP 17
6304: PPUSH
6305: CALL_OW 303
6309: PUSH
6310: LD_EXP 17
6314: PPUSH
6315: CALL_OW 301
6319: OR
6320: AND
6321: IFFALSE 6334
// AddMedal ( Cyrus , - 2 ) ;
6323: LD_STRING Cyrus
6325: PPUSH
6326: LD_INT 2
6328: NEG
6329: PPUSH
6330: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
6334: LD_OWVAR 67
6338: PUSH
6339: LD_INT 3
6341: EQUAL
6342: PUSH
6343: LD_VAR 0 4
6347: AND
6348: PUSH
6349: LD_VAR 0 5
6353: AND
6354: PUSH
6355: LD_VAR 0 6
6359: AND
6360: IFFALSE 6372
// SetAchievementEX ( ACH_AMER , 1 ) ;
6362: LD_STRING ACH_AMER
6364: PPUSH
6365: LD_INT 1
6367: PPUSH
6368: CALL_OW 564
// GiveMedals ( MAIN ) ;
6372: LD_STRING MAIN
6374: PPUSH
6375: CALL_OW 102
// RewardPeople ( to_reward ) ;
6379: LD_VAR 0 2
6383: PPUSH
6384: CALL_OW 43
// if bobby_saved then
6388: LD_EXP 12
6392: IFFALSE 6412
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
6394: LD_EXP 16
6398: PPUSH
6399: LD_EXP 2
6403: PUSH
6404: LD_STRING Bobby
6406: STR
6407: PPUSH
6408: CALL_OW 38
// if cyrus_saved then
6412: LD_EXP 13
6416: IFFALSE 6436
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
6418: LD_EXP 17
6422: PPUSH
6423: LD_EXP 2
6427: PUSH
6428: LD_STRING Cyrus
6430: STR
6431: PPUSH
6432: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
6436: LD_EXP 15
6440: PPUSH
6441: LD_EXP 2
6445: PUSH
6446: LD_STRING JMM
6448: STR
6449: PPUSH
6450: CALL_OW 38
// if tick <= 3 3$00 then
6454: LD_OWVAR 1
6458: PUSH
6459: LD_INT 6300
6461: LESSEQUAL
6462: IFFALSE 6471
// SetAchievement ( ACH_ASPEED_1 ) ;
6464: LD_STRING ACH_ASPEED_1
6466: PPUSH
6467: CALL_OW 543
// YouWin ;
6471: CALL_OW 103
// end ; end_of_file end_of_file
6475: PPOPN 6
6477: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
6478: GO 6480
6480: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
6481: LD_STRING initStreamRollete();
6483: PPUSH
6484: CALL_OW 559
// InitStreamMode ;
6488: CALL 6497 0 0
// DefineStreamItems ( ) ;
6492: CALL 6937 0 0
// end ;
6496: END
// function InitStreamMode ; begin
6497: LD_INT 0
6499: PPUSH
// streamModeActive := false ;
6500: LD_ADDR_EXP 26
6504: PUSH
6505: LD_INT 0
6507: ST_TO_ADDR
// normalCounter := 26 ;
6508: LD_ADDR_EXP 27
6512: PUSH
6513: LD_INT 26
6515: ST_TO_ADDR
// hardcoreCounter := 12 ;
6516: LD_ADDR_EXP 28
6520: PUSH
6521: LD_INT 12
6523: ST_TO_ADDR
// sRocket := false ;
6524: LD_ADDR_EXP 31
6528: PUSH
6529: LD_INT 0
6531: ST_TO_ADDR
// sSpeed := false ;
6532: LD_ADDR_EXP 30
6536: PUSH
6537: LD_INT 0
6539: ST_TO_ADDR
// sEngine := false ;
6540: LD_ADDR_EXP 32
6544: PUSH
6545: LD_INT 0
6547: ST_TO_ADDR
// sSpec := false ;
6548: LD_ADDR_EXP 29
6552: PUSH
6553: LD_INT 0
6555: ST_TO_ADDR
// sLevel := false ;
6556: LD_ADDR_EXP 33
6560: PUSH
6561: LD_INT 0
6563: ST_TO_ADDR
// sArmoury := false ;
6564: LD_ADDR_EXP 34
6568: PUSH
6569: LD_INT 0
6571: ST_TO_ADDR
// sRadar := false ;
6572: LD_ADDR_EXP 35
6576: PUSH
6577: LD_INT 0
6579: ST_TO_ADDR
// sBunker := false ;
6580: LD_ADDR_EXP 36
6584: PUSH
6585: LD_INT 0
6587: ST_TO_ADDR
// sHack := false ;
6588: LD_ADDR_EXP 37
6592: PUSH
6593: LD_INT 0
6595: ST_TO_ADDR
// sFire := false ;
6596: LD_ADDR_EXP 38
6600: PUSH
6601: LD_INT 0
6603: ST_TO_ADDR
// sRefresh := false ;
6604: LD_ADDR_EXP 39
6608: PUSH
6609: LD_INT 0
6611: ST_TO_ADDR
// sExp := false ;
6612: LD_ADDR_EXP 40
6616: PUSH
6617: LD_INT 0
6619: ST_TO_ADDR
// sDepot := false ;
6620: LD_ADDR_EXP 41
6624: PUSH
6625: LD_INT 0
6627: ST_TO_ADDR
// sFlag := false ;
6628: LD_ADDR_EXP 42
6632: PUSH
6633: LD_INT 0
6635: ST_TO_ADDR
// sKamikadze := false ;
6636: LD_ADDR_EXP 50
6640: PUSH
6641: LD_INT 0
6643: ST_TO_ADDR
// sTroll := false ;
6644: LD_ADDR_EXP 51
6648: PUSH
6649: LD_INT 0
6651: ST_TO_ADDR
// sSlow := false ;
6652: LD_ADDR_EXP 52
6656: PUSH
6657: LD_INT 0
6659: ST_TO_ADDR
// sLack := false ;
6660: LD_ADDR_EXP 53
6664: PUSH
6665: LD_INT 0
6667: ST_TO_ADDR
// sTank := false ;
6668: LD_ADDR_EXP 55
6672: PUSH
6673: LD_INT 0
6675: ST_TO_ADDR
// sRemote := false ;
6676: LD_ADDR_EXP 56
6680: PUSH
6681: LD_INT 0
6683: ST_TO_ADDR
// sPowell := false ;
6684: LD_ADDR_EXP 57
6688: PUSH
6689: LD_INT 0
6691: ST_TO_ADDR
// sTeleport := false ;
6692: LD_ADDR_EXP 60
6696: PUSH
6697: LD_INT 0
6699: ST_TO_ADDR
// sOilTower := false ;
6700: LD_ADDR_EXP 62
6704: PUSH
6705: LD_INT 0
6707: ST_TO_ADDR
// sShovel := false ;
6708: LD_ADDR_EXP 63
6712: PUSH
6713: LD_INT 0
6715: ST_TO_ADDR
// sSheik := false ;
6716: LD_ADDR_EXP 64
6720: PUSH
6721: LD_INT 0
6723: ST_TO_ADDR
// sEarthquake := false ;
6724: LD_ADDR_EXP 66
6728: PUSH
6729: LD_INT 0
6731: ST_TO_ADDR
// sAI := false ;
6732: LD_ADDR_EXP 67
6736: PUSH
6737: LD_INT 0
6739: ST_TO_ADDR
// sCargo := false ;
6740: LD_ADDR_EXP 70
6744: PUSH
6745: LD_INT 0
6747: ST_TO_ADDR
// sDLaser := false ;
6748: LD_ADDR_EXP 71
6752: PUSH
6753: LD_INT 0
6755: ST_TO_ADDR
// sExchange := false ;
6756: LD_ADDR_EXP 72
6760: PUSH
6761: LD_INT 0
6763: ST_TO_ADDR
// sFac := false ;
6764: LD_ADDR_EXP 73
6768: PUSH
6769: LD_INT 0
6771: ST_TO_ADDR
// sPower := false ;
6772: LD_ADDR_EXP 74
6776: PUSH
6777: LD_INT 0
6779: ST_TO_ADDR
// sRandom := false ;
6780: LD_ADDR_EXP 75
6784: PUSH
6785: LD_INT 0
6787: ST_TO_ADDR
// sShield := false ;
6788: LD_ADDR_EXP 76
6792: PUSH
6793: LD_INT 0
6795: ST_TO_ADDR
// sTime := false ;
6796: LD_ADDR_EXP 77
6800: PUSH
6801: LD_INT 0
6803: ST_TO_ADDR
// sTools := false ;
6804: LD_ADDR_EXP 78
6808: PUSH
6809: LD_INT 0
6811: ST_TO_ADDR
// sSold := false ;
6812: LD_ADDR_EXP 43
6816: PUSH
6817: LD_INT 0
6819: ST_TO_ADDR
// sDiff := false ;
6820: LD_ADDR_EXP 44
6824: PUSH
6825: LD_INT 0
6827: ST_TO_ADDR
// sFog := false ;
6828: LD_ADDR_EXP 47
6832: PUSH
6833: LD_INT 0
6835: ST_TO_ADDR
// sReset := false ;
6836: LD_ADDR_EXP 48
6840: PUSH
6841: LD_INT 0
6843: ST_TO_ADDR
// sSun := false ;
6844: LD_ADDR_EXP 49
6848: PUSH
6849: LD_INT 0
6851: ST_TO_ADDR
// sTiger := false ;
6852: LD_ADDR_EXP 45
6856: PUSH
6857: LD_INT 0
6859: ST_TO_ADDR
// sBomb := false ;
6860: LD_ADDR_EXP 46
6864: PUSH
6865: LD_INT 0
6867: ST_TO_ADDR
// sWound := false ;
6868: LD_ADDR_EXP 54
6872: PUSH
6873: LD_INT 0
6875: ST_TO_ADDR
// sBetray := false ;
6876: LD_ADDR_EXP 58
6880: PUSH
6881: LD_INT 0
6883: ST_TO_ADDR
// sContamin := false ;
6884: LD_ADDR_EXP 59
6888: PUSH
6889: LD_INT 0
6891: ST_TO_ADDR
// sOil := false ;
6892: LD_ADDR_EXP 61
6896: PUSH
6897: LD_INT 0
6899: ST_TO_ADDR
// sStu := false ;
6900: LD_ADDR_EXP 65
6904: PUSH
6905: LD_INT 0
6907: ST_TO_ADDR
// sBazooka := false ;
6908: LD_ADDR_EXP 68
6912: PUSH
6913: LD_INT 0
6915: ST_TO_ADDR
// sMortar := false ;
6916: LD_ADDR_EXP 69
6920: PUSH
6921: LD_INT 0
6923: ST_TO_ADDR
// sRanger := false ;
6924: LD_ADDR_EXP 79
6928: PUSH
6929: LD_INT 0
6931: ST_TO_ADDR
// end ;
6932: LD_VAR 0 1
6936: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
6937: LD_INT 0
6939: PPUSH
6940: PPUSH
6941: PPUSH
6942: PPUSH
6943: PPUSH
// result := [ ] ;
6944: LD_ADDR_VAR 0 1
6948: PUSH
6949: EMPTY
6950: ST_TO_ADDR
// if campaign_id = 1 then
6951: LD_OWVAR 69
6955: PUSH
6956: LD_INT 1
6958: EQUAL
6959: IFFALSE 9895
// begin case mission_number of 1 :
6961: LD_OWVAR 70
6965: PUSH
6966: LD_INT 1
6968: DOUBLE
6969: EQUAL
6970: IFTRUE 6974
6972: GO 7038
6974: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
6975: LD_ADDR_VAR 0 1
6979: PUSH
6980: LD_INT 2
6982: PUSH
6983: LD_INT 4
6985: PUSH
6986: LD_INT 11
6988: PUSH
6989: LD_INT 12
6991: PUSH
6992: LD_INT 15
6994: PUSH
6995: LD_INT 16
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_INT 23
7003: PUSH
7004: LD_INT 26
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: PUSH
7018: LD_INT 101
7020: PUSH
7021: LD_INT 102
7023: PUSH
7024: LD_INT 106
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: LIST
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: ST_TO_ADDR
7036: GO 9895
7038: LD_INT 2
7040: DOUBLE
7041: EQUAL
7042: IFTRUE 7046
7044: GO 7118
7046: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
7047: LD_ADDR_VAR 0 1
7051: PUSH
7052: LD_INT 2
7054: PUSH
7055: LD_INT 4
7057: PUSH
7058: LD_INT 11
7060: PUSH
7061: LD_INT 12
7063: PUSH
7064: LD_INT 15
7066: PUSH
7067: LD_INT 16
7069: PUSH
7070: LD_INT 22
7072: PUSH
7073: LD_INT 23
7075: PUSH
7076: LD_INT 26
7078: PUSH
7079: EMPTY
7080: LIST
7081: LIST
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 101
7092: PUSH
7093: LD_INT 102
7095: PUSH
7096: LD_INT 105
7098: PUSH
7099: LD_INT 106
7101: PUSH
7102: LD_INT 108
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: ST_TO_ADDR
7116: GO 9895
7118: LD_INT 3
7120: DOUBLE
7121: EQUAL
7122: IFTRUE 7126
7124: GO 7202
7126: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
7127: LD_ADDR_VAR 0 1
7131: PUSH
7132: LD_INT 2
7134: PUSH
7135: LD_INT 4
7137: PUSH
7138: LD_INT 5
7140: PUSH
7141: LD_INT 11
7143: PUSH
7144: LD_INT 12
7146: PUSH
7147: LD_INT 15
7149: PUSH
7150: LD_INT 16
7152: PUSH
7153: LD_INT 22
7155: PUSH
7156: LD_INT 26
7158: PUSH
7159: LD_INT 36
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 101
7176: PUSH
7177: LD_INT 102
7179: PUSH
7180: LD_INT 105
7182: PUSH
7183: LD_INT 106
7185: PUSH
7186: LD_INT 108
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: ST_TO_ADDR
7200: GO 9895
7202: LD_INT 4
7204: DOUBLE
7205: EQUAL
7206: IFTRUE 7210
7208: GO 7294
7210: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
7211: LD_ADDR_VAR 0 1
7215: PUSH
7216: LD_INT 2
7218: PUSH
7219: LD_INT 4
7221: PUSH
7222: LD_INT 5
7224: PUSH
7225: LD_INT 8
7227: PUSH
7228: LD_INT 11
7230: PUSH
7231: LD_INT 12
7233: PUSH
7234: LD_INT 15
7236: PUSH
7237: LD_INT 16
7239: PUSH
7240: LD_INT 22
7242: PUSH
7243: LD_INT 23
7245: PUSH
7246: LD_INT 26
7248: PUSH
7249: LD_INT 36
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: LIST
7262: LIST
7263: LIST
7264: LIST
7265: PUSH
7266: LD_INT 101
7268: PUSH
7269: LD_INT 102
7271: PUSH
7272: LD_INT 105
7274: PUSH
7275: LD_INT 106
7277: PUSH
7278: LD_INT 108
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: LIST
7285: LIST
7286: LIST
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: ST_TO_ADDR
7292: GO 9895
7294: LD_INT 5
7296: DOUBLE
7297: EQUAL
7298: IFTRUE 7302
7300: GO 7402
7302: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
7303: LD_ADDR_VAR 0 1
7307: PUSH
7308: LD_INT 2
7310: PUSH
7311: LD_INT 4
7313: PUSH
7314: LD_INT 5
7316: PUSH
7317: LD_INT 6
7319: PUSH
7320: LD_INT 8
7322: PUSH
7323: LD_INT 11
7325: PUSH
7326: LD_INT 12
7328: PUSH
7329: LD_INT 15
7331: PUSH
7332: LD_INT 16
7334: PUSH
7335: LD_INT 22
7337: PUSH
7338: LD_INT 23
7340: PUSH
7341: LD_INT 25
7343: PUSH
7344: LD_INT 26
7346: PUSH
7347: LD_INT 36
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: LIST
7360: LIST
7361: LIST
7362: LIST
7363: LIST
7364: LIST
7365: PUSH
7366: LD_INT 101
7368: PUSH
7369: LD_INT 102
7371: PUSH
7372: LD_INT 105
7374: PUSH
7375: LD_INT 106
7377: PUSH
7378: LD_INT 108
7380: PUSH
7381: LD_INT 109
7383: PUSH
7384: LD_INT 112
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: LIST
7392: LIST
7393: LIST
7394: LIST
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: ST_TO_ADDR
7400: GO 9895
7402: LD_INT 6
7404: DOUBLE
7405: EQUAL
7406: IFTRUE 7410
7408: GO 7530
7410: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
7411: LD_ADDR_VAR 0 1
7415: PUSH
7416: LD_INT 2
7418: PUSH
7419: LD_INT 4
7421: PUSH
7422: LD_INT 5
7424: PUSH
7425: LD_INT 6
7427: PUSH
7428: LD_INT 8
7430: PUSH
7431: LD_INT 11
7433: PUSH
7434: LD_INT 12
7436: PUSH
7437: LD_INT 15
7439: PUSH
7440: LD_INT 16
7442: PUSH
7443: LD_INT 20
7445: PUSH
7446: LD_INT 21
7448: PUSH
7449: LD_INT 22
7451: PUSH
7452: LD_INT 23
7454: PUSH
7455: LD_INT 25
7457: PUSH
7458: LD_INT 26
7460: PUSH
7461: LD_INT 30
7463: PUSH
7464: LD_INT 31
7466: PUSH
7467: LD_INT 32
7469: PUSH
7470: LD_INT 36
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: LIST
7478: LIST
7479: LIST
7480: LIST
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 101
7496: PUSH
7497: LD_INT 102
7499: PUSH
7500: LD_INT 105
7502: PUSH
7503: LD_INT 106
7505: PUSH
7506: LD_INT 108
7508: PUSH
7509: LD_INT 109
7511: PUSH
7512: LD_INT 112
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: LIST
7519: LIST
7520: LIST
7521: LIST
7522: LIST
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: ST_TO_ADDR
7528: GO 9895
7530: LD_INT 7
7532: DOUBLE
7533: EQUAL
7534: IFTRUE 7538
7536: GO 7638
7538: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
7539: LD_ADDR_VAR 0 1
7543: PUSH
7544: LD_INT 2
7546: PUSH
7547: LD_INT 4
7549: PUSH
7550: LD_INT 5
7552: PUSH
7553: LD_INT 7
7555: PUSH
7556: LD_INT 11
7558: PUSH
7559: LD_INT 12
7561: PUSH
7562: LD_INT 15
7564: PUSH
7565: LD_INT 16
7567: PUSH
7568: LD_INT 20
7570: PUSH
7571: LD_INT 21
7573: PUSH
7574: LD_INT 22
7576: PUSH
7577: LD_INT 23
7579: PUSH
7580: LD_INT 25
7582: PUSH
7583: LD_INT 26
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: LIST
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 101
7604: PUSH
7605: LD_INT 102
7607: PUSH
7608: LD_INT 103
7610: PUSH
7611: LD_INT 105
7613: PUSH
7614: LD_INT 106
7616: PUSH
7617: LD_INT 108
7619: PUSH
7620: LD_INT 112
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: LIST
7627: LIST
7628: LIST
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: ST_TO_ADDR
7636: GO 9895
7638: LD_INT 8
7640: DOUBLE
7641: EQUAL
7642: IFTRUE 7646
7644: GO 7774
7646: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
7647: LD_ADDR_VAR 0 1
7651: PUSH
7652: LD_INT 2
7654: PUSH
7655: LD_INT 4
7657: PUSH
7658: LD_INT 5
7660: PUSH
7661: LD_INT 6
7663: PUSH
7664: LD_INT 7
7666: PUSH
7667: LD_INT 8
7669: PUSH
7670: LD_INT 11
7672: PUSH
7673: LD_INT 12
7675: PUSH
7676: LD_INT 15
7678: PUSH
7679: LD_INT 16
7681: PUSH
7682: LD_INT 20
7684: PUSH
7685: LD_INT 21
7687: PUSH
7688: LD_INT 22
7690: PUSH
7691: LD_INT 23
7693: PUSH
7694: LD_INT 25
7696: PUSH
7697: LD_INT 26
7699: PUSH
7700: LD_INT 30
7702: PUSH
7703: LD_INT 31
7705: PUSH
7706: LD_INT 32
7708: PUSH
7709: LD_INT 36
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PUSH
7734: LD_INT 101
7736: PUSH
7737: LD_INT 102
7739: PUSH
7740: LD_INT 103
7742: PUSH
7743: LD_INT 105
7745: PUSH
7746: LD_INT 106
7748: PUSH
7749: LD_INT 108
7751: PUSH
7752: LD_INT 109
7754: PUSH
7755: LD_INT 112
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: ST_TO_ADDR
7772: GO 9895
7774: LD_INT 9
7776: DOUBLE
7777: EQUAL
7778: IFTRUE 7782
7780: GO 7918
7782: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
7783: LD_ADDR_VAR 0 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 4
7793: PUSH
7794: LD_INT 5
7796: PUSH
7797: LD_INT 6
7799: PUSH
7800: LD_INT 7
7802: PUSH
7803: LD_INT 8
7805: PUSH
7806: LD_INT 11
7808: PUSH
7809: LD_INT 12
7811: PUSH
7812: LD_INT 15
7814: PUSH
7815: LD_INT 16
7817: PUSH
7818: LD_INT 20
7820: PUSH
7821: LD_INT 21
7823: PUSH
7824: LD_INT 22
7826: PUSH
7827: LD_INT 23
7829: PUSH
7830: LD_INT 25
7832: PUSH
7833: LD_INT 26
7835: PUSH
7836: LD_INT 28
7838: PUSH
7839: LD_INT 30
7841: PUSH
7842: LD_INT 31
7844: PUSH
7845: LD_INT 32
7847: PUSH
7848: LD_INT 36
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: LIST
7866: LIST
7867: LIST
7868: LIST
7869: LIST
7870: LIST
7871: LIST
7872: LIST
7873: PUSH
7874: LD_INT 101
7876: PUSH
7877: LD_INT 102
7879: PUSH
7880: LD_INT 103
7882: PUSH
7883: LD_INT 105
7885: PUSH
7886: LD_INT 106
7888: PUSH
7889: LD_INT 108
7891: PUSH
7892: LD_INT 109
7894: PUSH
7895: LD_INT 112
7897: PUSH
7898: LD_INT 114
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: LIST
7906: LIST
7907: LIST
7908: LIST
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: ST_TO_ADDR
7916: GO 9895
7918: LD_INT 10
7920: DOUBLE
7921: EQUAL
7922: IFTRUE 7926
7924: GO 8110
7926: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
7927: LD_ADDR_VAR 0 1
7931: PUSH
7932: LD_INT 2
7934: PUSH
7935: LD_INT 4
7937: PUSH
7938: LD_INT 5
7940: PUSH
7941: LD_INT 6
7943: PUSH
7944: LD_INT 7
7946: PUSH
7947: LD_INT 8
7949: PUSH
7950: LD_INT 9
7952: PUSH
7953: LD_INT 10
7955: PUSH
7956: LD_INT 11
7958: PUSH
7959: LD_INT 12
7961: PUSH
7962: LD_INT 13
7964: PUSH
7965: LD_INT 14
7967: PUSH
7968: LD_INT 15
7970: PUSH
7971: LD_INT 16
7973: PUSH
7974: LD_INT 17
7976: PUSH
7977: LD_INT 18
7979: PUSH
7980: LD_INT 19
7982: PUSH
7983: LD_INT 20
7985: PUSH
7986: LD_INT 21
7988: PUSH
7989: LD_INT 22
7991: PUSH
7992: LD_INT 23
7994: PUSH
7995: LD_INT 24
7997: PUSH
7998: LD_INT 25
8000: PUSH
8001: LD_INT 26
8003: PUSH
8004: LD_INT 28
8006: PUSH
8007: LD_INT 30
8009: PUSH
8010: LD_INT 31
8012: PUSH
8013: LD_INT 32
8015: PUSH
8016: LD_INT 36
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: LIST
8032: LIST
8033: LIST
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PUSH
8050: LD_INT 101
8052: PUSH
8053: LD_INT 102
8055: PUSH
8056: LD_INT 103
8058: PUSH
8059: LD_INT 104
8061: PUSH
8062: LD_INT 105
8064: PUSH
8065: LD_INT 106
8067: PUSH
8068: LD_INT 107
8070: PUSH
8071: LD_INT 108
8073: PUSH
8074: LD_INT 109
8076: PUSH
8077: LD_INT 110
8079: PUSH
8080: LD_INT 111
8082: PUSH
8083: LD_INT 112
8085: PUSH
8086: LD_INT 114
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: LIST
8101: LIST
8102: LIST
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: ST_TO_ADDR
8108: GO 9895
8110: LD_INT 11
8112: DOUBLE
8113: EQUAL
8114: IFTRUE 8118
8116: GO 8310
8118: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
8119: LD_ADDR_VAR 0 1
8123: PUSH
8124: LD_INT 2
8126: PUSH
8127: LD_INT 3
8129: PUSH
8130: LD_INT 4
8132: PUSH
8133: LD_INT 5
8135: PUSH
8136: LD_INT 6
8138: PUSH
8139: LD_INT 7
8141: PUSH
8142: LD_INT 8
8144: PUSH
8145: LD_INT 9
8147: PUSH
8148: LD_INT 10
8150: PUSH
8151: LD_INT 11
8153: PUSH
8154: LD_INT 12
8156: PUSH
8157: LD_INT 13
8159: PUSH
8160: LD_INT 14
8162: PUSH
8163: LD_INT 15
8165: PUSH
8166: LD_INT 16
8168: PUSH
8169: LD_INT 17
8171: PUSH
8172: LD_INT 18
8174: PUSH
8175: LD_INT 19
8177: PUSH
8178: LD_INT 20
8180: PUSH
8181: LD_INT 21
8183: PUSH
8184: LD_INT 22
8186: PUSH
8187: LD_INT 23
8189: PUSH
8190: LD_INT 24
8192: PUSH
8193: LD_INT 25
8195: PUSH
8196: LD_INT 26
8198: PUSH
8199: LD_INT 28
8201: PUSH
8202: LD_INT 30
8204: PUSH
8205: LD_INT 31
8207: PUSH
8208: LD_INT 32
8210: PUSH
8211: LD_INT 34
8213: PUSH
8214: LD_INT 36
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 101
8252: PUSH
8253: LD_INT 102
8255: PUSH
8256: LD_INT 103
8258: PUSH
8259: LD_INT 104
8261: PUSH
8262: LD_INT 105
8264: PUSH
8265: LD_INT 106
8267: PUSH
8268: LD_INT 107
8270: PUSH
8271: LD_INT 108
8273: PUSH
8274: LD_INT 109
8276: PUSH
8277: LD_INT 110
8279: PUSH
8280: LD_INT 111
8282: PUSH
8283: LD_INT 112
8285: PUSH
8286: LD_INT 114
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: LIST
8293: LIST
8294: LIST
8295: LIST
8296: LIST
8297: LIST
8298: LIST
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: ST_TO_ADDR
8308: GO 9895
8310: LD_INT 12
8312: DOUBLE
8313: EQUAL
8314: IFTRUE 8318
8316: GO 8526
8318: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
8319: LD_ADDR_VAR 0 1
8323: PUSH
8324: LD_INT 1
8326: PUSH
8327: LD_INT 2
8329: PUSH
8330: LD_INT 3
8332: PUSH
8333: LD_INT 4
8335: PUSH
8336: LD_INT 5
8338: PUSH
8339: LD_INT 6
8341: PUSH
8342: LD_INT 7
8344: PUSH
8345: LD_INT 8
8347: PUSH
8348: LD_INT 9
8350: PUSH
8351: LD_INT 10
8353: PUSH
8354: LD_INT 11
8356: PUSH
8357: LD_INT 12
8359: PUSH
8360: LD_INT 13
8362: PUSH
8363: LD_INT 14
8365: PUSH
8366: LD_INT 15
8368: PUSH
8369: LD_INT 16
8371: PUSH
8372: LD_INT 17
8374: PUSH
8375: LD_INT 18
8377: PUSH
8378: LD_INT 19
8380: PUSH
8381: LD_INT 20
8383: PUSH
8384: LD_INT 21
8386: PUSH
8387: LD_INT 22
8389: PUSH
8390: LD_INT 23
8392: PUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 25
8398: PUSH
8399: LD_INT 26
8401: PUSH
8402: LD_INT 27
8404: PUSH
8405: LD_INT 28
8407: PUSH
8408: LD_INT 30
8410: PUSH
8411: LD_INT 31
8413: PUSH
8414: LD_INT 32
8416: PUSH
8417: LD_INT 33
8419: PUSH
8420: LD_INT 34
8422: PUSH
8423: LD_INT 36
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: LIST
8435: LIST
8436: LIST
8437: LIST
8438: LIST
8439: LIST
8440: LIST
8441: LIST
8442: LIST
8443: LIST
8444: LIST
8445: LIST
8446: LIST
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: LIST
8453: LIST
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: LIST
8460: LIST
8461: PUSH
8462: LD_INT 101
8464: PUSH
8465: LD_INT 102
8467: PUSH
8468: LD_INT 103
8470: PUSH
8471: LD_INT 104
8473: PUSH
8474: LD_INT 105
8476: PUSH
8477: LD_INT 106
8479: PUSH
8480: LD_INT 107
8482: PUSH
8483: LD_INT 108
8485: PUSH
8486: LD_INT 109
8488: PUSH
8489: LD_INT 110
8491: PUSH
8492: LD_INT 111
8494: PUSH
8495: LD_INT 112
8497: PUSH
8498: LD_INT 113
8500: PUSH
8501: LD_INT 114
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: LIST
8508: LIST
8509: LIST
8510: LIST
8511: LIST
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: LIST
8518: LIST
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: ST_TO_ADDR
8524: GO 9895
8526: LD_INT 13
8528: DOUBLE
8529: EQUAL
8530: IFTRUE 8534
8532: GO 8730
8534: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
8535: LD_ADDR_VAR 0 1
8539: PUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 2
8545: PUSH
8546: LD_INT 3
8548: PUSH
8549: LD_INT 4
8551: PUSH
8552: LD_INT 5
8554: PUSH
8555: LD_INT 8
8557: PUSH
8558: LD_INT 9
8560: PUSH
8561: LD_INT 10
8563: PUSH
8564: LD_INT 11
8566: PUSH
8567: LD_INT 12
8569: PUSH
8570: LD_INT 14
8572: PUSH
8573: LD_INT 15
8575: PUSH
8576: LD_INT 16
8578: PUSH
8579: LD_INT 17
8581: PUSH
8582: LD_INT 18
8584: PUSH
8585: LD_INT 19
8587: PUSH
8588: LD_INT 20
8590: PUSH
8591: LD_INT 21
8593: PUSH
8594: LD_INT 22
8596: PUSH
8597: LD_INT 23
8599: PUSH
8600: LD_INT 24
8602: PUSH
8603: LD_INT 25
8605: PUSH
8606: LD_INT 26
8608: PUSH
8609: LD_INT 27
8611: PUSH
8612: LD_INT 28
8614: PUSH
8615: LD_INT 30
8617: PUSH
8618: LD_INT 31
8620: PUSH
8621: LD_INT 32
8623: PUSH
8624: LD_INT 33
8626: PUSH
8627: LD_INT 34
8629: PUSH
8630: LD_INT 36
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: LIST
8664: LIST
8665: PUSH
8666: LD_INT 101
8668: PUSH
8669: LD_INT 102
8671: PUSH
8672: LD_INT 103
8674: PUSH
8675: LD_INT 104
8677: PUSH
8678: LD_INT 105
8680: PUSH
8681: LD_INT 106
8683: PUSH
8684: LD_INT 107
8686: PUSH
8687: LD_INT 108
8689: PUSH
8690: LD_INT 109
8692: PUSH
8693: LD_INT 110
8695: PUSH
8696: LD_INT 111
8698: PUSH
8699: LD_INT 112
8701: PUSH
8702: LD_INT 113
8704: PUSH
8705: LD_INT 114
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: LIST
8722: LIST
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: ST_TO_ADDR
8728: GO 9895
8730: LD_INT 14
8732: DOUBLE
8733: EQUAL
8734: IFTRUE 8738
8736: GO 8950
8738: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
8739: LD_ADDR_VAR 0 1
8743: PUSH
8744: LD_INT 1
8746: PUSH
8747: LD_INT 2
8749: PUSH
8750: LD_INT 3
8752: PUSH
8753: LD_INT 4
8755: PUSH
8756: LD_INT 5
8758: PUSH
8759: LD_INT 6
8761: PUSH
8762: LD_INT 7
8764: PUSH
8765: LD_INT 8
8767: PUSH
8768: LD_INT 9
8770: PUSH
8771: LD_INT 10
8773: PUSH
8774: LD_INT 11
8776: PUSH
8777: LD_INT 12
8779: PUSH
8780: LD_INT 13
8782: PUSH
8783: LD_INT 14
8785: PUSH
8786: LD_INT 15
8788: PUSH
8789: LD_INT 16
8791: PUSH
8792: LD_INT 17
8794: PUSH
8795: LD_INT 18
8797: PUSH
8798: LD_INT 19
8800: PUSH
8801: LD_INT 20
8803: PUSH
8804: LD_INT 21
8806: PUSH
8807: LD_INT 22
8809: PUSH
8810: LD_INT 23
8812: PUSH
8813: LD_INT 24
8815: PUSH
8816: LD_INT 25
8818: PUSH
8819: LD_INT 26
8821: PUSH
8822: LD_INT 27
8824: PUSH
8825: LD_INT 28
8827: PUSH
8828: LD_INT 29
8830: PUSH
8831: LD_INT 30
8833: PUSH
8834: LD_INT 31
8836: PUSH
8837: LD_INT 32
8839: PUSH
8840: LD_INT 33
8842: PUSH
8843: LD_INT 34
8845: PUSH
8846: LD_INT 36
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: LIST
8860: LIST
8861: LIST
8862: LIST
8863: LIST
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_INT 101
8888: PUSH
8889: LD_INT 102
8891: PUSH
8892: LD_INT 103
8894: PUSH
8895: LD_INT 104
8897: PUSH
8898: LD_INT 105
8900: PUSH
8901: LD_INT 106
8903: PUSH
8904: LD_INT 107
8906: PUSH
8907: LD_INT 108
8909: PUSH
8910: LD_INT 109
8912: PUSH
8913: LD_INT 110
8915: PUSH
8916: LD_INT 111
8918: PUSH
8919: LD_INT 112
8921: PUSH
8922: LD_INT 113
8924: PUSH
8925: LD_INT 114
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: LIST
8940: LIST
8941: LIST
8942: LIST
8943: PUSH
8944: EMPTY
8945: LIST
8946: LIST
8947: ST_TO_ADDR
8948: GO 9895
8950: LD_INT 15
8952: DOUBLE
8953: EQUAL
8954: IFTRUE 8958
8956: GO 9170
8958: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
8959: LD_ADDR_VAR 0 1
8963: PUSH
8964: LD_INT 1
8966: PUSH
8967: LD_INT 2
8969: PUSH
8970: LD_INT 3
8972: PUSH
8973: LD_INT 4
8975: PUSH
8976: LD_INT 5
8978: PUSH
8979: LD_INT 6
8981: PUSH
8982: LD_INT 7
8984: PUSH
8985: LD_INT 8
8987: PUSH
8988: LD_INT 9
8990: PUSH
8991: LD_INT 10
8993: PUSH
8994: LD_INT 11
8996: PUSH
8997: LD_INT 12
8999: PUSH
9000: LD_INT 13
9002: PUSH
9003: LD_INT 14
9005: PUSH
9006: LD_INT 15
9008: PUSH
9009: LD_INT 16
9011: PUSH
9012: LD_INT 17
9014: PUSH
9015: LD_INT 18
9017: PUSH
9018: LD_INT 19
9020: PUSH
9021: LD_INT 20
9023: PUSH
9024: LD_INT 21
9026: PUSH
9027: LD_INT 22
9029: PUSH
9030: LD_INT 23
9032: PUSH
9033: LD_INT 24
9035: PUSH
9036: LD_INT 25
9038: PUSH
9039: LD_INT 26
9041: PUSH
9042: LD_INT 27
9044: PUSH
9045: LD_INT 28
9047: PUSH
9048: LD_INT 29
9050: PUSH
9051: LD_INT 30
9053: PUSH
9054: LD_INT 31
9056: PUSH
9057: LD_INT 32
9059: PUSH
9060: LD_INT 33
9062: PUSH
9063: LD_INT 34
9065: PUSH
9066: LD_INT 36
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: LIST
9079: LIST
9080: LIST
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: LIST
9086: LIST
9087: LIST
9088: LIST
9089: LIST
9090: LIST
9091: LIST
9092: LIST
9093: LIST
9094: LIST
9095: LIST
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: LIST
9101: LIST
9102: LIST
9103: LIST
9104: LIST
9105: PUSH
9106: LD_INT 101
9108: PUSH
9109: LD_INT 102
9111: PUSH
9112: LD_INT 103
9114: PUSH
9115: LD_INT 104
9117: PUSH
9118: LD_INT 105
9120: PUSH
9121: LD_INT 106
9123: PUSH
9124: LD_INT 107
9126: PUSH
9127: LD_INT 108
9129: PUSH
9130: LD_INT 109
9132: PUSH
9133: LD_INT 110
9135: PUSH
9136: LD_INT 111
9138: PUSH
9139: LD_INT 112
9141: PUSH
9142: LD_INT 113
9144: PUSH
9145: LD_INT 114
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: LIST
9163: PUSH
9164: EMPTY
9165: LIST
9166: LIST
9167: ST_TO_ADDR
9168: GO 9895
9170: LD_INT 16
9172: DOUBLE
9173: EQUAL
9174: IFTRUE 9178
9176: GO 9302
9178: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
9179: LD_ADDR_VAR 0 1
9183: PUSH
9184: LD_INT 2
9186: PUSH
9187: LD_INT 4
9189: PUSH
9190: LD_INT 5
9192: PUSH
9193: LD_INT 7
9195: PUSH
9196: LD_INT 11
9198: PUSH
9199: LD_INT 12
9201: PUSH
9202: LD_INT 15
9204: PUSH
9205: LD_INT 16
9207: PUSH
9208: LD_INT 20
9210: PUSH
9211: LD_INT 21
9213: PUSH
9214: LD_INT 22
9216: PUSH
9217: LD_INT 23
9219: PUSH
9220: LD_INT 25
9222: PUSH
9223: LD_INT 26
9225: PUSH
9226: LD_INT 30
9228: PUSH
9229: LD_INT 31
9231: PUSH
9232: LD_INT 32
9234: PUSH
9235: LD_INT 33
9237: PUSH
9238: LD_INT 34
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: LIST
9254: LIST
9255: LIST
9256: LIST
9257: LIST
9258: LIST
9259: LIST
9260: LIST
9261: PUSH
9262: LD_INT 101
9264: PUSH
9265: LD_INT 102
9267: PUSH
9268: LD_INT 103
9270: PUSH
9271: LD_INT 106
9273: PUSH
9274: LD_INT 108
9276: PUSH
9277: LD_INT 112
9279: PUSH
9280: LD_INT 113
9282: PUSH
9283: LD_INT 114
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: LIST
9290: LIST
9291: LIST
9292: LIST
9293: LIST
9294: LIST
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: ST_TO_ADDR
9300: GO 9895
9302: LD_INT 17
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9522
9310: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
9311: LD_ADDR_VAR 0 1
9315: PUSH
9316: LD_INT 1
9318: PUSH
9319: LD_INT 2
9321: PUSH
9322: LD_INT 3
9324: PUSH
9325: LD_INT 4
9327: PUSH
9328: LD_INT 5
9330: PUSH
9331: LD_INT 6
9333: PUSH
9334: LD_INT 7
9336: PUSH
9337: LD_INT 8
9339: PUSH
9340: LD_INT 9
9342: PUSH
9343: LD_INT 10
9345: PUSH
9346: LD_INT 11
9348: PUSH
9349: LD_INT 12
9351: PUSH
9352: LD_INT 13
9354: PUSH
9355: LD_INT 14
9357: PUSH
9358: LD_INT 15
9360: PUSH
9361: LD_INT 16
9363: PUSH
9364: LD_INT 17
9366: PUSH
9367: LD_INT 18
9369: PUSH
9370: LD_INT 19
9372: PUSH
9373: LD_INT 20
9375: PUSH
9376: LD_INT 21
9378: PUSH
9379: LD_INT 22
9381: PUSH
9382: LD_INT 23
9384: PUSH
9385: LD_INT 24
9387: PUSH
9388: LD_INT 25
9390: PUSH
9391: LD_INT 26
9393: PUSH
9394: LD_INT 27
9396: PUSH
9397: LD_INT 28
9399: PUSH
9400: LD_INT 29
9402: PUSH
9403: LD_INT 30
9405: PUSH
9406: LD_INT 31
9408: PUSH
9409: LD_INT 32
9411: PUSH
9412: LD_INT 33
9414: PUSH
9415: LD_INT 34
9417: PUSH
9418: LD_INT 36
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: LIST
9429: LIST
9430: LIST
9431: LIST
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: PUSH
9458: LD_INT 101
9460: PUSH
9461: LD_INT 102
9463: PUSH
9464: LD_INT 103
9466: PUSH
9467: LD_INT 104
9469: PUSH
9470: LD_INT 105
9472: PUSH
9473: LD_INT 106
9475: PUSH
9476: LD_INT 107
9478: PUSH
9479: LD_INT 108
9481: PUSH
9482: LD_INT 109
9484: PUSH
9485: LD_INT 110
9487: PUSH
9488: LD_INT 111
9490: PUSH
9491: LD_INT 112
9493: PUSH
9494: LD_INT 113
9496: PUSH
9497: LD_INT 114
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: ST_TO_ADDR
9520: GO 9895
9522: LD_INT 18
9524: DOUBLE
9525: EQUAL
9526: IFTRUE 9530
9528: GO 9666
9530: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
9531: LD_ADDR_VAR 0 1
9535: PUSH
9536: LD_INT 2
9538: PUSH
9539: LD_INT 4
9541: PUSH
9542: LD_INT 5
9544: PUSH
9545: LD_INT 7
9547: PUSH
9548: LD_INT 11
9550: PUSH
9551: LD_INT 12
9553: PUSH
9554: LD_INT 15
9556: PUSH
9557: LD_INT 16
9559: PUSH
9560: LD_INT 20
9562: PUSH
9563: LD_INT 21
9565: PUSH
9566: LD_INT 22
9568: PUSH
9569: LD_INT 23
9571: PUSH
9572: LD_INT 25
9574: PUSH
9575: LD_INT 26
9577: PUSH
9578: LD_INT 30
9580: PUSH
9581: LD_INT 31
9583: PUSH
9584: LD_INT 32
9586: PUSH
9587: LD_INT 33
9589: PUSH
9590: LD_INT 34
9592: PUSH
9593: LD_INT 35
9595: PUSH
9596: LD_INT 36
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: LIST
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: LD_INT 101
9624: PUSH
9625: LD_INT 102
9627: PUSH
9628: LD_INT 103
9630: PUSH
9631: LD_INT 106
9633: PUSH
9634: LD_INT 108
9636: PUSH
9637: LD_INT 112
9639: PUSH
9640: LD_INT 113
9642: PUSH
9643: LD_INT 114
9645: PUSH
9646: LD_INT 115
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: ST_TO_ADDR
9664: GO 9895
9666: LD_INT 19
9668: DOUBLE
9669: EQUAL
9670: IFTRUE 9674
9672: GO 9894
9674: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
9675: LD_ADDR_VAR 0 1
9679: PUSH
9680: LD_INT 1
9682: PUSH
9683: LD_INT 2
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 4
9691: PUSH
9692: LD_INT 5
9694: PUSH
9695: LD_INT 6
9697: PUSH
9698: LD_INT 7
9700: PUSH
9701: LD_INT 8
9703: PUSH
9704: LD_INT 9
9706: PUSH
9707: LD_INT 10
9709: PUSH
9710: LD_INT 11
9712: PUSH
9713: LD_INT 12
9715: PUSH
9716: LD_INT 13
9718: PUSH
9719: LD_INT 14
9721: PUSH
9722: LD_INT 15
9724: PUSH
9725: LD_INT 16
9727: PUSH
9728: LD_INT 17
9730: PUSH
9731: LD_INT 18
9733: PUSH
9734: LD_INT 19
9736: PUSH
9737: LD_INT 20
9739: PUSH
9740: LD_INT 21
9742: PUSH
9743: LD_INT 22
9745: PUSH
9746: LD_INT 23
9748: PUSH
9749: LD_INT 24
9751: PUSH
9752: LD_INT 25
9754: PUSH
9755: LD_INT 26
9757: PUSH
9758: LD_INT 27
9760: PUSH
9761: LD_INT 28
9763: PUSH
9764: LD_INT 29
9766: PUSH
9767: LD_INT 30
9769: PUSH
9770: LD_INT 31
9772: PUSH
9773: LD_INT 32
9775: PUSH
9776: LD_INT 33
9778: PUSH
9779: LD_INT 34
9781: PUSH
9782: LD_INT 35
9784: PUSH
9785: LD_INT 36
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: PUSH
9826: LD_INT 101
9828: PUSH
9829: LD_INT 102
9831: PUSH
9832: LD_INT 103
9834: PUSH
9835: LD_INT 104
9837: PUSH
9838: LD_INT 105
9840: PUSH
9841: LD_INT 106
9843: PUSH
9844: LD_INT 107
9846: PUSH
9847: LD_INT 108
9849: PUSH
9850: LD_INT 109
9852: PUSH
9853: LD_INT 110
9855: PUSH
9856: LD_INT 111
9858: PUSH
9859: LD_INT 112
9861: PUSH
9862: LD_INT 113
9864: PUSH
9865: LD_INT 114
9867: PUSH
9868: LD_INT 115
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: LIST
9885: LIST
9886: LIST
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: ST_TO_ADDR
9892: GO 9895
9894: POP
// end ; if result then
9895: LD_VAR 0 1
9899: IFFALSE 10188
// begin normal :=  ;
9901: LD_ADDR_VAR 0 3
9905: PUSH
9906: LD_STRING 
9908: ST_TO_ADDR
// hardcore :=  ;
9909: LD_ADDR_VAR 0 4
9913: PUSH
9914: LD_STRING 
9916: ST_TO_ADDR
// for i = 1 to normalCounter do
9917: LD_ADDR_VAR 0 5
9921: PUSH
9922: DOUBLE
9923: LD_INT 1
9925: DEC
9926: ST_TO_ADDR
9927: LD_EXP 27
9931: PUSH
9932: FOR_TO
9933: IFFALSE 10034
// begin tmp := 0 ;
9935: LD_ADDR_VAR 0 2
9939: PUSH
9940: LD_STRING 0
9942: ST_TO_ADDR
// if result [ 1 ] then
9943: LD_VAR 0 1
9947: PUSH
9948: LD_INT 1
9950: ARRAY
9951: IFFALSE 10016
// if result [ 1 ] [ 1 ] = i then
9953: LD_VAR 0 1
9957: PUSH
9958: LD_INT 1
9960: ARRAY
9961: PUSH
9962: LD_INT 1
9964: ARRAY
9965: PUSH
9966: LD_VAR 0 5
9970: EQUAL
9971: IFFALSE 10016
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
9973: LD_ADDR_VAR 0 1
9977: PUSH
9978: LD_VAR 0 1
9982: PPUSH
9983: LD_INT 1
9985: PPUSH
9986: LD_VAR 0 1
9990: PUSH
9991: LD_INT 1
9993: ARRAY
9994: PPUSH
9995: LD_INT 1
9997: PPUSH
9998: CALL_OW 3
10002: PPUSH
10003: CALL_OW 1
10007: ST_TO_ADDR
// tmp := 1 ;
10008: LD_ADDR_VAR 0 2
10012: PUSH
10013: LD_STRING 1
10015: ST_TO_ADDR
// end ; normal := normal & tmp ;
10016: LD_ADDR_VAR 0 3
10020: PUSH
10021: LD_VAR 0 3
10025: PUSH
10026: LD_VAR 0 2
10030: STR
10031: ST_TO_ADDR
// end ;
10032: GO 9932
10034: POP
10035: POP
// for i = 1 to hardcoreCounter do
10036: LD_ADDR_VAR 0 5
10040: PUSH
10041: DOUBLE
10042: LD_INT 1
10044: DEC
10045: ST_TO_ADDR
10046: LD_EXP 28
10050: PUSH
10051: FOR_TO
10052: IFFALSE 10157
// begin tmp := 0 ;
10054: LD_ADDR_VAR 0 2
10058: PUSH
10059: LD_STRING 0
10061: ST_TO_ADDR
// if result [ 2 ] then
10062: LD_VAR 0 1
10066: PUSH
10067: LD_INT 2
10069: ARRAY
10070: IFFALSE 10139
// if result [ 2 ] [ 1 ] = 100 + i then
10072: LD_VAR 0 1
10076: PUSH
10077: LD_INT 2
10079: ARRAY
10080: PUSH
10081: LD_INT 1
10083: ARRAY
10084: PUSH
10085: LD_INT 100
10087: PUSH
10088: LD_VAR 0 5
10092: PLUS
10093: EQUAL
10094: IFFALSE 10139
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
10096: LD_ADDR_VAR 0 1
10100: PUSH
10101: LD_VAR 0 1
10105: PPUSH
10106: LD_INT 2
10108: PPUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_INT 2
10116: ARRAY
10117: PPUSH
10118: LD_INT 1
10120: PPUSH
10121: CALL_OW 3
10125: PPUSH
10126: CALL_OW 1
10130: ST_TO_ADDR
// tmp := 1 ;
10131: LD_ADDR_VAR 0 2
10135: PUSH
10136: LD_STRING 1
10138: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
10139: LD_ADDR_VAR 0 4
10143: PUSH
10144: LD_VAR 0 4
10148: PUSH
10149: LD_VAR 0 2
10153: STR
10154: ST_TO_ADDR
// end ;
10155: GO 10051
10157: POP
10158: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
10159: LD_STRING getStreamItemsFromMission("
10161: PUSH
10162: LD_VAR 0 3
10166: STR
10167: PUSH
10168: LD_STRING ","
10170: STR
10171: PUSH
10172: LD_VAR 0 4
10176: STR
10177: PUSH
10178: LD_STRING ")
10180: STR
10181: PPUSH
10182: CALL_OW 559
// end else
10186: GO 10195
// ToLua ( getStreamItemsFromMission("","") ) ;
10188: LD_STRING getStreamItemsFromMission("","")
10190: PPUSH
10191: CALL_OW 559
// end ;
10195: LD_VAR 0 1
10199: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
10200: LD_VAR 0 2
10204: PUSH
10205: LD_INT 100
10207: EQUAL
10208: IFFALSE 11157
// begin if not StreamModeActive then
10210: LD_EXP 26
10214: NOT
10215: IFFALSE 10225
// StreamModeActive := true ;
10217: LD_ADDR_EXP 26
10221: PUSH
10222: LD_INT 1
10224: ST_TO_ADDR
// if p3 = 0 then
10225: LD_VAR 0 3
10229: PUSH
10230: LD_INT 0
10232: EQUAL
10233: IFFALSE 10239
// InitStreamMode ;
10235: CALL 6497 0 0
// if p3 = 1 then
10239: LD_VAR 0 3
10243: PUSH
10244: LD_INT 1
10246: EQUAL
10247: IFFALSE 10257
// sRocket := true ;
10249: LD_ADDR_EXP 31
10253: PUSH
10254: LD_INT 1
10256: ST_TO_ADDR
// if p3 = 2 then
10257: LD_VAR 0 3
10261: PUSH
10262: LD_INT 2
10264: EQUAL
10265: IFFALSE 10275
// sSpeed := true ;
10267: LD_ADDR_EXP 30
10271: PUSH
10272: LD_INT 1
10274: ST_TO_ADDR
// if p3 = 3 then
10275: LD_VAR 0 3
10279: PUSH
10280: LD_INT 3
10282: EQUAL
10283: IFFALSE 10293
// sEngine := true ;
10285: LD_ADDR_EXP 32
10289: PUSH
10290: LD_INT 1
10292: ST_TO_ADDR
// if p3 = 4 then
10293: LD_VAR 0 3
10297: PUSH
10298: LD_INT 4
10300: EQUAL
10301: IFFALSE 10311
// sSpec := true ;
10303: LD_ADDR_EXP 29
10307: PUSH
10308: LD_INT 1
10310: ST_TO_ADDR
// if p3 = 5 then
10311: LD_VAR 0 3
10315: PUSH
10316: LD_INT 5
10318: EQUAL
10319: IFFALSE 10329
// sLevel := true ;
10321: LD_ADDR_EXP 33
10325: PUSH
10326: LD_INT 1
10328: ST_TO_ADDR
// if p3 = 6 then
10329: LD_VAR 0 3
10333: PUSH
10334: LD_INT 6
10336: EQUAL
10337: IFFALSE 10347
// sArmoury := true ;
10339: LD_ADDR_EXP 34
10343: PUSH
10344: LD_INT 1
10346: ST_TO_ADDR
// if p3 = 7 then
10347: LD_VAR 0 3
10351: PUSH
10352: LD_INT 7
10354: EQUAL
10355: IFFALSE 10365
// sRadar := true ;
10357: LD_ADDR_EXP 35
10361: PUSH
10362: LD_INT 1
10364: ST_TO_ADDR
// if p3 = 8 then
10365: LD_VAR 0 3
10369: PUSH
10370: LD_INT 8
10372: EQUAL
10373: IFFALSE 10383
// sBunker := true ;
10375: LD_ADDR_EXP 36
10379: PUSH
10380: LD_INT 1
10382: ST_TO_ADDR
// if p3 = 9 then
10383: LD_VAR 0 3
10387: PUSH
10388: LD_INT 9
10390: EQUAL
10391: IFFALSE 10401
// sHack := true ;
10393: LD_ADDR_EXP 37
10397: PUSH
10398: LD_INT 1
10400: ST_TO_ADDR
// if p3 = 10 then
10401: LD_VAR 0 3
10405: PUSH
10406: LD_INT 10
10408: EQUAL
10409: IFFALSE 10419
// sFire := true ;
10411: LD_ADDR_EXP 38
10415: PUSH
10416: LD_INT 1
10418: ST_TO_ADDR
// if p3 = 11 then
10419: LD_VAR 0 3
10423: PUSH
10424: LD_INT 11
10426: EQUAL
10427: IFFALSE 10437
// sRefresh := true ;
10429: LD_ADDR_EXP 39
10433: PUSH
10434: LD_INT 1
10436: ST_TO_ADDR
// if p3 = 12 then
10437: LD_VAR 0 3
10441: PUSH
10442: LD_INT 12
10444: EQUAL
10445: IFFALSE 10455
// sExp := true ;
10447: LD_ADDR_EXP 40
10451: PUSH
10452: LD_INT 1
10454: ST_TO_ADDR
// if p3 = 13 then
10455: LD_VAR 0 3
10459: PUSH
10460: LD_INT 13
10462: EQUAL
10463: IFFALSE 10473
// sDepot := true ;
10465: LD_ADDR_EXP 41
10469: PUSH
10470: LD_INT 1
10472: ST_TO_ADDR
// if p3 = 14 then
10473: LD_VAR 0 3
10477: PUSH
10478: LD_INT 14
10480: EQUAL
10481: IFFALSE 10491
// sFlag := true ;
10483: LD_ADDR_EXP 42
10487: PUSH
10488: LD_INT 1
10490: ST_TO_ADDR
// if p3 = 15 then
10491: LD_VAR 0 3
10495: PUSH
10496: LD_INT 15
10498: EQUAL
10499: IFFALSE 10509
// sKamikadze := true ;
10501: LD_ADDR_EXP 50
10505: PUSH
10506: LD_INT 1
10508: ST_TO_ADDR
// if p3 = 16 then
10509: LD_VAR 0 3
10513: PUSH
10514: LD_INT 16
10516: EQUAL
10517: IFFALSE 10527
// sTroll := true ;
10519: LD_ADDR_EXP 51
10523: PUSH
10524: LD_INT 1
10526: ST_TO_ADDR
// if p3 = 17 then
10527: LD_VAR 0 3
10531: PUSH
10532: LD_INT 17
10534: EQUAL
10535: IFFALSE 10545
// sSlow := true ;
10537: LD_ADDR_EXP 52
10541: PUSH
10542: LD_INT 1
10544: ST_TO_ADDR
// if p3 = 18 then
10545: LD_VAR 0 3
10549: PUSH
10550: LD_INT 18
10552: EQUAL
10553: IFFALSE 10563
// sLack := true ;
10555: LD_ADDR_EXP 53
10559: PUSH
10560: LD_INT 1
10562: ST_TO_ADDR
// if p3 = 19 then
10563: LD_VAR 0 3
10567: PUSH
10568: LD_INT 19
10570: EQUAL
10571: IFFALSE 10581
// sTank := true ;
10573: LD_ADDR_EXP 55
10577: PUSH
10578: LD_INT 1
10580: ST_TO_ADDR
// if p3 = 20 then
10581: LD_VAR 0 3
10585: PUSH
10586: LD_INT 20
10588: EQUAL
10589: IFFALSE 10599
// sRemote := true ;
10591: LD_ADDR_EXP 56
10595: PUSH
10596: LD_INT 1
10598: ST_TO_ADDR
// if p3 = 21 then
10599: LD_VAR 0 3
10603: PUSH
10604: LD_INT 21
10606: EQUAL
10607: IFFALSE 10617
// sPowell := true ;
10609: LD_ADDR_EXP 57
10613: PUSH
10614: LD_INT 1
10616: ST_TO_ADDR
// if p3 = 22 then
10617: LD_VAR 0 3
10621: PUSH
10622: LD_INT 22
10624: EQUAL
10625: IFFALSE 10635
// sTeleport := true ;
10627: LD_ADDR_EXP 60
10631: PUSH
10632: LD_INT 1
10634: ST_TO_ADDR
// if p3 = 23 then
10635: LD_VAR 0 3
10639: PUSH
10640: LD_INT 23
10642: EQUAL
10643: IFFALSE 10653
// sOilTower := true ;
10645: LD_ADDR_EXP 62
10649: PUSH
10650: LD_INT 1
10652: ST_TO_ADDR
// if p3 = 24 then
10653: LD_VAR 0 3
10657: PUSH
10658: LD_INT 24
10660: EQUAL
10661: IFFALSE 10671
// sShovel := true ;
10663: LD_ADDR_EXP 63
10667: PUSH
10668: LD_INT 1
10670: ST_TO_ADDR
// if p3 = 25 then
10671: LD_VAR 0 3
10675: PUSH
10676: LD_INT 25
10678: EQUAL
10679: IFFALSE 10689
// sSheik := true ;
10681: LD_ADDR_EXP 64
10685: PUSH
10686: LD_INT 1
10688: ST_TO_ADDR
// if p3 = 26 then
10689: LD_VAR 0 3
10693: PUSH
10694: LD_INT 26
10696: EQUAL
10697: IFFALSE 10707
// sEarthquake := true ;
10699: LD_ADDR_EXP 66
10703: PUSH
10704: LD_INT 1
10706: ST_TO_ADDR
// if p3 = 27 then
10707: LD_VAR 0 3
10711: PUSH
10712: LD_INT 27
10714: EQUAL
10715: IFFALSE 10725
// sAI := true ;
10717: LD_ADDR_EXP 67
10721: PUSH
10722: LD_INT 1
10724: ST_TO_ADDR
// if p3 = 28 then
10725: LD_VAR 0 3
10729: PUSH
10730: LD_INT 28
10732: EQUAL
10733: IFFALSE 10743
// sCargo := true ;
10735: LD_ADDR_EXP 70
10739: PUSH
10740: LD_INT 1
10742: ST_TO_ADDR
// if p3 = 29 then
10743: LD_VAR 0 3
10747: PUSH
10748: LD_INT 29
10750: EQUAL
10751: IFFALSE 10761
// sDLaser := true ;
10753: LD_ADDR_EXP 71
10757: PUSH
10758: LD_INT 1
10760: ST_TO_ADDR
// if p3 = 30 then
10761: LD_VAR 0 3
10765: PUSH
10766: LD_INT 30
10768: EQUAL
10769: IFFALSE 10779
// sExchange := true ;
10771: LD_ADDR_EXP 72
10775: PUSH
10776: LD_INT 1
10778: ST_TO_ADDR
// if p3 = 31 then
10779: LD_VAR 0 3
10783: PUSH
10784: LD_INT 31
10786: EQUAL
10787: IFFALSE 10797
// sFac := true ;
10789: LD_ADDR_EXP 73
10793: PUSH
10794: LD_INT 1
10796: ST_TO_ADDR
// if p3 = 32 then
10797: LD_VAR 0 3
10801: PUSH
10802: LD_INT 32
10804: EQUAL
10805: IFFALSE 10815
// sPower := true ;
10807: LD_ADDR_EXP 74
10811: PUSH
10812: LD_INT 1
10814: ST_TO_ADDR
// if p3 = 33 then
10815: LD_VAR 0 3
10819: PUSH
10820: LD_INT 33
10822: EQUAL
10823: IFFALSE 10833
// sRandom := true ;
10825: LD_ADDR_EXP 75
10829: PUSH
10830: LD_INT 1
10832: ST_TO_ADDR
// if p3 = 34 then
10833: LD_VAR 0 3
10837: PUSH
10838: LD_INT 34
10840: EQUAL
10841: IFFALSE 10851
// sShield := true ;
10843: LD_ADDR_EXP 76
10847: PUSH
10848: LD_INT 1
10850: ST_TO_ADDR
// if p3 = 35 then
10851: LD_VAR 0 3
10855: PUSH
10856: LD_INT 35
10858: EQUAL
10859: IFFALSE 10869
// sTime := true ;
10861: LD_ADDR_EXP 77
10865: PUSH
10866: LD_INT 1
10868: ST_TO_ADDR
// if p3 = 36 then
10869: LD_VAR 0 3
10873: PUSH
10874: LD_INT 36
10876: EQUAL
10877: IFFALSE 10887
// sTools := true ;
10879: LD_ADDR_EXP 78
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
// if p3 = 101 then
10887: LD_VAR 0 3
10891: PUSH
10892: LD_INT 101
10894: EQUAL
10895: IFFALSE 10905
// sSold := true ;
10897: LD_ADDR_EXP 43
10901: PUSH
10902: LD_INT 1
10904: ST_TO_ADDR
// if p3 = 102 then
10905: LD_VAR 0 3
10909: PUSH
10910: LD_INT 102
10912: EQUAL
10913: IFFALSE 10923
// sDiff := true ;
10915: LD_ADDR_EXP 44
10919: PUSH
10920: LD_INT 1
10922: ST_TO_ADDR
// if p3 = 103 then
10923: LD_VAR 0 3
10927: PUSH
10928: LD_INT 103
10930: EQUAL
10931: IFFALSE 10941
// sFog := true ;
10933: LD_ADDR_EXP 47
10937: PUSH
10938: LD_INT 1
10940: ST_TO_ADDR
// if p3 = 104 then
10941: LD_VAR 0 3
10945: PUSH
10946: LD_INT 104
10948: EQUAL
10949: IFFALSE 10959
// sReset := true ;
10951: LD_ADDR_EXP 48
10955: PUSH
10956: LD_INT 1
10958: ST_TO_ADDR
// if p3 = 105 then
10959: LD_VAR 0 3
10963: PUSH
10964: LD_INT 105
10966: EQUAL
10967: IFFALSE 10977
// sSun := true ;
10969: LD_ADDR_EXP 49
10973: PUSH
10974: LD_INT 1
10976: ST_TO_ADDR
// if p3 = 106 then
10977: LD_VAR 0 3
10981: PUSH
10982: LD_INT 106
10984: EQUAL
10985: IFFALSE 10995
// sTiger := true ;
10987: LD_ADDR_EXP 45
10991: PUSH
10992: LD_INT 1
10994: ST_TO_ADDR
// if p3 = 107 then
10995: LD_VAR 0 3
10999: PUSH
11000: LD_INT 107
11002: EQUAL
11003: IFFALSE 11013
// sBomb := true ;
11005: LD_ADDR_EXP 46
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// if p3 = 108 then
11013: LD_VAR 0 3
11017: PUSH
11018: LD_INT 108
11020: EQUAL
11021: IFFALSE 11031
// sWound := true ;
11023: LD_ADDR_EXP 54
11027: PUSH
11028: LD_INT 1
11030: ST_TO_ADDR
// if p3 = 109 then
11031: LD_VAR 0 3
11035: PUSH
11036: LD_INT 109
11038: EQUAL
11039: IFFALSE 11049
// sBetray := true ;
11041: LD_ADDR_EXP 58
11045: PUSH
11046: LD_INT 1
11048: ST_TO_ADDR
// if p3 = 110 then
11049: LD_VAR 0 3
11053: PUSH
11054: LD_INT 110
11056: EQUAL
11057: IFFALSE 11067
// sContamin := true ;
11059: LD_ADDR_EXP 59
11063: PUSH
11064: LD_INT 1
11066: ST_TO_ADDR
// if p3 = 111 then
11067: LD_VAR 0 3
11071: PUSH
11072: LD_INT 111
11074: EQUAL
11075: IFFALSE 11085
// sOil := true ;
11077: LD_ADDR_EXP 61
11081: PUSH
11082: LD_INT 1
11084: ST_TO_ADDR
// if p3 = 112 then
11085: LD_VAR 0 3
11089: PUSH
11090: LD_INT 112
11092: EQUAL
11093: IFFALSE 11103
// sStu := true ;
11095: LD_ADDR_EXP 65
11099: PUSH
11100: LD_INT 1
11102: ST_TO_ADDR
// if p3 = 113 then
11103: LD_VAR 0 3
11107: PUSH
11108: LD_INT 113
11110: EQUAL
11111: IFFALSE 11121
// sBazooka := true ;
11113: LD_ADDR_EXP 68
11117: PUSH
11118: LD_INT 1
11120: ST_TO_ADDR
// if p3 = 114 then
11121: LD_VAR 0 3
11125: PUSH
11126: LD_INT 114
11128: EQUAL
11129: IFFALSE 11139
// sMortar := true ;
11131: LD_ADDR_EXP 69
11135: PUSH
11136: LD_INT 1
11138: ST_TO_ADDR
// if p3 = 115 then
11139: LD_VAR 0 3
11143: PUSH
11144: LD_INT 115
11146: EQUAL
11147: IFFALSE 11157
// sRanger := true ;
11149: LD_ADDR_EXP 79
11153: PUSH
11154: LD_INT 1
11156: ST_TO_ADDR
// end ; end ;
11157: PPOPN 6
11159: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11160: LD_EXP 26
11164: PUSH
11165: LD_EXP 31
11169: AND
11170: IFFALSE 11294
11172: GO 11174
11174: DISABLE
11175: LD_INT 0
11177: PPUSH
11178: PPUSH
// begin enable ;
11179: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 22
11187: PUSH
11188: LD_OWVAR 2
11192: PUSH
11193: EMPTY
11194: LIST
11195: LIST
11196: PUSH
11197: LD_INT 2
11199: PUSH
11200: LD_INT 34
11202: PUSH
11203: LD_INT 7
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: PUSH
11210: LD_INT 34
11212: PUSH
11213: LD_INT 45
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 34
11222: PUSH
11223: LD_INT 28
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 34
11232: PUSH
11233: LD_INT 47
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PPUSH
11251: CALL_OW 69
11255: ST_TO_ADDR
// if not tmp then
11256: LD_VAR 0 2
11260: NOT
11261: IFFALSE 11265
// exit ;
11263: GO 11294
// for i in tmp do
11265: LD_ADDR_VAR 0 1
11269: PUSH
11270: LD_VAR 0 2
11274: PUSH
11275: FOR_IN
11276: IFFALSE 11292
// begin SetLives ( i , 0 ) ;
11278: LD_VAR 0 1
11282: PPUSH
11283: LD_INT 0
11285: PPUSH
11286: CALL_OW 234
// end ;
11290: GO 11275
11292: POP
11293: POP
// end ;
11294: PPOPN 2
11296: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
11297: LD_EXP 26
11301: PUSH
11302: LD_EXP 32
11306: AND
11307: IFFALSE 11391
11309: GO 11311
11311: DISABLE
11312: LD_INT 0
11314: PPUSH
11315: PPUSH
// begin enable ;
11316: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
11317: LD_ADDR_VAR 0 2
11321: PUSH
11322: LD_INT 22
11324: PUSH
11325: LD_OWVAR 2
11329: PUSH
11330: EMPTY
11331: LIST
11332: LIST
11333: PUSH
11334: LD_INT 32
11336: PUSH
11337: LD_INT 3
11339: PUSH
11340: EMPTY
11341: LIST
11342: LIST
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PPUSH
11348: CALL_OW 69
11352: ST_TO_ADDR
// if not tmp then
11353: LD_VAR 0 2
11357: NOT
11358: IFFALSE 11362
// exit ;
11360: GO 11391
// for i in tmp do
11362: LD_ADDR_VAR 0 1
11366: PUSH
11367: LD_VAR 0 2
11371: PUSH
11372: FOR_IN
11373: IFFALSE 11389
// begin SetLives ( i , 0 ) ;
11375: LD_VAR 0 1
11379: PPUSH
11380: LD_INT 0
11382: PPUSH
11383: CALL_OW 234
// end ;
11387: GO 11372
11389: POP
11390: POP
// end ;
11391: PPOPN 2
11393: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
11394: LD_EXP 26
11398: PUSH
11399: LD_EXP 29
11403: AND
11404: IFFALSE 11497
11406: GO 11408
11408: DISABLE
11409: LD_INT 0
11411: PPUSH
// begin enable ;
11412: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
11413: LD_ADDR_VAR 0 1
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_OWVAR 2
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 5
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 9
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 25
11455: PUSH
11456: LD_INT 8
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: EMPTY
11464: LIST
11465: LIST
11466: LIST
11467: LIST
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PPUSH
11473: CALL_OW 69
11477: PUSH
11478: FOR_IN
11479: IFFALSE 11495
// begin SetClass ( i , 1 ) ;
11481: LD_VAR 0 1
11485: PPUSH
11486: LD_INT 1
11488: PPUSH
11489: CALL_OW 336
// end ;
11493: GO 11478
11495: POP
11496: POP
// end ;
11497: PPOPN 1
11499: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
11500: LD_EXP 26
11504: PUSH
11505: LD_EXP 30
11509: AND
11510: PUSH
11511: LD_OWVAR 65
11515: PUSH
11516: LD_INT 7
11518: LESS
11519: AND
11520: IFFALSE 11534
11522: GO 11524
11524: DISABLE
// begin enable ;
11525: ENABLE
// game_speed := 7 ;
11526: LD_ADDR_OWVAR 65
11530: PUSH
11531: LD_INT 7
11533: ST_TO_ADDR
// end ;
11534: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
11535: LD_EXP 26
11539: PUSH
11540: LD_EXP 33
11544: AND
11545: IFFALSE 11747
11547: GO 11549
11549: DISABLE
11550: LD_INT 0
11552: PPUSH
11553: PPUSH
11554: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_INT 81
11562: PUSH
11563: LD_OWVAR 2
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 21
11574: PUSH
11575: LD_INT 1
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: PPUSH
11586: CALL_OW 69
11590: ST_TO_ADDR
// if not tmp then
11591: LD_VAR 0 3
11595: NOT
11596: IFFALSE 11600
// exit ;
11598: GO 11747
// if tmp > 5 then
11600: LD_VAR 0 3
11604: PUSH
11605: LD_INT 5
11607: GREATER
11608: IFFALSE 11620
// k := 5 else
11610: LD_ADDR_VAR 0 2
11614: PUSH
11615: LD_INT 5
11617: ST_TO_ADDR
11618: GO 11630
// k := tmp ;
11620: LD_ADDR_VAR 0 2
11624: PUSH
11625: LD_VAR 0 3
11629: ST_TO_ADDR
// for i := 1 to k do
11630: LD_ADDR_VAR 0 1
11634: PUSH
11635: DOUBLE
11636: LD_INT 1
11638: DEC
11639: ST_TO_ADDR
11640: LD_VAR 0 2
11644: PUSH
11645: FOR_TO
11646: IFFALSE 11745
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
11648: LD_VAR 0 3
11652: PUSH
11653: LD_VAR 0 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 4
11666: MOD
11667: PUSH
11668: LD_INT 1
11670: PLUS
11671: PPUSH
11672: CALL_OW 259
11676: PUSH
11677: LD_INT 10
11679: LESS
11680: IFFALSE 11743
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
11682: LD_VAR 0 3
11686: PUSH
11687: LD_VAR 0 1
11691: ARRAY
11692: PPUSH
11693: LD_VAR 0 1
11697: PUSH
11698: LD_INT 4
11700: MOD
11701: PUSH
11702: LD_INT 1
11704: PLUS
11705: PPUSH
11706: LD_VAR 0 3
11710: PUSH
11711: LD_VAR 0 1
11715: ARRAY
11716: PPUSH
11717: LD_VAR 0 1
11721: PUSH
11722: LD_INT 4
11724: MOD
11725: PUSH
11726: LD_INT 1
11728: PLUS
11729: PPUSH
11730: CALL_OW 259
11734: PUSH
11735: LD_INT 1
11737: PLUS
11738: PPUSH
11739: CALL_OW 237
11743: GO 11645
11745: POP
11746: POP
// end ;
11747: PPOPN 3
11749: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
11750: LD_EXP 26
11754: PUSH
11755: LD_EXP 34
11759: AND
11760: IFFALSE 11780
11762: GO 11764
11764: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
11765: LD_INT 4
11767: PPUSH
11768: LD_OWVAR 2
11772: PPUSH
11773: LD_INT 0
11775: PPUSH
11776: CALL_OW 324
11780: END
// every 0 0$1 trigger StreamModeActive and sShovel do
11781: LD_EXP 26
11785: PUSH
11786: LD_EXP 63
11790: AND
11791: IFFALSE 11811
11793: GO 11795
11795: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
11796: LD_INT 19
11798: PPUSH
11799: LD_OWVAR 2
11803: PPUSH
11804: LD_INT 0
11806: PPUSH
11807: CALL_OW 324
11811: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
11812: LD_EXP 26
11816: PUSH
11817: LD_EXP 35
11821: AND
11822: IFFALSE 11924
11824: GO 11826
11826: DISABLE
11827: LD_INT 0
11829: PPUSH
11830: PPUSH
// begin enable ;
11831: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
11832: LD_ADDR_VAR 0 2
11836: PUSH
11837: LD_INT 22
11839: PUSH
11840: LD_OWVAR 2
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 2
11851: PUSH
11852: LD_INT 34
11854: PUSH
11855: LD_INT 11
11857: PUSH
11858: EMPTY
11859: LIST
11860: LIST
11861: PUSH
11862: LD_INT 34
11864: PUSH
11865: LD_INT 30
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: EMPTY
11873: LIST
11874: LIST
11875: LIST
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: ST_TO_ADDR
// if not tmp then
11886: LD_VAR 0 2
11890: NOT
11891: IFFALSE 11895
// exit ;
11893: GO 11924
// for i in tmp do
11895: LD_ADDR_VAR 0 1
11899: PUSH
11900: LD_VAR 0 2
11904: PUSH
11905: FOR_IN
11906: IFFALSE 11922
// begin SetLives ( i , 0 ) ;
11908: LD_VAR 0 1
11912: PPUSH
11913: LD_INT 0
11915: PPUSH
11916: CALL_OW 234
// end ;
11920: GO 11905
11922: POP
11923: POP
// end ;
11924: PPOPN 2
11926: END
// every 0 0$1 trigger StreamModeActive and sBunker do
11927: LD_EXP 26
11931: PUSH
11932: LD_EXP 36
11936: AND
11937: IFFALSE 11957
11939: GO 11941
11941: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
11942: LD_INT 32
11944: PPUSH
11945: LD_OWVAR 2
11949: PPUSH
11950: LD_INT 0
11952: PPUSH
11953: CALL_OW 324
11957: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
11958: LD_EXP 26
11962: PUSH
11963: LD_EXP 37
11967: AND
11968: IFFALSE 12149
11970: GO 11972
11972: DISABLE
11973: LD_INT 0
11975: PPUSH
11976: PPUSH
11977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
11978: LD_ADDR_VAR 0 2
11982: PUSH
11983: LD_INT 22
11985: PUSH
11986: LD_OWVAR 2
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: PUSH
11995: LD_INT 33
11997: PUSH
11998: LD_INT 3
12000: PUSH
12001: EMPTY
12002: LIST
12003: LIST
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PPUSH
12009: CALL_OW 69
12013: ST_TO_ADDR
// if not tmp then
12014: LD_VAR 0 2
12018: NOT
12019: IFFALSE 12023
// exit ;
12021: GO 12149
// side := 0 ;
12023: LD_ADDR_VAR 0 3
12027: PUSH
12028: LD_INT 0
12030: ST_TO_ADDR
// for i := 1 to 8 do
12031: LD_ADDR_VAR 0 1
12035: PUSH
12036: DOUBLE
12037: LD_INT 1
12039: DEC
12040: ST_TO_ADDR
12041: LD_INT 8
12043: PUSH
12044: FOR_TO
12045: IFFALSE 12093
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12047: LD_OWVAR 2
12051: PUSH
12052: LD_VAR 0 1
12056: NONEQUAL
12057: PUSH
12058: LD_OWVAR 2
12062: PPUSH
12063: LD_VAR 0 1
12067: PPUSH
12068: CALL_OW 81
12072: PUSH
12073: LD_INT 2
12075: EQUAL
12076: AND
12077: IFFALSE 12091
// begin side := i ;
12079: LD_ADDR_VAR 0 3
12083: PUSH
12084: LD_VAR 0 1
12088: ST_TO_ADDR
// break ;
12089: GO 12093
// end ;
12091: GO 12044
12093: POP
12094: POP
// if not side then
12095: LD_VAR 0 3
12099: NOT
12100: IFFALSE 12104
// exit ;
12102: GO 12149
// for i := 1 to tmp do
12104: LD_ADDR_VAR 0 1
12108: PUSH
12109: DOUBLE
12110: LD_INT 1
12112: DEC
12113: ST_TO_ADDR
12114: LD_VAR 0 2
12118: PUSH
12119: FOR_TO
12120: IFFALSE 12147
// if Prob ( 60 ) then
12122: LD_INT 60
12124: PPUSH
12125: CALL_OW 13
12129: IFFALSE 12145
// SetSide ( i , side ) ;
12131: LD_VAR 0 1
12135: PPUSH
12136: LD_VAR 0 3
12140: PPUSH
12141: CALL_OW 235
12145: GO 12119
12147: POP
12148: POP
// end ;
12149: PPOPN 3
12151: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12152: LD_EXP 26
12156: PUSH
12157: LD_EXP 39
12161: AND
12162: IFFALSE 12281
12164: GO 12166
12166: DISABLE
12167: LD_INT 0
12169: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12170: LD_ADDR_VAR 0 1
12174: PUSH
12175: LD_INT 22
12177: PUSH
12178: LD_OWVAR 2
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 21
12189: PUSH
12190: LD_INT 1
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 3
12199: PUSH
12200: LD_INT 23
12202: PUSH
12203: LD_INT 0
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: LIST
12218: PPUSH
12219: CALL_OW 69
12223: PUSH
12224: FOR_IN
12225: IFFALSE 12279
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 257
12236: PUSH
12237: LD_INT 1
12239: PUSH
12240: LD_INT 2
12242: PUSH
12243: LD_INT 3
12245: PUSH
12246: LD_INT 4
12248: PUSH
12249: EMPTY
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: IN
12255: IFFALSE 12277
// SetClass ( un , rand ( 1 , 4 ) ) ;
12257: LD_VAR 0 1
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: LD_INT 4
12267: PPUSH
12268: CALL_OW 12
12272: PPUSH
12273: CALL_OW 336
12277: GO 12224
12279: POP
12280: POP
// end ;
12281: PPOPN 1
12283: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
12284: LD_EXP 26
12288: PUSH
12289: LD_EXP 38
12293: AND
12294: IFFALSE 12373
12296: GO 12298
12298: DISABLE
12299: LD_INT 0
12301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12302: LD_ADDR_VAR 0 1
12306: PUSH
12307: LD_INT 22
12309: PUSH
12310: LD_OWVAR 2
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 21
12321: PUSH
12322: LD_INT 3
12324: PUSH
12325: EMPTY
12326: LIST
12327: LIST
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PPUSH
12333: CALL_OW 69
12337: ST_TO_ADDR
// if not tmp then
12338: LD_VAR 0 1
12342: NOT
12343: IFFALSE 12347
// exit ;
12345: GO 12373
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
12347: LD_VAR 0 1
12351: PUSH
12352: LD_INT 1
12354: PPUSH
12355: LD_VAR 0 1
12359: PPUSH
12360: CALL_OW 12
12364: ARRAY
12365: PPUSH
12366: LD_INT 100
12368: PPUSH
12369: CALL_OW 234
// end ;
12373: PPOPN 1
12375: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
12376: LD_EXP 26
12380: PUSH
12381: LD_EXP 40
12385: AND
12386: IFFALSE 12484
12388: GO 12390
12390: DISABLE
12391: LD_INT 0
12393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12394: LD_ADDR_VAR 0 1
12398: PUSH
12399: LD_INT 22
12401: PUSH
12402: LD_OWVAR 2
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: PUSH
12411: LD_INT 21
12413: PUSH
12414: LD_INT 1
12416: PUSH
12417: EMPTY
12418: LIST
12419: LIST
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: PPUSH
12425: CALL_OW 69
12429: ST_TO_ADDR
// if not tmp then
12430: LD_VAR 0 1
12434: NOT
12435: IFFALSE 12439
// exit ;
12437: GO 12484
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
12439: LD_VAR 0 1
12443: PUSH
12444: LD_INT 1
12446: PPUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 12
12456: ARRAY
12457: PPUSH
12458: LD_INT 1
12460: PPUSH
12461: LD_INT 4
12463: PPUSH
12464: CALL_OW 12
12468: PPUSH
12469: LD_INT 3000
12471: PPUSH
12472: LD_INT 9000
12474: PPUSH
12475: CALL_OW 12
12479: PPUSH
12480: CALL_OW 492
// end ;
12484: PPOPN 1
12486: END
// every 0 0$1 trigger StreamModeActive and sDepot do
12487: LD_EXP 26
12491: PUSH
12492: LD_EXP 41
12496: AND
12497: IFFALSE 12517
12499: GO 12501
12501: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
12502: LD_INT 1
12504: PPUSH
12505: LD_OWVAR 2
12509: PPUSH
12510: LD_INT 0
12512: PPUSH
12513: CALL_OW 324
12517: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
12518: LD_EXP 26
12522: PUSH
12523: LD_EXP 42
12527: AND
12528: IFFALSE 12611
12530: GO 12532
12532: DISABLE
12533: LD_INT 0
12535: PPUSH
12536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
12537: LD_ADDR_VAR 0 2
12541: PUSH
12542: LD_INT 22
12544: PUSH
12545: LD_OWVAR 2
12549: PUSH
12550: EMPTY
12551: LIST
12552: LIST
12553: PUSH
12554: LD_INT 21
12556: PUSH
12557: LD_INT 3
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: PPUSH
12568: CALL_OW 69
12572: ST_TO_ADDR
// if not tmp then
12573: LD_VAR 0 2
12577: NOT
12578: IFFALSE 12582
// exit ;
12580: GO 12611
// for i in tmp do
12582: LD_ADDR_VAR 0 1
12586: PUSH
12587: LD_VAR 0 2
12591: PUSH
12592: FOR_IN
12593: IFFALSE 12609
// SetBLevel ( i , 10 ) ;
12595: LD_VAR 0 1
12599: PPUSH
12600: LD_INT 10
12602: PPUSH
12603: CALL_OW 241
12607: GO 12592
12609: POP
12610: POP
// end ;
12611: PPOPN 2
12613: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
12614: LD_EXP 26
12618: PUSH
12619: LD_EXP 43
12623: AND
12624: IFFALSE 12735
12626: GO 12628
12628: DISABLE
12629: LD_INT 0
12631: PPUSH
12632: PPUSH
12633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12634: LD_ADDR_VAR 0 3
12638: PUSH
12639: LD_INT 22
12641: PUSH
12642: LD_OWVAR 2
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: LD_INT 25
12653: PUSH
12654: LD_INT 1
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: EMPTY
12662: LIST
12663: LIST
12664: PPUSH
12665: CALL_OW 69
12669: ST_TO_ADDR
// if not tmp then
12670: LD_VAR 0 3
12674: NOT
12675: IFFALSE 12679
// exit ;
12677: GO 12735
// un := tmp [ rand ( 1 , tmp ) ] ;
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: PPUSH
12692: LD_VAR 0 3
12696: PPUSH
12697: CALL_OW 12
12701: ARRAY
12702: ST_TO_ADDR
// if Crawls ( un ) then
12703: LD_VAR 0 2
12707: PPUSH
12708: CALL_OW 318
12712: IFFALSE 12723
// ComWalk ( un ) ;
12714: LD_VAR 0 2
12718: PPUSH
12719: CALL_OW 138
// SetClass ( un , class_sniper ) ;
12723: LD_VAR 0 2
12727: PPUSH
12728: LD_INT 5
12730: PPUSH
12731: CALL_OW 336
// end ;
12735: PPOPN 3
12737: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
12738: LD_EXP 26
12742: PUSH
12743: LD_EXP 44
12747: AND
12748: PUSH
12749: LD_OWVAR 67
12753: PUSH
12754: LD_INT 3
12756: LESS
12757: AND
12758: IFFALSE 12777
12760: GO 12762
12762: DISABLE
// Difficulty := Difficulty + 1 ;
12763: LD_ADDR_OWVAR 67
12767: PUSH
12768: LD_OWVAR 67
12772: PUSH
12773: LD_INT 1
12775: PLUS
12776: ST_TO_ADDR
12777: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
12778: LD_EXP 26
12782: PUSH
12783: LD_EXP 45
12787: AND
12788: IFFALSE 12891
12790: GO 12792
12792: DISABLE
12793: LD_INT 0
12795: PPUSH
// begin for i := 1 to 5 do
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: DOUBLE
12802: LD_INT 1
12804: DEC
12805: ST_TO_ADDR
12806: LD_INT 5
12808: PUSH
12809: FOR_TO
12810: IFFALSE 12889
// begin uc_nation := nation_nature ;
12812: LD_ADDR_OWVAR 21
12816: PUSH
12817: LD_INT 0
12819: ST_TO_ADDR
// uc_side := 0 ;
12820: LD_ADDR_OWVAR 20
12824: PUSH
12825: LD_INT 0
12827: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
12828: LD_ADDR_OWVAR 29
12832: PUSH
12833: LD_INT 12
12835: PUSH
12836: LD_INT 12
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: ST_TO_ADDR
// hc_agressivity := 20 ;
12843: LD_ADDR_OWVAR 35
12847: PUSH
12848: LD_INT 20
12850: ST_TO_ADDR
// hc_class := class_tiger ;
12851: LD_ADDR_OWVAR 28
12855: PUSH
12856: LD_INT 14
12858: ST_TO_ADDR
// hc_gallery :=  ;
12859: LD_ADDR_OWVAR 33
12863: PUSH
12864: LD_STRING 
12866: ST_TO_ADDR
// hc_name :=  ;
12867: LD_ADDR_OWVAR 26
12871: PUSH
12872: LD_STRING 
12874: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
12875: CALL_OW 44
12879: PPUSH
12880: LD_INT 0
12882: PPUSH
12883: CALL_OW 51
// end ;
12887: GO 12809
12889: POP
12890: POP
// end ;
12891: PPOPN 1
12893: END
// every 0 0$1 trigger StreamModeActive and sBomb do
12894: LD_EXP 26
12898: PUSH
12899: LD_EXP 46
12903: AND
12904: IFFALSE 12913
12906: GO 12908
12908: DISABLE
// StreamSibBomb ;
12909: CALL 12914 0 0
12913: END
// export function StreamSibBomb ; var i , x , y ; begin
12914: LD_INT 0
12916: PPUSH
12917: PPUSH
12918: PPUSH
12919: PPUSH
// result := false ;
12920: LD_ADDR_VAR 0 1
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// for i := 1 to 16 do
12928: LD_ADDR_VAR 0 2
12932: PUSH
12933: DOUBLE
12934: LD_INT 1
12936: DEC
12937: ST_TO_ADDR
12938: LD_INT 16
12940: PUSH
12941: FOR_TO
12942: IFFALSE 13141
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
12944: LD_ADDR_VAR 0 3
12948: PUSH
12949: LD_INT 10
12951: PUSH
12952: LD_INT 20
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 40
12960: PUSH
12961: LD_INT 50
12963: PUSH
12964: LD_INT 60
12966: PUSH
12967: LD_INT 70
12969: PUSH
12970: LD_INT 80
12972: PUSH
12973: LD_INT 90
12975: PUSH
12976: LD_INT 100
12978: PUSH
12979: LD_INT 110
12981: PUSH
12982: LD_INT 120
12984: PUSH
12985: LD_INT 130
12987: PUSH
12988: LD_INT 140
12990: PUSH
12991: LD_INT 150
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: PUSH
13011: LD_INT 1
13013: PPUSH
13014: LD_INT 15
13016: PPUSH
13017: CALL_OW 12
13021: ARRAY
13022: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
13023: LD_ADDR_VAR 0 4
13027: PUSH
13028: LD_INT 10
13030: PUSH
13031: LD_INT 20
13033: PUSH
13034: LD_INT 30
13036: PUSH
13037: LD_INT 40
13039: PUSH
13040: LD_INT 50
13042: PUSH
13043: LD_INT 60
13045: PUSH
13046: LD_INT 70
13048: PUSH
13049: LD_INT 80
13051: PUSH
13052: LD_INT 90
13054: PUSH
13055: LD_INT 100
13057: PUSH
13058: LD_INT 110
13060: PUSH
13061: LD_INT 120
13063: PUSH
13064: LD_INT 130
13066: PUSH
13067: LD_INT 140
13069: PUSH
13070: LD_INT 150
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: PUSH
13090: LD_INT 1
13092: PPUSH
13093: LD_INT 15
13095: PPUSH
13096: CALL_OW 12
13100: ARRAY
13101: ST_TO_ADDR
// if ValidHex ( x , y ) then
13102: LD_VAR 0 3
13106: PPUSH
13107: LD_VAR 0 4
13111: PPUSH
13112: CALL_OW 488
13116: IFFALSE 13139
// begin result := [ x , y ] ;
13118: LD_ADDR_VAR 0 1
13122: PUSH
13123: LD_VAR 0 3
13127: PUSH
13128: LD_VAR 0 4
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: ST_TO_ADDR
// break ;
13137: GO 13141
// end ; end ;
13139: GO 12941
13141: POP
13142: POP
// if result then
13143: LD_VAR 0 1
13147: IFFALSE 13207
// begin ToLua ( playSibBomb() ) ;
13149: LD_STRING playSibBomb()
13151: PPUSH
13152: CALL_OW 559
// wait ( 0 0$14 ) ;
13156: LD_INT 490
13158: PPUSH
13159: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
13163: LD_VAR 0 1
13167: PUSH
13168: LD_INT 1
13170: ARRAY
13171: PPUSH
13172: LD_VAR 0 1
13176: PUSH
13177: LD_INT 2
13179: ARRAY
13180: PPUSH
13181: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13185: LD_VAR 0 1
13189: PUSH
13190: LD_INT 1
13192: ARRAY
13193: PPUSH
13194: LD_VAR 0 1
13198: PUSH
13199: LD_INT 2
13201: ARRAY
13202: PPUSH
13203: CALL_OW 429
// end ; end ;
13207: LD_VAR 0 1
13211: RET
// every 0 0$1 trigger StreamModeActive and sReset do
13212: LD_EXP 26
13216: PUSH
13217: LD_EXP 48
13221: AND
13222: IFFALSE 13234
13224: GO 13226
13226: DISABLE
// YouLost (  ) ;
13227: LD_STRING 
13229: PPUSH
13230: CALL_OW 104
13234: END
// every 0 0$1 trigger StreamModeActive and sFog do
13235: LD_EXP 26
13239: PUSH
13240: LD_EXP 47
13244: AND
13245: IFFALSE 13259
13247: GO 13249
13249: DISABLE
// FogOff ( your_side ) ;
13250: LD_OWVAR 2
13254: PPUSH
13255: CALL_OW 344
13259: END
// every 0 0$1 trigger StreamModeActive and sSun do
13260: LD_EXP 26
13264: PUSH
13265: LD_EXP 49
13269: AND
13270: IFFALSE 13298
13272: GO 13274
13274: DISABLE
// begin solar_recharge_percent := 0 ;
13275: LD_ADDR_OWVAR 79
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13283: LD_INT 10500
13285: PPUSH
13286: CALL_OW 67
// solar_recharge_percent := 100 ;
13290: LD_ADDR_OWVAR 79
13294: PUSH
13295: LD_INT 100
13297: ST_TO_ADDR
// end ;
13298: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13299: LD_EXP 26
13303: PUSH
13304: LD_EXP 50
13308: AND
13309: IFFALSE 13548
13311: GO 13313
13313: DISABLE
13314: LD_INT 0
13316: PPUSH
13317: PPUSH
13318: PPUSH
// begin tmp := [ ] ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: EMPTY
13325: ST_TO_ADDR
// for i := 1 to 6 do
13326: LD_ADDR_VAR 0 1
13330: PUSH
13331: DOUBLE
13332: LD_INT 1
13334: DEC
13335: ST_TO_ADDR
13336: LD_INT 6
13338: PUSH
13339: FOR_TO
13340: IFFALSE 13445
// begin uc_nation := nation_nature ;
13342: LD_ADDR_OWVAR 21
13346: PUSH
13347: LD_INT 0
13349: ST_TO_ADDR
// uc_side := 0 ;
13350: LD_ADDR_OWVAR 20
13354: PUSH
13355: LD_INT 0
13357: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13358: LD_ADDR_OWVAR 29
13362: PUSH
13363: LD_INT 12
13365: PUSH
13366: LD_INT 12
13368: PUSH
13369: EMPTY
13370: LIST
13371: LIST
13372: ST_TO_ADDR
// hc_agressivity := 20 ;
13373: LD_ADDR_OWVAR 35
13377: PUSH
13378: LD_INT 20
13380: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13381: LD_ADDR_OWVAR 28
13385: PUSH
13386: LD_INT 17
13388: ST_TO_ADDR
// hc_gallery :=  ;
13389: LD_ADDR_OWVAR 33
13393: PUSH
13394: LD_STRING 
13396: ST_TO_ADDR
// hc_name :=  ;
13397: LD_ADDR_OWVAR 26
13401: PUSH
13402: LD_STRING 
13404: ST_TO_ADDR
// un := CreateHuman ;
13405: LD_ADDR_VAR 0 2
13409: PUSH
13410: CALL_OW 44
13414: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
13415: LD_VAR 0 2
13419: PPUSH
13420: LD_INT 1
13422: PPUSH
13423: CALL_OW 51
// tmp := tmp ^ un ;
13427: LD_ADDR_VAR 0 3
13431: PUSH
13432: LD_VAR 0 3
13436: PUSH
13437: LD_VAR 0 2
13441: ADD
13442: ST_TO_ADDR
// end ;
13443: GO 13339
13445: POP
13446: POP
// repeat wait ( 0 0$1 ) ;
13447: LD_INT 35
13449: PPUSH
13450: CALL_OW 67
// for un in tmp do
13454: LD_ADDR_VAR 0 2
13458: PUSH
13459: LD_VAR 0 3
13463: PUSH
13464: FOR_IN
13465: IFFALSE 13539
// begin if IsDead ( un ) then
13467: LD_VAR 0 2
13471: PPUSH
13472: CALL_OW 301
13476: IFFALSE 13496
// begin tmp := tmp diff un ;
13478: LD_ADDR_VAR 0 3
13482: PUSH
13483: LD_VAR 0 3
13487: PUSH
13488: LD_VAR 0 2
13492: DIFF
13493: ST_TO_ADDR
// continue ;
13494: GO 13464
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
13496: LD_VAR 0 2
13500: PPUSH
13501: LD_INT 3
13503: PUSH
13504: LD_INT 22
13506: PUSH
13507: LD_INT 0
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: PPUSH
13518: CALL_OW 69
13522: PPUSH
13523: LD_VAR 0 2
13527: PPUSH
13528: CALL_OW 74
13532: PPUSH
13533: CALL_OW 115
// end ;
13537: GO 13464
13539: POP
13540: POP
// until not tmp ;
13541: LD_VAR 0 3
13545: NOT
13546: IFFALSE 13447
// end ;
13548: PPOPN 3
13550: END
// every 0 0$1 trigger StreamModeActive and sTroll do
13551: LD_EXP 26
13555: PUSH
13556: LD_EXP 51
13560: AND
13561: IFFALSE 13615
13563: GO 13565
13565: DISABLE
// begin ToLua ( displayTroll(); ) ;
13566: LD_STRING displayTroll();
13568: PPUSH
13569: CALL_OW 559
// wait ( 3 3$00 ) ;
13573: LD_INT 6300
13575: PPUSH
13576: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13580: LD_STRING hideTroll();
13582: PPUSH
13583: CALL_OW 559
// wait ( 1 1$00 ) ;
13587: LD_INT 2100
13589: PPUSH
13590: CALL_OW 67
// ToLua ( displayTroll(); ) ;
13594: LD_STRING displayTroll();
13596: PPUSH
13597: CALL_OW 559
// wait ( 1 1$00 ) ;
13601: LD_INT 2100
13603: PPUSH
13604: CALL_OW 67
// ToLua ( hideTroll(); ) ;
13608: LD_STRING hideTroll();
13610: PPUSH
13611: CALL_OW 559
// end ;
13615: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
13616: LD_EXP 26
13620: PUSH
13621: LD_EXP 52
13625: AND
13626: IFFALSE 13689
13628: GO 13630
13630: DISABLE
13631: LD_INT 0
13633: PPUSH
// begin p := 0 ;
13634: LD_ADDR_VAR 0 1
13638: PUSH
13639: LD_INT 0
13641: ST_TO_ADDR
// repeat game_speed := 1 ;
13642: LD_ADDR_OWVAR 65
13646: PUSH
13647: LD_INT 1
13649: ST_TO_ADDR
// wait ( 0 0$1 ) ;
13650: LD_INT 35
13652: PPUSH
13653: CALL_OW 67
// p := p + 1 ;
13657: LD_ADDR_VAR 0 1
13661: PUSH
13662: LD_VAR 0 1
13666: PUSH
13667: LD_INT 1
13669: PLUS
13670: ST_TO_ADDR
// until p >= 60 ;
13671: LD_VAR 0 1
13675: PUSH
13676: LD_INT 60
13678: GREATEREQUAL
13679: IFFALSE 13642
// game_speed := 4 ;
13681: LD_ADDR_OWVAR 65
13685: PUSH
13686: LD_INT 4
13688: ST_TO_ADDR
// end ;
13689: PPOPN 1
13691: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
13692: LD_EXP 26
13696: PUSH
13697: LD_EXP 53
13701: AND
13702: IFFALSE 13848
13704: GO 13706
13706: DISABLE
13707: LD_INT 0
13709: PPUSH
13710: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
13711: LD_ADDR_VAR 0 1
13715: PUSH
13716: LD_INT 22
13718: PUSH
13719: LD_OWVAR 2
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PUSH
13728: LD_INT 2
13730: PUSH
13731: LD_INT 30
13733: PUSH
13734: LD_INT 0
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PUSH
13741: LD_INT 30
13743: PUSH
13744: LD_INT 1
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: EMPTY
13752: LIST
13753: LIST
13754: LIST
13755: PUSH
13756: EMPTY
13757: LIST
13758: LIST
13759: PPUSH
13760: CALL_OW 69
13764: ST_TO_ADDR
// if not depot then
13765: LD_VAR 0 1
13769: NOT
13770: IFFALSE 13774
// exit ;
13772: GO 13848
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
13774: LD_ADDR_VAR 0 2
13778: PUSH
13779: LD_VAR 0 1
13783: PUSH
13784: LD_INT 1
13786: PPUSH
13787: LD_VAR 0 1
13791: PPUSH
13792: CALL_OW 12
13796: ARRAY
13797: PPUSH
13798: CALL_OW 274
13802: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
13803: LD_VAR 0 2
13807: PPUSH
13808: LD_INT 1
13810: PPUSH
13811: LD_INT 0
13813: PPUSH
13814: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
13818: LD_VAR 0 2
13822: PPUSH
13823: LD_INT 2
13825: PPUSH
13826: LD_INT 0
13828: PPUSH
13829: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
13833: LD_VAR 0 2
13837: PPUSH
13838: LD_INT 3
13840: PPUSH
13841: LD_INT 0
13843: PPUSH
13844: CALL_OW 277
// end ;
13848: PPOPN 2
13850: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
13851: LD_EXP 26
13855: PUSH
13856: LD_EXP 54
13860: AND
13861: IFFALSE 13958
13863: GO 13865
13865: DISABLE
13866: LD_INT 0
13868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13869: LD_ADDR_VAR 0 1
13873: PUSH
13874: LD_INT 22
13876: PUSH
13877: LD_OWVAR 2
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PUSH
13886: LD_INT 21
13888: PUSH
13889: LD_INT 1
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_INT 3
13898: PUSH
13899: LD_INT 23
13901: PUSH
13902: LD_INT 0
13904: PUSH
13905: EMPTY
13906: LIST
13907: LIST
13908: PUSH
13909: EMPTY
13910: LIST
13911: LIST
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: LIST
13917: PPUSH
13918: CALL_OW 69
13922: ST_TO_ADDR
// if not tmp then
13923: LD_VAR 0 1
13927: NOT
13928: IFFALSE 13932
// exit ;
13930: GO 13958
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
13932: LD_VAR 0 1
13936: PUSH
13937: LD_INT 1
13939: PPUSH
13940: LD_VAR 0 1
13944: PPUSH
13945: CALL_OW 12
13949: ARRAY
13950: PPUSH
13951: LD_INT 200
13953: PPUSH
13954: CALL_OW 234
// end ;
13958: PPOPN 1
13960: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
13961: LD_EXP 26
13965: PUSH
13966: LD_EXP 55
13970: AND
13971: IFFALSE 14050
13973: GO 13975
13975: DISABLE
13976: LD_INT 0
13978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
13979: LD_ADDR_VAR 0 1
13983: PUSH
13984: LD_INT 22
13986: PUSH
13987: LD_OWVAR 2
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: LD_INT 21
13998: PUSH
13999: LD_INT 2
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PPUSH
14010: CALL_OW 69
14014: ST_TO_ADDR
// if not tmp then
14015: LD_VAR 0 1
14019: NOT
14020: IFFALSE 14024
// exit ;
14022: GO 14050
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14024: LD_VAR 0 1
14028: PUSH
14029: LD_INT 1
14031: PPUSH
14032: LD_VAR 0 1
14036: PPUSH
14037: CALL_OW 12
14041: ARRAY
14042: PPUSH
14043: LD_INT 60
14045: PPUSH
14046: CALL_OW 234
// end ;
14050: PPOPN 1
14052: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14053: LD_EXP 26
14057: PUSH
14058: LD_EXP 56
14062: AND
14063: IFFALSE 14162
14065: GO 14067
14067: DISABLE
14068: LD_INT 0
14070: PPUSH
14071: PPUSH
// begin enable ;
14072: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14073: LD_ADDR_VAR 0 1
14077: PUSH
14078: LD_INT 22
14080: PUSH
14081: LD_OWVAR 2
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 61
14092: PUSH
14093: EMPTY
14094: LIST
14095: PUSH
14096: LD_INT 33
14098: PUSH
14099: LD_INT 2
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: PPUSH
14111: CALL_OW 69
14115: ST_TO_ADDR
// if not tmp then
14116: LD_VAR 0 1
14120: NOT
14121: IFFALSE 14125
// exit ;
14123: GO 14162
// for i in tmp do
14125: LD_ADDR_VAR 0 2
14129: PUSH
14130: LD_VAR 0 1
14134: PUSH
14135: FOR_IN
14136: IFFALSE 14160
// if IsControledBy ( i ) then
14138: LD_VAR 0 2
14142: PPUSH
14143: CALL_OW 312
14147: IFFALSE 14158
// ComUnlink ( i ) ;
14149: LD_VAR 0 2
14153: PPUSH
14154: CALL_OW 136
14158: GO 14135
14160: POP
14161: POP
// end ;
14162: PPOPN 2
14164: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
14165: LD_EXP 26
14169: PUSH
14170: LD_EXP 57
14174: AND
14175: IFFALSE 14315
14177: GO 14179
14179: DISABLE
14180: LD_INT 0
14182: PPUSH
14183: PPUSH
// begin ToLua ( displayPowell(); ) ;
14184: LD_STRING displayPowell();
14186: PPUSH
14187: CALL_OW 559
// uc_side := 0 ;
14191: LD_ADDR_OWVAR 20
14195: PUSH
14196: LD_INT 0
14198: ST_TO_ADDR
// uc_nation := 2 ;
14199: LD_ADDR_OWVAR 21
14203: PUSH
14204: LD_INT 2
14206: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
14207: LD_ADDR_OWVAR 37
14211: PUSH
14212: LD_INT 14
14214: ST_TO_ADDR
// vc_engine := engine_siberite ;
14215: LD_ADDR_OWVAR 39
14219: PUSH
14220: LD_INT 3
14222: ST_TO_ADDR
// vc_control := control_apeman ;
14223: LD_ADDR_OWVAR 38
14227: PUSH
14228: LD_INT 5
14230: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
14231: LD_ADDR_OWVAR 40
14235: PUSH
14236: LD_INT 29
14238: ST_TO_ADDR
// un := CreateVehicle ;
14239: LD_ADDR_VAR 0 2
14243: PUSH
14244: CALL_OW 45
14248: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
14249: LD_VAR 0 2
14253: PPUSH
14254: LD_INT 1
14256: PPUSH
14257: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
14261: LD_INT 35
14263: PPUSH
14264: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
14268: LD_VAR 0 2
14272: PPUSH
14273: LD_INT 22
14275: PUSH
14276: LD_OWVAR 2
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: PPUSH
14285: CALL_OW 69
14289: PPUSH
14290: LD_VAR 0 2
14294: PPUSH
14295: CALL_OW 74
14299: PPUSH
14300: CALL_OW 115
// until IsDead ( un ) ;
14304: LD_VAR 0 2
14308: PPUSH
14309: CALL_OW 301
14313: IFFALSE 14261
// end ;
14315: PPOPN 2
14317: END
// every 0 0$1 trigger StreamModeActive and sStu do
14318: LD_EXP 26
14322: PUSH
14323: LD_EXP 65
14327: AND
14328: IFFALSE 14344
14330: GO 14332
14332: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14333: LD_STRING displayStucuk();
14335: PPUSH
14336: CALL_OW 559
// ResetFog ;
14340: CALL_OW 335
// end ;
14344: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14345: LD_EXP 26
14349: PUSH
14350: LD_EXP 58
14354: AND
14355: IFFALSE 14496
14357: GO 14359
14359: DISABLE
14360: LD_INT 0
14362: PPUSH
14363: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14364: LD_ADDR_VAR 0 2
14368: PUSH
14369: LD_INT 22
14371: PUSH
14372: LD_OWVAR 2
14376: PUSH
14377: EMPTY
14378: LIST
14379: LIST
14380: PUSH
14381: LD_INT 21
14383: PUSH
14384: LD_INT 1
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PPUSH
14395: CALL_OW 69
14399: ST_TO_ADDR
// if not tmp then
14400: LD_VAR 0 2
14404: NOT
14405: IFFALSE 14409
// exit ;
14407: GO 14496
// un := tmp [ rand ( 1 , tmp ) ] ;
14409: LD_ADDR_VAR 0 1
14413: PUSH
14414: LD_VAR 0 2
14418: PUSH
14419: LD_INT 1
14421: PPUSH
14422: LD_VAR 0 2
14426: PPUSH
14427: CALL_OW 12
14431: ARRAY
14432: ST_TO_ADDR
// SetSide ( un , 0 ) ;
14433: LD_VAR 0 1
14437: PPUSH
14438: LD_INT 0
14440: PPUSH
14441: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14445: LD_VAR 0 1
14449: PPUSH
14450: LD_OWVAR 3
14454: PUSH
14455: LD_VAR 0 1
14459: DIFF
14460: PPUSH
14461: LD_VAR 0 1
14465: PPUSH
14466: CALL_OW 74
14470: PPUSH
14471: CALL_OW 115
// wait ( 0 0$20 ) ;
14475: LD_INT 700
14477: PPUSH
14478: CALL_OW 67
// SetSide ( un , your_side ) ;
14482: LD_VAR 0 1
14486: PPUSH
14487: LD_OWVAR 2
14491: PPUSH
14492: CALL_OW 235
// end ;
14496: PPOPN 2
14498: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
14499: LD_EXP 26
14503: PUSH
14504: LD_EXP 59
14508: AND
14509: IFFALSE 14615
14511: GO 14513
14513: DISABLE
14514: LD_INT 0
14516: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14517: LD_ADDR_VAR 0 1
14521: PUSH
14522: LD_INT 22
14524: PUSH
14525: LD_OWVAR 2
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PUSH
14534: LD_INT 2
14536: PUSH
14537: LD_INT 30
14539: PUSH
14540: LD_INT 0
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PUSH
14547: LD_INT 30
14549: PUSH
14550: LD_INT 1
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PUSH
14557: EMPTY
14558: LIST
14559: LIST
14560: LIST
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: PPUSH
14566: CALL_OW 69
14570: ST_TO_ADDR
// if not depot then
14571: LD_VAR 0 1
14575: NOT
14576: IFFALSE 14580
// exit ;
14578: GO 14615
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
14580: LD_VAR 0 1
14584: PUSH
14585: LD_INT 1
14587: ARRAY
14588: PPUSH
14589: CALL_OW 250
14593: PPUSH
14594: LD_VAR 0 1
14598: PUSH
14599: LD_INT 1
14601: ARRAY
14602: PPUSH
14603: CALL_OW 251
14607: PPUSH
14608: LD_INT 70
14610: PPUSH
14611: CALL_OW 495
// end ;
14615: PPOPN 1
14617: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
14618: LD_EXP 26
14622: PUSH
14623: LD_EXP 60
14627: AND
14628: IFFALSE 14839
14630: GO 14632
14632: DISABLE
14633: LD_INT 0
14635: PPUSH
14636: PPUSH
14637: PPUSH
14638: PPUSH
14639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14640: LD_ADDR_VAR 0 5
14644: PUSH
14645: LD_INT 22
14647: PUSH
14648: LD_OWVAR 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 21
14659: PUSH
14660: LD_INT 1
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: EMPTY
14668: LIST
14669: LIST
14670: PPUSH
14671: CALL_OW 69
14675: ST_TO_ADDR
// if not tmp then
14676: LD_VAR 0 5
14680: NOT
14681: IFFALSE 14685
// exit ;
14683: GO 14839
// for i in tmp do
14685: LD_ADDR_VAR 0 1
14689: PUSH
14690: LD_VAR 0 5
14694: PUSH
14695: FOR_IN
14696: IFFALSE 14837
// begin d := rand ( 0 , 5 ) ;
14698: LD_ADDR_VAR 0 4
14702: PUSH
14703: LD_INT 0
14705: PPUSH
14706: LD_INT 5
14708: PPUSH
14709: CALL_OW 12
14713: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
14714: LD_ADDR_VAR 0 2
14718: PUSH
14719: LD_VAR 0 1
14723: PPUSH
14724: CALL_OW 250
14728: PPUSH
14729: LD_VAR 0 4
14733: PPUSH
14734: LD_INT 3
14736: PPUSH
14737: LD_INT 12
14739: PPUSH
14740: CALL_OW 12
14744: PPUSH
14745: CALL_OW 272
14749: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
14750: LD_ADDR_VAR 0 3
14754: PUSH
14755: LD_VAR 0 1
14759: PPUSH
14760: CALL_OW 251
14764: PPUSH
14765: LD_VAR 0 4
14769: PPUSH
14770: LD_INT 3
14772: PPUSH
14773: LD_INT 12
14775: PPUSH
14776: CALL_OW 12
14780: PPUSH
14781: CALL_OW 273
14785: ST_TO_ADDR
// if ValidHex ( x , y ) then
14786: LD_VAR 0 2
14790: PPUSH
14791: LD_VAR 0 3
14795: PPUSH
14796: CALL_OW 488
14800: IFFALSE 14835
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
14802: LD_VAR 0 1
14806: PPUSH
14807: LD_VAR 0 2
14811: PPUSH
14812: LD_VAR 0 3
14816: PPUSH
14817: LD_INT 3
14819: PPUSH
14820: LD_INT 6
14822: PPUSH
14823: CALL_OW 12
14827: PPUSH
14828: LD_INT 1
14830: PPUSH
14831: CALL_OW 483
// end ;
14835: GO 14695
14837: POP
14838: POP
// end ;
14839: PPOPN 5
14841: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
14842: LD_EXP 26
14846: PUSH
14847: LD_EXP 61
14851: AND
14852: IFFALSE 14946
14854: GO 14856
14856: DISABLE
14857: LD_INT 0
14859: PPUSH
14860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
14861: LD_ADDR_VAR 0 2
14865: PUSH
14866: LD_INT 22
14868: PUSH
14869: LD_OWVAR 2
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 32
14880: PUSH
14881: LD_INT 1
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: LD_INT 21
14890: PUSH
14891: LD_INT 2
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: LIST
14902: PPUSH
14903: CALL_OW 69
14907: ST_TO_ADDR
// if not tmp then
14908: LD_VAR 0 2
14912: NOT
14913: IFFALSE 14917
// exit ;
14915: GO 14946
// for i in tmp do
14917: LD_ADDR_VAR 0 1
14921: PUSH
14922: LD_VAR 0 2
14926: PUSH
14927: FOR_IN
14928: IFFALSE 14944
// SetFuel ( i , 0 ) ;
14930: LD_VAR 0 1
14934: PPUSH
14935: LD_INT 0
14937: PPUSH
14938: CALL_OW 240
14942: GO 14927
14944: POP
14945: POP
// end ;
14946: PPOPN 2
14948: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
14949: LD_EXP 26
14953: PUSH
14954: LD_EXP 62
14958: AND
14959: IFFALSE 15025
14961: GO 14963
14963: DISABLE
14964: LD_INT 0
14966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
14967: LD_ADDR_VAR 0 1
14971: PUSH
14972: LD_INT 22
14974: PUSH
14975: LD_OWVAR 2
14979: PUSH
14980: EMPTY
14981: LIST
14982: LIST
14983: PUSH
14984: LD_INT 30
14986: PUSH
14987: LD_INT 29
14989: PUSH
14990: EMPTY
14991: LIST
14992: LIST
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PPUSH
14998: CALL_OW 69
15002: ST_TO_ADDR
// if not tmp then
15003: LD_VAR 0 1
15007: NOT
15008: IFFALSE 15012
// exit ;
15010: GO 15025
// DestroyUnit ( tmp [ 1 ] ) ;
15012: LD_VAR 0 1
15016: PUSH
15017: LD_INT 1
15019: ARRAY
15020: PPUSH
15021: CALL_OW 65
// end ;
15025: PPOPN 1
15027: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15028: LD_EXP 26
15032: PUSH
15033: LD_EXP 64
15037: AND
15038: IFFALSE 15167
15040: GO 15042
15042: DISABLE
15043: LD_INT 0
15045: PPUSH
// begin uc_side := 0 ;
15046: LD_ADDR_OWVAR 20
15050: PUSH
15051: LD_INT 0
15053: ST_TO_ADDR
// uc_nation := nation_arabian ;
15054: LD_ADDR_OWVAR 21
15058: PUSH
15059: LD_INT 2
15061: ST_TO_ADDR
// hc_gallery :=  ;
15062: LD_ADDR_OWVAR 33
15066: PUSH
15067: LD_STRING 
15069: ST_TO_ADDR
// hc_name :=  ;
15070: LD_ADDR_OWVAR 26
15074: PUSH
15075: LD_STRING 
15077: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
15078: LD_INT 1
15080: PPUSH
15081: LD_INT 11
15083: PPUSH
15084: LD_INT 10
15086: PPUSH
15087: CALL_OW 380
// un := CreateHuman ;
15091: LD_ADDR_VAR 0 1
15095: PUSH
15096: CALL_OW 44
15100: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15101: LD_VAR 0 1
15105: PPUSH
15106: LD_INT 1
15108: PPUSH
15109: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15113: LD_INT 35
15115: PPUSH
15116: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15120: LD_VAR 0 1
15124: PPUSH
15125: LD_INT 22
15127: PUSH
15128: LD_OWVAR 2
15132: PUSH
15133: EMPTY
15134: LIST
15135: LIST
15136: PPUSH
15137: CALL_OW 69
15141: PPUSH
15142: LD_VAR 0 1
15146: PPUSH
15147: CALL_OW 74
15151: PPUSH
15152: CALL_OW 115
// until IsDead ( un ) ;
15156: LD_VAR 0 1
15160: PPUSH
15161: CALL_OW 301
15165: IFFALSE 15113
// end ;
15167: PPOPN 1
15169: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
15170: LD_EXP 26
15174: PUSH
15175: LD_EXP 66
15179: AND
15180: IFFALSE 15192
15182: GO 15184
15184: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
15185: LD_STRING earthquake(getX(game), 0, 32)
15187: PPUSH
15188: CALL_OW 559
15192: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
15193: LD_EXP 26
15197: PUSH
15198: LD_EXP 67
15202: AND
15203: IFFALSE 15294
15205: GO 15207
15207: DISABLE
15208: LD_INT 0
15210: PPUSH
// begin enable ;
15211: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
15212: LD_ADDR_VAR 0 1
15216: PUSH
15217: LD_INT 22
15219: PUSH
15220: LD_OWVAR 2
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PUSH
15229: LD_INT 21
15231: PUSH
15232: LD_INT 2
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: PUSH
15239: LD_INT 33
15241: PUSH
15242: LD_INT 3
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: PUSH
15249: EMPTY
15250: LIST
15251: LIST
15252: LIST
15253: PPUSH
15254: CALL_OW 69
15258: ST_TO_ADDR
// if not tmp then
15259: LD_VAR 0 1
15263: NOT
15264: IFFALSE 15268
// exit ;
15266: GO 15294
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
15268: LD_VAR 0 1
15272: PUSH
15273: LD_INT 1
15275: PPUSH
15276: LD_VAR 0 1
15280: PPUSH
15281: CALL_OW 12
15285: ARRAY
15286: PPUSH
15287: LD_INT 1
15289: PPUSH
15290: CALL_OW 234
// end ;
15294: PPOPN 1
15296: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
15297: LD_EXP 26
15301: PUSH
15302: LD_EXP 68
15306: AND
15307: IFFALSE 15448
15309: GO 15311
15311: DISABLE
15312: LD_INT 0
15314: PPUSH
15315: PPUSH
15316: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15317: LD_ADDR_VAR 0 3
15321: PUSH
15322: LD_INT 22
15324: PUSH
15325: LD_OWVAR 2
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: PUSH
15334: LD_INT 25
15336: PUSH
15337: LD_INT 1
15339: PUSH
15340: EMPTY
15341: LIST
15342: LIST
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PPUSH
15348: CALL_OW 69
15352: ST_TO_ADDR
// if not tmp then
15353: LD_VAR 0 3
15357: NOT
15358: IFFALSE 15362
// exit ;
15360: GO 15448
// un := tmp [ rand ( 1 , tmp ) ] ;
15362: LD_ADDR_VAR 0 2
15366: PUSH
15367: LD_VAR 0 3
15371: PUSH
15372: LD_INT 1
15374: PPUSH
15375: LD_VAR 0 3
15379: PPUSH
15380: CALL_OW 12
15384: ARRAY
15385: ST_TO_ADDR
// if Crawls ( un ) then
15386: LD_VAR 0 2
15390: PPUSH
15391: CALL_OW 318
15395: IFFALSE 15406
// ComWalk ( un ) ;
15397: LD_VAR 0 2
15401: PPUSH
15402: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
15406: LD_VAR 0 2
15410: PPUSH
15411: LD_INT 9
15413: PPUSH
15414: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
15418: LD_INT 28
15420: PPUSH
15421: LD_OWVAR 2
15425: PPUSH
15426: LD_INT 2
15428: PPUSH
15429: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
15433: LD_INT 29
15435: PPUSH
15436: LD_OWVAR 2
15440: PPUSH
15441: LD_INT 2
15443: PPUSH
15444: CALL_OW 322
// end ;
15448: PPOPN 3
15450: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
15451: LD_EXP 26
15455: PUSH
15456: LD_EXP 69
15460: AND
15461: IFFALSE 15572
15463: GO 15465
15465: DISABLE
15466: LD_INT 0
15468: PPUSH
15469: PPUSH
15470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 22
15478: PUSH
15479: LD_OWVAR 2
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: LD_INT 25
15490: PUSH
15491: LD_INT 1
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PPUSH
15502: CALL_OW 69
15506: ST_TO_ADDR
// if not tmp then
15507: LD_VAR 0 3
15511: NOT
15512: IFFALSE 15516
// exit ;
15514: GO 15572
// un := tmp [ rand ( 1 , tmp ) ] ;
15516: LD_ADDR_VAR 0 2
15520: PUSH
15521: LD_VAR 0 3
15525: PUSH
15526: LD_INT 1
15528: PPUSH
15529: LD_VAR 0 3
15533: PPUSH
15534: CALL_OW 12
15538: ARRAY
15539: ST_TO_ADDR
// if Crawls ( un ) then
15540: LD_VAR 0 2
15544: PPUSH
15545: CALL_OW 318
15549: IFFALSE 15560
// ComWalk ( un ) ;
15551: LD_VAR 0 2
15555: PPUSH
15556: CALL_OW 138
// SetClass ( un , class_mortar ) ;
15560: LD_VAR 0 2
15564: PPUSH
15565: LD_INT 8
15567: PPUSH
15568: CALL_OW 336
// end ;
15572: PPOPN 3
15574: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
15575: LD_EXP 26
15579: PUSH
15580: LD_EXP 70
15584: AND
15585: IFFALSE 15729
15587: GO 15589
15589: DISABLE
15590: LD_INT 0
15592: PPUSH
15593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
15594: LD_ADDR_VAR 0 2
15598: PUSH
15599: LD_INT 22
15601: PUSH
15602: LD_OWVAR 2
15606: PUSH
15607: EMPTY
15608: LIST
15609: LIST
15610: PUSH
15611: LD_INT 21
15613: PUSH
15614: LD_INT 2
15616: PUSH
15617: EMPTY
15618: LIST
15619: LIST
15620: PUSH
15621: LD_INT 2
15623: PUSH
15624: LD_INT 34
15626: PUSH
15627: LD_INT 12
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: PUSH
15634: LD_INT 34
15636: PUSH
15637: LD_INT 51
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: PUSH
15644: LD_INT 34
15646: PUSH
15647: LD_INT 32
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: LIST
15658: LIST
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL_OW 69
15669: ST_TO_ADDR
// if not tmp then
15670: LD_VAR 0 2
15674: NOT
15675: IFFALSE 15679
// exit ;
15677: GO 15729
// for i in tmp do
15679: LD_ADDR_VAR 0 1
15683: PUSH
15684: LD_VAR 0 2
15688: PUSH
15689: FOR_IN
15690: IFFALSE 15727
// if GetCargo ( i , mat_artifact ) = 0 then
15692: LD_VAR 0 1
15696: PPUSH
15697: LD_INT 4
15699: PPUSH
15700: CALL_OW 289
15704: PUSH
15705: LD_INT 0
15707: EQUAL
15708: IFFALSE 15725
// SetCargo ( i , mat_siberit , 100 ) ;
15710: LD_VAR 0 1
15714: PPUSH
15715: LD_INT 3
15717: PPUSH
15718: LD_INT 100
15720: PPUSH
15721: CALL_OW 290
15725: GO 15689
15727: POP
15728: POP
// end ;
15729: PPOPN 2
15731: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
15732: LD_EXP 26
15736: PUSH
15737: LD_EXP 71
15741: AND
15742: IFFALSE 15895
15744: GO 15746
15746: DISABLE
15747: LD_INT 0
15749: PPUSH
15750: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
15751: LD_ADDR_VAR 0 2
15755: PUSH
15756: LD_INT 22
15758: PUSH
15759: LD_OWVAR 2
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: PPUSH
15768: CALL_OW 69
15772: ST_TO_ADDR
// if not tmp then
15773: LD_VAR 0 2
15777: NOT
15778: IFFALSE 15782
// exit ;
15780: GO 15895
// for i := 1 to 2 do
15782: LD_ADDR_VAR 0 1
15786: PUSH
15787: DOUBLE
15788: LD_INT 1
15790: DEC
15791: ST_TO_ADDR
15792: LD_INT 2
15794: PUSH
15795: FOR_TO
15796: IFFALSE 15893
// begin uc_side := your_side ;
15798: LD_ADDR_OWVAR 20
15802: PUSH
15803: LD_OWVAR 2
15807: ST_TO_ADDR
// uc_nation := nation_american ;
15808: LD_ADDR_OWVAR 21
15812: PUSH
15813: LD_INT 1
15815: ST_TO_ADDR
// vc_chassis := us_morphling ;
15816: LD_ADDR_OWVAR 37
15820: PUSH
15821: LD_INT 5
15823: ST_TO_ADDR
// vc_engine := engine_siberite ;
15824: LD_ADDR_OWVAR 39
15828: PUSH
15829: LD_INT 3
15831: ST_TO_ADDR
// vc_control := control_computer ;
15832: LD_ADDR_OWVAR 38
15836: PUSH
15837: LD_INT 3
15839: ST_TO_ADDR
// vc_weapon := us_double_laser ;
15840: LD_ADDR_OWVAR 40
15844: PUSH
15845: LD_INT 10
15847: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
15848: CALL_OW 45
15852: PPUSH
15853: LD_VAR 0 2
15857: PUSH
15858: LD_INT 1
15860: ARRAY
15861: PPUSH
15862: CALL_OW 250
15866: PPUSH
15867: LD_VAR 0 2
15871: PUSH
15872: LD_INT 1
15874: ARRAY
15875: PPUSH
15876: CALL_OW 251
15880: PPUSH
15881: LD_INT 12
15883: PPUSH
15884: LD_INT 1
15886: PPUSH
15887: CALL_OW 50
// end ;
15891: GO 15795
15893: POP
15894: POP
// end ;
15895: PPOPN 2
15897: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
15898: LD_EXP 26
15902: PUSH
15903: LD_EXP 72
15907: AND
15908: IFFALSE 16130
15910: GO 15912
15912: DISABLE
15913: LD_INT 0
15915: PPUSH
15916: PPUSH
15917: PPUSH
15918: PPUSH
15919: PPUSH
15920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15921: LD_ADDR_VAR 0 6
15925: PUSH
15926: LD_INT 22
15928: PUSH
15929: LD_OWVAR 2
15933: PUSH
15934: EMPTY
15935: LIST
15936: LIST
15937: PUSH
15938: LD_INT 21
15940: PUSH
15941: LD_INT 1
15943: PUSH
15944: EMPTY
15945: LIST
15946: LIST
15947: PUSH
15948: LD_INT 3
15950: PUSH
15951: LD_INT 23
15953: PUSH
15954: LD_INT 0
15956: PUSH
15957: EMPTY
15958: LIST
15959: LIST
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: PUSH
15965: EMPTY
15966: LIST
15967: LIST
15968: LIST
15969: PPUSH
15970: CALL_OW 69
15974: ST_TO_ADDR
// if not tmp then
15975: LD_VAR 0 6
15979: NOT
15980: IFFALSE 15984
// exit ;
15982: GO 16130
// s1 := rand ( 1 , 4 ) ;
15984: LD_ADDR_VAR 0 2
15988: PUSH
15989: LD_INT 1
15991: PPUSH
15992: LD_INT 4
15994: PPUSH
15995: CALL_OW 12
15999: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
16000: LD_ADDR_VAR 0 4
16004: PUSH
16005: LD_VAR 0 6
16009: PUSH
16010: LD_INT 1
16012: ARRAY
16013: PPUSH
16014: LD_VAR 0 2
16018: PPUSH
16019: CALL_OW 259
16023: ST_TO_ADDR
// if s1 = 1 then
16024: LD_VAR 0 2
16028: PUSH
16029: LD_INT 1
16031: EQUAL
16032: IFFALSE 16052
// s2 := rand ( 2 , 4 ) else
16034: LD_ADDR_VAR 0 3
16038: PUSH
16039: LD_INT 2
16041: PPUSH
16042: LD_INT 4
16044: PPUSH
16045: CALL_OW 12
16049: ST_TO_ADDR
16050: GO 16060
// s2 := 1 ;
16052: LD_ADDR_VAR 0 3
16056: PUSH
16057: LD_INT 1
16059: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
16060: LD_ADDR_VAR 0 5
16064: PUSH
16065: LD_VAR 0 6
16069: PUSH
16070: LD_INT 1
16072: ARRAY
16073: PPUSH
16074: LD_VAR 0 3
16078: PPUSH
16079: CALL_OW 259
16083: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
16084: LD_VAR 0 6
16088: PUSH
16089: LD_INT 1
16091: ARRAY
16092: PPUSH
16093: LD_VAR 0 2
16097: PPUSH
16098: LD_VAR 0 5
16102: PPUSH
16103: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
16107: LD_VAR 0 6
16111: PUSH
16112: LD_INT 1
16114: ARRAY
16115: PPUSH
16116: LD_VAR 0 3
16120: PPUSH
16121: LD_VAR 0 4
16125: PPUSH
16126: CALL_OW 237
// end ;
16130: PPOPN 6
16132: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
16133: LD_EXP 26
16137: PUSH
16138: LD_EXP 73
16142: AND
16143: IFFALSE 16222
16145: GO 16147
16147: DISABLE
16148: LD_INT 0
16150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
16151: LD_ADDR_VAR 0 1
16155: PUSH
16156: LD_INT 22
16158: PUSH
16159: LD_OWVAR 2
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: LD_INT 30
16170: PUSH
16171: LD_INT 3
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: PPUSH
16182: CALL_OW 69
16186: ST_TO_ADDR
// if not tmp then
16187: LD_VAR 0 1
16191: NOT
16192: IFFALSE 16196
// exit ;
16194: GO 16222
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16196: LD_VAR 0 1
16200: PUSH
16201: LD_INT 1
16203: PPUSH
16204: LD_VAR 0 1
16208: PPUSH
16209: CALL_OW 12
16213: ARRAY
16214: PPUSH
16215: LD_INT 1
16217: PPUSH
16218: CALL_OW 234
// end ;
16222: PPOPN 1
16224: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
16225: LD_EXP 26
16229: PUSH
16230: LD_EXP 74
16234: AND
16235: IFFALSE 16347
16237: GO 16239
16239: DISABLE
16240: LD_INT 0
16242: PPUSH
16243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
16244: LD_ADDR_VAR 0 2
16248: PUSH
16249: LD_INT 22
16251: PUSH
16252: LD_OWVAR 2
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 2
16263: PUSH
16264: LD_INT 30
16266: PUSH
16267: LD_INT 27
16269: PUSH
16270: EMPTY
16271: LIST
16272: LIST
16273: PUSH
16274: LD_INT 30
16276: PUSH
16277: LD_INT 26
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PUSH
16284: LD_INT 30
16286: PUSH
16287: LD_INT 28
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: LIST
16298: LIST
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PPUSH
16304: CALL_OW 69
16308: ST_TO_ADDR
// if not tmp then
16309: LD_VAR 0 2
16313: NOT
16314: IFFALSE 16318
// exit ;
16316: GO 16347
// for i in tmp do
16318: LD_ADDR_VAR 0 1
16322: PUSH
16323: LD_VAR 0 2
16327: PUSH
16328: FOR_IN
16329: IFFALSE 16345
// SetLives ( i , 1 ) ;
16331: LD_VAR 0 1
16335: PPUSH
16336: LD_INT 1
16338: PPUSH
16339: CALL_OW 234
16343: GO 16328
16345: POP
16346: POP
// end ;
16347: PPOPN 2
16349: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
16350: LD_EXP 26
16354: PUSH
16355: LD_EXP 75
16359: AND
16360: IFFALSE 16634
16362: GO 16364
16364: DISABLE
16365: LD_INT 0
16367: PPUSH
16368: PPUSH
16369: PPUSH
// begin i := rand ( 1 , 7 ) ;
16370: LD_ADDR_VAR 0 1
16374: PUSH
16375: LD_INT 1
16377: PPUSH
16378: LD_INT 7
16380: PPUSH
16381: CALL_OW 12
16385: ST_TO_ADDR
// case i of 1 :
16386: LD_VAR 0 1
16390: PUSH
16391: LD_INT 1
16393: DOUBLE
16394: EQUAL
16395: IFTRUE 16399
16397: GO 16409
16399: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
16400: LD_STRING earthquake(getX(game), 0, 32)
16402: PPUSH
16403: CALL_OW 559
16407: GO 16634
16409: LD_INT 2
16411: DOUBLE
16412: EQUAL
16413: IFTRUE 16417
16415: GO 16431
16417: POP
// begin ToLua ( displayStucuk(); ) ;
16418: LD_STRING displayStucuk();
16420: PPUSH
16421: CALL_OW 559
// ResetFog ;
16425: CALL_OW 335
// end ; 3 :
16429: GO 16634
16431: LD_INT 3
16433: DOUBLE
16434: EQUAL
16435: IFTRUE 16439
16437: GO 16543
16439: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16440: LD_ADDR_VAR 0 2
16444: PUSH
16445: LD_INT 22
16447: PUSH
16448: LD_OWVAR 2
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: PUSH
16457: LD_INT 25
16459: PUSH
16460: LD_INT 1
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PPUSH
16471: CALL_OW 69
16475: ST_TO_ADDR
// if not tmp then
16476: LD_VAR 0 2
16480: NOT
16481: IFFALSE 16485
// exit ;
16483: GO 16634
// un := tmp [ rand ( 1 , tmp ) ] ;
16485: LD_ADDR_VAR 0 3
16489: PUSH
16490: LD_VAR 0 2
16494: PUSH
16495: LD_INT 1
16497: PPUSH
16498: LD_VAR 0 2
16502: PPUSH
16503: CALL_OW 12
16507: ARRAY
16508: ST_TO_ADDR
// if Crawls ( un ) then
16509: LD_VAR 0 3
16513: PPUSH
16514: CALL_OW 318
16518: IFFALSE 16529
// ComWalk ( un ) ;
16520: LD_VAR 0 3
16524: PPUSH
16525: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16529: LD_VAR 0 3
16533: PPUSH
16534: LD_INT 8
16536: PPUSH
16537: CALL_OW 336
// end ; 4 :
16541: GO 16634
16543: LD_INT 4
16545: DOUBLE
16546: EQUAL
16547: IFTRUE 16551
16549: GO 16612
16551: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16552: LD_ADDR_VAR 0 2
16556: PUSH
16557: LD_INT 22
16559: PUSH
16560: LD_OWVAR 2
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PUSH
16569: LD_INT 30
16571: PUSH
16572: LD_INT 29
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: PPUSH
16583: CALL_OW 69
16587: ST_TO_ADDR
// if not tmp then
16588: LD_VAR 0 2
16592: NOT
16593: IFFALSE 16597
// exit ;
16595: GO 16634
// DestroyUnit ( tmp [ 1 ] ) ;
16597: LD_VAR 0 2
16601: PUSH
16602: LD_INT 1
16604: ARRAY
16605: PPUSH
16606: CALL_OW 65
// end ; 5 .. 7 :
16610: GO 16634
16612: LD_INT 5
16614: DOUBLE
16615: GREATEREQUAL
16616: IFFALSE 16624
16618: LD_INT 7
16620: DOUBLE
16621: LESSEQUAL
16622: IFTRUE 16626
16624: GO 16633
16626: POP
// StreamSibBomb ; end ;
16627: CALL 12914 0 0
16631: GO 16634
16633: POP
// end ;
16634: PPOPN 3
16636: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
16637: LD_EXP 26
16641: PUSH
16642: LD_EXP 76
16646: AND
16647: IFFALSE 16803
16649: GO 16651
16651: DISABLE
16652: LD_INT 0
16654: PPUSH
16655: PPUSH
16656: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
16657: LD_ADDR_VAR 0 2
16661: PUSH
16662: LD_INT 81
16664: PUSH
16665: LD_OWVAR 2
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 2
16676: PUSH
16677: LD_INT 21
16679: PUSH
16680: LD_INT 1
16682: PUSH
16683: EMPTY
16684: LIST
16685: LIST
16686: PUSH
16687: LD_INT 21
16689: PUSH
16690: LD_INT 2
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: PPUSH
16706: CALL_OW 69
16710: ST_TO_ADDR
// if not tmp then
16711: LD_VAR 0 2
16715: NOT
16716: IFFALSE 16720
// exit ;
16718: GO 16803
// p := 0 ;
16720: LD_ADDR_VAR 0 3
16724: PUSH
16725: LD_INT 0
16727: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
16728: LD_INT 35
16730: PPUSH
16731: CALL_OW 67
// p := p + 1 ;
16735: LD_ADDR_VAR 0 3
16739: PUSH
16740: LD_VAR 0 3
16744: PUSH
16745: LD_INT 1
16747: PLUS
16748: ST_TO_ADDR
// for i in tmp do
16749: LD_ADDR_VAR 0 1
16753: PUSH
16754: LD_VAR 0 2
16758: PUSH
16759: FOR_IN
16760: IFFALSE 16791
// if GetLives ( i ) < 1000 then
16762: LD_VAR 0 1
16766: PPUSH
16767: CALL_OW 256
16771: PUSH
16772: LD_INT 1000
16774: LESS
16775: IFFALSE 16789
// SetLives ( i , 1000 ) ;
16777: LD_VAR 0 1
16781: PPUSH
16782: LD_INT 1000
16784: PPUSH
16785: CALL_OW 234
16789: GO 16759
16791: POP
16792: POP
// until p > 20 ;
16793: LD_VAR 0 3
16797: PUSH
16798: LD_INT 20
16800: GREATER
16801: IFFALSE 16728
// end ;
16803: PPOPN 3
16805: END
// every 0 0$1 trigger StreamModeActive and sTime do
16806: LD_EXP 26
16810: PUSH
16811: LD_EXP 77
16815: AND
16816: IFFALSE 16851
16818: GO 16820
16820: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
16821: LD_INT 28
16823: PPUSH
16824: LD_OWVAR 2
16828: PPUSH
16829: LD_INT 2
16831: PPUSH
16832: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
16836: LD_INT 30
16838: PPUSH
16839: LD_OWVAR 2
16843: PPUSH
16844: LD_INT 2
16846: PPUSH
16847: CALL_OW 322
// end ;
16851: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
16852: LD_EXP 26
16856: PUSH
16857: LD_EXP 78
16861: AND
16862: IFFALSE 16983
16864: GO 16866
16866: DISABLE
16867: LD_INT 0
16869: PPUSH
16870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16871: LD_ADDR_VAR 0 2
16875: PUSH
16876: LD_INT 22
16878: PUSH
16879: LD_OWVAR 2
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: LD_INT 21
16890: PUSH
16891: LD_INT 1
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: PUSH
16898: LD_INT 3
16900: PUSH
16901: LD_INT 23
16903: PUSH
16904: LD_INT 0
16906: PUSH
16907: EMPTY
16908: LIST
16909: LIST
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: PPUSH
16920: CALL_OW 69
16924: ST_TO_ADDR
// if not tmp then
16925: LD_VAR 0 2
16929: NOT
16930: IFFALSE 16934
// exit ;
16932: GO 16983
// for i in tmp do
16934: LD_ADDR_VAR 0 1
16938: PUSH
16939: LD_VAR 0 2
16943: PUSH
16944: FOR_IN
16945: IFFALSE 16981
// begin if Crawls ( i ) then
16947: LD_VAR 0 1
16951: PPUSH
16952: CALL_OW 318
16956: IFFALSE 16967
// ComWalk ( i ) ;
16958: LD_VAR 0 1
16962: PPUSH
16963: CALL_OW 138
// SetClass ( i , 2 ) ;
16967: LD_VAR 0 1
16971: PPUSH
16972: LD_INT 2
16974: PPUSH
16975: CALL_OW 336
// end ;
16979: GO 16944
16981: POP
16982: POP
// end ;
16983: PPOPN 2
16985: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
16986: LD_EXP 26
16990: PUSH
16991: LD_EXP 79
16995: AND
16996: IFFALSE 17217
16998: GO 17000
17000: DISABLE
17001: LD_INT 0
17003: PPUSH
17004: PPUSH
17005: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
17006: LD_OWVAR 2
17010: PPUSH
17011: LD_INT 9
17013: PPUSH
17014: LD_INT 1
17016: PPUSH
17017: LD_INT 1
17019: PPUSH
17020: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
17024: LD_INT 9
17026: PPUSH
17027: LD_OWVAR 2
17031: PPUSH
17032: CALL_OW 343
// uc_side := 9 ;
17036: LD_ADDR_OWVAR 20
17040: PUSH
17041: LD_INT 9
17043: ST_TO_ADDR
// uc_nation := 2 ;
17044: LD_ADDR_OWVAR 21
17048: PUSH
17049: LD_INT 2
17051: ST_TO_ADDR
// hc_name := Dark Warrior ;
17052: LD_ADDR_OWVAR 26
17056: PUSH
17057: LD_STRING Dark Warrior
17059: ST_TO_ADDR
// hc_gallery :=  ;
17060: LD_ADDR_OWVAR 33
17064: PUSH
17065: LD_STRING 
17067: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
17068: LD_INT 1
17070: PPUSH
17071: LD_INT 1
17073: PPUSH
17074: LD_INT 10
17076: PPUSH
17077: CALL_OW 380
// un := CreateHuman ;
17081: LD_ADDR_VAR 0 3
17085: PUSH
17086: CALL_OW 44
17090: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17091: LD_VAR 0 3
17095: PPUSH
17096: LD_INT 1
17098: PPUSH
17099: CALL_OW 51
// p := 0 ;
17103: LD_ADDR_VAR 0 2
17107: PUSH
17108: LD_INT 0
17110: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17111: LD_INT 35
17113: PPUSH
17114: CALL_OW 67
// if GetLives ( un ) < 1000 then
17118: LD_VAR 0 3
17122: PPUSH
17123: CALL_OW 256
17127: PUSH
17128: LD_INT 1000
17130: LESS
17131: IFFALSE 17145
// SetLives ( un , 1000 ) ;
17133: LD_VAR 0 3
17137: PPUSH
17138: LD_INT 1000
17140: PPUSH
17141: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
17145: LD_VAR 0 3
17149: PPUSH
17150: LD_INT 81
17152: PUSH
17153: LD_OWVAR 2
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: PPUSH
17162: CALL_OW 69
17166: PPUSH
17167: LD_VAR 0 3
17171: PPUSH
17172: CALL_OW 74
17176: PPUSH
17177: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
17181: LD_VAR 0 2
17185: PUSH
17186: LD_INT 60
17188: GREATER
17189: PUSH
17190: LD_VAR 0 3
17194: PPUSH
17195: CALL_OW 301
17199: OR
17200: IFFALSE 17111
// if un then
17202: LD_VAR 0 3
17206: IFFALSE 17217
// RemoveUnit ( un ) ;
17208: LD_VAR 0 3
17212: PPUSH
17213: CALL_OW 64
// end ; end_of_file
17217: PPOPN 3
17219: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
17220: LD_INT 0
17222: PPUSH
17223: PPUSH
17224: PPUSH
17225: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
17226: LD_VAR 0 1
17230: PPUSH
17231: CALL_OW 264
17235: PUSH
17236: LD_EXP 84
17240: EQUAL
17241: IFFALSE 17313
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
17243: LD_INT 68
17245: PPUSH
17246: LD_VAR 0 1
17250: PPUSH
17251: CALL_OW 255
17255: PPUSH
17256: CALL_OW 321
17260: PUSH
17261: LD_INT 2
17263: EQUAL
17264: IFFALSE 17276
// eff := 70 else
17266: LD_ADDR_VAR 0 6
17270: PUSH
17271: LD_INT 70
17273: ST_TO_ADDR
17274: GO 17284
// eff := 30 ;
17276: LD_ADDR_VAR 0 6
17280: PUSH
17281: LD_INT 30
17283: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
17284: LD_VAR 0 1
17288: PPUSH
17289: CALL_OW 250
17293: PPUSH
17294: LD_VAR 0 1
17298: PPUSH
17299: CALL_OW 251
17303: PPUSH
17304: LD_VAR 0 6
17308: PPUSH
17309: CALL_OW 495
// end ; end ;
17313: LD_VAR 0 4
17317: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
17318: LD_INT 0
17320: PPUSH
17321: PPUSH
17322: PPUSH
17323: PPUSH
17324: PPUSH
17325: PPUSH
// if cmd = 124 then
17326: LD_VAR 0 1
17330: PUSH
17331: LD_INT 124
17333: EQUAL
17334: IFFALSE 17540
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
17336: LD_ADDR_VAR 0 5
17340: PUSH
17341: LD_INT 2
17343: PUSH
17344: LD_INT 34
17346: PUSH
17347: LD_INT 53
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: PUSH
17354: LD_INT 34
17356: PUSH
17357: LD_INT 14
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: LIST
17368: PPUSH
17369: CALL_OW 69
17373: ST_TO_ADDR
// if not tmp then
17374: LD_VAR 0 5
17378: NOT
17379: IFFALSE 17383
// exit ;
17381: GO 17540
// for i in tmp do
17383: LD_ADDR_VAR 0 3
17387: PUSH
17388: LD_VAR 0 5
17392: PUSH
17393: FOR_IN
17394: IFFALSE 17538
// begin taskList := GetTaskList ( i ) ;
17396: LD_ADDR_VAR 0 6
17400: PUSH
17401: LD_VAR 0 3
17405: PPUSH
17406: CALL_OW 437
17410: ST_TO_ADDR
// if not taskList then
17411: LD_VAR 0 6
17415: NOT
17416: IFFALSE 17420
// continue ;
17418: GO 17393
// for j = 1 to taskList do
17420: LD_ADDR_VAR 0 4
17424: PUSH
17425: DOUBLE
17426: LD_INT 1
17428: DEC
17429: ST_TO_ADDR
17430: LD_VAR 0 6
17434: PUSH
17435: FOR_TO
17436: IFFALSE 17534
// if taskList [ j ] [ 1 ] = | then
17438: LD_VAR 0 6
17442: PUSH
17443: LD_VAR 0 4
17447: ARRAY
17448: PUSH
17449: LD_INT 1
17451: ARRAY
17452: PUSH
17453: LD_STRING |
17455: EQUAL
17456: IFFALSE 17532
// begin _taskList := Delete ( taskList , 1 ) ;
17458: LD_ADDR_VAR 0 7
17462: PUSH
17463: LD_VAR 0 6
17467: PPUSH
17468: LD_INT 1
17470: PPUSH
17471: CALL_OW 3
17475: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
17476: LD_VAR 0 3
17480: PPUSH
17481: LD_VAR 0 7
17485: PPUSH
17486: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
17490: LD_VAR 0 3
17494: PPUSH
17495: LD_VAR 0 6
17499: PUSH
17500: LD_VAR 0 4
17504: ARRAY
17505: PUSH
17506: LD_INT 2
17508: ARRAY
17509: PPUSH
17510: LD_VAR 0 6
17514: PUSH
17515: LD_VAR 0 4
17519: ARRAY
17520: PUSH
17521: LD_INT 3
17523: ARRAY
17524: PPUSH
17525: LD_INT 8
17527: PPUSH
17528: CALL 17545 0 4
// end ;
17532: GO 17435
17534: POP
17535: POP
// end ;
17536: GO 17393
17538: POP
17539: POP
// end ; end ;
17540: LD_VAR 0 2
17544: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
17545: LD_INT 0
17547: PPUSH
17548: PPUSH
17549: PPUSH
17550: PPUSH
17551: PPUSH
17552: PPUSH
17553: PPUSH
17554: PPUSH
17555: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
17556: LD_VAR 0 1
17560: NOT
17561: PUSH
17562: LD_VAR 0 2
17566: PPUSH
17567: LD_VAR 0 3
17571: PPUSH
17572: CALL_OW 488
17576: NOT
17577: OR
17578: PUSH
17579: LD_VAR 0 4
17583: NOT
17584: OR
17585: IFFALSE 17589
// exit ;
17587: GO 17929
// list := [ ] ;
17589: LD_ADDR_VAR 0 13
17593: PUSH
17594: EMPTY
17595: ST_TO_ADDR
// if x - r < 0 then
17596: LD_VAR 0 2
17600: PUSH
17601: LD_VAR 0 4
17605: MINUS
17606: PUSH
17607: LD_INT 0
17609: LESS
17610: IFFALSE 17622
// min_x := 0 else
17612: LD_ADDR_VAR 0 7
17616: PUSH
17617: LD_INT 0
17619: ST_TO_ADDR
17620: GO 17638
// min_x := x - r ;
17622: LD_ADDR_VAR 0 7
17626: PUSH
17627: LD_VAR 0 2
17631: PUSH
17632: LD_VAR 0 4
17636: MINUS
17637: ST_TO_ADDR
// if y - r < 0 then
17638: LD_VAR 0 3
17642: PUSH
17643: LD_VAR 0 4
17647: MINUS
17648: PUSH
17649: LD_INT 0
17651: LESS
17652: IFFALSE 17664
// min_y := 0 else
17654: LD_ADDR_VAR 0 8
17658: PUSH
17659: LD_INT 0
17661: ST_TO_ADDR
17662: GO 17680
// min_y := y - r ;
17664: LD_ADDR_VAR 0 8
17668: PUSH
17669: LD_VAR 0 3
17673: PUSH
17674: LD_VAR 0 4
17678: MINUS
17679: ST_TO_ADDR
// max_x := x + r ;
17680: LD_ADDR_VAR 0 9
17684: PUSH
17685: LD_VAR 0 2
17689: PUSH
17690: LD_VAR 0 4
17694: PLUS
17695: ST_TO_ADDR
// max_y := y + r ;
17696: LD_ADDR_VAR 0 10
17700: PUSH
17701: LD_VAR 0 3
17705: PUSH
17706: LD_VAR 0 4
17710: PLUS
17711: ST_TO_ADDR
// for _x = min_x to max_x do
17712: LD_ADDR_VAR 0 11
17716: PUSH
17717: DOUBLE
17718: LD_VAR 0 7
17722: DEC
17723: ST_TO_ADDR
17724: LD_VAR 0 9
17728: PUSH
17729: FOR_TO
17730: IFFALSE 17847
// for _y = min_y to max_y do
17732: LD_ADDR_VAR 0 12
17736: PUSH
17737: DOUBLE
17738: LD_VAR 0 8
17742: DEC
17743: ST_TO_ADDR
17744: LD_VAR 0 10
17748: PUSH
17749: FOR_TO
17750: IFFALSE 17843
// begin if not ValidHex ( _x , _y ) then
17752: LD_VAR 0 11
17756: PPUSH
17757: LD_VAR 0 12
17761: PPUSH
17762: CALL_OW 488
17766: NOT
17767: IFFALSE 17771
// continue ;
17769: GO 17749
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
17771: LD_VAR 0 11
17775: PPUSH
17776: LD_VAR 0 12
17780: PPUSH
17781: CALL_OW 351
17785: PUSH
17786: LD_VAR 0 11
17790: PPUSH
17791: LD_VAR 0 12
17795: PPUSH
17796: CALL_OW 554
17800: AND
17801: IFFALSE 17841
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
17803: LD_ADDR_VAR 0 13
17807: PUSH
17808: LD_VAR 0 13
17812: PPUSH
17813: LD_VAR 0 13
17817: PUSH
17818: LD_INT 1
17820: PLUS
17821: PPUSH
17822: LD_VAR 0 11
17826: PUSH
17827: LD_VAR 0 12
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: PPUSH
17836: CALL_OW 2
17840: ST_TO_ADDR
// end ;
17841: GO 17749
17843: POP
17844: POP
17845: GO 17729
17847: POP
17848: POP
// if not list then
17849: LD_VAR 0 13
17853: NOT
17854: IFFALSE 17858
// exit ;
17856: GO 17929
// for i in list do
17858: LD_ADDR_VAR 0 6
17862: PUSH
17863: LD_VAR 0 13
17867: PUSH
17868: FOR_IN
17869: IFFALSE 17927
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
17871: LD_VAR 0 1
17875: PPUSH
17876: LD_STRING M
17878: PUSH
17879: LD_VAR 0 6
17883: PUSH
17884: LD_INT 1
17886: ARRAY
17887: PUSH
17888: LD_VAR 0 6
17892: PUSH
17893: LD_INT 2
17895: ARRAY
17896: PUSH
17897: LD_INT 0
17899: PUSH
17900: LD_INT 0
17902: PUSH
17903: LD_INT 0
17905: PUSH
17906: LD_INT 0
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: EMPTY
17919: LIST
17920: PPUSH
17921: CALL_OW 447
17925: GO 17868
17927: POP
17928: POP
// end ; end_of_file
17929: LD_VAR 0 5
17933: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
17934: GO 17936
17936: DISABLE
// begin ru_radar := 98 ;
17937: LD_ADDR_EXP 80
17941: PUSH
17942: LD_INT 98
17944: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17945: LD_ADDR_EXP 81
17949: PUSH
17950: LD_INT 89
17952: ST_TO_ADDR
// us_hack := 99 ;
17953: LD_ADDR_EXP 82
17957: PUSH
17958: LD_INT 99
17960: ST_TO_ADDR
// us_artillery := 97 ;
17961: LD_ADDR_EXP 83
17965: PUSH
17966: LD_INT 97
17968: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17969: LD_ADDR_EXP 84
17973: PUSH
17974: LD_INT 91
17976: ST_TO_ADDR
// end ;
17977: END
