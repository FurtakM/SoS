// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 69 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
   8: LD_INT 4
  10: PPUSH
  11: LD_INT 3
  13: PPUSH
  14: LD_INT 3
  16: PPUSH
  17: LD_INT 5
  19: PPUSH
  20: LD_INT 1
  22: PPUSH
  23: LD_INT 0
  25: PPUSH
  26: LD_INT 0
  28: PPUSH
  29: LD_INT 6
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL 985 0 9
// PrepareAmerican ;
  39: CALL 4726 0 0
// PrepareAlliance ;
  43: CALL 182 0 0
// Action ;
  47: CALL 2134 0 0
// SaveForQuickRestart ;
  51: CALL_OW 22
// if debug then
  55: LD_EXP 1
  59: IFFALSE 68
// FogOff ( 7 ) ;
  61: LD_INT 7
  63: PPUSH
  64: CALL_OW 344
// end ;
  68: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime ; function Init ; begin
  69: LD_INT 0
  71: PPUSH
// debug := 1 ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 1
  79: ST_TO_ADDR
// activeBombTest := false ;
  80: LD_ADDR_EXP 2
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// bombExploded := false ;
  88: LD_ADDR_EXP 4
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
  96: LD_ADDR_EXP 3
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// enteredContaminatedArea := false ;
 104: LD_ADDR_EXP 5
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// artifactPickedUp := false ;
 112: LD_ADDR_EXP 6
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// planCaptured := false ;
 120: LD_ADDR_EXP 7
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// seenBase := false ;
 128: LD_ADDR_EXP 8
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 11 11$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 9
 140: PUSH
 141: LD_INT 42000
 143: PUSH
 144: LD_INT 33600
 146: PUSH
 147: LD_INT 23100
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// canEnd := false ;
 161: LD_ADDR_EXP 10
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// missionTime := 0 0$00 ;
 169: LD_ADDR_EXP 11
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// end ; end_of_file
 177: LD_VAR 0 1
 181: RET
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 182: LD_INT 0
 184: PPUSH
 185: PPUSH
 186: PPUSH
 187: PPUSH
 188: PPUSH
 189: PPUSH
 190: PPUSH
// uc_side := 7 ;
 191: LD_ADDR_OWVAR 20
 195: PUSH
 196: LD_INT 7
 198: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 199: LD_ADDR_EXP 12
 203: PUSH
 204: LD_STRING JMM
 206: PPUSH
 207: LD_EXP 1
 211: NOT
 212: PPUSH
 213: LD_STRING 14a_
 215: PPUSH
 216: CALL 864 0 3
 220: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 221: LD_ADDR_EXP 13
 225: PUSH
 226: LD_STRING Burlak
 228: PPUSH
 229: LD_EXP 1
 233: NOT
 234: PPUSH
 235: LD_STRING 14a_
 237: PPUSH
 238: CALL 864 0 3
 242: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING Joan
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 13a_
 259: PPUSH
 260: CALL 864 0 3
 264: ST_TO_ADDR
// if not Joan then
 265: LD_EXP 14
 269: NOT
 270: IFFALSE 403
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_STRING 13a_others
 279: PPUSH
 280: CALL_OW 31
 284: ST_TO_ADDR
// if tmp then
 285: LD_VAR 0 2
 289: IFFALSE 365
// begin for i in tmp do
 291: LD_ADDR_VAR 0 3
 295: PUSH
 296: LD_VAR 0 2
 300: PUSH
 301: FOR_IN
 302: IFFALSE 363
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 304: LD_VAR 0 3
 308: PPUSH
 309: CALL_OW 257
 313: PUSH
 314: LD_INT 4
 316: EQUAL
 317: PUSH
 318: LD_VAR 0 3
 322: PPUSH
 323: CALL_OW 258
 327: PUSH
 328: LD_INT 1
 330: EQUAL
 331: AND
 332: PUSH
 333: LD_VAR 0 3
 337: PPUSH
 338: CALL_OW 248
 342: PUSH
 343: LD_INT 3
 345: EQUAL
 346: AND
 347: IFFALSE 361
// begin RuSci := i ;
 349: LD_ADDR_EXP 15
 353: PUSH
 354: LD_VAR 0 3
 358: ST_TO_ADDR
// break ;
 359: GO 363
// end ;
 361: GO 301
 363: POP
 364: POP
// end ; if not RuSci then
 365: LD_EXP 15
 369: NOT
 370: IFFALSE 403
// begin uc_nation := 3 ;
 372: LD_ADDR_OWVAR 21
 376: PUSH
 377: LD_INT 3
 379: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 4
 385: PPUSH
 386: LD_INT 10
 388: PPUSH
 389: CALL_OW 380
// RuSci := CreateHuman ;
 393: LD_ADDR_EXP 15
 397: PUSH
 398: CALL_OW 44
 402: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 403: LD_ADDR_VAR 0 6
 407: PUSH
 408: LD_STRING 14a_JMMVeh
 410: PPUSH
 411: LD_INT 5
 413: PUSH
 414: LD_INT 3
 416: PUSH
 417: LD_INT 1
 419: PUSH
 420: LD_INT 7
 422: PUSH
 423: LD_INT 0
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: LIST
 436: PPUSH
 437: CALL_OW 30
 441: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 442: LD_ADDR_VAR 0 7
 446: PUSH
 447: LD_STRING 14a_BurlakVeh
 449: PPUSH
 450: LD_INT 22
 452: PUSH
 453: LD_INT 3
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 51
 461: PUSH
 462: LD_INT 0
 464: PUSH
 465: LD_INT 3
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: PPUSH
 476: CALL_OW 30
 480: ST_TO_ADDR
// uc_direction := 4 ;
 481: LD_ADDR_OWVAR 24
 485: PUSH
 486: LD_INT 4
 488: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 489: LD_ADDR_OWVAR 21
 493: PUSH
 494: LD_VAR 0 6
 498: PUSH
 499: LD_INT 6
 501: ARRAY
 502: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 503: LD_VAR 0 6
 507: PUSH
 508: LD_INT 1
 510: ARRAY
 511: PPUSH
 512: LD_VAR 0 6
 516: PUSH
 517: LD_INT 2
 519: ARRAY
 520: PPUSH
 521: LD_VAR 0 6
 525: PUSH
 526: LD_INT 3
 528: ARRAY
 529: PPUSH
 530: LD_VAR 0 6
 534: PUSH
 535: LD_INT 4
 537: ARRAY
 538: PPUSH
 539: LD_INT 60
 541: PPUSH
 542: LD_INT 80
 544: PPUSH
 545: CALL_OW 12
 549: PPUSH
 550: CALL 927 0 5
// JMMVeh := CreateVehicle ;
 554: LD_ADDR_VAR 0 4
 558: PUSH
 559: CALL_OW 45
 563: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 564: LD_VAR 0 4
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 0
 574: PPUSH
 575: CALL 1589 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 579: LD_VAR 0 6
 583: PUSH
 584: LD_INT 5
 586: ARRAY
 587: PUSH
 588: LD_INT 0
 590: NONEQUAL
 591: IFFALSE 611
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 593: LD_VAR 0 4
 597: PPUSH
 598: LD_VAR 0 6
 602: PUSH
 603: LD_INT 5
 605: ARRAY
 606: PPUSH
 607: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 611: LD_EXP 12
 615: PPUSH
 616: LD_VAR 0 4
 620: PPUSH
 621: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 625: LD_ADDR_OWVAR 21
 629: PUSH
 630: LD_VAR 0 7
 634: PUSH
 635: LD_INT 6
 637: ARRAY
 638: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 639: LD_VAR 0 7
 643: PUSH
 644: LD_INT 1
 646: ARRAY
 647: PPUSH
 648: LD_VAR 0 7
 652: PUSH
 653: LD_INT 2
 655: ARRAY
 656: PPUSH
 657: LD_VAR 0 7
 661: PUSH
 662: LD_INT 3
 664: ARRAY
 665: PPUSH
 666: LD_VAR 0 7
 670: PUSH
 671: LD_INT 4
 673: ARRAY
 674: PPUSH
 675: LD_INT 60
 677: PPUSH
 678: LD_INT 80
 680: PPUSH
 681: CALL_OW 12
 685: PPUSH
 686: CALL 927 0 5
// BurlakVeh := CreateVehicle ;
 690: LD_ADDR_VAR 0 5
 694: PUSH
 695: CALL_OW 45
 699: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 700: LD_VAR 0 5
 704: PPUSH
 705: LD_INT 1
 707: PPUSH
 708: LD_INT 0
 710: PPUSH
 711: CALL 1589 0 3
 715: NOT
 716: IFFALSE 736
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 718: LD_VAR 0 5
 722: PPUSH
 723: LD_INT 233
 725: PPUSH
 726: LD_INT 85
 728: PPUSH
 729: LD_INT 0
 731: PPUSH
 732: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 736: LD_VAR 0 7
 740: PUSH
 741: LD_INT 5
 743: ARRAY
 744: PUSH
 745: LD_INT 0
 747: NONEQUAL
 748: IFFALSE 768
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 750: LD_VAR 0 5
 754: PPUSH
 755: LD_VAR 0 7
 759: PUSH
 760: LD_INT 5
 762: ARRAY
 763: PPUSH
 764: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 768: LD_EXP 13
 772: PPUSH
 773: LD_VAR 0 5
 777: PPUSH
 778: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 782: LD_ADDR_VAR 0 2
 786: PUSH
 787: LD_INT 178
 789: PUSH
 790: LD_INT 91
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: PUSH
 797: LD_INT 137
 799: PUSH
 800: LD_INT 83
 802: PUSH
 803: EMPTY
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 157
 809: PUSH
 810: LD_INT 75
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: PUSH
 822: LD_OWVAR 67
 826: ARRAY
 827: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 828: LD_INT 4
 830: PPUSH
 831: LD_INT 4
 833: PPUSH
 834: LD_VAR 0 2
 838: PUSH
 839: LD_INT 1
 841: ARRAY
 842: PPUSH
 843: LD_VAR 0 2
 847: PUSH
 848: LD_INT 2
 850: ARRAY
 851: PPUSH
 852: LD_INT 0
 854: PPUSH
 855: CALL_OW 58
// end ; end_of_file
 859: LD_VAR 0 1
 863: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 864: LD_INT 0
 866: PPUSH
 867: PPUSH
// if exist_mode then
 868: LD_VAR 0 2
 872: IFFALSE 897
// unit := CreateCharacter ( prefix & ident ) else
 874: LD_ADDR_VAR 0 5
 878: PUSH
 879: LD_VAR 0 3
 883: PUSH
 884: LD_VAR 0 1
 888: STR
 889: PPUSH
 890: CALL_OW 34
 894: ST_TO_ADDR
 895: GO 912
// unit := NewCharacter ( ident ) ;
 897: LD_ADDR_VAR 0 5
 901: PUSH
 902: LD_VAR 0 1
 906: PPUSH
 907: CALL_OW 25
 911: ST_TO_ADDR
// result := unit ;
 912: LD_ADDR_VAR 0 4
 916: PUSH
 917: LD_VAR 0 5
 921: ST_TO_ADDR
// end ;
 922: LD_VAR 0 4
 926: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 927: LD_INT 0
 929: PPUSH
// vc_chassis := chassis ;
 930: LD_ADDR_OWVAR 37
 934: PUSH
 935: LD_VAR 0 1
 939: ST_TO_ADDR
// vc_engine := engine ;
 940: LD_ADDR_OWVAR 39
 944: PUSH
 945: LD_VAR 0 2
 949: ST_TO_ADDR
// vc_control := control ;
 950: LD_ADDR_OWVAR 38
 954: PUSH
 955: LD_VAR 0 3
 959: ST_TO_ADDR
// vc_weapon := weapon ;
 960: LD_ADDR_OWVAR 40
 964: PUSH
 965: LD_VAR 0 4
 969: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 970: LD_ADDR_OWVAR 41
 974: PUSH
 975: LD_VAR 0 5
 979: ST_TO_ADDR
// end ;
 980: LD_VAR 0 6
 984: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
 985: LD_INT 0
 987: PPUSH
 988: PPUSH
 989: PPUSH
// uc_side = 0 ;
 990: LD_ADDR_OWVAR 20
 994: PUSH
 995: LD_INT 0
 997: ST_TO_ADDR
// uc_nation = 0 ;
 998: LD_ADDR_OWVAR 21
1002: PUSH
1003: LD_INT 0
1005: ST_TO_ADDR
// InitHc ;
1006: CALL_OW 19
// InitVc ;
1010: CALL_OW 20
// if mastodonts then
1014: LD_VAR 0 6
1018: IFFALSE 1085
// for i = 1 to mastodonts do
1020: LD_ADDR_VAR 0 11
1024: PUSH
1025: DOUBLE
1026: LD_INT 1
1028: DEC
1029: ST_TO_ADDR
1030: LD_VAR 0 6
1034: PUSH
1035: FOR_TO
1036: IFFALSE 1083
// begin vc_chassis := 31 ;
1038: LD_ADDR_OWVAR 37
1042: PUSH
1043: LD_INT 31
1045: ST_TO_ADDR
// vc_control := control_rider ;
1046: LD_ADDR_OWVAR 38
1050: PUSH
1051: LD_INT 4
1053: ST_TO_ADDR
// animal := CreateVehicle ;
1054: LD_ADDR_VAR 0 12
1058: PUSH
1059: CALL_OW 45
1063: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1064: LD_VAR 0 12
1068: PPUSH
1069: LD_VAR 0 8
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL 1589 0 3
// end ;
1081: GO 1035
1083: POP
1084: POP
// if horses then
1085: LD_VAR 0 5
1089: IFFALSE 1156
// for i = 1 to horses do
1091: LD_ADDR_VAR 0 11
1095: PUSH
1096: DOUBLE
1097: LD_INT 1
1099: DEC
1100: ST_TO_ADDR
1101: LD_VAR 0 5
1105: PUSH
1106: FOR_TO
1107: IFFALSE 1154
// begin hc_class := 21 ;
1109: LD_ADDR_OWVAR 28
1113: PUSH
1114: LD_INT 21
1116: ST_TO_ADDR
// hc_gallery :=  ;
1117: LD_ADDR_OWVAR 33
1121: PUSH
1122: LD_STRING 
1124: ST_TO_ADDR
// animal := CreateHuman ;
1125: LD_ADDR_VAR 0 12
1129: PUSH
1130: CALL_OW 44
1134: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1135: LD_VAR 0 12
1139: PPUSH
1140: LD_VAR 0 8
1144: PPUSH
1145: LD_INT 0
1147: PPUSH
1148: CALL 1589 0 3
// end ;
1152: GO 1106
1154: POP
1155: POP
// if birds then
1156: LD_VAR 0 1
1160: IFFALSE 1227
// for i = 1 to birds do
1162: LD_ADDR_VAR 0 11
1166: PUSH
1167: DOUBLE
1168: LD_INT 1
1170: DEC
1171: ST_TO_ADDR
1172: LD_VAR 0 1
1176: PUSH
1177: FOR_TO
1178: IFFALSE 1225
// begin hc_class = 18 ;
1180: LD_ADDR_OWVAR 28
1184: PUSH
1185: LD_INT 18
1187: ST_TO_ADDR
// hc_gallery =  ;
1188: LD_ADDR_OWVAR 33
1192: PUSH
1193: LD_STRING 
1195: ST_TO_ADDR
// animal := CreateHuman ;
1196: LD_ADDR_VAR 0 12
1200: PUSH
1201: CALL_OW 44
1205: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1206: LD_VAR 0 12
1210: PPUSH
1211: LD_VAR 0 8
1215: PPUSH
1216: LD_INT 0
1218: PPUSH
1219: CALL 1589 0 3
// end ;
1223: GO 1177
1225: POP
1226: POP
// if tigers then
1227: LD_VAR 0 2
1231: IFFALSE 1315
// for i = 1 to tigers do
1233: LD_ADDR_VAR 0 11
1237: PUSH
1238: DOUBLE
1239: LD_INT 1
1241: DEC
1242: ST_TO_ADDR
1243: LD_VAR 0 2
1247: PUSH
1248: FOR_TO
1249: IFFALSE 1313
// begin hc_class = class_tiger ;
1251: LD_ADDR_OWVAR 28
1255: PUSH
1256: LD_INT 14
1258: ST_TO_ADDR
// hc_gallery =  ;
1259: LD_ADDR_OWVAR 33
1263: PUSH
1264: LD_STRING 
1266: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1267: LD_ADDR_OWVAR 35
1271: PUSH
1272: LD_INT 7
1274: NEG
1275: PPUSH
1276: LD_INT 7
1278: PPUSH
1279: CALL_OW 12
1283: ST_TO_ADDR
// animal := CreateHuman ;
1284: LD_ADDR_VAR 0 12
1288: PUSH
1289: CALL_OW 44
1293: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1294: LD_VAR 0 12
1298: PPUSH
1299: LD_VAR 0 8
1303: PPUSH
1304: LD_INT 0
1306: PPUSH
1307: CALL 1589 0 3
// end ;
1311: GO 1248
1313: POP
1314: POP
// if apemans then
1315: LD_VAR 0 3
1319: IFFALSE 1442
// for i = 1 to apemans do
1321: LD_ADDR_VAR 0 11
1325: PUSH
1326: DOUBLE
1327: LD_INT 1
1329: DEC
1330: ST_TO_ADDR
1331: LD_VAR 0 3
1335: PUSH
1336: FOR_TO
1337: IFFALSE 1440
// begin hc_class = class_apeman ;
1339: LD_ADDR_OWVAR 28
1343: PUSH
1344: LD_INT 12
1346: ST_TO_ADDR
// hc_gallery =  ;
1347: LD_ADDR_OWVAR 33
1351: PUSH
1352: LD_STRING 
1354: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1355: LD_ADDR_OWVAR 35
1359: PUSH
1360: LD_INT 5
1362: NEG
1363: PPUSH
1364: LD_INT 5
1366: PPUSH
1367: CALL_OW 12
1371: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1372: LD_ADDR_OWVAR 31
1376: PUSH
1377: LD_INT 1
1379: PPUSH
1380: LD_INT 3
1382: PPUSH
1383: CALL_OW 12
1387: PUSH
1388: LD_INT 1
1390: PPUSH
1391: LD_INT 3
1393: PPUSH
1394: CALL_OW 12
1398: PUSH
1399: LD_INT 0
1401: PUSH
1402: LD_INT 0
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: ST_TO_ADDR
// animal := CreateHuman ;
1411: LD_ADDR_VAR 0 12
1415: PUSH
1416: CALL_OW 44
1420: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1421: LD_VAR 0 12
1425: PPUSH
1426: LD_VAR 0 8
1430: PPUSH
1431: LD_INT 0
1433: PPUSH
1434: CALL 1589 0 3
// end ;
1438: GO 1336
1440: POP
1441: POP
// if enchidnas then
1442: LD_VAR 0 4
1446: IFFALSE 1513
// for i = 1 to enchidnas do
1448: LD_ADDR_VAR 0 11
1452: PUSH
1453: DOUBLE
1454: LD_INT 1
1456: DEC
1457: ST_TO_ADDR
1458: LD_VAR 0 4
1462: PUSH
1463: FOR_TO
1464: IFFALSE 1511
// begin hc_class = 13 ;
1466: LD_ADDR_OWVAR 28
1470: PUSH
1471: LD_INT 13
1473: ST_TO_ADDR
// hc_gallery =  ;
1474: LD_ADDR_OWVAR 33
1478: PUSH
1479: LD_STRING 
1481: ST_TO_ADDR
// animal := CreateHuman ;
1482: LD_ADDR_VAR 0 12
1486: PUSH
1487: CALL_OW 44
1491: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1492: LD_VAR 0 12
1496: PPUSH
1497: LD_VAR 0 8
1501: PPUSH
1502: LD_INT 0
1504: PPUSH
1505: CALL 1589 0 3
// end ;
1509: GO 1463
1511: POP
1512: POP
// if fishes then
1513: LD_VAR 0 7
1517: IFFALSE 1584
// for i = 1 to fishes do
1519: LD_ADDR_VAR 0 11
1523: PUSH
1524: DOUBLE
1525: LD_INT 1
1527: DEC
1528: ST_TO_ADDR
1529: LD_VAR 0 7
1533: PUSH
1534: FOR_TO
1535: IFFALSE 1582
// begin hc_class = 20 ;
1537: LD_ADDR_OWVAR 28
1541: PUSH
1542: LD_INT 20
1544: ST_TO_ADDR
// hc_gallery =  ;
1545: LD_ADDR_OWVAR 33
1549: PUSH
1550: LD_STRING 
1552: ST_TO_ADDR
// animal := CreateHuman ;
1553: LD_ADDR_VAR 0 12
1557: PUSH
1558: CALL_OW 44
1562: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1563: LD_VAR 0 12
1567: PPUSH
1568: LD_VAR 0 9
1572: PPUSH
1573: LD_INT 0
1575: PPUSH
1576: CALL 1589 0 3
// end ;
1580: GO 1534
1582: POP
1583: POP
// end ;
1584: LD_VAR 0 10
1588: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1589: LD_INT 0
1591: PPUSH
1592: PPUSH
1593: PPUSH
1594: PPUSH
// if not unit or not area then
1595: LD_VAR 0 1
1599: NOT
1600: PUSH
1601: LD_VAR 0 2
1605: NOT
1606: OR
1607: IFFALSE 1611
// exit ;
1609: GO 1775
// tmp := AreaToList ( area , i ) ;
1611: LD_ADDR_VAR 0 6
1615: PUSH
1616: LD_VAR 0 2
1620: PPUSH
1621: LD_VAR 0 5
1625: PPUSH
1626: CALL_OW 517
1630: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1631: LD_ADDR_VAR 0 5
1635: PUSH
1636: DOUBLE
1637: LD_INT 1
1639: DEC
1640: ST_TO_ADDR
1641: LD_VAR 0 6
1645: PUSH
1646: LD_INT 1
1648: ARRAY
1649: PUSH
1650: FOR_TO
1651: IFFALSE 1773
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1653: LD_ADDR_VAR 0 7
1657: PUSH
1658: LD_VAR 0 6
1662: PUSH
1663: LD_INT 1
1665: ARRAY
1666: PUSH
1667: LD_VAR 0 5
1671: ARRAY
1672: PUSH
1673: LD_VAR 0 6
1677: PUSH
1678: LD_INT 2
1680: ARRAY
1681: PUSH
1682: LD_VAR 0 5
1686: ARRAY
1687: PUSH
1688: EMPTY
1689: LIST
1690: LIST
1691: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1692: LD_VAR 0 7
1696: PUSH
1697: LD_INT 1
1699: ARRAY
1700: PPUSH
1701: LD_VAR 0 7
1705: PUSH
1706: LD_INT 2
1708: ARRAY
1709: PPUSH
1710: CALL_OW 428
1714: PUSH
1715: LD_INT 0
1717: EQUAL
1718: IFFALSE 1771
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1720: LD_VAR 0 1
1724: PPUSH
1725: LD_VAR 0 7
1729: PUSH
1730: LD_INT 1
1732: ARRAY
1733: PPUSH
1734: LD_VAR 0 7
1738: PUSH
1739: LD_INT 2
1741: ARRAY
1742: PPUSH
1743: LD_VAR 0 3
1747: PPUSH
1748: CALL_OW 48
// result := IsPlaced ( unit ) ;
1752: LD_ADDR_VAR 0 4
1756: PUSH
1757: LD_VAR 0 1
1761: PPUSH
1762: CALL_OW 305
1766: ST_TO_ADDR
// exit ;
1767: POP
1768: POP
1769: GO 1775
// end ; end ;
1771: GO 1650
1773: POP
1774: POP
// end ;
1775: LD_VAR 0 4
1779: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1780: LD_INT 0
1782: PPUSH
1783: PPUSH
1784: PPUSH
1785: PPUSH
1786: PPUSH
1787: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1788: LD_VAR 0 1
1792: NOT
1793: PUSH
1794: LD_VAR 0 1
1798: PPUSH
1799: CALL_OW 263
1803: PUSH
1804: LD_INT 2
1806: EQUAL
1807: NOT
1808: OR
1809: IFFALSE 1813
// exit ;
1811: GO 2129
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1813: LD_ADDR_VAR 0 6
1817: PUSH
1818: LD_INT 22
1820: PUSH
1821: LD_VAR 0 1
1825: PPUSH
1826: CALL_OW 255
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: PUSH
1835: LD_INT 2
1837: PUSH
1838: LD_INT 30
1840: PUSH
1841: LD_INT 36
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 34
1850: PUSH
1851: LD_INT 31
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: PPUSH
1867: CALL_OW 69
1871: ST_TO_ADDR
// if not tmp then
1872: LD_VAR 0 6
1876: NOT
1877: IFFALSE 1881
// exit ;
1879: GO 2129
// result := [ ] ;
1881: LD_ADDR_VAR 0 2
1885: PUSH
1886: EMPTY
1887: ST_TO_ADDR
// for i in tmp do
1888: LD_ADDR_VAR 0 3
1892: PUSH
1893: LD_VAR 0 6
1897: PUSH
1898: FOR_IN
1899: IFFALSE 1970
// begin t := UnitsInside ( i ) ;
1901: LD_ADDR_VAR 0 4
1905: PUSH
1906: LD_VAR 0 3
1910: PPUSH
1911: CALL_OW 313
1915: ST_TO_ADDR
// if t then
1916: LD_VAR 0 4
1920: IFFALSE 1968
// for j in t do
1922: LD_ADDR_VAR 0 7
1926: PUSH
1927: LD_VAR 0 4
1931: PUSH
1932: FOR_IN
1933: IFFALSE 1966
// result := Insert ( result , result + 1 , j ) ;
1935: LD_ADDR_VAR 0 2
1939: PUSH
1940: LD_VAR 0 2
1944: PPUSH
1945: LD_VAR 0 2
1949: PUSH
1950: LD_INT 1
1952: PLUS
1953: PPUSH
1954: LD_VAR 0 7
1958: PPUSH
1959: CALL_OW 2
1963: ST_TO_ADDR
1964: GO 1932
1966: POP
1967: POP
// end ;
1968: GO 1898
1970: POP
1971: POP
// if not result then
1972: LD_VAR 0 2
1976: NOT
1977: IFFALSE 1981
// exit ;
1979: GO 2129
// mech := result [ 1 ] ;
1981: LD_ADDR_VAR 0 5
1985: PUSH
1986: LD_VAR 0 2
1990: PUSH
1991: LD_INT 1
1993: ARRAY
1994: ST_TO_ADDR
// if result > 1 then
1995: LD_VAR 0 2
1999: PUSH
2000: LD_INT 1
2002: GREATER
2003: IFFALSE 2115
// for i = 2 to result do
2005: LD_ADDR_VAR 0 3
2009: PUSH
2010: DOUBLE
2011: LD_INT 2
2013: DEC
2014: ST_TO_ADDR
2015: LD_VAR 0 2
2019: PUSH
2020: FOR_TO
2021: IFFALSE 2113
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2023: LD_ADDR_VAR 0 4
2027: PUSH
2028: LD_VAR 0 2
2032: PUSH
2033: LD_VAR 0 3
2037: ARRAY
2038: PPUSH
2039: LD_INT 3
2041: PPUSH
2042: CALL_OW 259
2046: PUSH
2047: LD_VAR 0 2
2051: PUSH
2052: LD_VAR 0 3
2056: ARRAY
2057: PPUSH
2058: CALL_OW 432
2062: MINUS
2063: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2064: LD_VAR 0 4
2068: PUSH
2069: LD_VAR 0 5
2073: PPUSH
2074: LD_INT 3
2076: PPUSH
2077: CALL_OW 259
2081: PUSH
2082: LD_VAR 0 5
2086: PPUSH
2087: CALL_OW 432
2091: MINUS
2092: GREATEREQUAL
2093: IFFALSE 2111
// mech := result [ i ] ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 2
2104: PUSH
2105: LD_VAR 0 3
2109: ARRAY
2110: ST_TO_ADDR
// end ;
2111: GO 2020
2113: POP
2114: POP
// ComLinkTo ( vehicle , mech ) ;
2115: LD_VAR 0 1
2119: PPUSH
2120: LD_VAR 0 5
2124: PPUSH
2125: CALL_OW 135
// end ; end_of_file
2129: LD_VAR 0 2
2133: RET
// export function Action ; begin
2134: LD_INT 0
2136: PPUSH
// InGameOn ;
2137: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2141: LD_INT 221
2143: PPUSH
2144: LD_INT 80
2146: PPUSH
2147: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2151: LD_EXP 12
2155: PUSH
2156: LD_EXP 13
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: PPUSH
2165: LD_INT 217
2167: PPUSH
2168: LD_INT 79
2170: PPUSH
2171: CALL_OW 111
// wait ( 0 0$7 ) ;
2175: LD_INT 245
2177: PPUSH
2178: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2182: LD_EXP 12
2186: PUSH
2187: LD_EXP 13
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: PPUSH
2196: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2200: LD_EXP 13
2204: PPUSH
2205: LD_STRING D2-Bur-1
2207: PPUSH
2208: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2212: LD_EXP 12
2216: PPUSH
2217: LD_STRING D2-JMM-1
2219: PPUSH
2220: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2224: LD_INT 18
2226: PPUSH
2227: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2231: LD_EXP 13
2235: PPUSH
2236: LD_EXP 12
2240: PPUSH
2241: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2245: LD_EXP 13
2249: PPUSH
2250: LD_STRING D2-Bur-2
2252: PPUSH
2253: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2257: LD_EXP 13
2261: PPUSH
2262: LD_INT 21
2264: PUSH
2265: LD_INT 2
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: PPUSH
2277: LD_EXP 13
2281: PPUSH
2282: CALL_OW 74
2286: PPUSH
2287: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2291: LD_EXP 12
2295: PPUSH
2296: LD_INT 21
2298: PUSH
2299: LD_INT 2
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PPUSH
2306: CALL_OW 69
2310: PPUSH
2311: LD_EXP 12
2315: PPUSH
2316: CALL_OW 74
2320: PPUSH
2321: CALL_OW 120
// wait ( 0 0$1 ) ;
2325: LD_INT 35
2327: PPUSH
2328: CALL_OW 67
// InGameOff ;
2332: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2336: LD_STRING MArtPickup
2338: PPUSH
2339: CALL_OW 337
// end ;
2343: LD_VAR 0 1
2347: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2348: LD_EXP 20
2352: PPUSH
2353: LD_INT 101
2355: PUSH
2356: LD_INT 7
2358: PUSH
2359: EMPTY
2360: LIST
2361: LIST
2362: PPUSH
2363: CALL_OW 72
2367: IFFALSE 2396
2369: GO 2371
2371: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2372: LD_EXP 13
2376: PPUSH
2377: LD_STRING D3-Bur-1
2379: PPUSH
2380: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2384: LD_EXP 12
2388: PPUSH
2389: LD_STRING D3-JMM-1
2391: PPUSH
2392: CALL_OW 88
// end ;
2396: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2397: LD_INT 5
2399: PPUSH
2400: LD_INT 22
2402: PUSH
2403: LD_INT 7
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: PPUSH
2410: CALL_OW 70
2414: IFFALSE 2745
2416: GO 2418
2418: DISABLE
// begin wait ( 0 0$3 ) ;
2419: LD_INT 105
2421: PPUSH
2422: CALL_OW 67
// DialogueOn ;
2426: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2430: LD_EXP 12
2434: PPUSH
2435: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2439: LD_EXP 12
2443: PPUSH
2444: LD_STRING D3a-JMM-1
2446: PPUSH
2447: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2451: LD_EXP 13
2455: PPUSH
2456: LD_STRING D3a-Bur-1
2458: PPUSH
2459: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2463: LD_EXP 12
2467: PPUSH
2468: LD_STRING D3a-JMM-2
2470: PPUSH
2471: CALL_OW 88
// if Joan then
2475: LD_EXP 14
2479: IFFALSE 2495
// SayRadio ( Joan , D3a-Joan-2 ) else
2481: LD_EXP 14
2485: PPUSH
2486: LD_STRING D3a-Joan-2
2488: PPUSH
2489: CALL_OW 94
2493: GO 2507
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2495: LD_EXP 15
2499: PPUSH
2500: LD_STRING D3a-RSci1-2
2502: PPUSH
2503: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2507: LD_EXP 16
2511: PPUSH
2512: LD_STRING D3a-Huck-2
2514: PPUSH
2515: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2519: LD_EXP 17
2523: PPUSH
2524: LD_STRING D3a-Pow-2
2526: PPUSH
2527: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2531: LD_EXP 16
2535: PPUSH
2536: LD_STRING D3a-Huck-3
2538: PPUSH
2539: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2543: LD_EXP 17
2547: PPUSH
2548: LD_STRING D3a-Pow-3
2550: PPUSH
2551: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2555: LD_EXP 16
2559: PPUSH
2560: LD_STRING D3a-Huck-4
2562: PPUSH
2563: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2567: LD_EXP 12
2571: PPUSH
2572: LD_STRING D3a-JMM-4
2574: PPUSH
2575: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2579: LD_EXP 13
2583: PPUSH
2584: LD_STRING D3a-Bur-4
2586: PPUSH
2587: CALL_OW 88
// if Joan then
2591: LD_EXP 14
2595: IFFALSE 2611
// SayRadio ( Joan , D3a-Joan-4 ) else
2597: LD_EXP 14
2601: PPUSH
2602: LD_STRING D3a-Joan-4
2604: PPUSH
2605: CALL_OW 94
2609: GO 2623
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2611: LD_EXP 15
2615: PPUSH
2616: LD_STRING D3a-RSci1-4
2618: PPUSH
2619: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2623: LD_INT 133
2625: PPUSH
2626: LD_INT 43
2628: PPUSH
2629: LD_INT 7
2631: PPUSH
2632: LD_INT 10
2634: NEG
2635: PPUSH
2636: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2640: LD_INT 133
2642: PPUSH
2643: LD_INT 43
2645: PPUSH
2646: LD_INT 7
2648: PPUSH
2649: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2653: LD_INT 133
2655: PPUSH
2656: LD_INT 43
2658: PPUSH
2659: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2663: LD_INT 10
2665: PPUSH
2666: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2670: LD_EXP 12
2674: PPUSH
2675: LD_STRING D3a-JMM-5
2677: PPUSH
2678: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2682: LD_EXP 13
2686: PPUSH
2687: LD_STRING D3a-Bur-5
2689: PPUSH
2690: CALL_OW 88
// DialogueOff ;
2694: CALL_OW 7
// seenBase := true ;
2698: LD_ADDR_EXP 8
2702: PUSH
2703: LD_INT 1
2705: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2706: LD_INT 525
2708: PUSH
2709: LD_INT 420
2711: PUSH
2712: LD_INT 315
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: LD_OWVAR 67
2724: ARRAY
2725: PPUSH
2726: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2730: LD_EXP 19
2734: PPUSH
2735: LD_INT 142
2737: PPUSH
2738: LD_INT 52
2740: PPUSH
2741: CALL_OW 116
// end ;
2745: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2746: LD_EXP 8
2750: NOT
2751: PUSH
2752: LD_EXP 4
2756: NOT
2757: AND
2758: IFFALSE 2778
2760: GO 2762
2762: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2763: LD_EXP 19
2767: PPUSH
2768: LD_INT 142
2770: PPUSH
2771: LD_INT 52
2773: PPUSH
2774: CALL_OW 116
2778: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2779: LD_INT 0
2781: PPUSH
2782: PPUSH
// contaminateTime := tick ;
2783: LD_ADDR_EXP 3
2787: PUSH
2788: LD_OWVAR 1
2792: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2793: LD_INT 175
2795: PPUSH
2796: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2800: LD_ADDR_VAR 0 5
2804: PUSH
2805: LD_INT 4
2807: PPUSH
2808: CALL_OW 469
2812: ST_TO_ADDR
// if art then
2813: LD_VAR 0 5
2817: IFFALSE 2856
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2819: LD_VAR 0 5
2823: PUSH
2824: LD_INT 1
2826: ARRAY
2827: PUSH
2828: LD_INT 157
2830: EQUAL
2831: PUSH
2832: LD_VAR 0 5
2836: PUSH
2837: LD_INT 2
2839: ARRAY
2840: PUSH
2841: LD_INT 75
2843: EQUAL
2844: AND
2845: IFFALSE 2856
// begin YouLost ( Artefact ) ;
2847: LD_STRING Artefact
2849: PPUSH
2850: CALL_OW 104
// exit ;
2854: GO 3008
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2856: LD_EXP 12
2860: PPUSH
2861: CALL_OW 302
2865: PUSH
2866: LD_EXP 13
2870: PPUSH
2871: CALL_OW 302
2875: AND
2876: IFFALSE 2953
// begin DialogueOn ;
2878: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2882: LD_EXP 12
2886: PPUSH
2887: LD_STRING D6a-JMM-1
2889: PPUSH
2890: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2894: LD_EXP 13
2898: PPUSH
2899: LD_STRING D6a-Bur-1
2901: PPUSH
2902: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2906: LD_EXP 12
2910: PPUSH
2911: LD_STRING D6c-JMM-1
2913: PPUSH
2914: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2918: LD_EXP 13
2922: PPUSH
2923: LD_STRING D6c-Bur-1
2925: PPUSH
2926: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2930: LD_EXP 12
2934: PPUSH
2935: LD_STRING D6c-JMM-2
2937: PPUSH
2938: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2942: LD_STRING MBase
2944: PPUSH
2945: CALL_OW 337
// DialogueOff ;
2949: CALL_OW 7
// end ; bombExploded := true ;
2953: LD_ADDR_EXP 4
2957: PUSH
2958: LD_INT 1
2960: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
2961: LD_INT 6300
2963: PUSH
2964: LD_INT 5250
2966: PUSH
2967: LD_INT 4200
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: PUSH
2975: LD_OWVAR 67
2979: ARRAY
2980: PPUSH
2981: CALL_OW 67
// if IsOk ( JMM ) then
2985: LD_EXP 12
2989: PPUSH
2990: CALL_OW 302
2994: IFFALSE 3008
// Say ( JMM , D8-JMM-1 ) ;
2996: LD_EXP 12
3000: PPUSH
3001: LD_STRING D8-JMM-1
3003: PPUSH
3004: CALL_OW 88
// end ;
3008: LD_VAR 0 4
3012: RET
// every 0 0$1 trigger stevensTimer and bombExploded do
3013: LD_EXP 9
3017: PUSH
3018: LD_EXP 4
3022: AND
3023: IFFALSE 3078
3025: GO 3027
3027: DISABLE
// begin enable ;
3028: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3029: LD_INT 9
3031: PPUSH
3032: LD_INT 22
3034: PUSH
3035: LD_INT 7
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: PPUSH
3042: CALL_OW 70
3046: IFFALSE 3064
// stevensTimer := stevensTimer - 0 0$30 else
3048: LD_ADDR_EXP 9
3052: PUSH
3053: LD_EXP 9
3057: PUSH
3058: LD_INT 1050
3060: MINUS
3061: ST_TO_ADDR
3062: GO 3078
// stevensTimer := stevensTimer - 0 0$1 ;
3064: LD_ADDR_EXP 9
3068: PUSH
3069: LD_EXP 9
3073: PUSH
3074: LD_INT 35
3076: MINUS
3077: ST_TO_ADDR
// end ;
3078: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 do var i , tmp ;
3079: LD_EXP 9
3083: PUSH
3084: LD_INT 0
3086: LESSEQUAL
3087: IFFALSE 3218
3089: GO 3091
3091: DISABLE
3092: LD_INT 0
3094: PPUSH
3095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3096: LD_ADDR_VAR 0 2
3100: PUSH
3101: LD_INT 22
3103: PUSH
3104: LD_INT 1
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: PUSH
3111: LD_INT 25
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PPUSH
3125: CALL_OW 69
3129: ST_TO_ADDR
// for i in tmp do
3130: LD_ADDR_VAR 0 1
3134: PUSH
3135: LD_VAR 0 2
3139: PUSH
3140: FOR_IN
3141: IFFALSE 3169
// begin ComExitBuilding ( i ) ;
3143: LD_VAR 0 1
3147: PPUSH
3148: CALL_OW 122
// AddComMoveXY ( i , 29 , 56 ) ;
3152: LD_VAR 0 1
3156: PPUSH
3157: LD_INT 29
3159: PPUSH
3160: LD_INT 56
3162: PPUSH
3163: CALL_OW 171
// end ;
3167: GO 3140
3169: POP
3170: POP
// repeat wait ( 0 0$1 ) ;
3171: LD_INT 35
3173: PPUSH
3174: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3178: LD_INT 8
3180: PPUSH
3181: LD_INT 22
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PUSH
3191: LD_INT 25
3193: PUSH
3194: LD_INT 4
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PPUSH
3205: CALL_OW 70
3209: IFFALSE 3171
// YouLost ( Time ) ;
3211: LD_STRING Time
3213: PPUSH
3214: CALL_OW 104
// end ;
3218: PPOPN 2
3220: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3221: LD_INT 22
3223: PUSH
3224: LD_INT 7
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PUSH
3231: LD_INT 92
3233: PUSH
3234: LD_INT 142
3236: PUSH
3237: LD_INT 52
3239: PUSH
3240: LD_INT 27
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PPUSH
3253: CALL_OW 69
3257: PUSH
3258: LD_EXP 3
3262: PUSH
3263: LD_INT 6000
3265: PLUS
3266: PUSH
3267: LD_OWVAR 1
3271: GREATER
3272: AND
3273: PUSH
3274: LD_EXP 4
3278: AND
3279: IFFALSE 3334
3281: GO 3283
3283: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3284: LD_EXP 12
3288: PUSH
3289: LD_EXP 13
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL_OW 85
// DialogueOn ;
3302: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3306: LD_EXP 12
3310: PPUSH
3311: LD_STRING D6b-JMM-1
3313: PPUSH
3314: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3318: LD_EXP 13
3322: PPUSH
3323: LD_STRING D6b-Bur-1
3325: PPUSH
3326: CALL_OW 88
// DialogueOff ;
3330: CALL_OW 7
// end ;
3334: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3335: LD_EXP 13
3339: PPUSH
3340: LD_INT 142
3342: PPUSH
3343: LD_INT 52
3345: PPUSH
3346: CALL_OW 297
3350: PUSH
3351: LD_INT 25
3353: LESS
3354: PUSH
3355: LD_EXP 13
3359: PPUSH
3360: CALL_OW 310
3364: PPUSH
3365: LD_INT 142
3367: PPUSH
3368: LD_INT 52
3370: PPUSH
3371: CALL_OW 297
3375: PUSH
3376: LD_INT 25
3378: LESS
3379: OR
3380: PUSH
3381: LD_EXP 13
3385: PPUSH
3386: CALL_OW 256
3390: PUSH
3391: LD_INT 1000
3393: LESS
3394: AND
3395: PUSH
3396: LD_EXP 3
3400: PUSH
3401: LD_INT 6000
3403: PLUS
3404: PUSH
3405: LD_OWVAR 1
3409: GREATER
3410: AND
3411: PUSH
3412: LD_EXP 4
3416: AND
3417: IFFALSE 3450
3419: GO 3421
3421: DISABLE
// begin DialogueOn ;
3422: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3426: LD_EXP 13
3430: PPUSH
3431: LD_STRING D7-Bur-1
3433: PPUSH
3434: CALL_OW 88
// enteredContaminatedArea := true ;
3438: LD_ADDR_EXP 5
3442: PUSH
3443: LD_INT 1
3445: ST_TO_ADDR
// DialogueOff ;
3446: CALL_OW 7
// end ;
3450: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3451: LD_EXP 12
3455: PPUSH
3456: LD_INT 142
3458: PPUSH
3459: LD_INT 52
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 25
3469: LESS
3470: PUSH
3471: LD_EXP 12
3475: PPUSH
3476: CALL_OW 310
3480: PPUSH
3481: LD_INT 142
3483: PPUSH
3484: LD_INT 52
3486: PPUSH
3487: CALL_OW 297
3491: PUSH
3492: LD_INT 25
3494: LESS
3495: OR
3496: PUSH
3497: LD_EXP 12
3501: PPUSH
3502: CALL_OW 256
3506: PUSH
3507: LD_INT 1000
3509: LESS
3510: AND
3511: PUSH
3512: LD_EXP 3
3516: PUSH
3517: LD_INT 6000
3519: PLUS
3520: PUSH
3521: LD_OWVAR 1
3525: GREATER
3526: AND
3527: PUSH
3528: LD_EXP 4
3532: AND
3533: IFFALSE 3566
3535: GO 3537
3537: DISABLE
// begin DialogueOn ;
3538: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3542: LD_EXP 12
3546: PPUSH
3547: LD_STRING D7-JMM-1
3549: PPUSH
3550: CALL_OW 88
// enteredContaminatedArea := true ;
3554: LD_ADDR_EXP 5
3558: PUSH
3559: LD_INT 1
3561: ST_TO_ADDR
// DialogueOff ;
3562: CALL_OW 7
// end ;
3566: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3567: LD_EXP 6
3571: PUSH
3572: LD_EXP 12
3576: PPUSH
3577: CALL_OW 302
3581: AND
3582: PUSH
3583: LD_EXP 13
3587: PPUSH
3588: CALL_OW 302
3592: AND
3593: IFFALSE 3662
3595: GO 3597
3597: DISABLE
// begin DialogueOn ;
3598: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3602: LD_EXP 12
3606: PUSH
3607: LD_EXP 13
3611: PUSH
3612: EMPTY
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3620: LD_EXP 12
3624: PPUSH
3625: LD_STRING D4-JMM-1
3627: PPUSH
3628: CALL_OW 88
// if not bombExploded then
3632: LD_EXP 4
3636: NOT
3637: IFFALSE 3651
// Say ( Burlak , D4-Bur-1 ) ;
3639: LD_EXP 13
3643: PPUSH
3644: LD_STRING D4-Bur-1
3646: PPUSH
3647: CALL_OW 88
// DialogueOff ;
3651: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3655: LD_STRING MReturn
3657: PPUSH
3658: CALL_OW 337
// end ;
3662: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3663: LD_EXP 7
3667: NOT
3668: PUSH
3669: LD_INT 22
3671: PUSH
3672: LD_INT 7
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 91
3681: PUSH
3682: LD_INT 9
3684: PUSH
3685: LD_INT 6
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PPUSH
3697: CALL_OW 69
3701: AND
3702: IFFALSE 3779
3704: GO 3706
3706: DISABLE
// begin DialogueOn ;
3707: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3711: LD_INT 55
3713: PPUSH
3714: LD_INT 11
3716: PPUSH
3717: LD_INT 7
3719: PPUSH
3720: LD_INT 6
3722: NEG
3723: PPUSH
3724: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3728: LD_INT 55
3730: PPUSH
3731: LD_INT 11
3733: PPUSH
3734: LD_INT 7
3736: PPUSH
3737: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3741: LD_EXP 13
3745: PPUSH
3746: LD_STRING D9-Bur-1
3748: PPUSH
3749: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3753: LD_EXP 12
3757: PPUSH
3758: LD_STRING D9-JMM-1
3760: PPUSH
3761: CALL_OW 88
// DialogueOff ;
3765: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3769: LD_INT 9
3771: PPUSH
3772: LD_INT 7
3774: PPUSH
3775: CALL_OW 235
// end ;
3779: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3780: LD_INT 9
3782: PPUSH
3783: LD_INT 22
3785: PUSH
3786: LD_INT 7
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PPUSH
3793: CALL_OW 70
3797: IFFALSE 3833
3799: GO 3801
3801: DISABLE
// begin wait ( 0 0$07 ) ;
3802: LD_INT 245
3804: PPUSH
3805: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3809: LD_EXP 12
3813: PPUSH
3814: LD_STRING D10b-JMM-1
3816: PPUSH
3817: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3821: LD_EXP 13
3825: PPUSH
3826: LD_STRING D10b-Bur-1
3828: PPUSH
3829: CALL_OW 88
// end ;
3833: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3834: LD_EXP 9
3838: PUSH
3839: LD_INT 22
3841: PUSH
3842: LD_INT 1
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: LD_INT 25
3851: PUSH
3852: LD_INT 4
3854: PUSH
3855: EMPTY
3856: LIST
3857: LIST
3858: PUSH
3859: LD_INT 26
3861: PUSH
3862: LD_INT 1
3864: PUSH
3865: EMPTY
3866: LIST
3867: LIST
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: PPUSH
3874: CALL_OW 69
3878: AND
3879: PUSH
3880: LD_INT 5
3882: PPUSH
3883: CALL_OW 255
3887: PUSH
3888: LD_INT 7
3890: EQUAL
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 1
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 25
3904: PUSH
3905: LD_INT 1
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 0
3923: EQUAL
3924: OR
3925: AND
3926: IFFALSE 4308
3928: GO 3930
3930: DISABLE
3931: LD_INT 0
3933: PPUSH
// begin case Query ( QKill ) of 1 :
3934: LD_STRING QKill
3936: PPUSH
3937: CALL_OW 97
3941: PUSH
3942: LD_INT 1
3944: DOUBLE
3945: EQUAL
3946: IFTRUE 3950
3948: GO 4296
3950: POP
// begin DialogueOn ;
3951: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
3955: LD_EXP 12
3959: PPUSH
3960: LD_STRING D10a-JMM-1
3962: PPUSH
3963: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
3967: LD_EXP 13
3971: PPUSH
3972: LD_STRING D10a-Bur-1
3974: PPUSH
3975: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
3979: LD_EXP 12
3983: PPUSH
3984: LD_STRING D10a-JMM-2
3986: PPUSH
3987: CALL_OW 88
// if IsOk ( Stevens ) then
3991: LD_EXP 16
3995: PPUSH
3996: CALL_OW 302
4000: IFFALSE 4016
// Say ( Stevens , D10a-Huck-2 ) else
4002: LD_EXP 16
4006: PPUSH
4007: LD_STRING D10a-Huck-2
4009: PPUSH
4010: CALL_OW 88
4014: GO 4067
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_INT 1
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: PUSH
4026: LD_INT 25
4028: PUSH
4029: LD_INT 4
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PUSH
4036: LD_INT 26
4038: PUSH
4039: LD_INT 1
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PPUSH
4051: CALL_OW 69
4055: PUSH
4056: LD_INT 1
4058: ARRAY
4059: PPUSH
4060: LD_STRING D10a-ASci1-3
4062: PPUSH
4063: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4067: LD_EXP 12
4071: PPUSH
4072: LD_STRING D10a-JMM-4
4074: PPUSH
4075: CALL_OW 88
// if IsOk ( Stevens ) then
4079: LD_EXP 16
4083: PPUSH
4084: CALL_OW 302
4088: IFFALSE 4102
// Say ( Stevens , D10a-Huck-3 ) ;
4090: LD_EXP 16
4094: PPUSH
4095: LD_STRING D10a-Huck-3
4097: PPUSH
4098: CALL_OW 88
// DialogueOff ;
4102: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 7
4111: PPUSH
4112: LD_INT 1
4114: PPUSH
4115: LD_INT 1
4117: PPUSH
4118: CALL_OW 80
// planCaptured := true ;
4122: LD_ADDR_EXP 7
4126: PUSH
4127: LD_INT 1
4129: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4130: LD_STRING MEnd
4132: PPUSH
4133: CALL_OW 337
// canEnd := true ;
4137: LD_ADDR_EXP 10
4141: PUSH
4142: LD_INT 1
4144: ST_TO_ADDR
// missionTime := tick ;
4145: LD_ADDR_EXP 11
4149: PUSH
4150: LD_OWVAR 1
4154: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
4155: LD_INT 70
4157: PPUSH
4158: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4162: LD_ADDR_VAR 0 1
4166: PUSH
4167: LD_INT 22
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PUSH
4177: LD_INT 21
4179: PUSH
4180: LD_INT 1
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PPUSH
4191: CALL_OW 69
4195: PUSH
4196: FOR_IN
4197: IFFALSE 4261
// begin if IsInArea ( i , stevensEscapeArea ) then
4199: LD_VAR 0 1
4203: PPUSH
4204: LD_INT 8
4206: PPUSH
4207: CALL_OW 308
4211: IFFALSE 4224
// begin RemoveUnit ( i ) ;
4213: LD_VAR 0 1
4217: PPUSH
4218: CALL_OW 64
// continue ;
4222: GO 4196
// end ; if IsInUnit ( i ) then
4224: LD_VAR 0 1
4228: PPUSH
4229: CALL_OW 310
4233: IFFALSE 4244
// ComExitBuilding ( i ) ;
4235: LD_VAR 0 1
4239: PPUSH
4240: CALL_OW 122
// AddComMoveXY ( i , 28 , 55 ) ;
4244: LD_VAR 0 1
4248: PPUSH
4249: LD_INT 28
4251: PPUSH
4252: LD_INT 55
4254: PPUSH
4255: CALL_OW 171
// end ;
4259: GO 4196
4261: POP
4262: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4263: LD_INT 22
4265: PUSH
4266: LD_INT 1
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PUSH
4273: LD_INT 21
4275: PUSH
4276: LD_INT 1
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: NOT
4292: IFFALSE 4155
// end ; 2 :
4294: GO 4308
4296: LD_INT 2
4298: DOUBLE
4299: EQUAL
4300: IFTRUE 4304
4302: GO 4307
4304: POP
// ; end ;
4305: GO 4308
4307: POP
// end ;
4308: PPOPN 1
4310: END
// every 0 0$1 trigger GetSide ( us_lab ) = 7 and not planCaptured do
4311: LD_INT 1
4313: PPUSH
4314: CALL_OW 255
4318: PUSH
4319: LD_INT 7
4321: EQUAL
4322: PUSH
4323: LD_EXP 7
4327: NOT
4328: AND
4329: IFFALSE 4367
4331: GO 4333
4333: DISABLE
// begin planCaptured := true ;
4334: LD_ADDR_EXP 7
4338: PUSH
4339: LD_INT 1
4341: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4342: LD_STRING MEnd
4344: PPUSH
4345: CALL_OW 337
// canEnd := true ;
4349: LD_ADDR_EXP 10
4353: PUSH
4354: LD_INT 1
4356: ST_TO_ADDR
// missionTime := tick ;
4357: LD_ADDR_EXP 11
4361: PUSH
4362: LD_OWVAR 1
4366: ST_TO_ADDR
// end ;
4367: END
// every 0 0$1 trigger canEnd do var un ;
4368: LD_EXP 10
4372: IFFALSE 4472
4374: GO 4376
4376: DISABLE
4377: LD_INT 0
4379: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4380: LD_INT 10
4382: PPUSH
4383: LD_INT 1
4385: PPUSH
4386: CALL_OW 424
// if Difficulty < 2 then
4390: LD_OWVAR 67
4394: PUSH
4395: LD_INT 2
4397: LESS
4398: IFFALSE 4402
// exit ;
4400: GO 4472
// uc_side := 8 ;
4402: LD_ADDR_OWVAR 20
4406: PUSH
4407: LD_INT 8
4409: ST_TO_ADDR
// uc_nation := 2 ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 2
4417: ST_TO_ADDR
// InitHc ;
4418: CALL_OW 19
// PrepareHuman ( false , class_sniper , 10 ) ;
4422: LD_INT 0
4424: PPUSH
4425: LD_INT 5
4427: PPUSH
4428: LD_INT 10
4430: PPUSH
4431: CALL_OW 380
// un := CreateHuman ;
4435: LD_ADDR_VAR 0 1
4439: PUSH
4440: CALL_OW 44
4444: ST_TO_ADDR
// PlaceUnitXY ( un , 227 , 87 , false ) ;
4445: LD_VAR 0 1
4449: PPUSH
4450: LD_INT 227
4452: PPUSH
4453: LD_INT 87
4455: PPUSH
4456: LD_INT 0
4458: PPUSH
4459: CALL_OW 48
// ComHold ( un ) ;
4463: LD_VAR 0 1
4467: PPUSH
4468: CALL_OW 140
// end ;
4472: PPOPN 1
4474: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4475: LD_EXP 7
4479: NOT
4480: PUSH
4481: LD_INT 1
4483: PPUSH
4484: CALL_OW 301
4488: AND
4489: IFFALSE 4501
4491: GO 4493
4493: DISABLE
// YouLost ( Lab ) ;
4494: LD_STRING Lab
4496: PPUSH
4497: CALL_OW 104
4501: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do
4502: LD_INT 10
4504: PPUSH
4505: LD_INT 22
4507: PUSH
4508: LD_INT 7
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PPUSH
4515: CALL_OW 70
4519: PUSH
4520: LD_INT 2
4522: GREATEREQUAL
4523: PUSH
4524: LD_INT 10
4526: PPUSH
4527: LD_INT 2
4529: PUSH
4530: LD_INT 34
4532: PUSH
4533: LD_INT 12
4535: PUSH
4536: EMPTY
4537: LIST
4538: LIST
4539: PUSH
4540: LD_INT 34
4542: PUSH
4543: LD_INT 51
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: PPUSH
4555: CALL_OW 70
4559: AND
4560: PUSH
4561: LD_EXP 10
4565: AND
4566: PUSH
4567: LD_EXP 7
4571: AND
4572: PUSH
4573: LD_EXP 6
4577: AND
4578: IFFALSE 4725
4580: GO 4582
4582: DISABLE
// begin AddMedal ( Explosion , 1 ) ;
4583: LD_STRING Explosion
4585: PPUSH
4586: LD_INT 1
4588: PPUSH
4589: CALL_OW 101
// if enteredContaminatedArea then
4593: LD_EXP 5
4597: IFFALSE 4611
// AddMedal ( BioHazard , 1 ) else
4599: LD_STRING BioHazard
4601: PPUSH
4602: LD_INT 1
4604: PPUSH
4605: CALL_OW 101
4609: GO 4622
// AddMedal ( BioHazard , - 1 ) ;
4611: LD_STRING BioHazard
4613: PPUSH
4614: LD_INT 1
4616: NEG
4617: PPUSH
4618: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
4622: LD_EXP 11
4626: PUSH
4627: LD_INT 42000
4629: PUSH
4630: LD_INT 31500
4632: PUSH
4633: LD_INT 25200
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: LIST
4640: PUSH
4641: LD_OWVAR 67
4645: ARRAY
4646: LESSEQUAL
4647: IFFALSE 4661
// AddMedal ( Speed , 1 ) else
4649: LD_STRING Speed
4651: PPUSH
4652: LD_INT 1
4654: PPUSH
4655: CALL_OW 101
4659: GO 4672
// AddMedal ( Speed , - 1 ) ;
4661: LD_STRING Speed
4663: PPUSH
4664: LD_INT 1
4666: NEG
4667: PPUSH
4668: CALL_OW 101
// GiveMedals ( Main ) ;
4672: LD_STRING Main
4674: PPUSH
4675: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
4679: LD_EXP 12
4683: PUSH
4684: LD_EXP 13
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: PPUSH
4693: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
4697: LD_EXP 12
4701: PPUSH
4702: LD_STRING 14a_JMM
4704: PPUSH
4705: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
4709: LD_EXP 13
4713: PPUSH
4714: LD_STRING 14a_Burlak
4716: PPUSH
4717: CALL_OW 38
// YouWin ;
4721: CALL_OW 103
// end ; end_of_file
4725: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
4726: LD_INT 0
4728: PPUSH
4729: PPUSH
4730: PPUSH
4731: PPUSH
// uc_side := 1 ;
4732: LD_ADDR_OWVAR 20
4736: PUSH
4737: LD_INT 1
4739: ST_TO_ADDR
// uc_nation := 1 ;
4740: LD_ADDR_OWVAR 21
4744: PUSH
4745: LD_INT 1
4747: ST_TO_ADDR
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
4748: LD_INT 34
4750: PPUSH
4751: CALL_OW 274
4755: PPUSH
4756: LD_INT 1
4758: PPUSH
4759: LD_INT 500
4761: PPUSH
4762: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
4766: LD_INT 34
4768: PPUSH
4769: CALL_OW 274
4773: PPUSH
4774: LD_INT 3
4776: PPUSH
4777: LD_INT 20
4779: PPUSH
4780: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
4784: LD_ADDR_EXP 16
4788: PUSH
4789: LD_STRING Stevens
4791: PPUSH
4792: CALL_OW 25
4796: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
4797: LD_ADDR_EXP 17
4801: PUSH
4802: LD_STRING Powell
4804: PPUSH
4805: CALL_OW 25
4809: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
4810: LD_EXP 16
4814: PPUSH
4815: LD_INT 1
4817: PPUSH
4818: CALL_OW 52
// vehGuard := [ ] ;
4822: LD_ADDR_EXP 21
4826: PUSH
4827: EMPTY
4828: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
4829: LD_INT 4
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: LD_INT 3
4837: PPUSH
4838: LD_INT 8
4840: PPUSH
4841: LD_INT 100
4843: PPUSH
4844: CALL 927 0 5
// sibBomb := CreateVehicle ;
4848: LD_ADDR_EXP 19
4852: PUSH
4853: CALL_OW 45
4857: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
4858: LD_EXP 19
4862: PPUSH
4863: LD_INT 1
4865: PPUSH
4866: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
4870: LD_EXP 19
4874: PPUSH
4875: LD_INT 93
4877: PPUSH
4878: LD_INT 74
4880: PPUSH
4881: LD_INT 0
4883: PPUSH
4884: CALL_OW 48
// guards := [ ] ;
4888: LD_ADDR_EXP 20
4892: PUSH
4893: EMPTY
4894: ST_TO_ADDR
// for i = 1 to 3 do
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: DOUBLE
4901: LD_INT 1
4903: DEC
4904: ST_TO_ADDR
4905: LD_INT 3
4907: PUSH
4908: FOR_TO
4909: IFFALSE 5001
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
4911: LD_INT 0
4913: PPUSH
4914: LD_INT 1
4916: PPUSH
4917: LD_INT 8
4919: PUSH
4920: LD_INT 9
4922: PUSH
4923: LD_INT 10
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: LIST
4930: PUSH
4931: LD_OWVAR 67
4935: ARRAY
4936: PPUSH
4937: CALL_OW 380
// un := CreateHuman ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: CALL_OW 44
4950: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
4951: LD_VAR 0 3
4955: PPUSH
4956: LD_INT 2
4958: PUSH
4959: LD_INT 3
4961: PUSH
4962: LD_INT 4
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_VAR 0 2
4974: ARRAY
4975: PPUSH
4976: LD_INT 0
4978: PPUSH
4979: CALL_OW 49
// guards := guards ^ un ;
4983: LD_ADDR_EXP 20
4987: PUSH
4988: LD_EXP 20
4992: PUSH
4993: LD_VAR 0 3
4997: ADD
4998: ST_TO_ADDR
// end ;
4999: GO 4908
5001: POP
5002: POP
// baseGuards := [ ] ;
5003: LD_ADDR_EXP 18
5007: PUSH
5008: EMPTY
5009: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5010: LD_ADDR_VAR 0 2
5014: PUSH
5015: DOUBLE
5016: LD_INT 1
5018: DEC
5019: ST_TO_ADDR
5020: LD_INT 5
5022: PUSH
5023: LD_INT 6
5025: PUSH
5026: LD_INT 7
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: PUSH
5034: LD_OWVAR 67
5038: ARRAY
5039: PUSH
5040: FOR_TO
5041: IFFALSE 5187
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5043: LD_INT 0
5045: PPUSH
5046: LD_INT 8
5048: PUSH
5049: LD_INT 9
5051: PUSH
5052: LD_INT 10
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: PUSH
5060: LD_OWVAR 67
5064: ARRAY
5065: PPUSH
5066: CALL_OW 381
// un := CreateHuman ;
5070: LD_ADDR_VAR 0 3
5074: PUSH
5075: CALL_OW 44
5079: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5080: LD_ADDR_EXP 18
5084: PUSH
5085: LD_EXP 18
5089: PUSH
5090: LD_VAR 0 3
5094: ADD
5095: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5096: LD_ADDR_VAR 0 4
5100: PUSH
5101: LD_INT 22
5103: PUSH
5104: LD_INT 1
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 58
5113: PUSH
5114: EMPTY
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 32
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: ST_TO_ADDR
// if tmp then
5137: LD_VAR 0 4
5141: IFFALSE 5173
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5143: LD_VAR 0 3
5147: PPUSH
5148: LD_VAR 0 4
5152: PUSH
5153: LD_INT 1
5155: PPUSH
5156: LD_VAR 0 4
5160: PPUSH
5161: CALL_OW 12
5165: ARRAY
5166: PPUSH
5167: CALL_OW 52
5171: GO 5185
// PlaceHumanInUnit ( un , us_bar ) ;
5173: LD_VAR 0 3
5177: PPUSH
5178: LD_INT 51
5180: PPUSH
5181: CALL_OW 52
// end ;
5185: GO 5040
5187: POP
5188: POP
// if Difficulty > 1 then
5189: LD_OWVAR 67
5193: PUSH
5194: LD_INT 1
5196: GREATER
5197: IFFALSE 5241
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5199: LD_INT 0
5201: PPUSH
5202: LD_INT 5
5204: PPUSH
5205: LD_INT 9
5207: PUSH
5208: LD_INT 10
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_OWVAR 67
5219: PUSH
5220: LD_INT 1
5222: MINUS
5223: ARRAY
5224: PPUSH
5225: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5229: CALL_OW 44
5233: PPUSH
5234: LD_INT 80
5236: PPUSH
5237: CALL_OW 52
// end ; for i = 1 to 3 do
5241: LD_ADDR_VAR 0 2
5245: PUSH
5246: DOUBLE
5247: LD_INT 1
5249: DEC
5250: ST_TO_ADDR
5251: LD_INT 3
5253: PUSH
5254: FOR_TO
5255: IFFALSE 5281
// begin PrepareMechanic ( false , 9 ) ;
5257: LD_INT 0
5259: PPUSH
5260: LD_INT 9
5262: PPUSH
5263: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5267: CALL_OW 44
5271: PPUSH
5272: LD_INT 43
5274: PPUSH
5275: CALL_OW 52
// end ;
5279: GO 5254
5281: POP
5282: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5283: CALL_OW 44
5287: PPUSH
5288: LD_INT 49
5290: PPUSH
5291: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: DOUBLE
5301: LD_INT 1
5303: DEC
5304: ST_TO_ADDR
5305: LD_INT 1
5307: PUSH
5308: LD_OWVAR 67
5312: PLUS
5313: PUSH
5314: FOR_TO
5315: IFFALSE 5358
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5317: LD_INT 0
5319: PPUSH
5320: LD_INT 8
5322: PUSH
5323: LD_INT 9
5325: PUSH
5326: LD_INT 10
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: LIST
5333: PUSH
5334: LD_OWVAR 67
5338: ARRAY
5339: PPUSH
5340: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5344: CALL_OW 44
5348: PPUSH
5349: LD_INT 5
5351: PPUSH
5352: CALL_OW 52
// end ;
5356: GO 5314
5358: POP
5359: POP
// for i = 1 to 3 do
5360: LD_ADDR_VAR 0 2
5364: PUSH
5365: DOUBLE
5366: LD_INT 1
5368: DEC
5369: ST_TO_ADDR
5370: LD_INT 3
5372: PUSH
5373: FOR_TO
5374: IFFALSE 5400
// begin PrepareScientist ( false , 10 ) ;
5376: LD_INT 0
5378: PPUSH
5379: LD_INT 10
5381: PPUSH
5382: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
5386: CALL_OW 44
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: CALL_OW 52
// end ;
5398: GO 5373
5400: POP
5401: POP
// end ;
5402: LD_VAR 0 1
5406: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
5407: LD_EXP 20
5411: PUSH
5412: LD_EXP 2
5416: NOT
5417: AND
5418: IFFALSE 5604
5420: GO 5422
5422: DISABLE
5423: LD_INT 0
5425: PPUSH
5426: PPUSH
5427: PPUSH
// begin enable ;
5428: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: LD_INT 204
5436: PUSH
5437: LD_INT 30
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 165
5446: PUSH
5447: LD_INT 24
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: PUSH
5454: LD_INT 195
5456: PUSH
5457: LD_INT 6
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 223
5466: PUSH
5467: LD_INT 54
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: PUSH
5474: LD_INT 214
5476: PUSH
5477: LD_INT 84
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PUSH
5484: LD_INT 206
5486: PUSH
5487: LD_INT 71
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: LIST
5501: ST_TO_ADDR
// for i in guards do
5502: LD_ADDR_VAR 0 1
5506: PUSH
5507: LD_EXP 20
5511: PUSH
5512: FOR_IN
5513: IFFALSE 5602
// begin if HasTask ( i ) then
5515: LD_VAR 0 1
5519: PPUSH
5520: CALL_OW 314
5524: IFFALSE 5530
// continue else
5526: GO 5512
5528: GO 5600
// begin j := rand ( 1 , 6 ) ;
5530: LD_ADDR_VAR 0 2
5534: PUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_INT 6
5540: PPUSH
5541: CALL_OW 12
5545: ST_TO_ADDR
// if not See ( 7 , i ) then
5546: LD_INT 7
5548: PPUSH
5549: LD_VAR 0 1
5553: PPUSH
5554: CALL_OW 292
5558: NOT
5559: IFFALSE 5600
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
5561: LD_VAR 0 1
5565: PPUSH
5566: LD_VAR 0 3
5570: PUSH
5571: LD_VAR 0 2
5575: ARRAY
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_VAR 0 2
5590: ARRAY
5591: PUSH
5592: LD_INT 2
5594: ARRAY
5595: PPUSH
5596: CALL_OW 114
// end ; end ;
5600: GO 5512
5602: POP
5603: POP
// end ;
5604: PPOPN 3
5606: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
5607: LD_EXP 21
5611: PUSH
5612: LD_EXP 7
5616: NOT
5617: AND
5618: IFFALSE 5689
5620: GO 5622
5622: DISABLE
5623: LD_INT 0
5625: PPUSH
// begin enable ;
5626: ENABLE
// for i in vehGuard do
5627: LD_ADDR_VAR 0 1
5631: PUSH
5632: LD_EXP 21
5636: PUSH
5637: FOR_IN
5638: IFFALSE 5687
// if IsOk ( vehGuard ) then
5640: LD_EXP 21
5644: PPUSH
5645: CALL_OW 302
5649: IFFALSE 5685
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
5651: LD_VAR 0 1
5655: PPUSH
5656: LD_INT 22
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PPUSH
5666: CALL_OW 69
5670: PPUSH
5671: LD_VAR 0 1
5675: PPUSH
5676: CALL_OW 74
5680: PPUSH
5681: CALL_OW 115
5685: GO 5637
5687: POP
5688: POP
// end ;
5689: PPOPN 1
5691: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
5692: LD_EXP 4
5696: PUSH
5697: LD_INT 43
5699: PPUSH
5700: CALL_OW 302
5704: AND
5705: PUSH
5706: LD_EXP 7
5710: NOT
5711: AND
5712: IFFALSE 5760
5714: GO 5716
5716: DISABLE
// begin enable ;
5717: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
5718: LD_INT 43
5720: PPUSH
5721: LD_INT 5
5723: PPUSH
5724: LD_INT 3
5726: PPUSH
5727: LD_INT 2
5729: PPUSH
5730: LD_INT 7
5732: PUSH
5733: LD_INT 7
5735: PUSH
5736: LD_INT 9
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 1
5746: PPUSH
5747: LD_INT 3
5749: PPUSH
5750: CALL_OW 12
5754: ARRAY
5755: PPUSH
5756: CALL_OW 125
// end ;
5760: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
5761: LD_INT 22
5763: PUSH
5764: LD_INT 1
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PUSH
5771: LD_INT 25
5773: PUSH
5774: LD_INT 5
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PUSH
5781: LD_INT 50
5783: PUSH
5784: EMPTY
5785: LIST
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: PPUSH
5792: CALL_OW 69
5796: PUSH
5797: LD_EXP 7
5801: NOT
5802: AND
5803: IFFALSE 6032
5805: GO 5807
5807: DISABLE
5808: LD_INT 0
5810: PPUSH
5811: PPUSH
// begin enable ;
5812: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
5813: LD_ADDR_VAR 0 1
5817: PUSH
5818: LD_INT 22
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PUSH
5828: LD_INT 25
5830: PUSH
5831: LD_INT 5
5833: PUSH
5834: EMPTY
5835: LIST
5836: LIST
5837: PUSH
5838: LD_INT 50
5840: PUSH
5841: EMPTY
5842: LIST
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PPUSH
5849: CALL_OW 69
5853: ST_TO_ADDR
// if not tmp then
5854: LD_VAR 0 1
5858: NOT
5859: IFFALSE 5863
// exit ;
5861: GO 6032
// b := IsInUnit ( tmp [ 1 ] ) ;
5863: LD_ADDR_VAR 0 2
5867: PUSH
5868: LD_VAR 0 1
5872: PUSH
5873: LD_INT 1
5875: ARRAY
5876: PPUSH
5877: CALL_OW 310
5881: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
5882: LD_VAR 0 2
5886: NOT
5887: PUSH
5888: LD_VAR 0 1
5892: PUSH
5893: LD_INT 1
5895: ARRAY
5896: PPUSH
5897: CALL_OW 314
5901: OR
5902: IFFALSE 5906
// exit ;
5904: GO 6032
// if b = us_bun1 then
5906: LD_VAR 0 2
5910: PUSH
5911: LD_INT 80
5913: EQUAL
5914: IFFALSE 5975
// begin ComExitBuilding ( tmp [ 1 ] ) ;
5916: LD_VAR 0 1
5920: PUSH
5921: LD_INT 1
5923: ARRAY
5924: PPUSH
5925: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
5929: LD_VAR 0 1
5933: PUSH
5934: LD_INT 1
5936: ARRAY
5937: PPUSH
5938: LD_INT 27
5940: PPUSH
5941: LD_INT 44
5943: PPUSH
5944: CALL_OW 174
// if IsOk ( us_bun2 ) then
5948: LD_INT 55
5950: PPUSH
5951: CALL_OW 302
5955: IFFALSE 5973
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
5957: LD_VAR 0 1
5961: PUSH
5962: LD_INT 1
5964: ARRAY
5965: PPUSH
5966: LD_INT 55
5968: PPUSH
5969: CALL_OW 180
// end else
5973: GO 6032
// begin ComExitBuilding ( tmp [ 1 ] ) ;
5975: LD_VAR 0 1
5979: PUSH
5980: LD_INT 1
5982: ARRAY
5983: PPUSH
5984: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
5988: LD_VAR 0 1
5992: PUSH
5993: LD_INT 1
5995: ARRAY
5996: PPUSH
5997: LD_INT 92
5999: PPUSH
6000: LD_INT 51
6002: PPUSH
6003: CALL_OW 174
// if IsOk ( us_bun1 ) then
6007: LD_INT 80
6009: PPUSH
6010: CALL_OW 302
6014: IFFALSE 6032
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6016: LD_VAR 0 1
6020: PUSH
6021: LD_INT 1
6023: ARRAY
6024: PPUSH
6025: LD_INT 80
6027: PPUSH
6028: CALL_OW 180
// end ; end ;
6032: PPOPN 2
6034: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6035: LD_EXP 7
6039: NOT
6040: PUSH
6041: LD_INT 9
6043: PPUSH
6044: LD_INT 22
6046: PUSH
6047: LD_INT 1
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PUSH
6054: LD_INT 21
6056: PUSH
6057: LD_INT 3
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: PUSH
6064: LD_INT 3
6066: PUSH
6067: LD_INT 24
6069: PUSH
6070: LD_INT 1000
6072: PUSH
6073: EMPTY
6074: LIST
6075: LIST
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 70
6090: AND
6091: IFFALSE 6502
6093: GO 6095
6095: DISABLE
6096: LD_INT 0
6098: PPUSH
6099: PPUSH
6100: PPUSH
6101: PPUSH
// begin enable ;
6102: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6103: LD_ADDR_VAR 0 2
6107: PUSH
6108: LD_INT 22
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 25
6120: PUSH
6121: LD_INT 2
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 24
6130: PUSH
6131: LD_INT 1000
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: PPUSH
6143: CALL_OW 69
6147: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6148: LD_ADDR_VAR 0 3
6152: PUSH
6153: LD_INT 22
6155: PUSH
6156: LD_INT 1
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 25
6165: PUSH
6166: LD_INT 2
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PUSH
6173: LD_INT 3
6175: PUSH
6176: LD_INT 24
6178: PUSH
6179: LD_INT 750
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 69
6199: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6200: LD_ADDR_VAR 0 4
6204: PUSH
6205: LD_INT 9
6207: PPUSH
6208: LD_INT 22
6210: PUSH
6211: LD_INT 1
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: PUSH
6218: LD_INT 21
6220: PUSH
6221: LD_INT 3
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 3
6230: PUSH
6231: LD_INT 24
6233: PUSH
6234: LD_INT 1000
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: PPUSH
6250: CALL_OW 70
6254: PUSH
6255: LD_INT 1
6257: DIFF
6258: ST_TO_ADDR
// if not tmp and not tmp2 then
6259: LD_VAR 0 2
6263: NOT
6264: PUSH
6265: LD_VAR 0 3
6269: NOT
6270: AND
6271: IFFALSE 6275
// exit ;
6273: GO 6502
// if tmp and b then
6275: LD_VAR 0 2
6279: PUSH
6280: LD_VAR 0 4
6284: AND
6285: IFFALSE 6415
// for i in tmp do
6287: LD_ADDR_VAR 0 1
6291: PUSH
6292: LD_VAR 0 2
6296: PUSH
6297: FOR_IN
6298: IFFALSE 6413
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6300: LD_VAR 0 1
6304: PPUSH
6305: CALL_OW 110
6309: PUSH
6310: LD_INT 1
6312: EQUAL
6313: PUSH
6314: LD_VAR 0 1
6318: PPUSH
6319: CALL_OW 256
6323: PUSH
6324: LD_INT 1000
6326: LESS
6327: AND
6328: IFFALSE 6334
// continue else
6330: GO 6297
6332: GO 6361
// if GetTag ( i ) = 1 then
6334: LD_VAR 0 1
6338: PPUSH
6339: CALL_OW 110
6343: PUSH
6344: LD_INT 1
6346: EQUAL
6347: IFFALSE 6361
// SetTag ( i , 0 ) ;
6349: LD_VAR 0 1
6353: PPUSH
6354: LD_INT 0
6356: PPUSH
6357: CALL_OW 109
// if IsInUnit ( i ) then
6361: LD_VAR 0 1
6365: PPUSH
6366: CALL_OW 310
6370: IFFALSE 6381
// ComExitBuilding ( i ) ;
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 122
// if not HasTask ( i ) then
6381: LD_VAR 0 1
6385: PPUSH
6386: CALL_OW 314
6390: NOT
6391: IFFALSE 6411
// AddComRepairBuilding ( i , b [ 1 ] ) ;
6393: LD_VAR 0 1
6397: PPUSH
6398: LD_VAR 0 4
6402: PUSH
6403: LD_INT 1
6405: ARRAY
6406: PPUSH
6407: CALL_OW 190
// end ;
6411: GO 6297
6413: POP
6414: POP
// if tmp2 then
6415: LD_VAR 0 3
6419: IFFALSE 6502
// for i in tmp2 do
6421: LD_ADDR_VAR 0 1
6425: PUSH
6426: LD_VAR 0 3
6430: PUSH
6431: FOR_IN
6432: IFFALSE 6500
// begin if not GetTag ( i ) = 1 then
6434: LD_VAR 0 1
6438: PPUSH
6439: CALL_OW 110
6443: PUSH
6444: LD_INT 1
6446: EQUAL
6447: NOT
6448: IFFALSE 6462
// SetTag ( i , 1 ) ;
6450: LD_VAR 0 1
6454: PPUSH
6455: LD_INT 1
6457: PPUSH
6458: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
6462: LD_VAR 0 1
6466: PPUSH
6467: LD_INT 88
6469: PPUSH
6470: LD_INT 75
6472: PPUSH
6473: CALL_OW 297
6477: PUSH
6478: LD_INT 6
6480: GREATER
6481: IFFALSE 6498
// ComMoveXY ( i , 88 , 75 ) ;
6483: LD_VAR 0 1
6487: PPUSH
6488: LD_INT 88
6490: PPUSH
6491: LD_INT 75
6493: PPUSH
6494: CALL_OW 111
// end ;
6498: GO 6431
6500: POP
6501: POP
// end ;
6502: PPOPN 4
6504: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
6505: LD_EXP 7
6509: NOT
6510: PUSH
6511: LD_EXP 9
6515: AND
6516: PUSH
6517: LD_INT 9
6519: PPUSH
6520: LD_INT 22
6522: PUSH
6523: LD_INT 1
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 21
6532: PUSH
6533: LD_INT 1
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: PUSH
6540: LD_INT 3
6542: PUSH
6543: LD_INT 24
6545: PUSH
6546: LD_INT 1000
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: PPUSH
6562: CALL_OW 70
6566: AND
6567: IFFALSE 6740
6569: GO 6571
6571: DISABLE
6572: LD_INT 0
6574: PPUSH
6575: PPUSH
6576: PPUSH
// begin enable ;
6577: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
6578: LD_ADDR_VAR 0 2
6582: PUSH
6583: LD_INT 22
6585: PUSH
6586: LD_INT 1
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PUSH
6593: LD_INT 25
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PPUSH
6607: CALL_OW 69
6611: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6612: LD_ADDR_VAR 0 3
6616: PUSH
6617: LD_INT 9
6619: PPUSH
6620: LD_INT 22
6622: PUSH
6623: LD_INT 1
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: LD_INT 21
6632: PUSH
6633: LD_INT 1
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: LD_INT 3
6642: PUSH
6643: LD_INT 24
6645: PUSH
6646: LD_INT 1000
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: PPUSH
6662: CALL_OW 70
6666: ST_TO_ADDR
// if not sci or not tmp then
6667: LD_VAR 0 2
6671: NOT
6672: PUSH
6673: LD_VAR 0 3
6677: NOT
6678: OR
6679: IFFALSE 6683
// exit ;
6681: GO 6740
// for i in sci do
6683: LD_ADDR_VAR 0 1
6687: PUSH
6688: LD_VAR 0 2
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6738
// if IsInUnit ( i ) then
6696: LD_VAR 0 1
6700: PPUSH
6701: CALL_OW 310
6705: IFFALSE 6718
// ComExitBuilding ( i ) else
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 122
6716: GO 6736
// ComHeal ( i , tmp [ 1 ] ) ;
6718: LD_VAR 0 1
6722: PPUSH
6723: LD_VAR 0 3
6727: PUSH
6728: LD_INT 1
6730: ARRAY
6731: PPUSH
6732: CALL_OW 128
6736: GO 6693
6738: POP
6739: POP
// end ;
6740: PPOPN 3
6742: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
6743: LD_EXP 7
6747: NOT
6748: PUSH
6749: LD_EXP 9
6753: AND
6754: PUSH
6755: LD_INT 1
6757: PPUSH
6758: CALL_OW 302
6762: AND
6763: PUSH
6764: LD_INT 9
6766: PPUSH
6767: LD_INT 22
6769: PUSH
6770: LD_INT 1
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 21
6779: PUSH
6780: LD_INT 1
6782: PUSH
6783: EMPTY
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 3
6789: PUSH
6790: LD_INT 24
6792: PUSH
6793: LD_INT 1000
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: PPUSH
6809: CALL_OW 70
6813: NOT
6814: AND
6815: PUSH
6816: LD_INT 22
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 25
6828: PUSH
6829: LD_INT 4
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: PUSH
6836: LD_INT 56
6838: PUSH
6839: EMPTY
6840: LIST
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: LIST
6846: PPUSH
6847: CALL_OW 69
6851: AND
6852: IFFALSE 6945
6854: GO 6856
6856: DISABLE
6857: LD_INT 0
6859: PPUSH
// begin enable ;
6860: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
6861: LD_ADDR_VAR 0 1
6865: PUSH
6866: LD_INT 22
6868: PUSH
6869: LD_INT 1
6871: PUSH
6872: EMPTY
6873: LIST
6874: LIST
6875: PUSH
6876: LD_INT 25
6878: PUSH
6879: LD_INT 4
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: PUSH
6886: LD_INT 56
6888: PUSH
6889: EMPTY
6890: LIST
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: PPUSH
6897: CALL_OW 69
6901: PUSH
6902: FOR_IN
6903: IFFALSE 6943
// if not GetTag ( i ) and not HasTask ( i ) then
6905: LD_VAR 0 1
6909: PPUSH
6910: CALL_OW 110
6914: NOT
6915: PUSH
6916: LD_VAR 0 1
6920: PPUSH
6921: CALL_OW 314
6925: NOT
6926: AND
6927: IFFALSE 6941
// ComEnterUnit ( i , us_lab ) ;
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_INT 1
6936: PPUSH
6937: CALL_OW 120
6941: GO 6902
6943: POP
6944: POP
// end ;
6945: PPOPN 1
6947: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
6948: LD_EXP 7
6952: NOT
6953: PUSH
6954: LD_INT 9
6956: PPUSH
6957: LD_INT 22
6959: PUSH
6960: LD_INT 1
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PUSH
6967: LD_INT 21
6969: PUSH
6970: LD_INT 3
6972: PUSH
6973: EMPTY
6974: LIST
6975: LIST
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: LD_INT 24
6982: PUSH
6983: LD_INT 1000
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: PPUSH
6999: CALL_OW 70
7003: NOT
7004: AND
7005: PUSH
7006: LD_INT 22
7008: PUSH
7009: LD_INT 1
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PUSH
7016: LD_INT 25
7018: PUSH
7019: LD_INT 2
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 56
7028: PUSH
7029: EMPTY
7030: LIST
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: LIST
7036: PPUSH
7037: CALL_OW 69
7041: AND
7042: IFFALSE 7135
7044: GO 7046
7046: DISABLE
7047: LD_INT 0
7049: PPUSH
// begin enable ;
7050: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7051: LD_ADDR_VAR 0 1
7055: PUSH
7056: LD_INT 22
7058: PUSH
7059: LD_INT 1
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: LD_INT 25
7068: PUSH
7069: LD_INT 2
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 56
7078: PUSH
7079: EMPTY
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: PPUSH
7087: CALL_OW 69
7091: PUSH
7092: FOR_IN
7093: IFFALSE 7133
// if not HasTask ( i ) and not GetTag ( i ) then
7095: LD_VAR 0 1
7099: PPUSH
7100: CALL_OW 314
7104: NOT
7105: PUSH
7106: LD_VAR 0 1
7110: PPUSH
7111: CALL_OW 110
7115: NOT
7116: AND
7117: IFFALSE 7131
// ComEnterUnit ( i , us_depot ) ;
7119: LD_VAR 0 1
7123: PPUSH
7124: LD_INT 5
7126: PPUSH
7127: CALL_OW 120
7131: GO 7092
7133: POP
7134: POP
// end ;
7135: PPOPN 1
7137: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
7138: LD_EXP 9
7142: PUSH
7143: LD_INT 0
7145: LESSEQUAL
7146: PUSH
7147: LD_EXP 16
7151: PPUSH
7152: CALL_OW 301
7156: OR
7157: PUSH
7158: LD_INT 22
7160: PUSH
7161: LD_INT 1
7163: PUSH
7164: EMPTY
7165: LIST
7166: LIST
7167: PUSH
7168: LD_INT 25
7170: PUSH
7171: LD_INT 4
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: PPUSH
7182: CALL_OW 69
7186: AND
7187: IFFALSE 7228
7189: GO 7191
7191: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) , us_lab ) ;
7192: LD_INT 22
7194: PUSH
7195: LD_INT 1
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: LD_INT 25
7204: PUSH
7205: LD_INT 4
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PPUSH
7216: CALL_OW 69
7220: PPUSH
7221: LD_INT 1
7223: PPUSH
7224: CALL_OW 167
7228: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7229: LD_EXP 7
7233: NOT
7234: PUSH
7235: LD_INT 7
7237: PPUSH
7238: LD_INT 22
7240: PUSH
7241: LD_INT 7
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: PPUSH
7248: CALL_OW 70
7252: AND
7253: IFFALSE 7344
7255: GO 7257
7257: DISABLE
7258: LD_INT 0
7260: PPUSH
// begin wait ( 0 0$2 ) ;
7261: LD_INT 70
7263: PPUSH
7264: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7268: LD_ADDR_VAR 0 1
7272: PUSH
7273: LD_INT 22
7275: PUSH
7276: LD_INT 1
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: LD_INT 25
7285: PUSH
7286: LD_INT 1
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PPUSH
7297: CALL_OW 69
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7342
// begin if IsInUnit ( i ) then
7305: LD_VAR 0 1
7309: PPUSH
7310: CALL_OW 310
7314: IFFALSE 7325
// ComExitBuilding ( i ) ;
7316: LD_VAR 0 1
7320: PPUSH
7321: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7325: LD_VAR 0 1
7329: PPUSH
7330: LD_INT 92
7332: PPUSH
7333: LD_INT 78
7335: PPUSH
7336: CALL_OW 174
// end ;
7340: GO 7302
7342: POP
7343: POP
// end ; end_of_file
7344: PPOPN 1
7346: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7347: LD_VAR 0 1
7351: PPUSH
7352: LD_VAR 0 2
7356: PPUSH
7357: LD_VAR 0 3
7361: PPUSH
7362: CALL 2779 0 3
7366: PPOPN 3
7368: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7369: LD_EXP 12
7373: PPUSH
7374: CALL_OW 257
7378: PUSH
7379: LD_INT 4
7381: EQUAL
7382: PUSH
7383: LD_EXP 13
7387: PPUSH
7388: CALL_OW 257
7392: PUSH
7393: LD_INT 4
7395: EQUAL
7396: OR
7397: IFFALSE 7401
// exit ;
7399: GO 7439
// if un = JMM then
7401: LD_VAR 0 1
7405: PUSH
7406: LD_EXP 12
7410: EQUAL
7411: IFFALSE 7420
// YouLost ( JMM ) ;
7413: LD_STRING JMM
7415: PPUSH
7416: CALL_OW 104
// if un = Burlak then
7420: LD_VAR 0 1
7424: PUSH
7425: LD_EXP 13
7429: EQUAL
7430: IFFALSE 7439
// YouLost ( Burlak ) ;
7432: LD_STRING Burlak
7434: PPUSH
7435: CALL_OW 104
// end ;
7439: PPOPN 1
7441: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7442: LD_VAR 0 1
7446: PUSH
7447: LD_EXP 12
7451: EQUAL
7452: IFFALSE 7461
// YouLost ( JMM ) ;
7454: LD_STRING JMM
7456: PPUSH
7457: CALL_OW 104
// if un = Burlak then
7461: LD_VAR 0 1
7465: PUSH
7466: LD_EXP 13
7470: EQUAL
7471: IFFALSE 7480
// YouLost ( Burlak ) ;
7473: LD_STRING Burlak
7475: PPUSH
7476: CALL_OW 104
// end ;
7480: PPOPN 1
7482: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
7483: LD_VAR 0 1
7487: PPUSH
7488: CALL_OW 255
7492: PUSH
7493: LD_INT 7
7495: EQUAL
7496: IFFALSE 7506
// artifactPickedUp := true ;
7498: LD_ADDR_EXP 6
7502: PUSH
7503: LD_INT 1
7505: ST_TO_ADDR
// end ;
7506: PPOPN 2
7508: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
7509: LD_ADDR_EXP 6
7513: PUSH
7514: LD_INT 0
7516: ST_TO_ADDR
7517: PPOPN 2
7519: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
7520: LD_VAR 0 1
7524: PPUSH
7525: CALL_OW 255
7529: PUSH
7530: LD_INT 1
7532: NONEQUAL
7533: IFFALSE 7537
// exit ;
7535: GO 7584
// wait ( 0 0$5 ) ;
7537: LD_INT 175
7539: PPUSH
7540: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
7544: LD_VAR 0 1
7548: PPUSH
7549: CALL_OW 263
7553: PUSH
7554: LD_INT 2
7556: EQUAL
7557: IFFALSE 7568
// Connect ( vehicle ) ;
7559: LD_VAR 0 1
7563: PPUSH
7564: CALL 1780 0 1
// vehGuard := vehGuard ^ vehicle ;
7568: LD_ADDR_EXP 21
7572: PUSH
7573: LD_EXP 21
7577: PUSH
7578: LD_VAR 0 1
7582: ADD
7583: ST_TO_ADDR
// end ; end_of_file
7584: PPOPN 2
7586: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7587: GO 7589
7589: DISABLE
// begin ru_radar := 98 ;
7590: LD_ADDR_EXP 22
7594: PUSH
7595: LD_INT 98
7597: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7598: LD_ADDR_EXP 23
7602: PUSH
7603: LD_INT 89
7605: ST_TO_ADDR
// us_hack := 99 ;
7606: LD_ADDR_EXP 24
7610: PUSH
7611: LD_INT 99
7613: ST_TO_ADDR
// us_artillery := 97 ;
7614: LD_ADDR_EXP 25
7618: PUSH
7619: LD_INT 97
7621: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7622: LD_ADDR_EXP 26
7626: PUSH
7627: LD_INT 91
7629: ST_TO_ADDR
// end ;
7630: END
