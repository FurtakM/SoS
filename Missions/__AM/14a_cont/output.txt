// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 992 0 9
// PrepareAmerican ;
  46: CALL 5180 0 0
// PrepareAlliance ;
  50: CALL 189 0 0
// Action ;
  54: CALL 2141 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 11 11$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 23100
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
// uc_side := 7 ;
 198: LD_ADDR_OWVAR 20
 202: PUSH
 203: LD_INT 7
 205: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 206: LD_ADDR_EXP 12
 210: PUSH
 211: LD_STRING JMM
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 14a_
 222: PPUSH
 223: CALL 871 0 3
 227: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 228: LD_ADDR_EXP 13
 232: PUSH
 233: LD_STRING Burlak
 235: PPUSH
 236: LD_EXP 1
 240: NOT
 241: PPUSH
 242: LD_STRING 14a_
 244: PPUSH
 245: CALL 871 0 3
 249: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 250: LD_ADDR_EXP 14
 254: PUSH
 255: LD_STRING Joan
 257: PPUSH
 258: LD_EXP 1
 262: NOT
 263: PPUSH
 264: LD_STRING 13a_
 266: PPUSH
 267: CALL 871 0 3
 271: ST_TO_ADDR
// if not Joan then
 272: LD_EXP 14
 276: NOT
 277: IFFALSE 410
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 279: LD_ADDR_VAR 0 2
 283: PUSH
 284: LD_STRING 13a_others
 286: PPUSH
 287: CALL_OW 31
 291: ST_TO_ADDR
// if tmp then
 292: LD_VAR 0 2
 296: IFFALSE 372
// begin for i in tmp do
 298: LD_ADDR_VAR 0 3
 302: PUSH
 303: LD_VAR 0 2
 307: PUSH
 308: FOR_IN
 309: IFFALSE 370
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 311: LD_VAR 0 3
 315: PPUSH
 316: CALL_OW 257
 320: PUSH
 321: LD_INT 4
 323: EQUAL
 324: PUSH
 325: LD_VAR 0 3
 329: PPUSH
 330: CALL_OW 258
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: PUSH
 340: LD_VAR 0 3
 344: PPUSH
 345: CALL_OW 248
 349: PUSH
 350: LD_INT 3
 352: EQUAL
 353: AND
 354: IFFALSE 368
// begin RuSci := i ;
 356: LD_ADDR_EXP 15
 360: PUSH
 361: LD_VAR 0 3
 365: ST_TO_ADDR
// break ;
 366: GO 370
// end ;
 368: GO 308
 370: POP
 371: POP
// end ; if not RuSci then
 372: LD_EXP 15
 376: NOT
 377: IFFALSE 410
// begin uc_nation := 3 ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 10
 395: PPUSH
 396: CALL_OW 380
// RuSci := CreateHuman ;
 400: LD_ADDR_EXP 15
 404: PUSH
 405: CALL_OW 44
 409: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 410: LD_ADDR_VAR 0 6
 414: PUSH
 415: LD_STRING 14a_JMMVeh
 417: PPUSH
 418: LD_INT 5
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 1
 426: PUSH
 427: LD_INT 7
 429: PUSH
 430: LD_INT 0
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: PPUSH
 444: CALL_OW 30
 448: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 449: LD_ADDR_VAR 0 7
 453: PUSH
 454: LD_STRING 14a_BurlakVeh
 456: PPUSH
 457: LD_INT 22
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 51
 468: PUSH
 469: LD_INT 0
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 30
 487: ST_TO_ADDR
// uc_direction := 4 ;
 488: LD_ADDR_OWVAR 24
 492: PUSH
 493: LD_INT 4
 495: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 496: LD_ADDR_OWVAR 21
 500: PUSH
 501: LD_VAR 0 6
 505: PUSH
 506: LD_INT 6
 508: ARRAY
 509: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 510: LD_VAR 0 6
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 2
 526: ARRAY
 527: PPUSH
 528: LD_VAR 0 6
 532: PUSH
 533: LD_INT 3
 535: ARRAY
 536: PPUSH
 537: LD_VAR 0 6
 541: PUSH
 542: LD_INT 4
 544: ARRAY
 545: PPUSH
 546: LD_INT 60
 548: PPUSH
 549: LD_INT 80
 551: PPUSH
 552: CALL_OW 12
 556: PPUSH
 557: CALL 934 0 5
// JMMVeh := CreateVehicle ;
 561: LD_ADDR_VAR 0 4
 565: PUSH
 566: CALL_OW 45
 570: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 571: LD_VAR 0 4
 575: PPUSH
 576: LD_INT 1
 578: PPUSH
 579: LD_INT 0
 581: PPUSH
 582: CALL 1596 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 586: LD_VAR 0 6
 590: PUSH
 591: LD_INT 5
 593: ARRAY
 594: PUSH
 595: LD_INT 0
 597: NONEQUAL
 598: IFFALSE 618
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_VAR 0 6
 609: PUSH
 610: LD_INT 5
 612: ARRAY
 613: PPUSH
 614: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 618: LD_EXP 12
 622: PPUSH
 623: LD_VAR 0 4
 627: PPUSH
 628: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 632: LD_ADDR_OWVAR 21
 636: PUSH
 637: LD_VAR 0 7
 641: PUSH
 642: LD_INT 6
 644: ARRAY
 645: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 646: LD_VAR 0 7
 650: PUSH
 651: LD_INT 1
 653: ARRAY
 654: PPUSH
 655: LD_VAR 0 7
 659: PUSH
 660: LD_INT 2
 662: ARRAY
 663: PPUSH
 664: LD_VAR 0 7
 668: PUSH
 669: LD_INT 3
 671: ARRAY
 672: PPUSH
 673: LD_VAR 0 7
 677: PUSH
 678: LD_INT 4
 680: ARRAY
 681: PPUSH
 682: LD_INT 60
 684: PPUSH
 685: LD_INT 80
 687: PPUSH
 688: CALL_OW 12
 692: PPUSH
 693: CALL 934 0 5
// BurlakVeh := CreateVehicle ;
 697: LD_ADDR_VAR 0 5
 701: PUSH
 702: CALL_OW 45
 706: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 707: LD_VAR 0 5
 711: PPUSH
 712: LD_INT 1
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL 1596 0 3
 722: NOT
 723: IFFALSE 743
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 725: LD_VAR 0 5
 729: PPUSH
 730: LD_INT 233
 732: PPUSH
 733: LD_INT 85
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 743: LD_VAR 0 7
 747: PUSH
 748: LD_INT 5
 750: ARRAY
 751: PUSH
 752: LD_INT 0
 754: NONEQUAL
 755: IFFALSE 775
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 757: LD_VAR 0 5
 761: PPUSH
 762: LD_VAR 0 7
 766: PUSH
 767: LD_INT 5
 769: ARRAY
 770: PPUSH
 771: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 775: LD_EXP 13
 779: PPUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 178
 796: PUSH
 797: LD_INT 91
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: PUSH
 804: LD_INT 137
 806: PUSH
 807: LD_INT 83
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 157
 816: PUSH
 817: LD_INT 75
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: LIST
 828: PUSH
 829: LD_OWVAR 67
 833: ARRAY
 834: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 835: LD_INT 4
 837: PPUSH
 838: LD_INT 4
 840: PPUSH
 841: LD_VAR 0 2
 845: PUSH
 846: LD_INT 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 2
 854: PUSH
 855: LD_INT 2
 857: ARRAY
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 58
// end ; end_of_file
 866: LD_VAR 0 1
 870: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 871: LD_INT 0
 873: PPUSH
 874: PPUSH
// if exist_mode then
 875: LD_VAR 0 2
 879: IFFALSE 904
// unit := CreateCharacter ( prefix & ident ) else
 881: LD_ADDR_VAR 0 5
 885: PUSH
 886: LD_VAR 0 3
 890: PUSH
 891: LD_VAR 0 1
 895: STR
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
 902: GO 919
// unit := NewCharacter ( ident ) ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 25
 918: ST_TO_ADDR
// result := unit ;
 919: LD_ADDR_VAR 0 4
 923: PUSH
 924: LD_VAR 0 5
 928: ST_TO_ADDR
// end ;
 929: LD_VAR 0 4
 933: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 934: LD_INT 0
 936: PPUSH
// vc_chassis := chassis ;
 937: LD_ADDR_OWVAR 37
 941: PUSH
 942: LD_VAR 0 1
 946: ST_TO_ADDR
// vc_engine := engine ;
 947: LD_ADDR_OWVAR 39
 951: PUSH
 952: LD_VAR 0 2
 956: ST_TO_ADDR
// vc_control := control ;
 957: LD_ADDR_OWVAR 38
 961: PUSH
 962: LD_VAR 0 3
 966: ST_TO_ADDR
// vc_weapon := weapon ;
 967: LD_ADDR_OWVAR 40
 971: PUSH
 972: LD_VAR 0 4
 976: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 977: LD_ADDR_OWVAR 41
 981: PUSH
 982: LD_VAR 0 5
 986: ST_TO_ADDR
// end ;
 987: LD_VAR 0 6
 991: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
// uc_side = 0 ;
 997: LD_ADDR_OWVAR 20
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// uc_nation = 0 ;
1005: LD_ADDR_OWVAR 21
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// InitHc ;
1013: CALL_OW 19
// InitVc ;
1017: CALL_OW 20
// if mastodonts then
1021: LD_VAR 0 6
1025: IFFALSE 1092
// for i = 1 to mastodonts do
1027: LD_ADDR_VAR 0 11
1031: PUSH
1032: DOUBLE
1033: LD_INT 1
1035: DEC
1036: ST_TO_ADDR
1037: LD_VAR 0 6
1041: PUSH
1042: FOR_TO
1043: IFFALSE 1090
// begin vc_chassis := 31 ;
1045: LD_ADDR_OWVAR 37
1049: PUSH
1050: LD_INT 31
1052: ST_TO_ADDR
// vc_control := control_rider ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_INT 4
1060: ST_TO_ADDR
// animal := CreateVehicle ;
1061: LD_ADDR_VAR 0 12
1065: PUSH
1066: CALL_OW 45
1070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1071: LD_VAR 0 12
1075: PPUSH
1076: LD_VAR 0 8
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL 1596 0 3
// end ;
1088: GO 1042
1090: POP
1091: POP
// if horses then
1092: LD_VAR 0 5
1096: IFFALSE 1163
// for i = 1 to horses do
1098: LD_ADDR_VAR 0 11
1102: PUSH
1103: DOUBLE
1104: LD_INT 1
1106: DEC
1107: ST_TO_ADDR
1108: LD_VAR 0 5
1112: PUSH
1113: FOR_TO
1114: IFFALSE 1161
// begin hc_class := 21 ;
1116: LD_ADDR_OWVAR 28
1120: PUSH
1121: LD_INT 21
1123: ST_TO_ADDR
// hc_gallery :=  ;
1124: LD_ADDR_OWVAR 33
1128: PUSH
1129: LD_STRING 
1131: ST_TO_ADDR
// animal := CreateHuman ;
1132: LD_ADDR_VAR 0 12
1136: PUSH
1137: CALL_OW 44
1141: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1142: LD_VAR 0 12
1146: PPUSH
1147: LD_VAR 0 8
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL 1596 0 3
// end ;
1159: GO 1113
1161: POP
1162: POP
// if birds then
1163: LD_VAR 0 1
1167: IFFALSE 1234
// for i = 1 to birds do
1169: LD_ADDR_VAR 0 11
1173: PUSH
1174: DOUBLE
1175: LD_INT 1
1177: DEC
1178: ST_TO_ADDR
1179: LD_VAR 0 1
1183: PUSH
1184: FOR_TO
1185: IFFALSE 1232
// begin hc_class = 18 ;
1187: LD_ADDR_OWVAR 28
1191: PUSH
1192: LD_INT 18
1194: ST_TO_ADDR
// hc_gallery =  ;
1195: LD_ADDR_OWVAR 33
1199: PUSH
1200: LD_STRING 
1202: ST_TO_ADDR
// animal := CreateHuman ;
1203: LD_ADDR_VAR 0 12
1207: PUSH
1208: CALL_OW 44
1212: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1213: LD_VAR 0 12
1217: PPUSH
1218: LD_VAR 0 8
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL 1596 0 3
// end ;
1230: GO 1184
1232: POP
1233: POP
// if tigers then
1234: LD_VAR 0 2
1238: IFFALSE 1322
// for i = 1 to tigers do
1240: LD_ADDR_VAR 0 11
1244: PUSH
1245: DOUBLE
1246: LD_INT 1
1248: DEC
1249: ST_TO_ADDR
1250: LD_VAR 0 2
1254: PUSH
1255: FOR_TO
1256: IFFALSE 1320
// begin hc_class = class_tiger ;
1258: LD_ADDR_OWVAR 28
1262: PUSH
1263: LD_INT 14
1265: ST_TO_ADDR
// hc_gallery =  ;
1266: LD_ADDR_OWVAR 33
1270: PUSH
1271: LD_STRING 
1273: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1274: LD_ADDR_OWVAR 35
1278: PUSH
1279: LD_INT 7
1281: NEG
1282: PPUSH
1283: LD_INT 7
1285: PPUSH
1286: CALL_OW 12
1290: ST_TO_ADDR
// animal := CreateHuman ;
1291: LD_ADDR_VAR 0 12
1295: PUSH
1296: CALL_OW 44
1300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1301: LD_VAR 0 12
1305: PPUSH
1306: LD_VAR 0 8
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL 1596 0 3
// end ;
1318: GO 1255
1320: POP
1321: POP
// if apemans then
1322: LD_VAR 0 3
1326: IFFALSE 1449
// for i = 1 to apemans do
1328: LD_ADDR_VAR 0 11
1332: PUSH
1333: DOUBLE
1334: LD_INT 1
1336: DEC
1337: ST_TO_ADDR
1338: LD_VAR 0 3
1342: PUSH
1343: FOR_TO
1344: IFFALSE 1447
// begin hc_class = class_apeman ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 12
1353: ST_TO_ADDR
// hc_gallery =  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1362: LD_ADDR_OWVAR 35
1366: PUSH
1367: LD_INT 5
1369: NEG
1370: PPUSH
1371: LD_INT 5
1373: PPUSH
1374: CALL_OW 12
1378: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1379: LD_ADDR_OWVAR 31
1383: PUSH
1384: LD_INT 1
1386: PPUSH
1387: LD_INT 3
1389: PPUSH
1390: CALL_OW 12
1394: PUSH
1395: LD_INT 1
1397: PPUSH
1398: LD_INT 3
1400: PPUSH
1401: CALL_OW 12
1405: PUSH
1406: LD_INT 0
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: ST_TO_ADDR
// animal := CreateHuman ;
1418: LD_ADDR_VAR 0 12
1422: PUSH
1423: CALL_OW 44
1427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1428: LD_VAR 0 12
1432: PPUSH
1433: LD_VAR 0 8
1437: PPUSH
1438: LD_INT 0
1440: PPUSH
1441: CALL 1596 0 3
// end ;
1445: GO 1343
1447: POP
1448: POP
// if enchidnas then
1449: LD_VAR 0 4
1453: IFFALSE 1520
// for i = 1 to enchidnas do
1455: LD_ADDR_VAR 0 11
1459: PUSH
1460: DOUBLE
1461: LD_INT 1
1463: DEC
1464: ST_TO_ADDR
1465: LD_VAR 0 4
1469: PUSH
1470: FOR_TO
1471: IFFALSE 1518
// begin hc_class = 13 ;
1473: LD_ADDR_OWVAR 28
1477: PUSH
1478: LD_INT 13
1480: ST_TO_ADDR
// hc_gallery =  ;
1481: LD_ADDR_OWVAR 33
1485: PUSH
1486: LD_STRING 
1488: ST_TO_ADDR
// animal := CreateHuman ;
1489: LD_ADDR_VAR 0 12
1493: PUSH
1494: CALL_OW 44
1498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1499: LD_VAR 0 12
1503: PPUSH
1504: LD_VAR 0 8
1508: PPUSH
1509: LD_INT 0
1511: PPUSH
1512: CALL 1596 0 3
// end ;
1516: GO 1470
1518: POP
1519: POP
// if fishes then
1520: LD_VAR 0 7
1524: IFFALSE 1591
// for i = 1 to fishes do
1526: LD_ADDR_VAR 0 11
1530: PUSH
1531: DOUBLE
1532: LD_INT 1
1534: DEC
1535: ST_TO_ADDR
1536: LD_VAR 0 7
1540: PUSH
1541: FOR_TO
1542: IFFALSE 1589
// begin hc_class = 20 ;
1544: LD_ADDR_OWVAR 28
1548: PUSH
1549: LD_INT 20
1551: ST_TO_ADDR
// hc_gallery =  ;
1552: LD_ADDR_OWVAR 33
1556: PUSH
1557: LD_STRING 
1559: ST_TO_ADDR
// animal := CreateHuman ;
1560: LD_ADDR_VAR 0 12
1564: PUSH
1565: CALL_OW 44
1569: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1570: LD_VAR 0 12
1574: PPUSH
1575: LD_VAR 0 9
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL 1596 0 3
// end ;
1587: GO 1541
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 10
1595: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
// if not unit or not area then
1602: LD_VAR 0 1
1606: NOT
1607: PUSH
1608: LD_VAR 0 2
1612: NOT
1613: OR
1614: IFFALSE 1618
// exit ;
1616: GO 1782
// tmp := AreaToList ( area , i ) ;
1618: LD_ADDR_VAR 0 6
1622: PUSH
1623: LD_VAR 0 2
1627: PPUSH
1628: LD_VAR 0 5
1632: PPUSH
1633: CALL_OW 517
1637: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1638: LD_ADDR_VAR 0 5
1642: PUSH
1643: DOUBLE
1644: LD_INT 1
1646: DEC
1647: ST_TO_ADDR
1648: LD_VAR 0 6
1652: PUSH
1653: LD_INT 1
1655: ARRAY
1656: PUSH
1657: FOR_TO
1658: IFFALSE 1780
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1660: LD_ADDR_VAR 0 7
1664: PUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_INT 1
1672: ARRAY
1673: PUSH
1674: LD_VAR 0 5
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 6
1684: PUSH
1685: LD_INT 2
1687: ARRAY
1688: PUSH
1689: LD_VAR 0 5
1693: ARRAY
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1699: LD_VAR 0 7
1703: PUSH
1704: LD_INT 1
1706: ARRAY
1707: PPUSH
1708: LD_VAR 0 7
1712: PUSH
1713: LD_INT 2
1715: ARRAY
1716: PPUSH
1717: CALL_OW 428
1721: PUSH
1722: LD_INT 0
1724: EQUAL
1725: IFFALSE 1778
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1727: LD_VAR 0 1
1731: PPUSH
1732: LD_VAR 0 7
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_VAR 0 7
1745: PUSH
1746: LD_INT 2
1748: ARRAY
1749: PPUSH
1750: LD_VAR 0 3
1754: PPUSH
1755: CALL_OW 48
// result := IsPlaced ( unit ) ;
1759: LD_ADDR_VAR 0 4
1763: PUSH
1764: LD_VAR 0 1
1768: PPUSH
1769: CALL_OW 305
1773: ST_TO_ADDR
// exit ;
1774: POP
1775: POP
1776: GO 1782
// end ; end ;
1778: GO 1657
1780: POP
1781: POP
// end ;
1782: LD_VAR 0 4
1786: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
1791: PPUSH
1792: PPUSH
1793: PPUSH
1794: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1795: LD_VAR 0 1
1799: NOT
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 263
1810: PUSH
1811: LD_INT 2
1813: EQUAL
1814: NOT
1815: OR
1816: IFFALSE 1820
// exit ;
1818: GO 2136
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1820: LD_ADDR_VAR 0 6
1824: PUSH
1825: LD_INT 22
1827: PUSH
1828: LD_VAR 0 1
1832: PPUSH
1833: CALL_OW 255
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 2
1844: PUSH
1845: LD_INT 30
1847: PUSH
1848: LD_INT 36
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 34
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: PPUSH
1874: CALL_OW 69
1878: ST_TO_ADDR
// if not tmp then
1879: LD_VAR 0 6
1883: NOT
1884: IFFALSE 1888
// exit ;
1886: GO 2136
// result := [ ] ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: EMPTY
1894: ST_TO_ADDR
// for i in tmp do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: LD_VAR 0 6
1904: PUSH
1905: FOR_IN
1906: IFFALSE 1977
// begin t := UnitsInside ( i ) ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: LD_VAR 0 3
1917: PPUSH
1918: CALL_OW 313
1922: ST_TO_ADDR
// if t then
1923: LD_VAR 0 4
1927: IFFALSE 1975
// for j in t do
1929: LD_ADDR_VAR 0 7
1933: PUSH
1934: LD_VAR 0 4
1938: PUSH
1939: FOR_IN
1940: IFFALSE 1973
// result := Insert ( result , result + 1 , j ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_VAR 0 2
1956: PUSH
1957: LD_INT 1
1959: PLUS
1960: PPUSH
1961: LD_VAR 0 7
1965: PPUSH
1966: CALL_OW 2
1970: ST_TO_ADDR
1971: GO 1939
1973: POP
1974: POP
// end ;
1975: GO 1905
1977: POP
1978: POP
// if not result then
1979: LD_VAR 0 2
1983: NOT
1984: IFFALSE 1988
// exit ;
1986: GO 2136
// mech := result [ 1 ] ;
1988: LD_ADDR_VAR 0 5
1992: PUSH
1993: LD_VAR 0 2
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: ST_TO_ADDR
// if result > 1 then
2002: LD_VAR 0 2
2006: PUSH
2007: LD_INT 1
2009: GREATER
2010: IFFALSE 2122
// for i = 2 to result do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 2
2020: DEC
2021: ST_TO_ADDR
2022: LD_VAR 0 2
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2120
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2030: LD_ADDR_VAR 0 4
2034: PUSH
2035: LD_VAR 0 2
2039: PUSH
2040: LD_VAR 0 3
2044: ARRAY
2045: PPUSH
2046: LD_INT 3
2048: PPUSH
2049: CALL_OW 259
2053: PUSH
2054: LD_VAR 0 2
2058: PUSH
2059: LD_VAR 0 3
2063: ARRAY
2064: PPUSH
2065: CALL_OW 432
2069: MINUS
2070: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2071: LD_VAR 0 4
2075: PUSH
2076: LD_VAR 0 5
2080: PPUSH
2081: LD_INT 3
2083: PPUSH
2084: CALL_OW 259
2088: PUSH
2089: LD_VAR 0 5
2093: PPUSH
2094: CALL_OW 432
2098: MINUS
2099: GREATEREQUAL
2100: IFFALSE 2118
// mech := result [ i ] ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: ST_TO_ADDR
// end ;
2118: GO 2027
2120: POP
2121: POP
// ComLinkTo ( vehicle , mech ) ;
2122: LD_VAR 0 1
2126: PPUSH
2127: LD_VAR 0 5
2131: PPUSH
2132: CALL_OW 135
// end ; end_of_file
2136: LD_VAR 0 2
2140: RET
// export function Action ; begin
2141: LD_INT 0
2143: PPUSH
// InGameOn ;
2144: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2148: LD_INT 221
2150: PPUSH
2151: LD_INT 80
2153: PPUSH
2154: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2158: LD_EXP 12
2162: PUSH
2163: LD_EXP 13
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PPUSH
2172: LD_INT 217
2174: PPUSH
2175: LD_INT 79
2177: PPUSH
2178: CALL_OW 111
// wait ( 0 0$7 ) ;
2182: LD_INT 245
2184: PPUSH
2185: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2189: LD_EXP 12
2193: PUSH
2194: LD_EXP 13
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2207: LD_EXP 13
2211: PPUSH
2212: LD_STRING D2-Bur-1
2214: PPUSH
2215: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2219: LD_EXP 12
2223: PPUSH
2224: LD_STRING D2-JMM-1
2226: PPUSH
2227: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2231: LD_INT 18
2233: PPUSH
2234: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2238: LD_EXP 13
2242: PPUSH
2243: LD_EXP 12
2247: PPUSH
2248: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2252: LD_EXP 13
2256: PPUSH
2257: LD_STRING D2-Bur-2
2259: PPUSH
2260: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2264: LD_EXP 13
2268: PPUSH
2269: LD_INT 21
2271: PUSH
2272: LD_INT 2
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: PPUSH
2279: CALL_OW 69
2283: PPUSH
2284: LD_EXP 13
2288: PPUSH
2289: CALL_OW 74
2293: PPUSH
2294: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2298: LD_EXP 12
2302: PPUSH
2303: LD_INT 21
2305: PUSH
2306: LD_INT 2
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PPUSH
2313: CALL_OW 69
2317: PPUSH
2318: LD_EXP 12
2322: PPUSH
2323: CALL_OW 74
2327: PPUSH
2328: CALL_OW 120
// wait ( 0 0$1 ) ;
2332: LD_INT 35
2334: PPUSH
2335: CALL_OW 67
// InGameOff ;
2339: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2343: LD_STRING MArtPickup
2345: PPUSH
2346: CALL_OW 337
// end ;
2350: LD_VAR 0 1
2354: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2355: LD_EXP 20
2359: PPUSH
2360: LD_INT 101
2362: PUSH
2363: LD_INT 7
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: CALL_OW 72
2374: IFFALSE 2403
2376: GO 2378
2378: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2379: LD_EXP 13
2383: PPUSH
2384: LD_STRING D3-Bur-1
2386: PPUSH
2387: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2391: LD_EXP 12
2395: PPUSH
2396: LD_STRING D3-JMM-1
2398: PPUSH
2399: CALL_OW 88
// end ;
2403: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2404: LD_INT 5
2406: PPUSH
2407: LD_INT 22
2409: PUSH
2410: LD_INT 7
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PPUSH
2417: CALL_OW 70
2421: IFFALSE 2752
2423: GO 2425
2425: DISABLE
// begin wait ( 0 0$3 ) ;
2426: LD_INT 105
2428: PPUSH
2429: CALL_OW 67
// DialogueOn ;
2433: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2437: LD_EXP 12
2441: PPUSH
2442: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2446: LD_EXP 12
2450: PPUSH
2451: LD_STRING D3a-JMM-1
2453: PPUSH
2454: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2458: LD_EXP 13
2462: PPUSH
2463: LD_STRING D3a-Bur-1
2465: PPUSH
2466: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2470: LD_EXP 12
2474: PPUSH
2475: LD_STRING D3a-JMM-2
2477: PPUSH
2478: CALL_OW 88
// if Joan then
2482: LD_EXP 14
2486: IFFALSE 2502
// SayRadio ( Joan , D3a-Joan-2 ) else
2488: LD_EXP 14
2492: PPUSH
2493: LD_STRING D3a-Joan-2
2495: PPUSH
2496: CALL_OW 94
2500: GO 2514
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2502: LD_EXP 15
2506: PPUSH
2507: LD_STRING D3a-RSci1-2
2509: PPUSH
2510: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2514: LD_EXP 16
2518: PPUSH
2519: LD_STRING D3a-Huck-2
2521: PPUSH
2522: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2526: LD_EXP 17
2530: PPUSH
2531: LD_STRING D3a-Pow-2
2533: PPUSH
2534: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2538: LD_EXP 16
2542: PPUSH
2543: LD_STRING D3a-Huck-3
2545: PPUSH
2546: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2550: LD_EXP 17
2554: PPUSH
2555: LD_STRING D3a-Pow-3
2557: PPUSH
2558: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2562: LD_EXP 16
2566: PPUSH
2567: LD_STRING D3a-Huck-4
2569: PPUSH
2570: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2574: LD_EXP 12
2578: PPUSH
2579: LD_STRING D3a-JMM-4
2581: PPUSH
2582: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2586: LD_EXP 13
2590: PPUSH
2591: LD_STRING D3a-Bur-4
2593: PPUSH
2594: CALL_OW 88
// if Joan then
2598: LD_EXP 14
2602: IFFALSE 2618
// SayRadio ( Joan , D3a-Joan-4 ) else
2604: LD_EXP 14
2608: PPUSH
2609: LD_STRING D3a-Joan-4
2611: PPUSH
2612: CALL_OW 94
2616: GO 2630
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2618: LD_EXP 15
2622: PPUSH
2623: LD_STRING D3a-RSci1-4
2625: PPUSH
2626: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2630: LD_INT 133
2632: PPUSH
2633: LD_INT 43
2635: PPUSH
2636: LD_INT 7
2638: PPUSH
2639: LD_INT 10
2641: NEG
2642: PPUSH
2643: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2647: LD_INT 133
2649: PPUSH
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 7
2655: PPUSH
2656: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2660: LD_INT 133
2662: PPUSH
2663: LD_INT 43
2665: PPUSH
2666: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2677: LD_EXP 12
2681: PPUSH
2682: LD_STRING D3a-JMM-5
2684: PPUSH
2685: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2689: LD_EXP 13
2693: PPUSH
2694: LD_STRING D3a-Bur-5
2696: PPUSH
2697: CALL_OW 88
// DialogueOff ;
2701: CALL_OW 7
// seenBase := true ;
2705: LD_ADDR_EXP 8
2709: PUSH
2710: LD_INT 1
2712: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2713: LD_INT 525
2715: PUSH
2716: LD_INT 420
2718: PUSH
2719: LD_INT 315
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: PUSH
2727: LD_OWVAR 67
2731: ARRAY
2732: PPUSH
2733: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_INT 142
2744: PPUSH
2745: LD_INT 52
2747: PPUSH
2748: CALL_OW 116
// end ;
2752: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2753: LD_EXP 8
2757: NOT
2758: PUSH
2759: LD_EXP 4
2763: NOT
2764: AND
2765: IFFALSE 2785
2767: GO 2769
2769: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2770: LD_EXP 19
2774: PPUSH
2775: LD_INT 142
2777: PPUSH
2778: LD_INT 52
2780: PPUSH
2781: CALL_OW 116
2785: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2786: LD_INT 0
2788: PPUSH
2789: PPUSH
// contaminateTime := tick ;
2790: LD_ADDR_EXP 3
2794: PUSH
2795: LD_OWVAR 1
2799: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2800: LD_INT 175
2802: PPUSH
2803: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2807: LD_ADDR_VAR 0 5
2811: PUSH
2812: LD_INT 4
2814: PPUSH
2815: CALL_OW 469
2819: ST_TO_ADDR
// if art then
2820: LD_VAR 0 5
2824: IFFALSE 2863
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2826: LD_VAR 0 5
2830: PUSH
2831: LD_INT 1
2833: ARRAY
2834: PUSH
2835: LD_INT 157
2837: EQUAL
2838: PUSH
2839: LD_VAR 0 5
2843: PUSH
2844: LD_INT 2
2846: ARRAY
2847: PUSH
2848: LD_INT 75
2850: EQUAL
2851: AND
2852: IFFALSE 2863
// begin YouLost ( Artefact ) ;
2854: LD_STRING Artefact
2856: PPUSH
2857: CALL_OW 104
// exit ;
2861: GO 3015
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2863: LD_EXP 12
2867: PPUSH
2868: CALL_OW 302
2872: PUSH
2873: LD_EXP 13
2877: PPUSH
2878: CALL_OW 302
2882: AND
2883: IFFALSE 2960
// begin DialogueOn ;
2885: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2889: LD_EXP 12
2893: PPUSH
2894: LD_STRING D6a-JMM-1
2896: PPUSH
2897: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2901: LD_EXP 13
2905: PPUSH
2906: LD_STRING D6a-Bur-1
2908: PPUSH
2909: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2913: LD_EXP 12
2917: PPUSH
2918: LD_STRING D6c-JMM-1
2920: PPUSH
2921: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2925: LD_EXP 13
2929: PPUSH
2930: LD_STRING D6c-Bur-1
2932: PPUSH
2933: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2937: LD_EXP 12
2941: PPUSH
2942: LD_STRING D6c-JMM-2
2944: PPUSH
2945: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2949: LD_STRING MBase
2951: PPUSH
2952: CALL_OW 337
// DialogueOff ;
2956: CALL_OW 7
// end ; bombExploded := true ;
2960: LD_ADDR_EXP 4
2964: PUSH
2965: LD_INT 1
2967: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
2968: LD_INT 6300
2970: PUSH
2971: LD_INT 5250
2973: PUSH
2974: LD_INT 4200
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PUSH
2982: LD_OWVAR 67
2986: ARRAY
2987: PPUSH
2988: CALL_OW 67
// if IsOk ( JMM ) then
2992: LD_EXP 12
2996: PPUSH
2997: CALL_OW 302
3001: IFFALSE 3015
// Say ( JMM , D8-JMM-1 ) ;
3003: LD_EXP 12
3007: PPUSH
3008: LD_STRING D8-JMM-1
3010: PPUSH
3011: CALL_OW 88
// end ;
3015: LD_VAR 0 4
3019: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3020: LD_EXP 9
3024: PUSH
3025: LD_EXP 7
3029: NOT
3030: AND
3031: PUSH
3032: LD_EXP 4
3036: AND
3037: IFFALSE 3092
3039: GO 3041
3041: DISABLE
// begin enable ;
3042: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3043: LD_INT 9
3045: PPUSH
3046: LD_INT 22
3048: PUSH
3049: LD_INT 7
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PPUSH
3056: CALL_OW 70
3060: IFFALSE 3078
// stevensTimer := stevensTimer - 0 0$30 else
3062: LD_ADDR_EXP 9
3066: PUSH
3067: LD_EXP 9
3071: PUSH
3072: LD_INT 1050
3074: MINUS
3075: ST_TO_ADDR
3076: GO 3092
// stevensTimer := stevensTimer - 0 0$1 ;
3078: LD_ADDR_EXP 9
3082: PUSH
3083: LD_EXP 9
3087: PUSH
3088: LD_INT 35
3090: MINUS
3091: ST_TO_ADDR
// end ;
3092: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3093: LD_EXP 9
3097: PUSH
3098: LD_INT 0
3100: LESSEQUAL
3101: PUSH
3102: LD_EXP 7
3106: NOT
3107: AND
3108: IFFALSE 3272
3110: GO 3112
3112: DISABLE
3113: LD_INT 0
3115: PPUSH
3116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: LD_INT 22
3124: PUSH
3125: LD_INT 1
3127: PUSH
3128: EMPTY
3129: LIST
3130: LIST
3131: PUSH
3132: LD_INT 25
3134: PUSH
3135: LD_INT 4
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PPUSH
3146: CALL_OW 69
3150: ST_TO_ADDR
// for i in tmp do
3151: LD_ADDR_VAR 0 1
3155: PUSH
3156: LD_VAR 0 2
3160: PUSH
3161: FOR_IN
3162: IFFALSE 3215
// begin if IsInUnit ( i ) then
3164: LD_VAR 0 1
3168: PPUSH
3169: CALL_OW 310
3173: IFFALSE 3186
// ComExitBuilding ( i ) else
3175: LD_VAR 0 1
3179: PPUSH
3180: CALL_OW 122
3184: GO 3213
// if not HasTask ( i ) then
3186: LD_VAR 0 1
3190: PPUSH
3191: CALL_OW 314
3195: NOT
3196: IFFALSE 3213
// ComMoveXY ( i , 29 , 56 ) ;
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 29
3205: PPUSH
3206: LD_INT 56
3208: PPUSH
3209: CALL_OW 111
// end ;
3213: GO 3161
3215: POP
3216: POP
// repeat wait ( 0 0$1 ) ;
3217: LD_INT 35
3219: PPUSH
3220: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3224: LD_INT 8
3226: PPUSH
3227: LD_INT 22
3229: PUSH
3230: LD_INT 1
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: LD_INT 25
3239: PUSH
3240: LD_INT 4
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PPUSH
3251: CALL_OW 70
3255: IFFALSE 3217
// if planCaptured then
3257: LD_EXP 7
3261: IFFALSE 3265
// exit ;
3263: GO 3272
// YouLost ( Time ) ;
3265: LD_STRING Time
3267: PPUSH
3268: CALL_OW 104
// end ;
3272: PPOPN 2
3274: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3275: LD_INT 22
3277: PUSH
3278: LD_INT 7
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: PUSH
3285: LD_INT 92
3287: PUSH
3288: LD_INT 142
3290: PUSH
3291: LD_INT 52
3293: PUSH
3294: LD_INT 27
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: PUSH
3312: LD_EXP 3
3316: PUSH
3317: LD_INT 6000
3319: PLUS
3320: PUSH
3321: LD_OWVAR 1
3325: GREATER
3326: AND
3327: PUSH
3328: LD_EXP 4
3332: AND
3333: IFFALSE 3388
3335: GO 3337
3337: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3338: LD_EXP 12
3342: PUSH
3343: LD_EXP 13
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PPUSH
3352: CALL_OW 85
// DialogueOn ;
3356: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3360: LD_EXP 12
3364: PPUSH
3365: LD_STRING D6b-JMM-1
3367: PPUSH
3368: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3372: LD_EXP 13
3376: PPUSH
3377: LD_STRING D6b-Bur-1
3379: PPUSH
3380: CALL_OW 88
// DialogueOff ;
3384: CALL_OW 7
// end ;
3388: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3389: LD_EXP 13
3393: PPUSH
3394: LD_INT 142
3396: PPUSH
3397: LD_INT 52
3399: PPUSH
3400: CALL_OW 297
3404: PUSH
3405: LD_INT 25
3407: LESS
3408: PUSH
3409: LD_EXP 13
3413: PPUSH
3414: CALL_OW 310
3418: PPUSH
3419: LD_INT 142
3421: PPUSH
3422: LD_INT 52
3424: PPUSH
3425: CALL_OW 297
3429: PUSH
3430: LD_INT 25
3432: LESS
3433: OR
3434: PUSH
3435: LD_EXP 13
3439: PPUSH
3440: CALL_OW 256
3444: PUSH
3445: LD_INT 1000
3447: LESS
3448: AND
3449: PUSH
3450: LD_EXP 3
3454: PUSH
3455: LD_INT 6000
3457: PLUS
3458: PUSH
3459: LD_OWVAR 1
3463: GREATER
3464: AND
3465: PUSH
3466: LD_EXP 4
3470: AND
3471: IFFALSE 3504
3473: GO 3475
3475: DISABLE
// begin DialogueOn ;
3476: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3480: LD_EXP 13
3484: PPUSH
3485: LD_STRING D7-Bur-1
3487: PPUSH
3488: CALL_OW 88
// enteredContaminatedArea := true ;
3492: LD_ADDR_EXP 5
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// DialogueOff ;
3500: CALL_OW 7
// end ;
3504: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3505: LD_EXP 12
3509: PPUSH
3510: LD_INT 142
3512: PPUSH
3513: LD_INT 52
3515: PPUSH
3516: CALL_OW 297
3520: PUSH
3521: LD_INT 25
3523: LESS
3524: PUSH
3525: LD_EXP 12
3529: PPUSH
3530: CALL_OW 310
3534: PPUSH
3535: LD_INT 142
3537: PPUSH
3538: LD_INT 52
3540: PPUSH
3541: CALL_OW 297
3545: PUSH
3546: LD_INT 25
3548: LESS
3549: OR
3550: PUSH
3551: LD_EXP 12
3555: PPUSH
3556: CALL_OW 256
3560: PUSH
3561: LD_INT 1000
3563: LESS
3564: AND
3565: PUSH
3566: LD_EXP 3
3570: PUSH
3571: LD_INT 6000
3573: PLUS
3574: PUSH
3575: LD_OWVAR 1
3579: GREATER
3580: AND
3581: PUSH
3582: LD_EXP 4
3586: AND
3587: IFFALSE 3620
3589: GO 3591
3591: DISABLE
// begin DialogueOn ;
3592: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3596: LD_EXP 12
3600: PPUSH
3601: LD_STRING D7-JMM-1
3603: PPUSH
3604: CALL_OW 88
// enteredContaminatedArea := true ;
3608: LD_ADDR_EXP 5
3612: PUSH
3613: LD_INT 1
3615: ST_TO_ADDR
// DialogueOff ;
3616: CALL_OW 7
// end ;
3620: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3621: LD_EXP 6
3625: PUSH
3626: LD_EXP 12
3630: PPUSH
3631: CALL_OW 302
3635: AND
3636: PUSH
3637: LD_EXP 13
3641: PPUSH
3642: CALL_OW 302
3646: AND
3647: IFFALSE 3716
3649: GO 3651
3651: DISABLE
// begin DialogueOn ;
3652: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3656: LD_EXP 12
3660: PUSH
3661: LD_EXP 13
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: PPUSH
3670: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3674: LD_EXP 12
3678: PPUSH
3679: LD_STRING D4-JMM-1
3681: PPUSH
3682: CALL_OW 88
// if not bombExploded then
3686: LD_EXP 4
3690: NOT
3691: IFFALSE 3705
// Say ( Burlak , D4-Bur-1 ) ;
3693: LD_EXP 13
3697: PPUSH
3698: LD_STRING D4-Bur-1
3700: PPUSH
3701: CALL_OW 88
// DialogueOff ;
3705: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3709: LD_STRING MReturn
3711: PPUSH
3712: CALL_OW 337
// end ;
3716: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3717: LD_EXP 7
3721: NOT
3722: PUSH
3723: LD_INT 22
3725: PUSH
3726: LD_INT 7
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: LD_INT 91
3735: PUSH
3736: LD_INT 9
3738: PUSH
3739: LD_INT 6
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: AND
3756: IFFALSE 3833
3758: GO 3760
3760: DISABLE
// begin DialogueOn ;
3761: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3765: LD_INT 55
3767: PPUSH
3768: LD_INT 11
3770: PPUSH
3771: LD_INT 7
3773: PPUSH
3774: LD_INT 6
3776: NEG
3777: PPUSH
3778: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3782: LD_INT 55
3784: PPUSH
3785: LD_INT 11
3787: PPUSH
3788: LD_INT 7
3790: PPUSH
3791: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3795: LD_EXP 13
3799: PPUSH
3800: LD_STRING D9-Bur-1
3802: PPUSH
3803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3807: LD_EXP 12
3811: PPUSH
3812: LD_STRING D9-JMM-1
3814: PPUSH
3815: CALL_OW 88
// DialogueOff ;
3819: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3823: LD_INT 9
3825: PPUSH
3826: LD_INT 7
3828: PPUSH
3829: CALL_OW 235
// end ;
3833: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3834: LD_INT 9
3836: PPUSH
3837: LD_INT 22
3839: PUSH
3840: LD_INT 7
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PPUSH
3847: CALL_OW 70
3851: IFFALSE 3887
3853: GO 3855
3855: DISABLE
// begin wait ( 0 0$07 ) ;
3856: LD_INT 245
3858: PPUSH
3859: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3863: LD_EXP 12
3867: PPUSH
3868: LD_STRING D10b-JMM-1
3870: PPUSH
3871: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3875: LD_EXP 13
3879: PPUSH
3880: LD_STRING D10b-Bur-1
3882: PPUSH
3883: CALL_OW 88
// end ;
3887: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3888: LD_EXP 9
3892: PUSH
3893: LD_INT 22
3895: PUSH
3896: LD_INT 1
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 25
3905: PUSH
3906: LD_INT 4
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: LD_INT 26
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 69
3932: AND
3933: PUSH
3934: LD_INT 5
3936: PPUSH
3937: CALL_OW 255
3941: PUSH
3942: LD_INT 7
3944: EQUAL
3945: PUSH
3946: LD_INT 22
3948: PUSH
3949: LD_INT 1
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 25
3958: PUSH
3959: LD_INT 1
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: PPUSH
3970: CALL_OW 69
3974: PUSH
3975: LD_INT 0
3977: EQUAL
3978: OR
3979: AND
3980: IFFALSE 4562
3982: GO 3984
3984: DISABLE
3985: LD_INT 0
3987: PPUSH
// begin case Query ( QKill ) of 1 :
3988: LD_STRING QKill
3990: PPUSH
3991: CALL_OW 97
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4550
4004: POP
// begin DialogueOn ;
4005: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4009: LD_EXP 12
4013: PPUSH
4014: LD_STRING D10a-JMM-1
4016: PPUSH
4017: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4021: LD_EXP 13
4025: PPUSH
4026: LD_STRING D10a-Bur-1
4028: PPUSH
4029: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4033: LD_EXP 12
4037: PPUSH
4038: LD_STRING D10a-JMM-2
4040: PPUSH
4041: CALL_OW 88
// if IsOk ( Stevens ) then
4045: LD_EXP 16
4049: PPUSH
4050: CALL_OW 302
4054: IFFALSE 4070
// Say ( Stevens , D10a-Huck-2 ) else
4056: LD_EXP 16
4060: PPUSH
4061: LD_STRING D10a-Huck-2
4063: PPUSH
4064: CALL_OW 88
4068: GO 4121
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4070: LD_INT 22
4072: PUSH
4073: LD_INT 1
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: LD_INT 25
4082: PUSH
4083: LD_INT 4
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: LD_INT 26
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: PPUSH
4105: CALL_OW 69
4109: PUSH
4110: LD_INT 1
4112: ARRAY
4113: PPUSH
4114: LD_STRING D10a-ASci1-3
4116: PPUSH
4117: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4121: LD_EXP 12
4125: PPUSH
4126: LD_STRING D10a-JMM-4
4128: PPUSH
4129: CALL_OW 88
// if IsOk ( Stevens ) then
4133: LD_EXP 16
4137: PPUSH
4138: CALL_OW 302
4142: IFFALSE 4156
// Say ( Stevens , D10a-Huck-3 ) ;
4144: LD_EXP 16
4148: PPUSH
4149: LD_STRING D10a-Huck-3
4151: PPUSH
4152: CALL_OW 88
// DialogueOff ;
4156: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4160: LD_INT 1
4162: PPUSH
4163: LD_INT 7
4165: PPUSH
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 80
// planCaptured := true ;
4176: LD_ADDR_EXP 7
4180: PUSH
4181: LD_INT 1
4183: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4184: LD_STRING MEnd
4186: PPUSH
4187: CALL_OW 337
// canEnd := true ;
4191: LD_ADDR_EXP 10
4195: PUSH
4196: LD_INT 1
4198: ST_TO_ADDR
// missionTime := tick ;
4199: LD_ADDR_EXP 11
4203: PUSH
4204: LD_OWVAR 1
4208: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4209: LD_INT 35
4211: PPUSH
4212: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4216: LD_INT 22
4218: PUSH
4219: LD_INT 1
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PUSH
4226: LD_INT 3
4228: PUSH
4229: LD_INT 50
4231: PUSH
4232: EMPTY
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: PPUSH
4243: CALL_OW 69
4247: IFFALSE 4363
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4249: LD_ADDR_VAR 0 1
4253: PUSH
4254: LD_INT 22
4256: PUSH
4257: LD_INT 1
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 25
4266: PUSH
4267: LD_INT 4
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4361
// begin if IsInUnit ( i ) then
4286: LD_VAR 0 1
4290: PPUSH
4291: CALL_OW 310
4295: IFFALSE 4308
// ComExitBuilding ( i ) else
4297: LD_VAR 0 1
4301: PPUSH
4302: CALL_OW 122
4306: GO 4359
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4308: LD_VAR 0 1
4312: PPUSH
4313: LD_INT 22
4315: PUSH
4316: LD_INT 1
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PUSH
4323: LD_INT 3
4325: PUSH
4326: LD_INT 50
4328: PUSH
4329: EMPTY
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PPUSH
4340: CALL_OW 69
4344: PPUSH
4345: LD_VAR 0 1
4349: PPUSH
4350: CALL_OW 74
4354: PPUSH
4355: CALL_OW 128
// end ;
4359: GO 4283
4361: POP
4362: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4363: LD_INT 22
4365: PUSH
4366: LD_INT 1
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 3
4375: PUSH
4376: LD_INT 50
4378: PUSH
4379: EMPTY
4380: LIST
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PPUSH
4390: CALL_OW 69
4394: NOT
4395: IFFALSE 4209
// repeat wait ( 3 ) ;
4397: LD_INT 3
4399: PPUSH
4400: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4404: LD_ADDR_VAR 0 1
4408: PUSH
4409: LD_INT 22
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: LD_INT 21
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: PUSH
4438: FOR_IN
4439: IFFALSE 4515
// begin if IsInArea ( i , stevensEscapeArea ) then
4441: LD_VAR 0 1
4445: PPUSH
4446: LD_INT 8
4448: PPUSH
4449: CALL_OW 308
4453: IFFALSE 4466
// begin RemoveUnit ( i ) ;
4455: LD_VAR 0 1
4459: PPUSH
4460: CALL_OW 64
// continue ;
4464: GO 4438
// end ; if IsInUnit ( i ) then
4466: LD_VAR 0 1
4470: PPUSH
4471: CALL_OW 310
4475: IFFALSE 4486
// ComExitBuilding ( i ) ;
4477: LD_VAR 0 1
4481: PPUSH
4482: CALL_OW 122
// if not HasTask ( i ) then
4486: LD_VAR 0 1
4490: PPUSH
4491: CALL_OW 314
4495: NOT
4496: IFFALSE 4513
// ComMoveXY ( i , 28 , 55 ) ;
4498: LD_VAR 0 1
4502: PPUSH
4503: LD_INT 28
4505: PPUSH
4506: LD_INT 55
4508: PPUSH
4509: CALL_OW 111
// end ;
4513: GO 4438
4515: POP
4516: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4517: LD_INT 22
4519: PUSH
4520: LD_INT 1
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 21
4529: PUSH
4530: LD_INT 1
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PPUSH
4541: CALL_OW 69
4545: NOT
4546: IFFALSE 4397
// end ; 2 :
4548: GO 4562
4550: LD_INT 2
4552: DOUBLE
4553: EQUAL
4554: IFTRUE 4558
4556: GO 4561
4558: POP
// ; end ;
4559: GO 4562
4561: POP
// end ;
4562: PPOPN 1
4564: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4565: LD_EXP 10
4569: IFFALSE 4926
4571: GO 4573
4573: DISABLE
4574: LD_INT 0
4576: PPUSH
4577: PPUSH
4578: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4579: LD_INT 10
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 424
// if Difficulty < 2 then
4589: LD_OWVAR 67
4593: PUSH
4594: LD_INT 2
4596: LESS
4597: IFFALSE 4601
// exit ;
4599: GO 4926
// uc_side := 4 ;
4601: LD_ADDR_OWVAR 20
4605: PUSH
4606: LD_INT 4
4608: ST_TO_ADDR
// uc_nation := 1 ;
4609: LD_ADDR_OWVAR 21
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// InitHc ;
4617: CALL_OW 19
// tmp := [ ] ;
4621: LD_ADDR_VAR 0 3
4625: PUSH
4626: EMPTY
4627: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4628: LD_INT 0
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 10
4636: PPUSH
4637: CALL_OW 380
// un := CreateHuman ;
4641: LD_ADDR_VAR 0 1
4645: PUSH
4646: CALL_OW 44
4650: ST_TO_ADDR
// tmp := [ un ] ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: LD_VAR 0 1
4660: PUSH
4661: EMPTY
4662: LIST
4663: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4664: LD_VAR 0 1
4668: PPUSH
4669: LD_INT 226
4671: PPUSH
4672: LD_INT 86
4674: PPUSH
4675: LD_INT 0
4677: PPUSH
4678: CALL_OW 48
// ComHold ( un ) ;
4682: LD_VAR 0 1
4686: PPUSH
4687: CALL_OW 140
// for i = 1 to 3 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 3
4703: PUSH
4704: FOR_TO
4705: IFFALSE 4804
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4707: LD_INT 0
4709: PPUSH
4710: LD_INT 1
4712: PPUSH
4713: LD_INT 8
4715: PPUSH
4716: CALL_OW 380
// un := CreateHuman ;
4720: LD_ADDR_VAR 0 1
4724: PUSH
4725: CALL_OW 44
4729: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4730: LD_VAR 0 1
4734: PPUSH
4735: LD_INT 5
4737: PPUSH
4738: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4742: LD_VAR 0 1
4746: PPUSH
4747: LD_INT 215
4749: PUSH
4750: LD_INT 217
4752: PUSH
4753: LD_INT 219
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_VAR 0 2
4765: ARRAY
4766: PPUSH
4767: LD_INT 76
4769: PPUSH
4770: LD_INT 0
4772: PPUSH
4773: CALL_OW 48
// ComCrawl ( un ) ;
4777: LD_VAR 0 1
4781: PPUSH
4782: CALL_OW 137
// tmp := tmp ^ un ;
4786: LD_ADDR_VAR 0 3
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: LD_VAR 0 1
4800: ADD
4801: ST_TO_ADDR
// end ;
4802: GO 4704
4804: POP
4805: POP
// repeat wait ( 0 0$1 ) ;
4806: LD_INT 35
4808: PPUSH
4809: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4813: LD_VAR 0 1
4817: PPUSH
4818: LD_INT 24
4820: PUSH
4821: LD_INT 1000
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PPUSH
4828: CALL_OW 72
4832: NOT
4833: IFFALSE 4806
// for i in tmp do
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_VAR 0 3
4844: PUSH
4845: FOR_IN
4846: IFFALSE 4924
// begin wait ( 0 0$1 ) ;
4848: LD_INT 35
4850: PPUSH
4851: CALL_OW 67
// if Crawls ( i ) then
4855: LD_VAR 0 2
4859: PPUSH
4860: CALL_OW 318
4864: IFFALSE 4877
// ComWalk ( i ) else
4866: LD_VAR 0 2
4870: PPUSH
4871: CALL_OW 138
4875: GO 4922
// if GetClass ( i ) = class_sniper then
4877: LD_VAR 0 2
4881: PPUSH
4882: CALL_OW 257
4886: PUSH
4887: LD_INT 5
4889: EQUAL
4890: IFFALSE 4908
// ComAttackSoporific ( i , JMM ) else
4892: LD_VAR 0 2
4896: PPUSH
4897: LD_EXP 12
4901: PPUSH
4902: CALL_OW 166
4906: GO 4922
// ComAttackUnit ( i , JMM ) ;
4908: LD_VAR 0 2
4912: PPUSH
4913: LD_EXP 12
4917: PPUSH
4918: CALL_OW 115
// end ;
4922: GO 4845
4924: POP
4925: POP
// end ;
4926: PPOPN 3
4928: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4929: LD_EXP 7
4933: NOT
4934: PUSH
4935: LD_INT 1
4937: PPUSH
4938: CALL_OW 301
4942: AND
4943: IFFALSE 4955
4945: GO 4947
4947: DISABLE
// YouLost ( Lab ) ;
4948: LD_STRING Lab
4950: PPUSH
4951: CALL_OW 104
4955: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do
4956: LD_INT 10
4958: PPUSH
4959: LD_INT 22
4961: PUSH
4962: LD_INT 7
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 70
4973: PUSH
4974: LD_INT 2
4976: GREATEREQUAL
4977: PUSH
4978: LD_INT 10
4980: PPUSH
4981: LD_INT 2
4983: PUSH
4984: LD_INT 34
4986: PUSH
4987: LD_INT 12
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 34
4996: PUSH
4997: LD_INT 51
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: LIST
5008: PPUSH
5009: CALL_OW 70
5013: AND
5014: PUSH
5015: LD_EXP 10
5019: AND
5020: PUSH
5021: LD_EXP 7
5025: AND
5026: PUSH
5027: LD_EXP 6
5031: AND
5032: IFFALSE 5179
5034: GO 5036
5036: DISABLE
// begin AddMedal ( Explosion , 1 ) ;
5037: LD_STRING Explosion
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: CALL_OW 101
// if enteredContaminatedArea then
5047: LD_EXP 5
5051: IFFALSE 5065
// AddMedal ( BioHazard , 1 ) else
5053: LD_STRING BioHazard
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 101
5063: GO 5076
// AddMedal ( BioHazard , - 1 ) ;
5065: LD_STRING BioHazard
5067: PPUSH
5068: LD_INT 1
5070: NEG
5071: PPUSH
5072: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5076: LD_EXP 11
5080: PUSH
5081: LD_INT 42000
5083: PUSH
5084: LD_INT 31500
5086: PUSH
5087: LD_INT 25200
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: LESSEQUAL
5101: IFFALSE 5115
// AddMedal ( Speed , 1 ) else
5103: LD_STRING Speed
5105: PPUSH
5106: LD_INT 1
5108: PPUSH
5109: CALL_OW 101
5113: GO 5126
// AddMedal ( Speed , - 1 ) ;
5115: LD_STRING Speed
5117: PPUSH
5118: LD_INT 1
5120: NEG
5121: PPUSH
5122: CALL_OW 101
// GiveMedals ( Main ) ;
5126: LD_STRING Main
5128: PPUSH
5129: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5133: LD_EXP 12
5137: PUSH
5138: LD_EXP 13
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PPUSH
5147: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5151: LD_EXP 12
5155: PPUSH
5156: LD_STRING 14a_JMM
5158: PPUSH
5159: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5163: LD_EXP 13
5167: PPUSH
5168: LD_STRING 14a_Burlak
5170: PPUSH
5171: CALL_OW 38
// YouWin ;
5175: CALL_OW 103
// end ; end_of_file
5179: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5180: LD_INT 0
5182: PPUSH
5183: PPUSH
5184: PPUSH
5185: PPUSH
// uc_side := 1 ;
5186: LD_ADDR_OWVAR 20
5190: PUSH
5191: LD_INT 1
5193: ST_TO_ADDR
// uc_nation := 1 ;
5194: LD_ADDR_OWVAR 21
5198: PUSH
5199: LD_INT 1
5201: ST_TO_ADDR
// InitHc ;
5202: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5206: LD_INT 34
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5224: LD_INT 34
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 3
5234: PPUSH
5235: LD_INT 20
5237: PPUSH
5238: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5242: LD_ADDR_EXP 16
5246: PUSH
5247: LD_STRING Stevens
5249: PPUSH
5250: CALL_OW 25
5254: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5255: LD_ADDR_EXP 17
5259: PUSH
5260: LD_STRING Powell
5262: PPUSH
5263: CALL_OW 25
5267: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5268: LD_EXP 16
5272: PPUSH
5273: LD_INT 1
5275: PPUSH
5276: CALL_OW 52
// vehGuard := [ ] ;
5280: LD_ADDR_EXP 21
5284: PUSH
5285: EMPTY
5286: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5287: LD_INT 4
5289: PPUSH
5290: LD_INT 3
5292: PPUSH
5293: LD_INT 3
5295: PPUSH
5296: LD_INT 8
5298: PPUSH
5299: LD_INT 100
5301: PPUSH
5302: CALL 934 0 5
// sibBomb := CreateVehicle ;
5306: LD_ADDR_EXP 19
5310: PUSH
5311: CALL_OW 45
5315: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5316: LD_EXP 19
5320: PPUSH
5321: LD_INT 1
5323: PPUSH
5324: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5328: LD_EXP 19
5332: PPUSH
5333: LD_INT 93
5335: PPUSH
5336: LD_INT 74
5338: PPUSH
5339: LD_INT 0
5341: PPUSH
5342: CALL_OW 48
// guards := [ ] ;
5346: LD_ADDR_EXP 20
5350: PUSH
5351: EMPTY
5352: ST_TO_ADDR
// for i = 1 to 3 do
5353: LD_ADDR_VAR 0 2
5357: PUSH
5358: DOUBLE
5359: LD_INT 1
5361: DEC
5362: ST_TO_ADDR
5363: LD_INT 3
5365: PUSH
5366: FOR_TO
5367: IFFALSE 5459
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5369: LD_INT 0
5371: PPUSH
5372: LD_INT 1
5374: PPUSH
5375: LD_INT 8
5377: PUSH
5378: LD_INT 9
5380: PUSH
5381: LD_INT 10
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: LIST
5388: PUSH
5389: LD_OWVAR 67
5393: ARRAY
5394: PPUSH
5395: CALL_OW 380
// un := CreateHuman ;
5399: LD_ADDR_VAR 0 3
5403: PUSH
5404: CALL_OW 44
5408: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5409: LD_VAR 0 3
5413: PPUSH
5414: LD_INT 2
5416: PUSH
5417: LD_INT 3
5419: PUSH
5420: LD_INT 4
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: LIST
5427: PUSH
5428: LD_VAR 0 2
5432: ARRAY
5433: PPUSH
5434: LD_INT 0
5436: PPUSH
5437: CALL_OW 49
// guards := guards ^ un ;
5441: LD_ADDR_EXP 20
5445: PUSH
5446: LD_EXP 20
5450: PUSH
5451: LD_VAR 0 3
5455: ADD
5456: ST_TO_ADDR
// end ;
5457: GO 5366
5459: POP
5460: POP
// baseGuards := [ ] ;
5461: LD_ADDR_EXP 18
5465: PUSH
5466: EMPTY
5467: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5468: LD_ADDR_VAR 0 2
5472: PUSH
5473: DOUBLE
5474: LD_INT 1
5476: DEC
5477: ST_TO_ADDR
5478: LD_INT 5
5480: PUSH
5481: LD_INT 6
5483: PUSH
5484: LD_INT 7
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: LIST
5491: PUSH
5492: LD_OWVAR 67
5496: ARRAY
5497: PUSH
5498: FOR_TO
5499: IFFALSE 5645
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5501: LD_INT 0
5503: PPUSH
5504: LD_INT 8
5506: PUSH
5507: LD_INT 9
5509: PUSH
5510: LD_INT 10
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: PUSH
5518: LD_OWVAR 67
5522: ARRAY
5523: PPUSH
5524: CALL_OW 381
// un := CreateHuman ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: CALL_OW 44
5537: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5538: LD_ADDR_EXP 18
5542: PUSH
5543: LD_EXP 18
5547: PUSH
5548: LD_VAR 0 3
5552: ADD
5553: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5554: LD_ADDR_VAR 0 4
5558: PUSH
5559: LD_INT 22
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 58
5571: PUSH
5572: EMPTY
5573: LIST
5574: PUSH
5575: LD_INT 30
5577: PUSH
5578: LD_INT 32
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PPUSH
5590: CALL_OW 69
5594: ST_TO_ADDR
// if tmp then
5595: LD_VAR 0 4
5599: IFFALSE 5631
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5601: LD_VAR 0 3
5605: PPUSH
5606: LD_VAR 0 4
5610: PUSH
5611: LD_INT 1
5613: PPUSH
5614: LD_VAR 0 4
5618: PPUSH
5619: CALL_OW 12
5623: ARRAY
5624: PPUSH
5625: CALL_OW 52
5629: GO 5643
// PlaceHumanInUnit ( un , us_bar ) ;
5631: LD_VAR 0 3
5635: PPUSH
5636: LD_INT 51
5638: PPUSH
5639: CALL_OW 52
// end ;
5643: GO 5498
5645: POP
5646: POP
// if Difficulty > 1 then
5647: LD_OWVAR 67
5651: PUSH
5652: LD_INT 1
5654: GREATER
5655: IFFALSE 5699
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 5
5662: PPUSH
5663: LD_INT 9
5665: PUSH
5666: LD_INT 10
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PUSH
5673: LD_OWVAR 67
5677: PUSH
5678: LD_INT 1
5680: MINUS
5681: ARRAY
5682: PPUSH
5683: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5687: CALL_OW 44
5691: PPUSH
5692: LD_INT 80
5694: PPUSH
5695: CALL_OW 52
// end ; for i = 1 to 3 do
5699: LD_ADDR_VAR 0 2
5703: PUSH
5704: DOUBLE
5705: LD_INT 1
5707: DEC
5708: ST_TO_ADDR
5709: LD_INT 3
5711: PUSH
5712: FOR_TO
5713: IFFALSE 5739
// begin PrepareMechanic ( false , 9 ) ;
5715: LD_INT 0
5717: PPUSH
5718: LD_INT 9
5720: PPUSH
5721: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5725: CALL_OW 44
5729: PPUSH
5730: LD_INT 43
5732: PPUSH
5733: CALL_OW 52
// end ;
5737: GO 5712
5739: POP
5740: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5741: CALL_OW 44
5745: PPUSH
5746: LD_INT 49
5748: PPUSH
5749: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5753: LD_ADDR_VAR 0 2
5757: PUSH
5758: DOUBLE
5759: LD_INT 1
5761: DEC
5762: ST_TO_ADDR
5763: LD_INT 1
5765: PUSH
5766: LD_OWVAR 67
5770: PLUS
5771: PUSH
5772: FOR_TO
5773: IFFALSE 5816
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5775: LD_INT 0
5777: PPUSH
5778: LD_INT 8
5780: PUSH
5781: LD_INT 9
5783: PUSH
5784: LD_INT 10
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: PUSH
5792: LD_OWVAR 67
5796: ARRAY
5797: PPUSH
5798: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5802: CALL_OW 44
5806: PPUSH
5807: LD_INT 5
5809: PPUSH
5810: CALL_OW 52
// end ;
5814: GO 5772
5816: POP
5817: POP
// for i = 1 to 3 do
5818: LD_ADDR_VAR 0 2
5822: PUSH
5823: DOUBLE
5824: LD_INT 1
5826: DEC
5827: ST_TO_ADDR
5828: LD_INT 3
5830: PUSH
5831: FOR_TO
5832: IFFALSE 5858
// begin PrepareScientist ( false , 10 ) ;
5834: LD_INT 0
5836: PPUSH
5837: LD_INT 10
5839: PPUSH
5840: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
5844: CALL_OW 44
5848: PPUSH
5849: LD_INT 1
5851: PPUSH
5852: CALL_OW 52
// end ;
5856: GO 5831
5858: POP
5859: POP
// end ;
5860: LD_VAR 0 1
5864: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
5865: LD_EXP 20
5869: PUSH
5870: LD_EXP 2
5874: NOT
5875: AND
5876: IFFALSE 6062
5878: GO 5880
5880: DISABLE
5881: LD_INT 0
5883: PPUSH
5884: PPUSH
5885: PPUSH
// begin enable ;
5886: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
5887: LD_ADDR_VAR 0 3
5891: PUSH
5892: LD_INT 204
5894: PUSH
5895: LD_INT 30
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: PUSH
5902: LD_INT 165
5904: PUSH
5905: LD_INT 24
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: PUSH
5912: LD_INT 195
5914: PUSH
5915: LD_INT 6
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: PUSH
5922: LD_INT 223
5924: PUSH
5925: LD_INT 54
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PUSH
5932: LD_INT 214
5934: PUSH
5935: LD_INT 84
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PUSH
5942: LD_INT 206
5944: PUSH
5945: LD_INT 71
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: ST_TO_ADDR
// for i in guards do
5960: LD_ADDR_VAR 0 1
5964: PUSH
5965: LD_EXP 20
5969: PUSH
5970: FOR_IN
5971: IFFALSE 6060
// begin if HasTask ( i ) then
5973: LD_VAR 0 1
5977: PPUSH
5978: CALL_OW 314
5982: IFFALSE 5988
// continue else
5984: GO 5970
5986: GO 6058
// begin j := rand ( 1 , 6 ) ;
5988: LD_ADDR_VAR 0 2
5992: PUSH
5993: LD_INT 1
5995: PPUSH
5996: LD_INT 6
5998: PPUSH
5999: CALL_OW 12
6003: ST_TO_ADDR
// if not See ( 7 , i ) then
6004: LD_INT 7
6006: PPUSH
6007: LD_VAR 0 1
6011: PPUSH
6012: CALL_OW 292
6016: NOT
6017: IFFALSE 6058
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_VAR 0 3
6028: PUSH
6029: LD_VAR 0 2
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: ARRAY
6038: PPUSH
6039: LD_VAR 0 3
6043: PUSH
6044: LD_VAR 0 2
6048: ARRAY
6049: PUSH
6050: LD_INT 2
6052: ARRAY
6053: PPUSH
6054: CALL_OW 114
// end ; end ;
6058: GO 5970
6060: POP
6061: POP
// end ;
6062: PPOPN 3
6064: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6065: LD_EXP 21
6069: PUSH
6070: LD_EXP 7
6074: NOT
6075: AND
6076: IFFALSE 6147
6078: GO 6080
6080: DISABLE
6081: LD_INT 0
6083: PPUSH
// begin enable ;
6084: ENABLE
// for i in vehGuard do
6085: LD_ADDR_VAR 0 1
6089: PUSH
6090: LD_EXP 21
6094: PUSH
6095: FOR_IN
6096: IFFALSE 6145
// if IsOk ( vehGuard ) then
6098: LD_EXP 21
6102: PPUSH
6103: CALL_OW 302
6107: IFFALSE 6143
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6109: LD_VAR 0 1
6113: PPUSH
6114: LD_INT 22
6116: PUSH
6117: LD_INT 7
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 69
6128: PPUSH
6129: LD_VAR 0 1
6133: PPUSH
6134: CALL_OW 74
6138: PPUSH
6139: CALL_OW 115
6143: GO 6095
6145: POP
6146: POP
// end ;
6147: PPOPN 1
6149: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6150: LD_EXP 4
6154: PUSH
6155: LD_INT 43
6157: PPUSH
6158: CALL_OW 302
6162: AND
6163: PUSH
6164: LD_EXP 7
6168: NOT
6169: AND
6170: IFFALSE 6218
6172: GO 6174
6174: DISABLE
// begin enable ;
6175: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6176: LD_INT 43
6178: PPUSH
6179: LD_INT 5
6181: PPUSH
6182: LD_INT 3
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 7
6190: PUSH
6191: LD_INT 7
6193: PUSH
6194: LD_INT 9
6196: PUSH
6197: EMPTY
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 1
6204: PPUSH
6205: LD_INT 3
6207: PPUSH
6208: CALL_OW 12
6212: ARRAY
6213: PPUSH
6214: CALL_OW 125
// end ;
6218: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6219: LD_INT 22
6221: PUSH
6222: LD_INT 1
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PUSH
6229: LD_INT 25
6231: PUSH
6232: LD_INT 5
6234: PUSH
6235: EMPTY
6236: LIST
6237: LIST
6238: PUSH
6239: LD_INT 50
6241: PUSH
6242: EMPTY
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: PPUSH
6250: CALL_OW 69
6254: PUSH
6255: LD_EXP 7
6259: NOT
6260: AND
6261: IFFALSE 6490
6263: GO 6265
6265: DISABLE
6266: LD_INT 0
6268: PPUSH
6269: PPUSH
// begin enable ;
6270: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6271: LD_ADDR_VAR 0 1
6275: PUSH
6276: LD_INT 22
6278: PUSH
6279: LD_INT 1
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: LD_INT 25
6288: PUSH
6289: LD_INT 5
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PUSH
6296: LD_INT 50
6298: PUSH
6299: EMPTY
6300: LIST
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: PPUSH
6307: CALL_OW 69
6311: ST_TO_ADDR
// if not tmp then
6312: LD_VAR 0 1
6316: NOT
6317: IFFALSE 6321
// exit ;
6319: GO 6490
// b := IsInUnit ( tmp [ 1 ] ) ;
6321: LD_ADDR_VAR 0 2
6325: PUSH
6326: LD_VAR 0 1
6330: PUSH
6331: LD_INT 1
6333: ARRAY
6334: PPUSH
6335: CALL_OW 310
6339: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6340: LD_VAR 0 2
6344: NOT
6345: PUSH
6346: LD_VAR 0 1
6350: PUSH
6351: LD_INT 1
6353: ARRAY
6354: PPUSH
6355: CALL_OW 314
6359: OR
6360: IFFALSE 6364
// exit ;
6362: GO 6490
// if b = us_bun1 then
6364: LD_VAR 0 2
6368: PUSH
6369: LD_INT 80
6371: EQUAL
6372: IFFALSE 6433
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6374: LD_VAR 0 1
6378: PUSH
6379: LD_INT 1
6381: ARRAY
6382: PPUSH
6383: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6387: LD_VAR 0 1
6391: PUSH
6392: LD_INT 1
6394: ARRAY
6395: PPUSH
6396: LD_INT 27
6398: PPUSH
6399: LD_INT 44
6401: PPUSH
6402: CALL_OW 174
// if IsOk ( us_bun2 ) then
6406: LD_INT 55
6408: PPUSH
6409: CALL_OW 302
6413: IFFALSE 6431
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6415: LD_VAR 0 1
6419: PUSH
6420: LD_INT 1
6422: ARRAY
6423: PPUSH
6424: LD_INT 55
6426: PPUSH
6427: CALL_OW 180
// end else
6431: GO 6490
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6433: LD_VAR 0 1
6437: PUSH
6438: LD_INT 1
6440: ARRAY
6441: PPUSH
6442: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6446: LD_VAR 0 1
6450: PUSH
6451: LD_INT 1
6453: ARRAY
6454: PPUSH
6455: LD_INT 92
6457: PPUSH
6458: LD_INT 51
6460: PPUSH
6461: CALL_OW 174
// if IsOk ( us_bun1 ) then
6465: LD_INT 80
6467: PPUSH
6468: CALL_OW 302
6472: IFFALSE 6490
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6474: LD_VAR 0 1
6478: PUSH
6479: LD_INT 1
6481: ARRAY
6482: PPUSH
6483: LD_INT 80
6485: PPUSH
6486: CALL_OW 180
// end ; end ;
6490: PPOPN 2
6492: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6493: LD_EXP 7
6497: NOT
6498: PUSH
6499: LD_INT 9
6501: PPUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 1
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 3
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 24
6527: PUSH
6528: LD_INT 1000
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: PPUSH
6544: CALL_OW 70
6548: AND
6549: IFFALSE 6960
6551: GO 6553
6553: DISABLE
6554: LD_INT 0
6556: PPUSH
6557: PPUSH
6558: PPUSH
6559: PPUSH
// begin enable ;
6560: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6561: LD_ADDR_VAR 0 2
6565: PUSH
6566: LD_INT 22
6568: PUSH
6569: LD_INT 1
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 25
6578: PUSH
6579: LD_INT 2
6581: PUSH
6582: EMPTY
6583: LIST
6584: LIST
6585: PUSH
6586: LD_INT 24
6588: PUSH
6589: LD_INT 1000
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: LIST
6600: PPUSH
6601: CALL_OW 69
6605: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6606: LD_ADDR_VAR 0 3
6610: PUSH
6611: LD_INT 22
6613: PUSH
6614: LD_INT 1
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: PUSH
6621: LD_INT 25
6623: PUSH
6624: LD_INT 2
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: PUSH
6631: LD_INT 3
6633: PUSH
6634: LD_INT 24
6636: PUSH
6637: LD_INT 750
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: PPUSH
6653: CALL_OW 69
6657: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6658: LD_ADDR_VAR 0 4
6662: PUSH
6663: LD_INT 9
6665: PPUSH
6666: LD_INT 22
6668: PUSH
6669: LD_INT 1
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PUSH
6676: LD_INT 21
6678: PUSH
6679: LD_INT 3
6681: PUSH
6682: EMPTY
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 3
6688: PUSH
6689: LD_INT 24
6691: PUSH
6692: LD_INT 1000
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: LIST
6707: PPUSH
6708: CALL_OW 70
6712: PUSH
6713: LD_INT 1
6715: DIFF
6716: ST_TO_ADDR
// if not tmp and not tmp2 then
6717: LD_VAR 0 2
6721: NOT
6722: PUSH
6723: LD_VAR 0 3
6727: NOT
6728: AND
6729: IFFALSE 6733
// exit ;
6731: GO 6960
// if tmp and b then
6733: LD_VAR 0 2
6737: PUSH
6738: LD_VAR 0 4
6742: AND
6743: IFFALSE 6873
// for i in tmp do
6745: LD_ADDR_VAR 0 1
6749: PUSH
6750: LD_VAR 0 2
6754: PUSH
6755: FOR_IN
6756: IFFALSE 6871
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6758: LD_VAR 0 1
6762: PPUSH
6763: CALL_OW 110
6767: PUSH
6768: LD_INT 1
6770: EQUAL
6771: PUSH
6772: LD_VAR 0 1
6776: PPUSH
6777: CALL_OW 256
6781: PUSH
6782: LD_INT 1000
6784: LESS
6785: AND
6786: IFFALSE 6792
// continue else
6788: GO 6755
6790: GO 6819
// if GetTag ( i ) = 1 then
6792: LD_VAR 0 1
6796: PPUSH
6797: CALL_OW 110
6801: PUSH
6802: LD_INT 1
6804: EQUAL
6805: IFFALSE 6819
// SetTag ( i , 0 ) ;
6807: LD_VAR 0 1
6811: PPUSH
6812: LD_INT 0
6814: PPUSH
6815: CALL_OW 109
// if IsInUnit ( i ) then
6819: LD_VAR 0 1
6823: PPUSH
6824: CALL_OW 310
6828: IFFALSE 6839
// ComExitBuilding ( i ) ;
6830: LD_VAR 0 1
6834: PPUSH
6835: CALL_OW 122
// if not HasTask ( i ) then
6839: LD_VAR 0 1
6843: PPUSH
6844: CALL_OW 314
6848: NOT
6849: IFFALSE 6869
// AddComRepairBuilding ( i , b [ 1 ] ) ;
6851: LD_VAR 0 1
6855: PPUSH
6856: LD_VAR 0 4
6860: PUSH
6861: LD_INT 1
6863: ARRAY
6864: PPUSH
6865: CALL_OW 190
// end ;
6869: GO 6755
6871: POP
6872: POP
// if tmp2 then
6873: LD_VAR 0 3
6877: IFFALSE 6960
// for i in tmp2 do
6879: LD_ADDR_VAR 0 1
6883: PUSH
6884: LD_VAR 0 3
6888: PUSH
6889: FOR_IN
6890: IFFALSE 6958
// begin if not GetTag ( i ) = 1 then
6892: LD_VAR 0 1
6896: PPUSH
6897: CALL_OW 110
6901: PUSH
6902: LD_INT 1
6904: EQUAL
6905: NOT
6906: IFFALSE 6920
// SetTag ( i , 1 ) ;
6908: LD_VAR 0 1
6912: PPUSH
6913: LD_INT 1
6915: PPUSH
6916: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
6920: LD_VAR 0 1
6924: PPUSH
6925: LD_INT 88
6927: PPUSH
6928: LD_INT 75
6930: PPUSH
6931: CALL_OW 297
6935: PUSH
6936: LD_INT 6
6938: GREATER
6939: IFFALSE 6956
// ComMoveXY ( i , 88 , 75 ) ;
6941: LD_VAR 0 1
6945: PPUSH
6946: LD_INT 88
6948: PPUSH
6949: LD_INT 75
6951: PPUSH
6952: CALL_OW 111
// end ;
6956: GO 6889
6958: POP
6959: POP
// end ;
6960: PPOPN 4
6962: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
6963: LD_EXP 7
6967: NOT
6968: PUSH
6969: LD_EXP 9
6973: AND
6974: PUSH
6975: LD_INT 9
6977: PPUSH
6978: LD_INT 22
6980: PUSH
6981: LD_INT 1
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PUSH
6988: LD_INT 21
6990: PUSH
6991: LD_INT 1
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: LD_INT 24
7003: PUSH
7004: LD_INT 1000
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: LIST
7019: PPUSH
7020: CALL_OW 70
7024: AND
7025: IFFALSE 7198
7027: GO 7029
7029: DISABLE
7030: LD_INT 0
7032: PPUSH
7033: PPUSH
7034: PPUSH
// begin enable ;
7035: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7036: LD_ADDR_VAR 0 2
7040: PUSH
7041: LD_INT 22
7043: PUSH
7044: LD_INT 1
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: PUSH
7051: LD_INT 25
7053: PUSH
7054: LD_INT 4
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PPUSH
7065: CALL_OW 69
7069: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7070: LD_ADDR_VAR 0 3
7074: PUSH
7075: LD_INT 9
7077: PPUSH
7078: LD_INT 22
7080: PUSH
7081: LD_INT 1
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: LD_INT 21
7090: PUSH
7091: LD_INT 1
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 3
7100: PUSH
7101: LD_INT 24
7103: PUSH
7104: LD_INT 1000
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: LIST
7119: PPUSH
7120: CALL_OW 70
7124: ST_TO_ADDR
// if not sci or not tmp then
7125: LD_VAR 0 2
7129: NOT
7130: PUSH
7131: LD_VAR 0 3
7135: NOT
7136: OR
7137: IFFALSE 7141
// exit ;
7139: GO 7198
// for i in sci do
7141: LD_ADDR_VAR 0 1
7145: PUSH
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_IN
7152: IFFALSE 7196
// if IsInUnit ( i ) then
7154: LD_VAR 0 1
7158: PPUSH
7159: CALL_OW 310
7163: IFFALSE 7176
// ComExitBuilding ( i ) else
7165: LD_VAR 0 1
7169: PPUSH
7170: CALL_OW 122
7174: GO 7194
// ComHeal ( i , tmp [ 1 ] ) ;
7176: LD_VAR 0 1
7180: PPUSH
7181: LD_VAR 0 3
7185: PUSH
7186: LD_INT 1
7188: ARRAY
7189: PPUSH
7190: CALL_OW 128
7194: GO 7151
7196: POP
7197: POP
// end ;
7198: PPOPN 3
7200: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7201: LD_EXP 7
7205: NOT
7206: PUSH
7207: LD_EXP 9
7211: AND
7212: PUSH
7213: LD_INT 1
7215: PPUSH
7216: CALL_OW 302
7220: AND
7221: PUSH
7222: LD_INT 9
7224: PPUSH
7225: LD_INT 22
7227: PUSH
7228: LD_INT 1
7230: PUSH
7231: EMPTY
7232: LIST
7233: LIST
7234: PUSH
7235: LD_INT 21
7237: PUSH
7238: LD_INT 1
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 24
7250: PUSH
7251: LD_INT 1000
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: PPUSH
7267: CALL_OW 70
7271: NOT
7272: AND
7273: PUSH
7274: LD_INT 22
7276: PUSH
7277: LD_INT 1
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PUSH
7284: LD_INT 25
7286: PUSH
7287: LD_INT 4
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: PUSH
7294: LD_INT 56
7296: PUSH
7297: EMPTY
7298: LIST
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: LIST
7304: PPUSH
7305: CALL_OW 69
7309: AND
7310: IFFALSE 7403
7312: GO 7314
7314: DISABLE
7315: LD_INT 0
7317: PPUSH
// begin enable ;
7318: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7319: LD_ADDR_VAR 0 1
7323: PUSH
7324: LD_INT 22
7326: PUSH
7327: LD_INT 1
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 25
7336: PUSH
7337: LD_INT 4
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 56
7346: PUSH
7347: EMPTY
7348: LIST
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL_OW 69
7359: PUSH
7360: FOR_IN
7361: IFFALSE 7401
// if not GetTag ( i ) and not HasTask ( i ) then
7363: LD_VAR 0 1
7367: PPUSH
7368: CALL_OW 110
7372: NOT
7373: PUSH
7374: LD_VAR 0 1
7378: PPUSH
7379: CALL_OW 314
7383: NOT
7384: AND
7385: IFFALSE 7399
// ComEnterUnit ( i , us_lab ) ;
7387: LD_VAR 0 1
7391: PPUSH
7392: LD_INT 1
7394: PPUSH
7395: CALL_OW 120
7399: GO 7360
7401: POP
7402: POP
// end ;
7403: PPOPN 1
7405: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7406: LD_EXP 7
7410: NOT
7411: PUSH
7412: LD_INT 9
7414: PPUSH
7415: LD_INT 22
7417: PUSH
7418: LD_INT 1
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: LD_INT 21
7427: PUSH
7428: LD_INT 3
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: PUSH
7435: LD_INT 3
7437: PUSH
7438: LD_INT 24
7440: PUSH
7441: LD_INT 1000
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: PPUSH
7457: CALL_OW 70
7461: NOT
7462: AND
7463: PUSH
7464: LD_INT 22
7466: PUSH
7467: LD_INT 1
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 25
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 56
7486: PUSH
7487: EMPTY
7488: LIST
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: PPUSH
7495: CALL_OW 69
7499: AND
7500: IFFALSE 7593
7502: GO 7504
7504: DISABLE
7505: LD_INT 0
7507: PPUSH
// begin enable ;
7508: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7509: LD_ADDR_VAR 0 1
7513: PUSH
7514: LD_INT 22
7516: PUSH
7517: LD_INT 1
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PUSH
7524: LD_INT 25
7526: PUSH
7527: LD_INT 2
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: LD_INT 56
7536: PUSH
7537: EMPTY
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL_OW 69
7549: PUSH
7550: FOR_IN
7551: IFFALSE 7591
// if not HasTask ( i ) and not GetTag ( i ) then
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 314
7562: NOT
7563: PUSH
7564: LD_VAR 0 1
7568: PPUSH
7569: CALL_OW 110
7573: NOT
7574: AND
7575: IFFALSE 7589
// ComEnterUnit ( i , us_depot ) ;
7577: LD_VAR 0 1
7581: PPUSH
7582: LD_INT 5
7584: PPUSH
7585: CALL_OW 120
7589: GO 7550
7591: POP
7592: POP
// end ;
7593: PPOPN 1
7595: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7596: LD_EXP 9
7600: PUSH
7601: LD_INT 0
7603: LESSEQUAL
7604: PUSH
7605: LD_EXP 16
7609: PPUSH
7610: CALL_OW 301
7614: OR
7615: PUSH
7616: LD_INT 22
7618: PUSH
7619: LD_INT 1
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: PUSH
7626: LD_INT 25
7628: PUSH
7629: LD_INT 2
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 69
7644: AND
7645: IFFALSE 7686
7647: GO 7649
7649: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7650: LD_INT 22
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: LD_INT 25
7662: PUSH
7663: LD_INT 2
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PPUSH
7674: CALL_OW 69
7678: PPUSH
7679: LD_INT 1
7681: PPUSH
7682: CALL_OW 167
7686: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7687: LD_EXP 7
7691: NOT
7692: PUSH
7693: LD_INT 7
7695: PPUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 7
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PPUSH
7706: CALL_OW 70
7710: AND
7711: IFFALSE 7802
7713: GO 7715
7715: DISABLE
7716: LD_INT 0
7718: PPUSH
// begin wait ( 0 0$2 ) ;
7719: LD_INT 70
7721: PPUSH
7722: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7726: LD_ADDR_VAR 0 1
7730: PUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: LD_INT 25
7743: PUSH
7744: LD_INT 1
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 69
7759: PUSH
7760: FOR_IN
7761: IFFALSE 7800
// begin if IsInUnit ( i ) then
7763: LD_VAR 0 1
7767: PPUSH
7768: CALL_OW 310
7772: IFFALSE 7783
// ComExitBuilding ( i ) ;
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7783: LD_VAR 0 1
7787: PPUSH
7788: LD_INT 92
7790: PPUSH
7791: LD_INT 78
7793: PPUSH
7794: CALL_OW 174
// end ;
7798: GO 7760
7800: POP
7801: POP
// end ; end_of_file
7802: PPOPN 1
7804: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7805: LD_VAR 0 1
7809: PPUSH
7810: LD_VAR 0 2
7814: PPUSH
7815: LD_VAR 0 3
7819: PPUSH
7820: CALL 2786 0 3
7824: PPOPN 3
7826: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7827: LD_EXP 12
7831: PPUSH
7832: CALL_OW 257
7836: PUSH
7837: LD_INT 4
7839: EQUAL
7840: PUSH
7841: LD_EXP 13
7845: PPUSH
7846: CALL_OW 257
7850: PUSH
7851: LD_INT 4
7853: EQUAL
7854: OR
7855: IFFALSE 7859
// exit ;
7857: GO 7897
// if un = JMM then
7859: LD_VAR 0 1
7863: PUSH
7864: LD_EXP 12
7868: EQUAL
7869: IFFALSE 7878
// YouLost ( JMM ) ;
7871: LD_STRING JMM
7873: PPUSH
7874: CALL_OW 104
// if un = Burlak then
7878: LD_VAR 0 1
7882: PUSH
7883: LD_EXP 13
7887: EQUAL
7888: IFFALSE 7897
// YouLost ( Burlak ) ;
7890: LD_STRING Burlak
7892: PPUSH
7893: CALL_OW 104
// end ;
7897: PPOPN 1
7899: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7900: LD_VAR 0 1
7904: PUSH
7905: LD_EXP 12
7909: EQUAL
7910: IFFALSE 7919
// YouLost ( JMM ) ;
7912: LD_STRING JMM
7914: PPUSH
7915: CALL_OW 104
// if un = Burlak then
7919: LD_VAR 0 1
7923: PUSH
7924: LD_EXP 13
7928: EQUAL
7929: IFFALSE 7938
// YouLost ( Burlak ) ;
7931: LD_STRING Burlak
7933: PPUSH
7934: CALL_OW 104
// end ;
7938: PPOPN 1
7940: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
7941: LD_VAR 0 1
7945: PPUSH
7946: CALL_OW 255
7950: PUSH
7951: LD_INT 7
7953: EQUAL
7954: IFFALSE 7964
// artifactPickedUp := true ;
7956: LD_ADDR_EXP 6
7960: PUSH
7961: LD_INT 1
7963: ST_TO_ADDR
// end ;
7964: PPOPN 2
7966: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
7967: LD_ADDR_EXP 6
7971: PUSH
7972: LD_INT 0
7974: ST_TO_ADDR
7975: PPOPN 2
7977: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
7978: LD_VAR 0 1
7982: PPUSH
7983: CALL_OW 255
7987: PUSH
7988: LD_INT 1
7990: NONEQUAL
7991: IFFALSE 7995
// exit ;
7993: GO 8042
// wait ( 0 0$5 ) ;
7995: LD_INT 175
7997: PPUSH
7998: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8002: LD_VAR 0 1
8006: PPUSH
8007: CALL_OW 263
8011: PUSH
8012: LD_INT 2
8014: EQUAL
8015: IFFALSE 8026
// Connect ( vehicle ) ;
8017: LD_VAR 0 1
8021: PPUSH
8022: CALL 1787 0 1
// vehGuard := vehGuard ^ vehicle ;
8026: LD_ADDR_EXP 21
8030: PUSH
8031: LD_EXP 21
8035: PUSH
8036: LD_VAR 0 1
8040: ADD
8041: ST_TO_ADDR
// end ;
8042: PPOPN 2
8044: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8045: LD_VAR 0 1
8049: PUSH
8050: LD_INT 1
8052: EQUAL
8053: PUSH
8054: LD_EXP 7
8058: NOT
8059: AND
8060: IFFALSE 8095
// begin planCaptured := true ;
8062: LD_ADDR_EXP 7
8066: PUSH
8067: LD_INT 1
8069: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8070: LD_STRING MEnd
8072: PPUSH
8073: CALL_OW 337
// canEnd := true ;
8077: LD_ADDR_EXP 10
8081: PUSH
8082: LD_INT 1
8084: ST_TO_ADDR
// missionTime := tick ;
8085: LD_ADDR_EXP 11
8089: PUSH
8090: LD_OWVAR 1
8094: ST_TO_ADDR
// end ; end ;
8095: PPOPN 3
8097: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: CALL 8252 0 1
// end ; end_of_file
8107: PPOPN 1
8109: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8110: GO 8112
8112: DISABLE
// begin ru_radar := 98 ;
8113: LD_ADDR_EXP 22
8117: PUSH
8118: LD_INT 98
8120: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8121: LD_ADDR_EXP 23
8125: PUSH
8126: LD_INT 89
8128: ST_TO_ADDR
// us_hack := 99 ;
8129: LD_ADDR_EXP 24
8133: PUSH
8134: LD_INT 99
8136: ST_TO_ADDR
// us_artillery := 97 ;
8137: LD_ADDR_EXP 25
8141: PUSH
8142: LD_INT 97
8144: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8145: LD_ADDR_EXP 26
8149: PUSH
8150: LD_INT 91
8152: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8153: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8154: LD_INT 0
8156: PPUSH
8157: PPUSH
8158: PPUSH
8159: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8160: LD_VAR 0 1
8164: PPUSH
8165: CALL_OW 264
8169: PUSH
8170: LD_EXP 26
8174: EQUAL
8175: IFFALSE 8247
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8177: LD_INT 68
8179: PPUSH
8180: LD_VAR 0 1
8184: PPUSH
8185: CALL_OW 255
8189: PPUSH
8190: CALL_OW 321
8194: PUSH
8195: LD_INT 2
8197: EQUAL
8198: IFFALSE 8210
// eff := 70 else
8200: LD_ADDR_VAR 0 6
8204: PUSH
8205: LD_INT 70
8207: ST_TO_ADDR
8208: GO 8218
// eff := 30 ;
8210: LD_ADDR_VAR 0 6
8214: PUSH
8215: LD_INT 30
8217: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 250
8227: PPUSH
8228: LD_VAR 0 1
8232: PPUSH
8233: CALL_OW 251
8237: PPUSH
8238: LD_VAR 0 6
8242: PPUSH
8243: CALL_OW 495
// end ; end ;
8247: LD_VAR 0 4
8251: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8252: LD_INT 0
8254: PPUSH
8255: PPUSH
8256: PPUSH
8257: PPUSH
8258: PPUSH
8259: PPUSH
// if cmd = 124 then
8260: LD_VAR 0 1
8264: PUSH
8265: LD_INT 124
8267: EQUAL
8268: IFFALSE 8474
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8270: LD_ADDR_VAR 0 5
8274: PUSH
8275: LD_INT 2
8277: PUSH
8278: LD_INT 34
8280: PUSH
8281: LD_INT 53
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 34
8290: PUSH
8291: LD_INT 14
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: PPUSH
8303: CALL_OW 69
8307: ST_TO_ADDR
// if not tmp then
8308: LD_VAR 0 5
8312: NOT
8313: IFFALSE 8317
// exit ;
8315: GO 8474
// for i in tmp do
8317: LD_ADDR_VAR 0 3
8321: PUSH
8322: LD_VAR 0 5
8326: PUSH
8327: FOR_IN
8328: IFFALSE 8472
// begin taskList := GetTaskList ( i ) ;
8330: LD_ADDR_VAR 0 6
8334: PUSH
8335: LD_VAR 0 3
8339: PPUSH
8340: CALL_OW 437
8344: ST_TO_ADDR
// if not taskList then
8345: LD_VAR 0 6
8349: NOT
8350: IFFALSE 8354
// continue ;
8352: GO 8327
// for j = 1 to taskList do
8354: LD_ADDR_VAR 0 4
8358: PUSH
8359: DOUBLE
8360: LD_INT 1
8362: DEC
8363: ST_TO_ADDR
8364: LD_VAR 0 6
8368: PUSH
8369: FOR_TO
8370: IFFALSE 8468
// if taskList [ j ] [ 1 ] = | then
8372: LD_VAR 0 6
8376: PUSH
8377: LD_VAR 0 4
8381: ARRAY
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_STRING |
8389: EQUAL
8390: IFFALSE 8466
// begin _taskList := Delete ( taskList , 1 ) ;
8392: LD_ADDR_VAR 0 7
8396: PUSH
8397: LD_VAR 0 6
8401: PPUSH
8402: LD_INT 1
8404: PPUSH
8405: CALL_OW 3
8409: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8410: LD_VAR 0 3
8414: PPUSH
8415: LD_VAR 0 7
8419: PPUSH
8420: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8424: LD_VAR 0 3
8428: PPUSH
8429: LD_VAR 0 6
8433: PUSH
8434: LD_VAR 0 4
8438: ARRAY
8439: PUSH
8440: LD_INT 2
8442: ARRAY
8443: PPUSH
8444: LD_VAR 0 6
8448: PUSH
8449: LD_VAR 0 4
8453: ARRAY
8454: PUSH
8455: LD_INT 3
8457: ARRAY
8458: PPUSH
8459: LD_INT 8
8461: PPUSH
8462: CALL 8479 0 4
// end ;
8466: GO 8369
8468: POP
8469: POP
// end ;
8470: GO 8327
8472: POP
8473: POP
// end ; end ;
8474: LD_VAR 0 2
8478: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8479: LD_INT 0
8481: PPUSH
8482: PPUSH
8483: PPUSH
8484: PPUSH
8485: PPUSH
8486: PPUSH
8487: PPUSH
8488: PPUSH
8489: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8490: LD_VAR 0 1
8494: NOT
8495: PUSH
8496: LD_VAR 0 2
8500: PPUSH
8501: LD_VAR 0 3
8505: PPUSH
8506: CALL_OW 488
8510: NOT
8511: OR
8512: PUSH
8513: LD_VAR 0 4
8517: NOT
8518: OR
8519: IFFALSE 8523
// exit ;
8521: GO 8863
// list := [ ] ;
8523: LD_ADDR_VAR 0 13
8527: PUSH
8528: EMPTY
8529: ST_TO_ADDR
// if x - r < 0 then
8530: LD_VAR 0 2
8534: PUSH
8535: LD_VAR 0 4
8539: MINUS
8540: PUSH
8541: LD_INT 0
8543: LESS
8544: IFFALSE 8556
// min_x := 0 else
8546: LD_ADDR_VAR 0 7
8550: PUSH
8551: LD_INT 0
8553: ST_TO_ADDR
8554: GO 8572
// min_x := x - r ;
8556: LD_ADDR_VAR 0 7
8560: PUSH
8561: LD_VAR 0 2
8565: PUSH
8566: LD_VAR 0 4
8570: MINUS
8571: ST_TO_ADDR
// if y - r < 0 then
8572: LD_VAR 0 3
8576: PUSH
8577: LD_VAR 0 4
8581: MINUS
8582: PUSH
8583: LD_INT 0
8585: LESS
8586: IFFALSE 8598
// min_y := 0 else
8588: LD_ADDR_VAR 0 8
8592: PUSH
8593: LD_INT 0
8595: ST_TO_ADDR
8596: GO 8614
// min_y := y - r ;
8598: LD_ADDR_VAR 0 8
8602: PUSH
8603: LD_VAR 0 3
8607: PUSH
8608: LD_VAR 0 4
8612: MINUS
8613: ST_TO_ADDR
// max_x := x + r ;
8614: LD_ADDR_VAR 0 9
8618: PUSH
8619: LD_VAR 0 2
8623: PUSH
8624: LD_VAR 0 4
8628: PLUS
8629: ST_TO_ADDR
// max_y := y + r ;
8630: LD_ADDR_VAR 0 10
8634: PUSH
8635: LD_VAR 0 3
8639: PUSH
8640: LD_VAR 0 4
8644: PLUS
8645: ST_TO_ADDR
// for _x = min_x to max_x do
8646: LD_ADDR_VAR 0 11
8650: PUSH
8651: DOUBLE
8652: LD_VAR 0 7
8656: DEC
8657: ST_TO_ADDR
8658: LD_VAR 0 9
8662: PUSH
8663: FOR_TO
8664: IFFALSE 8781
// for _y = min_y to max_y do
8666: LD_ADDR_VAR 0 12
8670: PUSH
8671: DOUBLE
8672: LD_VAR 0 8
8676: DEC
8677: ST_TO_ADDR
8678: LD_VAR 0 10
8682: PUSH
8683: FOR_TO
8684: IFFALSE 8777
// begin if not ValidHex ( _x , _y ) then
8686: LD_VAR 0 11
8690: PPUSH
8691: LD_VAR 0 12
8695: PPUSH
8696: CALL_OW 488
8700: NOT
8701: IFFALSE 8705
// continue ;
8703: GO 8683
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
8705: LD_VAR 0 11
8709: PPUSH
8710: LD_VAR 0 12
8714: PPUSH
8715: CALL_OW 351
8719: PUSH
8720: LD_VAR 0 11
8724: PPUSH
8725: LD_VAR 0 12
8729: PPUSH
8730: CALL_OW 554
8734: AND
8735: IFFALSE 8775
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
8737: LD_ADDR_VAR 0 13
8741: PUSH
8742: LD_VAR 0 13
8746: PPUSH
8747: LD_VAR 0 13
8751: PUSH
8752: LD_INT 1
8754: PLUS
8755: PPUSH
8756: LD_VAR 0 11
8760: PUSH
8761: LD_VAR 0 12
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: PPUSH
8770: CALL_OW 2
8774: ST_TO_ADDR
// end ;
8775: GO 8683
8777: POP
8778: POP
8779: GO 8663
8781: POP
8782: POP
// if not list then
8783: LD_VAR 0 13
8787: NOT
8788: IFFALSE 8792
// exit ;
8790: GO 8863
// for i in list do
8792: LD_ADDR_VAR 0 6
8796: PUSH
8797: LD_VAR 0 13
8801: PUSH
8802: FOR_IN
8803: IFFALSE 8861
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
8805: LD_VAR 0 1
8809: PPUSH
8810: LD_STRING M
8812: PUSH
8813: LD_VAR 0 6
8817: PUSH
8818: LD_INT 1
8820: ARRAY
8821: PUSH
8822: LD_VAR 0 6
8826: PUSH
8827: LD_INT 2
8829: ARRAY
8830: PUSH
8831: LD_INT 0
8833: PUSH
8834: LD_INT 0
8836: PUSH
8837: LD_INT 0
8839: PUSH
8840: LD_INT 0
8842: PUSH
8843: EMPTY
8844: LIST
8845: LIST
8846: LIST
8847: LIST
8848: LIST
8849: LIST
8850: LIST
8851: PUSH
8852: EMPTY
8853: LIST
8854: PPUSH
8855: CALL_OW 447
8859: GO 8802
8861: POP
8862: POP
// end ;
8863: LD_VAR 0 5
8867: RET
