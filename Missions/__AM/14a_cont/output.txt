// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 992 0 9
// PrepareAmerican ;
  46: CALL 5180 0 0
// PrepareAlliance ;
  50: CALL 189 0 0
// Action ;
  54: CALL 2141 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 11 11$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 23100
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
// uc_side := 7 ;
 198: LD_ADDR_OWVAR 20
 202: PUSH
 203: LD_INT 7
 205: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 206: LD_ADDR_EXP 12
 210: PUSH
 211: LD_STRING JMM
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 14a_
 222: PPUSH
 223: CALL 871 0 3
 227: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 228: LD_ADDR_EXP 13
 232: PUSH
 233: LD_STRING Burlak
 235: PPUSH
 236: LD_EXP 1
 240: NOT
 241: PPUSH
 242: LD_STRING 14a_
 244: PPUSH
 245: CALL 871 0 3
 249: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 250: LD_ADDR_EXP 14
 254: PUSH
 255: LD_STRING Joan
 257: PPUSH
 258: LD_EXP 1
 262: NOT
 263: PPUSH
 264: LD_STRING 13a_
 266: PPUSH
 267: CALL 871 0 3
 271: ST_TO_ADDR
// if not Joan then
 272: LD_EXP 14
 276: NOT
 277: IFFALSE 410
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 279: LD_ADDR_VAR 0 2
 283: PUSH
 284: LD_STRING 13a_others
 286: PPUSH
 287: CALL_OW 31
 291: ST_TO_ADDR
// if tmp then
 292: LD_VAR 0 2
 296: IFFALSE 372
// begin for i in tmp do
 298: LD_ADDR_VAR 0 3
 302: PUSH
 303: LD_VAR 0 2
 307: PUSH
 308: FOR_IN
 309: IFFALSE 370
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 311: LD_VAR 0 3
 315: PPUSH
 316: CALL_OW 257
 320: PUSH
 321: LD_INT 4
 323: EQUAL
 324: PUSH
 325: LD_VAR 0 3
 329: PPUSH
 330: CALL_OW 258
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: PUSH
 340: LD_VAR 0 3
 344: PPUSH
 345: CALL_OW 248
 349: PUSH
 350: LD_INT 3
 352: EQUAL
 353: AND
 354: IFFALSE 368
// begin RuSci := i ;
 356: LD_ADDR_EXP 15
 360: PUSH
 361: LD_VAR 0 3
 365: ST_TO_ADDR
// break ;
 366: GO 370
// end ;
 368: GO 308
 370: POP
 371: POP
// end ; if not RuSci then
 372: LD_EXP 15
 376: NOT
 377: IFFALSE 410
// begin uc_nation := 3 ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 10
 395: PPUSH
 396: CALL_OW 380
// RuSci := CreateHuman ;
 400: LD_ADDR_EXP 15
 404: PUSH
 405: CALL_OW 44
 409: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 410: LD_ADDR_VAR 0 6
 414: PUSH
 415: LD_STRING 14a_JMMVeh
 417: PPUSH
 418: LD_INT 5
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 1
 426: PUSH
 427: LD_INT 7
 429: PUSH
 430: LD_INT 0
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: PPUSH
 444: CALL_OW 30
 448: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 449: LD_ADDR_VAR 0 7
 453: PUSH
 454: LD_STRING 14a_BurlakVeh
 456: PPUSH
 457: LD_INT 22
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 51
 468: PUSH
 469: LD_INT 0
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 30
 487: ST_TO_ADDR
// uc_direction := 4 ;
 488: LD_ADDR_OWVAR 24
 492: PUSH
 493: LD_INT 4
 495: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 496: LD_ADDR_OWVAR 21
 500: PUSH
 501: LD_VAR 0 6
 505: PUSH
 506: LD_INT 6
 508: ARRAY
 509: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 510: LD_VAR 0 6
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 2
 526: ARRAY
 527: PPUSH
 528: LD_VAR 0 6
 532: PUSH
 533: LD_INT 3
 535: ARRAY
 536: PPUSH
 537: LD_VAR 0 6
 541: PUSH
 542: LD_INT 4
 544: ARRAY
 545: PPUSH
 546: LD_INT 60
 548: PPUSH
 549: LD_INT 80
 551: PPUSH
 552: CALL_OW 12
 556: PPUSH
 557: CALL 934 0 5
// JMMVeh := CreateVehicle ;
 561: LD_ADDR_VAR 0 4
 565: PUSH
 566: CALL_OW 45
 570: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 571: LD_VAR 0 4
 575: PPUSH
 576: LD_INT 1
 578: PPUSH
 579: LD_INT 0
 581: PPUSH
 582: CALL 1596 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 586: LD_VAR 0 6
 590: PUSH
 591: LD_INT 5
 593: ARRAY
 594: PUSH
 595: LD_INT 0
 597: NONEQUAL
 598: IFFALSE 618
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_VAR 0 6
 609: PUSH
 610: LD_INT 5
 612: ARRAY
 613: PPUSH
 614: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 618: LD_EXP 12
 622: PPUSH
 623: LD_VAR 0 4
 627: PPUSH
 628: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 632: LD_ADDR_OWVAR 21
 636: PUSH
 637: LD_VAR 0 7
 641: PUSH
 642: LD_INT 6
 644: ARRAY
 645: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 646: LD_VAR 0 7
 650: PUSH
 651: LD_INT 1
 653: ARRAY
 654: PPUSH
 655: LD_VAR 0 7
 659: PUSH
 660: LD_INT 2
 662: ARRAY
 663: PPUSH
 664: LD_VAR 0 7
 668: PUSH
 669: LD_INT 3
 671: ARRAY
 672: PPUSH
 673: LD_VAR 0 7
 677: PUSH
 678: LD_INT 4
 680: ARRAY
 681: PPUSH
 682: LD_INT 60
 684: PPUSH
 685: LD_INT 80
 687: PPUSH
 688: CALL_OW 12
 692: PPUSH
 693: CALL 934 0 5
// BurlakVeh := CreateVehicle ;
 697: LD_ADDR_VAR 0 5
 701: PUSH
 702: CALL_OW 45
 706: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 707: LD_VAR 0 5
 711: PPUSH
 712: LD_INT 1
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL 1596 0 3
 722: NOT
 723: IFFALSE 743
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 725: LD_VAR 0 5
 729: PPUSH
 730: LD_INT 233
 732: PPUSH
 733: LD_INT 85
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 743: LD_VAR 0 7
 747: PUSH
 748: LD_INT 5
 750: ARRAY
 751: PUSH
 752: LD_INT 0
 754: NONEQUAL
 755: IFFALSE 775
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 757: LD_VAR 0 5
 761: PPUSH
 762: LD_VAR 0 7
 766: PUSH
 767: LD_INT 5
 769: ARRAY
 770: PPUSH
 771: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 775: LD_EXP 13
 779: PPUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 178
 796: PUSH
 797: LD_INT 91
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: PUSH
 804: LD_INT 137
 806: PUSH
 807: LD_INT 83
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 157
 816: PUSH
 817: LD_INT 75
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: LIST
 828: PUSH
 829: LD_OWVAR 67
 833: ARRAY
 834: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 835: LD_INT 4
 837: PPUSH
 838: LD_INT 4
 840: PPUSH
 841: LD_VAR 0 2
 845: PUSH
 846: LD_INT 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 2
 854: PUSH
 855: LD_INT 2
 857: ARRAY
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 58
// end ; end_of_file
 866: LD_VAR 0 1
 870: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 871: LD_INT 0
 873: PPUSH
 874: PPUSH
// if exist_mode then
 875: LD_VAR 0 2
 879: IFFALSE 904
// unit := CreateCharacter ( prefix & ident ) else
 881: LD_ADDR_VAR 0 5
 885: PUSH
 886: LD_VAR 0 3
 890: PUSH
 891: LD_VAR 0 1
 895: STR
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
 902: GO 919
// unit := NewCharacter ( ident ) ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 25
 918: ST_TO_ADDR
// result := unit ;
 919: LD_ADDR_VAR 0 4
 923: PUSH
 924: LD_VAR 0 5
 928: ST_TO_ADDR
// end ;
 929: LD_VAR 0 4
 933: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 934: LD_INT 0
 936: PPUSH
// vc_chassis := chassis ;
 937: LD_ADDR_OWVAR 37
 941: PUSH
 942: LD_VAR 0 1
 946: ST_TO_ADDR
// vc_engine := engine ;
 947: LD_ADDR_OWVAR 39
 951: PUSH
 952: LD_VAR 0 2
 956: ST_TO_ADDR
// vc_control := control ;
 957: LD_ADDR_OWVAR 38
 961: PUSH
 962: LD_VAR 0 3
 966: ST_TO_ADDR
// vc_weapon := weapon ;
 967: LD_ADDR_OWVAR 40
 971: PUSH
 972: LD_VAR 0 4
 976: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 977: LD_ADDR_OWVAR 41
 981: PUSH
 982: LD_VAR 0 5
 986: ST_TO_ADDR
// end ;
 987: LD_VAR 0 6
 991: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
// uc_side = 0 ;
 997: LD_ADDR_OWVAR 20
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// uc_nation = 0 ;
1005: LD_ADDR_OWVAR 21
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// InitHc ;
1013: CALL_OW 19
// InitVc ;
1017: CALL_OW 20
// if mastodonts then
1021: LD_VAR 0 6
1025: IFFALSE 1092
// for i = 1 to mastodonts do
1027: LD_ADDR_VAR 0 11
1031: PUSH
1032: DOUBLE
1033: LD_INT 1
1035: DEC
1036: ST_TO_ADDR
1037: LD_VAR 0 6
1041: PUSH
1042: FOR_TO
1043: IFFALSE 1090
// begin vc_chassis := 31 ;
1045: LD_ADDR_OWVAR 37
1049: PUSH
1050: LD_INT 31
1052: ST_TO_ADDR
// vc_control := control_rider ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_INT 4
1060: ST_TO_ADDR
// animal := CreateVehicle ;
1061: LD_ADDR_VAR 0 12
1065: PUSH
1066: CALL_OW 45
1070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1071: LD_VAR 0 12
1075: PPUSH
1076: LD_VAR 0 8
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL 1596 0 3
// end ;
1088: GO 1042
1090: POP
1091: POP
// if horses then
1092: LD_VAR 0 5
1096: IFFALSE 1163
// for i = 1 to horses do
1098: LD_ADDR_VAR 0 11
1102: PUSH
1103: DOUBLE
1104: LD_INT 1
1106: DEC
1107: ST_TO_ADDR
1108: LD_VAR 0 5
1112: PUSH
1113: FOR_TO
1114: IFFALSE 1161
// begin hc_class := 21 ;
1116: LD_ADDR_OWVAR 28
1120: PUSH
1121: LD_INT 21
1123: ST_TO_ADDR
// hc_gallery :=  ;
1124: LD_ADDR_OWVAR 33
1128: PUSH
1129: LD_STRING 
1131: ST_TO_ADDR
// animal := CreateHuman ;
1132: LD_ADDR_VAR 0 12
1136: PUSH
1137: CALL_OW 44
1141: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1142: LD_VAR 0 12
1146: PPUSH
1147: LD_VAR 0 8
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL 1596 0 3
// end ;
1159: GO 1113
1161: POP
1162: POP
// if birds then
1163: LD_VAR 0 1
1167: IFFALSE 1234
// for i = 1 to birds do
1169: LD_ADDR_VAR 0 11
1173: PUSH
1174: DOUBLE
1175: LD_INT 1
1177: DEC
1178: ST_TO_ADDR
1179: LD_VAR 0 1
1183: PUSH
1184: FOR_TO
1185: IFFALSE 1232
// begin hc_class = 18 ;
1187: LD_ADDR_OWVAR 28
1191: PUSH
1192: LD_INT 18
1194: ST_TO_ADDR
// hc_gallery =  ;
1195: LD_ADDR_OWVAR 33
1199: PUSH
1200: LD_STRING 
1202: ST_TO_ADDR
// animal := CreateHuman ;
1203: LD_ADDR_VAR 0 12
1207: PUSH
1208: CALL_OW 44
1212: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1213: LD_VAR 0 12
1217: PPUSH
1218: LD_VAR 0 8
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL 1596 0 3
// end ;
1230: GO 1184
1232: POP
1233: POP
// if tigers then
1234: LD_VAR 0 2
1238: IFFALSE 1322
// for i = 1 to tigers do
1240: LD_ADDR_VAR 0 11
1244: PUSH
1245: DOUBLE
1246: LD_INT 1
1248: DEC
1249: ST_TO_ADDR
1250: LD_VAR 0 2
1254: PUSH
1255: FOR_TO
1256: IFFALSE 1320
// begin hc_class = class_tiger ;
1258: LD_ADDR_OWVAR 28
1262: PUSH
1263: LD_INT 14
1265: ST_TO_ADDR
// hc_gallery =  ;
1266: LD_ADDR_OWVAR 33
1270: PUSH
1271: LD_STRING 
1273: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1274: LD_ADDR_OWVAR 35
1278: PUSH
1279: LD_INT 7
1281: NEG
1282: PPUSH
1283: LD_INT 7
1285: PPUSH
1286: CALL_OW 12
1290: ST_TO_ADDR
// animal := CreateHuman ;
1291: LD_ADDR_VAR 0 12
1295: PUSH
1296: CALL_OW 44
1300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1301: LD_VAR 0 12
1305: PPUSH
1306: LD_VAR 0 8
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL 1596 0 3
// end ;
1318: GO 1255
1320: POP
1321: POP
// if apemans then
1322: LD_VAR 0 3
1326: IFFALSE 1449
// for i = 1 to apemans do
1328: LD_ADDR_VAR 0 11
1332: PUSH
1333: DOUBLE
1334: LD_INT 1
1336: DEC
1337: ST_TO_ADDR
1338: LD_VAR 0 3
1342: PUSH
1343: FOR_TO
1344: IFFALSE 1447
// begin hc_class = class_apeman ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 12
1353: ST_TO_ADDR
// hc_gallery =  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1362: LD_ADDR_OWVAR 35
1366: PUSH
1367: LD_INT 5
1369: NEG
1370: PPUSH
1371: LD_INT 5
1373: PPUSH
1374: CALL_OW 12
1378: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1379: LD_ADDR_OWVAR 31
1383: PUSH
1384: LD_INT 1
1386: PPUSH
1387: LD_INT 3
1389: PPUSH
1390: CALL_OW 12
1394: PUSH
1395: LD_INT 1
1397: PPUSH
1398: LD_INT 3
1400: PPUSH
1401: CALL_OW 12
1405: PUSH
1406: LD_INT 0
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: ST_TO_ADDR
// animal := CreateHuman ;
1418: LD_ADDR_VAR 0 12
1422: PUSH
1423: CALL_OW 44
1427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1428: LD_VAR 0 12
1432: PPUSH
1433: LD_VAR 0 8
1437: PPUSH
1438: LD_INT 0
1440: PPUSH
1441: CALL 1596 0 3
// end ;
1445: GO 1343
1447: POP
1448: POP
// if enchidnas then
1449: LD_VAR 0 4
1453: IFFALSE 1520
// for i = 1 to enchidnas do
1455: LD_ADDR_VAR 0 11
1459: PUSH
1460: DOUBLE
1461: LD_INT 1
1463: DEC
1464: ST_TO_ADDR
1465: LD_VAR 0 4
1469: PUSH
1470: FOR_TO
1471: IFFALSE 1518
// begin hc_class = 13 ;
1473: LD_ADDR_OWVAR 28
1477: PUSH
1478: LD_INT 13
1480: ST_TO_ADDR
// hc_gallery =  ;
1481: LD_ADDR_OWVAR 33
1485: PUSH
1486: LD_STRING 
1488: ST_TO_ADDR
// animal := CreateHuman ;
1489: LD_ADDR_VAR 0 12
1493: PUSH
1494: CALL_OW 44
1498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1499: LD_VAR 0 12
1503: PPUSH
1504: LD_VAR 0 8
1508: PPUSH
1509: LD_INT 0
1511: PPUSH
1512: CALL 1596 0 3
// end ;
1516: GO 1470
1518: POP
1519: POP
// if fishes then
1520: LD_VAR 0 7
1524: IFFALSE 1591
// for i = 1 to fishes do
1526: LD_ADDR_VAR 0 11
1530: PUSH
1531: DOUBLE
1532: LD_INT 1
1534: DEC
1535: ST_TO_ADDR
1536: LD_VAR 0 7
1540: PUSH
1541: FOR_TO
1542: IFFALSE 1589
// begin hc_class = 20 ;
1544: LD_ADDR_OWVAR 28
1548: PUSH
1549: LD_INT 20
1551: ST_TO_ADDR
// hc_gallery =  ;
1552: LD_ADDR_OWVAR 33
1556: PUSH
1557: LD_STRING 
1559: ST_TO_ADDR
// animal := CreateHuman ;
1560: LD_ADDR_VAR 0 12
1564: PUSH
1565: CALL_OW 44
1569: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1570: LD_VAR 0 12
1574: PPUSH
1575: LD_VAR 0 9
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL 1596 0 3
// end ;
1587: GO 1541
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 10
1595: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
// if not unit or not area then
1602: LD_VAR 0 1
1606: NOT
1607: PUSH
1608: LD_VAR 0 2
1612: NOT
1613: OR
1614: IFFALSE 1618
// exit ;
1616: GO 1782
// tmp := AreaToList ( area , i ) ;
1618: LD_ADDR_VAR 0 6
1622: PUSH
1623: LD_VAR 0 2
1627: PPUSH
1628: LD_VAR 0 5
1632: PPUSH
1633: CALL_OW 517
1637: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1638: LD_ADDR_VAR 0 5
1642: PUSH
1643: DOUBLE
1644: LD_INT 1
1646: DEC
1647: ST_TO_ADDR
1648: LD_VAR 0 6
1652: PUSH
1653: LD_INT 1
1655: ARRAY
1656: PUSH
1657: FOR_TO
1658: IFFALSE 1780
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1660: LD_ADDR_VAR 0 7
1664: PUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_INT 1
1672: ARRAY
1673: PUSH
1674: LD_VAR 0 5
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 6
1684: PUSH
1685: LD_INT 2
1687: ARRAY
1688: PUSH
1689: LD_VAR 0 5
1693: ARRAY
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1699: LD_VAR 0 7
1703: PUSH
1704: LD_INT 1
1706: ARRAY
1707: PPUSH
1708: LD_VAR 0 7
1712: PUSH
1713: LD_INT 2
1715: ARRAY
1716: PPUSH
1717: CALL_OW 428
1721: PUSH
1722: LD_INT 0
1724: EQUAL
1725: IFFALSE 1778
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1727: LD_VAR 0 1
1731: PPUSH
1732: LD_VAR 0 7
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_VAR 0 7
1745: PUSH
1746: LD_INT 2
1748: ARRAY
1749: PPUSH
1750: LD_VAR 0 3
1754: PPUSH
1755: CALL_OW 48
// result := IsPlaced ( unit ) ;
1759: LD_ADDR_VAR 0 4
1763: PUSH
1764: LD_VAR 0 1
1768: PPUSH
1769: CALL_OW 305
1773: ST_TO_ADDR
// exit ;
1774: POP
1775: POP
1776: GO 1782
// end ; end ;
1778: GO 1657
1780: POP
1781: POP
// end ;
1782: LD_VAR 0 4
1786: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
1791: PPUSH
1792: PPUSH
1793: PPUSH
1794: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1795: LD_VAR 0 1
1799: NOT
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 263
1810: PUSH
1811: LD_INT 2
1813: EQUAL
1814: NOT
1815: OR
1816: IFFALSE 1820
// exit ;
1818: GO 2136
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1820: LD_ADDR_VAR 0 6
1824: PUSH
1825: LD_INT 22
1827: PUSH
1828: LD_VAR 0 1
1832: PPUSH
1833: CALL_OW 255
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 2
1844: PUSH
1845: LD_INT 30
1847: PUSH
1848: LD_INT 36
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 34
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: PPUSH
1874: CALL_OW 69
1878: ST_TO_ADDR
// if not tmp then
1879: LD_VAR 0 6
1883: NOT
1884: IFFALSE 1888
// exit ;
1886: GO 2136
// result := [ ] ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: EMPTY
1894: ST_TO_ADDR
// for i in tmp do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: LD_VAR 0 6
1904: PUSH
1905: FOR_IN
1906: IFFALSE 1977
// begin t := UnitsInside ( i ) ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: LD_VAR 0 3
1917: PPUSH
1918: CALL_OW 313
1922: ST_TO_ADDR
// if t then
1923: LD_VAR 0 4
1927: IFFALSE 1975
// for j in t do
1929: LD_ADDR_VAR 0 7
1933: PUSH
1934: LD_VAR 0 4
1938: PUSH
1939: FOR_IN
1940: IFFALSE 1973
// result := Insert ( result , result + 1 , j ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_VAR 0 2
1956: PUSH
1957: LD_INT 1
1959: PLUS
1960: PPUSH
1961: LD_VAR 0 7
1965: PPUSH
1966: CALL_OW 2
1970: ST_TO_ADDR
1971: GO 1939
1973: POP
1974: POP
// end ;
1975: GO 1905
1977: POP
1978: POP
// if not result then
1979: LD_VAR 0 2
1983: NOT
1984: IFFALSE 1988
// exit ;
1986: GO 2136
// mech := result [ 1 ] ;
1988: LD_ADDR_VAR 0 5
1992: PUSH
1993: LD_VAR 0 2
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: ST_TO_ADDR
// if result > 1 then
2002: LD_VAR 0 2
2006: PUSH
2007: LD_INT 1
2009: GREATER
2010: IFFALSE 2122
// for i = 2 to result do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 2
2020: DEC
2021: ST_TO_ADDR
2022: LD_VAR 0 2
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2120
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2030: LD_ADDR_VAR 0 4
2034: PUSH
2035: LD_VAR 0 2
2039: PUSH
2040: LD_VAR 0 3
2044: ARRAY
2045: PPUSH
2046: LD_INT 3
2048: PPUSH
2049: CALL_OW 259
2053: PUSH
2054: LD_VAR 0 2
2058: PUSH
2059: LD_VAR 0 3
2063: ARRAY
2064: PPUSH
2065: CALL_OW 432
2069: MINUS
2070: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2071: LD_VAR 0 4
2075: PUSH
2076: LD_VAR 0 5
2080: PPUSH
2081: LD_INT 3
2083: PPUSH
2084: CALL_OW 259
2088: PUSH
2089: LD_VAR 0 5
2093: PPUSH
2094: CALL_OW 432
2098: MINUS
2099: GREATEREQUAL
2100: IFFALSE 2118
// mech := result [ i ] ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: ST_TO_ADDR
// end ;
2118: GO 2027
2120: POP
2121: POP
// ComLinkTo ( vehicle , mech ) ;
2122: LD_VAR 0 1
2126: PPUSH
2127: LD_VAR 0 5
2131: PPUSH
2132: CALL_OW 135
// end ; end_of_file
2136: LD_VAR 0 2
2140: RET
// export function Action ; begin
2141: LD_INT 0
2143: PPUSH
// InGameOn ;
2144: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2148: LD_INT 221
2150: PPUSH
2151: LD_INT 80
2153: PPUSH
2154: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2158: LD_EXP 12
2162: PUSH
2163: LD_EXP 13
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PPUSH
2172: LD_INT 217
2174: PPUSH
2175: LD_INT 79
2177: PPUSH
2178: CALL_OW 111
// wait ( 0 0$7 ) ;
2182: LD_INT 245
2184: PPUSH
2185: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2189: LD_EXP 12
2193: PUSH
2194: LD_EXP 13
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2207: LD_EXP 13
2211: PPUSH
2212: LD_STRING D2-Bur-1
2214: PPUSH
2215: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2219: LD_EXP 12
2223: PPUSH
2224: LD_STRING D2-JMM-1
2226: PPUSH
2227: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2231: LD_INT 18
2233: PPUSH
2234: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2238: LD_EXP 13
2242: PPUSH
2243: LD_EXP 12
2247: PPUSH
2248: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2252: LD_EXP 13
2256: PPUSH
2257: LD_STRING D2-Bur-2
2259: PPUSH
2260: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2264: LD_EXP 13
2268: PPUSH
2269: LD_INT 21
2271: PUSH
2272: LD_INT 2
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: PPUSH
2279: CALL_OW 69
2283: PPUSH
2284: LD_EXP 13
2288: PPUSH
2289: CALL_OW 74
2293: PPUSH
2294: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2298: LD_EXP 12
2302: PPUSH
2303: LD_INT 21
2305: PUSH
2306: LD_INT 2
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PPUSH
2313: CALL_OW 69
2317: PPUSH
2318: LD_EXP 12
2322: PPUSH
2323: CALL_OW 74
2327: PPUSH
2328: CALL_OW 120
// wait ( 0 0$1 ) ;
2332: LD_INT 35
2334: PPUSH
2335: CALL_OW 67
// InGameOff ;
2339: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2343: LD_STRING MArtPickup
2345: PPUSH
2346: CALL_OW 337
// end ;
2350: LD_VAR 0 1
2354: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2355: LD_EXP 20
2359: PPUSH
2360: LD_INT 101
2362: PUSH
2363: LD_INT 7
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: CALL_OW 72
2374: IFFALSE 2403
2376: GO 2378
2378: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2379: LD_EXP 13
2383: PPUSH
2384: LD_STRING D3-Bur-1
2386: PPUSH
2387: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2391: LD_EXP 12
2395: PPUSH
2396: LD_STRING D3-JMM-1
2398: PPUSH
2399: CALL_OW 88
// end ;
2403: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2404: LD_INT 5
2406: PPUSH
2407: LD_INT 22
2409: PUSH
2410: LD_INT 7
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PPUSH
2417: CALL_OW 70
2421: IFFALSE 2752
2423: GO 2425
2425: DISABLE
// begin wait ( 0 0$3 ) ;
2426: LD_INT 105
2428: PPUSH
2429: CALL_OW 67
// DialogueOn ;
2433: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2437: LD_EXP 12
2441: PPUSH
2442: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2446: LD_EXP 12
2450: PPUSH
2451: LD_STRING D3a-JMM-1
2453: PPUSH
2454: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2458: LD_EXP 13
2462: PPUSH
2463: LD_STRING D3a-Bur-1
2465: PPUSH
2466: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2470: LD_EXP 12
2474: PPUSH
2475: LD_STRING D3a-JMM-2
2477: PPUSH
2478: CALL_OW 88
// if Joan then
2482: LD_EXP 14
2486: IFFALSE 2502
// SayRadio ( Joan , D3a-Joan-2 ) else
2488: LD_EXP 14
2492: PPUSH
2493: LD_STRING D3a-Joan-2
2495: PPUSH
2496: CALL_OW 94
2500: GO 2514
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2502: LD_EXP 15
2506: PPUSH
2507: LD_STRING D3a-RSci1-2
2509: PPUSH
2510: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2514: LD_EXP 16
2518: PPUSH
2519: LD_STRING D3a-Huck-2
2521: PPUSH
2522: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2526: LD_EXP 17
2530: PPUSH
2531: LD_STRING D3a-Pow-2
2533: PPUSH
2534: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2538: LD_EXP 16
2542: PPUSH
2543: LD_STRING D3a-Huck-3
2545: PPUSH
2546: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2550: LD_EXP 17
2554: PPUSH
2555: LD_STRING D3a-Pow-3
2557: PPUSH
2558: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2562: LD_EXP 16
2566: PPUSH
2567: LD_STRING D3a-Huck-4
2569: PPUSH
2570: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2574: LD_EXP 12
2578: PPUSH
2579: LD_STRING D3a-JMM-4
2581: PPUSH
2582: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2586: LD_EXP 13
2590: PPUSH
2591: LD_STRING D3a-Bur-4
2593: PPUSH
2594: CALL_OW 88
// if Joan then
2598: LD_EXP 14
2602: IFFALSE 2618
// SayRadio ( Joan , D3a-Joan-4 ) else
2604: LD_EXP 14
2608: PPUSH
2609: LD_STRING D3a-Joan-4
2611: PPUSH
2612: CALL_OW 94
2616: GO 2630
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2618: LD_EXP 15
2622: PPUSH
2623: LD_STRING D3a-RSci1-4
2625: PPUSH
2626: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2630: LD_INT 133
2632: PPUSH
2633: LD_INT 43
2635: PPUSH
2636: LD_INT 7
2638: PPUSH
2639: LD_INT 10
2641: NEG
2642: PPUSH
2643: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2647: LD_INT 133
2649: PPUSH
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 7
2655: PPUSH
2656: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2660: LD_INT 133
2662: PPUSH
2663: LD_INT 43
2665: PPUSH
2666: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2677: LD_EXP 12
2681: PPUSH
2682: LD_STRING D3a-JMM-5
2684: PPUSH
2685: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2689: LD_EXP 13
2693: PPUSH
2694: LD_STRING D3a-Bur-5
2696: PPUSH
2697: CALL_OW 88
// DialogueOff ;
2701: CALL_OW 7
// seenBase := true ;
2705: LD_ADDR_EXP 8
2709: PUSH
2710: LD_INT 1
2712: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2713: LD_INT 525
2715: PUSH
2716: LD_INT 420
2718: PUSH
2719: LD_INT 315
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: PUSH
2727: LD_OWVAR 67
2731: ARRAY
2732: PPUSH
2733: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_INT 142
2744: PPUSH
2745: LD_INT 52
2747: PPUSH
2748: CALL_OW 116
// end ;
2752: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2753: LD_EXP 8
2757: NOT
2758: PUSH
2759: LD_EXP 4
2763: NOT
2764: AND
2765: IFFALSE 2785
2767: GO 2769
2769: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2770: LD_EXP 19
2774: PPUSH
2775: LD_INT 142
2777: PPUSH
2778: LD_INT 52
2780: PPUSH
2781: CALL_OW 116
2785: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2786: LD_INT 0
2788: PPUSH
2789: PPUSH
// contaminateTime := tick ;
2790: LD_ADDR_EXP 3
2794: PUSH
2795: LD_OWVAR 1
2799: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2800: LD_INT 175
2802: PPUSH
2803: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2807: LD_ADDR_VAR 0 5
2811: PUSH
2812: LD_INT 4
2814: PPUSH
2815: CALL_OW 469
2819: ST_TO_ADDR
// if art then
2820: LD_VAR 0 5
2824: IFFALSE 2863
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2826: LD_VAR 0 5
2830: PUSH
2831: LD_INT 1
2833: ARRAY
2834: PUSH
2835: LD_INT 157
2837: EQUAL
2838: PUSH
2839: LD_VAR 0 5
2843: PUSH
2844: LD_INT 2
2846: ARRAY
2847: PUSH
2848: LD_INT 75
2850: EQUAL
2851: AND
2852: IFFALSE 2863
// begin YouLost ( Artefact ) ;
2854: LD_STRING Artefact
2856: PPUSH
2857: CALL_OW 104
// exit ;
2861: GO 3015
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2863: LD_EXP 12
2867: PPUSH
2868: CALL_OW 302
2872: PUSH
2873: LD_EXP 13
2877: PPUSH
2878: CALL_OW 302
2882: AND
2883: IFFALSE 2960
// begin DialogueOn ;
2885: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2889: LD_EXP 12
2893: PPUSH
2894: LD_STRING D6a-JMM-1
2896: PPUSH
2897: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2901: LD_EXP 13
2905: PPUSH
2906: LD_STRING D6a-Bur-1
2908: PPUSH
2909: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2913: LD_EXP 12
2917: PPUSH
2918: LD_STRING D6c-JMM-1
2920: PPUSH
2921: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2925: LD_EXP 13
2929: PPUSH
2930: LD_STRING D6c-Bur-1
2932: PPUSH
2933: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2937: LD_EXP 12
2941: PPUSH
2942: LD_STRING D6c-JMM-2
2944: PPUSH
2945: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2949: LD_STRING MBase
2951: PPUSH
2952: CALL_OW 337
// DialogueOff ;
2956: CALL_OW 7
// end ; bombExploded := true ;
2960: LD_ADDR_EXP 4
2964: PUSH
2965: LD_INT 1
2967: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
2968: LD_INT 6300
2970: PUSH
2971: LD_INT 5250
2973: PUSH
2974: LD_INT 4200
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PUSH
2982: LD_OWVAR 67
2986: ARRAY
2987: PPUSH
2988: CALL_OW 67
// if IsOk ( JMM ) then
2992: LD_EXP 12
2996: PPUSH
2997: CALL_OW 302
3001: IFFALSE 3015
// Say ( JMM , D8-JMM-1 ) ;
3003: LD_EXP 12
3007: PPUSH
3008: LD_STRING D8-JMM-1
3010: PPUSH
3011: CALL_OW 88
// end ;
3015: LD_VAR 0 4
3019: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3020: LD_EXP 9
3024: PUSH
3025: LD_EXP 7
3029: NOT
3030: AND
3031: PUSH
3032: LD_EXP 4
3036: AND
3037: IFFALSE 3092
3039: GO 3041
3041: DISABLE
// begin enable ;
3042: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3043: LD_INT 9
3045: PPUSH
3046: LD_INT 22
3048: PUSH
3049: LD_INT 7
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PPUSH
3056: CALL_OW 70
3060: IFFALSE 3078
// stevensTimer := stevensTimer - 0 0$30 else
3062: LD_ADDR_EXP 9
3066: PUSH
3067: LD_EXP 9
3071: PUSH
3072: LD_INT 1050
3074: MINUS
3075: ST_TO_ADDR
3076: GO 3092
// stevensTimer := stevensTimer - 0 0$1 ;
3078: LD_ADDR_EXP 9
3082: PUSH
3083: LD_EXP 9
3087: PUSH
3088: LD_INT 35
3090: MINUS
3091: ST_TO_ADDR
// end ;
3092: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3093: LD_EXP 9
3097: PUSH
3098: LD_INT 0
3100: LESSEQUAL
3101: PUSH
3102: LD_EXP 7
3106: NOT
3107: AND
3108: IFFALSE 3272
3110: GO 3112
3112: DISABLE
3113: LD_INT 0
3115: PPUSH
3116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: LD_INT 22
3124: PUSH
3125: LD_INT 1
3127: PUSH
3128: EMPTY
3129: LIST
3130: LIST
3131: PUSH
3132: LD_INT 25
3134: PUSH
3135: LD_INT 4
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PPUSH
3146: CALL_OW 69
3150: ST_TO_ADDR
// for i in tmp do
3151: LD_ADDR_VAR 0 1
3155: PUSH
3156: LD_VAR 0 2
3160: PUSH
3161: FOR_IN
3162: IFFALSE 3215
// begin if IsInUnit ( i ) then
3164: LD_VAR 0 1
3168: PPUSH
3169: CALL_OW 310
3173: IFFALSE 3186
// ComExitBuilding ( i ) else
3175: LD_VAR 0 1
3179: PPUSH
3180: CALL_OW 122
3184: GO 3213
// if not HasTask ( i ) then
3186: LD_VAR 0 1
3190: PPUSH
3191: CALL_OW 314
3195: NOT
3196: IFFALSE 3213
// ComMoveXY ( i , 29 , 56 ) ;
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 29
3205: PPUSH
3206: LD_INT 56
3208: PPUSH
3209: CALL_OW 111
// end ;
3213: GO 3161
3215: POP
3216: POP
// repeat wait ( 0 0$1 ) ;
3217: LD_INT 35
3219: PPUSH
3220: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3224: LD_INT 8
3226: PPUSH
3227: LD_INT 22
3229: PUSH
3230: LD_INT 1
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: LD_INT 25
3239: PUSH
3240: LD_INT 4
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PPUSH
3251: CALL_OW 70
3255: IFFALSE 3217
// if planCaptured then
3257: LD_EXP 7
3261: IFFALSE 3265
// exit ;
3263: GO 3272
// YouLost ( Time ) ;
3265: LD_STRING Time
3267: PPUSH
3268: CALL_OW 104
// end ;
3272: PPOPN 2
3274: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3275: LD_INT 22
3277: PUSH
3278: LD_INT 7
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: PUSH
3285: LD_INT 92
3287: PUSH
3288: LD_INT 142
3290: PUSH
3291: LD_INT 52
3293: PUSH
3294: LD_INT 27
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: PUSH
3312: LD_EXP 3
3316: PUSH
3317: LD_INT 6000
3319: PLUS
3320: PUSH
3321: LD_OWVAR 1
3325: GREATER
3326: AND
3327: PUSH
3328: LD_EXP 4
3332: AND
3333: IFFALSE 3388
3335: GO 3337
3337: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3338: LD_EXP 12
3342: PUSH
3343: LD_EXP 13
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PPUSH
3352: CALL_OW 85
// DialogueOn ;
3356: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3360: LD_EXP 12
3364: PPUSH
3365: LD_STRING D6b-JMM-1
3367: PPUSH
3368: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3372: LD_EXP 13
3376: PPUSH
3377: LD_STRING D6b-Bur-1
3379: PPUSH
3380: CALL_OW 88
// DialogueOff ;
3384: CALL_OW 7
// end ;
3388: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3389: LD_EXP 13
3393: PPUSH
3394: LD_INT 142
3396: PPUSH
3397: LD_INT 52
3399: PPUSH
3400: CALL_OW 297
3404: PUSH
3405: LD_INT 25
3407: LESS
3408: PUSH
3409: LD_EXP 13
3413: PPUSH
3414: CALL_OW 310
3418: PPUSH
3419: LD_INT 142
3421: PPUSH
3422: LD_INT 52
3424: PPUSH
3425: CALL_OW 297
3429: PUSH
3430: LD_INT 25
3432: LESS
3433: OR
3434: PUSH
3435: LD_EXP 13
3439: PPUSH
3440: CALL_OW 256
3444: PUSH
3445: LD_INT 1000
3447: LESS
3448: AND
3449: PUSH
3450: LD_EXP 3
3454: PUSH
3455: LD_INT 6000
3457: PLUS
3458: PUSH
3459: LD_OWVAR 1
3463: GREATER
3464: AND
3465: PUSH
3466: LD_EXP 4
3470: AND
3471: IFFALSE 3504
3473: GO 3475
3475: DISABLE
// begin DialogueOn ;
3476: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3480: LD_EXP 13
3484: PPUSH
3485: LD_STRING D7-Bur-1
3487: PPUSH
3488: CALL_OW 88
// enteredContaminatedArea := true ;
3492: LD_ADDR_EXP 5
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// DialogueOff ;
3500: CALL_OW 7
// end ;
3504: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3505: LD_EXP 12
3509: PPUSH
3510: LD_INT 142
3512: PPUSH
3513: LD_INT 52
3515: PPUSH
3516: CALL_OW 297
3520: PUSH
3521: LD_INT 25
3523: LESS
3524: PUSH
3525: LD_EXP 12
3529: PPUSH
3530: CALL_OW 310
3534: PPUSH
3535: LD_INT 142
3537: PPUSH
3538: LD_INT 52
3540: PPUSH
3541: CALL_OW 297
3545: PUSH
3546: LD_INT 25
3548: LESS
3549: OR
3550: PUSH
3551: LD_EXP 12
3555: PPUSH
3556: CALL_OW 256
3560: PUSH
3561: LD_INT 1000
3563: LESS
3564: AND
3565: PUSH
3566: LD_EXP 3
3570: PUSH
3571: LD_INT 6000
3573: PLUS
3574: PUSH
3575: LD_OWVAR 1
3579: GREATER
3580: AND
3581: PUSH
3582: LD_EXP 4
3586: AND
3587: IFFALSE 3620
3589: GO 3591
3591: DISABLE
// begin DialogueOn ;
3592: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3596: LD_EXP 12
3600: PPUSH
3601: LD_STRING D7-JMM-1
3603: PPUSH
3604: CALL_OW 88
// enteredContaminatedArea := true ;
3608: LD_ADDR_EXP 5
3612: PUSH
3613: LD_INT 1
3615: ST_TO_ADDR
// DialogueOff ;
3616: CALL_OW 7
// end ;
3620: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3621: LD_EXP 6
3625: PUSH
3626: LD_EXP 12
3630: PPUSH
3631: CALL_OW 302
3635: AND
3636: PUSH
3637: LD_EXP 13
3641: PPUSH
3642: CALL_OW 302
3646: AND
3647: IFFALSE 3716
3649: GO 3651
3651: DISABLE
// begin DialogueOn ;
3652: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3656: LD_EXP 12
3660: PUSH
3661: LD_EXP 13
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: PPUSH
3670: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3674: LD_EXP 12
3678: PPUSH
3679: LD_STRING D4-JMM-1
3681: PPUSH
3682: CALL_OW 88
// if not bombExploded then
3686: LD_EXP 4
3690: NOT
3691: IFFALSE 3705
// Say ( Burlak , D4-Bur-1 ) ;
3693: LD_EXP 13
3697: PPUSH
3698: LD_STRING D4-Bur-1
3700: PPUSH
3701: CALL_OW 88
// DialogueOff ;
3705: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3709: LD_STRING MReturn
3711: PPUSH
3712: CALL_OW 337
// end ;
3716: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3717: LD_EXP 7
3721: NOT
3722: PUSH
3723: LD_INT 22
3725: PUSH
3726: LD_INT 7
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: LD_INT 91
3735: PUSH
3736: LD_INT 9
3738: PUSH
3739: LD_INT 6
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: AND
3756: IFFALSE 3833
3758: GO 3760
3760: DISABLE
// begin DialogueOn ;
3761: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3765: LD_INT 55
3767: PPUSH
3768: LD_INT 11
3770: PPUSH
3771: LD_INT 7
3773: PPUSH
3774: LD_INT 6
3776: NEG
3777: PPUSH
3778: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3782: LD_INT 55
3784: PPUSH
3785: LD_INT 11
3787: PPUSH
3788: LD_INT 7
3790: PPUSH
3791: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3795: LD_EXP 13
3799: PPUSH
3800: LD_STRING D9-Bur-1
3802: PPUSH
3803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3807: LD_EXP 12
3811: PPUSH
3812: LD_STRING D9-JMM-1
3814: PPUSH
3815: CALL_OW 88
// DialogueOff ;
3819: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3823: LD_INT 9
3825: PPUSH
3826: LD_INT 7
3828: PPUSH
3829: CALL_OW 235
// end ;
3833: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3834: LD_INT 9
3836: PPUSH
3837: LD_INT 22
3839: PUSH
3840: LD_INT 7
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PPUSH
3847: CALL_OW 70
3851: IFFALSE 3887
3853: GO 3855
3855: DISABLE
// begin wait ( 0 0$07 ) ;
3856: LD_INT 245
3858: PPUSH
3859: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3863: LD_EXP 12
3867: PPUSH
3868: LD_STRING D10b-JMM-1
3870: PPUSH
3871: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3875: LD_EXP 13
3879: PPUSH
3880: LD_STRING D10b-Bur-1
3882: PPUSH
3883: CALL_OW 88
// end ;
3887: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3888: LD_EXP 9
3892: PUSH
3893: LD_INT 22
3895: PUSH
3896: LD_INT 1
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 25
3905: PUSH
3906: LD_INT 4
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: LD_INT 26
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 69
3932: AND
3933: PUSH
3934: LD_INT 5
3936: PPUSH
3937: CALL_OW 255
3941: PUSH
3942: LD_INT 7
3944: EQUAL
3945: PUSH
3946: LD_INT 22
3948: PUSH
3949: LD_INT 1
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 25
3958: PUSH
3959: LD_INT 1
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: PPUSH
3970: CALL_OW 69
3974: PUSH
3975: LD_INT 0
3977: EQUAL
3978: OR
3979: AND
3980: IFFALSE 4562
3982: GO 3984
3984: DISABLE
3985: LD_INT 0
3987: PPUSH
// begin case Query ( QKill ) of 1 :
3988: LD_STRING QKill
3990: PPUSH
3991: CALL_OW 97
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4550
4004: POP
// begin DialogueOn ;
4005: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4009: LD_EXP 12
4013: PPUSH
4014: LD_STRING D10a-JMM-1
4016: PPUSH
4017: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4021: LD_EXP 13
4025: PPUSH
4026: LD_STRING D10a-Bur-1
4028: PPUSH
4029: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4033: LD_EXP 12
4037: PPUSH
4038: LD_STRING D10a-JMM-2
4040: PPUSH
4041: CALL_OW 88
// if IsOk ( Stevens ) then
4045: LD_EXP 16
4049: PPUSH
4050: CALL_OW 302
4054: IFFALSE 4070
// Say ( Stevens , D10a-Huck-2 ) else
4056: LD_EXP 16
4060: PPUSH
4061: LD_STRING D10a-Huck-2
4063: PPUSH
4064: CALL_OW 88
4068: GO 4121
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4070: LD_INT 22
4072: PUSH
4073: LD_INT 1
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: LD_INT 25
4082: PUSH
4083: LD_INT 4
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: LD_INT 26
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: PPUSH
4105: CALL_OW 69
4109: PUSH
4110: LD_INT 1
4112: ARRAY
4113: PPUSH
4114: LD_STRING D10a-ASci1-3
4116: PPUSH
4117: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4121: LD_EXP 12
4125: PPUSH
4126: LD_STRING D10a-JMM-4
4128: PPUSH
4129: CALL_OW 88
// if IsOk ( Stevens ) then
4133: LD_EXP 16
4137: PPUSH
4138: CALL_OW 302
4142: IFFALSE 4156
// Say ( Stevens , D10a-Huck-3 ) ;
4144: LD_EXP 16
4148: PPUSH
4149: LD_STRING D10a-Huck-3
4151: PPUSH
4152: CALL_OW 88
// DialogueOff ;
4156: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4160: LD_INT 1
4162: PPUSH
4163: LD_INT 7
4165: PPUSH
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 80
// planCaptured := true ;
4176: LD_ADDR_EXP 7
4180: PUSH
4181: LD_INT 1
4183: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4184: LD_STRING MEnd
4186: PPUSH
4187: CALL_OW 337
// canEnd := true ;
4191: LD_ADDR_EXP 10
4195: PUSH
4196: LD_INT 1
4198: ST_TO_ADDR
// missionTime := tick ;
4199: LD_ADDR_EXP 11
4203: PUSH
4204: LD_OWVAR 1
4208: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4209: LD_INT 35
4211: PPUSH
4212: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4216: LD_INT 22
4218: PUSH
4219: LD_INT 1
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PUSH
4226: LD_INT 3
4228: PUSH
4229: LD_INT 50
4231: PUSH
4232: EMPTY
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: PPUSH
4243: CALL_OW 69
4247: IFFALSE 4363
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4249: LD_ADDR_VAR 0 1
4253: PUSH
4254: LD_INT 22
4256: PUSH
4257: LD_INT 1
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 25
4266: PUSH
4267: LD_INT 4
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4361
// begin if IsInUnit ( i ) then
4286: LD_VAR 0 1
4290: PPUSH
4291: CALL_OW 310
4295: IFFALSE 4308
// ComExitBuilding ( i ) else
4297: LD_VAR 0 1
4301: PPUSH
4302: CALL_OW 122
4306: GO 4359
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4308: LD_VAR 0 1
4312: PPUSH
4313: LD_INT 22
4315: PUSH
4316: LD_INT 1
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PUSH
4323: LD_INT 3
4325: PUSH
4326: LD_INT 50
4328: PUSH
4329: EMPTY
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PPUSH
4340: CALL_OW 69
4344: PPUSH
4345: LD_VAR 0 1
4349: PPUSH
4350: CALL_OW 74
4354: PPUSH
4355: CALL_OW 128
// end ;
4359: GO 4283
4361: POP
4362: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4363: LD_INT 22
4365: PUSH
4366: LD_INT 1
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 3
4375: PUSH
4376: LD_INT 50
4378: PUSH
4379: EMPTY
4380: LIST
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PPUSH
4390: CALL_OW 69
4394: NOT
4395: IFFALSE 4209
// repeat wait ( 3 ) ;
4397: LD_INT 3
4399: PPUSH
4400: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4404: LD_ADDR_VAR 0 1
4408: PUSH
4409: LD_INT 22
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: LD_INT 21
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: PUSH
4438: FOR_IN
4439: IFFALSE 4515
// begin if IsInArea ( i , stevensEscapeArea ) then
4441: LD_VAR 0 1
4445: PPUSH
4446: LD_INT 8
4448: PPUSH
4449: CALL_OW 308
4453: IFFALSE 4466
// begin RemoveUnit ( i ) ;
4455: LD_VAR 0 1
4459: PPUSH
4460: CALL_OW 64
// continue ;
4464: GO 4438
// end ; if IsInUnit ( i ) then
4466: LD_VAR 0 1
4470: PPUSH
4471: CALL_OW 310
4475: IFFALSE 4486
// ComExitBuilding ( i ) ;
4477: LD_VAR 0 1
4481: PPUSH
4482: CALL_OW 122
// if not HasTask ( i ) then
4486: LD_VAR 0 1
4490: PPUSH
4491: CALL_OW 314
4495: NOT
4496: IFFALSE 4513
// ComMoveXY ( i , 28 , 55 ) ;
4498: LD_VAR 0 1
4502: PPUSH
4503: LD_INT 28
4505: PPUSH
4506: LD_INT 55
4508: PPUSH
4509: CALL_OW 111
// end ;
4513: GO 4438
4515: POP
4516: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4517: LD_INT 22
4519: PUSH
4520: LD_INT 1
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 21
4529: PUSH
4530: LD_INT 1
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PPUSH
4541: CALL_OW 69
4545: NOT
4546: IFFALSE 4397
// end ; 2 :
4548: GO 4562
4550: LD_INT 2
4552: DOUBLE
4553: EQUAL
4554: IFTRUE 4558
4556: GO 4561
4558: POP
// ; end ;
4559: GO 4562
4561: POP
// end ;
4562: PPOPN 1
4564: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4565: LD_EXP 10
4569: IFFALSE 4926
4571: GO 4573
4573: DISABLE
4574: LD_INT 0
4576: PPUSH
4577: PPUSH
4578: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4579: LD_INT 10
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 424
// if Difficulty < 2 then
4589: LD_OWVAR 67
4593: PUSH
4594: LD_INT 2
4596: LESS
4597: IFFALSE 4601
// exit ;
4599: GO 4926
// uc_side := 4 ;
4601: LD_ADDR_OWVAR 20
4605: PUSH
4606: LD_INT 4
4608: ST_TO_ADDR
// uc_nation := 1 ;
4609: LD_ADDR_OWVAR 21
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// InitHc ;
4617: CALL_OW 19
// tmp := [ ] ;
4621: LD_ADDR_VAR 0 3
4625: PUSH
4626: EMPTY
4627: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4628: LD_INT 0
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 10
4636: PPUSH
4637: CALL_OW 380
// un := CreateHuman ;
4641: LD_ADDR_VAR 0 1
4645: PUSH
4646: CALL_OW 44
4650: ST_TO_ADDR
// tmp := [ un ] ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: LD_VAR 0 1
4660: PUSH
4661: EMPTY
4662: LIST
4663: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4664: LD_VAR 0 1
4668: PPUSH
4669: LD_INT 226
4671: PPUSH
4672: LD_INT 86
4674: PPUSH
4675: LD_INT 0
4677: PPUSH
4678: CALL_OW 48
// ComHold ( un ) ;
4682: LD_VAR 0 1
4686: PPUSH
4687: CALL_OW 140
// for i = 1 to 3 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 3
4703: PUSH
4704: FOR_TO
4705: IFFALSE 4804
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4707: LD_INT 0
4709: PPUSH
4710: LD_INT 1
4712: PPUSH
4713: LD_INT 8
4715: PPUSH
4716: CALL_OW 380
// un := CreateHuman ;
4720: LD_ADDR_VAR 0 1
4724: PUSH
4725: CALL_OW 44
4729: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4730: LD_VAR 0 1
4734: PPUSH
4735: LD_INT 5
4737: PPUSH
4738: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4742: LD_VAR 0 1
4746: PPUSH
4747: LD_INT 215
4749: PUSH
4750: LD_INT 217
4752: PUSH
4753: LD_INT 219
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_VAR 0 2
4765: ARRAY
4766: PPUSH
4767: LD_INT 76
4769: PPUSH
4770: LD_INT 0
4772: PPUSH
4773: CALL_OW 48
// ComCrawl ( un ) ;
4777: LD_VAR 0 1
4781: PPUSH
4782: CALL_OW 137
// tmp := tmp ^ un ;
4786: LD_ADDR_VAR 0 3
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: LD_VAR 0 1
4800: ADD
4801: ST_TO_ADDR
// end ;
4802: GO 4704
4804: POP
4805: POP
// repeat wait ( 0 0$1 ) ;
4806: LD_INT 35
4808: PPUSH
4809: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4813: LD_VAR 0 1
4817: PPUSH
4818: LD_INT 24
4820: PUSH
4821: LD_INT 1000
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PPUSH
4828: CALL_OW 72
4832: NOT
4833: IFFALSE 4806
// for i in tmp do
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_VAR 0 3
4844: PUSH
4845: FOR_IN
4846: IFFALSE 4924
// begin wait ( 0 0$1 ) ;
4848: LD_INT 35
4850: PPUSH
4851: CALL_OW 67
// if Crawls ( i ) then
4855: LD_VAR 0 2
4859: PPUSH
4860: CALL_OW 318
4864: IFFALSE 4877
// ComWalk ( i ) else
4866: LD_VAR 0 2
4870: PPUSH
4871: CALL_OW 138
4875: GO 4922
// if GetClass ( i ) = class_sniper then
4877: LD_VAR 0 2
4881: PPUSH
4882: CALL_OW 257
4886: PUSH
4887: LD_INT 5
4889: EQUAL
4890: IFFALSE 4908
// ComAttackSoporific ( i , JMM ) else
4892: LD_VAR 0 2
4896: PPUSH
4897: LD_EXP 12
4901: PPUSH
4902: CALL_OW 166
4906: GO 4922
// ComAttackUnit ( i , JMM ) ;
4908: LD_VAR 0 2
4912: PPUSH
4913: LD_EXP 12
4917: PPUSH
4918: CALL_OW 115
// end ;
4922: GO 4845
4924: POP
4925: POP
// end ;
4926: PPOPN 3
4928: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4929: LD_EXP 7
4933: NOT
4934: PUSH
4935: LD_INT 1
4937: PPUSH
4938: CALL_OW 301
4942: AND
4943: IFFALSE 4955
4945: GO 4947
4947: DISABLE
// YouLost ( Lab ) ;
4948: LD_STRING Lab
4950: PPUSH
4951: CALL_OW 104
4955: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do
4956: LD_INT 10
4958: PPUSH
4959: LD_INT 22
4961: PUSH
4962: LD_INT 7
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 70
4973: PUSH
4974: LD_INT 2
4976: GREATEREQUAL
4977: PUSH
4978: LD_INT 10
4980: PPUSH
4981: LD_INT 2
4983: PUSH
4984: LD_INT 34
4986: PUSH
4987: LD_INT 12
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 34
4996: PUSH
4997: LD_INT 51
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: LIST
5008: PPUSH
5009: CALL_OW 70
5013: AND
5014: PUSH
5015: LD_EXP 10
5019: AND
5020: PUSH
5021: LD_EXP 7
5025: AND
5026: PUSH
5027: LD_EXP 6
5031: AND
5032: IFFALSE 5179
5034: GO 5036
5036: DISABLE
// begin AddMedal ( Explosion , 1 ) ;
5037: LD_STRING Explosion
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: CALL_OW 101
// if enteredContaminatedArea then
5047: LD_EXP 5
5051: IFFALSE 5065
// AddMedal ( BioHazard , 1 ) else
5053: LD_STRING BioHazard
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 101
5063: GO 5076
// AddMedal ( BioHazard , - 1 ) ;
5065: LD_STRING BioHazard
5067: PPUSH
5068: LD_INT 1
5070: NEG
5071: PPUSH
5072: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5076: LD_EXP 11
5080: PUSH
5081: LD_INT 42000
5083: PUSH
5084: LD_INT 31500
5086: PUSH
5087: LD_INT 25200
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: LESSEQUAL
5101: IFFALSE 5115
// AddMedal ( Speed , 1 ) else
5103: LD_STRING Speed
5105: PPUSH
5106: LD_INT 1
5108: PPUSH
5109: CALL_OW 101
5113: GO 5126
// AddMedal ( Speed , - 1 ) ;
5115: LD_STRING Speed
5117: PPUSH
5118: LD_INT 1
5120: NEG
5121: PPUSH
5122: CALL_OW 101
// GiveMedals ( Main ) ;
5126: LD_STRING Main
5128: PPUSH
5129: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5133: LD_EXP 12
5137: PUSH
5138: LD_EXP 13
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PPUSH
5147: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5151: LD_EXP 12
5155: PPUSH
5156: LD_STRING 14a_JMM
5158: PPUSH
5159: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5163: LD_EXP 13
5167: PPUSH
5168: LD_STRING 14a_Burlak
5170: PPUSH
5171: CALL_OW 38
// YouWin ;
5175: CALL_OW 103
// end ; end_of_file
5179: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5180: LD_INT 0
5182: PPUSH
5183: PPUSH
5184: PPUSH
5185: PPUSH
// uc_side := 1 ;
5186: LD_ADDR_OWVAR 20
5190: PUSH
5191: LD_INT 1
5193: ST_TO_ADDR
// uc_nation := 1 ;
5194: LD_ADDR_OWVAR 21
5198: PUSH
5199: LD_INT 1
5201: ST_TO_ADDR
// InitHc ;
5202: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5206: LD_INT 34
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5224: LD_INT 34
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 3
5234: PPUSH
5235: LD_INT 20
5237: PPUSH
5238: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5242: LD_ADDR_EXP 16
5246: PUSH
5247: LD_STRING Stevens
5249: PPUSH
5250: CALL_OW 25
5254: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5255: LD_ADDR_EXP 17
5259: PUSH
5260: LD_STRING Powell
5262: PPUSH
5263: CALL_OW 25
5267: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5268: LD_EXP 16
5272: PPUSH
5273: LD_INT 1
5275: PPUSH
5276: CALL_OW 52
// vehGuard := [ ] ;
5280: LD_ADDR_EXP 21
5284: PUSH
5285: EMPTY
5286: ST_TO_ADDR
// hc_importance := 0 ;
5287: LD_ADDR_OWVAR 32
5291: PUSH
5292: LD_INT 0
5294: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5295: LD_INT 4
5297: PPUSH
5298: LD_INT 3
5300: PPUSH
5301: LD_INT 3
5303: PPUSH
5304: LD_INT 8
5306: PPUSH
5307: LD_INT 100
5309: PPUSH
5310: CALL 934 0 5
// sibBomb := CreateVehicle ;
5314: LD_ADDR_EXP 19
5318: PUSH
5319: CALL_OW 45
5323: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5324: LD_EXP 19
5328: PPUSH
5329: LD_INT 1
5331: PPUSH
5332: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5336: LD_EXP 19
5340: PPUSH
5341: LD_INT 93
5343: PPUSH
5344: LD_INT 74
5346: PPUSH
5347: LD_INT 0
5349: PPUSH
5350: CALL_OW 48
// guards := [ ] ;
5354: LD_ADDR_EXP 20
5358: PUSH
5359: EMPTY
5360: ST_TO_ADDR
// for i = 1 to 3 do
5361: LD_ADDR_VAR 0 2
5365: PUSH
5366: DOUBLE
5367: LD_INT 1
5369: DEC
5370: ST_TO_ADDR
5371: LD_INT 3
5373: PUSH
5374: FOR_TO
5375: IFFALSE 5467
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5377: LD_INT 0
5379: PPUSH
5380: LD_INT 1
5382: PPUSH
5383: LD_INT 8
5385: PUSH
5386: LD_INT 9
5388: PUSH
5389: LD_INT 10
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_OWVAR 67
5401: ARRAY
5402: PPUSH
5403: CALL_OW 380
// un := CreateHuman ;
5407: LD_ADDR_VAR 0 3
5411: PUSH
5412: CALL_OW 44
5416: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5417: LD_VAR 0 3
5421: PPUSH
5422: LD_INT 2
5424: PUSH
5425: LD_INT 3
5427: PUSH
5428: LD_INT 4
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: LIST
5435: PUSH
5436: LD_VAR 0 2
5440: ARRAY
5441: PPUSH
5442: LD_INT 0
5444: PPUSH
5445: CALL_OW 49
// guards := guards ^ un ;
5449: LD_ADDR_EXP 20
5453: PUSH
5454: LD_EXP 20
5458: PUSH
5459: LD_VAR 0 3
5463: ADD
5464: ST_TO_ADDR
// end ;
5465: GO 5374
5467: POP
5468: POP
// baseGuards := [ ] ;
5469: LD_ADDR_EXP 18
5473: PUSH
5474: EMPTY
5475: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5476: LD_ADDR_VAR 0 2
5480: PUSH
5481: DOUBLE
5482: LD_INT 1
5484: DEC
5485: ST_TO_ADDR
5486: LD_INT 5
5488: PUSH
5489: LD_INT 6
5491: PUSH
5492: LD_INT 7
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: PUSH
5506: FOR_TO
5507: IFFALSE 5653
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5509: LD_INT 0
5511: PPUSH
5512: LD_INT 8
5514: PUSH
5515: LD_INT 9
5517: PUSH
5518: LD_INT 10
5520: PUSH
5521: EMPTY
5522: LIST
5523: LIST
5524: LIST
5525: PUSH
5526: LD_OWVAR 67
5530: ARRAY
5531: PPUSH
5532: CALL_OW 381
// un := CreateHuman ;
5536: LD_ADDR_VAR 0 3
5540: PUSH
5541: CALL_OW 44
5545: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5546: LD_ADDR_EXP 18
5550: PUSH
5551: LD_EXP 18
5555: PUSH
5556: LD_VAR 0 3
5560: ADD
5561: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5562: LD_ADDR_VAR 0 4
5566: PUSH
5567: LD_INT 22
5569: PUSH
5570: LD_INT 1
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: LD_INT 58
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 30
5585: PUSH
5586: LD_INT 32
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: LIST
5597: PPUSH
5598: CALL_OW 69
5602: ST_TO_ADDR
// if tmp then
5603: LD_VAR 0 4
5607: IFFALSE 5639
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5609: LD_VAR 0 3
5613: PPUSH
5614: LD_VAR 0 4
5618: PUSH
5619: LD_INT 1
5621: PPUSH
5622: LD_VAR 0 4
5626: PPUSH
5627: CALL_OW 12
5631: ARRAY
5632: PPUSH
5633: CALL_OW 52
5637: GO 5651
// PlaceHumanInUnit ( un , us_bar ) ;
5639: LD_VAR 0 3
5643: PPUSH
5644: LD_INT 51
5646: PPUSH
5647: CALL_OW 52
// end ;
5651: GO 5506
5653: POP
5654: POP
// if Difficulty > 1 then
5655: LD_OWVAR 67
5659: PUSH
5660: LD_INT 1
5662: GREATER
5663: IFFALSE 5707
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5665: LD_INT 0
5667: PPUSH
5668: LD_INT 5
5670: PPUSH
5671: LD_INT 9
5673: PUSH
5674: LD_INT 10
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: PUSH
5681: LD_OWVAR 67
5685: PUSH
5686: LD_INT 1
5688: MINUS
5689: ARRAY
5690: PPUSH
5691: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5695: CALL_OW 44
5699: PPUSH
5700: LD_INT 80
5702: PPUSH
5703: CALL_OW 52
// end ; for i = 1 to 3 do
5707: LD_ADDR_VAR 0 2
5711: PUSH
5712: DOUBLE
5713: LD_INT 1
5715: DEC
5716: ST_TO_ADDR
5717: LD_INT 3
5719: PUSH
5720: FOR_TO
5721: IFFALSE 5747
// begin PrepareMechanic ( false , 9 ) ;
5723: LD_INT 0
5725: PPUSH
5726: LD_INT 9
5728: PPUSH
5729: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5733: CALL_OW 44
5737: PPUSH
5738: LD_INT 43
5740: PPUSH
5741: CALL_OW 52
// end ;
5745: GO 5720
5747: POP
5748: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5749: CALL_OW 44
5753: PPUSH
5754: LD_INT 49
5756: PPUSH
5757: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 1
5773: PUSH
5774: LD_OWVAR 67
5778: PLUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5783: LD_INT 0
5785: PPUSH
5786: LD_INT 8
5788: PUSH
5789: LD_INT 9
5791: PUSH
5792: LD_INT 10
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: PUSH
5800: LD_OWVAR 67
5804: ARRAY
5805: PPUSH
5806: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5810: CALL_OW 44
5814: PPUSH
5815: LD_INT 5
5817: PPUSH
5818: CALL_OW 52
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i = 1 to 3 do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: DOUBLE
5832: LD_INT 1
5834: DEC
5835: ST_TO_ADDR
5836: LD_INT 3
5838: PUSH
5839: FOR_TO
5840: IFFALSE 5866
// begin PrepareScientist ( false , 10 ) ;
5842: LD_INT 0
5844: PPUSH
5845: LD_INT 10
5847: PPUSH
5848: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
5852: CALL_OW 44
5856: PPUSH
5857: LD_INT 1
5859: PPUSH
5860: CALL_OW 52
// end ;
5864: GO 5839
5866: POP
5867: POP
// end ;
5868: LD_VAR 0 1
5872: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
5873: LD_EXP 20
5877: PUSH
5878: LD_EXP 2
5882: NOT
5883: AND
5884: IFFALSE 6070
5886: GO 5888
5888: DISABLE
5889: LD_INT 0
5891: PPUSH
5892: PPUSH
5893: PPUSH
// begin enable ;
5894: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
5895: LD_ADDR_VAR 0 3
5899: PUSH
5900: LD_INT 204
5902: PUSH
5903: LD_INT 30
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PUSH
5910: LD_INT 165
5912: PUSH
5913: LD_INT 24
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: PUSH
5920: LD_INT 195
5922: PUSH
5923: LD_INT 6
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: PUSH
5930: LD_INT 223
5932: PUSH
5933: LD_INT 54
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: PUSH
5940: LD_INT 214
5942: PUSH
5943: LD_INT 84
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: PUSH
5950: LD_INT 206
5952: PUSH
5953: LD_INT 71
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: PUSH
5960: EMPTY
5961: LIST
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: ST_TO_ADDR
// for i in guards do
5968: LD_ADDR_VAR 0 1
5972: PUSH
5973: LD_EXP 20
5977: PUSH
5978: FOR_IN
5979: IFFALSE 6068
// begin if HasTask ( i ) then
5981: LD_VAR 0 1
5985: PPUSH
5986: CALL_OW 314
5990: IFFALSE 5996
// continue else
5992: GO 5978
5994: GO 6066
// begin j := rand ( 1 , 6 ) ;
5996: LD_ADDR_VAR 0 2
6000: PUSH
6001: LD_INT 1
6003: PPUSH
6004: LD_INT 6
6006: PPUSH
6007: CALL_OW 12
6011: ST_TO_ADDR
// if not See ( 7 , i ) then
6012: LD_INT 7
6014: PPUSH
6015: LD_VAR 0 1
6019: PPUSH
6020: CALL_OW 292
6024: NOT
6025: IFFALSE 6066
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6027: LD_VAR 0 1
6031: PPUSH
6032: LD_VAR 0 3
6036: PUSH
6037: LD_VAR 0 2
6041: ARRAY
6042: PUSH
6043: LD_INT 1
6045: ARRAY
6046: PPUSH
6047: LD_VAR 0 3
6051: PUSH
6052: LD_VAR 0 2
6056: ARRAY
6057: PUSH
6058: LD_INT 2
6060: ARRAY
6061: PPUSH
6062: CALL_OW 114
// end ; end ;
6066: GO 5978
6068: POP
6069: POP
// end ;
6070: PPOPN 3
6072: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6073: LD_EXP 21
6077: PUSH
6078: LD_EXP 7
6082: NOT
6083: AND
6084: IFFALSE 6155
6086: GO 6088
6088: DISABLE
6089: LD_INT 0
6091: PPUSH
// begin enable ;
6092: ENABLE
// for i in vehGuard do
6093: LD_ADDR_VAR 0 1
6097: PUSH
6098: LD_EXP 21
6102: PUSH
6103: FOR_IN
6104: IFFALSE 6153
// if IsOk ( vehGuard ) then
6106: LD_EXP 21
6110: PPUSH
6111: CALL_OW 302
6115: IFFALSE 6151
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6117: LD_VAR 0 1
6121: PPUSH
6122: LD_INT 22
6124: PUSH
6125: LD_INT 7
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PPUSH
6132: CALL_OW 69
6136: PPUSH
6137: LD_VAR 0 1
6141: PPUSH
6142: CALL_OW 74
6146: PPUSH
6147: CALL_OW 115
6151: GO 6103
6153: POP
6154: POP
// end ;
6155: PPOPN 1
6157: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6158: LD_EXP 4
6162: PUSH
6163: LD_INT 43
6165: PPUSH
6166: CALL_OW 302
6170: AND
6171: PUSH
6172: LD_EXP 7
6176: NOT
6177: AND
6178: IFFALSE 6226
6180: GO 6182
6182: DISABLE
// begin enable ;
6183: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6184: LD_INT 43
6186: PPUSH
6187: LD_INT 5
6189: PPUSH
6190: LD_INT 3
6192: PPUSH
6193: LD_INT 2
6195: PPUSH
6196: LD_INT 7
6198: PUSH
6199: LD_INT 7
6201: PUSH
6202: LD_INT 9
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 1
6212: PPUSH
6213: LD_INT 3
6215: PPUSH
6216: CALL_OW 12
6220: ARRAY
6221: PPUSH
6222: CALL_OW 125
// end ;
6226: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6227: LD_INT 22
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PUSH
6237: LD_INT 25
6239: PUSH
6240: LD_INT 5
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PUSH
6247: LD_INT 50
6249: PUSH
6250: EMPTY
6251: LIST
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: LIST
6257: PPUSH
6258: CALL_OW 69
6262: PUSH
6263: LD_EXP 7
6267: NOT
6268: AND
6269: IFFALSE 6498
6271: GO 6273
6273: DISABLE
6274: LD_INT 0
6276: PPUSH
6277: PPUSH
// begin enable ;
6278: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6279: LD_ADDR_VAR 0 1
6283: PUSH
6284: LD_INT 22
6286: PUSH
6287: LD_INT 1
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 25
6296: PUSH
6297: LD_INT 5
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 50
6306: PUSH
6307: EMPTY
6308: LIST
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: PPUSH
6315: CALL_OW 69
6319: ST_TO_ADDR
// if not tmp then
6320: LD_VAR 0 1
6324: NOT
6325: IFFALSE 6329
// exit ;
6327: GO 6498
// b := IsInUnit ( tmp [ 1 ] ) ;
6329: LD_ADDR_VAR 0 2
6333: PUSH
6334: LD_VAR 0 1
6338: PUSH
6339: LD_INT 1
6341: ARRAY
6342: PPUSH
6343: CALL_OW 310
6347: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6348: LD_VAR 0 2
6352: NOT
6353: PUSH
6354: LD_VAR 0 1
6358: PUSH
6359: LD_INT 1
6361: ARRAY
6362: PPUSH
6363: CALL_OW 314
6367: OR
6368: IFFALSE 6372
// exit ;
6370: GO 6498
// if b = us_bun1 then
6372: LD_VAR 0 2
6376: PUSH
6377: LD_INT 80
6379: EQUAL
6380: IFFALSE 6441
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6382: LD_VAR 0 1
6386: PUSH
6387: LD_INT 1
6389: ARRAY
6390: PPUSH
6391: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6395: LD_VAR 0 1
6399: PUSH
6400: LD_INT 1
6402: ARRAY
6403: PPUSH
6404: LD_INT 27
6406: PPUSH
6407: LD_INT 44
6409: PPUSH
6410: CALL_OW 174
// if IsOk ( us_bun2 ) then
6414: LD_INT 55
6416: PPUSH
6417: CALL_OW 302
6421: IFFALSE 6439
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6423: LD_VAR 0 1
6427: PUSH
6428: LD_INT 1
6430: ARRAY
6431: PPUSH
6432: LD_INT 55
6434: PPUSH
6435: CALL_OW 180
// end else
6439: GO 6498
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6441: LD_VAR 0 1
6445: PUSH
6446: LD_INT 1
6448: ARRAY
6449: PPUSH
6450: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6454: LD_VAR 0 1
6458: PUSH
6459: LD_INT 1
6461: ARRAY
6462: PPUSH
6463: LD_INT 92
6465: PPUSH
6466: LD_INT 51
6468: PPUSH
6469: CALL_OW 174
// if IsOk ( us_bun1 ) then
6473: LD_INT 80
6475: PPUSH
6476: CALL_OW 302
6480: IFFALSE 6498
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6482: LD_VAR 0 1
6486: PUSH
6487: LD_INT 1
6489: ARRAY
6490: PPUSH
6491: LD_INT 80
6493: PPUSH
6494: CALL_OW 180
// end ; end ;
6498: PPOPN 2
6500: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6501: LD_EXP 7
6505: NOT
6506: PUSH
6507: LD_INT 9
6509: PPUSH
6510: LD_INT 22
6512: PUSH
6513: LD_INT 1
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 21
6522: PUSH
6523: LD_INT 3
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 3
6532: PUSH
6533: LD_INT 24
6535: PUSH
6536: LD_INT 1000
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: LIST
6551: PPUSH
6552: CALL_OW 70
6556: AND
6557: IFFALSE 6968
6559: GO 6561
6561: DISABLE
6562: LD_INT 0
6564: PPUSH
6565: PPUSH
6566: PPUSH
6567: PPUSH
// begin enable ;
6568: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6569: LD_ADDR_VAR 0 2
6573: PUSH
6574: LD_INT 22
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: LD_INT 25
6586: PUSH
6587: LD_INT 2
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: LD_INT 24
6596: PUSH
6597: LD_INT 1000
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: PPUSH
6609: CALL_OW 69
6613: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6614: LD_ADDR_VAR 0 3
6618: PUSH
6619: LD_INT 22
6621: PUSH
6622: LD_INT 1
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 25
6631: PUSH
6632: LD_INT 2
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 24
6644: PUSH
6645: LD_INT 750
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: LIST
6660: PPUSH
6661: CALL_OW 69
6665: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6666: LD_ADDR_VAR 0 4
6670: PUSH
6671: LD_INT 9
6673: PPUSH
6674: LD_INT 22
6676: PUSH
6677: LD_INT 1
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: LD_INT 21
6686: PUSH
6687: LD_INT 3
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PUSH
6694: LD_INT 3
6696: PUSH
6697: LD_INT 24
6699: PUSH
6700: LD_INT 1000
6702: PUSH
6703: EMPTY
6704: LIST
6705: LIST
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 70
6720: PUSH
6721: LD_INT 1
6723: DIFF
6724: ST_TO_ADDR
// if not tmp and not tmp2 then
6725: LD_VAR 0 2
6729: NOT
6730: PUSH
6731: LD_VAR 0 3
6735: NOT
6736: AND
6737: IFFALSE 6741
// exit ;
6739: GO 6968
// if tmp and b then
6741: LD_VAR 0 2
6745: PUSH
6746: LD_VAR 0 4
6750: AND
6751: IFFALSE 6881
// for i in tmp do
6753: LD_ADDR_VAR 0 1
6757: PUSH
6758: LD_VAR 0 2
6762: PUSH
6763: FOR_IN
6764: IFFALSE 6879
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6766: LD_VAR 0 1
6770: PPUSH
6771: CALL_OW 110
6775: PUSH
6776: LD_INT 1
6778: EQUAL
6779: PUSH
6780: LD_VAR 0 1
6784: PPUSH
6785: CALL_OW 256
6789: PUSH
6790: LD_INT 1000
6792: LESS
6793: AND
6794: IFFALSE 6800
// continue else
6796: GO 6763
6798: GO 6827
// if GetTag ( i ) = 1 then
6800: LD_VAR 0 1
6804: PPUSH
6805: CALL_OW 110
6809: PUSH
6810: LD_INT 1
6812: EQUAL
6813: IFFALSE 6827
// SetTag ( i , 0 ) ;
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 109
// if IsInUnit ( i ) then
6827: LD_VAR 0 1
6831: PPUSH
6832: CALL_OW 310
6836: IFFALSE 6847
// ComExitBuilding ( i ) ;
6838: LD_VAR 0 1
6842: PPUSH
6843: CALL_OW 122
// if not HasTask ( i ) then
6847: LD_VAR 0 1
6851: PPUSH
6852: CALL_OW 314
6856: NOT
6857: IFFALSE 6877
// AddComRepairBuilding ( i , b [ 1 ] ) ;
6859: LD_VAR 0 1
6863: PPUSH
6864: LD_VAR 0 4
6868: PUSH
6869: LD_INT 1
6871: ARRAY
6872: PPUSH
6873: CALL_OW 190
// end ;
6877: GO 6763
6879: POP
6880: POP
// if tmp2 then
6881: LD_VAR 0 3
6885: IFFALSE 6968
// for i in tmp2 do
6887: LD_ADDR_VAR 0 1
6891: PUSH
6892: LD_VAR 0 3
6896: PUSH
6897: FOR_IN
6898: IFFALSE 6966
// begin if not GetTag ( i ) = 1 then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 110
6909: PUSH
6910: LD_INT 1
6912: EQUAL
6913: NOT
6914: IFFALSE 6928
// SetTag ( i , 1 ) ;
6916: LD_VAR 0 1
6920: PPUSH
6921: LD_INT 1
6923: PPUSH
6924: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
6928: LD_VAR 0 1
6932: PPUSH
6933: LD_INT 88
6935: PPUSH
6936: LD_INT 75
6938: PPUSH
6939: CALL_OW 297
6943: PUSH
6944: LD_INT 6
6946: GREATER
6947: IFFALSE 6964
// ComMoveXY ( i , 88 , 75 ) ;
6949: LD_VAR 0 1
6953: PPUSH
6954: LD_INT 88
6956: PPUSH
6957: LD_INT 75
6959: PPUSH
6960: CALL_OW 111
// end ;
6964: GO 6897
6966: POP
6967: POP
// end ;
6968: PPOPN 4
6970: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
6971: LD_EXP 7
6975: NOT
6976: PUSH
6977: LD_EXP 9
6981: AND
6982: PUSH
6983: LD_INT 9
6985: PPUSH
6986: LD_INT 22
6988: PUSH
6989: LD_INT 1
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: PUSH
6996: LD_INT 21
6998: PUSH
6999: LD_INT 1
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: PUSH
7006: LD_INT 3
7008: PUSH
7009: LD_INT 24
7011: PUSH
7012: LD_INT 1000
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: EMPTY
7024: LIST
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 70
7032: AND
7033: IFFALSE 7206
7035: GO 7037
7037: DISABLE
7038: LD_INT 0
7040: PPUSH
7041: PPUSH
7042: PPUSH
// begin enable ;
7043: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7044: LD_ADDR_VAR 0 2
7048: PUSH
7049: LD_INT 22
7051: PUSH
7052: LD_INT 1
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 25
7061: PUSH
7062: LD_INT 4
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: PPUSH
7073: CALL_OW 69
7077: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7078: LD_ADDR_VAR 0 3
7082: PUSH
7083: LD_INT 9
7085: PPUSH
7086: LD_INT 22
7088: PUSH
7089: LD_INT 1
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PUSH
7096: LD_INT 21
7098: PUSH
7099: LD_INT 1
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: LD_INT 3
7108: PUSH
7109: LD_INT 24
7111: PUSH
7112: LD_INT 1000
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: PPUSH
7128: CALL_OW 70
7132: ST_TO_ADDR
// if not sci or not tmp then
7133: LD_VAR 0 2
7137: NOT
7138: PUSH
7139: LD_VAR 0 3
7143: NOT
7144: OR
7145: IFFALSE 7149
// exit ;
7147: GO 7206
// for i in sci do
7149: LD_ADDR_VAR 0 1
7153: PUSH
7154: LD_VAR 0 2
7158: PUSH
7159: FOR_IN
7160: IFFALSE 7204
// if IsInUnit ( i ) then
7162: LD_VAR 0 1
7166: PPUSH
7167: CALL_OW 310
7171: IFFALSE 7184
// ComExitBuilding ( i ) else
7173: LD_VAR 0 1
7177: PPUSH
7178: CALL_OW 122
7182: GO 7202
// ComHeal ( i , tmp [ 1 ] ) ;
7184: LD_VAR 0 1
7188: PPUSH
7189: LD_VAR 0 3
7193: PUSH
7194: LD_INT 1
7196: ARRAY
7197: PPUSH
7198: CALL_OW 128
7202: GO 7159
7204: POP
7205: POP
// end ;
7206: PPOPN 3
7208: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7209: LD_EXP 7
7213: NOT
7214: PUSH
7215: LD_EXP 9
7219: AND
7220: PUSH
7221: LD_INT 1
7223: PPUSH
7224: CALL_OW 302
7228: AND
7229: PUSH
7230: LD_INT 9
7232: PPUSH
7233: LD_INT 22
7235: PUSH
7236: LD_INT 1
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 21
7245: PUSH
7246: LD_INT 1
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: LD_INT 3
7255: PUSH
7256: LD_INT 24
7258: PUSH
7259: LD_INT 1000
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: LIST
7274: PPUSH
7275: CALL_OW 70
7279: NOT
7280: AND
7281: PUSH
7282: LD_INT 22
7284: PUSH
7285: LD_INT 1
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: PUSH
7292: LD_INT 25
7294: PUSH
7295: LD_INT 4
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PUSH
7302: LD_INT 56
7304: PUSH
7305: EMPTY
7306: LIST
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: PPUSH
7313: CALL_OW 69
7317: AND
7318: IFFALSE 7411
7320: GO 7322
7322: DISABLE
7323: LD_INT 0
7325: PPUSH
// begin enable ;
7326: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7327: LD_ADDR_VAR 0 1
7331: PUSH
7332: LD_INT 22
7334: PUSH
7335: LD_INT 1
7337: PUSH
7338: EMPTY
7339: LIST
7340: LIST
7341: PUSH
7342: LD_INT 25
7344: PUSH
7345: LD_INT 4
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 56
7354: PUSH
7355: EMPTY
7356: LIST
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: LIST
7362: PPUSH
7363: CALL_OW 69
7367: PUSH
7368: FOR_IN
7369: IFFALSE 7409
// if not GetTag ( i ) and not HasTask ( i ) then
7371: LD_VAR 0 1
7375: PPUSH
7376: CALL_OW 110
7380: NOT
7381: PUSH
7382: LD_VAR 0 1
7386: PPUSH
7387: CALL_OW 314
7391: NOT
7392: AND
7393: IFFALSE 7407
// ComEnterUnit ( i , us_lab ) ;
7395: LD_VAR 0 1
7399: PPUSH
7400: LD_INT 1
7402: PPUSH
7403: CALL_OW 120
7407: GO 7368
7409: POP
7410: POP
// end ;
7411: PPOPN 1
7413: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7414: LD_EXP 7
7418: NOT
7419: PUSH
7420: LD_INT 9
7422: PPUSH
7423: LD_INT 22
7425: PUSH
7426: LD_INT 1
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PUSH
7433: LD_INT 21
7435: PUSH
7436: LD_INT 3
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: PUSH
7443: LD_INT 3
7445: PUSH
7446: LD_INT 24
7448: PUSH
7449: LD_INT 1000
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: PPUSH
7465: CALL_OW 70
7469: NOT
7470: AND
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_INT 1
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 25
7484: PUSH
7485: LD_INT 2
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: LD_INT 56
7494: PUSH
7495: EMPTY
7496: LIST
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: LIST
7502: PPUSH
7503: CALL_OW 69
7507: AND
7508: IFFALSE 7601
7510: GO 7512
7512: DISABLE
7513: LD_INT 0
7515: PPUSH
// begin enable ;
7516: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7517: LD_ADDR_VAR 0 1
7521: PUSH
7522: LD_INT 22
7524: PUSH
7525: LD_INT 1
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PUSH
7532: LD_INT 25
7534: PUSH
7535: LD_INT 2
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 56
7544: PUSH
7545: EMPTY
7546: LIST
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: LIST
7552: PPUSH
7553: CALL_OW 69
7557: PUSH
7558: FOR_IN
7559: IFFALSE 7599
// if not HasTask ( i ) and not GetTag ( i ) then
7561: LD_VAR 0 1
7565: PPUSH
7566: CALL_OW 314
7570: NOT
7571: PUSH
7572: LD_VAR 0 1
7576: PPUSH
7577: CALL_OW 110
7581: NOT
7582: AND
7583: IFFALSE 7597
// ComEnterUnit ( i , us_depot ) ;
7585: LD_VAR 0 1
7589: PPUSH
7590: LD_INT 5
7592: PPUSH
7593: CALL_OW 120
7597: GO 7558
7599: POP
7600: POP
// end ;
7601: PPOPN 1
7603: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7604: LD_EXP 9
7608: PUSH
7609: LD_INT 0
7611: LESSEQUAL
7612: PUSH
7613: LD_EXP 16
7617: PPUSH
7618: CALL_OW 301
7622: OR
7623: PUSH
7624: LD_INT 22
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 25
7636: PUSH
7637: LD_INT 2
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: PPUSH
7648: CALL_OW 69
7652: AND
7653: IFFALSE 7694
7655: GO 7657
7657: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7658: LD_INT 22
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PPUSH
7682: CALL_OW 69
7686: PPUSH
7687: LD_INT 1
7689: PPUSH
7690: CALL_OW 167
7694: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7695: LD_EXP 7
7699: NOT
7700: PUSH
7701: LD_INT 7
7703: PPUSH
7704: LD_INT 22
7706: PUSH
7707: LD_INT 7
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PPUSH
7714: CALL_OW 70
7718: AND
7719: IFFALSE 7810
7721: GO 7723
7723: DISABLE
7724: LD_INT 0
7726: PPUSH
// begin wait ( 0 0$2 ) ;
7727: LD_INT 70
7729: PPUSH
7730: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_INT 22
7741: PUSH
7742: LD_INT 1
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 25
7751: PUSH
7752: LD_INT 1
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PPUSH
7763: CALL_OW 69
7767: PUSH
7768: FOR_IN
7769: IFFALSE 7808
// begin if IsInUnit ( i ) then
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL_OW 310
7780: IFFALSE 7791
// ComExitBuilding ( i ) ;
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7791: LD_VAR 0 1
7795: PPUSH
7796: LD_INT 92
7798: PPUSH
7799: LD_INT 78
7801: PPUSH
7802: CALL_OW 174
// end ;
7806: GO 7768
7808: POP
7809: POP
// end ; end_of_file
7810: PPOPN 1
7812: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7813: LD_VAR 0 1
7817: PPUSH
7818: LD_VAR 0 2
7822: PPUSH
7823: LD_VAR 0 3
7827: PPUSH
7828: CALL 2786 0 3
7832: PPOPN 3
7834: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7835: LD_EXP 12
7839: PPUSH
7840: CALL_OW 257
7844: PUSH
7845: LD_INT 4
7847: EQUAL
7848: PUSH
7849: LD_EXP 13
7853: PPUSH
7854: CALL_OW 257
7858: PUSH
7859: LD_INT 4
7861: EQUAL
7862: OR
7863: IFFALSE 7867
// exit ;
7865: GO 7905
// if un = JMM then
7867: LD_VAR 0 1
7871: PUSH
7872: LD_EXP 12
7876: EQUAL
7877: IFFALSE 7886
// YouLost ( JMM ) ;
7879: LD_STRING JMM
7881: PPUSH
7882: CALL_OW 104
// if un = Burlak then
7886: LD_VAR 0 1
7890: PUSH
7891: LD_EXP 13
7895: EQUAL
7896: IFFALSE 7905
// YouLost ( Burlak ) ;
7898: LD_STRING Burlak
7900: PPUSH
7901: CALL_OW 104
// end ;
7905: PPOPN 1
7907: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7908: LD_VAR 0 1
7912: PUSH
7913: LD_EXP 12
7917: EQUAL
7918: IFFALSE 7927
// YouLost ( JMM ) ;
7920: LD_STRING JMM
7922: PPUSH
7923: CALL_OW 104
// if un = Burlak then
7927: LD_VAR 0 1
7931: PUSH
7932: LD_EXP 13
7936: EQUAL
7937: IFFALSE 7946
// YouLost ( Burlak ) ;
7939: LD_STRING Burlak
7941: PPUSH
7942: CALL_OW 104
// end ;
7946: PPOPN 1
7948: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
7949: LD_VAR 0 1
7953: PPUSH
7954: CALL_OW 255
7958: PUSH
7959: LD_INT 7
7961: EQUAL
7962: IFFALSE 7972
// artifactPickedUp := true ;
7964: LD_ADDR_EXP 6
7968: PUSH
7969: LD_INT 1
7971: ST_TO_ADDR
// end ;
7972: PPOPN 2
7974: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
7975: LD_ADDR_EXP 6
7979: PUSH
7980: LD_INT 0
7982: ST_TO_ADDR
7983: PPOPN 2
7985: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
7986: LD_VAR 0 1
7990: PPUSH
7991: CALL_OW 255
7995: PUSH
7996: LD_INT 1
7998: NONEQUAL
7999: IFFALSE 8003
// exit ;
8001: GO 8050
// wait ( 0 0$5 ) ;
8003: LD_INT 175
8005: PPUSH
8006: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8010: LD_VAR 0 1
8014: PPUSH
8015: CALL_OW 263
8019: PUSH
8020: LD_INT 2
8022: EQUAL
8023: IFFALSE 8034
// Connect ( vehicle ) ;
8025: LD_VAR 0 1
8029: PPUSH
8030: CALL 1787 0 1
// vehGuard := vehGuard ^ vehicle ;
8034: LD_ADDR_EXP 21
8038: PUSH
8039: LD_EXP 21
8043: PUSH
8044: LD_VAR 0 1
8048: ADD
8049: ST_TO_ADDR
// end ;
8050: PPOPN 2
8052: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8053: LD_VAR 0 1
8057: PUSH
8058: LD_INT 1
8060: EQUAL
8061: PUSH
8062: LD_EXP 7
8066: NOT
8067: AND
8068: IFFALSE 8103
// begin planCaptured := true ;
8070: LD_ADDR_EXP 7
8074: PUSH
8075: LD_INT 1
8077: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8078: LD_STRING MEnd
8080: PPUSH
8081: CALL_OW 337
// canEnd := true ;
8085: LD_ADDR_EXP 10
8089: PUSH
8090: LD_INT 1
8092: ST_TO_ADDR
// missionTime := tick ;
8093: LD_ADDR_EXP 11
8097: PUSH
8098: LD_OWVAR 1
8102: ST_TO_ADDR
// end ; end ;
8103: PPOPN 3
8105: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL 8260 0 1
// end ; end_of_file
8115: PPOPN 1
8117: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8118: GO 8120
8120: DISABLE
// begin ru_radar := 98 ;
8121: LD_ADDR_EXP 22
8125: PUSH
8126: LD_INT 98
8128: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8129: LD_ADDR_EXP 23
8133: PUSH
8134: LD_INT 89
8136: ST_TO_ADDR
// us_hack := 99 ;
8137: LD_ADDR_EXP 24
8141: PUSH
8142: LD_INT 99
8144: ST_TO_ADDR
// us_artillery := 97 ;
8145: LD_ADDR_EXP 25
8149: PUSH
8150: LD_INT 97
8152: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8153: LD_ADDR_EXP 26
8157: PUSH
8158: LD_INT 91
8160: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8161: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8162: LD_INT 0
8164: PPUSH
8165: PPUSH
8166: PPUSH
8167: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 264
8177: PUSH
8178: LD_EXP 26
8182: EQUAL
8183: IFFALSE 8255
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8185: LD_INT 68
8187: PPUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 255
8197: PPUSH
8198: CALL_OW 321
8202: PUSH
8203: LD_INT 2
8205: EQUAL
8206: IFFALSE 8218
// eff := 70 else
8208: LD_ADDR_VAR 0 6
8212: PUSH
8213: LD_INT 70
8215: ST_TO_ADDR
8216: GO 8226
// eff := 30 ;
8218: LD_ADDR_VAR 0 6
8222: PUSH
8223: LD_INT 30
8225: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8226: LD_VAR 0 1
8230: PPUSH
8231: CALL_OW 250
8235: PPUSH
8236: LD_VAR 0 1
8240: PPUSH
8241: CALL_OW 251
8245: PPUSH
8246: LD_VAR 0 6
8250: PPUSH
8251: CALL_OW 495
// end ; end ;
8255: LD_VAR 0 4
8259: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
// if cmd = 124 then
8268: LD_VAR 0 1
8272: PUSH
8273: LD_INT 124
8275: EQUAL
8276: IFFALSE 8482
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8278: LD_ADDR_VAR 0 5
8282: PUSH
8283: LD_INT 2
8285: PUSH
8286: LD_INT 34
8288: PUSH
8289: LD_INT 53
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PUSH
8296: LD_INT 34
8298: PUSH
8299: LD_INT 14
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: PPUSH
8311: CALL_OW 69
8315: ST_TO_ADDR
// if not tmp then
8316: LD_VAR 0 5
8320: NOT
8321: IFFALSE 8325
// exit ;
8323: GO 8482
// for i in tmp do
8325: LD_ADDR_VAR 0 3
8329: PUSH
8330: LD_VAR 0 5
8334: PUSH
8335: FOR_IN
8336: IFFALSE 8480
// begin taskList := GetTaskList ( i ) ;
8338: LD_ADDR_VAR 0 6
8342: PUSH
8343: LD_VAR 0 3
8347: PPUSH
8348: CALL_OW 437
8352: ST_TO_ADDR
// if not taskList then
8353: LD_VAR 0 6
8357: NOT
8358: IFFALSE 8362
// continue ;
8360: GO 8335
// for j = 1 to taskList do
8362: LD_ADDR_VAR 0 4
8366: PUSH
8367: DOUBLE
8368: LD_INT 1
8370: DEC
8371: ST_TO_ADDR
8372: LD_VAR 0 6
8376: PUSH
8377: FOR_TO
8378: IFFALSE 8476
// if taskList [ j ] [ 1 ] = | then
8380: LD_VAR 0 6
8384: PUSH
8385: LD_VAR 0 4
8389: ARRAY
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PUSH
8395: LD_STRING |
8397: EQUAL
8398: IFFALSE 8474
// begin _taskList := Delete ( taskList , 1 ) ;
8400: LD_ADDR_VAR 0 7
8404: PUSH
8405: LD_VAR 0 6
8409: PPUSH
8410: LD_INT 1
8412: PPUSH
8413: CALL_OW 3
8417: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8418: LD_VAR 0 3
8422: PPUSH
8423: LD_VAR 0 7
8427: PPUSH
8428: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8432: LD_VAR 0 3
8436: PPUSH
8437: LD_VAR 0 6
8441: PUSH
8442: LD_VAR 0 4
8446: ARRAY
8447: PUSH
8448: LD_INT 2
8450: ARRAY
8451: PPUSH
8452: LD_VAR 0 6
8456: PUSH
8457: LD_VAR 0 4
8461: ARRAY
8462: PUSH
8463: LD_INT 3
8465: ARRAY
8466: PPUSH
8467: LD_INT 8
8469: PPUSH
8470: CALL 8487 0 4
// end ;
8474: GO 8377
8476: POP
8477: POP
// end ;
8478: GO 8335
8480: POP
8481: POP
// end ; end ;
8482: LD_VAR 0 2
8486: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
8492: PPUSH
8493: PPUSH
8494: PPUSH
8495: PPUSH
8496: PPUSH
8497: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8498: LD_VAR 0 1
8502: NOT
8503: PUSH
8504: LD_VAR 0 2
8508: PPUSH
8509: LD_VAR 0 3
8513: PPUSH
8514: CALL_OW 488
8518: NOT
8519: OR
8520: PUSH
8521: LD_VAR 0 4
8525: NOT
8526: OR
8527: IFFALSE 8531
// exit ;
8529: GO 8871
// list := [ ] ;
8531: LD_ADDR_VAR 0 13
8535: PUSH
8536: EMPTY
8537: ST_TO_ADDR
// if x - r < 0 then
8538: LD_VAR 0 2
8542: PUSH
8543: LD_VAR 0 4
8547: MINUS
8548: PUSH
8549: LD_INT 0
8551: LESS
8552: IFFALSE 8564
// min_x := 0 else
8554: LD_ADDR_VAR 0 7
8558: PUSH
8559: LD_INT 0
8561: ST_TO_ADDR
8562: GO 8580
// min_x := x - r ;
8564: LD_ADDR_VAR 0 7
8568: PUSH
8569: LD_VAR 0 2
8573: PUSH
8574: LD_VAR 0 4
8578: MINUS
8579: ST_TO_ADDR
// if y - r < 0 then
8580: LD_VAR 0 3
8584: PUSH
8585: LD_VAR 0 4
8589: MINUS
8590: PUSH
8591: LD_INT 0
8593: LESS
8594: IFFALSE 8606
// min_y := 0 else
8596: LD_ADDR_VAR 0 8
8600: PUSH
8601: LD_INT 0
8603: ST_TO_ADDR
8604: GO 8622
// min_y := y - r ;
8606: LD_ADDR_VAR 0 8
8610: PUSH
8611: LD_VAR 0 3
8615: PUSH
8616: LD_VAR 0 4
8620: MINUS
8621: ST_TO_ADDR
// max_x := x + r ;
8622: LD_ADDR_VAR 0 9
8626: PUSH
8627: LD_VAR 0 2
8631: PUSH
8632: LD_VAR 0 4
8636: PLUS
8637: ST_TO_ADDR
// max_y := y + r ;
8638: LD_ADDR_VAR 0 10
8642: PUSH
8643: LD_VAR 0 3
8647: PUSH
8648: LD_VAR 0 4
8652: PLUS
8653: ST_TO_ADDR
// for _x = min_x to max_x do
8654: LD_ADDR_VAR 0 11
8658: PUSH
8659: DOUBLE
8660: LD_VAR 0 7
8664: DEC
8665: ST_TO_ADDR
8666: LD_VAR 0 9
8670: PUSH
8671: FOR_TO
8672: IFFALSE 8789
// for _y = min_y to max_y do
8674: LD_ADDR_VAR 0 12
8678: PUSH
8679: DOUBLE
8680: LD_VAR 0 8
8684: DEC
8685: ST_TO_ADDR
8686: LD_VAR 0 10
8690: PUSH
8691: FOR_TO
8692: IFFALSE 8785
// begin if not ValidHex ( _x , _y ) then
8694: LD_VAR 0 11
8698: PPUSH
8699: LD_VAR 0 12
8703: PPUSH
8704: CALL_OW 488
8708: NOT
8709: IFFALSE 8713
// continue ;
8711: GO 8691
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
8713: LD_VAR 0 11
8717: PPUSH
8718: LD_VAR 0 12
8722: PPUSH
8723: CALL_OW 351
8727: PUSH
8728: LD_VAR 0 11
8732: PPUSH
8733: LD_VAR 0 12
8737: PPUSH
8738: CALL_OW 554
8742: AND
8743: IFFALSE 8783
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
8745: LD_ADDR_VAR 0 13
8749: PUSH
8750: LD_VAR 0 13
8754: PPUSH
8755: LD_VAR 0 13
8759: PUSH
8760: LD_INT 1
8762: PLUS
8763: PPUSH
8764: LD_VAR 0 11
8768: PUSH
8769: LD_VAR 0 12
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: PPUSH
8778: CALL_OW 2
8782: ST_TO_ADDR
// end ;
8783: GO 8691
8785: POP
8786: POP
8787: GO 8671
8789: POP
8790: POP
// if not list then
8791: LD_VAR 0 13
8795: NOT
8796: IFFALSE 8800
// exit ;
8798: GO 8871
// for i in list do
8800: LD_ADDR_VAR 0 6
8804: PUSH
8805: LD_VAR 0 13
8809: PUSH
8810: FOR_IN
8811: IFFALSE 8869
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
8813: LD_VAR 0 1
8817: PPUSH
8818: LD_STRING M
8820: PUSH
8821: LD_VAR 0 6
8825: PUSH
8826: LD_INT 1
8828: ARRAY
8829: PUSH
8830: LD_VAR 0 6
8834: PUSH
8835: LD_INT 2
8837: ARRAY
8838: PUSH
8839: LD_INT 0
8841: PUSH
8842: LD_INT 0
8844: PUSH
8845: LD_INT 0
8847: PUSH
8848: LD_INT 0
8850: PUSH
8851: EMPTY
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: EMPTY
8861: LIST
8862: PPUSH
8863: CALL_OW 447
8867: GO 8810
8869: POP
8870: POP
// end ;
8871: LD_VAR 0 5
8875: RET
