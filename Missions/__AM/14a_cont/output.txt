// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 992 0 9
// PrepareAmerican ;
  46: CALL 5250 0 0
// PrepareAlliance ;
  50: CALL 189 0 0
// Action ;
  54: CALL 2141 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 11 11$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 23100
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
// uc_side := 7 ;
 198: LD_ADDR_OWVAR 20
 202: PUSH
 203: LD_INT 7
 205: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 206: LD_ADDR_EXP 12
 210: PUSH
 211: LD_STRING JMM
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 14a_
 222: PPUSH
 223: CALL 871 0 3
 227: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 228: LD_ADDR_EXP 13
 232: PUSH
 233: LD_STRING Burlak
 235: PPUSH
 236: LD_EXP 1
 240: NOT
 241: PPUSH
 242: LD_STRING 14a_
 244: PPUSH
 245: CALL 871 0 3
 249: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 250: LD_ADDR_EXP 14
 254: PUSH
 255: LD_STRING Joan
 257: PPUSH
 258: LD_EXP 1
 262: NOT
 263: PPUSH
 264: LD_STRING 13a_
 266: PPUSH
 267: CALL 871 0 3
 271: ST_TO_ADDR
// if not Joan then
 272: LD_EXP 14
 276: NOT
 277: IFFALSE 410
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 279: LD_ADDR_VAR 0 2
 283: PUSH
 284: LD_STRING 13a_others
 286: PPUSH
 287: CALL_OW 31
 291: ST_TO_ADDR
// if tmp then
 292: LD_VAR 0 2
 296: IFFALSE 372
// begin for i in tmp do
 298: LD_ADDR_VAR 0 3
 302: PUSH
 303: LD_VAR 0 2
 307: PUSH
 308: FOR_IN
 309: IFFALSE 370
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 311: LD_VAR 0 3
 315: PPUSH
 316: CALL_OW 257
 320: PUSH
 321: LD_INT 4
 323: EQUAL
 324: PUSH
 325: LD_VAR 0 3
 329: PPUSH
 330: CALL_OW 258
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: PUSH
 340: LD_VAR 0 3
 344: PPUSH
 345: CALL_OW 248
 349: PUSH
 350: LD_INT 3
 352: EQUAL
 353: AND
 354: IFFALSE 368
// begin RuSci := i ;
 356: LD_ADDR_EXP 15
 360: PUSH
 361: LD_VAR 0 3
 365: ST_TO_ADDR
// break ;
 366: GO 370
// end ;
 368: GO 308
 370: POP
 371: POP
// end ; if not RuSci then
 372: LD_EXP 15
 376: NOT
 377: IFFALSE 410
// begin uc_nation := 3 ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 10
 395: PPUSH
 396: CALL_OW 380
// RuSci := CreateHuman ;
 400: LD_ADDR_EXP 15
 404: PUSH
 405: CALL_OW 44
 409: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 410: LD_ADDR_VAR 0 6
 414: PUSH
 415: LD_STRING 14a_JMMVeh
 417: PPUSH
 418: LD_INT 5
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 1
 426: PUSH
 427: LD_INT 7
 429: PUSH
 430: LD_INT 0
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: PPUSH
 444: CALL_OW 30
 448: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 449: LD_ADDR_VAR 0 7
 453: PUSH
 454: LD_STRING 14a_BurlakVeh
 456: PPUSH
 457: LD_INT 22
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 51
 468: PUSH
 469: LD_INT 0
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 30
 487: ST_TO_ADDR
// uc_direction := 4 ;
 488: LD_ADDR_OWVAR 24
 492: PUSH
 493: LD_INT 4
 495: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 496: LD_ADDR_OWVAR 21
 500: PUSH
 501: LD_VAR 0 6
 505: PUSH
 506: LD_INT 6
 508: ARRAY
 509: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 510: LD_VAR 0 6
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 2
 526: ARRAY
 527: PPUSH
 528: LD_VAR 0 6
 532: PUSH
 533: LD_INT 3
 535: ARRAY
 536: PPUSH
 537: LD_VAR 0 6
 541: PUSH
 542: LD_INT 4
 544: ARRAY
 545: PPUSH
 546: LD_INT 60
 548: PPUSH
 549: LD_INT 80
 551: PPUSH
 552: CALL_OW 12
 556: PPUSH
 557: CALL 934 0 5
// JMMVeh := CreateVehicle ;
 561: LD_ADDR_VAR 0 4
 565: PUSH
 566: CALL_OW 45
 570: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 571: LD_VAR 0 4
 575: PPUSH
 576: LD_INT 1
 578: PPUSH
 579: LD_INT 0
 581: PPUSH
 582: CALL 1596 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 586: LD_VAR 0 6
 590: PUSH
 591: LD_INT 5
 593: ARRAY
 594: PUSH
 595: LD_INT 0
 597: NONEQUAL
 598: IFFALSE 618
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_VAR 0 6
 609: PUSH
 610: LD_INT 5
 612: ARRAY
 613: PPUSH
 614: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 618: LD_EXP 12
 622: PPUSH
 623: LD_VAR 0 4
 627: PPUSH
 628: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 632: LD_ADDR_OWVAR 21
 636: PUSH
 637: LD_VAR 0 7
 641: PUSH
 642: LD_INT 6
 644: ARRAY
 645: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 646: LD_VAR 0 7
 650: PUSH
 651: LD_INT 1
 653: ARRAY
 654: PPUSH
 655: LD_VAR 0 7
 659: PUSH
 660: LD_INT 2
 662: ARRAY
 663: PPUSH
 664: LD_VAR 0 7
 668: PUSH
 669: LD_INT 3
 671: ARRAY
 672: PPUSH
 673: LD_VAR 0 7
 677: PUSH
 678: LD_INT 4
 680: ARRAY
 681: PPUSH
 682: LD_INT 60
 684: PPUSH
 685: LD_INT 80
 687: PPUSH
 688: CALL_OW 12
 692: PPUSH
 693: CALL 934 0 5
// BurlakVeh := CreateVehicle ;
 697: LD_ADDR_VAR 0 5
 701: PUSH
 702: CALL_OW 45
 706: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 707: LD_VAR 0 5
 711: PPUSH
 712: LD_INT 1
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL 1596 0 3
 722: NOT
 723: IFFALSE 743
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 725: LD_VAR 0 5
 729: PPUSH
 730: LD_INT 233
 732: PPUSH
 733: LD_INT 85
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 743: LD_VAR 0 7
 747: PUSH
 748: LD_INT 5
 750: ARRAY
 751: PUSH
 752: LD_INT 0
 754: NONEQUAL
 755: IFFALSE 775
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 757: LD_VAR 0 5
 761: PPUSH
 762: LD_VAR 0 7
 766: PUSH
 767: LD_INT 5
 769: ARRAY
 770: PPUSH
 771: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 775: LD_EXP 13
 779: PPUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 178
 796: PUSH
 797: LD_INT 91
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: PUSH
 804: LD_INT 137
 806: PUSH
 807: LD_INT 83
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 157
 816: PUSH
 817: LD_INT 75
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: LIST
 828: PUSH
 829: LD_OWVAR 67
 833: ARRAY
 834: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 835: LD_INT 4
 837: PPUSH
 838: LD_INT 4
 840: PPUSH
 841: LD_VAR 0 2
 845: PUSH
 846: LD_INT 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 2
 854: PUSH
 855: LD_INT 2
 857: ARRAY
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 58
// end ; end_of_file
 866: LD_VAR 0 1
 870: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 871: LD_INT 0
 873: PPUSH
 874: PPUSH
// if exist_mode then
 875: LD_VAR 0 2
 879: IFFALSE 904
// unit := CreateCharacter ( prefix & ident ) else
 881: LD_ADDR_VAR 0 5
 885: PUSH
 886: LD_VAR 0 3
 890: PUSH
 891: LD_VAR 0 1
 895: STR
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
 902: GO 919
// unit := NewCharacter ( ident ) ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 25
 918: ST_TO_ADDR
// result := unit ;
 919: LD_ADDR_VAR 0 4
 923: PUSH
 924: LD_VAR 0 5
 928: ST_TO_ADDR
// end ;
 929: LD_VAR 0 4
 933: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 934: LD_INT 0
 936: PPUSH
// vc_chassis := chassis ;
 937: LD_ADDR_OWVAR 37
 941: PUSH
 942: LD_VAR 0 1
 946: ST_TO_ADDR
// vc_engine := engine ;
 947: LD_ADDR_OWVAR 39
 951: PUSH
 952: LD_VAR 0 2
 956: ST_TO_ADDR
// vc_control := control ;
 957: LD_ADDR_OWVAR 38
 961: PUSH
 962: LD_VAR 0 3
 966: ST_TO_ADDR
// vc_weapon := weapon ;
 967: LD_ADDR_OWVAR 40
 971: PUSH
 972: LD_VAR 0 4
 976: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 977: LD_ADDR_OWVAR 41
 981: PUSH
 982: LD_VAR 0 5
 986: ST_TO_ADDR
// end ;
 987: LD_VAR 0 6
 991: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
// uc_side = 0 ;
 997: LD_ADDR_OWVAR 20
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// uc_nation = 0 ;
1005: LD_ADDR_OWVAR 21
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// InitHc ;
1013: CALL_OW 19
// InitVc ;
1017: CALL_OW 20
// if mastodonts then
1021: LD_VAR 0 6
1025: IFFALSE 1092
// for i = 1 to mastodonts do
1027: LD_ADDR_VAR 0 11
1031: PUSH
1032: DOUBLE
1033: LD_INT 1
1035: DEC
1036: ST_TO_ADDR
1037: LD_VAR 0 6
1041: PUSH
1042: FOR_TO
1043: IFFALSE 1090
// begin vc_chassis := 31 ;
1045: LD_ADDR_OWVAR 37
1049: PUSH
1050: LD_INT 31
1052: ST_TO_ADDR
// vc_control := control_rider ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_INT 4
1060: ST_TO_ADDR
// animal := CreateVehicle ;
1061: LD_ADDR_VAR 0 12
1065: PUSH
1066: CALL_OW 45
1070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1071: LD_VAR 0 12
1075: PPUSH
1076: LD_VAR 0 8
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL 1596 0 3
// end ;
1088: GO 1042
1090: POP
1091: POP
// if horses then
1092: LD_VAR 0 5
1096: IFFALSE 1163
// for i = 1 to horses do
1098: LD_ADDR_VAR 0 11
1102: PUSH
1103: DOUBLE
1104: LD_INT 1
1106: DEC
1107: ST_TO_ADDR
1108: LD_VAR 0 5
1112: PUSH
1113: FOR_TO
1114: IFFALSE 1161
// begin hc_class := 21 ;
1116: LD_ADDR_OWVAR 28
1120: PUSH
1121: LD_INT 21
1123: ST_TO_ADDR
// hc_gallery :=  ;
1124: LD_ADDR_OWVAR 33
1128: PUSH
1129: LD_STRING 
1131: ST_TO_ADDR
// animal := CreateHuman ;
1132: LD_ADDR_VAR 0 12
1136: PUSH
1137: CALL_OW 44
1141: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1142: LD_VAR 0 12
1146: PPUSH
1147: LD_VAR 0 8
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL 1596 0 3
// end ;
1159: GO 1113
1161: POP
1162: POP
// if birds then
1163: LD_VAR 0 1
1167: IFFALSE 1234
// for i = 1 to birds do
1169: LD_ADDR_VAR 0 11
1173: PUSH
1174: DOUBLE
1175: LD_INT 1
1177: DEC
1178: ST_TO_ADDR
1179: LD_VAR 0 1
1183: PUSH
1184: FOR_TO
1185: IFFALSE 1232
// begin hc_class = 18 ;
1187: LD_ADDR_OWVAR 28
1191: PUSH
1192: LD_INT 18
1194: ST_TO_ADDR
// hc_gallery =  ;
1195: LD_ADDR_OWVAR 33
1199: PUSH
1200: LD_STRING 
1202: ST_TO_ADDR
// animal := CreateHuman ;
1203: LD_ADDR_VAR 0 12
1207: PUSH
1208: CALL_OW 44
1212: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1213: LD_VAR 0 12
1217: PPUSH
1218: LD_VAR 0 8
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL 1596 0 3
// end ;
1230: GO 1184
1232: POP
1233: POP
// if tigers then
1234: LD_VAR 0 2
1238: IFFALSE 1322
// for i = 1 to tigers do
1240: LD_ADDR_VAR 0 11
1244: PUSH
1245: DOUBLE
1246: LD_INT 1
1248: DEC
1249: ST_TO_ADDR
1250: LD_VAR 0 2
1254: PUSH
1255: FOR_TO
1256: IFFALSE 1320
// begin hc_class = class_tiger ;
1258: LD_ADDR_OWVAR 28
1262: PUSH
1263: LD_INT 14
1265: ST_TO_ADDR
// hc_gallery =  ;
1266: LD_ADDR_OWVAR 33
1270: PUSH
1271: LD_STRING 
1273: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1274: LD_ADDR_OWVAR 35
1278: PUSH
1279: LD_INT 7
1281: NEG
1282: PPUSH
1283: LD_INT 7
1285: PPUSH
1286: CALL_OW 12
1290: ST_TO_ADDR
// animal := CreateHuman ;
1291: LD_ADDR_VAR 0 12
1295: PUSH
1296: CALL_OW 44
1300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1301: LD_VAR 0 12
1305: PPUSH
1306: LD_VAR 0 8
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL 1596 0 3
// end ;
1318: GO 1255
1320: POP
1321: POP
// if apemans then
1322: LD_VAR 0 3
1326: IFFALSE 1449
// for i = 1 to apemans do
1328: LD_ADDR_VAR 0 11
1332: PUSH
1333: DOUBLE
1334: LD_INT 1
1336: DEC
1337: ST_TO_ADDR
1338: LD_VAR 0 3
1342: PUSH
1343: FOR_TO
1344: IFFALSE 1447
// begin hc_class = class_apeman ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 12
1353: ST_TO_ADDR
// hc_gallery =  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1362: LD_ADDR_OWVAR 35
1366: PUSH
1367: LD_INT 5
1369: NEG
1370: PPUSH
1371: LD_INT 5
1373: PPUSH
1374: CALL_OW 12
1378: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1379: LD_ADDR_OWVAR 31
1383: PUSH
1384: LD_INT 1
1386: PPUSH
1387: LD_INT 3
1389: PPUSH
1390: CALL_OW 12
1394: PUSH
1395: LD_INT 1
1397: PPUSH
1398: LD_INT 3
1400: PPUSH
1401: CALL_OW 12
1405: PUSH
1406: LD_INT 0
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: ST_TO_ADDR
// animal := CreateHuman ;
1418: LD_ADDR_VAR 0 12
1422: PUSH
1423: CALL_OW 44
1427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1428: LD_VAR 0 12
1432: PPUSH
1433: LD_VAR 0 8
1437: PPUSH
1438: LD_INT 0
1440: PPUSH
1441: CALL 1596 0 3
// end ;
1445: GO 1343
1447: POP
1448: POP
// if enchidnas then
1449: LD_VAR 0 4
1453: IFFALSE 1520
// for i = 1 to enchidnas do
1455: LD_ADDR_VAR 0 11
1459: PUSH
1460: DOUBLE
1461: LD_INT 1
1463: DEC
1464: ST_TO_ADDR
1465: LD_VAR 0 4
1469: PUSH
1470: FOR_TO
1471: IFFALSE 1518
// begin hc_class = 13 ;
1473: LD_ADDR_OWVAR 28
1477: PUSH
1478: LD_INT 13
1480: ST_TO_ADDR
// hc_gallery =  ;
1481: LD_ADDR_OWVAR 33
1485: PUSH
1486: LD_STRING 
1488: ST_TO_ADDR
// animal := CreateHuman ;
1489: LD_ADDR_VAR 0 12
1493: PUSH
1494: CALL_OW 44
1498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1499: LD_VAR 0 12
1503: PPUSH
1504: LD_VAR 0 8
1508: PPUSH
1509: LD_INT 0
1511: PPUSH
1512: CALL 1596 0 3
// end ;
1516: GO 1470
1518: POP
1519: POP
// if fishes then
1520: LD_VAR 0 7
1524: IFFALSE 1591
// for i = 1 to fishes do
1526: LD_ADDR_VAR 0 11
1530: PUSH
1531: DOUBLE
1532: LD_INT 1
1534: DEC
1535: ST_TO_ADDR
1536: LD_VAR 0 7
1540: PUSH
1541: FOR_TO
1542: IFFALSE 1589
// begin hc_class = 20 ;
1544: LD_ADDR_OWVAR 28
1548: PUSH
1549: LD_INT 20
1551: ST_TO_ADDR
// hc_gallery =  ;
1552: LD_ADDR_OWVAR 33
1556: PUSH
1557: LD_STRING 
1559: ST_TO_ADDR
// animal := CreateHuman ;
1560: LD_ADDR_VAR 0 12
1564: PUSH
1565: CALL_OW 44
1569: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1570: LD_VAR 0 12
1574: PPUSH
1575: LD_VAR 0 9
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL 1596 0 3
// end ;
1587: GO 1541
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 10
1595: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
// if not unit or not area then
1602: LD_VAR 0 1
1606: NOT
1607: PUSH
1608: LD_VAR 0 2
1612: NOT
1613: OR
1614: IFFALSE 1618
// exit ;
1616: GO 1782
// tmp := AreaToList ( area , i ) ;
1618: LD_ADDR_VAR 0 6
1622: PUSH
1623: LD_VAR 0 2
1627: PPUSH
1628: LD_VAR 0 5
1632: PPUSH
1633: CALL_OW 517
1637: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1638: LD_ADDR_VAR 0 5
1642: PUSH
1643: DOUBLE
1644: LD_INT 1
1646: DEC
1647: ST_TO_ADDR
1648: LD_VAR 0 6
1652: PUSH
1653: LD_INT 1
1655: ARRAY
1656: PUSH
1657: FOR_TO
1658: IFFALSE 1780
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1660: LD_ADDR_VAR 0 7
1664: PUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_INT 1
1672: ARRAY
1673: PUSH
1674: LD_VAR 0 5
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 6
1684: PUSH
1685: LD_INT 2
1687: ARRAY
1688: PUSH
1689: LD_VAR 0 5
1693: ARRAY
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1699: LD_VAR 0 7
1703: PUSH
1704: LD_INT 1
1706: ARRAY
1707: PPUSH
1708: LD_VAR 0 7
1712: PUSH
1713: LD_INT 2
1715: ARRAY
1716: PPUSH
1717: CALL_OW 428
1721: PUSH
1722: LD_INT 0
1724: EQUAL
1725: IFFALSE 1778
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1727: LD_VAR 0 1
1731: PPUSH
1732: LD_VAR 0 7
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_VAR 0 7
1745: PUSH
1746: LD_INT 2
1748: ARRAY
1749: PPUSH
1750: LD_VAR 0 3
1754: PPUSH
1755: CALL_OW 48
// result := IsPlaced ( unit ) ;
1759: LD_ADDR_VAR 0 4
1763: PUSH
1764: LD_VAR 0 1
1768: PPUSH
1769: CALL_OW 305
1773: ST_TO_ADDR
// exit ;
1774: POP
1775: POP
1776: GO 1782
// end ; end ;
1778: GO 1657
1780: POP
1781: POP
// end ;
1782: LD_VAR 0 4
1786: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
1791: PPUSH
1792: PPUSH
1793: PPUSH
1794: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1795: LD_VAR 0 1
1799: NOT
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 263
1810: PUSH
1811: LD_INT 2
1813: EQUAL
1814: NOT
1815: OR
1816: IFFALSE 1820
// exit ;
1818: GO 2136
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1820: LD_ADDR_VAR 0 6
1824: PUSH
1825: LD_INT 22
1827: PUSH
1828: LD_VAR 0 1
1832: PPUSH
1833: CALL_OW 255
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 2
1844: PUSH
1845: LD_INT 30
1847: PUSH
1848: LD_INT 36
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 34
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: PPUSH
1874: CALL_OW 69
1878: ST_TO_ADDR
// if not tmp then
1879: LD_VAR 0 6
1883: NOT
1884: IFFALSE 1888
// exit ;
1886: GO 2136
// result := [ ] ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: EMPTY
1894: ST_TO_ADDR
// for i in tmp do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: LD_VAR 0 6
1904: PUSH
1905: FOR_IN
1906: IFFALSE 1977
// begin t := UnitsInside ( i ) ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: LD_VAR 0 3
1917: PPUSH
1918: CALL_OW 313
1922: ST_TO_ADDR
// if t then
1923: LD_VAR 0 4
1927: IFFALSE 1975
// for j in t do
1929: LD_ADDR_VAR 0 7
1933: PUSH
1934: LD_VAR 0 4
1938: PUSH
1939: FOR_IN
1940: IFFALSE 1973
// result := Insert ( result , result + 1 , j ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_VAR 0 2
1956: PUSH
1957: LD_INT 1
1959: PLUS
1960: PPUSH
1961: LD_VAR 0 7
1965: PPUSH
1966: CALL_OW 2
1970: ST_TO_ADDR
1971: GO 1939
1973: POP
1974: POP
// end ;
1975: GO 1905
1977: POP
1978: POP
// if not result then
1979: LD_VAR 0 2
1983: NOT
1984: IFFALSE 1988
// exit ;
1986: GO 2136
// mech := result [ 1 ] ;
1988: LD_ADDR_VAR 0 5
1992: PUSH
1993: LD_VAR 0 2
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: ST_TO_ADDR
// if result > 1 then
2002: LD_VAR 0 2
2006: PUSH
2007: LD_INT 1
2009: GREATER
2010: IFFALSE 2122
// for i = 2 to result do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 2
2020: DEC
2021: ST_TO_ADDR
2022: LD_VAR 0 2
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2120
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2030: LD_ADDR_VAR 0 4
2034: PUSH
2035: LD_VAR 0 2
2039: PUSH
2040: LD_VAR 0 3
2044: ARRAY
2045: PPUSH
2046: LD_INT 3
2048: PPUSH
2049: CALL_OW 259
2053: PUSH
2054: LD_VAR 0 2
2058: PUSH
2059: LD_VAR 0 3
2063: ARRAY
2064: PPUSH
2065: CALL_OW 432
2069: MINUS
2070: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2071: LD_VAR 0 4
2075: PUSH
2076: LD_VAR 0 5
2080: PPUSH
2081: LD_INT 3
2083: PPUSH
2084: CALL_OW 259
2088: PUSH
2089: LD_VAR 0 5
2093: PPUSH
2094: CALL_OW 432
2098: MINUS
2099: GREATEREQUAL
2100: IFFALSE 2118
// mech := result [ i ] ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: ST_TO_ADDR
// end ;
2118: GO 2027
2120: POP
2121: POP
// ComLinkTo ( vehicle , mech ) ;
2122: LD_VAR 0 1
2126: PPUSH
2127: LD_VAR 0 5
2131: PPUSH
2132: CALL_OW 135
// end ; end_of_file
2136: LD_VAR 0 2
2140: RET
// export function Action ; begin
2141: LD_INT 0
2143: PPUSH
// InGameOn ;
2144: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2148: LD_INT 221
2150: PPUSH
2151: LD_INT 80
2153: PPUSH
2154: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2158: LD_EXP 12
2162: PUSH
2163: LD_EXP 13
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PPUSH
2172: LD_INT 217
2174: PPUSH
2175: LD_INT 79
2177: PPUSH
2178: CALL_OW 111
// wait ( 0 0$7 ) ;
2182: LD_INT 245
2184: PPUSH
2185: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2189: LD_EXP 12
2193: PUSH
2194: LD_EXP 13
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2207: LD_EXP 13
2211: PPUSH
2212: LD_STRING D2-Bur-1
2214: PPUSH
2215: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2219: LD_EXP 12
2223: PPUSH
2224: LD_STRING D2-JMM-1
2226: PPUSH
2227: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2231: LD_INT 18
2233: PPUSH
2234: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2238: LD_EXP 13
2242: PPUSH
2243: LD_EXP 12
2247: PPUSH
2248: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2252: LD_EXP 13
2256: PPUSH
2257: LD_STRING D2-Bur-2
2259: PPUSH
2260: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2264: LD_EXP 13
2268: PPUSH
2269: LD_INT 21
2271: PUSH
2272: LD_INT 2
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: PPUSH
2279: CALL_OW 69
2283: PPUSH
2284: LD_EXP 13
2288: PPUSH
2289: CALL_OW 74
2293: PPUSH
2294: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2298: LD_EXP 12
2302: PPUSH
2303: LD_INT 21
2305: PUSH
2306: LD_INT 2
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PPUSH
2313: CALL_OW 69
2317: PPUSH
2318: LD_EXP 12
2322: PPUSH
2323: CALL_OW 74
2327: PPUSH
2328: CALL_OW 120
// wait ( 0 0$1 ) ;
2332: LD_INT 35
2334: PPUSH
2335: CALL_OW 67
// InGameOff ;
2339: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2343: LD_STRING MArtPickup
2345: PPUSH
2346: CALL_OW 337
// end ;
2350: LD_VAR 0 1
2354: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2355: LD_EXP 20
2359: PPUSH
2360: LD_INT 101
2362: PUSH
2363: LD_INT 7
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: CALL_OW 72
2374: IFFALSE 2403
2376: GO 2378
2378: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2379: LD_EXP 13
2383: PPUSH
2384: LD_STRING D3-Bur-1
2386: PPUSH
2387: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2391: LD_EXP 12
2395: PPUSH
2396: LD_STRING D3-JMM-1
2398: PPUSH
2399: CALL_OW 88
// end ;
2403: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2404: LD_INT 5
2406: PPUSH
2407: LD_INT 22
2409: PUSH
2410: LD_INT 7
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PPUSH
2417: CALL_OW 70
2421: IFFALSE 2752
2423: GO 2425
2425: DISABLE
// begin wait ( 0 0$3 ) ;
2426: LD_INT 105
2428: PPUSH
2429: CALL_OW 67
// DialogueOn ;
2433: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2437: LD_EXP 12
2441: PPUSH
2442: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2446: LD_EXP 12
2450: PPUSH
2451: LD_STRING D3a-JMM-1
2453: PPUSH
2454: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2458: LD_EXP 13
2462: PPUSH
2463: LD_STRING D3a-Bur-1
2465: PPUSH
2466: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2470: LD_EXP 12
2474: PPUSH
2475: LD_STRING D3a-JMM-2
2477: PPUSH
2478: CALL_OW 88
// if Joan then
2482: LD_EXP 14
2486: IFFALSE 2502
// SayRadio ( Joan , D3a-Joan-2 ) else
2488: LD_EXP 14
2492: PPUSH
2493: LD_STRING D3a-Joan-2
2495: PPUSH
2496: CALL_OW 94
2500: GO 2514
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2502: LD_EXP 15
2506: PPUSH
2507: LD_STRING D3a-RSci1-2
2509: PPUSH
2510: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2514: LD_EXP 16
2518: PPUSH
2519: LD_STRING D3a-Huck-2
2521: PPUSH
2522: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2526: LD_EXP 17
2530: PPUSH
2531: LD_STRING D3a-Pow-2
2533: PPUSH
2534: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2538: LD_EXP 16
2542: PPUSH
2543: LD_STRING D3a-Huck-3
2545: PPUSH
2546: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2550: LD_EXP 17
2554: PPUSH
2555: LD_STRING D3a-Pow-3
2557: PPUSH
2558: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2562: LD_EXP 16
2566: PPUSH
2567: LD_STRING D3a-Huck-4
2569: PPUSH
2570: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2574: LD_EXP 12
2578: PPUSH
2579: LD_STRING D3a-JMM-4
2581: PPUSH
2582: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2586: LD_EXP 13
2590: PPUSH
2591: LD_STRING D3a-Bur-4
2593: PPUSH
2594: CALL_OW 88
// if Joan then
2598: LD_EXP 14
2602: IFFALSE 2618
// SayRadio ( Joan , D3a-Joan-4 ) else
2604: LD_EXP 14
2608: PPUSH
2609: LD_STRING D3a-Joan-4
2611: PPUSH
2612: CALL_OW 94
2616: GO 2630
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2618: LD_EXP 15
2622: PPUSH
2623: LD_STRING D3a-RSci1-4
2625: PPUSH
2626: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2630: LD_INT 133
2632: PPUSH
2633: LD_INT 43
2635: PPUSH
2636: LD_INT 7
2638: PPUSH
2639: LD_INT 10
2641: NEG
2642: PPUSH
2643: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2647: LD_INT 133
2649: PPUSH
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 7
2655: PPUSH
2656: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2660: LD_INT 133
2662: PPUSH
2663: LD_INT 43
2665: PPUSH
2666: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2677: LD_EXP 12
2681: PPUSH
2682: LD_STRING D3a-JMM-5
2684: PPUSH
2685: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2689: LD_EXP 13
2693: PPUSH
2694: LD_STRING D3a-Bur-5
2696: PPUSH
2697: CALL_OW 88
// DialogueOff ;
2701: CALL_OW 7
// seenBase := true ;
2705: LD_ADDR_EXP 8
2709: PUSH
2710: LD_INT 1
2712: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2713: LD_INT 525
2715: PUSH
2716: LD_INT 420
2718: PUSH
2719: LD_INT 315
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: PUSH
2727: LD_OWVAR 67
2731: ARRAY
2732: PPUSH
2733: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_INT 142
2744: PPUSH
2745: LD_INT 52
2747: PPUSH
2748: CALL_OW 116
// end ;
2752: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2753: LD_EXP 8
2757: NOT
2758: PUSH
2759: LD_EXP 4
2763: NOT
2764: AND
2765: IFFALSE 2785
2767: GO 2769
2769: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2770: LD_EXP 19
2774: PPUSH
2775: LD_INT 142
2777: PPUSH
2778: LD_INT 52
2780: PPUSH
2781: CALL_OW 116
2785: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2786: LD_INT 0
2788: PPUSH
2789: PPUSH
// contaminateTime := tick ;
2790: LD_ADDR_EXP 3
2794: PUSH
2795: LD_OWVAR 1
2799: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2800: LD_INT 175
2802: PPUSH
2803: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2807: LD_ADDR_VAR 0 5
2811: PUSH
2812: LD_INT 4
2814: PPUSH
2815: CALL_OW 469
2819: ST_TO_ADDR
// if art then
2820: LD_VAR 0 5
2824: IFFALSE 2863
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2826: LD_VAR 0 5
2830: PUSH
2831: LD_INT 1
2833: ARRAY
2834: PUSH
2835: LD_INT 157
2837: EQUAL
2838: PUSH
2839: LD_VAR 0 5
2843: PUSH
2844: LD_INT 2
2846: ARRAY
2847: PUSH
2848: LD_INT 75
2850: EQUAL
2851: AND
2852: IFFALSE 2863
// begin YouLost ( Artefact ) ;
2854: LD_STRING Artefact
2856: PPUSH
2857: CALL_OW 104
// exit ;
2861: GO 3015
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2863: LD_EXP 12
2867: PPUSH
2868: CALL_OW 302
2872: PUSH
2873: LD_EXP 13
2877: PPUSH
2878: CALL_OW 302
2882: AND
2883: IFFALSE 2960
// begin DialogueOn ;
2885: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2889: LD_EXP 12
2893: PPUSH
2894: LD_STRING D6a-JMM-1
2896: PPUSH
2897: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2901: LD_EXP 13
2905: PPUSH
2906: LD_STRING D6a-Bur-1
2908: PPUSH
2909: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2913: LD_EXP 12
2917: PPUSH
2918: LD_STRING D6c-JMM-1
2920: PPUSH
2921: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2925: LD_EXP 13
2929: PPUSH
2930: LD_STRING D6c-Bur-1
2932: PPUSH
2933: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2937: LD_EXP 12
2941: PPUSH
2942: LD_STRING D6c-JMM-2
2944: PPUSH
2945: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2949: LD_STRING MBase
2951: PPUSH
2952: CALL_OW 337
// DialogueOff ;
2956: CALL_OW 7
// end ; bombExploded := true ;
2960: LD_ADDR_EXP 4
2964: PUSH
2965: LD_INT 1
2967: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
2968: LD_INT 6300
2970: PUSH
2971: LD_INT 5250
2973: PUSH
2974: LD_INT 4200
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PUSH
2982: LD_OWVAR 67
2986: ARRAY
2987: PPUSH
2988: CALL_OW 67
// if IsOk ( JMM ) then
2992: LD_EXP 12
2996: PPUSH
2997: CALL_OW 302
3001: IFFALSE 3015
// Say ( JMM , D8-JMM-1 ) ;
3003: LD_EXP 12
3007: PPUSH
3008: LD_STRING D8-JMM-1
3010: PPUSH
3011: CALL_OW 88
// end ;
3015: LD_VAR 0 4
3019: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3020: LD_EXP 9
3024: PUSH
3025: LD_EXP 7
3029: NOT
3030: AND
3031: PUSH
3032: LD_EXP 4
3036: AND
3037: IFFALSE 3092
3039: GO 3041
3041: DISABLE
// begin enable ;
3042: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3043: LD_INT 9
3045: PPUSH
3046: LD_INT 22
3048: PUSH
3049: LD_INT 7
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PPUSH
3056: CALL_OW 70
3060: IFFALSE 3078
// stevensTimer := stevensTimer - 0 0$30 else
3062: LD_ADDR_EXP 9
3066: PUSH
3067: LD_EXP 9
3071: PUSH
3072: LD_INT 1050
3074: MINUS
3075: ST_TO_ADDR
3076: GO 3092
// stevensTimer := stevensTimer - 0 0$1 ;
3078: LD_ADDR_EXP 9
3082: PUSH
3083: LD_EXP 9
3087: PUSH
3088: LD_INT 35
3090: MINUS
3091: ST_TO_ADDR
// end ;
3092: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3093: LD_EXP 9
3097: PUSH
3098: LD_INT 0
3100: LESSEQUAL
3101: PUSH
3102: LD_EXP 7
3106: NOT
3107: AND
3108: IFFALSE 3272
3110: GO 3112
3112: DISABLE
3113: LD_INT 0
3115: PPUSH
3116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: LD_INT 22
3124: PUSH
3125: LD_INT 1
3127: PUSH
3128: EMPTY
3129: LIST
3130: LIST
3131: PUSH
3132: LD_INT 25
3134: PUSH
3135: LD_INT 4
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: PPUSH
3146: CALL_OW 69
3150: ST_TO_ADDR
// for i in tmp do
3151: LD_ADDR_VAR 0 1
3155: PUSH
3156: LD_VAR 0 2
3160: PUSH
3161: FOR_IN
3162: IFFALSE 3215
// begin if IsInUnit ( i ) then
3164: LD_VAR 0 1
3168: PPUSH
3169: CALL_OW 310
3173: IFFALSE 3186
// ComExitBuilding ( i ) else
3175: LD_VAR 0 1
3179: PPUSH
3180: CALL_OW 122
3184: GO 3213
// if not HasTask ( i ) then
3186: LD_VAR 0 1
3190: PPUSH
3191: CALL_OW 314
3195: NOT
3196: IFFALSE 3213
// ComMoveXY ( i , 29 , 56 ) ;
3198: LD_VAR 0 1
3202: PPUSH
3203: LD_INT 29
3205: PPUSH
3206: LD_INT 56
3208: PPUSH
3209: CALL_OW 111
// end ;
3213: GO 3161
3215: POP
3216: POP
// repeat wait ( 0 0$1 ) ;
3217: LD_INT 35
3219: PPUSH
3220: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3224: LD_INT 8
3226: PPUSH
3227: LD_INT 22
3229: PUSH
3230: LD_INT 1
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: LD_INT 25
3239: PUSH
3240: LD_INT 4
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PPUSH
3251: CALL_OW 70
3255: IFFALSE 3217
// if planCaptured then
3257: LD_EXP 7
3261: IFFALSE 3265
// exit ;
3263: GO 3272
// YouLost ( Time ) ;
3265: LD_STRING Time
3267: PPUSH
3268: CALL_OW 104
// end ;
3272: PPOPN 2
3274: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3275: LD_INT 22
3277: PUSH
3278: LD_INT 7
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: PUSH
3285: LD_INT 92
3287: PUSH
3288: LD_INT 142
3290: PUSH
3291: LD_INT 52
3293: PUSH
3294: LD_INT 27
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 69
3311: PUSH
3312: LD_EXP 3
3316: PUSH
3317: LD_INT 6000
3319: PLUS
3320: PUSH
3321: LD_OWVAR 1
3325: GREATER
3326: AND
3327: PUSH
3328: LD_EXP 4
3332: AND
3333: IFFALSE 3388
3335: GO 3337
3337: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3338: LD_EXP 12
3342: PUSH
3343: LD_EXP 13
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PPUSH
3352: CALL_OW 85
// DialogueOn ;
3356: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3360: LD_EXP 12
3364: PPUSH
3365: LD_STRING D6b-JMM-1
3367: PPUSH
3368: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3372: LD_EXP 13
3376: PPUSH
3377: LD_STRING D6b-Bur-1
3379: PPUSH
3380: CALL_OW 88
// DialogueOff ;
3384: CALL_OW 7
// end ;
3388: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3389: LD_EXP 13
3393: PPUSH
3394: LD_INT 142
3396: PPUSH
3397: LD_INT 52
3399: PPUSH
3400: CALL_OW 297
3404: PUSH
3405: LD_INT 25
3407: LESS
3408: PUSH
3409: LD_EXP 13
3413: PPUSH
3414: CALL_OW 310
3418: PPUSH
3419: LD_INT 142
3421: PPUSH
3422: LD_INT 52
3424: PPUSH
3425: CALL_OW 297
3429: PUSH
3430: LD_INT 25
3432: LESS
3433: OR
3434: PUSH
3435: LD_EXP 13
3439: PPUSH
3440: CALL_OW 256
3444: PUSH
3445: LD_INT 1000
3447: LESS
3448: AND
3449: PUSH
3450: LD_EXP 3
3454: PUSH
3455: LD_INT 6000
3457: PLUS
3458: PUSH
3459: LD_OWVAR 1
3463: GREATER
3464: AND
3465: PUSH
3466: LD_EXP 4
3470: AND
3471: IFFALSE 3504
3473: GO 3475
3475: DISABLE
// begin DialogueOn ;
3476: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3480: LD_EXP 13
3484: PPUSH
3485: LD_STRING D7-Bur-1
3487: PPUSH
3488: CALL_OW 88
// enteredContaminatedArea := true ;
3492: LD_ADDR_EXP 5
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// DialogueOff ;
3500: CALL_OW 7
// end ;
3504: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3505: LD_EXP 12
3509: PPUSH
3510: LD_INT 142
3512: PPUSH
3513: LD_INT 52
3515: PPUSH
3516: CALL_OW 297
3520: PUSH
3521: LD_INT 25
3523: LESS
3524: PUSH
3525: LD_EXP 12
3529: PPUSH
3530: CALL_OW 310
3534: PPUSH
3535: LD_INT 142
3537: PPUSH
3538: LD_INT 52
3540: PPUSH
3541: CALL_OW 297
3545: PUSH
3546: LD_INT 25
3548: LESS
3549: OR
3550: PUSH
3551: LD_EXP 12
3555: PPUSH
3556: CALL_OW 256
3560: PUSH
3561: LD_INT 1000
3563: LESS
3564: AND
3565: PUSH
3566: LD_EXP 3
3570: PUSH
3571: LD_INT 6000
3573: PLUS
3574: PUSH
3575: LD_OWVAR 1
3579: GREATER
3580: AND
3581: PUSH
3582: LD_EXP 4
3586: AND
3587: IFFALSE 3620
3589: GO 3591
3591: DISABLE
// begin DialogueOn ;
3592: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3596: LD_EXP 12
3600: PPUSH
3601: LD_STRING D7-JMM-1
3603: PPUSH
3604: CALL_OW 88
// enteredContaminatedArea := true ;
3608: LD_ADDR_EXP 5
3612: PUSH
3613: LD_INT 1
3615: ST_TO_ADDR
// DialogueOff ;
3616: CALL_OW 7
// end ;
3620: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3621: LD_EXP 6
3625: PUSH
3626: LD_EXP 12
3630: PPUSH
3631: CALL_OW 302
3635: AND
3636: PUSH
3637: LD_EXP 13
3641: PPUSH
3642: CALL_OW 302
3646: AND
3647: IFFALSE 3716
3649: GO 3651
3651: DISABLE
// begin DialogueOn ;
3652: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3656: LD_EXP 12
3660: PUSH
3661: LD_EXP 13
3665: PUSH
3666: EMPTY
3667: LIST
3668: LIST
3669: PPUSH
3670: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3674: LD_EXP 12
3678: PPUSH
3679: LD_STRING D4-JMM-1
3681: PPUSH
3682: CALL_OW 88
// if not bombExploded then
3686: LD_EXP 4
3690: NOT
3691: IFFALSE 3705
// Say ( Burlak , D4-Bur-1 ) ;
3693: LD_EXP 13
3697: PPUSH
3698: LD_STRING D4-Bur-1
3700: PPUSH
3701: CALL_OW 88
// DialogueOff ;
3705: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3709: LD_STRING MReturn
3711: PPUSH
3712: CALL_OW 337
// end ;
3716: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3717: LD_EXP 7
3721: NOT
3722: PUSH
3723: LD_INT 22
3725: PUSH
3726: LD_INT 7
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: LD_INT 91
3735: PUSH
3736: LD_INT 9
3738: PUSH
3739: LD_INT 6
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PPUSH
3751: CALL_OW 69
3755: AND
3756: IFFALSE 3833
3758: GO 3760
3760: DISABLE
// begin DialogueOn ;
3761: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3765: LD_INT 55
3767: PPUSH
3768: LD_INT 11
3770: PPUSH
3771: LD_INT 7
3773: PPUSH
3774: LD_INT 6
3776: NEG
3777: PPUSH
3778: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3782: LD_INT 55
3784: PPUSH
3785: LD_INT 11
3787: PPUSH
3788: LD_INT 7
3790: PPUSH
3791: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3795: LD_EXP 13
3799: PPUSH
3800: LD_STRING D9-Bur-1
3802: PPUSH
3803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3807: LD_EXP 12
3811: PPUSH
3812: LD_STRING D9-JMM-1
3814: PPUSH
3815: CALL_OW 88
// DialogueOff ;
3819: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3823: LD_INT 9
3825: PPUSH
3826: LD_INT 7
3828: PPUSH
3829: CALL_OW 235
// end ;
3833: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3834: LD_INT 9
3836: PPUSH
3837: LD_INT 22
3839: PUSH
3840: LD_INT 7
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PPUSH
3847: CALL_OW 70
3851: IFFALSE 3887
3853: GO 3855
3855: DISABLE
// begin wait ( 0 0$07 ) ;
3856: LD_INT 245
3858: PPUSH
3859: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3863: LD_EXP 12
3867: PPUSH
3868: LD_STRING D10b-JMM-1
3870: PPUSH
3871: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3875: LD_EXP 13
3879: PPUSH
3880: LD_STRING D10b-Bur-1
3882: PPUSH
3883: CALL_OW 88
// end ;
3887: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3888: LD_EXP 9
3892: PUSH
3893: LD_INT 22
3895: PUSH
3896: LD_INT 1
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 25
3905: PUSH
3906: LD_INT 4
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: LD_INT 26
3915: PUSH
3916: LD_INT 1
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 69
3932: AND
3933: PUSH
3934: LD_INT 5
3936: PPUSH
3937: CALL_OW 255
3941: PUSH
3942: LD_INT 7
3944: EQUAL
3945: PUSH
3946: LD_INT 22
3948: PUSH
3949: LD_INT 1
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 25
3958: PUSH
3959: LD_INT 1
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: PPUSH
3970: CALL_OW 69
3974: PUSH
3975: LD_INT 0
3977: EQUAL
3978: OR
3979: AND
3980: IFFALSE 4562
3982: GO 3984
3984: DISABLE
3985: LD_INT 0
3987: PPUSH
// begin case Query ( QKill ) of 1 :
3988: LD_STRING QKill
3990: PPUSH
3991: CALL_OW 97
3995: PUSH
3996: LD_INT 1
3998: DOUBLE
3999: EQUAL
4000: IFTRUE 4004
4002: GO 4550
4004: POP
// begin DialogueOn ;
4005: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4009: LD_EXP 12
4013: PPUSH
4014: LD_STRING D10a-JMM-1
4016: PPUSH
4017: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4021: LD_EXP 13
4025: PPUSH
4026: LD_STRING D10a-Bur-1
4028: PPUSH
4029: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4033: LD_EXP 12
4037: PPUSH
4038: LD_STRING D10a-JMM-2
4040: PPUSH
4041: CALL_OW 88
// if IsOk ( Stevens ) then
4045: LD_EXP 16
4049: PPUSH
4050: CALL_OW 302
4054: IFFALSE 4070
// Say ( Stevens , D10a-Huck-2 ) else
4056: LD_EXP 16
4060: PPUSH
4061: LD_STRING D10a-Huck-2
4063: PPUSH
4064: CALL_OW 88
4068: GO 4121
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4070: LD_INT 22
4072: PUSH
4073: LD_INT 1
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: PUSH
4080: LD_INT 25
4082: PUSH
4083: LD_INT 4
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PUSH
4090: LD_INT 26
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: PPUSH
4105: CALL_OW 69
4109: PUSH
4110: LD_INT 1
4112: ARRAY
4113: PPUSH
4114: LD_STRING D10a-ASci1-3
4116: PPUSH
4117: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4121: LD_EXP 12
4125: PPUSH
4126: LD_STRING D10a-JMM-4
4128: PPUSH
4129: CALL_OW 88
// if IsOk ( Stevens ) then
4133: LD_EXP 16
4137: PPUSH
4138: CALL_OW 302
4142: IFFALSE 4156
// Say ( Stevens , D10a-Huck-3 ) ;
4144: LD_EXP 16
4148: PPUSH
4149: LD_STRING D10a-Huck-3
4151: PPUSH
4152: CALL_OW 88
// DialogueOff ;
4156: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4160: LD_INT 1
4162: PPUSH
4163: LD_INT 7
4165: PPUSH
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 80
// planCaptured := true ;
4176: LD_ADDR_EXP 7
4180: PUSH
4181: LD_INT 1
4183: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4184: LD_STRING MEnd
4186: PPUSH
4187: CALL_OW 337
// canEnd := true ;
4191: LD_ADDR_EXP 10
4195: PUSH
4196: LD_INT 1
4198: ST_TO_ADDR
// missionTime := tick ;
4199: LD_ADDR_EXP 11
4203: PUSH
4204: LD_OWVAR 1
4208: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4209: LD_INT 35
4211: PPUSH
4212: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4216: LD_INT 22
4218: PUSH
4219: LD_INT 1
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PUSH
4226: LD_INT 3
4228: PUSH
4229: LD_INT 50
4231: PUSH
4232: EMPTY
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: PPUSH
4243: CALL_OW 69
4247: IFFALSE 4363
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4249: LD_ADDR_VAR 0 1
4253: PUSH
4254: LD_INT 22
4256: PUSH
4257: LD_INT 1
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 25
4266: PUSH
4267: LD_INT 4
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4361
// begin if IsInUnit ( i ) then
4286: LD_VAR 0 1
4290: PPUSH
4291: CALL_OW 310
4295: IFFALSE 4308
// ComExitBuilding ( i ) else
4297: LD_VAR 0 1
4301: PPUSH
4302: CALL_OW 122
4306: GO 4359
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4308: LD_VAR 0 1
4312: PPUSH
4313: LD_INT 22
4315: PUSH
4316: LD_INT 1
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PUSH
4323: LD_INT 3
4325: PUSH
4326: LD_INT 50
4328: PUSH
4329: EMPTY
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: PPUSH
4340: CALL_OW 69
4344: PPUSH
4345: LD_VAR 0 1
4349: PPUSH
4350: CALL_OW 74
4354: PPUSH
4355: CALL_OW 128
// end ;
4359: GO 4283
4361: POP
4362: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4363: LD_INT 22
4365: PUSH
4366: LD_INT 1
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 3
4375: PUSH
4376: LD_INT 50
4378: PUSH
4379: EMPTY
4380: LIST
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: PPUSH
4390: CALL_OW 69
4394: NOT
4395: IFFALSE 4209
// repeat wait ( 3 ) ;
4397: LD_INT 3
4399: PPUSH
4400: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4404: LD_ADDR_VAR 0 1
4408: PUSH
4409: LD_INT 22
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: PUSH
4419: LD_INT 21
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 69
4437: PUSH
4438: FOR_IN
4439: IFFALSE 4515
// begin if IsInArea ( i , stevensEscapeArea ) then
4441: LD_VAR 0 1
4445: PPUSH
4446: LD_INT 8
4448: PPUSH
4449: CALL_OW 308
4453: IFFALSE 4466
// begin RemoveUnit ( i ) ;
4455: LD_VAR 0 1
4459: PPUSH
4460: CALL_OW 64
// continue ;
4464: GO 4438
// end ; if IsInUnit ( i ) then
4466: LD_VAR 0 1
4470: PPUSH
4471: CALL_OW 310
4475: IFFALSE 4486
// ComExitBuilding ( i ) ;
4477: LD_VAR 0 1
4481: PPUSH
4482: CALL_OW 122
// if not HasTask ( i ) then
4486: LD_VAR 0 1
4490: PPUSH
4491: CALL_OW 314
4495: NOT
4496: IFFALSE 4513
// ComMoveXY ( i , 28 , 55 ) ;
4498: LD_VAR 0 1
4502: PPUSH
4503: LD_INT 28
4505: PPUSH
4506: LD_INT 55
4508: PPUSH
4509: CALL_OW 111
// end ;
4513: GO 4438
4515: POP
4516: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4517: LD_INT 22
4519: PUSH
4520: LD_INT 1
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 21
4529: PUSH
4530: LD_INT 1
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PPUSH
4541: CALL_OW 69
4545: NOT
4546: IFFALSE 4397
// end ; 2 :
4548: GO 4562
4550: LD_INT 2
4552: DOUBLE
4553: EQUAL
4554: IFTRUE 4558
4556: GO 4561
4558: POP
// ; end ;
4559: GO 4562
4561: POP
// end ;
4562: PPOPN 1
4564: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4565: LD_EXP 10
4569: IFFALSE 4926
4571: GO 4573
4573: DISABLE
4574: LD_INT 0
4576: PPUSH
4577: PPUSH
4578: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4579: LD_INT 10
4581: PPUSH
4582: LD_INT 1
4584: PPUSH
4585: CALL_OW 424
// if Difficulty < 2 then
4589: LD_OWVAR 67
4593: PUSH
4594: LD_INT 2
4596: LESS
4597: IFFALSE 4601
// exit ;
4599: GO 4926
// uc_side := 4 ;
4601: LD_ADDR_OWVAR 20
4605: PUSH
4606: LD_INT 4
4608: ST_TO_ADDR
// uc_nation := 1 ;
4609: LD_ADDR_OWVAR 21
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// InitHc ;
4617: CALL_OW 19
// tmp := [ ] ;
4621: LD_ADDR_VAR 0 3
4625: PUSH
4626: EMPTY
4627: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4628: LD_INT 0
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 10
4636: PPUSH
4637: CALL_OW 380
// un := CreateHuman ;
4641: LD_ADDR_VAR 0 1
4645: PUSH
4646: CALL_OW 44
4650: ST_TO_ADDR
// tmp := [ un ] ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: LD_VAR 0 1
4660: PUSH
4661: EMPTY
4662: LIST
4663: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4664: LD_VAR 0 1
4668: PPUSH
4669: LD_INT 226
4671: PPUSH
4672: LD_INT 86
4674: PPUSH
4675: LD_INT 0
4677: PPUSH
4678: CALL_OW 48
// ComHold ( un ) ;
4682: LD_VAR 0 1
4686: PPUSH
4687: CALL_OW 140
// for i = 1 to 3 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 3
4703: PUSH
4704: FOR_TO
4705: IFFALSE 4804
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4707: LD_INT 0
4709: PPUSH
4710: LD_INT 1
4712: PPUSH
4713: LD_INT 8
4715: PPUSH
4716: CALL_OW 380
// un := CreateHuman ;
4720: LD_ADDR_VAR 0 1
4724: PUSH
4725: CALL_OW 44
4729: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4730: LD_VAR 0 1
4734: PPUSH
4735: LD_INT 5
4737: PPUSH
4738: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4742: LD_VAR 0 1
4746: PPUSH
4747: LD_INT 215
4749: PUSH
4750: LD_INT 217
4752: PUSH
4753: LD_INT 219
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_VAR 0 2
4765: ARRAY
4766: PPUSH
4767: LD_INT 76
4769: PPUSH
4770: LD_INT 0
4772: PPUSH
4773: CALL_OW 48
// ComCrawl ( un ) ;
4777: LD_VAR 0 1
4781: PPUSH
4782: CALL_OW 137
// tmp := tmp ^ un ;
4786: LD_ADDR_VAR 0 3
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: LD_VAR 0 1
4800: ADD
4801: ST_TO_ADDR
// end ;
4802: GO 4704
4804: POP
4805: POP
// repeat wait ( 0 0$1 ) ;
4806: LD_INT 35
4808: PPUSH
4809: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4813: LD_VAR 0 1
4817: PPUSH
4818: LD_INT 24
4820: PUSH
4821: LD_INT 1000
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PPUSH
4828: CALL_OW 72
4832: NOT
4833: IFFALSE 4806
// for i in tmp do
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_VAR 0 3
4844: PUSH
4845: FOR_IN
4846: IFFALSE 4924
// begin wait ( 0 0$1 ) ;
4848: LD_INT 35
4850: PPUSH
4851: CALL_OW 67
// if Crawls ( i ) then
4855: LD_VAR 0 2
4859: PPUSH
4860: CALL_OW 318
4864: IFFALSE 4877
// ComWalk ( i ) else
4866: LD_VAR 0 2
4870: PPUSH
4871: CALL_OW 138
4875: GO 4922
// if GetClass ( i ) = class_sniper then
4877: LD_VAR 0 2
4881: PPUSH
4882: CALL_OW 257
4886: PUSH
4887: LD_INT 5
4889: EQUAL
4890: IFFALSE 4908
// ComAttackSoporific ( i , JMM ) else
4892: LD_VAR 0 2
4896: PPUSH
4897: LD_EXP 12
4901: PPUSH
4902: CALL_OW 166
4906: GO 4922
// ComAttackUnit ( i , JMM ) ;
4908: LD_VAR 0 2
4912: PPUSH
4913: LD_EXP 12
4917: PPUSH
4918: CALL_OW 115
// end ;
4922: GO 4845
4924: POP
4925: POP
// end ;
4926: PPOPN 3
4928: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4929: LD_EXP 7
4933: NOT
4934: PUSH
4935: LD_INT 1
4937: PPUSH
4938: CALL_OW 301
4942: AND
4943: IFFALSE 4955
4945: GO 4947
4947: DISABLE
// YouLost ( Lab ) ;
4948: LD_STRING Lab
4950: PPUSH
4951: CALL_OW 104
4955: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
4956: LD_INT 10
4958: PPUSH
4959: LD_INT 22
4961: PUSH
4962: LD_INT 7
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 70
4973: PUSH
4974: LD_INT 2
4976: GREATEREQUAL
4977: PUSH
4978: LD_INT 10
4980: PPUSH
4981: LD_INT 2
4983: PUSH
4984: LD_INT 34
4986: PUSH
4987: LD_INT 12
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 34
4996: PUSH
4997: LD_INT 51
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: LIST
5008: PPUSH
5009: CALL_OW 70
5013: AND
5014: PUSH
5015: LD_EXP 10
5019: AND
5020: PUSH
5021: LD_EXP 7
5025: AND
5026: PUSH
5027: LD_EXP 6
5031: AND
5032: IFFALSE 5247
5034: GO 5036
5036: DISABLE
5037: LD_INT 0
5039: PPUSH
5040: PPUSH
// begin m1 := false ;
5041: LD_ADDR_VAR 0 1
5045: PUSH
5046: LD_INT 0
5048: ST_TO_ADDR
// m2 := false ;
5049: LD_ADDR_VAR 0 2
5053: PUSH
5054: LD_INT 0
5056: ST_TO_ADDR
// AddMedal ( Explosion , 1 ) ;
5057: LD_STRING Explosion
5059: PPUSH
5060: LD_INT 1
5062: PPUSH
5063: CALL_OW 101
// if enteredContaminatedArea then
5067: LD_EXP 5
5071: IFFALSE 5093
// begin m1 := true ;
5073: LD_ADDR_VAR 0 1
5077: PUSH
5078: LD_INT 1
5080: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5081: LD_STRING BioHazard
5083: PPUSH
5084: LD_INT 1
5086: PPUSH
5087: CALL_OW 101
// end else
5091: GO 5104
// AddMedal ( BioHazard , - 1 ) ;
5093: LD_STRING BioHazard
5095: PPUSH
5096: LD_INT 1
5098: NEG
5099: PPUSH
5100: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5104: LD_EXP 11
5108: PUSH
5109: LD_INT 42000
5111: PUSH
5112: LD_INT 31500
5114: PUSH
5115: LD_INT 25200
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: LIST
5122: PUSH
5123: LD_OWVAR 67
5127: ARRAY
5128: LESSEQUAL
5129: IFFALSE 5151
// begin m2 := true ;
5131: LD_ADDR_VAR 0 2
5135: PUSH
5136: LD_INT 1
5138: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5139: LD_STRING Speed
5141: PPUSH
5142: LD_INT 1
5144: PPUSH
5145: CALL_OW 101
// end else
5149: GO 5162
// AddMedal ( Speed , - 1 ) ;
5151: LD_STRING Speed
5153: PPUSH
5154: LD_INT 1
5156: NEG
5157: PPUSH
5158: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5162: LD_OWVAR 67
5166: PUSH
5167: LD_INT 3
5169: EQUAL
5170: PUSH
5171: LD_VAR 0 1
5175: AND
5176: PUSH
5177: LD_VAR 0 2
5181: AND
5182: IFFALSE 5194
// SetAchievementEX ( ACH_AMER , 18 ) ;
5184: LD_STRING ACH_AMER
5186: PPUSH
5187: LD_INT 18
5189: PPUSH
5190: CALL_OW 564
// GiveMedals ( Main ) ;
5194: LD_STRING Main
5196: PPUSH
5197: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5201: LD_EXP 12
5205: PUSH
5206: LD_EXP 13
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PPUSH
5215: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5219: LD_EXP 12
5223: PPUSH
5224: LD_STRING 14a_JMM
5226: PPUSH
5227: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5231: LD_EXP 13
5235: PPUSH
5236: LD_STRING 14a_Burlak
5238: PPUSH
5239: CALL_OW 38
// YouWin ;
5243: CALL_OW 103
// end ; end_of_file
5247: PPOPN 2
5249: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5250: LD_INT 0
5252: PPUSH
5253: PPUSH
5254: PPUSH
5255: PPUSH
// uc_side := 1 ;
5256: LD_ADDR_OWVAR 20
5260: PUSH
5261: LD_INT 1
5263: ST_TO_ADDR
// uc_nation := 1 ;
5264: LD_ADDR_OWVAR 21
5268: PUSH
5269: LD_INT 1
5271: ST_TO_ADDR
// InitHc ;
5272: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5276: LD_INT 34
5278: PPUSH
5279: CALL_OW 274
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_INT 500
5289: PPUSH
5290: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5294: LD_INT 34
5296: PPUSH
5297: CALL_OW 274
5301: PPUSH
5302: LD_INT 3
5304: PPUSH
5305: LD_INT 20
5307: PPUSH
5308: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5312: LD_ADDR_EXP 16
5316: PUSH
5317: LD_STRING Stevens
5319: PPUSH
5320: CALL_OW 25
5324: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5325: LD_ADDR_EXP 17
5329: PUSH
5330: LD_STRING Powell
5332: PPUSH
5333: CALL_OW 25
5337: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5338: LD_EXP 16
5342: PPUSH
5343: LD_INT 1
5345: PPUSH
5346: CALL_OW 52
// vehGuard := [ ] ;
5350: LD_ADDR_EXP 21
5354: PUSH
5355: EMPTY
5356: ST_TO_ADDR
// hc_importance := 0 ;
5357: LD_ADDR_OWVAR 32
5361: PUSH
5362: LD_INT 0
5364: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5365: LD_INT 4
5367: PPUSH
5368: LD_INT 3
5370: PPUSH
5371: LD_INT 3
5373: PPUSH
5374: LD_INT 8
5376: PPUSH
5377: LD_INT 100
5379: PPUSH
5380: CALL 934 0 5
// sibBomb := CreateVehicle ;
5384: LD_ADDR_EXP 19
5388: PUSH
5389: CALL_OW 45
5393: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5394: LD_EXP 19
5398: PPUSH
5399: LD_INT 1
5401: PPUSH
5402: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5406: LD_EXP 19
5410: PPUSH
5411: LD_INT 93
5413: PPUSH
5414: LD_INT 74
5416: PPUSH
5417: LD_INT 0
5419: PPUSH
5420: CALL_OW 48
// guards := [ ] ;
5424: LD_ADDR_EXP 20
5428: PUSH
5429: EMPTY
5430: ST_TO_ADDR
// for i = 1 to 3 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 3
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5537
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5447: LD_INT 0
5449: PPUSH
5450: LD_INT 1
5452: PPUSH
5453: LD_INT 8
5455: PUSH
5456: LD_INT 9
5458: PUSH
5459: LD_INT 10
5461: PUSH
5462: EMPTY
5463: LIST
5464: LIST
5465: LIST
5466: PUSH
5467: LD_OWVAR 67
5471: ARRAY
5472: PPUSH
5473: CALL_OW 380
// un := CreateHuman ;
5477: LD_ADDR_VAR 0 3
5481: PUSH
5482: CALL_OW 44
5486: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5487: LD_VAR 0 3
5491: PPUSH
5492: LD_INT 2
5494: PUSH
5495: LD_INT 3
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_VAR 0 2
5510: ARRAY
5511: PPUSH
5512: LD_INT 0
5514: PPUSH
5515: CALL_OW 49
// guards := guards ^ un ;
5519: LD_ADDR_EXP 20
5523: PUSH
5524: LD_EXP 20
5528: PUSH
5529: LD_VAR 0 3
5533: ADD
5534: ST_TO_ADDR
// end ;
5535: GO 5444
5537: POP
5538: POP
// baseGuards := [ ] ;
5539: LD_ADDR_EXP 18
5543: PUSH
5544: EMPTY
5545: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5546: LD_ADDR_VAR 0 2
5550: PUSH
5551: DOUBLE
5552: LD_INT 1
5554: DEC
5555: ST_TO_ADDR
5556: LD_INT 5
5558: PUSH
5559: LD_INT 6
5561: PUSH
5562: LD_INT 7
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: PUSH
5570: LD_OWVAR 67
5574: ARRAY
5575: PUSH
5576: FOR_TO
5577: IFFALSE 5723
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5579: LD_INT 0
5581: PPUSH
5582: LD_INT 8
5584: PUSH
5585: LD_INT 9
5587: PUSH
5588: LD_INT 10
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL_OW 381
// un := CreateHuman ;
5606: LD_ADDR_VAR 0 3
5610: PUSH
5611: CALL_OW 44
5615: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5616: LD_ADDR_EXP 18
5620: PUSH
5621: LD_EXP 18
5625: PUSH
5626: LD_VAR 0 3
5630: ADD
5631: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5632: LD_ADDR_VAR 0 4
5636: PUSH
5637: LD_INT 22
5639: PUSH
5640: LD_INT 1
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: LD_INT 58
5649: PUSH
5650: EMPTY
5651: LIST
5652: PUSH
5653: LD_INT 30
5655: PUSH
5656: LD_INT 32
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: PPUSH
5668: CALL_OW 69
5672: ST_TO_ADDR
// if tmp then
5673: LD_VAR 0 4
5677: IFFALSE 5709
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5679: LD_VAR 0 3
5683: PPUSH
5684: LD_VAR 0 4
5688: PUSH
5689: LD_INT 1
5691: PPUSH
5692: LD_VAR 0 4
5696: PPUSH
5697: CALL_OW 12
5701: ARRAY
5702: PPUSH
5703: CALL_OW 52
5707: GO 5721
// PlaceHumanInUnit ( un , us_bar ) ;
5709: LD_VAR 0 3
5713: PPUSH
5714: LD_INT 51
5716: PPUSH
5717: CALL_OW 52
// end ;
5721: GO 5576
5723: POP
5724: POP
// if Difficulty > 1 then
5725: LD_OWVAR 67
5729: PUSH
5730: LD_INT 1
5732: GREATER
5733: IFFALSE 5777
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5735: LD_INT 0
5737: PPUSH
5738: LD_INT 5
5740: PPUSH
5741: LD_INT 9
5743: PUSH
5744: LD_INT 10
5746: PUSH
5747: EMPTY
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: PUSH
5756: LD_INT 1
5758: MINUS
5759: ARRAY
5760: PPUSH
5761: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5765: CALL_OW 44
5769: PPUSH
5770: LD_INT 80
5772: PPUSH
5773: CALL_OW 52
// end ; for i = 1 to 3 do
5777: LD_ADDR_VAR 0 2
5781: PUSH
5782: DOUBLE
5783: LD_INT 1
5785: DEC
5786: ST_TO_ADDR
5787: LD_INT 3
5789: PUSH
5790: FOR_TO
5791: IFFALSE 5817
// begin PrepareMechanic ( false , 9 ) ;
5793: LD_INT 0
5795: PPUSH
5796: LD_INT 9
5798: PPUSH
5799: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5803: CALL_OW 44
5807: PPUSH
5808: LD_INT 43
5810: PPUSH
5811: CALL_OW 52
// end ;
5815: GO 5790
5817: POP
5818: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5819: CALL_OW 44
5823: PPUSH
5824: LD_INT 49
5826: PPUSH
5827: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5831: LD_ADDR_VAR 0 2
5835: PUSH
5836: DOUBLE
5837: LD_INT 1
5839: DEC
5840: ST_TO_ADDR
5841: LD_INT 1
5843: PUSH
5844: LD_OWVAR 67
5848: PLUS
5849: PUSH
5850: FOR_TO
5851: IFFALSE 5894
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5853: LD_INT 0
5855: PPUSH
5856: LD_INT 8
5858: PUSH
5859: LD_INT 9
5861: PUSH
5862: LD_INT 10
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: LIST
5869: PUSH
5870: LD_OWVAR 67
5874: ARRAY
5875: PPUSH
5876: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5880: CALL_OW 44
5884: PPUSH
5885: LD_INT 5
5887: PPUSH
5888: CALL_OW 52
// end ;
5892: GO 5850
5894: POP
5895: POP
// for i = 1 to 3 do
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: DOUBLE
5902: LD_INT 1
5904: DEC
5905: ST_TO_ADDR
5906: LD_INT 3
5908: PUSH
5909: FOR_TO
5910: IFFALSE 5936
// begin PrepareScientist ( false , 10 ) ;
5912: LD_INT 0
5914: PPUSH
5915: LD_INT 10
5917: PPUSH
5918: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
5922: CALL_OW 44
5926: PPUSH
5927: LD_INT 1
5929: PPUSH
5930: CALL_OW 52
// end ;
5934: GO 5909
5936: POP
5937: POP
// end ;
5938: LD_VAR 0 1
5942: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
5943: LD_EXP 20
5947: PUSH
5948: LD_EXP 2
5952: NOT
5953: AND
5954: IFFALSE 6140
5956: GO 5958
5958: DISABLE
5959: LD_INT 0
5961: PPUSH
5962: PPUSH
5963: PPUSH
// begin enable ;
5964: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
5965: LD_ADDR_VAR 0 3
5969: PUSH
5970: LD_INT 204
5972: PUSH
5973: LD_INT 30
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 165
5982: PUSH
5983: LD_INT 24
5985: PUSH
5986: EMPTY
5987: LIST
5988: LIST
5989: PUSH
5990: LD_INT 195
5992: PUSH
5993: LD_INT 6
5995: PUSH
5996: EMPTY
5997: LIST
5998: LIST
5999: PUSH
6000: LD_INT 223
6002: PUSH
6003: LD_INT 54
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 214
6012: PUSH
6013: LD_INT 84
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 206
6022: PUSH
6023: LD_INT 71
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: ST_TO_ADDR
// for i in guards do
6038: LD_ADDR_VAR 0 1
6042: PUSH
6043: LD_EXP 20
6047: PUSH
6048: FOR_IN
6049: IFFALSE 6138
// begin if HasTask ( i ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 314
6060: IFFALSE 6066
// continue else
6062: GO 6048
6064: GO 6136
// begin j := rand ( 1 , 6 ) ;
6066: LD_ADDR_VAR 0 2
6070: PUSH
6071: LD_INT 1
6073: PPUSH
6074: LD_INT 6
6076: PPUSH
6077: CALL_OW 12
6081: ST_TO_ADDR
// if not See ( 7 , i ) then
6082: LD_INT 7
6084: PPUSH
6085: LD_VAR 0 1
6089: PPUSH
6090: CALL_OW 292
6094: NOT
6095: IFFALSE 6136
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6097: LD_VAR 0 1
6101: PPUSH
6102: LD_VAR 0 3
6106: PUSH
6107: LD_VAR 0 2
6111: ARRAY
6112: PUSH
6113: LD_INT 1
6115: ARRAY
6116: PPUSH
6117: LD_VAR 0 3
6121: PUSH
6122: LD_VAR 0 2
6126: ARRAY
6127: PUSH
6128: LD_INT 2
6130: ARRAY
6131: PPUSH
6132: CALL_OW 114
// end ; end ;
6136: GO 6048
6138: POP
6139: POP
// end ;
6140: PPOPN 3
6142: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6143: LD_EXP 21
6147: PUSH
6148: LD_EXP 7
6152: NOT
6153: AND
6154: IFFALSE 6225
6156: GO 6158
6158: DISABLE
6159: LD_INT 0
6161: PPUSH
// begin enable ;
6162: ENABLE
// for i in vehGuard do
6163: LD_ADDR_VAR 0 1
6167: PUSH
6168: LD_EXP 21
6172: PUSH
6173: FOR_IN
6174: IFFALSE 6223
// if IsOk ( vehGuard ) then
6176: LD_EXP 21
6180: PPUSH
6181: CALL_OW 302
6185: IFFALSE 6221
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6187: LD_VAR 0 1
6191: PPUSH
6192: LD_INT 22
6194: PUSH
6195: LD_INT 7
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PPUSH
6202: CALL_OW 69
6206: PPUSH
6207: LD_VAR 0 1
6211: PPUSH
6212: CALL_OW 74
6216: PPUSH
6217: CALL_OW 115
6221: GO 6173
6223: POP
6224: POP
// end ;
6225: PPOPN 1
6227: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6228: LD_EXP 4
6232: PUSH
6233: LD_INT 43
6235: PPUSH
6236: CALL_OW 302
6240: AND
6241: PUSH
6242: LD_EXP 7
6246: NOT
6247: AND
6248: IFFALSE 6296
6250: GO 6252
6252: DISABLE
// begin enable ;
6253: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6254: LD_INT 43
6256: PPUSH
6257: LD_INT 5
6259: PPUSH
6260: LD_INT 3
6262: PPUSH
6263: LD_INT 2
6265: PPUSH
6266: LD_INT 7
6268: PUSH
6269: LD_INT 7
6271: PUSH
6272: LD_INT 9
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 1
6282: PPUSH
6283: LD_INT 3
6285: PPUSH
6286: CALL_OW 12
6290: ARRAY
6291: PPUSH
6292: CALL_OW 125
// end ;
6296: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6297: LD_INT 22
6299: PUSH
6300: LD_INT 1
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PUSH
6307: LD_INT 25
6309: PUSH
6310: LD_INT 5
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PUSH
6317: LD_INT 50
6319: PUSH
6320: EMPTY
6321: LIST
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: PPUSH
6328: CALL_OW 69
6332: PUSH
6333: LD_EXP 7
6337: NOT
6338: AND
6339: IFFALSE 6568
6341: GO 6343
6343: DISABLE
6344: LD_INT 0
6346: PPUSH
6347: PPUSH
// begin enable ;
6348: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6349: LD_ADDR_VAR 0 1
6353: PUSH
6354: LD_INT 22
6356: PUSH
6357: LD_INT 1
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 25
6366: PUSH
6367: LD_INT 5
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 50
6376: PUSH
6377: EMPTY
6378: LIST
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PPUSH
6385: CALL_OW 69
6389: ST_TO_ADDR
// if not tmp then
6390: LD_VAR 0 1
6394: NOT
6395: IFFALSE 6399
// exit ;
6397: GO 6568
// b := IsInUnit ( tmp [ 1 ] ) ;
6399: LD_ADDR_VAR 0 2
6403: PUSH
6404: LD_VAR 0 1
6408: PUSH
6409: LD_INT 1
6411: ARRAY
6412: PPUSH
6413: CALL_OW 310
6417: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6418: LD_VAR 0 2
6422: NOT
6423: PUSH
6424: LD_VAR 0 1
6428: PUSH
6429: LD_INT 1
6431: ARRAY
6432: PPUSH
6433: CALL_OW 314
6437: OR
6438: IFFALSE 6442
// exit ;
6440: GO 6568
// if b = us_bun1 then
6442: LD_VAR 0 2
6446: PUSH
6447: LD_INT 80
6449: EQUAL
6450: IFFALSE 6511
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6452: LD_VAR 0 1
6456: PUSH
6457: LD_INT 1
6459: ARRAY
6460: PPUSH
6461: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6465: LD_VAR 0 1
6469: PUSH
6470: LD_INT 1
6472: ARRAY
6473: PPUSH
6474: LD_INT 27
6476: PPUSH
6477: LD_INT 44
6479: PPUSH
6480: CALL_OW 174
// if IsOk ( us_bun2 ) then
6484: LD_INT 55
6486: PPUSH
6487: CALL_OW 302
6491: IFFALSE 6509
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6493: LD_VAR 0 1
6497: PUSH
6498: LD_INT 1
6500: ARRAY
6501: PPUSH
6502: LD_INT 55
6504: PPUSH
6505: CALL_OW 180
// end else
6509: GO 6568
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6511: LD_VAR 0 1
6515: PUSH
6516: LD_INT 1
6518: ARRAY
6519: PPUSH
6520: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6524: LD_VAR 0 1
6528: PUSH
6529: LD_INT 1
6531: ARRAY
6532: PPUSH
6533: LD_INT 92
6535: PPUSH
6536: LD_INT 51
6538: PPUSH
6539: CALL_OW 174
// if IsOk ( us_bun1 ) then
6543: LD_INT 80
6545: PPUSH
6546: CALL_OW 302
6550: IFFALSE 6568
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6552: LD_VAR 0 1
6556: PUSH
6557: LD_INT 1
6559: ARRAY
6560: PPUSH
6561: LD_INT 80
6563: PPUSH
6564: CALL_OW 180
// end ; end ;
6568: PPOPN 2
6570: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6571: LD_EXP 7
6575: NOT
6576: PUSH
6577: LD_INT 9
6579: PPUSH
6580: LD_INT 22
6582: PUSH
6583: LD_INT 1
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: PUSH
6590: LD_INT 21
6592: PUSH
6593: LD_INT 3
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 3
6602: PUSH
6603: LD_INT 24
6605: PUSH
6606: LD_INT 1000
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: LIST
6621: PPUSH
6622: CALL_OW 70
6626: AND
6627: IFFALSE 7038
6629: GO 6631
6631: DISABLE
6632: LD_INT 0
6634: PPUSH
6635: PPUSH
6636: PPUSH
6637: PPUSH
// begin enable ;
6638: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6639: LD_ADDR_VAR 0 2
6643: PUSH
6644: LD_INT 22
6646: PUSH
6647: LD_INT 1
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 25
6656: PUSH
6657: LD_INT 2
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 24
6666: PUSH
6667: LD_INT 1000
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: PPUSH
6679: CALL_OW 69
6683: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6684: LD_ADDR_VAR 0 3
6688: PUSH
6689: LD_INT 22
6691: PUSH
6692: LD_INT 1
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: LD_INT 25
6701: PUSH
6702: LD_INT 2
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: PUSH
6709: LD_INT 3
6711: PUSH
6712: LD_INT 24
6714: PUSH
6715: LD_INT 750
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: PUSH
6726: EMPTY
6727: LIST
6728: LIST
6729: LIST
6730: PPUSH
6731: CALL_OW 69
6735: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6736: LD_ADDR_VAR 0 4
6740: PUSH
6741: LD_INT 9
6743: PPUSH
6744: LD_INT 22
6746: PUSH
6747: LD_INT 1
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 21
6756: PUSH
6757: LD_INT 3
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 3
6766: PUSH
6767: LD_INT 24
6769: PUSH
6770: LD_INT 1000
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: LIST
6785: PPUSH
6786: CALL_OW 70
6790: PUSH
6791: LD_INT 1
6793: DIFF
6794: ST_TO_ADDR
// if not tmp and not tmp2 then
6795: LD_VAR 0 2
6799: NOT
6800: PUSH
6801: LD_VAR 0 3
6805: NOT
6806: AND
6807: IFFALSE 6811
// exit ;
6809: GO 7038
// if tmp and b then
6811: LD_VAR 0 2
6815: PUSH
6816: LD_VAR 0 4
6820: AND
6821: IFFALSE 6951
// for i in tmp do
6823: LD_ADDR_VAR 0 1
6827: PUSH
6828: LD_VAR 0 2
6832: PUSH
6833: FOR_IN
6834: IFFALSE 6949
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6836: LD_VAR 0 1
6840: PPUSH
6841: CALL_OW 110
6845: PUSH
6846: LD_INT 1
6848: EQUAL
6849: PUSH
6850: LD_VAR 0 1
6854: PPUSH
6855: CALL_OW 256
6859: PUSH
6860: LD_INT 1000
6862: LESS
6863: AND
6864: IFFALSE 6870
// continue else
6866: GO 6833
6868: GO 6897
// if GetTag ( i ) = 1 then
6870: LD_VAR 0 1
6874: PPUSH
6875: CALL_OW 110
6879: PUSH
6880: LD_INT 1
6882: EQUAL
6883: IFFALSE 6897
// SetTag ( i , 0 ) ;
6885: LD_VAR 0 1
6889: PPUSH
6890: LD_INT 0
6892: PPUSH
6893: CALL_OW 109
// if IsInUnit ( i ) then
6897: LD_VAR 0 1
6901: PPUSH
6902: CALL_OW 310
6906: IFFALSE 6917
// ComExitBuilding ( i ) ;
6908: LD_VAR 0 1
6912: PPUSH
6913: CALL_OW 122
// if not HasTask ( i ) then
6917: LD_VAR 0 1
6921: PPUSH
6922: CALL_OW 314
6926: NOT
6927: IFFALSE 6947
// AddComRepairBuilding ( i , b [ 1 ] ) ;
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_VAR 0 4
6938: PUSH
6939: LD_INT 1
6941: ARRAY
6942: PPUSH
6943: CALL_OW 190
// end ;
6947: GO 6833
6949: POP
6950: POP
// if tmp2 then
6951: LD_VAR 0 3
6955: IFFALSE 7038
// for i in tmp2 do
6957: LD_ADDR_VAR 0 1
6961: PUSH
6962: LD_VAR 0 3
6966: PUSH
6967: FOR_IN
6968: IFFALSE 7036
// begin if not GetTag ( i ) = 1 then
6970: LD_VAR 0 1
6974: PPUSH
6975: CALL_OW 110
6979: PUSH
6980: LD_INT 1
6982: EQUAL
6983: NOT
6984: IFFALSE 6998
// SetTag ( i , 1 ) ;
6986: LD_VAR 0 1
6990: PPUSH
6991: LD_INT 1
6993: PPUSH
6994: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
6998: LD_VAR 0 1
7002: PPUSH
7003: LD_INT 88
7005: PPUSH
7006: LD_INT 75
7008: PPUSH
7009: CALL_OW 297
7013: PUSH
7014: LD_INT 6
7016: GREATER
7017: IFFALSE 7034
// ComMoveXY ( i , 88 , 75 ) ;
7019: LD_VAR 0 1
7023: PPUSH
7024: LD_INT 88
7026: PPUSH
7027: LD_INT 75
7029: PPUSH
7030: CALL_OW 111
// end ;
7034: GO 6967
7036: POP
7037: POP
// end ;
7038: PPOPN 4
7040: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7041: LD_EXP 7
7045: NOT
7046: PUSH
7047: LD_EXP 9
7051: AND
7052: PUSH
7053: LD_INT 9
7055: PPUSH
7056: LD_INT 22
7058: PUSH
7059: LD_INT 1
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: LD_INT 21
7068: PUSH
7069: LD_INT 1
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 3
7078: PUSH
7079: LD_INT 24
7081: PUSH
7082: LD_INT 1000
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: LIST
7097: PPUSH
7098: CALL_OW 70
7102: AND
7103: IFFALSE 7276
7105: GO 7107
7107: DISABLE
7108: LD_INT 0
7110: PPUSH
7111: PPUSH
7112: PPUSH
// begin enable ;
7113: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7114: LD_ADDR_VAR 0 2
7118: PUSH
7119: LD_INT 22
7121: PUSH
7122: LD_INT 1
7124: PUSH
7125: EMPTY
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 25
7131: PUSH
7132: LD_INT 4
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: PPUSH
7143: CALL_OW 69
7147: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7148: LD_ADDR_VAR 0 3
7152: PUSH
7153: LD_INT 9
7155: PPUSH
7156: LD_INT 22
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: LD_INT 21
7168: PUSH
7169: LD_INT 1
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 3
7178: PUSH
7179: LD_INT 24
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 70
7202: ST_TO_ADDR
// if not sci or not tmp then
7203: LD_VAR 0 2
7207: NOT
7208: PUSH
7209: LD_VAR 0 3
7213: NOT
7214: OR
7215: IFFALSE 7219
// exit ;
7217: GO 7276
// for i in sci do
7219: LD_ADDR_VAR 0 1
7223: PUSH
7224: LD_VAR 0 2
7228: PUSH
7229: FOR_IN
7230: IFFALSE 7274
// if IsInUnit ( i ) then
7232: LD_VAR 0 1
7236: PPUSH
7237: CALL_OW 310
7241: IFFALSE 7254
// ComExitBuilding ( i ) else
7243: LD_VAR 0 1
7247: PPUSH
7248: CALL_OW 122
7252: GO 7272
// ComHeal ( i , tmp [ 1 ] ) ;
7254: LD_VAR 0 1
7258: PPUSH
7259: LD_VAR 0 3
7263: PUSH
7264: LD_INT 1
7266: ARRAY
7267: PPUSH
7268: CALL_OW 128
7272: GO 7229
7274: POP
7275: POP
// end ;
7276: PPOPN 3
7278: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7279: LD_EXP 7
7283: NOT
7284: PUSH
7285: LD_EXP 9
7289: AND
7290: PUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 302
7298: AND
7299: PUSH
7300: LD_INT 9
7302: PPUSH
7303: LD_INT 22
7305: PUSH
7306: LD_INT 1
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: PUSH
7313: LD_INT 21
7315: PUSH
7316: LD_INT 1
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 3
7325: PUSH
7326: LD_INT 24
7328: PUSH
7329: LD_INT 1000
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 70
7349: NOT
7350: AND
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: PUSH
7362: LD_INT 25
7364: PUSH
7365: LD_INT 4
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: LD_INT 56
7374: PUSH
7375: EMPTY
7376: LIST
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: LIST
7382: PPUSH
7383: CALL_OW 69
7387: AND
7388: IFFALSE 7481
7390: GO 7392
7392: DISABLE
7393: LD_INT 0
7395: PPUSH
// begin enable ;
7396: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7397: LD_ADDR_VAR 0 1
7401: PUSH
7402: LD_INT 22
7404: PUSH
7405: LD_INT 1
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PUSH
7412: LD_INT 25
7414: PUSH
7415: LD_INT 4
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: LD_INT 56
7424: PUSH
7425: EMPTY
7426: LIST
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 69
7437: PUSH
7438: FOR_IN
7439: IFFALSE 7479
// if not GetTag ( i ) and not HasTask ( i ) then
7441: LD_VAR 0 1
7445: PPUSH
7446: CALL_OW 110
7450: NOT
7451: PUSH
7452: LD_VAR 0 1
7456: PPUSH
7457: CALL_OW 314
7461: NOT
7462: AND
7463: IFFALSE 7477
// ComEnterUnit ( i , us_lab ) ;
7465: LD_VAR 0 1
7469: PPUSH
7470: LD_INT 1
7472: PPUSH
7473: CALL_OW 120
7477: GO 7438
7479: POP
7480: POP
// end ;
7481: PPOPN 1
7483: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7484: LD_EXP 7
7488: NOT
7489: PUSH
7490: LD_INT 9
7492: PPUSH
7493: LD_INT 22
7495: PUSH
7496: LD_INT 1
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: LD_INT 21
7505: PUSH
7506: LD_INT 3
7508: PUSH
7509: EMPTY
7510: LIST
7511: LIST
7512: PUSH
7513: LD_INT 3
7515: PUSH
7516: LD_INT 24
7518: PUSH
7519: LD_INT 1000
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: LIST
7534: PPUSH
7535: CALL_OW 70
7539: NOT
7540: AND
7541: PUSH
7542: LD_INT 22
7544: PUSH
7545: LD_INT 1
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: LD_INT 25
7554: PUSH
7555: LD_INT 2
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: LD_INT 56
7564: PUSH
7565: EMPTY
7566: LIST
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: LIST
7572: PPUSH
7573: CALL_OW 69
7577: AND
7578: IFFALSE 7671
7580: GO 7582
7582: DISABLE
7583: LD_INT 0
7585: PPUSH
// begin enable ;
7586: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7587: LD_ADDR_VAR 0 1
7591: PUSH
7592: LD_INT 22
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 25
7604: PUSH
7605: LD_INT 2
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 56
7614: PUSH
7615: EMPTY
7616: LIST
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: LIST
7622: PPUSH
7623: CALL_OW 69
7627: PUSH
7628: FOR_IN
7629: IFFALSE 7669
// if not HasTask ( i ) and not GetTag ( i ) then
7631: LD_VAR 0 1
7635: PPUSH
7636: CALL_OW 314
7640: NOT
7641: PUSH
7642: LD_VAR 0 1
7646: PPUSH
7647: CALL_OW 110
7651: NOT
7652: AND
7653: IFFALSE 7667
// ComEnterUnit ( i , us_depot ) ;
7655: LD_VAR 0 1
7659: PPUSH
7660: LD_INT 5
7662: PPUSH
7663: CALL_OW 120
7667: GO 7628
7669: POP
7670: POP
// end ;
7671: PPOPN 1
7673: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7674: LD_EXP 9
7678: PUSH
7679: LD_INT 0
7681: LESSEQUAL
7682: PUSH
7683: LD_EXP 16
7687: PPUSH
7688: CALL_OW 301
7692: OR
7693: PUSH
7694: LD_INT 22
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 25
7706: PUSH
7707: LD_INT 2
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: AND
7723: IFFALSE 7764
7725: GO 7727
7727: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7728: LD_INT 22
7730: PUSH
7731: LD_INT 1
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PUSH
7738: LD_INT 25
7740: PUSH
7741: LD_INT 2
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: PPUSH
7752: CALL_OW 69
7756: PPUSH
7757: LD_INT 1
7759: PPUSH
7760: CALL_OW 167
7764: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7765: LD_EXP 7
7769: NOT
7770: PUSH
7771: LD_INT 7
7773: PPUSH
7774: LD_INT 22
7776: PUSH
7777: LD_INT 7
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PPUSH
7784: CALL_OW 70
7788: AND
7789: IFFALSE 7880
7791: GO 7793
7793: DISABLE
7794: LD_INT 0
7796: PPUSH
// begin wait ( 0 0$2 ) ;
7797: LD_INT 70
7799: PPUSH
7800: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7804: LD_ADDR_VAR 0 1
7808: PUSH
7809: LD_INT 22
7811: PUSH
7812: LD_INT 1
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: LD_INT 25
7821: PUSH
7822: LD_INT 1
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 69
7837: PUSH
7838: FOR_IN
7839: IFFALSE 7878
// begin if IsInUnit ( i ) then
7841: LD_VAR 0 1
7845: PPUSH
7846: CALL_OW 310
7850: IFFALSE 7861
// ComExitBuilding ( i ) ;
7852: LD_VAR 0 1
7856: PPUSH
7857: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7861: LD_VAR 0 1
7865: PPUSH
7866: LD_INT 92
7868: PPUSH
7869: LD_INT 78
7871: PPUSH
7872: CALL_OW 174
// end ;
7876: GO 7838
7878: POP
7879: POP
// end ; end_of_file
7880: PPOPN 1
7882: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7883: LD_VAR 0 1
7887: PPUSH
7888: LD_VAR 0 2
7892: PPUSH
7893: LD_VAR 0 3
7897: PPUSH
7898: CALL 2786 0 3
7902: PPOPN 3
7904: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7905: LD_EXP 12
7909: PPUSH
7910: CALL_OW 257
7914: PUSH
7915: LD_INT 4
7917: EQUAL
7918: PUSH
7919: LD_EXP 13
7923: PPUSH
7924: CALL_OW 257
7928: PUSH
7929: LD_INT 4
7931: EQUAL
7932: OR
7933: IFFALSE 7937
// exit ;
7935: GO 7975
// if un = JMM then
7937: LD_VAR 0 1
7941: PUSH
7942: LD_EXP 12
7946: EQUAL
7947: IFFALSE 7956
// YouLost ( JMM ) ;
7949: LD_STRING JMM
7951: PPUSH
7952: CALL_OW 104
// if un = Burlak then
7956: LD_VAR 0 1
7960: PUSH
7961: LD_EXP 13
7965: EQUAL
7966: IFFALSE 7975
// YouLost ( Burlak ) ;
7968: LD_STRING Burlak
7970: PPUSH
7971: CALL_OW 104
// end ;
7975: PPOPN 1
7977: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7978: LD_VAR 0 1
7982: PUSH
7983: LD_EXP 12
7987: EQUAL
7988: IFFALSE 7997
// YouLost ( JMM ) ;
7990: LD_STRING JMM
7992: PPUSH
7993: CALL_OW 104
// if un = Burlak then
7997: LD_VAR 0 1
8001: PUSH
8002: LD_EXP 13
8006: EQUAL
8007: IFFALSE 8016
// YouLost ( Burlak ) ;
8009: LD_STRING Burlak
8011: PPUSH
8012: CALL_OW 104
// end ;
8016: PPOPN 1
8018: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8019: LD_VAR 0 1
8023: PPUSH
8024: CALL_OW 255
8028: PUSH
8029: LD_INT 7
8031: EQUAL
8032: IFFALSE 8042
// artifactPickedUp := true ;
8034: LD_ADDR_EXP 6
8038: PUSH
8039: LD_INT 1
8041: ST_TO_ADDR
// end ;
8042: PPOPN 2
8044: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8045: LD_ADDR_EXP 6
8049: PUSH
8050: LD_INT 0
8052: ST_TO_ADDR
8053: PPOPN 2
8055: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8056: LD_VAR 0 1
8060: PPUSH
8061: CALL_OW 255
8065: PUSH
8066: LD_INT 1
8068: NONEQUAL
8069: IFFALSE 8073
// exit ;
8071: GO 8120
// wait ( 0 0$5 ) ;
8073: LD_INT 175
8075: PPUSH
8076: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8080: LD_VAR 0 1
8084: PPUSH
8085: CALL_OW 263
8089: PUSH
8090: LD_INT 2
8092: EQUAL
8093: IFFALSE 8104
// Connect ( vehicle ) ;
8095: LD_VAR 0 1
8099: PPUSH
8100: CALL 1787 0 1
// vehGuard := vehGuard ^ vehicle ;
8104: LD_ADDR_EXP 21
8108: PUSH
8109: LD_EXP 21
8113: PUSH
8114: LD_VAR 0 1
8118: ADD
8119: ST_TO_ADDR
// end ;
8120: PPOPN 2
8122: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8123: LD_VAR 0 1
8127: PUSH
8128: LD_INT 1
8130: EQUAL
8131: PUSH
8132: LD_EXP 7
8136: NOT
8137: AND
8138: IFFALSE 8173
// begin planCaptured := true ;
8140: LD_ADDR_EXP 7
8144: PUSH
8145: LD_INT 1
8147: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8148: LD_STRING MEnd
8150: PPUSH
8151: CALL_OW 337
// canEnd := true ;
8155: LD_ADDR_EXP 10
8159: PUSH
8160: LD_INT 1
8162: ST_TO_ADDR
// missionTime := tick ;
8163: LD_ADDR_EXP 11
8167: PUSH
8168: LD_OWVAR 1
8172: ST_TO_ADDR
// end ; end ;
8173: PPOPN 3
8175: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8176: LD_VAR 0 1
8180: PPUSH
8181: CALL 8330 0 1
// end ; end_of_file
8185: PPOPN 1
8187: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8188: GO 8190
8190: DISABLE
// begin ru_radar := 98 ;
8191: LD_ADDR_EXP 22
8195: PUSH
8196: LD_INT 98
8198: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8199: LD_ADDR_EXP 23
8203: PUSH
8204: LD_INT 89
8206: ST_TO_ADDR
// us_hack := 99 ;
8207: LD_ADDR_EXP 24
8211: PUSH
8212: LD_INT 99
8214: ST_TO_ADDR
// us_artillery := 97 ;
8215: LD_ADDR_EXP 25
8219: PUSH
8220: LD_INT 97
8222: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8223: LD_ADDR_EXP 26
8227: PUSH
8228: LD_INT 91
8230: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8231: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8232: LD_INT 0
8234: PPUSH
8235: PPUSH
8236: PPUSH
8237: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8238: LD_VAR 0 1
8242: PPUSH
8243: CALL_OW 264
8247: PUSH
8248: LD_EXP 26
8252: EQUAL
8253: IFFALSE 8325
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8255: LD_INT 68
8257: PPUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 255
8267: PPUSH
8268: CALL_OW 321
8272: PUSH
8273: LD_INT 2
8275: EQUAL
8276: IFFALSE 8288
// eff := 70 else
8278: LD_ADDR_VAR 0 6
8282: PUSH
8283: LD_INT 70
8285: ST_TO_ADDR
8286: GO 8296
// eff := 30 ;
8288: LD_ADDR_VAR 0 6
8292: PUSH
8293: LD_INT 30
8295: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8296: LD_VAR 0 1
8300: PPUSH
8301: CALL_OW 250
8305: PPUSH
8306: LD_VAR 0 1
8310: PPUSH
8311: CALL_OW 251
8315: PPUSH
8316: LD_VAR 0 6
8320: PPUSH
8321: CALL_OW 495
// end ; end ;
8325: LD_VAR 0 4
8329: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8330: LD_INT 0
8332: PPUSH
8333: PPUSH
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
// if cmd = 124 then
8338: LD_VAR 0 1
8342: PUSH
8343: LD_INT 124
8345: EQUAL
8346: IFFALSE 8552
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8348: LD_ADDR_VAR 0 5
8352: PUSH
8353: LD_INT 2
8355: PUSH
8356: LD_INT 34
8358: PUSH
8359: LD_INT 53
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PUSH
8366: LD_INT 34
8368: PUSH
8369: LD_INT 14
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: LIST
8380: PPUSH
8381: CALL_OW 69
8385: ST_TO_ADDR
// if not tmp then
8386: LD_VAR 0 5
8390: NOT
8391: IFFALSE 8395
// exit ;
8393: GO 8552
// for i in tmp do
8395: LD_ADDR_VAR 0 3
8399: PUSH
8400: LD_VAR 0 5
8404: PUSH
8405: FOR_IN
8406: IFFALSE 8550
// begin taskList := GetTaskList ( i ) ;
8408: LD_ADDR_VAR 0 6
8412: PUSH
8413: LD_VAR 0 3
8417: PPUSH
8418: CALL_OW 437
8422: ST_TO_ADDR
// if not taskList then
8423: LD_VAR 0 6
8427: NOT
8428: IFFALSE 8432
// continue ;
8430: GO 8405
// for j = 1 to taskList do
8432: LD_ADDR_VAR 0 4
8436: PUSH
8437: DOUBLE
8438: LD_INT 1
8440: DEC
8441: ST_TO_ADDR
8442: LD_VAR 0 6
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8546
// if taskList [ j ] [ 1 ] = | then
8450: LD_VAR 0 6
8454: PUSH
8455: LD_VAR 0 4
8459: ARRAY
8460: PUSH
8461: LD_INT 1
8463: ARRAY
8464: PUSH
8465: LD_STRING |
8467: EQUAL
8468: IFFALSE 8544
// begin _taskList := Delete ( taskList , 1 ) ;
8470: LD_ADDR_VAR 0 7
8474: PUSH
8475: LD_VAR 0 6
8479: PPUSH
8480: LD_INT 1
8482: PPUSH
8483: CALL_OW 3
8487: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8488: LD_VAR 0 3
8492: PPUSH
8493: LD_VAR 0 7
8497: PPUSH
8498: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8502: LD_VAR 0 3
8506: PPUSH
8507: LD_VAR 0 6
8511: PUSH
8512: LD_VAR 0 4
8516: ARRAY
8517: PUSH
8518: LD_INT 2
8520: ARRAY
8521: PPUSH
8522: LD_VAR 0 6
8526: PUSH
8527: LD_VAR 0 4
8531: ARRAY
8532: PUSH
8533: LD_INT 3
8535: ARRAY
8536: PPUSH
8537: LD_INT 8
8539: PPUSH
8540: CALL 8557 0 4
// end ;
8544: GO 8447
8546: POP
8547: POP
// end ;
8548: GO 8405
8550: POP
8551: POP
// end ; end ;
8552: LD_VAR 0 2
8556: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8557: LD_INT 0
8559: PPUSH
8560: PPUSH
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8568: LD_VAR 0 1
8572: NOT
8573: PUSH
8574: LD_VAR 0 2
8578: PPUSH
8579: LD_VAR 0 3
8583: PPUSH
8584: CALL_OW 488
8588: NOT
8589: OR
8590: PUSH
8591: LD_VAR 0 4
8595: NOT
8596: OR
8597: IFFALSE 8601
// exit ;
8599: GO 8941
// list := [ ] ;
8601: LD_ADDR_VAR 0 13
8605: PUSH
8606: EMPTY
8607: ST_TO_ADDR
// if x - r < 0 then
8608: LD_VAR 0 2
8612: PUSH
8613: LD_VAR 0 4
8617: MINUS
8618: PUSH
8619: LD_INT 0
8621: LESS
8622: IFFALSE 8634
// min_x := 0 else
8624: LD_ADDR_VAR 0 7
8628: PUSH
8629: LD_INT 0
8631: ST_TO_ADDR
8632: GO 8650
// min_x := x - r ;
8634: LD_ADDR_VAR 0 7
8638: PUSH
8639: LD_VAR 0 2
8643: PUSH
8644: LD_VAR 0 4
8648: MINUS
8649: ST_TO_ADDR
// if y - r < 0 then
8650: LD_VAR 0 3
8654: PUSH
8655: LD_VAR 0 4
8659: MINUS
8660: PUSH
8661: LD_INT 0
8663: LESS
8664: IFFALSE 8676
// min_y := 0 else
8666: LD_ADDR_VAR 0 8
8670: PUSH
8671: LD_INT 0
8673: ST_TO_ADDR
8674: GO 8692
// min_y := y - r ;
8676: LD_ADDR_VAR 0 8
8680: PUSH
8681: LD_VAR 0 3
8685: PUSH
8686: LD_VAR 0 4
8690: MINUS
8691: ST_TO_ADDR
// max_x := x + r ;
8692: LD_ADDR_VAR 0 9
8696: PUSH
8697: LD_VAR 0 2
8701: PUSH
8702: LD_VAR 0 4
8706: PLUS
8707: ST_TO_ADDR
// max_y := y + r ;
8708: LD_ADDR_VAR 0 10
8712: PUSH
8713: LD_VAR 0 3
8717: PUSH
8718: LD_VAR 0 4
8722: PLUS
8723: ST_TO_ADDR
// for _x = min_x to max_x do
8724: LD_ADDR_VAR 0 11
8728: PUSH
8729: DOUBLE
8730: LD_VAR 0 7
8734: DEC
8735: ST_TO_ADDR
8736: LD_VAR 0 9
8740: PUSH
8741: FOR_TO
8742: IFFALSE 8859
// for _y = min_y to max_y do
8744: LD_ADDR_VAR 0 12
8748: PUSH
8749: DOUBLE
8750: LD_VAR 0 8
8754: DEC
8755: ST_TO_ADDR
8756: LD_VAR 0 10
8760: PUSH
8761: FOR_TO
8762: IFFALSE 8855
// begin if not ValidHex ( _x , _y ) then
8764: LD_VAR 0 11
8768: PPUSH
8769: LD_VAR 0 12
8773: PPUSH
8774: CALL_OW 488
8778: NOT
8779: IFFALSE 8783
// continue ;
8781: GO 8761
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
8783: LD_VAR 0 11
8787: PPUSH
8788: LD_VAR 0 12
8792: PPUSH
8793: CALL_OW 351
8797: PUSH
8798: LD_VAR 0 11
8802: PPUSH
8803: LD_VAR 0 12
8807: PPUSH
8808: CALL_OW 554
8812: AND
8813: IFFALSE 8853
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
8815: LD_ADDR_VAR 0 13
8819: PUSH
8820: LD_VAR 0 13
8824: PPUSH
8825: LD_VAR 0 13
8829: PUSH
8830: LD_INT 1
8832: PLUS
8833: PPUSH
8834: LD_VAR 0 11
8838: PUSH
8839: LD_VAR 0 12
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PPUSH
8848: CALL_OW 2
8852: ST_TO_ADDR
// end ;
8853: GO 8761
8855: POP
8856: POP
8857: GO 8741
8859: POP
8860: POP
// if not list then
8861: LD_VAR 0 13
8865: NOT
8866: IFFALSE 8870
// exit ;
8868: GO 8941
// for i in list do
8870: LD_ADDR_VAR 0 6
8874: PUSH
8875: LD_VAR 0 13
8879: PUSH
8880: FOR_IN
8881: IFFALSE 8939
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
8883: LD_VAR 0 1
8887: PPUSH
8888: LD_STRING M
8890: PUSH
8891: LD_VAR 0 6
8895: PUSH
8896: LD_INT 1
8898: ARRAY
8899: PUSH
8900: LD_VAR 0 6
8904: PUSH
8905: LD_INT 2
8907: ARRAY
8908: PUSH
8909: LD_INT 0
8911: PUSH
8912: LD_INT 0
8914: PUSH
8915: LD_INT 0
8917: PUSH
8918: LD_INT 0
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: PUSH
8930: EMPTY
8931: LIST
8932: PPUSH
8933: CALL_OW 447
8937: GO 8880
8939: POP
8940: POP
// end ;
8941: LD_VAR 0 5
8945: RET
