// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5335 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2178 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1633 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1633 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// if mastodonts then
1058: LD_VAR 0 6
1062: IFFALSE 1129
// for i = 1 to mastodonts do
1064: LD_ADDR_VAR 0 11
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 6
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1127
// begin vc_chassis := 31 ;
1082: LD_ADDR_OWVAR 37
1086: PUSH
1087: LD_INT 31
1089: ST_TO_ADDR
// vc_control := control_rider ;
1090: LD_ADDR_OWVAR 38
1094: PUSH
1095: LD_INT 4
1097: ST_TO_ADDR
// animal := CreateVehicle ;
1098: LD_ADDR_VAR 0 12
1102: PUSH
1103: CALL_OW 45
1107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1108: LD_VAR 0 12
1112: PPUSH
1113: LD_VAR 0 8
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL 1633 0 3
// end ;
1125: GO 1079
1127: POP
1128: POP
// if horses then
1129: LD_VAR 0 5
1133: IFFALSE 1200
// for i = 1 to horses do
1135: LD_ADDR_VAR 0 11
1139: PUSH
1140: DOUBLE
1141: LD_INT 1
1143: DEC
1144: ST_TO_ADDR
1145: LD_VAR 0 5
1149: PUSH
1150: FOR_TO
1151: IFFALSE 1198
// begin hc_class := 21 ;
1153: LD_ADDR_OWVAR 28
1157: PUSH
1158: LD_INT 21
1160: ST_TO_ADDR
// hc_gallery :=  ;
1161: LD_ADDR_OWVAR 33
1165: PUSH
1166: LD_STRING 
1168: ST_TO_ADDR
// animal := CreateHuman ;
1169: LD_ADDR_VAR 0 12
1173: PUSH
1174: CALL_OW 44
1178: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1179: LD_VAR 0 12
1183: PPUSH
1184: LD_VAR 0 8
1188: PPUSH
1189: LD_INT 0
1191: PPUSH
1192: CALL 1633 0 3
// end ;
1196: GO 1150
1198: POP
1199: POP
// if birds then
1200: LD_VAR 0 1
1204: IFFALSE 1271
// for i = 1 to birds do
1206: LD_ADDR_VAR 0 11
1210: PUSH
1211: DOUBLE
1212: LD_INT 1
1214: DEC
1215: ST_TO_ADDR
1216: LD_VAR 0 1
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1269
// begin hc_class = 18 ;
1224: LD_ADDR_OWVAR 28
1228: PUSH
1229: LD_INT 18
1231: ST_TO_ADDR
// hc_gallery =  ;
1232: LD_ADDR_OWVAR 33
1236: PUSH
1237: LD_STRING 
1239: ST_TO_ADDR
// animal := CreateHuman ;
1240: LD_ADDR_VAR 0 12
1244: PUSH
1245: CALL_OW 44
1249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1250: LD_VAR 0 12
1254: PPUSH
1255: LD_VAR 0 8
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL 1633 0 3
// end ;
1267: GO 1221
1269: POP
1270: POP
// if tigers then
1271: LD_VAR 0 2
1275: IFFALSE 1359
// for i = 1 to tigers do
1277: LD_ADDR_VAR 0 11
1281: PUSH
1282: DOUBLE
1283: LD_INT 1
1285: DEC
1286: ST_TO_ADDR
1287: LD_VAR 0 2
1291: PUSH
1292: FOR_TO
1293: IFFALSE 1357
// begin hc_class = class_tiger ;
1295: LD_ADDR_OWVAR 28
1299: PUSH
1300: LD_INT 14
1302: ST_TO_ADDR
// hc_gallery =  ;
1303: LD_ADDR_OWVAR 33
1307: PUSH
1308: LD_STRING 
1310: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1311: LD_ADDR_OWVAR 35
1315: PUSH
1316: LD_INT 7
1318: NEG
1319: PPUSH
1320: LD_INT 7
1322: PPUSH
1323: CALL_OW 12
1327: ST_TO_ADDR
// animal := CreateHuman ;
1328: LD_ADDR_VAR 0 12
1332: PUSH
1333: CALL_OW 44
1337: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1338: LD_VAR 0 12
1342: PPUSH
1343: LD_VAR 0 8
1347: PPUSH
1348: LD_INT 0
1350: PPUSH
1351: CALL 1633 0 3
// end ;
1355: GO 1292
1357: POP
1358: POP
// if apemans then
1359: LD_VAR 0 3
1363: IFFALSE 1486
// for i = 1 to apemans do
1365: LD_ADDR_VAR 0 11
1369: PUSH
1370: DOUBLE
1371: LD_INT 1
1373: DEC
1374: ST_TO_ADDR
1375: LD_VAR 0 3
1379: PUSH
1380: FOR_TO
1381: IFFALSE 1484
// begin hc_class = class_apeman ;
1383: LD_ADDR_OWVAR 28
1387: PUSH
1388: LD_INT 12
1390: ST_TO_ADDR
// hc_gallery =  ;
1391: LD_ADDR_OWVAR 33
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1399: LD_ADDR_OWVAR 35
1403: PUSH
1404: LD_INT 5
1406: NEG
1407: PPUSH
1408: LD_INT 5
1410: PPUSH
1411: CALL_OW 12
1415: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1416: LD_ADDR_OWVAR 31
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_INT 3
1426: PPUSH
1427: CALL_OW 12
1431: PUSH
1432: LD_INT 1
1434: PPUSH
1435: LD_INT 3
1437: PPUSH
1438: CALL_OW 12
1442: PUSH
1443: LD_INT 0
1445: PUSH
1446: LD_INT 0
1448: PUSH
1449: EMPTY
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: ST_TO_ADDR
// animal := CreateHuman ;
1455: LD_ADDR_VAR 0 12
1459: PUSH
1460: CALL_OW 44
1464: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1465: LD_VAR 0 12
1469: PPUSH
1470: LD_VAR 0 8
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL 1633 0 3
// end ;
1482: GO 1380
1484: POP
1485: POP
// if enchidnas then
1486: LD_VAR 0 4
1490: IFFALSE 1557
// for i = 1 to enchidnas do
1492: LD_ADDR_VAR 0 11
1496: PUSH
1497: DOUBLE
1498: LD_INT 1
1500: DEC
1501: ST_TO_ADDR
1502: LD_VAR 0 4
1506: PUSH
1507: FOR_TO
1508: IFFALSE 1555
// begin hc_class = 13 ;
1510: LD_ADDR_OWVAR 28
1514: PUSH
1515: LD_INT 13
1517: ST_TO_ADDR
// hc_gallery =  ;
1518: LD_ADDR_OWVAR 33
1522: PUSH
1523: LD_STRING 
1525: ST_TO_ADDR
// animal := CreateHuman ;
1526: LD_ADDR_VAR 0 12
1530: PUSH
1531: CALL_OW 44
1535: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1536: LD_VAR 0 12
1540: PPUSH
1541: LD_VAR 0 8
1545: PPUSH
1546: LD_INT 0
1548: PPUSH
1549: CALL 1633 0 3
// end ;
1553: GO 1507
1555: POP
1556: POP
// if fishes then
1557: LD_VAR 0 7
1561: IFFALSE 1628
// for i = 1 to fishes do
1563: LD_ADDR_VAR 0 11
1567: PUSH
1568: DOUBLE
1569: LD_INT 1
1571: DEC
1572: ST_TO_ADDR
1573: LD_VAR 0 7
1577: PUSH
1578: FOR_TO
1579: IFFALSE 1626
// begin hc_class = 20 ;
1581: LD_ADDR_OWVAR 28
1585: PUSH
1586: LD_INT 20
1588: ST_TO_ADDR
// hc_gallery =  ;
1589: LD_ADDR_OWVAR 33
1593: PUSH
1594: LD_STRING 
1596: ST_TO_ADDR
// animal := CreateHuman ;
1597: LD_ADDR_VAR 0 12
1601: PUSH
1602: CALL_OW 44
1606: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1607: LD_VAR 0 12
1611: PPUSH
1612: LD_VAR 0 9
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: CALL 1633 0 3
// end ;
1624: GO 1578
1626: POP
1627: POP
// end ;
1628: LD_VAR 0 10
1632: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1633: LD_INT 0
1635: PPUSH
1636: PPUSH
1637: PPUSH
1638: PPUSH
// if not unit or not area then
1639: LD_VAR 0 1
1643: NOT
1644: PUSH
1645: LD_VAR 0 2
1649: NOT
1650: OR
1651: IFFALSE 1655
// exit ;
1653: GO 1819
// tmp := AreaToList ( area , i ) ;
1655: LD_ADDR_VAR 0 6
1659: PUSH
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_VAR 0 5
1669: PPUSH
1670: CALL_OW 517
1674: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_VAR 0 6
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1817
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1697: LD_ADDR_VAR 0 7
1701: PUSH
1702: LD_VAR 0 6
1706: PUSH
1707: LD_INT 1
1709: ARRAY
1710: PUSH
1711: LD_VAR 0 5
1715: ARRAY
1716: PUSH
1717: LD_VAR 0 6
1721: PUSH
1722: LD_INT 2
1724: ARRAY
1725: PUSH
1726: LD_VAR 0 5
1730: ARRAY
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1736: LD_VAR 0 7
1740: PUSH
1741: LD_INT 1
1743: ARRAY
1744: PPUSH
1745: LD_VAR 0 7
1749: PUSH
1750: LD_INT 2
1752: ARRAY
1753: PPUSH
1754: CALL_OW 428
1758: PUSH
1759: LD_INT 0
1761: EQUAL
1762: IFFALSE 1815
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1764: LD_VAR 0 1
1768: PPUSH
1769: LD_VAR 0 7
1773: PUSH
1774: LD_INT 1
1776: ARRAY
1777: PPUSH
1778: LD_VAR 0 7
1782: PUSH
1783: LD_INT 2
1785: ARRAY
1786: PPUSH
1787: LD_VAR 0 3
1791: PPUSH
1792: CALL_OW 48
// result := IsPlaced ( unit ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 305
1810: ST_TO_ADDR
// exit ;
1811: POP
1812: POP
1813: GO 1819
// end ; end ;
1815: GO 1694
1817: POP
1818: POP
// end ;
1819: LD_VAR 0 4
1823: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1824: LD_INT 0
1826: PPUSH
1827: PPUSH
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1832: LD_VAR 0 1
1836: NOT
1837: PUSH
1838: LD_VAR 0 1
1842: PPUSH
1843: CALL_OW 263
1847: PUSH
1848: LD_INT 2
1850: EQUAL
1851: NOT
1852: OR
1853: IFFALSE 1857
// exit ;
1855: GO 2173
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1857: LD_ADDR_VAR 0 6
1861: PUSH
1862: LD_INT 22
1864: PUSH
1865: LD_VAR 0 1
1869: PPUSH
1870: CALL_OW 255
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 30
1884: PUSH
1885: LD_INT 36
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 34
1894: PUSH
1895: LD_INT 31
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: PPUSH
1911: CALL_OW 69
1915: ST_TO_ADDR
// if not tmp then
1916: LD_VAR 0 6
1920: NOT
1921: IFFALSE 1925
// exit ;
1923: GO 2173
// result := [ ] ;
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: EMPTY
1931: ST_TO_ADDR
// for i in tmp do
1932: LD_ADDR_VAR 0 3
1936: PUSH
1937: LD_VAR 0 6
1941: PUSH
1942: FOR_IN
1943: IFFALSE 2014
// begin t := UnitsInside ( i ) ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 313
1959: ST_TO_ADDR
// if t then
1960: LD_VAR 0 4
1964: IFFALSE 2012
// for j in t do
1966: LD_ADDR_VAR 0 7
1970: PUSH
1971: LD_VAR 0 4
1975: PUSH
1976: FOR_IN
1977: IFFALSE 2010
// result := Insert ( result , result + 1 , j ) ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_VAR 0 2
1988: PPUSH
1989: LD_VAR 0 2
1993: PUSH
1994: LD_INT 1
1996: PLUS
1997: PPUSH
1998: LD_VAR 0 7
2002: PPUSH
2003: CALL_OW 2
2007: ST_TO_ADDR
2008: GO 1976
2010: POP
2011: POP
// end ;
2012: GO 1942
2014: POP
2015: POP
// if not result then
2016: LD_VAR 0 2
2020: NOT
2021: IFFALSE 2025
// exit ;
2023: GO 2173
// mech := result [ 1 ] ;
2025: LD_ADDR_VAR 0 5
2029: PUSH
2030: LD_VAR 0 2
2034: PUSH
2035: LD_INT 1
2037: ARRAY
2038: ST_TO_ADDR
// if result > 1 then
2039: LD_VAR 0 2
2043: PUSH
2044: LD_INT 1
2046: GREATER
2047: IFFALSE 2159
// for i = 2 to result do
2049: LD_ADDR_VAR 0 3
2053: PUSH
2054: DOUBLE
2055: LD_INT 2
2057: DEC
2058: ST_TO_ADDR
2059: LD_VAR 0 2
2063: PUSH
2064: FOR_TO
2065: IFFALSE 2157
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2067: LD_ADDR_VAR 0 4
2071: PUSH
2072: LD_VAR 0 2
2076: PUSH
2077: LD_VAR 0 3
2081: ARRAY
2082: PPUSH
2083: LD_INT 3
2085: PPUSH
2086: CALL_OW 259
2090: PUSH
2091: LD_VAR 0 2
2095: PUSH
2096: LD_VAR 0 3
2100: ARRAY
2101: PPUSH
2102: CALL_OW 432
2106: MINUS
2107: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2108: LD_VAR 0 4
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_INT 3
2120: PPUSH
2121: CALL_OW 259
2125: PUSH
2126: LD_VAR 0 5
2130: PPUSH
2131: CALL_OW 432
2135: MINUS
2136: GREATEREQUAL
2137: IFFALSE 2155
// mech := result [ i ] ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 2
2148: PUSH
2149: LD_VAR 0 3
2153: ARRAY
2154: ST_TO_ADDR
// end ;
2155: GO 2064
2157: POP
2158: POP
// ComLinkTo ( vehicle , mech ) ;
2159: LD_VAR 0 1
2163: PPUSH
2164: LD_VAR 0 5
2168: PPUSH
2169: CALL_OW 135
// end ; end_of_file
2173: LD_VAR 0 2
2177: RET
// export function Action ; begin
2178: LD_INT 0
2180: PPUSH
// InGameOn ;
2181: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2185: LD_INT 221
2187: PPUSH
2188: LD_INT 80
2190: PPUSH
2191: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2195: LD_EXP 14
2199: PUSH
2200: LD_EXP 15
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: LD_INT 217
2211: PPUSH
2212: LD_INT 79
2214: PPUSH
2215: CALL_OW 111
// wait ( 0 0$7 ) ;
2219: LD_INT 245
2221: PPUSH
2222: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2226: LD_EXP 14
2230: PUSH
2231: LD_EXP 15
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2244: LD_EXP 15
2248: PPUSH
2249: LD_STRING D2-Bur-1
2251: PPUSH
2252: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2256: LD_EXP 14
2260: PPUSH
2261: LD_STRING D2-JMM-1
2263: PPUSH
2264: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2268: LD_INT 18
2270: PPUSH
2271: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2275: LD_EXP 15
2279: PPUSH
2280: LD_EXP 14
2284: PPUSH
2285: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2289: LD_EXP 15
2293: PPUSH
2294: LD_STRING D2-Bur-2
2296: PPUSH
2297: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2301: LD_EXP 15
2305: PPUSH
2306: LD_INT 21
2308: PUSH
2309: LD_INT 2
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: PPUSH
2321: LD_EXP 15
2325: PPUSH
2326: CALL_OW 74
2330: PPUSH
2331: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_INT 21
2342: PUSH
2343: LD_INT 2
2345: PUSH
2346: EMPTY
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL_OW 69
2354: PPUSH
2355: LD_EXP 14
2359: PPUSH
2360: CALL_OW 74
2364: PPUSH
2365: CALL_OW 120
// wait ( 0 0$1 ) ;
2369: LD_INT 35
2371: PPUSH
2372: CALL_OW 67
// InGameOff ;
2376: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2380: LD_STRING MArtPickup
2382: PPUSH
2383: CALL_OW 337
// end ;
2387: LD_VAR 0 1
2391: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2392: LD_EXP 22
2396: PPUSH
2397: LD_INT 101
2399: PUSH
2400: LD_INT 7
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 72
2411: IFFALSE 2440
2413: GO 2415
2415: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2416: LD_EXP 15
2420: PPUSH
2421: LD_STRING D3-Bur-1
2423: PPUSH
2424: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2428: LD_EXP 14
2432: PPUSH
2433: LD_STRING D3-JMM-1
2435: PPUSH
2436: CALL_OW 88
// end ;
2440: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2441: LD_INT 5
2443: PPUSH
2444: LD_INT 22
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 70
2458: IFFALSE 2789
2460: GO 2462
2462: DISABLE
// begin wait ( 0 0$3 ) ;
2463: LD_INT 105
2465: PPUSH
2466: CALL_OW 67
// DialogueOn ;
2470: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2474: LD_EXP 14
2478: PPUSH
2479: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2483: LD_EXP 14
2487: PPUSH
2488: LD_STRING D3a-JMM-1
2490: PPUSH
2491: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2495: LD_EXP 15
2499: PPUSH
2500: LD_STRING D3a-Bur-1
2502: PPUSH
2503: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2507: LD_EXP 14
2511: PPUSH
2512: LD_STRING D3a-JMM-2
2514: PPUSH
2515: CALL_OW 88
// if Joan then
2519: LD_EXP 16
2523: IFFALSE 2539
// SayRadio ( Joan , D3a-Joan-2 ) else
2525: LD_EXP 16
2529: PPUSH
2530: LD_STRING D3a-Joan-2
2532: PPUSH
2533: CALL_OW 94
2537: GO 2551
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2539: LD_EXP 17
2543: PPUSH
2544: LD_STRING D3a-RSci1-2
2546: PPUSH
2547: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2551: LD_EXP 18
2555: PPUSH
2556: LD_STRING D3a-Huck-2
2558: PPUSH
2559: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2563: LD_EXP 19
2567: PPUSH
2568: LD_STRING D3a-Pow-2
2570: PPUSH
2571: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2575: LD_EXP 18
2579: PPUSH
2580: LD_STRING D3a-Huck-3
2582: PPUSH
2583: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2587: LD_EXP 19
2591: PPUSH
2592: LD_STRING D3a-Pow-3
2594: PPUSH
2595: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2599: LD_EXP 18
2603: PPUSH
2604: LD_STRING D3a-Huck-4
2606: PPUSH
2607: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2611: LD_EXP 14
2615: PPUSH
2616: LD_STRING D3a-JMM-4
2618: PPUSH
2619: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2623: LD_EXP 15
2627: PPUSH
2628: LD_STRING D3a-Bur-4
2630: PPUSH
2631: CALL_OW 88
// if Joan then
2635: LD_EXP 16
2639: IFFALSE 2655
// SayRadio ( Joan , D3a-Joan-4 ) else
2641: LD_EXP 16
2645: PPUSH
2646: LD_STRING D3a-Joan-4
2648: PPUSH
2649: CALL_OW 94
2653: GO 2667
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2655: LD_EXP 17
2659: PPUSH
2660: LD_STRING D3a-RSci1-4
2662: PPUSH
2663: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2667: LD_INT 133
2669: PPUSH
2670: LD_INT 43
2672: PPUSH
2673: LD_INT 7
2675: PPUSH
2676: LD_INT 10
2678: NEG
2679: PPUSH
2680: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2684: LD_INT 133
2686: PPUSH
2687: LD_INT 43
2689: PPUSH
2690: LD_INT 7
2692: PPUSH
2693: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2697: LD_INT 133
2699: PPUSH
2700: LD_INT 43
2702: PPUSH
2703: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2707: LD_INT 10
2709: PPUSH
2710: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2714: LD_EXP 14
2718: PPUSH
2719: LD_STRING D3a-JMM-5
2721: PPUSH
2722: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2726: LD_EXP 15
2730: PPUSH
2731: LD_STRING D3a-Bur-5
2733: PPUSH
2734: CALL_OW 88
// DialogueOff ;
2738: CALL_OW 7
// seenBase := true ;
2742: LD_ADDR_EXP 8
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2750: LD_INT 525
2752: PUSH
2753: LD_INT 420
2755: PUSH
2756: LD_INT 315
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2774: LD_EXP 21
2778: PPUSH
2779: LD_INT 142
2781: PPUSH
2782: LD_INT 52
2784: PPUSH
2785: CALL_OW 116
// end ;
2789: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2790: LD_EXP 8
2794: NOT
2795: PUSH
2796: LD_EXP 4
2800: NOT
2801: AND
2802: IFFALSE 2822
2804: GO 2806
2806: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2807: LD_EXP 21
2811: PPUSH
2812: LD_INT 142
2814: PPUSH
2815: LD_INT 52
2817: PPUSH
2818: CALL_OW 116
2822: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2823: LD_INT 0
2825: PPUSH
2826: PPUSH
// contaminateTime := tick ;
2827: LD_ADDR_EXP 3
2831: PUSH
2832: LD_OWVAR 1
2836: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2837: LD_INT 175
2839: PPUSH
2840: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_INT 4
2851: PPUSH
2852: CALL_OW 469
2856: ST_TO_ADDR
// if art then
2857: LD_VAR 0 5
2861: IFFALSE 2900
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2863: LD_VAR 0 5
2867: PUSH
2868: LD_INT 1
2870: ARRAY
2871: PUSH
2872: LD_INT 157
2874: EQUAL
2875: PUSH
2876: LD_VAR 0 5
2880: PUSH
2881: LD_INT 2
2883: ARRAY
2884: PUSH
2885: LD_INT 75
2887: EQUAL
2888: AND
2889: IFFALSE 2900
// begin YouLost ( Artefact ) ;
2891: LD_STRING Artefact
2893: PPUSH
2894: CALL_OW 104
// exit ;
2898: GO 3052
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2900: LD_EXP 14
2904: PPUSH
2905: CALL_OW 302
2909: PUSH
2910: LD_EXP 15
2914: PPUSH
2915: CALL_OW 302
2919: AND
2920: IFFALSE 2997
// begin DialogueOn ;
2922: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2926: LD_EXP 14
2930: PPUSH
2931: LD_STRING D6a-JMM-1
2933: PPUSH
2934: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2938: LD_EXP 15
2942: PPUSH
2943: LD_STRING D6a-Bur-1
2945: PPUSH
2946: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2950: LD_EXP 14
2954: PPUSH
2955: LD_STRING D6c-JMM-1
2957: PPUSH
2958: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2962: LD_EXP 15
2966: PPUSH
2967: LD_STRING D6c-Bur-1
2969: PPUSH
2970: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2974: LD_EXP 14
2978: PPUSH
2979: LD_STRING D6c-JMM-2
2981: PPUSH
2982: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2986: LD_STRING MBase
2988: PPUSH
2989: CALL_OW 337
// DialogueOff ;
2993: CALL_OW 7
// end ; bombExploded := true ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: LD_INT 1
3004: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3005: LD_INT 6300
3007: PUSH
3008: LD_INT 5250
3010: PUSH
3011: LD_INT 4200
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PPUSH
3025: CALL_OW 67
// if IsOk ( JMM ) then
3029: LD_EXP 14
3033: PPUSH
3034: CALL_OW 302
3038: IFFALSE 3052
// Say ( JMM , D8-JMM-1 ) ;
3040: LD_EXP 14
3044: PPUSH
3045: LD_STRING D8-JMM-1
3047: PPUSH
3048: CALL_OW 88
// end ;
3052: LD_VAR 0 4
3056: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3057: LD_EXP 9
3061: PUSH
3062: LD_EXP 7
3066: NOT
3067: AND
3068: PUSH
3069: LD_EXP 4
3073: AND
3074: IFFALSE 3129
3076: GO 3078
3078: DISABLE
// begin enable ;
3079: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3080: LD_INT 9
3082: PPUSH
3083: LD_INT 22
3085: PUSH
3086: LD_INT 7
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 70
3097: IFFALSE 3115
// stevensTimer := stevensTimer - 0 0$30 else
3099: LD_ADDR_EXP 9
3103: PUSH
3104: LD_EXP 9
3108: PUSH
3109: LD_INT 1050
3111: MINUS
3112: ST_TO_ADDR
3113: GO 3129
// stevensTimer := stevensTimer - 0 0$1 ;
3115: LD_ADDR_EXP 9
3119: PUSH
3120: LD_EXP 9
3124: PUSH
3125: LD_INT 35
3127: MINUS
3128: ST_TO_ADDR
// end ;
3129: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3130: LD_EXP 9
3134: PUSH
3135: LD_INT 0
3137: LESSEQUAL
3138: PUSH
3139: LD_EXP 7
3143: NOT
3144: AND
3145: IFFALSE 3309
3147: GO 3149
3149: DISABLE
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: ST_TO_ADDR
// for i in tmp do
3188: LD_ADDR_VAR 0 1
3192: PUSH
3193: LD_VAR 0 2
3197: PUSH
3198: FOR_IN
3199: IFFALSE 3252
// begin if IsInUnit ( i ) then
3201: LD_VAR 0 1
3205: PPUSH
3206: CALL_OW 310
3210: IFFALSE 3223
// ComExitBuilding ( i ) else
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 122
3221: GO 3250
// if not HasTask ( i ) then
3223: LD_VAR 0 1
3227: PPUSH
3228: CALL_OW 314
3232: NOT
3233: IFFALSE 3250
// ComMoveXY ( i , 29 , 56 ) ;
3235: LD_VAR 0 1
3239: PPUSH
3240: LD_INT 29
3242: PPUSH
3243: LD_INT 56
3245: PPUSH
3246: CALL_OW 111
// end ;
3250: GO 3198
3252: POP
3253: POP
// repeat wait ( 0 0$1 ) ;
3254: LD_INT 35
3256: PPUSH
3257: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3261: LD_INT 8
3263: PPUSH
3264: LD_INT 22
3266: PUSH
3267: LD_INT 1
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 25
3276: PUSH
3277: LD_INT 4
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL_OW 70
3292: IFFALSE 3254
// if planCaptured then
3294: LD_EXP 7
3298: IFFALSE 3302
// exit ;
3300: GO 3309
// YouLost ( Time ) ;
3302: LD_STRING Time
3304: PPUSH
3305: CALL_OW 104
// end ;
3309: PPOPN 2
3311: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3312: LD_INT 22
3314: PUSH
3315: LD_INT 7
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: LD_INT 92
3324: PUSH
3325: LD_INT 142
3327: PUSH
3328: LD_INT 52
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 69
3348: PUSH
3349: LD_EXP 3
3353: PUSH
3354: LD_INT 6000
3356: PLUS
3357: PUSH
3358: LD_OWVAR 1
3362: GREATER
3363: AND
3364: PUSH
3365: LD_EXP 4
3369: AND
3370: IFFALSE 3425
3372: GO 3374
3374: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3375: LD_EXP 14
3379: PUSH
3380: LD_EXP 15
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 85
// DialogueOn ;
3393: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3397: LD_EXP 14
3401: PPUSH
3402: LD_STRING D6b-JMM-1
3404: PPUSH
3405: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3409: LD_EXP 15
3413: PPUSH
3414: LD_STRING D6b-Bur-1
3416: PPUSH
3417: CALL_OW 88
// DialogueOff ;
3421: CALL_OW 7
// end ;
3425: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3426: LD_EXP 15
3430: PPUSH
3431: LD_INT 142
3433: PPUSH
3434: LD_INT 52
3436: PPUSH
3437: CALL_OW 297
3441: PUSH
3442: LD_INT 25
3444: LESS
3445: PUSH
3446: LD_EXP 15
3450: PPUSH
3451: CALL_OW 310
3455: PPUSH
3456: LD_INT 142
3458: PPUSH
3459: LD_INT 52
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 25
3469: LESS
3470: OR
3471: PUSH
3472: LD_EXP 15
3476: PPUSH
3477: CALL_OW 256
3481: PUSH
3482: LD_INT 1000
3484: LESS
3485: AND
3486: PUSH
3487: LD_EXP 3
3491: PUSH
3492: LD_INT 6000
3494: PLUS
3495: PUSH
3496: LD_OWVAR 1
3500: GREATER
3501: AND
3502: PUSH
3503: LD_EXP 4
3507: AND
3508: IFFALSE 3541
3510: GO 3512
3512: DISABLE
// begin DialogueOn ;
3513: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3517: LD_EXP 15
3521: PPUSH
3522: LD_STRING D7-Bur-1
3524: PPUSH
3525: CALL_OW 88
// enteredContaminatedArea := true ;
3529: LD_ADDR_EXP 5
3533: PUSH
3534: LD_INT 1
3536: ST_TO_ADDR
// DialogueOff ;
3537: CALL_OW 7
// end ;
3541: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3542: LD_EXP 14
3546: PPUSH
3547: LD_INT 142
3549: PPUSH
3550: LD_INT 52
3552: PPUSH
3553: CALL_OW 297
3557: PUSH
3558: LD_INT 25
3560: LESS
3561: PUSH
3562: LD_EXP 14
3566: PPUSH
3567: CALL_OW 310
3571: PPUSH
3572: LD_INT 142
3574: PPUSH
3575: LD_INT 52
3577: PPUSH
3578: CALL_OW 297
3582: PUSH
3583: LD_INT 25
3585: LESS
3586: OR
3587: PUSH
3588: LD_EXP 14
3592: PPUSH
3593: CALL_OW 256
3597: PUSH
3598: LD_INT 1000
3600: LESS
3601: AND
3602: PUSH
3603: LD_EXP 3
3607: PUSH
3608: LD_INT 6000
3610: PLUS
3611: PUSH
3612: LD_OWVAR 1
3616: GREATER
3617: AND
3618: PUSH
3619: LD_EXP 4
3623: AND
3624: IFFALSE 3657
3626: GO 3628
3628: DISABLE
// begin DialogueOn ;
3629: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3633: LD_EXP 14
3637: PPUSH
3638: LD_STRING D7-JMM-1
3640: PPUSH
3641: CALL_OW 88
// enteredContaminatedArea := true ;
3645: LD_ADDR_EXP 5
3649: PUSH
3650: LD_INT 1
3652: ST_TO_ADDR
// DialogueOff ;
3653: CALL_OW 7
// end ;
3657: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3658: LD_EXP 6
3662: PUSH
3663: LD_EXP 14
3667: PPUSH
3668: CALL_OW 302
3672: AND
3673: PUSH
3674: LD_EXP 15
3678: PPUSH
3679: CALL_OW 302
3683: AND
3684: IFFALSE 3753
3686: GO 3688
3688: DISABLE
// begin DialogueOn ;
3689: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3693: LD_EXP 14
3697: PUSH
3698: LD_EXP 15
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PPUSH
3707: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3711: LD_EXP 14
3715: PPUSH
3716: LD_STRING D4-JMM-1
3718: PPUSH
3719: CALL_OW 88
// if not bombExploded then
3723: LD_EXP 4
3727: NOT
3728: IFFALSE 3742
// Say ( Burlak , D4-Bur-1 ) ;
3730: LD_EXP 15
3734: PPUSH
3735: LD_STRING D4-Bur-1
3737: PPUSH
3738: CALL_OW 88
// DialogueOff ;
3742: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3746: LD_STRING MReturn
3748: PPUSH
3749: CALL_OW 337
// end ;
3753: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3754: LD_EXP 7
3758: NOT
3759: PUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 7
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 91
3772: PUSH
3773: LD_INT 9
3775: PUSH
3776: LD_INT 6
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PPUSH
3788: CALL_OW 69
3792: AND
3793: IFFALSE 3870
3795: GO 3797
3797: DISABLE
// begin DialogueOn ;
3798: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3802: LD_INT 55
3804: PPUSH
3805: LD_INT 11
3807: PPUSH
3808: LD_INT 7
3810: PPUSH
3811: LD_INT 6
3813: NEG
3814: PPUSH
3815: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3819: LD_INT 55
3821: PPUSH
3822: LD_INT 11
3824: PPUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3832: LD_EXP 15
3836: PPUSH
3837: LD_STRING D9-Bur-1
3839: PPUSH
3840: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3844: LD_EXP 14
3848: PPUSH
3849: LD_STRING D9-JMM-1
3851: PPUSH
3852: CALL_OW 88
// DialogueOff ;
3856: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3860: LD_INT 9
3862: PPUSH
3863: LD_INT 7
3865: PPUSH
3866: CALL_OW 235
// end ;
3870: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3871: LD_INT 9
3873: PPUSH
3874: LD_INT 22
3876: PUSH
3877: LD_INT 7
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 70
3888: IFFALSE 3924
3890: GO 3892
3892: DISABLE
// begin wait ( 0 0$07 ) ;
3893: LD_INT 245
3895: PPUSH
3896: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3900: LD_EXP 14
3904: PPUSH
3905: LD_STRING D10b-JMM-1
3907: PPUSH
3908: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3912: LD_EXP 15
3916: PPUSH
3917: LD_STRING D10b-Bur-1
3919: PPUSH
3920: CALL_OW 88
// end ;
3924: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3925: LD_EXP 9
3929: PUSH
3930: LD_INT 22
3932: PUSH
3933: LD_INT 1
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 4
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 26
3952: PUSH
3953: LD_INT 1
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: LIST
3964: PPUSH
3965: CALL_OW 69
3969: AND
3970: PUSH
3971: LD_INT 5
3973: PPUSH
3974: CALL_OW 255
3978: PUSH
3979: LD_INT 7
3981: EQUAL
3982: PUSH
3983: LD_INT 22
3985: PUSH
3986: LD_INT 1
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 25
3995: PUSH
3996: LD_INT 1
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: CALL_OW 69
4011: PUSH
4012: LD_INT 0
4014: EQUAL
4015: OR
4016: AND
4017: IFFALSE 4606
4019: GO 4021
4021: DISABLE
4022: LD_INT 0
4024: PPUSH
// begin case Query ( QKill ) of 1 :
4025: LD_STRING QKill
4027: PPUSH
4028: CALL_OW 97
4032: PUSH
4033: LD_INT 1
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4041
4039: GO 4594
4041: POP
// begin DialogueOn ;
4042: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4046: LD_EXP 14
4050: PPUSH
4051: LD_STRING D10a-JMM-1
4053: PPUSH
4054: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4058: LD_EXP 15
4062: PPUSH
4063: LD_STRING D10a-Bur-1
4065: PPUSH
4066: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4070: LD_EXP 14
4074: PPUSH
4075: LD_STRING D10a-JMM-2
4077: PPUSH
4078: CALL_OW 88
// if IsOk ( Stevens ) then
4082: LD_EXP 18
4086: PPUSH
4087: CALL_OW 302
4091: IFFALSE 4107
// Say ( Stevens , D10a-Huck-2 ) else
4093: LD_EXP 18
4097: PPUSH
4098: LD_STRING D10a-Huck-2
4100: PPUSH
4101: CALL_OW 88
4105: GO 4158
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4107: LD_INT 22
4109: PUSH
4110: LD_INT 1
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: LD_INT 25
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: LD_INT 26
4129: PUSH
4130: LD_INT 1
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: PPUSH
4151: LD_STRING D10a-ASci1-3
4153: PPUSH
4154: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4158: LD_EXP 14
4162: PPUSH
4163: LD_STRING D10a-JMM-4
4165: PPUSH
4166: CALL_OW 88
// if IsOk ( Stevens ) then
4170: LD_EXP 18
4174: PPUSH
4175: CALL_OW 302
4179: IFFALSE 4193
// Say ( Stevens , D10a-Huck-3 ) ;
4181: LD_EXP 18
4185: PPUSH
4186: LD_STRING D10a-Huck-3
4188: PPUSH
4189: CALL_OW 88
// DialogueOff ;
4193: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4197: LD_INT 1
4199: PPUSH
4200: LD_INT 7
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: CALL_OW 80
// planCaptured := true ;
4213: LD_ADDR_EXP 7
4217: PUSH
4218: LD_INT 1
4220: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4221: LD_STRING MEnd
4223: PPUSH
4224: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4228: LD_STRING ACH_DIPLOMACY
4230: PPUSH
4231: CALL_OW 543
// canEnd := true ;
4235: LD_ADDR_EXP 10
4239: PUSH
4240: LD_INT 1
4242: ST_TO_ADDR
// missionTime := tick ;
4243: LD_ADDR_EXP 11
4247: PUSH
4248: LD_OWVAR 1
4252: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4260: LD_INT 22
4262: PUSH
4263: LD_INT 1
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 3
4272: PUSH
4273: LD_INT 50
4275: PUSH
4276: EMPTY
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: IFFALSE 4407
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_INT 22
4300: PUSH
4301: LD_INT 1
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: LD_INT 25
4310: PUSH
4311: LD_INT 4
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PPUSH
4322: CALL_OW 69
4326: PUSH
4327: FOR_IN
4328: IFFALSE 4405
// begin if IsInUnit ( i ) then
4330: LD_VAR 0 1
4334: PPUSH
4335: CALL_OW 310
4339: IFFALSE 4352
// ComExitBuilding ( i ) else
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 122
4350: GO 4403
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: LD_INT 22
4359: PUSH
4360: LD_INT 1
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 3
4369: PUSH
4370: LD_INT 50
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PPUSH
4384: CALL_OW 69
4388: PPUSH
4389: LD_VAR 0 1
4393: PPUSH
4394: CALL_OW 74
4398: PPUSH
4399: CALL_OW 128
// end ;
4403: GO 4327
4405: POP
4406: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4407: LD_INT 22
4409: PUSH
4410: LD_INT 1
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 3
4419: PUSH
4420: LD_INT 50
4422: PUSH
4423: EMPTY
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: EMPTY
4431: LIST
4432: LIST
4433: PPUSH
4434: CALL_OW 69
4438: NOT
4439: IFFALSE 4253
// repeat wait ( 3 ) ;
4441: LD_INT 3
4443: PPUSH
4444: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4448: LD_ADDR_VAR 0 1
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_INT 1
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 21
4465: PUSH
4466: LD_INT 1
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PPUSH
4477: CALL_OW 69
4481: PUSH
4482: FOR_IN
4483: IFFALSE 4559
// begin if IsInArea ( i , stevensEscapeArea ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: LD_INT 8
4492: PPUSH
4493: CALL_OW 308
4497: IFFALSE 4510
// begin RemoveUnit ( i ) ;
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 64
// continue ;
4508: GO 4482
// end ; if IsInUnit ( i ) then
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 310
4519: IFFALSE 4530
// ComExitBuilding ( i ) ;
4521: LD_VAR 0 1
4525: PPUSH
4526: CALL_OW 122
// if not HasTask ( i ) then
4530: LD_VAR 0 1
4534: PPUSH
4535: CALL_OW 314
4539: NOT
4540: IFFALSE 4557
// ComMoveXY ( i , 28 , 55 ) ;
4542: LD_VAR 0 1
4546: PPUSH
4547: LD_INT 28
4549: PPUSH
4550: LD_INT 55
4552: PPUSH
4553: CALL_OW 111
// end ;
4557: GO 4482
4559: POP
4560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4561: LD_INT 22
4563: PUSH
4564: LD_INT 1
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 69
4589: NOT
4590: IFFALSE 4441
// end ; 2 :
4592: GO 4606
4594: LD_INT 2
4596: DOUBLE
4597: EQUAL
4598: IFTRUE 4602
4600: GO 4605
4602: POP
// ; end ;
4603: GO 4606
4605: POP
// end ;
4606: PPOPN 1
4608: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4609: LD_EXP 10
4613: IFFALSE 4970
4615: GO 4617
4617: DISABLE
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
4622: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4623: LD_INT 10
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: CALL_OW 424
// if Difficulty < 2 then
4633: LD_OWVAR 67
4637: PUSH
4638: LD_INT 2
4640: LESS
4641: IFFALSE 4645
// exit ;
4643: GO 4970
// uc_side := 4 ;
4645: LD_ADDR_OWVAR 20
4649: PUSH
4650: LD_INT 4
4652: ST_TO_ADDR
// uc_nation := 1 ;
4653: LD_ADDR_OWVAR 21
4657: PUSH
4658: LD_INT 1
4660: ST_TO_ADDR
// InitHc ;
4661: CALL_OW 19
// tmp := [ ] ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: EMPTY
4671: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4672: LD_INT 0
4674: PPUSH
4675: LD_INT 5
4677: PPUSH
4678: LD_INT 10
4680: PPUSH
4681: CALL_OW 380
// un := CreateHuman ;
4685: LD_ADDR_VAR 0 1
4689: PUSH
4690: CALL_OW 44
4694: ST_TO_ADDR
// tmp := [ un ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_VAR 0 1
4704: PUSH
4705: EMPTY
4706: LIST
4707: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4708: LD_VAR 0 1
4712: PPUSH
4713: LD_INT 226
4715: PPUSH
4716: LD_INT 86
4718: PPUSH
4719: LD_INT 0
4721: PPUSH
4722: CALL_OW 48
// ComHold ( un ) ;
4726: LD_VAR 0 1
4730: PPUSH
4731: CALL_OW 140
// for i = 1 to 3 do
4735: LD_ADDR_VAR 0 2
4739: PUSH
4740: DOUBLE
4741: LD_INT 1
4743: DEC
4744: ST_TO_ADDR
4745: LD_INT 3
4747: PUSH
4748: FOR_TO
4749: IFFALSE 4848
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4751: LD_INT 0
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: LD_INT 8
4759: PPUSH
4760: CALL_OW 380
// un := CreateHuman ;
4764: LD_ADDR_VAR 0 1
4768: PUSH
4769: CALL_OW 44
4773: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4774: LD_VAR 0 1
4778: PPUSH
4779: LD_INT 5
4781: PPUSH
4782: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4786: LD_VAR 0 1
4790: PPUSH
4791: LD_INT 215
4793: PUSH
4794: LD_INT 217
4796: PUSH
4797: LD_INT 219
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: LIST
4804: PUSH
4805: LD_VAR 0 2
4809: ARRAY
4810: PPUSH
4811: LD_INT 76
4813: PPUSH
4814: LD_INT 0
4816: PPUSH
4817: CALL_OW 48
// ComCrawl ( un ) ;
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 137
// tmp := tmp ^ un ;
4830: LD_ADDR_VAR 0 3
4834: PUSH
4835: LD_VAR 0 3
4839: PUSH
4840: LD_VAR 0 1
4844: ADD
4845: ST_TO_ADDR
// end ;
4846: GO 4748
4848: POP
4849: POP
// repeat wait ( 0 0$1 ) ;
4850: LD_INT 35
4852: PPUSH
4853: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4857: LD_VAR 0 1
4861: PPUSH
4862: LD_INT 24
4864: PUSH
4865: LD_INT 1000
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PPUSH
4872: CALL_OW 72
4876: NOT
4877: IFFALSE 4850
// for i in tmp do
4879: LD_ADDR_VAR 0 2
4883: PUSH
4884: LD_VAR 0 3
4888: PUSH
4889: FOR_IN
4890: IFFALSE 4968
// begin wait ( 0 0$1 ) ;
4892: LD_INT 35
4894: PPUSH
4895: CALL_OW 67
// if Crawls ( i ) then
4899: LD_VAR 0 2
4903: PPUSH
4904: CALL_OW 318
4908: IFFALSE 4921
// ComWalk ( i ) else
4910: LD_VAR 0 2
4914: PPUSH
4915: CALL_OW 138
4919: GO 4966
// if GetClass ( i ) = class_sniper then
4921: LD_VAR 0 2
4925: PPUSH
4926: CALL_OW 257
4930: PUSH
4931: LD_INT 5
4933: EQUAL
4934: IFFALSE 4952
// ComAttackSoporific ( i , JMM ) else
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_EXP 14
4945: PPUSH
4946: CALL_OW 166
4950: GO 4966
// ComAttackUnit ( i , JMM ) ;
4952: LD_VAR 0 2
4956: PPUSH
4957: LD_EXP 14
4961: PPUSH
4962: CALL_OW 115
// end ;
4966: GO 4889
4968: POP
4969: POP
// end ;
4970: PPOPN 3
4972: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4973: LD_EXP 7
4977: NOT
4978: PUSH
4979: LD_INT 1
4981: PPUSH
4982: CALL_OW 301
4986: AND
4987: IFFALSE 4999
4989: GO 4991
4991: DISABLE
// YouLost ( Lab ) ;
4992: LD_STRING Lab
4994: PPUSH
4995: CALL_OW 104
4999: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5000: LD_INT 10
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 7
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 70
5017: PUSH
5018: LD_INT 2
5020: GREATEREQUAL
5021: PUSH
5022: LD_INT 10
5024: PPUSH
5025: LD_INT 2
5027: PUSH
5028: LD_INT 34
5030: PUSH
5031: LD_INT 12
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 34
5040: PUSH
5041: LD_INT 51
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 70
5057: AND
5058: PUSH
5059: LD_EXP 10
5063: AND
5064: PUSH
5065: LD_EXP 7
5069: AND
5070: PUSH
5071: LD_EXP 6
5075: AND
5076: IFFALSE 5332
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
// begin m1 := false ;
5085: LD_ADDR_VAR 0 1
5089: PUSH
5090: LD_INT 0
5092: ST_TO_ADDR
// m2 := false ;
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: LD_INT 0
5100: ST_TO_ADDR
// if killCounter = 0 then
5101: LD_EXP 12
5105: PUSH
5106: LD_INT 0
5108: EQUAL
5109: IFFALSE 5118
// SetAchievement ( ACH_PACIFIST ) ;
5111: LD_STRING ACH_PACIFIST
5113: PPUSH
5114: CALL_OW 543
// if tick < 7 7$00 then
5118: LD_OWVAR 1
5122: PUSH
5123: LD_INT 14700
5125: LESS
5126: IFFALSE 5142
// begin wait ( 3 ) ;
5128: LD_INT 3
5130: PPUSH
5131: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5135: LD_STRING ACH_ASPEED_18
5137: PPUSH
5138: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5142: LD_STRING Explosion
5144: PPUSH
5145: LD_INT 1
5147: PPUSH
5148: CALL_OW 101
// if enteredContaminatedArea then
5152: LD_EXP 5
5156: IFFALSE 5178
// begin m1 := true ;
5158: LD_ADDR_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5166: LD_STRING BioHazard
5168: PPUSH
5169: LD_INT 1
5171: PPUSH
5172: CALL_OW 101
// end else
5176: GO 5189
// AddMedal ( BioHazard , - 1 ) ;
5178: LD_STRING BioHazard
5180: PPUSH
5181: LD_INT 1
5183: NEG
5184: PPUSH
5185: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5189: LD_EXP 11
5193: PUSH
5194: LD_INT 42000
5196: PUSH
5197: LD_INT 31500
5199: PUSH
5200: LD_INT 25200
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_OWVAR 67
5212: ARRAY
5213: LESSEQUAL
5214: IFFALSE 5236
// begin m2 := true ;
5216: LD_ADDR_VAR 0 2
5220: PUSH
5221: LD_INT 1
5223: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5224: LD_STRING Speed
5226: PPUSH
5227: LD_INT 1
5229: PPUSH
5230: CALL_OW 101
// end else
5234: GO 5247
// AddMedal ( Speed , - 1 ) ;
5236: LD_STRING Speed
5238: PPUSH
5239: LD_INT 1
5241: NEG
5242: PPUSH
5243: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5247: LD_OWVAR 67
5251: PUSH
5252: LD_INT 3
5254: EQUAL
5255: PUSH
5256: LD_VAR 0 1
5260: AND
5261: PUSH
5262: LD_VAR 0 2
5266: AND
5267: IFFALSE 5279
// SetAchievementEX ( ACH_AMER , 18 ) ;
5269: LD_STRING ACH_AMER
5271: PPUSH
5272: LD_INT 18
5274: PPUSH
5275: CALL_OW 564
// GiveMedals ( Main ) ;
5279: LD_STRING Main
5281: PPUSH
5282: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5286: LD_EXP 14
5290: PUSH
5291: LD_EXP 15
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5304: LD_EXP 14
5308: PPUSH
5309: LD_STRING 14a_JMM
5311: PPUSH
5312: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5316: LD_EXP 15
5320: PPUSH
5321: LD_STRING 14a_Burlak
5323: PPUSH
5324: CALL_OW 38
// YouWin ;
5328: CALL_OW 103
// end ; end_of_file
5332: PPOPN 2
5334: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5335: LD_INT 0
5337: PPUSH
5338: PPUSH
5339: PPUSH
5340: PPUSH
// uc_side := 1 ;
5341: LD_ADDR_OWVAR 20
5345: PUSH
5346: LD_INT 1
5348: ST_TO_ADDR
// uc_nation := 1 ;
5349: LD_ADDR_OWVAR 21
5353: PUSH
5354: LD_INT 1
5356: ST_TO_ADDR
// InitHc ;
5357: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5361: LD_INT 34
5363: PPUSH
5364: CALL_OW 274
5368: PPUSH
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 500
5374: PPUSH
5375: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5379: LD_INT 34
5381: PPUSH
5382: CALL_OW 274
5386: PPUSH
5387: LD_INT 3
5389: PPUSH
5390: LD_INT 20
5392: PPUSH
5393: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5397: LD_ADDR_EXP 18
5401: PUSH
5402: LD_STRING Stevens
5404: PPUSH
5405: CALL_OW 25
5409: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5410: LD_ADDR_EXP 19
5414: PUSH
5415: LD_STRING Powell
5417: PPUSH
5418: CALL_OW 25
5422: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5423: LD_EXP 18
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: CALL_OW 52
// vehGuard := [ ] ;
5435: LD_ADDR_EXP 23
5439: PUSH
5440: EMPTY
5441: ST_TO_ADDR
// hc_importance := 0 ;
5442: LD_ADDR_OWVAR 32
5446: PUSH
5447: LD_INT 0
5449: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 3
5455: PPUSH
5456: LD_INT 3
5458: PPUSH
5459: LD_INT 8
5461: PPUSH
5462: LD_INT 100
5464: PPUSH
5465: CALL 971 0 5
// sibBomb := CreateVehicle ;
5469: LD_ADDR_EXP 21
5473: PUSH
5474: CALL_OW 45
5478: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5479: LD_EXP 21
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5491: LD_EXP 21
5495: PPUSH
5496: LD_INT 93
5498: PPUSH
5499: LD_INT 74
5501: PPUSH
5502: LD_INT 0
5504: PPUSH
5505: CALL_OW 48
// guards := [ ] ;
5509: LD_ADDR_EXP 22
5513: PUSH
5514: EMPTY
5515: ST_TO_ADDR
// for i = 1 to 3 do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_INT 3
5528: PUSH
5529: FOR_TO
5530: IFFALSE 5622
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5532: LD_INT 0
5534: PPUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_INT 8
5540: PUSH
5541: LD_INT 9
5543: PUSH
5544: LD_INT 10
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PPUSH
5558: CALL_OW 380
// un := CreateHuman ;
5562: LD_ADDR_VAR 0 3
5566: PUSH
5567: CALL_OW 44
5571: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5572: LD_VAR 0 3
5576: PPUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 4
5585: PUSH
5586: EMPTY
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_VAR 0 2
5595: ARRAY
5596: PPUSH
5597: LD_INT 0
5599: PPUSH
5600: CALL_OW 49
// guards := guards ^ un ;
5604: LD_ADDR_EXP 22
5608: PUSH
5609: LD_EXP 22
5613: PUSH
5614: LD_VAR 0 3
5618: ADD
5619: ST_TO_ADDR
// end ;
5620: GO 5529
5622: POP
5623: POP
// baseGuards := [ ] ;
5624: LD_ADDR_EXP 20
5628: PUSH
5629: EMPTY
5630: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5631: LD_ADDR_VAR 0 2
5635: PUSH
5636: DOUBLE
5637: LD_INT 1
5639: DEC
5640: ST_TO_ADDR
5641: LD_INT 5
5643: PUSH
5644: LD_INT 6
5646: PUSH
5647: LD_INT 7
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: PUSH
5655: LD_OWVAR 67
5659: ARRAY
5660: PUSH
5661: FOR_TO
5662: IFFALSE 5808
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5664: LD_INT 0
5666: PPUSH
5667: LD_INT 8
5669: PUSH
5670: LD_INT 9
5672: PUSH
5673: LD_INT 10
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: PUSH
5681: LD_OWVAR 67
5685: ARRAY
5686: PPUSH
5687: CALL_OW 381
// un := CreateHuman ;
5691: LD_ADDR_VAR 0 3
5695: PUSH
5696: CALL_OW 44
5700: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5701: LD_ADDR_EXP 20
5705: PUSH
5706: LD_EXP 20
5710: PUSH
5711: LD_VAR 0 3
5715: ADD
5716: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5717: LD_ADDR_VAR 0 4
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 58
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 30
5740: PUSH
5741: LD_INT 32
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 69
5757: ST_TO_ADDR
// if tmp then
5758: LD_VAR 0 4
5762: IFFALSE 5794
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5764: LD_VAR 0 3
5768: PPUSH
5769: LD_VAR 0 4
5773: PUSH
5774: LD_INT 1
5776: PPUSH
5777: LD_VAR 0 4
5781: PPUSH
5782: CALL_OW 12
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
5792: GO 5806
// PlaceHumanInUnit ( un , us_bar ) ;
5794: LD_VAR 0 3
5798: PPUSH
5799: LD_INT 51
5801: PPUSH
5802: CALL_OW 52
// end ;
5806: GO 5661
5808: POP
5809: POP
// if Difficulty > 1 then
5810: LD_OWVAR 67
5814: PUSH
5815: LD_INT 1
5817: GREATER
5818: IFFALSE 5862
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5820: LD_INT 0
5822: PPUSH
5823: LD_INT 5
5825: PPUSH
5826: LD_INT 9
5828: PUSH
5829: LD_INT 10
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PUSH
5836: LD_OWVAR 67
5840: PUSH
5841: LD_INT 1
5843: MINUS
5844: ARRAY
5845: PPUSH
5846: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5850: CALL_OW 44
5854: PPUSH
5855: LD_INT 80
5857: PPUSH
5858: CALL_OW 52
// end ; for i = 1 to 3 do
5862: LD_ADDR_VAR 0 2
5866: PUSH
5867: DOUBLE
5868: LD_INT 1
5870: DEC
5871: ST_TO_ADDR
5872: LD_INT 3
5874: PUSH
5875: FOR_TO
5876: IFFALSE 5902
// begin PrepareMechanic ( false , 9 ) ;
5878: LD_INT 0
5880: PPUSH
5881: LD_INT 9
5883: PPUSH
5884: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5888: CALL_OW 44
5892: PPUSH
5893: LD_INT 43
5895: PPUSH
5896: CALL_OW 52
// end ;
5900: GO 5875
5902: POP
5903: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_INT 49
5911: PPUSH
5912: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5916: LD_ADDR_VAR 0 2
5920: PUSH
5921: DOUBLE
5922: LD_INT 1
5924: DEC
5925: ST_TO_ADDR
5926: LD_INT 1
5928: PUSH
5929: LD_OWVAR 67
5933: PLUS
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5979
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5938: LD_INT 0
5940: PPUSH
5941: LD_INT 8
5943: PUSH
5944: LD_INT 9
5946: PUSH
5947: LD_INT 10
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: LD_OWVAR 67
5959: ARRAY
5960: PPUSH
5961: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5965: CALL_OW 44
5969: PPUSH
5970: LD_INT 5
5972: PPUSH
5973: CALL_OW 52
// end ;
5977: GO 5935
5979: POP
5980: POP
// for i = 1 to 3 do
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: DOUBLE
5987: LD_INT 1
5989: DEC
5990: ST_TO_ADDR
5991: LD_INT 3
5993: PUSH
5994: FOR_TO
5995: IFFALSE 6021
// begin PrepareScientist ( false , 10 ) ;
5997: LD_INT 0
5999: PPUSH
6000: LD_INT 10
6002: PPUSH
6003: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6007: CALL_OW 44
6011: PPUSH
6012: LD_INT 1
6014: PPUSH
6015: CALL_OW 52
// end ;
6019: GO 5994
6021: POP
6022: POP
// end ;
6023: LD_VAR 0 1
6027: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6028: LD_EXP 22
6032: PUSH
6033: LD_EXP 2
6037: NOT
6038: AND
6039: IFFALSE 6225
6041: GO 6043
6043: DISABLE
6044: LD_INT 0
6046: PPUSH
6047: PPUSH
6048: PPUSH
// begin enable ;
6049: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6050: LD_ADDR_VAR 0 3
6054: PUSH
6055: LD_INT 204
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 165
6067: PUSH
6068: LD_INT 24
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PUSH
6075: LD_INT 195
6077: PUSH
6078: LD_INT 6
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: LD_INT 223
6087: PUSH
6088: LD_INT 54
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 214
6097: PUSH
6098: LD_INT 84
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 206
6107: PUSH
6108: LD_INT 71
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: ST_TO_ADDR
// for i in guards do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: LD_EXP 22
6132: PUSH
6133: FOR_IN
6134: IFFALSE 6223
// begin if HasTask ( i ) then
6136: LD_VAR 0 1
6140: PPUSH
6141: CALL_OW 314
6145: IFFALSE 6151
// continue else
6147: GO 6133
6149: GO 6221
// begin j := rand ( 1 , 6 ) ;
6151: LD_ADDR_VAR 0 2
6155: PUSH
6156: LD_INT 1
6158: PPUSH
6159: LD_INT 6
6161: PPUSH
6162: CALL_OW 12
6166: ST_TO_ADDR
// if not See ( 7 , i ) then
6167: LD_INT 7
6169: PPUSH
6170: LD_VAR 0 1
6174: PPUSH
6175: CALL_OW 292
6179: NOT
6180: IFFALSE 6221
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6182: LD_VAR 0 1
6186: PPUSH
6187: LD_VAR 0 3
6191: PUSH
6192: LD_VAR 0 2
6196: ARRAY
6197: PUSH
6198: LD_INT 1
6200: ARRAY
6201: PPUSH
6202: LD_VAR 0 3
6206: PUSH
6207: LD_VAR 0 2
6211: ARRAY
6212: PUSH
6213: LD_INT 2
6215: ARRAY
6216: PPUSH
6217: CALL_OW 114
// end ; end ;
6221: GO 6133
6223: POP
6224: POP
// end ;
6225: PPOPN 3
6227: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6228: LD_EXP 23
6232: PUSH
6233: LD_EXP 7
6237: NOT
6238: AND
6239: IFFALSE 6310
6241: GO 6243
6243: DISABLE
6244: LD_INT 0
6246: PPUSH
// begin enable ;
6247: ENABLE
// for i in vehGuard do
6248: LD_ADDR_VAR 0 1
6252: PUSH
6253: LD_EXP 23
6257: PUSH
6258: FOR_IN
6259: IFFALSE 6308
// if IsOk ( vehGuard ) then
6261: LD_EXP 23
6265: PPUSH
6266: CALL_OW 302
6270: IFFALSE 6306
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 22
6279: PUSH
6280: LD_INT 7
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 74
6301: PPUSH
6302: CALL_OW 115
6306: GO 6258
6308: POP
6309: POP
// end ;
6310: PPOPN 1
6312: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6313: LD_EXP 4
6317: PUSH
6318: LD_INT 43
6320: PPUSH
6321: CALL_OW 302
6325: AND
6326: PUSH
6327: LD_EXP 7
6331: NOT
6332: AND
6333: IFFALSE 6381
6335: GO 6337
6337: DISABLE
// begin enable ;
6338: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6339: LD_INT 43
6341: PPUSH
6342: LD_INT 5
6344: PPUSH
6345: LD_INT 3
6347: PPUSH
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 7
6353: PUSH
6354: LD_INT 7
6356: PUSH
6357: LD_INT 9
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 3
6370: PPUSH
6371: CALL_OW 12
6375: ARRAY
6376: PPUSH
6377: CALL_OW 125
// end ;
6381: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6382: LD_INT 22
6384: PUSH
6385: LD_INT 1
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 25
6394: PUSH
6395: LD_INT 5
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PUSH
6402: LD_INT 50
6404: PUSH
6405: EMPTY
6406: LIST
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: LD_EXP 7
6422: NOT
6423: AND
6424: IFFALSE 6653
6426: GO 6428
6428: DISABLE
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
// begin enable ;
6433: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6434: LD_ADDR_VAR 0 1
6438: PUSH
6439: LD_INT 22
6441: PUSH
6442: LD_INT 1
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 25
6451: PUSH
6452: LD_INT 5
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 50
6461: PUSH
6462: EMPTY
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PPUSH
6470: CALL_OW 69
6474: ST_TO_ADDR
// if not tmp then
6475: LD_VAR 0 1
6479: NOT
6480: IFFALSE 6484
// exit ;
6482: GO 6653
// b := IsInUnit ( tmp [ 1 ] ) ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_VAR 0 1
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 310
6502: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6503: LD_VAR 0 2
6507: NOT
6508: PUSH
6509: LD_VAR 0 1
6513: PUSH
6514: LD_INT 1
6516: ARRAY
6517: PPUSH
6518: CALL_OW 314
6522: OR
6523: IFFALSE 6527
// exit ;
6525: GO 6653
// if b = us_bun1 then
6527: LD_VAR 0 2
6531: PUSH
6532: LD_INT 80
6534: EQUAL
6535: IFFALSE 6596
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6537: LD_VAR 0 1
6541: PUSH
6542: LD_INT 1
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6550: LD_VAR 0 1
6554: PUSH
6555: LD_INT 1
6557: ARRAY
6558: PPUSH
6559: LD_INT 27
6561: PPUSH
6562: LD_INT 44
6564: PPUSH
6565: CALL_OW 174
// if IsOk ( us_bun2 ) then
6569: LD_INT 55
6571: PPUSH
6572: CALL_OW 302
6576: IFFALSE 6594
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6578: LD_VAR 0 1
6582: PUSH
6583: LD_INT 1
6585: ARRAY
6586: PPUSH
6587: LD_INT 55
6589: PPUSH
6590: CALL_OW 180
// end else
6594: GO 6653
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6609: LD_VAR 0 1
6613: PUSH
6614: LD_INT 1
6616: ARRAY
6617: PPUSH
6618: LD_INT 92
6620: PPUSH
6621: LD_INT 51
6623: PPUSH
6624: CALL_OW 174
// if IsOk ( us_bun1 ) then
6628: LD_INT 80
6630: PPUSH
6631: CALL_OW 302
6635: IFFALSE 6653
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6637: LD_VAR 0 1
6641: PUSH
6642: LD_INT 1
6644: ARRAY
6645: PPUSH
6646: LD_INT 80
6648: PPUSH
6649: CALL_OW 180
// end ; end ;
6653: PPOPN 2
6655: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6656: LD_EXP 7
6660: NOT
6661: PUSH
6662: LD_INT 9
6664: PPUSH
6665: LD_INT 22
6667: PUSH
6668: LD_INT 1
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: LD_INT 21
6677: PUSH
6678: LD_INT 3
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 3
6687: PUSH
6688: LD_INT 24
6690: PUSH
6691: LD_INT 1000
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 70
6711: AND
6712: IFFALSE 7123
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
// begin enable ;
6723: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 22
6731: PUSH
6732: LD_INT 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 25
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: LD_INT 1000
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: PPUSH
6764: CALL_OW 69
6768: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6769: LD_ADDR_VAR 0 3
6773: PUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 25
6786: PUSH
6787: LD_INT 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 24
6799: PUSH
6800: LD_INT 750
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6821: LD_ADDR_VAR 0 4
6825: PUSH
6826: LD_INT 9
6828: PPUSH
6829: LD_INT 22
6831: PUSH
6832: LD_INT 1
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 24
6854: PUSH
6855: LD_INT 1000
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: PPUSH
6871: CALL_OW 70
6875: PUSH
6876: LD_INT 1
6878: DIFF
6879: ST_TO_ADDR
// if not tmp and not tmp2 then
6880: LD_VAR 0 2
6884: NOT
6885: PUSH
6886: LD_VAR 0 3
6890: NOT
6891: AND
6892: IFFALSE 6896
// exit ;
6894: GO 7123
// if tmp and b then
6896: LD_VAR 0 2
6900: PUSH
6901: LD_VAR 0 4
6905: AND
6906: IFFALSE 7036
// for i in tmp do
6908: LD_ADDR_VAR 0 1
6912: PUSH
6913: LD_VAR 0 2
6917: PUSH
6918: FOR_IN
6919: IFFALSE 7034
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6921: LD_VAR 0 1
6925: PPUSH
6926: CALL_OW 110
6930: PUSH
6931: LD_INT 1
6933: EQUAL
6934: PUSH
6935: LD_VAR 0 1
6939: PPUSH
6940: CALL_OW 256
6944: PUSH
6945: LD_INT 1000
6947: LESS
6948: AND
6949: IFFALSE 6955
// continue else
6951: GO 6918
6953: GO 6982
// if GetTag ( i ) = 1 then
6955: LD_VAR 0 1
6959: PPUSH
6960: CALL_OW 110
6964: PUSH
6965: LD_INT 1
6967: EQUAL
6968: IFFALSE 6982
// SetTag ( i , 0 ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_INT 0
6977: PPUSH
6978: CALL_OW 109
// if IsInUnit ( i ) then
6982: LD_VAR 0 1
6986: PPUSH
6987: CALL_OW 310
6991: IFFALSE 7002
// ComExitBuilding ( i ) ;
6993: LD_VAR 0 1
6997: PPUSH
6998: CALL_OW 122
// if not HasTask ( i ) then
7002: LD_VAR 0 1
7006: PPUSH
7007: CALL_OW 314
7011: NOT
7012: IFFALSE 7032
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_VAR 0 4
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: CALL_OW 190
// end ;
7032: GO 6918
7034: POP
7035: POP
// if tmp2 then
7036: LD_VAR 0 3
7040: IFFALSE 7123
// for i in tmp2 do
7042: LD_ADDR_VAR 0 1
7046: PUSH
7047: LD_VAR 0 3
7051: PUSH
7052: FOR_IN
7053: IFFALSE 7121
// begin if not GetTag ( i ) = 1 then
7055: LD_VAR 0 1
7059: PPUSH
7060: CALL_OW 110
7064: PUSH
7065: LD_INT 1
7067: EQUAL
7068: NOT
7069: IFFALSE 7083
// SetTag ( i , 1 ) ;
7071: LD_VAR 0 1
7075: PPUSH
7076: LD_INT 1
7078: PPUSH
7079: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7083: LD_VAR 0 1
7087: PPUSH
7088: LD_INT 88
7090: PPUSH
7091: LD_INT 75
7093: PPUSH
7094: CALL_OW 297
7098: PUSH
7099: LD_INT 6
7101: GREATER
7102: IFFALSE 7119
// ComMoveXY ( i , 88 , 75 ) ;
7104: LD_VAR 0 1
7108: PPUSH
7109: LD_INT 88
7111: PPUSH
7112: LD_INT 75
7114: PPUSH
7115: CALL_OW 111
// end ;
7119: GO 7052
7121: POP
7122: POP
// end ;
7123: PPOPN 4
7125: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7126: LD_EXP 7
7130: NOT
7131: PUSH
7132: LD_EXP 9
7136: AND
7137: PUSH
7138: LD_INT 9
7140: PPUSH
7141: LD_INT 22
7143: PUSH
7144: LD_INT 1
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 21
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 3
7163: PUSH
7164: LD_INT 24
7166: PUSH
7167: LD_INT 1000
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL_OW 70
7187: AND
7188: IFFALSE 7361
7190: GO 7192
7192: DISABLE
7193: LD_INT 0
7195: PPUSH
7196: PPUSH
7197: PPUSH
// begin enable ;
7198: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7199: LD_ADDR_VAR 0 2
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_INT 1
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 25
7216: PUSH
7217: LD_INT 4
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: PPUSH
7228: CALL_OW 69
7232: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_INT 9
7240: PPUSH
7241: LD_INT 22
7243: PUSH
7244: LD_INT 1
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: LD_INT 21
7253: PUSH
7254: LD_INT 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 3
7263: PUSH
7264: LD_INT 24
7266: PUSH
7267: LD_INT 1000
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: PPUSH
7283: CALL_OW 70
7287: ST_TO_ADDR
// if not sci or not tmp then
7288: LD_VAR 0 2
7292: NOT
7293: PUSH
7294: LD_VAR 0 3
7298: NOT
7299: OR
7300: IFFALSE 7304
// exit ;
7302: GO 7361
// for i in sci do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: LD_VAR 0 2
7313: PUSH
7314: FOR_IN
7315: IFFALSE 7359
// if IsInUnit ( i ) then
7317: LD_VAR 0 1
7321: PPUSH
7322: CALL_OW 310
7326: IFFALSE 7339
// ComExitBuilding ( i ) else
7328: LD_VAR 0 1
7332: PPUSH
7333: CALL_OW 122
7337: GO 7357
// ComHeal ( i , tmp [ 1 ] ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 1
7351: ARRAY
7352: PPUSH
7353: CALL_OW 128
7357: GO 7314
7359: POP
7360: POP
// end ;
7361: PPOPN 3
7363: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7364: LD_EXP 7
7368: NOT
7369: PUSH
7370: LD_EXP 9
7374: AND
7375: PUSH
7376: LD_INT 1
7378: PPUSH
7379: CALL_OW 302
7383: AND
7384: PUSH
7385: LD_INT 9
7387: PPUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 21
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: LD_INT 24
7413: PUSH
7414: LD_INT 1000
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 70
7434: NOT
7435: AND
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 25
7449: PUSH
7450: LD_INT 4
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 56
7459: PUSH
7460: EMPTY
7461: LIST
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: AND
7473: IFFALSE 7566
7475: GO 7477
7477: DISABLE
7478: LD_INT 0
7480: PPUSH
// begin enable ;
7481: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_INT 1
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 4
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 56
7509: PUSH
7510: EMPTY
7511: LIST
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: PPUSH
7518: CALL_OW 69
7522: PUSH
7523: FOR_IN
7524: IFFALSE 7564
// if not GetTag ( i ) and not HasTask ( i ) then
7526: LD_VAR 0 1
7530: PPUSH
7531: CALL_OW 110
7535: NOT
7536: PUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 314
7546: NOT
7547: AND
7548: IFFALSE 7562
// ComEnterUnit ( i , us_lab ) ;
7550: LD_VAR 0 1
7554: PPUSH
7555: LD_INT 1
7557: PPUSH
7558: CALL_OW 120
7562: GO 7523
7564: POP
7565: POP
// end ;
7566: PPOPN 1
7568: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7569: LD_EXP 7
7573: NOT
7574: PUSH
7575: LD_INT 9
7577: PPUSH
7578: LD_INT 22
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: LD_INT 21
7590: PUSH
7591: LD_INT 3
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 24
7603: PUSH
7604: LD_INT 1000
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: PPUSH
7620: CALL_OW 70
7624: NOT
7625: AND
7626: PUSH
7627: LD_INT 22
7629: PUSH
7630: LD_INT 1
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PUSH
7637: LD_INT 25
7639: PUSH
7640: LD_INT 2
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 56
7649: PUSH
7650: EMPTY
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: PPUSH
7658: CALL_OW 69
7662: AND
7663: IFFALSE 7756
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin enable ;
7671: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7672: LD_ADDR_VAR 0 1
7676: PUSH
7677: LD_INT 22
7679: PUSH
7680: LD_INT 1
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 25
7689: PUSH
7690: LD_INT 2
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: LD_INT 56
7699: PUSH
7700: EMPTY
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: PPUSH
7708: CALL_OW 69
7712: PUSH
7713: FOR_IN
7714: IFFALSE 7754
// if not HasTask ( i ) and not GetTag ( i ) then
7716: LD_VAR 0 1
7720: PPUSH
7721: CALL_OW 314
7725: NOT
7726: PUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 110
7736: NOT
7737: AND
7738: IFFALSE 7752
// ComEnterUnit ( i , us_depot ) ;
7740: LD_VAR 0 1
7744: PPUSH
7745: LD_INT 5
7747: PPUSH
7748: CALL_OW 120
7752: GO 7713
7754: POP
7755: POP
// end ;
7756: PPOPN 1
7758: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7759: LD_EXP 9
7763: PUSH
7764: LD_INT 0
7766: LESSEQUAL
7767: PUSH
7768: LD_EXP 18
7772: PPUSH
7773: CALL_OW 301
7777: OR
7778: PUSH
7779: LD_INT 22
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PUSH
7789: LD_INT 25
7791: PUSH
7792: LD_INT 2
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 69
7807: AND
7808: IFFALSE 7849
7810: GO 7812
7812: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7813: LD_INT 22
7815: PUSH
7816: LD_INT 1
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PUSH
7823: LD_INT 25
7825: PUSH
7826: LD_INT 2
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 69
7841: PPUSH
7842: LD_INT 1
7844: PPUSH
7845: CALL_OW 167
7849: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7850: LD_EXP 7
7854: NOT
7855: PUSH
7856: LD_INT 7
7858: PPUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 7
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 70
7873: AND
7874: IFFALSE 7965
7876: GO 7878
7878: DISABLE
7879: LD_INT 0
7881: PPUSH
// begin wait ( 0 0$2 ) ;
7882: LD_INT 70
7884: PPUSH
7885: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7889: LD_ADDR_VAR 0 1
7893: PUSH
7894: LD_INT 22
7896: PUSH
7897: LD_INT 1
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: PUSH
7904: LD_INT 25
7906: PUSH
7907: LD_INT 1
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 69
7922: PUSH
7923: FOR_IN
7924: IFFALSE 7963
// begin if IsInUnit ( i ) then
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 310
7935: IFFALSE 7946
// ComExitBuilding ( i ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_INT 92
7953: PPUSH
7954: LD_INT 78
7956: PPUSH
7957: CALL_OW 174
// end ;
7961: GO 7923
7963: POP
7964: POP
// end ; end_of_file
7965: PPOPN 1
7967: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7968: LD_VAR 0 1
7972: PPUSH
7973: LD_VAR 0 2
7977: PPUSH
7978: LD_VAR 0 3
7982: PPUSH
7983: CALL 2823 0 3
7987: PPOPN 3
7989: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7990: LD_EXP 14
7994: PPUSH
7995: CALL_OW 257
7999: PUSH
8000: LD_INT 4
8002: EQUAL
8003: PUSH
8004: LD_EXP 15
8008: PPUSH
8009: CALL_OW 257
8013: PUSH
8014: LD_INT 4
8016: EQUAL
8017: OR
8018: IFFALSE 8022
// exit ;
8020: GO 8060
// if un = JMM then
8022: LD_VAR 0 1
8026: PUSH
8027: LD_EXP 14
8031: EQUAL
8032: IFFALSE 8041
// YouLost ( JMM ) ;
8034: LD_STRING JMM
8036: PPUSH
8037: CALL_OW 104
// if un = Burlak then
8041: LD_VAR 0 1
8045: PUSH
8046: LD_EXP 15
8050: EQUAL
8051: IFFALSE 8060
// YouLost ( Burlak ) ;
8053: LD_STRING Burlak
8055: PPUSH
8056: CALL_OW 104
// end ;
8060: PPOPN 1
8062: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8063: LD_VAR 0 1
8067: PUSH
8068: LD_EXP 14
8072: EQUAL
8073: IFFALSE 8082
// YouLost ( JMM ) ;
8075: LD_STRING JMM
8077: PPUSH
8078: CALL_OW 104
// if un = Burlak then
8082: LD_VAR 0 1
8086: PUSH
8087: LD_EXP 15
8091: EQUAL
8092: IFFALSE 8101
// YouLost ( Burlak ) ;
8094: LD_STRING Burlak
8096: PPUSH
8097: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8101: LD_VAR 0 1
8105: PUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 1
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 23
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PPUSH
8130: CALL_OW 69
8134: IN
8135: IFFALSE 8151
// killCounter := killCounter + 1 ;
8137: LD_ADDR_EXP 12
8141: PUSH
8142: LD_EXP 12
8146: PUSH
8147: LD_INT 1
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: PPOPN 1
8153: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8154: LD_VAR 0 2
8158: PUSH
8159: LD_INT 7
8161: EQUAL
8162: PUSH
8163: LD_VAR 0 1
8167: PUSH
8168: LD_INT 2
8170: PUSH
8171: LD_INT 30
8173: PUSH
8174: LD_INT 31
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 30
8183: PUSH
8184: LD_INT 32
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 30
8193: PUSH
8194: LD_INT 33
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 69
8211: IN
8212: AND
8213: IFFALSE 8229
// bunkerCounter := bunkerCounter + 1 ;
8215: LD_ADDR_EXP 13
8219: PUSH
8220: LD_EXP 13
8224: PUSH
8225: LD_INT 1
8227: PLUS
8228: ST_TO_ADDR
// end ;
8229: PPOPN 3
8231: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8232: LD_VAR 0 1
8236: PPUSH
8237: CALL_OW 255
8241: PUSH
8242: LD_INT 7
8244: EQUAL
8245: IFFALSE 8255
// artifactPickedUp := true ;
8247: LD_ADDR_EXP 6
8251: PUSH
8252: LD_INT 1
8254: ST_TO_ADDR
// end ;
8255: PPOPN 2
8257: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8258: LD_ADDR_EXP 6
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
8266: PPOPN 2
8268: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 255
8278: PUSH
8279: LD_INT 1
8281: NONEQUAL
8282: IFFALSE 8286
// exit ;
8284: GO 8333
// wait ( 0 0$5 ) ;
8286: LD_INT 175
8288: PPUSH
8289: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 263
8302: PUSH
8303: LD_INT 2
8305: EQUAL
8306: IFFALSE 8317
// Connect ( vehicle ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL 1824 0 1
// vehGuard := vehGuard ^ vehicle ;
8317: LD_ADDR_EXP 23
8321: PUSH
8322: LD_EXP 23
8326: PUSH
8327: LD_VAR 0 1
8331: ADD
8332: ST_TO_ADDR
// end ;
8333: PPOPN 2
8335: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8336: LD_VAR 0 1
8340: PUSH
8341: LD_INT 1
8343: EQUAL
8344: PUSH
8345: LD_EXP 7
8349: NOT
8350: AND
8351: IFFALSE 8386
// begin planCaptured := true ;
8353: LD_ADDR_EXP 7
8357: PUSH
8358: LD_INT 1
8360: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8361: LD_STRING MEnd
8363: PPUSH
8364: CALL_OW 337
// canEnd := true ;
8368: LD_ADDR_EXP 10
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// missionTime := tick ;
8376: LD_ADDR_EXP 11
8380: PUSH
8381: LD_OWVAR 1
8385: ST_TO_ADDR
// end ; end ;
8386: PPOPN 3
8388: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL 13301 0 1
// end ; end_of_file
8398: PPOPN 1
8400: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8401: GO 8403
8403: DISABLE
// begin ru_radar := 98 ;
8404: LD_ADDR_EXP 24
8408: PUSH
8409: LD_INT 98
8411: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8412: LD_ADDR_EXP 25
8416: PUSH
8417: LD_INT 89
8419: ST_TO_ADDR
// us_hack := 99 ;
8420: LD_ADDR_EXP 26
8424: PUSH
8425: LD_INT 99
8427: ST_TO_ADDR
// us_artillery := 97 ;
8428: LD_ADDR_EXP 27
8432: PUSH
8433: LD_INT 97
8435: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8436: LD_ADDR_EXP 28
8440: PUSH
8441: LD_INT 91
8443: ST_TO_ADDR
// end ; end_of_file end_of_file
8444: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
8445: GO 8447
8447: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8448: LD_STRING initStreamRollete();
8450: PPUSH
8451: CALL_OW 559
// InitStreamMode ;
8455: CALL 8460 0 0
// end ;
8459: END
// function InitStreamMode ; begin
8460: LD_INT 0
8462: PPUSH
// streamModeActive := false ;
8463: LD_ADDR_EXP 29
8467: PUSH
8468: LD_INT 0
8470: ST_TO_ADDR
// sRocket := false ;
8471: LD_ADDR_EXP 32
8475: PUSH
8476: LD_INT 0
8478: ST_TO_ADDR
// sSpeed := false ;
8479: LD_ADDR_EXP 31
8483: PUSH
8484: LD_INT 0
8486: ST_TO_ADDR
// sEngine := false ;
8487: LD_ADDR_EXP 33
8491: PUSH
8492: LD_INT 0
8494: ST_TO_ADDR
// sSpec := false ;
8495: LD_ADDR_EXP 30
8499: PUSH
8500: LD_INT 0
8502: ST_TO_ADDR
// sLevel := false ;
8503: LD_ADDR_EXP 34
8507: PUSH
8508: LD_INT 0
8510: ST_TO_ADDR
// sArmoury := false ;
8511: LD_ADDR_EXP 35
8515: PUSH
8516: LD_INT 0
8518: ST_TO_ADDR
// sRadar := false ;
8519: LD_ADDR_EXP 36
8523: PUSH
8524: LD_INT 0
8526: ST_TO_ADDR
// sBunker := false ;
8527: LD_ADDR_EXP 37
8531: PUSH
8532: LD_INT 0
8534: ST_TO_ADDR
// sHack := false ;
8535: LD_ADDR_EXP 38
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// sFire := false ;
8543: LD_ADDR_EXP 39
8547: PUSH
8548: LD_INT 0
8550: ST_TO_ADDR
// sRefresh := false ;
8551: LD_ADDR_EXP 40
8555: PUSH
8556: LD_INT 0
8558: ST_TO_ADDR
// sExp := false ;
8559: LD_ADDR_EXP 41
8563: PUSH
8564: LD_INT 0
8566: ST_TO_ADDR
// sDepot := false ;
8567: LD_ADDR_EXP 42
8571: PUSH
8572: LD_INT 0
8574: ST_TO_ADDR
// sFlag := false ;
8575: LD_ADDR_EXP 43
8579: PUSH
8580: LD_INT 0
8582: ST_TO_ADDR
// sKamikadze := false ;
8583: LD_ADDR_EXP 51
8587: PUSH
8588: LD_INT 0
8590: ST_TO_ADDR
// sTroll := false ;
8591: LD_ADDR_EXP 52
8595: PUSH
8596: LD_INT 0
8598: ST_TO_ADDR
// sSlow := false ;
8599: LD_ADDR_EXP 53
8603: PUSH
8604: LD_INT 0
8606: ST_TO_ADDR
// sLack := false ;
8607: LD_ADDR_EXP 54
8611: PUSH
8612: LD_INT 0
8614: ST_TO_ADDR
// sTank := false ;
8615: LD_ADDR_EXP 56
8619: PUSH
8620: LD_INT 0
8622: ST_TO_ADDR
// sRemote := false ;
8623: LD_ADDR_EXP 57
8627: PUSH
8628: LD_INT 0
8630: ST_TO_ADDR
// sPowell := false ;
8631: LD_ADDR_EXP 58
8635: PUSH
8636: LD_INT 0
8638: ST_TO_ADDR
// sTeleport := false ;
8639: LD_ADDR_EXP 61
8643: PUSH
8644: LD_INT 0
8646: ST_TO_ADDR
// sOilTower := false ;
8647: LD_ADDR_EXP 63
8651: PUSH
8652: LD_INT 0
8654: ST_TO_ADDR
// sShovel := false ;
8655: LD_ADDR_EXP 64
8659: PUSH
8660: LD_INT 0
8662: ST_TO_ADDR
// sSheik := false ;
8663: LD_ADDR_EXP 65
8667: PUSH
8668: LD_INT 0
8670: ST_TO_ADDR
// sSold := false ;
8671: LD_ADDR_EXP 44
8675: PUSH
8676: LD_INT 0
8678: ST_TO_ADDR
// sDiff := false ;
8679: LD_ADDR_EXP 45
8683: PUSH
8684: LD_INT 0
8686: ST_TO_ADDR
// sFog := false ;
8687: LD_ADDR_EXP 48
8691: PUSH
8692: LD_INT 0
8694: ST_TO_ADDR
// sReset := false ;
8695: LD_ADDR_EXP 49
8699: PUSH
8700: LD_INT 0
8702: ST_TO_ADDR
// sSun := false ;
8703: LD_ADDR_EXP 50
8707: PUSH
8708: LD_INT 0
8710: ST_TO_ADDR
// sTiger := false ;
8711: LD_ADDR_EXP 46
8715: PUSH
8716: LD_INT 0
8718: ST_TO_ADDR
// sBomb := false ;
8719: LD_ADDR_EXP 47
8723: PUSH
8724: LD_INT 0
8726: ST_TO_ADDR
// sWound := false ;
8727: LD_ADDR_EXP 55
8731: PUSH
8732: LD_INT 0
8734: ST_TO_ADDR
// sBetray := false ;
8735: LD_ADDR_EXP 59
8739: PUSH
8740: LD_INT 0
8742: ST_TO_ADDR
// sContamin := false ;
8743: LD_ADDR_EXP 60
8747: PUSH
8748: LD_INT 0
8750: ST_TO_ADDR
// sOil := false ;
8751: LD_ADDR_EXP 62
8755: PUSH
8756: LD_INT 0
8758: ST_TO_ADDR
// sStu := false ;
8759: LD_ADDR_EXP 66
8763: PUSH
8764: LD_INT 0
8766: ST_TO_ADDR
// end ;
8767: LD_VAR 0 1
8771: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8772: LD_VAR 0 2
8776: PUSH
8777: LD_INT 100
8779: EQUAL
8780: IFFALSE 9477
// begin if not StreamModeActive then
8782: LD_EXP 29
8786: NOT
8787: IFFALSE 8797
// StreamModeActive := true ;
8789: LD_ADDR_EXP 29
8793: PUSH
8794: LD_INT 1
8796: ST_TO_ADDR
// if p3 = 0 then
8797: LD_VAR 0 3
8801: PUSH
8802: LD_INT 0
8804: EQUAL
8805: IFFALSE 8811
// InitStreamMode ;
8807: CALL 8460 0 0
// if p3 = 1 then
8811: LD_VAR 0 3
8815: PUSH
8816: LD_INT 1
8818: EQUAL
8819: IFFALSE 8829
// sRocket := true ;
8821: LD_ADDR_EXP 32
8825: PUSH
8826: LD_INT 1
8828: ST_TO_ADDR
// if p3 = 2 then
8829: LD_VAR 0 3
8833: PUSH
8834: LD_INT 2
8836: EQUAL
8837: IFFALSE 8847
// sSpeed := true ;
8839: LD_ADDR_EXP 31
8843: PUSH
8844: LD_INT 1
8846: ST_TO_ADDR
// if p3 = 3 then
8847: LD_VAR 0 3
8851: PUSH
8852: LD_INT 3
8854: EQUAL
8855: IFFALSE 8865
// sEngine := true ;
8857: LD_ADDR_EXP 33
8861: PUSH
8862: LD_INT 1
8864: ST_TO_ADDR
// if p3 = 4 then
8865: LD_VAR 0 3
8869: PUSH
8870: LD_INT 4
8872: EQUAL
8873: IFFALSE 8883
// sSpec := true ;
8875: LD_ADDR_EXP 30
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// if p3 = 5 then
8883: LD_VAR 0 3
8887: PUSH
8888: LD_INT 5
8890: EQUAL
8891: IFFALSE 8901
// sLevel := true ;
8893: LD_ADDR_EXP 34
8897: PUSH
8898: LD_INT 1
8900: ST_TO_ADDR
// if p3 = 6 then
8901: LD_VAR 0 3
8905: PUSH
8906: LD_INT 6
8908: EQUAL
8909: IFFALSE 8919
// sArmoury := true ;
8911: LD_ADDR_EXP 35
8915: PUSH
8916: LD_INT 1
8918: ST_TO_ADDR
// if p3 = 7 then
8919: LD_VAR 0 3
8923: PUSH
8924: LD_INT 7
8926: EQUAL
8927: IFFALSE 8937
// sRadar := true ;
8929: LD_ADDR_EXP 36
8933: PUSH
8934: LD_INT 1
8936: ST_TO_ADDR
// if p3 = 8 then
8937: LD_VAR 0 3
8941: PUSH
8942: LD_INT 8
8944: EQUAL
8945: IFFALSE 8955
// sBunker := true ;
8947: LD_ADDR_EXP 37
8951: PUSH
8952: LD_INT 1
8954: ST_TO_ADDR
// if p3 = 9 then
8955: LD_VAR 0 3
8959: PUSH
8960: LD_INT 9
8962: EQUAL
8963: IFFALSE 8973
// sHack := true ;
8965: LD_ADDR_EXP 38
8969: PUSH
8970: LD_INT 1
8972: ST_TO_ADDR
// if p3 = 10 then
8973: LD_VAR 0 3
8977: PUSH
8978: LD_INT 10
8980: EQUAL
8981: IFFALSE 8991
// sFire := true ;
8983: LD_ADDR_EXP 39
8987: PUSH
8988: LD_INT 1
8990: ST_TO_ADDR
// if p3 = 11 then
8991: LD_VAR 0 3
8995: PUSH
8996: LD_INT 11
8998: EQUAL
8999: IFFALSE 9009
// sRefresh := true ;
9001: LD_ADDR_EXP 40
9005: PUSH
9006: LD_INT 1
9008: ST_TO_ADDR
// if p3 = 12 then
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 12
9016: EQUAL
9017: IFFALSE 9027
// sExp := true ;
9019: LD_ADDR_EXP 41
9023: PUSH
9024: LD_INT 1
9026: ST_TO_ADDR
// if p3 = 13 then
9027: LD_VAR 0 3
9031: PUSH
9032: LD_INT 13
9034: EQUAL
9035: IFFALSE 9045
// sDepot := true ;
9037: LD_ADDR_EXP 42
9041: PUSH
9042: LD_INT 1
9044: ST_TO_ADDR
// if p3 = 14 then
9045: LD_VAR 0 3
9049: PUSH
9050: LD_INT 14
9052: EQUAL
9053: IFFALSE 9063
// sFlag := true ;
9055: LD_ADDR_EXP 43
9059: PUSH
9060: LD_INT 1
9062: ST_TO_ADDR
// if p3 = 15 then
9063: LD_VAR 0 3
9067: PUSH
9068: LD_INT 15
9070: EQUAL
9071: IFFALSE 9081
// sKamikadze := true ;
9073: LD_ADDR_EXP 51
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// if p3 = 16 then
9081: LD_VAR 0 3
9085: PUSH
9086: LD_INT 16
9088: EQUAL
9089: IFFALSE 9099
// sTroll := true ;
9091: LD_ADDR_EXP 52
9095: PUSH
9096: LD_INT 1
9098: ST_TO_ADDR
// if p3 = 17 then
9099: LD_VAR 0 3
9103: PUSH
9104: LD_INT 17
9106: EQUAL
9107: IFFALSE 9117
// sSlow := true ;
9109: LD_ADDR_EXP 53
9113: PUSH
9114: LD_INT 1
9116: ST_TO_ADDR
// if p3 = 18 then
9117: LD_VAR 0 3
9121: PUSH
9122: LD_INT 18
9124: EQUAL
9125: IFFALSE 9135
// sLack := true ;
9127: LD_ADDR_EXP 54
9131: PUSH
9132: LD_INT 1
9134: ST_TO_ADDR
// if p3 = 19 then
9135: LD_VAR 0 3
9139: PUSH
9140: LD_INT 19
9142: EQUAL
9143: IFFALSE 9153
// sTank := true ;
9145: LD_ADDR_EXP 56
9149: PUSH
9150: LD_INT 1
9152: ST_TO_ADDR
// if p3 = 20 then
9153: LD_VAR 0 3
9157: PUSH
9158: LD_INT 20
9160: EQUAL
9161: IFFALSE 9171
// sRemote := true ;
9163: LD_ADDR_EXP 57
9167: PUSH
9168: LD_INT 1
9170: ST_TO_ADDR
// if p3 = 21 then
9171: LD_VAR 0 3
9175: PUSH
9176: LD_INT 21
9178: EQUAL
9179: IFFALSE 9189
// sPowell := true ;
9181: LD_ADDR_EXP 58
9185: PUSH
9186: LD_INT 1
9188: ST_TO_ADDR
// if p3 = 22 then
9189: LD_VAR 0 3
9193: PUSH
9194: LD_INT 22
9196: EQUAL
9197: IFFALSE 9207
// sTeleport := true ;
9199: LD_ADDR_EXP 61
9203: PUSH
9204: LD_INT 1
9206: ST_TO_ADDR
// if p3 = 23 then
9207: LD_VAR 0 3
9211: PUSH
9212: LD_INT 23
9214: EQUAL
9215: IFFALSE 9225
// sOilTower := true ;
9217: LD_ADDR_EXP 63
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// if p3 = 24 then
9225: LD_VAR 0 3
9229: PUSH
9230: LD_INT 24
9232: EQUAL
9233: IFFALSE 9243
// sShovel := true ;
9235: LD_ADDR_EXP 64
9239: PUSH
9240: LD_INT 1
9242: ST_TO_ADDR
// if p3 = 25 then
9243: LD_VAR 0 3
9247: PUSH
9248: LD_INT 25
9250: EQUAL
9251: IFFALSE 9261
// sSheik := true ;
9253: LD_ADDR_EXP 65
9257: PUSH
9258: LD_INT 1
9260: ST_TO_ADDR
// if p3 = 101 then
9261: LD_VAR 0 3
9265: PUSH
9266: LD_INT 101
9268: EQUAL
9269: IFFALSE 9279
// sSold := true ;
9271: LD_ADDR_EXP 44
9275: PUSH
9276: LD_INT 1
9278: ST_TO_ADDR
// if p3 = 102 then
9279: LD_VAR 0 3
9283: PUSH
9284: LD_INT 102
9286: EQUAL
9287: IFFALSE 9297
// sDiff := true ;
9289: LD_ADDR_EXP 45
9293: PUSH
9294: LD_INT 1
9296: ST_TO_ADDR
// if p3 = 103 then
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 103
9304: EQUAL
9305: IFFALSE 9315
// sFog := true ;
9307: LD_ADDR_EXP 48
9311: PUSH
9312: LD_INT 1
9314: ST_TO_ADDR
// if p3 = 104 then
9315: LD_VAR 0 3
9319: PUSH
9320: LD_INT 104
9322: EQUAL
9323: IFFALSE 9333
// sReset := true ;
9325: LD_ADDR_EXP 49
9329: PUSH
9330: LD_INT 1
9332: ST_TO_ADDR
// if p3 = 105 then
9333: LD_VAR 0 3
9337: PUSH
9338: LD_INT 105
9340: EQUAL
9341: IFFALSE 9351
// sSun := true ;
9343: LD_ADDR_EXP 50
9347: PUSH
9348: LD_INT 1
9350: ST_TO_ADDR
// if p3 = 106 then
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 106
9358: EQUAL
9359: IFFALSE 9369
// sTiger := true ;
9361: LD_ADDR_EXP 46
9365: PUSH
9366: LD_INT 1
9368: ST_TO_ADDR
// if p3 = 107 then
9369: LD_VAR 0 3
9373: PUSH
9374: LD_INT 107
9376: EQUAL
9377: IFFALSE 9387
// sBomb := true ;
9379: LD_ADDR_EXP 47
9383: PUSH
9384: LD_INT 1
9386: ST_TO_ADDR
// if p3 = 108 then
9387: LD_VAR 0 3
9391: PUSH
9392: LD_INT 108
9394: EQUAL
9395: IFFALSE 9405
// sWound := true ;
9397: LD_ADDR_EXP 55
9401: PUSH
9402: LD_INT 1
9404: ST_TO_ADDR
// if p3 = 109 then
9405: LD_VAR 0 3
9409: PUSH
9410: LD_INT 109
9412: EQUAL
9413: IFFALSE 9423
// sBetray := true ;
9415: LD_ADDR_EXP 59
9419: PUSH
9420: LD_INT 1
9422: ST_TO_ADDR
// if p3 = 110 then
9423: LD_VAR 0 3
9427: PUSH
9428: LD_INT 110
9430: EQUAL
9431: IFFALSE 9441
// sContamin := true ;
9433: LD_ADDR_EXP 60
9437: PUSH
9438: LD_INT 1
9440: ST_TO_ADDR
// if p3 = 111 then
9441: LD_VAR 0 3
9445: PUSH
9446: LD_INT 111
9448: EQUAL
9449: IFFALSE 9459
// sOil := true ;
9451: LD_ADDR_EXP 62
9455: PUSH
9456: LD_INT 1
9458: ST_TO_ADDR
// if p3 = 112 then
9459: LD_VAR 0 3
9463: PUSH
9464: LD_INT 112
9466: EQUAL
9467: IFFALSE 9477
// sStu := true ;
9469: LD_ADDR_EXP 66
9473: PUSH
9474: LD_INT 1
9476: ST_TO_ADDR
// end ; end ;
9477: PPOPN 6
9479: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
9480: LD_EXP 29
9484: PUSH
9485: LD_EXP 32
9489: AND
9490: IFFALSE 9614
9492: GO 9494
9494: DISABLE
9495: LD_INT 0
9497: PPUSH
9498: PPUSH
// begin enable ;
9499: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
9500: LD_ADDR_VAR 0 2
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_OWVAR 2
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: LD_INT 2
9519: PUSH
9520: LD_INT 34
9522: PUSH
9523: LD_INT 7
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: PUSH
9530: LD_INT 34
9532: PUSH
9533: LD_INT 45
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 34
9542: PUSH
9543: LD_INT 28
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 34
9552: PUSH
9553: LD_INT 47
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: LIST
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PPUSH
9571: CALL_OW 69
9575: ST_TO_ADDR
// if not tmp then
9576: LD_VAR 0 2
9580: NOT
9581: IFFALSE 9585
// exit ;
9583: GO 9614
// for i in tmp do
9585: LD_ADDR_VAR 0 1
9589: PUSH
9590: LD_VAR 0 2
9594: PUSH
9595: FOR_IN
9596: IFFALSE 9612
// begin SetLives ( i , 0 ) ;
9598: LD_VAR 0 1
9602: PPUSH
9603: LD_INT 0
9605: PPUSH
9606: CALL_OW 234
// end ;
9610: GO 9595
9612: POP
9613: POP
// end ;
9614: PPOPN 2
9616: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
9617: LD_EXP 29
9621: PUSH
9622: LD_EXP 33
9626: AND
9627: IFFALSE 9708
9629: GO 9631
9631: DISABLE
9632: LD_INT 0
9634: PPUSH
9635: PPUSH
// begin enable ;
9636: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
9637: LD_ADDR_VAR 0 2
9641: PUSH
9642: LD_INT 22
9644: PUSH
9645: LD_OWVAR 2
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PUSH
9654: LD_INT 32
9656: PUSH
9657: LD_INT 3
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: ST_TO_ADDR
// if not tmp then
9673: LD_VAR 0 2
9677: NOT
9678: IFFALSE 9682
// exit ;
9680: GO 9708
// for i in tmp do
9682: LD_ADDR_VAR 0 1
9686: PUSH
9687: LD_VAR 0 2
9691: PUSH
9692: FOR_IN
9693: IFFALSE 9706
// begin DestroyUnit ( i ) ;
9695: LD_VAR 0 1
9699: PPUSH
9700: CALL_OW 65
// end ;
9704: GO 9692
9706: POP
9707: POP
// end ;
9708: PPOPN 2
9710: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9711: LD_EXP 29
9715: PUSH
9716: LD_EXP 30
9720: AND
9721: IFFALSE 9814
9723: GO 9725
9725: DISABLE
9726: LD_INT 0
9728: PPUSH
// begin enable ;
9729: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9730: LD_ADDR_VAR 0 1
9734: PUSH
9735: LD_INT 22
9737: PUSH
9738: LD_OWVAR 2
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: PUSH
9747: LD_INT 2
9749: PUSH
9750: LD_INT 25
9752: PUSH
9753: LD_INT 5
9755: PUSH
9756: EMPTY
9757: LIST
9758: LIST
9759: PUSH
9760: LD_INT 25
9762: PUSH
9763: LD_INT 9
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PUSH
9770: LD_INT 25
9772: PUSH
9773: LD_INT 8
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: LIST
9784: LIST
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: PPUSH
9790: CALL_OW 69
9794: PUSH
9795: FOR_IN
9796: IFFALSE 9812
// begin SetClass ( i , 1 ) ;
9798: LD_VAR 0 1
9802: PPUSH
9803: LD_INT 1
9805: PPUSH
9806: CALL_OW 336
// end ;
9810: GO 9795
9812: POP
9813: POP
// end ;
9814: PPOPN 1
9816: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9817: LD_EXP 29
9821: PUSH
9822: LD_EXP 31
9826: AND
9827: PUSH
9828: LD_OWVAR 65
9832: PUSH
9833: LD_INT 7
9835: LESS
9836: AND
9837: IFFALSE 9851
9839: GO 9841
9841: DISABLE
// begin enable ;
9842: ENABLE
// game_speed := 7 ;
9843: LD_ADDR_OWVAR 65
9847: PUSH
9848: LD_INT 7
9850: ST_TO_ADDR
// end ;
9851: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9852: LD_EXP 29
9856: PUSH
9857: LD_EXP 34
9861: AND
9862: IFFALSE 10064
9864: GO 9866
9866: DISABLE
9867: LD_INT 0
9869: PPUSH
9870: PPUSH
9871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9872: LD_ADDR_VAR 0 3
9876: PUSH
9877: LD_INT 81
9879: PUSH
9880: LD_OWVAR 2
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 21
9891: PUSH
9892: LD_INT 1
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 69
9907: ST_TO_ADDR
// if not tmp then
9908: LD_VAR 0 3
9912: NOT
9913: IFFALSE 9917
// exit ;
9915: GO 10064
// if tmp > 5 then
9917: LD_VAR 0 3
9921: PUSH
9922: LD_INT 5
9924: GREATER
9925: IFFALSE 9937
// k := 5 else
9927: LD_ADDR_VAR 0 2
9931: PUSH
9932: LD_INT 5
9934: ST_TO_ADDR
9935: GO 9947
// k := tmp ;
9937: LD_ADDR_VAR 0 2
9941: PUSH
9942: LD_VAR 0 3
9946: ST_TO_ADDR
// for i := 1 to k do
9947: LD_ADDR_VAR 0 1
9951: PUSH
9952: DOUBLE
9953: LD_INT 1
9955: DEC
9956: ST_TO_ADDR
9957: LD_VAR 0 2
9961: PUSH
9962: FOR_TO
9963: IFFALSE 10062
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9965: LD_VAR 0 3
9969: PUSH
9970: LD_VAR 0 1
9974: ARRAY
9975: PPUSH
9976: LD_VAR 0 1
9980: PUSH
9981: LD_INT 4
9983: MOD
9984: PUSH
9985: LD_INT 1
9987: PLUS
9988: PPUSH
9989: CALL_OW 259
9993: PUSH
9994: LD_INT 10
9996: LESS
9997: IFFALSE 10060
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9999: LD_VAR 0 3
10003: PUSH
10004: LD_VAR 0 1
10008: ARRAY
10009: PPUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_INT 4
10017: MOD
10018: PUSH
10019: LD_INT 1
10021: PLUS
10022: PPUSH
10023: LD_VAR 0 3
10027: PUSH
10028: LD_VAR 0 1
10032: ARRAY
10033: PPUSH
10034: LD_VAR 0 1
10038: PUSH
10039: LD_INT 4
10041: MOD
10042: PUSH
10043: LD_INT 1
10045: PLUS
10046: PPUSH
10047: CALL_OW 259
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: PPUSH
10056: CALL_OW 237
10060: GO 9962
10062: POP
10063: POP
// end ;
10064: PPOPN 3
10066: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
10067: LD_EXP 29
10071: PUSH
10072: LD_EXP 35
10076: AND
10077: IFFALSE 10097
10079: GO 10081
10081: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
10082: LD_INT 4
10084: PPUSH
10085: LD_OWVAR 2
10089: PPUSH
10090: LD_INT 0
10092: PPUSH
10093: CALL_OW 324
10097: END
// every 0 0$1 trigger StreamModeActive and sShovel do
10098: LD_EXP 29
10102: PUSH
10103: LD_EXP 64
10107: AND
10108: IFFALSE 10128
10110: GO 10112
10112: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
10113: LD_INT 19
10115: PPUSH
10116: LD_OWVAR 2
10120: PPUSH
10121: LD_INT 0
10123: PPUSH
10124: CALL_OW 324
10128: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
10129: LD_EXP 29
10133: PUSH
10134: LD_EXP 36
10138: AND
10139: IFFALSE 10238
10141: GO 10143
10143: DISABLE
10144: LD_INT 0
10146: PPUSH
10147: PPUSH
// begin enable ;
10148: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
10149: LD_ADDR_VAR 0 2
10153: PUSH
10154: LD_INT 22
10156: PUSH
10157: LD_OWVAR 2
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: PUSH
10166: LD_INT 2
10168: PUSH
10169: LD_INT 34
10171: PUSH
10172: LD_INT 11
10174: PUSH
10175: EMPTY
10176: LIST
10177: LIST
10178: PUSH
10179: LD_INT 34
10181: PUSH
10182: LD_INT 30
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: LIST
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PPUSH
10198: CALL_OW 69
10202: ST_TO_ADDR
// if not tmp then
10203: LD_VAR 0 2
10207: NOT
10208: IFFALSE 10212
// exit ;
10210: GO 10238
// for i in tmp do
10212: LD_ADDR_VAR 0 1
10216: PUSH
10217: LD_VAR 0 2
10221: PUSH
10222: FOR_IN
10223: IFFALSE 10236
// begin DestroyUnit ( i ) ;
10225: LD_VAR 0 1
10229: PPUSH
10230: CALL_OW 65
// end ;
10234: GO 10222
10236: POP
10237: POP
// end ;
10238: PPOPN 2
10240: END
// every 0 0$1 trigger StreamModeActive and sBunker do
10241: LD_EXP 29
10245: PUSH
10246: LD_EXP 37
10250: AND
10251: IFFALSE 10271
10253: GO 10255
10255: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
10256: LD_INT 32
10258: PPUSH
10259: LD_OWVAR 2
10263: PPUSH
10264: LD_INT 0
10266: PPUSH
10267: CALL_OW 324
10271: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
10272: LD_EXP 29
10276: PUSH
10277: LD_EXP 38
10281: AND
10282: IFFALSE 10463
10284: GO 10286
10286: DISABLE
10287: LD_INT 0
10289: PPUSH
10290: PPUSH
10291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
10292: LD_ADDR_VAR 0 2
10296: PUSH
10297: LD_INT 22
10299: PUSH
10300: LD_OWVAR 2
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: PUSH
10309: LD_INT 33
10311: PUSH
10312: LD_INT 3
10314: PUSH
10315: EMPTY
10316: LIST
10317: LIST
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PPUSH
10323: CALL_OW 69
10327: ST_TO_ADDR
// if not tmp then
10328: LD_VAR 0 2
10332: NOT
10333: IFFALSE 10337
// exit ;
10335: GO 10463
// side := 0 ;
10337: LD_ADDR_VAR 0 3
10341: PUSH
10342: LD_INT 0
10344: ST_TO_ADDR
// for i := 1 to 8 do
10345: LD_ADDR_VAR 0 1
10349: PUSH
10350: DOUBLE
10351: LD_INT 1
10353: DEC
10354: ST_TO_ADDR
10355: LD_INT 8
10357: PUSH
10358: FOR_TO
10359: IFFALSE 10407
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
10361: LD_OWVAR 2
10365: PUSH
10366: LD_VAR 0 1
10370: NONEQUAL
10371: PUSH
10372: LD_OWVAR 2
10376: PPUSH
10377: LD_VAR 0 1
10381: PPUSH
10382: CALL_OW 81
10386: PUSH
10387: LD_INT 2
10389: EQUAL
10390: AND
10391: IFFALSE 10405
// begin side := i ;
10393: LD_ADDR_VAR 0 3
10397: PUSH
10398: LD_VAR 0 1
10402: ST_TO_ADDR
// break ;
10403: GO 10407
// end ;
10405: GO 10358
10407: POP
10408: POP
// if not side then
10409: LD_VAR 0 3
10413: NOT
10414: IFFALSE 10418
// exit ;
10416: GO 10463
// for i := 1 to tmp do
10418: LD_ADDR_VAR 0 1
10422: PUSH
10423: DOUBLE
10424: LD_INT 1
10426: DEC
10427: ST_TO_ADDR
10428: LD_VAR 0 2
10432: PUSH
10433: FOR_TO
10434: IFFALSE 10461
// if Prob ( 30 ) then
10436: LD_INT 30
10438: PPUSH
10439: CALL_OW 13
10443: IFFALSE 10459
// SetSide ( i , side ) ;
10445: LD_VAR 0 1
10449: PPUSH
10450: LD_VAR 0 3
10454: PPUSH
10455: CALL_OW 235
10459: GO 10433
10461: POP
10462: POP
// end ;
10463: PPOPN 3
10465: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
10466: LD_EXP 29
10470: PUSH
10471: LD_EXP 40
10475: AND
10476: IFFALSE 10595
10478: GO 10480
10480: DISABLE
10481: LD_INT 0
10483: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
10484: LD_ADDR_VAR 0 1
10488: PUSH
10489: LD_INT 22
10491: PUSH
10492: LD_OWVAR 2
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PUSH
10501: LD_INT 21
10503: PUSH
10504: LD_INT 1
10506: PUSH
10507: EMPTY
10508: LIST
10509: LIST
10510: PUSH
10511: LD_INT 3
10513: PUSH
10514: LD_INT 23
10516: PUSH
10517: LD_INT 0
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: LIST
10532: PPUSH
10533: CALL_OW 69
10537: PUSH
10538: FOR_IN
10539: IFFALSE 10593
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
10541: LD_VAR 0 1
10545: PPUSH
10546: CALL_OW 257
10550: PUSH
10551: LD_INT 1
10553: PUSH
10554: LD_INT 2
10556: PUSH
10557: LD_INT 3
10559: PUSH
10560: LD_INT 4
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: IN
10569: IFFALSE 10591
// SetClass ( un , rand ( 1 , 4 ) ) ;
10571: LD_VAR 0 1
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: LD_INT 4
10581: PPUSH
10582: CALL_OW 12
10586: PPUSH
10587: CALL_OW 336
10591: GO 10538
10593: POP
10594: POP
// end ;
10595: PPOPN 1
10597: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
10598: LD_EXP 29
10602: PUSH
10603: LD_EXP 39
10607: AND
10608: IFFALSE 10687
10610: GO 10612
10612: DISABLE
10613: LD_INT 0
10615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10616: LD_ADDR_VAR 0 1
10620: PUSH
10621: LD_INT 22
10623: PUSH
10624: LD_OWVAR 2
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 21
10635: PUSH
10636: LD_INT 3
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: EMPTY
10644: LIST
10645: LIST
10646: PPUSH
10647: CALL_OW 69
10651: ST_TO_ADDR
// if not tmp then
10652: LD_VAR 0 1
10656: NOT
10657: IFFALSE 10661
// exit ;
10659: GO 10687
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
10661: LD_VAR 0 1
10665: PUSH
10666: LD_INT 1
10668: PPUSH
10669: LD_VAR 0 1
10673: PPUSH
10674: CALL_OW 12
10678: ARRAY
10679: PPUSH
10680: LD_INT 100
10682: PPUSH
10683: CALL_OW 234
// end ;
10687: PPOPN 1
10689: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10690: LD_EXP 29
10694: PUSH
10695: LD_EXP 41
10699: AND
10700: IFFALSE 10798
10702: GO 10704
10704: DISABLE
10705: LD_INT 0
10707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10708: LD_ADDR_VAR 0 1
10712: PUSH
10713: LD_INT 22
10715: PUSH
10716: LD_OWVAR 2
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: LD_INT 21
10727: PUSH
10728: LD_INT 1
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: PPUSH
10739: CALL_OW 69
10743: ST_TO_ADDR
// if not tmp then
10744: LD_VAR 0 1
10748: NOT
10749: IFFALSE 10753
// exit ;
10751: GO 10798
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10753: LD_VAR 0 1
10757: PUSH
10758: LD_INT 1
10760: PPUSH
10761: LD_VAR 0 1
10765: PPUSH
10766: CALL_OW 12
10770: ARRAY
10771: PPUSH
10772: LD_INT 1
10774: PPUSH
10775: LD_INT 4
10777: PPUSH
10778: CALL_OW 12
10782: PPUSH
10783: LD_INT 3000
10785: PPUSH
10786: LD_INT 9000
10788: PPUSH
10789: CALL_OW 12
10793: PPUSH
10794: CALL_OW 492
// end ;
10798: PPOPN 1
10800: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10801: LD_EXP 29
10805: PUSH
10806: LD_EXP 42
10810: AND
10811: IFFALSE 10831
10813: GO 10815
10815: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10816: LD_INT 1
10818: PPUSH
10819: LD_OWVAR 2
10823: PPUSH
10824: LD_INT 0
10826: PPUSH
10827: CALL_OW 324
10831: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10832: LD_EXP 29
10836: PUSH
10837: LD_EXP 43
10841: AND
10842: IFFALSE 10925
10844: GO 10846
10846: DISABLE
10847: LD_INT 0
10849: PPUSH
10850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10851: LD_ADDR_VAR 0 2
10855: PUSH
10856: LD_INT 22
10858: PUSH
10859: LD_OWVAR 2
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: PUSH
10868: LD_INT 21
10870: PUSH
10871: LD_INT 3
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: EMPTY
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 69
10886: ST_TO_ADDR
// if not tmp then
10887: LD_VAR 0 2
10891: NOT
10892: IFFALSE 10896
// exit ;
10894: GO 10925
// for i in tmp do
10896: LD_ADDR_VAR 0 1
10900: PUSH
10901: LD_VAR 0 2
10905: PUSH
10906: FOR_IN
10907: IFFALSE 10923
// SetBLevel ( i , 10 ) ;
10909: LD_VAR 0 1
10913: PPUSH
10914: LD_INT 10
10916: PPUSH
10917: CALL_OW 241
10921: GO 10906
10923: POP
10924: POP
// end ;
10925: PPOPN 2
10927: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
10928: LD_EXP 29
10932: PUSH
10933: LD_EXP 44
10937: AND
10938: IFFALSE 11049
10940: GO 10942
10942: DISABLE
10943: LD_INT 0
10945: PPUSH
10946: PPUSH
10947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10948: LD_ADDR_VAR 0 3
10952: PUSH
10953: LD_INT 22
10955: PUSH
10956: LD_OWVAR 2
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 25
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 69
10983: ST_TO_ADDR
// if not tmp then
10984: LD_VAR 0 3
10988: NOT
10989: IFFALSE 10993
// exit ;
10991: GO 11049
// un := tmp [ rand ( 1 , tmp ) ] ;
10993: LD_ADDR_VAR 0 2
10997: PUSH
10998: LD_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: PPUSH
11006: LD_VAR 0 3
11010: PPUSH
11011: CALL_OW 12
11015: ARRAY
11016: ST_TO_ADDR
// if Crawls ( un ) then
11017: LD_VAR 0 2
11021: PPUSH
11022: CALL_OW 318
11026: IFFALSE 11037
// ComWalk ( un ) ;
11028: LD_VAR 0 2
11032: PPUSH
11033: CALL_OW 138
// SetClass ( un , class_sniper ) ;
11037: LD_VAR 0 2
11041: PPUSH
11042: LD_INT 5
11044: PPUSH
11045: CALL_OW 336
// end ;
11049: PPOPN 3
11051: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
11052: LD_EXP 29
11056: PUSH
11057: LD_EXP 45
11061: AND
11062: PUSH
11063: LD_OWVAR 67
11067: PUSH
11068: LD_INT 3
11070: LESS
11071: AND
11072: IFFALSE 11091
11074: GO 11076
11076: DISABLE
// Difficulty := Difficulty + 1 ;
11077: LD_ADDR_OWVAR 67
11081: PUSH
11082: LD_OWVAR 67
11086: PUSH
11087: LD_INT 1
11089: PLUS
11090: ST_TO_ADDR
11091: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
11092: LD_EXP 29
11096: PUSH
11097: LD_EXP 46
11101: AND
11102: IFFALSE 11205
11104: GO 11106
11106: DISABLE
11107: LD_INT 0
11109: PPUSH
// begin for i := 1 to 5 do
11110: LD_ADDR_VAR 0 1
11114: PUSH
11115: DOUBLE
11116: LD_INT 1
11118: DEC
11119: ST_TO_ADDR
11120: LD_INT 5
11122: PUSH
11123: FOR_TO
11124: IFFALSE 11203
// begin uc_nation := nation_nature ;
11126: LD_ADDR_OWVAR 21
11130: PUSH
11131: LD_INT 0
11133: ST_TO_ADDR
// uc_side := 0 ;
11134: LD_ADDR_OWVAR 20
11138: PUSH
11139: LD_INT 0
11141: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11142: LD_ADDR_OWVAR 29
11146: PUSH
11147: LD_INT 12
11149: PUSH
11150: LD_INT 12
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: ST_TO_ADDR
// hc_agressivity := 20 ;
11157: LD_ADDR_OWVAR 35
11161: PUSH
11162: LD_INT 20
11164: ST_TO_ADDR
// hc_class := class_tiger ;
11165: LD_ADDR_OWVAR 28
11169: PUSH
11170: LD_INT 14
11172: ST_TO_ADDR
// hc_gallery :=  ;
11173: LD_ADDR_OWVAR 33
11177: PUSH
11178: LD_STRING 
11180: ST_TO_ADDR
// hc_name :=  ;
11181: LD_ADDR_OWVAR 26
11185: PUSH
11186: LD_STRING 
11188: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
11189: CALL_OW 44
11193: PPUSH
11194: LD_INT 0
11196: PPUSH
11197: CALL_OW 51
// end ;
11201: GO 11123
11203: POP
11204: POP
// end ;
11205: PPOPN 1
11207: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
11208: LD_EXP 29
11212: PUSH
11213: LD_EXP 47
11217: AND
11218: IFFALSE 11392
11220: GO 11222
11222: DISABLE
11223: LD_INT 0
11225: PPUSH
11226: PPUSH
11227: PPUSH
11228: PPUSH
// begin result := false ;
11229: LD_ADDR_VAR 0 4
11233: PUSH
11234: LD_INT 0
11236: ST_TO_ADDR
// for i := 1 to 8 do
11237: LD_ADDR_VAR 0 1
11241: PUSH
11242: DOUBLE
11243: LD_INT 1
11245: DEC
11246: ST_TO_ADDR
11247: LD_INT 8
11249: PUSH
11250: FOR_TO
11251: IFFALSE 11362
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
11253: LD_ADDR_VAR 0 2
11257: PUSH
11258: LD_INT 10
11260: PUSH
11261: LD_INT 50
11263: PUSH
11264: LD_INT 90
11266: PUSH
11267: LD_INT 140
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: PUSH
11276: LD_INT 1
11278: PPUSH
11279: LD_INT 4
11281: PPUSH
11282: CALL_OW 12
11286: ARRAY
11287: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
11288: LD_ADDR_VAR 0 3
11292: PUSH
11293: LD_INT 10
11295: PUSH
11296: LD_INT 50
11298: PUSH
11299: LD_INT 90
11301: PUSH
11302: LD_INT 140
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: LD_INT 1
11313: PPUSH
11314: LD_INT 4
11316: PPUSH
11317: CALL_OW 12
11321: ARRAY
11322: ST_TO_ADDR
// if ValidHex ( x , y ) then
11323: LD_VAR 0 2
11327: PPUSH
11328: LD_VAR 0 3
11332: PPUSH
11333: CALL_OW 488
11337: IFFALSE 11360
// begin result := [ x , y ] ;
11339: LD_ADDR_VAR 0 4
11343: PUSH
11344: LD_VAR 0 2
11348: PUSH
11349: LD_VAR 0 3
11353: PUSH
11354: EMPTY
11355: LIST
11356: LIST
11357: ST_TO_ADDR
// break ;
11358: GO 11362
// end ; end ;
11360: GO 11250
11362: POP
11363: POP
// if result then
11364: LD_VAR 0 4
11368: IFFALSE 11392
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
11370: LD_VAR 0 4
11374: PUSH
11375: LD_INT 1
11377: ARRAY
11378: PPUSH
11379: LD_VAR 0 4
11383: PUSH
11384: LD_INT 2
11386: ARRAY
11387: PPUSH
11388: CALL_OW 429
// end ;
11392: PPOPN 4
11394: END
// every 0 0$1 trigger StreamModeActive and sReset do
11395: LD_EXP 29
11399: PUSH
11400: LD_EXP 49
11404: AND
11405: IFFALSE 11417
11407: GO 11409
11409: DISABLE
// YouLost (  ) ;
11410: LD_STRING 
11412: PPUSH
11413: CALL_OW 104
11417: END
// every 0 0$1 trigger StreamModeActive and sFog do
11418: LD_EXP 29
11422: PUSH
11423: LD_EXP 48
11427: AND
11428: IFFALSE 11442
11430: GO 11432
11432: DISABLE
// FogOff ( your_side ) ;
11433: LD_OWVAR 2
11437: PPUSH
11438: CALL_OW 344
11442: END
// every 0 0$1 trigger StreamModeActive and sSun do
11443: LD_EXP 29
11447: PUSH
11448: LD_EXP 50
11452: AND
11453: IFFALSE 11481
11455: GO 11457
11457: DISABLE
// begin solar_recharge_percent := 0 ;
11458: LD_ADDR_OWVAR 79
11462: PUSH
11463: LD_INT 0
11465: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11466: LD_INT 10500
11468: PPUSH
11469: CALL_OW 67
// solar_recharge_percent := 100 ;
11473: LD_ADDR_OWVAR 79
11477: PUSH
11478: LD_INT 100
11480: ST_TO_ADDR
// end ;
11481: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
11482: LD_EXP 29
11486: PUSH
11487: LD_EXP 51
11491: AND
11492: IFFALSE 11731
11494: GO 11496
11496: DISABLE
11497: LD_INT 0
11499: PPUSH
11500: PPUSH
11501: PPUSH
// begin tmp := [ ] ;
11502: LD_ADDR_VAR 0 3
11506: PUSH
11507: EMPTY
11508: ST_TO_ADDR
// for i := 1 to 6 do
11509: LD_ADDR_VAR 0 1
11513: PUSH
11514: DOUBLE
11515: LD_INT 1
11517: DEC
11518: ST_TO_ADDR
11519: LD_INT 6
11521: PUSH
11522: FOR_TO
11523: IFFALSE 11628
// begin uc_nation := nation_nature ;
11525: LD_ADDR_OWVAR 21
11529: PUSH
11530: LD_INT 0
11532: ST_TO_ADDR
// uc_side := 0 ;
11533: LD_ADDR_OWVAR 20
11537: PUSH
11538: LD_INT 0
11540: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11541: LD_ADDR_OWVAR 29
11545: PUSH
11546: LD_INT 12
11548: PUSH
11549: LD_INT 12
11551: PUSH
11552: EMPTY
11553: LIST
11554: LIST
11555: ST_TO_ADDR
// hc_agressivity := 20 ;
11556: LD_ADDR_OWVAR 35
11560: PUSH
11561: LD_INT 20
11563: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11564: LD_ADDR_OWVAR 28
11568: PUSH
11569: LD_INT 17
11571: ST_TO_ADDR
// hc_gallery :=  ;
11572: LD_ADDR_OWVAR 33
11576: PUSH
11577: LD_STRING 
11579: ST_TO_ADDR
// hc_name :=  ;
11580: LD_ADDR_OWVAR 26
11584: PUSH
11585: LD_STRING 
11587: ST_TO_ADDR
// un := CreateHuman ;
11588: LD_ADDR_VAR 0 2
11592: PUSH
11593: CALL_OW 44
11597: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11598: LD_VAR 0 2
11602: PPUSH
11603: LD_INT 1
11605: PPUSH
11606: CALL_OW 51
// tmp := tmp * un ;
11610: LD_ADDR_VAR 0 3
11614: PUSH
11615: LD_VAR 0 3
11619: PUSH
11620: LD_VAR 0 2
11624: MUL
11625: ST_TO_ADDR
// end ;
11626: GO 11522
11628: POP
11629: POP
// repeat wait ( 0 0$1 ) ;
11630: LD_INT 35
11632: PPUSH
11633: CALL_OW 67
// for un in tmp do
11637: LD_ADDR_VAR 0 2
11641: PUSH
11642: LD_VAR 0 3
11646: PUSH
11647: FOR_IN
11648: IFFALSE 11722
// begin if IsDead ( un ) then
11650: LD_VAR 0 2
11654: PPUSH
11655: CALL_OW 301
11659: IFFALSE 11679
// begin tmp := tmp diff un ;
11661: LD_ADDR_VAR 0 3
11665: PUSH
11666: LD_VAR 0 3
11670: PUSH
11671: LD_VAR 0 2
11675: DIFF
11676: ST_TO_ADDR
// continue ;
11677: GO 11647
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11679: LD_VAR 0 2
11683: PPUSH
11684: LD_INT 3
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 0
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PPUSH
11701: CALL_OW 69
11705: PPUSH
11706: LD_VAR 0 2
11710: PPUSH
11711: CALL_OW 74
11715: PPUSH
11716: CALL_OW 115
// end ;
11720: GO 11647
11722: POP
11723: POP
// until not tmp ;
11724: LD_VAR 0 3
11728: NOT
11729: IFFALSE 11630
// end ;
11731: PPOPN 3
11733: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11734: LD_EXP 29
11738: PUSH
11739: LD_EXP 52
11743: AND
11744: IFFALSE 11770
11746: GO 11748
11748: DISABLE
// begin ToLua ( displayTroll(); ) ;
11749: LD_STRING displayTroll();
11751: PPUSH
11752: CALL_OW 559
// wait ( 3 3$00 ) ;
11756: LD_INT 6300
11758: PPUSH
11759: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11763: LD_STRING hideTroll();
11765: PPUSH
11766: CALL_OW 559
// end ;
11770: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11771: LD_EXP 29
11775: PUSH
11776: LD_EXP 53
11780: AND
11781: IFFALSE 11844
11783: GO 11785
11785: DISABLE
11786: LD_INT 0
11788: PPUSH
// begin p := 0 ;
11789: LD_ADDR_VAR 0 1
11793: PUSH
11794: LD_INT 0
11796: ST_TO_ADDR
// repeat game_speed := 1 ;
11797: LD_ADDR_OWVAR 65
11801: PUSH
11802: LD_INT 1
11804: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11805: LD_INT 35
11807: PPUSH
11808: CALL_OW 67
// p := p + 1 ;
11812: LD_ADDR_VAR 0 1
11816: PUSH
11817: LD_VAR 0 1
11821: PUSH
11822: LD_INT 1
11824: PLUS
11825: ST_TO_ADDR
// until p >= 60 ;
11826: LD_VAR 0 1
11830: PUSH
11831: LD_INT 60
11833: GREATEREQUAL
11834: IFFALSE 11797
// game_speed := 4 ;
11836: LD_ADDR_OWVAR 65
11840: PUSH
11841: LD_INT 4
11843: ST_TO_ADDR
// end ;
11844: PPOPN 1
11846: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11847: LD_EXP 29
11851: PUSH
11852: LD_EXP 54
11856: AND
11857: IFFALSE 12003
11859: GO 11861
11861: DISABLE
11862: LD_INT 0
11864: PPUSH
11865: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: LD_INT 22
11873: PUSH
11874: LD_OWVAR 2
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: LD_INT 2
11885: PUSH
11886: LD_INT 30
11888: PUSH
11889: LD_INT 0
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 30
11898: PUSH
11899: LD_INT 1
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: LIST
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PPUSH
11915: CALL_OW 69
11919: ST_TO_ADDR
// if not depot then
11920: LD_VAR 0 1
11924: NOT
11925: IFFALSE 11929
// exit ;
11927: GO 12003
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11929: LD_ADDR_VAR 0 2
11933: PUSH
11934: LD_VAR 0 1
11938: PUSH
11939: LD_INT 1
11941: PPUSH
11942: LD_VAR 0 1
11946: PPUSH
11947: CALL_OW 12
11951: ARRAY
11952: PPUSH
11953: CALL_OW 274
11957: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11958: LD_VAR 0 2
11962: PPUSH
11963: LD_INT 1
11965: PPUSH
11966: LD_INT 0
11968: PPUSH
11969: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11973: LD_VAR 0 2
11977: PPUSH
11978: LD_INT 2
11980: PPUSH
11981: LD_INT 0
11983: PPUSH
11984: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11988: LD_VAR 0 2
11992: PPUSH
11993: LD_INT 3
11995: PPUSH
11996: LD_INT 0
11998: PPUSH
11999: CALL_OW 277
// end ;
12003: PPOPN 2
12005: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
12006: LD_EXP 29
12010: PUSH
12011: LD_EXP 55
12015: AND
12016: IFFALSE 12113
12018: GO 12020
12020: DISABLE
12021: LD_INT 0
12023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12024: LD_ADDR_VAR 0 1
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: LD_OWVAR 2
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: PUSH
12041: LD_INT 21
12043: PUSH
12044: LD_INT 1
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: PUSH
12051: LD_INT 3
12053: PUSH
12054: LD_INT 23
12056: PUSH
12057: LD_INT 0
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: LIST
12072: PPUSH
12073: CALL_OW 69
12077: ST_TO_ADDR
// if not tmp then
12078: LD_VAR 0 1
12082: NOT
12083: IFFALSE 12087
// exit ;
12085: GO 12113
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
12087: LD_VAR 0 1
12091: PUSH
12092: LD_INT 1
12094: PPUSH
12095: LD_VAR 0 1
12099: PPUSH
12100: CALL_OW 12
12104: ARRAY
12105: PPUSH
12106: LD_INT 200
12108: PPUSH
12109: CALL_OW 234
// end ;
12113: PPOPN 1
12115: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
12116: LD_EXP 29
12120: PUSH
12121: LD_EXP 56
12125: AND
12126: IFFALSE 12205
12128: GO 12130
12130: DISABLE
12131: LD_INT 0
12133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 22
12141: PUSH
12142: LD_OWVAR 2
12146: PUSH
12147: EMPTY
12148: LIST
12149: LIST
12150: PUSH
12151: LD_INT 21
12153: PUSH
12154: LD_INT 2
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: PUSH
12161: EMPTY
12162: LIST
12163: LIST
12164: PPUSH
12165: CALL_OW 69
12169: ST_TO_ADDR
// if not tmp then
12170: LD_VAR 0 1
12174: NOT
12175: IFFALSE 12179
// exit ;
12177: GO 12205
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
12179: LD_VAR 0 1
12183: PUSH
12184: LD_INT 1
12186: PPUSH
12187: LD_VAR 0 1
12191: PPUSH
12192: CALL_OW 12
12196: ARRAY
12197: PPUSH
12198: LD_INT 60
12200: PPUSH
12201: CALL_OW 234
// end ;
12205: PPOPN 1
12207: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
12208: LD_EXP 29
12212: PUSH
12213: LD_EXP 57
12217: AND
12218: IFFALSE 12317
12220: GO 12222
12222: DISABLE
12223: LD_INT 0
12225: PPUSH
12226: PPUSH
// begin enable ;
12227: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
12228: LD_ADDR_VAR 0 1
12232: PUSH
12233: LD_INT 22
12235: PUSH
12236: LD_OWVAR 2
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 61
12247: PUSH
12248: EMPTY
12249: LIST
12250: PUSH
12251: LD_INT 33
12253: PUSH
12254: LD_INT 2
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: LIST
12265: PPUSH
12266: CALL_OW 69
12270: ST_TO_ADDR
// if not tmp then
12271: LD_VAR 0 1
12275: NOT
12276: IFFALSE 12280
// exit ;
12278: GO 12317
// for i in tmp do
12280: LD_ADDR_VAR 0 2
12284: PUSH
12285: LD_VAR 0 1
12289: PUSH
12290: FOR_IN
12291: IFFALSE 12315
// if IsControledBy ( i ) then
12293: LD_VAR 0 2
12297: PPUSH
12298: CALL_OW 312
12302: IFFALSE 12313
// ComUnlink ( i ) ;
12304: LD_VAR 0 2
12308: PPUSH
12309: CALL_OW 136
12313: GO 12290
12315: POP
12316: POP
// end ;
12317: PPOPN 2
12319: END
// every 0 0$1 trigger StreamModeActive and sPowell do
12320: LD_EXP 29
12324: PUSH
12325: LD_EXP 58
12329: AND
12330: IFFALSE 12370
12332: GO 12334
12334: DISABLE
// begin ToLua ( displayPowell(); ) ;
12335: LD_STRING displayPowell();
12337: PPUSH
12338: CALL_OW 559
// wait ( 0 0$20 ) ;
12342: LD_INT 700
12344: PPUSH
12345: CALL_OW 67
// ToLua ( displayPowell(); ) ;
12349: LD_STRING displayPowell();
12351: PPUSH
12352: CALL_OW 559
// wait ( 0 0$40 ) ;
12356: LD_INT 1400
12358: PPUSH
12359: CALL_OW 67
// ToLua ( displayPowell(); ) ;
12363: LD_STRING displayPowell();
12365: PPUSH
12366: CALL_OW 559
// end ;
12370: END
// every 0 0$1 trigger StreamModeActive and sStu do
12371: LD_EXP 29
12375: PUSH
12376: LD_EXP 66
12380: AND
12381: IFFALSE 12393
12383: GO 12385
12385: DISABLE
// begin ToLua ( displayStucuk(); ) ;
12386: LD_STRING displayStucuk();
12388: PPUSH
12389: CALL_OW 559
// end ;
12393: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
12394: LD_EXP 29
12398: PUSH
12399: LD_EXP 59
12403: AND
12404: IFFALSE 12545
12406: GO 12408
12408: DISABLE
12409: LD_INT 0
12411: PPUSH
12412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12413: LD_ADDR_VAR 0 2
12417: PUSH
12418: LD_INT 22
12420: PUSH
12421: LD_OWVAR 2
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: PUSH
12430: LD_INT 21
12432: PUSH
12433: LD_INT 1
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PPUSH
12444: CALL_OW 69
12448: ST_TO_ADDR
// if not tmp then
12449: LD_VAR 0 2
12453: NOT
12454: IFFALSE 12458
// exit ;
12456: GO 12545
// un := tmp [ rand ( 1 , tmp ) ] ;
12458: LD_ADDR_VAR 0 1
12462: PUSH
12463: LD_VAR 0 2
12467: PUSH
12468: LD_INT 1
12470: PPUSH
12471: LD_VAR 0 2
12475: PPUSH
12476: CALL_OW 12
12480: ARRAY
12481: ST_TO_ADDR
// SetSide ( un , 0 ) ;
12482: LD_VAR 0 1
12486: PPUSH
12487: LD_INT 0
12489: PPUSH
12490: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
12494: LD_VAR 0 1
12498: PPUSH
12499: LD_OWVAR 3
12503: PUSH
12504: LD_VAR 0 1
12508: DIFF
12509: PPUSH
12510: LD_VAR 0 1
12514: PPUSH
12515: CALL_OW 74
12519: PPUSH
12520: CALL_OW 115
// wait ( 0 0$20 ) ;
12524: LD_INT 700
12526: PPUSH
12527: CALL_OW 67
// SetSide ( un , your_side ) ;
12531: LD_VAR 0 1
12535: PPUSH
12536: LD_OWVAR 2
12540: PPUSH
12541: CALL_OW 235
// end ;
12545: PPOPN 2
12547: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
12548: LD_EXP 29
12552: PUSH
12553: LD_EXP 60
12557: AND
12558: IFFALSE 12664
12560: GO 12562
12562: DISABLE
12563: LD_INT 0
12565: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12566: LD_ADDR_VAR 0 1
12570: PUSH
12571: LD_INT 22
12573: PUSH
12574: LD_OWVAR 2
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PUSH
12583: LD_INT 2
12585: PUSH
12586: LD_INT 30
12588: PUSH
12589: LD_INT 0
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: LD_INT 30
12598: PUSH
12599: LD_INT 1
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: LIST
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PPUSH
12615: CALL_OW 69
12619: ST_TO_ADDR
// if not depot then
12620: LD_VAR 0 1
12624: NOT
12625: IFFALSE 12629
// exit ;
12627: GO 12664
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
12629: LD_VAR 0 1
12633: PUSH
12634: LD_INT 1
12636: ARRAY
12637: PPUSH
12638: CALL_OW 250
12642: PPUSH
12643: LD_VAR 0 1
12647: PUSH
12648: LD_INT 1
12650: ARRAY
12651: PPUSH
12652: CALL_OW 251
12656: PPUSH
12657: LD_INT 70
12659: PPUSH
12660: CALL_OW 495
// end ;
12664: PPOPN 1
12666: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
12667: LD_EXP 29
12671: PUSH
12672: LD_EXP 61
12676: AND
12677: IFFALSE 12888
12679: GO 12681
12681: DISABLE
12682: LD_INT 0
12684: PPUSH
12685: PPUSH
12686: PPUSH
12687: PPUSH
12688: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
12689: LD_ADDR_VAR 0 5
12693: PUSH
12694: LD_INT 22
12696: PUSH
12697: LD_OWVAR 2
12701: PUSH
12702: EMPTY
12703: LIST
12704: LIST
12705: PUSH
12706: LD_INT 21
12708: PUSH
12709: LD_INT 1
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PPUSH
12720: CALL_OW 69
12724: ST_TO_ADDR
// if not tmp then
12725: LD_VAR 0 5
12729: NOT
12730: IFFALSE 12734
// exit ;
12732: GO 12888
// for i in tmp do
12734: LD_ADDR_VAR 0 1
12738: PUSH
12739: LD_VAR 0 5
12743: PUSH
12744: FOR_IN
12745: IFFALSE 12886
// begin d := rand ( 0 , 5 ) ;
12747: LD_ADDR_VAR 0 4
12751: PUSH
12752: LD_INT 0
12754: PPUSH
12755: LD_INT 5
12757: PPUSH
12758: CALL_OW 12
12762: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
12763: LD_ADDR_VAR 0 2
12767: PUSH
12768: LD_VAR 0 1
12772: PPUSH
12773: CALL_OW 250
12777: PPUSH
12778: LD_VAR 0 4
12782: PPUSH
12783: LD_INT 3
12785: PPUSH
12786: LD_INT 12
12788: PPUSH
12789: CALL_OW 12
12793: PPUSH
12794: CALL_OW 272
12798: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
12799: LD_ADDR_VAR 0 3
12803: PUSH
12804: LD_VAR 0 1
12808: PPUSH
12809: CALL_OW 251
12813: PPUSH
12814: LD_VAR 0 4
12818: PPUSH
12819: LD_INT 3
12821: PPUSH
12822: LD_INT 12
12824: PPUSH
12825: CALL_OW 12
12829: PPUSH
12830: CALL_OW 273
12834: ST_TO_ADDR
// if ValidHex ( x , y ) then
12835: LD_VAR 0 2
12839: PPUSH
12840: LD_VAR 0 3
12844: PPUSH
12845: CALL_OW 488
12849: IFFALSE 12884
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
12851: LD_VAR 0 1
12855: PPUSH
12856: LD_VAR 0 2
12860: PPUSH
12861: LD_VAR 0 3
12865: PPUSH
12866: LD_INT 3
12868: PPUSH
12869: LD_INT 6
12871: PPUSH
12872: CALL_OW 12
12876: PPUSH
12877: LD_INT 1
12879: PPUSH
12880: CALL_OW 483
// end ;
12884: GO 12744
12886: POP
12887: POP
// end ;
12888: PPOPN 5
12890: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
12891: LD_EXP 29
12895: PUSH
12896: LD_EXP 62
12900: AND
12901: IFFALSE 12995
12903: GO 12905
12905: DISABLE
12906: LD_INT 0
12908: PPUSH
12909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
12910: LD_ADDR_VAR 0 2
12914: PUSH
12915: LD_INT 22
12917: PUSH
12918: LD_OWVAR 2
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 32
12929: PUSH
12930: LD_INT 1
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PUSH
12937: LD_INT 21
12939: PUSH
12940: LD_INT 2
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: PPUSH
12952: CALL_OW 69
12956: ST_TO_ADDR
// if not tmp then
12957: LD_VAR 0 2
12961: NOT
12962: IFFALSE 12966
// exit ;
12964: GO 12995
// for i in tmp do
12966: LD_ADDR_VAR 0 1
12970: PUSH
12971: LD_VAR 0 2
12975: PUSH
12976: FOR_IN
12977: IFFALSE 12993
// SetFuel ( i , 0 ) ;
12979: LD_VAR 0 1
12983: PPUSH
12984: LD_INT 0
12986: PPUSH
12987: CALL_OW 240
12991: GO 12976
12993: POP
12994: POP
// end ;
12995: PPOPN 2
12997: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
12998: LD_EXP 29
13002: PUSH
13003: LD_EXP 63
13007: AND
13008: IFFALSE 13074
13010: GO 13012
13012: DISABLE
13013: LD_INT 0
13015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
13016: LD_ADDR_VAR 0 1
13020: PUSH
13021: LD_INT 22
13023: PUSH
13024: LD_OWVAR 2
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: LD_INT 30
13035: PUSH
13036: LD_INT 29
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if not tmp then
13052: LD_VAR 0 1
13056: NOT
13057: IFFALSE 13061
// exit ;
13059: GO 13074
// DestroyUnit ( tmp [ 1 ] ) ;
13061: LD_VAR 0 1
13065: PUSH
13066: LD_INT 1
13068: ARRAY
13069: PPUSH
13070: CALL_OW 65
// end ;
13074: PPOPN 1
13076: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
13077: LD_EXP 29
13081: PUSH
13082: LD_EXP 65
13086: AND
13087: IFFALSE 13200
13089: GO 13091
13091: DISABLE
13092: LD_INT 0
13094: PPUSH
// begin uc_side := 0 ;
13095: LD_ADDR_OWVAR 20
13099: PUSH
13100: LD_INT 0
13102: ST_TO_ADDR
// uc_nation := nation_arabian ;
13103: LD_ADDR_OWVAR 21
13107: PUSH
13108: LD_INT 2
13110: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
13111: LD_INT 1
13113: PPUSH
13114: LD_INT 10
13116: PPUSH
13117: LD_INT 11
13119: PPUSH
13120: CALL_OW 380
// un := CreateHuman ;
13124: LD_ADDR_VAR 0 1
13128: PUSH
13129: CALL_OW 44
13133: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
13134: LD_VAR 0 1
13138: PPUSH
13139: LD_INT 1
13141: PPUSH
13142: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
13146: LD_INT 35
13148: PPUSH
13149: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
13153: LD_VAR 0 1
13157: PPUSH
13158: LD_INT 22
13160: PUSH
13161: LD_OWVAR 2
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: PPUSH
13170: CALL_OW 69
13174: PPUSH
13175: LD_VAR 0 1
13179: PPUSH
13180: CALL_OW 74
13184: PPUSH
13185: CALL_OW 115
// until IsDead ( un ) ;
13189: LD_VAR 0 1
13193: PPUSH
13194: CALL_OW 301
13198: IFFALSE 13146
// end ; end_of_file
13200: PPOPN 1
13202: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
13203: LD_INT 0
13205: PPUSH
13206: PPUSH
13207: PPUSH
13208: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
13209: LD_VAR 0 1
13213: PPUSH
13214: CALL_OW 264
13218: PUSH
13219: LD_EXP 28
13223: EQUAL
13224: IFFALSE 13296
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
13226: LD_INT 68
13228: PPUSH
13229: LD_VAR 0 1
13233: PPUSH
13234: CALL_OW 255
13238: PPUSH
13239: CALL_OW 321
13243: PUSH
13244: LD_INT 2
13246: EQUAL
13247: IFFALSE 13259
// eff := 70 else
13249: LD_ADDR_VAR 0 6
13253: PUSH
13254: LD_INT 70
13256: ST_TO_ADDR
13257: GO 13267
// eff := 30 ;
13259: LD_ADDR_VAR 0 6
13263: PUSH
13264: LD_INT 30
13266: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
13267: LD_VAR 0 1
13271: PPUSH
13272: CALL_OW 250
13276: PPUSH
13277: LD_VAR 0 1
13281: PPUSH
13282: CALL_OW 251
13286: PPUSH
13287: LD_VAR 0 6
13291: PPUSH
13292: CALL_OW 495
// end ; end ;
13296: LD_VAR 0 4
13300: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
13301: LD_INT 0
13303: PPUSH
13304: PPUSH
13305: PPUSH
13306: PPUSH
13307: PPUSH
13308: PPUSH
// if cmd = 124 then
13309: LD_VAR 0 1
13313: PUSH
13314: LD_INT 124
13316: EQUAL
13317: IFFALSE 13523
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
13319: LD_ADDR_VAR 0 5
13323: PUSH
13324: LD_INT 2
13326: PUSH
13327: LD_INT 34
13329: PUSH
13330: LD_INT 53
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: PUSH
13337: LD_INT 34
13339: PUSH
13340: LD_INT 14
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: PPUSH
13352: CALL_OW 69
13356: ST_TO_ADDR
// if not tmp then
13357: LD_VAR 0 5
13361: NOT
13362: IFFALSE 13366
// exit ;
13364: GO 13523
// for i in tmp do
13366: LD_ADDR_VAR 0 3
13370: PUSH
13371: LD_VAR 0 5
13375: PUSH
13376: FOR_IN
13377: IFFALSE 13521
// begin taskList := GetTaskList ( i ) ;
13379: LD_ADDR_VAR 0 6
13383: PUSH
13384: LD_VAR 0 3
13388: PPUSH
13389: CALL_OW 437
13393: ST_TO_ADDR
// if not taskList then
13394: LD_VAR 0 6
13398: NOT
13399: IFFALSE 13403
// continue ;
13401: GO 13376
// for j = 1 to taskList do
13403: LD_ADDR_VAR 0 4
13407: PUSH
13408: DOUBLE
13409: LD_INT 1
13411: DEC
13412: ST_TO_ADDR
13413: LD_VAR 0 6
13417: PUSH
13418: FOR_TO
13419: IFFALSE 13517
// if taskList [ j ] [ 1 ] = | then
13421: LD_VAR 0 6
13425: PUSH
13426: LD_VAR 0 4
13430: ARRAY
13431: PUSH
13432: LD_INT 1
13434: ARRAY
13435: PUSH
13436: LD_STRING |
13438: EQUAL
13439: IFFALSE 13515
// begin _taskList := Delete ( taskList , 1 ) ;
13441: LD_ADDR_VAR 0 7
13445: PUSH
13446: LD_VAR 0 6
13450: PPUSH
13451: LD_INT 1
13453: PPUSH
13454: CALL_OW 3
13458: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
13459: LD_VAR 0 3
13463: PPUSH
13464: LD_VAR 0 7
13468: PPUSH
13469: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
13473: LD_VAR 0 3
13477: PPUSH
13478: LD_VAR 0 6
13482: PUSH
13483: LD_VAR 0 4
13487: ARRAY
13488: PUSH
13489: LD_INT 2
13491: ARRAY
13492: PPUSH
13493: LD_VAR 0 6
13497: PUSH
13498: LD_VAR 0 4
13502: ARRAY
13503: PUSH
13504: LD_INT 3
13506: ARRAY
13507: PPUSH
13508: LD_INT 8
13510: PPUSH
13511: CALL 13528 0 4
// end ;
13515: GO 13418
13517: POP
13518: POP
// end ;
13519: GO 13376
13521: POP
13522: POP
// end ; end ;
13523: LD_VAR 0 2
13527: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
13528: LD_INT 0
13530: PPUSH
13531: PPUSH
13532: PPUSH
13533: PPUSH
13534: PPUSH
13535: PPUSH
13536: PPUSH
13537: PPUSH
13538: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
13539: LD_VAR 0 1
13543: NOT
13544: PUSH
13545: LD_VAR 0 2
13549: PPUSH
13550: LD_VAR 0 3
13554: PPUSH
13555: CALL_OW 488
13559: NOT
13560: OR
13561: PUSH
13562: LD_VAR 0 4
13566: NOT
13567: OR
13568: IFFALSE 13572
// exit ;
13570: GO 13912
// list := [ ] ;
13572: LD_ADDR_VAR 0 13
13576: PUSH
13577: EMPTY
13578: ST_TO_ADDR
// if x - r < 0 then
13579: LD_VAR 0 2
13583: PUSH
13584: LD_VAR 0 4
13588: MINUS
13589: PUSH
13590: LD_INT 0
13592: LESS
13593: IFFALSE 13605
// min_x := 0 else
13595: LD_ADDR_VAR 0 7
13599: PUSH
13600: LD_INT 0
13602: ST_TO_ADDR
13603: GO 13621
// min_x := x - r ;
13605: LD_ADDR_VAR 0 7
13609: PUSH
13610: LD_VAR 0 2
13614: PUSH
13615: LD_VAR 0 4
13619: MINUS
13620: ST_TO_ADDR
// if y - r < 0 then
13621: LD_VAR 0 3
13625: PUSH
13626: LD_VAR 0 4
13630: MINUS
13631: PUSH
13632: LD_INT 0
13634: LESS
13635: IFFALSE 13647
// min_y := 0 else
13637: LD_ADDR_VAR 0 8
13641: PUSH
13642: LD_INT 0
13644: ST_TO_ADDR
13645: GO 13663
// min_y := y - r ;
13647: LD_ADDR_VAR 0 8
13651: PUSH
13652: LD_VAR 0 3
13656: PUSH
13657: LD_VAR 0 4
13661: MINUS
13662: ST_TO_ADDR
// max_x := x + r ;
13663: LD_ADDR_VAR 0 9
13667: PUSH
13668: LD_VAR 0 2
13672: PUSH
13673: LD_VAR 0 4
13677: PLUS
13678: ST_TO_ADDR
// max_y := y + r ;
13679: LD_ADDR_VAR 0 10
13683: PUSH
13684: LD_VAR 0 3
13688: PUSH
13689: LD_VAR 0 4
13693: PLUS
13694: ST_TO_ADDR
// for _x = min_x to max_x do
13695: LD_ADDR_VAR 0 11
13699: PUSH
13700: DOUBLE
13701: LD_VAR 0 7
13705: DEC
13706: ST_TO_ADDR
13707: LD_VAR 0 9
13711: PUSH
13712: FOR_TO
13713: IFFALSE 13830
// for _y = min_y to max_y do
13715: LD_ADDR_VAR 0 12
13719: PUSH
13720: DOUBLE
13721: LD_VAR 0 8
13725: DEC
13726: ST_TO_ADDR
13727: LD_VAR 0 10
13731: PUSH
13732: FOR_TO
13733: IFFALSE 13826
// begin if not ValidHex ( _x , _y ) then
13735: LD_VAR 0 11
13739: PPUSH
13740: LD_VAR 0 12
13744: PPUSH
13745: CALL_OW 488
13749: NOT
13750: IFFALSE 13754
// continue ;
13752: GO 13732
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
13754: LD_VAR 0 11
13758: PPUSH
13759: LD_VAR 0 12
13763: PPUSH
13764: CALL_OW 351
13768: PUSH
13769: LD_VAR 0 11
13773: PPUSH
13774: LD_VAR 0 12
13778: PPUSH
13779: CALL_OW 554
13783: AND
13784: IFFALSE 13824
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
13786: LD_ADDR_VAR 0 13
13790: PUSH
13791: LD_VAR 0 13
13795: PPUSH
13796: LD_VAR 0 13
13800: PUSH
13801: LD_INT 1
13803: PLUS
13804: PPUSH
13805: LD_VAR 0 11
13809: PUSH
13810: LD_VAR 0 12
13814: PUSH
13815: EMPTY
13816: LIST
13817: LIST
13818: PPUSH
13819: CALL_OW 2
13823: ST_TO_ADDR
// end ;
13824: GO 13732
13826: POP
13827: POP
13828: GO 13712
13830: POP
13831: POP
// if not list then
13832: LD_VAR 0 13
13836: NOT
13837: IFFALSE 13841
// exit ;
13839: GO 13912
// for i in list do
13841: LD_ADDR_VAR 0 6
13845: PUSH
13846: LD_VAR 0 13
13850: PUSH
13851: FOR_IN
13852: IFFALSE 13910
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
13854: LD_VAR 0 1
13858: PPUSH
13859: LD_STRING M
13861: PUSH
13862: LD_VAR 0 6
13866: PUSH
13867: LD_INT 1
13869: ARRAY
13870: PUSH
13871: LD_VAR 0 6
13875: PUSH
13876: LD_INT 2
13878: ARRAY
13879: PUSH
13880: LD_INT 0
13882: PUSH
13883: LD_INT 0
13885: PUSH
13886: LD_INT 0
13888: PUSH
13889: LD_INT 0
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: PUSH
13901: EMPTY
13902: LIST
13903: PPUSH
13904: CALL_OW 447
13908: GO 13851
13910: POP
13911: POP
// end ;
13912: LD_VAR 0 5
13916: RET
