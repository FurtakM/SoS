// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 992 0 9
// PrepareAmerican ;
  46: CALL 4733 0 0
// PrepareAlliance ;
  50: CALL 189 0 0
// Action ;
  54: CALL 2141 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := 1 ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 1
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 11 11$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 23100
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ; end_of_file
 184: LD_VAR 0 1
 188: RET
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 189: LD_INT 0
 191: PPUSH
 192: PPUSH
 193: PPUSH
 194: PPUSH
 195: PPUSH
 196: PPUSH
 197: PPUSH
// uc_side := 7 ;
 198: LD_ADDR_OWVAR 20
 202: PUSH
 203: LD_INT 7
 205: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 206: LD_ADDR_EXP 12
 210: PUSH
 211: LD_STRING JMM
 213: PPUSH
 214: LD_EXP 1
 218: NOT
 219: PPUSH
 220: LD_STRING 14a_
 222: PPUSH
 223: CALL 871 0 3
 227: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 228: LD_ADDR_EXP 13
 232: PUSH
 233: LD_STRING Burlak
 235: PPUSH
 236: LD_EXP 1
 240: NOT
 241: PPUSH
 242: LD_STRING 14a_
 244: PPUSH
 245: CALL 871 0 3
 249: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 250: LD_ADDR_EXP 14
 254: PUSH
 255: LD_STRING Joan
 257: PPUSH
 258: LD_EXP 1
 262: NOT
 263: PPUSH
 264: LD_STRING 13a_
 266: PPUSH
 267: CALL 871 0 3
 271: ST_TO_ADDR
// if not Joan then
 272: LD_EXP 14
 276: NOT
 277: IFFALSE 410
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 279: LD_ADDR_VAR 0 2
 283: PUSH
 284: LD_STRING 13a_others
 286: PPUSH
 287: CALL_OW 31
 291: ST_TO_ADDR
// if tmp then
 292: LD_VAR 0 2
 296: IFFALSE 372
// begin for i in tmp do
 298: LD_ADDR_VAR 0 3
 302: PUSH
 303: LD_VAR 0 2
 307: PUSH
 308: FOR_IN
 309: IFFALSE 370
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 311: LD_VAR 0 3
 315: PPUSH
 316: CALL_OW 257
 320: PUSH
 321: LD_INT 4
 323: EQUAL
 324: PUSH
 325: LD_VAR 0 3
 329: PPUSH
 330: CALL_OW 258
 334: PUSH
 335: LD_INT 1
 337: EQUAL
 338: AND
 339: PUSH
 340: LD_VAR 0 3
 344: PPUSH
 345: CALL_OW 248
 349: PUSH
 350: LD_INT 3
 352: EQUAL
 353: AND
 354: IFFALSE 368
// begin RuSci := i ;
 356: LD_ADDR_EXP 15
 360: PUSH
 361: LD_VAR 0 3
 365: ST_TO_ADDR
// break ;
 366: GO 370
// end ;
 368: GO 308
 370: POP
 371: POP
// end ; if not RuSci then
 372: LD_EXP 15
 376: NOT
 377: IFFALSE 410
// begin uc_nation := 3 ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 10
 395: PPUSH
 396: CALL_OW 380
// RuSci := CreateHuman ;
 400: LD_ADDR_EXP 15
 404: PUSH
 405: CALL_OW 44
 409: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 410: LD_ADDR_VAR 0 6
 414: PUSH
 415: LD_STRING 14a_JMMVeh
 417: PPUSH
 418: LD_INT 5
 420: PUSH
 421: LD_INT 3
 423: PUSH
 424: LD_INT 1
 426: PUSH
 427: LD_INT 7
 429: PUSH
 430: LD_INT 0
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: PPUSH
 444: CALL_OW 30
 448: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 449: LD_ADDR_VAR 0 7
 453: PUSH
 454: LD_STRING 14a_BurlakVeh
 456: PPUSH
 457: LD_INT 22
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 51
 468: PUSH
 469: LD_INT 0
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 30
 487: ST_TO_ADDR
// uc_direction := 4 ;
 488: LD_ADDR_OWVAR 24
 492: PUSH
 493: LD_INT 4
 495: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 496: LD_ADDR_OWVAR 21
 500: PUSH
 501: LD_VAR 0 6
 505: PUSH
 506: LD_INT 6
 508: ARRAY
 509: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 510: LD_VAR 0 6
 514: PUSH
 515: LD_INT 1
 517: ARRAY
 518: PPUSH
 519: LD_VAR 0 6
 523: PUSH
 524: LD_INT 2
 526: ARRAY
 527: PPUSH
 528: LD_VAR 0 6
 532: PUSH
 533: LD_INT 3
 535: ARRAY
 536: PPUSH
 537: LD_VAR 0 6
 541: PUSH
 542: LD_INT 4
 544: ARRAY
 545: PPUSH
 546: LD_INT 60
 548: PPUSH
 549: LD_INT 80
 551: PPUSH
 552: CALL_OW 12
 556: PPUSH
 557: CALL 934 0 5
// JMMVeh := CreateVehicle ;
 561: LD_ADDR_VAR 0 4
 565: PUSH
 566: CALL_OW 45
 570: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 571: LD_VAR 0 4
 575: PPUSH
 576: LD_INT 1
 578: PPUSH
 579: LD_INT 0
 581: PPUSH
 582: CALL 1596 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 586: LD_VAR 0 6
 590: PUSH
 591: LD_INT 5
 593: ARRAY
 594: PUSH
 595: LD_INT 0
 597: NONEQUAL
 598: IFFALSE 618
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 600: LD_VAR 0 4
 604: PPUSH
 605: LD_VAR 0 6
 609: PUSH
 610: LD_INT 5
 612: ARRAY
 613: PPUSH
 614: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 618: LD_EXP 12
 622: PPUSH
 623: LD_VAR 0 4
 627: PPUSH
 628: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 632: LD_ADDR_OWVAR 21
 636: PUSH
 637: LD_VAR 0 7
 641: PUSH
 642: LD_INT 6
 644: ARRAY
 645: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 646: LD_VAR 0 7
 650: PUSH
 651: LD_INT 1
 653: ARRAY
 654: PPUSH
 655: LD_VAR 0 7
 659: PUSH
 660: LD_INT 2
 662: ARRAY
 663: PPUSH
 664: LD_VAR 0 7
 668: PUSH
 669: LD_INT 3
 671: ARRAY
 672: PPUSH
 673: LD_VAR 0 7
 677: PUSH
 678: LD_INT 4
 680: ARRAY
 681: PPUSH
 682: LD_INT 60
 684: PPUSH
 685: LD_INT 80
 687: PPUSH
 688: CALL_OW 12
 692: PPUSH
 693: CALL 934 0 5
// BurlakVeh := CreateVehicle ;
 697: LD_ADDR_VAR 0 5
 701: PUSH
 702: CALL_OW 45
 706: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 707: LD_VAR 0 5
 711: PPUSH
 712: LD_INT 1
 714: PPUSH
 715: LD_INT 0
 717: PPUSH
 718: CALL 1596 0 3
 722: NOT
 723: IFFALSE 743
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 725: LD_VAR 0 5
 729: PPUSH
 730: LD_INT 233
 732: PPUSH
 733: LD_INT 85
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 743: LD_VAR 0 7
 747: PUSH
 748: LD_INT 5
 750: ARRAY
 751: PUSH
 752: LD_INT 0
 754: NONEQUAL
 755: IFFALSE 775
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 757: LD_VAR 0 5
 761: PPUSH
 762: LD_VAR 0 7
 766: PUSH
 767: LD_INT 5
 769: ARRAY
 770: PPUSH
 771: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 775: LD_EXP 13
 779: PPUSH
 780: LD_VAR 0 5
 784: PPUSH
 785: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 789: LD_ADDR_VAR 0 2
 793: PUSH
 794: LD_INT 178
 796: PUSH
 797: LD_INT 91
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: PUSH
 804: LD_INT 137
 806: PUSH
 807: LD_INT 83
 809: PUSH
 810: EMPTY
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 157
 816: PUSH
 817: LD_INT 75
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: LIST
 828: PUSH
 829: LD_OWVAR 67
 833: ARRAY
 834: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 835: LD_INT 4
 837: PPUSH
 838: LD_INT 4
 840: PPUSH
 841: LD_VAR 0 2
 845: PUSH
 846: LD_INT 1
 848: ARRAY
 849: PPUSH
 850: LD_VAR 0 2
 854: PUSH
 855: LD_INT 2
 857: ARRAY
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 58
// end ; end_of_file
 866: LD_VAR 0 1
 870: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 871: LD_INT 0
 873: PPUSH
 874: PPUSH
// if exist_mode then
 875: LD_VAR 0 2
 879: IFFALSE 904
// unit := CreateCharacter ( prefix & ident ) else
 881: LD_ADDR_VAR 0 5
 885: PUSH
 886: LD_VAR 0 3
 890: PUSH
 891: LD_VAR 0 1
 895: STR
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
 902: GO 919
// unit := NewCharacter ( ident ) ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 25
 918: ST_TO_ADDR
// result := unit ;
 919: LD_ADDR_VAR 0 4
 923: PUSH
 924: LD_VAR 0 5
 928: ST_TO_ADDR
// end ;
 929: LD_VAR 0 4
 933: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 934: LD_INT 0
 936: PPUSH
// vc_chassis := chassis ;
 937: LD_ADDR_OWVAR 37
 941: PUSH
 942: LD_VAR 0 1
 946: ST_TO_ADDR
// vc_engine := engine ;
 947: LD_ADDR_OWVAR 39
 951: PUSH
 952: LD_VAR 0 2
 956: ST_TO_ADDR
// vc_control := control ;
 957: LD_ADDR_OWVAR 38
 961: PUSH
 962: LD_VAR 0 3
 966: ST_TO_ADDR
// vc_weapon := weapon ;
 967: LD_ADDR_OWVAR 40
 971: PUSH
 972: LD_VAR 0 4
 976: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 977: LD_ADDR_OWVAR 41
 981: PUSH
 982: LD_VAR 0 5
 986: ST_TO_ADDR
// end ;
 987: LD_VAR 0 6
 991: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
 992: LD_INT 0
 994: PPUSH
 995: PPUSH
 996: PPUSH
// uc_side = 0 ;
 997: LD_ADDR_OWVAR 20
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// uc_nation = 0 ;
1005: LD_ADDR_OWVAR 21
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// InitHc ;
1013: CALL_OW 19
// InitVc ;
1017: CALL_OW 20
// if mastodonts then
1021: LD_VAR 0 6
1025: IFFALSE 1092
// for i = 1 to mastodonts do
1027: LD_ADDR_VAR 0 11
1031: PUSH
1032: DOUBLE
1033: LD_INT 1
1035: DEC
1036: ST_TO_ADDR
1037: LD_VAR 0 6
1041: PUSH
1042: FOR_TO
1043: IFFALSE 1090
// begin vc_chassis := 31 ;
1045: LD_ADDR_OWVAR 37
1049: PUSH
1050: LD_INT 31
1052: ST_TO_ADDR
// vc_control := control_rider ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_INT 4
1060: ST_TO_ADDR
// animal := CreateVehicle ;
1061: LD_ADDR_VAR 0 12
1065: PUSH
1066: CALL_OW 45
1070: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1071: LD_VAR 0 12
1075: PPUSH
1076: LD_VAR 0 8
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL 1596 0 3
// end ;
1088: GO 1042
1090: POP
1091: POP
// if horses then
1092: LD_VAR 0 5
1096: IFFALSE 1163
// for i = 1 to horses do
1098: LD_ADDR_VAR 0 11
1102: PUSH
1103: DOUBLE
1104: LD_INT 1
1106: DEC
1107: ST_TO_ADDR
1108: LD_VAR 0 5
1112: PUSH
1113: FOR_TO
1114: IFFALSE 1161
// begin hc_class := 21 ;
1116: LD_ADDR_OWVAR 28
1120: PUSH
1121: LD_INT 21
1123: ST_TO_ADDR
// hc_gallery :=  ;
1124: LD_ADDR_OWVAR 33
1128: PUSH
1129: LD_STRING 
1131: ST_TO_ADDR
// animal := CreateHuman ;
1132: LD_ADDR_VAR 0 12
1136: PUSH
1137: CALL_OW 44
1141: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1142: LD_VAR 0 12
1146: PPUSH
1147: LD_VAR 0 8
1151: PPUSH
1152: LD_INT 0
1154: PPUSH
1155: CALL 1596 0 3
// end ;
1159: GO 1113
1161: POP
1162: POP
// if birds then
1163: LD_VAR 0 1
1167: IFFALSE 1234
// for i = 1 to birds do
1169: LD_ADDR_VAR 0 11
1173: PUSH
1174: DOUBLE
1175: LD_INT 1
1177: DEC
1178: ST_TO_ADDR
1179: LD_VAR 0 1
1183: PUSH
1184: FOR_TO
1185: IFFALSE 1232
// begin hc_class = 18 ;
1187: LD_ADDR_OWVAR 28
1191: PUSH
1192: LD_INT 18
1194: ST_TO_ADDR
// hc_gallery =  ;
1195: LD_ADDR_OWVAR 33
1199: PUSH
1200: LD_STRING 
1202: ST_TO_ADDR
// animal := CreateHuman ;
1203: LD_ADDR_VAR 0 12
1207: PUSH
1208: CALL_OW 44
1212: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1213: LD_VAR 0 12
1217: PPUSH
1218: LD_VAR 0 8
1222: PPUSH
1223: LD_INT 0
1225: PPUSH
1226: CALL 1596 0 3
// end ;
1230: GO 1184
1232: POP
1233: POP
// if tigers then
1234: LD_VAR 0 2
1238: IFFALSE 1322
// for i = 1 to tigers do
1240: LD_ADDR_VAR 0 11
1244: PUSH
1245: DOUBLE
1246: LD_INT 1
1248: DEC
1249: ST_TO_ADDR
1250: LD_VAR 0 2
1254: PUSH
1255: FOR_TO
1256: IFFALSE 1320
// begin hc_class = class_tiger ;
1258: LD_ADDR_OWVAR 28
1262: PUSH
1263: LD_INT 14
1265: ST_TO_ADDR
// hc_gallery =  ;
1266: LD_ADDR_OWVAR 33
1270: PUSH
1271: LD_STRING 
1273: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1274: LD_ADDR_OWVAR 35
1278: PUSH
1279: LD_INT 7
1281: NEG
1282: PPUSH
1283: LD_INT 7
1285: PPUSH
1286: CALL_OW 12
1290: ST_TO_ADDR
// animal := CreateHuman ;
1291: LD_ADDR_VAR 0 12
1295: PUSH
1296: CALL_OW 44
1300: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1301: LD_VAR 0 12
1305: PPUSH
1306: LD_VAR 0 8
1310: PPUSH
1311: LD_INT 0
1313: PPUSH
1314: CALL 1596 0 3
// end ;
1318: GO 1255
1320: POP
1321: POP
// if apemans then
1322: LD_VAR 0 3
1326: IFFALSE 1449
// for i = 1 to apemans do
1328: LD_ADDR_VAR 0 11
1332: PUSH
1333: DOUBLE
1334: LD_INT 1
1336: DEC
1337: ST_TO_ADDR
1338: LD_VAR 0 3
1342: PUSH
1343: FOR_TO
1344: IFFALSE 1447
// begin hc_class = class_apeman ;
1346: LD_ADDR_OWVAR 28
1350: PUSH
1351: LD_INT 12
1353: ST_TO_ADDR
// hc_gallery =  ;
1354: LD_ADDR_OWVAR 33
1358: PUSH
1359: LD_STRING 
1361: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1362: LD_ADDR_OWVAR 35
1366: PUSH
1367: LD_INT 5
1369: NEG
1370: PPUSH
1371: LD_INT 5
1373: PPUSH
1374: CALL_OW 12
1378: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1379: LD_ADDR_OWVAR 31
1383: PUSH
1384: LD_INT 1
1386: PPUSH
1387: LD_INT 3
1389: PPUSH
1390: CALL_OW 12
1394: PUSH
1395: LD_INT 1
1397: PPUSH
1398: LD_INT 3
1400: PPUSH
1401: CALL_OW 12
1405: PUSH
1406: LD_INT 0
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: ST_TO_ADDR
// animal := CreateHuman ;
1418: LD_ADDR_VAR 0 12
1422: PUSH
1423: CALL_OW 44
1427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1428: LD_VAR 0 12
1432: PPUSH
1433: LD_VAR 0 8
1437: PPUSH
1438: LD_INT 0
1440: PPUSH
1441: CALL 1596 0 3
// end ;
1445: GO 1343
1447: POP
1448: POP
// if enchidnas then
1449: LD_VAR 0 4
1453: IFFALSE 1520
// for i = 1 to enchidnas do
1455: LD_ADDR_VAR 0 11
1459: PUSH
1460: DOUBLE
1461: LD_INT 1
1463: DEC
1464: ST_TO_ADDR
1465: LD_VAR 0 4
1469: PUSH
1470: FOR_TO
1471: IFFALSE 1518
// begin hc_class = 13 ;
1473: LD_ADDR_OWVAR 28
1477: PUSH
1478: LD_INT 13
1480: ST_TO_ADDR
// hc_gallery =  ;
1481: LD_ADDR_OWVAR 33
1485: PUSH
1486: LD_STRING 
1488: ST_TO_ADDR
// animal := CreateHuman ;
1489: LD_ADDR_VAR 0 12
1493: PUSH
1494: CALL_OW 44
1498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1499: LD_VAR 0 12
1503: PPUSH
1504: LD_VAR 0 8
1508: PPUSH
1509: LD_INT 0
1511: PPUSH
1512: CALL 1596 0 3
// end ;
1516: GO 1470
1518: POP
1519: POP
// if fishes then
1520: LD_VAR 0 7
1524: IFFALSE 1591
// for i = 1 to fishes do
1526: LD_ADDR_VAR 0 11
1530: PUSH
1531: DOUBLE
1532: LD_INT 1
1534: DEC
1535: ST_TO_ADDR
1536: LD_VAR 0 7
1540: PUSH
1541: FOR_TO
1542: IFFALSE 1589
// begin hc_class = 20 ;
1544: LD_ADDR_OWVAR 28
1548: PUSH
1549: LD_INT 20
1551: ST_TO_ADDR
// hc_gallery =  ;
1552: LD_ADDR_OWVAR 33
1556: PUSH
1557: LD_STRING 
1559: ST_TO_ADDR
// animal := CreateHuman ;
1560: LD_ADDR_VAR 0 12
1564: PUSH
1565: CALL_OW 44
1569: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1570: LD_VAR 0 12
1574: PPUSH
1575: LD_VAR 0 9
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL 1596 0 3
// end ;
1587: GO 1541
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 10
1595: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
// if not unit or not area then
1602: LD_VAR 0 1
1606: NOT
1607: PUSH
1608: LD_VAR 0 2
1612: NOT
1613: OR
1614: IFFALSE 1618
// exit ;
1616: GO 1782
// tmp := AreaToList ( area , i ) ;
1618: LD_ADDR_VAR 0 6
1622: PUSH
1623: LD_VAR 0 2
1627: PPUSH
1628: LD_VAR 0 5
1632: PPUSH
1633: CALL_OW 517
1637: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1638: LD_ADDR_VAR 0 5
1642: PUSH
1643: DOUBLE
1644: LD_INT 1
1646: DEC
1647: ST_TO_ADDR
1648: LD_VAR 0 6
1652: PUSH
1653: LD_INT 1
1655: ARRAY
1656: PUSH
1657: FOR_TO
1658: IFFALSE 1780
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1660: LD_ADDR_VAR 0 7
1664: PUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_INT 1
1672: ARRAY
1673: PUSH
1674: LD_VAR 0 5
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 6
1684: PUSH
1685: LD_INT 2
1687: ARRAY
1688: PUSH
1689: LD_VAR 0 5
1693: ARRAY
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1699: LD_VAR 0 7
1703: PUSH
1704: LD_INT 1
1706: ARRAY
1707: PPUSH
1708: LD_VAR 0 7
1712: PUSH
1713: LD_INT 2
1715: ARRAY
1716: PPUSH
1717: CALL_OW 428
1721: PUSH
1722: LD_INT 0
1724: EQUAL
1725: IFFALSE 1778
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1727: LD_VAR 0 1
1731: PPUSH
1732: LD_VAR 0 7
1736: PUSH
1737: LD_INT 1
1739: ARRAY
1740: PPUSH
1741: LD_VAR 0 7
1745: PUSH
1746: LD_INT 2
1748: ARRAY
1749: PPUSH
1750: LD_VAR 0 3
1754: PPUSH
1755: CALL_OW 48
// result := IsPlaced ( unit ) ;
1759: LD_ADDR_VAR 0 4
1763: PUSH
1764: LD_VAR 0 1
1768: PPUSH
1769: CALL_OW 305
1773: ST_TO_ADDR
// exit ;
1774: POP
1775: POP
1776: GO 1782
// end ; end ;
1778: GO 1657
1780: POP
1781: POP
// end ;
1782: LD_VAR 0 4
1786: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
1791: PPUSH
1792: PPUSH
1793: PPUSH
1794: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1795: LD_VAR 0 1
1799: NOT
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 263
1810: PUSH
1811: LD_INT 2
1813: EQUAL
1814: NOT
1815: OR
1816: IFFALSE 1820
// exit ;
1818: GO 2136
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1820: LD_ADDR_VAR 0 6
1824: PUSH
1825: LD_INT 22
1827: PUSH
1828: LD_VAR 0 1
1832: PPUSH
1833: CALL_OW 255
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 2
1844: PUSH
1845: LD_INT 30
1847: PUSH
1848: LD_INT 36
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 34
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: LIST
1868: LIST
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: PPUSH
1874: CALL_OW 69
1878: ST_TO_ADDR
// if not tmp then
1879: LD_VAR 0 6
1883: NOT
1884: IFFALSE 1888
// exit ;
1886: GO 2136
// result := [ ] ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: EMPTY
1894: ST_TO_ADDR
// for i in tmp do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: LD_VAR 0 6
1904: PUSH
1905: FOR_IN
1906: IFFALSE 1977
// begin t := UnitsInside ( i ) ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: LD_VAR 0 3
1917: PPUSH
1918: CALL_OW 313
1922: ST_TO_ADDR
// if t then
1923: LD_VAR 0 4
1927: IFFALSE 1975
// for j in t do
1929: LD_ADDR_VAR 0 7
1933: PUSH
1934: LD_VAR 0 4
1938: PUSH
1939: FOR_IN
1940: IFFALSE 1973
// result := Insert ( result , result + 1 , j ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_VAR 0 2
1956: PUSH
1957: LD_INT 1
1959: PLUS
1960: PPUSH
1961: LD_VAR 0 7
1965: PPUSH
1966: CALL_OW 2
1970: ST_TO_ADDR
1971: GO 1939
1973: POP
1974: POP
// end ;
1975: GO 1905
1977: POP
1978: POP
// if not result then
1979: LD_VAR 0 2
1983: NOT
1984: IFFALSE 1988
// exit ;
1986: GO 2136
// mech := result [ 1 ] ;
1988: LD_ADDR_VAR 0 5
1992: PUSH
1993: LD_VAR 0 2
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: ST_TO_ADDR
// if result > 1 then
2002: LD_VAR 0 2
2006: PUSH
2007: LD_INT 1
2009: GREATER
2010: IFFALSE 2122
// for i = 2 to result do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 2
2020: DEC
2021: ST_TO_ADDR
2022: LD_VAR 0 2
2026: PUSH
2027: FOR_TO
2028: IFFALSE 2120
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2030: LD_ADDR_VAR 0 4
2034: PUSH
2035: LD_VAR 0 2
2039: PUSH
2040: LD_VAR 0 3
2044: ARRAY
2045: PPUSH
2046: LD_INT 3
2048: PPUSH
2049: CALL_OW 259
2053: PUSH
2054: LD_VAR 0 2
2058: PUSH
2059: LD_VAR 0 3
2063: ARRAY
2064: PPUSH
2065: CALL_OW 432
2069: MINUS
2070: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2071: LD_VAR 0 4
2075: PUSH
2076: LD_VAR 0 5
2080: PPUSH
2081: LD_INT 3
2083: PPUSH
2084: CALL_OW 259
2088: PUSH
2089: LD_VAR 0 5
2093: PPUSH
2094: CALL_OW 432
2098: MINUS
2099: GREATEREQUAL
2100: IFFALSE 2118
// mech := result [ i ] ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 2
2111: PUSH
2112: LD_VAR 0 3
2116: ARRAY
2117: ST_TO_ADDR
// end ;
2118: GO 2027
2120: POP
2121: POP
// ComLinkTo ( vehicle , mech ) ;
2122: LD_VAR 0 1
2126: PPUSH
2127: LD_VAR 0 5
2131: PPUSH
2132: CALL_OW 135
// end ; end_of_file
2136: LD_VAR 0 2
2140: RET
// export function Action ; begin
2141: LD_INT 0
2143: PPUSH
// InGameOn ;
2144: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2148: LD_INT 221
2150: PPUSH
2151: LD_INT 80
2153: PPUSH
2154: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2158: LD_EXP 12
2162: PUSH
2163: LD_EXP 13
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PPUSH
2172: LD_INT 217
2174: PPUSH
2175: LD_INT 79
2177: PPUSH
2178: CALL_OW 111
// wait ( 0 0$7 ) ;
2182: LD_INT 245
2184: PPUSH
2185: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2189: LD_EXP 12
2193: PUSH
2194: LD_EXP 13
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: PPUSH
2203: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2207: LD_EXP 13
2211: PPUSH
2212: LD_STRING D2-Bur-1
2214: PPUSH
2215: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2219: LD_EXP 12
2223: PPUSH
2224: LD_STRING D2-JMM-1
2226: PPUSH
2227: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2231: LD_INT 18
2233: PPUSH
2234: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2238: LD_EXP 13
2242: PPUSH
2243: LD_EXP 12
2247: PPUSH
2248: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2252: LD_EXP 13
2256: PPUSH
2257: LD_STRING D2-Bur-2
2259: PPUSH
2260: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2264: LD_EXP 13
2268: PPUSH
2269: LD_INT 21
2271: PUSH
2272: LD_INT 2
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: PPUSH
2279: CALL_OW 69
2283: PPUSH
2284: LD_EXP 13
2288: PPUSH
2289: CALL_OW 74
2293: PPUSH
2294: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2298: LD_EXP 12
2302: PPUSH
2303: LD_INT 21
2305: PUSH
2306: LD_INT 2
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: PPUSH
2313: CALL_OW 69
2317: PPUSH
2318: LD_EXP 12
2322: PPUSH
2323: CALL_OW 74
2327: PPUSH
2328: CALL_OW 120
// wait ( 0 0$1 ) ;
2332: LD_INT 35
2334: PPUSH
2335: CALL_OW 67
// InGameOff ;
2339: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2343: LD_STRING MArtPickup
2345: PPUSH
2346: CALL_OW 337
// end ;
2350: LD_VAR 0 1
2354: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2355: LD_EXP 20
2359: PPUSH
2360: LD_INT 101
2362: PUSH
2363: LD_INT 7
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: CALL_OW 72
2374: IFFALSE 2403
2376: GO 2378
2378: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2379: LD_EXP 13
2383: PPUSH
2384: LD_STRING D3-Bur-1
2386: PPUSH
2387: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2391: LD_EXP 12
2395: PPUSH
2396: LD_STRING D3-JMM-1
2398: PPUSH
2399: CALL_OW 88
// end ;
2403: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2404: LD_INT 5
2406: PPUSH
2407: LD_INT 22
2409: PUSH
2410: LD_INT 7
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PPUSH
2417: CALL_OW 70
2421: IFFALSE 2752
2423: GO 2425
2425: DISABLE
// begin wait ( 0 0$3 ) ;
2426: LD_INT 105
2428: PPUSH
2429: CALL_OW 67
// DialogueOn ;
2433: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2437: LD_EXP 12
2441: PPUSH
2442: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2446: LD_EXP 12
2450: PPUSH
2451: LD_STRING D3a-JMM-1
2453: PPUSH
2454: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2458: LD_EXP 13
2462: PPUSH
2463: LD_STRING D3a-Bur-1
2465: PPUSH
2466: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2470: LD_EXP 12
2474: PPUSH
2475: LD_STRING D3a-JMM-2
2477: PPUSH
2478: CALL_OW 88
// if Joan then
2482: LD_EXP 14
2486: IFFALSE 2502
// SayRadio ( Joan , D3a-Joan-2 ) else
2488: LD_EXP 14
2492: PPUSH
2493: LD_STRING D3a-Joan-2
2495: PPUSH
2496: CALL_OW 94
2500: GO 2514
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2502: LD_EXP 15
2506: PPUSH
2507: LD_STRING D3a-RSci1-2
2509: PPUSH
2510: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2514: LD_EXP 16
2518: PPUSH
2519: LD_STRING D3a-Huck-2
2521: PPUSH
2522: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2526: LD_EXP 17
2530: PPUSH
2531: LD_STRING D3a-Pow-2
2533: PPUSH
2534: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2538: LD_EXP 16
2542: PPUSH
2543: LD_STRING D3a-Huck-3
2545: PPUSH
2546: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2550: LD_EXP 17
2554: PPUSH
2555: LD_STRING D3a-Pow-3
2557: PPUSH
2558: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2562: LD_EXP 16
2566: PPUSH
2567: LD_STRING D3a-Huck-4
2569: PPUSH
2570: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2574: LD_EXP 12
2578: PPUSH
2579: LD_STRING D3a-JMM-4
2581: PPUSH
2582: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2586: LD_EXP 13
2590: PPUSH
2591: LD_STRING D3a-Bur-4
2593: PPUSH
2594: CALL_OW 88
// if Joan then
2598: LD_EXP 14
2602: IFFALSE 2618
// SayRadio ( Joan , D3a-Joan-4 ) else
2604: LD_EXP 14
2608: PPUSH
2609: LD_STRING D3a-Joan-4
2611: PPUSH
2612: CALL_OW 94
2616: GO 2630
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2618: LD_EXP 15
2622: PPUSH
2623: LD_STRING D3a-RSci1-4
2625: PPUSH
2626: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2630: LD_INT 133
2632: PPUSH
2633: LD_INT 43
2635: PPUSH
2636: LD_INT 7
2638: PPUSH
2639: LD_INT 10
2641: NEG
2642: PPUSH
2643: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2647: LD_INT 133
2649: PPUSH
2650: LD_INT 43
2652: PPUSH
2653: LD_INT 7
2655: PPUSH
2656: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2660: LD_INT 133
2662: PPUSH
2663: LD_INT 43
2665: PPUSH
2666: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2677: LD_EXP 12
2681: PPUSH
2682: LD_STRING D3a-JMM-5
2684: PPUSH
2685: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2689: LD_EXP 13
2693: PPUSH
2694: LD_STRING D3a-Bur-5
2696: PPUSH
2697: CALL_OW 88
// DialogueOff ;
2701: CALL_OW 7
// seenBase := true ;
2705: LD_ADDR_EXP 8
2709: PUSH
2710: LD_INT 1
2712: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2713: LD_INT 525
2715: PUSH
2716: LD_INT 420
2718: PUSH
2719: LD_INT 315
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: LIST
2726: PUSH
2727: LD_OWVAR 67
2731: ARRAY
2732: PPUSH
2733: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2737: LD_EXP 19
2741: PPUSH
2742: LD_INT 142
2744: PPUSH
2745: LD_INT 52
2747: PPUSH
2748: CALL_OW 116
// end ;
2752: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2753: LD_EXP 8
2757: NOT
2758: PUSH
2759: LD_EXP 4
2763: NOT
2764: AND
2765: IFFALSE 2785
2767: GO 2769
2769: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2770: LD_EXP 19
2774: PPUSH
2775: LD_INT 142
2777: PPUSH
2778: LD_INT 52
2780: PPUSH
2781: CALL_OW 116
2785: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2786: LD_INT 0
2788: PPUSH
2789: PPUSH
// contaminateTime := tick ;
2790: LD_ADDR_EXP 3
2794: PUSH
2795: LD_OWVAR 1
2799: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2800: LD_INT 175
2802: PPUSH
2803: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2807: LD_ADDR_VAR 0 5
2811: PUSH
2812: LD_INT 4
2814: PPUSH
2815: CALL_OW 469
2819: ST_TO_ADDR
// if art then
2820: LD_VAR 0 5
2824: IFFALSE 2863
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2826: LD_VAR 0 5
2830: PUSH
2831: LD_INT 1
2833: ARRAY
2834: PUSH
2835: LD_INT 157
2837: EQUAL
2838: PUSH
2839: LD_VAR 0 5
2843: PUSH
2844: LD_INT 2
2846: ARRAY
2847: PUSH
2848: LD_INT 75
2850: EQUAL
2851: AND
2852: IFFALSE 2863
// begin YouLost ( Artefact ) ;
2854: LD_STRING Artefact
2856: PPUSH
2857: CALL_OW 104
// exit ;
2861: GO 3015
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2863: LD_EXP 12
2867: PPUSH
2868: CALL_OW 302
2872: PUSH
2873: LD_EXP 13
2877: PPUSH
2878: CALL_OW 302
2882: AND
2883: IFFALSE 2960
// begin DialogueOn ;
2885: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2889: LD_EXP 12
2893: PPUSH
2894: LD_STRING D6a-JMM-1
2896: PPUSH
2897: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2901: LD_EXP 13
2905: PPUSH
2906: LD_STRING D6a-Bur-1
2908: PPUSH
2909: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2913: LD_EXP 12
2917: PPUSH
2918: LD_STRING D6c-JMM-1
2920: PPUSH
2921: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2925: LD_EXP 13
2929: PPUSH
2930: LD_STRING D6c-Bur-1
2932: PPUSH
2933: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2937: LD_EXP 12
2941: PPUSH
2942: LD_STRING D6c-JMM-2
2944: PPUSH
2945: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2949: LD_STRING MBase
2951: PPUSH
2952: CALL_OW 337
// DialogueOff ;
2956: CALL_OW 7
// end ; bombExploded := true ;
2960: LD_ADDR_EXP 4
2964: PUSH
2965: LD_INT 1
2967: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
2968: LD_INT 6300
2970: PUSH
2971: LD_INT 5250
2973: PUSH
2974: LD_INT 4200
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PUSH
2982: LD_OWVAR 67
2986: ARRAY
2987: PPUSH
2988: CALL_OW 67
// if IsOk ( JMM ) then
2992: LD_EXP 12
2996: PPUSH
2997: CALL_OW 302
3001: IFFALSE 3015
// Say ( JMM , D8-JMM-1 ) ;
3003: LD_EXP 12
3007: PPUSH
3008: LD_STRING D8-JMM-1
3010: PPUSH
3011: CALL_OW 88
// end ;
3015: LD_VAR 0 4
3019: RET
// every 0 0$1 trigger stevensTimer and bombExploded do
3020: LD_EXP 9
3024: PUSH
3025: LD_EXP 4
3029: AND
3030: IFFALSE 3085
3032: GO 3034
3034: DISABLE
// begin enable ;
3035: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3036: LD_INT 9
3038: PPUSH
3039: LD_INT 22
3041: PUSH
3042: LD_INT 7
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: PPUSH
3049: CALL_OW 70
3053: IFFALSE 3071
// stevensTimer := stevensTimer - 0 0$30 else
3055: LD_ADDR_EXP 9
3059: PUSH
3060: LD_EXP 9
3064: PUSH
3065: LD_INT 1050
3067: MINUS
3068: ST_TO_ADDR
3069: GO 3085
// stevensTimer := stevensTimer - 0 0$1 ;
3071: LD_ADDR_EXP 9
3075: PUSH
3076: LD_EXP 9
3080: PUSH
3081: LD_INT 35
3083: MINUS
3084: ST_TO_ADDR
// end ;
3085: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 do var i , tmp ;
3086: LD_EXP 9
3090: PUSH
3091: LD_INT 0
3093: LESSEQUAL
3094: IFFALSE 3225
3096: GO 3098
3098: DISABLE
3099: LD_INT 0
3101: PPUSH
3102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: LD_INT 22
3110: PUSH
3111: LD_INT 1
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PUSH
3118: LD_INT 25
3120: PUSH
3121: LD_INT 4
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: PUSH
3128: EMPTY
3129: LIST
3130: LIST
3131: PPUSH
3132: CALL_OW 69
3136: ST_TO_ADDR
// for i in tmp do
3137: LD_ADDR_VAR 0 1
3141: PUSH
3142: LD_VAR 0 2
3146: PUSH
3147: FOR_IN
3148: IFFALSE 3176
// begin ComExitBuilding ( i ) ;
3150: LD_VAR 0 1
3154: PPUSH
3155: CALL_OW 122
// AddComMoveXY ( i , 29 , 56 ) ;
3159: LD_VAR 0 1
3163: PPUSH
3164: LD_INT 29
3166: PPUSH
3167: LD_INT 56
3169: PPUSH
3170: CALL_OW 171
// end ;
3174: GO 3147
3176: POP
3177: POP
// repeat wait ( 0 0$1 ) ;
3178: LD_INT 35
3180: PPUSH
3181: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3185: LD_INT 8
3187: PPUSH
3188: LD_INT 22
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 25
3200: PUSH
3201: LD_INT 4
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: PUSH
3208: EMPTY
3209: LIST
3210: LIST
3211: PPUSH
3212: CALL_OW 70
3216: IFFALSE 3178
// YouLost ( Time ) ;
3218: LD_STRING Time
3220: PPUSH
3221: CALL_OW 104
// end ;
3225: PPOPN 2
3227: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3228: LD_INT 22
3230: PUSH
3231: LD_INT 7
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 92
3240: PUSH
3241: LD_INT 142
3243: PUSH
3244: LD_INT 52
3246: PUSH
3247: LD_INT 27
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: PPUSH
3260: CALL_OW 69
3264: PUSH
3265: LD_EXP 3
3269: PUSH
3270: LD_INT 6000
3272: PLUS
3273: PUSH
3274: LD_OWVAR 1
3278: GREATER
3279: AND
3280: PUSH
3281: LD_EXP 4
3285: AND
3286: IFFALSE 3341
3288: GO 3290
3290: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3291: LD_EXP 12
3295: PUSH
3296: LD_EXP 13
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: PPUSH
3305: CALL_OW 85
// DialogueOn ;
3309: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3313: LD_EXP 12
3317: PPUSH
3318: LD_STRING D6b-JMM-1
3320: PPUSH
3321: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3325: LD_EXP 13
3329: PPUSH
3330: LD_STRING D6b-Bur-1
3332: PPUSH
3333: CALL_OW 88
// DialogueOff ;
3337: CALL_OW 7
// end ;
3341: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3342: LD_EXP 13
3346: PPUSH
3347: LD_INT 142
3349: PPUSH
3350: LD_INT 52
3352: PPUSH
3353: CALL_OW 297
3357: PUSH
3358: LD_INT 25
3360: LESS
3361: PUSH
3362: LD_EXP 13
3366: PPUSH
3367: CALL_OW 310
3371: PPUSH
3372: LD_INT 142
3374: PPUSH
3375: LD_INT 52
3377: PPUSH
3378: CALL_OW 297
3382: PUSH
3383: LD_INT 25
3385: LESS
3386: OR
3387: PUSH
3388: LD_EXP 13
3392: PPUSH
3393: CALL_OW 256
3397: PUSH
3398: LD_INT 1000
3400: LESS
3401: AND
3402: PUSH
3403: LD_EXP 3
3407: PUSH
3408: LD_INT 6000
3410: PLUS
3411: PUSH
3412: LD_OWVAR 1
3416: GREATER
3417: AND
3418: PUSH
3419: LD_EXP 4
3423: AND
3424: IFFALSE 3457
3426: GO 3428
3428: DISABLE
// begin DialogueOn ;
3429: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3433: LD_EXP 13
3437: PPUSH
3438: LD_STRING D7-Bur-1
3440: PPUSH
3441: CALL_OW 88
// enteredContaminatedArea := true ;
3445: LD_ADDR_EXP 5
3449: PUSH
3450: LD_INT 1
3452: ST_TO_ADDR
// DialogueOff ;
3453: CALL_OW 7
// end ;
3457: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3458: LD_EXP 12
3462: PPUSH
3463: LD_INT 142
3465: PPUSH
3466: LD_INT 52
3468: PPUSH
3469: CALL_OW 297
3473: PUSH
3474: LD_INT 25
3476: LESS
3477: PUSH
3478: LD_EXP 12
3482: PPUSH
3483: CALL_OW 310
3487: PPUSH
3488: LD_INT 142
3490: PPUSH
3491: LD_INT 52
3493: PPUSH
3494: CALL_OW 297
3498: PUSH
3499: LD_INT 25
3501: LESS
3502: OR
3503: PUSH
3504: LD_EXP 12
3508: PPUSH
3509: CALL_OW 256
3513: PUSH
3514: LD_INT 1000
3516: LESS
3517: AND
3518: PUSH
3519: LD_EXP 3
3523: PUSH
3524: LD_INT 6000
3526: PLUS
3527: PUSH
3528: LD_OWVAR 1
3532: GREATER
3533: AND
3534: PUSH
3535: LD_EXP 4
3539: AND
3540: IFFALSE 3573
3542: GO 3544
3544: DISABLE
// begin DialogueOn ;
3545: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3549: LD_EXP 12
3553: PPUSH
3554: LD_STRING D7-JMM-1
3556: PPUSH
3557: CALL_OW 88
// enteredContaminatedArea := true ;
3561: LD_ADDR_EXP 5
3565: PUSH
3566: LD_INT 1
3568: ST_TO_ADDR
// DialogueOff ;
3569: CALL_OW 7
// end ;
3573: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3574: LD_EXP 6
3578: PUSH
3579: LD_EXP 12
3583: PPUSH
3584: CALL_OW 302
3588: AND
3589: PUSH
3590: LD_EXP 13
3594: PPUSH
3595: CALL_OW 302
3599: AND
3600: IFFALSE 3669
3602: GO 3604
3604: DISABLE
// begin DialogueOn ;
3605: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3609: LD_EXP 12
3613: PUSH
3614: LD_EXP 13
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3627: LD_EXP 12
3631: PPUSH
3632: LD_STRING D4-JMM-1
3634: PPUSH
3635: CALL_OW 88
// if not bombExploded then
3639: LD_EXP 4
3643: NOT
3644: IFFALSE 3658
// Say ( Burlak , D4-Bur-1 ) ;
3646: LD_EXP 13
3650: PPUSH
3651: LD_STRING D4-Bur-1
3653: PPUSH
3654: CALL_OW 88
// DialogueOff ;
3658: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3662: LD_STRING MReturn
3664: PPUSH
3665: CALL_OW 337
// end ;
3669: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3670: LD_EXP 7
3674: NOT
3675: PUSH
3676: LD_INT 22
3678: PUSH
3679: LD_INT 7
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PUSH
3686: LD_INT 91
3688: PUSH
3689: LD_INT 9
3691: PUSH
3692: LD_INT 6
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PPUSH
3704: CALL_OW 69
3708: AND
3709: IFFALSE 3786
3711: GO 3713
3713: DISABLE
// begin DialogueOn ;
3714: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3718: LD_INT 55
3720: PPUSH
3721: LD_INT 11
3723: PPUSH
3724: LD_INT 7
3726: PPUSH
3727: LD_INT 6
3729: NEG
3730: PPUSH
3731: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3735: LD_INT 55
3737: PPUSH
3738: LD_INT 11
3740: PPUSH
3741: LD_INT 7
3743: PPUSH
3744: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3748: LD_EXP 13
3752: PPUSH
3753: LD_STRING D9-Bur-1
3755: PPUSH
3756: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3760: LD_EXP 12
3764: PPUSH
3765: LD_STRING D9-JMM-1
3767: PPUSH
3768: CALL_OW 88
// DialogueOff ;
3772: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3776: LD_INT 9
3778: PPUSH
3779: LD_INT 7
3781: PPUSH
3782: CALL_OW 235
// end ;
3786: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3787: LD_INT 9
3789: PPUSH
3790: LD_INT 22
3792: PUSH
3793: LD_INT 7
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: PPUSH
3800: CALL_OW 70
3804: IFFALSE 3840
3806: GO 3808
3808: DISABLE
// begin wait ( 0 0$07 ) ;
3809: LD_INT 245
3811: PPUSH
3812: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3816: LD_EXP 12
3820: PPUSH
3821: LD_STRING D10b-JMM-1
3823: PPUSH
3824: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3828: LD_EXP 13
3832: PPUSH
3833: LD_STRING D10b-Bur-1
3835: PPUSH
3836: CALL_OW 88
// end ;
3840: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3841: LD_EXP 9
3845: PUSH
3846: LD_INT 22
3848: PUSH
3849: LD_INT 1
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PUSH
3856: LD_INT 25
3858: PUSH
3859: LD_INT 4
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: PUSH
3866: LD_INT 26
3868: PUSH
3869: LD_INT 1
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: PPUSH
3881: CALL_OW 69
3885: AND
3886: PUSH
3887: LD_INT 5
3889: PPUSH
3890: CALL_OW 255
3894: PUSH
3895: LD_INT 7
3897: EQUAL
3898: PUSH
3899: LD_INT 22
3901: PUSH
3902: LD_INT 1
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PUSH
3909: LD_INT 25
3911: PUSH
3912: LD_INT 1
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PPUSH
3923: CALL_OW 69
3927: PUSH
3928: LD_INT 0
3930: EQUAL
3931: OR
3932: AND
3933: IFFALSE 4315
3935: GO 3937
3937: DISABLE
3938: LD_INT 0
3940: PPUSH
// begin case Query ( QKill ) of 1 :
3941: LD_STRING QKill
3943: PPUSH
3944: CALL_OW 97
3948: PUSH
3949: LD_INT 1
3951: DOUBLE
3952: EQUAL
3953: IFTRUE 3957
3955: GO 4303
3957: POP
// begin DialogueOn ;
3958: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
3962: LD_EXP 12
3966: PPUSH
3967: LD_STRING D10a-JMM-1
3969: PPUSH
3970: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
3974: LD_EXP 13
3978: PPUSH
3979: LD_STRING D10a-Bur-1
3981: PPUSH
3982: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
3986: LD_EXP 12
3990: PPUSH
3991: LD_STRING D10a-JMM-2
3993: PPUSH
3994: CALL_OW 88
// if IsOk ( Stevens ) then
3998: LD_EXP 16
4002: PPUSH
4003: CALL_OW 302
4007: IFFALSE 4023
// Say ( Stevens , D10a-Huck-2 ) else
4009: LD_EXP 16
4013: PPUSH
4014: LD_STRING D10a-Huck-2
4016: PPUSH
4017: CALL_OW 88
4021: GO 4074
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4023: LD_INT 22
4025: PUSH
4026: LD_INT 1
4028: PUSH
4029: EMPTY
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 25
4035: PUSH
4036: LD_INT 4
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 26
4045: PUSH
4046: LD_INT 1
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PPUSH
4058: CALL_OW 69
4062: PUSH
4063: LD_INT 1
4065: ARRAY
4066: PPUSH
4067: LD_STRING D10a-ASci1-3
4069: PPUSH
4070: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4074: LD_EXP 12
4078: PPUSH
4079: LD_STRING D10a-JMM-4
4081: PPUSH
4082: CALL_OW 88
// if IsOk ( Stevens ) then
4086: LD_EXP 16
4090: PPUSH
4091: CALL_OW 302
4095: IFFALSE 4109
// Say ( Stevens , D10a-Huck-3 ) ;
4097: LD_EXP 16
4101: PPUSH
4102: LD_STRING D10a-Huck-3
4104: PPUSH
4105: CALL_OW 88
// DialogueOff ;
4109: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4113: LD_INT 1
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: LD_INT 1
4121: PPUSH
4122: LD_INT 1
4124: PPUSH
4125: CALL_OW 80
// planCaptured := true ;
4129: LD_ADDR_EXP 7
4133: PUSH
4134: LD_INT 1
4136: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4137: LD_STRING MEnd
4139: PPUSH
4140: CALL_OW 337
// canEnd := true ;
4144: LD_ADDR_EXP 10
4148: PUSH
4149: LD_INT 1
4151: ST_TO_ADDR
// missionTime := tick ;
4152: LD_ADDR_EXP 11
4156: PUSH
4157: LD_OWVAR 1
4161: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
4162: LD_INT 70
4164: PPUSH
4165: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4169: LD_ADDR_VAR 0 1
4173: PUSH
4174: LD_INT 22
4176: PUSH
4177: LD_INT 1
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PUSH
4184: LD_INT 21
4186: PUSH
4187: LD_INT 1
4189: PUSH
4190: EMPTY
4191: LIST
4192: LIST
4193: PUSH
4194: EMPTY
4195: LIST
4196: LIST
4197: PPUSH
4198: CALL_OW 69
4202: PUSH
4203: FOR_IN
4204: IFFALSE 4268
// begin if IsInArea ( i , stevensEscapeArea ) then
4206: LD_VAR 0 1
4210: PPUSH
4211: LD_INT 8
4213: PPUSH
4214: CALL_OW 308
4218: IFFALSE 4231
// begin RemoveUnit ( i ) ;
4220: LD_VAR 0 1
4224: PPUSH
4225: CALL_OW 64
// continue ;
4229: GO 4203
// end ; if IsInUnit ( i ) then
4231: LD_VAR 0 1
4235: PPUSH
4236: CALL_OW 310
4240: IFFALSE 4251
// ComExitBuilding ( i ) ;
4242: LD_VAR 0 1
4246: PPUSH
4247: CALL_OW 122
// AddComMoveXY ( i , 28 , 55 ) ;
4251: LD_VAR 0 1
4255: PPUSH
4256: LD_INT 28
4258: PPUSH
4259: LD_INT 55
4261: PPUSH
4262: CALL_OW 171
// end ;
4266: GO 4203
4268: POP
4269: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4270: LD_INT 22
4272: PUSH
4273: LD_INT 1
4275: PUSH
4276: EMPTY
4277: LIST
4278: LIST
4279: PUSH
4280: LD_INT 21
4282: PUSH
4283: LD_INT 1
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PPUSH
4294: CALL_OW 69
4298: NOT
4299: IFFALSE 4162
// end ; 2 :
4301: GO 4315
4303: LD_INT 2
4305: DOUBLE
4306: EQUAL
4307: IFTRUE 4311
4309: GO 4314
4311: POP
// ; end ;
4312: GO 4315
4314: POP
// end ;
4315: PPOPN 1
4317: END
// every 0 0$1 trigger GetSide ( us_lab ) = 7 and not planCaptured do
4318: LD_INT 1
4320: PPUSH
4321: CALL_OW 255
4325: PUSH
4326: LD_INT 7
4328: EQUAL
4329: PUSH
4330: LD_EXP 7
4334: NOT
4335: AND
4336: IFFALSE 4374
4338: GO 4340
4340: DISABLE
// begin planCaptured := true ;
4341: LD_ADDR_EXP 7
4345: PUSH
4346: LD_INT 1
4348: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4349: LD_STRING MEnd
4351: PPUSH
4352: CALL_OW 337
// canEnd := true ;
4356: LD_ADDR_EXP 10
4360: PUSH
4361: LD_INT 1
4363: ST_TO_ADDR
// missionTime := tick ;
4364: LD_ADDR_EXP 11
4368: PUSH
4369: LD_OWVAR 1
4373: ST_TO_ADDR
// end ;
4374: END
// every 0 0$1 trigger canEnd do var un ;
4375: LD_EXP 10
4379: IFFALSE 4479
4381: GO 4383
4383: DISABLE
4384: LD_INT 0
4386: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4387: LD_INT 10
4389: PPUSH
4390: LD_INT 1
4392: PPUSH
4393: CALL_OW 424
// if Difficulty < 2 then
4397: LD_OWVAR 67
4401: PUSH
4402: LD_INT 2
4404: LESS
4405: IFFALSE 4409
// exit ;
4407: GO 4479
// uc_side := 8 ;
4409: LD_ADDR_OWVAR 20
4413: PUSH
4414: LD_INT 8
4416: ST_TO_ADDR
// uc_nation := 2 ;
4417: LD_ADDR_OWVAR 21
4421: PUSH
4422: LD_INT 2
4424: ST_TO_ADDR
// InitHc ;
4425: CALL_OW 19
// PrepareHuman ( false , class_sniper , 10 ) ;
4429: LD_INT 0
4431: PPUSH
4432: LD_INT 5
4434: PPUSH
4435: LD_INT 10
4437: PPUSH
4438: CALL_OW 380
// un := CreateHuman ;
4442: LD_ADDR_VAR 0 1
4446: PUSH
4447: CALL_OW 44
4451: ST_TO_ADDR
// PlaceUnitXY ( un , 227 , 87 , false ) ;
4452: LD_VAR 0 1
4456: PPUSH
4457: LD_INT 227
4459: PPUSH
4460: LD_INT 87
4462: PPUSH
4463: LD_INT 0
4465: PPUSH
4466: CALL_OW 48
// ComHold ( un ) ;
4470: LD_VAR 0 1
4474: PPUSH
4475: CALL_OW 140
// end ;
4479: PPOPN 1
4481: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4482: LD_EXP 7
4486: NOT
4487: PUSH
4488: LD_INT 1
4490: PPUSH
4491: CALL_OW 301
4495: AND
4496: IFFALSE 4508
4498: GO 4500
4500: DISABLE
// YouLost ( Lab ) ;
4501: LD_STRING Lab
4503: PPUSH
4504: CALL_OW 104
4508: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do
4509: LD_INT 10
4511: PPUSH
4512: LD_INT 22
4514: PUSH
4515: LD_INT 7
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL_OW 70
4526: PUSH
4527: LD_INT 2
4529: GREATEREQUAL
4530: PUSH
4531: LD_INT 10
4533: PPUSH
4534: LD_INT 2
4536: PUSH
4537: LD_INT 34
4539: PUSH
4540: LD_INT 12
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PUSH
4547: LD_INT 34
4549: PUSH
4550: LD_INT 51
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: PPUSH
4562: CALL_OW 70
4566: AND
4567: PUSH
4568: LD_EXP 10
4572: AND
4573: PUSH
4574: LD_EXP 7
4578: AND
4579: PUSH
4580: LD_EXP 6
4584: AND
4585: IFFALSE 4732
4587: GO 4589
4589: DISABLE
// begin AddMedal ( Explosion , 1 ) ;
4590: LD_STRING Explosion
4592: PPUSH
4593: LD_INT 1
4595: PPUSH
4596: CALL_OW 101
// if enteredContaminatedArea then
4600: LD_EXP 5
4604: IFFALSE 4618
// AddMedal ( BioHazard , 1 ) else
4606: LD_STRING BioHazard
4608: PPUSH
4609: LD_INT 1
4611: PPUSH
4612: CALL_OW 101
4616: GO 4629
// AddMedal ( BioHazard , - 1 ) ;
4618: LD_STRING BioHazard
4620: PPUSH
4621: LD_INT 1
4623: NEG
4624: PPUSH
4625: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
4629: LD_EXP 11
4633: PUSH
4634: LD_INT 42000
4636: PUSH
4637: LD_INT 31500
4639: PUSH
4640: LD_INT 25200
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: LIST
4647: PUSH
4648: LD_OWVAR 67
4652: ARRAY
4653: LESSEQUAL
4654: IFFALSE 4668
// AddMedal ( Speed , 1 ) else
4656: LD_STRING Speed
4658: PPUSH
4659: LD_INT 1
4661: PPUSH
4662: CALL_OW 101
4666: GO 4679
// AddMedal ( Speed , - 1 ) ;
4668: LD_STRING Speed
4670: PPUSH
4671: LD_INT 1
4673: NEG
4674: PPUSH
4675: CALL_OW 101
// GiveMedals ( Main ) ;
4679: LD_STRING Main
4681: PPUSH
4682: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
4686: LD_EXP 12
4690: PUSH
4691: LD_EXP 13
4695: PUSH
4696: EMPTY
4697: LIST
4698: LIST
4699: PPUSH
4700: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
4704: LD_EXP 12
4708: PPUSH
4709: LD_STRING 14a_JMM
4711: PPUSH
4712: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
4716: LD_EXP 13
4720: PPUSH
4721: LD_STRING 14a_Burlak
4723: PPUSH
4724: CALL_OW 38
// YouWin ;
4728: CALL_OW 103
// end ; end_of_file
4732: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
4733: LD_INT 0
4735: PPUSH
4736: PPUSH
4737: PPUSH
4738: PPUSH
// uc_side := 1 ;
4739: LD_ADDR_OWVAR 20
4743: PUSH
4744: LD_INT 1
4746: ST_TO_ADDR
// uc_nation := 1 ;
4747: LD_ADDR_OWVAR 21
4751: PUSH
4752: LD_INT 1
4754: ST_TO_ADDR
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
4755: LD_INT 34
4757: PPUSH
4758: CALL_OW 274
4762: PPUSH
4763: LD_INT 1
4765: PPUSH
4766: LD_INT 500
4768: PPUSH
4769: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
4773: LD_INT 34
4775: PPUSH
4776: CALL_OW 274
4780: PPUSH
4781: LD_INT 3
4783: PPUSH
4784: LD_INT 20
4786: PPUSH
4787: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
4791: LD_ADDR_EXP 16
4795: PUSH
4796: LD_STRING Stevens
4798: PPUSH
4799: CALL_OW 25
4803: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
4804: LD_ADDR_EXP 17
4808: PUSH
4809: LD_STRING Powell
4811: PPUSH
4812: CALL_OW 25
4816: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
4817: LD_EXP 16
4821: PPUSH
4822: LD_INT 1
4824: PPUSH
4825: CALL_OW 52
// vehGuard := [ ] ;
4829: LD_ADDR_EXP 21
4833: PUSH
4834: EMPTY
4835: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
4836: LD_INT 4
4838: PPUSH
4839: LD_INT 3
4841: PPUSH
4842: LD_INT 3
4844: PPUSH
4845: LD_INT 8
4847: PPUSH
4848: LD_INT 100
4850: PPUSH
4851: CALL 934 0 5
// sibBomb := CreateVehicle ;
4855: LD_ADDR_EXP 19
4859: PUSH
4860: CALL_OW 45
4864: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
4865: LD_EXP 19
4869: PPUSH
4870: LD_INT 1
4872: PPUSH
4873: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
4877: LD_EXP 19
4881: PPUSH
4882: LD_INT 93
4884: PPUSH
4885: LD_INT 74
4887: PPUSH
4888: LD_INT 0
4890: PPUSH
4891: CALL_OW 48
// guards := [ ] ;
4895: LD_ADDR_EXP 20
4899: PUSH
4900: EMPTY
4901: ST_TO_ADDR
// for i = 1 to 3 do
4902: LD_ADDR_VAR 0 2
4906: PUSH
4907: DOUBLE
4908: LD_INT 1
4910: DEC
4911: ST_TO_ADDR
4912: LD_INT 3
4914: PUSH
4915: FOR_TO
4916: IFFALSE 5008
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
4918: LD_INT 0
4920: PPUSH
4921: LD_INT 1
4923: PPUSH
4924: LD_INT 8
4926: PUSH
4927: LD_INT 9
4929: PUSH
4930: LD_INT 10
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: LIST
4937: PUSH
4938: LD_OWVAR 67
4942: ARRAY
4943: PPUSH
4944: CALL_OW 380
// un := CreateHuman ;
4948: LD_ADDR_VAR 0 3
4952: PUSH
4953: CALL_OW 44
4957: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
4958: LD_VAR 0 3
4962: PPUSH
4963: LD_INT 2
4965: PUSH
4966: LD_INT 3
4968: PUSH
4969: LD_INT 4
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: LIST
4976: PUSH
4977: LD_VAR 0 2
4981: ARRAY
4982: PPUSH
4983: LD_INT 0
4985: PPUSH
4986: CALL_OW 49
// guards := guards ^ un ;
4990: LD_ADDR_EXP 20
4994: PUSH
4995: LD_EXP 20
4999: PUSH
5000: LD_VAR 0 3
5004: ADD
5005: ST_TO_ADDR
// end ;
5006: GO 4915
5008: POP
5009: POP
// baseGuards := [ ] ;
5010: LD_ADDR_EXP 18
5014: PUSH
5015: EMPTY
5016: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5017: LD_ADDR_VAR 0 2
5021: PUSH
5022: DOUBLE
5023: LD_INT 1
5025: DEC
5026: ST_TO_ADDR
5027: LD_INT 5
5029: PUSH
5030: LD_INT 6
5032: PUSH
5033: LD_INT 7
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: LIST
5040: PUSH
5041: LD_OWVAR 67
5045: ARRAY
5046: PUSH
5047: FOR_TO
5048: IFFALSE 5194
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5050: LD_INT 0
5052: PPUSH
5053: LD_INT 8
5055: PUSH
5056: LD_INT 9
5058: PUSH
5059: LD_INT 10
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: LIST
5066: PUSH
5067: LD_OWVAR 67
5071: ARRAY
5072: PPUSH
5073: CALL_OW 381
// un := CreateHuman ;
5077: LD_ADDR_VAR 0 3
5081: PUSH
5082: CALL_OW 44
5086: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5087: LD_ADDR_EXP 18
5091: PUSH
5092: LD_EXP 18
5096: PUSH
5097: LD_VAR 0 3
5101: ADD
5102: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5103: LD_ADDR_VAR 0 4
5107: PUSH
5108: LD_INT 22
5110: PUSH
5111: LD_INT 1
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PUSH
5118: LD_INT 58
5120: PUSH
5121: EMPTY
5122: LIST
5123: PUSH
5124: LD_INT 30
5126: PUSH
5127: LD_INT 32
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: ST_TO_ADDR
// if tmp then
5144: LD_VAR 0 4
5148: IFFALSE 5180
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5150: LD_VAR 0 3
5154: PPUSH
5155: LD_VAR 0 4
5159: PUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_VAR 0 4
5167: PPUSH
5168: CALL_OW 12
5172: ARRAY
5173: PPUSH
5174: CALL_OW 52
5178: GO 5192
// PlaceHumanInUnit ( un , us_bar ) ;
5180: LD_VAR 0 3
5184: PPUSH
5185: LD_INT 51
5187: PPUSH
5188: CALL_OW 52
// end ;
5192: GO 5047
5194: POP
5195: POP
// if Difficulty > 1 then
5196: LD_OWVAR 67
5200: PUSH
5201: LD_INT 1
5203: GREATER
5204: IFFALSE 5248
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5206: LD_INT 0
5208: PPUSH
5209: LD_INT 5
5211: PPUSH
5212: LD_INT 9
5214: PUSH
5215: LD_INT 10
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: PUSH
5227: LD_INT 1
5229: MINUS
5230: ARRAY
5231: PPUSH
5232: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5236: CALL_OW 44
5240: PPUSH
5241: LD_INT 80
5243: PPUSH
5244: CALL_OW 52
// end ; for i = 1 to 3 do
5248: LD_ADDR_VAR 0 2
5252: PUSH
5253: DOUBLE
5254: LD_INT 1
5256: DEC
5257: ST_TO_ADDR
5258: LD_INT 3
5260: PUSH
5261: FOR_TO
5262: IFFALSE 5288
// begin PrepareMechanic ( false , 9 ) ;
5264: LD_INT 0
5266: PPUSH
5267: LD_INT 9
5269: PPUSH
5270: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5274: CALL_OW 44
5278: PPUSH
5279: LD_INT 43
5281: PPUSH
5282: CALL_OW 52
// end ;
5286: GO 5261
5288: POP
5289: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5290: CALL_OW 44
5294: PPUSH
5295: LD_INT 49
5297: PPUSH
5298: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5302: LD_ADDR_VAR 0 2
5306: PUSH
5307: DOUBLE
5308: LD_INT 1
5310: DEC
5311: ST_TO_ADDR
5312: LD_INT 1
5314: PUSH
5315: LD_OWVAR 67
5319: PLUS
5320: PUSH
5321: FOR_TO
5322: IFFALSE 5365
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5324: LD_INT 0
5326: PPUSH
5327: LD_INT 8
5329: PUSH
5330: LD_INT 9
5332: PUSH
5333: LD_INT 10
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: LIST
5340: PUSH
5341: LD_OWVAR 67
5345: ARRAY
5346: PPUSH
5347: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5351: CALL_OW 44
5355: PPUSH
5356: LD_INT 5
5358: PPUSH
5359: CALL_OW 52
// end ;
5363: GO 5321
5365: POP
5366: POP
// for i = 1 to 3 do
5367: LD_ADDR_VAR 0 2
5371: PUSH
5372: DOUBLE
5373: LD_INT 1
5375: DEC
5376: ST_TO_ADDR
5377: LD_INT 3
5379: PUSH
5380: FOR_TO
5381: IFFALSE 5407
// begin PrepareScientist ( false , 10 ) ;
5383: LD_INT 0
5385: PPUSH
5386: LD_INT 10
5388: PPUSH
5389: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
5393: CALL_OW 44
5397: PPUSH
5398: LD_INT 1
5400: PPUSH
5401: CALL_OW 52
// end ;
5405: GO 5380
5407: POP
5408: POP
// end ;
5409: LD_VAR 0 1
5413: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
5414: LD_EXP 20
5418: PUSH
5419: LD_EXP 2
5423: NOT
5424: AND
5425: IFFALSE 5611
5427: GO 5429
5429: DISABLE
5430: LD_INT 0
5432: PPUSH
5433: PPUSH
5434: PPUSH
// begin enable ;
5435: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
5436: LD_ADDR_VAR 0 3
5440: PUSH
5441: LD_INT 204
5443: PUSH
5444: LD_INT 30
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: PUSH
5451: LD_INT 165
5453: PUSH
5454: LD_INT 24
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PUSH
5461: LD_INT 195
5463: PUSH
5464: LD_INT 6
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: PUSH
5471: LD_INT 223
5473: PUSH
5474: LD_INT 54
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: PUSH
5481: LD_INT 214
5483: PUSH
5484: LD_INT 84
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 206
5493: PUSH
5494: LD_INT 71
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: ST_TO_ADDR
// for i in guards do
5509: LD_ADDR_VAR 0 1
5513: PUSH
5514: LD_EXP 20
5518: PUSH
5519: FOR_IN
5520: IFFALSE 5609
// begin if HasTask ( i ) then
5522: LD_VAR 0 1
5526: PPUSH
5527: CALL_OW 314
5531: IFFALSE 5537
// continue else
5533: GO 5519
5535: GO 5607
// begin j := rand ( 1 , 6 ) ;
5537: LD_ADDR_VAR 0 2
5541: PUSH
5542: LD_INT 1
5544: PPUSH
5545: LD_INT 6
5547: PPUSH
5548: CALL_OW 12
5552: ST_TO_ADDR
// if not See ( 7 , i ) then
5553: LD_INT 7
5555: PPUSH
5556: LD_VAR 0 1
5560: PPUSH
5561: CALL_OW 292
5565: NOT
5566: IFFALSE 5607
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
5568: LD_VAR 0 1
5572: PPUSH
5573: LD_VAR 0 3
5577: PUSH
5578: LD_VAR 0 2
5582: ARRAY
5583: PUSH
5584: LD_INT 1
5586: ARRAY
5587: PPUSH
5588: LD_VAR 0 3
5592: PUSH
5593: LD_VAR 0 2
5597: ARRAY
5598: PUSH
5599: LD_INT 2
5601: ARRAY
5602: PPUSH
5603: CALL_OW 114
// end ; end ;
5607: GO 5519
5609: POP
5610: POP
// end ;
5611: PPOPN 3
5613: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
5614: LD_EXP 21
5618: PUSH
5619: LD_EXP 7
5623: NOT
5624: AND
5625: IFFALSE 5696
5627: GO 5629
5629: DISABLE
5630: LD_INT 0
5632: PPUSH
// begin enable ;
5633: ENABLE
// for i in vehGuard do
5634: LD_ADDR_VAR 0 1
5638: PUSH
5639: LD_EXP 21
5643: PUSH
5644: FOR_IN
5645: IFFALSE 5694
// if IsOk ( vehGuard ) then
5647: LD_EXP 21
5651: PPUSH
5652: CALL_OW 302
5656: IFFALSE 5692
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
5658: LD_VAR 0 1
5662: PPUSH
5663: LD_INT 22
5665: PUSH
5666: LD_INT 7
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PPUSH
5673: CALL_OW 69
5677: PPUSH
5678: LD_VAR 0 1
5682: PPUSH
5683: CALL_OW 74
5687: PPUSH
5688: CALL_OW 115
5692: GO 5644
5694: POP
5695: POP
// end ;
5696: PPOPN 1
5698: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
5699: LD_EXP 4
5703: PUSH
5704: LD_INT 43
5706: PPUSH
5707: CALL_OW 302
5711: AND
5712: PUSH
5713: LD_EXP 7
5717: NOT
5718: AND
5719: IFFALSE 5767
5721: GO 5723
5723: DISABLE
// begin enable ;
5724: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
5725: LD_INT 43
5727: PPUSH
5728: LD_INT 5
5730: PPUSH
5731: LD_INT 3
5733: PPUSH
5734: LD_INT 2
5736: PPUSH
5737: LD_INT 7
5739: PUSH
5740: LD_INT 7
5742: PUSH
5743: LD_INT 9
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_INT 1
5753: PPUSH
5754: LD_INT 3
5756: PPUSH
5757: CALL_OW 12
5761: ARRAY
5762: PPUSH
5763: CALL_OW 125
// end ;
5767: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
5768: LD_INT 22
5770: PUSH
5771: LD_INT 1
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: PUSH
5778: LD_INT 25
5780: PUSH
5781: LD_INT 5
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_INT 50
5790: PUSH
5791: EMPTY
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: LIST
5798: PPUSH
5799: CALL_OW 69
5803: PUSH
5804: LD_EXP 7
5808: NOT
5809: AND
5810: IFFALSE 6039
5812: GO 5814
5814: DISABLE
5815: LD_INT 0
5817: PPUSH
5818: PPUSH
// begin enable ;
5819: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
5820: LD_ADDR_VAR 0 1
5824: PUSH
5825: LD_INT 22
5827: PUSH
5828: LD_INT 1
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PUSH
5835: LD_INT 25
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 50
5847: PUSH
5848: EMPTY
5849: LIST
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: LIST
5855: PPUSH
5856: CALL_OW 69
5860: ST_TO_ADDR
// if not tmp then
5861: LD_VAR 0 1
5865: NOT
5866: IFFALSE 5870
// exit ;
5868: GO 6039
// b := IsInUnit ( tmp [ 1 ] ) ;
5870: LD_ADDR_VAR 0 2
5874: PUSH
5875: LD_VAR 0 1
5879: PUSH
5880: LD_INT 1
5882: ARRAY
5883: PPUSH
5884: CALL_OW 310
5888: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
5889: LD_VAR 0 2
5893: NOT
5894: PUSH
5895: LD_VAR 0 1
5899: PUSH
5900: LD_INT 1
5902: ARRAY
5903: PPUSH
5904: CALL_OW 314
5908: OR
5909: IFFALSE 5913
// exit ;
5911: GO 6039
// if b = us_bun1 then
5913: LD_VAR 0 2
5917: PUSH
5918: LD_INT 80
5920: EQUAL
5921: IFFALSE 5982
// begin ComExitBuilding ( tmp [ 1 ] ) ;
5923: LD_VAR 0 1
5927: PUSH
5928: LD_INT 1
5930: ARRAY
5931: PPUSH
5932: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
5936: LD_VAR 0 1
5940: PUSH
5941: LD_INT 1
5943: ARRAY
5944: PPUSH
5945: LD_INT 27
5947: PPUSH
5948: LD_INT 44
5950: PPUSH
5951: CALL_OW 174
// if IsOk ( us_bun2 ) then
5955: LD_INT 55
5957: PPUSH
5958: CALL_OW 302
5962: IFFALSE 5980
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
5964: LD_VAR 0 1
5968: PUSH
5969: LD_INT 1
5971: ARRAY
5972: PPUSH
5973: LD_INT 55
5975: PPUSH
5976: CALL_OW 180
// end else
5980: GO 6039
// begin ComExitBuilding ( tmp [ 1 ] ) ;
5982: LD_VAR 0 1
5986: PUSH
5987: LD_INT 1
5989: ARRAY
5990: PPUSH
5991: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
5995: LD_VAR 0 1
5999: PUSH
6000: LD_INT 1
6002: ARRAY
6003: PPUSH
6004: LD_INT 92
6006: PPUSH
6007: LD_INT 51
6009: PPUSH
6010: CALL_OW 174
// if IsOk ( us_bun1 ) then
6014: LD_INT 80
6016: PPUSH
6017: CALL_OW 302
6021: IFFALSE 6039
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6023: LD_VAR 0 1
6027: PUSH
6028: LD_INT 1
6030: ARRAY
6031: PPUSH
6032: LD_INT 80
6034: PPUSH
6035: CALL_OW 180
// end ; end ;
6039: PPOPN 2
6041: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6042: LD_EXP 7
6046: NOT
6047: PUSH
6048: LD_INT 9
6050: PPUSH
6051: LD_INT 22
6053: PUSH
6054: LD_INT 1
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: PUSH
6061: LD_INT 21
6063: PUSH
6064: LD_INT 3
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: PUSH
6071: LD_INT 3
6073: PUSH
6074: LD_INT 24
6076: PUSH
6077: LD_INT 1000
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: LIST
6092: PPUSH
6093: CALL_OW 70
6097: AND
6098: IFFALSE 6509
6100: GO 6102
6102: DISABLE
6103: LD_INT 0
6105: PPUSH
6106: PPUSH
6107: PPUSH
6108: PPUSH
// begin enable ;
6109: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6110: LD_ADDR_VAR 0 2
6114: PUSH
6115: LD_INT 22
6117: PUSH
6118: LD_INT 1
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 25
6127: PUSH
6128: LD_INT 2
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: LD_INT 24
6137: PUSH
6138: LD_INT 1000
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL_OW 69
6154: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6155: LD_ADDR_VAR 0 3
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 1
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 25
6172: PUSH
6173: LD_INT 2
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: LD_INT 3
6182: PUSH
6183: LD_INT 24
6185: PUSH
6186: LD_INT 750
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PUSH
6197: EMPTY
6198: LIST
6199: LIST
6200: LIST
6201: PPUSH
6202: CALL_OW 69
6206: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6207: LD_ADDR_VAR 0 4
6211: PUSH
6212: LD_INT 9
6214: PPUSH
6215: LD_INT 22
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: LD_INT 21
6227: PUSH
6228: LD_INT 3
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 3
6237: PUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 1000
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: PPUSH
6257: CALL_OW 70
6261: PUSH
6262: LD_INT 1
6264: DIFF
6265: ST_TO_ADDR
// if not tmp and not tmp2 then
6266: LD_VAR 0 2
6270: NOT
6271: PUSH
6272: LD_VAR 0 3
6276: NOT
6277: AND
6278: IFFALSE 6282
// exit ;
6280: GO 6509
// if tmp and b then
6282: LD_VAR 0 2
6286: PUSH
6287: LD_VAR 0 4
6291: AND
6292: IFFALSE 6422
// for i in tmp do
6294: LD_ADDR_VAR 0 1
6298: PUSH
6299: LD_VAR 0 2
6303: PUSH
6304: FOR_IN
6305: IFFALSE 6420
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6307: LD_VAR 0 1
6311: PPUSH
6312: CALL_OW 110
6316: PUSH
6317: LD_INT 1
6319: EQUAL
6320: PUSH
6321: LD_VAR 0 1
6325: PPUSH
6326: CALL_OW 256
6330: PUSH
6331: LD_INT 1000
6333: LESS
6334: AND
6335: IFFALSE 6341
// continue else
6337: GO 6304
6339: GO 6368
// if GetTag ( i ) = 1 then
6341: LD_VAR 0 1
6345: PPUSH
6346: CALL_OW 110
6350: PUSH
6351: LD_INT 1
6353: EQUAL
6354: IFFALSE 6368
// SetTag ( i , 0 ) ;
6356: LD_VAR 0 1
6360: PPUSH
6361: LD_INT 0
6363: PPUSH
6364: CALL_OW 109
// if IsInUnit ( i ) then
6368: LD_VAR 0 1
6372: PPUSH
6373: CALL_OW 310
6377: IFFALSE 6388
// ComExitBuilding ( i ) ;
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 122
// if not HasTask ( i ) then
6388: LD_VAR 0 1
6392: PPUSH
6393: CALL_OW 314
6397: NOT
6398: IFFALSE 6418
// AddComRepairBuilding ( i , b [ 1 ] ) ;
6400: LD_VAR 0 1
6404: PPUSH
6405: LD_VAR 0 4
6409: PUSH
6410: LD_INT 1
6412: ARRAY
6413: PPUSH
6414: CALL_OW 190
// end ;
6418: GO 6304
6420: POP
6421: POP
// if tmp2 then
6422: LD_VAR 0 3
6426: IFFALSE 6509
// for i in tmp2 do
6428: LD_ADDR_VAR 0 1
6432: PUSH
6433: LD_VAR 0 3
6437: PUSH
6438: FOR_IN
6439: IFFALSE 6507
// begin if not GetTag ( i ) = 1 then
6441: LD_VAR 0 1
6445: PPUSH
6446: CALL_OW 110
6450: PUSH
6451: LD_INT 1
6453: EQUAL
6454: NOT
6455: IFFALSE 6469
// SetTag ( i , 1 ) ;
6457: LD_VAR 0 1
6461: PPUSH
6462: LD_INT 1
6464: PPUSH
6465: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
6469: LD_VAR 0 1
6473: PPUSH
6474: LD_INT 88
6476: PPUSH
6477: LD_INT 75
6479: PPUSH
6480: CALL_OW 297
6484: PUSH
6485: LD_INT 6
6487: GREATER
6488: IFFALSE 6505
// ComMoveXY ( i , 88 , 75 ) ;
6490: LD_VAR 0 1
6494: PPUSH
6495: LD_INT 88
6497: PPUSH
6498: LD_INT 75
6500: PPUSH
6501: CALL_OW 111
// end ;
6505: GO 6438
6507: POP
6508: POP
// end ;
6509: PPOPN 4
6511: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
6512: LD_EXP 7
6516: NOT
6517: PUSH
6518: LD_EXP 9
6522: AND
6523: PUSH
6524: LD_INT 9
6526: PPUSH
6527: LD_INT 22
6529: PUSH
6530: LD_INT 1
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: PUSH
6537: LD_INT 21
6539: PUSH
6540: LD_INT 1
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 24
6552: PUSH
6553: LD_INT 1000
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PUSH
6564: EMPTY
6565: LIST
6566: LIST
6567: LIST
6568: PPUSH
6569: CALL_OW 70
6573: AND
6574: IFFALSE 6747
6576: GO 6578
6578: DISABLE
6579: LD_INT 0
6581: PPUSH
6582: PPUSH
6583: PPUSH
// begin enable ;
6584: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
6585: LD_ADDR_VAR 0 2
6589: PUSH
6590: LD_INT 22
6592: PUSH
6593: LD_INT 1
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 25
6602: PUSH
6603: LD_INT 4
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PPUSH
6614: CALL_OW 69
6618: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6619: LD_ADDR_VAR 0 3
6623: PUSH
6624: LD_INT 9
6626: PPUSH
6627: LD_INT 22
6629: PUSH
6630: LD_INT 1
6632: PUSH
6633: EMPTY
6634: LIST
6635: LIST
6636: PUSH
6637: LD_INT 21
6639: PUSH
6640: LD_INT 1
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: LD_INT 3
6649: PUSH
6650: LD_INT 24
6652: PUSH
6653: LD_INT 1000
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: PPUSH
6669: CALL_OW 70
6673: ST_TO_ADDR
// if not sci or not tmp then
6674: LD_VAR 0 2
6678: NOT
6679: PUSH
6680: LD_VAR 0 3
6684: NOT
6685: OR
6686: IFFALSE 6690
// exit ;
6688: GO 6747
// for i in sci do
6690: LD_ADDR_VAR 0 1
6694: PUSH
6695: LD_VAR 0 2
6699: PUSH
6700: FOR_IN
6701: IFFALSE 6745
// if IsInUnit ( i ) then
6703: LD_VAR 0 1
6707: PPUSH
6708: CALL_OW 310
6712: IFFALSE 6725
// ComExitBuilding ( i ) else
6714: LD_VAR 0 1
6718: PPUSH
6719: CALL_OW 122
6723: GO 6743
// ComHeal ( i , tmp [ 1 ] ) ;
6725: LD_VAR 0 1
6729: PPUSH
6730: LD_VAR 0 3
6734: PUSH
6735: LD_INT 1
6737: ARRAY
6738: PPUSH
6739: CALL_OW 128
6743: GO 6700
6745: POP
6746: POP
// end ;
6747: PPOPN 3
6749: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
6750: LD_EXP 7
6754: NOT
6755: PUSH
6756: LD_EXP 9
6760: AND
6761: PUSH
6762: LD_INT 1
6764: PPUSH
6765: CALL_OW 302
6769: AND
6770: PUSH
6771: LD_INT 9
6773: PPUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 21
6786: PUSH
6787: LD_INT 1
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 24
6799: PUSH
6800: LD_INT 1000
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 70
6820: NOT
6821: AND
6822: PUSH
6823: LD_INT 22
6825: PUSH
6826: LD_INT 1
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: PUSH
6833: LD_INT 25
6835: PUSH
6836: LD_INT 4
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 56
6845: PUSH
6846: EMPTY
6847: LIST
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: LIST
6853: PPUSH
6854: CALL_OW 69
6858: AND
6859: IFFALSE 6952
6861: GO 6863
6863: DISABLE
6864: LD_INT 0
6866: PPUSH
// begin enable ;
6867: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
6868: LD_ADDR_VAR 0 1
6872: PUSH
6873: LD_INT 22
6875: PUSH
6876: LD_INT 1
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 25
6885: PUSH
6886: LD_INT 4
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: LD_INT 56
6895: PUSH
6896: EMPTY
6897: LIST
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: LIST
6903: PPUSH
6904: CALL_OW 69
6908: PUSH
6909: FOR_IN
6910: IFFALSE 6950
// if not GetTag ( i ) and not HasTask ( i ) then
6912: LD_VAR 0 1
6916: PPUSH
6917: CALL_OW 110
6921: NOT
6922: PUSH
6923: LD_VAR 0 1
6927: PPUSH
6928: CALL_OW 314
6932: NOT
6933: AND
6934: IFFALSE 6948
// ComEnterUnit ( i , us_lab ) ;
6936: LD_VAR 0 1
6940: PPUSH
6941: LD_INT 1
6943: PPUSH
6944: CALL_OW 120
6948: GO 6909
6950: POP
6951: POP
// end ;
6952: PPOPN 1
6954: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
6955: LD_EXP 7
6959: NOT
6960: PUSH
6961: LD_INT 9
6963: PPUSH
6964: LD_INT 22
6966: PUSH
6967: LD_INT 1
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 21
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 3
6986: PUSH
6987: LD_INT 24
6989: PUSH
6990: LD_INT 1000
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: LIST
7005: PPUSH
7006: CALL_OW 70
7010: NOT
7011: AND
7012: PUSH
7013: LD_INT 22
7015: PUSH
7016: LD_INT 1
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 25
7025: PUSH
7026: LD_INT 2
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 56
7035: PUSH
7036: EMPTY
7037: LIST
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: PPUSH
7044: CALL_OW 69
7048: AND
7049: IFFALSE 7142
7051: GO 7053
7053: DISABLE
7054: LD_INT 0
7056: PPUSH
// begin enable ;
7057: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7058: LD_ADDR_VAR 0 1
7062: PUSH
7063: LD_INT 22
7065: PUSH
7066: LD_INT 1
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: PUSH
7073: LD_INT 25
7075: PUSH
7076: LD_INT 2
7078: PUSH
7079: EMPTY
7080: LIST
7081: LIST
7082: PUSH
7083: LD_INT 56
7085: PUSH
7086: EMPTY
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 69
7098: PUSH
7099: FOR_IN
7100: IFFALSE 7140
// if not HasTask ( i ) and not GetTag ( i ) then
7102: LD_VAR 0 1
7106: PPUSH
7107: CALL_OW 314
7111: NOT
7112: PUSH
7113: LD_VAR 0 1
7117: PPUSH
7118: CALL_OW 110
7122: NOT
7123: AND
7124: IFFALSE 7138
// ComEnterUnit ( i , us_depot ) ;
7126: LD_VAR 0 1
7130: PPUSH
7131: LD_INT 5
7133: PPUSH
7134: CALL_OW 120
7138: GO 7099
7140: POP
7141: POP
// end ;
7142: PPOPN 1
7144: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
7145: LD_EXP 9
7149: PUSH
7150: LD_INT 0
7152: LESSEQUAL
7153: PUSH
7154: LD_EXP 16
7158: PPUSH
7159: CALL_OW 301
7163: OR
7164: PUSH
7165: LD_INT 22
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: LD_INT 25
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PPUSH
7189: CALL_OW 69
7193: AND
7194: IFFALSE 7235
7196: GO 7198
7198: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) , us_lab ) ;
7199: LD_INT 22
7201: PUSH
7202: LD_INT 1
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: LD_INT 25
7211: PUSH
7212: LD_INT 4
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PPUSH
7223: CALL_OW 69
7227: PPUSH
7228: LD_INT 1
7230: PPUSH
7231: CALL_OW 167
7235: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7236: LD_EXP 7
7240: NOT
7241: PUSH
7242: LD_INT 7
7244: PPUSH
7245: LD_INT 22
7247: PUSH
7248: LD_INT 7
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 70
7259: AND
7260: IFFALSE 7351
7262: GO 7264
7264: DISABLE
7265: LD_INT 0
7267: PPUSH
// begin wait ( 0 0$2 ) ;
7268: LD_INT 70
7270: PPUSH
7271: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7275: LD_ADDR_VAR 0 1
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 25
7292: PUSH
7293: LD_INT 1
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: PPUSH
7304: CALL_OW 69
7308: PUSH
7309: FOR_IN
7310: IFFALSE 7349
// begin if IsInUnit ( i ) then
7312: LD_VAR 0 1
7316: PPUSH
7317: CALL_OW 310
7321: IFFALSE 7332
// ComExitBuilding ( i ) ;
7323: LD_VAR 0 1
7327: PPUSH
7328: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7332: LD_VAR 0 1
7336: PPUSH
7337: LD_INT 92
7339: PPUSH
7340: LD_INT 78
7342: PPUSH
7343: CALL_OW 174
// end ;
7347: GO 7309
7349: POP
7350: POP
// end ; end_of_file
7351: PPOPN 1
7353: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7354: LD_VAR 0 1
7358: PPUSH
7359: LD_VAR 0 2
7363: PPUSH
7364: LD_VAR 0 3
7368: PPUSH
7369: CALL 2786 0 3
7373: PPOPN 3
7375: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7376: LD_EXP 12
7380: PPUSH
7381: CALL_OW 257
7385: PUSH
7386: LD_INT 4
7388: EQUAL
7389: PUSH
7390: LD_EXP 13
7394: PPUSH
7395: CALL_OW 257
7399: PUSH
7400: LD_INT 4
7402: EQUAL
7403: OR
7404: IFFALSE 7408
// exit ;
7406: GO 7446
// if un = JMM then
7408: LD_VAR 0 1
7412: PUSH
7413: LD_EXP 12
7417: EQUAL
7418: IFFALSE 7427
// YouLost ( JMM ) ;
7420: LD_STRING JMM
7422: PPUSH
7423: CALL_OW 104
// if un = Burlak then
7427: LD_VAR 0 1
7431: PUSH
7432: LD_EXP 13
7436: EQUAL
7437: IFFALSE 7446
// YouLost ( Burlak ) ;
7439: LD_STRING Burlak
7441: PPUSH
7442: CALL_OW 104
// end ;
7446: PPOPN 1
7448: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7449: LD_VAR 0 1
7453: PUSH
7454: LD_EXP 12
7458: EQUAL
7459: IFFALSE 7468
// YouLost ( JMM ) ;
7461: LD_STRING JMM
7463: PPUSH
7464: CALL_OW 104
// if un = Burlak then
7468: LD_VAR 0 1
7472: PUSH
7473: LD_EXP 13
7477: EQUAL
7478: IFFALSE 7487
// YouLost ( Burlak ) ;
7480: LD_STRING Burlak
7482: PPUSH
7483: CALL_OW 104
// end ;
7487: PPOPN 1
7489: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
7490: LD_VAR 0 1
7494: PPUSH
7495: CALL_OW 255
7499: PUSH
7500: LD_INT 7
7502: EQUAL
7503: IFFALSE 7513
// artifactPickedUp := true ;
7505: LD_ADDR_EXP 6
7509: PUSH
7510: LD_INT 1
7512: ST_TO_ADDR
// end ;
7513: PPOPN 2
7515: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
7516: LD_ADDR_EXP 6
7520: PUSH
7521: LD_INT 0
7523: ST_TO_ADDR
7524: PPOPN 2
7526: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
7527: LD_VAR 0 1
7531: PPUSH
7532: CALL_OW 255
7536: PUSH
7537: LD_INT 1
7539: NONEQUAL
7540: IFFALSE 7544
// exit ;
7542: GO 7591
// wait ( 0 0$5 ) ;
7544: LD_INT 175
7546: PPUSH
7547: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
7551: LD_VAR 0 1
7555: PPUSH
7556: CALL_OW 263
7560: PUSH
7561: LD_INT 2
7563: EQUAL
7564: IFFALSE 7575
// Connect ( vehicle ) ;
7566: LD_VAR 0 1
7570: PPUSH
7571: CALL 1787 0 1
// vehGuard := vehGuard ^ vehicle ;
7575: LD_ADDR_EXP 21
7579: PUSH
7580: LD_EXP 21
7584: PUSH
7585: LD_VAR 0 1
7589: ADD
7590: ST_TO_ADDR
// end ; end_of_file
7591: PPOPN 2
7593: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
7594: GO 7596
7596: DISABLE
// begin ru_radar := 98 ;
7597: LD_ADDR_EXP 22
7601: PUSH
7602: LD_INT 98
7604: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
7605: LD_ADDR_EXP 23
7609: PUSH
7610: LD_INT 89
7612: ST_TO_ADDR
// us_hack := 99 ;
7613: LD_ADDR_EXP 24
7617: PUSH
7618: LD_INT 99
7620: ST_TO_ADDR
// us_artillery := 97 ;
7621: LD_ADDR_EXP 25
7625: PUSH
7626: LD_INT 97
7628: ST_TO_ADDR
// ar_bio_bomb := 91 ;
7629: LD_ADDR_EXP 26
7633: PUSH
7634: LD_INT 91
7636: ST_TO_ADDR
// end ;
7637: END
