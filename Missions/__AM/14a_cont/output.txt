// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5335 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2178 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1633 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1633 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// if mastodonts then
1058: LD_VAR 0 6
1062: IFFALSE 1129
// for i = 1 to mastodonts do
1064: LD_ADDR_VAR 0 11
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 6
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1127
// begin vc_chassis := 31 ;
1082: LD_ADDR_OWVAR 37
1086: PUSH
1087: LD_INT 31
1089: ST_TO_ADDR
// vc_control := control_rider ;
1090: LD_ADDR_OWVAR 38
1094: PUSH
1095: LD_INT 4
1097: ST_TO_ADDR
// animal := CreateVehicle ;
1098: LD_ADDR_VAR 0 12
1102: PUSH
1103: CALL_OW 45
1107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1108: LD_VAR 0 12
1112: PPUSH
1113: LD_VAR 0 8
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL 1633 0 3
// end ;
1125: GO 1079
1127: POP
1128: POP
// if horses then
1129: LD_VAR 0 5
1133: IFFALSE 1200
// for i = 1 to horses do
1135: LD_ADDR_VAR 0 11
1139: PUSH
1140: DOUBLE
1141: LD_INT 1
1143: DEC
1144: ST_TO_ADDR
1145: LD_VAR 0 5
1149: PUSH
1150: FOR_TO
1151: IFFALSE 1198
// begin hc_class := 21 ;
1153: LD_ADDR_OWVAR 28
1157: PUSH
1158: LD_INT 21
1160: ST_TO_ADDR
// hc_gallery :=  ;
1161: LD_ADDR_OWVAR 33
1165: PUSH
1166: LD_STRING 
1168: ST_TO_ADDR
// animal := CreateHuman ;
1169: LD_ADDR_VAR 0 12
1173: PUSH
1174: CALL_OW 44
1178: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1179: LD_VAR 0 12
1183: PPUSH
1184: LD_VAR 0 8
1188: PPUSH
1189: LD_INT 0
1191: PPUSH
1192: CALL 1633 0 3
// end ;
1196: GO 1150
1198: POP
1199: POP
// if birds then
1200: LD_VAR 0 1
1204: IFFALSE 1271
// for i = 1 to birds do
1206: LD_ADDR_VAR 0 11
1210: PUSH
1211: DOUBLE
1212: LD_INT 1
1214: DEC
1215: ST_TO_ADDR
1216: LD_VAR 0 1
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1269
// begin hc_class = 18 ;
1224: LD_ADDR_OWVAR 28
1228: PUSH
1229: LD_INT 18
1231: ST_TO_ADDR
// hc_gallery =  ;
1232: LD_ADDR_OWVAR 33
1236: PUSH
1237: LD_STRING 
1239: ST_TO_ADDR
// animal := CreateHuman ;
1240: LD_ADDR_VAR 0 12
1244: PUSH
1245: CALL_OW 44
1249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1250: LD_VAR 0 12
1254: PPUSH
1255: LD_VAR 0 8
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL 1633 0 3
// end ;
1267: GO 1221
1269: POP
1270: POP
// if tigers then
1271: LD_VAR 0 2
1275: IFFALSE 1359
// for i = 1 to tigers do
1277: LD_ADDR_VAR 0 11
1281: PUSH
1282: DOUBLE
1283: LD_INT 1
1285: DEC
1286: ST_TO_ADDR
1287: LD_VAR 0 2
1291: PUSH
1292: FOR_TO
1293: IFFALSE 1357
// begin hc_class = class_tiger ;
1295: LD_ADDR_OWVAR 28
1299: PUSH
1300: LD_INT 14
1302: ST_TO_ADDR
// hc_gallery =  ;
1303: LD_ADDR_OWVAR 33
1307: PUSH
1308: LD_STRING 
1310: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1311: LD_ADDR_OWVAR 35
1315: PUSH
1316: LD_INT 7
1318: NEG
1319: PPUSH
1320: LD_INT 7
1322: PPUSH
1323: CALL_OW 12
1327: ST_TO_ADDR
// animal := CreateHuman ;
1328: LD_ADDR_VAR 0 12
1332: PUSH
1333: CALL_OW 44
1337: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1338: LD_VAR 0 12
1342: PPUSH
1343: LD_VAR 0 8
1347: PPUSH
1348: LD_INT 0
1350: PPUSH
1351: CALL 1633 0 3
// end ;
1355: GO 1292
1357: POP
1358: POP
// if apemans then
1359: LD_VAR 0 3
1363: IFFALSE 1486
// for i = 1 to apemans do
1365: LD_ADDR_VAR 0 11
1369: PUSH
1370: DOUBLE
1371: LD_INT 1
1373: DEC
1374: ST_TO_ADDR
1375: LD_VAR 0 3
1379: PUSH
1380: FOR_TO
1381: IFFALSE 1484
// begin hc_class = class_apeman ;
1383: LD_ADDR_OWVAR 28
1387: PUSH
1388: LD_INT 12
1390: ST_TO_ADDR
// hc_gallery =  ;
1391: LD_ADDR_OWVAR 33
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1399: LD_ADDR_OWVAR 35
1403: PUSH
1404: LD_INT 5
1406: NEG
1407: PPUSH
1408: LD_INT 5
1410: PPUSH
1411: CALL_OW 12
1415: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1416: LD_ADDR_OWVAR 31
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_INT 3
1426: PPUSH
1427: CALL_OW 12
1431: PUSH
1432: LD_INT 1
1434: PPUSH
1435: LD_INT 3
1437: PPUSH
1438: CALL_OW 12
1442: PUSH
1443: LD_INT 0
1445: PUSH
1446: LD_INT 0
1448: PUSH
1449: EMPTY
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: ST_TO_ADDR
// animal := CreateHuman ;
1455: LD_ADDR_VAR 0 12
1459: PUSH
1460: CALL_OW 44
1464: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1465: LD_VAR 0 12
1469: PPUSH
1470: LD_VAR 0 8
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL 1633 0 3
// end ;
1482: GO 1380
1484: POP
1485: POP
// if enchidnas then
1486: LD_VAR 0 4
1490: IFFALSE 1557
// for i = 1 to enchidnas do
1492: LD_ADDR_VAR 0 11
1496: PUSH
1497: DOUBLE
1498: LD_INT 1
1500: DEC
1501: ST_TO_ADDR
1502: LD_VAR 0 4
1506: PUSH
1507: FOR_TO
1508: IFFALSE 1555
// begin hc_class = 13 ;
1510: LD_ADDR_OWVAR 28
1514: PUSH
1515: LD_INT 13
1517: ST_TO_ADDR
// hc_gallery =  ;
1518: LD_ADDR_OWVAR 33
1522: PUSH
1523: LD_STRING 
1525: ST_TO_ADDR
// animal := CreateHuman ;
1526: LD_ADDR_VAR 0 12
1530: PUSH
1531: CALL_OW 44
1535: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1536: LD_VAR 0 12
1540: PPUSH
1541: LD_VAR 0 8
1545: PPUSH
1546: LD_INT 0
1548: PPUSH
1549: CALL 1633 0 3
// end ;
1553: GO 1507
1555: POP
1556: POP
// if fishes then
1557: LD_VAR 0 7
1561: IFFALSE 1628
// for i = 1 to fishes do
1563: LD_ADDR_VAR 0 11
1567: PUSH
1568: DOUBLE
1569: LD_INT 1
1571: DEC
1572: ST_TO_ADDR
1573: LD_VAR 0 7
1577: PUSH
1578: FOR_TO
1579: IFFALSE 1626
// begin hc_class = 20 ;
1581: LD_ADDR_OWVAR 28
1585: PUSH
1586: LD_INT 20
1588: ST_TO_ADDR
// hc_gallery =  ;
1589: LD_ADDR_OWVAR 33
1593: PUSH
1594: LD_STRING 
1596: ST_TO_ADDR
// animal := CreateHuman ;
1597: LD_ADDR_VAR 0 12
1601: PUSH
1602: CALL_OW 44
1606: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1607: LD_VAR 0 12
1611: PPUSH
1612: LD_VAR 0 9
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: CALL 1633 0 3
// end ;
1624: GO 1578
1626: POP
1627: POP
// end ;
1628: LD_VAR 0 10
1632: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1633: LD_INT 0
1635: PPUSH
1636: PPUSH
1637: PPUSH
1638: PPUSH
// if not unit or not area then
1639: LD_VAR 0 1
1643: NOT
1644: PUSH
1645: LD_VAR 0 2
1649: NOT
1650: OR
1651: IFFALSE 1655
// exit ;
1653: GO 1819
// tmp := AreaToList ( area , i ) ;
1655: LD_ADDR_VAR 0 6
1659: PUSH
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_VAR 0 5
1669: PPUSH
1670: CALL_OW 517
1674: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_VAR 0 6
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1817
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1697: LD_ADDR_VAR 0 7
1701: PUSH
1702: LD_VAR 0 6
1706: PUSH
1707: LD_INT 1
1709: ARRAY
1710: PUSH
1711: LD_VAR 0 5
1715: ARRAY
1716: PUSH
1717: LD_VAR 0 6
1721: PUSH
1722: LD_INT 2
1724: ARRAY
1725: PUSH
1726: LD_VAR 0 5
1730: ARRAY
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1736: LD_VAR 0 7
1740: PUSH
1741: LD_INT 1
1743: ARRAY
1744: PPUSH
1745: LD_VAR 0 7
1749: PUSH
1750: LD_INT 2
1752: ARRAY
1753: PPUSH
1754: CALL_OW 428
1758: PUSH
1759: LD_INT 0
1761: EQUAL
1762: IFFALSE 1815
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1764: LD_VAR 0 1
1768: PPUSH
1769: LD_VAR 0 7
1773: PUSH
1774: LD_INT 1
1776: ARRAY
1777: PPUSH
1778: LD_VAR 0 7
1782: PUSH
1783: LD_INT 2
1785: ARRAY
1786: PPUSH
1787: LD_VAR 0 3
1791: PPUSH
1792: CALL_OW 48
// result := IsPlaced ( unit ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 305
1810: ST_TO_ADDR
// exit ;
1811: POP
1812: POP
1813: GO 1819
// end ; end ;
1815: GO 1694
1817: POP
1818: POP
// end ;
1819: LD_VAR 0 4
1823: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1824: LD_INT 0
1826: PPUSH
1827: PPUSH
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1832: LD_VAR 0 1
1836: NOT
1837: PUSH
1838: LD_VAR 0 1
1842: PPUSH
1843: CALL_OW 263
1847: PUSH
1848: LD_INT 2
1850: EQUAL
1851: NOT
1852: OR
1853: IFFALSE 1857
// exit ;
1855: GO 2173
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1857: LD_ADDR_VAR 0 6
1861: PUSH
1862: LD_INT 22
1864: PUSH
1865: LD_VAR 0 1
1869: PPUSH
1870: CALL_OW 255
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 30
1884: PUSH
1885: LD_INT 36
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 34
1894: PUSH
1895: LD_INT 31
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: PPUSH
1911: CALL_OW 69
1915: ST_TO_ADDR
// if not tmp then
1916: LD_VAR 0 6
1920: NOT
1921: IFFALSE 1925
// exit ;
1923: GO 2173
// result := [ ] ;
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: EMPTY
1931: ST_TO_ADDR
// for i in tmp do
1932: LD_ADDR_VAR 0 3
1936: PUSH
1937: LD_VAR 0 6
1941: PUSH
1942: FOR_IN
1943: IFFALSE 2014
// begin t := UnitsInside ( i ) ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 313
1959: ST_TO_ADDR
// if t then
1960: LD_VAR 0 4
1964: IFFALSE 2012
// for j in t do
1966: LD_ADDR_VAR 0 7
1970: PUSH
1971: LD_VAR 0 4
1975: PUSH
1976: FOR_IN
1977: IFFALSE 2010
// result := Insert ( result , result + 1 , j ) ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_VAR 0 2
1988: PPUSH
1989: LD_VAR 0 2
1993: PUSH
1994: LD_INT 1
1996: PLUS
1997: PPUSH
1998: LD_VAR 0 7
2002: PPUSH
2003: CALL_OW 2
2007: ST_TO_ADDR
2008: GO 1976
2010: POP
2011: POP
// end ;
2012: GO 1942
2014: POP
2015: POP
// if not result then
2016: LD_VAR 0 2
2020: NOT
2021: IFFALSE 2025
// exit ;
2023: GO 2173
// mech := result [ 1 ] ;
2025: LD_ADDR_VAR 0 5
2029: PUSH
2030: LD_VAR 0 2
2034: PUSH
2035: LD_INT 1
2037: ARRAY
2038: ST_TO_ADDR
// if result > 1 then
2039: LD_VAR 0 2
2043: PUSH
2044: LD_INT 1
2046: GREATER
2047: IFFALSE 2159
// for i = 2 to result do
2049: LD_ADDR_VAR 0 3
2053: PUSH
2054: DOUBLE
2055: LD_INT 2
2057: DEC
2058: ST_TO_ADDR
2059: LD_VAR 0 2
2063: PUSH
2064: FOR_TO
2065: IFFALSE 2157
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2067: LD_ADDR_VAR 0 4
2071: PUSH
2072: LD_VAR 0 2
2076: PUSH
2077: LD_VAR 0 3
2081: ARRAY
2082: PPUSH
2083: LD_INT 3
2085: PPUSH
2086: CALL_OW 259
2090: PUSH
2091: LD_VAR 0 2
2095: PUSH
2096: LD_VAR 0 3
2100: ARRAY
2101: PPUSH
2102: CALL_OW 432
2106: MINUS
2107: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2108: LD_VAR 0 4
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_INT 3
2120: PPUSH
2121: CALL_OW 259
2125: PUSH
2126: LD_VAR 0 5
2130: PPUSH
2131: CALL_OW 432
2135: MINUS
2136: GREATEREQUAL
2137: IFFALSE 2155
// mech := result [ i ] ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 2
2148: PUSH
2149: LD_VAR 0 3
2153: ARRAY
2154: ST_TO_ADDR
// end ;
2155: GO 2064
2157: POP
2158: POP
// ComLinkTo ( vehicle , mech ) ;
2159: LD_VAR 0 1
2163: PPUSH
2164: LD_VAR 0 5
2168: PPUSH
2169: CALL_OW 135
// end ; end_of_file
2173: LD_VAR 0 2
2177: RET
// export function Action ; begin
2178: LD_INT 0
2180: PPUSH
// InGameOn ;
2181: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2185: LD_INT 221
2187: PPUSH
2188: LD_INT 80
2190: PPUSH
2191: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2195: LD_EXP 14
2199: PUSH
2200: LD_EXP 15
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: LD_INT 217
2211: PPUSH
2212: LD_INT 79
2214: PPUSH
2215: CALL_OW 111
// wait ( 0 0$7 ) ;
2219: LD_INT 245
2221: PPUSH
2222: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2226: LD_EXP 14
2230: PUSH
2231: LD_EXP 15
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2244: LD_EXP 15
2248: PPUSH
2249: LD_STRING D2-Bur-1
2251: PPUSH
2252: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2256: LD_EXP 14
2260: PPUSH
2261: LD_STRING D2-JMM-1
2263: PPUSH
2264: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2268: LD_INT 18
2270: PPUSH
2271: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2275: LD_EXP 15
2279: PPUSH
2280: LD_EXP 14
2284: PPUSH
2285: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2289: LD_EXP 15
2293: PPUSH
2294: LD_STRING D2-Bur-2
2296: PPUSH
2297: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2301: LD_EXP 15
2305: PPUSH
2306: LD_INT 21
2308: PUSH
2309: LD_INT 2
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: PPUSH
2321: LD_EXP 15
2325: PPUSH
2326: CALL_OW 74
2330: PPUSH
2331: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_INT 21
2342: PUSH
2343: LD_INT 2
2345: PUSH
2346: EMPTY
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL_OW 69
2354: PPUSH
2355: LD_EXP 14
2359: PPUSH
2360: CALL_OW 74
2364: PPUSH
2365: CALL_OW 120
// wait ( 0 0$1 ) ;
2369: LD_INT 35
2371: PPUSH
2372: CALL_OW 67
// InGameOff ;
2376: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2380: LD_STRING MArtPickup
2382: PPUSH
2383: CALL_OW 337
// end ;
2387: LD_VAR 0 1
2391: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2392: LD_EXP 22
2396: PPUSH
2397: LD_INT 101
2399: PUSH
2400: LD_INT 7
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 72
2411: IFFALSE 2440
2413: GO 2415
2415: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2416: LD_EXP 15
2420: PPUSH
2421: LD_STRING D3-Bur-1
2423: PPUSH
2424: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2428: LD_EXP 14
2432: PPUSH
2433: LD_STRING D3-JMM-1
2435: PPUSH
2436: CALL_OW 88
// end ;
2440: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2441: LD_INT 5
2443: PPUSH
2444: LD_INT 22
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 70
2458: IFFALSE 2789
2460: GO 2462
2462: DISABLE
// begin wait ( 0 0$3 ) ;
2463: LD_INT 105
2465: PPUSH
2466: CALL_OW 67
// DialogueOn ;
2470: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2474: LD_EXP 14
2478: PPUSH
2479: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2483: LD_EXP 14
2487: PPUSH
2488: LD_STRING D3a-JMM-1
2490: PPUSH
2491: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2495: LD_EXP 15
2499: PPUSH
2500: LD_STRING D3a-Bur-1
2502: PPUSH
2503: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2507: LD_EXP 14
2511: PPUSH
2512: LD_STRING D3a-JMM-2
2514: PPUSH
2515: CALL_OW 88
// if Joan then
2519: LD_EXP 16
2523: IFFALSE 2539
// SayRadio ( Joan , D3a-Joan-2 ) else
2525: LD_EXP 16
2529: PPUSH
2530: LD_STRING D3a-Joan-2
2532: PPUSH
2533: CALL_OW 94
2537: GO 2551
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2539: LD_EXP 17
2543: PPUSH
2544: LD_STRING D3a-RSci1-2
2546: PPUSH
2547: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2551: LD_EXP 18
2555: PPUSH
2556: LD_STRING D3a-Huck-2
2558: PPUSH
2559: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2563: LD_EXP 19
2567: PPUSH
2568: LD_STRING D3a-Pow-2
2570: PPUSH
2571: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2575: LD_EXP 18
2579: PPUSH
2580: LD_STRING D3a-Huck-3
2582: PPUSH
2583: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2587: LD_EXP 19
2591: PPUSH
2592: LD_STRING D3a-Pow-3
2594: PPUSH
2595: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2599: LD_EXP 18
2603: PPUSH
2604: LD_STRING D3a-Huck-4
2606: PPUSH
2607: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2611: LD_EXP 14
2615: PPUSH
2616: LD_STRING D3a-JMM-4
2618: PPUSH
2619: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2623: LD_EXP 15
2627: PPUSH
2628: LD_STRING D3a-Bur-4
2630: PPUSH
2631: CALL_OW 88
// if Joan then
2635: LD_EXP 16
2639: IFFALSE 2655
// SayRadio ( Joan , D3a-Joan-4 ) else
2641: LD_EXP 16
2645: PPUSH
2646: LD_STRING D3a-Joan-4
2648: PPUSH
2649: CALL_OW 94
2653: GO 2667
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2655: LD_EXP 17
2659: PPUSH
2660: LD_STRING D3a-RSci1-4
2662: PPUSH
2663: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2667: LD_INT 133
2669: PPUSH
2670: LD_INT 43
2672: PPUSH
2673: LD_INT 7
2675: PPUSH
2676: LD_INT 10
2678: NEG
2679: PPUSH
2680: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2684: LD_INT 133
2686: PPUSH
2687: LD_INT 43
2689: PPUSH
2690: LD_INT 7
2692: PPUSH
2693: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2697: LD_INT 133
2699: PPUSH
2700: LD_INT 43
2702: PPUSH
2703: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2707: LD_INT 10
2709: PPUSH
2710: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2714: LD_EXP 14
2718: PPUSH
2719: LD_STRING D3a-JMM-5
2721: PPUSH
2722: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2726: LD_EXP 15
2730: PPUSH
2731: LD_STRING D3a-Bur-5
2733: PPUSH
2734: CALL_OW 88
// DialogueOff ;
2738: CALL_OW 7
// seenBase := true ;
2742: LD_ADDR_EXP 8
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2750: LD_INT 525
2752: PUSH
2753: LD_INT 420
2755: PUSH
2756: LD_INT 315
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2774: LD_EXP 21
2778: PPUSH
2779: LD_INT 142
2781: PPUSH
2782: LD_INT 52
2784: PPUSH
2785: CALL_OW 116
// end ;
2789: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2790: LD_EXP 8
2794: NOT
2795: PUSH
2796: LD_EXP 4
2800: NOT
2801: AND
2802: IFFALSE 2822
2804: GO 2806
2806: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2807: LD_EXP 21
2811: PPUSH
2812: LD_INT 142
2814: PPUSH
2815: LD_INT 52
2817: PPUSH
2818: CALL_OW 116
2822: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2823: LD_INT 0
2825: PPUSH
2826: PPUSH
// contaminateTime := tick ;
2827: LD_ADDR_EXP 3
2831: PUSH
2832: LD_OWVAR 1
2836: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2837: LD_INT 175
2839: PPUSH
2840: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_INT 4
2851: PPUSH
2852: CALL_OW 469
2856: ST_TO_ADDR
// if art then
2857: LD_VAR 0 5
2861: IFFALSE 2900
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2863: LD_VAR 0 5
2867: PUSH
2868: LD_INT 1
2870: ARRAY
2871: PUSH
2872: LD_INT 157
2874: EQUAL
2875: PUSH
2876: LD_VAR 0 5
2880: PUSH
2881: LD_INT 2
2883: ARRAY
2884: PUSH
2885: LD_INT 75
2887: EQUAL
2888: AND
2889: IFFALSE 2900
// begin YouLost ( Artefact ) ;
2891: LD_STRING Artefact
2893: PPUSH
2894: CALL_OW 104
// exit ;
2898: GO 3052
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2900: LD_EXP 14
2904: PPUSH
2905: CALL_OW 302
2909: PUSH
2910: LD_EXP 15
2914: PPUSH
2915: CALL_OW 302
2919: AND
2920: IFFALSE 2997
// begin DialogueOn ;
2922: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2926: LD_EXP 14
2930: PPUSH
2931: LD_STRING D6a-JMM-1
2933: PPUSH
2934: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2938: LD_EXP 15
2942: PPUSH
2943: LD_STRING D6a-Bur-1
2945: PPUSH
2946: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2950: LD_EXP 14
2954: PPUSH
2955: LD_STRING D6c-JMM-1
2957: PPUSH
2958: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2962: LD_EXP 15
2966: PPUSH
2967: LD_STRING D6c-Bur-1
2969: PPUSH
2970: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2974: LD_EXP 14
2978: PPUSH
2979: LD_STRING D6c-JMM-2
2981: PPUSH
2982: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2986: LD_STRING MBase
2988: PPUSH
2989: CALL_OW 337
// DialogueOff ;
2993: CALL_OW 7
// end ; bombExploded := true ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: LD_INT 1
3004: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3005: LD_INT 6300
3007: PUSH
3008: LD_INT 5250
3010: PUSH
3011: LD_INT 4200
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PPUSH
3025: CALL_OW 67
// if IsOk ( JMM ) then
3029: LD_EXP 14
3033: PPUSH
3034: CALL_OW 302
3038: IFFALSE 3052
// Say ( JMM , D8-JMM-1 ) ;
3040: LD_EXP 14
3044: PPUSH
3045: LD_STRING D8-JMM-1
3047: PPUSH
3048: CALL_OW 88
// end ;
3052: LD_VAR 0 4
3056: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3057: LD_EXP 9
3061: PUSH
3062: LD_EXP 7
3066: NOT
3067: AND
3068: PUSH
3069: LD_EXP 4
3073: AND
3074: IFFALSE 3129
3076: GO 3078
3078: DISABLE
// begin enable ;
3079: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3080: LD_INT 9
3082: PPUSH
3083: LD_INT 22
3085: PUSH
3086: LD_INT 7
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 70
3097: IFFALSE 3115
// stevensTimer := stevensTimer - 0 0$30 else
3099: LD_ADDR_EXP 9
3103: PUSH
3104: LD_EXP 9
3108: PUSH
3109: LD_INT 1050
3111: MINUS
3112: ST_TO_ADDR
3113: GO 3129
// stevensTimer := stevensTimer - 0 0$1 ;
3115: LD_ADDR_EXP 9
3119: PUSH
3120: LD_EXP 9
3124: PUSH
3125: LD_INT 35
3127: MINUS
3128: ST_TO_ADDR
// end ;
3129: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3130: LD_EXP 9
3134: PUSH
3135: LD_INT 0
3137: LESSEQUAL
3138: PUSH
3139: LD_EXP 7
3143: NOT
3144: AND
3145: IFFALSE 3309
3147: GO 3149
3149: DISABLE
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: ST_TO_ADDR
// for i in tmp do
3188: LD_ADDR_VAR 0 1
3192: PUSH
3193: LD_VAR 0 2
3197: PUSH
3198: FOR_IN
3199: IFFALSE 3252
// begin if IsInUnit ( i ) then
3201: LD_VAR 0 1
3205: PPUSH
3206: CALL_OW 310
3210: IFFALSE 3223
// ComExitBuilding ( i ) else
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 122
3221: GO 3250
// if not HasTask ( i ) then
3223: LD_VAR 0 1
3227: PPUSH
3228: CALL_OW 314
3232: NOT
3233: IFFALSE 3250
// ComMoveXY ( i , 29 , 56 ) ;
3235: LD_VAR 0 1
3239: PPUSH
3240: LD_INT 29
3242: PPUSH
3243: LD_INT 56
3245: PPUSH
3246: CALL_OW 111
// end ;
3250: GO 3198
3252: POP
3253: POP
// repeat wait ( 0 0$1 ) ;
3254: LD_INT 35
3256: PPUSH
3257: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3261: LD_INT 8
3263: PPUSH
3264: LD_INT 22
3266: PUSH
3267: LD_INT 1
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 25
3276: PUSH
3277: LD_INT 4
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL_OW 70
3292: IFFALSE 3254
// if planCaptured then
3294: LD_EXP 7
3298: IFFALSE 3302
// exit ;
3300: GO 3309
// YouLost ( Time ) ;
3302: LD_STRING Time
3304: PPUSH
3305: CALL_OW 104
// end ;
3309: PPOPN 2
3311: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3312: LD_INT 22
3314: PUSH
3315: LD_INT 7
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: LD_INT 92
3324: PUSH
3325: LD_INT 142
3327: PUSH
3328: LD_INT 52
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 69
3348: PUSH
3349: LD_EXP 3
3353: PUSH
3354: LD_INT 6000
3356: PLUS
3357: PUSH
3358: LD_OWVAR 1
3362: GREATER
3363: AND
3364: PUSH
3365: LD_EXP 4
3369: AND
3370: IFFALSE 3425
3372: GO 3374
3374: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3375: LD_EXP 14
3379: PUSH
3380: LD_EXP 15
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 85
// DialogueOn ;
3393: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3397: LD_EXP 14
3401: PPUSH
3402: LD_STRING D6b-JMM-1
3404: PPUSH
3405: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3409: LD_EXP 15
3413: PPUSH
3414: LD_STRING D6b-Bur-1
3416: PPUSH
3417: CALL_OW 88
// DialogueOff ;
3421: CALL_OW 7
// end ;
3425: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3426: LD_EXP 15
3430: PPUSH
3431: LD_INT 142
3433: PPUSH
3434: LD_INT 52
3436: PPUSH
3437: CALL_OW 297
3441: PUSH
3442: LD_INT 25
3444: LESS
3445: PUSH
3446: LD_EXP 15
3450: PPUSH
3451: CALL_OW 310
3455: PPUSH
3456: LD_INT 142
3458: PPUSH
3459: LD_INT 52
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 25
3469: LESS
3470: OR
3471: PUSH
3472: LD_EXP 15
3476: PPUSH
3477: CALL_OW 256
3481: PUSH
3482: LD_INT 1000
3484: LESS
3485: AND
3486: PUSH
3487: LD_EXP 3
3491: PUSH
3492: LD_INT 6000
3494: PLUS
3495: PUSH
3496: LD_OWVAR 1
3500: GREATER
3501: AND
3502: PUSH
3503: LD_EXP 4
3507: AND
3508: IFFALSE 3541
3510: GO 3512
3512: DISABLE
// begin DialogueOn ;
3513: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3517: LD_EXP 15
3521: PPUSH
3522: LD_STRING D7-Bur-1
3524: PPUSH
3525: CALL_OW 88
// enteredContaminatedArea := true ;
3529: LD_ADDR_EXP 5
3533: PUSH
3534: LD_INT 1
3536: ST_TO_ADDR
// DialogueOff ;
3537: CALL_OW 7
// end ;
3541: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3542: LD_EXP 14
3546: PPUSH
3547: LD_INT 142
3549: PPUSH
3550: LD_INT 52
3552: PPUSH
3553: CALL_OW 297
3557: PUSH
3558: LD_INT 25
3560: LESS
3561: PUSH
3562: LD_EXP 14
3566: PPUSH
3567: CALL_OW 310
3571: PPUSH
3572: LD_INT 142
3574: PPUSH
3575: LD_INT 52
3577: PPUSH
3578: CALL_OW 297
3582: PUSH
3583: LD_INT 25
3585: LESS
3586: OR
3587: PUSH
3588: LD_EXP 14
3592: PPUSH
3593: CALL_OW 256
3597: PUSH
3598: LD_INT 1000
3600: LESS
3601: AND
3602: PUSH
3603: LD_EXP 3
3607: PUSH
3608: LD_INT 6000
3610: PLUS
3611: PUSH
3612: LD_OWVAR 1
3616: GREATER
3617: AND
3618: PUSH
3619: LD_EXP 4
3623: AND
3624: IFFALSE 3657
3626: GO 3628
3628: DISABLE
// begin DialogueOn ;
3629: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3633: LD_EXP 14
3637: PPUSH
3638: LD_STRING D7-JMM-1
3640: PPUSH
3641: CALL_OW 88
// enteredContaminatedArea := true ;
3645: LD_ADDR_EXP 5
3649: PUSH
3650: LD_INT 1
3652: ST_TO_ADDR
// DialogueOff ;
3653: CALL_OW 7
// end ;
3657: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3658: LD_EXP 6
3662: PUSH
3663: LD_EXP 14
3667: PPUSH
3668: CALL_OW 302
3672: AND
3673: PUSH
3674: LD_EXP 15
3678: PPUSH
3679: CALL_OW 302
3683: AND
3684: IFFALSE 3753
3686: GO 3688
3688: DISABLE
// begin DialogueOn ;
3689: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3693: LD_EXP 14
3697: PUSH
3698: LD_EXP 15
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PPUSH
3707: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3711: LD_EXP 14
3715: PPUSH
3716: LD_STRING D4-JMM-1
3718: PPUSH
3719: CALL_OW 88
// if not bombExploded then
3723: LD_EXP 4
3727: NOT
3728: IFFALSE 3742
// Say ( Burlak , D4-Bur-1 ) ;
3730: LD_EXP 15
3734: PPUSH
3735: LD_STRING D4-Bur-1
3737: PPUSH
3738: CALL_OW 88
// DialogueOff ;
3742: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3746: LD_STRING MReturn
3748: PPUSH
3749: CALL_OW 337
// end ;
3753: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3754: LD_EXP 7
3758: NOT
3759: PUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 7
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 91
3772: PUSH
3773: LD_INT 9
3775: PUSH
3776: LD_INT 6
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PPUSH
3788: CALL_OW 69
3792: AND
3793: IFFALSE 3870
3795: GO 3797
3797: DISABLE
// begin DialogueOn ;
3798: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3802: LD_INT 55
3804: PPUSH
3805: LD_INT 11
3807: PPUSH
3808: LD_INT 7
3810: PPUSH
3811: LD_INT 6
3813: NEG
3814: PPUSH
3815: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3819: LD_INT 55
3821: PPUSH
3822: LD_INT 11
3824: PPUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3832: LD_EXP 15
3836: PPUSH
3837: LD_STRING D9-Bur-1
3839: PPUSH
3840: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3844: LD_EXP 14
3848: PPUSH
3849: LD_STRING D9-JMM-1
3851: PPUSH
3852: CALL_OW 88
// DialogueOff ;
3856: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3860: LD_INT 9
3862: PPUSH
3863: LD_INT 7
3865: PPUSH
3866: CALL_OW 235
// end ;
3870: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3871: LD_INT 9
3873: PPUSH
3874: LD_INT 22
3876: PUSH
3877: LD_INT 7
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 70
3888: IFFALSE 3924
3890: GO 3892
3892: DISABLE
// begin wait ( 0 0$07 ) ;
3893: LD_INT 245
3895: PPUSH
3896: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3900: LD_EXP 14
3904: PPUSH
3905: LD_STRING D10b-JMM-1
3907: PPUSH
3908: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3912: LD_EXP 15
3916: PPUSH
3917: LD_STRING D10b-Bur-1
3919: PPUSH
3920: CALL_OW 88
// end ;
3924: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3925: LD_EXP 9
3929: PUSH
3930: LD_INT 22
3932: PUSH
3933: LD_INT 1
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 4
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 26
3952: PUSH
3953: LD_INT 1
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: LIST
3964: PPUSH
3965: CALL_OW 69
3969: AND
3970: PUSH
3971: LD_INT 5
3973: PPUSH
3974: CALL_OW 255
3978: PUSH
3979: LD_INT 7
3981: EQUAL
3982: PUSH
3983: LD_INT 22
3985: PUSH
3986: LD_INT 1
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 25
3995: PUSH
3996: LD_INT 1
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: CALL_OW 69
4011: PUSH
4012: LD_INT 0
4014: EQUAL
4015: OR
4016: AND
4017: IFFALSE 4606
4019: GO 4021
4021: DISABLE
4022: LD_INT 0
4024: PPUSH
// begin case Query ( QKill ) of 1 :
4025: LD_STRING QKill
4027: PPUSH
4028: CALL_OW 97
4032: PUSH
4033: LD_INT 1
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4041
4039: GO 4594
4041: POP
// begin DialogueOn ;
4042: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4046: LD_EXP 14
4050: PPUSH
4051: LD_STRING D10a-JMM-1
4053: PPUSH
4054: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4058: LD_EXP 15
4062: PPUSH
4063: LD_STRING D10a-Bur-1
4065: PPUSH
4066: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4070: LD_EXP 14
4074: PPUSH
4075: LD_STRING D10a-JMM-2
4077: PPUSH
4078: CALL_OW 88
// if IsOk ( Stevens ) then
4082: LD_EXP 18
4086: PPUSH
4087: CALL_OW 302
4091: IFFALSE 4107
// Say ( Stevens , D10a-Huck-2 ) else
4093: LD_EXP 18
4097: PPUSH
4098: LD_STRING D10a-Huck-2
4100: PPUSH
4101: CALL_OW 88
4105: GO 4158
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4107: LD_INT 22
4109: PUSH
4110: LD_INT 1
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: LD_INT 25
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: LD_INT 26
4129: PUSH
4130: LD_INT 1
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: PPUSH
4151: LD_STRING D10a-ASci1-3
4153: PPUSH
4154: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4158: LD_EXP 14
4162: PPUSH
4163: LD_STRING D10a-JMM-4
4165: PPUSH
4166: CALL_OW 88
// if IsOk ( Stevens ) then
4170: LD_EXP 18
4174: PPUSH
4175: CALL_OW 302
4179: IFFALSE 4193
// Say ( Stevens , D10a-Huck-3 ) ;
4181: LD_EXP 18
4185: PPUSH
4186: LD_STRING D10a-Huck-3
4188: PPUSH
4189: CALL_OW 88
// DialogueOff ;
4193: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4197: LD_INT 1
4199: PPUSH
4200: LD_INT 7
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: CALL_OW 80
// planCaptured := true ;
4213: LD_ADDR_EXP 7
4217: PUSH
4218: LD_INT 1
4220: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4221: LD_STRING MEnd
4223: PPUSH
4224: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4228: LD_STRING ACH_DIPLOMACY
4230: PPUSH
4231: CALL_OW 543
// canEnd := true ;
4235: LD_ADDR_EXP 10
4239: PUSH
4240: LD_INT 1
4242: ST_TO_ADDR
// missionTime := tick ;
4243: LD_ADDR_EXP 11
4247: PUSH
4248: LD_OWVAR 1
4252: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4260: LD_INT 22
4262: PUSH
4263: LD_INT 1
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 3
4272: PUSH
4273: LD_INT 50
4275: PUSH
4276: EMPTY
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: IFFALSE 4407
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_INT 22
4300: PUSH
4301: LD_INT 1
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: LD_INT 25
4310: PUSH
4311: LD_INT 4
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PPUSH
4322: CALL_OW 69
4326: PUSH
4327: FOR_IN
4328: IFFALSE 4405
// begin if IsInUnit ( i ) then
4330: LD_VAR 0 1
4334: PPUSH
4335: CALL_OW 310
4339: IFFALSE 4352
// ComExitBuilding ( i ) else
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 122
4350: GO 4403
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: LD_INT 22
4359: PUSH
4360: LD_INT 1
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 3
4369: PUSH
4370: LD_INT 50
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PPUSH
4384: CALL_OW 69
4388: PPUSH
4389: LD_VAR 0 1
4393: PPUSH
4394: CALL_OW 74
4398: PPUSH
4399: CALL_OW 128
// end ;
4403: GO 4327
4405: POP
4406: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4407: LD_INT 22
4409: PUSH
4410: LD_INT 1
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 3
4419: PUSH
4420: LD_INT 50
4422: PUSH
4423: EMPTY
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: EMPTY
4431: LIST
4432: LIST
4433: PPUSH
4434: CALL_OW 69
4438: NOT
4439: IFFALSE 4253
// repeat wait ( 3 ) ;
4441: LD_INT 3
4443: PPUSH
4444: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4448: LD_ADDR_VAR 0 1
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_INT 1
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 21
4465: PUSH
4466: LD_INT 1
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PPUSH
4477: CALL_OW 69
4481: PUSH
4482: FOR_IN
4483: IFFALSE 4559
// begin if IsInArea ( i , stevensEscapeArea ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: LD_INT 8
4492: PPUSH
4493: CALL_OW 308
4497: IFFALSE 4510
// begin RemoveUnit ( i ) ;
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 64
// continue ;
4508: GO 4482
// end ; if IsInUnit ( i ) then
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 310
4519: IFFALSE 4530
// ComExitBuilding ( i ) ;
4521: LD_VAR 0 1
4525: PPUSH
4526: CALL_OW 122
// if not HasTask ( i ) then
4530: LD_VAR 0 1
4534: PPUSH
4535: CALL_OW 314
4539: NOT
4540: IFFALSE 4557
// ComMoveXY ( i , 28 , 55 ) ;
4542: LD_VAR 0 1
4546: PPUSH
4547: LD_INT 28
4549: PPUSH
4550: LD_INT 55
4552: PPUSH
4553: CALL_OW 111
// end ;
4557: GO 4482
4559: POP
4560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4561: LD_INT 22
4563: PUSH
4564: LD_INT 1
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 69
4589: NOT
4590: IFFALSE 4441
// end ; 2 :
4592: GO 4606
4594: LD_INT 2
4596: DOUBLE
4597: EQUAL
4598: IFTRUE 4602
4600: GO 4605
4602: POP
// ; end ;
4603: GO 4606
4605: POP
// end ;
4606: PPOPN 1
4608: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4609: LD_EXP 10
4613: IFFALSE 4970
4615: GO 4617
4617: DISABLE
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
4622: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4623: LD_INT 10
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: CALL_OW 424
// if Difficulty < 2 then
4633: LD_OWVAR 67
4637: PUSH
4638: LD_INT 2
4640: LESS
4641: IFFALSE 4645
// exit ;
4643: GO 4970
// uc_side := 4 ;
4645: LD_ADDR_OWVAR 20
4649: PUSH
4650: LD_INT 4
4652: ST_TO_ADDR
// uc_nation := 1 ;
4653: LD_ADDR_OWVAR 21
4657: PUSH
4658: LD_INT 1
4660: ST_TO_ADDR
// InitHc ;
4661: CALL_OW 19
// tmp := [ ] ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: EMPTY
4671: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4672: LD_INT 0
4674: PPUSH
4675: LD_INT 5
4677: PPUSH
4678: LD_INT 10
4680: PPUSH
4681: CALL_OW 380
// un := CreateHuman ;
4685: LD_ADDR_VAR 0 1
4689: PUSH
4690: CALL_OW 44
4694: ST_TO_ADDR
// tmp := [ un ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_VAR 0 1
4704: PUSH
4705: EMPTY
4706: LIST
4707: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4708: LD_VAR 0 1
4712: PPUSH
4713: LD_INT 226
4715: PPUSH
4716: LD_INT 86
4718: PPUSH
4719: LD_INT 0
4721: PPUSH
4722: CALL_OW 48
// ComHold ( un ) ;
4726: LD_VAR 0 1
4730: PPUSH
4731: CALL_OW 140
// for i = 1 to 3 do
4735: LD_ADDR_VAR 0 2
4739: PUSH
4740: DOUBLE
4741: LD_INT 1
4743: DEC
4744: ST_TO_ADDR
4745: LD_INT 3
4747: PUSH
4748: FOR_TO
4749: IFFALSE 4848
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4751: LD_INT 0
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: LD_INT 8
4759: PPUSH
4760: CALL_OW 380
// un := CreateHuman ;
4764: LD_ADDR_VAR 0 1
4768: PUSH
4769: CALL_OW 44
4773: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4774: LD_VAR 0 1
4778: PPUSH
4779: LD_INT 5
4781: PPUSH
4782: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4786: LD_VAR 0 1
4790: PPUSH
4791: LD_INT 215
4793: PUSH
4794: LD_INT 217
4796: PUSH
4797: LD_INT 219
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: LIST
4804: PUSH
4805: LD_VAR 0 2
4809: ARRAY
4810: PPUSH
4811: LD_INT 76
4813: PPUSH
4814: LD_INT 0
4816: PPUSH
4817: CALL_OW 48
// ComCrawl ( un ) ;
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 137
// tmp := tmp ^ un ;
4830: LD_ADDR_VAR 0 3
4834: PUSH
4835: LD_VAR 0 3
4839: PUSH
4840: LD_VAR 0 1
4844: ADD
4845: ST_TO_ADDR
// end ;
4846: GO 4748
4848: POP
4849: POP
// repeat wait ( 0 0$1 ) ;
4850: LD_INT 35
4852: PPUSH
4853: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4857: LD_VAR 0 1
4861: PPUSH
4862: LD_INT 24
4864: PUSH
4865: LD_INT 1000
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PPUSH
4872: CALL_OW 72
4876: NOT
4877: IFFALSE 4850
// for i in tmp do
4879: LD_ADDR_VAR 0 2
4883: PUSH
4884: LD_VAR 0 3
4888: PUSH
4889: FOR_IN
4890: IFFALSE 4968
// begin wait ( 0 0$1 ) ;
4892: LD_INT 35
4894: PPUSH
4895: CALL_OW 67
// if Crawls ( i ) then
4899: LD_VAR 0 2
4903: PPUSH
4904: CALL_OW 318
4908: IFFALSE 4921
// ComWalk ( i ) else
4910: LD_VAR 0 2
4914: PPUSH
4915: CALL_OW 138
4919: GO 4966
// if GetClass ( i ) = class_sniper then
4921: LD_VAR 0 2
4925: PPUSH
4926: CALL_OW 257
4930: PUSH
4931: LD_INT 5
4933: EQUAL
4934: IFFALSE 4952
// ComAttackSoporific ( i , JMM ) else
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_EXP 14
4945: PPUSH
4946: CALL_OW 166
4950: GO 4966
// ComAttackUnit ( i , JMM ) ;
4952: LD_VAR 0 2
4956: PPUSH
4957: LD_EXP 14
4961: PPUSH
4962: CALL_OW 115
// end ;
4966: GO 4889
4968: POP
4969: POP
// end ;
4970: PPOPN 3
4972: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4973: LD_EXP 7
4977: NOT
4978: PUSH
4979: LD_INT 1
4981: PPUSH
4982: CALL_OW 301
4986: AND
4987: IFFALSE 4999
4989: GO 4991
4991: DISABLE
// YouLost ( Lab ) ;
4992: LD_STRING Lab
4994: PPUSH
4995: CALL_OW 104
4999: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5000: LD_INT 10
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 7
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 70
5017: PUSH
5018: LD_INT 2
5020: GREATEREQUAL
5021: PUSH
5022: LD_INT 10
5024: PPUSH
5025: LD_INT 2
5027: PUSH
5028: LD_INT 34
5030: PUSH
5031: LD_INT 12
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 34
5040: PUSH
5041: LD_INT 51
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 70
5057: AND
5058: PUSH
5059: LD_EXP 10
5063: AND
5064: PUSH
5065: LD_EXP 7
5069: AND
5070: PUSH
5071: LD_EXP 6
5075: AND
5076: IFFALSE 5332
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
// begin m1 := false ;
5085: LD_ADDR_VAR 0 1
5089: PUSH
5090: LD_INT 0
5092: ST_TO_ADDR
// m2 := false ;
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: LD_INT 0
5100: ST_TO_ADDR
// if killCounter = 0 then
5101: LD_EXP 12
5105: PUSH
5106: LD_INT 0
5108: EQUAL
5109: IFFALSE 5118
// SetAchievement ( ACH_PACIFIST ) ;
5111: LD_STRING ACH_PACIFIST
5113: PPUSH
5114: CALL_OW 543
// if tick < 7 7$00 then
5118: LD_OWVAR 1
5122: PUSH
5123: LD_INT 14700
5125: LESS
5126: IFFALSE 5142
// begin wait ( 3 ) ;
5128: LD_INT 3
5130: PPUSH
5131: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5135: LD_STRING ACH_ASPEED_18
5137: PPUSH
5138: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5142: LD_STRING Explosion
5144: PPUSH
5145: LD_INT 1
5147: PPUSH
5148: CALL_OW 101
// if enteredContaminatedArea then
5152: LD_EXP 5
5156: IFFALSE 5178
// begin m1 := true ;
5158: LD_ADDR_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5166: LD_STRING BioHazard
5168: PPUSH
5169: LD_INT 1
5171: PPUSH
5172: CALL_OW 101
// end else
5176: GO 5189
// AddMedal ( BioHazard , - 1 ) ;
5178: LD_STRING BioHazard
5180: PPUSH
5181: LD_INT 1
5183: NEG
5184: PPUSH
5185: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5189: LD_EXP 11
5193: PUSH
5194: LD_INT 42000
5196: PUSH
5197: LD_INT 31500
5199: PUSH
5200: LD_INT 25200
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_OWVAR 67
5212: ARRAY
5213: LESSEQUAL
5214: IFFALSE 5236
// begin m2 := true ;
5216: LD_ADDR_VAR 0 2
5220: PUSH
5221: LD_INT 1
5223: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5224: LD_STRING Speed
5226: PPUSH
5227: LD_INT 1
5229: PPUSH
5230: CALL_OW 101
// end else
5234: GO 5247
// AddMedal ( Speed , - 1 ) ;
5236: LD_STRING Speed
5238: PPUSH
5239: LD_INT 1
5241: NEG
5242: PPUSH
5243: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5247: LD_OWVAR 67
5251: PUSH
5252: LD_INT 3
5254: EQUAL
5255: PUSH
5256: LD_VAR 0 1
5260: AND
5261: PUSH
5262: LD_VAR 0 2
5266: AND
5267: IFFALSE 5279
// SetAchievementEX ( ACH_AMER , 18 ) ;
5269: LD_STRING ACH_AMER
5271: PPUSH
5272: LD_INT 18
5274: PPUSH
5275: CALL_OW 564
// GiveMedals ( Main ) ;
5279: LD_STRING Main
5281: PPUSH
5282: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5286: LD_EXP 14
5290: PUSH
5291: LD_EXP 15
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5304: LD_EXP 14
5308: PPUSH
5309: LD_STRING 14a_JMM
5311: PPUSH
5312: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5316: LD_EXP 15
5320: PPUSH
5321: LD_STRING 14a_Burlak
5323: PPUSH
5324: CALL_OW 38
// YouWin ;
5328: CALL_OW 103
// end ; end_of_file
5332: PPOPN 2
5334: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5335: LD_INT 0
5337: PPUSH
5338: PPUSH
5339: PPUSH
5340: PPUSH
// uc_side := 1 ;
5341: LD_ADDR_OWVAR 20
5345: PUSH
5346: LD_INT 1
5348: ST_TO_ADDR
// uc_nation := 1 ;
5349: LD_ADDR_OWVAR 21
5353: PUSH
5354: LD_INT 1
5356: ST_TO_ADDR
// InitHc ;
5357: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5361: LD_INT 34
5363: PPUSH
5364: CALL_OW 274
5368: PPUSH
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 500
5374: PPUSH
5375: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5379: LD_INT 34
5381: PPUSH
5382: CALL_OW 274
5386: PPUSH
5387: LD_INT 3
5389: PPUSH
5390: LD_INT 20
5392: PPUSH
5393: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5397: LD_ADDR_EXP 18
5401: PUSH
5402: LD_STRING Stevens
5404: PPUSH
5405: CALL_OW 25
5409: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5410: LD_ADDR_EXP 19
5414: PUSH
5415: LD_STRING Powell
5417: PPUSH
5418: CALL_OW 25
5422: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5423: LD_EXP 18
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: CALL_OW 52
// vehGuard := [ ] ;
5435: LD_ADDR_EXP 23
5439: PUSH
5440: EMPTY
5441: ST_TO_ADDR
// hc_importance := 0 ;
5442: LD_ADDR_OWVAR 32
5446: PUSH
5447: LD_INT 0
5449: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 3
5455: PPUSH
5456: LD_INT 3
5458: PPUSH
5459: LD_INT 8
5461: PPUSH
5462: LD_INT 100
5464: PPUSH
5465: CALL 971 0 5
// sibBomb := CreateVehicle ;
5469: LD_ADDR_EXP 21
5473: PUSH
5474: CALL_OW 45
5478: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5479: LD_EXP 21
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5491: LD_EXP 21
5495: PPUSH
5496: LD_INT 93
5498: PPUSH
5499: LD_INT 74
5501: PPUSH
5502: LD_INT 0
5504: PPUSH
5505: CALL_OW 48
// guards := [ ] ;
5509: LD_ADDR_EXP 22
5513: PUSH
5514: EMPTY
5515: ST_TO_ADDR
// for i = 1 to 3 do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_INT 3
5528: PUSH
5529: FOR_TO
5530: IFFALSE 5622
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5532: LD_INT 0
5534: PPUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_INT 8
5540: PUSH
5541: LD_INT 9
5543: PUSH
5544: LD_INT 10
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PPUSH
5558: CALL_OW 380
// un := CreateHuman ;
5562: LD_ADDR_VAR 0 3
5566: PUSH
5567: CALL_OW 44
5571: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5572: LD_VAR 0 3
5576: PPUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 4
5585: PUSH
5586: EMPTY
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_VAR 0 2
5595: ARRAY
5596: PPUSH
5597: LD_INT 0
5599: PPUSH
5600: CALL_OW 49
// guards := guards ^ un ;
5604: LD_ADDR_EXP 22
5608: PUSH
5609: LD_EXP 22
5613: PUSH
5614: LD_VAR 0 3
5618: ADD
5619: ST_TO_ADDR
// end ;
5620: GO 5529
5622: POP
5623: POP
// baseGuards := [ ] ;
5624: LD_ADDR_EXP 20
5628: PUSH
5629: EMPTY
5630: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5631: LD_ADDR_VAR 0 2
5635: PUSH
5636: DOUBLE
5637: LD_INT 1
5639: DEC
5640: ST_TO_ADDR
5641: LD_INT 5
5643: PUSH
5644: LD_INT 6
5646: PUSH
5647: LD_INT 7
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: PUSH
5655: LD_OWVAR 67
5659: ARRAY
5660: PUSH
5661: FOR_TO
5662: IFFALSE 5808
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5664: LD_INT 0
5666: PPUSH
5667: LD_INT 8
5669: PUSH
5670: LD_INT 9
5672: PUSH
5673: LD_INT 10
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: PUSH
5681: LD_OWVAR 67
5685: ARRAY
5686: PPUSH
5687: CALL_OW 381
// un := CreateHuman ;
5691: LD_ADDR_VAR 0 3
5695: PUSH
5696: CALL_OW 44
5700: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5701: LD_ADDR_EXP 20
5705: PUSH
5706: LD_EXP 20
5710: PUSH
5711: LD_VAR 0 3
5715: ADD
5716: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5717: LD_ADDR_VAR 0 4
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 58
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 30
5740: PUSH
5741: LD_INT 32
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 69
5757: ST_TO_ADDR
// if tmp then
5758: LD_VAR 0 4
5762: IFFALSE 5794
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5764: LD_VAR 0 3
5768: PPUSH
5769: LD_VAR 0 4
5773: PUSH
5774: LD_INT 1
5776: PPUSH
5777: LD_VAR 0 4
5781: PPUSH
5782: CALL_OW 12
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
5792: GO 5806
// PlaceHumanInUnit ( un , us_bar ) ;
5794: LD_VAR 0 3
5798: PPUSH
5799: LD_INT 51
5801: PPUSH
5802: CALL_OW 52
// end ;
5806: GO 5661
5808: POP
5809: POP
// if Difficulty > 1 then
5810: LD_OWVAR 67
5814: PUSH
5815: LD_INT 1
5817: GREATER
5818: IFFALSE 5862
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5820: LD_INT 0
5822: PPUSH
5823: LD_INT 5
5825: PPUSH
5826: LD_INT 9
5828: PUSH
5829: LD_INT 10
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PUSH
5836: LD_OWVAR 67
5840: PUSH
5841: LD_INT 1
5843: MINUS
5844: ARRAY
5845: PPUSH
5846: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5850: CALL_OW 44
5854: PPUSH
5855: LD_INT 80
5857: PPUSH
5858: CALL_OW 52
// end ; for i = 1 to 3 do
5862: LD_ADDR_VAR 0 2
5866: PUSH
5867: DOUBLE
5868: LD_INT 1
5870: DEC
5871: ST_TO_ADDR
5872: LD_INT 3
5874: PUSH
5875: FOR_TO
5876: IFFALSE 5902
// begin PrepareMechanic ( false , 9 ) ;
5878: LD_INT 0
5880: PPUSH
5881: LD_INT 9
5883: PPUSH
5884: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5888: CALL_OW 44
5892: PPUSH
5893: LD_INT 43
5895: PPUSH
5896: CALL_OW 52
// end ;
5900: GO 5875
5902: POP
5903: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_INT 49
5911: PPUSH
5912: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5916: LD_ADDR_VAR 0 2
5920: PUSH
5921: DOUBLE
5922: LD_INT 1
5924: DEC
5925: ST_TO_ADDR
5926: LD_INT 1
5928: PUSH
5929: LD_OWVAR 67
5933: PLUS
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5979
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5938: LD_INT 0
5940: PPUSH
5941: LD_INT 8
5943: PUSH
5944: LD_INT 9
5946: PUSH
5947: LD_INT 10
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: LD_OWVAR 67
5959: ARRAY
5960: PPUSH
5961: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5965: CALL_OW 44
5969: PPUSH
5970: LD_INT 5
5972: PPUSH
5973: CALL_OW 52
// end ;
5977: GO 5935
5979: POP
5980: POP
// for i = 1 to 3 do
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: DOUBLE
5987: LD_INT 1
5989: DEC
5990: ST_TO_ADDR
5991: LD_INT 3
5993: PUSH
5994: FOR_TO
5995: IFFALSE 6021
// begin PrepareScientist ( false , 10 ) ;
5997: LD_INT 0
5999: PPUSH
6000: LD_INT 10
6002: PPUSH
6003: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6007: CALL_OW 44
6011: PPUSH
6012: LD_INT 1
6014: PPUSH
6015: CALL_OW 52
// end ;
6019: GO 5994
6021: POP
6022: POP
// end ;
6023: LD_VAR 0 1
6027: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6028: LD_EXP 22
6032: PUSH
6033: LD_EXP 2
6037: NOT
6038: AND
6039: IFFALSE 6225
6041: GO 6043
6043: DISABLE
6044: LD_INT 0
6046: PPUSH
6047: PPUSH
6048: PPUSH
// begin enable ;
6049: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6050: LD_ADDR_VAR 0 3
6054: PUSH
6055: LD_INT 204
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 165
6067: PUSH
6068: LD_INT 24
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PUSH
6075: LD_INT 195
6077: PUSH
6078: LD_INT 6
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: LD_INT 223
6087: PUSH
6088: LD_INT 54
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 214
6097: PUSH
6098: LD_INT 84
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 206
6107: PUSH
6108: LD_INT 71
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: ST_TO_ADDR
// for i in guards do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: LD_EXP 22
6132: PUSH
6133: FOR_IN
6134: IFFALSE 6223
// begin if HasTask ( i ) then
6136: LD_VAR 0 1
6140: PPUSH
6141: CALL_OW 314
6145: IFFALSE 6151
// continue else
6147: GO 6133
6149: GO 6221
// begin j := rand ( 1 , 6 ) ;
6151: LD_ADDR_VAR 0 2
6155: PUSH
6156: LD_INT 1
6158: PPUSH
6159: LD_INT 6
6161: PPUSH
6162: CALL_OW 12
6166: ST_TO_ADDR
// if not See ( 7 , i ) then
6167: LD_INT 7
6169: PPUSH
6170: LD_VAR 0 1
6174: PPUSH
6175: CALL_OW 292
6179: NOT
6180: IFFALSE 6221
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6182: LD_VAR 0 1
6186: PPUSH
6187: LD_VAR 0 3
6191: PUSH
6192: LD_VAR 0 2
6196: ARRAY
6197: PUSH
6198: LD_INT 1
6200: ARRAY
6201: PPUSH
6202: LD_VAR 0 3
6206: PUSH
6207: LD_VAR 0 2
6211: ARRAY
6212: PUSH
6213: LD_INT 2
6215: ARRAY
6216: PPUSH
6217: CALL_OW 114
// end ; end ;
6221: GO 6133
6223: POP
6224: POP
// end ;
6225: PPOPN 3
6227: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6228: LD_EXP 23
6232: PUSH
6233: LD_EXP 7
6237: NOT
6238: AND
6239: IFFALSE 6310
6241: GO 6243
6243: DISABLE
6244: LD_INT 0
6246: PPUSH
// begin enable ;
6247: ENABLE
// for i in vehGuard do
6248: LD_ADDR_VAR 0 1
6252: PUSH
6253: LD_EXP 23
6257: PUSH
6258: FOR_IN
6259: IFFALSE 6308
// if IsOk ( vehGuard ) then
6261: LD_EXP 23
6265: PPUSH
6266: CALL_OW 302
6270: IFFALSE 6306
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 22
6279: PUSH
6280: LD_INT 7
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 74
6301: PPUSH
6302: CALL_OW 115
6306: GO 6258
6308: POP
6309: POP
// end ;
6310: PPOPN 1
6312: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6313: LD_EXP 4
6317: PUSH
6318: LD_INT 43
6320: PPUSH
6321: CALL_OW 302
6325: AND
6326: PUSH
6327: LD_EXP 7
6331: NOT
6332: AND
6333: IFFALSE 6381
6335: GO 6337
6337: DISABLE
// begin enable ;
6338: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6339: LD_INT 43
6341: PPUSH
6342: LD_INT 5
6344: PPUSH
6345: LD_INT 3
6347: PPUSH
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 7
6353: PUSH
6354: LD_INT 7
6356: PUSH
6357: LD_INT 9
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 3
6370: PPUSH
6371: CALL_OW 12
6375: ARRAY
6376: PPUSH
6377: CALL_OW 125
// end ;
6381: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6382: LD_INT 22
6384: PUSH
6385: LD_INT 1
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 25
6394: PUSH
6395: LD_INT 5
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PUSH
6402: LD_INT 50
6404: PUSH
6405: EMPTY
6406: LIST
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: LD_EXP 7
6422: NOT
6423: AND
6424: IFFALSE 6653
6426: GO 6428
6428: DISABLE
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
// begin enable ;
6433: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6434: LD_ADDR_VAR 0 1
6438: PUSH
6439: LD_INT 22
6441: PUSH
6442: LD_INT 1
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 25
6451: PUSH
6452: LD_INT 5
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 50
6461: PUSH
6462: EMPTY
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PPUSH
6470: CALL_OW 69
6474: ST_TO_ADDR
// if not tmp then
6475: LD_VAR 0 1
6479: NOT
6480: IFFALSE 6484
// exit ;
6482: GO 6653
// b := IsInUnit ( tmp [ 1 ] ) ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_VAR 0 1
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 310
6502: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6503: LD_VAR 0 2
6507: NOT
6508: PUSH
6509: LD_VAR 0 1
6513: PUSH
6514: LD_INT 1
6516: ARRAY
6517: PPUSH
6518: CALL_OW 314
6522: OR
6523: IFFALSE 6527
// exit ;
6525: GO 6653
// if b = us_bun1 then
6527: LD_VAR 0 2
6531: PUSH
6532: LD_INT 80
6534: EQUAL
6535: IFFALSE 6596
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6537: LD_VAR 0 1
6541: PUSH
6542: LD_INT 1
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6550: LD_VAR 0 1
6554: PUSH
6555: LD_INT 1
6557: ARRAY
6558: PPUSH
6559: LD_INT 27
6561: PPUSH
6562: LD_INT 44
6564: PPUSH
6565: CALL_OW 174
// if IsOk ( us_bun2 ) then
6569: LD_INT 55
6571: PPUSH
6572: CALL_OW 302
6576: IFFALSE 6594
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6578: LD_VAR 0 1
6582: PUSH
6583: LD_INT 1
6585: ARRAY
6586: PPUSH
6587: LD_INT 55
6589: PPUSH
6590: CALL_OW 180
// end else
6594: GO 6653
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6609: LD_VAR 0 1
6613: PUSH
6614: LD_INT 1
6616: ARRAY
6617: PPUSH
6618: LD_INT 92
6620: PPUSH
6621: LD_INT 51
6623: PPUSH
6624: CALL_OW 174
// if IsOk ( us_bun1 ) then
6628: LD_INT 80
6630: PPUSH
6631: CALL_OW 302
6635: IFFALSE 6653
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6637: LD_VAR 0 1
6641: PUSH
6642: LD_INT 1
6644: ARRAY
6645: PPUSH
6646: LD_INT 80
6648: PPUSH
6649: CALL_OW 180
// end ; end ;
6653: PPOPN 2
6655: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6656: LD_EXP 7
6660: NOT
6661: PUSH
6662: LD_INT 9
6664: PPUSH
6665: LD_INT 22
6667: PUSH
6668: LD_INT 1
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: LD_INT 21
6677: PUSH
6678: LD_INT 3
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 3
6687: PUSH
6688: LD_INT 24
6690: PUSH
6691: LD_INT 1000
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 70
6711: AND
6712: IFFALSE 7123
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
// begin enable ;
6723: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 22
6731: PUSH
6732: LD_INT 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 25
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: LD_INT 1000
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: PPUSH
6764: CALL_OW 69
6768: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6769: LD_ADDR_VAR 0 3
6773: PUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 25
6786: PUSH
6787: LD_INT 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 24
6799: PUSH
6800: LD_INT 750
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6821: LD_ADDR_VAR 0 4
6825: PUSH
6826: LD_INT 9
6828: PPUSH
6829: LD_INT 22
6831: PUSH
6832: LD_INT 1
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 24
6854: PUSH
6855: LD_INT 1000
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: PPUSH
6871: CALL_OW 70
6875: PUSH
6876: LD_INT 1
6878: DIFF
6879: ST_TO_ADDR
// if not tmp and not tmp2 then
6880: LD_VAR 0 2
6884: NOT
6885: PUSH
6886: LD_VAR 0 3
6890: NOT
6891: AND
6892: IFFALSE 6896
// exit ;
6894: GO 7123
// if tmp and b then
6896: LD_VAR 0 2
6900: PUSH
6901: LD_VAR 0 4
6905: AND
6906: IFFALSE 7036
// for i in tmp do
6908: LD_ADDR_VAR 0 1
6912: PUSH
6913: LD_VAR 0 2
6917: PUSH
6918: FOR_IN
6919: IFFALSE 7034
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6921: LD_VAR 0 1
6925: PPUSH
6926: CALL_OW 110
6930: PUSH
6931: LD_INT 1
6933: EQUAL
6934: PUSH
6935: LD_VAR 0 1
6939: PPUSH
6940: CALL_OW 256
6944: PUSH
6945: LD_INT 1000
6947: LESS
6948: AND
6949: IFFALSE 6955
// continue else
6951: GO 6918
6953: GO 6982
// if GetTag ( i ) = 1 then
6955: LD_VAR 0 1
6959: PPUSH
6960: CALL_OW 110
6964: PUSH
6965: LD_INT 1
6967: EQUAL
6968: IFFALSE 6982
// SetTag ( i , 0 ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_INT 0
6977: PPUSH
6978: CALL_OW 109
// if IsInUnit ( i ) then
6982: LD_VAR 0 1
6986: PPUSH
6987: CALL_OW 310
6991: IFFALSE 7002
// ComExitBuilding ( i ) ;
6993: LD_VAR 0 1
6997: PPUSH
6998: CALL_OW 122
// if not HasTask ( i ) then
7002: LD_VAR 0 1
7006: PPUSH
7007: CALL_OW 314
7011: NOT
7012: IFFALSE 7032
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_VAR 0 4
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: CALL_OW 190
// end ;
7032: GO 6918
7034: POP
7035: POP
// if tmp2 then
7036: LD_VAR 0 3
7040: IFFALSE 7123
// for i in tmp2 do
7042: LD_ADDR_VAR 0 1
7046: PUSH
7047: LD_VAR 0 3
7051: PUSH
7052: FOR_IN
7053: IFFALSE 7121
// begin if not GetTag ( i ) = 1 then
7055: LD_VAR 0 1
7059: PPUSH
7060: CALL_OW 110
7064: PUSH
7065: LD_INT 1
7067: EQUAL
7068: NOT
7069: IFFALSE 7083
// SetTag ( i , 1 ) ;
7071: LD_VAR 0 1
7075: PPUSH
7076: LD_INT 1
7078: PPUSH
7079: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7083: LD_VAR 0 1
7087: PPUSH
7088: LD_INT 88
7090: PPUSH
7091: LD_INT 75
7093: PPUSH
7094: CALL_OW 297
7098: PUSH
7099: LD_INT 6
7101: GREATER
7102: IFFALSE 7119
// ComMoveXY ( i , 88 , 75 ) ;
7104: LD_VAR 0 1
7108: PPUSH
7109: LD_INT 88
7111: PPUSH
7112: LD_INT 75
7114: PPUSH
7115: CALL_OW 111
// end ;
7119: GO 7052
7121: POP
7122: POP
// end ;
7123: PPOPN 4
7125: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7126: LD_EXP 7
7130: NOT
7131: PUSH
7132: LD_EXP 9
7136: AND
7137: PUSH
7138: LD_INT 9
7140: PPUSH
7141: LD_INT 22
7143: PUSH
7144: LD_INT 1
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 21
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 3
7163: PUSH
7164: LD_INT 24
7166: PUSH
7167: LD_INT 1000
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL_OW 70
7187: AND
7188: IFFALSE 7361
7190: GO 7192
7192: DISABLE
7193: LD_INT 0
7195: PPUSH
7196: PPUSH
7197: PPUSH
// begin enable ;
7198: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7199: LD_ADDR_VAR 0 2
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_INT 1
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 25
7216: PUSH
7217: LD_INT 4
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: PPUSH
7228: CALL_OW 69
7232: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_INT 9
7240: PPUSH
7241: LD_INT 22
7243: PUSH
7244: LD_INT 1
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: LD_INT 21
7253: PUSH
7254: LD_INT 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 3
7263: PUSH
7264: LD_INT 24
7266: PUSH
7267: LD_INT 1000
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: PPUSH
7283: CALL_OW 70
7287: ST_TO_ADDR
// if not sci or not tmp then
7288: LD_VAR 0 2
7292: NOT
7293: PUSH
7294: LD_VAR 0 3
7298: NOT
7299: OR
7300: IFFALSE 7304
// exit ;
7302: GO 7361
// for i in sci do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: LD_VAR 0 2
7313: PUSH
7314: FOR_IN
7315: IFFALSE 7359
// if IsInUnit ( i ) then
7317: LD_VAR 0 1
7321: PPUSH
7322: CALL_OW 310
7326: IFFALSE 7339
// ComExitBuilding ( i ) else
7328: LD_VAR 0 1
7332: PPUSH
7333: CALL_OW 122
7337: GO 7357
// ComHeal ( i , tmp [ 1 ] ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 1
7351: ARRAY
7352: PPUSH
7353: CALL_OW 128
7357: GO 7314
7359: POP
7360: POP
// end ;
7361: PPOPN 3
7363: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7364: LD_EXP 7
7368: NOT
7369: PUSH
7370: LD_EXP 9
7374: AND
7375: PUSH
7376: LD_INT 1
7378: PPUSH
7379: CALL_OW 302
7383: AND
7384: PUSH
7385: LD_INT 9
7387: PPUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 21
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: LD_INT 24
7413: PUSH
7414: LD_INT 1000
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 70
7434: NOT
7435: AND
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 25
7449: PUSH
7450: LD_INT 4
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 56
7459: PUSH
7460: EMPTY
7461: LIST
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: AND
7473: IFFALSE 7566
7475: GO 7477
7477: DISABLE
7478: LD_INT 0
7480: PPUSH
// begin enable ;
7481: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_INT 1
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 4
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 56
7509: PUSH
7510: EMPTY
7511: LIST
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: PPUSH
7518: CALL_OW 69
7522: PUSH
7523: FOR_IN
7524: IFFALSE 7564
// if not GetTag ( i ) and not HasTask ( i ) then
7526: LD_VAR 0 1
7530: PPUSH
7531: CALL_OW 110
7535: NOT
7536: PUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 314
7546: NOT
7547: AND
7548: IFFALSE 7562
// ComEnterUnit ( i , us_lab ) ;
7550: LD_VAR 0 1
7554: PPUSH
7555: LD_INT 1
7557: PPUSH
7558: CALL_OW 120
7562: GO 7523
7564: POP
7565: POP
// end ;
7566: PPOPN 1
7568: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7569: LD_EXP 7
7573: NOT
7574: PUSH
7575: LD_INT 9
7577: PPUSH
7578: LD_INT 22
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: LD_INT 21
7590: PUSH
7591: LD_INT 3
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 24
7603: PUSH
7604: LD_INT 1000
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: PPUSH
7620: CALL_OW 70
7624: NOT
7625: AND
7626: PUSH
7627: LD_INT 22
7629: PUSH
7630: LD_INT 1
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PUSH
7637: LD_INT 25
7639: PUSH
7640: LD_INT 2
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 56
7649: PUSH
7650: EMPTY
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: PPUSH
7658: CALL_OW 69
7662: AND
7663: IFFALSE 7756
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin enable ;
7671: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7672: LD_ADDR_VAR 0 1
7676: PUSH
7677: LD_INT 22
7679: PUSH
7680: LD_INT 1
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 25
7689: PUSH
7690: LD_INT 2
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: LD_INT 56
7699: PUSH
7700: EMPTY
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: PPUSH
7708: CALL_OW 69
7712: PUSH
7713: FOR_IN
7714: IFFALSE 7754
// if not HasTask ( i ) and not GetTag ( i ) then
7716: LD_VAR 0 1
7720: PPUSH
7721: CALL_OW 314
7725: NOT
7726: PUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 110
7736: NOT
7737: AND
7738: IFFALSE 7752
// ComEnterUnit ( i , us_depot ) ;
7740: LD_VAR 0 1
7744: PPUSH
7745: LD_INT 5
7747: PPUSH
7748: CALL_OW 120
7752: GO 7713
7754: POP
7755: POP
// end ;
7756: PPOPN 1
7758: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7759: LD_EXP 9
7763: PUSH
7764: LD_INT 0
7766: LESSEQUAL
7767: PUSH
7768: LD_EXP 18
7772: PPUSH
7773: CALL_OW 301
7777: OR
7778: PUSH
7779: LD_INT 22
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PUSH
7789: LD_INT 25
7791: PUSH
7792: LD_INT 2
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 69
7807: AND
7808: IFFALSE 7849
7810: GO 7812
7812: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7813: LD_INT 22
7815: PUSH
7816: LD_INT 1
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PUSH
7823: LD_INT 25
7825: PUSH
7826: LD_INT 2
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 69
7841: PPUSH
7842: LD_INT 1
7844: PPUSH
7845: CALL_OW 167
7849: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7850: LD_EXP 7
7854: NOT
7855: PUSH
7856: LD_INT 7
7858: PPUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 7
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 70
7873: AND
7874: IFFALSE 7965
7876: GO 7878
7878: DISABLE
7879: LD_INT 0
7881: PPUSH
// begin wait ( 0 0$2 ) ;
7882: LD_INT 70
7884: PPUSH
7885: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7889: LD_ADDR_VAR 0 1
7893: PUSH
7894: LD_INT 22
7896: PUSH
7897: LD_INT 1
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: PUSH
7904: LD_INT 25
7906: PUSH
7907: LD_INT 1
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 69
7922: PUSH
7923: FOR_IN
7924: IFFALSE 7963
// begin if IsInUnit ( i ) then
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 310
7935: IFFALSE 7946
// ComExitBuilding ( i ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_INT 92
7953: PPUSH
7954: LD_INT 78
7956: PPUSH
7957: CALL_OW 174
// end ;
7961: GO 7923
7963: POP
7964: POP
// end ; end_of_file
7965: PPOPN 1
7967: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7968: LD_VAR 0 1
7972: PPUSH
7973: LD_VAR 0 2
7977: PPUSH
7978: LD_VAR 0 3
7982: PPUSH
7983: CALL 2823 0 3
7987: PPOPN 3
7989: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7990: LD_EXP 14
7994: PPUSH
7995: CALL_OW 257
7999: PUSH
8000: LD_INT 4
8002: EQUAL
8003: PUSH
8004: LD_EXP 15
8008: PPUSH
8009: CALL_OW 257
8013: PUSH
8014: LD_INT 4
8016: EQUAL
8017: OR
8018: IFFALSE 8022
// exit ;
8020: GO 8060
// if un = JMM then
8022: LD_VAR 0 1
8026: PUSH
8027: LD_EXP 14
8031: EQUAL
8032: IFFALSE 8041
// YouLost ( JMM ) ;
8034: LD_STRING JMM
8036: PPUSH
8037: CALL_OW 104
// if un = Burlak then
8041: LD_VAR 0 1
8045: PUSH
8046: LD_EXP 15
8050: EQUAL
8051: IFFALSE 8060
// YouLost ( Burlak ) ;
8053: LD_STRING Burlak
8055: PPUSH
8056: CALL_OW 104
// end ;
8060: PPOPN 1
8062: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8063: LD_VAR 0 1
8067: PUSH
8068: LD_EXP 14
8072: EQUAL
8073: IFFALSE 8082
// YouLost ( JMM ) ;
8075: LD_STRING JMM
8077: PPUSH
8078: CALL_OW 104
// if un = Burlak then
8082: LD_VAR 0 1
8086: PUSH
8087: LD_EXP 15
8091: EQUAL
8092: IFFALSE 8101
// YouLost ( Burlak ) ;
8094: LD_STRING Burlak
8096: PPUSH
8097: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8101: LD_VAR 0 1
8105: PUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 1
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 23
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PPUSH
8130: CALL_OW 69
8134: IN
8135: IFFALSE 8151
// killCounter := killCounter + 1 ;
8137: LD_ADDR_EXP 12
8141: PUSH
8142: LD_EXP 12
8146: PUSH
8147: LD_INT 1
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: PPOPN 1
8153: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8154: LD_VAR 0 2
8158: PUSH
8159: LD_INT 7
8161: EQUAL
8162: PUSH
8163: LD_VAR 0 1
8167: PUSH
8168: LD_INT 2
8170: PUSH
8171: LD_INT 30
8173: PUSH
8174: LD_INT 31
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 30
8183: PUSH
8184: LD_INT 32
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 30
8193: PUSH
8194: LD_INT 33
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 69
8211: IN
8212: AND
8213: IFFALSE 8229
// bunkerCounter := bunkerCounter + 1 ;
8215: LD_ADDR_EXP 13
8219: PUSH
8220: LD_EXP 13
8224: PUSH
8225: LD_INT 1
8227: PLUS
8228: ST_TO_ADDR
// end ;
8229: PPOPN 3
8231: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8232: LD_VAR 0 1
8236: PPUSH
8237: CALL_OW 255
8241: PUSH
8242: LD_INT 7
8244: EQUAL
8245: IFFALSE 8255
// artifactPickedUp := true ;
8247: LD_ADDR_EXP 6
8251: PUSH
8252: LD_INT 1
8254: ST_TO_ADDR
// end ;
8255: PPOPN 2
8257: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8258: LD_ADDR_EXP 6
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
8266: PPOPN 2
8268: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 255
8278: PUSH
8279: LD_INT 1
8281: NONEQUAL
8282: IFFALSE 8286
// exit ;
8284: GO 8333
// wait ( 0 0$5 ) ;
8286: LD_INT 175
8288: PPUSH
8289: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 263
8302: PUSH
8303: LD_INT 2
8305: EQUAL
8306: IFFALSE 8317
// Connect ( vehicle ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL 1824 0 1
// vehGuard := vehGuard ^ vehicle ;
8317: LD_ADDR_EXP 23
8321: PUSH
8322: LD_EXP 23
8326: PUSH
8327: LD_VAR 0 1
8331: ADD
8332: ST_TO_ADDR
// end ;
8333: PPOPN 2
8335: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8336: LD_VAR 0 1
8340: PUSH
8341: LD_INT 1
8343: EQUAL
8344: PUSH
8345: LD_EXP 7
8349: NOT
8350: AND
8351: IFFALSE 8386
// begin planCaptured := true ;
8353: LD_ADDR_EXP 7
8357: PUSH
8358: LD_INT 1
8360: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8361: LD_STRING MEnd
8363: PPUSH
8364: CALL_OW 337
// canEnd := true ;
8368: LD_ADDR_EXP 10
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// missionTime := tick ;
8376: LD_ADDR_EXP 11
8380: PUSH
8381: LD_OWVAR 1
8385: ST_TO_ADDR
// end ; end ;
8386: PPOPN 3
8388: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL 10807 0 1
// end ; end_of_file
8398: PPOPN 1
8400: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8401: GO 8403
8403: DISABLE
// begin ru_radar := 98 ;
8404: LD_ADDR_EXP 24
8408: PUSH
8409: LD_INT 98
8411: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8412: LD_ADDR_EXP 25
8416: PUSH
8417: LD_INT 89
8419: ST_TO_ADDR
// us_hack := 99 ;
8420: LD_ADDR_EXP 26
8424: PUSH
8425: LD_INT 99
8427: ST_TO_ADDR
// us_artillery := 97 ;
8428: LD_ADDR_EXP 27
8432: PUSH
8433: LD_INT 97
8435: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8436: LD_ADDR_EXP 28
8440: PUSH
8441: LD_INT 91
8443: ST_TO_ADDR
// end ; end_of_file end_of_file
8444: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
8445: GO 8447
8447: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8448: LD_STRING initStreamRollete();
8450: PPUSH
8451: CALL_OW 559
// InitStreamMode ;
8455: CALL 8460 0 0
// end ;
8459: END
// function InitStreamMode ; begin
8460: LD_INT 0
8462: PPUSH
// streamModeActive := false ;
8463: LD_ADDR_EXP 29
8467: PUSH
8468: LD_INT 0
8470: ST_TO_ADDR
// sRocket := false ;
8471: LD_ADDR_EXP 32
8475: PUSH
8476: LD_INT 0
8478: ST_TO_ADDR
// sSpeed := false ;
8479: LD_ADDR_EXP 31
8483: PUSH
8484: LD_INT 0
8486: ST_TO_ADDR
// sEngine := false ;
8487: LD_ADDR_EXP 33
8491: PUSH
8492: LD_INT 0
8494: ST_TO_ADDR
// sSpec := false ;
8495: LD_ADDR_EXP 30
8499: PUSH
8500: LD_INT 0
8502: ST_TO_ADDR
// sLevel := false ;
8503: LD_ADDR_EXP 34
8507: PUSH
8508: LD_INT 0
8510: ST_TO_ADDR
// sArmoury := false ;
8511: LD_ADDR_EXP 35
8515: PUSH
8516: LD_INT 0
8518: ST_TO_ADDR
// sRadar := false ;
8519: LD_ADDR_EXP 36
8523: PUSH
8524: LD_INT 0
8526: ST_TO_ADDR
// sBunker := false ;
8527: LD_ADDR_EXP 37
8531: PUSH
8532: LD_INT 0
8534: ST_TO_ADDR
// sHack := false ;
8535: LD_ADDR_EXP 38
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// sFire := false ;
8543: LD_ADDR_EXP 39
8547: PUSH
8548: LD_INT 0
8550: ST_TO_ADDR
// sRefresh := false ;
8551: LD_ADDR_EXP 40
8555: PUSH
8556: LD_INT 0
8558: ST_TO_ADDR
// sExp := false ;
8559: LD_ADDR_EXP 41
8563: PUSH
8564: LD_INT 0
8566: ST_TO_ADDR
// sDepot := false ;
8567: LD_ADDR_EXP 42
8571: PUSH
8572: LD_INT 0
8574: ST_TO_ADDR
// sFlag := false ;
8575: LD_ADDR_EXP 43
8579: PUSH
8580: LD_INT 0
8582: ST_TO_ADDR
// sSold := false ;
8583: LD_ADDR_EXP 44
8587: PUSH
8588: LD_INT 0
8590: ST_TO_ADDR
// sDiff := false ;
8591: LD_ADDR_EXP 45
8595: PUSH
8596: LD_INT 0
8598: ST_TO_ADDR
// sTiger := false ;
8599: LD_ADDR_EXP 46
8603: PUSH
8604: LD_INT 0
8606: ST_TO_ADDR
// sBomb := false ;
8607: LD_ADDR_EXP 47
8611: PUSH
8612: LD_INT 0
8614: ST_TO_ADDR
// sFog := false ;
8615: LD_ADDR_EXP 48
8619: PUSH
8620: LD_INT 0
8622: ST_TO_ADDR
// sReset := false ;
8623: LD_ADDR_EXP 49
8627: PUSH
8628: LD_INT 0
8630: ST_TO_ADDR
// sSun := false ;
8631: LD_ADDR_EXP 50
8635: PUSH
8636: LD_INT 0
8638: ST_TO_ADDR
// end ;
8639: LD_VAR 0 1
8643: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8644: LD_VAR 0 2
8648: PUSH
8649: LD_INT 100
8651: EQUAL
8652: IFFALSE 9061
// begin if not StreamModeActive then
8654: LD_EXP 29
8658: NOT
8659: IFFALSE 8669
// StreamModeActive := true ;
8661: LD_ADDR_EXP 29
8665: PUSH
8666: LD_INT 1
8668: ST_TO_ADDR
// if p3 = 0 then
8669: LD_VAR 0 3
8673: PUSH
8674: LD_INT 0
8676: EQUAL
8677: IFFALSE 8683
// InitStreamMode ;
8679: CALL 8460 0 0
// if p3 = 1 then
8683: LD_VAR 0 3
8687: PUSH
8688: LD_INT 1
8690: EQUAL
8691: IFFALSE 8701
// sRocket := true ;
8693: LD_ADDR_EXP 32
8697: PUSH
8698: LD_INT 1
8700: ST_TO_ADDR
// if p3 = 2 then
8701: LD_VAR 0 3
8705: PUSH
8706: LD_INT 2
8708: EQUAL
8709: IFFALSE 8719
// sSpeed := true ;
8711: LD_ADDR_EXP 31
8715: PUSH
8716: LD_INT 1
8718: ST_TO_ADDR
// if p3 = 3 then
8719: LD_VAR 0 3
8723: PUSH
8724: LD_INT 3
8726: EQUAL
8727: IFFALSE 8737
// sEngine := true ;
8729: LD_ADDR_EXP 33
8733: PUSH
8734: LD_INT 1
8736: ST_TO_ADDR
// if p3 = 4 then
8737: LD_VAR 0 3
8741: PUSH
8742: LD_INT 4
8744: EQUAL
8745: IFFALSE 8755
// sSpec := true ;
8747: LD_ADDR_EXP 30
8751: PUSH
8752: LD_INT 1
8754: ST_TO_ADDR
// if p3 = 5 then
8755: LD_VAR 0 3
8759: PUSH
8760: LD_INT 5
8762: EQUAL
8763: IFFALSE 8773
// sLevel := true ;
8765: LD_ADDR_EXP 34
8769: PUSH
8770: LD_INT 1
8772: ST_TO_ADDR
// if p3 = 6 then
8773: LD_VAR 0 3
8777: PUSH
8778: LD_INT 6
8780: EQUAL
8781: IFFALSE 8791
// sArmoury := true ;
8783: LD_ADDR_EXP 35
8787: PUSH
8788: LD_INT 1
8790: ST_TO_ADDR
// if p3 = 7 then
8791: LD_VAR 0 3
8795: PUSH
8796: LD_INT 7
8798: EQUAL
8799: IFFALSE 8809
// sRadar := true ;
8801: LD_ADDR_EXP 36
8805: PUSH
8806: LD_INT 1
8808: ST_TO_ADDR
// if p3 = 8 then
8809: LD_VAR 0 3
8813: PUSH
8814: LD_INT 8
8816: EQUAL
8817: IFFALSE 8827
// sBunker := true ;
8819: LD_ADDR_EXP 37
8823: PUSH
8824: LD_INT 1
8826: ST_TO_ADDR
// if p3 = 9 then
8827: LD_VAR 0 3
8831: PUSH
8832: LD_INT 9
8834: EQUAL
8835: IFFALSE 8845
// sHack := true ;
8837: LD_ADDR_EXP 38
8841: PUSH
8842: LD_INT 1
8844: ST_TO_ADDR
// if p3 = 10 then
8845: LD_VAR 0 3
8849: PUSH
8850: LD_INT 10
8852: EQUAL
8853: IFFALSE 8863
// sFire := true ;
8855: LD_ADDR_EXP 39
8859: PUSH
8860: LD_INT 1
8862: ST_TO_ADDR
// if p3 = 11 then
8863: LD_VAR 0 3
8867: PUSH
8868: LD_INT 11
8870: EQUAL
8871: IFFALSE 8881
// sRefresh := true ;
8873: LD_ADDR_EXP 40
8877: PUSH
8878: LD_INT 1
8880: ST_TO_ADDR
// if p3 = 12 then
8881: LD_VAR 0 3
8885: PUSH
8886: LD_INT 12
8888: EQUAL
8889: IFFALSE 8899
// sExp := true ;
8891: LD_ADDR_EXP 41
8895: PUSH
8896: LD_INT 1
8898: ST_TO_ADDR
// if p3 = 13 then
8899: LD_VAR 0 3
8903: PUSH
8904: LD_INT 13
8906: EQUAL
8907: IFFALSE 8917
// sDepot := true ;
8909: LD_ADDR_EXP 42
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// if p3 = 14 then
8917: LD_VAR 0 3
8921: PUSH
8922: LD_INT 14
8924: EQUAL
8925: IFFALSE 8935
// sFlag := true ;
8927: LD_ADDR_EXP 43
8931: PUSH
8932: LD_INT 1
8934: ST_TO_ADDR
// if p3 = 101 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 101
8942: EQUAL
8943: IFFALSE 8953
// sSold := true ;
8945: LD_ADDR_EXP 44
8949: PUSH
8950: LD_INT 1
8952: ST_TO_ADDR
// if p3 = 102 then
8953: LD_VAR 0 3
8957: PUSH
8958: LD_INT 102
8960: EQUAL
8961: IFFALSE 8971
// sDiff := true ;
8963: LD_ADDR_EXP 45
8967: PUSH
8968: LD_INT 1
8970: ST_TO_ADDR
// if p3 = 103 then
8971: LD_VAR 0 3
8975: PUSH
8976: LD_INT 103
8978: EQUAL
8979: IFFALSE 8989
// sFog := true ;
8981: LD_ADDR_EXP 48
8985: PUSH
8986: LD_INT 1
8988: ST_TO_ADDR
// if p3 = 104 then
8989: LD_VAR 0 3
8993: PUSH
8994: LD_INT 104
8996: EQUAL
8997: IFFALSE 9007
// sReset := true ;
8999: LD_ADDR_EXP 49
9003: PUSH
9004: LD_INT 1
9006: ST_TO_ADDR
// if p3 = 105 then
9007: LD_VAR 0 3
9011: PUSH
9012: LD_INT 105
9014: EQUAL
9015: IFFALSE 9025
// sSun := true ;
9017: LD_ADDR_EXP 50
9021: PUSH
9022: LD_INT 1
9024: ST_TO_ADDR
// if p3 = 106 then
9025: LD_VAR 0 3
9029: PUSH
9030: LD_INT 106
9032: EQUAL
9033: IFFALSE 9043
// sTiger := true ;
9035: LD_ADDR_EXP 46
9039: PUSH
9040: LD_INT 1
9042: ST_TO_ADDR
// if p3 = 107 then
9043: LD_VAR 0 3
9047: PUSH
9048: LD_INT 107
9050: EQUAL
9051: IFFALSE 9061
// sBomb := true ;
9053: LD_ADDR_EXP 47
9057: PUSH
9058: LD_INT 1
9060: ST_TO_ADDR
// end ; end ;
9061: PPOPN 6
9063: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
9064: LD_EXP 29
9068: PUSH
9069: LD_EXP 32
9073: AND
9074: IFFALSE 9195
9076: GO 9078
9078: DISABLE
9079: LD_INT 0
9081: PPUSH
9082: PPUSH
// begin enable ;
9083: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
9084: LD_ADDR_VAR 0 2
9088: PUSH
9089: LD_INT 22
9091: PUSH
9092: LD_OWVAR 2
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 2
9103: PUSH
9104: LD_INT 34
9106: PUSH
9107: LD_INT 7
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PUSH
9114: LD_INT 34
9116: PUSH
9117: LD_INT 45
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 34
9126: PUSH
9127: LD_INT 28
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 34
9136: PUSH
9137: LD_INT 47
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: PUSH
9151: EMPTY
9152: LIST
9153: LIST
9154: PPUSH
9155: CALL_OW 69
9159: ST_TO_ADDR
// if not tmp then
9160: LD_VAR 0 2
9164: NOT
9165: IFFALSE 9169
// exit ;
9167: GO 9195
// for i in tmp do
9169: LD_ADDR_VAR 0 1
9173: PUSH
9174: LD_VAR 0 2
9178: PUSH
9179: FOR_IN
9180: IFFALSE 9193
// begin DestroyUnit ( i ) ;
9182: LD_VAR 0 1
9186: PPUSH
9187: CALL_OW 65
// end ;
9191: GO 9179
9193: POP
9194: POP
// end ;
9195: PPOPN 2
9197: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
9198: LD_EXP 29
9202: PUSH
9203: LD_EXP 33
9207: AND
9208: IFFALSE 9289
9210: GO 9212
9212: DISABLE
9213: LD_INT 0
9215: PPUSH
9216: PPUSH
// begin enable ;
9217: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
9218: LD_ADDR_VAR 0 2
9222: PUSH
9223: LD_INT 22
9225: PUSH
9226: LD_OWVAR 2
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PUSH
9235: LD_INT 32
9237: PUSH
9238: LD_INT 3
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: PPUSH
9249: CALL_OW 69
9253: ST_TO_ADDR
// if not tmp then
9254: LD_VAR 0 2
9258: NOT
9259: IFFALSE 9263
// exit ;
9261: GO 9289
// for i in tmp do
9263: LD_ADDR_VAR 0 1
9267: PUSH
9268: LD_VAR 0 2
9272: PUSH
9273: FOR_IN
9274: IFFALSE 9287
// begin DestroyUnit ( i ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: CALL_OW 65
// end ;
9285: GO 9273
9287: POP
9288: POP
// end ;
9289: PPOPN 2
9291: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9292: LD_EXP 29
9296: PUSH
9297: LD_EXP 30
9301: AND
9302: IFFALSE 9395
9304: GO 9306
9306: DISABLE
9307: LD_INT 0
9309: PPUSH
// begin enable ;
9310: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9311: LD_ADDR_VAR 0 1
9315: PUSH
9316: LD_INT 22
9318: PUSH
9319: LD_OWVAR 2
9323: PUSH
9324: EMPTY
9325: LIST
9326: LIST
9327: PUSH
9328: LD_INT 2
9330: PUSH
9331: LD_INT 25
9333: PUSH
9334: LD_INT 5
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: PUSH
9341: LD_INT 25
9343: PUSH
9344: LD_INT 9
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: PUSH
9351: LD_INT 25
9353: PUSH
9354: LD_INT 8
9356: PUSH
9357: EMPTY
9358: LIST
9359: LIST
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: PPUSH
9371: CALL_OW 69
9375: PUSH
9376: FOR_IN
9377: IFFALSE 9393
// begin SetClass ( i , 1 ) ;
9379: LD_VAR 0 1
9383: PPUSH
9384: LD_INT 1
9386: PPUSH
9387: CALL_OW 336
// end ;
9391: GO 9376
9393: POP
9394: POP
// end ;
9395: PPOPN 1
9397: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9398: LD_EXP 29
9402: PUSH
9403: LD_EXP 31
9407: AND
9408: PUSH
9409: LD_OWVAR 65
9413: PUSH
9414: LD_INT 7
9416: LESS
9417: AND
9418: IFFALSE 9432
9420: GO 9422
9422: DISABLE
// begin enable ;
9423: ENABLE
// game_speed := 7 ;
9424: LD_ADDR_OWVAR 65
9428: PUSH
9429: LD_INT 7
9431: ST_TO_ADDR
// end ;
9432: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9433: LD_EXP 29
9437: PUSH
9438: LD_EXP 34
9442: AND
9443: IFFALSE 9645
9445: GO 9447
9447: DISABLE
9448: LD_INT 0
9450: PPUSH
9451: PPUSH
9452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9453: LD_ADDR_VAR 0 3
9457: PUSH
9458: LD_INT 81
9460: PUSH
9461: LD_OWVAR 2
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: PUSH
9470: LD_INT 21
9472: PUSH
9473: LD_INT 1
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: PPUSH
9484: CALL_OW 69
9488: ST_TO_ADDR
// if not tmp then
9489: LD_VAR 0 3
9493: NOT
9494: IFFALSE 9498
// exit ;
9496: GO 9645
// if tmp > 5 then
9498: LD_VAR 0 3
9502: PUSH
9503: LD_INT 5
9505: GREATER
9506: IFFALSE 9518
// k := 5 else
9508: LD_ADDR_VAR 0 2
9512: PUSH
9513: LD_INT 5
9515: ST_TO_ADDR
9516: GO 9528
// k := tmp ;
9518: LD_ADDR_VAR 0 2
9522: PUSH
9523: LD_VAR 0 3
9527: ST_TO_ADDR
// for i := 1 to k do
9528: LD_ADDR_VAR 0 1
9532: PUSH
9533: DOUBLE
9534: LD_INT 1
9536: DEC
9537: ST_TO_ADDR
9538: LD_VAR 0 2
9542: PUSH
9543: FOR_TO
9544: IFFALSE 9643
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9546: LD_VAR 0 3
9550: PUSH
9551: LD_VAR 0 1
9555: ARRAY
9556: PPUSH
9557: LD_VAR 0 1
9561: PUSH
9562: LD_INT 4
9564: MOD
9565: PUSH
9566: LD_INT 1
9568: PLUS
9569: PPUSH
9570: CALL_OW 259
9574: PUSH
9575: LD_INT 10
9577: LESS
9578: IFFALSE 9641
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9580: LD_VAR 0 3
9584: PUSH
9585: LD_VAR 0 1
9589: ARRAY
9590: PPUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_INT 4
9598: MOD
9599: PUSH
9600: LD_INT 1
9602: PLUS
9603: PPUSH
9604: LD_VAR 0 3
9608: PUSH
9609: LD_VAR 0 1
9613: ARRAY
9614: PPUSH
9615: LD_VAR 0 1
9619: PUSH
9620: LD_INT 4
9622: MOD
9623: PUSH
9624: LD_INT 1
9626: PLUS
9627: PPUSH
9628: CALL_OW 259
9632: PUSH
9633: LD_INT 1
9635: PLUS
9636: PPUSH
9637: CALL_OW 237
9641: GO 9543
9643: POP
9644: POP
// end ;
9645: PPOPN 3
9647: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9648: LD_EXP 29
9652: PUSH
9653: LD_EXP 35
9657: AND
9658: IFFALSE 9678
9660: GO 9662
9662: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9663: LD_INT 4
9665: PPUSH
9666: LD_OWVAR 2
9670: PPUSH
9671: LD_INT 0
9673: PPUSH
9674: CALL_OW 324
9678: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9679: LD_EXP 29
9683: PUSH
9684: LD_EXP 36
9688: AND
9689: IFFALSE 9788
9691: GO 9693
9693: DISABLE
9694: LD_INT 0
9696: PPUSH
9697: PPUSH
// begin enable ;
9698: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9699: LD_ADDR_VAR 0 2
9703: PUSH
9704: LD_INT 22
9706: PUSH
9707: LD_OWVAR 2
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: PUSH
9716: LD_INT 2
9718: PUSH
9719: LD_INT 34
9721: PUSH
9722: LD_INT 11
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 34
9731: PUSH
9732: LD_INT 30
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: PPUSH
9748: CALL_OW 69
9752: ST_TO_ADDR
// if not tmp then
9753: LD_VAR 0 2
9757: NOT
9758: IFFALSE 9762
// exit ;
9760: GO 9788
// for i in tmp do
9762: LD_ADDR_VAR 0 1
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9786
// begin DestroyUnit ( i ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: CALL_OW 65
// end ;
9784: GO 9772
9786: POP
9787: POP
// end ;
9788: PPOPN 2
9790: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9791: LD_EXP 29
9795: PUSH
9796: LD_EXP 37
9800: AND
9801: IFFALSE 9821
9803: GO 9805
9805: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9806: LD_INT 32
9808: PPUSH
9809: LD_OWVAR 2
9813: PPUSH
9814: LD_INT 0
9816: PPUSH
9817: CALL_OW 324
9821: END
// every 0 0$1 trigger StreamModeActive and sHack do
9822: LD_EXP 29
9826: PUSH
9827: LD_EXP 38
9831: AND
9832: IFFALSE 9852
9834: GO 9836
9836: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
9837: LD_INT 33
9839: PPUSH
9840: LD_OWVAR 2
9844: PPUSH
9845: LD_INT 0
9847: PPUSH
9848: CALL_OW 322
9852: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9853: LD_EXP 29
9857: PUSH
9858: LD_EXP 39
9862: AND
9863: IFFALSE 9942
9865: GO 9867
9867: DISABLE
9868: LD_INT 0
9870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9871: LD_ADDR_VAR 0 1
9875: PUSH
9876: LD_INT 22
9878: PUSH
9879: LD_OWVAR 2
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PUSH
9888: LD_INT 21
9890: PUSH
9891: LD_INT 3
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PUSH
9898: EMPTY
9899: LIST
9900: LIST
9901: PPUSH
9902: CALL_OW 69
9906: ST_TO_ADDR
// if not tmp then
9907: LD_VAR 0 1
9911: NOT
9912: IFFALSE 9916
// exit ;
9914: GO 9942
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
9916: LD_VAR 0 1
9920: PUSH
9921: LD_INT 1
9923: PPUSH
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 12
9933: ARRAY
9934: PPUSH
9935: LD_INT 100
9937: PPUSH
9938: CALL_OW 234
// end ;
9942: PPOPN 1
9944: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
9945: LD_EXP 29
9949: PUSH
9950: LD_EXP 41
9954: AND
9955: IFFALSE 10053
9957: GO 9959
9959: DISABLE
9960: LD_INT 0
9962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9963: LD_ADDR_VAR 0 1
9967: PUSH
9968: LD_INT 22
9970: PUSH
9971: LD_OWVAR 2
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: PUSH
9980: LD_INT 21
9982: PUSH
9983: LD_INT 1
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: PPUSH
9994: CALL_OW 69
9998: ST_TO_ADDR
// if not tmp then
9999: LD_VAR 0 1
10003: NOT
10004: IFFALSE 10008
// exit ;
10006: GO 10053
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10008: LD_VAR 0 1
10012: PUSH
10013: LD_INT 1
10015: PPUSH
10016: LD_VAR 0 1
10020: PPUSH
10021: CALL_OW 12
10025: ARRAY
10026: PPUSH
10027: LD_INT 1
10029: PPUSH
10030: LD_INT 4
10032: PPUSH
10033: CALL_OW 12
10037: PPUSH
10038: LD_INT 3000
10040: PPUSH
10041: LD_INT 9000
10043: PPUSH
10044: CALL_OW 12
10048: PPUSH
10049: CALL_OW 492
// end ;
10053: PPOPN 1
10055: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10056: LD_EXP 29
10060: PUSH
10061: LD_EXP 42
10065: AND
10066: IFFALSE 10086
10068: GO 10070
10070: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10071: LD_INT 1
10073: PPUSH
10074: LD_OWVAR 2
10078: PPUSH
10079: LD_INT 0
10081: PPUSH
10082: CALL_OW 324
10086: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10087: LD_EXP 29
10091: PUSH
10092: LD_EXP 43
10096: AND
10097: IFFALSE 10180
10099: GO 10101
10101: DISABLE
10102: LD_INT 0
10104: PPUSH
10105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10106: LD_ADDR_VAR 0 2
10110: PUSH
10111: LD_INT 22
10113: PUSH
10114: LD_OWVAR 2
10118: PUSH
10119: EMPTY
10120: LIST
10121: LIST
10122: PUSH
10123: LD_INT 21
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: EMPTY
10130: LIST
10131: LIST
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PPUSH
10137: CALL_OW 69
10141: ST_TO_ADDR
// if not tmp then
10142: LD_VAR 0 2
10146: NOT
10147: IFFALSE 10151
// exit ;
10149: GO 10180
// for i in tmp do
10151: LD_ADDR_VAR 0 1
10155: PUSH
10156: LD_VAR 0 2
10160: PUSH
10161: FOR_IN
10162: IFFALSE 10178
// SetBLevel ( i , 10 ) ;
10164: LD_VAR 0 1
10168: PPUSH
10169: LD_INT 10
10171: PPUSH
10172: CALL_OW 241
10176: GO 10161
10178: POP
10179: POP
// end ;
10180: PPOPN 2
10182: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
10183: LD_EXP 29
10187: PUSH
10188: LD_EXP 44
10192: AND
10193: IFFALSE 10276
10195: GO 10197
10197: DISABLE
10198: LD_INT 0
10200: PPUSH
10201: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10202: LD_ADDR_VAR 0 2
10206: PUSH
10207: LD_INT 22
10209: PUSH
10210: LD_OWVAR 2
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PUSH
10219: LD_INT 25
10221: PUSH
10222: LD_INT 1
10224: PUSH
10225: EMPTY
10226: LIST
10227: LIST
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PPUSH
10233: CALL_OW 69
10237: ST_TO_ADDR
// if not tmp then
10238: LD_VAR 0 2
10242: NOT
10243: IFFALSE 10247
// exit ;
10245: GO 10276
// for i in tmp do
10247: LD_ADDR_VAR 0 1
10251: PUSH
10252: LD_VAR 0 2
10256: PUSH
10257: FOR_IN
10258: IFFALSE 10274
// SetClass ( i , 4 ) ;
10260: LD_VAR 0 1
10264: PPUSH
10265: LD_INT 4
10267: PPUSH
10268: CALL_OW 336
10272: GO 10257
10274: POP
10275: POP
// end ;
10276: PPOPN 2
10278: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10279: LD_EXP 29
10283: PUSH
10284: LD_EXP 45
10288: AND
10289: PUSH
10290: LD_OWVAR 67
10294: PUSH
10295: LD_INT 3
10297: LESS
10298: AND
10299: IFFALSE 10318
10301: GO 10303
10303: DISABLE
// Difficulty := Difficulty + 1 ;
10304: LD_ADDR_OWVAR 67
10308: PUSH
10309: LD_OWVAR 67
10313: PUSH
10314: LD_INT 1
10316: PLUS
10317: ST_TO_ADDR
10318: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10319: LD_EXP 29
10323: PUSH
10324: LD_EXP 46
10328: AND
10329: IFFALSE 10432
10331: GO 10333
10333: DISABLE
10334: LD_INT 0
10336: PPUSH
// begin for i := 1 to 5 do
10337: LD_ADDR_VAR 0 1
10341: PUSH
10342: DOUBLE
10343: LD_INT 1
10345: DEC
10346: ST_TO_ADDR
10347: LD_INT 5
10349: PUSH
10350: FOR_TO
10351: IFFALSE 10430
// begin uc_nation := nation_nature ;
10353: LD_ADDR_OWVAR 21
10357: PUSH
10358: LD_INT 0
10360: ST_TO_ADDR
// uc_side := 0 ;
10361: LD_ADDR_OWVAR 20
10365: PUSH
10366: LD_INT 0
10368: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10369: LD_ADDR_OWVAR 29
10373: PUSH
10374: LD_INT 12
10376: PUSH
10377: LD_INT 12
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: ST_TO_ADDR
// hc_agressivity := 20 ;
10384: LD_ADDR_OWVAR 35
10388: PUSH
10389: LD_INT 20
10391: ST_TO_ADDR
// hc_class := class_tiger ;
10392: LD_ADDR_OWVAR 28
10396: PUSH
10397: LD_INT 14
10399: ST_TO_ADDR
// hc_gallery :=  ;
10400: LD_ADDR_OWVAR 33
10404: PUSH
10405: LD_STRING 
10407: ST_TO_ADDR
// hc_name :=  ;
10408: LD_ADDR_OWVAR 26
10412: PUSH
10413: LD_STRING 
10415: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10416: CALL_OW 44
10420: PPUSH
10421: LD_INT 0
10423: PPUSH
10424: CALL_OW 51
// end ;
10428: GO 10350
10430: POP
10431: POP
// end ;
10432: PPOPN 1
10434: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
10435: LD_EXP 29
10439: PUSH
10440: LD_EXP 47
10444: AND
10445: IFFALSE 10619
10447: GO 10449
10449: DISABLE
10450: LD_INT 0
10452: PPUSH
10453: PPUSH
10454: PPUSH
10455: PPUSH
// begin result := false ;
10456: LD_ADDR_VAR 0 4
10460: PUSH
10461: LD_INT 0
10463: ST_TO_ADDR
// for i := 1 to 8 do
10464: LD_ADDR_VAR 0 1
10468: PUSH
10469: DOUBLE
10470: LD_INT 1
10472: DEC
10473: ST_TO_ADDR
10474: LD_INT 8
10476: PUSH
10477: FOR_TO
10478: IFFALSE 10589
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: LD_INT 10
10487: PUSH
10488: LD_INT 50
10490: PUSH
10491: LD_INT 90
10493: PUSH
10494: LD_INT 140
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: LIST
10501: LIST
10502: PUSH
10503: LD_INT 1
10505: PPUSH
10506: LD_INT 4
10508: PPUSH
10509: CALL_OW 12
10513: ARRAY
10514: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10515: LD_ADDR_VAR 0 3
10519: PUSH
10520: LD_INT 10
10522: PUSH
10523: LD_INT 50
10525: PUSH
10526: LD_INT 90
10528: PUSH
10529: LD_INT 140
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 1
10540: PPUSH
10541: LD_INT 4
10543: PPUSH
10544: CALL_OW 12
10548: ARRAY
10549: ST_TO_ADDR
// if ValidHex ( x , y ) then
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 3
10559: PPUSH
10560: CALL_OW 488
10564: IFFALSE 10587
// begin result := [ x , y ] ;
10566: LD_ADDR_VAR 0 4
10570: PUSH
10571: LD_VAR 0 2
10575: PUSH
10576: LD_VAR 0 3
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: ST_TO_ADDR
// break ;
10585: GO 10589
// end ; end ;
10587: GO 10477
10589: POP
10590: POP
// if result then
10591: LD_VAR 0 4
10595: IFFALSE 10619
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10597: LD_VAR 0 4
10601: PUSH
10602: LD_INT 1
10604: ARRAY
10605: PPUSH
10606: LD_VAR 0 4
10610: PUSH
10611: LD_INT 2
10613: ARRAY
10614: PPUSH
10615: CALL_OW 429
// end ;
10619: PPOPN 4
10621: END
// every 0 0$1 trigger StreamModeActive and sReset do
10622: LD_EXP 29
10626: PUSH
10627: LD_EXP 49
10631: AND
10632: IFFALSE 10644
10634: GO 10636
10636: DISABLE
// YouLost (  ) ;
10637: LD_STRING 
10639: PPUSH
10640: CALL_OW 104
10644: END
// every 0 0$1 trigger StreamModeActive and sFog do
10645: LD_EXP 29
10649: PUSH
10650: LD_EXP 48
10654: AND
10655: IFFALSE 10669
10657: GO 10659
10659: DISABLE
// FogOff ( your_side ) ;
10660: LD_OWVAR 2
10664: PPUSH
10665: CALL_OW 344
10669: END
// every 0 0$1 trigger StreamModeActive and sSun do
10670: LD_EXP 29
10674: PUSH
10675: LD_EXP 50
10679: AND
10680: IFFALSE 10708
10682: GO 10684
10684: DISABLE
// begin solar_recharge_percent := 0 ;
10685: LD_ADDR_OWVAR 79
10689: PUSH
10690: LD_INT 0
10692: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10693: LD_INT 10500
10695: PPUSH
10696: CALL_OW 67
// solar_recharge_percent := 100 ;
10700: LD_ADDR_OWVAR 79
10704: PUSH
10705: LD_INT 100
10707: ST_TO_ADDR
// end ; end_of_file
10708: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
10709: LD_INT 0
10711: PPUSH
10712: PPUSH
10713: PPUSH
10714: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
10715: LD_VAR 0 1
10719: PPUSH
10720: CALL_OW 264
10724: PUSH
10725: LD_EXP 28
10729: EQUAL
10730: IFFALSE 10802
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
10732: LD_INT 68
10734: PPUSH
10735: LD_VAR 0 1
10739: PPUSH
10740: CALL_OW 255
10744: PPUSH
10745: CALL_OW 321
10749: PUSH
10750: LD_INT 2
10752: EQUAL
10753: IFFALSE 10765
// eff := 70 else
10755: LD_ADDR_VAR 0 6
10759: PUSH
10760: LD_INT 70
10762: ST_TO_ADDR
10763: GO 10773
// eff := 30 ;
10765: LD_ADDR_VAR 0 6
10769: PUSH
10770: LD_INT 30
10772: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: CALL_OW 250
10782: PPUSH
10783: LD_VAR 0 1
10787: PPUSH
10788: CALL_OW 251
10792: PPUSH
10793: LD_VAR 0 6
10797: PPUSH
10798: CALL_OW 495
// end ; end ;
10802: LD_VAR 0 4
10806: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
10807: LD_INT 0
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
10813: PPUSH
10814: PPUSH
// if cmd = 124 then
10815: LD_VAR 0 1
10819: PUSH
10820: LD_INT 124
10822: EQUAL
10823: IFFALSE 11029
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
10825: LD_ADDR_VAR 0 5
10829: PUSH
10830: LD_INT 2
10832: PUSH
10833: LD_INT 34
10835: PUSH
10836: LD_INT 53
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PUSH
10843: LD_INT 34
10845: PUSH
10846: LD_INT 14
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: LIST
10857: PPUSH
10858: CALL_OW 69
10862: ST_TO_ADDR
// if not tmp then
10863: LD_VAR 0 5
10867: NOT
10868: IFFALSE 10872
// exit ;
10870: GO 11029
// for i in tmp do
10872: LD_ADDR_VAR 0 3
10876: PUSH
10877: LD_VAR 0 5
10881: PUSH
10882: FOR_IN
10883: IFFALSE 11027
// begin taskList := GetTaskList ( i ) ;
10885: LD_ADDR_VAR 0 6
10889: PUSH
10890: LD_VAR 0 3
10894: PPUSH
10895: CALL_OW 437
10899: ST_TO_ADDR
// if not taskList then
10900: LD_VAR 0 6
10904: NOT
10905: IFFALSE 10909
// continue ;
10907: GO 10882
// for j = 1 to taskList do
10909: LD_ADDR_VAR 0 4
10913: PUSH
10914: DOUBLE
10915: LD_INT 1
10917: DEC
10918: ST_TO_ADDR
10919: LD_VAR 0 6
10923: PUSH
10924: FOR_TO
10925: IFFALSE 11023
// if taskList [ j ] [ 1 ] = | then
10927: LD_VAR 0 6
10931: PUSH
10932: LD_VAR 0 4
10936: ARRAY
10937: PUSH
10938: LD_INT 1
10940: ARRAY
10941: PUSH
10942: LD_STRING |
10944: EQUAL
10945: IFFALSE 11021
// begin _taskList := Delete ( taskList , 1 ) ;
10947: LD_ADDR_VAR 0 7
10951: PUSH
10952: LD_VAR 0 6
10956: PPUSH
10957: LD_INT 1
10959: PPUSH
10960: CALL_OW 3
10964: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
10965: LD_VAR 0 3
10969: PPUSH
10970: LD_VAR 0 7
10974: PPUSH
10975: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
10979: LD_VAR 0 3
10983: PPUSH
10984: LD_VAR 0 6
10988: PUSH
10989: LD_VAR 0 4
10993: ARRAY
10994: PUSH
10995: LD_INT 2
10997: ARRAY
10998: PPUSH
10999: LD_VAR 0 6
11003: PUSH
11004: LD_VAR 0 4
11008: ARRAY
11009: PUSH
11010: LD_INT 3
11012: ARRAY
11013: PPUSH
11014: LD_INT 8
11016: PPUSH
11017: CALL 11034 0 4
// end ;
11021: GO 10924
11023: POP
11024: POP
// end ;
11025: GO 10882
11027: POP
11028: POP
// end ; end ;
11029: LD_VAR 0 2
11033: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11034: LD_INT 0
11036: PPUSH
11037: PPUSH
11038: PPUSH
11039: PPUSH
11040: PPUSH
11041: PPUSH
11042: PPUSH
11043: PPUSH
11044: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11045: LD_VAR 0 1
11049: NOT
11050: PUSH
11051: LD_VAR 0 2
11055: PPUSH
11056: LD_VAR 0 3
11060: PPUSH
11061: CALL_OW 488
11065: NOT
11066: OR
11067: PUSH
11068: LD_VAR 0 4
11072: NOT
11073: OR
11074: IFFALSE 11078
// exit ;
11076: GO 11418
// list := [ ] ;
11078: LD_ADDR_VAR 0 13
11082: PUSH
11083: EMPTY
11084: ST_TO_ADDR
// if x - r < 0 then
11085: LD_VAR 0 2
11089: PUSH
11090: LD_VAR 0 4
11094: MINUS
11095: PUSH
11096: LD_INT 0
11098: LESS
11099: IFFALSE 11111
// min_x := 0 else
11101: LD_ADDR_VAR 0 7
11105: PUSH
11106: LD_INT 0
11108: ST_TO_ADDR
11109: GO 11127
// min_x := x - r ;
11111: LD_ADDR_VAR 0 7
11115: PUSH
11116: LD_VAR 0 2
11120: PUSH
11121: LD_VAR 0 4
11125: MINUS
11126: ST_TO_ADDR
// if y - r < 0 then
11127: LD_VAR 0 3
11131: PUSH
11132: LD_VAR 0 4
11136: MINUS
11137: PUSH
11138: LD_INT 0
11140: LESS
11141: IFFALSE 11153
// min_y := 0 else
11143: LD_ADDR_VAR 0 8
11147: PUSH
11148: LD_INT 0
11150: ST_TO_ADDR
11151: GO 11169
// min_y := y - r ;
11153: LD_ADDR_VAR 0 8
11157: PUSH
11158: LD_VAR 0 3
11162: PUSH
11163: LD_VAR 0 4
11167: MINUS
11168: ST_TO_ADDR
// max_x := x + r ;
11169: LD_ADDR_VAR 0 9
11173: PUSH
11174: LD_VAR 0 2
11178: PUSH
11179: LD_VAR 0 4
11183: PLUS
11184: ST_TO_ADDR
// max_y := y + r ;
11185: LD_ADDR_VAR 0 10
11189: PUSH
11190: LD_VAR 0 3
11194: PUSH
11195: LD_VAR 0 4
11199: PLUS
11200: ST_TO_ADDR
// for _x = min_x to max_x do
11201: LD_ADDR_VAR 0 11
11205: PUSH
11206: DOUBLE
11207: LD_VAR 0 7
11211: DEC
11212: ST_TO_ADDR
11213: LD_VAR 0 9
11217: PUSH
11218: FOR_TO
11219: IFFALSE 11336
// for _y = min_y to max_y do
11221: LD_ADDR_VAR 0 12
11225: PUSH
11226: DOUBLE
11227: LD_VAR 0 8
11231: DEC
11232: ST_TO_ADDR
11233: LD_VAR 0 10
11237: PUSH
11238: FOR_TO
11239: IFFALSE 11332
// begin if not ValidHex ( _x , _y ) then
11241: LD_VAR 0 11
11245: PPUSH
11246: LD_VAR 0 12
11250: PPUSH
11251: CALL_OW 488
11255: NOT
11256: IFFALSE 11260
// continue ;
11258: GO 11238
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11260: LD_VAR 0 11
11264: PPUSH
11265: LD_VAR 0 12
11269: PPUSH
11270: CALL_OW 351
11274: PUSH
11275: LD_VAR 0 11
11279: PPUSH
11280: LD_VAR 0 12
11284: PPUSH
11285: CALL_OW 554
11289: AND
11290: IFFALSE 11330
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11292: LD_ADDR_VAR 0 13
11296: PUSH
11297: LD_VAR 0 13
11301: PPUSH
11302: LD_VAR 0 13
11306: PUSH
11307: LD_INT 1
11309: PLUS
11310: PPUSH
11311: LD_VAR 0 11
11315: PUSH
11316: LD_VAR 0 12
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PPUSH
11325: CALL_OW 2
11329: ST_TO_ADDR
// end ;
11330: GO 11238
11332: POP
11333: POP
11334: GO 11218
11336: POP
11337: POP
// if not list then
11338: LD_VAR 0 13
11342: NOT
11343: IFFALSE 11347
// exit ;
11345: GO 11418
// for i in list do
11347: LD_ADDR_VAR 0 6
11351: PUSH
11352: LD_VAR 0 13
11356: PUSH
11357: FOR_IN
11358: IFFALSE 11416
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
11360: LD_VAR 0 1
11364: PPUSH
11365: LD_STRING M
11367: PUSH
11368: LD_VAR 0 6
11372: PUSH
11373: LD_INT 1
11375: ARRAY
11376: PUSH
11377: LD_VAR 0 6
11381: PUSH
11382: LD_INT 2
11384: ARRAY
11385: PUSH
11386: LD_INT 0
11388: PUSH
11389: LD_INT 0
11391: PUSH
11392: LD_INT 0
11394: PUSH
11395: LD_INT 0
11397: PUSH
11398: EMPTY
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: PUSH
11407: EMPTY
11408: LIST
11409: PPUSH
11410: CALL_OW 447
11414: GO 11357
11416: POP
11417: POP
// end ;
11418: LD_VAR 0 5
11422: RET
