// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5335 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2178 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1633 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1633 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// if mastodonts then
1058: LD_VAR 0 6
1062: IFFALSE 1129
// for i = 1 to mastodonts do
1064: LD_ADDR_VAR 0 11
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 6
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1127
// begin vc_chassis := 31 ;
1082: LD_ADDR_OWVAR 37
1086: PUSH
1087: LD_INT 31
1089: ST_TO_ADDR
// vc_control := control_rider ;
1090: LD_ADDR_OWVAR 38
1094: PUSH
1095: LD_INT 4
1097: ST_TO_ADDR
// animal := CreateVehicle ;
1098: LD_ADDR_VAR 0 12
1102: PUSH
1103: CALL_OW 45
1107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1108: LD_VAR 0 12
1112: PPUSH
1113: LD_VAR 0 8
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL 1633 0 3
// end ;
1125: GO 1079
1127: POP
1128: POP
// if horses then
1129: LD_VAR 0 5
1133: IFFALSE 1200
// for i = 1 to horses do
1135: LD_ADDR_VAR 0 11
1139: PUSH
1140: DOUBLE
1141: LD_INT 1
1143: DEC
1144: ST_TO_ADDR
1145: LD_VAR 0 5
1149: PUSH
1150: FOR_TO
1151: IFFALSE 1198
// begin hc_class := 21 ;
1153: LD_ADDR_OWVAR 28
1157: PUSH
1158: LD_INT 21
1160: ST_TO_ADDR
// hc_gallery :=  ;
1161: LD_ADDR_OWVAR 33
1165: PUSH
1166: LD_STRING 
1168: ST_TO_ADDR
// animal := CreateHuman ;
1169: LD_ADDR_VAR 0 12
1173: PUSH
1174: CALL_OW 44
1178: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1179: LD_VAR 0 12
1183: PPUSH
1184: LD_VAR 0 8
1188: PPUSH
1189: LD_INT 0
1191: PPUSH
1192: CALL 1633 0 3
// end ;
1196: GO 1150
1198: POP
1199: POP
// if birds then
1200: LD_VAR 0 1
1204: IFFALSE 1271
// for i = 1 to birds do
1206: LD_ADDR_VAR 0 11
1210: PUSH
1211: DOUBLE
1212: LD_INT 1
1214: DEC
1215: ST_TO_ADDR
1216: LD_VAR 0 1
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1269
// begin hc_class = 18 ;
1224: LD_ADDR_OWVAR 28
1228: PUSH
1229: LD_INT 18
1231: ST_TO_ADDR
// hc_gallery =  ;
1232: LD_ADDR_OWVAR 33
1236: PUSH
1237: LD_STRING 
1239: ST_TO_ADDR
// animal := CreateHuman ;
1240: LD_ADDR_VAR 0 12
1244: PUSH
1245: CALL_OW 44
1249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1250: LD_VAR 0 12
1254: PPUSH
1255: LD_VAR 0 8
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL 1633 0 3
// end ;
1267: GO 1221
1269: POP
1270: POP
// if tigers then
1271: LD_VAR 0 2
1275: IFFALSE 1359
// for i = 1 to tigers do
1277: LD_ADDR_VAR 0 11
1281: PUSH
1282: DOUBLE
1283: LD_INT 1
1285: DEC
1286: ST_TO_ADDR
1287: LD_VAR 0 2
1291: PUSH
1292: FOR_TO
1293: IFFALSE 1357
// begin hc_class = class_tiger ;
1295: LD_ADDR_OWVAR 28
1299: PUSH
1300: LD_INT 14
1302: ST_TO_ADDR
// hc_gallery =  ;
1303: LD_ADDR_OWVAR 33
1307: PUSH
1308: LD_STRING 
1310: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1311: LD_ADDR_OWVAR 35
1315: PUSH
1316: LD_INT 7
1318: NEG
1319: PPUSH
1320: LD_INT 7
1322: PPUSH
1323: CALL_OW 12
1327: ST_TO_ADDR
// animal := CreateHuman ;
1328: LD_ADDR_VAR 0 12
1332: PUSH
1333: CALL_OW 44
1337: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1338: LD_VAR 0 12
1342: PPUSH
1343: LD_VAR 0 8
1347: PPUSH
1348: LD_INT 0
1350: PPUSH
1351: CALL 1633 0 3
// end ;
1355: GO 1292
1357: POP
1358: POP
// if apemans then
1359: LD_VAR 0 3
1363: IFFALSE 1486
// for i = 1 to apemans do
1365: LD_ADDR_VAR 0 11
1369: PUSH
1370: DOUBLE
1371: LD_INT 1
1373: DEC
1374: ST_TO_ADDR
1375: LD_VAR 0 3
1379: PUSH
1380: FOR_TO
1381: IFFALSE 1484
// begin hc_class = class_apeman ;
1383: LD_ADDR_OWVAR 28
1387: PUSH
1388: LD_INT 12
1390: ST_TO_ADDR
// hc_gallery =  ;
1391: LD_ADDR_OWVAR 33
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1399: LD_ADDR_OWVAR 35
1403: PUSH
1404: LD_INT 5
1406: NEG
1407: PPUSH
1408: LD_INT 5
1410: PPUSH
1411: CALL_OW 12
1415: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1416: LD_ADDR_OWVAR 31
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_INT 3
1426: PPUSH
1427: CALL_OW 12
1431: PUSH
1432: LD_INT 1
1434: PPUSH
1435: LD_INT 3
1437: PPUSH
1438: CALL_OW 12
1442: PUSH
1443: LD_INT 0
1445: PUSH
1446: LD_INT 0
1448: PUSH
1449: EMPTY
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: ST_TO_ADDR
// animal := CreateHuman ;
1455: LD_ADDR_VAR 0 12
1459: PUSH
1460: CALL_OW 44
1464: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1465: LD_VAR 0 12
1469: PPUSH
1470: LD_VAR 0 8
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL 1633 0 3
// end ;
1482: GO 1380
1484: POP
1485: POP
// if enchidnas then
1486: LD_VAR 0 4
1490: IFFALSE 1557
// for i = 1 to enchidnas do
1492: LD_ADDR_VAR 0 11
1496: PUSH
1497: DOUBLE
1498: LD_INT 1
1500: DEC
1501: ST_TO_ADDR
1502: LD_VAR 0 4
1506: PUSH
1507: FOR_TO
1508: IFFALSE 1555
// begin hc_class = 13 ;
1510: LD_ADDR_OWVAR 28
1514: PUSH
1515: LD_INT 13
1517: ST_TO_ADDR
// hc_gallery =  ;
1518: LD_ADDR_OWVAR 33
1522: PUSH
1523: LD_STRING 
1525: ST_TO_ADDR
// animal := CreateHuman ;
1526: LD_ADDR_VAR 0 12
1530: PUSH
1531: CALL_OW 44
1535: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1536: LD_VAR 0 12
1540: PPUSH
1541: LD_VAR 0 8
1545: PPUSH
1546: LD_INT 0
1548: PPUSH
1549: CALL 1633 0 3
// end ;
1553: GO 1507
1555: POP
1556: POP
// if fishes then
1557: LD_VAR 0 7
1561: IFFALSE 1628
// for i = 1 to fishes do
1563: LD_ADDR_VAR 0 11
1567: PUSH
1568: DOUBLE
1569: LD_INT 1
1571: DEC
1572: ST_TO_ADDR
1573: LD_VAR 0 7
1577: PUSH
1578: FOR_TO
1579: IFFALSE 1626
// begin hc_class = 20 ;
1581: LD_ADDR_OWVAR 28
1585: PUSH
1586: LD_INT 20
1588: ST_TO_ADDR
// hc_gallery =  ;
1589: LD_ADDR_OWVAR 33
1593: PUSH
1594: LD_STRING 
1596: ST_TO_ADDR
// animal := CreateHuman ;
1597: LD_ADDR_VAR 0 12
1601: PUSH
1602: CALL_OW 44
1606: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1607: LD_VAR 0 12
1611: PPUSH
1612: LD_VAR 0 9
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: CALL 1633 0 3
// end ;
1624: GO 1578
1626: POP
1627: POP
// end ;
1628: LD_VAR 0 10
1632: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1633: LD_INT 0
1635: PPUSH
1636: PPUSH
1637: PPUSH
1638: PPUSH
// if not unit or not area then
1639: LD_VAR 0 1
1643: NOT
1644: PUSH
1645: LD_VAR 0 2
1649: NOT
1650: OR
1651: IFFALSE 1655
// exit ;
1653: GO 1819
// tmp := AreaToList ( area , i ) ;
1655: LD_ADDR_VAR 0 6
1659: PUSH
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_VAR 0 5
1669: PPUSH
1670: CALL_OW 517
1674: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_VAR 0 6
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1817
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1697: LD_ADDR_VAR 0 7
1701: PUSH
1702: LD_VAR 0 6
1706: PUSH
1707: LD_INT 1
1709: ARRAY
1710: PUSH
1711: LD_VAR 0 5
1715: ARRAY
1716: PUSH
1717: LD_VAR 0 6
1721: PUSH
1722: LD_INT 2
1724: ARRAY
1725: PUSH
1726: LD_VAR 0 5
1730: ARRAY
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1736: LD_VAR 0 7
1740: PUSH
1741: LD_INT 1
1743: ARRAY
1744: PPUSH
1745: LD_VAR 0 7
1749: PUSH
1750: LD_INT 2
1752: ARRAY
1753: PPUSH
1754: CALL_OW 428
1758: PUSH
1759: LD_INT 0
1761: EQUAL
1762: IFFALSE 1815
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1764: LD_VAR 0 1
1768: PPUSH
1769: LD_VAR 0 7
1773: PUSH
1774: LD_INT 1
1776: ARRAY
1777: PPUSH
1778: LD_VAR 0 7
1782: PUSH
1783: LD_INT 2
1785: ARRAY
1786: PPUSH
1787: LD_VAR 0 3
1791: PPUSH
1792: CALL_OW 48
// result := IsPlaced ( unit ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 305
1810: ST_TO_ADDR
// exit ;
1811: POP
1812: POP
1813: GO 1819
// end ; end ;
1815: GO 1694
1817: POP
1818: POP
// end ;
1819: LD_VAR 0 4
1823: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1824: LD_INT 0
1826: PPUSH
1827: PPUSH
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1832: LD_VAR 0 1
1836: NOT
1837: PUSH
1838: LD_VAR 0 1
1842: PPUSH
1843: CALL_OW 263
1847: PUSH
1848: LD_INT 2
1850: EQUAL
1851: NOT
1852: OR
1853: IFFALSE 1857
// exit ;
1855: GO 2173
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1857: LD_ADDR_VAR 0 6
1861: PUSH
1862: LD_INT 22
1864: PUSH
1865: LD_VAR 0 1
1869: PPUSH
1870: CALL_OW 255
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 30
1884: PUSH
1885: LD_INT 36
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 34
1894: PUSH
1895: LD_INT 31
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: PPUSH
1911: CALL_OW 69
1915: ST_TO_ADDR
// if not tmp then
1916: LD_VAR 0 6
1920: NOT
1921: IFFALSE 1925
// exit ;
1923: GO 2173
// result := [ ] ;
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: EMPTY
1931: ST_TO_ADDR
// for i in tmp do
1932: LD_ADDR_VAR 0 3
1936: PUSH
1937: LD_VAR 0 6
1941: PUSH
1942: FOR_IN
1943: IFFALSE 2014
// begin t := UnitsInside ( i ) ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 313
1959: ST_TO_ADDR
// if t then
1960: LD_VAR 0 4
1964: IFFALSE 2012
// for j in t do
1966: LD_ADDR_VAR 0 7
1970: PUSH
1971: LD_VAR 0 4
1975: PUSH
1976: FOR_IN
1977: IFFALSE 2010
// result := Insert ( result , result + 1 , j ) ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_VAR 0 2
1988: PPUSH
1989: LD_VAR 0 2
1993: PUSH
1994: LD_INT 1
1996: PLUS
1997: PPUSH
1998: LD_VAR 0 7
2002: PPUSH
2003: CALL_OW 2
2007: ST_TO_ADDR
2008: GO 1976
2010: POP
2011: POP
// end ;
2012: GO 1942
2014: POP
2015: POP
// if not result then
2016: LD_VAR 0 2
2020: NOT
2021: IFFALSE 2025
// exit ;
2023: GO 2173
// mech := result [ 1 ] ;
2025: LD_ADDR_VAR 0 5
2029: PUSH
2030: LD_VAR 0 2
2034: PUSH
2035: LD_INT 1
2037: ARRAY
2038: ST_TO_ADDR
// if result > 1 then
2039: LD_VAR 0 2
2043: PUSH
2044: LD_INT 1
2046: GREATER
2047: IFFALSE 2159
// for i = 2 to result do
2049: LD_ADDR_VAR 0 3
2053: PUSH
2054: DOUBLE
2055: LD_INT 2
2057: DEC
2058: ST_TO_ADDR
2059: LD_VAR 0 2
2063: PUSH
2064: FOR_TO
2065: IFFALSE 2157
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2067: LD_ADDR_VAR 0 4
2071: PUSH
2072: LD_VAR 0 2
2076: PUSH
2077: LD_VAR 0 3
2081: ARRAY
2082: PPUSH
2083: LD_INT 3
2085: PPUSH
2086: CALL_OW 259
2090: PUSH
2091: LD_VAR 0 2
2095: PUSH
2096: LD_VAR 0 3
2100: ARRAY
2101: PPUSH
2102: CALL_OW 432
2106: MINUS
2107: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2108: LD_VAR 0 4
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_INT 3
2120: PPUSH
2121: CALL_OW 259
2125: PUSH
2126: LD_VAR 0 5
2130: PPUSH
2131: CALL_OW 432
2135: MINUS
2136: GREATEREQUAL
2137: IFFALSE 2155
// mech := result [ i ] ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 2
2148: PUSH
2149: LD_VAR 0 3
2153: ARRAY
2154: ST_TO_ADDR
// end ;
2155: GO 2064
2157: POP
2158: POP
// ComLinkTo ( vehicle , mech ) ;
2159: LD_VAR 0 1
2163: PPUSH
2164: LD_VAR 0 5
2168: PPUSH
2169: CALL_OW 135
// end ; end_of_file
2173: LD_VAR 0 2
2177: RET
// export function Action ; begin
2178: LD_INT 0
2180: PPUSH
// InGameOn ;
2181: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2185: LD_INT 221
2187: PPUSH
2188: LD_INT 80
2190: PPUSH
2191: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2195: LD_EXP 14
2199: PUSH
2200: LD_EXP 15
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: LD_INT 217
2211: PPUSH
2212: LD_INT 79
2214: PPUSH
2215: CALL_OW 111
// wait ( 0 0$7 ) ;
2219: LD_INT 245
2221: PPUSH
2222: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2226: LD_EXP 14
2230: PUSH
2231: LD_EXP 15
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2244: LD_EXP 15
2248: PPUSH
2249: LD_STRING D2-Bur-1
2251: PPUSH
2252: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2256: LD_EXP 14
2260: PPUSH
2261: LD_STRING D2-JMM-1
2263: PPUSH
2264: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2268: LD_INT 18
2270: PPUSH
2271: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2275: LD_EXP 15
2279: PPUSH
2280: LD_EXP 14
2284: PPUSH
2285: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2289: LD_EXP 15
2293: PPUSH
2294: LD_STRING D2-Bur-2
2296: PPUSH
2297: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2301: LD_EXP 15
2305: PPUSH
2306: LD_INT 21
2308: PUSH
2309: LD_INT 2
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: PPUSH
2321: LD_EXP 15
2325: PPUSH
2326: CALL_OW 74
2330: PPUSH
2331: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_INT 21
2342: PUSH
2343: LD_INT 2
2345: PUSH
2346: EMPTY
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL_OW 69
2354: PPUSH
2355: LD_EXP 14
2359: PPUSH
2360: CALL_OW 74
2364: PPUSH
2365: CALL_OW 120
// wait ( 0 0$1 ) ;
2369: LD_INT 35
2371: PPUSH
2372: CALL_OW 67
// InGameOff ;
2376: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2380: LD_STRING MArtPickup
2382: PPUSH
2383: CALL_OW 337
// end ;
2387: LD_VAR 0 1
2391: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2392: LD_EXP 22
2396: PPUSH
2397: LD_INT 101
2399: PUSH
2400: LD_INT 7
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 72
2411: IFFALSE 2440
2413: GO 2415
2415: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2416: LD_EXP 15
2420: PPUSH
2421: LD_STRING D3-Bur-1
2423: PPUSH
2424: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2428: LD_EXP 14
2432: PPUSH
2433: LD_STRING D3-JMM-1
2435: PPUSH
2436: CALL_OW 88
// end ;
2440: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2441: LD_INT 5
2443: PPUSH
2444: LD_INT 22
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 70
2458: IFFALSE 2789
2460: GO 2462
2462: DISABLE
// begin wait ( 0 0$3 ) ;
2463: LD_INT 105
2465: PPUSH
2466: CALL_OW 67
// DialogueOn ;
2470: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2474: LD_EXP 14
2478: PPUSH
2479: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2483: LD_EXP 14
2487: PPUSH
2488: LD_STRING D3a-JMM-1
2490: PPUSH
2491: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2495: LD_EXP 15
2499: PPUSH
2500: LD_STRING D3a-Bur-1
2502: PPUSH
2503: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2507: LD_EXP 14
2511: PPUSH
2512: LD_STRING D3a-JMM-2
2514: PPUSH
2515: CALL_OW 88
// if Joan then
2519: LD_EXP 16
2523: IFFALSE 2539
// SayRadio ( Joan , D3a-Joan-2 ) else
2525: LD_EXP 16
2529: PPUSH
2530: LD_STRING D3a-Joan-2
2532: PPUSH
2533: CALL_OW 94
2537: GO 2551
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2539: LD_EXP 17
2543: PPUSH
2544: LD_STRING D3a-RSci1-2
2546: PPUSH
2547: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2551: LD_EXP 18
2555: PPUSH
2556: LD_STRING D3a-Huck-2
2558: PPUSH
2559: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2563: LD_EXP 19
2567: PPUSH
2568: LD_STRING D3a-Pow-2
2570: PPUSH
2571: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2575: LD_EXP 18
2579: PPUSH
2580: LD_STRING D3a-Huck-3
2582: PPUSH
2583: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2587: LD_EXP 19
2591: PPUSH
2592: LD_STRING D3a-Pow-3
2594: PPUSH
2595: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2599: LD_EXP 18
2603: PPUSH
2604: LD_STRING D3a-Huck-4
2606: PPUSH
2607: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2611: LD_EXP 14
2615: PPUSH
2616: LD_STRING D3a-JMM-4
2618: PPUSH
2619: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2623: LD_EXP 15
2627: PPUSH
2628: LD_STRING D3a-Bur-4
2630: PPUSH
2631: CALL_OW 88
// if Joan then
2635: LD_EXP 16
2639: IFFALSE 2655
// SayRadio ( Joan , D3a-Joan-4 ) else
2641: LD_EXP 16
2645: PPUSH
2646: LD_STRING D3a-Joan-4
2648: PPUSH
2649: CALL_OW 94
2653: GO 2667
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2655: LD_EXP 17
2659: PPUSH
2660: LD_STRING D3a-RSci1-4
2662: PPUSH
2663: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2667: LD_INT 133
2669: PPUSH
2670: LD_INT 43
2672: PPUSH
2673: LD_INT 7
2675: PPUSH
2676: LD_INT 10
2678: NEG
2679: PPUSH
2680: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2684: LD_INT 133
2686: PPUSH
2687: LD_INT 43
2689: PPUSH
2690: LD_INT 7
2692: PPUSH
2693: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2697: LD_INT 133
2699: PPUSH
2700: LD_INT 43
2702: PPUSH
2703: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2707: LD_INT 10
2709: PPUSH
2710: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2714: LD_EXP 14
2718: PPUSH
2719: LD_STRING D3a-JMM-5
2721: PPUSH
2722: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2726: LD_EXP 15
2730: PPUSH
2731: LD_STRING D3a-Bur-5
2733: PPUSH
2734: CALL_OW 88
// DialogueOff ;
2738: CALL_OW 7
// seenBase := true ;
2742: LD_ADDR_EXP 8
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2750: LD_INT 525
2752: PUSH
2753: LD_INT 420
2755: PUSH
2756: LD_INT 315
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2774: LD_EXP 21
2778: PPUSH
2779: LD_INT 142
2781: PPUSH
2782: LD_INT 52
2784: PPUSH
2785: CALL_OW 116
// end ;
2789: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2790: LD_EXP 8
2794: NOT
2795: PUSH
2796: LD_EXP 4
2800: NOT
2801: AND
2802: IFFALSE 2822
2804: GO 2806
2806: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2807: LD_EXP 21
2811: PPUSH
2812: LD_INT 142
2814: PPUSH
2815: LD_INT 52
2817: PPUSH
2818: CALL_OW 116
2822: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2823: LD_INT 0
2825: PPUSH
2826: PPUSH
// contaminateTime := tick ;
2827: LD_ADDR_EXP 3
2831: PUSH
2832: LD_OWVAR 1
2836: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2837: LD_INT 175
2839: PPUSH
2840: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_INT 4
2851: PPUSH
2852: CALL_OW 469
2856: ST_TO_ADDR
// if art then
2857: LD_VAR 0 5
2861: IFFALSE 2900
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2863: LD_VAR 0 5
2867: PUSH
2868: LD_INT 1
2870: ARRAY
2871: PUSH
2872: LD_INT 157
2874: EQUAL
2875: PUSH
2876: LD_VAR 0 5
2880: PUSH
2881: LD_INT 2
2883: ARRAY
2884: PUSH
2885: LD_INT 75
2887: EQUAL
2888: AND
2889: IFFALSE 2900
// begin YouLost ( Artefact ) ;
2891: LD_STRING Artefact
2893: PPUSH
2894: CALL_OW 104
// exit ;
2898: GO 3052
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2900: LD_EXP 14
2904: PPUSH
2905: CALL_OW 302
2909: PUSH
2910: LD_EXP 15
2914: PPUSH
2915: CALL_OW 302
2919: AND
2920: IFFALSE 2997
// begin DialogueOn ;
2922: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2926: LD_EXP 14
2930: PPUSH
2931: LD_STRING D6a-JMM-1
2933: PPUSH
2934: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2938: LD_EXP 15
2942: PPUSH
2943: LD_STRING D6a-Bur-1
2945: PPUSH
2946: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2950: LD_EXP 14
2954: PPUSH
2955: LD_STRING D6c-JMM-1
2957: PPUSH
2958: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2962: LD_EXP 15
2966: PPUSH
2967: LD_STRING D6c-Bur-1
2969: PPUSH
2970: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2974: LD_EXP 14
2978: PPUSH
2979: LD_STRING D6c-JMM-2
2981: PPUSH
2982: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2986: LD_STRING MBase
2988: PPUSH
2989: CALL_OW 337
// DialogueOff ;
2993: CALL_OW 7
// end ; bombExploded := true ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: LD_INT 1
3004: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3005: LD_INT 6300
3007: PUSH
3008: LD_INT 5250
3010: PUSH
3011: LD_INT 4200
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PPUSH
3025: CALL_OW 67
// if IsOk ( JMM ) then
3029: LD_EXP 14
3033: PPUSH
3034: CALL_OW 302
3038: IFFALSE 3052
// Say ( JMM , D8-JMM-1 ) ;
3040: LD_EXP 14
3044: PPUSH
3045: LD_STRING D8-JMM-1
3047: PPUSH
3048: CALL_OW 88
// end ;
3052: LD_VAR 0 4
3056: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3057: LD_EXP 9
3061: PUSH
3062: LD_EXP 7
3066: NOT
3067: AND
3068: PUSH
3069: LD_EXP 4
3073: AND
3074: IFFALSE 3129
3076: GO 3078
3078: DISABLE
// begin enable ;
3079: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3080: LD_INT 9
3082: PPUSH
3083: LD_INT 22
3085: PUSH
3086: LD_INT 7
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 70
3097: IFFALSE 3115
// stevensTimer := stevensTimer - 0 0$30 else
3099: LD_ADDR_EXP 9
3103: PUSH
3104: LD_EXP 9
3108: PUSH
3109: LD_INT 1050
3111: MINUS
3112: ST_TO_ADDR
3113: GO 3129
// stevensTimer := stevensTimer - 0 0$1 ;
3115: LD_ADDR_EXP 9
3119: PUSH
3120: LD_EXP 9
3124: PUSH
3125: LD_INT 35
3127: MINUS
3128: ST_TO_ADDR
// end ;
3129: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3130: LD_EXP 9
3134: PUSH
3135: LD_INT 0
3137: LESSEQUAL
3138: PUSH
3139: LD_EXP 7
3143: NOT
3144: AND
3145: IFFALSE 3309
3147: GO 3149
3149: DISABLE
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: ST_TO_ADDR
// for i in tmp do
3188: LD_ADDR_VAR 0 1
3192: PUSH
3193: LD_VAR 0 2
3197: PUSH
3198: FOR_IN
3199: IFFALSE 3252
// begin if IsInUnit ( i ) then
3201: LD_VAR 0 1
3205: PPUSH
3206: CALL_OW 310
3210: IFFALSE 3223
// ComExitBuilding ( i ) else
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 122
3221: GO 3250
// if not HasTask ( i ) then
3223: LD_VAR 0 1
3227: PPUSH
3228: CALL_OW 314
3232: NOT
3233: IFFALSE 3250
// ComMoveXY ( i , 29 , 56 ) ;
3235: LD_VAR 0 1
3239: PPUSH
3240: LD_INT 29
3242: PPUSH
3243: LD_INT 56
3245: PPUSH
3246: CALL_OW 111
// end ;
3250: GO 3198
3252: POP
3253: POP
// repeat wait ( 0 0$1 ) ;
3254: LD_INT 35
3256: PPUSH
3257: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3261: LD_INT 8
3263: PPUSH
3264: LD_INT 22
3266: PUSH
3267: LD_INT 1
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 25
3276: PUSH
3277: LD_INT 4
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL_OW 70
3292: IFFALSE 3254
// if planCaptured then
3294: LD_EXP 7
3298: IFFALSE 3302
// exit ;
3300: GO 3309
// YouLost ( Time ) ;
3302: LD_STRING Time
3304: PPUSH
3305: CALL_OW 104
// end ;
3309: PPOPN 2
3311: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3312: LD_INT 22
3314: PUSH
3315: LD_INT 7
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: LD_INT 92
3324: PUSH
3325: LD_INT 142
3327: PUSH
3328: LD_INT 52
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 69
3348: PUSH
3349: LD_EXP 3
3353: PUSH
3354: LD_INT 6000
3356: PLUS
3357: PUSH
3358: LD_OWVAR 1
3362: GREATER
3363: AND
3364: PUSH
3365: LD_EXP 4
3369: AND
3370: IFFALSE 3425
3372: GO 3374
3374: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3375: LD_EXP 14
3379: PUSH
3380: LD_EXP 15
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 85
// DialogueOn ;
3393: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3397: LD_EXP 14
3401: PPUSH
3402: LD_STRING D6b-JMM-1
3404: PPUSH
3405: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3409: LD_EXP 15
3413: PPUSH
3414: LD_STRING D6b-Bur-1
3416: PPUSH
3417: CALL_OW 88
// DialogueOff ;
3421: CALL_OW 7
// end ;
3425: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3426: LD_EXP 15
3430: PPUSH
3431: LD_INT 142
3433: PPUSH
3434: LD_INT 52
3436: PPUSH
3437: CALL_OW 297
3441: PUSH
3442: LD_INT 25
3444: LESS
3445: PUSH
3446: LD_EXP 15
3450: PPUSH
3451: CALL_OW 310
3455: PPUSH
3456: LD_INT 142
3458: PPUSH
3459: LD_INT 52
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 25
3469: LESS
3470: OR
3471: PUSH
3472: LD_EXP 15
3476: PPUSH
3477: CALL_OW 256
3481: PUSH
3482: LD_INT 1000
3484: LESS
3485: AND
3486: PUSH
3487: LD_EXP 3
3491: PUSH
3492: LD_INT 6000
3494: PLUS
3495: PUSH
3496: LD_OWVAR 1
3500: GREATER
3501: AND
3502: PUSH
3503: LD_EXP 4
3507: AND
3508: IFFALSE 3541
3510: GO 3512
3512: DISABLE
// begin DialogueOn ;
3513: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3517: LD_EXP 15
3521: PPUSH
3522: LD_STRING D7-Bur-1
3524: PPUSH
3525: CALL_OW 88
// enteredContaminatedArea := true ;
3529: LD_ADDR_EXP 5
3533: PUSH
3534: LD_INT 1
3536: ST_TO_ADDR
// DialogueOff ;
3537: CALL_OW 7
// end ;
3541: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3542: LD_EXP 14
3546: PPUSH
3547: LD_INT 142
3549: PPUSH
3550: LD_INT 52
3552: PPUSH
3553: CALL_OW 297
3557: PUSH
3558: LD_INT 25
3560: LESS
3561: PUSH
3562: LD_EXP 14
3566: PPUSH
3567: CALL_OW 310
3571: PPUSH
3572: LD_INT 142
3574: PPUSH
3575: LD_INT 52
3577: PPUSH
3578: CALL_OW 297
3582: PUSH
3583: LD_INT 25
3585: LESS
3586: OR
3587: PUSH
3588: LD_EXP 14
3592: PPUSH
3593: CALL_OW 256
3597: PUSH
3598: LD_INT 1000
3600: LESS
3601: AND
3602: PUSH
3603: LD_EXP 3
3607: PUSH
3608: LD_INT 6000
3610: PLUS
3611: PUSH
3612: LD_OWVAR 1
3616: GREATER
3617: AND
3618: PUSH
3619: LD_EXP 4
3623: AND
3624: IFFALSE 3657
3626: GO 3628
3628: DISABLE
// begin DialogueOn ;
3629: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3633: LD_EXP 14
3637: PPUSH
3638: LD_STRING D7-JMM-1
3640: PPUSH
3641: CALL_OW 88
// enteredContaminatedArea := true ;
3645: LD_ADDR_EXP 5
3649: PUSH
3650: LD_INT 1
3652: ST_TO_ADDR
// DialogueOff ;
3653: CALL_OW 7
// end ;
3657: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3658: LD_EXP 6
3662: PUSH
3663: LD_EXP 14
3667: PPUSH
3668: CALL_OW 302
3672: AND
3673: PUSH
3674: LD_EXP 15
3678: PPUSH
3679: CALL_OW 302
3683: AND
3684: IFFALSE 3753
3686: GO 3688
3688: DISABLE
// begin DialogueOn ;
3689: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3693: LD_EXP 14
3697: PUSH
3698: LD_EXP 15
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PPUSH
3707: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3711: LD_EXP 14
3715: PPUSH
3716: LD_STRING D4-JMM-1
3718: PPUSH
3719: CALL_OW 88
// if not bombExploded then
3723: LD_EXP 4
3727: NOT
3728: IFFALSE 3742
// Say ( Burlak , D4-Bur-1 ) ;
3730: LD_EXP 15
3734: PPUSH
3735: LD_STRING D4-Bur-1
3737: PPUSH
3738: CALL_OW 88
// DialogueOff ;
3742: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3746: LD_STRING MReturn
3748: PPUSH
3749: CALL_OW 337
// end ;
3753: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3754: LD_EXP 7
3758: NOT
3759: PUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 7
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 91
3772: PUSH
3773: LD_INT 9
3775: PUSH
3776: LD_INT 6
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PPUSH
3788: CALL_OW 69
3792: AND
3793: IFFALSE 3870
3795: GO 3797
3797: DISABLE
// begin DialogueOn ;
3798: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3802: LD_INT 55
3804: PPUSH
3805: LD_INT 11
3807: PPUSH
3808: LD_INT 7
3810: PPUSH
3811: LD_INT 6
3813: NEG
3814: PPUSH
3815: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3819: LD_INT 55
3821: PPUSH
3822: LD_INT 11
3824: PPUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3832: LD_EXP 15
3836: PPUSH
3837: LD_STRING D9-Bur-1
3839: PPUSH
3840: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3844: LD_EXP 14
3848: PPUSH
3849: LD_STRING D9-JMM-1
3851: PPUSH
3852: CALL_OW 88
// DialogueOff ;
3856: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3860: LD_INT 9
3862: PPUSH
3863: LD_INT 7
3865: PPUSH
3866: CALL_OW 235
// end ;
3870: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3871: LD_INT 9
3873: PPUSH
3874: LD_INT 22
3876: PUSH
3877: LD_INT 7
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 70
3888: IFFALSE 3924
3890: GO 3892
3892: DISABLE
// begin wait ( 0 0$07 ) ;
3893: LD_INT 245
3895: PPUSH
3896: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3900: LD_EXP 14
3904: PPUSH
3905: LD_STRING D10b-JMM-1
3907: PPUSH
3908: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3912: LD_EXP 15
3916: PPUSH
3917: LD_STRING D10b-Bur-1
3919: PPUSH
3920: CALL_OW 88
// end ;
3924: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3925: LD_EXP 9
3929: PUSH
3930: LD_INT 22
3932: PUSH
3933: LD_INT 1
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 4
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 26
3952: PUSH
3953: LD_INT 1
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: LIST
3964: PPUSH
3965: CALL_OW 69
3969: AND
3970: PUSH
3971: LD_INT 5
3973: PPUSH
3974: CALL_OW 255
3978: PUSH
3979: LD_INT 7
3981: EQUAL
3982: PUSH
3983: LD_INT 22
3985: PUSH
3986: LD_INT 1
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 25
3995: PUSH
3996: LD_INT 1
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: CALL_OW 69
4011: PUSH
4012: LD_INT 0
4014: EQUAL
4015: OR
4016: AND
4017: IFFALSE 4606
4019: GO 4021
4021: DISABLE
4022: LD_INT 0
4024: PPUSH
// begin case Query ( QKill ) of 1 :
4025: LD_STRING QKill
4027: PPUSH
4028: CALL_OW 97
4032: PUSH
4033: LD_INT 1
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4041
4039: GO 4594
4041: POP
// begin DialogueOn ;
4042: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4046: LD_EXP 14
4050: PPUSH
4051: LD_STRING D10a-JMM-1
4053: PPUSH
4054: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4058: LD_EXP 15
4062: PPUSH
4063: LD_STRING D10a-Bur-1
4065: PPUSH
4066: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4070: LD_EXP 14
4074: PPUSH
4075: LD_STRING D10a-JMM-2
4077: PPUSH
4078: CALL_OW 88
// if IsOk ( Stevens ) then
4082: LD_EXP 18
4086: PPUSH
4087: CALL_OW 302
4091: IFFALSE 4107
// Say ( Stevens , D10a-Huck-2 ) else
4093: LD_EXP 18
4097: PPUSH
4098: LD_STRING D10a-Huck-2
4100: PPUSH
4101: CALL_OW 88
4105: GO 4158
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4107: LD_INT 22
4109: PUSH
4110: LD_INT 1
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: LD_INT 25
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: LD_INT 26
4129: PUSH
4130: LD_INT 1
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: PPUSH
4151: LD_STRING D10a-ASci1-3
4153: PPUSH
4154: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4158: LD_EXP 14
4162: PPUSH
4163: LD_STRING D10a-JMM-4
4165: PPUSH
4166: CALL_OW 88
// if IsOk ( Stevens ) then
4170: LD_EXP 18
4174: PPUSH
4175: CALL_OW 302
4179: IFFALSE 4193
// Say ( Stevens , D10a-Huck-3 ) ;
4181: LD_EXP 18
4185: PPUSH
4186: LD_STRING D10a-Huck-3
4188: PPUSH
4189: CALL_OW 88
// DialogueOff ;
4193: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4197: LD_INT 1
4199: PPUSH
4200: LD_INT 7
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: CALL_OW 80
// planCaptured := true ;
4213: LD_ADDR_EXP 7
4217: PUSH
4218: LD_INT 1
4220: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4221: LD_STRING MEnd
4223: PPUSH
4224: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4228: LD_STRING ACH_DIPLOMACY
4230: PPUSH
4231: CALL_OW 543
// canEnd := true ;
4235: LD_ADDR_EXP 10
4239: PUSH
4240: LD_INT 1
4242: ST_TO_ADDR
// missionTime := tick ;
4243: LD_ADDR_EXP 11
4247: PUSH
4248: LD_OWVAR 1
4252: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4260: LD_INT 22
4262: PUSH
4263: LD_INT 1
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 3
4272: PUSH
4273: LD_INT 50
4275: PUSH
4276: EMPTY
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: IFFALSE 4407
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_INT 22
4300: PUSH
4301: LD_INT 1
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: LD_INT 25
4310: PUSH
4311: LD_INT 4
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PPUSH
4322: CALL_OW 69
4326: PUSH
4327: FOR_IN
4328: IFFALSE 4405
// begin if IsInUnit ( i ) then
4330: LD_VAR 0 1
4334: PPUSH
4335: CALL_OW 310
4339: IFFALSE 4352
// ComExitBuilding ( i ) else
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 122
4350: GO 4403
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: LD_INT 22
4359: PUSH
4360: LD_INT 1
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 3
4369: PUSH
4370: LD_INT 50
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PPUSH
4384: CALL_OW 69
4388: PPUSH
4389: LD_VAR 0 1
4393: PPUSH
4394: CALL_OW 74
4398: PPUSH
4399: CALL_OW 128
// end ;
4403: GO 4327
4405: POP
4406: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4407: LD_INT 22
4409: PUSH
4410: LD_INT 1
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 3
4419: PUSH
4420: LD_INT 50
4422: PUSH
4423: EMPTY
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: EMPTY
4431: LIST
4432: LIST
4433: PPUSH
4434: CALL_OW 69
4438: NOT
4439: IFFALSE 4253
// repeat wait ( 3 ) ;
4441: LD_INT 3
4443: PPUSH
4444: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4448: LD_ADDR_VAR 0 1
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_INT 1
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 21
4465: PUSH
4466: LD_INT 1
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PPUSH
4477: CALL_OW 69
4481: PUSH
4482: FOR_IN
4483: IFFALSE 4559
// begin if IsInArea ( i , stevensEscapeArea ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: LD_INT 8
4492: PPUSH
4493: CALL_OW 308
4497: IFFALSE 4510
// begin RemoveUnit ( i ) ;
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 64
// continue ;
4508: GO 4482
// end ; if IsInUnit ( i ) then
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 310
4519: IFFALSE 4530
// ComExitBuilding ( i ) ;
4521: LD_VAR 0 1
4525: PPUSH
4526: CALL_OW 122
// if not HasTask ( i ) then
4530: LD_VAR 0 1
4534: PPUSH
4535: CALL_OW 314
4539: NOT
4540: IFFALSE 4557
// ComMoveXY ( i , 28 , 55 ) ;
4542: LD_VAR 0 1
4546: PPUSH
4547: LD_INT 28
4549: PPUSH
4550: LD_INT 55
4552: PPUSH
4553: CALL_OW 111
// end ;
4557: GO 4482
4559: POP
4560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4561: LD_INT 22
4563: PUSH
4564: LD_INT 1
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 69
4589: NOT
4590: IFFALSE 4441
// end ; 2 :
4592: GO 4606
4594: LD_INT 2
4596: DOUBLE
4597: EQUAL
4598: IFTRUE 4602
4600: GO 4605
4602: POP
// ; end ;
4603: GO 4606
4605: POP
// end ;
4606: PPOPN 1
4608: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4609: LD_EXP 10
4613: IFFALSE 4970
4615: GO 4617
4617: DISABLE
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
4622: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4623: LD_INT 10
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: CALL_OW 424
// if Difficulty < 2 then
4633: LD_OWVAR 67
4637: PUSH
4638: LD_INT 2
4640: LESS
4641: IFFALSE 4645
// exit ;
4643: GO 4970
// uc_side := 4 ;
4645: LD_ADDR_OWVAR 20
4649: PUSH
4650: LD_INT 4
4652: ST_TO_ADDR
// uc_nation := 1 ;
4653: LD_ADDR_OWVAR 21
4657: PUSH
4658: LD_INT 1
4660: ST_TO_ADDR
// InitHc ;
4661: CALL_OW 19
// tmp := [ ] ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: EMPTY
4671: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4672: LD_INT 0
4674: PPUSH
4675: LD_INT 5
4677: PPUSH
4678: LD_INT 10
4680: PPUSH
4681: CALL_OW 380
// un := CreateHuman ;
4685: LD_ADDR_VAR 0 1
4689: PUSH
4690: CALL_OW 44
4694: ST_TO_ADDR
// tmp := [ un ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_VAR 0 1
4704: PUSH
4705: EMPTY
4706: LIST
4707: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4708: LD_VAR 0 1
4712: PPUSH
4713: LD_INT 226
4715: PPUSH
4716: LD_INT 86
4718: PPUSH
4719: LD_INT 0
4721: PPUSH
4722: CALL_OW 48
// ComHold ( un ) ;
4726: LD_VAR 0 1
4730: PPUSH
4731: CALL_OW 140
// for i = 1 to 3 do
4735: LD_ADDR_VAR 0 2
4739: PUSH
4740: DOUBLE
4741: LD_INT 1
4743: DEC
4744: ST_TO_ADDR
4745: LD_INT 3
4747: PUSH
4748: FOR_TO
4749: IFFALSE 4848
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4751: LD_INT 0
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: LD_INT 8
4759: PPUSH
4760: CALL_OW 380
// un := CreateHuman ;
4764: LD_ADDR_VAR 0 1
4768: PUSH
4769: CALL_OW 44
4773: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4774: LD_VAR 0 1
4778: PPUSH
4779: LD_INT 5
4781: PPUSH
4782: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4786: LD_VAR 0 1
4790: PPUSH
4791: LD_INT 215
4793: PUSH
4794: LD_INT 217
4796: PUSH
4797: LD_INT 219
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: LIST
4804: PUSH
4805: LD_VAR 0 2
4809: ARRAY
4810: PPUSH
4811: LD_INT 76
4813: PPUSH
4814: LD_INT 0
4816: PPUSH
4817: CALL_OW 48
// ComCrawl ( un ) ;
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 137
// tmp := tmp ^ un ;
4830: LD_ADDR_VAR 0 3
4834: PUSH
4835: LD_VAR 0 3
4839: PUSH
4840: LD_VAR 0 1
4844: ADD
4845: ST_TO_ADDR
// end ;
4846: GO 4748
4848: POP
4849: POP
// repeat wait ( 0 0$1 ) ;
4850: LD_INT 35
4852: PPUSH
4853: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4857: LD_VAR 0 1
4861: PPUSH
4862: LD_INT 24
4864: PUSH
4865: LD_INT 1000
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PPUSH
4872: CALL_OW 72
4876: NOT
4877: IFFALSE 4850
// for i in tmp do
4879: LD_ADDR_VAR 0 2
4883: PUSH
4884: LD_VAR 0 3
4888: PUSH
4889: FOR_IN
4890: IFFALSE 4968
// begin wait ( 0 0$1 ) ;
4892: LD_INT 35
4894: PPUSH
4895: CALL_OW 67
// if Crawls ( i ) then
4899: LD_VAR 0 2
4903: PPUSH
4904: CALL_OW 318
4908: IFFALSE 4921
// ComWalk ( i ) else
4910: LD_VAR 0 2
4914: PPUSH
4915: CALL_OW 138
4919: GO 4966
// if GetClass ( i ) = class_sniper then
4921: LD_VAR 0 2
4925: PPUSH
4926: CALL_OW 257
4930: PUSH
4931: LD_INT 5
4933: EQUAL
4934: IFFALSE 4952
// ComAttackSoporific ( i , JMM ) else
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_EXP 14
4945: PPUSH
4946: CALL_OW 166
4950: GO 4966
// ComAttackUnit ( i , JMM ) ;
4952: LD_VAR 0 2
4956: PPUSH
4957: LD_EXP 14
4961: PPUSH
4962: CALL_OW 115
// end ;
4966: GO 4889
4968: POP
4969: POP
// end ;
4970: PPOPN 3
4972: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4973: LD_EXP 7
4977: NOT
4978: PUSH
4979: LD_INT 1
4981: PPUSH
4982: CALL_OW 301
4986: AND
4987: IFFALSE 4999
4989: GO 4991
4991: DISABLE
// YouLost ( Lab ) ;
4992: LD_STRING Lab
4994: PPUSH
4995: CALL_OW 104
4999: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5000: LD_INT 10
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 7
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 70
5017: PUSH
5018: LD_INT 2
5020: GREATEREQUAL
5021: PUSH
5022: LD_INT 10
5024: PPUSH
5025: LD_INT 2
5027: PUSH
5028: LD_INT 34
5030: PUSH
5031: LD_INT 12
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 34
5040: PUSH
5041: LD_INT 51
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 70
5057: AND
5058: PUSH
5059: LD_EXP 10
5063: AND
5064: PUSH
5065: LD_EXP 7
5069: AND
5070: PUSH
5071: LD_EXP 6
5075: AND
5076: IFFALSE 5332
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
// begin m1 := false ;
5085: LD_ADDR_VAR 0 1
5089: PUSH
5090: LD_INT 0
5092: ST_TO_ADDR
// m2 := false ;
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: LD_INT 0
5100: ST_TO_ADDR
// if killCounter = 0 then
5101: LD_EXP 12
5105: PUSH
5106: LD_INT 0
5108: EQUAL
5109: IFFALSE 5118
// SetAchievement ( ACH_PACIFIST ) ;
5111: LD_STRING ACH_PACIFIST
5113: PPUSH
5114: CALL_OW 543
// if tick < 7 7$00 then
5118: LD_OWVAR 1
5122: PUSH
5123: LD_INT 14700
5125: LESS
5126: IFFALSE 5142
// begin wait ( 3 ) ;
5128: LD_INT 3
5130: PPUSH
5131: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5135: LD_STRING ACH_ASPEED_18
5137: PPUSH
5138: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5142: LD_STRING Explosion
5144: PPUSH
5145: LD_INT 1
5147: PPUSH
5148: CALL_OW 101
// if enteredContaminatedArea then
5152: LD_EXP 5
5156: IFFALSE 5178
// begin m1 := true ;
5158: LD_ADDR_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5166: LD_STRING BioHazard
5168: PPUSH
5169: LD_INT 1
5171: PPUSH
5172: CALL_OW 101
// end else
5176: GO 5189
// AddMedal ( BioHazard , - 1 ) ;
5178: LD_STRING BioHazard
5180: PPUSH
5181: LD_INT 1
5183: NEG
5184: PPUSH
5185: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5189: LD_EXP 11
5193: PUSH
5194: LD_INT 42000
5196: PUSH
5197: LD_INT 31500
5199: PUSH
5200: LD_INT 25200
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_OWVAR 67
5212: ARRAY
5213: LESSEQUAL
5214: IFFALSE 5236
// begin m2 := true ;
5216: LD_ADDR_VAR 0 2
5220: PUSH
5221: LD_INT 1
5223: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5224: LD_STRING Speed
5226: PPUSH
5227: LD_INT 1
5229: PPUSH
5230: CALL_OW 101
// end else
5234: GO 5247
// AddMedal ( Speed , - 1 ) ;
5236: LD_STRING Speed
5238: PPUSH
5239: LD_INT 1
5241: NEG
5242: PPUSH
5243: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5247: LD_OWVAR 67
5251: PUSH
5252: LD_INT 3
5254: EQUAL
5255: PUSH
5256: LD_VAR 0 1
5260: AND
5261: PUSH
5262: LD_VAR 0 2
5266: AND
5267: IFFALSE 5279
// SetAchievementEX ( ACH_AMER , 18 ) ;
5269: LD_STRING ACH_AMER
5271: PPUSH
5272: LD_INT 18
5274: PPUSH
5275: CALL_OW 564
// GiveMedals ( Main ) ;
5279: LD_STRING Main
5281: PPUSH
5282: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5286: LD_EXP 14
5290: PUSH
5291: LD_EXP 15
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5304: LD_EXP 14
5308: PPUSH
5309: LD_STRING 14a_JMM
5311: PPUSH
5312: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5316: LD_EXP 15
5320: PPUSH
5321: LD_STRING 14a_Burlak
5323: PPUSH
5324: CALL_OW 38
// YouWin ;
5328: CALL_OW 103
// end ; end_of_file
5332: PPOPN 2
5334: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5335: LD_INT 0
5337: PPUSH
5338: PPUSH
5339: PPUSH
5340: PPUSH
// uc_side := 1 ;
5341: LD_ADDR_OWVAR 20
5345: PUSH
5346: LD_INT 1
5348: ST_TO_ADDR
// uc_nation := 1 ;
5349: LD_ADDR_OWVAR 21
5353: PUSH
5354: LD_INT 1
5356: ST_TO_ADDR
// InitHc ;
5357: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5361: LD_INT 34
5363: PPUSH
5364: CALL_OW 274
5368: PPUSH
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 500
5374: PPUSH
5375: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5379: LD_INT 34
5381: PPUSH
5382: CALL_OW 274
5386: PPUSH
5387: LD_INT 3
5389: PPUSH
5390: LD_INT 20
5392: PPUSH
5393: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5397: LD_ADDR_EXP 18
5401: PUSH
5402: LD_STRING Stevens
5404: PPUSH
5405: CALL_OW 25
5409: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5410: LD_ADDR_EXP 19
5414: PUSH
5415: LD_STRING Powell
5417: PPUSH
5418: CALL_OW 25
5422: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5423: LD_EXP 18
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: CALL_OW 52
// vehGuard := [ ] ;
5435: LD_ADDR_EXP 23
5439: PUSH
5440: EMPTY
5441: ST_TO_ADDR
// hc_importance := 0 ;
5442: LD_ADDR_OWVAR 32
5446: PUSH
5447: LD_INT 0
5449: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 3
5455: PPUSH
5456: LD_INT 3
5458: PPUSH
5459: LD_INT 8
5461: PPUSH
5462: LD_INT 100
5464: PPUSH
5465: CALL 971 0 5
// sibBomb := CreateVehicle ;
5469: LD_ADDR_EXP 21
5473: PUSH
5474: CALL_OW 45
5478: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5479: LD_EXP 21
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5491: LD_EXP 21
5495: PPUSH
5496: LD_INT 93
5498: PPUSH
5499: LD_INT 74
5501: PPUSH
5502: LD_INT 0
5504: PPUSH
5505: CALL_OW 48
// guards := [ ] ;
5509: LD_ADDR_EXP 22
5513: PUSH
5514: EMPTY
5515: ST_TO_ADDR
// for i = 1 to 3 do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_INT 3
5528: PUSH
5529: FOR_TO
5530: IFFALSE 5622
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5532: LD_INT 0
5534: PPUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_INT 8
5540: PUSH
5541: LD_INT 9
5543: PUSH
5544: LD_INT 10
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PPUSH
5558: CALL_OW 380
// un := CreateHuman ;
5562: LD_ADDR_VAR 0 3
5566: PUSH
5567: CALL_OW 44
5571: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5572: LD_VAR 0 3
5576: PPUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 4
5585: PUSH
5586: EMPTY
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_VAR 0 2
5595: ARRAY
5596: PPUSH
5597: LD_INT 0
5599: PPUSH
5600: CALL_OW 49
// guards := guards ^ un ;
5604: LD_ADDR_EXP 22
5608: PUSH
5609: LD_EXP 22
5613: PUSH
5614: LD_VAR 0 3
5618: ADD
5619: ST_TO_ADDR
// end ;
5620: GO 5529
5622: POP
5623: POP
// baseGuards := [ ] ;
5624: LD_ADDR_EXP 20
5628: PUSH
5629: EMPTY
5630: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5631: LD_ADDR_VAR 0 2
5635: PUSH
5636: DOUBLE
5637: LD_INT 1
5639: DEC
5640: ST_TO_ADDR
5641: LD_INT 5
5643: PUSH
5644: LD_INT 6
5646: PUSH
5647: LD_INT 7
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: PUSH
5655: LD_OWVAR 67
5659: ARRAY
5660: PUSH
5661: FOR_TO
5662: IFFALSE 5808
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5664: LD_INT 0
5666: PPUSH
5667: LD_INT 8
5669: PUSH
5670: LD_INT 9
5672: PUSH
5673: LD_INT 10
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: PUSH
5681: LD_OWVAR 67
5685: ARRAY
5686: PPUSH
5687: CALL_OW 381
// un := CreateHuman ;
5691: LD_ADDR_VAR 0 3
5695: PUSH
5696: CALL_OW 44
5700: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5701: LD_ADDR_EXP 20
5705: PUSH
5706: LD_EXP 20
5710: PUSH
5711: LD_VAR 0 3
5715: ADD
5716: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5717: LD_ADDR_VAR 0 4
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 58
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 30
5740: PUSH
5741: LD_INT 32
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 69
5757: ST_TO_ADDR
// if tmp then
5758: LD_VAR 0 4
5762: IFFALSE 5794
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5764: LD_VAR 0 3
5768: PPUSH
5769: LD_VAR 0 4
5773: PUSH
5774: LD_INT 1
5776: PPUSH
5777: LD_VAR 0 4
5781: PPUSH
5782: CALL_OW 12
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
5792: GO 5806
// PlaceHumanInUnit ( un , us_bar ) ;
5794: LD_VAR 0 3
5798: PPUSH
5799: LD_INT 51
5801: PPUSH
5802: CALL_OW 52
// end ;
5806: GO 5661
5808: POP
5809: POP
// if Difficulty > 1 then
5810: LD_OWVAR 67
5814: PUSH
5815: LD_INT 1
5817: GREATER
5818: IFFALSE 5862
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5820: LD_INT 0
5822: PPUSH
5823: LD_INT 5
5825: PPUSH
5826: LD_INT 9
5828: PUSH
5829: LD_INT 10
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PUSH
5836: LD_OWVAR 67
5840: PUSH
5841: LD_INT 1
5843: MINUS
5844: ARRAY
5845: PPUSH
5846: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5850: CALL_OW 44
5854: PPUSH
5855: LD_INT 80
5857: PPUSH
5858: CALL_OW 52
// end ; for i = 1 to 3 do
5862: LD_ADDR_VAR 0 2
5866: PUSH
5867: DOUBLE
5868: LD_INT 1
5870: DEC
5871: ST_TO_ADDR
5872: LD_INT 3
5874: PUSH
5875: FOR_TO
5876: IFFALSE 5902
// begin PrepareMechanic ( false , 9 ) ;
5878: LD_INT 0
5880: PPUSH
5881: LD_INT 9
5883: PPUSH
5884: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5888: CALL_OW 44
5892: PPUSH
5893: LD_INT 43
5895: PPUSH
5896: CALL_OW 52
// end ;
5900: GO 5875
5902: POP
5903: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_INT 49
5911: PPUSH
5912: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5916: LD_ADDR_VAR 0 2
5920: PUSH
5921: DOUBLE
5922: LD_INT 1
5924: DEC
5925: ST_TO_ADDR
5926: LD_INT 1
5928: PUSH
5929: LD_OWVAR 67
5933: PLUS
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5979
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5938: LD_INT 0
5940: PPUSH
5941: LD_INT 8
5943: PUSH
5944: LD_INT 9
5946: PUSH
5947: LD_INT 10
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: LD_OWVAR 67
5959: ARRAY
5960: PPUSH
5961: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5965: CALL_OW 44
5969: PPUSH
5970: LD_INT 5
5972: PPUSH
5973: CALL_OW 52
// end ;
5977: GO 5935
5979: POP
5980: POP
// for i = 1 to 3 do
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: DOUBLE
5987: LD_INT 1
5989: DEC
5990: ST_TO_ADDR
5991: LD_INT 3
5993: PUSH
5994: FOR_TO
5995: IFFALSE 6021
// begin PrepareScientist ( false , 10 ) ;
5997: LD_INT 0
5999: PPUSH
6000: LD_INT 10
6002: PPUSH
6003: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6007: CALL_OW 44
6011: PPUSH
6012: LD_INT 1
6014: PPUSH
6015: CALL_OW 52
// end ;
6019: GO 5994
6021: POP
6022: POP
// end ;
6023: LD_VAR 0 1
6027: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6028: LD_EXP 22
6032: PUSH
6033: LD_EXP 2
6037: NOT
6038: AND
6039: IFFALSE 6225
6041: GO 6043
6043: DISABLE
6044: LD_INT 0
6046: PPUSH
6047: PPUSH
6048: PPUSH
// begin enable ;
6049: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6050: LD_ADDR_VAR 0 3
6054: PUSH
6055: LD_INT 204
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 165
6067: PUSH
6068: LD_INT 24
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PUSH
6075: LD_INT 195
6077: PUSH
6078: LD_INT 6
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: LD_INT 223
6087: PUSH
6088: LD_INT 54
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 214
6097: PUSH
6098: LD_INT 84
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 206
6107: PUSH
6108: LD_INT 71
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: ST_TO_ADDR
// for i in guards do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: LD_EXP 22
6132: PUSH
6133: FOR_IN
6134: IFFALSE 6223
// begin if HasTask ( i ) then
6136: LD_VAR 0 1
6140: PPUSH
6141: CALL_OW 314
6145: IFFALSE 6151
// continue else
6147: GO 6133
6149: GO 6221
// begin j := rand ( 1 , 6 ) ;
6151: LD_ADDR_VAR 0 2
6155: PUSH
6156: LD_INT 1
6158: PPUSH
6159: LD_INT 6
6161: PPUSH
6162: CALL_OW 12
6166: ST_TO_ADDR
// if not See ( 7 , i ) then
6167: LD_INT 7
6169: PPUSH
6170: LD_VAR 0 1
6174: PPUSH
6175: CALL_OW 292
6179: NOT
6180: IFFALSE 6221
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6182: LD_VAR 0 1
6186: PPUSH
6187: LD_VAR 0 3
6191: PUSH
6192: LD_VAR 0 2
6196: ARRAY
6197: PUSH
6198: LD_INT 1
6200: ARRAY
6201: PPUSH
6202: LD_VAR 0 3
6206: PUSH
6207: LD_VAR 0 2
6211: ARRAY
6212: PUSH
6213: LD_INT 2
6215: ARRAY
6216: PPUSH
6217: CALL_OW 114
// end ; end ;
6221: GO 6133
6223: POP
6224: POP
// end ;
6225: PPOPN 3
6227: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6228: LD_EXP 23
6232: PUSH
6233: LD_EXP 7
6237: NOT
6238: AND
6239: IFFALSE 6310
6241: GO 6243
6243: DISABLE
6244: LD_INT 0
6246: PPUSH
// begin enable ;
6247: ENABLE
// for i in vehGuard do
6248: LD_ADDR_VAR 0 1
6252: PUSH
6253: LD_EXP 23
6257: PUSH
6258: FOR_IN
6259: IFFALSE 6308
// if IsOk ( vehGuard ) then
6261: LD_EXP 23
6265: PPUSH
6266: CALL_OW 302
6270: IFFALSE 6306
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 22
6279: PUSH
6280: LD_INT 7
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 74
6301: PPUSH
6302: CALL_OW 115
6306: GO 6258
6308: POP
6309: POP
// end ;
6310: PPOPN 1
6312: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6313: LD_EXP 4
6317: PUSH
6318: LD_INT 43
6320: PPUSH
6321: CALL_OW 302
6325: AND
6326: PUSH
6327: LD_EXP 7
6331: NOT
6332: AND
6333: IFFALSE 6381
6335: GO 6337
6337: DISABLE
// begin enable ;
6338: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6339: LD_INT 43
6341: PPUSH
6342: LD_INT 5
6344: PPUSH
6345: LD_INT 3
6347: PPUSH
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 7
6353: PUSH
6354: LD_INT 7
6356: PUSH
6357: LD_INT 9
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 3
6370: PPUSH
6371: CALL_OW 12
6375: ARRAY
6376: PPUSH
6377: CALL_OW 125
// end ;
6381: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6382: LD_INT 22
6384: PUSH
6385: LD_INT 1
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 25
6394: PUSH
6395: LD_INT 5
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PUSH
6402: LD_INT 50
6404: PUSH
6405: EMPTY
6406: LIST
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: LD_EXP 7
6422: NOT
6423: AND
6424: IFFALSE 6653
6426: GO 6428
6428: DISABLE
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
// begin enable ;
6433: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6434: LD_ADDR_VAR 0 1
6438: PUSH
6439: LD_INT 22
6441: PUSH
6442: LD_INT 1
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 25
6451: PUSH
6452: LD_INT 5
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 50
6461: PUSH
6462: EMPTY
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PPUSH
6470: CALL_OW 69
6474: ST_TO_ADDR
// if not tmp then
6475: LD_VAR 0 1
6479: NOT
6480: IFFALSE 6484
// exit ;
6482: GO 6653
// b := IsInUnit ( tmp [ 1 ] ) ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_VAR 0 1
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 310
6502: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6503: LD_VAR 0 2
6507: NOT
6508: PUSH
6509: LD_VAR 0 1
6513: PUSH
6514: LD_INT 1
6516: ARRAY
6517: PPUSH
6518: CALL_OW 314
6522: OR
6523: IFFALSE 6527
// exit ;
6525: GO 6653
// if b = us_bun1 then
6527: LD_VAR 0 2
6531: PUSH
6532: LD_INT 80
6534: EQUAL
6535: IFFALSE 6596
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6537: LD_VAR 0 1
6541: PUSH
6542: LD_INT 1
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6550: LD_VAR 0 1
6554: PUSH
6555: LD_INT 1
6557: ARRAY
6558: PPUSH
6559: LD_INT 27
6561: PPUSH
6562: LD_INT 44
6564: PPUSH
6565: CALL_OW 174
// if IsOk ( us_bun2 ) then
6569: LD_INT 55
6571: PPUSH
6572: CALL_OW 302
6576: IFFALSE 6594
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6578: LD_VAR 0 1
6582: PUSH
6583: LD_INT 1
6585: ARRAY
6586: PPUSH
6587: LD_INT 55
6589: PPUSH
6590: CALL_OW 180
// end else
6594: GO 6653
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6609: LD_VAR 0 1
6613: PUSH
6614: LD_INT 1
6616: ARRAY
6617: PPUSH
6618: LD_INT 92
6620: PPUSH
6621: LD_INT 51
6623: PPUSH
6624: CALL_OW 174
// if IsOk ( us_bun1 ) then
6628: LD_INT 80
6630: PPUSH
6631: CALL_OW 302
6635: IFFALSE 6653
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6637: LD_VAR 0 1
6641: PUSH
6642: LD_INT 1
6644: ARRAY
6645: PPUSH
6646: LD_INT 80
6648: PPUSH
6649: CALL_OW 180
// end ; end ;
6653: PPOPN 2
6655: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6656: LD_EXP 7
6660: NOT
6661: PUSH
6662: LD_INT 9
6664: PPUSH
6665: LD_INT 22
6667: PUSH
6668: LD_INT 1
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: LD_INT 21
6677: PUSH
6678: LD_INT 3
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 3
6687: PUSH
6688: LD_INT 24
6690: PUSH
6691: LD_INT 1000
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 70
6711: AND
6712: IFFALSE 7123
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
// begin enable ;
6723: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 22
6731: PUSH
6732: LD_INT 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 25
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: LD_INT 1000
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: PPUSH
6764: CALL_OW 69
6768: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6769: LD_ADDR_VAR 0 3
6773: PUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 25
6786: PUSH
6787: LD_INT 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 24
6799: PUSH
6800: LD_INT 750
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6821: LD_ADDR_VAR 0 4
6825: PUSH
6826: LD_INT 9
6828: PPUSH
6829: LD_INT 22
6831: PUSH
6832: LD_INT 1
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 24
6854: PUSH
6855: LD_INT 1000
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: PPUSH
6871: CALL_OW 70
6875: PUSH
6876: LD_INT 1
6878: DIFF
6879: ST_TO_ADDR
// if not tmp and not tmp2 then
6880: LD_VAR 0 2
6884: NOT
6885: PUSH
6886: LD_VAR 0 3
6890: NOT
6891: AND
6892: IFFALSE 6896
// exit ;
6894: GO 7123
// if tmp and b then
6896: LD_VAR 0 2
6900: PUSH
6901: LD_VAR 0 4
6905: AND
6906: IFFALSE 7036
// for i in tmp do
6908: LD_ADDR_VAR 0 1
6912: PUSH
6913: LD_VAR 0 2
6917: PUSH
6918: FOR_IN
6919: IFFALSE 7034
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6921: LD_VAR 0 1
6925: PPUSH
6926: CALL_OW 110
6930: PUSH
6931: LD_INT 1
6933: EQUAL
6934: PUSH
6935: LD_VAR 0 1
6939: PPUSH
6940: CALL_OW 256
6944: PUSH
6945: LD_INT 1000
6947: LESS
6948: AND
6949: IFFALSE 6955
// continue else
6951: GO 6918
6953: GO 6982
// if GetTag ( i ) = 1 then
6955: LD_VAR 0 1
6959: PPUSH
6960: CALL_OW 110
6964: PUSH
6965: LD_INT 1
6967: EQUAL
6968: IFFALSE 6982
// SetTag ( i , 0 ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_INT 0
6977: PPUSH
6978: CALL_OW 109
// if IsInUnit ( i ) then
6982: LD_VAR 0 1
6986: PPUSH
6987: CALL_OW 310
6991: IFFALSE 7002
// ComExitBuilding ( i ) ;
6993: LD_VAR 0 1
6997: PPUSH
6998: CALL_OW 122
// if not HasTask ( i ) then
7002: LD_VAR 0 1
7006: PPUSH
7007: CALL_OW 314
7011: NOT
7012: IFFALSE 7032
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_VAR 0 4
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: CALL_OW 190
// end ;
7032: GO 6918
7034: POP
7035: POP
// if tmp2 then
7036: LD_VAR 0 3
7040: IFFALSE 7123
// for i in tmp2 do
7042: LD_ADDR_VAR 0 1
7046: PUSH
7047: LD_VAR 0 3
7051: PUSH
7052: FOR_IN
7053: IFFALSE 7121
// begin if not GetTag ( i ) = 1 then
7055: LD_VAR 0 1
7059: PPUSH
7060: CALL_OW 110
7064: PUSH
7065: LD_INT 1
7067: EQUAL
7068: NOT
7069: IFFALSE 7083
// SetTag ( i , 1 ) ;
7071: LD_VAR 0 1
7075: PPUSH
7076: LD_INT 1
7078: PPUSH
7079: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7083: LD_VAR 0 1
7087: PPUSH
7088: LD_INT 88
7090: PPUSH
7091: LD_INT 75
7093: PPUSH
7094: CALL_OW 297
7098: PUSH
7099: LD_INT 6
7101: GREATER
7102: IFFALSE 7119
// ComMoveXY ( i , 88 , 75 ) ;
7104: LD_VAR 0 1
7108: PPUSH
7109: LD_INT 88
7111: PPUSH
7112: LD_INT 75
7114: PPUSH
7115: CALL_OW 111
// end ;
7119: GO 7052
7121: POP
7122: POP
// end ;
7123: PPOPN 4
7125: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7126: LD_EXP 7
7130: NOT
7131: PUSH
7132: LD_EXP 9
7136: AND
7137: PUSH
7138: LD_INT 9
7140: PPUSH
7141: LD_INT 22
7143: PUSH
7144: LD_INT 1
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 21
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 3
7163: PUSH
7164: LD_INT 24
7166: PUSH
7167: LD_INT 1000
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL_OW 70
7187: AND
7188: IFFALSE 7361
7190: GO 7192
7192: DISABLE
7193: LD_INT 0
7195: PPUSH
7196: PPUSH
7197: PPUSH
// begin enable ;
7198: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7199: LD_ADDR_VAR 0 2
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_INT 1
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 25
7216: PUSH
7217: LD_INT 4
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: PPUSH
7228: CALL_OW 69
7232: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_INT 9
7240: PPUSH
7241: LD_INT 22
7243: PUSH
7244: LD_INT 1
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: LD_INT 21
7253: PUSH
7254: LD_INT 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 3
7263: PUSH
7264: LD_INT 24
7266: PUSH
7267: LD_INT 1000
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: PPUSH
7283: CALL_OW 70
7287: ST_TO_ADDR
// if not sci or not tmp then
7288: LD_VAR 0 2
7292: NOT
7293: PUSH
7294: LD_VAR 0 3
7298: NOT
7299: OR
7300: IFFALSE 7304
// exit ;
7302: GO 7361
// for i in sci do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: LD_VAR 0 2
7313: PUSH
7314: FOR_IN
7315: IFFALSE 7359
// if IsInUnit ( i ) then
7317: LD_VAR 0 1
7321: PPUSH
7322: CALL_OW 310
7326: IFFALSE 7339
// ComExitBuilding ( i ) else
7328: LD_VAR 0 1
7332: PPUSH
7333: CALL_OW 122
7337: GO 7357
// ComHeal ( i , tmp [ 1 ] ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 1
7351: ARRAY
7352: PPUSH
7353: CALL_OW 128
7357: GO 7314
7359: POP
7360: POP
// end ;
7361: PPOPN 3
7363: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7364: LD_EXP 7
7368: NOT
7369: PUSH
7370: LD_EXP 9
7374: AND
7375: PUSH
7376: LD_INT 1
7378: PPUSH
7379: CALL_OW 302
7383: AND
7384: PUSH
7385: LD_INT 9
7387: PPUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 21
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: LD_INT 24
7413: PUSH
7414: LD_INT 1000
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 70
7434: NOT
7435: AND
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 25
7449: PUSH
7450: LD_INT 4
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 56
7459: PUSH
7460: EMPTY
7461: LIST
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: AND
7473: IFFALSE 7566
7475: GO 7477
7477: DISABLE
7478: LD_INT 0
7480: PPUSH
// begin enable ;
7481: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_INT 1
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 4
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 56
7509: PUSH
7510: EMPTY
7511: LIST
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: PPUSH
7518: CALL_OW 69
7522: PUSH
7523: FOR_IN
7524: IFFALSE 7564
// if not GetTag ( i ) and not HasTask ( i ) then
7526: LD_VAR 0 1
7530: PPUSH
7531: CALL_OW 110
7535: NOT
7536: PUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 314
7546: NOT
7547: AND
7548: IFFALSE 7562
// ComEnterUnit ( i , us_lab ) ;
7550: LD_VAR 0 1
7554: PPUSH
7555: LD_INT 1
7557: PPUSH
7558: CALL_OW 120
7562: GO 7523
7564: POP
7565: POP
// end ;
7566: PPOPN 1
7568: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7569: LD_EXP 7
7573: NOT
7574: PUSH
7575: LD_INT 9
7577: PPUSH
7578: LD_INT 22
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: LD_INT 21
7590: PUSH
7591: LD_INT 3
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 24
7603: PUSH
7604: LD_INT 1000
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: PPUSH
7620: CALL_OW 70
7624: NOT
7625: AND
7626: PUSH
7627: LD_INT 22
7629: PUSH
7630: LD_INT 1
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PUSH
7637: LD_INT 25
7639: PUSH
7640: LD_INT 2
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 56
7649: PUSH
7650: EMPTY
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: PPUSH
7658: CALL_OW 69
7662: AND
7663: IFFALSE 7756
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin enable ;
7671: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7672: LD_ADDR_VAR 0 1
7676: PUSH
7677: LD_INT 22
7679: PUSH
7680: LD_INT 1
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 25
7689: PUSH
7690: LD_INT 2
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: LD_INT 56
7699: PUSH
7700: EMPTY
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: PPUSH
7708: CALL_OW 69
7712: PUSH
7713: FOR_IN
7714: IFFALSE 7754
// if not HasTask ( i ) and not GetTag ( i ) then
7716: LD_VAR 0 1
7720: PPUSH
7721: CALL_OW 314
7725: NOT
7726: PUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 110
7736: NOT
7737: AND
7738: IFFALSE 7752
// ComEnterUnit ( i , us_depot ) ;
7740: LD_VAR 0 1
7744: PPUSH
7745: LD_INT 5
7747: PPUSH
7748: CALL_OW 120
7752: GO 7713
7754: POP
7755: POP
// end ;
7756: PPOPN 1
7758: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7759: LD_EXP 9
7763: PUSH
7764: LD_INT 0
7766: LESSEQUAL
7767: PUSH
7768: LD_EXP 18
7772: PPUSH
7773: CALL_OW 301
7777: OR
7778: PUSH
7779: LD_INT 22
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PUSH
7789: LD_INT 25
7791: PUSH
7792: LD_INT 2
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 69
7807: AND
7808: IFFALSE 7849
7810: GO 7812
7812: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7813: LD_INT 22
7815: PUSH
7816: LD_INT 1
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PUSH
7823: LD_INT 25
7825: PUSH
7826: LD_INT 2
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 69
7841: PPUSH
7842: LD_INT 1
7844: PPUSH
7845: CALL_OW 167
7849: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7850: LD_EXP 7
7854: NOT
7855: PUSH
7856: LD_INT 7
7858: PPUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 7
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 70
7873: AND
7874: IFFALSE 7965
7876: GO 7878
7878: DISABLE
7879: LD_INT 0
7881: PPUSH
// begin wait ( 0 0$2 ) ;
7882: LD_INT 70
7884: PPUSH
7885: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7889: LD_ADDR_VAR 0 1
7893: PUSH
7894: LD_INT 22
7896: PUSH
7897: LD_INT 1
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: PUSH
7904: LD_INT 25
7906: PUSH
7907: LD_INT 1
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 69
7922: PUSH
7923: FOR_IN
7924: IFFALSE 7963
// begin if IsInUnit ( i ) then
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 310
7935: IFFALSE 7946
// ComExitBuilding ( i ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_INT 92
7953: PPUSH
7954: LD_INT 78
7956: PPUSH
7957: CALL_OW 174
// end ;
7961: GO 7923
7963: POP
7964: POP
// end ; end_of_file
7965: PPOPN 1
7967: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7968: LD_VAR 0 1
7972: PPUSH
7973: LD_VAR 0 2
7977: PPUSH
7978: LD_VAR 0 3
7982: PPUSH
7983: CALL 2823 0 3
7987: PPOPN 3
7989: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7990: LD_EXP 14
7994: PPUSH
7995: CALL_OW 257
7999: PUSH
8000: LD_INT 4
8002: EQUAL
8003: PUSH
8004: LD_EXP 15
8008: PPUSH
8009: CALL_OW 257
8013: PUSH
8014: LD_INT 4
8016: EQUAL
8017: OR
8018: IFFALSE 8022
// exit ;
8020: GO 8060
// if un = JMM then
8022: LD_VAR 0 1
8026: PUSH
8027: LD_EXP 14
8031: EQUAL
8032: IFFALSE 8041
// YouLost ( JMM ) ;
8034: LD_STRING JMM
8036: PPUSH
8037: CALL_OW 104
// if un = Burlak then
8041: LD_VAR 0 1
8045: PUSH
8046: LD_EXP 15
8050: EQUAL
8051: IFFALSE 8060
// YouLost ( Burlak ) ;
8053: LD_STRING Burlak
8055: PPUSH
8056: CALL_OW 104
// end ;
8060: PPOPN 1
8062: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8063: LD_VAR 0 1
8067: PUSH
8068: LD_EXP 14
8072: EQUAL
8073: IFFALSE 8082
// YouLost ( JMM ) ;
8075: LD_STRING JMM
8077: PPUSH
8078: CALL_OW 104
// if un = Burlak then
8082: LD_VAR 0 1
8086: PUSH
8087: LD_EXP 15
8091: EQUAL
8092: IFFALSE 8101
// YouLost ( Burlak ) ;
8094: LD_STRING Burlak
8096: PPUSH
8097: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8101: LD_VAR 0 1
8105: PUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 1
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 23
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PPUSH
8130: CALL_OW 69
8134: IN
8135: IFFALSE 8151
// killCounter := killCounter + 1 ;
8137: LD_ADDR_EXP 12
8141: PUSH
8142: LD_EXP 12
8146: PUSH
8147: LD_INT 1
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: PPOPN 1
8153: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8154: LD_VAR 0 2
8158: PUSH
8159: LD_INT 7
8161: EQUAL
8162: PUSH
8163: LD_VAR 0 1
8167: PUSH
8168: LD_INT 2
8170: PUSH
8171: LD_INT 30
8173: PUSH
8174: LD_INT 31
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 30
8183: PUSH
8184: LD_INT 32
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 30
8193: PUSH
8194: LD_INT 33
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 69
8211: IN
8212: AND
8213: IFFALSE 8229
// bunkerCounter := bunkerCounter + 1 ;
8215: LD_ADDR_EXP 13
8219: PUSH
8220: LD_EXP 13
8224: PUSH
8225: LD_INT 1
8227: PLUS
8228: ST_TO_ADDR
// end ;
8229: PPOPN 3
8231: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8232: LD_VAR 0 1
8236: PPUSH
8237: CALL_OW 255
8241: PUSH
8242: LD_INT 7
8244: EQUAL
8245: IFFALSE 8255
// artifactPickedUp := true ;
8247: LD_ADDR_EXP 6
8251: PUSH
8252: LD_INT 1
8254: ST_TO_ADDR
// end ;
8255: PPOPN 2
8257: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8258: LD_ADDR_EXP 6
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
8266: PPOPN 2
8268: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 255
8278: PUSH
8279: LD_INT 1
8281: NONEQUAL
8282: IFFALSE 8286
// exit ;
8284: GO 8333
// wait ( 0 0$5 ) ;
8286: LD_INT 175
8288: PPUSH
8289: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 263
8302: PUSH
8303: LD_INT 2
8305: EQUAL
8306: IFFALSE 8317
// Connect ( vehicle ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL 1824 0 1
// vehGuard := vehGuard ^ vehicle ;
8317: LD_ADDR_EXP 23
8321: PUSH
8322: LD_EXP 23
8326: PUSH
8327: LD_VAR 0 1
8331: ADD
8332: ST_TO_ADDR
// end ;
8333: PPOPN 2
8335: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8336: LD_VAR 0 1
8340: PUSH
8341: LD_INT 1
8343: EQUAL
8344: PUSH
8345: LD_EXP 7
8349: NOT
8350: AND
8351: IFFALSE 8386
// begin planCaptured := true ;
8353: LD_ADDR_EXP 7
8357: PUSH
8358: LD_INT 1
8360: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8361: LD_STRING MEnd
8363: PPUSH
8364: CALL_OW 337
// canEnd := true ;
8368: LD_ADDR_EXP 10
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// missionTime := tick ;
8376: LD_ADDR_EXP 11
8380: PUSH
8381: LD_OWVAR 1
8385: ST_TO_ADDR
// end ; end ;
8386: PPOPN 3
8388: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL 12058 0 1
// end ; end_of_file
8398: PPOPN 1
8400: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8401: GO 8403
8403: DISABLE
// begin ru_radar := 98 ;
8404: LD_ADDR_EXP 24
8408: PUSH
8409: LD_INT 98
8411: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8412: LD_ADDR_EXP 25
8416: PUSH
8417: LD_INT 89
8419: ST_TO_ADDR
// us_hack := 99 ;
8420: LD_ADDR_EXP 26
8424: PUSH
8425: LD_INT 99
8427: ST_TO_ADDR
// us_artillery := 97 ;
8428: LD_ADDR_EXP 27
8432: PUSH
8433: LD_INT 97
8435: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8436: LD_ADDR_EXP 28
8440: PUSH
8441: LD_INT 91
8443: ST_TO_ADDR
// end ; end_of_file end_of_file
8444: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
8445: GO 8447
8447: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8448: LD_STRING initStreamRollete();
8450: PPUSH
8451: CALL_OW 559
// InitStreamMode ;
8455: CALL 8460 0 0
// end ;
8459: END
// function InitStreamMode ; begin
8460: LD_INT 0
8462: PPUSH
// streamModeActive := false ;
8463: LD_ADDR_EXP 29
8467: PUSH
8468: LD_INT 0
8470: ST_TO_ADDR
// sRocket := false ;
8471: LD_ADDR_EXP 32
8475: PUSH
8476: LD_INT 0
8478: ST_TO_ADDR
// sSpeed := false ;
8479: LD_ADDR_EXP 31
8483: PUSH
8484: LD_INT 0
8486: ST_TO_ADDR
// sEngine := false ;
8487: LD_ADDR_EXP 33
8491: PUSH
8492: LD_INT 0
8494: ST_TO_ADDR
// sSpec := false ;
8495: LD_ADDR_EXP 30
8499: PUSH
8500: LD_INT 0
8502: ST_TO_ADDR
// sLevel := false ;
8503: LD_ADDR_EXP 34
8507: PUSH
8508: LD_INT 0
8510: ST_TO_ADDR
// sArmoury := false ;
8511: LD_ADDR_EXP 35
8515: PUSH
8516: LD_INT 0
8518: ST_TO_ADDR
// sRadar := false ;
8519: LD_ADDR_EXP 36
8523: PUSH
8524: LD_INT 0
8526: ST_TO_ADDR
// sBunker := false ;
8527: LD_ADDR_EXP 37
8531: PUSH
8532: LD_INT 0
8534: ST_TO_ADDR
// sHack := false ;
8535: LD_ADDR_EXP 38
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// sFire := false ;
8543: LD_ADDR_EXP 39
8547: PUSH
8548: LD_INT 0
8550: ST_TO_ADDR
// sRefresh := false ;
8551: LD_ADDR_EXP 40
8555: PUSH
8556: LD_INT 0
8558: ST_TO_ADDR
// sExp := false ;
8559: LD_ADDR_EXP 41
8563: PUSH
8564: LD_INT 0
8566: ST_TO_ADDR
// sDepot := false ;
8567: LD_ADDR_EXP 42
8571: PUSH
8572: LD_INT 0
8574: ST_TO_ADDR
// sFlag := false ;
8575: LD_ADDR_EXP 43
8579: PUSH
8580: LD_INT 0
8582: ST_TO_ADDR
// sKamikadze := false ;
8583: LD_ADDR_EXP 51
8587: PUSH
8588: LD_INT 0
8590: ST_TO_ADDR
// sTroll := false ;
8591: LD_ADDR_EXP 52
8595: PUSH
8596: LD_INT 0
8598: ST_TO_ADDR
// sSlow := false ;
8599: LD_ADDR_EXP 53
8603: PUSH
8604: LD_INT 0
8606: ST_TO_ADDR
// sLack := false ;
8607: LD_ADDR_EXP 54
8611: PUSH
8612: LD_INT 0
8614: ST_TO_ADDR
// sTank := false ;
8615: LD_ADDR_EXP 56
8619: PUSH
8620: LD_INT 0
8622: ST_TO_ADDR
// sRemote := false ;
8623: LD_ADDR_EXP 57
8627: PUSH
8628: LD_INT 0
8630: ST_TO_ADDR
// sSold := false ;
8631: LD_ADDR_EXP 44
8635: PUSH
8636: LD_INT 0
8638: ST_TO_ADDR
// sDiff := false ;
8639: LD_ADDR_EXP 45
8643: PUSH
8644: LD_INT 0
8646: ST_TO_ADDR
// sFog := false ;
8647: LD_ADDR_EXP 48
8651: PUSH
8652: LD_INT 0
8654: ST_TO_ADDR
// sReset := false ;
8655: LD_ADDR_EXP 49
8659: PUSH
8660: LD_INT 0
8662: ST_TO_ADDR
// sSun := false ;
8663: LD_ADDR_EXP 50
8667: PUSH
8668: LD_INT 0
8670: ST_TO_ADDR
// sTiger := false ;
8671: LD_ADDR_EXP 46
8675: PUSH
8676: LD_INT 0
8678: ST_TO_ADDR
// sBomb := false ;
8679: LD_ADDR_EXP 47
8683: PUSH
8684: LD_INT 0
8686: ST_TO_ADDR
// sWound := false ;
8687: LD_ADDR_EXP 55
8691: PUSH
8692: LD_INT 0
8694: ST_TO_ADDR
// end ;
8695: LD_VAR 0 1
8699: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
8700: LD_VAR 0 2
8704: PUSH
8705: LD_INT 100
8707: EQUAL
8708: IFFALSE 9243
// begin if not StreamModeActive then
8710: LD_EXP 29
8714: NOT
8715: IFFALSE 8725
// StreamModeActive := true ;
8717: LD_ADDR_EXP 29
8721: PUSH
8722: LD_INT 1
8724: ST_TO_ADDR
// if p3 = 0 then
8725: LD_VAR 0 3
8729: PUSH
8730: LD_INT 0
8732: EQUAL
8733: IFFALSE 8739
// InitStreamMode ;
8735: CALL 8460 0 0
// if p3 = 1 then
8739: LD_VAR 0 3
8743: PUSH
8744: LD_INT 1
8746: EQUAL
8747: IFFALSE 8757
// sRocket := true ;
8749: LD_ADDR_EXP 32
8753: PUSH
8754: LD_INT 1
8756: ST_TO_ADDR
// if p3 = 2 then
8757: LD_VAR 0 3
8761: PUSH
8762: LD_INT 2
8764: EQUAL
8765: IFFALSE 8775
// sSpeed := true ;
8767: LD_ADDR_EXP 31
8771: PUSH
8772: LD_INT 1
8774: ST_TO_ADDR
// if p3 = 3 then
8775: LD_VAR 0 3
8779: PUSH
8780: LD_INT 3
8782: EQUAL
8783: IFFALSE 8793
// sEngine := true ;
8785: LD_ADDR_EXP 33
8789: PUSH
8790: LD_INT 1
8792: ST_TO_ADDR
// if p3 = 4 then
8793: LD_VAR 0 3
8797: PUSH
8798: LD_INT 4
8800: EQUAL
8801: IFFALSE 8811
// sSpec := true ;
8803: LD_ADDR_EXP 30
8807: PUSH
8808: LD_INT 1
8810: ST_TO_ADDR
// if p3 = 5 then
8811: LD_VAR 0 3
8815: PUSH
8816: LD_INT 5
8818: EQUAL
8819: IFFALSE 8829
// sLevel := true ;
8821: LD_ADDR_EXP 34
8825: PUSH
8826: LD_INT 1
8828: ST_TO_ADDR
// if p3 = 6 then
8829: LD_VAR 0 3
8833: PUSH
8834: LD_INT 6
8836: EQUAL
8837: IFFALSE 8847
// sArmoury := true ;
8839: LD_ADDR_EXP 35
8843: PUSH
8844: LD_INT 1
8846: ST_TO_ADDR
// if p3 = 7 then
8847: LD_VAR 0 3
8851: PUSH
8852: LD_INT 7
8854: EQUAL
8855: IFFALSE 8865
// sRadar := true ;
8857: LD_ADDR_EXP 36
8861: PUSH
8862: LD_INT 1
8864: ST_TO_ADDR
// if p3 = 8 then
8865: LD_VAR 0 3
8869: PUSH
8870: LD_INT 8
8872: EQUAL
8873: IFFALSE 8883
// sBunker := true ;
8875: LD_ADDR_EXP 37
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// if p3 = 9 then
8883: LD_VAR 0 3
8887: PUSH
8888: LD_INT 9
8890: EQUAL
8891: IFFALSE 8901
// sHack := true ;
8893: LD_ADDR_EXP 38
8897: PUSH
8898: LD_INT 1
8900: ST_TO_ADDR
// if p3 = 10 then
8901: LD_VAR 0 3
8905: PUSH
8906: LD_INT 10
8908: EQUAL
8909: IFFALSE 8919
// sFire := true ;
8911: LD_ADDR_EXP 39
8915: PUSH
8916: LD_INT 1
8918: ST_TO_ADDR
// if p3 = 11 then
8919: LD_VAR 0 3
8923: PUSH
8924: LD_INT 11
8926: EQUAL
8927: IFFALSE 8937
// sRefresh := true ;
8929: LD_ADDR_EXP 40
8933: PUSH
8934: LD_INT 1
8936: ST_TO_ADDR
// if p3 = 12 then
8937: LD_VAR 0 3
8941: PUSH
8942: LD_INT 12
8944: EQUAL
8945: IFFALSE 8955
// sExp := true ;
8947: LD_ADDR_EXP 41
8951: PUSH
8952: LD_INT 1
8954: ST_TO_ADDR
// if p3 = 13 then
8955: LD_VAR 0 3
8959: PUSH
8960: LD_INT 13
8962: EQUAL
8963: IFFALSE 8973
// sDepot := true ;
8965: LD_ADDR_EXP 42
8969: PUSH
8970: LD_INT 1
8972: ST_TO_ADDR
// if p3 = 14 then
8973: LD_VAR 0 3
8977: PUSH
8978: LD_INT 14
8980: EQUAL
8981: IFFALSE 8991
// sFlag := true ;
8983: LD_ADDR_EXP 43
8987: PUSH
8988: LD_INT 1
8990: ST_TO_ADDR
// if p3 = 15 then
8991: LD_VAR 0 3
8995: PUSH
8996: LD_INT 15
8998: EQUAL
8999: IFFALSE 9009
// sKamikadze := true ;
9001: LD_ADDR_EXP 51
9005: PUSH
9006: LD_INT 1
9008: ST_TO_ADDR
// if p3 = 16 then
9009: LD_VAR 0 3
9013: PUSH
9014: LD_INT 16
9016: EQUAL
9017: IFFALSE 9027
// sTroll := true ;
9019: LD_ADDR_EXP 52
9023: PUSH
9024: LD_INT 1
9026: ST_TO_ADDR
// if p3 = 17 then
9027: LD_VAR 0 3
9031: PUSH
9032: LD_INT 17
9034: EQUAL
9035: IFFALSE 9045
// sSlow := true ;
9037: LD_ADDR_EXP 53
9041: PUSH
9042: LD_INT 1
9044: ST_TO_ADDR
// if p3 = 18 then
9045: LD_VAR 0 3
9049: PUSH
9050: LD_INT 18
9052: EQUAL
9053: IFFALSE 9063
// sLack := true ;
9055: LD_ADDR_EXP 54
9059: PUSH
9060: LD_INT 1
9062: ST_TO_ADDR
// if p3 = 19 then
9063: LD_VAR 0 3
9067: PUSH
9068: LD_INT 19
9070: EQUAL
9071: IFFALSE 9081
// sTank := true ;
9073: LD_ADDR_EXP 56
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// if p3 = 20 then
9081: LD_VAR 0 3
9085: PUSH
9086: LD_INT 20
9088: EQUAL
9089: IFFALSE 9099
// sRemote := true ;
9091: LD_ADDR_EXP 57
9095: PUSH
9096: LD_INT 1
9098: ST_TO_ADDR
// if p3 = 101 then
9099: LD_VAR 0 3
9103: PUSH
9104: LD_INT 101
9106: EQUAL
9107: IFFALSE 9117
// sSold := true ;
9109: LD_ADDR_EXP 44
9113: PUSH
9114: LD_INT 1
9116: ST_TO_ADDR
// if p3 = 102 then
9117: LD_VAR 0 3
9121: PUSH
9122: LD_INT 102
9124: EQUAL
9125: IFFALSE 9135
// sDiff := true ;
9127: LD_ADDR_EXP 45
9131: PUSH
9132: LD_INT 1
9134: ST_TO_ADDR
// if p3 = 103 then
9135: LD_VAR 0 3
9139: PUSH
9140: LD_INT 103
9142: EQUAL
9143: IFFALSE 9153
// sFog := true ;
9145: LD_ADDR_EXP 48
9149: PUSH
9150: LD_INT 1
9152: ST_TO_ADDR
// if p3 = 104 then
9153: LD_VAR 0 3
9157: PUSH
9158: LD_INT 104
9160: EQUAL
9161: IFFALSE 9171
// sReset := true ;
9163: LD_ADDR_EXP 49
9167: PUSH
9168: LD_INT 1
9170: ST_TO_ADDR
// if p3 = 105 then
9171: LD_VAR 0 3
9175: PUSH
9176: LD_INT 105
9178: EQUAL
9179: IFFALSE 9189
// sSun := true ;
9181: LD_ADDR_EXP 50
9185: PUSH
9186: LD_INT 1
9188: ST_TO_ADDR
// if p3 = 106 then
9189: LD_VAR 0 3
9193: PUSH
9194: LD_INT 106
9196: EQUAL
9197: IFFALSE 9207
// sTiger := true ;
9199: LD_ADDR_EXP 46
9203: PUSH
9204: LD_INT 1
9206: ST_TO_ADDR
// if p3 = 107 then
9207: LD_VAR 0 3
9211: PUSH
9212: LD_INT 107
9214: EQUAL
9215: IFFALSE 9225
// sBomb := true ;
9217: LD_ADDR_EXP 47
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// if p3 = 108 then
9225: LD_VAR 0 3
9229: PUSH
9230: LD_INT 108
9232: EQUAL
9233: IFFALSE 9243
// sWound := true ;
9235: LD_ADDR_EXP 55
9239: PUSH
9240: LD_INT 1
9242: ST_TO_ADDR
// end ; end ;
9243: PPOPN 6
9245: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
9246: LD_EXP 29
9250: PUSH
9251: LD_EXP 32
9255: AND
9256: IFFALSE 9377
9258: GO 9260
9260: DISABLE
9261: LD_INT 0
9263: PPUSH
9264: PPUSH
// begin enable ;
9265: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
9266: LD_ADDR_VAR 0 2
9270: PUSH
9271: LD_INT 22
9273: PUSH
9274: LD_OWVAR 2
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: PUSH
9283: LD_INT 2
9285: PUSH
9286: LD_INT 34
9288: PUSH
9289: LD_INT 7
9291: PUSH
9292: EMPTY
9293: LIST
9294: LIST
9295: PUSH
9296: LD_INT 34
9298: PUSH
9299: LD_INT 45
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PUSH
9306: LD_INT 34
9308: PUSH
9309: LD_INT 28
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PUSH
9316: LD_INT 34
9318: PUSH
9319: LD_INT 47
9321: PUSH
9322: EMPTY
9323: LIST
9324: LIST
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: LIST
9330: LIST
9331: LIST
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PPUSH
9337: CALL_OW 69
9341: ST_TO_ADDR
// if not tmp then
9342: LD_VAR 0 2
9346: NOT
9347: IFFALSE 9351
// exit ;
9349: GO 9377
// for i in tmp do
9351: LD_ADDR_VAR 0 1
9355: PUSH
9356: LD_VAR 0 2
9360: PUSH
9361: FOR_IN
9362: IFFALSE 9375
// begin DestroyUnit ( i ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: CALL_OW 65
// end ;
9373: GO 9361
9375: POP
9376: POP
// end ;
9377: PPOPN 2
9379: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
9380: LD_EXP 29
9384: PUSH
9385: LD_EXP 33
9389: AND
9390: IFFALSE 9471
9392: GO 9394
9394: DISABLE
9395: LD_INT 0
9397: PPUSH
9398: PPUSH
// begin enable ;
9399: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
9400: LD_ADDR_VAR 0 2
9404: PUSH
9405: LD_INT 22
9407: PUSH
9408: LD_OWVAR 2
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: PUSH
9417: LD_INT 32
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PUSH
9427: EMPTY
9428: LIST
9429: LIST
9430: PPUSH
9431: CALL_OW 69
9435: ST_TO_ADDR
// if not tmp then
9436: LD_VAR 0 2
9440: NOT
9441: IFFALSE 9445
// exit ;
9443: GO 9471
// for i in tmp do
9445: LD_ADDR_VAR 0 1
9449: PUSH
9450: LD_VAR 0 2
9454: PUSH
9455: FOR_IN
9456: IFFALSE 9469
// begin DestroyUnit ( i ) ;
9458: LD_VAR 0 1
9462: PPUSH
9463: CALL_OW 65
// end ;
9467: GO 9455
9469: POP
9470: POP
// end ;
9471: PPOPN 2
9473: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
9474: LD_EXP 29
9478: PUSH
9479: LD_EXP 30
9483: AND
9484: IFFALSE 9577
9486: GO 9488
9488: DISABLE
9489: LD_INT 0
9491: PPUSH
// begin enable ;
9492: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
9493: LD_ADDR_VAR 0 1
9497: PUSH
9498: LD_INT 22
9500: PUSH
9501: LD_OWVAR 2
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: PUSH
9510: LD_INT 2
9512: PUSH
9513: LD_INT 25
9515: PUSH
9516: LD_INT 5
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PUSH
9523: LD_INT 25
9525: PUSH
9526: LD_INT 9
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: PUSH
9533: LD_INT 25
9535: PUSH
9536: LD_INT 8
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: PPUSH
9553: CALL_OW 69
9557: PUSH
9558: FOR_IN
9559: IFFALSE 9575
// begin SetClass ( i , 1 ) ;
9561: LD_VAR 0 1
9565: PPUSH
9566: LD_INT 1
9568: PPUSH
9569: CALL_OW 336
// end ;
9573: GO 9558
9575: POP
9576: POP
// end ;
9577: PPOPN 1
9579: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
9580: LD_EXP 29
9584: PUSH
9585: LD_EXP 31
9589: AND
9590: PUSH
9591: LD_OWVAR 65
9595: PUSH
9596: LD_INT 7
9598: LESS
9599: AND
9600: IFFALSE 9614
9602: GO 9604
9604: DISABLE
// begin enable ;
9605: ENABLE
// game_speed := 7 ;
9606: LD_ADDR_OWVAR 65
9610: PUSH
9611: LD_INT 7
9613: ST_TO_ADDR
// end ;
9614: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
9615: LD_EXP 29
9619: PUSH
9620: LD_EXP 34
9624: AND
9625: IFFALSE 9827
9627: GO 9629
9629: DISABLE
9630: LD_INT 0
9632: PPUSH
9633: PPUSH
9634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
9635: LD_ADDR_VAR 0 3
9639: PUSH
9640: LD_INT 81
9642: PUSH
9643: LD_OWVAR 2
9647: PUSH
9648: EMPTY
9649: LIST
9650: LIST
9651: PUSH
9652: LD_INT 21
9654: PUSH
9655: LD_INT 1
9657: PUSH
9658: EMPTY
9659: LIST
9660: LIST
9661: PUSH
9662: EMPTY
9663: LIST
9664: LIST
9665: PPUSH
9666: CALL_OW 69
9670: ST_TO_ADDR
// if not tmp then
9671: LD_VAR 0 3
9675: NOT
9676: IFFALSE 9680
// exit ;
9678: GO 9827
// if tmp > 5 then
9680: LD_VAR 0 3
9684: PUSH
9685: LD_INT 5
9687: GREATER
9688: IFFALSE 9700
// k := 5 else
9690: LD_ADDR_VAR 0 2
9694: PUSH
9695: LD_INT 5
9697: ST_TO_ADDR
9698: GO 9710
// k := tmp ;
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_VAR 0 3
9709: ST_TO_ADDR
// for i := 1 to k do
9710: LD_ADDR_VAR 0 1
9714: PUSH
9715: DOUBLE
9716: LD_INT 1
9718: DEC
9719: ST_TO_ADDR
9720: LD_VAR 0 2
9724: PUSH
9725: FOR_TO
9726: IFFALSE 9825
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
9728: LD_VAR 0 3
9732: PUSH
9733: LD_VAR 0 1
9737: ARRAY
9738: PPUSH
9739: LD_VAR 0 1
9743: PUSH
9744: LD_INT 4
9746: MOD
9747: PUSH
9748: LD_INT 1
9750: PLUS
9751: PPUSH
9752: CALL_OW 259
9756: PUSH
9757: LD_INT 10
9759: LESS
9760: IFFALSE 9823
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
9762: LD_VAR 0 3
9766: PUSH
9767: LD_VAR 0 1
9771: ARRAY
9772: PPUSH
9773: LD_VAR 0 1
9777: PUSH
9778: LD_INT 4
9780: MOD
9781: PUSH
9782: LD_INT 1
9784: PLUS
9785: PPUSH
9786: LD_VAR 0 3
9790: PUSH
9791: LD_VAR 0 1
9795: ARRAY
9796: PPUSH
9797: LD_VAR 0 1
9801: PUSH
9802: LD_INT 4
9804: MOD
9805: PUSH
9806: LD_INT 1
9808: PLUS
9809: PPUSH
9810: CALL_OW 259
9814: PUSH
9815: LD_INT 1
9817: PLUS
9818: PPUSH
9819: CALL_OW 237
9823: GO 9725
9825: POP
9826: POP
// end ;
9827: PPOPN 3
9829: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
9830: LD_EXP 29
9834: PUSH
9835: LD_EXP 35
9839: AND
9840: IFFALSE 9860
9842: GO 9844
9844: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
9845: LD_INT 4
9847: PPUSH
9848: LD_OWVAR 2
9852: PPUSH
9853: LD_INT 0
9855: PPUSH
9856: CALL_OW 324
9860: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
9861: LD_EXP 29
9865: PUSH
9866: LD_EXP 36
9870: AND
9871: IFFALSE 9970
9873: GO 9875
9875: DISABLE
9876: LD_INT 0
9878: PPUSH
9879: PPUSH
// begin enable ;
9880: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
9881: LD_ADDR_VAR 0 2
9885: PUSH
9886: LD_INT 22
9888: PUSH
9889: LD_OWVAR 2
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PUSH
9898: LD_INT 2
9900: PUSH
9901: LD_INT 34
9903: PUSH
9904: LD_INT 11
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: PUSH
9911: LD_INT 34
9913: PUSH
9914: LD_INT 30
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: PUSH
9921: EMPTY
9922: LIST
9923: LIST
9924: LIST
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: PPUSH
9930: CALL_OW 69
9934: ST_TO_ADDR
// if not tmp then
9935: LD_VAR 0 2
9939: NOT
9940: IFFALSE 9944
// exit ;
9942: GO 9970
// for i in tmp do
9944: LD_ADDR_VAR 0 1
9948: PUSH
9949: LD_VAR 0 2
9953: PUSH
9954: FOR_IN
9955: IFFALSE 9968
// begin DestroyUnit ( i ) ;
9957: LD_VAR 0 1
9961: PPUSH
9962: CALL_OW 65
// end ;
9966: GO 9954
9968: POP
9969: POP
// end ;
9970: PPOPN 2
9972: END
// every 0 0$1 trigger StreamModeActive and sBunker do
9973: LD_EXP 29
9977: PUSH
9978: LD_EXP 37
9982: AND
9983: IFFALSE 10003
9985: GO 9987
9987: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
9988: LD_INT 32
9990: PPUSH
9991: LD_OWVAR 2
9995: PPUSH
9996: LD_INT 0
9998: PPUSH
9999: CALL_OW 324
10003: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
10004: LD_EXP 29
10008: PUSH
10009: LD_EXP 38
10013: AND
10014: IFFALSE 10195
10016: GO 10018
10018: DISABLE
10019: LD_INT 0
10021: PPUSH
10022: PPUSH
10023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
10024: LD_ADDR_VAR 0 2
10028: PUSH
10029: LD_INT 22
10031: PUSH
10032: LD_OWVAR 2
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 33
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: PPUSH
10055: CALL_OW 69
10059: ST_TO_ADDR
// if not tmp then
10060: LD_VAR 0 2
10064: NOT
10065: IFFALSE 10069
// exit ;
10067: GO 10195
// side := 0 ;
10069: LD_ADDR_VAR 0 3
10073: PUSH
10074: LD_INT 0
10076: ST_TO_ADDR
// for i := 1 to 8 do
10077: LD_ADDR_VAR 0 1
10081: PUSH
10082: DOUBLE
10083: LD_INT 1
10085: DEC
10086: ST_TO_ADDR
10087: LD_INT 8
10089: PUSH
10090: FOR_TO
10091: IFFALSE 10139
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
10093: LD_OWVAR 2
10097: PUSH
10098: LD_VAR 0 1
10102: NONEQUAL
10103: PUSH
10104: LD_OWVAR 2
10108: PPUSH
10109: LD_VAR 0 1
10113: PPUSH
10114: CALL_OW 81
10118: PUSH
10119: LD_INT 2
10121: EQUAL
10122: AND
10123: IFFALSE 10137
// begin side := i ;
10125: LD_ADDR_VAR 0 3
10129: PUSH
10130: LD_VAR 0 1
10134: ST_TO_ADDR
// break ;
10135: GO 10139
// end ;
10137: GO 10090
10139: POP
10140: POP
// if not side then
10141: LD_VAR 0 3
10145: NOT
10146: IFFALSE 10150
// exit ;
10148: GO 10195
// for i := 1 to tmp do
10150: LD_ADDR_VAR 0 1
10154: PUSH
10155: DOUBLE
10156: LD_INT 1
10158: DEC
10159: ST_TO_ADDR
10160: LD_VAR 0 2
10164: PUSH
10165: FOR_TO
10166: IFFALSE 10193
// if Prob ( 30 ) then
10168: LD_INT 30
10170: PPUSH
10171: CALL_OW 13
10175: IFFALSE 10191
// SetSide ( i , side ) ;
10177: LD_VAR 0 1
10181: PPUSH
10182: LD_VAR 0 3
10186: PPUSH
10187: CALL_OW 235
10191: GO 10165
10193: POP
10194: POP
// end ;
10195: PPOPN 3
10197: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
10198: LD_EXP 29
10202: PUSH
10203: LD_EXP 40
10207: AND
10208: IFFALSE 10327
10210: GO 10212
10212: DISABLE
10213: LD_INT 0
10215: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
10216: LD_ADDR_VAR 0 1
10220: PUSH
10221: LD_INT 22
10223: PUSH
10224: LD_OWVAR 2
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PUSH
10233: LD_INT 21
10235: PUSH
10236: LD_INT 1
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 3
10245: PUSH
10246: LD_INT 23
10248: PUSH
10249: LD_INT 0
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: LIST
10264: PPUSH
10265: CALL_OW 69
10269: PUSH
10270: FOR_IN
10271: IFFALSE 10325
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
10273: LD_VAR 0 1
10277: PPUSH
10278: CALL_OW 257
10282: PUSH
10283: LD_INT 1
10285: PUSH
10286: LD_INT 2
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 4
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: IN
10301: IFFALSE 10323
// SetClass ( un , rand ( 1 , 4 ) ) ;
10303: LD_VAR 0 1
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 4
10313: PPUSH
10314: CALL_OW 12
10318: PPUSH
10319: CALL_OW 336
10323: GO 10270
10325: POP
10326: POP
// end ;
10327: PPOPN 1
10329: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
10330: LD_EXP 29
10334: PUSH
10335: LD_EXP 39
10339: AND
10340: IFFALSE 10419
10342: GO 10344
10344: DISABLE
10345: LD_INT 0
10347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10348: LD_ADDR_VAR 0 1
10352: PUSH
10353: LD_INT 22
10355: PUSH
10356: LD_OWVAR 2
10360: PUSH
10361: EMPTY
10362: LIST
10363: LIST
10364: PUSH
10365: LD_INT 21
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: PPUSH
10379: CALL_OW 69
10383: ST_TO_ADDR
// if not tmp then
10384: LD_VAR 0 1
10388: NOT
10389: IFFALSE 10393
// exit ;
10391: GO 10419
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
10393: LD_VAR 0 1
10397: PUSH
10398: LD_INT 1
10400: PPUSH
10401: LD_VAR 0 1
10405: PPUSH
10406: CALL_OW 12
10410: ARRAY
10411: PPUSH
10412: LD_INT 100
10414: PPUSH
10415: CALL_OW 234
// end ;
10419: PPOPN 1
10421: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
10422: LD_EXP 29
10426: PUSH
10427: LD_EXP 41
10431: AND
10432: IFFALSE 10530
10434: GO 10436
10436: DISABLE
10437: LD_INT 0
10439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
10440: LD_ADDR_VAR 0 1
10444: PUSH
10445: LD_INT 22
10447: PUSH
10448: LD_OWVAR 2
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PUSH
10457: LD_INT 21
10459: PUSH
10460: LD_INT 1
10462: PUSH
10463: EMPTY
10464: LIST
10465: LIST
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: PPUSH
10471: CALL_OW 69
10475: ST_TO_ADDR
// if not tmp then
10476: LD_VAR 0 1
10480: NOT
10481: IFFALSE 10485
// exit ;
10483: GO 10530
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
10485: LD_VAR 0 1
10489: PUSH
10490: LD_INT 1
10492: PPUSH
10493: LD_VAR 0 1
10497: PPUSH
10498: CALL_OW 12
10502: ARRAY
10503: PPUSH
10504: LD_INT 1
10506: PPUSH
10507: LD_INT 4
10509: PPUSH
10510: CALL_OW 12
10514: PPUSH
10515: LD_INT 3000
10517: PPUSH
10518: LD_INT 9000
10520: PPUSH
10521: CALL_OW 12
10525: PPUSH
10526: CALL_OW 492
// end ;
10530: PPOPN 1
10532: END
// every 0 0$1 trigger StreamModeActive and sDepot do
10533: LD_EXP 29
10537: PUSH
10538: LD_EXP 42
10542: AND
10543: IFFALSE 10563
10545: GO 10547
10547: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
10548: LD_INT 1
10550: PPUSH
10551: LD_OWVAR 2
10555: PPUSH
10556: LD_INT 0
10558: PPUSH
10559: CALL_OW 324
10563: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
10564: LD_EXP 29
10568: PUSH
10569: LD_EXP 43
10573: AND
10574: IFFALSE 10657
10576: GO 10578
10578: DISABLE
10579: LD_INT 0
10581: PPUSH
10582: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
10583: LD_ADDR_VAR 0 2
10587: PUSH
10588: LD_INT 22
10590: PUSH
10591: LD_OWVAR 2
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: PUSH
10600: LD_INT 21
10602: PUSH
10603: LD_INT 3
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: PPUSH
10614: CALL_OW 69
10618: ST_TO_ADDR
// if not tmp then
10619: LD_VAR 0 2
10623: NOT
10624: IFFALSE 10628
// exit ;
10626: GO 10657
// for i in tmp do
10628: LD_ADDR_VAR 0 1
10632: PUSH
10633: LD_VAR 0 2
10637: PUSH
10638: FOR_IN
10639: IFFALSE 10655
// SetBLevel ( i , 10 ) ;
10641: LD_VAR 0 1
10645: PPUSH
10646: LD_INT 10
10648: PPUSH
10649: CALL_OW 241
10653: GO 10638
10655: POP
10656: POP
// end ;
10657: PPOPN 2
10659: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
10660: LD_EXP 29
10664: PUSH
10665: LD_EXP 44
10669: AND
10670: IFFALSE 10773
10672: GO 10674
10674: DISABLE
10675: LD_INT 0
10677: PPUSH
10678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10679: LD_ADDR_VAR 0 2
10683: PUSH
10684: LD_INT 22
10686: PUSH
10687: LD_OWVAR 2
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: PUSH
10696: LD_INT 25
10698: PUSH
10699: LD_INT 1
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PPUSH
10710: CALL_OW 69
10714: ST_TO_ADDR
// if not tmp then
10715: LD_VAR 0 2
10719: NOT
10720: IFFALSE 10724
// exit ;
10722: GO 10773
// for i in tmp do
10724: LD_ADDR_VAR 0 1
10728: PUSH
10729: LD_VAR 0 2
10733: PUSH
10734: FOR_IN
10735: IFFALSE 10771
// begin if Crawls ( i ) then
10737: LD_VAR 0 1
10741: PPUSH
10742: CALL_OW 318
10746: IFFALSE 10757
// ComWalk ( i ) ;
10748: LD_VAR 0 1
10752: PPUSH
10753: CALL_OW 138
// SetClass ( i , 4 ) ;
10757: LD_VAR 0 1
10761: PPUSH
10762: LD_INT 4
10764: PPUSH
10765: CALL_OW 336
// end ;
10769: GO 10734
10771: POP
10772: POP
// end ;
10773: PPOPN 2
10775: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
10776: LD_EXP 29
10780: PUSH
10781: LD_EXP 45
10785: AND
10786: PUSH
10787: LD_OWVAR 67
10791: PUSH
10792: LD_INT 3
10794: LESS
10795: AND
10796: IFFALSE 10815
10798: GO 10800
10800: DISABLE
// Difficulty := Difficulty + 1 ;
10801: LD_ADDR_OWVAR 67
10805: PUSH
10806: LD_OWVAR 67
10810: PUSH
10811: LD_INT 1
10813: PLUS
10814: ST_TO_ADDR
10815: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
10816: LD_EXP 29
10820: PUSH
10821: LD_EXP 46
10825: AND
10826: IFFALSE 10929
10828: GO 10830
10830: DISABLE
10831: LD_INT 0
10833: PPUSH
// begin for i := 1 to 5 do
10834: LD_ADDR_VAR 0 1
10838: PUSH
10839: DOUBLE
10840: LD_INT 1
10842: DEC
10843: ST_TO_ADDR
10844: LD_INT 5
10846: PUSH
10847: FOR_TO
10848: IFFALSE 10927
// begin uc_nation := nation_nature ;
10850: LD_ADDR_OWVAR 21
10854: PUSH
10855: LD_INT 0
10857: ST_TO_ADDR
// uc_side := 0 ;
10858: LD_ADDR_OWVAR 20
10862: PUSH
10863: LD_INT 0
10865: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10866: LD_ADDR_OWVAR 29
10870: PUSH
10871: LD_INT 12
10873: PUSH
10874: LD_INT 12
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: ST_TO_ADDR
// hc_agressivity := 20 ;
10881: LD_ADDR_OWVAR 35
10885: PUSH
10886: LD_INT 20
10888: ST_TO_ADDR
// hc_class := class_tiger ;
10889: LD_ADDR_OWVAR 28
10893: PUSH
10894: LD_INT 14
10896: ST_TO_ADDR
// hc_gallery :=  ;
10897: LD_ADDR_OWVAR 33
10901: PUSH
10902: LD_STRING 
10904: ST_TO_ADDR
// hc_name :=  ;
10905: LD_ADDR_OWVAR 26
10909: PUSH
10910: LD_STRING 
10912: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
10913: CALL_OW 44
10917: PPUSH
10918: LD_INT 0
10920: PPUSH
10921: CALL_OW 51
// end ;
10925: GO 10847
10927: POP
10928: POP
// end ;
10929: PPOPN 1
10931: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
10932: LD_EXP 29
10936: PUSH
10937: LD_EXP 47
10941: AND
10942: IFFALSE 11116
10944: GO 10946
10946: DISABLE
10947: LD_INT 0
10949: PPUSH
10950: PPUSH
10951: PPUSH
10952: PPUSH
// begin result := false ;
10953: LD_ADDR_VAR 0 4
10957: PUSH
10958: LD_INT 0
10960: ST_TO_ADDR
// for i := 1 to 8 do
10961: LD_ADDR_VAR 0 1
10965: PUSH
10966: DOUBLE
10967: LD_INT 1
10969: DEC
10970: ST_TO_ADDR
10971: LD_INT 8
10973: PUSH
10974: FOR_TO
10975: IFFALSE 11086
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
10977: LD_ADDR_VAR 0 2
10981: PUSH
10982: LD_INT 10
10984: PUSH
10985: LD_INT 50
10987: PUSH
10988: LD_INT 90
10990: PUSH
10991: LD_INT 140
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 1
11002: PPUSH
11003: LD_INT 4
11005: PPUSH
11006: CALL_OW 12
11010: ARRAY
11011: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
11012: LD_ADDR_VAR 0 3
11016: PUSH
11017: LD_INT 10
11019: PUSH
11020: LD_INT 50
11022: PUSH
11023: LD_INT 90
11025: PUSH
11026: LD_INT 140
11028: PUSH
11029: EMPTY
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: PUSH
11035: LD_INT 1
11037: PPUSH
11038: LD_INT 4
11040: PPUSH
11041: CALL_OW 12
11045: ARRAY
11046: ST_TO_ADDR
// if ValidHex ( x , y ) then
11047: LD_VAR 0 2
11051: PPUSH
11052: LD_VAR 0 3
11056: PPUSH
11057: CALL_OW 488
11061: IFFALSE 11084
// begin result := [ x , y ] ;
11063: LD_ADDR_VAR 0 4
11067: PUSH
11068: LD_VAR 0 2
11072: PUSH
11073: LD_VAR 0 3
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: ST_TO_ADDR
// break ;
11082: GO 11086
// end ; end ;
11084: GO 10974
11086: POP
11087: POP
// if result then
11088: LD_VAR 0 4
11092: IFFALSE 11116
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
11094: LD_VAR 0 4
11098: PUSH
11099: LD_INT 1
11101: ARRAY
11102: PPUSH
11103: LD_VAR 0 4
11107: PUSH
11108: LD_INT 2
11110: ARRAY
11111: PPUSH
11112: CALL_OW 429
// end ;
11116: PPOPN 4
11118: END
// every 0 0$1 trigger StreamModeActive and sReset do
11119: LD_EXP 29
11123: PUSH
11124: LD_EXP 49
11128: AND
11129: IFFALSE 11141
11131: GO 11133
11133: DISABLE
// YouLost (  ) ;
11134: LD_STRING 
11136: PPUSH
11137: CALL_OW 104
11141: END
// every 0 0$1 trigger StreamModeActive and sFog do
11142: LD_EXP 29
11146: PUSH
11147: LD_EXP 48
11151: AND
11152: IFFALSE 11166
11154: GO 11156
11156: DISABLE
// FogOff ( your_side ) ;
11157: LD_OWVAR 2
11161: PPUSH
11162: CALL_OW 344
11166: END
// every 0 0$1 trigger StreamModeActive and sSun do
11167: LD_EXP 29
11171: PUSH
11172: LD_EXP 50
11176: AND
11177: IFFALSE 11205
11179: GO 11181
11181: DISABLE
// begin solar_recharge_percent := 0 ;
11182: LD_ADDR_OWVAR 79
11186: PUSH
11187: LD_INT 0
11189: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11190: LD_INT 10500
11192: PPUSH
11193: CALL_OW 67
// solar_recharge_percent := 100 ;
11197: LD_ADDR_OWVAR 79
11201: PUSH
11202: LD_INT 100
11204: ST_TO_ADDR
// end ;
11205: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
11206: LD_EXP 29
11210: PUSH
11211: LD_EXP 51
11215: AND
11216: IFFALSE 11371
11218: GO 11220
11220: DISABLE
11221: LD_INT 0
11223: PPUSH
11224: PPUSH
// begin for i := 1 to 6 do
11225: LD_ADDR_VAR 0 1
11229: PUSH
11230: DOUBLE
11231: LD_INT 1
11233: DEC
11234: ST_TO_ADDR
11235: LD_INT 6
11237: PUSH
11238: FOR_TO
11239: IFFALSE 11369
// begin uc_nation := nation_nature ;
11241: LD_ADDR_OWVAR 21
11245: PUSH
11246: LD_INT 0
11248: ST_TO_ADDR
// uc_side := 0 ;
11249: LD_ADDR_OWVAR 20
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
11257: LD_ADDR_OWVAR 29
11261: PUSH
11262: LD_INT 12
11264: PUSH
11265: LD_INT 12
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: ST_TO_ADDR
// hc_agressivity := 20 ;
11272: LD_ADDR_OWVAR 35
11276: PUSH
11277: LD_INT 20
11279: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
11280: LD_ADDR_OWVAR 28
11284: PUSH
11285: LD_INT 17
11287: ST_TO_ADDR
// hc_gallery :=  ;
11288: LD_ADDR_OWVAR 33
11292: PUSH
11293: LD_STRING 
11295: ST_TO_ADDR
// hc_name :=  ;
11296: LD_ADDR_OWVAR 26
11300: PUSH
11301: LD_STRING 
11303: ST_TO_ADDR
// un := CreateHuman ;
11304: LD_ADDR_VAR 0 2
11308: PUSH
11309: CALL_OW 44
11313: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
11314: LD_VAR 0 2
11318: PPUSH
11319: LD_INT 1
11321: PPUSH
11322: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
11326: LD_VAR 0 2
11330: PPUSH
11331: LD_INT 3
11333: PUSH
11334: LD_INT 22
11336: PUSH
11337: LD_INT 0
11339: PUSH
11340: EMPTY
11341: LIST
11342: LIST
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PPUSH
11348: CALL_OW 69
11352: PPUSH
11353: LD_VAR 0 2
11357: PPUSH
11358: CALL_OW 74
11362: PPUSH
11363: CALL_OW 115
// end ;
11367: GO 11238
11369: POP
11370: POP
// end ;
11371: PPOPN 2
11373: END
// every 0 0$1 trigger StreamModeActive and sTroll do
11374: LD_EXP 29
11378: PUSH
11379: LD_EXP 52
11383: AND
11384: IFFALSE 11410
11386: GO 11388
11388: DISABLE
// begin ToLua ( displayTroll(); ) ;
11389: LD_STRING displayTroll();
11391: PPUSH
11392: CALL_OW 559
// wait ( 3 3$00 ) ;
11396: LD_INT 6300
11398: PPUSH
11399: CALL_OW 67
// ToLua ( hideTroll(); ) ;
11403: LD_STRING hideTroll();
11405: PPUSH
11406: CALL_OW 559
// end ;
11410: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
11411: LD_EXP 29
11415: PUSH
11416: LD_EXP 53
11420: AND
11421: IFFALSE 11484
11423: GO 11425
11425: DISABLE
11426: LD_INT 0
11428: PPUSH
// begin p := 0 ;
11429: LD_ADDR_VAR 0 1
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
// repeat game_speed := 1 ;
11437: LD_ADDR_OWVAR 65
11441: PUSH
11442: LD_INT 1
11444: ST_TO_ADDR
// wait ( 0 0$1 ) ;
11445: LD_INT 35
11447: PPUSH
11448: CALL_OW 67
// p := p + 1 ;
11452: LD_ADDR_VAR 0 1
11456: PUSH
11457: LD_VAR 0 1
11461: PUSH
11462: LD_INT 1
11464: PLUS
11465: ST_TO_ADDR
// until p >= 60 ;
11466: LD_VAR 0 1
11470: PUSH
11471: LD_INT 60
11473: GREATEREQUAL
11474: IFFALSE 11437
// game_speed := 4 ;
11476: LD_ADDR_OWVAR 65
11480: PUSH
11481: LD_INT 4
11483: ST_TO_ADDR
// end ;
11484: PPOPN 1
11486: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
11487: LD_EXP 29
11491: PUSH
11492: LD_EXP 54
11496: AND
11497: IFFALSE 11643
11499: GO 11501
11501: DISABLE
11502: LD_INT 0
11504: PPUSH
11505: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11506: LD_ADDR_VAR 0 1
11510: PUSH
11511: LD_INT 22
11513: PUSH
11514: LD_OWVAR 2
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: PUSH
11523: LD_INT 2
11525: PUSH
11526: LD_INT 30
11528: PUSH
11529: LD_INT 0
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: LD_INT 30
11538: PUSH
11539: LD_INT 1
11541: PUSH
11542: EMPTY
11543: LIST
11544: LIST
11545: PUSH
11546: EMPTY
11547: LIST
11548: LIST
11549: LIST
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: PPUSH
11555: CALL_OW 69
11559: ST_TO_ADDR
// if not depot then
11560: LD_VAR 0 1
11564: NOT
11565: IFFALSE 11569
// exit ;
11567: GO 11643
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
11569: LD_ADDR_VAR 0 2
11573: PUSH
11574: LD_VAR 0 1
11578: PUSH
11579: LD_INT 1
11581: PPUSH
11582: LD_VAR 0 1
11586: PPUSH
11587: CALL_OW 12
11591: ARRAY
11592: PPUSH
11593: CALL_OW 274
11597: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
11598: LD_VAR 0 2
11602: PPUSH
11603: LD_INT 1
11605: PPUSH
11606: LD_INT 0
11608: PPUSH
11609: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
11613: LD_VAR 0 2
11617: PPUSH
11618: LD_INT 2
11620: PPUSH
11621: LD_INT 0
11623: PPUSH
11624: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
11628: LD_VAR 0 2
11632: PPUSH
11633: LD_INT 3
11635: PPUSH
11636: LD_INT 0
11638: PPUSH
11639: CALL_OW 277
// end ;
11643: PPOPN 2
11645: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
11646: LD_EXP 29
11650: PUSH
11651: LD_EXP 55
11655: AND
11656: IFFALSE 11753
11658: GO 11660
11660: DISABLE
11661: LD_INT 0
11663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11664: LD_ADDR_VAR 0 1
11668: PUSH
11669: LD_INT 22
11671: PUSH
11672: LD_OWVAR 2
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: PUSH
11681: LD_INT 21
11683: PUSH
11684: LD_INT 1
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 3
11693: PUSH
11694: LD_INT 23
11696: PUSH
11697: LD_INT 0
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PUSH
11704: EMPTY
11705: LIST
11706: LIST
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: LIST
11712: PPUSH
11713: CALL_OW 69
11717: ST_TO_ADDR
// if not tmp then
11718: LD_VAR 0 1
11722: NOT
11723: IFFALSE 11727
// exit ;
11725: GO 11753
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
11727: LD_VAR 0 1
11731: PUSH
11732: LD_INT 1
11734: PPUSH
11735: LD_VAR 0 1
11739: PPUSH
11740: CALL_OW 12
11744: ARRAY
11745: PPUSH
11746: LD_INT 200
11748: PPUSH
11749: CALL_OW 234
// end ;
11753: PPOPN 1
11755: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
11756: LD_EXP 29
11760: PUSH
11761: LD_EXP 56
11765: AND
11766: IFFALSE 11845
11768: GO 11770
11770: DISABLE
11771: LD_INT 0
11773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
11774: LD_ADDR_VAR 0 1
11778: PUSH
11779: LD_INT 22
11781: PUSH
11782: LD_OWVAR 2
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: LD_INT 21
11793: PUSH
11794: LD_INT 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PPUSH
11805: CALL_OW 69
11809: ST_TO_ADDR
// if not tmp then
11810: LD_VAR 0 1
11814: NOT
11815: IFFALSE 11819
// exit ;
11817: GO 11845
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
11819: LD_VAR 0 1
11823: PUSH
11824: LD_INT 1
11826: PPUSH
11827: LD_VAR 0 1
11831: PPUSH
11832: CALL_OW 12
11836: ARRAY
11837: PPUSH
11838: LD_INT 10
11840: PPUSH
11841: CALL_OW 234
// end ;
11845: PPOPN 1
11847: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
11848: LD_EXP 29
11852: PUSH
11853: LD_EXP 57
11857: AND
11858: IFFALSE 11957
11860: GO 11862
11862: DISABLE
11863: LD_INT 0
11865: PPUSH
11866: PPUSH
// begin enable ;
11867: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
11868: LD_ADDR_VAR 0 1
11872: PUSH
11873: LD_INT 22
11875: PUSH
11876: LD_OWVAR 2
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: PUSH
11885: LD_INT 61
11887: PUSH
11888: EMPTY
11889: LIST
11890: PUSH
11891: LD_INT 33
11893: PUSH
11894: LD_INT 2
11896: PUSH
11897: EMPTY
11898: LIST
11899: LIST
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: LIST
11905: PPUSH
11906: CALL_OW 69
11910: ST_TO_ADDR
// if not tmp then
11911: LD_VAR 0 1
11915: NOT
11916: IFFALSE 11920
// exit ;
11918: GO 11957
// for i in tmp do
11920: LD_ADDR_VAR 0 2
11924: PUSH
11925: LD_VAR 0 1
11929: PUSH
11930: FOR_IN
11931: IFFALSE 11955
// if IsControledBy ( i ) then
11933: LD_VAR 0 2
11937: PPUSH
11938: CALL_OW 312
11942: IFFALSE 11953
// ComUnlink ( i ) ;
11944: LD_VAR 0 2
11948: PPUSH
11949: CALL_OW 136
11953: GO 11930
11955: POP
11956: POP
// end ; end_of_file
11957: PPOPN 2
11959: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
11960: LD_INT 0
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11966: LD_VAR 0 1
11970: PPUSH
11971: CALL_OW 264
11975: PUSH
11976: LD_EXP 28
11980: EQUAL
11981: IFFALSE 12053
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11983: LD_INT 68
11985: PPUSH
11986: LD_VAR 0 1
11990: PPUSH
11991: CALL_OW 255
11995: PPUSH
11996: CALL_OW 321
12000: PUSH
12001: LD_INT 2
12003: EQUAL
12004: IFFALSE 12016
// eff := 70 else
12006: LD_ADDR_VAR 0 6
12010: PUSH
12011: LD_INT 70
12013: ST_TO_ADDR
12014: GO 12024
// eff := 30 ;
12016: LD_ADDR_VAR 0 6
12020: PUSH
12021: LD_INT 30
12023: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
12024: LD_VAR 0 1
12028: PPUSH
12029: CALL_OW 250
12033: PPUSH
12034: LD_VAR 0 1
12038: PPUSH
12039: CALL_OW 251
12043: PPUSH
12044: LD_VAR 0 6
12048: PPUSH
12049: CALL_OW 495
// end ; end ;
12053: LD_VAR 0 4
12057: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
12058: LD_INT 0
12060: PPUSH
12061: PPUSH
12062: PPUSH
12063: PPUSH
12064: PPUSH
12065: PPUSH
// if cmd = 124 then
12066: LD_VAR 0 1
12070: PUSH
12071: LD_INT 124
12073: EQUAL
12074: IFFALSE 12280
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
12076: LD_ADDR_VAR 0 5
12080: PUSH
12081: LD_INT 2
12083: PUSH
12084: LD_INT 34
12086: PUSH
12087: LD_INT 53
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 34
12096: PUSH
12097: LD_INT 14
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: PPUSH
12109: CALL_OW 69
12113: ST_TO_ADDR
// if not tmp then
12114: LD_VAR 0 5
12118: NOT
12119: IFFALSE 12123
// exit ;
12121: GO 12280
// for i in tmp do
12123: LD_ADDR_VAR 0 3
12127: PUSH
12128: LD_VAR 0 5
12132: PUSH
12133: FOR_IN
12134: IFFALSE 12278
// begin taskList := GetTaskList ( i ) ;
12136: LD_ADDR_VAR 0 6
12140: PUSH
12141: LD_VAR 0 3
12145: PPUSH
12146: CALL_OW 437
12150: ST_TO_ADDR
// if not taskList then
12151: LD_VAR 0 6
12155: NOT
12156: IFFALSE 12160
// continue ;
12158: GO 12133
// for j = 1 to taskList do
12160: LD_ADDR_VAR 0 4
12164: PUSH
12165: DOUBLE
12166: LD_INT 1
12168: DEC
12169: ST_TO_ADDR
12170: LD_VAR 0 6
12174: PUSH
12175: FOR_TO
12176: IFFALSE 12274
// if taskList [ j ] [ 1 ] = | then
12178: LD_VAR 0 6
12182: PUSH
12183: LD_VAR 0 4
12187: ARRAY
12188: PUSH
12189: LD_INT 1
12191: ARRAY
12192: PUSH
12193: LD_STRING |
12195: EQUAL
12196: IFFALSE 12272
// begin _taskList := Delete ( taskList , 1 ) ;
12198: LD_ADDR_VAR 0 7
12202: PUSH
12203: LD_VAR 0 6
12207: PPUSH
12208: LD_INT 1
12210: PPUSH
12211: CALL_OW 3
12215: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
12216: LD_VAR 0 3
12220: PPUSH
12221: LD_VAR 0 7
12225: PPUSH
12226: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
12230: LD_VAR 0 3
12234: PPUSH
12235: LD_VAR 0 6
12239: PUSH
12240: LD_VAR 0 4
12244: ARRAY
12245: PUSH
12246: LD_INT 2
12248: ARRAY
12249: PPUSH
12250: LD_VAR 0 6
12254: PUSH
12255: LD_VAR 0 4
12259: ARRAY
12260: PUSH
12261: LD_INT 3
12263: ARRAY
12264: PPUSH
12265: LD_INT 8
12267: PPUSH
12268: CALL 12285 0 4
// end ;
12272: GO 12175
12274: POP
12275: POP
// end ;
12276: GO 12133
12278: POP
12279: POP
// end ; end ;
12280: LD_VAR 0 2
12284: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
12285: LD_INT 0
12287: PPUSH
12288: PPUSH
12289: PPUSH
12290: PPUSH
12291: PPUSH
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
12296: LD_VAR 0 1
12300: NOT
12301: PUSH
12302: LD_VAR 0 2
12306: PPUSH
12307: LD_VAR 0 3
12311: PPUSH
12312: CALL_OW 488
12316: NOT
12317: OR
12318: PUSH
12319: LD_VAR 0 4
12323: NOT
12324: OR
12325: IFFALSE 12329
// exit ;
12327: GO 12669
// list := [ ] ;
12329: LD_ADDR_VAR 0 13
12333: PUSH
12334: EMPTY
12335: ST_TO_ADDR
// if x - r < 0 then
12336: LD_VAR 0 2
12340: PUSH
12341: LD_VAR 0 4
12345: MINUS
12346: PUSH
12347: LD_INT 0
12349: LESS
12350: IFFALSE 12362
// min_x := 0 else
12352: LD_ADDR_VAR 0 7
12356: PUSH
12357: LD_INT 0
12359: ST_TO_ADDR
12360: GO 12378
// min_x := x - r ;
12362: LD_ADDR_VAR 0 7
12366: PUSH
12367: LD_VAR 0 2
12371: PUSH
12372: LD_VAR 0 4
12376: MINUS
12377: ST_TO_ADDR
// if y - r < 0 then
12378: LD_VAR 0 3
12382: PUSH
12383: LD_VAR 0 4
12387: MINUS
12388: PUSH
12389: LD_INT 0
12391: LESS
12392: IFFALSE 12404
// min_y := 0 else
12394: LD_ADDR_VAR 0 8
12398: PUSH
12399: LD_INT 0
12401: ST_TO_ADDR
12402: GO 12420
// min_y := y - r ;
12404: LD_ADDR_VAR 0 8
12408: PUSH
12409: LD_VAR 0 3
12413: PUSH
12414: LD_VAR 0 4
12418: MINUS
12419: ST_TO_ADDR
// max_x := x + r ;
12420: LD_ADDR_VAR 0 9
12424: PUSH
12425: LD_VAR 0 2
12429: PUSH
12430: LD_VAR 0 4
12434: PLUS
12435: ST_TO_ADDR
// max_y := y + r ;
12436: LD_ADDR_VAR 0 10
12440: PUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 4
12450: PLUS
12451: ST_TO_ADDR
// for _x = min_x to max_x do
12452: LD_ADDR_VAR 0 11
12456: PUSH
12457: DOUBLE
12458: LD_VAR 0 7
12462: DEC
12463: ST_TO_ADDR
12464: LD_VAR 0 9
12468: PUSH
12469: FOR_TO
12470: IFFALSE 12587
// for _y = min_y to max_y do
12472: LD_ADDR_VAR 0 12
12476: PUSH
12477: DOUBLE
12478: LD_VAR 0 8
12482: DEC
12483: ST_TO_ADDR
12484: LD_VAR 0 10
12488: PUSH
12489: FOR_TO
12490: IFFALSE 12583
// begin if not ValidHex ( _x , _y ) then
12492: LD_VAR 0 11
12496: PPUSH
12497: LD_VAR 0 12
12501: PPUSH
12502: CALL_OW 488
12506: NOT
12507: IFFALSE 12511
// continue ;
12509: GO 12489
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
12511: LD_VAR 0 11
12515: PPUSH
12516: LD_VAR 0 12
12520: PPUSH
12521: CALL_OW 351
12525: PUSH
12526: LD_VAR 0 11
12530: PPUSH
12531: LD_VAR 0 12
12535: PPUSH
12536: CALL_OW 554
12540: AND
12541: IFFALSE 12581
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12543: LD_ADDR_VAR 0 13
12547: PUSH
12548: LD_VAR 0 13
12552: PPUSH
12553: LD_VAR 0 13
12557: PUSH
12558: LD_INT 1
12560: PLUS
12561: PPUSH
12562: LD_VAR 0 11
12566: PUSH
12567: LD_VAR 0 12
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PPUSH
12576: CALL_OW 2
12580: ST_TO_ADDR
// end ;
12581: GO 12489
12583: POP
12584: POP
12585: GO 12469
12587: POP
12588: POP
// if not list then
12589: LD_VAR 0 13
12593: NOT
12594: IFFALSE 12598
// exit ;
12596: GO 12669
// for i in list do
12598: LD_ADDR_VAR 0 6
12602: PUSH
12603: LD_VAR 0 13
12607: PUSH
12608: FOR_IN
12609: IFFALSE 12667
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12611: LD_VAR 0 1
12615: PPUSH
12616: LD_STRING M
12618: PUSH
12619: LD_VAR 0 6
12623: PUSH
12624: LD_INT 1
12626: ARRAY
12627: PUSH
12628: LD_VAR 0 6
12632: PUSH
12633: LD_INT 2
12635: ARRAY
12636: PUSH
12637: LD_INT 0
12639: PUSH
12640: LD_INT 0
12642: PUSH
12643: LD_INT 0
12645: PUSH
12646: LD_INT 0
12648: PUSH
12649: EMPTY
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: PPUSH
12661: CALL_OW 447
12665: GO 12608
12667: POP
12668: POP
// end ;
12669: LD_VAR 0 5
12673: RET
