// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 76 0 0
// PrepareNature ( 4 , 3 , 3 , 5 , 1 , 0 , 0 , natureArea , 0 ) ;
  15: LD_INT 4
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 3
  23: PPUSH
  24: LD_INT 5
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 0
  32: PPUSH
  33: LD_INT 0
  35: PPUSH
  36: LD_INT 6
  38: PPUSH
  39: LD_INT 0
  41: PPUSH
  42: CALL 1029 0 9
// PrepareAmerican ;
  46: CALL 5335 0 0
// PrepareAlliance ;
  50: CALL 226 0 0
// Action ;
  54: CALL 2178 0 0
// SaveForQuickRestart ;
  58: CALL_OW 22
// if debug then
  62: LD_EXP 1
  66: IFFALSE 75
// FogOff ( 7 ) ;
  68: LD_INT 7
  70: PPUSH
  71: CALL_OW 344
// end ;
  75: END
// export debug , activeBombTest , contaminateTime , bombExploded , enteredContaminatedArea , artifactPickedUp , planCaptured , seenBase , stevensTimer , canEnd , missionTime , killCounter , bunkerCounter ; function Init ; begin
  76: LD_INT 0
  78: PPUSH
// debug := false ;
  79: LD_ADDR_EXP 1
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// activeBombTest := false ;
  87: LD_ADDR_EXP 2
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// bombExploded := false ;
  95: LD_ADDR_EXP 4
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// contaminateTime := 0 0$00 ;
 103: LD_ADDR_EXP 3
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// enteredContaminatedArea := false ;
 111: LD_ADDR_EXP 5
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// artifactPickedUp := false ;
 119: LD_ADDR_EXP 6
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// planCaptured := false ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// seenBase := false ;
 135: LD_ADDR_EXP 8
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// stevensTimer := [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] ;
 143: LD_ADDR_EXP 9
 147: PUSH
 148: LD_INT 42000
 150: PUSH
 151: LD_INT 33600
 153: PUSH
 154: LD_INT 29400
 156: PUSH
 157: EMPTY
 158: LIST
 159: LIST
 160: LIST
 161: PUSH
 162: LD_OWVAR 67
 166: ARRAY
 167: ST_TO_ADDR
// canEnd := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// missionTime := 0 0$00 ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// killCounter := 0 ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// bunkerCounter := 0 ;
 192: LD_ADDR_EXP 13
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// end ;
 200: LD_VAR 0 1
 204: RET
// every 0 0$1 trigger bunkerCounter >= 3 do
 205: LD_EXP 13
 209: PUSH
 210: LD_INT 3
 212: GREATEREQUAL
 213: IFFALSE 225
 215: GO 217
 217: DISABLE
// SetAchievement ( ACH_ONEMANARMY ) ; end_of_file
 218: LD_STRING ACH_ONEMANARMY
 220: PPUSH
 221: CALL_OW 543
 225: END
// export JMM , Burlak , Joan , RuSci ; export function PrepareAlliance ; var tmp , i , JMMVeh , BurlakVeh , VarJMMVeh , VarBurlakVeh ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
 230: PPUSH
 231: PPUSH
 232: PPUSH
 233: PPUSH
 234: PPUSH
// uc_side := 7 ;
 235: LD_ADDR_OWVAR 20
 239: PUSH
 240: LD_INT 7
 242: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
 243: LD_ADDR_EXP 14
 247: PUSH
 248: LD_STRING JMM
 250: PPUSH
 251: LD_EXP 1
 255: NOT
 256: PPUSH
 257: LD_STRING 14a_
 259: PPUSH
 260: CALL 908 0 3
 264: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
 265: LD_ADDR_EXP 15
 269: PUSH
 270: LD_STRING Burlak
 272: PPUSH
 273: LD_EXP 1
 277: NOT
 278: PPUSH
 279: LD_STRING 14a_
 281: PPUSH
 282: CALL 908 0 3
 286: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
 287: LD_ADDR_EXP 16
 291: PUSH
 292: LD_STRING Joan
 294: PPUSH
 295: LD_EXP 1
 299: NOT
 300: PPUSH
 301: LD_STRING 13a_
 303: PPUSH
 304: CALL 908 0 3
 308: ST_TO_ADDR
// if not Joan then
 309: LD_EXP 16
 313: NOT
 314: IFFALSE 447
// begin tmp := CreateCharacterSet ( 13a_others ) ;
 316: LD_ADDR_VAR 0 2
 320: PUSH
 321: LD_STRING 13a_others
 323: PPUSH
 324: CALL_OW 31
 328: ST_TO_ADDR
// if tmp then
 329: LD_VAR 0 2
 333: IFFALSE 409
// begin for i in tmp do
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_VAR 0 2
 344: PUSH
 345: FOR_IN
 346: IFFALSE 407
// if GetClass ( i ) = 4 and GetSex ( i ) = sex_male and GetNation ( i ) = nation_russian then
 348: LD_VAR 0 3
 352: PPUSH
 353: CALL_OW 257
 357: PUSH
 358: LD_INT 4
 360: EQUAL
 361: PUSH
 362: LD_VAR 0 3
 366: PPUSH
 367: CALL_OW 258
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: PUSH
 377: LD_VAR 0 3
 381: PPUSH
 382: CALL_OW 248
 386: PUSH
 387: LD_INT 3
 389: EQUAL
 390: AND
 391: IFFALSE 405
// begin RuSci := i ;
 393: LD_ADDR_EXP 17
 397: PUSH
 398: LD_VAR 0 3
 402: ST_TO_ADDR
// break ;
 403: GO 407
// end ;
 405: GO 345
 407: POP
 408: POP
// end ; if not RuSci then
 409: LD_EXP 17
 413: NOT
 414: IFFALSE 447
// begin uc_nation := 3 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 3
 423: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 10 ) ;
 424: LD_INT 1
 426: PPUSH
 427: LD_INT 4
 429: PPUSH
 430: LD_INT 10
 432: PPUSH
 433: CALL_OW 380
// RuSci := CreateHuman ;
 437: LD_ADDR_EXP 17
 441: PUSH
 442: CALL_OW 44
 446: ST_TO_ADDR
// end ; end ; VarJMMVeh := LoadVariable ( 14a_JMMVeh , [ us_morphling , engine_siberite , control_manual , us_rocket_launcher , 0 , 1 ] ) ;
 447: LD_ADDR_VAR 0 6
 451: PUSH
 452: LD_STRING 14a_JMMVeh
 454: PPUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 1
 463: PUSH
 464: LD_INT 7
 466: PUSH
 467: LD_INT 0
 469: PUSH
 470: LD_INT 1
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: LIST
 480: PPUSH
 481: CALL_OW 30
 485: ST_TO_ADDR
// VarBurlakVeh := LoadVariable ( 14a_BurlakVeh , [ ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 0 , 3 ] ) ;
 486: LD_ADDR_VAR 0 7
 490: PUSH
 491: LD_STRING 14a_BurlakVeh
 493: PPUSH
 494: LD_INT 22
 496: PUSH
 497: LD_INT 3
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 51
 505: PUSH
 506: LD_INT 0
 508: PUSH
 509: LD_INT 3
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: PPUSH
 520: CALL_OW 30
 524: ST_TO_ADDR
// uc_direction := 4 ;
 525: LD_ADDR_OWVAR 24
 529: PUSH
 530: LD_INT 4
 532: ST_TO_ADDR
// uc_nation := VarJMMVeh [ 6 ] ;
 533: LD_ADDR_OWVAR 21
 537: PUSH
 538: LD_VAR 0 6
 542: PUSH
 543: LD_INT 6
 545: ARRAY
 546: ST_TO_ADDR
// PrepareVehicle ( VarJMMVeh [ 1 ] , VarJMMVeh [ 2 ] , VarJMMVeh [ 3 ] , VarJMMVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 547: LD_VAR 0 6
 551: PUSH
 552: LD_INT 1
 554: ARRAY
 555: PPUSH
 556: LD_VAR 0 6
 560: PUSH
 561: LD_INT 2
 563: ARRAY
 564: PPUSH
 565: LD_VAR 0 6
 569: PUSH
 570: LD_INT 3
 572: ARRAY
 573: PPUSH
 574: LD_VAR 0 6
 578: PUSH
 579: LD_INT 4
 581: ARRAY
 582: PPUSH
 583: LD_INT 60
 585: PPUSH
 586: LD_INT 80
 588: PPUSH
 589: CALL_OW 12
 593: PPUSH
 594: CALL 971 0 5
// JMMVeh := CreateVehicle ;
 598: LD_ADDR_VAR 0 4
 602: PUSH
 603: CALL_OW 45
 607: ST_TO_ADDR
// PlaceUnitInArea ( JMMVeh , startArea , false ) ;
 608: LD_VAR 0 4
 612: PPUSH
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL 1633 0 3
// if VarJMMVeh [ 5 ] <> 0 then
 623: LD_VAR 0 6
 627: PUSH
 628: LD_INT 5
 630: ARRAY
 631: PUSH
 632: LD_INT 0
 634: NONEQUAL
 635: IFFALSE 655
// SetMark ( JMMVeh , VarJMMVeh [ 5 ] ) ;
 637: LD_VAR 0 4
 641: PPUSH
 642: LD_VAR 0 6
 646: PUSH
 647: LD_INT 5
 649: ARRAY
 650: PPUSH
 651: CALL_OW 242
// PlaceHumanInUnit ( JMM , JMMVeh ) ;
 655: LD_EXP 14
 659: PPUSH
 660: LD_VAR 0 4
 664: PPUSH
 665: CALL_OW 52
// uc_nation := VarBurlakVeh [ 6 ] ;
 669: LD_ADDR_OWVAR 21
 673: PUSH
 674: LD_VAR 0 7
 678: PUSH
 679: LD_INT 6
 681: ARRAY
 682: ST_TO_ADDR
// PrepareVehicle ( VarBurlakVeh [ 1 ] , VarBurlakVeh [ 2 ] , VarBurlakVeh [ 3 ] , VarBurlakVeh [ 4 ] , rand ( 60 , 80 ) ) ;
 683: LD_VAR 0 7
 687: PUSH
 688: LD_INT 1
 690: ARRAY
 691: PPUSH
 692: LD_VAR 0 7
 696: PUSH
 697: LD_INT 2
 699: ARRAY
 700: PPUSH
 701: LD_VAR 0 7
 705: PUSH
 706: LD_INT 3
 708: ARRAY
 709: PPUSH
 710: LD_VAR 0 7
 714: PUSH
 715: LD_INT 4
 717: ARRAY
 718: PPUSH
 719: LD_INT 60
 721: PPUSH
 722: LD_INT 80
 724: PPUSH
 725: CALL_OW 12
 729: PPUSH
 730: CALL 971 0 5
// BurlakVeh := CreateVehicle ;
 734: LD_ADDR_VAR 0 5
 738: PUSH
 739: CALL_OW 45
 743: ST_TO_ADDR
// if not PlaceUnitInArea ( BurlakVeh , startArea , false ) then
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL 1633 0 3
 759: NOT
 760: IFFALSE 780
// PlaceUnitXY ( BurlakVeh , 233 , 85 , false ) ;
 762: LD_VAR 0 5
 766: PPUSH
 767: LD_INT 233
 769: PPUSH
 770: LD_INT 85
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 48
// if VarBurlakVeh [ 5 ] <> 0 then
 780: LD_VAR 0 7
 784: PUSH
 785: LD_INT 5
 787: ARRAY
 788: PUSH
 789: LD_INT 0
 791: NONEQUAL
 792: IFFALSE 812
// SetMark ( BurlakVeh , VarBurlakVeh [ 5 ] ) ;
 794: LD_VAR 0 5
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 5
 806: ARRAY
 807: PPUSH
 808: CALL_OW 242
// PlaceHumanInUnit ( Burlak , BurlakVeh ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_VAR 0 5
 821: PPUSH
 822: CALL_OW 52
// tmp := [ [ 178 , 91 ] , [ 137 , 83 ] , [ 157 , 75 ] ] [ Difficulty ] ;
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: LD_INT 178
 833: PUSH
 834: LD_INT 91
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 137
 843: PUSH
 844: LD_INT 83
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: PUSH
 851: LD_INT 157
 853: PUSH
 854: LD_INT 75
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: PUSH
 866: LD_OWVAR 67
 870: ARRAY
 871: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 4 , tmp [ 1 ] , tmp [ 2 ] , false ) ;
 872: LD_INT 4
 874: PPUSH
 875: LD_INT 4
 877: PPUSH
 878: LD_VAR 0 2
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 2
 894: ARRAY
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 58
// end ; end_of_file
 903: LD_VAR 0 1
 907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 908: LD_INT 0
 910: PPUSH
 911: PPUSH
// if exist_mode then
 912: LD_VAR 0 2
 916: IFFALSE 941
// unit := CreateCharacter ( prefix & ident ) else
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_VAR 0 3
 927: PUSH
 928: LD_VAR 0 1
 932: STR
 933: PPUSH
 934: CALL_OW 34
 938: ST_TO_ADDR
 939: GO 956
// unit := NewCharacter ( ident ) ;
 941: LD_ADDR_VAR 0 5
 945: PUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 25
 955: ST_TO_ADDR
// result := unit ;
 956: LD_ADDR_VAR 0 4
 960: PUSH
 961: LD_VAR 0 5
 965: ST_TO_ADDR
// end ;
 966: LD_VAR 0 4
 970: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
 971: LD_INT 0
 973: PPUSH
// vc_chassis := chassis ;
 974: LD_ADDR_OWVAR 37
 978: PUSH
 979: LD_VAR 0 1
 983: ST_TO_ADDR
// vc_engine := engine ;
 984: LD_ADDR_OWVAR 39
 988: PUSH
 989: LD_VAR 0 2
 993: ST_TO_ADDR
// vc_control := control ;
 994: LD_ADDR_OWVAR 38
 998: PUSH
 999: LD_VAR 0 3
1003: ST_TO_ADDR
// vc_weapon := weapon ;
1004: LD_ADDR_OWVAR 40
1008: PUSH
1009: LD_VAR 0 4
1013: ST_TO_ADDR
// vc_fuel_battery := fuel ;
1014: LD_ADDR_OWVAR 41
1018: PUSH
1019: LD_VAR 0 5
1023: ST_TO_ADDR
// end ;
1024: LD_VAR 0 6
1028: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
1029: LD_INT 0
1031: PPUSH
1032: PPUSH
1033: PPUSH
// uc_side = 0 ;
1034: LD_ADDR_OWVAR 20
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// uc_nation = 0 ;
1042: LD_ADDR_OWVAR 21
1046: PUSH
1047: LD_INT 0
1049: ST_TO_ADDR
// InitHc ;
1050: CALL_OW 19
// InitVc ;
1054: CALL_OW 20
// if mastodonts then
1058: LD_VAR 0 6
1062: IFFALSE 1129
// for i = 1 to mastodonts do
1064: LD_ADDR_VAR 0 11
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_VAR 0 6
1078: PUSH
1079: FOR_TO
1080: IFFALSE 1127
// begin vc_chassis := 31 ;
1082: LD_ADDR_OWVAR 37
1086: PUSH
1087: LD_INT 31
1089: ST_TO_ADDR
// vc_control := control_rider ;
1090: LD_ADDR_OWVAR 38
1094: PUSH
1095: LD_INT 4
1097: ST_TO_ADDR
// animal := CreateVehicle ;
1098: LD_ADDR_VAR 0 12
1102: PUSH
1103: CALL_OW 45
1107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1108: LD_VAR 0 12
1112: PPUSH
1113: LD_VAR 0 8
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL 1633 0 3
// end ;
1125: GO 1079
1127: POP
1128: POP
// if horses then
1129: LD_VAR 0 5
1133: IFFALSE 1200
// for i = 1 to horses do
1135: LD_ADDR_VAR 0 11
1139: PUSH
1140: DOUBLE
1141: LD_INT 1
1143: DEC
1144: ST_TO_ADDR
1145: LD_VAR 0 5
1149: PUSH
1150: FOR_TO
1151: IFFALSE 1198
// begin hc_class := 21 ;
1153: LD_ADDR_OWVAR 28
1157: PUSH
1158: LD_INT 21
1160: ST_TO_ADDR
// hc_gallery :=  ;
1161: LD_ADDR_OWVAR 33
1165: PUSH
1166: LD_STRING 
1168: ST_TO_ADDR
// animal := CreateHuman ;
1169: LD_ADDR_VAR 0 12
1173: PUSH
1174: CALL_OW 44
1178: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1179: LD_VAR 0 12
1183: PPUSH
1184: LD_VAR 0 8
1188: PPUSH
1189: LD_INT 0
1191: PPUSH
1192: CALL 1633 0 3
// end ;
1196: GO 1150
1198: POP
1199: POP
// if birds then
1200: LD_VAR 0 1
1204: IFFALSE 1271
// for i = 1 to birds do
1206: LD_ADDR_VAR 0 11
1210: PUSH
1211: DOUBLE
1212: LD_INT 1
1214: DEC
1215: ST_TO_ADDR
1216: LD_VAR 0 1
1220: PUSH
1221: FOR_TO
1222: IFFALSE 1269
// begin hc_class = 18 ;
1224: LD_ADDR_OWVAR 28
1228: PUSH
1229: LD_INT 18
1231: ST_TO_ADDR
// hc_gallery =  ;
1232: LD_ADDR_OWVAR 33
1236: PUSH
1237: LD_STRING 
1239: ST_TO_ADDR
// animal := CreateHuman ;
1240: LD_ADDR_VAR 0 12
1244: PUSH
1245: CALL_OW 44
1249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1250: LD_VAR 0 12
1254: PPUSH
1255: LD_VAR 0 8
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL 1633 0 3
// end ;
1267: GO 1221
1269: POP
1270: POP
// if tigers then
1271: LD_VAR 0 2
1275: IFFALSE 1359
// for i = 1 to tigers do
1277: LD_ADDR_VAR 0 11
1281: PUSH
1282: DOUBLE
1283: LD_INT 1
1285: DEC
1286: ST_TO_ADDR
1287: LD_VAR 0 2
1291: PUSH
1292: FOR_TO
1293: IFFALSE 1357
// begin hc_class = class_tiger ;
1295: LD_ADDR_OWVAR 28
1299: PUSH
1300: LD_INT 14
1302: ST_TO_ADDR
// hc_gallery =  ;
1303: LD_ADDR_OWVAR 33
1307: PUSH
1308: LD_STRING 
1310: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
1311: LD_ADDR_OWVAR 35
1315: PUSH
1316: LD_INT 7
1318: NEG
1319: PPUSH
1320: LD_INT 7
1322: PPUSH
1323: CALL_OW 12
1327: ST_TO_ADDR
// animal := CreateHuman ;
1328: LD_ADDR_VAR 0 12
1332: PUSH
1333: CALL_OW 44
1337: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1338: LD_VAR 0 12
1342: PPUSH
1343: LD_VAR 0 8
1347: PPUSH
1348: LD_INT 0
1350: PPUSH
1351: CALL 1633 0 3
// end ;
1355: GO 1292
1357: POP
1358: POP
// if apemans then
1359: LD_VAR 0 3
1363: IFFALSE 1486
// for i = 1 to apemans do
1365: LD_ADDR_VAR 0 11
1369: PUSH
1370: DOUBLE
1371: LD_INT 1
1373: DEC
1374: ST_TO_ADDR
1375: LD_VAR 0 3
1379: PUSH
1380: FOR_TO
1381: IFFALSE 1484
// begin hc_class = class_apeman ;
1383: LD_ADDR_OWVAR 28
1387: PUSH
1388: LD_INT 12
1390: ST_TO_ADDR
// hc_gallery =  ;
1391: LD_ADDR_OWVAR 33
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
1399: LD_ADDR_OWVAR 35
1403: PUSH
1404: LD_INT 5
1406: NEG
1407: PPUSH
1408: LD_INT 5
1410: PPUSH
1411: CALL_OW 12
1415: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
1416: LD_ADDR_OWVAR 31
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_INT 3
1426: PPUSH
1427: CALL_OW 12
1431: PUSH
1432: LD_INT 1
1434: PPUSH
1435: LD_INT 3
1437: PPUSH
1438: CALL_OW 12
1442: PUSH
1443: LD_INT 0
1445: PUSH
1446: LD_INT 0
1448: PUSH
1449: EMPTY
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: ST_TO_ADDR
// animal := CreateHuman ;
1455: LD_ADDR_VAR 0 12
1459: PUSH
1460: CALL_OW 44
1464: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1465: LD_VAR 0 12
1469: PPUSH
1470: LD_VAR 0 8
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL 1633 0 3
// end ;
1482: GO 1380
1484: POP
1485: POP
// if enchidnas then
1486: LD_VAR 0 4
1490: IFFALSE 1557
// for i = 1 to enchidnas do
1492: LD_ADDR_VAR 0 11
1496: PUSH
1497: DOUBLE
1498: LD_INT 1
1500: DEC
1501: ST_TO_ADDR
1502: LD_VAR 0 4
1506: PUSH
1507: FOR_TO
1508: IFFALSE 1555
// begin hc_class = 13 ;
1510: LD_ADDR_OWVAR 28
1514: PUSH
1515: LD_INT 13
1517: ST_TO_ADDR
// hc_gallery =  ;
1518: LD_ADDR_OWVAR 33
1522: PUSH
1523: LD_STRING 
1525: ST_TO_ADDR
// animal := CreateHuman ;
1526: LD_ADDR_VAR 0 12
1530: PUSH
1531: CALL_OW 44
1535: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
1536: LD_VAR 0 12
1540: PPUSH
1541: LD_VAR 0 8
1545: PPUSH
1546: LD_INT 0
1548: PPUSH
1549: CALL 1633 0 3
// end ;
1553: GO 1507
1555: POP
1556: POP
// if fishes then
1557: LD_VAR 0 7
1561: IFFALSE 1628
// for i = 1 to fishes do
1563: LD_ADDR_VAR 0 11
1567: PUSH
1568: DOUBLE
1569: LD_INT 1
1571: DEC
1572: ST_TO_ADDR
1573: LD_VAR 0 7
1577: PUSH
1578: FOR_TO
1579: IFFALSE 1626
// begin hc_class = 20 ;
1581: LD_ADDR_OWVAR 28
1585: PUSH
1586: LD_INT 20
1588: ST_TO_ADDR
// hc_gallery =  ;
1589: LD_ADDR_OWVAR 33
1593: PUSH
1594: LD_STRING 
1596: ST_TO_ADDR
// animal := CreateHuman ;
1597: LD_ADDR_VAR 0 12
1601: PUSH
1602: CALL_OW 44
1606: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
1607: LD_VAR 0 12
1611: PPUSH
1612: LD_VAR 0 9
1616: PPUSH
1617: LD_INT 0
1619: PPUSH
1620: CALL 1633 0 3
// end ;
1624: GO 1578
1626: POP
1627: POP
// end ;
1628: LD_VAR 0 10
1632: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
1633: LD_INT 0
1635: PPUSH
1636: PPUSH
1637: PPUSH
1638: PPUSH
// if not unit or not area then
1639: LD_VAR 0 1
1643: NOT
1644: PUSH
1645: LD_VAR 0 2
1649: NOT
1650: OR
1651: IFFALSE 1655
// exit ;
1653: GO 1819
// tmp := AreaToList ( area , i ) ;
1655: LD_ADDR_VAR 0 6
1659: PUSH
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_VAR 0 5
1669: PPUSH
1670: CALL_OW 517
1674: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: DOUBLE
1681: LD_INT 1
1683: DEC
1684: ST_TO_ADDR
1685: LD_VAR 0 6
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: PUSH
1694: FOR_TO
1695: IFFALSE 1817
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
1697: LD_ADDR_VAR 0 7
1701: PUSH
1702: LD_VAR 0 6
1706: PUSH
1707: LD_INT 1
1709: ARRAY
1710: PUSH
1711: LD_VAR 0 5
1715: ARRAY
1716: PUSH
1717: LD_VAR 0 6
1721: PUSH
1722: LD_INT 2
1724: ARRAY
1725: PUSH
1726: LD_VAR 0 5
1730: ARRAY
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
1736: LD_VAR 0 7
1740: PUSH
1741: LD_INT 1
1743: ARRAY
1744: PPUSH
1745: LD_VAR 0 7
1749: PUSH
1750: LD_INT 2
1752: ARRAY
1753: PPUSH
1754: CALL_OW 428
1758: PUSH
1759: LD_INT 0
1761: EQUAL
1762: IFFALSE 1815
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
1764: LD_VAR 0 1
1768: PPUSH
1769: LD_VAR 0 7
1773: PUSH
1774: LD_INT 1
1776: ARRAY
1777: PPUSH
1778: LD_VAR 0 7
1782: PUSH
1783: LD_INT 2
1785: ARRAY
1786: PPUSH
1787: LD_VAR 0 3
1791: PPUSH
1792: CALL_OW 48
// result := IsPlaced ( unit ) ;
1796: LD_ADDR_VAR 0 4
1800: PUSH
1801: LD_VAR 0 1
1805: PPUSH
1806: CALL_OW 305
1810: ST_TO_ADDR
// exit ;
1811: POP
1812: POP
1813: GO 1819
// end ; end ;
1815: GO 1694
1817: POP
1818: POP
// end ;
1819: LD_VAR 0 4
1823: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
1824: LD_INT 0
1826: PPUSH
1827: PPUSH
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
1832: LD_VAR 0 1
1836: NOT
1837: PUSH
1838: LD_VAR 0 1
1842: PPUSH
1843: CALL_OW 263
1847: PUSH
1848: LD_INT 2
1850: EQUAL
1851: NOT
1852: OR
1853: IFFALSE 1857
// exit ;
1855: GO 2173
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
1857: LD_ADDR_VAR 0 6
1861: PUSH
1862: LD_INT 22
1864: PUSH
1865: LD_VAR 0 1
1869: PPUSH
1870: CALL_OW 255
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 30
1884: PUSH
1885: LD_INT 36
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 34
1894: PUSH
1895: LD_INT 31
1897: PUSH
1898: EMPTY
1899: LIST
1900: LIST
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: PPUSH
1911: CALL_OW 69
1915: ST_TO_ADDR
// if not tmp then
1916: LD_VAR 0 6
1920: NOT
1921: IFFALSE 1925
// exit ;
1923: GO 2173
// result := [ ] ;
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: EMPTY
1931: ST_TO_ADDR
// for i in tmp do
1932: LD_ADDR_VAR 0 3
1936: PUSH
1937: LD_VAR 0 6
1941: PUSH
1942: FOR_IN
1943: IFFALSE 2014
// begin t := UnitsInside ( i ) ;
1945: LD_ADDR_VAR 0 4
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: CALL_OW 313
1959: ST_TO_ADDR
// if t then
1960: LD_VAR 0 4
1964: IFFALSE 2012
// for j in t do
1966: LD_ADDR_VAR 0 7
1970: PUSH
1971: LD_VAR 0 4
1975: PUSH
1976: FOR_IN
1977: IFFALSE 2010
// result := Insert ( result , result + 1 , j ) ;
1979: LD_ADDR_VAR 0 2
1983: PUSH
1984: LD_VAR 0 2
1988: PPUSH
1989: LD_VAR 0 2
1993: PUSH
1994: LD_INT 1
1996: PLUS
1997: PPUSH
1998: LD_VAR 0 7
2002: PPUSH
2003: CALL_OW 2
2007: ST_TO_ADDR
2008: GO 1976
2010: POP
2011: POP
// end ;
2012: GO 1942
2014: POP
2015: POP
// if not result then
2016: LD_VAR 0 2
2020: NOT
2021: IFFALSE 2025
// exit ;
2023: GO 2173
// mech := result [ 1 ] ;
2025: LD_ADDR_VAR 0 5
2029: PUSH
2030: LD_VAR 0 2
2034: PUSH
2035: LD_INT 1
2037: ARRAY
2038: ST_TO_ADDR
// if result > 1 then
2039: LD_VAR 0 2
2043: PUSH
2044: LD_INT 1
2046: GREATER
2047: IFFALSE 2159
// for i = 2 to result do
2049: LD_ADDR_VAR 0 3
2053: PUSH
2054: DOUBLE
2055: LD_INT 2
2057: DEC
2058: ST_TO_ADDR
2059: LD_VAR 0 2
2063: PUSH
2064: FOR_TO
2065: IFFALSE 2157
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
2067: LD_ADDR_VAR 0 4
2071: PUSH
2072: LD_VAR 0 2
2076: PUSH
2077: LD_VAR 0 3
2081: ARRAY
2082: PPUSH
2083: LD_INT 3
2085: PPUSH
2086: CALL_OW 259
2090: PUSH
2091: LD_VAR 0 2
2095: PUSH
2096: LD_VAR 0 3
2100: ARRAY
2101: PPUSH
2102: CALL_OW 432
2106: MINUS
2107: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
2108: LD_VAR 0 4
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_INT 3
2120: PPUSH
2121: CALL_OW 259
2125: PUSH
2126: LD_VAR 0 5
2130: PPUSH
2131: CALL_OW 432
2135: MINUS
2136: GREATEREQUAL
2137: IFFALSE 2155
// mech := result [ i ] ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 2
2148: PUSH
2149: LD_VAR 0 3
2153: ARRAY
2154: ST_TO_ADDR
// end ;
2155: GO 2064
2157: POP
2158: POP
// ComLinkTo ( vehicle , mech ) ;
2159: LD_VAR 0 1
2163: PPUSH
2164: LD_VAR 0 5
2168: PPUSH
2169: CALL_OW 135
// end ; end_of_file
2173: LD_VAR 0 2
2177: RET
// export function Action ; begin
2178: LD_INT 0
2180: PPUSH
// InGameOn ;
2181: CALL_OW 8
// CenterNowOnXY ( 221 , 80 ) ;
2185: LD_INT 221
2187: PPUSH
2188: LD_INT 80
2190: PPUSH
2191: CALL_OW 86
// ComMoveXY ( [ JMM , Burlak ] , 217 , 79 ) ;
2195: LD_EXP 14
2199: PUSH
2200: LD_EXP 15
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: LD_INT 217
2211: PPUSH
2212: LD_INT 79
2214: PPUSH
2215: CALL_OW 111
// wait ( 0 0$7 ) ;
2219: LD_INT 245
2221: PPUSH
2222: CALL_OW 67
// ComExitVehicle ( [ JMM , Burlak ] ) ;
2226: LD_EXP 14
2230: PUSH
2231: LD_EXP 15
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 121
// Say ( Burlak , D2-Bur-1 ) ;
2244: LD_EXP 15
2248: PPUSH
2249: LD_STRING D2-Bur-1
2251: PPUSH
2252: CALL_OW 88
// Say ( JMM , D2-JMM-1 ) ;
2256: LD_EXP 14
2260: PPUSH
2261: LD_STRING D2-JMM-1
2263: PPUSH
2264: CALL_OW 88
// wait ( 0 0$0.5 ) ;
2268: LD_INT 18
2270: PPUSH
2271: CALL_OW 67
// ComTurnUnit ( Burlak , JMM ) ;
2275: LD_EXP 15
2279: PPUSH
2280: LD_EXP 14
2284: PPUSH
2285: CALL_OW 119
// Say ( Burlak , D2-Bur-2 ) ;
2289: LD_EXP 15
2293: PPUSH
2294: LD_STRING D2-Bur-2
2296: PPUSH
2297: CALL_OW 88
// ComEnterUnit ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , Burlak ) ) ;
2301: LD_EXP 15
2305: PPUSH
2306: LD_INT 21
2308: PUSH
2309: LD_INT 2
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: PPUSH
2321: LD_EXP 15
2325: PPUSH
2326: CALL_OW 74
2330: PPUSH
2331: CALL_OW 120
// ComEnterUnit ( JMM , NearestUnitToUnit ( FilterAllUnits ( [ f_type , unit_vehicle ] ) , JMM ) ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_INT 21
2342: PUSH
2343: LD_INT 2
2345: PUSH
2346: EMPTY
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL_OW 69
2354: PPUSH
2355: LD_EXP 14
2359: PPUSH
2360: CALL_OW 74
2364: PPUSH
2365: CALL_OW 120
// wait ( 0 0$1 ) ;
2369: LD_INT 35
2371: PPUSH
2372: CALL_OW 67
// InGameOff ;
2376: CALL_OW 9
// ChangeMissionObjectives ( MArtPickup ) ;
2380: LD_STRING MArtPickup
2382: PPUSH
2383: CALL_OW 337
// end ;
2387: LD_VAR 0 1
2391: RET
// every 0 0$1 trigger UnitFilter ( guards , [ f_see , 7 ] ) do
2392: LD_EXP 22
2396: PPUSH
2397: LD_INT 101
2399: PUSH
2400: LD_INT 7
2402: PUSH
2403: EMPTY
2404: LIST
2405: LIST
2406: PPUSH
2407: CALL_OW 72
2411: IFFALSE 2440
2413: GO 2415
2415: DISABLE
// begin Say ( Burlak , D3-Bur-1 ) ;
2416: LD_EXP 15
2420: PPUSH
2421: LD_STRING D3-Bur-1
2423: PPUSH
2424: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2428: LD_EXP 14
2432: PPUSH
2433: LD_STRING D3-JMM-1
2435: PPUSH
2436: CALL_OW 88
// end ;
2440: END
// every 0 0$2 trigger FilterUnitsInArea ( usTestBase , [ f_side , 7 ] ) do
2441: LD_INT 5
2443: PPUSH
2444: LD_INT 22
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 70
2458: IFFALSE 2789
2460: GO 2462
2462: DISABLE
// begin wait ( 0 0$3 ) ;
2463: LD_INT 105
2465: PPUSH
2466: CALL_OW 67
// DialogueOn ;
2470: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2474: LD_EXP 14
2478: PPUSH
2479: CALL_OW 87
// Say ( JMM , D3a-JMM-1 ) ;
2483: LD_EXP 14
2487: PPUSH
2488: LD_STRING D3a-JMM-1
2490: PPUSH
2491: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
2495: LD_EXP 15
2499: PPUSH
2500: LD_STRING D3a-Bur-1
2502: PPUSH
2503: CALL_OW 88
// Say ( JMM , D3a-JMM-2 ) ;
2507: LD_EXP 14
2511: PPUSH
2512: LD_STRING D3a-JMM-2
2514: PPUSH
2515: CALL_OW 88
// if Joan then
2519: LD_EXP 16
2523: IFFALSE 2539
// SayRadio ( Joan , D3a-Joan-2 ) else
2525: LD_EXP 16
2529: PPUSH
2530: LD_STRING D3a-Joan-2
2532: PPUSH
2533: CALL_OW 94
2537: GO 2551
// SayRadio ( RuSci , D3a-RSci1-2 ) ;
2539: LD_EXP 17
2543: PPUSH
2544: LD_STRING D3a-RSci1-2
2546: PPUSH
2547: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
2551: LD_EXP 18
2555: PPUSH
2556: LD_STRING D3a-Huck-2
2558: PPUSH
2559: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
2563: LD_EXP 19
2567: PPUSH
2568: LD_STRING D3a-Pow-2
2570: PPUSH
2571: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
2575: LD_EXP 18
2579: PPUSH
2580: LD_STRING D3a-Huck-3
2582: PPUSH
2583: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-3 ) ;
2587: LD_EXP 19
2591: PPUSH
2592: LD_STRING D3a-Pow-3
2594: PPUSH
2595: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-4 ) ;
2599: LD_EXP 18
2603: PPUSH
2604: LD_STRING D3a-Huck-4
2606: PPUSH
2607: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
2611: LD_EXP 14
2615: PPUSH
2616: LD_STRING D3a-JMM-4
2618: PPUSH
2619: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
2623: LD_EXP 15
2627: PPUSH
2628: LD_STRING D3a-Bur-4
2630: PPUSH
2631: CALL_OW 88
// if Joan then
2635: LD_EXP 16
2639: IFFALSE 2655
// SayRadio ( Joan , D3a-Joan-4 ) else
2641: LD_EXP 16
2645: PPUSH
2646: LD_STRING D3a-Joan-4
2648: PPUSH
2649: CALL_OW 94
2653: GO 2667
// SayRadio ( RuSci , D3a-RSci1-4 ) ;
2655: LD_EXP 17
2659: PPUSH
2660: LD_STRING D3a-RSci1-4
2662: PPUSH
2663: CALL_OW 94
// PlaceSeeing ( 133 , 43 , 7 , - 10 ) ;
2667: LD_INT 133
2669: PPUSH
2670: LD_INT 43
2672: PPUSH
2673: LD_INT 7
2675: PPUSH
2676: LD_INT 10
2678: NEG
2679: PPUSH
2680: CALL_OW 330
// RemoveSeeing ( 133 , 43 , 7 ) ;
2684: LD_INT 133
2686: PPUSH
2687: LD_INT 43
2689: PPUSH
2690: LD_INT 7
2692: PPUSH
2693: CALL_OW 331
// CenterNowOnXY ( 133 , 43 ) ;
2697: LD_INT 133
2699: PPUSH
2700: LD_INT 43
2702: PPUSH
2703: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
2707: LD_INT 10
2709: PPUSH
2710: CALL_OW 68
// Say ( JMM , D3a-JMM-5 ) ;
2714: LD_EXP 14
2718: PPUSH
2719: LD_STRING D3a-JMM-5
2721: PPUSH
2722: CALL_OW 88
// Say ( Burlak , D3a-Bur-5 ) ;
2726: LD_EXP 15
2730: PPUSH
2731: LD_STRING D3a-Bur-5
2733: PPUSH
2734: CALL_OW 88
// DialogueOff ;
2738: CALL_OW 7
// seenBase := true ;
2742: LD_ADDR_EXP 8
2746: PUSH
2747: LD_INT 1
2749: ST_TO_ADDR
// wait ( [ 0 0$15 , 0 0$12 , 0 0$9 ] [ Difficulty ] ) ;
2750: LD_INT 525
2752: PUSH
2753: LD_INT 420
2755: PUSH
2756: LD_INT 315
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 67
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2774: LD_EXP 21
2778: PPUSH
2779: LD_INT 142
2781: PPUSH
2782: LD_INT 52
2784: PPUSH
2785: CALL_OW 116
// end ;
2789: END
// every 5 5$00 trigger not seenBase and not bombExploded do
2790: LD_EXP 8
2794: NOT
2795: PUSH
2796: LD_EXP 4
2800: NOT
2801: AND
2802: IFFALSE 2822
2804: GO 2806
2806: DISABLE
// ComAttackPlace ( sibBomb , 142 , 52 ) ;
2807: LD_EXP 21
2811: PPUSH
2812: LD_INT 142
2814: PPUSH
2815: LD_INT 52
2817: PPUSH
2818: CALL_OW 116
2822: END
// export function OnBombExploded ( bomb , x , y ) ; var art ; begin
2823: LD_INT 0
2825: PPUSH
2826: PPUSH
// contaminateTime := tick ;
2827: LD_ADDR_EXP 3
2831: PUSH
2832: LD_OWVAR 1
2836: ST_TO_ADDR
// wait ( 0 0$5 ) ;
2837: LD_INT 175
2839: PPUSH
2840: CALL_OW 67
// art := FindArtifact ( 4 ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_INT 4
2851: PPUSH
2852: CALL_OW 469
2856: ST_TO_ADDR
// if art then
2857: LD_VAR 0 5
2861: IFFALSE 2900
// if art [ 1 ] = 157 and art [ 2 ] = 75 then
2863: LD_VAR 0 5
2867: PUSH
2868: LD_INT 1
2870: ARRAY
2871: PUSH
2872: LD_INT 157
2874: EQUAL
2875: PUSH
2876: LD_VAR 0 5
2880: PUSH
2881: LD_INT 2
2883: ARRAY
2884: PUSH
2885: LD_INT 75
2887: EQUAL
2888: AND
2889: IFFALSE 2900
// begin YouLost ( Artefact ) ;
2891: LD_STRING Artefact
2893: PPUSH
2894: CALL_OW 104
// exit ;
2898: GO 3052
// end ; if IsOK ( JMM ) and IsOk ( Burlak ) then
2900: LD_EXP 14
2904: PPUSH
2905: CALL_OW 302
2909: PUSH
2910: LD_EXP 15
2914: PPUSH
2915: CALL_OW 302
2919: AND
2920: IFFALSE 2997
// begin DialogueOn ;
2922: CALL_OW 6
// Say ( JMM , D6a-JMM-1 ) ;
2926: LD_EXP 14
2930: PPUSH
2931: LD_STRING D6a-JMM-1
2933: PPUSH
2934: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
2938: LD_EXP 15
2942: PPUSH
2943: LD_STRING D6a-Bur-1
2945: PPUSH
2946: CALL_OW 88
// Say ( JMM , D6c-JMM-1 ) ;
2950: LD_EXP 14
2954: PPUSH
2955: LD_STRING D6c-JMM-1
2957: PPUSH
2958: CALL_OW 88
// Say ( Burlak , D6c-Bur-1 ) ;
2962: LD_EXP 15
2966: PPUSH
2967: LD_STRING D6c-Bur-1
2969: PPUSH
2970: CALL_OW 88
// Say ( JMM , D6c-JMM-2 ) ;
2974: LD_EXP 14
2978: PPUSH
2979: LD_STRING D6c-JMM-2
2981: PPUSH
2982: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
2986: LD_STRING MBase
2988: PPUSH
2989: CALL_OW 337
// DialogueOff ;
2993: CALL_OW 7
// end ; bombExploded := true ;
2997: LD_ADDR_EXP 4
3001: PUSH
3002: LD_INT 1
3004: ST_TO_ADDR
// wait ( [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ) ;
3005: LD_INT 6300
3007: PUSH
3008: LD_INT 5250
3010: PUSH
3011: LD_INT 4200
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PPUSH
3025: CALL_OW 67
// if IsOk ( JMM ) then
3029: LD_EXP 14
3033: PPUSH
3034: CALL_OW 302
3038: IFFALSE 3052
// Say ( JMM , D8-JMM-1 ) ;
3040: LD_EXP 14
3044: PPUSH
3045: LD_STRING D8-JMM-1
3047: PPUSH
3048: CALL_OW 88
// end ;
3052: LD_VAR 0 4
3056: RET
// every 0 0$1 trigger stevensTimer and not planCaptured and bombExploded do
3057: LD_EXP 9
3061: PUSH
3062: LD_EXP 7
3066: NOT
3067: AND
3068: PUSH
3069: LD_EXP 4
3073: AND
3074: IFFALSE 3129
3076: GO 3078
3078: DISABLE
// begin enable ;
3079: ENABLE
// if FilterUnitsInArea ( usBase , [ f_side , 7 ] ) then
3080: LD_INT 9
3082: PPUSH
3083: LD_INT 22
3085: PUSH
3086: LD_INT 7
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 70
3097: IFFALSE 3115
// stevensTimer := stevensTimer - 0 0$30 else
3099: LD_ADDR_EXP 9
3103: PUSH
3104: LD_EXP 9
3108: PUSH
3109: LD_INT 1050
3111: MINUS
3112: ST_TO_ADDR
3113: GO 3129
// stevensTimer := stevensTimer - 0 0$1 ;
3115: LD_ADDR_EXP 9
3119: PUSH
3120: LD_EXP 9
3124: PUSH
3125: LD_INT 35
3127: MINUS
3128: ST_TO_ADDR
// end ;
3129: END
// every 0 0$1 trigger stevensTimer <= 0 0$00 and not planCaptured do var i , tmp ;
3130: LD_EXP 9
3134: PUSH
3135: LD_INT 0
3137: LESSEQUAL
3138: PUSH
3139: LD_EXP 7
3143: NOT
3144: AND
3145: IFFALSE 3309
3147: GO 3149
3149: DISABLE
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3154: LD_ADDR_VAR 0 2
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: LD_INT 25
3171: PUSH
3172: LD_INT 4
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 69
3187: ST_TO_ADDR
// for i in tmp do
3188: LD_ADDR_VAR 0 1
3192: PUSH
3193: LD_VAR 0 2
3197: PUSH
3198: FOR_IN
3199: IFFALSE 3252
// begin if IsInUnit ( i ) then
3201: LD_VAR 0 1
3205: PPUSH
3206: CALL_OW 310
3210: IFFALSE 3223
// ComExitBuilding ( i ) else
3212: LD_VAR 0 1
3216: PPUSH
3217: CALL_OW 122
3221: GO 3250
// if not HasTask ( i ) then
3223: LD_VAR 0 1
3227: PPUSH
3228: CALL_OW 314
3232: NOT
3233: IFFALSE 3250
// ComMoveXY ( i , 29 , 56 ) ;
3235: LD_VAR 0 1
3239: PPUSH
3240: LD_INT 29
3242: PPUSH
3243: LD_INT 56
3245: PPUSH
3246: CALL_OW 111
// end ;
3250: GO 3198
3252: POP
3253: POP
// repeat wait ( 0 0$1 ) ;
3254: LD_INT 35
3256: PPUSH
3257: CALL_OW 67
// until FilterUnitsInArea ( stevensEscapeArea , [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
3261: LD_INT 8
3263: PPUSH
3264: LD_INT 22
3266: PUSH
3267: LD_INT 1
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 25
3276: PUSH
3277: LD_INT 4
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PUSH
3284: EMPTY
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL_OW 70
3292: IFFALSE 3254
// if planCaptured then
3294: LD_EXP 7
3298: IFFALSE 3302
// exit ;
3300: GO 3309
// YouLost ( Time ) ;
3302: LD_STRING Time
3304: PPUSH
3305: CALL_OW 104
// end ;
3309: PPOPN 2
3311: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_distxy , 142 , 52 , 27 ] ] ) and contaminateTime + 6000 > tick and bombExploded do
3312: LD_INT 22
3314: PUSH
3315: LD_INT 7
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PUSH
3322: LD_INT 92
3324: PUSH
3325: LD_INT 142
3327: PUSH
3328: LD_INT 52
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: EMPTY
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 69
3348: PUSH
3349: LD_EXP 3
3353: PUSH
3354: LD_INT 6000
3356: PLUS
3357: PUSH
3358: LD_OWVAR 1
3362: GREATER
3363: AND
3364: PUSH
3365: LD_EXP 4
3369: AND
3370: IFFALSE 3425
3372: GO 3374
3374: DISABLE
// begin CenterOnUnits ( [ JMM , Burlak ] ) ;
3375: LD_EXP 14
3379: PUSH
3380: LD_EXP 15
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 85
// DialogueOn ;
3393: CALL_OW 6
// Say ( JMM , D6b-JMM-1 ) ;
3397: LD_EXP 14
3401: PPUSH
3402: LD_STRING D6b-JMM-1
3404: PPUSH
3405: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
3409: LD_EXP 15
3413: PPUSH
3414: LD_STRING D6b-Bur-1
3416: PPUSH
3417: CALL_OW 88
// DialogueOff ;
3421: CALL_OW 7
// end ;
3425: END
// every 0 0$1 trigger ( GetDistUnitXY ( Burlak , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( Burlak ) , 142 , 52 ) < 25 ) and GetLives ( Burlak ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3426: LD_EXP 15
3430: PPUSH
3431: LD_INT 142
3433: PPUSH
3434: LD_INT 52
3436: PPUSH
3437: CALL_OW 297
3441: PUSH
3442: LD_INT 25
3444: LESS
3445: PUSH
3446: LD_EXP 15
3450: PPUSH
3451: CALL_OW 310
3455: PPUSH
3456: LD_INT 142
3458: PPUSH
3459: LD_INT 52
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 25
3469: LESS
3470: OR
3471: PUSH
3472: LD_EXP 15
3476: PPUSH
3477: CALL_OW 256
3481: PUSH
3482: LD_INT 1000
3484: LESS
3485: AND
3486: PUSH
3487: LD_EXP 3
3491: PUSH
3492: LD_INT 6000
3494: PLUS
3495: PUSH
3496: LD_OWVAR 1
3500: GREATER
3501: AND
3502: PUSH
3503: LD_EXP 4
3507: AND
3508: IFFALSE 3541
3510: GO 3512
3512: DISABLE
// begin DialogueOn ;
3513: CALL_OW 6
// Say ( Burlak , D7-Bur-1 ) ;
3517: LD_EXP 15
3521: PPUSH
3522: LD_STRING D7-Bur-1
3524: PPUSH
3525: CALL_OW 88
// enteredContaminatedArea := true ;
3529: LD_ADDR_EXP 5
3533: PUSH
3534: LD_INT 1
3536: ST_TO_ADDR
// DialogueOff ;
3537: CALL_OW 7
// end ;
3541: END
// every 0 0$1 trigger ( GetDistUnitXY ( JMM , 142 , 52 ) < 25 or GetDistUnitXY ( IsInUnit ( JMM ) , 142 , 52 ) < 25 ) and GetLives ( JMM ) < 1000 and contaminateTime + 6000 > tick and bombExploded do
3542: LD_EXP 14
3546: PPUSH
3547: LD_INT 142
3549: PPUSH
3550: LD_INT 52
3552: PPUSH
3553: CALL_OW 297
3557: PUSH
3558: LD_INT 25
3560: LESS
3561: PUSH
3562: LD_EXP 14
3566: PPUSH
3567: CALL_OW 310
3571: PPUSH
3572: LD_INT 142
3574: PPUSH
3575: LD_INT 52
3577: PPUSH
3578: CALL_OW 297
3582: PUSH
3583: LD_INT 25
3585: LESS
3586: OR
3587: PUSH
3588: LD_EXP 14
3592: PPUSH
3593: CALL_OW 256
3597: PUSH
3598: LD_INT 1000
3600: LESS
3601: AND
3602: PUSH
3603: LD_EXP 3
3607: PUSH
3608: LD_INT 6000
3610: PLUS
3611: PUSH
3612: LD_OWVAR 1
3616: GREATER
3617: AND
3618: PUSH
3619: LD_EXP 4
3623: AND
3624: IFFALSE 3657
3626: GO 3628
3628: DISABLE
// begin DialogueOn ;
3629: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
3633: LD_EXP 14
3637: PPUSH
3638: LD_STRING D7-JMM-1
3640: PPUSH
3641: CALL_OW 88
// enteredContaminatedArea := true ;
3645: LD_ADDR_EXP 5
3649: PUSH
3650: LD_INT 1
3652: ST_TO_ADDR
// DialogueOff ;
3653: CALL_OW 7
// end ;
3657: END
// every 0 0$1 trigger artifactPickedUp and IsOk ( JMM ) and IsOk ( Burlak ) do
3658: LD_EXP 6
3662: PUSH
3663: LD_EXP 14
3667: PPUSH
3668: CALL_OW 302
3672: AND
3673: PUSH
3674: LD_EXP 15
3678: PPUSH
3679: CALL_OW 302
3683: AND
3684: IFFALSE 3753
3686: GO 3688
3688: DISABLE
// begin DialogueOn ;
3689: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Burlak ] ) ;
3693: LD_EXP 14
3697: PUSH
3698: LD_EXP 15
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PPUSH
3707: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3711: LD_EXP 14
3715: PPUSH
3716: LD_STRING D4-JMM-1
3718: PPUSH
3719: CALL_OW 88
// if not bombExploded then
3723: LD_EXP 4
3727: NOT
3728: IFFALSE 3742
// Say ( Burlak , D4-Bur-1 ) ;
3730: LD_EXP 15
3734: PPUSH
3735: LD_STRING D4-Bur-1
3737: PPUSH
3738: CALL_OW 88
// DialogueOff ;
3742: CALL_OW 7
// ChangeMissionObjectives ( MReturn ) ;
3746: LD_STRING MReturn
3748: PPUSH
3749: CALL_OW 337
// end ;
3753: END
// every 0 0$2 trigger not planCaptured and FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , us_dep_north , 6 ] ] ) do
3754: LD_EXP 7
3758: NOT
3759: PUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 7
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: PUSH
3770: LD_INT 91
3772: PUSH
3773: LD_INT 9
3775: PUSH
3776: LD_INT 6
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PPUSH
3788: CALL_OW 69
3792: AND
3793: IFFALSE 3870
3795: GO 3797
3797: DISABLE
// begin DialogueOn ;
3798: CALL_OW 6
// PlaceSeeing ( 55 , 11 , 7 , - 6 ) ;
3802: LD_INT 55
3804: PPUSH
3805: LD_INT 11
3807: PPUSH
3808: LD_INT 7
3810: PPUSH
3811: LD_INT 6
3813: NEG
3814: PPUSH
3815: CALL_OW 330
// RemoveSeeing ( 55 , 11 , 7 ) ;
3819: LD_INT 55
3821: PPUSH
3822: LD_INT 11
3824: PPUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL_OW 331
// Say ( Burlak , D9-Bur-1 ) ;
3832: LD_EXP 15
3836: PPUSH
3837: LD_STRING D9-Bur-1
3839: PPUSH
3840: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
3844: LD_EXP 14
3848: PPUSH
3849: LD_STRING D9-JMM-1
3851: PPUSH
3852: CALL_OW 88
// DialogueOff ;
3856: CALL_OW 7
// SetSide ( us_dep_north , 7 ) ;
3860: LD_INT 9
3862: PPUSH
3863: LD_INT 7
3865: PPUSH
3866: CALL_OW 235
// end ;
3870: END
// every 0 0$1 trigger FilterUnitsInArea ( usBase , [ f_side , 7 ] ) do
3871: LD_INT 9
3873: PPUSH
3874: LD_INT 22
3876: PUSH
3877: LD_INT 7
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PPUSH
3884: CALL_OW 70
3888: IFFALSE 3924
3890: GO 3892
3892: DISABLE
// begin wait ( 0 0$07 ) ;
3893: LD_INT 245
3895: PPUSH
3896: CALL_OW 67
// Say ( JMM , D10b-JMM-1 ) ;
3900: LD_EXP 14
3904: PPUSH
3905: LD_STRING D10b-JMM-1
3907: PPUSH
3908: CALL_OW 88
// Say ( Burlak , D10b-Bur-1 ) ;
3912: LD_EXP 15
3916: PPUSH
3917: LD_STRING D10b-Bur-1
3919: PPUSH
3920: CALL_OW 88
// end ;
3924: END
// every 0 0$1 trigger stevensTimer and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) and ( GetSide ( us_depot ) = 7 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 ) do var i ;
3925: LD_EXP 9
3929: PUSH
3930: LD_INT 22
3932: PUSH
3933: LD_INT 1
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 4
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 26
3952: PUSH
3953: LD_INT 1
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: LIST
3964: PPUSH
3965: CALL_OW 69
3969: AND
3970: PUSH
3971: LD_INT 5
3973: PPUSH
3974: CALL_OW 255
3978: PUSH
3979: LD_INT 7
3981: EQUAL
3982: PUSH
3983: LD_INT 22
3985: PUSH
3986: LD_INT 1
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 25
3995: PUSH
3996: LD_INT 1
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: CALL_OW 69
4011: PUSH
4012: LD_INT 0
4014: EQUAL
4015: OR
4016: AND
4017: IFFALSE 4606
4019: GO 4021
4021: DISABLE
4022: LD_INT 0
4024: PPUSH
// begin case Query ( QKill ) of 1 :
4025: LD_STRING QKill
4027: PPUSH
4028: CALL_OW 97
4032: PUSH
4033: LD_INT 1
4035: DOUBLE
4036: EQUAL
4037: IFTRUE 4041
4039: GO 4594
4041: POP
// begin DialogueOn ;
4042: CALL_OW 6
// Say ( JMM , D10a-JMM-1 ) ;
4046: LD_EXP 14
4050: PPUSH
4051: LD_STRING D10a-JMM-1
4053: PPUSH
4054: CALL_OW 88
// Say ( Burlak , D10a-Bur-1 ) ;
4058: LD_EXP 15
4062: PPUSH
4063: LD_STRING D10a-Bur-1
4065: PPUSH
4066: CALL_OW 88
// Say ( JMM , D10a-JMM-2 ) ;
4070: LD_EXP 14
4074: PPUSH
4075: LD_STRING D10a-JMM-2
4077: PPUSH
4078: CALL_OW 88
// if IsOk ( Stevens ) then
4082: LD_EXP 18
4086: PPUSH
4087: CALL_OW 302
4091: IFFALSE 4107
// Say ( Stevens , D10a-Huck-2 ) else
4093: LD_EXP 18
4097: PPUSH
4098: LD_STRING D10a-Huck-2
4100: PPUSH
4101: CALL_OW 88
4105: GO 4158
// Say ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) [ 1 ] , D10a-ASci1-3 ) ;
4107: LD_INT 22
4109: PUSH
4110: LD_INT 1
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: PUSH
4117: LD_INT 25
4119: PUSH
4120: LD_INT 4
4122: PUSH
4123: EMPTY
4124: LIST
4125: LIST
4126: PUSH
4127: LD_INT 26
4129: PUSH
4130: LD_INT 1
4132: PUSH
4133: EMPTY
4134: LIST
4135: LIST
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: PUSH
4147: LD_INT 1
4149: ARRAY
4150: PPUSH
4151: LD_STRING D10a-ASci1-3
4153: PPUSH
4154: CALL_OW 88
// Say ( JMM , D10a-JMM-4 ) ;
4158: LD_EXP 14
4162: PPUSH
4163: LD_STRING D10a-JMM-4
4165: PPUSH
4166: CALL_OW 88
// if IsOk ( Stevens ) then
4170: LD_EXP 18
4174: PPUSH
4175: CALL_OW 302
4179: IFFALSE 4193
// Say ( Stevens , D10a-Huck-3 ) ;
4181: LD_EXP 18
4185: PPUSH
4186: LD_STRING D10a-Huck-3
4188: PPUSH
4189: CALL_OW 88
// DialogueOff ;
4193: CALL_OW 7
// SetAttitude ( 1 , 7 , att_friend , true ) ;
4197: LD_INT 1
4199: PPUSH
4200: LD_INT 7
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: CALL_OW 80
// planCaptured := true ;
4213: LD_ADDR_EXP 7
4217: PUSH
4218: LD_INT 1
4220: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
4221: LD_STRING MEnd
4223: PPUSH
4224: CALL_OW 337
// SetAchievement ( ACH_DIPLOMACY ) ;
4228: LD_STRING ACH_DIPLOMACY
4230: PPUSH
4231: CALL_OW 543
// canEnd := true ;
4235: LD_ADDR_EXP 10
4239: PUSH
4240: LD_INT 1
4242: ST_TO_ADDR
// missionTime := tick ;
4243: LD_ADDR_EXP 11
4247: PUSH
4248: LD_OWVAR 1
4252: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) then
4260: LD_INT 22
4262: PUSH
4263: LD_INT 1
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 3
4272: PUSH
4273: LD_INT 50
4275: PUSH
4276: EMPTY
4277: LIST
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: IFFALSE 4407
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_INT 22
4300: PUSH
4301: LD_INT 1
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: LD_INT 25
4310: PUSH
4311: LD_INT 4
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PPUSH
4322: CALL_OW 69
4326: PUSH
4327: FOR_IN
4328: IFFALSE 4405
// begin if IsInUnit ( i ) then
4330: LD_VAR 0 1
4334: PPUSH
4335: CALL_OW 310
4339: IFFALSE 4352
// ComExitBuilding ( i ) else
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 122
4350: GO 4403
// ComHeal ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) , i ) ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: LD_INT 22
4359: PUSH
4360: LD_INT 1
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 3
4369: PUSH
4370: LD_INT 50
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PPUSH
4384: CALL_OW 69
4388: PPUSH
4389: LD_VAR 0 1
4393: PPUSH
4394: CALL_OW 74
4398: PPUSH
4399: CALL_OW 128
// end ;
4403: GO 4327
4405: POP
4406: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] ] ) ;
4407: LD_INT 22
4409: PUSH
4410: LD_INT 1
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 3
4419: PUSH
4420: LD_INT 50
4422: PUSH
4423: EMPTY
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: EMPTY
4431: LIST
4432: LIST
4433: PPUSH
4434: CALL_OW 69
4438: NOT
4439: IFFALSE 4253
// repeat wait ( 3 ) ;
4441: LD_INT 3
4443: PPUSH
4444: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
4448: LD_ADDR_VAR 0 1
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_INT 1
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 21
4465: PUSH
4466: LD_INT 1
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PPUSH
4477: CALL_OW 69
4481: PUSH
4482: FOR_IN
4483: IFFALSE 4559
// begin if IsInArea ( i , stevensEscapeArea ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: LD_INT 8
4492: PPUSH
4493: CALL_OW 308
4497: IFFALSE 4510
// begin RemoveUnit ( i ) ;
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 64
// continue ;
4508: GO 4482
// end ; if IsInUnit ( i ) then
4510: LD_VAR 0 1
4514: PPUSH
4515: CALL_OW 310
4519: IFFALSE 4530
// ComExitBuilding ( i ) ;
4521: LD_VAR 0 1
4525: PPUSH
4526: CALL_OW 122
// if not HasTask ( i ) then
4530: LD_VAR 0 1
4534: PPUSH
4535: CALL_OW 314
4539: NOT
4540: IFFALSE 4557
// ComMoveXY ( i , 28 , 55 ) ;
4542: LD_VAR 0 1
4546: PPUSH
4547: LD_INT 28
4549: PPUSH
4550: LD_INT 55
4552: PPUSH
4553: CALL_OW 111
// end ;
4557: GO 4482
4559: POP
4560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
4561: LD_INT 22
4563: PUSH
4564: LD_INT 1
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: LD_INT 21
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PPUSH
4585: CALL_OW 69
4589: NOT
4590: IFFALSE 4441
// end ; 2 :
4592: GO 4606
4594: LD_INT 2
4596: DOUBLE
4597: EQUAL
4598: IFTRUE 4602
4600: GO 4605
4602: POP
// ; end ;
4603: GO 4606
4605: POP
// end ;
4606: PPOPN 1
4608: END
// every 0 0$1 trigger canEnd do var un , i , tmp ;
4609: LD_EXP 10
4613: IFFALSE 4970
4615: GO 4617
4617: DISABLE
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
4622: PPUSH
// begin SetAreaMapShow ( endMissionArea , 1 ) ;
4623: LD_INT 10
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: CALL_OW 424
// if Difficulty < 2 then
4633: LD_OWVAR 67
4637: PUSH
4638: LD_INT 2
4640: LESS
4641: IFFALSE 4645
// exit ;
4643: GO 4970
// uc_side := 4 ;
4645: LD_ADDR_OWVAR 20
4649: PUSH
4650: LD_INT 4
4652: ST_TO_ADDR
// uc_nation := 1 ;
4653: LD_ADDR_OWVAR 21
4657: PUSH
4658: LD_INT 1
4660: ST_TO_ADDR
// InitHc ;
4661: CALL_OW 19
// tmp := [ ] ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: EMPTY
4671: ST_TO_ADDR
// PrepareHuman ( false , class_sniper , 10 ) ;
4672: LD_INT 0
4674: PPUSH
4675: LD_INT 5
4677: PPUSH
4678: LD_INT 10
4680: PPUSH
4681: CALL_OW 380
// un := CreateHuman ;
4685: LD_ADDR_VAR 0 1
4689: PUSH
4690: CALL_OW 44
4694: ST_TO_ADDR
// tmp := [ un ] ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_VAR 0 1
4704: PUSH
4705: EMPTY
4706: LIST
4707: ST_TO_ADDR
// PlaceUnitXY ( un , 226 , 86 , false ) ;
4708: LD_VAR 0 1
4712: PPUSH
4713: LD_INT 226
4715: PPUSH
4716: LD_INT 86
4718: PPUSH
4719: LD_INT 0
4721: PPUSH
4722: CALL_OW 48
// ComHold ( un ) ;
4726: LD_VAR 0 1
4730: PPUSH
4731: CALL_OW 140
// for i = 1 to 3 do
4735: LD_ADDR_VAR 0 2
4739: PUSH
4740: DOUBLE
4741: LD_INT 1
4743: DEC
4744: ST_TO_ADDR
4745: LD_INT 3
4747: PUSH
4748: FOR_TO
4749: IFFALSE 4848
// begin PrepareHuman ( false , class_soldier , 8 ) ;
4751: LD_INT 0
4753: PPUSH
4754: LD_INT 1
4756: PPUSH
4757: LD_INT 8
4759: PPUSH
4760: CALL_OW 380
// un := CreateHuman ;
4764: LD_ADDR_VAR 0 1
4768: PUSH
4769: CALL_OW 44
4773: ST_TO_ADDR
// SetDir ( un , 5 ) ;
4774: LD_VAR 0 1
4778: PPUSH
4779: LD_INT 5
4781: PPUSH
4782: CALL_OW 233
// PlaceUnitXY ( un , [ 215 , 217 , 219 ] [ i ] , 76 , false ) ;
4786: LD_VAR 0 1
4790: PPUSH
4791: LD_INT 215
4793: PUSH
4794: LD_INT 217
4796: PUSH
4797: LD_INT 219
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: LIST
4804: PUSH
4805: LD_VAR 0 2
4809: ARRAY
4810: PPUSH
4811: LD_INT 76
4813: PPUSH
4814: LD_INT 0
4816: PPUSH
4817: CALL_OW 48
// ComCrawl ( un ) ;
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 137
// tmp := tmp ^ un ;
4830: LD_ADDR_VAR 0 3
4834: PUSH
4835: LD_VAR 0 3
4839: PUSH
4840: LD_VAR 0 1
4844: ADD
4845: ST_TO_ADDR
// end ;
4846: GO 4748
4848: POP
4849: POP
// repeat wait ( 0 0$1 ) ;
4850: LD_INT 35
4852: PPUSH
4853: CALL_OW 67
// until not UnitFilter ( un , [ f_lives , 1000 ] ) ;
4857: LD_VAR 0 1
4861: PPUSH
4862: LD_INT 24
4864: PUSH
4865: LD_INT 1000
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PPUSH
4872: CALL_OW 72
4876: NOT
4877: IFFALSE 4850
// for i in tmp do
4879: LD_ADDR_VAR 0 2
4883: PUSH
4884: LD_VAR 0 3
4888: PUSH
4889: FOR_IN
4890: IFFALSE 4968
// begin wait ( 0 0$1 ) ;
4892: LD_INT 35
4894: PPUSH
4895: CALL_OW 67
// if Crawls ( i ) then
4899: LD_VAR 0 2
4903: PPUSH
4904: CALL_OW 318
4908: IFFALSE 4921
// ComWalk ( i ) else
4910: LD_VAR 0 2
4914: PPUSH
4915: CALL_OW 138
4919: GO 4966
// if GetClass ( i ) = class_sniper then
4921: LD_VAR 0 2
4925: PPUSH
4926: CALL_OW 257
4930: PUSH
4931: LD_INT 5
4933: EQUAL
4934: IFFALSE 4952
// ComAttackSoporific ( i , JMM ) else
4936: LD_VAR 0 2
4940: PPUSH
4941: LD_EXP 14
4945: PPUSH
4946: CALL_OW 166
4950: GO 4966
// ComAttackUnit ( i , JMM ) ;
4952: LD_VAR 0 2
4956: PPUSH
4957: LD_EXP 14
4961: PPUSH
4962: CALL_OW 115
// end ;
4966: GO 4889
4968: POP
4969: POP
// end ;
4970: PPOPN 3
4972: END
// every 0 0$1 trigger not planCaptured and IsDead ( us_lab ) do
4973: LD_EXP 7
4977: NOT
4978: PUSH
4979: LD_INT 1
4981: PPUSH
4982: CALL_OW 301
4986: AND
4987: IFFALSE 4999
4989: GO 4991
4991: DISABLE
// YouLost ( Lab ) ;
4992: LD_STRING Lab
4994: PPUSH
4995: CALL_OW 104
4999: END
// every 0 0$1 trigger FilterUnitsInArea ( endMissionArea , [ f_side , 7 ] ) >= 2 and FilterUnitsInArea ( endMissionArea , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) and canEnd and planCaptured and artifactPickedUp do var m1 , m2 ;
5000: LD_INT 10
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 7
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 70
5017: PUSH
5018: LD_INT 2
5020: GREATEREQUAL
5021: PUSH
5022: LD_INT 10
5024: PPUSH
5025: LD_INT 2
5027: PUSH
5028: LD_INT 34
5030: PUSH
5031: LD_INT 12
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 34
5040: PUSH
5041: LD_INT 51
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 70
5057: AND
5058: PUSH
5059: LD_EXP 10
5063: AND
5064: PUSH
5065: LD_EXP 7
5069: AND
5070: PUSH
5071: LD_EXP 6
5075: AND
5076: IFFALSE 5332
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
// begin m1 := false ;
5085: LD_ADDR_VAR 0 1
5089: PUSH
5090: LD_INT 0
5092: ST_TO_ADDR
// m2 := false ;
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: LD_INT 0
5100: ST_TO_ADDR
// if killCounter = 0 then
5101: LD_EXP 12
5105: PUSH
5106: LD_INT 0
5108: EQUAL
5109: IFFALSE 5118
// SetAchievement ( ACH_PACIFIST ) ;
5111: LD_STRING ACH_PACIFIST
5113: PPUSH
5114: CALL_OW 543
// if tick < 7 7$00 then
5118: LD_OWVAR 1
5122: PUSH
5123: LD_INT 14700
5125: LESS
5126: IFFALSE 5142
// begin wait ( 3 ) ;
5128: LD_INT 3
5130: PPUSH
5131: CALL_OW 67
// SetAchievement ( ACH_ASPEED_18 ) ;
5135: LD_STRING ACH_ASPEED_18
5137: PPUSH
5138: CALL_OW 543
// end ; AddMedal ( Explosion , 1 ) ;
5142: LD_STRING Explosion
5144: PPUSH
5145: LD_INT 1
5147: PPUSH
5148: CALL_OW 101
// if enteredContaminatedArea then
5152: LD_EXP 5
5156: IFFALSE 5178
// begin m1 := true ;
5158: LD_ADDR_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ST_TO_ADDR
// AddMedal ( BioHazard , 1 ) ;
5166: LD_STRING BioHazard
5168: PPUSH
5169: LD_INT 1
5171: PPUSH
5172: CALL_OW 101
// end else
5176: GO 5189
// AddMedal ( BioHazard , - 1 ) ;
5178: LD_STRING BioHazard
5180: PPUSH
5181: LD_INT 1
5183: NEG
5184: PPUSH
5185: CALL_OW 101
// if missionTime <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
5189: LD_EXP 11
5193: PUSH
5194: LD_INT 42000
5196: PUSH
5197: LD_INT 31500
5199: PUSH
5200: LD_INT 25200
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: LD_OWVAR 67
5212: ARRAY
5213: LESSEQUAL
5214: IFFALSE 5236
// begin m2 := true ;
5216: LD_ADDR_VAR 0 2
5220: PUSH
5221: LD_INT 1
5223: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
5224: LD_STRING Speed
5226: PPUSH
5227: LD_INT 1
5229: PPUSH
5230: CALL_OW 101
// end else
5234: GO 5247
// AddMedal ( Speed , - 1 ) ;
5236: LD_STRING Speed
5238: PPUSH
5239: LD_INT 1
5241: NEG
5242: PPUSH
5243: CALL_OW 101
// if Difficulty = 3 and m1 and m2 then
5247: LD_OWVAR 67
5251: PUSH
5252: LD_INT 3
5254: EQUAL
5255: PUSH
5256: LD_VAR 0 1
5260: AND
5261: PUSH
5262: LD_VAR 0 2
5266: AND
5267: IFFALSE 5279
// SetAchievementEX ( ACH_AMER , 18 ) ;
5269: LD_STRING ACH_AMER
5271: PPUSH
5272: LD_INT 18
5274: PPUSH
5275: CALL_OW 564
// GiveMedals ( Main ) ;
5279: LD_STRING Main
5281: PPUSH
5282: CALL_OW 102
// RewardPeople ( [ JMM , Burlak ] ) ;
5286: LD_EXP 14
5290: PUSH
5291: LD_EXP 15
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 43
// SaveCharacters ( JMM , 14a_JMM ) ;
5304: LD_EXP 14
5308: PPUSH
5309: LD_STRING 14a_JMM
5311: PPUSH
5312: CALL_OW 38
// SaveCharacters ( Burlak , 14a_Burlak ) ;
5316: LD_EXP 15
5320: PPUSH
5321: LD_STRING 14a_Burlak
5323: PPUSH
5324: CALL_OW 38
// YouWin ;
5328: CALL_OW 103
// end ; end_of_file
5332: PPOPN 2
5334: END
// export Stevens , Powell , baseGuards , sibBomb , guards , vehGuard ; export function PrepareAmerican ; var i , un , tmp ; begin
5335: LD_INT 0
5337: PPUSH
5338: PPUSH
5339: PPUSH
5340: PPUSH
// uc_side := 1 ;
5341: LD_ADDR_OWVAR 20
5345: PUSH
5346: LD_INT 1
5348: ST_TO_ADDR
// uc_nation := 1 ;
5349: LD_ADDR_OWVAR 21
5353: PUSH
5354: LD_INT 1
5356: ST_TO_ADDR
// InitHc ;
5357: CALL_OW 19
// SetResourceType ( GetBase ( us_depot2 ) , mat_cans , 500 ) ;
5361: LD_INT 34
5363: PPUSH
5364: CALL_OW 274
5368: PPUSH
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 500
5374: PPUSH
5375: CALL_OW 277
// SetResourceType ( GetBase ( us_depot2 ) , mat_siberit , 20 ) ;
5379: LD_INT 34
5381: PPUSH
5382: CALL_OW 274
5386: PPUSH
5387: LD_INT 3
5389: PPUSH
5390: LD_INT 20
5392: PPUSH
5393: CALL_OW 277
// Stevens := NewCharacter ( Stevens ) ;
5397: LD_ADDR_EXP 18
5401: PUSH
5402: LD_STRING Stevens
5404: PPUSH
5405: CALL_OW 25
5409: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
5410: LD_ADDR_EXP 19
5414: PUSH
5415: LD_STRING Powell
5417: PPUSH
5418: CALL_OW 25
5422: ST_TO_ADDR
// PlaceHumanInUnit ( Stevens , us_lab ) ;
5423: LD_EXP 18
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: CALL_OW 52
// vehGuard := [ ] ;
5435: LD_ADDR_EXP 23
5439: PUSH
5440: EMPTY
5441: ST_TO_ADDR
// hc_importance := 0 ;
5442: LD_ADDR_OWVAR 32
5446: PUSH
5447: LD_INT 0
5449: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_siberite , control_computer , us_siberium_rocket , 100 ) ;
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 3
5455: PPUSH
5456: LD_INT 3
5458: PPUSH
5459: LD_INT 8
5461: PPUSH
5462: LD_INT 100
5464: PPUSH
5465: CALL 971 0 5
// sibBomb := CreateVehicle ;
5469: LD_ADDR_EXP 21
5473: PUSH
5474: CALL_OW 45
5478: ST_TO_ADDR
// SetDir ( sibBomb , 1 ) ;
5479: LD_EXP 21
5483: PPUSH
5484: LD_INT 1
5486: PPUSH
5487: CALL_OW 233
// PlaceUnitXY ( sibBomb , 93 , 74 , false ) ;
5491: LD_EXP 21
5495: PPUSH
5496: LD_INT 93
5498: PPUSH
5499: LD_INT 74
5501: PPUSH
5502: LD_INT 0
5504: PPUSH
5505: CALL_OW 48
// guards := [ ] ;
5509: LD_ADDR_EXP 22
5513: PUSH
5514: EMPTY
5515: ST_TO_ADDR
// for i = 1 to 3 do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_INT 3
5528: PUSH
5529: FOR_TO
5530: IFFALSE 5622
// begin PrepareHuman ( false , class_soldier , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5532: LD_INT 0
5534: PPUSH
5535: LD_INT 1
5537: PPUSH
5538: LD_INT 8
5540: PUSH
5541: LD_INT 9
5543: PUSH
5544: LD_INT 10
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PPUSH
5558: CALL_OW 380
// un := CreateHuman ;
5562: LD_ADDR_VAR 0 3
5566: PUSH
5567: CALL_OW 44
5571: ST_TO_ADDR
// PlaceUnitArea ( un , [ patrol1 , patrol2 , patrol3 ] [ i ] , false ) ;
5572: LD_VAR 0 3
5576: PPUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 4
5585: PUSH
5586: EMPTY
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_VAR 0 2
5595: ARRAY
5596: PPUSH
5597: LD_INT 0
5599: PPUSH
5600: CALL_OW 49
// guards := guards ^ un ;
5604: LD_ADDR_EXP 22
5608: PUSH
5609: LD_EXP 22
5613: PUSH
5614: LD_VAR 0 3
5618: ADD
5619: ST_TO_ADDR
// end ;
5620: GO 5529
5622: POP
5623: POP
// baseGuards := [ ] ;
5624: LD_ADDR_EXP 20
5628: PUSH
5629: EMPTY
5630: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
5631: LD_ADDR_VAR 0 2
5635: PUSH
5636: DOUBLE
5637: LD_INT 1
5639: DEC
5640: ST_TO_ADDR
5641: LD_INT 5
5643: PUSH
5644: LD_INT 6
5646: PUSH
5647: LD_INT 7
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: PUSH
5655: LD_OWVAR 67
5659: ARRAY
5660: PUSH
5661: FOR_TO
5662: IFFALSE 5808
// begin PrepareSoldier ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5664: LD_INT 0
5666: PPUSH
5667: LD_INT 8
5669: PUSH
5670: LD_INT 9
5672: PUSH
5673: LD_INT 10
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: PUSH
5681: LD_OWVAR 67
5685: ARRAY
5686: PPUSH
5687: CALL_OW 381
// un := CreateHuman ;
5691: LD_ADDR_VAR 0 3
5695: PUSH
5696: CALL_OW 44
5700: ST_TO_ADDR
// baseGuards := baseGuards ^ un ;
5701: LD_ADDR_EXP 20
5705: PUSH
5706: LD_EXP 20
5710: PUSH
5711: LD_VAR 0 3
5715: ADD
5716: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
5717: LD_ADDR_VAR 0 4
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 58
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 30
5740: PUSH
5741: LD_INT 32
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 69
5757: ST_TO_ADDR
// if tmp then
5758: LD_VAR 0 4
5762: IFFALSE 5794
// PlaceHumanInUnit ( un , tmp [ rand ( 1 , tmp ) ] ) else
5764: LD_VAR 0 3
5768: PPUSH
5769: LD_VAR 0 4
5773: PUSH
5774: LD_INT 1
5776: PPUSH
5777: LD_VAR 0 4
5781: PPUSH
5782: CALL_OW 12
5786: ARRAY
5787: PPUSH
5788: CALL_OW 52
5792: GO 5806
// PlaceHumanInUnit ( un , us_bar ) ;
5794: LD_VAR 0 3
5798: PPUSH
5799: LD_INT 51
5801: PPUSH
5802: CALL_OW 52
// end ;
5806: GO 5661
5808: POP
5809: POP
// if Difficulty > 1 then
5810: LD_OWVAR 67
5814: PUSH
5815: LD_INT 1
5817: GREATER
5818: IFFALSE 5862
// begin PrepareHuman ( false , class_sniper , [ 9 , 10 ] [ Difficulty - 1 ] ) ;
5820: LD_INT 0
5822: PPUSH
5823: LD_INT 5
5825: PPUSH
5826: LD_INT 9
5828: PUSH
5829: LD_INT 10
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PUSH
5836: LD_OWVAR 67
5840: PUSH
5841: LD_INT 1
5843: MINUS
5844: ARRAY
5845: PPUSH
5846: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_bun1 ) ;
5850: CALL_OW 44
5854: PPUSH
5855: LD_INT 80
5857: PPUSH
5858: CALL_OW 52
// end ; for i = 1 to 3 do
5862: LD_ADDR_VAR 0 2
5866: PUSH
5867: DOUBLE
5868: LD_INT 1
5870: DEC
5871: ST_TO_ADDR
5872: LD_INT 3
5874: PUSH
5875: FOR_TO
5876: IFFALSE 5902
// begin PrepareMechanic ( false , 9 ) ;
5878: LD_INT 0
5880: PPUSH
5881: LD_INT 9
5883: PPUSH
5884: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
5888: CALL_OW 44
5892: PPUSH
5893: LD_INT 43
5895: PPUSH
5896: CALL_OW 52
// end ;
5900: GO 5875
5902: POP
5903: POP
// PlaceHumanInUnit ( CreateHuman , us_ct ) ;
5904: CALL_OW 44
5908: PPUSH
5909: LD_INT 49
5911: PPUSH
5912: CALL_OW 52
// for i = 1 to 1 + Difficulty do
5916: LD_ADDR_VAR 0 2
5920: PUSH
5921: DOUBLE
5922: LD_INT 1
5924: DEC
5925: ST_TO_ADDR
5926: LD_INT 1
5928: PUSH
5929: LD_OWVAR 67
5933: PLUS
5934: PUSH
5935: FOR_TO
5936: IFFALSE 5979
// begin PrepareEngineer ( false , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
5938: LD_INT 0
5940: PPUSH
5941: LD_INT 8
5943: PUSH
5944: LD_INT 9
5946: PUSH
5947: LD_INT 10
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: LD_OWVAR 67
5959: ARRAY
5960: PPUSH
5961: CALL_OW 382
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
5965: CALL_OW 44
5969: PPUSH
5970: LD_INT 5
5972: PPUSH
5973: CALL_OW 52
// end ;
5977: GO 5935
5979: POP
5980: POP
// for i = 1 to 3 do
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: DOUBLE
5987: LD_INT 1
5989: DEC
5990: ST_TO_ADDR
5991: LD_INT 3
5993: PUSH
5994: FOR_TO
5995: IFFALSE 6021
// begin PrepareScientist ( false , 10 ) ;
5997: LD_INT 0
5999: PPUSH
6000: LD_INT 10
6002: PPUSH
6003: CALL_OW 384
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
6007: CALL_OW 44
6011: PPUSH
6012: LD_INT 1
6014: PPUSH
6015: CALL_OW 52
// end ;
6019: GO 5994
6021: POP
6022: POP
// end ;
6023: LD_VAR 0 1
6027: RET
// every 0 0$2 trigger guards and not activeBombTest do var i , j , points ;
6028: LD_EXP 22
6032: PUSH
6033: LD_EXP 2
6037: NOT
6038: AND
6039: IFFALSE 6225
6041: GO 6043
6043: DISABLE
6044: LD_INT 0
6046: PPUSH
6047: PPUSH
6048: PPUSH
// begin enable ;
6049: ENABLE
// points := [ [ 204 , 30 ] , [ 165 , 24 ] , [ 195 , 6 ] , [ 223 , 54 ] , [ 214 , 84 ] , [ 206 , 71 ] ] ;
6050: LD_ADDR_VAR 0 3
6054: PUSH
6055: LD_INT 204
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 165
6067: PUSH
6068: LD_INT 24
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PUSH
6075: LD_INT 195
6077: PUSH
6078: LD_INT 6
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: LD_INT 223
6087: PUSH
6088: LD_INT 54
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 214
6097: PUSH
6098: LD_INT 84
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: LD_INT 206
6107: PUSH
6108: LD_INT 71
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: ST_TO_ADDR
// for i in guards do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: LD_EXP 22
6132: PUSH
6133: FOR_IN
6134: IFFALSE 6223
// begin if HasTask ( i ) then
6136: LD_VAR 0 1
6140: PPUSH
6141: CALL_OW 314
6145: IFFALSE 6151
// continue else
6147: GO 6133
6149: GO 6221
// begin j := rand ( 1 , 6 ) ;
6151: LD_ADDR_VAR 0 2
6155: PUSH
6156: LD_INT 1
6158: PPUSH
6159: LD_INT 6
6161: PPUSH
6162: CALL_OW 12
6166: ST_TO_ADDR
// if not See ( 7 , i ) then
6167: LD_INT 7
6169: PPUSH
6170: LD_VAR 0 1
6174: PPUSH
6175: CALL_OW 292
6179: NOT
6180: IFFALSE 6221
// ComAgressiveMove ( i , points [ j ] [ 1 ] , points [ j ] [ 2 ] ) ;
6182: LD_VAR 0 1
6186: PPUSH
6187: LD_VAR 0 3
6191: PUSH
6192: LD_VAR 0 2
6196: ARRAY
6197: PUSH
6198: LD_INT 1
6200: ARRAY
6201: PPUSH
6202: LD_VAR 0 3
6206: PUSH
6207: LD_VAR 0 2
6211: ARRAY
6212: PUSH
6213: LD_INT 2
6215: ARRAY
6216: PPUSH
6217: CALL_OW 114
// end ; end ;
6221: GO 6133
6223: POP
6224: POP
// end ;
6225: PPOPN 3
6227: END
// every 0 0$1 trigger vehGuard and not planCaptured do var i ;
6228: LD_EXP 23
6232: PUSH
6233: LD_EXP 7
6237: NOT
6238: AND
6239: IFFALSE 6310
6241: GO 6243
6243: DISABLE
6244: LD_INT 0
6246: PPUSH
// begin enable ;
6247: ENABLE
// for i in vehGuard do
6248: LD_ADDR_VAR 0 1
6252: PUSH
6253: LD_EXP 23
6257: PUSH
6258: FOR_IN
6259: IFFALSE 6308
// if IsOk ( vehGuard ) then
6261: LD_EXP 23
6265: PPUSH
6266: CALL_OW 302
6270: IFFALSE 6306
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) ;
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 22
6279: PUSH
6280: LD_INT 7
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 74
6301: PPUSH
6302: CALL_OW 115
6306: GO 6258
6308: POP
6309: POP
// end ;
6310: PPOPN 1
6312: END
// every 9 9$00 trigger bombExploded and IsOk ( us_fac ) and not planCaptured do
6313: LD_EXP 4
6317: PUSH
6318: LD_INT 43
6320: PPUSH
6321: CALL_OW 302
6325: AND
6326: PUSH
6327: LD_EXP 7
6331: NOT
6332: AND
6333: IFFALSE 6381
6335: GO 6337
6337: DISABLE
// begin enable ;
6338: ENABLE
// ComConstruct ( us_fac , us_morphling , engine_siberite , control_remote , [ us_rocket_launcher , us_rocket_launcher , us_laser ] [ rand ( 1 , 3 ) ] ) ;
6339: LD_INT 43
6341: PPUSH
6342: LD_INT 5
6344: PPUSH
6345: LD_INT 3
6347: PPUSH
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 7
6353: PUSH
6354: LD_INT 7
6356: PUSH
6357: LD_INT 9
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 3
6370: PPUSH
6371: CALL_OW 12
6375: ARRAY
6376: PPUSH
6377: CALL_OW 125
// end ;
6381: END
// every 1 1$45 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) and not planCaptured do var tmp , b ;
6382: LD_INT 22
6384: PUSH
6385: LD_INT 1
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 25
6394: PUSH
6395: LD_INT 5
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PUSH
6402: LD_INT 50
6404: PUSH
6405: EMPTY
6406: LIST
6407: PUSH
6408: EMPTY
6409: LIST
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: LD_EXP 7
6422: NOT
6423: AND
6424: IFFALSE 6653
6426: GO 6428
6428: DISABLE
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
// begin enable ;
6433: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_sniper ] , [ f_ok ] ] ) ;
6434: LD_ADDR_VAR 0 1
6438: PUSH
6439: LD_INT 22
6441: PUSH
6442: LD_INT 1
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 25
6451: PUSH
6452: LD_INT 5
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PUSH
6459: LD_INT 50
6461: PUSH
6462: EMPTY
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PPUSH
6470: CALL_OW 69
6474: ST_TO_ADDR
// if not tmp then
6475: LD_VAR 0 1
6479: NOT
6480: IFFALSE 6484
// exit ;
6482: GO 6653
// b := IsInUnit ( tmp [ 1 ] ) ;
6484: LD_ADDR_VAR 0 2
6488: PUSH
6489: LD_VAR 0 1
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 310
6502: ST_TO_ADDR
// if not b or HasTask ( tmp [ 1 ] ) then
6503: LD_VAR 0 2
6507: NOT
6508: PUSH
6509: LD_VAR 0 1
6513: PUSH
6514: LD_INT 1
6516: ARRAY
6517: PPUSH
6518: CALL_OW 314
6522: OR
6523: IFFALSE 6527
// exit ;
6525: GO 6653
// if b = us_bun1 then
6527: LD_VAR 0 2
6531: PUSH
6532: LD_INT 80
6534: EQUAL
6535: IFFALSE 6596
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6537: LD_VAR 0 1
6541: PUSH
6542: LD_INT 1
6544: ARRAY
6545: PPUSH
6546: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 27 , 44 ) ;
6550: LD_VAR 0 1
6554: PUSH
6555: LD_INT 1
6557: ARRAY
6558: PPUSH
6559: LD_INT 27
6561: PPUSH
6562: LD_INT 44
6564: PPUSH
6565: CALL_OW 174
// if IsOk ( us_bun2 ) then
6569: LD_INT 55
6571: PPUSH
6572: CALL_OW 302
6576: IFFALSE 6594
// AddComEnterUnit ( tmp [ 1 ] , us_bun2 ) ;
6578: LD_VAR 0 1
6582: PUSH
6583: LD_INT 1
6585: ARRAY
6586: PPUSH
6587: LD_INT 55
6589: PPUSH
6590: CALL_OW 180
// end else
6594: GO 6653
// begin ComExitBuilding ( tmp [ 1 ] ) ;
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 122
// AddComAgressiveMove ( tmp [ 1 ] , 92 , 51 ) ;
6609: LD_VAR 0 1
6613: PUSH
6614: LD_INT 1
6616: ARRAY
6617: PPUSH
6618: LD_INT 92
6620: PPUSH
6621: LD_INT 51
6623: PPUSH
6624: CALL_OW 174
// if IsOk ( us_bun1 ) then
6628: LD_INT 80
6630: PPUSH
6631: CALL_OW 302
6635: IFFALSE 6653
// AddComEnterUnit ( tmp [ 1 ] , us_bun1 ) ;
6637: LD_VAR 0 1
6641: PUSH
6642: LD_INT 1
6644: ARRAY
6645: PPUSH
6646: LD_INT 80
6648: PPUSH
6649: CALL_OW 180
// end ; end ;
6653: PPOPN 2
6655: END
// every 0 0$1 trigger not planCaptured and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , tmp , tmp2 , b ;
6656: LD_EXP 7
6660: NOT
6661: PUSH
6662: LD_INT 9
6664: PPUSH
6665: LD_INT 22
6667: PUSH
6668: LD_INT 1
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: LD_INT 21
6677: PUSH
6678: LD_INT 3
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 3
6687: PUSH
6688: LD_INT 24
6690: PUSH
6691: LD_INT 1000
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: PPUSH
6707: CALL_OW 70
6711: AND
6712: IFFALSE 7123
6714: GO 6716
6716: DISABLE
6717: LD_INT 0
6719: PPUSH
6720: PPUSH
6721: PPUSH
6722: PPUSH
// begin enable ;
6723: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
6724: LD_ADDR_VAR 0 2
6728: PUSH
6729: LD_INT 22
6731: PUSH
6732: LD_INT 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 25
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: LD_INT 1000
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: PPUSH
6764: CALL_OW 69
6768: ST_TO_ADDR
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 750 ] ] ] ) ;
6769: LD_ADDR_VAR 0 3
6773: PUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 25
6786: PUSH
6787: LD_INT 2
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 3
6796: PUSH
6797: LD_INT 24
6799: PUSH
6800: LD_INT 750
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: ST_TO_ADDR
// b := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) diff us_lab ;
6821: LD_ADDR_VAR 0 4
6825: PUSH
6826: LD_INT 9
6828: PPUSH
6829: LD_INT 22
6831: PUSH
6832: LD_INT 1
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 24
6854: PUSH
6855: LD_INT 1000
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: LIST
6870: PPUSH
6871: CALL_OW 70
6875: PUSH
6876: LD_INT 1
6878: DIFF
6879: ST_TO_ADDR
// if not tmp and not tmp2 then
6880: LD_VAR 0 2
6884: NOT
6885: PUSH
6886: LD_VAR 0 3
6890: NOT
6891: AND
6892: IFFALSE 6896
// exit ;
6894: GO 7123
// if tmp and b then
6896: LD_VAR 0 2
6900: PUSH
6901: LD_VAR 0 4
6905: AND
6906: IFFALSE 7036
// for i in tmp do
6908: LD_ADDR_VAR 0 1
6912: PUSH
6913: LD_VAR 0 2
6917: PUSH
6918: FOR_IN
6919: IFFALSE 7034
// begin if GetTag ( i ) = 1 and GetLives ( i ) < 1000 then
6921: LD_VAR 0 1
6925: PPUSH
6926: CALL_OW 110
6930: PUSH
6931: LD_INT 1
6933: EQUAL
6934: PUSH
6935: LD_VAR 0 1
6939: PPUSH
6940: CALL_OW 256
6944: PUSH
6945: LD_INT 1000
6947: LESS
6948: AND
6949: IFFALSE 6955
// continue else
6951: GO 6918
6953: GO 6982
// if GetTag ( i ) = 1 then
6955: LD_VAR 0 1
6959: PPUSH
6960: CALL_OW 110
6964: PUSH
6965: LD_INT 1
6967: EQUAL
6968: IFFALSE 6982
// SetTag ( i , 0 ) ;
6970: LD_VAR 0 1
6974: PPUSH
6975: LD_INT 0
6977: PPUSH
6978: CALL_OW 109
// if IsInUnit ( i ) then
6982: LD_VAR 0 1
6986: PPUSH
6987: CALL_OW 310
6991: IFFALSE 7002
// ComExitBuilding ( i ) ;
6993: LD_VAR 0 1
6997: PPUSH
6998: CALL_OW 122
// if not HasTask ( i ) then
7002: LD_VAR 0 1
7006: PPUSH
7007: CALL_OW 314
7011: NOT
7012: IFFALSE 7032
// AddComRepairBuilding ( i , b [ 1 ] ) ;
7014: LD_VAR 0 1
7018: PPUSH
7019: LD_VAR 0 4
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: CALL_OW 190
// end ;
7032: GO 6918
7034: POP
7035: POP
// if tmp2 then
7036: LD_VAR 0 3
7040: IFFALSE 7123
// for i in tmp2 do
7042: LD_ADDR_VAR 0 1
7046: PUSH
7047: LD_VAR 0 3
7051: PUSH
7052: FOR_IN
7053: IFFALSE 7121
// begin if not GetTag ( i ) = 1 then
7055: LD_VAR 0 1
7059: PPUSH
7060: CALL_OW 110
7064: PUSH
7065: LD_INT 1
7067: EQUAL
7068: NOT
7069: IFFALSE 7083
// SetTag ( i , 1 ) ;
7071: LD_VAR 0 1
7075: PPUSH
7076: LD_INT 1
7078: PPUSH
7079: CALL_OW 109
// if GetDistUnitXY ( i , 88 , 75 ) > 6 then
7083: LD_VAR 0 1
7087: PPUSH
7088: LD_INT 88
7090: PPUSH
7091: LD_INT 75
7093: PPUSH
7094: CALL_OW 297
7098: PUSH
7099: LD_INT 6
7101: GREATER
7102: IFFALSE 7119
// ComMoveXY ( i , 88 , 75 ) ;
7104: LD_VAR 0 1
7108: PPUSH
7109: LD_INT 88
7111: PPUSH
7112: LD_INT 75
7114: PPUSH
7115: CALL_OW 111
// end ;
7119: GO 7052
7121: POP
7122: POP
// end ;
7123: PPOPN 4
7125: END
// every 0 0$1 trigger not planCaptured and stevensTimer and FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var i , sci , tmp ;
7126: LD_EXP 7
7130: NOT
7131: PUSH
7132: LD_EXP 9
7136: AND
7137: PUSH
7138: LD_INT 9
7140: PPUSH
7141: LD_INT 22
7143: PUSH
7144: LD_INT 1
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 21
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 3
7163: PUSH
7164: LD_INT 24
7166: PUSH
7167: LD_INT 1000
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: PPUSH
7183: CALL_OW 70
7187: AND
7188: IFFALSE 7361
7190: GO 7192
7192: DISABLE
7193: LD_INT 0
7195: PPUSH
7196: PPUSH
7197: PPUSH
// begin enable ;
7198: ENABLE
// sci := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) ;
7199: LD_ADDR_VAR 0 2
7203: PUSH
7204: LD_INT 22
7206: PUSH
7207: LD_INT 1
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 25
7216: PUSH
7217: LD_INT 4
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: PPUSH
7228: CALL_OW 69
7232: ST_TO_ADDR
// tmp := FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_INT 9
7240: PPUSH
7241: LD_INT 22
7243: PUSH
7244: LD_INT 1
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: LD_INT 21
7253: PUSH
7254: LD_INT 1
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: LD_INT 3
7263: PUSH
7264: LD_INT 24
7266: PUSH
7267: LD_INT 1000
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: PPUSH
7283: CALL_OW 70
7287: ST_TO_ADDR
// if not sci or not tmp then
7288: LD_VAR 0 2
7292: NOT
7293: PUSH
7294: LD_VAR 0 3
7298: NOT
7299: OR
7300: IFFALSE 7304
// exit ;
7302: GO 7361
// for i in sci do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: LD_VAR 0 2
7313: PUSH
7314: FOR_IN
7315: IFFALSE 7359
// if IsInUnit ( i ) then
7317: LD_VAR 0 1
7321: PPUSH
7322: CALL_OW 310
7326: IFFALSE 7339
// ComExitBuilding ( i ) else
7328: LD_VAR 0 1
7332: PPUSH
7333: CALL_OW 122
7337: GO 7357
// ComHeal ( i , tmp [ 1 ] ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_VAR 0 3
7348: PUSH
7349: LD_INT 1
7351: ARRAY
7352: PPUSH
7353: CALL_OW 128
7357: GO 7314
7359: POP
7360: POP
// end ;
7361: PPOPN 3
7363: END
// every 0 0$1 trigger not planCaptured and stevensTimer and IsOk ( us_lab ) and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do var i ;
7364: LD_EXP 7
7368: NOT
7369: PUSH
7370: LD_EXP 9
7374: AND
7375: PUSH
7376: LD_INT 1
7378: PPUSH
7379: CALL_OW 302
7383: AND
7384: PUSH
7385: LD_INT 9
7387: PPUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 21
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: LD_INT 24
7413: PUSH
7414: LD_INT 1000
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 70
7434: NOT
7435: AND
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 25
7449: PUSH
7450: LD_INT 4
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 56
7459: PUSH
7460: EMPTY
7461: LIST
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: AND
7473: IFFALSE 7566
7475: GO 7477
7477: DISABLE
7478: LD_INT 0
7480: PPUSH
// begin enable ;
7481: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] , [ f_outside ] ] ) do
7482: LD_ADDR_VAR 0 1
7486: PUSH
7487: LD_INT 22
7489: PUSH
7490: LD_INT 1
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 4
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 56
7509: PUSH
7510: EMPTY
7511: LIST
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: PPUSH
7518: CALL_OW 69
7522: PUSH
7523: FOR_IN
7524: IFFALSE 7564
// if not GetTag ( i ) and not HasTask ( i ) then
7526: LD_VAR 0 1
7530: PPUSH
7531: CALL_OW 110
7535: NOT
7536: PUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 314
7546: NOT
7547: AND
7548: IFFALSE 7562
// ComEnterUnit ( i , us_lab ) ;
7550: LD_VAR 0 1
7554: PPUSH
7555: LD_INT 1
7557: PPUSH
7558: CALL_OW 120
7562: GO 7523
7564: POP
7565: POP
// end ;
7566: PPOPN 1
7568: END
// every 0 0$1 trigger not planCaptured and not FilterUnitsInArea ( usBase , [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do var i ;
7569: LD_EXP 7
7573: NOT
7574: PUSH
7575: LD_INT 9
7577: PPUSH
7578: LD_INT 22
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: LD_INT 21
7590: PUSH
7591: LD_INT 3
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 24
7603: PUSH
7604: LD_INT 1000
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: PPUSH
7620: CALL_OW 70
7624: NOT
7625: AND
7626: PUSH
7627: LD_INT 22
7629: PUSH
7630: LD_INT 1
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PUSH
7637: LD_INT 25
7639: PUSH
7640: LD_INT 2
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 56
7649: PUSH
7650: EMPTY
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: PPUSH
7658: CALL_OW 69
7662: AND
7663: IFFALSE 7756
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin enable ;
7671: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] , [ f_outside ] ] ) do
7672: LD_ADDR_VAR 0 1
7676: PUSH
7677: LD_INT 22
7679: PUSH
7680: LD_INT 1
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 25
7689: PUSH
7690: LD_INT 2
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: LD_INT 56
7699: PUSH
7700: EMPTY
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: PPUSH
7708: CALL_OW 69
7712: PUSH
7713: FOR_IN
7714: IFFALSE 7754
// if not HasTask ( i ) and not GetTag ( i ) then
7716: LD_VAR 0 1
7720: PPUSH
7721: CALL_OW 314
7725: NOT
7726: PUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 110
7736: NOT
7737: AND
7738: IFFALSE 7752
// ComEnterUnit ( i , us_depot ) ;
7740: LD_VAR 0 1
7744: PPUSH
7745: LD_INT 5
7747: PPUSH
7748: CALL_OW 120
7752: GO 7713
7754: POP
7755: POP
// end ;
7756: PPOPN 1
7758: END
// every 0 0$1 trigger ( stevensTimer <= 0 0$00 or IsDead ( Stevens ) ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do
7759: LD_EXP 9
7763: PUSH
7764: LD_INT 0
7766: LESSEQUAL
7767: PUSH
7768: LD_EXP 18
7772: PPUSH
7773: CALL_OW 301
7777: OR
7778: PUSH
7779: LD_INT 22
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PUSH
7789: LD_INT 25
7791: PUSH
7792: LD_INT 2
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 69
7807: AND
7808: IFFALSE 7849
7810: GO 7812
7812: DISABLE
// ComDismantle ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) , us_lab ) ;
7813: LD_INT 22
7815: PUSH
7816: LD_INT 1
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PUSH
7823: LD_INT 25
7825: PUSH
7826: LD_INT 2
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PPUSH
7837: CALL_OW 69
7841: PPUSH
7842: LD_INT 1
7844: PPUSH
7845: CALL_OW 167
7849: END
// every 0 0$4 trigger not planCaptured and FilterUnitsInArea ( usBaseCriticalArea , [ f_side , 7 ] ) do var i ;
7850: LD_EXP 7
7854: NOT
7855: PUSH
7856: LD_INT 7
7858: PPUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 7
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 70
7873: AND
7874: IFFALSE 7965
7876: GO 7878
7878: DISABLE
7879: LD_INT 0
7881: PPUSH
// begin wait ( 0 0$2 ) ;
7882: LD_INT 70
7884: PPUSH
7885: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) do
7889: LD_ADDR_VAR 0 1
7893: PUSH
7894: LD_INT 22
7896: PUSH
7897: LD_INT 1
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: PUSH
7904: LD_INT 25
7906: PUSH
7907: LD_INT 1
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 69
7922: PUSH
7923: FOR_IN
7924: IFFALSE 7963
// begin if IsInUnit ( i ) then
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 310
7935: IFFALSE 7946
// ComExitBuilding ( i ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// AddComAgressiveMove ( i , 92 , 78 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_INT 92
7953: PPUSH
7954: LD_INT 78
7956: PPUSH
7957: CALL_OW 174
// end ;
7961: GO 7923
7963: POP
7964: POP
// end ; end_of_file
7965: PPOPN 1
7967: END
// on SiberiteRocketExploded ( sibRocket , x , y ) do OnBombExploded ( sibRocket , x , y ) ;
7968: LD_VAR 0 1
7972: PPUSH
7973: LD_VAR 0 2
7977: PPUSH
7978: LD_VAR 0 3
7982: PPUSH
7983: CALL 2823 0 3
7987: PPOPN 3
7989: END
// on UnitGoesToRed ( un ) do begin if GetClass ( JMM ) = 4 or GetClass ( Burlak ) = 4 then
7990: LD_EXP 14
7994: PPUSH
7995: CALL_OW 257
7999: PUSH
8000: LD_INT 4
8002: EQUAL
8003: PUSH
8004: LD_EXP 15
8008: PPUSH
8009: CALL_OW 257
8013: PUSH
8014: LD_INT 4
8016: EQUAL
8017: OR
8018: IFFALSE 8022
// exit ;
8020: GO 8060
// if un = JMM then
8022: LD_VAR 0 1
8026: PUSH
8027: LD_EXP 14
8031: EQUAL
8032: IFFALSE 8041
// YouLost ( JMM ) ;
8034: LD_STRING JMM
8036: PPUSH
8037: CALL_OW 104
// if un = Burlak then
8041: LD_VAR 0 1
8045: PUSH
8046: LD_EXP 15
8050: EQUAL
8051: IFFALSE 8060
// YouLost ( Burlak ) ;
8053: LD_STRING Burlak
8055: PPUSH
8056: CALL_OW 104
// end ;
8060: PPOPN 1
8062: END
// on UnitDestroyed ( un ) do begin if un = JMM then
8063: LD_VAR 0 1
8067: PUSH
8068: LD_EXP 14
8072: EQUAL
8073: IFFALSE 8082
// YouLost ( JMM ) ;
8075: LD_STRING JMM
8077: PPUSH
8078: CALL_OW 104
// if un = Burlak then
8082: LD_VAR 0 1
8086: PUSH
8087: LD_EXP 15
8091: EQUAL
8092: IFFALSE 8101
// YouLost ( Burlak ) ;
8094: LD_STRING Burlak
8096: PPUSH
8097: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
8101: LD_VAR 0 1
8105: PUSH
8106: LD_INT 21
8108: PUSH
8109: LD_INT 1
8111: PUSH
8112: EMPTY
8113: LIST
8114: LIST
8115: PUSH
8116: LD_INT 23
8118: PUSH
8119: LD_INT 1
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PPUSH
8130: CALL_OW 69
8134: IN
8135: IFFALSE 8151
// killCounter := killCounter + 1 ;
8137: LD_ADDR_EXP 12
8141: PUSH
8142: LD_EXP 12
8146: PUSH
8147: LD_INT 1
8149: PLUS
8150: ST_TO_ADDR
// end ;
8151: PPOPN 1
8153: END
// on UnitDestroyed_Extra ( un , killer_side , killer_unit ) do begin if killer_side = 7 and un in FilterAllUnits ( [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
8154: LD_VAR 0 2
8158: PUSH
8159: LD_INT 7
8161: EQUAL
8162: PUSH
8163: LD_VAR 0 1
8167: PUSH
8168: LD_INT 2
8170: PUSH
8171: LD_INT 30
8173: PUSH
8174: LD_INT 31
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 30
8183: PUSH
8184: LD_INT 32
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 30
8193: PUSH
8194: LD_INT 33
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 69
8211: IN
8212: AND
8213: IFFALSE 8229
// bunkerCounter := bunkerCounter + 1 ;
8215: LD_ADDR_EXP 13
8219: PUSH
8220: LD_EXP 13
8224: PUSH
8225: LD_INT 1
8227: PLUS
8228: ST_TO_ADDR
// end ;
8229: PPOPN 3
8231: END
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 7 then
8232: LD_VAR 0 1
8236: PPUSH
8237: CALL_OW 255
8241: PUSH
8242: LD_INT 7
8244: EQUAL
8245: IFFALSE 8255
// artifactPickedUp := true ;
8247: LD_ADDR_EXP 6
8251: PUSH
8252: LD_INT 1
8254: ST_TO_ADDR
// end ;
8255: PPOPN 2
8257: END
// on ArtifactUnloaded ( cargo , artifact ) do artifactPickedUp := false ;
8258: LD_ADDR_EXP 6
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
8266: PPOPN 2
8268: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) <> 1 then
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 255
8278: PUSH
8279: LD_INT 1
8281: NONEQUAL
8282: IFFALSE 8286
// exit ;
8284: GO 8333
// wait ( 0 0$5 ) ;
8286: LD_INT 175
8288: PPUSH
8289: CALL_OW 67
// if GetControl ( vehicle ) = control_remote then
8293: LD_VAR 0 1
8297: PPUSH
8298: CALL_OW 263
8302: PUSH
8303: LD_INT 2
8305: EQUAL
8306: IFFALSE 8317
// Connect ( vehicle ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL 1824 0 1
// vehGuard := vehGuard ^ vehicle ;
8317: LD_ADDR_EXP 23
8321: PUSH
8322: LD_EXP 23
8326: PUSH
8327: LD_VAR 0 1
8331: ADD
8332: ST_TO_ADDR
// end ;
8333: PPOPN 2
8335: END
// on BuildingCaptured ( captured , old_side , unit ) do begin if captured = us_lab and not planCaptured then
8336: LD_VAR 0 1
8340: PUSH
8341: LD_INT 1
8343: EQUAL
8344: PUSH
8345: LD_EXP 7
8349: NOT
8350: AND
8351: IFFALSE 8386
// begin planCaptured := true ;
8353: LD_ADDR_EXP 7
8357: PUSH
8358: LD_INT 1
8360: ST_TO_ADDR
// ChangeMissionObjectives ( MEnd ) ;
8361: LD_STRING MEnd
8363: PPUSH
8364: CALL_OW 337
// canEnd := true ;
8368: LD_ADDR_EXP 10
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
// missionTime := tick ;
8376: LD_ADDR_EXP 11
8380: PUSH
8381: LD_OWVAR 1
8385: ST_TO_ADDR
// end ; end ;
8386: PPOPN 3
8388: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL 19285 0 1
// end ; end_of_file
8398: PPOPN 1
8400: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8401: GO 8403
8403: DISABLE
// begin ru_radar := 98 ;
8404: LD_ADDR_EXP 24
8408: PUSH
8409: LD_INT 98
8411: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8412: LD_ADDR_EXP 25
8416: PUSH
8417: LD_INT 89
8419: ST_TO_ADDR
// us_hack := 99 ;
8420: LD_ADDR_EXP 26
8424: PUSH
8425: LD_INT 99
8427: ST_TO_ADDR
// us_artillery := 97 ;
8428: LD_ADDR_EXP 27
8432: PUSH
8433: LD_INT 97
8435: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8436: LD_ADDR_EXP 28
8440: PUSH
8441: LD_INT 91
8443: ST_TO_ADDR
// end ; end_of_file end_of_file
8444: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
8445: GO 8447
8447: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8448: LD_STRING initStreamRollete();
8450: PPUSH
8451: CALL_OW 559
// InitStreamMode ;
8455: CALL 8464 0 0
// DefineStreamItems ( ) ;
8459: CALL 8904 0 0
// end ;
8463: END
// function InitStreamMode ; begin
8464: LD_INT 0
8466: PPUSH
// streamModeActive := false ;
8467: LD_ADDR_EXP 29
8471: PUSH
8472: LD_INT 0
8474: ST_TO_ADDR
// normalCounter := 26 ;
8475: LD_ADDR_EXP 30
8479: PUSH
8480: LD_INT 26
8482: ST_TO_ADDR
// hardcoreCounter := 12 ;
8483: LD_ADDR_EXP 31
8487: PUSH
8488: LD_INT 12
8490: ST_TO_ADDR
// sRocket := false ;
8491: LD_ADDR_EXP 34
8495: PUSH
8496: LD_INT 0
8498: ST_TO_ADDR
// sSpeed := false ;
8499: LD_ADDR_EXP 33
8503: PUSH
8504: LD_INT 0
8506: ST_TO_ADDR
// sEngine := false ;
8507: LD_ADDR_EXP 35
8511: PUSH
8512: LD_INT 0
8514: ST_TO_ADDR
// sSpec := false ;
8515: LD_ADDR_EXP 32
8519: PUSH
8520: LD_INT 0
8522: ST_TO_ADDR
// sLevel := false ;
8523: LD_ADDR_EXP 36
8527: PUSH
8528: LD_INT 0
8530: ST_TO_ADDR
// sArmoury := false ;
8531: LD_ADDR_EXP 37
8535: PUSH
8536: LD_INT 0
8538: ST_TO_ADDR
// sRadar := false ;
8539: LD_ADDR_EXP 38
8543: PUSH
8544: LD_INT 0
8546: ST_TO_ADDR
// sBunker := false ;
8547: LD_ADDR_EXP 39
8551: PUSH
8552: LD_INT 0
8554: ST_TO_ADDR
// sHack := false ;
8555: LD_ADDR_EXP 40
8559: PUSH
8560: LD_INT 0
8562: ST_TO_ADDR
// sFire := false ;
8563: LD_ADDR_EXP 41
8567: PUSH
8568: LD_INT 0
8570: ST_TO_ADDR
// sRefresh := false ;
8571: LD_ADDR_EXP 42
8575: PUSH
8576: LD_INT 0
8578: ST_TO_ADDR
// sExp := false ;
8579: LD_ADDR_EXP 43
8583: PUSH
8584: LD_INT 0
8586: ST_TO_ADDR
// sDepot := false ;
8587: LD_ADDR_EXP 44
8591: PUSH
8592: LD_INT 0
8594: ST_TO_ADDR
// sFlag := false ;
8595: LD_ADDR_EXP 45
8599: PUSH
8600: LD_INT 0
8602: ST_TO_ADDR
// sKamikadze := false ;
8603: LD_ADDR_EXP 53
8607: PUSH
8608: LD_INT 0
8610: ST_TO_ADDR
// sTroll := false ;
8611: LD_ADDR_EXP 54
8615: PUSH
8616: LD_INT 0
8618: ST_TO_ADDR
// sSlow := false ;
8619: LD_ADDR_EXP 55
8623: PUSH
8624: LD_INT 0
8626: ST_TO_ADDR
// sLack := false ;
8627: LD_ADDR_EXP 56
8631: PUSH
8632: LD_INT 0
8634: ST_TO_ADDR
// sTank := false ;
8635: LD_ADDR_EXP 58
8639: PUSH
8640: LD_INT 0
8642: ST_TO_ADDR
// sRemote := false ;
8643: LD_ADDR_EXP 59
8647: PUSH
8648: LD_INT 0
8650: ST_TO_ADDR
// sPowell := false ;
8651: LD_ADDR_EXP 60
8655: PUSH
8656: LD_INT 0
8658: ST_TO_ADDR
// sTeleport := false ;
8659: LD_ADDR_EXP 63
8663: PUSH
8664: LD_INT 0
8666: ST_TO_ADDR
// sOilTower := false ;
8667: LD_ADDR_EXP 65
8671: PUSH
8672: LD_INT 0
8674: ST_TO_ADDR
// sShovel := false ;
8675: LD_ADDR_EXP 66
8679: PUSH
8680: LD_INT 0
8682: ST_TO_ADDR
// sSheik := false ;
8683: LD_ADDR_EXP 67
8687: PUSH
8688: LD_INT 0
8690: ST_TO_ADDR
// sEarthquake := false ;
8691: LD_ADDR_EXP 69
8695: PUSH
8696: LD_INT 0
8698: ST_TO_ADDR
// sAI := false ;
8699: LD_ADDR_EXP 70
8703: PUSH
8704: LD_INT 0
8706: ST_TO_ADDR
// sCargo := false ;
8707: LD_ADDR_EXP 73
8711: PUSH
8712: LD_INT 0
8714: ST_TO_ADDR
// sDLaser := false ;
8715: LD_ADDR_EXP 74
8719: PUSH
8720: LD_INT 0
8722: ST_TO_ADDR
// sExchange := false ;
8723: LD_ADDR_EXP 75
8727: PUSH
8728: LD_INT 0
8730: ST_TO_ADDR
// sFac := false ;
8731: LD_ADDR_EXP 76
8735: PUSH
8736: LD_INT 0
8738: ST_TO_ADDR
// sPower := false ;
8739: LD_ADDR_EXP 77
8743: PUSH
8744: LD_INT 0
8746: ST_TO_ADDR
// sRandom := false ;
8747: LD_ADDR_EXP 78
8751: PUSH
8752: LD_INT 0
8754: ST_TO_ADDR
// sShield := false ;
8755: LD_ADDR_EXP 79
8759: PUSH
8760: LD_INT 0
8762: ST_TO_ADDR
// sTime := false ;
8763: LD_ADDR_EXP 80
8767: PUSH
8768: LD_INT 0
8770: ST_TO_ADDR
// sTools := false ;
8771: LD_ADDR_EXP 81
8775: PUSH
8776: LD_INT 0
8778: ST_TO_ADDR
// sSold := false ;
8779: LD_ADDR_EXP 46
8783: PUSH
8784: LD_INT 0
8786: ST_TO_ADDR
// sDiff := false ;
8787: LD_ADDR_EXP 47
8791: PUSH
8792: LD_INT 0
8794: ST_TO_ADDR
// sFog := false ;
8795: LD_ADDR_EXP 50
8799: PUSH
8800: LD_INT 0
8802: ST_TO_ADDR
// sReset := false ;
8803: LD_ADDR_EXP 51
8807: PUSH
8808: LD_INT 0
8810: ST_TO_ADDR
// sSun := false ;
8811: LD_ADDR_EXP 52
8815: PUSH
8816: LD_INT 0
8818: ST_TO_ADDR
// sTiger := false ;
8819: LD_ADDR_EXP 48
8823: PUSH
8824: LD_INT 0
8826: ST_TO_ADDR
// sBomb := false ;
8827: LD_ADDR_EXP 49
8831: PUSH
8832: LD_INT 0
8834: ST_TO_ADDR
// sWound := false ;
8835: LD_ADDR_EXP 57
8839: PUSH
8840: LD_INT 0
8842: ST_TO_ADDR
// sBetray := false ;
8843: LD_ADDR_EXP 61
8847: PUSH
8848: LD_INT 0
8850: ST_TO_ADDR
// sContamin := false ;
8851: LD_ADDR_EXP 62
8855: PUSH
8856: LD_INT 0
8858: ST_TO_ADDR
// sOil := false ;
8859: LD_ADDR_EXP 64
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// sStu := false ;
8867: LD_ADDR_EXP 68
8871: PUSH
8872: LD_INT 0
8874: ST_TO_ADDR
// sBazooka := false ;
8875: LD_ADDR_EXP 71
8879: PUSH
8880: LD_INT 0
8882: ST_TO_ADDR
// sMortar := false ;
8883: LD_ADDR_EXP 72
8887: PUSH
8888: LD_INT 0
8890: ST_TO_ADDR
// sRanger := false ;
8891: LD_ADDR_EXP 82
8895: PUSH
8896: LD_INT 0
8898: ST_TO_ADDR
// end ;
8899: LD_VAR 0 1
8903: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8904: LD_INT 0
8906: PPUSH
8907: PPUSH
8908: PPUSH
8909: PPUSH
8910: PPUSH
// result := [ ] ;
8911: LD_ADDR_VAR 0 1
8915: PUSH
8916: EMPTY
8917: ST_TO_ADDR
// if campaign_id = 1 then
8918: LD_OWVAR 69
8922: PUSH
8923: LD_INT 1
8925: EQUAL
8926: IFFALSE 11862
// begin case mission_number of 1 :
8928: LD_OWVAR 70
8932: PUSH
8933: LD_INT 1
8935: DOUBLE
8936: EQUAL
8937: IFTRUE 8941
8939: GO 9005
8941: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8942: LD_ADDR_VAR 0 1
8946: PUSH
8947: LD_INT 2
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 11
8955: PUSH
8956: LD_INT 12
8958: PUSH
8959: LD_INT 15
8961: PUSH
8962: LD_INT 16
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 23
8970: PUSH
8971: LD_INT 26
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: LIST
8978: LIST
8979: LIST
8980: LIST
8981: LIST
8982: LIST
8983: LIST
8984: PUSH
8985: LD_INT 101
8987: PUSH
8988: LD_INT 102
8990: PUSH
8991: LD_INT 106
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: LIST
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: ST_TO_ADDR
9003: GO 11862
9005: LD_INT 2
9007: DOUBLE
9008: EQUAL
9009: IFTRUE 9013
9011: GO 9085
9013: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
9014: LD_ADDR_VAR 0 1
9018: PUSH
9019: LD_INT 2
9021: PUSH
9022: LD_INT 4
9024: PUSH
9025: LD_INT 11
9027: PUSH
9028: LD_INT 12
9030: PUSH
9031: LD_INT 15
9033: PUSH
9034: LD_INT 16
9036: PUSH
9037: LD_INT 22
9039: PUSH
9040: LD_INT 23
9042: PUSH
9043: LD_INT 26
9045: PUSH
9046: EMPTY
9047: LIST
9048: LIST
9049: LIST
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: PUSH
9057: LD_INT 101
9059: PUSH
9060: LD_INT 102
9062: PUSH
9063: LD_INT 105
9065: PUSH
9066: LD_INT 106
9068: PUSH
9069: LD_INT 108
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: ST_TO_ADDR
9083: GO 11862
9085: LD_INT 3
9087: DOUBLE
9088: EQUAL
9089: IFTRUE 9093
9091: GO 9169
9093: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
9094: LD_ADDR_VAR 0 1
9098: PUSH
9099: LD_INT 2
9101: PUSH
9102: LD_INT 4
9104: PUSH
9105: LD_INT 5
9107: PUSH
9108: LD_INT 11
9110: PUSH
9111: LD_INT 12
9113: PUSH
9114: LD_INT 15
9116: PUSH
9117: LD_INT 16
9119: PUSH
9120: LD_INT 22
9122: PUSH
9123: LD_INT 26
9125: PUSH
9126: LD_INT 36
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: PUSH
9141: LD_INT 101
9143: PUSH
9144: LD_INT 102
9146: PUSH
9147: LD_INT 105
9149: PUSH
9150: LD_INT 106
9152: PUSH
9153: LD_INT 108
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: ST_TO_ADDR
9167: GO 11862
9169: LD_INT 4
9171: DOUBLE
9172: EQUAL
9173: IFTRUE 9177
9175: GO 9261
9177: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
9178: LD_ADDR_VAR 0 1
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: LD_INT 4
9188: PUSH
9189: LD_INT 5
9191: PUSH
9192: LD_INT 8
9194: PUSH
9195: LD_INT 11
9197: PUSH
9198: LD_INT 12
9200: PUSH
9201: LD_INT 15
9203: PUSH
9204: LD_INT 16
9206: PUSH
9207: LD_INT 22
9209: PUSH
9210: LD_INT 23
9212: PUSH
9213: LD_INT 26
9215: PUSH
9216: LD_INT 36
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: LD_INT 101
9235: PUSH
9236: LD_INT 102
9238: PUSH
9239: LD_INT 105
9241: PUSH
9242: LD_INT 106
9244: PUSH
9245: LD_INT 108
9247: PUSH
9248: EMPTY
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: ST_TO_ADDR
9259: GO 11862
9261: LD_INT 5
9263: DOUBLE
9264: EQUAL
9265: IFTRUE 9269
9267: GO 9369
9269: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
9270: LD_ADDR_VAR 0 1
9274: PUSH
9275: LD_INT 2
9277: PUSH
9278: LD_INT 4
9280: PUSH
9281: LD_INT 5
9283: PUSH
9284: LD_INT 6
9286: PUSH
9287: LD_INT 8
9289: PUSH
9290: LD_INT 11
9292: PUSH
9293: LD_INT 12
9295: PUSH
9296: LD_INT 15
9298: PUSH
9299: LD_INT 16
9301: PUSH
9302: LD_INT 22
9304: PUSH
9305: LD_INT 23
9307: PUSH
9308: LD_INT 25
9310: PUSH
9311: LD_INT 26
9313: PUSH
9314: LD_INT 36
9316: PUSH
9317: EMPTY
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: LIST
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: LIST
9331: LIST
9332: PUSH
9333: LD_INT 101
9335: PUSH
9336: LD_INT 102
9338: PUSH
9339: LD_INT 105
9341: PUSH
9342: LD_INT 106
9344: PUSH
9345: LD_INT 108
9347: PUSH
9348: LD_INT 109
9350: PUSH
9351: LD_INT 112
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: LIST
9358: LIST
9359: LIST
9360: LIST
9361: LIST
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: ST_TO_ADDR
9367: GO 11862
9369: LD_INT 6
9371: DOUBLE
9372: EQUAL
9373: IFTRUE 9377
9375: GO 9497
9377: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
9378: LD_ADDR_VAR 0 1
9382: PUSH
9383: LD_INT 2
9385: PUSH
9386: LD_INT 4
9388: PUSH
9389: LD_INT 5
9391: PUSH
9392: LD_INT 6
9394: PUSH
9395: LD_INT 8
9397: PUSH
9398: LD_INT 11
9400: PUSH
9401: LD_INT 12
9403: PUSH
9404: LD_INT 15
9406: PUSH
9407: LD_INT 16
9409: PUSH
9410: LD_INT 20
9412: PUSH
9413: LD_INT 21
9415: PUSH
9416: LD_INT 22
9418: PUSH
9419: LD_INT 23
9421: PUSH
9422: LD_INT 25
9424: PUSH
9425: LD_INT 26
9427: PUSH
9428: LD_INT 30
9430: PUSH
9431: LD_INT 31
9433: PUSH
9434: LD_INT 32
9436: PUSH
9437: LD_INT 36
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 101
9463: PUSH
9464: LD_INT 102
9466: PUSH
9467: LD_INT 105
9469: PUSH
9470: LD_INT 106
9472: PUSH
9473: LD_INT 108
9475: PUSH
9476: LD_INT 109
9478: PUSH
9479: LD_INT 112
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: LIST
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: ST_TO_ADDR
9495: GO 11862
9497: LD_INT 7
9499: DOUBLE
9500: EQUAL
9501: IFTRUE 9505
9503: GO 9605
9505: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9506: LD_ADDR_VAR 0 1
9510: PUSH
9511: LD_INT 2
9513: PUSH
9514: LD_INT 4
9516: PUSH
9517: LD_INT 5
9519: PUSH
9520: LD_INT 7
9522: PUSH
9523: LD_INT 11
9525: PUSH
9526: LD_INT 12
9528: PUSH
9529: LD_INT 15
9531: PUSH
9532: LD_INT 16
9534: PUSH
9535: LD_INT 20
9537: PUSH
9538: LD_INT 21
9540: PUSH
9541: LD_INT 22
9543: PUSH
9544: LD_INT 23
9546: PUSH
9547: LD_INT 25
9549: PUSH
9550: LD_INT 26
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_INT 101
9571: PUSH
9572: LD_INT 102
9574: PUSH
9575: LD_INT 103
9577: PUSH
9578: LD_INT 105
9580: PUSH
9581: LD_INT 106
9583: PUSH
9584: LD_INT 108
9586: PUSH
9587: LD_INT 112
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: LIST
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: ST_TO_ADDR
9603: GO 11862
9605: LD_INT 8
9607: DOUBLE
9608: EQUAL
9609: IFTRUE 9613
9611: GO 9741
9613: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9614: LD_ADDR_VAR 0 1
9618: PUSH
9619: LD_INT 2
9621: PUSH
9622: LD_INT 4
9624: PUSH
9625: LD_INT 5
9627: PUSH
9628: LD_INT 6
9630: PUSH
9631: LD_INT 7
9633: PUSH
9634: LD_INT 8
9636: PUSH
9637: LD_INT 11
9639: PUSH
9640: LD_INT 12
9642: PUSH
9643: LD_INT 15
9645: PUSH
9646: LD_INT 16
9648: PUSH
9649: LD_INT 20
9651: PUSH
9652: LD_INT 21
9654: PUSH
9655: LD_INT 22
9657: PUSH
9658: LD_INT 23
9660: PUSH
9661: LD_INT 25
9663: PUSH
9664: LD_INT 26
9666: PUSH
9667: LD_INT 30
9669: PUSH
9670: LD_INT 31
9672: PUSH
9673: LD_INT 32
9675: PUSH
9676: LD_INT 36
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 101
9703: PUSH
9704: LD_INT 102
9706: PUSH
9707: LD_INT 103
9709: PUSH
9710: LD_INT 105
9712: PUSH
9713: LD_INT 106
9715: PUSH
9716: LD_INT 108
9718: PUSH
9719: LD_INT 109
9721: PUSH
9722: LD_INT 112
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: LIST
9729: LIST
9730: LIST
9731: LIST
9732: LIST
9733: LIST
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: ST_TO_ADDR
9739: GO 11862
9741: LD_INT 9
9743: DOUBLE
9744: EQUAL
9745: IFTRUE 9749
9747: GO 9885
9749: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_INT 2
9757: PUSH
9758: LD_INT 4
9760: PUSH
9761: LD_INT 5
9763: PUSH
9764: LD_INT 6
9766: PUSH
9767: LD_INT 7
9769: PUSH
9770: LD_INT 8
9772: PUSH
9773: LD_INT 11
9775: PUSH
9776: LD_INT 12
9778: PUSH
9779: LD_INT 15
9781: PUSH
9782: LD_INT 16
9784: PUSH
9785: LD_INT 20
9787: PUSH
9788: LD_INT 21
9790: PUSH
9791: LD_INT 22
9793: PUSH
9794: LD_INT 23
9796: PUSH
9797: LD_INT 25
9799: PUSH
9800: LD_INT 26
9802: PUSH
9803: LD_INT 28
9805: PUSH
9806: LD_INT 30
9808: PUSH
9809: LD_INT 31
9811: PUSH
9812: LD_INT 32
9814: PUSH
9815: LD_INT 36
9817: PUSH
9818: EMPTY
9819: LIST
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: LIST
9840: PUSH
9841: LD_INT 101
9843: PUSH
9844: LD_INT 102
9846: PUSH
9847: LD_INT 103
9849: PUSH
9850: LD_INT 105
9852: PUSH
9853: LD_INT 106
9855: PUSH
9856: LD_INT 108
9858: PUSH
9859: LD_INT 109
9861: PUSH
9862: LD_INT 112
9864: PUSH
9865: LD_INT 114
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: LIST
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: ST_TO_ADDR
9883: GO 11862
9885: LD_INT 10
9887: DOUBLE
9888: EQUAL
9889: IFTRUE 9893
9891: GO 10077
9893: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_INT 2
9901: PUSH
9902: LD_INT 4
9904: PUSH
9905: LD_INT 5
9907: PUSH
9908: LD_INT 6
9910: PUSH
9911: LD_INT 7
9913: PUSH
9914: LD_INT 8
9916: PUSH
9917: LD_INT 9
9919: PUSH
9920: LD_INT 10
9922: PUSH
9923: LD_INT 11
9925: PUSH
9926: LD_INT 12
9928: PUSH
9929: LD_INT 13
9931: PUSH
9932: LD_INT 14
9934: PUSH
9935: LD_INT 15
9937: PUSH
9938: LD_INT 16
9940: PUSH
9941: LD_INT 17
9943: PUSH
9944: LD_INT 18
9946: PUSH
9947: LD_INT 19
9949: PUSH
9950: LD_INT 20
9952: PUSH
9953: LD_INT 21
9955: PUSH
9956: LD_INT 22
9958: PUSH
9959: LD_INT 23
9961: PUSH
9962: LD_INT 24
9964: PUSH
9965: LD_INT 25
9967: PUSH
9968: LD_INT 26
9970: PUSH
9971: LD_INT 28
9973: PUSH
9974: LD_INT 30
9976: PUSH
9977: LD_INT 31
9979: PUSH
9980: LD_INT 32
9982: PUSH
9983: LD_INT 36
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: LIST
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: LIST
10014: LIST
10015: LIST
10016: PUSH
10017: LD_INT 101
10019: PUSH
10020: LD_INT 102
10022: PUSH
10023: LD_INT 103
10025: PUSH
10026: LD_INT 104
10028: PUSH
10029: LD_INT 105
10031: PUSH
10032: LD_INT 106
10034: PUSH
10035: LD_INT 107
10037: PUSH
10038: LD_INT 108
10040: PUSH
10041: LD_INT 109
10043: PUSH
10044: LD_INT 110
10046: PUSH
10047: LD_INT 111
10049: PUSH
10050: LD_INT 112
10052: PUSH
10053: LD_INT 114
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: ST_TO_ADDR
10075: GO 11862
10077: LD_INT 11
10079: DOUBLE
10080: EQUAL
10081: IFTRUE 10085
10083: GO 10277
10085: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
10086: LD_ADDR_VAR 0 1
10090: PUSH
10091: LD_INT 2
10093: PUSH
10094: LD_INT 3
10096: PUSH
10097: LD_INT 4
10099: PUSH
10100: LD_INT 5
10102: PUSH
10103: LD_INT 6
10105: PUSH
10106: LD_INT 7
10108: PUSH
10109: LD_INT 8
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: LD_INT 10
10117: PUSH
10118: LD_INT 11
10120: PUSH
10121: LD_INT 12
10123: PUSH
10124: LD_INT 13
10126: PUSH
10127: LD_INT 14
10129: PUSH
10130: LD_INT 15
10132: PUSH
10133: LD_INT 16
10135: PUSH
10136: LD_INT 17
10138: PUSH
10139: LD_INT 18
10141: PUSH
10142: LD_INT 19
10144: PUSH
10145: LD_INT 20
10147: PUSH
10148: LD_INT 21
10150: PUSH
10151: LD_INT 22
10153: PUSH
10154: LD_INT 23
10156: PUSH
10157: LD_INT 24
10159: PUSH
10160: LD_INT 25
10162: PUSH
10163: LD_INT 26
10165: PUSH
10166: LD_INT 28
10168: PUSH
10169: LD_INT 30
10171: PUSH
10172: LD_INT 31
10174: PUSH
10175: LD_INT 32
10177: PUSH
10178: LD_INT 34
10180: PUSH
10181: LD_INT 36
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 101
10219: PUSH
10220: LD_INT 102
10222: PUSH
10223: LD_INT 103
10225: PUSH
10226: LD_INT 104
10228: PUSH
10229: LD_INT 105
10231: PUSH
10232: LD_INT 106
10234: PUSH
10235: LD_INT 107
10237: PUSH
10238: LD_INT 108
10240: PUSH
10241: LD_INT 109
10243: PUSH
10244: LD_INT 110
10246: PUSH
10247: LD_INT 111
10249: PUSH
10250: LD_INT 112
10252: PUSH
10253: LD_INT 114
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: ST_TO_ADDR
10275: GO 11862
10277: LD_INT 12
10279: DOUBLE
10280: EQUAL
10281: IFTRUE 10285
10283: GO 10493
10285: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
10286: LD_ADDR_VAR 0 1
10290: PUSH
10291: LD_INT 1
10293: PUSH
10294: LD_INT 2
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 4
10302: PUSH
10303: LD_INT 5
10305: PUSH
10306: LD_INT 6
10308: PUSH
10309: LD_INT 7
10311: PUSH
10312: LD_INT 8
10314: PUSH
10315: LD_INT 9
10317: PUSH
10318: LD_INT 10
10320: PUSH
10321: LD_INT 11
10323: PUSH
10324: LD_INT 12
10326: PUSH
10327: LD_INT 13
10329: PUSH
10330: LD_INT 14
10332: PUSH
10333: LD_INT 15
10335: PUSH
10336: LD_INT 16
10338: PUSH
10339: LD_INT 17
10341: PUSH
10342: LD_INT 18
10344: PUSH
10345: LD_INT 19
10347: PUSH
10348: LD_INT 20
10350: PUSH
10351: LD_INT 21
10353: PUSH
10354: LD_INT 22
10356: PUSH
10357: LD_INT 23
10359: PUSH
10360: LD_INT 24
10362: PUSH
10363: LD_INT 25
10365: PUSH
10366: LD_INT 26
10368: PUSH
10369: LD_INT 27
10371: PUSH
10372: LD_INT 28
10374: PUSH
10375: LD_INT 30
10377: PUSH
10378: LD_INT 31
10380: PUSH
10381: LD_INT 32
10383: PUSH
10384: LD_INT 33
10386: PUSH
10387: LD_INT 34
10389: PUSH
10390: LD_INT 36
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 101
10431: PUSH
10432: LD_INT 102
10434: PUSH
10435: LD_INT 103
10437: PUSH
10438: LD_INT 104
10440: PUSH
10441: LD_INT 105
10443: PUSH
10444: LD_INT 106
10446: PUSH
10447: LD_INT 107
10449: PUSH
10450: LD_INT 108
10452: PUSH
10453: LD_INT 109
10455: PUSH
10456: LD_INT 110
10458: PUSH
10459: LD_INT 111
10461: PUSH
10462: LD_INT 112
10464: PUSH
10465: LD_INT 113
10467: PUSH
10468: LD_INT 114
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: LIST
10486: PUSH
10487: EMPTY
10488: LIST
10489: LIST
10490: ST_TO_ADDR
10491: GO 11862
10493: LD_INT 13
10495: DOUBLE
10496: EQUAL
10497: IFTRUE 10501
10499: GO 10697
10501: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10502: LD_ADDR_VAR 0 1
10506: PUSH
10507: LD_INT 1
10509: PUSH
10510: LD_INT 2
10512: PUSH
10513: LD_INT 3
10515: PUSH
10516: LD_INT 4
10518: PUSH
10519: LD_INT 5
10521: PUSH
10522: LD_INT 8
10524: PUSH
10525: LD_INT 9
10527: PUSH
10528: LD_INT 10
10530: PUSH
10531: LD_INT 11
10533: PUSH
10534: LD_INT 12
10536: PUSH
10537: LD_INT 14
10539: PUSH
10540: LD_INT 15
10542: PUSH
10543: LD_INT 16
10545: PUSH
10546: LD_INT 17
10548: PUSH
10549: LD_INT 18
10551: PUSH
10552: LD_INT 19
10554: PUSH
10555: LD_INT 20
10557: PUSH
10558: LD_INT 21
10560: PUSH
10561: LD_INT 22
10563: PUSH
10564: LD_INT 23
10566: PUSH
10567: LD_INT 24
10569: PUSH
10570: LD_INT 25
10572: PUSH
10573: LD_INT 26
10575: PUSH
10576: LD_INT 27
10578: PUSH
10579: LD_INT 28
10581: PUSH
10582: LD_INT 30
10584: PUSH
10585: LD_INT 31
10587: PUSH
10588: LD_INT 32
10590: PUSH
10591: LD_INT 33
10593: PUSH
10594: LD_INT 34
10596: PUSH
10597: LD_INT 36
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 101
10635: PUSH
10636: LD_INT 102
10638: PUSH
10639: LD_INT 103
10641: PUSH
10642: LD_INT 104
10644: PUSH
10645: LD_INT 105
10647: PUSH
10648: LD_INT 106
10650: PUSH
10651: LD_INT 107
10653: PUSH
10654: LD_INT 108
10656: PUSH
10657: LD_INT 109
10659: PUSH
10660: LD_INT 110
10662: PUSH
10663: LD_INT 111
10665: PUSH
10666: LD_INT 112
10668: PUSH
10669: LD_INT 113
10671: PUSH
10672: LD_INT 114
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: LIST
10679: LIST
10680: LIST
10681: LIST
10682: LIST
10683: LIST
10684: LIST
10685: LIST
10686: LIST
10687: LIST
10688: LIST
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: ST_TO_ADDR
10695: GO 11862
10697: LD_INT 14
10699: DOUBLE
10700: EQUAL
10701: IFTRUE 10705
10703: GO 10917
10705: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10706: LD_ADDR_VAR 0 1
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: LD_INT 2
10716: PUSH
10717: LD_INT 3
10719: PUSH
10720: LD_INT 4
10722: PUSH
10723: LD_INT 5
10725: PUSH
10726: LD_INT 6
10728: PUSH
10729: LD_INT 7
10731: PUSH
10732: LD_INT 8
10734: PUSH
10735: LD_INT 9
10737: PUSH
10738: LD_INT 10
10740: PUSH
10741: LD_INT 11
10743: PUSH
10744: LD_INT 12
10746: PUSH
10747: LD_INT 13
10749: PUSH
10750: LD_INT 14
10752: PUSH
10753: LD_INT 15
10755: PUSH
10756: LD_INT 16
10758: PUSH
10759: LD_INT 17
10761: PUSH
10762: LD_INT 18
10764: PUSH
10765: LD_INT 19
10767: PUSH
10768: LD_INT 20
10770: PUSH
10771: LD_INT 21
10773: PUSH
10774: LD_INT 22
10776: PUSH
10777: LD_INT 23
10779: PUSH
10780: LD_INT 24
10782: PUSH
10783: LD_INT 25
10785: PUSH
10786: LD_INT 26
10788: PUSH
10789: LD_INT 27
10791: PUSH
10792: LD_INT 28
10794: PUSH
10795: LD_INT 29
10797: PUSH
10798: LD_INT 30
10800: PUSH
10801: LD_INT 31
10803: PUSH
10804: LD_INT 32
10806: PUSH
10807: LD_INT 33
10809: PUSH
10810: LD_INT 34
10812: PUSH
10813: LD_INT 36
10815: PUSH
10816: EMPTY
10817: LIST
10818: LIST
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: LIST
10826: LIST
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: LIST
10844: LIST
10845: LIST
10846: LIST
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 101
10855: PUSH
10856: LD_INT 102
10858: PUSH
10859: LD_INT 103
10861: PUSH
10862: LD_INT 104
10864: PUSH
10865: LD_INT 105
10867: PUSH
10868: LD_INT 106
10870: PUSH
10871: LD_INT 107
10873: PUSH
10874: LD_INT 108
10876: PUSH
10877: LD_INT 109
10879: PUSH
10880: LD_INT 110
10882: PUSH
10883: LD_INT 111
10885: PUSH
10886: LD_INT 112
10888: PUSH
10889: LD_INT 113
10891: PUSH
10892: LD_INT 114
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: LIST
10909: LIST
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: ST_TO_ADDR
10915: GO 11862
10917: LD_INT 15
10919: DOUBLE
10920: EQUAL
10921: IFTRUE 10925
10923: GO 11137
10925: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10926: LD_ADDR_VAR 0 1
10930: PUSH
10931: LD_INT 1
10933: PUSH
10934: LD_INT 2
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: LD_INT 4
10942: PUSH
10943: LD_INT 5
10945: PUSH
10946: LD_INT 6
10948: PUSH
10949: LD_INT 7
10951: PUSH
10952: LD_INT 8
10954: PUSH
10955: LD_INT 9
10957: PUSH
10958: LD_INT 10
10960: PUSH
10961: LD_INT 11
10963: PUSH
10964: LD_INT 12
10966: PUSH
10967: LD_INT 13
10969: PUSH
10970: LD_INT 14
10972: PUSH
10973: LD_INT 15
10975: PUSH
10976: LD_INT 16
10978: PUSH
10979: LD_INT 17
10981: PUSH
10982: LD_INT 18
10984: PUSH
10985: LD_INT 19
10987: PUSH
10988: LD_INT 20
10990: PUSH
10991: LD_INT 21
10993: PUSH
10994: LD_INT 22
10996: PUSH
10997: LD_INT 23
10999: PUSH
11000: LD_INT 24
11002: PUSH
11003: LD_INT 25
11005: PUSH
11006: LD_INT 26
11008: PUSH
11009: LD_INT 27
11011: PUSH
11012: LD_INT 28
11014: PUSH
11015: LD_INT 29
11017: PUSH
11018: LD_INT 30
11020: PUSH
11021: LD_INT 31
11023: PUSH
11024: LD_INT 32
11026: PUSH
11027: LD_INT 33
11029: PUSH
11030: LD_INT 34
11032: PUSH
11033: LD_INT 36
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: LIST
11052: LIST
11053: LIST
11054: LIST
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: LIST
11064: LIST
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: LIST
11072: PUSH
11073: LD_INT 101
11075: PUSH
11076: LD_INT 102
11078: PUSH
11079: LD_INT 103
11081: PUSH
11082: LD_INT 104
11084: PUSH
11085: LD_INT 105
11087: PUSH
11088: LD_INT 106
11090: PUSH
11091: LD_INT 107
11093: PUSH
11094: LD_INT 108
11096: PUSH
11097: LD_INT 109
11099: PUSH
11100: LD_INT 110
11102: PUSH
11103: LD_INT 111
11105: PUSH
11106: LD_INT 112
11108: PUSH
11109: LD_INT 113
11111: PUSH
11112: LD_INT 114
11114: PUSH
11115: EMPTY
11116: LIST
11117: LIST
11118: LIST
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: LIST
11127: LIST
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: ST_TO_ADDR
11135: GO 11862
11137: LD_INT 16
11139: DOUBLE
11140: EQUAL
11141: IFTRUE 11145
11143: GO 11269
11145: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
11146: LD_ADDR_VAR 0 1
11150: PUSH
11151: LD_INT 2
11153: PUSH
11154: LD_INT 4
11156: PUSH
11157: LD_INT 5
11159: PUSH
11160: LD_INT 7
11162: PUSH
11163: LD_INT 11
11165: PUSH
11166: LD_INT 12
11168: PUSH
11169: LD_INT 15
11171: PUSH
11172: LD_INT 16
11174: PUSH
11175: LD_INT 20
11177: PUSH
11178: LD_INT 21
11180: PUSH
11181: LD_INT 22
11183: PUSH
11184: LD_INT 23
11186: PUSH
11187: LD_INT 25
11189: PUSH
11190: LD_INT 26
11192: PUSH
11193: LD_INT 30
11195: PUSH
11196: LD_INT 31
11198: PUSH
11199: LD_INT 32
11201: PUSH
11202: LD_INT 33
11204: PUSH
11205: LD_INT 34
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: PUSH
11229: LD_INT 101
11231: PUSH
11232: LD_INT 102
11234: PUSH
11235: LD_INT 103
11237: PUSH
11238: LD_INT 106
11240: PUSH
11241: LD_INT 108
11243: PUSH
11244: LD_INT 112
11246: PUSH
11247: LD_INT 113
11249: PUSH
11250: LD_INT 114
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: ST_TO_ADDR
11267: GO 11862
11269: LD_INT 17
11271: DOUBLE
11272: EQUAL
11273: IFTRUE 11277
11275: GO 11489
11277: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
11278: LD_ADDR_VAR 0 1
11282: PUSH
11283: LD_INT 1
11285: PUSH
11286: LD_INT 2
11288: PUSH
11289: LD_INT 3
11291: PUSH
11292: LD_INT 4
11294: PUSH
11295: LD_INT 5
11297: PUSH
11298: LD_INT 6
11300: PUSH
11301: LD_INT 7
11303: PUSH
11304: LD_INT 8
11306: PUSH
11307: LD_INT 9
11309: PUSH
11310: LD_INT 10
11312: PUSH
11313: LD_INT 11
11315: PUSH
11316: LD_INT 12
11318: PUSH
11319: LD_INT 13
11321: PUSH
11322: LD_INT 14
11324: PUSH
11325: LD_INT 15
11327: PUSH
11328: LD_INT 16
11330: PUSH
11331: LD_INT 17
11333: PUSH
11334: LD_INT 18
11336: PUSH
11337: LD_INT 19
11339: PUSH
11340: LD_INT 20
11342: PUSH
11343: LD_INT 21
11345: PUSH
11346: LD_INT 22
11348: PUSH
11349: LD_INT 23
11351: PUSH
11352: LD_INT 24
11354: PUSH
11355: LD_INT 25
11357: PUSH
11358: LD_INT 26
11360: PUSH
11361: LD_INT 27
11363: PUSH
11364: LD_INT 28
11366: PUSH
11367: LD_INT 29
11369: PUSH
11370: LD_INT 30
11372: PUSH
11373: LD_INT 31
11375: PUSH
11376: LD_INT 32
11378: PUSH
11379: LD_INT 33
11381: PUSH
11382: LD_INT 34
11384: PUSH
11385: LD_INT 36
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: PUSH
11425: LD_INT 101
11427: PUSH
11428: LD_INT 102
11430: PUSH
11431: LD_INT 103
11433: PUSH
11434: LD_INT 104
11436: PUSH
11437: LD_INT 105
11439: PUSH
11440: LD_INT 106
11442: PUSH
11443: LD_INT 107
11445: PUSH
11446: LD_INT 108
11448: PUSH
11449: LD_INT 109
11451: PUSH
11452: LD_INT 110
11454: PUSH
11455: LD_INT 111
11457: PUSH
11458: LD_INT 112
11460: PUSH
11461: LD_INT 113
11463: PUSH
11464: LD_INT 114
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: LIST
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: LIST
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: ST_TO_ADDR
11487: GO 11862
11489: LD_INT 18
11491: DOUBLE
11492: EQUAL
11493: IFTRUE 11497
11495: GO 11633
11497: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11498: LD_ADDR_VAR 0 1
11502: PUSH
11503: LD_INT 2
11505: PUSH
11506: LD_INT 4
11508: PUSH
11509: LD_INT 5
11511: PUSH
11512: LD_INT 7
11514: PUSH
11515: LD_INT 11
11517: PUSH
11518: LD_INT 12
11520: PUSH
11521: LD_INT 15
11523: PUSH
11524: LD_INT 16
11526: PUSH
11527: LD_INT 20
11529: PUSH
11530: LD_INT 21
11532: PUSH
11533: LD_INT 22
11535: PUSH
11536: LD_INT 23
11538: PUSH
11539: LD_INT 25
11541: PUSH
11542: LD_INT 26
11544: PUSH
11545: LD_INT 30
11547: PUSH
11548: LD_INT 31
11550: PUSH
11551: LD_INT 32
11553: PUSH
11554: LD_INT 33
11556: PUSH
11557: LD_INT 34
11559: PUSH
11560: LD_INT 35
11562: PUSH
11563: LD_INT 36
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: LIST
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: LIST
11586: LIST
11587: LIST
11588: PUSH
11589: LD_INT 101
11591: PUSH
11592: LD_INT 102
11594: PUSH
11595: LD_INT 103
11597: PUSH
11598: LD_INT 106
11600: PUSH
11601: LD_INT 108
11603: PUSH
11604: LD_INT 112
11606: PUSH
11607: LD_INT 113
11609: PUSH
11610: LD_INT 114
11612: PUSH
11613: LD_INT 115
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: ST_TO_ADDR
11631: GO 11862
11633: LD_INT 19
11635: DOUBLE
11636: EQUAL
11637: IFTRUE 11641
11639: GO 11861
11641: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11642: LD_ADDR_VAR 0 1
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: LD_INT 2
11652: PUSH
11653: LD_INT 3
11655: PUSH
11656: LD_INT 4
11658: PUSH
11659: LD_INT 5
11661: PUSH
11662: LD_INT 6
11664: PUSH
11665: LD_INT 7
11667: PUSH
11668: LD_INT 8
11670: PUSH
11671: LD_INT 9
11673: PUSH
11674: LD_INT 10
11676: PUSH
11677: LD_INT 11
11679: PUSH
11680: LD_INT 12
11682: PUSH
11683: LD_INT 13
11685: PUSH
11686: LD_INT 14
11688: PUSH
11689: LD_INT 15
11691: PUSH
11692: LD_INT 16
11694: PUSH
11695: LD_INT 17
11697: PUSH
11698: LD_INT 18
11700: PUSH
11701: LD_INT 19
11703: PUSH
11704: LD_INT 20
11706: PUSH
11707: LD_INT 21
11709: PUSH
11710: LD_INT 22
11712: PUSH
11713: LD_INT 23
11715: PUSH
11716: LD_INT 24
11718: PUSH
11719: LD_INT 25
11721: PUSH
11722: LD_INT 26
11724: PUSH
11725: LD_INT 27
11727: PUSH
11728: LD_INT 28
11730: PUSH
11731: LD_INT 29
11733: PUSH
11734: LD_INT 30
11736: PUSH
11737: LD_INT 31
11739: PUSH
11740: LD_INT 32
11742: PUSH
11743: LD_INT 33
11745: PUSH
11746: LD_INT 34
11748: PUSH
11749: LD_INT 35
11751: PUSH
11752: LD_INT 36
11754: PUSH
11755: EMPTY
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: PUSH
11793: LD_INT 101
11795: PUSH
11796: LD_INT 102
11798: PUSH
11799: LD_INT 103
11801: PUSH
11802: LD_INT 104
11804: PUSH
11805: LD_INT 105
11807: PUSH
11808: LD_INT 106
11810: PUSH
11811: LD_INT 107
11813: PUSH
11814: LD_INT 108
11816: PUSH
11817: LD_INT 109
11819: PUSH
11820: LD_INT 110
11822: PUSH
11823: LD_INT 111
11825: PUSH
11826: LD_INT 112
11828: PUSH
11829: LD_INT 113
11831: PUSH
11832: LD_INT 114
11834: PUSH
11835: LD_INT 115
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: ST_TO_ADDR
11859: GO 11862
11861: POP
// end ; if result then
11862: LD_VAR 0 1
11866: IFFALSE 12155
// begin normal :=  ;
11868: LD_ADDR_VAR 0 3
11872: PUSH
11873: LD_STRING 
11875: ST_TO_ADDR
// hardcore :=  ;
11876: LD_ADDR_VAR 0 4
11880: PUSH
11881: LD_STRING 
11883: ST_TO_ADDR
// for i = 1 to normalCounter do
11884: LD_ADDR_VAR 0 5
11888: PUSH
11889: DOUBLE
11890: LD_INT 1
11892: DEC
11893: ST_TO_ADDR
11894: LD_EXP 30
11898: PUSH
11899: FOR_TO
11900: IFFALSE 12001
// begin tmp := 0 ;
11902: LD_ADDR_VAR 0 2
11906: PUSH
11907: LD_STRING 0
11909: ST_TO_ADDR
// if result [ 1 ] then
11910: LD_VAR 0 1
11914: PUSH
11915: LD_INT 1
11917: ARRAY
11918: IFFALSE 11983
// if result [ 1 ] [ 1 ] = i then
11920: LD_VAR 0 1
11924: PUSH
11925: LD_INT 1
11927: ARRAY
11928: PUSH
11929: LD_INT 1
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 5
11937: EQUAL
11938: IFFALSE 11983
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11940: LD_ADDR_VAR 0 1
11944: PUSH
11945: LD_VAR 0 1
11949: PPUSH
11950: LD_INT 1
11952: PPUSH
11953: LD_VAR 0 1
11957: PUSH
11958: LD_INT 1
11960: ARRAY
11961: PPUSH
11962: LD_INT 1
11964: PPUSH
11965: CALL_OW 3
11969: PPUSH
11970: CALL_OW 1
11974: ST_TO_ADDR
// tmp := 1 ;
11975: LD_ADDR_VAR 0 2
11979: PUSH
11980: LD_STRING 1
11982: ST_TO_ADDR
// end ; normal := normal & tmp ;
11983: LD_ADDR_VAR 0 3
11987: PUSH
11988: LD_VAR 0 3
11992: PUSH
11993: LD_VAR 0 2
11997: STR
11998: ST_TO_ADDR
// end ;
11999: GO 11899
12001: POP
12002: POP
// for i = 1 to hardcoreCounter do
12003: LD_ADDR_VAR 0 5
12007: PUSH
12008: DOUBLE
12009: LD_INT 1
12011: DEC
12012: ST_TO_ADDR
12013: LD_EXP 31
12017: PUSH
12018: FOR_TO
12019: IFFALSE 12124
// begin tmp := 0 ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_STRING 0
12028: ST_TO_ADDR
// if result [ 2 ] then
12029: LD_VAR 0 1
12033: PUSH
12034: LD_INT 2
12036: ARRAY
12037: IFFALSE 12106
// if result [ 2 ] [ 1 ] = 100 + i then
12039: LD_VAR 0 1
12043: PUSH
12044: LD_INT 2
12046: ARRAY
12047: PUSH
12048: LD_INT 1
12050: ARRAY
12051: PUSH
12052: LD_INT 100
12054: PUSH
12055: LD_VAR 0 5
12059: PLUS
12060: EQUAL
12061: IFFALSE 12106
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
12063: LD_ADDR_VAR 0 1
12067: PUSH
12068: LD_VAR 0 1
12072: PPUSH
12073: LD_INT 2
12075: PPUSH
12076: LD_VAR 0 1
12080: PUSH
12081: LD_INT 2
12083: ARRAY
12084: PPUSH
12085: LD_INT 1
12087: PPUSH
12088: CALL_OW 3
12092: PPUSH
12093: CALL_OW 1
12097: ST_TO_ADDR
// tmp := 1 ;
12098: LD_ADDR_VAR 0 2
12102: PUSH
12103: LD_STRING 1
12105: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
12106: LD_ADDR_VAR 0 4
12110: PUSH
12111: LD_VAR 0 4
12115: PUSH
12116: LD_VAR 0 2
12120: STR
12121: ST_TO_ADDR
// end ;
12122: GO 12018
12124: POP
12125: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
12126: LD_STRING getStreamItemsFromMission("
12128: PUSH
12129: LD_VAR 0 3
12133: STR
12134: PUSH
12135: LD_STRING ","
12137: STR
12138: PUSH
12139: LD_VAR 0 4
12143: STR
12144: PUSH
12145: LD_STRING ")
12147: STR
12148: PPUSH
12149: CALL_OW 559
// end else
12153: GO 12162
// ToLua ( getStreamItemsFromMission("","") ) ;
12155: LD_STRING getStreamItemsFromMission("","")
12157: PPUSH
12158: CALL_OW 559
// end ;
12162: LD_VAR 0 1
12166: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
12167: LD_VAR 0 2
12171: PUSH
12172: LD_INT 100
12174: EQUAL
12175: IFFALSE 13124
// begin if not StreamModeActive then
12177: LD_EXP 29
12181: NOT
12182: IFFALSE 12192
// StreamModeActive := true ;
12184: LD_ADDR_EXP 29
12188: PUSH
12189: LD_INT 1
12191: ST_TO_ADDR
// if p3 = 0 then
12192: LD_VAR 0 3
12196: PUSH
12197: LD_INT 0
12199: EQUAL
12200: IFFALSE 12206
// InitStreamMode ;
12202: CALL 8464 0 0
// if p3 = 1 then
12206: LD_VAR 0 3
12210: PUSH
12211: LD_INT 1
12213: EQUAL
12214: IFFALSE 12224
// sRocket := true ;
12216: LD_ADDR_EXP 34
12220: PUSH
12221: LD_INT 1
12223: ST_TO_ADDR
// if p3 = 2 then
12224: LD_VAR 0 3
12228: PUSH
12229: LD_INT 2
12231: EQUAL
12232: IFFALSE 12242
// sSpeed := true ;
12234: LD_ADDR_EXP 33
12238: PUSH
12239: LD_INT 1
12241: ST_TO_ADDR
// if p3 = 3 then
12242: LD_VAR 0 3
12246: PUSH
12247: LD_INT 3
12249: EQUAL
12250: IFFALSE 12260
// sEngine := true ;
12252: LD_ADDR_EXP 35
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// if p3 = 4 then
12260: LD_VAR 0 3
12264: PUSH
12265: LD_INT 4
12267: EQUAL
12268: IFFALSE 12278
// sSpec := true ;
12270: LD_ADDR_EXP 32
12274: PUSH
12275: LD_INT 1
12277: ST_TO_ADDR
// if p3 = 5 then
12278: LD_VAR 0 3
12282: PUSH
12283: LD_INT 5
12285: EQUAL
12286: IFFALSE 12296
// sLevel := true ;
12288: LD_ADDR_EXP 36
12292: PUSH
12293: LD_INT 1
12295: ST_TO_ADDR
// if p3 = 6 then
12296: LD_VAR 0 3
12300: PUSH
12301: LD_INT 6
12303: EQUAL
12304: IFFALSE 12314
// sArmoury := true ;
12306: LD_ADDR_EXP 37
12310: PUSH
12311: LD_INT 1
12313: ST_TO_ADDR
// if p3 = 7 then
12314: LD_VAR 0 3
12318: PUSH
12319: LD_INT 7
12321: EQUAL
12322: IFFALSE 12332
// sRadar := true ;
12324: LD_ADDR_EXP 38
12328: PUSH
12329: LD_INT 1
12331: ST_TO_ADDR
// if p3 = 8 then
12332: LD_VAR 0 3
12336: PUSH
12337: LD_INT 8
12339: EQUAL
12340: IFFALSE 12350
// sBunker := true ;
12342: LD_ADDR_EXP 39
12346: PUSH
12347: LD_INT 1
12349: ST_TO_ADDR
// if p3 = 9 then
12350: LD_VAR 0 3
12354: PUSH
12355: LD_INT 9
12357: EQUAL
12358: IFFALSE 12368
// sHack := true ;
12360: LD_ADDR_EXP 40
12364: PUSH
12365: LD_INT 1
12367: ST_TO_ADDR
// if p3 = 10 then
12368: LD_VAR 0 3
12372: PUSH
12373: LD_INT 10
12375: EQUAL
12376: IFFALSE 12386
// sFire := true ;
12378: LD_ADDR_EXP 41
12382: PUSH
12383: LD_INT 1
12385: ST_TO_ADDR
// if p3 = 11 then
12386: LD_VAR 0 3
12390: PUSH
12391: LD_INT 11
12393: EQUAL
12394: IFFALSE 12404
// sRefresh := true ;
12396: LD_ADDR_EXP 42
12400: PUSH
12401: LD_INT 1
12403: ST_TO_ADDR
// if p3 = 12 then
12404: LD_VAR 0 3
12408: PUSH
12409: LD_INT 12
12411: EQUAL
12412: IFFALSE 12422
// sExp := true ;
12414: LD_ADDR_EXP 43
12418: PUSH
12419: LD_INT 1
12421: ST_TO_ADDR
// if p3 = 13 then
12422: LD_VAR 0 3
12426: PUSH
12427: LD_INT 13
12429: EQUAL
12430: IFFALSE 12440
// sDepot := true ;
12432: LD_ADDR_EXP 44
12436: PUSH
12437: LD_INT 1
12439: ST_TO_ADDR
// if p3 = 14 then
12440: LD_VAR 0 3
12444: PUSH
12445: LD_INT 14
12447: EQUAL
12448: IFFALSE 12458
// sFlag := true ;
12450: LD_ADDR_EXP 45
12454: PUSH
12455: LD_INT 1
12457: ST_TO_ADDR
// if p3 = 15 then
12458: LD_VAR 0 3
12462: PUSH
12463: LD_INT 15
12465: EQUAL
12466: IFFALSE 12476
// sKamikadze := true ;
12468: LD_ADDR_EXP 53
12472: PUSH
12473: LD_INT 1
12475: ST_TO_ADDR
// if p3 = 16 then
12476: LD_VAR 0 3
12480: PUSH
12481: LD_INT 16
12483: EQUAL
12484: IFFALSE 12494
// sTroll := true ;
12486: LD_ADDR_EXP 54
12490: PUSH
12491: LD_INT 1
12493: ST_TO_ADDR
// if p3 = 17 then
12494: LD_VAR 0 3
12498: PUSH
12499: LD_INT 17
12501: EQUAL
12502: IFFALSE 12512
// sSlow := true ;
12504: LD_ADDR_EXP 55
12508: PUSH
12509: LD_INT 1
12511: ST_TO_ADDR
// if p3 = 18 then
12512: LD_VAR 0 3
12516: PUSH
12517: LD_INT 18
12519: EQUAL
12520: IFFALSE 12530
// sLack := true ;
12522: LD_ADDR_EXP 56
12526: PUSH
12527: LD_INT 1
12529: ST_TO_ADDR
// if p3 = 19 then
12530: LD_VAR 0 3
12534: PUSH
12535: LD_INT 19
12537: EQUAL
12538: IFFALSE 12548
// sTank := true ;
12540: LD_ADDR_EXP 58
12544: PUSH
12545: LD_INT 1
12547: ST_TO_ADDR
// if p3 = 20 then
12548: LD_VAR 0 3
12552: PUSH
12553: LD_INT 20
12555: EQUAL
12556: IFFALSE 12566
// sRemote := true ;
12558: LD_ADDR_EXP 59
12562: PUSH
12563: LD_INT 1
12565: ST_TO_ADDR
// if p3 = 21 then
12566: LD_VAR 0 3
12570: PUSH
12571: LD_INT 21
12573: EQUAL
12574: IFFALSE 12584
// sPowell := true ;
12576: LD_ADDR_EXP 60
12580: PUSH
12581: LD_INT 1
12583: ST_TO_ADDR
// if p3 = 22 then
12584: LD_VAR 0 3
12588: PUSH
12589: LD_INT 22
12591: EQUAL
12592: IFFALSE 12602
// sTeleport := true ;
12594: LD_ADDR_EXP 63
12598: PUSH
12599: LD_INT 1
12601: ST_TO_ADDR
// if p3 = 23 then
12602: LD_VAR 0 3
12606: PUSH
12607: LD_INT 23
12609: EQUAL
12610: IFFALSE 12620
// sOilTower := true ;
12612: LD_ADDR_EXP 65
12616: PUSH
12617: LD_INT 1
12619: ST_TO_ADDR
// if p3 = 24 then
12620: LD_VAR 0 3
12624: PUSH
12625: LD_INT 24
12627: EQUAL
12628: IFFALSE 12638
// sShovel := true ;
12630: LD_ADDR_EXP 66
12634: PUSH
12635: LD_INT 1
12637: ST_TO_ADDR
// if p3 = 25 then
12638: LD_VAR 0 3
12642: PUSH
12643: LD_INT 25
12645: EQUAL
12646: IFFALSE 12656
// sSheik := true ;
12648: LD_ADDR_EXP 67
12652: PUSH
12653: LD_INT 1
12655: ST_TO_ADDR
// if p3 = 26 then
12656: LD_VAR 0 3
12660: PUSH
12661: LD_INT 26
12663: EQUAL
12664: IFFALSE 12674
// sEarthquake := true ;
12666: LD_ADDR_EXP 69
12670: PUSH
12671: LD_INT 1
12673: ST_TO_ADDR
// if p3 = 27 then
12674: LD_VAR 0 3
12678: PUSH
12679: LD_INT 27
12681: EQUAL
12682: IFFALSE 12692
// sAI := true ;
12684: LD_ADDR_EXP 70
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// if p3 = 28 then
12692: LD_VAR 0 3
12696: PUSH
12697: LD_INT 28
12699: EQUAL
12700: IFFALSE 12710
// sCargo := true ;
12702: LD_ADDR_EXP 73
12706: PUSH
12707: LD_INT 1
12709: ST_TO_ADDR
// if p3 = 29 then
12710: LD_VAR 0 3
12714: PUSH
12715: LD_INT 29
12717: EQUAL
12718: IFFALSE 12728
// sDLaser := true ;
12720: LD_ADDR_EXP 74
12724: PUSH
12725: LD_INT 1
12727: ST_TO_ADDR
// if p3 = 30 then
12728: LD_VAR 0 3
12732: PUSH
12733: LD_INT 30
12735: EQUAL
12736: IFFALSE 12746
// sExchange := true ;
12738: LD_ADDR_EXP 75
12742: PUSH
12743: LD_INT 1
12745: ST_TO_ADDR
// if p3 = 31 then
12746: LD_VAR 0 3
12750: PUSH
12751: LD_INT 31
12753: EQUAL
12754: IFFALSE 12764
// sFac := true ;
12756: LD_ADDR_EXP 76
12760: PUSH
12761: LD_INT 1
12763: ST_TO_ADDR
// if p3 = 32 then
12764: LD_VAR 0 3
12768: PUSH
12769: LD_INT 32
12771: EQUAL
12772: IFFALSE 12782
// sPower := true ;
12774: LD_ADDR_EXP 77
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// if p3 = 33 then
12782: LD_VAR 0 3
12786: PUSH
12787: LD_INT 33
12789: EQUAL
12790: IFFALSE 12800
// sRandom := true ;
12792: LD_ADDR_EXP 78
12796: PUSH
12797: LD_INT 1
12799: ST_TO_ADDR
// if p3 = 34 then
12800: LD_VAR 0 3
12804: PUSH
12805: LD_INT 34
12807: EQUAL
12808: IFFALSE 12818
// sShield := true ;
12810: LD_ADDR_EXP 79
12814: PUSH
12815: LD_INT 1
12817: ST_TO_ADDR
// if p3 = 35 then
12818: LD_VAR 0 3
12822: PUSH
12823: LD_INT 35
12825: EQUAL
12826: IFFALSE 12836
// sTime := true ;
12828: LD_ADDR_EXP 80
12832: PUSH
12833: LD_INT 1
12835: ST_TO_ADDR
// if p3 = 36 then
12836: LD_VAR 0 3
12840: PUSH
12841: LD_INT 36
12843: EQUAL
12844: IFFALSE 12854
// sTools := true ;
12846: LD_ADDR_EXP 81
12850: PUSH
12851: LD_INT 1
12853: ST_TO_ADDR
// if p3 = 101 then
12854: LD_VAR 0 3
12858: PUSH
12859: LD_INT 101
12861: EQUAL
12862: IFFALSE 12872
// sSold := true ;
12864: LD_ADDR_EXP 46
12868: PUSH
12869: LD_INT 1
12871: ST_TO_ADDR
// if p3 = 102 then
12872: LD_VAR 0 3
12876: PUSH
12877: LD_INT 102
12879: EQUAL
12880: IFFALSE 12890
// sDiff := true ;
12882: LD_ADDR_EXP 47
12886: PUSH
12887: LD_INT 1
12889: ST_TO_ADDR
// if p3 = 103 then
12890: LD_VAR 0 3
12894: PUSH
12895: LD_INT 103
12897: EQUAL
12898: IFFALSE 12908
// sFog := true ;
12900: LD_ADDR_EXP 50
12904: PUSH
12905: LD_INT 1
12907: ST_TO_ADDR
// if p3 = 104 then
12908: LD_VAR 0 3
12912: PUSH
12913: LD_INT 104
12915: EQUAL
12916: IFFALSE 12926
// sReset := true ;
12918: LD_ADDR_EXP 51
12922: PUSH
12923: LD_INT 1
12925: ST_TO_ADDR
// if p3 = 105 then
12926: LD_VAR 0 3
12930: PUSH
12931: LD_INT 105
12933: EQUAL
12934: IFFALSE 12944
// sSun := true ;
12936: LD_ADDR_EXP 52
12940: PUSH
12941: LD_INT 1
12943: ST_TO_ADDR
// if p3 = 106 then
12944: LD_VAR 0 3
12948: PUSH
12949: LD_INT 106
12951: EQUAL
12952: IFFALSE 12962
// sTiger := true ;
12954: LD_ADDR_EXP 48
12958: PUSH
12959: LD_INT 1
12961: ST_TO_ADDR
// if p3 = 107 then
12962: LD_VAR 0 3
12966: PUSH
12967: LD_INT 107
12969: EQUAL
12970: IFFALSE 12980
// sBomb := true ;
12972: LD_ADDR_EXP 49
12976: PUSH
12977: LD_INT 1
12979: ST_TO_ADDR
// if p3 = 108 then
12980: LD_VAR 0 3
12984: PUSH
12985: LD_INT 108
12987: EQUAL
12988: IFFALSE 12998
// sWound := true ;
12990: LD_ADDR_EXP 57
12994: PUSH
12995: LD_INT 1
12997: ST_TO_ADDR
// if p3 = 109 then
12998: LD_VAR 0 3
13002: PUSH
13003: LD_INT 109
13005: EQUAL
13006: IFFALSE 13016
// sBetray := true ;
13008: LD_ADDR_EXP 61
13012: PUSH
13013: LD_INT 1
13015: ST_TO_ADDR
// if p3 = 110 then
13016: LD_VAR 0 3
13020: PUSH
13021: LD_INT 110
13023: EQUAL
13024: IFFALSE 13034
// sContamin := true ;
13026: LD_ADDR_EXP 62
13030: PUSH
13031: LD_INT 1
13033: ST_TO_ADDR
// if p3 = 111 then
13034: LD_VAR 0 3
13038: PUSH
13039: LD_INT 111
13041: EQUAL
13042: IFFALSE 13052
// sOil := true ;
13044: LD_ADDR_EXP 64
13048: PUSH
13049: LD_INT 1
13051: ST_TO_ADDR
// if p3 = 112 then
13052: LD_VAR 0 3
13056: PUSH
13057: LD_INT 112
13059: EQUAL
13060: IFFALSE 13070
// sStu := true ;
13062: LD_ADDR_EXP 68
13066: PUSH
13067: LD_INT 1
13069: ST_TO_ADDR
// if p3 = 113 then
13070: LD_VAR 0 3
13074: PUSH
13075: LD_INT 113
13077: EQUAL
13078: IFFALSE 13088
// sBazooka := true ;
13080: LD_ADDR_EXP 71
13084: PUSH
13085: LD_INT 1
13087: ST_TO_ADDR
// if p3 = 114 then
13088: LD_VAR 0 3
13092: PUSH
13093: LD_INT 114
13095: EQUAL
13096: IFFALSE 13106
// sMortar := true ;
13098: LD_ADDR_EXP 72
13102: PUSH
13103: LD_INT 1
13105: ST_TO_ADDR
// if p3 = 115 then
13106: LD_VAR 0 3
13110: PUSH
13111: LD_INT 115
13113: EQUAL
13114: IFFALSE 13124
// sRanger := true ;
13116: LD_ADDR_EXP 82
13120: PUSH
13121: LD_INT 1
13123: ST_TO_ADDR
// end ; end ;
13124: PPOPN 6
13126: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
13127: LD_EXP 29
13131: PUSH
13132: LD_EXP 34
13136: AND
13137: IFFALSE 13261
13139: GO 13141
13141: DISABLE
13142: LD_INT 0
13144: PPUSH
13145: PPUSH
// begin enable ;
13146: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
13147: LD_ADDR_VAR 0 2
13151: PUSH
13152: LD_INT 22
13154: PUSH
13155: LD_OWVAR 2
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 2
13166: PUSH
13167: LD_INT 34
13169: PUSH
13170: LD_INT 7
13172: PUSH
13173: EMPTY
13174: LIST
13175: LIST
13176: PUSH
13177: LD_INT 34
13179: PUSH
13180: LD_INT 45
13182: PUSH
13183: EMPTY
13184: LIST
13185: LIST
13186: PUSH
13187: LD_INT 34
13189: PUSH
13190: LD_INT 28
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: PUSH
13197: LD_INT 34
13199: PUSH
13200: LD_INT 47
13202: PUSH
13203: EMPTY
13204: LIST
13205: LIST
13206: PUSH
13207: EMPTY
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PPUSH
13218: CALL_OW 69
13222: ST_TO_ADDR
// if not tmp then
13223: LD_VAR 0 2
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13261
// for i in tmp do
13232: LD_ADDR_VAR 0 1
13236: PUSH
13237: LD_VAR 0 2
13241: PUSH
13242: FOR_IN
13243: IFFALSE 13259
// begin SetLives ( i , 0 ) ;
13245: LD_VAR 0 1
13249: PPUSH
13250: LD_INT 0
13252: PPUSH
13253: CALL_OW 234
// end ;
13257: GO 13242
13259: POP
13260: POP
// end ;
13261: PPOPN 2
13263: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13264: LD_EXP 29
13268: PUSH
13269: LD_EXP 35
13273: AND
13274: IFFALSE 13358
13276: GO 13278
13278: DISABLE
13279: LD_INT 0
13281: PPUSH
13282: PPUSH
// begin enable ;
13283: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13284: LD_ADDR_VAR 0 2
13288: PUSH
13289: LD_INT 22
13291: PUSH
13292: LD_OWVAR 2
13296: PUSH
13297: EMPTY
13298: LIST
13299: LIST
13300: PUSH
13301: LD_INT 32
13303: PUSH
13304: LD_INT 3
13306: PUSH
13307: EMPTY
13308: LIST
13309: LIST
13310: PUSH
13311: EMPTY
13312: LIST
13313: LIST
13314: PPUSH
13315: CALL_OW 69
13319: ST_TO_ADDR
// if not tmp then
13320: LD_VAR 0 2
13324: NOT
13325: IFFALSE 13329
// exit ;
13327: GO 13358
// for i in tmp do
13329: LD_ADDR_VAR 0 1
13333: PUSH
13334: LD_VAR 0 2
13338: PUSH
13339: FOR_IN
13340: IFFALSE 13356
// begin SetLives ( i , 0 ) ;
13342: LD_VAR 0 1
13346: PPUSH
13347: LD_INT 0
13349: PPUSH
13350: CALL_OW 234
// end ;
13354: GO 13339
13356: POP
13357: POP
// end ;
13358: PPOPN 2
13360: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13361: LD_EXP 29
13365: PUSH
13366: LD_EXP 32
13370: AND
13371: IFFALSE 13464
13373: GO 13375
13375: DISABLE
13376: LD_INT 0
13378: PPUSH
// begin enable ;
13379: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13380: LD_ADDR_VAR 0 1
13384: PUSH
13385: LD_INT 22
13387: PUSH
13388: LD_OWVAR 2
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PUSH
13397: LD_INT 2
13399: PUSH
13400: LD_INT 25
13402: PUSH
13403: LD_INT 5
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: LD_INT 25
13412: PUSH
13413: LD_INT 9
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PUSH
13420: LD_INT 25
13422: PUSH
13423: LD_INT 8
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PPUSH
13440: CALL_OW 69
13444: PUSH
13445: FOR_IN
13446: IFFALSE 13462
// begin SetClass ( i , 1 ) ;
13448: LD_VAR 0 1
13452: PPUSH
13453: LD_INT 1
13455: PPUSH
13456: CALL_OW 336
// end ;
13460: GO 13445
13462: POP
13463: POP
// end ;
13464: PPOPN 1
13466: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13467: LD_EXP 29
13471: PUSH
13472: LD_EXP 33
13476: AND
13477: PUSH
13478: LD_OWVAR 65
13482: PUSH
13483: LD_INT 7
13485: LESS
13486: AND
13487: IFFALSE 13501
13489: GO 13491
13491: DISABLE
// begin enable ;
13492: ENABLE
// game_speed := 7 ;
13493: LD_ADDR_OWVAR 65
13497: PUSH
13498: LD_INT 7
13500: ST_TO_ADDR
// end ;
13501: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13502: LD_EXP 29
13506: PUSH
13507: LD_EXP 36
13511: AND
13512: IFFALSE 13714
13514: GO 13516
13516: DISABLE
13517: LD_INT 0
13519: PPUSH
13520: PPUSH
13521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_INT 81
13529: PUSH
13530: LD_OWVAR 2
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: PUSH
13539: LD_INT 21
13541: PUSH
13542: LD_INT 1
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PPUSH
13553: CALL_OW 69
13557: ST_TO_ADDR
// if not tmp then
13558: LD_VAR 0 3
13562: NOT
13563: IFFALSE 13567
// exit ;
13565: GO 13714
// if tmp > 5 then
13567: LD_VAR 0 3
13571: PUSH
13572: LD_INT 5
13574: GREATER
13575: IFFALSE 13587
// k := 5 else
13577: LD_ADDR_VAR 0 2
13581: PUSH
13582: LD_INT 5
13584: ST_TO_ADDR
13585: GO 13597
// k := tmp ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_VAR 0 3
13596: ST_TO_ADDR
// for i := 1 to k do
13597: LD_ADDR_VAR 0 1
13601: PUSH
13602: DOUBLE
13603: LD_INT 1
13605: DEC
13606: ST_TO_ADDR
13607: LD_VAR 0 2
13611: PUSH
13612: FOR_TO
13613: IFFALSE 13712
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13615: LD_VAR 0 3
13619: PUSH
13620: LD_VAR 0 1
13624: ARRAY
13625: PPUSH
13626: LD_VAR 0 1
13630: PUSH
13631: LD_INT 4
13633: MOD
13634: PUSH
13635: LD_INT 1
13637: PLUS
13638: PPUSH
13639: CALL_OW 259
13643: PUSH
13644: LD_INT 10
13646: LESS
13647: IFFALSE 13710
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13649: LD_VAR 0 3
13653: PUSH
13654: LD_VAR 0 1
13658: ARRAY
13659: PPUSH
13660: LD_VAR 0 1
13664: PUSH
13665: LD_INT 4
13667: MOD
13668: PUSH
13669: LD_INT 1
13671: PLUS
13672: PPUSH
13673: LD_VAR 0 3
13677: PUSH
13678: LD_VAR 0 1
13682: ARRAY
13683: PPUSH
13684: LD_VAR 0 1
13688: PUSH
13689: LD_INT 4
13691: MOD
13692: PUSH
13693: LD_INT 1
13695: PLUS
13696: PPUSH
13697: CALL_OW 259
13701: PUSH
13702: LD_INT 1
13704: PLUS
13705: PPUSH
13706: CALL_OW 237
13710: GO 13612
13712: POP
13713: POP
// end ;
13714: PPOPN 3
13716: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13717: LD_EXP 29
13721: PUSH
13722: LD_EXP 37
13726: AND
13727: IFFALSE 13747
13729: GO 13731
13731: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13732: LD_INT 4
13734: PPUSH
13735: LD_OWVAR 2
13739: PPUSH
13740: LD_INT 0
13742: PPUSH
13743: CALL_OW 324
13747: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13748: LD_EXP 29
13752: PUSH
13753: LD_EXP 66
13757: AND
13758: IFFALSE 13778
13760: GO 13762
13762: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13763: LD_INT 19
13765: PPUSH
13766: LD_OWVAR 2
13770: PPUSH
13771: LD_INT 0
13773: PPUSH
13774: CALL_OW 324
13778: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13779: LD_EXP 29
13783: PUSH
13784: LD_EXP 38
13788: AND
13789: IFFALSE 13891
13791: GO 13793
13793: DISABLE
13794: LD_INT 0
13796: PPUSH
13797: PPUSH
// begin enable ;
13798: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13799: LD_ADDR_VAR 0 2
13803: PUSH
13804: LD_INT 22
13806: PUSH
13807: LD_OWVAR 2
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PUSH
13816: LD_INT 2
13818: PUSH
13819: LD_INT 34
13821: PUSH
13822: LD_INT 11
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 34
13831: PUSH
13832: LD_INT 30
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: LIST
13843: PUSH
13844: EMPTY
13845: LIST
13846: LIST
13847: PPUSH
13848: CALL_OW 69
13852: ST_TO_ADDR
// if not tmp then
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13862
// exit ;
13860: GO 13891
// for i in tmp do
13862: LD_ADDR_VAR 0 1
13866: PUSH
13867: LD_VAR 0 2
13871: PUSH
13872: FOR_IN
13873: IFFALSE 13889
// begin SetLives ( i , 0 ) ;
13875: LD_VAR 0 1
13879: PPUSH
13880: LD_INT 0
13882: PPUSH
13883: CALL_OW 234
// end ;
13887: GO 13872
13889: POP
13890: POP
// end ;
13891: PPOPN 2
13893: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13894: LD_EXP 29
13898: PUSH
13899: LD_EXP 39
13903: AND
13904: IFFALSE 13924
13906: GO 13908
13908: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13909: LD_INT 32
13911: PPUSH
13912: LD_OWVAR 2
13916: PPUSH
13917: LD_INT 0
13919: PPUSH
13920: CALL_OW 324
13924: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13925: LD_EXP 29
13929: PUSH
13930: LD_EXP 40
13934: AND
13935: IFFALSE 14116
13937: GO 13939
13939: DISABLE
13940: LD_INT 0
13942: PPUSH
13943: PPUSH
13944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13945: LD_ADDR_VAR 0 2
13949: PUSH
13950: LD_INT 22
13952: PUSH
13953: LD_OWVAR 2
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: LD_INT 33
13964: PUSH
13965: LD_INT 3
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PPUSH
13976: CALL_OW 69
13980: ST_TO_ADDR
// if not tmp then
13981: LD_VAR 0 2
13985: NOT
13986: IFFALSE 13990
// exit ;
13988: GO 14116
// side := 0 ;
13990: LD_ADDR_VAR 0 3
13994: PUSH
13995: LD_INT 0
13997: ST_TO_ADDR
// for i := 1 to 8 do
13998: LD_ADDR_VAR 0 1
14002: PUSH
14003: DOUBLE
14004: LD_INT 1
14006: DEC
14007: ST_TO_ADDR
14008: LD_INT 8
14010: PUSH
14011: FOR_TO
14012: IFFALSE 14060
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
14014: LD_OWVAR 2
14018: PUSH
14019: LD_VAR 0 1
14023: NONEQUAL
14024: PUSH
14025: LD_OWVAR 2
14029: PPUSH
14030: LD_VAR 0 1
14034: PPUSH
14035: CALL_OW 81
14039: PUSH
14040: LD_INT 2
14042: EQUAL
14043: AND
14044: IFFALSE 14058
// begin side := i ;
14046: LD_ADDR_VAR 0 3
14050: PUSH
14051: LD_VAR 0 1
14055: ST_TO_ADDR
// break ;
14056: GO 14060
// end ;
14058: GO 14011
14060: POP
14061: POP
// if not side then
14062: LD_VAR 0 3
14066: NOT
14067: IFFALSE 14071
// exit ;
14069: GO 14116
// for i := 1 to tmp do
14071: LD_ADDR_VAR 0 1
14075: PUSH
14076: DOUBLE
14077: LD_INT 1
14079: DEC
14080: ST_TO_ADDR
14081: LD_VAR 0 2
14085: PUSH
14086: FOR_TO
14087: IFFALSE 14114
// if Prob ( 60 ) then
14089: LD_INT 60
14091: PPUSH
14092: CALL_OW 13
14096: IFFALSE 14112
// SetSide ( i , side ) ;
14098: LD_VAR 0 1
14102: PPUSH
14103: LD_VAR 0 3
14107: PPUSH
14108: CALL_OW 235
14112: GO 14086
14114: POP
14115: POP
// end ;
14116: PPOPN 3
14118: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
14119: LD_EXP 29
14123: PUSH
14124: LD_EXP 42
14128: AND
14129: IFFALSE 14248
14131: GO 14133
14133: DISABLE
14134: LD_INT 0
14136: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
14137: LD_ADDR_VAR 0 1
14141: PUSH
14142: LD_INT 22
14144: PUSH
14145: LD_OWVAR 2
14149: PUSH
14150: EMPTY
14151: LIST
14152: LIST
14153: PUSH
14154: LD_INT 21
14156: PUSH
14157: LD_INT 1
14159: PUSH
14160: EMPTY
14161: LIST
14162: LIST
14163: PUSH
14164: LD_INT 3
14166: PUSH
14167: LD_INT 23
14169: PUSH
14170: LD_INT 0
14172: PUSH
14173: EMPTY
14174: LIST
14175: LIST
14176: PUSH
14177: EMPTY
14178: LIST
14179: LIST
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: LIST
14185: PPUSH
14186: CALL_OW 69
14190: PUSH
14191: FOR_IN
14192: IFFALSE 14246
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
14194: LD_VAR 0 1
14198: PPUSH
14199: CALL_OW 257
14203: PUSH
14204: LD_INT 1
14206: PUSH
14207: LD_INT 2
14209: PUSH
14210: LD_INT 3
14212: PUSH
14213: LD_INT 4
14215: PUSH
14216: EMPTY
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: IN
14222: IFFALSE 14244
// SetClass ( un , rand ( 1 , 4 ) ) ;
14224: LD_VAR 0 1
14228: PPUSH
14229: LD_INT 1
14231: PPUSH
14232: LD_INT 4
14234: PPUSH
14235: CALL_OW 12
14239: PPUSH
14240: CALL_OW 336
14244: GO 14191
14246: POP
14247: POP
// end ;
14248: PPOPN 1
14250: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
14251: LD_EXP 29
14255: PUSH
14256: LD_EXP 41
14260: AND
14261: IFFALSE 14340
14263: GO 14265
14265: DISABLE
14266: LD_INT 0
14268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: LD_INT 22
14276: PUSH
14277: LD_OWVAR 2
14281: PUSH
14282: EMPTY
14283: LIST
14284: LIST
14285: PUSH
14286: LD_INT 21
14288: PUSH
14289: LD_INT 3
14291: PUSH
14292: EMPTY
14293: LIST
14294: LIST
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PPUSH
14300: CALL_OW 69
14304: ST_TO_ADDR
// if not tmp then
14305: LD_VAR 0 1
14309: NOT
14310: IFFALSE 14314
// exit ;
14312: GO 14340
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14314: LD_VAR 0 1
14318: PUSH
14319: LD_INT 1
14321: PPUSH
14322: LD_VAR 0 1
14326: PPUSH
14327: CALL_OW 12
14331: ARRAY
14332: PPUSH
14333: LD_INT 100
14335: PPUSH
14336: CALL_OW 234
// end ;
14340: PPOPN 1
14342: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14343: LD_EXP 29
14347: PUSH
14348: LD_EXP 43
14352: AND
14353: IFFALSE 14451
14355: GO 14357
14357: DISABLE
14358: LD_INT 0
14360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14361: LD_ADDR_VAR 0 1
14365: PUSH
14366: LD_INT 22
14368: PUSH
14369: LD_OWVAR 2
14373: PUSH
14374: EMPTY
14375: LIST
14376: LIST
14377: PUSH
14378: LD_INT 21
14380: PUSH
14381: LD_INT 1
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PPUSH
14392: CALL_OW 69
14396: ST_TO_ADDR
// if not tmp then
14397: LD_VAR 0 1
14401: NOT
14402: IFFALSE 14406
// exit ;
14404: GO 14451
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14406: LD_VAR 0 1
14410: PUSH
14411: LD_INT 1
14413: PPUSH
14414: LD_VAR 0 1
14418: PPUSH
14419: CALL_OW 12
14423: ARRAY
14424: PPUSH
14425: LD_INT 1
14427: PPUSH
14428: LD_INT 4
14430: PPUSH
14431: CALL_OW 12
14435: PPUSH
14436: LD_INT 3000
14438: PPUSH
14439: LD_INT 9000
14441: PPUSH
14442: CALL_OW 12
14446: PPUSH
14447: CALL_OW 492
// end ;
14451: PPOPN 1
14453: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14454: LD_EXP 29
14458: PUSH
14459: LD_EXP 44
14463: AND
14464: IFFALSE 14484
14466: GO 14468
14468: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14469: LD_INT 1
14471: PPUSH
14472: LD_OWVAR 2
14476: PPUSH
14477: LD_INT 0
14479: PPUSH
14480: CALL_OW 324
14484: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14485: LD_EXP 29
14489: PUSH
14490: LD_EXP 45
14494: AND
14495: IFFALSE 14578
14497: GO 14499
14499: DISABLE
14500: LD_INT 0
14502: PPUSH
14503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14504: LD_ADDR_VAR 0 2
14508: PUSH
14509: LD_INT 22
14511: PUSH
14512: LD_OWVAR 2
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 21
14523: PUSH
14524: LD_INT 3
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PPUSH
14535: CALL_OW 69
14539: ST_TO_ADDR
// if not tmp then
14540: LD_VAR 0 2
14544: NOT
14545: IFFALSE 14549
// exit ;
14547: GO 14578
// for i in tmp do
14549: LD_ADDR_VAR 0 1
14553: PUSH
14554: LD_VAR 0 2
14558: PUSH
14559: FOR_IN
14560: IFFALSE 14576
// SetBLevel ( i , 10 ) ;
14562: LD_VAR 0 1
14566: PPUSH
14567: LD_INT 10
14569: PPUSH
14570: CALL_OW 241
14574: GO 14559
14576: POP
14577: POP
// end ;
14578: PPOPN 2
14580: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14581: LD_EXP 29
14585: PUSH
14586: LD_EXP 46
14590: AND
14591: IFFALSE 14702
14593: GO 14595
14595: DISABLE
14596: LD_INT 0
14598: PPUSH
14599: PPUSH
14600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14601: LD_ADDR_VAR 0 3
14605: PUSH
14606: LD_INT 22
14608: PUSH
14609: LD_OWVAR 2
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PUSH
14618: LD_INT 25
14620: PUSH
14621: LD_INT 1
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PUSH
14628: EMPTY
14629: LIST
14630: LIST
14631: PPUSH
14632: CALL_OW 69
14636: ST_TO_ADDR
// if not tmp then
14637: LD_VAR 0 3
14641: NOT
14642: IFFALSE 14646
// exit ;
14644: GO 14702
// un := tmp [ rand ( 1 , tmp ) ] ;
14646: LD_ADDR_VAR 0 2
14650: PUSH
14651: LD_VAR 0 3
14655: PUSH
14656: LD_INT 1
14658: PPUSH
14659: LD_VAR 0 3
14663: PPUSH
14664: CALL_OW 12
14668: ARRAY
14669: ST_TO_ADDR
// if Crawls ( un ) then
14670: LD_VAR 0 2
14674: PPUSH
14675: CALL_OW 318
14679: IFFALSE 14690
// ComWalk ( un ) ;
14681: LD_VAR 0 2
14685: PPUSH
14686: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14690: LD_VAR 0 2
14694: PPUSH
14695: LD_INT 5
14697: PPUSH
14698: CALL_OW 336
// end ;
14702: PPOPN 3
14704: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14705: LD_EXP 29
14709: PUSH
14710: LD_EXP 47
14714: AND
14715: PUSH
14716: LD_OWVAR 67
14720: PUSH
14721: LD_INT 3
14723: LESS
14724: AND
14725: IFFALSE 14744
14727: GO 14729
14729: DISABLE
// Difficulty := Difficulty + 1 ;
14730: LD_ADDR_OWVAR 67
14734: PUSH
14735: LD_OWVAR 67
14739: PUSH
14740: LD_INT 1
14742: PLUS
14743: ST_TO_ADDR
14744: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14745: LD_EXP 29
14749: PUSH
14750: LD_EXP 48
14754: AND
14755: IFFALSE 14858
14757: GO 14759
14759: DISABLE
14760: LD_INT 0
14762: PPUSH
// begin for i := 1 to 5 do
14763: LD_ADDR_VAR 0 1
14767: PUSH
14768: DOUBLE
14769: LD_INT 1
14771: DEC
14772: ST_TO_ADDR
14773: LD_INT 5
14775: PUSH
14776: FOR_TO
14777: IFFALSE 14856
// begin uc_nation := nation_nature ;
14779: LD_ADDR_OWVAR 21
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// uc_side := 0 ;
14787: LD_ADDR_OWVAR 20
14791: PUSH
14792: LD_INT 0
14794: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14795: LD_ADDR_OWVAR 29
14799: PUSH
14800: LD_INT 12
14802: PUSH
14803: LD_INT 12
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: ST_TO_ADDR
// hc_agressivity := 20 ;
14810: LD_ADDR_OWVAR 35
14814: PUSH
14815: LD_INT 20
14817: ST_TO_ADDR
// hc_class := class_tiger ;
14818: LD_ADDR_OWVAR 28
14822: PUSH
14823: LD_INT 14
14825: ST_TO_ADDR
// hc_gallery :=  ;
14826: LD_ADDR_OWVAR 33
14830: PUSH
14831: LD_STRING 
14833: ST_TO_ADDR
// hc_name :=  ;
14834: LD_ADDR_OWVAR 26
14838: PUSH
14839: LD_STRING 
14841: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14842: CALL_OW 44
14846: PPUSH
14847: LD_INT 0
14849: PPUSH
14850: CALL_OW 51
// end ;
14854: GO 14776
14856: POP
14857: POP
// end ;
14858: PPOPN 1
14860: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14861: LD_EXP 29
14865: PUSH
14866: LD_EXP 49
14870: AND
14871: IFFALSE 14880
14873: GO 14875
14875: DISABLE
// StreamSibBomb ;
14876: CALL 14881 0 0
14880: END
// export function StreamSibBomb ; var i , x , y ; begin
14881: LD_INT 0
14883: PPUSH
14884: PPUSH
14885: PPUSH
14886: PPUSH
// result := false ;
14887: LD_ADDR_VAR 0 1
14891: PUSH
14892: LD_INT 0
14894: ST_TO_ADDR
// for i := 1 to 16 do
14895: LD_ADDR_VAR 0 2
14899: PUSH
14900: DOUBLE
14901: LD_INT 1
14903: DEC
14904: ST_TO_ADDR
14905: LD_INT 16
14907: PUSH
14908: FOR_TO
14909: IFFALSE 15108
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14911: LD_ADDR_VAR 0 3
14915: PUSH
14916: LD_INT 10
14918: PUSH
14919: LD_INT 20
14921: PUSH
14922: LD_INT 30
14924: PUSH
14925: LD_INT 40
14927: PUSH
14928: LD_INT 50
14930: PUSH
14931: LD_INT 60
14933: PUSH
14934: LD_INT 70
14936: PUSH
14937: LD_INT 80
14939: PUSH
14940: LD_INT 90
14942: PUSH
14943: LD_INT 100
14945: PUSH
14946: LD_INT 110
14948: PUSH
14949: LD_INT 120
14951: PUSH
14952: LD_INT 130
14954: PUSH
14955: LD_INT 140
14957: PUSH
14958: LD_INT 150
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: LIST
14965: LIST
14966: LIST
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: LIST
14972: LIST
14973: LIST
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 1
14980: PPUSH
14981: LD_INT 15
14983: PPUSH
14984: CALL_OW 12
14988: ARRAY
14989: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14990: LD_ADDR_VAR 0 4
14994: PUSH
14995: LD_INT 10
14997: PUSH
14998: LD_INT 20
15000: PUSH
15001: LD_INT 30
15003: PUSH
15004: LD_INT 40
15006: PUSH
15007: LD_INT 50
15009: PUSH
15010: LD_INT 60
15012: PUSH
15013: LD_INT 70
15015: PUSH
15016: LD_INT 80
15018: PUSH
15019: LD_INT 90
15021: PUSH
15022: LD_INT 100
15024: PUSH
15025: LD_INT 110
15027: PUSH
15028: LD_INT 120
15030: PUSH
15031: LD_INT 130
15033: PUSH
15034: LD_INT 140
15036: PUSH
15037: LD_INT 150
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: PUSH
15057: LD_INT 1
15059: PPUSH
15060: LD_INT 15
15062: PPUSH
15063: CALL_OW 12
15067: ARRAY
15068: ST_TO_ADDR
// if ValidHex ( x , y ) then
15069: LD_VAR 0 3
15073: PPUSH
15074: LD_VAR 0 4
15078: PPUSH
15079: CALL_OW 488
15083: IFFALSE 15106
// begin result := [ x , y ] ;
15085: LD_ADDR_VAR 0 1
15089: PUSH
15090: LD_VAR 0 3
15094: PUSH
15095: LD_VAR 0 4
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: ST_TO_ADDR
// break ;
15104: GO 15108
// end ; end ;
15106: GO 14908
15108: POP
15109: POP
// if result then
15110: LD_VAR 0 1
15114: IFFALSE 15174
// begin ToLua ( playSibBomb() ) ;
15116: LD_STRING playSibBomb()
15118: PPUSH
15119: CALL_OW 559
// wait ( 0 0$14 ) ;
15123: LD_INT 490
15125: PPUSH
15126: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
15130: LD_VAR 0 1
15134: PUSH
15135: LD_INT 1
15137: ARRAY
15138: PPUSH
15139: LD_VAR 0 1
15143: PUSH
15144: LD_INT 2
15146: ARRAY
15147: PPUSH
15148: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
15152: LD_VAR 0 1
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: PPUSH
15161: LD_VAR 0 1
15165: PUSH
15166: LD_INT 2
15168: ARRAY
15169: PPUSH
15170: CALL_OW 429
// end ; end ;
15174: LD_VAR 0 1
15178: RET
// every 0 0$1 trigger StreamModeActive and sReset do
15179: LD_EXP 29
15183: PUSH
15184: LD_EXP 51
15188: AND
15189: IFFALSE 15201
15191: GO 15193
15193: DISABLE
// YouLost (  ) ;
15194: LD_STRING 
15196: PPUSH
15197: CALL_OW 104
15201: END
// every 0 0$1 trigger StreamModeActive and sFog do
15202: LD_EXP 29
15206: PUSH
15207: LD_EXP 50
15211: AND
15212: IFFALSE 15226
15214: GO 15216
15216: DISABLE
// FogOff ( your_side ) ;
15217: LD_OWVAR 2
15221: PPUSH
15222: CALL_OW 344
15226: END
// every 0 0$1 trigger StreamModeActive and sSun do
15227: LD_EXP 29
15231: PUSH
15232: LD_EXP 52
15236: AND
15237: IFFALSE 15265
15239: GO 15241
15241: DISABLE
// begin solar_recharge_percent := 0 ;
15242: LD_ADDR_OWVAR 79
15246: PUSH
15247: LD_INT 0
15249: ST_TO_ADDR
// wait ( 5 5$00 ) ;
15250: LD_INT 10500
15252: PPUSH
15253: CALL_OW 67
// solar_recharge_percent := 100 ;
15257: LD_ADDR_OWVAR 79
15261: PUSH
15262: LD_INT 100
15264: ST_TO_ADDR
// end ;
15265: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15266: LD_EXP 29
15270: PUSH
15271: LD_EXP 53
15275: AND
15276: IFFALSE 15515
15278: GO 15280
15280: DISABLE
15281: LD_INT 0
15283: PPUSH
15284: PPUSH
15285: PPUSH
// begin tmp := [ ] ;
15286: LD_ADDR_VAR 0 3
15290: PUSH
15291: EMPTY
15292: ST_TO_ADDR
// for i := 1 to 6 do
15293: LD_ADDR_VAR 0 1
15297: PUSH
15298: DOUBLE
15299: LD_INT 1
15301: DEC
15302: ST_TO_ADDR
15303: LD_INT 6
15305: PUSH
15306: FOR_TO
15307: IFFALSE 15412
// begin uc_nation := nation_nature ;
15309: LD_ADDR_OWVAR 21
15313: PUSH
15314: LD_INT 0
15316: ST_TO_ADDR
// uc_side := 0 ;
15317: LD_ADDR_OWVAR 20
15321: PUSH
15322: LD_INT 0
15324: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15325: LD_ADDR_OWVAR 29
15329: PUSH
15330: LD_INT 12
15332: PUSH
15333: LD_INT 12
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: ST_TO_ADDR
// hc_agressivity := 20 ;
15340: LD_ADDR_OWVAR 35
15344: PUSH
15345: LD_INT 20
15347: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15348: LD_ADDR_OWVAR 28
15352: PUSH
15353: LD_INT 17
15355: ST_TO_ADDR
// hc_gallery :=  ;
15356: LD_ADDR_OWVAR 33
15360: PUSH
15361: LD_STRING 
15363: ST_TO_ADDR
// hc_name :=  ;
15364: LD_ADDR_OWVAR 26
15368: PUSH
15369: LD_STRING 
15371: ST_TO_ADDR
// un := CreateHuman ;
15372: LD_ADDR_VAR 0 2
15376: PUSH
15377: CALL_OW 44
15381: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15382: LD_VAR 0 2
15386: PPUSH
15387: LD_INT 1
15389: PPUSH
15390: CALL_OW 51
// tmp := tmp ^ un ;
15394: LD_ADDR_VAR 0 3
15398: PUSH
15399: LD_VAR 0 3
15403: PUSH
15404: LD_VAR 0 2
15408: ADD
15409: ST_TO_ADDR
// end ;
15410: GO 15306
15412: POP
15413: POP
// repeat wait ( 0 0$1 ) ;
15414: LD_INT 35
15416: PPUSH
15417: CALL_OW 67
// for un in tmp do
15421: LD_ADDR_VAR 0 2
15425: PUSH
15426: LD_VAR 0 3
15430: PUSH
15431: FOR_IN
15432: IFFALSE 15506
// begin if IsDead ( un ) then
15434: LD_VAR 0 2
15438: PPUSH
15439: CALL_OW 301
15443: IFFALSE 15463
// begin tmp := tmp diff un ;
15445: LD_ADDR_VAR 0 3
15449: PUSH
15450: LD_VAR 0 3
15454: PUSH
15455: LD_VAR 0 2
15459: DIFF
15460: ST_TO_ADDR
// continue ;
15461: GO 15431
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15463: LD_VAR 0 2
15467: PPUSH
15468: LD_INT 3
15470: PUSH
15471: LD_INT 22
15473: PUSH
15474: LD_INT 0
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: EMPTY
15482: LIST
15483: LIST
15484: PPUSH
15485: CALL_OW 69
15489: PPUSH
15490: LD_VAR 0 2
15494: PPUSH
15495: CALL_OW 74
15499: PPUSH
15500: CALL_OW 115
// end ;
15504: GO 15431
15506: POP
15507: POP
// until not tmp ;
15508: LD_VAR 0 3
15512: NOT
15513: IFFALSE 15414
// end ;
15515: PPOPN 3
15517: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15518: LD_EXP 29
15522: PUSH
15523: LD_EXP 54
15527: AND
15528: IFFALSE 15582
15530: GO 15532
15532: DISABLE
// begin ToLua ( displayTroll(); ) ;
15533: LD_STRING displayTroll();
15535: PPUSH
15536: CALL_OW 559
// wait ( 3 3$00 ) ;
15540: LD_INT 6300
15542: PPUSH
15543: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15547: LD_STRING hideTroll();
15549: PPUSH
15550: CALL_OW 559
// wait ( 1 1$00 ) ;
15554: LD_INT 2100
15556: PPUSH
15557: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15561: LD_STRING displayTroll();
15563: PPUSH
15564: CALL_OW 559
// wait ( 1 1$00 ) ;
15568: LD_INT 2100
15570: PPUSH
15571: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15575: LD_STRING hideTroll();
15577: PPUSH
15578: CALL_OW 559
// end ;
15582: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15583: LD_EXP 29
15587: PUSH
15588: LD_EXP 55
15592: AND
15593: IFFALSE 15656
15595: GO 15597
15597: DISABLE
15598: LD_INT 0
15600: PPUSH
// begin p := 0 ;
15601: LD_ADDR_VAR 0 1
15605: PUSH
15606: LD_INT 0
15608: ST_TO_ADDR
// repeat game_speed := 1 ;
15609: LD_ADDR_OWVAR 65
15613: PUSH
15614: LD_INT 1
15616: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15617: LD_INT 35
15619: PPUSH
15620: CALL_OW 67
// p := p + 1 ;
15624: LD_ADDR_VAR 0 1
15628: PUSH
15629: LD_VAR 0 1
15633: PUSH
15634: LD_INT 1
15636: PLUS
15637: ST_TO_ADDR
// until p >= 60 ;
15638: LD_VAR 0 1
15642: PUSH
15643: LD_INT 60
15645: GREATEREQUAL
15646: IFFALSE 15609
// game_speed := 4 ;
15648: LD_ADDR_OWVAR 65
15652: PUSH
15653: LD_INT 4
15655: ST_TO_ADDR
// end ;
15656: PPOPN 1
15658: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15659: LD_EXP 29
15663: PUSH
15664: LD_EXP 56
15668: AND
15669: IFFALSE 15815
15671: GO 15673
15673: DISABLE
15674: LD_INT 0
15676: PPUSH
15677: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15678: LD_ADDR_VAR 0 1
15682: PUSH
15683: LD_INT 22
15685: PUSH
15686: LD_OWVAR 2
15690: PUSH
15691: EMPTY
15692: LIST
15693: LIST
15694: PUSH
15695: LD_INT 2
15697: PUSH
15698: LD_INT 30
15700: PUSH
15701: LD_INT 0
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 30
15710: PUSH
15711: LD_INT 1
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: LIST
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: PPUSH
15727: CALL_OW 69
15731: ST_TO_ADDR
// if not depot then
15732: LD_VAR 0 1
15736: NOT
15737: IFFALSE 15741
// exit ;
15739: GO 15815
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15741: LD_ADDR_VAR 0 2
15745: PUSH
15746: LD_VAR 0 1
15750: PUSH
15751: LD_INT 1
15753: PPUSH
15754: LD_VAR 0 1
15758: PPUSH
15759: CALL_OW 12
15763: ARRAY
15764: PPUSH
15765: CALL_OW 274
15769: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15770: LD_VAR 0 2
15774: PPUSH
15775: LD_INT 1
15777: PPUSH
15778: LD_INT 0
15780: PPUSH
15781: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15785: LD_VAR 0 2
15789: PPUSH
15790: LD_INT 2
15792: PPUSH
15793: LD_INT 0
15795: PPUSH
15796: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15800: LD_VAR 0 2
15804: PPUSH
15805: LD_INT 3
15807: PPUSH
15808: LD_INT 0
15810: PPUSH
15811: CALL_OW 277
// end ;
15815: PPOPN 2
15817: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15818: LD_EXP 29
15822: PUSH
15823: LD_EXP 57
15827: AND
15828: IFFALSE 15925
15830: GO 15832
15832: DISABLE
15833: LD_INT 0
15835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15836: LD_ADDR_VAR 0 1
15840: PUSH
15841: LD_INT 22
15843: PUSH
15844: LD_OWVAR 2
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: PUSH
15853: LD_INT 21
15855: PUSH
15856: LD_INT 1
15858: PUSH
15859: EMPTY
15860: LIST
15861: LIST
15862: PUSH
15863: LD_INT 3
15865: PUSH
15866: LD_INT 23
15868: PUSH
15869: LD_INT 0
15871: PUSH
15872: EMPTY
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: LIST
15884: PPUSH
15885: CALL_OW 69
15889: ST_TO_ADDR
// if not tmp then
15890: LD_VAR 0 1
15894: NOT
15895: IFFALSE 15899
// exit ;
15897: GO 15925
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15899: LD_VAR 0 1
15903: PUSH
15904: LD_INT 1
15906: PPUSH
15907: LD_VAR 0 1
15911: PPUSH
15912: CALL_OW 12
15916: ARRAY
15917: PPUSH
15918: LD_INT 200
15920: PPUSH
15921: CALL_OW 234
// end ;
15925: PPOPN 1
15927: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15928: LD_EXP 29
15932: PUSH
15933: LD_EXP 58
15937: AND
15938: IFFALSE 16017
15940: GO 15942
15942: DISABLE
15943: LD_INT 0
15945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15946: LD_ADDR_VAR 0 1
15950: PUSH
15951: LD_INT 22
15953: PUSH
15954: LD_OWVAR 2
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: PUSH
15963: LD_INT 21
15965: PUSH
15966: LD_INT 2
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PPUSH
15977: CALL_OW 69
15981: ST_TO_ADDR
// if not tmp then
15982: LD_VAR 0 1
15986: NOT
15987: IFFALSE 15991
// exit ;
15989: GO 16017
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15991: LD_VAR 0 1
15995: PUSH
15996: LD_INT 1
15998: PPUSH
15999: LD_VAR 0 1
16003: PPUSH
16004: CALL_OW 12
16008: ARRAY
16009: PPUSH
16010: LD_INT 60
16012: PPUSH
16013: CALL_OW 234
// end ;
16017: PPOPN 1
16019: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
16020: LD_EXP 29
16024: PUSH
16025: LD_EXP 59
16029: AND
16030: IFFALSE 16129
16032: GO 16034
16034: DISABLE
16035: LD_INT 0
16037: PPUSH
16038: PPUSH
// begin enable ;
16039: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
16040: LD_ADDR_VAR 0 1
16044: PUSH
16045: LD_INT 22
16047: PUSH
16048: LD_OWVAR 2
16052: PUSH
16053: EMPTY
16054: LIST
16055: LIST
16056: PUSH
16057: LD_INT 61
16059: PUSH
16060: EMPTY
16061: LIST
16062: PUSH
16063: LD_INT 33
16065: PUSH
16066: LD_INT 2
16068: PUSH
16069: EMPTY
16070: LIST
16071: LIST
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: LIST
16077: PPUSH
16078: CALL_OW 69
16082: ST_TO_ADDR
// if not tmp then
16083: LD_VAR 0 1
16087: NOT
16088: IFFALSE 16092
// exit ;
16090: GO 16129
// for i in tmp do
16092: LD_ADDR_VAR 0 2
16096: PUSH
16097: LD_VAR 0 1
16101: PUSH
16102: FOR_IN
16103: IFFALSE 16127
// if IsControledBy ( i ) then
16105: LD_VAR 0 2
16109: PPUSH
16110: CALL_OW 312
16114: IFFALSE 16125
// ComUnlink ( i ) ;
16116: LD_VAR 0 2
16120: PPUSH
16121: CALL_OW 136
16125: GO 16102
16127: POP
16128: POP
// end ;
16129: PPOPN 2
16131: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
16132: LD_EXP 29
16136: PUSH
16137: LD_EXP 60
16141: AND
16142: IFFALSE 16282
16144: GO 16146
16146: DISABLE
16147: LD_INT 0
16149: PPUSH
16150: PPUSH
// begin ToLua ( displayPowell(); ) ;
16151: LD_STRING displayPowell();
16153: PPUSH
16154: CALL_OW 559
// uc_side := 0 ;
16158: LD_ADDR_OWVAR 20
16162: PUSH
16163: LD_INT 0
16165: ST_TO_ADDR
// uc_nation := 2 ;
16166: LD_ADDR_OWVAR 21
16170: PUSH
16171: LD_INT 2
16173: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16174: LD_ADDR_OWVAR 37
16178: PUSH
16179: LD_INT 14
16181: ST_TO_ADDR
// vc_engine := engine_siberite ;
16182: LD_ADDR_OWVAR 39
16186: PUSH
16187: LD_INT 3
16189: ST_TO_ADDR
// vc_control := control_apeman ;
16190: LD_ADDR_OWVAR 38
16194: PUSH
16195: LD_INT 5
16197: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
16198: LD_ADDR_OWVAR 40
16202: PUSH
16203: LD_INT 29
16205: ST_TO_ADDR
// un := CreateVehicle ;
16206: LD_ADDR_VAR 0 2
16210: PUSH
16211: CALL_OW 45
16215: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16216: LD_VAR 0 2
16220: PPUSH
16221: LD_INT 1
16223: PPUSH
16224: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16228: LD_INT 35
16230: PPUSH
16231: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16235: LD_VAR 0 2
16239: PPUSH
16240: LD_INT 22
16242: PUSH
16243: LD_OWVAR 2
16247: PUSH
16248: EMPTY
16249: LIST
16250: LIST
16251: PPUSH
16252: CALL_OW 69
16256: PPUSH
16257: LD_VAR 0 2
16261: PPUSH
16262: CALL_OW 74
16266: PPUSH
16267: CALL_OW 115
// until IsDead ( un ) ;
16271: LD_VAR 0 2
16275: PPUSH
16276: CALL_OW 301
16280: IFFALSE 16228
// end ;
16282: PPOPN 2
16284: END
// every 0 0$1 trigger StreamModeActive and sStu do
16285: LD_EXP 29
16289: PUSH
16290: LD_EXP 68
16294: AND
16295: IFFALSE 16311
16297: GO 16299
16299: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16300: LD_STRING displayStucuk();
16302: PPUSH
16303: CALL_OW 559
// ResetFog ;
16307: CALL_OW 335
// end ;
16311: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16312: LD_EXP 29
16316: PUSH
16317: LD_EXP 61
16321: AND
16322: IFFALSE 16463
16324: GO 16326
16326: DISABLE
16327: LD_INT 0
16329: PPUSH
16330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16331: LD_ADDR_VAR 0 2
16335: PUSH
16336: LD_INT 22
16338: PUSH
16339: LD_OWVAR 2
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: PUSH
16348: LD_INT 21
16350: PUSH
16351: LD_INT 1
16353: PUSH
16354: EMPTY
16355: LIST
16356: LIST
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: PPUSH
16362: CALL_OW 69
16366: ST_TO_ADDR
// if not tmp then
16367: LD_VAR 0 2
16371: NOT
16372: IFFALSE 16376
// exit ;
16374: GO 16463
// un := tmp [ rand ( 1 , tmp ) ] ;
16376: LD_ADDR_VAR 0 1
16380: PUSH
16381: LD_VAR 0 2
16385: PUSH
16386: LD_INT 1
16388: PPUSH
16389: LD_VAR 0 2
16393: PPUSH
16394: CALL_OW 12
16398: ARRAY
16399: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 0
16407: PPUSH
16408: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16412: LD_VAR 0 1
16416: PPUSH
16417: LD_OWVAR 3
16421: PUSH
16422: LD_VAR 0 1
16426: DIFF
16427: PPUSH
16428: LD_VAR 0 1
16432: PPUSH
16433: CALL_OW 74
16437: PPUSH
16438: CALL_OW 115
// wait ( 0 0$20 ) ;
16442: LD_INT 700
16444: PPUSH
16445: CALL_OW 67
// SetSide ( un , your_side ) ;
16449: LD_VAR 0 1
16453: PPUSH
16454: LD_OWVAR 2
16458: PPUSH
16459: CALL_OW 235
// end ;
16463: PPOPN 2
16465: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16466: LD_EXP 29
16470: PUSH
16471: LD_EXP 62
16475: AND
16476: IFFALSE 16582
16478: GO 16480
16480: DISABLE
16481: LD_INT 0
16483: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16484: LD_ADDR_VAR 0 1
16488: PUSH
16489: LD_INT 22
16491: PUSH
16492: LD_OWVAR 2
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 2
16503: PUSH
16504: LD_INT 30
16506: PUSH
16507: LD_INT 0
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: LD_INT 30
16516: PUSH
16517: LD_INT 1
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PPUSH
16533: CALL_OW 69
16537: ST_TO_ADDR
// if not depot then
16538: LD_VAR 0 1
16542: NOT
16543: IFFALSE 16547
// exit ;
16545: GO 16582
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16547: LD_VAR 0 1
16551: PUSH
16552: LD_INT 1
16554: ARRAY
16555: PPUSH
16556: CALL_OW 250
16560: PPUSH
16561: LD_VAR 0 1
16565: PUSH
16566: LD_INT 1
16568: ARRAY
16569: PPUSH
16570: CALL_OW 251
16574: PPUSH
16575: LD_INT 70
16577: PPUSH
16578: CALL_OW 495
// end ;
16582: PPOPN 1
16584: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16585: LD_EXP 29
16589: PUSH
16590: LD_EXP 63
16594: AND
16595: IFFALSE 16806
16597: GO 16599
16599: DISABLE
16600: LD_INT 0
16602: PPUSH
16603: PPUSH
16604: PPUSH
16605: PPUSH
16606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16607: LD_ADDR_VAR 0 5
16611: PUSH
16612: LD_INT 22
16614: PUSH
16615: LD_OWVAR 2
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: LD_INT 21
16626: PUSH
16627: LD_INT 1
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: PPUSH
16638: CALL_OW 69
16642: ST_TO_ADDR
// if not tmp then
16643: LD_VAR 0 5
16647: NOT
16648: IFFALSE 16652
// exit ;
16650: GO 16806
// for i in tmp do
16652: LD_ADDR_VAR 0 1
16656: PUSH
16657: LD_VAR 0 5
16661: PUSH
16662: FOR_IN
16663: IFFALSE 16804
// begin d := rand ( 0 , 5 ) ;
16665: LD_ADDR_VAR 0 4
16669: PUSH
16670: LD_INT 0
16672: PPUSH
16673: LD_INT 5
16675: PPUSH
16676: CALL_OW 12
16680: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16681: LD_ADDR_VAR 0 2
16685: PUSH
16686: LD_VAR 0 1
16690: PPUSH
16691: CALL_OW 250
16695: PPUSH
16696: LD_VAR 0 4
16700: PPUSH
16701: LD_INT 3
16703: PPUSH
16704: LD_INT 12
16706: PPUSH
16707: CALL_OW 12
16711: PPUSH
16712: CALL_OW 272
16716: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16717: LD_ADDR_VAR 0 3
16721: PUSH
16722: LD_VAR 0 1
16726: PPUSH
16727: CALL_OW 251
16731: PPUSH
16732: LD_VAR 0 4
16736: PPUSH
16737: LD_INT 3
16739: PPUSH
16740: LD_INT 12
16742: PPUSH
16743: CALL_OW 12
16747: PPUSH
16748: CALL_OW 273
16752: ST_TO_ADDR
// if ValidHex ( x , y ) then
16753: LD_VAR 0 2
16757: PPUSH
16758: LD_VAR 0 3
16762: PPUSH
16763: CALL_OW 488
16767: IFFALSE 16802
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16769: LD_VAR 0 1
16773: PPUSH
16774: LD_VAR 0 2
16778: PPUSH
16779: LD_VAR 0 3
16783: PPUSH
16784: LD_INT 3
16786: PPUSH
16787: LD_INT 6
16789: PPUSH
16790: CALL_OW 12
16794: PPUSH
16795: LD_INT 1
16797: PPUSH
16798: CALL_OW 483
// end ;
16802: GO 16662
16804: POP
16805: POP
// end ;
16806: PPOPN 5
16808: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16809: LD_EXP 29
16813: PUSH
16814: LD_EXP 64
16818: AND
16819: IFFALSE 16913
16821: GO 16823
16823: DISABLE
16824: LD_INT 0
16826: PPUSH
16827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16828: LD_ADDR_VAR 0 2
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_OWVAR 2
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: PUSH
16845: LD_INT 32
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 21
16857: PUSH
16858: LD_INT 2
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: LIST
16869: PPUSH
16870: CALL_OW 69
16874: ST_TO_ADDR
// if not tmp then
16875: LD_VAR 0 2
16879: NOT
16880: IFFALSE 16884
// exit ;
16882: GO 16913
// for i in tmp do
16884: LD_ADDR_VAR 0 1
16888: PUSH
16889: LD_VAR 0 2
16893: PUSH
16894: FOR_IN
16895: IFFALSE 16911
// SetFuel ( i , 0 ) ;
16897: LD_VAR 0 1
16901: PPUSH
16902: LD_INT 0
16904: PPUSH
16905: CALL_OW 240
16909: GO 16894
16911: POP
16912: POP
// end ;
16913: PPOPN 2
16915: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16916: LD_EXP 29
16920: PUSH
16921: LD_EXP 65
16925: AND
16926: IFFALSE 16992
16928: GO 16930
16930: DISABLE
16931: LD_INT 0
16933: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16934: LD_ADDR_VAR 0 1
16938: PUSH
16939: LD_INT 22
16941: PUSH
16942: LD_OWVAR 2
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: LD_INT 30
16953: PUSH
16954: LD_INT 29
16956: PUSH
16957: EMPTY
16958: LIST
16959: LIST
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL_OW 69
16969: ST_TO_ADDR
// if not tmp then
16970: LD_VAR 0 1
16974: NOT
16975: IFFALSE 16979
// exit ;
16977: GO 16992
// DestroyUnit ( tmp [ 1 ] ) ;
16979: LD_VAR 0 1
16983: PUSH
16984: LD_INT 1
16986: ARRAY
16987: PPUSH
16988: CALL_OW 65
// end ;
16992: PPOPN 1
16994: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16995: LD_EXP 29
16999: PUSH
17000: LD_EXP 67
17004: AND
17005: IFFALSE 17134
17007: GO 17009
17009: DISABLE
17010: LD_INT 0
17012: PPUSH
// begin uc_side := 0 ;
17013: LD_ADDR_OWVAR 20
17017: PUSH
17018: LD_INT 0
17020: ST_TO_ADDR
// uc_nation := nation_arabian ;
17021: LD_ADDR_OWVAR 21
17025: PUSH
17026: LD_INT 2
17028: ST_TO_ADDR
// hc_gallery :=  ;
17029: LD_ADDR_OWVAR 33
17033: PUSH
17034: LD_STRING 
17036: ST_TO_ADDR
// hc_name :=  ;
17037: LD_ADDR_OWVAR 26
17041: PUSH
17042: LD_STRING 
17044: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
17045: LD_INT 1
17047: PPUSH
17048: LD_INT 11
17050: PPUSH
17051: LD_INT 10
17053: PPUSH
17054: CALL_OW 380
// un := CreateHuman ;
17058: LD_ADDR_VAR 0 1
17062: PUSH
17063: CALL_OW 44
17067: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17068: LD_VAR 0 1
17072: PPUSH
17073: LD_INT 1
17075: PPUSH
17076: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17080: LD_INT 35
17082: PPUSH
17083: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17087: LD_VAR 0 1
17091: PPUSH
17092: LD_INT 22
17094: PUSH
17095: LD_OWVAR 2
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 69
17108: PPUSH
17109: LD_VAR 0 1
17113: PPUSH
17114: CALL_OW 74
17118: PPUSH
17119: CALL_OW 115
// until IsDead ( un ) ;
17123: LD_VAR 0 1
17127: PPUSH
17128: CALL_OW 301
17132: IFFALSE 17080
// end ;
17134: PPOPN 1
17136: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
17137: LD_EXP 29
17141: PUSH
17142: LD_EXP 69
17146: AND
17147: IFFALSE 17159
17149: GO 17151
17151: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
17152: LD_STRING earthquake(getX(game), 0, 32)
17154: PPUSH
17155: CALL_OW 559
17159: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
17160: LD_EXP 29
17164: PUSH
17165: LD_EXP 70
17169: AND
17170: IFFALSE 17261
17172: GO 17174
17174: DISABLE
17175: LD_INT 0
17177: PPUSH
// begin enable ;
17178: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
17179: LD_ADDR_VAR 0 1
17183: PUSH
17184: LD_INT 22
17186: PUSH
17187: LD_OWVAR 2
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 21
17198: PUSH
17199: LD_INT 2
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: PUSH
17206: LD_INT 33
17208: PUSH
17209: LD_INT 3
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: LIST
17220: PPUSH
17221: CALL_OW 69
17225: ST_TO_ADDR
// if not tmp then
17226: LD_VAR 0 1
17230: NOT
17231: IFFALSE 17235
// exit ;
17233: GO 17261
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: PPUSH
17243: LD_VAR 0 1
17247: PPUSH
17248: CALL_OW 12
17252: ARRAY
17253: PPUSH
17254: LD_INT 1
17256: PPUSH
17257: CALL_OW 234
// end ;
17261: PPOPN 1
17263: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17264: LD_EXP 29
17268: PUSH
17269: LD_EXP 71
17273: AND
17274: IFFALSE 17415
17276: GO 17278
17278: DISABLE
17279: LD_INT 0
17281: PPUSH
17282: PPUSH
17283: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17284: LD_ADDR_VAR 0 3
17288: PUSH
17289: LD_INT 22
17291: PUSH
17292: LD_OWVAR 2
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 1
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: PPUSH
17315: CALL_OW 69
17319: ST_TO_ADDR
// if not tmp then
17320: LD_VAR 0 3
17324: NOT
17325: IFFALSE 17329
// exit ;
17327: GO 17415
// un := tmp [ rand ( 1 , tmp ) ] ;
17329: LD_ADDR_VAR 0 2
17333: PUSH
17334: LD_VAR 0 3
17338: PUSH
17339: LD_INT 1
17341: PPUSH
17342: LD_VAR 0 3
17346: PPUSH
17347: CALL_OW 12
17351: ARRAY
17352: ST_TO_ADDR
// if Crawls ( un ) then
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 318
17362: IFFALSE 17373
// ComWalk ( un ) ;
17364: LD_VAR 0 2
17368: PPUSH
17369: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17373: LD_VAR 0 2
17377: PPUSH
17378: LD_INT 9
17380: PPUSH
17381: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17385: LD_INT 28
17387: PPUSH
17388: LD_OWVAR 2
17392: PPUSH
17393: LD_INT 2
17395: PPUSH
17396: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17400: LD_INT 29
17402: PPUSH
17403: LD_OWVAR 2
17407: PPUSH
17408: LD_INT 2
17410: PPUSH
17411: CALL_OW 322
// end ;
17415: PPOPN 3
17417: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17418: LD_EXP 29
17422: PUSH
17423: LD_EXP 72
17427: AND
17428: IFFALSE 17539
17430: GO 17432
17432: DISABLE
17433: LD_INT 0
17435: PPUSH
17436: PPUSH
17437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17438: LD_ADDR_VAR 0 3
17442: PUSH
17443: LD_INT 22
17445: PUSH
17446: LD_OWVAR 2
17450: PUSH
17451: EMPTY
17452: LIST
17453: LIST
17454: PUSH
17455: LD_INT 25
17457: PUSH
17458: LD_INT 1
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: PUSH
17465: EMPTY
17466: LIST
17467: LIST
17468: PPUSH
17469: CALL_OW 69
17473: ST_TO_ADDR
// if not tmp then
17474: LD_VAR 0 3
17478: NOT
17479: IFFALSE 17483
// exit ;
17481: GO 17539
// un := tmp [ rand ( 1 , tmp ) ] ;
17483: LD_ADDR_VAR 0 2
17487: PUSH
17488: LD_VAR 0 3
17492: PUSH
17493: LD_INT 1
17495: PPUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: CALL_OW 12
17505: ARRAY
17506: ST_TO_ADDR
// if Crawls ( un ) then
17507: LD_VAR 0 2
17511: PPUSH
17512: CALL_OW 318
17516: IFFALSE 17527
// ComWalk ( un ) ;
17518: LD_VAR 0 2
17522: PPUSH
17523: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17527: LD_VAR 0 2
17531: PPUSH
17532: LD_INT 8
17534: PPUSH
17535: CALL_OW 336
// end ;
17539: PPOPN 3
17541: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17542: LD_EXP 29
17546: PUSH
17547: LD_EXP 73
17551: AND
17552: IFFALSE 17696
17554: GO 17556
17556: DISABLE
17557: LD_INT 0
17559: PPUSH
17560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17561: LD_ADDR_VAR 0 2
17565: PUSH
17566: LD_INT 22
17568: PUSH
17569: LD_OWVAR 2
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: PUSH
17578: LD_INT 21
17580: PUSH
17581: LD_INT 2
17583: PUSH
17584: EMPTY
17585: LIST
17586: LIST
17587: PUSH
17588: LD_INT 2
17590: PUSH
17591: LD_INT 34
17593: PUSH
17594: LD_INT 12
17596: PUSH
17597: EMPTY
17598: LIST
17599: LIST
17600: PUSH
17601: LD_INT 34
17603: PUSH
17604: LD_INT 51
17606: PUSH
17607: EMPTY
17608: LIST
17609: LIST
17610: PUSH
17611: LD_INT 34
17613: PUSH
17614: LD_INT 32
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: PUSH
17621: EMPTY
17622: LIST
17623: LIST
17624: LIST
17625: LIST
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: LIST
17631: PPUSH
17632: CALL_OW 69
17636: ST_TO_ADDR
// if not tmp then
17637: LD_VAR 0 2
17641: NOT
17642: IFFALSE 17646
// exit ;
17644: GO 17696
// for i in tmp do
17646: LD_ADDR_VAR 0 1
17650: PUSH
17651: LD_VAR 0 2
17655: PUSH
17656: FOR_IN
17657: IFFALSE 17694
// if GetCargo ( i , mat_artifact ) = 0 then
17659: LD_VAR 0 1
17663: PPUSH
17664: LD_INT 4
17666: PPUSH
17667: CALL_OW 289
17671: PUSH
17672: LD_INT 0
17674: EQUAL
17675: IFFALSE 17692
// SetCargo ( i , mat_siberit , 100 ) ;
17677: LD_VAR 0 1
17681: PPUSH
17682: LD_INT 3
17684: PPUSH
17685: LD_INT 100
17687: PPUSH
17688: CALL_OW 290
17692: GO 17656
17694: POP
17695: POP
// end ;
17696: PPOPN 2
17698: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17699: LD_EXP 29
17703: PUSH
17704: LD_EXP 74
17708: AND
17709: IFFALSE 17862
17711: GO 17713
17713: DISABLE
17714: LD_INT 0
17716: PPUSH
17717: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17718: LD_ADDR_VAR 0 2
17722: PUSH
17723: LD_INT 22
17725: PUSH
17726: LD_OWVAR 2
17730: PUSH
17731: EMPTY
17732: LIST
17733: LIST
17734: PPUSH
17735: CALL_OW 69
17739: ST_TO_ADDR
// if not tmp then
17740: LD_VAR 0 2
17744: NOT
17745: IFFALSE 17749
// exit ;
17747: GO 17862
// for i := 1 to 2 do
17749: LD_ADDR_VAR 0 1
17753: PUSH
17754: DOUBLE
17755: LD_INT 1
17757: DEC
17758: ST_TO_ADDR
17759: LD_INT 2
17761: PUSH
17762: FOR_TO
17763: IFFALSE 17860
// begin uc_side := your_side ;
17765: LD_ADDR_OWVAR 20
17769: PUSH
17770: LD_OWVAR 2
17774: ST_TO_ADDR
// uc_nation := nation_american ;
17775: LD_ADDR_OWVAR 21
17779: PUSH
17780: LD_INT 1
17782: ST_TO_ADDR
// vc_chassis := us_morphling ;
17783: LD_ADDR_OWVAR 37
17787: PUSH
17788: LD_INT 5
17790: ST_TO_ADDR
// vc_engine := engine_siberite ;
17791: LD_ADDR_OWVAR 39
17795: PUSH
17796: LD_INT 3
17798: ST_TO_ADDR
// vc_control := control_computer ;
17799: LD_ADDR_OWVAR 38
17803: PUSH
17804: LD_INT 3
17806: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17807: LD_ADDR_OWVAR 40
17811: PUSH
17812: LD_INT 10
17814: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17815: CALL_OW 45
17819: PPUSH
17820: LD_VAR 0 2
17824: PUSH
17825: LD_INT 1
17827: ARRAY
17828: PPUSH
17829: CALL_OW 250
17833: PPUSH
17834: LD_VAR 0 2
17838: PUSH
17839: LD_INT 1
17841: ARRAY
17842: PPUSH
17843: CALL_OW 251
17847: PPUSH
17848: LD_INT 12
17850: PPUSH
17851: LD_INT 1
17853: PPUSH
17854: CALL_OW 50
// end ;
17858: GO 17762
17860: POP
17861: POP
// end ;
17862: PPOPN 2
17864: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17865: LD_EXP 29
17869: PUSH
17870: LD_EXP 75
17874: AND
17875: IFFALSE 18097
17877: GO 17879
17879: DISABLE
17880: LD_INT 0
17882: PPUSH
17883: PPUSH
17884: PPUSH
17885: PPUSH
17886: PPUSH
17887: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17888: LD_ADDR_VAR 0 6
17892: PUSH
17893: LD_INT 22
17895: PUSH
17896: LD_OWVAR 2
17900: PUSH
17901: EMPTY
17902: LIST
17903: LIST
17904: PUSH
17905: LD_INT 21
17907: PUSH
17908: LD_INT 1
17910: PUSH
17911: EMPTY
17912: LIST
17913: LIST
17914: PUSH
17915: LD_INT 3
17917: PUSH
17918: LD_INT 23
17920: PUSH
17921: LD_INT 0
17923: PUSH
17924: EMPTY
17925: LIST
17926: LIST
17927: PUSH
17928: EMPTY
17929: LIST
17930: LIST
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: PPUSH
17937: CALL_OW 69
17941: ST_TO_ADDR
// if not tmp then
17942: LD_VAR 0 6
17946: NOT
17947: IFFALSE 17951
// exit ;
17949: GO 18097
// s1 := rand ( 1 , 4 ) ;
17951: LD_ADDR_VAR 0 2
17955: PUSH
17956: LD_INT 1
17958: PPUSH
17959: LD_INT 4
17961: PPUSH
17962: CALL_OW 12
17966: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17967: LD_ADDR_VAR 0 4
17971: PUSH
17972: LD_VAR 0 6
17976: PUSH
17977: LD_INT 1
17979: ARRAY
17980: PPUSH
17981: LD_VAR 0 2
17985: PPUSH
17986: CALL_OW 259
17990: ST_TO_ADDR
// if s1 = 1 then
17991: LD_VAR 0 2
17995: PUSH
17996: LD_INT 1
17998: EQUAL
17999: IFFALSE 18019
// s2 := rand ( 2 , 4 ) else
18001: LD_ADDR_VAR 0 3
18005: PUSH
18006: LD_INT 2
18008: PPUSH
18009: LD_INT 4
18011: PPUSH
18012: CALL_OW 12
18016: ST_TO_ADDR
18017: GO 18027
// s2 := 1 ;
18019: LD_ADDR_VAR 0 3
18023: PUSH
18024: LD_INT 1
18026: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
18027: LD_ADDR_VAR 0 5
18031: PUSH
18032: LD_VAR 0 6
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: LD_VAR 0 3
18045: PPUSH
18046: CALL_OW 259
18050: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
18051: LD_VAR 0 6
18055: PUSH
18056: LD_INT 1
18058: ARRAY
18059: PPUSH
18060: LD_VAR 0 2
18064: PPUSH
18065: LD_VAR 0 5
18069: PPUSH
18070: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
18074: LD_VAR 0 6
18078: PUSH
18079: LD_INT 1
18081: ARRAY
18082: PPUSH
18083: LD_VAR 0 3
18087: PPUSH
18088: LD_VAR 0 4
18092: PPUSH
18093: CALL_OW 237
// end ;
18097: PPOPN 6
18099: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
18100: LD_EXP 29
18104: PUSH
18105: LD_EXP 76
18109: AND
18110: IFFALSE 18189
18112: GO 18114
18114: DISABLE
18115: LD_INT 0
18117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
18118: LD_ADDR_VAR 0 1
18122: PUSH
18123: LD_INT 22
18125: PUSH
18126: LD_OWVAR 2
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PUSH
18135: LD_INT 30
18137: PUSH
18138: LD_INT 3
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: PPUSH
18149: CALL_OW 69
18153: ST_TO_ADDR
// if not tmp then
18154: LD_VAR 0 1
18158: NOT
18159: IFFALSE 18163
// exit ;
18161: GO 18189
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18163: LD_VAR 0 1
18167: PUSH
18168: LD_INT 1
18170: PPUSH
18171: LD_VAR 0 1
18175: PPUSH
18176: CALL_OW 12
18180: ARRAY
18181: PPUSH
18182: LD_INT 1
18184: PPUSH
18185: CALL_OW 234
// end ;
18189: PPOPN 1
18191: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
18192: LD_EXP 29
18196: PUSH
18197: LD_EXP 77
18201: AND
18202: IFFALSE 18314
18204: GO 18206
18206: DISABLE
18207: LD_INT 0
18209: PPUSH
18210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_INT 22
18218: PUSH
18219: LD_OWVAR 2
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: PUSH
18228: LD_INT 2
18230: PUSH
18231: LD_INT 30
18233: PUSH
18234: LD_INT 27
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: LD_INT 30
18243: PUSH
18244: LD_INT 26
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PUSH
18251: LD_INT 30
18253: PUSH
18254: LD_INT 28
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: PUSH
18261: EMPTY
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PPUSH
18271: CALL_OW 69
18275: ST_TO_ADDR
// if not tmp then
18276: LD_VAR 0 2
18280: NOT
18281: IFFALSE 18285
// exit ;
18283: GO 18314
// for i in tmp do
18285: LD_ADDR_VAR 0 1
18289: PUSH
18290: LD_VAR 0 2
18294: PUSH
18295: FOR_IN
18296: IFFALSE 18312
// SetLives ( i , 1 ) ;
18298: LD_VAR 0 1
18302: PPUSH
18303: LD_INT 1
18305: PPUSH
18306: CALL_OW 234
18310: GO 18295
18312: POP
18313: POP
// end ;
18314: PPOPN 2
18316: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18317: LD_EXP 29
18321: PUSH
18322: LD_EXP 78
18326: AND
18327: IFFALSE 18601
18329: GO 18331
18331: DISABLE
18332: LD_INT 0
18334: PPUSH
18335: PPUSH
18336: PPUSH
// begin i := rand ( 1 , 7 ) ;
18337: LD_ADDR_VAR 0 1
18341: PUSH
18342: LD_INT 1
18344: PPUSH
18345: LD_INT 7
18347: PPUSH
18348: CALL_OW 12
18352: ST_TO_ADDR
// case i of 1 :
18353: LD_VAR 0 1
18357: PUSH
18358: LD_INT 1
18360: DOUBLE
18361: EQUAL
18362: IFTRUE 18366
18364: GO 18376
18366: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18367: LD_STRING earthquake(getX(game), 0, 32)
18369: PPUSH
18370: CALL_OW 559
18374: GO 18601
18376: LD_INT 2
18378: DOUBLE
18379: EQUAL
18380: IFTRUE 18384
18382: GO 18398
18384: POP
// begin ToLua ( displayStucuk(); ) ;
18385: LD_STRING displayStucuk();
18387: PPUSH
18388: CALL_OW 559
// ResetFog ;
18392: CALL_OW 335
// end ; 3 :
18396: GO 18601
18398: LD_INT 3
18400: DOUBLE
18401: EQUAL
18402: IFTRUE 18406
18404: GO 18510
18406: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18407: LD_ADDR_VAR 0 2
18411: PUSH
18412: LD_INT 22
18414: PUSH
18415: LD_OWVAR 2
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PUSH
18424: LD_INT 25
18426: PUSH
18427: LD_INT 1
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: PPUSH
18438: CALL_OW 69
18442: ST_TO_ADDR
// if not tmp then
18443: LD_VAR 0 2
18447: NOT
18448: IFFALSE 18452
// exit ;
18450: GO 18601
// un := tmp [ rand ( 1 , tmp ) ] ;
18452: LD_ADDR_VAR 0 3
18456: PUSH
18457: LD_VAR 0 2
18461: PUSH
18462: LD_INT 1
18464: PPUSH
18465: LD_VAR 0 2
18469: PPUSH
18470: CALL_OW 12
18474: ARRAY
18475: ST_TO_ADDR
// if Crawls ( un ) then
18476: LD_VAR 0 3
18480: PPUSH
18481: CALL_OW 318
18485: IFFALSE 18496
// ComWalk ( un ) ;
18487: LD_VAR 0 3
18491: PPUSH
18492: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18496: LD_VAR 0 3
18500: PPUSH
18501: LD_INT 8
18503: PPUSH
18504: CALL_OW 336
// end ; 4 :
18508: GO 18601
18510: LD_INT 4
18512: DOUBLE
18513: EQUAL
18514: IFTRUE 18518
18516: GO 18579
18518: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18519: LD_ADDR_VAR 0 2
18523: PUSH
18524: LD_INT 22
18526: PUSH
18527: LD_OWVAR 2
18531: PUSH
18532: EMPTY
18533: LIST
18534: LIST
18535: PUSH
18536: LD_INT 30
18538: PUSH
18539: LD_INT 29
18541: PUSH
18542: EMPTY
18543: LIST
18544: LIST
18545: PUSH
18546: EMPTY
18547: LIST
18548: LIST
18549: PPUSH
18550: CALL_OW 69
18554: ST_TO_ADDR
// if not tmp then
18555: LD_VAR 0 2
18559: NOT
18560: IFFALSE 18564
// exit ;
18562: GO 18601
// DestroyUnit ( tmp [ 1 ] ) ;
18564: LD_VAR 0 2
18568: PUSH
18569: LD_INT 1
18571: ARRAY
18572: PPUSH
18573: CALL_OW 65
// end ; 5 .. 7 :
18577: GO 18601
18579: LD_INT 5
18581: DOUBLE
18582: GREATEREQUAL
18583: IFFALSE 18591
18585: LD_INT 7
18587: DOUBLE
18588: LESSEQUAL
18589: IFTRUE 18593
18591: GO 18600
18593: POP
// StreamSibBomb ; end ;
18594: CALL 14881 0 0
18598: GO 18601
18600: POP
// end ;
18601: PPOPN 3
18603: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18604: LD_EXP 29
18608: PUSH
18609: LD_EXP 79
18613: AND
18614: IFFALSE 18770
18616: GO 18618
18618: DISABLE
18619: LD_INT 0
18621: PPUSH
18622: PPUSH
18623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18624: LD_ADDR_VAR 0 2
18628: PUSH
18629: LD_INT 81
18631: PUSH
18632: LD_OWVAR 2
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 2
18643: PUSH
18644: LD_INT 21
18646: PUSH
18647: LD_INT 1
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: PUSH
18654: LD_INT 21
18656: PUSH
18657: LD_INT 2
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: LIST
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: PPUSH
18673: CALL_OW 69
18677: ST_TO_ADDR
// if not tmp then
18678: LD_VAR 0 2
18682: NOT
18683: IFFALSE 18687
// exit ;
18685: GO 18770
// p := 0 ;
18687: LD_ADDR_VAR 0 3
18691: PUSH
18692: LD_INT 0
18694: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18695: LD_INT 35
18697: PPUSH
18698: CALL_OW 67
// p := p + 1 ;
18702: LD_ADDR_VAR 0 3
18706: PUSH
18707: LD_VAR 0 3
18711: PUSH
18712: LD_INT 1
18714: PLUS
18715: ST_TO_ADDR
// for i in tmp do
18716: LD_ADDR_VAR 0 1
18720: PUSH
18721: LD_VAR 0 2
18725: PUSH
18726: FOR_IN
18727: IFFALSE 18758
// if GetLives ( i ) < 1000 then
18729: LD_VAR 0 1
18733: PPUSH
18734: CALL_OW 256
18738: PUSH
18739: LD_INT 1000
18741: LESS
18742: IFFALSE 18756
// SetLives ( i , 1000 ) ;
18744: LD_VAR 0 1
18748: PPUSH
18749: LD_INT 1000
18751: PPUSH
18752: CALL_OW 234
18756: GO 18726
18758: POP
18759: POP
// until p > 20 ;
18760: LD_VAR 0 3
18764: PUSH
18765: LD_INT 20
18767: GREATER
18768: IFFALSE 18695
// end ;
18770: PPOPN 3
18772: END
// every 0 0$1 trigger StreamModeActive and sTime do
18773: LD_EXP 29
18777: PUSH
18778: LD_EXP 80
18782: AND
18783: IFFALSE 18818
18785: GO 18787
18787: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18788: LD_INT 28
18790: PPUSH
18791: LD_OWVAR 2
18795: PPUSH
18796: LD_INT 2
18798: PPUSH
18799: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18803: LD_INT 30
18805: PPUSH
18806: LD_OWVAR 2
18810: PPUSH
18811: LD_INT 2
18813: PPUSH
18814: CALL_OW 322
// end ;
18818: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18819: LD_EXP 29
18823: PUSH
18824: LD_EXP 81
18828: AND
18829: IFFALSE 18950
18831: GO 18833
18833: DISABLE
18834: LD_INT 0
18836: PPUSH
18837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18838: LD_ADDR_VAR 0 2
18842: PUSH
18843: LD_INT 22
18845: PUSH
18846: LD_OWVAR 2
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: LD_INT 21
18857: PUSH
18858: LD_INT 1
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: LD_INT 3
18867: PUSH
18868: LD_INT 23
18870: PUSH
18871: LD_INT 0
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not tmp then
18892: LD_VAR 0 2
18896: NOT
18897: IFFALSE 18901
// exit ;
18899: GO 18950
// for i in tmp do
18901: LD_ADDR_VAR 0 1
18905: PUSH
18906: LD_VAR 0 2
18910: PUSH
18911: FOR_IN
18912: IFFALSE 18948
// begin if Crawls ( i ) then
18914: LD_VAR 0 1
18918: PPUSH
18919: CALL_OW 318
18923: IFFALSE 18934
// ComWalk ( i ) ;
18925: LD_VAR 0 1
18929: PPUSH
18930: CALL_OW 138
// SetClass ( i , 2 ) ;
18934: LD_VAR 0 1
18938: PPUSH
18939: LD_INT 2
18941: PPUSH
18942: CALL_OW 336
// end ;
18946: GO 18911
18948: POP
18949: POP
// end ;
18950: PPOPN 2
18952: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18953: LD_EXP 29
18957: PUSH
18958: LD_EXP 82
18962: AND
18963: IFFALSE 19184
18965: GO 18967
18967: DISABLE
18968: LD_INT 0
18970: PPUSH
18971: PPUSH
18972: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18973: LD_OWVAR 2
18977: PPUSH
18978: LD_INT 9
18980: PPUSH
18981: LD_INT 1
18983: PPUSH
18984: LD_INT 1
18986: PPUSH
18987: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18991: LD_INT 9
18993: PPUSH
18994: LD_OWVAR 2
18998: PPUSH
18999: CALL_OW 343
// uc_side := 9 ;
19003: LD_ADDR_OWVAR 20
19007: PUSH
19008: LD_INT 9
19010: ST_TO_ADDR
// uc_nation := 2 ;
19011: LD_ADDR_OWVAR 21
19015: PUSH
19016: LD_INT 2
19018: ST_TO_ADDR
// hc_name := Dark Warrior ;
19019: LD_ADDR_OWVAR 26
19023: PUSH
19024: LD_STRING Dark Warrior
19026: ST_TO_ADDR
// hc_gallery :=  ;
19027: LD_ADDR_OWVAR 33
19031: PUSH
19032: LD_STRING 
19034: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
19035: LD_INT 1
19037: PPUSH
19038: LD_INT 1
19040: PPUSH
19041: LD_INT 10
19043: PPUSH
19044: CALL_OW 380
// un := CreateHuman ;
19048: LD_ADDR_VAR 0 3
19052: PUSH
19053: CALL_OW 44
19057: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19058: LD_VAR 0 3
19062: PPUSH
19063: LD_INT 1
19065: PPUSH
19066: CALL_OW 51
// p := 0 ;
19070: LD_ADDR_VAR 0 2
19074: PUSH
19075: LD_INT 0
19077: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19078: LD_INT 35
19080: PPUSH
19081: CALL_OW 67
// if GetLives ( un ) < 1000 then
19085: LD_VAR 0 3
19089: PPUSH
19090: CALL_OW 256
19094: PUSH
19095: LD_INT 1000
19097: LESS
19098: IFFALSE 19112
// SetLives ( un , 1000 ) ;
19100: LD_VAR 0 3
19104: PPUSH
19105: LD_INT 1000
19107: PPUSH
19108: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
19112: LD_VAR 0 3
19116: PPUSH
19117: LD_INT 81
19119: PUSH
19120: LD_OWVAR 2
19124: PUSH
19125: EMPTY
19126: LIST
19127: LIST
19128: PPUSH
19129: CALL_OW 69
19133: PPUSH
19134: LD_VAR 0 3
19138: PPUSH
19139: CALL_OW 74
19143: PPUSH
19144: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
19148: LD_VAR 0 2
19152: PUSH
19153: LD_INT 60
19155: GREATER
19156: PUSH
19157: LD_VAR 0 3
19161: PPUSH
19162: CALL_OW 301
19166: OR
19167: IFFALSE 19078
// if un then
19169: LD_VAR 0 3
19173: IFFALSE 19184
// RemoveUnit ( un ) ;
19175: LD_VAR 0 3
19179: PPUSH
19180: CALL_OW 64
// end ; end_of_file
19184: PPOPN 3
19186: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
19187: LD_INT 0
19189: PPUSH
19190: PPUSH
19191: PPUSH
19192: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19193: LD_VAR 0 1
19197: PPUSH
19198: CALL_OW 264
19202: PUSH
19203: LD_EXP 28
19207: EQUAL
19208: IFFALSE 19280
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19210: LD_INT 68
19212: PPUSH
19213: LD_VAR 0 1
19217: PPUSH
19218: CALL_OW 255
19222: PPUSH
19223: CALL_OW 321
19227: PUSH
19228: LD_INT 2
19230: EQUAL
19231: IFFALSE 19243
// eff := 70 else
19233: LD_ADDR_VAR 0 6
19237: PUSH
19238: LD_INT 70
19240: ST_TO_ADDR
19241: GO 19251
// eff := 30 ;
19243: LD_ADDR_VAR 0 6
19247: PUSH
19248: LD_INT 30
19250: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19251: LD_VAR 0 1
19255: PPUSH
19256: CALL_OW 250
19260: PPUSH
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 251
19270: PPUSH
19271: LD_VAR 0 6
19275: PPUSH
19276: CALL_OW 495
// end ; end ;
19280: LD_VAR 0 4
19284: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
19285: LD_INT 0
19287: PPUSH
19288: PPUSH
19289: PPUSH
19290: PPUSH
19291: PPUSH
19292: PPUSH
// if cmd = 124 then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 124
19300: EQUAL
19301: IFFALSE 19507
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
19303: LD_ADDR_VAR 0 5
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 34
19313: PUSH
19314: LD_INT 53
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 34
19323: PUSH
19324: LD_INT 14
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PPUSH
19336: CALL_OW 69
19340: ST_TO_ADDR
// if not tmp then
19341: LD_VAR 0 5
19345: NOT
19346: IFFALSE 19350
// exit ;
19348: GO 19507
// for i in tmp do
19350: LD_ADDR_VAR 0 3
19354: PUSH
19355: LD_VAR 0 5
19359: PUSH
19360: FOR_IN
19361: IFFALSE 19505
// begin taskList := GetTaskList ( i ) ;
19363: LD_ADDR_VAR 0 6
19367: PUSH
19368: LD_VAR 0 3
19372: PPUSH
19373: CALL_OW 437
19377: ST_TO_ADDR
// if not taskList then
19378: LD_VAR 0 6
19382: NOT
19383: IFFALSE 19387
// continue ;
19385: GO 19360
// for j = 1 to taskList do
19387: LD_ADDR_VAR 0 4
19391: PUSH
19392: DOUBLE
19393: LD_INT 1
19395: DEC
19396: ST_TO_ADDR
19397: LD_VAR 0 6
19401: PUSH
19402: FOR_TO
19403: IFFALSE 19501
// if taskList [ j ] [ 1 ] = | then
19405: LD_VAR 0 6
19409: PUSH
19410: LD_VAR 0 4
19414: ARRAY
19415: PUSH
19416: LD_INT 1
19418: ARRAY
19419: PUSH
19420: LD_STRING |
19422: EQUAL
19423: IFFALSE 19499
// begin _taskList := Delete ( taskList , 1 ) ;
19425: LD_ADDR_VAR 0 7
19429: PUSH
19430: LD_VAR 0 6
19434: PPUSH
19435: LD_INT 1
19437: PPUSH
19438: CALL_OW 3
19442: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
19443: LD_VAR 0 3
19447: PPUSH
19448: LD_VAR 0 7
19452: PPUSH
19453: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
19457: LD_VAR 0 3
19461: PPUSH
19462: LD_VAR 0 6
19466: PUSH
19467: LD_VAR 0 4
19471: ARRAY
19472: PUSH
19473: LD_INT 2
19475: ARRAY
19476: PPUSH
19477: LD_VAR 0 6
19481: PUSH
19482: LD_VAR 0 4
19486: ARRAY
19487: PUSH
19488: LD_INT 3
19490: ARRAY
19491: PPUSH
19492: LD_INT 8
19494: PPUSH
19495: CALL 19512 0 4
// end ;
19499: GO 19402
19501: POP
19502: POP
// end ;
19503: GO 19360
19505: POP
19506: POP
// end ; end ;
19507: LD_VAR 0 2
19511: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19512: LD_INT 0
19514: PPUSH
19515: PPUSH
19516: PPUSH
19517: PPUSH
19518: PPUSH
19519: PPUSH
19520: PPUSH
19521: PPUSH
19522: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19523: LD_VAR 0 1
19527: NOT
19528: PUSH
19529: LD_VAR 0 2
19533: PPUSH
19534: LD_VAR 0 3
19538: PPUSH
19539: CALL_OW 488
19543: NOT
19544: OR
19545: PUSH
19546: LD_VAR 0 4
19550: NOT
19551: OR
19552: IFFALSE 19556
// exit ;
19554: GO 19896
// list := [ ] ;
19556: LD_ADDR_VAR 0 13
19560: PUSH
19561: EMPTY
19562: ST_TO_ADDR
// if x - r < 0 then
19563: LD_VAR 0 2
19567: PUSH
19568: LD_VAR 0 4
19572: MINUS
19573: PUSH
19574: LD_INT 0
19576: LESS
19577: IFFALSE 19589
// min_x := 0 else
19579: LD_ADDR_VAR 0 7
19583: PUSH
19584: LD_INT 0
19586: ST_TO_ADDR
19587: GO 19605
// min_x := x - r ;
19589: LD_ADDR_VAR 0 7
19593: PUSH
19594: LD_VAR 0 2
19598: PUSH
19599: LD_VAR 0 4
19603: MINUS
19604: ST_TO_ADDR
// if y - r < 0 then
19605: LD_VAR 0 3
19609: PUSH
19610: LD_VAR 0 4
19614: MINUS
19615: PUSH
19616: LD_INT 0
19618: LESS
19619: IFFALSE 19631
// min_y := 0 else
19621: LD_ADDR_VAR 0 8
19625: PUSH
19626: LD_INT 0
19628: ST_TO_ADDR
19629: GO 19647
// min_y := y - r ;
19631: LD_ADDR_VAR 0 8
19635: PUSH
19636: LD_VAR 0 3
19640: PUSH
19641: LD_VAR 0 4
19645: MINUS
19646: ST_TO_ADDR
// max_x := x + r ;
19647: LD_ADDR_VAR 0 9
19651: PUSH
19652: LD_VAR 0 2
19656: PUSH
19657: LD_VAR 0 4
19661: PLUS
19662: ST_TO_ADDR
// max_y := y + r ;
19663: LD_ADDR_VAR 0 10
19667: PUSH
19668: LD_VAR 0 3
19672: PUSH
19673: LD_VAR 0 4
19677: PLUS
19678: ST_TO_ADDR
// for _x = min_x to max_x do
19679: LD_ADDR_VAR 0 11
19683: PUSH
19684: DOUBLE
19685: LD_VAR 0 7
19689: DEC
19690: ST_TO_ADDR
19691: LD_VAR 0 9
19695: PUSH
19696: FOR_TO
19697: IFFALSE 19814
// for _y = min_y to max_y do
19699: LD_ADDR_VAR 0 12
19703: PUSH
19704: DOUBLE
19705: LD_VAR 0 8
19709: DEC
19710: ST_TO_ADDR
19711: LD_VAR 0 10
19715: PUSH
19716: FOR_TO
19717: IFFALSE 19810
// begin if not ValidHex ( _x , _y ) then
19719: LD_VAR 0 11
19723: PPUSH
19724: LD_VAR 0 12
19728: PPUSH
19729: CALL_OW 488
19733: NOT
19734: IFFALSE 19738
// continue ;
19736: GO 19716
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19738: LD_VAR 0 11
19742: PPUSH
19743: LD_VAR 0 12
19747: PPUSH
19748: CALL_OW 351
19752: PUSH
19753: LD_VAR 0 11
19757: PPUSH
19758: LD_VAR 0 12
19762: PPUSH
19763: CALL_OW 554
19767: AND
19768: IFFALSE 19808
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19770: LD_ADDR_VAR 0 13
19774: PUSH
19775: LD_VAR 0 13
19779: PPUSH
19780: LD_VAR 0 13
19784: PUSH
19785: LD_INT 1
19787: PLUS
19788: PPUSH
19789: LD_VAR 0 11
19793: PUSH
19794: LD_VAR 0 12
19798: PUSH
19799: EMPTY
19800: LIST
19801: LIST
19802: PPUSH
19803: CALL_OW 2
19807: ST_TO_ADDR
// end ;
19808: GO 19716
19810: POP
19811: POP
19812: GO 19696
19814: POP
19815: POP
// if not list then
19816: LD_VAR 0 13
19820: NOT
19821: IFFALSE 19825
// exit ;
19823: GO 19896
// for i in list do
19825: LD_ADDR_VAR 0 6
19829: PUSH
19830: LD_VAR 0 13
19834: PUSH
19835: FOR_IN
19836: IFFALSE 19894
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
19838: LD_VAR 0 1
19842: PPUSH
19843: LD_STRING M
19845: PUSH
19846: LD_VAR 0 6
19850: PUSH
19851: LD_INT 1
19853: ARRAY
19854: PUSH
19855: LD_VAR 0 6
19859: PUSH
19860: LD_INT 2
19862: ARRAY
19863: PUSH
19864: LD_INT 0
19866: PUSH
19867: LD_INT 0
19869: PUSH
19870: LD_INT 0
19872: PUSH
19873: LD_INT 0
19875: PUSH
19876: EMPTY
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: PUSH
19885: EMPTY
19886: LIST
19887: PPUSH
19888: CALL_OW 447
19892: GO 19835
19894: POP
19895: POP
// end ;
19896: LD_VAR 0 5
19900: RET
